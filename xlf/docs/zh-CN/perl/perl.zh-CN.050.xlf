<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="55a77b36211d3d02a45104bff8d76788cd986acc" translate="yes" xml:space="preserve">
          <source>You can get commercial support of Perl if you wish, although for most users the informal support will more than suffice. See the answer to &quot;Where can I buy a commercial version of Perl?&quot; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83877e131c38375e988c7edf4defa59ad28286ba" translate="yes" xml:space="preserve">
          <source>You can get gzip from &lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc7caff36ea8191fb948cb25382a0802d8b70e3" translate="yes" xml:space="preserve">
          <source>You can get gzip from &lt;a href=&quot;http://www.s390.ibm.com/products/oe/bpxqp1.html&quot;&gt;http://www.s390.ibm.com/products/oe/bpxqp1.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb45063df183ed03ff063ebe2021495fbb9baff" translate="yes" xml:space="preserve">
          <source>You can get into trouble if you use constants in a context which automatically quotes barewords (as is true for any subroutine call). For example, you can't say &lt;code&gt;$hash{CONSTANT}&lt;/code&gt; because &lt;code&gt;CONSTANT&lt;/code&gt; will be interpreted as a string. Use &lt;code&gt;$hash{CONSTANT()}&lt;/code&gt; or &lt;code&gt;$hash{+CONSTANT}&lt;/code&gt; to prevent the bareword quoting mechanism from kicking in. Similarly, since the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator quotes a bareword immediately to its left, you have to say &lt;code&gt;CONSTANT() =&amp;gt; 'value'&lt;/code&gt; (or simply use a comma in place of the big arrow) instead of &lt;code&gt;CONSTANT =&amp;gt; 'value'&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6872803f70582536909b7aa8df4da94cd4d37a4" translate="yes" xml:space="preserve">
          <source>You can have an environment variable PERL_INSTALL_ROOT set which will be prepended as a directory to each installed file (and directory).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa58ede728fa900b2be53c5925b3b4ff8069c044" translate="yes" xml:space="preserve">
          <source>You can ignore [pad]THXx when browsing the Perl headers/sources. Those are strictly for use within the core. Extensions and embedders need only be aware of [pad]THX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a479cb9681a1cb4f6cbb2bcf71ac6471f5092e" translate="yes" xml:space="preserve">
          <source>You can imagine how bad things would be if, for example, the SYS$MANAGER or SYS$SYSTEM logical names were deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2157dc8c06b7685edcc449748ab0e77243e5a157" translate="yes" xml:space="preserve">
          <source>You can immediately see a slightly different focus to the subroutine profiling modules, and we start to see exactly which line of code is taking the most time. That regex line is looking a bit suspicious, for example. Remember that these tools are supposed to be used together, there is no single best way to profile your code, you need to use the best tools for the job.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ccbef4b59df5e513c51a0c19924a7a01e4981e" translate="yes" xml:space="preserve">
          <source>You can import &lt;code&gt;:pushpop&lt;/code&gt; and maintain a stack of colors using PUSHCOLOR, POPCOLOR, and LOCALCOLOR. PUSHCOLOR takes the attribute string that starts its argument and pushes it onto a stack of attributes. POPCOLOR removes the top of the stack and restores the previous attributes set by the argument of a prior PUSHCOLOR. LOCALCOLOR surrounds its argument in a PUSHCOLOR and POPCOLOR so that the color resets afterward.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7225c37bbdccefc8a70c019da87c9b8dea7a6b29" translate="yes" xml:space="preserve">
          <source>You can import all the great circle formulas by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ccdd2eb8d7e6ad6ca52482a2893e8ad5920726c" translate="yes" xml:space="preserve">
          <source>You can import radial coordinate conversion functions by using the &lt;code&gt;:radial&lt;/code&gt; tag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a747eb56defc25ea65ac8c773f590bb69f4cf6d4" translate="yes" xml:space="preserve">
          <source>You can import symbolic mode constants (&lt;code&gt;S_IF*&lt;/code&gt; ) and functions (&lt;code&gt;S_IS*&lt;/code&gt; ) from the Fcntl module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c8f6c731717afeb2f914b548c9389d16df04b0" translate="yes" xml:space="preserve">
          <source>You can include one underscore between any two digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06780cff3747acdd27c6cb36674311a1b2286d47" translate="yes" xml:space="preserve">
          <source>You can instead write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4bd7d42db9b74a8aac6c0368becb036004d4652" translate="yes" xml:space="preserve">
          <source>You can intermix &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; matches with &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\G.../g&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;\G&lt;/code&gt; is a zero-width assertion that matches the exact position where the previous &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;, if any, left off. Without the &lt;code&gt;/g&lt;/code&gt; modifier, the &lt;code&gt;\G&lt;/code&gt; assertion still anchors at &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as it was at the start of the operation (see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;), but the match is of course only attempted once. Using &lt;code&gt;\G&lt;/code&gt; without &lt;code&gt;/g&lt;/code&gt; on a target string that has not previously had a &lt;code&gt;/g&lt;/code&gt; match applied to it is the same as using the &lt;code&gt;\A&lt;/code&gt; assertion to match the beginning of the string. Note also that, currently, &lt;code&gt;\G&lt;/code&gt; is only properly supported when anchored at the very beginning of the pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b86b2d839c827310b20f3c55919cf18f3acb03" translate="yes" xml:space="preserve">
          <source>You can inversely compute the destination if you know the starting point, direction, and distance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfc74f0d7463fa46580b22cd874ca59538b399a" translate="yes" xml:space="preserve">
          <source>You can list opcodes by names, or use a tag name; see &lt;a href=&quot;opcode#Predefined-Opcode-Tags&quot;&gt;Predefined Opcode Tags in Opcode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="001468774175cba071073df8732faf49990cd65b" translate="yes" xml:space="preserve">
          <source>You can load a custom &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Parser::Formatter&quot;&gt;TAP::Parser::Formatter&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97cc72d3ba21acacd11a8df6beb891397824853a" translate="yes" xml:space="preserve">
          <source>You can load custom &lt;a href=&quot;tap/parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s, to change the way the parser interprets particular</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="864c8cc598c8e4c08f636d6accb98e4216dd8dc6" translate="yes" xml:space="preserve">
          <source>You can log in to the bug tracking system and comment on existing bug reports. If you have additional information regarding an existing bug, please add it. This will help the porters fix the bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b967da2737530b2ccb33fdb14ce4b355858a95" translate="yes" xml:space="preserve">
          <source>You can look into using the &lt;code&gt;DB_File&lt;/code&gt; module and &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie()&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;$DB_BTREE&lt;/code&gt; hash bindings as documented in &lt;a href=&quot;db_file#In-Memory-Databases&quot;&gt;In Memory Databases in DB_File&lt;/a&gt;. The &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt; module from CPAN might also be instructive. Although this does keep your hash sorted, you might not like the slowdown you suffer from the tie interface. Are you sure you need to do this? :)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03c6c46e2fd91fc95b867e10fbdca9429550351" translate="yes" xml:space="preserve">
          <source>You can make references to anything, including scalars, functions, and other references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f238aab29e64ee5c9b032d4d04c0ab30c79c6501" translate="yes" xml:space="preserve">
          <source>You can make the while loop a lot shorter with this suggestion from Benjamin Goldberg:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec5f2b2db5f7957e7b186e607473a4a56ae2fd0" translate="yes" xml:space="preserve">
          <source>You can make your configuration changes permanent by calling the command &lt;code&gt;o conf commit&lt;/code&gt; . Alternatively set the &lt;code&gt;auto_commit&lt;/code&gt; variable to true by running &lt;code&gt;o conf init auto_commit&lt;/code&gt; and answering the following question with yes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2011dcb658fe55c431da3ed5067e6f4bf4528970" translate="yes" xml:space="preserve">
          <source>You can mimic class subtraction using lookahead. For example, what UTS#18 might write as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3461cd371c3715543776c435145f8478a0ac6ec8" translate="yes" xml:space="preserve">
          <source>You can mock TTY input to debugger by adding arbitrary commands to @DB::typeahead. For example, your</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9cef6663d4cd69a19179eacb290a6dcc1e8352" translate="yes" xml:space="preserve">
          <source>You can modify &lt;code&gt;@ARGV&lt;/code&gt; before the first &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as long as the array ends up containing the list of filenames you really want. Line numbers (&lt;code&gt;$.&lt;/code&gt; ) continue as though the input were one big happy file. See the example in &lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt; for how to reset line numbers on each file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8a419c4027fffc2a00680692cdd50042e9d07e" translate="yes" xml:space="preserve">
          <source>You can modify the 'commands' for example to hardwire an absolute path by e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de41be22b6a5efcacf396fbce08b0572f97fd60" translate="yes" xml:space="preserve">
          <source>You can only declare autoties for types &lt;code&gt;&quot;SCALAR&quot;&lt;/code&gt; , &lt;code&gt;&quot;ARRAY&quot;&lt;/code&gt; , and &lt;code&gt;&quot;HASH&quot;&lt;/code&gt; . They're the only things (apart from typeglobs -- which are not declarable) that Perl can tie.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d6492d8d5c8ebf50c4b6f0278c97639e62301c" translate="yes" xml:space="preserve">
          <source>You can only obtain this using an alias, and Getopt::Long of at least version 2.13.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce5924582aac2aa9ee7cd1ad99c9e8ff1e6ecea" translate="yes" xml:space="preserve">
          <source>You can only use the elliptical statement to stand in for a complete statement. These examples of how the ellipsis works:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cae8654bfe063f888826b48470927a2c30f96cd" translate="yes" xml:space="preserve">
          <source>You can open a file for input or output using the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function. It's documented in extravagant detail in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;, but in short:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce96504bc4965bb9a6b5d98ed74131b7aef0ff79" translate="yes" xml:space="preserve">
          <source>You can override predefined aliases by simply applying define_alias(). The new alias is always evaluated first, and when necessary, define_alias() flushes the internal cache to make the new definition available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef785435f6086fb9fd6b00d9def6f92017001719" translate="yes" xml:space="preserve">
          <source>You can override the default and build a shared libperl if you wish (Configure ... -Duseshrplib).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ed2e27db33bd8f090672fcd70380db3caec730" translate="yes" xml:space="preserve">
          <source>You can override this by giving extra arguments; see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f74d7cb907a2b7504c7060b4ad0ec87a6506fe" translate="yes" xml:space="preserve">
          <source>You can override this by passing the desired rounding mode as parameter to &lt;code&gt;as_number()&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b4dbfc185a430ad159257351a9ef1b4f3e946a" translate="yes" xml:space="preserve">
          <source>You can pass an argument to your plugin by appending an &lt;code&gt;=&lt;/code&gt; after the plugin name, eg &lt;code&gt;-PMyPlugin=foo&lt;/code&gt; . You can pass multiple arguments using commas:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577ba47f8467272240629f611eeec9e04fdaf1e6" translate="yes" xml:space="preserve">
          <source>You can pass arguments to your plugin by appending &lt;code&gt;=arg1,arg2,etc&lt;/code&gt; to the plugin name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b26d7e57483cd1ed4bf2659755481a3ca93653" translate="yes" xml:space="preserve">
          <source>You can pick up prebuilt binaries for Solaris from &lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt;, &lt;a href=&quot;http://www.blastwave.org&quot;&gt;http://www.blastwave.org&lt;/a&gt;, ActiveState &lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt;, and &lt;a href=&quot;http://www.perl.com/&quot;&gt;http://www.perl.com/&lt;/a&gt; under the Binaries list at the top of the page. There are probably other sources as well. Please note that these sites are under the control of their respective owners, not the perl developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afad181efc494d271a3d1339fc4bea9100125dd3" translate="yes" xml:space="preserve">
          <source>You can preallocate space for a hash by assigning to the keys() function. This rounds up the allocated buckets to the next power of two:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ece78405c91977c16dd3a742419b856c5fd5394" translate="yes" xml:space="preserve">
          <source>You can probably expect your users to be able to guess that they can request less CPU or memory or just &quot;less&quot; overall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb56a3e59af78b8d5da4daff16effef12d060e2" translate="yes" xml:space="preserve">
          <source>You can provide this layer when &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;ing the file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d0d59bd2621cca1e6ec0d854420947ec5a4ec5" translate="yes" xml:space="preserve">
          <source>You can put a &lt;code&gt;+&lt;/code&gt; in front of the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; to indicate that you want both read and write access to the file; thus &lt;code&gt;+&amp;lt;&lt;/code&gt; is almost always preferred for read/write updates--the &lt;code&gt;+&amp;gt;&lt;/code&gt; mode would clobber the file first. You can't usually use either read-write mode for updating textfiles, since they have variable-length records. See the &lt;b&gt;-i&lt;/b&gt; switch in &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt; for a better approach. The file is created with permissions of &lt;code&gt;0666&lt;/code&gt; modified by the process's &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c78cfaaebb70f40ad0f93e0301fba4283c243b" translate="yes" xml:space="preserve">
          <source>You can put a &lt;code&gt;+&lt;/code&gt; in front of the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; to indicate that you want both read and write access to the file; thus &lt;code&gt;+&amp;lt;&lt;/code&gt; is almost always preferred for read/write updates--the &lt;code&gt;+&amp;gt;&lt;/code&gt; mode would clobber the file first. You can't usually use either read-write mode for updating textfiles, since they have variable-length records. See the &lt;b&gt;-i&lt;/b&gt; switch in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for a better approach. The file is created with permissions of &lt;code&gt;0666&lt;/code&gt; modified by the process's &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8c4f9eec7c5f71cbfe88cf0f5ec847885d12d2" translate="yes" xml:space="preserve">
          <source>You can put any backslash sequence character class (with the exception of &lt;code&gt;\N&lt;/code&gt; and &lt;code&gt;\R&lt;/code&gt; ) inside a bracketed character class, and it will act just as if you had put all characters matched by the backslash sequence inside the character class. For instance, &lt;code&gt;[a-f\d]&lt;/code&gt; matches any decimal digit, or any of the lowercase letters between 'a' and 'f' inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88a6953f485e8c5fc3aeb601fd219de754900f0" translate="yes" xml:space="preserve">
          <source>You can read from an open filehandle using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. In scalar context it reads a single line from the filehandle, and in list context it reads the whole file in, assigning each line to an element of the list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ab2ef6e453973e41443b71f9d3e34175e99630" translate="yes" xml:space="preserve">
          <source>You can read more about profiling in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f2324bbf3536a80f241b597db331417bcbe8c1" translate="yes" xml:space="preserve">
          <source>You can redistribute and/or modify this document under the same terms as Perl itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7dc0e1fc9ad5b87e77bf63d3f4081648cdf49ca" translate="yes" xml:space="preserve">
          <source>You can request that the flock() constants (LOCK_SH, LOCK_EX, LOCK_NB and LOCK_UN) be provided by using the tag &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f4701466ab8780e7a2b0e9f2a17e8d0b7017d5" translate="yes" xml:space="preserve">
          <source>You can request that the old constants (FAPPEND, FASYNC, FCREAT, FDEFER, FEXCL, FNDELAY, FNONBLOCK, FSYNC, FTRUNC) be provided for compatibility reasons by using the tag &lt;code&gt;:Fcompat&lt;/code&gt; . For new applications the newer versions of these constants are suggested (O_APPEND, O_ASYNC, O_CREAT, O_DEFER, O_EXCL, O_NDELAY, O_NONBLOCK, O_SYNC, O_TRUNC).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caaaaed5194349d7e53889bf69ba7c88d167c7d9" translate="yes" xml:space="preserve">
          <source>You can reset this cache by assigning an empty hashref to it, or individually remove keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4fc671bd928d082df8dcbc4d77c81ac14538200" translate="yes" xml:space="preserve">
          <source>You can retrieve the result via -&amp;gt;data but usually you don't have to because the stringify operator (&quot;&quot;) is overridden to do exactly that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc6861c31e761832a97f33e3f90e04d306eb3ee" translate="yes" xml:space="preserve">
          <source>You can return the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5203f3ceab8b6b9bc7b6ca2deddcda6d494d3e9" translate="yes" xml:space="preserve">
          <source>You can run a command in the background with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92356e98ca4379f9b92a2bcc41db6e953218853" translate="yes" xml:space="preserve">
          <source>You can run all the tests with the following commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab3a450deb8a8c4cd405b2e23f88d23efbbf2ec" translate="yes" xml:space="preserve">
          <source>You can run an individual test by a command similar to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7019e534322025bbdc3a56a0ada6decc0fac6688" translate="yes" xml:space="preserve">
          <source>You can run into similar problems when you store &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; or &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; into AVs or HVs. Trying to modify such elements will give you the following error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a3f2e45a171b8580b9277e027aa9cbf304aecf" translate="yes" xml:space="preserve">
          <source>You can run part of the test suite by hand by using one of the following commands from the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9677002a55994cfb79edd644465223dc6f275627" translate="yes" xml:space="preserve">
          <source>You can safely ignore the line about &quot;prototyping behavior&quot; - it is explained in &lt;a href=&quot;perlxs#The-PROTOTYPES%3a-Keyword&quot;&gt;The PROTOTYPES: Keyword in perlxs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00bbb0e9f9b7d267fed175221358a00b2882f0e8" translate="yes" xml:space="preserve">
          <source>You can safely replace &lt;code&gt;isa&lt;/code&gt; with &lt;code&gt;DOES&lt;/code&gt; (although the converse is not true).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c22b7008ae62adff98ca02982c07c25fd7ebcc" translate="yes" xml:space="preserve">
          <source>You can say &lt;code&gt;*foo{PACKAGE}&lt;/code&gt; and &lt;code&gt;*foo{NAME}&lt;/code&gt; to find out what name and package the *foo symbol table entry comes from. This may be useful in a subroutine that gets passed typeglobs as arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1966e0b952d6a25db96c9f73b3f341a3e54cf712" translate="yes" xml:space="preserve">
          <source>You can say &lt;code&gt;BEGIN { $Exporter::Verbose=1 }&lt;/code&gt; to see how the specifications are being processed and what is actually being imported into modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ffa8d04bb2be838b7be17e141561b51ef27dbcb" translate="yes" xml:space="preserve">
          <source>You can search CPAN on &lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="decda746759f350cc820cd1383e913824bf2e767" translate="yes" xml:space="preserve">
          <source>You can search for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; related bug reports at &lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/&lt;/a&gt;. If needed submit any new bugs, problems, patches, etc. to: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=threads&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=threads&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802f6c1f9273b694e1c0cdbd6edb66de5f11d6b4" translate="yes" xml:space="preserve">
          <source>You can see from the above that the effect of &lt;code&gt;unicode_strings&lt;/code&gt; increased over several Perl releases. (And Perl's support for Unicode continues to improve; it's best to use the latest available release in order to get the most complete and accurate results possible.) Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically chosen if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169f5a8ded36f882f89340ed4481186781ecd0dd" translate="yes" xml:space="preserve">
          <source>You can see this with the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30453af312489e18bd58825504c04b5c3c816c5" translate="yes" xml:space="preserve">
          <source>You can see whether your Perl was built with PerlIO by running &lt;code&gt;perl -V&lt;/code&gt; and looking for the &lt;code&gt;useperlio=&lt;/code&gt; line. If &lt;code&gt;useperlio&lt;/code&gt; is &lt;code&gt;define&lt;/code&gt; , you have PerlIO; otherwise you don't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d64238a1676682fd78cc68f5aa21599974d313a" translate="yes" xml:space="preserve">
          <source>You can see which (or neither) threading flavour you have by running &lt;code&gt;perl -V&lt;/code&gt; and looking at the &lt;code&gt;Platform&lt;/code&gt; section. If you have &lt;code&gt;useithreads=define&lt;/code&gt; you have ithreads, if you have &lt;code&gt;use5005threads=define&lt;/code&gt; you have 5.005 threads. If you have neither, you don't have any thread support built in. If you have both, you are in trouble.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc1d6869249a32d7f829c0b3a5e051d9383488b" translate="yes" xml:space="preserve">
          <source>You can see why the arrows are important. Without them, we would have had to write &lt;code&gt;${$a[1]}[2]&lt;/code&gt; instead of &lt;code&gt;$a[1][2]&lt;/code&gt; . For three-dimensional arrays, they let us write &lt;code&gt;$x[2][3][5]&lt;/code&gt; instead of the unreadable &lt;code&gt;${${$x[2]}[3]}[5]&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46ad3852d414e337d72bbed36bfa27c57b29adc" translate="yes" xml:space="preserve">
          <source>You can set and query each of these options interactively in the cpan shell with the &lt;code&gt;o conf&lt;/code&gt; or the &lt;code&gt;o conf init&lt;/code&gt; command as specified below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16508b3f102bc9307eda4b040c0235215ac4aad7" translate="yes" xml:space="preserve">
          <source>You can set the &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; elements to set the POSIX realtime signal handlers, use &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; on the elements, and use &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; on the &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; to find out how many POSIX realtime signals there are available &lt;code&gt;(SIGRTMAX - SIGRTMIN + 1&lt;/code&gt; , the &lt;code&gt;SIGRTMAX&lt;/code&gt; is a valid POSIX realtime signal).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6da332e187deef2beadbe770ab6beeaee593c3" translate="yes" xml:space="preserve">
          <source>You can set the values of the &lt;code&gt;%SIG&lt;/code&gt; hash to be the functions you want to handle the signal. After perl catches the signal, it looks in &lt;code&gt;%SIG&lt;/code&gt; for a key with the same name as the signal, then calls the subroutine value for that key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee1469992dc1b9c8f0b603349904e7ab865deb8" translate="yes" xml:space="preserve">
          <source>You can set the variable &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 1, if you want to force File::Find to always stat directories. This was used for file systems that do not have an &lt;code&gt;nlink&lt;/code&gt; count matching the number of sub-directories. Examples are ISO-9660 (CD-ROM), AFS, HPFS (OS/2 file system), FAT (DOS file system) and a couple of others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5472b025e4a5169aacbf87f4ca700aef907769b9" translate="yes" xml:space="preserve">
          <source>You can set these attributes on the parser object before you call &lt;code&gt;parse_file&lt;/code&gt; (or a similar method) on it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11091c76638b6f543204cac0351812864021173" translate="yes" xml:space="preserve">
          <source>You can set these with cereg.exe, a (remote) registry editor or via the PerlIDE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45d7d92f838159f25ad37c4eba92cfbf985fe7f" translate="yes" xml:space="preserve">
          <source>You can set this in your &lt;code&gt;CPAN.pm&lt;/code&gt; configuration so modules automatically install in your private library directory when you use the CPAN.pm shell:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30390221c1f07dd9de6ff3b92b3e83f72d1fc24c" translate="yes" xml:space="preserve">
          <source>You can sometimes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db7fa33c434550059625aa8e8d2392ae86f8c71" translate="yes" xml:space="preserve">
          <source>You can specify a character class, by enclosing a list of characters in &lt;code&gt;[]&lt;/code&gt; , which will match any character from the list. If the first character after the &quot;[&quot; is &quot;^&quot;, the class matches any character not in the list. Within a list, the &quot;-&quot; character specifies a range, so that &lt;code&gt;a-z&lt;/code&gt; represents all characters between &quot;a&quot; and &quot;z&quot;, inclusive. If you want either &quot;-&quot; or &quot;]&quot; itself to be a member of a class, put it at the start of the list (possibly after a &quot;^&quot;), or escape it with a backslash. &quot;-&quot; is also taken literally when it is at the end of the list, just before the closing &quot;]&quot;. (The following all specify the same class of three characters: &lt;code&gt;[-az]&lt;/code&gt; , &lt;code&gt;[az-]&lt;/code&gt; , and &lt;code&gt;[a\-z]&lt;/code&gt; . All are different from &lt;code&gt;[a-z]&lt;/code&gt; , which specifies a class containing twenty-six characters, even on EBCDIC-based character sets.) Also, if you try to use the character classes &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; , or &lt;code&gt;\D&lt;/code&gt; as endpoints of a range, the &quot;-&quot; is understood literally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26fab1522afd0e2727fdb333919185675d766a45" translate="yes" xml:space="preserve">
          <source>You can specify a precision (for numeric conversions) or a maximum width (for string conversions) by specifying a &lt;code&gt;.&lt;/code&gt; followed by a number. For floating-point formats except &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; , this specifies how many places right of the decimal point to show (the default being 6). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7117f36d5a9b63e0e2af83d4187313124e5bec9" translate="yes" xml:space="preserve">
          <source>You can specify a series of alternatives for a pattern using &quot;|&quot; to separate them, so that &lt;code&gt;fee|fie|foe&lt;/code&gt; will match any of &quot;fee&quot;, &quot;fie&quot;, or &quot;foe&quot; in the target string (as would &lt;code&gt;f(e|i|o)e&lt;/code&gt;). The first alternative includes everything from the last pattern delimiter (&quot;(&quot;, &quot;(?:&quot;, etc. or the beginning of the pattern) up to the first &quot;|&quot;, and the last alternative contains everything from the last &quot;|&quot; to the next closing pattern delimiter. That's why it's common practice to include alternatives in parentheses: to minimize confusion about where they start and end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0acf2a3cfcada005163c068fb15aa1f1ca963b" translate="yes" xml:space="preserve">
          <source>You can specify several classes to try by joining them with commas or semicolons, as in &lt;code&gt;-MTk::SuperPod;Tk::Pod&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1590cfec6710042ae4b201c340cadca79997b8f8" translate="yes" xml:space="preserve">
          <source>You can stop using AutoLoader by simply</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb2363990bc861a2294e72254c60f889449d2d6" translate="yes" xml:space="preserve">
          <source>You can switch encodings on an already opened stream by using &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;; see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4a77a592ef4f50bebb75551ecc777ec47349e4" translate="yes" xml:space="preserve">
          <source>You can switch locales as often as you wish at run time with the &lt;code&gt;POSIX::setlocale()&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35fb0ec3f2c6e87bec34d10cff3e1fa0aa39f99" translate="yes" xml:space="preserve">
          <source>You can test for these with Perl's &lt;b&gt;-S&lt;/b&gt; file test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33cabbc3e6b78a04641195c801755295c5b1770a" translate="yes" xml:space="preserve">
          <source>You can test out changing these variables temporarily, and if the new settings seem to help, put those settings into your shell startup files. Consult your local documentation for the exact details. For Bourne-like shells (&lt;b&gt;sh&lt;/b&gt;, &lt;b&gt;ksh&lt;/b&gt;, &lt;b&gt;bash&lt;/b&gt;, &lt;b&gt;zsh&lt;/b&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aef87ade0298c8e39a512c631e34755f8d99a1d" translate="yes" xml:space="preserve">
          <source>You can test whether an SV is using copy-on-write with &lt;code&gt;SvIsCOW(sv)&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7b765496cd5db87bb4e9bf905826761c1ac026" translate="yes" xml:space="preserve">
          <source>You can therefore save time by reusing this object as follows;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9025bea13f42c28d6d27d405ef555cfdfb67e0c5" translate="yes" xml:space="preserve">
          <source>You can think of &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; as a &lt;code&gt;typeof&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf104869dd9c15f6376b764dcf7d585d45ca8039" translate="yes" xml:space="preserve">
          <source>You can think of &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; as a &lt;code&gt;typeof&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728882433c08d9f5799a415b920db42fb16d9b1c" translate="yes" xml:space="preserve">
          <source>You can think of a module as the fundamental unit of reusable Perl code; see &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details. Whenever anyone creates a chunk of Perl code that they think will be useful to the world, they register as a Perl developer at &lt;a href=&quot;http://www.cpan.org/modules/04pause.html&quot;&gt;http://www.cpan.org/modules/04pause.html&lt;/a&gt; so that they can then upload their code to the CPAN. The CPAN is the Comprehensive Perl Archive Network and can be accessed at &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; , and searched at &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969f96d8ec4df0c71d177e6b1625408e665ae979" translate="yes" xml:space="preserve">
          <source>You can tie the cache tables to any sort of tied hash that you want to, as long as it supports &lt;code&gt;TIEHASH&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; , &lt;code&gt;STORE&lt;/code&gt; , and &lt;code&gt;EXISTS&lt;/code&gt; . For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dff5882ff33a85a3a95fb0e709084606bfc8485" translate="yes" xml:space="preserve">
          <source>You can try using encryption via source filters (Filter::* from CPAN, or Filter::Util::Call and Filter::Simple since Perl 5.8). But crackers might be able to decrypt it. You can try using the byte code compiler and interpreter described below, but crackers might be able to de-compile it. You can try using the native-code compiler described below, but crackers might be able to disassemble it. These pose varying degrees of difficulty to people wanting to get at your code, but none can definitively conceal it (this is true of every language, not just Perl).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd149095683892a2c8050e33a089a96e4ba58ba3" translate="yes" xml:space="preserve">
          <source>You can try using encryption via source filters (Starting from Perl 5.8 the Filter::Simple and Filter::Util::Call modules are included in the standard distribution), but any decent programmer will be able to decrypt it. You can try using the byte code compiler and interpreter described later in &lt;a href=&quot;perlfaq3&quot;&gt;perlfaq3&lt;/a&gt;, but the curious might still be able to de-compile it. You can try using the native-code compiler described later, but crackers might be able to disassemble it. These pose varying degrees of difficulty to people wanting to get at your code, but none can definitively conceal it (true of every language, not just Perl).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b09b812e89e288611a3620bc913b5b1b0fe4650" translate="yes" xml:space="preserve">
          <source>You can turn off that eagerness-to-help by declaring an attribute handler with the keyword &lt;code&gt;RAWDATA&lt;/code&gt; . For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5701868a13c5d43cf7a782ca599e3f4284f18bb" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#(%3f%23text)&quot;&gt;(?#text)&lt;/a&gt; to create a comment that ends earlier than the end of the current line, but &lt;code&gt;text&lt;/code&gt; also can't contain the closing delimiter unless escaped with a backslash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d944fb3215d0dd16d4105b924d26c8f26a00944" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; to find out if a given property is one which has a restricted set of values, and if so, what those values are. But usually each value actually has several synonyms. For example, in Unicode binary properties,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53d0563bc5da053955b9d3b7d437fbd188f8795" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number::Format&lt;/a&gt; to separate places in a number. It handles locale information for those of you who want to insert full stops instead (or anything else that they want to use, really).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f5dd665c5e9d2b71ecb4caa05c28940c8fc3d9" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;http://search.cpan.org/perldoc/URI::Find&quot;&gt;URI::Find&lt;/a&gt; to extract URLs from an arbitrary text document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe2956ea1b7c9e1e517ba013b7204dc28c702c8" translate="yes" xml:space="preserve">
          <source>You can use &lt;b&gt;-C0&lt;/b&gt; (or &lt;code&gt;&quot;0&quot;&lt;/code&gt; for &lt;code&gt;PERL_UNICODE&lt;/code&gt; ) to explicitly disable all the above Unicode features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8820cb36e9b0a2ef9812096c3ae47e4337e70f22" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;-w optionname&lt;/code&gt; (without a value) as shorthand for &lt;code&gt;-w optionname:&lt;i&gt;TRUE&lt;/i&gt;&lt;/code&gt;. This is presumably useful in cases of on/off features like: &lt;code&gt;-w page_numbering&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34722383d4a6c958172dfe61f02074274ede7a9" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without parentheses to locate the end of each input file, in case you want to append to each file, or reset line numbering (see example in &lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7509178f0cc142ffa6970d993aa78a311665535a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; if the columns are separated by whitespace or some other delimiter, as long as whitespace or the delimiter cannot appear as part of the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207bd81996c41f563d70786505a61f566bf7c9d1" translate="yes" xml:space="preserve">
          <source>You can use Andreas Koenig's CPAN module ( &lt;a href=&quot;http://www.cpan.org/modules/by-module/CPAN&quot;&gt;http://www.cpan.org/modules/by-module/CPAN&lt;/a&gt; ) to automate the following steps, from DECOMPRESS through INSTALL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4fa2e9a279c718478efb15dbd58f3963c395b2" translate="yes" xml:space="preserve">
          <source>You can use Perl's somewhat exotic &lt;code&gt;..&lt;/code&gt; operator (documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0352c7c82515615be31fde318d8a078c0a2c1a97" translate="yes" xml:space="preserve">
          <source>You can use a leading underscore to indicate that a variable or function should not be used outside the package that defined it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388231cbd33477282c1e5dc7ff7aa725ad26b114" translate="yes" xml:space="preserve">
          <source>You can use a string as if it were a reference. If you use the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; as an array reference, it's taken to be a reference to the array &lt;code&gt;@foo&lt;/code&gt; . This is called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc3bc3485dafe6de0835e8cb890731728d4f233" translate="yes" xml:space="preserve">
          <source>You can use an &quot;=&quot; instead of the &quot;:&quot;, as in: &lt;code&gt;-w textsize=15&lt;/code&gt; . This might be more (or less) convenient, depending on what shell you use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659b448e1309e418ec405468f01e562189ac5581" translate="yes" xml:space="preserve">
          <source>You can use an alternative library to drive Math::BigInt. See the section &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;MATH LIBRARY&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c7a81f2a96d58e5477ffb42832551e4a65a1ae" translate="yes" xml:space="preserve">
          <source>You can use and redistribute this document under the same terms as Perl itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02346143e059d2c6966f5b1da988acae6f664ce7" translate="yes" xml:space="preserve">
          <source>You can use another collation element table if desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ffd7e86ab2f265c3b1b5af5301c88022dfacbd" translate="yes" xml:space="preserve">
          <source>You can use any combination of the methods from none to all four.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727cc3b9105721ca57e170521deb86b9cfbaaa16" translate="yes" xml:space="preserve">
          <source>You can use any combination of the methods, from none, to all four.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf084acc213926a976c0b6e7b2d7ff58c8a1c98" translate="yes" xml:space="preserve">
          <source>You can use formatting codes in ordinary paragraphs, for &lt;b&gt;bold&lt;/b&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0f4d35c03dc40ee00f05e56f139894c4c251ca" translate="yes" xml:space="preserve">
          <source>You can use it as follows:</source>
          <target state="translated">您可以按以下方式使用它。</target>
        </trans-unit>
        <trans-unit id="cfbc7862683635b53050e53b7defa0eddc13b749" translate="yes" xml:space="preserve">
          <source>You can use more than one source filter on a single file. Similarly, you can reuse the same filter in as many files as you like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2c65d2dbc0740833a918a76d1bf6977975706a" translate="yes" xml:space="preserve">
          <source>You can use parentheses for functions' arguments or omit them according to your personal taste. They are only required occasionally to clarify issues of precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78045ec633e87e0c82678bcb8abea9b50b38e139" translate="yes" xml:space="preserve">
          <source>You can use that same structure to count the entries any way that you like. If you want the count of the keys with vowels in them, you just test for that instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264d904732b18badb8f8af0ee614fe938cb62fd3" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://search.cpan.org/perldoc/File::Random&quot;&gt;File::Random&lt;/a&gt; module which provides a function for that algorithm:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12dc43addaceb3325735b42235a5db7b043fe8e8" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ANSIScreen&quot;&gt;Term::ANSIScreen&lt;/a&gt; module to get the special sequence. Import the &lt;code&gt;cls&lt;/code&gt; function (or the &lt;code&gt;:screen&lt;/code&gt; tag):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e45dc25f4fd438a13c8ce07a9424e43bd367039" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Time::JulianDay&quot;&gt;Time::JulianDay&lt;/a&gt; module available on CPAN. Ensure that you really want to find a Julian day, though, as many people have different ideas about Julian days (see &lt;a href=&quot;http://www.hermetic.ch/cal_stud/jdn.htm&quot;&gt;http://www.hermetic.ch/cal_stud/jdn.htm&lt;/a&gt; for instance):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba1788ef1bedfa0514aebf9080742800f7823493" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module, part of the Standard Library, which can convert a date/time to a Julian Day:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19bff3f43fe0160ae5712a54b49b7225e08cf437" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; variable to detect if you are currently in the global destruction phase:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b01f73c25a67d7de0988508e3d6a08d549191f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keyword to fall through from one case to the next:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0512ec103381f142d5cd53ad55c41fe8a57f36b8" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $array[$idx]&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $hash{key}&lt;/code&gt; constructs to delete a composite type entry for the current block and restore it when it ends. They return the array/hash value before the localization, which means that they are respectively equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75c67446fa3d94c780e921da6acd4affb168a6f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; built-in function in scalar context to find out have many entries you have in a hash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a43fdc7d4ed02e813e0075b65927b5536f01d4" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; functions to reset &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;. To simply reset the iterator used by &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; without doing anything else, use one of them in void context:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91d95a3ba11b677c44eabfc4c39139686174c03a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;END&lt;/code&gt; block to simulate &lt;code&gt;atexit()&lt;/code&gt; . Each package's &lt;code&gt;END&lt;/code&gt; block is called when the program or thread ends. See the &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; manpage for more details about &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23320d34367d7c8e19c4f3b2648a39107aaceafc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;Text::Soundex&lt;/code&gt; module. If you want to do fuzzy or close matching, you might also try the &lt;a href=&quot;http://search.cpan.org/perldoc/String::Approx&quot;&gt;String::Approx&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Metaphone&quot;&gt;Text::Metaphone&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Text::DoubleMetaphone&quot;&gt;Text::DoubleMetaphone&lt;/a&gt; modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488d88c32abab4c7103bc8a9f7d995aca32467c4" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;UNIVERSAL&lt;/code&gt; class (see &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;). However, please be very careful to consider the consequences of doing this: adding methods to every object is very likely to have unintended consequences. If possible, it would be better to have all your object inherit from some common base class, or to use an object system like Moose that supports roles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e82c1f5d6a6827f8e16779cc47df9c04d7d8adc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;\[]&lt;/code&gt; backslash group notation to specify more than one allowed argument type. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a5b3337e458ba95bc1ff4b8a89d182c9528c72" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;break&lt;/code&gt; keyword to break out of the enclosing &lt;code&gt;given&lt;/code&gt; block. Every &lt;code&gt;when&lt;/code&gt; block is implicitly ended with a &lt;code&gt;break&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e6268ce8a22314d30cc236ac406a7320d8f9ec" translate="yes" xml:space="preserve">
          <source>You can use the Configure script in non-interactive mode too. When I built my</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88ac92f15e86bfef2bc330f6e37cbdfaa5d2949" translate="yes" xml:space="preserve">
          <source>You can use the POSIX character class syntax &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; documented in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e278d58c9ab507fbb7f9453e431896c65ad5fd6f" translate="yes" xml:space="preserve">
          <source>You can use the SDK by exporting some additions to Perl's 'ccflags' and '..flags' config variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcba1d434e18427e8484e54d9e14e5566e79c6d1" translate="yes" xml:space="preserve">
          <source>You can use the builtin &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc()&lt;/a&gt;&lt;/code&gt; function for most filehandles, but it won't (easily) work on a terminal device. For STDIN, either use the Term::ReadKey module from CPAN or use the sample code in &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad23301638fa59a074f7b5a830adc451b7882aec" translate="yes" xml:space="preserve">
          <source>You can use the debugger's &lt;code&gt;x&lt;/code&gt; command to dump out complex data structures. For example, given the assignment to $AoA above, here's the debugger output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c95e7176a4cdb8eb19d859ce523240b91e0d516f" translate="yes" xml:space="preserve">
          <source>You can use the following types of values for allow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce0a691bebd0b371247224bb7f78a55fdff48f0" translate="yes" xml:space="preserve">
          <source>You can use the four-argument form of sysread to continually add to a buffer. After you add to the buffer, you check if you have a complete line (using your regular expression).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da343e9c661b7d9b54a6aef1473ed8a755544823" translate="yes" xml:space="preserve">
          <source>You can use the shareware Winzip ( &lt;a href=&quot;http://www.winzip.com&quot;&gt;http://www.winzip.com&lt;/a&gt; ) to decompress and unpack modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29131242da6a21b6f2efd67a20aaa973ec754794" translate="yes" xml:space="preserve">
          <source>You can use the substitution operator to find pairs of characters (or runs of characters) and replace them with a single instance. In this substitution, we find a character in &lt;code&gt;(.)&lt;/code&gt;. The memory parentheses store the matched character in the back-reference &lt;code&gt;\g1&lt;/code&gt; and we use that to require that the same thing immediately follow it. We replace that part of the string with the character in &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56ec6ea26f22e6bec1d13c6dc597e46c1853d2d" translate="yes" xml:space="preserve">
          <source>You can use the substr() function as an lvalue, in which case EXPR must itself be an lvalue. If you assign something shorter than LENGTH, the string will shrink, and if you assign something longer than LENGTH, the string will grow to accommodate it. To keep the string the same length, you may need to pad or chop your value using &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5696279d1bd6b651a532c13cf176bc61670cde27" translate="yes" xml:space="preserve">
          <source>You can use the substr() function as an lvalue, in which case EXPR must itself be an lvalue. If you assign something shorter than LENGTH, the string will shrink, and if you assign something longer than LENGTH, the string will grow to accommodate it. To keep the string the same length, you may need to pad or chop your value using &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfeed36c7e84bfafbf0ea57f25867379b77f770c" translate="yes" xml:space="preserve">
          <source>You can use the tainted() function of the Scalar::Util module, available from CPAN (or included with Perl since release 5.8.0). See also &lt;a href=&quot;perlsec#Laundering-and-Detecting-Tainted-Data&quot;&gt;Laundering and Detecting Tainted Data in perlsec&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d2af0acba58841da7d114d861e093a90573f8a" translate="yes" xml:space="preserve">
          <source>You can use these macros if you call code that may croak, but you need to do some cleanup before giving control back to Perl. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d60246dfc629fa2c767c2383b114af7d8fad4bc" translate="yes" xml:space="preserve">
          <source>You can use this as a shortcut to determine whether &lt;code&gt;Archive::Tar&lt;/code&gt; will do what you think before passing compressed archives to its &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2583bc76f12f41a833e44f457c707f446ecc90f" translate="yes" xml:space="preserve">
          <source>You can use this class as the base class for a Pod formatter/processor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc269b809151a32259fd4bfb2f0eaf592a60142" translate="yes" xml:space="preserve">
          <source>You can use this subroutine to get and set the traversal mask for a specific hash. Setting the mask ensures that a given hash will produce the same key order. &lt;b&gt;Note&lt;/b&gt; that this does &lt;b&gt;not&lt;/b&gt; guarantee that &lt;b&gt;two&lt;/b&gt; hashes will produce the same key order for the same hash seed and traversal mask, items that collide into one bucket may have different orders regardless of this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e57a6a3e1ac0e576a34f1deb9cbe35e8438d88f" translate="yes" xml:space="preserve">
          <source>You can use this to find out whether two handles refer to the same underlying descriptor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f6df83e5ac1b378170dbde8b31e8b10cee41f6" translate="yes" xml:space="preserve">
          <source>You can use this to print out all the variables in a package, for instance. The standard but antiquated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6fe2602c37d36cd939b3f2966e9882c1457b54a" translate="yes" xml:space="preserve">
          <source>You can use whitespace and the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator to lay them out more nicely:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2d95bc6981ab5724b117c21adf2c42ff1324ac" translate="yes" xml:space="preserve">
          <source>You can watch Perl's regular expression engine at work to verify for yourself if Perl is recompiling a regular expression. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re
'debug'&lt;/code&gt; pragma (comes with Perl 5.005 and later) shows the details. With Perls before 5.6, you should see &lt;code&gt;re&lt;/code&gt; reporting that its compiling the regular expression on each iteration. With Perl 5.6 or later, you should only see &lt;code&gt;re&lt;/code&gt; report that for the first iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95a7534126966a35fdb290a82cc3eb90110d990" translate="yes" xml:space="preserve">
          <source>You can work around the first case by using the fully qualified name (&lt;code&gt;$Package::FOO&lt;/code&gt; ) where you need a local value, or by overriding it by saying &lt;code&gt;*FOO = *Package::FOO&lt;/code&gt; in your script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74896a00006c71879750ed85d659cbff45ee1a05" translate="yes" xml:space="preserve">
          <source>You can write this by hand or generate it with 'make manifest'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c2fce28dbd805f8d7a870a949b6c5834632bf2" translate="yes" xml:space="preserve">
          <source>You can write this more briefly using a grep, which does the same thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb98a8eca7d1aa69e5a0eb195e9e9713bd18c72" translate="yes" xml:space="preserve">
          <source>You can write your regular expressions just like someone on an ASCII platform would do. But keep in mind that using octal or hex notation to specify a particular code point will give you the character that the EBCDIC code page natively maps to it. (This is also true of all double-quoted strings.) If you want to write portably, just use the &lt;code&gt;\N{U+...}&lt;/code&gt; notation everywhere where you would have used &lt;code&gt;\x{...}&lt;/code&gt; , and don't use octal notation at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62834a834066a3093a80c93ec315493101e7f82e" translate="yes" xml:space="preserve">
          <source>You can't disambiguate that by saying &lt;code&gt;\{1}000&lt;/code&gt; , whereas you can fix it with &lt;code&gt;${1}000&lt;/code&gt;. The operation of interpolation should not be confused with the operation of matching a backreference. Certainly they mean two different things on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18683b4b76072abbee71a6881cdb8bc575df90f" translate="yes" xml:space="preserve">
          <source>You can't have a hash whose values are arrays; hash values can only be scalars. We're stuck with that. But a single reference can refer to an entire array, and references are scalars, so you can have a hash of references to arrays, and it'll act a lot like a hash of arrays, and it'll be just as useful as a hash of arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10d9e535268b6be7a5edad8c961bf0a3eba1a2f" translate="yes" xml:space="preserve">
          <source>You can't prevent people from sending your script bad data. Even if you add some client-side checks, people may disable them or bypass them completely. For instance, someone might use a module such as &lt;a href=&quot;http://search.cpan.org/perldoc/LWP&quot;&gt;LWP&lt;/a&gt; to submit to your web site. If you want to prevent data that try to use SQL injection or other sorts of attacks (and you should want to), you have to not trust any data that enter your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8673b45bcf51a92e5bbd4f8ac4117b4afa807acf" translate="yes" xml:space="preserve">
          <source>You can't produce a tied constant by giving a tied scalar as the value. References to tied variables, however, can be used as constants without any problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d171546c154312737dfd62e998eea96bcef04d" translate="yes" xml:space="preserve">
          <source>You can't store GLOB, FORMLINE, REGEXP, etc.... If you can define semantics for those operations, feel free to enhance Storable so that it can deal with them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c681bde3f10285d1065419cbcfdfe8d15a0638" translate="yes" xml:space="preserve">
          <source>You can't take the address of anything, although a similar operator in Perl is the backslash, which creates a reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d03f47a54efdf6a567386eabfcea4dcbcebbcab" translate="yes" xml:space="preserve">
          <source>You can't use a reference to an array or hash in quite the same way that you would a real array or hash. For C or C++ programmers unused to distinguishing between arrays and pointers to the same, this can be confusing. If so, just think of it as the difference between a structure and a pointer to a structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88b12efd9288b17ac8ba038151b3170bc987f73" translate="yes" xml:space="preserve">
          <source>You can't. Some use the UTF8 flag for this, but that's misuse, and makes well behaved modules like Data::Dumper look bad. The flag is useless for this purpose, because it's off when an 8 bit encoding (by default ISO-8859-1) is used to store the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fd8f1486a5edc4ee6dd1a50f986e5205ada1304" translate="yes" xml:space="preserve">
          <source>You can't. This is because UTF-8 data is stored in bytes just like non-UTF-8 data. The Unicode character 200, (&lt;code&gt;0xC8&lt;/code&gt; for you hex types) capital E with a grave accent, is represented by the two bytes &lt;code&gt;v196.172&lt;/code&gt; . Unfortunately, the non-Unicode string &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(196).chr(172)&lt;/a&gt;&lt;/code&gt; has that byte sequence as well. So you can't tell just by looking -- this is what makes Unicode input an interesting problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a4ed4ed782a30731e5ac82f99a95d222b188b0" translate="yes" xml:space="preserve">
          <source>You can't. You need to imitate the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; call (see &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for sample code) and then have a signal handler for the INT signal that passes the signal on to the subprocess. Or you can check for it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969f4cfd26924af3983dcc03e66552409285562e" translate="yes" xml:space="preserve">
          <source>You can, of course, declare separate handlers for these types as well (but you'll need to specify &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; warnings 'redefine'&lt;/code&gt; to do it quietly):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74374dec5e50007a2bb85f4a7c8771f4686fdade" translate="yes" xml:space="preserve">
          <source>You cannot Configure Perl to use long doubles unless you have at least Tru64 V5.0, the long double support simply wasn't functional enough before that. Perl's Configure will override attempts to use the long doubles (you can notice this by Configure finding out that the modfl() function does not work as it should).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8bdeec288ef204b43d051952afe1296036c485c" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;format_formfeed()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206c72a8b7cef7a32a6db021ff310a9ca6c22c22" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;format_line_break_characters()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be794aed40b9701358348d087034d06f390762c7" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;input_record_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9632f1b73e717ca255777fe1c2f39799e45e4a" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;output_field_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f3ec65172d98e67d60dc40971034bddc7747e9" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;output_record_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9134fa5f451fb01a8e6eeae9f39b7f5a89fc7ce" translate="yes" xml:space="preserve">
          <source>You cannot change the ordering once the database has been created. Thus you must use the same compare function every time you access the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e33a69a0160e97c284c6f83bf69b3911fb50910" translate="yes" xml:space="preserve">
          <source>You cannot currently get the precision from a specified number, but it is intended that this will be possible in the future, for example using &lt;code&gt;.*2$&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a19723c24ab74fcf1cad038cc364f2eed15903b" translate="yes" xml:space="preserve">
          <source>You cannot discern from mere inspection which builtins are unary operators (like chop() and chdir()) and which are list operators (like print() and unlink()). (Unless prototyped, user-defined subroutines can &lt;b&gt;only&lt;/b&gt; be list operators, never unary ones.) See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab137c3fb7d6e07844b33eb499911ea797677bd5" translate="yes" xml:space="preserve">
          <source>You cannot easily tie a multilevel data structure (such as a hash of hashes) to a dbm file. The first problem is that all but GDBM and Berkeley DB have size limitations, but beyond that, you also have problems with how references are to be represented on disk. One experimental module that does partially attempt to address this need is the MLDBM module. Check your nearest CPAN site as described in &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for source code to MLDBM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38213a95a75072574eb5ab9364f983653ee56ffc" translate="yes" xml:space="preserve">
          <source>You cannot easily tie a multilevel data structure (such as a hash of hashes) to a dbm file. The first problem is that all but GDBM and Berkeley DB have size limitations, but beyond that, you also have problems with how references are to be represented on disk. One module that does attempt to address this need is DBM::Deep. Check your nearest CPAN site as described in &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for source code. Note that despite its name, DBM::Deep does not use dbm. Another earlier attempt at solving the problem is MLDBM, which is also available on the CPAN, but which has some fairly serious limitations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54808a204fe862b1dfa25e752a892b2a04ab63bf" translate="yes" xml:space="preserve">
          <source>You cannot get stack frame information or in any fashion debug functions that were not compiled by Perl, such as those from C or C++ extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b370a3f9299c4f8abb35adc5b9b2b86568a00bc8" translate="yes" xml:space="preserve">
          <source>You cannot lock the individual elements of a container variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2b8b7a26c050e538a292ea22f61da0581625210" translate="yes" xml:space="preserve">
          <source>You cannot portably &quot;stack&quot; cpp directives. For example in the above you need two separate BURGLE() #defines, one for each #ifdef branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b918f134e01ab04a493d865bacd0ad2555d6eed0" translate="yes" xml:space="preserve">
          <source>You cannot set $RS to a pattern, only a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891970fccef081510b98291902ea82121168e7ae" translate="yes" xml:space="preserve">
          <source>You cannot tie this routine directly to an option, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d9b5eae243979aa930fce2644c85c94e98e03e5" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;b&gt;-i&lt;/b&gt; to create directories or to strip extensions from files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d40633e0023663f60f6c6868c36efce9e85c50a" translate="yes" xml:space="preserve">
          <source>You compare the sort keys using a binary comparison and get the result of the comparison of the strings using UCA.</source>
          <target state="translated">你用二进制比较来比较排序键,用UCA得到字符串的比较结果。</target>
        </trans-unit>
        <trans-unit id="794fe9a7963db4b15645c3e75175ca30a42e7c02" translate="yes" xml:space="preserve">
          <source>You could also exclude &lt;code&gt;LC_NUMERIC&lt;/code&gt; , if you don't need it, by</source>
          <target state="translated">您也可以排除 &lt;code&gt;LC_NUMERIC&lt;/code&gt; ，如果不需要的话</target>
        </trans-unit>
        <trans-unit id="63946de92748533808fd29d4342bd54a0ec7a953" translate="yes" xml:space="preserve">
          <source>You could also have used the existing block property names:</source>
          <target state="translated">你也可以使用现有的块属性名称。</target>
        </trans-unit>
        <trans-unit id="eaa54d59d0ed5e55dbc530f16d131415959a1711" translate="yes" xml:space="preserve">
          <source>You could also investigate the can() method in the UNIVERSAL class (part of the standard perl distribution).</source>
          <target state="translated">你也可以研究一下UNIVERSAL类中的can()方法(标准perl发行版的一部分)。</target>
        </trans-unit>
        <trans-unit id="802dff37470d190b2a864a13c708bc5907b98d91" translate="yes" xml:space="preserve">
          <source>You could also just know all the perl errors, and although there are some people who may know all of them, you probably don't. However, they all should be in the &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; manpage. If you don't find the error in there, it probably isn't a perl error.</source>
          <target state="translated">您也可能只知道所有perl错误，尽管有些人可能知道所有这些错误，但您可能不知道。但是，它们都应该在&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;联机帮助页中。如果您没有在其中找到错误，则可能不是perl错误。</target>
        </trans-unit>
        <trans-unit id="80d2dd3ba7c4c2069cf58261b6aaeb6dcd467d24" translate="yes" xml:space="preserve">
          <source>You could also write a single get/set method using an optional argument:</source>
          <target state="translated">你也可以使用一个可选的参数写一个单一的get/set方法。</target>
        </trans-unit>
        <trans-unit id="8444b9fc7a3ed8d2fa7659ffde996510ee7f1f46" translate="yes" xml:space="preserve">
          <source>You could build a web site using &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; and your own code, but for anything other than a very basic web site, using a web framework (that uses &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt;) is a better option.</source>
          <target state="translated">您可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt;和自己的代码来构建网站，但是对于非常基本的网站以外的其他任何情况，使用Web框架（使用&lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt;）则是更好的选择。</target>
        </trans-unit>
        <trans-unit id="2158ae7a8b9ea3f34a07fb0e90c3b98892665dc8" translate="yes" xml:space="preserve">
          <source>You could conceivably do both.</source>
          <target state="translated">可以想象,你可以两者兼得。</target>
        </trans-unit>
        <trans-unit id="49073618f97078f446e251732bebc1a46a9b86b9" translate="yes" xml:space="preserve">
          <source>You could do the memoization yourself, by rewriting the function, like this:</source>
          <target state="translated">你可以自己做备忘,重写函数,像这样。</target>
        </trans-unit>
        <trans-unit id="a8bc28868b949ea5a73ffcd10a5a6d7af5c6ab02" translate="yes" xml:space="preserve">
          <source>You could do this:</source>
          <target state="translated">你可以这样做。</target>
        </trans-unit>
        <trans-unit id="9e128ecfca5b0e265baad327ad431d782e5e7ffc" translate="yes" xml:space="preserve">
          <source>You could edit that header yourself to remove that last '/', or you might note that Language Environment (LE) APAR PQ39997 describes the problem and PTF's UQ46272 and UQ46271 are the (R8 at least) fixes and apply them. If left unattended that syntax error will turn up as an inability for Perl to build its &quot;Socket&quot; extension.</source>
          <target state="translated">你可以自己编辑那个头来删除最后的 '/',或者你可以注意语言环境 (LE)APAR PQ39997 描述了这个问题,而 PTF 的 UQ46272 和 UQ46271 则是 (至少是 R8)修复方法并应用它们。如果不加以注意,该语法错误将变成Perl无法构建其 &quot;Socket &quot;扩展。</target>
        </trans-unit>
        <trans-unit id="3e7ad6be7d9fb2b01433fa3be5444bc3be8a1d7d" translate="yes" xml:space="preserve">
          <source>You could instead do lookups on $wanted with:</source>
          <target state="translated">你可以用以下方法对$wanted进行查找。</target>
        </trans-unit>
        <trans-unit id="457f8e624ad1da28bfb9cf34b1f79dc6623d16da" translate="yes" xml:space="preserve">
          <source>You could just store all your dates as a number and then subtract. Life isn't always that simple though.</source>
          <target state="translated">你可以把所有的日期都存成一个数字,然后再减去。不过生活并不总是那么简单。</target>
        </trans-unit>
        <trans-unit id="c19f6ab6291cf9eaf2e211ed563b35ea9ac437b5" translate="yes" xml:space="preserve">
          <source>You could open the document in a web browser, and change the character set or character encoding until you can visually confirm that all characters look the way they should.</source>
          <target state="translated">你可以在网络浏览器中打开文档,然后改变字符集或字符编码,直到你能直观地确认所有字符看起来都是这样。</target>
        </trans-unit>
        <trans-unit id="2a20c232c667e613d02f2b4874878f40bc6c28f2" translate="yes" xml:space="preserve">
          <source>You could write the last two using the &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-d&lt;/code&gt; operators. Commonly available &lt;code&gt;S_IF*&lt;/code&gt; constants are:</source>
          <target state="translated">您可以使用 &lt;code&gt;-u&lt;/code&gt; 和 &lt;code&gt;-d&lt;/code&gt; 运算符编写最后两个。常用的 &lt;code&gt;S_IF*&lt;/code&gt; 常量为：</target>
        </trans-unit>
        <trans-unit id="2516f9cbf3f3333565923611bf8e4c6225451c64" translate="yes" xml:space="preserve">
          <source>You create the queue with &lt;code&gt;Thread::Queue-&amp;gt;new()&lt;/code&gt; . Then you can add lists of scalars onto the end with &lt;code&gt;enqueue()&lt;/code&gt; , and pop scalars off the front of it with &lt;code&gt;dequeue()&lt;/code&gt; . A queue has no fixed size, and can grow as needed to hold everything pushed on to it.</source>
          <target state="translated">您使用 &lt;code&gt;Thread::Queue-&amp;gt;new()&lt;/code&gt; 创建队列。然后，您可以使用 &lt;code&gt;enqueue()&lt;/code&gt; 将标量列表添加到末尾，并使用 &lt;code&gt;dequeue()&lt;/code&gt; 将标量列表弹出其最前面。队列没有固定的大小，并且可以根据需要增长以容纳推送到它的所有内容。</target>
        </trans-unit>
        <trans-unit id="dede4110b8ccb447bd7101130015f76cda530da1" translate="yes" xml:space="preserve">
          <source>You currently don't need to instantiate a factory in order to use it.</source>
          <target state="translated">目前你不需要实例化工厂就可以使用它。</target>
        </trans-unit>
        <trans-unit id="94aa24e74566493da77121fdf1cf79a43455f271" translate="yes" xml:space="preserve">
          <source>You did not run &lt;code&gt;omflibs&lt;/code&gt; . See &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">您没有运行 &lt;code&gt;omflibs&lt;/code&gt; 。请参阅&lt;a href=&quot;#Prerequisites&quot;&gt;先决条件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="351e72fc696e530c4b98b81dced35a153aee9b73" translate="yes" xml:space="preserve">
          <source>You did try the &lt;b&gt;-w&lt;/b&gt; switch, didn't you?</source>
          <target state="translated">您确实尝试了&lt;b&gt;-w&lt;/b&gt;开关，不是吗？</target>
        </trans-unit>
        <trans-unit id="88ae653a2469feaccaacebc0c4775e33fd1da464" translate="yes" xml:space="preserve">
          <source>You do need to be careful with the logical names representing process-permanent files, such as &lt;code&gt;SYS$INPUT&lt;/code&gt; and &lt;code&gt;SYS$OUTPUT&lt;/code&gt; . The translations for these logical names are prepended with a two-byte binary value (0x1B 0x00) that needs to be stripped off if you want to use it. (In previous versions of Perl it wasn't possible to get the values of these logical names, as the null byte acted as an end-of-string marker)</source>
          <target state="translated">您确实需要注意代表进程永久文件的逻辑名，例如 &lt;code&gt;SYS$INPUT&lt;/code&gt; 和 &lt;code&gt;SYS$OUTPUT&lt;/code&gt; 。这些逻辑名的转换之前带有两个字节的二进制值（0x1B 0x00），如果要使用它，则需要将其删除。（在以前的Perl版本中，无法获得这些逻辑名的值，因为空字节充当字符串结尾标记）</target>
        </trans-unit>
        <trans-unit id="058b0924bf8d4ec16b563bbf0577363645a7bf62" translate="yes" xml:space="preserve">
          <source>You do not call &lt;code&gt;setlogsock&lt;/code&gt; .</source>
          <target state="translated">您不调用 &lt;code&gt;setlogsock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0688f744612cb917b09a1848a221dbc87e7927a1" translate="yes" xml:space="preserve">
          <source>You do not have MT-safe</source>
          <target state="translated">你没有MT-safe</target>
        </trans-unit>
        <trans-unit id="2e1ca2f68a9ba2ef298384c1d65396bc3e584c1e" translate="yes" xml:space="preserve">
          <source>You do not have to override methods shown below unless you have to.</source>
          <target state="translated">你不必覆盖下面显示的方法,除非你必须这样做。</target>
        </trans-unit>
        <trans-unit id="d463f5c40ea27790902d715d5582fd331f2a8862" translate="yes" xml:space="preserve">
          <source>You do this by using &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and replacing your &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;s with &lt;code&gt;carp&lt;/code&gt; s. If you need to &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, say &lt;code&gt;croak&lt;/code&gt; instead. However, keep &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in place for your sanity checks - where it really is your module at fault.</source>
          <target state="translated">通过使用这样做&lt;a href=&quot;carp&quot;&gt;鲤鱼&lt;/a&gt;和更换你的 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 与S &lt;code&gt;carp&lt;/code&gt; 秒。如果您需要 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，请说&amp;ldquo; &lt;code&gt;croak&lt;/code&gt; 。但是，请 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; ，并 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 在地方的完整性检查-它真的是你的过错模块。</target>
        </trans-unit>
        <trans-unit id="005e9bdc4a22cadca7bbf603665f85ba87cfef2b" translate="yes" xml:space="preserve">
          <source>You don't actually</source>
          <target state="translated">你其实并没有</target>
        </trans-unit>
        <trans-unit id="27b09323fd0303316a1e04f47208b954d9880846" translate="yes" xml:space="preserve">
          <source>You don't actually &quot;trap&quot; a control character. Instead, that character generates a signal which is sent to your terminal's currently foregrounded process group, which you then trap in your process. Signals are documented in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; and the section on &quot;Signals&quot; in the Camel.</source>
          <target state="translated">您实际上并没有&amp;ldquo;捕获&amp;rdquo;控制字符。而是，该角色生成一个信号，该信号被发送到终端的当前前台进程组，然后您将其捕获在进程中。信号记录在&lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc的Signals&lt;/a&gt;和Camel的&amp;ldquo; Signals&amp;rdquo;部分中。</target>
        </trans-unit>
        <trans-unit id="9b1e2e036145d009e379c1e58f4e8404e4bb7c5f" translate="yes" xml:space="preserve">
          <source>You don't have to check for &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on the return from &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;. Like &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;, it maps a &lt;code&gt;0&lt;/code&gt; return from the system call into &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in Perl. This string is true in boolean context and &lt;code&gt;0&lt;/code&gt; in numeric context. It is also exempt from the normal &lt;b&gt;-w&lt;/b&gt; warnings on improper numeric conversions.</source>
          <target state="translated">您不必检查 &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 。像 &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 一样，它将Perl中从系统调用返回的 &lt;code&gt;0&lt;/code&gt; 映射为 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 。该字符串在布尔上下文中为true，在数字上下文中为 &lt;code&gt;0&lt;/code&gt; 。对于不正确的数字转换，它也不受常规的&lt;b&gt;-w&lt;/b&gt;警告的影响。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="91e28b8dde4eef2778828dc13bbb504ddd8429b3" translate="yes" xml:space="preserve">
          <source>You don't have to check for &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on the return from &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;. Like &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;, it maps a &lt;code&gt;0&lt;/code&gt; return from the system call into &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in Perl. This string is true in boolean context and &lt;code&gt;0&lt;/code&gt; in numeric context. It is also exempt from the normal &lt;b&gt;-w&lt;/b&gt; warnings on improper numeric conversions.</source>
          <target state="translated">您不必检查 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 。像 &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 一样，它将Perl中从系统调用返回的 &lt;code&gt;0&lt;/code&gt; 映射为 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 。该字符串在布尔上下文中为true，在数字上下文中为 &lt;code&gt;0&lt;/code&gt; 。对于不正确的数字转换，它也不受常规的&lt;b&gt;-w&lt;/b&gt;警告的影响。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3317a455934bcb4f5310b2ce1e13684a7b6884c6" translate="yes" xml:space="preserve">
          <source>You don't have to close FILEHANDLE if you are immediately going to do another &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; on it, because &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; closes it for you. (See &lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt;.) However, an explicit &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on an input file resets the line counter (&lt;code&gt;$.&lt;/code&gt; ), while the implicit close done by &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">如果您要立即对其进行另一个 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ，则不必关闭FILEHANDLE ，因为 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 会为您关闭它。（请参见&lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt;。）但是，输入文件上的显式 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 重置行计数器（ &lt;code&gt;$.&lt;/code&gt; ），而 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 所进行的隐式关闭则不会。</target>
        </trans-unit>
        <trans-unit id="d144697260e1beed6903444902a55fc7aceb423c" translate="yes" xml:space="preserve">
          <source>You don't have to close FILEHANDLE if you are immediately going to do another &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; on it, because &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; closes it for you. (See &lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt;.) However, an explicit &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on an input file resets the line counter (&lt;code&gt;$.&lt;/code&gt; ), while the implicit close done by &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">如果您要立即对其进行另一个 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ，则不必关闭FILEHANDLE ，因为 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 会为您关闭它。（请参见&lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt;。）但是，输入文件上的显式 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 重置行计数器（ &lt;code&gt;$.&lt;/code&gt; ），而 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 所进行的隐式关闭则不会。</target>
        </trans-unit>
        <trans-unit id="ada37b6245f195e4fcd7aa6724d9b314782b9989" translate="yes" xml:space="preserve">
          <source>You don't have to do anything new in your extension to get this; since the Perl library provides Perl_get_context(), it will all just work.</source>
          <target state="translated">你不需要在你的扩展中做任何新的事情来获得这个功能;因为Perl库提供了Perl_get_context(),所以这一切都能正常工作。</target>
        </trans-unit>
        <trans-unit id="0afa6281a85d9c8f0451db68d3408cd7d6bba6a9" translate="yes" xml:space="preserve">
          <source>You don't have to do this all on the command line, though, there are a few GUI options out there. The nice thing about these is you can wave a mouse over a variable and a dump of its data will appear in an appropriate window, or in a popup balloon, no more tiresome typing of 'x $varname' :-)</source>
          <target state="translated">你不必在命令行上完成这些工作,不过,有一些GUI选项。这些选项的好处是,你可以在一个变量上挥动鼠标,它的数据转储就会出现在一个适当的窗口中,或者在一个弹出的气球中,再也不用烦人地输入 &quot;x $varname &quot;了 :-)</target>
        </trans-unit>
        <trans-unit id="bc3f5455b30ee7863f96aa530c94393c0cafca20" translate="yes" xml:space="preserve">
          <source>You don't have to enclose POSIX class names inside double brackets, hence both of the following work:</source>
          <target state="translated">你不必把POSIX类名放在双括号内,因此下面两个都可以。</target>
        </trans-unit>
        <trans-unit id="229ae092ed53a2ce77c4892afb43389969fbd9bc" translate="yes" xml:space="preserve">
          <source>You don't have to use \b to match words though. You can look for non-word characters surrounded by word characters. These strings match the pattern /\b'\b/.</source>
          <target state="translated">不过你不一定非要用\b来匹配单词。你可以寻找被单词字符包围的非单词字符。这些字符串符合/\b'\b/的模式。</target>
        </trans-unit>
        <trans-unit id="21cad750fa1f143b35b4124baa7518d27d8319c9" translate="yes" xml:space="preserve">
          <source>You don't have to worry about finding or paying for Perl; it's freely available and several popular operating systems come with Perl. Community support in places such as Perlmonks ( &lt;a href=&quot;http://www.perlmonks.com&quot;&gt;http://www.perlmonks.com&lt;/a&gt; ) and the various Perl mailing lists ( &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt; ) means that you can usually get quick answers to your problems.</source>
          <target state="translated">您不必担心寻找Perl或为它付费。它是免费提供的，Perl随附了几种流行的操作系统。在Perlmonks（&lt;a href=&quot;http://www.perlmonks.com&quot;&gt;http://www.perlmonks.com&lt;/a&gt;）和各种Perl邮件列表（&lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt;）之类的地方，社区支持意味着您通常可以快速找到问题的答案。</target>
        </trans-unit>
        <trans-unit id="8365eeff3d04c895cb1076cf6e1217da1d00d04f" translate="yes" xml:space="preserve">
          <source>You don't just have to match on fixed strings. In fact, you can match on just about anything you could dream of by using more complex regular expressions. These are documented at great length in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, but for the meantime, here's a quick cheat sheet:</source>
          <target state="translated">您不仅需要匹配固定的字符串。实际上，通过使用更复杂的正则表达式，您几乎可以匹配任何您梦dream以求的东西。这些文件在&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;中有大量记录，但与此同时，这是一个快速备忘单：</target>
        </trans-unit>
        <trans-unit id="6fa3f4f65b9497a1fe4774a26aaf551f58ec3c5f" translate="yes" xml:space="preserve">
          <source>You don't need to have /usr/ucb/ in your PATH to build perl. If you want /usr/ucb/ in your PATH anyway, make sure that /usr/ucb/ is NOT in your PATH before the directory containing the right C compiler.</source>
          <target state="translated">你不需要在你的PATH里有/usr/ucb/来编译perl。如果你想让/usr/ucb/在你的PATH中,确保/usr/ucb/不在你的PATH中,而在包含正确的C编译器的目录前。</target>
        </trans-unit>
        <trans-unit id="e40dd09143f7def3dc81d2ff9344d2600d1d1ae7" translate="yes" xml:space="preserve">
          <source>You don't really have to count them yourself, though, since Perl already does that with the &lt;code&gt;$.&lt;/code&gt; variable, which is the current line number from the last filehandle read:</source>
          <target state="translated">不过，由于Perl已经使用 &lt;code&gt;$.&lt;/code&gt; 做到了这一点，因此您实际上不必自己计算它们。变量，它是最近读取的文件句柄中的当前行号：</target>
        </trans-unit>
        <trans-unit id="b24e0508e2da733e0f794e663fee88bb39a1e25a" translate="yes" xml:space="preserve">
          <source>You don't skip tests which are failing because there's a bug in your program, or for which you don't yet have code written. For that you use TODO. Read on.</source>
          <target state="translated">你不会跳过那些因为你的程序有bug而失败的测试,或者你还没有写好代码的测试。为此,你使用TODO。请继续阅读。</target>
        </trans-unit>
        <trans-unit id="710a0707d7d6991623d26d4226d9c4d860f3f7d5" translate="yes" xml:space="preserve">
          <source>You forgot to check &lt;code&gt;$?&lt;/code&gt; to see whether the program even ran correctly. Even if you wrote</source>
          <target state="translated">您忘了检查 &lt;code&gt;$?&lt;/code&gt; 查看程序是否正确运行。即使你写了</target>
        </trans-unit>
        <trans-unit id="fc90d9f18467dae7f984c44b04f6fed62e49d3b4" translate="yes" xml:space="preserve">
          <source>You get two references to the same array. If you modify &lt;code&gt;$aref1-&amp;gt;[23]&lt;/code&gt; and then look at &lt;code&gt;$aref2-&amp;gt;[23]&lt;/code&gt; you'll see the change.</source>
          <target state="translated">您将获得对同一数组的两个引用。如果修改 &lt;code&gt;$aref1-&amp;gt;[23]&lt;/code&gt; ，然后查看 &lt;code&gt;$aref2-&amp;gt;[23]&lt;/code&gt; 您将看到更改。</target>
        </trans-unit>
        <trans-unit id="d8e5e5638bed24bad2d4ab312bfe1360cb8707ce" translate="yes" xml:space="preserve">
          <source>You have a data file that expresses greetings in different languages. Its format is &quot;[language tag]=[how to say 'Hello']&quot;, like:</source>
          <target state="translated">你有一个用不同语言表达问候语的数据文件。它的格式是&quot;[语言标签]=[如何说'你好']&quot;,比如。</target>
        </trans-unit>
        <trans-unit id="afbb6b8d64f8b4b3f378ab57026bdb8753122fdc" translate="yes" xml:space="preserve">
          <source>You have a piece of data on which many different operations are applied.</source>
          <target state="translated">你有一个数据,在这个数据上应用了许多不同的操作。</target>
        </trans-unit>
        <trans-unit id="f8eed8b91591afe605349a4edd81010c1b4133d5" translate="yes" xml:space="preserve">
          <source>You have a very old pdksh. See &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">您有一个非常老的pdksh。请参阅&lt;a href=&quot;#Prerequisites&quot;&gt;先决条件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0763fc81d3cd7a4189100a79a22596558a167896" translate="yes" xml:space="preserve">
          <source>You have an older version of</source>
          <target state="translated">你有一个旧版本的</target>
        </trans-unit>
        <trans-unit id="72b9024251b30a14c45724d6bbd90abab3f232a3" translate="yes" xml:space="preserve">
          <source>You have been warned already in &lt;a href=&quot;#Selecting-What-to-Export&quot;&gt;Selecting What to Export&lt;/a&gt; to not export:</source>
          <target state="translated">您已经在&lt;a href=&quot;#Selecting-What-to-Export&quot;&gt;选择要导出的内容&lt;/a&gt;中不发出警告：</target>
        </trans-unit>
        <trans-unit id="43dfe62727996603d47468da8d91c958abc24b74" translate="yes" xml:space="preserve">
          <source>You have created an XSUB interface to an application's C API.</source>
          <target state="translated">你已经创建了一个XSUB接口到应用程序的C API。</target>
        </trans-unit>
        <trans-unit id="c236e9b8bd9523c45d8e12fd36ee9331405ecbff" translate="yes" xml:space="preserve">
          <source>You have defined an END handler for an attribute that is being applied to a lexical variable. Since the variable may not be available during END this won't happen.</source>
          <target state="translated">你为一个应用于词法变量的属性定义了一个END处理程序。由于变量在END期间可能无法使用,所以不会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="717f15e5bfd4a04630296d7e18d1dc4a8563c670" translate="yes" xml:space="preserve">
          <source>You have set the &lt;code&gt;WindowBits&lt;/code&gt; parameter to &lt;code&gt;-MAX_WBITS&lt;/code&gt; in the constructor for this object, i.e. you are uncompressing a raw deflated data stream (RFC 1951).</source>
          <target state="translated">您已设置 &lt;code&gt;WindowBits&lt;/code&gt; 参数 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 在构造该对象，即你解压缩原始瘪数据流（RFC 1951）。</target>
        </trans-unit>
        <trans-unit id="522d08a79de6280adc20232939d047a4cc891b57" translate="yes" xml:space="preserve">
          <source>You have the choice to set the config variable &lt;code&gt;scan_cache&lt;/code&gt; to &lt;code&gt;never&lt;/code&gt; . Then you must clean it up yourself. The other possible values, &lt;code&gt;atstart&lt;/code&gt; and &lt;code&gt;atexit&lt;/code&gt; clean up the build directory when you start (or more precisely, after the first extraction into the build directory) or exit the CPAN shell, respectively. If you never start up the CPAN shell, you probably also have to clean up the build directory yourself.</source>
          <target state="translated">您可以选择将配置变量 &lt;code&gt;scan_cache&lt;/code&gt; 设置为 &lt;code&gt;never&lt;/code&gt; 。然后，您必须自己清理它。其他可能的值，分别是 &lt;code&gt;atstart&lt;/code&gt; 和 &lt;code&gt;atexit&lt;/code&gt; ，它们分别在您启动时（或更确切地说，在第一次提取到构建目录中之后）或退出CPAN Shell时清除构建目录。如果您从不启动CPAN Shell，则可能还必须自己清理build目录。</target>
        </trans-unit>
        <trans-unit id="b2deb6a8cd98a82f2aaaef2ec6bec5741ef832ea" translate="yes" xml:space="preserve">
          <source>You have the same problem with &lt;a href=&quot;time/local&quot;&gt;Time::Local&lt;/a&gt;, which will give the wrong answer for those same special cases:</source>
          <target state="translated">您在&lt;a href=&quot;time/local&quot;&gt;Time :: Local上遇到&lt;/a&gt;了相同的问题，对于相同的特殊情况，这将给出错误的答案：</target>
        </trans-unit>
        <trans-unit id="d93e439cde6acc82e52bf85fad48553b810a706b" translate="yes" xml:space="preserve">
          <source>You have to be prepared to &quot;reap&quot; the child process when it finishes.</source>
          <target state="translated">你要做好准备,当孩子的过程结束后,你要 &quot;收获&quot;。</target>
        </trans-unit>
        <trans-unit id="7bc9963f1adfa43aa2eba732c53b836ac12c4562" translate="yes" xml:space="preserve">
          <source>You have to decide whether you want to use string or numeric comparisons.</source>
          <target state="translated">你必须决定你是要使用字符串还是数字比较。</target>
        </trans-unit>
        <trans-unit id="4cf51b08c425e59c5631231a092f6037897d07c7" translate="yes" xml:space="preserve">
          <source>You have to decide whether your array has numeric or string indices.</source>
          <target state="translated">你必须决定你的数组是有数字还是字符串索引。</target>
        </trans-unit>
        <trans-unit id="a73461591d1d0c0412d08a5e1e1cc7e69b28c7fe" translate="yes" xml:space="preserve">
          <source>You have to have Pod::Simple::RTF installed (from the Pod::Simple dist), or this module won't work.</source>
          <target state="translated">你必须安装Pod::Simple::RTF(来自Pod::Simple dist),否则这个模块将无法工作。</target>
        </trans-unit>
        <trans-unit id="58b51a173ef28ef95718c75aa4bacf0fb0ef7258" translate="yes" xml:space="preserve">
          <source>You have to have installed Pod::Simple::XMLOutStream (from the Pod::Simple dist), or this class won't work.</source>
          <target state="translated">你必须安装了Pod::Simple::XMLOutStream(来自Pod::Simple dist),否则这个类将无法工作。</target>
        </trans-unit>
        <trans-unit id="f9f9dbede53dcc87c8a6c2c35d9ae17a92119e03" translate="yes" xml:space="preserve">
          <source>You have to have installed Tk::Pod first, or this class won't load.</source>
          <target state="translated">你必须先安装Tk::Pod,否则这个类不会加载。</target>
        </trans-unit>
        <trans-unit id="95bfc19d25cce1034c6f167e8df494025bec3f1c" translate="yes" xml:space="preserve">
          <source>You have to have two hex digits after a braceless &lt;code&gt;\x&lt;/code&gt; (use a leading zero to make two). These restrictions are to lower the incidence of typos causing the class to not match what you thought it would.</source>
          <target state="translated">无括号的 &lt;code&gt;\x&lt;/code&gt; 后面必须有两个十六进制数字（使用前导零表示两个）。这些限制是为了减少导致班级与您认为的不符的错别字的发生。</target>
        </trans-unit>
        <trans-unit id="c268b51167b66309dd9d49ba2a2c249b1b287fa0" translate="yes" xml:space="preserve">
          <source>You have to keep track of N yourself. For example, let's say you want to change the fifth occurrence of &lt;code&gt;&quot;whoever&quot;&lt;/code&gt; or &lt;code&gt;&quot;whomever&quot;&lt;/code&gt; into &lt;code&gt;&quot;whosoever&quot;&lt;/code&gt; or &lt;code&gt;&quot;whomsoever&quot;&lt;/code&gt; , case insensitively. These all assume that $_ contains the string to be altered.</source>
          <target state="translated">您必须自己跟踪N。例如，假设您要不区分大小写地将第五次出现的 &lt;code&gt;&quot;whoever&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;whomever&quot;&lt;/code&gt; 更改为 &lt;code&gt;&quot;whosoever&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;whomsoever&quot;&lt;/code&gt; 。这些都假定$ _包含要更改的字符串。</target>
        </trans-unit>
        <trans-unit id="ac02203046e578344330c6d8542449742080d451" translate="yes" xml:space="preserve">
          <source>You have to run this program by hand; it's not run as part of the Perl installation.</source>
          <target state="translated">你必须手动运行这个程序;它不会作为Perl安装的一部分运行。</target>
        </trans-unit>
        <trans-unit id="64c3798560849a7dba79bf1106dd1dedfd652114" translate="yes" xml:space="preserve">
          <source>You have tried to use one of the &lt;code&gt;-rwxRWX&lt;/code&gt; filetests with &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;
filetest 'access'&lt;/code&gt; in effect. &lt;code&gt;File::stat&lt;/code&gt; will ignore the pragma, and just use the information in the &lt;code&gt;mode&lt;/code&gt; member as usual.</source>
          <target state="translated">您尝试使用 &lt;code&gt;-rwxRWX&lt;/code&gt; filetest中的一项，并且 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; 。 &lt;code&gt;File::stat&lt;/code&gt; 将忽略编译指示，仅照常使用 &lt;code&gt;mode&lt;/code&gt; 成员中的信息。</target>
        </trans-unit>
        <trans-unit id="f298d6edd85361a4fe69a118c738c5c6d1ac6519" translate="yes" xml:space="preserve">
          <source>You just can't, okay? Instead, put all the specifications together with commas between them in a single &lt;code&gt;ATTR(&lt;i&gt;specification&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="translated">你不能，好吗？取而代之的是，将所有规范以及它们之间的逗号放在一个 &lt;code&gt;ATTR(&lt;i&gt;specification&lt;/i&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afbf451f9422303960f49b456d9bb760406138be" translate="yes" xml:space="preserve">
          <source>You likely need to figure out how this multi-byte character got mixed up with your single-byte locale (or perhaps you thought you had a UTF-8 locale, but Perl disagrees).</source>
          <target state="translated">你很可能需要弄清楚这个多字节字符是如何与你的单字节区位混在一起的 (或者你以为你有一个 UTF-8 区位,但 Perl 不同意)。</target>
        </trans-unit>
        <trans-unit id="b36efc02e455a878d40bce54d0800047ed5ce051" translate="yes" xml:space="preserve">
          <source>You may (and usually should) use the three-argument form of open to specify I/O layers (sometimes referred to as &quot;disciplines&quot;) to apply to the handle that affect how the input and output are processed (see &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt; and &lt;a href=&quot;../perlio&quot;&gt;PerlIO&lt;/a&gt; for more details). For example:</source>
          <target state="translated">您可能（通常应该）使用open的三参数形式来指定I / O层（有时称为&amp;ldquo;学科&amp;rdquo;）以应用于影响输入和输出处理方式的句柄（请参见&lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt;和&lt;a href=&quot;../perlio&quot;&gt;PerlIO&lt;/a&gt;以获取相关信息）。更多细节）。例如：</target>
        </trans-unit>
        <trans-unit id="f4242caecdd2a41134c434e48293066c09a61129" translate="yes" xml:space="preserve">
          <source>You may (and usually should) use the three-argument form of open to specify I/O layers (sometimes referred to as &quot;disciplines&quot;) to apply to the handle that affect how the input and output are processed (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; and &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; for more details). For example:</source>
          <target state="translated">您可能（通常应该）使用open的三参数形式来指定I / O层（有时称为&amp;ldquo;学科&amp;rdquo;）以应用于影响输入和输出处理方式的句柄（请参见&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;和&lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;以获取相关信息）。更多细节）。例如：</target>
        </trans-unit>
        <trans-unit id="9e56389d96587e792278e4c558eb5807976007cf" translate="yes" xml:space="preserve">
          <source>You may access the repository over the web. This allows you to browse the tree, see recent commits, subscribe to RSS feeds for the changes, search for particular commits and more. You may access it at &lt;a href=&quot;http://perl5.git.perl.org/perl.git&quot;&gt;http://perl5.git.perl.org/perl.git&lt;/a&gt;. A mirror of the repository is found at &lt;a href=&quot;https://github.com/Perl/perl5&quot;&gt;https://github.com/Perl/perl5&lt;/a&gt;.</source>
          <target state="translated">您可以通过Web访问存储库。这使您可以浏览树，查看最近的提交，订阅RSS feed进行更改，搜索特定的提交等等。您可以在&lt;a href=&quot;http://perl5.git.perl.org/perl.git&quot;&gt;http://perl5.git.perl.org/perl.git上&lt;/a&gt;访问它。可以在&lt;a href=&quot;https://github.com/Perl/perl5&quot;&gt;https://github.com/Perl/perl5&lt;/a&gt;找到存储库的镜像。</target>
        </trans-unit>
        <trans-unit id="d839e720ae2e7bff2fab5b0520b346cd44ca6b4d" translate="yes" xml:space="preserve">
          <source>You may add other methods to the UNIVERSAL class via Perl or XS code. You do not need to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; UNIVERSAL&lt;/code&gt; to make these methods available to your program (and you should not do so).</source>
          <target state="translated">您可以通过Perl或XS代码将其他方法添加到UNIVERSAL类中。您不需要 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; UNIVERSAL&lt;/code&gt; 使这些方法可用于您的程序（并且您不应这样做）。</target>
        </trans-unit>
        <trans-unit id="100a6f059c39fc4530e46957891e388f20cf1052" translate="yes" xml:space="preserve">
          <source>You may also choose to assign the strings &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; or &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; as the handler, in which case Perl will try to discard the signal or do the default thing.</source>
          <target state="translated">您也可以选择将字符串 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; 为处理程序，在这种情况下，Perl将尝试丢弃信号或执行默认操作。</target>
        </trans-unit>
        <trans-unit id="daa282ce292ff54483ba2ce846a92dc96f9168dc" translate="yes" xml:space="preserve">
          <source>You may also examine the &quot;safe&quot; flag on the output action object which is filled in when given as the third parameter to &lt;code&gt;POSIX::sigaction()&lt;/code&gt; :</source>
          <target state="translated">您还可以检查输出操作对象上的&amp;ldquo;安全&amp;rdquo;标志，该标志在作为 &lt;code&gt;POSIX::sigaction()&lt;/code&gt; 的第三个参数给出时被填充：</target>
        </trans-unit>
        <trans-unit id="01c5b9373dd2d19d42f55fdae95d97ea20dd07a1" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;gr_&lt;/code&gt; . Thus, &lt;code&gt;$group_obj-&amp;gt;gid()&lt;/code&gt; corresponds to $gr_gid if you import the fields. Array references are available as regular array variables, so &lt;code&gt;@{ $group_obj-&amp;gt;members() }&lt;/code&gt; would be simply @gr_members.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。（请注意，这仍然会覆盖您的核心功能。）将这些字段作为以前面的 &lt;code&gt;gr_&lt;/code&gt; 命名的变量进行访问。因此，如果导入字段，则 &lt;code&gt;$group_obj-&amp;gt;gid()&lt;/code&gt; 对应于$ gr_gid。数组引用可作为常规数组变量使用，因此 &lt;code&gt;@{ $group_obj-&amp;gt;members() }&lt;/code&gt; 就是@gr_members。</target>
        </trans-unit>
        <trans-unit id="fa4935199f235ba2f0cd0a1d49e3ac1a3bbd011f" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;h_&lt;/code&gt; . Thus, &lt;code&gt;$host_obj-&amp;gt;name()&lt;/code&gt; corresponds to $h_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $host_obj-&amp;gt;aliases()
}&lt;/code&gt; would be simply @h_aliases.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。 （请注意，这仍然会覆盖您的核心功能。）将这些字段作为以前面的 &lt;code&gt;h_&lt;/code&gt; 命名的变量进行访问。因此，如果导入字段，则 &lt;code&gt;$host_obj-&amp;gt;name()&lt;/code&gt; 对应于$ h_name。数组引用可以作为常规数组变量使用，因此例如 &lt;code&gt;@{ $host_obj-&amp;gt;aliases() }&lt;/code&gt; 就是@h_aliases。</target>
        </trans-unit>
        <trans-unit id="60ec160f76fcfc38cc73d96c90a7ce874d6384c9" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;n_&lt;/code&gt; . Thus, &lt;code&gt;$net_obj-&amp;gt;name()&lt;/code&gt; corresponds to $n_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $net_obj-&amp;gt;aliases()
}&lt;/code&gt; would be simply @n_aliases.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。 （请注意，这仍然会覆盖您的核心功能。）将这些字段作为以前面的 &lt;code&gt;n_&lt;/code&gt; 命名的变量进行访问。因此，如果您导入字段，则 &lt;code&gt;$net_obj-&amp;gt;name()&lt;/code&gt; 对应于$ n_name。数组引用可以作为常规数组变量使用，因此例如 &lt;code&gt;@{ $net_obj-&amp;gt;aliases() }&lt;/code&gt; 就是@n_aliases。</target>
        </trans-unit>
        <trans-unit id="cd8189e5c613aac0e23d3c0670ed3ce2f5ae13db" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;p_&lt;/code&gt; . Thus, &lt;code&gt;$proto_obj-&amp;gt;name()&lt;/code&gt; corresponds to $p_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $proto_obj-&amp;gt;aliases()
}&lt;/code&gt; would be simply @p_aliases.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。 （请注意，这仍然会覆盖您的核心功能。）将这些字段作为以前面的 &lt;code&gt;p_&lt;/code&gt; 命名的变量进行访问。因此，如果导入字段，则 &lt;code&gt;$proto_obj-&amp;gt;name()&lt;/code&gt; 对应于$ p_name。数组引用可以作为常规数组变量使用，因此例如 &lt;code&gt;@{ $proto_obj-&amp;gt;aliases() }&lt;/code&gt; 就是@p_aliases。</target>
        </trans-unit>
        <trans-unit id="25ca76eb17a2cf86a0c57fdc15c696e88b6cf4c9" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;pw_&lt;/code&gt; in front their method names. Thus, &lt;code&gt;$passwd_obj-&amp;gt;shell&lt;/code&gt; corresponds to $pw_shell if you import the fields.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。 （请注意，这仍然会覆盖您的核心功能。）将这些字段作为变量使用方法名称前的 &lt;code&gt;pw_&lt;/code&gt; 命名。因此，如果导入字段，则 &lt;code&gt;$passwd_obj-&amp;gt;shell&lt;/code&gt; 对应于$ pw_shell。</target>
        </trans-unit>
        <trans-unit id="274d859e81c068db4c48efa8f50c77493ca5cdbd" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;s_&lt;/code&gt; . Thus, &lt;code&gt;$serv_obj-&amp;gt;name()&lt;/code&gt; corresponds to $s_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $serv_obj-&amp;gt;aliases()}&lt;/code&gt; would be simply @s_aliases.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。 （请注意，这仍然会覆盖您的核心功能。）将这些字段作为以前面的 &lt;code&gt;s_&lt;/code&gt; 命名的变量进行访问。因此，如果导入字段，则 &lt;code&gt;$serv_obj-&amp;gt;name()&lt;/code&gt; 对应于$ s_name。数组引用可以作为常规数组变量使用，因此例如 &lt;code&gt;@{ $serv_obj-&amp;gt;aliases()}&lt;/code&gt; 就是@s_aliases。</target>
        </trans-unit>
        <trans-unit id="447198c5b98b7b54155b70c415358589d509c62e" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;tm_&lt;/code&gt; in front their method names. Thus, &lt;code&gt;$tm_obj-&amp;gt;mday()&lt;/code&gt; corresponds to $tm_mday if you import the fields.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。（请注意，这仍然会覆盖您的核心功能。）将这些字段作为变量使用方法名称 &lt;code&gt;tm_&lt;/code&gt; 变量tm_命名。因此，如果导入字段，则 &lt;code&gt;$tm_obj-&amp;gt;mday()&lt;/code&gt; 对应于$ tm_mday。</target>
        </trans-unit>
        <trans-unit id="5c856054dbb9356054cca7ccfef163a998ceb55f" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your stat() and lstat() functions.) Access these fields as variables named with a preceding &lt;code&gt;st_&lt;/code&gt; in front their method names. Thus, &lt;code&gt;$stat_obj-&amp;gt;dev()&lt;/code&gt; corresponds to $st_dev if you import the fields.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。（请注意，这仍然会覆盖您的stat（）和lstat（）函数。）以变量名的形式访问这些字段， &lt;code&gt;st_&lt;/code&gt; 在其方法名称前加一个前置st_。因此，如果您导入字段，则 &lt;code&gt;$stat_obj-&amp;gt;dev()&lt;/code&gt; 对应于$ st_dev。</target>
        </trans-unit>
        <trans-unit id="a6b6b26fcc9879eca82e69c4a67570540fca4ae9" translate="yes" xml:space="preserve">
          <source>You may also need to apply the patches supplied with the binary distribution of perl. It also makes sense to look on the perl5-porters mailing list for the latest OS/2-related patches (see &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&lt;/a&gt;). Such patches usually contain strings &lt;code&gt;/os2/&lt;/code&gt; and &lt;code&gt;patch&lt;/code&gt; , so it makes sense looking for these strings.</source>
          <target state="translated">您可能还需要应用perl二进制发行版随附的补丁。在perl5-porters邮件列表中查找与OS / 2相关的最新补丁也很有意义（请参阅&lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&lt;/a&gt;）。这样的补丁通常包含字符串 &lt;code&gt;/os2/&lt;/code&gt; 和 &lt;code&gt;patch&lt;/code&gt; ，因此查找这些字符串很有意义。</target>
        </trans-unit>
        <trans-unit id="6aa8495c9efa1eb6aea78e6cd751529d33d7b29e" translate="yes" xml:space="preserve">
          <source>You may also need to comment out the &lt;code&gt;DELAYLOAD = ...&lt;/code&gt; line in the Makefile if you're using VC++ 6.0 without the latest service pack and the linker reports an internal error.</source>
          <target state="translated">如果您使用的是不带最新Service Pack的VC ++ 6.0，并且链接器报告内部错误，则可能还需要注释掉Makefile中的 &lt;code&gt;DELAYLOAD = ...&lt;/code&gt; 行。</target>
        </trans-unit>
        <trans-unit id="2c64c3fbfbcaace5918da128791239c43cdf19d2" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; to check whether subroutine &lt;code&gt;&amp;amp;func&lt;/code&gt; has ever been defined. The return value is unaffected by any forward declarations of &lt;code&gt;&amp;amp;func&lt;/code&gt; . A subroutine that is not defined may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;../perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">您也可以使用 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; 检查子程序 &lt;code&gt;&amp;amp;func&lt;/code&gt; 是否已定义。返回值不受 &lt;code&gt;&amp;amp;func&lt;/code&gt; 的任何前向声明的影响。未定义的子例程可能仍然可以调用：其程序包可能具有 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法，该方法使它在第一次被调用时就存在。参见&lt;a href=&quot;../perlsub&quot;&gt;perlsub&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="172f346295165efa4fd86444269a98fd3b778c01" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; to check whether subroutine &lt;code&gt;&amp;amp;func&lt;/code&gt; has ever been defined. The return value is unaffected by any forward declarations of &lt;code&gt;&amp;amp;func&lt;/code&gt; . A subroutine that is not defined may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">您也可以使用 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; 检查子程序 &lt;code&gt;&amp;amp;func&lt;/code&gt; 是否已定义。返回值不受 &lt;code&gt;&amp;amp;func&lt;/code&gt; 的任何前向声明的影响。未定义的子例程可能仍然可以调用：其程序包可能具有 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法，该方法使它在第一次被调用时就存在。参见&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b5f7479dd4b17df91be39e0264b553fbc922288" translate="yes" xml:space="preserve">
          <source>You may also use backticks to invoke a DCL subprocess, whose output is used as the return value of the expression. The string between the backticks is handled as if it were the argument to the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; operator (see below). In this case, Perl will wait for the subprocess to complete before continuing.</source>
          <target state="translated">您也可以使用反引号来调用DCL子进程，该子进程的输出用作表达式的返回值。反引号之间的字符串的处理方式就像是 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 运算符的参数一样（请参见下文）。在这种情况下，Perl将等待子进程完成后再继续。</target>
        </trans-unit>
        <trans-unit id="5448f65c98891197c6cecbe08ead986b82724f17" translate="yes" xml:space="preserve">
          <source>You may also use dmake. See &lt;a href=&quot;#Make&quot;&gt;Make&lt;/a&gt; above on how to get it.</source>
          <target state="translated">您也可以使用dmake。有关如何获取的信息，请参见上面的&amp;ldquo; &lt;a href=&quot;#Make&quot;&gt;制作&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3196fa8d2ff4d6ac1033b15a7916441466060e42" translate="yes" xml:space="preserve">
          <source>You may also use the &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; module (part of the standard perl distribution), but be warned that it has a different order of arguments from &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt; (see &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt;).</source>
          <target state="translated">您也可以使用&lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt;模块（标准perl发行版的一部分），但要注意其模块的参数顺序与&lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2的&lt;/a&gt;顺序不同（请参阅&lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6b7ef88e606ea55cb21f76eea0e0de1fb7b9db2f" translate="yes" xml:space="preserve">
          <source>You may also want to look at one other option for building a perl that will work on Windows: the README.cygwin file, which give a different set of rules to build a perl for Windows. This method will probably enable you to build a more Unix-compatible perl, but you will also need to download and use various other build-time and run-time support software described in that file.</source>
          <target state="translated">你可能还想看看另外一个可以在Windows上运行的perl的选项:README.cygwin文件,它给出了一套不同的规则来构建Windows下的perl。这种方法可能会让你构建一个更兼容Unix的perl,但你还需要下载并使用该文件中描述的其他各种构建时和运行时支持软件。</target>
        </trans-unit>
        <trans-unit id="47d8e5afa5f51ce60391c15623a30d357b47dac4" translate="yes" xml:space="preserve">
          <source>You may also want to override the &lt;b&gt;begin_input()&lt;/b&gt; and &lt;b&gt;end_input()&lt;/b&gt; methods for your subclass (to perform any needed per-file and/or per-document initialization or cleanup).</source>
          <target state="translated">您可能还想为您的子类覆盖&lt;b&gt;begin_input（）&lt;/b&gt;和&lt;b&gt;end_input（）&lt;/b&gt;方法（以执行任何需要的按文件和/或按文档的初始化或清除操作）。</target>
        </trans-unit>
        <trans-unit id="fad70035f3a1b89b3667a331878011a9d50cf74f" translate="yes" xml:space="preserve">
          <source>You may also want to read over the source for &lt;code&gt;File::Findgrep&lt;/code&gt; and its constituent modules -- they are a complete (if small) example application that uses Maketext.</source>
          <target state="translated">您可能还想阅读 &lt;code&gt;File::Findgrep&lt;/code&gt; 及其组成模块的源代码-它们是使用Maketext的完整（如果很小）的示例应用程序。</target>
        </trans-unit>
        <trans-unit id="32c591edfbc105cf26f618c0c72cc57761fceff2" translate="yes" xml:space="preserve">
          <source>You may also wish to discuss with the translators the question of how to relate different subforms of the same language tag, considering how this reacts with &lt;code&gt;get_handle&lt;/code&gt; 's treatment of these. For example, if a user accepts interfaces in &quot;en, fr&quot;, and you have interfaces available in &quot;en-US&quot; and &quot;fr&quot;, what should they get? You may wish to resolve this by establishing that &quot;en&quot; and &quot;en-US&quot; are effectively synonymous, by having one class zero-derive from the other.</source>
          <target state="translated">您可能还希望与翻译人员讨论如何关联同一个语言标签的不同子形式的问题，考虑它如何与 &lt;code&gt;get_handle&lt;/code&gt; 对这些形式的反应。例如，如果用户接受&amp;ldquo; en，fr&amp;rdquo;中的接口，而您拥有&amp;ldquo; en-US&amp;rdquo;和&amp;ldquo; fr&amp;rdquo;中的可用接口，那么他们应该得到什么？您可能希望通过使&amp;ldquo; en&amp;rdquo;和&amp;ldquo; en-US&amp;rdquo;有效同义来解决这一问题，方法是让一个类从另一个派生为零。</target>
        </trans-unit>
        <trans-unit id="05003e2911012bca46d826b18714273b702cbb78" translate="yes" xml:space="preserve">
          <source>You may also, in the Bourne shell tradition, specify an EXPR beginning with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, in which case the rest of the string is interpreted as the name of a filehandle (or file descriptor, if numeric) to be duped (as &lt;code&gt;dup(2)&lt;/code&gt; ) and opened. You may use &lt;code&gt;&amp;amp;&lt;/code&gt; after &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;+&amp;gt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt; , and &lt;code&gt;+&amp;lt;&lt;/code&gt; . The mode you specify should match the mode of the original filehandle. (Duping a filehandle does not take into account any existing contents of IO buffers.) If you use the three-argument form, then you can pass either a number, the name of a filehandle, or the normal &quot;reference to a glob&quot;.</source>
          <target state="translated">您还可以按照Bourne shell传统，以 &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; 开头指定EXPR ，在这种情况下，字符串的其余部分将解释为要复制的文件句柄（或文件描述符，如果是数字）的名称（如 &lt;code&gt;dup(2)&lt;/code&gt; ）并打开。您可以在 &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;+&amp;gt;&lt;/code&gt; ， &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;+&amp;lt;&lt;/code&gt; 之后使用＆。您指定的模式应与原始文件句柄的模式匹配。 （对文件句柄进行复制不会考虑IO缓冲区的任何现有内容。）如果使用三参数形式，则可以传递数字，文件句柄的名称或常规的&amp;ldquo;对glob的引用&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1c5fc563eb0d1fd26ae839cfa02427332324573f" translate="yes" xml:space="preserve">
          <source>You may ask whether one of these was implemented on the system Perl was built on by asking the importable &lt;code&gt;pw_has&lt;/code&gt; function about them. This function returns true if all parameters are supported fields on the build platform, false if one or more were not, and raises an exception if you asked about a field that Perl never knows how to provide. Parameters may be in a space-separated string, or as separate arguments. If you pass no parameters, the function returns the list of &lt;code&gt;struct pwd&lt;/code&gt; fields supported by your build platform's C library, as a list in list context, or a space-separated string in scalar context. Note that just because your C library had a field doesn't necessarily mean that it's fully implemented on that system.</source>
          <target state="translated">您可以通过询问可导入的 &lt;code&gt;pw_has&lt;/code&gt; 函数来询问是否在Perl的系统上实现了其中之一。如果在构建平台上支持所有参数，则此函数返回true；如果不支持一个或多个，则返回false；如果询问有关Perl不知道如何提供的字段，则该函数将引发异常。参数可以用空格分隔，也可以作为单独的参数。如果不传递任何参数，则该函数将返回构建平台的C库支持的 &lt;code&gt;struct pwd&lt;/code&gt; 字段的列表，列表上下文中的列表或标量上下文中以空格分隔的字符串。请注意，仅仅因为您的C库包含一个字段，并不一定意味着它已在该系统上完全实现。</target>
        </trans-unit>
        <trans-unit id="56003b76083072e5d28f4c38591744948d360c03" translate="yes" xml:space="preserve">
          <source>You may at this point want to consider whether your base class (Projname::L10N), from which all lexicons inherit from (Projname::L10N::en, Projname::L10N::es, etc.), should be an _AUTO lexicon. It may be true that in theory, all needed messages will be in each language class; but in the presumably unlikely or &quot;impossible&quot; case of lookup failure, you should consider whether your program should throw an exception, emit text in English (or whatever your project's first language is), or some more complex solution as described in the section &quot;Controlling Lookup Failure&quot;, above.</source>
          <target state="translated">这时你可能要考虑你的基类(Projname::L10N)是否应该是一个_AUTO词典,所有的词典都是从这个基类继承而来的(Projname::L10N::en、Projname::L10N::es等)。理论上,所有需要的消息都会在每个语言类中,这可能是真的;但在大概不太可能或 &quot;不可能 &quot;出现查找失败的情况下,你应该考虑你的程序是否应该抛出一个异常,发出英语(或不管你的项目的第一语言是什么)的文本,或者像上面 &quot;控制查找失败 &quot;一节中描述的一些更复杂的解决方案。</target>
        </trans-unit>
        <trans-unit id="00dd50349ec2812a0e8ba87a508b17b844d30458" translate="yes" xml:space="preserve">
          <source>You may be able to figure out what's going wrong using the Perl debugger. For information about how to use the debugger &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;.</source>
          <target state="translated">使用Perl调试器，您可能可以找出问题所在。有关如何使用调试器&lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perldebug&quot;&gt;perldebug的信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="538c1768e7dd08c154327dd9d81d8469210ac3b8" translate="yes" xml:space="preserve">
          <source>You may be mixing the Tru64 cc/ar/ld with the GNU gcc/ar/ld. That may work, but sometimes it doesn't (your gcc or GNU utils may have been compiled for an incompatible OS release).</source>
          <target state="translated">您可能将 Tru64 cc/ar/ld 与 GNU gcc/ar/ld 混合使用。这可能会有效,但有时不会(您的 gcc 或 GNU utils 可能是为不兼容的操作系统版本编译的)。</target>
        </trans-unit>
        <trans-unit id="569474da0977b8a6d57c606d4bf816045d439deb" translate="yes" xml:space="preserve">
          <source>You may be more comfortable with the Perl version of that:</source>
          <target state="translated">你可能更喜欢Perl版本的。</target>
        </trans-unit>
        <trans-unit id="a2c2934cf1eab265e83a97c11bed16b38a8b5801" translate="yes" xml:space="preserve">
          <source>You may be presented with strings in any of these equivalent forms. There is currently nothing in Perl 5 that ignores the differences. So you'll have to specially hanlde it. The usual advice is to convert your inputs to &lt;code&gt;NFD&lt;/code&gt; before processing further.</source>
          <target state="translated">可能会以任何这些等效形式为您提供字符串。目前，Perl 5中没有什么可以忽略这些差异。因此，您必须专门处理它。通常的建议是在进一步处理之前将输入转换为 &lt;code&gt;NFD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58f64d73709bb7f46995ccc9ddf584cf761fc186" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;can&lt;/code&gt; as a class (static) method or an object method.</source>
          <target state="translated">您可以将 &lt;code&gt;can&lt;/code&gt; 称为类（静态）方法或对象方法。</target>
        </trans-unit>
        <trans-unit id="8cf034da6832021586a2104fbbd0c08a1605f5bc" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;hv_delete&lt;/code&gt; or &lt;code&gt;hv_delete_ent&lt;/code&gt; on the hash entry that the iterator currently points to, without losing your place or invalidating your iterator. Note that in this case the current entry is deleted from the hash with your iterator holding the last reference to it. Your iterator is flagged to free the entry on the next call to &lt;code&gt;hv_iternext&lt;/code&gt; , so you must not discard your iterator immediately else the entry will leak - call &lt;code&gt;hv_iternext&lt;/code&gt; to trigger the resource deallocation.</source>
          <target state="translated">您可以在迭代器当前指向的哈希条目上调用 &lt;code&gt;hv_delete&lt;/code&gt; 或 &lt;code&gt;hv_delete_ent&lt;/code&gt; ，而不会失去位置或使迭代器无效。请注意，在这种情况下，当前条目将从哈希中删除，而您的迭代器将保留对它的最后一个引用。您的迭代器被标记为在下次调用 &lt;code&gt;hv_iternext&lt;/code&gt; 时释放该条目，因此您不得立即丢弃该迭代器，否则该条目将泄漏-调用 &lt;code&gt;hv_iternext&lt;/code&gt; 触发资源释放。</target>
        </trans-unit>
        <trans-unit id="9be40ceb1a7306a76b520e9584d2eca0a12452f8" translate="yes" xml:space="preserve">
          <source>You may change the pager which is used via &lt;code&gt;o pager=...&lt;/code&gt; command.</source>
          <target state="translated">您可以更改通过 &lt;code&gt;o pager=...&lt;/code&gt; 命令使用的寻呼机。</target>
        </trans-unit>
        <trans-unit id="8d0d219cb50b9b95de99bdba2a6790e3027b1988" translate="yes" xml:space="preserve">
          <source>You may choose one of six different protocols to use for the ping. The &quot;tcp&quot; protocol is the default. Note that a live remote host may still fail to be pingable by one or more of these protocols. For example, www.microsoft.com is generally alive but not &quot;icmp&quot; pingable.</source>
          <target state="translated">你可以从六种不同的协议中选择一种来进行ping。tcp &quot;协议是默认的。请注意,一个正常运行的远程主机可能仍然无法被其中一个或多个协议ping。例如,www.microsoft.com 通常是活着的,但不能被 &quot;icmp &quot;ping。</target>
        </trans-unit>
        <trans-unit id="5b9386b09cdd1212e7410c2ab62737e2149c7f2b" translate="yes" xml:space="preserve">
          <source>You may create a shared library that refers to another library, which may be either an archive library or a shared library. If this second library is a shared library, this is called a &quot;dependent library&quot;. The dependent library's name is recorded in the main shared library, but it is not linked into the shared library. Instead, it is loaded when the main shared library is loaded. This can cause problems if you build an extension on one system and move it to another system where the libraries may not be located in the same place as on the first system.</source>
          <target state="translated">您可以创建一个指向另一个库的共享库,这个库可以是归档库,也可以是共享库。如果第二个库是共享库,则称为 &quot;依赖库&quot;。从属库的名称记录在主共享库中,但它不链接到共享库中。相反,当主共享库被加载时,它会被加载。如果你在一个系统上建立了一个扩展,并将其移动到另一个系统上,而在另一个系统上,库的位置可能与第一个系统上的不一样,那么这就会造成问题。</target>
        </trans-unit>
        <trans-unit id="9c69978ae72909c6a0d4c9ce7bda602f4029ade9" translate="yes" xml:space="preserve">
          <source>You may declare &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables at the outermost scope of a file to hide any such identifiers from the world outside that file. This is similar in spirit to C's static variables when they are used at the file level. To do this with a subroutine requires the use of a closure (an anonymous function that accesses enclosing lexicals). If you want to create a private subroutine that cannot be called from outside that block, it can declare a lexical variable containing an anonymous sub reference:</source>
          <target state="translated">You may declare &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables at the outermost scope of a file to hide any such identifiers from the world outside that file. This is similar in spirit to C's static variables when they are used at the file level. To do this with a subroutine requires the use of a closure (an anonymous function that accesses enclosing lexicals). If you want to create a private subroutine that cannot be called from outside that block, it can declare a lexical variable containing an anonymous sub reference:</target>
        </trans-unit>
        <trans-unit id="4c485e566982c516f185802a5bb8005684c87aaf" translate="yes" xml:space="preserve">
          <source>You may do &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads qw(yield)&lt;/code&gt; , and then just use &lt;code&gt;yield()&lt;/code&gt; in your code.</source>
          <target state="translated">您可以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads qw(yield)&lt;/code&gt; ，然后在代码中使用 &lt;code&gt;yield()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad59ee540ee6c5334c4114152f24df062a49e4a1" translate="yes" xml:space="preserve">
          <source>You may encounter the following warning message at Perl startup:</source>
          <target state="translated">你可能会在Perl启动时遇到以下警告信息。</target>
        </trans-unit>
        <trans-unit id="294037a277c0cf3bb9e6ace3733986ce5d32b057" translate="yes" xml:space="preserve">
          <source>You may find it helpful to have a &quot;macro dictionary&quot;, which you can produce by saying &lt;code&gt;cpp -dM perl.c | &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . Even then,</source>
          <target state="translated">您可能会发现有一个&amp;ldquo;宏字典&amp;rdquo;会很有帮助，您可以通过说出 &lt;code&gt;cpp -dM perl.c | &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 来生成它。排序。即使这样，</target>
        </trans-unit>
        <trans-unit id="972b606b3734fb1680ed24e777ce569b72a6f320" translate="yes" xml:space="preserve">
          <source>You may find it helpful to use letter case to indicate the scope or nature of a variable. For example:</source>
          <target state="translated">您可能会发现使用字母大小写来表示变量的范围或性质很有帮助。例如:</target>
        </trans-unit>
        <trans-unit id="c25f48a1ca763d34150d8bac8dc30aeefcd980b5" translate="yes" xml:space="preserve">
          <source>You may get a bus error core dump from the op/pwent or op/grent tests. If compiled with -g you will see a stack trace much like the following:</source>
          <target state="translated">你可能会从op/pwent或op/grent测试中得到一个总线错误核心转储。如果用-g编译,你会看到一个类似下面的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="108b6e50ab8abc6a709ca1e727e6115ff077c1f8" translate="yes" xml:space="preserve">
          <source>You may get a warning when doing a threaded build:</source>
          <target state="translated">在进行线程构建时,你可能会得到一个警告。</target>
        </trans-unit>
        <trans-unit id="22f1e826336ce72e185bd16ea03c1b6430323fa0" translate="yes" xml:space="preserve">
          <source>You may have an optional comma before the closing parenthesis of a list literal, so that you can say:</source>
          <target state="translated">你可以在列表文字的结尾括号前有一个可选的逗号,这样你就可以说。</target>
        </trans-unit>
        <trans-unit id="94ced856f582ad7ad5a45cb74870b4f4ae27ed8b" translate="yes" xml:space="preserve">
          <source>You may have to add extra libraries as well. Which ones? Perhaps those printed by</source>
          <target state="translated">你可能还需要添加额外的库。哪些库?也许是那些由</target>
        </trans-unit>
        <trans-unit id="adc5eceb43ab39f0721310d8a087b92c4cf96e19" translate="yes" xml:space="preserve">
          <source>You may have to re-read this entire section a few times...</source>
          <target state="translated">你可能要重新读几遍这一整节......</target>
        </trans-unit>
        <trans-unit id="9e568be51255384d52fb1c41217e7d274f15f0ca" translate="yes" xml:space="preserve">
          <source>You may ignore the error message for the first element of the archive (this doesn't look like a tar archive / skipping to next file...), it's only the directory which will be created automatically anyway.</source>
          <target state="translated">你可以忽略归档的第一个元素的错误信息(这看起来不像一个tar归档/跳到下一个文件......),它只是自动创建的目录。</target>
        </trans-unit>
        <trans-unit id="927c6b1abd9425ad341215fb99d87b72f734b089" translate="yes" xml:space="preserve">
          <source>You may intersperse documentation and Perl code within the .pm file. In fact, if you want to use method autoloading, you must do this, as the comment inside the .pm file explains.</source>
          <target state="translated">你可以在.pm文件中穿插文档和Perl代码。事实上,如果你想使用方法自动加载,你必须这样做,正如.pm文件中的注释所解释的那样。</target>
        </trans-unit>
        <trans-unit id="b911c24edf96323dfee0b5a16ac2655f93ba03e8" translate="yes" xml:space="preserve">
          <source>You may lock arrays and hashes as well as scalars. Locking an array, though, will not block subsequent locks on array elements, just lock attempts on the array itself.</source>
          <target state="translated">你可以锁定数组、哈希以及标量。不过锁定一个数组不会阻止后续对数组元素的锁定,只是对数组本身的锁定尝试。</target>
        </trans-unit>
        <trans-unit id="00344360ec287bdb5274fbd2e88953a8065f329a" translate="yes" xml:space="preserve">
          <source>You may look into the file</source>
          <target state="translated">你可以查一下文件</target>
        </trans-unit>
        <trans-unit id="9516dc740ae77942efcf6e8fd80e5504a8b1fd26" translate="yes" xml:space="preserve">
          <source>You may mail your bug reports (be sure to include full configuration information as output by the myconfig program in the perl source tree, or by &lt;code&gt;perl -V&lt;/code&gt; ) to perlbug@perl.org . If you've succeeded in compiling perl, the &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; script in the</source>
          <target state="translated">您可以将错误报告（请确保将完整的配置信息作为myconfig程序在perl源树中或 &lt;code&gt;perl -V&lt;/code&gt; 中输出的信息）邮寄到perlbug@perl.org。如果您成功编译了perl，&lt;a href=&quot;perlbug&quot;&gt;请&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="9b598b6ebd49a9a2c8435acfea60cd639dc39cf9" translate="yes" xml:space="preserve">
          <source>You may need the following GNU programs in order to install perl:</source>
          <target state="translated">你可能需要以下GNU程序来安装perl。</target>
        </trans-unit>
        <trans-unit id="65000230f7491853635f8932fbc750e90e8f3c2d" translate="yes" xml:space="preserve">
          <source>You may need to be</source>
          <target state="translated">你可能需要</target>
        </trans-unit>
        <trans-unit id="64a7e3cbbe6d605d5c662e6d4594cef6c6e25ffe" translate="yes" xml:space="preserve">
          <source>You may need to carry out some system configuration tasks before running the Configure script for Perl.</source>
          <target state="translated">在运行Perl的Configure脚本之前,你可能需要执行一些系统配置任务。</target>
        </trans-unit>
        <trans-unit id="d10056deec90cd668c3f12e0f304b01dde73621d" translate="yes" xml:space="preserve">
          <source>You may need to make this change to scripts written for a Unix system which expect that after a call to &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, no files with the names passed to &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will exist. (Note: This can be changed at compile time; if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; and &lt;code&gt;$Config{'d_unlink_all_versions'}&lt;/code&gt; is &lt;code&gt;define&lt;/code&gt; , then &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will delete all versions of a file on the first call.)</source>
          <target state="translated">您可能需要对为Unix系统编写的脚本进行此更改，这些脚本期望在调用 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 之后，不存在名称传递给 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 的文件。 （注意：这可以在编译时更改；如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; 并且 &lt;code&gt;$Config{'d_unlink_all_versions'}&lt;/code&gt; 是 &lt;code&gt;define&lt;/code&gt; ，则 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 将在第一次调用时删除文件的所有版本。）</target>
        </trans-unit>
        <trans-unit id="3ec14405f03df7cdb78bb123848d4a14d07a8d45" translate="yes" xml:space="preserve">
          <source>You may not (usefully) use a reference as the key to a hash. It will be converted into a string:</source>
          <target state="translated">你不可以(有用的)使用引用作为哈希的密钥。它将被转换为一个字符串。</target>
        </trans-unit>
        <trans-unit id="d8a434e0ce88a99bf8a5488e4b0fad4981c52cd7" translate="yes" xml:space="preserve">
          <source>You may not even need to write the module. Check whether it's already been done in Perl, and avoid re-inventing the wheel unless you have a good reason.</source>
          <target state="translated">你可能甚至不需要写模块。检查一下是否已经在Perl中做过了,除非你有充分的理由,否则要避免重新发明轮子。</target>
        </trans-unit>
        <trans-unit id="936986b9e470ced1f7fdf65dd9ad838a32d13386" translate="yes" xml:space="preserve">
          <source>You may not use data derived from outside your program to affect something else outside your program--at least, not by accident. All command line arguments, environment variables, locale information (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), results of certain system calls (&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink()&lt;/a&gt;&lt;/code&gt;, the variable of &lt;code&gt;&lt;a href=&quot;functions/shmread&quot;&gt;shmread()&lt;/a&gt;&lt;/code&gt;, the messages returned by &lt;code&gt;&lt;a href=&quot;functions/msgrcv&quot;&gt;msgrcv()&lt;/a&gt;&lt;/code&gt;, the password, gcos and shell fields returned by the &lt;code&gt;getpwxxx()&lt;/code&gt; calls), and all file input are marked as &quot;tainted&quot;. Tainted data may not be used directly or indirectly in any command that invokes a sub-shell, nor in any command that modifies files, directories, or processes, &lt;b&gt;with the following exceptions&lt;/b&gt;:</source>
          <target state="translated">您可能不会使用从程序外部获取的数据来影响程序外部的其他内容-至少并非偶然。所有命令行参数，环境变量，本地信息（参见&lt;a href=&quot;perllocale&quot;&gt;perllocale手册&lt;/a&gt;），某些系统调用（结果 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink()&lt;/a&gt;&lt;/code&gt; ，可变 &lt;code&gt;&lt;a href=&quot;functions/shmread&quot;&gt;shmread()&lt;/a&gt;&lt;/code&gt; ，通过返回的消息 &lt;code&gt;&lt;a href=&quot;functions/msgrcv&quot;&gt;msgrcv()&lt;/a&gt;&lt;/code&gt; ,密码，GCOS和外壳由 &lt;code&gt;getpwxxx()&lt;/code&gt; 调用返回的字段）和所有文件输入都标记为&amp;ldquo;污染&amp;rdquo;。&lt;b&gt;除以下情况外&lt;/b&gt;，不得在调用子外壳程序的任何命令中或在修改文件，目录或进程的任何命令中直接或间接使用污染数据：</target>
        </trans-unit>
        <trans-unit id="656cab64db0943d80c2c347bdd21c8a07c645dc2" translate="yes" xml:space="preserve">
          <source>You may once in a while try a &quot;make microperl&quot; to see whether we can still compile Perl with just the bare minimum of interfaces. (See README.micro.)</source>
          <target state="translated">你可以偶尔尝试一下 &quot;make microperl&quot;,看看我们是否还能用最低限度的接口来编译Perl。(参见 README.micro.)</target>
        </trans-unit>
        <trans-unit id="67acb9777380059ff280be22d8c3f8940dae8cc7" translate="yes" xml:space="preserve">
          <source>You may or may not choose to follow this usage. But never write &quot;PERL&quot;, because perl is not an acronym.</source>
          <target state="translated">你可以选择也可以不选择遵循这种用法。但千万不要写 &quot;PERL&quot;,因为perl不是一个缩写。</target>
        </trans-unit>
        <trans-unit id="613fbbe8af8f9b1517992c7dc5a2a0283f5a8c13" translate="yes" xml:space="preserve">
          <source>You may override this as you like; Maketext doesn't use it for anything.</source>
          <target state="translated">你可以随意覆盖它,Maketext不会用它来做任何事情。</target>
        </trans-unit>
        <trans-unit id="471b54cb9da3fd2429477493f77011df7439603d" translate="yes" xml:space="preserve">
          <source>You may run into memory limits, in which case you should use the -Xmx option:</source>
          <target state="translated">你可能会遇到内存限制,在这种情况下,你应该使用-Xmx选项。</target>
        </trans-unit>
        <trans-unit id="2b87668ec2b109de55eff18c1a93548bfc928cdb" translate="yes" xml:space="preserve">
          <source>You may see a message about errors while extracting</source>
          <target state="translated">您可能会在解压时看到一条关于错误的信息</target>
        </trans-unit>
        <trans-unit id="567b2cee3d4edcc53c5dd10d0ae801a480e80721" translate="yes" xml:space="preserve">
          <source>You may see some messages during Configure that seem suspicious.</source>
          <target state="translated">在配置过程中,你可能会看到一些看似可疑的信息。</target>
        </trans-unit>
        <trans-unit id="3d40b88fd93e71db6719630cc623bcd6de5e08cd" translate="yes" xml:space="preserve">
          <source>You may see the term &quot;invariant&quot; character or code point. This simply means that the character has the same numeric value and representation when encoded in UTF-8 (or UTF-EBCDIC) as when not. (Note that this is a very different concept from &lt;a href=&quot;#The-13-variant-characters&quot;&gt;The 13 variant characters&lt;/a&gt; mentioned above. Careful prose will use the term &quot;UTF-8 invariant&quot; instead of just &quot;invariant&quot;, but most often you'll see just &quot;invariant&quot;.) For example, the ordinal value of &quot;A&quot; is 193 in most EBCDIC code pages, and also is 193 when encoded in UTF-EBCDIC. All UTF-8 (or UTF-EBCDIC) variant code points occupy at least two bytes when encoded in UTF-8 (or UTF-EBCDIC); by definition, the UTF-8 (or UTF-EBCDIC) invariant code points are exactly one byte whether encoded in UTF-8 (or UTF-EBCDIC), or not. (By now you see why people typically just say &quot;UTF-8&quot; when they also mean &quot;UTF-EBCDIC&quot;. For the rest of this document, we'll mostly be casual about it too.) In ASCII UTF-8, the code points corresponding to the lowest 128 ordinal numbers (0 - 127: the ASCII characters) are invariant. In UTF-EBCDIC, there are 160 invariant characters. (If you care, the EBCDIC invariants are those characters which have ASCII equivalents, plus those that correspond to the C1 controls (128 - 159 on ASCII platforms).)</source>
          <target state="translated">您可能会看到术语&amp;ldquo;不变&amp;rdquo;字符或代码点。这仅表示在使用UTF-8（或UTF-EBCDIC）进行编码时，该字符具有与未使用相同的数字值和表示。 （请注意，这与&lt;a href=&quot;#The-13-variant-characters&quot;&gt;13个变体字符&lt;/a&gt;截然不同上文提到的。细心的散文将使用术语&amp;ldquo; UTF-8不变式&amp;rdquo;，而不仅仅是&amp;ldquo;不变式&amp;rdquo;，但是大多数情况下，您只会看到&amp;ldquo;不变式&amp;rdquo;。）例如，在大多数EBCDIC代码页中，&amp;ldquo; A&amp;rdquo;的序数值为193，以UTF-EBCDIC编码时也为193。当以UTF-8（或UTF-EBCDIC）进行编码时，所有UTF-8（或UTF-EBCDIC）变体代码点至少占据两个字节；根据定义，无论是否以UTF-8（或UTF-EBCDIC）进行编码，UTF-8（或UTF-EBCDIC）不变代码点都是一个字节。 （到现在为止，您就会明白为什么人们在通常也表示&amp;ldquo; UTF-EBCDIC&amp;rdquo;的情况下通常只说&amp;ldquo; UTF-8&amp;rdquo;。对于本文档的其余部分，我们也会大为随意。）在ASCII UTF-8中，与最低的128个序数（0-127：ASCII字符）相对应的代码点是不变的。在UTF-EBCDIC中，有160个不变字符。 （如果需要，EBCDIC不变量是指具有ASCII等价字符的字符，以及与C1控件相对应的字符（在ASCII平台上为128-159）。）</target>
        </trans-unit>
        <trans-unit id="fa093d809cde8bd253ba564171319f316c1ecb65" translate="yes" xml:space="preserve">
          <source>You may set the &lt;code&gt;dw_size&lt;/code&gt; option to limit the amount of data that can be saved in the deferred write buffer. This limit may not exceed the total memory limit. For example, if you set &lt;code&gt;dw_size&lt;/code&gt; to 1000 and &lt;code&gt;memory&lt;/code&gt; to 2500, that means that no more than 1000 bytes of deferred writes will be saved up. The space available for the read cache will vary, but it will always be at least 1500 bytes (if the deferred write buffer is full) and it could grow as large as 2500 bytes (if the deferred write buffer is empty.)</source>
          <target state="translated">您可以设置 &lt;code&gt;dw_size&lt;/code&gt; 选项以限制可以保存在延迟写入缓冲区中的数据量。此限制不能超过总内存限制。例如，如果将 &lt;code&gt;dw_size&lt;/code&gt; 设置为1000，将 &lt;code&gt;memory&lt;/code&gt; 为2500，则意味着最多可以保存1000个字节的延迟写入。读缓存的可用空间会有所不同，但始终至少为1500字节（如果延迟的写缓冲区已满），并且可能会增长到2500字节（如果延迟的写缓冲区为空）。</target>
        </trans-unit>
        <trans-unit id="fbe802847d2e9437afa3772a7f3ed12ac0cb75f5" translate="yes" xml:space="preserve">
          <source>You may use any combination of these three values 'SUCCESS','FAILURE','DELAY' in the anonymous array reference as defined by RFC3461 (see &lt;a href=&quot;http://www.ietf.org/rfc/rfc3461.txt&quot;&gt;http://www.ietf.org/rfc/rfc3461.txt&lt;/a&gt; for more information. Note: quotations in this topic from same.).</source>
          <target state="translated">您可以在RFC3461定义的匿名数组引用中使用这三个值'SUCCESS'，'FAILURE'，'DELAY'的任意组合（有关更多信息，请参见&lt;a href=&quot;http://www.ietf.org/rfc/rfc3461.txt&quot;&gt;http://www.ietf.org/rfc/rfc3461.txt）&lt;/a&gt;。注意：本主题中的引号相同。）。</target>
        </trans-unit>
        <trans-unit id="3726ab64bc777be024735266d80e288f34e7bd83" translate="yes" xml:space="preserve">
          <source>You may use the &lt;code&gt;mv&lt;/code&gt; alias for this function in the same way that you may use the &lt;code&gt;cp&lt;/code&gt; alias for &lt;code&gt;copy&lt;/code&gt; .</source>
          <target state="translated">可以将 &lt;code&gt;mv&lt;/code&gt; 别名用于此功能，就像将 &lt;code&gt;cp&lt;/code&gt; 别名用于 &lt;code&gt;copy&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="9368b724095114d596f9a9bbd047855f785492a1" translate="yes" xml:space="preserve">
          <source>You may use the syntax &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; File::Copy &quot;cp&quot;&lt;/code&gt; to get at the &lt;code&gt;cp&lt;/code&gt; alias for this function. The syntax is</source>
          <target state="translated">您可以使用语法 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; File::Copy &quot;cp&quot;&lt;/code&gt; 来获取此函数的 &lt;code&gt;cp&lt;/code&gt; 别名。语法是</target>
        </trans-unit>
        <trans-unit id="2ef4fe61a399da32f9cc97283defa049459439a2" translate="yes" xml:space="preserve">
          <source>You may want to configure something like</source>
          <target state="translated">你可能想配置一些像</target>
        </trans-unit>
        <trans-unit id="274166c866cd17a4a70da3e9dd16359e3df50e0e" translate="yes" xml:space="preserve">
          <source>You may want to use the &lt;code&gt;&lt;a href=&quot;perlrecharclass#Digits&quot;&gt;/\d/&lt;/a&gt;&lt;/code&gt; construct instead.</source>
          <target state="translated">您可能要改用 &lt;code&gt;&lt;a href=&quot;perlrecharclass#Digits&quot;&gt;/\d/&lt;/a&gt;&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="3d3a0b34238678a39ac71745f1262bf0f4700e24" translate="yes" xml:space="preserve">
          <source>You may want to use the &lt;code&gt;&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;/\s/&lt;/a&gt;&lt;/code&gt; construct instead.</source>
          <target state="translated">您可能要改用 &lt;code&gt;&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;/\s/&lt;/a&gt;&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="30ce0fc76dee65d768e8b8edbb86d17b3ec69cef" translate="yes" xml:space="preserve">
          <source>You may want to use the &lt;code&gt;&lt;a href=&quot;perlrecharclass#Word-characters&quot;&gt;/\w/&lt;/a&gt;&lt;/code&gt; construct instead.</source>
          <target state="translated">您可能要改用 &lt;code&gt;&lt;a href=&quot;perlrecharclass#Word-characters&quot;&gt;/\w/&lt;/a&gt;&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="599db7e90374e2462ae43e1deb74b5ede6e00ac9" translate="yes" xml:space="preserve">
          <source>You may wish to put your version of perl in the PATH of all users by changing the link</source>
          <target state="translated">您可能希望将您的perl版本放在所有用户的PATH中,方法是更改以下链接</target>
        </trans-unit>
        <trans-unit id="a667970ef9d2de2018d0cc9d89b6040168c92e68" translate="yes" xml:space="preserve">
          <source>You might also be interested in using the &lt;a href=&quot;benchmark&quot;&gt;Benchmark&lt;/a&gt; to measure and compare code snippets.</source>
          <target state="translated">您可能还对使用&lt;a href=&quot;benchmark&quot;&gt;基准&lt;/a&gt;来测量和比较代码段感兴趣。</target>
        </trans-unit>
        <trans-unit id="f2fb8d4423459616a83c78e11c0c6368281abff5" translate="yes" xml:space="preserve">
          <source>You might also find it more fun to use the standard &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module, or the &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; module's &lt;code&gt;$DB_RECNO&lt;/code&gt; bindings, which allow you to tie an array to a file so that accessing an element of the array actually accesses the corresponding line in the file.</source>
          <target state="translated">您可能还会发现使用标准的&lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt;模块或&lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt;模块的 &lt;code&gt;$DB_RECNO&lt;/code&gt; 绑定会更有趣，该绑定使您可以将数组绑定到文件，以便访问数组的元素实际上可以访问数组中的相应行。文件。</target>
        </trans-unit>
        <trans-unit id="e08469744ffe89846f236eef2581143171c3fbcd" translate="yes" xml:space="preserve">
          <source>You might also have loaded that from a function:</source>
          <target state="translated">你也可能是从一个函数中加载的。</target>
        </trans-unit>
        <trans-unit id="95a16ffa9a148d97aba69dab68818a05442a9c0f" translate="yes" xml:space="preserve">
          <source>You might also see the terms &lt;b&gt;getter&lt;/b&gt; and &lt;b&gt;setter&lt;/b&gt;. These are two types of accessors. A getter gets the attribute's value, while a setter sets it. Another term for a setter is &lt;b&gt;mutator&lt;/b&gt;</source>
          <target state="translated">您可能还会看到术语&lt;b&gt;getter&lt;/b&gt;和&lt;b&gt;setter&lt;/b&gt;。这是两种类型的访问器。获取器获取属性的值，而设置器设置属性的值。setter的另一个术语是&lt;b&gt;mutator&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a6f4008d05ac5a7684642f452fcea99bbe63649d" translate="yes" xml:space="preserve">
          <source>You might also think of closure as a way to write a subroutine template without using eval(). Here's a small example of how closures work:</source>
          <target state="translated">你也可以把闭包看作是一种不使用eval()而编写子程序模板的方法。下面是一个关于闭包如何工作的小例子。</target>
        </trans-unit>
        <trans-unit id="b07a183cbfa7c2c5ada23e1358bb836c0036ff82" translate="yes" xml:space="preserve">
          <source>You might also want to check out &lt;a href=&quot;perlfaq8#How-do-I-keep-my-own-module%2flibrary-directory%3f&quot;&gt;How do I keep my own module/library directory? in perlfaq8&lt;/a&gt;.</source>
          <target state="translated">您可能还想查看&lt;a href=&quot;perlfaq8#How-do-I-keep-my-own-module%2flibrary-directory%3f&quot;&gt;如何保留自己的模块/库目录？在perlfaq8中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9d50c5088a6a6db1dd16f71b5a0b7ad311259d2" translate="yes" xml:space="preserve">
          <source>You might also want to employ anonymous functions for simple signal handlers:</source>
          <target state="translated">你可能还想为简单的信号处理程序采用匿名函数。</target>
        </trans-unit>
        <trans-unit id="c4f0a4c3456aabab2b8397ba18c3d239195efdd9" translate="yes" xml:space="preserve">
          <source>You might also want to have GNU groff for OS/390 installed before running the &quot;make install&quot; step for Perl.</source>
          <target state="translated">在运行 Perl 的 &quot;make install &quot;步骤之前,你可能还需要安装 GNU groff for OS/390。</target>
        </trans-unit>
        <trans-unit id="2fa0f7304d269ada4e265c5dcd91a35489923597" translate="yes" xml:space="preserve">
          <source>You might also want to trap any errors by wrapping an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block around the whole thing.</source>
          <target state="translated">您可能还想通过将 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 块包裹在整个对象上来捕获任何错误。</target>
        </trans-unit>
        <trans-unit id="ae14caefeb104abfd32e1ac4b08ddaa6c43442c2" translate="yes" xml:space="preserve">
          <source>You might be tempted to think that deferred writing is like transactions, with &lt;code&gt;flush&lt;/code&gt; as &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;discard&lt;/code&gt; as &lt;code&gt;rollback&lt;/code&gt; , but it isn't, so don't.</source>
          <target state="translated">您可能会倾向于认为延迟写入就像是事务，将 &lt;code&gt;flush&lt;/code&gt; 作为 &lt;code&gt;commit&lt;/code&gt; ， &lt;code&gt;discard&lt;/code&gt; 作为 &lt;code&gt;rollback&lt;/code&gt; ，但是事实并非如此，所以不要这样做。</target>
        </trans-unit>
        <trans-unit id="eadb7f27713b1af6126dec14d8fa3f25be31b545" translate="yes" xml:space="preserve">
          <source>You might be tempted to use &lt;code&gt;$#array + 1&lt;/code&gt; to tell you how many items there are in an array. Don't bother. As it happens, using &lt;code&gt;@array&lt;/code&gt; where Perl expects to find a scalar value (&quot;in scalar context&quot;) will give you the number of elements in the array:</source>
          <target state="translated">您可能会想使用 &lt;code&gt;$#array + 1&lt;/code&gt; 来告诉您数组中有多少个项目。不要打扰 碰巧的是，在Perl期望找到标量值的地方使用&amp;ldquo; &lt;code&gt;@array&lt;/code&gt; &amp;rdquo;（&amp;ldquo;在标量上下文中&amp;rdquo;）将为您提供数组中元素的数量：</target>
        </trans-unit>
        <trans-unit id="cdd5e43c44200a95eaa3aa45d374b3ef4d1b96c7" translate="yes" xml:space="preserve">
          <source>You might consider using just Math::BigInt or Math::BigFloat, since they allow you finer control over what get's done in which module/space. For instance, simple loop counters will be Math::BigInts under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bignum;&lt;/code&gt; and this is slower than keeping them as Perl scalars:</source>
          <target state="translated">您可能会考虑只使用Math :: BigInt或Math :: BigFloat，因为它们使您可以更好地控制在哪个模块/空间中完成的工作。例如，简单的循环计数器将是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bignum;&lt;/code&gt; Math :: BigInts ；这比将它们保持为Perl标量要慢：</target>
        </trans-unit>
        <trans-unit id="602086881bebd3c9c81540dfd1686b9dc1e9a7c1" translate="yes" xml:space="preserve">
          <source>You might expect this to output &quot;12&quot;. In fact, it prints &quot;&amp;lt;&quot;: the ASCII result of treating &quot;|&quot; as a bitwise string operator - that is, the result of treating the operands as the strings &quot;4&quot; and &quot;8&quot; rather than numbers. The fact that numify (&lt;code&gt;0+&lt;/code&gt; ) is implemented but stringify (&lt;code&gt;&quot;&quot;&lt;/code&gt; ) isn't makes no difference since the latter is simply autogenerated from the former.</source>
          <target state="translated">您可能希望它输出&amp;ldquo; 12&amp;rdquo;。实际上，它会打印&amp;ldquo; &amp;lt;&amp;rdquo;：处理&amp;ldquo; |&amp;rdquo;的ASCII结果 作为按位的字符串运算符-即，将操作数视为字符串&amp;ldquo; 4&amp;rdquo;和&amp;ldquo; 8&amp;rdquo;而不是数字的结果。实现numify（ &lt;code&gt;0+&lt;/code&gt; ）而实现stringify（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）并没有什么不同，因为后者只是从前者自动生成的。</target>
        </trans-unit>
        <trans-unit id="ec2b6e72cccd9ea401a92e1c584d3ce729f0ed23" translate="yes" xml:space="preserve">
          <source>You might find these links useful:</source>
          <target state="translated">你可能会发现这些链接很有用。</target>
        </trans-unit>
        <trans-unit id="7041884103fb3be2206f9857bdd3e655cde0bf34" translate="yes" xml:space="preserve">
          <source>You might have expected test 3 to fail because it seems to a more general purpose version of test 1. The important difference between them is that test 3 contains a quantifier (&lt;code&gt;\D*&lt;/code&gt; ) and so can use backtracking, whereas test 1 will not. What's happening is that you've asked &quot;Is it true that at the start of $x, following 0 or more non-digits, you have something that's not 123?&quot; If the pattern matcher had let &lt;code&gt;\D*&lt;/code&gt; expand to &quot;ABC&quot;, this would have caused the whole pattern to fail.</source>
          <target state="translated">您可能希望测试3失败，因为它似乎是测试1的通用版本。它们之间的重要区别在于，测试3包含量词（ &lt;code&gt;\D*&lt;/code&gt; ），因此可以使用回溯，而测试1则不会。发生的事情是，您问&amp;ldquo;在$ x的开头，跟随0或多个非数字，您的值不是123吗？&amp;rdquo; 如果模式匹配器将 &lt;code&gt;\D*&lt;/code&gt; 扩展为&amp;ldquo; ABC&amp;rdquo;，则将导致整个模式失败。</target>
        </trans-unit>
        <trans-unit id="f5bd0f9bdd3b3f8f6c3d7920cb7c553cce6d6284" translate="yes" xml:space="preserve">
          <source>You might like to read Mark Jason Dominus's &quot;Suffering From Buffering&quot; at &lt;a href=&quot;http://perl.plover.com/FAQs/Buffering.html&quot;&gt;http://perl.plover.com/FAQs/Buffering.html&lt;/a&gt; .</source>
          <target state="translated">您可能想在&lt;a href=&quot;http://perl.plover.com/FAQs/Buffering.html&quot;&gt;http://perl.plover.com/FAQs/Buffering.html&lt;/a&gt;上阅读Mark Jason Dominus的&amp;ldquo;遭受缓冲&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="d5e0af742e5a24576127c7192de3da3f64667af3" translate="yes" xml:space="preserve">
          <source>You might like to use &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; to read in a program configuration file. Manual error checking can be done this way:</source>
          <target state="translated">您可能想使用 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 读取程序配置文件。可以通过以下方式进行手动错误检查：</target>
        </trans-unit>
        <trans-unit id="ea3e43e35b42104c2dfdbbb81763643be691010c" translate="yes" xml:space="preserve">
          <source>You might like to use &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; to read in a program configuration file. Manual error checking can be done this way:</source>
          <target state="translated">您可能想使用 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 读取程序配置文件。可以通过以下方式进行手动错误检查：</target>
        </trans-unit>
        <trans-unit id="052100b20ac103ab19054e70ed9a9d17e374ebf5" translate="yes" xml:space="preserve">
          <source>You might love it. You might feel that everyone else needs it. But there might not actually be any real demand for it out there. If you're unsure about the demand your module will have, consider sending out feelers on the &lt;code&gt;comp.lang.perl.modules&lt;/code&gt; newsgroup, or as a last resort, ask the modules list at &lt;code&gt;modules@perl.org&lt;/code&gt; . Remember that this is a closed list with a very long turn-around time - be prepared to wait a good while for a response from them.</source>
          <target state="translated">您可能会喜欢。您可能会觉得其他所有人都需要它。但是实际上可能没有任何实际需求。如果您不确定模块的需求，请考虑在 &lt;code&gt;comp.lang.perl.modules&lt;/code&gt; 新闻组中发送探针，或者作为最后的选择，在 &lt;code&gt;modules@perl.org&lt;/code&gt; 上询问模块列表。请记住，这是一个关闭列表，周转时间很长-请准备好等待一段时间，以便得到他们的答复。</target>
        </trans-unit>
        <trans-unit id="169bde04d58834aed9e29a6302664c4d13ccbcd6" translate="yes" xml:space="preserve">
          <source>You might not need all the power of XS. The Inline::C module lets you put C code directly in your Perl source. It handles all the magic to make it work. You still have to learn at least some of the perl API but you won't have to deal with the complexity of the XS support files.</source>
          <target state="translated">你可能不需要XS的所有功能。Inline::C模块可以让你直接在Perl源代码中加入C代码。它处理了所有的魔法,使其工作。你仍然需要学习至少一些perl API,但你不必处理复杂的XS支持文件。</target>
        </trans-unit>
        <trans-unit id="3b031c43f33840adc70b02de47a8fd1daefabaa6" translate="yes" xml:space="preserve">
          <source>You might notice several familiar Perl concepts in this collection of ACM columns from Jon Bentley. The similarity to the title of the major Perl book (which came later) is not completely accidental:</source>
          <target state="translated">你可能会注意到,在Jon Bentley的这本ACM专栏集中,有几个熟悉的Perl概念。与主要的Perl书籍(后来才有的)的标题相似并非完全偶然。</target>
        </trans-unit>
        <trans-unit id="66fdf1bb9d02362c3ab6fa3feaa38bdbfcec77f8" translate="yes" xml:space="preserve">
          <source>You might notice that you could use backticks for much the same effect as opening a pipe for reading:</source>
          <target state="translated">你可能会注意到,你可以用背杆来达到和开管阅读差不多的效果。</target>
        </trans-unit>
        <trans-unit id="42704287df9412e9063781246ba069342cd72b32" translate="yes" xml:space="preserve">
          <source>You might notice this when each of the elements of &lt;code&gt;@array&lt;/code&gt; end with a newline. You expect to print one element per line, but notice that every line after the first is indented:</source>
          <target state="translated">当 &lt;code&gt;@array&lt;/code&gt; 的每个元素以换行符结尾时，您可能会注意到这一点。您希望每行打印一个元素，但是请注意，第一行之后的每一行都是缩进的：</target>
        </trans-unit>
        <trans-unit id="e3ccde21cef99ed04d4c1fb15da658aad8223bd5" translate="yes" xml:space="preserve">
          <source>You might prefer to go on to &lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt; instead of &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;; it discusses lists of lists and multidimensional arrays in detail. After that, you should move on to &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt;; it's a Data Structure Cookbook that shows recipes for using and printing out arrays of hashes, hashes of arrays, and other kinds of data.</source>
          <target state="translated">您可能更喜欢&lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt;而不是&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;；它详细讨论了列表列表和多维数组。之后，您应该继续进行&lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt;；这是一本数据结构手册，其中显示了使用和打印哈希数组，数组哈希以及其他类型数据的方法。</target>
        </trans-unit>
        <trans-unit id="a6310ecb45c68b753610be852acb876a80aa3c10" translate="yes" xml:space="preserve">
          <source>You might relate this to a fictional 'Translate' module:</source>
          <target state="translated">你可以把它和一个虚构的 &quot;翻译 &quot;模块联系起来。</target>
        </trans-unit>
        <trans-unit id="13ab2e65d93fb0059f6f55ed6a75f22913178d96" translate="yes" xml:space="preserve">
          <source>You might remember &lt;code&gt;ok() or diag()&lt;/code&gt; with the mnemonic &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;() or
&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;()&lt;/code&gt; .</source>
          <target state="translated">您可能还记得 &lt;code&gt;ok() or diag()&lt;/code&gt; 以及助记符 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;() or &lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37d4864369383102be2440cd5c5cb4b7987e528b" translate="yes" xml:space="preserve">
          <source>You might sometimes see reference to Rule 1 and Rule 2. Larry's power as Supreme Court is expressed in The Rules:</source>
          <target state="translated">你有时可能会看到对规则1和规则2的参考。拉里作为最高法院的权力在《规则》中得到了体现。</target>
        </trans-unit>
        <trans-unit id="f5b7d1197bc89948add2ed3f352d319d84d2e28b" translate="yes" xml:space="preserve">
          <source>You might try &lt;a href=&quot;encode/guess&quot;&gt;Encode::Guess&lt;/a&gt;, but it has a number of limitations.</source>
          <target state="translated">您可以尝试&lt;a href=&quot;encode/guess&quot;&gt;Encode :: Guess&lt;/a&gt;，但是它有很多限制。</target>
        </trans-unit>
        <trans-unit id="193b85d5b4fe0e90a0d9c66d7d0b78036e923063" translate="yes" xml:space="preserve">
          <source>You might want to do the same thing for expressing key bindings or the like (since hardwiring &quot;q&quot; as the binding for the function that quits a screen/menu/program is useful only if your language happens to associate &quot;q&quot; with &quot;quit&quot;!)</source>
          <target state="translated">你可能想对表达键绑定或类似的东西做同样的事情(因为只有当你的语言恰好将 &quot;q &quot;与 &quot;quit &quot;联系在一起时,将 &quot;q &quot;作为退出屏幕/菜单/程序的函数绑定才会有用!)。</target>
        </trans-unit>
        <trans-unit id="b5d495d915ce638287be04e211dc9e03d5ac46bf" translate="yes" xml:space="preserve">
          <source>You might want to keep these desktop references close by your keyboard:</source>
          <target state="translated">你可能想把这些桌面参考资料放在键盘旁。</target>
        </trans-unit>
        <trans-unit id="0d1eb54f95a4e04b463b84dfe6de9e8067695824" translate="yes" xml:space="preserve">
          <source>You might wonder why &lt;code&gt;'.'&lt;/code&gt; matches everything but &lt;code&gt;&quot;\n&quot;&lt;/code&gt; - why not every character? The reason is that often one is matching against lines and would like to ignore the newline characters. For instance, while the string &lt;code&gt;&quot;\n&quot;&lt;/code&gt; represents one line, we would like to think of it as empty. Then</source>
          <target state="translated">您可能想知道为什么 &lt;code&gt;'.'&lt;/code&gt; 匹配除 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 所有字符-为什么不匹配每个字符？原因是经常有人将其与行匹配并且想忽略换行符。例如，虽然字符串 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 代表一行，但我们希望将其视为空。然后</target>
        </trans-unit>
        <trans-unit id="e851d081cca3db1538b95133dfa4e2591e66b038" translate="yes" xml:space="preserve">
          <source>You must Configure perl with</source>
          <target state="translated">你必须在配置perl时使用</target>
        </trans-unit>
        <trans-unit id="c18657846c86f19718177ea80036f400e403ff68" translate="yes" xml:space="preserve">
          <source>You must be triply conscious of cross-platform concerns. This usually boils down to using &lt;a href=&quot;file/spec&quot;&gt;File::Spec&lt;/a&gt;, avoiding things like &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; unless absolutely necessary, and not assuming that a given character has a particular ordinal value (code point) or that its UTF-8 representation is composed of particular bytes.</source>
          <target state="translated">您必须三重意识到跨平台问题。这通常归结为使用&lt;a href=&quot;file/spec&quot;&gt;File :: Spec&lt;/a&gt;，除非绝对必要，否则避免使用 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 之类的东西，并且不假定给定字符具有特定的序数值（代码点）或它的UTF-8表示形式构成的特定字节。</target>
        </trans-unit>
        <trans-unit id="8daf2a31e4062052794994fb1a77c6bf915b4376" translate="yes" xml:space="preserve">
          <source>You must call &lt;code&gt;plan(...)&lt;/code&gt; once and only once. You should call it in a &lt;code&gt;BEGIN {...}&lt;/code&gt; block, like so:</source>
          <target state="translated">您只能调用一次 &lt;code&gt;plan(...)&lt;/code&gt; 。您应该在 &lt;code&gt;BEGIN {...}&lt;/code&gt; 块中调用它，如下所示：</target>
        </trans-unit>
        <trans-unit id="0d9b102a51e636379025c1716da72ec7158d144f" translate="yes" xml:space="preserve">
          <source>You must have a plan.</source>
          <target state="translated">你必须有一个计划。</target>
        </trans-unit>
        <trans-unit id="f323bd128da70502b49397ad0f7c4f483197be9e" translate="yes" xml:space="preserve">
          <source>You must have a project base class, which you load, and which you then use as the first argument in the call to YourProjClass-&amp;gt;get_handle(...). It should derive (whether directly or indirectly) from Locale::Maketext. It &lt;b&gt;doesn't matter&lt;/b&gt; how you name this class, although assuming this is the localization component of your Super Mega Program, good names for your project class might be SuperMegaProgram::Localization, SuperMegaProgram::L10N, SuperMegaProgram::I18N, SuperMegaProgram::International, or even SuperMegaProgram::Languages or SuperMegaProgram::Messages.</source>
          <target state="translated">您必须具有一个项目基类，该基类必须加载，然后用作调用YourProjClass-&amp;gt; get_handle（...）的第一个参数。它应该（无论是直接还是间接）从Locale :: Maketext派生。这&lt;b&gt;不要紧，&lt;/b&gt;你如何命名这个类，但假设这是你的超大型项目的本地化部件，为您的项目类的好名字可能是SuperMegaProgram ::本地化，SuperMegaProgram ::本地化，SuperMegaProgram ::国际化，SuperMegaProgram ::国际，甚至SuperMegaProgram :: Languages或SuperMegaProgram :: Messages。</target>
        </trans-unit>
        <trans-unit id="739cc975a787be41633b91aa5de71e36b127ddec" translate="yes" xml:space="preserve">
          <source>You must install the &lt;code&gt;Expect&lt;/code&gt; module to use &lt;code&gt;eexpect&lt;/code&gt; . CPAN.pm does not install it for you.</source>
          <target state="translated">您必须安装 &lt;code&gt;Expect&lt;/code&gt; 模块才能使用 &lt;code&gt;eexpect&lt;/code&gt; 。CPAN.pm不会为您安装它。</target>
        </trans-unit>
        <trans-unit id="72fde4fbc93c4a749f9096aea6d3bd9a70e80b1d" translate="yes" xml:space="preserve">
          <source>You must install the &lt;code&gt;Expect&lt;/code&gt; module to use &lt;code&gt;expect&lt;/code&gt; . CPAN.pm does not install it for you.</source>
          <target state="translated">您必须安装 &lt;code&gt;Expect&lt;/code&gt; 到使用模块 &lt;code&gt;expect&lt;/code&gt; 。CPAN.pm不会为您安装它。</target>
        </trans-unit>
        <trans-unit id="4490a879ca5d596cdf1f67e2681afb5d54f17c52" translate="yes" xml:space="preserve">
          <source>You must make sure that any paths and path components are properly surrounded with double-quotes if they contain spaces. For example, &lt;code&gt;$potential_libs&lt;/code&gt; could be (literally):</source>
          <target state="translated">如果路径和路径组件包含空格，则必须确保用双引号将其正确包围。例如， &lt;code&gt;$potential_libs&lt;/code&gt; 可以是（字面上）：</target>
        </trans-unit>
        <trans-unit id="30c4fd5a99a25cad991844e3c5c4f7509fd399a0" translate="yes" xml:space="preserve">
          <source>You must open your files before you print to them.</source>
          <target state="translated">您必须在打印之前打开文件。</target>
        </trans-unit>
        <trans-unit id="45897939488bd63d927112e2ca64e2fec16238a0" translate="yes" xml:space="preserve">
          <source>You must override the abstract methods as noted above.</source>
          <target state="translated">你必须覆盖上面提到的抽象方法。</target>
        </trans-unit>
        <trans-unit id="2aa81922480ed45c435c4cf0c99c4c4aba3634fc" translate="yes" xml:space="preserve">
          <source>You must use &lt;code&gt;elsif&lt;/code&gt; rather than &lt;code&gt;else if&lt;/code&gt; .</source>
          <target state="translated">您必须使用 &lt;code&gt;elsif&lt;/code&gt; 而不是 &lt;code&gt;else if&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39c7a78d87a43f543e7180d2370d441ee16c546b" translate="yes" xml:space="preserve">
          <source>You must use an ANSI C compiler to build perl. Perl can be compiled with either Sun's add-on C compiler or with gcc. The C compiler that shipped with SunOS4 will not do.</source>
          <target state="translated">你必须使用ANSI C编译器来编译perl。Perl 可以用 Sun 的附加 C 编译器或 gcc 编译。SunOS4附带的C编译器是不行的。</target>
        </trans-unit>
        <trans-unit id="c168b8ed4e8b351eba14fd33d598861cf2969e22" translate="yes" xml:space="preserve">
          <source>You must yourself do any alignment or padding by inserting, for example, enough &lt;code&gt;&quot;x&quot;&lt;/code&gt; es while packing. There is no way for pack() and unpack() to know where characters are going to or coming from, so they handle their output and input as flat sequences of characters.</source>
          <target state="translated">您必须自己进行任何对齐或填充操作，例如在包装时插入足够的 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 。pack（）和unpack（）无法知道字符的去向或来源，因此它们将输出和输入作为字符的平面序列来处理。</target>
        </trans-unit>
        <trans-unit id="495ba80801ecf71f6944f8f06ac3f6b0ec33f568" translate="yes" xml:space="preserve">
          <source>You need a &quot;make&quot; program to build the sources. If you are using Visual C++ or the Windows SDK tools, nmake will work. Builds using the gcc need dmake.</source>
          <target state="translated">你需要一个 &quot;make &quot;程序来构建源代码。如果你使用Visual C++或Windows SDK工具,nmake就可以。使用gcc编译则需要dmake。</target>
        </trans-unit>
        <trans-unit id="384c0cf5619a59f9ce19e0cd720b3f9bfb700b5a" translate="yes" xml:space="preserve">
          <source>You need a separate perl executable</source>
          <target state="translated">你需要一个单独的perl可执行文件</target>
        </trans-unit>
        <trans-unit id="aa34c474feea2ebcd51fe52bc61e21c7aa534d7c" translate="yes" xml:space="preserve">
          <source>You need an installed and working gccsdk cross compiler &lt;a href=&quot;http://gccsdk.riscos.info/&quot;&gt;http://gccsdk.riscos.info/&lt;/a&gt; and REXEN &lt;a href=&quot;http://www.cp15.org/programming/&quot;&gt;http://www.cp15.org/programming/&lt;/a&gt;</source>
          <target state="translated">您需要一个已安装且正在运行的gccsdk交叉编译器&lt;a href=&quot;http://gccsdk.riscos.info/&quot;&gt;http://gccsdk.riscos.info/&lt;/a&gt;和REXEN &lt;a href=&quot;http://www.cp15.org/programming/&quot;&gt;http://www.cp15.org/programming/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4caefc1d4e2631b1200ec354d43fce32735ee7c7" translate="yes" xml:space="preserve">
          <source>You need at the very least AmigaOS version 2.0. Recommended is version 3.1.</source>
          <target state="translated">你至少需要AmigaOS 2.0版本。推荐的是3.1版本。</target>
        </trans-unit>
        <trans-unit id="5333f88ac5bf8fd24e224f0d8051b5fec4dfc6b5" translate="yes" xml:space="preserve">
          <source>You need the Unix emulation for AmigaOS, whose most important part is &lt;b&gt;ixemul.library&lt;/b&gt;. For a minimum setup, get the latest versions of the following packages from the Aminet archives ( &lt;a href=&quot;http://www.aminet.net/~aminet/&quot;&gt;http://www.aminet.net/~aminet/&lt;/a&gt; ):</source>
          <target state="translated">您需要用于AmigaOS的Unix仿真，其最重要的部分是&lt;b&gt;ixemul.library&lt;/b&gt;。对于最低设置，请从Aminet存档（&lt;a href=&quot;http://www.aminet.net/~aminet/&quot;&gt;http://www.aminet.net/~aminet/&lt;/a&gt;）中获取以下软件包的最新版本：</target>
        </trans-unit>
        <trans-unit id="46e89c73cbc6b5dd39fd756e0f6110a1446e5be5" translate="yes" xml:space="preserve">
          <source>You need the following files to build perl (or add new modules):</source>
          <target state="translated">你需要以下文件来构建perl(或添加新模块)。</target>
        </trans-unit>
        <trans-unit id="9f9c012bcf4380f633cf4f7379c24b96c60ecb4b" translate="yes" xml:space="preserve">
          <source>You need to add either braces or blanks to disambiguate.</source>
          <target state="translated">你需要加括号或空白来消除歧义。</target>
        </trans-unit>
        <trans-unit id="cd33ddce78ff1c7340f83b621a3b3b7072ee0d07" translate="yes" xml:space="preserve">
          <source>You need to apply the patches in</source>
          <target state="translated">你需要以</target>
        </trans-unit>
        <trans-unit id="1e3349f1cb25ac13b86ae16e145a0b5decd29f3c" translate="yes" xml:space="preserve">
          <source>You need to correct all the entries which look like file paths (they currently start with &lt;code&gt;f:/&lt;/code&gt;).</source>
          <target state="translated">您需要更正所有看起来像文件路径的条目（它们当前以 &lt;code&gt;f:/&lt;/code&gt; 开头）。</target>
        </trans-unit>
        <trans-unit id="ac623d9d2638d8e7b4db69f0dfe7d1ff10e6b5e8" translate="yes" xml:space="preserve">
          <source>You need to create a local file or directory handle or a local function.</source>
          <target state="translated">你需要创建一个本地文件或目录句柄或一个本地函数。</target>
        </trans-unit>
        <trans-unit id="f1f5eb114f0c20a6807ea82566cc5f87d3a50a5b" translate="yes" xml:space="preserve">
          <source>You need to fetch the latest perl source (including developers releases). With some probability it is located in</source>
          <target state="translated">你需要获取最新的perl源代码(包括开发者发布的版本)。它很有可能位于</target>
        </trans-unit>
        <trans-unit id="965f03aeeab996c747b3c012ec9e65e74625b61a" translate="yes" xml:space="preserve">
          <source>You need to give a global variable a temporary value, especially $_.</source>
          <target state="translated">你需要给全局变量一个临时值,尤其是$_。</target>
        </trans-unit>
        <trans-unit id="4566431899ec1f0737bac24e93a9db0aa49d528e" translate="yes" xml:space="preserve">
          <source>You need to have the latest &lt;b&gt;ixemul&lt;/b&gt; (Unix emulation for Amiga) from Aminet.</source>
          <target state="translated">您需要具有&lt;b&gt;Aminet&lt;/b&gt;的最新&lt;b&gt;ixemul&lt;/b&gt;（Amiga的Unix仿真）。</target>
        </trans-unit>
        <trans-unit id="a7ac6e008f84ae7c7059b678b8182fe611763a32" translate="yes" xml:space="preserve">
          <source>You need to have the latest EMX development environment, the full GNU tool suite (gawk renamed to awk, and GNU</source>
          <target state="translated">你需要有最新的EMX开发环境,完整的GNU工具套件(gawk改名为awk,以及GNU</target>
        </trans-unit>
        <trans-unit id="f0226c50fdff6c76ac2211b429b8387e73ade57a" translate="yes" xml:space="preserve">
          <source>You need to have zlib 1.2.1 or better if you want to use the &lt;code&gt;-Merge&lt;/code&gt; option with &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; , &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; and &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; .</source>
          <target state="translated">如果要将 &lt;code&gt;-Merge&lt;/code&gt; 选项与 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; ， &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 和 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 结合使用，则需要zlib 1.2.1或更高版本。</target>
        </trans-unit>
        <trans-unit id="f7d2bb828dde58ca4350b2c6d38a82848f926212" translate="yes" xml:space="preserve">
          <source>You need to make sure your script is executable, is accessible by the user CGI is running the script under (which is probably not the user account you tested it under), does not rely on any environment variables (like PATH) from the user it isn't running under, and isn't in a location where the CGI server can't find it, basically, more or less. Please see the following for more information:</source>
          <target state="translated">你需要确保你的脚本是可执行的,是CGI运行脚本的用户可以访问的(这可能不是你测试的用户账户),不依赖任何环境变量(比如PATH),不在CGI服务器找不到的位置,基本上,或多或少。详情请看下面的内容。</target>
        </trans-unit>
        <trans-unit id="28dffbeaeb79cbefc3a6182c3945facf9e0c58d9" translate="yes" xml:space="preserve">
          <source>You need to pass references to these objects. See &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference in perlsub&lt;/a&gt; for this particular question, and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for information on references.</source>
          <target state="translated">您需要将引用传递给这些对象。有关特定问题，请参见&lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;perlsub中的按引用传递；有关参考的信息，&lt;/a&gt;请参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3725b76142cf0ba93578fc0f4b37b143a50c105" translate="yes" xml:space="preserve">
          <source>You need to perform the same general operations on related types of data, but with slight variations depending on the specific type of data the operations are applied to.</source>
          <target state="translated">你需要对相关类型的数据进行相同的一般操作,但根据操作所应用的具体数据类型,略有变化。</target>
        </trans-unit>
        <trans-unit id="eca7b2277d21c0c8eb2a5172b673ea24b48da4eb" translate="yes" xml:space="preserve">
          <source>You need to use &lt;code&gt;sv_magicext&lt;/code&gt; to add magic to SvREADONLY SVs and also to add more than one instance of the same 'how'.</source>
          <target state="translated">您需要使用 &lt;code&gt;sv_magicext&lt;/code&gt; 将魔术添加到SvREADONLY SV中，并且还需要添加多个相同的&amp;ldquo; how&amp;rdquo;实例。</target>
        </trans-unit>
        <trans-unit id="48a3262ccbefb20acd592d55306e17827a38c688" translate="yes" xml:space="preserve">
          <source>You now have better understanding of what a source filter is, and you might even have a possible use for them. If you feel like playing with source filters but need a bit of inspiration, here are some extra features you could add to the Debug filter.</source>
          <target state="translated">你现在对源码过滤器有了更好的理解,你甚至可能对它们有了可能的用途。如果你觉得想玩源码过滤器,但需要一点灵感,这里有一些你可以添加到Debug过滤器的额外功能。</target>
        </trans-unit>
        <trans-unit id="73cbac231eb90b456375cc000b5becdd4bf8f684" translate="yes" xml:space="preserve">
          <source>You probably cannot fix the thing that runs perl, but you can change how perl outputs its warnings by defining a custom warning and die functions.</source>
          <target state="translated">你可能无法修复运行perl的东西,但是你可以通过定义一个自定义的警告和死机函数来改变perl输出警告的方式。</target>
        </trans-unit>
        <trans-unit id="c42726aad22724c022f0c559e39f4d6e8477c11a" translate="yes" xml:space="preserve">
          <source>You probably cannot mix &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; is often implemented using &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您可能无法将 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 呼叫混合使用，因为 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 通常是使用 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 实现的。</target>
        </trans-unit>
        <trans-unit id="15661abf22e3cef9f933847127ca80cfb4161e88" translate="yes" xml:space="preserve">
          <source>You probably cannot mix &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; is often implemented using &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您可能无法将 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 呼叫混合使用，因为 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 通常是使用 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 实现的。</target>
        </trans-unit>
        <trans-unit id="c6ea02ffa42491538c740d65bba124e60d5ff937" translate="yes" xml:space="preserve">
          <source>You probably expect this code to print the equivalent of</source>
          <target state="translated">你可能希望这段代码能打印出相当于以下的代码</target>
        </trans-unit>
        <trans-unit id="d62ac8cab5911278724664b4481b34fb6ef41dfa" translate="yes" xml:space="preserve">
          <source>You probably meant to use &lt;code&gt;$]&lt;/code&gt; instead. &lt;code&gt;$[&lt;/code&gt; is the base for indexing arrays. &lt;code&gt;$]&lt;/code&gt; is the Perl version number in decimal.</source>
          <target state="translated">您可能打算使用 &lt;code&gt;$]&lt;/code&gt; 来代替。 &lt;code&gt;$[&lt;/code&gt; 是索引数组的基础。 &lt;code&gt;$]&lt;/code&gt; 是十进制的Perl版本号。</target>
        </trans-unit>
        <trans-unit id="fd777891ad8556771da5ce520e6dfb0017006c11" translate="yes" xml:space="preserve">
          <source>You probably shouldn't rely upon the &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; being podded out forever. Not all pod translators are well-behaved in this regard, and perhaps the compiler will become pickier.</source>
          <target state="translated">您可能不应该永远依赖 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; 。在这方面，并非所有的pod转换器都表现良好，也许编译器会变得更挑剔。</target>
        </trans-unit>
        <trans-unit id="f7e43d034a25f1af2139047ca7966917ab4cd1dd" translate="yes" xml:space="preserve">
          <source>You probably want to use one of the assortment of wrappers, such as &lt;code&gt;SvSetSV&lt;/code&gt; , &lt;code&gt;SvSetSV_nosteal&lt;/code&gt; , &lt;code&gt;SvSetMagicSV&lt;/code&gt; and &lt;code&gt;SvSetMagicSV_nosteal&lt;/code&gt; .</source>
          <target state="translated">您可能要使用各种包装器之一，例如 &lt;code&gt;SvSetSV&lt;/code&gt; ， &lt;code&gt;SvSetSV_nosteal&lt;/code&gt; ， &lt;code&gt;SvSetMagicSV&lt;/code&gt; 和 &lt;code&gt;SvSetMagicSV_nosteal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d6ef8cdce7f3fb77e02bca3307aceacf65c4aa9" translate="yes" xml:space="preserve">
          <source>You probably wrote something like this:</source>
          <target state="translated">你可能写了这样的东西。</target>
        </trans-unit>
        <trans-unit id="39ad4b4dd2e75230f3579c0483b312257f0274c5" translate="yes" xml:space="preserve">
          <source>You really need GNU make to compile this. GNU make ships by default with QNX 4.23, but you can get it from quics for earlier versions.</source>
          <target state="translated">您确实需要使用 GNU make 来编译。QNX 4.23 中默认有 GNU make,但您可以从 quics 中获取早期版本。</target>
        </trans-unit>
        <trans-unit id="e91eff73482d2359765ffe5506e4ead5d70a7574" translate="yes" xml:space="preserve">
          <source>You really probably want to be using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; instead, because &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; isn't what most people think of as &quot;local&quot;. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details.</source>
          <target state="translated">您可能真的想使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ，因为大多数人都不认为 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 是&amp;ldquo; local&amp;rdquo;。有关详细信息，请参见&lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;perlsub中通过my（）的私有变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab88c992626b72f6894fc343016d386fe947c5ce" translate="yes" xml:space="preserve">
          <source>You really probably want to be using &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; instead, because &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; isn't what most people think of as &quot;local&quot;. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details.</source>
          <target state="translated">您可能真的想使用 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ，因为大多数人都不认为 &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 是&amp;ldquo; local&amp;rdquo;。有关详细信息，请参见&lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;perlsub中通过my（）的私有变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d15f62d6aa63d728245cd3284fc083f9f68cff93" translate="yes" xml:space="preserve">
          <source>You see, if you call pstruct by its other incybernation, c2ph, you have a code generator that translates C code into perl code! Well, structure and union declarations at least, but that's quite a bit.</source>
          <target state="translated">你看,如果你用它的另一个incybernation,c2ph来调用pstruct,你就有了一个代码生成器,它可以把C代码翻译成perl代码!至少,结构化和联合声明,但也有不少。好吧,至少是结构和联合声明,但那是相当多的。</target>
        </trans-unit>
        <trans-unit id="95f74aa64cd2ea580871d2847f70b2776302bedc" translate="yes" xml:space="preserve">
          <source>You should also &quot;register&quot; your op with the Perl interpreter so that it can produce sensible error and warning messages. Since it is possible to have multiple custom ops within the one &quot;logical&quot; op type &lt;code&gt;OP_CUSTOM&lt;/code&gt; , Perl uses the value of &lt;code&gt;o-&amp;gt;op_ppaddr&lt;/code&gt; to determine which custom op it is dealing with. You should create an &lt;code&gt;XOP&lt;/code&gt; structure for each ppaddr you use, set the properties of the custom op with &lt;code&gt;XopENTRY_set&lt;/code&gt; , and register the structure against the ppaddr using &lt;code&gt;Perl_custom_op_register&lt;/code&gt; . A trivial example might look like:</source>
          <target state="translated">您还应该在Perl解释器中&amp;ldquo;注册&amp;rdquo;您的操作，以便它可以产生明智的错误和警告消息。由于在一个&amp;ldquo;逻辑&amp;rdquo;操作类型 &lt;code&gt;OP_CUSTOM&lt;/code&gt; 中可能有多个自定义操作，因此Perl使用 &lt;code&gt;o-&amp;gt;op_ppaddr&lt;/code&gt; 的值来确定它正在处理哪个自定义操作。您应该创建一个 &lt;code&gt;XOP&lt;/code&gt; 为每个使用ppaddr结构，设置与自定义运算的性能 &lt;code&gt;XopENTRY_set&lt;/code&gt; ，并注册反对使用ppaddr结构 &lt;code&gt;Perl_custom_op_register&lt;/code&gt; 。一个简单的示例可能看起来像：</target>
        </trans-unit>
        <trans-unit id="8cd501f21ed6c5e9d05fc6e18329636984dc10c8" translate="yes" xml:space="preserve">
          <source>You should also check out the Frequently Asked Questions list in comp.unix.* for things like this: the answer is essentially the same. It's very system-dependent. Here's one solution that works on BSD systems:</source>
          <target state="translated">你还应该查看comp.unix.*中的常见问题列表,了解类似这样的事情:答案基本上是一样的。这是非常依赖于系统的。这里有一个适用于BSD系统的解决方案。</target>
        </trans-unit>
        <trans-unit id="f04dff0eea092cd0ec8988c859db7bf95d5caa53" translate="yes" xml:space="preserve">
          <source>You should also check your modules, and upgrade them if necessary. For example, HTML::Entities requires version &amp;gt;= 1.32 to function correctly, even though the changelog is silent about this.</source>
          <target state="translated">您还应该检查模块，并在必要时进行升级。例如，HTML :: Entities要求版本&amp;gt; = 1.32才能正常运行，即使更改日​​志对此未作任何说明。</target>
        </trans-unit>
        <trans-unit id="1bf271b2d5721f863cabe314c6f3ea53dab9ccef" translate="yes" xml:space="preserve">
          <source>You should also look at &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;.</source>
          <target state="translated">您还应该查看&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a2a8e7bc27f2427aec43e373a1d93fb28c7dab24" translate="yes" xml:space="preserve">
          <source>You should also take a look at &lt;a href=&quot;perlmodstyle&quot;&gt;perlmodstyle&lt;/a&gt; for best practices in making a module.</source>
          <target state="translated">您还应该查看&lt;a href=&quot;perlmodstyle&quot;&gt;perlmodstyle&lt;/a&gt;以获取制作模块的最佳实践。</target>
        </trans-unit>
        <trans-unit id="50caca8ed03bfd57a516ccc3b6dfa215ef520713" translate="yes" xml:space="preserve">
          <source>You should also try to get feedback from people who are already familiar with the module's application domain and the CPAN naming system. Authors of similar modules, or modules with similar names, may be a good place to start, as are community sites like &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perlmonks.org&quot;&gt;Perl Monks&lt;/a&gt;.</source>
          <target state="translated">您还应该尝试从已经熟悉该模块的应用程序域和CPAN命名系统的人员那里获得反馈。类似模块或具有相似名称的模块的作者可能是一个不错的起点，就像&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perlmonks.org&quot;&gt;Perl Monks&lt;/a&gt;这样的社区网站一样。</target>
        </trans-unit>
        <trans-unit id="6748d5917300372787fdc7a9ff0a6b3a57b1d0d9" translate="yes" xml:space="preserve">
          <source>You should always support a &lt;code&gt;HASH&lt;/code&gt; argument to &lt;code&gt;TIEHASH&lt;/code&gt; that ties the underlying cache so that the user can specify that the cache is also persistent or that it has some other interesting semantics. The example above demonstrates how to do this, as does &lt;code&gt;Memoize::Expire&lt;/code&gt; .</source>
          <target state="translated">您应该始终支持 &lt;code&gt;TIEHASH&lt;/code&gt; 的 &lt;code&gt;HASH&lt;/code&gt; 参数，该参数绑定了基础缓存，以便用户可以指定缓存也是持久性的或具有其他有趣的语义。上面的示例演示了如何执行此操作， &lt;code&gt;Memoize::Expire&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3be69763ec9a168e71d6a325f5feb839520bece8" translate="yes" xml:space="preserve">
          <source>You should attempt older code to fully use</source>
          <target state="translated">你应该尝试用旧的代码来完全使用</target>
        </trans-unit>
        <trans-unit id="2aa5702baea4b6cbbf8baf7ed5e04e20725d5137" translate="yes" xml:space="preserve">
          <source>You should be aware that it is unsupported, and is not claimed to be fit for any purpose. If your system allows installation of arbitrary locales, you may find the definitions useful as they are, or as a basis for the development of your own locales.</source>
          <target state="translated">你应该意识到,它是不被支持的,也没有声称适合任何目的。如果你的系统允许安装任意的locales,你可能会发现这些定义是有用的,或者作为开发你自己的locales的基础。</target>
        </trans-unit>
        <trans-unit id="e3162405a76386caaa175c4a5b3c2a85402c9c86" translate="yes" xml:space="preserve">
          <source>You should be careful about creating mortal variables. Strange things can happen if you make the same value mortal within multiple contexts, or if you make a variable mortal multiple times. Thinking of &quot;Mortalization&quot; as deferred &lt;code&gt;SvREFCNT_dec&lt;/code&gt; should help to minimize such problems. For example if you are passing an SV which you</source>
          <target state="translated">您应谨慎创建致命变量。如果您在多个上下文中使同一个值成为凡人，或者多次使一个变量凡人，则可能会发生奇怪的事情。将&amp;ldquo;道德化&amp;rdquo;视为延迟 &lt;code&gt;SvREFCNT_dec&lt;/code&gt; 应该有助于最大程度地减少此类问题。例如，如果您传递的是SV</target>
        </trans-unit>
        <trans-unit id="f75000df91bba9bce6bbc0dce623bb898fe50b2f" translate="yes" xml:space="preserve">
          <source>You should be very careful when modifying the default values of most special variables described in this document. In most cases you want to localize these variables before changing them, since if you don't, the change may affect other modules which rely on the default values of the special variables that you have changed. This is one of the correct ways to read the whole file at once:</source>
          <target state="translated">在修改本文档中描述的大多数特殊变量的默认值时,您应该非常小心。在大多数情况下,您希望在修改这些变量之前先将它们本地化,因为如果您不这样做,您的修改可能会影响到其他依赖您所修改的特殊变量的默认值的模块。这是一次读取整个文件的正确方法之一。</target>
        </trans-unit>
        <trans-unit id="949c1f70059f0d92507bf8500b354d7dab533cd7" translate="yes" xml:space="preserve">
          <source>You should by now have had a look at &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;, which tells you about Perl's internal variable types: SVs, HVs, AVs and the rest. If not, do that now.</source>
          <target state="translated">现在，您应该已经了解了&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;，它向您介绍了Perl的内部变量类型：SV，HV，AV和其他变量。如果没有，请立即执行。</target>
        </trans-unit>
        <trans-unit id="1de8c82aa4b462c346cc4f7308a916f25f4fef57" translate="yes" xml:space="preserve">
          <source>You should have received a copy of the GNU General Public License along with this library program; it should be in the file &lt;code&gt;COPYING&lt;/code&gt; . If not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA</source>
          <target state="translated">您应该已经与该库程序一起收到了GNU通用公共许可证的副本；它应该在 &lt;code&gt;COPYING&lt;/code&gt; 文件中。如果没有，请写信给美国自由软件基金会有限公司（Free Software Foundation，Inc.），美国马萨诸塞州波士顿市5楼富兰克林街02110-1301</target>
        </trans-unit>
        <trans-unit id="e47e81623eb986394886e54e85f1183c3a98df4e" translate="yes" xml:space="preserve">
          <source>You should in general be leery of using functions that could potentially return lists in scalar context without explicitly stating such. This would be clearer to the casual reader:</source>
          <target state="translated">一般来说,你应该谨慎使用可能在标量上下文中返回列表的函数,而不明确说明。这对普通读者来说会更清楚。</target>
        </trans-unit>
        <trans-unit id="f07911b4c8d126039388d13cb35130da1027b105" translate="yes" xml:space="preserve">
          <source>You should make a module out of any code that you think is going to be useful to others. Anything that's likely to fill a hole in the communal library and which someone else can slot directly into their program. Any part of your code which you can isolate and extract and plug into something else is a likely candidate.</source>
          <target state="translated">你应该把任何你认为对别人有用的代码做成一个模块。任何可能填补公共库中的漏洞,并且别人可以直接插入他们的程序中的代码。你的代码的任何部分,只要你能分离、提取并插入到其他程序中,都是一个可能的候选。</target>
        </trans-unit>
        <trans-unit id="040633d0da585780031086722446751b04946152" translate="yes" xml:space="preserve">
          <source>You should neither care about nor depend on the internal representation; it might change without notice. Use &lt;b&gt;ONLY&lt;/b&gt; method calls like &lt;code&gt;$x-&amp;gt;sign();&lt;/code&gt; instead relying on the internal representation.</source>
          <target state="translated">您既不应该在乎也不依赖于内部代表；它可能会更改，恕不另行通知。&lt;b&gt;仅&lt;/b&gt;使用方法调用，例如 &lt;code&gt;$x-&amp;gt;sign();&lt;/code&gt; 而是依靠内部表示。</target>
        </trans-unit>
        <trans-unit id="8e48507edb3519e34f20c7e3d955b48a4ed82ad2" translate="yes" xml:space="preserve">
          <source>You should normally only add directories to @INC. If you need to delete directories from @INC take care to only delete those which you added yourself or which you are certain are not needed by other modules in your script. Other modules may have added directories which they need for correct operation.</source>
          <target state="translated">通常情况下,您应该只向 @INC 中添加目录,如果您需要从 @INC 中删除目录,请注意只删除那些您自己添加的或您确定不需要的模块。如果您需要从@INC中删除目录,请注意只删除那些您自己添加的或者您确定脚本中其他模块不需要的目录。其他模块可能已经添加了它们需要的目录,以保证正确的操作。</target>
        </trans-unit>
        <trans-unit id="693cc772a08fe2cee68cbfc24c2a6625d73c01c6" translate="yes" xml:space="preserve">
          <source>You should not depend on the internal format, all accesses must go through accessor methods. E.g. looking at $x-&amp;gt;{sign} is not a bright idea since there is no guaranty that the object in question has such a hashkey, nor is a hash underneath at all.</source>
          <target state="translated">您不应该依赖内部格式，所有访问都必须通过访问器方法进行。例如，查看$ x-&amp;gt; {sign}并不是一个好主意，因为没有保证所讨论的对象具有这样的哈希键，也根本没有下面的哈希。</target>
        </trans-unit>
        <trans-unit id="d13d5397797f2275509831750bfac02171b7d4f3" translate="yes" xml:space="preserve">
          <source>You should not depend on the internal format, all accesses must go through accessor methods. E.g. looking at $x-&amp;gt;{sign} is not a good idea since there is no guaranty that the object in question has such a hash key, nor is a hash underneath at all.</source>
          <target state="translated">您不应该依赖内部格式，所有访问都必须通过访问器方法进行。例如，查看$ x-&amp;gt; {sign}并不是一个好主意，因为没有保证所讨论的对象具有这样的哈希键，也根本没有哈希。</target>
        </trans-unit>
        <trans-unit id="6e8d21cc64f2bc1e9d1ef661a62db1a121e53da8" translate="yes" xml:space="preserve">
          <source>You should not even &lt;b&gt;want&lt;/b&gt; to use</source>
          <target state="translated">你甚至都不&lt;b&gt;想要&lt;/b&gt;使用</target>
        </trans-unit>
        <trans-unit id="675338533405ed3338eef5ef4ee169f82f2ec7e6" translate="yes" xml:space="preserve">
          <source>You should not use perl's malloc if you are building with gcc. There are reports of core dumps, especially in the PDL module. The problem appears to go away under -DDEBUGGING, so it has been difficult to track down. Sun's compiler appears to be okay with or without perl's malloc. [XXX further investigation is needed here.]</source>
          <target state="translated">如果你是用gcc构建的话,你不应该使用perl的malloc。有关于核心转储的报告,特别是在PDL模块中。这个问题似乎在-DDEBUGGING下消失了,所以很难追查。Sun的编译器似乎不管有没有perl的malloc都没问题。[这里需要XXX进一步调查。]</target>
        </trans-unit>
        <trans-unit id="13af3135f590e4077444d490629ef8daddd658bc" translate="yes" xml:space="preserve">
          <source>You should note that, if it is necessary to store the SV (&lt;code&gt;name&lt;/code&gt; in the example above) which corresponds to the Perl subroutine so that it can be used later in the program, it not enough just to store a copy of the pointer to the SV. Say the code above had been like this:</source>
          <target state="translated">您应注意，如果有必要存储与Perl子例程相对应的SV（上例中的 &lt;code&gt;name&lt;/code&gt; ），以便以后在程序中使用它，仅存储指向该指针的指针的副本是不够的。 SV。说上面的代码是这样的：</target>
        </trans-unit>
        <trans-unit id="30d7be701b66af4a13ce23ca4f4637ef46685c93" translate="yes" xml:space="preserve">
          <source>You should probably be using lexical variables anyway, although the issue is the same here:</source>
          <target state="translated">你可能无论如何都应该使用词法变量,尽管这里的问题是一样的。</target>
        </trans-unit>
        <trans-unit id="54112594f7721aec0b526a825c8c553a794597d2" translate="yes" xml:space="preserve">
          <source>You should say</source>
          <target state="translated">你应该说</target>
        </trans-unit>
        <trans-unit id="5ae04df28b1ca8233ad4f14017b75003d4a4c0fc" translate="yes" xml:space="preserve">
          <source>You should seldom if ever use &lt;code&gt;0644&lt;/code&gt; as argument to &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, because that takes away the user's option to have a more permissive umask. Better to omit it. See the perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">如果曾经使用 &lt;code&gt;0644&lt;/code&gt; 作为 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 的参数，则几乎不应该使用它，因为这样可以避免用户选择具有更大许可的umask。最好省略它。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 上的perlfunc（1）条目。</target>
        </trans-unit>
        <trans-unit id="a5da0398cef906098b3aedb900161f9013fc9dbe" translate="yes" xml:space="preserve">
          <source>You should seldom if ever use &lt;code&gt;0644&lt;/code&gt; as argument to &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, because that takes away the user's option to have a more permissive umask. Better to omit it. See the perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">如果曾经使用 &lt;code&gt;0644&lt;/code&gt; 作为 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 的参数，则几乎不应该使用它，因为这样可以避免用户选择具有更大许可的umask。最好省略它。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 上的perlfunc（1）条目。</target>
        </trans-unit>
        <trans-unit id="93291955e6753d9b28d9290f1f843ab314e860d1" translate="yes" xml:space="preserve">
          <source>You should take great pains to try to pass the function the type of variable it wants, when possible. It will save you a lot of trouble in the long run.</source>
          <target state="translated">在可能的情况下,你应该不厌其烦地尽量给函数传递它想要的变量类型。从长远来看,这将为你省去很多麻烦。</target>
        </trans-unit>
        <trans-unit id="12e9cbf7ef859529e7aa6ad559377e6f6b1073a2" translate="yes" xml:space="preserve">
          <source>You should think long and hard about why you need everything loaded at once. It's just not a scalable solution.</source>
          <target state="translated">你应该好好想想为什么要一次装完所有的东西。这不是一个可扩展的解决方案。</target>
        </trans-unit>
        <trans-unit id="60692fdbea6181558282af5a09ad1a91226b0568" translate="yes" xml:space="preserve">
          <source>You should use</source>
          <target state="translated">你应该使用</target>
        </trans-unit>
        <trans-unit id="6151ee9c13ae718ea297cb2924721c23869b50eb" translate="yes" xml:space="preserve">
          <source>You should use the &lt;b&gt;-T&lt;/b&gt; flag to enable taint checking (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) even if we aren't running setuid or setgid. This is always a good idea for servers or any program run on behalf of someone else (like CGI scripts), because it lessens the chances that people from the outside will be able to compromise your system.</source>
          <target state="translated">即使我们没有运行setuid或setgid，也应使用&lt;b&gt;-T&lt;/b&gt;标志启用污点检查（请参阅&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;）。对于服务器或代表其他人运行的任何程序（例如CGI脚本）来说，这始终是一个好主意，因为它减少了外部人员入侵您系统的机会。</target>
        </trans-unit>
        <trans-unit id="c6b52a2caf001c41f2fbe0900c81a2862fac3a04" translate="yes" xml:space="preserve">
          <source>You should use this</source>
          <target state="translated">你应该用这个</target>
        </trans-unit>
        <trans-unit id="f980030e1ddd6415377ab007be132a7835310a08" translate="yes" xml:space="preserve">
          <source>You should use this option if you are using UTF-16 and others which linefeed is not $/.</source>
          <target state="translated">如果你使用UTF-16和其他非$/的行进,你应该使用这个选项。</target>
        </trans-unit>
        <trans-unit id="db384f65b44d08a41642068cf25462a07360e950" translate="yes" xml:space="preserve">
          <source>You should usually be able to ignore this and just use the module without thinking about deferring. However, special applications may require fine control over which writes are deferred, or may require that all writes be immediate. To disable the autodeferment feature, use</source>
          <target state="translated">通常您应该可以忽略这一点,只需使用该模块,而无需考虑推迟。然而,特殊的应用程序可能需要精细地控制哪些写入是延迟的,或者可能要求所有的写入都是立即的。要禁用自动延迟功能,请使用</target>
        </trans-unit>
        <trans-unit id="962a252e8053766a043aa7e45b2c62a450a0683c" translate="yes" xml:space="preserve">
          <source>You shouldn't have to care. But you may if your Perl is before 5.14.0 or you haven't specified &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
5.012&lt;/code&gt; (or higher) because otherwise the rules for the code points in the range 128 to 255 are different depending on whether the string they are contained within is in Unicode or not. (See &lt;a href=&quot;perlunicode#When-Unicode-Does-Not-Happen&quot;&gt;When Unicode Does Not Happen in perlunicode&lt;/a&gt;.)</source>
          <target state="translated">您不必关心。但是，如果您的Perl在5.14.0之前，或者您未指定 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; （或更高版本），则可能会出现这种情况，因为否则，代码点在128到255之间的规则会有所不同，具体取决于字符串是否它们是否包含在Unicode中。（请参阅&lt;a href=&quot;perlunicode#When-Unicode-Does-Not-Happen&quot;&gt;何时在perlunicode中不发生Unicode&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="a8856a657ecb3d97a5c46abba56a556f46cc66ed" translate="yes" xml:space="preserve">
          <source>You shouldn't need to set this variable, since File::Find should now detect such file systems on-the-fly and switch itself to using stat. This works even for parts of your file system, like a mounted CD-ROM.</source>
          <target state="translated">你不需要设置这个变量,因为 File::Find 现在应该可以即时检测到这样的文件系统,并将自己切换到使用 stat。这甚至适用于文件系统的一部分,比如挂载的 CD-ROM。</target>
        </trans-unit>
        <trans-unit id="07632dfd399f0ee08d2dcc1bc356caea0fb1fc3a" translate="yes" xml:space="preserve">
          <source>You shouldn't worry about what this format is, because conversion is automatically done when you decode or encode.</source>
          <target state="translated">你不应该担心这个格式是什么,因为在你解码或编码的时候会自动进行转换。</target>
        </trans-unit>
        <trans-unit id="1bf2aae490ef3108185dddeac7ace7d36d9b8359" translate="yes" xml:space="preserve">
          <source>You specified a character that has the given plainer way of writing it, and which is also portable to platforms running with different character sets.</source>
          <target state="translated">你指定的字符具有给定的更简单的书写方式,而且还可以移植到运行不同字符集的平台上。</target>
        </trans-unit>
        <trans-unit id="ba1446898cf703a433f10e50053c48b7c4bd65ea" translate="yes" xml:space="preserve">
          <source>You specify the parameters that will be passed into the XSUB on the line(s) after you declare the function's return value and name. Each input parameter line starts with optional whitespace, and may have an optional terminating semicolon.</source>
          <target state="translated">你可以在声明函数的返回值和名称之后的行中指定传入XSUB的参数。每个输入参数行以可选的空格开始,并且可以有一个可选的分号结束。</target>
        </trans-unit>
        <trans-unit id="5e23d741eb164f1a1d95de07ecc25c6899dd796b" translate="yes" xml:space="preserve">
          <source>You spend lots and lots of money on dedicated hardware, but this is bound to get you talked about.</source>
          <target state="translated">你在专用硬件上花了很多很多钱,但这必然会让你被人议论。</target>
        </trans-unit>
        <trans-unit id="e47578a3d656799aa6fd209dfd66ed644e50edb2" translate="yes" xml:space="preserve">
          <source>You then can run the test(s) from your test suite that call &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;. At this point the output of &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; is safely captured by &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; rather than being interpreted as real test output.</source>
          <target state="translated">然后，您可以从测试套件中运行调用&lt;a href=&quot;../builder&quot;&gt;Test :: Builder的测试&lt;/a&gt;。此时，&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;的输出将由&lt;a href=&quot;tester&quot;&gt;Test :: Builder :: Tester&lt;/a&gt;安全地捕获，而不是被解释为真实的测试输出。</target>
        </trans-unit>
        <trans-unit id="89f392c3f60b78b930a2c99b682f5745b402f97b" translate="yes" xml:space="preserve">
          <source>You tried to use a negative time argument.</source>
          <target state="translated">你想用否定时间的说法。</target>
        </trans-unit>
        <trans-unit id="215da501a4d763185822fdec5710086fea4dd9c5" translate="yes" xml:space="preserve">
          <source>You use an old version of GNU make. See &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">您使用的是旧版本的GNU make。请参阅&lt;a href=&quot;#Prerequisites&quot;&gt;先决条件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="220275358a49875c3abbea24e2340553d9cb4444" translate="yes" xml:space="preserve">
          <source>You use the &lt;code&gt;\G&lt;/code&gt; anchor to start the next match on the same string where the last match left off. The regular expression engine cannot skip over any characters to find the next match with this anchor, so &lt;code&gt;\G&lt;/code&gt; is similar to the beginning of string anchor, &lt;code&gt;^&lt;/code&gt;. The &lt;code&gt;\G&lt;/code&gt; anchor is typically used with the &lt;code&gt;g&lt;/code&gt; flag. It uses the value of &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as the position to start the next match. As the match operator makes successive matches, it updates &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; with the position of the next character past the last match (or the first character of the next match, depending on how you like to look at it). Each string has its own &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">您可以使用 &lt;code&gt;\G&lt;/code&gt; 锚点在同一字符串上开始下一个匹配，而最后一个匹配将从该字符串开始。正则表达式引擎无法跳过任何字符来查找与此锚点匹配的下一个匹配项，因此 &lt;code&gt;\G&lt;/code&gt; 类似于字符串锚点 &lt;code&gt;^&lt;/code&gt; 的开头。所述 &lt;code&gt;\G&lt;/code&gt; 锚通常用于与 &lt;code&gt;g&lt;/code&gt; 标志。它使用 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 的值作为开始下一个匹配的位置。当match运算符进行连续的匹配时，它将使用上一个匹配项（或下一个匹配项的第一个字符）之后的下一个字符的位置来更新 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; ，具体取决于您的喜好。每个字符串都有其自己的 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="fc28690a1164ffed63384fc9d48573f0201b1c8c" translate="yes" xml:space="preserve">
          <source>You use the utime() function documented in &lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt;. By way of example, here's a little program that copies the read and write times from its first argument to all the rest of them.</source>
          <target state="translated">您可以使用中记录了UTIME（）函数&lt;a href=&quot;functions/utime&quot;&gt;UTIME&lt;/a&gt;。举例来说，这是一个小程序，它将读写时间从其第一个参数复制到所有其他参数。</target>
        </trans-unit>
        <trans-unit id="6636b861a3b2aa1c111b3f0b60ae946532727186" translate="yes" xml:space="preserve">
          <source>You usually can use the value of &lt;code&gt;$^X&lt;/code&gt; to re-invoke an independent copy of the same perl that is currently running, e.g.,</source>
          <target state="translated">通常，您可以使用 &lt;code&gt;$^X&lt;/code&gt; 的值重新调用当前正在运行的同一Perl的独立副本，例如，</target>
        </trans-unit>
        <trans-unit id="aa6e6cfea08fbea7a5de694a45b0570deb9eda14" translate="yes" xml:space="preserve">
          <source>You usually can't. Memory allocated to lexicals (i.e. my() variables) cannot be reclaimed or reused even if they go out of scope. It is reserved in case the variables come back into scope. Memory allocated to global variables can be reused (within your program) by using undef() and/or delete().</source>
          <target state="translated">通常不能。分配给词法(即my()变量)的内存即使超出了作用域,也不能被回收或重新使用。它被保留在变量重新进入作用域的情况下。分配给全局变量的内存可以通过使用undef()和/或delete()重新使用(在你的程序中)。</target>
        </trans-unit>
        <trans-unit id="654d5925759821a41f7b319f6f5acce1580b7e6a" translate="yes" xml:space="preserve">
          <source>You want to temporarily change just one element of an array or hash.</source>
          <target state="translated">你想临时改变一个数组或哈希中的一个元素。</target>
        </trans-unit>
        <trans-unit id="2ba6881210a4041e425c0b40054f89e605a3c752" translate="yes" xml:space="preserve">
          <source>You will also need to be able to connect over the Internet to the public key servers, like pgp.mit.edu, and their port 11731 (the HKP protocol).</source>
          <target state="translated">你还需要能够通过互联网连接到公钥服务器,比如pgp.mit.edu,以及他们的11731端口(HKP协议)。</target>
        </trans-unit>
        <trans-unit id="c62030728cb5bac5bc525932491c14ac0a7adf6d" translate="yes" xml:space="preserve">
          <source>You will also need to download the &quot;Platform SDK&quot; (the &quot;Core SDK&quot; and &quot;MDAC SDK&quot; components are required) for header files, libraries and rc.exe, and &quot;.NET Framework SDK&quot; for more libraries and nmake.exe. Note that the latter (which also includes the free compiler and linker) requires the &quot;.NET Framework Redistributable&quot; to be installed first. This can be downloaded and installed separately, but is included in the &quot;Visual C++ Toolkit 2003&quot; anyway.</source>
          <target state="translated">你还需要下载 &quot;Platform SDK&quot;(需要 &quot;Core SDK &quot;和 &quot;MDAC SDK &quot;组件)以获取头文件、库和rc.exe,以及&quot;.NET Framework SDK &quot;以获取更多库和nmake.exe。注意,后者(还包括免费的编译器和链接器)需要先安装&quot;.NET Framework Redistributable&quot;。这可以单独下载和安装,但无论如何都包含在 &quot;Visual C++Toolkit 2003 &quot;中。</target>
        </trans-unit>
        <trans-unit id="356f5d0daa70748f28cbf7166d4f341295254619" translate="yes" xml:space="preserve">
          <source>You will also need to download the &quot;Windows SDK&quot; (the &quot;Core SDK&quot; and &quot;MDAC SDK&quot; components are required) for more header files and libraries.</source>
          <target state="translated">您还需要下载 &quot;Windows SDK&quot;(需要 &quot;Core SDK &quot;和 &quot;MDAC SDK &quot;组件)以获得更多的头文件和库。</target>
        </trans-unit>
        <trans-unit id="a1a5cfadaa899360662110efdf3739aae4dbc6c1" translate="yes" xml:space="preserve">
          <source>You will encounter this particular error message when you have the &lt;code&gt;strict 'subs'&lt;/code&gt; pragma (or the full strict pragma) in your script. Consider this script:</source>
          <target state="translated">当脚本中包含 &lt;code&gt;strict 'subs'&lt;/code&gt; 编译指示（或完整的严格编译指示）时，将遇到此特定的错误消息。考虑以下脚本：</target>
        </trans-unit>
        <trans-unit id="9ef82421bf1d6104efddfdc8565b14c0ddc86aec" translate="yes" xml:space="preserve">
          <source>You will find this behavior is slightly different from that of &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handlers (which don't suppress the error text, but can instead call &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again to change it).</source>
          <target state="translated">您会发现此行为与 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 处理程序的行为略有不同（该处理程序不会隐藏错误文本，但可以再次调用 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 进行更改）。</target>
        </trans-unit>
        <trans-unit id="7d85e118af6c81732006143a60990cead4fa03d5" translate="yes" xml:space="preserve">
          <source>You will find this behavior is slightly different from that of &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handlers (which don't suppress the error text, but can instead call &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again to change it).</source>
          <target state="translated">您会发现此行为与 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 处理程序的行为略有不同（该处理程序不会隐藏错误文本，但可以再次调用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 进行更改）。</target>
        </trans-unit>
        <trans-unit id="c01bddfdbad27a7674a351ac148e02cb61a266a6" translate="yes" xml:space="preserve">
          <source>You will get this error message when one of the parameters in the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call is wrong. Unfortunately there are quite a few parameters to get wrong, so it can be difficult to figure out which one it is.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用中的参数之一错误时，您将收到此错误消息。不幸的是，有很多参数会出错，因此很难弄清楚它是哪一个。</target>
        </trans-unit>
        <trans-unit id="b306755ccc7dd24d9d304eb11d95322f9c7d1c36" translate="yes" xml:space="preserve">
          <source>You will have to make sure that CCTYPE is set correctly and that CCHOME points to wherever you installed your compiler.</source>
          <target state="translated">你必须确保CCTYPE设置正确,并且CCHOME指向你安装编译器的地方。</target>
        </trans-unit>
        <trans-unit id="b8d67b6a7548006b180c9c0aa7f1777391e8e3f6" translate="yes" xml:space="preserve">
          <source>You will need a copy of Git for your computer. You can fetch a copy of the repository using the git protocol:</source>
          <target state="translated">你需要在你的电脑上安装一个Git的副本,你可以使用git协议来获取仓库的副本。你可以使用 git 协议获取仓库的副本。</target>
        </trans-unit>
        <trans-unit id="7a0e1442c7d674a64133a4ac5cbad0b8f84016fe" translate="yes" xml:space="preserve">
          <source>You will need perl version 5.005_03 or newer.</source>
          <target state="translated">你需要perl 5.005_03或更新的版本。</target>
        </trans-unit>
        <trans-unit id="c20642cf215c3811e3976c0a074a0bc8e167607f" translate="yes" xml:space="preserve">
          <source>You will need the packages mentioned in</source>
          <target state="translated">你将需要在</target>
        </trans-unit>
        <trans-unit id="125a7a338622da6411e41d9bf9ce7dc1495ae8ff" translate="yes" xml:space="preserve">
          <source>You will need to have Module::Signature installed, which in turn requires that you have at least one of Crypt::OpenPGP module or the command-line</source>
          <target state="translated">你需要安装Module::Signature,而这又要求你至少有一个Crypt::OpenPGP模块或命令行的</target>
        </trans-unit>
        <trans-unit id="26225667638a5ef1fac02d60146f2f3c0e15d299" translate="yes" xml:space="preserve">
          <source>You will need to open every other filehandle on your own. Although there are many variants, the most common way to call Perl's open() function is with three arguments and one return value:</source>
          <target state="translated">你需要自己打开其他每一个文件柄。虽然有很多变体,但调用Perl的open()函数最常见的方式是使用三个参数和一个返回值。</target>
        </trans-unit>
        <trans-unit id="ced186b3bff5ac2b886750a50b53e155abe57dbc" translate="yes" xml:space="preserve">
          <source>You will probably find these modifiers even more useful if you have to deal with big- or little-endian C structures. Be sure to read &lt;a href=&quot;#Packing-and-Unpacking-C-Structures&quot;&gt;Packing and Unpacking C Structures&lt;/a&gt; for more on that.</source>
          <target state="translated">如果必须处理大尾数的C结构，则这些修饰符可能会更加有用。请务必阅读&lt;a href=&quot;#Packing-and-Unpacking-C-Structures&quot;&gt;打包C结构&lt;/a&gt;的更多信息。</target>
        </trans-unit>
        <trans-unit id="299bf5b3f1c12a5c613500fd1bf200a8e448ae9f" translate="yes" xml:space="preserve">
          <source>You will see a message about errors while extracting</source>
          <target state="translated">在解压时,你会看到一条关于错误的信息。</target>
        </trans-unit>
        <trans-unit id="d4ae5109d0174e4b426288bcd1b8e77508718bce" translate="yes" xml:space="preserve">
          <source>You will sometimes see older books or documentation mention &quot;blessing a reference&quot; or describe an object as a &quot;blessed reference&quot;, but this is incorrect. It isn't the reference that is blessed as an object; it's the thing the reference refers to (i.e. the referent).</source>
          <target state="translated">您有时会看到较老的书籍或文档中提到 &quot;祝福一个参照物 &quot;或将一个对象描述为 &quot;祝福参照物&quot;,但这是不正确的。被祝福为对象的不是参考文献,而是参考文献所指的东西(即参照物)。</target>
        </trans-unit>
        <trans-unit id="e797714a16ef1ab3d51adb0398a2351cdb2d4869" translate="yes" xml:space="preserve">
          <source>You would do</source>
          <target state="translated">你会做</target>
        </trans-unit>
        <trans-unit id="6a39b437275322e4ded1326f66b7e094ff120686" translate="yes" xml:space="preserve">
          <source>You would do well to understand that the TIEARRAY and TIEHASH interfaces are mere sugar to invoke some perl method calls while using the uniform hash and array syntax. The use of this sugar imposes some overhead (typically about two to four extra opcodes per FETCH/STORE operation, in addition to the creation of all the mortal variables required to invoke the methods). This overhead will be comparatively small if the TIE methods are themselves substantial, but if they are only a few statements long, the overhead will not be insignificant.</source>
          <target state="translated">你最好明白,TIEARRAY和TIEHASH接口只是一个糖,用来调用一些perl方法,同时使用统一的哈希和数组语法。这种糖的使用会带来一些开销(通常每个FETCH/STORE操作会有两到四个额外的操作码,此外还要创建调用方法所需的所有凡人变量)。如果TIE方法本身就很可观,那么这个开销就会相对较小,但如果这些方法只有几条语句长,那么这个开销就不小了。</target>
        </trans-unit>
        <trans-unit id="d4ff63e38580a86bc4e960e615187745a0cf46e6" translate="yes" xml:space="preserve">
          <source>You would tell &lt;code&gt;Memoize&lt;/code&gt; to use this normalizer this way:</source>
          <target state="translated">您将告诉 &lt;code&gt;Memoize&lt;/code&gt; 以这种方式使用此规范化器：</target>
        </trans-unit>
        <trans-unit id="26052a9c2b555b8c00fe517ca714ea40b56ea28f" translate="yes" xml:space="preserve">
          <source>You would think passing files to an XS is difficult, with all the typeglobs and stuff. Well, it isn't.</source>
          <target state="translated">你会觉得把文件传到XS上很困难,因为有很多打字夹之类的东西。其实不然。</target>
        </trans-unit>
        <trans-unit id="97f37569bdb5c4ba52eeb6c3306265613993e5ff" translate="yes" xml:space="preserve">
          <source>You'll also find that &lt;code&gt;foreach&lt;/code&gt; loop used to create a topicalizer and a switch:</source>
          <target state="translated">您还将发现用于创建主题分析器和开关的 &lt;code&gt;foreach&lt;/code&gt; 循环：</target>
        </trans-unit>
        <trans-unit id="5e9bf36ecbd53fc8e26acf6fb90205c1b5356d3c" translate="yes" xml:space="preserve">
          <source>You'll also have to choose the appropriate library directory (</source>
          <target state="translated">你还得选择合适的库目录(</target>
        </trans-unit>
        <trans-unit id="d14f9a4e84e4a65a6fcadc471d3775e2d2026c66" translate="yes" xml:space="preserve">
          <source>You'll also need to add the following code to the top of the .xs file, just after the include of &quot;XSUB.h&quot;:</source>
          <target state="translated">你还需要将以下代码添加到.xs文件的顶部,就在 &quot;XSUB.h &quot;的包含之后。</target>
        </trans-unit>
        <trans-unit id="067d0f39aaa002449de130921826b00edd6e52d4" translate="yes" xml:space="preserve">
          <source>You'll also see code that does this without a temporary variable, as in</source>
          <target state="translated">你也会看到一些代码在没有临时变量的情况下这样做,如</target>
        </trans-unit>
        <trans-unit id="e76c883ffb7e9e13e48b98bafcbb6fa1aa675b80" translate="yes" xml:space="preserve">
          <source>You'll be in trouble. Those should (in 99.8% of the cases) be the simpler and more direct:</source>
          <target state="translated">你会有麻烦的。这些应该(在99.8%的情况下)是比较简单直接的。</target>
        </trans-unit>
        <trans-unit id="f885bd4b3bb53aff3bed3dec0b066248d1576a12" translate="yes" xml:space="preserve">
          <source>You'll have to catch the SIGCHLD signal, and possibly SIGPIPE too. SIGCHLD is sent when the backgrounded process finishes. SIGPIPE is sent when you write to a filehandle whose child process has closed (an untrapped SIGPIPE can cause your program to silently die). This is not an issue with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system(&quot;cmd&amp;amp;&quot;)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您必须捕获SIGCHLD信号，并且可能还捕获SIGPIPE。后台进程完成时发送SIGCHLD。当您写入其子进程已关闭的文件句柄时，将发送SIGPIPE（未捕获的SIGPIPE可能导致您的程序无声地死掉）。这不是 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system(&quot;cmd&amp;amp;&quot;)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c26c7e5ed49de9efc0c0dba307a9def27936a34" translate="yes" xml:space="preserve">
          <source>You'll have to choose the appropriate compiler (</source>
          <target state="translated">你必须选择合适的编译器(</target>
        </trans-unit>
        <trans-unit id="e62d384e427e6ef82a853693fc0380e3a4a6bcdd" translate="yes" xml:space="preserve">
          <source>You'll know your submission has been processed when you receive an email from our ticket tracking system. This email will give you a ticket number. Once your patch has made it to the ticket tracking system, it will also be sent to the perl5-porters@perl.org list.</source>
          <target state="translated">当您收到我们的票务跟踪系统发出的电子邮件时,您就会知道您的提交已被处理。这封邮件会给你一个票号。一旦你的补丁进入票务跟踪系统,它也会被发送到perl5-porters@perl.org 列表。</target>
        </trans-unit>
        <trans-unit id="feea2270863ca6e9573aba26122b77d4eeb6b2e7" translate="yes" xml:space="preserve">
          <source>You'll need the &lt;code&gt;nmake&lt;/code&gt; utility, available at &lt;a href=&quot;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&quot;&gt;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&lt;/a&gt; or dmake, available on CPAN. &lt;a href=&quot;http://search.cpan.org/dist/dmake/&quot;&gt;http://search.cpan.org/dist/dmake/&lt;/a&gt;</source>
          <target state="translated">您需要 &lt;code&gt;nmake&lt;/code&gt; 实用程序，该程序可从CPAN上获得，&lt;a href=&quot;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&quot;&gt;网址&lt;/a&gt;为http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe或dmake。&lt;a href=&quot;http://search.cpan.org/dist/dmake/&quot;&gt;http://search.cpan.org/dist/dmake/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d98bbda9e4101a6a3cc3bbb0d325b9faa857f4a3" translate="yes" xml:space="preserve">
          <source>You'll want to do that in your Perl source tree so the debugger can read the source code. You should see the copyright message, followed by the prompt.</source>
          <target state="translated">你会想在你的Perl源码树中这样做,这样调试器就可以读取源码。你应该看到版权信息,然后是提示。</target>
        </trans-unit>
        <trans-unit id="43eea0417aae56c41dd79afb85423b61a36ecf9b" translate="yes" xml:space="preserve">
          <source>You're confusing the purpose of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and backticks (``). &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; runs a command and returns exit status information (as a 16 bit value: the low 7 bits are the signal the process died from, if any, and the high 8 bits are the actual exit value). Backticks (``) run a command and return what it sent to STDOUT.</source>
          <target state="translated">您混淆了 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 和反引号（``）的用途。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 运行命令并返回退出状态信息（作为16位值：低7位是进程退出的信号（如果有），高8位是实际退出值）。反引号（``）运行命令并将其发送给STDOUT的命令返回。</target>
        </trans-unit>
        <trans-unit id="0067a9abf52f5d5adc52730de693ce9354a17edf" translate="yes" xml:space="preserve">
          <source>You're encouraged to create self-tests for your module to ensure it's working as intended on the myriad platforms Perl supports; if you upload your module to CPAN, a host of testers will build your module and send you the results of the tests. Again, &lt;code&gt;module-starter&lt;/code&gt; and &lt;code&gt;h2xs&lt;/code&gt; provide a test framework which you can extend - you should do something more than just checking your module will compile. &lt;a href=&quot;test/simple&quot;&gt;Test::Simple&lt;/a&gt; and &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; are good places to start when writing a test suite.</source>
          <target state="translated">我们鼓励您为模块创建自检，以确保其在Perl支持的众多平台上按预期工作。如果您将模块上传到CPAN，则大量的测试人员将构建您的模块并向您发送测试结果。再次， &lt;code&gt;module-starter&lt;/code&gt; 和 &lt;code&gt;h2xs&lt;/code&gt; 提供了可以扩展的测试框架-您应该做的不仅仅是检查模块是否可以编译。&lt;a href=&quot;test/simple&quot;&gt;测试：：简单&lt;/a&gt;和&lt;a href=&quot;test/more&quot;&gt;测试：：更多&lt;/a&gt;是编写测试套件时开始的好地方。</target>
        </trans-unit>
        <trans-unit id="1465c23d6a9abbc69d7c02001d0a261855c5206d" translate="yes" xml:space="preserve">
          <source>You're probably trying to convert a string to a number, which Perl only converts as a decimal number. When Perl converts a string to a number, it ignores leading spaces and zeroes, then assumes the rest of the digits are in base 10:</source>
          <target state="translated">你可能是想把一个字符串转换为数字,而 Perl 只把它转换为十进制数。当 Perl 将一个字符串转换为数字时,它会忽略前导空格和零,然后假设其余的数字都是以 10 为基数。</target>
        </trans-unit>
        <trans-unit id="f32dee0623a34d25e555f7bd9fe977163f048dfb" translate="yes" xml:space="preserve">
          <source>You're still out of luck if you need to keep track of decaying protons though.</source>
          <target state="translated">不过如果你需要追踪衰变的质子,你还是很倒霉的。</target>
        </trans-unit>
        <trans-unit id="4522acbd81c14b3349dda685727b4174a91c46c1" translate="yes" xml:space="preserve">
          <source>You're unlikely to ever need to construct an object of this class for yourself, but if you want to, call &lt;code&gt;Pod::Simple::PullParserEndToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt; )&lt;/code&gt;</source>
          <target state="translated">您几乎不需要自己构造此类的对象，但是如果愿意，请调用 &lt;code&gt;Pod::Simple::PullParserEndToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt; )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13c2c796fe95a445a68ec254f6e70e50cbdb3db7" translate="yes" xml:space="preserve">
          <source>You're unlikely to ever need to construct an object of this class for yourself, but if you want to, call &lt;code&gt;Pod::Simple::PullParserStartToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt;, &lt;i&gt;attrhash&lt;/i&gt; )&lt;/code&gt;</source>
          <target state="translated">您几乎不需要自己构造此类的对象，但是如果愿意，请调用 &lt;code&gt;Pod::Simple::PullParserStartToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt;, &lt;i&gt;attrhash&lt;/i&gt; )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63fdd43345f7726cfc85c93addac87c77eec8e6e" translate="yes" xml:space="preserve">
          <source>You're unlikely to ever need to construct an object of this class for yourself, but if you want to, call &lt;code&gt;Pod::Simple::PullParserTextToken-&amp;gt;new( &lt;i&gt;text&lt;/i&gt; )&lt;/code&gt;</source>
          <target state="translated">您几乎不需要自己构造此类的对象，但是如果愿意，请调用 &lt;code&gt;Pod::Simple::PullParserTextToken-&amp;gt;new( &lt;i&gt;text&lt;/i&gt; )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="244e1e138ccb1ddf345dc218bc4eb88a0d9affd5" translate="yes" xml:space="preserve">
          <source>You've asked &lt;code&gt;Fatal&lt;/code&gt; to replace a subroutine, but it's not a Perl built-in, and &lt;code&gt;Fatal&lt;/code&gt; couldn't find it as a regular subroutine. It either doesn't exist or has not yet been defined.</source>
          <target state="translated">您已经要求 &lt;code&gt;Fatal&lt;/code&gt; 替换一个子例程，但是它不是Perl内置的，并且 &lt;code&gt;Fatal&lt;/code&gt; 找不到它作为常规子例程。它不存在或尚未定义。</target>
        </trans-unit>
        <trans-unit id="e40be2d06acbdf1af8b44d624778687fbb9e49ee" translate="yes" xml:space="preserve">
          <source>You've asked &lt;code&gt;Fatal&lt;/code&gt; to try and replace a subroutine which does not exist, or has not yet been defined.</source>
          <target state="translated">您已要求 &lt;code&gt;Fatal&lt;/code&gt; 尝试替换不存在或尚未定义的子例程。</target>
        </trans-unit>
        <trans-unit id="b50e18d238da3dcc7957f257361d12bcaab56e61" translate="yes" xml:space="preserve">
          <source>You've called &lt;code&gt;Fatal&lt;/code&gt; with an argument that doesn't look like a subroutine name, nor a switch that this version of Fatal understands.</source>
          <target state="translated">您用一个看起来不像子例程名称的参数调用了 &lt;code&gt;Fatal&lt;/code&gt; ，也没有使用此版本的Fatal可以理解的开关。</target>
        </trans-unit>
        <trans-unit id="dcf998c7dc1a2b4fcde7c406f8c5df0a1daf51ce" translate="yes" xml:space="preserve">
          <source>You've found a bug in &lt;code&gt;Fatal&lt;/code&gt; . Please report it using the &lt;code&gt;perlbug&lt;/code&gt; command.</source>
          <target state="translated">您已经在 &lt;code&gt;Fatal&lt;/code&gt; 中发现了一个错误。请使用 &lt;code&gt;perlbug&lt;/code&gt; 命令报告它。</target>
        </trans-unit>
        <trans-unit id="475fb69a6a2555d09a61f2284d19f582455e0ff5" translate="yes" xml:space="preserve">
          <source>You've insisted on hints for user-subroutines, either by pre-pending a &lt;code&gt;!&lt;/code&gt; to the subroutine name itself, or earlier in the list of arguments to &lt;code&gt;autodie&lt;/code&gt; . However the subroutine in question does not have any hints available.</source>
          <target state="translated">您一直坚持在用户子例程的提示上，方法是在前面加 &lt;code&gt;!&lt;/code&gt; 子例程名称本身，或在 &lt;code&gt;autodie&lt;/code&gt; 的参数列表中的较早位置。但是，所讨论的子例程没有任何可用提示。</target>
        </trans-unit>
        <trans-unit id="3c13a053a1a459196298d76dc68f54350a5781eb" translate="yes" xml:space="preserve">
          <source>You've probably seen shuffling algorithms that work using splice, randomly picking another element to swap the current element with</source>
          <target state="translated">你可能见过使用拼接工作的洗牌算法,随机挑选另一个元素与当前元素进行交换</target>
        </trans-unit>
        <trans-unit id="4f7734dcac6827c63f3c8f78e3f70fe360dc90d8" translate="yes" xml:space="preserve">
          <source>You've tried to use &lt;code&gt;Fatal&lt;/code&gt; on a Perl built-in that can't be overridden, such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, which means that &lt;code&gt;Fatal&lt;/code&gt; can't help you, although some other modules might. See the &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; section of this documentation.</source>
          <target state="translated">您尝试在无法覆盖的Perl内置组件上使用 &lt;code&gt;Fatal&lt;/code&gt; ，例如 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ，这意味着 &lt;code&gt;Fatal&lt;/code&gt; 无法为您提供帮助，尽管某些其他模块可能会帮助您。请&lt;a href=&quot;#SEE-ALSO&quot;&gt;参阅&lt;/a&gt;本文档的另请参阅部分。</target>
        </trans-unit>
        <trans-unit id="770547bed3b38328c9ebe9f8750573476f6753ff" translate="yes" xml:space="preserve">
          <source>Young and free of legacy weight, providing a lightweight and easy to learn API. Has a growing addon ecosystem. It is best used for smaller projects and very easy to learn for beginners.</source>
          <target state="translated">年轻,没有传统的重量,提供轻量级和易于学习的API。拥有一个不断发展的附加组件生态系统。它最适合用于小型项目,对于初学者来说非常容易学习。</target>
        </trans-unit>
        <trans-unit id="3c6f85b02933dd53061abea03a23ce712a1c9139" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; is most probably working just fine. It's the numbers that aren't quite what you think.</source>
          <target state="translated">您的 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; 最有可能工作得很好。这些数字与您的想法不符。</target>
        </trans-unit>
        <trans-unit id="df53f54d51a07584d7be09d83850a7da9c15786b" translate="yes" xml:space="preserve">
          <source>Your basic test. Pass if &lt;code&gt;$test&lt;/code&gt; is true, fail if $test is false. Just like Test::Simple's &lt;code&gt;ok()&lt;/code&gt; .</source>
          <target state="translated">您的基本测试。如果 &lt;code&gt;$test&lt;/code&gt; 为true，则通过；如果$ test为false，则失败。就像Test :: Simple的 &lt;code&gt;ok()&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="b237ec1c8f3c84ff91c26a3b96b070c2410531e4" translate="yes" xml:space="preserve">
          <source>Your best bet is to use the single argument form:</source>
          <target state="translated">你最好的选择是使用单参数形式。</target>
        </trans-unit>
        <trans-unit id="30a923bd50861e3e1f2796d154bd6dcc6842fa55" translate="yes" xml:space="preserve">
          <source>Your choice:</source>
          <target state="translated">你自己选吧</target>
        </trans-unit>
        <trans-unit id="2240cd19d3c19a8cd0a6388378dc061fa17be90f" translate="yes" xml:space="preserve">
          <source>Your commit message should describe what part of the Perl core you're changing and what you expect your patch to do.</source>
          <target state="translated">你的提交信息应该描述你要修改的 Perl 核心的哪一部分,以及你希望你的补丁做什么。</target>
        </trans-unit>
        <trans-unit id="9f522992b80d434f30bfc99a44403ac7ea5d333f" translate="yes" xml:space="preserve">
          <source>Your commit message should describe why the change you are making is important. When someone looks at your change in six months or six years, your intent should be clear.</source>
          <target state="translated">你的承诺信息应该描述为什么你所做的改变是重要的。当别人在六个月或六年后看到你的变化时,你的意图应该是明确的。</target>
        </trans-unit>
        <trans-unit id="0e92f837de5ea84ed03360a4aeae41a080276983" translate="yes" xml:space="preserve">
          <source>Your current &lt;b&gt;directory&lt;/b&gt;, from which relative pathnames are interpreted by the &lt;b&gt;operating system&lt;/b&gt;. The operating system knows your current directory because you told it with a &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;, or because you started out in the place where your parent &lt;b&gt;process&lt;/b&gt; was when you were born.</source>
          <target state="translated">您的当前&lt;b&gt;目录&lt;/b&gt;，&lt;b&gt;操作系统&lt;/b&gt;从该&lt;b&gt;目录&lt;/b&gt;解释相对路径名。操作系统知道您的当前目录是因为您使用 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 告诉了该目录，或者因为您是从出生时父&lt;b&gt;进程&lt;/b&gt;所在的地方开始的。</target>
        </trans-unit>
        <trans-unit id="d9200ca79b7b623bd2d92209c7c88d5edf0f0d25" translate="yes" xml:space="preserve">
          <source>Your custom type should then be picked up automatically by the &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="translated">然后，您的自定义类型应由&lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt;自动拾取。</target>
        </trans-unit>
        <trans-unit id="8e7f0615cde01baf7008f00eb9c075025028921a" translate="yes" xml:space="preserve">
          <source>Your distribution &lt;b&gt;must&lt;/b&gt; have a &lt;code&gt;NAME&lt;/code&gt; .</source>
          <target state="translated">您的发行版&lt;b&gt;必须&lt;/b&gt;有一个 &lt;code&gt;NAME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df70fd54c497020a59006e2165eb78aadc748605" translate="yes" xml:space="preserve">
          <source>Your first try should probably be the &lt;a href=&quot;text/balanced&quot;&gt;Text::Balanced&lt;/a&gt; module, which is in the Perl standard library since Perl 5.8. It has a variety of functions to deal with tricky text. The &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; module can also help by providing canned patterns you can use.</source>
          <target state="translated">您的第一个尝试可能应该是&lt;a href=&quot;text/balanced&quot;&gt;Text :: Balanced&lt;/a&gt;模块，该模块自Perl 5.8起就位于Perl标准库中。它具有多种功能来处理棘手的文本。在&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;正则表达式::常见&lt;/a&gt;模块还可以通过提供罐装模式，您可以使用帮助。</target>
        </trans-unit>
        <trans-unit id="880f6f429e2d63ef4a94f9a2206ede8287e74da3" translate="yes" xml:space="preserve">
          <source>Your interfaces should be understandable by an average Perl programmer. The following guidelines may help you judge whether your API is sufficiently straightforward:</source>
          <target state="translated">你的接口应该是一个普通的Perl程序员可以理解的。下面的指南可以帮助你判断你的API是否足够简单。</target>
        </trans-unit>
        <trans-unit id="d26baf198cb18edde520e205142e25037414abf9" translate="yes" xml:space="preserve">
          <source>Your internet domain name</source>
          <target state="translated">您的互联网域名</target>
        </trans-unit>
        <trans-unit id="c8e05b300242eb52ca20c1b662ee525c5256fe27" translate="yes" xml:space="preserve">
          <source>Your interpreter doesn't know how to communicate with these extensions on its own. A little glue will help. Up until now you've been calling</source>
          <target state="translated">你的解释器自己不知道如何与这些扩展通信。一点胶水会有帮助。到目前为止,你一直在调用</target>
        </trans-unit>
        <trans-unit id="926b6183d26bfd81c7f17ff04a868dae347149ae" translate="yes" xml:space="preserve">
          <source>Your mileage may vary...</source>
          <target state="translated">您的里程数可能会有所不同...</target>
        </trans-unit>
        <trans-unit id="60a065094064545ff1123708e618e1b6cf8cbd1c" translate="yes" xml:space="preserve">
          <source>Your mileage will vary. If in any doubt &lt;b&gt;do not use it&lt;/b&gt;.</source>
          <target state="translated">您的里程会有所不同。如有任何疑问，&lt;b&gt;请勿使用&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="c8a47834f473426f773c0b79429bd305f3db3ac9" translate="yes" xml:space="preserve">
          <source>Your module may be object oriented (OO) or not, or it may have both kinds of interfaces available. There are pros and cons of each technique, which should be considered when you design your API.</source>
          <target state="translated">你的模块可能是面向对象(OO)的,也可能不是,或者它可能有两种接口可用。每种技术都有优点和缺点,当你设计API时,应该考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="4936a62e724ff21109fff06e820adf4197164d03" translate="yes" xml:space="preserve">
          <source>Your module should also include a README file describing the module and giving pointers to further information (website, author email).</source>
          <target state="translated">你的模块还应该包含一个README文件,描述该模块,并提供进一步的信息(网站、作者邮箱)。</target>
        </trans-unit>
        <trans-unit id="290b95e5d44851668b2e9d3e7d74fdc415789c4e" translate="yes" xml:space="preserve">
          <source>Your module should have a clearly defined scope which is no longer than a single sentence. Can your module be broken down into a family of related modules?</source>
          <target state="translated">您的模块应该有一个明确定义的范围,不超过一句话。您的模块是否可以分解成一个相关模块的家族?</target>
        </trans-unit>
        <trans-unit id="8348552a40cd77a386588c2671c4e766e50a33bd" translate="yes" xml:space="preserve">
          <source>Your module should include documentation aimed at Perl developers. You should use Perl's &quot;plain old documentation&quot; (POD) for your general technical documentation, though you may wish to write additional documentation (white papers, tutorials, etc) in some other format. You need to cover the following subjects:</source>
          <target state="translated">你的模块应该包括针对 Perl 开发者的文档。你应该使用Perl的 &quot;老式文档&quot;(POD)来编写一般的技术文档,尽管你可能希望用其他格式来编写额外的文档(白皮书、教程等)。你需要涵盖以下主题。</target>
        </trans-unit>
        <trans-unit id="861d9c806a8066b7b2265b2640dfe765fcbec7fa" translate="yes" xml:space="preserve">
          <source>Your module should run successfully under the strict pragma and should run without generating any warnings. Your module should also handle taint-checking where appropriate, though this can cause difficulties in many cases.</source>
          <target state="translated">您的模块应该在strict pragma下成功运行,并且应该在不产生任何警告的情况下运行。您的模块也应该在适当的时候处理污点检查,尽管这在很多情况下会造成困难。</target>
        </trans-unit>
        <trans-unit id="55948057c1f1e500efb989c6858ac749bffed2dd" translate="yes" xml:space="preserve">
          <source>Your module will be part of a developer's toolkit. It will not, in itself, form the &lt;b&gt;entire&lt;/b&gt; toolkit. It's tempting to add extra features until your code is a monolithic system rather than a set of modular building blocks.</source>
          <target state="translated">您的模块将成为开发人员工具包的一部分。它本身不会构成&lt;b&gt;整个&lt;/b&gt;工具箱。诱人的是要添加额外的功能，直到您的代码是单片系统而不是一组模块化构建块。</target>
        </trans-unit>
        <trans-unit id="ad14f196f53d1d71d675a079baed8e60dbe25d0c" translate="yes" xml:space="preserve">
          <source>Your name for distributing the package with the version number included. This is used by 'make dist' to name the resulting archive file.</source>
          <target state="translated">你用来发布包含版本号的软件包的名称。这将被'make dist'用来命名生成的存档文件。</target>
        </trans-unit>
        <trans-unit id="175b500be69da19db3c39bbbb8f52b905fefd909" translate="yes" xml:space="preserve">
          <source>Your naming should be consistent. For instance, it's better to have:</source>
          <target state="translated">你的命名应该是一致的。比如说,最好有。</target>
        </trans-unit>
        <trans-unit id="f42ef3040bfea4a52c4a41099b15560c160072e6" translate="yes" xml:space="preserve">
          <source>Your new toolkit</source>
          <target state="translated">您的新工具箱</target>
        </trans-unit>
        <trans-unit id="ab842b2beec604e1059561d157771750a66116bd" translate="yes" xml:space="preserve">
          <source>Your patch may be returned with requests for changes, or requests for more detailed explanations about your fix.</source>
          <target state="translated">您的补丁可能会被退回,要求更改,或要求对您的修复进行更详细的解释。</target>
        </trans-unit>
        <trans-unit id="1fe050a844b774ad50502f71e6d05cbaaefcd33b" translate="yes" xml:space="preserve">
          <source>Your programs can use the Config module to check whether threads are enabled. If your program can't run without them, you can say something like:</source>
          <target state="translated">你的程序可以使用Config模块来检查是否启用了线程。如果你的程序没有线程就无法运行,你可以说这样的话。</target>
        </trans-unit>
        <trans-unit id="3998dbed349b6ee91c59e7ad32be8eef4f4d5eba" translate="yes" xml:space="preserve">
          <source>Your return address. The program will ask you to confirm its default if you don't use this option.</source>
          <target state="translated">您的返回地址。如果你不使用这个选项,程序会要求你确认它的默认地址。</target>
        </trans-unit>
        <trans-unit id="b4ef3a10fbcdb1f56987b1c90e4c788bb1481b23" translate="yes" xml:space="preserve">
          <source>Your script will declare a skip with the reason why you skipped and exit immediately with a zero (success). See &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; for details.</source>
          <target state="translated">您的脚本将声明一个跳过，说明您跳过的原因并立即以零（成功）退出。有关详细信息，请参见&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ffadff849a0704c5040d7dc21528967305be780" translate="yes" xml:space="preserve">
          <source>Your system documentation for &lt;code&gt;clock&lt;/code&gt; , &lt;code&gt;clock_gettime&lt;/code&gt; , &lt;code&gt;clock_getres&lt;/code&gt; , &lt;code&gt;clock_nanosleep&lt;/code&gt; , &lt;code&gt;clock_settime&lt;/code&gt; , &lt;code&gt;getitimer&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , &lt;code&gt;setitimer&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ualarm&lt;/code&gt; .</source>
          <target state="translated">您的 &lt;code&gt;clock&lt;/code&gt; ， &lt;code&gt;clock_gettime&lt;/code&gt; ， &lt;code&gt;clock_getres&lt;/code&gt; ， &lt;code&gt;clock_nanosleep&lt;/code&gt; ， &lt;code&gt;clock_settime&lt;/code&gt; ， &lt;code&gt;getitimer&lt;/code&gt; ， &lt;code&gt;gettimeofday&lt;/code&gt; ， &lt;code&gt;setitimer&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;ualarm&lt;/code&gt; 的系统文档。</target>
        </trans-unit>
        <trans-unit id="f45278c990de17bddc07886e62872d5705e84df2" translate="yes" xml:space="preserve">
          <source>Your system may also have man pages installed for those modules, in which case you can probably just use the man(1) command.</source>
          <target state="translated">你的系统可能还安装了这些模块的手册,在这种情况下,你可以直接使用 man(1)命令。</target>
        </trans-unit>
        <trans-unit id="f67311ed40fd91017f49e031b08d5e66ea348e7f" translate="yes" xml:space="preserve">
          <source>Your system may use lockfiles to control multiple access. Make sure you follow the correct protocol. Unpredictable behavior can result from multiple processes reading from one device.</source>
          <target state="translated">您的系统可能会使用锁文件来控制多个访问。确保您遵循正确的协议。从一个设备读取多个进程会导致不可预测的行为。</target>
        </trans-unit>
        <trans-unit id="69b78ca3bd9762db3a1f2fc87f8707247fab00ca" translate="yes" xml:space="preserve">
          <source>Your terminal expects ISO-8859-1 (yes/no)?</source>
          <target state="translated">您的终端希望使用ISO-8859-1(是/否)?</target>
        </trans-unit>
        <trans-unit id="eb27aa8afa0df31a742a7c36ee000dde7a333d59" translate="yes" xml:space="preserve">
          <source>Your test suite additions should generally follow these guidelines (courtesy of Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;):</source>
          <target state="translated">您添加的测试套件通常应遵循以下准则（由Gurusamy Sarathy提供：&amp;lt;gsar@activestate.com&amp;gt;）：</target>
        </trans-unit>
        <trans-unit id="6757bbaa3e59b9eae8d3358f1cb54cb3839ec256" translate="yes" xml:space="preserve">
          <source>Your text string will be sent using the bytes in Perl's internal format. In some cases, Perl will warn you that you're doing something wrong, with a friendly warning:</source>
          <target state="translated">你的文本字符串将使用Perl的内部格式的字节来发送。在某些情况下,Perl 会警告你做错了什么,并发出友好的警告。</target>
        </trans-unit>
        <trans-unit id="e6fdf4d82698552aa3b04fea17dd3738278fad63" translate="yes" xml:space="preserve">
          <source>Your version number for distributing the package. This defaults to 0.1.</source>
          <target state="translated">您发布软件包的版本号。默认值为0.1。</target>
        </trans-unit>
        <trans-unit id="6470a2f4b416b0ce03b530f9156d5bf0649ff6c9" translate="yes" xml:space="preserve">
          <source>Your version number for the .xs file of this package. This defaults to the value of the VERSION attribute.</source>
          <target state="translated">你的这个软件包的.xs文件的版本号。这个默认为VERSION属性的值。</target>
        </trans-unit>
        <trans-unit id="f943e56eab4587790a7d8e3702190e81dcdaf111" translate="yes" xml:space="preserve">
          <source>YourModule.pm</source>
          <target state="translated">YourModule.pm</target>
        </trans-unit>
        <trans-unit id="a032b09d002bfec745ff9618af85165922efa0c5" translate="yes" xml:space="preserve">
          <source>YourPackage.pm</source>
          <target state="translated">YourPackage.pm</target>
        </trans-unit>
        <trans-unit id="96b451942b04b66df98082b51a96fd9c21c979e6" translate="yes" xml:space="preserve">
          <source>YourPackage.xs</source>
          <target state="translated">YourPackage.xs</target>
        </trans-unit>
        <trans-unit id="3a63a963c11724e54297328f1cd01fab7cc056fb" translate="yes" xml:space="preserve">
          <source>YourProjClass-&amp;gt;fallback_language_classes()</source>
          <target state="translated">YourProjClass-&amp;gt;fallback_language_classes()</target>
        </trans-unit>
        <trans-unit id="93d7ab614acf51e6ed84bd194c23c002e0bc546a" translate="yes" xml:space="preserve">
          <source>YourProjClass-&amp;gt;fallback_languages()</source>
          <target state="translated">YourProjClass-&amp;gt;fallback_languages()</target>
        </trans-unit>
        <trans-unit id="98d44898a77a54f7718ada94977059bdfaa937a9" translate="yes" xml:space="preserve">
          <source>Yuval Kogman &amp;lt;nothingmuch@woobling.org&amp;gt;</source>
          <target state="translated">Yuval Kogman &amp;lt;nothingmuch@woobling.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cf3031c81c2a11248f63acc5b78e4d34caa6f6e1" translate="yes" xml:space="preserve">
          <source>Yves Orton suggested and helped for making &lt;code&gt;Sys::Syslog&lt;/code&gt; use the native event logger under Win32 systems.</source>
          <target state="translated">Yves Orton建议并帮助使 &lt;code&gt;Sys::Syslog&lt;/code&gt; 在Win32系统下使用本机事件记录器。</target>
        </trans-unit>
        <trans-unit id="909f99a779adb66a76fc53ab56c7dd1caf35d0fd" translate="yes" xml:space="preserve">
          <source>Z</source>
          <target state="translated">Z</target>
        </trans-unit>
        <trans-unit id="f2fd2a56c54b7c37d0d9f4b109a0de518f12a9a8" translate="yes" xml:space="preserve">
          <source>Zeus for Windows is another Win32 multi-language editor/IDE that comes with support for Perl.</source>
          <target state="translated">Zeus for Windows是另一个支持Perl的Win32多语言编辑器/IDE。</target>
        </trans-unit>
        <trans-unit id="db104e2c14625f90e76e1788e4a37b936ee652b6" translate="yes" xml:space="preserve">
          <source>Zlib Library Version Support</source>
          <target state="translated">Zlib库版本支持</target>
        </trans-unit>
        <trans-unit id="1e5c2f367f02e47a8c160cda1cd9d91decbac441" translate="yes" xml:space="preserve">
          <source>[</source>
          <target state="translated">[</target>
        </trans-unit>
        <trans-unit id="fd2a987f8fd28617d0641e26e1ee23e3f1c471fb" translate="yes" xml:space="preserve">
          <source>[.Foo.Bar]</source>
          <target state="translated">[.Foo.Bar]</target>
        </trans-unit>
        <trans-unit id="4b6373280a08e827a1ab5c68abe6349dceef8925" translate="yes" xml:space="preserve">
          <source>[.Lib.Auto.</source>
          <target state="translated">[.Lib.Auto.</target>
        </trans-unit>
        <trans-unit id="630f50e0cd8cffab6e0a142979fe618389586858" translate="yes" xml:space="preserve">
          <source>[.pod]</source>
          <target state="translated">[.pod]</target>
        </trans-unit>
        <trans-unit id="0cf7207af93f70e6c641ba1e90b8e15f86916573" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;http://en.wikipedia.org/wiki/Base64#URL_applications&quot;&gt;http://en.wikipedia.org/wiki/Base64#URL_applications&lt;/a&gt;</source>
          <target state="translated">[1] &lt;a href=&quot;http://en.wikipedia.org/wiki/Base64#URL_applications&quot;&gt;http://en.wikipedia.org/wiki/Base64#URL_applications&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6819c355b216edc67b6c6a8c6dab5509cee1376" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;http://perl.plover.com/Rx/paper/&quot;&gt;http://perl.plover.com/Rx/paper/&lt;/a&gt;</source>
          <target state="translated">[1] &lt;a href=&quot;http://perl.plover.com/Rx/paper/&quot;&gt;http://perl.plover.com/Rx/paper/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f4bcc9cdddccdc2ae22d3c3454a7739be0e29b10" translate="yes" xml:space="preserve">
          <source>[2] &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;</source>
          <target state="translated">[2] &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b002b78bc12a3ff6e29895fae1de731a69f453ae" translate="yes" xml:space="preserve">
          <source>[&lt;b&gt;-help&lt;/b&gt;] [&lt;b&gt;-man&lt;/b&gt;] [&lt;b&gt;-exit&lt;/b&gt;</source>
          <target state="translated">[ &lt;b&gt;-help&lt;/b&gt; ] [ &lt;b&gt;-man&lt;/b&gt; ] [ &lt;b&gt;-exit&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b0275f738749aa6cac8eb913cf57b88a87e7251a" translate="yes" xml:space="preserve">
          <source>[= =] and [. .]</source>
          <target state="translated">[= =]和[。。]</target>
        </trans-unit>
        <trans-unit id="afca1504bc2e3c3044d29b9874e85f36958af894" translate="yes" xml:space="preserve">
          <source>[Building/installing modules]</source>
          <target state="translated">[构建/安装模块]</target>
        </trans-unit>
        <trans-unit id="1c6555677db9746d71e639d2861c450df21a423a" translate="yes" xml:space="preserve">
          <source>[INTERNAL] Test whether</source>
          <target state="translated">[内部]测试是否</target>
        </trans-unit>
        <trans-unit id="3e3a19400d8a2d90d0db0e1989c48275083a979d" translate="yes" xml:space="preserve">
          <source>[INTERNAL] Tests whether the UTF8 flag is turned on in the</source>
          <target state="translated">[INTERNAL]测试UTF8标志是否在</target>
        </trans-unit>
        <trans-unit id="22eb99e5f093e515d3af9067fe7ea86722b6bbf1" translate="yes" xml:space="preserve">
          <source>[INTERNAL] Turns the</source>
          <target state="translated">[内部]将</target>
        </trans-unit>
        <trans-unit id="009b33a0528361398d9c707d1795bc4cfafeac38" translate="yes" xml:space="preserve">
          <source>[If you have the recommended version of bash for DJGPP, this is already done for you.]</source>
          <target state="translated">[如果您有推荐的DJGPP bash版本，则已经为您完成了。]</target>
        </trans-unit>
        <trans-unit id="5af5c7f45b299c973fea5c4dcd0294b1e6234199" translate="yes" xml:space="preserve">
          <source>[If you have the recommended versions of djdev, shell utilities and gawk, all these are already done for you, and you will not need to do anything.]</source>
          <target state="translated">[如果有推荐的djdev版本，shell实用程序和gawk版本，那么所有这些都已经为您完成，您将无需执行任何操作。</target>
        </trans-unit>
        <trans-unit id="f3b3a575af1d23fed1f5628631ec3936ffe0f6d1" translate="yes" xml:space="preserve">
          <source>[Installing/building perl]</source>
          <target state="translated">[安装/构建perl]</target>
        </trans-unit>
        <trans-unit id="5d1e8f7d83caac3b34475dd7d9e3096070d95629" translate="yes" xml:space="preserve">
          <source>[MAYCHANGE] In other words, the array or hash fetch/store functions don't really fetch and store actual values in the case of tied arrays and hashes. They merely call &lt;code&gt;mg_copy&lt;/code&gt; to attach magic to the values that were meant to be &quot;stored&quot; or &quot;fetched&quot;. Later calls to &lt;code&gt;mg_get&lt;/code&gt; and &lt;code&gt;mg_set&lt;/code&gt; actually do the job of invoking the TIE methods on the underlying objects. Thus the magic mechanism currently implements a kind of lazy access to arrays and hashes.</source>
          <target state="translated">[MAYCHANGE]换句话说，在绑定数组和哈希的情况下，数组或哈希获取/存储函数实际上并不获取和存储实际值。他们仅调用 &lt;code&gt;mg_copy&lt;/code&gt; 将魔术附加到本应&amp;ldquo;存储&amp;rdquo;或&amp;ldquo;获取&amp;rdquo;的值上。以后对 &lt;code&gt;mg_get&lt;/code&gt; 和 &lt;code&gt;mg_set&lt;/code&gt; 的调用实际上完成了在基础对象上调用TIE方法的工作。因此，魔术机制当前实现了对数组和哈希的一种惰性访问。</target>
        </trans-unit>
        <trans-unit id="2c69f013a0c0b9f7ed975da9c912abcf0653290a" translate="yes" xml:space="preserve">
          <source>[NEWVAL]</source>
          <target state="translated">[NEWVAL]</target>
        </trans-unit>
        <trans-unit id="4f834c241d7bdeabf113279ffdacebc7dc88459c" translate="yes" xml:space="preserve">
          <source>[Some of this answer was contributed by Kenneth Albanowski.]</source>
          <target state="translated">[部分答案是肯尼思&amp;middot;阿尔巴诺夫斯基（Kenneth Albanowski）提供的。]</target>
        </trans-unit>
        <trans-unit id="e9c2c8715a2a88d854204445ba9c4d5016aa0191" translate="yes" xml:space="preserve">
          <source>[This function has been largely superseded by the &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tie&lt;/a&gt; function.]</source>
          <target state="translated">[此功能已被&lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tie&lt;/a&gt;函数取代。]</target>
        </trans-unit>
        <trans-unit id="b1c00ee4c595ea64bb97d342fb1c568e80ba451b" translate="yes" xml:space="preserve">
          <source>[This function has been largely superseded by the &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; function.]</source>
          <target state="translated">[此功能已由 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 功能大大取代。]</target>
        </trans-unit>
        <trans-unit id="3b25169a6ac2e6f9178110c63d21693ee54fec41" translate="yes" xml:space="preserve">
          <source>[This function has been largely superseded by the &lt;code&gt;&lt;a href=&quot;untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; function.]</source>
          <target state="translated">[此功能已由 &lt;code&gt;&lt;a href=&quot;untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 功能大大取代。]</target>
        </trans-unit>
        <trans-unit id="466698b7c92675c3f06ae6b2691207f2e8b24913" translate="yes" xml:space="preserve">
          <source>[This section provides a short overview only...]</source>
          <target state="translated">[本节仅提供简短概述...]</target>
        </trans-unit>
        <trans-unit id="68ecc94bfa207a245a096cc2d83887da582b2e04" translate="yes" xml:space="preserve">
          <source>[This section still under construction. Ignore everything here. Post no bills. Everything not permitted is forbidden.]</source>
          <target state="translated">[此部分仍在建设中。忽略这里的一切。没有帐单。禁止所有不允许的事情。]</target>
        </trans-unit>
        <trans-unit id="69f3514fe4449506ca2c5d0bbc28b3f3698032b0" translate="yes" xml:space="preserve">
          <source>[Well, it was in</source>
          <target state="translated">[嗯，那是在</target>
        </trans-unit>
        <trans-unit id="88f04dbeb1493ee12988be863cfacc3c7afc777a" translate="yes" xml:space="preserve">
          <source>[linebreak]</source>
          <target state="translated">[linebreak]</target>
        </trans-unit>
        <trans-unit id="434d82c910fba2a895a5be59050f05f00a371e10" translate="yes" xml:space="preserve">
          <source>[r,t]</source>
          <target state="translated">[r,t]</target>
        </trans-unit>
        <trans-unit id="6018e494126b314973d815b3477ee1c68ccc6d49" translate="yes" xml:space="preserve">
          <source>[space][space]</source>
          <target state="translated">[space][space]</target>
        </trans-unit>
        <trans-unit id="cb559588de140bc32d992097ac9c98f627da21d3" translate="yes" xml:space="preserve">
          <source>\D is a negated \d; it represents any character but a digit</source>
          <target state="translated">\ D是否定的\ d; 它代表数字以外的任何字符</target>
        </trans-unit>
        <trans-unit id="6f370d6af4556227e5ea557e0c0431081559d1a3" translate="yes" xml:space="preserve">
          <source>\D is a negated \d; it represents any other character than a digit, or [^\d]</source>
          <target state="translated">\ D是否定的\ d; 它代表数字以外的任何其他字符，或[^ \ d]</target>
        </trans-unit>
        <trans-unit id="483707e791c24bf4f182daf8d06032f62bf516af" translate="yes" xml:space="preserve">
          <source>\N</source>
          <target state="translated">\N</target>
        </trans-unit>
        <trans-unit id="4b60caece8e9624e4c91f3da6482cbb9fa5912e3" translate="yes" xml:space="preserve">
          <source>\N, like the period, matches any character but &quot;\n&quot;, but it does so regardless of whether the modifier &lt;code&gt;//s&lt;/code&gt; is in effect.</source>
          <target state="translated">\ N与句点一样，匹配除&amp;ldquo; \ n&amp;rdquo;以外的任何字符，但是无论修饰符 &lt;code&gt;//s&lt;/code&gt; 是否有效，它都可以匹配。</target>
        </trans-unit>
        <trans-unit id="5201358bd3798962465786e1340b8d798eb0da66" translate="yes" xml:space="preserve">
          <source>\S is a negated \s; it represents any non-whitespace character</source>
          <target state="translated">\ S是取反的\ s; 它代表任何非空白字符</target>
        </trans-unit>
        <trans-unit id="2aaa2b30524de7ddb035b2ae4eda9d942f299a65" translate="yes" xml:space="preserve">
          <source>\S is a negated \s; it represents any non-whitespace character [^\s]</source>
          <target state="translated">\ S是取反的\ s; 它代表任何非空白字符[^ \ s]</target>
        </trans-unit>
        <trans-unit id="133129d31f2a64079b4ceec9832484853084047e" translate="yes" xml:space="preserve">
          <source>\W is a negated \w; it represents any non-word character</source>
          <target state="translated">\ W是负数\ w; 它代表任何非单词字符</target>
        </trans-unit>
        <trans-unit id="2f560e92ebecb72c198e33822a82e6e5d9a8c550" translate="yes" xml:space="preserve">
          <source>\W is a negated \w; it represents any non-word character [^\w]</source>
          <target state="translated">\ W是负数\ w; 它代表任何非单词字符[^ \ w]</target>
        </trans-unit>
        <trans-unit id="ddc0294fd2b2565335d9fa242ca21ab1de388250" translate="yes" xml:space="preserve">
          <source>\d is a digit and represents</source>
          <target state="translated">\ d是一个数字，代表</target>
        </trans-unit>
        <trans-unit id="97c6b30e873b86cfc47d930fe4d9ba2652595791" translate="yes" xml:space="preserve">
          <source>\d matches a digit, not just [0-9] but also digits from non-roman scripts</source>
          <target state="translated">\ d匹配一个数字，不仅是[0-9]，还匹配非罗马脚本中的数字</target>
        </trans-unit>
        <trans-unit id="ef7e6794ca9c6a06b54b66f279237fb8daaaeea8" translate="yes" xml:space="preserve">
          <source>\n</source>
          <target state="translated">\n</target>
        </trans-unit>
        <trans-unit id="7b4662d5c71b2e001cf94c995515942d7af18900" translate="yes" xml:space="preserve">
          <source>\s is a whitespace character and represents</source>
          <target state="translated">\ s是一个空格字符，代表</target>
        </trans-unit>
        <trans-unit id="34a39001363ef5f5ff61ce5c0f19ca73473f1c4c" translate="yes" xml:space="preserve">
          <source>\s matches a whitespace character, the set [\ \t\r\n\f] and others</source>
          <target state="translated">\ s匹配空白字符，集合[\ \ t \ r \ n \ f]和其他字符</target>
        </trans-unit>
        <trans-unit id="5b2fc8d661205bb1347d335b86f497e98283eb99" translate="yes" xml:space="preserve">
          <source>\w is a word character (alphanumeric or _) and represents</source>
          <target state="translated">\ w是单词字符（字母数字或_），表示</target>
        </trans-unit>
        <trans-unit id="9dec4b43c57ccafde6f9f014b8fdbdc6ad78db44" translate="yes" xml:space="preserve">
          <source>\w matches a word character (alphanumeric or _), not just [0-9a-zA-Z_] but also digits and characters from non-roman scripts</source>
          <target state="translated">\ w匹配一个单词字符（字母数字或_），不仅是[0-9a-zA-Z_]，而且还匹配非罗马脚本中的数字和字符</target>
        </trans-unit>
        <trans-unit id="3ae3339d3df42bd81574a61520ae7ec1b26f3f20" translate="yes" xml:space="preserve">
          <source>\xXX</source>
          <target state="translated">\xXX</target>
        </trans-unit>
        <trans-unit id="4ff447b8ef42ca51fa6fb287bed8d40f49be58f1" translate="yes" xml:space="preserve">
          <source>]</source>
          <target state="translated">]</target>
        </trans-unit>
        <trans-unit id="5270612a32d634db637d354ac0c6c3ea3a691c4e" translate="yes" xml:space="preserve">
          <source>] ...]</source>
          <target state="translated">] ...]</target>
        </trans-unit>
        <trans-unit id="7ba1b0d7168057117598130b4cf4913ce7a6d1dd" translate="yes" xml:space="preserve">
          <source>] [</source>
          <target state="translated">] [</target>
        </trans-unit>
        <trans-unit id="e5f96af2d25deb494bcf280fcc22ad9c64b0b550" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;--&lt;/b&gt; ] [</source>
          <target state="translated">] [ &lt;b&gt;-&lt;/b&gt; ] [</target>
        </trans-unit>
        <trans-unit id="7837a05d80f9d4246db05db7739ac9da350692ee" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-A&lt;/b&gt; ] [ &lt;b&gt;-ok&lt;/b&gt; | &lt;b&gt;-okay&lt;/b&gt; | &lt;b&gt;-nok&lt;/b&gt; | &lt;b&gt;-nokay&lt;/b&gt; ]</source>
          <target state="translated">] [ &lt;b&gt;-A&lt;/b&gt; ] [ &lt;b&gt;-ok&lt;/b&gt; | &lt;b&gt;-okay&lt;/b&gt; | &lt;b&gt;-nok&lt;/b&gt; | &lt;b&gt;-nokay&lt;/b&gt; ]</target>
        </trans-unit>
        <trans-unit id="5d5d86b624a368f240fc8ef717bfac5763b684cc" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-F&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-F&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fa5aee76641c8374c4a3bb363faca409d18cd95d" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-M&lt;/b&gt;[&lt;b&gt;-&lt;/b&gt;]</source>
          <target state="translated">] [ &lt;b&gt;-M&lt;/b&gt; [ &lt;b&gt;-&lt;/b&gt; ]</target>
        </trans-unit>
        <trans-unit id="fe33edc3b5acacf101538a5199d8ef6004372824" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-b&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-b&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d91a8c76a043075cdd5f57b8dc8dd020742dc547" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-c&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-c&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4088d7468ddaef6b6676933981d369aadcae05a4" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-e&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-e&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d446bd20cd4f210e32dddf0953007e6f2d1b5053" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-f&lt;/b&gt; ] [ &lt;b&gt;-C [&lt;i&gt;number/list&lt;/i&gt;] &lt;/b&gt;] [ &lt;b&gt;-S&lt;/b&gt; ] [ &lt;b&gt;-x&lt;/b&gt;[</source>
          <target state="translated">] [ &lt;b&gt;-f&lt;/b&gt; ] [ &lt;b&gt;-C [ &lt;i&gt;数字/列表&lt;/i&gt; ]&lt;/b&gt; ] [ &lt;b&gt;-S&lt;/b&gt; ] [ &lt;b&gt;-x&lt;/b&gt; [</target>
        </trans-unit>
        <trans-unit id="aca1a0eb03ef6c4968553072034eeee79bad305b" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-l&lt;/b&gt;[</source>
          <target state="translated">] [ &lt;b&gt;-l&lt;/b&gt; [</target>
        </trans-unit>
        <trans-unit id="f481bbb7a3ba5ecc6ab5d2ec8921b0caad222177" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-m&lt;/b&gt;[&lt;b&gt;-&lt;/b&gt;]</source>
          <target state="translated">] [ &lt;b&gt;-m&lt;/b&gt; [ &lt;b&gt;-&lt;/b&gt; ]</target>
        </trans-unit>
        <trans-unit id="7be946169865caf0b4ad4e1c551c97f832b6089b" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-r&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-r&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3b371bc5f1731a182afaca0f4c21e6e42f754174" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-s&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-s&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1cab1fd629b30db28801a88fb200dff0c7358250" translate="yes" xml:space="preserve">
          <source>] [ &lt;code&gt;,&lt;/code&gt; [</source>
          <target state="translated">] [ &lt;code&gt;,&lt;/code&gt; [</target>
        </trans-unit>
        <trans-unit id="60ce1ac427ca955aba7df5e26e666a0cbcdc2f9a" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--date&lt;/b&gt;=</source>
          <target state="translated">] [ &lt;b&gt;--date&lt;/b&gt; =</target>
        </trans-unit>
        <trans-unit id="d95dd25605574b2c81782f8507419949dc89534a" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--errors&lt;/b&gt;=</source>
          <target state="translated">] [ &lt;b&gt;--errors&lt;/b&gt; =</target>
        </trans-unit>
        <trans-unit id="fbbc117050d9385ff235a1dc760a3b8dfa0999cc" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--fixed&lt;/b&gt;=</source>
          <target state="translated">] [ &lt;b&gt;--fixed&lt;/b&gt; =</target>
        </trans-unit>
        <trans-unit id="a9250074a5445bcf8eef004dc71ec67ecb9c809b" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--fixedbold&lt;/b&gt;=</source>
          <target state="translated">] [ &lt;b&gt;--fixedbold&lt;/b&gt; =</target>
        </trans-unit>
        <trans-unit id="d7f9db810e921cd28d21cd440fca4722b8d4bf69" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--fixedbolditalic&lt;/b&gt;=</source>
          <target state="translated">] [ &lt;b&gt;--fixedbolditalic&lt;/b&gt; =</target>
        </trans-unit>
        <trans-unit id="aa2fbdd948dba01a46110fa01725308ca2ef5a08" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--fixeditalic&lt;/b&gt;=</source>
          <target state="translated">] [ &lt;b&gt;--fixeditalic&lt;/b&gt; =</target>
        </trans-unit>
        <trans-unit id="6fe77b356c6468bc7d92a318ad6bc1146c2e9172" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--name&lt;/b&gt;=</source>
          <target state="translated">] [ &lt;b&gt;--name&lt;/b&gt; =</target>
        </trans-unit>
        <trans-unit id="39d7370445bc798950f647a09f55cf0aa24d1af4" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--nourls&lt;/b&gt;] [&lt;b&gt;--official&lt;/b&gt;] [&lt;b&gt;--quotes&lt;/b&gt;=</source>
          <target state="translated">] [ &lt;b&gt;--nourls&lt;/b&gt; ] [ &lt;b&gt;--official&lt;/b&gt; ] [ &lt;b&gt;--quotes&lt;/b&gt; =</target>
        </trans-unit>
        <trans-unit id="3ec1ee1005b040af6eed1e1fb1b89be01226d9ce" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--nourls&lt;/b&gt;] [&lt;b&gt;--stderr&lt;/b&gt;] [&lt;b&gt;-w&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;--nourls&lt;/b&gt; ] [ &lt;b&gt;--stderr&lt;/b&gt; ] [ &lt;b&gt;-w&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc864e3beb0db82da5fea274b5d83179e2d64279" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--release&lt;/b&gt;[=</source>
          <target state="translated">] [- &lt;b&gt;版本&lt;/b&gt; [=</target>
        </trans-unit>
        <trans-unit id="039bb11ec7e8c6197572dde03eb7f6b45f6c8aa6" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--stderr&lt;/b&gt;] [&lt;b&gt;--utf8&lt;/b&gt;] [&lt;b&gt;--verbose&lt;/b&gt;] [</source>
          <target state="translated">] [ &lt;b&gt;--stderr&lt;/b&gt; ] [ &lt;b&gt;--utf8&lt;/b&gt; ] [ &lt;b&gt;--verbose&lt;/b&gt; ] [</target>
        </trans-unit>
        <trans-unit id="a4b5a58dd7ad938ef0e7ae582da7c0d873b1c242" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;-formatter&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-formatter&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3fea5aca88ab916f93ed287dace98a76f7c143b9" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;-i&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-i&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="53f6bda63d23372157c365e9965c7ef45e33a277" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;-output&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-输出&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="18e0dd56af29c5174edbefe6f7085682dda6e116" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;-pathlist&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-pathlist&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="22e124d430902d5c5221cf1c7cf4da237a26222d" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;-q&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-q&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0fde4e5d48f00a1e501ad8fe7e8926bde75175b1" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;-verbose&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-verbose&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e725a8e5ac100bccc71bd3fa100f49857c67db06" translate="yes" xml:space="preserve">
          <source>] ] &lt;code&gt;}&lt;/code&gt;.</source>
          <target state="translated">]] &lt;code&gt;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="840af7de6cad4319ff4be78eacfb9c5acf43cf39" translate="yes" xml:space="preserve">
          <source>] ] [ &lt;b&gt;-0&lt;/b&gt;[</source>
          <target state="translated">]] [ &lt;b&gt;-0&lt;/b&gt; [</target>
        </trans-unit>
        <trans-unit id="9bd44ceffbf549e2ad098d1002b1d677b7d0aa0b" translate="yes" xml:space="preserve">
          <source>] ] [ &lt;b&gt;-D&lt;/b&gt;[</source>
          <target state="translated">]] [ &lt;b&gt;-D&lt;/b&gt; [</target>
        </trans-unit>
        <trans-unit id="7bb86a5d6f5da412edc5fa8d69ccfe2ff581bca6" translate="yes" xml:space="preserve">
          <source>] ] [ &lt;b&gt;-I&lt;/b&gt;</source>
          <target state="translated">]] [ &lt;b&gt;-I&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="598e07f95f029fa4f2ce352acaf2288c664b4b76" translate="yes" xml:space="preserve">
          <source>] ] [ &lt;b&gt;-cw&lt;/b&gt; ] [ &lt;b&gt;-d&lt;/b&gt;[&lt;b&gt;t&lt;/b&gt;][:</source>
          <target state="translated">]] [ &lt;b&gt;-cw&lt;/b&gt; ] [ &lt;b&gt;-d&lt;/b&gt; [ &lt;b&gt;t&lt;/b&gt; ] [：</target>
        </trans-unit>
        <trans-unit id="9db4a34f3f65d57a976aae91bae6f7bcb0835f01" translate="yes" xml:space="preserve">
          <source>] ] [ &lt;b&gt;-i&lt;/b&gt;[</source>
          <target state="translated">]] [ &lt;b&gt;-i&lt;/b&gt; [</target>
        </trans-unit>
        <trans-unit id="9d460c5f4d3c2477cabad0ac755529bb24fc2217" translate="yes" xml:space="preserve">
          <source>] ] [ &lt;b&gt;-pna&lt;/b&gt; ] [ &lt;b&gt;-F&lt;/b&gt;</source>
          <target state="translated">]] [ &lt;b&gt;-pna&lt;/b&gt; ] [ &lt;b&gt;-F&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc8d2ac6bf0f644f728f5f8cfc8080a8f51efa0e" translate="yes" xml:space="preserve">
          <source>] ] [ [&lt;b&gt;-e&lt;/b&gt;|&lt;b&gt;-E&lt;/b&gt;]</source>
          <target state="translated">]] [[ &lt;b&gt;-e&lt;/b&gt; | &lt;b&gt;-E&lt;/b&gt; ]</target>
        </trans-unit>
        <trans-unit id="9a7dbaad3cf2aa9abf7389e31afb732d6e15865c" translate="yes" xml:space="preserve">
          <source>]. I.e., &quot;_1&quot; becomes with $_[1], and &quot;_-3&quot; is interpreted as $_[-3] (in which case @_ should have at least three elements in it). Note that $_[0] is the language handle, and is typically not named directly.</source>
          <target state="translated">]。即，&amp;ldquo; _ 1&amp;rdquo;与$ _ [1]一起出现，而&amp;ldquo; _-3&amp;rdquo;被解释为$ _ [-3]（在这种情况下，@_中应至少包含三个元素）。请注意，$ _ [0]是语言句柄，通常不会直接命名。</target>
        </trans-unit>
        <trans-unit id="3fad04c26433591d23451512c23642ef92daf2c6" translate="yes" xml:space="preserve">
          <source>]...</source>
          <target state="translated">]...</target>
        </trans-unit>
        <trans-unit id="36407ed3b603d0dfcd1bd6d50bc3fd8861d8d53f" translate="yes" xml:space="preserve">
          <source>][&lt;b&gt;,-p&lt;/b&gt;][&lt;b&gt;,-q&lt;/b&gt;][&lt;b&gt;,-l&lt;/b&gt;] [&lt;b&gt;,-s&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;，-p&lt;/b&gt; ] [ &lt;b&gt;，-q&lt;/b&gt; ] [ &lt;b&gt;，-l&lt;/b&gt; ] [ &lt;b&gt;，-s&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a9030ca5cbcfd3f3b2ec230506e50fbd3cb2d7e0" translate="yes" xml:space="preserve">
          <source>][&lt;b&gt;,-x&lt;/b&gt;</source>
          <target state="translated">][&lt;b&gt;,-x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8755a99ada779c83177a95e225a5063fe7499c98" translate="yes" xml:space="preserve">
          <source>]] [&lt;b&gt;--section&lt;/b&gt;=</source>
          <target state="translated">]] [ &lt;b&gt;--section&lt;/b&gt; =</target>
        </trans-unit>
        <trans-unit id="52fd940d0f74d5bee59eaa7c4f0549763254e747" translate="yes" xml:space="preserve">
          <source>_AUTHORS_</source>
          <target state="translated">_AUTHORS_</target>
        </trans-unit>
        <trans-unit id="6b18f91a4d56bcb4195d01326c1707f269dca59a" translate="yes" xml:space="preserve">
          <source>_FFFE and 0x</source>
          <target state="translated">_FFFE和0x</target>
        </trans-unit>
        <trans-unit id="9ab76b9bb5c2c00731a6298f38a4cee313b768d1" translate="yes" xml:space="preserve">
          <source>_FFFF), all non-shortest encodings, etc.</source>
          <target state="translated">_FFFF），所有非最短编码等。</target>
        </trans-unit>
        <trans-unit id="335f29be57bcf11c73c32f1eb934a4263c82062e" translate="yes" xml:space="preserve">
          <source>_MANIFEST_</source>
          <target state="translated">_MANIFEST_</target>
        </trans-unit>
        <trans-unit id="95a35cef151f823296dfad3b7387390964178aff" translate="yes" xml:space="preserve">
          <source>_PDF_ files</source>
          <target state="translated">_PDF_个文件</target>
        </trans-unit>
        <trans-unit id="a004e5d824ef48686abd54ae20b660d4a2c545c5" translate="yes" xml:space="preserve">
          <source>_Really_ Symbolic Calculator</source>
          <target state="translated">_Really_符号计算器</target>
        </trans-unit>
        <trans-unit id="544b04467d0a8ee1a845e4b919a57d9da6144a5e" translate="yes" xml:space="preserve">
          <source>__DATA__</source>
          <target state="translated">__DATA__</target>
        </trans-unit>
        <trans-unit id="c7919376414e8b09a0411c19eee34a71902436cc" translate="yes" xml:space="preserve">
          <source>__DATA__, __END__, and the FOOBAR::DATA filehandle.</source>
          <target state="translated">__DATA __，__ END__和FOOBAR :: DATA文件句柄。</target>
        </trans-unit>
        <trans-unit id="ce8a6e08bc25f2ef37956e900401265cf56138c8" translate="yes" xml:space="preserve">
          <source>__END__</source>
          <target state="translated">__END__</target>
        </trans-unit>
        <trans-unit id="9d5d8995523b8b8951428baa81ea663ff0bd2c77" translate="yes" xml:space="preserve">
          <source>__FILE__</source>
          <target state="translated">__FILE__</target>
        </trans-unit>
        <trans-unit id="a51b95694c81c92580bff6f580f8e200ecf86661" translate="yes" xml:space="preserve">
          <source>__LINE__</source>
          <target state="translated">__LINE__</target>
        </trans-unit>
        <trans-unit id="04bd40a79312fa43a624aef25ac864c0770871a3" translate="yes" xml:space="preserve">
          <source>__PACKAGE__</source>
          <target state="translated">__PACKAGE__</target>
        </trans-unit>
        <trans-unit id="b0563c4fda49219aeb921efb5a63d4cff221a59b" translate="yes" xml:space="preserve">
          <source>__SUB__</source>
          <target state="translated">__SUB__</target>
        </trans-unit>
        <trans-unit id="aba4564d3c1fb21ecf21279947a269bfd72d5448" translate="yes" xml:space="preserve">
          <source>__int64</source>
          <target state="translated">__int64</target>
        </trans-unit>
        <trans-unit id="3485357323ef68368533ee148f92fcc38f19f972" translate="yes" xml:space="preserve">
          <source>_bgcd()</source>
          <target state="translated">_bgcd()</target>
        </trans-unit>
        <trans-unit id="3cde53170729285b62e4195015718cc3fccd9d47" translate="yes" xml:space="preserve">
          <source>_control87(3)</source>
          <target state="translated">_control87(3)</target>
        </trans-unit>
        <trans-unit id="ff4fbe22558273c6659ff3e79e3859bcae2f877b" translate="yes" xml:space="preserve">
          <source>_digit($obj, 0)</source>
          <target state="translated">_digit（$ obj，0）</target>
        </trans-unit>
        <trans-unit id="25fb2a539a78bedeb7219e53f2b8469577c24022" translate="yes" xml:space="preserve">
          <source>_digit(123, -1)</source>
          <target state="translated">_digit（123，-1）</target>
        </trans-unit>
        <trans-unit id="a23c4cef0829fb103be12bd8e5048bf513e4694f" translate="yes" xml:space="preserve">
          <source>_perl.exe_</source>
          <target state="translated">_perl.exe_</target>
        </trans-unit>
        <trans-unit id="2f72a716af3238025dd4229dd58b83bc8629ac38" translate="yes" xml:space="preserve">
          <source>_perl_.exe_</source>
          <target state="translated">_perl_.exe_</target>
        </trans-unit>
        <trans-unit id="5991d513b9abe99f11e9b16c8256e4e9e06ca2ba" translate="yes" xml:space="preserve">
          <source>_perl__.exe_</source>
          <target state="translated">_perl__.exe_</target>
        </trans-unit>
        <trans-unit id="2db94965490eada37ae5ff14a1e0846dbe050e7c" translate="yes" xml:space="preserve">
          <source>_perl___.exe_</source>
          <target state="translated">_perl___.exe_</target>
        </trans-unit>
        <trans-unit id="1fdbb463b8aba017e1e17708622b828c0a70d691" translate="yes" xml:space="preserve">
          <source>_prove</source>
          <target state="translated">_prove</target>
        </trans-unit>
        <trans-unit id="998aae22ec5a43bf133ffb2d411823f4c8a72a20" translate="yes" xml:space="preserve">
          <source>_proverc</source>
          <target state="translated">_proverc</target>
        </trans-unit>
        <trans-unit id="be410059a97a4524ce3b914f3e9c9e407663c029" translate="yes" xml:space="preserve">
          <source>_read</source>
          <target state="translated">_read</target>
        </trans-unit>
        <trans-unit id="8f67b7c018384a0d10f9d2b4577d0c0658bc078a" translate="yes" xml:space="preserve">
          <source>_stdlib.h_ functions</source>
          <target state="translated">_stdlib.h_函数</target>
        </trans-unit>
        <trans-unit id="d4086139b290958ed25f5bd7a1ff3d730dcf31a9" translate="yes" xml:space="preserve">
          <source>_sub()</source>
          <target state="translated">_sub()</target>
        </trans-unit>
        <trans-unit id="ab1aafd933e3c1f34b78838ca464fabb2cd4e4ef" translate="yes" xml:space="preserve">
          <source>_utf8_off</source>
          <target state="translated">_utf8_off</target>
        </trans-unit>
        <trans-unit id="17db770cf15f37a3c9f4bbc8584367bfd333dd75" translate="yes" xml:space="preserve">
          <source>_utf8_on</source>
          <target state="translated">_utf8_on</target>
        </trans-unit>
        <trans-unit id="349a2cf958187a837c3aed60aca5ce84a2ba8f78" translate="yes" xml:space="preserve">
          <source>`Memoizing' a function makes it faster by trading space for time. It does this by caching the return values of the function in a table. If you call the function again with the same arguments, &lt;code&gt;memoize&lt;/code&gt; jumps in and gives you the value out of the table, instead of letting the function compute the value all over again.</source>
          <target state="translated">&amp;ldquo;记忆&amp;rdquo;功能可以通过交换时间来使其更快。它通过在表中缓存函数的返回值来实现。如果再次使用相同的参数调用该函数，则 &lt;code&gt;memoize&lt;/code&gt; 会跳转并为您提供表中的值，而不是让该函数重新计算该值。</target>
        </trans-unit>
        <trans-unit id="97a327decd1b5a73620456539cf89766d09acb8c" translate="yes" xml:space="preserve">
          <source>`` and pipe-open do not work under DOS.</source>
          <target state="translated">``和管道打开在DOS下不起作用。</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="049537f8ff01227a5296e1d4f8184a98a3f6ecb6" translate="yes" xml:space="preserve">
          <source>a &lt;b&gt;-u&lt;/b&gt; flag to make it unbuffered. But very few commands are designed to operate over pipes, so this seldom works unless you yourself wrote the program on the other end of the double-ended pipe.</source>
          <target state="translated">一个&lt;b&gt;-u&lt;/b&gt;标志，使其缓冲。但是设计用于在管道上运行的命令很少，因此除非您自己在双端管道的另一端编写了程序，否则这很少起作用。</target>
        </trans-unit>
        <trans-unit id="29515f80a90ad15c4d7bd700ddff82308e27f071" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;DESTROY&lt;/code&gt; method), which the call to &lt;code&gt;EVERY::LAST::Destroy&lt;/code&gt; in the inherited destructor then correctly picks up.</source>
          <target state="translated">一个 &lt;code&gt;DESTROY&lt;/code&gt; 方法），其调用 &lt;code&gt;EVERY::LAST::Destroy&lt;/code&gt; 在继承的析构函数然后正确拾取。</target>
        </trans-unit>
        <trans-unit id="5b4991d0075936f9dd187e536d33c94e2aa27450" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;new&lt;/code&gt; method), which the call to &lt;code&gt;EVERY::LAST::Init&lt;/code&gt; in the inherited constructor then correctly picks up.</source>
          <target state="translated">一个 &lt;code&gt;new&lt;/code&gt; 方法），然后在继承的构造函数中对 &lt;code&gt;EVERY::LAST::Init&lt;/code&gt; 的调用会正确进行。</target>
        </trans-unit>
        <trans-unit id="c969393479d626630230a3b33439fab76b06b48e" translate="yes" xml:space="preserve">
          <source>a PREFIX was given as an argument to WriteMakefile() it will set it to the $new_prefix + $default. This is for systems whose file layouts don't neatly fit into our ideas of prefixes.</source>
          <target state="translated">如果WriteMakefile()给了一个Prefix作为参数,那么它将把它设置为$new_prefix+$default。这是为那些文件布局不符合我们对前缀的理解的系统准备的。</target>
        </trans-unit>
        <trans-unit id="1e7f6022e597b2747e658cd9274fe1392855ea63" translate="yes" xml:space="preserve">
          <source>a Pod block with a &quot;=cut&quot; command. In that case, the Pod processor must halt parsing of the input file, and must by default emit a warning.</source>
          <target state="translated">一个带有&quot;=cut &quot;命令的Pod块。在这种情况下,Pod处理器必须停止对输入文件的解析,并默认发出警告。</target>
        </trans-unit>
        <trans-unit id="a295228fd9bd780a4f55d14f8063050501961916" translate="yes" xml:space="preserve">
          <source>a blank (read: empty) line, with the single exception of the file start, which is also starting a paragraph. That means that especially a command (e.g. &lt;code&gt;=head1&lt;/code&gt; )</source>
          <target state="translated">空白（读取：空）行，但文件start例外，该文件也开始一段。这意味着特别是一个命令（例如 &lt;code&gt;=head1&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="75c1385dc7bf5ab285efa7812871a616728a97fa" translate="yes" xml:space="preserve">
          <source>a blank line.</source>
          <target state="translated">空行。</target>
        </trans-unit>
        <trans-unit id="23d9744ba98ffa764233c38e2d3604f3b2d4a76e" translate="yes" xml:space="preserve">
          <source>a bytestream and should not be treated as such. This makes using I/O mechanisms with internal buffering like stdio (i.e. print() and friends) especially cumbersome. Use syswrite(), or better send(), like in the example below.</source>
          <target state="translated">是一个bytestream,不应该被当作是一个bytestream。这使得使用像stdio这样的内部缓冲的I/O机制(即print()和friends)特别麻烦。使用syswrite(),或者更好的send(),就像下面的例子。</target>
        </trans-unit>
        <trans-unit id="633f7c37ae295810943767d3bf2df992ec0feaea" translate="yes" xml:space="preserve">
          <source>a call to &lt;code&gt;SvPV()&lt;/code&gt; or one of its variants, in case any call to string overloading updates the internal UTF-8 encoding flag.</source>
          <target state="translated">如果对字符串重载的任何调用都会更新内部UTF-8编码标志，则对 &lt;code&gt;SvPV()&lt;/code&gt; 或其变体之一的调用。</target>
        </trans-unit>
        <trans-unit id="3db5176b71e2550579d05b0d599c0802a2e9855b" translate="yes" xml:space="preserve">
          <source>a call to SvPV() or one of its variants, in case any call to string overloading updates the internal flag.</source>
          <target state="translated">调用SvPV()或它的一个变体,以防任何对字符串重载的调用更新内部标志。</target>
        </trans-unit>
        <trans-unit id="8e150fc9a00a9d6aba574abf6b3ddaf310665b85" translate="yes" xml:space="preserve">
          <source>a caller (that is, if we're in a subroutine or &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;) and the undefined value otherwise. caller never returns XS subs and they are skipped. The next pure perl sub will appear instead of the XS sub in caller's return values. In list context, caller returns</source>
          <target state="translated">调用方（也就是说，如果我们在子例程， &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 中），否则为未定义的值。调用者从不返回XS子，它们将被跳过。在调用者的返回值中，将出现下一个纯perl子而不是XS子。在列表上下文中，调用者返回</target>
        </trans-unit>
        <trans-unit id="27f90951a846aad1e51cfa906ae9aae15befd397" translate="yes" xml:space="preserve">
          <source>a caller (that is, if we're in a subroutine or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;) and the undefined value otherwise. caller never returns XS subs and they are skipped. The next pure perl sub will appear instead of the XS sub in caller's return values. In list context, caller returns</source>
          <target state="translated">调用方（也就是说，如果我们在子例程， &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 中），否则为未定义的值。调用者从不返回XS子，它们将被跳过。在调用者的返回值中，将出现下一个纯perl子而不是XS子。在列表上下文中，调用者返回</target>
        </trans-unit>
        <trans-unit id="98a69b7d014f4c34538d96daa513e20ae3249ccf" translate="yes" xml:space="preserve">
          <source>a character</source>
          <target state="translated">字样</target>
        </trans-unit>
        <trans-unit id="4d30a63fe6161c410a2de8ef976b935b79ebde5a" translate="yes" xml:space="preserve">
          <source>a directory which the extensions Perl library module passes to the DynaLoader when asking it to map the shareable image, or</source>
          <target state="translated">当要求DynaLoader映射可共享镜像时,扩展Perl库模块传递给DynaLoader的目录,或</target>
        </trans-unit>
        <trans-unit id="d53e127062317983028dd489e9754291d72caa45" translate="yes" xml:space="preserve">
          <source>a dummy implementation.</source>
          <target state="translated">一个假的实施。</target>
        </trans-unit>
        <trans-unit id="607bd3e7b2e3b5390e3bf8ef6a8b9efe50dc7299" translate="yes" xml:space="preserve">
          <source>a failure of the OS/2 API call, having some workarounds coded).</source>
          <target state="translated">OS/2 API调用失败,有一些变通办法)。)</target>
        </trans-unit>
        <trans-unit id="f2f9eb42b04a6bb70eb81a0ae0a802e7347d6301" translate="yes" xml:space="preserve">
          <source>a filehandle, even though it looks like one). DBNAME is the name of the database (without the</source>
          <target state="translated">是一个文件柄,尽管它看起来像一个)。)DBNAME是数据库的名称(不含下面的</target>
        </trans-unit>
        <trans-unit id="d89a37a0200dc0b35d04809afbc53cbf5901983a" translate="yes" xml:space="preserve">
          <source>a function, and precedence doesn't matter. Otherwise it's a list operator or unary operator, and precedence does matter. Whitespace between the function and left parenthesis doesn't count, so sometimes you need to be careful:</source>
          <target state="translated">一个函数,优先级并不重要。否则就是一个列表运算符或单数运算符,优先级确实很重要。函数和左括号之间的空白不计,所以有时你需要小心。</target>
        </trans-unit>
        <trans-unit id="42d8657e92871e593008c5368345a46e3ebc4eac" translate="yes" xml:space="preserve">
          <source>a hard reference. If you use it as a reference, it'll be treated as a symbolic reference. That is, the value of the scalar is taken to be the</source>
          <target state="translated">一个硬引用。如果你把它作为一个参考,它将被当作一个符号参考。也就是说,标量的值会被当作是那个</target>
        </trans-unit>
        <trans-unit id="b47a8f555bfc4607fa743152b516f486d86995c9" translate="yes" xml:space="preserve">
          <source>a leading &quot;:&quot;. Empty portions are returned as empty string ''.</source>
          <target state="translated">前面的&quot;:&quot;。空的部分将作为空字符串''返回。</target>
        </trans-unit>
        <trans-unit id="c3ead9f1232af179bcf0c56760a744aa581fa638" translate="yes" xml:space="preserve">
          <source>a long time ago, and some people got used to our funny spelling, and so just as with &lt;code&gt;HTTP_REFERER&lt;/code&gt; &amp;rsquo;s own missing letter, our weird spelling has stuck around.</source>
          <target state="translated">很久以前，有些人已经习惯了我们有趣的拼写，因此就像 &lt;code&gt;HTTP_REFERER&lt;/code&gt; 自己的丢失字母一样，我们的怪异拼写仍然存在。</target>
        </trans-unit>
        <trans-unit id="c5ab2e702917e9fab9c642c3876da1a3b4538ce1" translate="yes" xml:space="preserve">
          <source>a mergesort, which happens to be stable, will be employed anyway. Note that</source>
          <target state="translated">恰好是稳定的合并排序,将被采用。请注意</target>
        </trans-unit>
        <trans-unit id="02537a2b811222631d1996c38165a9255a043dba" translate="yes" xml:space="preserve">
          <source>a noun (i.e., saying how much of it there is, while giving the correct form of it). The behavior of this method is handy for English and a few other Western European languages, and you should override it for languages where it's not suitable. You can feel free to read the source, but the current implementation is basically as this pseudocode describes:</source>
          <target state="translated">一个名词(即说它有多少,同时给出它的正确形式)。这个方法的行为对于英语和其他一些西欧语言来说很方便,对于不适合的语言,你应该覆盖它。你可以随意阅读源码,但目前的实现基本如这个伪代码所描述的那样。</target>
        </trans-unit>
        <trans-unit id="cbaad0f8fdd1c074dd23e8663bc741bba26c0e9b" translate="yes" xml:space="preserve">
          <source>a number &lt;code&gt;OS_MAJOR + 0.001 * OS_MINOR&lt;/code&gt; .</source>
          <target state="translated">一个数字 &lt;code&gt;OS_MAJOR + 0.001 * OS_MINOR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20b1aa3e6979f290ef40d1e602b1d7ee858c53e5" translate="yes" xml:space="preserve">
          <source>a parse error.</source>
          <target state="translated">来解析错误。</target>
        </trans-unit>
        <trans-unit id="36958640033ae606fe1d0a4aeb5cf8119f6964e4" translate="yes" xml:space="preserve">
          <source>a particular place, in combination with non-linguistic location-specific information such as what currency is used there. Locales</source>
          <target state="translated">一个特定的地方,结合非语言的特定地点信息,如那里使用什么货币。地点</target>
        </trans-unit>
        <trans-unit id="427679a88e71c9d05f75a15acaaf64e423868907" translate="yes" xml:space="preserve">
          <source>a posteriori</source>
          <target state="translated">事后</target>
        </trans-unit>
        <trans-unit id="a7361da6063a7ceef198f250842e89b36593b797" translate="yes" xml:space="preserve">
          <source>a reference to a &lt;code&gt;Pod::Paragraph&lt;/code&gt; object which contains further information about the paragraph (see &lt;a href=&quot;inputobjects&quot;&gt;Pod::InputObjects&lt;/a&gt; for details).</source>
          <target state="translated">对 &lt;code&gt;Pod::Paragraph&lt;/code&gt; 对象的引用，该对象包含有关该段落的更多信息（有关详细信息，请参见&lt;a href=&quot;inputobjects&quot;&gt;Pod :: InputObjects&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c80e050c47afd7c7439491b82841365aa5c3f43a" translate="yes" xml:space="preserve">
          <source>a reference to a &lt;code&gt;Pod::Paragraph&lt;/code&gt; object which contains further information about the paragraph command (see &lt;a href=&quot;inputobjects&quot;&gt;Pod::InputObjects&lt;/a&gt; for details).</source>
          <target state="translated">对 &lt;code&gt;Pod::Paragraph&lt;/code&gt; 对象的引用，该对象包含有关段落命令的更多信息（有关详细信息，请参见&lt;a href=&quot;inputobjects&quot;&gt;Pod :: InputObjects&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f1cf41b67f8ac934bdb1895a8415ee32895dafcf" translate="yes" xml:space="preserve">
          <source>a reference to the subroutine;</source>
          <target state="translated">对子程序的引用。</target>
        </trans-unit>
        <trans-unit id="c10bb3ae2e9e12614dc451b112b763b0e4c6ea09" translate="yes" xml:space="preserve">
          <source>a reference to the symbol table entry (typeglob) containing the subroutine;</source>
          <target state="translated">对包含子程序的符号表条目(typeglob)的引用。</target>
        </trans-unit>
        <trans-unit id="716ec8e228f41268238a19d64c81add7c59efa1b" translate="yes" xml:space="preserve">
          <source>a regex:</source>
          <target state="translated">a regex。</target>
        </trans-unit>
        <trans-unit id="ff9123773c3af11dc4fc6c1bb3d5deb9aca9a8cf" translate="yes" xml:space="preserve">
          <source>a regexp and backreferences &lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; ,... only</source>
          <target state="translated">一个正则表达式和反向引用 &lt;code&gt;\g1&lt;/code&gt; ， &lt;code&gt;\g2&lt;/code&gt; ，...仅</target>
        </trans-unit>
        <trans-unit id="01acfa70c00b2c40814c6e8e07848ca1e6071adc" translate="yes" xml:space="preserve">
          <source>a regexp. This is a really nice feature; what matches later in a regexp is made to depend on what matched earlier in the regexp. Suppose we wanted to look for doubled words in a text, like 'the the'. The following regexp finds all 3-letter doubles with a space in between:</source>
          <target state="translated">一个regexp。这是一个非常好的功能;在一个regexp中,后面匹配的内容取决于前面匹配的内容。假设我们想寻找文本中的双字词,比如'the the'。下面的regexp可以找到所有中间有空格的3个字母的双字。</target>
        </trans-unit>
        <trans-unit id="479e514b0897fdfb8d6718c16ce953228a292ea2" translate="yes" xml:space="preserve">
          <source>a regexp; not doing so may lead to surprising and unsatisfactory results.</source>
          <target state="translated">一个regexp;不这样做可能会导致令人惊讶和不满意的结果。</target>
        </trans-unit>
        <trans-unit id="8430d6aa05798e9ad31cc9f0f4c419ec21ff77ea" translate="yes" xml:space="preserve">
          <source>a simple word</source>
          <target state="translated">简言之</target>
        </trans-unit>
        <trans-unit id="e941e8088e0ee725d5a1331bbb15c1f7fa4f3cdd" translate="yes" xml:space="preserve">
          <source>a string of Perl statements.</source>
          <target state="translated">一串Perl语句。</target>
        </trans-unit>
        <trans-unit id="76ca2e58b13a0c692067763da1d921195c362fc6" translate="yes" xml:space="preserve">
          <source>a string of octal digits. See also &lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt;, if all you have is a string.</source>
          <target state="translated">一串八进制数字。如果您只有一个字符串，请参见&lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f83ace0c428bcd5408c51dfef2ab5e8998435bd7" translate="yes" xml:space="preserve">
          <source>a string of octal digits. See also &lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;, if all you have is a string.</source>
          <target state="translated">一串八进制数字。如果您只有一个字符串，请参见&lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3166c6d48bdc27e53a55abb43985ea1756a1268" translate="yes" xml:space="preserve">
          <source>a subroutine reference.</source>
          <target state="translated">一个子程序参考。</target>
        </trans-unit>
        <trans-unit id="04f0c4b1fd780f4be3730ec3c5d7dfd8c9451073" translate="yes" xml:space="preserve">
          <source>a thread:</source>
          <target state="translated">一条线。</target>
        </trans-unit>
        <trans-unit id="fe6d7479ae4200c3a6f4997fc5801bb9889aa1b5" translate="yes" xml:space="preserve">
          <source>a whitespace character.)</source>
          <target state="translated">一个空格字符)。)</target>
        </trans-unit>
        <trans-unit id="78ecd65792fd338affd06e9d02fd8d0820236817" translate="yes" xml:space="preserve">
          <source>a) How do I verify that an email address is correctly formatted?</source>
          <target state="translated">a)我如何验证电子邮件地址的格式是否正确?</target>
        </trans-unit>
        <trans-unit id="1ee08278869a8bdd3842c22f817ca34ed228cb42" translate="yes" xml:space="preserve">
          <source>a+bi</source>
          <target state="translated">a+bi</target>
        </trans-unit>
        <trans-unit id="81541b7da471dd2332c53aedfa2bdfe3a4665452" translate="yes" xml:space="preserve">
          <source>a-f (or A-F, case doesn't matter). Each hexadecimal digit represents four bits, or half a byte. &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 0x..., &quot;\n&quot;&lt;/code&gt; will show a hexadecimal number in decimal, and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;%x\n&quot;, $decimal&lt;/code&gt; will show a decimal number in hexadecimal. If you have just the &quot;hex digits&quot; of a hexadecimal number, you can use the &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">AF（或AF，大小写无关紧要）。每个十六进制数字代表四位或半个字节。 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 0x..., &quot;\n&quot;&lt;/code&gt; 将以十进制显示一个十六进制数，而 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;%x\n&quot;, $decimal&lt;/code&gt; 将以十六进制显示一个十进制数。如果只有十六进制数字的&amp;ldquo;十六进制数字&amp;rdquo;，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex()&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="ed5e8e851dceeb90b5c2b37a81b2ad11ae340d95" translate="yes" xml:space="preserve">
          <source>a.out-style build</source>
          <target state="translated">a.外式建造</target>
        </trans-unit>
        <trans-unit id="5780daf6db0b013dbf82807c9f85abba683b0820" translate="yes" xml:space="preserve">
          <source>about</source>
          <target state="translated">about</target>
        </trans-unit>
        <trans-unit id="8f203a021dc29f479a81bd2dd69f4ea2898f02f6" translate="yes" xml:space="preserve">
          <source>about all the dependencies, so you should make sure that anything is up-to-date, say, by doing</source>
          <target state="translated">的所有依赖关系,所以你应该确保任何东西都是最新的,比如说,通过执行</target>
        </trans-unit>
        <trans-unit id="9fbb397449fabe7370de4e726a586750c0e025d4" translate="yes" xml:space="preserve">
          <source>above</source>
          <target state="translated">above</target>
        </trans-unit>
        <trans-unit id="3f8528380c147f9aa2206094f2404301d5bc3dbf" translate="yes" xml:space="preserve">
          <source>above is set up automatically during the build to a correct value on the builder machine, but is overridable at runtime,</source>
          <target state="translated">以上是在构建过程中自动设置为构建机上的正确值,但在运行时是可以覆盖的。</target>
        </trans-unit>
        <trans-unit id="82451b41fd7878180b6aa2b54e369cbec4e8032c" translate="yes" xml:space="preserve">
          <source>abs</source>
          <target state="translated">abs</target>
        </trans-unit>
        <trans-unit id="a239a7dbad7ea85832efb23e90576b2dd038b7a1" translate="yes" xml:space="preserve">
          <source>abs VALUE</source>
          <target state="translated">ABS VALUE</target>
        </trans-unit>
        <trans-unit id="415190d7a2135efc9f152a71915dffbe7a71529a" translate="yes" xml:space="preserve">
          <source>abs, alarm, chomp, chop, chr, chroot, cos, defined, eval, evalbytes, exp, fc, glob, hex, int, lc, lcfirst, length, log, lstat, mkdir, oct, ord, pos, print, printf, quotemeta, readlink, readpipe, ref, require, reverse (in scalar context only), rmdir, say, sin, split (for its second argument), sqrt, stat, study, uc, ucfirst, unlink, unpack.</source>
          <target state="translated">abs,alarm,chomp,chop,chr,chroot,cos,defined,eval,evalbytes,exp,fc,glob,hex,int,lc,lcfirst,length,log,lstat,mkdir,oct,ord,pos,print,printf,quotemeta,readlink,readpipe,ref,require,reverse (仅在标量上下文中),rmdir,say,sin,split (对于它的第二个参数),sqrt,stat,study,uc,ucfirst,unlink,unpack。</target>
        </trans-unit>
        <trans-unit id="5e8fc1f161ebdf02ac9d2d940aca4c69e7ddd903" translate="yes" xml:space="preserve">
          <source>abs_path and friends</source>
          <target state="translated">abs_path和朋友</target>
        </trans-unit>
        <trans-unit id="a4694021c8d1356f5760adc6ce253b54e2f437f0" translate="yes" xml:space="preserve">
          <source>absolute. This decision was made due to portability reasons. Since &lt;code&gt;File::Spec-&amp;gt;catdir()&lt;/code&gt; returns relative paths on all other operating systems, it will now also follow this convention on Mac OS. Note that this may break some existing scripts.</source>
          <target state="translated">绝对。由于可移植性原因而做出此决定。由于 &lt;code&gt;File::Spec-&amp;gt;catdir()&lt;/code&gt; 返回所有其他操作系统上的相对路径，因此它现在也将在Mac OS上遵循此约定。请注意，这可能会破坏某些现有脚本。</target>
        </trans-unit>
        <trans-unit id="eb40247beed3ba10597c7fdb55272d4608c34191" translate="yes" xml:space="preserve">
          <source>absolute. This decision was made due to portability reasons. Since &lt;code&gt;File::Spec-&amp;gt;catfile()&lt;/code&gt; returns relative paths on all other operating systems, it will now also follow this convention on Mac OS. Note that this may break some existing scripts.</source>
          <target state="translated">绝对。由于可移植性原因而做出此决定。由于 &lt;code&gt;File::Spec-&amp;gt;catfile()&lt;/code&gt; 返回所有其他操作系统上的相对路径，因此现在在Mac OS上也将遵循此约定。请注意，这可能会破坏某些现有脚本。</target>
        </trans-unit>
        <trans-unit id="75eebe6521e20b7f9388d31918b564655eac99ce" translate="yes" xml:space="preserve">
          <source>absolutely cannot wait for the fix to be made upstream, released to CPAN and copied to blead, you must add (or update) a &lt;code&gt;CUSTOMIZED&lt;/code&gt; entry in the</source>
          <target state="translated">绝对不能等待修复程序进行上游，释放到CPAN并复制到blead，你必须添加（或更新）一个 &lt;code&gt;CUSTOMIZED&lt;/code&gt; 在入门</target>
        </trans-unit>
        <trans-unit id="7a532dc15a911b9b9181922abf6ced9885b401e9" translate="yes" xml:space="preserve">
          <source>accent-insensitive Unicode sort</source>
          <target state="translated">重音不敏感的Unicode排序</target>
        </trans-unit>
        <trans-unit id="e586a9d31c9053af08de34074e1d2e2b09839079" translate="yes" xml:space="preserve">
          <source>accent-insensitive comparisons</source>
          <target state="translated">重音不敏感的比较</target>
        </trans-unit>
        <trans-unit id="fc8cc4afa9fee369f0ce78c3b97600f87cf033b7" translate="yes" xml:space="preserve">
          <source>accent-insensitive locale comparisons</source>
          <target state="translated">口音不敏感的语言比较</target>
        </trans-unit>
        <trans-unit id="5fb801f2f30ac5b8a6671f1d04a959a51fc1671e" translate="yes" xml:space="preserve">
          <source>accept</source>
          <target state="translated">accept</target>
        </trans-unit>
        <trans-unit id="ae12c11f3760218cae63851a278652cd3eaea3b8" translate="yes" xml:space="preserve">
          <source>accept NEWSOCKET,GENERICSOCKET</source>
          <target state="translated">接受NEWSOCKET,GENERICSOCKET。</target>
        </trans-unit>
        <trans-unit id="5fc8d440432f0b7db9d7569d2e82bb54a31bbead" translate="yes" xml:space="preserve">
          <source>accept_targets_as_html</source>
          <target state="translated">accept_targets_as_html</target>
        </trans-unit>
        <trans-unit id="67dff9ee8056247422bb2cdd74c074036da47a0c" translate="yes" xml:space="preserve">
          <source>accessing</source>
          <target state="translated">accessing</target>
        </trans-unit>
        <trans-unit id="de3a63299e5e19ed22af733ce3c9c55e72ad3106" translate="yes" xml:space="preserve">
          <source>accessor function for the &quot;safe signals&quot; flag of a SigAction object; see &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for general information on safe (a.k.a. &quot;deferred&quot;) signals. If you wish to handle a signal safely, use this accessor to set the &quot;safe&quot; flag in the &lt;code&gt;POSIX::SigAction&lt;/code&gt; object:</source>
          <target state="translated">SigAction对象的&amp;ldquo;安全信号&amp;rdquo;标志的访问器函数；有关安全（也称为&amp;ldquo;延迟&amp;rdquo;）信号的一般信息，请参见&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;。如果希望安全处理信号，请使用此访问器在 &lt;code&gt;POSIX::SigAction&lt;/code&gt; 对象中设置&amp;ldquo;安全&amp;rdquo;标志：</target>
        </trans-unit>
        <trans-unit id="130627c716765ea3404bece5800d80aa45677b23" translate="yes" xml:space="preserve">
          <source>accessor functions to get/set the values of a SigAction object.</source>
          <target state="translated">访问函数来获取/设置SigAction对象的值。</target>
        </trans-unit>
        <trans-unit id="b7f71f41bfbef50f02bf886cf865af8975cb5786" translate="yes" xml:space="preserve">
          <source>accidentally</source>
          <target state="translated">accidentally</target>
        </trans-unit>
        <trans-unit id="3959b939e5424783c493f42cf465f2662e1abbe0" translate="yes" xml:space="preserve">
          <source>acosec</source>
          <target state="translated">acosec</target>
        </trans-unit>
        <trans-unit id="94cd96ac8391252b0d7300cdaef80570e8f1939f" translate="yes" xml:space="preserve">
          <source>acosech</source>
          <target state="translated">acosech</target>
        </trans-unit>
        <trans-unit id="c8be89c327cde8b860df98308b35887bdf811326" translate="yes" xml:space="preserve">
          <source>acot</source>
          <target state="translated">acot</target>
        </trans-unit>
        <trans-unit id="b5aa292058ce240d98a24e0ca78c79be934f0018" translate="yes" xml:space="preserve">
          <source>acotan</source>
          <target state="translated">acotan</target>
        </trans-unit>
        <trans-unit id="299176f2fa0007084d06d47b1d722326f90b487a" translate="yes" xml:space="preserve">
          <source>acotanh</source>
          <target state="translated">acotanh</target>
        </trans-unit>
        <trans-unit id="eef264f7031ee0d55b786c83a83d07ec29a99714" translate="yes" xml:space="preserve">
          <source>acsc</source>
          <target state="translated">acsc</target>
        </trans-unit>
        <trans-unit id="742151db90a3d5f8f47cde2a0573ae956bba7225" translate="yes" xml:space="preserve">
          <source>action&quot; or &quot;manu-</source>
          <target state="translated">行动 &quot;或 &quot;manu-</target>
        </trans-unit>
        <trans-unit id="2bb6b986c5d6fb26dd9dd1054b545ce022371b0c" translate="yes" xml:space="preserve">
          <source>active</source>
          <target state="translated">active</target>
        </trans-unit>
        <trans-unit id="50f46198a1bd51840547aee34fc045921e43d4c6" translate="yes" xml:space="preserve">
          <source>actual</source>
          <target state="translated">actual</target>
        </trans-unit>
        <trans-unit id="5e9b6a0946d93d3600096c34f7b9c6d8f4af95ac" translate="yes" xml:space="preserve">
          <source>actually made it back to</source>
          <target state="translated">归来</target>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="1d1b3b51172716d0cb050801b8fab16ebc7d7185" translate="yes" xml:space="preserve">
          <source>add_bits</source>
          <target state="translated">add_bits</target>
        </trans-unit>
        <trans-unit id="8bab9844d8f1c6dd4567678a3d4228ce8b501259" translate="yes" xml:space="preserve">
          <source>add_bits($data, $nbits)</source>
          <target state="translated">add_bits($data,$nbits)</target>
        </trans-unit>
        <trans-unit id="93ac08fbb73a3cad19b1e009a5e2b9a0a78a5e4b" translate="yes" xml:space="preserve">
          <source>add_bits()</source>
          <target state="translated">add_bits()</target>
        </trans-unit>
        <trans-unit id="64dea38af51fbf2c8ff3ee6ea4af6ed53003ace2" translate="yes" xml:space="preserve">
          <source>add_callback ()</source>
          <target state="translated">add_callback()</target>
        </trans-unit>
        <trans-unit id="94d0e78aca0adb443be5d146e1dac8975ed16903" translate="yes" xml:space="preserve">
          <source>add_style ()</source>
          <target state="translated">add_style()</target>
        </trans-unit>
        <trans-unit id="c3805175370d19c334b59f45b87343b9f2b7f5e1" translate="yes" xml:space="preserve">
          <source>addition</source>
          <target state="translated">addition</target>
        </trans-unit>
        <trans-unit id="c662180230cad14787d4ab7e77aa08681ce783fa" translate="yes" xml:space="preserve">
          <source>address</source>
          <target state="translated">address</target>
        </trans-unit>
        <trans-unit id="91ea4e7b6b94343d715c7982210567115655cb20" translate="yes" xml:space="preserve">
          <source>adds a new name for a control character.</source>
          <target state="translated">为控制字符添加一个新名称。</target>
        </trans-unit>
        <trans-unit id="9c677b000cbca8edd8a283feb5874aa9705fe891" translate="yes" xml:space="preserve">
          <source>adds it automatically when building a program. However, when accessing an executable as a normal file (e.g.,</source>
          <target state="translated">在构建程序时自动添加。但是,当把可执行文件作为一个普通文件访问时(例如。</target>
        </trans-unit>
        <trans-unit id="095c0c5ecd4727ed55c8b2fdc7688091189d0cae" translate="yes" xml:space="preserve">
          <source>adds the line to the history of input, from where it can be used if the actual &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is present.</source>
          <target state="translated">将行添加到输入的历史记录中，如果存在实际的 &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 行，则可以从此处使用该行。</target>
        </trans-unit>
        <trans-unit id="b0b7161ec6ad88575ef86bb08f43a11d9469dba1" translate="yes" xml:space="preserve">
          <source>adecimal.</source>
          <target state="translated">adecimal.</target>
        </trans-unit>
        <trans-unit id="b144ec6dfdab55ae2963bf4c782c7e4157019ffd" translate="yes" xml:space="preserve">
          <source>adminaddress</source>
          <target state="translated">adminaddress</target>
        </trans-unit>
        <trans-unit id="916a530bfc75fe948657d7b5108d40fc2508c596" translate="yes" xml:space="preserve">
          <source>advised to follow this introduction with more information from the full Perl manual, the table of contents to which can be found in &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt;.</source>
          <target state="translated">建议遵循此介绍从全手动的Perl的更多信息，内容的表，它可以在发现&lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aab93e8e3796f91139b951be5ef4c63e4b3fdff0" translate="yes" xml:space="preserve">
          <source>affect normal access to a variable. (Locks on subs are different, and covered in a bit.) If you really,</source>
          <target state="translated">影响对变量的正常访问。(子上的锁就不一样了,一会儿再讲。)如果你真的。</target>
        </trans-unit>
        <trans-unit id="d16b511453d6e723e850460d0b087be14fb56fb1" translate="yes" xml:space="preserve">
          <source>afs.U</source>
          <target state="translated">afs.U</target>
        </trans-unit>
        <trans-unit id="405906c9d5be6ae5393ca65fb0e7c38e0d585ecb" translate="yes" xml:space="preserve">
          <source>after</source>
          <target state="translated">after</target>
        </trans-unit>
        <trans-unit id="1a8a978377842aa511fbb5bb66f929228650a830" translate="yes" xml:space="preserve">
          <source>after a &lt;b&gt;failure&lt;/b&gt;:</source>
          <target state="translated">经过一个&lt;b&gt;失败的&lt;/b&gt;：</target>
        </trans-unit>
        <trans-unit id="2391217343165dbdcc1e85432eaed6f2d40232f2" translate="yes" xml:space="preserve">
          <source>after the first line of wrap(). This is not a most effective implementation, one may consider</source>
          <target state="translated">在wrap()的第一行之后。这并不是最有效的实现方式,我们可以考虑在第一行wrap()之后使用</target>
        </trans-unit>
        <trans-unit id="d501db092c38ad8292690be746bddff30bdd42c1" translate="yes" xml:space="preserve">
          <source>after which you may use either</source>
          <target state="translated">之后,您可以使用</target>
        </trans-unit>
        <trans-unit id="d237158794ce68f8acfcb27dbb3524b7d367bc44" translate="yes" xml:space="preserve">
          <source>after you made your modifications.</source>
          <target state="translated">在您进行修改后。</target>
        </trans-unit>
        <trans-unit id="0de616ced95f0b022d2889588dcde62712d64ff3" translate="yes" xml:space="preserve">
          <source>again, and run</source>
          <target state="translated">再跑</target>
        </trans-unit>
        <trans-unit id="80ece22ca1db999b834ed949964a66789d2cf76d" translate="yes" xml:space="preserve">
          <source>against the previous and current perls to see what difference it has made, and whether anything else has slowed down as a consequence.</source>
          <target state="translated">对照之前和当前的perls,看看它有什么不同,以及是否有其他东西因此而变慢。</target>
        </trans-unit>
        <trans-unit id="f1525d2f1de4ff409ccb719b4f0bd276a7bb7c21" translate="yes" xml:space="preserve">
          <source>agree on the type of reference and also on the organization of data within the object body. Failure to agree on the type results in immediate death when the wrong method tries to access an object. Failure to agree on data organization may lead to one class trampling over the data of another.</source>
          <target state="translated">就引用的类型以及对象主体内的数据组织达成一致。如果不能就类型达成一致,当错误的方法试图访问一个对象时,就会立即死亡。未能就数据组织达成一致,可能导致一个类践踏另一个类的数据。</target>
        </trans-unit>
        <trans-unit id="73468898c9988e2f9e409b93e8bff16eaa79c0ba" translate="yes" xml:space="preserve">
          <source>alarm</source>
          <target state="translated">alarm</target>
        </trans-unit>
        <trans-unit id="05d57bf3c2063c1b5c9e035ba1e89e203c424841" translate="yes" xml:space="preserve">
          <source>alarm SECONDS</source>
          <target state="translated">警报秒数</target>
        </trans-unit>
        <trans-unit id="605bec3b3bc4303313aa3e75ef5affbb28a79c75" translate="yes" xml:space="preserve">
          <source>albeit with substitutions such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/LATIN//&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/VULGAR//&lt;/a&gt;&lt;/code&gt; in all cases; &lt;code&gt;s/CAPITAL LETTER//&lt;/code&gt; in some cases; and &lt;code&gt;s/SMALL LETTER ([A-Z])/\l$1/&lt;/code&gt; in some other cases. Controls are listed using their Unicode 6.2 abbreviations. The differences between the 0037 and 1047 sets are flagged with &lt;code&gt;**&lt;/code&gt; . The differences between the 1047 and POSIX-BC sets are flagged with &lt;code&gt;##.&lt;/code&gt; All &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; numbers listed are decimal. If you would rather see this table listing octal values, then run the table (that is, the pod source text of this document, since this recipe may not work with a pod2_other_format translation) through:</source>
          <target state="translated">尽管在所有情况下都替换为 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/LATIN//&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/VULGAR//&lt;/a&gt;&lt;/code&gt; ； &lt;code&gt;s/CAPITAL LETTER//&lt;/code&gt; 在某些情况下；和 &lt;code&gt;s/SMALL LETTER ([A-Z])/\l$1/&lt;/code&gt; 在其他情况下）。控件使用其Unicode 6.2缩写列出。 0037和1047集之间的差异用 &lt;code&gt;**&lt;/code&gt; 标记。 1047和POSIX-BC集之间的差异用 &lt;code&gt;##.&lt;/code&gt; 标记。列出的所有 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; 数字均为十进制。如果您希望该表列出八进制值，请通过以下方式运行该表（即此文档的pod源文本，因为此配方可能不适用于pod2_other_format转换）：</target>
        </trans-unit>
        <trans-unit id="3b21e0f54dca09308ec896c51cda4f9ca4dd91a4" translate="yes" xml:space="preserve">
          <source>aliases</source>
          <target state="translated">aliases</target>
        </trans-unit>
        <trans-unit id="3d30739d4c2f9e4b4a11180a7c3327f3e52fd8d3" translate="yes" xml:space="preserve">
          <source>alignbytes.U</source>
          <target state="translated">alignbytes.U</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="509fd71434fbe53c02bb286882f845078ef5ee17" translate="yes" xml:space="preserve">
          <source>all compressed data to the output data stream.</source>
          <target state="translated">所有压缩数据到输出数据流。</target>
        </trans-unit>
        <trans-unit id="8130249f3817c584cba8ad27e67056edd1c31fac" translate="yes" xml:space="preserve">
          <source>all its ancestor classes. (This is because the idea of &quot;class data&quot; isn't directly implemented in Perl, but is instead left to individual class-systems to implement as they see fit..)</source>
          <target state="translated">的所有祖先类。(这是因为 &quot;类数据 &quot;这个概念在Perl中并没有直接实现,而是留给了各个类系统去实现他们认为合适的东西...)</target>
        </trans-unit>
        <trans-unit id="8cc5040f7ad90d3df578f4dce7d48b395ac1b9d9" translate="yes" xml:space="preserve">
          <source>all of the help</source>
          <target state="translated">万般无奈</target>
        </trans-unit>
        <trans-unit id="7d7ebf534a4b32567ce1f6b72446d3e09f27b240" translate="yes" xml:space="preserve">
          <source>all other versions of the module you're installing</source>
          <target state="translated">您正在安装的模块的所有其他版本的版本</target>
        </trans-unit>
        <trans-unit id="de05e27afdc59b4d9bbeeae86d35f670cdbf6280" translate="yes" xml:space="preserve">
          <source>all remaining lines from is this way:</source>
          <target state="translated">所有剩余的行从是这样的。</target>
        </trans-unit>
        <trans-unit id="f966b162e6dd45e46a9c1021ad48d8c4e414675d" translate="yes" xml:space="preserve">
          <source>all the subroutines are called in a list context.</source>
          <target state="translated">所有的子程序都是在列表上下文中调用的。</target>
        </trans-unit>
        <trans-unit id="78d2c8306e2172f468ed7da94e5e7fdd772dd33e" translate="yes" xml:space="preserve">
          <source>all uncompressed data to the output data stream.</source>
          <target state="translated">所有未压缩的数据到输出数据流。</target>
        </trans-unit>
        <trans-unit id="e6543caf79edcee1b041e9193f69e17c853ef1f4" translate="yes" xml:space="preserve">
          <source>all with optional leading and trailing zeros and/or spaces. Additionally, numbers are allowed to have an underscore between any two digits.</source>
          <target state="translated">所有的数字都有可选的前导和尾部的0和/或空格。此外,数字可以在任何两个数字之间有下划线。</target>
        </trans-unit>
        <trans-unit id="acff2f4d1898df7e94ecaebad18831a97e4519ff" translate="yes" xml:space="preserve">
          <source>all_target</source>
          <target state="translated">all_target</target>
        </trans-unit>
        <trans-unit id="12b42e096b7bca3af7ec1c5ba1a6445e520a72d8" translate="yes" xml:space="preserve">
          <source>allkeys.txt</source>
          <target state="translated">allkeys.txt</target>
        </trans-unit>
        <trans-unit id="78c9d45e7d52c660866b311227728fee1dfd5e6c" translate="yes" xml:space="preserve">
          <source>allocates some memory and constructs a Perl interpreter, along these lines:</source>
          <target state="translated">分配一些内存并构造一个Perl解释器,大致如下。</target>
        </trans-unit>
        <trans-unit id="4ac387a6f0f3e93209827552db5ced03710025ff" translate="yes" xml:space="preserve">
          <source>allow suppressing all such STDERR output, and instead allow an option for reporting errors/warnings in some other way, whether by triggering a callback, or noting errors in some attribute of the document object, or some similarly unobtrusive mechanism -- or even by appending a &quot;Pod Errors&quot; section to the end of the parsed form of the document.</source>
          <target state="translated">允许抑制所有这样的STDERR输出,而允许选择以其他方式报告错误/警告,无论是通过触发一个回调,还是在文档对象的某些属性中指出错误,或一些类似的不显眼的机制,甚至是在文档的解析形式的末尾附加一个 &quot;Pod错误 &quot;部分。</target>
        </trans-unit>
        <trans-unit id="eb4eaf28d97cf6eeb14d04f7a34316c390474dbc" translate="yes" xml:space="preserve">
          <source>allow( $test_me, \@criteria );</source>
          <target state="translated">allow($test_me,\@criteria )。</target>
        </trans-unit>
        <trans-unit id="023f8167a0ccb01c809eb2dc9a66997533fa1ae8" translate="yes" xml:space="preserve">
          <source>allowed if $pat is a precompiled regular expression, even if $pat contains &lt;code&gt;(?{ ... })&lt;/code&gt; assertions or &lt;code&gt;(??{ ... })&lt;/code&gt; subexpressions.</source>
          <target state="translated">即使$ pat是预编译的正则表达式也允许，即使$ pat包含 &lt;code&gt;(?{ ... })&lt;/code&gt; 断言或 &lt;code&gt;(??{ ... })&lt;/code&gt; 子表达式。</target>
        </trans-unit>
        <trans-unit id="4301b689bb097155e3bb6d16044296e9269b5529" translate="yes" xml:space="preserve">
          <source>allows Perl to do unsafe operations. Currently the only &quot;unsafe&quot; operations are attempting to unlink directories while running as superuser and running setuid programs with fatal taint checks turned into warnings. Note that warnings must be enabled along with this option to actually</source>
          <target state="translated">允许 Perl 进行不安全的操作。目前唯一的 &quot;不安全 &quot;操作是在以超级用户身份运行时试图解开目录的链接,以及在运行 setuid 程序时将致命的污点检查变成警告。请注意,警告必须和这个选项一起启用,才能真正实现</target>
        </trans-unit>
        <trans-unit id="132c35f7c02912ac7c614dd2a393fc9375c90687" translate="yes" xml:space="preserve">
          <source>allows the &lt;code&gt;:default&lt;/code&gt; list from a particular version to be used. This provides the convenience of using the default methods, but the surety that no behavioral changes will occur if the &lt;code&gt;autodie&lt;/code&gt; module is upgraded.</source>
          <target state="translated">允许使用特定版本的 &lt;code&gt;:default&lt;/code&gt; 列表。这提供了使用默认方法的便利，但是可以确保如果升级了 &lt;code&gt;autodie&lt;/code&gt; 模块，则不会发生任何行为更改。</target>
        </trans-unit>
        <trans-unit id="423d437bbbc6bb7d398c30b28e10d75c03e10783" translate="yes" xml:space="preserve">
          <source>allows you to refer to special variables (like &lt;code&gt;$/&lt;/code&gt; ) with names (like $RS), as though they were in &lt;b&gt;awk&lt;/b&gt;; see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for details.</source>
          <target state="translated">允许您使用名称（例如$ RS）来引用特殊变量（例如 &lt;code&gt;$/&lt;/code&gt; ），就像它们在&lt;b&gt;awk中一样&lt;/b&gt;；有关详细信息，请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9e2ef61def87209ec2dd5c8efef68de53d4aef6" translate="yes" xml:space="preserve">
          <source>almost</source>
          <target state="translated">almost</target>
        </trans-unit>
        <trans-unit id="f5f5592352120c7c5dd3e80cd891b2a35cc0756a" translate="yes" xml:space="preserve">
          <source>along with #including</source>
          <target state="translated">随着#包括</target>
        </trans-unit>
        <trans-unit id="f84474a16e6ac5b152e8cf62a4c115b6109f018b" translate="yes" xml:space="preserve">
          <source>alphabetic</source>
          <target state="translated">alphabetic</target>
        </trans-unit>
        <trans-unit id="b859ef3e26b0a8f0f8e5984aa4d45230ec4e08bc" translate="yes" xml:space="preserve">
          <source>already exist</source>
          <target state="translated">已有</target>
        </trans-unit>
        <trans-unit id="34879e54886ec3a6f952c7af1d444870828e03e7" translate="yes" xml:space="preserve">
          <source>already-existing</source>
          <target state="translated">already-existing</target>
        </trans-unit>
        <trans-unit id="09706c418809f1f4cfda992435ca1438eddaaeed" translate="yes" xml:space="preserve">
          <source>also</source>
          <target state="translated">also</target>
        </trans-unit>
        <trans-unit id="53ed2e1b9d4ccdc537294ab308f9c5d1e151cf60" translate="yes" xml:space="preserve">
          <source>also creates the prototyping header files for the internal functions, generates the documentation and a lot of other bits and pieces. It's important that when you add a new function to the core or change an existing one, you change the data in the table in</source>
          <target state="translated">还为内部函数创建原型头文件,生成文档和许多其他零碎的东西。重要的是,当你在核心中添加一个新的函数或改变一个现有的函数时,你要改变表中的数据。</target>
        </trans-unit>
        <trans-unit id="4298c06d3073002d95a1081fb801b4a99c5de328" translate="yes" xml:space="preserve">
          <source>also exists). Cygwin does not require a</source>
          <target state="translated">也存在)。)Cygwin不需要一个</target>
        </trans-unit>
        <trans-unit id="2ce647c4199231c5e08b22c4a1f2a2b4b84f2e7b" translate="yes" xml:space="preserve">
          <source>also includes the platform's native underscore character, no matter what the locale is.</source>
          <target state="translated">还包括平台的原生下划线字符,不管是什么地方。</target>
        </trans-unit>
        <trans-unit id="17b130cdba41303da201c9df43f19e9e6a5a45ad" translate="yes" xml:space="preserve">
          <source>also provides a number of &lt;code&gt;PerlIOBase_xxxx()&lt;/code&gt; functions which are intended to be used in the table slots of classes which do not need to do anything special for a particular method.</source>
          <target state="translated">它还提供了许多 &lt;code&gt;PerlIOBase_xxxx()&lt;/code&gt; 函数，这些函数旨在用于类的表槽中，这些类不需要为特定方法做任何特殊的事情。</target>
        </trans-unit>
        <trans-unit id="edb013a0b027689799b6d3bb946b0380fa2999b8" translate="yes" xml:space="preserve">
          <source>alter the interpretation of nested formatting codes, meaning that the following four example lines are identical in meaning:</source>
          <target state="translated">改变了嵌套格式码的解释,也就是说下面四行例句的含义是相同的。</target>
        </trans-unit>
        <trans-unit id="370d1bb1966aad5766de7d85dcf3b3cc7341ab95" translate="yes" xml:space="preserve">
          <source>alternation</source>
          <target state="translated">alternation</target>
        </trans-unit>
        <trans-unit id="c78b3591272b10760192271aec607cc2988dcb68" translate="yes" xml:space="preserve">
          <source>although without duplicating any side effects that dereferencing the lvalue might trigger, such as from &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie()&lt;/a&gt;&lt;/code&gt;. Other assignment operators work similarly. The following are recognized:</source>
          <target state="translated">尽管不重复任何可能会导致取消引用左值的副作用，例如来自 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie()&lt;/a&gt;&lt;/code&gt; 。其他分配运算符的工作方式与此类似。可以识别以下内容：</target>
        </trans-unit>
        <trans-unit id="6656018ac96d0295d887ff2893ba9af66ae16af2" translate="yes" xml:space="preserve">
          <source>always</source>
          <target state="translated">always</target>
        </trans-unit>
        <trans-unit id="fb980e8b0c064246b90fe9981d818b33511ba028" translate="yes" xml:space="preserve">
          <source>always be called &lt;code&gt;my_cxt_t&lt;/code&gt; . The other &lt;code&gt;CXT*&lt;/code&gt; macros assume the existence of the &lt;code&gt;my_cxt_t&lt;/code&gt; typedef name.</source>
          <target state="translated">始终称为 &lt;code&gt;my_cxt_t&lt;/code&gt; 。其他 &lt;code&gt;CXT*&lt;/code&gt; 宏假定存在 &lt;code&gt;my_cxt_t&lt;/code&gt; typedef名称。</target>
        </trans-unit>
        <trans-unit id="9e7cc664880363e8a6f8dd216803f53660c055a7" translate="yes" xml:space="preserve">
          <source>ambient_pragmas</source>
          <target state="translated">ambient_pragmas</target>
        </trans-unit>
        <trans-unit id="75a14d5aecfa0926099831db837cd6a62fe95561" translate="yes" xml:space="preserve">
          <source>amed character.</source>
          <target state="translated">酰胺的特点。</target>
        </trans-unit>
        <trans-unit id="de73eac0c305038f0437bc6a1f994a5a4379ed28" translate="yes" xml:space="preserve">
          <source>an</source>
          <target state="translated">an</target>
        </trans-unit>
        <trans-unit id="8f91a7d4c013d689792014cce41cfca93df8643f" translate="yes" xml:space="preserve">
          <source>an arrayref of CPAN::Distroprefs::Pref objects</source>
          <target state="translated">CPAN::Distroprefs::Pref对象的数组ref。</target>
        </trans-unit>
        <trans-unit id="1fd4e0318cb46a3d9d16dba83e533928a4e2874e" translate="yes" xml:space="preserve">
          <source>an embedded newline, so it doesn't remove it. This pattern still removes the newline at the end of the string:</source>
          <target state="translated">嵌入的换行,所以它不会删除它。这种模式仍然会删除字符串末尾的换行符。</target>
        </trans-unit>
        <trans-unit id="419fb031bbb1d3bd852934c637cbdadfffbdbcd6" translate="yes" xml:space="preserve">
          <source>an entire array or an entire hash (or to just about anything else). Names are one kind of reference that you're already familiar with. Think of the President of the United States: a messy, inconvenient bag of blood and bones. But to talk about him, or to represent him in a computer program, all you need is the easy, convenient scalar string &quot;Barack Obama&quot;.</source>
          <target state="translated">整个数组或整个哈希(或任何其他东西)。名字是你已经熟悉的一种参考。想想美国总统:一个混乱的、不方便的血和骨头的袋子。但要谈论他,或者在计算机程序中表示他,你只需要一个简单方便的标量字符串 &quot;Barack Obama&quot;。</target>
        </trans-unit>
        <trans-unit id="2130df2147e633640bd9a0d05e6d376dee6ccd2f" translate="yes" xml:space="preserve">
          <source>an error has occurred, the return value will always be 0.</source>
          <target state="translated">发生了错误,返回值将始终为0。</target>
        </trans-unit>
        <trans-unit id="753f0741a207012aea84c4e049df342c160b9190" translate="yes" xml:space="preserve">
          <source>an error has occurred, the return value will be 1 and the value on the top of the stack will be</source>
          <target state="translated">发生错误,返回值为1,栈顶的值为</target>
        </trans-unit>
        <trans-unit id="409ef8643f1d521a89ca1a0c3155c4a711f5a647" translate="yes" xml:space="preserve">
          <source>an error to register the same object multiple times with varying sets of hashrefs. Any hashrefs that are not registered yet will be added, others ignored.</source>
          <target state="translated">一个错误,多次注册同一个对象,并使用不同的散列字集。任何尚未注册的哈希夫将被添加,其他的将被忽略。</target>
        </trans-unit>
        <trans-unit id="f7cb42641753796859e397b207b75ba5bcc045ca" translate="yes" xml:space="preserve">
          <source>an integer within [-9, +9]), this is called</source>
          <target state="translated">在[-9,+9]范围内的一个整数),这就叫做</target>
        </trans-unit>
        <trans-unit id="f06df609aed50661247cc6ec96c1599c193c3ec4" translate="yes" xml:space="preserve">
          <source>anchor</source>
          <target state="translated">anchor</target>
        </trans-unit>
        <trans-unit id="04f99c29e783f9cb4ae84f58faccd00a818b9492" translate="yes" xml:space="preserve">
          <source>anchor_items</source>
          <target state="translated">anchor_items</target>
        </trans-unit>
        <trans-unit id="68694b44e6f48917189ec5e4ceb1c0fef7ef80b9" translate="yes" xml:space="preserve">
          <source>anchored fixed string</source>
          <target state="translated">定弦</target>
        </trans-unit>
        <trans-unit id="43c00fd1688ea15081e7af4c5f2652c8c8653500" translate="yes" xml:space="preserve">
          <source>anchorify</source>
          <target state="translated">anchorify</target>
        </trans-unit>
        <trans-unit id="f3ef6e09da1f05d18d52776cc5fea65e3b316091" translate="yes" xml:space="preserve">
          <source>anchorname</source>
          <target state="translated">anchorname</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="41f7d9aafc306017d119acf70705c827d97696a7" translate="yes" xml:space="preserve">
          <source>and &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.)</source>
          <target state="translated">和&lt;a href=&quot;encode&quot;&gt;编码&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="1e7b3b70ce0b7269aa85ddea66ae89e1b660b6b7" translate="yes" xml:space="preserve">
          <source>and &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;, or &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt;, &quot;How do I flush/unbuffer an output filehandle? Why must I do this?&quot;):</source>
          <target state="translated">并&lt;a href=&quot;functions/select&quot;&gt;选择&lt;/a&gt;或&lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; &amp;ldquo;如何刷新/ 取消缓冲输出文件句柄？为什么必须这样做？&amp;rdquo;）：</target>
        </trans-unit>
        <trans-unit id="016f4b3a6b408b7434c9c8addd29fcfb251b75bc" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;$default&lt;/code&gt; is 0.</source>
          <target state="translated">和 &lt;code&gt;$default&lt;/code&gt; 为0。</target>
        </trans-unit>
        <trans-unit id="79e3a95c66eb0995a5b17cf160488513cd9c4836" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;$status&lt;/code&gt; will contain the</source>
          <target state="translated">并且 &lt;code&gt;$status&lt;/code&gt; 将包含</target>
        </trans-unit>
        <trans-unit id="fb55aba7e200d190a26516edaeb1e8c8f871d671" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;$status&lt;/code&gt; will hold the</source>
          <target state="translated">并且 &lt;code&gt;$status&lt;/code&gt; 将保存</target>
        </trans-unit>
        <trans-unit id="f7a05a7c74e5456a922f33cfd811202c94bfd7a6" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;$status&lt;/code&gt; will hold the a</source>
          <target state="translated">并且 &lt;code&gt;$status&lt;/code&gt; 将保留一个</target>
        </trans-unit>
        <trans-unit id="faf11d208a41db985f49c9f628222cbd33a1d444" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;$status&lt;/code&gt; will hold the exact</source>
          <target state="translated">并且 &lt;code&gt;$status&lt;/code&gt; 将保留确切的位置</target>
        </trans-unit>
        <trans-unit id="311c8c621fca6c1133276b3546a71e41872cd5b3" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; myint;&lt;/code&gt; is</source>
          <target state="translated">也 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; myint;&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="fe56ad1fd6916544bd67d364c47ef22b8722997c" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;Archive::Tar&lt;/code&gt; will call &lt;code&gt;Cwd::cwd()&lt;/code&gt; internally again.</source>
          <target state="translated">和 &lt;code&gt;Archive::Tar&lt;/code&gt; 将再次在内部调用 &lt;code&gt;Cwd::cwd()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aeba6e0c46a5c93c432546b879e4bda2afa3e55c" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;Perl_dump_all&lt;/code&gt; , which dumps all the subroutines in the stash and the op tree of the main root.</source>
          <target state="translated">和 &lt;code&gt;Perl_dump_all&lt;/code&gt; ，将所有子例程转储到主根目录的存储区和操作树中。</target>
        </trans-unit>
        <trans-unit id="24b1d9fb54b19f2a4bf7a0a575b93e2448d41ac7" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;asynch_read_if&lt;/code&gt; could look like this</source>
          <target state="translated">和 &lt;code&gt;asynch_read_if&lt;/code&gt; 可能看起来像这样</target>
        </trans-unit>
        <trans-unit id="52260a6c12657e7cd53ed4aeda42476a80ffde69" translate="yes" xml:space="preserve">
          <source>and C</source>
          <target state="translated">和C</target>
        </trans-unit>
        <trans-unit id="ce624d2a956a4c4fdd87bb0d4c8b8565acc10eb6" translate="yes" xml:space="preserve">
          <source>and CRT DLL. I know no advantages of this executable over &lt;code&gt;perl.exe&lt;/code&gt; , but it cannot fork() at all. Well, one advantage is that the build process is not so convoluted as with &lt;code&gt;perl.exe&lt;/code&gt; .</source>
          <target state="translated">和CRT DLL。我不知道该可执行文件比 &lt;code&gt;perl.exe&lt;/code&gt; 有什么优势，但是它根本不能fork（）。好吧，一个优点是构建过程不会像 &lt;code&gt;perl.exe&lt;/code&gt; 那样令人费解。</target>
        </trans-unit>
        <trans-unit id="d2f78e98c292b6edbfc33a84d6b47bc8f258f6d2" translate="yes" xml:space="preserve">
          <source>and Configure will give up.</source>
          <target state="translated">和配置会放弃。</target>
        </trans-unit>
        <trans-unit id="e6601ba493fd802e8c69e73fa3178575540d2f6c" translate="yes" xml:space="preserve">
          <source>and Mark Adler</source>
          <target state="translated">和Mark Adler</target>
        </trans-unit>
        <trans-unit id="86d575fb0f5c883349b5a7f286abb3edbe3207c7" translate="yes" xml:space="preserve">
          <source>and Perl knows that it has to invoke the PerlIOAPR_open() method implemented by the APR layer.</source>
          <target state="translated">和Perl知道它必须调用APR层实现的PerlIOAPR_open()方法。</target>
        </trans-unit>
        <trans-unit id="e32c9b9186aa8e9288a2accdf939a5bb0683c0cb" translate="yes" xml:space="preserve">
          <source>and UNIX, &lt;code&gt;$gzerrno&lt;/code&gt; should only be used to check for the presence of</source>
          <target state="translated">和UNIX， &lt;code&gt;$gzerrno&lt;/code&gt; 仅应用于检查是否存在</target>
        </trans-unit>
        <trans-unit id="dce6c6da0aef880545eedbf05f807b0628611184" translate="yes" xml:space="preserve">
          <source>and UTF-16 is the name of the encoding that embraces them.</source>
          <target state="translated">和UTF-16是拥抱它们的编码名称。</target>
        </trans-unit>
        <trans-unit id="c3a319360d3cdf3729627355f1ee1dd75a51847e" translate="yes" xml:space="preserve">
          <source>and ad hoc &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $test ? &quot;ok 42\n&quot; : &quot;not ok 42\n&quot;&lt;/code&gt; . The decision of which to use depends on what part of the test suite you're working on. This is a measure to prevent a high-level failure (such as Config.pm breaking) from causing basic functionality tests to fail.</source>
          <target state="translated">并临时 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $test ? &quot;ok 42\n&quot; : &quot;not ok 42\n&quot;&lt;/code&gt; 。使用哪个决定取决于您正在使用的测试套件的哪一部分。这是一种防止高级故障（例如Config.pm中断）导致基本功能测试失败的措施。</target>
        </trans-unit>
        <trans-unit id="1759eff6deec8639c809421ad0c28a76e0ef5cae" translate="yes" xml:space="preserve">
          <source>and also $Config::Config{'scriptdir'}</source>
          <target state="translated">还有$Config::Config{'scriptdir'}。</target>
        </trans-unit>
        <trans-unit id="092a598de52599e5ea26b086e728adfcb8a8f87b" translate="yes" xml:space="preserve">
          <source>and also how strings are parsed by &lt;code&gt;POSIX::strtod()&lt;/code&gt; as numbers:</source>
          <target state="translated">以及 &lt;code&gt;POSIX::strtod()&lt;/code&gt; 如何将字符串解析为数字：</target>
        </trans-unit>
        <trans-unit id="53d3cfa28bbb90ed936aa07f73ce71dbef9ab3f7" translate="yes" xml:space="preserve">
          <source>and are now removed.</source>
          <target state="translated">并已被删除。</target>
        </trans-unit>
        <trans-unit id="d7e49eb1b589da099384cdd5bcb2b002b2679a4a" translate="yes" xml:space="preserve">
          <source>and as</source>
          <target state="translated">又如</target>
        </trans-unit>
        <trans-unit id="f930cc83716047f99549b196c0f6ea5f5c50196e" translate="yes" xml:space="preserve">
          <source>and auxiliary ones</source>
          <target state="translated">和辅助性的</target>
        </trans-unit>
        <trans-unit id="0e8dd9b894bf299a78c91001723d0325159a6a91" translate="yes" xml:space="preserve">
          <source>and basic block profiling with gcc, see the latest GNU CC manual. As of gcc 4.8, this is at &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov-Intro.html#Gcov-Intro&quot;&gt;http://gcc.gnu.org/onlinedocs/gcc/Gcov-Intro.html#Gcov-Intro&lt;/a&gt;</source>
          <target state="translated">和使用gcc进行基本块分析，请参见最新的GNU CC手册。从gcc 4.8开始，此地址位于&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov-Intro.html#Gcov-Intro&quot;&gt;http://gcc.gnu.org/onlinedocs/gcc/Gcov-Intro.html#Gcov-Intro&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67ac2d9e2193d40fc9c92b85950de3190240ebb3" translate="yes" xml:space="preserve">
          <source>and be sure to also set the environment variable _C89_CCMODE=1 (exporting _C89_CCMODE=1 is also a good idea for users of GNU make).</source>
          <target state="translated">并确保设置环境变量 _C89_CCMODE=1 (导出 _C89_CCMODE=1 也是 GNU make 用户的一个好主意)。</target>
        </trans-unit>
        <trans-unit id="cce2b5ee15547d8411b108ac01a1af3d3a13be3a" translate="yes" xml:space="preserve">
          <source>and belong to the user running the program:</source>
          <target state="translated">并属于运行程序的用户。</target>
        </trans-unit>
        <trans-unit id="68c1df893d3dfe1344316c80822ce4982fc34977" translate="yes" xml:space="preserve">
          <source>and by default output is displayed inline.</source>
          <target state="translated">并且默认情况下,输出是内联显示。</target>
        </trans-unit>
        <trans-unit id="9d972577906aa2c316e9c360f92a8897dc203b61" translate="yes" xml:space="preserve">
          <source>and by definition, the solution is noted</source>
          <target state="translated">而根据定义,解决方案被指出</target>
        </trans-unit>
        <trans-unit id="31788a27790e7797ed6a059ba1faefdb6a39e6a9" translate="yes" xml:space="preserve">
          <source>and call</source>
          <target state="translated">并称</target>
        </trans-unit>
        <trans-unit id="2b74bf70fe4b516f104f35b9ee09019d1d9b9441" translate="yes" xml:space="preserve">
          <source>and call it with &lt;code&gt;perl dangerous.pl 'rm -rfv *|'&lt;/code&gt; , it actually opens a pipe, executes the &lt;code&gt;rm&lt;/code&gt; command and reads &lt;code&gt;rm&lt;/code&gt; 's output from that pipe. If you want all items in &lt;code&gt;@ARGV&lt;/code&gt; to be interpreted as file names, you can use the module &lt;code&gt;ARGV::readonly&lt;/code&gt; from CPAN, or use the double bracket:</source>
          <target state="translated">并用 &lt;code&gt;perl dangerous.pl 'rm -rfv *|'&lt;/code&gt; 称呼它 ，它实际上打开了一个管道，执行 &lt;code&gt;rm&lt;/code&gt; 命令并从该管道读取 &lt;code&gt;rm&lt;/code&gt; 的输出。如果要将 &lt;code&gt;@ARGV&lt;/code&gt; 中的所有项目都解释为文件名，则可以使用CPAN中的模块 &lt;code&gt;ARGV::readonly&lt;/code&gt; 或使用双括号：</target>
        </trans-unit>
        <trans-unit id="cdadfa4e29a3387e757303b12e15c9ac8ce26389" translate="yes" xml:space="preserve">
          <source>and calling &lt;code&gt;Perl_mro_register&lt;/code&gt; :</source>
          <target state="translated">并调用 &lt;code&gt;Perl_mro_register&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2dd76bc4189d4946771f4e716aa51df3f1240631" translate="yes" xml:space="preserve">
          <source>and choose your favorite parameters. After a few downloads running the &lt;code&gt;hosts&lt;/code&gt; command will probably assist you in choosing the best mirror sites.</source>
          <target state="translated">然后选择您喜欢的参数。下载几次后，运行 &lt;code&gt;hosts&lt;/code&gt; 命令可能会帮助您选择最佳的镜像站点。</target>
        </trans-unit>
        <trans-unit id="a8c3f91d52eab0005bf1821357c56257522b3d7e" translate="yes" xml:space="preserve">
          <source>and concatenate it to</source>
          <target state="translated">并将其连接成</target>
        </trans-unit>
        <trans-unit id="2ff89dcb837ced149fb6b5224ee21778d994fc8a" translate="yes" xml:space="preserve">
          <source>and continuing to the first nul. These octets are interpreted as either UTF-8 or Latin-1, according to whether the &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; flag is set in</source>
          <target state="translated">并继续到第一个nul。根据是否在 &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; 位置设置了LEX_STUFF_UTF8标志，这些八位位组被解释为UTF-8或Latin-1 。</target>
        </trans-unit>
        <trans-unit id="3b4b74100dbb60dc7d23a3f17b465ea647875121" translate="yes" xml:space="preserve">
          <source>and correct anything wrong you find there. I do not expect it is needed anywhere.</source>
          <target state="translated">并纠正你发现的任何错误。我不期望在任何地方都需要它。</target>
        </trans-unit>
        <trans-unit id="c0554b9855c1b4a6c0834e79b079617190a40bcb" translate="yes" xml:space="preserve">
          <source>and dies. Therefore the SunOS 4.1 hints file explicitly sets the ld to be</source>
          <target state="translated">而死亡。因此,SunOS 4.1 的提示文件明确地将 ld 设置为</target>
        </trans-unit>
        <trans-unit id="c349b5535bebf3c0ad16ae9e94907ffd5cecb983" translate="yes" xml:space="preserve">
          <source>and divines whether they passed or failed based on their output to STDOUT (details above). It prints out each individual test which failed along with a summary report and a how long it all took.</source>
          <target state="translated">并根据它们输出到STDOUT的结果来判断它们是通过了还是失败了(详情见上文)。它打印出每一个失败的测试,以及一个总结报告和花了多长时间。</target>
        </trans-unit>
        <trans-unit id="a5fd741bd9f2a58aedde00aa2b92b647f2b4c3d7" translate="yes" xml:space="preserve">
          <source>and doing a bunch of messy heuristics on the resulting</source>
          <target state="translated">并对产生的结果做了一堆乱七八糟的启发式分析</target>
        </trans-unit>
        <trans-unit id="79a24dfc42595a13dbd8f77aa55520c5f2654ac8" translate="yes" xml:space="preserve">
          <source>and earlier, the default setting is based on whether or not $prefix contains the string &lt;code&gt;perl&lt;/code&gt; .</source>
          <target state="translated">和更早的版本，默认设置基于$ prefix是否包含字符串 &lt;code&gt;perl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca01c68b157f542551615a222bf4d40f1c92ab92" translate="yes" xml:space="preserve">
          <source>and ending at</source>
          <target state="translated">止于</target>
        </trans-unit>
        <trans-unit id="edc511aaa0ea9a61210a5a9707c8841bf5cc309d" translate="yes" xml:space="preserve">
          <source>and even</source>
          <target state="translated">甚至</target>
        </trans-unit>
        <trans-unit id="883426c92d8b38847917d43ce3dd00b6254d2bed" translate="yes" xml:space="preserve">
          <source>and expect C to be B, because the bearing constantly changes when going from A to B (except in some special case like the meridians or the circles of latitudes) and in great_circle_destination() one gives a &lt;b&gt;constant&lt;/b&gt; bearing to follow.</source>
          <target state="translated">并期望C为B，因为从A到B时方位会不断变化（在某些特殊情况下，例如子午线或纬度圆除外），而great_circle_destination（）中的方位会&lt;b&gt;不断变化&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="3ee040c85734bc842f7986baed3ad3d4c7a277c5" translate="yes" xml:space="preserve">
          <source>and extension authors. If your extension is dynamically loaded, DynaLoader creates</source>
          <target state="translated">和扩展作者。如果您的扩展是动态加载的,DynaLoader会创建</target>
        </trans-unit>
        <trans-unit id="d176fa9bd5235077e8d5cc1dc829719336ead81b" translate="yes" xml:space="preserve">
          <source>and fields. So far, the functions of &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; are unaware of any classes, which I consider a feature. Therefore &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; doesn't address the serialization problems.</source>
          <target state="translated">和领域。到目前为止， &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 的功能尚未意识到任何类，我认为这是一个功能。因此， &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 序列化问题。</target>
        </trans-unit>
        <trans-unit id="6420fc98ccacfbcabdd1358ce52dbb2f18c3b757" translate="yes" xml:space="preserve">
          <source>and for &lt;code&gt;_&lt;/code&gt; to explicitly populate the object using the unexported and undocumented populate() function with CORE::stat():</source>
          <target state="translated">并使用带有CORE :: stat（）的未导出和未记录的populate（）函数使 &lt;code&gt;_&lt;/code&gt; 显式填充对象：</target>
        </trans-unit>
        <trans-unit id="9ecd2684e5d35794eb09b10452dc598bb0f3ca39" translate="yes" xml:space="preserve">
          <source>and for writing:</source>
          <target state="translated">并为写作。</target>
        </trans-unit>
        <trans-unit id="c07a028d906529efcbd2ee19e8498ca6b129b522" translate="yes" xml:space="preserve">
          <source>and from Latin-1 code points to EBCDIC code points</source>
          <target state="translated">和从拉丁文1号码点到EBCDIC码点。</target>
        </trans-unit>
        <trans-unit id="3f19bd785ca0e403ace13135f2e7d2f6fda0fce7" translate="yes" xml:space="preserve">
          <source>and get &lt;code&gt;&quot;mu&lt;/code&gt; &amp;szlig;&lt;code&gt;&quot;&lt;/code&gt; in &lt;code&gt;$match&lt;/code&gt; , since &lt;code&gt;&quot;mu&lt;/code&gt; &amp;szlig;&lt;code&gt;&quot;&lt;/code&gt; is primary equal to &lt;code&gt;&quot;M&lt;/code&gt; &amp;uuml;&lt;code&gt;SS&quot;&lt;/code&gt; .</source>
          <target state="translated">并在 &lt;code&gt;$match&lt;/code&gt; 获得 &lt;code&gt;&quot;mu&lt;/code&gt; mu&amp;szlig; &lt;code&gt;&quot;&lt;/code&gt; ，因为 &lt;code&gt;&quot;mu&lt;/code&gt; mu&amp;szlig; &lt;code&gt;&quot;&lt;/code&gt; 主要等于 &lt;code&gt;&quot;M&lt;/code&gt; M&amp;uuml;SS &lt;code&gt;SS&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17094f04dd71da09c7e552c076f1634e82049f36" translate="yes" xml:space="preserve">
          <source>and have it work portably.</source>
          <target state="translated">并使其能够便携地工作。</target>
        </trans-unit>
        <trans-unit id="a5a8ee21b9af7088e79e9b68f8de88da612fb525" translate="yes" xml:space="preserve">
          <source>and have some pending arguments such as header-file names. This is ok:</source>
          <target state="translated">并有一些待定的参数,如头文件名。这是好的。</target>
        </trans-unit>
        <trans-unit id="d2a6339505fec77b2c331da5c4ce78372f108fa3" translate="yes" xml:space="preserve">
          <source>and hence print:</source>
          <target state="translated">从而印。</target>
        </trans-unit>
        <trans-unit id="43fb62ee614e6b7e422fd695927ade0aa52a2d8a" translate="yes" xml:space="preserve">
          <source>and here is a C function to call it</source>
          <target state="translated">这里有一个C函数来调用它</target>
        </trans-unit>
        <trans-unit id="5091999bd97a90f1245944c2fb5cff579789d3a7" translate="yes" xml:space="preserve">
          <source>and here is a C function to call it.</source>
          <target state="translated">这里有一个C函数来调用它。</target>
        </trans-unit>
        <trans-unit id="9b815eb7a25ba6650e8aed21b42d3225c5665f92" translate="yes" xml:space="preserve">
          <source>and if a method-name was given, it is invoked as:</source>
          <target state="translated">如果给定了方法名,则以如下方式调用。</target>
        </trans-unit>
        <trans-unit id="cc0088cffc94d4cfc5e772584e99d2d2392934ec" translate="yes" xml:space="preserve">
          <source>and if you want to compress each file one at a time, this will do the trick</source>
          <target state="translated">如果你想一次压缩一个文件,这个方法就可以了。</target>
        </trans-unit>
        <trans-unit id="99ebfac46815750e967685ef0c045d72e263a9e9" translate="yes" xml:space="preserve">
          <source>and in</source>
          <target state="translated">并在</target>
        </trans-unit>
        <trans-unit id="633f5443d1716f6d61c0fc8d8b08ec73cf1d7a57" translate="yes" xml:space="preserve">
          <source>and in:</source>
          <target state="translated">并在。</target>
        </trans-unit>
        <trans-unit id="1d0130f8a3921bc892b37851ce6cc11bad75e4c1" translate="yes" xml:space="preserve">
          <source>and is</source>
          <target state="translated">并且是</target>
        </trans-unit>
        <trans-unit id="ebbea3f118453a1b7e7d79408e6db651a9e30122" translate="yes" xml:space="preserve">
          <source>and is invoked when you say</source>
          <target state="translated">并在你说</target>
        </trans-unit>
        <trans-unit id="7ecd6605c858a1a66d6b614d96b36273cffaf756" translate="yes" xml:space="preserve">
          <source>and is now removed.</source>
          <target state="translated">并已删除。</target>
        </trans-unit>
        <trans-unit id="73402b7701fac32d16b3ff7c74498b1589d19a23" translate="yes" xml:space="preserve">
          <source>and is sought only in the current directory.</source>
          <target state="translated">并只在当前目录中寻找。</target>
        </trans-unit>
        <trans-unit id="15dd7cf5f3a3a46ccd4b8609412b5d9ec3d381ec" translate="yes" xml:space="preserve">
          <source>and is typically used to test whether a particular extension is available.</source>
          <target state="translated">并通常用于测试某个特定扩展是否可用。</target>
        </trans-unit>
        <trans-unit id="040dda9958c7c671c9590ef80fa78defd13909d5" translate="yes" xml:space="preserve">
          <source>and is used like this:</source>
          <target state="translated">并且是这样使用的。</target>
        </trans-unit>
        <trans-unit id="7a0762f239de965ed45f319d1c0a1eb571367472" translate="yes" xml:space="preserve">
          <source>and it always croaks on error.</source>
          <target state="translated">而且它总是在出错时呱呱叫。</target>
        </trans-unit>
        <trans-unit id="37328fc9c48882c8dd3a9ee9675314c5a2fe5451" translate="yes" xml:space="preserve">
          <source>and it is called thusly</source>
          <target state="translated">乃谓</target>
        </trans-unit>
        <trans-unit id="30dae0c952d8a4bc4211df4fa02a32b80f898a03" translate="yes" xml:space="preserve">
          <source>and it will print:</source>
          <target state="translated">就可以打印了。</target>
        </trans-unit>
        <trans-unit id="92f48e8870b365babea517ca9b817b451b407aad" translate="yes" xml:space="preserve">
          <source>and it would import the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; override. But if they said</source>
          <target state="translated">它将导入 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 覆盖。但是如果他们说</target>
        </trans-unit>
        <trans-unit id="c15e27e77f8641be998c0928e2456baabe13d2d3" translate="yes" xml:space="preserve">
          <source>and look for 'undef' to find the unsupported APIs (or from Perl use Config).</source>
          <target state="translated">并寻找'undef'来查找不支持的API(或者从Perl中使用Config)。</target>
        </trans-unit>
        <trans-unit id="d0408bb76ba414190a2d1aabc2693a0c0369eb0d" translate="yes" xml:space="preserve">
          <source>and managing the</source>
          <target state="translated">和管理</target>
        </trans-unit>
        <trans-unit id="6d7251c76d8c565a4c8c07c1d963ea078e2097d6" translate="yes" xml:space="preserve">
          <source>and never returns</source>
          <target state="translated">一去不返</target>
        </trans-unit>
        <trans-unit id="ffbc147df069ca6800db6b624cd3c1abcb34c6b3" translate="yes" xml:space="preserve">
          <source>and no matter which sort of shell it's called from, the Perl program will read from the file</source>
          <target state="translated">无论从哪种类型的shell中调用它,Perl程序都会从文件中读出</target>
        </trans-unit>
        <trans-unit id="2f3522d8409fab2c8bd7a9a935e5958b1545b923" translate="yes" xml:space="preserve">
          <source>and not</source>
          <target state="translated">而不是</target>
        </trans-unit>
        <trans-unit id="aece363ea57b99203cb8486606d46afddab39c93" translate="yes" xml:space="preserve">
          <source>and not worry about whether the subscripts are reserved words. In the rare event that you do wish to do something like</source>
          <target state="translated">而不用担心下标是否为保留字。在极少数情况下,您确实希望做一些类似于</target>
        </trans-unit>
        <trans-unit id="90867a465b6b8e0350b0a553fb9bdc04f2f044ec" translate="yes" xml:space="preserve">
          <source>and notify &amp;lt;modules@perl.org&amp;gt;.</source>
          <target state="translated">并通知&amp;lt;modules@perl.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="4fe6790d00afd2e85336f040031f25d3b71777a0" translate="yes" xml:space="preserve">
          <source>and omit the second call to &lt;code&gt;A::foo&lt;/code&gt; (since it would not be distinct from the first call to &lt;code&gt;A::foo&lt;/code&gt; ).</source>
          <target state="translated">并省略对 &lt;code&gt;A::foo&lt;/code&gt; 的第二次调用（因为它与对 &lt;code&gt;A::foo&lt;/code&gt; 的第一次调用没有区别）。</target>
        </trans-unit>
        <trans-unit id="adeced66d67fcec42518c7d43125b26bcafca512" translate="yes" xml:space="preserve">
          <source>and on &lt;code&gt;PATH&lt;/code&gt; . To find arguments for these scripts Perl uses a different algorithm than</source>
          <target state="translated">并在 &lt;code&gt;PATH&lt;/code&gt; 上。为了找到这些脚本的参数，Perl使用与以下算法不同的算法</target>
        </trans-unit>
        <trans-unit id="2af9cc5d9a90aea15c856967222ce6dfd62554a0" translate="yes" xml:space="preserve">
          <source>and on already open streams, use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">在已经打开的流上，使用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5c28d75bfe8ef3f77376f1de537f6ababec7c8f5" translate="yes" xml:space="preserve">
          <source>and one can inspect the value in debugger using all the possible methods.</source>
          <target state="translated">并且可以使用所有可能的方法在调试器中检查该值。</target>
        </trans-unit>
        <trans-unit id="9e3a44de13daa4279c477d6ae9ad2ae6048934f2" translate="yes" xml:space="preserve">
          <source>and only &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$!&lt;/a&gt; and &lt;a href=&quot;perlvar#%24EXTENDED_OS_ERROR&quot;&gt;$^E&lt;/a&gt; will be locale aware. Everything else is unaffected.</source>
          <target state="translated">只有&lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$！&lt;/a&gt;和&lt;a href=&quot;perlvar#%24EXTENDED_OS_ERROR&quot;&gt;$ ^ E&lt;/a&gt;将知道区域设置。其他所有内容均不受影响。</target>
        </trans-unit>
        <trans-unit id="3dfb4545fb1273b004ecd4b9a59f733f64c1cedd" translate="yes" xml:space="preserve">
          <source>and only if the condition is true. &lt;code&gt;unless&lt;/code&gt; is the opposite, it executes the statement</source>
          <target state="translated">并且只有在条件为真的情况下。 &lt;code&gt;unless&lt;/code&gt; 相反，它执行语句</target>
        </trans-unit>
        <trans-unit id="45c260afb98f09cfba9f5207fc8117fcdbcb8feb" translate="yes" xml:space="preserve">
          <source>and only the first of these match:</source>
          <target state="translated">而只有其中的第一种匹配。</target>
        </trans-unit>
        <trans-unit id="32e3341449eff9e33d610a484aa1f31d028b2c36" translate="yes" xml:space="preserve">
          <source>and optimizing the final combined regexp.</source>
          <target state="translated">并优化最终的组合regexp。</target>
        </trans-unit>
        <trans-unit id="899fcac99a7dec6812e6bf7aee73eeaf10908c82" translate="yes" xml:space="preserve">
          <source>and other auto-generated files.</source>
          <target state="translated">和其他自动生成的文件。</target>
        </trans-unit>
        <trans-unit id="c684acd53848e74a7154abad5efe0e096b7463d3" translate="yes" xml:space="preserve">
          <source>and part</source>
          <target state="translated">和部分</target>
        </trans-unit>
        <trans-unit id="d67e5dc377fc2536598e164820c52f727da6d6ab" translate="yes" xml:space="preserve">
          <source>and pass &lt;code&gt;$buf&lt;/code&gt; to your send routine. Some protocols demand that the count should include the length of the count itself: then just add 4 to the data length. (But make sure to read &lt;a href=&quot;#Lengths-and-Widths&quot;&gt;Lengths and Widths&lt;/a&gt; before you really code this!)</source>
          <target state="translated">并将 &lt;code&gt;$buf&lt;/code&gt; 传递给您的发送例程。一些协议要求计数应包括计数本身的长度：然后只需将数据长度加4。（但是在真正编写此代码之前，请确保先阅读&amp;ldquo; &lt;a href=&quot;#Lengths-and-Widths&quot;&gt;长度和宽度&amp;rdquo;&lt;/a&gt;！）</target>
        </trans-unit>
        <trans-unit id="d58ccce831f8e9123bc9e80b9e66f8248b980f4c" translate="yes" xml:space="preserve">
          <source>and process time (in UNIX-like systems the sum of</source>
          <target state="translated">和进程时间(在类似UNIX的系统中,以下两项的总和是指</target>
        </trans-unit>
        <trans-unit id="3fd6226fa225944b6194d79ef250caae14aa04c4" translate="yes" xml:space="preserve">
          <source>and produces results. If you need to customize its behaviour you should probably familiarize yourself with the source first. Enough lecturing.</source>
          <target state="translated">并产生结果。如果你需要定制它的行为,你可能应该先熟悉一下源头。讲的够多了。</target>
        </trans-unit>
        <trans-unit id="bc18719ba2c64a9b71c32941b959a3b37a8e9ccb" translate="yes" xml:space="preserve">
          <source>and programs into</source>
          <target state="translated">和程序成</target>
        </trans-unit>
        <trans-unit id="04b3f3eb12446afa59ba04e34128aaa73360c8fb" translate="yes" xml:space="preserve">
          <source>and puts the</source>
          <target state="translated">并把</target>
        </trans-unit>
        <trans-unit id="1050864b9d5630870510b4c5ed9d494b62e3e1ac" translate="yes" xml:space="preserve">
          <source>and recompile perl</source>
          <target state="translated">并重新编译perl</target>
        </trans-unit>
        <trans-unit id="04dc98e6e6ecb08df2b06a8c82f091b8669d8771" translate="yes" xml:space="preserve">
          <source>and return a list anyway. If so, then only the last element of the list will be returned.</source>
          <target state="translated">并返回一个列表。如果是这样,那么将只返回列表中的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="bea3ea10f617b4820cdc83a6257e4c5d2c2ed531" translate="yes" xml:space="preserve">
          <source>and returns a sequence of octets.</source>
          <target state="translated">并返回一个八位数的序列。</target>
        </trans-unit>
        <trans-unit id="69bdd065458a753e9be3338a81aee1403915b245" translate="yes" xml:space="preserve">
          <source>and returns this:</source>
          <target state="translated">并返回这个。</target>
        </trans-unit>
        <trans-unit id="05a85acb845c8558aabbfdc75bce2f31eacc6f3d" translate="yes" xml:space="preserve">
          <source>and runs it through the pager specified in &lt;code&gt;$CPAN::Config-&amp;gt;{pager}&lt;/code&gt; .</source>
          <target state="translated">并通过 &lt;code&gt;$CPAN::Config-&amp;gt;{pager}&lt;/code&gt; 指定的寻呼机运行它。</target>
        </trans-unit>
        <trans-unit id="88b01bfc16080bd793c508ce92be40c54c4e0d32" translate="yes" xml:space="preserve">
          <source>and see whether they list something resembling these</source>
          <target state="translated">看看他们是否列出了类似于这些的东西</target>
        </trans-unit>
        <trans-unit id="9407dd89aa838f3db9bc1ee001171ae499cdf58c" translate="yes" xml:space="preserve">
          <source>and send a line of data to it this way:</source>
          <target state="translated">并这样发送一行数据给它。</target>
        </trans-unit>
        <trans-unit id="834b5f4699ca8ef5bed1ec71205174ca1aa071f2" translate="yes" xml:space="preserve">
          <source>and should never be used lightly.</source>
          <target state="translated">而绝不能轻易使用。</target>
        </trans-unit>
        <trans-unit id="cc72a00bf5f82a31e19586f8d5648eeb9609f807" translate="yes" xml:space="preserve">
          <source>and so on.</source>
          <target state="translated">诸如此类。</target>
        </trans-unit>
        <trans-unit id="9db3feda6610247fb93d16581c9f1e324a0dc3ce" translate="yes" xml:space="preserve">
          <source>and so on. Note how the trailing sub-version is automatically stripped from the version.</source>
          <target state="translated">以此类推。请注意后面的子版本是如何从版本中自动剥离的。</target>
        </trans-unit>
        <trans-unit id="0b888a2f960617a6f6c366d202b424cbea99cdde" translate="yes" xml:space="preserve">
          <source>and some C to call it</source>
          <target state="translated">和一些C来称呼它</target>
        </trans-unit>
        <trans-unit id="a1e18734fb68f76855ac9d83f86033f89bcb6297" translate="yes" xml:space="preserve">
          <source>and someone has been calling it with an array or expression returning a list:</source>
          <target state="translated">有人用数组或表达式调用它,返回一个列表。</target>
        </trans-unit>
        <trans-unit id="c88d797f97ab7980940e6fbc2a0b1b0f03bf45ed" translate="yes" xml:space="preserve">
          <source>and start with this template:</source>
          <target state="translated">并从这个模板开始。</target>
        </trans-unit>
        <trans-unit id="60a1a53956f7f1b07c9ff7e2cf048e0d61cf0aff" translate="yes" xml:space="preserve">
          <source>and still have it work under all the modes Perl could have been compiled with.</source>
          <target state="translated">并且在Perl可以编译的所有模式下仍然可以工作。</target>
        </trans-unit>
        <trans-unit id="b93c07a562c2c0c86991f560b275725c74228f04" translate="yes" xml:space="preserve">
          <source>and suffix of C&amp;lt;.dat&amp;gt; would generate a file similar to F</source>
          <target state="translated">和C &amp;lt;.dat&amp;gt;的后缀将生成类似于F的文件</target>
        </trans-unit>
        <trans-unit id="58b0b8a5933189f91ce79bd5aaa4c4a91a53f4c2" translate="yes" xml:space="preserve">
          <source>and symbolic sub references</source>
          <target state="translated">和符号子引用</target>
        </trans-unit>
        <trans-unit id="c8bd05940ef361af618d2f58d8ef228c2dc1eee1" translate="yes" xml:space="preserve">
          <source>and that the default flags are kept in a global C variable &lt;code&gt;default_flags&lt;/code&gt; . Suppose that you want to create an interface which is called as</source>
          <target state="translated">并且默认标志保留在全局C变量 &lt;code&gt;default_flags&lt;/code&gt; 中。假设您要创建一个称为</target>
        </trans-unit>
        <trans-unit id="97ed4c8cfdc4058f64674afafa62d45ea754ba4b" translate="yes" xml:space="preserve">
          <source>and that will set this class as the default formatter to run when you do &lt;code&gt;perldoc whatever&lt;/code&gt; .</source>
          <target state="translated">这会将此类设置为在执行 &lt;code&gt;perldoc whatever&lt;/code&gt; 时运行的默认格式化程序。</target>
        </trans-unit>
        <trans-unit id="38d402cb5ba5ced669d83f33b900f232ec58d72a" translate="yes" xml:space="preserve">
          <source>and the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a3e1044d78ff80b32d4053c48546a54399bb4a" translate="yes" xml:space="preserve">
          <source>and the (compiled)</source>
          <target state="translated">和(编译)的</target>
        </trans-unit>
        <trans-unit id="7709e2962fcebb7a32dface22926131efe462333" translate="yes" xml:space="preserve">
          <source>and the &lt;code&gt;&quot;-&quot;&lt;/code&gt; shouldn't be the first character. If you want to be hypercorrect, stay case-insensitive and within the 8.3 naming convention (all the files and directories have to be unique within one directory if their names are lowercased and truncated to eight characters before the &lt;code&gt;.&lt;/code&gt;, if any, and to three characters after the &lt;code&gt;.&lt;/code&gt;, if any). (And do not use &lt;code&gt;.&lt;/code&gt;s in directory names.)</source>
          <target state="translated">并且 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 不应是第一个字符。如果要超级正确，请保持大小写不敏感并且在8.3命名约定之内（如果文件和目录的名称均小写并在 &lt;code&gt;.&lt;/code&gt; 之前截断为八个字符（如果有的话）和三个，则所有文件和目录在一个目录中必须唯一。 &lt;code&gt;.&lt;/code&gt; 之后的字符（如果有）。（不要使用 &lt;code&gt;.&lt;/code&gt; 在目录名峰）</target>
        </trans-unit>
        <trans-unit id="4d66f33f291aa497e1fbb1cea751208ffbc34985" translate="yes" xml:space="preserve">
          <source>and the &lt;code&gt;S_IF*&lt;/code&gt; functions are</source>
          <target state="translated">和 &lt;code&gt;S_IF*&lt;/code&gt; 函数是</target>
        </trans-unit>
        <trans-unit id="2942a15e2cfe5df5d7b4806203036ff2059365fd" translate="yes" xml:space="preserve">
          <source>and the &lt;code&gt;build&lt;/code&gt; of the &lt;code&gt;prereqs&lt;/code&gt; field of your</source>
          <target state="translated">以及您的 &lt;code&gt;prereqs&lt;/code&gt; 字段的 &lt;code&gt;build&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab5709809a705fe3cbf34a47d36a8f9e3b151b2f" translate="yes" xml:space="preserve">
          <source>and the &lt;code&gt;configure&lt;/code&gt; of the &lt;code&gt;prereqs&lt;/code&gt; field of your</source>
          <target state="translated">以及您的 &lt;code&gt;prereqs&lt;/code&gt; 字段的 &lt;code&gt;configure&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02c4a9e6fa1ed7552c9cc696dccfac8693bb8d07" translate="yes" xml:space="preserve">
          <source>and the &lt;code&gt;padadd_STATE&lt;/code&gt; flag get added to</source>
          <target state="translated">和 &lt;code&gt;padadd_STATE&lt;/code&gt; 标志添加到</target>
        </trans-unit>
        <trans-unit id="3e4685b36d5a4d2703e2682160eabe2135a107d7" translate="yes" xml:space="preserve">
          <source>and the &lt;code&gt;runtime&lt;/code&gt; of the &lt;code&gt;prereqs&lt;/code&gt; field of your</source>
          <target state="translated">以及您的 &lt;code&gt;prereqs&lt;/code&gt; 字段的 &lt;code&gt;runtime&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25ff9d2e379f8fa04204de9723f370d19f946094" translate="yes" xml:space="preserve">
          <source>and the &lt;code&gt;test&lt;/code&gt; of the &lt;code&gt;prereqs&lt;/code&gt; field of your</source>
          <target state="translated">和您的 &lt;code&gt;prereqs&lt;/code&gt; 字段的 &lt;code&gt;test&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad51d3bef464cc47afa473cbf58e8f411acbad00" translate="yes" xml:space="preserve">
          <source>and the B part would be serialized by the engine. In &lt;code&gt;STORABLE_thaw&lt;/code&gt; , you would get back the reference to the B' object, deserialized for you.</source>
          <target state="translated">B部分将由引擎序列化。在 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 中，您将获得对B'对象的引用，该对象已为您反序列化。</target>
        </trans-unit>
        <trans-unit id="147f20996051af5faf516917523025a59c3b1223" translate="yes" xml:space="preserve">
          <source>and the anonymous sub used with a</source>
          <target state="translated">和匿名子与</target>
        </trans-unit>
        <trans-unit id="be7ddd8a1c2d20b11344c530e59b1a76ec5867c2" translate="yes" xml:space="preserve">
          <source>and the assignments to &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT_OK&lt;/code&gt; happen immediately, leaving no room for something to get awry or just plain wrong.</source>
          <target state="translated">并且对 &lt;code&gt;@ISA&lt;/code&gt; 和 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 的分配立即发生，不留任何空间来弄错或只是犯错。</target>
        </trans-unit>
        <trans-unit id="ec3881e38f6bc29241523880e8b6087893781e29" translate="yes" xml:space="preserve">
          <source>and the code for rpcb_gettime() can be rewritten as</source>
          <target state="translated">而rpcb_gettime()的代码可以重写为</target>
        </trans-unit>
        <trans-unit id="d0b288947e39526d473e38a00227523ed22a3b40" translate="yes" xml:space="preserve">
          <source>and the context and data stacks, as shown by &lt;code&gt;-Dstv&lt;/code&gt; , look like:</source>
          <target state="translated">以及上下文和数据堆栈（如 &lt;code&gt;-Dstv&lt;/code&gt; 所示）如下所示：</target>
        </trans-unit>
        <trans-unit id="0053caf8d86bff52b61e0db6e20570501321030d" translate="yes" xml:space="preserve">
          <source>and the decoding is</source>
          <target state="translated">而解码是</target>
        </trans-unit>
        <trans-unit id="6db487f2363f1808733e361f4f9ef6e4c29bac55" translate="yes" xml:space="preserve">
          <source>and the dual-life modules are in</source>
          <target state="translated">和双寿命模块在</target>
        </trans-unit>
        <trans-unit id="701a5fbfcd6a3d0bfbaa14dc1799d0bcc3687760" translate="yes" xml:space="preserve">
          <source>and the first argument of myref() will be a reference to a scalar, an array, a hash, a code, or a glob.</source>
          <target state="translated">和myref()的第一个参数将是对一个标量、数组、哈希、代码或glob的引用。</target>
        </trans-unit>
        <trans-unit id="41644e439068ccf4dd12a38456eb1c0abd4f9ac4" translate="yes" xml:space="preserve">
          <source>and the following code will read the hexdump in and convert it on the fly back into bytes:</source>
          <target state="translated">而下面的代码将读入hexdump,并在飞行中把它转换回字节。</target>
        </trans-unit>
        <trans-unit id="50b6d807bc1aa40041d0aec64ce2f373303ab28d" translate="yes" xml:space="preserve">
          <source>and the latter should be used for consistency.</source>
          <target state="translated">而为了保持一致性,应采用后者。</target>
        </trans-unit>
        <trans-unit id="a319d5d5f1db6ffbf62ebbd0eae703d0f1b20336" translate="yes" xml:space="preserve">
          <source>and the method form of &lt;code&gt;isa&lt;/code&gt; for the second:</source>
          <target state="translated">第二个 &lt;code&gt;isa&lt;/code&gt; 的方法形式：</target>
        </trans-unit>
        <trans-unit id="d51a49fa5c4b18f00dbcb9d665d43c1102906852" translate="yes" xml:space="preserve">
          <source>and the newer &lt;a href=&quot;concise&quot;&gt;B::Concise&lt;/a&gt;, &lt;a href=&quot;terse&quot;&gt;B::Terse&lt;/a&gt;.</source>
          <target state="translated">和更新的&lt;a href=&quot;concise&quot;&gt;B :: Concise&lt;/a&gt;，&lt;a href=&quot;terse&quot;&gt;B :: Terse&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0101ea36f11aa234346b21c12169ca0fa18afce9" translate="yes" xml:space="preserve">
          <source>and the numeric value of $c becomes 5. However, after calling</source>
          <target state="translated">而$c的数值变成了5。然而,在调用</target>
        </trans-unit>
        <trans-unit id="59496338c48bb851d2fcd377f515a4eb8426caa1" translate="yes" xml:space="preserve">
          <source>and the old 5.005 style threading, or for that matter, to most other threading systems out there, is that by default, no data is shared. When a new Perl thread is created, all the data associated with the current thread is copied to the new thread, and is subsequently private to that new thread! This is similar in feel to what happens when a Unix process forks, except that in this case, the data is just copied to a different part of memory within the same process rather than a real fork taking place.</source>
          <target state="translated">和旧的5.005风格的线程,或者说,对于大多数其他线程系统来说,默认情况下,没有数据是共享的。当一个新的Perl线程被创建时,所有与当前线程相关的数据都会被复制到新线程中,并且随后成为新线程的私有数据!这与Unix进程分叉时的感觉类似。这和 Unix 进程分叉时的感觉很相似,只是在这种情况下,数据只是被复制到了同一个进程的内存中的不同部分,而不是真正的分叉。</target>
        </trans-unit>
        <trans-unit id="f98e525fd3fa23c9c2e46620627a8148db25bb3f" translate="yes" xml:space="preserve">
          <source>and the process defaults to expand the filespec) and pass the rest of &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;'s argument to it as parameters. If the token has no file type, and matches a file with null type, then an attempt is made to determine whether the file is an executable image which should be invoked using &lt;code&gt;MCR&lt;/code&gt; or a text file which should be passed to DCL as a command procedure.</source>
          <target state="translated">并且该过程默认情况下会扩展filespec），并将 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 的其余参数作为参数传递给它。如果令牌没有文件类型，并且与空类型的文件匹配，则尝试确定该文件是应使用 &lt;code&gt;MCR&lt;/code&gt; 调用的可执行映像还是应作为命令过程传递给DCL的文本文件。</target>
        </trans-unit>
        <trans-unit id="ddacafb3c506d7d636313e8cd8381b88b300fc0f" translate="yes" xml:space="preserve">
          <source>and the process defaults, and if successful, the resulting file is invoked via &lt;code&gt;MCR&lt;/code&gt; . This allows you to invoke an image directly simply by passing the file specification to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, a common Unixish idiom. If the token has no file type, and matches a file with null type, then an attempt is made to determine whether the file is an executable image which should be invoked using &lt;code&gt;MCR&lt;/code&gt; or a text file which should be passed to DCL as a command procedure.</source>
          <target state="translated">并且该过程为默认设置，如果成功，则通过 &lt;code&gt;MCR&lt;/code&gt; 调用生成的文件。这使您可以简单地通过将文件规范传递给 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; （一种常见的Unixish习惯用法）直接调用图像。如果令牌没有文件类型，并且与空类型的文件匹配，则尝试确定该文件是应使用 &lt;code&gt;MCR&lt;/code&gt; 调用的可执行映像还是应作为命令过程传递给DCL的文本文件。</target>
        </trans-unit>
        <trans-unit id="01a7d35d5fca09ca87a957bce5a8e41bd9acadb8" translate="yes" xml:space="preserve">
          <source>and the repeat count is obtained by popping off the last element from the stack. The</source>
          <target state="translated">和重复次数是通过从堆栈中弹出最后一个元素获得的。栈中的</target>
        </trans-unit>
        <trans-unit id="ffb8c286d177a7fde4b96ec8e58df11a57708992" translate="yes" xml:space="preserve">
          <source>and the result is not what you likely expected. No warnings are generated. If you do string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;'s within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , you should instead change the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; line to do something like:</source>
          <target state="translated">结果不是您预期的那样。不生成警告。如果在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境的范围内进行字符串 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，则应改为更改 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 行以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="5826e275e51e2f92c417012d26e57183b67ddebf" translate="yes" xml:space="preserve">
          <source>and the second as</source>
          <target state="translated">第二种为</target>
        </trans-unit>
        <trans-unit id="4b0c54cf5e55bcce5334c4fb8936e4b45df4be44" translate="yes" xml:space="preserve">
          <source>and the variable is only assigned if the condition is false. In Perl, you need parentheses:</source>
          <target state="translated">而且只有当条件为假时,变量才会被赋值。在Perl中,你需要使用括号。</target>
        </trans-unit>
        <trans-unit id="b195225fa7acc0b96c9d796bff6aa32f9bf25de1" translate="yes" xml:space="preserve">
          <source>and their source code:</source>
          <target state="translated">及其源代码。</target>
        </trans-unit>
        <trans-unit id="a357a0b3b6bb01e41a042b584904f6b12375f3f1" translate="yes" xml:space="preserve">
          <source>and then</source>
          <target state="translated">然后</target>
        </trans-unit>
        <trans-unit id="a89a3626b8565f1e4fe93595aa23beb07a814bdf" translate="yes" xml:space="preserve">
          <source>and then &lt;code&gt;make install&lt;/code&gt; directly in the subshell.</source>
          <target state="translated">然后直接在子Shell中 &lt;code&gt;make install&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c057b91530af5ff3d52f001fe2897560766773fd" translate="yes" xml:space="preserve">
          <source>and then I can use it as:</source>
          <target state="translated">然后我可以用它作为。</target>
        </trans-unit>
        <trans-unit id="7ee1c36bc806d74c955b8deeab5a71a91290b0b4" translate="yes" xml:space="preserve">
          <source>and then at the end add a subroutine (which will override the pre-existing subroutine). Remember to use a tab character to indent the line beginning with &quot;cd&quot;!</source>
          <target state="translated">然后在最后添加一个子程序(它将覆盖已有的子程序)。记得使用tab字符缩进以 &quot;cd &quot;开头的行!</target>
        </trans-unit>
        <trans-unit id="ab0d506f35fd3822d193cc9360b63e031c3942f4" translate="yes" xml:space="preserve">
          <source>and then calls the compiled value, and returns that. (I.e., if $key looks like bracket notation, $compiled is a sub, and we return &amp;amp;{$compiled}(@params); but if $key is just a plain string, we just return that.)</source>
          <target state="translated">然后调用编译后的值，并返回该值。（即，如果$ key看起来像是括号符号，则$ compiled是一个子项，并且我们返回＆{$ compiled}（@ params）；但是，如果$ key只是一个纯字符串，我们将其返回。）</target>
        </trans-unit>
        <trans-unit id="44a3152294c4111f2c746a317f7528eba26af20d" translate="yes" xml:space="preserve">
          <source>and then compile Perl. The places where fchdir() is used have alternatives for systems that do not have fchdir() available.</source>
          <target state="translated">然后编译Perl。在使用fchdir()的地方,对于没有fchdir()的系统,有其他的选择。</target>
        </trans-unit>
        <trans-unit id="9b2df89c641d69f45a815efca5beef7560ca9a0a" translate="yes" xml:space="preserve">
          <source>and then just answer client requests for language $wanted by just looking up</source>
          <target state="translated">然后只需回答客户对语言$wanted的请求,只需查到了</target>
        </trans-unit>
        <trans-unit id="8b1640f57029d1835984f3af20d2191014b99ddf" translate="yes" xml:space="preserve">
          <source>and then only hard references will be allowed for the rest of the enclosing block. An inner block may countermand that with</source>
          <target state="translated">然后只允许对包围块的其余部分进行硬引用。内嵌块可以用</target>
        </trans-unit>
        <trans-unit id="451e30567469e8b460f1d3bc5414c41a6638cddf" translate="yes" xml:space="preserve">
          <source>and then re-compiling and installing. (&lt;code&gt;%Config&lt;/code&gt; is available from the Config module).</source>
          <target state="translated">然后重新编译安装。（ &lt;code&gt;%Config&lt;/code&gt; 可从Config模块获得）。</target>
        </trans-unit>
        <trans-unit id="a0240abc49e91dec760c37658ba9b71575aed0e0" translate="yes" xml:space="preserve">
          <source>and then restart the debugger using the &lt;code&gt;R&lt;/code&gt; command (if possible). One can use &lt;code&gt;b
compile subname&lt;/code&gt; for the same purpose.</source>
          <target state="translated">然后使用 &lt;code&gt;R&lt;/code&gt; 命令重新启动调试器（如果可能）。出于相同的目的，可以使用 &lt;code&gt;b compile subname&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbf31119ed47c5f8b69e18f4d5f705e1c96574bd" translate="yes" xml:space="preserve">
          <source>and then there's</source>
          <target state="translated">还有</target>
        </trans-unit>
        <trans-unit id="353ea5311f06d213fb4274ba5a999ecceb56a41b" translate="yes" xml:space="preserve">
          <source>and then use pax.</source>
          <target state="translated">然后用Pax。</target>
        </trans-unit>
        <trans-unit id="48126773317a746d38788a830d1f700877f824cc" translate="yes" xml:space="preserve">
          <source>and there are currently 32 types. These different structures contain pointers to various routines that perform additional actions depending on which function is being called.</source>
          <target state="translated">并且目前有32种类型。这些不同的结构包含指向各种例程的指针,这些例程根据被调用的函数执行额外的操作。</target>
        </trans-unit>
        <trans-unit id="125d179aee3f08c5f3f28753f2a610fce93912ec" translate="yes" xml:space="preserve">
          <source>and these</source>
          <target state="translated">而这些</target>
        </trans-unit>
        <trans-unit id="e1493a3f0807b6f38cd28b6afc4496c286e444bc" translate="yes" xml:space="preserve">
          <source>and these conditions now hold; changes in caps:</source>
          <target state="translated">而现在这些条件都是成立的;上限的变化。</target>
        </trans-unit>
        <trans-unit id="634f4431e19540e83429c99c727415ca241cf810" translate="yes" xml:space="preserve">
          <source>and they need renamed to this</source>
          <target state="translated">而他们需要改名为这个</target>
        </trans-unit>
        <trans-unit id="c08d7693095dbd2bcba2f2bba00e5c933e696272" translate="yes" xml:space="preserve">
          <source>and things will Just Work.</source>
          <target state="translated">事情就会水到渠成。</target>
        </trans-unit>
        <trans-unit id="13d6234dafca22c495f68d2e93ffa91530cf4576" translate="yes" xml:space="preserve">
          <source>and this all reduces to one string internally. Likewise, if you say</source>
          <target state="translated">而这一切在内部都简化为一个字符串。同样,如果你说</target>
        </trans-unit>
        <trans-unit id="54d316122df54908b330dbe67e0eb1a7496b2e8d" translate="yes" xml:space="preserve">
          <source>and this is the C function</source>
          <target state="translated">这就是C函数</target>
        </trans-unit>
        <trans-unit id="b0b7cef2e136b9167abea8c18920b79278779cc6" translate="yes" xml:space="preserve">
          <source>and this is the equivalent skeleton for the</source>
          <target state="translated">而这是等价的骨架。</target>
        </trans-unit>
        <trans-unit id="6eebd24f36d63aecef99cba57072fffe82f277ba" translate="yes" xml:space="preserve">
          <source>and this is what it outputs:</source>
          <target state="translated">这就是它的输出。</target>
        </trans-unit>
        <trans-unit id="fd12e4da86b9aadfbb2734c8e5f1bee5da3b93ce" translate="yes" xml:space="preserve">
          <source>and this to write compress files, if you have the &lt;code&gt;compress&lt;/code&gt; program available</source>
          <target state="translated">如果您有可用的 &lt;code&gt;compress&lt;/code&gt; 程序，这将写入压缩文件</target>
        </trans-unit>
        <trans-unit id="e2c2bf67a7935e18e359ad79d84198585a4af3bd" translate="yes" xml:space="preserve">
          <source>and this with &lt;code&gt;gunzip&lt;/code&gt;</source>
          <target state="translated">这与 &lt;code&gt;gunzip&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d39dfbea4e5b4447637693f64c38ebc1f8116f81" translate="yes" xml:space="preserve">
          <source>and thus the North American servers happen to be listed between the European and the South American sites.</source>
          <target state="translated">因此,北美服务器恰好被列在欧洲和南美网站之间。</target>
        </trans-unit>
        <trans-unit id="cb400c328bbed62df7bf2a79424df0971a9b0060" translate="yes" xml:space="preserve">
          <source>and to convert it back:</source>
          <target state="translated">并将其转换回来。</target>
        </trans-unit>
        <trans-unit id="389eab738d2c24825aaf583e6d4e7e90f7197558" translate="yes" xml:space="preserve">
          <source>and to make a subroutine visible to other packages in the same scope:</source>
          <target state="translated">并使子程序对同一范围内的其他包可见。</target>
        </trans-unit>
        <trans-unit id="217975290eb70597845ac22d0c9eaec6ba4f2b06" translate="yes" xml:space="preserve">
          <source>and to pop the return value out. Take a deep breath...</source>
          <target state="translated">并将返回值弹出。深吸一口气...</target>
        </trans-unit>
        <trans-unit id="f2f253ad479c1e47993bd311d49420fc3740b03a" translate="yes" xml:space="preserve">
          <source>and to prevent the filter's being turned off in any way:</source>
          <target state="translated">并以任何方式防止过滤器的关闭。</target>
        </trans-unit>
        <trans-unit id="f457722dbced2bf2ae91cbfea945e31146a31b39" translate="yes" xml:space="preserve">
          <source>and to set CCHOME, CCINCDIR and CCLIBDIR as per the environment setup above.</source>
          <target state="translated">并按照上面的环境设置设置CCHOME、CCINCDIR和CCLIBDIR。</target>
        </trans-unit>
        <trans-unit id="d2fe6dcb8f246d2fce35f742575fa001821e5680" translate="yes" xml:space="preserve">
          <source>and tries again, since it's customary to have file types on all files under VMS.</source>
          <target state="translated">并再次尝试,因为按照惯例,VMS下所有文件都有文件类型。</target>
        </trans-unit>
        <trans-unit id="3b1648c7e0ac8e95616dae97bc077625fd8d6af2" translate="yes" xml:space="preserve">
          <source>and uncomment the relevant variables near the end of the file.</source>
          <target state="translated">并在文件结尾处取消相关变量的注释。</target>
        </trans-unit>
        <trans-unit id="cfcf943d2393a6f28d49e0ffac0815fd27da0bf6" translate="yes" xml:space="preserve">
          <source>and uncomment the struct.</source>
          <target state="translated">并取消对结构的注释。</target>
        </trans-unit>
        <trans-unit id="9e6562a3babb41524cb81f0cde70dfef28222be8" translate="yes" xml:space="preserve">
          <source>and under Win32, the approximately equivalent:</source>
          <target state="translated">而在Win32下,大约相当于。</target>
        </trans-unit>
        <trans-unit id="46d5ca958aec010c55ad2c03e5821dac149faf98" translate="yes" xml:space="preserve">
          <source>and use the &lt;code&gt;TIOCNOTTY&lt;/code&gt; ioctl() on it instead. See tty(4) for details.</source>
          <target state="translated">并改用 &lt;code&gt;TIOCNOTTY&lt;/code&gt; ioctl（）。有关详细信息，请参见tty（4）。</target>
        </trans-unit>
        <trans-unit id="9f14a6780c851ae104f1481fc1a9906cf9782249" translate="yes" xml:space="preserve">
          <source>and wait:</source>
          <target state="translated">并等待。</target>
        </trans-unit>
        <trans-unit id="69c07c00f94d0c5b0709bf9c6938ba419bdf55e3" translate="yes" xml:space="preserve">
          <source>and when compiling the POSIX extension</source>
          <target state="translated">而当编译POSIX扩展时</target>
        </trans-unit>
        <trans-unit id="6ee8bc7f7f274956ec858de1f58858d8da87dae0" translate="yes" xml:space="preserve">
          <source>and will work on any list:</source>
          <target state="translated">并将在任何清单上工作。</target>
        </trans-unit>
        <trans-unit id="56f643ea045d7d28116e861b4f87f762cdd48385" translate="yes" xml:space="preserve">
          <source>and you are attempting to remove an ancestor, such as</source>
          <target state="translated">而您正试图删除一个祖先,如</target>
        </trans-unit>
        <trans-unit id="675d70b7c962e8ca4b793a761fbb9992623d3828" translate="yes" xml:space="preserve">
          <source>and you can create well-formed Unicode with</source>
          <target state="translated">你可以用以下方法创建格式良好的Unicode</target>
        </trans-unit>
        <trans-unit id="9c639a2ec15edc09ca8e02e951acf39319cc8f44" translate="yes" xml:space="preserve">
          <source>and you want to Export symbol &lt;code&gt;$A::b&lt;/code&gt; back to the module that called package A. Since Exporter relies on the import method to work, via inheritance, as it stands Exporter::import() will never get called. Instead, say the following:</source>
          <target state="translated">您想将符号 &lt;code&gt;$A::b&lt;/code&gt; 导出到调用包A的模块中。由于Exporter依赖于导入方法，因此通过继承起作用，因为继承人Exporter :: import（）永远不会被调用。相反，请说以下内容：</target>
        </trans-unit>
        <trans-unit id="622cd26503fac9383fb718bed2b3ddba040f7083" translate="yes" xml:space="preserve">
          <source>and you want to produce an output like this, with each country mentioned once, and then an alphabetical list of the cities in that country:</source>
          <target state="translated">而你想产生这样的输出,每个国家被提及一次,然后按字母顺序列出这个国家的城市。</target>
        </trans-unit>
        <trans-unit id="4c1468c599d605484919b48473553ef4293085c5" translate="yes" xml:space="preserve">
          <source>and you're done.</source>
          <target state="translated">你就可以了。</target>
        </trans-unit>
        <trans-unit id="b0adec687e3ab4fff14b5efa8b7087cfcfe80d04" translate="yes" xml:space="preserve">
          <source>and/or</source>
          <target state="translated">and/or</target>
        </trans-unit>
        <trans-unit id="9f29ab58f3ce583beed68be5f3bf29542855d9de" translate="yes" xml:space="preserve">
          <source>angles being equal to</source>
          <target state="translated">角等于</target>
        </trans-unit>
        <trans-unit id="03f6df04819f61a4ed7725f72fc3f5557572193e" translate="yes" xml:space="preserve">
          <source>angles.</source>
          <target state="translated">angles.</target>
        </trans-unit>
        <trans-unit id="0a92fab3230134cca6eadd9898325b9b2ae67998" translate="yes" xml:space="preserve">
          <source>anonymous</source>
          <target state="translated">anonymous</target>
        </trans-unit>
        <trans-unit id="f3939ccfbbc78c50725aff277833f2cbdd31e9da" translate="yes" xml:space="preserve">
          <source>anonymous subroutine.)</source>
          <target state="translated">匿名子程序)。)</target>
        </trans-unit>
        <trans-unit id="14ccf9a789edbcad8533f0e8977c70173ff9dfa6" translate="yes" xml:space="preserve">
          <source>anonymous@</source>
          <target state="translated">anonymous@</target>
        </trans-unit>
        <trans-unit id="b7c8ffb8fbc67c171328e0e8f643694e8e61b335" translate="yes" xml:space="preserve">
          <source>another</source>
          <target state="translated">another</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
