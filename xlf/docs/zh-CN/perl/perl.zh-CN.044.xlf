<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="fe9382125ff2c139dab5a2974252e8c96e13c1f7" translate="yes" xml:space="preserve">
          <source>This does not check if &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $brooklyn{tree}&lt;/code&gt; is true, it checks if it returns 1. Very different. Similar caveats exist for false and 0. In these cases, use &lt;code&gt;ok()&lt;/code&gt; .</source>
          <target state="translated">这不会检查 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $brooklyn{tree}&lt;/code&gt; 是否&lt;a href=&quot;../functions/exists&quot;&gt;存在&lt;/a&gt;，而是检查它是否返回1。非常不同。对于false和0存在类似的警告。在这些情况下，请使用 &lt;code&gt;ok()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98a4bb476f64546166599da65496591b48105011" translate="yes" xml:space="preserve">
          <source>This does not consult the local filesystem on Unix, Win32, OS/2 or Mac OS (Classic). It does consult the working environment for VMS (see &lt;a href=&quot;vms#file_name_is_absolute&quot;&gt;file_name_is_absolute in File::Spec::VMS&lt;/a&gt;).</source>
          <target state="translated">这不参考Unix，Win32，OS / 2或Mac OS（经典）上的本地文件系统。它确实参考了VMS的工作环境（请参阅&lt;a href=&quot;vms#file_name_is_absolute&quot;&gt;File :: Spec :: VMS中的file_name_is_absolute&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5567db63aec81d4f2bb7d5785e7a6d2074129096" translate="yes" xml:space="preserve">
          <source>This does not consult the local filesystem on Unix, Win32, OS/2, or Mac OS (Classic). It does consult the working environment for VMS (see &lt;a href=&quot;spec/vms#file_name_is_absolute&quot;&gt;file_name_is_absolute in File::Spec::VMS&lt;/a&gt;).</source>
          <target state="translated">这不参考Unix，Win32，OS / 2或Mac OS（经典）上的本地文件系统。它确实参考了VMS的工作环境（请参阅&lt;a href=&quot;spec/vms#file_name_is_absolute&quot;&gt;File :: Spec :: VMS中的file_name_is_absolute&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0a35bcc864cbc531874ff7b69a1ed16eb2d6e952" translate="yes" xml:space="preserve">
          <source>This does not need an interpreter context, so the definition has no &lt;code&gt;pTHX&lt;/code&gt; , and it follows that callers don't use &lt;code&gt;aTHX&lt;/code&gt; . (See &lt;a href=&quot;#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;Background and PERL_IMPLICIT_CONTEXT&lt;/a&gt;.)</source>
          <target state="translated">这不需要解释器上下文，因此该定义没有 &lt;code&gt;pTHX&lt;/code&gt; ，因此，调用者不使用 &lt;code&gt;aTHX&lt;/code&gt; 。（请参阅&lt;a href=&quot;#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;背景和PERL_IMPLICIT_CONTEXT&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="7d5400494835955231d73bab6efd7d27c959f429" translate="yes" xml:space="preserve">
          <source>This does not work with object methods, however; all object methods have to be in the symbol table of some package to be found. See &lt;a href=&quot;perlref#Function-Templates&quot;&gt;Function Templates in perlref&lt;/a&gt; for something of a work-around to this.</source>
          <target state="translated">但是，这不适用于对象方法。所有对象方法都必须在某个包的符号表中才能找到。有关此问题的&lt;a href=&quot;perlref#Function-Templates&quot;&gt;变通方法&lt;/a&gt;，请参见perlref中的功能模板。</target>
        </trans-unit>
        <trans-unit id="0d2225ec395dc726d6f789db247181b8752831a9" translate="yes" xml:space="preserve">
          <source>This does require you to read the entire archive in to memory first, since otherwise we wouldn't know what data to fill the copy with. (This means that you cannot use the class methods, including &lt;code&gt;iter&lt;/code&gt; on archives that have incompatible filetypes and still expect things to work).</source>
          <target state="translated">这确实需要您首先将整个档案读入内存，因为否则我们将不知道用什么数据填充副本。（这意味着您不能使用类方法，包括对文件类型不兼容但仍期望其正常工作的归档文件进行 &lt;code&gt;iter&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d695e6a31e5a4eec6a56e77d637d17eb575265f8" translate="yes" xml:space="preserve">
          <source>This does the same:</source>
          <target state="translated">这也是同样的道理。</target>
        </trans-unit>
        <trans-unit id="dc02dd18bd8bcc4ec6d08efce5d8f98b8592ad09" translate="yes" xml:space="preserve">
          <source>This doesn't copy the underlying array:</source>
          <target state="translated">这不会复制底层数组。</target>
        </trans-unit>
        <trans-unit id="6a45cffcf59adcdd497d8553e6a4ac8aa27d7fd9" translate="yes" xml:space="preserve">
          <source>This doesn't do anything to your input, or to your output. It only influences the way your sources are read. You can use Unicode in string literals, in identifiers (but they still have to be &quot;word characters&quot; according to &lt;code&gt;\w&lt;/code&gt; ), and even in custom delimiters.</source>
          <target state="translated">这对您的输入或输出没有任何作用。它仅影响阅读源的方式。您可以在字符串文字，标识符（但根据 &lt;code&gt;\w&lt;/code&gt; ，它们仍必须是&amp;ldquo;单词字符&amp;rdquo; ）甚至自定义定界符中使用Unicode 。</target>
        </trans-unit>
        <trans-unit id="c08d4d18717ad728adb161ebb6ace72d574c3c92" translate="yes" xml:space="preserve">
          <source>This doesn't mean that a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variable declared in a statically enclosing lexical scope would be invisible. Only dynamic scopes are cut off. For example, the &lt;code&gt;bumpx()&lt;/code&gt; function below has access to the lexical $x variable because both the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; occurred at the same scope, presumably file scope.</source>
          <target state="translated">这并不意味着在静态封闭的词法范围内声明的 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 变量将不可见。仅动态范围被切断。例如，下面的 &lt;code&gt;bumpx()&lt;/code&gt; 函数可以访问词法$ x变量，因为 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 都发生在同一作用域（大概是文件作用域）中。</target>
        </trans-unit>
        <trans-unit id="e40a26e5ea83812803ea5b81ef047b1db82eff02" translate="yes" xml:space="preserve">
          <source>This doesn't work if you explicitly specify a loop variable, as in &lt;code&gt;for $item (@array)&lt;/code&gt; . You have to use the default variable &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">如果您显式指定循环变量（如 &lt;code&gt;for $item (@array)&lt;/code&gt; ，则此方法无效。您必须使用默认变量 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2c583421317d67ae6f6464366487994f4149ea1" translate="yes" xml:space="preserve">
          <source>This doesn't work so cleanly for varargs functions, though, as macros imply that the number of arguments is known in advance. Instead we either need to spell them out fully, passing &lt;code&gt;aTHX_&lt;/code&gt; as the first argument (the Perl core tends to do this with functions like Perl_warner), or use a context-free version.</source>
          <target state="translated">但是，这对于varargs函数而言并不是很干净，因为宏暗示着事先知道参数的数量。取而代之的是，我们要么完全拼出它们，将 &lt;code&gt;aTHX_&lt;/code&gt; 作为第一个参数传递（Perl内核倾向于使用Perl_warner之类的函数来做到这一点），或者使用上下文无关的版本。</target>
        </trans-unit>
        <trans-unit id="dd35b5e520e91c0129daf21db3448c07f88b99cf" translate="yes" xml:space="preserve">
          <source>This effect can be demonstrated by setting up a test script with both forms, including a &lt;code&gt;debug()&lt;/code&gt; subroutine to emulate typical &lt;code&gt;logger()&lt;/code&gt; functionality.</source>
          <target state="translated">可以通过设置两种形式的测试脚本 &lt;code&gt;debug()&lt;/code&gt; 包括一个debug（）子例程来模拟典型的 &lt;code&gt;logger()&lt;/code&gt; 功能）来证明这种效果。</target>
        </trans-unit>
        <trans-unit id="fbe2310a8ff7d61c27678f186cd1f8d32e53b8ee" translate="yes" xml:space="preserve">
          <source>This effectively means that your source code behaves as if it were written in UTF-8 with &lt;code&gt;'use utf8&lt;/code&gt; ' in effect. So even if your editor only supports Shift_JIS, for example, you can still try examples in Chapter 15 of &lt;code&gt;Programming Perl, 3rd Ed.&lt;/code&gt;.</source>
          <target state="translated">这实际上意味着您的源代码的行为就像是用UTF-8编写的，并且有效地 &lt;code&gt;'use utf8&lt;/code&gt; 了&amp;ldquo; use utf8 &amp;rdquo;。因此，例如，即使您的编辑器仅支持Shift_JIS，您仍然可以尝试《 &lt;code&gt;Programming Perl, 3rd Ed.&lt;/code&gt; 第15章中的示例。。</target>
        </trans-unit>
        <trans-unit id="f3a80c354b71b0daaada6c4b42d328f1e3ab3798" translate="yes" xml:space="preserve">
          <source>This enables a trace mode and is primarily for debugging bigint or Math::BigInt.</source>
          <target state="translated">这可以启用跟踪模式,主要用于调试bigint或Math::BigInt。</target>
        </trans-unit>
        <trans-unit id="9c02cc31d70507771fd57c515a75adc482efe06a" translate="yes" xml:space="preserve">
          <source>This enables a trace mode and is primarily for debugging bignum or Math::BigInt/Math::BigFloat.</source>
          <target state="translated">这可以启用跟踪模式,主要用于调试bignum或Math::BigInt/Math::BigFloat。</target>
        </trans-unit>
        <trans-unit id="cec63c166c07d8ad2b6a0564923160e4e6afd3a9" translate="yes" xml:space="preserve">
          <source>This enables aliasing via assignment to references:</source>
          <target state="translated">这可以通过对引用的赋值实现别名。</target>
        </trans-unit>
        <trans-unit id="f0c59e41b4a3df893d1d884cf9253595b11ba6fc" translate="yes" xml:space="preserve">
          <source>This enables debugging output when calling commandline utilities to fetch files. This also enables &lt;code&gt;Carp::longmess&lt;/code&gt; errors, instead of the regular &lt;code&gt;carp&lt;/code&gt; errors.</source>
          <target state="translated">这样可以在调用命令行实用程序以提取文件时调试输出。这也启用了 &lt;code&gt;Carp::longmess&lt;/code&gt; 错误，而不是常规的 &lt;code&gt;carp&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="79613693422bd25bf48f5f8810aa0da8bd572cf9" translate="yes" xml:space="preserve">
          <source>This enables declaration of subroutines via &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; sub foo&lt;/code&gt; , &lt;code&gt;state sub foo&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; sub foo&lt;/code&gt; syntax. See &lt;a href=&quot;perlsub#Lexical-Subroutines&quot;&gt;Lexical Subroutines in perlsub&lt;/a&gt; for details.</source>
          <target state="translated">这样可以通过 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; sub foo&lt;/code&gt; ， &lt;code&gt;state sub foo&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; sub foo&lt;/code&gt; 语法声明子程序。有关详细信息，请参见&lt;a href=&quot;perlsub#Lexical-Subroutines&quot;&gt;perlsub中的词法子例程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80e1dcd9c198904d910331965aa69cd1ca8bccf4" translate="yes" xml:space="preserve">
          <source>This enables the programmer to do operations that combine functionalities that are available in the shell.</source>
          <target state="translated">这样,程序员就可以进行结合shell中现有功能的操作。</target>
        </trans-unit>
        <trans-unit id="e90120b49b0763003fb5ddee58d3021476d96c8e" translate="yes" xml:space="preserve">
          <source>This enables unpacking of subroutine arguments into lexical variables by syntax such as</source>
          <target state="translated">这使得子程序的参数可以通过如下语法解包成词汇变量</target>
        </trans-unit>
        <trans-unit id="b1b55e253e92ad7341b5b1784881c341c542cf5a" translate="yes" xml:space="preserve">
          <source>This entry can be used to store a C structure (the number of bytes to be copied is calculated using the C &lt;code&gt;sizeof&lt;/code&gt; function) and can be used as an alternative to T_PTRREF without having to worry about a memory leak (since Perl will clean up the SV).</source>
          <target state="translated">该条目可用于存储C结构（要复制的字节数是使用C &lt;code&gt;sizeof&lt;/code&gt; 函数计算的），并且可以用作T_PTRREF的替代，而不必担心内存泄漏（因为Perl会清理内存SV）。</target>
        </trans-unit>
        <trans-unit id="2f3300c27110c85898913011cf397618813e91ac" translate="yes" xml:space="preserve">
          <source>This environment variable allows the user to specify custom color aliases that will be understood by color(), colored(), and colorvalid(). None of the other functions will be affected, and no new color constants will be created. The custom colors are aliases for existing color names; no new escape sequences can be introduced. Only alphanumerics, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt; , and &lt;code&gt;-&lt;/code&gt; are allowed in alias names.</source>
          <target state="translated">此环境变量允许用户指定将由color（），colored（）和colorvalid（）理解的自定义颜色别名。其他功能均不会受到影响，也不会创建新的颜色常数。自定义颜色是现有颜色名称的别名。无法引入新的转义序列。仅字母数字， &lt;code&gt;.&lt;/code&gt; ， &lt;code&gt;_&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 允许使用别名。</target>
        </trans-unit>
        <trans-unit id="eeb4dcf1cb6c13fe396a4c4857e58d83a3e881a1" translate="yes" xml:space="preserve">
          <source>This environment variable is read and applied when the Term::ANSIColor module is loaded and is then subsequently ignored. Changes to ANSI_COLORS_ALIASES after the module is loaded will have no effect. See coloralias() for an equivalent facility that can be used at runtime.</source>
          <target state="translated">这个环境变量在Term::ANSIColor模块加载时被读取并应用,随后被忽略。在模块加载后对ANSI_COLORS_ALIASES的更改将不会有任何影响。参见coloralias()以获得一个可以在运行时使用的等价设施。</target>
        </trans-unit>
        <trans-unit id="08e7401d917dc7c04b41058352f2e564e79feab2" translate="yes" xml:space="preserve">
          <source>This environment variable, available starting in Perl v5.20, if set (to any value), tells Perl to not use the rest of the environment variables to initialize with. Instead, Perl uses whatever the current locale settings are. This is particularly useful in embedded environments, see &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;Using embedded Perl with POSIX locales in perlembed&lt;/a&gt;.</source>
          <target state="translated">如果将Perl v5.20设置为任何值，则此环境变量可从Perl v5.20开始使用，它告诉Perl不要使用其余的环境变量进行初始化。取而代之的是，Perl使用任何当前的语言环境设置。这在嵌入式环境中特别有用，请参阅&lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;在perlembed中将嵌入式Perl与POSIX语言环境一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01f9c0ecaa03744be9ea320c0c4f588e6b9faad8" translate="yes" xml:space="preserve">
          <source>This evaluates STRING as perl code inside the compartment.</source>
          <target state="translated">这将STRING作为perl代码在车厢内进行评估。</target>
        </trans-unit>
        <trans-unit id="85da3ed8e7eeed1d7664ca9b45804ed926dd64a7" translate="yes" xml:space="preserve">
          <source>This evaluates the contents of file FILENAME inside the compartment. See above documentation on the &lt;b&gt;reval&lt;/b&gt; method for further details.</source>
          <target state="translated">这将评估隔离专区中文件FILENAME的内容。有关更多详细信息，请参见上述有关&lt;b&gt;reval&lt;/b&gt;方法的文档。</target>
        </trans-unit>
        <trans-unit id="c4d1039eeddc372ecb07a9ed65ed3a51b6d6ae64" translate="yes" xml:space="preserve">
          <source>This example added quite a few new concepts. We'll take them one at a time.</source>
          <target state="translated">这个例子增加了不少新概念。我们逐一来看看。</target>
        </trans-unit>
        <trans-unit id="b69f2ecf80918f850deb9506044c7c7d1e270ee4" translate="yes" xml:space="preserve">
          <source>This example does not include any retries and may consequently fail to contact a reachable host. The most prominent reason for this is congestion of the queues on the sending host if the number of hosts to contact is sufficiently large.</source>
          <target state="translated">这个例子不包括任何重试,因此可能无法联系到可到达的主机。最主要的原因是,如果要联系的主机数量足够多,发送主机上的队列就会出现拥堵。</target>
        </trans-unit>
        <trans-unit id="90a572c629dcfb44919f712f7d6b779f25e5dfe2" translate="yes" xml:space="preserve">
          <source>This example is aborted at compile time as we use the attribute &quot;Test&quot; which isn't allowed. &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; returns a list that contains a single element ('Test').</source>
          <target state="translated">此示例在编译时中止，因为我们使用了不允许的属性&amp;ldquo; Test&amp;rdquo;。 &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; 返回包含单个元素的列表（&amp;ldquo;测试&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="f90369b8f8beb64315ed6181cebf6923dd367b56" translate="yes" xml:space="preserve">
          <source>This example is fairly trivial; for more complex cases and a deeper explanation, see the links in the &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; section.</source>
          <target state="translated">这个例子很简单。有关更复杂的情况和更深入的说明，请参见&amp;ldquo;另请&lt;a href=&quot;#SEE-ALSO&quot;&gt;参阅&amp;rdquo;&lt;/a&gt;部分中的链接。</target>
        </trans-unit>
        <trans-unit id="1253f47712d1828f7f774117d0efa3abf09df500" translate="yes" xml:space="preserve">
          <source>This example is fully equivalent with:</source>
          <target state="translated">这个例子完全等同于。</target>
        </trans-unit>
        <trans-unit id="4cd1eae4be0b88a312be5ff0a3c94c909b4f359b" translate="yes" xml:space="preserve">
          <source>This example is preferred over the previous one--even for Unix platforms--because now any &lt;code&gt;\015&lt;/code&gt; 's (&lt;code&gt;\cM&lt;/code&gt; 's) are stripped out (and there was much rejoicing).</source>
          <target state="translated">这个示例比以前的示例更受青睐-即使对于Unix平台-也是如此，因为现在删除了所有 &lt;code&gt;\015&lt;/code&gt; （ &lt;code&gt;\cM&lt;/code&gt; ）（很高兴）。</target>
        </trans-unit>
        <trans-unit id="2155785b4684f8ca5810fa768aca5a675651e726" translate="yes" xml:space="preserve">
          <source>This example prints the mail domain name of the SMTP server known as mailhost:</source>
          <target state="translated">这个例子打印的是名为mailhost的SMTP服务器的邮件域名。</target>
        </trans-unit>
        <trans-unit id="5df3c7e69cf9c030621b9397e847c01645ddee17" translate="yes" xml:space="preserve">
          <source>This example requires the following typemap entry. Consult &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; for more information about adding new typemaps for an extension.</source>
          <target state="translated">本示例需要以下类型映射条目。有关为扩展添加新的类型图的更多信息，请查阅&lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="41a9b74b00161dd5b470ab9ac8171979158c1d90" translate="yes" xml:space="preserve">
          <source>This example runs. At compile time &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; is called. In that subroutine, we check if any attribute is disallowed and we return a list of these &quot;bad attributes&quot;.</source>
          <target state="translated">此示例运行。在编译时，将调用 &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; 。在该子例程中，我们检查是否不允许任何属性，并返回这些&amp;ldquo;不良属性&amp;rdquo;的列表。</target>
        </trans-unit>
        <trans-unit id="8ff407d302a1d7afb3f758e29e8d54e23989741b" translate="yes" xml:space="preserve">
          <source>This example sends a small message to the postmaster at the SMTP server known as mailhost:</source>
          <target state="translated">这个例子在名为mailhost的SMTP服务器上向邮递员发送一个小消息。</target>
        </trans-unit>
        <trans-unit id="78b434a9f3a15806251887966899fdd84de7d2e2" translate="yes" xml:space="preserve">
          <source>This example separates a text into fields which are quote delimited, curly bracketed, and anything else. The delimited and bracketed parts are also blessed to identify them (the &quot;anything else&quot; is unblessed):</source>
          <target state="translated">这个例子将一个文本分为引号分隔的字段、大括号分隔的字段和其他任何字段。分界线和括号内的部分也是有祝福的,以便识别它们(&quot;其他任何东西 &quot;是没有祝福的)。</target>
        </trans-unit>
        <trans-unit id="9dff0d51281eb7bf5e0a018b6b24fe9e35070941" translate="yes" xml:space="preserve">
          <source>This example shows how to create a database, add key/value pairs to the database, delete keys/value pairs and finally how to enumerate the contents of the database.</source>
          <target state="translated">这个例子展示了如何创建数据库、向数据库添加键/值对、删除键/值对以及最后如何枚举数据库的内容。</target>
        </trans-unit>
        <trans-unit id="880ede3f528ae25983090ec0e0156cb403c63af8" translate="yes" xml:space="preserve">
          <source>This example shows rewriting weights. &lt;code&gt;rewrite&lt;/code&gt; is allowed to affect code points, weights, and the name.</source>
          <target state="translated">本示例显示重写权重。允许 &lt;code&gt;rewrite&lt;/code&gt; 以影响代码点，权重和名称。</target>
        </trans-unit>
        <trans-unit id="780bd69540d0ebaeb9c9ed4a226f52e8bf4d6c92" translate="yes" xml:space="preserve">
          <source>This example shows two calls that should have the same effect:</source>
          <target state="translated">这个例子显示了两个应该具有相同效果的调用。</target>
        </trans-unit>
        <trans-unit id="84ff60fe8d031f55c9709b2299fa816e68248930" translate="yes" xml:space="preserve">
          <source>This example takes a regular expression from the argument list and prints the lines of input that match it:</source>
          <target state="translated">这个例子从参数列表中提取一个正则表达式,并打印与之匹配的输入行。</target>
        </trans-unit>
        <trans-unit id="078e5feeaf68f01a2929c0090cee690d8ca945ea" translate="yes" xml:space="preserve">
          <source>This example treats the slightly modified contents of $directory as a hash. The modifications are that the keys</source>
          <target state="translated">这个例子将$directory中稍加修改的内容作为一个哈希处理。修改后的键是</target>
        </trans-unit>
        <trans-unit id="98e05dd997bb9813bf387c2523a2ee3778ba728f" translate="yes" xml:space="preserve">
          <source>This example uses a code expression in a conditional to match a definite article, either 'the' in English or 'der|die|das' in German:</source>
          <target state="translated">这个例子在条件中使用代码表达式来匹配定冠词,可以是英语中的'the',也可以是德语中的'der|die|das'。</target>
        </trans-unit>
        <trans-unit id="c87cae12f1868f49317dcbc2ec2e9d5385ba1820" translate="yes" xml:space="preserve">
          <source>This example will be used with the following Perl statements.</source>
          <target state="translated">这个例子将与以下Perl语句一起使用。</target>
        </trans-unit>
        <trans-unit id="f8787b73d75916a7f7029d06b65a57928067677b" translate="yes" xml:space="preserve">
          <source>This example will fail to recognize that an error occurred inside the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; . Here's why: the call_Subtract code got executed while perl was cleaning up temporaries when exiting the outer braced block, and because call_Subtract is implemented with</source>
          <target state="translated">此示例将无法识别 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 内部发生错误。原因如下：在退出外部支撑块时，perl在清理临时文件时执行了call_Subtract代码，并且因为用</target>
        </trans-unit>
        <trans-unit id="3f78c3b59ae95350e4323c3cb4c7f0dc6fda1338" translate="yes" xml:space="preserve">
          <source>This example works on many platforms that have a shell compatible with Bourne shell:</source>
          <target state="translated">这个例子适用于许多与Bourne shell兼容的平台。</target>
        </trans-unit>
        <trans-unit id="15d5f8da3c8eb09a121cb765eeca738ccef36a74" translate="yes" xml:space="preserve">
          <source>This experimental attribute, introduced in Perl 5.22, only applies to anonymous subroutines. It causes the subroutine to be called as soon as the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; expression is evaluated. The return value is captured and turned into a constant subroutine.</source>
          <target state="translated">Perl 5.22中引入的该实验属性仅适用于匿名子例程。它使子例程在计算 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 表达式后立即被调用。捕获返回值并将其转换为常量子例程。</target>
        </trans-unit>
        <trans-unit id="c659fee685d6111f5eef41a4fc47f104c94d024f" translate="yes" xml:space="preserve">
          <source>This expression is actually equivalent to &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt; , due to the higher precedence of &lt;code&gt;==&lt;/code&gt; . This is probably not what you want. (If you really meant to write this, disable the warning, or, better, put the parentheses explicitly and write &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt; ).</source>
          <target state="translated">由于 &lt;code&gt;==&lt;/code&gt; 的优先级较高，因此该表达式实际上等效于 &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt; 。这可能不是您想要的。（如果确实要编写此代码，请禁用警告，或者更好的方法是，将括号显式地写入 &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3d95c2dd6bdf3facfce8eb7c29c42e8682159b3f" translate="yes" xml:space="preserve">
          <source>This extension is somewhat contrived. It is based on the code in the previous example. It calls the statfs function multiple times, accepting a reference to an array of filenames as input, and returning a reference to an array of hashes containing the data for each of the filesystems.</source>
          <target state="translated">这个扩展有些造作。它是基于前面例子中的代码。它多次调用 statfs 函数,接受一个文件名数组的引用作为输入,并返回一个包含每个文件系统数据的哈希数组的引用。</target>
        </trans-unit>
        <trans-unit id="443c1ad31c99bd2962c1e14f9f6e565d7abce59c" translate="yes" xml:space="preserve">
          <source>This extension is very Unix-oriented (struct statfs and the statfs system call). If you are not running on a Unix system, you can substitute for statfs any other function that returns multiple values, you can hard-code values to be returned to the caller (although this will be a bit harder to test the error case), or you can simply not do this example. If you change the XSUB, be sure to fix the test cases to match the changes.</source>
          <target state="translated">这个扩展是非常面向Unix的(struct statfs和statfs系统调用)。如果你不是在Unix系统上运行,你可以用其他任何返回多个值的函数来代替statfs,你可以硬编码返回给调用者的值(尽管这对测试错误情况会有点困难),或者你可以干脆不做这个例子。如果你改变了XSUB,一定要修正测试用例,使之符合变化。</target>
        </trans-unit>
        <trans-unit id="31882b218e30926e9578b39c27a5a21498d0f3ba" translate="yes" xml:space="preserve">
          <source>This fails because the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; makes STDERR go to where STDOUT was going at the time of the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;. The backticks then make STDOUT go to a string, but don't change STDERR (which still goes to the old STDOUT).</source>
          <target state="translated">失败的原因是 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 让STDERR转至STDOUT原本打算在家的时间 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 。然后，反引号使STDOUT转到字符串，但不要更改STDERR（仍将其转到旧的STDOUT）。</target>
        </trans-unit>
        <trans-unit id="31d57b0a4260007b8d7df0d0cf0818de49b401fd" translate="yes" xml:space="preserve">
          <source>This failure does not seem to cause any problems. With older gcc versions, &quot;parse error&quot; is reported instead of &quot;missing binary operator&quot;.</source>
          <target state="translated">这个故障似乎没有引起任何问题。在旧版本的gcc中,报告的是 &quot;parse error &quot;而不是 &quot;missing binary operator&quot;。</target>
        </trans-unit>
        <trans-unit id="7e96692d6e8677f9247e8d718c35a2f5314dd78a" translate="yes" xml:space="preserve">
          <source>This feature (introduced in Perl 5.10) significantly extends the power of Perl's pattern matching. By referring to some other capture group anywhere in the pattern with the construct &lt;code&gt;(?group-ref)&lt;/code&gt;, the</source>
          <target state="translated">此功能（在Perl 5.10中引入）大大扩展了Perl模式匹配的功能。通过使用构造 &lt;code&gt;(?group-ref)&lt;/code&gt; 在模式中的任何地方引用其他捕获组，</target>
        </trans-unit>
        <trans-unit id="39313d94f9ceb03c0da32836d49794a646f76b32" translate="yes" xml:space="preserve">
          <source>This feature allows code like this to work :</source>
          <target state="translated">这个功能可以让这样的代码工作。</target>
        </trans-unit>
        <trans-unit id="d279f2466dab661314717405c1c291df785e033f" translate="yes" xml:space="preserve">
          <source>This feature hasn't been tested with multiple threads, but it will only show the backtrace of the thread doing the backtracing.</source>
          <target state="translated">这个功能还没有经过多线程的测试,但它只会显示做回溯的线程的回溯。</target>
        </trans-unit>
        <trans-unit id="3f31330eeb1eb16a4131ea44941bd450e02ba159" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.16 onwards.</source>
          <target state="translated">这个功能从Perl 5.16开始就有了。</target>
        </trans-unit>
        <trans-unit id="a0eb6c955c276bb211d5f6e97040a35b64f681c9" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.18 onwards.</source>
          <target state="translated">这个功能从Perl 5.18开始就有了。</target>
        </trans-unit>
        <trans-unit id="5350c7db9e5ccded478eeb543bf7a26b7856c3e9" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.20 onwards.</source>
          <target state="translated">这个功能从Perl 5.20开始就有了。</target>
        </trans-unit>
        <trans-unit id="d594f14a3251cf1780c8a95d14833fb1764cbcb5" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.22 onwards.</source>
          <target state="translated">这个功能从Perl 5.22开始就有了。</target>
        </trans-unit>
        <trans-unit id="cdd060361bef60c9e8d128e54b15bdf49a0df3f0" translate="yes" xml:space="preserve">
          <source>This feature is available starting with Perl 5.10.</source>
          <target state="translated">这个功能从Perl 5.10开始提供。</target>
        </trans-unit>
        <trans-unit id="f16229bb3e38370fa369bac03ef842b45e6ac174" translate="yes" xml:space="preserve">
          <source>This feature is available starting with Perl 5.12; was almost fully implemented in Perl 5.14; and extended in Perl 5.16 to cover &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从Perl 5.12开始可以使用此功能。在Perl 5.14中几乎完全实现；在Perl 5.16中进行了扩展，以涵盖 &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3fa1f4ec8b7292a36ec1d671af80c0ba1c4dbf6" translate="yes" xml:space="preserve">
          <source>This feature is available starting with Perl 5.16.</source>
          <target state="translated">这个功能从Perl 5.16开始提供。</target>
        </trans-unit>
        <trans-unit id="4cf7997500a8320557eaa4d36e75775cc5a5b761" translate="yes" xml:space="preserve">
          <source>This feature is available under this name starting with Perl 5.16. In previous versions, it was simply on all the time, and this pragma knew nothing about it.</source>
          <target state="translated">从Perl 5.16开始,这个功能就以这个名字出现了。在以前的版本中,它只是一直处于开启状态,而这个pragma对它一无所知。</target>
        </trans-unit>
        <trans-unit id="b957d6504ae997d3a3efef291b5e1aad2b736b3a" translate="yes" xml:space="preserve">
          <source>This feature is enabled by 'importing' the non-existent symbol 'verbose'. You would typically enable it by saying</source>
          <target state="translated">这个功能是通过 &quot;导入 &quot;不存在的符号 &quot;verbose &quot;来启用的。通常您可以通过以下方式启用它</target>
        </trans-unit>
        <trans-unit id="02d76db5faed0f26a8be3e80c39fd86b2f9e9ac8" translate="yes" xml:space="preserve">
          <source>This feature is implemented as a new op type, &lt;code&gt;OP_CUSTOM&lt;/code&gt; . The Perl core does not &quot;know&quot; anything special about this op type, and so it will not be involved in any optimizations. This also means that you can define your custom ops to be any op structure -- unary, binary, list and so on -- you like.</source>
          <target state="translated">此功能实现为新的op类型 &lt;code&gt;OP_CUSTOM&lt;/code&gt; 。Perl内核不&amp;ldquo;知道&amp;rdquo;关于此op类型的任何特殊信息，因此它不会参与任何优化。这也意味着您可以将自定义操作定义为您喜欢的任何操作结构-一元，二进制，列表等。</target>
        </trans-unit>
        <trans-unit id="d3d9a13d27e32567256bd5ed07966300b2843571" translate="yes" xml:space="preserve">
          <source>This feature is useful when processing a file format that encapsulates a compressed data stream (e.g. gzip, zip) and there is useful data immediately after the deflation stream.</source>
          <target state="translated">当处理封装压缩数据流(如gzip、zip)的文件格式时,这个功能很有用,而且在放气流之后立即有有用的数据。</target>
        </trans-unit>
        <trans-unit id="70ff4f5cd1e98da8a085f691d09087dfafce10bc" translate="yes" xml:space="preserve">
          <source>This feature is useful when processing a file format that encapsulates a compressed data stream (e.g. gzip, zip).</source>
          <target state="translated">该功能在处理封装压缩数据流的文件格式(如gzip、zip)时非常有用。</target>
        </trans-unit>
        <trans-unit id="e4da939b7443e26e164efdaa4d6f81b9bc175434" translate="yes" xml:space="preserve">
          <source>This feature requires configuration option &lt;b&gt;permute&lt;/b&gt;, see section &lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;Configuring Getopt::Long&lt;/a&gt;.</source>
          <target state="translated">此功能需要配置选项&lt;b&gt;permute&lt;/b&gt;，请参阅&amp;ldquo; &lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;配置Getopt :: Long&amp;rdquo;部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b84829a17ad80817afc9eefb1b49f97bfdfe8fac" translate="yes" xml:space="preserve">
          <source>This feature supports the legacy &lt;code&gt;$[&lt;/code&gt; variable. See &lt;a href=&quot;perlvar#%24%5b&quot;&gt;$[ in perlvar&lt;/a&gt; and &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;. It is on by default but disabled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; (see &lt;a href=&quot;#IMPLICIT-LOADING&quot;&gt;IMPLICIT LOADING&lt;/a&gt;, below).</source>
          <target state="translated">此功能支持旧版 &lt;code&gt;$[&lt;/code&gt; 变量。请参阅&lt;a href=&quot;perlvar#%24%5b&quot;&gt;$ [在perlvar&lt;/a&gt;和&lt;a href=&quot;arybase&quot;&gt;arybase中&lt;/a&gt;。它默认情况下处于启用状态，但在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 禁用（请参见下面的&amp;ldquo; 隐式&lt;a href=&quot;#IMPLICIT-LOADING&quot;&gt;加载&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ccaa07991a8c1bc153311bc6ab0dcadf92aec838" translate="yes" xml:space="preserve">
          <source>This feature, available starting in v5.12, matches any character that is &lt;b&gt;not&lt;/b&gt; a newline. It is a short-hand for writing &lt;code&gt;[^\n]&lt;/code&gt;, and is identical to the &lt;code&gt;.&lt;/code&gt; metasymbol, except under the &lt;code&gt;/s&lt;/code&gt; flag, which changes the meaning of &lt;code&gt;.&lt;/code&gt;, but not &lt;code&gt;\N&lt;/code&gt; .</source>
          <target state="translated">此功能从v5.12开始可用，它匹配&lt;b&gt;不是&lt;/b&gt;换行符的任何字符。它是写 &lt;code&gt;[^\n]&lt;/code&gt; 的简写，与相同 &lt;code&gt;.&lt;/code&gt; 元符号，但 &lt;code&gt;/s&lt;/code&gt; 标志下的符号会更改的含义 &lt;code&gt;.&lt;/code&gt; ，但不是 &lt;code&gt;\N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86eab6101dbb39be1f4756f21ad94b3dc3f5b53a" translate="yes" xml:space="preserve">
          <source>This field defaults to the time the &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; object was created if this option is not specified.</source>
          <target state="translated">如果未指定此选项，则此字段默认为创建 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 对象的时间。</target>
        </trans-unit>
        <trans-unit id="0ae6e594e4f58006926409640dc519990e005708" translate="yes" xml:space="preserve">
          <source>This field defaults to the time the &lt;code&gt;IO::Compress::Zip&lt;/code&gt; object was created if this option is not specified and the &lt;code&gt;$input&lt;/code&gt; parameter is not a filename.</source>
          <target state="translated">如果未指定此选项并且 &lt;code&gt;$input&lt;/code&gt; 参数不是文件名，则该字段默认为创建 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 对象的时间。</target>
        </trans-unit>
        <trans-unit id="e1736869f31835444fcd2554056bb1bdc04ff6bd" translate="yes" xml:space="preserve">
          <source>This field points at a &lt;code&gt;reg_data&lt;/code&gt; structure, which is defined as follows</source>
          <target state="translated">该字段指向 &lt;code&gt;reg_data&lt;/code&gt; 结构，其定义如下</target>
        </trans-unit>
        <trans-unit id="990821d4ec37cddf0c064311fa9c677b83df34b2" translate="yes" xml:space="preserve">
          <source>This field points at a &lt;code&gt;regexp_engine&lt;/code&gt; structure which contains pointers to the subroutines that are to be used for performing a match. It is the compiling routine's responsibility to populate this field before returning the regexp object.</source>
          <target state="translated">该字段指向 &lt;code&gt;regexp_engine&lt;/code&gt; 结构，该结构包含用于执行匹配的子例程的指针。在返回regexp对象之前，填充此字段是编译例程的职责。</target>
        </trans-unit>
        <trans-unit id="423f1e020ff559262836a01099aa9f00246b3cb0" translate="yes" xml:space="preserve">
          <source>This file contains instructions how to build Perl for Haiku and lists known problems.</source>
          <target state="translated">这个文件包含了如何构建Perl for Haiku的说明,并列出了已知的问题。</target>
        </trans-unit>
        <trans-unit id="16e77d17e03a82d35fe5f118c6d17cc03a2f5d43" translate="yes" xml:space="preserve">
          <source>This file contains notes for building perl on the Stratus OpenVOS operating system. Perl is a scripting or macro language that is popular on many systems. See &lt;a href=&quot;perlbook&quot;&gt;perlbook&lt;/a&gt; for a number of good books on Perl.</source>
          <target state="translated">该文件包含在Stratus OpenVOS操作系统上构建perl的说明。Perl是一种脚本或宏语言，在许多系统上都很流行。有关&lt;a href=&quot;perlbook&quot;&gt;Perl&lt;/a&gt;的许多优秀书籍，请参见perlbook。</target>
        </trans-unit>
        <trans-unit id="1b8ecba533b9b274e408d86f1a2361d08ce45153" translate="yes" xml:space="preserve">
          <source>This file contains the documentation of the perl public API generated by</source>
          <target state="translated">这个文件包含了由下列文件生成的perl公共API的文档。</target>
        </trans-unit>
        <trans-unit id="772ef66d2f091024ffe5331d4173bb5adc436597" translate="yes" xml:space="preserve">
          <source>This file gives instructions for building Perl 5.7 and above, and also Perl modules for NetWare. Before you start, you may want to read the README file found in the top level directory into which the Perl source code distribution was extracted. Make sure you read and understand the terms under which the software is being distributed.</source>
          <target state="translated">这个文件给出了构建Perl 5.7及以上版本的说明,以及NetWare的Perl模块。在您开始之前,您可能需要阅读在解压 Perl 源代码发行版的顶层目录中找到的 README 文件。确保你阅读并理解软件发布的条款。</target>
        </trans-unit>
        <trans-unit id="6ec203908c78957c98ea92f12965f186f5810be8" translate="yes" xml:space="preserve">
          <source>This file gives the instructions for building Perl5.8 and above for WinCE. Please read and understand the terms under which this software is distributed.</source>
          <target state="translated">本文件给出了为WinCE构建Perl5.8及以上版本的说明。请阅读并理解本软件的发布条款。</target>
        </trans-unit>
        <trans-unit id="cf6acf338e7fac3c001977fe9f2038807c39d850" translate="yes" xml:space="preserve">
          <source>This file is the autogenerated documentation of functions in the Perl interpreter that are documented using Perl's internal documentation format but are not marked as part of the Perl API. In other words, &lt;b&gt;they are not for use in extensions&lt;/b&gt;!</source>
          <target state="translated">该文件是Perl解释器中功能的自动生成的文档，这些文档是使用Perl的内部文档格式记录的，但未标记为Perl API的一部分。换句话说，&lt;b&gt;它们不用于扩展&lt;/b&gt;！</target>
        </trans-unit>
        <trans-unit id="37bc1fa4735275726caf451da3d6c18e093591a1" translate="yes" xml:space="preserve">
          <source>This file lists everyone who's contributed to Perl. If you submit a patch, you should add your name to this file as part of the patch.</source>
          <target state="translated">这个文件列出了所有对 Perl 有贡献的人。如果你提交了一个补丁,你应该把你的名字作为补丁的一部分加入到这个文件中。</target>
        </trans-unit>
        <trans-unit id="bfb66abe74ae898df9c2dbe0e11c53cf1576bcaf" translate="yes" xml:space="preserve">
          <source>This file resides somewhere deep in the location you installed your perl library, find it out by</source>
          <target state="translated">这个文件位于你安装perl库的某个深处,通过以下方法找到它</target>
        </trans-unit>
        <trans-unit id="6cb5bba8cb2fb8c111c0a512a6843cebdb2655ae" translate="yes" xml:space="preserve">
          <source>This file will get parsed, and produce a maybe empty &lt;code&gt;@DynaLoader::dl_resolve_using&lt;/code&gt; array for the current architecture. That will be extended by $BSLOADLIBS, which was computed by ExtUtils::Liblist::ext(). If this array still is empty, we do nothing, else we write a .bs file with an &lt;code&gt;@DynaLoader::dl_resolve_using&lt;/code&gt; array.</source>
          <target state="translated">该文件将被解析，并为当前体系结构生成一个可能为空的 &lt;code&gt;@DynaLoader::dl_resolve_using&lt;/code&gt; 数组。这将由$ BSLOADLIBS扩展，该扩展由ExtUtils :: Liblist :: ext（）计算。如果该数组仍然为空，则不执行任何操作，否则我们将使用 &lt;code&gt;@DynaLoader::dl_resolve_using&lt;/code&gt; 数组编写一个.bs文件。</target>
        </trans-unit>
        <trans-unit id="77507ae6fec16ecb1a49a0d13053514b63919993" translate="yes" xml:space="preserve">
          <source>This filter ensures that all data written to the DBM file is null terminated. This is useful when you have a perl script that needs to interoperate with a DBM file that a C program also uses. A fairly common issue is for the C application to include the terminating null in a string when it writes to the DBM file. This filter will ensure that all data written to the DBM file can be read by the C application.</source>
          <target state="translated">这个过滤器确保所有写入DBM文件的数据都是空结束的。当你有一个perl脚本需要与一个C程序也使用的DBM文件进行交互时,这个过滤器就很有用。一个相当常见的问题是,当C程序向DBM文件写入数据时,会在一个字符串中包含终止的null。这个过滤器将确保所有写入DBM文件的数据可以被C程序读取。</target>
        </trans-unit>
        <trans-unit id="1a16c760c71ffbcc7dbae1135b5e99738b98c9c4" translate="yes" xml:space="preserve">
          <source>This filter will compress all data before it is written to the database and uncompressed it on reading.</source>
          <target state="translated">这个过滤器会在数据写入数据库之前压缩所有数据,并在读取时解压。</target>
        </trans-unit>
        <trans-unit id="ff45bc95d2be91a9f62c2d432c6510d29da26205" translate="yes" xml:space="preserve">
          <source>This final example contains both ordinary and pattern code expressions. It detects whether a binary string &lt;code&gt;1101010010001...&lt;/code&gt; has a Fibonacci spacing 0,1,1,2,3,5,... of the &lt;code&gt;1&lt;/code&gt; 's:</source>
          <target state="translated">最后一个示例包含普通代码和模式代码表达式。它检测二进制字符串 &lt;code&gt;1101010010001...&lt;/code&gt; 的斐波那契间距是否为 &lt;code&gt;1&lt;/code&gt; 的0,1,1,2,3,5，... ：</target>
        </trans-unit>
        <trans-unit id="4dfd467bd9194695ec17711b8f65393c531e176b" translate="yes" xml:space="preserve">
          <source>This finishes implementation of a primitive symbolic calculator in 50 lines of Perl code. Since the numeric values of subexpressions are not cached, the calculator is very slow.</source>
          <target state="translated">这就用50行Perl代码完成了一个原始符号计算器的实现。由于子表达式的数值没有被缓存,所以计算器的速度非常慢。</target>
        </trans-unit>
        <trans-unit id="432b2214978806677872de825506327a25e6c8da" translate="yes" xml:space="preserve">
          <source>This first trivial example will call a Perl subroutine,</source>
          <target state="translated">这第一个琐碎的例子将调用一个Perl子程序。</target>
        </trans-unit>
        <trans-unit id="7a73aefe087a5a3cae31e7663f998536b4f2db63" translate="yes" xml:space="preserve">
          <source>This flag has 2 effects:</source>
          <target state="translated">这个旗子有2个效果。</target>
        </trans-unit>
        <trans-unit id="caa34b07e62e9949dde06d4f7ad8cedfd3b7de3f" translate="yes" xml:space="preserve">
          <source>This flag has an important effect on Perl's treatment of the string: if UTF-8 data is not properly distinguished, regular expressions, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; and other string handling operations will have undesirable (wrong) results.</source>
          <target state="translated">此标志对Perl的字符串处理有重要影响：如果未正确区分UTF-8数据，则正则表达式， &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; 和其他字符串处理操作将产生不良（错误）结果。</target>
        </trans-unit>
        <trans-unit id="a176da4e70ce1acc6541f9df33982a6b757fc468" translate="yes" xml:space="preserve">
          <source>This flag is set to true if the API is tracing through subroutine calls.</source>
          <target state="translated">如果API通过子程序调用进行跟踪,则该标志被设置为true。</target>
        </trans-unit>
        <trans-unit id="201e9afdfb172b15efef161ffd6b8fd219c793ac" translate="yes" xml:space="preserve">
          <source>This flag is supported in Sun WorkShop Compilers 5.0 and onwards (now marketed under the name Forte) when used on Solaris 7 or later on UltraSparc systems.</source>
          <target state="translated">当在Solaris 7或更高版本的UltraSparc系统上使用时,Sun WorkShop Compilers 5.0及以后的版本(现在以Forte的名称销售)支持该标志。</target>
        </trans-unit>
        <trans-unit id="b160cdb384c536dc3f048d4a9c7c790cc3b24bae" translate="yes" xml:space="preserve">
          <source>This flag tells Perl to interpret the supplied string as a vector of integers, one for each character in the string. Perl applies the format to each integer in turn, then joins the resulting strings with a separator (a dot &lt;code&gt;.&lt;/code&gt; by default). This can be useful for displaying ordinal values of characters in arbitrary strings:</source>
          <target state="translated">此标志告诉Perl将提供的字符串解释为整数向量，该整数表示字符串中的每个字符。Perl依次将格式应用于每个整数，然后使用分隔符（默认为点 &lt;code&gt;.&lt;/code&gt; ）连接结果字符串。这对于显示任意字符串中字符的有序值很有用：</target>
        </trans-unit>
        <trans-unit id="f881a1e5bd78a37c63f807e7bc9fe5e3e92898af" translate="yes" xml:space="preserve">
          <source>This flag was removed in perl 5.18.0. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; is now special-cased solely in the parser. RXf_SPLIT is still #defined, so you can test for it. This is how it used to work:</source>
          <target state="translated">此标志已在perl 5.18.0中删除。现在，仅在解析器中对 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; 进行了特殊区分。RXf_SPLIT仍然是#defined，因此您可以对其进行测试。这是它过去的工作方式：</target>
        </trans-unit>
        <trans-unit id="d833b586ef20499906978002bb10914b6b58edd4" translate="yes" xml:space="preserve">
          <source>This flag was removed in perl 5.18.0. It is still #defined, so you can set it, but doing so will have no effect. This is how it used to work:</source>
          <target state="translated">这个标志在perl 5.18.0中被移除。它仍然是#defined的,所以你可以设置它,但这样做不会有任何效果。这就是以前的工作方式。</target>
        </trans-unit>
        <trans-unit id="dc95d1efdd1713c3cca7c0b3c4bdefdda1fde08a" translate="yes" xml:space="preserve">
          <source>This flag, if given, suppresses the URL when anchor text is given, so this example would be formatted as just &lt;code&gt;foo&lt;/code&gt; . This can produce less cluttered output in cases where the URLs are not particularly important.</source>
          <target state="translated">如果提供此标志，则在提供锚文本时将禁止显示URL，因此此示例的格式将仅为 &lt;code&gt;foo&lt;/code&gt; 。在URL不是特别重要的情况下，这可以减少混乱的输出。</target>
        </trans-unit>
        <trans-unit id="c0dbb07c9842c891feb553c44a3898bc7209b8ed" translate="yes" xml:space="preserve">
          <source>This flag, used in the length slot of hash entries and magic structures, specifies the structure contains an &lt;code&gt;SV*&lt;/code&gt; pointer where a &lt;code&gt;char*&lt;/code&gt; pointer is to be expected. (For information only--not to be used).</source>
          <target state="translated">该标志用在哈希条目和魔术结构的长度槽中，用于指定包含 &lt;code&gt;SV*&lt;/code&gt; 指针的结构，在该指针中应有 &lt;code&gt;char*&lt;/code&gt; 指针。（仅供参考，请勿使用）。</target>
        </trans-unit>
        <trans-unit id="bbab49144d33f97cf4910c662167d2afe655dc3e" translate="yes" xml:space="preserve">
          <source>This forces the &lt;code&gt;AUTOLOAD&lt;/code&gt; for &lt;code&gt;SO_LINGER&lt;/code&gt; to take place before SO_LINGER is encountered later in &lt;code&gt;My&lt;/code&gt; package.</source>
          <target state="translated">这迫使 &lt;code&gt;AUTOLOAD&lt;/code&gt; 为 &lt;code&gt;SO_LINGER&lt;/code&gt; SO_LINGER在以后遇到之前进行 &lt;code&gt;My&lt;/code&gt; 包。</target>
        </trans-unit>
        <trans-unit id="b15b4ab4a7170566f869487aafa326bf0ce9445d" translate="yes" xml:space="preserve">
          <source>This forces the short and the long members to be little-endian, and is just fine if you don't have too many struct members. But we could also use the byte-order modifier on a group and write the following:</source>
          <target state="translated">这样就强制短成员和长成员都是小字节的,如果你的结构成员不多的话,就可以了。但我们也可以在一个组上使用字节序修饰符,并写出以下内容。</target>
        </trans-unit>
        <trans-unit id="40f05df3e2fa93dbc3244d6e8aa705438a4243e3" translate="yes" xml:space="preserve">
          <source>This form of the pragma allows essentially seamless handling of locales with Unicode. The collation order will be by Unicode code point order. It is strongly recommended that when you need to order and sort strings that you use the standard module &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; which gives much better results in many instances than you can get with the old-style locale handling.</source>
          <target state="translated">这种编译指示形式允许使用Unicode无缝地处理语言环境。整理顺序将按Unicode代码点顺序进行。强烈建议您在需要对字符串进行排序和排序时，使用标准模块&lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;，它在许多实例中提供的效果比旧式语言环境处理要好得多。</target>
        </trans-unit>
        <trans-unit id="cdc9f2e82b133c2773ec210a8571ca6b553d5115" translate="yes" xml:space="preserve">
          <source>This formality is needed when properties are not binary; that is, if they can take on more values than just &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt; . For example, the &lt;code&gt;Bidi_Class&lt;/code&gt; property (see &lt;a href=&quot;#Bidirectional-Character-Types&quot;&gt;Bidirectional Character Types&lt;/a&gt; below), can take on several different values, such as &lt;code&gt;Left&lt;/code&gt; , &lt;code&gt;Right&lt;/code&gt; , &lt;code&gt;Whitespace&lt;/code&gt; , and others. To match these, one needs to specify both the property name (&lt;code&gt;Bidi_Class&lt;/code&gt; ), AND the value being matched against (&lt;code&gt;Left&lt;/code&gt; , &lt;code&gt;Right&lt;/code&gt; ,</source>
          <target state="translated">如果属性不是二进制的，则需要这种形式。也就是说，如果它们可以接受的值不仅仅是 &lt;code&gt;True&lt;/code&gt; 和 &lt;code&gt;False&lt;/code&gt; 。例如， &lt;code&gt;Bidi_Class&lt;/code&gt; 属性（请参见下面的&lt;a href=&quot;#Bidirectional-Character-Types&quot;&gt;双向字符类型&lt;/a&gt;）可以采用几个不同的值，例如 &lt;code&gt;Left&lt;/code&gt; ， &lt;code&gt;Right&lt;/code&gt; ， &lt;code&gt;Whitespace&lt;/code&gt; 和其他。要匹配这些属性，需要同时指定属性名称（ &lt;code&gt;Bidi_Class&lt;/code&gt; ）和要与之匹配的值（ &lt;code&gt;Left&lt;/code&gt; ， &lt;code&gt;Right&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="e6b05c6c31caa81ea454aca24f6c1d1188903888" translate="yes" xml:space="preserve">
          <source>This formatting code is syntactically simple, but semantically complex. What it means is that each space in the printable content of this code signifies a non-breaking space.</source>
          <target state="translated">这个格式代码在语法上很简单,但在语义上很复杂。它的意思是,在该代码的可打印内容中,每一个空格都表示一个非断开的空格。</target>
        </trans-unit>
        <trans-unit id="d77c232922b63b050101d5932a616e0ed5728461" translate="yes" xml:space="preserve">
          <source>This free toolkit contains the same compiler and linker that ship with Visual C++ .NET 2003 Professional, but doesn't contain everything necessary to build Perl.</source>
          <target state="translated">这个免费的工具包包含了和Visual C++.NET 2003 Professional一样的编译器和链接器,但并不包含构建Perl所需的一切。</target>
        </trans-unit>
        <trans-unit id="5c5a6423b0a65bc38b33d48cf33a85a24bf291a8" translate="yes" xml:space="preserve">
          <source>This free version of Visual C++ 2005 Professional contains the same compiler and linker that ship with the full version, but doesn't contain everything necessary to build Perl.</source>
          <target state="translated">这个免费版的Visual C++2005 Professional包含与完整版相同的编译器和链接器,但并不包含构建Perl所需的一切。</target>
        </trans-unit>
        <trans-unit id="eb31e64d6cc8d22ff5f69477b5a67be71c8242ad" translate="yes" xml:space="preserve">
          <source>This function (not exported) lets you reset the sequence numbers (note that they're numbered arbitrarily, their goal being to be human readable). Its purpose is mostly to support testing, i.e. to compare the concise output from two identical anonymous subroutines (but different instances). Without the reset, B::Concise, seeing that they're separate optrees, generates different sequence numbers in the output.</source>
          <target state="translated">这个函数(没有导出)可以让你重置序列号(注意,它们的编号是任意的,其目的是为了让人可以读懂)。它的目的主要是为了支持测试,即比较两个相同的匿名子程序(但实例不同)的简洁输出。如果没有复位,B::Concise看到它们是独立的optrees,就会在输出中产生不同的序列号。</target>
        </trans-unit>
        <trans-unit id="1f57c1588a54710c722f648f2f8000721f89bfc3" translate="yes" xml:space="preserve">
          <source>This function accepts any UV as input. To forbid or warn on non-Unicode code points, or those that may be problematic, see &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;.</source>
          <target state="translated">此功能接受任何紫外线作为输入。要禁止或警告非Unicode代码点或可能存在问题的代码点，请参见&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bcc1cbc95f41c6ca77822a286a66032b96a97b23" translate="yes" xml:space="preserve">
          <source>This function accepts two arguments, adds them, and prints their sum. Its return value is the numuber of characters it printed, but you probably didn't care about that. But &lt;code&gt;Memoize&lt;/code&gt; doesn't understand that. If you memoize this function, you will get the result you expect the first time you ask it to print the sum of 2 and 3, but subsequent calls will return 1 (the return value of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;) without actually printing anything.</source>
          <target state="translated">此函数接受两个参数，将它们相加并打印它们的总和。它的返回值是它打印的字符数，但您可能并不在意。但是 &lt;code&gt;Memoize&lt;/code&gt; 对此并不了解。如果记住该功能，则在第一次要求它打印2和3的总和时会得到期望的结果，但是随后的调用将返回1（ &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 的返回值），而实际上不打印任何内容。</target>
        </trans-unit>
        <trans-unit id="cb8ff2980a7098008fca7a80ae815b328b64b56a" translate="yes" xml:space="preserve">
          <source>This function adheres to the POSIX syntax for command line options, with GNU extensions. In general, this means that options have long names instead of single letters, and are introduced with a double dash &quot;--&quot;. Support for bundling of command line options, as was the case with the more traditional single-letter approach, is provided but not enabled by default.</source>
          <target state="translated">这个函数遵循POSIX命令行选项的语法,并有GNU的扩展。一般来说,这意味着选项的名称是长的,而不是单字母,并且用双破折号&quot;--&quot;引入。提供了对命令行选项捆绑的支持,就像传统的单字母方法一样,但默认情况下没有启用。</target>
        </trans-unit>
        <trans-unit id="7b0b646247c6327383124f41d35ef99ac00aaf8b" translate="yes" xml:space="preserve">
          <source>This function assigns the prototype of the named core function to &lt;code&gt;sv&lt;/code&gt; , or to a new mortal SV if &lt;code&gt;sv&lt;/code&gt; is NULL. It returns the modified &lt;code&gt;sv&lt;/code&gt; , or NULL if the core function has no prototype. &lt;code&gt;code&lt;/code&gt; is a code as returned by &lt;code&gt;keyword()&lt;/code&gt; . It must not be equal to 0.</source>
          <target state="translated">该函数将命名核心函数的原型分配给 &lt;code&gt;sv&lt;/code&gt; ，如果 &lt;code&gt;sv&lt;/code&gt; 为NULL 则分配给新的凡人SV 。它返回修改后的 &lt;code&gt;sv&lt;/code&gt; ，如果核心函数没有原型，则返回NULL。 &lt;code&gt;code&lt;/code&gt; 是由 &lt;code&gt;keyword()&lt;/code&gt; 返回的代码。它不能等于0。</target>
        </trans-unit>
        <trans-unit id="14c8f38efd4e3476b651d12afb352ad397950bd5" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragma, such as in a locale, as &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; does.</source>
          <target state="translated">此功能在各种编译指示下（例如在语言环境中）的行为与&lt;a href=&quot;#lc&quot;&gt;lc相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8378e0b6c78c094cc27c1f818ab7aa1e8291a68d" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragma, such as in a locale, as &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; does.</source>
          <target state="translated">此功能在各种编译指示下（例如在语言环境中）的行为与&lt;a href=&quot;lc&quot;&gt;lc相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bdf27edd1f3ed7033638bb2d9262acb5626e2202" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragma, such as within &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; , as &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; does, with the single exception of &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; of LATIN CAPITAL LETTER SHARP S (U+1E9E) within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . The foldcase of this character would normally be &lt;code&gt;&quot;ss&quot;&lt;/code&gt; , but as explained in the &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; section, case changes that cross the 255/256 boundary are problematic under locales, and are hence prohibited. Therefore, this function under locale returns instead the string &lt;code&gt;&quot;\x{17F}\x{17F}&quot;&lt;/code&gt; , which is the LATIN SMALL LETTER LONG S. Since that character itself folds to &lt;code&gt;&quot;s&quot;&lt;/code&gt; , the string of two of them together should be equivalent to a single U+1E9E when foldcased.</source>
          <target state="translated">此函数的行为下的各种编译指示，诸如内以相同的方式 &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; ，如&lt;a href=&quot;#lc&quot;&gt;LC&lt;/a&gt;确实，与唯一例外 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; LATIN CAPITAL LETTER SHARP S（U + 1E9E）的范围内 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 。该字符的折号通常为 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; ，但是如&lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt;部分所述，跨越255/256边界的大小写更改在区域设置中是有问题的，因此被禁止。因此，该语言环境下的函数将返回字符串 &lt;code&gt;&quot;\x{17F}\x{17F}&quot;&lt;/code&gt; ，这是拉丁文的小写字母LONGS。由于该字符本身会折叠为 &lt;code&gt;&quot;s&quot;&lt;/code&gt; ，将它们中的两个一起折叠时的字符串应等效于单个U + 1E9E。</target>
        </trans-unit>
        <trans-unit id="ceceba872ecbef53671fa2bb946f4d1ad71c1d4b" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragma, such as within &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; , as &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; does, with the single exception of &lt;code&gt;&lt;a href=&quot;fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; of LATIN CAPITAL LETTER SHARP S (U+1E9E) within the scope of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . The foldcase of this character would normally be &lt;code&gt;&quot;ss&quot;&lt;/code&gt; , but as explained in the &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; section, case changes that cross the 255/256 boundary are problematic under locales, and are hence prohibited. Therefore, this function under locale returns instead the string &lt;code&gt;&quot;\x{17F}\x{17F}&quot;&lt;/code&gt; , which is the LATIN SMALL LETTER LONG S. Since that character itself folds to &lt;code&gt;&quot;s&quot;&lt;/code&gt; , the string of two of them together should be equivalent to a single U+1E9E when foldcased.</source>
          <target state="translated">此函数的行为下的各种编译指示，诸如内以相同的方式 &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; ，如&lt;a href=&quot;lc&quot;&gt;LC&lt;/a&gt;确实，与唯一例外 &lt;code&gt;&lt;a href=&quot;fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; LATIN CAPITAL LETTER SHARP S（U + 1E9E）的范围内 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 。该字符的折号通常为 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; ，但是如&lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt;部分所述，跨越255/256边界的大小写更改在区域设置中是有问题的，因此被禁止。因此，该语言环境下的函数将返回字符串 &lt;code&gt;&quot;\x{17F}\x{17F}&quot;&lt;/code&gt; ，这是拉丁文的小写字母LONGS。由于该字符本身会折叠为 &lt;code&gt;&quot;s&quot;&lt;/code&gt; ，将它们中的两个一起折叠时的字符串应等效于单个U + 1E9E。</target>
        </trans-unit>
        <trans-unit id="8e622f55ce5e0f86a0059d75a25d61e3419fef9f" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragmata, such as in a locale, as &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; does.</source>
          <target state="translated">该功能在各种语用下（例如在语言环境中）的行为与&lt;a href=&quot;#lc&quot;&gt;lc相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a06484c004f74f9c8853b354936ff3f59e84875a" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragmata, such as in a locale, as &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; does.</source>
          <target state="translated">该功能在各种语用下（例如在语言环境中）的行为与&lt;a href=&quot;lc&quot;&gt;lc相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d07fce4b805ea45a197ef238496fb301033d2545" translate="yes" xml:space="preserve">
          <source>This function binds a variable to a package class that will provide the implementation for the variable. VARIABLE is the name of the variable to be enchanted. CLASSNAME is the name of a class implementing objects of correct type. Any additional arguments are passed to the appropriate constructor method of the class (meaning &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;TIEARRAY&lt;/code&gt; , or &lt;code&gt;TIEHASH&lt;/code&gt; ). Typically these are arguments such as might be passed to the &lt;code&gt;dbm_open()&lt;/code&gt; function of C. The object returned by the constructor is also returned by the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function, which would be useful if you want to access other methods in CLASSNAME.</source>
          <target state="translated">此函数将变量绑定到包类，该包类将提供该变量的实现。 VARIABLE是要附魔的变量的名称。 CLASSNAME是实现正确类型的对象的类的名称。任何其他参数都将传递给该类的相应构造函数方法（意味着 &lt;code&gt;TIESCALAR&lt;/code&gt; ， &lt;code&gt;TIEHANDLE&lt;/code&gt; ， &lt;code&gt;TIEARRAY&lt;/code&gt; 或 &lt;code&gt;TIEHASH&lt;/code&gt; ）。通常，这些参数是诸如可能传递给C的 &lt;code&gt;dbm_open()&lt;/code&gt; 函数的参数。构造函数返回的对象也由 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数返回，如果要访问CLASSNAME中的其他方法，这将很有用。</target>
        </trans-unit>
        <trans-unit id="c3bc0e801ef7f17e4d79ee445885b2be27f25c2b" translate="yes" xml:space="preserve">
          <source>This function binds a variable to a package class that will provide the implementation for the variable. VARIABLE is the name of the variable to be enchanted. CLASSNAME is the name of a class implementing objects of correct type. Any additional arguments are passed to the appropriate constructor method of the class (meaning &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;TIEARRAY&lt;/code&gt; , or &lt;code&gt;TIEHASH&lt;/code&gt; ). Typically these are arguments such as might be passed to the &lt;code&gt;dbm_open()&lt;/code&gt; function of C. The object returned by the constructor is also returned by the &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function, which would be useful if you want to access other methods in CLASSNAME.</source>
          <target state="translated">此函数将变量绑定到包类，该包类将提供该变量的实现。 VARIABLE是要附魔的变量的名称。 CLASSNAME是实现正确类型的对象的类的名称。任何其他参数都将传递给该类的相应构造函数方法（意味着 &lt;code&gt;TIESCALAR&lt;/code&gt; ， &lt;code&gt;TIEHANDLE&lt;/code&gt; ， &lt;code&gt;TIEARRAY&lt;/code&gt; 或 &lt;code&gt;TIEHASH&lt;/code&gt; ）。通常，这些参数是诸如可能传递给C的 &lt;code&gt;dbm_open()&lt;/code&gt; 函数的参数。构造函数返回的对象也由 &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数返回，如果要访问CLASSNAME中的其他方法，这将很有用。</target>
        </trans-unit>
        <trans-unit id="5132f8607896a5505c904bfd8891d2794b3208e8" translate="yes" xml:space="preserve">
          <source>This function can take a hash of options:</source>
          <target state="translated">这个函数可以接受一个选项的哈希值。</target>
        </trans-unit>
        <trans-unit id="f0cccb23235ebb22439bd8ff2e5a998bf5aa962e" translate="yes" xml:space="preserve">
          <source>This function cannot be used on an entire array or hash to find out how many elements these have. For that, use &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; @array&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;
%hash&lt;/code&gt; , respectively.</source>
          <target state="translated">不能在整个数组或哈希上使用此函数来找出这些元素有多少个元素。为此，分别使用 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; @array&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ba6657c5fa298f8f6fa2444117335de3f819a9a" translate="yes" xml:space="preserve">
          <source>This function cannot be used on an entire array or hash to find out how many elements these have. For that, use &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt; @array&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;
%hash&lt;/code&gt; , respectively.</source>
          <target state="translated">不能在整个数组或哈希上使用此函数来找出这些元素有多少个元素。为此，分别使用 &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt; @array&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; %hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="118dd1a89ee26e341a24a616a4886c6624f3f97c" translate="yes" xml:space="preserve">
          <source>This function causes an immediate core dump. See also the &lt;b&gt;-u&lt;/b&gt; command-line switch in &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;, which does the same thing. Primarily this is so that you can use the &lt;b&gt;undump&lt;/b&gt; program (not supplied) to turn your core dump into an executable binary after having initialized all your variables at the beginning of the program. When the new binary is executed it will begin by executing a &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; (with all the restrictions that &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; suffers). Think of it as a goto with an intervening core dump and reincarnation. If &lt;code&gt;LABEL&lt;/code&gt; is omitted, restarts the program from the top. The &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">此功能导致立即发生核心转储。另请参见&lt;a href=&quot;../perlrun&quot;&gt;perlrun中&lt;/a&gt;的&lt;b&gt;-u&lt;/b&gt;命令行开关，其功能相同。首先，这样做是为了使您可以在程序开始处初始化所有变量之后，使用&lt;b&gt;undump&lt;/b&gt;程序（未提供）将核心转储转换为可执行二进制文件。当执行新的二进制文件，将通过执行开始 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; LABEL（与所有限制条件 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 遭受）。可以将其视为具有中间转储和转世的goto。如果省略了 &lt;code&gt;LABEL&lt;/code&gt; ，则从顶部重新启动程序。该 &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; EXPR&lt;/code&gt; EXPR&lt;b&gt;&lt;/b&gt;从Perl 5.18.0开始可用的表单允许在运行时计算名称，否则与 &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; LABEL&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="2644b0d090106df2bac79cc1278fe935e270aa17" translate="yes" xml:space="preserve">
          <source>This function causes an immediate core dump. See also the &lt;b&gt;-u&lt;/b&gt; command-line switch in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;, which does the same thing. Primarily this is so that you can use the &lt;b&gt;undump&lt;/b&gt; program (not supplied) to turn your core dump into an executable binary after having initialized all your variables at the beginning of the program. When the new binary is executed it will begin by executing a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; (with all the restrictions that &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; suffers). Think of it as a goto with an intervening core dump and reincarnation. If &lt;code&gt;LABEL&lt;/code&gt; is omitted, restarts the program from the top. The &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">此功能导致立即发生核心转储。另请参见&lt;a href=&quot;perlrun&quot;&gt;perlrun中&lt;/a&gt;的&lt;b&gt;-u&lt;/b&gt;命令行开关，其功能相同。首先，这样做是为了使您可以在程序开始处初始化所有变量之后，使用&lt;b&gt;undump&lt;/b&gt;程序（未提供）将核心转储转换为可执行二进制文件。当执行新的二进制文件，将通过执行开始 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; LABEL（与所有限制条件 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 遭受）。可以将其视为具有中间转储和转世的goto。如果省略了 &lt;code&gt;LABEL&lt;/code&gt; ，则从顶部重新启动程序。该 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; EXPR&lt;/code&gt; EXPR&lt;b&gt;&lt;/b&gt;从Perl 5.18.0开始可用的表单允许在运行时计算名称，否则与 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; LABEL&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="8952b46dfeb17de53351ddf4d21ae7d55c07b2d8" translate="yes" xml:space="preserve">
          <source>This function combines &lt;code&gt;perl_inc()&lt;/code&gt; , &lt;code&gt;ccflags()&lt;/code&gt; and &lt;code&gt;ccdlflags()&lt;/code&gt; into one.</source>
          <target state="translated">此函数将 &lt;code&gt;perl_inc()&lt;/code&gt; ， &lt;code&gt;ccflags()&lt;/code&gt; 和 &lt;code&gt;ccdlflags()&lt;/code&gt; 合并为一个。</target>
        </trans-unit>
        <trans-unit id="3221a438c3aad48b5c48a805755ad197928b0f99" translate="yes" xml:space="preserve">
          <source>This function detects things that can't be modified, such as &lt;code&gt;$x+1&lt;/code&gt; , and generates errors for them. For example, &lt;code&gt;$x+1 = 2&lt;/code&gt; would cause it to be called with an op of type OP_ADD and a &lt;code&gt;type&lt;/code&gt; argument of OP_SASSIGN.</source>
          <target state="translated">此函数检测无法修改的内容，例如 &lt;code&gt;$x+1&lt;/code&gt; ，并为其生成错误。例如， &lt;code&gt;$x+1 = 2&lt;/code&gt; 会导致它与类型OP_ADD的运算和一个被称为 &lt;code&gt;type&lt;/code&gt; OP_SASSIGN的论点。</target>
        </trans-unit>
        <trans-unit id="50025265ce70752e52bdd20aeddabe5be1d58395" translate="yes" xml:space="preserve">
          <source>This function does not use a typemap. Instead, we declare it as accepting one SV* (scalar) parameter, and returning an SV* value, and we take care of populating these scalars within the code. Because we are only returning one value, we don't need a &lt;code&gt;PPCODE:&lt;/code&gt; directive - instead, we use &lt;code&gt;CODE:&lt;/code&gt; and &lt;code&gt;OUTPUT:&lt;/code&gt; directives.</source>
          <target state="translated">此函数不使用类型映射。相反，我们将其声明为接受一个SV *（标量）参数，并返回一个SV *值，并负责在代码中填充这些标量。因为只返回一个值，所以不需要 &lt;code&gt;PPCODE:&lt;/code&gt; 指令-相反，我们使用 &lt;code&gt;CODE:&lt;/code&gt; 和 &lt;code&gt;OUTPUT:&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="6180191f0bc721d501520e66b164a9ef20a22d11" translate="yes" xml:space="preserve">
          <source>This function enables/disables error popups associated with hardware errors (Disk not ready etc.) and software exceptions.</source>
          <target state="translated">此功能可启用/禁用与硬件错误(磁盘未准备好等)和软件异常相关的错误弹出窗口。</target>
        </trans-unit>
        <trans-unit id="467712b5ef786ba52bfac5af598e2fd6afe41fb8" translate="yes" xml:space="preserve">
          <source>This function finalizes the optree. Should be called directly after the complete optree is built. It does some additional checking which can't be done in the normal ck_xxx functions and makes the tree thread-safe.</source>
          <target state="translated">这个函数可以最终完成optree的构建。应该在建立完整的 optree 后直接调用。它做了一些普通ck_xxx函数无法完成的额外检查,并使树的线程安全。</target>
        </trans-unit>
        <trans-unit id="529aa240cc0116c0500e7c8811796b1b622bb45e" translate="yes" xml:space="preserve">
          <source>This function has a &lt;code&gt;Perl_&lt;/code&gt; prefix; i.e. it is defined as &lt;code&gt;Perl_av_fetch&lt;/code&gt; .</source>
          <target state="translated">这个函数有一个 &lt;code&gt;Perl_&lt;/code&gt; 前缀。即定义为 &lt;code&gt;Perl_av_fetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de86eb1f3f7a618ab133b8ece7ae081d7566d329" translate="yes" xml:space="preserve">
          <source>This function has documentation using the &lt;code&gt;apidoc&lt;/code&gt; feature which we'll look at in a second. Some functions have 'd' but not 'A'; docs are good.</source>
          <target state="translated">此函数具有使用 &lt;code&gt;apidoc&lt;/code&gt; 功能的文档，我们将在稍后介绍。有些功能带有&amp;ldquo; d&amp;rdquo;但没有&amp;ldquo; A&amp;rdquo;；文档是好的。</target>
        </trans-unit>
        <trans-unit id="0ade2373bef2bb276b87f95d3a360655ec661c9a" translate="yes" xml:space="preserve">
          <source>This function invalidates isa caches on the old stash, on all subpackages nested inside it, and on the subclasses of all those, including non-existent packages that have corresponding entries in &lt;code&gt;stash&lt;/code&gt; .</source>
          <target state="translated">此功能会使旧存储库，嵌套在其中的所有子包以及所有这些存储库的子类上的isa缓存失效，包括那些在 &lt;code&gt;stash&lt;/code&gt; 中具有相应条目的不存在的程序包。</target>
        </trans-unit>
        <trans-unit id="c21846dd58e70501c7ae85693ffbb155deb7ba64" translate="yes" xml:space="preserve">
          <source>This function is a deprecated synonym for &lt;a href=&quot;#uvoffuni_to_utf8_flags&quot;&gt;uvoffuni_to_utf8_flags&lt;/a&gt;, which itself, while not deprecated, should be used only in isolated circumstances. These functions were useful for code that wanted to handle both EBCDIC and ASCII platforms with Unicode properties, but starting in Perl v5.20, the distinctions between the platforms have mostly been made invisible to most code, so this function is quite unlikely to be what you want.</source>
          <target state="translated">该函数是&lt;a href=&quot;#uvoffuni_to_utf8_flags&quot;&gt;uvoffuni_to_utf8_flags&lt;/a&gt;的不推荐使用的同义词，该功能本身（虽然不推荐使用）仅应在单独的情况下使用。这些功能对于希望同时处理具有Unicode属性的EBCDIC和ASCII平台的代码很有用，但是从Perl v5.20开始，大多数代码几乎看不到平台之间的区别，因此该功能不太可能是你要。</target>
        </trans-unit>
        <trans-unit id="2913484e77586e8d68e21770c7b4063c930b583c" translate="yes" xml:space="preserve">
          <source>This function is a good candidate for memoization. If you memoize the `fib' function above, it will compute fib(14) exactly once, the first time it needs to, and then save the result in a table. Then if you ask for fib(14) again, it gives you the result out of the table. While computing fib(14), instead of computing fib(12) twice, it does it once; the second time it needs the value it gets it from the table. It doesn't compute fib(11) four times; it computes it once, getting it from the table the next three times. Instead of making 1,200 recursive calls to `fib', it makes 15. This makes the function about 150 times faster.</source>
          <target state="translated">这个函数是一个很好的记忆化的候选函数。如果你把上面的`fib'函数备忘录化,它将在第一次需要计算fib(14)的时候准确地计算一次,然后把结果保存在一个表中。然后,如果你再问fib(14),它就会把结果从表中给你。在计算fib(14)时,它不是计算两次fib(12),而是计算一次;第二次需要值时,它从表中获取。它不计算 fib(11)四次,而是计算一次,接下来三次从表中获取。它不需要对`fib'进行 1200 次递归调用,而是进行 15 次。这使得函数的速度快了150倍。</target>
        </trans-unit>
        <trans-unit id="8abb1909fce4e7f9c7aa7be2b9644d4d00810b89" translate="yes" xml:space="preserve">
          <source>This function is a part of the public API. All such functions should also have 'd', very few do not.</source>
          <target state="translated">这个函数是公共API的一部分。所有这样的函数也应该有'd',很少有不这样做的。</target>
        </trans-unit>
        <trans-unit id="752724e6180b12da8e6cd0e0935f30eed783f92d" translate="yes" xml:space="preserve">
          <source>This function is a stand-in replacement for &lt;a href=&quot;../../scalar/util#%24addr-%3d-refaddr(-%24ref-)&quot;&gt;Scalar::Util::refaddr&lt;/a&gt;, that is, it returns the reference address of its argument as a numeric value. The only difference is that &lt;code&gt;refaddr()&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when given a non-reference while &lt;code&gt;id()&lt;/code&gt; returns its argument unchanged.</source>
          <target state="translated">此函数是&lt;a href=&quot;../../scalar/util#%24addr-%3d-refaddr(-%24ref-)&quot;&gt;Scalar :: Util :: refaddr的&lt;/a&gt;替代品，即，它以数字值形式返回其参数的引用地址。唯一的区别是，当给定非引用时， &lt;code&gt;refaddr()&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，而 &lt;code&gt;id()&lt;/code&gt; 返回其参数不变。</target>
        </trans-unit>
        <trans-unit id="8a0d9ec972199a89df14d600a89c7347e29e2743" translate="yes" xml:space="preserve">
          <source>This function is deprecated due to the possibility that malformed input could cause reading beyond the end of the input buffer. Use &lt;a href=&quot;#isUTF8_CHAR&quot;&gt;isUTF8_CHAR&lt;/a&gt; instead.</source>
          <target state="translated">由于错误的输入可能导致读取超出输入缓冲区末尾的可能性，因此不建议使用此功能。请改用&lt;a href=&quot;#isUTF8_CHAR&quot;&gt;isUTF8_CHAR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="28ce789b612136fafacb486bd5bb357e8d0e4268" translate="yes" xml:space="preserve">
          <source>This function is disabled if the global variable $KEEP_ALL is true and an unlink on open file is supported. If the unlink is to be deferred to the END block, the file is still registered for removal.</source>
          <target state="translated">如果全局变量$KEEP_ALL为真,并且支持在打开文件时取消链接,则禁用此功能。如果取消链接的时间被推迟到END块,那么文件仍然会被删除。</target>
        </trans-unit>
        <trans-unit id="8ff75df81e21a36cc9176732a80e9ccf2b68ffdf" translate="yes" xml:space="preserve">
          <source>This function is disabled if the global variable $KEEP_ALL is true.</source>
          <target state="translated">如果全局变量$KEEP_ALL为true,则该函数被禁用。</target>
        </trans-unit>
        <trans-unit id="1b3c45f3e25d0a4f2eec52ed9b0f4d623aa7d540" translate="yes" xml:space="preserve">
          <source>This function is expected to be used to signal to perl that this SV is about to be written to, and any extra book-keeping needs to be taken care of. Hence, it croaks on read-only values.</source>
          <target state="translated">这个函数被认为是用来向perl发出信号,表示这个SV即将被写入,并且需要处理任何额外的记账。因此,它在只读值上会发出呱呱声。</target>
        </trans-unit>
        <trans-unit id="046e9e5d6bd1398867e1dee81f27fefb4c212d31" translate="yes" xml:space="preserve">
          <source>This function is expensive in time and memory.</source>
          <target state="translated">这个功能在时间和内存上都很昂贵。</target>
        </trans-unit>
        <trans-unit id="0e275fe5def47eb8b770fec4e729d202771a5b5a" translate="yes" xml:space="preserve">
          <source>This function is explicitly exported.</source>
          <target state="translated">这个功能是明确输出的。</target>
        </trans-unit>
        <trans-unit id="baae2ca89cb1960ad8e6c66b2b2c6b874d4b3266" translate="yes" xml:space="preserve">
          <source>This function is like &lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt; with a string argument, except it always parses its argument, or &lt;code&gt;$_&lt;/code&gt; if EXPR is omitted, as a string of bytes. A string containing characters whose ordinal value exceeds 255 results in an error. Source filters activated within the evaluated code apply to the code itself.</source>
          <target state="translated">此函数类似于带有字符串参数的&lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt;，不同之处在于它始终将其参数解析为 &lt;code&gt;$_&lt;/code&gt; 如果省略EXPR则解析为$ _）作为字节字符串。包含序数值超过255的字符的字符串将导致错误。在评估代码中激活的源过滤器将应用于代码本身。</target>
        </trans-unit>
        <trans-unit id="4699e383ec11b8d15b996f85aefd9a02e9b5bdaf" translate="yes" xml:space="preserve">
          <source>This function is like &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; with a string argument, except it always parses its argument, or &lt;code&gt;$_&lt;/code&gt; if EXPR is omitted, as a string of bytes. A string containing characters whose ordinal value exceeds 255 results in an error. Source filters activated within the evaluated code apply to the code itself.</source>
          <target state="translated">此函数类似于带有字符串参数的&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;，不同之处在于它始终将其参数解析为 &lt;code&gt;$_&lt;/code&gt; 如果省略EXPR则解析为$ _）作为字节字符串。包含序数值超过255的字符的字符串将导致错误。在评估代码中激活的源过滤器将应用于代码本身。</target>
        </trans-unit>
        <trans-unit id="caeb1cd5a4880a4de69d7c039879029a5a9067db" translate="yes" xml:space="preserve">
          <source>This function is like them, but the input is a strict Unicode (as opposed to native) code point. Only in very rare circumstances should code not be using the native code point.</source>
          <target state="translated">这个函数和它们一样,但输入的是一个严格的Unicode(相对于本地)码点。只有在极少数情况下,代码不应该使用本地码点。</target>
        </trans-unit>
        <trans-unit id="3a6987023b3feeacf2b107686c8afb184bf9785b" translate="yes" xml:space="preserve">
          <source>This function is most useful in the idiom</source>
          <target state="translated">这个功能在以下成语中最有用</target>
        </trans-unit>
        <trans-unit id="2ba0cefbbfd398911c6a8851cb85930170c481ec" translate="yes" xml:space="preserve">
          <source>This function is not exported by default, so you'll have to ask for it via:</source>
          <target state="translated">这个函数默认不导出,所以你必须通过。</target>
        </trans-unit>
        <trans-unit id="3f6a1a85d5fc88c0e9364254a35bb1ced4455307" translate="yes" xml:space="preserve">
          <source>This function is now largely obsolete, mostly because it's very hard to convert a core file into an executable. That's why you should now invoke it as &lt;code&gt;CORE::dump()&lt;/code&gt; , if you don't want to be warned against a possible typo.</source>
          <target state="translated">现在该功能已过时，主要是因为很难将核心文件转换为可执行文件。因此，如果您不想被警告可能出现错字，现在应该以 &lt;code&gt;CORE::dump()&lt;/code&gt; 调用它。</target>
        </trans-unit>
        <trans-unit id="5839521ffabe37be44c9b142d6f0e122410904e4" translate="yes" xml:space="preserve">
          <source>This function is only available under the &lt;code&gt;&lt;a href=&quot;evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; feature, a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; (or higher) declaration, or with a &lt;code&gt;CORE::&lt;/code&gt; prefix. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; for more information.</source>
          <target state="translated">此功能仅在 &lt;code&gt;&lt;a href=&quot;evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 功能， &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; （或更高版本）声明或带有 &lt;code&gt;CORE::&lt;/code&gt; 前缀的情况下可用。请参阅&lt;a href=&quot;../feature&quot;&gt;功能&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="2ce5a3cfad478a3c3fe7a7e04e3ec1df865cc5b4" translate="yes" xml:space="preserve">
          <source>This function is only available under the &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; feature, a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; (or higher) declaration, or with a &lt;code&gt;CORE::&lt;/code&gt; prefix. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; for more information.</source>
          <target state="translated">此功能仅在 &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 功能， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; （或更高版本）声明或带有 &lt;code&gt;CORE::&lt;/code&gt; 前缀的情况下可用。请参阅&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="e43d0a24f1f599b09639816ea4bcc88309ead9ce" translate="yes" xml:space="preserve">
          <source>This function is only used by sv_true() and friends, and only if the latter's argument is neither SvPOK, SvIOK nor SvNOK. If the flags contain SV_GMAGIC, then it does an mg_get() first.</source>
          <target state="translated">这个函数只有sv_true()和friends使用,而且只有当后者的参数既不是SvPOK、SvIOK也不是SvNOK时才使用。如果标志中包含SV_GMAGIC,那么它先做一个mg_get()。</target>
        </trans-unit>
        <trans-unit id="0b5776fa05d807fc6265ae0f0ad2309322f8e80a" translate="yes" xml:space="preserve">
          <source>This function is part of the experimental development API, and may change or disappear without notice.</source>
          <target state="translated">这个功能是实验性开发API的一部分,可能会在没有通知的情况下改变或消失。</target>
        </trans-unit>
        <trans-unit id="df4b28e7c0c75c36faca5ca1d70518986b2de4c0" translate="yes" xml:space="preserve">
          <source>This function is provided for compatibility with the Unix shell command &lt;code&gt;basename(1)&lt;/code&gt; . It does &lt;b&gt;NOT&lt;/b&gt; always return the file name portion of a path as you might expect. To be safe, if you want the file name portion of a path use &lt;code&gt;fileparse()&lt;/code&gt; .</source>
          <target state="translated">提供此功能是为了与Unix shell命令 &lt;code&gt;basename(1)&lt;/code&gt; 兼容。它&lt;b&gt;不&lt;/b&gt;总是返回路径的文件名部分，你可能期望。为了安全起见，如果您想要路径的文件名部分，请使用 &lt;code&gt;fileparse()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="deb4ec1fbe8c66b8f2020144f5701828bedcfe14" translate="yes" xml:space="preserve">
          <source>This function is provided for compatibility with the Unix shell command &lt;code&gt;dirname(1)&lt;/code&gt; and has inherited some of its quirks. In spite of its name it does &lt;b&gt;NOT&lt;/b&gt; always return the directory name as you might expect. To be safe, if you want the directory name of a path use &lt;code&gt;fileparse()&lt;/code&gt; .</source>
          <target state="translated">提供此函数是为了与Unix shell命令 &lt;code&gt;dirname(1)&lt;/code&gt; 兼容，并且继承了它的一些怪癖。尽管它的名字它&lt;b&gt;不&lt;/b&gt;总是返回正如你所预料的目录名。为了安全起见，如果您想要路径的目录名称，请使用 &lt;code&gt;fileparse()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02937778415d96c12ca24363d4faada4d7809ec7" translate="yes" xml:space="preserve">
          <source>This function is slightly neater and more convenient than the otherwise-equivalent code</source>
          <target state="translated">这个函数比其他等价的代码略微整洁和方便一些</target>
        </trans-unit>
        <trans-unit id="253b045013c433366a31c2cad960bf3283fd7d39" translate="yes" xml:space="preserve">
          <source>This function is the implementation of the &lt;a href=&quot;#LINKLIST&quot;&gt;LINKLIST&lt;/a&gt; macro. It should not be called directly.</source>
          <target state="translated">此功能是&lt;a href=&quot;#LINKLIST&quot;&gt;LINKLIST&lt;/a&gt;宏的实现。不应直接调用它。</target>
        </trans-unit>
        <trans-unit id="2a063dac587bf0c596a82a9c061b8f58b0075f3f" translate="yes" xml:space="preserve">
          <source>This function is the reason for &lt;code&gt;Test&lt;/code&gt; 's existence. It's the basic function that handles printing &quot;&lt;code&gt;ok&lt;/code&gt; &quot; or &quot;&lt;code&gt;not ok&lt;/code&gt; &quot;, along with the current test number. (That's what &lt;code&gt;Test::Harness&lt;/code&gt; wants to see.)</source>
          <target state="translated">此功能是 &lt;code&gt;Test&lt;/code&gt; 存在的原因。这是处理打印&amp;ldquo; &lt;code&gt;ok&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;not ok&lt;/code&gt; &amp;rdquo;以及当前测试编号的基本功能。（这就是 &lt;code&gt;Test::Harness&lt;/code&gt; 想要看到的。）</target>
        </trans-unit>
        <trans-unit id="077b1426e82943be7223b00766173ba5b1d4acf4" translate="yes" xml:space="preserve">
          <source>This function is used to create an in-memory gzip file with the minimum possible gzip header (exactly 10 bytes).</source>
          <target state="translated">这个函数用于创建一个内存中的gzip文件,其gzip头最小(正好是10字节)。</target>
        </trans-unit>
        <trans-unit id="4e0a2ccd31b9bdd8066d5b9d22011351f1760ec7" translate="yes" xml:space="preserve">
          <source>This function is used to uncompress an in-memory gzip file.</source>
          <target state="translated">该函数用于解压内存中的gzip文件。</target>
        </trans-unit>
        <trans-unit id="a3560ca8857460f655d69dd6b49d96a0f7f4a536" translate="yes" xml:space="preserve">
          <source>This function is useful for producing a directory tree identical to the intended distribution tree.</source>
          <target state="translated">这个函数对于生成一个与目标分布树相同的目录树非常有用。</target>
        </trans-unit>
        <trans-unit id="7f19b2798743cc5e3f86e0124b7ddc89a4b3ff92" translate="yes" xml:space="preserve">
          <source>This function is very slow. Why? To compute fib(14), it first wants to compute fib(13) and fib(12), and add the results. But to compute fib(13), it first has to compute fib(12) and fib(11), and then it comes back and computes fib(12) all over again even though the answer is the same. And both of the times that it wants to compute fib(12), it has to compute fib(11) from scratch, and then it has to do it again each time it wants to compute fib(13). This function does so much recomputing of old results that it takes a really long time to run---fib(14) makes 1,200 extra recursive calls to itself, to compute and recompute things that it already computed.</source>
          <target state="translated">这个功能非常慢。为什么呢?它要计算fib(14),首先要计算fib(13)和fib(12),然后把结果相加。但是要计算fib(13),它先要计算fib(12)和fib(11),然后再回来重新计算fib(12),尽管答案是一样的。而且两次要计算fib(12)的时候,都要从头开始计算fib(11),然后每次要计算fib(13)的时候又要重新计算。这个函数对旧的结果做了太多的重新计算,以至于它需要很长的时间来运行------fib(14)对自己做了1200次额外的递归调用,来计算和重新计算它已经计算过的东西。</target>
        </trans-unit>
        <trans-unit id="658ccab5957d9fcb5acf02b75800173326f8ac18" translate="yes" xml:space="preserve">
          <source>This function is visible to extensions included in the Perl core.</source>
          <target state="translated">这个函数对Perl核心中的扩展是可见的。</target>
        </trans-unit>
        <trans-unit id="bced169d4ae2df2074f45ec48dfe76cbdcf9e8fb" translate="yes" xml:space="preserve">
          <source>This function isn't exported out of the Perl core.</source>
          <target state="translated">这个函数并没有从Perl核心中导出。</target>
        </trans-unit>
        <trans-unit id="44b0e9309a1e4a7388d6c16c7d9a1708e320c5c8" translate="yes" xml:space="preserve">
          <source>This function makes use of the fact that the presence of tainted data anywhere within an expression renders the entire expression tainted. It would be inefficient for every operator to test every argument for taintedness. Instead, the slightly more efficient and conservative approach is used that if any tainted value has been accessed within the same expression, the whole expression is considered tainted.</source>
          <target state="translated">这个函数利用了这样一个事实,即在一个表达式中的任何地方出现污点数据都会使整个表达式受到污染。如果每个操作者都要测试每个参数的污染性,效率会很低。相反,我们采用了稍微高效和保守的方法,即如果在同一个表达式中访问了任何污点值,则整个表达式被认为是污点。</target>
        </trans-unit>
        <trans-unit id="2fa84a514560c863f7089eb7ca24d6683d764569" translate="yes" xml:space="preserve">
          <source>This function may redirect error popups associated with hardware errors (Disk not ready etc.) and software exceptions to the file POPUPLOG.OS2 at the root directory of the specified drive. Overrides OS2::Error() specified by individual programs. Given argument undef will disable redirection.</source>
          <target state="translated">这个函数可以将与硬件错误(Disk not ready等)和软件异常相关的错误弹出窗口重定向到指定驱动器根目录下的文件POPUPLOG.OS2。覆盖OS2::Error(),由个别程序指定。给定参数 undef 将禁用重定向。</target>
        </trans-unit>
        <trans-unit id="b9c43d91069a9273330810504102211439262d63" translate="yes" xml:space="preserve">
          <source>This function never returns; &lt;code&gt;croak&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; and friends.</source>
          <target state="translated">该函数永不返回； &lt;code&gt;croak&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 和朋友。</target>
        </trans-unit>
        <trans-unit id="50a0a533f960128e3a086dc96db9b1aafa52d5a7" translate="yes" xml:space="preserve">
          <source>This function normally returns a list. Suppose you memoize it and merge the caches:</source>
          <target state="translated">这个函数通常返回一个列表。假设你将其记忆并合并缓存。</target>
        </trans-unit>
        <trans-unit id="3b85997713311e08de3e59dac5499d89e1dccd03" translate="yes" xml:space="preserve">
          <source>This function only exists if Perl has been compiled to use ithreads.</source>
          <target state="translated">只有当Perl被编译成使用ithreads时,这个函数才会存在。</target>
        </trans-unit>
        <trans-unit id="61fee0518a7d8b237d34517bc719658c6b719ec4" translate="yes" xml:space="preserve">
          <source>This function only operates on officially approved (not provisional) named sequences.</source>
          <target state="translated">该功能仅在正式批准的(非临时)命名序列上运行。</target>
        </trans-unit>
        <trans-unit id="e59aa3c08f27111519b6ecd9388b33347100905a" translate="yes" xml:space="preserve">
          <source>This function only works on &lt;code&gt;new()&lt;/code&gt; and it assumes &lt;code&gt;new()&lt;/code&gt; will return just a single object which isa &lt;code&gt;$class&lt;/code&gt; .</source>
          <target state="translated">该函数仅在 &lt;code&gt;new()&lt;/code&gt; 上起作用，并且假定 &lt;code&gt;new()&lt;/code&gt; 将仅返回单个对象isa &lt;code&gt;$class&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2eb7d023997a73d6817733ba90181d612a2b1cdc" translate="yes" xml:space="preserve">
          <source>This function opens either the</source>
          <target state="translated">该功能可以打开</target>
        </trans-unit>
        <trans-unit id="441aca7229169cbbddd3f285c046a735dc532182" translate="yes" xml:space="preserve">
          <source>This function performs syntax checking on a prototype, &lt;code&gt;proto&lt;/code&gt; . If &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; is true, any illegal characters or mismatched brackets will trigger illegalproto warnings, declaring that they were detected in the prototype for &lt;code&gt;name&lt;/code&gt; .</source>
          <target state="translated">此函数对原型 &lt;code&gt;proto&lt;/code&gt; 执行语法检查。如果 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 为true，则任何非法字符或不匹配的括号将触发非法原型警告，声明已在原型中检测到 &lt;code&gt;name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91930e6b34fa8d1a9857a2f7de94cb11275f2880" translate="yes" xml:space="preserve">
          <source>This function performs the work of the legacy functions gethostbyname(), getservbyname(), inet_aton() and pack_sockaddr_in().</source>
          <target state="translated">这个函数执行传统函数gethostbyname()、getervbyname()、inet_aton()和pack_sockaddr_in()的工作。</target>
        </trans-unit>
        <trans-unit id="b69a639ae94b0e84e8a91026a470893dc8e2e4fa" translate="yes" xml:space="preserve">
          <source>This function performs the work of the legacy functions unpack_sockaddr_in(), inet_ntoa(), gethostbyaddr() and getservbyport().</source>
          <target state="translated">这个函数执行传统函数unpack_sockaddr_in()、inet_ntoa()、gethostbyaddr()和getervbyport()的工作。</target>
        </trans-unit>
        <trans-unit id="3d1364c8524baa88f5749c97cf4b3c3b92b20d7d" translate="yes" xml:space="preserve">
          <source>This function places an advisory lock on a shared variable or referenced object contained in</source>
          <target state="translated">这个函数将咨询锁放置在一个共享变量或引用对象上,该对象包含在这个函数中。</target>
        </trans-unit>
        <trans-unit id="13aa5d944aea63735721eab1c7c43ad176915f14" translate="yes" xml:space="preserve">
          <source>This function returns a string of &lt;code&gt;boot_$ModuleName&lt;/code&gt; prototypes for each @modules.</source>
          <target state="translated">该函数为每个@modules 返回一个 &lt;code&gt;boot_$ModuleName&lt;/code&gt; 原型字符串。</target>
        </trans-unit>
        <trans-unit id="4f9139a43ab3e4540adae4f5d5020617b2e643b8" translate="yes" xml:space="preserve">
          <source>This function returns a string of calls to &lt;code&gt;newXS()&lt;/code&gt; that glue the module</source>
          <target state="translated">此函数返回对 &lt;code&gt;newXS()&lt;/code&gt; 的调用字符串，以将模块粘在一起</target>
        </trans-unit>
        <trans-unit id="621ba7bc642c79bf406939acb2b7c2b8df3903c7" translate="yes" xml:space="preserve">
          <source>This function returns an encoded version of the string ($str) given as argument.</source>
          <target state="translated">此函数返回作为参数的字符串($str)的编码版本。</target>
        </trans-unit>
        <trans-unit id="44086926e42f35072b303b091e9d9e0a7ca33b91" translate="yes" xml:space="preserve">
          <source>This function returns empty-list if given anything other than a formally valid language tag.</source>
          <target state="translated">如果给定的不是正式有效的语言标签,该函数返回空列表。</target>
        </trans-unit>
        <trans-unit id="865f16a5f2b57a820e8bf84b966f732abf36eb70" translate="yes" xml:space="preserve">
          <source>This function returns the plain text version of the string given as argument. The lines of the result are &quot;\n&quot; terminated, even if the $str argument contains &quot;\r\n&quot; terminated lines.</source>
          <target state="translated">这个函数返回作为参数的字符串的纯文本版本。即使$str参数包含&quot;\r\n &quot;终止的行,结果中的行也是&quot;\n &quot;终止的。</target>
        </trans-unit>
        <trans-unit id="a5ab5fe7ba11e207b5f81eca8f934ec6da3fef9c" translate="yes" xml:space="preserve">
          <source>This function returns the string that results from decoding the scalar value</source>
          <target state="translated">该函数返回标量值解码后的字符串。</target>
        </trans-unit>
        <trans-unit id="3d6da7152ac538ef94012168e86ee3522aaad549" translate="yes" xml:space="preserve">
          <source>This function returns the string with the first character modified if it is a control character. It converts it to ^X format first, so that &quot;\cG&quot; becomes &quot;^G&quot;. This is used internally by &lt;a href=&quot;#SAFENAME&quot;&gt;B::GV::SAFENAME&lt;/a&gt;, but you can call it directly.</source>
          <target state="translated">如果它是控制字符，则此函数返回修改后的第一个字符的字符串。它将首先将其转换为^ X格式，以便&amp;ldquo; \ cG&amp;rdquo;变为&amp;ldquo; ^ G&amp;rdquo;。由&lt;a href=&quot;#SAFENAME&quot;&gt;B :: GV :: SAFENAME&lt;/a&gt;内部使用，但是您可以直接调用它。</target>
        </trans-unit>
        <trans-unit id="3960f619466a09edf20242d0c7f969690cbc6219" translate="yes" xml:space="preserve">
          <source>This function should be as efficient as possible to keep your programs running as fast as possible.</source>
          <target state="translated">这个功能应该尽可能地提高工作效率,以保证你的程序尽可能快地运行。</target>
        </trans-unit>
        <trans-unit id="3a1ef4b3781258f0fdbabb5991f2b0a7c13aaadc" translate="yes" xml:space="preserve">
          <source>This function should have been named wantlist() instead.</source>
          <target state="translated">这个函数应该被命名为wantlist()。</target>
        </trans-unit>
        <trans-unit id="0b507d2e008bacdbb9e54edf21d0bbb50fdaab83" translate="yes" xml:space="preserve">
          <source>This function should not be called if you are using the object oriented interface since the it will interfere with the object destructor deleting the file.</source>
          <target state="translated">如果你使用的是面向对象的接口,这个函数就不应该被调用,因为它将会干扰对象析构器删除文件。</target>
        </trans-unit>
        <trans-unit id="c82575cb1cd9500578e180e36936964e6acbcd65" translate="yes" xml:space="preserve">
          <source>This function should not have a compatibility macro to define, say, &lt;code&gt;Perl_parse&lt;/code&gt; to &lt;code&gt;parse&lt;/code&gt; . It must be called as &lt;code&gt;Perl_parse&lt;/code&gt; .</source>
          <target state="translated">该函数不应具有用于定义要 &lt;code&gt;parse&lt;/code&gt; &lt;code&gt;Perl_parse&lt;/code&gt; 的兼容性宏。它必须称为 &lt;code&gt;Perl_parse&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd99feaf61a2bec56d635937abeb8d24fef9d878" translate="yes" xml:space="preserve">
          <source>This function simply calls the Microsoft C library _getdcwd() function.</source>
          <target state="translated">这个函数只是简单地调用微软C库的_getdcwd()函数。</target>
        </trans-unit>
        <trans-unit id="7c73c162d2f4a3c57002d94f30e626af9a64555c" translate="yes" xml:space="preserve">
          <source>This function simply returns a string defining the same &lt;code&gt;EXTERN_C&lt;/code&gt; macro as</source>
          <target state="translated">该函数仅返回定义与 &lt;code&gt;EXTERN_C&lt;/code&gt; 宏相同的字符串。</target>
        </trans-unit>
        <trans-unit id="9ab2ac7d8042c579036bf811ff64ad55b40d9830" translate="yes" xml:space="preserve">
          <source>This function skips over the automatic calls to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; made on the behalf of the debugger. If the stack frame requested was a sub called by &lt;code&gt;DB::sub&lt;/code&gt; , the return value will be the frame for the call to &lt;code&gt;DB::sub&lt;/code&gt; , since that has the correct line number/etc. for the call site. If</source>
          <target state="translated">此函数跳过代表调试器对 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 的自动调用。如果请求的堆栈帧是由 &lt;code&gt;DB::sub&lt;/code&gt; sub调用的子帧，则返回值将是调用 &lt;code&gt;DB::sub&lt;/code&gt; 的帧，因为它具有正确的行号/等。用于呼叫站点。如果</target>
        </trans-unit>
        <trans-unit id="3f1ed900c36dd5852fb31f0242bde189d87ee34e" translate="yes" xml:space="preserve">
          <source>This function takes a list of 0 or more language tags that constitute a given user's Accept-Language list, and returns a list of tags for</source>
          <target state="translated">这个函数接收构成用户接受语言列表的0个或更多语言标签的列表,并返回一个标签列表,供用户使用。</target>
        </trans-unit>
        <trans-unit id="2e20c9e90738e4e12b4b244ae6847d7d7fb0c7dd" translate="yes" xml:space="preserve">
          <source>This function takes a variable number of arguments, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; style. The argument list should end with &lt;code&gt;...&lt;/code&gt; , like this:</source>
          <target state="translated">此函数采用可变数量的参数，即 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 样式。参数列表应以 &lt;code&gt;...&lt;/code&gt; 结尾，如下所示：</target>
        </trans-unit>
        <trans-unit id="cf2eecbd5d099ce08ffbe9b809327bd3414ba65b" translate="yes" xml:space="preserve">
          <source>This function takes no arguments, and as far as &lt;code&gt;Memoize&lt;/code&gt; is concerned, it always returns the same result. &lt;code&gt;Memoize&lt;/code&gt; is wrong, of course, and the memoized version of this function will call &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; once to get the current time, and it will return that same time every time you call it after that.</source>
          <target state="translated">此函数不带任何参数，就 &lt;code&gt;Memoize&lt;/code&gt; 而言，它始终返回相同的结果。当然， &lt;code&gt;Memoize&lt;/code&gt; 是错误的，此函数的已记忆版本将调用 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 一次以获取当前时间，并且此后每次调用它都会返回相同的时间。</target>
        </trans-unit>
        <trans-unit id="5edb4f65abb2fc47967dac5333a9e803321aac25" translate="yes" xml:space="preserve">
          <source>This function tells the thingy referenced by REF that it is now an object in the CLASSNAME package. If CLASSNAME is omitted, the current package is used. Because a &lt;code&gt;&lt;a href=&quot;bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; is often the last thing in a constructor, it returns the reference for convenience. Always use the two-argument version if a derived class might inherit the function doing the blessing. See &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; for more about the blessing (and blessings) of objects.</source>
          <target state="translated">此函数告诉REF所引用的对象它现在是CLASSNAME包中的一个对象。如果省略CLASSNAME，则使用当前包。由于 &lt;code&gt;&lt;a href=&quot;bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 通常是构造函数中的最后一件事，因此为了方便起见，它返回引用。如果派生类可能继承祝福功能，则始终使用两个参数的版本。有关&lt;a href=&quot;../perlobj&quot;&gt;对象&lt;/a&gt;的祝福（和祝福），请参阅perlobj。</target>
        </trans-unit>
        <trans-unit id="264717bee5831f635e17b82abeba8fa8b801090b" translate="yes" xml:space="preserve">
          <source>This function tells the thingy referenced by REF that it is now an object in the CLASSNAME package. If CLASSNAME is omitted, the current package is used. Because a &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; is often the last thing in a constructor, it returns the reference for convenience. Always use the two-argument version if a derived class might inherit the function doing the blessing. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more about the blessing (and blessings) of objects.</source>
          <target state="translated">此函数告诉REF所引用的对象它现在是CLASSNAME包中的一个对象。如果省略CLASSNAME，则使用当前包。由于 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 通常是构造函数中的最后一件事，因此为了方便起见，它返回引用。如果派生类可能继承祝福功能，则始终使用两个参数的版本。有关&lt;a href=&quot;perlobj&quot;&gt;对象&lt;/a&gt;的祝福（和祝福），请参阅perlobj。</target>
        </trans-unit>
        <trans-unit id="5d01eea1f06346371db6a328408650ca1c6b5ca7" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;code&gt;load&lt;/code&gt; function or the &lt;code&gt;autoload_remote&lt;/code&gt; function from Module::Load under the hood.</source>
          <target state="translated">此函数使用引擎盖下Module :: Load 的 &lt;code&gt;load&lt;/code&gt; 函数或 &lt;code&gt;autoload_remote&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="dde06d7625f57e7da1a76d11827641ea58931d51" translate="yes" xml:space="preserve">
          <source>This function was useful for code that wanted to handle both EBCDIC and ASCII platforms with Unicode properties, but starting in Perl v5.20, the distinctions between the platforms have mostly been made invisible to most code, so this function is quite unlikely to be what you want. If you do need this precise functionality, use instead &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;NATIVE_TO_UNI(utf8n_to_uvchr(...))&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能对于希望同时处理具有Unicode属性的EBCDIC和ASCII平台的代码很有用，但是从Perl v5.20开始，大多数代码几乎看不到平台之间的区别，因此该功能不太可能是你要。如果确实需要此精确功能，请改用 &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;NATIVE_TO_UNI(utf8n_to_uvchr(...))&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e428d7e7165fe610c2ec2aae0a7a0abdc81b5d5a" translate="yes" xml:space="preserve">
          <source>This function will calculate and return the binary digest of the bytes of the given file. The function will croak if it fails to open or read the file.</source>
          <target state="translated">该函数将计算并返回给定文件的字节数的二进制摘要。如果无法打开或读取文件,该函数将崩溃。</target>
        </trans-unit>
        <trans-unit id="e710ca7b4ebf9ab0536802088bacbcbd1c5ec7fb" translate="yes" xml:space="preserve">
          <source>This function will concatenate all arguments, calculate the MD5 digest of this &quot;message&quot;, and return it in binary form. The returned string will be 16 bytes long.</source>
          <target state="translated">这个函数将连接所有参数,计算这个 &quot;消息 &quot;的MD5摘要,并以二进制形式返回。返回的字符串将是16个字节长。</target>
        </trans-unit>
        <trans-unit id="c489f76d5438c6d22b3cb418ff3f520db9ae337f" translate="yes" xml:space="preserve">
          <source>This function will convert to UTF-8 (and not warn) even code points that aren't legal Unicode or are problematic, unless &lt;code&gt;flags&lt;/code&gt; contains one or more of the following flags:</source>
          <target state="translated">除非 &lt;code&gt;flags&lt;/code&gt; 包含以下一个或多个标志，否则该功能将转换为UTF-8（并且不会发出警告），甚至是非合法Unicode或有问题的代码点。</target>
        </trans-unit>
        <trans-unit id="bfa2e2cbe1081798fb5dd07961b2589448f68e0d" translate="yes" xml:space="preserve">
          <source>This function will croak if it can't connect to the syslog daemon.</source>
          <target state="translated">如果不能连接到syslog守护进程,这个功能就会崩溃。</target>
        </trans-unit>
        <trans-unit id="c8fb41e9972ce033692cb3bc009110bcfa6b3909" translate="yes" xml:space="preserve">
          <source>This function will not be confused by overloading or blessing. In internals terms, this extracts the regexp pointer out of the PERL_MAGIC_qr structure so it cannot be fooled.</source>
          <target state="translated">这个函数不会被重载或祝福所混淆。用内部术语来说,这个函数从PERL_MAGIC_qr结构中提取regexp指针,所以不会被骗。</target>
        </trans-unit>
        <trans-unit id="bdf7565f2d5b49ccdcf0417e04e7ffb7876b15d0" translate="yes" xml:space="preserve">
          <source>This function will split up your program into files that the AutoLoader module can handle. It is used by both the standard perl libraries and by the MakeMaker utility, to automatically configure libraries for autoloading.</source>
          <target state="translated">这个功能将把你的程序分割成AutoLoader模块可以处理的文件。它被标准的perl库和MakeMaker实用程序使用,以自动配置自动加载的库。</target>
        </trans-unit>
        <trans-unit id="eb5d34127b41d73e4ad33707ae6e0f3468fa3088" translate="yes" xml:space="preserve">
          <source>This function works like the system call by the same name: it makes the named directory the new root directory for all further pathnames that begin with a &lt;code&gt;/&lt;/code&gt; by your process and all its children. (It doesn't change your current working directory, which is unaffected.) For security reasons, this call is restricted to the superuser. If FILENAME is omitted, does a &lt;code&gt;&lt;a href=&quot;chroot&quot;&gt;chroot&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">此函数的工作方式类似于具有相同名称的系统调用：它使命名目录成为您的进程及其所有子级以 &lt;code&gt;/&lt;/code&gt; 开头的所有其他路径名的新根目录。 （它不会更改您当前的工作目录，该目录不会受到影响。）出于安全原因，此调用仅限于超级用户。如果省略FILENAME，则对 &lt;code&gt;$_&lt;/code&gt; 执行 &lt;code&gt;&lt;a href=&quot;chroot&quot;&gt;chroot&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4f0880e6d532a1f27ed2ddbef9335a9b1af6165" translate="yes" xml:space="preserve">
          <source>This function works like the system call by the same name: it makes the named directory the new root directory for all further pathnames that begin with a &lt;code&gt;/&lt;/code&gt; by your process and all its children. (It doesn't change your current working directory, which is unaffected.) For security reasons, this call is restricted to the superuser. If FILENAME is omitted, does a &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">此函数的工作方式类似于具有相同名称的系统调用：它使命名目录成为您的进程及其所有子级以 &lt;code&gt;/&lt;/code&gt; 开头的所有其他路径名的新根目录。 （它不会更改您当前的工作目录，该目录不会受到影响。）出于安全原因，此调用仅限于超级用户。如果省略FILENAME，则对 &lt;code&gt;$_&lt;/code&gt; 执行 &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef6e36bc13a174b6b1778b35a2d60399ce6095bb" translate="yes" xml:space="preserve">
          <source>This function, if given a language tag, returns all language tags that are alternate forms of this language tag. (I.e., tags which refer to the same language.) This is meant to handle legacy tags caused by the minor changes in language tag standards over the years; and the x-/i- alternation is also dealt with.</source>
          <target state="translated">如果给定一个语言标签,这个函数将返回这个语言标签的所有替代形式的语言标签。(即指同一种语言的标签。)这是为了处理多年来语言标签标准的细微变化所导致的遗留标签;x-/i-交替也被处理。</target>
        </trans-unit>
        <trans-unit id="b8a93fcdf2125a7d09fd995b425967c3b4164e45" translate="yes" xml:space="preserve">
          <source>This function, if given a language tag, returns an encoding of it such that:</source>
          <target state="translated">如果给定一个语言标签,这个函数将返回它的编码,这样:</target>
        </trans-unit>
        <trans-unit id="ab422ba4ddb7cdb9c2c2585a4c8bf7188aa9975a" translate="yes" xml:space="preserve">
          <source>This function, which is included in the two export tags listed above, takes one or two arguments. The first is the glob pattern. The second is a set of flags ORed together. The available flags are listed below under &lt;a href=&quot;#POSIX-FLAGS&quot;&gt;POSIX FLAGS&lt;/a&gt;. If the second argument is omitted, &lt;code&gt;GLOB_CSH&lt;/code&gt; (or &lt;code&gt;GLOB_CSH|GLOB_NOCASE&lt;/code&gt; on VMS and DOSish systems) is used by default.</source>
          <target state="translated">上面列出的两个导出标记中包含的此函数采用一个或两个参数。首先是水珠图案。第二个是一组标志进行&amp;ldquo;或&amp;rdquo;运算。可用的标志在&lt;a href=&quot;#POSIX-FLAGS&quot;&gt;POSIX FLAGS下列出&lt;/a&gt;。如果省略第二个参数，则默认使用 &lt;code&gt;GLOB_CSH&lt;/code&gt; （或在VMS和DOSish系统上为 &lt;code&gt;GLOB_CSH|GLOB_NOCASE&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7607d86adf25319082630a8f720c18a028dc2b55" translate="yes" xml:space="preserve">
          <source>This functionality is disabled for setuid scripts and for scripts run with &lt;b&gt;-T&lt;/b&gt;.</source>
          <target state="translated">对于setuid脚本和&lt;b&gt;-T&lt;/b&gt;运行的脚本，此功能被禁用。</target>
        </trans-unit>
        <trans-unit id="5e7553b3094129fa58516257b0cce463898fb85b" translate="yes" xml:space="preserve">
          <source>This generates a compile-time error if you access a variable that was neither explicitly declared (using any of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
vars&lt;/code&gt; ) nor fully qualified. (Because this is to avoid variable suicide problems and subtle dynamic scoping issues, a merely &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; variable isn't good enough.) See &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;, &lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;, &lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;, &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;, and &lt;a href=&quot;vars&quot;&gt;vars&lt;/a&gt;.</source>
          <target state="translated">如果您访问既未明确声明（使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; ）也未完全限定的变量，则会生成编译时错误。（因为这是为了避免变量自杀问题和细微的动态作用域问题，所以仅 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 变量是不够的。）请参阅&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;，&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;，&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;，&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;和&lt;a href=&quot;vars&quot;&gt;vars&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f74c9a11ba157a546c0c89330b1cb3bdd1614525" translate="yes" xml:space="preserve">
          <source>This generates a runtime error if you use symbolic references (see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;).</source>
          <target state="translated">如果使用符号引用，则会生成运行时错误（请参阅&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3b0f601577dbb5896904df9ff737e1fa0298974a" translate="yes" xml:space="preserve">
          <source>This gets interpreted as:</source>
          <target state="translated">这被解释为:</target>
        </trans-unit>
        <trans-unit id="70bf742be7e750bec7fa9fb8e4b6fe30ec9b5f65" translate="yes" xml:space="preserve">
          <source>This gives nasty overhead when you are trying to dynamically require modules at runtime, since you will need to change the module notation (&lt;code&gt;Acme::Comment&lt;/code&gt; ) to a file notation fitting the particular platform you are on.</source>
          <target state="translated">当您尝试在运行时动态要求模块时，这会带来讨厌的开销，因为您需要将模块符号（ &lt;code&gt;Acme::Comment&lt;/code&gt; ）更改为适合您所使用的特定平台的文件符号。</target>
        </trans-unit>
        <trans-unit id="7c019885847002a06e56f60b480505499d5d7585" translate="yes" xml:space="preserve">
          <source>This gives the name of the extension (</source>
          <target state="translated">这给出了扩展名的名称(</target>
        </trans-unit>
        <trans-unit id="6b221eef709fb6d96fbb9db3f118edc097a1ba2d" translate="yes" xml:space="preserve">
          <source>This global modifies the argument given to &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; by &lt;code&gt;Params::Check::check()&lt;/code&gt; and is useful if you have a custom wrapper function around &lt;code&gt;Params::Check::check()&lt;/code&gt; . The value must be an integer, indicating the number of wrapper functions inserted between the real function call and &lt;code&gt;Params::Check::check()&lt;/code&gt; .</source>
          <target state="translated">该全局变量修改了 &lt;code&gt;Params::Check::check()&lt;/code&gt; 给 &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 的参数，如果您在 &lt;code&gt;Params::Check::check()&lt;/code&gt; 周围有一个自定义包装函数，则此方法很有用。该值必须是整数，表示在实函数调用和 &lt;code&gt;Params::Check::check()&lt;/code&gt; 之间插入的包装器函数的数量。</target>
        </trans-unit>
        <trans-unit id="f8923baf9a118df6243078227c2bc3261ab6c170" translate="yes" xml:space="preserve">
          <source>This globally overrides the default behavior of calling &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; inside a thread, and effectively causes such calls to behave the same as &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; . In other words, with this setting, calling &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; causes only the thread to terminate.</source>
          <target state="translated">这将全局覆盖在线程内调用 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 的默认行为，并有效地导致此类调用的行为与 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 。换句话说，使用此设置，调用 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 只会导致线程终止。</target>
        </trans-unit>
        <trans-unit id="9d1a7a9bddd9acdc92fdc5c3e015da338283422a" translate="yes" xml:space="preserve">
          <source>This guarantees that STDOUT (where the test results appear) and STDERR (where the diagnostics appear) will stay in sync. The harness will display any diagnostics your tests emit on STDERR.</source>
          <target state="translated">这保证了STDOUT(显示测试结果的地方)和STDERR(显示诊断程序的地方)将保持同步。线束将在STDERR上显示您的测试发出的任何诊断程序。</target>
        </trans-unit>
        <trans-unit id="06edcd446459b13f358d5f7a1e7f44f85855880a" translate="yes" xml:space="preserve">
          <source>This happened because the presence of overloading was checked too early, before any tie()d access was attempted. If the class of the value FETCH()ed from the tied variable does not change, a simple workaround for code that is to run on older Perl versions is to access the value (via &lt;code&gt;() = $foo&lt;/code&gt; or some such) immediately after tie()ing, so that after this call the</source>
          <target state="translated">发生这种情况的原因是，在尝试进行任何tie（）d访问之前，都太早检查了过载的存在。如果从绑定变量获取的值FETCH（）的类未更改，则在较早的Perl版本上运行的代码的一种简单解决方法是：在绑定后立即访问值（通过 &lt;code&gt;() = $foo&lt;/code&gt; 或诸如此类） （）ing，以便在此调用之后</target>
        </trans-unit>
        <trans-unit id="4f907111d1d29806bed6e772fe053aff55cf72f3" translate="yes" xml:space="preserve">
          <source>This happens because Berkeley DB uses dynamic memory to allocate buffers which will subsequently be written to the database file. Being dynamic, the memory could have been used for anything before DB malloced it. As Berkeley DB doesn't clear the memory once it has been allocated, the unused portions will contain random junk. In the case where a Perl script gets written to the database, the random junk will correspond to an area of dynamic memory that happened to be used during the compilation of the script.</source>
          <target state="translated">之所以会发生这种情况,是因为Berkeley DB使用动态内存来分配缓冲区,缓冲区随后将被写入数据库文件。由于是动态的,在DB malloced之前,内存可能已经被用于任何事情。由于Berkeley DB一旦分配了内存,就不会清除内存,因此未使用的部分将包含随机的垃圾。在Perl脚本被写入数据库的情况下,随机垃圾将对应于脚本编译过程中碰巧被使用的动态内存区域。</target>
        </trans-unit>
        <trans-unit id="2287d497a37220b85075e14fb44f3c5f11c4109c" translate="yes" xml:space="preserve">
          <source>This happens because you can't really share arbitrary data structures with foreign processes.</source>
          <target state="translated">发生这种情况是因为你不能真正与外来进程共享任意的数据结构。</target>
        </trans-unit>
        <trans-unit id="3663fa9d53c5bc8b1c430a10078b98451ddfbf78" translate="yes" xml:space="preserve">
          <source>This happens only if your perl is compiled to use stdio instead of perlio, which is the default. Some (maybe all?) stdios set error and eof flags that you may need to clear. The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module defines &lt;code&gt;clearerr()&lt;/code&gt; that you can use. That is the technically correct way to do it. Here are some less reliable workarounds:</source>
          <target state="translated">仅当您的perl编译为使用stdio而不是perlio（这是默认设置）时，才会发生这种情况。一些（也许是全部？）stdio设置了错误和eof标志，您可能需要清除它们。该&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块定义 &lt;code&gt;clearerr()&lt;/code&gt; ，您可以使用。从技术上讲，这是正确的方法。以下是一些不太可靠的解决方法：</target>
        </trans-unit>
        <trans-unit id="40e2474ab2464f5a6d8b366f637789f861001327" translate="yes" xml:space="preserve">
          <source>This happens to avoid shell interpolation problems when whitespace is present in directory names.</source>
          <target state="translated">发生这种情况是为了避免目录名中出现空白时的shell插值问题。</target>
        </trans-unit>
        <trans-unit id="76f62e127c6c53c05eb19f5eae3fcd84ce29184a" translate="yes" xml:space="preserve">
          <source>This has a significant advantage in space over reading the whole file in. You can find a proof of this method in</source>
          <target state="translated">这比把整个文件读进去在空间上有很大的优势。你可以在下面找到这个方法的证明</target>
        </trans-unit>
        <trans-unit id="a19e57e2a77c7fc3b4122f04d13e6469dce9f91c" translate="yes" xml:space="preserve">
          <source>This has been recorded in &lt;a href=&quot;http://search.cpan.org/perldoc/rt.cpan.org&quot;&gt;rt.cpan.org&lt;/a&gt; as bug #37532: Unable to interleave STDOUT and STDERR.</source>
          <target state="translated">这已在&lt;a href=&quot;http://search.cpan.org/perldoc/rt.cpan.org&quot;&gt;rt.cpan.org中&lt;/a&gt;记录为错误＃37532：无法交错STDOUT和STDERR。</target>
        </trans-unit>
        <trans-unit id="f52d89b3c166d4a363c55e83875dec4c4067987e" translate="yes" xml:space="preserve">
          <source>This has several advantages. Accessors make it easier to change the implementation of an object later while still preserving the original API.</source>
          <target state="translated">这有几个优点。接入器使得以后更容易改变一个对象的实现,同时仍然保留原来的API。</target>
        </trans-unit>
        <trans-unit id="34b1eddfb5655aec91f3e8e1f2978f9657ae01a0" translate="yes" xml:space="preserve">
          <source>This has the effect of storing the cache in a &lt;code&gt;DB_File&lt;/code&gt; database whose name is in &lt;code&gt;$filename&lt;/code&gt; . The cache will persist after the program has exited. Next time the program runs, it will find the cache already populated from the previous run of the program. Or you can forcibly populate the cache by constructing a batch program that runs in the background and populates the cache file. Then when you come to run your real program the memoized function will be fast because all its results have been precomputed.</source>
          <target state="translated">这具有将缓存存储在名称为 &lt;code&gt;$filename&lt;/code&gt; 的 &lt;code&gt;DB_File&lt;/code&gt; 数据库中的效果。程序退出后，缓存将继续存在。下次该程序运行时，它将找到该程序的上一次运行已填充的缓存。或者，您可以通过构造一个在后台运行并填充缓存文件的批处理程序来强制填充缓存。然后，当您开始运行真实程序时，由于所有功能的结果均已预先计算，因此记忆功能将很快。</target>
        </trans-unit>
        <trans-unit id="4f55042605688b1e566dc7078adcb80b2ae71090" translate="yes" xml:space="preserve">
          <source>This has the interesting effect of creating a function local to another function, something not normally supported in Perl.</source>
          <target state="translated">这有一个有趣的效果,就是在另一个函数的局部创建一个函数,这在Perl中通常是不支持的。</target>
        </trans-unit>
        <trans-unit id="b1797c70a1d197e558ba86167569174dbeb96a8a" translate="yes" xml:space="preserve">
          <source>This hash should map POD files (or scripts containing POD) to the man file names under the &lt;code&gt;blib/man1/&lt;/code&gt; directory, as in the following example:</source>
          <target state="translated">此哈希应将POD文件（或包含POD的脚本）映射到 &lt;code&gt;blib/man1/&lt;/code&gt; 目录下的man文件名，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="e9df8c379bbf80ee5fdd7c982a32f28e6ec7e7ad" translate="yes" xml:space="preserve">
          <source>This holds a hash-of-lists. Each list contains the functions in the category the key denotes.</source>
          <target state="translated">这里面有一个列表的哈希。每个列表都包含键所代表的类别中的函数。</target>
        </trans-unit>
        <trans-unit id="80d4d81772f7d6d67760a370f3b5798c816acf17" translate="yes" xml:space="preserve">
          <source>This holds a string of the last error that happened during a call to &lt;code&gt;can_load&lt;/code&gt; . It is useful to inspect this when &lt;code&gt;can_load&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它保存了在调用 &lt;code&gt;can_load&lt;/code&gt; 期间发生的最后一个错误的字符串。当 &lt;code&gt;can_load&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 时检查此值很有用。</target>
        </trans-unit>
        <trans-unit id="807ff9f1a614524ec64299d0ff11753e548d2db4" translate="yes" xml:space="preserve">
          <source>This holds the cache of the &lt;code&gt;can_load&lt;/code&gt; function. If you explicitly want to remove the current cache, you can set this variable to &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">这保存了 &lt;code&gt;can_load&lt;/code&gt; 函数的缓存。如果您明确希望删除当前缓存，则可以将此变量设置为 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ab611b7e6d978fe2070f07754881b8d06390403" translate="yes" xml:space="preserve">
          <source>This identical to the numerical values of the &lt;code&gt;$!&lt;/code&gt; , see &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$ERRNO in perlvar&lt;/a&gt;.</source>
          <target state="translated">这等于 &lt;code&gt;$!&lt;/code&gt; 的数值！，请参阅&lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;perlvar中的$ ERRNO&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eebbc38db38088437ee3de434676f2c9849a55f6" translate="yes" xml:space="preserve">
          <source>This implementation never has to fetch the context using a function call, since it is always passed as an extra argument. Depending on your needs for simplicity or efficiency, you may mix the previous two approaches freely.</source>
          <target state="translated">这种实现永远不需要使用函数调用来获取上下文,因为它总是作为一个额外的参数传递。根据你对简单或效率的需求,你可以自由混合前面两种方法。</target>
        </trans-unit>
        <trans-unit id="7b6dd1dd5bc3b526c6e18c4c4cf7662fc526f6c1" translate="yes" xml:space="preserve">
          <source>This implements the C library function of the same name, which on most systems returns the current login from</source>
          <target state="translated">这实现了同名的C库函数,在大多数系统中,该函数从</target>
        </trans-unit>
        <trans-unit id="9b00dbaf392453f8a0c495715d87f8a967ac3280" translate="yes" xml:space="preserve">
          <source>This implicit use of &lt;code&gt;$_&lt;/code&gt; greatly simplifies the filter.</source>
          <target state="translated">&lt;code&gt;$_&lt;/code&gt; 这种隐式使用大大简化了过滤器。</target>
        </trans-unit>
        <trans-unit id="5b50085de4def35b6bdec8ddfe646e562a42bf85" translate="yes" xml:space="preserve">
          <source>This implicitly turns on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; .</source>
          <target state="translated">这将隐式启用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1913f881cf8f6c8733392373df598260e9eff553" translate="yes" xml:space="preserve">
          <source>This implies, among other things, that any magic eventually carried by those variables is locally lost. In other words, saying &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; */&lt;/code&gt; will not have any effect on the internal value of the input record separator.</source>
          <target state="translated">这意味着，除其他因素外，这些变量最终携带的所有魔力都会局部丢失。换句话说，说 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; */&lt;/code&gt; 不会对输入记录分隔符的内部值产生任何影响。</target>
        </trans-unit>
        <trans-unit id="853b46dcbc0a00c897209b2e5eda11d1bef5190a" translate="yes" xml:space="preserve">
          <source>This imports all the symbols from YourModule's &lt;code&gt;@EXPORT&lt;/code&gt; into the namespace of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">这会将所有符号从YourModule的 &lt;code&gt;@EXPORT&lt;/code&gt; 导入到 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句的名称空间中。</target>
        </trans-unit>
        <trans-unit id="cc30f208dc0886e9e09f0ad72a7741fdb1114419" translate="yes" xml:space="preserve">
          <source>This imports only the symbols listed by the caller into their namespace. All listed symbols must be in your &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; , else an error occurs. The advanced export features of Exporter are accessed like this, but with list entries that are syntactically distinct from symbol names.</source>
          <target state="translated">这仅将调用者列出的符号导入其名称空间。所有列出的符号必须在您的 &lt;code&gt;@EXPORT&lt;/code&gt; 或 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 中，否则会发生错误。可以通过这种方式访问​​Exporter的高级导出功能，但是使用与符号名称在语法上不同的列表条目。</target>
        </trans-unit>
        <trans-unit id="f54334948064b9890996f54ddad24e2c8dcfde1a" translate="yes" xml:space="preserve">
          <source>This incantation is a bit much to remember, but Perl will display it for you if you say &lt;code&gt;perl &quot;-V:startperl&quot;&lt;/code&gt; .</source>
          <target state="translated">这个咒语要记住很多，但是如果您说 &lt;code&gt;perl &quot;-V:startperl&quot;&lt;/code&gt; ，Perl会为您显示。</target>
        </trans-unit>
        <trans-unit id="5270d55bdd99c39c88df6b66aa86ef8a427ec941" translate="yes" xml:space="preserve">
          <source>This includes everything before the &amp;lt;title&amp;gt; opening tag including the Document type and including the opening &amp;lt;title&amp;gt; tag. The following call will set it to be a simple HTML file:</source>
          <target state="translated">这包括&amp;lt;title&amp;gt;开头标记之前的所有内容，包括Document类型和开头的&amp;lt;title&amp;gt;标记。以下调用将其设置为简单的HTML文件：</target>
        </trans-unit>
        <trans-unit id="5e4643de8eedeed9698ffe2974d9db63ab9e6ea1" translate="yes" xml:space="preserve">
          <source>This indicates how numbers should be formatted for human readability, for example the character used as the decimal point.</source>
          <target state="translated">这表明数字应该如何格式化以利于人类阅读,例如用作小数点的字符。</target>
        </trans-unit>
        <trans-unit id="6005230475219b0a5021d5218cbbce15d92f7c81" translate="yes" xml:space="preserve">
          <source>This indicates that Configure is being run with a broken Korn shell (even though you think you are using a Bourne shell by using &quot;sh Configure&quot; or &quot;./Configure&quot;). The Korn shell bug has been reported to Compaq as of February 1999 but in the meanwhile, the reason ksh is being used is that you have the environment variable BIN_SH set to 'xpg4'. This causes /bin/sh to delegate its duties to /bin/posix/sh (a ksh). Unset the environment variable and rerun Configure.</source>
          <target state="translated">这表明配置是用一个损坏的Korn shell运行的(即使你认为你使用 &quot;sh Configure &quot;或&quot;./Configure &quot;使用的是Bourne shell)。从1999年2月起,Korn shell的错误已经被报告给康柏公司,但与此同时,使用ksh的原因是你将环境变量BIN_SH设置为 &quot;xpg4&quot;。这将导致/bin/sh将其职责委托给/bin/posix/sh(一个ksh)。取消设置环境变量,重新运行配置。</target>
        </trans-unit>
        <trans-unit id="062f44d9692db42f54456303d55718a170b1e245" translate="yes" xml:space="preserve">
          <source>This indicates the ordering of letters for comparison and sorting. In Latin alphabets, for example, &quot;b&quot;, generally follows &quot;a&quot;.</source>
          <target state="translated">这表示字母的排序,以便比较和排序。例如,在拉丁字母中,&quot;b &quot;一般排在 &quot;a &quot;之后。</target>
        </trans-unit>
        <trans-unit id="e6751de1d4a71c579b34f21fa42d3fbd6eb68764" translate="yes" xml:space="preserve">
          <source>This indicates, for example if a character is an uppercase letter.</source>
          <target state="translated">例如,这表示一个字符是否是大写字母。</target>
        </trans-unit>
        <trans-unit id="f1ba19f7444dcdb1f5fd5e30a3ff4c300dd9b51b" translate="yes" xml:space="preserve">
          <source>This information should not be considered complete; it includes possibly transient information about idiosyncrasies of some of the ports, almost all of which are in a state of constant evolution. Thus, this material should be considered a perpetual work in progress (&lt;code&gt;&amp;lt;IMG SRC=&quot;yellow_sign.gif&quot; ALT=&quot;Under Construction&quot;&amp;gt;&lt;/code&gt; ).</source>
          <target state="translated">此信息不应被认为是完整的；它可能包含有关某些端口特质的瞬态信息，几乎所有端口都处于不断发展的状态。因此，该材料应被视为永久性的 &lt;code&gt;&amp;lt;IMG SRC=&quot;yellow_sign.gif&quot; ALT=&quot;Under Construction&quot;&amp;gt;&lt;/code&gt; （&amp;lt;IMG SRC =&amp;ldquo; yellow_sign.gif&amp;rdquo; ALT =&amp;ldquo;在建中&amp;rdquo;&amp;gt;）。</target>
        </trans-unit>
        <trans-unit id="1f308a14f85f6b55bddba54f6f0dccb1fe994f0d" translate="yes" xml:space="preserve">
          <source>This inserts the contents of the default MANIFEST.SKIP file</source>
          <target state="translated">这将插入默认的MANIFEST.SKIP文件的内容。</target>
        </trans-unit>
        <trans-unit id="a183a2a7c1e850deb76aa146e5c8c7d75a1d8b67" translate="yes" xml:space="preserve">
          <source>This inserts the contents of the specified external file</source>
          <target state="translated">这将插入指定外部文件的内容。</target>
        </trans-unit>
        <trans-unit id="710127152df45ef23f215433723e52cbd88020a4" translate="yes" xml:space="preserve">
          <source>This install method only has the power to install the distribution if there are no dependencies in the way. To install an object along with all its dependencies, use CPAN::Shell-&amp;gt;install.</source>
          <target state="translated">如果安装方式没有依赖性，则此安装方法只能安装发行版。要安装对象及其所有依赖项，请使用CPAN :: Shell-&amp;gt; install。</target>
        </trans-unit>
        <trans-unit id="081204399b94282349e76c93ee84e633b6e3ee15" translate="yes" xml:space="preserve">
          <source>This instance of this layer supports the &quot;fast &lt;code&gt;gets&lt;/code&gt; &quot; interface. Normally set based on &lt;code&gt;PERLIO_K_FASTGETS&lt;/code&gt; for the class and by the existence of the function(s) in the table. However a class that normally provides that interface may need to avoid it on a particular instance. The &quot;pending&quot; layer needs to do this when it is pushed above a layer which does not support the interface. (Perl's &lt;code&gt;sv_gets()&lt;/code&gt; does not expect the streams fast &lt;code&gt;gets&lt;/code&gt; behaviour to change during one &quot;get&quot;.)</source>
          <target state="translated">该层的实例支持&amp;ldquo;快速 &lt;code&gt;gets&lt;/code&gt; &amp;rdquo;接口。通常根据类的 &lt;code&gt;PERLIO_K_FASTGETS&lt;/code&gt; 以及表中函数的存在来进行设置。但是，通常提供该接口的类可能需要在特定实例上避免使用该接口。当&amp;ldquo;待定&amp;rdquo;层被推到不支持该接口的层上方时，需要执行此操作。（Perl的 &lt;code&gt;sv_gets()&lt;/code&gt; 并不希望流快速 &lt;code&gt;gets&lt;/code&gt; 行为在一个&amp;ldquo;获取&amp;rdquo;期间发生变化。）</target>
        </trans-unit>
        <trans-unit id="7a3d641c3fb98c37692677f17bfddfa4c0c2f88d" translate="yes" xml:space="preserve">
          <source>This integer normally starts off at a value of &lt;code&gt;1&lt;/code&gt; when a package stash is instantiated. Calling it on packages whose stashes do not exist at all will return &lt;code&gt;0&lt;/code&gt; . If a package stash is completely deleted (not a normal occurrence, but it can happen if someone does something like &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %PkgName::&lt;/code&gt; ), the number will be reset to either &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; , depending on how completely the package was wiped out.</source>
          <target state="translated">实例化包存储时，此整数通常以 &lt;code&gt;1&lt;/code&gt; 开头。在根本没有任何隐藏的包上调用它会返回 &lt;code&gt;0&lt;/code&gt; 。如果一个软件包的存储被完全删除（这不是正常现象，但是如果有人执行 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %PkgName::&lt;/code&gt; 这类操作则可能发生），则该数字将重置为 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; ，具体取决于软件包被清除的方式。</target>
        </trans-unit>
        <trans-unit id="737a7a5efcfd42959d110feeee676008fd682bf1" translate="yes" xml:space="preserve">
          <source>This interface allows sequential retrieval from the database. See &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; for full details.</source>
          <target state="translated">该接口允许从数据库中顺序检索。有关完整的详细信息，请参见&lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd749bb331e8a5d590f7e5603f780fdc41010317" translate="yes" xml:space="preserve">
          <source>This interface is based on the work and comments of (in no particular order): Larry Wall, Robert Sanders, Dean Roehrich, Jeff Okamoto, Anno Siegel, Thomas Neumann, Paul Marquess, Charles Bailey, myself and others.</source>
          <target state="translated">这个界面是基于以下人员的工作和评论(排名不分先后):Larry Wall、Robert Sanders、Dean Roehrich、Jeff Okamoto、Anno Siegel、Thomas Neumann、Paul Marquess、Charles Bailey、我和其他人。Larry Wall、Robert Sanders、Dean Roehrich、Jeff Okamoto、Anno Siegel、Thomas Neumann、Paul Marquess、Charles Bailey、我本人和其他人。</target>
        </trans-unit>
        <trans-unit id="491fa4fd719b046d8f39f03410b7b5fb6254dca4" translate="yes" xml:space="preserve">
          <source>This interface is handled slightly differently in &lt;b&gt;DB_File&lt;/b&gt;. Here is an equivalent call using &lt;b&gt;DB_File&lt;/b&gt;:</source>
          <target state="translated">该接口在&lt;b&gt;DB_File中的&lt;/b&gt;处理略有不同。这是使用&lt;b&gt;DB_File&lt;/b&gt;的等效调用：</target>
        </trans-unit>
        <trans-unit id="49d69eea5115951977bf6e8780a64dd29c4226c4" translate="yes" xml:space="preserve">
          <source>This interpolation combines with the facts that the opening and closing parentheses are optional (except when necessary for precedence) and lists may end with an optional comma to mean that multiple commas within lists are legal syntax. The list &lt;code&gt;1,,3&lt;/code&gt; is a concatenation of two lists, &lt;code&gt;1,&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; , the first of which ends with that optional comma. &lt;code&gt;1,,3&lt;/code&gt; is &lt;code&gt;(1,),(3)&lt;/code&gt; is &lt;code&gt;1,3&lt;/code&gt; (And similarly for &lt;code&gt;1,,,3&lt;/code&gt; is &lt;code&gt;(1,),(,),3&lt;/code&gt; is &lt;code&gt;1,3&lt;/code&gt; and so on.) Not that we'd advise you to use this obfuscation.</source>
          <target state="translated">此插值法与以下事实结合在一起：左括号和右括号是可选的（优先级除外），列表可能以可选的逗号结尾，表示列表中的多个逗号是合法语法。列表 &lt;code&gt;1,,3&lt;/code&gt; 是两个列表 &lt;code&gt;1,&lt;/code&gt; 和 &lt;code&gt;3&lt;/code&gt; 的串联，其中第一个以该可选的逗号结尾。 &lt;code&gt;1,,3&lt;/code&gt; 是 &lt;code&gt;(1,),(3)&lt;/code&gt; 是 &lt;code&gt;1,3&lt;/code&gt; （类似地，对于 &lt;code&gt;1,,,3&lt;/code&gt; 是 &lt;code&gt;(1,),(,),3&lt;/code&gt; 是 &lt;code&gt;1,3&lt;/code&gt; ，依此类推。）不是我们d建议您使用这种混淆处理。</target>
        </trans-unit>
        <trans-unit id="ff7fca560bcccd2ead2613d40d2441ab2644441f" translate="yes" xml:space="preserve">
          <source>This introduces another problem: what if you just know that your data is UTF-16, but you don't know which endianness? Byte Order Marks, or &lt;code&gt;BOM&lt;/code&gt; 's, are a solution to this. A special character has been reserved in Unicode to function as a byte order marker: the character with the code point &lt;code&gt;U+FEFF&lt;/code&gt; is the &lt;code&gt;BOM&lt;/code&gt; .</source>
          <target state="translated">这带来了另一个问题：如果仅知道您的数据是UTF-16，但不知道哪个字节顺序怎么办？字节顺序标记或 &lt;code&gt;BOM&lt;/code&gt; 是解决此问题的方法。 Unicode中已保留一个特殊字符以用作字节顺序标记：代码点为 &lt;code&gt;U+FEFF&lt;/code&gt; 的字符是 &lt;code&gt;BOM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d98b577e394b09ee4f02d9918217111200cab8f" translate="yes" xml:space="preserve">
          <source>This introductory document does not aim to be complete. It does not even aim to be entirely accurate. In some cases perfection has been sacrificed in the goal of getting the general idea across. You are</source>
          <target state="translated">本介绍性文件并不力求完整。它甚至不打算做到完全准确。在某些情况下,为了表达大意,我们牺牲了完美。您是</target>
        </trans-unit>
        <trans-unit id="2b646e06b5c6dfedf386d47b899ec3f8734e765d" translate="yes" xml:space="preserve">
          <source>This is &lt;b&gt;not&lt;/b&gt; the reverse of PerlIO_exportFILE().</source>
          <target state="translated">这与PerlIO_exportFILE（）&lt;b&gt;并非&lt;/b&gt;相反。</target>
        </trans-unit>
        <trans-unit id="a5d69879cdfbe586062188f3d7ff676e78424d35" translate="yes" xml:space="preserve">
          <source>This is &lt;b&gt;very&lt;/b&gt; similar to previous, only the first two ops differ. This subroutine rendering is more representative, insofar as a single main program will have many subs.</source>
          <target state="translated">这与以前&lt;b&gt;非常&lt;/b&gt;相似，只是前两个操作有所不同。就单个主程序将具有多个子程序而言，此子例程呈现更具代表性。</target>
        </trans-unit>
        <trans-unit id="13a9fc12865137f8c322a100d88693c3b3008c0d" translate="yes" xml:space="preserve">
          <source>This is Perl, so it does the exact right thing. It sees that you want to push &lt;code&gt;Athens&lt;/code&gt; onto an array that doesn't exist, so it helpfully makes a new, empty, anonymous array for you, installs it into &lt;code&gt;%table&lt;/code&gt; , and then pushes &lt;code&gt;Athens&lt;/code&gt; onto it. This is called 'autovivification'--bringing things to life automatically. Perl saw that the key wasn't in the hash, so it created a new hash entry automatically. Perl saw that you wanted to use the hash value as an array, so it created a new empty array and installed a reference to it in the hash automatically. And as usual, Perl made the array one element longer to hold the new city name.</source>
          <target state="translated">这是Perl，所以它做的很正确。它看到您想将 &lt;code&gt;Athens&lt;/code&gt; 推送到一个不存在的数组上，因此它会为您创建一个新的空的匿名数组，将其安装到 &lt;code&gt;%table&lt;/code&gt; 中，然后将 &lt;code&gt;Athens&lt;/code&gt; 推送到该数组上。这就是所谓的&amp;ldquo;自我生存&amp;rdquo;，即自动将事物带入生活。Perl看到密钥不在哈希中，因此它自动创建了一个新的哈希条目。Perl看到您想将哈希值用作数组，因此它创建了一个新的空数组，并在哈希中自动安装了对它的引用。和往常一样，Perl将数组的元素长度增加了一个，以容纳新的城市名称。</target>
        </trans-unit>
        <trans-unit id="d199012301aebd153320803c30f339cb29b9c3f4" translate="yes" xml:space="preserve">
          <source>This is TRUE if the image store data in network order. This means that it was created with nstore() or similar.</source>
          <target state="translated">如果图像按网络顺序存储数据,则该值为TRUE。这意味着它是用nstore()或类似的方法创建的。</target>
        </trans-unit>
        <trans-unit id="701541b651d14d9ce17a8309970ae17dc9d55c05" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to display Pod source as itself! Pretty Zen, huh?</source>
          <target state="translated">这是一个 &quot;插件 &quot;类,它可以让Perldoc以自己的身份显示Pod源。很有禅意,是吧?</target>
        </trans-unit>
        <trans-unit id="a75770ef9b0c598ca7fde366202ade0c04715297" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Man and &lt;code&gt;groff&lt;/code&gt; for reading Pod pages.</source>
          <target state="translated">这是一个&amp;ldquo;插件&amp;rdquo;类，允许Perldoc使用Pod :: Man和 &lt;code&gt;groff&lt;/code&gt; 来读取Pod页面。</target>
        </trans-unit>
        <trans-unit id="81393ce7a71c653a02bafc9503ad7f009bece819" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Man as a formatter class.</source>
          <target state="translated">这是一个 &quot;插件 &quot;类,允许Perldoc使用Pod::Man作为formatter类。</target>
        </trans-unit>
        <trans-unit id="62907aa2e6a91bf9a0b7a6c6e963db493d7938e3" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Simple::Checker as a &quot;formatter&quot; class (or if that is not available, then Pod::Checker), to check for errors in a given Pod file.</source>
          <target state="translated">这是一个 &quot;插件 &quot;类,它允许Perldoc使用Pod::Simple::Checker作为一个 &quot;formatter &quot;类(如果没有,则使用Pod::Checker),来检查给定Pod文件中的错误。</target>
        </trans-unit>
        <trans-unit id="55e3a501ab6032afe89831dc532a3a24c547307d" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Simple::RTF as a formatter class.</source>
          <target state="translated">这是一个 &quot;插件 &quot;类,它允许Perldoc使用Pod::Simple::RTF作为格式化类。</target>
        </trans-unit>
        <trans-unit id="68678eb1c55adc089ba0d404634d06ee4b438a50" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Simple::XMLOutStream as a formatter class.</source>
          <target state="translated">这是一个 &quot;插件 &quot;类,它允许Perldoc使用Pod::Simple::XMLOutStream作为formatter类。</target>
        </trans-unit>
        <trans-unit id="e1aa800043dc8a94d0d283dacfd5ba2b12a78539" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Text as a formatter class.</source>
          <target state="translated">这是一个 &quot;插件 &quot;类,允许Perldoc使用Pod::Text作为格式化类。</target>
        </trans-unit>
        <trans-unit id="dddce66063ab47a1230107d6a866110ade33c3fe" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Tk::Pod as a formatter class.</source>
          <target state="translated">这是一个 &quot;插件 &quot;类,允许Perldoc使用Tk::Pod作为formatter类。</target>
        </trans-unit>
        <trans-unit id="4275fe3ef141a55b62b40502070bf737ec2ea8ca" translate="yes" xml:space="preserve">
          <source>This is a &quot;postponed&quot; regular subexpression. It behaves in</source>
          <target state="translated">这是一个 &quot;推迟的 &quot;常规子表达式。它的行为方式是</target>
        </trans-unit>
        <trans-unit id="a9ec1e3198488308c3643ad69f8d075d9b8f92de" translate="yes" xml:space="preserve">
          <source>This is a 'catch-all' method which returns true if any tests have currently failed, any TODO tests unexpectedly succeeded, or any parse errors occurred.</source>
          <target state="translated">这是一个 &quot;包罗万象 &quot;的方法,如果当前有任何测试失败,有任何TODO测试意外成功,或者有任何解析错误发生,则返回true。</target>
        </trans-unit>
        <trans-unit id="f9b6bdcb215a6cedd90d3fc776185364f2309aa9" translate="yes" xml:space="preserve">
          <source>This is a CPAN module that has better error handling and more facilities than Open3.</source>
          <target state="translated">这是一个CPAN模块,比Open3有更好的错误处理和更多的设施。</target>
        </trans-unit>
        <trans-unit id="b7d2a521ae98c293152277e05794dfa3dbb364fa" translate="yes" xml:space="preserve">
          <source>This is a Perl binding for the cross-platform wxWidgets toolkit ( &lt;a href=&quot;http://www.wxwidgets.org&quot;&gt;http://www.wxwidgets.org&lt;/a&gt; ). It works under Unix, Win32 and Mac OS X, using native widgets (Gtk under Unix). The interface follows the C++ interface closely, but the documentation is a little sparse for someone who doesn't know the library, mostly just referring you to the C++ documentation.</source>
          <target state="translated">这是跨平台wxWidgets工具包（&lt;a href=&quot;http://www.wxwidgets.org&quot;&gt;http://www.wxwidgets.org&lt;/a&gt;）的Perl绑定。它使用本机小部件（在Unix下为Gtk）在Unix，Win32和Mac OS X下工作。该接口紧随C ++接口，但是对于不了解该库的人来说，该文档很少，主要是向您介绍C ++文档。</target>
        </trans-unit>
        <trans-unit id="64369b0966513691c61b8897fc5c7b37a7f32789" translate="yes" xml:space="preserve">
          <source>This is a big step forward, and can give a threaded program quite a performance boost over non-threaded programs. Threads that block performing I/O, for example, won't block threads that are doing other things. Each process still has only one thread running at once, though, regardless of how many CPUs a system might have.</source>
          <target state="translated">这是一个很大的进步,可以让线程程序的性能比非线程程序提升不少。例如,阻塞执行I/O的线程,不会阻塞正在做其他事情的线程。不过无论系统有多少个CPU,每个进程仍然只有一个线程同时运行。</target>
        </trans-unit>
        <trans-unit id="e1c71251d2a2ccec8dd46781a0eb70dbaafe4b05" translate="yes" xml:space="preserve">
          <source>This is a bit tricky. You can't simply write the command like this:</source>
          <target state="translated">这是一个有点棘手的问题。你不能简单地写这样的命令。</target>
        </trans-unit>
        <trans-unit id="9d5816967d821cb6be38c83ea72dd77eb458d174" translate="yes" xml:space="preserve">
          <source>This is a case of convergent evolution with Joshua Pritikin's &lt;a href=&quot;../test&quot;&gt;Test&lt;/a&gt; module. I was largely unaware of its existence when I'd first written my own &lt;code&gt;ok()&lt;/code&gt; routines. This module exists because I can't figure out how to easily wedge test names into Test's interface (along with a few other problems).</source>
          <target state="translated">这是Joshua Pritikin的&amp;ldquo; &lt;a href=&quot;../test&quot;&gt;测试&amp;rdquo;&lt;/a&gt;模块收敛融合的一个案例。当我第一次编写自己的 &lt;code&gt;ok()&lt;/code&gt; 例程时，我基本上不知道它的存在。该模块的存在是因为我无法弄清楚如何轻松地将测试名称插入Test的界面（以及其他一些问题）。</target>
        </trans-unit>
        <trans-unit id="97fc5a87a825ec27b25306a412b0a1048b673845" translate="yes" xml:space="preserve">
          <source>This is a class method that constructs a &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; object and returns a reference to the new interior sequence object. It should be given two keyword arguments. The &lt;code&gt;-ldelim&lt;/code&gt; keyword indicates the corresponding left-delimiter of the interior sequence (e.g. '&amp;lt;'). The &lt;code&gt;-name&lt;/code&gt; keyword indicates the name of the corresponding interior sequence command, such as &lt;code&gt;I&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; or &lt;code&gt;C&lt;/code&gt; . The &lt;code&gt;-file&lt;/code&gt; and &lt;code&gt;-line&lt;/code&gt; keywords indicate the filename and line number corresponding to the beginning of the interior sequence. If the &lt;code&gt;$ptree&lt;/code&gt; argument is given, it must be the last argument, and it must be either string, or else an array-ref suitable for passing to &lt;b&gt;Pod::ParseTree::new&lt;/b&gt; (or it may be a reference to a Pod::ParseTree object).</source>
          <target state="translated">这是一个构造 &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; 对象并返回对新内部序列对象的引用的类方法。应该给它两个关键字参数。所述 &lt;code&gt;-ldelim&lt;/code&gt; 关键字指示内部序列的对应的左分隔符（例如&amp;ldquo;&amp;lt;&amp;rdquo;）。所述 &lt;code&gt;-name&lt;/code&gt; 关键字指示相应的内部序列命令，如名称 &lt;code&gt;I&lt;/code&gt; 或 &lt;code&gt;B&lt;/code&gt; 或 &lt;code&gt;C&lt;/code&gt; 。该 &lt;code&gt;-file&lt;/code&gt; 和 &lt;code&gt;-line&lt;/code&gt; 关键字指示对应于内部序列开始的文件名和行号。如果 &lt;code&gt;$ptree&lt;/code&gt; 给定参数，它必须是最后一个参数，并且必须是字符串，或者是适合传递给&lt;b&gt;Pod :: ParseTree :: new&lt;/b&gt;的array-ref （或者可以是对Pod :: ParseTree对象的引用） 。</target>
        </trans-unit>
        <trans-unit id="29f55cb5b171aa91fa3174d7342b227ed1f417e9" translate="yes" xml:space="preserve">
          <source>This is a class method that constructs a &lt;code&gt;Pod::Paragraph&lt;/code&gt; object and returns a reference to the new paragraph object. It may be given one or two keyword arguments. The &lt;code&gt;-text&lt;/code&gt; keyword indicates the corresponding text of the POD paragraph. The &lt;code&gt;-name&lt;/code&gt; keyword indicates the name of the corresponding POD command, such as &lt;code&gt;head1&lt;/code&gt; or &lt;code&gt;item&lt;/code&gt; (it should</source>
          <target state="translated">这是一个构造 &lt;code&gt;Pod::Paragraph&lt;/code&gt; 对象并返回对新段落对象的引用的类方法。可以给它一个或两个关键字参数。该 &lt;code&gt;-text&lt;/code&gt; 关键字表示POD款的相应文字。所述 &lt;code&gt;-name&lt;/code&gt; 关键字指示相应的POD命令的名称，诸如 &lt;code&gt;head1&lt;/code&gt; 或 &lt;code&gt;item&lt;/code&gt; （它应该</target>
        </trans-unit>
        <trans-unit id="331988b0033be159e38f1f3db9e7086fd5ac78d2" translate="yes" xml:space="preserve">
          <source>This is a class method that constructs a &lt;code&gt;Pod::Parse_tree&lt;/code&gt; object and returns a reference to the new parse-tree. If a single-argument is given, it must be a reference to an array, and is used to initialize the root (top) of the parse tree.</source>
          <target state="translated">这是一个构造 &lt;code&gt;Pod::Parse_tree&lt;/code&gt; 对象并返回对新分析树的引用的类方法。如果给出单参数，则它必须是对数组的引用，并用于初始化解析树的根（顶部）。</target>
        </trans-unit>
        <trans-unit id="135e61a3e6ed1b5dcdd255926dda22779c807d83" translate="yes" xml:space="preserve">
          <source>This is a classic race condition: you take two steps to do something which must be done in one. That's why computer hardware provides an atomic test-and-set instruction. In theory, this &quot;ought&quot; to work:</source>
          <target state="translated">这是一个典型的竞赛条件:你用两步来做必须一步完成的事情。这就是为什么计算机硬件提供了一个原子测试和设置指令。理论上,这 &quot;应该 &quot;是可行的。</target>
        </trans-unit>
        <trans-unit id="06ed0aa0bcc2d08b1ae41c2e1fbf2ac9199a80b7" translate="yes" xml:space="preserve">
          <source>This is a cleanup variable for try test programs. Internal Configure use only.</source>
          <target state="translated">这是尝试测试程序的清理变量。仅供内部配置使用。</target>
        </trans-unit>
        <trans-unit id="15d31d32837b2199fecd9abd8b0259d5c2027995" translate="yes" xml:space="preserve">
          <source>This is a collection of words of wisdom for a Perl porter; some of it is only useful to the pumpkin holder, but most of it applies to anyone wanting to go about Perl development.</source>
          <target state="translated">这是一个Perl搬运工的智慧之言的集合;其中有些只对南瓜持有者有用,但大部分适用于任何想要进行Perl开发的人。</target>
        </trans-unit>
        <trans-unit id="78a03e08bc2123708a34ec2db4804cf0d2100751" translate="yes" xml:space="preserve">
          <source>This is a common error when trying to build perl on Solaris 2.6 with a gcc installation from Solaris 2.5 or 2.5.1. The Solaris header files changed, so you need to update your gcc installation. You can either rerun the fixincludes script from gcc or take the opportunity to update your gcc installation.</source>
          <target state="translated">这是一个常见的错误,当你试图在Solaris 2.6上使用Solaris 2.5或2.5.1的gcc安装来构建perl时。Solaris的头文件发生了变化,所以你需要更新你的gcc安装。你可以重新运行gcc中的fixincludes脚本,或者借此机会更新你的gcc安装。</target>
        </trans-unit>
        <trans-unit id="ff129a99820711b57abb25f1b58ba7136b7e8cde" translate="yes" xml:space="preserve">
          <source>This is a difficult question to answer, and the best answer is only a guess.</source>
          <target state="translated">这个问题很难回答,最好的答案也只是猜测。</target>
        </trans-unit>
        <trans-unit id="999f0dc4cf91e26f969aecc31f8b8b85ae8a6af3" translate="yes" xml:space="preserve">
          <source>This is a factory class that takes a &lt;a href=&quot;source&quot;&gt;TAP::Parser::Source&lt;/a&gt; and runs it through all the registered &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s to see which one should handle the source.</source>
          <target state="translated">这是一个工厂类，它使用&lt;a href=&quot;source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt;并通过所有已注册的&lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler对其&lt;/a&gt;运行，以查看哪个应处理源。</target>
        </trans-unit>
        <trans-unit id="c43e76a8b7a7a6439251d5db4f28f61ba4f7ca79" translate="yes" xml:space="preserve">
          <source>This is a fancy bracketed character class that can be used for more readable and less error-prone classes, and to perform set operations, such as intersection. An example is</source>
          <target state="translated">这是一个花哨的括号字符类,可以用于可读性更强、更不容易出错的类,也可以用于执行集合操作,比如交集。一个例子是</target>
        </trans-unit>
        <trans-unit id="bd5b0b089eff91377cede66c47419fc9845c1784" translate="yes" xml:space="preserve">
          <source>This is a fixed variant of T_HVREF that decrements the refcount appropriately when returning an HV*. Introduced in perl 5.15.4.</source>
          <target state="translated">这是 T_HVREF 的一个固定变体,当返回 HV*时,它会适当地减少 refcount。在 perl 5.15.4 中引入。</target>
        </trans-unit>
        <trans-unit id="926e4c62112da36d18d2c1c89330bc60c9162eb2" translate="yes" xml:space="preserve">
          <source>This is a fully ported Perl for OS/390 Version 2 Release 3, 5, 6, 7, 8, and 9. It may work on other versions or releases, but those are the ones we've tested it on.</source>
          <target state="translated">这是一个完全移植的Perl,适用于OS/390第2版第3、5、6、7、8和9版。它可能会在其他版本或版本上工作,但这些都是我们测试过的版本。</target>
        </trans-unit>
        <trans-unit id="372ffff7fde6d07d99e54e14755b9d58626070f2" translate="yes" xml:space="preserve">
          <source>This is a function which adds a string, &lt;code&gt;ptr&lt;/code&gt; , of length &lt;code&gt;len&lt;/code&gt; onto the end of the PV stored in &lt;code&gt;sv&lt;/code&gt; . The first thing we do in line 6 is make sure that the SV &lt;b&gt;has&lt;/b&gt; a valid PV, by calling the &lt;code&gt;SvPV_force&lt;/code&gt; macro to force a PV. As a side effect, &lt;code&gt;tlen&lt;/code&gt; gets set to the current value of the PV, and the PV itself is returned to &lt;code&gt;junk&lt;/code&gt; .</source>
          <target state="translated">此函数将长度为 &lt;code&gt;len&lt;/code&gt; 的字符串 &lt;code&gt;ptr&lt;/code&gt; 添加到 &lt;code&gt;sv&lt;/code&gt; 中存储的PV的末尾。在第6行中，我们要做的第一件事是通过调用 &lt;code&gt;SvPV_force&lt;/code&gt; 宏强制PV来确保SV &lt;b&gt;具有&lt;/b&gt;有效的PV。副作用是，将 &lt;code&gt;tlen&lt;/code&gt; 设置为PV的当前值，并且PV本身返回给 &lt;code&gt;junk&lt;/code&gt; 。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2774055b00e3419620eb5d95ca0978a88958d21c" translate="yes" xml:space="preserve">
          <source>This is a fundamental limitation of the way hashes are constructed in Perl. The error messages produced when this happens will often be quite cryptic -- in the worst case there may be none at all, and you'll only later find that something is broken.</source>
          <target state="translated">这是Perl中构造哈希的方式的一个基本限制。当这种情况发生时,产生的错误信息通常是相当神秘的 --在最坏的情况下,可能根本没有任何错误信息,你只会在后来发现有些东西被破坏了。</target>
        </trans-unit>
        <trans-unit id="5634f9ec91b3e104474c739e05fd80458193ebf9" translate="yes" xml:space="preserve">
          <source>This is a get-or-set method for the compartment's operator mask.</source>
          <target state="translated">这是隔间的操作面具的获取或设置方法。</target>
        </trans-unit>
        <trans-unit id="e894d85c5e9df5228e61b20283457ef4058bfbeb" translate="yes" xml:space="preserve">
          <source>This is a good introduction and will direct you towards other man pages that may interest you.</source>
          <target state="translated">这是个很好的介绍,会引导你去看其他你可能感兴趣的男人网页。</target>
        </trans-unit>
        <trans-unit id="8c7d928409a2a83d36eb046953e31000e8fced30" translate="yes" xml:space="preserve">
          <source>This is a hash reference which contains a template as explained in the &lt;code&gt;SYNOPSIS&lt;/code&gt; and &lt;code&gt;Template&lt;/code&gt; section.</source>
          <target state="translated">这是一个哈希参考，其中包含一个模板，如&amp;ldquo; &lt;code&gt;SYNOPSIS&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;Template&lt;/code&gt; 部分所述。</target>
        </trans-unit>
        <trans-unit id="abdb64e67c36b80a4a66af77ecfc2b1aa4e68e20" translate="yes" xml:space="preserve">
          <source>This is a hash used internally to track named capture groups and their offsets. The keys are the names of the buffers the values are dualvars, with the IV slot holding the number of buffers with the given name and the pv being an embedded array of I32. The values may also be contained independently in the data array in cases where named backreferences are used.</source>
          <target state="translated">这是一个内部使用的哈希值,用于跟踪命名的捕获组和它们的偏移量。键是缓冲区的名称,值是双变量,IV槽是给定名称的缓冲区数量,pv是I32的嵌入式数组。在使用命名后引用的情况下,这些值也可以独立包含在数据数组中。</target>
        </trans-unit>
        <trans-unit id="ee128cd6218c9f00f0c878c04ed7c1d2ba1c0dcc" translate="yes" xml:space="preserve">
          <source>This is a hashref of module/version pairs. The version indicates the minimum version to load. If no version is provided, any version is assumed to be good enough.</source>
          <target state="translated">这是一个模块/版本对的哈希夫。版本表示要加载的最小版本。如果没有提供版本,则认为任何版本都足够好。</target>
        </trans-unit>
        <trans-unit id="ea245b58697360367e48479db117e287399d341e" translate="yes" xml:space="preserve">
          <source>This is a hashref registering what modules/utilities were known to fail for fetching files (mostly because they weren't installed).</source>
          <target state="translated">这是个哈希夫,记录了哪些模块/实用程序在获取文件时失败(主要是因为它们没有安装)。</target>
        </trans-unit>
        <trans-unit id="9eb7a0a93db9a83c1c6303ceaf2e042280cc43c1" translate="yes" xml:space="preserve">
          <source>This is a list of questions and answers about Unicode in Perl, intended to be read after &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;.</source>
          <target state="translated">这是Perl中有关Unicode的问答列表，打算在&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;之后阅读。</target>
        </trans-unit>
        <trans-unit id="36d9a4f8cf6a08db2c492aa7d56c16aa12a7c5d3" translate="yes" xml:space="preserve">
          <source>This is a little bit more complex in the case of UTF-8, see what &lt;code&gt;Perl_reg_numbered_buff_length&lt;/code&gt; does with &lt;a href=&quot;perlapi#is_utf8_string_loclen&quot;&gt;is_utf8_string_loclen&lt;/a&gt;.</source>
          <target state="translated">对于UTF-8，这有点复杂，请参阅 &lt;code&gt;Perl_reg_numbered_buff_length&lt;/code&gt; 对&lt;a href=&quot;perlapi#is_utf8_string_loclen&quot;&gt;is_utf8_string_loclen的作用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2ee3c54bcb807a66fe7b80e3caf8861bbb44a5c" translate="yes" xml:space="preserve">
          <source>This is a message from your shell telling you that the command 'ar' was not found. You need to check your PATH environment variable to make sure that it includes the directory with the 'ar' command. This is a common problem on Solaris, where 'ar' is in the /usr/ccs/bin/ directory.</source>
          <target state="translated">这是你的shell发出的信息,告诉你没有找到'ar'命令。你需要检查你的PATH环境变量,以确保它包括'ar'命令的目录。这是Solaris上常见的问题,因为'ar'在/usr/ccs/bin/目录下。</target>
        </trans-unit>
        <trans-unit id="7be9582165bd5c245d33269d0775adef5b86c2d1" translate="yes" xml:space="preserve">
          <source>This is a misleadingly-named synonym for &lt;a href=&quot;#is_invariant_string&quot;&gt;is_invariant_string&lt;/a&gt;. On ASCII-ish platforms, the name isn't misleading: the ASCII-range characters are exactly the UTF-8 invariants. But EBCDIC machines have more invariants than just the ASCII characters, so &lt;code&gt;is_invariant_string&lt;/code&gt; is preferred.</source>
          <target state="translated">这是&lt;a href=&quot;#is_invariant_string&quot;&gt;is_invariant_string的&lt;/a&gt;具有误导性的同义词。在ASCII平台上，该名称不会引起误解：ASCII范围字符恰好是UTF-8不变式。但是EBCDIC机器不仅仅具有ASCII字符而具有更多的不变量，因此 &lt;code&gt;is_invariant_string&lt;/code&gt; 是首选。</target>
        </trans-unit>
        <trans-unit id="de824f4204bca39b6173554bd682eeaf59e1fe59" translate="yes" xml:space="preserve">
          <source>This is a no-op on Win32.</source>
          <target state="translated">这在Win32上是不可能的。</target>
        </trans-unit>
        <trans-unit id="7c97b390951ae9bd8a25bf05c714cdf4d686ebf3" translate="yes" xml:space="preserve">
          <source>This is a noop provided for completeness.</source>
          <target state="translated">这是为完整而提供的noop。</target>
        </trans-unit>
        <trans-unit id="09b98a2fdc86ae4c3444a314c0304e18f2968e2d" translate="yes" xml:space="preserve">
          <source>This is a placeholder option.</source>
          <target state="translated">这是一个占位选项。</target>
        </trans-unit>
        <trans-unit id="309f4be6a68d1ca1ce9f563923f5229fee286990" translate="yes" xml:space="preserve">
          <source>This is a ported perl for the POSIX subsystem in BS2000 VERSION OSD V3.1A or later. It may work on other versions, but we started porting and testing it with 3.1A and are currently using Version V4.0A.</source>
          <target state="translated">这是为BS2000 VERSION OSD V3.1A或更高版本的POSIX子系统移植的perl。它可能会在其他版本上工作,但我们从3.1A开始移植和测试它,目前使用的是V4.0A版本。</target>
        </trans-unit>
        <trans-unit id="639c8df7e83fc87480520c466044037ac91d5b6f" translate="yes" xml:space="preserve">
          <source>This is a protocol used by some firewall ftp proxies. It is used to authorise the user to send data out. If both arguments are not specified then &lt;code&gt;authorize&lt;/code&gt; uses &lt;code&gt;Net::Netrc&lt;/code&gt; to do a lookup.</source>
          <target state="translated">这是某些防火墙ftp代理使用的协议。它用于授权用户发送数据。如果两个参数都未指定，则 &lt;code&gt;authorize&lt;/code&gt; 使用 &lt;code&gt;Net::Netrc&lt;/code&gt; 进行查找。</target>
        </trans-unit>
        <trans-unit id="35b9db060b8091b2af5afc80f2eb9e19755899c4" translate="yes" xml:space="preserve">
          <source>This is a quick reference to Perl's regular expressions. For full information see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, as well as the &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; section in this document.</source>
          <target state="translated">这是对Perl正则表达式的快速参考。有关完整信息，请参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;和&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;，以及本文档中的&amp;ldquo; 另请&lt;a href=&quot;#SEE-ALSO&quot;&gt;参阅&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="d47823b6d4d1bf90c0ec374b8fb409bfdb682e4b" translate="yes" xml:space="preserve">
          <source>This is a re-implementation of stdio-like buffering written as a PerlIO layer. As such it will call whatever layer is below it for its operations, typically &lt;code&gt;:unix&lt;/code&gt; .</source>
          <target state="translated">这是写为PerlIO层的类stdio缓冲的重新实现。这样，它将调用其下面的任何层进行操作，通常是 &lt;code&gt;:unix&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f72833b07fdaaa27353877ad8c40f0425a069181" translate="yes" xml:space="preserve">
          <source>This is a reference card for people who are familiar with the C library and who want to do things the Perl way; to tell them which functions they ought to use instead of the more normal C functions.</source>
          <target state="translated">这是为那些熟悉C库,但又想用Perl方式做事的人准备的参考卡片;告诉他们应该使用哪些函数,而不是更普通的C函数。</target>
        </trans-unit>
        <trans-unit id="c471b4ac155563a00fba4ae9a0887cfc3abb5085" translate="yes" xml:space="preserve">
          <source>This is a reference to a hash of named arguments which need checking.</source>
          <target state="translated">这是对需要检查的命名参数的哈希的引用。</target>
        </trans-unit>
        <trans-unit id="3afd1b8fae5b72ccc5141dfe79c691921d5825d2" translate="yes" xml:space="preserve">
          <source>This is a replacement for an earlier Pod::Text module written by Tom Christiansen. It has a revamped interface, since it now uses Pod::Parser, but an interface roughly compatible with the old Pod::Text::pod2text() function is still available. Please change to the new calling convention, though.</source>
          <target state="translated">这是Tom Christiansen编写的早期Pod::Text模块的替代品。它有一个全新的界面,因为它现在使用了Pod::Parser,但是一个与旧的Pod::Text::pod2text()函数大致兼容的界面仍然可用。不过请改成新的调用约定。</target>
        </trans-unit>
        <trans-unit id="c47cbb12fb76c06a9104b6dcce71cb1371c44a36" translate="yes" xml:space="preserve">
          <source>This is a replacement for an earlier Pod::Text module written by Tom Christiansen. It has a revamped interface, since it now uses Pod::Simple, but an interface roughly compatible with the old Pod::Text::pod2text() function is still available. Please change to the new calling convention, though.</source>
          <target state="translated">这是Tom Christiansen编写的早期Pod::Text模块的替代品。它有一个全新的界面,因为它现在使用了Pod::Simple,但是一个与旧的Pod::Text::pod2text()函数大致兼容的界面仍然可用。不过请改成新的调用约定。</target>
        </trans-unit>
        <trans-unit id="3b47b707c5aa2685e694887a6a732f13742fa45a" translate="yes" xml:space="preserve">
          <source>This is a runtime equivalent to &lt;code&gt;\N{...}&lt;/code&gt; .</source>
          <target state="translated">这是等效于 &lt;code&gt;\N{...}&lt;/code&gt; 的运行时。</target>
        </trans-unit>
        <trans-unit id="f7a879136a0009e169d98349a2353c9b002b70d9" translate="yes" xml:space="preserve">
          <source>This is a set of four-letter (capitalized) codes from ISO 15924 such as 'Phnx' for Phoenician. It also includes additions to this set included in the IANA language registry.</source>
          <target state="translated">这是一套来自ISO 15924的四字母(大写)代码,如腓尼基语的 &quot;Phnx&quot;。它还包括列入IANA语言登记册的这套代码的补充内容。</target>
        </trans-unit>
        <trans-unit id="6ef813cd850a9f27ba1c4663d4e71f25b5053fb3" translate="yes" xml:space="preserve">
          <source>This is a set of three-digit numeric codes from ISO 15924 such as 115 for Phoenician.</source>
          <target state="translated">这是一组来自ISO 15924的三位数数字代码,如115代表腓尼基人。</target>
        </trans-unit>
        <trans-unit id="349f283b1feb640d3ec35d62b03e25d6ddada207" translate="yes" xml:space="preserve">
          <source>This is a set of three-letter (uppercase) codes from ISO 4217 such as EUR for Euro.</source>
          <target state="translated">这是一组来自ISO 4217的三个字母(大写)代码,如EUR代表欧元。</target>
        </trans-unit>
        <trans-unit id="6241a7679be2105aef445a1326e4d5af9e0ed08e" translate="yes" xml:space="preserve">
          <source>This is a short tutorial on writing a simple module with MakeMaker. It's really not that hard.</source>
          <target state="translated">这是一个关于用MakeMaker编写一个简单模块的简短教程。其实并不难。</target>
        </trans-unit>
        <trans-unit id="53100bf0748f5ba489bc4dc460d2dfa8f3afc641" translate="yes" xml:space="preserve">
          <source>This is a short way of setting &lt;code&gt;gnu_compat&lt;/code&gt;&lt;code&gt;bundling&lt;/code&gt;&lt;code&gt;permute&lt;/code&gt;&lt;code&gt;no_getopt_compat&lt;/code&gt; . With &lt;code&gt;gnu_getopt&lt;/code&gt; , command line handling should be fully compatible with GNU getopt_long().</source>
          <target state="translated">这是设置的一小段路 &lt;code&gt;gnu_compat&lt;/code&gt; &lt;code&gt;bundling&lt;/code&gt; &lt;code&gt;permute&lt;/code&gt; &lt;code&gt;no_getopt_compat&lt;/code&gt; 。使用 &lt;code&gt;gnu_getopt&lt;/code&gt; ，命令行处理应该与GNU getopt_long（）完全兼容。</target>
        </trans-unit>
        <trans-unit id="7af9997becadfe87d824ab8762ffccd7719bb2b4" translate="yes" xml:space="preserve">
          <source>This is a shortcut for &lt;code&gt;$token-&amp;gt;type() eq &quot;end&quot;&lt;/code&gt;</source>
          <target state="translated">这是 &lt;code&gt;$token-&amp;gt;type() eq &quot;end&quot;&lt;/code&gt; 的快捷方式</target>
        </trans-unit>
        <trans-unit id="588934f1b5f409b7ed4ee0102675e3e7a80e417d" translate="yes" xml:space="preserve">
          <source>This is a shortcut for &lt;code&gt;$token-&amp;gt;type() eq &quot;start&quot;&lt;/code&gt;</source>
          <target state="translated">这是 &lt;code&gt;$token-&amp;gt;type() eq &quot;start&quot;&lt;/code&gt; 的快捷方式</target>
        </trans-unit>
        <trans-unit id="cf3172ad5af1d75bb916c8179d00c2eb32b1726b" translate="yes" xml:space="preserve">
          <source>This is a shortcut for &lt;code&gt;$token-&amp;gt;type() eq &quot;text&quot;&lt;/code&gt;</source>
          <target state="translated">这是 &lt;code&gt;$token-&amp;gt;type() eq &quot;text&quot;&lt;/code&gt; 的快捷方式</target>
        </trans-unit>
        <trans-unit id="14414929d404b298096e05330ae3a552582cc596" translate="yes" xml:space="preserve">
          <source>This is a shortcut method for creating a new parser object, setting the output handle to STDOUT, and then processing the specified file (or filehandle, or in-memory document). This is handy for one-liners like this:</source>
          <target state="translated">这是一个快捷方法,用于创建一个新的解析器对象,将输出句柄设置为STDOUT,然后处理指定的文件(或filehandle,或内存中的文档)。这对于像这样的单行本很方便。</target>
        </trans-unit>
        <trans-unit id="dcc6d2562c6f7206f328c3550bdc5e8e52460de3" translate="yes" xml:space="preserve">
          <source>This is a side-effect of &lt;code&gt;$^W&lt;/code&gt; being dynamically scoped.</source>
          <target state="translated">这是 &lt;code&gt;$^W&lt;/code&gt; 动态作用域的副作用。</target>
        </trans-unit>
        <trans-unit id="8fa6df25c130c949bab77362ff50f938867d104d" translate="yes" xml:space="preserve">
          <source>This is a simple base class used by &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; to store objects that represent the current bit of test output data from TAP (usually a single line). Unless you're subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">这是&lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt;使用的简单基类，用于存储表示TAP的测试输出数据的当前位的对象（通常为一行）。除非您要进行子类化，否则可能不需要直接使用此模块。</target>
        </trans-unit>
        <trans-unit id="5a6a517a000eee7c9d8650e790b06bace86ece1d" translate="yes" xml:space="preserve">
          <source>This is a simple factory class which returns a &lt;a href=&quot;result&quot;&gt;TAP::Parser::Result&lt;/a&gt; subclass representing the current bit of test data from TAP (usually a single line). It is used primarily by &lt;a href=&quot;grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt;. Unless you're subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">这是一个简单的工厂类，它返回一个&lt;a href=&quot;result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;子类，该子类表示TAP中测试数据的当前位（通常为一行）。它主要由&lt;a href=&quot;grammar&quot;&gt;TAP :: Parser :: Grammar使用&lt;/a&gt;。除非您要进行子类化，否则可能不需要直接使用此模块。</target>
        </trans-unit>
        <trans-unit id="ae7e075e46130a389abcce2b8eca77b2b0799334" translate="yes" xml:space="preserve">
          <source>This is a simple iterator base class that defines &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;'s iterator API. Iterators are typically created from &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s.</source>
          <target state="translated">这是一个简单的迭代器基类，它定义了&lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt;的迭代器API。迭代器通常是从&lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;创建的。</target>
        </trans-unit>
        <trans-unit id="3ef2b28fd5eff705f1f406ac6e66e9bba64a8d81" translate="yes" xml:space="preserve">
          <source>This is a simple iterator wrapper for arrays of scalar content, used by &lt;a href=&quot;../../parser&quot;&gt;TAP::Parser&lt;/a&gt;. Unless you're writing a plugin or subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">这是&lt;a href=&quot;../../parser&quot;&gt;TAP :: Parser&lt;/a&gt;使用的简单的标量内容数组的迭代器包装器。除非您正在编写插件或子类，否则可能不需要直接使用此模块。</target>
        </trans-unit>
        <trans-unit id="6211175f40b02f3bcb25615dc63d424f5b04b85e" translate="yes" xml:space="preserve">
          <source>This is a simple iterator wrapper for executing external processes, used by &lt;a href=&quot;../../parser&quot;&gt;TAP::Parser&lt;/a&gt;. Unless you're writing a plugin or subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">这是一个简单的迭代器包装器，用于执行&lt;a href=&quot;../../parser&quot;&gt;TAP :: Parser&lt;/a&gt;使用的外部进程。除非您正在编写插件或子类，否则可能不需要直接使用此模块。</target>
        </trans-unit>
        <trans-unit id="08f74f820359ec13407ecd95ebc00861df2faa4a" translate="yes" xml:space="preserve">
          <source>This is a simple iterator wrapper for reading from filehandles, used by &lt;a href=&quot;../../parser&quot;&gt;TAP::Parser&lt;/a&gt;. Unless you're writing a plugin or subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">这是一个简单的迭代器包装器，用于读取文件句柄，由&lt;a href=&quot;../../parser&quot;&gt;TAP :: Parser使用&lt;/a&gt;。除非您正在编写插件或子类，否则可能不需要直接使用此模块。</target>
        </trans-unit>
        <trans-unit id="fb6d528be7b9b50f443385c12d7c3581d3c5b271" translate="yes" xml:space="preserve">
          <source>This is a simple test harness which allows tests to be run and results automatically aggregated and output to STDOUT.</source>
          <target state="translated">这是一个简单的测试线束,它允许测试运行,结果自动汇总并输出到STDOUT。</target>
        </trans-unit>
        <trans-unit id="94c2e1c3d42721757938806d86cea256f2130297" translate="yes" xml:space="preserve">
          <source>This is a small simple module which simplifies the manipulation of @INC at compile time.</source>
          <target state="translated">这是一个简单的小模块,它简化了编译时对@INC的操作。</target>
        </trans-unit>
        <trans-unit id="ed45414649005cf46b9b142e78787c7d0efdd654" translate="yes" xml:space="preserve">
          <source>This is a standard message issued by OS/2 applications. *nix applications die in silence. It is considered to be a feature. One can easily disable this by appropriate sighandlers.</source>
          <target state="translated">这是OS/2应用程序发出的标准信息。*nix应用程序在沉默中死亡。这被认为是一个特性。人们可以通过适当的sighandlers轻松地禁用它。</target>
        </trans-unit>
        <trans-unit id="ae30c10c2c1eb9a5c4373e69ebda02e4f56fd6ac" translate="yes" xml:space="preserve">
          <source>This is a static function and is defined as &lt;code&gt;STATIC S_whatever&lt;/code&gt; , and usually called within the sources as &lt;code&gt;whatever(...)&lt;/code&gt; .</source>
          <target state="translated">这是一个静态函数，定义为 &lt;code&gt;STATIC S_whatever&lt;/code&gt; ，通常在源代码中称为what &lt;code&gt;whatever(...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93db2ec99a46178540e6d933d3db3e813cba4109" translate="yes" xml:space="preserve">
          <source>This is a statically linked &lt;code&gt;a.out&lt;/code&gt; -style executable. It cannot load dynamic Perl extensions. The executable supplied in binary distributions has a lot of extensions prebuilt, thus the above restriction is important only if you use custom-built extensions. This executable is a VIO application.</source>
          <target state="translated">这是一个静态链接的 &lt;code&gt;a.out&lt;/code&gt; 样式的可执行文件。它无法加载动态Perl扩展。二进制发行版中提供的可执行文件具有许多预先构建的扩展，因此仅当您使用定制构建的扩展时，上述限制才重要。该可执行文件是VIO应用程序。</target>
        </trans-unit>
        <trans-unit id="fc094e72af8b9d6622201511120df9125d5e32ff" translate="yes" xml:space="preserve">
          <source>This is a string combining version, subversion and perl_patchlevel (if perl_patchlevel is non-zero). It is typically something like 'version 7 subversion 1' or 'version 7 subversion 1 patchlevel 11224' It is computed here to avoid duplication of code in</source>
          <target state="translated">这是一个结合了版本、subversion 和 perl_patchlevel 的字符串 (如果 perl_patchlevel 为非零)。它通常是类似于 'version 7 subversion 1' 或 'version 7 subversion 1 patchlevel 11224' 这样的字符串。</target>
        </trans-unit>
        <trans-unit id="344924719b1bae83eead5b685f2904260f7cb31e" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a YAML block is encountered.</source>
          <target state="translated">这是&lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;的子类。如果遇到YAML块，则将返回此类的令牌。</target>
        </trans-unit>
        <trans-unit id="cf06d3cd2a668f16a1a9ea1434ebed8459984ced" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a bail out line is encountered.</source>
          <target state="translated">这是&lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;的子类。如果遇到紧急援助线，将返回此类的令牌。</target>
        </trans-unit>
        <trans-unit id="1c79fb77a91aa29bad4fe0d58e746157c12b1af2" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a comment line is encountered.</source>
          <target state="translated">这是&lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;的子类。如果遇到注释行，将返回此类的标记。</target>
        </trans-unit>
        <trans-unit id="f5e73059f9980ac5f029fc80717ab9da6cff6341" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a plan line is encountered.</source>
          <target state="translated">这是&lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;的子类。如果遇到计划行，将返回此类的标记。</target>
        </trans-unit>
        <trans-unit id="dc05d4de16b8c5b025bf96846c216318ce2e7788" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a pragma is encountered.</source>
          <target state="translated">这是&lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;的子类。如果遇到编译指示，则将返回此类的标记。</target>
        </trans-unit>
        <trans-unit id="173909c91c915dbe5ae4e1761f6ce3015f27ac8e" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a test line is encountered.</source>
          <target state="translated">这是&lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;的子类。如果遇到测试行，将返回此类的标记。</target>
        </trans-unit>
        <trans-unit id="d99a6f5c44525e8196b8a9f8f432a4c8297fe174" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a version line is encountered.</source>
          <target state="translated">这是&lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;的子类。如果遇到版本行，则将返回此类的标记。</target>
        </trans-unit>
        <trans-unit id="f9dc0dfab2b15f7dcded6106f389d289ed7b45a8" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if the parser does not recognize the token line. For example:</source>
          <target state="translated">这是&lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;的子类。如果解析器无法识别标记行，则将返回此类的标记。例如：</target>
        </trans-unit>
        <trans-unit id="ed4cd1012a41fb5a1a7060605167f8be93252008" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt; and inherits all its methods.</source>
          <target state="translated">这是&lt;a href=&quot;../simple&quot;&gt;Pod :: Simple&lt;/a&gt;的子类，并继承其所有方法。</target>
        </trans-unit>
        <trans-unit id="81afca9fe5e8caf5fd548b6ee9f92134f9dc21dc" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;methody&quot;&gt;Pod::Simple::Methody&lt;/a&gt; and inherits all its methods. The implementation is entirely different than &lt;a href=&quot;html&quot;&gt;Pod::Simple::HTML&lt;/a&gt;, but it largely preserves the same interface.</source>
          <target state="translated">这是&lt;a href=&quot;methody&quot;&gt;Pod :: Simple :: Methody&lt;/a&gt;的子类，并继承其所有方法。该实现与&lt;a href=&quot;html&quot;&gt;Pod :: Simple :: HTML&lt;/a&gt;完全不同，但是在很大程度上保留了相同的接口。</target>
        </trans-unit>
        <trans-unit id="5a42087b4a78a20207066122ca4141600c24be72" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; and inherits all its methods (and options).</source>
          <target state="translated">这是&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;的子类，并继承其所有方法（和选项）。</target>
        </trans-unit>
        <trans-unit id="ea32c34eae791ae221ac4a3cce2869532666d30e" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;pullparsertoken&quot;&gt;Pod::Simple::PullParserToken&lt;/a&gt; and inherits all its methods, and adds these methods:</source>
          <target state="translated">这是&lt;a href=&quot;pullparsertoken&quot;&gt;Pod :: Simple :: PullParserToken&lt;/a&gt;的子类，并继承其所有方法，并添加以下方法：</target>
        </trans-unit>
        <trans-unit id="aa9cce04d90d56b725964eab73e0fca5ac743d29" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for AIX.</source>
          <target state="translated">这是ExtUtils::MM_Unix的一个子类,它包含了AIX的功能。</target>
        </trans-unit>
        <trans-unit id="0d4a1a4cfdafa1cb09a4fb89fe42af2c7616286a" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for DOS.</source>
          <target state="translated">这是ExtUtils::MM_Unix的一个子类,它包含了DOS的功能。</target>
        </trans-unit>
        <trans-unit id="1586bedfb51abdc0ca225f9c3db5c388bf3fe7c7" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for QNX.</source>
          <target state="translated">这是 ExtUtils::MM_Unix 的一个子类,它包含 QNX 的功能。</target>
        </trans-unit>
        <trans-unit id="c6edbaa56530abda8144785f91c81fc02ebf9b90" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for VOS.</source>
          <target state="translated">这是ExtUtils::MM_Unix的一个子类,它包含了VOS的功能。</target>
        </trans-unit>
        <trans-unit id="2e5c7251645932dc8d1dc7c962cbf2e45c3f4094" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for the AT&amp;amp;T U/WIN UNIX on Windows environment.</source>
          <target state="translated">这是ExtUtils :: MM_Unix的子类，它包含Windows环境下AT＆T U / WIN UNIX的功能。</target>
        </trans-unit>
        <trans-unit id="93a42e55d1097c11d0072e86d7f542b3230e6bcf" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Win32 containing changes necessary to get MakeMaker playing nice with command.com and other Win9Xisms.</source>
          <target state="translated">这是ExtUtils::MM_Win32的一个子类,它包含了让MakeMaker与command.com和其他Win9Xisms良好配合的必要改变。</target>
        </trans-unit>
        <trans-unit id="fb8a82ae7e4bcc23be8b85858941e5009748ca04" translate="yes" xml:space="preserve">
          <source>This is a suggestion to the OS to let this thread yield CPU time to other threads. What actually happens is highly dependent upon the underlying thread implementation.</source>
          <target state="translated">这是对操作系统的建议,让这个线程把CPU时间让给其他线程。实际发生的情况很大程度上取决于底层线程的实现。</target>
        </trans-unit>
        <trans-unit id="a6edb8217d2751ef4a763256a458a4449c4b36b5" translate="yes" xml:space="preserve">
          <source>This is a superclass for &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;-based modules. It provides a handful of common functionality and a method of getting at the underlying &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; object.</source>
          <target state="translated">这是基于&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;的模块的超类。它提供了一些常用功能以及一种获取底层&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;对象的方法。</target>
        </trans-unit>
        <trans-unit id="55903e986f0ab6ec743472dc06cf20bffa759a05" translate="yes" xml:space="preserve">
          <source>This is a synonym for (! foldEQ())</source>
          <target state="translated">这是(!foldEQ())的同义词。</target>
        </trans-unit>
        <trans-unit id="53444e6b25598bcd7a21f4559d1c88a0a3357fc9" translate="yes" xml:space="preserve">
          <source>This is a synonym for (! foldEQ_locale())</source>
          <target state="translated">这是(! foldEQ_locale())的同义词。</target>
        </trans-unit>
        <trans-unit id="0fc9211f34524643d77b88ccf3fbe69c0926ca68" translate="yes" xml:space="preserve">
          <source>This is a synonym for &lt;code&gt;\p{Present_In=*}&lt;/code&gt;</source>
          <target state="translated">这是 &lt;code&gt;\p{Present_In=*}&lt;/code&gt; 的同义词</target>
        </trans-unit>
        <trans-unit id="ef2cd0a3571852b5da355e5994ba81184e031c06" translate="yes" xml:space="preserve">
          <source>This is a template for a function suitable for the &lt;code&gt;uf_val&lt;/code&gt; field in a &lt;code&gt;ufuncs&lt;/code&gt; structure for this call. The &lt;code&gt;uf_set&lt;/code&gt; and &lt;code&gt;uf_index&lt;/code&gt; fields are irrelevant.</source>
          <target state="translated">这是适用于此调用的 &lt;code&gt;ufuncs&lt;/code&gt; 结构中 &lt;code&gt;uf_val&lt;/code&gt; 字段的函数的模板。该 &lt;code&gt;uf_set&lt;/code&gt; 和 &lt;code&gt;uf_index&lt;/code&gt; 字段是无关的。</target>
        </trans-unit>
        <trans-unit id="9a3d72bf731a4c00183b3bacd2aaed590afe1490" translate="yes" xml:space="preserve">
          <source>This is a term used for characters occupying more than one byte.</source>
          <target state="translated">这是一个用于占用一个以上字节的字符的术语。</target>
        </trans-unit>
        <trans-unit id="da67b166e535d5aab2dfd4a4bef7fa2c7dc18440" translate="yes" xml:space="preserve">
          <source>This is a useful alternative to the &lt;code&gt;verbose&lt;/code&gt; key.</source>
          <target state="translated">这是 &lt;code&gt;verbose&lt;/code&gt; 键的有用替代方法。</target>
        </trans-unit>
        <trans-unit id="618f9f0ef250e390bb1ce0844593906ed698aa6a" translate="yes" xml:space="preserve">
          <source>This is a user-pragma. If you're very lucky some code you're using will know that you asked for less CPU usage or ram or fat or... we just can't know. Consult your documentation on everything you're currently using.</source>
          <target state="translated">这是一个用户原则。如果你很幸运的话,一些你正在使用的代码会知道你要求减少CPU的使用量或内存或脂肪或......我们只是不知道。请查阅你目前使用的一切文档。</target>
        </trans-unit>
        <trans-unit id="e65d4664502f4836edff6c3f42d466dce62c114e" translate="yes" xml:space="preserve">
          <source>This is achieved by creating separate watchdog process which spawns the specified program in a separate process session and supervises it: optionally feeds it with input, stores its exit code, stdout and stderr, terminates it in case it runs longer than specified.</source>
          <target state="translated">这是通过创建单独的看门狗进程来实现的,看门狗进程在一个单独的进程会话中生成指定的程序,并监督它:有选择地给它提供输入,存储它的退出代码、stdout和stderr,在它运行的时间超过指定时间时终止它。</target>
        </trans-unit>
        <trans-unit id="bb7efcdf0700fbaadbdc0f648a8badbdf9664612" translate="yes" xml:space="preserve">
          <source>This is actually a Pod::Simple::Checker (or Pod::Checker) subclass, and inherits all its options.</source>
          <target state="translated">这实际上是一个Pod::Simple::Checker(或Pod:::Checker)子类,并继承了它的所有选项。</target>
        </trans-unit>
        <trans-unit id="e4a943560ee56b7076fa64d64bd3da44e85a30ca" translate="yes" xml:space="preserve">
          <source>This is actually a Pod::Simple::RTF subclass, and inherits all its options.</source>
          <target state="translated">这实际上是一个Pod::Simple::RTF子类,并继承了它的所有选项。</target>
        </trans-unit>
        <trans-unit id="92b8d72a94a8da6c54d9f33ab092eb620ca878de" translate="yes" xml:space="preserve">
          <source>This is actually a Pod::Simple::XMLOutStream subclass, and inherits all its options.</source>
          <target state="translated">这实际上是一个Pod::Simple::XMLOutStream子类,并继承了它的所有选项。</target>
        </trans-unit>
        <trans-unit id="8eda3362231deb25dfd89db58202611c06a3d40c" translate="yes" xml:space="preserve">
          <source>This is all very powerful, of course, and should be used only in moderation to make the world a better place.</source>
          <target state="translated">当然,这都是非常强大的,只应适度使用,让世界变得更美好。</target>
        </trans-unit>
        <trans-unit id="a0a76465b05604833b1a2e0c25409dcb3ddad85c" translate="yes" xml:space="preserve">
          <source>This is also a no-op on Win32.</source>
          <target state="translated">这在Win32上也是没有办法的事情。</target>
        </trans-unit>
        <trans-unit id="a906c4fc08f6c0cd00609aae3ea9167c7850d130" translate="yes" xml:space="preserve">
          <source>This is also helpful for the case where a package lives within a differently named file:</source>
          <target state="translated">这对于一个包住在不同名称的文件中的情况也很有帮助。</target>
        </trans-unit>
        <trans-unit id="783e4cc092057905b6553d7a8d798ecf7ac0db31" translate="yes" xml:space="preserve">
          <source>This is also invalid:</source>
          <target state="translated">这也是无效的。</target>
        </trans-unit>
        <trans-unit id="c1d7e1e2839d2377297de367eca0902f0ba00891" translate="yes" xml:space="preserve">
          <source>This is also the logical inverse of Perl_isfinite().</source>
          <target state="translated">这也是Perl_isfinite()的逻辑反演。</target>
        </trans-unit>
        <trans-unit id="c778320b203a5e38261d5a20fb7ed1b70340a749" translate="yes" xml:space="preserve">
          <source>This is also used to store the name of an autoloaded subroutine in an XS AUTOLOAD routine. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;Autoloading with XSUBs in perlguts&lt;/a&gt;.</source>
          <target state="translated">这也用于在XS AUTOLOAD例程中存储自动加载的子例程的名称。请参见&lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;在perlguts中使用XSUB自动加载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6dda58eafcf63f43293998602056ada9565deb26" translate="yes" xml:space="preserve">
          <source>This is also useful for applications emulating &lt;code&gt;tail -f&lt;/code&gt; . Once you hit EOF on your read and then sleep for a while, you (probably) have to stick in a dummy seek() to reset things. The &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; doesn't change the position, but it</source>
          <target state="translated">这对于模拟 &lt;code&gt;tail -f&lt;/code&gt; 的应用程序也很有用。一旦您在阅读中击中EOF并睡了一会儿，您（可能）就必须坚持使用虚拟的seek（）来重置事物。在 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 不改变立场，但它</target>
        </trans-unit>
        <trans-unit id="545e9279207dbe359d514df130705d9c342445f3" translate="yes" xml:space="preserve">
          <source>This is also useful for applications emulating &lt;code&gt;tail -f&lt;/code&gt; . Once you hit EOF on your read and then sleep for a while, you (probably) have to stick in a dummy seek() to reset things. The &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; doesn't change the position, but it</source>
          <target state="translated">这对于模拟 &lt;code&gt;tail -f&lt;/code&gt; 的应用程序也很有用。一旦您在阅读中击中EOF并睡了一会儿，您（可能）就必须坚持使用虚拟的seek（）来重置事物。在 &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 不改变立场，但它</target>
        </trans-unit>
        <trans-unit id="3a6f47fb722d0ea7678e717327e932adc89f5068" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;omf&lt;/code&gt; -style executable which is dynamically linked to</source>
          <target state="translated">这是 &lt;code&gt;omf&lt;/code&gt; 样式的可执行文件，它动态链接到</target>
        </trans-unit>
        <trans-unit id="8d756c24376672373a010de25a2097378db4129a" translate="yes" xml:space="preserve">
          <source>This is an XS interface to Perl's &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">这是Perl的 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 函数的XS接口。</target>
        </trans-unit>
        <trans-unit id="af496b01592b41744cf75154ff216cf0d89995f5" translate="yes" xml:space="preserve">
          <source>This is an XS interface to Perl's &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">这是Perl &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 功能的XS接口。</target>
        </trans-unit>
        <trans-unit id="3e6cd5c9b47acd371c49a0cb03b008b70d97eb82" translate="yes" xml:space="preserve">
          <source>This is an advisory and may not be called in the case where tests are being supplied to Test::Harness by an iterator.</source>
          <target state="translated">这是一个警告,在测试由迭代器提供给Test::Harness的情况下,可能不会被调用。</target>
        </trans-unit>
        <trans-unit id="e308dd432d69b5157566a6a8a06cea4450cd898c" translate="yes" xml:space="preserve">
          <source>This is an architecture-independent macro to copy one structure to another.</source>
          <target state="translated">这是一个独立于架构的宏,用于将一个结构复制到另一个结构。</target>
        </trans-unit>
        <trans-unit id="142891d3e046c25d09b04f0976a954076a30931f" translate="yes" xml:space="preserve">
          <source>This is an array ref holding blacklisted modules/utilities for fetching files with.</source>
          <target state="translated">这是一个数组 ref,其中包含了用于获取文件的黑名单模块/实用程序。</target>
        </trans-unit>
        <trans-unit id="df12371f4d4ec63415fcab8f4e275a767f08fe3d" translate="yes" xml:space="preserve">
          <source>This is an array reference containing all the output sent to STDOUT the command generated. The notes from &lt;a href=&quot;#full_buffer&quot;&gt;full_buffer&lt;/a&gt; apply.</source>
          <target state="translated">这是一个数组引用，其中包含所有发送到STDOUT的命令生成的输出。&lt;a href=&quot;#full_buffer&quot;&gt;full_buffer中&lt;/a&gt;的注释适用。</target>
        </trans-unit>
        <trans-unit id="5d8a9ac748db8e604ab1a3be03c2cd4ff11d70fa" translate="yes" xml:space="preserve">
          <source>This is an array reference containing all the output the command generated. Note that buffers are only available if you have &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; installed, or if your system is able to work with &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt; -- see below). Otherwise, this element will be &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个数组引用，其中包含命令生成的所有输出。请注意，只有在安装了&lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC :: Run&lt;/a&gt;或系统能够使用&lt;a href=&quot;open3&quot;&gt;IPC :: Open3时，缓冲区才可用&lt;/a&gt; -参见下文）。否则，此元素将为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c18758c49f12c582c5080bf3c3ccaff6f97f99da" translate="yes" xml:space="preserve">
          <source>This is an arrayreference containing all the output sent to STDERR the command generated. The notes from &lt;a href=&quot;#full_buffer&quot;&gt;full_buffer&lt;/a&gt; apply.</source>
          <target state="translated">这是一个数组引用，其中包含将生成的命令发送到STDERR的所有输出。&lt;a href=&quot;#full_buffer&quot;&gt;full_buffer中&lt;/a&gt;的注释适用。</target>
        </trans-unit>
        <trans-unit id="35261ed11f8f6da05d71e00af479e064b704d1d3" translate="yes" xml:space="preserve">
          <source>This is an error because the region is opened by &quot;thing&quot;, and the &quot;=end&quot; tries to close &quot;hting&quot; [sic].</source>
          <target state="translated">这是一个错误,因为该区域是由 &quot;thing &quot;打开的,而&quot;=end &quot;试图关闭 &quot;hting&quot;[原文如此]。</target>
        </trans-unit>
        <trans-unit id="b79a05e5e946ef4d9b0147040712489ddfe70bec" translate="yes" xml:space="preserve">
          <source>This is an experimental feature and the interface may change.</source>
          <target state="translated">这是一个实验性的功能,界面可能会改变。</target>
        </trans-unit>
        <trans-unit id="038057198b05cf435f922989a902c34a0ad8bec5" translate="yes" xml:space="preserve">
          <source>This is an experimental feature available starting in 5.18, and is subject to change as we gain field experience with it. Any attempt to use it will raise a warning, unless disabled via</source>
          <target state="translated">这是一个从5.18开始的实验性功能,随着我们获得的实际经验,可能会有所改变。任何试图使用它的行为都会引起警告,除非通过以下方式禁用</target>
        </trans-unit>
        <trans-unit id="52d334621bd62974acc022322ae25fb3c75cd6d1" translate="yes" xml:space="preserve">
          <source>This is an extremely simple, extremely basic module for writing tests suitable for CPAN modules and other pursuits. If you wish to do more complicated testing, use the Test::More module (a drop-in replacement for this one).</source>
          <target state="translated">这是一个极其简单、极其基础的模块,用于编写适合CPAN模块和其他追求的测试。如果你想做更复杂的测试,请使用Test::More模块(这个模块的一个替换)。</target>
        </trans-unit>
        <trans-unit id="fc193a250bf3f7bae0644ab68952c14087e27f56" translate="yes" xml:space="preserve">
          <source>This is an internal function used by &lt;code&gt;&lt;a href=&quot;format&quot;&gt;format&lt;/a&gt;&lt;/code&gt;s, though you may call it, too. It formats (see &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;) a list of values according to the contents of PICTURE, placing the output into the format output accumulator, &lt;code&gt;$^A&lt;/code&gt; (or &lt;code&gt;$ACCUMULATOR&lt;/code&gt; in English). Eventually, when a &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; is done, the contents of &lt;code&gt;$^A&lt;/code&gt; are written to some filehandle. You could also read &lt;code&gt;$^A&lt;/code&gt; and then set &lt;code&gt;$^A&lt;/code&gt; back to &lt;code&gt;&quot;&quot;&lt;/code&gt; . Note that a format typically does one &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; per line of form, but the &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; function itself doesn't care how many newlines are embedded in the PICTURE. This means that the &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; tokens treat the entire PICTURE as a single line. You may therefore need to use multiple formlines to implement a single record format, just like the &lt;code&gt;&lt;a href=&quot;format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; compiler.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; s 使用的内部函数，尽管您也可以调用它。它根据PICTURE的内容对值列表进行格式化（请参阅&lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;），然后将输出放入格式输出累加器 &lt;code&gt;$^A&lt;/code&gt; （或 &lt;code&gt;$ACCUMULATOR&lt;/code&gt; 英文）中。最终，完成 &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 操作后， &lt;code&gt;$^A&lt;/code&gt; 的内容将被写到某个文件句柄中。您还可以阅读 &lt;code&gt;$^A&lt;/code&gt; ，然后将 &lt;code&gt;$^A&lt;/code&gt; 设置回 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。需要注意的是格式通常做一个 &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 每个表格的行，但 &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 函数本身并不关心在PICTURE中嵌入了多少换行符。这意味着 &lt;code&gt;~&lt;/code&gt; 和 &lt;code&gt;~~&lt;/code&gt; 标记将整个PICTURE视为一行。因此，您可能需要使用多个格式行来实现单个记录格式，就像 &lt;code&gt;&lt;a href=&quot;format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 编译器一样。</target>
        </trans-unit>
        <trans-unit id="cd310f7276a510d01ce03cf67c2975df5756cafc" translate="yes" xml:space="preserve">
          <source>This is an internal function used by &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt;s, though you may call it, too. It formats (see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;) a list of values according to the contents of PICTURE, placing the output into the format output accumulator, &lt;code&gt;$^A&lt;/code&gt; (or &lt;code&gt;$ACCUMULATOR&lt;/code&gt; in English). Eventually, when a &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; is done, the contents of &lt;code&gt;$^A&lt;/code&gt; are written to some filehandle. You could also read &lt;code&gt;$^A&lt;/code&gt; and then set &lt;code&gt;$^A&lt;/code&gt; back to &lt;code&gt;&quot;&quot;&lt;/code&gt; . Note that a format typically does one &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; per line of form, but the &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; function itself doesn't care how many newlines are embedded in the PICTURE. This means that the &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; tokens treat the entire PICTURE as a single line. You may therefore need to use multiple formlines to implement a single record format, just like the &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; compiler.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; s 使用的内部函数，尽管您也可以调用它。它根据PICTURE的内容对值列表进行格式化（请参阅&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;），然后将输出放入格式输出累加器 &lt;code&gt;$^A&lt;/code&gt; （或 &lt;code&gt;$ACCUMULATOR&lt;/code&gt; 英文）中。最终，完成 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 操作后， &lt;code&gt;$^A&lt;/code&gt; 的内容将被写到某个文件句柄中。您还可以阅读 &lt;code&gt;$^A&lt;/code&gt; ，然后将 &lt;code&gt;$^A&lt;/code&gt; 设置回 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。需要注意的是格式通常做一个 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 每个表格的行，但 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 函数本身并不关心在PICTURE中嵌入了多少换行符。这意味着 &lt;code&gt;~&lt;/code&gt; 和 &lt;code&gt;~~&lt;/code&gt; 标记将整个PICTURE视为一行。因此，您可能需要使用多个格式行来实现单个记录格式，就像 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 编译器一样。</target>
        </trans-unit>
        <trans-unit id="10fae8cad46b6999dd334a3e0cee274316414176" translate="yes" xml:space="preserve">
          <source>This is an internal module for controlling the debug level (a.k.a. trace level) of Pod::Simple. This is of interest only to Pod::Simple developers.</source>
          <target state="translated">这是一个内部模块,用于控制Pod::Simple的调试级别(也就是跟踪级别)。这只有Pod::Simple开发者才会感兴趣。</target>
        </trans-unit>
        <trans-unit id="91ad54ddf5b339889a4d7e36baa90c6c5e3e7226" translate="yes" xml:space="preserve">
          <source>This is an internal routine that turns scalars into objects.</source>
          <target state="translated">这是一个内部例程,可以将标量变成对象。</target>
        </trans-unit>
        <trans-unit id="8cdba91d1ae6fc951cd637b385ae75d511979603" translate="yes" xml:space="preserve">
          <source>This is an introduction to the use of performance and optimization techniques which can be used with particular reference to perl programs. While many perl developers have come from other languages, and can use their prior knowledge where appropriate, there are many other people who might benefit from a few perl specific pointers. If you want the condensed version, perhaps the best advice comes from the renowned Japanese Samurai, Miyamoto Musashi, who said:</source>
          <target state="translated">这是一个关于性能和优化技术使用的介绍,可以特别参考perl程序。虽然许多perl开发人员来自其他语言,可以在适当的地方使用他们之前的知识,但也有许多其他人可能会从一些perl特定的指针中受益。如果你想要精简版,也许最好的建议来自日本著名的武士宫本武藏,他说。</target>
        </trans-unit>
        <trans-unit id="1366a76cfef4230c6beae74ce2285fa6d6be94b2" translate="yes" xml:space="preserve">
          <source>This is an old synonym for _a.</source>
          <target state="translated">这是一个古老的同义词_a。</target>
        </trans-unit>
        <trans-unit id="18fb271daf0d1e76d3278d9f0bd4670eecfaa747" translate="yes" xml:space="preserve">
          <source>This is an old synonym for _exe.</source>
          <target state="translated">这是一个古老的同义词_exe。</target>
        </trans-unit>
        <trans-unit id="e951b381a4c4d96fa5592d033afe7d8fa718b152" translate="yes" xml:space="preserve">
          <source>This is an old synonym for _o.</source>
          <target state="translated">这是一个古老的同义词_o。</target>
        </trans-unit>
        <trans-unit id="cb104080e92edd7dc3925f96e9fda2c7d309ad5a" translate="yes" xml:space="preserve">
          <source>This is an old synonym for p_ in</source>
          <target state="translated">这是p_的旧同义词。</target>
        </trans-unit>
        <trans-unit id="f5d749cd3a1da6fa9f5e91de2edcf596acd57750" translate="yes" xml:space="preserve">
          <source>This is an upper limit on the amount of memory that &lt;code&gt;Tie::File&lt;/code&gt; will consume at any time while managing the file. This is used for two things: managing the</source>
          <target state="translated">这是管理 &lt;code&gt;Tie::File&lt;/code&gt; 随时使用的内存量的上限。这用于两件事：</target>
        </trans-unit>
        <trans-unit id="50601fd9eec31dfdb13471caa9bb11bc5c6a291d" translate="yes" xml:space="preserve">
          <source>This is another step where the presence of the &lt;code&gt;/x&lt;/code&gt; modifier is relevant. The RE engine scans the string from left to right and converts it into a finite automaton.</source>
          <target state="translated">这是存在 &lt;code&gt;/x&lt;/code&gt; 修饰符的另一个步骤。RE引擎从左到右扫描字符串，并将其转换为有限的自动机。</target>
        </trans-unit>
        <trans-unit id="6bc6e3e8d1b2d61b10ef0d4362b29339c92de71f" translate="yes" xml:space="preserve">
          <source>This is bad because splice is already O(N), and since you do it N times, you just invented a quadratic algorithm; that is, O(N**2). This does not scale, although Perl is so efficient that you probably won't notice this until you have rather largish arrays.</source>
          <target state="translated">这很糟糕,因为拼接已经是O(N)了,而且由于你做了N次,你只是发明了一个二次元算法;也就是说,O(N**2)。这并不具有扩展性,尽管Perl的效率很高,你可能不会注意到这一点,直到你有了相当大的数组。</target>
        </trans-unit>
        <trans-unit id="3c8339d12c8a36725299f222df00f24cfd8f69bf" translate="yes" xml:space="preserve">
          <source>This is basically shorthand for saying:</source>
          <target state="translated">这基本上是速记的说法。</target>
        </trans-unit>
        <trans-unit id="df105f720cfd558cf78bf5414610fa1937dfed89" translate="yes" xml:space="preserve">
          <source>This is because math with overloaded operators follows the first (dominating) operand, and the operation of that is called and returns thus the result. So, Math::BigInt::bdiv() will always return a Math::BigInt, regardless whether the result should be a Math::BigFloat or the second operant is one.</source>
          <target state="translated">这是因为具有重载操作符的数学遵循第一个(支配性)操作符,并调用该操作符的操作,从而返回结果。所以,Math::BigInt::bdiv()总是会返回一个Math::BigInt,不管结果应该是一个Math::BigFloat还是第二个操作数是一个。</target>
        </trans-unit>
        <trans-unit id="9d0c7a7cdf189de0cf4679b172df320157dc1c04" translate="yes" xml:space="preserve">
          <source>This is because named subroutines are created at compile time so their lexical variables get assigned to the parent lexicals from the first execution of the parent block. If a parent scope is entered a second time, its lexicals are created again, while the nested subs still reference the old ones.</source>
          <target state="translated">这是因为命名的子程序是在编译时创建的,所以它们的词法变量会在第一次执行父块时被分配给父词法。如果第二次输入父作用域,它的词法会被再次创建,而嵌套的子程序仍然引用旧的子程序。</target>
        </trans-unit>
        <trans-unit id="c5db892d6d5c6549aeb31514ada7ecd4f892effe" translate="yes" xml:space="preserve">
          <source>This is best demonstrated by example. Normally copy-on-write will prevent the substitution from operator from using this hack, but if you can craft a string for which copy-on-write is not possible, you can see it in play. In the current implementation, the final byte of a string buffer is used as a copy-on-write reference count. If the buffer is not big enough, then copy-on-write is skipped. First have a look at an empty string:</source>
          <target state="translated">这是最好的例子。一般来说,copy-on-write会阻止操作者使用这个黑客进行替换,但是如果你可以制作一个不可能copy-on-write的字符串,你可以看到它的作用。在当前的实现中,字符串缓冲区的最后一个字节被用作写后复制的引用计数。如果缓冲区不够大,那么就会跳过copy-on-write。首先来看一个空字符串。</target>
        </trans-unit>
        <trans-unit id="110ec42eab0899b77be520515c85d69e76f3210b" translate="yes" xml:space="preserve">
          <source>This is best explained using the following example:</source>
          <target state="translated">这一点最好用下面的例子来解释。</target>
        </trans-unit>
        <trans-unit id="5ccb22d8b75566be2249f3211df19f165abb3a07" translate="yes" xml:space="preserve">
          <source>This is called an &quot;array slice&quot;.</source>
          <target state="translated">这就是所谓的 &quot;数组分片&quot;。</target>
        </trans-unit>
        <trans-unit id="891aecbf1a8602556b6b3c6e2627cb164d6eebbc" translate="yes" xml:space="preserve">
          <source>This is called at the end of a lexical scope, just after unwinding the stack.</source>
          <target state="translated">这是在一个词法作用域结束时调用的,就在释放堆栈之后。</target>
        </trans-unit>
        <trans-unit id="7256e74371eb8bec49de48cf27c3c7d965b76d10" translate="yes" xml:space="preserve">
          <source>This is called at the end of a lexical scope, just before unwinding the stack.</source>
          <target state="translated">这是在一个词法作用域结束时调用的,就在释放堆栈之前。</target>
        </trans-unit>
        <trans-unit id="39c51821499fb79c1bf1a7b16255cbfad901f488" translate="yes" xml:space="preserve">
          <source>This is called by -&amp;gt;new to initialize newly-constructed language handles. If you define an init method in your class, remember that it's usually considered a good idea to call $lh-&amp;gt;SUPER::init in it (presumably at the beginning), so that all classes get a chance to initialize a new object however they see fit.</source>
          <target state="translated">这由-&amp;gt; new调用，以初始化新构造的语言句柄。如果您在类中定义了一个init方法，请记住通常在其中调用$ lh-&amp;gt; SUPER :: init是一个好主意（大概是在开始时），以便所有类都有机会初始化一个新对象。他们认为合适。</target>
        </trans-unit>
        <trans-unit id="0f9664c006f22f51b95f420aa8dd1316340a796c" translate="yes" xml:space="preserve">
          <source>This is called just after starting a new lexical scope. Note that Perl code like</source>
          <target state="translated">在启动一个新的词法作用域之后,就会调用这个函数。请注意,像这样的 Perl 代码</target>
        </trans-unit>
        <trans-unit id="1b4b72a19d24ff4c03ca59dfaf92e37705fe82d9" translate="yes" xml:space="preserve">
          <source>This is called just before starting to compile an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;
FILE&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, after the eval has been set up.</source>
          <target state="translated">在建立 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; ，就在开始编译eval STRING， &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 之前调用此方法。</target>
        </trans-unit>
        <trans-unit id="63bc4c621adbf8f868c20e693d52ccd14e7f8bee" translate="yes" xml:space="preserve">
          <source>This is called just like any other method, with the object as the first argument. It does not receive any additional arguments. However, the &lt;code&gt;$_[0]&lt;/code&gt; variable will be read-only in the destructor, so you cannot assign a value to it.</source>
          <target state="translated">就像任何其他方法一样，以对象作为第一个参数来调用它。它不接收任何其他参数。但是， &lt;code&gt;$_[0]&lt;/code&gt; 变量在析构函数中将是只读的，因此您不能为其分配值。</target>
        </trans-unit>
        <trans-unit id="a2a0ca9ad6271402577255f9f1a63a32921a68ca" translate="yes" xml:space="preserve">
          <source>This is called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">发生 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 时称为此事件。请参阅&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;下面的解开陷阱&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85277e9fbb24fb6a920480ff94a71d2b7d6a947a" translate="yes" xml:space="preserve">
          <source>This is called when a stash is assigned to a new location in the symbol table.</source>
          <target state="translated">当一个储藏室被分配到符号表的一个新位置时,就会调用这个功能。</target>
        </trans-unit>
        <trans-unit id="89a93e1f017cbb5b7b2446a6eb7bdd8163601a7e" translate="yes" xml:space="preserve">
          <source>This is called when a stash is deleted from the symbol table.</source>
          <target state="translated">当从符号表中删除一个存储时,就会调用这个函数。</target>
        </trans-unit>
        <trans-unit id="92909fe70994d8eb483f136285b4a0530d9ad33d" translate="yes" xml:space="preserve">
          <source>This is called when the hash is evaluated in scalar context. In order to mimic the behaviour of untied hashes, this method should return a false value when the tied hash is considered empty. If this method does not exist, perl will make some educated guesses and return true when the hash is inside an iteration. If this isn't the case, FIRSTKEY is called, and the result will be a false value if FIRSTKEY returns the empty list, true otherwise.</source>
          <target state="translated">当哈希在标量上下文中被评估时,会调用这个方法。为了模仿未绑定哈希的行为,当绑定哈希被认为是空的时候,这个方法应该返回一个false值。如果这个方法不存在,perl会做一些有根据的猜测,当哈希在迭代内部时返回true。如果不是这种情况,则调用FIRSTKEY,如果FIRSTKEY返回空列表,结果将是一个false值,否则为true。</target>
        </trans-unit>
        <trans-unit id="43b19ffb80b780fe42418c60b4b551943190ef11" translate="yes" xml:space="preserve">
          <source>This is caused by the fact that a block by itself acts as a loop that executes once, see &lt;a href=&quot;#Basic-BLOCKs&quot;&gt;Basic BLOCKs&lt;/a&gt;.</source>
          <target state="translated">这是由于以下事实造成的：一个块本身就充当一次执行一次的循环，请参见&lt;a href=&quot;#Basic-BLOCKs&quot;&gt;Basic BLOCKs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52af186e7022d7cef4d799cfdb6b5d984aef07fe" translate="yes" xml:space="preserve">
          <source>This is commonly used to suppress the creation of man pages. MAN3PODS takes a hash ref not a string, but the above worked by accident in old versions of MakeMaker.</source>
          <target state="translated">这通常用于抑制man页的创建。MAN3PODS取的是哈希ref而不是字符串,但在旧版本的MakeMaker中,上面的工作是意外的。</target>
        </trans-unit>
        <trans-unit id="e5f528c0702057989be1850bcd519b0dfbd35566" translate="yes" xml:space="preserve">
          <source>This is complete documentation about all aspects of references. For a shorter, tutorial introduction to just the essential features, see &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;.</source>
          <target state="translated">这是有关参考所有方面的完整文档。有关基本功能的简短教程介绍，请参见&lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="49ca539e3859d247b8a2739f333e60f8db59abef" translate="yes" xml:space="preserve">
          <source>This is completely general, but the most computationally expensive strategy. Choose one or the other character set and transform to that for every sort comparision. Here's a complete example that transforms to ASCII sort order:</source>
          <target state="translated">这是完全通用的,但计算成本最高的策略。选择一个或另一个字符集,并在每次排序比较中转换为该字符集。这里有一个完整的例子,可以转换为ASCII排序顺序。</target>
        </trans-unit>
        <trans-unit id="94195eae88e55c65702824bf560045165c39578d" translate="yes" xml:space="preserve">
          <source>This is converted to a tree similar to this one:</source>
          <target state="translated">这样转换为类似于这棵树。</target>
        </trans-unit>
        <trans-unit id="6748d7a69c27bb3281328ef679799289a62c1105" translate="yes" xml:space="preserve">
          <source>This is currently supported by pod2text (Pod::Text), pod2man (Pod::Man), and any other pod2xxx or Pod::Xxxx translators that use Pod::Parser 1.093 or later, or Pod::Tree 1.02 or later.</source>
          <target state="translated">目前,pod2text(Pod::Text)、pod2man(Pod::Man)以及任何其他使用Pod::Parser 1.093或更高版本的pod2xxx或Pod::Xxxx翻译器,或Pod::Tree 1.02或更高版本的翻译器都支持这个功能。</target>
        </trans-unit>
        <trans-unit id="593812f69db240f293446ffb5751455ff8815826" translate="yes" xml:space="preserve">
          <source>This is different from finding out the package an object is blessed into, which might not be the current package. For that, use &lt;code&gt;blessed&lt;/code&gt; from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;, part of the Standard Library since Perl 5.8:</source>
          <target state="translated">这与找出对象被祝福的包不同，后者可能不是当前的包。为此，请使用&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util的&lt;/a&gt; &lt;code&gt;blessed&lt;/code&gt; (从Perl 5.8开始成为标准库的一部分）：</target>
        </trans-unit>
        <trans-unit id="fb97ecda4c6d5be858b3ffd4a4b01f62707feb1c" translate="yes" xml:space="preserve">
          <source>This is different than printing the array without the interpolation:</source>
          <target state="translated">这与打印没有插值的数组不同。</target>
        </trans-unit>
        <trans-unit id="2e89efe08d07d2fc445ecb0a49388c2db1540bc9" translate="yes" xml:space="preserve">
          <source>This is disabled by default.</source>
          <target state="translated">默认情况下是禁用的。</target>
        </trans-unit>
        <trans-unit id="a9b83c7f438982c73dfeaa8ce24f6687d2ff66f7" translate="yes" xml:space="preserve">
          <source>This is discussed in more detail in &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;; see the entry on</source>
          <target state="translated">在&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;中将对此进行更详细的讨论；请参阅以下条目</target>
        </trans-unit>
        <trans-unit id="76fae6a858b50aa10f361d29a97f6c807c02664b" translate="yes" xml:space="preserve">
          <source>This is documented in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;, and although it's not the easiest thing to read, it does work. In each of these examples, we call the function inside the braces used to dereference a reference. If we have more than one return value, we can construct and dereference an anonymous array. In this case, we call the function in list context.</source>
          <target state="translated">这是在&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;中记录的，尽管它不是最容易阅读的东西，但它确实可以工作。在这些示例中的每个示例中，我们在括号内调用用于取消引用引用的函数。如果我们有多个返回值，则可以构造和取消引用一个匿名数组。在这种情况下，我们在列表上下文中调用该函数。</target>
        </trans-unit>
        <trans-unit id="cc9f74e233591efd345d524b870503e793053031" translate="yes" xml:space="preserve">
          <source>This is done by using hostname lookup and the &lt;code&gt;local_netmask&lt;/code&gt; entry in the configuration data.</source>
          <target state="translated">这是通过使用主机名查找和配置数据中的 &lt;code&gt;local_netmask&lt;/code&gt; 条目来完成的。</target>
        </trans-unit>
        <trans-unit id="454855df818209bc8493bdfbab3f2ca7ae6dfdc7" translate="yes" xml:space="preserve">
          <source>This is done for a breakpoint in the current file.</source>
          <target state="translated">这是对当前文件中的断点进行的。</target>
        </trans-unit>
        <trans-unit id="4a47be7db788c450b66cdea2d395c9b71203ef53" translate="yes" xml:space="preserve">
          <source>This is due to a bug in the C library's printf routine. printf(&quot;'%e'&quot;, 0. ) produces '0.000000e+0', but ANSI requires '0.000000e+00'. QNX has acknowledged the bug.</source>
          <target state="translated">这是由于 C 库的 printf 例程出现了一个错误。printf(&quot;'%e'&quot;,0.)会生成 &quot;0.000000e+0&quot;,但 ANSI 要求是 &quot;0.000000e+00&quot;。QNX 已承认这一错误。</target>
        </trans-unit>
        <trans-unit id="71e4fa6fb5f00ffdde6cecd71fb22bb161db5777" translate="yes" xml:space="preserve">
          <source>This is due to the performance optimisation of using &lt;code&gt;MULTICALL&lt;/code&gt; for the code block, which means that fresh SVs do not get allocated for each call to the block. Instead, the same SV is re-assigned for each iteration, and all the closures will share the value seen on the final iteration.</source>
          <target state="translated">这是由于对代码块使用 &lt;code&gt;MULTICALL&lt;/code&gt; 进行了性能优化，这意味着不会为每次调用该块分配新的SV。取而代之的是，为每个迭代重新分配相同的SV，并且所有闭包将共享在最终迭代中看到的值。</target>
        </trans-unit>
        <trans-unit id="447f198b012c8346529f18f6ac62c32d7efbbdb9" translate="yes" xml:space="preserve">
          <source>This is elaborately and painstakingly described in the</source>
          <target state="translated">中对此进行了详尽而细致的描述。</target>
        </trans-unit>
        <trans-unit id="821291d0776e9b5b0d39c1a20f26c0a1d006ccf3" translate="yes" xml:space="preserve">
          <source>This is enabled by default.</source>
          <target state="translated">默认情况下是启用的。</target>
        </trans-unit>
        <trans-unit id="05dc6a6637a3cd1c406048840a442a226332304e" translate="yes" xml:space="preserve">
          <source>This is equivalent to putting &lt;code&gt;?:&lt;/code&gt; at the beginning of every capturing group:</source>
          <target state="translated">这等效于将 &lt;code&gt;?:&lt;/code&gt; 放在每个捕获组的开头：</target>
        </trans-unit>
        <trans-unit id="8b27aed9ee162e49847966b3b51b71c4860ae778" translate="yes" xml:space="preserve">
          <source>This is equivalent to the following code:</source>
          <target state="translated">这相当于下面的代码。</target>
        </trans-unit>
        <trans-unit id="db66d69de876b62af8e4e583ee35fa7336ce738e" translate="yes" xml:space="preserve">
          <source>This is especially handy for the handles that Perl has already opened for you.</source>
          <target state="translated">这对于Perl已经为你打开的句柄尤其方便。</target>
        </trans-unit>
        <trans-unit id="f8d05739ccb676f898da1bfecdf838eee060521a" translate="yes" xml:space="preserve">
          <source>This is especially noticeable in scripts like Makefiles and test suites, which often assume &lt;code&gt;/&lt;/code&gt; as a path separator for subdirectories.</source>
          <target state="translated">这在Makefile和测试套件之类的脚本中尤其明显，这些脚本通常将 &lt;code&gt;/&lt;/code&gt; 用作子目录的路径分隔符。</target>
        </trans-unit>
        <trans-unit id="f527eac137b06210e13666ef8269894d061c4071" translate="yes" xml:space="preserve">
          <source>This is especially significant, given that &lt;code&gt;__DIE__&lt;/code&gt; hooks can call &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again, which has the effect of changing their error messages:</source>
          <target state="translated">鉴于 &lt;code&gt;__DIE__&lt;/code&gt; 挂钩可以再次调用 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，这具有更改其错误消息的作用，因此这尤其重要。</target>
        </trans-unit>
        <trans-unit id="e72ff779e72b05ba7f524c22b987a33b6ce734c7" translate="yes" xml:space="preserve">
          <source>This is especially significant, given that &lt;code&gt;__DIE__&lt;/code&gt; hooks can call &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again, which has the effect of changing their error messages:</source>
          <target state="translated">鉴于 &lt;code&gt;__DIE__&lt;/code&gt; 挂钩可以再次调用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，这具有更改其错误消息的作用，因此这尤其重要。</target>
        </trans-unit>
        <trans-unit id="818858cb9601e6ed62390539756668bab6bf2c4d" translate="yes" xml:space="preserve">
          <source>This is especially true if trying to catch &lt;code&gt;SIGALRM&lt;/code&gt; in a thread. To handle alarms in threads, set up a signal handler in the main thread, and then use &lt;a href=&quot;#THREAD-SIGNALLING&quot;&gt;THREAD SIGNALLING&lt;/a&gt; to relay the signal to the thread:</source>
          <target state="translated">如果尝试在线程中捕获 &lt;code&gt;SIGALRM&lt;/code&gt; ，则尤其如此。要处理线程中的警报，请在主线程中设置信号处理程序，然后使用&lt;a href=&quot;#THREAD-SIGNALLING&quot;&gt;THREAD SIGNALING&lt;/a&gt;将信号中继到线程：</target>
        </trans-unit>
        <trans-unit id="fd6dde33455dcaab484709ef3e2e047ba6858d2a" translate="yes" xml:space="preserve">
          <source>This is essentially a linear encoding of a nondeterministic finite-state machine (aka syntax charts or &quot;railroad normal form&quot; in parsing technology).</source>
          <target state="translated">这本质上是一种非确定性有限状态机的线性编码(也就是解析技术中的语法图或 &quot;铁路正常形式&quot;)。</target>
        </trans-unit>
        <trans-unit id="c2c33667b47416ed635e9db2747270d43c9fb79e" translate="yes" xml:space="preserve">
          <source>This is exactly equivalent to</source>
          <target state="translated">这完全等同于</target>
        </trans-unit>
        <trans-unit id="2888d5ca02740e184f93a1ad103d7f0d59cf4bf3" translate="yes" xml:space="preserve">
          <source>This is exactly equivalent to writing &lt;code&gt;$sub-&amp;gt;($file)&lt;/code&gt; . You may see this idiom in the wild combined with a call to &lt;code&gt;can&lt;/code&gt; :</source>
          <target state="translated">这完全等同于编写 &lt;code&gt;$sub-&amp;gt;($file)&lt;/code&gt; 。您可能会在野外看到这个成语以及对 &lt;code&gt;can&lt;/code&gt; 的调用：</target>
        </trans-unit>
        <trans-unit id="fc0020f4d9923684685bbbcf57921ec11fb0aac1" translate="yes" xml:space="preserve">
          <source>This is exactly the problem the</source>
          <target state="translated">这正是问题所在。</target>
        </trans-unit>
        <trans-unit id="1323ae3621b03444ef40592d920a99e3788e04fe" translate="yes" xml:space="preserve">
          <source>This is exactly the same as:</source>
          <target state="translated">这与。</target>
        </trans-unit>
        <trans-unit id="5350516b52a22254c5df97eb2c2d9b4520e43a69" translate="yes" xml:space="preserve">
          <source>This is fairly secure because &lt;code&gt;/\w+/&lt;/code&gt; doesn't normally match shell metacharacters, nor are dot, dash, or at going to mean something special to the shell. Use of &lt;code&gt;/.+/&lt;/code&gt; would have been insecure in theory because it lets everything through, but Perl doesn't check for that. The lesson is that when untainting, you must be exceedingly careful with your patterns. Laundering data using regular expression is the</source>
          <target state="translated">这是相当安全的，因为 &lt;code&gt;/\w+/&lt;/code&gt; 通常不匹配shell元字符，也不是点，破折号或对shell来说有些特殊的含义。 &lt;code&gt;/.+/&lt;/code&gt; 的使用在理论上是不安全的，因为它可以使所有内容通过，但是Perl不会对此进行检查。教训是，在取消污染时，必须格外小心。使用正则表达式清洗数据是</target>
        </trans-unit>
        <trans-unit id="4d2e8c2e8c603b9443a2fa3515b87175734dfedd" translate="yes" xml:space="preserve">
          <source>This is faster than using the &lt;b&gt;-exec&lt;/b&gt; switch of</source>
          <target state="translated">这比使用更快的&lt;b&gt;-exec&lt;/b&gt;开关</target>
        </trans-unit>
        <trans-unit id="1aa28f8ff665fed944de016ad1db63136902800f" translate="yes" xml:space="preserve">
          <source>This is fine for systems programming when sendmail is known to be available. But it is not fine for many non-Unix systems, and even some Unix systems that may not have sendmail installed. If a portable solution is needed, see the various distributions on CPAN that deal with it. &lt;code&gt;Mail::Mailer&lt;/code&gt; and &lt;code&gt;Mail::Send&lt;/code&gt; in the &lt;code&gt;MailTools&lt;/code&gt; distribution are commonly used, and provide several mailing methods, including &lt;code&gt;mail&lt;/code&gt; , &lt;code&gt;sendmail&lt;/code&gt; , and direct SMTP (via &lt;code&gt;Net::SMTP&lt;/code&gt; ) if a mail transfer agent is not available. &lt;code&gt;Mail::Sendmail&lt;/code&gt; is a standalone module that provides simple, platform-independent mailing.</source>
          <target state="translated">当已知sendmail可用时，这对于系统编程是很好的。但是对于许多非Unix系统，甚至某些可能未安装sendmail的Unix系统，它也不是很好。如果需要便携式解决方案，请参阅处理该解决方案的CPAN上的各种发行版。 &lt;code&gt;Mail::Mailer&lt;/code&gt; 和 &lt;code&gt;Mail::Send&lt;/code&gt; 在 &lt;code&gt;MailTools&lt;/code&gt; 分布常用，并且提供多种通讯方式，包括 &lt;code&gt;mail&lt;/code&gt; ， &lt;code&gt;sendmail&lt;/code&gt; 的，和直接SMTP（通过 &lt;code&gt;Net::SMTP&lt;/code&gt; ）如果一个邮件传输代理不可用。 &lt;code&gt;Mail::Sendmail&lt;/code&gt; 是一个独立的模块，提供简单的，与平台无关的邮件。</target>
        </trans-unit>
        <trans-unit id="3aabced6833bcc3911383da0e252138fb5ec6985" translate="yes" xml:space="preserve">
          <source>This is fine if you are just looking for a single character. However, if you are trying to count multiple character substrings within a larger string, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; won't work. What you can do is wrap a while() loop around a global pattern match. For example, let's count negative integers:</source>
          <target state="translated">如果您只寻找一个字符，这很好。但是，如果您要计算较大字符串中的多个字符子字符串， &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 将不起作用。您可以做的是将while（）循环包装在全局模式匹配周围。例如，让我们计算负整数：</target>
        </trans-unit>
        <trans-unit id="9cfd669832389228af06dec1239a8521733d9cc4" translate="yes" xml:space="preserve">
          <source>This is for backwards compatibility, and may be deprecated in the future.</source>
          <target state="translated">这是为了向后兼容,将来可能会被废弃。</target>
        </trans-unit>
        <trans-unit id="0e1feb67b0818a9b1deb572f5e23a9f9edab3c53" translate="yes" xml:space="preserve">
          <source>This is for clustering, not capturing; it groups subexpressions like &quot;()&quot;, but doesn't make backreferences as &quot;()&quot; does. So</source>
          <target state="translated">这是为了聚类,而不是捕获;它将子表达式分组,比如&quot;()&quot;,但不像&quot;()&quot;那样做反向引用。所以</target>
        </trans-unit>
        <trans-unit id="fd0c739b12ea8f303fae64c2fc3f585b7a17c56e" translate="yes" xml:space="preserve">
          <source>This is for heuristics which attempt to create directory structures that mirror those of the installed perl.</source>
          <target state="translated">这是针对那些试图创建镜像安装的perl的目录结构的启发式方法。</target>
        </trans-unit>
        <trans-unit id="f8b7de1b28f0c9aa17d5f75d5f2141f8c81f40ef" translate="yes" xml:space="preserve">
          <source>This is for unsigned integers. It is equivalent to using T_UV but explicitly casts the variable to type &lt;code&gt;unsigned &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; . The default type for &lt;code&gt;unsigned &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; is T_UV.</source>
          <target state="translated">这用于无符号整数。这等效于使用T_UV，但显式将变量强制类型转换为 &lt;code&gt;unsigned &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;unsigned &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 的默认类型为T_UV。</target>
        </trans-unit>
        <trans-unit id="223ca8fc8e06498b8700fcaf3a5b924a9287e801" translate="yes" xml:space="preserve">
          <source>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</source>
          <target state="translated">这是一个自由软件;您可以在与Perl 5编程语言系统本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="b876192e43b0c3f007bf98e622b2f335f00b0f03" translate="yes" xml:space="preserve">
          <source>This is functionally identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; function for suspending the execution of the current for process for certain number of seconds, see &lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;. There is one significant difference, however: &lt;code&gt;POSIX::sleep()&lt;/code&gt; returns the number of &lt;b&gt;unslept&lt;/b&gt; seconds, while the &lt;code&gt;CORE::sleep()&lt;/code&gt; returns the number of slept seconds.</source>
          <target state="translated">这在功能上与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数将进程的当前执行暂停一定的秒数，请参见&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;。有一个显著的差异，但是： &lt;code&gt;POSIX::sleep()&lt;/code&gt; 返回的数量&lt;b&gt;unslept&lt;/b&gt;秒，而 &lt;code&gt;CORE::sleep()&lt;/code&gt; 返回睡觉的秒数。</target>
        </trans-unit>
        <trans-unit id="4fb4b681258fa0233585a271cede9e357d7bbce9" translate="yes" xml:space="preserve">
          <source>This is generally meant to be called from inside Bracket Notation (which is discussed later), as in</source>
          <target state="translated">这一般是指从括号内调用(后面会讨论),如在</target>
        </trans-unit>
        <trans-unit id="487a457dae8e51eb07ff40b59ced8f82c47ea01f" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, but large testing systems often have weird internal needs.</source>
          <target state="translated">一般不建议这样做,但大型测试系统往往有奇怪的内部需求。</target>
        </trans-unit>
        <trans-unit id="abeb233860c7acca6119cb787cba71a4bde24872" translate="yes" xml:space="preserve">
          <source>This is grandfathered (for \1 to \9) for the RHS of a substitute to avoid shocking the &lt;b&gt;sed&lt;/b&gt; addicts, but it's a dirty habit to get into. That's because in PerlThink, the righthand side of an &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; is a double-quoted string. &lt;code&gt;\1&lt;/code&gt; in the usual double-quoted string means a control-A. The customary Unix meaning of &lt;code&gt;\1&lt;/code&gt; is kludged in for &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;. However, if you get into the habit of doing that, you get yourself into trouble if you then add an &lt;code&gt;/e&lt;/code&gt; modifier.</source>
          <target state="translated">这是祖父级（用于\ 1 \ 9）的替代品的RHS避免震撼&lt;b&gt;sed的&lt;/b&gt;吸毒者，但它是一个肮脏的习惯进入。这是因为在PerlThink中， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 的右侧是双引号字符串。通常的双引号字符串中的 &lt;code&gt;\1&lt;/code&gt; 表示控件A。 &lt;code&gt;\1&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 的惯用Unix含义为s ///。但是，如果您习惯这样做，那么在添加 &lt;code&gt;/e&lt;/code&gt; 修饰符时就会遇到麻烦。</target>
        </trans-unit>
        <trans-unit id="a33e8e516c4662a8793090c4f24cce78089ad98d" translate="yes" xml:space="preserve">
          <source>This is handy when you want to do a list assignment in a Boolean context, because most list functions return a null list when finished, which when assigned produces a 0, which is interpreted as FALSE.</source>
          <target state="translated">当你想在布尔上下文中进行列表赋值时,这很方便,因为大多数列表函数在完成赋值后都会返回一个空列表,当赋值后会产生一个0,解释为FALSE。</target>
        </trans-unit>
        <trans-unit id="8c2cfb1906a45c414c7c96fc609271f7955af896" translate="yes" xml:space="preserve">
          <source>This is how it works now:</source>
          <target state="translated">这就是现在的工作方式。</target>
        </trans-unit>
        <trans-unit id="7dbdb31e7c27bacbcb7fe1d4ef14ea6d653940f1" translate="yes" xml:space="preserve">
          <source>This is identical in operation to directories(), except that it includes all the intermediate directories back up to the specified directories.</source>
          <target state="translated">这和directories()的操作是一样的,只是它把所有的中间目录备份到指定的目录中。</target>
        </trans-unit>
        <trans-unit id="e351930a2f0204ac9b6b12368a795bebdda09c11" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs()&lt;/a&gt;&lt;/code&gt; function for returning the absolute value of the numerical argument, see &lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;.</source>
          <target state="translated">这与Perl内置的 &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于返回数值参数的绝对值，请参见&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="695d548bdbb7db69858dd0c63a58915988364e1a" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs()&lt;/a&gt;&lt;/code&gt; function, returning the absolute value of its numerical argument.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs()&lt;/a&gt;&lt;/code&gt; 函数相同，返回其数值参数的绝对值。</target>
        </trans-unit>
        <trans-unit id="f9120a2adefbe5ba2e37ba001760405e7d0a7dbe" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; function, either for arming or disarming the &lt;code&gt;SIGARLM&lt;/code&gt; timer.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 函数相同，可用于布防或撤防 &lt;code&gt;SIGARLM&lt;/code&gt; 计时器。</target>
        </trans-unit>
        <trans-unit id="48a476413067dd99ab4121abaa36c23eb2d9f153" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; function, returning the arcus tangent defined by its two numerical arguments, the</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; 函数相同，返回由其两个数值参数（即</target>
        </trans-unit>
        <trans-unit id="a05756bd65e3a6ef14f82f8385fe7e460811d0b5" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; function, allowing one to change the working (default) directory, see &lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 函数相同，允许它更改工作目录（默认），请参阅&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e888ff11c427adcd230a49c55dda839ea4139d83" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod()&lt;/a&gt;&lt;/code&gt; function, allowing one to change file and directory permissions, see &lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod()&lt;/a&gt;&lt;/code&gt; 函数相同，允许更改文件和目录权限，请参阅&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43527baa97f98b6bb9f0a7d166453b7ea32ff963" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; function, allowing one to change file and directory owners and groups, see &lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数允许更改文件和目录的所有者和组，请参阅&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="137a34ed8adb7ab17d656d13fbf0961186414eb0" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir()&lt;/a&gt;&lt;/code&gt; function for closing a directory handle, see &lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;.</source>
          <target state="translated">这与用于关闭目录句柄的Perl内置的 &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir()&lt;/a&gt;&lt;/code&gt; 函数相同，请参见&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e039818d97c69012826d73ac04fb7fe2694eb5b3" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos()&lt;/a&gt;&lt;/code&gt; function, for returning the cosine of its numerical argument, see &lt;a href=&quot;functions/cos&quot;&gt;cos&lt;/a&gt;. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos()&lt;/a&gt;&lt;/code&gt; 函数相同，有关返回其数字参数的余弦的信息，请参见&lt;a href=&quot;functions/cos&quot;&gt;cos&lt;/a&gt;。另请参见&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7986353e4fd90f34533ad5983c9c0772e03e142" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; function for exiting the program, see &lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 函数（用于退出程序）相同，请参见&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2c5c838eac2ca99b87036128b4be02041ba664e" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp()&lt;/a&gt;&lt;/code&gt; function for returning the exponent (</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp()&lt;/a&gt;&lt;/code&gt; 函数相同，用于返回指数（</target>
        </trans-unit>
        <trans-unit id="0f8afa6cc9b9bce42a0f876c4312c43a9b501d34" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; 函数相同，请参见&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0526f440f4487b3f67fbf7e27396c04e1d2573cc" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; function for duplicating the current process, see &lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt; and &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; if you are in Windows.</source>
          <target state="translated">这与用于复制当前进程的Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 函数相同，如果您在Windows 中，请参见&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;和&lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f40ae5570bc527bc5a1dd6d93c31c6aa0f593934" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc()&lt;/a&gt;&lt;/code&gt; 函数相同，请参见&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35d7514c028c77e7ca42538761981fea1a5e7fde" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getgrgid&quot;&gt;getgrgid()&lt;/a&gt;&lt;/code&gt; function for returning group entries by group identifiers, see &lt;a href=&quot;functions/getgrgid&quot;&gt;getgrgid&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/getgrgid&quot;&gt;getgrgid()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于通过组标识符返回组条目，请参见&lt;a href=&quot;functions/getgrgid&quot;&gt;getgrgid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60e26e2d8720ed0149b7b87c377d73417035968a" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getgrnam&quot;&gt;getgrnam()&lt;/a&gt;&lt;/code&gt; function for returning group entries by group names, see &lt;a href=&quot;functions/getgrnam&quot;&gt;getgrnam&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/getgrnam&quot;&gt;getgrnam()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于按组名返回组条目，请参见&lt;a href=&quot;functions/getgrnam&quot;&gt;getgrnam&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d15624acd39757d16036f7262ed6bcece3061f3a" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getlogin&quot;&gt;getlogin()&lt;/a&gt;&lt;/code&gt; function for returning the user name associated with the current session, see &lt;a href=&quot;functions/getlogin&quot;&gt;getlogin&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/getlogin&quot;&gt;getlogin()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于返回与当前会话关联的用户名，请参见&lt;a href=&quot;functions/getlogin&quot;&gt;getlogin&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="186fcd1d3a57037edb361be5db32f5f007ca9211" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getpgrp&quot;&gt;getpgrp()&lt;/a&gt;&lt;/code&gt; function for returning the process group identifier of the current process, see &lt;a href=&quot;functions/getpgrp&quot;&gt;getpgrp&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/getpgrp&quot;&gt;getpgrp()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于返回当前进程的进程组标识符，请参见&lt;a href=&quot;functions/getpgrp&quot;&gt;getpgrp&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1809496150480256c93f1aafd87f931437ce086" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getppid&quot;&gt;getppid()&lt;/a&gt;&lt;/code&gt; function for returning the process identifier of the parent process of the current process , see &lt;a href=&quot;functions/getppid&quot;&gt;getppid&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/getppid&quot;&gt;getppid()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于返回当前进程的父进程的进程标识符，请参见&lt;a href=&quot;functions/getppid&quot;&gt;getppid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="457ce51591f9cb379a5adb26605bff1ac3f4ef40" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getpwnam&quot;&gt;getpwnam()&lt;/a&gt;&lt;/code&gt; function for returning user entries by user names, see &lt;a href=&quot;functions/getpwnam&quot;&gt;getpwnam&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/getpwnam&quot;&gt;getpwnam()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于通过用户名返回用户条目，请参见&lt;a href=&quot;functions/getpwnam&quot;&gt;getpwnam&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="099bdffd8de12dde36332facd7fd521fe7604dc8" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid()&lt;/a&gt;&lt;/code&gt; function for returning user entries by user identifiers, see &lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于通过用户标识符返回用户条目，请参见&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2f87263d58fd06391e632ecc597293fca726096" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; function for converting seconds since the epoch to a date in Greenwich Mean Time, see &lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;.</source>
          <target state="translated">这与Perl内置的 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于将自纪元以来的秒数转换为格林威治标准时间的日期，请参见&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3c0f6e328c0a9e84f4089fb4367baf98b6b1c72" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; 函数相同，请参见&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b121ee200825f5ba836e4ff9ea046596d9a0669c" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; function for sending signals to processes (often to terminate them), see &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于向进程发送信号（通常将其终止），请参见&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b81f62db22691a94ae2b3fa4ba9674d2bf0b3fd0" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link()&lt;/a&gt;&lt;/code&gt; function for creating hard links into files, see &lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于在文件中创建硬链接，请参见&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44d5f3c7d27301e5eb1acf76c204cabece604701" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; function for converting seconds since the epoch to a date see &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;.</source>
          <target state="translated">这与Perl内置的 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于将自纪元转换为秒后的秒数转换为日期，请参见&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e0909781f3283ef9c3e20db724f85b91f439d90" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log()&lt;/a&gt;&lt;/code&gt; function, returning the natural (</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log()&lt;/a&gt;&lt;/code&gt; 函数相同，返回自然值（</target>
        </trans-unit>
        <trans-unit id="e971f99436b45984924e279dba0a0153fd2a323c" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir()&lt;/a&gt;&lt;/code&gt; function for creating directories, see &lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir()&lt;/a&gt;&lt;/code&gt; 函数（用于创建目录）相同，请参见&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b41549ebc9ad587ccb819b0a3ec0f8792362c7d3" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; function for reading directory entries, see &lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 函数（用于读取目录条目）相同，请参见&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35438e0216a544df5038b4544cbb587885a54611" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; function for renaming files, see &lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; 命名文件功能相同（请参阅&lt;a href=&quot;functions/rename&quot;&gt;named）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5d513c94dc874928c142ca043089cff6c9b7ef0" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; function for rewinding directory entry streams, see &lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; 函数（用于倒退目录条目流）相同，请参见&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb204757196695331f28a45173a4730e85e7f0fb" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir()&lt;/a&gt;&lt;/code&gt; function for removing (empty) directories, see &lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于删除（空）目录，请参阅&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f5d85ea0b853465bcc33fe450ea49c14a87d8b77" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin()&lt;/a&gt;&lt;/code&gt; function for returning the sine of the numerical argument, see &lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">这与Perl内置的 &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin()&lt;/a&gt;&lt;/code&gt; 函数相同，用于返回数值参数的正弦值，请参见&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;。另请参见&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="919e7a21c6ecbb020823d058dd90c7b0a9eb3a55" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt()&lt;/a&gt;&lt;/code&gt; function. for returning the square root of the numerical argument, see &lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt()&lt;/a&gt;&lt;/code&gt; 函数相同。有关返回数值参数的平方根的信息，请参见&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0eaf8f167427908f7febf3b312f3b5eb7b5e1919" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; function for returning information about files and directories.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于返回有关文件和目录的信息。</target>
        </trans-unit>
        <trans-unit id="41d6fd8cbb0b29357e5142e667be5a61001f2978" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 函数相同，请参见&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3273b4b3b0615a180eb23eebf260bd07416587ce" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; function for returning the number of seconds since the epoch (whatever it is for the system), see &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数返回自纪元以来的秒数（无论对于系统是什么），请参见&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c38ab013e5c6afb6168a48634dc91f08bf30d4f9" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask()&lt;/a&gt;&lt;/code&gt; function for setting (and querying) the file creation permission mask, see &lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于设置（和查询）文件创建许可权掩码，请参见&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88df1d410534e354bba714dca11791a1312464a8" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt; function for removing files, see &lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;.</source>
          <target state="translated">这与Perl内置的用于删除文件的 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt; 函数相同，请参见&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cb3ad24016b3eaa5941feee2fcd750ab1532552" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime()&lt;/a&gt;&lt;/code&gt; function for changing the time stamps of files and directories, see &lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime()&lt;/a&gt;&lt;/code&gt; 函数相同，该函数用于更改文件和目录的时间戳，请参见&lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2c58755bc175c3890516b5d42561515cbd4c528" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;.</source>
          <target state="translated">这与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 函数相同，请参见&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c33a2624a3bac1d7979963b70993ae442f03646c" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;_exit()&lt;/code&gt; . It exits the program immediately which means among other things buffered I/O is &lt;b&gt;not&lt;/b&gt; flushed.</source>
          <target state="translated">这与C函数 &lt;code&gt;_exit()&lt;/code&gt; 相同。它立即退出程序，这意味着缓冲的I / O &lt;b&gt;不&lt;/b&gt;刷新。</target>
        </trans-unit>
        <trans-unit id="f80c449f3b57bbebcb07635c9eb453473b86c188" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;abort()&lt;/code&gt; . It terminates the process with a &lt;code&gt;SIGABRT&lt;/code&gt; signal unless caught by a signal handler or if the handler does not return normally (it e.g. does a &lt;code&gt;longjmp&lt;/code&gt; ).</source>
          <target state="translated">这与C函数 &lt;code&gt;abort()&lt;/code&gt; 相同。除非信号处理程序捕获到该处理程序或该处理程序未正常返回（例如， &lt;code&gt;longjmp&lt;/code&gt; 会返回），否则它将以 &lt;code&gt;SIGABRT&lt;/code&gt; 信号终止该过程。</target>
        </trans-unit>
        <trans-unit id="d259a90ce3ab2f4e634cfbde2a7c2b688963f261" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;acos()&lt;/code&gt; , returning the arcus cosine of its numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">这与C函数 &lt;code&gt;acos()&lt;/code&gt; 相同，返回其数值参数的反正弦余弦。另请参见&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccee1e25346b17fb481ba7f4de4b0b4f50758bcf" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;acosh()&lt;/code&gt; , returning the hyperbolic arcus cosine of its numerical argument [C99]. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">这与C函数 &lt;code&gt;acosh()&lt;/code&gt; 相同，返回其数值参数[C99]的双曲反正弦余弦。另请参见&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8333095da54e7a945d4144cea8a756431c8956dd" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;asctime()&lt;/code&gt; . It returns a string of the form</source>
          <target state="translated">这与C函数 &lt;code&gt;asctime()&lt;/code&gt; 相同。它返回以下形式的字符串</target>
        </trans-unit>
        <trans-unit id="83275b8475bd60ebbcd493cefc6cdd7a1783a9d1" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;asin()&lt;/code&gt; , returning the arcus sine of its numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">这与C函数 &lt;code&gt;asin()&lt;/code&gt; 相同，返回其数值参数的反正弦值。另请参见&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35c416500eafa9e5a5d6b613f8969a9c043a063d" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;asinh()&lt;/code&gt; , returning the hyperbolic arcus sine of its numerical argument [C99]. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">这与C函数 &lt;code&gt;asinh()&lt;/code&gt; 相同，返回其数值参数[C99]的双曲反正弦值。另请参见&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1e5aa7da9f697f4c8ff8dc1fb698909d946bb08" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;atan()&lt;/code&gt; , returning the arcus tangent of its numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">这与C函数 &lt;code&gt;atan()&lt;/code&gt; 相同，返回其数值参数的反正切值。另请参见&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11f0cbd1a192e343ff198d459f44a118616c801d" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;atanh()&lt;/code&gt; , returning the hyperbolic arcus tangent of its numerical argument [C99]. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">这与C函数 &lt;code&gt;atanh()&lt;/code&gt; 相同，返回其数值参数[C99]的双曲圆弧正切。另请参见&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1019f8f1ad013c7cb1f6add559add30196a2727" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;ceil()&lt;/code&gt; , returning the smallest integer value greater than or equal to the given numerical argument.</source>
          <target state="translated">这与C函数 &lt;code&gt;ceil()&lt;/code&gt; 相同，返回大于或等于给定数值参数的最小整数值。</target>
        </trans-unit>
        <trans-unit id="d09fd6d4a60edcd6b29ae2efeeb92f7f1a3032dc" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;clock()&lt;/code&gt; , returning the amount of spent processor time in microseconds.</source>
          <target state="translated">这与C函数 &lt;code&gt;clock()&lt;/code&gt; 相同，以微秒为单位返回所花费的处理器时间。</target>
        </trans-unit>
        <trans-unit id="ed50101b37aabb6ccd0f72bf1cd12dc057e125c6" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;cosh()&lt;/code&gt; , for returning the hyperbolic cosine of its numeric argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">这与C函数 &lt;code&gt;cosh()&lt;/code&gt; 相同，用于返回其数字参数的双曲余弦值。另请参见&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f87a9c64391c986e35e0df3a461ddde69989f77" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;ctime()&lt;/code&gt; and equivalent to &lt;code&gt;asctime(&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;(...))&lt;/code&gt; , see &lt;a href=&quot;#asctime&quot;&gt;asctime&lt;/a&gt; and &lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt;.</source>
          <target state="translated">这与C函数 &lt;code&gt;ctime()&lt;/code&gt; 相同，并且等效于 &lt;code&gt;asctime(&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;(...))&lt;/code&gt; ，请参见&lt;a href=&quot;#asctime&quot;&gt;asctime&lt;/a&gt;和&lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="98a7a8b5298975e8b4638f6e08f625101ddd94f1" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;difftime()&lt;/code&gt; , for returning the time difference (in seconds) between two times (as returned by &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt;), see &lt;a href=&quot;#time&quot;&gt;time&lt;/a&gt;.</source>
          <target state="translated">这与C函数 &lt;code&gt;difftime()&lt;/code&gt; 相同，用于返回两次（由 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 返回）之间的时间差（以秒为单位），请参见&lt;a href=&quot;#time&quot;&gt;time&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3400f6cf25b03ffea13db374eb3a67b922b12f5c" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;floor()&lt;/code&gt; , returning the largest integer value less than or equal to the numerical argument.</source>
          <target state="translated">这与C函数 &lt;code&gt;floor()&lt;/code&gt; 相同，返回小于或等于数值参数的最大整数值。</target>
        </trans-unit>
        <trans-unit id="b40ee9ab2883fdc4ea6712b24d8986ecec5f39fc" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;fmod()&lt;/code&gt; .</source>
          <target state="translated">这与C函数 &lt;code&gt;fmod()&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="7b7a8f7914876d99686857a5b212ffa67a406bf2" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;ldexp()&lt;/code&gt; for multiplying floating point numbers with powers of two.</source>
          <target state="translated">这与C函数 &lt;code&gt;ldexp()&lt;/code&gt; 相同，用于将浮点数乘以2的幂。</target>
        </trans-unit>
        <trans-unit id="5967c218ae5e6977bcfb278510b90089a48661b4" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;log10()&lt;/code&gt; , returning the 10-base logarithm of the numerical argument. You can also use</source>
          <target state="translated">这与C函数 &lt;code&gt;log10()&lt;/code&gt; 相同，返回数值参数的10进制对数。您也可以使用</target>
        </trans-unit>
        <trans-unit id="d960a256a04c197a9681bc6a5b2df4621c6abcef" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;mblen()&lt;/code&gt; .</source>
          <target state="translated">这与C函数 &lt;code&gt;mblen()&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="72da259370ed7368b03117d248a4d69905a2aec8" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;mbstowcs()&lt;/code&gt; .</source>
          <target state="translated">这与C函数 &lt;code&gt;mbstowcs()&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="e9cb9e5092c37fe36ba32ebf9a50fb911920ee05" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;mbtowc()&lt;/code&gt; .</source>
          <target state="translated">这与C函数 &lt;code&gt;mbtowc()&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="34c30fa04962ce474f9dd2f58f200b70edfa44f9" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;perror()&lt;/code&gt; , which outputs to the standard error stream the specified message followed by &lt;code&gt;&quot;: &quot;&lt;/code&gt; and the current error string. Use the &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; function and the &lt;code&gt;$!&lt;/code&gt; variable instead, see &lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt; and &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$ERRNO in perlvar&lt;/a&gt;.</source>
          <target state="translated">这与C函数 &lt;code&gt;perror()&lt;/code&gt; 相同，该函数将指定的消息后跟 &lt;code&gt;&quot;: &quot;&lt;/code&gt; 和当前错误字符串输出到标准错误流。使用 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; 函数和 &lt;code&gt;$!&lt;/code&gt; 而是改为查看&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;和&lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$ perlvar中的$ ERRNO&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8cc1118a61c7aca10633514f234f4da1ee0e5bc3" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;setsid()&lt;/code&gt; for setting the session identifier of the current process.</source>
          <target state="translated">这与用于设置当前进程的会话标识符的C函数 &lt;code&gt;setsid()&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="a8b9a9e6d01fce018b50fa102ad5992e876d6995" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;sinh()&lt;/code&gt; for returning the hyperbolic sine of the numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">这与用于返回数值参数的双曲正弦的C函数 &lt;code&gt;sinh()&lt;/code&gt; 相同。另请参见&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5620e4c58d5e806939f06354c891f33af057e241" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;strcoll()&lt;/code&gt; for collating (comparing) strings transformed using the &lt;code&gt;strxfrm()&lt;/code&gt; function. Not really needed since Perl can do this transparently, see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">这与C函数 &lt;code&gt;strcoll()&lt;/code&gt; 相同，用于整理（比较）使用 &lt;code&gt;strxfrm()&lt;/code&gt; 函数转换的字符串。由于Perl可以透明地执行此操作，因此并不需要，请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c1de6e40d16de1b4908183780ee818a15a66a41" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tan()&lt;/code&gt; , returning the tangent of the numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">这与C函数 &lt;code&gt;tan()&lt;/code&gt; 相同，返回数字参数的正切值。另请参见&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d53070d8b102022984bacaa431429b0ea23b53bf" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tanh()&lt;/code&gt; , returning the hyperbolic tangent of the numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">这与C函数 &lt;code&gt;tanh()&lt;/code&gt; 相同，返回数值参数的双曲正切值。另请参见&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4339b3026b6818ba331f4b8dad83033d79b015ba" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tcgetpgrp()&lt;/code&gt; for returning the process group identifier of the foreground process group of the controlling terminal.</source>
          <target state="translated">这与C函数 &lt;code&gt;tcgetpgrp()&lt;/code&gt; 相同，用于返回控制终端的前台进程组的进程组标识符。</target>
        </trans-unit>
        <trans-unit id="10385672619fbe5424be8d41f4c81323dffb2c77" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;ttyname()&lt;/code&gt; for returning the name of the current terminal.</source>
          <target state="translated">这与用于返回当前终端名称的C函数 &lt;code&gt;ttyname()&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="61c4adb4504ab133429c5dcca9e634dda0234fa4" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tzset()&lt;/code&gt; for setting the current timezone based on the environment variable &lt;code&gt;TZ&lt;/code&gt; , to be used by &lt;code&gt;ctime()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;mktime()&lt;/code&gt; , and &lt;code&gt;strftime()&lt;/code&gt; functions.</source>
          <target state="translated">这与C函数 &lt;code&gt;tzset()&lt;/code&gt; 相同，后者基于环境变量 &lt;code&gt;TZ&lt;/code&gt; 设置当前时区，由 &lt;code&gt;ctime()&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;mktime()&lt;/code&gt; 和 &lt;code&gt;strftime()&lt;/code&gt; 函数使用。</target>
        </trans-unit>
        <trans-unit id="6eac2e9b93151c25128e8b44336e559f1ca26691" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;wcstombs()&lt;/code&gt; .</source>
          <target state="translated">这与C函数 &lt;code&gt;wcstombs()&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="6531eaab1a3fcd3d02f83fe194ba892352425032" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;wctomb()&lt;/code&gt; .</source>
          <target state="translated">这与C函数 &lt;code&gt;wctomb()&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="2b638e3d48a14e811a63d8a3b93348f1843f5897" translate="yes" xml:space="preserve">
          <source>This is identical to the C function, except that it can apply to a single character or to a whole string, and currently operates as if the locale always is &quot;C&quot;. Consider using the &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;, see &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;, or the equivalent &lt;code&gt;\L&lt;/code&gt; operator inside doublequotish strings.</source>
          <target state="translated">除了可以应用于单个字符或整个字符串之外，此功能与C函数相同，并且当前的运行方式就像语言环境始终为&amp;ldquo; C&amp;rdquo;一样。考虑使用 &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; 函数，请参见&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;，&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;或双引号字符串中的等效 &lt;code&gt;\L&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="30976c7fff7754f905b7e098aaebc37d849842e9" translate="yes" xml:space="preserve">
          <source>This is identical to the C function, except the order of arguments is consistent with Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; with the added restriction of only one path, not a list of paths. Does the same thing as the &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; function but changes the owner of a symbolic link instead of the file the symbolic link points to.</source>
          <target state="translated">这与C函数相同，不同之处在于参数的顺序与Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 一致，只增加了一条路径，而不是路径列表。执行与 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 函数相同的操作，但是更改符号链接的所有者，而不是符号链接指向的文件。</target>
        </trans-unit>
        <trans-unit id="cec15e827312e3918cb71e034a41abdc4f73a598" translate="yes" xml:space="preserve">
          <source>This is identical to the DL_FUNCS attribute available via MakeMaker, from which it is usually taken. Its value is a reference to an associative array, in which each key is the name of a package, and each value is an a reference to an array of function names which should be exported by the extension. For instance, one might say &lt;code&gt;DL_FUNCS =&amp;gt; { Homer::Iliad =&amp;gt; [ qw(trojans greeks) ],
Homer::Odyssey =&amp;gt; [ qw(travellers family suitors) ] }&lt;/code&gt; . The function names should be identical to those in the XSUB code; &lt;code&gt;Mksymlists&lt;/code&gt; will alter the names written to the linker option file to match the changes made by</source>
          <target state="translated">该属性与通常通过MakeMaker获得的DL_FUNCS属性相同。它的值是对关联数组的引用，其中每个键是包的名称，每个值是对应由扩展名导出的函数名称的数组的引用。例如，有人可能会说 &lt;code&gt;DL_FUNCS =&amp;gt; { Homer::Iliad =&amp;gt; [ qw(trojans greeks) ], Homer::Odyssey =&amp;gt; [ qw(travellers family suitors) ] }&lt;/code&gt; 。函数名称应与XSUB代码中的名称相同； &lt;code&gt;Mksymlists&lt;/code&gt; 将更改写入链接器选项文件的名称，以匹配由</target>
        </trans-unit>
        <trans-unit id="310f96db114f72f372da9166d69a4cc6f2cae9b1" translate="yes" xml:space="preserve">
          <source>This is identical to the DL_VARS attribute available via MakeMaker, and, like DL_FUNCS, it is usually specified via MakeMaker. Its value is a reference to an array of variable names which should be exported by the extension.</source>
          <target state="translated">这与通过MakeMaker提供的DL_VARS属性相同,和DL_FUNCS一样,它通常通过MakeMaker来指定。它的值是对一个变量名数组的引用,该数组应该由扩展程序导出。</target>
        </trans-unit>
        <trans-unit id="b412f9ab149e41469d7ba2eef653a9c88721e439" translate="yes" xml:space="preserve">
          <source>This is identical to the macro &lt;a href=&quot;#isUTF8_CHAR&quot;&gt;isUTF8_CHAR&lt;/a&gt;.</source>
          <target state="translated">这与宏&lt;a href=&quot;#isUTF8_CHAR&quot;&gt;isUTF8_CHAR&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="6cee0007e2daab07905e6dc7537e69cd21d5b2ba" translate="yes" xml:space="preserve">
          <source>This is ignored by most formatters, but some may use it for building indexes. It always renders as empty-string. Example: &lt;code&gt;X&amp;lt;absolutizing relative URLs&amp;gt;&lt;/code&gt;</source>
          <target state="translated">大多数格式化程序都忽略了它，但是有些格式化程序可以将其用于建立索引。它始终呈现为空字符串。示例： &lt;code&gt;X&amp;lt;absolutizing relative URLs&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be9929994c9a23587b60ac75552db3fe41c07468" translate="yes" xml:space="preserve">
          <source>This is implemented as a macro.</source>
          <target state="translated">这是作为一个宏来实现的。</target>
        </trans-unit>
        <trans-unit id="667c85db18e1907f43da9d70ad90da9e90ed961a" translate="yes" xml:space="preserve">
          <source>This is important because miniperl, used to build XS modules in the core, can not load XS.</source>
          <target state="translated">这一点很重要,因为用于在核心中构建XS模块的miniperl不能加载XS。</target>
        </trans-unit>
        <trans-unit id="144222a27e6ef028e4173cd0825a23a1090abbf3" translate="yes" xml:space="preserve">
          <source>This is in contrast to many other dynamic languages, where the operation is determined by the type of the first argument. It also means that Perl has two versions of some operators, one for numeric and one for string comparison. For example &lt;code&gt;$x == $y&lt;/code&gt; compares two numbers for equality, and &lt;code&gt;$x &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; $y&lt;/code&gt; compares two strings.</source>
          <target state="translated">这与许多其他动态语言相反，后者的操作由第一个参数的类型确定。这也意味着Perl有两种​​版本的某些运算符，一种用于数字运算，另一种用于字符串比较。例如， &lt;code&gt;$x == $y&lt;/code&gt; 比较两个数字是否相等，而 &lt;code&gt;$x &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; $y&lt;/code&gt; 比较两个字符串。</target>
        </trans-unit>
        <trans-unit id="17fded423d74ecd2cac30cc09f0fef74a562c96a" translate="yes" xml:space="preserve">
          <source>This is intended for authors of modules which do lots of class introspection, as it allows them to very quickly check if anything important about the local properties of a given class have changed since the last time they looked. It does not increment on method/&lt;code&gt;@ISA&lt;/code&gt; changes in superclasses.</source>
          <target state="translated">这适用于进行大量类自省的模块的作者，因为它使他们可以非常快速地检查自上次查看以来与给定类的局部属性有关的任何重要事项是否已更改。它不会在超类中的方法/ @ &lt;code&gt;@ISA&lt;/code&gt; 更改上增加。</target>
        </trans-unit>
        <trans-unit id="8048e3a62929d8c0b743c4d8a83b98f6eb0f81fb" translate="yes" xml:space="preserve">
          <source>This is intended to largely replace the deprecated pseudo-hashes.</source>
          <target state="translated">这在很大程度上是为了取代被废弃的伪哈希值。</target>
        </trans-unit>
        <trans-unit id="db4b800255fcc3a17f2b811fc2b88aebde232685" translate="yes" xml:space="preserve">
          <source>This is invalid because every &quot;=end&quot; command must have a formatname parameter.</source>
          <target state="translated">这是无效的,因为每条&quot;=end &quot;命令都必须有一个formatname参数。</target>
        </trans-unit>
        <trans-unit id="61a2277b2bd23db81a91f83c4d1f3dd9feb9a041" translate="yes" xml:space="preserve">
          <source>This is just a basic proof of concept. It should be seriously expanded to support configurable coloration via options passed to the constructor, and &lt;b&gt;pod2text&lt;/b&gt; should be taught about those.</source>
          <target state="translated">这只是概念的基本证明。应该认真地扩展它，以通过传递给构造函数的选项来支持可配置的着色，并且应该教&lt;b&gt;pod2text&lt;/b&gt;有关这些内容。</target>
        </trans-unit>
        <trans-unit id="68c9d184917794ed93e7fda1e4971f91e0c45375" translate="yes" xml:space="preserve">
          <source>This is just a beta release -- there are a good number of things still left to do. Notably, support for EBCDIC platforms is still half-done, an untested.</source>
          <target state="translated">这只是一个测试版--还有很多事情没有做。值得注意的是,对EBCDIC平台的支持仍然是半成品,是一个未经测试的。</target>
        </trans-unit>
        <trans-unit id="219ed1315313e10e560072058c3673015172eb8a" translate="yes" xml:space="preserve">
          <source>This is just a quick start guide. For a more in-depth tutorial on regexes, see &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; and for the reference page, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">这只是一个快速入门指南。有关正则表达式的更深入的教程，请参见&lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;；对于参考页面，请参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="285e57010c635f262d70613679ce183fe2c1fc6d" translate="yes" xml:space="preserve">
          <source>This is just a restatement of the previous section. Unless you are completely certain you know what you are doing, avoid mixing filtered &amp;amp; non-filtered data.</source>
          <target state="translated">这只是上一节的重述。除非您完全确定自己知道自己在做什么，否则请避免混合使用已过滤和未过滤的数据。</target>
        </trans-unit>
        <trans-unit id="0eb6c125a87601bb415e7dd8ac4261d5f4ccd383" translate="yes" xml:space="preserve">
          <source>This is just a shorthand for a typeglob assignment at compile time:</source>
          <target state="translated">这只是编译时typeglob赋值的一个简写。</target>
        </trans-unit>
        <trans-unit id="15b35232b5a8087ae488ff75565de5703f14864d" translate="yes" xml:space="preserve">
          <source>This is just a tutorial. For the full story on Perl regular expressions, see the &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; regular expressions reference page.</source>
          <target state="translated">这只是一个教程。有关Perl正则表达式的完整信息，请参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;正则表达式参考页。</target>
        </trans-unit>
        <trans-unit id="9456d5890fbed572d26379cc56324c8cfe828e36" translate="yes" xml:space="preserve">
          <source>This is just a wrapper around Perl's normal &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. It's provided so that you can use &quot;sprintf&quot; in Bracket Notation:</source>
          <target state="translated">这只是Perl正常 &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 函数的包装。提供它是为了使您可以在括号表示法中使用&amp;ldquo; sprintf&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="77266324e65b81993bcee36043a748db86e77bf5" translate="yes" xml:space="preserve">
          <source>This is just an alias for $ctx-&amp;gt;new.</source>
          <target state="translated">这只是$ ctx-&amp;gt; new的别名。</target>
        </trans-unit>
        <trans-unit id="4341fe03623ad4301c3243c214057adf6cd69228" translate="yes" xml:space="preserve">
          <source>This is just an alias for $md5-&amp;gt;new.</source>
          <target state="translated">这只是$ md5-&amp;gt; new的别名。</target>
        </trans-unit>
        <trans-unit id="abb98ec9f418273dc2ca6cd9acdcab91a8675d3b" translate="yes" xml:space="preserve">
          <source>This is just like get_title, except that it returns just the modulename, if the title seems to be of the form &quot;SomeModuleName -- description&quot;.</source>
          <target state="translated">这和get_title一样,只是如果标题的形式是 &quot;SomeModuleName --description&quot;,那么它只返回modulename。</target>
        </trans-unit>
        <trans-unit id="3efe951774b37c8f5ed5c70b61d80e43335a5d14" translate="yes" xml:space="preserve">
          <source>This is just like the &lt;code&gt;m/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;/code&gt; search, except that it matches only once between calls to the &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; operator. This is a useful optimization when you want to see only the first occurrence of something in each file of a set of files, for instance. Only &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m??&lt;/a&gt;&lt;/code&gt; patterns local to the current package are reset.</source>
          <target state="translated">就像 &lt;code&gt;m/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;/code&gt; search一样，只不过它在对 &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; 运算符的调用之间仅匹配一次。例如，当您只想查看某组文件的每个文件中某事物的首次出现时，这是有用的优化。只有 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m??&lt;/a&gt;&lt;/code&gt; 重置当前程序包本地的模式。</target>
        </trans-unit>
        <trans-unit id="d1f273b15a0cb3300a978b7939f344dd1d08639d" translate="yes" xml:space="preserve">
          <source>This is like &lt;code&gt;&quot;a&quot;&lt;/code&gt; , but some elements are the empty string, and should not be adjusted. The one internal Perl property accessible by &lt;code&gt;prop_invmap&lt;/code&gt; is of this type: &quot;Perl_Decimal_Digit&quot; returns an inversion map which gives the numeric values that are represented by the Unicode decimal digit characters. Characters that don't represent decimal digits map to the empty string, like so:</source>
          <target state="translated">就像 &lt;code&gt;&quot;a&quot;&lt;/code&gt; ，但是某些元素是空字符串，因此不应进行调整。 &lt;code&gt;prop_invmap&lt;/code&gt; 可访问的一个内部Perl属性是这种类型：&amp;ldquo; Perl_Decimal_Digit&amp;rdquo;返回一个反转映射，该映射给出了用Unicode十进制数字字符表示的数值。不代表十进制数字的字符映射到空字符串，如下所示：</target>
        </trans-unit>
        <trans-unit id="4c2c127a4acabd567283fc3055323b13e8a32015" translate="yes" xml:space="preserve">
          <source>This is like the SMTP transport, but uses TLS security. You can authenticate with this module as well, using any mechanisms your server supports after STARTTLS.</source>
          <target state="translated">这就像SMTP传输一样,但使用TLS安全。你也可以使用这个模块进行验证,使用你的服务器在STARTTLS之后支持的任何机制。</target>
        </trans-unit>
        <trans-unit id="ee19061e56d9213c77400710440b7c20343ebe03" translate="yes" xml:space="preserve">
          <source>This is mainly useful for constructing bitmaps for &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; and low-level POSIX tty-handling operations. If FILEHANDLE is an expression, the value is taken as an indirect filehandle, generally its name.</source>
          <target state="translated">这对于为 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 和低级POSIX tty处理操作构造位图非常有用。如果FILEHANDLE是一个表达式，则该值将作为间接文件句柄，通常是其名称。</target>
        </trans-unit>
        <trans-unit id="4451800d0e0114802550054b61665e033a2b00a5" translate="yes" xml:space="preserve">
          <source>This is mainly useful for constructing bitmaps for &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; and low-level POSIX tty-handling operations. If FILEHANDLE is an expression, the value is taken as an indirect filehandle, generally its name.</source>
          <target state="translated">这对于为 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 和低级POSIX tty处理操作构造位图非常有用。如果FILEHANDLE是一个表达式，则该值将作为间接文件句柄，通常是其名称。</target>
        </trans-unit>
        <trans-unit id="37ce9a12e2723922e8bd944d2d5d67e411bc7f1f" translate="yes" xml:space="preserve">
          <source>This is merely a synonym for &lt;code&gt;as_string&lt;/code&gt; .</source>
          <target state="translated">这只是 &lt;code&gt;as_string&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="4dab1c8c1fba88ee26cb0159afceae84eeab9c5c" translate="yes" xml:space="preserve">
          <source>This is more portable than the raw &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;, but not as illustrative:</source>
          <target state="translated">这比原始的 &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 更可移植，但不作为说明：</target>
        </trans-unit>
        <trans-unit id="e4ef392975ecd504b3ac95743d2709331ec1fc38" translate="yes" xml:space="preserve">
          <source>This is neither a specimen of simplicity nor a paragon of portability but it illustrates the point: We are able to sneak behind the scenes and access Perl's otherwise well-guarded memory! (Important note: Perl's &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; does</source>
          <target state="translated">这既不是简单性的样本，也不是可移植性的典范，但它说明了这一点：我们能够在后台偷偷摸摸，并访问Perl受到良好保护的内存！（重要说明：Perl的 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 确实</target>
        </trans-unit>
        <trans-unit id="10ebf1cbe04784f38db52da63b8ec5a60455457d" translate="yes" xml:space="preserve">
          <source>This is normally all you need to know. However, many options are available:</source>
          <target state="translated">通常这就是你需要知道的全部内容。不过,还有很多选择。</target>
        </trans-unit>
        <trans-unit id="d00bfe25391751730fea233731dd8b0f5f6ab569" translate="yes" xml:space="preserve">
          <source>This is not &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;, which tells you how to use the debugger. This manpage describes low-level details concerning the debugger's internals, which range from difficult to impossible to understand for anyone who isn't incredibly intimate with Perl's guts. Caveat lector.</source>
          <target state="translated">这不是&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;，它告诉您如何使用调试器。该手册页描述了有关调试器内部的低级详细信息，对于不熟悉Perl胆量的人，范围从难以理解到难以理解。注意警告。</target>
        </trans-unit>
        <trans-unit id="f404a9e2e0db79bb4f43c8d7bbb05496d430ba62" translate="yes" xml:space="preserve">
          <source>This is not a general purpose Unicode to byte encoding interface: use the Encode extension for that.</source>
          <target state="translated">这不是一个通用的Unicode到字节的编码接口:使用Encode扩展。</target>
        </trans-unit>
        <trans-unit id="7457d8ee09385437d0b615e7e131b4e9c0b973a9" translate="yes" xml:space="preserve">
          <source>This is not a general purpose byte encoding to Unicode interface: use the Encode extension for that.</source>
          <target state="translated">这不是一个通用的字节编码到Unicode接口:使用Encode扩展。</target>
        </trans-unit>
        <trans-unit id="d116bb6d0c3c84c2243b689bc93fe4a6155eb5cb" translate="yes" xml:space="preserve">
          <source>This is not as short as before, but it makes it more obvious that we intend to have little-endian byte-order for a whole group, not only for individual template codes. It can also be more readable and easier to maintain.</source>
          <target state="translated">这虽然没有以前那么短,但它使我们更清楚地表明,我们打算对整个组采用小字节顺序,而不是只对单个模板代码采用小字节顺序。也可以更易读,更易维护。</target>
        </trans-unit>
        <trans-unit id="21c82389f9ec1dc190c296dba01242b89223a846" translate="yes" xml:space="preserve">
          <source>This is not ideal, but it seems to be the best compromise. If it doesn't work for you, please let me know the details of how it broke.</source>
          <target state="translated">这并不理想,但这似乎是最好的折中办法。如果它对你不起作用,请告诉我它是如何坏掉的细节。</target>
        </trans-unit>
        <trans-unit id="a8f2331f9105fa67d4e126b8930145be58fae503" translate="yes" xml:space="preserve">
          <source>This is not ok:</source>
          <target state="translated">这是不可以的。</target>
        </trans-unit>
        <trans-unit id="909f3f0de148a4f0a784930ff89af77cea3c7576" translate="yes" xml:space="preserve">
          <source>This is not really a &quot;severe&quot; error, but it is supposed to be raised by default even if warnings are not enabled, and currently the only way to do that in Perl is to mark it as serious.</source>
          <target state="translated">这并不是一个真正的 &quot;严重 &quot;错误,但它应该是在默认情况下引发的,即使没有启用警告,目前在Perl中唯一的方法是将其标记为严重错误。</target>
        </trans-unit>
        <trans-unit id="197111743c19bce55304223ee2f18830ead89426" translate="yes" xml:space="preserve">
          <source>This is not the normal way to consume lexed text. For that, use &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt;.</source>
          <target state="translated">这不是使用词汇化文本的正常方法。为此，请使用&lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f9e6c0b666a1af0815bd174af9f121c2162997f" translate="yes" xml:space="preserve">
          <source>This is not the right answer at all, but the sum looks correct. I wonder if it's anything to do with operator precedence? We'll try a couple of other possibilities with our sum:</source>
          <target state="translated">这根本不是正确的答案,但和看起来是正确的。我想这是不是和运算符的优先性有关?我们用我们的和来试试其他几种可能性。</target>
        </trans-unit>
        <trans-unit id="8a04fbe62aa8087e67610ad69a72c7364e385eaa" translate="yes" xml:space="preserve">
          <source>This is not the sigil you use in front of an array name to get the last index, like &lt;code&gt;$#array&lt;/code&gt; . That's still how you get the last index of an array in Perl. The two have nothing to do with each other.</source>
          <target state="translated">这不是在数组名称前使用的符号，以获取最后的索引，例如 &lt;code&gt;$#array&lt;/code&gt; 。这仍然是您在Perl中获得数组的最后一个索引的方式。两者彼此无关。</target>
        </trans-unit>
        <trans-unit id="a71eefb6bc615d22ea75cd4d866e05c590f48f94" translate="yes" xml:space="preserve">
          <source>This is not to say that Perl threads are completely different from everything that's ever come before. They're not. Perl's threading model owes a lot to other thread models, especially POSIX. Just as Perl is not C, though, Perl threads are not POSIX threads. So if you find yourself looking for mutexes, or thread priorities, it's time to step back a bit and think about what you want to do and how Perl can do it.</source>
          <target state="translated">这并不是说Perl线程与之前的一切完全不同。其实不然。Perl的线程模型欠其他线程模型很多,尤其是POSIX。不过就像Perl不是C一样,Perl线程也不是POSIX线程。所以,如果你发现自己在寻找mutexes,或者线程优先级,那么你就应该退后一步,想想你想做什么,以及Perl如何做到这一点。</target>
        </trans-unit>
        <trans-unit id="1490fa72c1eafb91d46399cb68efda52398b105d" translate="yes" xml:space="preserve">
          <source>This is not very useful, and perl currently optimizes this away.</source>
          <target state="translated">这不是很有用,目前perl把这个优化掉了。</target>
        </trans-unit>
        <trans-unit id="719ad110f9ecd2d06449f518fe559ae60b466e21" translate="yes" xml:space="preserve">
          <source>This is now the recommended interface to install().</source>
          <target state="translated">这就是现在推荐的安装()接口。</target>
        </trans-unit>
        <trans-unit id="8dd3c5aefc65986cd4924a120675ce7dc9b1881f" translate="yes" xml:space="preserve">
          <source>This is of paramount importance, since it's the documentation of what goes where in the Perl source. Read it over a couple of times and it might start to make sense - don't worry if it doesn't yet, because the best way to study it is to read it in conjunction with poking at Perl source, and we'll do that later on.</source>
          <target state="translated">这一点是最重要的,因为它是Perl源码中哪些内容在哪里的文档。把它读上几遍,可能就会开始明白了--如果还不明白也不要担心,因为研究它的最好方法是结合戳穿Perl源码来读,我们稍后再做。</target>
        </trans-unit>
        <trans-unit id="fadd54f30e37dbf502c0a6893df00ea6b04ab979" translate="yes" xml:space="preserve">
          <source>This is often useful if you need to check the current Perl version before &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;ing library modules that won't work with older versions of Perl. (We try not to do this more than we have to.)</source>
          <target state="translated">如果您需要在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 不兼容旧版本Perl的库模块之前检查当前Perl版本，这通常很有用。（我们尽量不要做比我们要做的更多的事情。）</target>
        </trans-unit>
        <trans-unit id="96345383ecfecda78d417eea671d77452c1d163e" translate="yes" xml:space="preserve">
          <source>This is often useful if you need to check the current Perl version before &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;ing library modules that won't work with older versions of Perl. (We try not to do this more than we have to.)</source>
          <target state="translated">如果您需要在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 不兼容旧版本Perl的库模块之前检查当前Perl版本，这通常很有用。（我们尽量不要做比我们要做的更多的事情。）</target>
        </trans-unit>
        <trans-unit id="b7065d0815c75fb916f5ccef644a97fc5f9a5ab5" translate="yes" xml:space="preserve">
          <source>This is one of the cases we mentioned earlier in which references could spring into existence when in an lvalue context. Before this statement, &lt;code&gt;$array[$x]&lt;/code&gt; may have been undefined. If so, it's automatically defined with a hash reference so that we can look up &lt;code&gt;{&quot;foo&quot;}&lt;/code&gt; in it. Likewise &lt;code&gt;$array[$x]-&amp;gt;{&quot;foo&quot;}&lt;/code&gt; will automatically get defined with an array reference so that we can look up &lt;code&gt;[0]&lt;/code&gt; in it. This process is called</source>
          <target state="translated">这是我们前面提到的情况之一，在左值上下文中，引用可能会出现。在此语句之前，可能未定义 &lt;code&gt;$array[$x]&lt;/code&gt; 。如果是这样，它将自动使用哈希引用进行定义，以便我们可以在其中查找 &lt;code&gt;{&quot;foo&quot;}&lt;/code&gt; 。同样， &lt;code&gt;$array[$x]-&amp;gt;{&quot;foo&quot;}&lt;/code&gt; 将自动使用数组引用进行定义，以便我们可以在其中查找 &lt;code&gt;[0]&lt;/code&gt; 。这个过程叫做</target>
        </trans-unit>
        <trans-unit id="6a3344e74e174252dc0aef67360fb712feea83d3" translate="yes" xml:space="preserve">
          <source>This is one of the only places where giving a prototype to a closure makes much sense. If you wanted to impose scalar context on the arguments of these functions (probably not a wise idea for this particular example), you could have written it this way instead:</source>
          <target state="translated">这是唯一一个给一个闭包提供原型的地方,是很有意义的。如果你想把标量上下文强加在这些函数的参数上(对于这个特殊的例子来说,这可能不是一个明智的想法),你可以这样写。</target>
        </trans-unit>
        <trans-unit id="8815273ee560d0448d9c01c105592b19a9f70fd8" translate="yes" xml:space="preserve">
          <source>This is only present when &lt;code&gt;netorder&lt;/code&gt; is FALSE. It is the $Config{byteorder} string of the perl that created this image. It is a string like &quot;1234&quot; (32 bit little endian) or &quot;87654321&quot; (64 bit big endian). This must match the current perl for the image to be readable by Storable.</source>
          <target state="translated">仅在 &lt;code&gt;netorder&lt;/code&gt; 为FALSE 时才存在。是创建该映像的perl的$ Config {byteorder}字符串。它是一个字符串，例如&amp;ldquo; 1234&amp;rdquo;（32位小端）或&amp;ldquo; 87654321&amp;rdquo;（64位大端）。这必须与当前perl匹配才能使Storable读取图像。</target>
        </trans-unit>
        <trans-unit id="84ff724c95d2598efdb8d7d443f2851d8e9c24b5" translate="yes" xml:space="preserve">
          <source>This is only required on some platforms which do not handle dependent libraries automatically. For example the Socket Perl extension library (</source>
          <target state="translated">只有在一些不会自动处理依赖库的平台上才需要这样做。例如Socket Perl扩展库(</target>
        </trans-unit>
        <trans-unit id="3167fd37c36e8874785bfe9f3f3013cce7f288bd" translate="yes" xml:space="preserve">
          <source>This is open source software. The code repository is available for public review and contribution under the terms of the license.</source>
          <target state="translated">这是一个开放源码软件。根据许可证的条款,代码库可供公众审查和贡献。</target>
        </trans-unit>
        <trans-unit id="bcfe5a91a20366b07a20b45c08c83d2cb3335747" translate="yes" xml:space="preserve">
          <source>This is our final regexp. To recap, we built a regexp by</source>
          <target state="translated">这是我们最后的regexp。概括地说,我们通过以下方法建立了一个regexp。</target>
        </trans-unit>
        <trans-unit id="55cbe19c15cda5405c9b99032930566aa6e4cd4b" translate="yes" xml:space="preserve">
          <source>This is parsed as:</source>
          <target state="translated">这被解析为:</target>
        </trans-unit>
        <trans-unit id="4f7853da7a16df56ba94a3f89eeeb6c41db7cabc" translate="yes" xml:space="preserve">
          <source>This is partially implemented now.</source>
          <target state="translated">现在已经部分实施。</target>
        </trans-unit>
        <trans-unit id="2a6f22dd0203804895067e4cd94d48784411f916" translate="yes" xml:space="preserve">
          <source>This is particularly useful for dynamic patterns, such as those read in from a configuration file, taken from an argument, or specified in a table somewhere. Consider the case where some patterns want to be case-sensitive and some do not: The case-insensitive ones merely need to include &lt;code&gt;(?i)&lt;/code&gt; at the front of the pattern. For example:</source>
          <target state="translated">这对于动态模式特别有用，例如从配置文件读入，从参数获取或在某个地方的表中指定的动态模式。考虑以下情况：有些模式要区分大小写，而有些则不想：不区分大小写的模式只需要在模式的前面包含 &lt;code&gt;(?i)&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="aaa59114ea7716b61a1b0ecf212fbfdac38cd5ec" translate="yes" xml:space="preserve">
          <source>This is particularly useful if you have More Than One Way (tm) to solve a problem in a program, and only wish to continue down a path if all modules could be loaded, and not load them if they couldn't.</source>
          <target state="translated">如果你在一个程序中有多个方法(tm)来解决一个问题,并且只希望在所有模块都能加载的情况下继续往下走,如果不能加载就不加载,这一点特别有用。</target>
        </trans-unit>
        <trans-unit id="7f5141125aa28c42d6dec636c32fcbaa85fe78c3" translate="yes" xml:space="preserve">
          <source>This is particularly useful when applied to code references returned from reval().</source>
          <target state="translated">当应用于从reval()返回的代码引用时,这一点特别有用。</target>
        </trans-unit>
        <trans-unit id="3afdcef939cf6d1f8b0ef2be038cdb0c7d7984fa" translate="yes" xml:space="preserve">
          <source>This is powerful, and slightly dangerous, in that it's possible to intend (with the utmost sincerity) to use a hard reference, and accidentally use a symbolic reference instead. To protect against that, you can say</source>
          <target state="translated">这是强大的,也是稍微危险的,因为它有可能打算(以最大的诚意)使用一个硬引用,而不小心使用一个符号引用。为了防止这种情况,你可以说</target>
        </trans-unit>
        <trans-unit id="1d61b3fe5532441244041a6185a4d7b90b80ec48" translate="yes" xml:space="preserve">
          <source>This is primarily meant for the use of modules such as FTP where passwords are sent, but we do not want to display them in the debugging information.</source>
          <target state="translated">这主要是针对FTP等发送密码的模块的使用,但我们不希望在调试信息中显示密码。</target>
        </trans-unit>
        <trans-unit id="01c91853268ed50e9d0a33c6896652af44de4d99" translate="yes" xml:space="preserve">
          <source>This is primarily of use for people who repackage Perl modules.</source>
          <target state="translated">这主要是给重新打包Perl模块的人用的。</target>
        </trans-unit>
        <trans-unit id="831dab0bf255edc5ba7e605462344bdbe78142e8" translate="yes" xml:space="preserve">
          <source>This is primarily used inside &lt;code&gt;(?{...})&lt;/code&gt; blocks for examining text recently matched. For example, to effectively capture text to a variable (in addition to &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc.), replace &lt;code&gt;(...)&lt;/code&gt; with</source>
          <target state="translated">这主要用于 &lt;code&gt;(?{...})&lt;/code&gt; 块内部，以检查最近匹配的文本。例如，要有效地将文本捕获到变量中（除了 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等），请将 &lt;code&gt;(...)&lt;/code&gt; 替换为</target>
        </trans-unit>
        <trans-unit id="43405231d7a3fc726c046090388674dddde66ec5" translate="yes" xml:space="preserve">
          <source>This is primarily useful for install scripts.</source>
          <target state="translated">这主要是对安装脚本有用。</target>
        </trans-unit>
        <trans-unit id="71555351eedbd86160cbba934f94d326494c3535" translate="yes" xml:space="preserve">
          <source>This is printf() equivalent. printf is #defined to this function, so it is (currently) legal to use &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(fmt,...)&lt;/a&gt;&lt;/code&gt; in perl sources.</source>
          <target state="translated">这等效于printf（）。printf是为此函数定义的＃，因此（当前 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(fmt,...)&lt;/a&gt;&lt;/code&gt; 在perl源代码中使用printf（fmt，...）是合法的。</target>
        </trans-unit>
        <trans-unit id="4ea35349c6ed8d6a98b7de634d09f57721480861" translate="yes" xml:space="preserve">
          <source>This is private to the Perl core and subject to change. Should be left null.</source>
          <target state="translated">这是Perl核心的隐私,可能会有变化。应该保持为空。</target>
        </trans-unit>
        <trans-unit id="98fa02440d9fac9b73c470e7ca881854b6795009" translate="yes" xml:space="preserve">
          <source>This is probably not what you want to use, you probably wanted &lt;a href=&quot;#sv_usepvn_flags&quot;&gt;sv_usepvn_flags&lt;/a&gt; or &lt;a href=&quot;#sv_setpvn&quot;&gt;sv_setpvn&lt;/a&gt; or &lt;a href=&quot;#sv_setpvs&quot;&gt;sv_setpvs&lt;/a&gt;.</source>
          <target state="translated">这可能不是您要使用的，您可能想要&lt;a href=&quot;#sv_usepvn_flags&quot;&gt;sv_usepvn_flags&lt;/a&gt;或&lt;a href=&quot;#sv_setpvn&quot;&gt;sv_setpvn&lt;/a&gt;或&lt;a href=&quot;#sv_setpvs&quot;&gt;sv_setpvs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="697287005f5cb5ed6d011d9e5061126f21f55b05" translate="yes" xml:space="preserve">
          <source>This is provided as a more readable version of &lt;code&gt;if (!&lt;i&gt;condition&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="translated">它以 &lt;code&gt;if (!&lt;i&gt;condition&lt;/i&gt;)&lt;/code&gt; 可读性更高的形式提供。</target>
        </trans-unit>
        <trans-unit id="4cabb9b2376d3134de9c8bd807fc2548baba2fca" translate="yes" xml:space="preserve">
          <source>This is quite different, however, from not even trusting the writer of the code not to try to do something evil. That's the kind of trust needed when someone hands you a program you've never seen before and says, &quot;Here, run this.&quot; For that kind of safety, you might want to check out the Safe module, included standard in the Perl distribution. This module allows the programmer to set up special compartments in which all system operations are trapped and namespace access is carefully controlled. Safe should not be considered bullet-proof, though: it will not prevent the foreign code to set up infinite loops, allocate gigabytes of memory, or even abusing perl bugs to make the host interpreter crash or behave in unpredictable ways. In any case it's better avoided completely if you're really concerned about security.</source>
          <target state="translated">然而,这与不相信代码的作者不会试图做一些邪恶的事情是完全不同的。当有人递给你一个你从未见过的程序,并说 &quot;给你,运行这个 &quot;时,你需要的就是这种信任。为了这种安全,你可能会想看看安全模块,它包含在Perl发行版的标准配置中。这个模块允许程序员设置特殊的隔间,所有的系统操作都会在其中被捕获,命名空间的访问也会被仔细控制。不过Safe不应该被认为是万无一失的:它不能防止外来代码建立无限循环,分配千兆字节的内存,甚至滥用perl bug使主机解释器崩溃或以不可预测的方式行事。总之,如果你真的担心安全问题,最好完全避免。</target>
        </trans-unit>
        <trans-unit id="fc844a09760bd8a2dc9b577b36da09548b575605" translate="yes" xml:space="preserve">
          <source>This is quite typical for .xs files: usually the .xs file provides an interface to an existing C function. Then this C function is defined somewhere (either in an external library, or in the first part of .xs file), and a Perl interface to this function (i.e. &quot;Perl glue&quot;) is described in the second part of .xs file. The situation in &lt;a href=&quot;#EXAMPLE-1&quot;&gt;EXAMPLE 1&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;EXAMPLE 2&lt;/a&gt;, and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;EXAMPLE 3&lt;/a&gt;, when all the work is done inside the &quot;Perl glue&quot;, is somewhat of an exception rather than the rule.</source>
          <target state="translated">这对于.xs文件是非常典型的：通常.xs文件为现有C函数提供接口。然后，在某处（在外部库中或.xs文件的第一部分中）定义此C函数，并在.xs文件的第二部分中描述此函数的Perl接口（即&amp;ldquo; Perl胶&amp;rdquo;）。当所有工作都在&amp;ldquo; Perl胶水&amp;rdquo;中完成时，&lt;a href=&quot;#EXAMPLE-1&quot;&gt;示例1&lt;/a&gt;，&lt;a href=&quot;#EXAMPLE-2&quot;&gt;示例2&lt;/a&gt;和&lt;a href=&quot;#EXAMPLE-3&quot;&gt;示例3中&lt;/a&gt;的情况在某种程度上是一种例外，而非常规。</target>
        </trans-unit>
        <trans-unit id="c3a982ed6685f74bf9f57db540f3caed5035dcd6" translate="yes" xml:space="preserve">
          <source>This is quite useful as it usually improves readability. While this works fine for an &lt;code&gt;SV *&lt;/code&gt; , it's unfortunately not as easy to have &lt;code&gt;AV *&lt;/code&gt; or &lt;code&gt;HV *&lt;/code&gt; as a return value. You</source>
          <target state="translated">这非常有用，因为它通常可以提高可读性。尽管这对于 &lt;code&gt;SV *&lt;/code&gt; 可以正常工作，但不幸的是，将 &lt;code&gt;AV *&lt;/code&gt; 或 &lt;code&gt;HV *&lt;/code&gt; 作为返回值并不容易。您</target>
        </trans-unit>
        <trans-unit id="df9aa2c2c409f58ba99139ca42f157f4afdf7a29" translate="yes" xml:space="preserve">
          <source>This is rarely used. It's one way to get around using an E&amp;lt;...&amp;gt; code sometimes. For example, instead of &quot;&lt;code&gt;NE&amp;lt;lt&amp;gt;3&lt;/code&gt;&quot; (for &quot;N&amp;lt;3&quot;) you could write &quot;&lt;code&gt;NZ&amp;lt;&amp;gt;&amp;lt;3&lt;/code&gt; &quot; (the &quot;Z&amp;lt;&amp;gt;&quot; breaks up the &quot;N&quot; and the &quot;&amp;lt;&quot; so they can't be considered the part of a (fictitious) &quot;N&amp;lt;...&amp;gt;&quot; code).</source>
          <target state="translated">这很少使用。有时是使用E &amp;lt;...&amp;gt;代码的一种解决方法。例如，代替&amp;ldquo; &lt;code&gt;NE&amp;lt;lt&amp;gt;3&lt;/code&gt; &amp;rdquo;（对于&amp;ldquo; N &amp;lt;3&amp;rdquo;），您可以编写&amp;ldquo; &lt;code&gt;NZ&amp;lt;&amp;gt;&amp;lt;3&lt;/code&gt; &amp;rdquo;（&amp;ldquo; Z &amp;lt;&amp;gt;&amp;rdquo;将&amp;ldquo; N&amp;rdquo;和&amp;ldquo; &amp;lt;&amp;rdquo;分开，因此它们不能被视为（虚拟）&amp;ldquo; N &amp;lt;...&amp;gt;&amp;rdquo;代码的一部分）。</target>
        </trans-unit>
        <trans-unit id="5c569493cb06e371332b5d2d180bdd4a7a876b1d" translate="yes" xml:space="preserve">
          <source>This is required by some servers. For example if you are connecting to an INN server and you have transfer permission your connection will be connected to the transfer daemon, not the NNTP daemon. Issuing this command will cause the transfer daemon to hand over control to the NNTP daemon.</source>
          <target state="translated">这是一些服务器所需要的。例如,如果你连接到一个 INN 服务器,并且你有传输权限,你的连接将连接到传输守护进程,而不是 NNTP 守护进程。发出这个命令将导致传输守护进程将控制权交给NNTP守护进程。</target>
        </trans-unit>
        <trans-unit id="1aba726220151e0bdd8e20f672a38f3cb853c543" translate="yes" xml:space="preserve">
          <source>This is required since on many unix systems C is not owned by root.</source>
          <target state="translated">这是必须的,因为在许多unix系统中,C不属于root。</target>
        </trans-unit>
        <trans-unit id="53e759494f9bf8d7efd9149cfc161ebbf71db524" translate="yes" xml:space="preserve">
          <source>This is safer than and replaces the &quot;no_plan&quot; plan.</source>
          <target state="translated">这比 &quot;no_plan &quot;计划更安全,并取代了它。</target>
        </trans-unit>
        <trans-unit id="c7ebcb8463dd98d519e70a00c26fec5b1949c87c" translate="yes" xml:space="preserve">
          <source>This is seldom necessary, though, because this is done automatically, like when you access an array:</source>
          <target state="translated">不过这很少是必要的,因为这是自动完成的,就像你访问一个数组一样。</target>
        </trans-unit>
        <trans-unit id="5b39df7c425593c524473bd917a5316f755e7f35" translate="yes" xml:space="preserve">
          <source>This is set to &lt;code&gt;true&lt;/code&gt; in</source>
          <target state="translated">这是设置为 &lt;code&gt;true&lt;/code&gt; 的</target>
        </trans-unit>
        <trans-unit id="bda100b399c447a02432db64ae424bebb5a77bb3" translate="yes" xml:space="preserve">
          <source>This is set to a true value. It allows the tests to determine if they are being executed through the harness or by any other means.</source>
          <target state="translated">这被设置为真值。它允许测试确定它们是通过线束还是通过任何其他方式执行。</target>
        </trans-unit>
        <trans-unit id="8825b383410611d9ab88c7c6da41a37ab67b7bd2" translate="yes" xml:space="preserve">
          <source>This is similar in spirit to, but not the same as, grep(1) and its relatives. In particular, it is not limited to using regular expressions.</source>
          <target state="translated">这与grep(1)及其亲属的精神类似,但不一样。特别是,它不限于使用正则表达式。</target>
        </trans-unit>
        <trans-unit id="031672016e4d502c018309428e47661800aac1a9" translate="yes" xml:space="preserve">
          <source>This is similar to</source>
          <target state="translated">这类似于</target>
        </trans-unit>
        <trans-unit id="3e6ba00cc4274369aaec7e06e964eb77cd40c12d" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$&amp;amp;&lt;/code&gt; (&lt;code&gt;$MATCH&lt;/code&gt; ) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">这类似于 &lt;code&gt;$&amp;amp;&lt;/code&gt; （ &lt;code&gt;$MATCH&lt;/code&gt; ），只是它不会招致与该变量相关的性能损失。</target>
        </trans-unit>
        <trans-unit id="95e9006abb746eec00ddbe6c7b21cfe4ec62c97b" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$'&lt;/code&gt; (&lt;code&gt;$POSTMATCH&lt;/code&gt; ) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">这类似于 &lt;code&gt;$'&lt;/code&gt; （ &lt;code&gt;$POSTMATCH&lt;/code&gt; ），除了它不会招致与该变量相关的性能损失外。</target>
        </trans-unit>
        <trans-unit id="62e38c00b725c5a13563494b1438770078513b03" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$`&lt;/code&gt; ($PREMATCH) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">类似于 &lt;code&gt;$`&lt;/code&gt; （$ PREMATCH），不同之处在于它不会招致与该变量相关的性能损失。</target>
        </trans-unit>
        <trans-unit id="b7b04635104076e8869c03a97df7510eda62d809" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt;, but just returns either a code reference or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to indicate that no further methods of this name exist.</source>
          <target state="translated">这类似于 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; ，但是只返回代码引用或 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 来指示不存在该名称的其他方法。</target>
        </trans-unit>
        <trans-unit id="f73fed07cf9661cd5a76d43367f7870e1dfd1e63" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;string_vianame&lt;/code&gt; . The main difference is that under most circumstances, &lt;code&gt;vianame&lt;/code&gt; returns an ordinal code point, whereas &lt;code&gt;string_vianame&lt;/code&gt; returns a string. For example,</source>
          <target state="translated">这类似于 &lt;code&gt;string_vianame&lt;/code&gt; 。主要区别在于，在大多数情况下， &lt;code&gt;vianame&lt;/code&gt; 返回一个序号代码点，而 &lt;code&gt;string_vianame&lt;/code&gt; 返回一个字符串。例如，</target>
        </trans-unit>
        <trans-unit id="82735301d82a0dc4313bb1d53ad031d27f023c2f" translate="yes" xml:space="preserve">
          <source>This is similar to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; function for returning a string that has the arguments formatted as requested, see &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;.</source>
          <target state="translated">这类似于Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 函数，该函数返回具有根据要求设置格式的参数的字符串，请参见&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb9fc002d8f7d1fdb8d39dcb8cc96f69462055b3" translate="yes" xml:space="preserve">
          <source>This is similar to calling the &lt;code&gt;x&lt;/code&gt; command on each applicable var.</source>
          <target state="translated">这类似于在每个适用的var上调用 &lt;code&gt;x&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="c882c2e2c2f32205e6402773c4c5a8648cf274ab" translate="yes" xml:space="preserve">
          <source>This is similar to the &quot;cut group&quot; operator &lt;code&gt;::&lt;/code&gt; from Perl 6. Like &lt;code&gt;(*PRUNE)&lt;/code&gt; , this verb always matches, and when backtracked into on failure, it causes the regex engine to try the next alternation in the innermost enclosing group (capturing or otherwise) that has alternations. The two branches of a &lt;code&gt;(?(condition)yes-pattern|no-pattern)&lt;/code&gt; do not count as an alternation, as far as &lt;code&gt;(*THEN)&lt;/code&gt; is concerned.</source>
          <target state="translated">这是类似于&amp;ldquo;切团&amp;rdquo;运营商 &lt;code&gt;::&lt;/code&gt; 在Perl 6赞 &lt;code&gt;(*PRUNE)&lt;/code&gt; ，这个动词总是匹配，当回溯到上失败，它会导致正则表达式引擎来尝试最内层组在接下来的交替（捕获或以其他方式）。就 &lt;code&gt;(*THEN)&lt;/code&gt; 而言 &lt;code&gt;(?(condition)yes-pattern|no-pattern)&lt;/code&gt; 的两个分支不算作交替。</target>
        </trans-unit>
        <trans-unit id="5b23340a8a44f500f9fdd2f514353aafef1f1600" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;dup()&lt;/code&gt; , for duplicating a file descriptor.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;dup()&lt;/code&gt; ，用于复制文件描述符。</target>
        </trans-unit>
        <trans-unit id="bc59e25f670eb40f71d53b45961566d88e8da8a1" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;dup2()&lt;/code&gt; , for duplicating a file descriptor to an another known file descriptor.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;dup2()&lt;/code&gt; ，用于将文件描述符复制到另一个已知的文件描述符。</target>
        </trans-unit>
        <trans-unit id="f3ae23dd5fc0059c09ec24ea0c5ef5acb6d58fa1" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;mkfifo()&lt;/code&gt; for creating FIFO special files.</source>
          <target state="translated">这类似于用于创建FIFO特殊文件的C函数 &lt;code&gt;mkfifo()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb82e089ae466005cc0dc383a964501667069da5" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;nice()&lt;/code&gt; , for changing the scheduling preference of the current process. Positive arguments mean a more polite process, negative values a more needy process. Normal (non-root) user processes can only change towards being more polite.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;nice()&lt;/code&gt; ，用于更改当前进程的调度首选项。积极的论点意味着更礼貌的过程，消极的价值观意味着更需要的过程。普通（非root用户）用户进程只能朝着更礼貌的方向转变。</target>
        </trans-unit>
        <trans-unit id="458e14f71182f02f4a806b4f96c30f94a69e2f5d" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;pause()&lt;/code&gt; , which suspends the execution of the current process until a signal is received.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;pause()&lt;/code&gt; ，该函数暂停当前进程的执行，直到接收到信号为止。</target>
        </trans-unit>
        <trans-unit id="b5c0406fc055d4e959d81bed9920f88092d08404" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;setpgid()&lt;/code&gt; for setting the process group identifier of the current process.</source>
          <target state="translated">这类似于用于设置当前进程的进程组标识符的C函数 &lt;code&gt;setpgid()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b56c5c880f143b4a031f787b44269acb561de2d9" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcdrain()&lt;/code&gt; for draining the output queue of its argument stream.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;tcdrain()&lt;/code&gt; 耗尽其参数流的输出队列。</target>
        </trans-unit>
        <trans-unit id="fba332acc7267461256bd4bbecd53d5cd07ab313" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcflow()&lt;/code&gt; for controlling the flow of its argument stream.</source>
          <target state="translated">这类似于用于控制其参数流的C函数 &lt;code&gt;tcflow()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2235c85d6f3847cd44159a3753a652d29703f3f5" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcflush()&lt;/code&gt; for flushing the I/O buffers of its argument stream.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;tcflush()&lt;/code&gt; 刷新其参数流的I / O缓冲区。</target>
        </trans-unit>
        <trans-unit id="32c5db3dfe196b930ba8a6acd29334ab37d33b0e" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcsendbreak()&lt;/code&gt; for sending a break on its argument stream.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;tcsendbreak()&lt;/code&gt; 在其参数流上发送中断。</target>
        </trans-unit>
        <trans-unit id="d51d66ac3fd31e0526e015560112bf7a83d1d7e3" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcsetpgrp()&lt;/code&gt; for setting the process group identifier of the foreground process group of the controlling terminal.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;tcsetpgrp()&lt;/code&gt; ,用于设置控制终端的前台进程组的进程组标识符。</target>
        </trans-unit>
        <trans-unit id="66ffda00414691432da9fbf5e0758036abbf4c87" translate="yes" xml:space="preserve">
          <source>This is similar to the C function, except that it can apply to a single character or to a whole string, and currently operates as if the locale always is &quot;C&quot;. Consider using the &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;, or the equivalent &lt;code&gt;\U&lt;/code&gt; operator inside doublequotish strings.</source>
          <target state="translated">这与C函数类似，不同之处在于它可以应用于单个字符或整个字符串，并且当前的运行方式就像语言环境始终为&amp;ldquo; C&amp;rdquo;一样。考虑使用 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 函数，请参见&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;或双引号字符串中的等效 &lt;code&gt;\U&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="8eda6f0f736dfb783b722b66835ba379ce58a17f" translate="yes" xml:space="preserve">
          <source>This is similar to using T_OPAQUEPTR but can be used to process more than one element.</source>
          <target state="translated">这与使用T_OPAQUEPTR类似,但可以用来处理多个元素。</target>
        </trans-unit>
        <trans-unit id="a070e7d29b17578c9c82db6eb47bc8205a22821e" translate="yes" xml:space="preserve">
          <source>This is so that you can write loops like:</source>
          <target state="translated">这是为了让你可以写出像这样的循环。</target>
        </trans-unit>
        <trans-unit id="5bb4dbbe89d426f58f9d96c7270c7af2e03e5d56" translate="yes" xml:space="preserve">
          <source>This is something you, the programmer, has to keep track of; sorry. You could consider adopting a kind of &quot;Hungarian notation&quot; to help with this.</source>
          <target state="translated">这是你,程序员,必须跟踪的事情;抱歉。你可以考虑采用一种 &quot;匈牙利符号 &quot;来帮助解决这个问题。</target>
        </trans-unit>
        <trans-unit id="f62086875f698e88f1673ff191123d1ebe166ce0" translate="yes" xml:space="preserve">
          <source>This is somewhat equivalent to the C-style switch statement's fallthrough functionality (not to be confused with</source>
          <target state="translated">这在一定程度上等同于C式开关语句的跌穿功能(不要与</target>
        </trans-unit>
        <trans-unit id="7039ef5c59f1a390b0357d66a81e16efc5deefb4" translate="yes" xml:space="preserve">
          <source>This is somewhat like &lt;code&gt;SUPER&lt;/code&gt; , but it uses the C3 method resolution order to get better consistency in multiple inheritance situations. Note that while inheritance in general follows whichever MRO is in effect for the given class, &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; only uses the C3 MRO.</source>
          <target state="translated">这有点像 &lt;code&gt;SUPER&lt;/code&gt; ，但是它使用C3方法解析顺序来在多重继承情况下获得更好的一致性。请注意，虽然继承通常遵循对给定类有效的MRO，但 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 仅使用C3 MRO。</target>
        </trans-unit>
        <trans-unit id="a6e2c8909db8a95dab398add127a82ec5182c9bc" translate="yes" xml:space="preserve">
          <source>This is still a symbolic reference, and is still saddled with the problems enumerated above. It would be far better to write:</source>
          <target state="translated">这仍然是一种象征性的提法,仍然存在上述问题。如果写成:</target>
        </trans-unit>
        <trans-unit id="dc230bd2bfa305e90c52714b5b02997ea62329f3" translate="yes" xml:space="preserve">
          <source>This is subroutine definition, not a real function</source>
          <target state="translated">这是子程序的定义,不是真正的函数。</target>
        </trans-unit>
        <trans-unit id="b1e77ff60ef4ac8debe40c75ba809e724ed8905b" translate="yes" xml:space="preserve">
          <source>This is substantially different than the behavior of &lt;code&gt;SUPER&lt;/code&gt; under complex multiple inheritance. (This becomes obvious when one realizes that the common superclasses in the C3 linearizations of a given class and one of its parents will not always be ordered the same for both.)</source>
          <target state="translated">这与 &lt;code&gt;SUPER&lt;/code&gt; 在复杂的多重继承下的行为有本质的不同。（当人们意识到给定类的C3线性化中的公共超类及其父级中的一个不一定总是被定为相同时，这一点就变得显而易见。）</target>
        </trans-unit>
        <trans-unit id="23e17e01cd60708587cb31d9ff8b363ecd66c020" translate="yes" xml:space="preserve">
          <source>This is sufficient because non-XS modules install only &quot;.pm&quot; files and (sometimes) pod and/or man documentation. No re-linking of the perl binary is needed to build, install or use non-XS modules.</source>
          <target state="translated">这就足够了,因为非XS模块只安装&quot;.pm &quot;文件和(有时)pod和/或man文档。构建、安装或使用非 XS 模块不需要重新链接 perl 二进制文件。</target>
        </trans-unit>
        <trans-unit id="0c58a399144492e3d85b2b92893dc4441d4f1a4b" translate="yes" xml:space="preserve">
          <source>This is synonymous with:</source>
          <target state="translated">这是同义词。</target>
        </trans-unit>
        <trans-unit id="f36d5338bbc7b7f385e72503a212aefb9d4b21f2" translate="yes" xml:space="preserve">
          <source>This is the &quot;branch reset&quot; pattern, which has the special property that the capture groups are numbered from the same starting point in each alternation branch. It is available starting from perl 5.10.0.</source>
          <target state="translated">这是 &quot;分支重置 &quot;模式,它有一个特殊的属性,即在每个交替分支中,捕获组从同一个起点开始编号。从perl 5.10.0开始就可以使用。</target>
        </trans-unit>
        <trans-unit id="19421af57fe146a06eb56f9f30349ebe8341f96d" translate="yes" xml:space="preserve">
          <source>This is the &quot;make test&quot; result from the said combination:</source>
          <target state="translated">这就是上述组合的 &quot;使试 &quot;结果。</target>
        </trans-unit>
        <trans-unit id="62ca18cb3607997061d57b9fd320ab0f041516b6" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; SV. Always refer to this as &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; .</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; SV。始终将此称为 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4760f68814e5682fe3f5f10b06ed0b34903e395" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;false&lt;/code&gt; SV. See &lt;code&gt;PL_sv_yes&lt;/code&gt; . Always refer to this as &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; .</source>
          <target state="translated">这是 &lt;code&gt;false&lt;/code&gt; SV。参见 &lt;code&gt;PL_sv_yes&lt;/code&gt; 。始终将此称为 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69477e80b4da6549c4778882346d8c2f1a054a61" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;true&lt;/code&gt; SV. See &lt;code&gt;PL_sv_no&lt;/code&gt; . Always refer to this as &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; .</source>
          <target state="translated">这是 &lt;code&gt;true&lt;/code&gt; SV。参见 &lt;code&gt;PL_sv_no&lt;/code&gt; 。始终将此称为 &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7194017d84a1b8d81ca4290d44c59af66198e5c2" translate="yes" xml:space="preserve">
          <source>This is the Perl 6 &quot;commit pattern&quot; &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; or &lt;code&gt;:::&lt;/code&gt;. It's a zero-width pattern similar to &lt;code&gt;(*SKIP)&lt;/code&gt; , except that when backtracked into on failure it causes the match to fail outright. No further attempts to find a valid match by advancing the start pointer will occur again. For example,</source>
          <target state="translated">这是Perl 6&amp;ldquo;提交模式&amp;rdquo; &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 或 &lt;code&gt;:::&lt;/code&gt; 。这是一个零宽度模式，类似于 &lt;code&gt;(*SKIP)&lt;/code&gt; ，除了在失败时回溯到失败时会导致匹配完全失败。不会再发生任何通过提前开始指针来查找有效匹配项的尝试。例如，</target>
        </trans-unit>
        <trans-unit id="6d8e4baf0d85adfeec247ab733be39725f479200" translate="yes" xml:space="preserve">
          <source>This is the Perl patch level, a numeric change identifier, as defined by whichever source code maintenance system is used to maintain the patches; currently Perforce. It does not correlate with the Perl version numbers or the maintenance versus development dichotomy except by also being increasing.</source>
          <target state="translated">这是 Perl 补丁级别,一个数字变化标识符,由任何一个用于维护补丁的源代码维护系统定义,目前是 Perforce。它与Perl版本号或维护与开发的二分法并无关联,除非它也在增加。</target>
        </trans-unit>
        <trans-unit id="0eaf16c26ce67bf186071a739f6615eb11610fd4" translate="yes" xml:space="preserve">
          <source>This is the SV to be matched against. Note that the actual char array to be matched against is supplied by the arguments described below; the SV is just used to determine UTF8ness, &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">这是要匹配的SV。注意，要匹配的实际char数组由下面描述的参数提供；SV仅用于确定UTF8ness， &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="4d720b4f15a9201913736e953c720d9b63d81ea0" translate="yes" xml:space="preserve">
          <source>This is the Unicode-aware way of saying</source>
          <target state="translated">这是Unicode-aware的说法。</target>
        </trans-unit>
        <trans-unit id="455ede6174f3d5161f6c2d4aa6425c94536894ca" translate="yes" xml:space="preserve">
          <source>This is the basic function to generate temporary files. The behaviour of the file can be changed using various options:</source>
          <target state="translated">这是生成临时文件的基本功能。文件的行为可以通过各种选项来改变。</target>
        </trans-unit>
        <trans-unit id="a05b57eee11f052b052017c3ff384fae39edc53f" translate="yes" xml:space="preserve">
          <source>This is the command to execute. It may be either a string or an array reference. This is a required argument.</source>
          <target state="translated">这是要执行的命令。它可以是一个字符串或数组引用。这是一个必要的参数。</target>
        </trans-unit>
        <trans-unit id="78880bb496bf709fa9881c622c08f3137e6dd8f7" translate="yes" xml:space="preserve">
          <source>This is the constructor for &lt;b&gt;Pod::Parser&lt;/b&gt; and its subclasses. You</source>
          <target state="translated">这是&lt;b&gt;Pod :: Parser&lt;/b&gt;及其子类的构造函数。您</target>
        </trans-unit>
        <trans-unit id="3d8bf5bd14f4dda830975aad7d7af3e9d034509f" translate="yes" xml:space="preserve">
          <source>This is the constructor for a new Net::FTP object. &lt;code&gt;HOST&lt;/code&gt; is the name of the remote host to which an FTP connection is required.</source>
          <target state="translated">这是一个新的Net :: FTP对象的构造函数。 &lt;code&gt;HOST&lt;/code&gt; 是需要与FTP连接的远程主机的名称。</target>
        </trans-unit>
        <trans-unit id="d79a978a5e7757a479b9fe30cd0cc290698241af" translate="yes" xml:space="preserve">
          <source>This is the constructor for a new Net::NNTP object. &lt;code&gt;HOST&lt;/code&gt; is the name of the remote host to which a NNTP connection is required. If not given then it may be passed as the &lt;code&gt;Host&lt;/code&gt; option described below. If no host is passed then two environment variables are checked, first &lt;code&gt;NNTPSERVER&lt;/code&gt; then &lt;code&gt;NEWSHOST&lt;/code&gt; , then &lt;code&gt;Net::Config&lt;/code&gt; is checked, and if a host is not found then &lt;code&gt;news&lt;/code&gt; is used.</source>
          <target state="translated">这是新的Net :: NNTP对象的构造函数。 &lt;code&gt;HOST&lt;/code&gt; 是需要NNTP连接的远程主机的名称。如果未给出，则可以作为下面描述的&amp;ldquo; &lt;code&gt;Host&lt;/code&gt; 选项传递。如果未传递任何主机，则将检查两个环境变量，首先是 &lt;code&gt;NNTPSERVER&lt;/code&gt; ,然后是 &lt;code&gt;NEWSHOST&lt;/code&gt; ，然后是 &lt;code&gt;Net::Config&lt;/code&gt; ，如果没有找到主机，则使用 &lt;code&gt;news&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a1411000dcca44bd6224ab398773d981b55ca56" translate="yes" xml:space="preserve">
          <source>This is the constructor for a new Net::POP3 object. &lt;code&gt;HOST&lt;/code&gt; is the name of the remote host to which an POP3 connection is required.</source>
          <target state="translated">这是一个新的Net :: POP3对象的构造函数。 &lt;code&gt;HOST&lt;/code&gt; 是需要POP3连接的远程主机的名称。</target>
        </trans-unit>
        <trans-unit id="b5e150d75dbb5f649a71e256e018f3d6ee5d68ad" translate="yes" xml:space="preserve">
          <source>This is the constructor for a new Net::SMTP object. &lt;code&gt;HOST&lt;/code&gt; is the name of the remote host to which an SMTP connection is required.</source>
          <target state="translated">这是新的Net :: SMTP对象的构造函数。 &lt;code&gt;HOST&lt;/code&gt; 是需要SMTP连接的远程主机的名称。</target>
        </trans-unit>
        <trans-unit id="3dcdb98a1ad7340bd49db77b64b7ed1e7e6ac7fa" translate="yes" xml:space="preserve">
          <source>This is the constructor for the class. That means it is expected to return a blessed reference of some sort. The reference can be used to hold some internal information.</source>
          <target state="translated">这是该类的构造函数。这意味着它要返回一个某种祝福的引用。这个引用可以用来保存一些内部信息。</target>
        </trans-unit>
        <trans-unit id="7f8efcba15ad2c7fb65b185c0d87e50ef7c7af8b" translate="yes" xml:space="preserve">
          <source>This is the constructor for the class. That means it is expected to return a blessed reference through which the new array (probably an anonymous ARRAY ref) will be accessed.</source>
          <target state="translated">这是该类的构造函数。这意味着它将返回一个祝福的引用,通过这个引用来访问新的数组(可能是一个匿名的ARRAY ref)。</target>
        </trans-unit>
        <trans-unit id="4ddd75a12229b0af35fd3f3217e95a18f27831c9" translate="yes" xml:space="preserve">
          <source>This is the constructor for the class. That means it is expected to return a blessed reference through which the new object (probably but not necessarily an anonymous hash) will be accessed.</source>
          <target state="translated">这是该类的构造函数。这意味着它将返回一个受祝福的引用,通过这个引用可以访问新的对象(可能但不一定是匿名哈希)。</target>
        </trans-unit>
        <trans-unit id="c3ca80029525d0505c9c19a25619277e596ad6ff" translate="yes" xml:space="preserve">
          <source>This is the constructor for the class. That means it is expected to return a blessed reference to a new scalar (probably anonymous) that it's creating. For example:</source>
          <target state="translated">这是该类的构造函数。这意味着它要返回一个对它正在创建的新标量(可能是匿名的)的祝福引用。比如说</target>
        </trans-unit>
        <trans-unit id="97c7d16dbe44cbd95a833f47b94f50f6214ea17d" translate="yes" xml:space="preserve">
          <source>This is the default code set.</source>
          <target state="translated">这是默认的代码集。</target>
        </trans-unit>
        <trans-unit id="f42f9d3bfdedb4c34f927c70a8b84d5ca486809d" translate="yes" xml:space="preserve">
          <source>This is the default value if none was provided by the user. This is also the type &lt;code&gt;strict_type&lt;/code&gt; will look at when checking type integrity (see below).</source>
          <target state="translated">如果用户未提供默认值，则为默认值。这也是类型类型 &lt;code&gt;strict_type&lt;/code&gt; 在检查类型完整性时将查看的类型（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="60c4aeb1d9a588518e8c401cb7140416c2986e58" translate="yes" xml:space="preserve">
          <source>This is the default. If you can use the</source>
          <target state="translated">这是默认的。如果您可以使用</target>
        </trans-unit>
        <trans-unit id="2b115e2483ec3abaacaac1f9ae2d4e5dce2387c0" translate="yes" xml:space="preserve">
          <source>This is the directory where the .pm and .pod files you wish to have installed go. They are laid out according to namespace. So Foo::Bar is</source>
          <target state="translated">这是你希望安装的.pm和.pod文件所在的目录。它们是根据命名空间排列的。所以 Foo::Bar 是</target>
        </trans-unit>
        <trans-unit id="d930a14451f27529d05daafcbdbe065ab4700f11" translate="yes" xml:space="preserve">
          <source>This is the documentation of version 0.33</source>
          <target state="translated">这是0.33版本的文档</target>
        </trans-unit>
        <trans-unit id="412a728d73be865262b84817f05ddc7c35324cf4" translate="yes" xml:space="preserve">
          <source>This is the easiest way to implement threads, and the way most OSes start. The big disadvantage is that, since the OS knows nothing about threads, if one thread blocks they all do. Typical blocking activities include most system calls, most I/O, and things like &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是实现线程的最简单方法，也是大多数操作系统启动的方法。最大的缺点是，由于OS对线程一无所知，因此如果一个线程阻塞，它们都知道。典型的阻塞活动包括大多数系统调用，大多数I / O以及 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 之类的事情。</target>
        </trans-unit>
        <trans-unit id="9c6f35e7150b834f9f05080f6b4f16bfc1d90561" translate="yes" xml:space="preserve">
          <source>This is the email address that will be sent as your anonymous ftp password.</source>
          <target state="translated">这是将作为您的匿名ftp密码发送的电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="03a8ad8de2657fbb598356bba52fec61dbe4557b" translate="yes" xml:space="preserve">
          <source>This is the existing flag. If the lexical warnings pragma is &lt;b&gt;not&lt;/b&gt; used in any of you code, or any of the modules that you use, this flag will enable warnings everywhere. See &lt;a href=&quot;#Backward-Compatibility&quot;&gt;Backward Compatibility&lt;/a&gt; for details of how this flag interacts with lexical warnings.</source>
          <target state="translated">这是现有的标志。如果您的任何代码或所用的任何模块中&lt;b&gt;均未&lt;/b&gt;使用词法警告语用说明，则此标志将在各处启用警告。有关此标志如何与词汇警告交互的详细信息，请参见&lt;a href=&quot;#Backward-Compatibility&quot;&gt;向后兼容性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb41b10f4355a8511d19503b44266dfd63767081" translate="yes" xml:space="preserve">
          <source>This is the full Uppercase_Mapping property (as opposed to the Simple_Uppercase_Mapping given in the example for format &lt;code&gt;&quot;a&quot;&lt;/code&gt; ). The only difference between the two in the ranges shown is that the code point at 0x0149 (LATIN SMALL LETTER N PRECEDED BY APOSTROPHE) maps to a string of two characters, 0x02BC (MODIFIER LETTER APOSTROPHE) followed by 0x004E (LATIN CAPITAL LETTER N).</source>
          <target state="translated">这是完整的Uppercase_Mapping属性（与示例中格式 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 给出的Simple_Uppercase_Mapping相反）。所显示的范围之间的唯一区别是0x0149的代码点（由APOSTROPHE代替的拉丁小写字母N）映射为两个字符的字符串，即0x02BC（修饰符为APOSTROPHE），后跟0x004E（拉丁文的大写字母N）。</target>
        </trans-unit>
        <trans-unit id="871175ae8bd1e88a96090e3ee5d094a4a3c823c8" translate="yes" xml:space="preserve">
          <source>This is the function that does the real work. It should use the current values of @dl_require_symbols and @dl_resolve_using if required.</source>
          <target state="translated">这个函数才是真正的工作。如果需要的话,它应该使用@dl_require_symbols和@dl_resolve_using的当前值。</target>
        </trans-unit>
        <trans-unit id="0f9cd536958034f18b34b73afd163424db233b70" translate="yes" xml:space="preserve">
          <source>This is the global compile-time. That includes, basically, every &lt;code&gt;BEGIN&lt;/code&gt; block executed directly or indirectly from during the compile-time of the top-level program.</source>
          <target state="translated">这是全局编译时间。基本上，这包括在顶层程序的编译期间直接或间接执行的每个 &lt;code&gt;BEGIN&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="394f7937653a5d479f930b2ee200056fdee9eaa3" translate="yes" xml:space="preserve">
          <source>This is the highest UID on the current system that refers to a root UID. This is used to make sure that the temporary directory is owned by a system UID (C</source>
          <target state="translated">这是当前系统中最高的UID,它指的是一个根UID。用来确定临时目录是由系统UID拥有的(C</target>
        </trans-unit>
        <trans-unit id="6328f4bdaf24cfea2076758e63c586a6679bf323" translate="yes" xml:space="preserve">
          <source>This is the internal function implementing the &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">这是实现 &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; 运算符的内部函数，但是您可以直接使用它。所述 &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; 操作中更详细讨论的&lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I / O算perlop得到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2a5b446b2d0ba2a35085618db8046fb9068c0dc" translate="yes" xml:space="preserve">
          <source>This is the internal function implementing the &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">这是实现 &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; 运算符的内部函数，但是您可以直接使用它。所述 &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; 操作中更详细讨论的&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I / O算perlop得到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c755425aff2265b37f84fd527f7d77c0d4f14125" translate="yes" xml:space="preserve">
          <source>This is the inverse of the &lt;code&gt;:utf8&lt;/code&gt; layer. It turns off the flag on the layer below so that data read from it is considered to be &quot;octets&quot; i.e. characters in the range 0..255 only. Likewise on output perl will warn if a &quot;wide&quot; character is written to a such a stream.</source>
          <target state="translated">这与 &lt;code&gt;:utf8&lt;/code&gt; 层相反。它关闭了下一层的标志，因此从它读取的数据被认为是&amp;ldquo;八位字节&amp;rdquo;，即仅在0..255范围内的字符。同样，在输出时，如果将&amp;ldquo;宽&amp;rdquo;字符写入这样的流，则perl将发出警告。</target>
        </trans-unit>
        <trans-unit id="05a7690a54b93d5cbfbc43460dc86928e9ff4860" translate="yes" xml:space="preserve">
          <source>This is the least computationally expensive strategy. It may require some user education.</source>
          <target state="translated">这是计算成本最低的策略。它可能需要一些用户教育。</target>
        </trans-unit>
        <trans-unit id="6fe99eed7290a54a82a6a3a3aa2c3b4a2bb07743" translate="yes" xml:space="preserve">
          <source>This is the level of HTML &quot;Hn&quot; element to which a Pod &quot;head1&quot; corresponds. For example, if &lt;code&gt;html_h_level&lt;/code&gt; is set to 2, a head1 will produce an H2, a head2 will produce an H3, and so on.</source>
          <target state="translated">这是Pod&amp;ldquo; head1&amp;rdquo;所对应的HTML&amp;ldquo; Hn&amp;rdquo;元素的级别。例如，如果 &lt;code&gt;html_h_level&lt;/code&gt; 设置为2 ，则head1将产生一个H2，head2将产生一个H3，依此类推。</target>
        </trans-unit>
        <trans-unit id="dbf2d95bd6e71bbc931d90912ac4916f4a329b66" translate="yes" xml:space="preserve">
          <source>This is the lower layer of the Perl parser, managing characters and tokens.</source>
          <target state="translated">这是Perl解析器的下层,管理字符和标记。</target>
        </trans-unit>
        <trans-unit id="12044b247d0e34184da8c4d82be7f35e7cce2add" translate="yes" xml:space="preserve">
          <source>This is the module that is used as a frontend to the Perl Compiler.</source>
          <target state="translated">这是作为Perl编译器的前端模块。</target>
        </trans-unit>
        <trans-unit id="d48b3bc5add16b69ab6764e7aa4a54509b451c2e" translate="yes" xml:space="preserve">
          <source>This is the most compact form, but it is not well suited for printing or embedding in places that can't handle arbitrary data.</source>
          <target state="translated">这是最紧凑的形式,但它不太适合打印或嵌入到不能处理任意数据的地方。</target>
        </trans-unit>
        <trans-unit id="6f4b6501db089524291430841e3e59e649fd1a7f" translate="yes" xml:space="preserve">
          <source>This is the most important method in Locale::Maketext:</source>
          <target state="translated">这是Locale::Maketext中最重要的方法。</target>
        </trans-unit>
        <trans-unit id="d28b3b2c303cf9fffc3f2cf8865a24397d2fa229" translate="yes" xml:space="preserve">
          <source>This is the most serious problem in Perl 5.20 and earlier. Fixing this required internal changes in Perl 5.22.</source>
          <target state="translated">这是Perl 5.20和更早版本中最严重的问题。要解决这个问题,需要在Perl 5.22中进行内部修改。</target>
        </trans-unit>
        <trans-unit id="cb5f568d5745a8f721d4963249e63f161fe9a2ef" translate="yes" xml:space="preserve">
          <source>This is the name or Internet address of the remote host the server is running on. We could have specified a longer name like &lt;code&gt;&quot;www.perl.com&quot;&lt;/code&gt; , or an address like &lt;code&gt;&quot;207.171.7.72&quot;&lt;/code&gt; . For demonstration purposes, we've used the special hostname &lt;code&gt;&quot;localhost&quot;&lt;/code&gt; , which should always mean the current machine you're running on. The corresponding Internet address for localhost is &lt;code&gt;&quot;127.0.0.1&quot;&lt;/code&gt; , if you'd rather use that.</source>
          <target state="translated">这是服务器正在运行的远程主机的名称或Internet地址。我们可以指定一个较长的名称，如 &lt;code&gt;&quot;www.perl.com&quot;&lt;/code&gt; ，或如地址 &lt;code&gt;&quot;207.171.7.72&quot;&lt;/code&gt; 。出于演示目的，我们使用了特殊的主机名 &lt;code&gt;&quot;localhost&quot;&lt;/code&gt; ，该主机名始终表示您正在运行的当前计算机。如果您愿意使用localhost的对应Internet地址为 &lt;code&gt;&quot;127.0.0.1&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0d786852f1a6c1dea1d6a765cf9070b49db2732" translate="yes" xml:space="preserve">
          <source>This is the normal entry point for automatic dynamic loading in Perl.</source>
          <target state="translated">这是Perl中自动动态加载的正常切入点。</target>
        </trans-unit>
        <trans-unit id="26340ea40f200c2c1e1dfe6e82669d9feb0fd306" translate="yes" xml:space="preserve">
          <source>This is the normal operation. It translates various literals encountered in the Perl source file from the encoding</source>
          <target state="translated">这是正常的操作。它将Perl源文件中遇到的各种文字从编码中翻译出来。</target>
        </trans-unit>
        <trans-unit id="a889101131356644debee9dab9979e5406fc98f2" translate="yes" xml:space="preserve">
          <source>This is the old form of &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;, which has no flags parameter.</source>
          <target state="translated">这是&lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;的旧形式，没有flags参数。</target>
        </trans-unit>
        <trans-unit id="230f7f138d64e36f52758c07316eb9c1eee4e053" translate="yes" xml:space="preserve">
          <source>This is the only executable with does not require OS/2.</source>
          <target state="translated">这是唯一不需要OS/2的可执行文件。</target>
        </trans-unit>
        <trans-unit id="46297865ee1d382d368720a50d5f077d38b59862" translate="yes" xml:space="preserve">
          <source>This is the only form of quoting in perl where there is no need to worry about escaping content, something that code generators can and do make good use of.</source>
          <target state="translated">这是perl中唯一一种不用担心内容转义的引用形式,代码生成器可以也确实很好地利用了这一点。</target>
        </trans-unit>
        <trans-unit id="346faabc7115374b4309ef76fa20a9a155ac4597" translate="yes" xml:space="preserve">
          <source>This is the only implementation for which &lt;code&gt;PerlIO_apply_layers()&lt;/code&gt; does anything &quot;interesting&quot;.</source>
          <target state="translated">这是 &lt;code&gt;PerlIO_apply_layers()&lt;/code&gt; 进行任何&amp;ldquo;有趣&amp;rdquo;操作的唯一实现。</target>
        </trans-unit>
        <trans-unit id="60f1241a31b62b7745507b52788f2eba7d4fd0c6" translate="yes" xml:space="preserve">
          <source>This is the only way you can create a custom named sequence of code points.</source>
          <target state="translated">这是唯一可以创建一个自定义命名的代码点序列的方法。</target>
        </trans-unit>
        <trans-unit id="78dcaca387707f29d8cc3a2585a362d39b2766bf" translate="yes" xml:space="preserve">
          <source>This is the output when it is executed:</source>
          <target state="translated">这是执行时的输出。</target>
        </trans-unit>
        <trans-unit id="e716423e3a6c7217437c06867a38499b8c6c05ea" translate="yes" xml:space="preserve">
          <source>This is the preferred method of passing input to the constructor.</source>
          <target state="translated">这是向构造函数传递输入的首选方法。</target>
        </trans-unit>
        <trans-unit id="3f3e131dd809784965b27d16458f5818d1df8c11" translate="yes" xml:space="preserve">
          <source>This is the preferred way to get the &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; object. You should</source>
          <target state="translated">这是获取&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;对象的首选方法。你应该</target>
        </trans-unit>
        <trans-unit id="cf4eba93f23876936daa22cc2fcf49ea7ecb8e5d" translate="yes" xml:space="preserve">
          <source>This is the primary function for copying scalars, and most other copy-ish functions and macros use this underneath.</source>
          <target state="translated">这是复制标量的主要函数,其他大多数复制类函数和宏都在下面使用这个函数。</target>
        </trans-unit>
        <trans-unit id="d281635f40f0f24e55d7183cb71173555b3719a4" translate="yes" xml:space="preserve">
          <source>This is the primary interface for interacting with C&amp;lt;:temp&amp;gt;. Using the OO interface a temporary file can be created when the object is constructed and the file can be removed when the object is no longer required.</source>
          <target state="translated">这是与C &amp;lt;：temp&amp;gt;进行交互的主要接口。使用OO接口，可以在构造对象时创建一个临时文件，而在不再需要该对象时可以删除该文件。</target>
        </trans-unit>
        <trans-unit id="05f4f2b81da1e7eb80147e0a0e24d6cb8a7b101e" translate="yes" xml:space="preserve">
          <source>This is the purpose of</source>
          <target state="translated">这就是我们的目的。</target>
        </trans-unit>
        <trans-unit id="c0f05eba3f3af5d5e22733e34a51cbbb4cab705c" translate="yes" xml:space="preserve">
          <source>This is the recommended interface for creation of temporary directories. By default the directory will not be removed on exit (that is, it won't be temporary; this behaviour can not be changed because of issues with backwards compatibility). To enable removal either use the CLEANUP option which will trigger removal on program exit, or consider using the &quot;newdir&quot; method in the object interface which will allow the directory to be cleaned up when the object goes out of scope.</source>
          <target state="translated">这是创建临时目录的推荐界面。默认情况下,该目录不会在退出时被删除(也就是说,它不会是临时的;由于向后兼容性的问题,这种行为无法改变)。如果要启用删除,可以使用cleanup选项,它将在程序退出时触发删除,或者考虑使用对象接口中的 &quot;newdir &quot;方法,它将允许在对象超出范围时清理目录。</target>
        </trans-unit>
        <trans-unit id="bd97525cca1b83f38306d58e91365a2fad99fcd5" translate="yes" xml:space="preserve">
          <source>This is the root directory into which the code will be installed. It</source>
          <target state="translated">这是代码将被安装到的根目录。它</target>
        </trans-unit>
        <trans-unit id="bc652aaf1adcdf8a4d8dd86919935233000111ae" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;simple&quot;&gt;Test::Simple&lt;/a&gt;'s &lt;code&gt;ok()&lt;/code&gt; routine.</source>
          <target state="translated">这与&lt;a href=&quot;simple&quot;&gt;Test :: Simple&lt;/a&gt;的 &lt;code&gt;ok()&lt;/code&gt; 例程相同。</target>
        </trans-unit>
        <trans-unit id="c649411547df265abe7a680926ab24280bdd17cc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;FB_QUIET&lt;/code&gt; above, except that instead of being silent on errors, it issues a warning. This is handy for when you are debugging.</source>
          <target state="translated">这与上面的 &lt;code&gt;FB_QUIET&lt;/code&gt; 相同，只是它发出警告而不是对错误保持沉默。这在调试时非常方便。</target>
        </trans-unit>
        <trans-unit id="0ae700aa87900b468f3878348b89397f03c7e04f" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\p{Blank}&lt;/code&gt; : a character that changes the spacing horizontally.</source>
          <target state="translated">这与 &lt;code&gt;\h&lt;/code&gt; 和 &lt;code&gt;\p{Blank}&lt;/code&gt; ：一个可水平更改间距的字符。</target>
        </trans-unit>
        <trans-unit id="fbc09138370cb171c094bfc6c30b8f2a18097f95" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\p{HorizSpace}&lt;/code&gt; : A character that changes the spacing horizontally.</source>
          <target state="translated">这与 &lt;code&gt;\h&lt;/code&gt; 和 &lt;code&gt;\p{HorizSpace}&lt;/code&gt; ：一个可水平更改间距的字符。</target>
        </trans-unit>
        <trans-unit id="7b5f883b8c3b129477e8adf6ce3d17842b4509c9" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\s&lt;/code&gt;, including beyond ASCII.</source>
          <target state="translated">这与 &lt;code&gt;\s&lt;/code&gt; 相同，包括ASCII以外的内容。</target>
        </trans-unit>
        <trans-unit id="7e9dbff8b446293a154a68b17c80ce2409d2cfe1" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\s&lt;/code&gt;, restricted to ASCII, namely &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; and starting in Perl v5.18, a vertical tab.</source>
          <target state="translated">这与 &lt;code&gt;\s&lt;/code&gt; 相同，仅限于ASCII，即 &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; 并且从Perl v5.18（垂直标签）开始。</target>
        </trans-unit>
        <trans-unit id="6256409cd33d9cdf7337e20319de658ce6caee15" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\v&lt;/code&gt; : A character that changes the spacing vertically.</source>
          <target state="translated">这与 &lt;code&gt;\v&lt;/code&gt; 相同：垂直更改间距的字符。</target>
        </trans-unit>
        <trans-unit id="4da601bf04f15ab42ea7eb6f0e3d60619c539d79" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\w&lt;/code&gt; , including over 100_000 characters beyond ASCII.</source>
          <target state="translated">这与 &lt;code&gt;\w&lt;/code&gt; 相同，包括超过ASCII的100_000个字符。</target>
        </trans-unit>
        <trans-unit id="f93b7dea9a5c9d0ac4b1d3dcf4d8d34138603086" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\w&lt;/code&gt; , restricted to ASCII, namely &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;</source>
          <target state="translated">这与 &lt;code&gt;\w&lt;/code&gt; 相同，仅限于ASCII，即 &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8213b0c400904773c8fb4aa6534b5c57f7c89c7f" translate="yes" xml:space="preserve">
          <source>This is the same as machine name except that default matches any name. There can be only one default token, and it must be after all machine tokens. This is normally used as:</source>
          <target state="translated">这与机器名称相同,只是默认与任何名称相匹配。默认标记只能有一个,而且必须在所有机器标记之后。这通常被用来作为。</target>
        </trans-unit>
        <trans-unit id="941bd502236d1dea3c975471a03ebbb873d56ae1" translate="yes" xml:space="preserve">
          <source>This is the same as the bin variable, but is filename expanded at configuration time, for use in your makefiles.</source>
          <target state="translated">这与 bin 变量相同,但在配置时扩展了文件名,以便在 makefile 中使用。</target>
        </trans-unit>
        <trans-unit id="c486c8726e0003d1e95bb96e015320afb3b6dfa4" translate="yes" xml:space="preserve">
          <source>This is the same as the sitebin variable, but is filename expanded at configuration time, for use in your makefiles.</source>
          <target state="translated">这与 sitebin 变量相同,但在配置时扩展了文件名,以便在 makefile 中使用。</target>
        </trans-unit>
        <trans-unit id="cdc9f1e5725bf6d120b1c425b6dcc03a53feac1e" translate="yes" xml:space="preserve">
          <source>This is the same as the sitescript variable, but is filename expanded at configuration time, for use in your makefiles.</source>
          <target state="translated">这与 sitescript 变量相同,但在配置时扩展了文件名,以便在 makefile 中使用。</target>
        </trans-unit>
        <trans-unit id="43bee717903e4bfa25fa311f06b4356fc3deab92" translate="yes" xml:space="preserve">
          <source>This is the same executable as</source>
          <target state="translated">这是相同的可执行文件,如</target>
        </trans-unit>
        <trans-unit id="9b93eb63da42a6ae191e4cb65dbdf73df302acbd" translate="yes" xml:space="preserve">
          <source>This is the same facility used by the ANSI_COLORS_ALIASES environment variable (see &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; below) but can be used at runtime, not just when the module is loaded.</source>
          <target state="translated">这与ANSI_COLORS_ALIASES环境变量（请参见下面的&lt;a href=&quot;#ENVIRONMENT&quot;&gt;环境&lt;/a&gt;）使用的功能相同，但可以在运行时使用，而不仅是在加载模块时使用。</target>
        </trans-unit>
        <trans-unit id="08be885869480e470d72f31729368e83f4f891ce" translate="yes" xml:space="preserve">
          <source>This is the semaphore &quot;P operation&quot; (the name derives from the Dutch word &quot;pak&quot;, which means &quot;capture&quot; -- the semaphore operations were named by the late Dijkstra, who was Dutch).</source>
          <target state="translated">这就是旗语 &quot;P操作&quot;(这个名字来源于荷兰语 &quot;pak&quot;,意思是 &quot;捕获&quot;--旗语操作是由已故荷兰人Dijkstra命名的)。</target>
        </trans-unit>
        <trans-unit id="2f98c90508409620ac27064f1b688373cf5874e7" translate="yes" xml:space="preserve">
          <source>This is the semaphore &quot;V operation&quot; (the name derives from the Dutch word &quot;vrij&quot;, which means &quot;release&quot;).</source>
          <target state="translated">这就是信号灯 &quot;V操作&quot;(这个名字来源于荷兰语 &quot;vrij&quot;,意思是 &quot;释放&quot;)。</target>
        </trans-unit>
        <trans-unit id="a276cc3b822e5fb68d4f30cd1b14facc89497c26" translate="yes" xml:space="preserve">
          <source>This is the service name or port number we'd like to connect to. We could have gotten away with using just &lt;code&gt;&quot;daytime&quot;&lt;/code&gt; on systems with a well-configured system services file,[FOOTNOTE: The system services file is found in</source>
          <target state="translated">这是我们要连接的服务名称或端口号。我们本可以在带有配置良好的系统服务文件的系统上仅使用 &lt;code&gt;&quot;daytime&quot;&lt;/code&gt; ，[注意：系统服务文件位于</target>
        </trans-unit>
        <trans-unit id="55fdeec4b425af4c4fa8e9a6591ac8f8843fb073" translate="yes" xml:space="preserve">
          <source>This is the set of three-digit numeric codes from ISO 3166-1, such as 064 for Bhutan. These codes are actually defined and maintained by the U.N. Statistics division.</source>
          <target state="translated">这是ISO 3166-1中的一套三位数数字代码,例如不丹的064。这些代码实际上是由联合国统计司定义和维护的。</target>
        </trans-unit>
        <trans-unit id="233002d6fef285c425f811c11a49106685a1ea36" translate="yes" xml:space="preserve">
          <source>This is the set of three-digit numeric codes from ISO 4217.</source>
          <target state="translated">这是一组来自ISO 4217的三位数数字代码。</target>
        </trans-unit>
        <trans-unit id="bfc22c533358da5232ffaf0870e72df120463375" translate="yes" xml:space="preserve">
          <source>This is the set of three-letter (lowercase) bibliographic codes from ISO 639-2 and 639-5, such as 'heb' for Hebrew. It also includes additions to this set included in the IANA language registry.</source>
          <target state="translated">这是一套ISO 639-2和639-5中的三字母(小写)书目代码,例如希伯来文的 &quot;heb&quot;。它还包括IANA语言登记册中对这套编码的补充。</target>
        </trans-unit>
        <trans-unit id="b92c48de1f053f976481719f4f81fdeafd62c023" translate="yes" xml:space="preserve">
          <source>This is the set of three-letter (lowercase) codes from ISO 3166-1, such as 'brb' for Barbados. These codes are actually defined and maintained by the U.N. Statistics division.</source>
          <target state="translated">这是ISO 3166-1中的一组三个字母(小写)的代码,例如巴巴多斯的 &quot;brb&quot;。这些代码实际上是由联合国统计司定义和维护的。</target>
        </trans-unit>
        <trans-unit id="fc3ae49739721f6f95ec3491951800d9f83ab84d" translate="yes" xml:space="preserve">
          <source>This is the set of three-letter (lowercase) terminologic codes from ISO 639.</source>
          <target state="translated">这是ISO 639中的一组三个字母(小写)的术语代码。</target>
        </trans-unit>
        <trans-unit id="e6807d4fe48e31222818be49432ee24ba40f6e11" translate="yes" xml:space="preserve">
          <source>This is the set of two-letter (lowercase) codes from ISO 3166-1, such as 'tv' for Tuvalu.</source>
          <target state="translated">这是ISO 3166-1中的一组双字母(小写)代码,如图瓦卢的 &quot;tv&quot;。</target>
        </trans-unit>
        <trans-unit id="acd74dadb16fbf234cd8906af18d327510923daf" translate="yes" xml:space="preserve">
          <source>This is the set of two-letter (lowercase) codes from ISO 639-1, such as 'he' for Hebrew. It also includes additions to this set included in the IANA language registry.</source>
          <target state="translated">这是一套ISO 639-1的双字母(小写)代码,例如希伯来语的 &quot;he&quot;。它还包括IANA语言注册表中对这套代码的补充。</target>
        </trans-unit>
        <trans-unit id="94c349798d0090117d6582dfd31da6381fa814e6" translate="yes" xml:space="preserve">
          <source>This is the standard unix library builder. We use wlib. With Watcom 10.6, when wlib is linked as &quot;ar&quot;, it behaves like ar and all is fine. Under 9.5, a cover is required. One is included in ../qnx</source>
          <target state="translated">这是标准的unix库构建器。我们使用的是wlib。在Watcom 10.6的情况下,当wlib链接为 &quot;ar &quot;时,它的行为就像ar一样,一切正常。在9.5下,需要一个封面。在./qnx中包含了一个。</target>
        </trans-unit>
        <trans-unit id="e58e7a91164b2c61f4741d28ff686a23ffe5c5eb" translate="yes" xml:space="preserve">
          <source>This is the useragent as &lt;code&gt;LWP&lt;/code&gt; will report it.</source>
          <target state="translated">这是用户代理，因为 &lt;code&gt;LWP&lt;/code&gt; 将报告它。</target>
        </trans-unit>
        <trans-unit id="15261bed556ba490ce02abc9f071087b0df0d036" translate="yes" xml:space="preserve">
          <source>This is the version of &lt;code&gt;Test::Harness&lt;/code&gt; .</source>
          <target state="translated">这是 &lt;code&gt;Test::Harness&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="6a22ff202852862487c229ecb92eca4a84e51119" translate="yes" xml:space="preserve">
          <source>This is to prevent the problem of one module changing the array base out from under another module inadvertently. See &lt;a href=&quot;perlvar#%24%5b&quot;&gt;$[ in perlvar&lt;/a&gt; and &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;.</source>
          <target state="translated">这是为了防止一个模块无意中将阵列基座从另一个模块下移出的问题。请参阅&lt;a href=&quot;perlvar#%24%5b&quot;&gt;$ [在perlvar&lt;/a&gt;和&lt;a href=&quot;arybase&quot;&gt;arybase中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd68c145924ef1010d3fbbd465d445886b4ed770" translate="yes" xml:space="preserve">
          <source>This is tremendously more efficient than reading the entire file into memory as an array of lines and then processing it one element at a time, which is often--if not almost always--the wrong approach. Whenever you see someone do this:</source>
          <target state="translated">这比把整个文件作为一个数组读到内存中,然后一次只处理一个元素要高效得多,而后者往往是--如果不是几乎总是--错误的方法。每当你看到有人这样做的时候。</target>
        </trans-unit>
        <trans-unit id="a35e6506a9b88f457b9f4a865f1ac711f7750ab3" translate="yes" xml:space="preserve">
          <source>This is true for all numeric template codes. But don't expect miracles: if the packed value exceeds the allotted byte capacity, high order bits are silently discarded, and unpack certainly won't be able to pull them back out of some magic hat. And, when you pack using a signed template code such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, an excess value may result in the sign bit getting set, and unpacking this will smartly return a negative value.</source>
          <target state="translated">对于所有数字模板代码都是如此。但是不要指望奇迹：如果压缩后的值超过了分配的字节容量，则高阶位会被静默丢弃，并且解压缩肯定无法将其从魔术帽中拉出来。并且，当您使用带符号的模板代码（例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; )打包时，过多的值可能会导致符号位被置位，而将其解压缩将聪明地返回负值。</target>
        </trans-unit>
        <trans-unit id="e7272df8729202c7ff033cb7fabd9d5f450b6676" translate="yes" xml:space="preserve">
          <source>This is true on Unix, where &lt;code&gt;catdir(&quot;&quot;,&quot;a&quot;,&quot;b&quot;)&lt;/code&gt; yields &quot;/a/b&quot; and &lt;code&gt;rootdir()&lt;/code&gt; is &quot;/&quot;. Note that &lt;code&gt;rootdir()&lt;/code&gt; on Mac OS is the startup volume, which is the closest in concept to Unix' &quot;/&quot;. This should help to run existing scripts originally written for Unix.</source>
          <target state="translated">在Unix上是这样，其中 &lt;code&gt;catdir(&quot;&quot;,&quot;a&quot;,&quot;b&quot;)&lt;/code&gt; 产生&amp;ldquo; / a / b&amp;rdquo;，而 &lt;code&gt;rootdir()&lt;/code&gt; 是&amp;ldquo; /&amp;rdquo;。请注意，Mac OS上的 &lt;code&gt;rootdir()&lt;/code&gt; 是启动卷，其概念上与Unix'/'最接近。这应该有助于运行最初为Unix编写的现有脚本。</target>
        </trans-unit>
        <trans-unit id="397412f4d7a6d97f2f133b4c7f78e290d9cd2f84" translate="yes" xml:space="preserve">
          <source>This is typically used when testing cannot continue such as a critical module failing to compile or a necessary external utility not being available such as a database connection failing.</source>
          <target state="translated">这通常是在测试无法继续时使用的,比如关键模块无法编译,或者必要的外部工具不可用,比如数据库连接失败。</target>
        </trans-unit>
        <trans-unit id="bb1c3b06955402418f9a1645b31426cf2675075b" translate="yes" xml:space="preserve">
          <source>This is ugly. As of Perl 5.9.2, there's a much nicer way to express your desire for a certain byte-order: the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers. &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier, while &lt;code&gt;&amp;lt;&lt;/code&gt; is the little-endian modifier. Using them, we could rewrite the above code as:</source>
          <target state="translated">这很丑。从Perl 5.9.2开始，有一种更好的方式来表达您对某个字节顺序的渴望： &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&lt;/code&gt; 修饰符。 &lt;code&gt;&amp;gt;&lt;/code&gt; 是大端修饰符，而 &lt;code&gt;&amp;lt;&lt;/code&gt; 是小端修饰符。使用它们，我们可以将上面的代码重写为：</target>
        </trans-unit>
        <trans-unit id="f64a4511ee072e665d5896089985a46b9305c064" translate="yes" xml:space="preserve">
          <source>This is used (optionally) by configure to list the contents of libraries. I will generate a cover function on the fly in the UU directory.</source>
          <target state="translated">这被configure用来(可选)列出库的内容。我将在UU目录下飞快地生成一个封面函数。</target>
        </trans-unit>
        <trans-unit id="e13da45b8fdb5dfbf619cb00d77540e51b9f0de1" translate="yes" xml:space="preserve">
          <source>This is used by Perl itself only for accessing operating system error messages via &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$!&lt;/a&gt; and &lt;a href=&quot;perlvar#%24EXTENDED_OS_ERROR&quot;&gt;$^E&lt;/a&gt;.</source>
          <target state="translated">Perl本身仅将其用于通过&lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$！&lt;/a&gt;访问操作系统错误消息。和&lt;a href=&quot;perlvar#%24EXTENDED_OS_ERROR&quot;&gt;$ ^ E&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="685a67efb688fb26fb65af406110717f25e2b745" translate="yes" xml:space="preserve">
          <source>This is used by XS code that that is &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale-aware to force the locale for category &lt;code&gt;LC_NUMERIC&lt;/code&gt; to be what perl thinks is the current underlying locale. (The perl interpreter could be wrong about what the underlying locale actually is if some C or XS code has called the C library function</source>
          <target state="translated">XS代码使用此代码，它是 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境感知的，以强制类别 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 的语言环境成为perl认为是当前基础语言环境的语言。（如果某些C或XS代码调用了C库函数，则Perl解释器可能会误解基本语言环境的实际含义。</target>
        </trans-unit>
        <trans-unit id="6e065e9419827f7c0624c9591e7e2d9d64727710" translate="yes" xml:space="preserve">
          <source>This is used by perl to run external commands which explicitly require shell, like the commands using</source>
          <target state="translated">这被perl用来运行明确需要shell的外部命令,比如使用</target>
        </trans-unit>
        <trans-unit id="64698930b8cfe161fa438c57b55293be0ad5eced" translate="yes" xml:space="preserve">
          <source>This is used by the &lt;code&gt;perldoc&lt;/code&gt; program (see &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;), and may be used to generate HTML documentation usable by WWW browsers, and documentation in zillions of other formats: &lt;code&gt;info&lt;/code&gt; , &lt;code&gt;LaTeX&lt;/code&gt; , &lt;code&gt;Acrobat&lt;/code&gt; , &lt;code&gt;FrameMaker&lt;/code&gt; and so on. [Use programs such as</source>
          <target state="translated">这由 &lt;code&gt;perldoc&lt;/code&gt; 程序使用（请参阅&lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;），并且可以用于生成可供WWW浏览器使用的HTML文档以及成千上万种其他格式的文档： &lt;code&gt;info&lt;/code&gt; ， &lt;code&gt;LaTeX&lt;/code&gt; ， &lt;code&gt;Acrobat&lt;/code&gt; ， &lt;code&gt;FrameMaker&lt;/code&gt; 等。[使用诸如</target>
        </trans-unit>
        <trans-unit id="938e99644f7869851b92cffce88c437cad0e1198" translate="yes" xml:space="preserve">
          <source>This is used for instance by &lt;a href=&quot;http://search.cpan.org/perldoc/Math::BigInt::Constant&quot;&gt;Math::BigInt::Constant&lt;/a&gt;.</source>
          <target state="translated">例如，&lt;a href=&quot;http://search.cpan.org/perldoc/Math::BigInt::Constant&quot;&gt;Math :: BigInt :: Constant使用它&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89a92812a074e6032ec40db97f0e02dae0db9d29" translate="yes" xml:space="preserve">
          <source>This is used for passing perl filehandles to and from C using &lt;code&gt;FILE *&lt;/code&gt; structures.</source>
          <target state="translated">这用于使用 &lt;code&gt;FILE *&lt;/code&gt; 结构将perl文件句柄与C之间传递。</target>
        </trans-unit>
        <trans-unit id="e990faa3bfbeb576a41b956da185db53775fca9a" translate="yes" xml:space="preserve">
          <source>This is used for passing perl filehandles to and from C using &lt;code&gt;PerlIO *&lt;/code&gt; structures. The file handle can used for reading and writing. This corresponds to the &lt;code&gt;+&amp;lt;&lt;/code&gt; mode, see also T_IN and T_OUT.</source>
          <target state="translated">这用于使用 &lt;code&gt;PerlIO *&lt;/code&gt; 结构将perl文件句柄与C 传递。文件句柄可用于读取和写入。这对应于 &lt;code&gt;+&amp;lt;&lt;/code&gt; 模式，另请参见T_IN和T_OUT。</target>
        </trans-unit>
        <trans-unit id="45afb2cb863a986ba92ff0947755735a5e6d66a7" translate="yes" xml:space="preserve">
          <source>This is used for tests that under some conditions can be skipped. It's basically equivalent to:</source>
          <target state="translated">这个用于某些条件下可以跳过的测试。它基本等同于。</target>
        </trans-unit>
        <trans-unit id="9e0a9f53f8706ee02f00b4b66258c8d781bdebc5" translate="yes" xml:space="preserve">
          <source>This is used heavily by Configure and then by perl itself. QNX4's version is fine, but Configure will choke on the 16-bit version, so if you are running QNX 4.22, link /bin/sh to /bin32/ksh</source>
          <target state="translated">Configure 和 perl 本身都会大量使用这个功能。QNX4 的版本没问题,但配置会对 16 位版本造成阻碍,因此,如果运行 QNX 4.22,请将 /bin/sh 链接到 /bin32/ksh。</target>
        </trans-unit>
        <trans-unit id="88552389c076b1697dd901849fcd278da90bf901" translate="yes" xml:space="preserve">
          <source>This is used in conjunction with one of the macros &lt;a href=&quot;#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;STORE_LC_NUMERIC_SET_TO_NEEDED&lt;/a&gt; and &lt;a href=&quot;#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&lt;/a&gt;</source>
          <target state="translated">与宏&lt;a href=&quot;#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;STORE_LC_NUMERIC_SET_TO_NEEDED&lt;/a&gt;和&lt;a href=&quot;#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&lt;/a&gt;之一结合使用</target>
        </trans-unit>
        <trans-unit id="51b114b6070b2dbbb4c5faa25f40aadc4f1bf209" translate="yes" xml:space="preserve">
          <source>This is used internally by various sv-modifying functions, such as sv_setsv, sv_setiv and sv_pvn_force.</source>
          <target state="translated">这在内部被各种sv修改函数使用,比如sv_etssv、sv_setiv和sv_pvn_force。</target>
        </trans-unit>
        <trans-unit id="2674017b922020ed58a1ae38d38243bb158c698b" translate="yes" xml:space="preserve">
          <source>This is used to convert the perl argument list to a C array and for pushing the contents of a C array onto the perl argument stack.</source>
          <target state="translated">它用于将perl参数列表转换为C数组,并将C数组的内容推送到perl参数栈中。</target>
        </trans-unit>
        <trans-unit id="1dfca62a32b70d4bff67e06bed578f950673ab61" translate="yes" xml:space="preserve">
          <source>This is used to help wrap XS or C code that that is &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale-aware. This locale category is generally kept set to the C locale by Perl for backwards compatibility, and because most XS code that reads floating point values can cope only with the decimal radix character being a dot.</source>
          <target state="translated">这用于帮助包装 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境感知的XS或C代码。为了向后兼容，Perl将此语言环境类别通常设置为C语言环境，因为大多数读取浮点值的XS代码只能应付十进制基数点。</target>
        </trans-unit>
        <trans-unit id="61ffe3ce8492ad29999613fc31942e00c100ad7a" translate="yes" xml:space="preserve">
          <source>This is used to set the build type to debug or release. Change the build type only after executing SetNWBld.bat</source>
          <target state="translated">这用于将构建类型设置为调试或发布。只有在执行SetNWBld.bat后,才能更改构建类型。</target>
        </trans-unit>
        <trans-unit id="33295dd981a7660fbc204da5e0a0ad1772d342a0" translate="yes" xml:space="preserve">
          <source>This is used to track which tests unexpectedly succeeded.</source>
          <target state="translated">这是用来跟踪哪些测试意外成功的。</target>
        </trans-unit>
        <trans-unit id="717574ff9403ecd69bea9a30328bf1a90f831842" translate="yes" xml:space="preserve">
          <source>This is used to write code for styles of operating system. See os_flavor_is() for use.</source>
          <target state="translated">这是用来编写操作系统风格的代码。使用方法参见os_flavor_is()。</target>
        </trans-unit>
        <trans-unit id="a64fac67cd72a00814ab828e9c9bd92a6463973e" translate="yes" xml:space="preserve">
          <source>This is useful for code like:</source>
          <target state="translated">这对于像这样的代码很有用。</target>
        </trans-unit>
        <trans-unit id="0a2bc63942e3a80b89ce25e1ac1f8a32f3bda215" translate="yes" xml:space="preserve">
          <source>This is useful for keeping copies of references, but you don't want to prevent the object being DESTROY-ed at its usual time.</source>
          <target state="translated">这对于保存引用的副本是很有用的,但你不想阻止对象在平时被DESTROY-ed。</target>
        </trans-unit>
        <trans-unit id="42a4e9a54829e179cb44fc85ba544f789e1c2e15" translate="yes" xml:space="preserve">
          <source>This is useful if you want to report then some other way than &lt;code&gt;carp&lt;/code&gt; 'ing when the verbose flag is on.</source>
          <target state="translated">如果您要报告详细标志打开时的除 &lt;code&gt;carp&lt;/code&gt; 以外的其他方式，这将非常有用。</target>
        </trans-unit>
        <trans-unit id="3180e175adf2fd8ff88aab37691cd4b1c546dfea" translate="yes" xml:space="preserve">
          <source>This is useful to avoid a CODE: block for a C function which takes a parameter by reference. Typically, the parameter should be not a pointer type (an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; but not an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int*&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;long*&lt;/code&gt; ).</source>
          <target state="translated">对于避免通过引用获取参数的C函数的CODE：块，这很有用。通常，该参数不应为指针类型（ &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;long&lt;/code&gt; ,而不是 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int*&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;long*&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9e13765136cecd81d6e3522084679384fb85c0ae" translate="yes" xml:space="preserve">
          <source>This is useful when calculating checksum for files:</source>
          <target state="translated">这在计算文件的校验和时很有用。</target>
        </trans-unit>
        <trans-unit id="61dbd2c8b8aff05e41e7c5996e136b2e52680ad0" translate="yes" xml:space="preserve">
          <source>This is useful with sockets when you want to tell the other side you're done writing but not done reading, or vice versa. It's also a more insistent form of close because it also disables the file descriptor in any forked copies in other processes.</source>
          <target state="translated">当你想告诉对方你已经写完了,但还没有读完,或者反之亦然时,这对套接字很有用。这也是close的一种更坚持的形式,因为它也会在其他进程的任何分叉副本中禁用文件描述符。</target>
        </trans-unit>
        <trans-unit id="f513c390b6f7958ee20cf98d8560715b5f8df7bb" translate="yes" xml:space="preserve">
          <source>This is variable gets set in various places to tell i_fcntl that &amp;lt;fcntl.h&amp;gt; should be included.</source>
          <target state="translated">在各个位置设置此变量以告诉i_fcntl应该包含&amp;lt;fcntl.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="a219720ed763ff153bf9c4206e6fc4962fcc28fa" translate="yes" xml:space="preserve">
          <source>This is variable gets set in various places to tell i_sys_file that &amp;lt;sys/file.h&amp;gt; should be included.</source>
          <target state="translated">在各个位置设置此变量，以告诉i_sys_file应该包含&amp;lt;sys / file.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="c6c48e550cd9137be036063a2bb992fbdc655583" translate="yes" xml:space="preserve">
          <source>This is very dangerous, as you may block forever. It assumes it's going to talk to something like &lt;b&gt;bc&lt;/b&gt;, both writing to it and reading from it. This is presumably safe because you &quot;know&quot; that commands like &lt;b&gt;bc&lt;/b&gt; will read a line at a time and output a line at a time. Programs like &lt;b&gt;sort&lt;/b&gt; that read their entire input stream first, however, are quite apt to cause deadlock.</source>
          <target state="translated">这非常危险，因为您可能会永远受阻。它假定它将与&lt;b&gt;bc&lt;/b&gt;之类的对象进行对话，同时对其进行写入和读取。这大概是安全的，因为您&amp;ldquo;知道&amp;rdquo;诸如&lt;b&gt;bc之类的&lt;/b&gt;命令将一次读取一行并一次输出一行。但是，诸如&lt;b&gt;sort之类的&lt;/b&gt;程序会首先读取其整个输入流，因此很容易引起死锁。</target>
        </trans-unit>
        <trans-unit id="4d27e7008a46081de6bf70cf35ea9983d5762e5e" translate="yes" xml:space="preserve">
          <source>This is very similar to &quot;How do I process an entire hash?&quot;, also in &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;, but a bit simpler in the common cases.</source>
          <target state="translated">这与&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4中的&lt;/a&gt; &amp;ldquo;如何处理整个散列？&amp;rdquo;非常相似，但在常见情况下要简单一些。</target>
        </trans-unit>
        <trans-unit id="e597cd56d56a437656a2f431e5a405bb225ea80c" translate="yes" xml:space="preserve">
          <source>This is very useful if you insist on taking an array reference as argument for example.</source>
          <target state="translated">例如,如果你坚持使用数组引用作为参数,这就非常有用。</target>
        </trans-unit>
        <trans-unit id="9ecc6a74af1d686f96a51556930a084f0975a2d7" translate="yes" xml:space="preserve">
          <source>This is what APPNOTE.TXT has to say on what should be stored in the zip filename header field.</source>
          <target state="translated">这是APPNOTE.TXT关于应该在zip文件名头栏中存储的内容。</target>
        </trans-unit>
        <trans-unit id="ccdaae868b02e396a128e9209508dfb651981fc3" translate="yes" xml:space="preserve">
          <source>This is what system() (see &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;), &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;), and</source>
          <target state="translated">这就是system（）（请参阅&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;）， &lt;code&gt;``&lt;/code&gt; （请参阅&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop中的I / O运算符&lt;/a&gt;）和</target>
        </trans-unit>
        <trans-unit id="57e5ac17ec3c4ac0ba4b990c6d906bee2bbc734b" translate="yes" xml:space="preserve">
          <source>This is what you really need to know as an XS programmer, of course. When an XSUB returns a pointer to a C structure that pointer is stored in an SV and a reference to that SV is placed on the XSUB stack. So the output from an XSUB which uses something like the T_PTROBJ map might look something like this:</source>
          <target state="translated">当然,这才是作为一个XS程序员真正需要知道的。当XSUB返回一个指向C结构的指针时,这个指针会被存储在SV中,并且SV的引用会被放置在XSUB堆栈中。因此,使用T_PTROBJ映射的XSUB的输出可能是这样的。</target>
        </trans-unit>
        <trans-unit id="4310f6ad3f6095c3049af8ec37cf9d1c7e8bca42" translate="yes" xml:space="preserve">
          <source>This is when the firewall implemented in the kernel (via NAT, or networking address translation), it allows you to hide a complete network behind one IP address. With this firewall no special compiling is needed as you can access hosts directly.</source>
          <target state="translated">这时在内核中实现的防火墙(通过NAT,或网络地址转换),它允许你将一个完整的网络隐藏在一个IP地址后面。有了这种防火墙,不需要特殊的编译,因为你可以直接访问主机。</target>
        </trans-unit>
        <trans-unit id="fb3eba7f97ab07f3173100c09ae1ea0eedcc95ab" translate="yes" xml:space="preserve">
          <source>This is when the firewall machine runs a web server, and to access the outside world, you must do so via that web server. If you set environment variables like http_proxy or ftp_proxy to values beginning with http://, or in your web browser you've proxy information set, then you know you are running behind an http firewall.</source>
          <target state="translated">这时防火墙的机器运行的是一个web服务器,要访问外界,必须通过这个web服务器。如果你将http_proxy或ftp_proxy等环境变量设置为以http://开头的值,或者在你的Web浏览器中设置了代理信息,那么你就知道你是在http防火墙后面运行。</target>
        </trans-unit>
        <trans-unit id="75c3d5cffa21770fa5fe6937e649710847afafb8" translate="yes" xml:space="preserve">
          <source>This is when you see something like:</source>
          <target state="translated">这时你看到的是这样的东西。</target>
        </trans-unit>
        <trans-unit id="2ad104027af291dcad88bf06901ecbc700b85cc1" translate="yes" xml:space="preserve">
          <source>This is where roles come in. It makes a lot of sense to create a &lt;code&gt;HasOnOffSwitch&lt;/code&gt; role and apply it to both classes. This role would define a known API like providing &lt;code&gt;turn_on()&lt;/code&gt; and &lt;code&gt;turn_off()&lt;/code&gt; methods.</source>
          <target state="translated">这是角色出现的地方。创建 &lt;code&gt;HasOnOffSwitch&lt;/code&gt; 角色并将其应用于两个类都非常有意义。该角色将定义一个已知的API，例如提供 &lt;code&gt;turn_on()&lt;/code&gt; 和 &lt;code&gt;turn_off()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="4320c9ea9a75ef79b1c739e5fcf494dc9cfb50f4" translate="yes" xml:space="preserve">
          <source>This is which protocol to use. In this case, the socket handle returned will be connected to a TCP socket, because we want a stream-oriented connection, that is, one that acts pretty much like a plain old file. Not all sockets are this of this type. For example, the UDP protocol can be used to make a datagram socket, used for message-passing.</source>
          <target state="translated">这就是要使用哪种协议。在这种情况下,返回的套接字句柄将连接到一个TCP套接字,因为我们想要的是一个面向流的连接,也就是说,这个套接字的行为很像一个普通的文件。并不是所有的套接字都是这种类型的。例如,UDP协议可以用来做一个数据报套接字,用于消息传递。</target>
        </trans-unit>
        <trans-unit id="30ceb66515d4a53e1d2f25ce989ec733d96ff6db" translate="yes" xml:space="preserve">
          <source>This is which protocol to use. Like our clients, we'll still specify &lt;code&gt;&quot;tcp&quot;&lt;/code&gt; here.</source>
          <target state="translated">这是要使用的协议。与客户一样，我们仍将在此处指定 &lt;code&gt;&quot;tcp&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04d23d996b25b2c2795e313433104ffdca7710c6" translate="yes" xml:space="preserve">
          <source>This is, I hope, a natural term given the implementation, and should avoid connotations that are inherent in earlier uses of &quot;discipline&quot; for things which are rather different.</source>
          <target state="translated">我希望这是一个自然而然的术语,考虑到执行情况,应该避免早先使用 &quot;纪律 &quot;来表示相当不同的事物所固有的内涵。</target>
        </trans-unit>
        <trans-unit id="921e3efa52591567d6779d551efd563ccc94a973" translate="yes" xml:space="preserve">
          <source>This isn't as simple a question as it sounds. There are two parts:</source>
          <target state="translated">这不是一个听起来简单的问题。有两个部分。</target>
        </trans-unit>
        <trans-unit id="033f6ccbcb480bbc0ac7d9079cba07009a6cd094" translate="yes" xml:space="preserve">
          <source>This item specifies the name by which the linker knows the extension, which may be different from the name of the extension itself (for instance, some linkers add an '_' to the name of the extension). If it is not specified, it is derived from the NAME attribute. It is presently used only by OS2 and Win32.</source>
          <target state="translated">这一项指定了链接者知道扩展的名称,它可能与扩展本身的名称不同(例如,有些链接者在扩展的名称中添加'_')。如果它没有被指定,则从NAME属性导出。目前它只被OS2和Win32使用。</target>
        </trans-unit>
        <trans-unit id="d17e4bc352cfe7c72913c884191bd7c2a2036595" translate="yes" xml:space="preserve">
          <source>This key allows for variable weighting of variable collation elements, which are marked with an ASTERISK in the table (NOTE: Many punctuation marks and symbols are variable in</source>
          <target state="translated">这个键可以对可变的整理元素进行可变的加权,这些元素在表格中用ASTERISK标记(注:许多标点符号和符号是可变的在</target>
        </trans-unit>
        <trans-unit id="cb089e180f4d1e1151abdbf8ed66a17ba5f2e56e" translate="yes" xml:space="preserve">
          <source>This key can be used to specify the name of the linker option file (minus the OS-specific extension), if for some reason you do not want to use the default value, which is the last word of the NAME attribute (</source>
          <target state="translated">这个键可以用来指定链接器选项文件的名称(减去操作系统特定的扩展名),如果出于某些原因你不想使用默认值,即NAME属性的最后一个字 (</target>
        </trans-unit>
        <trans-unit id="6dc6a49c5fb309cc8a7f7ab658d2498baeeb643a" translate="yes" xml:space="preserve">
          <source>This keyword allows one to define an INTERFACE using a different way to extract a function pointer from an XSUB. The text which follows this keyword should give the name of macros which would extract/set a function pointer. The extractor macro is given return type, &lt;code&gt;CV*&lt;/code&gt; , and &lt;code&gt;XSANY.any_dptr&lt;/code&gt; for this &lt;code&gt;CV*&lt;/code&gt; . The setter macro is given cv, and the function pointer.</source>
          <target state="translated">此关键字允许使用不同的方法从XSUB提取函数指针来定义接口。该关键字后面的文本应提供将提取/设置函数指针的宏的名称。提取器宏的返回类型为 &lt;code&gt;CV*&lt;/code&gt; ，并且为此 &lt;code&gt;CV*&lt;/code&gt; &lt;code&gt;XSANY.any_dptr&lt;/code&gt; 。给setter宏赋cv和功能指针。</target>
        </trans-unit>
        <trans-unit id="2eb4e29be94617115ad887f08c53a3d0726b0bcf" translate="yes" xml:space="preserve">
          <source>This keyword can be used to pull other files into the XS module. The other files may have XS code. INCLUDE: can also be used to run a command to generate the XS code to be pulled into the module.</source>
          <target state="translated">这个关键字可以用来将其他文件拉到XS模块中。其他文件可能有XS代码。INCLUDE:也可以用来运行一个命令来生成XS代码,并将其拉到模块中。</target>
        </trans-unit>
        <trans-unit id="7ed11759f14ddd60bb197c65bf243efdd708cc88" translate="yes" xml:space="preserve">
          <source>This keyword can be used when an XSUB requires special cleanup procedures before it terminates. When the CLEANUP: keyword is used it must follow any CODE:, or OUTPUT: blocks which are present in the XSUB. The code specified for the cleanup block will be added as the last statements in the XSUB.</source>
          <target state="translated">当XSUB在结束前需要特殊的清理程序时,可以使用这个关键字。当使用CLEANUP:关键字时,它必须跟随XSUB中存在的任何CODE:或OUTPUT:块。为清理块指定的代码将作为XSUB中的最后一条语句加入。</target>
        </trans-unit>
        <trans-unit id="7ea24ab5d7dbe276068f1e0046e6f8d0e31be74b" translate="yes" xml:space="preserve">
          <source>This keyword can be used when an XSUB requires special procedures executed after the C subroutine call is performed. When the POSTCALL: keyword is used it must precede OUTPUT: and CLEANUP: blocks which are present in the XSUB.</source>
          <target state="translated">当XSUB需要在执行C子程序调用后执行特殊程序时,可以使用这个关键字。当使用POSTCALL:关键字时,它必须在XSUB中存在的OUTPUT:和CLEANUP:块之前。</target>
        </trans-unit>
        <trans-unit id="ae2e5d68051ec8479ea84ba54d17bcf4606d62cb" translate="yes" xml:space="preserve">
          <source>This keyword declares the current XSUB as a keeper of the given calling signature. If some text follows this keyword, it is considered as a list of functions which have this signature, and should be attached to the current XSUB.</source>
          <target state="translated">这个关键字声明当前XSUB是给定调用签名的保存者。如果这个关键字后面有一些文本,它被认为是具有这个签名的函数的列表,并且应该附加到当前XSUB。</target>
        </trans-unit>
        <trans-unit id="58666c3be919a203268b54d032b3c1bf1338cbb5" translate="yes" xml:space="preserve">
          <source>This keyword is available only when the &lt;code&gt;&quot;fc&quot;&lt;/code&gt; feature is enabled, or when prefixed with &lt;code&gt;CORE::&lt;/code&gt; ; See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt;. Alternately, include a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">仅当启用 &lt;code&gt;&quot;fc&quot;&lt;/code&gt; 功能或带有 &lt;code&gt;CORE::&lt;/code&gt; 前缀时，此关键字才可用。请参阅&lt;a href=&quot;../feature&quot;&gt;功能&lt;/a&gt;。或者，将 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 或更高版本包含在当前范围内。</target>
        </trans-unit>
        <trans-unit id="42d2aecd2684fd64241ade61155e375dd422775d" translate="yes" xml:space="preserve">
          <source>This keyword is available only when the &lt;code&gt;&quot;fc&quot;&lt;/code&gt; feature is enabled, or when prefixed with &lt;code&gt;CORE::&lt;/code&gt; ; See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. Alternately, include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">仅当启用 &lt;code&gt;&quot;fc&quot;&lt;/code&gt; 功能或带有 &lt;code&gt;CORE::&lt;/code&gt; 前缀时，此关键字才可用。请参阅&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。或者，将 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 或更高版本包含在当前范围内。</target>
        </trans-unit>
        <trans-unit id="f176175c36b805a68ac4fb3277c81ce3879ff21b" translate="yes" xml:space="preserve">
          <source>This keyword is available only when the &lt;code&gt;&quot;say&quot;&lt;/code&gt; feature is enabled, or when prefixed with &lt;code&gt;CORE::&lt;/code&gt; ; see &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt;. Alternately, include a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">仅当启用 &lt;code&gt;&quot;say&quot;&lt;/code&gt; 功能或带有 &lt;code&gt;CORE::&lt;/code&gt; 前缀时，此关键字才可用。见&lt;a href=&quot;../feature&quot;&gt;功能&lt;/a&gt;。或者， &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; 或更高版本包含在当前范围内。</target>
        </trans-unit>
        <trans-unit id="7248453615df5e8da2ccdbead940326c86edd409" translate="yes" xml:space="preserve">
          <source>This keyword is available only when the &lt;code&gt;&quot;say&quot;&lt;/code&gt; feature is enabled, or when prefixed with &lt;code&gt;CORE::&lt;/code&gt; ; see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. Alternately, include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">仅当启用 &lt;code&gt;&quot;say&quot;&lt;/code&gt; 功能或带有 &lt;code&gt;CORE::&lt;/code&gt; 前缀时，此关键字才可用。见&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。或者， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; 或更高版本包含在当前范围内。</target>
        </trans-unit>
        <trans-unit id="4ef9d8d4891aa770100745063fafba75dd87bbdc" translate="yes" xml:space="preserve">
          <source>This keyword is documented in &lt;a href=&quot;../perlsub#Autoloading&quot;&gt;Autoloading in perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../perlsub#Autoloading&quot;&gt;在perlsub的自动加载中&lt;/a&gt;记录了此关键字。</target>
        </trans-unit>
        <trans-unit id="017edb25f20d66cd7958f76d9e8eba1497b2b334" translate="yes" xml:space="preserve">
          <source>This keyword is documented in &lt;a href=&quot;perlsub#Autoloading&quot;&gt;Autoloading in perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlsub#Autoloading&quot;&gt;在perlsub的自动加载中&lt;/a&gt;记录了此关键字。</target>
        </trans-unit>
        <trans-unit id="f7b17b66d48631c7667c9941d17b69ddf9ef0b49" translate="yes" xml:space="preserve">
          <source>This keyword is enabled by the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature; see &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; for more information on &lt;code&gt;&quot;switch&quot;&lt;/code&gt; . You can also access it by prefixing it with &lt;code&gt;CORE::&lt;/code&gt; . Alternatively, include a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">此关键字由 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 功能启用；有关 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 更多信息，请参见&lt;a href=&quot;../feature&quot;&gt;功能&lt;/a&gt;。您还可以通过在其前面加上 &lt;code&gt;CORE::&lt;/code&gt; 来访问它。可替代地，包括 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; V5.10或更高到当前范围。</target>
        </trans-unit>
        <trans-unit id="bcf1ac4839e0d0322a8d99444375f29015dd872d" translate="yes" xml:space="preserve">
          <source>This keyword is enabled by the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature; see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; for more information on &lt;code&gt;&quot;switch&quot;&lt;/code&gt; . You can also access it by prefixing it with &lt;code&gt;CORE::&lt;/code&gt; . Alternatively, include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">此关键字由 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 功能启用；有关 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 更多信息，请参见&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。您还可以通过在其前面加上 &lt;code&gt;CORE::&lt;/code&gt; 来访问它。可替代地，包括 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; V5.10或更高到当前范围。</target>
        </trans-unit>
        <trans-unit id="29762772c48cba2696e2ebbb42e9c2d4888e7318" translate="yes" xml:space="preserve">
          <source>This keyword is similar to the PROTOTYPES: keyword above but can be used to force &lt;b&gt;xsubpp&lt;/b&gt; to use a specific prototype for the XSUB. This keyword overrides all other prototype options and keywords but affects only the current XSUB. Consult &lt;a href=&quot;perlsub#Prototypes&quot;&gt;Prototypes in perlsub&lt;/a&gt; for information about Perl prototypes.</source>
          <target state="translated">此关键字与上面的PROTOTYPES：关键字相似，但可用于强制&lt;b&gt;xsubpp&lt;/b&gt;为XSUB使用特定的原型。该关键字将覆盖所有其他原型选项和关键字，但仅影响当前的XSUB。有关Perl原型的信息，请查阅&lt;a href=&quot;perlsub#Prototypes&quot;&gt;perlsub中的Prototypes&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85b8915eb7407eed5e4863e8fa3af3a2f3aafc0d" translate="yes" xml:space="preserve">
          <source>This keyword is used in more complicated XSUBs which require special handling for the C function. The RETVAL variable is still declared, but it will not be returned unless it is specified in the OUTPUT: section.</source>
          <target state="translated">这个关键字用在比较复杂的XSUB中,需要对C函数进行特殊处理。RETVAL变量仍然被声明,但除非在OUTPUT:部分指定,否则它不会被返回。</target>
        </trans-unit>
        <trans-unit id="aa7963343b84df8b23c604395808970c0e2420a5" translate="yes" xml:space="preserve">
          <source>This keyword makes sense only if &lt;code&gt;RETVAL&lt;/code&gt; is going to be accessed by the user-supplied code. It is especially useful to make a function interface more Perl-like, especially when the C return value is just an error condition indicator. For example,</source>
          <target state="translated">仅当用户提供的代码将访问 &lt;code&gt;RETVAL&lt;/code&gt; 时,此关键字才有意义。使函数接口更像Perl尤其有用，尤其是当C返回值只是错误条件指示符时。例如，</target>
        </trans-unit>
        <trans-unit id="b1b52e23340e03d5e2d9ec935c2b222b8a59f7e3" translate="yes" xml:space="preserve">
          <source>This keyword may be used any time after the first MODULE keyword and should appear on a line by itself. The first blank line after the keyword will terminate the code block.</source>
          <target state="translated">这个关键字可以在第一个MODULE关键字之后的任何时间使用,并且应该单独出现在一行。关键字后的第一个空行将终止该代码块。</target>
        </trans-unit>
        <trans-unit id="8c3c885b0fa12332744123cf10bb6f10b80fe29e" translate="yes" xml:space="preserve">
          <source>This keyword should follow the PACKAGE keyword when used. If PACKAGE is not used then PREFIX should follow the MODULE keyword.</source>
          <target state="translated">当使用PACKAGE关键字时,这个关键字应该跟在PACKAGE关键字后面。如果不使用PACKAGE,那么PREFIX应该跟在MODULE关键字后面。</target>
        </trans-unit>
        <trans-unit id="febcd526951ded918c85fd19d9088e687e73cc02" translate="yes" xml:space="preserve">
          <source>This keyword will normally be used to complement the CODE: keyword. The RETVAL variable is not recognized as an output variable when the CODE: keyword is present. The OUTPUT: keyword is used in this situation to tell the compiler that RETVAL really is an output variable.</source>
          <target state="translated">这个关键字通常用于补充CODE:关键字。当CODE:关键字出现时,RETVAL变量不被识别为输出变量。在这种情况下,OUTPUT:关键字用来告诉编译器RETVAL确实是一个输出变量。</target>
        </trans-unit>
        <trans-unit id="cb6c35b047be04a4c7f82192e6412bfe49f97ba3" translate="yes" xml:space="preserve">
          <source>This last example is purely for purposes of completeness. You should not be trying to mess with the attributes of something in a package that's not your own.</source>
          <target state="translated">最后一个例子纯粹是为了完整的目的。你不应该试图在一个不是你自己的包里搞乱某些东西的属性。</target>
        </trans-unit>
        <trans-unit id="862d993f36bd27f44699b4c5102357c5ca816339" translate="yes" xml:space="preserve">
          <source>This last example shows the use of this construct to specify an ordinary bracketed character class without additional set operations. Note the white space within it; &lt;code&gt;/x&lt;/code&gt; is turned on even within bracketed character classes, except you can't have comments inside them. Hence,</source>
          <target state="translated">最后一个示例显示了如何使用此结构指定普通的带括号的字符类，而无需进行额外的设置操作。注意其中的空白； &lt;code&gt;/x&lt;/code&gt; 甚至在带括号的字符类中都已打开，除非您不能在其中添加注释。因此，</target>
        </trans-unit>
        <trans-unit id="9220dfc1805deb030c183292c9d16a65be2d81b4" translate="yes" xml:space="preserve">
          <source>This last example splits &lt;code&gt;$foo&lt;/code&gt; into the first two words and the remainder of the line, and assigns those three fields to &lt;code&gt;$F1&lt;/code&gt; , &lt;code&gt;$F2&lt;/code&gt; , and &lt;code&gt;$Etc&lt;/code&gt; . The conditional is true if any variables were assigned; that is, if the pattern matched.</source>
          <target state="translated">最后一个例子拆分 &lt;code&gt;$foo&lt;/code&gt; 到前两个单词和行的剩余部分，并且这三个领域分配给 &lt;code&gt;$F1&lt;/code&gt; ， &lt;code&gt;$F2&lt;/code&gt; ，和 &lt;code&gt;$Etc&lt;/code&gt; 。如果分配了任何变量，则条件为true；否则为false。也就是说，如果模式匹配。</target>
        </trans-unit>
        <trans-unit id="b0e7606501a4d8dcdc827582f8772dc7d2f7c727" translate="yes" xml:space="preserve">
          <source>This last one is present only in perl 5.22.0 and higher.</source>
          <target state="translated">最后一个只在perl 5.22.0和更高版本中出现。</target>
        </trans-unit>
        <trans-unit id="71d99570ae143a5a3edf0f9d507ad7328c03cf89" translate="yes" xml:space="preserve">
          <source>This latter is improper because when the &quot;=end outer&quot; command is seen, the currently open region has the formatname &quot;inner&quot;, not &quot;outer&quot;. (It just happens that &quot;outer&quot; is the format name of a higher-up region.) This is an error. Processors must by default report this as an error, and may halt processing the document containing that error. A corollary of this is that regions cannot &quot;overlap&quot;. That is, the latter block above does not represent a region called &quot;outer&quot; which contains X and Y, overlapping a region called &quot;inner&quot; which contains Y and Z. But because it is invalid (as all apparently overlapping regions would be), it doesn't represent that, or anything at all.</source>
          <target state="translated">后者是不恰当的,因为当看到&quot;=end outer &quot;命令时,当前打开的区域的格式名是 &quot;inner&quot;,而不是&quot; outer&quot;。(只是碰巧 &quot;external &quot;是上级区域的格式名。)这是一个错误。处理器默认必须将此报告为错误,并可能停止处理包含该错误的文档。这一点的必然结果是,区域不能 &quot;重叠&quot;。也就是说,上面的后一个块并不代表一个包含X和Y的名为 &quot;外 &quot;的区域,与一个包含Y和Z的名为 &quot;内 &quot;的区域重叠,但因为它是无效的(因为所有明显重叠的区域都会无效),所以它并不代表这个区域,或者根本不代表任何东西。</target>
        </trans-unit>
        <trans-unit id="7a8db66183eb60025ea9a2964bbf14f04f11348c" translate="yes" xml:space="preserve">
          <source>This layer provides a PerlIO interface by wrapping system's ANSI C &quot;stdio&quot; library calls. The layer provides both buffering and IO. Note that the &lt;code&gt;:stdio&lt;/code&gt; layer does</source>
          <target state="translated">该层通过包装系统的ANSI C&amp;ldquo; stdio&amp;rdquo;库调用来提供PerlIO接口。该层同时提供缓冲和IO。请注意 &lt;code&gt;:stdio&lt;/code&gt; 层确实</target>
        </trans-unit>
        <trans-unit id="b630c4528c6aff17852e4e3ca55c2d5a2c70831c" translate="yes" xml:space="preserve">
          <source>This leads to the other two differences. Since a single code point is returned, the function can't handle named character sequences, as these are composed of multiple characters (it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for these. And, the code point can be that of any character, even ones that aren't legal under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma,</source>
          <target state="translated">这导致其他两个差异。由于返回了单个代码点，因此该函数无法处理命名的字符序列，因为它们由多个字符组成（对于这些字符，它返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。而且，该代码点可以是任何字符的字符，即使不是合法 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 下的编译指示，</target>
        </trans-unit>
        <trans-unit id="d60f65e26f1f4e74963a10d1932144990bf5f1a5" translate="yes" xml:space="preserve">
          <source>This lets you override an existing type with your own custom type, or register a completely new type, eg:</source>
          <target state="translated">这让你可以用你自己的自定义类型覆盖现有的类型,或者注册一个全新的类型,例如。</target>
        </trans-unit>
        <trans-unit id="3afaf78f703df78ea1b2a3a94074c1f6af7d070b" translate="yes" xml:space="preserve">
          <source>This level of sophistication puts filtering out of the reach of many programmers.</source>
          <target state="translated">这种复杂程度让很多程序员无法实现过滤。</target>
        </trans-unit>
        <trans-unit id="96b38d379d8ea7799ed19600bd96b2cf3c932e45" translate="yes" xml:space="preserve">
          <source>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</source>
          <target state="translated">这个库的发布是希望它是有用的,但没有任何保证,甚至没有默示的适销性或适合特定用途的保证。更多细节请参见GNU通用公共许可证。</target>
        </trans-unit>
        <trans-unit id="5235941a62b852074a7c3e9fc51537a52e5be7a3" translate="yes" xml:space="preserve">
          <source>This library is free software. You can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">这个库是免费软件。你可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="f877037944f8c1888cbf64249275515c89dec317" translate="yes" xml:space="preserve">
          <source>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.8.7 or, at your option, any later version of Perl 5 you may have available.</source>
          <target state="translated">这个库是自由软件;您可以在与Perl本身相同的条款下重新发布它和/或修改它,可以是Perl 5.8.7版本,也可以是您可以选择的Perl 5的任何更新版本。</target>
        </trans-unit>
        <trans-unit id="59869bc853c079c70b9f3b6879026f6cde3bb8df" translate="yes" xml:space="preserve">
          <source>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">这个库是自由软件;你可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="95bf2cec5fb49eb84ad57753eb4accbc37f2ba0f" translate="yes" xml:space="preserve">
          <source>This library is free software; you may redistribute and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">这个库是自由软件;你可以在与Perl本身相同的条款下重新发布和/或修改它。</target>
        </trans-unit>
        <trans-unit id="5912c0244d5e6338722acbdad50efbccb8883b11" translate="yes" xml:space="preserve">
          <source>This library is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">这个库是自由软件;你可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="4f410cd597bbeaeb5f199c6d8d09628b5554744f" translate="yes" xml:space="preserve">
          <source>This library is useful for the &lt;code&gt;find2perl&lt;/code&gt; tool, which when fed,</source>
          <target state="translated">该库对于 &lt;code&gt;find2perl&lt;/code&gt; 工具非常有用，该工具在喂入后，</target>
        </trans-unit>
        <trans-unit id="c0bf3b785ab345744e2dfb1b0071fc64c2b599fe" translate="yes" xml:space="preserve">
          <source>This library provides functions for common tasks involving language tags as they are needed in a variety of protocols and applications.</source>
          <target state="translated">该库为涉及语言标签的常见任务提供了功能,因为它们在各种协议和应用中都需要。</target>
        </trans-unit>
        <trans-unit id="0c8a7928010093d74c8591010b017561f0beda8e" translate="yes" xml:space="preserve">
          <source>This library provides support for big integer calculations. It is not intended to be used by other modules. Other modules which support the same API (see below) can also be used to support Math::BigInt, like Math::BigInt::GMP and Math::BigInt::Pari.</source>
          <target state="translated">这个库提供对大整数计算的支持。它不打算被其他模块使用。其他支持相同 API 的模块(见下文)也可用于支持 Math::BigInt,如 Math::BigInt::GMP 和 Math::BigInt::Pari。</target>
        </trans-unit>
        <trans-unit id="a3eb497d536b5c644bfd0b5d3e8c9055b4a9a57d" translate="yes" xml:space="preserve">
          <source>This limitation arises from fundamental technical difficulties in cloning and restarting the stacks used by the Perl parser in the middle of a parse.</source>
          <target state="translated">这种限制来自于在解析过程中克隆和重启Perl解析器使用的堆栈的基本技术困难。</target>
        </trans-unit>
        <trans-unit id="5fe79b21d14490122d11b41cbba492989dbd2358" translate="yes" xml:space="preserve">
          <source>This limitation might be removed in a future version of perl.</source>
          <target state="translated">这个限制可能会在未来的perl版本中被删除。</target>
        </trans-unit>
        <trans-unit id="68a6939633ab7f637a699e2abcb07f19152f1003" translate="yes" xml:space="preserve">
          <source>This line is taken from &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Soundex&quot;&gt;Text::Soundex&lt;/a&gt; 3.04, and marks it as deprecated beyond Perl 5.16. If you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Text::Soundex&lt;/code&gt; in Perl 5.18, for example, and you have used &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;, then you'll get a warning message (the deprecate module looks to see whether the calling module was &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;'d from a core library directory, and if so, generates a warning), unless you've installed a more recent version of &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Soundex&quot;&gt;Text::Soundex&lt;/a&gt; from CPAN.</source>
          <target state="translated">该行摘自&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Soundex&quot;&gt;Text :: Soundex&lt;/a&gt; 3.04，并将其标记为在Perl 5.16之后不推荐使用。例如，如果您在Perl 5.18中 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Text::Soundex&lt;/code&gt; ，并且已使用&lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;，则将收到警告消息（不赞成使用的模块将查看调用模块是否从核心库目录中 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 'd，并且如果是这样，则会生成警告），除非您从CPAN 安装了更新版本的&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Soundex&quot;&gt;Text :: Soundex&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d4d9656ee66f6221eea8c2856144cdf8d5022fd" translate="yes" xml:space="preserve">
          <source>This list includes architecture-dependent directories back to version $api_versionstring (e.g. 5.5.640) and architecture-independent directories all the way back to 5.005.</source>
          <target state="translated">这个列表包括了从$api_versionstring版本(如5.5.640)开始的依赖于架构的目录和从5.005开始的不依赖于架构的目录。</target>
        </trans-unit>
        <trans-unit id="2a2fc6936d401079e1014279fe24282359b2ced4" translate="yes" xml:space="preserve">
          <source>This list is in alphabetical order by English name of the language.</source>
          <target state="translated">该列表按语言的英文名称的字母顺序排列。</target>
        </trans-unit>
        <trans-unit id="fbc78c3347e34ef8b4193dfb718a45521c4ab8d4" translate="yes" xml:space="preserve">
          <source>This list of categories is used to produce the same order as the &lt;a href=&quot;../perlfunc#Perl-Functions-by-Category&quot;&gt;Perl Functions by Category in perlfunc&lt;/a&gt; section.</source>
          <target state="translated">此类别列表用于产生与&lt;a href=&quot;../perlfunc#Perl-Functions-by-Category&quot;&gt;perlfunc&lt;/a&gt;部分中按类别列出的Perl函数的顺序。</target>
        </trans-unit>
        <trans-unit id="b0d8392d22aa3f9f1cc5418d2f71d3d9b55240c2" translate="yes" xml:space="preserve">
          <source>This list used to contain :base_io prior to Opcode 1.07.</source>
          <target state="translated">在Opcode 1.07之前,这个列表包含:base_io。</target>
        </trans-unit>
        <trans-unit id="f6d74c66919ae745b2d3650dc11a98193dcd5f79" translate="yes" xml:space="preserve">
          <source>This load time hit can be a problem when startup speed is important, such as with a command-line script or a &quot;plain vanilla&quot; CGI script that must be loaded each time it is executed.</source>
          <target state="translated">当启动速度很重要的时候,比如命令行脚本或每次执行时都必须加载的 &quot;普通的vanilla &quot;CGI脚本,这种加载时间的影响可能是一个问题。</target>
        </trans-unit>
        <trans-unit id="f016e1379d18764668778064a6a84ece9741d1da" translate="yes" xml:space="preserve">
          <source>This logical name must be defined before Perl is started.</source>
          <target state="translated">这个逻辑名称必须在Perl启动之前定义。</target>
        </trans-unit>
        <trans-unit id="2da9ead2fb770925df3e972a0efa2a82cbbd6ec6" translate="yes" xml:space="preserve">
          <source>This looks in the %Lexicon of the language handle $lh and all its superclasses, looking for an entry whose key is the string</source>
          <target state="translated">这将在语言句柄$lh和所有超级类的%Lexicon中寻找一个键为字符串的条目。</target>
        </trans-unit>
        <trans-unit id="6b4001bd2a1ae040dc8e95119817ede264954c05" translate="yes" xml:space="preserve">
          <source>This loses precision, to avoid this use &lt;a href=&quot;#as_int()%2fas_number()&quot;&gt;as_int()&lt;/a&gt; instead.</source>
          <target state="translated">为了避免这种情况，请避免使用&lt;a href=&quot;#as_int()%2fas_number()&quot;&gt;as_int（）&lt;/a&gt;来降低精度。</target>
        </trans-unit>
        <trans-unit id="2cb2a7c80cbcd1bcc850e8fe88a609a4116cf1c4" translate="yes" xml:space="preserve">
          <source>This machine-native collation (which is what you get unless &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
locale&lt;/code&gt; has appeared earlier in the same block) must be used for sorting raw binary data, whereas the locale-dependent collation of the first example is useful for natural text.</source>
          <target state="translated">必须使用这种机器本地排序规则（除非 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 在同一块中更早出现，否则您将获得此结果），用于对原始二进制数据进行排序，而第一个示例的与语言环境有关的排序规则对于自然文本很有用。</target>
        </trans-unit>
        <trans-unit id="fe9b1418e4cf2456d34c78acbb912d03460323b0" translate="yes" xml:space="preserve">
          <source>This macro automatically adjusts the stack for you, if needed. Thus, you do not need to call &lt;code&gt;EXTEND&lt;/code&gt; to extend the stack.</source>
          <target state="translated">如果需要，此宏会自动为您调整堆栈。因此，您无需调用 &lt;code&gt;EXTEND&lt;/code&gt; 即可扩展堆栈。</target>
        </trans-unit>
        <trans-unit id="28984ae179e05c5bf9916303fc08d37c02058ac5" translate="yes" xml:space="preserve">
          <source>This macro is only used by sv_true() or its macro equivalent, and only if the latter's argument is neither SvPOK, SvIOK nor SvNOK. It calls sv_2bool_flags with the SV_GMAGIC flag.</source>
          <target state="translated">这个宏只有sv_true()或其等价的宏才能使用,而且只有当后者的参数既不是SvPOK、SvIOK也不是SvNOK时才能使用。它调用带有SV_GMAGIC标志的sv_2bool_flags。</target>
        </trans-unit>
        <trans-unit id="e10545c4894740426ee72f48ac1e29d7b762c0e6" translate="yes" xml:space="preserve">
          <source>This macro is the start of wrapping the C or XS code; the wrap ending is done by calling the &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; macro after the operation. Otherwise the state can be changed that will adversely affect other XS code.</source>
          <target state="translated">这个宏是包装C或XS代码的开始。包装结束是通过在操作后调用&lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt;宏来完成的。否则，可以更改状态，这会对其他XS代码产生不利影响。</target>
        </trans-unit>
        <trans-unit id="108576184697c52b594b5fe191807eddc07365bd" translate="yes" xml:space="preserve">
          <source>This macro is used to define a unique key to refer to the static data for an XS module. The suggested naming scheme, as used by h2xs, is to use a string that consists of the module name, the string &quot;::_guts&quot; and the module version number.</source>
          <target state="translated">这个宏用来定义一个唯一的键,用来引用XS模块的静态数据。建议使用h2xs使用的命名方式,即使用一个由模块名、字符串&quot;::_guts &quot;和模块版本号组成的字符串。</target>
        </trans-unit>
        <trans-unit id="c6d4c1493bd7a58de9fad441658972687cd16b89" translate="yes" xml:space="preserve">
          <source>This macro makes sure the current &lt;code&gt;LC_NUMERIC&lt;/code&gt; state is set properly, to be aware of locale if the call to the XS or C code from the Perl program is from within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ; or to ignore locale if the call is instead from outside such scope.</source>
          <target state="translated">如果从Perl程序对XS或C代码的调用是在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; locale的范围内，则此宏可确保正确设置当前的 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 状态，以了解语言环境。或忽略区域设置（如果调用来自该范围之外）。</target>
        </trans-unit>
        <trans-unit id="a92648c32efc9502af17e5ceb0078f95c4ee774c" translate="yes" xml:space="preserve">
          <source>This macro should be used as a statement. It declares a private variable (whose name begins with an underscore) that is needed by the other macros in this section. Failing to include this correctly should lead to a syntax error. For compatibility with C89 C compilers it should be placed in a block before any executable statements.</source>
          <target state="translated">这个宏应该作为一个语句使用。它声明了一个私有变量(其名称以下划线开头),本节中的其他宏需要这个变量。如果不能正确地包含这个宏,应该导致语法错误。为了与C89 C编译器兼容,它应该放在任何可执行语句之前的块中。</target>
        </trans-unit>
        <trans-unit id="b90726f024761758381d53bc05e127149501c3cd" translate="yes" xml:space="preserve">
          <source>This makes &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; return the native VMS exit status instead of emulating the POSIX exit status.</source>
          <target state="translated">这使 &lt;code&gt;$?&lt;/code&gt; 并且 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 返回本地VMS退出状态，而不是模拟POSIX退出状态。</target>
        </trans-unit>
        <trans-unit id="8a2c6d4ff2fd838d04decac262a17dd105743f47" translate="yes" xml:space="preserve">
          <source>This makes &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; produce a successful exit (with status SS$_NORMAL), instead of emulating UNIX exit(), which considers &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; to indicate an error. As with the CRTL's exit() function, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; is also mapped to an exit status of SS$_NORMAL, and any other argument to exit() is used directly as Perl's exit status.</source>
          <target state="translated">这使 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; 产生一个成功的出口（状态为SS $ _NORMAL），而不是模拟UNIX exit（），后者将 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; 视为错误。与CRTL的exit（）函数一样， &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; 也映射到SS $ _NORMAL的出口状态，而exit（）的任何其他参数直接用作Perl的出口状态。</target>
        </trans-unit>
        <trans-unit id="7bf5212d7d68fd2597a5ccb3dac44a0ec0acbc33" translate="yes" xml:space="preserve">
          <source>This makes all times relative to the local time zone, instead of the default of Universal Time (a.k.a Greenwich Mean Time, or GMT).</source>
          <target state="translated">这使得所有的时间都是相对于当地时区的,而不是默认的世界时间(也就是格林威治标准时间,或GMT)。</target>
        </trans-unit>
        <trans-unit id="9babc5bd4d4d8fad4e1a1114788e7c9d9589298f" translate="yes" xml:space="preserve">
          <source>This makes it easy for people to use your module with Perl. Note that this licensing example is neither an endorsement or a requirement, you are of course free to choose any licensing.</source>
          <target state="translated">这使得人们很容易用Perl来使用你的模块。请注意,这个授权例子既不是认可也不是要求,当然你可以自由选择任何授权方式。</target>
        </trans-unit>
        <trans-unit id="f6b677bb7d54149dada8aa52108296cc95f7e885" translate="yes" xml:space="preserve">
          <source>This makes it easy to turn memoizing on and off.</source>
          <target state="translated">这样就可以很方便地开启和关闭备忘录。</target>
        </trans-unit>
        <trans-unit id="84c2faa4aab99c70a3db865e9bc75342b3b56a52" translate="yes" xml:space="preserve">
          <source>This makes it easy to write loops that terminate when a null list is returned:</source>
          <target state="translated">这使得编写循环很容易在返回空列表时终止。</target>
        </trans-unit>
        <trans-unit id="ef9cd0d8fba7947707aa196a6028ecbb8adf2cd7" translate="yes" xml:space="preserve">
          <source>This makes it possible for you to have a single point of configuring what subclasses should be used, which means that in many cases you'll find you only need to sub-class one of the parser's components.</source>
          <target state="translated">这使得你可以在一个点上配置应该使用哪些子类,这意味着在很多情况下,你会发现你只需要对解析器的一个组件进行子类化。</target>
        </trans-unit>
        <trans-unit id="80334a3bb6611cb20a20615249beb172fdbc5b91" translate="yes" xml:space="preserve">
          <source>This makes it possible to mix arguments of different classes (as in 2.5 + 2) as well es preserve accuracy (as in sqrt(3)).</source>
          <target state="translated">这使得它可以混合不同类的参数(如2.5+2)以及保持精度(如sqrt(3))。</target>
        </trans-unit>
        <trans-unit id="304f656ae607b7cf896345e4cfc56ab064cd5820" translate="yes" xml:space="preserve">
          <source>This makes it possible to write a constructor like this:</source>
          <target state="translated">这样就可以写一个这样的构造函数。</target>
        </trans-unit>
        <trans-unit id="08c53718a75ad3b112dec7a9bbaa9b39968746d5" translate="yes" xml:space="preserve">
          <source>This makes sure that &lt;code&gt;foo bar&lt;/code&gt; is treated as a string, rather than two separate arguments to the &lt;code&gt;echo&lt;/code&gt; function.</source>
          <target state="translated">这确保将 &lt;code&gt;foo bar&lt;/code&gt; 视为字符串，而不是 &lt;code&gt;echo&lt;/code&gt; 函数的两个独立参数。</target>
        </trans-unit>
        <trans-unit id="d11f54f9813ffdcb8a603cf0a760fa85bee8c0f3" translate="yes" xml:space="preserve">
          <source>This makes the four standard bitwise operators (&lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; ) treat their operands consistently as numbers, and introduces four new dotted operators (&lt;code&gt;&amp;amp;. |. ^. ~.&lt;/code&gt; ) that treat their operands consistently as strings. The same applies to the assignment variants (&lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt; ).</source>
          <target state="translated">这使四个标准按位运算符（ &lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; ）始终将其操作数视为数字，并引入了四个新的点分运算符（ &lt;code&gt;&amp;amp;. |. ^. ~.&lt;/code&gt; ）将其操作数视为字符串。分配变量也是如此（ &lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="168408e4eda2afd55c396c633b53aaec0eb729d4" translate="yes" xml:space="preserve">
          <source>This makes this XSUB look similar to an ANSI C declaration. An optional semicolon is allowed after the argument list, as in</source>
          <target state="translated">这使得这个XSUB看起来类似于ANSI C声明。在参数列表后允许使用分号,如在</target>
        </trans-unit>
        <trans-unit id="2eced7035bcf730659e224115fc20b5232c60142" translate="yes" xml:space="preserve">
          <source>This man page is for the version for modern perls and so that's probably what you've got.</source>
          <target state="translated">这个手册页是针对现代perls的版本,所以这可能是你的问题。</target>
        </trans-unit>
        <trans-unit id="b1f55a347ef2e9626ef51c086b431d8a172c3d1b" translate="yes" xml:space="preserve">
          <source>This manpage contains short recipes demonstrating how to handle common Unicode operations in Perl, plus one complete program at the end. Any undeclared variables in individual recipes are assumed to have a previous appropriate value in them.</source>
          <target state="translated">本手册包含了简短的配方,演示了如何在Perl中处理常见的Unicode操作,最后还有一个完整的程序。任何未声明的变量都会被假定为有一个合适的前值。</target>
        </trans-unit>
        <trans-unit id="aa682f1e123b444504fdfffff8f8767942781c1e" translate="yes" xml:space="preserve">
          <source>This manual page discusses the syntax and use of character classes in Perl regular expressions.</source>
          <target state="translated">本手册页面讨论了Perl正则表达式中字符类的语法和使用。</target>
        </trans-unit>
        <trans-unit id="3369a77e4e9693acaaa9351801ed7f0c5ee8faea" translate="yes" xml:space="preserve">
          <source>This maps from US-ASCII codes (like 32) to the corresponding character (like space, for 32). Only characters 32 to 126 are defined. This is meant for use by &lt;code&gt;e2char($x)&lt;/code&gt; when it senses that it's running on a non-ASCII platform (where chr(32) doesn't get you a space -- but $Code2USASCII{32} will). It's documented here just in case you might find it useful.</source>
          <target state="translated">这从US-ASCII代码（如32）映射到相应的字符（如32的空格）。仅定义了字符32至126。这意味着通过使用 &lt;code&gt;e2char($x)&lt;/code&gt; ，当它感知到它在非ASCII平台上运行（其中CHR（32）不给你一个空间-但$ {Code2USASCII 32}会）。如果您可能会觉得有用，请在此处进行记录。</target>
        </trans-unit>
        <trans-unit id="cb4d3919cb732684c195097b0bb170a903bf1284" translate="yes" xml:space="preserve">
          <source>This marks the end of the region opened by the matching &quot;=begin formatname&quot; region. If &quot;formatname&quot; is not the formatname of the most recent open &quot;=begin formatname&quot; region, then this is an error, and must generate an error message. This is discussed in detail in the section &lt;a href=&quot;#About-Data-Paragraphs-and-%22%3dbegin%2f%3dend%22-Regions&quot;&gt;About Data Paragraphs and =begin/=end Regions&lt;/a&gt;.</source>
          <target state="translated">这标志着由匹配的&amp;ldquo; = begin formatname&amp;rdquo;区域打开的区域的结尾。如果&amp;ldquo; formatname&amp;rdquo;不是最近打开的&amp;ldquo; = begin formatname&amp;rdquo;区域的格式名，则这是错误，并且必须生成错误消息。&lt;a href=&quot;#About-Data-Paragraphs-and-%22%3dbegin%2f%3dend%22-Regions&quot;&gt;关于数据段落和= begin / = end区域&lt;/a&gt;中将对此进行详细讨论。</target>
        </trans-unit>
        <trans-unit id="5f3eb630ccbc8c1b4b4ea62b60c2f17bbd2e13b1" translate="yes" xml:space="preserve">
          <source>This marks the following paragraphs (until the matching &quot;=end formatname&quot;) as being for some special kind of processing. Unless &quot;formatname&quot; begins with a colon, the contained non-command paragraphs are data paragraphs. But if &quot;formatname&quot;</source>
          <target state="translated">这标志着下面的段落(直到匹配的&quot;=end formatname&quot;)是为了进行某种特殊的处理。除非 &quot;formatname &quot;以冒号开头,否则包含的非命令段落都是数据段落。但如果 &quot;formatname&quot;</target>
        </trans-unit>
        <trans-unit id="199ca4d2282805128a713cd4c31b353ecaf62285" translate="yes" xml:space="preserve">
          <source>This matches a Unicode</source>
          <target state="translated">这与Unicode的</target>
        </trans-unit>
        <trans-unit id="7a2285705bf65a5f3a4137269fb669e26419a225" translate="yes" xml:space="preserve">
          <source>This matches a Unicode &quot;Grapheme Cluster Boundary&quot;. (Actually Perl always uses the improved &quot;extended&quot; grapheme cluster&quot;). These are explained below under &lt;a href=&quot;#%5cX&quot;&gt;\X&lt;/a&gt;. In fact, &lt;code&gt;\X&lt;/code&gt; is another way to get the same functionality. It is equivalent to &lt;code&gt;/.+?\b{gcb}/&lt;/code&gt; . Use whichever is most convenient for your situation.</source>
          <target state="translated">这与Unicode&amp;ldquo;字形簇边界&amp;rdquo;匹配。（实际上，Perl始终使用改进的&amp;ldquo;扩展&amp;rdquo;字素簇&amp;rdquo;。下面在&lt;a href=&quot;#%5cX&quot;&gt;\ X&lt;/a&gt;下进行了说明。实际上， &lt;code&gt;\X&lt;/code&gt; 是获得相同功能的另一种方式。它等效于 &lt;code&gt;/.+?\b{gcb}/&lt;/code&gt; 。根据您的情况选择最方便的一种。</target>
        </trans-unit>
        <trans-unit id="43a174e3acf9fe3da094fe1e29ca009a0ac07471" translate="yes" xml:space="preserve">
          <source>This matches a Unicode &quot;Sentence Boundary&quot;. This is an aid to parsing natural language sentences. It gives good, but imperfect results. For example, it thinks that &quot;Mr. Smith&quot; is two sentences. More details are at &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/&lt;/a&gt;. Note also that it thinks that anything matching &lt;a href=&quot;#%5cR&quot;&gt;\R&lt;/a&gt; (except form feed and vertical tab) is a sentence boundary. &lt;code&gt;\b{sb}&lt;/code&gt; works with text designed for word-processors which wrap lines automatically for display, but hard-coded line boundaries are considered to be essentially the ends of text blocks (paragraphs really), and hence the ends of sententces. &lt;code&gt;\b{sb}&lt;/code&gt; doesn't do well with text containing embedded newlines, like the source text of the document you are reading. Such text needs to be preprocessed to get rid of the line separators before looking for sentence boundaries. Some people view this as a bug in the Unicode standard, and this behavior is quite subject to change in future Perl versions.</source>
          <target state="translated">这与Unicode&amp;ldquo;句子边界&amp;rdquo;匹配。这有助于解析自然语言句子。它给出了良好但不完美的结果。例如，它认为&amp;ldquo;史密斯先生&amp;rdquo;是两个句子。有关更多详细信息，&lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;请访问http://www.unicode.org/reports/tr29/&lt;/a&gt;。还要注意，它认为与&lt;a href=&quot;#%5cR&quot;&gt;\ R&lt;/a&gt;匹配的任何内容（换页符和垂直制表符除外）都是句子边界。 &lt;code&gt;\b{sb}&lt;/code&gt; 与为文字处理器设计的文本一起使用，这些文字处理器自动换行以显示，但是硬编码的行边界本质上被认为是文本块的末端（实际上是段落），因此也是句子的末端。 &lt;code&gt;\b{sb}&lt;/code&gt; 包含嵌入式换行符的文本效果不佳，例如您正在阅读的文档的源文本。在查找句子边界之前，需要对此类文本进行预处理以消除行分隔符。有人将其视为Unicode标准中的错误，并且此行为在将来的Perl版本中会受到很大的影响。</target>
        </trans-unit>
        <trans-unit id="862d390cde50da1c3067a4f5bf13a23004164fc2" translate="yes" xml:space="preserve">
          <source>This matches a Unicode &quot;Word Boundary&quot;. This gives better (though not perfect) results for natural language processing than plain &lt;code&gt;\b&lt;/code&gt; (without braces) does. For example, it understands that apostrophes can be in the middle of words and that parentheses aren't (see the examples below). More details are at &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/&lt;/a&gt;.</source>
          <target state="translated">这与Unicode&amp;ldquo;单词边界&amp;rdquo;匹配。与纯 &lt;code&gt;\b&lt;/code&gt; （不带花括号）相比，这为自然语言处理提供了更好的（尽管不是完美的）结果。例如，它理解撇号可以在单词的中间，而括号不能在单词的中间（请参见下面的示例）。有关更多详细信息，&lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;请访问http://www.unicode.org/reports/tr29/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46f9c4b6a0133a2ba4a4536268bb4388e6462d37" translate="yes" xml:space="preserve">
          <source>This matches any &lt;code&gt;\p{Alphabetic}&lt;/code&gt; or &lt;code&gt;\p{Decimal_Number}&lt;/code&gt; character.</source>
          <target state="translated">这匹配任何 &lt;code&gt;\p{Alphabetic}&lt;/code&gt; 或 &lt;code&gt;\p{Decimal_Number}&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="1368a197a87ba6ed14500f8908565c9ada6f62ff" translate="yes" xml:space="preserve">
          <source>This matches any assigned code point; that is, any code point whose &lt;a href=&quot;#General_Category&quot;&gt;general category&lt;/a&gt; is not &lt;code&gt;Unassigned&lt;/code&gt; (or equivalently, not &lt;code&gt;Cn&lt;/code&gt; ).</source>
          <target state="translated">这匹配任何分配的代码点；也就是说，其&lt;a href=&quot;#General_Category&quot;&gt;常规类别&lt;/a&gt;不是 &lt;code&gt;Unassigned&lt;/code&gt; （或等效地，不是 &lt;code&gt;Cn&lt;/code&gt; ）的任何代码点。</target>
        </trans-unit>
        <trans-unit id="a2970fcf592bf526b7624da46ffe2c2926bcdb66" translate="yes" xml:space="preserve">
          <source>This matches any character that is graphical or blank, except controls.</source>
          <target state="translated">这与任何图形或空白的字符相匹配,但控件除外。</target>
        </trans-unit>
        <trans-unit id="9dcbf046b8bea0226e813051a826c67a230a6bfb" translate="yes" xml:space="preserve">
          <source>This matches any of the 128 characters in the US-ASCII character set, which is a subset of Unicode.</source>
          <target state="translated">这与US-ASCII字符集的128个字符中的任何一个相匹配,US-ASCII字符集是Unicode的一个子集。</target>
        </trans-unit>
        <trans-unit id="6f971eb914dae58555e5f55db125c34d663d6429" translate="yes" xml:space="preserve">
          <source>This matches any of the 1_114_112 Unicode code points. &lt;code&gt;\p{Any}&lt;/code&gt; .</source>
          <target state="translated">这匹配任何1_114_112 Unicode代码点。 &lt;code&gt;\p{Any}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50e5a95f3a6d3f1afad03782326f2e0e7b9c9ed7" translate="yes" xml:space="preserve">
          <source>This matches any of the 1_114_112 Unicode code points. It is a synonym for &lt;code&gt;\p{Unicode}&lt;/code&gt; .</source>
          <target state="translated">这匹配任何1_114_112 Unicode代码点。它是 &lt;code&gt;\p{Unicode}&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="1ddbc160eb4c94b6ef293222be013d55a26c3ebd" translate="yes" xml:space="preserve">
          <source>This matches digits that are in either the Thai or Laotian scripts.</source>
          <target state="translated">这与泰文或老挝文的数字相匹配。</target>
        </trans-unit>
        <trans-unit id="bed0a3d92b78eec58ff8b7c04af52fb9a269486e" translate="yes" xml:space="preserve">
          <source>This matches every possible code point. It is equivalent to &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/./s&lt;/a&gt;&lt;/code&gt;. Unlike all the other non-user-defined &lt;code&gt;\p{}&lt;/code&gt; property matches, no warning is ever generated if this is property is matched against a non-Unicode code point (see &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;Beyond Unicode code points&lt;/a&gt; below).</source>
          <target state="translated">这匹配每个可能的代码点。等效于 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/./s&lt;/a&gt;&lt;/code&gt; 。与所有其他非用户定义的 &lt;code&gt;\p{}&lt;/code&gt; 属性匹配不同，如果此属性与非Unicode代码点匹配，则不会生成任何警告（请参见下面的&lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;Unicode代码点之外&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e5af876b8e44759fbc1c5f4ebb39fe615bb29e7e" translate="yes" xml:space="preserve">
          <source>This matches the English vowels plus the SPACE character. All the other escapes accepted by normal bracketed character classes are accepted here as well; but unrecognized escapes that generate warnings in normal classes are fatal errors here.</source>
          <target state="translated">这与英语元音加上SPACE字符相匹配。所有其他正常括号内字符类所接受的转义符在这里也被接受;但是在正常类中产生警告的未识别的转义符在这里是致命的错误。</target>
        </trans-unit>
        <trans-unit id="6fe0bd3d52f9526a3bdbdf0fb7b2272dd4226b2a" translate="yes" xml:space="preserve">
          <source>This may a variant of just &lt;a href=&quot;#I-cannot-run-external-programs&quot;&gt;I cannot run external programs&lt;/a&gt;, or a deeper problem. Basically: you</source>
          <target state="translated">这可能只是&lt;a href=&quot;#I-cannot-run-external-programs&quot;&gt;我无法运行外部程序&lt;/a&gt;的变体，或者是更深层次的问题。基本上：你</target>
        </trans-unit>
        <trans-unit id="3c2e6cadd45bf9050033dd0f02dee64c1cb36e02" translate="yes" xml:space="preserve">
          <source>This may also be a good time to ensure that your /etc/protocol file and either your /etc/resolv.conf or /etc/hosts files are in place. The IBM document that described such USS system setup issues was SC28-1890-07 &quot;OS/390 UNIX System Services Planning&quot;, in particular Chapter 6 on customizing the OE shell.</source>
          <target state="translated">这也可能是确保你的/etc/protocol文件和/etc/resolv.conf或/etc/hosts文件到位的好时机。描述这种USS系统设置问题的IBM文档是SC28-1890-07 &quot;OS/390 UNIX系统服务规划&quot;,特别是第6章关于定制OE shell的内容。</target>
        </trans-unit>
        <trans-unit id="1206b674e03199df25ca78fd2210a65fd2a21ff2" translate="yes" xml:space="preserve">
          <source>This may also be set to the special value &lt;code&gt;none&lt;/code&gt; , in which case no quote marks are added around C&amp;lt;&amp;gt; text (but the font is still changed for troff output).</source>
          <target state="translated">也可以将其设置为特殊值 &lt;code&gt;none&lt;/code&gt; ，在这种情况下，不会在C &amp;lt;&amp;gt;文本周围添加引号（但是对于troff输出，字体仍然会更改）。</target>
        </trans-unit>
        <trans-unit id="345f8ac7fec5019dbde30571fee3e63e792fb3cf" translate="yes" xml:space="preserve">
          <source>This may also be set to the special value &lt;code&gt;none&lt;/code&gt; , in which case no quote marks are added around C&amp;lt;&amp;gt; text.</source>
          <target state="translated">也可以将其设置为特殊值 &lt;code&gt;none&lt;/code&gt; ，在这种情况下，不会在C &amp;lt;&amp;gt;文本周围添加引号。</target>
        </trans-unit>
        <trans-unit id="a4b045aef9d01569a459e4507e2bf0dbcc4d078d" translate="yes" xml:space="preserve">
          <source>This may be less obvious in other situations, such as &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt;, for instance when grepping through a list of weakened references to objects that may have been destroyed already:</source>
          <target state="translated">在其他情况下，例如 &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; ，这可能不太明显，例如，在通过grep遍历可能已经销毁的对象的弱引用列表时：</target>
        </trans-unit>
        <trans-unit id="9b6b611a35aea5e6cbfaa34dfad89779e54d15a6" translate="yes" xml:space="preserve">
          <source>This may be useful if other modules expect this module to be</source>
          <target state="translated">如果其他模块希望这个模块是一个新的模块,这可能是有用的。</target>
        </trans-unit>
        <trans-unit id="bb1bd20d64f2ccdce3f2cc8fcef954e7c80b5a33" translate="yes" xml:space="preserve">
          <source>This may be useful since, say, types which are &lt;code&gt;typedef&lt;/code&gt; -equivalent to integers may represent OS-related handles, and one may want to work with these handles in OO-way, as in &lt;code&gt;$handle-&amp;gt;do_something()&lt;/code&gt; . Use &lt;code&gt;-o .&lt;/code&gt; if you want to handle all the &lt;code&gt;typedef&lt;/code&gt; ed types as opaque types.</source>
          <target state="translated">这可能是有用的，因为，例如， &lt;code&gt;typedef&lt;/code&gt; 等效于整数的类型可能表示与OS相关的句柄，并且可能想要以OO方式使用这些句柄，例如 &lt;code&gt;$handle-&amp;gt;do_something()&lt;/code&gt; 。使用 &lt;code&gt;-o .&lt;/code&gt; 如果要处理所有 &lt;code&gt;typedef&lt;/code&gt; 编类型为不透明的类型。</target>
        </trans-unit>
        <trans-unit id="219180c7e012f10d4f7a83d42d7e8f2690484f40" translate="yes" xml:space="preserve">
          <source>This may break in two ways:</source>
          <target state="translated">这可能会有两个方面的突破。</target>
        </trans-unit>
        <trans-unit id="c894611388eb78ec067fed71d079c9e5816ca7b5" translate="yes" xml:space="preserve">
          <source>This may cause problems:</source>
          <target state="translated">这可能会造成问题。</target>
        </trans-unit>
        <trans-unit id="5b07568535355dc79492449b01ec4948cfdc2343" translate="yes" xml:space="preserve">
          <source>This may expect the C</source>
          <target state="translated">这可能期待C</target>
        </trans-unit>
        <trans-unit id="03f2543e21cbd92a7ee1ca79827f8f9611eefa56" translate="yes" xml:space="preserve">
          <source>This may later be extended to include other information, so be careful with pattern-matching on the results.</source>
          <target state="translated">以后可能会扩展到包括其他信息,所以在结果上要注意模式匹配。</target>
        </trans-unit>
        <trans-unit id="e21dadcda575196402392ef6ce13a8923c3356bf" translate="yes" xml:space="preserve">
          <source>This may lead to problems later in case the socket is accessed via the &quot;usual&quot; file-system calls using the &quot;initial&quot; name.</source>
          <target state="translated">这可能导致以后在使用 &quot;初始 &quot;名称通过 &quot;通常 &quot;的文件系统调用访问套接字时出现问题。</target>
        </trans-unit>
        <trans-unit id="6110636ef5b993e8ba32881ebb3b6bb734669e0b" translate="yes" xml:space="preserve">
          <source>This may take a couple of hours on 1GHz processor (when run the first time). And this should not be necessarily a smooth procedure. Some modules may not specify required dependencies, so one may need to repeat this procedure several times until the results stabilize.</source>
          <target state="translated">这在1GHz处理器上可能需要几个小时(第一次运行时)。而且这不一定是一个顺利的过程。有些模块可能没有指定所需的依赖关系,所以可能需要重复这个过程几次,直到结果稳定下来。</target>
        </trans-unit>
        <trans-unit id="21e8b83f4a4668675b959f09a3dddc3f913b92a2" translate="yes" xml:space="preserve">
          <source>This means integer values like 1.01E2 or even 1000E-2 are also accepted. Non-integer values result in NaN.</source>
          <target state="translated">这意味着像1.01E2甚至1000E-2这样的整数值也被接受。非整数值会导致NaN。</target>
        </trans-unit>
        <trans-unit id="0df399dd4c0ebd437b2b092068503ec57072d7a4" translate="yes" xml:space="preserve">
          <source>This means somewhere a routine got a BigFloat/Lite but expected a BigInt (or vice versa) and the upgrade/downgrad path was missing. This is a bug, please report it so that we can fix it.</source>
          <target state="translated">这意味着某个例程得到了BigFloat/Lite,但期望得到BigInt(或反之亦然),而升级/降级路径缺失。这是一个bug,请报告它,以便我们能够修复它。</target>
        </trans-unit>
        <trans-unit id="14a58ee32b8ae7bdc388a529d03ef7e5871a7f4e" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;catdir()&lt;/code&gt; is called only when there are two or more arguments, as one might expect.</source>
          <target state="translated">这意味着，仅在有两个或多个参数时才调用 &lt;code&gt;catdir()&lt;/code&gt; ，这可能会引起人们的预期。</target>
        </trans-unit>
        <trans-unit id="578c842326a0346c93813339f663f40295cced47" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;prop_invmap&lt;/code&gt; returns a 4 element list. For example,</source>
          <target state="translated">这意味着 &lt;code&gt;prop_invmap&lt;/code&gt; 返回一个4元素列表。例如，</target>
        </trans-unit>
        <trans-unit id="38b6532eaf6e68ec76d8a337e1c024ccfeab03a8" translate="yes" xml:space="preserve">
          <source>This means that arithmetic involving only string values or string literals will be performed using Perl's built-in operators.</source>
          <target state="translated">这意味着,只涉及字符串值或字符串字面的运算将使用 Perl 的内置运算符来执行。</target>
        </trans-unit>
        <trans-unit id="01006b71ced49944419d9cf9ecdab2df41a8f161" translate="yes" xml:space="preserve">
          <source>This means that if a developer only needs a module for the BAR standard, they should not be forced to install libraries for FOO as well.</source>
          <target state="translated">这意味着,如果一个开发者只需要一个BAR标准的模块,他们不应该被迫为FOO也安装库。</target>
        </trans-unit>
        <trans-unit id="a939b578ee66e30d68a1cb74f87d0079e5aa7b9c" translate="yes" xml:space="preserve">
          <source>This means that it short-circuits: the right expression is evaluated only if the left expression is false. Due to its precedence, you must be careful to avoid using it as replacement for the &lt;code&gt;||&lt;/code&gt; operator. It usually works out better for flow control than in assignments:</source>
          <target state="translated">这意味着它短路：仅当左表达式为false时，才对右表达式求值。由于其优先级，您必须小心避免使用它代替 &lt;code&gt;||&lt;/code&gt; 。操作员。通常，对于流量控制而言，比在分配中效果更好：</target>
        </trans-unit>
        <trans-unit id="be9154072eb271aa42c51fcc713d07f839133a3a" translate="yes" xml:space="preserve">
          <source>This means that the code points from 0 to 0x2F do not represent decimal digits; the code point 0x30 (DIGIT ZERO) represents 0; code point 0x31, (DIGIT ONE), represents 0+1-0 = 1; ... code point 0x39, (DIGIT NINE), represents 0+9-0 = 9; ... code points 0x3A through 0x65F do not represent decimal digits; 0x660 (ARABIC-INDIC DIGIT ZERO), represents 0; ... 0x07C1 (NKO DIGIT ONE), represents 0+1-0 = 1 ...</source>
          <target state="translated">这意味着从0到0x2F的代码点不代表十进制数字;代码点0x30(DIGIT ZERO)代表0;代码点0x31,(DIGIT ONE),代表0+1-0=1;......代码点0x39,(DIGIT NINE),代表0+9-0=9;......代码点0x3A到0x65F不代表十进制数字;0x660(ARABIC-INDIC DIGIT ZERO),代表0;......。0x07C1(NKO数字一),代表0+1-0=1......。</target>
        </trans-unit>
        <trans-unit id="53a7571a93760445ebdaebf443e990e621523e20" translate="yes" xml:space="preserve">
          <source>This means that the example in the synopsis could be rewritten more simply as:</source>
          <target state="translated">这意味着,提纲中的例子可以更简单地改写为。</target>
        </trans-unit>
        <trans-unit id="a1f3ea2c657f7b7f7d19db3a4421f880ee25efe3" translate="yes" xml:space="preserve">
          <source>This means that the space in the middle of the visible link text must not be broken across lines. In other words, it's the same as this:</source>
          <target state="translated">也就是说,可见链接文字中间的空格不能跨行断开。换句话说,就是和这个一样。</target>
        </trans-unit>
        <trans-unit id="64c7de2c5fffc581047d71755a716f6efa16c586" translate="yes" xml:space="preserve">
          <source>This means that the words in</source>
          <target state="translated">这意味着,在</target>
        </trans-unit>
        <trans-unit id="f1569c4431f8fc6543e767edacb7a758da5a6960" translate="yes" xml:space="preserve">
          <source>This means that when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; is in effect, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; lets you use a package variable without qualifying it with the package name, but only within the lexical scope of the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration. This applies immediately--even within the same statement.</source>
          <target state="translated">这意味着当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; 生效时， &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 允许您使用包变量而不用包名来限定它，而只能在 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明的词法范围内使用。这立即适用-即使在同一语句中也是如此。</target>
        </trans-unit>
        <trans-unit id="f586cceadb03a1ba8357cc824f5f5d4e8015da6f" translate="yes" xml:space="preserve">
          <source>This means that when &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; is in effect, &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; lets you use a package variable without qualifying it with the package name, but only within the lexical scope of the &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration. This applies immediately--even within the same statement.</source>
          <target state="translated">这意味着当 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; 生效时， &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 允许您使用包变量而不用包名来限定它，而只能在 &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明的词法范围内使用。这立即适用-即使在同一语句中也是如此。</target>
        </trans-unit>
        <trans-unit id="b81785772e2cebea14c023690b3e80231bc941d4" translate="yes" xml:space="preserve">
          <source>This means that you can embed Perl code in your typemap (C) code using constructs such as &lt;code&gt;${ perl code that evaluates to &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; reference here }&lt;/code&gt; . A common use case is to generate error messages that refer to the true function name even when using the ALIAS XS feature:</source>
          <target state="translated">这意味着您可以使用诸如 &lt;code&gt;${ perl code that evaluates to &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; reference here }&lt;/code&gt; 结构将Perl代码嵌入到类型映射（C）代码中。一个常见的用例是即使使用ALIAS XS功能，也会生成引用真实函数名称的错误消息：</target>
        </trans-unit>
        <trans-unit id="fae397e13ee74537dfbe00fc3647b75575531d38" translate="yes" xml:space="preserve">
          <source>This means that you can pass back or save away references to lexical variables, whereas to return a pointer to a C auto is a grave error. It also gives us a way to simulate C's function statics. Here's a mechanism for giving a function private variables with both lexical scoping and a static lifetime. If you do want to create something like C's static variables, just enclose the whole function in an extra block, and put the static variable outside the function but in the block.</source>
          <target state="translated">这意味着你可以传回或保存掉对词法变量的引用,而返回一个指向C语言自动变量的指针是一个严重的错误。它还为我们提供了一种模拟 C 的函数静态的方法。这里有一个机制,可以给一个函数提供私有变量,同时具有词法范围和静态寿命。如果你确实想创建类似于C的静态变量,只需将整个函数封闭在一个额外的块中,并将静态变量放在函数之外,但放在块中即可。</target>
        </trans-unit>
        <trans-unit id="ba95400be83f3e213b12cd9a0fd5821a87880672" translate="yes" xml:space="preserve">
          <source>This means that your locale settings had &lt;code&gt;LC_ALL&lt;/code&gt; set to &quot;En_US&quot; and LANG exists but has no value. Perl tried to believe you but could not. Instead, Perl gave up and fell back to the &quot;C&quot; locale, the default locale that is supposed to work no matter what. (On Windows, it first tries falling back to the system default locale.) This usually means your locale settings were wrong, they mention locales your system has never heard of, or the locale installation in your system has problems (for example, some system files are broken or missing). There are quick and temporary fixes to these problems, as well as more thorough and lasting fixes.</source>
          <target state="translated">这意味着您的区域设置将 &lt;code&gt;LC_ALL&lt;/code&gt; 设置为&amp;ldquo; En_US&amp;rdquo;，并且LANG存在但没有任何值。 Perl试图相信您，但无法相信。取而代之的是，Perl放弃并退回到&amp;ldquo; C&amp;rdquo;区域设置，该区域设置无论如何都可以正常工作。 （在Windows上，它首先尝试回退到系统默认语言环境。）这通常意味着您的语言环境设置有误，它们提到系统从未听说过的语言环境，或者系统中的语言环境安装有问题（例如，某些系统文件损坏或丢失）。有针对这些问题的快速和临时修复程序，以及更彻底，更持久的修复程序。</target>
        </trans-unit>
        <trans-unit id="935bdf240cb07ad1d6c61c4ce332cb8c8c8bea3f" translate="yes" xml:space="preserve">
          <source>This means the hook can be inherited like any other method, and that</source>
          <target state="translated">这意味着钩子可以像其他方法一样被继承,而且</target>
        </trans-unit>
        <trans-unit id="2829080b86855df25144fdad5ccaac91d3e22b76" translate="yes" xml:space="preserve">
          <source>This means the same thing as the above &quot;=begin html&quot; ... &quot;=end html&quot; region.</source>
          <target state="translated">这与上面的&quot;=begin html&quot;...的意思是一样的。&quot;=end html &quot;区域。</target>
        </trans-unit>
        <trans-unit id="44c698371a2bc8c8f85a78f7834202f417a26f2b" translate="yes" xml:space="preserve">
          <source>This means you would have to be very careful of the load order:</source>
          <target state="translated">这意味着你必须要非常小心的装载顺序。</target>
        </trans-unit>
        <trans-unit id="cff2ec52af1291aa43e3a1c0cb12356c3eeef13f" translate="yes" xml:space="preserve">
          <source>This member is of type &lt;code&gt;Perl_cpeep_t&lt;/code&gt; , which expands to &lt;code&gt;void
(*Perl_cpeep_t)(aTHX_ OP *o, OP *oldop)&lt;/code&gt; . If it is set, this function will be called from &lt;code&gt;Perl_rpeep&lt;/code&gt; when ops of this type are encountered by the peephole optimizer.</source>
          <target state="translated">该成员的类型为 &lt;code&gt;Perl_cpeep_t&lt;/code&gt; ，它扩展为 &lt;code&gt;void (*Perl_cpeep_t)(aTHX_ OP *o, OP *oldop)&lt;/code&gt; 。如果已设置，则窥孔优化器遇到这种类型的操作时，将从 &lt;code&gt;Perl_rpeep&lt;/code&gt; 调用此函数。</target>
        </trans-unit>
        <trans-unit id="4f15c1dce331d08d1c4dfe4e281cc0a0a4b34f0a" translate="yes" xml:space="preserve">
          <source>This message can be seen quite often with DB_File on systems with &quot;hard&quot; dynamic linking, like &lt;code&gt;AIX&lt;/code&gt; and &lt;code&gt;OS/2&lt;/code&gt; . It is a bug of &lt;code&gt;Berkeley DB&lt;/code&gt; which is left unnoticed if &lt;code&gt;DB&lt;/code&gt; uses</source>
          <target state="translated">在具有&amp;ldquo;硬&amp;rdquo;动态链接的系统（例如 &lt;code&gt;AIX&lt;/code&gt; 和 &lt;code&gt;OS/2&lt;/code&gt; )上，使用DB_File可以经常看到此消息。这是 &lt;code&gt;Berkeley DB&lt;/code&gt; 的错误，如果 &lt;code&gt;DB&lt;/code&gt; 使用</target>
        </trans-unit>
        <trans-unit id="23eb60fb126cb22151d73766a234b7a419df8dc7" translate="yes" xml:space="preserve">
          <source>This message is output once each time a bad locale is switched into within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , or on the first possibly-affected operation if the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; inherits a bad one. It is not raised for any operations from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="translated">每当在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的范围内将不良区域设置切换到该区域时，或在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 继承了不良区域的第一个可能受影响的操作上，都会输出此消息。对于&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块的任何操作，不会引发它。</target>
        </trans-unit>
        <trans-unit id="9f1e56024310d1748ef48e25b309befac60c3c39" translate="yes" xml:space="preserve">
          <source>This message is suppressed (unless it has been made fatal) if it is immaterial to the results of the match if the code point is Unicode or not. For example, the property &lt;code&gt;\p{ASCII_Hex_Digit}&lt;/code&gt; only can match the 22 characters &lt;code&gt;[0-9A-Fa-f]&lt;/code&gt; , so obviously all other code points, Unicode or not, won't match it. (And &lt;code&gt;\P{ASCII_Hex_Digit}&lt;/code&gt; will match every code point except these 22.)</source>
          <target state="translated">如果代码点是否为Unicode，则对匹配结果不重要时，将禁止显示此消息（除非已使其成为致命消息）。例如，属性 &lt;code&gt;\p{ASCII_Hex_Digit}&lt;/code&gt; 只能匹配22个字符 &lt;code&gt;[0-9A-Fa-f]&lt;/code&gt; ，因此显然所有其他代码点（无论是否为Unicode）都不匹配。（并且 &lt;code&gt;\P{ASCII_Hex_Digit}&lt;/code&gt; 将匹配除这22个以外的每个代码点。）</target>
        </trans-unit>
        <trans-unit id="7bb0745c94a8675163fb7cf1b6b4c0dfe9dfc2a4" translate="yes" xml:space="preserve">
          <source>This method (by having it return the name of a language-tag that has an existing language class) can be used for making sure that &lt;code&gt;get_handle&lt;/code&gt; will always manage to construct a language handle (assuming your language classes are in an appropriate @INC directory). Or you can use the next method:</source>
          <target state="translated">此方法（通过使其返回具有现有语言类的语言标签的名称）可用于确保 &lt;code&gt;get_handle&lt;/code&gt; 将始终设法构造语言句柄（假设您的语言类位于适当的@INC目录中） 。或者，您可以使用下一个方法：</target>
        </trans-unit>
        <trans-unit id="43b19e8a9632f033ee0217cf824970a6266507f4" translate="yes" xml:space="preserve">
          <source>This method &lt;b&gt;only&lt;/b&gt; recurses into hashes that are referenced by another hash. Thus a Hash of Hashes (HoH) will all be restricted, but a Hash of Arrays of Hashes (HoAoH) will only have the top hash restricted.</source>
          <target state="translated">此方法&lt;b&gt;仅&lt;/b&gt;递归到另一个哈希引用的哈希。因此，哈希散列（HoH）都将受到限制，但是哈希散列（HoAoH）只会限制顶部散列。</target>
        </trans-unit>
        <trans-unit id="a9adaf0f299fbd1e9f3a618dc3103eaac097e023" translate="yes" xml:space="preserve">
          <source>This method allows you declare all subsequent tests as TODO tests, up until the &lt;code&gt;todo_end&lt;/code&gt; method has been called.</source>
          <target state="translated">此方法允许您将所有后续测试声明为TODO测试，直到调用 &lt;code&gt;todo_end&lt;/code&gt; 方法为止。</target>
        </trans-unit>
        <trans-unit id="730814a3d72347a8011b0b6b58b63dc1cbc1cb75" translate="yes" xml:space="preserve">
          <source>This method always returns &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when compressing.</source>
          <target state="translated">压缩时，此方法始终返回 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6afef23ef81e88b5f94163ca10a11464e31ea48f" translate="yes" xml:space="preserve">
          <source>This method appends the given text or parse-tree to the current parse-tree. If the last item on the parse-tree is text and the argument is also text, then the text is appended to the last item (not added as a separate string). Otherwise the argument is added as a new string or parse-tree</source>
          <target state="translated">本方法将给定的文本或解析树附加到当前的解析树上,如果解析树上的最后一项是文本,并且参数也是文本,那么文本将被附加到最后一项上(而不是作为单独的字符串添加)。如果解析树上的最后一项是文本,而参数也是文本,那么文本将被追加到最后一项上(而不是作为一个单独的字符串添加)。否则,参数将作为一个新的字符串或解析树被添加。</target>
        </trans-unit>
        <trans-unit id="ea9b54b0560b3ed55c0cd396158f6152d9f5e42b" translate="yes" xml:space="preserve">
          <source>This method behaves like &lt;code&gt;accept_targets_as_text&lt;/code&gt; , but also marks the region as one whose content should be emitted literally, without HTML entity escaping or wrapping in a &lt;code&gt;div&lt;/code&gt; element.</source>
          <target state="translated">此方法的行为类似于 &lt;code&gt;accept_targets_as_text&lt;/code&gt; ，但也将该区域标记为应按字面意义发出其内容的区域，而HTML实体没有转义或包装在 &lt;code&gt;div&lt;/code&gt; 元素中。</target>
        </trans-unit>
        <trans-unit id="366bdf6f4cd4331574bef09ad73e8fc1d9c85442" translate="yes" xml:space="preserve">
          <source>This method can also be called as a</source>
          <target state="translated">这个方法也可以作为</target>
        </trans-unit>
        <trans-unit id="715fe7c265d92fe58819e384722c797c228ac231" translate="yes" xml:space="preserve">
          <source>This method can be used to (re)parse a (new) hyperlink, i.e. the contents of a &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence. The result is stored in the current object. Warnings are stored in the &lt;b&gt;warnings&lt;/b&gt; property. E.g. sections like &lt;code&gt;L&amp;lt;open(2)&amp;gt;&lt;/code&gt; are deprecated, as they do not point to Perl documents. &lt;code&gt;L&amp;lt;DBI::foo(3p)&amp;gt;&lt;/code&gt; is wrong as well, the manpage section can simply be dropped.</source>
          <target state="translated">该方法可用于（重新）解析（新）超链接，即 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 序列的内容。结果存储在当前对象中。警告存储在&lt;b&gt;警告&lt;/b&gt;属性中。例如，不赞成使用 &lt;code&gt;L&amp;lt;open(2)&amp;gt;&lt;/code&gt; 类的节，因为它们未指向Perl文档。 &lt;code&gt;L&amp;lt;DBI::foo(3p)&amp;gt;&lt;/code&gt; 也是错误的，可以直接删除联机帮助页部分。</target>
        </trans-unit>
        <trans-unit id="f1f35fb67080240d23f2eac011ae3670c8591965" translate="yes" xml:space="preserve">
          <source>This method can be used to attempt to recover good data from a compressed data stream that is partially corrupt. It scans &lt;code&gt;$input&lt;/code&gt; until it reaches either a</source>
          <target state="translated">此方法可用于尝试从部分损坏的压缩数据流中恢复良好的数据。它扫描 &lt;code&gt;$input&lt;/code&gt; 直到到达一个</target>
        </trans-unit>
        <trans-unit id="90ddd0ac6657449db229f14a03b758f7e485db52" translate="yes" xml:space="preserve">
          <source>This method can be used to wait for a transfer to complete between a passive server and a non-passive server. The method should be called on the passive server with the &lt;code&gt;Net::FTP&lt;/code&gt; object for the non-passive server passed as an argument.</source>
          <target state="translated">此方法可用于等待被动服务器和非被动服务器之间的传输完成。在被动服务器上应使用 &lt;code&gt;Net::FTP&lt;/code&gt; 对象作为参数传递非被动服务器的方法。</target>
        </trans-unit>
        <trans-unit id="ef82cc525f992d173e6595484cbecf34f240de62" translate="yes" xml:space="preserve">
          <source>This method checks for the existence of a specific key/value pair. If the pair exists, the cursor is left pointing to the pair and the method returns 0. Otherwise the method returns a non-zero value.</source>
          <target state="translated">本方法检查是否存在一个特定的键/值对。如果这对键/值存在,则光标左键指向这对键/值,方法返回0。否则,本方法返回一个非零值。</target>
        </trans-unit>
        <trans-unit id="082e97019fd385ec77aeb826bdad258d6d406921" translate="yes" xml:space="preserve">
          <source>This method deletes a specific key/value pair. It returns 0 if they exist and have been deleted successfully. Otherwise the method returns a non-zero value.</source>
          <target state="translated">本方法删除一个特定的键/值对。如果它们存在并且被成功删除,则返回0。否则本方法返回一个非零值。</target>
        </trans-unit>
        <trans-unit id="f513febb40f0a4c26460c04fb3a509ae4b426b01" translate="yes" xml:space="preserve">
          <source>This method deserializes the given string of JSON and the result. If the source was UTF-8 encoded, the string must be decoded before calling &lt;code&gt;load_json_string&lt;/code&gt; .</source>
          <target state="translated">此方法反序列化给定的JSON字符串和结果。如果源是UTF-8编码的，则必须在调用 &lt;code&gt;load_json_string&lt;/code&gt; 之前对字符串进行解码。</target>
        </trans-unit>
        <trans-unit id="f96e67c98ce1447f296a5e844322e09f6dd910a8" translate="yes" xml:space="preserve">
          <source>This method deserializes the given string of YAML and returns the first document in it. (CPAN metadata files should always have only one document.) If the source was UTF-8 encoded, the string must be decoded before calling &lt;code&gt;load_yaml_string&lt;/code&gt; .</source>
          <target state="translated">此方法反序列化给定的YAML字符串，并返回其中的第一个文档。（CPAN元数据文件应始终只有一个文档。）如果源是UTF-8编码的，则在调用 &lt;code&gt;load_yaml_string&lt;/code&gt; 之前必须对字符串进行解码。</target>
        </trans-unit>
        <trans-unit id="34a514b4f19b9ac86f842d6404bf8e89dd74c0e2" translate="yes" xml:space="preserve">
          <source>This method does</source>
          <target state="translated">本方法不</target>
        </trans-unit>
        <trans-unit id="54d18cd2ca68c9792cf6431fafe4da3a6cbdd8dc" translate="yes" xml:space="preserve">
          <source>This method does not implement a complete YAML dumper, being limited to dump a hash with values which are strings, undef's or nested hashes and arrays of strings. No quoting/escaping is done.</source>
          <target state="translated">这个方法并没有实现一个完整的YAML转储器,仅限于转储一个包含字符串、undef's或嵌套的字符串哈希和数组的值。没有进行引号/转码。</target>
        </trans-unit>
        <trans-unit id="bf3b86793c28703b24d0cd86f4cd0ebea05c47fa" translate="yes" xml:space="preserve">
          <source>This method fully supports the use of the variable &lt;code&gt;$/&lt;/code&gt; (or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; or &lt;code&gt;$RS&lt;/code&gt; when &lt;code&gt;English&lt;/code&gt; is in use) to determine what constitutes an end of line. Paragraph mode, record mode and file slurp mode are all supported.</source>
          <target state="translated">该方法完全支持使用可变的 &lt;code&gt;$/&lt;/code&gt; （或 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; 或 &lt;code&gt;$RS&lt;/code&gt; 当 &lt;code&gt;English&lt;/code&gt; 是在使用中），以确定什么构成线的端部。支持段落模式，记录模式和文件记录模式。</target>
        </trans-unit>
        <trans-unit id="7abd31a42f5dc198423e7bfa2a6a7d4410aa53a3" translate="yes" xml:space="preserve">
          <source>This method gets faster the more sparse the bit vector is. (Courtesy of Tim Bunce and Winfried Koenig.)</source>
          <target state="translated">这种方法在位向量越稀疏的情况下速度越快。(由Tim Bunce和Winfried Koenig提供)</target>
        </trans-unit>
        <trans-unit id="5106fbdd40086fe1994d026f8235d7c19445b51f" translate="yes" xml:space="preserve">
          <source>This method gets triggered during a keys() or each() iteration. It has a second argument which is the last key that had been accessed. This is useful if you're carrying about ordering or calling the iterator from more than one sequence, or not really storing things in a hash anywhere.</source>
          <target state="translated">这个方法在keys()或each()迭代时被触发。它的第二个参数是最后一个被访问的键。如果你从多个序列中进行排序或调用迭代器,或者不是真的把东西存储在哈希中,这个方法就很有用。</target>
        </trans-unit>
        <trans-unit id="2b32b03e834069c38c85e8165c3d6300a8ef2db8" translate="yes" xml:space="preserve">
          <source>This method gets/sets the children of the top node in the parse-tree. If no arguments are given, it returns the list (array) of children (each of which should be either a string or a &lt;b&gt;Pod::InteriorSequence&lt;/b&gt;. Otherwise, if arguments are given, they are treated as the new list of children for the top node.</source>
          <target state="translated">此方法获取/设置解析树中顶级节点的子级。如果未提供任何参数，则返回子项的列表（数组）（每个子项应为字符串或&lt;b&gt;Pod :: InteriorSequence&lt;/b&gt;。否则，如果提供了参数，则将其视为顶部子项的新子级列表）节点。</target>
        </trans-unit>
        <trans-unit id="b46a6ad296dd61f630d70737a71545994d0ce79d" translate="yes" xml:space="preserve">
          <source>This method gets/sets the top node of the parse-tree. If no arguments are given, it returns the topmost node in the tree (the root), which is also a &lt;b&gt;Pod::ParseTree&lt;/b&gt;. If it is given a single argument that is a reference, then the reference is assumed to a parse-tree and becomes the new top node. Otherwise, if arguments are given, they are treated as the new list of children for the top node.</source>
          <target state="translated">此方法获取/设置解析树的顶部节点。如果未提供任何参数，它将返回树中的最高节点（根），该节点也是&lt;b&gt;Pod :: ParseTree&lt;/b&gt;。如果给定单个参数作为引用，则该引用将假定为解析树，并成为新的顶级节点。否则，如果给出参数，则将其视为顶部节点的新子级列表。</target>
        </trans-unit>
        <trans-unit id="59076bbdbb5b4ddcc87d5e0b9c9e7bca5153b33d" translate="yes" xml:space="preserve">
          <source>This method handles the body of text that is marked up to be code. You might for instance override this to plug in a syntax highlighter. The base implementation just escapes the text.</source>
          <target state="translated">这个方法处理被标记为代码的文本主体。例如,你可以重写这个方法来插入一个语法高亮器。基本实现只是对文本进行转义。</target>
        </trans-unit>
        <trans-unit id="7f7d4c41920dd2575a0ef9de52d6dfd4b083b3af" translate="yes" xml:space="preserve">
          <source>This method handles the body of text within any element: it's the body of a paragraph, or everything between a &quot;=begin&quot; tag and the corresponding &quot;=end&quot; tag, or the text within an L entity, etc. You would want to override this if you are adding a custom element type that does more than just display formatted text. Perhaps adding a way to generate HTML tables from an extended version of POD.</source>
          <target state="translated">这个方法可以处理任何元素中的文本主体:它是一个段落的主体,或者是&quot;=begin &quot;标签和相应的&quot;=end &quot;标签之间的所有内容,或者是一个L实体中的文本等等。如果你要添加一个自定义的元素类型,不仅仅是显示格式化的文本,你会想要覆盖这一点。或许可以添加一种从POD的扩展版本中生成HTML表格的方法。</target>
        </trans-unit>
        <trans-unit id="0712996dc1b8ffb7aa50e7d069711d277d763268" translate="yes" xml:space="preserve">
          <source>This method has exactly the same effect as</source>
          <target state="translated">这种方法的效果与</target>
        </trans-unit>
        <trans-unit id="065b0a15e17527d35032fe1e6828915d084d4b0d" translate="yes" xml:space="preserve">
          <source>This method is a synonym for &lt;code&gt;actual_passed&lt;/code&gt; .</source>
          <target state="translated">此方法是 &lt;code&gt;actual_passed&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="a3a66a71f2968f9c82df6782744ec138e9c54cf9" translate="yes" xml:space="preserve">
          <source>This method is called automatically when the object is used as a string.</source>
          <target state="translated">当对象被用作字符串时,本方法会被自动调用。</target>
        </trans-unit>
        <trans-unit id="a819fa8543b1fdd50426768934ef9b1f1b767855" translate="yes" xml:space="preserve">
          <source>This method is called automatically when the object is used in string context.</source>
          <target state="translated">当该对象在字符串上下文中使用时,该方法会自动调用。</target>
        </trans-unit>
        <trans-unit id="ac138a74ffc74278892e510893352f2e36c5d5e7" translate="yes" xml:space="preserve">
          <source>This method is called by &lt;code&gt;response&lt;/code&gt; as a method with one argument. It should return an array of 2 values, the 3-digit status code and a flag which is true when this is part of a multi-line response and this line is not the last.</source>
          <target state="translated">&lt;code&gt;response&lt;/code&gt; 将此方法称为带有一个参数的方法。它应返回2个值的数组，3位状态代码和一个标志，当它是多行响应的一部分并且不是最后一行时，则为true。</target>
        </trans-unit>
        <trans-unit id="caa6afaab7cedc695e3c6f58f69b2ab8274688f3" translate="yes" xml:space="preserve">
          <source>This method is called during construction by &lt;code&gt;IO::Pipe::new&lt;/code&gt; on the newly created &lt;code&gt;IO::Pipe&lt;/code&gt; object. It returns an array of two objects blessed into &lt;code&gt;IO::Pipe::End&lt;/code&gt; , or a subclass thereof.</source>
          <target state="translated">在构造期间，由新创建的 &lt;code&gt;IO::Pipe&lt;/code&gt; 对象上的 &lt;code&gt;IO::Pipe::new&lt;/code&gt; 调用此方法。它返回祝福给 &lt;code&gt;IO::Pipe::End&lt;/code&gt; 或其子类的两个对象组成的数组。</target>
        </trans-unit>
        <trans-unit id="5287b2e5ba98e503e67859e5f2d01d79cbfa6c5e" translate="yes" xml:space="preserve">
          <source>This method is called to print debugging information. TEXT is the text being sent. The method should return the text to be printed.</source>
          <target state="translated">调用本方法打印调试信息。TEXT是被发送的文本。本方法应返回要打印的文本。</target>
        </trans-unit>
        <trans-unit id="f167b29ab442c8210c9356c7997b2fd2247776b0" translate="yes" xml:space="preserve">
          <source>This method is called when the handle is read via &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt; HANDLE&lt;/code&gt; .</source>
          <target state="translated">通过 &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt; HANDLE&lt;/code&gt; 读取句柄时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="c6629dc17ac853da211380c0f404bf1fca26aed1" translate="yes" xml:space="preserve">
          <source>This method is called with two arguments: the relevant package name, and a reference to a variable or subroutine for which package-defined attributes are desired. The expected return value is a list of associated attributes. This list may be empty.</source>
          <target state="translated">这个方法的调用有两个参数:相关的包名,以及对需要包定义属性的变量或子程序的引用。预期的返回值是一个相关属性的列表。这个列表可以是空的。</target>
        </trans-unit>
        <trans-unit id="45320fc2f3e3a4eca2479ec9f217dfab3504ebe5" translate="yes" xml:space="preserve">
          <source>This method is called with two fixed arguments, followed by the list of attributes from the relevant declaration. The two fixed arguments are the relevant package name and a reference to the declared subroutine or variable. The expected return value is a list of attributes which were not recognized by this handler. Note that this allows for a derived class to delegate a call to its base class, and then only examine the attributes which the base class didn't already handle for it.</source>
          <target state="translated">这个方法的调用有两个固定参数,后面是相关声明的属性列表。两个固定参数是相关的包名和对声明的子程序或变量的引用。预期的返回值是一个没有被该处理程序识别的属性列表。请注意,这允许派生类将调用委托给它的基类,然后只检查基类没有为它处理的属性。</target>
        </trans-unit>
        <trans-unit id="6abefc963006076df05b84dfc6d2811ce9f6040b" translate="yes" xml:space="preserve">
          <source>This method is deprecated if running under Perl 5.8, and is no longer present if running under Perl 5.9</source>
          <target state="translated">如果在Perl 5.8下运行,此方法已被废弃,如果在Perl 5.9下运行,此方法也不再存在。</target>
        </trans-unit>
        <trans-unit id="5c663722b6a1ec14ffe0820b635acf25e140b2e8" translate="yes" xml:space="preserve">
          <source>This method is invoked after gathering up all the lines in a paragraph and after determining the cutting state of the paragraph, but before trying to further parse or interpret them. After &lt;b&gt;preprocess_paragraph()&lt;/b&gt; returns, the current cutting state (which is returned by &lt;code&gt;$self-&amp;gt;cutting()&lt;/code&gt; ) is examined. If it evaluates to true then input text (including the given &lt;code&gt;$text&lt;/code&gt; ) is cut (not processed) until the next POD directive is encountered.</source>
          <target state="translated">在收集段落中的所有行之后，在确定段落的剪切状态之后，但是在尝试进一步解析或解释它们之前，将调用此方法。返回&lt;b&gt;preprocess_paragraph（）&lt;/b&gt;后，将检查当前的切割状态（由 &lt;code&gt;$self-&amp;gt;cutting()&lt;/code&gt; ）。如果计算结果为true，则输入文本（包括给定的 &lt;code&gt;$text&lt;/code&gt; ）将被剪切（不处理），直到遇到下一个POD指令为止。</target>
        </trans-unit>
        <trans-unit id="10379a9139313cde9e23b44b9d3191ab35fe83cb" translate="yes" xml:space="preserve">
          <source>This method is invoked at the beginning of processing for each POD document that is encountered in the input. Subclasses should override this method to perform any per-document initialization.</source>
          <target state="translated">在处理开始时,对输入中遇到的每个POD文档都会调用这个方法。子类应该重写这个方法来执行任何每个文档的初始化。</target>
        </trans-unit>
        <trans-unit id="413604196761a8f6291ef93425b6ff6c449d0805" translate="yes" xml:space="preserve">
          <source>This method is invoked at the end of processing for each POD document that is encountered in the input. Subclasses should override this method to perform any per-document finalization.</source>
          <target state="translated">在处理结束时,对输入中遇到的每个POD文档都会调用这个方法。子类应该重写这个方法来执行任何每个文档的最终处理。</target>
        </trans-unit>
        <trans-unit id="c39c6b3f4be6d469d8afebc0b47e837d73cf3993" translate="yes" xml:space="preserve">
          <source>This method is invoked by &lt;b&gt;parse_from_filehandle()&lt;/b&gt; immediately</source>
          <target state="translated">&lt;b&gt;parse_from_filehandle（）&lt;/b&gt;立即调用此方法</target>
        </trans-unit>
        <trans-unit id="6747dae8cbf5615de1cf353ad79e0a07cee8a900" translate="yes" xml:space="preserve">
          <source>This method is less often useful. It assumes that the string stored in the struct is null-terminated, and disregards the length information.</source>
          <target state="translated">这种方法不太有用。它假设存储在结构体中的字符串是空端的,并且不考虑长度信息。</target>
        </trans-unit>
        <trans-unit id="c79ad557d9b0fbcd0831200e697c308d8d3ffa30" translate="yes" xml:space="preserve">
          <source>This method is non-blocking, and will return only as many items as are available to fulfill the request:</source>
          <target state="translated">这个方法是非阻塞的,将只返回可用来满足请求的项目数量。</target>
        </trans-unit>
        <trans-unit id="6fb78fde591144d3983cff09b4ae34dcd5c3fb9d" translate="yes" xml:space="preserve">
          <source>This method is not present if running under Perl 5.9, as the PMROOT information is no longer stored directly in the hash.</source>
          <target state="translated">如果在Perl 5.9下运行,这个方法就不存在了,因为PMROOT信息不再直接存储在哈希中。</target>
        </trans-unit>
        <trans-unit id="f1244eb4316f69131f6963e6774a849bda60f19c" translate="yes" xml:space="preserve">
          <source>This method is of no use for general Perl threads programming. Its intent is to provide other (XS-based) thread modules with the capability to access, and possibly manipulate, the underlying thread structure associated with a Perl thread.</source>
          <target state="translated">这个方法对一般的Perl线程编程没有用处。它的目的是为其他(基于XS的)线程模块提供访问并可能操作与Perl线程相关联的底层线程结构的能力。</target>
        </trans-unit>
        <trans-unit id="21dc78ea221a1896dd75e4ea5a218dfbc7c4df02" translate="yes" xml:space="preserve">
          <source>This method is protected and not intended to be called outside of MakeMaker.</source>
          <target state="translated">这个方法是受保护的,不打算在MakeMaker之外调用。</target>
        </trans-unit>
        <trans-unit id="e5a20cfe7a533839e6244ee0ceb882a48e01de5e" translate="yes" xml:space="preserve">
          <source>This method is similar to share() but allows you to explicitly name the package that symbols should be shared from. The symbol names (including type characters) are supplied as an array reference.</source>
          <target state="translated">这个方法类似于share(),但允许你明确地命名应该从哪个包共享符号。符号名称(包括类型字符)作为一个数组引用提供。</target>
        </trans-unit>
        <trans-unit id="f5a57d1e0f15bd04707c86271032904c47bf2e9b" translate="yes" xml:space="preserve">
          <source>This method is the one you usually want. It constructs a string using the length and offset information in the struct: for ordinary scalars it will return the string that you'd see from Perl, even if it contains null characters.</source>
          <target state="translated">这个方法是你通常需要的方法,它使用结构体中的长度和偏移量信息构造一个字符串。它使用结构中的长度和偏移量信息构造一个字符串:对于普通的标量,它将返回你在Perl中看到的字符串,即使它包含空字符。</target>
        </trans-unit>
        <trans-unit id="01115bf69ddf4deb1227d201ea74e47486095d25" translate="yes" xml:space="preserve">
          <source>This method is triggered when a tied hash is about to go out of scope. You don't really need it unless you're trying to add debugging or have auxiliary state to clean up. Here's a very simple function:</source>
          <target state="translated">当一个绑定的哈希即将超出范围时,这个方法会被触发。你并不真的需要它,除非你想增加调试或者有辅助状态需要清理。这里有一个非常简单的函数。</target>
        </trans-unit>
        <trans-unit id="2987f28dec8ef9effc2010b2cf05de3e78ff66c2" translate="yes" xml:space="preserve">
          <source>This method is triggered when the user uses the exists() function on a particular hash. In our example, we'll look at the &lt;code&gt;{LIST}&lt;/code&gt; hash element for this:</source>
          <target state="translated">当用户在特定哈希上使用exist（）函数时，将触发此方法。在我们的示例中，我们将为此查看 &lt;code&gt;{LIST}&lt;/code&gt; 哈希元素：</target>
        </trans-unit>
        <trans-unit id="642b5a68b22f43aa4631e9ecbebcec5f49cf6aa8" translate="yes" xml:space="preserve">
          <source>This method is triggered when the whole hash is to be cleared, usually by assigning the empty list to it.</source>
          <target state="translated">当要清除整个哈希时,这个方法就会被触发,通常是将空列表分配给它。</target>
        </trans-unit>
        <trans-unit id="b7c5e76fa8c5d820b269407c2691745bfe513299" translate="yes" xml:space="preserve">
          <source>This method is triggered when we remove an element from the hash, typically by using the delete() function. Again, we'll be careful to check whether they really want to clobber files.</source>
          <target state="translated">当我们从哈希中删除一个元素时,这个方法就会被触发,通常是通过使用delete()函数。同样,我们要注意检查他们是否真的要clobber文件。</target>
        </trans-unit>
        <trans-unit id="d44b267a60e501cab8cef2efaa122beb61916cef" translate="yes" xml:space="preserve">
          <source>This method is used to add to the currently selected sections and subsections of POD documentation that are to be printed and/or processed. See &amp;lt;select()&amp;gt; for replacing the currently selected sections.</source>
          <target state="translated">此方法用于将要打印和/或处理的POD文档添加到当前选定的部分和子部分。请参见&amp;lt;select（）&amp;gt;替换当前选定的部分。</target>
        </trans-unit>
        <trans-unit id="79298df7a94b5d243fe4caa12d96cacff3087b81" translate="yes" xml:space="preserve">
          <source>This method is used to determine if the block of text given in &lt;code&gt;$paragraph&lt;/code&gt; falls within the currently selected set of POD sections and subsections to be printed or processed. This method is also responsible for keeping track of the current input section and subsections. It is assumed that &lt;code&gt;$paragraph&lt;/code&gt; is the most recently read (but not yet processed) input paragraph.</source>
          <target state="translated">此方法用于确定 &lt;code&gt;$paragraph&lt;/code&gt; 给定的文本块是否属于要打印或处理的POD部分和子部分的当前选定集合。此方法还负责跟踪当前输入节和子节。假定 &lt;code&gt;$paragraph&lt;/code&gt; 是最近读取（但尚未处理）的输入段落。</target>
        </trans-unit>
        <trans-unit id="bbbe3e628f204e314a28a9c25f8f03f14e0f6464" translate="yes" xml:space="preserve">
          <source>This method is used to select the particular sections and subsections of POD documentation that are to be printed and/or processed. The existing set of selected sections is</source>
          <target state="translated">此方法用于选择要打印和/或处理的POD文件的特定部分和子部分。现有的选定章节集是</target>
        </trans-unit>
        <trans-unit id="bef747284ac03954e21b22973b38b9cf4e4e7f3d" translate="yes" xml:space="preserve">
          <source>This method is useful if you need to perform your own interpolation of interior sequences and can't rely upon &lt;b&gt;interpolate&lt;/b&gt; to expand them in simple bottom-up order.</source>
          <target state="translated">如果您需要对内部序列执行自己的插值并且不能依赖于&lt;b&gt;插值&lt;/b&gt;以简单的自底向上的顺序扩展它们，则此方法很有用。</target>
        </trans-unit>
        <trans-unit id="49a58cbb089494a695c730a567717e544a3c0dd9" translate="yes" xml:space="preserve">
          <source>This method isn't terribly useful since modules which share the same Test::Builder object might get exported to different packages and only the last one will be honored.</source>
          <target state="translated">这个方法并不是很有用,因为共享同一个Test::Builder对象的模块可能会被导出到不同的包中,只有最后一个才会被尊重。</target>
        </trans-unit>
        <trans-unit id="6554ac6945a5df20c377de63d8de44dbce743773" translate="yes" xml:space="preserve">
          <source>This method keyword is documented in &lt;a href=&quot;../perlobj#Destructors&quot;&gt;Destructors in perlobj&lt;/a&gt;.</source>
          <target state="translated">此方法关键字记录&lt;a href=&quot;../perlobj#Destructors&quot;&gt;在perlobj的Destructors中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e359554a4d991920df0d798d38cb8b6bf47ec29" translate="yes" xml:space="preserve">
          <source>This method keyword is documented in &lt;a href=&quot;perlobj#Destructors&quot;&gt;Destructors in perlobj&lt;/a&gt;.</source>
          <target state="translated">此方法关键字记录&lt;a href=&quot;perlobj#Destructors&quot;&gt;在perlobj的Destructors中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c21da25dd954f9e366c6cef85d1af33e75fddf8f" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests actually failed, regardless of whether or not a TODO directive was found.</source>
          <target state="translated">这个方法可以让你知道哪些(或多少)测试实际上是失败的,不管是否找到了TODO指令。</target>
        </trans-unit>
        <trans-unit id="a2b6c5d7eeef2dcb58cd2d68cdfe40caf21f8820" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests actually passed but were declared as &quot;TODO&quot; tests.</source>
          <target state="translated">这个方法可以让你知道哪些(或多少)测试实际通过了,但被声明为 &quot;TODO &quot;测试。</target>
        </trans-unit>
        <trans-unit id="08a5db262046c866f7d810a5b71d8ec989df7d80" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests actually passed, regardless of whether or not a TODO directive was found.</source>
          <target state="translated">这个方法可以让你知道哪些(或多少)测试实际通过了,不管是否找到了TODO指令。</target>
        </trans-unit>
        <trans-unit id="7562f7ac693aec459c0c9b344acb705680f1f7f7" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests failed. If a test passed but had a TODO directive, it will &lt;b&gt;NOT&lt;/b&gt; be counted as a failed test.</source>
          <target state="translated">此方法使您知道哪些（或多少）个测试失败。如果测试通过但具有TODO指令，则&lt;b&gt;不会&lt;/b&gt;被视为失败测试。</target>
        </trans-unit>
        <trans-unit id="b1956c9e443594eef5939e2522e06e528138f73a" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests had SKIP directives.</source>
          <target state="translated">这个方法可以让你知道哪些(或多少)测试有SKIP指令。</target>
        </trans-unit>
        <trans-unit id="d552dee0411d16f26c2347ec73027455bcd691a0" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests had TODO directives.</source>
          <target state="translated">这个方法可以让你知道哪些(或多少)测试有TODO指令。</target>
        </trans-unit>
        <trans-unit id="62d19246ed330e746e1fe150131f18c164bb14d2" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests passed. If a test failed but had a TODO directive, it will be counted as a passed test.</source>
          <target state="translated">这个方法让你知道哪些(或多少)测试通过了。如果一个测试失败了,但有TODO指令,它将被算作一个通过的测试。</target>
        </trans-unit>
        <trans-unit id="cc582265ee4f696fc9e8e3fad6147cf5023780c3" translate="yes" xml:space="preserve">
          <source>This method may be overridden by subclasses to take the appropriate action when a block of verbatim text is encountered. It is passed the following parameters:</source>
          <target state="translated">这个方法可以被子类重载,以便在遇到一块逐字文本时采取适当的行动。本方法的参数如下。</target>
        </trans-unit>
        <trans-unit id="2ef97fe79f3074bd51a79fd7f9a20c0d8326e891" translate="yes" xml:space="preserve">
          <source>This method may be overridden by subclasses to take the appropriate action when a normal block of POD text is encountered (although the base class method will usually do what you want). It is passed the following parameters:</source>
          <target state="translated">当遇到一个正常的POD文本块时,这个方法可以被子类重载,以采取适当的行动(尽管基类方法通常会做你想要的事情)。它被传递给以下参数。</target>
        </trans-unit>
        <trans-unit id="f193021bd1e2803e8135ddd336589fd3fdb1031b" translate="yes" xml:space="preserve">
          <source>This method merely runs the parser and parses all of the TAP.</source>
          <target state="translated">这个方法只是运行解析器并解析所有的TAP。</target>
        </trans-unit>
        <trans-unit id="d5b810a222612f34da5ba09951a3a157e593734d" translate="yes" xml:space="preserve">
          <source>This method only works on Perl v5.9.4 or later.</source>
          <target state="translated">这个方法只适用于Perl v5.9.4或更高版本。</target>
        </trans-unit>
        <trans-unit id="3eb04a70399efe3a3bc64926ce7a5f07e9940d0a" translate="yes" xml:space="preserve">
          <source>This method performs any necessary cleanup for the interior-sequence. If you override this method then it is &lt;b&gt;imperative&lt;/b&gt; that you invoke the parent method from within your own method, otherwise</source>
          <target state="translated">此方法对内部序列执行任何必要的清理。如果覆盖此方法，则&lt;b&gt;必须&lt;/b&gt;从自己的方法中调用父方法，否则</target>
        </trans-unit>
        <trans-unit id="714dcc55d92cf752f4b4184074298408c801245b" translate="yes" xml:space="preserve">
          <source>This method performs any necessary cleanup for the parse-tree. If you override this method then it is &lt;b&gt;imperative&lt;/b&gt; that you invoke the parent method from within your own method, otherwise</source>
          <target state="translated">此方法对解析树执行任何必要的清除。如果覆盖此方法，则&lt;b&gt;必须&lt;/b&gt;从自己的方法中调用父方法，否则</target>
        </trans-unit>
        <trans-unit id="094b13118759d86cdc1f33cdf2b7a72869820716" translate="yes" xml:space="preserve">
          <source>This method performs any necessary object initialization. It takes no arguments (other than the object instance of course, which is typically copied to a local variable named &lt;code&gt;$self&lt;/code&gt; ). If subclasses override this method then they</source>
          <target state="translated">此方法执行任何必要的对象初始化。它不带任何参数（当然不是对象实例，通常将其复制到名为 &lt;code&gt;$self&lt;/code&gt; 的局部变量中）。如果子类重写此方法，则它们</target>
        </trans-unit>
        <trans-unit id="1b4637e9cdcc1db5f14b9635de49858c878c102c" translate="yes" xml:space="preserve">
          <source>This method prepends the given text or parse-tree to the current parse-tree. If the first item on the parse-tree is text and the argument is also text, then the text is prepended to the first item (not added as a separate string). Otherwise the argument is added as a new string or parse-tree</source>
          <target state="translated">本方法将给定的文本或解析树预先加入到当前的解析树中。如果解析树上的第一项是文本,而参数也是文本,那么文本就会被预先添加到第一项中(而不是作为一个单独的字符串添加)。否则,参数将作为一个新的字符串或解析树被添加。</target>
        </trans-unit>
        <trans-unit id="843c78718fa264afa1695d6f64c3d712c49fd84a" translate="yes" xml:space="preserve">
          <source>This method prints the test as a string. It will probably be similar, but not necessarily identical, to the original test line. Directives are capitalized, some whitespace may be trimmed and a test number will be added if it was not present in the original line. If you need the original text of the test line, use the &lt;code&gt;raw&lt;/code&gt; method.</source>
          <target state="translated">此方法将测试打印为字符串。它可能与原始测试线相似，但不一定相同。指令使用大写字母，如果原始行中不存在测试编号，则可能会对其进行裁剪并添加测试编号。如果您需要测试行的原始文本，请使用 &lt;code&gt;raw&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="c461db5fa5d2d546751540785c1da918e27ef9ee" translate="yes" xml:space="preserve">
          <source>This method processes an XS file and sends output to a C file. The method may be called as a function (this is the legacy interface) and will then use a singleton as invocant.</source>
          <target state="translated">该方法处理XS文件并将输出发送到C文件。该方法可以作为函数调用(这是传统的接口),然后将使用一个单人作为 invocant。</target>
        </trans-unit>
        <trans-unit id="443a8a4abd0996a8f53eec3622235de842b5198f" translate="yes" xml:space="preserve">
          <source>This method reconstructs the encoding object if necessary. If you need to store the state during encoding, this is where you clone your object.</source>
          <target state="translated">如果需要的话,这个方法可以重建编码对象。如果你需要存储编码期间的状态,这就是你克隆对象的地方。</target>
        </trans-unit>
        <trans-unit id="4be2e04731b97866ee5b4ac0d1bde14c1df759bd" translate="yes" xml:space="preserve">
          <source>This method returns 0 if the object can be modified with the given operation, or 1 if not.</source>
          <target state="translated">如果对象可以通过给定的操作进行修改,则此方法返回0,如果不能,则返回1。</target>
        </trans-unit>
        <trans-unit id="3441f0af9f59d5dc45617aeb66969ab6a0963d73" translate="yes" xml:space="preserve">
          <source>This method returns TRUE if the GP field of the GV is NULL.</source>
          <target state="translated">如果GV的GP字段为NULL,本方法返回TRUE。</target>
        </trans-unit>
        <trans-unit id="d7b58df6d5a2c18121bb505720d0e804af99a7dd" translate="yes" xml:space="preserve">
          <source>This method returns a list of the currently active section headings and subheadings in the document being parsed. The list of headings returned corresponds to the most recently parsed paragraph of the input.</source>
          <target state="translated">此方法返回正在解析的文档中当前有效的章节标题和副标题列表。返回的标题列表对应于输入中最近解析的段落。</target>
        </trans-unit>
        <trans-unit id="dfd6da7f680f7708aaaafbe88d4fbd81537fbb12" translate="yes" xml:space="preserve">
          <source>This method returns either a hash reference (in scalar context) or a list or hash references (in array context) that contains information about each of the header fields in the compressed data stream(s).</source>
          <target state="translated">此方法返回一个哈希引用(在标量上下文中)或一个列表或哈希引用(在数组上下文中),其中包含压缩数据流中每个头字段的信息。</target>
        </trans-unit>
        <trans-unit id="5613e8d87481a66c6331ffba3f17e879703b23af" translate="yes" xml:space="preserve">
          <source>This method returns the &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; object associated with Your::Class. It is not a constructor so you can call it as often as you like.</source>
          <target state="translated">此方法返回与Your :: Class关联的&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;对象。它不是构造函数，因此您可以随意调用它。</target>
        </trans-unit>
        <trans-unit id="c6ed5af13a1529fb7b65c36511f205e560c0e629" translate="yes" xml:space="preserve">
          <source>This method returns the AV specific flags. In Perl 5.9 these are now stored in with the main SV flags, so this method is no longer present.</source>
          <target state="translated">这个方法返回 AV 的特定标志。在Perl 5.9中,这些标志现在和主SV标志一起存储,所以这个方法不再存在。</target>
        </trans-unit>
        <trans-unit id="230f2b0705cb9c1bd36492ae8437541d92944923" translate="yes" xml:space="preserve">
          <source>This method returns the byte offset of the start of the &lt;code&gt;$n&lt;/code&gt; th record in the file. If there is no such record, it returns an undefined value.</source>
          <target state="translated">此方法返回文件中第 &lt;code&gt;$n&lt;/code&gt; 个记录的开始的字节偏移量。如果没有这样的记录，它将返回一个未定义的值。</target>
        </trans-unit>
        <trans-unit id="cda1e7a80b8c4ff8a50d7193bfa7f2353fb0bb3a" translate="yes" xml:space="preserve">
          <source>This method returns the internal length field, which consists of the number of internal bytes, not necessarily the number of logical characters.</source>
          <target state="translated">本方法返回内部长度字段,该字段由内部字节数组成,不一定是逻辑字符数。</target>
        </trans-unit>
        <trans-unit id="3195470feffd08399489b4ea58a94cbd49fb15f2" translate="yes" xml:space="preserve">
          <source>This method returns the name of the glob, but if the first character of the name is a control character, then it converts it to ^X first, so that *^G would return &quot;^G&quot; rather than &quot;\cG&quot;.</source>
          <target state="translated">该方法返回glob的名称,但如果名称的第一个字符是控制字符,则先将其转换为^X,所以*^G将返回&quot;^G &quot;而不是&quot;\cG&quot;。</target>
        </trans-unit>
        <trans-unit id="d436f65e4ac4dfd0f8045b3c54271c25339bbf38" translate="yes" xml:space="preserve">
          <source>This method returns the name of the package that is the root of the compartment's namespace.</source>
          <target state="translated">这个方法返回的是作为隔间命名空间根的包的名称。</target>
        </trans-unit>
        <trans-unit id="b1039ff3465ca6dc27db9b5d11bc6e35d5848fc0" translate="yes" xml:space="preserve">
          <source>This method returns the number of [a certain kind of] errors encountered during processing of the XS file.</source>
          <target state="translated">本方法返回XS文件处理过程中遇到的[某种]错误数量。</target>
        </trans-unit>
        <trans-unit id="0d20c8d8462990e4c532228bf94cacc069885810" translate="yes" xml:space="preserve">
          <source>This method returns the number of bytes allocated (via malloc) for storing the string. This is 0 if the scalar does not &quot;own&quot; the string.</source>
          <target state="translated">本方法返回为存储字符串分配的字节数(通过malloc)。如果标量不 &quot;拥有 &quot;字符串,则返回0。</target>
        </trans-unit>
        <trans-unit id="dc49b5d5eff536554a52d021b3411834001a3a6e" translate="yes" xml:space="preserve">
          <source>This method returns the results of the parsing, one result at a time. Note that it is destructive. You can't rewind and examine previous results.</source>
          <target state="translated">这个方法每次只返回一个结果的解析结果。注意,它是破坏性的。你不能倒带和检查以前的结果。</target>
        </trans-unit>
        <trans-unit id="0ab9ad920897cda27f5f563bb7197ba468b33916" translate="yes" xml:space="preserve">
          <source>This method returns the textual representation of the hyperlink as above, but without markers (read only). Depending on the link type this is one of the following alternatives (the + and * denote the portions of the text that are marked up):</source>
          <target state="translated">此方法返回超链接的文本表示,如上所述,但没有标记(只读)。根据链接类型的不同,它是以下选项之一(+和*表示文本中被标记的部分)。</target>
        </trans-unit>
        <trans-unit id="59c2ab7b96065dfd63ce37b4f21c2d16dce7d68c" translate="yes" xml:space="preserve">
          <source>This method returns the value of the IV as an integer. It differs from &lt;code&gt;IV&lt;/code&gt; in that it returns the correct value regardless of whether it's stored signed or unsigned.</source>
          <target state="translated">此方法以整数形式返回IV的值。它与 &lt;code&gt;IV&lt;/code&gt; 的不同之处在于，无论存储的是带符号的还是无符号的，它都返回正确的值。</target>
        </trans-unit>
        <trans-unit id="1569bccb9cee6a2175f9b489178e6d0824ba382b" translate="yes" xml:space="preserve">
          <source>This method sets or returns the POD page this link points to.</source>
          <target state="translated">此方法设置或返回此链接指向的POD页面。</target>
        </trans-unit>
        <trans-unit id="5626475bc6df98d403b9b1a4c6d8bd8eead196ba" translate="yes" xml:space="preserve">
          <source>This method sets the size (in half-points, like 15 for 7.5-point) that the header on each page will appear in. The header is usually just &quot;</source>
          <target state="translated">这个方法可以设置每页页眉的大小(以半点为单位,比如7.5点的15点)。页眉通常只有&quot;</target>
        </trans-unit>
        <trans-unit id="49562bbb9cccfd05b2f9dd5f5c25626dc9296a99" translate="yes" xml:space="preserve">
          <source>This method sets the size (in half-points, like 21 for 10.5-point) that codeblocks (&quot;verbatim sections&quot;) will appear as.</source>
          <target state="translated">本方法设置代码块(&quot;逐字节&quot;)的大小(以半点为单位,如10.5点的21点)。</target>
        </trans-unit>
        <trans-unit id="b751a506f13c7e1535b7f83c798a478f8a346484" translate="yes" xml:space="preserve">
          <source>This method sets the size (in half-points, like 26 for 13-point) that normal paragraphic text will appear in.</source>
          <target state="translated">此方法设置正常段落文字的大小(以半点为单位,如26点为13点)。</target>
        </trans-unit>
        <trans-unit id="4a47dc314786b539ecdca5143ef23b8e1941b547" translate="yes" xml:space="preserve">
          <source>This method should</source>
          <target state="translated">此方法应</target>
        </trans-unit>
        <trans-unit id="a1c0bdcb0359edd01294194cece7860e3da71acb" translate="yes" xml:space="preserve">
          <source>This method should be overridden by subclasses that wish to perform any kind of preprocessing for each</source>
          <target state="translated">这个方法应该被希望对每个</target>
        </trans-unit>
        <trans-unit id="4045b5b845e6b96a3e7f9e9b3149fb374504376e" translate="yes" xml:space="preserve">
          <source>This method should be overridden by subclasses that wish to perform any kind of preprocessing for each block (paragraph) of POD documentation that appears in the input stream. The parameter &lt;code&gt;$text&lt;/code&gt; is the POD paragraph from the input file; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number for the beginning of the corresponding paragraph.</source>
          <target state="translated">希望对输入流中出现的POD文档的每个块（段）执行任何类型的预处理的子类都应重写此方法。参数 &lt;code&gt;$text&lt;/code&gt; 是输入文件中的POD段落；参数 &lt;code&gt;$line_num&lt;/code&gt; 是相应段落开头的行号。</target>
        </trans-unit>
        <trans-unit id="517b86d5501e13cc5ca0478526d9e56418238e3c" translate="yes" xml:space="preserve">
          <source>This method should be overridden by subclasses to take the appropriate action when a POD command paragraph (denoted by a line beginning with &quot;=&quot;) is encountered. When such a POD directive is seen in the input, this method is called and is passed:</source>
          <target state="translated">当遇到POD指令段(用&quot;=&quot;开头的行表示)时,子类应重载此方法,以采取相应的操作。当在输入中看到这样的POD指令时,就会调用本方法,并将其传递给。</target>
        </trans-unit>
        <trans-unit id="4057fa0aee2966d0f3fb518e4370c12ff228c00a" translate="yes" xml:space="preserve">
          <source>This method should be overridden by subclasses to take the appropriate action when an interior sequence is encountered. An interior sequence is an embedded command within a block of text which appears as a command name (usually a single uppercase character) followed immediately by a string of text which is enclosed in angle brackets. This method is passed the sequence command &lt;code&gt;$seq_cmd&lt;/code&gt; and the corresponding text &lt;code&gt;$seq_arg&lt;/code&gt; . It is invoked by the &lt;b&gt;interpolate()&lt;/b&gt; method for each interior sequence that occurs in the string that it is passed. It should return the desired text string to be used in place of the interior sequence. The &lt;code&gt;$pod_seq&lt;/code&gt; argument is a reference to a &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; object which contains further information about the interior sequence. Please see &lt;a href=&quot;inputobjects&quot;&gt;Pod::InputObjects&lt;/a&gt; for details if you need to access this additional information.</source>
          <target state="translated">遇到内部序列时，子类应重写此方法以采取适当的措施。内部序列是嵌入在文本块中的命令，该文本块显示为命令名称（通常是一个大写字符），紧随其后的是一串包含在尖括号中的文本字符串。该方法通过序列命令 &lt;code&gt;$seq_cmd&lt;/code&gt; 和相应的文本 &lt;code&gt;$seq_arg&lt;/code&gt; 。它由&lt;b&gt;interpolate（）&lt;/b&gt;方法为传递给它的字符串中出现的每个内部序列调用。它应返回所需的文本字符串以代替内部序列。在 &lt;code&gt;$pod_seq&lt;/code&gt; 参数是一个参考 &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; 包含有关内部序列的更多信息的对象。如果您需要访问此附加信息，请参见&lt;a href=&quot;inputobjects&quot;&gt;Pod :: InputObjects&lt;/a&gt;了解详细信息。</target>
        </trans-unit>
        <trans-unit id="429d3f42da5b40589bd5bfe3cdeaeea4b58f3cb7" translate="yes" xml:space="preserve">
          <source>This method takes a filename and does the following:</source>
          <target state="translated">本方法接收一个文件名,并执行以下操作。</target>
        </trans-unit>
        <trans-unit id="7d455696794a1091f3f69965ce8778b043cee526" translate="yes" xml:space="preserve">
          <source>This method takes an input filehandle (which is assumed to already be opened for reading) and reads the entire input stream looking for blocks (paragraphs) of POD documentation to be processed. If no first argument is given the default input filehandle &lt;code&gt;STDIN&lt;/code&gt; is used.</source>
          <target state="translated">此方法采用输入文件句柄（假定已经打开以进行读取），并读取整个输入流，以查找要处理的POD文档的块（段落）。如果没有给出第一个参数，则使用默认输入文件句柄 &lt;code&gt;STDIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d21cbfa9655bea409751abece40beb185c2a106" translate="yes" xml:space="preserve">
          <source>This method takes an optional parameter, &lt;code&gt;$flush_type&lt;/code&gt; , that controls how the flushing will be carried out. By default the &lt;code&gt;$flush_type&lt;/code&gt; used is &lt;code&gt;Z_FINISH&lt;/code&gt; . Other valid values for &lt;code&gt;$flush_type&lt;/code&gt; are &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; , &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; , &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; and &lt;code&gt;Z_BLOCK&lt;/code&gt; . It is strongly recommended that you only set the &lt;code&gt;flush_type&lt;/code&gt; parameter if you fully understand the implications of what it does - overuse of &lt;code&gt;flush&lt;/code&gt; can seriously degrade the level of compression achieved. See the &lt;code&gt;zlib&lt;/code&gt; documentation for details.</source>
          <target state="translated">此方法采用一个可选参数 &lt;code&gt;$flush_type&lt;/code&gt; ，该参数控制将如何执行刷新。默认情况下，使用的 &lt;code&gt;$flush_type&lt;/code&gt; 是 &lt;code&gt;Z_FINISH&lt;/code&gt; 。 &lt;code&gt;$flush_type&lt;/code&gt; 其他有效值是 &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; ， &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; ， &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; 和 &lt;code&gt;Z_BLOCK&lt;/code&gt; 。强烈建议您仅在完全了解其含义的情况下才设置 &lt;code&gt;flush_type&lt;/code&gt; 参数-过度使用 &lt;code&gt;flush&lt;/code&gt; 会严重降低所达到的压缩级别。有关详细信息，请参见 &lt;code&gt;zlib&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="9a36ff48f2f3559090075d4ecd3d184fea06bced" translate="yes" xml:space="preserve">
          <source>This method takes no arguments, it has the exact same effect as invoking &amp;lt;select()&amp;gt; with no arguments.</source>
          <target state="translated">此方法不带任何参数，与调用不带参数的&amp;lt;select（）&amp;gt;具有完全相同的效果。</target>
        </trans-unit>
        <trans-unit id="21a6dff8df6ddbca7896a9686976cc84571da4fe" translate="yes" xml:space="preserve">
          <source>This method translates all text (including any embedded interior sequences) in the given text string &lt;code&gt;$text&lt;/code&gt; and returns the interpolated result. The parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number corresponding to the beginning of &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">此方法转换给定文本字符串 &lt;code&gt;$text&lt;/code&gt; 中的所有文本（包括任何嵌入的内部序列），并返回插值结果。参数 &lt;code&gt;$line_num&lt;/code&gt; 是与 &lt;code&gt;$text&lt;/code&gt; 开头相对应的行号。</target>
        </trans-unit>
        <trans-unit id="d98885f1731321cbbe841c4174d52925fb86ae4c" translate="yes" xml:space="preserve">
          <source>This method turns an arbitrary string into a valid XHTML ID attribute value. The rules enforced, following &lt;a href=&quot;http://webdesign.about.com/od/htmltags/a/aa031707.htm&quot;&gt;http://webdesign.about.com/od/htmltags/a/aa031707.htm&lt;/a&gt;, are:</source>
          <target state="translated">此方法将任意字符串转换为有效的XHTML ID属性值。遵循&lt;a href=&quot;http://webdesign.about.com/od/htmltags/a/aa031707.htm&quot;&gt;http://webdesign.about.com/od/htmltags/a/aa031707.htm&lt;/a&gt;实施的规则是：</target>
        </trans-unit>
        <trans-unit id="5d3c6a2354f8ed5d57f49370abc6615f8bbe3512" translate="yes" xml:space="preserve">
          <source>This method used to be useful back when Test::Builder worked on Perls before 5.6 which didn't have qr//. Now its pretty useless.</source>
          <target state="translated">当Test::Builder在5.6之前的Perls上工作时,这个方法曾经很有用,因为5.6没有qr//。现在它已经没有用了。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
