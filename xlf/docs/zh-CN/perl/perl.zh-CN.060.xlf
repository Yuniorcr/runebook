<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d57dd39f43cd00fc9fcf08a3e6ef2330c6e56ff0" translate="yes" xml:space="preserve">
          <source>The following will determine the maximum length of the longest allowable pathname on the filesystem which holds &lt;code&gt;/var&lt;/code&gt;.</source>
          <target state="translated">下面将确定保存 &lt;code&gt;/var&lt;/code&gt; 的文件系统上允许的最长路径名的最大长度。</target>
        </trans-unit>
        <trans-unit id="5cbb13ad67db7840db7c7d12b58ddc55ef0ed900" translate="yes" xml:space="preserve">
          <source>The following will get the machine's clock speed.</source>
          <target state="translated">下面将得到机器的时钟速度。</target>
        </trans-unit>
        <trans-unit id="577c472e2dc0fc4d87aa88d05e48ae7e476e2971" translate="yes" xml:space="preserve">
          <source>The following will probably not do what you expect:</source>
          <target state="translated">下面的内容可能不会如你所愿。</target>
        </trans-unit>
        <trans-unit id="5c8bd82fe901dea332f23983ad9e29577c0fed4c" translate="yes" xml:space="preserve">
          <source>The following will probably not print what you expect:</source>
          <target state="translated">下面的内容可能不会像你期望的那样打印。</target>
        </trans-unit>
        <trans-unit id="119de64c9692dd9e013f0596370be8f29169b856" translate="yes" xml:space="preserve">
          <source>The following will query the current &lt;code&gt;LC_CTYPE&lt;/code&gt; category. (No second argument means 'query'.)</source>
          <target state="translated">下面将查询当前的 &lt;code&gt;LC_CTYPE&lt;/code&gt; 类别。（没有第二个参数表示&amp;ldquo;查询&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="5966453b4cde6268559966748dc7d8bf8fdd0ec2" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_COLLATE&lt;/code&gt; behaviour to Argentinian Spanish. &lt;b&gt;NOTE&lt;/b&gt;: The naming and availability of locales depends on your operating system. Please consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for how to find out which locales are available in your system.</source>
          <target state="translated">下面将把 &lt;code&gt;LC_COLLATE&lt;/code&gt; 行为设置为阿根廷西班牙语。&lt;b&gt;注意&lt;/b&gt;：语言环境的命名和可用性取决于您的操作系统。请咨询&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;以了解如何找出系统中可用的语言环境。</target>
        </trans-unit>
        <trans-unit id="5abcdbfe7d0b6ac6ed18a19f7b6cc537b1839b5d" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_CTYPE&lt;/code&gt; behaviour according to the locale environment variables (the second argument &lt;code&gt;&quot;&quot;&lt;/code&gt; ). Please see your system's &lt;code&gt;setlocale(3)&lt;/code&gt; documentation for the locale environment variables' meaning or consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">下面将根据语言环境环境变量（第二个参数 &lt;code&gt;&quot;&quot;&lt;/code&gt; ）设置 &lt;code&gt;LC_CTYPE&lt;/code&gt; 行为。请参阅系统的 &lt;code&gt;setlocale(3)&lt;/code&gt; 文档以了解语言环境环境变量的含义，或查阅&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="216ff7e1b32a193101b360016063f1dbe17b7ec9" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_CTYPE&lt;/code&gt; behaviour according to the locale environment variables (the second argument &lt;code&gt;&quot;&quot;&lt;/code&gt;). Please see your system's &lt;code&gt;setlocale(3)&lt;/code&gt; documentation for the locale environment variables' meaning or consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbd57a3195c4519fb09fab198f3facf1b32479f" translate="yes" xml:space="preserve">
          <source>The following will set the traditional UNIX system locale behavior (the second argument &lt;code&gt;&quot;C&quot;&lt;/code&gt; ).</source>
          <target state="translated">下面将设置传统的UNIX系统语言环境行为（第二个参数 &lt;code&gt;&quot;C&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9d989bfd17f8da94563bcb6ebfdcbf583a757e87" translate="yes" xml:space="preserve">
          <source>The following will set the traditional UNIX system locale behavior (the second argument &lt;code&gt;&quot;C&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d394598bfc021311cf0f2bb824273bc318b5797a" translate="yes" xml:space="preserve">
          <source>The following would first try to find Math::BigInt::Foo, then Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:</source>
          <target state="translated">下面会先尝试寻找Math::BigInt::Foo,然后再寻找Math::BigInt::Bar,当这也失败时,再回复到Math::BigInt::Calc。</target>
        </trans-unit>
        <trans-unit id="9ce20518f56534bcc1118c0bf986d78eef528c90" translate="yes" xml:space="preserve">
          <source>The following:</source>
          <target state="translated">以下是:</target>
        </trans-unit>
        <trans-unit id="678f5358c7187caa2da5eff48aaaa0b704fbae9c" translate="yes" xml:space="preserve">
          <source>The followings items are mostly for reference and general Unicode knowledge, Perl doesn't use these constructs internally.</source>
          <target state="translated">下面的内容主要是供参考和一般的Unicode知识,Perl内部并没有使用这些结构。</target>
        </trans-unit>
        <trans-unit id="0e4f79728d04ec0471d6bf96e407b112aa0cabf3" translate="yes" xml:space="preserve">
          <source>The foregoing mechanism for overriding built-in is restricted, quite deliberately, to the package that requests the import. There is a second method that is sometimes applicable when you wish to override a built-in everywhere, without regard to namespace boundaries. This is achieved by importing a sub into the special namespace &lt;code&gt;CORE::GLOBAL::&lt;/code&gt; . Here is an example that quite brazenly replaces the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator with something that understands regular expressions.</source>
          <target state="translated">覆盖内置的上述机制非常有意地限于请求导入的包。当您希望在任何地方覆盖内置而不考虑名称空间边界时，还有第二种方法有时适用。这是通过将子项导入特殊名称空间 &lt;code&gt;CORE::GLOBAL::&lt;/code&gt; 。这是一个用理解正则表达式的东西大胆地替换 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 运算符的示例。</target>
        </trans-unit>
        <trans-unit id="ef8b42b5ef636a805f830b90ca5398d8a3c613f1" translate="yes" xml:space="preserve">
          <source>The foregoing mechanism for overriding built-in is restricted, quite deliberately, to the package that requests the import. There is a second method that is sometimes applicable when you wish to override a built-in everywhere, without regard to namespace boundaries. This is achieved by importing a sub into the special namespace &lt;code&gt;CORE::GLOBAL::&lt;/code&gt;. Here is an example that quite brazenly replaces the &lt;code&gt;glob&lt;/code&gt; operator with something that understands regular expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85c90a6a43ec9e5bf7a5a11ec769ca8bd55e119" translate="yes" xml:space="preserve">
          <source>The fork() emulation is implemented at the level of the Perl interpreter. What this means in general is that running fork() will actually clone the running interpreter and all its state, and run the cloned interpreter in a separate thread, beginning execution in the new thread just after the point where the fork() was called in the parent. We will refer to the thread that implements this child &quot;process&quot; as the pseudo-process.</source>
          <target state="translated">fork()的仿真是在Perl解释器的层面上实现的。一般来说,这意味着运行fork()实际上会克隆正在运行的解释器和它的所有状态,并在一个单独的线程中运行克隆的解释器,在父线程中调用fork()的点之后开始在新线程中执行。我们将把实现这个子 &quot;进程 &quot;的线程称为伪进程。</target>
        </trans-unit>
        <trans-unit id="e04f09879ad602b86af95f9f6d5d371e6757eda4" translate="yes" xml:space="preserve">
          <source>The fork() emulation may not behave as expected when it is executed in an application which embeds a Perl interpreter and calls Perl APIs that can evaluate bits of Perl code. This stems from the fact that the emulation only has knowledge about the Perl interpreter's own data structures and knows nothing about the containing application's state. For example, any state carried on the application's own call stack is out of reach.</source>
          <target state="translated">fork()仿真在嵌入Perl解释器并调用Perl API的应用程序中执行时,可能不会像预期那样表现。这源于这样一个事实,即仿真只了解Perl解释器自身的数据结构,而对包含应用程序的状态一无所知。例如,应用程序自己的调用堆栈上携带的任何状态都是无法获取的。</target>
        </trans-unit>
        <trans-unit id="0708717756f902c5ff59069bd45289469d28d91c" translate="yes" xml:space="preserve">
          <source>The fork() emulation will not work entirely correctly when called from within a BEGIN block. The forked copy will run the contents of the BEGIN block, but will not continue parsing the source stream after the BEGIN block. For example, consider the following code:</source>
          <target state="translated">当从BEGIN块中调用fork()仿真时,它将不能完全正确地工作。fork()的副本将运行BEGIN块的内容,但不会在BEGIN块之后继续解析源流。例如,考虑以下代码。</target>
        </trans-unit>
        <trans-unit id="15be1c6ce9042f03bee94913baeb82a3ff565ee8" translate="yes" xml:space="preserve">
          <source>The fork() has to come before the setsid() to ensure you aren't a process group leader; the setsid() will fail if you are. If your system doesn't have the setsid() function, open</source>
          <target state="translated">fork()必须在setsid()之前出现,以确保你不是进程组组长;如果你是,setsid()就会失败。如果你的系统没有setsid()函数,打开</target>
        </trans-unit>
        <trans-unit id="9d31d094967d18a344cd7885a66ada91947ca8a3" translate="yes" xml:space="preserve">
          <source>The forked debugger requires the environment variable &lt;code&gt;TERM&lt;/code&gt; to be &lt;code&gt;xterm&lt;/code&gt; , and the environment variable &lt;code&gt;DISPLAY&lt;/code&gt; to exist. &lt;code&gt;xterm&lt;/code&gt; must be in lower case.</source>
          <target state="translated">分叉的调试器要求环境变量 &lt;code&gt;TERM&lt;/code&gt; 为 &lt;code&gt;xterm&lt;/code&gt; ，并且环境变量 &lt;code&gt;DISPLAY&lt;/code&gt; 存在。 &lt;code&gt;xterm&lt;/code&gt; 必须小写。</target>
        </trans-unit>
        <trans-unit id="80ddbda74fdf5f4c1a0f7f135f152cdae53aae97" translate="yes" xml:space="preserve">
          <source>The forked debugger requires the environment variable &lt;code&gt;TERM&lt;/code&gt; to be &lt;code&gt;xterm&lt;/code&gt;, and the environment variable &lt;code&gt;DISPLAY&lt;/code&gt; to exist. &lt;code&gt;xterm&lt;/code&gt; must be in lower case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a1b936aa7515813dbe100195592b08e94ebcb1" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;$x **= $y&lt;/code&gt; is faster than &lt;code&gt;$x = $x ** $y;&lt;/code&gt; , though.</source>
          <target state="translated">&lt;code&gt;$x **= $y&lt;/code&gt; 的形式比 &lt;code&gt;$x = $x ** $y;&lt;/code&gt; 的形式快；不过。</target>
        </trans-unit>
        <trans-unit id="6d60b9b98398cc175682fc83afb5cb2a3d960481" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;$x **= $y&lt;/code&gt; is faster than &lt;code&gt;$x = $x ** $y;&lt;/code&gt;, though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea29df8f31e738f8731934d29265ffb8df1b05f7" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt;, available in Perl 4, is no longer available. Replace any occurrence of &lt;code&gt;if BLOCK&lt;/code&gt; by &lt;code&gt;if (&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK)&lt;/code&gt; .</source>
          <target state="translated">Perl 4中可用的 &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt; 表格不再可用。更换出现的任何 &lt;code&gt;if BLOCK&lt;/code&gt; 的 &lt;code&gt;if (&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ab550c0e5d5dbe7a57264f4fc68930ea27ef872" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt;, available in Perl 4, is no longer available. Replace any occurrence of &lt;code&gt;if BLOCK&lt;/code&gt; by &lt;code&gt;if (do BLOCK)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d89d2ce75f6dd9a5b033644a202a3e0573863e" translate="yes" xml:space="preserve">
          <source>The formal syntax of a section specification is:</source>
          <target state="translated">剖面规范的形式语法是。</target>
        </trans-unit>
        <trans-unit id="feafac52c2f0bb1c62c34d80f1ccae00a8b7bff5" translate="yes" xml:space="preserve">
          <source>The format is roughly the same as a header section except for the fallback flag: | followed by 0..3. The meaning of the possible values is as follows:</source>
          <target state="translated">除了回退标志外,格式与头部分大致相同。| 后面是0...3。可能的值的含义如下。</target>
        </trans-unit>
        <trans-unit id="7de51818a43a9eeabc5f149d791bcd953969e5ec" translate="yes" xml:space="preserve">
          <source>The format is the same as PREREQ_PM.</source>
          <target state="translated">格式与PREREQ_PM相同。</target>
        </trans-unit>
        <trans-unit id="4a91025674068746c104cf678dff09a87e09a62d" translate="yes" xml:space="preserve">
          <source>The format is:</source>
          <target state="translated">其格式为:</target>
        </trans-unit>
        <trans-unit id="cab7930ea8f9bb0b5e8551406e705f9d6d55872a" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 的构造函数的格式如下所示</target>
        </trans-unit>
        <trans-unit id="2b7f4c6f10c021d585a52efc7c38f1f01339227d" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 的构造函数格式如下所示</target>
        </trans-unit>
        <trans-unit id="e03dc6c86b8958f9b62ec7a6a483ad0e4753decb" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 的构造函数格式如下所示</target>
        </trans-unit>
        <trans-unit id="2cd916282c4e6b36ecc3a6af27b028bb638d27b9" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 的构造函数的格式如下所示</target>
        </trans-unit>
        <trans-unit id="96cf103266184d2ab7c512526262f24222f5b3fa" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Zip&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Zip&lt;/code&gt; 的构造函数格式如下所示</target>
        </trans-unit>
        <trans-unit id="7cddd4e7224584228dd40d8278ce06df26d30be6" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::AnyInflate is shown below</source>
          <target state="translated">IO::Uncompress::AnyInflate的构造函数的格式如下所示。</target>
        </trans-unit>
        <trans-unit id="f335334476f7fdad7a158077eda96d1e77d620ba" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::AnyUncompress is shown below</source>
          <target state="translated">IO::Uncompress::AnyUncompress的构造函数的格式如下所示。</target>
        </trans-unit>
        <trans-unit id="d8f9f10c69da3c0a902ce3d0bf3a43a4fe3d0d99" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Bunzip2 is shown below</source>
          <target state="translated">IO::Uncompress::Bunzip2的构造函数的格式如下所示。</target>
        </trans-unit>
        <trans-unit id="1aee64e705754fe9513f8b1c5a275541fbf25126" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Gunzip is shown below</source>
          <target state="translated">IO::Uncompress::Gunzip的构造函数的格式如下所示。</target>
        </trans-unit>
        <trans-unit id="e0479ea0c00c6dbc0391fab896f56792a7f58abf" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Inflate is shown below</source>
          <target state="translated">IO::Uncompress::Inflate的构造函数的格式如下所示。</target>
        </trans-unit>
        <trans-unit id="abbcd988c20a7a7af1b1b62b62f212c0f098a642" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::RawInflate is shown below</source>
          <target state="translated">IO::Uncompress::RawInflate的构造函数的格式如下所示。</target>
        </trans-unit>
        <trans-unit id="266217c42524ecb82328e7bc0e8f8cf67f30e119" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Unzip is shown below</source>
          <target state="translated">IO::Uncompress::Unzip的构造函数的格式如下所示。</target>
        </trans-unit>
        <trans-unit id="6ce17f5dc7d5e6006e0ab81d86bb016be0d29f0f" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;#gmtime&quot;&gt;gmtime&lt;/a&gt; builtin. See also the &lt;code&gt;Time::Local&lt;/code&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by time()), and the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's strftime(3) and mktime(3) functions.</source>
          <target state="translated">该标量值的格式与语言环境&lt;b&gt;无关，&lt;/b&gt;而是内置于Perl中。对于GMT而非本地时间，请使用内置的&lt;a href=&quot;#gmtime&quot;&gt;gmtime&lt;/a&gt;。另请参见 &lt;code&gt;Time::Local&lt;/code&gt; 模块（用于将秒，分钟，小时等转换回time（）返回的整数值），以及&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块的strftime（3）和mktime（3）函数。</target>
        </trans-unit>
        <trans-unit id="2c7d4e187b4ee40d7ac4cdd3dd9c17ff06ab82de" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;#gmtime-EXPR&quot;&gt;&lt;code&gt;gmtime&lt;/code&gt;&lt;/a&gt; builtin. See also the &lt;a href=&quot;Time::Local&quot;&gt;&lt;code&gt;Time::Local&lt;/code&gt;&lt;/a&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by &lt;a href=&quot;#time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;), and the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's &lt;a href=&quot;posix#strftime&quot;&gt;&lt;code&gt;strftime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;posix#mktime&quot;&gt;&lt;code&gt;mktime&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2da41af1cf680b6887d63dd253c6e01471391c6" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;gmtime&quot;&gt;gmtime&lt;/a&gt; builtin. See also the &lt;code&gt;Time::Local&lt;/code&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by time()), and the &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; module's strftime(3) and mktime(3) functions.</source>
          <target state="translated">该标量值的格式与语言环境&lt;b&gt;无关，&lt;/b&gt;而是内置于Perl中。对于GMT而非本地时间，请使用内置的&lt;a href=&quot;gmtime&quot;&gt;gmtime&lt;/a&gt;。另请参见 &lt;code&gt;Time::Local&lt;/code&gt; 模块（用于将秒，分钟，小时等转换回time（）返回的整数值），以及&lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;模块的strftime（3）和mktime（3）函数。</target>
        </trans-unit>
        <trans-unit id="7fb9dcbdf87a920318a01eb480379e8f7c7c3de2" translate="yes" xml:space="preserve">
          <source>The format specifier detection is not complete printf-syntax detection, but it should catch most common cases.</source>
          <target state="translated">格式指定符检测并不是完整的printf-syntax检测,但它应该能抓住大多数常见的情况。</target>
        </trans-unit>
        <trans-unit id="256ecd9d04a27fc1ec23dd2c77863e67bcf5ad16" translate="yes" xml:space="preserve">
          <source>The formats supported are</source>
          <target state="translated">支持的格式有</target>
        </trans-unit>
        <trans-unit id="0577a9efbbb4297e7d5cf847fb8e2a9cc4cdfef4" translate="yes" xml:space="preserve">
          <source>The formats supported are:</source>
          <target state="translated">支持的格式有:</target>
        </trans-unit>
        <trans-unit id="f7762b6266ff516b0fab73ac7af6d025adc1f538" translate="yes" xml:space="preserve">
          <source>The formats that can convert characters to numbers and vice versa will be different from their ASCII counterparts when executed on an EBCDIC platform. Examples include:</source>
          <target state="translated">当在EBCDIC平台上执行时,可以将字符转换为数字,反之亦然的格式将与ASCII对应的格式不同。例子包括:</target>
        </trans-unit>
        <trans-unit id="5f27c48c4d04704c74b0b5d7d716d5ed43b40c07" translate="yes" xml:space="preserve">
          <source>The former default in which Perl would always use a loose interpretation of UTF-8 has now been overruled:</source>
          <target state="translated">以前的默认情况下,Perl 总是使用对 UTF-8 的宽松解释,现在已经被推翻了。</target>
        </trans-unit>
        <trans-unit id="bacc21ee4934a43e7cffae5409abb3139d8d7444" translate="yes" xml:space="preserve">
          <source>The former is defined to imply Unicode handling; and the latter indicates a Unicode locale, hence a Unicode interpretation of all strings within it.</source>
          <target state="translated">前者被定义为意味着Unicode处理;而后者则表示Unicode区域,因此对其中的所有字符串进行Unicode解释。</target>
        </trans-unit>
        <trans-unit id="abc8578e218b1958e7644bd43d9d008d1386b618" translate="yes" xml:space="preserve">
          <source>The formerly undocumented STRICT argument sets strictness: if true 'use strict;' is used, otherwise it uses 'no strict;'. &lt;b&gt;Note&lt;/b&gt;: if STRICT is omitted 'no strict;' is the default.</source>
          <target state="translated">以前未记录的STRICT参数设置了严格性：如果为真，则&amp;ldquo;使用严格&amp;rdquo;；使用，否则使用&amp;ldquo;不严格&amp;rdquo;。&lt;b&gt;注意&lt;/b&gt;：如果忽略STRICT，则表示&amp;ldquo;不严格&amp;rdquo;；是默认值。</target>
        </trans-unit>
        <trans-unit id="18a3596eca3e6e803312bc68b427ff1f1eeb325a" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;(?'&lt;i&gt;NAME&lt;/i&gt;'&lt;i&gt;pattern&lt;/i&gt;)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;&lt;i&gt;NAME&lt;/i&gt;&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)&lt;/code&gt; are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c48d78ca541fb734f8a681b44e6478f12be1be" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;(?'NAME'pattern)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt; are equivalent.</source>
          <target state="translated">形式 &lt;code&gt;(?'NAME'pattern)&lt;/code&gt; 和 &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt; 形式是等效的。</target>
        </trans-unit>
        <trans-unit id="3165776bcfd76f28e0c24205090accd64be6f1e3" translate="yes" xml:space="preserve">
          <source>The formula is from the Red Dragon book (reformulated to use the data available) and is documented at &lt;a href=&quot;http://www.strchr.com/hash_functions&quot;&gt;http://www.strchr.com/hash_functions&lt;/a&gt;</source>
          <target state="translated">该公式来自《红龙》（Red Dragon）书（使用现有数据进行了调整），并记录在&lt;a href=&quot;http://www.strchr.com/hash_functions&quot;&gt;http://www.strchr.com/hash_functions中&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea332d524efecd12f52e313e0715e604daa7345f" translate="yes" xml:space="preserve">
          <source>The four &lt;code&gt;CPAN::*&lt;/code&gt; Classes: Author, Bundle, Module, Distribution</source>
          <target state="translated">四个 &lt;code&gt;CPAN::*&lt;/code&gt; 类：作者，捆绑包，模块，分发</target>
        </trans-unit>
        <trans-unit id="4ebe0eef114ce361363114266a5b30d9fc215c2f" translate="yes" xml:space="preserve">
          <source>The four &lt;code&gt;filter_*&lt;/code&gt; methods shown above are available in all the DBM modules that ship with Perl, namely DB_File, GDBM_File, NDBM_File, ODBM_File and SDBM_File.</source>
          <target state="translated">Perl附带的所有DBM模块中都提供了上面显示的四个 &lt;code&gt;filter_*&lt;/code&gt; 方法，即DB_File，GDBM_File，NDBM_File，ODBM_File和SDBM_File。</target>
        </trans-unit>
        <trans-unit id="a87cd62b5e4a547576560e5204e87547d60f9cfe" translate="yes" xml:space="preserve">
          <source>The four CPAN::* Classes: Author, Bundle, Module, Distribution</source>
          <target state="translated">四个CPAN::*类。作者、捆绑包、模块、分发</target>
        </trans-unit>
        <trans-unit id="fe1fb546f60704c6d1d156b3f6fadf776528094a" translate="yes" xml:space="preserve">
          <source>The four element types -- scalar, array, hash, and class -- are represented by strings -- &lt;code&gt;'$'&lt;/code&gt; , &lt;code&gt;'@'&lt;/code&gt; , &lt;code&gt;'%'&lt;/code&gt; , and a class name -- optionally preceded by a &lt;code&gt;'*'&lt;/code&gt; .</source>
          <target state="translated">四个元素类型-标量，数组，哈希和类-用字符串表示- &lt;code&gt;'$'&lt;/code&gt; ， &lt;code&gt;'@'&lt;/code&gt; ， &lt;code&gt;'%'&lt;/code&gt; 和类名称-可选地以 &lt;code&gt;'*'&lt;/code&gt; 开头。</target>
        </trans-unit>
        <trans-unit id="92b64884f8f61e4bda03f0b1b810258bc7d0365f" translate="yes" xml:space="preserve">
          <source>The four element types -- scalar, array, hash, and class -- are represented by strings -- &lt;code&gt;'$'&lt;/code&gt;, &lt;code&gt;'@'&lt;/code&gt;, &lt;code&gt;'%'&lt;/code&gt;, and a class name -- optionally preceded by a &lt;code&gt;'*'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010d48814dc6637936a58a714f4a5b8ac2c0e5b8" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is 0.</source>
          <target state="translated">为此格式返回的列表中的第四个（索引[3]）元素（ &lt;code&gt;$default&lt;/code&gt; ）为0。</target>
        </trans-unit>
        <trans-unit id="2e817fac52edc4c5e0caee985a6afb86c7862868" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; .</source>
          <target state="translated">为此格式返回的列表中的第四个（索引[3]）元素（ &lt;code&gt;$default&lt;/code&gt; ）是 &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d015fffd23c241225267b70dd79dfdb0ced38265" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is the empty string.</source>
          <target state="translated">为此格式返回的列表中的第四个元素（索引[3]）（ &lt;code&gt;$default&lt;/code&gt; ）是空字符串。</target>
        </trans-unit>
        <trans-unit id="dbf8c5de03271df9c0ea8fd5c41bcc753a3e2e78" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt;) in the list returned for this format is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a31746958b0c54f45a9490ade3495335e57ef5" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt;) in the list returned for this format is &lt;code&gt;&quot;NaN&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ce6cb48f2a76c182227b4de66778e078fb3c5c" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt;) in the list returned for this format is the empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee5dc54dca610abdb335a6016c33fad310b745e" translate="yes" xml:space="preserve">
          <source>The fourth argument,</source>
          <target state="translated">第四种说法。</target>
        </trans-unit>
        <trans-unit id="d46f45156438266dbc454cfdd5c8500aa9cf2dd2" translate="yes" xml:space="preserve">
          <source>The fourth operation is the same as the logical not of the third operation and is specified the same way as the third with the addition of a caret character &lt;code&gt;^&lt;/code&gt; at the beginning of the test string just inside the open square bracket.</source>
          <target state="translated">第四项操作与第三项操作的逻辑非相同，并以与第三项操作相同的方式指定，只是在方括号内的测试字符串开头添加了插入符号 &lt;code&gt;^&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc43b69f9d12ff24c27cb6addf7ed86730581d51" translate="yes" xml:space="preserve">
          <source>The fourth through ninth highest priorities are to look in the corresponding grandparent, great-grandparent and great-great-grandparent directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517bbe0d839ce687e5bde7b590dd68865b524c37" translate="yes" xml:space="preserve">
          <source>The friends locked into &lt;code&gt;M$&lt;/code&gt; world would appreciate the fact that this executable runs under DOS, Win0.3*, Win0.95 and WinNT with an appropriate extender. See &lt;a href=&quot;#Other-OSes&quot;&gt;&quot;Other OSes&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67d6a9240f3ec0e157e3e0a648b8e35a0a7ab23" translate="yes" xml:space="preserve">
          <source>The friends locked into &lt;code&gt;M$&lt;/code&gt; world would appreciate the fact that this executable runs under DOS, Win0.3*, Win0.95 and WinNT with an appropriate extender. See &lt;a href=&quot;#Other-OSes&quot;&gt;Other OSes&lt;/a&gt;.</source>
          <target state="translated">锁定在 &lt;code&gt;M$&lt;/code&gt; 世界中的朋友可能会喜欢这个可执行文件在DOS，Win0.3 *，Win0.95和WinNT以及适当的扩展程序下运行的事实。请参阅&lt;a href=&quot;#Other-OSes&quot;&gt;其他操作系统&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="043867751e64107d60b95a69e8badcc29251fb84" translate="yes" xml:space="preserve">
          <source>The full circle is 2</source>
          <target state="translated">全圆是2</target>
        </trans-unit>
        <trans-unit id="d29a10ef910506015d780ee21ef968e5b95cf038" translate="yes" xml:space="preserve">
          <source>The full definition for this field is given in the &lt;a href=&quot;#Prereq-Spec&quot;&gt;&quot;Prereq Spec&quot;&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37765aa0855e93aba1c1cfea3d54b9c2c469bca1" translate="yes" xml:space="preserve">
          <source>The full documentation for &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; provides a thorough reference to this function, beyond the best-practice basics covered here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66fe9d715897deb9cd4770d030e58e58ff7af5a" translate="yes" xml:space="preserve">
          <source>The full list of alternatives is:</source>
          <target state="translated">替代品的完整清单是:</target>
        </trans-unit>
        <trans-unit id="e2b044fa3549d52ee2f4f118ecc7f64b424bcc29" translate="yes" xml:space="preserve">
          <source>The full set of contributors always includes the folks mentioned in &lt;a href=&quot;IO::Stringy#CHANGE-LOG&quot;&gt;&quot;CHANGE LOG&quot; in IO::Stringy&lt;/a&gt;. But just the same, special thanks to the following individuals for their invaluable contributions (if I've forgotten or misspelled your name, please email me!):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baccc1ffc22a33efb39b1687159250f28dc423fa" translate="yes" xml:space="preserve">
          <source>The full text of the license can be found in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a153a5f23194fa493b49953e70a37ba58abfd1" translate="yes" xml:space="preserve">
          <source>The full text of the license can be found in the LICENSE file included with this module.</source>
          <target state="translated">许可证的全文可以在本模块包含的LICENSE文件中找到。</target>
        </trans-unit>
        <trans-unit id="c54557502ca6f64ebd0cff3c9dbc11ca01487c1f" translate="yes" xml:space="preserve">
          <source>The full version number of this package, such as 5.6.1 (or 5_6_1). This combines revision, patchlevel, and subversion to get the full version number, including any possible subversions. This is suitable for use as a directory name, and hence is filesystem dependent.</source>
          <target state="translated">这个软件包的完整版本号,比如 5.6.1 (或 5_6_1)。这结合了修订版、补丁级别和subversion来获得完整的版本号,包括任何可能的subversion。这适合作为目录名使用,因此是依赖于文件系统的。</target>
        </trans-unit>
        <trans-unit id="5bc944c87864f3d28f9f02ec1b783a4a9aacca33" translate="yes" xml:space="preserve">
          <source>The fully qualified method name that was called is available in the &lt;code&gt;$AUTOLOAD&lt;/code&gt; package global for your class. Since this is a global, if you want to refer to do it without a package name prefix under &lt;code&gt;strict
'vars'&lt;/code&gt; , you need to declare it.</source>
          <target state="translated">在类的全局 &lt;code&gt;$AUTOLOAD&lt;/code&gt; 包中提供了被调用的标准方法名称。由于这是全局的，因此如果要在 &lt;code&gt;strict 'vars'&lt;/code&gt; 下引用而没有包名前缀的方法，则需要声明它。</target>
        </trans-unit>
        <trans-unit id="46868bf85da4047d1fd48569f16bb118135bfc66" translate="yes" xml:space="preserve">
          <source>The fully qualified method name that was called is available in the &lt;code&gt;$AUTOLOAD&lt;/code&gt; package global for your class. Since this is a global, if you want to refer to do it without a package name prefix under &lt;code&gt;strict 'vars'&lt;/code&gt;, you need to declare it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c7ff8a6b152356b1c3b87a4fa36cf4002b4367" translate="yes" xml:space="preserve">
          <source>The function</source>
          <target state="translated">职能</target>
        </trans-unit>
        <trans-unit id="d66346d1633c0f93998400fd3d2d89ef6dd2f1f1" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;utf8#Utility-functions&quot;&gt;&lt;code&gt;utf8::utf8_upgrade()&lt;/code&gt;&lt;/a&gt; can be explicitly used to permanently (unless a subsequent &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; is called) cause a string to be treated as Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1263ec90688607ca3bc3ec7bfb0fe38e6efd4c6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::utf8_upgrade() &lt;/a&gt; can be explicitly used to permanently (unless a subsequent &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; is called) cause a string to be treated as Unicode.</source>
          <target state="translated">函数&lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: utf8_upgrade（）&lt;/a&gt;可以显式地永久使用（除非随后的 &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; 被调用）导致将字符串视为Unicode。</target>
        </trans-unit>
        <trans-unit id="0110ffd54f081ff34d7394303d2f5fa900a42f45" translate="yes" xml:space="preserve">
          <source>The function &lt;b&gt;pod_find&lt;/b&gt; searches for POD documents in a given set of files and/or directories. It returns a hash with the file names as keys and the POD name as value. The POD name is derived from the file name and its position in the directory tree.</source>
          <target state="translated">函数&lt;b&gt;pod_find&lt;/b&gt;在给定的文件和/或目录&lt;b&gt;集中&lt;/b&gt;搜索POD文档。它返回一个哈希，文件名作为键，POD名称作为值。POD名称是从文件名及其在目录树中的位置得出的。</target>
        </trans-unit>
        <trans-unit id="48cfcd3ef7cb24df407c69f7ab8cfb221b006395" translate="yes" xml:space="preserve">
          <source>The function &lt;b&gt;simplify_name&lt;/b&gt; is equivalent to &lt;b&gt;basename&lt;/b&gt;, but also strips Perl-like extensions (.pm, .pl, .pod) and extensions like</source>
          <target state="translated">功能&lt;b&gt;simplify_name&lt;/b&gt;相当于&lt;b&gt;基名&lt;/b&gt;，而且剥离的Perl状延伸（.pm后缀，特等，.POD）和扩展等</target>
        </trans-unit>
        <trans-unit id="977e84004739e29fbaa341106fb1e524db41e10d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; has been deprecated, so code has been included to display a warning message whenever the calling module has (at least) the &quot;deprecated&quot; warnings category enabled. Something like this, say.</source>
          <target state="translated">该函数 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 已被弃用，因此只要调用模块启用（至少）启用了&amp;ldquo; deprecated&amp;rdquo;警告类别，便已包含用于显示警告消息的代码。像这样的事情。</target>
        </trans-unit>
        <trans-unit id="509f0d861d7a99d6a484f51f2a9188a5713a5b35" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;filter_read&lt;/code&gt; takes two forms:</source>
          <target state="translated">函数 &lt;code&gt;filter_read&lt;/code&gt; 采取两种形式：</target>
        </trans-unit>
        <trans-unit id="5c27f77e8d833b52d6b699513cb75e12cfb41e38" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;hostname()&lt;/code&gt; in the &lt;a href=&quot;Sys::Hostname&quot;&gt;Sys::Hostname&lt;/a&gt; module has always been documented to be called with no arguments. Historically it has not enforced this, and has actually accepted and ignored any arguments. As a result, some users have got the mistaken impression that an argument does something useful. To avoid these bugs, the function is being made strict. Passing arguments was deprecated in Perl 5.28 and became fatal in Perl 5.32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2b0d9ecb1c14fb1e59a3fd0192de217a46316b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;open&lt;/code&gt; has been deprecated, so code has been included to display a warning message whenever the calling module has (at least) the &quot;deprecated&quot; warnings category enabled. Something like this, say.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd4d38aee306d70f6097ade577ca383b52839ef" translate="yes" xml:space="preserve">
          <source>The function I18N::LangTags::List::name(...) is not exported.</source>
          <target state="translated">I18N::LangTags::List::name(...)函数没有导出。</target>
        </trans-unit>
        <trans-unit id="5583893e9ddd698662f18f40b85c6a69394dd032" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be created. Its behaviour may be tuned by an optional hashref appearing as the last parameter on the call.</source>
          <target state="translated">该函数接受一个要创建的目录列表。它的行为可以通过调用时最后一个参数中出现的可选的hashref来调整。</target>
        </trans-unit>
        <trans-unit id="1ccfd3fbf49c44a49b4970d5b4592c2961b06827" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be removed. (In point of fact, it will also accept filesystem entries which are not directories, such as regular files and symlinks. But, as its name suggests, its intent is to remove trees rather than individual files.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c25ffe36bf18f7f44be765fa3c82188ddbc3925" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be removed. Its behaviour may be tuned by an optional hashref appearing as the last parameter on the call.</source>
          <target state="translated">该函数接受一个要删除的目录列表。它的行为可以通过调用时最后一个参数中出现的可选的hashref来调整。</target>
        </trans-unit>
        <trans-unit id="3ef41ec1c0dbf85f3bcd0cef90f173dc6b18dec6" translate="yes" xml:space="preserve">
          <source>The function call &lt;code&gt;shell&lt;/code&gt; takes two optional arguments: one the prompt, the second the default initial command line (the latter only works if a real ReadLine interface module is installed).</source>
          <target state="translated">函数调用 &lt;code&gt;shell&lt;/code&gt; 程序带有两个可选参数：一个是提示，第二个是默认的初始命令行（仅当安装了真正的ReadLine接口模块时，后者才起作用）。</target>
        </trans-unit>
        <trans-unit id="f64674aceb9b0908fa74a739ca7fbade2ac2ee6e" translate="yes" xml:space="preserve">
          <source>The function declaration must be visible at compile time. The prototype affects only interpretation of new-style calls to the function, where new-style is defined as not using the &lt;code&gt;&amp;amp;&lt;/code&gt; character. In other words, if you call it like a built-in function, then it behaves like a built-in function. If you call it like an old-fashioned subroutine, then it behaves like an old-fashioned subroutine. It naturally falls out from this rule that prototypes have no influence on subroutine references like &lt;code&gt;\&amp;amp;foo&lt;/code&gt; or on indirect subroutine calls like &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; or &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt; .</source>
          <target state="translated">函数声明必须在编译时可见。该原型仅影响对该函数的新样式调用的解释，其中新样式定义为不使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 字符。换句话说，如果您像内置函数一样调用它，那么它的行为就像内置函数一样。如果您将其称为老式子例程，则其行为类似于老式子例程。从这个规则自然得出结论，原型对子程序引用（如 &lt;code&gt;\&amp;amp;foo&lt;/code&gt; )或间接子程序调用（如 &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; 或 &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a54076d47c791003b92c3959d64c01e6039e0bd6" translate="yes" xml:space="preserve">
          <source>The function declaration must be visible at compile time. The prototype affects only interpretation of new-style calls to the function, where new-style is defined as not using the &lt;code&gt;&amp;amp;&lt;/code&gt; character. In other words, if you call it like a built-in function, then it behaves like a built-in function. If you call it like an old-fashioned subroutine, then it behaves like an old-fashioned subroutine. It naturally falls out from this rule that prototypes have no influence on subroutine references like &lt;code&gt;\&amp;amp;foo&lt;/code&gt; or on indirect subroutine calls like &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; or &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a4f089237c0dd0b61fdd70575a337b465e2308" translate="yes" xml:space="preserve">
          <source>The function extracts the entry of the specified terminal type</source>
          <target state="translated">该函数提取指定终端类型的条目。</target>
        </trans-unit>
        <trans-unit id="dbacf36c4d8a578101fa6d12242c4841f7204b60" translate="yes" xml:space="preserve">
          <source>The function interface uses attribute strings to describe the colors and text attributes to assign to text. The recognized non-color attributes are clear, reset, bold, dark, faint, italic, underline, underscore, blink, reverse, and concealed. Clear and reset (reset to default attributes), dark and faint (dim and saturated), and underline and underscore are equivalent, so use whichever is the most intuitive to you.</source>
          <target state="translated">功能界面使用属性字符串来描述要分配给文本的颜色和文本属性。识别的非颜色属性有清晰、复位、粗体、暗淡、斜体、下划线、下划线、闪烁、反向和隐藏。清晰和重置(重置为默认属性)、深色和淡色(昏暗和饱和)、下划线和下划线是等价的,所以使用对你来说最直观的那一种。</target>
        </trans-unit>
        <trans-unit id="6f3bb6ac191764523c9d934c739e063f3ecbe7de" translate="yes" xml:space="preserve">
          <source>The function is called from the tokeniser, whenever a possible keyword is seen. &lt;code&gt;keyword_ptr&lt;/code&gt; points at the word in the parser's input buffer, and &lt;code&gt;keyword_len&lt;/code&gt; gives its length; it is not null-terminated. The function is expected to examine the word, and possibly other state such as &lt;a href=&quot;perlvar#%25%5EH&quot;&gt;%^H&lt;/a&gt;, to decide whether it wants to handle it as an extended keyword. If it does not, the function should return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt;, and the normal parser process will continue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55694c97e9ceb329d9698a51681bd4944db4ba6e" translate="yes" xml:space="preserve">
          <source>The function is called from the tokeniser, whenever a possible keyword is seen. &lt;code&gt;keyword_ptr&lt;/code&gt; points at the word in the parser's input buffer, and &lt;code&gt;keyword_len&lt;/code&gt; gives its length; it is not null-terminated. The function is expected to examine the word, and possibly other state such as &lt;a href=&quot;perlvar#%25%5eH&quot;&gt;%^H&lt;/a&gt;, to decide whether it wants to handle it as an extended keyword. If it does not, the function should return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; , and the normal parser process will continue.</source>
          <target state="translated">只要看到可能的关键字，就会从令牌处理程序中调用该函数。 &lt;code&gt;keyword_ptr&lt;/code&gt; 指向解析器输入缓冲区中的单词，而 &lt;code&gt;keyword_len&lt;/code&gt; 给出其长度；它不是以Null结尾的。该函数应检查该单词以及可能的其他状态，例如&lt;a href=&quot;perlvar#%25%5eH&quot;&gt;％^ H&lt;/a&gt;，以决定是否要将该单词作为扩展关键字来处理。如果没有，函数应返回 &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; ，正常的解析器过程将继续。</target>
        </trans-unit>
        <trans-unit id="9306c5da74b3095d5bd155bcdf129a71eee56339" translate="yes" xml:space="preserve">
          <source>The function looks in the symbol table of &lt;code&gt;$package&lt;/code&gt; for the typeglob for &lt;code&gt;$referent&lt;/code&gt; , which is a reference to a variable or subroutine (SCALAR, ARRAY, HASH, or CODE). If it finds the typeglob, it returns it. Otherwise, it returns undef. Note that &lt;code&gt;findsym&lt;/code&gt; memoizes the typeglobs it has previously successfully found, so subsequent calls with the same arguments should be much faster.</source>
          <target state="translated">该函数在 &lt;code&gt;$package&lt;/code&gt; 的符号表中查找 &lt;code&gt;$referent&lt;/code&gt; 的typeglob ，这是对变量或子例程（SCALAR，ARRAY，HASH或CODE）的引用。如果找到typeglob，则将其返回。否则，它返回undef。请注意， &lt;code&gt;findsym&lt;/code&gt; 会记住它先前已成功找到的typeglob，因此，使用相同参数的后续调用应快得多。</target>
        </trans-unit>
        <trans-unit id="4cae2e767271065d7f78fa3e9c794bcd99ab2963" translate="yes" xml:space="preserve">
          <source>The function looks in the symbol table of &lt;code&gt;$package&lt;/code&gt; for the typeglob for &lt;code&gt;$referent&lt;/code&gt;, which is a reference to a variable or subroutine (SCALAR, ARRAY, HASH, or CODE). If it finds the typeglob, it returns it. Otherwise, it returns undef. Note that &lt;code&gt;findsym&lt;/code&gt; memoizes the typeglobs it has previously successfully found, so subsequent calls with the same arguments should be much faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228b62ac93f3c97adf4846ab7a229490257f21f2" translate="yes" xml:space="preserve">
          <source>The function name and the return type must be placed on separate lines and should be flush left-adjusted.</source>
          <target state="translated">函数名和返回类型必须放在不同的行中,并应左调齐。</target>
        </trans-unit>
        <trans-unit id="497e4c985232c356046790edf3b0a4494724ab06" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;-Name =&amp;gt; value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">该函数可以选择使用多个指定为 &lt;code&gt;-Name =&amp;gt; value&lt;/code&gt; 对的命名选项。这允许定制各个选项，而不必在参数列表中全部指定它们。</target>
        </trans-unit>
        <trans-unit id="c334e8eba917e7f07e2743dd2e109fa8bab331b7" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;-Name=&amp;gt;value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">该函数可以选择采用多个指定为 &lt;code&gt;-Name=&amp;gt;value&lt;/code&gt; 对的命名选项。这允许定制各个选项，而不必在参数列表中全部指定它们。</target>
        </trans-unit>
        <trans-unit id="24c3d21a118e57cb0a792d18dd4aca22a45547ff" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;Name =&amp;gt; value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">该函数可以选择采用多个指定为 &lt;code&gt;Name =&amp;gt; value&lt;/code&gt; 对的命名选项。这允许定制各个选项，而不必在参数列表中全部指定它们。</target>
        </trans-unit>
        <trans-unit id="91502bdfeb749a40030a89a237be0405bf938f7b" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;NULL&lt;/code&gt; if there is no occurrence of &lt;code&gt;little&lt;/code&gt; within &lt;code&gt;big&lt;/code&gt;. If &lt;code&gt;little&lt;/code&gt; is the empty string, &lt;code&gt;big&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd7c1c2cc7bcbc10e2084326d92993267a12ffd" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;TRUE&lt;/code&gt; if the input string is empty, or if the corresponding C function returns &lt;code&gt;TRUE&lt;/code&gt; for every byte in the string.</source>
          <target state="translated">该函数返回 &lt;code&gt;TRUE&lt;/code&gt; ，如果输入的字符串是空的，或者如果对应的C函数返回 &lt;code&gt;TRUE&lt;/code&gt; 的字符串中的每一个字节。</target>
        </trans-unit>
        <trans-unit id="d8c35a5a4f8d066f0d21fe352b171cb7a12a9b6f" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; on error, with the reason for the error placed in &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt;. Just what is in the packed string depends on LEVEL and OPTNAME; consult &lt;a href=&quot;http://man.he.net/man2/getsockopt&quot;&gt;getsockopt(2)&lt;/a&gt; for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt;) format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18bb210a9d041841ab7e7d3f647d6ee1d366da33" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, with the reason for the error placed in &lt;code&gt;$!&lt;/code&gt; . Just what is in the packed string depends on LEVEL and OPTNAME; consult getsockopt(2) for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt; ) format.</source>
          <target state="translated">该函数返回一个表示请求的套接字选项的打包字符串，或者对错误的 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，错误原因放在 &lt;code&gt;$!&lt;/code&gt; 中!。打包字符串中的内容取决于LEVEL和OPTNAME；有关详细信息，请咨询getsockopt（2）。一个常见的情况是该选项是一个整数，在这种情况下，结果是一个打包的整数，您可以使用具有 &lt;code&gt;i&lt;/code&gt; （或 &lt;code&gt;I&lt;/code&gt; ）格式的 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 对其进行解码。</target>
        </trans-unit>
        <trans-unit id="f3bdd5d171fe014406932479dff47095d4169b23" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, with the reason for the error placed in &lt;code&gt;$!&lt;/code&gt; . Just what is in the packed string depends on LEVEL and OPTNAME; consult getsockopt(2) for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt; ) format.</source>
          <target state="translated">该函数返回一个表示请求的套接字选项的打包字符串，或者对错误的 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，错误原因放在 &lt;code&gt;$!&lt;/code&gt; 中!。打包字符串中的内容取决于LEVEL和OPTNAME；有关详细信息，请咨询getsockopt（2）。一个常见的情况是该选项是一个整数，在这种情况下，结果是一个打包的整数，您可以使用具有 &lt;code&gt;i&lt;/code&gt; （或 &lt;code&gt;I&lt;/code&gt; ）格式的 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 对其进行解码。</target>
        </trans-unit>
        <trans-unit id="e9c09e2f85dbb39e869f16bb5dde4b83ed886b56" translate="yes" xml:space="preserve">
          <source>The function returns a pointer to the constructed subroutine. If the sub is anonymous then ownership of one counted reference to the subroutine is transferred to the caller. If the sub is named then the caller does not get ownership of a reference. In most such cases, where the sub has a non-phase name, the sub will be alive at the point it is returned by virtue of being contained in the glob that names it. A phase-named subroutine will usually be alive by virtue of the reference owned by the phase's automatic run queue. A &lt;code&gt;BEGIN&lt;/code&gt; subroutine may have been destroyed already by the time this function returns, but currently bugs occur in that case before the caller gets control. It is the caller's responsibility to ensure that it knows which of these situations applies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9011070fbeb03f4af4eed5e55fde28d9eee21f2e" translate="yes" xml:space="preserve">
          <source>The function returns a pointer to the constructed subroutine. If the sub is anonymous then ownership of one counted reference to the subroutine is transferred to the caller. If the sub is named then the caller does not get ownership of a reference. In most such cases, where the sub has a non-phase name, the sub will be alive at the point it is returned by virtue of being contained in the glob that names it. A phase-named subroutine will usually be alive by virtue of the reference owned by the phase's automatic run queue. But a &lt;code&gt;BEGIN&lt;/code&gt; subroutine, having already been executed, will quite likely have been destroyed already by the time this function returns, making it erroneous for the caller to make any use of the returned pointer. It is the caller's responsibility to ensure that it knows which of these situations applies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c416a15314ff142b876195908cf3e0998cacb0b" translate="yes" xml:space="preserve">
          <source>The function returns a true value if the file was written successfully. Otherwise it returns a false value.</source>
          <target state="translated">如果文件写入成功,该函数返回一个真值,否则返回一个假值。否则返回一个false值。</target>
        </trans-unit>
        <trans-unit id="96868ec2f844938f055b367738ce668b3149cb6e" translate="yes" xml:space="preserve">
          <source>The function returns the list of directories actually created during the call; in scalar context the number of directories created.</source>
          <target state="translated">该函数返回调用过程中实际创建的目录列表;在标量上下文中,返回创建的目录数量。</target>
        </trans-unit>
        <trans-unit id="74e8f0415f195a35d73e8c99a877efa398a5fbfc" translate="yes" xml:space="preserve">
          <source>The function returns the menu id of the selected push button:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30520da28728f4bcd1c4695681153ff43915f3de" translate="yes" xml:space="preserve">
          <source>The function returns the number of files successfully deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b560ee48a1c4113ae4a064c91e40e3ebfc92205" translate="yes" xml:space="preserve">
          <source>The function should be defined like this:</source>
          <target state="translated">该函数应该这样定义。</target>
        </trans-unit>
        <trans-unit id="af1dfdcedd7b6d95c274f658ea41922443e248ed" translate="yes" xml:space="preserve">
          <source>The function should return a reference to an array containing the parent classes in order. The names of the classes should be the result of calling &lt;code&gt;HvENAME()&lt;/code&gt; on the stash. In those cases where &lt;code&gt;HvENAME()&lt;/code&gt; returns null, &lt;code&gt;HvNAME()&lt;/code&gt; should be used instead.</source>
          <target state="translated">该函数应按顺序返回对包含父类的数组的引用。类的名称应该是在存储区上调用 &lt;code&gt;HvENAME()&lt;/code&gt; 的结果。在 &lt;code&gt;HvENAME()&lt;/code&gt; 返回null的情况下，应 &lt;code&gt;HvNAME()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df40ff756f018edab3521eb313090bdefa039e32" translate="yes" xml:space="preserve">
          <source>The function takes as first argument a key to test against, and as second argument any form of criteria that are also allowed by the &lt;code&gt;allow&lt;/code&gt; key in the template.</source>
          <target state="translated">该函数将要测试的键用作第一个参数，而模板中的 &lt;code&gt;allow&lt;/code&gt; 键也允许使用任何形式的条件作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="f1378c8817cc1e710b51660b130f3baf8dd96ee6" translate="yes" xml:space="preserve">
          <source>The function takes one optional parameter, a reference to a hash. The contents of the hash allow the deflation interface to be tailored.</source>
          <target state="translated">该函数需要一个可选的参数,即一个哈希的引用。哈希值的内容允许对放气接口进行调整。</target>
        </trans-unit>
        <trans-unit id="deea19e69043d11a7254610da5a869b1f9452180" translate="yes" xml:space="preserve">
          <source>The function that handles the &lt;code&gt;allow&lt;/code&gt; key in the template is also available for independent use.</source>
          <target state="translated">处理模板中的 &lt;code&gt;allow&lt;/code&gt; 键的功能也可以独立使用。</target>
        </trans-unit>
        <trans-unit id="efcf392cc09771ca25c0652559e59fca2e7a7c50" translate="yes" xml:space="preserve">
          <source>The function visit() scans the SV arenas list, and calls a specified function for each SV it finds which is still live - ie which has an SvTYPE other than all 1's, and a non-zero SvREFCNT. visit() is used by the following functions (specified as [function that calls visit()] / [function called by visit() for each SV]):</source>
          <target state="translated">函数visit()扫描SV竞技场列表,并为它找到的每个SV调用一个指定的函数,这些SV仍然是实时的--即它的SvTYPE不是全部的1,并且SvREFCNT不为零。visit()被以下函数使用(指定为[调用visit()的函数]/[每个SV被visit()调用的函数])。</target>
        </trans-unit>
        <trans-unit id="8032aad3c9c6371a7328397cdc751815bd8235bd" translate="yes" xml:space="preserve">
          <source>The function will by default replace characters that can't be decoded by &quot;\x{FFFD}&quot;, the Unicode replacement character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19570f411b75d35372886127cc2a69449d9a4b6b" translate="yes" xml:space="preserve">
          <source>The function will croak with &quot;Wide character in subroutine entry&quot; if $bytes contains characters with code above 255. The base64 encoding is only defined for single-byte characters. Use the Encode module to select the byte encoding you want.</source>
          <target state="translated">如果$bytes包含编码大于255的字符,该函数将以 &quot;Wide character in subroutine entry&quot;(子程序输入中的宽字符)的形式出现。base64 编码只针对单字节字符。使用Encode模块来选择你想要的字节编码。</target>
        </trans-unit>
        <trans-unit id="b2a6bb6e55b46f9d735e2cbaab0b636efd193e6e" translate="yes" xml:space="preserve">
          <source>The function,</source>
          <target state="translated">该职能:</target>
        </trans-unit>
        <trans-unit id="56c2336779d3eb8fad6f134e1b3afd4055cf95fc" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_add&lt;/code&gt; , actually installs the filter. It takes one parameter which should be a reference. The kind of reference used will dictate which of the two filter types will be used.</source>
          <target state="translated">函数 &lt;code&gt;filter_add&lt;/code&gt; 实际上安装了过滤器。它采用一个应该作为参考的参数。使用的参考类型将决定要使用两种过滤器类型中的哪一种。</target>
        </trans-unit>
        <trans-unit id="953ee510269653d7250cb2c022a3b5e06178a57a" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_add&lt;/code&gt;, actually installs the filter. It takes one parameter which should be a reference. The kind of reference used will dictate which of the two filter types will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8317ff780b8620fb08e8151dfdbf3a52d2d611" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_del&lt;/code&gt; , is used to disable the current filter. It does not affect the running of the filter. All it does is tell Perl not to call filter any more.</source>
          <target state="translated">函数 &lt;code&gt;filter_del&lt;/code&gt; 用于禁用当前过滤器。它不会影响过滤器的运行。它所做的只是告诉Perl不要再调用filter了。</target>
        </trans-unit>
        <trans-unit id="5390ee2005fc8c59e72212b433101c76ad550f15" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_del&lt;/code&gt;, is used to disable the current filter. It does not affect the running of the filter. All it does is tell Perl not to call filter any more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85467ff647b7ea9bd91bc8fa0103d9ae4aadb9f" translate="yes" xml:space="preserve">
          <source>The functional interface is simply importable functions with the same name as the algorithm. The functions take the message as argument and return the digest. Example:</source>
          <target state="translated">功能接口是简单的可导入的与算法同名的函数。这些函数将消息作为参数并返回摘要。例如</target>
        </trans-unit>
        <trans-unit id="bf5b597fcbc2815c78fabe6a0ba67f38e49a2b3d" translate="yes" xml:space="preserve">
          <source>The functional interface needs Perl5.005 or better.</source>
          <target state="translated">功能界面需要Perl5.005或更高。</target>
        </trans-unit>
        <trans-unit id="4bdd9d3e5903e6dd1f8e73f664d773008086b093" translate="yes" xml:space="preserve">
          <source>The functions</source>
          <target state="translated">职能</target>
        </trans-unit>
        <trans-unit id="856ff8ad4698542f2d294ec36a49315416bf6990" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;http://man.he.net/man3/recvmsg&quot;&gt;recvmsg(3)&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/sendmsg&quot;&gt;sendmsg(3)&lt;/a&gt;, and &lt;a href=&quot;http://man.he.net/man3/socketpair&quot;&gt;socketpair(3)&lt;/a&gt; are not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9afae1770d87c27f0936f76c113b3734ec61024b" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;accept()&lt;/code&gt;, &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;pipe()&lt;/code&gt;, &lt;code&gt;readpipe()&lt;/code&gt; (as well as the related &lt;code&gt;qx&lt;/code&gt; and &lt;code&gt;`STRING`&lt;/code&gt; operators), &lt;code&gt;socket()&lt;/code&gt;, &lt;code&gt;socketpair()&lt;/code&gt;, and &lt;code&gt;sysopen()&lt;/code&gt; are affected by the lexical value of this variable. The implicit &lt;a href=&quot;#ARGV&quot;&gt;&quot;ARGV&quot;&lt;/a&gt; handle opened by &lt;code&gt;readline()&lt;/code&gt; (or the related &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; operators) on passed filenames is also affected (but not if it opens &lt;code&gt;STDIN&lt;/code&gt;). If this variable is not set, these functions will set the default layers as described in &lt;a href=&quot;perlio#Defaults-and-how-to-override-them&quot;&gt;&quot;Defaults and how to override them&quot; in PerlIO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ff03911b440c28f50688f4c9ab7665ef4a1c34" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;cond_wait()&lt;/code&gt; and &lt;code&gt;cond_signal()&lt;/code&gt; can be used in conjunction with locks to notify co-operating threads that a resource has become available. They are very similar in use to the functions found in &lt;code&gt;pthreads&lt;/code&gt; . However for most purposes, queues are simpler to use and more intuitive. See &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; for more details.</source>
          <target state="translated">函数 &lt;code&gt;cond_wait()&lt;/code&gt; 和 &lt;code&gt;cond_signal()&lt;/code&gt; 可以与锁结合使用，以通知合作线程资源已变得可用。它们的用法与 &lt;code&gt;pthreads&lt;/code&gt; 中的函数非常相似。但是，对于大多数目的而言，队列使用起来更简单，更直观。有关更多详细信息，请参见&lt;a href=&quot;threads/shared&quot;&gt;thread :: shared&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fdd336a11c2e07577ac0c13e1a2f33bcdcefa052" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;cond_wait()&lt;/code&gt; and &lt;code&gt;cond_signal()&lt;/code&gt; can be used in conjunction with locks to notify co-operating threads that a resource has become available. They are very similar in use to the functions found in &lt;code&gt;pthreads&lt;/code&gt;. However for most purposes, queues are simpler to use and more intuitive. See &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b4904f96b85af2bf6cf4659323a42dfc8558db" translate="yes" xml:space="preserve">
          <source>The functions and attributes are accessed via the &quot;tab&quot; (for table) member of &lt;code&gt;PerlIOl&lt;/code&gt; . The functions (methods of the layer &quot;class&quot;) are fixed, and are defined by the &lt;code&gt;PerlIO_funcs&lt;/code&gt; type. They are broadly the same as the public &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; functions:</source>
          <target state="translated">通过 &lt;code&gt;PerlIOl&lt;/code&gt; 的&amp;ldquo; tab&amp;rdquo;（用于表）成员可以访问功能和属性。功能（层&amp;ldquo;类&amp;rdquo;的方法）是固定的，并由 &lt;code&gt;PerlIO_funcs&lt;/code&gt; 类型定义。它们与公共 &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; 函数大致相同：</target>
        </trans-unit>
        <trans-unit id="da42f49a5d951340d77c54e3152012268bbac221" translate="yes" xml:space="preserve">
          <source>The functions and attributes are accessed via the &quot;tab&quot; (for table) member of &lt;code&gt;PerlIOl&lt;/code&gt;. The functions (methods of the layer &quot;class&quot;) are fixed, and are defined by the &lt;code&gt;PerlIO_funcs&lt;/code&gt; type. They are broadly the same as the public &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641685ab6429ec4eade93850f03823bb632c2710" translate="yes" xml:space="preserve">
          <source>The functions and attributes of the &quot;layer class&quot;.</source>
          <target state="translated">层类 &quot;的功能和属性。</target>
        </trans-unit>
        <trans-unit id="04a02ab73237464478de303a6921e51a12145bbd" translate="yes" xml:space="preserve">
          <source>The functions are modeled on those in</source>
          <target state="translated">这些功能都是以</target>
        </trans-unit>
        <trans-unit id="58e04ab7b2e7ccd7568d030e0e66721438c5c1d0" translate="yes" xml:space="preserve">
          <source>The functions in this module work as well as can be expected when used on earlier Unicode versions. But, obviously, they use the available data from that Unicode version. For example, if the Unicode version predates the definition of the script property (Unicode 3.1), then any function that deals with scripts is going to return &lt;code&gt;undef&lt;/code&gt; for the script portion of the return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529009dfac752f5a2536ceedfad4fb1e6f70b3ed" translate="yes" xml:space="preserve">
          <source>The functions in this section can serve as terms in an expression. They fall into two major categories: list operators and named unary operators. These differ in their precedence relationship with a following comma. (See the precedence table in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.) List operators take more than one argument, while unary operators can never take more than one argument. Thus, a comma terminates the argument of a unary operator, but merely separates the arguments of a list operator. A unary operator generally provides scalar context to its argument, while a list operator may provide either scalar or list contexts for its arguments. If it does both, scalar arguments come first and list argument follow, and there can only ever be one such list argument. For instance, &lt;a href=&quot;#splice-ARRAY%2COFFSET%2CLENGTH%2CLIST&quot;&gt;&lt;code&gt;splice&lt;/code&gt;&lt;/a&gt; has three scalar arguments followed by a list, whereas &lt;a href=&quot;#gethostbyname-NAME&quot;&gt;&lt;code&gt;gethostbyname&lt;/code&gt;&lt;/a&gt; has four scalar arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de8f908f8a6f8cbbe7a5d22657a37b7e7e24b80c" translate="yes" xml:space="preserve">
          <source>The functions in this section can serve as terms in an expression. They fall into two major categories: list operators and named unary operators. These differ in their precedence relationship with a following comma. (See the precedence table in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.) List operators take more than one argument, while unary operators can never take more than one argument. Thus, a comma terminates the argument of a unary operator, but merely separates the arguments of a list operator. A unary operator generally provides scalar context to its argument, while a list operator may provide either scalar or list contexts for its arguments. If it does both, scalar arguments come first and list argument follow, and there can only ever be one such list argument. For instance, splice() has three scalar arguments followed by a list, whereas gethostbyname() has four scalar arguments.</source>
          <target state="translated">本节中的函数可以用作表达式中的术语。它们分为两大类：列表运算符和命名一元运算符。它们的优先级关系与后跟逗号不同。（请参阅&lt;a href=&quot;perlop&quot;&gt;perlop中&lt;/a&gt;的优先级表。）列表运算符采用一个以上的参数，而一元运算符绝不能采用一个以上的参数。因此，逗号终止一元运算符的参数，但仅分隔列表运算符的参数。一元运算符通常为其参数提供标量上下文，而列表运算符可以为其参数提供标量或列表上下文。如果两者都执行，则标量参数排在最前面，列表参数排在后面，并且永远只能有一个这样的列表参数。例如，splice（）具有三个标量参数，后跟一个列表，而gethostbyname（）具有四个标量参数。</target>
        </trans-unit>
        <trans-unit id="db44e2533a11b8e3bb17098404db4eb4f6f38bb9" translate="yes" xml:space="preserve">
          <source>The functions not currently implemented include:</source>
          <target state="translated">目前未执行的职能包括:</target>
        </trans-unit>
        <trans-unit id="c91d15f478afdf6edcd21180f278e6de93659c87" translate="yes" xml:space="preserve">
          <source>The functions returns the number of files successfully deleted.</source>
          <target state="translated">该函数返回成功删除的文件数量。</target>
        </trans-unit>
        <trans-unit id="f6bd4366287856a0db88fc6b5b6a7d5f623cdf54" translate="yes" xml:space="preserve">
          <source>The functions that create ops, which have names like &lt;code&gt;newUNOP&lt;/code&gt; and &lt;code&gt;newBINOP&lt;/code&gt;, call a &quot;check&quot; function associated with each op type, before returning the op. The check functions can mangle the op as they see fit, and even replace it with an entirely new one. These functions are defined in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2856f3e4382d9f450458c2b6360a3461fef80e3f" translate="yes" xml:space="preserve">
          <source>The functions were deprecated in Perl 5.20, and removed in Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c725eeff7e9a331143580354d26ee52b59f30b" translate="yes" xml:space="preserve">
          <source>The gb2312han ordering includes 5 code points in private use area (E2D8..E2DC), that can't utilize &lt;code&gt;weightGB2312()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c6db468e398f8e94d67db3b6a47dc8ea853c6f" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wdeclaration-after-statement&lt;/code&gt; scans for such problems (by default on starting from Perl 5.9.4).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f00447c143aee7d5d5fe37917ea4e13f05bb95" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wdeclaration-after-statements&lt;/code&gt; scans for such problems (by default on starting from Perl 5.9.4).</source>
          <target state="translated">gcc选项 &lt;code&gt;-Wdeclaration-after-statements&lt;/code&gt; 扫描此类问题（默认情况下从Perl 5.9.4开始）。</target>
        </trans-unit>
        <trans-unit id="5ee3a23159a200898de862e7d5879870227625eb" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wendif-labels&lt;/code&gt; warns about the bad variant (by default on starting from Perl 5.9.4).</source>
          <target state="translated">gcc选项 &lt;code&gt;-Wendif-labels&lt;/code&gt; 警告有关错误的变体（默认情况下从Perl 5.9.4开始）。</target>
        </trans-unit>
        <trans-unit id="4d2d0d644a6adc7963542dd47a318273c10c274d" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wformat&lt;/code&gt; scans for such problems.</source>
          <target state="translated">gcc选项 &lt;code&gt;-Wformat&lt;/code&gt; 扫描此类问题。</target>
        </trans-unit>
        <trans-unit id="e2a941e3cdebbe41caee4c09c99b319335c33a51" translate="yes" xml:space="preserve">
          <source>The general answer is to use a CPAN module such as &lt;a href=&quot;Switch::Plain&quot;&gt;Switch::Plain&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af02f4de16ebe9571db6e3223402235667685fe3" translate="yes" xml:space="preserve">
          <source>The general format of this hash ref is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02921462c864d8e6c2a3ae360252bde69882166" translate="yes" xml:space="preserve">
          <source>The general structure of this module was written by Paul Evans &amp;lt;leonerd@leonerd.org.uk&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3325d45be5f27fbb2d4ff677421100e7fd8bb0" translate="yes" xml:space="preserve">
          <source>The generated C++ code will call &lt;code&gt;new&lt;/code&gt; .</source>
          <target state="translated">生成的C ++代码将调用 &lt;code&gt;new&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c6b61d936feb406f72b49e0c15b50e08be699f5" translate="yes" xml:space="preserve">
          <source>The generated C++ code will call &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40f7df8e8a0ceca1fdf5c8cc98299f799cdbb11" translate="yes" xml:space="preserve">
          <source>The generated Makefile enables the user of the extension to invoke</source>
          <target state="translated">生成的Makefile可以让扩展的用户调用</target>
        </trans-unit>
        <trans-unit id="ddf93e71778e5593e96208d788b15d2297c9188f" translate="yes" xml:space="preserve">
          <source>The generated singletons are kept around from instantiation until the end of the shell session. &amp;lt;plugin_list&amp;gt; can be reconfigured at any time at run time. While the cpan shell is running, it checks all activated plugins at each of the 8 reference points listed above and runs the respective method if it is implemented for that object. The method is called with the active CPAN::Distribution object passed in as an argument.</source>
          <target state="translated">生成的单例一直保持实例化状态，直到Shell会话结束。&amp;lt;plugin_list&amp;gt;可以在运行时随时重新配置。当cpan shell运行时，它将在上面列出的8个参考点中的每一个处检查所有已激活的插件，并运行针对该对象实现的相应方法。使用作为参数传入的活动CPAN :: Distribution对象调用该方法。</target>
        </trans-unit>
        <trans-unit id="04c9e6d408a35a88cbae891becfacfd45984120c" translate="yes" xml:space="preserve">
          <source>The generated trailer for a CODE: section ensures that the number of return values Perl will see is either 0 or 1 (depending on the &lt;code&gt;void&lt;/code&gt; ness of the return value of the C function, and heuristics mentioned in &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt;). The trailer generated for a PPCODE: section is based on the number of return values and on the number of times &lt;code&gt;SP&lt;/code&gt; was updated by &lt;code&gt;[X]PUSH*()&lt;/code&gt; macros.</source>
          <target state="translated">为CODE：部分生成的预告片确保Perl将看到的返回值数量为0或1（取决于C函数的返回值的 &lt;code&gt;void&lt;/code&gt; 性以及&lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;RETVAL变量中&lt;/a&gt;提到的启发式方法）。为PPCODE：部分生成的预告片基于返回值的数目以及 &lt;code&gt;[X]PUSH*()&lt;/code&gt; 宏更新 &lt;code&gt;SP&lt;/code&gt; 的次数。</target>
        </trans-unit>
        <trans-unit id="7153904b949c21e4b5069542df02f96114b91ebc" translate="yes" xml:space="preserve">
          <source>The generated trailer for a CODE: section ensures that the number of return values Perl will see is either 0 or 1 (depending on the &lt;code&gt;void&lt;/code&gt;ness of the return value of the C function, and heuristics mentioned in &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;&quot;The RETVAL Variable&quot;&lt;/a&gt;). The trailer generated for a PPCODE: section is based on the number of return values and on the number of times &lt;code&gt;SP&lt;/code&gt; was updated by &lt;code&gt;[X]PUSH*()&lt;/code&gt; macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ff48f0e128b0a15571a8a0caa4b35598c3501a" translate="yes" xml:space="preserve">
          <source>The generation number of the name at offset &lt;code&gt;po&lt;/code&gt; in the current compiling pad (lvalue).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147459e5132af1acc303407a971ff312e870e58e" translate="yes" xml:space="preserve">
          <source>The generation number of the name at offset &lt;code&gt;po&lt;/code&gt; in the current compiling pad (lvalue). Note that &lt;code&gt;SvUVX&lt;/code&gt; is hijacked for this purpose.</source>
          <target state="translated">当前编译区中偏移 &lt;code&gt;po&lt;/code&gt; 处的名称的生成编号（左值）。请注意，为此目的劫持了 &lt;code&gt;SvUVX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65beebb121c6a44259be26715db186e4a704f7cf" translate="yes" xml:space="preserve">
          <source>The generic flag bits are a hybrid of &lt;code&gt;O_XXXXX&lt;/code&gt; style flags deduced from the mode string passed to &lt;code&gt;PerlIO_open()&lt;/code&gt; , and state bits for typical buffer layers.</source>
          <target state="translated">通用标志位是从传递给 &lt;code&gt;PerlIO_open()&lt;/code&gt; 的模式字符串推导出的 &lt;code&gt;O_XXXXX&lt;/code&gt; 样式标志和典型缓冲区层的状态位的混合体。</target>
        </trans-unit>
        <trans-unit id="7439e63d8439f40f7da5afff81864b98adf5ed8e" translate="yes" xml:space="preserve">
          <source>The generic flag bits are a hybrid of &lt;code&gt;O_XXXXX&lt;/code&gt; style flags deduced from the mode string passed to &lt;code&gt;PerlIO_open()&lt;/code&gt;, and state bits for typical buffer layers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9373f74aec3f2b814c36a72b32de7c1df8cce7e8" translate="yes" xml:space="preserve">
          <source>The generic names by which a &lt;b&gt;subroutine&lt;/b&gt; knows its &lt;b&gt;arguments&lt;/b&gt;. In many languages, formal arguments are always given individual names; in Perl, the formal arguments are just the elements of an array. The formal arguments to a Perl program are &lt;code&gt;$ARGV[0]&lt;/code&gt; , &lt;code&gt;$ARGV[1]&lt;/code&gt; , and so on. Similarly, the formal arguments to a Perl subroutine are &lt;code&gt;$_[0]&lt;/code&gt; , &lt;code&gt;$_[1]&lt;/code&gt; , and so on. You may give the arguments individual names by assigning the values to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; list. See also &lt;b&gt;actual arguments&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;子例程&lt;/b&gt;知道其自&lt;b&gt;变量&lt;/b&gt;的通用名称。在许多语言中，形式参数总是被赋予单独的名称。在Perl中，形式参数只是数组的元素。 Perl程序的正式参数是 &lt;code&gt;$ARGV[0]&lt;/code&gt; ， &lt;code&gt;$ARGV[1]&lt;/code&gt; 等。类似地，Perl子例程的形式参数为 &lt;code&gt;$_[0]&lt;/code&gt; ， &lt;code&gt;$_[1]&lt;/code&gt; 等。您可以通过将值分配给 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 列表来为参数指定单独的名称。另请参阅&lt;b&gt;实际参数&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="f91ba75da27279a516590191fc599f042d12a39a" translate="yes" xml:space="preserve">
          <source>The generic names by which a &lt;b&gt;subroutine&lt;/b&gt; knows its &lt;b&gt;arguments&lt;/b&gt;. In many languages, formal arguments are always given individual names; in Perl, the formal arguments are just the elements of an array. The formal arguments to a Perl program are &lt;code&gt;$ARGV[0]&lt;/code&gt;, &lt;code&gt;$ARGV[1]&lt;/code&gt;, and so on. Similarly, the formal arguments to a Perl subroutine are &lt;code&gt;$_[0]&lt;/code&gt;, &lt;code&gt;$_[1]&lt;/code&gt;, and so on. You may give the arguments individual names by assigning the values to a &lt;code&gt;my&lt;/code&gt; list. See also &lt;b&gt;actual arguments&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34968429c314c796b06ef13d6256c2eed375227" translate="yes" xml:space="preserve">
          <source>The get_dup() Method</source>
          <target state="translated">get_dup()方法</target>
        </trans-unit>
        <trans-unit id="777933c68edb9f2b520827371d959a89885f825a" translate="yes" xml:space="preserve">
          <source>The getaddrinfo() function converts a hostname and a service name into a list of structures, each containing a potential way to connect() to the named service on the named host.</source>
          <target state="translated">getaddrinfo()函数将主机名和服务名转换为一个结构列表,每个结构都包含了连接()到命名主机上命名服务的潜在方式。</target>
        </trans-unit>
        <trans-unit id="b2567e2f657f48e5ffd91f457d438d649766ac8c" translate="yes" xml:space="preserve">
          <source>The getdcwd() function is also provided on Win32 to get the current working directory on the specified drive, since Windows maintains a separate current working directory for each drive. If no drive is specified then the current drive is assumed.</source>
          <target state="translated">在Win32上也提供了getdcwd()函数来获取指定驱动器上的当前工作目录,因为Windows为每个驱动器维护了一个单独的当前工作目录。如果没有指定驱动器,则假设当前驱动器。</target>
        </trans-unit>
        <trans-unit id="7ef18c4cc3726de3de6ec3372bc632ef914a89f5" translate="yes" xml:space="preserve">
          <source>The getgr() function is a simple front-end that forwards a numeric argument to getgrgid() and the rest to getgrnam().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ed783ab1755c8923c2106affd806182a9b2682" translate="yes" xml:space="preserve">
          <source>The gethost() function is a simple front-end that forwards a numeric argument to gethostbyaddr() by way of Socket::inet_aton, and the rest to gethostbyname().</source>
          <target state="translated">gethost()函数是一个简单的前端,它通过Socket::inet_aton将一个数字参数转发给gethostbyaddr(),其余的转发给gethostbyname()。</target>
        </trans-unit>
        <trans-unit id="91be5f2becab7f44b4c2d8e8646f84ed2e15605f" translate="yes" xml:space="preserve">
          <source>The gethost() functions do this in the Perl core:</source>
          <target state="translated">在Perl核心中,gethost()函数可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="3d809f6317a210fb06b8763a59c516ccb0250c8f" translate="yes" xml:space="preserve">
          <source>The getnameinfo() function converts a socket address, such as returned by getsockname() or getpeername(), into a pair of human-readable strings representing the address and service name.</source>
          <target state="translated">getnameinfo()函数将一个套接字地址(如由 getsockname()或 getpeername()返回的地址)转换为一对人可读的字符串,代表地址和服务名称。</target>
        </trans-unit>
        <trans-unit id="c7341d184608dfa3d666b4de167cfb9267a092b7" translate="yes" xml:space="preserve">
          <source>The getnet() function is a simple front-end that forwards a numeric argument to getnetbyaddr(), and the rest to getnetbyname().</source>
          <target state="translated">getnet()函数是一个简单的前端,它将一个数字参数转发给getnetbyaddr(),其余的转发给getnetbyname()。</target>
        </trans-unit>
        <trans-unit id="a2bc6ce1fe12be1b0104870e6335dfcba678d52a" translate="yes" xml:space="preserve">
          <source>The getnet() functions do this in the Perl core:</source>
          <target state="translated">在Perl核心中,getnet()函数可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="723d74402111c283b1693c27eac4e9e45b8e6ed9" translate="yes" xml:space="preserve">
          <source>The getproto() function is a simple front-end that forwards a numeric argument to getprotobyport(), and the rest to getprotobyname().</source>
          <target state="translated">getproto()函数是一个简单的前端,它将一个数字参数转发给getprotobyport(),其余的转发给getprotobyname()。</target>
        </trans-unit>
        <trans-unit id="7135ce934ee6874d87ad890231c34f496a98c1a0" translate="yes" xml:space="preserve">
          <source>The getpw() function is a simple front-end that forwards a numeric argument to getpwuid() and the rest to getpwnam().</source>
          <target state="translated">getpw()函数是一个简单的前端,它将一个数字参数转发给getpwuid(),其余的转发给getpwnam()。</target>
        </trans-unit>
        <trans-unit id="0d0b8e4657c6706a0314a90d140b3591ebd5a9bb" translate="yes" xml:space="preserve">
          <source>The getserv() function is a simple front-end that forwards a numeric argument to getservbyport(), and the rest to getservbyname().</source>
          <target state="translated">geterv()函数是一个简单的前端,它将一个数字参数转发给getervbyport(),其余的转发给getervbyname()。</target>
        </trans-unit>
        <trans-unit id="7b3093ca7aacbd788d18481992e739fec224cedd" translate="yes" xml:space="preserve">
          <source>The given arguments are made consistent as though by calling &lt;code&gt;mktime()&lt;/code&gt; before calling your system's &lt;code&gt;strftime()&lt;/code&gt; function, except that the &lt;code&gt;isdst&lt;/code&gt; value is not affected.</source>
          <target state="translated">就像在调用系统的 &lt;code&gt;strftime()&lt;/code&gt; 函数之前调用 &lt;code&gt;mktime()&lt;/code&gt; 一样，使给定的参数一致，不同之处在于 &lt;code&gt;isdst&lt;/code&gt; 值不受影响。</target>
        </trans-unit>
        <trans-unit id="a46f0a3dc0d7705f81eb9d2736f8d38ab0c36cf3" translate="yes" xml:space="preserve">
          <source>The given link to</source>
          <target state="translated">给定的链接</target>
        </trans-unit>
        <trans-unit id="1b7e0113518a74a9ca8cd3adb44721180fc0bb94" translate="yes" xml:space="preserve">
          <source>The glob angle-bracket operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is a pathname generator that implements the rules for file name pattern matching used by Unix-like shells such as the Bourne shell or C shell.</source>
          <target state="translated">glob angle-bracket运算符 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 是路径名生成器，用于实现类Unix外壳（例如Bourne外壳或C外壳）使用的文件名模式匹配规则。</target>
        </trans-unit>
        <trans-unit id="5e215c589947f616aa94dd5242e9494420cfca28" translate="yes" xml:space="preserve">
          <source>The glob containing the output field separator - &lt;code&gt;*,&lt;/code&gt; in Perl space.</source>
          <target state="translated">在Perl空间中包含输出字段分隔符- &lt;code&gt;*,&lt;/code&gt; 的glob 。</target>
        </trans-unit>
        <trans-unit id="72ac12b62c28c3baeece5702a243d181ecdda5a0" translate="yes" xml:space="preserve">
          <source>The glob was stopped because an error was encountered.</source>
          <target state="translated">由于遇到了错误,地球仪被停止。</target>
        </trans-unit>
        <trans-unit id="f628027fc4ac19b3e64d6b57171d06712a0f4de2" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;debug&lt;/code&gt; and &lt;code&gt;debugcolor&lt;/code&gt; pragmas allow one to get detailed debugging info about regexp compilation and execution. &lt;code&gt;debugcolor&lt;/code&gt; is the same as debug, except the debugging information is displayed in color on terminals that can display termcap color sequences. Here is example output:</source>
          <target state="translated">全局 &lt;code&gt;debug&lt;/code&gt; 和 &lt;code&gt;debugcolor&lt;/code&gt; 编译指示允许您获取有关regexp编译和执行的详细调试信息。 &lt;code&gt;debugcolor&lt;/code&gt; 与debug相同，除了debug信息以彩色显示在可以显示termcap颜色序列的终端上。这是示例输出：</target>
        </trans-unit>
        <trans-unit id="2364252b351b212be51c3b8e4ec104f73d0c11a2" translate="yes" xml:space="preserve">
          <source>The global variable $Devel::Peek::pv_limit can be set to limit the number of character printed in various string values. Setting it to 0 means no limit.</source>
          <target state="translated">全局变量$Devel::Peek::pv_limit可以被设置为限制各种字符串值的打印字符数。设置为0表示没有限制。</target>
        </trans-unit>
        <trans-unit id="8c46d35ee4a0a86a8c41ca71ad737aa7e8fc9118" translate="yes" xml:space="preserve">
          <source>The global variables, like &lt;code&gt;@ARGV&lt;/code&gt; or the punctuation variables, must be &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt;. This block reads in</source>
          <target state="translated">全局变量，如 &lt;code&gt;@ARGV&lt;/code&gt; 或标点符号变量，必须在 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 有美化版 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 。该块读入</target>
        </trans-unit>
        <trans-unit id="8eb2db16d327a3b3a5febe18528925e67ce48750" translate="yes" xml:space="preserve">
          <source>The global variables, like &lt;code&gt;@ARGV&lt;/code&gt; or the punctuation variables, must be &lt;code&gt;local&lt;/code&gt;ized with &lt;code&gt;local()&lt;/code&gt;. This block reads in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fffe8d3b97109dc55047625158598478b942552" translate="yes" xml:space="preserve">
          <source>The glossary of this document is based upon this site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968cbdca6785865baa2b963e00c7cf59fd1ce4f6" translate="yes" xml:space="preserve">
          <source>The glue code pulls the arguments from the Perl stack, converts these Perl values to the formats expected by a C function, call this C function, transfers the return values of the C function back to Perl. Return values here may be a conventional C return value or any C function arguments that may serve as output parameters. These return values may be passed back to Perl either by putting them on the Perl stack, or by modifying the arguments supplied from the Perl side.</source>
          <target state="translated">胶水代码从Perl堆栈中提取参数,将这些Perl值转换为C函数所期望的格式,调用这个C函数,将C函数的返回值转回Perl。这里的返回值可以是传统的C函数返回值,也可以是任何可以作为输出参数的C函数参数。这些返回值可以通过把它们放在Perl堆栈中,或者通过修改Perl方面提供的参数来传回Perl。</target>
        </trans-unit>
        <trans-unit id="cfb79bdb1e9bdcf50c5258db72c30cb6aeb1e3e1" translate="yes" xml:space="preserve">
          <source>The gmctime() function provides a way of getting at the scalar sense of the original CORE::gmtime() function.</source>
          <target state="translated">gmctime()函数提供了一种获取原始CORE::gmtime()函数的标量意义的方法。</target>
        </trans-unit>
        <trans-unit id="15e78ea46607c2d827f12212191bcd40dffea850" translate="yes" xml:space="preserve">
          <source>The goal here is to have a testing utility that's simple to learn, quick to use and difficult to trip yourself up with while still providing more flexibility than the existing Test.pm. As such, the names of the most common routines are kept tiny, special cases and magic side-effects are kept to a minimum. WYSIWYG.</source>
          <target state="translated">我们的目标是拥有一个简单易学、快速使用、难以让自己陷入困境的测试工具,同时还能提供比现有Test.pm更多的灵活性。因此,最常见的例程的名称都被保留得很小,特殊情况和神奇的副作用都被保留到最小。WYSIWYG.</target>
        </trans-unit>
        <trans-unit id="a352895328c4895bdf1e088252c7cfc98a73fd07" translate="yes" xml:space="preserve">
          <source>The goal of the CPAN Testers project (&lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt;) is to test as many CPAN packages as possible on as many platforms as possible. This provides valuable feedback to module authors and potential users to identify bugs or platform compatibility issues and improves the overall quality and value of CPAN.</source>
          <target state="translated">CPAN Testers项目（&lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt;）的目标是在尽可能多的平台上测试尽可能多的CPAN软件包。这为模块作者和潜在用户提供了宝贵的反馈，以识别错误或平台兼容性问题，并提高了CPAN的整体质量和价值。</target>
        </trans-unit>
        <trans-unit id="dc55056f0c4ea6c7742a56f2eaefd841cb6edeb2" translate="yes" xml:space="preserve">
          <source>The goal of the CPAN Testers project (http://testers.cpan.org/) is to test as many CPAN packages as possible on as many platforms as possible. This provides valuable feedback to module authors and potential users to identify bugs or platform compatibility issues and improves the overall quality and value of CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373cfbe1fa7d52d17deaf7ae1d8864f358d08a8b" translate="yes" xml:space="preserve">
          <source>The good news is that at least some DBM module should be available, and &lt;a href=&quot;anydbm_file&quot;&gt;&lt;code&gt;AnyDBM_File&lt;/code&gt;&lt;/a&gt; will use whichever module it can find. Of course, then the code needs to be fairly strict, dropping to the greatest common factor (e.g., not exceeding 1K for each record), so that it will work with any DBM module. See &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4f9c804c591c85f4c73346c685fe6b75566956" translate="yes" xml:space="preserve">
          <source>The good news is that at least some DBM module should be available, and &lt;code&gt;AnyDBM_File&lt;/code&gt; will use whichever module it can find. Of course, then the code needs to be fairly strict, dropping to the greatest common factor (e.g., not exceeding 1K for each record), so that it will work with any DBM module. See &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; for more details.</source>
          <target state="translated">好消息是至少应该有一些DBM模块可用，并且 &lt;code&gt;AnyDBM_File&lt;/code&gt; 将使用它可以找到的任何模块。当然，那么代码需要相当严格，降至最大的公因数（例如，每个记录不超过1K），以便它可以与任何DBM模块一起使用。有关更多详细信息，请参见&lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b5a1d8ce58ba1e38f16f3a0f1eb5ac058c6d368" translate="yes" xml:space="preserve">
          <source>The good old C code quality inspector, &lt;code&gt;lint&lt;/code&gt; , is available in several platforms, but please be aware that there are several different implementations of it by different vendors, which means that the flags are not identical across different platforms.</source>
          <target state="translated">良好的旧C代码质量检查器 &lt;code&gt;lint&lt;/code&gt; 可以在多个平台上使用，但是请注意，不同供应商有多种不同的实现方式，这意味着标记在不同平台上并不相同。</target>
        </trans-unit>
        <trans-unit id="339c076fdfc281a53eef98387e350ea8944bc3d1" translate="yes" xml:space="preserve">
          <source>The good old C code quality inspector, &lt;code&gt;lint&lt;/code&gt;, is available in several platforms, but please be aware that there are several different implementations of it by different vendors, which means that the flags are not identical across different platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a4aa574c2f36a349fb65698d1079a80c8716e6" translate="yes" xml:space="preserve">
          <source>The grammar gives you the following rule: you can make the thing on the left of the colon if you see all the things on the right in sequence. This is called a &quot;reduction&quot;, and the aim of parsing is to completely reduce the input. There are several different ways you can perform a reduction, separated by vertical bars: so, &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;=&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; makes a &lt;code&gt;term&lt;/code&gt; , and &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;+&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; can also make a &lt;code&gt;term&lt;/code&gt; .</source>
          <target state="translated">语法为您提供以下规则：如果按顺序看到右侧的所有内容，则可以将其制作在冒号的左侧。这称为&amp;ldquo;减少&amp;rdquo;，而解析的目的是完全减少输入。有几种不同的方法可以进行还原，用竖线分隔：那么， &lt;code&gt;term&lt;/code&gt; 其次 &lt;code&gt;=&lt;/code&gt; 后跟 &lt;code&gt;term&lt;/code&gt; 使得 &lt;code&gt;term&lt;/code&gt; 和 &lt;code&gt;term&lt;/code&gt; 随后 &lt;code&gt;+&lt;/code&gt; 其次是 &lt;code&gt;term&lt;/code&gt; 也可以让一个 &lt;code&gt;term&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99ddf81d340c9da6ddca44ef926625a7b314c62b" translate="yes" xml:space="preserve">
          <source>The grammar gives you the following rule: you can make the thing on the left of the colon if you see all the things on the right in sequence. This is called a &quot;reduction&quot;, and the aim of parsing is to completely reduce the input. There are several different ways you can perform a reduction, separated by vertical bars: so, &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;=&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; makes a &lt;code&gt;term&lt;/code&gt;, and &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;+&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; can also make a &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f689a3c521cea873db9ec7a159a154a44941fb63" translate="yes" xml:space="preserve">
          <source>The grammar, lines one and three of the snippet above, tells you how to build up more complex forms. These complex forms, &quot;non-terminal symbols&quot; are generally placed in lower case. &lt;code&gt;term&lt;/code&gt; here is a non-terminal symbol, representing a single expression.</source>
          <target state="translated">上面这段代码的第一行和第三行的语法告诉您如何构建更复杂的形式。这些复杂的形式，&amp;ldquo;非终结符&amp;rdquo;通常放在小写形式。这里的 &lt;code&gt;term&lt;/code&gt; 是一个非终结符，代表一个表达式。</target>
        </trans-unit>
        <trans-unit id="d748b942ca422b33db3c9c207b20fcf5e35fbf06" translate="yes" xml:space="preserve">
          <source>The great_circle_midpoint() is just a special case of</source>
          <target state="translated">great_circle_midpoint()只是一个特殊的例子。</target>
        </trans-unit>
        <trans-unit id="65a277526deeb0c81c0a5dcd559529318f7f89a5" translate="yes" xml:space="preserve">
          <source>The group as a whole is interpreted as follows:</source>
          <target state="translated">该组整体解释如下:</target>
        </trans-unit>
        <trans-unit id="fc9b7c0745af45eb8fd74cee86dd53c561106e37" translate="yes" xml:space="preserve">
          <source>The group id owning the file</source>
          <target state="translated">拥有该文件的组ID</target>
        </trans-unit>
        <trans-unit id="163b6e7222a22b065c1007b2d5c671945f219faa" translate="yes" xml:space="preserve">
          <source>The group name that owns the file</source>
          <target state="translated">拥有该文件的组名</target>
        </trans-unit>
        <trans-unit id="89fddac9a52f335bd6aece8163a19a7049c17f30" translate="yes" xml:space="preserve">
          <source>The grouping assigns a value to &lt;code&gt;\g1&lt;/code&gt;, so that the same 3-letter sequence is used for both parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5464b947891c7dfe478004d22eea99e392c2554b" translate="yes" xml:space="preserve">
          <source>The grouping assigns a value to \g1, so that the same 3-letter sequence is used for both parts.</source>
          <target state="translated">分组给/g1赋值,使两部分使用相同的3个字母序列。</target>
        </trans-unit>
        <trans-unit id="28563bfc58252e6ce5590c38ddeee29b7156bffa" translate="yes" xml:space="preserve">
          <source>The grouping construct &lt;code&gt;( ... )&lt;/code&gt; creates capture groups (also referred to as capture buffers). To refer to the current contents of a group later on, within the same pattern, use &lt;code&gt;\g1&lt;/code&gt; (or &lt;code&gt;\g{1}&lt;/code&gt;) for the first, &lt;code&gt;\g2&lt;/code&gt; (or &lt;code&gt;\g{2}&lt;/code&gt;) for the second, and so on. This is called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a808380dda4fa48a019446ad652d6dc63c38be3d" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also allow the extraction of the parts of a string that matched. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. They can be used just as ordinary variables:</source>
          <target state="translated">分组元字符 &lt;code&gt;()&lt;/code&gt; 也允许提取匹配的字符串部分。对于每个分组，内部匹配的部分都进入特殊变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等。它们可以像普通变量一样使用：</target>
        </trans-unit>
        <trans-unit id="c2b66b10db32d7f5b9d549c39f4a96523e13167f" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also allow the extraction of the parts of a string that matched. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. They can be used just as ordinary variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7778e0ad49a7501b63144277c49609f424265cc5" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also serve another completely different function: they allow the extraction of the parts of a string that matched. This is very useful to find out what matched and for text processing in general. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. They can be used just as ordinary variables:</source>
          <target state="translated">分组元字符 &lt;code&gt;()&lt;/code&gt; 还具有另一个完全不同的功能：它们允许提取匹配的字符串部分。通常，这对于查找匹配项以及进行文本处理非常有用。对于每个分组，内部匹配的部分都进入特殊变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等。它们可以像普通变量一样使用：</target>
        </trans-unit>
        <trans-unit id="f7d8e07f21ecf7c9b89414eb2748089fabb93562" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also serve another completely different function: they allow the extraction of the parts of a string that matched. This is very useful to find out what matched and for text processing in general. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eece9645dd47cfb0899002c6d7925c002a7646e" translate="yes" xml:space="preserve">
          <source>The guts of &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; utility.</source>
          <target state="translated">&lt;a href=&quot;../perldoc&quot;&gt;Perldoc&lt;/a&gt;实用程序的勇气。</target>
        </trans-unit>
        <trans-unit id="4573f027ad2a701c6d9118677a3e8b776808d62d" translate="yes" xml:space="preserve">
          <source>The guts of &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; utility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1a967bf7f342dcba1f488528612191eac5ba1e" translate="yes" xml:space="preserve">
          <source>The gzip support in &lt;code&gt;Compress::Zlib&lt;/code&gt; version 1.x can only work with a real filesystem filehandle. The filehandles used by Apache modules are not associated with the filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2c643a66e3a499a113b39d3630e9b4f6beb5ae" translate="yes" xml:space="preserve">
          <source>The handle identifies a directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31680a03b79cf90dad61ef90684e16f85b576d96" translate="yes" xml:space="preserve">
          <source>The handler names are based on the underlying type of the variable being declared or of the reference passed. Because these attributes are associated with subroutine or variable declarations, this deliberately ignores any possibility of being blessed into some package. Thus, a subroutine declaration uses &quot;CODE&quot; as its</source>
          <target state="translated">处理程序的名称是基于被声明的变量或传递的引用的基本类型。因为这些属性是与子程序或变量声明相关联的,这就刻意忽略了任何被祝福到某个包中的可能性。因此,一个子程序声明使用 &quot;CODE &quot;作为其</target>
        </trans-unit>
        <trans-unit id="a4c1e3467d4145540134804fd2549f602b627fdd" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals calls &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (actually &lt;code&gt;croak&lt;/code&gt; ) with a message indicating which signal was caught.</source>
          <target state="translated">用于随后安装的信号的处理程序调用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; （实际上是 &lt;code&gt;croak&lt;/code&gt; ），并显示一条消息，指示捕获了哪个信号。</target>
        </trans-unit>
        <trans-unit id="00d58947b3aad48761af600208c9e3fd41356ea5" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals calls &lt;code&gt;die&lt;/code&gt; (actually &lt;code&gt;croak&lt;/code&gt;) with a message indicating which signal was caught.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f12af1084926ed2ac194950a97f332b400e2448" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals outputs a Perl stack trace to STDERR and then tries to dump core. This is the default signal handler.</source>
          <target state="translated">用于后续安装信号的处理程序,向STDERR输出Perl堆栈跟踪,然后尝试转储核心。这是默认的信号处理程序。</target>
        </trans-unit>
        <trans-unit id="d5126c9fee7d8a5338a4248383236dc9ecb51986" translate="yes" xml:space="preserve">
          <source>The handling of A &amp;amp; P in MBI/MBF (the old core code shipped with Perl versions &amp;lt;= 5.7.2) is like this:</source>
          <target state="translated">MBI / MBF（Perl版本&amp;lt;= 5.7.2附带的旧核心代码）中的A＆P的处理如下：</target>
        </trans-unit>
        <trans-unit id="fc9357967428b2793ab9d519118dce3147a43e76" translate="yes" xml:space="preserve">
          <source>The handling of errors by the layer is not specified. e.g. when $! should be set explicitly, when the error handling should be just delegated to the top layer.</source>
          <target state="translated">层对错误的处理没有明确规定,比如什么时候应该显式设置$!,什么时候应该只是将错误处理委托给上层。</target>
        </trans-unit>
        <trans-unit id="3b8d0bb90f4b079a36f72ce61ffbf0db337af8a2" translate="yes" xml:space="preserve">
          <source>The handling of hyphens and em dashes is somewhat fragile, and one may get the wrong one under some circumstances. This should only matter for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">连字符和破折号的处理有些脆弱，在某些情况下可能会弄错一个。这仅对&lt;b&gt;troff&lt;/b&gt;输出重要。</target>
        </trans-unit>
        <trans-unit id="de0cf92f651484ad4efbe5f702009188bf5e94e3" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%ENV&lt;/code&gt; contains your current environment. Setting a value in &lt;code&gt;ENV&lt;/code&gt; changes the environment for any child processes you subsequently &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; off.</source>
          <target state="translated">哈希 &lt;code&gt;%ENV&lt;/code&gt; 包含您当前的环境。在 &lt;code&gt;ENV&lt;/code&gt; 中设置一个值会更改您随后 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 关闭的任何子进程的环境。</target>
        </trans-unit>
        <trans-unit id="195033ec6c0348a9a8c6b6c6ac70c90873828bda" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%ENV&lt;/code&gt; contains your current environment. Setting a value in &lt;code&gt;ENV&lt;/code&gt; changes the environment for any child processes you subsequently &lt;code&gt;fork()&lt;/code&gt; off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3342ea08441abded27300d3bc9cbf7a4f36851e5" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%INC&lt;/code&gt; contains entries for each filename included via the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; operators. The key is the filename you specified (with module names converted to pathnames), and the value is the location of the file found. The &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operator uses this hash to determine whether a particular file has already been included.</source>
          <target state="translated">哈希 &lt;code&gt;%INC&lt;/code&gt; 包含通过 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 运算符包含的每个文件名的条目。密钥是您指定的文件名（模块名称已转换为路径名），值是找到的文件的位置。该 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 运营商使用该哈希来确定特定文件是否已经被包含在内。</target>
        </trans-unit>
        <trans-unit id="266d3cf7610b8376c6c9862a0efb7aafe1dd7d00" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%INC&lt;/code&gt; contains entries for each filename included via the &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, or &lt;code&gt;use&lt;/code&gt; operators. The key is the filename you specified (with module names converted to pathnames), and the value is the location of the file found. The &lt;code&gt;require&lt;/code&gt; operator uses this hash to determine whether a particular file has already been included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0c946c442c59fafdf0cc03f5925a7d6a67576e" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%SIG&lt;/code&gt; contains signal handlers for signals. For example:</source>
          <target state="translated">哈希 &lt;code&gt;%SIG&lt;/code&gt; 包含信号的信号处理程序。例如：</target>
        </trans-unit>
        <trans-unit id="2b378e4f482e4b01f36a8f2a09efa90c92e18352" translate="yes" xml:space="preserve">
          <source>The hash algorithm is defined in the &lt;code&gt;PERL_HASH&lt;/code&gt; macro:</source>
          <target state="translated">哈希算法在 &lt;code&gt;PERL_HASH&lt;/code&gt; 宏中定义：</target>
        </trans-unit>
        <trans-unit id="9dd8951a5e30b83106f470f819a5f4eb8b3cc146" translate="yes" xml:space="preserve">
          <source>The hash contains a &quot;version&quot; key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea3de2cc53cbdd71b8b1d8903e357859f8beec1" translate="yes" xml:space="preserve">
          <source>The hash described above is returned for locale-independent casing, where at least one of the mappings has length longer than one. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the code point may have mappings, but if so, all are length one, and are returned by &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;. Note that when this function does return a value, it will be for the complete set of mappings for a code point, even those whose length is one.</source>
          <target state="translated">对于与语言环境无关的大小写，返回上述哈希值，其中至少一个映射的长度大于一个。如果返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则代码点可能具有映射，但如果是，则所有映射都是长度为1，并由&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;返回。请注意，当此函数确实返回值时，它将用于代码点的完整映射集，即使长度为1的映射也是如此。</target>
        </trans-unit>
        <trans-unit id="711d74daff085b3047aba5916127a254ddfd4772" translate="yes" xml:space="preserve">
          <source>The hash described above is returned for locale-independent casing, where at least one of the mappings has length longer than one. If &lt;code&gt;undef&lt;/code&gt; is returned, the code point may have mappings, but if so, all are length one, and are returned by &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt;. Note that when this function does return a value, it will be for the complete set of mappings for a code point, even those whose length is one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c18c1acf75672457070b2eb9996c5075b3edce2" translate="yes" xml:space="preserve">
          <source>The hash does not support exists().</source>
          <target state="translated">哈希不支持exist()。</target>
        </trans-unit>
        <trans-unit id="8ead17751b61a27f00737722511d4f0a6b122f2d" translate="yes" xml:space="preserve">
          <source>The hash has the same structure as the one returned by Storable::file_magic(). The &lt;code&gt;file&lt;/code&gt; element is true if the image is a file image.</source>
          <target state="translated">哈希与Storable :: file_magic（）返回的哈希具有相同的结构。该 &lt;code&gt;file&lt;/code&gt; 如果图像是文件图像元素是真实的。</target>
        </trans-unit>
        <trans-unit id="5130b4f9ca4de414c6b75c63b4b5de1f1cac05d9" translate="yes" xml:space="preserve">
          <source>The hash reference returned by the new() function can be used to examine and modify the contents of the .packlist. Items may be added/deleted from the .packlist by modifying the hash. If the value associated with a hash key is a scalar, the entry written to the .packlist by any subsequent write() will be a simple filename. If the value is a hash, the entry written will be the filename followed by the key=value pairs from the hash. Reading back the .packlist will recreate the original entries.</source>
          <target state="translated">new()函数返回的哈希引用可以用来检查和修改 .packlist 的内容。可以通过修改哈希值从.packlist中添加/删除项目。如果与哈希键相关联的值是一个标量,那么任何后续的write()写入.packlist的条目将是一个简单的文件名。如果值是一个哈希,写入的条目将是文件名,然后是哈希中的key=value对。读回.packlist将重新创建原始条目。</target>
        </trans-unit>
        <trans-unit id="7516ee71ac16390106261a6b0bbe1da56c817eef" translate="yes" xml:space="preserve">
          <source>The hash returned has the following elements:</source>
          <target state="translated">返回的哈希值有以下元素。</target>
        </trans-unit>
        <trans-unit id="5e040a1ccea7ca71c3bad7dc1e4a1dfbebdc6ad0" translate="yes" xml:space="preserve">
          <source>The hash structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a906eb4ff4eda3db678faefd07c14f14845797" translate="yes" xml:space="preserve">
          <source>The hash variable you want to tie.</source>
          <target state="translated">你要绑定的哈希变量。</target>
        </trans-unit>
        <trans-unit id="1e40f9760b2e7d5577d2825dfdedf13a7e442c00" translate="yes" xml:space="preserve">
          <source>The head of the chain of deleted ops is returned, or &lt;code&gt;NULL&lt;/code&gt; if no ops were deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ab4ffe148d6038400649049035912b11305e989" translate="yes" xml:space="preserve">
          <source>The head of the chain of deleted ops is returned, or NULL if no ops were deleted.</source>
          <target state="translated">返回已删除操作链的头部,如果没有删除操作,则返回NULL。</target>
        </trans-unit>
        <trans-unit id="fb8198ac36c0383db875a5b5488218cc0db38e42" translate="yes" xml:space="preserve">
          <source>The head of the stack is &lt;code&gt;PL_markstack_ptr&lt;/code&gt;, and points to the most recently-pushed item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387a371cfd5487134922ec368d5a02aa122c9278" translate="yes" xml:space="preserve">
          <source>The head of the stack is &lt;code&gt;PL_stack_sp&lt;/code&gt;, and points to the most recently-pushed item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa9e497fb69d1c1631afd8e4e7265382a3e02b69" translate="yes" xml:space="preserve">
          <source>The head of the stack is indexed by &lt;code&gt;PL_savestack_ix&lt;/code&gt;, an integer which stores the index in the array at which the next item should be pushed. (Note that this is different to most other stacks, which reference the most recently-pushed item).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaff0f01d94e655d09c1c9c0abff908c801c87d2" translate="yes" xml:space="preserve">
          <source>The head of the stack is indexed by &lt;code&gt;PL_scopestack_ix&lt;/code&gt;, an integer which stores the index of the array or arrays at which the next item should be pushed. (Note that this is different to most other stacks, which reference the most recently-pushed item).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf516ef8c50debb6627d05e33ce24dc47fb581a2" translate="yes" xml:space="preserve">
          <source>The head of the stack is indexed by &lt;code&gt;PL_tmps_ix&lt;/code&gt;, an integer which stores the index in the array of the most recently-pushed item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c336f0d4ef1d936490e8c7b4819c090f6400cf2" translate="yes" xml:space="preserve">
          <source>The header file written by this module, typically</source>
          <target state="translated">由该模块编写的头文件,一般为</target>
        </trans-unit>
        <trans-unit id="4c85c6655d7d1206831fdc527a34ff595586e985" translate="yes" xml:space="preserve">
          <source>The header section continues until a line containing the word CHARMAP. This section has a form of</source>
          <target state="translated">标题部分一直持续到包含CHARMAP字样的一行。这一部分的形式是</target>
        </trans-unit>
        <trans-unit id="a528e0d6eaf7b88f88a4f152246f56b029cd4490" translate="yes" xml:space="preserve">
          <source>The heart of Storable is written in C for decent speed. Extra low-level optimizations have been made when manipulating perl internals, to sacrifice encapsulation for the benefit of greater speed.</source>
          <target state="translated">Storable的核心是用C语言编写的,速度不错。在操作perl内部的时候,我们做了额外的低级优化,以牺牲封装来换取更快的速度。</target>
        </trans-unit>
        <trans-unit id="a8fcb5ed9aadb57481c4a4c9eabfd488f403dcd6" translate="yes" xml:space="preserve">
          <source>The here-doc modifier &lt;code&gt;~&lt;/code&gt; allows you to indent your here-docs to make the code more readable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6afbf6cabde867bd59953ce46fc882087b1bd27" translate="yes" xml:space="preserve">
          <source>The hex number may optionally be prefixed with &quot;0x&quot; or &quot;x&quot; unless &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; is set in</source>
          <target state="translated">十六进制数字可以选择以&amp;ldquo; 0x&amp;rdquo;或&amp;ldquo; x&amp;rdquo;为前缀，除非在 &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; 位置设置了PERL_SCAN_DISALLOW_PREFIX：</target>
        </trans-unit>
        <trans-unit id="13723a6864537beca2cddb32c984b567fe87e40b" translate="yes" xml:space="preserve">
          <source>The hex number may optionally be prefixed with &lt;code&gt;&quot;0x&quot;&lt;/code&gt; or &lt;code&gt;&quot;x&quot;&lt;/code&gt; unless &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; is set in &lt;code&gt;*flags&lt;/code&gt; on entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e84dec921d35d3ee6755f09b85656ef3201e9eb" translate="yes" xml:space="preserve">
          <source>The high-order 4 bytes of the total number of cylinders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70cee26392a760c84fafaebf12b0f84ec8e67796" translate="yes" xml:space="preserve">
          <source>The higher-level loops preserve an additional state between iterations: whether the last match was zero-length. To break the loop, the following match after a zero-length match is prohibited to have a length of zero. This prohibition interacts with backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;&quot;Backtracking&quot;&lt;/a&gt;), and so the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e478860a296847f9fc713c230a9fb9343e5f150e" translate="yes" xml:space="preserve">
          <source>The higher-level loops preserve an additional state between iterations: whether the last match was zero-length. To break the loop, the following match after a zero-length match is prohibited to have a length of zero. This prohibition interacts with backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;), and so the</source>
          <target state="translated">较高级别的循环在迭代之间保留一个附加状态：最后一个匹配是否为零长度。为了打破循环，在零长度匹配之后的以下匹配禁止为零。此禁止与回溯（请参见&lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;）相互作用，因此</target>
        </trans-unit>
        <trans-unit id="5d5a041b27e5325dac6f1b79cae3bff7a7552bef" translate="yes" xml:space="preserve">
          <source>The highest priority is to look in the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59406d517ca12a7bf5809c9dbfccd1e683e04f9f" translate="yes" xml:space="preserve">
          <source>The hinting interface allows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2214ecae9d593eb49cab164240c89849da3aae" translate="yes" xml:space="preserve">
          <source>The hintsfile is eval()ed immediately after the arguments given to WriteMakefile are stuffed into a hash reference $self but before this reference becomes blessed. So if you want to do the equivalent to override or create an attribute you would say something like</source>
          <target state="translated">hintsfile在给WriteMakefile的参数被塞进一个哈希引用$self之后,但在这个引用成为祝福之前,立即被eval()ed。所以,如果你想做等价的覆盖或创建一个属性,你会说像这样的话</target>
        </trans-unit>
        <trans-unit id="c6b34cade6e81d89b062f256b78cf0c9f72eec68" translate="yes" xml:space="preserve">
          <source>The hook used by perl's &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; operator. &lt;b&gt;ptype&lt;/b&gt; is perl's character for the kind of IO:</source>
          <target state="translated">Perl的 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 运算符使用的钩子。&lt;b&gt;ptype&lt;/b&gt;是perl的IO类型的特征：</target>
        </trans-unit>
        <trans-unit id="1add1ef58ecb7c35c4f838c64caf5db36bdf795e" translate="yes" xml:space="preserve">
          <source>The hook used by perl's &lt;code&gt;binmode&lt;/code&gt; operator. &lt;b&gt;ptype&lt;/b&gt; is perl's character for the kind of IO:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f349975f67add93f8850a9eaf9c6c17fd6d7655e" translate="yes" xml:space="preserve">
          <source>The host name supplied to getaddrinfo() did not provide any usable address data.</source>
          <target state="translated">提供给getaddrinfo()的主机名没有提供任何可用的地址数据。</target>
        </trans-unit>
        <trans-unit id="26f0f0653cc389e36c588050d688c99bccaa9d07" translate="yes" xml:space="preserve">
          <source>The host name supplied to getaddrinfo() does not exist, or the address supplied to getnameinfo() is not associated with a host name and the &lt;code&gt;NI_NAMEREQD&lt;/code&gt; flag was supplied.</source>
          <target state="translated">提供给getaddrinfo（）的主机名不存在，或者提供给getnameinfo（）的地址未与主机名关联，并且提供了 &lt;code&gt;NI_NAMEREQD&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="a5eeccb55ae3d60bff3752f2dd5a946e36daa986" translate="yes" xml:space="preserve">
          <source>The hostname in the uri. Will be empty if host was originally 'localhost' for a 'file://' url.</source>
          <target state="translated">uri中的主机名。如果host是'file://'url的'localhost',则为空。</target>
        </trans-unit>
        <trans-unit id="c156a44c9f3418b797d3bba0a0c3707b47fb0ac1" translate="yes" xml:space="preserve">
          <source>The hub class or subclass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b8df6ac6b4142b5235e5c136ec2dc940fbfdbc" translate="yes" xml:space="preserve">
          <source>The hub is the place where all events get processed and handed off to the formatter. The hub also tracks test state, and provides several hooks into the event pipeline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bcd00b585852692b974ea751e079b51540b5b54" translate="yes" xml:space="preserve">
          <source>The hyperbolic sine, cosine, and tangent</source>
          <target state="translated">双曲正弦、余弦和正切。</target>
        </trans-unit>
        <trans-unit id="ff901843574864f25cda07a5ab8922dd36a5d5b7" translate="yes" xml:space="preserve">
          <source>The icmp and icmpv6 protocols requires that the program be run as root or that it be setuid to root. The other protocols do not require special privileges, but not all network devices implement tcp or udp echo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67744a35db2bbac17aada3b55cebfdff3c8d58f" translate="yes" xml:space="preserve">
          <source>The icmp protocol requires that the program be run as root or that it be setuid to root. The other protocols do not require special privileges, but not all network devices implement tcp or udp echo.</source>
          <target state="translated">icmp协议要求程序必须以root身份运行,或者设置uid为root。其他协议不需要特殊的权限,但并非所有的网络设备都实现了tcp或udp echo。</target>
        </trans-unit>
        <trans-unit id="0eb904ac9079537474ee2cc5638a1c5ecde2814c" translate="yes" xml:space="preserve">
          <source>The id must start with a letter (a-z or A-Z)</source>
          <target state="translated">ID必须以字母(a-z或A-Z)开头。</target>
        </trans-unit>
        <trans-unit id="28d56a775fecdcfc9d3c448ae0628addf0163100" translate="yes" xml:space="preserve">
          <source>The ideal (but a bit ugly) way to never have to think about that is to use &lt;code&gt;BEGIN&lt;/code&gt; blocks. So the first part of the &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;&lt;/a&gt; code could be rewritten as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28df5f4390b3a084c824acbbd266525edf8be51a" translate="yes" xml:space="preserve">
          <source>The ideal (but a bit ugly) way to never have to think about that is to use &lt;code&gt;BEGIN&lt;/code&gt; blocks. So the first part of the &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; code could be rewritten as:</source>
          <target state="translated">无需考虑的理想（但有点难看）的方法是使用 &lt;code&gt;BEGIN&lt;/code&gt; 块。因此，&lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt;代码的第一部分可以重写为：</target>
        </trans-unit>
        <trans-unit id="3e76ae6d87db97d0c1319c6311b06f1b4140b992" translate="yes" xml:space="preserve">
          <source>The immediate, in addition to the current stable release, the previous stable release is maintained. See &lt;a href=&quot;perlpolicy#MAINTENANCE-AND-SUPPORT&quot;&gt;&quot;MAINTENANCE AND SUPPORT&quot; in perlpolicy&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b5bd1f2c1aa12d8d86dc87b94e48313e6fd68a" translate="yes" xml:space="preserve">
          <source>The immediate, previous releases (i.e. perl5.14.x ) are usually maintained for a while, although not at the same level as the current releases.</source>
          <target state="translated">前期的版本(例如 perl5.14.x )通常会被维护一段时间,尽管与当前的版本不在同一水平。</target>
        </trans-unit>
        <trans-unit id="805f5e34bdac09e91b618eb56a2ba5ac7b88cd61" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;:raw&lt;/code&gt; is as a pseudo-layer which when &quot;pushed&quot; pops itself and then any layers which do not declare themselves as suitable for binary data. (Undoing :utf8 and :crlf are implemented by clearing flags rather than popping layers but that is an implementation detail.)</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; 的实现是一个伪层，当&amp;ldquo;按下&amp;rdquo;时会弹出自身，然后弹出任何不声明自己适合于二进制数据的层。（撤消：utf8和：crlf是通过清除标志而不是弹出层来实现的，但这是实现的细节。）</target>
        </trans-unit>
        <trans-unit id="74166820cac25a2e66888d5644d8d2715e58984a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;:raw&lt;/code&gt; is as a pseudo-layer which when &quot;pushed&quot; pops itself and then any layers which would modify the binary data stream. (Undoing &lt;code&gt;:utf8&lt;/code&gt; and &lt;code&gt;:crlf&lt;/code&gt; may be implemented by clearing flags rather than popping layers but that is an implementation detail.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1868b2d1d8d2925ab9482699d09a63b0f1af9f3c" translate="yes" xml:space="preserve">
          <source>The implementation of individual components of the system is likely to change over time.</source>
          <target state="translated">该系统各个组成部分的执行情况可能会随着时间的推移而改变。</target>
        </trans-unit>
        <trans-unit id="6075b5ee16206eda7e75f744a66591ab7ff6ad34" translate="yes" xml:space="preserve">
          <source>The implementation of the C3 MRO and switchable MROs within the perl core was written by Brandon L Black. Nicholas Clark created the pluggable interface, refactored Brandon's implementation to work with it, and wrote this document.</source>
          <target state="translated">在perl核心中实现C3 MRO和可切换MRO是由Brandon L Black编写的。Nicholas Clark创建了可插拔的接口,对Brandon的实现进行了重构以与之配合,并编写了这个文档。</target>
        </trans-unit>
        <trans-unit id="0af6409c892c8fe954ef686ac149074100758771" translate="yes" xml:space="preserve">
          <source>The implementation that surfaces this limitation will not be changed. See the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f92ca5378313f5f6ef2629dcf71bf80c645c279f" translate="yes" xml:space="preserve">
          <source>The implication of the above description is that a pattern containing nested parentheses will result in a call graph which cycles through &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt; , &lt;code&gt;regpiece()&lt;/code&gt; , &lt;code&gt;regatom()&lt;/code&gt; , &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt;</source>
          <target state="translated">上面描述的含义是，包含嵌套括号的模式将导致调用图循环通过 &lt;code&gt;reg()&lt;/code&gt; ， &lt;code&gt;regbranch()&lt;/code&gt; ， &lt;code&gt;regpiece()&lt;/code&gt; ， &lt;code&gt;regatom()&lt;/code&gt; ， &lt;code&gt;reg()&lt;/code&gt; ， &lt;code&gt;regbranch()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5213d8ec5be4ed3cc0fcaff5c663e1f7ec79164" translate="yes" xml:space="preserve">
          <source>The implication of the above description is that a pattern containing nested parentheses will result in a call graph which cycles through &lt;code&gt;reg()&lt;/code&gt;, &lt;code&gt;regbranch()&lt;/code&gt;, &lt;code&gt;regpiece()&lt;/code&gt;, &lt;code&gt;regatom()&lt;/code&gt;, &lt;code&gt;reg()&lt;/code&gt;, &lt;code&gt;regbranch()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ca45a7499fa655d95fb3a1c14575987ee3c0c2" translate="yes" xml:space="preserve">
          <source>The implicit iterator variable in the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; 函数中的隐式迭代器变量。</target>
        </trans-unit>
        <trans-unit id="d0c861ae3d9b69a61149562b6cbed085fb5fa583" translate="yes" xml:space="preserve">
          <source>The implicit iterator variable in the &lt;code&gt;grep()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49df36702f6a3c6192de102a29688dbe9fd4061b" translate="yes" xml:space="preserve">
          <source>The implicit variable of &lt;code&gt;given()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;given()&lt;/code&gt; 的隐式变量。</target>
        </trans-unit>
        <trans-unit id="d7bb5561c43ecc998d31a66fa1460eabbf5c497c" translate="yes" xml:space="preserve">
          <source>The implicit variable of &lt;code&gt;given()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c82ff9343f818ba122f89e2a74fb9d1d0fecda" translate="yes" xml:space="preserve">
          <source>The importance of these tests is proportional to the alleged stability of a module. A module which purports to be stable or which hopes to achieve wide use should adhere to as strict a testing regime as possible.</source>
          <target state="translated">这些测试的重要性与一个模块的所谓稳定性成正比。一个自称稳定或希望得到广泛使用的模块应尽可能严格地遵守测试制度。</target>
        </trans-unit>
        <trans-unit id="09af00710c80d3dd70ebd96fd4367e42313c5d25" translate="yes" xml:space="preserve">
          <source>The importance of writing good test scripts cannot be over-emphasized. You should closely follow the &quot;ok/not ok&quot; style that Perl itself uses, so that it is very easy and unambiguous to determine the outcome of each test case. When you find and fix a bug, make sure you add a test case for it.</source>
          <target state="translated">写好测试脚本的重要性怎么强调都不过分。你应该严格遵循Perl本身所使用的 &quot;ok/not ok &quot;风格,这样就可以非常容易和明确地确定每个测试用例的结果。当你发现并修复一个bug时,一定要为它添加一个测试用例。</target>
        </trans-unit>
        <trans-unit id="a4561daf93366d570e71e9394fec54f9d31846e6" translate="yes" xml:space="preserve">
          <source>The important and distinguishing feature of run_forked is execution timeout which at first seems to be quite a simple task but if you think that the program which you're spawning might spawn some children itself (which in their turn could do the same and so on) it turns out to be not a simple issue.</source>
          <target state="translated">run_forked的重要和显著的特征是执行超时,这乍一看似乎是一个相当简单的任务,但如果你想到你正在产生的程序可能会产生一些子程序(它们反过来也可以做同样的事情,等等),就会发现这不是一个简单的问题。</target>
        </trans-unit>
        <trans-unit id="4973662d6822686f7aa087396e5cfac037bf9b09" translate="yes" xml:space="preserve">
          <source>The important parts of that are the second argument (the increment) to HEAP, and allowing the stack to be &quot;Above the (16M) line&quot;. If the heap increment is too small then when perl (for example loading unicode/Name.pl) tries to create a &quot;big&quot; (400K+) string it cannot fit in a single segment and you get &quot;Out of Memory!&quot; - even if there is still plenty of memory available.</source>
          <target state="translated">其中重要的部分是HEAP的第二个参数(增量),以及允许堆栈在&quot;(16M)行以上&quot;。如果堆增量太小,那么当perl(例如加载unicode/Name.pl)试图创建一个 &quot;大&quot;(400K以上)的字符串时,它无法容纳在一个段中,你会得到 &quot;Out of Memory!&quot;。-即使还有很多可用的内存,也会得到 &quot;Out of Memory!&quot;。</target>
        </trans-unit>
        <trans-unit id="3f69c866bd6b570c0ad67a5d6dcc4f47abb90206" translate="yes" xml:space="preserve">
          <source>The included contents will be inserted into the MANIFEST.SKIP file in between</source>
          <target state="translated">所包含的内容将被插入到MANIFEST.SKIP文件中的中间位置。</target>
        </trans-unit>
        <trans-unit id="321a9d8c0c3e343e922f69286afb469449a8323c" translate="yes" xml:space="preserve">
          <source>The independent subexpression &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; doesn't care about the rest of the regexp, so it sees an &lt;code&gt;'a'&lt;/code&gt; and grabs it. Then the rest of the regexp &lt;code&gt;ab&lt;/code&gt; cannot match. Because &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; is independent, there is no backtracking and the independent subexpression does not give up its &lt;code&gt;'a'&lt;/code&gt;. Thus the match of the regexp as a whole fails. A similar behavior occurs with completely independent regexps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02e5563a36b89e14fcbd689f1595a21037cddaee" translate="yes" xml:space="preserve">
          <source>The independent subexpression &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; doesn't care about the rest of the regexp, so it sees an &lt;code&gt;a&lt;/code&gt; and grabs it. Then the rest of the regexp &lt;code&gt;ab&lt;/code&gt; cannot match. Because &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; is independent, there is no backtracking and the independent subexpression does not give up its &lt;code&gt;a&lt;/code&gt; . Thus the match of the regexp as a whole fails. A similar behavior occurs with completely independent regexps:</source>
          <target state="translated">独立子表达式 &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; 不在乎正则表达式的其余部分，因此它看到 &lt;code&gt;a&lt;/code&gt; 并抓住了它。然后其余的regexp &lt;code&gt;ab&lt;/code&gt; 无法匹配。因为 &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; 是独立的，所以没有回溯，并且独立的子表达式不会放弃其 &lt;code&gt;a&lt;/code&gt; 。因此，整个regexp的匹配失败。完全独立的正则表达式也会发生类似的现象：</target>
        </trans-unit>
        <trans-unit id="d8911df7ecc3a80cd7cb7748b8608afa2215b297" translate="yes" xml:space="preserve">
          <source>The index entry specified contains nothing but whitespace.</source>
          <target state="translated">指定的索引条目只包含空格。</target>
        </trans-unit>
        <trans-unit id="8993f68ea89e04e52354fc3b53dacbbf01363016" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;a href=&quot;#index-STR%2CSUBSTR%2CPOSITION&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; returns -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed2b9d5332f95abb7e28bc54e5124d59c88ac74f" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; returns -1.</source>
          <target state="translated">索引函数在另一个字符串中搜索一个字符串，但是没有完整的正则表达式模式匹配的类似通配符的行为。它返回POSITION或之后STR中第一次出现SUBSTR的位置。如果省略POSITION，则从字符串的开头开始搜索。字符串开头之前或结尾之后的POSITION分别视为字符串的开头或结尾。POSITION和返回值基于零。如果未找到子字符串，则 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 返回-1。</target>
        </trans-unit>
        <trans-unit id="052a5a20374b32a9d318c8e657a3fc6d2c067a62" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;code&gt;&lt;a href=&quot;index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; returns -1.</source>
          <target state="translated">索引函数在另一个字符串中搜索一个字符串，但是没有完整的正则表达式模式匹配的类似通配符的行为。它返回POSITION或之后STR中第一次出现SUBSTR的位置。如果省略POSITION，则从字符串的开头开始搜索。字符串开头之前或结尾之后的POSITION分别视为字符串的开头或结尾。POSITION和返回值基于零。如果未找到子字符串，则 &lt;code&gt;&lt;a href=&quot;index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 返回-1。</target>
        </trans-unit>
        <trans-unit id="1deb1e733742d1b9b4e186c9d57759d15dd95d6b" translate="yes" xml:space="preserve">
          <source>The index of the last allocated space in the padlist. Note that the last pad may be in an earlier slot. Any entries following it will be &lt;code&gt;NULL&lt;/code&gt; in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d12f86f44aac2e21ecbe7b61cc95b95675209f" translate="yes" xml:space="preserve">
          <source>The index of the last allocated space in the padlist. Note that the last pad may be in an earlier slot. Any entries following it will be NULL in that case.</source>
          <target state="translated">垫表中最后一个分配的空间的索引。请注意,最后一个pad可能在一个较早的槽中。在这种情况下,它后面的任何条目将是NULL。</target>
        </trans-unit>
        <trans-unit id="e58a7f8912fdbd8eaa97b22ef4d5d356a40471d5" translate="yes" xml:space="preserve">
          <source>The index of the last pad entry.</source>
          <target state="translated">最后一个垫子的索引。</target>
        </trans-unit>
        <trans-unit id="9c1326f686e664ef67aae2567ac4696fd6d57b00" translate="yes" xml:space="preserve">
          <source>The index of the last pad name.</source>
          <target state="translated">最后一个垫名的索引。</target>
        </trans-unit>
        <trans-unit id="6e35b0206297becebb26c609423d65b1dfe24dd3" translate="yes" xml:space="preserve">
          <source>The indexing merely outputs messages via &lt;code&gt;.tm&lt;/code&gt; for each major page, section, subsection, item, and any &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; directives. See &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda2671ac9e05ad8e30450bd5f169c0ab42ddce2" translate="yes" xml:space="preserve">
          <source>The indexing merely outputs messages via &lt;code&gt;.tm&lt;/code&gt; for each major page, section, subsection, item, and any &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; directives. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for more details.</source>
          <target state="translated">索引仅通过 &lt;code&gt;.tm&lt;/code&gt; 为每个主要页面，节，小节，项目和任何 &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 指令输出消息。有关更多详细信息，请参见&lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c99d2cd33e1325afbec2e3f58c4236d44c82d895" translate="yes" xml:space="preserve">
          <source>The inferred anchor text is implemented per &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;:</source>
          <target state="translated">推断的锚文本是根据&lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;实现的：</target>
        </trans-unit>
        <trans-unit id="f2d5d2272835d0eeff1fcb72d6fc348f5deff4fa" translate="yes" xml:space="preserve">
          <source>The inferred anchor text is implemented per &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfbacdda04f65b21a64f3fbe8dd597fa30ae2f5" translate="yes" xml:space="preserve">
          <source>The infinity and not-a-number have their own special arithmetic rules. The general rule is that they are &quot;contagious&quot;: &lt;code&gt;Inf&lt;/code&gt; plus one is &lt;code&gt;Inf&lt;/code&gt; , and &lt;code&gt;NaN&lt;/code&gt; plus one is &lt;code&gt;NaN&lt;/code&gt; . Where things get interesting is when you combine infinities and not-a-numbers: &lt;code&gt;Inf&lt;/code&gt; minus &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; divided by &lt;code&gt;INf&lt;/code&gt; are &lt;code&gt;NaN&lt;/code&gt; (while &lt;code&gt;Inf&lt;/code&gt; plus &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; times &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; ). &lt;code&gt;NaN&lt;/code&gt; is also curious in that it does not equal any number,</source>
          <target state="translated">无穷大和非数字都有自己的特殊算术规则。一般规则是它们具有&amp;ldquo;传染性&amp;rdquo;： &lt;code&gt;Inf&lt;/code&gt; 加1为 &lt;code&gt;Inf&lt;/code&gt; ， &lt;code&gt;NaN&lt;/code&gt; 加1为 &lt;code&gt;NaN&lt;/code&gt; 。事情变得有趣的是，当你把无穷大，而不是一个号码： &lt;code&gt;Inf&lt;/code&gt; 减去 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;Inf&lt;/code&gt; 除以 &lt;code&gt;INf&lt;/code&gt; 是 &lt;code&gt;NaN&lt;/code&gt; （而 &lt;code&gt;Inf&lt;/code&gt; 加 &lt;code&gt;Inf&lt;/code&gt; 是 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;Inf&lt;/code&gt; 倍 &lt;code&gt;Inf&lt;/code&gt; 是 &lt;code&gt;Inf&lt;/code&gt; ）。 &lt;code&gt;NaN&lt;/code&gt; 也很好奇，因为它不等于任何数字，</target>
        </trans-unit>
        <trans-unit id="b82803e1dc2591f87a6c585b7453fcb7c5b2d49b" translate="yes" xml:space="preserve">
          <source>The infinity and not-a-number have their own special arithmetic rules. The general rule is that they are &quot;contagious&quot;: &lt;code&gt;Inf&lt;/code&gt; plus one is &lt;code&gt;Inf&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; plus one is &lt;code&gt;NaN&lt;/code&gt;. Where things get interesting is when you combine infinities and not-a-numbers: &lt;code&gt;Inf&lt;/code&gt; minus &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; divided by &lt;code&gt;Inf&lt;/code&gt; are &lt;code&gt;NaN&lt;/code&gt; (while &lt;code&gt;Inf&lt;/code&gt; plus &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; times &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt;). &lt;code&gt;NaN&lt;/code&gt; is also curious in that it does not equal any number,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7be9da06f66cb02df4f43ae1ea9430b4a4ec21" translate="yes" xml:space="preserve">
          <source>The infinity as a constant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e5e47a18eb5768545b57a7c2da190e8c801676" translate="yes" xml:space="preserve">
          <source>The infinity is the result of certain math operations that overflow the floating point range, like 9**9**9. The not-a-number is the result when the result is undefined or unrepresentable. Though note that you cannot get &lt;code&gt;NaN&lt;/code&gt; from some common &quot;undefined&quot; or &quot;out-of-range&quot; operations like dividing by zero, or square root of a negative number, since Perl generates fatal errors for those.</source>
          <target state="translated">无限是某些数学运算导致浮点数范围溢出的结果，例如9 ** 9 ** 9。当结果不确定或无法表示时，结果为非数字。但是请注意，您无法从某些常见的&amp;ldquo;未定义&amp;rdquo;或&amp;ldquo;超出范围&amp;rdquo;操作（例如除以零或负数的平方根）获得 &lt;code&gt;NaN&lt;/code&gt; ，因为Perl会为这些操作产生致命错误。</target>
        </trans-unit>
        <trans-unit id="00c49c340cf01a0ad0057e1d1a4eb69e30e225ff" translate="yes" xml:space="preserve">
          <source>The information in</source>
          <target state="translated">中的信息</target>
        </trans-unit>
        <trans-unit id="477d4eda55a2d3f9993a8441da0761392c6f4bde" translate="yes" xml:space="preserve">
          <source>The init routine asks a few questions and writes a CPAN/Config.pm or CPAN/MyConfig.pm file (depending on what it is currently using).</source>
          <target state="translated">init例程会询问一些问题,并写入一个CPAN/Config.pm或CPAN/MyConfig.pm文件(取决于它当前使用的是什么)。</target>
        </trans-unit>
        <trans-unit id="46a6f162dfe4fd1932efaab095f3ad6c7065353c" translate="yes" xml:space="preserve">
          <source>The initial Haiku port was done by Ingo Weinhold &amp;lt;ingo_weinhold@gmx.de&amp;gt;.</source>
          <target state="translated">最初的Haiku端口由Ingo Weinhold &amp;lt;ingo_weinhold@gmx.de&amp;gt;完成。</target>
        </trans-unit>
        <trans-unit id="98cc24e951f63d830750ae3c1189e0eb891874c8" translate="yes" xml:space="preserve">
          <source>The initial call must supply the root of the tree as both top and o.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30baee764016e0fd1d74fa20302dc7f15e17366e" translate="yes" xml:space="preserve">
          <source>The initial comment shows a contrived, even dangerous example. By overriding &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; globally, you would be forcing the new (and subversive) behavior for the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator for</source>
          <target state="translated">最初的评论显示了一个人为的甚至危险的例子。通过全局覆盖 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; ，您将强制 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 运算符的新（且具有颠覆性）行为</target>
        </trans-unit>
        <trans-unit id="60355db9cd866fe1c7fe0bda38b193d6a4e848c8" translate="yes" xml:space="preserve">
          <source>The initial comment shows a contrived, even dangerous example. By overriding &lt;code&gt;glob&lt;/code&gt; globally, you would be forcing the new (and subversive) behavior for the &lt;code&gt;glob&lt;/code&gt; operator for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825ce23847c0393ed93e8d89640392b4a5b33a5c" translate="yes" xml:space="preserve">
          <source>The initial program is started up using the locale specified from the environment, as currently, described in &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt;. All newly created threads start with &lt;code&gt;LC_ALL&lt;/code&gt; set to &lt;code&gt;&quot;C&quot;&lt;/code&gt;&amp;gt;. Each thread may use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; to query or switch its locale at any time, without affecting any other thread. All locale-dependent operations automatically use their thread's locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd35ba0a15f59402bf69541a0c2a672b5245bb7" translate="yes" xml:space="preserve">
          <source>The initializer for a class element is an object of the corresponding class, or of one of it's subclasses, or a reference to a hash containing named arguments to be passed to the element's constructor.</source>
          <target state="translated">类元素的初始化器是相应类的对象,或者是它的一个子类的对象,或者是对包含命名参数的哈希的引用,这些参数将传递给元素的构造函数。</target>
        </trans-unit>
        <trans-unit id="12094a548e09c78cbb33f308cc132c5c3175cfa2" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;curlen&lt;/code&gt; parameter was 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7270a1d75b517033df50fe18fd9734207c302454" translate="yes" xml:space="preserve">
          <source>The input character at &lt;code&gt;p&lt;/code&gt; is assumed to be well-formed.</source>
          <target state="translated">假定 &lt;code&gt;p&lt;/code&gt; 处的输入字符格式正确。</target>
        </trans-unit>
        <trans-unit id="5b4da48b1525c95aa66984d855f728baeff9dd23" translate="yes" xml:space="preserve">
          <source>The input data will be read from each file in turn.</source>
          <target state="translated">输入数据将依次从每个文件中读取。</target>
        </trans-unit>
        <trans-unit id="6a300bdc55cb2694c445f5d77189a272f405a2c8" translate="yes" xml:space="preserve">
          <source>The input number must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">输入数字必须是非负整数，或以 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 开头的字符串，其余部分视为十六进制整数。文字数字常量必须是无符号的；如果前导零或包含非十进制十六进制数字，则将其解释为十六进制；否则将被解释为十进制。如果以 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 开头，则将其解释为Unicode代码点；否则，将其解释为Unicode代码点。否则，它将被解释为本地的。 （只有256以下的代码点在Unicode和本机之间可以有所不同。）因此， &lt;code&gt;U+41&lt;/code&gt; 始终是拉丁字母&amp;ldquo; A&amp;rdquo;。但是 &lt;code&gt;0x41&lt;/code&gt; 在EBCDIC平台上可以是&amp;ldquo; NO-BREAK SPACE&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3bfc355d9523e05f661ba51d39053e5f158eac0d" translate="yes" xml:space="preserve">
          <source>The input number must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt;, it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74af33c799ba9469f42a06ffc1422c08fe76ab11" translate="yes" xml:space="preserve">
          <source>The input parameter name is loosely matched, which means that white space, hyphens, and underscores are ignored (except for the trailing underscore in the old_form grandfathered-in &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; , and both of which mean &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; ).</source>
          <target state="translated">输入参数名称是松散匹配的，这意味着空格，连字符和下划线将被忽略（除了old_form祖父输入的 &lt;code&gt;&quot;L_&quot;&lt;/code&gt; 的尾随下划线，最好将其写为 &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ，并且两者都意味着 &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="50a387d524817a7fe881c13a9828020ec107aa28" translate="yes" xml:space="preserve">
          <source>The input parameter name is loosely matched, which means that white space, hyphens, and underscores are ignored (except for the trailing underscore in the old_form grandfathered-in &lt;code&gt;&quot;L_&quot;&lt;/code&gt;, which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt;, and both of which mean &lt;code&gt;General_Category=Cased Letter&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e74e0d2d8b749838155344b24b616732216f51a" translate="yes" xml:space="preserve">
          <source>The input record separator - &lt;code&gt;$/&lt;/code&gt; in Perl space.</source>
          <target state="translated">输入记录分隔符-Perl空间中的 &lt;code&gt;$/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fa23e4762b9d73d4eaf4fe4ff40a6345a28b068" translate="yes" xml:space="preserve">
          <source>The input record separator, newline by default. This influences Perl's idea of what a &quot;line&quot; is. Works like &lt;b&gt;awk&lt;/b&gt;'s RS variable, including treating empty lines as a terminator if set to the null string (an empty line cannot contain any spaces or tabs). You may set it to a multi-character string to match a multi-character terminator, or to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to read through the end of file. Setting it to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; means something slightly different than setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; , if the file contains consecutive empty lines. Setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; will treat two or more consecutive empty lines as a single empty line. Setting to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; will blindly assume that the next input character belongs to the next paragraph, even if it's a newline.</source>
          <target state="translated">输入记录分隔符，默认为换行符。这影响了Perl关于&amp;ldquo;线&amp;rdquo;的概念。就像&lt;b&gt;awk&lt;/b&gt;的RS变量一样工作，包括如果将空行设置为null字符串（空行不能包含任何空格或制表符），则将空行视为终止符。您可以将其设置为多字符字符串以匹配多字符终止符，或者将其设置为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 以通读文件末尾。如果文件包含连续的空行，则将其设置为 &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 意味着与设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 稍有不同。设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 会将两个或多个连续的空行视为一个空行。设置为 &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 会盲目地假设下一个输入字符属于下一段，即使它是换行符也是如此。</target>
        </trans-unit>
        <trans-unit id="e85a2d63aac48888c217e5fc29fb75b0836651b1" translate="yes" xml:space="preserve">
          <source>The input record separator, newline by default. This influences Perl's idea of what a &quot;line&quot; is. Works like &lt;b&gt;awk&lt;/b&gt;'s RS variable, including treating empty lines as a terminator if set to the null string (an empty line cannot contain any spaces or tabs). You may set it to a multi-character string to match a multi-character terminator, or to &lt;code&gt;undef&lt;/code&gt; to read through the end of file. Setting it to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; means something slightly different than setting to &lt;code&gt;&quot;&quot;&lt;/code&gt;, if the file contains consecutive empty lines. Setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; will treat two or more consecutive empty lines as a single empty line. Setting to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; will blindly assume that the next input character belongs to the next paragraph, even if it's a newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a207c3a9402edc134f0e1308be59f0ea92cbf62" translate="yes" xml:space="preserve">
          <source>The input sequence is not standard UTF-8, but a Perl extension. This bit is set only if the input &lt;code&gt;flags&lt;/code&gt; parameter contains either the &lt;code&gt;UTF8_DISALLOW_PERL_EXTENDED&lt;/code&gt; or the &lt;code&gt;UTF8_WARN_PERL_EXTENDED&lt;/code&gt; flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1ce589ec1298c83c9efa29e1da93e2c83adb1f" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that &lt;code&gt;curlen&lt;/code&gt; is smaller than required for a complete sequence. In other words, the input is for a partial character sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da71ee8003bfe3e8ec2c57918f6f663af8a1ae47" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that a non-continuation type byte was found in a position where only a continuation type one should be. See also &lt;a href=&quot;#UTF8_GOT_SHORT&quot;&gt;&quot;&lt;code&gt;UTF8_GOT_SHORT&lt;/code&gt;&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4e094d6ddae88fabdfbba8b8e5241b863d54f9" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that it is for a -Unicode UTF-16 surrogate code point. This bit is set only if the input &lt;code&gt;flags&lt;/code&gt; parameter contains either the &lt;code&gt;UTF8_DISALLOW_SURROGATE&lt;/code&gt; or the &lt;code&gt;UTF8_WARN_SURROGATE&lt;/code&gt; flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff44b5ee5ee25243c0818e9bac3059eeea96ab14" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that it is for a code point that is not representable in the number of bits available in an IV on the current platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903db38b58d5e3ef05b722cc2b0b61f1d172318a" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that it is for a non-Unicode code point; that is, one above the legal Unicode maximum. This bit is set only if the input &lt;code&gt;flags&lt;/code&gt; parameter contains either the &lt;code&gt;UTF8_DISALLOW_SUPER&lt;/code&gt; or the &lt;code&gt;UTF8_WARN_SUPER&lt;/code&gt; flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c430a74085221ab38d297957bbc930788c28aae9" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that the first byte was a UTF-8 continuation byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7003ec3d60fe29e1076b40608f946cd82019d546" translate="yes" xml:space="preserve">
          <source>The input sequence was malformed in that there is some other sequence that evaluates to the same code point, but that sequence is shorter than this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e2a05c675d83b32cdc798d03f4bd19670bf464" translate="yes" xml:space="preserve">
          <source>The insertion of a scalar or list value somewhere in the middle of another value, such that it appears to have been there all along. In Perl, variable interpolation happens in double-quoted strings and patterns, and list interpolation occurs when constructing the list of values to pass to a list operator or other such construct that takes a</source>
          <target state="translated">将一个标量值或列表值插入到另一个值的中间某处,使其看起来好像一直都在那里。在Perl中,变量插值发生在双引号字符串和模式中,而列表插值则发生在构建要传递给列表运算符的值列表或其他类似的构造中,这些构造取一个</target>
        </trans-unit>
        <trans-unit id="4d21a2b8d717cbebbeaee5c37e1b249a9b6f4299" translate="yes" xml:space="preserve">
          <source>The inspiration for the stop codon DNA example came from the ZIP code example in chapter 7 of</source>
          <target state="translated">终止密码子DNA例子的灵感来自于在《中国科学》第7章中的ZIP码例子。</target>
        </trans-unit>
        <trans-unit id="4a97f9d9b06cf863773b30ca4503b6a95be51b13" translate="yes" xml:space="preserve">
          <source>The installation paths that you set during the build get compiled into perl, so you don't have to do anything additional to start using that perl (except add its location to your PATH variable).</source>
          <target state="translated">你在构建过程中设置的安装路径会被编译成perl,所以你不需要做任何额外的事情就可以开始使用该perl(除了将它的位置添加到你的PATH变量)。</target>
        </trans-unit>
        <trans-unit id="ed7ec50305347f54da6bfda8296e9515a40cfdd4" translate="yes" xml:space="preserve">
          <source>The installer is ancient and has a few bugs on the paths it uses. You will have to fix them later. Basically, some things go into &quot;C:/Program Files/Windows CE Tools&quot;, others go into &quot;C:/Windows CE Tools&quot; regardless of the path you gave to the installer (the default will be &quot;C:/Windows CE Tools&quot;). Reboots will be required for the installer to proceed. Also .c and .h associations with Visual Studio might get overridden when installing EVC4. You have been warned.</source>
          <target state="translated">安装程序是古老的,它使用的路径上有一些错误。你将不得不稍后修复它们。基本上,有些东西会进入 &quot;C:/Program Files/Windows CE Tools&quot;,有些则会进入 &quot;C:/Windows CE Tools&quot;,不管你给安装程序的路径如何(默认是 &quot;C:/Windows CE Tools&quot;)。安装程序需要重新启动才能进行。另外,在安装EVC4时,Visual Studio的.c和.h关联可能会被覆盖。您已被警告。</target>
        </trans-unit>
        <trans-unit id="5b7ef7bcb453733f9ef12df7a7d461832dbe120b" translate="yes" xml:space="preserve">
          <source>The installman script will try to run on OS/390. There will be fewer errors if you have a roff utility installed. You can obtain GNU groff from the Redbook SG24-5944-00 ftp site.</source>
          <target state="translated">安装脚本将尝试在OS/390上运行。如果你安装了roff实用程序,错误就会减少。你可以从 Redbook SG24-5944-00 ftp 站点获得 GNU groff。</target>
        </trans-unit>
        <trans-unit id="85593ec8ae8efa2e0dca43eb532734290d86abb5" translate="yes" xml:space="preserve">
          <source>The integer a computer uses to represent a given character. ASCII codepoints are in the range 0 to 127; Unicode codepoints are in the range 0 to 0x1F_FFFF; and Perl codepoints are in the range 0 to 2&amp;sup3;&amp;sup2;&amp;minus;1 or 0 to 2⁶⁴&amp;minus;1, depending on your native integer size. In Perl Culture, sometimes called &lt;b&gt;ordinals&lt;/b&gt;.</source>
          <target state="translated">计算机用来表示给定字符的整数。ASCII码点的范围是0到127；Unicode代码点的范围是0到0x1F_FFFF；和Perl代码点的范围是0到2&amp;sup3;&amp;sup2;&amp;minus;1或0到2 ^ -1，这取决于您的本机整数大小。在Perl文化中，有时也称为普通&lt;b&gt;俗语&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="fffacf90cdbd65b0d80477a60f2e9ed117d5e990" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; , and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="translated">整数格式 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;I&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;J&lt;/code&gt; 本质上不可在处理器和操作系统之间移植，因为它们遵循本机字节序和字节序。例如，一个4字节的整数0x12345678（十进制305419896）将被本机排序（安排并由CPU寄存器处理）为字节，如下所示：</target>
        </trans-unit>
        <trans-unit id="c85dc9716f98ce9d26e0b8a1181441b82dd671db" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; , and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="translated">整数格式 &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;I&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;J&lt;/code&gt; 本质上不可在处理器和操作系统之间移植，因为它们遵循本机字节序和字节序。例如，一个4字节的整数0x12345678（十进制305419896）将被本机排序（安排并由CPU寄存器处理）为字节，如下所示：</target>
        </trans-unit>
        <trans-unit id="8d253eb6809a9562624388d35993ef60096f96e8" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1696e5627c4e618d6b57f471d56db53f3261ebc8" translate="yes" xml:space="preserve">
          <source>The integer four, not to be confused with six, Tom&amp;rsquo;s favorite editor. IV also means an internal Integer Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold, not to be confused with an &lt;b&gt;NV&lt;/b&gt;.</source>
          <target state="translated">整数四，不要与汤姆最喜欢的编辑器六混淆。IV还表示&lt;b&gt;标量&lt;/b&gt;可以容纳的内部整数值，不要与&lt;b&gt;NV&lt;/b&gt;混淆。</target>
        </trans-unit>
        <trans-unit id="38f7f88bfbbfc7fbb6565adc2a9af0982c4ebbc9" translate="yes" xml:space="preserve">
          <source>The integer or name form of the &lt;code&gt;condition&lt;/code&gt; allows us to choose, with more flexibility, what to match based on what matched earlier in the regexp. This searches for words of the form &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; or &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt; :</source>
          <target state="translated">的的整数或名称的形式 &lt;code&gt;condition&lt;/code&gt; 允许我们选择，更大的灵活性，并基于前面的正则表达式匹配什么匹配什么。此搜索形式为 &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt; 单词：</target>
        </trans-unit>
        <trans-unit id="fa48e81451f89adaf419b03b6f56f3e3cdc6501d" translate="yes" xml:space="preserve">
          <source>The integer or name form of the &lt;code&gt;condition&lt;/code&gt; allows us to choose, with more flexibility, what to match based on what matched earlier in the regexp. This searches for words of the form &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; or &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05de89837820906430d66857198677bee870304" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="translated">整数类型 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;L&lt;/code&gt; 后面可以跟有 &lt;code&gt;!&lt;/code&gt; 修饰符以指定本机短裤或多头。如该示例中所示的上方，一个裸 &lt;code&gt;l&lt;/code&gt; 手段恰好32位，虽然天然 &lt;code&gt;long&lt;/code&gt; 由本地C编译器看到的可能较大。这主要是在64位平台上的问题。您可以查看是否使用 &lt;code&gt;!&lt;/code&gt; 这种方式有什么不同：</target>
        </trans-unit>
        <trans-unit id="e28530f74a983b5b7c88ba8ea81f426cbf7efd7c" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="translated">整数类型 &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;L&lt;/code&gt; 后面可以跟有 &lt;code&gt;!&lt;/code&gt; 修饰符以指定本机短裤或多头。如该示例中所示的上方，一个裸 &lt;code&gt;l&lt;/code&gt; 手段恰好32位，虽然天然 &lt;code&gt;long&lt;/code&gt; 由本地C编译器看到的可能较大。这主要是在64位平台上的问题。您可以查看是否使用 &lt;code&gt;!&lt;/code&gt; 这种方式有什么不同：</target>
        </trans-unit>
        <trans-unit id="b9395373d953b00358ac2a4a8b3d6e5305da7861" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5708b037f56278734976c0deaf7b452666b9a4" translate="yes" xml:space="preserve">
          <source>The intended purpose of this routine is to concatenate</source>
          <target state="translated">这个例程的目的是连接</target>
        </trans-unit>
        <trans-unit id="35499217c3dc076a80a3d7b854f65596514d0493" translate="yes" xml:space="preserve">
          <source>The intent is simplicity of use, not power of expression. Paragraphs look like paragraphs (block format), so that they stand out visually, and so that I could run them through &lt;code&gt;fmt&lt;/code&gt; easily to reformat them (that's F7 in my version of &lt;b&gt;vi&lt;/b&gt;, or Esc Q in my version of &lt;b&gt;emacs&lt;/b&gt;). I wanted the translator to always leave the &lt;code&gt;'&lt;/code&gt; and &lt;code&gt;`&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; quotes alone, in verbatim mode, so I could slurp in a working program, shift it over four spaces, and have it print out, er, verbatim. And presumably in a monospace font.</source>
          <target state="translated">目的是使用简单，而不是表达能力。段落看起来像段落（块格式），以便它们在视觉上脱颖而出，以便我可以轻松地通过 &lt;code&gt;fmt&lt;/code&gt; 运行它们以重新格式化它们（在我的&lt;b&gt;vi&lt;/b&gt;版本中为F7，在我的&lt;b&gt;emacs&lt;/b&gt;版本中为Esc Q ）。我想翻译永远离开 &lt;code&gt;'&lt;/code&gt; 和 &lt;code&gt;`&lt;/code&gt; 和 &lt;code&gt;&quot;&lt;/code&gt; 报价独自一人，在逐字模式，这样我就可以在一个工作程序等宽发出声音，在四个空格转向它，并把它打印出来，呃，一字不差。想必字体。</target>
        </trans-unit>
        <trans-unit id="0fe331c074ca976ebd60519539ebf547e9a5979f" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt;, which can be set by any system call, this means that the value of the exit code used by &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ab1ae02bd72d53207c68855ddd39b0273ee3a8" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;code&gt;$!&lt;/code&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt; , which can be set by any system call, this means that the value of the exit code used by &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="translated">目的是将有关可能原因的尽可能多的信息压缩到系统出口代码的有限空间中。但是，作为 &lt;code&gt;$!&lt;/code&gt; 是C的 &lt;code&gt;errno&lt;/code&gt; 的值，可以通过任何系统调用来设置，这意味着 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 所使用的退出代码的值可能是不可预测的，因此除了不可为零以外，不应依赖于此。</target>
        </trans-unit>
        <trans-unit id="0547c3f088cded7d6e36027ba3384ed9126a4a35" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;code&gt;$!&lt;/code&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt; , which can be set by any system call, this means that the value of the exit code used by &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="translated">目的是将有关可能原因的尽可能多的信息压缩到系统出口代码的有限空间中。但是，作为 &lt;code&gt;$!&lt;/code&gt; 是C的 &lt;code&gt;errno&lt;/code&gt; 的值，可以通过任何系统调用来设置，这意味着 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 所使用的退出代码的值可能是不可预测的，因此除了不可为零以外，不应依赖于此。</target>
        </trans-unit>
        <trans-unit id="2e91002a8407b92abe1904ddf5c320e2e26254c0" translate="yes" xml:space="preserve">
          <source>The interaction with the Perl compilation happens inside package &lt;code&gt;myint&lt;/code&gt; :</source>
          <target state="translated">与Perl编译的交互发生在包 &lt;code&gt;myint&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="aadf28bb5828714b5bb46305e38581c5103da604" translate="yes" xml:space="preserve">
          <source>The interaction with the Perl compilation happens inside package &lt;code&gt;myint&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4116edd722cc9f90eb68f17a977fcbd1367d5c" translate="yes" xml:space="preserve">
          <source>The interactive debugger understands the following commands:</source>
          <target state="translated">交互式调试器能理解以下命令。</target>
        </trans-unit>
        <trans-unit id="99a3cf2098e457c2b3c584e37ad9ed7869d1340e" translate="yes" xml:space="preserve">
          <source>The interested reader might have seen a number of flags that signify encodings or codesets - &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;latin1&lt;/code&gt; and &lt;code&gt;ascii&lt;/code&gt;. There seems to be some confusion on what these do, so here is a short comparison:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70d776f0381bce09991021b76dd2d122db7ce29" translate="yes" xml:space="preserve">
          <source>The interesting thing about &lt;code&gt;&amp;amp;&lt;/code&gt; is that you can generate new syntax with it, provided it's in the initial position:</source>
          <target state="translated">关于 &lt;code&gt;&amp;amp;&lt;/code&gt; 的有趣之处在于，只要它处于初始位置，就可以使用它生成新的语法：</target>
        </trans-unit>
        <trans-unit id="2354b426f3be078a3ef57dbce0f8523b4f89323f" translate="yes" xml:space="preserve">
          <source>The interface defined by this module is missing some of the later additions to perl's debugging functionality. As such, this interface should be considered highly experimental and subject to change.</source>
          <target state="translated">这个模块所定义的接口缺少一些后来添加到perl的调试功能。因此,这个接口应该被认为是高度实验性的,并且可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="6bc76db195856b77ae9c9e32f58ddf5271ff9965" translate="yes" xml:space="preserve">
          <source>The interface exposed by this module is very close to the current implementation of restricted hashes. Over time it is expected that this behavior will be extended and the interface abstracted further.</source>
          <target state="translated">这个模块所暴露的接口非常接近当前限制性哈希的实现。随着时间的推移,预计这种行为将得到扩展,接口将进一步抽象化。</target>
        </trans-unit>
        <trans-unit id="25ed6271fa2a1e00048e3f70c7ae05b81e869ba4" translate="yes" xml:space="preserve">
          <source>The interface is a bit odd because this is the result of a quick refactoring. Don't rely on it.</source>
          <target state="translated">界面有点奇怪,因为这是快速重构的结果。不要依赖它。</target>
        </trans-unit>
        <trans-unit id="4f992c0404449ac096de07bc9c29b6b99091aebe" translate="yes" xml:space="preserve">
          <source>The interface provided by version 2 of this module should be 100% backward compatible with version 1. If you find a difference in the expected behaviour please contact the author (See &lt;a href=&quot;#AUTHOR&quot;&gt;&quot;AUTHOR&quot;&lt;/a&gt;). See &lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;&quot;GZIP INTERFACE&quot;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86fb605133e4937943b1ba063015c9eb55c6a1c4" translate="yes" xml:space="preserve">
          <source>The interface provided by version 2 of this module should be 100% backward compatible with version 1. If you find a difference in the expected behaviour please contact the author (See &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt;). See &lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;GZIP INTERFACE&lt;/a&gt;</source>
          <target state="translated">此模块的版本2提供的接口应与版本1 100％向后兼容。如果发现预期的行为有所不同，请与作者联系（请参阅&lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt;）。参见&lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;GZIP接口&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="869b0eb21cd8ea8a7cd6e0d3a06abffd6a4f3e9a" translate="yes" xml:space="preserve">
          <source>The interface provides two ways to calculate digests: all-at-once, or in stages. To illustrate, the following short program computes the SHA-256 digest of &quot;hello world&quot; using each approach:</source>
          <target state="translated">该接口提供了两种计算摘要的方法:一次全部计算,或者分阶段计算。为了说明这一点,下面的小程序使用两种方法计算 &quot;hello world &quot;的SHA-256摘要。</target>
        </trans-unit>
        <trans-unit id="fb22cb5dbe02d4f126e70eb38eba99f572c134f7" translate="yes" xml:space="preserve">
          <source>The interface to Exec in entirely encapsulated within the perl class, there is no need to access the low level methods directly and they are not exported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="506d079f3d8576c485b8b85a9995943fec82c8f8" translate="yes" xml:space="preserve">
          <source>The interface to the arexx.class in entirely encapsulated within the perl class, there is no need to access the low level methods directly and they are not exported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dedf705c01e5c3576fd3717e147541ecb372f63" translate="yes" xml:space="preserve">
          <source>The internal advisory locking is implemented using Perl's flock() routine. If your system does not support any form of flock(), or if you share your files across NFS, you might wish to use other forms of locking by using modules such as LockFile::Simple which lock a file using a filesystem entry, instead of locking the file descriptor.</source>
          <target state="translated">内部咨询锁定是通过Perl的flock()例程实现的。如果你的系统不支持任何形式的flock(),或者你在NFS上共享你的文件,你可能希望使用其他形式的锁定,使用诸如LockFile::Simple这样的模块来锁定文件,而不是锁定文件描述符。</target>
        </trans-unit>
        <trans-unit id="b695712dbfa2556923ae8104354e307b6dd7d107" translate="yes" xml:space="preserve">
          <source>The internal structure of version objects is a blessed hash with several components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798a90f8fceb3237e533c15e8087d7887afcfeb7" translate="yes" xml:space="preserve">
          <source>The internal variable for debugging support. The meanings of the various bits are subject to change, but currently indicate:</source>
          <target state="translated">内部变量,用于支持调试。各位的含义可能会改变,但目前表示:</target>
        </trans-unit>
        <trans-unit id="85c386c4c074fc2a85f669eb89082305e3dd4f12" translate="yes" xml:space="preserve">
          <source>The internals automatically clone any name with characters 128-255 but none 256+ (ie one that could be either in bytes or utf8) into a second entry which is utf8 encoded.</source>
          <target state="translated">内部程序会自动克隆任何有128-255字符但没有256+字符的名字(即可以是字节或utf8的名字)到第二条utf8编码的条目中。</target>
        </trans-unit>
        <trans-unit id="68038f581434d0080618601485190514733606bb" translate="yes" xml:space="preserve">
          <source>The interpretation of operations and values in Perl sometimes depends on the requirements of the context around the operation or value. There are two major contexts: list and scalar. Certain operations return list values in contexts wanting a list, and scalar values otherwise. If this is true of an operation it will be mentioned in the documentation for that operation. In other words, Perl overloads certain operations based on whether the expected return value is singular or plural. Some words in English work this way, like &quot;fish&quot; and &quot;sheep&quot;.</source>
          <target state="translated">在Perl中,对操作和值的解释有时取决于操作或值周围的上下文的要求。有两种主要的上下文:list 和 scalar。某些操作在需要列表的上下文中返回列表值,否则返回标量值。如果一个操作是如此,它将在该操作的文档中提到。换句话说,Perl会根据预期返回值是单数还是复数来重载某些操作。英语中的一些单词就是这样工作的,比如 &quot;fish &quot;和 &quot;sheep&quot;。</target>
        </trans-unit>
        <trans-unit id="061664239d0f872c4965463ddd59f598a09d06f0" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="translated">默认情况下，仅基于文件的模式以及用户的uid和gid来解释文件权限运算符 &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-R&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; ， &lt;code&gt;-W&lt;/code&gt; ， &lt;code&gt;-x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 。可能还有其他原因导致您无法实际读取，写入或执行文件：例如，网络文件系统访问控制，ACL（访问控制列表），只读文件系统和无法识别的可执行格式。请注意，使用这六个特定的运算符来验证是否可以进行某些操作通常是一个错误，因为它可能会出现竞争状况。</target>
        </trans-unit>
        <trans-unit id="de2595dbfaf95d22e9019632865663f297c76092" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="translated">默认情况下，仅基于文件的模式以及用户的uid和gid来解释文件权限运算符 &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-R&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; ， &lt;code&gt;-W&lt;/code&gt; ， &lt;code&gt;-x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 。可能还有其他原因导致您无法实际读取，写入或执行文件：例如，网络文件系统访问控制，ACL（访问控制列表），只读文件系统和无法识别的可执行格式。请注意，使用这六个特定的运算符来验证是否可以进行某些操作通常是一个错误，因为它可能会出现竞争状况。</target>
        </trans-unit>
        <trans-unit id="488736b34ccb462579468e7b97e0ddad7de84d1d" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;, and &lt;code&gt;-X&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e2e01e4adc3fb9225914fc17730078576e41c6" translate="yes" xml:space="preserve">
          <source>The inverse function to &lt;code&gt;pairs&lt;/code&gt;; this function takes a list of &lt;code&gt;ARRAY&lt;/code&gt; references containing two elements each, and returns a flattened list of the two values from each of the pairs, in order. This is notionally equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54a39a0dd2a9db45fcc8606c6b9dc540f8d071d" translate="yes" xml:space="preserve">
          <source>The inverse operation - packing byte contents from a string of hexadecimal digits - is just as easily written. For instance:</source>
          <target state="translated">反向操作--从一串十六进制数字中打包字节内容--也很容易写出来。例如</target>
        </trans-unit>
        <trans-unit id="8aacdda2a613fe684f7ff0ec49be15c7f7bad342" translate="yes" xml:space="preserve">
          <source>The is the number of bytes that the Storable header occupies.</source>
          <target state="translated">是指Storable头占用的字节数。</target>
        </trans-unit>
        <trans-unit id="e08f7fe6dcc4a4ede748bb6d3fcab7c9e89b331c" translate="yes" xml:space="preserve">
          <source>The issue of whether to pass the arguments in a hash or a hashref is largely a matter of personal style.</source>
          <target state="translated">在哈希中传递参数还是哈希夫中传递参数的问题,主要是个人风格的问题。</target>
        </trans-unit>
        <trans-unit id="1270f1d87441c40c65f184813fb9549f6a05140e" translate="yes" xml:space="preserve">
          <source>The item you want to look up. Nested modules (such as &lt;code&gt;File::Basename&lt;/code&gt; ) are specified either as &lt;code&gt;File::Basename&lt;/code&gt; or &lt;code&gt;File/Basename&lt;/code&gt; . You may also give a descriptive name of a page, such as &lt;code&gt;perlfunc&lt;/code&gt; . For URLs, HTTP and HTTPS are the only kind currently supported.</source>
          <target state="translated">您要查找的项目。嵌套模块（例如 &lt;code&gt;File::Basename&lt;/code&gt; ）被指定为 &lt;code&gt;File::Basename&lt;/code&gt; 或 &lt;code&gt;File/Basename&lt;/code&gt; 。您还可以提供页面的描述性名称，例如 &lt;code&gt;perlfunc&lt;/code&gt; 。对于URL，HTTP和HTTPS是当前唯一支持的类型。</target>
        </trans-unit>
        <trans-unit id="4344e301a9e97fdf3fc9733e6ebe72949a9af633" translate="yes" xml:space="preserve">
          <source>The item you want to look up. Nested modules (such as &lt;code&gt;File::Basename&lt;/code&gt;) are specified either as &lt;code&gt;File::Basename&lt;/code&gt; or &lt;code&gt;File/Basename&lt;/code&gt;. You may also give a descriptive name of a page, such as &lt;code&gt;perlfunc&lt;/code&gt;. For URLs, HTTP and HTTPS are the only kind currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fbe0de2b65f06cfcea380e50cf6bef09ae06281" translate="yes" xml:space="preserve">
          <source>The iterator used by &lt;code&gt;each&lt;/code&gt; is attached to the hash or array, and is shared between all iteration operations applied to the same hash or array. Thus all uses of &lt;code&gt;each&lt;/code&gt; on a single hash or array advance the same iterator location. All uses of &lt;code&gt;each&lt;/code&gt; are also subject to having the iterator reset by any use of &lt;code&gt;keys&lt;/code&gt; or &lt;code&gt;values&lt;/code&gt; on the same hash or array, or by the hash (but not array) being referenced in list context. This makes &lt;code&gt;each&lt;/code&gt;-based loops quite fragile: it is easy to arrive at such a loop with the iterator already part way through the object, or to accidentally clobber the iterator state during execution of the loop body. It's easy enough to explicitly reset the iterator before starting a loop, but there is no way to insulate the iterator state used by a loop from the iterator state used by anything else that might execute during the loop body. To avoid these problems, use a &lt;code&gt;foreach&lt;/code&gt; loop rather than &lt;code&gt;while&lt;/code&gt;-&lt;code&gt;each&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b950b023ee8eee0b58c44c704206373f4189c22c" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;&quot;~~&quot;&lt;/code&gt; allows you to override the smart matching logic used by the &lt;code&gt;~~&lt;/code&gt; operator and the switch construct (&lt;code&gt;given&lt;/code&gt; /&lt;code&gt;when&lt;/code&gt; ). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; and &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">键 &lt;code&gt;&quot;~~&quot;&lt;/code&gt; 使您可以覆盖 &lt;code&gt;~~&lt;/code&gt; 运算符和switch构造（ &lt;code&gt;given&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; ）使用的智能匹配逻辑。请参见&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsyn&lt;/a&gt;和&lt;a href=&quot;feature&quot;&gt;feature中的&lt;/a&gt;Switch语句。</target>
        </trans-unit>
        <trans-unit id="8a2c34ae8224e419d58656178fbc2e7d6c0054d2" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;&quot;~~&quot;&lt;/code&gt; allows you to override the smart matching logic used by the &lt;code&gt;~~&lt;/code&gt; operator and the switch construct (&lt;code&gt;given&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt;). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt; and &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c40c6befa9e830eefbf95715d61be0cceba411db" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;'-X'&lt;/code&gt; is used to specify a subroutine to handle all the filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on: see &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt; for the full list); it is not possible to overload any filetest operator individually. To distinguish them, the letter following the '-' is passed as the second argument (that is, in the slot that for binary operators is used to pass the second operand).</source>
          <target state="translated">键 &lt;code&gt;'-X'&lt;/code&gt; 用于指定一个子例程来处理所有文件测试运算符（ &lt;code&gt;-f&lt;/code&gt; ， &lt;code&gt;-x&lt;/code&gt; 等：完整列表请参见&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;）；不可能单独重载任何filetest运算符。为了区别它们，将&amp;ldquo;-&amp;rdquo;后的字母作为第二个参数传递（即在用于二进制运算符的插槽中传递第二个操作数）。</target>
        </trans-unit>
        <trans-unit id="d619e5f63abc98b8cfd8901f2a523fddccb94536" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;'-X'&lt;/code&gt; is used to specify a subroutine to handle all the filetest operators (&lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;, and so on: see &lt;a href=&quot;perlfunc#-X&quot;&gt;&quot;-X&quot; in perlfunc&lt;/a&gt; for the full list); it is not possible to overload any filetest operator individually. To distinguish them, the letter following the '-' is passed as the second argument (that is, in the slot that for binary operators is used to pass the second operand).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e57e8aa67b22950a3905dc0aca0c46d976bdaa4" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;key&lt;/code&gt; of &lt;code&gt;hv&lt;/code&gt; is deleted at the end of</source>
          <target state="translated">关键的 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;hv&lt;/code&gt; 在结束时被删除</target>
        </trans-unit>
        <trans-unit id="39231120b3a0f9f7321946d1dcf4e67b7cbb06d0" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;neg&lt;/code&gt; is used for unary minus to disambiguate it from binary &lt;code&gt;-&lt;/code&gt; .</source>
          <target state="translated">关键字 &lt;code&gt;neg&lt;/code&gt; 用于一元减号，以使其与二进制 &lt;code&gt;-&lt;/code&gt; 消除歧义。</target>
        </trans-unit>
        <trans-unit id="8014230ab511707fdf318f6f60f165829ac3a885" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;neg&lt;/code&gt; is used for unary minus to disambiguate it from binary &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af0ef3d95080a656a5a0ae273ae380c9667ee38" translate="yes" xml:space="preserve">
          <source>The key function is</source>
          <target state="translated">关键功能是</target>
        </trans-unit>
        <trans-unit id="890e53c79df507f41db3dd4d31cb915a4367afdd" translate="yes" xml:space="preserve">
          <source>The key here is the &lt;code&gt;nss_delete&lt;/code&gt; call. One workaround for this bug seems to be to create add to the file</source>
          <target state="translated">此处的关键是 &lt;code&gt;nss_delete&lt;/code&gt; 调用。解决该错误的一种方法是在文件中创建添加</target>
        </trans-unit>
        <trans-unit id="f07d5f582b98b9cdfa2323f91d8c44e6ee01e73a" translate="yes" xml:space="preserve">
          <source>The key is specified by</source>
          <target state="translated">钥匙由</target>
        </trans-unit>
        <trans-unit id="dbf499b463a1d246f5657c7bd10575193916c7a6" translate="yes" xml:space="preserve">
          <source>The key is specified by &lt;code&gt;keypv&lt;/code&gt; and &lt;code&gt;keylen&lt;/code&gt;. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;COPHH_KEY_UTF8&lt;/code&gt; bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. &lt;code&gt;hash&lt;/code&gt; is a precomputed hash of the key string, or zero if it has not been precomputed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4574cc32e125230b635f70eb51279af8024135" translate="yes" xml:space="preserve">
          <source>The keys allowed in each of these pre-defined references is limited to the names used in the equivalent C structure. So, for example, the $DB_HASH reference will only allow keys called &lt;code&gt;bsize&lt;/code&gt; , &lt;code&gt;cachesize&lt;/code&gt; , &lt;code&gt;ffactor&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;lorder&lt;/code&gt; and &lt;code&gt;nelem&lt;/code&gt; .</source>
          <target state="translated">这些预定义引用中的每个允许的键都限于等效C结构中使用的名称。因此，例如，在$ DB_HASH参考将只允许钥匙叫 &lt;code&gt;bsize&lt;/code&gt; ， &lt;code&gt;cachesize&lt;/code&gt; ， &lt;code&gt;ffactor&lt;/code&gt; ， &lt;code&gt;hash&lt;/code&gt; ， &lt;code&gt;lorder&lt;/code&gt; 和 &lt;code&gt;nelem&lt;/code&gt; 个。</target>
        </trans-unit>
        <trans-unit id="b2b4b1e7a4b07bed8f5dd49d279e3a199199b7a2" translate="yes" xml:space="preserve">
          <source>The keys allowed in each of these pre-defined references is limited to the names used in the equivalent C structure. So, for example, the $DB_HASH reference will only allow keys called &lt;code&gt;bsize&lt;/code&gt;, &lt;code&gt;cachesize&lt;/code&gt;, &lt;code&gt;ffactor&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;lorder&lt;/code&gt; and &lt;code&gt;nelem&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ed2e67811ac5de5639075023acf0cc2ec381bf" translate="yes" xml:space="preserve">
          <source>The keys in the bottom layer hash with the meanings of their values are:</source>
          <target state="translated">底层哈希中的键及其值的含义是。</target>
        </trans-unit>
        <trans-unit id="7d244bc64e243794d6821e1a0dcab4a24a9f05ad" translate="yes" xml:space="preserve">
          <source>The keys in the hash with the meanings of their values are:</source>
          <target state="translated">哈希中的键及其值的含义是:</target>
        </trans-unit>
        <trans-unit id="b936421bf8217d2a23b78502c20a19e381f28f92" translate="yes" xml:space="preserve">
          <source>The keys of &lt;code&gt;%-&lt;/code&gt; -like hashes correspond to all buffer names found in the regular expression; the keys of &lt;code&gt;%+&lt;/code&gt; -like hashes list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="translated">类似 &lt;code&gt;%-&lt;/code&gt; 的哈希键对应于在正则表达式中找到的所有缓冲区名称。类似于 &lt;code&gt;%+&lt;/code&gt; 的哈希键仅列出已捕获（并因此与定义的值相关联）的缓冲区的名称。</target>
        </trans-unit>
        <trans-unit id="997d8f5f7d84196f7ef0d41e7b97b099b732ef37" translate="yes" xml:space="preserve">
          <source>The keys of &lt;code&gt;%-&lt;/code&gt;-like hashes correspond to all buffer names found in the regular expression; the keys of &lt;code&gt;%+&lt;/code&gt;-like hashes list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780fac85dedcdee4447dcad5c8a8d6b15a9a2af1" translate="yes" xml:space="preserve">
          <source>The keys of &lt;code&gt;provides&lt;/code&gt; are package names that can be found within the distribution. If a package name key is provided, it must have a Map with the following valid subkeys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108fc2066c755818e3590f4d9c35e36d3cb855db" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;%+&lt;/code&gt; hash list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; 哈希的键仅列出已捕获（并因此与定义的值相关联）的缓冲区的名称。</target>
        </trans-unit>
        <trans-unit id="c4094ef8d037d1a4f33eb2e2deddaec00fa1265e" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;%-&lt;/code&gt; hash correspond to all buffer names found in the regular expression.</source>
          <target state="translated">&lt;code&gt;%-&lt;/code&gt; -hash 的键对应于在正则表达式中找到的所有缓冲区名称。</target>
        </trans-unit>
        <trans-unit id="cfdae1829d96426970bd25497a8e45b42e9a79f4" translate="yes" xml:space="preserve">
          <source>The keys of the hash will be the names of the entries in the directory. Reading a value from the hash will be the result of calling &lt;code&gt;File::stat::lstat&lt;/code&gt; . Deleting an element from the hash will delete the corresponding file or subdirectory, provided that &lt;code&gt;DIR_UNLINK&lt;/code&gt; is included in the &lt;code&gt;OPTIONS&lt;/code&gt; .</source>
          <target state="translated">哈希键将是目录中条目的名称。从哈希读取值将是调用 &lt;code&gt;File::stat::lstat&lt;/code&gt; 。如果在 &lt;code&gt;OPTIONS&lt;/code&gt; 中包含 &lt;code&gt;DIR_UNLINK&lt;/code&gt; ，则从哈希中删除元素将删除相应的文件或子目录。</target>
        </trans-unit>
        <trans-unit id="7764c6575d016ad4721493c64443d8e32ddb0474" translate="yes" xml:space="preserve">
          <source>The keys of the hash will be the names of the entries in the directory. Reading a value from the hash will be the result of calling &lt;code&gt;File::stat::lstat&lt;/code&gt;. Deleting an element from the hash will delete the corresponding file or subdirectory, provided that &lt;code&gt;DIR_UNLINK&lt;/code&gt; is included in the &lt;code&gt;OPTIONS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055987f11411d4374756daa33a787f39e5c8e2e5" translate="yes" xml:space="preserve">
          <source>The keys of this hash are the names of all the known subroutines. Each value is an encoded string that has the sprintf(3) format &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt; .</source>
          <target state="translated">该哈希的关键字是所有已知子例程的名称。每个值都是具有sprintf（3）格式的编码字符串 &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99eed0ed09082d94a43f5eb252bf07930e49246a" translate="yes" xml:space="preserve">
          <source>The keys of this hash are the names of all the known subroutines. Each value is an encoded string that has the sprintf(3) format &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3904530800da7eda131d2f33bddbe47a09140ae0" translate="yes" xml:space="preserve">
          <source>The kind of computer you&amp;rsquo;re working on, where one &amp;ldquo;kind of computer&amp;rdquo; means all those computers sharing a compatible machine language. Since Perl programs are (typically) simple text files, not executable images, a Perl program is much less sensitive to the architecture it&amp;rsquo;s running on than programs in other languages, such as C, that are &lt;b&gt;compiled&lt;/b&gt; into machine code. See also &lt;b&gt;platform&lt;/b&gt; and &lt;b&gt;operating system&lt;/b&gt;.</source>
          <target state="translated">您正在使用的计算机类型，其中&amp;ldquo;一种计算机&amp;rdquo;表示所有共享相同机器语言的计算机。由于Perl程序（通​​常）是简单的文本文件，而不是可执行图像，因此，Perl程序对其运行的体系结构的敏感性要比其他语言（如C）&lt;b&gt;编译&lt;/b&gt;为机器代码的程序低。另请参阅&lt;b&gt;平台&lt;/b&gt;和&lt;b&gt;操作系统&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="af5d08a24c9445659f44e97ac90d397b8dd843c2" translate="yes" xml:space="preserve">
          <source>The known import symbols are the &lt;code&gt;:gzip_external&lt;/code&gt; , &lt;code&gt;:gzip_read_open&lt;/code&gt; , and &lt;code&gt;:gzip_write_open&lt;/code&gt; . Anything else is not recognized.</source>
          <target state="translated">已知的导入符号是 &lt;code&gt;:gzip_external&lt;/code&gt; ， &lt;code&gt;:gzip_read_open&lt;/code&gt; 和 &lt;code&gt;:gzip_write_open&lt;/code&gt; 。其他没有被识别。</target>
        </trans-unit>
        <trans-unit id="f60d39e599c1ed70fbcd2d9685b7a2c305ef74b7" translate="yes" xml:space="preserve">
          <source>The known import symbols are the &lt;code&gt;:gzip_external&lt;/code&gt;, &lt;code&gt;:gzip_read_open&lt;/code&gt;, and &lt;code&gt;:gzip_write_open&lt;/code&gt;. Anything else is not recognized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad665994ad3405e05efc579c556de49d4423595" translate="yes" xml:space="preserve">
          <source>The label of the statement or block the OP is the start of, if any.</source>
          <target state="translated">如果有的话,上位机是声明或块的标签。</target>
        </trans-unit>
        <trans-unit id="147bc8ea909cecad4fb730859bb2907f9623910d" translate="yes" xml:space="preserve">
          <source>The lack of processing of &lt;code&gt;\\&lt;/code&gt; creates specific restrictions on the post-processed text. If the delimiter is &lt;code&gt;/&lt;/code&gt;, one cannot get the combination &lt;code&gt;\/&lt;/code&gt; into the result of this step. &lt;code&gt;/&lt;/code&gt; will finish the regular expression, &lt;code&gt;\/&lt;/code&gt; will be stripped to &lt;code&gt;/&lt;/code&gt; on the previous step, and &lt;code&gt;\\/&lt;/code&gt; will be left as is. Because &lt;code&gt;/&lt;/code&gt; is equivalent to &lt;code&gt;\/&lt;/code&gt; inside a regular expression, this does not matter unless the delimiter happens to be character special to the RE engine, such as in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s*foo*bar*&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m[foo]&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;?foo?&lt;/code&gt; ; or an alphanumeric char, as in:</source>
          <target state="translated">缺少对 &lt;code&gt;\\&lt;/code&gt; 的处理会对后处理的文本产生特定的限制。如果定界符为 &lt;code&gt;/&lt;/code&gt; ，则无法将组合 &lt;code&gt;\/&lt;/code&gt; 放入此步骤的结果中。 &lt;code&gt;/&lt;/code&gt; 将完成正则表达式， &lt;code&gt;\/&lt;/code&gt; 将在上一步中剥离到 &lt;code&gt;/&lt;/code&gt; ，而 &lt;code&gt;\\/&lt;/code&gt; 将保持不变。因为 &lt;code&gt;/&lt;/code&gt; 等价于正则表达式内的 &lt;code&gt;\/&lt;/code&gt; ，所以这无关紧要，除非分隔符恰好是RE引擎专用的字符，例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s*foo*bar*&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m[foo]&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;?foo?&lt;/code&gt; 。 ;或字母数字字符，例如：</target>
        </trans-unit>
        <trans-unit id="552da7166581dad2c401fcf7fae959ad601a8345" translate="yes" xml:space="preserve">
          <source>The lack of processing of &lt;code&gt;\\&lt;/code&gt; creates specific restrictions on the post-processed text. If the delimiter is &lt;code&gt;/&lt;/code&gt;, one cannot get the combination &lt;code&gt;\/&lt;/code&gt; into the result of this step. &lt;code&gt;/&lt;/code&gt; will finish the regular expression, &lt;code&gt;\/&lt;/code&gt; will be stripped to &lt;code&gt;/&lt;/code&gt; on the previous step, and &lt;code&gt;\\/&lt;/code&gt; will be left as is. Because &lt;code&gt;/&lt;/code&gt; is equivalent to &lt;code&gt;\/&lt;/code&gt; inside a regular expression, this does not matter unless the delimiter happens to be character special to the RE engine, such as in &lt;code&gt;s*foo*bar*&lt;/code&gt;, &lt;code&gt;m[foo]&lt;/code&gt;, or &lt;code&gt;m?foo?&lt;/code&gt;; or an alphanumeric char, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc7f7d746e559a86f68b3adb7a4d97f4b51af95" translate="yes" xml:space="preserve">
          <source>The langinfo() function is just a wrapper for the C nl_langinfo() interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11a57a26c23b0ae665c99897a59d6791986dbc2" translate="yes" xml:space="preserve">
          <source>The langinfo() function queries various locale information that can be used to localize output and user interfaces. It uses the current underlying locale, regardless of whether or not it was called from within the scope of &lt;code&gt;use locale&lt;/code&gt;. The langinfo() function requires one numeric argument that identifies the locale constant to query: if no argument is supplied, &lt;code&gt;$_&lt;/code&gt; is used. The numeric constants appropriate to be used as arguments are exportable from I18N::Langinfo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329bfa336d3d2c69ff7cf1363d051c82b14482d1" translate="yes" xml:space="preserve">
          <source>The langinfo() function queries various locale information that can be used to localize output and user interfaces. The langinfo() requires one numeric argument that identifies the locale constant to query: if no argument is supplied, &lt;code&gt;$_&lt;/code&gt; is used. The numeric constants appropriate to be used as arguments are exportable from I18N::Langinfo.</source>
          <target state="translated">langinfo（）函数查询各种可用于本地化输出和用户界面的语言环境信息。 langinfo（）需要一个数字参数来标识要查询的语言环境常量：如果未提供任何参数，则使用 &lt;code&gt;$_&lt;/code&gt; 。可从I18N :: Langinfo导出适合用作参数的数字常量。</target>
        </trans-unit>
        <trans-unit id="4ed86afb0e8b9f19c52713fc505ca8e2e35f2532" translate="yes" xml:space="preserve">
          <source>The langinfo() is just a wrapper for the C nl_langinfo() interface.</source>
          <target state="translated">langinfo()只是C语言nl_langinfo()接口的一个包装器。</target>
        </trans-unit>
        <trans-unit id="5d6f822e607c368c541adb8e9be9fa017016c7dd" translate="yes" xml:space="preserve">
          <source>The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal). It combines (in the author's opinion, anyway) some of the best features of &lt;b&gt;sed&lt;/b&gt;, &lt;b&gt;awk&lt;/b&gt;, and &lt;b&gt;sh&lt;/b&gt;, making it familiar and easy to use for Unix users to whip up quick solutions to annoying problems. Its general-purpose programming facilities support procedural, functional, and object-oriented programming paradigms, making Perl a comfortable language for the long haul on major projects, whatever your bent.</source>
          <target state="translated">该语言旨在实用（易于使用，高效，完整），而不是美观（小巧，优雅，简约）。它结合了（无论如何，以作者的观点）&lt;b&gt;sed&lt;/b&gt;，&lt;b&gt;awk&lt;/b&gt;和&lt;b&gt;sh的&lt;/b&gt;一些最佳功能，从而使Unix用户熟悉并易于使用，以快速解决烦人的问题。它的通用编程工具支持过程，函数和面向对象的编程范例，这使Perl成为长期从事大型项目的舒适语言，无论您喜欢什么。</target>
        </trans-unit>
        <trans-unit id="80a9351ce80597f624479310f1723e625f630d11" translate="yes" xml:space="preserve">
          <source>The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal). Its major features are that it's easy to use, supports both procedural and object-oriented (OO) programming, has powerful built-in support for text processing, and has one of the world's most impressive collections of third-party modules.</source>
          <target state="translated">该语言的目的是实用(易用、高效、完整)而不是美观(微小、优雅、简约)。它的主要特点是使用方便,支持程序化和面向对象(OO)编程,对文本处理有强大的内置支持,并拥有世界上最令人印象深刻的第三方模块集合之一。</target>
        </trans-unit>
        <trans-unit id="80efcc67009b4f458fbcd0e166207fe80337c34a" translate="yes" xml:space="preserve">
          <source>The language used is chosen from the loc_lang call. If a lookup is not possible, the i-default language will be used. If the lookup is not in the i-default language, then the key will be returned.</source>
          <target state="translated">所使用的语言是从 loc_lang 调用中选择的。如果无法进行查找,则使用i-default语言。如果查询的语言不是i-default语言,那么将返回密钥。</target>
        </trans-unit>
        <trans-unit id="fba6e11da7ba55d0215680ecc246683e4db3e510" translate="yes" xml:space="preserve">
          <source>The large file compilation environment is obtained with</source>
          <target state="translated">大文件编译环境是通过</target>
        </trans-unit>
        <trans-unit id="9d7ccfee30c3456085edda4007d3ffab9032209b" translate="yes" xml:space="preserve">
          <source>The largest acceptable code point is the Unicode maximum 0x10FFFF, and must not be a surrogate nor a non-character code point. Thus this excludes any code point from Perl's extended UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0842cd9650e7d459b2b787beb02fa153564ea6" translate="yes" xml:space="preserve">
          <source>The largest acceptable code point is the Unicode maximum 0x10FFFF. This differs from &lt;code&gt;&lt;a href=&quot;#isSTRICT_UTF8_CHAR&quot;&gt;&quot;isSTRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; only in that it accepts non-character code points. This corresponds to &lt;a href=&quot;http://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode Corrigendum #9&lt;/a&gt;. which said that non-character code points are merely discouraged rather than completely forbidden in open interchange. See &lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;&quot;Noncharacter code points&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c14ad6f7057f3647ab0ef224e2d72569a519808" translate="yes" xml:space="preserve">
          <source>The largest code point that is representable in UTF-EBCDIC is U+7FFF_FFFF. If you do &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; on a larger value, a runtime error (similar to division by 0) will happen.</source>
          <target state="translated">UTF-EBCDIC中可表示的最大代码点是U + 7FFF_FFFF。如果对较大的值执行 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; ，则会发生运行时错误（类似于除以0）。</target>
        </trans-unit>
        <trans-unit id="81c48ef57866e1c8154c2bdc64ad152dcbc81938" translate="yes" xml:space="preserve">
          <source>The largest code point that is representable in UTF-EBCDIC is U+7FFF_FFFF. If you try to pack a larger value into a character, a runtime error (similar to division by 0) will happen.</source>
          <target state="translated">UTF-EBCDIC中最大的代码点是U+7FFF_FFFF。如果你试图在一个字符中加入一个更大的值,就会发生一个运行时错误(类似于除以0)。</target>
        </trans-unit>
        <trans-unit id="e2cfb7719205bc05d873fbbc8977b16754d06f9e" translate="yes" xml:space="preserve">
          <source>The last &lt;b&gt;filehandle&lt;/b&gt; that was designated with &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select(FILEHANDLE)&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;STDOUT&lt;/code&gt; , if no filehandle has been selected.</source>
          <target state="translated">用 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select(FILEHANDLE)&lt;/a&gt;&lt;/code&gt; 指定的最后一个&lt;b&gt;文件句柄&lt;/b&gt;； &lt;code&gt;STDOUT&lt;/code&gt; ，如果尚未选择文件句柄。</target>
        </trans-unit>
        <trans-unit id="3778b44d76009b0ef5e1852751bc0831ec54a4e5" translate="yes" xml:space="preserve">
          <source>The last &lt;b&gt;filehandle&lt;/b&gt; that was designated with &lt;code&gt;select(FILEHANDLE)&lt;/code&gt;; &lt;code&gt;STDOUT&lt;/code&gt;, if no filehandle has been selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37441ece1fc3c98a0c6e1bb548dacae86d8fdd9" translate="yes" xml:space="preserve">
          <source>The last and final version of PA-RISC is 2.0, HP no longer sells any system with these CPU's.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544feb1340389177d3430ba94574fe7a8a59484b" translate="yes" xml:space="preserve">
          <source>The last argument is always considered to be the file portion. Since &lt;code&gt;catfile()&lt;/code&gt; uses &lt;code&gt;catdir()&lt;/code&gt; (see above) for the concatenation of the directory portions (if any), the following with regard to relative and absolute paths is true:</source>
          <target state="translated">最后一个参数始终被认为是文件部分。由于 &lt;code&gt;catfile()&lt;/code&gt; 使用 &lt;code&gt;catdir()&lt;/code&gt; （请参见上文）来串联目录部分（如果有），因此以下有关相对路径和绝对路径的设置为true：</target>
        </trans-unit>
        <trans-unit id="3d5ec4d10744144f22c4f4ea812b28436c8dedd9" translate="yes" xml:space="preserve">
          <source>The last example illustrates another feature of threads. You can spawn off several threads using the same subroutine. Each thread executes the same subroutine, but in a separate thread with a separate environment and potentially separate arguments.</source>
          <target state="translated">最后一个例子说明了线程的另一个特性。你可以使用同一个子程序衍生出多个线程。每个线程都执行同一个子程序,但在一个单独的线程中,有单独的环境和可能的单独参数。</target>
        </trans-unit>
        <trans-unit id="3a9ec3805e1d8d03ada9f35c7b038f53ba566eb8" translate="yes" xml:space="preserve">
          <source>The last example is very slow and outputs extra progress indicators that break the alignment of the result.</source>
          <target state="translated">最后一个例子非常慢,而且输出额外的进度指标,打破了结果的排列。</target>
        </trans-unit>
        <trans-unit id="d7140144abdabb3a340f6e7a9626f45a3f6e90a9" translate="yes" xml:space="preserve">
          <source>The last example points out that character classes are like alternations of characters. At a given character position, the first alternative that allows the regexp match to succeed will be the one that matches.</source>
          <target state="translated">最后一个例子指出,字符类就像字符的交替。在一个给定的字符位置,第一个让regexp匹配成功的备选方案将是匹配的。</target>
        </trans-unit>
        <trans-unit id="8ff092050a74224fa6cfcc69192829226bfd39ef" translate="yes" xml:space="preserve">
          <source>The last example should print:</source>
          <target state="translated">最后一个例子应该是打印的。</target>
        </trans-unit>
        <trans-unit id="d1b1f35817845b0ebf71ac4a0203b5b76bf2839d" translate="yes" xml:space="preserve">
          <source>The last example shows a match with an &lt;code&gt;'i'&lt;/code&gt;&lt;b&gt;modifier&lt;/b&gt;, which makes the match case-insensitive.</source>
          <target state="translated">最后一个示例显示了带有 &lt;code&gt;'i'&lt;/code&gt; &lt;b&gt;修饰符&lt;/b&gt;的匹配项，该匹配项不区分大小写。</target>
        </trans-unit>
        <trans-unit id="e71d02e5faff1a1d5185411ef0df70f32d8f6d20" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regex and replacement are treated as single-quoted strings.</source>
          <target state="translated">最后一个示例显示 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 可以使用其他定界符，例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; ，甚至 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; 。如果使用单引号 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; ，则将正则表达式和替换项视为单引号字符串。</target>
        </trans-unit>
        <trans-unit id="1c93c3433d587d711bbae225f518d07bf79a7bfc" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;code&gt;s///&lt;/code&gt; can use other delimiters, such as &lt;code&gt;s!!!&lt;/code&gt; and &lt;code&gt;s{}{}&lt;/code&gt;, and even &lt;code&gt;s{}//&lt;/code&gt;. If single quotes are used &lt;code&gt;s'''&lt;/code&gt;, then the regex and replacement are treated as single-quoted strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301cab1c29ad0c90c0fe8b5c51d14a74f03d135a" translate="yes" xml:space="preserve">
          <source>The last form sets the error returned by future calls to &lt;code&gt;fileLastError()&lt;/code&gt; and should not be used often. &lt;code&gt;$uError&lt;/code&gt; must be a numeric error code. Also returns the dual-valued version of &lt;code&gt;$uError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38175234fbd8da1fcb9cc33577b554c9cf1a8cdf" translate="yes" xml:space="preserve">
          <source>The last four modifiers listed above, added in Perl 5.14, control the character set rules, but &lt;code&gt;/a&lt;/code&gt; is the only one you are likely to want to specify explicitly; the other three are selected automatically by various pragmas.</source>
          <target state="translated">上面列出的最后四个修饰符是在Perl 5.14中添加的，它们控制字符集规则，但是 &lt;code&gt;/a&lt;/code&gt; 是您可能希望明确指定的唯一修饰符；其他三个则由各种实用程序自动选择。</target>
        </trans-unit>
        <trans-unit id="5b14495e6536f39321b81d2ad45a9b35a4c183b7" translate="yes" xml:space="preserve">
          <source>The last is particularly useful because it knows about machine-dependent architectures. The &lt;code&gt;lib.pm&lt;/code&gt; pragmatic module was first included with the 5.002 release of Perl.</source>
          <target state="translated">最后一个特别有用，因为它了解与机器有关的体系结构。该 &lt;code&gt;lib.pm&lt;/code&gt; 务实模块首次被列入与5.002版本的Perl。</target>
        </trans-unit>
        <trans-unit id="dee33a8bbee7fed8c390da45a40b2881511f80ec" translate="yes" xml:space="preserve">
          <source>The last item listed (SUNWhea in this example) is the package you need.</source>
          <target state="translated">最后一项(本例中的SUNWhea)是你需要的包。</target>
        </trans-unit>
        <trans-unit id="249e46d8e31e329b6f35d0380e06e9e88206bbb4" translate="yes" xml:space="preserve">
          <source>The last order date for HP 9000 systems was December 31, 2008.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f01afddbe80c4c268f0bac95652fd735743f86" translate="yes" xml:space="preserve">
          <source>The last rites performed by a parent &lt;b&gt;process&lt;/b&gt; on behalf of a deceased child process so that it doesn&amp;rsquo;t remain a &lt;b&gt;zombie&lt;/b&gt;. See the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; function calls.</source>
          <target state="translated">父&lt;b&gt;进程&lt;/b&gt;代表死者的子进程进行的最后一次仪式，这样它不会成为&lt;b&gt;僵尸&lt;/b&gt;。请参见 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 函数调用。</target>
        </trans-unit>
        <trans-unit id="57c0ac80818903e3f90bc72e811a2effb575b793" translate="yes" xml:space="preserve">
          <source>The last rites performed by a parent &lt;b&gt;process&lt;/b&gt; on behalf of a deceased child process so that it doesn&amp;rsquo;t remain a &lt;b&gt;zombie&lt;/b&gt;. See the &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;waitpid&lt;/code&gt; function calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc5a9dc56cbe77d2375a5e43361dd33676d7edc" translate="yes" xml:space="preserve">
          <source>The last three slots are a recent addition, and for source code compatibility they are only checked for if one of the three flags MGf_COPY, MGf_DUP or MGf_LOCAL is set in mg_flags. This means that most code can continue declaring a vtable as a 5-element value. These three are currently used exclusively by the threading code, and are highly subject to change.</source>
          <target state="translated">最后三个槽是最近增加的,为了保证源代码的兼容性,只有在mg_flags中设置了MGf、MGf_DUP或MGf_LOCAL三个标志之一时,才会对它们进行检查。这意味着大多数代码可以继续将一个vtable声明为一个5元素值。这三个标志目前只由线程代码使用,极有可能发生变化。</target>
        </trans-unit>
        <trans-unit id="0f2130944a7df2b125d5d6b5739b2f67242c3907" translate="yes" xml:space="preserve">
          <source>The last time the test program passed, in seconds from the epoch.</source>
          <target state="translated">测试程序最后一次通过的时间,从时间点算起,以秒为单位。</target>
        </trans-unit>
        <trans-unit id="21878c9b3f2934bab56f2ab1ab4a5f355bfffef3" translate="yes" xml:space="preserve">
          <source>The last time the test suite failed, in seconds from the epoch.</source>
          <target state="translated">测试套件最后一次失败的时间,从时间点算起,以秒为单位。</target>
        </trans-unit>
        <trans-unit id="c8d2323b355b183370e8260c625d724458199602" translate="yes" xml:space="preserve">
          <source>The last topic of Part 1 briefly covers how regexps are used in Perl programs. Where do they fit into Perl syntax?</source>
          <target state="translated">第1部分的最后一个主题简要介绍了如何在Perl程序中使用regexps。它们在Perl语法中的地位如何?</target>
        </trans-unit>
        <trans-unit id="b9c1bf499a546862f7d3dd462a65d36e8e01021a" translate="yes" xml:space="preserve">
          <source>The last two are a little tricky. In &lt;code&gt;[\$x]&lt;/code&gt; , the backslash protects the dollar sign, so the character class has two members &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; . In &lt;code&gt;[\\$x]&lt;/code&gt; , the backslash is protected, so &lt;code&gt;$x&lt;/code&gt; is treated as a variable and substituted in double quote fashion.</source>
          <target state="translated">最后两个有点棘手。在 &lt;code&gt;[\$x]&lt;/code&gt; ，反斜杠保护美元符号，因此字符类具有两个成员 &lt;code&gt;$&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 。在 &lt;code&gt;[\\$x]&lt;/code&gt; ，反斜杠受保护，因此 &lt;code&gt;$x&lt;/code&gt; 被视为变量并以双引号形式替换。</target>
        </trans-unit>
        <trans-unit id="8da4297e9e11b0bed733e96e0a5ce5a0d837c05e" translate="yes" xml:space="preserve">
          <source>The last two are a little tricky. In &lt;code&gt;[\$x]&lt;/code&gt;, the backslash protects the dollar sign, so the character class has two members &lt;code&gt;'$'&lt;/code&gt; and &lt;code&gt;'x'&lt;/code&gt;. In &lt;code&gt;[\\$x]&lt;/code&gt;, the backslash is protected, so &lt;code&gt;$x&lt;/code&gt; is treated as a variable and substituted in double quote fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a00c9f7ecacbf4d6fa87dfc5eecfd61397b17fd" translate="yes" xml:space="preserve">
          <source>The last two constructs may appear unintuitive to most people. The first repeatedly grows a string, whereas the second allocates a large chunk of memory in one go. On some systems, the second is more efficient than the first.</source>
          <target state="translated">最后两个结构对大多数人来说可能显得不直观。第一个结构是重复增长一个字符串,而第二个结构是一次性分配一大块内存。在某些系统上,第二种比第一种更有效率。</target>
        </trans-unit>
        <trans-unit id="701c321a0a2054ebe884423f3ddbe3fca4e7d084" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. (If your platform has a real &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt;, such as Linux and macOS, you can use the list form; it also works on Windows with Perl 5.22 or later.) You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3180c758450e8b48f9775fac7e74a8e6da633b" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="translated">每个块中的最后两个示例将管道显示为&amp;ldquo;列表形式&amp;rdquo;，并非所有平台都支持该形式。一个好的经验法则是，如果您的平台上有一个真正的 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; （换句话说，如果您的平台是Unix，包括Linux和MacOS X），则可以使用列表形式。您可能希望使用管道的列表形式，以便您可以将文字参数传递给命令，而无需外壳解释其中的任何外壳元字符的风险。但是，这也使您无法从打开管道到故意包含外壳元字符的命令，例如：</target>
        </trans-unit>
        <trans-unit id="224277da0631dd2948d98eac0e58b508ae236071" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="translated">每个块中的最后两个示例将管道显示为&amp;ldquo;列表形式&amp;rdquo;，并非所有平台都支持该形式。一个好的经验法则是，如果您的平台上有一个真正的 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; （换句话说，如果您的平台是Unix，包括Linux和MacOS X），则可以使用列表形式。您可能希望使用管道的列表形式，以便您可以将文字参数传递给命令，而无需外壳解释其中的任何外壳元字符的风险。但是，这也使您无法从打开管道到故意包含外壳元字符的命令，例如：</target>
        </trans-unit>
        <trans-unit id="bb538ba5316dfdb33cebda21455c3214d556eb70" translate="yes" xml:space="preserve">
          <source>The last two were added in Perl 5.22.</source>
          <target state="translated">最后两个是在Perl 5.22中加入的。</target>
        </trans-unit>
        <trans-unit id="631d7a78fc9992a33bb8f42345d827210e402509" translate="yes" xml:space="preserve">
          <source>The last type of L structure is for links to/within Pod documents. It is the most complex because it can have a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea40dd6a00c5982372bccbdaaeeb63948e0cf1b4" translate="yes" xml:space="preserve">
          <source>The later gives you some idea of what failed. It also makes it easier to find the test in your script, simply search for &quot;simple exponential&quot;.</source>
          <target state="translated">后面的内容让你知道什么地方失败了。这也使你更容易在脚本中找到测试,只需搜索 &quot;简单指数&quot;。</target>
        </trans-unit>
        <trans-unit id="263e6dbf8c2da6cc4831ea57d73cd01c49808e34" translate="yes" xml:space="preserve">
          <source>The latest</source>
          <target state="translated">最新的</target>
        </trans-unit>
        <trans-unit id="d3a60275112428b3ca0987c2c55a45bca5bde073" translate="yes" xml:space="preserve">
          <source>The latest Net::Ping release can be found at CPAN:</source>
          <target state="translated">最新的Net::Ping版本可以在CPAN找到。</target>
        </trans-unit>
        <trans-unit id="7b2e54c1e5a52bb047587bf92489f8f96027d992" translate="yes" xml:space="preserve">
          <source>The latest Net::Ping releases are included in cperl and perl5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874b36774125604150e5f59fd5253e7e8be8da9e" translate="yes" xml:space="preserve">
          <source>The latest Perl release (5.22.0 as of this writing) builds without changes under all versions of Mac OS X from 10.3 &quot;Panther&quot; onwards.</source>
          <target state="translated">最新的Perl版本(截至本文撰写时为5.22.0)在10.3 &quot;Panther &quot;以后的所有版本的Mac OS X上都能正常运行。</target>
        </trans-unit>
        <trans-unit id="064e946234db5ecc10d952d435ad39de892add96" translate="yes" xml:space="preserve">
          <source>The latest Perl release (5.32.0 as of this writing) builds without changes under all versions of Mac OS X from 10.3 &quot;Panther&quot; onwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfa4e030032052fa74752414fc7476dcdaf2c76" translate="yes" xml:space="preserve">
          <source>The latest libnet release is always on CPAN, you will find it in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc4f25838809cd7645317e2cc9e7753babbc628" translate="yes" xml:space="preserve">
          <source>The latest source tree is available via cvs:</source>
          <target state="translated">最新的源码树可以通过cvs.com获取。</target>
        </trans-unit>
        <trans-unit id="3373e831da21b443a04c03079b0c28bf4785000a" translate="yes" xml:space="preserve">
          <source>The latest source tree is available via git:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf89850a166f6a4ee0978de00ea5e89c74558d84" translate="yes" xml:space="preserve">
          <source>The latest versions are probably the least deployed and widely tested, so you may want to wait a few months after their release and see what problems others have if you are risk averse.</source>
          <target state="translated">最新的版本可能是部署最少、测试最广泛的版本,所以如果你想规避风险,不妨在其发布几个月后再看看别人有什么问题。</target>
        </trans-unit>
        <trans-unit id="283b07d7f4b68277645e0b52df897e2c505c20d3" translate="yes" xml:space="preserve">
          <source>The latest versions of perl have more bug fixes.</source>
          <target state="translated">最新版本的perl有更多的bug修复。</target>
        </trans-unit>
        <trans-unit id="5c3562f1019a54d151d180b0074eac428ec1b539" translate="yes" xml:space="preserve">
          <source>The latest versions of perl may contain performance improvements and features not present in older versions. There have been many changes in perl since perl5 was first introduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1651bfa501667c3bfa8d542631578218de1ab189" translate="yes" xml:space="preserve">
          <source>The latter is equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d373e425dea350cf42b44329f2372765cae74bb5" translate="yes" xml:space="preserve">
          <source>The latter pattern would be a character class consisting of a colon, and the letters &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt; .</source>
          <target state="translated">后一种模式是由冒号和字母 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; ， &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;h&lt;/code&gt; 组成的字符类。</target>
        </trans-unit>
        <trans-unit id="9695d45b272c946f52b02905e21523ca5bea55db" translate="yes" xml:space="preserve">
          <source>The latter pattern would be a character class consisting of a colon, and the letters &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e4aff4d2758e888da3bc5afffc2587abdc395f" translate="yes" xml:space="preserve">
          <source>The lax criteria corresponds to what is currently allowed by the version parser. All of the following formats are acceptable for dotted-decimal formats strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a94f6519fd2ea2b5da884bb4c80f8058226b090" translate="yes" xml:space="preserve">
          <source>The layer is acceptable to have in a binmode(FH) stack - i.e. it does not (or will configure itself not to) transform bytes passing through it.</source>
          <target state="translated">该层在binmode(FH)堆栈中是可以接受的--即它不会(或将自己配置为不会)转换通过它的字节。</target>
        </trans-unit>
        <trans-unit id="1281105f1d2923419cef70eff9c7bbaca9c31ca4" translate="yes" xml:space="preserve">
          <source>The layer is buffered.</source>
          <target state="translated">层的缓冲。</target>
        </trans-unit>
        <trans-unit id="aa6e981b462c3b07834414b5da8720376a618be1" translate="yes" xml:space="preserve">
          <source>The layers are returned in the order an open() or binmode() call would use them, and without colons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2977795d28c25d6eee9e0faa6c0a67b12612914" translate="yes" xml:space="preserve">
          <source>The layers are returned in the order an open() or binmode() call would use them. Note that the &quot;default stack&quot; depends on the operating system and on the Perl version, and both the compile-time and runtime configurations of Perl.</source>
          <target state="translated">这些层会按照open()或binmode()调用使用它们的顺序返回。请注意,&quot;默认堆栈 &quot;取决于操作系统和Perl版本,以及Perl的编译时和运行时配置。</target>
        </trans-unit>
        <trans-unit id="b3e7d5b78b27ea298f2a1cae1408ae86359ba800" translate="yes" xml:space="preserve">
          <source>The lddlflags addition is the only abnormal bit.</source>
          <target state="translated">lddlflags的添加是唯一的异常位。</target>
        </trans-unit>
        <trans-unit id="7eced80f21a0420b25c8520fadd19d07b97b6f61" translate="yes" xml:space="preserve">
          <source>The leading 'v' is optional if two or more decimals appear. If only a single decimal is included, then the leading 'v' is required to trigger the dotted-decimal parsing. A leading zero is permitted, though not recommended except when quoted, because of the risk that Perl will treat the number as octal. A trailing underscore plus one or more digits denotes an alpha or development release (and must be quoted to be parsed properly).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff5a5e9eacb7b6806eb625ddd8923ff29d2efc5" translate="yes" xml:space="preserve">
          <source>The leading &lt;code&gt;+{&lt;/code&gt; and &lt;code&gt;{;&lt;/code&gt; always serve to disambiguate the expression to mean either the HASH reference, or the BLOCK.</source>
          <target state="translated">前导 &lt;code&gt;+{&lt;/code&gt; 和 &lt;code&gt;{;&lt;/code&gt; 始终用于消除表示HASH引用或BLOCK的歧义。</target>
        </trans-unit>
        <trans-unit id="d4369969cfc835357a0f9f590f26252ba7f58c0e" translate="yes" xml:space="preserve">
          <source>The left hand side of the method invocation (or arrow) operator is the object (or class name), and the right hand side is the method name.</source>
          <target state="translated">方法调用(或箭头)运算符的左边是对象(或类名),右边是方法名。</target>
        </trans-unit>
        <trans-unit id="2a9cac37843dad5a4ff70fbd9f8ea25d75266dcb" translate="yes" xml:space="preserve">
          <source>The left side of the arrow can be any expression returning a reference, including a previous dereference. Note that &lt;code&gt;$array[$x]&lt;/code&gt; is</source>
          <target state="translated">箭头的左侧可以是任何返回引用的表达式，包括先前的取消引用。注意， &lt;code&gt;$array[$x]&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="eb221cc92a9038eecac3c016886c94b3bdd80217" translate="yes" xml:space="preserve">
          <source>The left-hand character up there indicates the context in which the function was called, with &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; meaning scalar or list contexts respectively, and &lt;code&gt;.&lt;/code&gt; meaning void context (which is actually a sort of scalar context). The display above says that you were in the function &lt;code&gt;main::infested&lt;/code&gt; when you ran the stack dump, and that it was called in scalar context from line 10 of the file</source>
          <target state="translated">左边的字符表示调用该函数的上下文， &lt;code&gt;$&lt;/code&gt; 和 &lt;code&gt;@&lt;/code&gt; 分别表示标量或列表上下文，以及 &lt;code&gt;.&lt;/code&gt; 表示无效上下文（实际上是一种标量上下文）。上面的显示显示，当您运行堆栈转储时，您处于函数 &lt;code&gt;main::infested&lt;/code&gt; ，并且在文件第10行的标量上下文中对其进行了调用</target>
        </trans-unit>
        <trans-unit id="d8cc674eda9906f58ae8371f8d5de07f046d9b51" translate="yes" xml:space="preserve">
          <source>The leftmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;lt;&quot;).</source>
          <target state="translated">最左定界符从参数文本开始到内部序列（应为&amp;ldquo; &amp;lt;&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="fbadd9b1973b1ad2d4e5362cd034946bff294cd7" translate="yes" xml:space="preserve">
          <source>The length [in bytes] of the section to be formatted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f9e2e6c56a351b6a88108f75341c9d329b9f6c" translate="yes" xml:space="preserve">
          <source>The length at which the argument list is truncated is governed by the next option:</source>
          <target state="translated">参数列表被截断的长度由下一个选项决定。</target>
        </trans-unit>
        <trans-unit id="0c237bc1e8c7da08e4bc9cf58175d51b2735fd6c" translate="yes" xml:space="preserve">
          <source>The length of an array is a scalar value. You may find the length of array @days by evaluating &lt;code&gt;$#days&lt;/code&gt; , as in &lt;b&gt;csh&lt;/b&gt;. However, this isn't the length of the array; it's the subscript of the last element, which is a different value since there is ordinarily a 0th element. Assigning to &lt;code&gt;$#days&lt;/code&gt; actually changes the length of the array. Shortening an array this way destroys intervening values. Lengthening an array that was previously shortened does not recover values that were in those elements.</source>
          <target state="translated">数组的长度是标量值。您可以通过评估 &lt;code&gt;$#days&lt;/code&gt; 来找到@days数组的长度，如&lt;b&gt;csh所示&lt;/b&gt;。但是，这不是数组的长度。它是最后一个元素的下标，这是一个不同的值，因为通常有第0个元素。分配给 &lt;code&gt;$#days&lt;/code&gt; 实际上会更改数组的长度。用这种方法缩短数组会破坏中间值。延长以前缩短的数组不会恢复这些元素中的值。</target>
        </trans-unit>
        <trans-unit id="f563a4457c7ea4c783229c274409e5e0accbf6ff" translate="yes" xml:space="preserve">
          <source>The length of an array is a scalar value. You may find the length of array @days by evaluating &lt;code&gt;$#days&lt;/code&gt;, as in &lt;b&gt;csh&lt;/b&gt;. However, this isn't the length of the array; it's the subscript of the last element, which is a different value since there is ordinarily a 0th element. Assigning to &lt;code&gt;$#days&lt;/code&gt; actually changes the length of the array. Shortening an array this way destroys intervening values. Lengthening an array that was previously shortened does not recover values that were in those elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4741e016ab3bf497ce5ef4aff13131c47a360d63" translate="yes" xml:space="preserve">
          <source>The length of the field is supplied by padding out the field with multiple &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, or &quot;|&quot; characters to specify a non-numeric field with, respectively, left justification, right justification, or centering. For a regular field, the value (up to the first newline) is taken and printed according to the selected justification, truncating excess characters. If you terminate a text field with &quot;...&quot;, three dots will be shown if the value is truncated. A special text field may be used to do rudimentary multi-line text block filling; see &lt;a href=&quot;#Using-Fill-Mode&quot;&gt;&quot;Using Fill Mode&quot;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ef5c234e3b75bc352e3b032ce59b9fa1929612" translate="yes" xml:space="preserve">
          <source>The length of the field is supplied by padding out the field with multiple &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, or &quot;|&quot; characters to specify a non-numeric field with, respectively, left justification, right justification, or centering. For a regular field, the value (up to the first newline) is taken and printed according to the selected justification, truncating excess characters. If you terminate a text field with &quot;...&quot;, three dots will be shown if the value is truncated. A special text field may be used to do rudimentary multi-line text block filling; see &lt;a href=&quot;#Using-Fill-Mode&quot;&gt;Using Fill Mode&lt;/a&gt; for details.</source>
          <target state="translated">通过用多个&amp;ldquo; &amp;lt;&amp;rdquo;，&amp;ldquo;&amp;ldquo;&amp;gt;&amp;rdquo;或&amp;ldquo; |&amp;rdquo;填充字段来提供字段的长度字符以分别指定具有左对齐，右对齐或居中的非数字字段。对于常规字段，将根据选定的对齐方式获取并打印该值（直到第一个换行符），并截断多余的字符。如果用&amp;ldquo; ...&amp;rdquo;终止文本字段，则值被截断时将显示三个点。特殊的文本字段可用于进行基本的多行文本块填充；有关详细信息，请参见&lt;a href=&quot;#Using-Fill-Mode&quot;&gt;使用填充模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="531fdf3344d9288341eaab36c6e742e75614f35e" translate="yes" xml:space="preserve">
          <source>The length of the filed in hex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b66a1a14f6dce4bff1a210ef4e586716a5899b" translate="yes" xml:space="preserve">
          <source>The length of the name.</source>
          <target state="translated">名的长度。</target>
        </trans-unit>
        <trans-unit id="696a9e70beeee9b566eace1cd87208a1d5c5089e" translate="yes" xml:space="preserve">
          <source>The length(NAME) Keyword</source>
          <target state="translated">长度(NAME)关键字</target>
        </trans-unit>
        <trans-unit id="b958bd03a02b517c3d184dfcfbefe403cc86c37f" translate="yes" xml:space="preserve">
          <source>The level can be changed as follows:</source>
          <target state="translated">可以按以下方式改变等级。</target>
        </trans-unit>
        <trans-unit id="64e6e89b4814ce7405192ddfc665d5e521c03538" translate="yes" xml:space="preserve">
          <source>The level constants are not exported by the module.</source>
          <target state="translated">级别常数不由模块导出。</target>
        </trans-unit>
        <trans-unit id="b4c1d901146534759d309f43fe1b8efda46ffa76" translate="yes" xml:space="preserve">
          <source>The level of detail in Perl module documentation generally goes from less detailed to more detailed. Your SYNOPSIS section should contain a minimal example of use (perhaps as little as one line of code; skip the unusual use cases or anything not needed by most users); the DESCRIPTION should describe your module in broad terms, generally in just a few paragraphs; more detail of the module's routines or methods, lengthy code examples, or other in-depth material should be given in subsequent sections.</source>
          <target state="translated">Perl 模块文档的详细程度一般是由少到多。你的 SYNOPSIS 部分应该包含一个最小的使用实例(可能只有一行代码,跳过不寻常的用例或任何大多数用户不需要的东西);DESCRIPTION 应该概括性地描述你的模块,一般只有几段;模块的例程或方法的更多细节、冗长的代码实例或其他深入的材料应该在后面的部分给出。</target>
        </trans-unit>
        <trans-unit id="0ce002d9483143d05cc2ba45ea1b81cd48bfc336" translate="yes" xml:space="preserve">
          <source>The lexer can be bypassed as well by creating the pattern from smaller components:</source>
          <target state="translated">通过从较小的组件创建模式,也可以绕过词典。</target>
        </trans-unit>
        <trans-unit id="dcb697055788c2e7dd63bc610ab1eb6ac51eb7cf" translate="yes" xml:space="preserve">
          <source>The lexer maintains various &lt;code&gt;char*&lt;/code&gt; pointers to things in the &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; buffer. If &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; is ever reallocated, all of these pointers must be updated. Don't attempt to do this manually, but rather use &lt;a href=&quot;#lex_grow_linestr&quot;&gt;&quot;lex_grow_linestr&quot;&lt;/a&gt; if you need to reallocate the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23265d5a0661d902031b21a8d3925278347efe2b" translate="yes" xml:space="preserve">
          <source>The lexer maintains various &lt;code&gt;char*&lt;/code&gt; pointers to things in the &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; buffer. If &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; is ever reallocated, all of these pointers must be updated. Don't attempt to do this manually, but rather use &lt;a href=&quot;#lex_grow_linestr&quot;&gt;lex_grow_linestr&lt;/a&gt; if you need to reallocate the buffer.</source>
          <target state="translated">词法分析器在 &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; 缓冲区中维护指向各种对象的 &lt;code&gt;char*&lt;/code&gt; 指针。如果曾经重新分配 &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; ,则必须更新所有这些指针。不要尝试手动执行此操作，如果需要重新分配缓冲区，请使用&lt;a href=&quot;#lex_grow_linestr&quot;&gt;lex_grow_linestr&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ed189d83743aeda186a080785030258aac3dd09" translate="yes" xml:space="preserve">
          <source>The libnetcfg utility can be used to configure the libnet. Starting from perl 5.8 libnet is part of the standard Perl distribution, but the libnetcfg can be used for any libnet installation.</source>
          <target state="translated">libnetcfg 工具可以用来配置 libnet。从 perl 5.8 开始,libnet 是标准 Perl 发行版的一部分,但 libnetcfg 可以用于任何 libnet 安装。</target>
        </trans-unit>
        <trans-unit id="b7cb7266f690af0bb383573e50d303e552d377e1" translate="yes" xml:space="preserve">
          <source>The libraries specified may be a mixture of static libraries and import libraries (to link with DLLs). Since both kinds are used pretty transparently on the Win32 platform, we do not attempt to distinguish between them.</source>
          <target state="translated">指定的库可能是静态库和导入库的混合体(与DLLs链接)。由于这两种库在Win32平台上的使用非常透明,我们不打算区分它们。</target>
        </trans-unit>
        <trans-unit id="df259280ce53fd256ff55110ddf21cb58f64ee0c" translate="yes" xml:space="preserve">
          <source>The library that is loaded last is used. Note that this can be overwritten at any time by loading a different library, and numbers constructed with different libraries cannot be used in math operations together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99e76c717b720c6c49420484756d2dfcd410c40" translate="yes" xml:space="preserve">
          <source>The library that is loaded last will be used. Note that this can be overwritten at any time by loading a different library, and numbers constructed with different libraries cannot be used in math operations together.</source>
          <target state="translated">最后加载的库将被使用。需要注意的是,可以随时通过加载不同的库来覆盖这个库,而且用不同库构造的数不能一起用于数学运算。</target>
        </trans-unit>
        <trans-unit id="f52597109e4fab2376043609905f67d9e1da90d1" translate="yes" xml:space="preserve">
          <source>The license under which this distribution may be used and redistributed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be37c25dc5d34ce7bba6cfdf56923967183a419" translate="yes" xml:space="preserve">
          <source>The licensing terms of your distribution. Generally it's &quot;perl_5&quot; for the same license as Perl itself.</source>
          <target state="translated">你的发行版的许可条款。一般来说,它是 &quot;perl_5&quot;,与Perl本身的许可证相同。</target>
        </trans-unit>
        <trans-unit id="ee54e36e284ff26a979d2076f6ca4023c3d73825" translate="yes" xml:space="preserve">
          <source>The line above describes the limits of buckets currently in use. Each bucket has two sizes: memory footprint and the maximal size of user data that can fit into this bucket. Suppose in the above example that the smallest bucket were size 4. The biggest bucket would have usable size 8188, and the memory footprint would be 8192.</source>
          <target state="translated">上面一行描述了目前使用的桶的限制。每个bucket都有两个大小:内存占用和可以装入这个bucket的用户数据的最大大小。假设在上面的例子中,最小的bucket的大小是4。最大的bucket的可用大小为8188,内存占用为8192。</target>
        </trans-unit>
        <trans-unit id="391452165da7e2f812078f7c3a4920d3947a871e" translate="yes" xml:space="preserve">
          <source>The line in &lt;code&gt;$E-&amp;gt;file&lt;/code&gt; where the exceptional code was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac97bcd51055b69e1b4470987fa154b899ce651a" translate="yes" xml:space="preserve">
          <source>The line number the error occurred in.</source>
          <target state="translated">发生错误的行号。</target>
        </trans-unit>
        <trans-unit id="cc23ac8e14569b4b19694084670492ce2aa4a0c6" translate="yes" xml:space="preserve">
          <source>The line shown is the one that is about to be executed &lt;b&gt;next&lt;/b&gt;, it hasn't happened yet. So while we can print a variable with the letter '&lt;b&gt;p&lt;/b&gt;', at this point all we'd get is an empty (undefined) value back. What we need to do is to step through the next executable statement with an '&lt;b&gt;s&lt;/b&gt;':</source>
          <target state="translated">所示的行是&lt;b&gt;下一步&lt;/b&gt;将要执行的行，尚未发生。因此，尽管我们可以打印带有字母&amp;ldquo; &lt;b&gt;p&lt;/b&gt; &amp;rdquo; 的变量，但此时我们得到的只是一个空（未定义）值。我们需要做的是通过下一个带有' &lt;b&gt;s&lt;/b&gt;的可执行语句：</target>
        </trans-unit>
        <trans-unit id="e54713c2cd710c76f4d69536879402921ef82d04" translate="yes" xml:space="preserve">
          <source>The linearized MRO of a class is an ordered array of all of the classes one would search when resolving a method on that class, starting with the class itself.</source>
          <target state="translated">一个类的线性化MRO是一个有序的数组,它包含了所有在该类上解析方法时要搜索的类,从该类本身开始。</target>
        </trans-unit>
        <trans-unit id="f96ce0004635ab8058e21a997ff0fdcac4680ebd" translate="yes" xml:space="preserve">
          <source>The link found cannot be parsed because it does not conform to the syntax described in &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">无法解析找到的链接，因为它不符合&lt;a href=&quot;../perlpod&quot;&gt;perlpod中&lt;/a&gt;描述的语法。</target>
        </trans-unit>
        <trans-unit id="365c0989adb3aa2936b9a9b37c715ae0175f622e" translate="yes" xml:space="preserve">
          <source>The link-text. If there is none, this must be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the link-text is &quot;Perl Functions&quot;. In &quot;L&amp;lt;Time::HiRes&amp;gt;&quot; and even &quot;L&amp;lt;|Time::HiRes&amp;gt;&quot;, there is no link text. Note that link text may contain formatting.)</source>
          <target state="translated">链接文本。如果没有，则必须为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。（例如，在&amp;ldquo; L &amp;lt;Perl函数| perlfunc&amp;gt;&amp;rdquo;中，链接文本为&amp;ldquo; Perl函数&amp;rdquo;。在&amp;ldquo; L &amp;lt;Time :: HiRes&amp;gt;&amp;rdquo;甚至&amp;ldquo; L &amp;lt;| Time :: HiRes&amp;gt;&amp;rdquo;中都没有链接文本。请注意，链接文本可能包含格式。）</target>
        </trans-unit>
        <trans-unit id="02b503d2f0eeb8483755cc493aa85b3fc0ad66ce" translate="yes" xml:space="preserve">
          <source>The link-text. If there is none, this must be &lt;code&gt;undef&lt;/code&gt;. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the link-text is &quot;Perl Functions&quot;. In &quot;L&amp;lt;Time::HiRes&amp;gt;&quot; and even &quot;L&amp;lt;|Time::HiRes&amp;gt;&quot;, there is no link text. Note that link text may contain formatting.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43c6585f184d3f50d1ee9b3f3e7c9226f529c8c" translate="yes" xml:space="preserve">
          <source>The list becomes the default for</source>
          <target state="translated">列表成为默认的</target>
        </trans-unit>
        <trans-unit id="3deb5bdbb77dae94d3dcc1cd91998f32e0e38f14" translate="yes" xml:space="preserve">
          <source>The list in the second argument means:</source>
          <target state="translated">第二个参数中的列表是指:</target>
        </trans-unit>
        <trans-unit id="e1406e4b9186eac7ca74cdee5b539fc3d6f09c6c" translate="yes" xml:space="preserve">
          <source>The list may well be incomplete, or even wrong in some places. When in doubt, consult the platform-specific README files in the Perl source distribution, and any other documentation resources accompanying a given port.</source>
          <target state="translated">这个列表很可能是不完整的,甚至在某些地方是错误的。如果有疑问,请查阅 Perl 源代码发行版中的特定平台的 README 文件,以及其它任何与特定 port 相关的文档资源。</target>
        </trans-unit>
        <trans-unit id="47c47cf18ff1538b7e1e7d5d97838485842b3427" translate="yes" xml:space="preserve">
          <source>The list of &lt;b&gt;directories&lt;/b&gt; the system searches to find a program you want to &lt;b&gt;execute&lt;/b&gt;. The list is stored as one of your &lt;b&gt;environment variables&lt;/b&gt;, accessible in Perl as &lt;code&gt;$ENV{PATH}&lt;/code&gt; .</source>
          <target state="translated">系统搜索以查找要&lt;b&gt;执行&lt;/b&gt;的程序的&lt;b&gt;目录&lt;/b&gt;列表。该列表存储为您的&lt;b&gt;环境变量之一&lt;/b&gt;，可以在Perl中作为 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="38740fd91fca4080ce68cbb1a2be0d91acbe5b88" translate="yes" xml:space="preserve">
          <source>The list of &lt;b&gt;directories&lt;/b&gt; the system searches to find a program you want to &lt;b&gt;execute&lt;/b&gt;. The list is stored as one of your &lt;b&gt;environment variables&lt;/b&gt;, accessible in Perl as &lt;code&gt;$ENV{PATH}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b24d146d5dbad44a8c4fe5e7cb3811111eac143" translate="yes" xml:space="preserve">
          <source>The list of characters within the character class gives the set of characters matched by the class. &lt;code&gt;&quot;[abc]&quot;&lt;/code&gt; matches a single &quot;a&quot; or &quot;b&quot; or &quot;c&quot;. But if the first character after the &lt;code&gt;&quot;[&quot;&lt;/code&gt; is &lt;code&gt;&quot;^&quot;&lt;/code&gt;, the class instead matches any character not in the list. Within a list, the &lt;code&gt;&quot;-&quot;&lt;/code&gt; character specifies a range of characters, so that &lt;code&gt;a-z&lt;/code&gt; represents all characters between &quot;a&quot; and &quot;z&quot;, inclusive. If you want either &lt;code&gt;&quot;-&quot;&lt;/code&gt; or &lt;code&gt;&quot;]&quot;&lt;/code&gt; itself to be a member of a class, put it at the start of the list (possibly after a &lt;code&gt;&quot;^&quot;&lt;/code&gt;), or escape it with a backslash. &lt;code&gt;&quot;-&quot;&lt;/code&gt; is also taken literally when it is at the end of the list, just before the closing &lt;code&gt;&quot;]&quot;&lt;/code&gt;. (The following all specify the same class of three characters: &lt;code&gt;[-az]&lt;/code&gt;, &lt;code&gt;[az-]&lt;/code&gt;, and &lt;code&gt;[a\-z]&lt;/code&gt;. All are different from &lt;code&gt;[a-z]&lt;/code&gt;, which specifies a class containing twenty-six characters, even on EBCDIC-based character sets.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880294bb5af5ca3525238395f901655f64c2020a" translate="yes" xml:space="preserve">
          <source>The list of functions supported by this module.</source>
          <target state="translated">本模块支持的功能列表。</target>
        </trans-unit>
        <trans-unit id="77160ea4e8b3bcdfb5681dd2b39ffff26dc948b8" translate="yes" xml:space="preserve">
          <source>The list of functions that will need to recompiled is: creat, fgetpos, fopen, freopen, fsetpos, fstat, fstatvfs, fstatvfsdev, ftruncate, ftw, lockf, lseek, lstat, mmap, nftw, open, prealloc, stat, statvfs, statvfsdev, tmpfile, truncate, getrlimit, setrlimit</source>
          <target state="translated">需要重新编译的函数列表是:create,fgetpos,fopen,freopen,fsetpos,fstat,fstatvfs,fstatvfsdev,ftruncate,ftw,lockf,lseek,lstat,mmap,nftw,open,prealloc,stat,statvfs,statvfsdev,tmpfile,truncate,getrlimit,setrlimit。</target>
        </trans-unit>
        <trans-unit id="0ece79552d7d2f7d04e0b952118b609964429027" translate="yes" xml:space="preserve">
          <source>The list of libraries needed by Perl only (any libraries needed by extensions only will by dropped, if using dynamic loading).</source>
          <target state="translated">只有Perl需要的库列表(如果使用动态加载,只有扩展需要的库将被删除)。</target>
        </trans-unit>
        <trans-unit id="8a88dc253dbf62089f3cd58a095e24a1f2508bc5" translate="yes" xml:space="preserve">
          <source>The list of macro definitions to be passed through must be specified using the /MACRO qualifier and must not add another /DEFINE qualifier. We prepend our own comma here to the contents of $(PASTHRU_DEFINE) because it is often empty and a comma always present in CCFLAGS would generate a missing qualifier value error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64ca6ece649f2cd25525c8ae9c0d312fa7bfc44" translate="yes" xml:space="preserve">
          <source>The list of moderators will be public knowledge. At present, it is: Aaron Crane, Andy Dougherty, Ricardo Signes, Steffen M&amp;uuml;ller.</source>
          <target state="translated">主持人名单将是公众知识。目前是：亚伦&amp;middot;克兰（Aaron Crane），安迪&amp;middot;多尔蒂（Andy Dougherty），里卡多&amp;middot;西涅斯（Ricardo Signes），斯特芬&amp;middot;穆勒（SteffenM&amp;uuml;ller）。</target>
        </trans-unit>
        <trans-unit id="78f6263b45ee82cd9e1bdb24d318e0dddc31338c" translate="yes" xml:space="preserve">
          <source>The list of moderators will be public knowledge. At present, it is: Andy Dougherty, Karen Etheridge, Ricardo Signes, Sawyer X, Steffen M&amp;uuml;ller, Todd Rinaldo, Aaron Crane.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1addfaddfdb521f7b3277e8c72cb79cc08f13e02" translate="yes" xml:space="preserve">
          <source>The list of output parameters occurs at the very end of the function, just after the OUTPUT: directive. The use of RETVAL tells Perl that you wish to send this value back as the return value of the XSUB function. In Example 3, we wanted the &quot;return value&quot; placed in the original variable which we passed in, so we listed it (and not RETVAL) in the OUTPUT: section.</source>
          <target state="translated">输出参数列表出现在函数的最后,就在OUTPUT:指令之后。使用RETVAL告诉Perl,你希望把这个值作为XSUB函数的返回值送回来。在例3中,我们希望把 &quot;返回值 &quot;放在我们传入的原始变量中,所以我们把它(而不是RETVAL)列在OUTPUT:部分。</target>
        </trans-unit>
        <trans-unit id="2539fe270e83e959d35fc853744365007ae544d9" translate="yes" xml:space="preserve">
          <source>The list of subfields can be supplied in any of the following formats</source>
          <target state="translated">子字段列表可以以下列任何一种格式提供。</target>
        </trans-unit>
        <trans-unit id="e16fd393ccc48ed4253b4ef65eb2fcd167d75fd6" translate="yes" xml:space="preserve">
          <source>The list of symbols for the iterator is assembled by spawning off a subprocess, which can be slow. Ideally, we should just traverse the process' symbol table directly from C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcba41fba02d24fea6ac236d8112cd5b98ebb87" translate="yes" xml:space="preserve">
          <source>The list of the registered CPAN sites follows. Please note that the sorting order is alphabetical on fields:</source>
          <target state="translated">已注册的CPAN网站列表如下。请注意,排序顺序是按字母顺序排列的。</target>
        </trans-unit>
        <trans-unit id="e411ef2006039baaa3efb0aa87f085a254587fe2" translate="yes" xml:space="preserve">
          <source>The list of the valid options is shown below. Options not specified will remain unchanged.</source>
          <target state="translated">有效选项列表如下所示。未指定的选项将保持不变。</target>
        </trans-unit>
        <trans-unit id="cca90ac8d52c301adc0df9b517c693dc0133a8b6" translate="yes" xml:space="preserve">
          <source>The list opened with &lt;code&gt;=over&lt;/code&gt; does not contain any items.</source>
          <target state="translated">用 &lt;code&gt;=over&lt;/code&gt; 打开的列表不包含任何项目。</target>
        </trans-unit>
        <trans-unit id="4d086b1f033b01df712b5de461a87fac4f3a292c" translate="yes" xml:space="preserve">
          <source>The list opened with &lt;code&gt;=over&lt;/code&gt; does not contain anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37870cad335f71a8db1ccbfc9f539b9f8492c3a2" translate="yes" xml:space="preserve">
          <source>The list reference contains one or more strings specifying patterns that are</source>
          <target state="translated">列表引用包含一个或多个字符串,指定的模式是</target>
        </trans-unit>
        <trans-unit id="7ecd93d98b44cbb94ca7891c2599a20dc8e75287" translate="yes" xml:space="preserve">
          <source>The list reference contains one or more strings specifying patterns that must</source>
          <target state="translated">列表引用包含一个或多个字符串,指定了必须使用的模式。</target>
        </trans-unit>
        <trans-unit id="0da38439f7a00ec9abb7cd8b98624a8251f6fb80" translate="yes" xml:space="preserve">
          <source>The listing below is alphabetical, case insensitive.</source>
          <target state="translated">以下列表按字母顺序排列,不区分大小写。</target>
        </trans-unit>
        <trans-unit id="768abd184089ae969a2334570319327e5afad505" translate="yes" xml:space="preserve">
          <source>The listing looks something like this:</source>
          <target state="translated">列表看起来像这样。</target>
        </trans-unit>
        <trans-unit id="a6fd74766ba848460935d167a256b131af8e02ea" translate="yes" xml:space="preserve">
          <source>The lists are ordered (roughly) so the most preferred names come before less preferred ones.</source>
          <target state="translated">名单是按顺序排列的(大致),所以最喜欢的名字在不太喜欢的名字之前。</target>
        </trans-unit>
        <trans-unit id="c3448e4c57076d015f65b6c72251baf22ba5950b" translate="yes" xml:space="preserve">
          <source>The literal string in the regex can be replaced by a variable:</source>
          <target state="translated">在regex中的文字字符串可以用一个变量来代替。</target>
        </trans-unit>
        <trans-unit id="9605e010408c59883a845d8cc68911d04aa028cd" translate="yes" xml:space="preserve">
          <source>The literal string in the regexp can be replaced by a variable:</source>
          <target state="translated">regexp中的字面字符串可以用一个变量代替。</target>
        </trans-unit>
        <trans-unit id="cc87d2f061afcaaa2771f59160c4bc3540da65d9" translate="yes" xml:space="preserve">
          <source>The literal string to be output. If it starts with a number and an optional '*' then the padding will be increased by an amount relative to this number, if the '*' is present then this amount will be multiplied by $cnt. This part of $string is removed before output/</source>
          <target state="translated">要输出的字面字符串。如果它以数字和可选的'*'开头,那么padding将增加一个相对于这个数字的数量,如果有'*',那么这个数量将乘以$cnt。$string的这部分内容会在输出前被删除。</target>
        </trans-unit>
        <trans-unit id="67b8f203dc692021f65103823771254ae8d76d5b" translate="yes" xml:space="preserve">
          <source>The literals that are converted are &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt; , and starting in v5.8.1, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. Operations that do conversions include &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;utf8::upgrade&lt;/code&gt; (but not &lt;code&gt;utf8::downgrade&lt;/code&gt; ), and &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">转换后的文字是 &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt; ，并且从v5.8.1开始， &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 。进行转换的操作包括 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;utf8::upgrade&lt;/code&gt; （但不包括 &lt;code&gt;utf8::downgrade&lt;/code&gt; ）和 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="116243fae422285ef1d7be17ca7bca8fa87732c6" translate="yes" xml:space="preserve">
          <source>The literals that are converted are &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt;, and starting in v5.8.1, &lt;code&gt;tr///&lt;/code&gt;. Operations that do conversions include &lt;code&gt;chr&lt;/code&gt;, &lt;code&gt;ord&lt;/code&gt;, &lt;code&gt;utf8::upgrade&lt;/code&gt; (but not &lt;code&gt;utf8::downgrade&lt;/code&gt;), and &lt;code&gt;chomp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dba36a88aebe7e92337b13757f05491149d1212d" translate="yes" xml:space="preserve">
          <source>The little number the &lt;b&gt;operating system&lt;/b&gt; uses to keep track of which opened &lt;b&gt;file&lt;/b&gt; you&amp;rsquo;re talking about. Perl hides the file descriptor inside a &lt;b&gt;standard I/O&lt;/b&gt; stream and then attaches the stream to a &lt;b&gt;filehandle&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;操作系统&lt;/b&gt;用来跟踪您正在谈论的哪个打开&lt;b&gt;文件&lt;/b&gt;的少量数字。Perl在&lt;b&gt;标准I / O&lt;/b&gt;流中隐藏文件描述符，然后将流附加到&lt;b&gt;filehandle&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="c45e18376e8b086f8c631b86953dc61fd730ab6e" translate="yes" xml:space="preserve">
          <source>The load function that dl_load_file() calls may require an absolute pathname. The dl_findfile() function and @dl_library_path can be used to search for and return the absolute pathname for the library/object that you wish to load.</source>
          <target state="translated">dl_load_file()调用的加载函数可能需要一个绝对路径名,dl_findfile()函数和@dl_library_path可以用来搜索并返回你想加载的库/对象的绝对路径名。dl_findfile()函数和@dl_library_path可以用来搜索并返回你想要加载的库/对象的绝对路径名。</target>
        </trans-unit>
        <trans-unit id="8c46c2259b1d6fa0f7f68fad81b43f4cfbd94e4d" translate="yes" xml:space="preserve">
          <source>The loaded modules are IO::Handle, IO::Seekable, IO::File, IO::Pipe, IO::Socket, IO::Dir. You should instead explicitly import the IO modules you want.</source>
          <target state="translated">加载的模块有IO::Handle、IO::Seekable、IO::File、IO::Pipe、IO::Socket、IO::Dir。你应该明确导入你想要的IO模块。</target>
        </trans-unit>
        <trans-unit id="0917a1903587e2d522edafea1a2d6e66a9118a13" translate="yes" xml:space="preserve">
          <source>The local() generated a compile-time error because you just touched a global name without fully qualifying it.</source>
          <target state="translated">local()产生了一个编译时错误,因为你只是碰了一个全局名,而没有完全限定它。</target>
        </trans-unit>
        <trans-unit id="0cf7efcc5129f771b3d1f0dd51149aa0de4647fc" translate="yes" xml:space="preserve">
          <source>The localeconv function</source>
          <target state="translated">当地的econv函数</target>
        </trans-unit>
        <trans-unit id="ba0cd5497a3f02564f53cc5f3cb0a7c74904a185" translate="yes" xml:space="preserve">
          <source>The locking technique went like this.</source>
          <target state="translated">锁定技术是这样的。</target>
        </trans-unit>
        <trans-unit id="6e5d8b4586e8d6172f220183afe910608a1d8583" translate="yes" xml:space="preserve">
          <source>The log level to use, with either the embedded, minimal logger or &lt;a href=&quot;Log::Log4perl&quot;&gt;Log::Log4perl&lt;/a&gt; if it is installed. Possible values are the same as the &lt;code&gt;Log::Log4perl&lt;/code&gt; levels: &lt;code&gt;TRACE&lt;/code&gt;, &lt;code&gt;DEBUG&lt;/code&gt;, &lt;code&gt;INFO&lt;/code&gt;, &lt;code&gt;WARN&lt;/code&gt;, &lt;code&gt;ERROR&lt;/code&gt;, and &lt;code&gt;FATAL&lt;/code&gt;. The default is &lt;code&gt;INFO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb02723b6a87664f1d9c172d5d68ee624445a8a4" translate="yes" xml:space="preserve">
          <source>The logarithm of the Gamma function [C99].</source>
          <target state="translated">Gamma函数的对数[C99]。</target>
        </trans-unit>
        <trans-unit id="12f81008559a10138f818056ec245c593a6400e5" translate="yes" xml:space="preserve">
          <source>The logic of &lt;code&gt;:locale&lt;/code&gt; is described in full in &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt;, but in short it is first trying nl_langinfo(CODESET) and then guessing from the LC_ALL and LANG locale environment variables.</source>
          <target state="translated">&lt;code&gt;:locale&lt;/code&gt; 的逻辑在&lt;a href=&quot;encoding&quot;&gt;编码&lt;/a&gt;中进行了完整描述，但简而言之，它首先尝试使用nl_langinfo（CODESET），然后从LC_ALL和LANG语言环境环境变量中进行猜测。</target>
        </trans-unit>
        <trans-unit id="788028f7f75ce2d23138d44a065abd859dafb9ea" translate="yes" xml:space="preserve">
          <source>The logic of &lt;code&gt;:locale&lt;/code&gt; is described in full in &lt;a href=&quot;encoding#The-%3Alocale-sub-pragma&quot;&gt;&quot;The &lt;code&gt;:locale&lt;/code&gt; sub-pragma&quot; in encoding&lt;/a&gt;, but in short it is first trying nl_langinfo(CODESET) and then guessing from the LC_ALL and LANG locale environment variables. &lt;code&gt;:locale&lt;/code&gt; also implicitly turns on &lt;code&gt;:std&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf878ca097d48d543ea19885a2629244c15e1017" translate="yes" xml:space="preserve">
          <source>The logic of finding which locale &lt;code&gt;:locale&lt;/code&gt; uses is as follows:</source>
          <target state="translated">查找哪个语言环境 &lt;code&gt;:locale&lt;/code&gt; 使用的逻辑如下：</target>
        </trans-unit>
        <trans-unit id="49964803a05917808abe031a83a5e6119fc9d862" translate="yes" xml:space="preserve">
          <source>The lone dot that ends a format can also prematurely end a mail message passing through a misconfigured Internet mailer (and based on experience, such misconfiguration is the rule, not the exception). So when sending format code through mail, you should indent it so that the format-ending dot is not on the left margin; this will prevent SMTP cutoff.</source>
          <target state="translated">结束格式的孤点也会使通过配置错误的Internet邮件器的邮件信息过早结束(根据经验,这种配置错误是常规,而不是例外)。因此,当通过邮件发送格式代码时,应将其缩进,使格式结尾点不在左侧空白处;这样可以防止SMTP切断。</target>
        </trans-unit>
        <trans-unit id="23ac1b0fabb60338fc7595b94617767f0048e6fc" translate="yes" xml:space="preserve">
          <source>The lonesome dash</source>
          <target state="translated">孤独的奔跑</target>
        </trans-unit>
        <trans-unit id="58b8d17fbed51ef506dcc5bc2dfad68f8e405d89" translate="yes" xml:space="preserve">
          <source>The long answer is that &quot;it depends&quot;, and a good answer cannot be given without knowing (at the very least) the language context. See &lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode::Collate&lt;/a&gt;, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8acab1ed969d76981aca60d63a3ad2f6189741fb" translate="yes" xml:space="preserve">
          <source>The long answer is that &quot;it depends&quot;, and a good answer cannot be given without knowing (at the very least) the language context. See &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt;, and</source>
          <target state="translated">长的答案是&amp;ldquo;取决于&amp;rdquo;，如果不（至少）不了解语言上下文，就不能给出一个好的答案。参见&lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;和</target>
        </trans-unit>
        <trans-unit id="12b46ea21e617b9bac57234d9626d778dcbba94b" translate="yes" xml:space="preserve">
          <source>The long answer is that you need to consider character normalization and casing issues: see &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;, Unicode Technical Report #15, &lt;a href=&quot;https://www.unicode.org/unicode/reports/tr15&quot;&gt;Unicode Normalization Forms&lt;/a&gt; and sections on case mapping in the &lt;a href=&quot;https://www.unicode.org&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b351929b2c368a051a670eae8fde3b6788ce75f" translate="yes" xml:space="preserve">
          <source>The long answer is that you need to consider character normalization and casing issues: see &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;, Unicode Technical Report #15, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2funicode%2freports%2ftr15&quot;&gt;Unicode Normalization Forms&lt;/a&gt; and sections on case mapping in the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">长答案是，您需要考虑字符规范化和大小写问题：请参见&lt;a href=&quot;unicode/normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;，Unicode技术报告＃15，&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2funicode%2freports%2ftr15&quot;&gt;Unicode规范化形式&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org&quot;&gt;Unicode标准&lt;/a&gt;中的大小写映射部分。</target>
        </trans-unit>
        <trans-unit id="b13e585010c555d0e300d8fe834b6f46a4ae81c6" translate="yes" xml:space="preserve">
          <source>The long answer is the rest of the manpage :-)</source>
          <target state="translated">长答案是manpage的其余部分:-)</target>
        </trans-unit>
        <trans-unit id="31adae3a57b090c57ee3c7e6d1bf3e97b3bf17d2" translate="yes" xml:space="preserve">
          <source>The long name is returned in a form nicely capitalized, suitable for printing.</source>
          <target state="translated">长名以大写的形式返回,适合打印。</target>
        </trans-unit>
        <trans-unit id="3088cd686b7b7b0dbd27c6c1543c10f8e12363eb" translate="yes" xml:space="preserve">
          <source>The lookahead and lookbehind assertions are generalizations of the anchor concept. Lookahead and lookbehind are zero-width assertions that let us specify which characters we want to test for. The lookahead assertion is denoted by &lt;code&gt;(?=regexp)&lt;/code&gt; and the lookbehind assertion is denoted by &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt;. Some examples are</source>
          <target state="translated">前瞻性声明和后向声明是锚概念的概括。前行和后行是零宽度的断言，可让我们指定要测试的字符。先行断言由 &lt;code&gt;(?=regexp)&lt;/code&gt; 表示，后向断言由 &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; 表示。一些例子是</target>
        </trans-unit>
        <trans-unit id="5683ae6515c38a0cd77c7a977d476fd0513aeaf5" translate="yes" xml:space="preserve">
          <source>The lookahead and lookbehind assertions are generalizations of the anchor concept. Lookahead and lookbehind are zero-width assertions that let us specify which characters we want to test for. The lookahead assertion is denoted by &lt;code&gt;(?=regexp)&lt;/code&gt; or (starting in 5.32, experimentally in 5.28) &lt;code&gt;(*pla:regexp)&lt;/code&gt; or &lt;code&gt;(*positive_lookahead:regexp)&lt;/code&gt;; and the lookbehind assertion is denoted by &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; or (starting in 5.32, experimentally in 5.28) &lt;code&gt;(*plb:fixed-regexp)&lt;/code&gt; or &lt;code&gt;(*positive_lookbehind:fixed-regexp)&lt;/code&gt;. Some examples are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f75c5b0c19aae838064eb95c9b0bb2969329be" translate="yes" xml:space="preserve">
          <source>The lookbehind &lt;code&gt;condition&lt;/code&gt; allows, along with backreferences, an earlier part of the match to influence a later part of the match. For instance,</source>
          <target state="translated">后向 &lt;code&gt;condition&lt;/code&gt; 与反向引用一起允许匹配的较早部分影响匹配的较后部分。例如，</target>
        </trans-unit>
        <trans-unit id="81e7a5f6a959e62bd2ce3d55576db8abdefeae7e" translate="yes" xml:space="preserve">
          <source>The loop will do the right thing for a while, but it will unexpectedly fail.</source>
          <target state="translated">循环会做对一段时间,但会意外失败。</target>
        </trans-unit>
        <trans-unit id="45575ec17d57b6c0181a285166eef0dbc45075e3" translate="yes" xml:space="preserve">
          <source>The loop will never terminate.</source>
          <target state="translated">循环永远不会终止。</target>
        </trans-unit>
        <trans-unit id="ef06996a2f846d6797b75f13080961cc1d5fe17b" translate="yes" xml:space="preserve">
          <source>The low levels of the stack work with the low-level operating system calls (file descriptors in C) getting bytes in and out, the higher layers of the stack buffer, filter, and otherwise manipulate the I/O, and return characters (or bytes) to Perl. Terms</source>
          <target state="translated">栈的低层与低层操作系统调用(C语言中的文件描述符)一起工作,获取字节进出,栈的高层缓冲、过滤和以其他方式操作I/O,并向Perl返回字符(或字节)。术语</target>
        </trans-unit>
        <trans-unit id="af589ba8a2b7e981d742f8a3045bf5151d26273f" translate="yes" xml:space="preserve">
          <source>The low-order 4 bytes of the total number of cylinders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dcd393353514c923ef3599ddd24840670260ada" translate="yes" xml:space="preserve">
          <source>The low-order and high-order [respectively] 4 bytes of the offset [in bytes] where the formatting should begin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebbaa8b5bbc22fc30de9a07ab039a1fa2504ddd5" translate="yes" xml:space="preserve">
          <source>The low-order and high-order [respectively] 4 bytes of the starting offset of the partition, measured in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e618b44ecefc43c73cbcbb761a0be8756b4a11d0" translate="yes" xml:space="preserve">
          <source>The lower-level loops are</source>
          <target state="translated">低级循环是</target>
        </trans-unit>
        <trans-unit id="d49e301cfdcfd0dc30c1292d8446531a39bb2c8d" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;$ref&lt;/code&gt; will be turned into a weak reference. This means that it will not hold a reference count on the object it references. Also when the reference count on that object reaches zero, the reference will be set to undef. This function mutates the lvalue passed as its argument and returns no value.</source>
          <target state="translated">左值 &lt;code&gt;$ref&lt;/code&gt; 将变为弱引用。这意味着它将不保留对其引用的对象的引用计数。同样，当该对象的引用计数达到零时，该引用将设置为undef。此函数使作为参数传递的左值发生突变，并且不返回任何值。</target>
        </trans-unit>
        <trans-unit id="24ee888b5b6764355f1443fa7075b59310751e36" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;$ref&lt;/code&gt; will be turned into a weak reference. This means that it will not hold a reference count on the object it references. Also, when the reference count on that object reaches zero, the reference will be set to undef. This function mutates the lvalue passed as its argument and returns no value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b929552916e7407c841dad6560b9f648df9456" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;REF&lt;/code&gt; will be turned from a weak reference back into a normal (strong) reference again. This function mutates the lvalue passed as its argument and returns no value. This undoes the action performed by &lt;a href=&quot;#weaken&quot;&gt;&quot;weaken&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3f15897ac19338676b9cf56d55755a66f779f6" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;REF&lt;/code&gt; will be turned from a weak reference back into a normal (strong) reference again. This function mutates the lvalue passed as its argument and returns no value. This undoes the action performed by &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt;.</source>
          <target state="translated">左值 &lt;code&gt;REF&lt;/code&gt; 将再次从弱参考变为正常（强）参考。此函数使作为参数传递的左值发生突变，并且不返回任何值。这取消了&lt;a href=&quot;#weaken&quot;&gt;弱化所&lt;/a&gt;执行的动作。</target>
        </trans-unit>
        <trans-unit id="c832abcca8e03b1175991e252a63bb6082afdd89" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;cxstack&lt;/code&gt; returns the base of the current context stack, while &lt;code&gt;cxstack_ix&lt;/code&gt; is the index of the current frame within that stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b79adf8cca5ef25d3cb23e673042840fb0ff857" translate="yes" xml:space="preserve">
          <source>The macro to put this target on stack is &lt;code&gt;PUSHTARG&lt;/code&gt; , and it is directly used in some opcodes, as well as indirectly in zillions of others, which use it via &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;.</source>
          <target state="translated">将这个目标放在堆栈上的宏是 &lt;code&gt;PUSHTARG&lt;/code&gt; ，它直接用在某些操作码中，也间接用在不计其数的其他操作码中，它们通过 &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; 使用它。</target>
        </trans-unit>
        <trans-unit id="693b2cae8dc15e395df0cd8e5b72f3d52fadcead" translate="yes" xml:space="preserve">
          <source>The macro to put this target on stack is &lt;code&gt;PUSHTARG&lt;/code&gt;, and it is directly used in some opcodes, as well as indirectly in zillions of others, which use it via &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde4ff87d6048995f18afa79c7d92547dd919bf7" translate="yes" xml:space="preserve">
          <source>The macros PERL_SYS_INIT3() and PERL_SYS_TERM() provide system-specific tune up of the C runtime environment necessary to run Perl interpreters; they should only be called once regardless of how many interpreters you create or destroy. Call PERL_SYS_INIT3() before you create your first interpreter, and PERL_SYS_TERM() after you free your last interpreter.</source>
          <target state="translated">宏PERL_SYS_INIT3()和PERL_SYS_TERM()提供了运行Perl解释器所需的C语言运行环境的系统特定调整;无论你创建或销毁了多少个解释器,它们都应该只被调用一次。在创建第一个解释器之前调用PERL_SYS_INIT3(),在释放最后一个解释器之后调用PERL_SYS_TERM()。</target>
        </trans-unit>
        <trans-unit id="b34be3b84eadf2e475f94c5862ce6783466cbe33" translate="yes" xml:space="preserve">
          <source>The macros below now require an extra parameter than in versions prior to Perl 5.32. The final parameter in each one is a pointer into the string supplied by the first parameter beyond which the input will not be read. This prevents potential reading beyond the end of the buffer. &lt;code&gt;isALPHANUMERIC_utf8&lt;/code&gt;, &lt;code&gt;isASCII_utf8&lt;/code&gt;, &lt;code&gt;isBLANK_utf8&lt;/code&gt;, &lt;code&gt;isCNTRL_utf8&lt;/code&gt;, &lt;code&gt;isDIGIT_utf8&lt;/code&gt;, &lt;code&gt;isIDFIRST_utf8&lt;/code&gt;, &lt;code&gt;isPSXSPC_utf8&lt;/code&gt;, &lt;code&gt;isSPACE_utf8&lt;/code&gt;, &lt;code&gt;isVERTWS_utf8&lt;/code&gt;, &lt;code&gt;isWORDCHAR_utf8&lt;/code&gt;, &lt;code&gt;isXDIGIT_utf8&lt;/code&gt;, &lt;code&gt;isALPHANUMERIC_LC_utf8&lt;/code&gt;, &lt;code&gt;isALPHA_LC_utf8&lt;/code&gt;, &lt;code&gt;isASCII_LC_utf8&lt;/code&gt;, &lt;code&gt;isBLANK_LC_utf8&lt;/code&gt;, &lt;code&gt;isCNTRL_LC_utf8&lt;/code&gt;, &lt;code&gt;isDIGIT_LC_utf8&lt;/code&gt;, &lt;code&gt;isGRAPH_LC_utf8&lt;/code&gt;, &lt;code&gt;isIDCONT_LC_utf8&lt;/code&gt;, &lt;code&gt;isIDFIRST_LC_utf8&lt;/code&gt;, &lt;code&gt;isLOWER_LC_utf8&lt;/code&gt;, &lt;code&gt;isPRINT_LC_utf8&lt;/code&gt;, &lt;code&gt;isPSXSPC_LC_utf8&lt;/code&gt;, &lt;code&gt;isPUNCT_LC_utf8&lt;/code&gt;, &lt;code&gt;isSPACE_LC_utf8&lt;/code&gt;, &lt;code&gt;isUPPER_LC_utf8&lt;/code&gt;, &lt;code&gt;isWORDCHAR_LC_utf8&lt;/code&gt;, &lt;code&gt;isXDIGIT_LC_utf8&lt;/code&gt;, &lt;code&gt;toFOLD_utf8&lt;/code&gt;, &lt;code&gt;toLOWER_utf8&lt;/code&gt;, &lt;code&gt;toTITLE_utf8&lt;/code&gt;, and &lt;code&gt;toUPPER_utf8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1139ce181f4f4cad2c7f324461583f5984431bd" translate="yes" xml:space="preserve">
          <source>The macros to simplify this type of error propagation are</source>
          <target state="translated">简化这种类型的错误传播的宏是</target>
        </trans-unit>
        <trans-unit id="c70f4757860a22dec9e7cd7195f5c976eb6e087f" translate="yes" xml:space="preserve">
          <source>The mailbox (MBX) that perl can create to communicate with a pipe defaults to a buffer size of 8192 on 64-bit systems, 512 on VAX. The default buffer size is adjustable via the logical name PERL_MBX_SIZE provided that the value falls between 128 and the SYSGEN parameter MAXBUF inclusive. For example, to set the mailbox size to 32767 use &lt;code&gt;$ENV{'PERL_MBX_SIZE'} = 32767;&lt;/code&gt; and then open and use pipe constructs. An alternative would be to issue the command:</source>
          <target state="translated">perl可以创建以与管道进行通信的邮箱（MBX）在64位系统上默认为8192，在VAX上为512。缺省缓冲区大小可通过逻辑名PERL_MBX_SIZE进行调整，条件是该值介于128和SYSGEN参数MAXBUF（含）之间。例如，要将邮箱大小设置为32767，请使用 &lt;code&gt;$ENV{'PERL_MBX_SIZE'} = 32767;&lt;/code&gt; 然后打开并使用管道结构。一种替代方法是发出命令：</target>
        </trans-unit>
        <trans-unit id="08ec92a415b0c7db1f570cc5fe1a3d90ed229b88" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$]&lt;/code&gt; over &lt;code&gt;$^V&lt;/code&gt; is that it works the same on any version of Perl. The disadvantages are that it can't easily be compared to versions in other formats (e.g. literal v-strings, &quot;v1.2.3&quot; or version objects) and numeric comparisons are subject to the binary floating point representation; it's good for numeric literal version checks and bad for comparing to a variable that hasn't been sanity-checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5ef5a84eaac465306135c82a819527f916862a" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$]&lt;/code&gt; over &lt;code&gt;$^V&lt;/code&gt; is that it works the same on any version of Perl. The disadvantages are that it can't easily be compared to versions in other formats (e.g. literal v-strings, &quot;v1.2.3&quot; or version objects) and numeric comparisons can occasionally fail; it's good for string literal version checks and bad for comparing to a variable that hasn't been sanity-checked.</source>
          <target state="translated">&lt;code&gt;$]&lt;/code&gt; 优于 &lt;code&gt;$^V&lt;/code&gt; 的主要优点是，它在任何版本的Perl上都可以工作。缺点是无法轻易将其与其他格式的版本（例如文字v字符串，&amp;ldquo; v1.2.3&amp;rdquo;或版本对象）进行比较，并且数值比较有时会失败；这对于字符串文字版本检查很有用，而对于与未经完整性检查的变量进行比较则不利。</target>
        </trans-unit>
        <trans-unit id="4dbfa08a8a6c8cbfafaef8a1a762c3513a39fb28" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$^V&lt;/code&gt; over &lt;code&gt;$]&lt;/code&gt; is that, for Perl v5.10.0 or later, it overloads operators, allowing easy comparison against other version representations (e.g. decimal, literal v-string, &quot;v1.2.3&quot;, or objects). The disadvantage is that prior to v5.10.0, it was only a literal v-string, which can't be easily printed or compared, whereas the behavior of &lt;code&gt;$]&lt;/code&gt; is unchanged on all versions of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb52b8877c2d456ae00a93e532373fbd1c4c24a5" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$^V&lt;/code&gt; over &lt;code&gt;$]&lt;/code&gt; is that, for Perl v5.10.0 or later, it overloads operators, allowing easy comparison against other version representations (e.g. decimal, literal v-string, &quot;v1.2.3&quot;, or objects). The disadvantage is that prior to v5.10.0, it was only a literal v-string, which can't be easily printed or compared.</source>
          <target state="translated">&lt;code&gt;$^V&lt;/code&gt; 优于 &lt;code&gt;$]&lt;/code&gt; 的主要优点是，对于Perl v5.10.0或更高版本，它会重载运算符，从而可以轻松地与其他版本表示形式进行比较（例如，十进制，文字v字符串，&amp;ldquo; v1.2.3&amp;rdquo;或对象） 。缺点是在v5.10.0之前，它只是一个文字v字符串，无法轻松打印或比较。</target>
        </trans-unit>
        <trans-unit id="101d1c6f485f1984d68802df9d96ca30aed70d37" translate="yes" xml:space="preserve">
          <source>The main change in &lt;code&gt;Compress::Zlib&lt;/code&gt; version 2.x is that it does not now interface directly to the zlib library. Instead it uses the &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; modules for reading/writing gzip files, and the &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; module for some low-level zlib access.</source>
          <target state="translated">&lt;code&gt;Compress::Zlib&lt;/code&gt; 版本2.x 的主要变化是，它现在不直接与zlib库交互。相反，它使用 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 和 &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; 模块读取/写入gzip文件，并使用 &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; 模块进行一些低级zlib访问。</target>
        </trans-unit>
        <trans-unit id="372171de4da878145ca85489d35a3856b5f753b3" translate="yes" xml:space="preserve">
          <source>The main difference between this form of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method and the previous one, is that this one will attempt to return</source>
          <target state="translated">这种形式的 &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 方法与上一种形式的主要区别在于，该形式将尝试返回</target>
        </trans-unit>
        <trans-unit id="208796ee71984ca1960f03809fd6acd6ef109429" translate="yes" xml:space="preserve">
          <source>The main difference between this form of the &lt;code&gt;read&lt;/code&gt; method and the previous one, is that this one will attempt to return</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="506249c3cb5dbdd1518162463cf96d2d3b772f7e" translate="yes" xml:space="preserve">
          <source>The main difference in your code when using &lt;code&gt;LimitOutput&lt;/code&gt; is having to deal with cases where the &lt;code&gt;$input&lt;/code&gt; parameter still contains some uncompressed data that &lt;code&gt;inflate&lt;/code&gt; hasn't processed yet. The status code returned from &lt;code&gt;inflate&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; if uncompression took place and &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; if the output buffer is full.</source>
          <target state="translated">在你的代码的主要区别在使用 &lt;code&gt;LimitOutput&lt;/code&gt; 是必须处理的情况下 &lt;code&gt;$input&lt;/code&gt; 参数仍然包含一些非压缩数据 &lt;code&gt;inflate&lt;/code&gt; 尚未处理。从返回的状态代码 &lt;code&gt;inflate&lt;/code&gt; 将 &lt;code&gt;Z_OK&lt;/code&gt; 如果解压缩发生和 &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; 如果输出缓冲区已满。</target>
        </trans-unit>
        <trans-unit id="92b5e72aa08b04ddc99309d77bb3cb7a3bd1fb12" translate="yes" xml:space="preserve">
          <source>The main division in the context struct is between a substitution scope (&lt;code&gt;CXt_SUBST&lt;/code&gt;) and block scopes, which are everything else. The former is just used while executing &lt;code&gt;s///e&lt;/code&gt;, and won't be discussed further here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05152f518d0f3656c0688ee9cee29d35fcced80c" translate="yes" xml:space="preserve">
          <source>The main enhancements over the standard DBM Filter hooks are:</source>
          <target state="translated">与标准的DBM Filter钩子相比,主要增强了以下几点。</target>
        </trans-unit>
        <trans-unit id="e1f5b26355b7b70560c834756cb61711542dab38" translate="yes" xml:space="preserve">
          <source>The main interface to Perl's documentation is &lt;code&gt;perldoc&lt;/code&gt; , although if you're reading this, it's more than likely that you've already found it.</source>
          <target state="translated">Perl文档的主要界面是 &lt;code&gt;perldoc&lt;/code&gt; ，尽管如果您正在阅读本文，那么很有可能已经找到了它。</target>
        </trans-unit>
        <trans-unit id="d4c0d9f985e6490addfa7c9bcf66885ac7eb6fd4" translate="yes" xml:space="preserve">
          <source>The main interface to Perl's documentation is &lt;code&gt;perldoc&lt;/code&gt;, although if you're reading this, it's more than likely that you've already found it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d35e12fdba0e51aa394bd8618a43431bb51d2f3" translate="yes" xml:space="preserve">
          <source>The main processing loop in the code handles reading of compressed data from STDIN.</source>
          <target state="translated">代码中的主处理循环处理从STDIN读取压缩数据。</target>
        </trans-unit>
        <trans-unit id="10be13178c7ed17eb7ff58045f81aad5069fb2a4" translate="yes" xml:space="preserve">
          <source>The main reason for using these constants is to help avoid spelling mistakes and similar typos. It will not help you if you forget to prefix the '+' though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fda3610207ec49730bec59c6f9f9a606bd23ef" translate="yes" xml:space="preserve">
          <source>The main restriction is that everything is a metacharacter. Thus, you cannot refer to single characters by doing something like this:</source>
          <target state="translated">主要的限制是,所有的东西都是元字符。因此,你不能通过这样的方式来引用单个字符。</target>
        </trans-unit>
        <trans-unit id="5f01e11115c777ec013558e25689beffe8389e6e" translate="yes" xml:space="preserve">
          <source>The main run-time, i.e. the execution of &lt;code&gt;PL_main_root&lt;/code&gt; .</source>
          <target state="translated">主要运行时，即 &lt;code&gt;PL_main_root&lt;/code&gt; 的执行。</target>
        </trans-unit>
        <trans-unit id="d7fd0d727cdc1e3c76c39fb195a6b8c660cb66d4" translate="yes" xml:space="preserve">
          <source>The main run-time, i.e. the execution of &lt;code&gt;PL_main_root&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fc4f091ec88a6495b33730022421e8180365bf" translate="yes" xml:space="preserve">
          <source>The main thing to bear in mind when comparing Perl's</source>
          <target state="translated">在比较Perl的</target>
        </trans-unit>
        <trans-unit id="c06e6958bf7f6e1def3af629026b1de09d93eea1" translate="yes" xml:space="preserve">
          <source>The main two standard installer modules are the old and well established ExtUtils::MakeMaker (for short: EUMM) which uses the Makefile.PL. And the next generation installer Module::Build (MB) which works with the Build.PL (and often comes with a Makefile.PL too). If a module comes only with one of the two we will use that one but if both are supplied then a decision must be made between EUMM and MB. See also &lt;a href=&quot;http://rt.cpan.org/Ticket/Display.html?id=29235&quot;&gt;http://rt.cpan.org/Ticket/Display.html?id=29235&lt;/a&gt; for a discussion about the right default.</source>
          <target state="translated">两个主要的标准安装程序模块是使用Makefile.PL的古老且完善的ExtUtils :: MakeMaker（简称：EUMM）。以及与Build.PL一起使用的下一代安装程序Module :: Build（MB）（通常也附带Makefile.PL）。如果模块仅带有两个模块中的一个，我们将使用该模块，但是如果同时提供了两个模块，则必须在EUMM和MB之间做出决定。另请参见&lt;a href=&quot;http://rt.cpan.org/Ticket/Display.html?id=29235&quot;&gt;http://rt.cpan.org/Ticket/Display.html?id=29235&lt;/a&gt;，以获取有关正确默认值的讨论。</target>
        </trans-unit>
        <trans-unit id="4a4d251a87e0958567984c04589a931c90f147e2" translate="yes" xml:space="preserve">
          <source>The main two standard installer modules are the old and well established ExtUtils::MakeMaker (for short: EUMM) which uses the Makefile.PL. And the next generation installer Module::Build (MB) which works with the Build.PL (and often comes with a Makefile.PL too). If a module comes only with one of the two we will use that one but if both are supplied then a decision must be made between EUMM and MB. See also http://rt.cpan.org/Ticket/Display.html?id=29235 for a discussion about the right default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05599914a88c35566cdc46d5be82351b5056b7bb" translate="yes" xml:space="preserve">
          <source>The main use for &lt;code&gt;ascii&lt;/code&gt; is to force the output to not contain characters with values &amp;gt; 127, which means you can interpret the resulting string as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and 8-bit-encoding, and still get the same data structure back. This is useful when your channel for JSON transfer is not 8-bit clean or the encoding might be mangled in between (e.g. in mail), and works because ASCII is a proper subset of most 8-bit and multibyte encodings in use in the world.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa39b18861e8c0d0fbd241aca023fce2a33049ad" translate="yes" xml:space="preserve">
          <source>The main use for &lt;code&gt;latin1&lt;/code&gt; is to relatively efficiently store binary data as JSON, at the expense of breaking compatibility with most JSON decoders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866c41ef1cd5e3c514447a1eb0c0a78fc5c432a8" translate="yes" xml:space="preserve">
          <source>The main use for this flag is efficiently encoding binary data as JSON text, as most octets will not be escaped, resulting in a smaller encoded size. The disadvantage is that the resulting JSON text is encoded in latin1 (and must correctly be treated as such when storing and transferring), a rare encoding for JSON. It is therefore most useful when you want to store data structures known to contain binary data efficiently in files or databases, not when talking to other JSON encoders/decoders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06fa4e1ba42a335acb6388e4bce2e76ff0904fc1" translate="yes" xml:space="preserve">
          <source>The main use for this flag is to produce JSON texts that can be transmitted over a 7-bit channel, as the encoded JSON texts will not contain any 8 bit characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f8fe511450837b8803ee63b84fd8df2352eb1f" translate="yes" xml:space="preserve">
          <source>The main use of the &lt;code&gt;@_&lt;/code&gt; pass-through feature is to write subroutines whose main job it is to call other subroutines for you. For further details, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@_&lt;/code&gt; 传递功能的主要用途是编写子例程，其主要工作是为您调用其他子例程。有关更多详细信息，请参见&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53e4e2133c40d29e72103e441a447d5a4a38fc75" translate="yes" xml:space="preserve">
          <source>The main use of typeglobs in modern Perl is create symbol table aliases. This assignment:</source>
          <target state="translated">在现代Perl中,typeglobs的主要用途是创建符号表别名。这个赋值。</target>
        </trans-unit>
        <trans-unit id="69b1898f468b9694e16716e650f4f44f6641ba6b" translate="yes" xml:space="preserve">
          <source>The main way they do this is by abstracting the solution into a Perl module. If you don't know what one of these is, the rest of this document isn't going to be much use to you. You're also missing out on an awful lot of useful code; consider having a look at &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; and &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt; before coming back here.</source>
          <target state="translated">他们这样做的主要方法是将解决方案抽象到Perl模块中。如果您不知道其中的一个是什么，那么本文档的其余部分对您将无用。您还错过了很多有用的代码。在回到这里之前，请考虑看看&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;，&lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt;和&lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f1c38b1c10cfb3cbb67b1b10b401ccad6c0863c" translate="yes" xml:space="preserve">
          <source>The main workhorse. This is a chimera executable: it is compiled as an &lt;code&gt;a.out&lt;/code&gt; -style executable, but is linked with &lt;code&gt;omf&lt;/code&gt; -style dynamic library</source>
          <target state="translated">主要力量。这是一个嵌合体可执行文件：它被编译为 &lt;code&gt;a.out&lt;/code&gt; -style可执行文件，但与 &lt;code&gt;omf&lt;/code&gt; -style动态库链接</target>
        </trans-unit>
        <trans-unit id="545144eca602ef4173887f0da06edec85e29ecc4" translate="yes" xml:space="preserve">
          <source>The main workhorse. This is a chimera executable: it is compiled as an &lt;code&gt;a.out&lt;/code&gt;-style executable, but is linked with &lt;code&gt;omf&lt;/code&gt;-style dynamic library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3956c803121907ff5d6974bf9c432a88f1cf833c" translate="yes" xml:space="preserve">
          <source>The major headers should be set out using a &lt;code&gt;=head1&lt;/code&gt; directive, and are historically written in the rather startling ALL UPPER CASE format; this is not mandatory, but it's strongly recommended so that sections have consistent naming across different software packages. Minor headers may be included using &lt;code&gt;=head2&lt;/code&gt; , and are typically in mixed case.</source>
          <target state="translated">主要标头应使用 &lt;code&gt;=head1&lt;/code&gt; 指令设置，并在过去以令人震惊的ALL UPPER CASE格式编写；这不是强制性的，但强烈建议这样做，以使各部分在不同的软件包之间具有一致的命名。可以使用 &lt;code&gt;=head2&lt;/code&gt; 包含次要标头，并且通常在混合情况下使用。</target>
        </trans-unit>
        <trans-unit id="00d415a583ddacb7562640a4ed5cbc374d3a4aac" translate="yes" xml:space="preserve">
          <source>The major headers should be set out using a &lt;code&gt;=head1&lt;/code&gt; directive, and are historically written in the rather startling ALL UPPER CASE format; this is not mandatory, but it's strongly recommended so that sections have consistent naming across different software packages. Minor headers may be included using &lt;code&gt;=head2&lt;/code&gt;, and are typically in mixed case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d78be692306962b0b26bf44b44f51f19191990" translate="yes" xml:space="preserve">
          <source>The major reference book on Perl, written by the creator of Perl, is</source>
          <target state="translated">关于Perl的主要参考书是由Perl的创造者所写的。</target>
        </trans-unit>
        <trans-unit id="13680a9d6e9227284375bc26da8c5530041e38fc" translate="yes" xml:space="preserve">
          <source>The majority of messages from the first three classifications above (W, D &amp;amp; S) can be controlled using the &lt;code&gt;warnings&lt;/code&gt; pragma.</source>
          <target state="translated">可以使用 &lt;code&gt;warnings&lt;/code&gt; 编译指示来控制上述前三个类别（W，D和S）中的大多数消息。</target>
        </trans-unit>
        <trans-unit id="47a0713a7794ab11956a543900cb0615be7d2460" translate="yes" xml:space="preserve">
          <source>The majority of the code above is concerned with reading the zip local header data. The code that I want to focus on is at the bottom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd369e1f787ef0292f11539410c5f0156585f6b5" translate="yes" xml:space="preserve">
          <source>The make process also creates the Perl extensions as</source>
          <target state="translated">make过程还将Perl扩展创建为</target>
        </trans-unit>
        <trans-unit id="6834c3d08e7b64ac9a3d75579db624c6bb6535ce" translate="yes" xml:space="preserve">
          <source>The make process runs only under WinNT shell. The NetWare makefile is located under the NetWare folder. This makes use of miniperl.exe to run some of the Perl scripts. To create miniperl.exe, first set the required paths for Visual c++ compiler (specify vcvars32 location) at the command prompt. Then run nmake from win32 folder through WinNT command prompt. The build process can be stopped after miniperl.exe is created. Then run nmake from NetWare folder through WinNT command prompt.</source>
          <target state="translated">make进程只在WinNT shell下运行。NetWare的makefile位于NetWare文件夹下,它使用miniperl.exe来运行一些Perl脚本。这就利用miniperl.exe来运行一些Perl脚本。要创建miniperl.exe,首先在命令提示符下设置Visual c++编译器所需的路径(指定vcvars32位置)。然后通过WinNT命令提示符从win32文件夹运行nmake。创建miniperl.exe后,可以停止构建过程。然后通过WinNT命令提示符从NetWare文件夹运行nmake。</target>
        </trans-unit>
        <trans-unit id="6f3be1c564860e93ed0610de17db5187711f88d0" translate="yes" xml:space="preserve">
          <source>The make target 'allsis' combines all the above SIS targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050ece2e16daad9919f83779717a0433d9f5277b" translate="yes" xml:space="preserve">
          <source>The make under /usr/ccs/bin works fine for building perl. If you have the Sun C compilers, you will also have a parallel version of make (dmake). This works fine to build perl, but can sometimes cause problems when running 'make test' due to underspecified dependencies between the different test harness files. The same problem can also affect the building of some add-on modules, so in those cases either specify '-m serial' on the dmake command line, or use /usr/ccs/bin/make instead. If you wish to use GNU make, be sure that the set-group-id bit is not set. If it is, then arrange your PATH so that /usr/ccs/bin/make is before GNU make or else have the system administrator disable the set-group-id bit on GNU make.</source>
          <target state="translated">在/usr/ccs/bin下的make可以很好地用于构建perl。如果你有Sun C编译器,你也会有一个并行版本的make(dmake)。这在构建perl时工作得很好,但在运行 &quot;make test &quot;时,有时会因为不同的test harness文件之间的依赖关系不够明确而导致问题。同样的问题也会影响一些附加模块的构建,所以在这种情况下,可以在dmake命令行中指定'-m serial',或者使用/usr/ccs/bin/make。如果你想使用 GNU make,请确保 set-group-id 位没有被设置。如果是,则应安排 PATH,使 /usr/ccs/bin/make 位于 GNU make 之前,否则请系统管理员禁用 GNU make 的 set-group-id 位。</target>
        </trans-unit>
        <trans-unit id="093c5a0fa4f10414f0bded11d9711f892cf8d016" translate="yes" xml:space="preserve">
          <source>The makefile for Win32 is used as a reference to create the makefile for NetWare. Also, the make process for NetWare port uses miniperl.exe to run scripts during the make and installation process.</source>
          <target state="translated">Win32的makefile被用作创建NetWare的makefile的参考。此外,NetWare端口的make过程使用miniperl.exe在make和安装过程中运行脚本。</target>
        </trans-unit>
        <trans-unit id="27e98181ad3a79924d7fd39b526549233ec76d6a" translate="yes" xml:space="preserve">
          <source>The man page documenting the an macro set may be</source>
          <target state="translated">记载宏集的手册页可以是</target>
        </trans-unit>
        <trans-unit id="623ee701bbcdbe97eed930b9efd8035f1a031aee" translate="yes" xml:space="preserve">
          <source>The man page documenting the an macro set may be &lt;a href=&quot;http://man.he.net/man5/man&quot;&gt;man(5)&lt;/a&gt; instead of &lt;a href=&quot;http://man.he.net/man7/man&quot;&gt;man(7)&lt;/a&gt; on your system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b2bfc99455c361765a64ae36b53dd690daec7f" translate="yes" xml:space="preserve">
          <source>The man page documenting the man macro set may be</source>
          <target state="translated">记录man宏集的man页面可以是</target>
        </trans-unit>
        <trans-unit id="7f7916f4586e4282d358ae1052455bb329b90846" translate="yes" xml:space="preserve">
          <source>The man page documenting the man macro set may be &lt;a href=&quot;http://man.he.net/man5/man&quot;&gt;man(5)&lt;/a&gt; instead of &lt;a href=&quot;http://man.he.net/man7/man&quot;&gt;man(7)&lt;/a&gt; on your system. Also, please see &lt;a href=&quot;http://man.he.net/man1/pod2man&quot;&gt;pod2man(1)&lt;/a&gt; for extensive documentation on writing manual pages if you've not done it before and aren't familiar with the conventions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284a6c5b883e0ac48b839ca370726900339633bc" translate="yes" xml:space="preserve">
          <source>The mandatory parameter &lt;code&gt;$input&lt;/code&gt; is used to determine the source of the compressed data. This parameter can take one of three forms.</source>
          <target state="translated">强制参数 &lt;code&gt;$input&lt;/code&gt; 用于确定压缩数据的来源。该参数可以采用以下三种形式之一。</target>
        </trans-unit>
        <trans-unit id="c485ab3d22837e3f8be3f1796e0e79d8c8f06f1f" translate="yes" xml:space="preserve">
          <source>The mandatory parameter &lt;code&gt;$output&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">强制参数 &lt;code&gt;$output&lt;/code&gt; 用于控制压缩数据的目的地。该参数可以采用以下形式之一。</target>
        </trans-unit>
        <trans-unit id="de616d536d8ef10cc9a3f654a8c90f376abf8093" translate="yes" xml:space="preserve">
          <source>The manual for GNU &lt;code&gt;gettext&lt;/code&gt; . The gettext dist is available in &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; -- get a recent gettext tarball and look in its &quot;doc/&quot; directory, there's an easily browsable HTML version in there. The gettext documentation asks lots of questions worth thinking about, even if some of their answers are sometimes wonky, particularly where they start talking about pluralization.</source>
          <target state="translated">GNU &lt;code&gt;gettext&lt;/code&gt; 手册。gettext dist可在 &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; 中获得-获取最新的gettext压缩文件，并在其&amp;ldquo; doc /&amp;rdquo;目录中查找，那里有一个易于浏览的HTML版本。gettext文档提出了许多值得考虑的问题，即使他们的某些回答有时有些古怪，尤其是在他们开始谈论多元性的地方。</target>
        </trans-unit>
        <trans-unit id="b1839a690d37e18249310936fdff387ca895bbd5" translate="yes" xml:space="preserve">
          <source>The manual for GNU &lt;code&gt;gettext&lt;/code&gt;. The gettext dist is available in &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; -- get a recent gettext tarball and look in its &quot;doc/&quot; directory, there's an easily browsable HTML version in there. The gettext documentation asks lots of questions worth thinking about, even if some of their answers are sometimes wonky, particularly where they start talking about pluralization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="154ce4660707f31f1810dc0e3b48188806eef41c" translate="yes" xml:space="preserve">
          <source>The many &lt;code&gt;SO_*&lt;/code&gt; and other constants provide the socket option names for getsockopt() and setsockopt().</source>
          <target state="translated">许多 &lt;code&gt;SO_*&lt;/code&gt; 和其他常量为getsockopt（）和setsockopt（）提供套接字选项名称。</target>
        </trans-unit>
        <trans-unit id="55aaa52fca491aa374cc9b313f0827cacbb95ed1" translate="yes" xml:space="preserve">
          <source>The map of tags-to-names that it uses is accessible as %I18N::LangTags::List::Name, and it's the same as the list that follows in this documentation, which should be useful to you even if you don't use this module.</source>
          <target state="translated">它所使用的标签到名称的映射可以访问%I18N::LangTags::List::Name,它和本文档中后面的列表是一样的,即使你不使用这个模块,也应该对你有用。</target>
        </trans-unit>
        <trans-unit id="4ec748c6f374bea6dd407e2a2206dd66cc0ef16e" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and Perl is stored in the global hash &lt;code&gt;Mapping&lt;/code&gt; this time. Using a hash has the distinct advantage that it allows an unlimited number of callbacks to be registered.</source>
          <target state="translated">这次，C回调和Perl之间的映射存储在全局哈希 &lt;code&gt;Mapping&lt;/code&gt; 。使用哈希具有明显的优势，即它允许注册无限数量的回调。</target>
        </trans-unit>
        <trans-unit id="3b99545de853bbada80b111bce027d144c0231ba" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and the Perl equivalent is stored in the global variable &lt;code&gt;callback&lt;/code&gt; .</source>
          <target state="translated">C回调和Perl等效项之间的映射存储在全局变量 &lt;code&gt;callback&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="8e93b95ea6fe70dd3da986ffb8fe9a8d23395a81" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and the Perl equivalent is stored in the global variable &lt;code&gt;callback&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc01e02bb3d7483c767fb0c7888218cdd8db8748" translate="yes" xml:space="preserve">
          <source>The mapping from Perl to JSON is slightly more difficult, as Perl is a truly typeless language, so we can only guess which JSON type is meant by a Perl value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a662bfcb14335a42ef03f81101790bf366195df" translate="yes" xml:space="preserve">
          <source>The mapping of &lt;code&gt;U+FFFD&lt;/code&gt; is corrected in Unicode 6.3.0. see &lt;a href=&quot;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&quot;&gt;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&lt;/a&gt; (7.1.4 Trailing Weights). Such a correction is reproduced by this.</source>
          <target state="translated">&lt;code&gt;U+FFFD&lt;/code&gt; 的映射在Unicode 6.3.0中已得到纠正。请参阅&lt;a href=&quot;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&quot;&gt;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights（7.1.4&lt;/a&gt;尾随权重）。由此再现这种校正。</target>
        </trans-unit>
        <trans-unit id="bff19693156a4d3c9d0ae54fb777710debdba865" translate="yes" xml:space="preserve">
          <source>The maps for almost all properties are simple scalars that should be interpreted as-is. These values are those given in the Unicode-supplied data files, which may be inconsistent as to capitalization and as to which synonym for a property-value is given. The results may be normalized by using the &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b1175bc8b4e9784f2300c93388884be8f7673f" translate="yes" xml:space="preserve">
          <source>The maps for almost all properties are simple scalars that should be interpreted as-is. These values are those given in the Unicode-supplied data files, which may be inconsistent as to capitalization and as to which synonym for a property-value is given. The results may be normalized by using the &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function.</source>
          <target state="translated">几乎所有属性的映射都是应按原样解释的简单标量。这些值是在Unicode提供的数据文件中给出的值，这些值在大小写以及给出属性值的同义词方面可能不一致。可以使用&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数将结果标准化。</target>
        </trans-unit>
        <trans-unit id="d366a92e1e29300af2573c9ebee67dbf16243194" translate="yes" xml:space="preserve">
          <source>The maps for the following are available at &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; but remain unsupported because those encodings need an algorithmical approach, currently unsupported by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2864353a5c8a1c71a51a027ee705129966bd16" translate="yes" xml:space="preserve">
          <source>The mark stack stores integers as I32 values, which are the height of the value stack at the time before the list began; thus the mark itself actually points to the value stack entry one before the list. The list itself starts at &lt;code&gt;mark + 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4bf89cabbc9315682f2b81d303b6aa4fa34849" translate="yes" xml:space="preserve">
          <source>The markup used to embed documentation into your Perl code. Pod stands for &amp;ldquo;Plain old documentation&amp;rdquo;. See Camel chapter 23, &amp;ldquo;Plain Old Documentation&amp;rdquo;.</source>
          <target state="translated">用于将文档嵌入到您的Perl代码中的标记。Pod代表&amp;ldquo;普通的旧文档&amp;rdquo;。请参见骆驼第23章，&amp;ldquo;普通旧文档&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="34cc83ddfdc06a0bade5acdcde84b75e2705b198" translate="yes" xml:space="preserve">
          <source>The master web site for CPAN is &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;, &lt;a href=&quot;http://www.cpan.org/SITES.html&quot;&gt;http://www.cpan.org/SITES.html&lt;/a&gt; lists all mirrors.</source>
          <target state="translated">主网站的CPAN是&lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;，&lt;a href=&quot;http://www.cpan.org/SITES.html&quot;&gt;http://www.cpan.org/SITES.html&lt;/a&gt;列出了所有的镜子。</target>
        </trans-unit>
        <trans-unit id="3c45f7edc42ff58b499f5e637a319d744b7420b9" translate="yes" xml:space="preserve">
          <source>The match is greedy and non-backtracking, so that the cluster is never broken up into smaller components.</source>
          <target state="translated">匹配是贪婪的和非回溯的,因此集群永远不会被分解成更小的组件。</target>
        </trans-unit>
        <trans-unit id="c68736af7f30812a5478f14010c89b4ae65386b0" translate="yes" xml:space="preserve">
          <source>The match operator is &quot;=~&quot;, not &quot;~&quot;. (&quot;~&quot; is the one's complement operator, as in C.)</source>
          <target state="translated">匹配运算符是&quot;=~&quot;,不是&quot;~&quot;。(&quot;~&quot;是一的补码运算符,如C语言。)</target>
        </trans-unit>
        <trans-unit id="5795a85f98b64dffbf8aba9e904fb2bc93749e98" translate="yes" xml:space="preserve">
          <source>The match operator is a double quote context, so you can interpolate your variable just like a double quoted string. In this case, you read the regular expression as user input and store it in &lt;code&gt;$regex&lt;/code&gt; . Once you have the pattern in &lt;code&gt;$regex&lt;/code&gt; , you use that variable in the match operator.</source>
          <target state="translated">match运算符是双引号上下文，因此您可以像双引号字符串一样对变量进行插值。在这种情况下，您将正则表达式作为用户输入读取，并将其存储在 &lt;code&gt;$regex&lt;/code&gt; 。一旦在 &lt;code&gt;$regex&lt;/code&gt; 有了模式，就可以在match运算符中使用该变量。</target>
        </trans-unit>
        <trans-unit id="fc14d244fbe8a0161a49513d59d3516c03861ccd" translate="yes" xml:space="preserve">
          <source>The match operator is a double quote context, so you can interpolate your variable just like a double quoted string. In this case, you read the regular expression as user input and store it in &lt;code&gt;$regex&lt;/code&gt;. Once you have the pattern in &lt;code&gt;$regex&lt;/code&gt;, you use that variable in the match operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab1da87cbb5d0fd800bfa0309cbbc3c397f76b8" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">匹配运算符。请参阅&lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop中的Regexp类似引用运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2d946e2bfb34dd4f7ba8364971084f9045ae306" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23da9f3c77f641f40df01068ee8c7ee0a479ea6c" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">匹配运算符。请参阅&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop中的Regexp类似引用运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f542541549a1bc6970c3286cf46be7af8b4f2d05" translate="yes" xml:space="preserve">
          <source>The match-once behavior is controlled by the match delimiter being &lt;code&gt;?&lt;/code&gt;; with any other delimiter this is the normal &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">一次匹配行为由匹配定界符控制为 &lt;code&gt;?&lt;/code&gt; ; 与其他定界符一起使用时，这是常规的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="9eb42805d07d25374f7b5e9e6773ad7d57c9e1fb" translate="yes" xml:space="preserve">
          <source>The match-once behavior is controlled by the match delimiter being &lt;code&gt;?&lt;/code&gt;; with any other delimiter this is the normal &lt;code&gt;m//&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeba81f62bbef449f5b856ee7d56cb86c716867d" translate="yes" xml:space="preserve">
          <source>The matched-pattern variables, &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; (pre-match), &lt;code&gt;$'&lt;/code&gt; (post-match), and &lt;code&gt;$+&lt;/code&gt; (last match) also are tainted.</source>
          <target state="translated">匹配模式变量 &lt;code&gt;$&amp;amp;&lt;/code&gt; ， &lt;code&gt;$`&lt;/code&gt; （赛前）， &lt;code&gt;$'&lt;/code&gt; （赛后）和 &lt;code&gt;$+&lt;/code&gt; （最后赛）也被污染。</target>
        </trans-unit>
        <trans-unit id="22ab92cf81444e038908ef762ce8e093bd1b736d" translate="yes" xml:space="preserve">
          <source>The matched-pattern variables, &lt;code&gt;$&amp;amp;&lt;/code&gt;, &lt;code&gt;$`&lt;/code&gt; (pre-match), &lt;code&gt;$'&lt;/code&gt; (post-match), and &lt;code&gt;$+&lt;/code&gt; (last match) also are tainted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef4278a734cc2ba9814c78fdf30442bf1892ae1" translate="yes" xml:space="preserve">
          <source>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. Note that the &lt;code&gt;:utf8&lt;/code&gt; layer must always be specified exactly like that; it is</source>
          <target state="translated">编码名称的匹配很松散：大小写无关紧要，许多编码都有几个别名。注意 &lt;code&gt;:utf8&lt;/code&gt; 层必须始终完全一样指定。它是</target>
        </trans-unit>
        <trans-unit id="906f4ce57c5894760cba731d333a52399d7a0c38" translate="yes" xml:space="preserve">
          <source>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. See &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt; for details and the list of supported locales.</source>
          <target state="translated">编码名称的匹配很松散：大小写无关紧要，许多编码都有几个别名。有关详细信息和支持的语言环境，请参见&lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f9b61e44ff3edc932c4eb7e36f1dd657aefd954" translate="yes" xml:space="preserve">
          <source>The material below is separated into three main sections: main issues of portability (&lt;a href=&quot;#ISSUES&quot;&gt;&quot;ISSUES&quot;&lt;/a&gt;), platform-specific issues (&lt;a href=&quot;#PLATFORMS&quot;&gt;&quot;PLATFORMS&quot;&lt;/a&gt;), and built-in Perl functions that behave differently on various ports (&lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;&quot;FUNCTION IMPLEMENTATIONS&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5401e94f4440b62a9a27d03fcc9d30b1169f66e8" translate="yes" xml:space="preserve">
          <source>The material below is separated into three main sections: main issues of portability (&lt;a href=&quot;#ISSUES&quot;&gt;ISSUES&lt;/a&gt;), platform-specific issues (&lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS&lt;/a&gt;), and built-in Perl functions that behave differently on various ports (&lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;FUNCTION IMPLEMENTATIONS&lt;/a&gt;).</source>
          <target state="translated">下面的材料分为三个主要部分：可移植性的主要问题（&lt;a href=&quot;#ISSUES&quot;&gt;ISSUES&lt;/a&gt;），特定于平台的问题（&lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS&lt;/a&gt;）和在各个端口上表现不同的内置Perl函数（&lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;FUNCTION IMPLEMENTATIONS&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6fb16dd0911e0291e015ca052ebafe0545c2d31f" translate="yes" xml:space="preserve">
          <source>The mathematically logical behavior for what matches when inverting is very different from what people expect, so we have decided to forbid it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8bdf4570ce948d9dc30acbc885de4c23118fcd9" translate="yes" xml:space="preserve">
          <source>The maximal stack recursion limit for your system is returned by &lt;code&gt;stack_depth()&lt;/code&gt; and &lt;code&gt;stack_depth_hash()&lt;/code&gt;. The hash limit is usually half the size of the array and ref limit, as the Perl hash API is not optimal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a757bded9f533a67a5134eccc21794fdd0b6bd" translate="yes" xml:space="preserve">
          <source>The maximum Unicode code point is &lt;code&gt;U+10FFFF&lt;/code&gt; , and Unicode only defines operations on code points up through that. But Perl works on code points up to the maximum permissible unsigned number available on the platform. However, Perl will not accept these from input streams unless lax rules are being used, and will warn (using the warning category &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if any are output.</source>
          <target state="translated">最大Unicode代码点为 &lt;code&gt;U+10FFFF&lt;/code&gt; ，而Unicode仅定义在此之后的代码点上的操作。但是Perl可以处理的代码点数最多可以达到平台上可用的最大允许无符号数。但是，除非使用松散规则，否则Perl将不接受输入流中的这些内容，并且将输出警告（使用警告类别 &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; ，它是 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 的子类别）。</target>
        </trans-unit>
        <trans-unit id="b742e9c8b7767f6a214c8234694eb3d1179ce880" translate="yes" xml:space="preserve">
          <source>The maximum Unicode code point is &lt;code&gt;U+10FFFF&lt;/code&gt;, and Unicode only defines operations on code points up through that. But Perl works on code points up to the maximum permissible signed number available on the platform. However, Perl will not accept these from input streams unless lax rules are being used, and will warn (using the warning category &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt;, which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt;) if any are output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf34b110c57827c6b09abffd19d7c17fb58a109" translate="yes" xml:space="preserve">
          <source>The maximum number of UTF-8 bytes a single Unicode character can uppercase/lowercase/titlecase/fold into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc1808d3e3fb6de5739d08162d085e4fb2b2c51" translate="yes" xml:space="preserve">
          <source>The maximum number of parallel tests to run at any time. Which tests can be run in parallel is controlled by &lt;code&gt;rules&lt;/code&gt; . The default is to run only one test at a time.</source>
          <target state="translated">随时可以运行的最大并行测试数。哪些测试可以并行运行由 &lt;code&gt;rules&lt;/code&gt; 控制。默认设置是一次仅运行一个测试。</target>
        </trans-unit>
        <trans-unit id="406651585ee02adfd4eadd3dc163e4004c7e7bf5" translate="yes" xml:space="preserve">
          <source>The maximum number of parallel tests to run at any time. Which tests can be run in parallel is controlled by &lt;code&gt;rules&lt;/code&gt;. The default is to run only one test at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec24717c6af4893fa65de730b8ddea405e13134" translate="yes" xml:space="preserve">
          <source>The maximum number this construct can express is &lt;code&gt;\777&lt;/code&gt; . If you need a larger one, you need to use &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\o{}&lt;/a&gt; instead. If you meant two separate things, you need to separate them:</source>
          <target state="translated">此构造可以表示的最大数量为 &lt;code&gt;\777&lt;/code&gt; 。如果您需要更大的文件夹，则需要改用&lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\ o {}&lt;/a&gt;。如果您要分开两件事，则需要将它们分开：</target>
        </trans-unit>
        <trans-unit id="7227c386d0e30465e8c341c159e2afa8f961c0f3" translate="yes" xml:space="preserve">
          <source>The maximum number this construct can express is &lt;code&gt;\777&lt;/code&gt;. If you need a larger one, you need to use &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\o{}&lt;/a&gt; instead. If you meant two separate things, you need to separate them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823e727fb7ce51ed0c50f11b0b5dce6f9f8c6422" translate="yes" xml:space="preserve">
          <source>The maximum size of a Storable header is currently 21 bytes. If the provided $buffer is only the first part of a Storable image it should at least be this long to ensure that read_magic() will recognize it as such.</source>
          <target state="translated">Storable头的最大大小目前是21字节。如果所提供的$buffer只是Storable映像的第一部分,那么至少应该有这么长,以确保read_magic()能够识别它。</target>
        </trans-unit>
        <trans-unit id="54655c72af2839e9f037d863fc7638dac7966cf0" translate="yes" xml:space="preserve">
          <source>The maximum size of an extra field 65535 bytes.</source>
          <target state="translated">额外字段的最大大小为65535字节。</target>
        </trans-unit>
        <trans-unit id="60da8f51a4ded24731bf101a405dc42107509236" translate="yes" xml:space="preserve">
          <source>The maximum size of the Extra Field 65535 bytes.</source>
          <target state="translated">额外字段的最大大小为65535字节。</target>
        </trans-unit>
        <trans-unit id="51d29e4ee16b1b5f77f1b62a7cfc84201aec0810" translate="yes" xml:space="preserve">
          <source>The maximum system file descriptor, ordinarily 2. System file descriptors are passed to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;ed processes, while higher file descriptors are not. Also, during an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, system file descriptors are preserved even if the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; fails (ordinary file descriptors are closed before the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; is attempted). The close-on-exec status of a file descriptor will be decided according to the value of &lt;code&gt;$^F&lt;/code&gt; when the corresponding file, pipe, or socket was opened, not the time of the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最大系统文件描述符，通常为2。系统文件描述符传递给 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 进程，而更高的文件描述符则不传递。另外，在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 期间，即使 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 失败（通常文件描述符在尝试 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 之前关闭），系统文件描述符也会保留。当打开相应的文件，管道或套接字时，文件描述符的执行关闭状态将根据 &lt;code&gt;$^F&lt;/code&gt; 的值确定，而不是根据 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 的时间确定。</target>
        </trans-unit>
        <trans-unit id="255fcbaa29e8f59e394f504d9d5b97b78390691f" translate="yes" xml:space="preserve">
          <source>The maximum system file descriptor, ordinarily 2. System file descriptors are passed to &lt;code&gt;exec()&lt;/code&gt;ed processes, while higher file descriptors are not. Also, during an &lt;code&gt;open()&lt;/code&gt;, system file descriptors are preserved even if the &lt;code&gt;open()&lt;/code&gt; fails (ordinary file descriptors are closed before the &lt;code&gt;open()&lt;/code&gt; is attempted). The close-on-exec status of a file descriptor will be decided according to the value of &lt;code&gt;$^F&lt;/code&gt; when the corresponding file, pipe, or socket was opened, not the time of the &lt;code&gt;exec()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e89770735afbf4b1f68a8769fe96140987a421" translate="yes" xml:space="preserve">
          <source>The maximum width of a single UTF-8 encoded character, in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db9125f66ae949d81694c6e6210bfeb871e3d64e" translate="yes" xml:space="preserve">
          <source>The mechanism of translation of &lt;code&gt;\N{...}&lt;/code&gt; escapes is general and not hardwired into</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; 转义的翻译机制是一般性的，并非硬性地</target>
        </trans-unit>
        <trans-unit id="15610051fc12501695115ef5aed4c6968c7a9267" translate="yes" xml:space="preserve">
          <source>The members whose names begin with &lt;code&gt;int_p_&lt;/code&gt; and &lt;code&gt;int_n_&lt;/code&gt; were added by POSIX.1-2008 and are only available on systems that support them.</source>
          <target state="translated">名称以 &lt;code&gt;int_p_&lt;/code&gt; 和 &lt;code&gt;int_n_&lt;/code&gt; 开头的成员是POSIX.1-2008添加的，并且仅在支持它们的系统上可用。</target>
        </trans-unit>
        <trans-unit id="4d5d40b7966fb62c912a4471f016e0810caccade" translate="yes" xml:space="preserve">
          <source>The message attempts to include the name of the called subroutine. If the subroutine has been aliased, the subroutine's original name will be shown, regardless of what name the caller used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="003de5e9e6baa363e9c030caff26155e591e361d" translate="yes" xml:space="preserve">
          <source>The message for the diag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a832ceb4e1a37f34e093f08ce43b0057c15482" translate="yes" xml:space="preserve">
          <source>The message for the note.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0974f2e5536c89d5a7aa01e203cfd55eb3c162" translate="yes" xml:space="preserve">
          <source>The message will be taken from whatever locale would be used by &lt;code&gt;$!&lt;/code&gt;, and will be encoded in the SV in whatever manner would be used by &lt;code&gt;$!&lt;/code&gt;. The details of this process are subject to future change. Currently, the message is taken from the C locale by default (usually producing an English message), and from the currently selected locale when in the scope of the &lt;code&gt;use locale&lt;/code&gt; pragma. A heuristic attempt is made to decode the message from the locale's character encoding, but it will only be decoded as either UTF-8 or ISO-8859-1. It is always correctly decoded in a UTF-8 locale, usually in an ISO-8859-1 locale, and never in any other locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36545165ac282d6d6bbbc3b54b056ad82f2d5183" translate="yes" xml:space="preserve">
          <source>The message, either sent via &lt;code&gt;datasend&lt;/code&gt; or as the &lt;code&gt;MESSAGE&lt;/code&gt; parameter, must be in the format as described by RFC822 and must contain From:, Newsgroups: and Subject: headers.</source>
          <target state="translated">通过 &lt;code&gt;datasend&lt;/code&gt; 发送或作为 &lt;code&gt;MESSAGE&lt;/code&gt; 参数发送的消息，必须采用RFC822描述的格式，并且必须包含From：，Newsgroups和Subject：标头。</target>
        </trans-unit>
        <trans-unit id="ee89b7499807e434bb5f68dbb5e73957271240a3" translate="yes" xml:space="preserve">
          <source>The messages are in alphabetical order, without regard to upper or lower-case. Some of these messages are generic. Spots that vary are denoted with a %s or other printf-style escape. These escapes are ignored by the alphabetical order, as are all characters other than letters. To look up your message, just ignore anything that is not a letter.</source>
          <target state="translated">这些信息按字母顺序排列,不分大写或小写。其中一些信息是通用的。不同的地方用%s或其他printf式转义符表示。这些转义符会被字母顺序所忽略,除了字母以外的所有字符也是如此。要查找你的信息,只需忽略任何不是字母的字符。</target>
        </trans-unit>
        <trans-unit id="e3b332cdd50b0075e2980a517442567c35047868" translate="yes" xml:space="preserve">
          <source>The messages from error exits from inside the Perl core are generally more serious, and are not suppressed.</source>
          <target state="translated">从Perl核心内部错误退出的信息一般比较严重,不会被压制。</target>
        </trans-unit>
        <trans-unit id="f4b9735187b885f7dd604f43a0be8de295177167" translate="yes" xml:space="preserve">
          <source>The meta facet contains all the meta-data attached to the event. In this case the &lt;code&gt;details&lt;/code&gt; field has no special meaning, but may be present if something sets the 'details' meta-key on the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af14bb7cef38c681cd522700a18f3c2e85c4645f" translate="yes" xml:space="preserve">
          <source>The metacharacter &lt;code&gt;&quot;|&quot;&lt;/code&gt; is used to match one thing or another. Thus</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1808948aa8eaa300120a3b2e59e72e75d61ea383" translate="yes" xml:space="preserve">
          <source>The metaconfig system has its own git repository. Please see its README file in &lt;a href=&quot;http://perl5.git.perl.org/metaconfig.git/&quot;&gt;http://perl5.git.perl.org/metaconfig.git/&lt;/a&gt; for more details.</source>
          <target state="translated">metaconfig系统具有自己的git存储库。有关更多详细信息，请参见&lt;a href=&quot;http://perl5.git.perl.org/metaconfig.git/&quot;&gt;http://perl5.git.perl.org/metaconfig.git/中的&lt;/a&gt;自述文件。</target>
        </trans-unit>
        <trans-unit id="bc1a65f602d496a5d44a6f0eb65c069b2917da93" translate="yes" xml:space="preserve">
          <source>The metaconfig system has its own git repository. Please see its README file in &lt;a href=&quot;https://github.com/Perl/metaconfig&quot;&gt;https://github.com/Perl/metaconfig&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef4d1d7707c31f137e3be5c9c3439a6616b37606" translate="yes" xml:space="preserve">
          <source>The metadata structure is a data element of type Map. This section describes valid keys within the Map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57044926f6935330105dc7655b75810e4319d78e" translate="yes" xml:space="preserve">
          <source>The metanotation &lt;code&gt;a{b,c,d}e&lt;/code&gt; is a shorthand for &lt;code&gt;abe ace ade&lt;/code&gt; . Left to right order is preserved, with results of matches being sorted separately at a low level to preserve this order. As a special case &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt; are passed undisturbed.</source>
          <target state="translated">元符号 &lt;code&gt;a{b,c,d}e&lt;/code&gt; 是 &lt;code&gt;abe ace ade&lt;/code&gt; 的简写。保留了从左到右的顺序，匹配结果在较低的级别上被单独排序以保留此顺序。作为一种特殊情况， &lt;code&gt;{&lt;/code&gt; ， &lt;code&gt;}&lt;/code&gt; 和 &lt;code&gt;{}&lt;/code&gt; 不受干扰地传递。</target>
        </trans-unit>
        <trans-unit id="9487974ec391513333e9625acd21a3a26e0c7e56" translate="yes" xml:space="preserve">
          <source>The metanotation &lt;code&gt;a{b,c,d}e&lt;/code&gt; is a shorthand for &lt;code&gt;abe ace ade&lt;/code&gt;. Left to right order is preserved, with results of matches being sorted separately at a low level to preserve this order. As a special case &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt; are passed undisturbed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3047e3773833dff832f2198e8a9edf5e427dcdc4" translate="yes" xml:space="preserve">
          <source>The method &lt;b&gt;simplify_name&lt;/b&gt; is equivalent to &lt;b&gt;basename&lt;/b&gt;, but also strips Perl-like extensions (.pm, .pl, .pod) and extensions like</source>
          <target state="translated">该方法&lt;b&gt;simplify_name&lt;/b&gt;相当于&lt;b&gt;基名&lt;/b&gt;，而且剥离的Perl状延伸（.pm后缀，特等，.POD）和扩展等</target>
        </trans-unit>
        <trans-unit id="81b66f93d3069f9e60e8cef6e91ea8cf83a141d7" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;pretty&lt;/code&gt; is doing object-to-string conversion, so it is natural to overload the operator &lt;code&gt;&quot;&quot;&lt;/code&gt; using this method. However, inside such a method it is not necessary to pretty-print the</source>
          <target state="translated">&lt;code&gt;pretty&lt;/code&gt; 方法正在执行对象到字符串的转换，因此使用此方法来重载运算符 &lt;code&gt;&quot;&quot;&lt;/code&gt; 是很自然的。但是，在这种方法中，不必对打印的内容进行漂亮的打印。</target>
        </trans-unit>
        <trans-unit id="a6763bc5ce44c1cfaff83e339121fc03fa4b9167" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;survey&lt;/code&gt; searches for POD documents in a given set of files and/or directories. This runs the search according to the various options set by the accessors above. (For example, if the &lt;code&gt;inc&lt;/code&gt; attribute is on, as it is by default, then the perl @INC directories are implicitly added to the list of directories (if any) that you specify.)</source>
          <target state="translated">方法 &lt;code&gt;survey&lt;/code&gt; 在给定的文件和/或目录集中搜索POD文档。这将根据上面的访问者设置的各种选项运行搜索。（例如，如果默认启用 &lt;code&gt;inc&lt;/code&gt; 属性，则将perl @INC目录隐式添加到您指定的目录列表（如果有）。）</target>
        </trans-unit>
        <trans-unit id="c2594fdbf7af0dec9dd0b0469d5ba6b9ac83d4b7" translate="yes" xml:space="preserve">
          <source>The method forms return the object itself when called with arguments, so that they can be chained together nicely.</source>
          <target state="translated">方法形式在调用有参数的对象时,会返回对象本身,这样可以很好地连锁在一起。</target>
        </trans-unit>
        <trans-unit id="2dce83e2cc72bad00d236d5c3647c5845395811f" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; $scalar, classname&lt;/code&gt; . Associates a new scalar instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">由命令 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; $scalar, classname&lt;/code&gt; 调用的方法。将新的标量实例与指定的类关联。 &lt;code&gt;LIST&lt;/code&gt; 将代表完成关联所需的其他参数（沿着&lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;和同胞）。</target>
        </trans-unit>
        <trans-unit id="1329855cb3bc4e49bb5ad4447529605d17972380" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; %hash, classname&lt;/code&gt; . Associates a new hash instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">命令 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; %hash, classname&lt;/code&gt; 调用的方法。将新的哈希实例与指定的类关联。 &lt;code&gt;LIST&lt;/code&gt; 将代表完成关联所需的其他参数（沿着&lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;和同胞）。</target>
        </trans-unit>
        <trans-unit id="f4e115efd5b349da6e5daf0e7907f6b8a0251fea" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; *glob, classname&lt;/code&gt; . Associates a new glob instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">由命令 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; *glob, classname&lt;/code&gt; 调用的方法。将新的glob实例与指定的类相关联。 &lt;code&gt;LIST&lt;/code&gt; 将代表完成关联所需的其他参数（沿着&lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;和同胞）。</target>
        </trans-unit>
        <trans-unit id="3c64476d97600b750453bf420a9f4075f0306d1d" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;tie $scalar, classname&lt;/code&gt;. Associates a new scalar instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf56df28d8dc9b4d15467c9f598303b09011b2d" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;tie %hash, classname&lt;/code&gt;. Associates a new hash instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef7e6fea27b8c9527a2ee7d3c51ad487105105d" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;tie *glob, classname&lt;/code&gt;. Associates a new glob instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf5b5c7ccd1b01e888481ba1e2326ba23ba62558" translate="yes" xml:space="preserve">
          <source>The method may be called as a function (this is the legacy interface) and will then use a singleton as invocant.</source>
          <target state="translated">该方法可以作为一个函数调用(这是传统的接口),然后将使用一个单子作为调用者。</target>
        </trans-unit>
        <trans-unit id="a347cbeea5ef9dc7aa2915d6eb1498ed186d3546" translate="yes" xml:space="preserve">
          <source>The method must then return the object. While technically you can return any Perl scalar, you might have to enable the &lt;code&gt;allow_nonref&lt;/code&gt; setting to make that work in all cases, so better return an actual blessed reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219560b3e009187526f9cca6647b331f9670e08d" translate="yes" xml:space="preserve">
          <source>The method takes care not to use a HERE-doc end marker that appears in the typemap string itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8494bae7398a8984704473fee4ce9cba1c67c3" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; are not defined in &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. Tied hashes do not require presence of these methods, but if defined, the methods will be called in proper time, see &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;.</source>
          <target state="translated">未在&lt;b&gt;Tie :: Hash&lt;/b&gt;，&lt;b&gt;Tie :: StdHash&lt;/b&gt;或&lt;b&gt;Tie :: ExtraHash中&lt;/b&gt;定义 &lt;code&gt;UNTIE&lt;/code&gt; 和 &lt;code&gt;DESTROY&lt;/code&gt; 方法。绑定的哈希不需要这些方法的存在，但是如果定义了这些方法，则将在适当的时间调用这些方法，请参见&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ef8892a6c7e1ed9417668a258714fa58aaa9de51" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; are not defined in &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. Tied hashes do not require presence of these methods, but if defined, the methods will be called in proper time, see &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0efdfb2d42a690264f248f711dbbf09fd69f9a" translate="yes" xml:space="preserve">
          <source>The methods POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE, and EXISTS are required if the perl operator with the corresponding (but lowercase) name is to operate on the tied array. The &lt;b&gt;Tie::Array&lt;/b&gt; class can be used as a base class to implement the first five of these in terms of the basic methods above. The default implementations of DELETE and EXISTS in &lt;b&gt;Tie::Array&lt;/b&gt; simply &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">如果具有相应（但小写）名称的perl运算符要在绑定数组上进行操作，则需要POP，PUSH，SHIFT，UNSHIFT，SPLICE，DELETE和EXISTS方法。根据上面的基本方法，&lt;b&gt;Tie :: Array&lt;/b&gt;类可以用作基础类来实现其中的前五个。&lt;b&gt;Tie :: Array&lt;/b&gt;中DELETE和EXISTS的默认实现只是 &lt;code&gt;croak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4a5e54d75cc63679c6ace9898dabb0095727d66" translate="yes" xml:space="preserve">
          <source>The methods POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE, and EXISTS are required if the perl operator with the corresponding (but lowercase) name is to operate on the tied array. The &lt;b&gt;Tie::Array&lt;/b&gt; class can be used as a base class to implement the first five of these in terms of the basic methods above. The default implementations of DELETE and EXISTS in &lt;b&gt;Tie::Array&lt;/b&gt; simply &lt;code&gt;croak&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca020c3e2bd3840f09ecda9c60cedd92ab50da2" translate="yes" xml:space="preserve">
          <source>The methods associated with a file might include &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与文件关联的方法可能包括 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9038e299e83dde3b869fda0661c2f473ffe7af89" translate="yes" xml:space="preserve">
          <source>The methods associated with a file might include &lt;code&gt;rename()&lt;/code&gt; and &lt;code&gt;write()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5263ae238fdcff040734aa4eb38a1f937d29acc1" translate="yes" xml:space="preserve">
          <source>The methods make the assumption that there are 24 hours in a day, 7 days in a week, 365.24225 days in a year and 12 months in a year. (from The Calendar FAQ at &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;)</source>
          <target state="translated">这些方法假设一天中有24小时，一周中有7天，一年365.24225天以及一年12个月。（摘自&lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html上&lt;/a&gt;的Calendar FAQ ）</target>
        </trans-unit>
        <trans-unit id="f3937d8a57bcf6a9fc84c7bb1157e33f7b1b81bb" translate="yes" xml:space="preserve">
          <source>The methods make the assumption that there are 24 hours in a day, 7 days in a week, 365.24225 days in a year and 12 months in a year. (from The Calendar FAQ at http://www.tondering.dk/claus/calendar.html)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59cd0464641ff6280d0d7597be80f4d79435c372" translate="yes" xml:space="preserve">
          <source>The methods provided by this package are designed to be used in conjunction with &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;. When MakeMaker writes a Makefile, it creates one or more objects that inherit their methods from a package &lt;a href=&quot;ExtUtils::MM&quot;&gt;MM&lt;/a&gt;. MM itself doesn't provide any methods, but it ISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating specific packages take the responsibility for all the methods provided by MM_Unix. We are trying to reduce the number of the necessary overrides by defining rather primitive operations within ExtUtils::MM_Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b489e4d842d7bd01e6f982c6cbb73f631b2bc2" translate="yes" xml:space="preserve">
          <source>The methods provided by this package are designed to be used in conjunction with ExtUtils::MakeMaker. When MakeMaker writes a Makefile, it creates one or more objects that inherit their methods from a package &lt;code&gt;MM&lt;/code&gt; . MM itself doesn't provide any methods, but it ISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating specific packages take the responsibility for all the methods provided by MM_Unix. We are trying to reduce the number of the necessary overrides by defining rather primitive operations within ExtUtils::MM_Unix.</source>
          <target state="translated">该软件包提供的方法旨在与ExtUtils :: MakeMaker结合使用。当MakeMaker编写Makefile时，它将创建一个或多个对象，这些对象从 &lt;code&gt;MM&lt;/code&gt; 包继承其方法。MM本身不提供任何方法，但是它提供了ISA ExtUtils :: MM_Unix类。MM的继承树允许操作特定的软件包负责MM_Unix提供的所有方法。我们正在尝试通过在ExtUtils :: MM_Unix中定义相当原始的操作来减少必要覆盖的次数。</target>
        </trans-unit>
        <trans-unit id="8c66ae4f45a17e24ec4e91baabbe3addbe06fe69" translate="yes" xml:space="preserve">
          <source>The methods return a status value. All return 0 on success. All return -1 to signify an error and set &lt;code&gt;$!&lt;/code&gt; to the exact error code. The return code 1 generally (but not always) means that the key specified did not exist in the database.</source>
          <target state="translated">这些方法返回状态值。成功均返回0。全部返回-1表示错误并设置 &lt;code&gt;$!&lt;/code&gt; 到确切的错误代码。返回代码1通常（但不总是）表示指定的密钥在数据库中不存在。</target>
        </trans-unit>
        <trans-unit id="fbd4260de22fedf44d365a30940fb70d70e7661e" translate="yes" xml:space="preserve">
          <source>The methods return true if the argument is positive or negative, respectively. &lt;code&gt;NaN&lt;/code&gt; is neither positive nor negative, while &lt;code&gt;+inf&lt;/code&gt; counts as positive, and &lt;code&gt;-inf&lt;/code&gt; is negative. A &lt;code&gt;zero&lt;/code&gt; is neither positive nor negative.</source>
          <target state="translated">如果参数分别为正数或负数，则这些方法分别返回true。 &lt;code&gt;NaN&lt;/code&gt; 既不为正也不为负，而 &lt;code&gt;+inf&lt;/code&gt; &lt;code&gt;-inf&lt;/code&gt; 正，-inf为负。甲 &lt;code&gt;zero&lt;/code&gt; 既不积极也不消极的。</target>
        </trans-unit>
        <trans-unit id="6c2ef40bc1a0b74efb3bfbccd9cee9239eba6f64" translate="yes" xml:space="preserve">
          <source>The midpoint between London and Tokyo being</source>
          <target state="translated">伦敦和东京之间的中间点是</target>
        </trans-unit>
        <trans-unit id="bbcb1c9041fb73d5b33a27311e97c3d17c5b0e33" translate="yes" xml:space="preserve">
          <source>The minimal implementation of the package &lt;code&gt;MyMaths&lt;/code&gt; would be something like this:</source>
          <target state="translated">&lt;code&gt;MyMaths&lt;/code&gt; 软件包的最小实现是这样的：</target>
        </trans-unit>
        <trans-unit id="3d4726f2195d659bbd07fd552c77e45ca0215cb6" translate="yes" xml:space="preserve">
          <source>The minimal length of the match.</source>
          <target state="translated">比赛的最小长度。</target>
        </trans-unit>
        <trans-unit id="4d621dfdcd896d4c7f5ef5df72bf41823f001388" translate="yes" xml:space="preserve">
          <source>The minimal string that will allow both the start of the string &lt;code&gt;'^'&lt;/code&gt; and the alternation to match is &lt;code&gt;Th&lt;/code&gt;, with the alternation &lt;code&gt;e|r&lt;/code&gt; matching &lt;code&gt;'e'&lt;/code&gt;. The second quantifier &lt;code&gt;.*&lt;/code&gt; is free to gobble up the rest of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a86715e4677adbc552d12f74a0aff8aa19f9b9f" translate="yes" xml:space="preserve">
          <source>The minimal string that will allow both the start of the string &lt;code&gt;^&lt;/code&gt; and the alternation to match is &lt;code&gt;Th&lt;/code&gt; , with the alternation &lt;code&gt;e|r&lt;/code&gt; matching &lt;code&gt;e&lt;/code&gt; . The second quantifier &lt;code&gt;.*&lt;/code&gt; is free to gobble up the rest of the string.</source>
          <target state="translated">允许字符串 &lt;code&gt;^&lt;/code&gt; 的开头和交替都匹配的最小字符串是 &lt;code&gt;Th&lt;/code&gt; ，交替 &lt;code&gt;e|r&lt;/code&gt; 匹配 &lt;code&gt;e&lt;/code&gt; 。第二个量词 &lt;code&gt;.*&lt;/code&gt; 可以自由吞噬字符串的其余部分。</target>
        </trans-unit>
        <trans-unit id="42ee81d06f4fac118ea52fe7a6d4f7afb844e686" translate="yes" xml:space="preserve">
          <source>The minimum prerequisites for the distribution, to which dynamic configuration will only add items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e954716b49cb8b56dd5f1434ce35c364bc034cbd" translate="yes" xml:space="preserve">
          <source>The minimum required version of Perl for this distribution.</source>
          <target state="translated">本发行版对Perl的最低要求版本。</target>
        </trans-unit>
        <trans-unit id="8f285323eacf0d3787ce2842089aae064f612899" translate="yes" xml:space="preserve">
          <source>The minimum severity level set by &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode may be changed to be ERROR or higher in the future depending on the results of testing and further review.</source>
          <target state="translated">由最小严重性级别组 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 模式可被改变为根据测试和进一步审查的结果在未来ERROR或更高。</target>
        </trans-unit>
        <trans-unit id="a1189f16cd283f7a0c83693c3d814114bd713075" translate="yes" xml:space="preserve">
          <source>The minimum severity level set by &lt;code&gt;die&lt;/code&gt; in &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode may be changed to be ERROR or higher in the future depending on the results of testing and further review.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0eb7e9cbc117a074d8972fb43eb29ea9f494777" translate="yes" xml:space="preserve">
          <source>The minimum string length (in characters) required for the pattern to match. This is used to prune the search space by not bothering to match any closer to the end of a string than would allow a match. For instance there is no point in even starting the regex engine if the minlen is 10 but the string is only 5 characters long. There is no way that the pattern can match.</source>
          <target state="translated">匹配模式所需的最小字符串长度(以字符为单位)。这个参数用来修剪搜索空间,如果字符串的长度接近尾部,就不会再去匹配。例如,如果最小长度是10,但字符串只有5个字符,那么启动regex引擎就没有意义。模式是不可能匹配的。</target>
        </trans-unit>
        <trans-unit id="210162554d25993f24361ef0d0eb6d7705ae9f1e" translate="yes" xml:space="preserve">
          <source>The mkpath() function provide the legacy interface of make_path() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to make_path().</source>
          <target state="translated">mkpath()函数提供了make_path()的传统接口,但对传递的参数有不同的解释。该函数的行为和返回值与make_path()相同。</target>
        </trans-unit>
        <trans-unit id="06ad56158c8fa5ced75a1aebddb172710774c3d6" translate="yes" xml:space="preserve">
          <source>The mode argument should be a string as would be passed to fopen/PerlIO_open. If it is NULL then - for legacy support - the code will (depending upon the platform and the implementation) either attempt to empirically determine the mode in which</source>
          <target state="translated">mode参数应该是一个字符串,就像传递给fopen/PerlIO_open一样。如果它是NULL,那么--对于传统的支持--代码将(取决于平台和实现)尝试根据经验确定模式,其中</target>
        </trans-unit>
        <trans-unit id="a3c9e181407a3d8dbcbede503e296bb6515c64a6" translate="yes" xml:space="preserve">
          <source>The modern convention for OO modules is to always use &lt;code&gt;new&lt;/code&gt; as the name for the constructor, but there is no requirement to do so. Any subroutine that blesses a data structure into a class is a valid constructor in Perl.</source>
          <target state="translated">OO模块的现代约定是始终使用 &lt;code&gt;new&lt;/code&gt; 作为构造函数的名称，但是没有必要这样做。将数据结构加到类中的任何子例程在Perl中都是有效的构造函数。</target>
        </trans-unit>
        <trans-unit id="3447af7744c6d54de16c62d9254e4d7db34879e8" translate="yes" xml:space="preserve">
          <source>The modern successor of &lt;code&gt;CJK.inf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a53357f11465725d38d814ff941d393401ed024" translate="yes" xml:space="preserve">
          <source>The module</source>
          <target state="translated">该模块</target>
        </trans-unit>
        <trans-unit id="73f13a2108211624409b0cfacd9ef18c01b16a7a" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;Perl::Unsafe::Signals&quot;&gt;Perl::Unsafe::Signals&lt;/a&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e5705c3d4c65fd8c41a20a40b57ad45ad89ac2" translate="yes" xml:space="preserve">
          <source>The module actually implements most of an interface described by Larry Wall on the perl5-porters mailing list here: &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&lt;/a&gt;</source>
          <target state="translated">该模块实际上实现了Larry Wall在perl5-porters邮件列表上描述的大多数接口：&lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&quot;&gt;http&lt;/a&gt; ://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html</target>
        </trans-unit>
        <trans-unit id="cbe2b6eee3b2ebdf5395a20e5b4843961160d7fa" translate="yes" xml:space="preserve">
          <source>The module actually implements most of an interface described by Larry Wall on the perl5-porters mailing list here: &lt;a href=&quot;https://www.nntp.perl.org/group/perl.perl5.porters/2000/01/msg5283.html&quot;&gt;https://www.nntp.perl.org/group/perl.perl5.porters/2000/01/msg5283.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eac150fbe415255f3cdb34d1744497bc9492853" translate="yes" xml:space="preserve">
          <source>The module also lets you save intermediate SHA states to a string. The</source>
          <target state="translated">该模块还可以让你把中间的SHA状态保存到一个字符串中。该</target>
        </trans-unit>
        <trans-unit id="ee711fa1cc9e23459ad1dea67a4bc2640b9361b2" translate="yes" xml:space="preserve">
          <source>The module and its user have a contract, part of which is common law, and part of which is &quot;written&quot;. Part of the common law contract is that a module doesn't pollute any namespace it wasn't asked to. The written contract for the module (A.K.A. documentation) may make other provisions. But then you know when you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; RedefineTheWorld&lt;/code&gt; that you're redefining the world and willing to take the consequences.</source>
          <target state="translated">该模块及其用户具有合同，其中一部分是普通法，一部分是&amp;ldquo;书面&amp;rdquo;的。普通法合同的一部分是，模块不会污染任何未被要求的名称空间。模块的书面合同（AKA文档）可能另有规定。但是随后您知道，当您 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; RedefineTheWorld&lt;/code&gt; ，您正在重新定义世界并愿意承担后果。</target>
        </trans-unit>
        <trans-unit id="9372253e447b67364ad520e524aa1e247f7dc577" translate="yes" xml:space="preserve">
          <source>The module and its user have a contract, part of which is common law, and part of which is &quot;written&quot;. Part of the common law contract is that a module doesn't pollute any namespace it wasn't asked to. The written contract for the module (A.K.A. documentation) may make other provisions. But then you know when you &lt;code&gt;use RedefineTheWorld&lt;/code&gt; that you're redefining the world and willing to take the consequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f631dbc58be0710de0b64e0128de801aadc778" translate="yes" xml:space="preserve">
          <source>The module appropriate for the current OS is automatically loaded by File::Spec. Since some modules (like VMS) make use of facilities available only under that OS, it may not be possible to load all modules under all operating systems.</source>
          <target state="translated">File::Spec 会自动加载适合当前操作系统的模块。由于有些模块(如VMS)只使用该操作系统下的设施,可能无法加载所有操作系统下的所有模块。</target>
        </trans-unit>
        <trans-unit id="f14f53ac2830f28434b0714747d843bf7a9d032c" translate="yes" xml:space="preserve">
          <source>The module author loves to hear how &lt;code&gt;autodie&lt;/code&gt; has made your life better (or worse). Feedback can be sent to &amp;lt;pjf@perltraining.com.au&amp;gt;.</source>
          <target state="translated">模块作者喜欢听听 &lt;code&gt;autodie&lt;/code&gt; 如何使您的生活变得更好（或更糟）。反馈可以发送到&amp;lt;pjf@perltraining.com.au&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="64e716d94d3201717e95856fa71dba02b691c1e4" translate="yes" xml:space="preserve">
          <source>The module functionality relies on symbolic references, so things will break under 'use strict' unless 'no strict &quot;refs&quot;' is also specified.</source>
          <target state="translated">该模块的功能依赖于符号引用,所以在 &quot;使用严格 &quot;的情况下,除非同时指定 &quot;没有严格的 &quot;refs&quot;&quot;,否则会出现问题。</target>
        </trans-unit>
        <trans-unit id="0003d7a83a288e163c978c48b4832ab6428ef2d5" translate="yes" xml:space="preserve">
          <source>The module is not entirely round-trip safe: For example it currently simply strips all comments. The order of entries in the maps is, however, preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34dfe6e94b964deab3088dd9f024d26797644959" translate="yes" xml:space="preserve">
          <source>The module is used to replace common UNIX commands. In all cases the functions work from @ARGV rather than taking arguments. This makes them easier to deal with in Makefiles. Call them like this:</source>
          <target state="translated">该模块用于替换常见的UNIX命令。在所有的情况下,函数都是通过@ARGV工作,而不是接受参数。这使得它们在Makefile中更容易处理。像这样调用它们。</target>
        </trans-unit>
        <trans-unit id="7b2c2d003f5a465317ebb185dd8468c1c69f2ab8" translate="yes" xml:space="preserve">
          <source>The module itself never broke, you do not need to upgrade.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a785d24a660af5bf727090a58cdad6783dbc670b" translate="yes" xml:space="preserve">
          <source>The module itself works fine, there is no need to upgrade.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c671baea2f821aba32cfc72c5c947bba8fda15dc" translate="yes" xml:space="preserve">
          <source>The module might issue the following warnings:</source>
          <target state="translated">该模块可能会发出以下警告:</target>
        </trans-unit>
        <trans-unit id="06580747828c7d751b4066d4d4c51e0e99e3ed97" translate="yes" xml:space="preserve">
          <source>The module that implements the canned filter can take one of two forms. Here is a template for the first</source>
          <target state="translated">实现罐装过滤器的模块可以采取两种形式之一。这里是第一种形式的模板</target>
        </trans-unit>
        <trans-unit id="aa3f15cb2c51087f06437c33aa4d5adadaa3850c" translate="yes" xml:space="preserve">
          <source>The module will auto-detect which, if any, of the supported compression formats is being used.</source>
          <target state="translated">该模块将自动检测正在使用的压缩格式(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="f166adc5fd8c563e508f523c65a82ae50be2d86f" translate="yes" xml:space="preserve">
          <source>The month (&lt;code&gt;mon&lt;/code&gt; ), weekday (&lt;code&gt;wday&lt;/code&gt; ), and yearday (&lt;code&gt;yday&lt;/code&gt; ) begin at zero,</source>
          <target state="translated">月份（ &lt;code&gt;mon&lt;/code&gt; ），周日（ &lt;code&gt;wday&lt;/code&gt; ）和yearday（ &lt;code&gt;yday&lt;/code&gt; ）开始于零，</target>
        </trans-unit>
        <trans-unit id="716f3ac895408852fbfe14ab4075855f3cc5828e" translate="yes" xml:space="preserve">
          <source>The month (&lt;code&gt;mon&lt;/code&gt;), weekday (&lt;code&gt;wday&lt;/code&gt;), and yearday (&lt;code&gt;yday&lt;/code&gt;) begin at zero,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7976bab032857556f1afeeb5486bc37536242264" translate="yes" xml:space="preserve">
          <source>The months and years can be negative for subtractions. Note that there is some &quot;strange&quot; behaviour when adding and subtracting months at the ends of months. Generally when the resulting month is shorter than the starting month then the number of overlap days is added. For example subtracting a month from 2008-03-31 will not result in 2008-02-31 as this is an impossible date. Instead you will get 2008-03-02. This appears to be consistent with other date manipulation tools.</source>
          <target state="translated">月和年可以是负数做减法。需要注意的是,在月末加减月份的时候,会有一些 &quot;奇怪 &quot;的行为。一般来说,当得出的月份比起始月份短时,就会加上重叠的天数。例如,从2008-03-31中减去一个月,结果不会是2008-02-31,因为这是个不可能的日期。相反,你会得到2008-03-02。这似乎与其他日期操作工具一致。</target>
        </trans-unit>
        <trans-unit id="467ee849edeaf9f54792730271f84d84084b5500" translate="yes" xml:space="preserve">
          <source>The more modern form of version assignment, with 3 (or potentially more) integers separated by decimal points (e.g. v1.2.3). This is the form that Perl itself has used since 5.6.0 was released. The leading 'v' is now strongly recommended for clarity, and will throw a warning in a future release if omitted. A leading 'v' character is required to pass the &lt;a href=&quot;#is_strict%28%29&quot;&gt;&quot;is_strict()&quot;&lt;/a&gt; test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9450d19149fb47c1c53f97698b4be633a15d56" translate="yes" xml:space="preserve">
          <source>The more you think about interfacing between two languages, the more you'll realize that the majority of programmer effort has to go into converting between the data structures that are native to either of the languages involved. This trumps other matter such as differing calling conventions because the problem space is so much greater. There are simply more ways to shove data into memory than there are ways to implement a function call.</source>
          <target state="translated">你对两种语言之间的接口考虑得越多,你就越会意识到,大部分程序员的努力都是为了在其中一种语言的本地数据结构之间进行转换。这胜过其他事项,比如不同的调用约定,因为问题空间要大得多。把数据塞进内存的方法比实现函数调用的方法多得多。</target>
        </trans-unit>
        <trans-unit id="8176a4ffeb356c4a7a23ddcef37f49bf2bb9d8e2" translate="yes" xml:space="preserve">
          <source>The mortal routines are not just for SVs; AVs and HVs can be made mortal by passing their address (type-casted to &lt;code&gt;SV*&lt;/code&gt; ) to the &lt;code&gt;sv_2mortal&lt;/code&gt; or &lt;code&gt;sv_mortalcopy&lt;/code&gt; routines.</source>
          <target state="translated">凡人的例程不仅适用于SV。通过将其地址（类型 &lt;code&gt;sv_2mortal&lt;/code&gt; 为 &lt;code&gt;SV*&lt;/code&gt; ）传递给sv_2mortal或 &lt;code&gt;sv_mortalcopy&lt;/code&gt; 例程，可以使AV和HV成为凡人。</target>
        </trans-unit>
        <trans-unit id="caf6b1916b41e472c1ad4cc38efc1ebb428fd15c" translate="yes" xml:space="preserve">
          <source>The mortal routines are not just for SVs; AVs and HVs can be made mortal by passing their address (type-casted to &lt;code&gt;SV*&lt;/code&gt;) to the &lt;code&gt;sv_2mortal&lt;/code&gt; or &lt;code&gt;sv_mortalcopy&lt;/code&gt; routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a1cfa37e915685db47ff38f6021965013b98c8b" translate="yes" xml:space="preserve">
          <source>The most common CPAN version numbering scheme looks like this:</source>
          <target state="translated">最常见的CPAN版本编号方案是这样的。</target>
        </trans-unit>
        <trans-unit id="d13f6c55db0d43d578a52888c54a47f93bad3e7e" translate="yes" xml:space="preserve">
          <source>The most common context-specific hints are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4361ab99106fa73a1bb41dd2c636e6a27fcbec" translate="yes" xml:space="preserve">
          <source>The most common example of this is changing the current working directory using &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;. One thread calls &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, and the working directory of all the threads changes.</source>
          <target state="translated">最常见的示例是使用 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 更改当前工作目录。一个线程调用 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; ，所有线程的工作目录都会更改。</target>
        </trans-unit>
        <trans-unit id="c1920ebe5b8490b9051b66a85a68049c7044d116" translate="yes" xml:space="preserve">
          <source>The most common example of this is changing the current working directory using &lt;code&gt;chdir()&lt;/code&gt;. One thread calls &lt;code&gt;chdir()&lt;/code&gt;, and the working directory of all the threads changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d1fc7a0fdb4e15b4bc8d9defba4491def9b679" translate="yes" xml:space="preserve">
          <source>The most common git command you will use will probably be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7e55ecc01719c5e313506a020593317cb7d856" translate="yes" xml:space="preserve">
          <source>The most common such DOS devices include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f63cc6de2a2448196e1a86a35300d77fbd9cdf9" translate="yes" xml:space="preserve">
          <source>The most common uses of the interactive modes are</source>
          <target state="translated">互动模式最常见的用途是</target>
        </trans-unit>
        <trans-unit id="3f3dfdc5e3f12eaa9aae95ba108f269ad1f91764" translate="yes" xml:space="preserve">
          <source>The most common way to create an object is to pass in key/value pairs where each key is an attribute and each value is what you want assigned to that attribute. No checking is done to verify the attributes or values are valid, you may do that in &lt;code&gt;init()&lt;/code&gt; if desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3870e4765effd8ab5e5da52360ab236ece22162c" translate="yes" xml:space="preserve">
          <source>The most commonly used of these functions is &lt;code&gt;Perl_sv_dump&lt;/code&gt; ; it's used for dumping SVs, AVs, HVs, and CVs. The &lt;code&gt;Devel::Peek&lt;/code&gt; module calls &lt;code&gt;sv_dump&lt;/code&gt; to produce debugging output from Perl-space, so users of that module should already be familiar with its format.</source>
          <target state="translated">这些函数中最常用的是 &lt;code&gt;Perl_sv_dump&lt;/code&gt; ；它用于转储SV，AV，HV和CV。该 &lt;code&gt;Devel::Peek&lt;/code&gt; 模块调用 &lt;code&gt;sv_dump&lt;/code&gt; 以从Perl的空间调试输出，使模块的用户应该已经熟悉了它的格式。</target>
        </trans-unit>
        <trans-unit id="40e2d355a29a78e1dd4f49324b9dbebe996e6a33" translate="yes" xml:space="preserve">
          <source>The most commonly used of these functions is &lt;code&gt;Perl_sv_dump&lt;/code&gt;; it's used for dumping SVs, AVs, HVs, and CVs. The &lt;code&gt;Devel::Peek&lt;/code&gt; module calls &lt;code&gt;sv_dump&lt;/code&gt; to produce debugging output from Perl-space, so users of that module should already be familiar with its format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3104b20dd3af96ae7f833de8c6d7e1e79108b35" translate="yes" xml:space="preserve">
          <source>The most convenient way of installing a binary distribution of perl is via perl installer</source>
          <target state="translated">最方便的安装perl二进制发行版的方法是通过perl安装程序。</target>
        </trans-unit>
        <trans-unit id="8449f9a2d2191f3c7392f9226647d2910704473a" translate="yes" xml:space="preserve">
          <source>The most efficient way is using &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; and &lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;. This is faster than using &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; when taking many, many strings. It is slower for just a few.</source>
          <target state="translated">最有效的方法是使用&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;和&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;。这比使用许多字符串时使用&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;更快。它慢了几个。</target>
        </trans-unit>
        <trans-unit id="e62c7de4b0c0c77c458201d125462fa3d57ea6f5" translate="yes" xml:space="preserve">
          <source>The most efficient way is using &lt;a href=&quot;perlfunc#pack&quot;&gt;pack()&lt;/a&gt; and &lt;a href=&quot;perlfunc#unpack&quot;&gt;unpack()&lt;/a&gt;. This is faster than using &lt;a href=&quot;perlfunc#substr&quot;&gt;substr()&lt;/a&gt; when taking many, many strings. It is slower for just a few.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee8f017f47cf02290cdcd6ac5e270d04e302d38" translate="yes" xml:space="preserve">
          <source>The most general way to do this is to cast them to a UV or IV, and print as in the &lt;a href=&quot;#Formatted-Printing-of-IVs%2C-UVs%2C-and-NVs&quot;&gt;previous section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c40808afd7fc4cc79463965386f4682ff94dfa" translate="yes" xml:space="preserve">
          <source>The most hairy case</source>
          <target state="translated">最毛躁的情况</target>
        </trans-unit>
        <trans-unit id="51dfbd93c1252c67b5797f63c0a32f35baffd72d" translate="yes" xml:space="preserve">
          <source>The most important Perl parsing rule is the first one discussed below: when processing a quoted construct, Perl first finds the end of that construct, then interprets its contents. If you understand this rule, you may skip the rest of this section on the first reading. The other rules are likely to contradict the user's expectations much less frequently than this first one.</source>
          <target state="translated">最重要的Perl解析规则是下面讨论的第一条:在处理一个引用的构造体时,Perl首先要找到该构造体的结尾,然后对其内容进行解释。如果你理解了这一规则,你可以在第一遍阅读时跳过本节的其他内容。其他规则与用户期望的矛盾可能比这第一条规则少得多。</target>
        </trans-unit>
        <trans-unit id="aef7d8dbf9d828ab96b855e0061e1f04b9541021" translate="yes" xml:space="preserve">
          <source>The most important attribute of a socket, like your telephone&amp;rsquo;s telephone number. Typically an IP address. See also &lt;b&gt;port&lt;/b&gt;.</source>
          <target state="translated">套接字的最重要属性，例如电话的电话号码。通常是IP地址。另请参阅&lt;b&gt;port&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="10d61cb4054b3dd458a76a9b2241b8875252cd6d" translate="yes" xml:space="preserve">
          <source>The most important of which are probably &lt;code&gt;GV_ADD&lt;/code&gt; and &lt;code&gt;SVf_UTF8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a25c59d901462fca0083edfc964d9c8bf518a04" translate="yes" xml:space="preserve">
          <source>The most important of which are probably GV_ADD and SVf_UTF8.</source>
          <target state="translated">其中最重要的可能是GV_ADD和SVf_UTF8。</target>
        </trans-unit>
        <trans-unit id="0626c5878256026e37d6cadc7a0a5c68ea6109bd" translate="yes" xml:space="preserve">
          <source>The most important of which is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aae52fef16fc25bcc3b6593dc3391e48196f1ad" translate="yes" xml:space="preserve">
          <source>The most important thing is to run your programs under the &lt;b&gt;-w&lt;/b&gt; flag at all times. You may turn it off explicitly for particular portions of code via the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;code&gt;$^W&lt;/code&gt; variable if you must. You should also always run under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; or know the reason why not. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; sigtrap&lt;/code&gt; and even &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; diagnostics&lt;/code&gt; pragmas may also prove useful.</source>
          <target state="translated">最重要的是始终在&lt;b&gt;-w&lt;/b&gt;标志下运行程序。您可以通过 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; 杂注或 &lt;code&gt;$^W&lt;/code&gt; 变量来显式关闭代码的特定部分（如果需要）。您还应该始终在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;下运行，或者知道为什么不这样做。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; sigtrap&lt;/code&gt; 甚至 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; diagnostics&lt;/code&gt; 的pragma也可以证明是有用的。</target>
        </trans-unit>
        <trans-unit id="8c3b2954acd0c4fdd7e8575f6e05f126659f29cc" translate="yes" xml:space="preserve">
          <source>The most important thing is to use &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; in all your code or know the reason why not to. You may turn them off explicitly for particular portions of code via &lt;code&gt;no warnings&lt;/code&gt; or &lt;code&gt;no strict&lt;/code&gt;, and this can be limited to the specific warnings or strict features you wish to disable. The &lt;b&gt;-w&lt;/b&gt; flag and &lt;code&gt;$^W&lt;/code&gt; variable should not be used for this purpose since they can affect code you use but did not write, such as modules from core or CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6be7df730b69bf2abfbfef25c9c73eef66cdf79" translate="yes" xml:space="preserve">
          <source>The most important thing to understand about all data structures in Perl--including multidimensional arrays--is that even though they might appear otherwise, Perl &lt;code&gt;@ARRAY&lt;/code&gt; s and &lt;code&gt;%HASH&lt;/code&gt; es are all internally one-dimensional. They can hold only scalar values (meaning a string, number, or a reference). They cannot directly contain other arrays or hashes, but instead contain</source>
          <target state="translated">要了解Perl中的所有数据结构（包括多维数组），最重要的事情是，即使它们可能以其他方式出现，Perl &lt;code&gt;@ARRAY&lt;/code&gt; 和 &lt;code&gt;%HASH&lt;/code&gt; 也是内部一维的。它们只能保存标量值（表示字符串，数字或引用）。它们不能直接包含其他数组或哈希，而是包含</target>
        </trans-unit>
        <trans-unit id="787b225130f60b5479ecb7c71a8dc7b419116101" translate="yes" xml:space="preserve">
          <source>The most important thing to understand about all data structures in Perl--including multidimensional arrays--is that even though they might appear otherwise, Perl &lt;code&gt;@ARRAY&lt;/code&gt;s and &lt;code&gt;%HASH&lt;/code&gt;es are all internally one-dimensional. They can hold only scalar values (meaning a string, number, or a reference). They cannot directly contain other arrays or hashes, but instead contain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5f029eca08711d302dd8f17b7e7f9e635b1ec8" translate="yes" xml:space="preserve">
          <source>The most popular books</source>
          <target state="translated">最受欢迎的书籍</target>
        </trans-unit>
        <trans-unit id="c77ae4b23596713f5e5db719e4b12df8a45dd104" translate="yes" xml:space="preserve">
          <source>The most practical use is likely to specify that some tests are not &quot;parallel-ready&quot;. Since mentioning a file with --rules doesn't cause it to be selected to run as a test, you can &quot;set and forget&quot; some rules preferences in your .proverc file. Then you'll be able to take maximum advantage of the performance benefits of parallel testing, while some exceptions are still run in parallel.</source>
          <target state="translated">最实际的用途可能是指定一些测试不是 &quot;并行就绪 &quot;的。由于用--rules提到一个文件并不会导致它被选为测试运行,所以你可以在你的.proverc文件中 &quot;设置并忘记 &quot;一些规则偏好。然后你就可以最大限度地利用并行测试的性能优势,而一些异常情况仍然会以并行方式运行。</target>
        </trans-unit>
        <trans-unit id="6f276b3b1a0cf0e0ed49a901109064669a604004" translate="yes" xml:space="preserve">
          <source>The most preferable one is &quot;The Default Unicode Collation Element Table&quot; (aka DUCET), available from the Unicode Consortium's website:</source>
          <target state="translated">最可取的是 &quot;默认Unicode整理元素表&quot;(又名DUCET),可从Unicode联盟的网站上获得。</target>
        </trans-unit>
        <trans-unit id="1a2b184063d0bc0a35feb7fb346e45c3d6648eb5" translate="yes" xml:space="preserve">
          <source>The most recent development releases of Perl have been experimenting with removing Perl's dependency on the &quot;normal&quot; standard I/O suite and allowing other stdio implementations to be used. This involves creating a new abstraction layer that then calls whichever implementation of stdio Perl was compiled with. All XSUBs should now use the functions in the PerlIO abstraction layer and not make any assumptions about what kind of stdio is being used.</source>
          <target state="translated">最近的Perl开发版本一直在尝试取消Perl对 &quot;普通 &quot;标准I/O套件的依赖,允许使用其他stdio实现。这涉及到创建一个新的抽象层,然后调用Perl编译时使用的任何stdio实现。现在,所有的XSUB都应该使用PerlIO抽象层中的函数,而不是对使用的stdio做任何假设。</target>
        </trans-unit>
        <trans-unit id="d790d27d68eef3be56d3d5afa1a5d1f30d794f18" translate="yes" xml:space="preserve">
          <source>The most recent upgrade to the PA-RISC design, it added support for 64-bit integer data.</source>
          <target state="translated">PA-RISC设计的最新升级,它增加了对64位整数数据的支持。</target>
        </trans-unit>
        <trans-unit id="0603f466834b0d6d823bdd46c3606b7ca755f71a" translate="yes" xml:space="preserve">
          <source>The most recent version of this module, including documentation and any news of importance, will be available at</source>
          <target state="translated">本模块的最新版本,包括文件和任何重要新闻,将在以下网站提供</target>
        </trans-unit>
        <trans-unit id="f4a085ad231e217eed37777279430f48e1cf87a2" translate="yes" xml:space="preserve">
          <source>The most significant information in the output is about the particular</source>
          <target state="translated">输出中最重要的信息是关于特定的</target>
        </trans-unit>
        <trans-unit id="9de43c038dc457f71dc272efc26e8a4eb0e6b17e" translate="yes" xml:space="preserve">
          <source>The most simple options are the ones that take no values. Their mere presence on the command line enables the option. Popular examples are:</source>
          <target state="translated">最简单的选项是那些不取值的选项。仅仅是在命令行中出现的选项就可以启用。常见的例子有:</target>
        </trans-unit>
        <trans-unit id="fe61ded48d4439fb9787ec0d115995f08935a048" translate="yes" xml:space="preserve">
          <source>The most useful option the cross referencer has is to save the report to a separate file. For instance, to save the report on</source>
          <target state="translated">交叉引用器最有用的选项是将报告保存到一个单独的文件中。例如,要将报告保存在</target>
        </trans-unit>
        <trans-unit id="762e20af8acff77775848b01e093c2cac3013ec4" translate="yes" xml:space="preserve">
          <source>The most useful types that will be returned are:</source>
          <target state="translated">将返回的最有用的类型是:</target>
        </trans-unit>
        <trans-unit id="a4f13e9fd0d66b114f604fe2129d7ad6d576d1c5" translate="yes" xml:space="preserve">
          <source>The movement of bits left or right in a computer word, which has the effect of multiplying or dividing by a power of 2.</source>
          <target state="translated">计算机字中位数的左右移动,其效果是乘以或除以2的幂。</target>
        </trans-unit>
        <trans-unit id="811ee2e71fefd4dbb8ec994c3d2df771d4653871" translate="yes" xml:space="preserve">
          <source>The multiple-bracket form does not affect the interpretation of the contents of the formatting code, only how it must end. That means that the examples above are also exactly the same as this:</source>
          <target state="translated">多括号的形式并不影响对格式码内容的解释,只影响其必须如何结束。也就是说,上面的例子也和这个完全一样。</target>
        </trans-unit>
        <trans-unit id="b62777fe39744a74b7fc65bfce887b1ed7aeecd0" translate="yes" xml:space="preserve">
          <source>The mutators for flags all return the JSON::PP object again and thus calls can be chained:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2632e91c7e1b901a77d044556dbd4ff9d5c87be" translate="yes" xml:space="preserve">
          <source>The name</source>
          <target state="translated">名称</target>
        </trans-unit>
        <trans-unit id="db6539b7ba93a9d46c820cb8d93cf44ff14b7c45" translate="yes" xml:space="preserve">
          <source>The name &quot;WinXP/.Net&quot; is used for historical reasons only, to maintain backwards compatibility of the Win32 module. Windows .NET Server has been renamed as Windows 2003 Server before final release and uses a different major/minor version number than Windows XP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32c3c3ac333fcf1879195759e18947b403def2d" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;new&lt;/code&gt; isn't special. We could name our constructor something else:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 名称并不特殊。我们可以将构造函数命名为其他名称：</target>
        </trans-unit>
        <trans-unit id="381ffb5c7c9337af9dd775ed33da7e16dd88d27a" translate="yes" xml:space="preserve">
          <source>The name in the IANA registry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="316e7deb3997f109974511d20499a1d93aa6493c" translate="yes" xml:space="preserve">
          <source>The name is returned as a mortal SV.</source>
          <target state="translated">名为凡人SV返回。</target>
        </trans-unit>
        <trans-unit id="e84fcc4ee47e1e1b5639888428e055c00959431a" translate="yes" xml:space="preserve">
          <source>The name may contain embedded E&amp;lt;&amp;gt; and Z&amp;lt;&amp;gt; formatting codes, and the section, anchor text, and inferred anchor text may contain any formatting codes. Any double quotes around the section are removed as part of the parsing, as is any leading or trailing whitespace.</source>
          <target state="translated">该名称可以包含嵌入的E &amp;lt;&amp;gt;和Z &amp;lt;&amp;gt;格式代码，并且节，锚文本和推断的锚文本可以包含任何格式代码。该部分周围的所有双引号都会被作为分析的一部分删除，所有前导或尾随空格也将被删除。</target>
        </trans-unit>
        <trans-unit id="8ada838033f411154fe022f162bc95bf1ac56e8a" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;(*SKIP:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; pattern has special significance. If a &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; was encountered while matching, then it is that position which is used as the &quot;skip point&quot;. If no &lt;code&gt;(*MARK)&lt;/code&gt; of that name was encountered, then the &lt;code&gt;(*SKIP)&lt;/code&gt; operator has no effect. When used without a name the &quot;skip point&quot; is where the match point was when executing the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f683b00c5db230ebae95056480292ae0fa37d30" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;(*SKIP:NAME)&lt;/code&gt; pattern has special significance. If a &lt;code&gt;(*MARK:NAME)&lt;/code&gt; was encountered while matching, then it is that position which is used as the &quot;skip point&quot;. If no &lt;code&gt;(*MARK)&lt;/code&gt; of that name was encountered, then the &lt;code&gt;(*SKIP)&lt;/code&gt; operator has no effect. When used without a name the &quot;skip point&quot; is where the match point was when executing the (*SKIP) pattern.</source>
          <target state="translated">该名称 &lt;code&gt;(*SKIP:NAME)&lt;/code&gt; 模式具有特殊的意义。如果在匹配时遇到 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; ，则该位置将用作&amp;ldquo;跳过点&amp;rdquo;。如果未遇到该名称的 &lt;code&gt;(*MARK)&lt;/code&gt; ，则 &lt;code&gt;(*SKIP)&lt;/code&gt; 运算符无效。不带名称使用时，&amp;ldquo;跳过点&amp;rdquo;是执行（* SKIP）模式时匹配点的位置。</target>
        </trans-unit>
        <trans-unit id="4ffbfa835ecb6cb544ad106cd35f35360cfc377b" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;result_class&lt;/code&gt; . Defaults to &lt;code&gt;App::Prove::State::Result&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;result_class&lt;/code&gt; 的名称。默认为 &lt;code&gt;App::Prove::State::Result&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b922baa1630e5f6c97eeff342a7feb7ab689a79" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;result_class&lt;/code&gt;. Defaults to &lt;code&gt;App::Prove::State::Result&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="689345a6c608b08f0da8c40d1de1f0d6ad537fb4" translate="yes" xml:space="preserve">
          <source>The name of the C subroutine generated which will return the constants. The default is</source>
          <target state="translated">生成的C子程序的名称,它将返回常量。默认值是</target>
        </trans-unit>
        <trans-unit id="24928164de71defca77ef40b5800aabbee56b274" translate="yes" xml:space="preserve">
          <source>The name of the Makefile to be produced. This is used for the second Makefile that will be produced for the MAP_TARGET.</source>
          <target state="translated">要生成的 Makefile 的名称。用于为MAP_TARGET制作的第二个Makefile。</target>
        </trans-unit>
        <trans-unit id="586bd0a2b6cddbba1d51a20c05e33d4e435a88ba" translate="yes" xml:space="preserve">
          <source>The name of the OP, or 'ex-foo' if the OP is a null that used to be a foo.</source>
          <target state="translated">上位机的名称,如果上位机是一个曾经是foo的null,则为 &quot;ex-foo&quot;。</target>
        </trans-unit>
        <trans-unit id="5c8f940ac3ab77f3cca6bf5d7c2332906bee0772" translate="yes" xml:space="preserve">
          <source>The name of the array containing the &lt;b&gt;argument&lt;/b&gt;&lt;b&gt;vector&lt;/b&gt; from the command line. If you use the empty &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator, &lt;code&gt;ARGV&lt;/code&gt; is the name of both the &lt;b&gt;filehandle&lt;/b&gt; used to traverse the arguments and the &lt;b&gt;scalar&lt;/b&gt; containing the name of the current input file.</source>
          <target state="translated">包含命令行中的&lt;b&gt;参数&lt;/b&gt;&lt;b&gt;向量&lt;/b&gt;的数组的名称。如果使用空的 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符，则 &lt;code&gt;ARGV&lt;/code&gt; 既是用于遍历参数的&lt;b&gt;文件句柄&lt;/b&gt;的名称，又是包含当前输入文件的名称的&lt;b&gt;标量&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="c0ef9637fb40c44d741c359416d9acc461c4754b" translate="yes" xml:space="preserve">
          <source>The name of the capability to be output.</source>
          <target state="translated">要输出的能力名称。</target>
        </trans-unit>
        <trans-unit id="25678c01479ff57e49b16538b63d4932cacd981b" translate="yes" xml:space="preserve">
          <source>The name of the class to use to aggregate test results. The default is &lt;a href=&quot;TAP::Parser::Aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cd22adf72a74a4b456151c3e1d9f81b33d09a6" translate="yes" xml:space="preserve">
          <source>The name of the class to use to aggregate test results. The default is &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;.</source>
          <target state="translated">用于汇总测试结果的类的名称。默认值为&lt;a href=&quot;parser/aggregator&quot;&gt;TAP :: Parser :: Aggregator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f598b6f749ef712a68f14ac426c778ed4bbb049" translate="yes" xml:space="preserve">
          <source>The name of the class to use to format output. The default is &lt;a href=&quot;TAP::Formatter::Console&quot;&gt;TAP::Formatter::Console&lt;/a&gt;, or &lt;a href=&quot;TAP::Formatter::File&quot;&gt;TAP::Formatter::File&lt;/a&gt; if the output isn't a TTY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaad217bdc2e240c2b5911f874d90cf603ae7ab9" translate="yes" xml:space="preserve">
          <source>The name of the class to use to format output. The default is &lt;a href=&quot;formatter/console&quot;&gt;TAP::Formatter::Console&lt;/a&gt;, or &lt;a href=&quot;formatter/file&quot;&gt;TAP::Formatter::File&lt;/a&gt; if the output isn't a TTY.</source>
          <target state="translated">用于格式化输出的类的名称。如果输出不是TTY ，则默认值为&lt;a href=&quot;formatter/console&quot;&gt;TAP :: Formatter :: Console&lt;/a&gt;或&lt;a href=&quot;formatter/file&quot;&gt;TAP :: Formatter :: File&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2938c30f6481c7209480e330f5d2558def4c79e1" translate="yes" xml:space="preserve">
          <source>The name of the class to use to multiplex tests during parallel testing. The default is &lt;a href=&quot;TAP::Parser::Multiplexer&quot;&gt;TAP::Parser::Multiplexer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72da2c41641715361491c5ff4abc5e20b2230add" translate="yes" xml:space="preserve">
          <source>The name of the class to use to multiplex tests during parallel testing. The default is &lt;a href=&quot;parser/multiplexer&quot;&gt;TAP::Parser::Multiplexer&lt;/a&gt;.</source>
          <target state="translated">在并行测试期间用于复用测试的类的名称。默认值为&lt;a href=&quot;parser/multiplexer&quot;&gt;TAP :: Parser :: Multiplexer&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d2b438590e86cedd0b4ce69e5a89edf3f57ce2f" translate="yes" xml:space="preserve">
          <source>The name of the class to use to parse TAP. The default is &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5c1530a58c08454895ba69cebd216b2fda858b" translate="yes" xml:space="preserve">
          <source>The name of the class to use to parse TAP. The default is &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="translated">用于解析TAP的类的名称。默认值为&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6353269469768546ffd890653f96373f13d0ecd8" translate="yes" xml:space="preserve">
          <source>The name of the class to use to schedule test execution. The default is &lt;a href=&quot;TAP::Parser::Scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c363903c8b428e2f92b68d74a94f7359ac65693" translate="yes" xml:space="preserve">
          <source>The name of the class to use to schedule test execution. The default is &lt;a href=&quot;parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="translated">用于计划测试执行的类的名称。默认值为&lt;a href=&quot;parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="be46c0fe1db34418e8697bff77cb46ef2046a9fa" translate="yes" xml:space="preserve">
          <source>The name of the constant, as seen by the perl code.</source>
          <target state="translated">常量的名称,如perl代码所示。</target>
        </trans-unit>
        <trans-unit id="4720e470b7493414aa6c88cde788462359384401" translate="yes" xml:space="preserve">
          <source>The name of the current report format for the currently selected output channel. The default format name is the same as the filehandle name. For example, the default format name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is just &lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">当前所选输出通道的当前报告格式的名称。默认格式名称与文件句柄名称相同。例如， &lt;code&gt;STDOUT&lt;/code&gt; 文件句柄的默认格式名称仅为 &lt;code&gt;STDOUT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f308d321f719413a7daef45e5b751142a5169847" translate="yes" xml:space="preserve">
          <source>The name of the current report format for the currently selected output channel. The default format name is the same as the filehandle name. For example, the default format name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is just &lt;code&gt;STDOUT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e5170077c0838d812432a43efc57d6e9e83c1c" translate="yes" xml:space="preserve">
          <source>The name of the current top-of-page format for the currently selected output channel. The default is the name of the filehandle with &lt;code&gt;_TOP&lt;/code&gt; appended. For example, the default format top name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is &lt;code&gt;STDOUT_TOP&lt;/code&gt; .</source>
          <target state="translated">当前所选输出通道的当前页面顶部格式的名称。默认值是附加了 &lt;code&gt;_TOP&lt;/code&gt; 的文件句柄的名称。例如， &lt;code&gt;STDOUT&lt;/code&gt; 文件句柄的默认格式名称为 &lt;code&gt;STDOUT_TOP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0743a6b94bb8bebfeea265e55206e1f27d87193" translate="yes" xml:space="preserve">
          <source>The name of the current top-of-page format for the currently selected output channel. The default is the name of the filehandle with &lt;code&gt;_TOP&lt;/code&gt; appended. For example, the default format top name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is &lt;code&gt;STDOUT_TOP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6379fb4c9e525f705c12afeef2d60c9f65c93af3" translate="yes" xml:space="preserve">
          <source>The name of the default local file, that $ff-&amp;gt;output_file falls back to if it would otherwise return no filename. For example when fetching a URI like &lt;a href=&quot;http://www.abc.net.au/&quot;&gt;http://www.abc.net.au/&lt;/a&gt; the contents retrieved may be from a remote file called 'index.html'. The default value of this attribute is literally 'file_default'.</source>
          <target state="translated">默认本地文件的名称，$ ff-&amp;gt; output_file会回退到该名称，否则它将不返回任何文件名。例如，当获取诸如&lt;a href=&quot;http://www.abc.net.au/&quot;&gt;http://www.abc.net.au/&lt;/a&gt;的URI时，检索到的内容可能来自名为&amp;ldquo; index.html&amp;rdquo;的远程文件。该属性的默认值为&amp;ldquo; file_default&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="724f86ff11ab9d4f954a655139b3c95fbd6d6b99" translate="yes" xml:space="preserve">
          <source>The name of the default local file, that $ff-&amp;gt;output_file falls back to if it would otherwise return no filename. For example when fetching a URI like http://www.abc.net.au/ the contents retrieved may be from a remote file called 'index.html'. The default value of this attribute is literally 'file_default'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ff7c2b3c1b5f1d9d21717655a465440b8c3a51" translate="yes" xml:space="preserve">
          <source>The name of the distribution. Often created by taking the &quot;main module&quot; in the distribution and changing &quot;::&quot; to &quot;-&quot;. Sometimes it's completely different, however, as in the case of the &lt;a href=&quot;http://search.cpan.org/author/GAAS/libwww-perl/&quot;&gt;libwww-perl&lt;/a&gt; distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec9b1148eb41355676951fe5003b4832073d292" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the C code. The default is &lt;code&gt;const-c.inc&lt;/code&gt; . The &lt;code&gt;-&lt;/code&gt; in the name ensures that the file can't be mistaken for anything related to a legitimate perl package name, and not naming the file &lt;code&gt;.c&lt;/code&gt; avoids having to override Makefile.PL's &lt;code&gt;.xs&lt;/code&gt; to &lt;code&gt;.c&lt;/code&gt; rules.</source>
          <target state="translated">包含C代码的要写入文件的名称。默认值为 &lt;code&gt;const-c.inc&lt;/code&gt; 。名称中的 &lt;code&gt;-&lt;/code&gt; 确保文件不会被误认为与合法的perl软件包名称相关的任何内容，并且不命名文件 &lt;code&gt;.c&lt;/code&gt; 避免了将Makefile.PL的 &lt;code&gt;.xs&lt;/code&gt; 覆盖为 &lt;code&gt;.c&lt;/code&gt; 规则。</target>
        </trans-unit>
        <trans-unit id="cd1ff7ef642391e787d3298e4e4d4178df728894" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the C code. The default is &lt;code&gt;const-c.inc&lt;/code&gt;. The &lt;code&gt;-&lt;/code&gt; in the name ensures that the file can't be mistaken for anything related to a legitimate perl package name, and not naming the file &lt;code&gt;.c&lt;/code&gt; avoids having to override Makefile.PL's &lt;code&gt;.xs&lt;/code&gt; to &lt;code&gt;.c&lt;/code&gt; rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bed22db2d9895f574b197dc49845a9793eb5ff4" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the XS code. The default is &lt;code&gt;const-xs.inc&lt;/code&gt; .</source>
          <target state="translated">包含XS代码的要写入文件的名称。默认值为 &lt;code&gt;const-xs.inc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff977189b5dca37639aa340e96771f65419bc6de" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the XS code. The default is &lt;code&gt;const-xs.inc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d500a8c6262466b93b5ca84e3fdd9132c3d42c" translate="yes" xml:space="preserve">
          <source>The name of the file you want to tie to the hash.</source>
          <target state="translated">你想绑定到哈希值的文件名。</target>
        </trans-unit>
        <trans-unit id="264313247d929c3123a9e7fe3982f9c4d6734ea2" translate="yes" xml:space="preserve">
          <source>The name of the file.</source>
          <target state="translated">文件的名称。</target>
        </trans-unit>
        <trans-unit id="2fed9b5e3d1ecfa444bc4bf0c0867e79f9d251bc" translate="yes" xml:space="preserve">
          <source>The name of the interior sequence command.</source>
          <target state="translated">内部序列命令的名称。</target>
        </trans-unit>
        <trans-unit id="850e998443ed95a332bbac695731c9e48b93fd64" translate="yes" xml:space="preserve">
          <source>The name of the label is returned in the form of a fresh scalar. If an optional label is absent, a null pointer is returned.</source>
          <target state="translated">标签的名称以新标量的形式返回。如果没有可选的标签,则返回一个空指针。</target>
        </trans-unit>
        <trans-unit id="73fad9a569b3c6f7964969b809a10335f9888518" translate="yes" xml:space="preserve">
          <source>The name of the layer whose open() method Perl should invoke on open(). For example if the layer is called APR, you will call:</source>
          <target state="translated">在open()时,Perl应该调用其open()方法的层的名称。例如,如果这个图层被称为APR,你将调用。</target>
        </trans-unit>
        <trans-unit id="72863e084ba8d90c496ae5c6484f120959926659" translate="yes" xml:space="preserve">
          <source>The name of the method</source>
          <target state="translated">方法的名称</target>
        </trans-unit>
        <trans-unit id="e4c23f5fa4cbd2a24c92f584213f4e01a597f939" translate="yes" xml:space="preserve">
          <source>The name of the module you wish to verify -- this is a required key</source>
          <target state="translated">您要验证的模块名称--这是一个必要的关键。</target>
        </trans-unit>
        <trans-unit id="8baabdd6359e36f0075679bff6c64a42d5070771" translate="yes" xml:space="preserve">
          <source>The name of the operating system under which this copy of Perl was built, as determined during the configuration process. For examples see &lt;a href=&quot;perlport#PLATFORMS&quot;&gt;&quot;PLATFORMS&quot; in perlport&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917bce2995f64faec20b4096ae916c3c8efb0bec" translate="yes" xml:space="preserve">
          <source>The name of the operating system under which this copy of Perl was built, as determined during the configuration process. For examples see &lt;a href=&quot;perlport#PLATFORMS&quot;&gt;PLATFORMS in perlport&lt;/a&gt;.</source>
          <target state="translated">在配置过程中确定的构建Perl副本的操作系统的名称。有关示例，请参见&lt;a href=&quot;perlport#PLATFORMS&quot;&gt;perlport中的PLATFORMS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2040df0b9281e990b52b6ffee0618e248f91a919" translate="yes" xml:space="preserve">
          <source>The name of the output file. This is the same as $ff-&amp;gt;file, but any query parameters are stripped off. For example:</source>
          <target state="translated">输出文件的名称。这与$ ff-&amp;gt; file相同，但是会删除所有查询参数。例如：</target>
        </trans-unit>
        <trans-unit id="cbe18d7ad69e81d6c826df352db92d6f22fccd8c" translate="yes" xml:space="preserve">
          <source>The name of the program being documented is conventionally written in bold (using B&amp;lt;&amp;gt;) wherever it occurs, as are all program options. Arguments should be written in italics (I&amp;lt;&amp;gt;). Function names are traditionally written in italics; if you write a function as function(), Pod::Man will take care of this for you. Literal code or commands should be in C&amp;lt;&amp;gt;. References to other man pages should be in the form &lt;code&gt;manpage(section)&lt;/code&gt; or &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt; , and Pod::Man will automatically format those appropriately. The second form, with L&amp;lt;&amp;gt;, is used to request that a POD formatter make a link to the man page if possible. As an exception, one normally omits the section when referring to module documentation since it's not clear what section module documentation will be in; use &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; for module references instead.</source>
          <target state="translated">记录的程序的名称通常会以粗体显示（使用B &amp;lt;&amp;gt;），所有程序选项也是如此。参数应以斜体（I &amp;lt;&amp;gt;）书写。函数名称传统上用斜体写；如果您将函数编写为function（），则Pod :: Man将为您解决此问题。文字代码或命令应位于C &amp;lt;&amp;gt;中。对其他手册页的引用应采用 &lt;code&gt;manpage(section)&lt;/code&gt; 或 &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt; ，并且Pod :: Man将自动将其格式正确。第二种形式，带有L &amp;lt;&amp;gt;，用于请求POD格式化程序在可能的情况下建立指向手册页的链接。作为例外，通常在引用模块文档时会省略该部分，因为尚不清楚模块文档将位于哪个部分。用 &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; 代替模块引用。</target>
        </trans-unit>
        <trans-unit id="1b18709c27f5d88461bdcb14ca9e036ab15a9e4c" translate="yes" xml:space="preserve">
          <source>The name of the program being documented is conventionally written in bold (using B&amp;lt;&amp;gt;) wherever it occurs, as are all program options. Arguments should be written in italics (I&amp;lt;&amp;gt;). Function names are traditionally written in italics; if you write a function as function(), Pod::Man will take care of this for you. Literal code or commands should be in C&amp;lt;&amp;gt;. References to other man pages should be in the form &lt;code&gt;manpage(section)&lt;/code&gt; or &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt;, and Pod::Man will automatically format those appropriately. The second form, with L&amp;lt;&amp;gt;, is used to request that a POD formatter make a link to the man page if possible. As an exception, one normally omits the section when referring to module documentation since it's not clear what section module documentation will be in; use &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; for module references instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1dece7f57632e56f321f082b4b7487de40077a" translate="yes" xml:space="preserve">
          <source>The name of the program currently executing, as typed on the command line. In C, the &lt;b&gt;command&lt;/b&gt; name is passed to the program as the first command-line argument. In Perl, it comes in separately as &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="translated">在命令行上键入的当前正在执行的程序的名称。在C语言中，&lt;b&gt;命令&lt;/b&gt;名称作为第一个命令行参数传递给程序。在Perl中，它作为 &lt;code&gt;$0&lt;/code&gt; 单独出现。</target>
        </trans-unit>
        <trans-unit id="24e0c1ed3bcd878bf180116a18e90c254b00991c" translate="yes" xml:space="preserve">
          <source>The name of the program currently executing, as typed on the command line. In C, the &lt;b&gt;command&lt;/b&gt; name is passed to the program as the first command-line argument. In Perl, it comes in separately as &lt;code&gt;$0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87ba5fd11240d3846b6402630cc4fc5a1bb692a" translate="yes" xml:space="preserve">
          <source>The name of the remote file. For the local file name, the result of $ff-&amp;gt;output_file will be used.</source>
          <target state="translated">远程文件的名称。对于本地文件名，将使用$ ff-&amp;gt; output_file的结果。</target>
        </trans-unit>
        <trans-unit id="7b5484f9bbb8c882de4857813fc18405c14f1941" translate="yes" xml:space="preserve">
          <source>The name of the subtest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a547e6d045957f910163d7d9750610edbb9f85" translate="yes" xml:space="preserve">
          <source>The name of the test that will be displayed after the &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;not
ok&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;ok&lt;/code&gt; 或 &lt;code&gt;not ok&lt;/code&gt; 之后将显示的测试名称。</target>
        </trans-unit>
        <trans-unit id="0319d70ade81e70a5ad5c9b04019b6a6a650fd8c" translate="yes" xml:space="preserve">
          <source>The name of the test that will be displayed after the &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;not ok&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed54953d3ed163e618a466d003f5bcd630ecc77" translate="yes" xml:space="preserve">
          <source>The name of the test. Usually a filename.</source>
          <target state="translated">测试的名称。通常是一个文件名。</target>
        </trans-unit>
        <trans-unit id="bddd22d202ef6bbfb07440852aa85decd3f86741" translate="yes" xml:space="preserve">
          <source>The name of the variable the OP's targ refers to, if any, otherwise the letter t followed by the OP's targ in decimal.</source>
          <target state="translated">OP的targ所指向的变量名称,如果有的话,否则在OP的targ后面加上字母t,用十进制表示。</target>
        </trans-unit>
        <trans-unit id="57d8fd0b0612e473ba409ed332506df9547952e4" translate="yes" xml:space="preserve">
          <source>The name of this target is the name of the tarball generated by tardist. This target does the actual work of turning the distdir into a tarball.</source>
          <target state="translated">这个目标的名字是 tardist 生成的 tar 包的名字。这个目标完成了将 distdir 变成 tar 包的实际工作。</target>
        </trans-unit>
        <trans-unit id="7f384abee623b7aefa3eee77d6cf325a89576f28" translate="yes" xml:space="preserve">
          <source>The name of this target is the name of the zip file generated by zipdist. This target does the actual work of turning the distdir into a zip file.</source>
          <target state="translated">这个目标的名称是 zipdist 生成的 zip 文件的名称。这个目标完成了将distdir转化为zip文件的实际工作。</target>
        </trans-unit>
        <trans-unit id="40fffdd6d8d082596e0b6d7269c4fc2ab2372dd8" translate="yes" xml:space="preserve">
          <source>The name or URL, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the name (also sometimes called the page) is &quot;perlfunc&quot;. In &quot;L&amp;lt;/CAVEATS&amp;gt;&quot;, the name is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">名称或URL，如果没有则为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。（例如，在&amp;ldquo; L &amp;lt;Perl Functions | perlfunc&amp;gt;&amp;rdquo;中，名称（有时也称为页面）为&amp;ldquo; perlfunc&amp;rdquo;。在&amp;ldquo; L &amp;lt;/ CAVEATS&amp;gt;&amp;rdquo;中，名称为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="db1774b0bd337a6db893379927df425f03f56870" translate="yes" xml:space="preserve">
          <source>The name or URL, or &lt;code&gt;undef&lt;/code&gt; if none. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the name (also sometimes called the page) is &quot;perlfunc&quot;. In &quot;L&amp;lt;/CAVEATS&amp;gt;&quot;, the name is &lt;code&gt;undef&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032b79c8986bca0bbbc3c31a86f48e2e4e0d3085" translate="yes" xml:space="preserve">
          <source>The name returned is the &quot;best&quot; (defined below) official name or alias for the code point, if available; otherwise your custom alias for it, if defined; otherwise &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. This means that your alias will only be returned for code points that don't have an official Unicode name (nor alias) such as private use code points.</source>
          <target state="translated">返回的名称是代码点的&amp;ldquo;最佳&amp;rdquo;（在下面定义）正式名称或别名；否则，您的自定义别名（如果已定义）；否则 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。这意味着您的别名将仅针对没有正式Unicode名称（也不是别名）的代码点（例如专用代码点）返回。</target>
        </trans-unit>
        <trans-unit id="6ccf456e05fb0bbcace6b6fbae7f69f4f9acbb13" translate="yes" xml:space="preserve">
          <source>The name returned is the &quot;best&quot; (defined below) official name or alias for the code point, if available; otherwise your custom alias for it, if defined; otherwise &lt;code&gt;undef&lt;/code&gt;. This means that your alias will only be returned for code points that don't have an official Unicode name (nor alias) such as private use code points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c859e03c561ae7900b19a5195289cf330fd686" translate="yes" xml:space="preserve">
          <source>The name specification contains the name of the option, optionally followed by a list of alternative names separated by vertical bar characters.</source>
          <target state="translated">名称规格包含了选项的名称,后面是由竖条字符分隔的备选名称列表。</target>
        </trans-unit>
        <trans-unit id="c00824bf96e3af72974b0dc7167ce50b9784a97a" translate="yes" xml:space="preserve">
          <source>The name stored in the pad name struct. This returns &lt;code&gt;NULL&lt;/code&gt; for a target slot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ea5f2153ac354bb676ac855da5204a1c4f0887" translate="yes" xml:space="preserve">
          <source>The name stored in the pad name struct. This returns NULL for a target slot.</source>
          <target state="translated">存储在pad name结构中的名称。对于目标槽,返回NULL。</target>
        </trans-unit>
        <trans-unit id="8d08870c9ada1df075e2fe0edf360d9170cd33f2" translate="yes" xml:space="preserve">
          <source>The name supplied for the test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9c5d421e8490b0fb44df42960273145ec017c2" translate="yes" xml:space="preserve">
          <source>The name that &lt;code&gt;gv_stash*v&lt;/code&gt; wants is the name of the package whose symbol table you want. The default package is called &lt;code&gt;main&lt;/code&gt; . If you have multiply nested packages, pass their names to &lt;code&gt;gv_stash*v&lt;/code&gt; , separated by &lt;code&gt;::&lt;/code&gt; as in the Perl language itself.</source>
          <target state="translated">那名 &lt;code&gt;gv_stash*v&lt;/code&gt; 要的是你想要其符号表中的包的名称。默认软件包称为 &lt;code&gt;main&lt;/code&gt; 。如果您有多个嵌套的软件包， &lt;code&gt;gv_stash*v&lt;/code&gt; 它们的名称传递给gv_stash * v，与Perl语言本身一样，以 &lt;code&gt;::&lt;/code&gt; 分隔。</target>
        </trans-unit>
        <trans-unit id="3ac1dff6b7360564b5ef0a6823013e115cd6dc89" translate="yes" xml:space="preserve">
          <source>The name that &lt;code&gt;gv_stash*v&lt;/code&gt; wants is the name of the package whose symbol table you want. The default package is called &lt;code&gt;main&lt;/code&gt;. If you have multiply nested packages, pass their names to &lt;code&gt;gv_stash*v&lt;/code&gt;, separated by &lt;code&gt;::&lt;/code&gt; as in the Perl language itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5602fbc4cb262cfe30268630c826bf892b1b3d53" translate="yes" xml:space="preserve">
          <source>The name used by the Perl community. That includes 'utf8' and 'ascii'. Unlike aliases, canonical names directly reach the method so such frequently used words like 'utf8' don't need to do alias lookups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44f8223ba7b643b349f360058fbf26b1973aa5a7" translate="yes" xml:space="preserve">
          <source>The name used by the organization that defined it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ea1c9f71e1742c14f7e274aadd24083453f785c" translate="yes" xml:space="preserve">
          <source>The name used to execute the current copy of Perl, from C's &lt;code&gt;argv[0]&lt;/code&gt; or (where supported)</source>
          <target state="translated">用于执行C的 &lt;code&gt;argv[0]&lt;/code&gt; 或（如果支持）的Perl当前副本的名称</target>
        </trans-unit>
        <trans-unit id="7d5e4108cb484849f5cc23fa9d5c378793d57fcf" translate="yes" xml:space="preserve">
          <source>The names</source>
          <target state="translated">名称</target>
        </trans-unit>
        <trans-unit id="e163bed624ffb39e2435b88e57776aaac39a8121" translate="yes" xml:space="preserve">
          <source>The names are in the old-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style versus new-style block names&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618e9ec6e6fd129b3719b6fed50188e89fd59442" translate="yes" xml:space="preserve">
          <source>The names are in the old-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">名称采用旧样式（请参见&amp;ldquo; &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;旧样式&amp;rdquo;和&amp;ldquo;新样式&amp;rdquo;的块名&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="07ca386df79309f7e041c206d3183ef66c0ddbc4" translate="yes" xml:space="preserve">
          <source>The names associated with pad entries.</source>
          <target state="translated">与焊盘条目相关的名称。</target>
        </trans-unit>
        <trans-unit id="9b163a7bfc6ff4bff1595ddcc9e4a9a73a9a9a05" translate="yes" xml:space="preserve">
          <source>The names have been chosen by analogy with &lt;a href=&quot;Tie::Scalar&quot;&gt;Tie::Scalar&lt;/a&gt; methods names with an additional &lt;b&gt;LENGTH&lt;/b&gt; callback for efficiency. However named capture variables are currently not tied internally but implemented via magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284af84a82eacc68e4acdb3ccfa2e6b8438eb902" translate="yes" xml:space="preserve">
          <source>The names have been chosen by analogy with &lt;a href=&quot;tie/scalar&quot;&gt;Tie::Scalar&lt;/a&gt; methods names with an additional &lt;b&gt;LENGTH&lt;/b&gt; callback for efficiency. However named capture variables are currently not tied internally but implemented via magic.</source>
          <target state="translated">名称的选择与&lt;a href=&quot;tie/scalar&quot;&gt;Tie :: Scalar&lt;/a&gt;方法名称类似，并带有附加的&lt;b&gt;LENGTH&lt;/b&gt;回调以提高效率。但是，命名的捕获变量当前不内部绑定，而是通过魔术实现的。</target>
        </trans-unit>
        <trans-unit id="6f2021e99e612abfa74ac94b1f6cbd3e729a273e" translate="yes" xml:space="preserve">
          <source>The names of any symbols that cannot be exported should be listed in the &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; array.</source>
          <target state="translated">&lt;code&gt;@EXPORT_FAIL&lt;/code&gt; 数组中应列出无法导出的任何符号的名称。</target>
        </trans-unit>
        <trans-unit id="ce28b5edeebefe670a07dac363032a7c7d1c8c78" translate="yes" xml:space="preserve">
          <source>The names of one or more patch files or other text attachments to be included with the report. Multiple files must be separated with commas.</source>
          <target state="translated">要列入报告的一个或多个补丁文件或其他文本附件的名称。多个文件必须用逗号分隔。</target>
        </trans-unit>
        <trans-unit id="8f857c3b3defbce0780a8f039ec3e39d992aed2b" translate="yes" xml:space="preserve">
          <source>The names of the constants are grouped by length. Generate child subroutines for each group with this number or more names in.</source>
          <target state="translated">常量的名称按长度分组。为每组生成子程序,每组有这个数量或更多的名字在。</target>
        </trans-unit>
        <trans-unit id="014e7ffcf388c955244e207841832a805e1b764b" translate="yes" xml:space="preserve">
          <source>The names of the fields can be obtained by calling &lt;code&gt;overview_fmt&lt;/code&gt; .</source>
          <target state="translated">可以通过调用 &lt;code&gt;overview_fmt&lt;/code&gt; 获得字段的名称。</target>
        </trans-unit>
        <trans-unit id="e645b67ba06f3c61734454bcb81a97d709157227" translate="yes" xml:space="preserve">
          <source>The names of the fields can be obtained by calling &lt;code&gt;overview_fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4fc313d5aefbc7e8f27ebb1be72375df1f65ec2" translate="yes" xml:space="preserve">
          <source>The names of the signals are the ones listed out by &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; on your system, or you can retrieve them using the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Signal&quot;&gt;IPC::Signal&lt;/a&gt;.</source>
          <target state="translated">信号的名称是系统上 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; 列出的名称，或者您可以使用CPAN模块&lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Signal&quot;&gt;IPC :: Signal&lt;/a&gt;检索它们。</target>
        </trans-unit>
        <trans-unit id="6e02e2136011dc08d1ab7910eb739f830a21ebe7" translate="yes" xml:space="preserve">
          <source>The names of the signals are the ones listed out by &lt;code&gt;kill -l&lt;/code&gt; on your system, or you can retrieve them using the CPAN module &lt;a href=&quot;IPC::Signal&quot;&gt;IPC::Signal&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5a87a1d013fec4fa7021ebe1fad71eb5dada0f" translate="yes" xml:space="preserve">
          <source>The naming of encodings, both by the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; and by the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma allows for flexible names: &lt;code&gt;koi8-r&lt;/code&gt; and &lt;code&gt;KOI8R&lt;/code&gt; will both be understood.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma 都对编码进行命名可以使用灵活的名称： &lt;code&gt;koi8-r&lt;/code&gt; 和 &lt;code&gt;KOI8R&lt;/code&gt; 都可以理解。</target>
        </trans-unit>
        <trans-unit id="854c8ac2d9120b67c893ac9dc1ee0ecda32433aa" translate="yes" xml:space="preserve">
          <source>The naming of encodings, both by the &lt;code&gt;open()&lt;/code&gt; and by the &lt;code&gt;open&lt;/code&gt; pragma allows for flexible names: &lt;code&gt;koi8-r&lt;/code&gt; and &lt;code&gt;KOI8R&lt;/code&gt; will both be understood.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8afc81fb7787a63e6fa9bc963817cbc2add1c18f" translate="yes" xml:space="preserve">
          <source>The native Win32 version of &lt;code&gt;seek()&lt;/code&gt;. &lt;code&gt;SetFilePointer&lt;/code&gt; sets the position within a file where the next read or write operation will start from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb26ebee327534f7eadec1f76baa31ad090fef00" translate="yes" xml:space="preserve">
          <source>The native status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. On POSIX-like systems this value can be decoded with the WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG and WIFCONTINUED functions provided by the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="translated">最后一个管道关闭，反引号（ &lt;code&gt;``&lt;/code&gt; ）命令，成功调用 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; 或从 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 运算符返回的本机状态。在类似POSIX的系统上，可以使用&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块提供的WIFEXITED，WEXITSTATUS，WIFSIGNALED，WTERMSIG，WIFSTOPPED，WSTOPSIG和WIFCONTINUED函数对该值进行解码。</target>
        </trans-unit>
        <trans-unit id="bbaba3e2cc788e3f7da9b6f38cb2688cde834f68" translate="yes" xml:space="preserve">
          <source>The native status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt;) command, successful call to &lt;code&gt;wait()&lt;/code&gt; or &lt;code&gt;waitpid()&lt;/code&gt;, or from the &lt;code&gt;system()&lt;/code&gt; operator. On POSIX-like systems this value can be decoded with the WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG and WIFCONTINUED functions provided by the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f679d50295d2d00d85ba280df81111988684878" translate="yes" xml:space="preserve">
          <source>The natural question: &quot;Why can't Perl compensate for the gaps?&quot; warrants an answer. One good reason is that C compilers might provide (non-ANSI) extensions permitting all sorts of fancy control over the way structures are aligned, even at the level of an individual structure field. And, if this were not enough, there is an insidious thing called &lt;code&gt;union&lt;/code&gt; where the amount of fill bytes cannot be derived from the alignment of the next item alone.</source>
          <target state="translated">自然的问题是：&amp;ldquo;为什么Perl无法弥补这些差距？&amp;rdquo; 有一个答案。一个很好的理由是C编译器可能会提供（非ANSI）扩展名，即使在单个结构字段的级别上，也可以对结构的对齐方式进行各种形式的控制。而且，如果这还不够的话，那么有一个阴险的事情叫做 &lt;code&gt;union&lt;/code&gt; ，其中填充字节的数量不能仅从下一项的对齐中得出。</target>
        </trans-unit>
        <trans-unit id="73304f2bc3720cbdf5bbe3a347ce1a6a6606cb3e" translate="yes" xml:space="preserve">
          <source>The natural way to do this is to have a hash whose keys are country names. Associated with each country name key is a list of the cities in that country. Each time you read a line of input, split it into a country and a city, look up the list of cities already known to be in that country, and append the new city to the list. When you're done reading the input, iterate over the hash as usual, sorting each list of cities before you print it out.</source>
          <target state="translated">自然而然的方法是有一个哈希,其键是国家名称。与每个国家名键相关联的是这个国家的城市列表。每次读取一行输入时,把它分成一个国家和一个城市,查找已经知道的那个国家的城市列表,并把新的城市追加到列表中。当你读完输入时,像往常一样在哈希中迭代,在打印出来之前对每个城市列表进行排序。</target>
        </trans-unit>
        <trans-unit id="47d44728d6d28aac48e384cc30fefc76b5a26c28" translate="yes" xml:space="preserve">
          <source>The negated versions of the lookahead and lookbehind assertions are denoted by &lt;code&gt;(?!regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; respectively. Or, starting in 5.32 (experimentally in 5.28), &lt;code&gt;(*nla:regexp)&lt;/code&gt;, &lt;code&gt;(*negative_lookahead:regexp)&lt;/code&gt;, &lt;code&gt;(*nlb:regexp)&lt;/code&gt;, or &lt;code&gt;(*negative_lookbehind:regexp)&lt;/code&gt;. They evaluate true if the regexps do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba13cfae515a220e252c3e1157af722de7da0aa" translate="yes" xml:space="preserve">
          <source>The negation is useful for defining (surprise!) negated classes.</source>
          <target state="translated">否定式对于定义(惊喜!)被否定的类是有用的。</target>
        </trans-unit>
        <trans-unit id="db0ad6bd4816ce652496b94f2f1d7976b92ada0c" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_NN&lt;/code&gt; which elide the NULL pointer check.</source>
          <target state="translated">该宏 &lt;code&gt;OP_TYPE_ISNT&lt;/code&gt; 的取反以及 &lt;code&gt;OP_TYPE_IS_NN&lt;/code&gt; 和 &lt;code&gt;OP_TYPE_ISNT_NN&lt;/code&gt; 都可以使用，它们忽略了NULL指针检查。</target>
        </trans-unit>
        <trans-unit id="34a8b60e3a36600480a60cec2deec17ff174ebef" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; which elide the &lt;code&gt;NULL&lt;/code&gt; pointer check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691f70fa29f72e49de97eccc12c05c1f840f1b46" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; which elide the NULL pointer check.</source>
          <target state="translated">该宏 &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; 的取反以及 &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; 和 &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; 都可以使用，它们可以忽略 NULL指针检查。</target>
        </trans-unit>
        <trans-unit id="528d5b378ab36165946632706d39fa6c9839837e" translate="yes" xml:space="preserve">
          <source>The new behavior provides a much more robust solution for checking Winsock errors in portable software without accidentally matching POSIX tests that were intended for other OSes and may have different meanings for Winsock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68f1f4d38ce035e2e238de529bbc7313afe802e" translate="yes" xml:space="preserve">
          <source>The new class is given a constructor method, &lt;code&gt;new&lt;/code&gt; , for creating struct objects.</source>
          <target state="translated">新类具有构造方法 &lt;code&gt;new&lt;/code&gt; ，用于创建struct对象。</target>
        </trans-unit>
        <trans-unit id="9d80888ad8b596747bf8185a9ccf7eb36f05c472" translate="yes" xml:space="preserve">
          <source>The new class is given a constructor method, &lt;code&gt;new&lt;/code&gt;, for creating struct objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133a286ef1fa797920ffbacb6d543c092bbb9c81" translate="yes" xml:space="preserve">
          <source>The new compare function must be specified when you create the database.</source>
          <target state="translated">新的比较函数必须在创建数据库时指定。</target>
        </trans-unit>
        <trans-unit id="6ca5133e85084fb8ccd654bdee5f648c6a7925f9" translate="yes" xml:space="preserve">
          <source>The new interface to the USE_PERLIO implementation. The layers &quot;:crlf&quot; and &quot;:raw&quot; are only ones allowed for other implementations and those are silently ignored. (As of perl5.8 &quot;:raw&quot; is deprecated.) Use PerlIO_binmode() below for the portable case.</source>
          <target state="translated">USE_PERLIO 实现的新接口。&quot;:crlf&quot; 和 &quot;:raw&quot; 这两个层是其他实现所允许的,它们会被默默地忽略。(从 perl5.8 开始,&quot;:raw&quot; 已经过时了。)使用下面的 PerlIO_binmode()来处理可移植的情况。</target>
        </trans-unit>
        <trans-unit id="ef605716ebbaada258955508adf61e07c343c95f" translate="yes" xml:space="preserve">
          <source>The new key is specified by</source>
          <target state="translated">新钥匙由</target>
        </trans-unit>
        <trans-unit id="93da98420a9bfc76d18ae79d8876182fff5c85c5" translate="yes" xml:space="preserve">
          <source>The new key is specified by &lt;code&gt;keypv&lt;/code&gt; and &lt;code&gt;keylen&lt;/code&gt;. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;REFCOUNTED_HE_KEY_UTF8&lt;/code&gt; bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. &lt;code&gt;hash&lt;/code&gt; is a precomputed hash of the key string, or zero if it has not been precomputed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853b1cad8315c050b3031642990285f3b3f61796" translate="yes" xml:space="preserve">
          <source>The new perlIO layer is used. NI-S' favorite.</source>
          <target state="translated">使用了新的perlIO层。NI-S的最爱。</target>
        </trans-unit>
        <trans-unit id="437054ab8086dcb8d5230b53692e92ce8976728d" translate="yes" xml:space="preserve">
          <source>The new prereqs object has no ties to the originals, and altering it further will not alter them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f44fc740bd8115fd48ea2f3dccbe8d30383620f" translate="yes" xml:space="preserve">
          <source>The new routine will be called whenever a built-in function is called without a qualifying package:</source>
          <target state="translated">每当调用一个没有限定包的内置函数时,新例程就会被调用。</target>
        </trans-unit>
        <trans-unit id="69fd8169a1c03a87b9cb7323668ea2985b78ca39" translate="yes" xml:space="preserve">
          <source>The new semantics are now only available with &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; . The old semantics are only available through &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; . Users are strongly encouraged to upgrade to at least 2.08 in order to avoid surprises.</source>
          <target state="translated">现在，新语义仅在 &lt;code&gt;make_path&lt;/code&gt; 和 &lt;code&gt;remove_tree&lt;/code&gt; 中可用。旧的语义只能通过 &lt;code&gt;mkpath&lt;/code&gt; 和 &lt;code&gt;rmtree&lt;/code&gt; 使用。强烈建议用户升级到至少2.08，以避免出现意外情况。</target>
        </trans-unit>
        <trans-unit id="e786b3ec60d0d79422f9596d38dfebba203b53ce" translate="yes" xml:space="preserve">
          <source>The new semantics are now only available with &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt;. The old semantics are only available through &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt;. Users are strongly encouraged to upgrade to at least 2.08 in order to avoid surprises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb00043758d6e48f38e06be5dcd0156fe97d078" translate="yes" xml:space="preserve">
          <source>The new shiny result of either genuine new functionality or your arduous refactoring is now ready and correctly exported. So what could possibly go wrong?</source>
          <target state="translated">无论是真正的新功能还是您艰辛的重构,新的闪亮结果现在已经准备好了,并且正确地导出了。那么有什么可能出错呢?</target>
        </trans-unit>
        <trans-unit id="c231cf25130a94dd10bb860a955a6b6ad30c18f8" translate="yes" xml:space="preserve">
          <source>The new simpler way to call &lt;code&gt;XSLoader::load()&lt;/code&gt; with no arguments at all does not work on Perl 5.8.4 and 5.8.5.</source>
          <target state="translated">根本没有任何参数调用 &lt;code&gt;XSLoader::load()&lt;/code&gt; 的新的更简单的方法在Perl 5.8.4和5.8.5上不起作用。</target>
        </trans-unit>
        <trans-unit id="80d8983154af8008f3d7e48dfd488df835186d04" translate="yes" xml:space="preserve">
          <source>The new thread creation is line 20. We pass on to it a reference to the queue we've created, and the prime number we've found. In lines 21 through 24, we check to make sure that our new thread got created, and if not, we stop checking any remaining numbers in the queue.</source>
          <target state="translated">新的线程创建是第20行。我们将我们创建的队列和找到的质数的引用传递给它。在第21行到第24行,我们检查我们的新线程是否被创建,如果没有,我们停止检查队列中剩余的数字。</target>
        </trans-unit>
        <trans-unit id="9044c695c3da968e5a2ea15d51b8b1e2dbc7cbb0" translate="yes" xml:space="preserve">
          <source>The new() function searches for all the installed .packlists on the system, and stores their contents. The .packlists can be queried with the functions described below. Where it searches by default is determined by the settings found in &lt;code&gt;%Config::Config&lt;/code&gt; , and what the value is of the PERL5LIB environment variable.</source>
          <target state="translated">new（）函数搜索系统上所有已安装的.packlists，并存储其内容。可以使用以下功能查询.packlists。默认情况下，它的搜索位置取决于 &lt;code&gt;%Config::Config&lt;/code&gt; 以及PERL5LIB环境变量的值。</target>
        </trans-unit>
        <trans-unit id="e6b22aa358acbe55c29900d7f62b40d0edc02821" translate="yes" xml:space="preserve">
          <source>The new() function searches for all the installed .packlists on the system, and stores their contents. The .packlists can be queried with the functions described below. Where it searches by default is determined by the settings found in &lt;code&gt;%Config::Config&lt;/code&gt;, and what the value is of the PERL5LIB environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e76ad120503fe22fb2abd0288095a443b471d16" translate="yes" xml:space="preserve">
          <source>The newer style replaces these with underscores, like this:</source>
          <target state="translated">新的样式用下划线代替了这些,就像这样。</target>
        </trans-unit>
        <trans-unit id="0249c11220739d961eab9d8efdfb827caa468595" translate="yes" xml:space="preserve">
          <source>The newly created subroutine takes ownership of a reference to the passed in SV.</source>
          <target state="translated">新创建的子程序拥有对传入SV的引用的所有权。</target>
        </trans-unit>
        <trans-unit id="c36ff1fb86ca87ccc2385388c9e1be809de8496c" translate="yes" xml:space="preserve">
          <source>The next 8 bits contain the termination status of the program.</source>
          <target state="translated">后面8位包含程序的终止状态。</target>
        </trans-unit>
        <trans-unit id="429ca09b18f928ad50edc605bbb88976cae30220" translate="yes" xml:space="preserve">
          <source>The next example demonstrates how one would place an explicit undef in the return value, should the need arise.</source>
          <target state="translated">下一个例子演示了如何在返回值中放置一个显式的undef,如果需要的话。</target>
        </trans-unit>
        <trans-unit id="abdb50fe44b0e7ab1495a77ca76309d394c16e26" translate="yes" xml:space="preserve">
          <source>The next example show how to use the &lt;code&gt;LimitOutput&lt;/code&gt; option. Notice the use of two nested loops in this case. The outer loop reads the data from the input source - STDIN and the inner loop repeatedly calls &lt;code&gt;inflate&lt;/code&gt; until &lt;code&gt;$input&lt;/code&gt; is exhausted, we get an error, or the end of the stream is reached. One point worth remembering is by using the &lt;code&gt;LimitOutput&lt;/code&gt; option you also get &lt;code&gt;ConsumeInput&lt;/code&gt; set as well - this makes the code below much simpler.</source>
          <target state="translated">下一个示例显示如何使用 &lt;code&gt;LimitOutput&lt;/code&gt; 选项。注意在这种情况下使用两个嵌套循环。外循环从输入源-STDIN读取数据，内循环重复调用 &lt;code&gt;inflate&lt;/code&gt; ,直到 &lt;code&gt;$input&lt;/code&gt; 耗尽，我们得到一个错误，或到达流的末尾。值得记住的一点是，通过使用 &lt;code&gt;LimitOutput&lt;/code&gt; 选项，您还可以设置 &lt;code&gt;ConsumeInput&lt;/code&gt; ，这使下面的代码更加简单。</target>
        </trans-unit>
        <trans-unit id="a73f1f7691d7497b711d0f4bac2e881b3c885873" translate="yes" xml:space="preserve">
          <source>The next example shows each input parameter evaluated late.</source>
          <target state="translated">下一个例子显示了每一个输入参数的后期评估。</target>
        </trans-unit>
        <trans-unit id="def9f1245a38d3c5116ce761f9376e6f2078f597" translate="yes" xml:space="preserve">
          <source>The next examples will use the following C++ class.</source>
          <target state="translated">接下来的例子将使用以下C++类。</target>
        </trans-unit>
        <trans-unit id="6c82e2eba4791c1303c10eb37d70a72bf59badcd" translate="yes" xml:space="preserve">
          <source>The next option deals with the charset (a.k.a. character set) your terminal supports. In general, CPAN is English speaking territory, so the charset does not matter much but some CPAN have names that are outside the ASCII range. If your terminal supports UTF-8, you should say no to the next question. If it expects ISO-8859-1 (also known as LATIN1) then you should say yes. If it supports neither, your answer does not matter because you will not be able to read the names of some authors anyway. If you answer no, names will be output in UTF-8.</source>
          <target state="translated">下一個選項是關於你的終端機所支援的字符集(charset)。一般來說,CPAN 是英文的領域,所以字符集並不重要,但有些 CPAN 的名稱是在 ASCII 範圍之外的,如果你的終端支援 UTF-8,你應該對下一個問題說不。如果您的终端支持UTF-8,您应该对下一个问题说不。如果您的终端支持ISO-8859-1(也称为LATIN1),那么您应该说 &quot;是&quot;。如果两者都不支持,您的回答就不重要了,因为您无论如何都无法读取某些作者的名字。如果您回答 &quot;否&quot;,名字将以UTF-8输出。</target>
        </trans-unit>
        <trans-unit id="128477608ba084f3baead065e12f71790ccb5def" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt; es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="translated">&lt;code&gt;BRANCH&lt;/code&gt; es 的下一个指针很有趣，因为它指向分支失败时应该执行的位置。执行时，如果引擎尝试从分支遍历到不是分支的 &lt;code&gt;regnext&lt;/code&gt; ，则引擎将知道整个分支集都已失败。</target>
        </trans-unit>
        <trans-unit id="49d098f677fc7d28016366882913ea295f0ea710" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt;es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b56244f1caeaf0b5b4e0b479de80d44c501b35d" translate="yes" xml:space="preserve">
          <source>The next step is interpolation in the text obtained, which is now delimiter-independent. There are multiple cases.</source>
          <target state="translated">下一步是在得到的文本中进行插值,现在的文本与分隔符无关。有多种情况。</target>
        </trans-unit>
        <trans-unit id="2e9d420a49c5570abf7ae9f3e075e9465afea859" translate="yes" xml:space="preserve">
          <source>The next step is the type-specific context processing; in this case &lt;code&gt;cx_popsub&lt;/code&gt;. In part, this looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b245543afec9985d508833acde280bdb2e09df89" translate="yes" xml:space="preserve">
          <source>The next step is to add some symlinks to system libraries. For example, the development software expect a library &lt;code&gt;libm.so&lt;/code&gt; that normally is a symlink to &lt;code&gt;libm.so.6&lt;/code&gt;. Synology only provides the latter and not the symlink.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e87f516f02471787ab2f018e28d7851e0ac5f9" translate="yes" xml:space="preserve">
          <source>The next step is to pop savestack entries: &lt;code&gt;CX_LEAVE_SCOPE(cx)&lt;/code&gt; is just defined as &lt;code&gt;LEAVE_SCOPE(cx-&amp;gt;blk_oldsaveix)&lt;/code&gt;. Note that during the popping, it's possible for perl to call destructors, call &lt;code&gt;STORE&lt;/code&gt; to undo localisations of tied vars, and so on. Any of these can die or call &lt;code&gt;exit()&lt;/code&gt;. In this case, &lt;code&gt;dounwind()&lt;/code&gt; will be called, and the current context stack frame will be re-processed. Thus it is vital that all steps in popping a context are done in such a way to support reentrancy. The other alternative, of decrementing &lt;code&gt;cxstack_ix&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d612978700e6928f957643eba3d0d61622b6ed" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system via email.</source>
          <target state="translated">下一步是通过电子邮件向Perl核心票务系统提交你的补丁。</target>
        </trans-unit>
        <trans-unit id="c53212a853da747bb753ac0eb206bd02a60002ca" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a6f456a2c90d50e2abfb7f37ee6f9a4299445f" translate="yes" xml:space="preserve">
          <source>The next task is to break the problem down into smaller problems that are easily converted into a regexp.</source>
          <target state="translated">接下来的任务是将问题分解成容易转换为regexp的小问题。</target>
        </trans-unit>
        <trans-unit id="c9e21bae9fb5eef63978dcfa71c7a0d3cb21ec24" translate="yes" xml:space="preserve">
          <source>The next time you wish to make a patch, you need to start from the latest perl in a pristine state. Check you don't have any local changes or added files in your perl check-out which you wish to keep, then run these commands:</source>
          <target state="translated">下一次你想打补丁的时候,你需要从最新的perl原始状态开始。检查你的 perl check-out 中没有任何你希望保留的本地修改或添加的文件,然后运行这些命令。</target>
        </trans-unit>
        <trans-unit id="79f58ceb3f799f52310d0fb9160eed5d3d3eaba7" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is it's like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="translated">todo测试的好处是,相对于简单地注释出一个测试块,它就像拥有一个程序化的todo列表。你知道还有多少工作要做,你知道有哪些错误,而且你会立即知道它们何时被修复。</target>
        </trans-unit>
        <trans-unit id="93f6c477375802df02f9578f889b424f60ac9928" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is that it is like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92737be37077b1e4ee6685cd7da7d12b0a775c27" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C requires that certain things be set up in the console before Visual C will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run the &lt;code&gt;vcvars32.bat&lt;/code&gt; file to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; or &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; . On a typical install of a Microsoft C compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files\Microsoft Visual Studio\VC98\Bin. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="translated">Visual C ++附带的nmake足以满足构建要求。 Visual C要求成功运行Visual C之前，必须在控制台中进行某些设置。要使控制台能够运行C编译器，您需要事先运行 &lt;code&gt;vcvars32.bat&lt;/code&gt; 文件以针对x86-32和x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; 或 &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; 进行编译。在典型安装的Microsoft C编译器产品上，这些批处理文件将已经在 &lt;code&gt;PATH&lt;/code&gt; 中环境变量，因此您可以在控制台中输入它们而无需绝对路径。如果您需要找到批处理文件的绝对路径，通常可以在C：\ Program Files \ Microsoft Visual Studio \ VC98 \ Bin之类的位置找到它。对于某些较新的Micrsoft C产品（〜2004年以后发行），安装程序将在开始菜单中放置一个快捷方式，以启动新的控制台窗口，并已为目标体系结构设置了控制台（x86-32或x86-64或IA64）。 。对于较新的编译器，您可以选择使用较旧的批处理文件。</target>
        </trans-unit>
        <trans-unit id="74b0871cc8ecf5b8ec07f0886c93ea7f99f29900" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C++ requires that certain things be set up in the console before Visual C++ will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run &lt;code&gt;vcvarsall.bat x86&lt;/code&gt; to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat amd64&lt;/code&gt;. On a typical install of a Microsoft C++ compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d92d9609b16a9236c6b0750e878097cebaf141fa" translate="yes" xml:space="preserve">
          <source>The nmake that comes with the Platform SDK will suffice for building Perl. Make sure you are building within one of the &quot;Build Environment&quot; shells available after you install the Platform SDK from the Start Menu.</source>
          <target state="translated">平台SDK自带的nmake就可以满足构建Perl的需要。确保你是在从开始菜单安装Platform SDK后,在 &quot;Build Environment &quot;shell中进行编译。</target>
        </trans-unit>
        <trans-unit id="4cf437af831d898cd280f5f9fa16e3b19f38db9a" translate="yes" xml:space="preserve">
          <source>The node type, either &lt;code&gt;section&lt;/code&gt; or &lt;code&gt;item&lt;/code&gt; . As an unofficial type, there is also &lt;code&gt;hyperlink&lt;/code&gt; , derived from e.g. &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">节点类型，可以是 &lt;code&gt;section&lt;/code&gt; 或 &lt;code&gt;item&lt;/code&gt; 。作为非官方类型，还存在 &lt;code&gt;hyperlink&lt;/code&gt; ，例如从 &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; &lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt; &amp;gt;派生而来。</target>
        </trans-unit>
        <trans-unit id="9d0e0bd31f6a31a67e6263a3a5396fe920511c99" translate="yes" xml:space="preserve">
          <source>The non-ASCII characters below 256 can have various meanings, depending on various things. (See, most notably, &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) But usually the whole range can be referred to as ISO-8859-1. Often, the term &quot;Latin-1&quot; (or &quot;Latin1&quot;) is used as an equivalent for ISO-8859-1. But some people treat &quot;Latin1&quot; as referring just to the characters in the range 128 through 255, or somethimes from 160 through 255. This documentation uses &quot;Latin1&quot; and &quot;Latin-1&quot; to refer to all 256 characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6361a2e3097d12a5b1db2175b6f9b22e2b4e005e" translate="yes" xml:space="preserve">
          <source>The non-blocking behaviour is an extension of the &lt;code&gt;IO::Socket::INET&lt;/code&gt; API, unique to &lt;code&gt;IO::Socket::IP&lt;/code&gt;, because the former does not support multi-homed non-blocking connect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8827c5b69a11959983a358ee79f064e14c978f0c" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt; ):</source>
          <target state="translated">非破坏性修饰符 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 导致返回替换结果，而不是修改 &lt;code&gt;$_&lt;/code&gt; （或使用 &lt;code&gt;=~&lt;/code&gt; 绑定到替换变量的任何变量）：</target>
        </trans-unit>
        <trans-unit id="33ea7bc6a1364954efde1784eb70e926a46ab789" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;s///r&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e24c19053882dd3539c4f0f017c48b302d8630" translate="yes" xml:space="preserve">
          <source>The non-zero numeric</source>
          <target state="translated">非零数字</target>
        </trans-unit>
        <trans-unit id="ed0d308e2d36922ca367c5db784707665a50eda8" translate="yes" xml:space="preserve">
          <source>The normal Makefile.PL that h2xs generates doesn't know about the mylib directory. We need to tell it that there is a subdirectory and that we will be generating a library in it. Let's add the argument MYEXTLIB to the WriteMakefile call so that it looks like this:</source>
          <target state="translated">h2xs生成的普通Makefile.PL不知道mylib目录。我们需要告诉它有一个子目录,并且我们将在其中生成一个库。让我们在WriteMakefile调用中添加参数MYEXTLIB,这样它看起来就像这样。</target>
        </trans-unit>
        <trans-unit id="b1469f4963ec233a67445e77b1dc5adf4ccf9ab7" translate="yes" xml:space="preserve">
          <source>The normal course of action is to call:</source>
          <target state="translated">正常的做法是打电话。</target>
        </trans-unit>
        <trans-unit id="32723b8237682738b9e39db42e26b25a535a8b05" translate="yes" xml:space="preserve">
          <source>The normal return provided by &lt;code&gt;scalar(%hash)&lt;/code&gt; is not available. What this means is that using %tied_hash in boolean context doesn't work right (currently this always tests false, regardless of whether the hash is empty or hash elements). [ This paragraph needs review in light of changes in 5.25 ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf683f52c0f42f564cf7e0ed381f4bb97cc8438" translate="yes" xml:space="preserve">
          <source>The normal use of this class is like so:</source>
          <target state="translated">这个类的正常使用是这样的。</target>
        </trans-unit>
        <trans-unit id="1ac2010e9cf7828bd4211d3176636428b6a9a255" translate="yes" xml:space="preserve">
          <source>The normal way to run a Perl program is by making it directly executable, or else by passing the name of the source file as an argument on the command line. (An interactive Perl environment is also possible--see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; for details on how to do that.) Upon startup, Perl looks for your program in one of the following places:</source>
          <target state="translated">运行Perl程序的通常方法是使其直接可执行，或者通过在命令行上传递源文件的名称作为参数。（也可以使用交互式Perl环境- 有关如何执行此&lt;a href=&quot;perldebug&quot;&gt;操作&lt;/a&gt;的详细信息，请参见perldebug。）启动后，Perl在以下位置之一查找程序：</target>
        </trans-unit>
        <trans-unit id="42b613b12f582e26d7e800d066ea1eb52e714a90" translate="yes" xml:space="preserve">
          <source>The not-a-number as a constant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46672cb58512b6dfcf1bfa852b6fb1012267b6a3" translate="yes" xml:space="preserve">
          <source>The notation still looks a little cumbersome, so there's one more abbreviation:</source>
          <target state="translated">符号还是显得有些繁琐,所以多了一个缩写。</target>
        </trans-unit>
        <trans-unit id="faf2109c5b26dde1813deee78331f15408acfe4a" translate="yes" xml:space="preserve">
          <source>The notion that an empty &lt;b&gt;derived class&lt;/b&gt; should behave exactly like its &lt;b&gt;base class&lt;/b&gt;.</source>
          <target state="translated">空&lt;b&gt;派生类的&lt;/b&gt;行为应与其&lt;b&gt;基类&lt;/b&gt;完全相同的概念。</target>
        </trans-unit>
        <trans-unit id="d26e84b13c8c8748080fe4085da63e6e9ef520f9" translate="yes" xml:space="preserve">
          <source>The notion that you can tell an &lt;b&gt;object&lt;/b&gt; to do something generic, and the object will interpret the command in different ways depending on its type. [&amp;lt; Greek &amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, many forms.]</source>
          <target state="translated">您可以告诉&lt;b&gt;对象&lt;/b&gt;执行通用操作的概念，并且对象将根据其类型以不同的方式解释命令。[&amp;lt;希腊语&amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;-+ &amp;mu;&amp;omicron;&amp;rho;ϕή，有多种形式。]</target>
        </trans-unit>
        <trans-unit id="ad272f88bed19c2e6cec366907b96e0baf112d7c" translate="yes" xml:space="preserve">
          <source>The notion that, with a complete set of simple tools that work well together, you can build almost anything you want. Which is fine if you&amp;rsquo;re assembling a tricycle, but if you&amp;rsquo;re building a defranishizing comboflux regurgalator, you really want your own machine shop in which to build special tools. Perl is sort of a machine shop.</source>
          <target state="translated">有了一套完整的简单工具，它们可以很好地协同工作，您可以构建几乎任何想要的东西。如果您要组装三轮车，那很好，但是如果您要制造脱色的康菲斯回流调节器，那么您真的希望自己的机械车间可以制造特殊的工具。Perl就像是一家机械厂。</target>
        </trans-unit>
        <trans-unit id="d8cd6888cbc4c56537079a3ca6af05881fde2aca" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt; , which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="translated">空文件句柄 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 是特殊的：它可用于模拟&lt;b&gt;sed&lt;/b&gt;和&lt;b&gt;awk&lt;/b&gt;以及其他任何使用文件名列表的Unix过滤器程序的行为，对所有文件名的每一行都执行相同的操作。来自 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 的输入或者来自标准输入，或者来自命令行上列出的每个文件。它是这样工作的：第一次计算 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 时，将检查 &lt;code&gt;@ARGV&lt;/code&gt; 数组，如果它为空，则 &lt;code&gt;$ARGV[0]&lt;/code&gt; 设置为 &lt;code&gt;&quot;-&quot;&lt;/code&gt; ，当打开时会为您提供标准输入。然后，将 &lt;code&gt;@ARGV&lt;/code&gt; 数组作为文件名列表进行处理。循环</target>
        </trans-unit>
        <trans-unit id="2eb5648c665e9498b1d4e1c662b451796e069c6c" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt;, which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d22af8d2b7cf7cf2c570f3f335ab2a750c99b68" translate="yes" xml:space="preserve">
          <source>The null list is represented by (). Interpolating it in a list has no effect. Thus ((),(),()) is equivalent to (). Similarly, interpolating an array with no elements is the same as if no array had been interpolated at that point.</source>
          <target state="translated">空列表用()表示。在列表中对其进行插值,没有效果。因此((),(),())相当于()。同理,对一个没有元素的数组进行插值,与此时没有数组插值是一样的。</target>
        </trans-unit>
        <trans-unit id="1797c45a73a5a87e1dcbfe3ceafa93cc5c4f9d01" translate="yes" xml:space="preserve">
          <source>The null loop times can be cached, the key being the number of rounds. The caching can be controlled using calls like these:</source>
          <target state="translated">可以缓存空循环时间,关键是轮数。缓存可以使用这样的调用来控制。</target>
        </trans-unit>
        <trans-unit id="c43d1fda274f03a112b4082e8056292b9c40d862" translate="yes" xml:space="preserve">
          <source>The number 0, the strings &lt;code&gt;'0'&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , the empty list &lt;code&gt;()&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; are all false in a boolean context. All other values are true. Negation of a true value by &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; returns a special false value. When evaluated as a string it is treated as &lt;code&gt;&quot;&quot;&lt;/code&gt; , but as a number, it is treated as 0. Most Perl operators that return true or false behave this way.</source>
          <target state="translated">在布尔上下文中，数字0，字符串 &lt;code&gt;'0'&lt;/code&gt; 和 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，空列表 &lt;code&gt;()&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 均为false。所有其他值都是正确的。否定真值 &lt;code&gt;!&lt;/code&gt; 或 &lt;code&gt;not&lt;/code&gt; 返回特殊的false值。以字符串形式求值时，将其视为 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，而将其视为数字，则将其视为0。大多数返回true或false的Perl运算符都将以这种方式运行。</target>
        </trans-unit>
        <trans-unit id="692f2a5740e6be2f2f4c50b1195b7318b218c93b" translate="yes" xml:space="preserve">
          <source>The number after Perl (i.e. the 5 after Perl 5) is the major release of the perl interpreter as well as the version of the language. Each major version has significant differences that earlier versions cannot support.</source>
          <target state="translated">Perl后面的数字(即Perl 5后面的5)是perl解释器的主要版本以及语言的版本。每一个主要版本都有早期版本无法支持的重大差异。</target>
        </trans-unit>
        <trans-unit id="3191b134cb3717b47b8c71b05a1d940752bad987" translate="yes" xml:space="preserve">
          <source>The number for the &quot;generation&quot; of the test run. The first generation is 1 (one) and subsequent generations are 2, 3, etc.</source>
          <target state="translated">测试运行的 &quot;代数&quot;。第一代为1(1),以后的代数为2、3等。</target>
        </trans-unit>
        <trans-unit id="2535d279c5200f7be07d31d15ce44068cdb20ffd" translate="yes" xml:space="preserve">
          <source>The number of &quot;hidden&quot; sectors for this partition. Actually this is the number of sectors found prior to this partition, that is, the starting offset [as found in &lt;code&gt;$uStartLow&lt;/code&gt; and &lt;code&gt;$ivStartHigh&lt;/code&gt;] divided by the number of bytes per sector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a9d7413ce0d5ac2d4144491992bf44868224aa" translate="yes" xml:space="preserve">
          <source>The number of bytes in each sector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa99ba7fda4b251af40087fa9ad0d33252bbd195" translate="yes" xml:space="preserve">
          <source>The number of concurrent jobs this formatter will handle.</source>
          <target state="translated">该表格器将处理的并发作业数量。</target>
        </trans-unit>
        <trans-unit id="36ffefa76cdb58a51fa74dc31caa513844b361e2" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after &lt;code&gt;av_fill()&lt;/code&gt; returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2ba45a48d3868e33de1ec7e956df019e81e42a" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after av_fill() returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt; .</source>
          <target state="translated">av_fill（）返回后，数组中的元素数将为 &lt;code&gt;fill + 1&lt;/code&gt; 。如果数组以前较短，则附加的其他元素将设置为NULL。如果数组较长，则释放多余的元素。 &lt;code&gt;av_fill(av, -1)&lt;/code&gt; 与 &lt;code&gt;av_clear(av)&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b9161f7d8230483ece3123e0d04957cb7a945f72" translate="yes" xml:space="preserve">
          <source>The number of items in a hash can be obtained by doing:</source>
          <target state="translated">可以通过做获得哈希中的项目数。</target>
        </trans-unit>
        <trans-unit id="e4c9a33204f057eb951c01e0df7449caf0e7389f" translate="yes" xml:space="preserve">
          <source>The number of lines left on the page of the currently selected output channel.</source>
          <target state="translated">当前选择的输出通道的页面剩余行数。</target>
        </trans-unit>
        <trans-unit id="8b661ef45c3e83256fc7a63d23f91b2343af29ac" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt; . The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) variable. Many error messages report both values, if available.</source>
          <target state="translated">在此之前读取的行数加1。Perl为打开的每个源文件或输入文件保留一个单独的行号。当前源文件的行号由 &lt;code&gt;__LINE__&lt;/code&gt; 表示。当前输入行号（对于最近通过 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; 读取的文件）用 &lt;code&gt;$.&lt;/code&gt; 表示。（ &lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ）变量。许多错误消息报告两个值（如果有）。</target>
        </trans-unit>
        <trans-unit id="2c32dc65a0983301d8b932b2ff7d13fbe8041de2" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt;. The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt;) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt;) variable. Many error messages report both values, if available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c26ea7021e22061094b1160120712623c26587e" translate="yes" xml:space="preserve">
          <source>The number of retrieval pointers that RMS has to maintain (0 to 127255)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7adfc7b3eafb7c58d678ada0cc8dfa22b0798638" translate="yes" xml:space="preserve">
          <source>The number of seconds the program ran for before being terminated, or 0 if no timeout occurred.</source>
          <target state="translated">终止前程序运行的秒数,如果没有超时,则为0。</target>
        </trans-unit>
        <trans-unit id="3f0ee453c0514a141454bf624811de74f7121fbc" translate="yes" xml:space="preserve">
          <source>The number of sectors in each track.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701c3dee8ddb529dd17cdf0b20bfe4db85c06698" translate="yes" xml:space="preserve">
          <source>The number of spaces to indent regular text, and the default indentation for &lt;code&gt;=over&lt;/code&gt; blocks. Defaults to 4.</source>
          <target state="translated">要缩进常规文本的空格数，以及 &lt;code&gt;=over&lt;/code&gt; 块的默认缩进。默认为4。</target>
        </trans-unit>
        <trans-unit id="e68baf88a8ecb32bf1315047769f8d0e186bb5f6" translate="yes" xml:space="preserve">
          <source>The number of tests actually seen</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65eb3487d858db8bd02f6c81679897d6d005441b" translate="yes" xml:space="preserve">
          <source>The number of tests in your script. This means all ok() and skip() calls.</source>
          <target state="translated">脚本中的测试次数。这意味着所有的ok()和skip()调用。</target>
        </trans-unit>
        <trans-unit id="7a3c79429902da3d2d3d81b8c529fe97388165ba" translate="yes" xml:space="preserve">
          <source>The number of tests that were planned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e2b7e50e91d743cd4a7b27aa45939dc1c6581f" translate="yes" xml:space="preserve">
          <source>The number of tests which failed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e318858e274a3b2d56e4e8546a3453a590b339" translate="yes" xml:space="preserve">
          <source>The number of tests with TODO directives.</source>
          <target state="translated">有TODO指令的测试数量。</target>
        </trans-unit>
        <trans-unit id="134bbf3c12ccdb3b17c2429c883dacdca5457a57" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;&quot;comp&quot;&lt;/a&gt; routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43b06bec0238ed7c22fd0d6e38144c2bb8f0d70" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; routine.</source>
          <target state="translated">引用结构的次数。当它降至0时，通过调用pregfree自动释放regexp。在每个引擎的&lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt;例程中应将其设置为1 。</target>
        </trans-unit>
        <trans-unit id="c7aa069edb979af7f298ec7da8f6245a682e62f6" translate="yes" xml:space="preserve">
          <source>The number of times the test has failed.</source>
          <target state="translated">测试失败的次数。</target>
        </trans-unit>
        <trans-unit id="f294a946b3a2f3d15985548e48a89b85b334300e" translate="yes" xml:space="preserve">
          <source>The number of times the test has passed.</source>
          <target state="translated">测试通过的次数。</target>
        </trans-unit>
        <trans-unit id="1ea0b9d7d53aa08d0e622974bcb543d8e9e34567" translate="yes" xml:space="preserve">
          <source>The number of tracks in each cylinder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ecf3312d862847aadfe59c31f3bcfa85cc3016b" translate="yes" xml:space="preserve">
          <source>The numbering within each branch will be as normal, and any groups following this construct will be numbered as though the construct contained only one branch, that being the one with the most capture groups in it.</source>
          <target state="translated">每个分支内的编号将与正常情况一样,该构造后的任何组将被编号,就好像该构造只包含一个分支,即其中有最多捕获组的那个分支。</target>
        </trans-unit>
        <trans-unit id="d3f5b7856c836d8ae15bae5d2911f695737356ba" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigFloat. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">数字以对象的形式存储,其内部可能随时发生变化,特别是在数学运算之间。这些对象也可能属于不同的类,比如Math::BigInt,或者Math::BigFloat。将它们混合在一起,即使是普通的标量,也不是什么特别的事情,而是正常的,也是意料之中的事情。</target>
        </trans-unit>
        <trans-unit id="0d52076285e4f235f1d8532711b46d3578467720" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigInt::Lite. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">数字以对象的形式存储,其内部可能随时发生变化,特别是在数学运算之间。这些对象也可能属于不同的类,比如Math::BigInt,或者Math::BigInt::Lite。将它们混合在一起,即使是普通的标量,也不是什么特别的事情,而是正常的,也是意料之中的事情。</target>
        </trans-unit>
        <trans-unit id="d62316f7524c3cde4e634f1fd21e7ac49fd46233" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to 0777), to be modified by the current &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="translated">应用于每个已创建目录的数字权限模式（默认为0777），由当前 &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 修改。如果目录已经存在（因此不需要创建），则不会修改权限。</target>
        </trans-unit>
        <trans-unit id="5dffd7d41fb958bc0c87e558861a514e1606e35f" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to &lt;code&gt;0777&lt;/code&gt;), to be modified by the current &lt;code&gt;umask&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e019f9571f72909dc6712d8ba72dd87f1a9db6" translate="yes" xml:space="preserve">
          <source>The numeric value of the COP's hint flags, or an empty string if this is not a COP.</source>
          <target state="translated">COP的提示标志的数值,如果不是COP,则为空字符串。</target>
        </trans-unit>
        <trans-unit id="419fea734cd75b36bfd625f906eafadf3594cbdf" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's flags.</source>
          <target state="translated">OP标志的数值。</target>
        </trans-unit>
        <trans-unit id="e13f8ed0a121e4b7f2050aa9d7bd9bd36bdb9772" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's private flags.</source>
          <target state="translated">OP的私有标志的数值。</target>
        </trans-unit>
        <trans-unit id="afdb5b0bce9be5274063464faba90d66849c8cbe" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's targ.</source>
          <target state="translated">上文中的targ的数值。</target>
        </trans-unit>
        <trans-unit id="e4bd78ffa7c276231e5c09572ec79b0007d54b06" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's type, in decimal.</source>
          <target state="translated">OP类型的数值,以十进制表示。</target>
        </trans-unit>
        <trans-unit id="38a4063b54e70e2579ef41b45391d9edbcb80e9f" translate="yes" xml:space="preserve">
          <source>The object actually used is of the class &lt;a href=&quot;ExtUtils::MY&quot;&gt;MY&lt;/a&gt; which allows you to override bits of MakeMaker inside your Makefile.PL by declaring MY::foo() methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a6a6fda3b81e72660dadfe40e0c6cbbf8b62d9b" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">该对象被重新赋予 &lt;code&gt;IO::Handle&lt;/code&gt; 的子类，并成为管道读取端的句柄。如果给出了 &lt;code&gt;ARGS&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ，并将 &lt;code&gt;ARGS&lt;/code&gt; 传递给exec。</target>
        </trans-unit>
        <trans-unit id="7b25df29627971e66202a04141c07ea01261d426" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">该对象被重新赋予 &lt;code&gt;IO::Handle&lt;/code&gt; 的子类，并成为管道写入端的句柄。如果给出了 &lt;code&gt;ARGS&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ，并将 &lt;code&gt;ARGS&lt;/code&gt; 传递给exec。</target>
        </trans-unit>
        <trans-unit id="fc8e459a67162585ed649c073732c1f153656661" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt;, and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;fork&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960d4697beb3f7754f165a72fa86b9e206ef71bf" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt;, and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;fork&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e63c161da60788dfbf25012eced379198e6461" translate="yes" xml:space="preserve">
          <source>The object or class on which a method is called is passed as one of the method's arguments, not as a separate &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="translated">调用方法的对象或类作为方法的参数之一传递，而不是作为单独的 &lt;code&gt;this&lt;/code&gt; 值传递。</target>
        </trans-unit>
        <trans-unit id="ac2428a9234f597f267cadbd7f0f16da4708e348" translate="yes" xml:space="preserve">
          <source>The object oriented interface lets you configure your own encoding or decoding style, within the limits of supported formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b98c3fd23a1ef70ae8197a79094d62be1e4c5c" translate="yes" xml:space="preserve">
          <source>The object oriented interface to &lt;code&gt;Digest::MD5&lt;/code&gt; is described in this section. After a &lt;code&gt;Digest::MD5&lt;/code&gt; object has been created, you will add data to it and finally ask for the digest in a suitable format. A single object can be used to calculate multiple digests.</source>
          <target state="translated">本节介绍了 &lt;code&gt;Digest::MD5&lt;/code&gt; 面向对象的接口。一个经过 &lt;code&gt;Digest::MD5&lt;/code&gt; 对象已经创建，您将数据添加到它，最后以合适的格式要求的摘要。单个对象可用于计算多个摘要。</target>
        </trans-unit>
        <trans-unit id="e33be9a872157d87d04d9ab372ad71b851a50cce" translate="yes" xml:space="preserve">
          <source>The object registry is also used to repair a field hash after thread cloning. Here, the entire object registry is processed. For every reference found there, the field hashes it has used are visited and the entry is updated.</source>
          <target state="translated">对象注册表也是用来修复线程克隆后的字段哈希。在这里,整个对象注册表都会被处理。对于在那里发现的每一个引用,都会访问它所使用的字段哈希,并更新条目。</target>
        </trans-unit>
        <trans-unit id="90c880f65630ae33e5e929b9f5badc61ea20d016" translate="yes" xml:space="preserve">
          <source>The object registry keeps track of references that have been used as field hash keys. The keys are generated from the reference address like in a field hash (though the registry isn't a field hash). Each value is a weak copy of the original reference, stored in an &lt;code&gt;SV&lt;/code&gt; that is itself magical (&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; again). The magical structure holds a list (another hash, really) of field hashes that the reference has been used with. When the weakref becomes stale, the magic is activated and uses the list to delete the reference from all field hashes it has been used with. After that, the entry is removed from the object registry itself. Implicitly, that frees the magic structure and the storage it has been using.</source>
          <target state="translated">对象注册表跟踪已用作字段哈希键的引用。键是从参考地址生成的，就像在字段哈希中一样（尽管注册表不是字段哈希）。每个值都是原始参考的弱副本，存储在本身就是魔术的 &lt;code&gt;SV&lt;/code&gt; 中（再次是 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; ）。神奇的结构保存了与引用一起使用的字段哈希的列表（实际上是另一个哈希）。当weakref变得陈旧时，魔术会被激活并使用该列表从与之一起使用的所有字段散列中删除引用。之后，该条目将从对象注册表本身中删除。隐式地，这释放了魔术结构及其一直在使用的存储空间。</target>
        </trans-unit>
        <trans-unit id="d72391ab64988da73b0a894ff996ef426650aa27" translate="yes" xml:space="preserve">
          <source>The object returned by &lt;code&gt;builder()&lt;/code&gt; may change at runtime so you should call &lt;code&gt;builder()&lt;/code&gt; inside each function rather than store it in a global.</source>
          <target state="translated">&lt;code&gt;builder()&lt;/code&gt; 返回的对象可能会在运行时更改，因此您应该在每个函数内调用 &lt;code&gt;builder()&lt;/code&gt; 而不是将其存储在全局函数中。</target>
        </trans-unit>
        <trans-unit id="0c2931896c0ae38a7dcf1ceb36dc3228043fb889" translate="yes" xml:space="preserve">
          <source>The object will be serialised as a JSON null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce4a435aaab3b8ce3beeeab8876d2f9007b9517" translate="yes" xml:space="preserve">
          <source>The object will be serialised as a JSON number value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afec221431749f399e52c9677871688987dfbb46" translate="yes" xml:space="preserve">
          <source>The oct() function is commonly used when a string such as &lt;code&gt;644&lt;/code&gt; needs to be converted into a file mode, for example. Although Perl automatically converts strings into numbers as needed, this automatic conversion assumes base 10.</source>
          <target state="translated">例如，当需要将诸如 &lt;code&gt;644&lt;/code&gt; 之类的字符串转换为文件模式时，通常使用oct（）函数。尽管Perl会根据需要自动将字符串转换为数字，但是此自动转换假定以10为底。</target>
        </trans-unit>
        <trans-unit id="09c9c348da6207c41e75d17f6b539e26d9c4cd1f" translate="yes" xml:space="preserve">
          <source>The official (threaded) builds from HP, as they are shipped on the Application DVD/CD's are available on &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt; for both PA-RISC and IPF (Itanium Processor Family). They are built with the HP ANSI-C compiler. Up till 5.8.8 that was done by ActiveState.</source>
          <target state="translated">对于HP 和PA-RISC ，官方的（线程化的）构建都来自应用DVD / CD上的出厂版本，可从&lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt;获得。和IPF（Itanium处理器系列）。它们是使用HP ANSI-C编译器构建的。直到5.8.8由ActiveState完成。</target>
        </trans-unit>
        <trans-unit id="94afd3df7a7936cd7021df875b7cc881f99b3a21" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at GitHub. Posting to the list and the bugtracker is not a right: all participants in discussion are expected to adhere to a standard of conduct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="122c2a7e4876853c52ff4c6bbc23491cac5b2166" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at rt.perl.org. All participants in discussion there are expected to adhere to a standard of conduct.</source>
          <target state="translated">开发perl的官方论坛是上面提到的perl5-porters邮件列表,以及它的bug跟踪器rt.perl.org。所有参与讨论的人都应该遵守行为标准。</target>
        </trans-unit>
        <trans-unit id="206093c38ad914ff8435f60fe865bef14dbff945" translate="yes" xml:space="preserve">
          <source>The official home of this project on the web.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318a2a25e89f6df5d0fee0930895c69196eba39a" translate="yes" xml:space="preserve">
          <source>The official name of VMS as of this writing is OpenVMS.</source>
          <target state="translated">截至目前,VMS的正式名称是OpenVMS。</target>
        </trans-unit>
        <trans-unit id="9e04119b1083995ffa8b809847e51388388f1606" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is</source>
          <target state="translated">Berkeley DB的官方网站是</target>
        </trans-unit>
        <trans-unit id="9ae89a7a7356b47202ed85668f00ace437b2ed69" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is &lt;a href=&quot;http://www.oracle.com/technology/products/berkeley-db/db/index.html&quot;&gt;http://www.oracle.com/technology/products/berkeley-db/db/index.html&lt;/a&gt;. All versions of Berkeley DB are available there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b569f6bcadd4a6fd7badb484a162b25dd85b5b2" translate="yes" xml:space="preserve">
          <source>The offset from the start of the file in hex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ba5881483f263a1268bc8d8cd7d41b8c76ce28" translate="yes" xml:space="preserve">
          <source>The old behavior is currently retained, warts and all, for backwards compatibility, but users are encouraged to change any code that tests &lt;code&gt;$!&lt;/code&gt; against &lt;code&gt;E*&lt;/code&gt; constants for Winsock errors to instead test &lt;code&gt;$^E&lt;/code&gt; against &lt;code&gt;WSAE*&lt;/code&gt; constants. After a suitable deprecation period, which started with Perl 5.24, the old behavior may be removed, leaving &lt;code&gt;$!&lt;/code&gt; unchanged after Winsock function calls, to avoid any possible confusion over which error variable to check.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
