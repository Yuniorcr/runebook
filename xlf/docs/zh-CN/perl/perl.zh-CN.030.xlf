<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="cdfcc78500cdaa84a66edd629ca6a9d6469e030b" translate="yes" xml:space="preserve">
          <source>It returns two strings: the first one, &lt;code&gt;$processed&lt;/code&gt; , is a part before the last starter, and the second one, &lt;code&gt;$unprocessed&lt;/code&gt; is another part after the first part. A starter is a character having a combining class of zero (see UAX #15).</source>
          <target state="translated">它返回两个字符串：第一个字符串 &lt;code&gt;$processed&lt;/code&gt; 是最后一个启动器之前的一部分，第二个字符串 &lt;code&gt;$unprocessed&lt;/code&gt; 是第一个部分之后的另一部分。起动器是一个组合类别为零的字符（请参阅UAX＃15）。</target>
        </trans-unit>
        <trans-unit id="e7d95a08ad814a7f6c58669c1b1316d305c90d5a" translate="yes" xml:space="preserve">
          <source>It sets up a class &lt;code&gt;Name&lt;/code&gt; that is a mirror of one of the implementation classes &lt;code&gt;Name_hash&lt;/code&gt; , &lt;code&gt;Name_id&lt;/code&gt; , ..., &lt;code&gt;Name_fieldhash&lt;/code&gt; . That determines which implementation is run.</source>
          <target state="translated">它设置了一个 &lt;code&gt;Name&lt;/code&gt; 类，它是实现类 &lt;code&gt;Name_hash&lt;/code&gt; ， &lt;code&gt;Name_id&lt;/code&gt; ，...， &lt;code&gt;Name_fieldhash&lt;/code&gt; 之一的镜像。那确定运行哪个实现。</target>
        </trans-unit>
        <trans-unit id="cb3f907f4536c2412455577e73bc09c598212b95" translate="yes" xml:space="preserve">
          <source>It should be noted that because of the double indirection in a &lt;code&gt;PerlIO *&lt;/code&gt; , a &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &quot;is&quot; a &lt;code&gt;PerlIO *&lt;/code&gt; , and so to some degree at least one layer can use the &quot;standard&quot; API on the next layer down.</source>
          <target state="translated">应该注意的是，由于 &lt;code&gt;PerlIO *&lt;/code&gt; 中的双重间接访问， &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &amp;ldquo;是&amp;rdquo; &lt;code&gt;PerlIO *&lt;/code&gt; ，因此在某种程度上至少一层可以在下一层使用&amp;ldquo;标准&amp;rdquo; API下。</target>
        </trans-unit>
        <trans-unit id="b14a8d613d8259f6f9199d94a881c7c7dcdcf9aa" translate="yes" xml:space="preserve">
          <source>It should be noted that the</source>
          <target state="translated">应该指出的是</target>
        </trans-unit>
        <trans-unit id="a59ebc15941a0d3262901c5719fbfc123fcebf0b" translate="yes" xml:space="preserve">
          <source>It splits the task of generating the Makefile into several subroutines that can be individually overridden. Each subroutine returns the text it wishes to have written to the Makefile.</source>
          <target state="translated">它将生成 Makefile 的任务分割成几个可以单独重写的子程序。每个子程序都返回它希望写入 Makefile 的文本。</target>
        </trans-unit>
        <trans-unit id="82c9f4b13f690f80567f90ba2a27e3429f909ad9" translate="yes" xml:space="preserve">
          <source>It starts like a perl module with a package declaration and a $VERSION variable. After that the pod section looks like any other pod with the only difference being that</source>
          <target state="translated">它的开始就像一个perl模块,有一个包声明和一个$VERSION变量。之后,pod部分看起来就像其他pod一样,唯一的区别就是</target>
        </trans-unit>
        <trans-unit id="20eae6f6b825ab7ac7ea22eebe86fa7977d3df1a" translate="yes" xml:space="preserve">
          <source>It supports the following options, which are explained in &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt;: alt, indent, loose, quotes, sentence, width</source>
          <target state="translated">它支持以下选项，在&lt;a href=&quot;../text&quot;&gt;Pod :: Text中&lt;/a&gt;进行了说明：alt，缩进，松散，引号，句子，宽度</target>
        </trans-unit>
        <trans-unit id="41aba7727d2b065747551c63f609a3ed9ed9ee45" translate="yes" xml:space="preserve">
          <source>It suppresses duplicates in the column &lt;code&gt;in CPAN file&lt;/code&gt; such that distributions with many upgradeable modules are listed only once.</source>
          <target state="translated">它抑制 &lt;code&gt;in CPAN file&lt;/code&gt; 列中的重复项，因此具有许多可升级模块的发行版仅列出一次。</target>
        </trans-unit>
        <trans-unit id="65a26945a658df9dae641582923dd3754dc6d274" translate="yes" xml:space="preserve">
          <source>It takes a hash reference as an argument with two optional keys:</source>
          <target state="translated">它以一个哈希引用作为参数,并带有两个可选的键。</target>
        </trans-unit>
        <trans-unit id="8e1dcd4bfabeba9ef57034858eb07de6c007a236" translate="yes" xml:space="preserve">
          <source>It takes three arguments:</source>
          <target state="translated">它需要三个论点。</target>
        </trans-unit>
        <trans-unit id="a46a1b8abd0b80e91377ad517ddde11f2ad6f67d" translate="yes" xml:space="preserve">
          <source>It tells where the old configuration file was found (if found).</source>
          <target state="translated">它告诉我们旧配置文件的位置(如果找到的话)。</target>
        </trans-unit>
        <trans-unit id="316a78b3112e7d60b8f4b8e53c96f0951d499e19" translate="yes" xml:space="preserve">
          <source>It turns out that you can actually do this also:</source>
          <target state="translated">原来,你其实也可以这样做。</target>
        </trans-unit>
        <trans-unit id="143c187acc40c6e4dc672359c95beead999d8959" translate="yes" xml:space="preserve">
          <source>It uses these values to set the extended timestamp field (ID is &quot;UT&quot;) in the local zip header using the three values, $atime, $mtime, $ctime. In addition it sets the extended timestamp field in the central zip header using &lt;code&gt;$mtime&lt;/code&gt; .</source>
          <target state="translated">它使用这些值使用$ atime，$ mtime，$ ctime这三个值在本地zip标头中设置扩展时间戳字段（ID为&amp;ldquo; UT&amp;rdquo;）。此外，它使用 &lt;code&gt;$mtime&lt;/code&gt; 在中央zip标头中设置扩展时间戳字段。</target>
        </trans-unit>
        <trans-unit id="f6d084cee81998d6ff3982adc3ae633d6de17437" translate="yes" xml:space="preserve">
          <source>It was easy to write by having it call the Unix cat(1) command, but it would probably be more portable to open the file manually (and somewhat more efficient). Of course, because dot files are a Unixy concept, we're not that concerned.</source>
          <target state="translated">让它调用Unix的cat(1)命令,写起来很容易,但如果手动打开文件,可能会更方便(效率更高一些)。当然,因为点阵文件是Unixy的概念,所以我们并不是很在意。</target>
        </trans-unit>
        <trans-unit id="c142dca333e2894efe138704aae3906df8914b33" translate="yes" xml:space="preserve">
          <source>It was extracted to dual-life on CPAN at version 1.95 by Paul Evans &amp;lt;leonerd@leonerd.org.uk&amp;gt;</source>
          <target state="translated">Paul Evans &amp;lt;leonerd@leonerd.org.uk&amp;gt;在1.95版的CPAN上将其提取为具有双重生命的文件。</target>
        </trans-unit>
        <trans-unit id="d62846658b7b31f9fc5efa8815011f4172e2d224" translate="yes" xml:space="preserve">
          <source>It was introduced to avoid the potential problems with the other form, available in all Perls. That form consists of a backslash followed by three octal digits. One problem with this form is that it can look exactly like an old-style backreference (see &lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;Disambiguation rules between old-style octal escapes and backreferences&lt;/a&gt; below.) You can avoid this by making the first of the three digits always a zero, but that makes \077 the largest code point specifiable.</source>
          <target state="translated">引入它是为了避免所有Perls中都提供的另一种形式的潜在问题。该形式由反斜杠和三个八进制数字组成。这种形式的一个问题是，它看起来就像是老式的反向引用（请参见下面的&lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;老式八进制转义和反向引用之间的消歧规则&lt;/a&gt;。）可以通过使三个数字中的第一个始终为零来避免这种情况，但是使\ 077成为最大可指定的代码点。</target>
        </trans-unit>
        <trans-unit id="d3ee2a6714e3e6adf556faba68422a058c942c27" translate="yes" xml:space="preserve">
          <source>It will also use a default typemap installed as &lt;code&gt;ExtUtils::typemap&lt;/code&gt; .</source>
          <target state="translated">它还将使用安装为 &lt;code&gt;ExtUtils::typemap&lt;/code&gt; 的默认类型图。</target>
        </trans-unit>
        <trans-unit id="49ab6ec702b4749c563dad7126fbebc3ad5a9050" translate="yes" xml:space="preserve">
          <source>It will also use the &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Locale&quot;&gt;Win32::Locale&lt;/a&gt; module, if it's installed.</source>
          <target state="translated">如果已安装，它将也使用&lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Locale&quot;&gt;Win32 :: Locale&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="eebcb44cc4b0d0bb319df0e9deccc15987032c7b" translate="yes" xml:space="preserve">
          <source>It will always have at least one parameter automatically passed by Perl - this corresponds to the name of the package. In the example above it will be &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt; .</source>
          <target state="translated">它将始终具有至少一个由Perl自动传递的参数-这与包的名称相对应。在上面的示例中，它将是 &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b05bb9d8d6cf0031940a72fb71a5bc98935f18a" translate="yes" xml:space="preserve">
          <source>It will default to the global setting of &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt; , which by default is 0.</source>
          <target state="translated">它将默认为 &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt; 的全局设置，默认为0。</target>
        </trans-unit>
        <trans-unit id="5c5106e7131ba864011023c16e2d910c408243d8" translate="yes" xml:space="preserve">
          <source>It will exit with 255.</source>
          <target state="translated">它将以255退出。</target>
        </trans-unit>
        <trans-unit id="cd3560715bcdcdb5a5493a3c2aa8a0baf196fb75" translate="yes" xml:space="preserve">
          <source>It will look in the environment for a</source>
          <target state="translated">它将在环境中寻找一个</target>
        </trans-unit>
        <trans-unit id="11ba08d3329959d8ccf0a41d4bc0caadee83aee8" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x (except overloaded operators) will modify $y, and vice versa. Or in other words, &lt;code&gt;=&lt;/code&gt; is only safe if you modify your BigInts only via overloaded math. As soon as you use a method call it breaks:</source>
          <target state="translated">它不会按照您的想法进行操作，例如复制$ x。相反，它只是再次引用&lt;b&gt;同一&lt;/b&gt;对象并将其存储在$ y中。因此，修改$ x的任何内容（重载运算符除外）都将修改$ y，反之亦然。换句话说， &lt;code&gt;=&lt;/code&gt; 仅在您仅通过重载数学修改BigInts时才安全。一旦使用方法调用，它就会中断：</target>
        </trans-unit>
        <trans-unit id="4ef09ffb235f52f01cd3d25c0c384cab0806a14c" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x will modify $y (except overloaded math operators), and vice versa. See &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for details and how to avoid that.</source>
          <target state="translated">它不会按照您的想法进行操作，例如复制$ x。相反，它只是再次引用&lt;b&gt;同一&lt;/b&gt;对象并将其存储在$ y中。因此，任何修改$ x的东西都会修改$ y（重载的数学运算符除外），反之亦然。有关详细信息以及如何避免这种情况，请参见&lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd48a6ec2ae8cb512d05f750d53684c09ff6166d" translate="yes" xml:space="preserve">
          <source>It will print 'A' and then terminate, as it considers the match to be zero-width, and thus will not match at the same position twice in a row.</source>
          <target state="translated">它将打印'A',然后终止,因为它认为匹配是零宽度的,因此不会在同一位置连续匹配两次。</target>
        </trans-unit>
        <trans-unit id="478635e0153852c95d172e95b14a9c73a7376ef9" translate="yes" xml:space="preserve">
          <source>It will produce output like this:</source>
          <target state="translated">它将产生这样的输出。</target>
        </trans-unit>
        <trans-unit id="033bdc255180f8b012ecc3dd8743f6cfc3998050" translate="yes" xml:space="preserve">
          <source>It will return undef if it was not able to find where the module was installed, or a hash reference with the following keys if it was able to find the file:</source>
          <target state="translated">如果找不到模块的安装位置,它将返回 undef,如果能够找到文件,则返回一个包含以下键的哈希引用。</target>
        </trans-unit>
        <trans-unit id="8fd1f4b13738ec21f8b65433f2c797f00d69b112" translate="yes" xml:space="preserve">
          <source>It won't work across a sequence of &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;retrieve&lt;/code&gt; operations, however, because the addresses in the retrieved objects, which are part of the stringified references, will probably differ from the original addresses. The topology of your structure is preserved, but not hidden semantics like those.</source>
          <target state="translated">但是，它不能在一系列 &lt;code&gt;store&lt;/code&gt; 和 &lt;code&gt;retrieve&lt;/code&gt; 操作中使用，因为检索到的对象中的地址（是字符串化引用的一部分）可能与原始地址不同。您的结构的拓扑将保留，但不会保留诸如此类的隐藏语义。</target>
        </trans-unit>
        <trans-unit id="d829aa608b7d822354368e8bc717a7f78948e864" translate="yes" xml:space="preserve">
          <source>It works on references, too:</source>
          <target state="translated">它对参考文献也有效。</target>
        </trans-unit>
        <trans-unit id="063657847573da8f9a48b2f56cfac7e5ef0c0bcc" translate="yes" xml:space="preserve">
          <source>It works this way as of Perl 5.18. Historically, it was inconsistent, and you would have to write</source>
          <target state="translated">从Perl 5.18开始,它是这样工作的。过去,这种方式是不一致的,你必须写出</target>
        </trans-unit>
        <trans-unit id="4c5e6eff5a06238d171586dbb35b0a88b0b974e6" translate="yes" xml:space="preserve">
          <source>It would be even more readable to write that this way:</source>
          <target state="translated">这样写就更有看头了。</target>
        </trans-unit>
        <trans-unit id="bb356348d0e8eb250c8d665196d735d29e867b02" translate="yes" xml:space="preserve">
          <source>It would be much better if you could ignore the NULL terminations issue in the main application code and have a mechanism that automatically added the terminating NULL to all keys and values whenever you write to the database and have them removed when you read from the database. As I'm sure you have already guessed, this is a problem that DBM Filters can fix very easily.</source>
          <target state="translated">如果你能在主应用程序代码中忽略NULL终止的问题,并有一个机制,每当你向数据库写入时,自动将终止的NULL添加到所有键和值中,并在从数据库中读取时让它们被删除,那就会好得多。相信你已经猜到了,这个问题DBM Filters可以很容易的解决。</target>
        </trans-unit>
        <trans-unit id="664879d0a9a8a0187a85ff4778c8dc4aba203972" translate="yes" xml:space="preserve">
          <source>It would be much safer if the &lt;code&gt;upcase_in()&lt;/code&gt; function were written to return a copy of its parameters instead of changing them in place:</source>
          <target state="translated">如果编写了 &lt;code&gt;upcase_in()&lt;/code&gt; 函数以返回其参数的副本而不是就地更改它们，则将更加安全：</target>
        </trans-unit>
        <trans-unit id="e4a501eefab1e263f175f9fb282fe6f38bf8d7a7" translate="yes" xml:space="preserve">
          <source>It would be nice if one could leave off the commas around the constants entirely and just say:</source>
          <target state="translated">如果能把常量周围的逗号完全去掉,而只说。</target>
        </trans-unit>
        <trans-unit id="7a5b5ee29fb341a3488cf2301ee04c0c66aa8f82" translate="yes" xml:space="preserve">
          <source>It would be nice if we could do this in one fell swoop: unpack a short, back up a little, and then unpack 2 bytes. Since Perl</source>
          <target state="translated">如果我们能一气呵成地完成这个任务,那就更好了:解包一个短的,后退一点,再解包两个字节。由于 Perl</target>
        </trans-unit>
        <trans-unit id="dcfbbfc45bc8f20d112951dc582ad08e297b4815" translate="yes" xml:space="preserve">
          <source>It would be nice to support encoding to non-UTF8, such as =?ISO-2022-JP? and =?ISO-8859-1?= but that makes the implementation too complicated. These days major mail agents all support =?UTF-8? so I think it is just good enough.</source>
          <target state="translated">如果能支持编码为非UTF8就更好了,比如=?ISO-2022-JP?和=?ISO-8859-1?=,但这样一来实现起来就太复杂了。现在主要的邮件代理都支持=?UTF-8?,所以我认为这就足够了。</target>
        </trans-unit>
        <trans-unit id="33c0be04ddea1d5a74e0dccb69b13ad0c437b131" translate="yes" xml:space="preserve">
          <source>It would put the generated files into needed locations. Manually put</source>
          <target state="translated">它会把生成的文件放到需要的位置。手动将</target>
        </trans-unit>
        <trans-unit id="79d53b44344312c7f974c895e0fb0eb2bd88118d" translate="yes" xml:space="preserve">
          <source>It's a Perl 4 style file defining values for system networking constants. Sometimes it is built using &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; when Perl is installed, but other times it is not. Modern programs should use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket;&lt;/code&gt; instead.</source>
          <target state="translated">这是一个Perl 4样式文件，用于定义系统网络常量的值。有时在安装Perl时是使用&lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt;构建的，而其他时候则不是。现代程序应 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket;&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="4113134dec0bea10f51321538387f13a1da8743a" translate="yes" xml:space="preserve">
          <source>It's a cardinal sin to break existing Perl programs. New warnings can be contentious--some say that a program that emits warnings is not broken, while others say it is. Adding keywords has the potential to break programs, changing the meaning of existing token sequences or functions might break programs.</source>
          <target state="translated">破坏现有的Perl程序是一种大罪。新的警告可能会引起争议--有些人说,发出警告的程序并没有被破坏,而另一些人则说它是被破坏的。添加关键字有可能破坏程序,改变现有标记序列或函数的含义也可能破坏程序。</target>
        </trans-unit>
        <trans-unit id="3443bb54ef3fac59b8ef057b86f52fe4980fafa5" translate="yes" xml:space="preserve">
          <source>It's a little tricker with c2ph because you have to get the includes right. I can't know this for your system, but it's not usually too terribly difficult.</source>
          <target state="translated">对于c2ph来说,这是一个比较棘手的问题,因为你必须得到正确的包括。我不知道你的系统是怎样的,但通常不会太难。</target>
        </trans-unit>
        <trans-unit id="110a6a21060fbfe67381c1323cb9f71073b9732c" translate="yes" xml:space="preserve">
          <source>It's also possible to get into trouble with other operations that don't care whether they use tainted values. Make judicious use of the file tests in dealing with any user-supplied filenames. When possible, do opens and such &lt;b&gt;after&lt;/b&gt; properly dropping any special user (or group!) privileges. Perl doesn't prevent you from opening tainted filenames for reading, so be careful what you print out. The tainting mechanism is intended to prevent stupid mistakes, not to remove the need for thought.</source>
          <target state="translated">对于其他不在乎是否使用污染值的操作，也可能会遇到麻烦。在处理用户提供的任何文件名时，明智地使用文件测试。如果可能，请&lt;b&gt;在&lt;/b&gt;正确删除任何特殊用户（或组！）特权&lt;b&gt;后&lt;/b&gt;执行打开等操作。Perl不会阻止您打开受污染的文件名进行读取，因此请小心打印输出。污染机制旨在防止愚蠢的错误，而不是消除思考的需要。</target>
        </trans-unit>
        <trans-unit id="66317ba5ef9718c34fadba6cc4766d4c890f748d" translate="yes" xml:space="preserve">
          <source>It's also the source of a useful idiom for executing a function or performing an operation in list context and then counting the number of return values, by assigning to an empty list and then using that assignment in scalar context. For example, this code:</source>
          <target state="translated">这也是一个有用的成语的来源,在列表上下文中执行一个函数或执行一个操作,然后计算返回值的数量,通过赋值给一个空列表,然后在标量上下文中使用该赋值。例如,这段代码。</target>
        </trans-unit>
        <trans-unit id="fb0964e5585557a9c666044136d7fe7eaf45d2a2" translate="yes" xml:space="preserve">
          <source>It's also too slow (despite caching).</source>
          <target state="translated">它也太慢了(尽管有缓存)。</target>
        </trans-unit>
        <trans-unit id="bfb78b8d261485bbdd288bb61ac4516df58d28f5" translate="yes" xml:space="preserve">
          <source>It's also useful in those cases where you are comparing numbers and &lt;code&gt;is()&lt;/code&gt; 's use of &lt;code&gt;eq&lt;/code&gt; will interfere:</source>
          <target state="translated">在比较数字并且 &lt;code&gt;is()&lt;/code&gt; 的 &lt;code&gt;eq&lt;/code&gt; 使用会干扰以下情况下，它也很有用：</target>
        </trans-unit>
        <trans-unit id="8752339d213c2f85078fabecb615c362db1828df" translate="yes" xml:space="preserve">
          <source>It's also worth taking a moment to explain what happens when you &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize a member of a composite type (i.e. an array or hash element). In this case, the element is &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized</source>
          <target state="translated">还值得花一些时间来解释一下，当您 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 复合类型的成员（即数组或哈希元素）时会发生什么。在这种情况下，元素是 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 化的</target>
        </trans-unit>
        <trans-unit id="bd541e8b6a88392365f934744a878ca9f6a497b7" translate="yes" xml:space="preserve">
          <source>It's better to have numerous simple routines than a few monolithic ones. If your routine changes its behaviour significantly based on its arguments, it's a sign that you should have two (or more) separate routines.</source>
          <target state="translated">拥有许多简单的例程比几个单体例程要好。如果你的例程根据它的参数显著地改变了它的行为,那就说明你应该有两个(或更多)独立的例程。</target>
        </trans-unit>
        <trans-unit id="f3b2de78648bbd7090bfe684b2c6827590ea2a26" translate="yes" xml:space="preserve">
          <source>It's designed to be used as a handy command line utility:</source>
          <target state="translated">它被设计为一个方便的命令行工具。</target>
        </trans-unit>
        <trans-unit id="96439b3081e445faf2fae88934bbc314011a0c32" translate="yes" xml:space="preserve">
          <source>It's easy to notice the problem in such a short example, but in more complicated code you are looking for trouble if you don't localize changes to the special variables.</source>
          <target state="translated">在这样一个简短的例子中很容易发现问题,但在更复杂的代码中,如果你不对特殊变量进行局部修改,你就会找麻烦。</target>
        </trans-unit>
        <trans-unit id="dde0b49167dc00c194116739ebbe7f23d5e20372" translate="yes" xml:space="preserve">
          <source>It's egg-eating all over again: Some think that as a bit string this should be written &quot;10001100&quot; i.e. beginning with the most significant bit, others insist on &quot;00110001&quot;. Well, Perl isn't biased, so that's why we have two bit string codes:</source>
          <target state="translated">这又是一个吃鸡蛋的过程。有人认为,作为一个位串,应该写成 &quot;10001100&quot; 即从最重要的位开始写,而其他人则坚持写成 &quot;00110001&quot;。好吧,Perl不偏不倚,所以我们才有两个位串代码。</target>
        </trans-unit>
        <trans-unit id="f24807b6184833a23a70254e8f0aebceeb147f40" translate="yes" xml:space="preserve">
          <source>It's especially useful when comparing greater-than or smaller-than relation between values:</source>
          <target state="translated">当比较数值之间的大于或小于关系时,它特别有用。</target>
        </trans-unit>
        <trans-unit id="1e3a1b4314f9d6c52bc40629c2fb29defff528f6" translate="yes" xml:space="preserve">
          <source>It's essential to run any timing measurements a sufficient number of times so the numbers settle on a numerical average, otherwise each run will naturally fluctuate due to variations in the environment, to reduce the effect of contention for &lt;code&gt;CPU&lt;/code&gt; resources and network bandwidth for instance. Running the above code for one million iterations, we can take a look at the report output by the &lt;code&gt;Benchmark&lt;/code&gt; module, to see which approach is the most effective.</source>
          <target state="translated">必须对任何时序测量进行足够的次数，这样才能使这些数值稳定在数值平均值上，否则每次运行都会由于环境变化而自然波动，以减少例如争用 &lt;code&gt;CPU&lt;/code&gt; 资源和网络带宽的影响。运行上面的代码一百万次迭代，我们可以看一下 &lt;code&gt;Benchmark&lt;/code&gt; 模块输出的报告，看看哪种方法是最有效的。</target>
        </trans-unit>
        <trans-unit id="7514b40c5333fb03e3aac77ea8c92f752cf5dd0e" translate="yes" xml:space="preserve">
          <source>It's for</source>
          <target state="translated">是给你的</target>
        </trans-unit>
        <trans-unit id="b4b810adc86730679601de6a1493c2a23c259247" translate="yes" xml:space="preserve">
          <source>It's good idea to post an announcement of the availability of your module (or the module itself if small) to the comp.lang.perl.announce Usenet newsgroup. This will at least ensure very wide once-off distribution.</source>
          <target state="translated">最好的办法是在 comp.lang.perl.announce Usenet 新闻组中发布一个关于你的模块 (如果是小模块的话,则是模块本身)的公告。这至少可以保证一次性的广泛传播。</target>
        </trans-unit>
        <trans-unit id="90af562410b60653a0aa18fd2da97246062921f5" translate="yes" xml:space="preserve">
          <source>It's good that you lost track, because you shouldn't depend on the internal format being any specific encoding. But since you asked: by default, the internal format is either ISO-8859-1 (latin-1), or utf8, depending on the history of the string. On EBCDIC platforms, this may be different even.</source>
          <target state="translated">很高兴你失去了方向,因为你不应该依赖内部格式是任何特定的编码。但既然你问了:默认情况下,内部格式是ISO-8859-1 (latin-1),或者utf8,这取决于字符串的历史。在EBCDIC平台上,这甚至可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="d9d2e12c0d08cbda4c9a91e7d799364ca6410b91" translate="yes" xml:space="preserve">
          <source>It's important that $how_many accurately reflects the number of tests in the SKIP block so the # of tests run will match up with your plan. If your plan is &lt;code&gt;no_plan&lt;/code&gt; $how_many is optional and will default to 1.</source>
          <target state="translated">$ how_many准确反映SKIP块中的测试数量非常重要，因此运行的测试数量应与您的计划相匹配。如果您的计划是 &lt;code&gt;no_plan&lt;/code&gt; ,则 $ how_many是可选的，默认为1。</target>
        </trans-unit>
        <trans-unit id="1e8b6f334f8979bc29ccd072552302ba947b27dc" translate="yes" xml:space="preserve">
          <source>It's important to know what custom operators won't do for you. They won't let you add new syntax to Perl, directly. They won't even let you add new keywords, directly. In fact, they won't change the way Perl compiles a program at all. You have to do those changes yourself, after Perl has compiled the program. You do this either by manipulating the op tree using a &lt;code&gt;CHECK&lt;/code&gt; block and the &lt;code&gt;B::Generate&lt;/code&gt; module, or by adding a custom peephole optimizer with the &lt;code&gt;optimize&lt;/code&gt; module.</source>
          <target state="translated">重要的是要知道自定义运算符对您没有帮助。他们不允许您直接向Perl添加新语法。他们甚至不允许您直接添加新关键字。实际上，它们根本不会改变Perl编译程序的方式。在Perl编译程序之后，您必须自己进行更改。您可以通过使用 &lt;code&gt;CHECK&lt;/code&gt; 块和 &lt;code&gt;B::Generate&lt;/code&gt; 模块来操作op树，也可以通过添加带有 &lt;code&gt;optimize&lt;/code&gt; 模块的自定义窥孔优化器来实现。</target>
        </trans-unit>
        <trans-unit id="885ff1b611d651161375b8dbd778f67a1c287d62" translate="yes" xml:space="preserve">
          <source>It's important to note that locks don't prevent access to the variable in question, only lock attempts. This is in keeping with Perl's longstanding tradition of courteous programming, and the advisory file locking that &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; gives you.</source>
          <target state="translated">重要的是要注意，锁并不会阻止对有问题的变量的访问，而只会阻止锁的尝试。这与Perl的长期礼貌编程传统以及 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; 为您提供的咨询文件锁定保持一致。</target>
        </trans-unit>
        <trans-unit id="b0ddbbe7b1b79fc3086fea949fd8823cad9c01f9" translate="yes" xml:space="preserve">
          <source>It's important to note that the resulting string does &lt;b&gt;not&lt;/b&gt; contain the padding characters typical of Base64 encodings. This omission is deliberate, and is done to maintain compatibility with the family of CPAN Digest modules. See &lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;PADDING OF BASE64 DIGESTS&lt;/a&gt; for details.</source>
          <target state="translated">值得注意的是，得到的字符串也很重要&lt;b&gt;不&lt;/b&gt;包含典型的Base64编码的填充字符。此遗漏是有意的，并且是为了保持与CPAN Digest模块系列的兼容性而进行的。有关详细信息&lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;，&lt;/a&gt;请参见填充BASE64数字。</target>
        </trans-unit>
        <trans-unit id="ebc53949ff6cd0c67b2204f9d9fce4d627aed693" translate="yes" xml:space="preserve">
          <source>It's important to realize that there are no bytes in a text string. Of course, Perl has its internal encoding to store the string in memory, but ignore that. If you have to do anything with the number of bytes, it's probably best to move that part to step 3, just after you've encoded the string. Then you know exactly how many bytes it will be in the destination string.</source>
          <target state="translated">要知道,文本字符串中没有字节,这一点很重要。当然,Perl有其内部编码来将字符串存储在内存中,但请忽略这一点。如果你必须对字节数做任何处理,最好把这部分移到步骤 3,就在你对字符串进行编码之后。这样你就可以准确地知道它在目标字符串中会有多少字节。</target>
        </trans-unit>
        <trans-unit id="968be3dc629433b16258b1052384042ab95062a2" translate="yes" xml:space="preserve">
          <source>It's important to set a few things straight first. This is the most important part of this tutorial. This view may conflict with other information that you may have found on the web, but that's mostly because many sources are wrong.</source>
          <target state="translated">首先要把一些事情说清楚。这是本教程最重要的部分。这个观点可能会与你在网上找到的其他信息相冲突,但这主要是因为很多来源是错误的。</target>
        </trans-unit>
        <trans-unit id="6903f2d3d35327d3bebb7683e89ad822d6bff850" translate="yes" xml:space="preserve">
          <source>It's important to understand that we are specifically</source>
          <target state="translated">重要的是,我们要明白,我们是专门的</target>
        </trans-unit>
        <trans-unit id="f9b3935d15d2be2d5136d58cf490c65310c19874" translate="yes" xml:space="preserve">
          <source>It's important you make sure to use the &lt;code&gt;[ ]&lt;/code&gt; array reference constructor. That's because this wouldn't work:</source>
          <target state="translated">确保使用 &lt;code&gt;[ ]&lt;/code&gt; 数组引用构造函数很重要。那是因为这行不通：</target>
        </trans-unit>
        <trans-unit id="134dc1d9bd724d0238c1c1d4c4831e9e7f0b91b6" translate="yes" xml:space="preserve">
          <source>It's likely you'll have to add new data types later.</source>
          <target state="translated">很可能你以后还要添加新的数据类型。</target>
        </trans-unit>
        <trans-unit id="4696eb464dfb95137de621144fb7f593ad6ebd66" translate="yes" xml:space="preserve">
          <source>It's not (not!) the boundary between whitespace and non-whitespace, and it's not the stuff between words we use to create sentences.</source>
          <target state="translated">它不是(不是!)whitespace和非whitespace之间的界限,也不是我们用来造句的单词之间的东西。</target>
        </trans-unit>
        <trans-unit id="6bef3566d208cec3b519ea92214ab4883f383173" translate="yes" xml:space="preserve">
          <source>It's not a good idea to split a construct in the middle like this, and it doesn't work here. Instead use the solution above.</source>
          <target state="translated">像这样在中间拆分一个构造并不是一个好主意,在这里是行不通的。而是使用上面的解决方案。</target>
        </trans-unit>
        <trans-unit id="ec66dac5bae6d199b4bd16298b91f74283fac7f8" translate="yes" xml:space="preserve">
          <source>It's not as easy a problem as it looks. How many words do you think are in there? Wait for it... wait for it.... If you answered 5 you're right. Perl words are groups of &lt;code&gt;\w+&lt;/code&gt; , but that's not what you want to capitalize. How is Perl supposed to know not to capitalize that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; after the apostrophe? You could try a regular expression:</source>
          <target state="translated">这看起来并不容易。您认为其中有几句话？等待...等待....如果您回答5，那么您是对的。Perl单词是 &lt;code&gt;\w+&lt;/code&gt; 组，但这不是您要大写的字母。Perl是如何应该知道不能够利用该 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 撇号后？您可以尝试使用正则表达式：</target>
        </trans-unit>
        <trans-unit id="8f3fa5386c065511869ec9dc4289bdbe2b8248c4" translate="yes" xml:space="preserve">
          <source>It's not enough to say: &quot;that will make it run faster&quot;, you have to check it. Rerun the code under control of the benchmarking or profiling modules, from the first step above, and check that the new code executed the &lt;b&gt;same task&lt;/b&gt; in</source>
          <target state="translated">仅仅说&amp;ldquo;这将使其运行得更快&amp;rdquo;还不够，您必须进行检查。重新运行下的基准或仿形模块的控制的代码，来自上述第一步骤中，并检查新的代码所执行的&lt;b&gt;相同的任务&lt;/b&gt;中</target>
        </trans-unit>
        <trans-unit id="ac2ff02b85c831d3f4a6ab13ec2cd187eee43782" translate="yes" xml:space="preserve">
          <source>It's not possible to individually showcase all the performance related code for Perl here, naturally, but here's a short list of modules from the CPAN which deserve further attention.</source>
          <target state="translated">在这里自然不可能单独展示所有Perl的性能相关代码,但这里有一个简短的CPAN模块列表,值得进一步关注。</target>
        </trans-unit>
        <trans-unit id="dd227a742cbf3f4b2811cdbf8769ec886d4ea747" translate="yes" xml:space="preserve">
          <source>It's not possible to use this module to embed formatting and color attributes using Perl formats. They replace the escape character with a space (as documented in</source>
          <target state="translated">使用这个模块不可能使用Perl格式来嵌入格式和颜色属性。它们用空格代替转义字符(如在</target>
        </trans-unit>
        <trans-unit id="8cf7485885d18503520503d1c1deed4967629127" translate="yes" xml:space="preserve">
          <source>It's not really a barrel of laughs, is it? In fact, it's worse than it may seem; the eagle-eyed may notice that the first field should only be 10 characters wide, and the error has propagated right through the other numbers - which we've had to count by hand. So it's error-prone as well as horribly unfriendly.</source>
          <target state="translated">这不是真的笑料百出吧?事实上,它比看起来更糟糕,眼尖的人可能会注意到,第一个字段应该只有10个字符宽,而这个错误已经直接传播到了其他数字中--我们不得不用手来计算。所以,这既容易出错,又可怕的不友好。</target>
        </trans-unit>
        <trans-unit id="a9d4e78b20b4ec5c47ad5e65cf852abb8251388b" translate="yes" xml:space="preserve">
          <source>It's ok for your test to change where STDOUT and STDERR point to, Test::Builder's default output settings will not be affected.</source>
          <target state="translated">你的测试可以改变 STDOUT 和 STDERR 的指向,Test::Builder 的默认输出设置不会受到影响。</target>
        </trans-unit>
        <trans-unit id="e6c4906faf9dc43631913b5936b5f4e02175738c" translate="yes" xml:space="preserve">
          <source>It's only intended as a rough tool. You may need to dicker with the files produced.</source>
          <target state="translated">它只是作为一个粗略的工具。你可能需要对产生的文件进行纠错。</target>
        </trans-unit>
        <trans-unit id="4ad5389b057242e5f2754208243d1e536ed13fdf" translate="yes" xml:space="preserve">
          <source>It's only written as a helper module for both CPAN.pm and CPANPLUS.pm.</source>
          <target state="translated">它只作为CPAN.pm和CPANPLUS.pm的辅助模块来编写。</target>
        </trans-unit>
        <trans-unit id="ce38cb5abf7b4d320a0e699a61e26594815c5fdf" translate="yes" xml:space="preserve">
          <source>It's perfectly safe to nest SKIP blocks. Each SKIP block must have the label &lt;code&gt;SKIP&lt;/code&gt; , or Test::More can't work its magic.</source>
          <target state="translated">嵌套跳过块非常安全。每个SKIP块都必须带有标签 &lt;code&gt;SKIP&lt;/code&gt; 或Test :: More不能发挥其魔力。</target>
        </trans-unit>
        <trans-unit id="23089c9252263a75014f4ca3ca447b38592d18ae" translate="yes" xml:space="preserve">
          <source>It's possible that not all modules listed below are installed on your system. For example, the GDBM_File module will not be installed if you don't have the gdbm library.</source>
          <target state="translated">有可能在你的系统中并没有安装下面列出的所有模块。例如,如果你没有gdbm库,GDBM_File模块将不会被安装。</target>
        </trans-unit>
        <trans-unit id="9d7827a4cab49cd207c98c793d3174f1c8aaeda1" translate="yes" xml:space="preserve">
          <source>It's possible to change the MRO of a given class either by using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
mro&lt;/code&gt; as shown in the synopsis, or by using the &lt;a href=&quot;#mro%3a%3aset_mro&quot;&gt;mro::set_mro&lt;/a&gt; function below.</source>
          <target state="translated">这是可能或者通过使用来改变给定类的MRO &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; mro&lt;/code&gt; 在概要中显示，或通过使用&lt;a href=&quot;#mro%3a%3aset_mro&quot;&gt;MRO :: set_mro&lt;/a&gt;以下功能。</target>
        </trans-unit>
        <trans-unit id="8141ee35a9c20672528ff17c177b18bb4b35dc61" translate="yes" xml:space="preserve">
          <source>It's possible to have a class that does not expose any publicly settable attributes. Not every class has attributes and methods.</source>
          <target state="translated">可以有一个不暴露任何可公开设置的属性的类。不是每个类都有属性和方法。</target>
        </trans-unit>
        <trans-unit id="fdf6b6ef2b9e4a59b56ec7ba91fcecae99b94163" translate="yes" xml:space="preserve">
          <source>It's possible to load multiple features together, using a</source>
          <target state="translated">可以将多个功能一起加载,使用一个</target>
        </trans-unit>
        <trans-unit id="66c778a3281518c9b26558498194320e4725fef9" translate="yes" xml:space="preserve">
          <source>It's possible to take the previous idea a little further, by using a compile time &lt;code&gt;DEBUG&lt;/code&gt; constant.</source>
          <target state="translated">通过使用编译时 &lt;code&gt;DEBUG&lt;/code&gt; 常量，可以使先前的想法更进一步。</target>
        </trans-unit>
        <trans-unit id="30a0b506f4d59de09c1852a82f659060edd73925" translate="yes" xml:space="preserve">
          <source>It's possible to use simple addition and subtraction of objects:</source>
          <target state="translated">可以使用简单的物体加减法。</target>
        </trans-unit>
        <trans-unit id="b2798edf93af2bc08dca21c6c73367266b229901" translate="yes" xml:space="preserve">
          <source>It's probably best to copy one of the existing runops functions and change it to suit your needs. Then, in the BOOT section of your XS file, add the line:</source>
          <target state="translated">最好是复制一个现有的runops函数,并根据你的需要进行修改。然后,在XS文件的BOOT部分,添加以下一行。</target>
        </trans-unit>
        <trans-unit id="b340d427890b7b2748a883b3fba121b10e7d2921" translate="yes" xml:space="preserve">
          <source>It's probably best to prototype new functions, not retrofit prototyping into older ones. That's because you must be especially careful about silent impositions of differing list versus scalar contexts. For example, if you decide that a function should take just one parameter, like this:</source>
          <target state="translated">最好的办法可能是对新功能进行原型设计,而不是将原型设计改造成旧功能。这是因为你必须特别小心不同列表与标量上下文的沉默强加。例如,如果你决定一个函数应该只取一个参数,就像这样。</target>
        </trans-unit>
        <trans-unit id="91ff9edf126b862a4aaa943668bacea81314c045" translate="yes" xml:space="preserve">
          <source>It's probably better to always use commas after constant names in order to force the next error.</source>
          <target state="translated">可能最好总是在常量名称后使用逗号,以强制下一个错误。</target>
        </trans-unit>
        <trans-unit id="16dbf025d239b7a2bc2c7033417d6a18d06e2afb" translate="yes" xml:space="preserve">
          <source>It's probably worth mentioning that if you're going to filetest the return values out of a readdir, you'd better prepend the directory in question. Otherwise, because we didn't chdir() there, it would have been testing the wrong file.</source>
          <target state="translated">可能值得一提的是,如果你要从一个readdir中测试返回值,你最好把有关的目录放在前面。否则,因为我们没有在那里使用chdir(),就会测试出错误的文件。</target>
        </trans-unit>
        <trans-unit id="e6c512535456a00f2d66365aceea1ac2fa50945d" translate="yes" xml:space="preserve">
          <source>It's quite possible that the target system doesn't have a readily available /tmp, so it's generall safer to do something like this:</source>
          <target state="translated">很有可能目标系统没有现成的/tmp,所以一般来说,这样做比较安全。</target>
        </trans-unit>
        <trans-unit id="8748833136242804cdf06e42df13a982b1789766" translate="yes" xml:space="preserve">
          <source>It's recommended that you run &lt;code&gt;use_ok()&lt;/code&gt; inside a BEGIN block so its functions are exported at compile-time and prototypes are properly honored.</source>
          <target state="translated">建议您在BEGIN块中运行 &lt;code&gt;use_ok()&lt;/code&gt; ,以便在编译时导出其功能，并适当使用原型。</target>
        </trans-unit>
        <trans-unit id="fbc60c6d884b88a267926002dcaceb4adc822c67" translate="yes" xml:space="preserve">
          <source>It's safe, however, to P- or p-pack a string literal, because Perl simply allocates an anonymous variable.</source>
          <target state="translated">然而,对字符串文字进行 P-或 p-pack 是安全的,因为 Perl 只是分配了一个匿名变量。</target>
        </trans-unit>
        <trans-unit id="18b132707c62c569a28f6b436602a7bfbd864dfd" translate="yes" xml:space="preserve">
          <source>It's still not quite so clear as prose, but it is very useful for describing the meaning of each part of the pattern.</source>
          <target state="translated">虽然还是没有散文那么清晰,但对于描述图案中每个部分的含义非常有用。</target>
        </trans-unit>
        <trans-unit id="08057143a2d44a0a378f9cd365b42fe324a68a97" translate="yes" xml:space="preserve">
          <source>It's still up to you to seek out the actual changes, and there might not actually be any. Perhaps all of the changes since you last checked cancelled each other out and left the package in the state it was in before.</source>
          <target state="translated">这还是要靠你自己去寻找实际的变化,实际上可能没有任何变化。也许自你上次检查后的所有变化都互相抵消了,使包裹处于之前的状态。</target>
        </trans-unit>
        <trans-unit id="6aa1b5e370d6ab122fa013735d3b648f88f35f20" translate="yes" xml:space="preserve">
          <source>It's the double quotes, not the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, doing this. Whenever you interpolate an array in a double quote context, Perl joins the elements with spaces (or whatever is in &lt;code&gt;$&quot;&lt;/code&gt; , which is a space by default):</source>
          <target state="translated">这样做是双引号而不是 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 。每当您在双引号上下文中插入数组时，Perl就会用空格（或 &lt;code&gt;$&quot;&lt;/code&gt; 任何内容，默认情况下是空格）将元素连接起来：</target>
        </trans-unit>
        <trans-unit id="faab5a6ebe5c2e1ecdb8d0e0f9a387f835a3623a" translate="yes" xml:space="preserve">
          <source>It's useful if you want to print out the name of a variable. If you restrict yourself to globs which exist at compile-time then the result ought to be unambiguous, because code like &lt;code&gt;${&quot;^G&quot;} = 1&lt;/code&gt; is compiled as two ops - a constant string and a dereference (rv2gv) - so that the glob is created at runtime.</source>
          <target state="translated">如果要打印出变量名，这很有用。如果将自己限制为在编译时存在的全局变量，那么结果应该是明确的，因为像 &lt;code&gt;${&quot;^G&quot;} = 1&lt;/code&gt; 被编译为两个操作-常量字符串和解引用（rv2gv）-这样全局变量是在运行时创建的。</target>
        </trans-unit>
        <trans-unit id="57045aa0891a8e6164538ff7cbd090571f866c1f" translate="yes" xml:space="preserve">
          <source>It's well known that software developers usually fully document the software they write. If, however, the world is in urgent need of your software and there is not enough time to write the full documentation please at least provide a README file containing:</source>
          <target state="translated">众所周知,软件开发者通常会对自己编写的软件进行完整的文档编写。但是,如果世界急需你的软件,而又没有足够的时间来编写完整的文档,请至少提供一个包含README文件。</target>
        </trans-unit>
        <trans-unit id="4198106b088c5bcb9774e212538d8c15169f58dc" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">固定宽度字体的斜体版本（实际上有点用词不当，因为大多数固定宽度字体仅具有斜体版本，而不是斜体版本）。默认为 &lt;code&gt;CI&lt;/code&gt; 。仅对&lt;b&gt;troff&lt;/b&gt;输出有效。</target>
        </trans-unit>
        <trans-unit id="583cdcdfd2a75305b35fba58a53f31af16e8fada" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">固定宽度字体的斜体版本（实际上有点用词不当，因为大多数固定宽度字体仅具有斜体版本，而不是斜体版本）。默认为 &lt;code&gt;CI&lt;/code&gt; 。仅对troff（1）输出有效。</target>
        </trans-unit>
        <trans-unit id="b15ebe35e9c7b71db4b6f242bc6c861b7b404110" translate="yes" xml:space="preserve">
          <source>Itanium Processor Family (IPF) and HP-UX</source>
          <target state="translated">Itanium处理器系列(IPF)和HP-UX。</target>
        </trans-unit>
        <trans-unit id="e54d4abd34db02334ef2ceaf6dadfd1a53f1ce9b" translate="yes" xml:space="preserve">
          <source>Itanium, Itanium 2 &amp;amp; Madison 6</source>
          <target state="translated">安腾，安腾2和麦迪逊6</target>
        </trans-unit>
        <trans-unit id="e359180eb8ab875848335db708d277f8c6f86293" translate="yes" xml:space="preserve">
          <source>Item, over, and back require a little more explanation: &quot;=over&quot; starts a region specifically for the generation of a list using &quot;=item&quot; commands, or for indenting (groups of) normal paragraphs. At the end of your list, use &quot;=back&quot; to end it. The</source>
          <target state="translated">item、over和back需要多一点解释。&quot;=over &quot;开始一个区域,专门用于使用&quot;=item &quot;命令生成一个列表,或者用于缩进(一组)普通段落。在你的列表的最后,使用&quot;=back &quot;来结束它。列表结束时,使用&quot;=回 &quot;来结束。</target>
        </trans-unit>
        <trans-unit id="bca788485b73309b9f1f94d8376ab88aa565b95b" translate="yes" xml:space="preserve">
          <source>Iterate raw input without applying any fixes for quirky input syntax.</source>
          <target state="translated">迭代原始输入,而不需要对古怪的输入语法进行任何修正。</target>
        </trans-unit>
        <trans-unit id="880d0fdfaa731611203ad90b727f9ad0e4c9d1d5" translate="yes" xml:space="preserve">
          <source>Iterate through it, of course.</source>
          <target state="translated">当然,迭代通过它。</target>
        </trans-unit>
        <trans-unit id="0c168efad25dad6474931abc9c9d01ef4bb67924" translate="yes" xml:space="preserve">
          <source>Iterate through the process output, of course.</source>
          <target state="translated">当然,经由过程输出迭代。</target>
        </trans-unit>
        <trans-unit id="e92d8ec2d181e1d01333d9fb58638b2b85aed8c4" translate="yes" xml:space="preserve">
          <source>Iterating over the PADNAMELIST iterates over all possible pad items. Pad slots for targets (SVs_PADTMP) and GVs end up having &amp;amp;PL_padname_undef &quot;names&quot;, while slots for constants have &amp;amp;PL_padname_const &quot;names&quot; (see pad_alloc()). That &amp;amp;PL_padname_undef and &amp;amp;PL_padname_const are used is an implementation detail subject to change. To test for them, use &lt;code&gt;!PadnamePV(name)&lt;/code&gt; and &lt;code&gt;PadnamePV(name)
&amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt; , respectively.</source>
          <target state="translated">遍历PADNAMELIST遍历所有可能的填充项目。目标（SVs_PADTMP）和GV的填充插槽最终以＆PL_padname_undef&amp;ldquo;名称&amp;rdquo;命名，而常量的插槽具有＆PL_padname_const&amp;ldquo;名称&amp;rdquo;（请参见pad_alloc（））。使用＆PL_padname_undef和＆PL_padname_const是可能更改的实现细节。要测试它们，请分别使用 &lt;code&gt;!PadnamePV(name)&lt;/code&gt; 和 &lt;code&gt;PadnamePV(name) &amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca668574626a9549ef81113edbe0269d243a6e70" translate="yes" xml:space="preserve">
          <source>Iterator for array-based TAP sources</source>
          <target state="translated">阵列式TAP源的迭代器</target>
        </trans-unit>
        <trans-unit id="e365acec52938bb4821137a9d3698525ef64c0e6" translate="yes" xml:space="preserve">
          <source>Iterator for filehandle-based TAP sources</source>
          <target state="translated">基于文件柄的TAP源的迭代器。</target>
        </trans-unit>
        <trans-unit id="608949e6615edc46b7788d7e5f71e396c783a95e" translate="yes" xml:space="preserve">
          <source>Iterator for process-based TAP sources</source>
          <target state="translated">基于过程的TAP源的迭代器</target>
        </trans-unit>
        <trans-unit id="1fdccc2b2140fc0f61c8fa7efaf9cf9309d438ee" translate="yes" xml:space="preserve">
          <source>IteratorFactory</source>
          <target state="translated">IteratorFactory</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="e11cc17e61cacb91ddb22ab15b88e065056ee12e" translate="yes" xml:space="preserve">
          <source>Ithreads work by cloning the data tree so that no data is shared between different threads. These threads can be used by using the &lt;code&gt;threads&lt;/code&gt; module or by doing fork() on win32 (fake fork() support). When a thread is cloned all Perl data is cloned, however non-Perl data cannot be cloned automatically. Perl after 5.8.0 has support for the &lt;code&gt;CLONE&lt;/code&gt; special subroutine. In &lt;code&gt;CLONE&lt;/code&gt; you can do whatever you need to do, like for example handle the cloning of non-Perl data, if necessary. &lt;code&gt;CLONE&lt;/code&gt; will be called once as a class method for every package that has it defined (or inherits it). It will be called in the context of the new thread, so all modifications are made in the new area. Currently CLONE is called with no parameters other than the invocant package name, but code should not assume that this will remain unchanged, as it is likely that in future extra parameters will be passed in to give more information about the state of cloning.</source>
          <target state="translated">Ithread通过克隆数据树来工作，因此不同线程之间不会共享数据。可以通过使用 &lt;code&gt;threads&lt;/code&gt; 模块或在win32上执行fork（）（使用伪造的fork（））来使用这些线程。克隆线程时，将克隆所有Perl数据，但是不能自动克隆非Perl数据。 5.8.0之后的Perl支持 &lt;code&gt;CLONE&lt;/code&gt; 特殊子例程。在 &lt;code&gt;CLONE&lt;/code&gt; 中,您可以执行所需的任何操作，例如，如有必要，处理非Perl数据的克隆。 &lt;code&gt;CLONE&lt;/code&gt; 将被定义为（或继承）每个包的类方法一次调用。将在新线程的上下文中调用它，因此所有修改都在新区​​域中进行。当前调用CLONE时除了发出主叫的程序包名称外没有其他参数，但是代码不应假定它会保持不变，因为将来可能会传入其他参数以提供有关克隆状态的更多信息。</target>
        </trans-unit>
        <trans-unit id="1fc560e7e4efb5d974d128bd00c3dd33446589b6" translate="yes" xml:space="preserve">
          <source>Its &lt;code&gt;pprivate&lt;/code&gt; and &lt;code&gt;intflags&lt;/code&gt; fields contain data specific to each engine.</source>
          <target state="translated">其 &lt;code&gt;pprivate&lt;/code&gt; 和 &lt;code&gt;intflags&lt;/code&gt; 字段包含特定于每个引擎的数据。</target>
        </trans-unit>
        <trans-unit id="16c6982b7d6141952759d09a7076ec5f4dab57ab" translate="yes" xml:space="preserve">
          <source>Its address can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed. Make sure that you don't try to compare a random sv with &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; . For example when interfacing Perl code, it'll work correctly for:</source>
          <target state="translated">只要需要 &lt;code&gt;SV*&lt;/code&gt; 就可以使用其地址。确保您不要尝试将随机sv与 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 进行比较。例如，当连接Perl代码时，它将在以下方面正常工作：</target>
        </trans-unit>
        <trans-unit id="0881b1abd4c8c0f2683196629616b2be066ab1e5" translate="yes" xml:space="preserve">
          <source>Its advantage over &lt;code&gt;ok()&lt;/code&gt; is when the test fails you'll know what $got and $expected were:</source>
          <target state="translated">与 &lt;code&gt;ok()&lt;/code&gt; 相比，它的优点是测试失败时，您将知道$ got和$ expected是什么：</target>
        </trans-unit>
        <trans-unit id="004b859afb711a2b891500dcf0aac6a8c2d2a9a8" translate="yes" xml:space="preserve">
          <source>Its advantages over &lt;code&gt;ok()&lt;/code&gt; are similar to that of &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; . Better diagnostics on failure.</source>
          <target state="translated">它比 &lt;code&gt;ok()&lt;/code&gt; 的优势类似于 &lt;code&gt;is()&lt;/code&gt; 和 &lt;code&gt;isnt()&lt;/code&gt; 的优势。更好的故障诊断。</target>
        </trans-unit>
        <trans-unit id="b47f30ae9fc0af2d5174d1161686c5cb48a52d13" translate="yes" xml:space="preserve">
          <source>Its behaviour is identical to using an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; type in XS with T_IV.</source>
          <target state="translated">它的行为与在XS中使用T_IV 使用 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 类型相同。</target>
        </trans-unit>
        <trans-unit id="fae697da5b215cc5fb762242f2f9d970cf1a4185" translate="yes" xml:space="preserve">
          <source>Its currently very simple and may be expanded sometime in the figure to include more flexible code and switches.</source>
          <target state="translated">其目前非常简单,可能会在图中的某个时候进行扩展,加入更多灵活的代码和开关。</target>
        </trans-unit>
        <trans-unit id="270729f2364ce03a3daacf9b717d32c8a85378b7" translate="yes" xml:space="preserve">
          <source>Its format is not guaranteed not to change over time.</source>
          <target state="translated">其格式不能保证不随时间而改变。</target>
        </trans-unit>
        <trans-unit id="41db9b49c066a3eed741a13ffe63dcafc0bc1631" translate="yes" xml:space="preserve">
          <source>Its name comes from the observation that this operation combined with the alternation operator (&lt;code&gt;|&lt;/code&gt;) can be used to create what is essentially a pattern-based if/then/else block:</source>
          <target state="translated">它的名字来自于观察到该操作与交替运算符（ &lt;code&gt;|&lt;/code&gt; ）结合使用时可以用来创建本质上基于模式的if / then / else块的方法：</target>
        </trans-unit>
        <trans-unit id="c1a5e19377208f27c49b06cb17d4ed4cd4b998dc" translate="yes" xml:space="preserve">
          <source>Its use of \x1b (escape) is also very questionable.</source>
          <target state="translated">其使用x1b(逃逸)也很值得商榷。</target>
        </trans-unit>
        <trans-unit id="c1782b37a47b28cba886190c0e7c9425d4b8409e" translate="yes" xml:space="preserve">
          <source>Its wrapping is done by &lt;a href=&quot;../../text/wrap&quot;&gt;Text::Wrap&lt;/a&gt;, so you can change &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; as you like.</source>
          <target state="translated">它的包装是通过&lt;a href=&quot;../../text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt;完成的，因此您可以根据需要更改 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="d7060e173c0374cb8eae482e18306d094b4a274a" translate="yes" xml:space="preserve">
          <source>JAPH stands for &quot;Just another Perl hacker,&quot;, which Randal Schwartz used to sign email and usenet messages starting in the late 1980s. He previously used the phrase with many subjects (&quot;Just another x hacker,&quot;), so to distinguish his JAPH, he started to write them as Perl programs:</source>
          <target state="translated">JAPH是 &quot;Just another Perl hacker &quot;的缩写,Randal Schwartz从20世纪80年代末开始用它来签署电子邮件和usenet消息。他之前用这句话的主题很多(&quot;Just another x hacker&quot;),所以为了区别他的JAPH,他开始把它们写成Perl程序。</target>
        </trans-unit>
        <trans-unit id="dced2aceecfe6edc6c5082affb4adef03ec116d9" translate="yes" xml:space="preserve">
          <source>JSON::XS compatible pure-Perl module.</source>
          <target state="translated">JSON::XS兼容的纯Perl模块。</target>
        </trans-unit>
        <trans-unit id="cc167be5863c0fa54ff8e14b6cf90200815632fb" translate="yes" xml:space="preserve">
          <source>James E. Keenan</source>
          <target state="translated">James E.Keenan</target>
        </trans-unit>
        <trans-unit id="57cf1bbb2770fa0d885d542ddaca96bfea96011e" translate="yes" xml:space="preserve">
          <source>James Keenan, &amp;lt;jkeenan@cpan.org&amp;gt;</source>
          <target state="translated">詹姆斯&amp;middot;基南（James Keenan），&amp;lt;jkeenan@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6ce48d285e726d9be92e6bf68e171d9553e0896e" translate="yes" xml:space="preserve">
          <source>Japanese Encodings</source>
          <target state="translated">日本编码</target>
        </trans-unit>
        <trans-unit id="ff7b561acfebbb2aad1864ab89f7d4e5285c6e22" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi</source>
          <target state="translated">Jarkko Hietaniemi</target>
        </trans-unit>
        <trans-unit id="a9a4e186a4a793bc3fef06e8162fa8ae0f705095" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">Jarkko Hietaniemi &amp;lt;</target>
        </trans-unit>
        <trans-unit id="13ce73395e162a5533c6ace927e40c80d2cab8fd" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;</source>
          <target state="translated">Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7adef0fede1e52584837e3b9fe09cbb854d77894" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt; Bryan Logan &amp;lt;bryanlog@us.ibm.com&amp;gt; David Larson &amp;lt;larson1@us.ibm.com&amp;gt;</source>
          <target state="translated">Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;布莱恩&amp;middot;洛根&amp;lt;bryanlog@us.ibm.com&amp;gt;大卫&amp;middot;拉森&amp;lt;larson1@us.ibm.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="276f92ff10492dd51e70f45871039bf3b88b6a4b" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi's original</source>
          <target state="translated">亚尔科-希塔涅米的原作</target>
        </trans-unit>
        <trans-unit id="04cfea13773f0ae1b7ac40ccd517f43dc7dcdad4" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, &amp;lt;jhi@hut.fi&amp;gt;</source>
          <target state="translated">Jarkko Hietaniemi，&amp;lt;jhi@hut.fi&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0bc2a5e3ff31736b8a57665e048886c573a122f3" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, conversion into libnetcfg for inclusion into Perl 5.8.</source>
          <target state="translated">Jarkko Hietaniemi,将其转换为libnetcfg,纳入Perl 5.8。</target>
        </trans-unit>
        <trans-unit id="692b885ac0ff146816113cee07c7dfe2ef0ba0a4" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi. Now maintained by perl5 porters.</source>
          <target state="translated">Jarkko Hietaniemi。现在由 perl5 移植者维护。</target>
        </trans-unit>
        <trans-unit id="f0bc884e41c8e0399ef072f3aad2d67eaa7fd5aa" translate="yes" xml:space="preserve">
          <source>JavaScript Traps</source>
          <target state="translated">JavaScript陷阱</target>
        </trans-unit>
        <trans-unit id="f2ef0f46c9cd103d2be6f2673d4379b347904df1" translate="yes" xml:space="preserve">
          <source>Jean Delvare provided the following table of different common terminal emulators and their support for the various attributes and others have helped me flesh it out:</source>
          <target state="translated">Jean Delvare提供了下表不同的常用终端仿真器及其对各种属性的支持,其他人也帮我把它具体化了。</target>
        </trans-unit>
        <trans-unit id="b63c65e75871d5c7820e4ea10cfd70f390f74d22" translate="yes" xml:space="preserve">
          <source>Jeff Okamoto &amp;lt;</source>
          <target state="translated">杰夫&amp;middot;冈本&amp;lt;</target>
        </trans-unit>
        <trans-unit id="7ec7c5d4610b8dd06ad086eed7d40f5d2aaef1a6" translate="yes" xml:space="preserve">
          <source>Jeff Okamoto, Tim Bunce, Nick Gianniotis, Steve Kelem, Gurusamy Sarathy and Larry Wall.</source>
          <target state="translated">Jeff Okamoto、Tim Bunce、Nick Gianniotis、Steve Kelem、Gurusamy Sarathy和Larry Wall。</target>
        </trans-unit>
        <trans-unit id="b3a656e0d05c4ded5764e8eee0b16063f85446f7" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden and Reini Urban provided greatly appreciated help to debug and polish &lt;code&gt;Sys::Syslog&lt;/code&gt; under Cygwin.</source>
          <target state="translated">Jerry D. Hedden和Reini Urban为在Cygwin下调试和完善 &lt;code&gt;Sys::Syslog&lt;/code&gt; 提供了极大的帮助。</target>
        </trans-unit>
        <trans-unit id="1a3cecc43a5465fa758b4f88b43cd646e6623b8f" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden, &amp;lt;jdhedden AT cpan DOT org&amp;gt;</source>
          <target state="translated">杰里&amp;middot;赫登（Jerry D.Hedden），&amp;lt;jpandden at cpan DOT org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ef645dbc725c293373ed9661992798b416e9b9b4" translate="yes" xml:space="preserve">
          <source>Joe Smith &amp;lt;Joe.Smith@inwap.com&amp;gt;, using the framework created by Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</source>
          <target state="translated">Joe Smith &amp;lt;Joe.Smith@inwap.com&amp;gt;，使用Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;创建的框架。</target>
        </trans-unit>
        <trans-unit id="c865a479b23a538482933eec4ec96a06755b572a" translate="yes" xml:space="preserve">
          <source>Johan Vromans &amp;lt;jvromans@squirrel.nl&amp;gt;</source>
          <target state="translated">Johan Vromans &amp;lt;jvromans@squirrel.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="bdfcbe7345fa5c91aff66147710f3cfd01971e09" translate="yes" xml:space="preserve">
          <source>Joins the separate strings of LIST into a single string with fields separated by the value of EXPR, and returns that new string. Example:</source>
          <target state="translated">将LIST的独立字符串连接成一个单一的字符串,字段用EXPR值分隔,并返回新的字符串。例子:将LIST中独立的字符串连接成一个单独的字符串,并以EXPR值分隔字段,然后返回新的字符串。</target>
        </trans-unit>
        <trans-unit id="8701a18a17d809f2f5e1d9461286d81392c749a1" translate="yes" xml:space="preserve">
          <source>Jon Orwant</source>
          <target state="translated">Jon Orwant</target>
        </trans-unit>
        <trans-unit id="9535723b8f84ea59122230a47649084f0880997b" translate="yes" xml:space="preserve">
          <source>Jon Orwant &amp;lt;</source>
          <target state="translated">乔恩&amp;middot;奥万特&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ddc19f76e720fe5e2b005501ad08de9eb7175b61" translate="yes" xml:space="preserve">
          <source>Joshua Chamas's Tie::Cache module may be useful as an expiration manager. (If you try this, let me know how it works out.)</source>
          <target state="translated">Joshua Chamas的Tie::Cache模块可能是有用的到期管理器。(如果你试过,让我知道效果如何。)</target>
        </trans-unit>
        <trans-unit id="272f944afb073e466e447521f217853887659759" translate="yes" xml:space="preserve">
          <source>Joshua ben Jore &amp;lt;jjore@cpan.org&amp;gt;</source>
          <target state="translated">约书亚&amp;middot;本&amp;middot;乔尔&amp;lt;jjore@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f8f06875505d336c6444e4ca735af60cc7f95b69" translate="yes" xml:space="preserve">
          <source>Judicious JavaScript programmers should take note of the following:</source>
          <target state="translated">聪明的JavaScript程序员应该注意以下几点。</target>
        </trans-unit>
        <trans-unit id="829558e61eb4ee30d56d5ca3997b5726751317c0" translate="yes" xml:space="preserve">
          <source>Juerd Waalboer &amp;lt;#####@juerd.nl&amp;gt;</source>
          <target state="translated">Juerd Waalboer &amp;lt;##### @ juerd.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d89d24d0ba5d206a7a244711764b4287f3aa5c8f" translate="yes" xml:space="preserve">
          <source>Juerd Waalboer &amp;lt;#####@juerd.nl&amp;gt;, with the help of many Perl Monks.</source>
          <target state="translated">在许多Perl僧侣的帮助下，Juerd Waalboer &amp;lt;##### @ juerd.nl&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="5f3e3f9c72e3b6a4486ec8a37b16219f4828a4df" translate="yes" xml:space="preserve">
          <source>Just a quick hint here for all those CGI programmers who can't figure out how on earth to get past that 'waiting for input' prompt, when running their CGI script from the command-line, try something like this:</source>
          <target state="translated">对于那些不知道如何通过 &quot;等待输入 &quot;提示的CGI程序员,当他们从命令行运行CGI脚本时,请尝试这样的提示。</target>
        </trans-unit>
        <trans-unit id="33892714232f2855fd91a542cad5d54aa9bb7133" translate="yes" xml:space="preserve">
          <source>Just as P5P collectively maintains the codebase, we collectively maintain the documentation. Writing a particular bit of documentation doesn't give an author control of the future of that documentation. At the same time, just as source code changes should match the style of their surrounding blocks, so should documentation changes.</source>
          <target state="translated">正如P5P集体维护代码库一样,我们也集体维护文档。编写一个特定的文档并不能让作者控制该文档的未来。同时,就像源代码的变化应该与周围区块的风格相匹配一样,文档的变化也应该如此。</target>
        </trans-unit>
        <trans-unit id="0aaf4ef0c9b344d1374053d108e2052e07431e98" translate="yes" xml:space="preserve">
          <source>Just as PERL_IMPLICIT_CONTEXT provides a way to bundle up everything that the interpreter knows about itself and pass it around, so too are there plans to allow the interpreter to bundle up everything it knows about the environment it's running on. This is enabled with the PERL_IMPLICIT_SYS macro. Currently it only works with USE_ITHREADS on Windows.</source>
          <target state="translated">就像PERL_IMPLICIT_CONTEXT提供了一种方法来捆绑解释器所知道的关于它自己的一切并将其传递出去一样,也有计划允许解释器捆绑它所知道的关于它所运行的环境的一切。这可以通过 PERL_IMPLICIT_SYS 宏来实现。目前它只适用于 Windows 上的 USE_ITHREADS。</target>
        </trans-unit>
        <trans-unit id="62e8906be80151cd95246c62df9e4761d5bc2332" translate="yes" xml:space="preserve">
          <source>Just as above, but maps from characters (like &quot;\xE9&quot;, lowercase e-acute) to characters (like &quot;e&quot;).</source>
          <target state="translated">和上面一样,但从字符(如&quot;\xE9&quot;,小写e-acute)映射到字符(如 &quot;e&quot;)。</target>
        </trans-unit>
        <trans-unit id="07b1550eae10318438b9e4b01a4b0de0c550fc87" translate="yes" xml:space="preserve">
          <source>Just as in all regular expressions, the pattern can be built up by including variables that are interpolated at regex compilation time. Care must be taken to ensure that you are getting what you expect. For example:</source>
          <target state="translated">就像在所有的正则表达式中一样,模式可以通过包含在regex编译时插值的变量来建立。必须注意确保你得到的是你期望的东西。例如</target>
        </trans-unit>
        <trans-unit id="fe8a855ccb8465e6e734bba6c85f798237a3ef83" translate="yes" xml:space="preserve">
          <source>Just as in the previous regexp, the first quantifier &lt;code&gt;.??&lt;/code&gt; can match earliest at position &lt;code&gt;'a'&lt;/code&gt; , so it does. The second quantifier is greedy, so it matches &lt;code&gt;mm&lt;/code&gt; , and the third matches the rest of the string.</source>
          <target state="translated">与前面的正则表达式一样，第一个量词 &lt;code&gt;.??&lt;/code&gt; 可以在位置 &lt;code&gt;'a'&lt;/code&gt; 最早匹配，所以可以。第二个量词是贪婪的，因此它匹配 &lt;code&gt;mm&lt;/code&gt; ，第三个量词匹配字符串的其余部分。</target>
        </trans-unit>
        <trans-unit id="54aa745852ee956f0149292237b30dcf7a75e890" translate="yes" xml:space="preserve">
          <source>Just as in the shell, a backslashed bareword following the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; means the same thing as a single-quoted string does:</source>
          <target state="translated">就像在外壳程序中一样，在 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 之后加上反斜杠的裸字与单引号字符串的含义相同：</target>
        </trans-unit>
        <trans-unit id="faebd7db1f892818770103ce78accf7713eb730f" translate="yes" xml:space="preserve">
          <source>Just as numeric comparisons can be autogenerated from the method for &lt;code&gt;'&amp;lt;=&amp;gt;'&lt;/code&gt; , string comparisons can be autogenerated from that for &lt;code&gt;'cmp'&lt;/code&gt; :</source>
          <target state="translated">正如可以从 &lt;code&gt;'&amp;lt;=&amp;gt;'&lt;/code&gt; 的方法自动生成数字比较一样，也可以从 &lt;code&gt;'cmp'&lt;/code&gt; 的方法自动生成字符串比较：</target>
        </trans-unit>
        <trans-unit id="8df19f323bb6b48a43ad85680dc0529bf785f1c3" translate="yes" xml:space="preserve">
          <source>Just as with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, no shell escapes happen when you &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; a list. Further examples of this can be found in &lt;a href=&quot;perlipc#Safe-Pipe-Opens&quot;&gt;Safe Pipe Opens in perlipc&lt;/a&gt;.</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 一样，当您 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 列表时，不会发生外壳转义。有关更多示例，请参见&lt;a href=&quot;perlipc#Safe-Pipe-Opens&quot;&gt;perlipc&lt;/a&gt;中的&amp;ldquo; 安全管道开口&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e255de21718ad7422221bd6f42f8ec7acc85a6f3" translate="yes" xml:space="preserve">
          <source>Just as with any Perl subroutine, all of the arguments passed in &lt;code&gt;@_&lt;/code&gt; are aliases to the original argument. This includes the object itself. If you assign directly to &lt;code&gt;$_[0]&lt;/code&gt; you will change the contents of the variable that holds the reference to the object. We recommend that you don't do this unless you know exactly what you're doing.</source>
          <target state="translated">正如任何Perl子，都在传递的参数 &lt;code&gt;@_&lt;/code&gt; 是别名到原来的说法。这包括对象本身。如果直接分配给 &lt;code&gt;$_[0]&lt;/code&gt; ，则将更改保存对象引用的变量的内容。我们建议您不要这样做，除非您确切知道自己在做什么。</target>
        </trans-unit>
        <trans-unit id="fccd05d91f9ee0d9fbbfbf38723d03e8a7c74f00" translate="yes" xml:space="preserve">
          <source>Just as with any signal, you can use &lt;code&gt;sigaction($rtsig, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, $oa)&lt;/code&gt; to retrieve the installed signal handler (or, rather, the signal action).</source>
          <target state="translated">与任何信号一样，您可以使用 &lt;code&gt;sigaction($rtsig, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, $oa)&lt;/code&gt; 来检索已安装的信号处理程序（或更确切地说，是信号操作）。</target>
        </trans-unit>
        <trans-unit id="1dc08a9e71893fc4c8e0aca93a96bf0beab842b5" translate="yes" xml:space="preserve">
          <source>Just because a lexical variable is lexically (also called statically) scoped to its enclosing block, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; FILE, this doesn't mean that within a function it works like a C static. It normally works more like a C auto, but with implicit garbage collection.</source>
          <target state="translated">仅仅因为词法变量在词法（也称为静态）范围内限定于其封闭块 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; FILE，这并不意味着该函数在函数内的作用类似于C static。通常，它的工作方式类似于C auto，但具有隐式垃圾回收功能。</target>
        </trans-unit>
        <trans-unit id="90c499a655f030c92a71b95e9b2689970ea91b8a" translate="yes" xml:space="preserve">
          <source>Just because you</source>
          <target state="translated">就因为你</target>
        </trans-unit>
        <trans-unit id="109e6f9598b8183bb06ce69968e5c56fc8392a6f" translate="yes" xml:space="preserve">
          <source>Just before HP took over Compaq, some systems were renamed. the link that contained the explanation is dead, so here's a short summary:</source>
          <target state="translated">就在惠普接管康柏之前,一些系统被重新命名.包含解释的链接已经死了,所以这里有一个简短的总结。</target>
        </trans-unit>
        <trans-unit id="75a3cd456f36493a47889dab1eae3ee74e772ac3" translate="yes" xml:space="preserve">
          <source>Just before removing a directory (after having successfully removed everything it contained), &lt;code&gt;remove_tree&lt;/code&gt; attempted to set the permissions on the directory to ensure it could be removed and failed. Program execution continues, but the directory may possibly not be deleted.</source>
          <target state="translated">就在删除目录之前（成功删除其中包含的所有内容之后）， &lt;code&gt;remove_tree&lt;/code&gt; 尝试在目录上设置权限，以确保可以删除该目录并使其失败。程序执行继续，但是目录可能未删除。</target>
        </trans-unit>
        <trans-unit id="9cff4cf2ef85b7a7babbfc6ed8ae94ad00cf8c95" translate="yes" xml:space="preserve">
          <source>Just don't forget that you have to put a semicolon on the end to finish the statement, as Perl doesn't know you're not going to try to do this:</source>
          <target state="translated">只是不要忘了,你必须在最后加上分号来完成语句,因为Perl不知道你不会尝试这样做。</target>
        </trans-unit>
        <trans-unit id="de3dbf5e42e97a50f069394cda4a6442ac1d1765" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, but implicitly appends a newline. &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; LIST&lt;/code&gt; is simply an abbreviation for &lt;code&gt;{ &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $\ = &quot;\n&quot;; &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; LIST }&lt;/code&gt; . To use FILEHANDLE without a LIST to print the contents of &lt;code&gt;$_&lt;/code&gt; to it, you must use a real filehandle like &lt;code&gt;FH&lt;/code&gt; , not an indirect one like &lt;code&gt;$fh&lt;/code&gt; .</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 一样，但是隐式地添加了换行符。 &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; LIST&lt;/code&gt; 只是 &lt;code&gt;{ &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $\ = &quot;\n&quot;; &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; LIST }&lt;/code&gt; 的缩写。打印清单}。要使用不带LIST的FILEHANDLE向其中打印 &lt;code&gt;$_&lt;/code&gt; 的内容，必须使用像 &lt;code&gt;FH&lt;/code&gt; 这样的真实文件句柄，而不是像 &lt;code&gt;$fh&lt;/code&gt; 这样的间接文件句柄。</target>
        </trans-unit>
        <trans-unit id="602502b6c9a3a727e615412b86a9aecefaaebcdb" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, but implicitly appends a newline. &lt;code&gt;&lt;a href=&quot;say&quot;&gt;say&lt;/a&gt; LIST&lt;/code&gt; is simply an abbreviation for &lt;code&gt;{ &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; $\ = &quot;\n&quot;; &lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; LIST }&lt;/code&gt; . To use FILEHANDLE without a LIST to print the contents of &lt;code&gt;$_&lt;/code&gt; to it, you must use a real filehandle like &lt;code&gt;FH&lt;/code&gt; , not an indirect one like &lt;code&gt;$fh&lt;/code&gt; .</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 一样，但是隐式地添加了换行符。 &lt;code&gt;&lt;a href=&quot;say&quot;&gt;say&lt;/a&gt; LIST&lt;/code&gt; 只是 &lt;code&gt;{ &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; $\ = &quot;\n&quot;; &lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; LIST }&lt;/code&gt; 的缩写。打印清单}。要使用不带LIST的FILEHANDLE向其中打印 &lt;code&gt;$_&lt;/code&gt; 的内容，必须使用像 &lt;code&gt;FH&lt;/code&gt; 这样的真实文件句柄，而不是像 &lt;code&gt;$fh&lt;/code&gt; 这样的间接文件句柄。</target>
        </trans-unit>
        <trans-unit id="841a87198bd8d5b2b617ad09071d079bbef63265" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;SAVEFREESV&lt;/code&gt; , but mortalizes &lt;code&gt;sv&lt;/code&gt; at the end of the current scope instead of decrementing its reference count. This usually has the effect of keeping &lt;code&gt;sv&lt;/code&gt; alive until the statement that called the currently live scope has finished executing.</source>
          <target state="translated">就像 &lt;code&gt;SAVEFREESV&lt;/code&gt; 一样，但是在当前范围的末尾使 &lt;code&gt;sv&lt;/code&gt; 无效，而不是减少其引用计数。这通常可以使 &lt;code&gt;sv&lt;/code&gt; 保持活动状态，直到调用当前活动范围的语句完成执行为止。</target>
        </trans-unit>
        <trans-unit id="bdee811de63331b1e390b9478886674b8221df6d" translate="yes" xml:space="preserve">
          <source>Just like alternation, quantifiers are also susceptible to backtracking. Here is a step-by-step analysis of the example</source>
          <target state="translated">就像交替一样,量词也是容易被回溯的。下面就以这个例子来逐步分析一下</target>
        </trans-unit>
        <trans-unit id="24cfeb3771fb43ef585a2f529448474ab41a12a3" translate="yes" xml:space="preserve">
          <source>Just like capa, but only uses a cache from the last time we asked the server, so as to avoid asking more than once.</source>
          <target state="translated">就像capa一样,但只使用上次向服务器询问时的缓存,这样可以避免多次询问。</target>
        </trans-unit>
        <trans-unit id="c07daab474d2a24a41bbf91648b44cb45c039da4" translate="yes" xml:space="preserve">
          <source>Just like have_compiler but for C++ instead of C.</source>
          <target state="translated">就像have_compiler一样,不过是C++而不是C。</target>
        </trans-unit>
        <trans-unit id="1ed1a130170978e2a4e7086c7c7306a25c8e7b33" translate="yes" xml:space="preserve">
          <source>Just like special scalars and arrays, there are also special hashes. The most well known of these is &lt;code&gt;%ENV&lt;/code&gt; which contains environment variables. Read all about it (and other special variables) in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">就像特殊的标量和数组一样，也有特殊的散列。其中最知名的是 &lt;code&gt;%ENV&lt;/code&gt; ，其中包含环境变量。在&lt;a href=&quot;perlvar&quot;&gt;perlvar中&lt;/a&gt;阅读有关它的所有信息（以及其他特殊变量）。</target>
        </trans-unit>
        <trans-unit id="19b37fcf66fa778fbd1b5d5fc50d7060df9d05e7" translate="yes" xml:space="preserve">
          <source>Just like the &quot;strict&quot; pragma any of these categories can be combined</source>
          <target state="translated">就像 &quot;严格 &quot;原则一样,这些类别中的任何一个都可以结合起来。</target>
        </trans-unit>
        <trans-unit id="82e865fa7feb693e6080cbf3d25a874d28e9c584" translate="yes" xml:space="preserve">
          <source>Just pressing Enter will do the most recent operation again - it's a blessing when stepping through miles of source code.</source>
          <target state="translated">只需按下Enter键,就会再次进行最新的操作--这在浏览数英里长的源代码时是个福音。</target>
        </trans-unit>
        <trans-unit id="fe244a50fe6aded057e3eae12f0a93027edb2381" translate="yes" xml:space="preserve">
          <source>Just say:</source>
          <target state="translated">只是说。</target>
        </trans-unit>
        <trans-unit id="d8c1011fd0f056428d5a8834a2c765887dde0f8b" translate="yes" xml:space="preserve">
          <source>Just set the integer value of the top stack entry to its negation.</source>
          <target state="translated">只需将顶层栈条目的整数值设置为其否定值即可。</target>
        </trans-unit>
        <trans-unit id="c7727ca967ac9b4f317d7c673ab3882351fa9d9d" translate="yes" xml:space="preserve">
          <source>Just simple slots for storing information about the line and the file the link was encountered in. Has to be filled in manually.</source>
          <target state="translated">只是简单的槽位,用于存储该行和链接所遇到的文件信息。必须手动填写。</target>
        </trans-unit>
        <trans-unit id="6b1d3328e0f08111bb8c2f1b7ffdbdee9651e208" translate="yes" xml:space="preserve">
          <source>Just to show that C programmers can write C in any programming language, if you prefer a more C-like solution, the following script makes the substitution have the same case, letter by letter, as the original. (It also happens to run about 240% slower than the Perlish solution runs.) If the substitution has more characters than the string being substituted, the case of the last character is used for the rest of the substitution.</source>
          <target state="translated">为了证明C程序员可以用任何编程语言编写C语言,如果你喜欢一个更像C语言的解决方案,下面的脚本可以使替换的字母与原来的字母具有相同的大小写,(它的运行速度也比Perlish解决方案慢240%)。(它的运行速度比Perlish的解决方案慢了240%。)如果替换的字符数比被替换的字符串多,则最后一个字符的大小写将用于替换的其余部分。</target>
        </trans-unit>
        <trans-unit id="4a091e09bfa339a10150c33a9aaadd4282459277" translate="yes" xml:space="preserve">
          <source>Just what it says, you're missing that file. MakeMaker uses it to determine if perl has been rebuilt since the Makefile was made. It's a bit of a bug that it halts installation.</source>
          <target state="translated">就像它说的那样,你缺少那个文件。MakeMaker用它来判断perl是否在Makefile制作后被重建。它停止安装是个小毛病。</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="66d19ca0f4158063f6e062dbc4b43cb2360ddc04" translate="yes" xml:space="preserve">
          <source>KEY/VALUE PAIR LIST FUNCTIONS</source>
          <target state="translated">钥匙/值组列表功能</target>
        </trans-unit>
        <trans-unit id="d873371555253b7c518cf82fe5be999156ffe1fc" translate="yes" xml:space="preserve">
          <source>KNOWN BUGS</source>
          <target state="translated">已知缺陷</target>
        </trans-unit>
        <trans-unit id="d7d37390d4b0162eaa199e8a40421a0fd151d9d4" translate="yes" xml:space="preserve">
          <source>KNOWN ISSUES</source>
          <target state="translated">已知问题</target>
        </trans-unit>
        <trans-unit id="49f7d6b044c08905cf6f12f8a90c2d7d80dd7870" translate="yes" xml:space="preserve">
          <source>KNOWN PROBLEMS</source>
          <target state="translated">已知问题</target>
        </trans-unit>
        <trans-unit id="ff0775fcc23b465723521876b29263b74199fe74" translate="yes" xml:space="preserve">
          <source>Karen Etheridge</source>
          <target state="translated">Karen Etheridge</target>
        </trans-unit>
        <trans-unit id="6587b068c21cd74b421d84d8dd8d104ffb717b74" translate="yes" xml:space="preserve">
          <source>Kawai,Takanori provides a Japanese translation of a very old version of this manpage at &lt;a href=&quot;http://homepage3.nifty.com/hippo2000/perltips/CPAN.htm&quot;&gt;http://homepage3.nifty.com/hippo2000/perltips/CPAN.htm&lt;/a&gt;</source>
          <target state="translated">Kawai，Takanori在&lt;a href=&quot;http://homepage3.nifty.com/hippo2000/perltips/CPAN.htm&quot;&gt;http://homepage3.nifty.com/hippo2000/perltips/CPAN.htm上&lt;/a&gt;提供了此手册的非常旧版本的日语翻译。</target>
        </trans-unit>
        <trans-unit id="dcff63b147198a52939742818ee2ef592a205e7e" translate="yes" xml:space="preserve">
          <source>Keep features/concepts as orthogonal as possible.</source>
          <target state="translated">尽量保持特征/概念的正交性。</target>
        </trans-unit>
        <trans-unit id="8e7b10c1d652b6b04a656b434f5b39616ccf1a50" translate="yes" xml:space="preserve">
          <source>Keep hacking until the tests pass.</source>
          <target state="translated">继续开黑,直到测试通过。</target>
        </trans-unit>
        <trans-unit id="af7d72158e7608d9c4b48305b5171ef45c75b0c8" translate="yes" xml:space="preserve">
          <source>Keep in mind that</source>
          <target state="translated">请记住</target>
        </trans-unit>
        <trans-unit id="ed0120a6a4cb952cfa71da323a4afdbfcf12e27d" translate="yes" xml:space="preserve">
          <source>Keep in mind that even if you think your code is not locale-aware, it may call a C library function that is. Hopefully the man page for such a function will indicate that dependency, but the documentation is imperfect.</source>
          <target state="translated">请记住,即使你认为你的代码不具有本地意识,它也可能会调用一个具有本地意识的 C 库函数。希望这样一个函数的手册页会指出这种依赖性,但文档并不完善。</target>
        </trans-unit>
        <trans-unit id="86f6615f078bb4d01730cb8fac56589317fa9a58" translate="yes" xml:space="preserve">
          <source>Keep in mind that only the first several &quot;odd-numbered&quot; buckets are used, so the information on size of the &quot;odd-numbered&quot; buckets which are not used is probably meaningless.</source>
          <target state="translated">请记住,只有前几个 &quot;奇数 &quot;桶才会被使用,所以没有被使用的 &quot;奇数 &quot;桶的大小信息可能没有意义。</target>
        </trans-unit>
        <trans-unit id="4ef95230ae4c52baacdb1c4884acabd7049d178c" translate="yes" xml:space="preserve">
          <source>Keep in mind that these compiler and linker settings will also be used when building CPAN modules. For XS modules to be compiled as a universal binary, any libraries it links to must also be universal binaries. The system libraries that Apple includes with the 10.4u SDK are all universal, but user-installed libraries may need to be re-installed as universal binaries.</source>
          <target state="translated">请记住,这些编译器和链接器的设置也将在构建CPAN模块时使用。要想将XS模块编译成通用二进制文件,它所链接的任何库也必须是通用二进制文件。苹果公司在10.4u SDK中包含的系统库都是通用的,但用户安装的库可能需要重新安装为通用二进制文件。</target>
        </trans-unit>
        <trans-unit id="9eeeda7b97916fa01cabcb38bff49279f0e6a0bb" translate="yes" xml:space="preserve">
          <source>Keep in mind that you can always supply</source>
          <target state="translated">请记住,您可以随时提供</target>
        </trans-unit>
        <trans-unit id="64a46910748217f86efd6627ba753bed01e58a81" translate="yes" xml:space="preserve">
          <source>Keep info about source lines on which a subroutine is defined.</source>
          <target state="translated">保存定义子程序的源行信息。</target>
        </trans-unit>
        <trans-unit id="f47e40b91fc5362642fcbe01770e5ce787e6ccdc" translate="yes" xml:space="preserve">
          <source>Keep it fast, simple, and useful.</source>
          <target state="translated">保持快速、简单、有用。</target>
        </trans-unit>
        <trans-unit id="a180636219ad9f73429c85412c6186e17a5910d6" translate="yes" xml:space="preserve">
          <source>Keep it open and exciting to use/patch/advocate Perl everywhere.</source>
          <target state="translated">保持它的开放性,让各地的Perl使用/补丁/倡导者都感到兴奋。</target>
        </trans-unit>
        <trans-unit id="c51474355aad094e34cfbd22e2141d08f6d33f4f" translate="yes" xml:space="preserve">
          <source>Keep more files open than the system permits</source>
          <target state="translated">打开的文件数量超过系统允许的数量</target>
        </trans-unit>
        <trans-unit id="14b49f2a3e5ec0e1cdb997e3d03cb485633984fa" translate="yes" xml:space="preserve">
          <source>Keep sets of symbol names palatable to the VMS linker</source>
          <target state="translated">让VMS链接器易于理解的符号名称集。</target>
        </trans-unit>
        <trans-unit id="b3a15ca125f2b3af86ad1584e6c4e2aafb908eae" translate="yes" xml:space="preserve">
          <source>Keep your documentation near the code it documents (&quot;inline&quot; documentation). Include POD for a given method right above that method's subroutine. This makes it easier to keep the documentation up to date, and avoids having to document each piece of code twice (once in POD and once in comments).</source>
          <target state="translated">让你的文档靠近它所记录的代码(&quot;内联 &quot;文档)。在一个给定方法的子程序的上方加入该方法的POD,这样可以更容易地保持文档的更新,并避免将每段代码记录两次(一次在POD中,一次在注释中)。这使得文档更容易保持更新,并避免了每段代码都要记录两次(一次在POD中,一次在注释中)。</target>
        </trans-unit>
        <trans-unit id="76d3b7f70d495b2b8a3270d608b55e23f648e0ce" translate="yes" xml:space="preserve">
          <source>Keeping track of the highest cached record. This would allow reads-in-a-row to skip the cache lookup faster (if reading from 1..N with empty cache at start, the last cached value will be always N-1).</source>
          <target state="translated">跟踪最高的缓存记录。这将允许一行中的读数更快地跳过缓存查找(如果从1...N开始读,缓存为空,则最后的缓存值将总是N-1)。</target>
        </trans-unit>
        <trans-unit id="4c7c7465de1db7f41ca1d8bdef4219bff0d7c120" translate="yes" xml:space="preserve">
          <source>Ken Williams &amp;lt;ken@mathforum.org&amp;gt;</source>
          <target state="translated">肯&amp;middot;威廉姆斯（Ken Williams）&amp;lt;ken@mathforum.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="abd59a29e35516d1b9c3ad5018ade24ad931f61e" translate="yes" xml:space="preserve">
          <source>Ken Williams, &amp;lt;ken@mathforum.org&amp;gt;</source>
          <target state="translated">肯&amp;middot;威廉姆斯（Ken Williams），&amp;lt;ken@mathforum.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0d1222a0218c97e36123b63438f7b4e4edcb6a3e" translate="yes" xml:space="preserve">
          <source>Ken Williams, kwilliams@cpan.org</source>
          <target state="translated">Ken Williams,kwilliams@cpan.org</target>
        </trans-unit>
        <trans-unit id="ee0c77223410ec7a299fe0a1261f164a0c42279d" translate="yes" xml:space="preserve">
          <source>Kenneth Albanowski (&amp;lt;kjahds@kjahds.com&amp;gt;), subsequently</source>
          <target state="translated">肯尼斯&amp;middot;阿尔巴诺夫斯基（&amp;lt;kjahds@kjahds.com&amp;gt;），随后</target>
        </trans-unit>
        <trans-unit id="348f36b3e5bbe51567b4fb414536380d7187542b" translate="yes" xml:space="preserve">
          <source>Kernel threads are the next step in thread evolution. The OS knows about kernel threads, and makes allowances for them. The main difference between a kernel thread and a user-mode thread is blocking. With kernel threads, things that block a single thread don't block other threads. This is not the case with user-mode threads, where the kernel blocks at the process level and not the thread level.</source>
          <target state="translated">内核线程是线程进化的下一步。操作系统知道内核线程,并为它们留有余地。内核线程和用户模式线程的主要区别是阻塞。对于内核线程,阻塞一个线程的事情不会阻塞其他线程。而用户模式线程则不是这样,内核是在进程级而不是线程级进行阻塞。</target>
        </trans-unit>
        <trans-unit id="259173b7d729d8dc6a66caf8b3aace35a75e8f99" translate="yes" xml:space="preserve">
          <source>Kevin Ryde</source>
          <target state="translated">Kevin Ryde</target>
        </trans-unit>
        <trans-unit id="a297e34f70da8957366c0d560c60295f4ab16d2a" translate="yes" xml:space="preserve">
          <source>Key feature milestones include:</source>
          <target state="translated">主要功能里程碑包括:</target>
        </trans-unit>
        <trans-unit id="bc06e1d8824d5b7cbd20d018550616dba1eeb7a3" translate="yes" xml:space="preserve">
          <source>Key naming</source>
          <target state="translated">关键命名</target>
        </trans-unit>
        <trans-unit id="0c71372d5d9156fb958ad05c3a06f64214fe7926" translate="yes" xml:space="preserve">
          <source>Key/Value Hash Slices</source>
          <target state="translated">键/值哈希片</target>
        </trans-unit>
        <trans-unit id="0a8746998a05aa11ad9c2dab8f6c1868e6458dab" translate="yes" xml:space="preserve">
          <source>Key/value pairs are extra information about the module. Fields include:</source>
          <target state="translated">键/值对是关于模块的额外信息。字段包括:</target>
        </trans-unit>
        <trans-unit id="26057b24ccfdf1266160f8baf076207f8248b2c2" translate="yes" xml:space="preserve">
          <source>Keyed on perl version this contains ISO formatted versions of the release dates, as gleaned from &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlhist.html&quot;&gt;perlhist&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlhist.html&quot;&gt;perlhist&lt;/a&gt;收集，以perl版本为键，其中包含发行日期的ISO格式版本。</target>
        </trans-unit>
        <trans-unit id="ac519cac59842ef7ce692b39ea336e75df75601a" translate="yes" xml:space="preserve">
          <source>Killing the parent process</source>
          <target state="translated">终止父进程</target>
        </trans-unit>
        <trans-unit id="76e63bc788196f0fc365bdd0b40b720b363e2116" translate="yes" xml:space="preserve">
          <source>Kirrily &quot;Skud&quot; Robert &amp;lt;skud@cpan.org&amp;gt;</source>
          <target state="translated">Kirrily&amp;ldquo; Skud&amp;rdquo; Robert &amp;lt;skud@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="132f84c02455b94d400579a7b40a518ce274e293" translate="yes" xml:space="preserve">
          <source>Know what you're testing. Read the docs, and the source.</source>
          <target state="translated">知道你在测试什么。阅读文档和源代码。</target>
        </trans-unit>
        <trans-unit id="90303445974fa3fe293cc60d64eaeca6bb4d14c9" translate="yes" xml:space="preserve">
          <source>Known Problems</source>
          <target state="translated">已知问题</target>
        </trans-unit>
        <trans-unit id="eb6d28effd6acc1d20ab0115a46d456361c67007" translate="yes" xml:space="preserve">
          <source>Known Problems with Perl on Hurd</source>
          <target state="translated">Hurd上Perl的已知问题</target>
        </trans-unit>
        <trans-unit id="b35d4f63dc3fe926a9db173d1f73bb17b3726246" translate="yes" xml:space="preserve">
          <source>Known problems</source>
          <target state="translated">已知问题</target>
        </trans-unit>
        <trans-unit id="773f5eaba0582fa827eb62a803e54c124b33061b" translate="yes" xml:space="preserve">
          <source>Known to be broken for 5.8.0 (but 5.6.1 and 5.7.2 can be used):</source>
          <target state="translated">已知在5.8.0中被破坏(但5.6.1和5.7.2可以使用)。</target>
        </trans-unit>
        <trans-unit id="cf8178f760b75a0d75931dde9fe9ac37025b060d" translate="yes" xml:space="preserve">
          <source>Korean Encodings</source>
          <target state="translated">韩语编码</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="a5009766b33ae437bdfad28ba25b247aa809447e" translate="yes" xml:space="preserve">
          <source>LANGUAGE CLASS HIERARCHIES</source>
          <target state="translated">语言类层次结构</target>
        </trans-unit>
        <trans-unit id="306bdaf58d73ea39af3b1402b65b299e6a4795ee" translate="yes" xml:space="preserve">
          <source>LAST UPDATE</source>
          <target state="translated">最后更新</target>
        </trans-unit>
        <trans-unit id="823feb18075201a2009bf899a2b4bee49397d8df" translate="yes" xml:space="preserve">
          <source>LC_TIME</source>
          <target state="translated">LC_TIME</target>
        </trans-unit>
        <trans-unit id="7c53807c1836659b4436f686a99f72b3f7ea4a20" translate="yes" xml:space="preserve">
          <source>LDLOADLIBS and EXTRALIBS are always identical under Win32, and BSLOADLIBS and LD_RUN_PATH are always empty (this may change in future).</source>
          <target state="translated">在Win32下,LDLOADLIBS和EXTRALIBS总是相同的,而BSLOADLIBS和LD_RUN_PATH总是空的(将来可能会改变)。</target>
        </trans-unit>
        <trans-unit id="27d827eb4792696500b4c73ad4ddf3c959ae3870" translate="yes" xml:space="preserve">
          <source>LDLOADLIBS and LD_RUN_PATH</source>
          <target state="translated">LDLOADLIBS和LD_RUN_PATH。</target>
        </trans-unit>
        <trans-unit id="1635e0d5ca894812009c83cf6cdbe20b68728252" translate="yes" xml:space="preserve">
          <source>LDLOADLIBS contains both the libraries found based on &lt;code&gt;$potential_libs&lt;/code&gt; and the CRTLs, if any, specified in Config.pm. EXTRALIBS contains just those libraries found based on &lt;code&gt;$potential_libs&lt;/code&gt; . BSLOADLIBS and LD_RUN_PATH are always empty.</source>
          <target state="translated">LDLOADLIBS包含基于 &lt;code&gt;$potential_libs&lt;/code&gt; 找到的库和在Config.pm中指定的CRTL（如果有）。EXTRALIBS仅包含基于 &lt;code&gt;$potential_libs&lt;/code&gt; 找到的那些库。BSLOADLIBS和LD_RUN_PATH始终为空。</target>
        </trans-unit>
        <trans-unit id="256f68025172870d1f3c1210b89212eca54d2c93" translate="yes" xml:space="preserve">
          <source>LDLOADLIBS's default is changed to $Config{libs}.</source>
          <target state="translated">LDLOADLIBS的默认值改为$Config{libs}。</target>
        </trans-unit>
        <trans-unit id="31a999d2e445df6d94c2d10d2f899c4b7a408247" translate="yes" xml:space="preserve">
          <source>LD_LIBRARY_PATH</source>
          <target state="translated">LD_LIBRARY_PATH</target>
        </trans-unit>
        <trans-unit id="9492fe99bfc78ed50462f6bcf892cde2a90aadb5" translate="yes" xml:space="preserve">
          <source>LEAVE_SRC</source>
          <target state="translated">LEAVE_SRC</target>
        </trans-unit>
        <trans-unit id="8753fd6c3b8da3cc6d317b80329ed3b40b2aa912" translate="yes" xml:space="preserve">
          <source>LETTERS</source>
          <target state="translated">LETTERS</target>
        </trans-unit>
        <trans-unit id="f481cc60f17adbd0734ec4396c3eec7ff4f97ae1" translate="yes" xml:space="preserve">
          <source>LEVEL</source>
          <target state="translated">LEVEL</target>
        </trans-unit>
        <trans-unit id="8ebe6b4ea1f79cdf5a0cfe5997e4373110b1513a" translate="yes" xml:space="preserve">
          <source>LIB should only be set at &lt;code&gt;perl Makefile.PL&lt;/code&gt; time but is allowed as a MakeMaker argument. It has the effect of setting both INSTALLPRIVLIB and INSTALLSITELIB to that value regardless any explicit setting of those arguments (or of PREFIX). INSTALLARCHLIB and INSTALLSITEARCH are set to the corresponding architecture subdirectory.</source>
          <target state="translated">LIB应该仅在 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 时设置，但允许作为MakeMaker参数。它具有将INSTALLPRIVLIB和INSTALLSITELIB都设置为该值的效果，而与这些参数（或PREFIX）的任何显式设置无关。INSTALLARCHLIB和INSTALLSITEARCH设置为相应的体系结构子目录。</target>
        </trans-unit>
        <trans-unit id="00484abc2f0a64aaebb7808382f0c80f8b800d94" translate="yes" xml:space="preserve">
          <source>LIBPTH, BASE_IMPORT, NLM_VERSION, MPKTOOL, TOOLPATH, BOOT_SYMBOL, NLM_SHORT_NAME, INCLUDE, PATH, MM_NW5_REVISION</source>
          <target state="translated">LIBPTH,BASE_IMPORT,NLM_VERSION,MPKTOOL,TOOLPATH,BOOT_SYMBOL,NLM_SHORT_NAME,INCLUDE,PATH,MM_NW5_REVISION。</target>
        </trans-unit>
        <trans-unit id="6e0ad2b047414107e8ce2f294fa40d216b5b68f9" translate="yes" xml:space="preserve">
          <source>LICENCE</source>
          <target state="translated">LICENCE</target>
        </trans-unit>
        <trans-unit id="0417c3cd20e5957970bf6e0315ba11993f41a4ef" translate="yes" xml:space="preserve">
          <source>LICENCE AND COPYRIGHT</source>
          <target state="translated">许可和版权</target>
        </trans-unit>
        <trans-unit id="0398ccd0f49298b10a3d76a47800d2ebecd49859" translate="yes" xml:space="preserve">
          <source>LICENSE</source>
          <target state="translated">LICENSE</target>
        </trans-unit>
        <trans-unit id="00e15f5838907cd7e1d4b00639d57748e292cb00" translate="yes" xml:space="preserve">
          <source>LIGHTWEIGHT CALLBACKS</source>
          <target state="translated">轻量级回访</target>
        </trans-unit>
        <trans-unit id="929a3a64284b80f705b148843a13caea7da8d500" translate="yes" xml:space="preserve">
          <source>LIMITATIONS</source>
          <target state="translated">LIMITATIONS</target>
        </trans-unit>
        <trans-unit id="e0e14c87e0e2d089b660f73f34d498e64b436810" translate="yes" xml:space="preserve">
          <source>LIMITATIONS of *-x*</source>
          <target state="translated">对*-x*的限制</target>
        </trans-unit>
        <trans-unit id="582303292e0d9bb459bbce59d367e726e77b22ef" translate="yes" xml:space="preserve">
          <source>LIMITATIONS of &lt;b&gt;-x&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;-x的&lt;/b&gt;局限性&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="83fa9b97f00ca753b1e5690c43dd3d3361c9665b" translate="yes" xml:space="preserve">
          <source>LIMITS</source>
          <target state="translated">LIMITS</target>
        </trans-unit>
        <trans-unit id="735cf1665d0fd36f4865e4bc7439abe369572e04" translate="yes" xml:space="preserve">
          <source>LIST</source>
          <target state="translated">LIST</target>
        </trans-unit>
        <trans-unit id="c717fe4bbb26a57f5091a39f5ae5c04c8ba67f80" translate="yes" xml:space="preserve">
          <source>LIST OF LANGUAGES</source>
          <target state="translated">语文清单</target>
        </trans-unit>
        <trans-unit id="7de1e2b32d16e9fef7b2a9299320e7f3351fbed7" translate="yes" xml:space="preserve">
          <source>LIST OF UTILITIES</source>
          <target state="translated">公用事业清单</target>
        </trans-unit>
        <trans-unit id="567a6688f397cbb26479212b5e88b04513465d6e" translate="yes" xml:space="preserve">
          <source>LIST-REDUCTION FUNCTIONS</source>
          <target state="translated">缩表功能</target>
        </trans-unit>
        <trans-unit id="79350be1daad6ac703bf5442efacc2b70bd2d6d8" translate="yes" xml:space="preserve">
          <source>LISTs do automatic interpolation of sublists. That is, when a LIST is evaluated, each element of the list is evaluated in list context, and the resulting list value is interpolated into LIST just as if each individual element were a member of LIST. Thus arrays and hashes lose their identity in a LIST--the list</source>
          <target state="translated">LIST可以进行子列表的自动插值。也就是说,当一个LIST被评估时,列表中的每一个元素都是在列表上下文中被评估的,所得到的列表值被内插到LIST中,就像每一个单独的元素是LIST的成员一样。因此,数组和哈希在LIST中失去了它们的身份--列表</target>
        </trans-unit>
        <trans-unit id="755d87179ae52e75a5bb95a78c2b37c1c06b5cfe" translate="yes" xml:space="preserve">
          <source>LNM$FILE_DEV</source>
          <target state="translated">LNM$FILE_DEV</target>
        </trans-unit>
        <trans-unit id="1b95b1479e9e1e6747637c53ec6e7b5b14710300" translate="yes" xml:space="preserve">
          <source>LOCALE</source>
          <target state="translated">LOCALE</target>
        </trans-unit>
        <trans-unit id="ff495344ff0fb9c5d5d9ca658b1dad0e61447a28" translate="yes" xml:space="preserve">
          <source>LOCALE CATEGORIES</source>
          <target state="translated">地方类别</target>
        </trans-unit>
        <trans-unit id="169a463b713e3988d9c565945a1d24d03d787111" translate="yes" xml:space="preserve">
          <source>LOCALE PROBLEMS</source>
          <target state="translated">当地的问题</target>
        </trans-unit>
        <trans-unit id="39f15a969419d44e933dbe07a4c0bebe3f003b8b" translate="yes" xml:space="preserve">
          <source>LOGGING</source>
          <target state="translated">LOGGING</target>
        </trans-unit>
        <trans-unit id="95b6b6c48c6cb1e24e041085cc38cb73e88d737e" translate="yes" xml:space="preserve">
          <source>LOOSE MATCHES</source>
          <target state="translated">失败的比赛</target>
        </trans-unit>
        <trans-unit id="18cd8d5a0349b94405db9dec7298507ccea49b05" translate="yes" xml:space="preserve">
          <source>LaTeX docs</source>
          <target state="translated">LaTeX文档</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="f70518aa15c2b8187c80ac13806c15fba56111e6" translate="yes" xml:space="preserve">
          <source>Language Classes</source>
          <target state="translated">语言班</target>
        </trans-unit>
        <trans-unit id="cfb711d350591217fd017e0b7ddd59e362322862" translate="yes" xml:space="preserve">
          <source>Language Extensions and Documentation Tools</source>
          <target state="translated">语言扩展和文档工具</target>
        </trans-unit>
        <trans-unit id="6bd54d34369f11dcd172dcc70f872fcab4fd9483" translate="yes" xml:space="preserve">
          <source>Language Handle Attributes and Internals</source>
          <target state="translated">语言句柄属性和内部结构</target>
        </trans-unit>
        <trans-unit id="c91e4f4c0ce2f8eae1ea5e261c4add9fa7392039" translate="yes" xml:space="preserve">
          <source>Language Specs</source>
          <target state="translated">语言规格</target>
        </trans-unit>
        <trans-unit id="f9d8878de4ae46e5debd26f638420ea68be31544" translate="yes" xml:space="preserve">
          <source>Language classes are what YourProjClass-&amp;gt;get_handle will try to load. It will look for them by taking each language-tag (&lt;b&gt;skipping&lt;/b&gt; it if it doesn't look like a language-tag or locale-tag!), turning it to all lowercase, turning dashes to underscores, and appending it to YourProjClass . &quot;::&quot;. So this:</source>
          <target state="translated">语言类是YourProjClass-&amp;gt; get_handle将尝试加载的类。它将通过获取每种语言标签来查找它们（如果它看起来不像语言标签或语言环境标签，则将其&lt;b&gt;跳过&lt;/b&gt;！），将其全部变为小写，将破折号变为下划线，并将其附加到YourProjClass上。&amp;ldquo; ::&amp;rdquo;。所以这：</target>
        </trans-unit>
        <trans-unit id="747c3b7de1d3c3e77b9c7320590e8b1ede8c25e3" translate="yes" xml:space="preserve">
          <source>Language classes may derive from other language classes (although they should have &quot;use</source>
          <target state="translated">语言类可以从其他语言类中派生出来(尽管它们应该有 &quot;使用 &quot;这个词)。</target>
        </trans-unit>
        <trans-unit id="a1e10c58f87505ae028c597e6cc528cbbe1058b2" translate="yes" xml:space="preserve">
          <source>Language tags are a formalism, described in RFC 3066 (obsoleting 1766), for declaring what language form (language and possibly dialect) a given chunk of information is in.</source>
          <target state="translated">语言标签是一种形式主义,在RFC 3066(过时的1766)中描述,用于声明一个给定的信息块是什么语言形式(语言和可能的方言)。</target>
        </trans-unit>
        <trans-unit id="97e909840ec23e6aa4c68a221630c55bfbbb900a" translate="yes" xml:space="preserve">
          <source>Language tags are not case-sensitive. en-US, en-us, En-Us, etc., are all the same tag, and denote the same language.</source>
          <target state="translated">语言标签不区分大小写,en-US、en-us、En-Us等都是同一个标签,表示同一种语言。</target>
        </trans-unit>
        <trans-unit id="2041c3756bf5afe1a1cc3301a6ebbbd4f47a0037" translate="yes" xml:space="preserve">
          <source>Language tags are not country codes. In fact, they are often distinct codes, as with language tag ja for Japanese, and ISO 3166 country code &lt;code&gt;.jp&lt;/code&gt; for Japan.</source>
          <target state="translated">语言标签不是国家/地区代码。实际上，它们通常是不同的代码，例如日语的语言标签ja和日本的ISO 3166国家/地区代码 &lt;code&gt;.jp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6108174a71e0210309b5a122717007cd6591f45e" translate="yes" xml:space="preserve">
          <source>Language tags are not for computer languages.</source>
          <target state="translated">语言标签不适用计算机语言。</target>
        </trans-unit>
        <trans-unit id="6368278c82dd6595f994cb8b61fde8b578ee7f10" translate="yes" xml:space="preserve">
          <source>Language tags are not locale IDs. A locale ID is written with a &quot;_&quot; instead of a &quot;-&quot;, (almost?) always matches &lt;code&gt;&lt;a href=&quot;../../functions/m&quot;&gt;m/^\w\w_\w\w\b/&lt;/a&gt;&lt;/code&gt;, and</source>
          <target state="translated">语言标记不是语言环境ID。语言环境ID是用&amp;ldquo; _&amp;rdquo;而不是&amp;ldquo;-&amp;rdquo;写的，（几乎是？）始终与 &lt;code&gt;&lt;a href=&quot;../../functions/m&quot;&gt;m/^\w\w_\w\w\b/&lt;/a&gt;&lt;/code&gt; 匹配，并且</target>
        </trans-unit>
        <trans-unit id="8edaa0c28ca3e32511fbcd5b5f49058ccc534792" translate="yes" xml:space="preserve">
          <source>Language-Specific</source>
          <target state="translated">Language-Specific</target>
        </trans-unit>
        <trans-unit id="21162f096b26204df6588bb5dc28d2f51868c501" translate="yes" xml:space="preserve">
          <source>Large File Support</source>
          <target state="translated">大文件支持</target>
        </trans-unit>
        <trans-unit id="cfd4c46c9150c3e9cafc48d2cf89b769398b7ba2" translate="yes" xml:space="preserve">
          <source>Large language group.</source>
          <target state="translated">大语种群体。</target>
        </trans-unit>
        <trans-unit id="68cb5c276851e088e954a75127561094108d7ebb" translate="yes" xml:space="preserve">
          <source>Large numbers of other programmers will be using your code modules.</source>
          <target state="translated">大量的其他程序员将使用你的代码模块。</target>
        </trans-unit>
        <trans-unit id="aed9d519447abe0e1e87e2be7e3184966a86c56b" translate="yes" xml:space="preserve">
          <source>Larger increments or decrements are handy in those cases where a thread needs to check out or return a number of resources at once.</source>
          <target state="translated">当一个线程需要同时签出或返回多个资源时,较大的增量或减量很方便。</target>
        </trans-unit>
        <trans-unit id="fd62837b713bdee00d46e7ce620e1a597b3acf56" translate="yes" xml:space="preserve">
          <source>Larry Wall</source>
          <target state="translated">拉里-沃尔</target>
        </trans-unit>
        <trans-unit id="9800616a976bc743bc49de05b3ff6a81a8fed2bf" translate="yes" xml:space="preserve">
          <source>Larry Wall &amp;lt;larry@wall.org&amp;gt;, with the help of oodles of other folks.</source>
          <target state="translated">拉里&amp;middot;沃尔（Larry Wall）&amp;lt;larry@wall.org&amp;gt;，在其他人的帮助下。</target>
        </trans-unit>
        <trans-unit id="50431f0b84e94e89d59726aa67764d4b5cb64130" translate="yes" xml:space="preserve">
          <source>Larry Wall and others</source>
          <target state="translated">拉里-沃尔等人</target>
        </trans-unit>
        <trans-unit id="0fb4b4d75483396b0cb6c4053090cf1353b0f053" translate="yes" xml:space="preserve">
          <source>Larry Wall designed the elegant inherited bootstrap mechanism and implemented the first Perl 5 dynamic loader using it.</source>
          <target state="translated">Larry Wall设计了优雅的继承引导机制,并使用它实现了第一个Perl 5动态加载器。</target>
        </trans-unit>
        <trans-unit id="49cef125f502490a3eaa452e5063337afd4e5415" translate="yes" xml:space="preserve">
          <source>Larry Wall, Sean M. Burke</source>
          <target state="translated">Larry Wall,Sean M.Burke</target>
        </trans-unit>
        <trans-unit id="cad8518108cca44400e2368862a0f1a16bff95c7" translate="yes" xml:space="preserve">
          <source>Larry has his reasons for each of these things, but he doesn't claim that everyone else's mind works the same as his does.</source>
          <target state="translated">拉里对这些事情都有他的理由,但他并没有说别人的思想和他的思想是一样的。</target>
        </trans-unit>
        <trans-unit id="3e11f8268af6857ace69f95b629b0d80778d0d6d" translate="yes" xml:space="preserve">
          <source>Larry is allowed to change his mind about any matter at a later date, regardless of whether he previously invoked Rule 1.</source>
          <target state="translated">拉里可以在日后改变对任何事项的看法,无论他之前是否援引了规则1。</target>
        </trans-unit>
        <trans-unit id="e3d699c187f5eebff127e90268deebe55f0277f7" translate="yes" xml:space="preserve">
          <source>Larry is always by definition right about how Perl should behave. This means he has final veto power on the core functionality.</source>
          <target state="translated">根据定义,Larry对于Perl应该如何表现总是正确的。这意味着他对核心功能有最终的否决权。</target>
        </trans-unit>
        <trans-unit id="91247cb31b4e3f24a173a3ed4edb3fbe905e9dfa" translate="yes" xml:space="preserve">
          <source>Larry said &quot;Although the Perl Slogan is</source>
          <target state="translated">Larry说:&quot;虽然Perl的口号是</target>
        </trans-unit>
        <trans-unit id="8840809999231d8845f9dcc8eb994457fd02a531" translate="yes" xml:space="preserve">
          <source>Larry sees Perl development along the lines of the US government: there's the Legislature (the porters), the Executive branch (the -pumpking), and the Supreme Court (Larry). The legislature can discuss and submit patches to the executive branch all they like, but the executive branch is free to veto them. Rarely, the Supreme Court will side with the executive branch over the legislature, or the legislature over the executive branch. Mostly, however, the legislature and the executive branch are supposed to get along and work out their differences without impeachment or court cases.</source>
          <target state="translated">Larry认为Perl的发展是沿着美国政府的思路进行的:有立法机构(搬运工)、行政部门(-pumpking)和最高法院(Larry)。立法机关可以随意讨论并向行政部门提交补丁,但行政部门可以随意否决。极少数情况下,最高法院会站在行政部门一边,而不是立法机关,或者立法机关站在行政部门一边。然而,在大多数情况下,立法机关和行政部门应该和睦相处,解决它们之间的分歧,而不需要进行弹劾或诉讼。</target>
        </trans-unit>
        <trans-unit id="86c4e4485ad3dbbdb5b5dd2e9dedc2315a7311d5" translate="yes" xml:space="preserve">
          <source>Last Changed</source>
          <target state="translated">最后更改</target>
        </trans-unit>
        <trans-unit id="1210639f474f0d343df95007771fdc202b411de7" translate="yes" xml:space="preserve">
          <source>Last In, First Out. See also &lt;b&gt;FIFO&lt;/b&gt;. A LIFO is usually called a &lt;b&gt;stack&lt;/b&gt;.</source>
          <target state="translated">后进先出。另请参见&lt;b&gt;FIFO&lt;/b&gt;。LIFO通常称为&lt;b&gt;堆栈&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="40830c73142a53064766f6ffa38ec5fccd97ec73" translate="yes" xml:space="preserve">
          <source>Last Updated: Fri, 29 Oct 1999 22:50:30 +0200</source>
          <target state="translated">最后更新。Fri,29 Oct 1999 22:50:30 +0200</target>
        </trans-unit>
        <trans-unit id="f1e5fc7462efd81797093d9980b1aa8171197971" translate="yes" xml:space="preserve">
          <source>Last but not least, here are various tips for safer coding. See also &lt;a href=&quot;perlclib&quot;&gt;perlclib&lt;/a&gt; for libc/stdio replacements one should use.</source>
          <target state="translated">最后但并非最不重要的一点是，这里提供了各种更安全的编码技巧。另请参阅&lt;a href=&quot;perlclib&quot;&gt;perlclib&lt;/a&gt;以获取应该使用的libc / stdio替换。</target>
        </trans-unit>
        <trans-unit id="dceffa1b326ba5ef1523c69acacd202e09a06fa6" translate="yes" xml:space="preserve">
          <source>Last modified 2013-04-29.</source>
          <target state="translated">最后修改为2013-04-29。</target>
        </trans-unit>
        <trans-unit id="5c3f1c04106319751d7e999882c029924d60d858" translate="yes" xml:space="preserve">
          <source>Last revised 14-Feb-1996, for Perl 5.002.</source>
          <target state="translated">最后修订于1996年2月14日,适用于Perl 5.002。</target>
        </trans-unit>
        <trans-unit id="c838bd278b91a142d60ea0e71aa5a59ad40e1552" translate="yes" xml:space="preserve">
          <source>Last update: 2008-10-29</source>
          <target state="translated">最后更新:2008-10-29</target>
        </trans-unit>
        <trans-unit id="fc7ec2c58f8d11214b25d3966287144f54470cfe" translate="yes" xml:space="preserve">
          <source>Last update: Tue Apr 26 18:30:55 MDT 2011</source>
          <target state="translated">最后更新:Tue Apr 26 18:30:55 MDT 2011</target>
        </trans-unit>
        <trans-unit id="d25a330cf94331e783b24031686ddd1e4f1da4ff" translate="yes" xml:space="preserve">
          <source>Last updated: 07 October 2014</source>
          <target state="translated">最后更新 2014年10月7日</target>
        </trans-unit>
        <trans-unit id="e1651fd9e16da0fb6683f8baa5303f215ef932af" translate="yes" xml:space="preserve">
          <source>Last updated: 2012-02-08</source>
          <target state="translated">最后更新。2012-02-08</target>
        </trans-unit>
        <trans-unit id="152779e4c8b9d8d930bb573d8f364d8d186f33dd" translate="yes" xml:space="preserve">
          <source>Lastly, the</source>
          <target state="translated">最后一点是</target>
        </trans-unit>
        <trans-unit id="4d407485e169287b1c2aa3f4a4b85bc45bed7a87" translate="yes" xml:space="preserve">
          <source>Lastly, there is a special method for working under &lt;b&gt;-T&lt;/b&gt; and setuid/gid scripts:</source>
          <target state="translated">最后，有一个特殊的方法可以在&lt;b&gt;-T&lt;/b&gt;和setuid / gid脚本下工作：</target>
        </trans-unit>
        <trans-unit id="202e6182477b0bfd7c1ee15e20cf42a59755cdd1" translate="yes" xml:space="preserve">
          <source>Laszlo Molnar,</source>
          <target state="translated">Laszlo Molnar,</target>
        </trans-unit>
        <trans-unit id="526c6b8794fab24bec118be16f23def6a69bab1c" translate="yes" xml:space="preserve">
          <source>Lately, ignoring or actively opposing compatibility with earlier versions of Perl has come into vogue. Sometimes, a change is proposed which wants to usurp syntax which previously had another meaning. Sometimes, a change wants to improve previously-crazy semantics.</source>
          <target state="translated">最近,忽视或积极反对与早期版本的Perl的兼容性已经成为一种时尚。有时,一个改动的提出,是想篡夺以前具有另一种意义的语法。有时,一个改动想改进以前疯狂的语义。</target>
        </trans-unit>
        <trans-unit id="36e7725e6d39280db73b49ece64538b8d66586a2" translate="yes" xml:space="preserve">
          <source>Later in the life of the object the methods may be queries with get() method and set() method (which accept multiple arguments).</source>
          <target state="translated">在对象的后期,可以用get()方法和set()方法(接受多个参数)进行查询。</target>
        </trans-unit>
        <trans-unit id="6e71bb4c4e3671df8bee4472c56c5267f4268f7f" translate="yes" xml:space="preserve">
          <source>Later invocations of coloralias() with the same ALIAS will override earlier aliases. There is no way to remove an alias.</source>
          <target state="translated">以后调用coloralias()时,如果使用相同的alias,会覆盖之前的别名。没有办法删除别名。</target>
        </trans-unit>
        <trans-unit id="c58245493d9e35fde84415d863d1963037986377" translate="yes" xml:space="preserve">
          <source>Later on, we'll pass this to Configure through -Dtargetenv</source>
          <target state="translated">稍后,我们将通过-Dtargetenv将其传递给配置。</target>
        </trans-unit>
        <trans-unit id="f8e3805b10e4c4f4b08c327d5a5b182642f7a406" translate="yes" xml:space="preserve">
          <source>Latest version of &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; on CPAN: &lt;a href=&quot;http://search.cpan.org/search?module=threads&quot;&gt;http://search.cpan.org/search?module=threads&lt;/a&gt;</source>
          <target state="translated">CPAN 上&lt;a href=&quot;threads&quot;&gt;线程的&lt;/a&gt;最新版本：&lt;a href=&quot;http://search.cpan.org/search?module=threads&quot;&gt;http&lt;/a&gt; ://search.cpan.org/search?module = threads</target>
        </trans-unit>
        <trans-unit id="55dfbb7924a9e791a0e250e51336f5378e1751eb" translate="yes" xml:space="preserve">
          <source>Latest version of &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; on CPAN: &lt;a href=&quot;http://search.cpan.org/search?module=threads%3A%3Ashared&quot;&gt;http://search.cpan.org/search?module=threads%3A%3Ashared&lt;/a&gt;</source>
          <target state="translated">最新版本的&lt;a href=&quot;threads/shared&quot;&gt;线程：：&lt;/a&gt;在CPAN上共享：&lt;a href=&quot;http://search.cpan.org/search?module=threads%3A%3Ashared&quot;&gt;http&lt;/a&gt; ://search.cpan.org/search?module = threads% 3A%3Ashared</target>
        </trans-unit>
        <trans-unit id="57e8cec14c4a568ca92f36bd23fabb426a1d8b2d" translate="yes" xml:space="preserve">
          <source>Latin 1 (ISO 8859-1)</source>
          <target state="translated">拉丁文1(ISO 8859-1)</target>
        </trans-unit>
        <trans-unit id="35bde1b1448a3634844f710f6f0c19bb97cc5c1e" translate="yes" xml:space="preserve">
          <source>Laundering and Detecting Tainted Data</source>
          <target state="translated">洗涤和检测受污染数据</target>
        </trans-unit>
        <trans-unit id="467f628abddb4dcd106efd4dcaeb617681eb8f7d" translate="yes" xml:space="preserve">
          <source>Layer allows buffer snooping.</source>
          <target state="translated">层允许缓冲区窥探。</target>
        </trans-unit>
        <trans-unit id="cb8d6c688037b3d7cd03ae365bbe000a64676df9" translate="yes" xml:space="preserve">
          <source>Layer can translate between &quot;\n&quot; and CRLF line ends.</source>
          <target state="translated">层可以在&quot;\n &quot;和CRLF线端之间进行转换。</target>
        </trans-unit>
        <trans-unit id="b12b05c07cab44e1c8dc0e859b671ac3d7cccd05" translate="yes" xml:space="preserve">
          <source>Layer is line buffered. Write data should be passed to next layer down whenever a &quot;\n&quot; is seen. Any data beyond the &quot;\n&quot; should then be processed.</source>
          <target state="translated">层是行缓冲的。每当看到&quot;/n &quot;时,应将写数据传给下一层。任何超过&quot;\n &quot;的数据都应该被处理。</target>
        </trans-unit>
        <trans-unit id="63a50a8c52a6d0d048f4fa59a33a9d88e95e80ac" translate="yes" xml:space="preserve">
          <source>Layer is performing Win32-like &quot;\n&quot; mapped to CR,LF for output and CR,LF mapped to &quot;\n&quot; for input. Normally the provided &quot;crlf&quot; layer is the only layer that need bother about this. &lt;code&gt;PerlIO_binmode()&lt;/code&gt; will mess with this flag rather than add/remove layers if the &lt;code&gt;PERLIO_K_CANCRLF&lt;/code&gt; bit is set for the layers class.</source>
          <target state="translated">层正在执行类似于Win32的&amp;ldquo; \ n&amp;rdquo;映射到CR，LF的输出和CR，LF映射到&amp;ldquo; \ n&amp;rdquo;的输入。通常，所提供的&amp;ldquo; crlf&amp;rdquo;层是唯一需要为此解决的层。如果将layers类的 &lt;code&gt;PERLIO_K_CANCRLF&lt;/code&gt; 位置1，则 &lt;code&gt;PerlIO_binmode()&lt;/code&gt; 将使此标志混乱，而不是添加/删除图层。</target>
        </trans-unit>
        <trans-unit id="eb03ef93aa3ad216c22ac53a17958f564d0c42cd" translate="yes" xml:space="preserve">
          <source>Layer is unbuffered - i.e. write to next layer down should occur for each write to this layer.</source>
          <target state="translated">层是无缓冲的--即对这一层的每一次写入都应该向下一层写入。</target>
        </trans-unit>
        <trans-unit id="9f3401294ca5c3ec99fdd44fd405f62db10c762f" translate="yes" xml:space="preserve">
          <source>Layer which calls &lt;code&gt;fread&lt;/code&gt; , &lt;code&gt;fwrite&lt;/code&gt; and &lt;code&gt;fseek&lt;/code&gt; /&lt;code&gt;ftell&lt;/code&gt; etc. Note that as this is &quot;real&quot; stdio it will ignore any layers beneath it and go straight to the operating system via the C library as usual.</source>
          <target state="translated">调用 &lt;code&gt;fread&lt;/code&gt; ， &lt;code&gt;fwrite&lt;/code&gt; 和 &lt;code&gt;fseek&lt;/code&gt; / &lt;code&gt;ftell&lt;/code&gt; 等的层。请注意，由于这是&amp;ldquo;真实的&amp;rdquo; stdio，它将忽略其下面的任何层，并照常通过C库直接进入操作系统。</target>
        </trans-unit>
        <trans-unit id="9ff9f300fa7d1bbc3f849481cc645ec702a3625b" translate="yes" xml:space="preserve">
          <source>Layers can be made available by extension modules. When an unknown layer is encountered the PerlIO code will perform the equivalent of :</source>
          <target state="translated">层可以通过扩展模块来实现。当遇到未知的层时,PerlIO代码将执行等价的.NET技术。</target>
        </trans-unit>
        <trans-unit id="0e3178f7991d7264f18bf3f06ccf8bf03e08f4f6" translate="yes" xml:space="preserve">
          <source>Layers in action.</source>
          <target state="translated">分层行动。</target>
        </trans-unit>
        <trans-unit id="90a85751546d30690f93cf14e09e26b8d8de391b" translate="yes" xml:space="preserve">
          <source>Layers it makes sense to include in the PERLIO environment variable are briefly summarized below. For more details see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;.</source>
          <target state="translated">下面简要概述了将包含在PERLIO环境变量中有意义的层。有关更多详细信息，请参见&lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69114be10292080f3d4afeef56cf245603257cc6" translate="yes" xml:space="preserve">
          <source>Layers vs Disciplines</source>
          <target state="translated">层次与学科</target>
        </trans-unit>
        <trans-unit id="a41c1d3ed9255c2fe23288b7c102a2dc110d982d" translate="yes" xml:space="preserve">
          <source>Lazy people and beginners may now stop reading the manual.</source>
          <target state="translated">懒人和初学者现在可以不看说明书了。</target>
        </trans-unit>
        <trans-unit id="b9f359f1580c6817c9a64d72d3882cfe9dcbaef9" translate="yes" xml:space="preserve">
          <source>Le Sergent, T. and B. Berthomieu. &quot;Incremental MultiThreaded Garbage Collection on Virtually Shared Memory Architectures&quot; in Memory Management: Proc. of the International Workshop IWMM 92, St. Malo, France, September 1992, Yves Bekkers and Jacques Cohen, eds. Springer, 1992, ISBN 3540-55940-X (real-life thread applications).</source>
          <target state="translated">Le Sergent,T.and B.Berthomieu.&quot;Incremental MultiThreaded Garbage Collection on Virtually Shared Memory Architectures&quot; in Memory Management:国际研讨会IWMM 92,法国圣马洛,1992年9月,Yves Bekkers和Jacques Cohen编辑。Springer,1992,ISBN 3540-55940-X(现实生活中的线程应用)。</target>
        </trans-unit>
        <trans-unit id="bd162d2f93cdcba4f68be85d18fd26ee09a12efb" translate="yes" xml:space="preserve">
          <source>Leading and trailing colons can be used together if you need positional parameter values without the names. Note that in the case below, the &lt;code&gt;PERL_API&lt;/code&gt; params are returned in alphabetical order.</source>
          <target state="translated">如果需要不带名称的位置参数值，则前导冒号和尾随冒号可以一起使用。请注意，在以下情况下， &lt;code&gt;PERL_API&lt;/code&gt; 参数以字母顺序返回。</target>
        </trans-unit>
        <trans-unit id="a19eb901d0541a10b461432e6635be906ecd8d19" translate="yes" xml:space="preserve">
          <source>Leading white space is ignored without warning, as too are any trailing non-digits, such as a decimal point (&lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; only handles non-negative integers, not negative integers or floating point).</source>
          <target state="translated">前导空格将被忽略而不会发出警告，尾随的非数字也将被忽略，例如小数点（ &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 只处理非负整数，而不是负整数或浮点数）。</target>
        </trans-unit>
        <trans-unit id="fb2634197a046f8fbd1bb749b3d21bb890485f5f" translate="yes" xml:space="preserve">
          <source>Leading white space is ignored without warning, as too are any trailing non-digits, such as a decimal point (&lt;code&gt;&lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; only handles non-negative integers, not negative integers or floating point).</source>
          <target state="translated">前导空格将被忽略而不会发出警告，尾随的非数字也将被忽略，例如小数点（ &lt;code&gt;&lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 只处理非负整数，而不是负整数或浮点数）。</target>
        </trans-unit>
        <trans-unit id="ba3f4ebacb603a1ffae736f19b872df26ac931b0" translate="yes" xml:space="preserve">
          <source>Learn Perl and rewrite it. Seriously, there's no simple converter. Things that are awkward to do in the shell are easy to do in Perl, and this very awkwardness is what would make a shell-&amp;gt;perl converter nigh-on impossible to write. By rewriting it, you'll think about what you're really trying to do, and hopefully will escape the shell's pipeline datastream paradigm, which while convenient for some matters, causes many inefficiencies.</source>
          <target state="translated">学习Perl并重写它。严重的是，没有简单的转换器。在Shell中难于处理的事情在Perl中很容易做到，而这种非常尴尬的事使Shell-&amp;gt; perl转换器几乎无法编写。通过重写它，您将考虑您真正想做的事情，并希望能够摆脱Shell的管道数据流范式，尽管这在某些方面很方便，但会导致许多低效率。</target>
        </trans-unit>
        <trans-unit id="4dd0a48cec0f53000c96d709bef9efb450bae6d8" translate="yes" xml:space="preserve">
          <source>Leaving out the Notify option usually defaults an SMTP service to its default behavior equivalent to ['FAILURE'] notifications only, but again this may be dependent upon your site's SMTP configuration.</source>
          <target state="translated">不使用 &quot;通知 &quot;选项通常会将SMTP服务默认为仅相当于['FAILURE']通知的行为,但这也可能取决于您网站的SMTP配置。</target>
        </trans-unit>
        <trans-unit id="a4c7551b205677232e62bc969aaaea5621b25584" translate="yes" xml:space="preserve">
          <source>Lee Johnson &amp;lt;notfadeaway at btinternet dot com&amp;gt;</source>
          <target state="translated">李&amp;middot;约翰逊（Lee Johnson）&amp;lt;btinternet dot com上的notfadeaway&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b6a5edc3102ea975638e0ce2bb8f6982f95bead8" translate="yes" xml:space="preserve">
          <source>Left and right padding with any character, creating a new string:</source>
          <target state="translated">用任意字符进行左右填充,创建一个新的字符串。</target>
        </trans-unit>
        <trans-unit id="7f1c7df67c81bb16bff18c751738160fab5ff982" translate="yes" xml:space="preserve">
          <source>Left and right padding with any character, modifying &lt;code&gt;$text&lt;/code&gt; directly:</source>
          <target state="translated">用任何字符左右填充，直接修改 &lt;code&gt;$text&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="af98dcfaae79ce4ac9aa9fbbe9635687fe2fe178" translate="yes" xml:space="preserve">
          <source>Left offset from pos() to start match at.</source>
          <target state="translated">从pos()到开始匹配的左偏移量。</target>
        </trans-unit>
        <trans-unit id="32ff2067f2a9f0deffe08043bfbad0999ed3babf" translate="yes" xml:space="preserve">
          <source>LeftString</source>
          <target state="translated">LeftString</target>
        </trans-unit>
        <trans-unit id="fb74bcaf76999b5ef8dae81b1022d842c093fe10" translate="yes" xml:space="preserve">
          <source>Legacy</source>
          <target state="translated">Legacy</target>
        </trans-unit>
        <trans-unit id="177a7c67030b56d701d66da14735a0847871d1fb" translate="yes" xml:space="preserve">
          <source>Legacy Character Sets</source>
          <target state="translated">遗留字符集</target>
        </trans-unit>
        <trans-unit id="45890076a74f7ba49cb141341bf0a665659f9168" translate="yes" xml:space="preserve">
          <source>Legacy Encodings</source>
          <target state="translated">遗留编码</target>
        </trans-unit>
        <trans-unit id="ca20c7f742784eaf8c9542c65094bd868679305e" translate="yes" xml:space="preserve">
          <source>Legacy multi byte EBCDIC code pages XXX.</source>
          <target state="translated">传统的多字节EBCDIC代码页XXX。</target>
        </trans-unit>
        <trans-unit id="b14ba2ec2e45438ad3facc4d4b02bd06eedc0c59" translate="yes" xml:space="preserve">
          <source>Legacy, fixed-width encodings defined by the ISO 10646 standard. UCS-2 is a 16-bit encoding. Unlike UTF-16, UCS-2 is not extensible beyond &lt;code&gt;U+FFFF&lt;/code&gt; , because it does not use surrogates. UCS-4 is a 32-bit encoding, functionally identical to UTF-32 (the difference being that UCS-4 forbids neither surrogates nor code points larger than &lt;code&gt;0x10_FFFF&lt;/code&gt; ).</source>
          <target state="translated">ISO 10646标准定义的旧版固定宽度编码。UCS-2是16位编码。与UTF-16不同，UCS-2不能扩展到 &lt;code&gt;U+FFFF&lt;/code&gt; 之外，因为它不使用代理。UCS-4是一种32位编码，功能上与UTF-32相同（不同之处在于UCS-4既不禁止代写也不禁止大于 &lt;code&gt;0x10_FFFF&lt;/code&gt; 的代码点）。</target>
        </trans-unit>
        <trans-unit id="00a83ae1dc6e4e324ce120afa5a8e7b91193b805" translate="yes" xml:space="preserve">
          <source>Legal &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs that match no characters</source>
          <target state="translated">没有字符的合法 &lt;code&gt;\p{}&lt;/code&gt; 和 &lt;code&gt;\P{}&lt;/code&gt; 构造</target>
        </trans-unit>
        <trans-unit id="b01926f0986a11c72cf140417a7b70c5868b0797" translate="yes" xml:space="preserve">
          <source>Legal \p{} and \P{} constructs that match no characters</source>
          <target state="translated">合法的p/{}和p/{}结构,不匹配任何字符。</target>
        </trans-unit>
        <trans-unit id="97f35de278fd2499acf694739f13d5aa76297107" translate="yes" xml:space="preserve">
          <source>Leif Eriksen &amp;lt;leif dot eriksen at bigpond dot com&amp;gt;</source>
          <target state="translated">Leif Eriksen &amp;lt;bigpond dot com上的leif dot eriksen&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6115881c5ecab4a82072aab1fbcafeaf5ae5a302" translate="yes" xml:space="preserve">
          <source>Length of the name.</source>
          <target state="translated">名字的长度。</target>
        </trans-unit>
        <trans-unit id="1deb1eed10d40a0d45e6e2d30e54152b66733959" translate="yes" xml:space="preserve">
          <source>Length to truncate the argument list when the &lt;code&gt;frame&lt;/code&gt; option's bit 4 is set.</source>
          <target state="translated">设置了 &lt;code&gt;frame&lt;/code&gt; 选项的位4 时截断参数列表的长度。</target>
        </trans-unit>
        <trans-unit id="1d1a91bdc1315d2ef3c37c514f4e0b41950b2992" translate="yes" xml:space="preserve">
          <source>Lengths and Widths</source>
          <target state="translated">长度和宽度</target>
        </trans-unit>
        <trans-unit id="c763c85942db32f81cf9ff36bb94bec3c42bb459" translate="yes" xml:space="preserve">
          <source>Let Perldoc check Pod for errors</source>
          <target state="translated">让Perldoc检查Pod的错误</target>
        </trans-unit>
        <trans-unit id="236e4f11c45d6dc4aeeb3e3ee19570b2cee88f0e" translate="yes" xml:space="preserve">
          <source>Let Perldoc convert Pod to nroff</source>
          <target state="translated">让Perldoc将Pod转换为nroff。</target>
        </trans-unit>
        <trans-unit id="974a4ac3dfc20423e93f62bd6d7257d2efff060e" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as ... Pod!</source>
          <target state="translated">让Perldoc把Pod渲染成......。Pod!</target>
        </trans-unit>
        <trans-unit id="89789b71272a03c7a7d2242762bf736542d90944" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as RTF</source>
          <target state="translated">让Perldoc将Pod渲染成RTF</target>
        </trans-unit>
        <trans-unit id="a09176a65c16f1ea87e512ddbd1ebf583706c4be" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as XML</source>
          <target state="translated">让Perldoc将Pod渲染成XML</target>
        </trans-unit>
        <trans-unit id="9dd1bef5afa3543070a44bc3e67a86b4a5626d33" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as man pages</source>
          <target state="translated">让Perldoc将Pod渲染成man pages</target>
        </trans-unit>
        <trans-unit id="cb573ad7df52482623e8e613fdbfbc5f59abce18" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as plaintext</source>
          <target state="translated">让Perldoc将Pod渲染成明文</target>
        </trans-unit>
        <trans-unit id="d279d6ba36fcd7e038b9dea67ba4516a9df60977" translate="yes" xml:space="preserve">
          <source>Let Perldoc use Tk::Pod to render Pod</source>
          <target state="translated">让Perldoc使用Tk::Pod来渲染Pod。</target>
        </trans-unit>
        <trans-unit id="757e98b6ce9386f0fb646f3598168b1185dc8359" translate="yes" xml:space="preserve">
          <source>Let it be noted that the flakiness of indirect filehandles is not related to whether they're strings, typeglobs, objects, or anything else. It's the syntax of the fundamental operators. Playing the object game doesn't help you at all here.</source>
          <target state="translated">我们要注意的是,间接文件柄的浮躁与它们是字符串、typeglobs、对象或其他任何东西无关。而是基本运算符的语法。玩对象游戏在这里对你一点帮助都没有。</target>
        </trans-unit>
        <trans-unit id="1fe958b2a6ee1393677c318cb2bd2d9b92f2cd48" translate="yes" xml:space="preserve">
          <source>Let it be stressed that</source>
          <target state="translated">需要强调的是</target>
        </trans-unit>
        <trans-unit id="b48514691c5b46e8297541220211ccc8b070316c" translate="yes" xml:space="preserve">
          <source>Let the index expire after how many days?</source>
          <target state="translated">让指数在多少天后到期?</target>
        </trans-unit>
        <trans-unit id="6104cb2c1f6570ab357e214a9780db2e76a15675" translate="yes" xml:space="preserve">
          <source>Let us now discuss Unicode character classes, most usually called &quot;character properties&quot;. These are represented by the &lt;code&gt;\p{name}&lt;/code&gt; escape sequence. Closely associated is the &lt;code&gt;\P{name}&lt;/code&gt; property, which is the negation of the &lt;code&gt;\p{name}&lt;/code&gt; one. For example, to match lower and uppercase characters,</source>
          <target state="translated">现在让我们讨论Unicode字符类，通常称为&amp;ldquo;字符属性&amp;rdquo;。这些由 &lt;code&gt;\p{name}&lt;/code&gt; 转义序列表示。紧密相关的是 &lt;code&gt;\P{name}&lt;/code&gt; 属性，它是 &lt;code&gt;\p{name}&lt;/code&gt; 的取反。例如，要匹配大小写字符，</target>
        </trans-unit>
        <trans-unit id="d5b865b005185fbf91c141118661a5d11906d96e" translate="yes" xml:space="preserve">
          <source>Let's also fix the MANIFEST file so that it accurately reflects the contents of our extension. The single line that says &quot;mylib&quot; should be replaced by the following three lines:</source>
          <target state="translated">让我们也修正一下MANIFEST文件,使它能准确地反映出我们扩展的内容。将 &quot;mylib &quot;这一行改为以下三行。</target>
        </trans-unit>
        <trans-unit id="f577dbeceee6187e31fa08c5d2d55b7b25ccea26" translate="yes" xml:space="preserve">
          <source>Let's assume that we have a package &lt;code&gt;Cool::Foo&lt;/code&gt; , which includes &lt;code&gt;Cool::Foo&lt;/code&gt; and &lt;code&gt;Cool::Bar&lt;/code&gt; modules each having a separate XS file. First we use the following</source>
          <target state="translated">假设我们有一个 &lt;code&gt;Cool::Foo&lt;/code&gt; 包，其中包括 &lt;code&gt;Cool::Foo&lt;/code&gt; 和 &lt;code&gt;Cool::Bar&lt;/code&gt; 模块，每个模块都有一个单独的XS文件。首先我们使用以下</target>
        </trans-unit>
        <trans-unit id="5b0ca95dec9c2d9636bc8d5032b2d5f394a81699" translate="yes" xml:space="preserve">
          <source>Let's begin by looking a simple scalar which is holding a string.</source>
          <target state="translated">我们先来看一个简单的标量,它是持有一个字符串。</target>
        </trans-unit>
        <trans-unit id="bf0b81e7623e4177f0bbf011b090062ef49e50b2" translate="yes" xml:space="preserve">
          <source>Let's consider how different regexps would match &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; :</source>
          <target state="translated">让我们考虑一下不同的正则表达式将如何匹配 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="df805a589a3384de86f5cf73ad97a197cc80b2b6" translate="yes" xml:space="preserve">
          <source>Let's consider what happens when the filtered code includes another module with use:</source>
          <target state="translated">让我们考虑一下当过滤后的代码包含另一个模块的使用时,会发生什么。</target>
        </trans-unit>
        <trans-unit id="c5bb45ed6a20ca29516eecb8c27b4f1a78faa8d9" translate="yes" xml:space="preserve">
          <source>Let's edit the .xs file by adding this to the end of the file:</source>
          <target state="translated">让我们编辑.xs文件,在文件末尾添加以下内容。</target>
        </trans-unit>
        <trans-unit id="f7e0018c031b17ac0ce35fd9db664c3f00e8a38b" translate="yes" xml:space="preserve">
          <source>Let's examine the cogs of this byte mill, one by one. There's the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; call, creating the items we intend to stuff into the &lt;code&gt;$env&lt;/code&gt; buffer: to each key (in &lt;code&gt;$_&lt;/code&gt; ) it adds the &lt;code&gt;=&lt;/code&gt; separator and the hash entry value. Each triplet is packed with the template code sequence &lt;code&gt;A*A*Z*&lt;/code&gt; that is repeated according to the number of keys. (Yes, that's what the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; function returns in scalar context.) To get the very last null byte, we add a &lt;code&gt;0&lt;/code&gt; at the end of the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; list, to be packed with &lt;code&gt;C&lt;/code&gt; . (Attentive readers may have noticed that we could have omitted the 0.)</source>
          <target state="translated">让我们一一检查这个字节磨的齿轮。有一个 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 调用，将我们打算填充到 &lt;code&gt;$env&lt;/code&gt; 缓冲区中的项目创建：在每个键（在 &lt;code&gt;$_&lt;/code&gt; ）中添加 &lt;code&gt;=&lt;/code&gt; 分隔符和哈希条目值。每个三元组都包装有根据键数重复的模板代码序列 &lt;code&gt;A*A*Z*&lt;/code&gt; 。 （是的，这就是在 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 的功能在标量上下文的回报）。为了得到最后的空字节，我们添加了一个 &lt;code&gt;0&lt;/code&gt; 在年底 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 清单，被挤满了 &lt;code&gt;C&lt;/code&gt; 。 （细心的读者可能已经注意到我们可以省略0。）</target>
        </trans-unit>
        <trans-unit id="9e554ae494be1d13390f7359c0d05574c54b38a5" translate="yes" xml:space="preserve">
          <source>Let's examine the whole implementation, for practice:</source>
          <target state="translated">我们来研究一下整个的实施,进行实践。</target>
        </trans-unit>
        <trans-unit id="cb0a55a99d6403d9b27402fcdfbf4d6ed2e005f9" translate="yes" xml:space="preserve">
          <source>Let's explore this feature a little more. We'll begin with the equivalent of</source>
          <target state="translated">我们再来探讨一下这个功能。我们先从相当于</target>
        </trans-unit>
        <trans-unit id="ebfb13b002928ab00b844746320f412762e65aa3" translate="yes" xml:space="preserve">
          <source>Let's give it a try:</source>
          <target state="translated">让我们试一试。</target>
        </trans-unit>
        <trans-unit id="4e14ae2cc2c4249d7ae1307778537f0e17717e46" translate="yes" xml:space="preserve">
          <source>Let's have a look at how Perl sees &lt;code&gt;$a = $b + $c&lt;/code&gt; :</source>
          <target state="translated">让我们看看Perl如何看待 &lt;code&gt;$a = $b + $c&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e928f3f516e4f40543bf011e7476bdaffeba6904" translate="yes" xml:space="preserve">
          <source>Let's look at another TCP client. This one connects to the TCP &quot;time&quot; service on a number of different machines and shows how far their clocks differ from the system on which it's being run:</source>
          <target state="translated">让我们看看另一个TCP客户端。这个客户端连接到一些不同机器上的TCP &quot;时间 &quot;服务,并显示它们的时钟与运行它的系统之间的差异。</target>
        </trans-unit>
        <trans-unit id="0bfde5091a0fdc4b1dcc0dd94b94093ffcfd6f13" translate="yes" xml:space="preserve">
          <source>Let's look at each in turn, using as an example a tie class for scalars that allows the user to do something like:</source>
          <target state="translated">让我们逐一来看,以标量的领带类为例,允许用户做这样的事情。</target>
        </trans-unit>
        <trans-unit id="8c38883dc5f76f55aab6aa025aff159c68fa3911" translate="yes" xml:space="preserve">
          <source>Let's look at each of these possible constructs in detail. There are separate sections on each of the following:</source>
          <target state="translated">让我们来详细看看这些可能的结构中的每一个。以下是关于每一种结构的单独章节。</target>
        </trans-unit>
        <trans-unit id="ad30ae9725c85002b6831ea9730f9076d479a5c8" translate="yes" xml:space="preserve">
          <source>Let's look at each of these principles in depth.</source>
          <target state="translated">让我们来深入了解一下这些原则。</target>
        </trans-unit>
        <trans-unit id="176db7a51355c5004c1f239aa8667a05811318e4" translate="yes" xml:space="preserve">
          <source>Let's look at the example above, but with minimal quantifiers:</source>
          <target state="translated">让我们来看看上面的例子,但用最小的量化器。</target>
        </trans-unit>
        <trans-unit id="44d6bf690bfe89fee660e282315649dfc02c909f" translate="yes" xml:space="preserve">
          <source>Let's make a quick object and x-plode it, first we'll start the debugger: it wants some form of input from STDIN, so we give it something non-committal, a zero:</source>
          <target state="translated">让我们做一个快速的对象并对其进行x-plode,首先我们将启动调试器:它希望从STDIN中获得某种形式的输入,所以我们给它一些非约定性的东西,一个零。</target>
        </trans-unit>
        <trans-unit id="2af4365a6067ebec1d91261e67cfd455affae6b4" translate="yes" xml:space="preserve">
          <source>Let's say your application is a server that will occasionally run Perl code from some arbitrary file. Your server has no way of knowing what code it's going to run. Very dangerous.</source>
          <target state="translated">假设你的应用程序是一个服务器,偶尔会从一些任意文件中运行Perl代码。你的服务器没有办法知道它要运行什么代码。非常危险。</target>
        </trans-unit>
        <trans-unit id="4d890463be6280c78f6b7f6a985632f09c2fa90e" translate="yes" xml:space="preserve">
          <source>Let's see a quick example of how all this is useful.</source>
          <target state="translated">让我们来看看一个快速的例子,看看这一切是如何有用的。</target>
        </trans-unit>
        <trans-unit id="e32a2ed9f3b04c47c03460e3d9853725a7d0f999" translate="yes" xml:space="preserve">
          <source>Let's see what &lt;code&gt;Benchmark&lt;/code&gt; makes of this:</source>
          <target state="translated">让我们看一下 &lt;code&gt;Benchmark&lt;/code&gt; 所做的：</target>
        </trans-unit>
        <trans-unit id="405776f1b44151a8af53d3cf919e2d8b537db4ed" translate="yes" xml:space="preserve">
          <source>Let's start in the middle, at line 4. This is a BINOP, a binary operator, which is at location &lt;code&gt;0x8179828&lt;/code&gt; . The specific operator in question is &lt;code&gt;sassign&lt;/code&gt; - scalar assignment - and you can find the code which implements it in the function &lt;code&gt;pp_sassign&lt;/code&gt; in</source>
          <target state="translated">让我们从中间的第4行开始。这是一个BINOP二进制运算符，位于位置 &lt;code&gt;0x8179828&lt;/code&gt; 。有问题的特定运算符是 &lt;code&gt;sassign&lt;/code&gt; -标量赋值-您可以在函数 &lt;code&gt;pp_sassign&lt;/code&gt; 中找到实现它的代码。</target>
        </trans-unit>
        <trans-unit id="fc1d4b156d0cb946936473b6a08e0d57dc7fd23f" translate="yes" xml:space="preserve">
          <source>Let's start with the second line. It says that the uppercase of code point 97 is 65; or &lt;code&gt;&lt;a href=&quot;../functions/uc&quot;&gt;uc(&quot;a&quot;)&lt;/a&gt;&lt;/code&gt; == &quot;A&quot;. But the line is for the entire range of code points 97 through 122. To get the mapping for any code point in this range, you take the offset it has from the beginning code point of the range, and add that to the mapping for that first code point. So, the mapping for 122 (&quot;z&quot;) is derived by taking the offset of 122 from 97 (=25) and adding that to 65, yielding 90 (&quot;z&quot;). Likewise for everything in between.</source>
          <target state="translated">让我们从第二行开始。它说代码点97的大写为65；或 &lt;code&gt;&lt;a href=&quot;../functions/uc&quot;&gt;uc(&quot;a&quot;)&lt;/a&gt;&lt;/code&gt; ==&amp;ldquo; A&amp;rdquo;。但是该行是针对代码点97到122的整个范围的。要获取此范围内任何代码点的映射，请获取其与该范围的开始代码点之间的偏移量，并将其添加到该范围的映射中第一个代码点。因此，通过从97（= 25）获得122的偏移量并将其加到65，得出90（&amp;ldquo; z&amp;rdquo;），从而得出122（&amp;ldquo; z&amp;rdquo;）的映射。同样，介于两者之间的所有内容。</target>
        </trans-unit>
        <trans-unit id="0880854fa8770ea11a4efe4579463972aa5ae537" translate="yes" xml:space="preserve">
          <source>Let's suppose you have some weird Martian encoding where pairs of ASCII uppercase letters encode single Martian letters (i.e. the two bytes &quot;CV&quot; make a single Martian letter, as do the two bytes &quot;SG&quot;, &quot;VS&quot;, &quot;XX&quot;, etc.). Other bytes represent single characters, just like ASCII.</source>
          <target state="translated">假设你有一些奇怪的火星语编码,其中一对ASCII大写字母编码单个火星语字母(即两个字节 &quot;CV &quot;组成一个火星语字母,两个字节 &quot;SG&quot;、&quot;VS&quot;、&quot;XX &quot;等也是如此)。其他字节代表单个字符,就像ASCII码一样。</target>
        </trans-unit>
        <trans-unit id="8f09fe13c85ec276cd87ab04a04d40aac9612c6e" translate="yes" xml:space="preserve">
          <source>Let's suppose you've got to read in a data file like this:</source>
          <target state="translated">假设你要读取的数据文件是这样的。</target>
        </trans-unit>
        <trans-unit id="2f7c544be1b70356d2951611060b9932dadf6ea2" translate="yes" xml:space="preserve">
          <source>Let's take a look at a portion of the .c file created for our extension. The file name is Mytest.c:</source>
          <target state="translated">我们来看看为我们的扩展名创建的.c文件的一部分。文件名是Mytest.c。</target>
        </trans-unit>
        <trans-unit id="ce5f83676281dd1446f1a5a503aee374bc369bcc" translate="yes" xml:space="preserve">
          <source>Let's take a look at the same program using a different profiler: &lt;code&gt;Devel::Profiler&lt;/code&gt; , a drop-in Perl-only replacement for &lt;code&gt;Devel::DProf&lt;/code&gt; . The usage is very slightly different in that instead of using the special &lt;code&gt;-d:&lt;/code&gt; flag, you pull &lt;code&gt;Devel::Profiler&lt;/code&gt; in directly as a module using &lt;code&gt;-M&lt;/code&gt; .</source>
          <target state="translated">让我们看一下使用不同的探查器的同一程序： &lt;code&gt;Devel::Profiler&lt;/code&gt; ，它是 &lt;code&gt;Devel::DProf&lt;/code&gt; 的仅Perl的替代品。用法略有不同，因为您无需使用特殊的 &lt;code&gt;-d:&lt;/code&gt; 标志，而是使用 &lt;code&gt;-M&lt;/code&gt; 将 &lt;code&gt;Devel::Profiler&lt;/code&gt; 直接作为模块拉入。</target>
        </trans-unit>
        <trans-unit id="230698ed5211b94950bbc39ebf4a2cd8603f3243" translate="yes" xml:space="preserve">
          <source>Let's take a simple patch from start to finish.</source>
          <target state="translated">让我们从头到尾看一个简单的补丁。</target>
        </trans-unit>
        <trans-unit id="2b003d41c47da4c513944208b256541b446c8a71" translate="yes" xml:space="preserve">
          <source>Let's take an example of manipulating a PV, from &lt;code&gt;sv_catpvn&lt;/code&gt; , in</source>
          <target state="translated">让我们操纵PV，从一个例子 &lt;code&gt;sv_catpvn&lt;/code&gt; ，在</target>
        </trans-unit>
        <trans-unit id="7c3c67f07cd4da0245ca6a99400a337a71fe4ec4" translate="yes" xml:space="preserve">
          <source>Let's take an example. Suppose you're reading in data from a local format into a hash-of-hashes in Perl, turning that into a tree, walking the tree and then piping each node to an Acme Transmogrifier Server.</source>
          <target state="translated">让我们举个例子。假设你从本地格式的数据中读取数据到Perl中的哈希值,将其变成一棵树,走完这棵树,然后将每个节点用管道传送到Acme Transmogrifier服务器。</target>
        </trans-unit>
        <trans-unit id="f39fd63d744cf93b2616319a85e2d2154efb3e45" translate="yes" xml:space="preserve">
          <source>Let's you write:</source>
          <target state="translated">让你写。</target>
        </trans-unit>
        <trans-unit id="2f17a5ca119319a7ec877e7a949710676dc887eb" translate="yes" xml:space="preserve">
          <source>Level 1 - Basic Unicode Support</source>
          <target state="translated">1级--基本Unicode支持</target>
        </trans-unit>
        <trans-unit id="0de802e5c110593513199ad6be14e0d3e4934cee" translate="yes" xml:space="preserve">
          <source>Level 2 - Extended Unicode Support</source>
          <target state="translated">第二级--扩展的Unicode支持</target>
        </trans-unit>
        <trans-unit id="bddac528f4922054293682b3a34528809353679b" translate="yes" xml:space="preserve">
          <source>Level 3 - Tailored Support</source>
          <target state="translated">第3级--量身定制的支持</target>
        </trans-unit>
        <trans-unit id="27b7cf7750bfaac558f7db0f6b00074662dc6814" translate="yes" xml:space="preserve">
          <source>Level of verbosity. By default, the debugger leaves your exceptions and warnings alone, because altering them can break correctly running programs. It will attempt to print a message when uncaught INT, BUS, or SEGV signals arrive. (But see the mention of signals in &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt; below.)</source>
          <target state="translated">详细程度。默认情况下，调试器不理会您的异常和警告，因为对其进行更改可能会破坏正常运行的程序。当未捕获的INT，BUS或SEGV信号到达时，它将尝试打印一条消息。（但是请参阅下面的&amp;ldquo; &lt;a href=&quot;#BUGS&quot;&gt;BUGS&amp;rdquo;&lt;/a&gt;中提到的信号。）</target>
        </trans-unit>
        <trans-unit id="ed47f098118b3a4908065115144a054c9afe75d6" translate="yes" xml:space="preserve">
          <source>Levels</source>
          <target state="translated">Levels</target>
        </trans-unit>
        <trans-unit id="dd4d01b82f363523e943497a1acd58ad122c1d74" translate="yes" xml:space="preserve">
          <source>Lewis, Bill, and Daniel J. Berg. Multithreaded Programming with Pthreads. Prentice Hall, 1997, ISBN 0-13-443698-9 (a well-written introduction to threads).</source>
          <target state="translated">Lewis,Bill,and Daniel J.Berg.Multithreaded Programming with Pthreads.Prentice Hall,1997年,ISBN 0-13-443698-9(对线程的介绍写得不错)。</target>
        </trans-unit>
        <trans-unit id="0130807d4961ca028150a643b43fa9d3af268eec" translate="yes" xml:space="preserve">
          <source>Lexer interface</source>
          <target state="translated">Lexer接口</target>
        </trans-unit>
        <trans-unit id="7c46e8b2c6a1b67615cc4a28b1803b6611e259c0" translate="yes" xml:space="preserve">
          <source>Lexical (my) variables declared in scopes external to a subroutine appear in code2ref output text as package variables. This is a tricky problem, as perl has no native facility for referring to a lexical variable defined within a different scope, although &lt;a href=&quot;http://search.cpan.org/perldoc/PadWalker&quot;&gt;PadWalker&lt;/a&gt; is a good start.</source>
          <target state="translated">在子例程外部的作用域中声明的词法（我）变量作为包变量出现在code2ref输出文本中。这是一个棘手的问题，因为尽管&lt;a href=&quot;http://search.cpan.org/perldoc/PadWalker&quot;&gt;PadWalker&lt;/a&gt;是一个很好的开始，但是perl没有本地功能来引用在不同范围内定义的词法变量。</target>
        </trans-unit>
        <trans-unit id="21795cace48f4382f41c503a0895c632d1557532" translate="yes" xml:space="preserve">
          <source>Lexical Subroutines</source>
          <target state="translated">词汇子程序</target>
        </trans-unit>
        <trans-unit id="91090443b78c24e5208fa0b7749049adce1d8581" translate="yes" xml:space="preserve">
          <source>Lexical effect</source>
          <target state="translated">词汇效应</target>
        </trans-unit>
        <trans-unit id="10e46358434f33f5da4b481844bfbc427a1eaf46" translate="yes" xml:space="preserve">
          <source>Lexical scopes of control structures are not bounded precisely by the braces that delimit their controlled blocks; control expressions are part of that scope, too. Thus in the loop</source>
          <target state="translated">控制结构的词法范围并不精确地由限定其控制块的括号来约束;控制表达式也是该范围的一部分。因此在循环中</target>
        </trans-unit>
        <trans-unit id="c32019b3ed41f9870148e7d8a8bcc91664cf5db8" translate="yes" xml:space="preserve">
          <source>Lexical subroutines are only available under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'lexical_subs'&lt;/code&gt; pragma, which produces a warning unless the &quot;experimental::lexical_subs&quot; warnings category is disabled.</source>
          <target state="translated">词汇子例程仅在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'lexical_subs'&lt;/code&gt; 编译指示下可用，除非禁用&amp;ldquo; experimental :: lexical_subs&amp;rdquo;警告类别，否则它会产生警告。</target>
        </trans-unit>
        <trans-unit id="63259d01172ac59370a7ece5661c26923725e28e" translate="yes" xml:space="preserve">
          <source>Lexical variable introduced (declared with my()) for the first time.</source>
          <target state="translated">首次引入词汇变量(用my()声明)。</target>
        </trans-unit>
        <trans-unit id="6bec4b7b4f94bd2a84719ee4041560ade2de4cd8" translate="yes" xml:space="preserve">
          <source>Lexical variables (declared with &quot;my&quot;) are not visible within a format unless the format is declared within the scope of the lexical variable.</source>
          <target state="translated">词汇变量(用 &quot;my &quot;声明)在格式中是不可见的,除非格式是在词汇变量的范围内声明的。</target>
        </trans-unit>
        <trans-unit id="56e8fa65a6460263a21b0d0b067830070ec69c2a" translate="yes" xml:space="preserve">
          <source>Lexical warnings get around these limitations by allowing finer control over where warnings can or can't be tripped.</source>
          <target state="translated">词法警告可以绕过这些限制,对警告可以或不可以被触发的地方进行更精细的控制。</target>
        </trans-unit>
        <trans-unit id="dfa37e8913139b1f0a81171648bb039460ba6c8c" translate="yes" xml:space="preserve">
          <source>Lexically control overloading</source>
          <target state="translated">词汇上控制超载</target>
        </trans-unit>
        <trans-unit id="d23a9b3c648b4ba0282c9679b9e53d7ed27aaf5d" translate="yes" xml:space="preserve">
          <source>Lexing code (whether in the Perl core or not) moves this pointer past the characters that it consumes. It is also expected to perform some bookkeeping whenever a newline character is consumed. This movement can be more conveniently performed by the function &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt;, which handles newlines appropriately.</source>
          <target state="translated">Lexing代码（无论是否在Perl内核中）将指针移到它消耗的字符之外。每当使用换行符时，它也应执行一些簿记。可以通过&lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt;函数更方便地执行此移动，该函数可以适当地处理换行符。</target>
        </trans-unit>
        <trans-unit id="dbdf2fc886297cee27c73397601ff4f39103c78d" translate="yes" xml:space="preserve">
          <source>Libnet Frequently Asked Questions</source>
          <target state="translated">Libnet常见问题</target>
        </trans-unit>
        <trans-unit id="e99e9a5a6c267649059fa8147d50e8a56d55d8c3" translate="yes" xml:space="preserve">
          <source>Libraries using &lt;a href=&quot;#FUNCTIONS&quot;&gt;warnings::warn&lt;/a&gt; for custom warning categories generally don't expect &lt;a href=&quot;#FUNCTIONS&quot;&gt;warnings::warn&lt;/a&gt; to be fatal and can wind up in an unexpected state as a result. For XS modules issuing categorized warnings, such unanticipated exceptions could also expose memory leak bugs.</source>
          <target state="translated">使用&lt;a href=&quot;#FUNCTIONS&quot;&gt;警告::警告&lt;/a&gt;来定制警告类别的库通常不会期望&lt;a href=&quot;#FUNCTIONS&quot;&gt;警告::警告&lt;/a&gt;是致命的，因此可能会以意外状态结束。对于发布分类警告的XS模块，此类意外的异常也可能会暴露内存泄漏错误。</target>
        </trans-unit>
        <trans-unit id="dbfd43d16e8972c230e7e22188720b2bf73e76c5" translate="yes" xml:space="preserve">
          <source>Library ... not found</source>
          <target state="translated">图书馆.未找到</target>
        </trans-unit>
        <trans-unit id="51ac812d4d63215ce6bab6ff80843a9768d50aa3" translate="yes" xml:space="preserve">
          <source>Library modules should not in general export built-in names like &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; as part of their default &lt;code&gt;@EXPORT&lt;/code&gt; list, because these may sneak into someone else's namespace and change the semantics unexpectedly. Instead, if the module adds that name to &lt;code&gt;@EXPORT_OK&lt;/code&gt; , then it's possible for a user to import the name explicitly, but not implicitly. That is, they could say</source>
          <target state="translated">库模块通常不应将内置名称（如 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; )导出为其默认 &lt;code&gt;@EXPORT&lt;/code&gt; 列表的一部分，因为它们可能会潜入其他人的名称空间并意外更改语义。相反，如果模块将名称添加到 &lt;code&gt;@EXPORT_OK&lt;/code&gt; ，则用户可以显式而非隐式导入名称。也就是说，他们可以说</target>
        </trans-unit>
        <trans-unit id="a8774f0e51de54365d13b10f234f9f0ab4b4c7b6" translate="yes" xml:space="preserve">
          <source>License is also granted to make and use derivative works provided that such works are identified as &quot;derived from the RSA Data Security, Inc. MD5 Message-Digest Algorithm&quot; in all material mentioning or referencing the derived work.</source>
          <target state="translated">只要在所有提及或引用衍生作品的材料中标明 &quot;源自RSA数据安全公司的MD5消息解密算法&quot;,就可获得制作和使用衍生作品的许可。在所有提到或引用派生作品的材料中,必须标明 &quot;源自RSA数据安全公司的MD5消息解密算法&quot;。</target>
        </trans-unit>
        <trans-unit id="8fb9dc902cb98efd9bae2b4a142dce7fcd9e3bb0" translate="yes" xml:space="preserve">
          <source>License to copy and use this software is granted provided that it is identified as the &quot;RSA Data Security, Inc. MD5 Message-Digest Algorithm&quot; in all material mentioning or referencing this software or this function.</source>
          <target state="translated">只要在所有提及或引用本软件或本功能的材料中标明本软件为 &quot;RSA Data Security,Inc.在所有提及或引用本软件或本功能的材料中,必须注明为 &quot;RSA数据安全公司MD5消息摘要算法&quot;,才允许复制和使用本软件。</target>
        </trans-unit>
        <trans-unit id="5924fd52bf49a8494e3d053dc865b25bbec5c6e6" translate="yes" xml:space="preserve">
          <source>Licensed under the GNU General Public License version 1 or later, or the Artistic License.</source>
          <target state="translated">授权使用GNU通用公共许可证1或更高版本,或艺术许可证。</target>
        </trans-unit>
        <trans-unit id="aa636d64869928622347b0ebd93665113e78146c" translate="yes" xml:space="preserve">
          <source>Licensing</source>
          <target state="translated">Licensing</target>
        </trans-unit>
        <trans-unit id="d5b616805cf9bfc9158dfb054c59875ea327a760" translate="yes" xml:space="preserve">
          <source>Life is not quite so transparent, however, when working with legacy encodings, I/O, and certain special cases:</source>
          <target state="translated">然而,在处理传统编码、I/O和某些特殊情况时,生活就不那么透明了。</target>
        </trans-unit>
        <trans-unit id="ab3a00d7b8ef92b4d6db8938fdc867c976af1617" translate="yes" xml:space="preserve">
          <source>Lifetime of the parent process and pseudo-processes</source>
          <target state="translated">父进程和伪进程的生命期</target>
        </trans-unit>
        <trans-unit id="cb79da38fbc832bc4294ccc8e4bcfcc8a2555134" translate="yes" xml:space="preserve">
          <source>Lightweight and lvalue version of &lt;code&gt;PAD_SV&lt;/code&gt; . Get or set the value at offset &lt;code&gt;po&lt;/code&gt; in the current pad. Unlike &lt;code&gt;PAD_SV&lt;/code&gt; , does not print diagnostics with -DX. For internal use only.</source>
          <target state="translated">&lt;code&gt;PAD_SV&lt;/code&gt; 的轻量级和左值版本。获取或设置在偏移值 &lt;code&gt;po&lt;/code&gt; 在当前垫。与 &lt;code&gt;PAD_SV&lt;/code&gt; 不同，它不使用-DX打印诊断信息。仅限内部使用。</target>
        </trans-unit>
        <trans-unit id="c7e02c95fe85052fcadf9745a5f1d0358088d936" translate="yes" xml:space="preserve">
          <source>Like</source>
          <target state="translated">Like</target>
        </trans-unit>
        <trans-unit id="c9df7c5b0e2428587b12f5f968c72b403b65e631" translate="yes" xml:space="preserve">
          <source>Like &quot;@*&quot;, this is a variable-width field. The value supplied must be a scalar variable. Perl puts the first line (up to the first &quot;\n&quot;) of the text into the field, and then chops off the front of the string so that the next time the variable is referenced, more of the text can be printed. The variable will</source>
          <target state="translated">和&quot;@*&quot;一样,这是一个可变宽度的字段。提供的值必须是一个标量变量。Perl会将文本的第一行(直到第一个&quot;\n&quot;)放入字段中,然后将字符串的前面切除,这样下次引用变量时,就可以打印更多的文本。变量将</target>
        </trans-unit>
        <trans-unit id="c138d511965d3d204a9ae2bc98753a226047b504" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;, the result may be an intermediate decomposition whose components are also decomposable. Use &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; to get the final decomposition in one step.</source>
          <target state="translated">像&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）一样&lt;/a&gt;，结果可能是中间分解，其成分也可分解。使用&lt;a href=&quot;normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;一步完成最终分解。</target>
        </trans-unit>
        <trans-unit id="3de5fd7897751225569f609d59202b32bba6024a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">像&lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt;一样，但是使用Perl标量而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="9e492b6f65de514837e38acf884d2920be6c9c8e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">像&lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt;一样，但是使用文字字符串而不是字符串/长度对，并且没有预先计算的哈希。</target>
        </trans-unit>
        <trans-unit id="2de1e66c1756b6fab3c6fdb05cde4f4f25568233" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">类似于&lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt;，但是采用以nul结尾的字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="de93912de0e72db38bde2b8e898d77fc9dc7395b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">类似于&lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt;，但是采用Perl标量而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="5f93afb3b500f705910109bc574d7e2b47ae58fd" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">类似于&lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt;，但是采用文字字符串而不是字符串/长度对，并且没有预先计算的哈希。</target>
        </trans-unit>
        <trans-unit id="7bc8a6b9daffa5d612ad332627c80e1cbcfc7c28" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">类似于&lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt;，但是采用以nul结尾的字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="eaf7282f7430d0c1f55fb04bc9095993eb65be76" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">类似于&lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt;，但采用Perl标量而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="b5ef552d2079e488edcf076c50da8cfc2edf287e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">类似于&lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt;，但是采用文字字符串而不是字符串/长度对，并且没有预先计算的哈希。</target>
        </trans-unit>
        <trans-unit id="1d820027a36b428c792671f4c8e4ee5300a7823f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">类似于&lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt;，但是采用以nul结尾的字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="73c1cef4e16a8379b39bb25b20396ecc27808f0b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">类似于&lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt;，但是采用Perl标量而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="f8b72f1ae998c27a3bc7952f2e79a7833ed58822" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">类似于&lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt;，但采用文字字符串而不是字符串/长度对，并且没有预先计算的哈希。</target>
        </trans-unit>
        <trans-unit id="3d6eb33ec672f221ab14ac8aaae5ee9923295a95" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">类似于&lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt;，但是采用以nul结尾的字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="54abf6089eca44394b7d1690bb3d38c0b82d3b35" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;, but lacks a flags parameter.</source>
          <target state="translated">类似于&lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;，但是缺少flags参数。</target>
        </trans-unit>
        <trans-unit id="9d0651cf67afe661baee2be32bf57a134f79be82" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#is_utf8_string&quot;&gt;is_utf8_string&lt;/a&gt; but stores the location of the failure (in the case of &quot;utf8ness failure&quot;) or the location &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt; (in the case of &quot;utf8ness success&quot;) in the &lt;code&gt;ep&lt;/code&gt; .</source>
          <target state="translated">像&lt;a href=&quot;#is_utf8_string&quot;&gt;is_utf8_string&lt;/a&gt;但存储故障的位置（在&amp;ldquo;utf8ness失败&amp;rdquo;的情况下）或位置 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;len&lt;/code&gt; （在&amp;ldquo;utf8ness成功&amp;rdquo;的情况下）的 &lt;code&gt;ep&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4826c3546aa34ea2d0524b77459a729065bbf15b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#is_utf8_string&quot;&gt;is_utf8_string&lt;/a&gt;() but stores the location of the failure (in the case of &quot;utf8ness failure&quot;) or the location &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt; (in the case of &quot;utf8ness success&quot;) in the &lt;code&gt;ep&lt;/code&gt; , and the number of UTF-8 encoded characters in the &lt;code&gt;el&lt;/code&gt; .</source>
          <target state="translated">像&lt;a href=&quot;#is_utf8_string&quot;&gt;is_utf8_string&lt;/a&gt;（），但存储的故障发生位置（在&amp;ldquo;utf8ness失败&amp;rdquo;的情况下）或位置的 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;len&lt;/code&gt; （在&amp;ldquo;utf8ness成功&amp;rdquo;的情况下）在 &lt;code&gt;ep&lt;/code&gt; ，和UTF-8编码的字符的数目在 &lt;code&gt;el&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3df9351141888ffdcb4847144fedfdb9527ae3f1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;lex_stuff_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="translated">类似于&lt;a href=&quot;#lex_stuff_pvn&quot;&gt;lex_stuff_pvn&lt;/a&gt;，但采用文字字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="855a9fc9268cf7c56dbfa870587e398be59edc5f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#nextafter&quot;&gt;nextafter&lt;/a&gt;, but potentially more accurate.</source>
          <target state="translated">类似于&lt;a href=&quot;#nextafter&quot;&gt;nextafter&lt;/a&gt;，但可能更准确。</target>
        </trans-unit>
        <trans-unit id="c3abb505c749731ad1d3986f391df84d9a744972" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#nexttoward&quot;&gt;nexttoward&lt;/a&gt;, but potentially less accurate.</source>
          <target state="translated">类似于&lt;a href=&quot;#nexttoward&quot;&gt;nexttoward&lt;/a&gt;，但准确性可能较低。</target>
        </trans-unit>
        <trans-unit id="724b06f3c6974466e0dcb566dbe47f6fad84aa5a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">像&lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt;一样，但是使用Perl标量而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="23a489d2aec93a2d851cb278177881615d6f059f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">像&lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt;一样，但是采用文字字符串而不是字符串/长度对，并且没有预先计算的哈希。</target>
        </trans-unit>
        <trans-unit id="401a90792585ceca6e1448d38f3a439e9e9ccb83" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">像&lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt;一样，但是采用以nul结尾的字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="046451b0d57dcef450722c52bfda2597acd52bb7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;refcounted_he_new_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">类似于&lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;refcounted_he_new_pvn&lt;/a&gt;，但采用Perl标量而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="6a998ebee49893ba076a8800f452b0183aae9a49" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;refcounted_he_new_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">像&lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;refcounted_he_new_pvn&lt;/a&gt;一样，但是使用文字字符串而不是字符串/长度对，并且没有预先计算的哈希。</target>
        </trans-unit>
        <trans-unit id="65d696e7d641f983cc3e14984e6670f40737f36e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;refcounted_he_new_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">像&lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;refcounted_he_new_pvn&lt;/a&gt;一样，但是使用以nul结尾的字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="a963885aaf0f61482fbaede4f9fc78877a13624a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#remainder&quot;&gt;remainder&lt;/a&gt; but also returns the low-order bits of the quotient (n) [C99]</source>
          <target state="translated">与&lt;a href=&quot;#remainder&quot;&gt;余数&lt;/a&gt;类似，但也返回商（n）的低位[C99]</target>
        </trans-unit>
        <trans-unit id="b5282dab906515d5042c87772d3d7af38dc7d497" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#round&quot;&gt;round&lt;/a&gt;, but as integer, as opposed to floating point [C99].</source>
          <target state="translated">类似于&lt;a href=&quot;#round&quot;&gt;round&lt;/a&gt;，但是作为整数，而不是浮点数[C99]。</target>
        </trans-unit>
        <trans-unit id="a05cbd07aa430b94f88ef1127d9cc3feb4a35b92" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#strtod&quot;&gt;strtod&lt;/a&gt; but for long doubles. Defined only if the system supports long doubles.</source>
          <target state="translated">像&lt;a href=&quot;#strtod&quot;&gt;strtod&lt;/a&gt;一样，但是长双打。仅在系统支持长双打时定义。</target>
        </trans-unit>
        <trans-unit id="07f5fd00ec8eac8e99d9f1474911e3920a009bb9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#sv_does_pv&quot;&gt;sv_does_pv&lt;/a&gt;, but doesn't take a &lt;code&gt;flags&lt;/code&gt; parameter.</source>
          <target state="translated">类似于&lt;a href=&quot;#sv_does_pv&quot;&gt;sv_does_pv&lt;/a&gt;，但不带有 &lt;code&gt;flags&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="ad65fa317ddd80710d2963974312eb533dd0432b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#sv_does_sv&quot;&gt;sv_does_sv&lt;/a&gt;, but takes a nul-terminated string instead of an SV.</source>
          <target state="translated">类似于&lt;a href=&quot;#sv_does_sv&quot;&gt;sv_does_sv&lt;/a&gt;，但是采用以nul终止的字符串而不是SV。</target>
        </trans-unit>
        <trans-unit id="aa34ede2432b39dab6d8a29f4520f696d8b17636" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#sv_does_sv&quot;&gt;sv_does_sv&lt;/a&gt;, but takes a string/length pair instead of an SV.</source>
          <target state="translated">类似于&lt;a href=&quot;#sv_does_sv&quot;&gt;sv_does_sv&lt;/a&gt;，但是采用字符串/长度对而不是SV。</target>
        </trans-unit>
        <trans-unit id="0270db3e4b83c7917acde896050328f249d7140a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;isnt()&lt;/code&gt; . Checks if &lt;code&gt;$got ne $dont_expect&lt;/code&gt; . This is the numeric version.</source>
          <target state="translated">像&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt;的 &lt;code&gt;isnt()&lt;/code&gt; 一样。检查 &lt;code&gt;$got ne $dont_expect&lt;/code&gt; 。这是数字版本。</target>
        </trans-unit>
        <trans-unit id="a5f74c54ee73f3446f105290901ca9cf61ea643a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;isnt()&lt;/code&gt; . Checks if &lt;code&gt;$got ne $dont_expect&lt;/code&gt; . This is the string version.</source>
          <target state="translated">像&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt;的 &lt;code&gt;isnt()&lt;/code&gt; 一样。检查 &lt;code&gt;$got ne $dont_expect&lt;/code&gt; 。这是字符串版本。</target>
        </trans-unit>
        <trans-unit id="9693737cd3c58d515bd81ab55ef59b90671ceaba" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;like()&lt;/code&gt; . Checks if $thing matches the given &lt;code&gt;$regex&lt;/code&gt; .</source>
          <target state="translated">像&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt;的 &lt;code&gt;like()&lt;/code&gt; 。检查$ thing是否匹配给定的 &lt;code&gt;$regex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="348be5230ca4cb8628d5a3ede0642c968809d567" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;unlike()&lt;/code&gt; . Checks if $thing &lt;b&gt;does not match&lt;/b&gt; the given &lt;code&gt;$regex&lt;/code&gt; .</source>
          <target state="translated">像&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt;的 &lt;code&gt;unlike()&lt;/code&gt; 。检查$ thing &lt;b&gt;是否与&lt;/b&gt;给定的 &lt;code&gt;$regex&lt;/code&gt; &lt;b&gt;不匹配&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="75959408f273f7b39d4c26886da9ddb8ba9ee269" translate="yes" xml:space="preserve">
          <source>Like &lt;b&gt;-T&lt;/b&gt;, but taint checks will issue warnings rather than fatal errors. These warnings can now be controlled normally with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
qw(taint)&lt;/code&gt; .</source>
          <target state="translated">与&lt;b&gt;-T&lt;/b&gt;相似，但污点检查将发出警告，而不是致命错误。现在可以正常地控制这些警告，而 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(taint)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19d3972f6bfa689ac944e15f05e77cbb13096271" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&quot;extract_delimited&quot;&lt;/code&gt; , the &lt;code&gt;extract_bracketed&lt;/code&gt; function takes up to three optional scalar arguments: a string to extract from, a delimiter specifier, and a prefix pattern. As before, a missing prefix defaults to optional whitespace and a missing text defaults to &lt;code&gt;$_&lt;/code&gt; . However, a missing delimiter specifier defaults to &lt;code&gt;'{}()[]&amp;lt;&amp;gt;'&lt;/code&gt; (see below).</source>
          <target state="translated">类似于 &lt;code&gt;&quot;extract_delimited&quot;&lt;/code&gt; ， &lt;code&gt;extract_bracketed&lt;/code&gt; 函数最多包含三个可选的标量参数：要从中提取的字符串，定界符说明符和前缀模式。和以前一样，缺少的前缀默认为可选的空格，缺少的文本默认为 &lt;code&gt;$_&lt;/code&gt; 。但是，缺少的分隔符说明符默认为 &lt;code&gt;'{}()[]&amp;lt;&amp;gt;'&lt;/code&gt; （请参见下文）。</target>
        </trans-unit>
        <trans-unit id="a8638e9c741c1e67ac1a4fb8957038d6a39847eb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;:i&lt;/code&gt; , but if the value is omitted, the</source>
          <target state="translated">类似于 &lt;code&gt;:i&lt;/code&gt; ，但是如果省略该值，则</target>
        </trans-unit>
        <trans-unit id="6c3eb9fc5ff253146a577da27d5894ba1dc92861" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;:i&lt;/code&gt; , but if the value is omitted, the current value for the option will be incremented.</source>
          <target state="translated">类似于 &lt;code&gt;:i&lt;/code&gt; ，但是如果省略该值，则该选项的当前值将增加。</target>
        </trans-unit>
        <trans-unit id="a8ec6b1469cf896b7423c3e7e32f92d207da0b8f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; allows you to lie to a program about its name if you use the &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; syntax. Again, see &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 一样，如果使用 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; PROGRAM LIST语法， &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 允许您在程序中撒谎。再次，请参阅&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53ce9db24e9d8151cb0d5ad673fbb551695d8498" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; allows you to lie to a program about its name if you use the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; syntax. Again, see &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 一样，如果使用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; PROGRAM LIST语法， &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 允许您在程序中撒谎。再次，请参阅&lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c07f470d836169d71198d296d47952ad2947c4f8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $variable&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; creates a lexical alias to the package subroutine of the same name.</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $variable&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 创建了一个词汇别名同名的包子程序。</target>
        </trans-unit>
        <trans-unit id="e8bfeaa61a4310c58029cc704a58399ca890239c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;=&lt;/code&gt; , but designates the argument as optional. If omitted, an empty string will be assigned to string values options, and the value zero to numeric options.</source>
          <target state="translated">像 &lt;code&gt;=&lt;/code&gt; ，但将参数指定为可选。如果省略，则将空字符串分配给字符串值选项，将零值分配给数字选项。</target>
        </trans-unit>
        <trans-unit id="9a58c5a4f4c388955ace0d1b2c081730bec782ab" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;ARRAY&lt;/code&gt; , but takes an index as an argument to get only one element, rather than a list of all of them.</source>
          <target state="translated">类似于 &lt;code&gt;ARRAY&lt;/code&gt; ，但是将索引作为参数仅获取一个元素，而不是所有元素的列表。</target>
        </trans-unit>
        <trans-unit id="904d0219765a58ae524cd174247fe80e59898174" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; is currently called with no parameters other than the invocant package name, although that may change. Similarly, to allow for future expansion, the return value should be a single &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; value.</source>
          <target state="translated">与 &lt;code&gt;CLONE&lt;/code&gt; 一样，当前调用 &lt;code&gt;CLONE_SKIP&lt;/code&gt; 的参数除了调用方程序包名称外没有其他参数，尽管可能会更改。同样，为了允许将来扩展，返回值应为单个 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="400aa1515ac06a94cb93b93ac9f5493878616d4c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Copy&lt;/code&gt; but returns dest. Useful for encouraging compilers to tail-call optimise.</source>
          <target state="translated">与 &lt;code&gt;Copy&lt;/code&gt; 类似，但返回目标。有助于鼓励编译器进行优化。</target>
        </trans-unit>
        <trans-unit id="14537197538893226d82efeb48b7a358e65846d7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Moose&lt;/code&gt; , &lt;code&gt;Class::Accessor&lt;/code&gt; generates accessor methods and a constructor for your class.</source>
          <target state="translated">像 &lt;code&gt;Moose&lt;/code&gt; 一样， &lt;code&gt;Class::Accessor&lt;/code&gt; 为您的类生成访问器方法和构造函数。</target>
        </trans-unit>
        <trans-unit id="5dc10814cde731762cb07a8de6fded71423754dc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Move&lt;/code&gt; but returns dest. Useful for encouraging compilers to tail-call optimise.</source>
          <target state="translated">与 &lt;code&gt;Move&lt;/code&gt; 类似，但返回目标。有助于鼓励编译器进行优化。</target>
        </trans-unit>
        <trans-unit id="63bea6acc9be28a6d3cb950aea732759df8ac57d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvIV&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">类似于 &lt;code&gt;SvIV&lt;/code&gt; ,但不处理魔术。</target>
        </trans-unit>
        <trans-unit id="8f72df42d4357277ebaaa7626ab2ec8434c74b44" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvNV&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">类似于 &lt;code&gt;SvNV&lt;/code&gt; ,但不处理魔术。</target>
        </trans-unit>
        <trans-unit id="f987f68efd96052a6b0a92226467d6e95b9160b3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; , but converts sv to byte representation first if necessary.</source>
          <target state="translated">与 &lt;code&gt;SvPV&lt;/code&gt; 相似，但如有必要，请先将sv转换为字节表示形式。</target>
        </trans-unit>
        <trans-unit id="d5b21bddc458bd8cbfcd7db407bfa101b7f02dfa" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; , but converts sv to byte representation first if necessary. Guarantees to evaluate sv only once; use the more efficient &lt;code&gt;SvPVbyte&lt;/code&gt; otherwise.</source>
          <target state="translated">与 &lt;code&gt;SvPV&lt;/code&gt; 相似，但如有必要，请先将sv转换为字节表示形式。保证只评估一次sv；否则，请使用效率更高的 &lt;code&gt;SvPVbyte&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="020487c29dd87ab0c92e767efba3c8f41b9bfcc7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; , but converts sv to utf8 first if necessary.</source>
          <target state="translated">与 &lt;code&gt;SvPV&lt;/code&gt; 相似，但如有必要，可先将sv转换为utf8。</target>
        </trans-unit>
        <trans-unit id="a5a0c092212799a2ed1d29176de9f03d368894bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; , but converts sv to utf8 first if necessary. Guarantees to evaluate sv only once; use the more efficient &lt;code&gt;SvPVutf8&lt;/code&gt; otherwise.</source>
          <target state="translated">与 &lt;code&gt;SvPV&lt;/code&gt; 相似，但如有必要，可先将sv转换为utf8。保证只评估一次sv；否则，请使用效率更高的 &lt;code&gt;SvPVutf8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="728e33d136e3d988de2e0baba97a509be6c9c1b3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">类似于 &lt;code&gt;SvPV&lt;/code&gt; ,但不处理魔法。</target>
        </trans-unit>
        <trans-unit id="9f644bfac194a0b755578b81e47d7586566e4504" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; but doesn't set a length variable.</source>
          <target state="translated">类似于 &lt;code&gt;SvPV&lt;/code&gt; ，但未设置长度变量。</target>
        </trans-unit>
        <trans-unit id="153041f77422ab93c76bcbcf6550af4c15800fa0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; but will force the SV into containing a string (&lt;code&gt;SvPOK&lt;/code&gt; ), and only a string (&lt;code&gt;SvPOK_only&lt;/code&gt; ), by hook or by crook. You need force if you are going to update the &lt;code&gt;SvPVX&lt;/code&gt; directly. Processes get magic.</source>
          <target state="translated">与 &lt;code&gt;SvPV&lt;/code&gt; 相似,但是将通过钩子或弯曲将SV强制包含字符串（ &lt;code&gt;SvPOK&lt;/code&gt; ）和仅字符串（ &lt;code&gt;SvPOK_only&lt;/code&gt; ）。如果要直接更新 &lt;code&gt;SvPVX&lt;/code&gt; ,则需要用力。流程变得神奇。</target>
        </trans-unit>
        <trans-unit id="d303190c56047f26fce52e3043032426e788042e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but converts sv to byte representation first if necessary.</source>
          <target state="translated">类似于 &lt;code&gt;SvPV_force&lt;/code&gt; ，但是如有必要，首先将sv转换为字节表示形式。</target>
        </trans-unit>
        <trans-unit id="e339b69da0fc6099ae5122846dd6d16329909d09" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but converts sv to byte representation first if necessary. Guarantees to evaluate sv only once; use the more efficient &lt;code&gt;SvPVbyte_force&lt;/code&gt; otherwise.</source>
          <target state="translated">类似于 &lt;code&gt;SvPV_force&lt;/code&gt; ，但是如有必要，首先将sv转换为字节表示形式。保证只评估一次sv；否则，使用效率更高的 &lt;code&gt;SvPVbyte_force&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33e41cb5a5972955c89d4da04933a8a79726a21b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but converts sv to utf8 first if necessary.</source>
          <target state="translated">类似于 &lt;code&gt;SvPV_force&lt;/code&gt; ，但如有必要，首先将sv转换为utf8。</target>
        </trans-unit>
        <trans-unit id="85dee70f70d9f59dd1fd504ab0aa00e6dc082a6e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but converts sv to utf8 first if necessary. Guarantees to evaluate sv only once; use the more efficient &lt;code&gt;SvPVutf8_force&lt;/code&gt; otherwise.</source>
          <target state="translated">类似于 &lt;code&gt;SvPV_force&lt;/code&gt; ，但如有必要，首先将sv转换为utf8。保证只评估一次sv；否则，使用效率更高的 &lt;code&gt;SvPVutf8_force&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ed49f80c2155ad585761ac04bf59edd4a6a0831" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but doesn't process get magic.</source>
          <target state="translated">就像 &lt;code&gt;SvPV_force&lt;/code&gt; 一样，但不会处理就变魔术了。</target>
        </trans-unit>
        <trans-unit id="dd41cfed5f0aafc487ed8b935e2fe00690512ae4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_nolen&lt;/code&gt; , but converts sv to byte representation first if necessary.</source>
          <target state="translated">类似于 &lt;code&gt;SvPV_nolen&lt;/code&gt; ，但如有必要，首先将sv转换为字节表示形式。</target>
        </trans-unit>
        <trans-unit id="569d8ee3b9025e7d46c4e22dc014e9293f09b9cf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_nolen&lt;/code&gt; , but converts sv to utf8 first if necessary.</source>
          <target state="translated">与 &lt;code&gt;SvPV_nolen&lt;/code&gt; 相似，但如有必要，可先将sv转换为utf8。</target>
        </trans-unit>
        <trans-unit id="c6ed04996a1df68aa8ad7cc1586c48a5135a6669" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_nolen&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">像 &lt;code&gt;SvPV_nolen&lt;/code&gt; 一样，但是不处理魔法。</target>
        </trans-unit>
        <trans-unit id="ab106c9006a177a2bcf08f263e2472e6c9b25246" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvSetSV&lt;/code&gt; , but does any set magic required afterwards.</source>
          <target state="translated">类似于 &lt;code&gt;SvSetSV&lt;/code&gt; ，但是之后需要进行任何设置魔术。</target>
        </trans-unit>
        <trans-unit id="388de52bdbcc28141b225f26cb9f3fe2e05660c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvSetSV_nosteal&lt;/code&gt; , but does any set magic required afterwards.</source>
          <target state="translated">像 &lt;code&gt;SvSetSV_nosteal&lt;/code&gt; 一样，但是之后需要执行任何设置魔术。</target>
        </trans-unit>
        <trans-unit id="3a27275be863ed7ef192a76ef76e83185d113390" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvUV&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">类似于 &lt;code&gt;SvUV&lt;/code&gt; ,但不处理魔术。</target>
        </trans-unit>
        <trans-unit id="c145fe31e7a9856cfd103483b939c0b69292c062" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Zero&lt;/code&gt; but returns dest. Useful for encouraging compilers to tail-call optimise.</source>
          <target state="translated">像 &lt;code&gt;Zero&lt;/code&gt; 但返回目标。有助于鼓励编译器进行优化。</target>
        </trans-unit>
        <trans-unit id="7a30913145132e032417d97e9d5716e5d07e3a09" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;article&lt;/code&gt; but only fetches the body of the article.</source>
          <target state="translated">类似于 &lt;code&gt;article&lt;/code&gt; 但仅获取文章的正文。</target>
        </trans-unit>
        <trans-unit id="dbf2edb5cf6acda874d56c0ec8d6a027b38ecd7b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;article&lt;/code&gt; but only fetches the headers for the article.</source>
          <target state="translated">类似于 &lt;code&gt;article&lt;/code&gt; 但仅获取文章的标题。</target>
        </trans-unit>
        <trans-unit id="698d6282638ff97d91804a4f1cf2ced815c09a43" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;cond_wait&lt;/code&gt; , this function may take a shared, &lt;b&gt;locked&lt;/b&gt; variable as an additional parameter; in this case the first parameter is an &lt;b&gt;unlocked&lt;/b&gt; condition variable protected by a distinct lock variable.</source>
          <target state="translated">像 &lt;code&gt;cond_wait&lt;/code&gt; 一样，此函数可以将共享的&lt;b&gt;锁定&lt;/b&gt;变量作为附加参数。在这种情况下，第一个参数是受不同锁变量保护的&lt;b&gt;解锁&lt;/b&gt;条件变量。</target>
        </trans-unit>
        <trans-unit id="c58a5c550c804eb437e5a9f29a412c2a917db541" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;copy&lt;/code&gt; , &lt;code&gt;rmscopy&lt;/code&gt; returns 1 on success. If an error occurs, it sets &lt;code&gt;$!&lt;/code&gt; , deletes the output file, and returns 0.</source>
          <target state="translated">像 &lt;code&gt;copy&lt;/code&gt; 一样， &lt;code&gt;rmscopy&lt;/code&gt; 成功返回1。如果发生错误，它将设置 &lt;code&gt;$!&lt;/code&gt; ，删除输出文件，并返回0。</target>
        </trans-unit>
        <trans-unit id="62662a2fcd9593969fecb7744ceb2295a389997a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;diag()&lt;/code&gt; , but it prints to the &lt;code&gt;output()&lt;/code&gt; handle so it will not normally be seen by the user except in verbose mode.</source>
          <target state="translated">与 &lt;code&gt;diag()&lt;/code&gt; 类似，但它会打印到 &lt;code&gt;output()&lt;/code&gt; 句柄，因此，除非在详细模式下，否则通常不会被用户看到。</target>
        </trans-unit>
        <trans-unit id="983d206f2bed9edbbc722e7d5cdb62e2a06346c5" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;diag()&lt;/code&gt; , except the message will not be seen when the test is run in a harness. It will only be visible in the verbose TAP stream.</source>
          <target state="translated">类似于 &lt;code&gt;diag()&lt;/code&gt; ，但是在线束中运行测试时不会看到该消息。它仅在详细的TAP流中可见。</target>
        </trans-unit>
        <trans-unit id="4ca575f5cd45b0a03fd8f03890b4f05a0793bc86" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;gv_stashpvn&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">类似于 &lt;code&gt;gv_stashpvn&lt;/code&gt; ，但是采用文字字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="9a99146718e4827b551f9b9e65221a90a0c6896f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;hv_fetch&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">类似于 &lt;code&gt;hv_fetch&lt;/code&gt; ，但是采用文字字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="1b54ec87ed43945667a5780ba1140342cbc85083" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;hv_store&lt;/code&gt; , but takes a literal string instead of a string/length pair and omits the hash parameter.</source>
          <target state="translated">类似于 &lt;code&gt;hv_store&lt;/code&gt; ，但采用文字字符串而不是字符串/长度对，并省略了hash参数。</target>
        </trans-unit>
        <trans-unit id="87cafedf7339223e94c98617ca5452de6e823831" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;is_regexp&lt;/code&gt; this function will not be confused by overloading or blessing of the object.</source>
          <target state="translated">与 &lt;code&gt;is_regexp&lt;/code&gt; 一样，此函数也不会因对象的重载或祝福而感到困惑。</target>
        </trans-unit>
        <trans-unit id="ec33eb3b85c09c1867b94d4c5d38b36ea16437ca" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">类似于 &lt;code&gt;newSVpvn&lt;/code&gt; ，但采用以 &lt;code&gt;NUL&lt;/code&gt; 结尾的文字字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="6def24d08af466796e4eeead658a36b729d71197" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn_flags&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">类似于 &lt;code&gt;newSVpvn_flags&lt;/code&gt; ，但采用字面量为 &lt;code&gt;NUL&lt;/code&gt; 的字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="df1c507c68363b1af9c5557f4eef915d6b55b26a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn_share&lt;/code&gt; , but takes a &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">类似于 &lt;code&gt;newSVpvn_share&lt;/code&gt; ，但采用 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="3dd80874ef095a04d51bc5aa179476376e4130b1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn_share&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair and omits the hash parameter.</source>
          <target state="translated">类似于 &lt;code&gt;newSVpvn_share&lt;/code&gt; ，但采用以 &lt;code&gt;NUL&lt;/code&gt; 终止的原义字符串而不是字符串/长度对，并省略了hash参数。</target>
        </trans-unit>
        <trans-unit id="aa6a38afce596ffe8e2f194c11ba3be9d30f3333" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pasv_xfer&lt;/code&gt; but the file is stored on the remote server using the STOU command.</source>
          <target state="translated">与 &lt;code&gt;pasv_xfer&lt;/code&gt; 相似,但是文件使用STOU命令存储在远程服务器上。</target>
        </trans-unit>
        <trans-unit id="7fdced39cfee983640cff74a2b9f6b6a909daee3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;require_ok&lt;/code&gt; , but it will &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; the $module in question and only loads modules, not files.</source>
          <target state="translated">像 &lt;code&gt;require_ok&lt;/code&gt; 一样，但是它将 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 有问题的$ module并且仅加载模块，而不是文件。</target>
        </trans-unit>
        <trans-unit id="d85e64ea446b94b53e6b0a98b79acffa9e65509e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;savepvn&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">类似于 &lt;code&gt;savepvn&lt;/code&gt; ，但是采用以 &lt;code&gt;NUL&lt;/code&gt; 终止的原义字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="c6f07f68a2d9761eca21ebc3401a1a91fade1e35" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;skip()&lt;/code&gt; , only it will declare the test as failing and TODO. Similar to</source>
          <target state="translated">就像 &lt;code&gt;skip()&lt;/code&gt; 一样，只有它将声明测试失败和TODO。相似</target>
        </trans-unit>
        <trans-unit id="ffb9b95fcba79da2d66d4cd56bc634f774dac146" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;summary()&lt;/code&gt; , but with a lot more detail.</source>
          <target state="translated">类似于 &lt;code&gt;summary()&lt;/code&gt; ，但有更多详细信息。</target>
        </trans-unit>
        <trans-unit id="8bc85a8c4d9155e4879660bb0fb6db949fdb86fb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_2pv()&lt;/code&gt; , but doesn't return the length too. You should usually use the macro wrapper &lt;code&gt;SvPV_nolen(sv)&lt;/code&gt; instead.</source>
          <target state="translated">类似于 &lt;code&gt;sv_2pv()&lt;/code&gt; ，但也不会返回长度。您通常应该使用宏包装程序 &lt;code&gt;SvPV_nolen(sv)&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="e28ad4ddf0b006c6eedf3f81dcaf16c9a74e085e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_catpv&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="74ec50e9ddcc0b0b4bd0d08a497824bb0da8c599" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpv&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">像 &lt;code&gt;sv_catpv&lt;/code&gt; 一样，但是不处理魔术。</target>
        </trans-unit>
        <trans-unit id="96301ae15c375b77c0b44d75ba25e64a78136a72" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvf&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_catpvf&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="8dbd5c1c6aa34bdcc67b11a771b5ad797b082fb9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_catpvn&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="52a1bc2daa3eca49de27291192d60d01346616bc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">类似于 &lt;code&gt;sv_catpvn&lt;/code&gt; ，但是采用文字字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="1e9ddae012626cb7e4439d9980907c822af4371b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">像 &lt;code&gt;sv_catpvn&lt;/code&gt; 一样，但是不处理魔术。</target>
        </trans-unit>
        <trans-unit id="56485c39e91b575f9eb207ecfc300725f3983593" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn_flags&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">像 &lt;code&gt;sv_catpvn_flags&lt;/code&gt; 一样，但是采用一个以 &lt;code&gt;NUL&lt;/code&gt; 终止的原义字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="7f05c96d8dfa46b087685cde4a872c91ee4af9a0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn_mg&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">类似于 &lt;code&gt;sv_catpvn_mg&lt;/code&gt; ，但是采用文字字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="58d239fc60878c8dca9fcf1e90342df6ee45eef1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn_nomg&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">类似于 &lt;code&gt;sv_catpvn_nomg&lt;/code&gt; ，但是采用文字字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="8fccee46cd5a2dbdef0b3ef34ed13318240c0cba" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catsv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_catsv&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="4126df4d71505019e5bb56c7d0ec65e860e57dbf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catsv&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">像 &lt;code&gt;sv_catsv&lt;/code&gt; 一样，但是不处理魔术。</target>
        </trans-unit>
        <trans-unit id="5d38cbaa11df45cfca68f415fbd38548adbd2370" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setiv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_setiv&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="fb5a47bbf6d640fdec1cfafd760bfcac50991da5" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setnv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_setnv&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="5d50840cdec742cb9632278831faf80f40688dc0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_setpv&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="b56d7c6489caae9851ec3dcbcf0456ce3751a5c3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvf&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_setpvf&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="cc0fa3335ee153a3cf62cbff610e08349e8ad4b2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpviv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_setpviv&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="60536ff4b89cb5040f19feec4be6721d10632d63" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvn&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_setpvn&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="550ac76e7931e655b1382b031643a9cb5f52950b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvn&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">类似于 &lt;code&gt;sv_setpvn&lt;/code&gt; ，但是采用文字字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="4532add555cdc643bf47f76523943ddddd111761" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvn_mg&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">类似于 &lt;code&gt;sv_setpvn_mg&lt;/code&gt; ，但是采用文字字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="87ab2d21a73ed79e392dc24ffd68bc21b0539241" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setref_pvn&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">类似于 &lt;code&gt;sv_setref_pvn&lt;/code&gt; ，但是采用文字字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="ab2af716b65ba49b4f611a8f9a63df24afbfd34e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setsv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_setsv&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="029cf42c4714d829664184f54a69a5ea13d859b0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setsv&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">像 &lt;code&gt;sv_setsv&lt;/code&gt; 一样，但是不处理魔术。</target>
        </trans-unit>
        <trans-unit id="bae58ef52e0fd2638f20a33b2c2ee3d70d45b7c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setuv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_setuv&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="edc41b001c50d7d45a00cf8022d9c1f06a67020a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_usepvn&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_usepvn&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="4287363f537b02349404ef50aa3650a2da519053" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_vcatpvf&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="14adf015575fe99f6c00f91da82a21970e20b8bd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_vsetpvf&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">像 &lt;code&gt;sv_vsetpvf&lt;/code&gt; 一样，也可以处理&amp;ldquo;设置&amp;rdquo;魔术。</target>
        </trans-unit>
        <trans-unit id="d4ce5b4a9c5792e4e3d807965bc2f0706dc489a6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;todo()&lt;/code&gt; but only returns the value of &lt;code&gt;$TODO&lt;/code&gt; ignoring &lt;code&gt;todo_start()&lt;/code&gt; .</source>
          <target state="translated">与 &lt;code&gt;todo()&lt;/code&gt; 类似，但只返回 &lt;code&gt;$TODO&lt;/code&gt; 的值，而忽略 &lt;code&gt;todo_start()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="824220de4c99cc183f3e468cfbca9236675ff6fd" translate="yes" xml:space="preserve">
          <source>Like C, Perl does a certain amount of expression evaluation at compile time whenever it determines that all arguments to an operator are static and have no side effects. In particular, string concatenation happens at compile time between literals that don't do variable substitution. Backslash interpolation also happens at compile time. You can say</source>
          <target state="translated">和C语言一样,Perl在编译时只要确定一个操作符的所有参数都是静态的,并且没有副作用,就会进行一定量的表达式评估。特别是,在编译时,不做变量替换的字元之间会发生字符串连接。反斜线插值也会在编译时发生。你可以说</target>
        </trans-unit>
        <trans-unit id="13593327ac22cf57826e7691f4f7f418be9cc890" translate="yes" xml:space="preserve">
          <source>Like CPAN::Bundle::inst_file, but returns the $VERSION</source>
          <target state="translated">和CPAN::Bundle::inst_file一样,但返回的是$VERSION。</target>
        </trans-unit>
        <trans-unit id="180b470a6637521531543b80ac419cbc37898af4" translate="yes" xml:space="preserve">
          <source>Like Open3 but without STDERR capture.</source>
          <target state="translated">像Open3一样,但没有STDERR捕捉。</target>
        </trans-unit>
        <trans-unit id="2a63fd6efd31d5a247539ef7d4f8ae9b22c58256" translate="yes" xml:space="preserve">
          <source>Like PERLPREFIX, but only for the site install locations.</source>
          <target state="translated">像PERLPREFIX一样,但只针对站点安装位置。</target>
        </trans-unit>
        <trans-unit id="991d27f54f9be6d1ccfe86b4d87c281614bb46a9" translate="yes" xml:space="preserve">
          <source>Like PERLPREFIX, but only for the vendor install locations.</source>
          <target state="translated">像PERLPREFIX一样,但只针对供应商的安装位置。</target>
        </trans-unit>
        <trans-unit id="3763cf6a811e93d689892e612d95e5287de00f17" translate="yes" xml:space="preserve">
          <source>Like PERLRUN, except it uses FULLPERL.</source>
          <target state="translated">和PERLRUN一样,只是它使用了FULLPERL。</target>
        </trans-unit>
        <trans-unit id="8dff3350726fa7fbd1b6410bcef4d0a73c7217e0" translate="yes" xml:space="preserve">
          <source>Like PERLRUNINST, except it uses FULLPERL.</source>
          <target state="translated">和PERLRUNINST一样,只是它使用了FULLPERL。</target>
        </trans-unit>
        <trans-unit id="5841126e64b3c89df76665c26ca814c87d8e1ffb" translate="yes" xml:space="preserve">
          <source>Like PREFIX, it sets several INSTALL* attributes at once. Unlike PREFIX it is easy to predict where the module will end up. The installation pattern looks like this:</source>
          <target state="translated">和PREFIX一样,它可以同时设置多个INSTALL*属性。与Prefix不同的是,它很容易预测模块的最终位置。安装模式是这样的。</target>
        </trans-unit>
        <trans-unit id="3eac640353c06a496dbb32cf64186b352fd16578" translate="yes" xml:space="preserve">
          <source>Like T_REFREF, except it does strict type checking (inheritance is not supported).</source>
          <target state="translated">和T_REFREF一样,只是它进行严格的类型检查(不支持继承)。</target>
        </trans-unit>
        <trans-unit id="b94e5c472f080d505351ce0495c57a8957e2a984" translate="yes" xml:space="preserve">
          <source>Like Test::More's &lt;code&gt;is()&lt;/code&gt; . Checks if &lt;code&gt;$got == $expected&lt;/code&gt; . This is the numeric version.</source>
          <target state="translated">像Test :: More的 &lt;code&gt;is()&lt;/code&gt; 一样。检查 &lt;code&gt;$got == $expected&lt;/code&gt; 。这是数字版本。</target>
        </trans-unit>
        <trans-unit id="cc96ef3fc2347f9c271af1895e169a768a31a74a" translate="yes" xml:space="preserve">
          <source>Like Test::More's &lt;code&gt;is()&lt;/code&gt; . Checks if &lt;code&gt;$got eq $expected&lt;/code&gt; . This is the string version.</source>
          <target state="translated">像Test :: More的 &lt;code&gt;is()&lt;/code&gt; 一样。检查 &lt;code&gt;$got eq $expected&lt;/code&gt; 。这是字符串版本。</target>
        </trans-unit>
        <trans-unit id="f7f7c9b4de7f16b968c9df459ba87fa3286f45be" translate="yes" xml:space="preserve">
          <source>Like UTF-8, UTF-16 is a variable-width encoding, but where UTF-8 uses 8-bit code units, UTF-16 uses 16-bit code units. All code points occupy either 2 or 4 bytes in UTF-16: code points &lt;code&gt;U+0000..U+FFFF&lt;/code&gt; are stored in a single 16-bit unit, and code points &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; in two 16-bit units. The latter case is using</source>
          <target state="translated">与UTF-8一样，UTF-16是可变宽度编码，但是在UTF-8使用8位代码单元的情况下，UTF-16使用16位代码单元的情况。所有代码点在UTF-16中占用2或4个字节：代码点 &lt;code&gt;U+0000..U+FFFF&lt;/code&gt; 以单个16位单元存储，代码点 &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; 以两个16 位单元存储单位。后一种情况是使用</target>
        </trans-unit>
        <trans-unit id="8dbb04c45e23e298185620fabadd06b7455bdd6a" translate="yes" xml:space="preserve">
          <source>Like UTF-8, but EBCDIC-safe, in the way that UTF-8 is ASCII-safe. This means that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; ,</source>
          <target state="translated">与UTF-8类似，但EBCDIC安全，就像UTF-8是ASCII安全一样。这意味着所有基本字符（包括所有具有ASCII等价字符的字符（例如 &lt;code&gt;&quot;A&quot;&lt;/code&gt; ， &lt;code&gt;&quot;0&quot;&lt;/code&gt; ， &lt;code&gt;&quot;%&quot;&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="6834a3fade58397a1a46bf4fd2e951ded5a49d5e" translate="yes" xml:space="preserve">
          <source>Like a forked process, but without &lt;b&gt;fork&lt;/b&gt;&amp;rsquo;s inherent memory protection. A thread is lighter weight than a full process, in that a process could have multiple threads running around in it, all fighting over the same process&amp;rsquo;s memory space unless steps are taken to protect threads from one another.</source>
          <target state="translated">就像分叉的过程一样，但是没有&lt;b&gt;fork&lt;/b&gt;的固有内存保护。线程比整个进程的权重轻，因为一个进程可能在其中运行多个线程，除非采取措施保护线程彼此之间的距离，否则所有线程都争夺同一进程的内存空间。</target>
        </trans-unit>
        <trans-unit id="5e2266dcab58f5b4cb8dc0bb09fd899c041599a2" translate="yes" xml:space="preserve">
          <source>Like all Perl character operations, length() normally deals in logical characters, not physical bytes. For how many bytes a string encoded as UTF-8 would take up, use &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(Encode::encode_utf8(EXPR))&lt;/a&gt;&lt;/code&gt; (you'll have to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode&lt;/code&gt; first). See &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">像所有Perl字符操作一样，length（）通常处理逻辑字符，而不是物理字节。若要将编码为UTF-8的字符串占用多少字节，请使用 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(Encode::encode_utf8(EXPR))&lt;/a&gt;&lt;/code&gt; （您必须首先 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode&lt;/code&gt; ）。请参阅&lt;a href=&quot;encode&quot;&gt;编码&lt;/a&gt;和&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78626057c138b9f0db027cda4d5b95c4d7adde63" translate="yes" xml:space="preserve">
          <source>Like all Perl character operations, length() normally deals in logical characters, not physical bytes. For how many bytes a string encoded as UTF-8 would take up, use &lt;code&gt;&lt;a href=&quot;length&quot;&gt;length(Encode::encode_utf8(EXPR))&lt;/a&gt;&lt;/code&gt; (you'll have to &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Encode&lt;/code&gt; first). See &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt; and &lt;a href=&quot;../perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">像所有Perl字符操作一样，length（）通常处理逻辑字符，而不是物理字节。若要将编码为UTF-8的字符串占用多少字节，请使用 &lt;code&gt;&lt;a href=&quot;length&quot;&gt;length(Encode::encode_utf8(EXPR))&lt;/a&gt;&lt;/code&gt; （您必须首先 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Encode&lt;/code&gt; ）。请参阅&lt;a href=&quot;../encode&quot;&gt;编码&lt;/a&gt;和&lt;a href=&quot;../perlunicode&quot;&gt;perlunicode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b262f2d7a83664abc258a4d3c715339214f8a1b0" translate="yes" xml:space="preserve">
          <source>Like chapters in many books, all top-level Perl source files (along with a few others here and there) begin with an epigrammatic inscription that alludes, indirectly and metaphorically, to the material you're about to read.</source>
          <target state="translated">就像许多书中的章节一样,所有顶级的Perl源文件(以及这里和那里的一些其他文件)都以一个表意性的题词开始,它间接地、隐喻地暗示了你将要阅读的材料。</target>
        </trans-unit>
        <trans-unit id="c0d2dcb20ae20f18b840f20ba286a29e5869333a" translate="yes" xml:space="preserve">
          <source>Like config_sh() but returns, as a list, only the config entries who's names match the $regex.</source>
          <target state="translated">和config_sh()一样,但是以列表的形式只返回名字与$regex匹配的配置项。</target>
        </trans-unit>
        <trans-unit id="f227f0321acaa416e145c904a4d8ec45847b8d64" translate="yes" xml:space="preserve">
          <source>Like expand, but returns objects of the appropriate type, i.e. CPAN::Bundle objects for bundles, CPAN::Module objects for modules, and CPAN::Distribution objects for distributions. Note: it does not expand to CPAN::Author objects.</source>
          <target state="translated">和 expand 一样,但是返回适当类型的对象,例如:CPAN::Bundle 对象代表 bundles,CPAN::Module 对象代表模块,CPAN::Distribution 对象代表分发。注意:它不能扩展到 CPAN::Author 对象。</target>
        </trans-unit>
        <trans-unit id="f385d834d0c261050be5f51ac316a9238769d175" translate="yes" xml:space="preserve">
          <source>Like many languages, Perl provides for user-defined subroutines. These may be located anywhere in the main program, loaded in from other files via the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; keywords, or generated on the fly using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or anonymous subroutines. You can even call a function indirectly using a variable containing its name or a CODE reference.</source>
          <target state="translated">与许多语言一样，Perl提供了用户定义的子例程。它们可以位于主程序中的任何位置，可以通过 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 关键字从其他文件加载，也可以使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 或匿名子例程动态生成。您甚至可以使用包含名称或CODE引用的变量来间接调用函数。</target>
        </trans-unit>
        <trans-unit id="a3bb042c0a5ea5166342c8b0ad6d2f8a2141fbc4" translate="yes" xml:space="preserve">
          <source>Like octal escapes, there are two forms of hexadecimal escapes, but both start with the sequence &lt;code&gt;\x&lt;/code&gt; . This is followed by either exactly two hexadecimal digits forming a number, or a hexadecimal number of arbitrary length surrounded by curly braces. The hexadecimal number is the code point of the character you want to express.</source>
          <target state="translated">像八进制转义一样，十六进制转义有两种形式，但都以序列 &lt;code&gt;\x&lt;/code&gt; 开头。其后是恰好两个十六进制数字组成一个数字，或者是由花括号包围的任意长度的十六进制数字。十六进制数字是您要表达的字符的代码点。</target>
        </trans-unit>
        <trans-unit id="ea93e43cdaa94011eb7f20af4624fc89df3b75e2" translate="yes" xml:space="preserve">
          <source>Like other pragmas (&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; , for example), features have a lexical effect. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature qw(foo)&lt;/code&gt; will only make the feature &quot;foo&quot; available from that point to the end of the enclosing block.</source>
          <target state="translated">像其他编译指示（例如， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; ）一样，要素也具有词法效果。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature qw(foo)&lt;/code&gt; 只会使从该点到封闭块末尾的功能&amp;ldquo; foo&amp;rdquo;可用。</target>
        </trans-unit>
        <trans-unit id="f84dcad78456fba45a7cd86383d5b5d51df6ab7d" translate="yes" xml:space="preserve">
          <source>Like property names, there is typically at least a short name for each such property-value, and a long name. If you know any name of the property-value (which you can get by &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt;, you can use &lt;code&gt;prop_value_aliases&lt;/code&gt; () to get the long name (when called in scalar context), or a list of all the names, with the short name in the 0th element, the long name in the next element, and any other synonyms in the remaining elements, in no particular order, except that any all-numeric synonyms will be last.</source>
          <target state="translated">像属性名称一样，每个这样的属性值通常至少有一个短名称和一个长名称。如果知道属性值的任何名称（可以通过&lt;a href=&quot;#prop_values()&quot;&gt;prop_values（）&lt;/a&gt;获得），则可以使用 &lt;code&gt;prop_value_aliases&lt;/code&gt; （）来获取长名称（在标量上下文中调用时）或所有名称的列表，并以短名称表示名称在第0个元素中，名称在下一个元素中，长名称，以及在其余元素中的任何其他同义词（没有特殊顺序），只是所有数字同义词都将是最后一个。</target>
        </trans-unit>
        <trans-unit id="199b34f10e1b7c8e7aa443166b2eaa7617b87f12" translate="yes" xml:space="preserve">
          <source>Like sv_copypv, but doesn't invoke get magic first.</source>
          <target state="translated">和 sv_copypv 一样,但不会先调用 get magic。</target>
        </trans-unit>
        <trans-unit id="fa3c089315a35ab69068f31035a53de1242b1f4a" translate="yes" xml:space="preserve">
          <source>Like sv_utf8_upgrade, but doesn't do magic on &lt;code&gt;sv&lt;/code&gt; .</source>
          <target state="translated">就像sv_utf8_upgrade一样，但是对 &lt;code&gt;sv&lt;/code&gt; 却没有作用。</target>
        </trans-unit>
        <trans-unit id="491235f5863c419144ac401911f4034bbb235829" translate="yes" xml:space="preserve">
          <source>Like sv_utf8_upgrade_flags, but has an additional parameter &lt;code&gt;extra&lt;/code&gt; , which is the number of unused bytes the string of 'sv' is guaranteed to have free after it upon return. This allows the caller to reserve extra space that it intends to fill, to avoid extra grows.</source>
          <target state="translated">像sv_utf8_upgrade_flags一样，但是有一个额外的参数 &lt;code&gt;extra&lt;/code&gt; ，这是保证'sv'的字符串在返回后可以释放的未使用字节数。这允许呼叫者保留打算填充的额外空间，以避免额外的增长。</target>
        </trans-unit>
        <trans-unit id="b473e807de38ef5585564f3999d8d88c0c2f9ac9" translate="yes" xml:space="preserve">
          <source>Like the</source>
          <target state="translated">就像...</target>
        </trans-unit>
        <trans-unit id="8e09e117230303a3e7e1540483add81bffa29662" translate="yes" xml:space="preserve">
          <source>Like the &lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicode properties&lt;/a&gt;, most of the POSIX properties match the same regardless of whether case-insensitive (&lt;code&gt;/i&lt;/code&gt;) matching is in effect or not. The two exceptions are &lt;code&gt;[:upper:]&lt;/code&gt; and &lt;code&gt;[:lower:]&lt;/code&gt;. Under &lt;code&gt;/i&lt;/code&gt;, they each match the union of &lt;code&gt;[:upper:]&lt;/code&gt; and &lt;code&gt;[:lower:]&lt;/code&gt;.</source>
          <target state="translated">像&lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicode属性&lt;/a&gt;一样，大多数POSIX属性都匹配相同的属性，而不管大小写不敏感（ &lt;code&gt;/i&lt;/code&gt; ）匹配是否有效。这两个例外是 &lt;code&gt;[:upper:]&lt;/code&gt; 和 &lt;code&gt;[:lower:]&lt;/code&gt; 。在 &lt;code&gt;/i&lt;/code&gt; 下，它们分别匹配 &lt;code&gt;[:upper:]&lt;/code&gt; 和 &lt;code&gt;[:lower:]&lt;/code&gt; 的并集。</target>
        </trans-unit>
        <trans-unit id="2bf3175a68d636ecf9925b34e6ff6a44a156b660" translate="yes" xml:space="preserve">
          <source>Like the existing DBM Filter functionality, this module arranges for the &lt;code&gt;$_&lt;/code&gt; variable to be populated with the key or value that a filter will check. This usually means that most DBM filters tend to be very short.</source>
          <target state="translated">像现有的DBM过滤器功能一样，此模块安排 &lt;code&gt;$_&lt;/code&gt; 变量填充过滤器将检查的键或值。这通常意味着大多数DBM过滤器往往都很短。</target>
        </trans-unit>
        <trans-unit id="f3cce6c08fa97ca0be477f0721fb283a52d10b11" translate="yes" xml:space="preserve">
          <source>Like the flattened incoming parameter list, the return list is also flattened on return. So all you have managed to do here is stored everything in &lt;code&gt;@a&lt;/code&gt; and made &lt;code&gt;@b&lt;/code&gt; empty. See &lt;a href=&quot;#Pass-by-Reference&quot;&gt;Pass by Reference&lt;/a&gt; for alternatives.</source>
          <target state="translated">像展平的传入参数列表一样，返回列表在返回时也变平。因此，您在这里所做的所有工作都将所有内容存储在 &lt;code&gt;@a&lt;/code&gt; 中，并将 &lt;code&gt;@b&lt;/code&gt; 设为空。请参阅&lt;a href=&quot;#Pass-by-Reference&quot;&gt;按引用传递以&lt;/a&gt;获取替代方法。</target>
        </trans-unit>
        <trans-unit id="afd075e21a0c597db0ab2821856e88ceb5961fd6" translate="yes" xml:space="preserve">
          <source>Like the normal &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt;, except it reports according to your &lt;code&gt;level()&lt;/code&gt; .</source>
          <target state="translated">像普通的 &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 一样，除了它根据您的 &lt;code&gt;level()&lt;/code&gt; 报告。</target>
        </trans-unit>
        <trans-unit id="200195811a3c205ce0d87247b5aab2a0a4c65d8e" translate="yes" xml:space="preserve">
          <source>Like their AV counterparts, &lt;code&gt;hv_clear&lt;/code&gt; deletes all the entries in the hash table but does not actually delete the hash table. The &lt;code&gt;hv_undef&lt;/code&gt; deletes both the entries and the hash table itself.</source>
          <target state="translated">像其AV副本一样， &lt;code&gt;hv_clear&lt;/code&gt; 删除哈希表中的所有条目，但实际上并不删除哈希表。该 &lt;code&gt;hv_undef&lt;/code&gt; 同时删除该条目和哈希表本身。</target>
        </trans-unit>
        <trans-unit id="e82abff5c6c10139b1928c82bbe909480a69e24a" translate="yes" xml:space="preserve">
          <source>Likely to occur for a perl binary that was not properly installed. Correct by conducting a proper installation.</source>
          <target state="translated">可能发生在没有正确安装的perl二进制文件上。通过进行正确的安装来纠正。</target>
        </trans-unit>
        <trans-unit id="5195e8e0970c4f356d29e2dc5df49c188d971cda" translate="yes" xml:space="preserve">
          <source>Likely to occur for a perl library tree that was not properly installed. Correct by conducting a proper installation.</source>
          <target state="translated">可能发生在没有正确安装的perl库树上。通过进行正确的安装来纠正。</target>
        </trans-unit>
        <trans-unit id="5a2da7a5f3225b97435c319fa8a430eb74f8dc5d" translate="yes" xml:space="preserve">
          <source>Likely to occur for a perl that was not properly installed. Correct by conducting a proper installation.</source>
          <target state="translated">很可能发生在没有正确安装的perl上。通过进行正确的安装来纠正。</target>
        </trans-unit>
        <trans-unit id="d87358f4e2ddd3816d7f56b79a06ec5e87b2b467" translate="yes" xml:space="preserve">
          <source>Likely, you should use this only for debugging anyway.</source>
          <target state="translated">很可能,无论如何,你应该只用它来调试。</target>
        </trans-unit>
        <trans-unit id="5e2ad79894aa707c67ca50ba4a61384758d0873a" translate="yes" xml:space="preserve">
          <source>Likewise on all other OS levels. Then execute the following command, and fill in its choices</source>
          <target state="translated">同样,在其他所有操作系统级别上也是如此。然后执行下面的命令,并填写它的选项</target>
        </trans-unit>
        <trans-unit id="907735ad554b354d50508dedc314aa895182b86c" translate="yes" xml:space="preserve">
          <source>Likewise the call in:</source>
          <target state="translated">同样也是叫进来的。</target>
        </trans-unit>
        <trans-unit id="65ed6c9aec28bb7eb33858993a0680b4d9a0419f" translate="yes" xml:space="preserve">
          <source>Likewise,</source>
          <target state="translated">Likewise,</target>
        </trans-unit>
        <trans-unit id="c02c1537f9374adb04ab89c0867bc362683b8992" translate="yes" xml:space="preserve">
          <source>Likewise, &lt;code&gt;o conf KEY &lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt; LIST&lt;/code&gt; passes the LIST to the corresponding splice command.</source>
          <target state="translated">同样， &lt;code&gt;o conf KEY &lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt; LIST&lt;/code&gt; 将LIST传递给相应的splice命令。</target>
        </trans-unit>
        <trans-unit id="886e8885f96bc8b4a5e209980f534b6f61eacaf4" translate="yes" xml:space="preserve">
          <source>Likewise, Filter::Simple is also smart enough to Do The Right Thing if you use Exporter:</source>
          <target state="translated">同样,如果你使用Exporter,Filter::Simple也足够聪明,可以做正确的事情。</target>
        </trans-unit>
        <trans-unit id="160bda2110bdb1f3a950ddf5accf544eb0786069" translate="yes" xml:space="preserve">
          <source>Likewise, declaring any variables with the &lt;code&gt;:Loud&lt;/code&gt; attribute within the package:</source>
          <target state="translated">同样，在包中使用 &lt;code&gt;:Loud&lt;/code&gt; 属性声明任何变量：</target>
        </trans-unit>
        <trans-unit id="d6adecc01f3598897c4c9f089b3d20664151e435" translate="yes" xml:space="preserve">
          <source>Likewise, the &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; formats pack a string that's that many bits long. Each such format generates 1 bit of the result. These are typically followed by a repeat count like &lt;code&gt;B8&lt;/code&gt; or &lt;code&gt;B64&lt;/code&gt; .</source>
          <target state="translated">同样， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 格式会打包一个字符串，该字符串的长度为数位。每个这样的格式都会产生1位结果。这些之后通常是重复计数，例如 &lt;code&gt;B8&lt;/code&gt; 或 &lt;code&gt;B64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0cbdf24c8a85f92cd82aa3a094249d6de02bf8f" translate="yes" xml:space="preserve">
          <source>Likewise, to create a class hierarchy in which every initializer inherited by a new object is invoked:</source>
          <target state="translated">同样,创建一个类的层次结构,在这个层次结构中,每个新对象继承的初始化器都会被调用。</target>
        </trans-unit>
        <trans-unit id="70bd46189954c3a64d496328cd96089f6f4f9542" translate="yes" xml:space="preserve">
          <source>Likewise, when using the &lt;code&gt;AutoSplit&lt;/code&gt; module, try to keep your functions to 8.3 naming and case-insensitive conventions; or, at the least, make it so the resulting files have a unique (case-insensitively) first 8 characters.</source>
          <target state="translated">同样，在使用 &lt;code&gt;AutoSplit&lt;/code&gt; 模块时，请尝试使函数遵循8.3命名和不区分大小写的约定。或至少这样做，使生成的文件的前8个字符唯一（不区分大小写）。</target>
        </trans-unit>
        <trans-unit id="a73edeb8158f532278a32208dcd47fe3a3d7f86f" translate="yes" xml:space="preserve">
          <source>Limit recursion depth to N levels when dumping structures. Negative values are interpreted as infinity. Default: infinity.</source>
          <target state="translated">倾倒结构时,将递推深度限制在N级。负值解释为无穷大。默认值:无穷大。</target>
        </trans-unit>
        <trans-unit id="2d1726e76688b7950a8162233fc1e17657b1edf0" translate="yes" xml:space="preserve">
          <source>Limitation with regard to &lt;code&gt;_&lt;/code&gt;</source>
          <target state="translated">关于 &lt;code&gt;_&lt;/code&gt; 的限制</target>
        </trans-unit>
        <trans-unit id="55330d97525455296ae0e4b51ff25bb7abdac5c6" translate="yes" xml:space="preserve">
          <source>Limitation with regard to _</source>
          <target state="translated">对_的限制</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="72e092ad529e2081e851e343be794f7609f24237" translate="yes" xml:space="preserve">
          <source>Limits of time_t</source>
          <target state="translated">时间的限制_t</target>
        </trans-unit>
        <trans-unit id="6234e2f414d2b26733b9fd769dba962a7fcc3692" translate="yes" xml:space="preserve">
          <source>Limits on Numbers of Open Files on Solaris.</source>
          <target state="translated">对Solaris上开放文件数量的限制。</target>
        </trans-unit>
        <trans-unit id="a139366c419ef510c76cf49f4a191349fd578640" translate="yes" xml:space="preserve">
          <source>Line 1 is a macro, and its definition is dependent on your operating system. Line 3 references &lt;code&gt;PL_do_undump&lt;/code&gt; , a global variable - all global variables in Perl start with &lt;code&gt;PL_&lt;/code&gt; . This tells you whether the current running program was created with the &lt;code&gt;-u&lt;/code&gt; flag to perl and then</source>
          <target state="translated">第1行是一个宏，其定义取决于您的操作系统。第3行引用 &lt;code&gt;PL_do_undump&lt;/code&gt; ，这是一个全局变量-Perl中的所有全局变量 &lt;code&gt;PL_&lt;/code&gt; 。这告诉您当前正在运行的程序是否是使用 &lt;code&gt;-u&lt;/code&gt; 标志创建的，然后是perl</target>
        </trans-unit>
        <trans-unit id="34d4d7a9a244a3d12dfe7fb244172b4a39165816" translate="yes" xml:space="preserve">
          <source>Line 1 tells us we're looking at an SV which lives at &lt;code&gt;0xa04ecbc&lt;/code&gt; in memory. SVs themselves are very simple structures, but they contain a pointer to a more complex structure. In this case, it's a PV, a structure which holds a string value, at location &lt;code&gt;0xa041450&lt;/code&gt; . Line 2 is the reference count; there are no other references to this data, so it's 1.</source>
          <target state="translated">第1行告诉我们，我们正在寻找一个 &lt;code&gt;0xa04ecbc&lt;/code&gt; 在内存中0xa04ecbc的SV 。SV本身是非常简单的结构，但是它们包含一个指向更复杂结构的指针。在这种情况下，它是PV，它是一个存储字符串值的结构，位于位置 &lt;code&gt;0xa041450&lt;/code&gt; 。第2行是参考计数；对此数据没有其他引用，因此为1。</target>
        </trans-unit>
        <trans-unit id="852a5525bd0666646b8baf89f18138582eb7fb29" translate="yes" xml:space="preserve">
          <source>Line 1, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Filter::cpp&lt;/code&gt; , includes and installs the &lt;code&gt;cpp&lt;/code&gt; filter module. All source filters work this way. The use statement is compiled and executed at compile time, before any more of the file is read, and it attaches the cpp filter to the source stream behind the scenes. Now the data flow looks like this:</source>
          <target state="translated">第1行， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Filter::cpp&lt;/code&gt; ，包括并安装 &lt;code&gt;cpp&lt;/code&gt; 过滤器模块。所有源过滤器都以这种方式工作。use语句在读取文件的更多内容之前在编译时进行编译和执行，并将cpp筛选器附加到后台的源流中。现在，数据流如下所示：</target>
        </trans-unit>
        <trans-unit id="7fe884af42f04d28c78e5fe62707a6228b47c52d" translate="yes" xml:space="preserve">
          <source>Line 10 does the actual catenation: the &lt;code&gt;Move&lt;/code&gt; macro moves a chunk of memory around: we move the string &lt;code&gt;ptr&lt;/code&gt; to the end of the PV - that's the start of the PV plus its current length. We're moving &lt;code&gt;len&lt;/code&gt; bytes of type &lt;code&gt;char&lt;/code&gt; . After doing so, we need to tell Perl we've extended the string, by altering &lt;code&gt;CUR&lt;/code&gt; to reflect the new length. &lt;code&gt;SvEND&lt;/code&gt; is a macro which gives us the end of the string, so that needs to be a &lt;code&gt;&quot;\0&quot;&lt;/code&gt; .</source>
          <target state="translated">第10行进行了实际的分类： &lt;code&gt;Move&lt;/code&gt; 宏在内存中移动了一块：我们将字符串 &lt;code&gt;ptr&lt;/code&gt; 移动到PV的末尾-这是PV的开始加上当前长度。我们要移出 &lt;code&gt;char&lt;/code&gt; 类型的 &lt;code&gt;len&lt;/code&gt; 个字节。这样做之后，我们需要通过更改 &lt;code&gt;CUR&lt;/code&gt; 以反映新的长度来告诉Perl我们已经扩展了字符串。 &lt;code&gt;SvEND&lt;/code&gt; 是一个宏，它为我们提供了字符串的结尾，因此需要为 &lt;code&gt;&quot;\0&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d7912d365642f9e0b2b596d940dc9036620ccc8" translate="yes" xml:space="preserve">
          <source>Line 10 is the null op: this does exactly nothing. What is that doing there? If you see the null op, it's a sign that something has been optimized away after parsing. As we mentioned in &lt;a href=&quot;#Optimization&quot;&gt;Optimization&lt;/a&gt;, the optimization stage sometimes converts two operations into one, for example when fetching a scalar variable. When this happens, instead of rewriting the op tree and cleaning up the dangling pointers, it's easier just to replace the redundant operation with the null op. Originally, the tree would have looked like this:</source>
          <target state="translated">第10行是null操作：这完全不执行任何操作。那在那里做什么？如果您看到null op，则表明在解析后已经优化了某些内容。正如我们在&amp;ldquo; &lt;a href=&quot;#Optimization&quot;&gt;优化&amp;rdquo;中&lt;/a&gt;提到的那样，优化阶段有时会将两个运算转换为一个运算，例如在获取标量变量时。发生这种情况时，与其重写操作树并清除悬空的指针，不如将多余的操作替换为空操作会更容易。最初，树看起来像这样：</target>
        </trans-unit>
        <trans-unit id="264f13994058273b1e958110b35aba9f84b7d3f9" translate="yes" xml:space="preserve">
          <source>Line 13 manipulates the flags; since we've changed the PV, any IV or NV values will no longer be valid: if we have &lt;code&gt;$a=10; $a.=&quot;6&quot;;&lt;/code&gt; we don't want to use the old IV of 10. &lt;code&gt;SvPOK_only_utf8&lt;/code&gt; is a special UTF-8-aware version of &lt;code&gt;SvPOK_only&lt;/code&gt; , a macro which turns off the IOK and NOK flags and turns on POK. The final &lt;code&gt;SvTAINT&lt;/code&gt; is a macro which launders tainted data if taint mode is turned on.</source>
          <target state="translated">第13行处理这些标志；因为我们已经更改了PV，所以任何IV或NV值都将不再有效：如果我们有 &lt;code&gt;$a=10; $a.=&quot;6&quot;;&lt;/code&gt; 我们不希望使用10的老IV &lt;code&gt;SvPOK_only_utf8&lt;/code&gt; 是一个特殊的UTF-8识别版本 &lt;code&gt;SvPOK_only&lt;/code&gt; ，宏即关闭了IOK和NOK标志，并打开POK。最后的 &lt;code&gt;SvTAINT&lt;/code&gt; 是一个宏，如果打开污点模式，该宏将洗涤污点数据。</target>
        </trans-unit>
        <trans-unit id="755dd87e19fd3ba2af902fab337428ef967e0ea8" translate="yes" xml:space="preserve">
          <source>Line 3 are the flags for this SV - it's OK to use it as a PV, it's a read-only SV (because it's a constant) and the data is a PV internally. Next we've got the contents of the string, starting at location &lt;code&gt;0xa0484e0&lt;/code&gt; .</source>
          <target state="translated">第3行是该SV的标志-可以将其用作PV，它是只读SV（因为它是一个常量），并且数据在内部是PV。接下来，我们从位置 &lt;code&gt;0xa0484e0&lt;/code&gt; 开始获取字符串的内容。</target>
        </trans-unit>
        <trans-unit id="40714861418609c0c173cdb387c1235ef584feb6" translate="yes" xml:space="preserve">
          <source>Line 4 calls a function in</source>
          <target state="translated">第4行调用</target>
        </trans-unit>
        <trans-unit id="fce643cab9a4e3c9a722892a06301bcddec99baf" translate="yes" xml:space="preserve">
          <source>Line 5 gives us the current length of the string - note that this does &lt;b&gt;not&lt;/b&gt; include the null terminator. Line 6 is not the length of the string, but the length of the currently allocated buffer; as the string grows, Perl automatically extends the available storage via a routine called &lt;code&gt;SvGROW&lt;/code&gt; .</source>
          <target state="translated">5号线给我们的字符串的当前长度-注意，这并&lt;b&gt;没有&lt;/b&gt;包括空终止符。第6行不是字符串的长度，而是当前分配的缓冲区的长度。随着字符串的增长，Perl通过名为 &lt;code&gt;SvGROW&lt;/code&gt; 的例程自动扩展可用存储。</target>
        </trans-unit>
        <trans-unit id="e801a645ef8652f9762283242a90486b96636e4b" translate="yes" xml:space="preserve">
          <source>Line 5 is another variable declaration - all variable declarations start with &lt;code&gt;d&lt;/code&gt; - which pops from the top of the argument stack two NVs (hence &lt;code&gt;nn&lt;/code&gt; ) and puts them into the variables &lt;code&gt;right&lt;/code&gt; and &lt;code&gt;left&lt;/code&gt; , hence the &lt;code&gt;rl&lt;/code&gt; . These are the two operands to the addition operator. Next, we call &lt;code&gt;SETn&lt;/code&gt; to set the NV of the return value to the result of adding the two values. This done, we return - the &lt;code&gt;RETURN&lt;/code&gt; macro makes sure that our return value is properly handled, and we pass the next operator to run back to the main run loop.</source>
          <target state="translated">第5行是另一个变量声明-所有变量声明都以 &lt;code&gt;d&lt;/code&gt; 开头-它从参数堆栈的顶部弹出两个NV（因此为 &lt;code&gt;nn&lt;/code&gt; ），并将它们分别放在变量的 &lt;code&gt;right&lt;/code&gt; 和 &lt;code&gt;left&lt;/code&gt; ，即 &lt;code&gt;rl&lt;/code&gt; 。这是加法运算符的两个操作数。接下来，我们调用 &lt;code&gt;SETn&lt;/code&gt; 将返回值的NV设置为两个值相加的结果。完成此操作后，我们返回 &lt;code&gt;RETURN&lt;/code&gt; 宏确保正确处理了我们的返回值，然后将下一个运算符传递回主运行循环。</target>
        </trans-unit>
        <trans-unit id="9ab0a06fa26dc1e693bbb46194cc19123ec14b86" translate="yes" xml:space="preserve">
          <source>Line 6 installs the city name into the appropriate array. &lt;code&gt;$table{$country}&lt;/code&gt; now holds a reference to the array of cities seen in that country so far. Line 6 is exactly like</source>
          <target state="translated">第6行将城市名称安装到适当的数组中。 &lt;code&gt;$table{$country}&lt;/code&gt; 现在引用了该国到目前为止所看到的城市。6号线就像</target>
        </trans-unit>
        <trans-unit id="62686b06fae48d96cf870eba5c52faaa0c94ec93" translate="yes" xml:space="preserve">
          <source>Line number that will be executed next.</source>
          <target state="translated">接下来要执行的行号。</target>
        </trans-unit>
        <trans-unit id="4c2e43f7c549f47cf9031361a83c442a60f08003" translate="yes" xml:space="preserve">
          <source>Line up corresponding items vertically.</source>
          <target state="translated">将相应的项目垂直排列。</target>
        </trans-unit>
        <trans-unit id="90a0a22c457fd80684a0398fb72051a69780b70d" translate="yes" xml:space="preserve">
          <source>Line up corresponding things vertically, especially if it'd be too long to fit on one line anyway.</source>
          <target state="translated">把相应的东西竖着排起来,特别是如果太长了,反正一条线上放不下。</target>
        </trans-unit>
        <trans-unit id="fddad56552c576f0323dae03070effe7302ccb5f" translate="yes" xml:space="preserve">
          <source>Line up your transliterations when it makes sense:</source>
          <target state="translated">在有意义的时候排好你的译名。</target>
        </trans-unit>
        <trans-unit id="4dd6f945e5b458504f42d21fe69947944476c20f" translate="yes" xml:space="preserve">
          <source>Line wrapping to form simple paragraphs</source>
          <target state="translated">绕行以形成简单的段落</target>
        </trans-unit>
        <trans-unit id="3c31b396df21c211f23a01f3c792334d1e4f696c" translate="yes" xml:space="preserve">
          <source>Line-by-line debugging. Causes &lt;code&gt;DB::DB()&lt;/code&gt; subroutine to be called for each statement executed. Also causes saving source code lines (like 0x400).</source>
          <target state="translated">逐行调试。原因 &lt;code&gt;DB::DB()&lt;/code&gt; 子程序被调用执行每个语句。也导致保存源代码行（如0x400）。</target>
        </trans-unit>
        <trans-unit id="6544069544ff400a2f96a13aacecf88aefcebba3" translate="yes" xml:space="preserve">
          <source>Lines 2-4 acquire a city and country name. Line 5 looks to see if the country is already present as a key in the hash. If it's not, the program uses the &lt;code&gt;[]&lt;/code&gt; notation (&lt;b&gt;Make Rule 2&lt;/b&gt;) to manufacture a new, empty anonymous array of cities, and installs a reference to it into the hash under the appropriate key.</source>
          <target state="translated">第2-4行获取城市和国家/地区名称。第5行查看该国家/地区是否已作为哈希中的键存在。如果不是，程序将使用 &lt;code&gt;[]&lt;/code&gt; 表示法（&lt;b&gt;制定规则2&lt;/b&gt;）来制造一个新的空的匿名城市数组，并在适当的键下将对它的引用安装到哈希中。</target>
        </trans-unit>
        <trans-unit id="f9204249863f9ef26ff51a8eb193e8408a39e90b" translate="yes" xml:space="preserve">
          <source>Lines 2-7 are responsible for building the structure in the first place. Here they are again:</source>
          <target state="translated">第2-7行首先负责建立结构。它们又在这里。</target>
        </trans-unit>
        <trans-unit id="de6cda1578fd7d9e7a9658f2b0c6b2f1938e7d0c" translate="yes" xml:space="preserve">
          <source>Lines are wrapped at &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; columns (default value: 76). &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; should be set to the full width of your output device. In fact, every resulting line will have length of no more than &lt;code&gt;$columns - 1&lt;/code&gt; .</source>
          <target state="translated">行被包装在 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; 列（默认值：76）。 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; 应该设置为输出设备的完整宽度。实际上，每条结果行的长度不得超过 &lt;code&gt;$columns - 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b80c81ac338346fa6d5a46950a43da0e9261d9f" translate="yes" xml:space="preserve">
          <source>Linguistic tailoring for DUCET via Unicode::Collate</source>
          <target state="translated">通过Unicode::Collate为DUCET进行语言上的调整。</target>
        </trans-unit>
        <trans-unit id="911361fa28ffec535144574ef716816f8b8cd069" translate="yes" xml:space="preserve">
          <source>Link count not updated because hard links are not quite that hard (They are sort of half-way between hard and soft links). (AmigaOS)</source>
          <target state="translated">链接数没有更新,因为硬链接并不是很硬(它们算是硬链接和软链接的中间环节)。(AmigaOS)</target>
        </trans-unit>
        <trans-unit id="1bd9f440f54676f1bb94923dc077847ab746b4ad" translate="yes" xml:space="preserve">
          <source>Link dynamic extensions with AddressSanitizer. You must manually specify &lt;code&gt;-shared&lt;/code&gt; because using &lt;code&gt;-Alddlflags=-shared&lt;/code&gt; will prevent Configure from setting a default value for &lt;code&gt;lddlflags&lt;/code&gt; , which usually contains &lt;code&gt;-shared&lt;/code&gt; (at least on Linux).</source>
          <target state="translated">将动态扩展与AddressSanitizer链接。您必须手动指定 &lt;code&gt;-shared&lt;/code&gt; 因为使用 &lt;code&gt;-Alddlflags=-shared&lt;/code&gt; 将防止从配置设置的默认值 &lt;code&gt;lddlflags&lt;/code&gt; ，通常包含 &lt;code&gt;-shared&lt;/code&gt; （至少在Linux上）。</target>
        </trans-unit>
        <trans-unit id="14f974c23cae7ac7ab09ab4582a91560c7102a2b" translate="yes" xml:space="preserve">
          <source>Link the perl executable with AddressSanitizer.</source>
          <target state="translated">用AddressSanitizer链接perl可执行文件。</target>
        </trans-unit>
        <trans-unit id="41c90512ffda6347e72f72d0a6f190da9ca1b80a" translate="yes" xml:space="preserve">
          <source>Link this text to that manual page. E.g., &lt;code&gt;L&amp;lt;Perl Error Messages|perldiag&amp;gt;&lt;/code&gt;</source>
          <target state="translated">将此文本链接到该手册页。例如， &lt;code&gt;L&amp;lt;Perl Error Messages|perldiag&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da1dd85543ffc6fef88aec54ac7001cdb21f6577" translate="yes" xml:space="preserve">
          <source>Link this text to that section in that manual page. E.g., &lt;code&gt;L&amp;lt;postfix &quot;if&quot;|perlsyn/&quot;Statement Modifiers&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">将此文本链接到该手册页中的该部分。例如， &lt;code&gt;L&amp;lt;postfix &quot;if&quot;|perlsyn/&quot;Statement Modifiers&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a893b38edbd5af20fcd220578252e31f67b32a6" translate="yes" xml:space="preserve">
          <source>Link this text to that section in this manual page. E.g., &lt;code&gt;L&amp;lt;the various attributes|/&quot;Member Data&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">将此文本链接到本手册页中的该部分。例如， &lt;code&gt;L&amp;lt;the various attributes|/&quot;Member Data&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a75b0dcbc63f378ca4b7ba049d880c48c223d9a" translate="yes" xml:space="preserve">
          <source>Link to a Perl manual page (e.g., &lt;code&gt;L&amp;lt;Net::Ping&amp;gt;&lt;/code&gt; ). Note that &lt;code&gt;name&lt;/code&gt; should not contain spaces. This syntax is also occasionally used for references to Unix man pages, as in &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">链接到Perl手册页（例如 &lt;code&gt;L&amp;lt;Net::Ping&amp;gt;&lt;/code&gt; ）。请注意， &lt;code&gt;name&lt;/code&gt; 不得包含空格。如 &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; 一样，该语法有时也用于引用Unix手册页。</target>
        </trans-unit>
        <trans-unit id="5ebcbb26d8410e15ec0a3bf942439d1fa6f0dc0e" translate="yes" xml:space="preserve">
          <source>Link to a section in other manual page. E.g., &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">链接到其他手册页中的部分。例如， &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a4be78347858c96ca4af009ad12e83b583efec3" translate="yes" xml:space="preserve">
          <source>Link to a section in this manual page. E.g., &lt;code&gt;L&amp;lt;/&quot;Object Methods&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">链接到本手册页面的一部分。例如， &lt;code&gt;L&amp;lt;/&quot;Object Methods&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c060793b58b5034337a483732320e10661d5f930" translate="yes" xml:space="preserve">
          <source>Linker Problems in Irix</source>
          <target state="translated">Irix中的链接器问题</target>
        </trans-unit>
        <trans-unit id="632c0116497fe7ec21df3b6015a06dceee2c2e46" translate="yes" xml:space="preserve">
          <source>Links to an absolute URL. For example, &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;The Perl Home Page|&lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">链接到绝对URL。例如， &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;L&amp;lt;The Perl Home Page|&lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ec4f23be8f3036b01885e23831c9d8422f8e25f" translate="yes" xml:space="preserve">
          <source>Linux Magazine</source>
          <target state="translated">Linux杂志</target>
        </trans-unit>
        <trans-unit id="2187306118c639d0411d3a1f0eea679c435e121f" translate="yes" xml:space="preserve">
          <source>Linux-specific shortcuts to specify the &lt;code&gt;O_NONBLOCK&lt;/code&gt; and &lt;code&gt;FD_CLOEXEC&lt;/code&gt; flags during a &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket(2)&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">特定于Linux的快捷方式，用于在 &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket(2)&lt;/a&gt;&lt;/code&gt; 调用期间指定 &lt;code&gt;O_NONBLOCK&lt;/code&gt; 和 &lt;code&gt;FD_CLOEXEC&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="7aaedd94529deff9e35130dfc5ae5796d73c29a7" translate="yes" xml:space="preserve">
          <source>LinuxThreads is now obsolete on Linux, and caching &lt;code&gt;getpid()&lt;/code&gt; like this made embedding perl unnecessarily complex (since you'd have to manually update the value of $$), so now &lt;code&gt;$$&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/getppid&quot;&gt;getppid()&lt;/a&gt;&lt;/code&gt; will always return the same values as the underlying C library.</source>
          <target state="translated">LinuxThreads现在在Linux上已经过时了，像这样缓存 &lt;code&gt;getpid()&lt;/code&gt; 使得嵌入perl变得不必要地复杂（因为您必须手动更新$$的值），所以现在 &lt;code&gt;$$&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/getppid&quot;&gt;getppid()&lt;/a&gt;&lt;/code&gt; 将始终返回与基础C库。</target>
        </trans-unit>
        <trans-unit id="29c9d470de128561132f93d1517a546cc93f2ef7" translate="yes" xml:space="preserve">
          <source>List (default all) actions, breakpoints and watch expressions</source>
          <target state="translated">列表(默认为全部)动作、断点和观察表达式</target>
        </trans-unit>
        <trans-unit id="4f52dc39b8b924455cea92e15110632fa2352d9b" translate="yes" xml:space="preserve">
          <source>List &lt;code&gt;incr+1&lt;/code&gt; lines starting at &lt;code&gt;min&lt;/code&gt; .</source>
          <target state="translated">列出从 &lt;code&gt;min&lt;/code&gt; 开始的 &lt;code&gt;incr+1&lt;/code&gt; 行。</target>
        </trans-unit>
        <trans-unit id="605938e2092b0e1418a4f6b86421f6d6aadd1b04" translate="yes" xml:space="preserve">
          <source>List Operators (Rightward)</source>
          <target state="translated">列表操作符(向右</target>
        </trans-unit>
        <trans-unit id="ea9c7040ec8c47c48d227dc0186264691d25d357" translate="yes" xml:space="preserve">
          <source>List a single line.</source>
          <target state="translated">列一个单行。</target>
        </trans-unit>
        <trans-unit id="43aa9239459d3ee11976e9110444e7fe09843446" translate="yes" xml:space="preserve">
          <source>List all build directories of distributions that have been tested successfully but have not yet been installed. See also &lt;code&gt;install_tested&lt;/code&gt; .</source>
          <target state="translated">列出已成功测试但尚未安装的发行版的所有构建目录。另请参阅 &lt;code&gt;install_tested&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="370cf490cd3daa93894252ec5158b9c077c837f2" translate="yes" xml:space="preserve">
          <source>List assignment in scalar context returns the number of elements produced by the expression on the right side of the assignment:</source>
          <target state="translated">标量上下文中的列表赋值返回赋值右侧表达式所产生的元素数。</target>
        </trans-unit>
        <trans-unit id="45a5a84ab7f0560a41223626f7533a814734e050" translate="yes" xml:space="preserve">
          <source>List constants</source>
          <target state="translated">列表常数</target>
        </trans-unit>
        <trans-unit id="55d8dbd99ddbc695154ff187f15da85365e9e00f" translate="yes" xml:space="preserve">
          <source>List constants are lists, not arrays. To index or slice them, they must be placed in parentheses.</source>
          <target state="translated">列表常量是列表,不是数组。要对它们进行索引或切分,必须将它们放在括号中。</target>
        </trans-unit>
        <trans-unit id="c9230863aaf9811a194bc857bc0390c6326f13d9" translate="yes" xml:space="preserve">
          <source>List constants are not inlined unless you are using Perl v5.20 or higher. In v5.20 or higher, they are still not read-only, but that may change in future versions.</source>
          <target state="translated">除非你使用的是 Perl v5.20 或更高版本,否则列表常量不会内联。在 v5.20 或更高版本中,它们仍然不是只读的,但在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="5d9c4f2773006f355714dc08c4a64f23012ee969" translate="yes" xml:space="preserve">
          <source>List directories as they are searched</source>
          <target state="translated">根据搜索结果列出目录</target>
        </trans-unit>
        <trans-unit id="0865484d5c94ce11961bf51a22181df567484e88" translate="yes" xml:space="preserve">
          <source>List first window of lines from subroutine.</source>
          <target state="translated">列出子程序的第一个窗口的行。</target>
        </trans-unit>
        <trans-unit id="19ff7a57a5555c3820cb313b589ff3e43f5801b3" translate="yes" xml:space="preserve">
          <source>List lines &lt;code&gt;min&lt;/code&gt; through &lt;code&gt;max&lt;/code&gt; . &lt;code&gt;l -&lt;/code&gt; is synonymous to &lt;code&gt;-&lt;/code&gt; .</source>
          <target state="translated">列出从 &lt;code&gt;min&lt;/code&gt; 到 &lt;code&gt;max&lt;/code&gt; 的行。 &lt;code&gt;l -&lt;/code&gt; 是同义 &lt;code&gt;-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b2f29a334d30972bc8a9045f68baae0dc3ec6d8" translate="yes" xml:space="preserve">
          <source>List next window of lines.</source>
          <target state="translated">列出下一个窗口的行。</target>
        </trans-unit>
        <trans-unit id="5359c0166343c48f9f035c401a1a6fd47a5d3c30" translate="yes" xml:space="preserve">
          <source>List of</source>
          <target state="translated">列表</target>
        </trans-unit>
        <trans-unit id="c7b2bf307cdc3add3b560b3cf9c6d9638160226a" translate="yes" xml:space="preserve">
          <source>List of _CHECK_ values</source>
          <target state="translated">_CHECK_值列表</target>
        </trans-unit>
        <trans-unit id="42e3128876d62127f71da94d3596564663a283a7" translate="yes" xml:space="preserve">
          <source>List of handlers that have been registered.</source>
          <target state="translated">已登记的处理人名单。</target>
        </trans-unit>
        <trans-unit id="942be8ea6b09c5850208d901ada25608760abbb7" translate="yes" xml:space="preserve">
          <source>List of libraries that need to be linked with when linking a perl binary which includes this extension. Only those libraries that actually exist are included. These are written to a file and used when linking perl.</source>
          <target state="translated">当链接一个包含该扩展的perl二进制文件时,需要链接的库列表。只包括那些实际存在的库。这些库会被写入一个文件,并在链接perl时使用。</target>
        </trans-unit>
        <trans-unit id="25c88a0a5acb1948d9832032688b4c20061ebe55" translate="yes" xml:space="preserve">
          <source>List of lines in currently loaded file.</source>
          <target state="translated">当前加载文件中的行列表。</target>
        </trans-unit>
        <trans-unit id="e2c751f0916c7f646852ece1bcfc81eae8d05b8f" translate="yes" xml:space="preserve">
          <source>List of object files, defaults to '$(BASEEXT)$(OBJ_EXT)', but can be a long string or an array containing all object files, e.g. &quot;tkpBind.o tkpButton.o tkpCanvas.o&quot; or [&quot;tkpBind.o&quot;, &quot;tkpButton.o&quot;, &quot;tkpCanvas.o&quot;]</source>
          <target state="translated">对象文件列表,默认为'$(BASEEXT)$(OBJ_EXT)',但可以是一个长字符串或包含所有对象文件的数组,例如 &quot;tkpBind.o tkpButton.o tkpCanvas.o &quot;或[&quot;tkpBind.o&quot;、&quot;tkpButton.o&quot;、&quot;tkpCanvas.o&quot;]。</target>
        </trans-unit>
        <trans-unit id="5c1db3ac864f059bce7875da034cf8c723ca64e1" translate="yes" xml:space="preserve">
          <source>List of those libraries that are needed but can be linked in dynamically at run time on this platform. SunOS/Solaris does not need this because ld records the information (from LDLOADLIBS) into the object file. This list is used to create a .bs (bootstrap) file.</source>
          <target state="translated">列出那些需要但可以在这个平台上运行时动态链接进来的库。SunOS/Solaris不需要这个,因为ld会把信息(来自LDLOADLIBS)记录到对象文件中。这个列表用来创建一个.bs(bootstrap)文件。</target>
        </trans-unit>
        <trans-unit id="5a0cf49d555f62d3d4e052b6541ec31f30e51960" translate="yes" xml:space="preserve">
          <source>List of those libraries which can or must be linked into the shared library when created using ld. These may be static or dynamic libraries. LD_RUN_PATH is a colon separated list of the directories in LDLOADLIBS. It is passed as an environment variable to the process that links the shared library.</source>
          <target state="translated">当使用ld创建时,可以或必须链接到共享库中的库的列表。这些库可以是静态库,也可以是动态库。LD_RUN_PATH是一个用冒号分隔的LDLOADLIBS目录列表。它作为一个环境变量传递给链接共享库的进程。</target>
        </trans-unit>
        <trans-unit id="2868b38546ebc5d5d8fcc48449cbafe99e0ffc2a" translate="yes" xml:space="preserve">
          <source>List out all pre-prompt Perl command actions.</source>
          <target state="translated">列出所有Perl命令前的动作。</target>
        </trans-unit>
        <trans-unit id="b2fda16ba9c5deaf514c003911417714fab1f6a2" translate="yes" xml:space="preserve">
          <source>List out post-prompt Perl command actions.</source>
          <target state="translated">列出提示后的Perl命令操作。</target>
        </trans-unit>
        <trans-unit id="b85c9a7b9160438294dae5b78f69ab7f0a89edb4" translate="yes" xml:space="preserve">
          <source>List out pre-prompt debugger commands.</source>
          <target state="translated">列出提示前的调试器命令。</target>
        </trans-unit>
        <trans-unit id="c433826fb0a01d3298adbd1cec75ac79e366fe70" translate="yes" xml:space="preserve">
          <source>List previous window of lines.</source>
          <target state="translated">列出上一个窗口的行。</target>
        </trans-unit>
        <trans-unit id="6828bea1ce4a116f7cab52f1ff715d22eb63c991" translate="yes" xml:space="preserve">
          <source>List subroutine names [not] matching the regex.</source>
          <target state="translated">列出[不]匹配regex的子程序名称。</target>
        </trans-unit>
        <trans-unit id="07d9bedea128205ac0ccf6ba46b2275b7e0355dc" translate="yes" xml:space="preserve">
          <source>List value constructors</source>
          <target state="translated">列表值构造器</target>
        </trans-unit>
        <trans-unit id="3b83ab8a9c9e9daa0f3c240465a14ac3cfec98b6" translate="yes" xml:space="preserve">
          <source>List values are denoted by separating individual values by commas (and enclosing the list in parentheses where precedence requires it):</source>
          <target state="translated">列表值用逗号隔开单个值来表示(如果优先级需要,则用括号将列表括起来)。</target>
        </trans-unit>
        <trans-unit id="9c332d7d437db4bb1a089aef08dedde1d03aa848" translate="yes" xml:space="preserve">
          <source>List values in scalar context</source>
          <target state="translated">在标量上下文中列出数值</target>
        </trans-unit>
        <trans-unit id="3e21f245885fcb8d2afb9ad390e31a12b2893368" translate="yes" xml:space="preserve">
          <source>List which methods may be called on the result of the evaluated expression. The expression may evaluated to a reference to a blessed object, or to a package name.</source>
          <target state="translated">列出哪些方法可以被调用到被评估的表达式的结果上。表达式可以被评估为对受祝福对象的引用,也可以被评估为包名。</target>
        </trans-unit>
        <trans-unit id="d8403bab2922ebc2678fad6cf5cb327231181154" translate="yes" xml:space="preserve">
          <source>List::Util</source>
          <target state="translated">List::Util</target>
        </trans-unit>
        <trans-unit id="0553bce08d5ad663737a32d66e461a6fde4d42cc" translate="yes" xml:space="preserve">
          <source>List::Util - A selection of general-utility list subroutines</source>
          <target state="translated">List::Util-一个普通实用的列表子程序的选择。</target>
        </trans-unit>
        <trans-unit id="e6ae9327a79eb9d0433ed0271e4debca709ad198" translate="yes" xml:space="preserve">
          <source>List::Util::XS</source>
          <target state="translated">List::Util::XS</target>
        </trans-unit>
        <trans-unit id="6a577f2f652a9865e261b6b1b9108f10eb35a6b7" translate="yes" xml:space="preserve">
          <source>List::Util::XS - Indicate if List::Util was compiled with a C compiler</source>
          <target state="translated">List::Util::XS-指示List::Util是否是用C编译器编译的。</target>
        </trans-unit>
        <trans-unit id="577f684095ccbc8608cf104c7d53ed608fc27e62" translate="yes" xml:space="preserve">
          <source>Listed below are functions that are either completely unimplemented or else have been implemented differently on various platforms. Following each description will be, in parentheses, a list of platforms that the description applies to.</source>
          <target state="translated">下面列出的是完全没有实现的功能,或者在不同平台上有不同的实现方式。在每个描述后面的括号中,将列出该描述适用的平台。</target>
        </trans-unit>
        <trans-unit id="c2100cb1ce0771ebf5c66d34af2b3109940abd61" translate="yes" xml:space="preserve">
          <source>Listing available encodings</source>
          <target state="translated">列出可用的编码</target>
        </trans-unit>
        <trans-unit id="dd09e23888b88d8b373ca4d91ed87f3200a2d3a8" translate="yes" xml:space="preserve">
          <source>Lists all available encodings, one per line, in case-insensitive order. Note that only the canonical names are listed; many aliases exist. For example, the names are case-insensitive, and many standard and common aliases work, such as &quot;latin1&quot; for &quot;ISO-8859-1&quot;, or &quot;ibm850&quot; instead of &quot;cp850&quot;, or &quot;winlatin1&quot; for &quot;cp1252&quot;. See &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt; for a full discussion.</source>
          <target state="translated">列出所有可用的编码，每行一种，不区分大小写。请注意，仅列出了规范名称；存在许多别名。例如，名称不区分大小写，并且可以使用许多标准别名和通用别名，例如&amp;ldquo; ISO-8859-1&amp;rdquo;的&amp;ldquo; latin1&amp;rdquo;，而不是&amp;ldquo; cp850&amp;rdquo;的&amp;ldquo; ibm850&amp;rdquo;或&amp;ldquo; cp1252&amp;rdquo;的&amp;ldquo; winlatin1&amp;rdquo; 。有关完整的讨论，请参见&lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4e9b933aa47588e5dca2e5d37752f783428eced" translate="yes" xml:space="preserve">
          <source>Lists known issues and incompatibilities; &lt;code&gt;&lt;a href=&quot;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&quot;&gt;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">列出已知问题和不兼容性； &lt;code&gt;&lt;a href=&quot;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&quot;&gt;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14b97602e24bdf80cc94582bec0e02d773290ecc" translate="yes" xml:space="preserve">
          <source>Lists may be assigned to only when each element of the list is itself legal to assign to:</source>
          <target state="translated">只有当列表中的每个元素本身是合法的时,才可以将列表分配给。</target>
        </trans-unit>
        <trans-unit id="91575e88330ca0a393b09df24c2f9572b830580f" translate="yes" xml:space="preserve">
          <source>Ll</source>
          <target state="translated">Ll</target>
        </trans-unit>
        <trans-unit id="ddcb77ff769ea54ca622848f6bedd4004fa4f4fa" translate="yes" xml:space="preserve">
          <source>Load</source>
          <target state="translated">Load</target>
        </trans-unit>
        <trans-unit id="dfb2a396182dae27999fc6c1e32de77266a8eaa5" translate="yes" xml:space="preserve">
          <source>Load a different math lib, see &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;MATH LIBRARY&lt;/a&gt;.</source>
          <target state="translated">加载其他数学库，请参见&lt;a href=&quot;#MATH-LIBRARY&quot;&gt;MATH LIBRARY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44a359a67f4a6d92b34e91186041854ab36b846b" translate="yes" xml:space="preserve">
          <source>Load a different math lib, see &lt;a href=&quot;#Math-Library&quot;&gt;Math Library&lt;/a&gt;.</source>
          <target state="translated">加载其他数学库，请参见&lt;a href=&quot;#Math-Library&quot;&gt;数学库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26c9c83eb2148dde20d87505b058099c18e18cdd" translate="yes" xml:space="preserve">
          <source>Load a harness replacement class.</source>
          <target state="translated">加载一个线束替换类。</target>
        </trans-unit>
        <trans-unit id="3ab8a70aafed206e446c89069a6d6fa487286375" translate="yes" xml:space="preserve">
          <source>Load functions only on demand</source>
          <target state="translated">负载功能只在需要时才会出现</target>
        </trans-unit>
        <trans-unit id="1a6bf14720b01e30066247880d6ebc3b8752469c" translate="yes" xml:space="preserve">
          <source>Load subroutines only on demand</source>
          <target state="translated">仅按需加载子程序</target>
        </trans-unit>
        <trans-unit id="d792f29bac65ac823df5b7bb2984ae1cc96bc863" translate="yes" xml:space="preserve">
          <source>Load the C Fcntl.h defines</source>
          <target state="translated">加载C Fcntl.h的定义。</target>
        </trans-unit>
        <trans-unit id="240fa313380982dac95b53cefb0c75077c026845" translate="yes" xml:space="preserve">
          <source>Load the state from a file</source>
          <target state="translated">从文件中加载状态</target>
        </trans-unit>
        <trans-unit id="15cac79f7c6e29d135cac8ed345f5ee74ad107b9" translate="yes" xml:space="preserve">
          <source>Load various IO modules</source>
          <target state="translated">加载各种IO模块</target>
        </trans-unit>
        <trans-unit id="59ee7110b16f2ee9279e975045a71b3b2753da6e" translate="yes" xml:space="preserve">
          <source>LoadFile</source>
          <target state="translated">LoadFile</target>
        </trans-unit>
        <trans-unit id="478aa4ede7f109d8fe9ce74fc47e542819bd58d3" translate="yes" xml:space="preserve">
          <source>Loads Perl library from &lt;code&gt;$exedir/../dll/lib/&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;$exedir/../dll/lib/&lt;/code&gt; 加载Perl库。</target>
        </trans-unit>
        <trans-unit id="3c5210c4cd9f4652e7e267673947f320fe973e2f" translate="yes" xml:space="preserve">
          <source>Loads a specified module and imports the default functions to the specified package.</source>
          <target state="translated">加载指定的模块,并将默认函数导入到指定的包中。</target>
        </trans-unit>
        <trans-unit id="27e6bb733433394f480bba5733da627a3f3f2045" translate="yes" xml:space="preserve">
          <source>Loads a specified module and imports the default functions.</source>
          <target state="translated">加载指定模块并导入默认函数。</target>
        </trans-unit>
        <trans-unit id="0912e26f46f2862f9bc8f741f795bbefe5ccdd67" translate="yes" xml:space="preserve">
          <source>Loads a specified module to the specified package.</source>
          <target state="translated">将指定的模块加载到指定的包中。</target>
        </trans-unit>
        <trans-unit id="6ec299bdf7d010c1eee08526d7bd0161603d96f6" translate="yes" xml:space="preserve">
          <source>Loads a specified module.</source>
          <target state="translated">加载指定的模块。</target>
        </trans-unit>
        <trans-unit id="4a312f5b131e98b974541ced8733bc202310a2a5" translate="yes" xml:space="preserve">
          <source>Loads the handler classes defined in &lt;a href=&quot;#config&quot;&gt;config&lt;/a&gt;. For example, given a config:</source>
          <target state="translated">加载&lt;a href=&quot;#config&quot;&gt;config中&lt;/a&gt;定义的处理程序类。例如，给定一个配置：</target>
        </trans-unit>
        <trans-unit id="ec6dda1ab28094112405a17ad65b1a4c1c089d63" translate="yes" xml:space="preserve">
          <source>Loads the module whose name is pointed to by the string part of name. Note that the actual module name, not its filename, should be given. Eg, &quot;Foo::Bar&quot; instead of &quot;Foo/Bar.pm&quot;. flags can be any of PERL_LOADMOD_DENY, PERL_LOADMOD_NOIMPORT, or PERL_LOADMOD_IMPORT_OPS (or 0 for no flags). ver, if specified and not NULL, provides version semantics similar to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Foo::Bar VERSION&lt;/code&gt; . The optional trailing SV* arguments can be used to specify arguments to the module's import() method, similar to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Foo::Bar VERSION LIST&lt;/code&gt; . They must be terminated with a final NULL pointer. Note that this list can only be omitted when the PERL_LOADMOD_NOIMPORT flag has been used. Otherwise at least a single NULL pointer to designate the default import list is required.</source>
          <target state="translated">加载名称由名称的字符串部分指向的模块。请注意，应提供实际的模块名称，而不是其文件名。例如，&amp;ldquo; Foo :: Bar&amp;rdquo;而不是&amp;ldquo; Foo / Bar.pm&amp;rdquo;。标志可以是PERL_LOADMOD_DENY，PERL_LOADMOD_NOIMPORT或PERL_LOADMOD_IMPORT_OPS中的任何一个（如果没有标志，则为0）。 ver，如果指定且不为NULL，则提供类似于 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Foo::Bar VERSION&lt;/code&gt; 版本语义。可选的尾随SV *参数可用于指定模块的import（）方法的参数，类似于 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Foo::Bar VERSION LIST&lt;/code&gt; 。它们必须以最终的NULL指针终止。请注意，仅当使用PERL_LOADMOD_NOIMPORT标志时，才能省略此列表。否则，至少需要一个NULL指针来指定默认的导入列表。</target>
        </trans-unit>
        <trans-unit id="9af5b63a9cb9853b15da20ea4f2739623dc82021" translate="yes" xml:space="preserve">
          <source>Loc.U</source>
          <target state="translated">Loc.U</target>
        </trans-unit>
        <trans-unit id="2c161b9d2652a245b17c473e85af35d98c964e27" translate="yes" xml:space="preserve">
          <source>Loc_ar.U</source>
          <target state="translated">Loc_ar.U</target>
        </trans-unit>
        <trans-unit id="40cd835b717a79093cb71f794169679d3511a012" translate="yes" xml:space="preserve">
          <source>Loc_sed.U</source>
          <target state="translated">Loc_sed.U</target>
        </trans-unit>
        <trans-unit id="b62225661a9783f7a6a2c6e6f754c699e4dfbc8e" translate="yes" xml:space="preserve">
          <source>Local Locales</source>
          <target state="translated">本地化</target>
        </trans-unit>
        <trans-unit id="00b7d8ac28ed6d0a7686172cc54cac83dde1640a" translate="yes" xml:space="preserve">
          <source>Local configuration data for libnet</source>
          <target state="translated">libnet的本地配置数据</target>
        </trans-unit>
        <trans-unit id="2073176912b2b8b08756b78673e90f32f9412f5a" translate="yes" xml:space="preserve">
          <source>Local hosts should normally respond to pings within milliseconds. However, on a very congested network it may take up to 3 seconds or longer to receive an echo packet from the remote host. If the timeout is set too low under these conditions, it will appear that the remote host is not reachable (which is almost the truth).</source>
          <target state="translated">本地主机通常应在几毫秒内响应ping。然而,在一个非常拥挤的网络上,可能需要3秒或更长时间才能收到来自远程主机的回波包。如果在这些条件下超时时间设置得太低,就会出现远程主机无法到达的情况(这几乎是事实)。</target>
        </trans-unit>
        <trans-unit id="29d6a411ea768d6e339737cbc631007347c4656b" translate="yes" xml:space="preserve">
          <source>Locale is not completely independent. The</source>
          <target state="translated">Locale不是完全独立的。该</target>
        </trans-unit>
        <trans-unit id="944d1183f1e4f233c0975643c2ef4f71a04349e2" translate="yes" xml:space="preserve">
          <source>Locale-related functions and macros</source>
          <target state="translated">本地相关功能和宏</target>
        </trans-unit>
        <trans-unit id="1f8d3cc6a62e48187b6914a4e521248e770e765b" translate="yes" xml:space="preserve">
          <source>Locale::Country</source>
          <target state="translated">Locale::Country</target>
        </trans-unit>
        <trans-unit id="711ea7f4d30a8250ee3539542d2d19015e5ecdec" translate="yes" xml:space="preserve">
          <source>Locale::Country - standard codes for country identification</source>
          <target state="translated">Locale::Country ----国家识别的标准代码。</target>
        </trans-unit>
        <trans-unit id="745a3f2e63c8527b20fd7a0effbd2a4f6ce52b10" translate="yes" xml:space="preserve">
          <source>Locale::Currency</source>
          <target state="translated">Locale::Currency</target>
        </trans-unit>
        <trans-unit id="c9d7708330810bdeae6d8e6f009ab34981fb3578" translate="yes" xml:space="preserve">
          <source>Locale::Currency - standard codes for currency identification</source>
          <target state="translated">Locale::Currency-用于货币识别的标准代码。</target>
        </trans-unit>
        <trans-unit id="a2f93f9cc8bf81f232cf25c9d6170a176bd3c8f2" translate="yes" xml:space="preserve">
          <source>Locale::Language</source>
          <target state="translated">Locale::Language</target>
        </trans-unit>
        <trans-unit id="cbd3f9670295ab004a97a8799e46f114e838f7c9" translate="yes" xml:space="preserve">
          <source>Locale::Language - standard codes for language identification</source>
          <target state="translated">Locale::Language-语言识别的标准代码。</target>
        </trans-unit>
        <trans-unit id="a9d8403dd9e14d9c4a74e42c449f4f4083d77a9b" translate="yes" xml:space="preserve">
          <source>Locale::Maketext</source>
          <target state="translated">Locale::Maketext</target>
        </trans-unit>
        <trans-unit id="58f6640492c0aec7031aee510f4ce0bcac4b2a22" translate="yes" xml:space="preserve">
          <source>Locale::Maketext - framework for localization</source>
          <target state="translated">Locale::Maketext-本地化框架。</target>
        </trans-unit>
        <trans-unit id="4ffc03bfc5c484b62d9372e1420bdf253f5b3f52" translate="yes" xml:space="preserve">
          <source>Locale::Maketext offers a variety of methods, which fall into three categories:</source>
          <target state="translated">Locale::Maketext提供了多种方法,分为三类。</target>
        </trans-unit>
        <trans-unit id="a5723d6c0c42ee05086667e38fd4249fe7082e8c" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::Guts</source>
          <target state="translated">Locale::Maketext::Guts</target>
        </trans-unit>
        <trans-unit id="63bea57dac9566b0aa40481ae087dc206e13e8ee" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::Guts - Deprecated module to load Locale::Maketext utf8 code</source>
          <target state="translated">Locale::Maketext::Guts-用于加载Locale::Maketext utf8代码的废弃模块。</target>
        </trans-unit>
        <trans-unit id="b14392dcdae7ce47ee917b41b3e73f1a3b72f5e1" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::GutsLoader</source>
          <target state="translated">Locale::Maketext::GutsLoader</target>
        </trans-unit>
        <trans-unit id="9810a1053985ebcf2f9b5544107826a653c00a65" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::GutsLoader - Deprecated module to load Locale::Maketext utf8 code</source>
          <target state="translated">Locale::Maketext::GutsLoader-用于加载Locale::Maketext utf8代码的废弃模块。</target>
        </trans-unit>
        <trans-unit id="a239b132192c48779d9a0ee403ad81c93ab75902" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::Simple</source>
          <target state="translated">Locale::Maketext::Simple</target>
        </trans-unit>
        <trans-unit id="a942c8cd15bd2125fe42db2a486e9feebf1cfa35" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::Simple - Simple interface to Locale::Maketext::Lexicon</source>
          <target state="translated">Locale::Maketext::Simple-Locale::Maketext::Lexicon的简单接口。</target>
        </trans-unit>
        <trans-unit id="1ee43c469c3726bd84652212d4ca88cc335a5967" translate="yes" xml:space="preserve">
          <source>Locale::Script</source>
          <target state="translated">Locale::Script</target>
        </trans-unit>
        <trans-unit id="8f438e3df7fafcc383b453fd3213f4653605e9c0" translate="yes" xml:space="preserve">
          <source>Locale::Script - standard codes for script identification</source>
          <target state="translated">Locale::Script-脚本识别的标准代码。</target>
        </trans-unit>
        <trans-unit id="a222060e32289bf6910ac4a07a10733be500bd99" translate="yes" xml:space="preserve">
          <source>Locales</source>
          <target state="translated">Locales</target>
        </trans-unit>
        <trans-unit id="f8764300ec3ae038b44ac23ce898f50ceb30676b" translate="yes" xml:space="preserve">
          <source>Locales are supported. There may be glitches when a locale is another EBCDIC code page which has some of the &lt;a href=&quot;#The-13-variant-characters&quot;&gt;code-page variant characters&lt;/a&gt; in other positions.</source>
          <target state="translated">支持语言环境。当语言环境是另一个EBCDIC代码页时，可能会出现故障，该&lt;a href=&quot;#The-13-variant-characters&quot;&gt;代码页&lt;/a&gt;在其他位置具有某些代码页变体字符。</target>
        </trans-unit>
        <trans-unit id="32f83a14354ab144fa1eeefe381bdddf7ef6a4b6" translate="yes" xml:space="preserve">
          <source>Localization of elements of composite types</source>
          <target state="translated">复合类型元素的本地化</target>
        </trans-unit>
        <trans-unit id="87574e6a695fdc9051fd38476db62bcaa8e7cafd" translate="yes" xml:space="preserve">
          <source>Localization of globs</source>
          <target state="translated">球体的定位</target>
        </trans-unit>
        <trans-unit id="f2f69b5bf206324f99fe659a46e5c54c241d441a" translate="yes" xml:space="preserve">
          <source>Localization of special variables</source>
          <target state="translated">特殊变量的本地化</target>
        </trans-unit>
        <trans-unit id="56adc662b2ff25957a5294f0112a3c7b0d263e47" translate="yes" xml:space="preserve">
          <source>Localized deletion of elements of composite types</source>
          <target state="translated">复合类型元素的局部删除</target>
        </trans-unit>
        <trans-unit id="e60da19033e636198e96d7e490201c9c1369d134" translate="yes" xml:space="preserve">
          <source>Localizing &lt;code&gt;$.&lt;/code&gt; will not localize the filehandle's line count</source>
          <target state="translated">本地化 &lt;code&gt;$.&lt;/code&gt; 不会本地化文件句柄的行数</target>
        </trans-unit>
        <trans-unit id="8364e7e87819604234599a1511218996199f997e" translate="yes" xml:space="preserve">
          <source>Localizing changes</source>
          <target state="translated">变化本地化</target>
        </trans-unit>
        <trans-unit id="f408eed5847840b83469388030b3326ba3bf4885" translate="yes" xml:space="preserve">
          <source>Localizing tied arrays or hashes does not work. After exiting the scope the arrays or the hashes are not restored.</source>
          <target state="translated">本地化绑定的数组或散列不起作用。退出作用域后,数组或哈希值不能恢复。</target>
        </trans-unit>
        <trans-unit id="00e0ebc3f4b2567f4695fa9503d51f87733e190d" translate="yes" xml:space="preserve">
          <source>Locate directory of original perl script</source>
          <target state="translated">找到原始perl脚本的目录</target>
        </trans-unit>
        <trans-unit id="cffe84cd97aaf675f786b03919bbd1aad3c3fe1d" translate="yes" xml:space="preserve">
          <source>Locate the CV corresponding to the currently executing sub or eval. If db_seqp is non_null, skip CVs that are in the DB package and populate *db_seqp with the cop sequence number at the point that the DB:: code was entered. (This allows debuggers to eval in the scope of the breakpoint rather than in the scope of the debugger itself.)</source>
          <target state="translated">找到当前执行的子或eval对应的CV。如果db_seqp为non_null,则跳过DB包中的CV,用输入DB::代码时的cop序列号填充*db_seqp。(这使得调试器可以在断点的范围内而不是在调试器本身的范围内进行评价。)</target>
        </trans-unit>
        <trans-unit id="f5cb0ec5fe28860a73ac5e9c7f201c2864475a69" translate="yes" xml:space="preserve">
          <source>Locates the full path to the script bin directory to allow the use of paths relative to the bin directory.</source>
          <target state="translated">定位脚本bin目录的完整路径,允许使用相对bin目录的路径。</target>
        </trans-unit>
        <trans-unit id="90f656c2cec82492063f2f19f63b0344475a8752" translate="yes" xml:space="preserve">
          <source>Location of Perl</source>
          <target state="translated">Perl的位置</target>
        </trans-unit>
        <trans-unit id="e526b099baebb5894aa471d61a7294aea38b4fdb" translate="yes" xml:space="preserve">
          <source>Lock the database with fd &amp;amp; flock.</source>
          <target state="translated">用fd和flock锁定数据库。</target>
        </trans-unit>
        <trans-unit id="877d08a97c129fe96b732f20ebe8f52e02d93eca" translate="yes" xml:space="preserve">
          <source>Locking and error checking are left as an exercise for the reader. Don't forget them or you'll be quite sorry.</source>
          <target state="translated">锁定和错误检查是留给读者的练习。不要忘记它们,否则你会相当后悔。</target>
        </trans-unit>
        <trans-unit id="66cac3a963a1045fd348fae956e2fc8becb2159a" translate="yes" xml:space="preserve">
          <source>Locking: The Trouble with fd</source>
          <target state="translated">锁定。fd的问题</target>
        </trans-unit>
        <trans-unit id="a0ee9e59f4952196e4f063486823a5e6655ed2ab" translate="yes" xml:space="preserve">
          <source>Locks and unlocks the value for an individual key of a hash. The value of a locked key cannot be changed.</source>
          <target state="translated">锁定和解锁一个哈希值的单个密钥。锁定的密钥的值不能改变。</target>
        </trans-unit>
        <trans-unit id="409c237554d2d89fa246a166165492e5479e6006" translate="yes" xml:space="preserve">
          <source>Locks are a handy tool to synchronize access to data, and using them properly is the key to safe shared data. Unfortunately, locks aren't without their dangers, especially when multiple locks are involved. Consider the following code:</source>
          <target state="translated">锁是同步访问数据的方便工具,正确使用锁是安全共享数据的关键。不幸的是,锁不是没有危险的,特别是涉及到多个锁的时候。考虑以下代码。</target>
        </trans-unit>
        <trans-unit id="d77ca7a462f2ee37cd5eeb13d2720840dd8f730e" translate="yes" xml:space="preserve">
          <source>Locks are recursive, which means it's okay for a thread to lock a variable more than once. The lock will last until the outermost &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; on the variable goes out of scope. For example:</source>
          <target state="translated">锁是递归的，这意味着线程可以多次锁定变量是可以的。锁定将一直持续到变量的最外面的 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 超出范围。例如：</target>
        </trans-unit>
        <trans-unit id="fc0486b135937b6c03b868507a94d272ff8ac6f4" translate="yes" xml:space="preserve">
          <source>Locks on variables only affect &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; calls--they do</source>
          <target state="translated">变量上的锁仅影响 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 调用-它们会</target>
        </trans-unit>
        <trans-unit id="2494e49f95e86d62c9e1df9443b971b1071d1eb2" translate="yes" xml:space="preserve">
          <source>Log all messages up to debug:</source>
          <target state="translated">将所有的信息记录下来,进行调试。</target>
        </trans-unit>
        <trans-unit id="ac20548f5a2664c1934f84717b314a50501d6ebb" translate="yes" xml:space="preserve">
          <source>Log an error that can't be ignored.</source>
          <target state="translated">记录一个不能忽略的错误。</target>
        </trans-unit>
        <trans-unit id="9f24d2b09c179c98a526a557d74f3d2be5514fb4" translate="yes" xml:space="preserve">
          <source>Log an error unless &lt;code&gt;$parser-&amp;gt;no_whining( TRUE );&lt;/code&gt; .</source>
          <target state="translated">记录错误，除非 &lt;code&gt;$parser-&amp;gt;no_whining( TRUE );&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="598cba7875d82844d0ea4fd50137d27e20e9822b" translate="yes" xml:space="preserve">
          <source>Log critical messages, errors and warnings:</source>
          <target state="translated">记录关键信息、错误和警告。</target>
        </trans-unit>
        <trans-unit id="2a127fbcd6604ca1cf80302b78e02d5ba87eed29" translate="yes" xml:space="preserve">
          <source>Log everything except informational messages:</source>
          <target state="translated">记录除信息信息以外的所有信息。</target>
        </trans-unit>
        <trans-unit id="346e7edbc99f3e01ce84957ff3c99842429de19b" translate="yes" xml:space="preserve">
          <source>Log into the remote FTP server with the given login information. If no arguments are given then the &lt;code&gt;Net::FTP&lt;/code&gt; uses the &lt;code&gt;Net::Netrc&lt;/code&gt; package to lookup the login information for the connected host. If no information is found then a login of</source>
          <target state="translated">使用给定的登录信息登录到远程FTP服务器。如果未提供任何参数，则 &lt;code&gt;Net::FTP&lt;/code&gt; 使用 &lt;code&gt;Net::Netrc&lt;/code&gt; 包查找所连接主机的登录信息。如果找不到信息，则登录</target>
        </trans-unit>
        <trans-unit id="38711dd5aba31d74455f59112be713add52892b6" translate="yes" xml:space="preserve">
          <source>Log to UDP port on &lt;code&gt;$remotehost&lt;/code&gt; instead of logging locally:</source>
          <target state="translated">登录到 &lt;code&gt;$remotehost&lt;/code&gt; 上的UDP端口，而不是本地登录：</target>
        </trans-unit>
        <trans-unit id="ef88b916547cdcd540b35fe969c4a4a3e3015dad" translate="yes" xml:space="preserve">
          <source>Logarithm base two [C99].</source>
          <target state="translated">对数基数二[C99].</target>
        </trans-unit>
        <trans-unit id="126a3068c345063640bada367b1b3170b97166a9" translate="yes" xml:space="preserve">
          <source>Logging if DEBUG (constant)</source>
          <target state="translated">如果DEBUG(常数),则进行日志记录</target>
        </trans-unit>
        <trans-unit id="786908e4097f50192db248aa36b5528e31277867" translate="yes" xml:space="preserve">
          <source>Logical And</source>
          <target state="translated">逻辑和</target>
        </trans-unit>
        <trans-unit id="4f0fe5e6156db1c8f396f9ada6968d19b442623d" translate="yes" xml:space="preserve">
          <source>Logical Defined-Or</source>
          <target state="translated">逻辑定义或</target>
        </trans-unit>
        <trans-unit id="27999dc9087d157951951d7c5ab5c57a64718d42" translate="yes" xml:space="preserve">
          <source>Logical Not</source>
          <target state="translated">逻辑性不强</target>
        </trans-unit>
        <trans-unit id="c27af685856a54b17004644154867c40474db6e5" translate="yes" xml:space="preserve">
          <source>Logical or and Exclusive Or</source>
          <target state="translated">逻辑或和独家或</target>
        </trans-unit>
        <trans-unit id="eaac42db96179506f42bd718fb8ac139cdc3650b" translate="yes" xml:space="preserve">
          <source>Logical paths specified by system variables containing comma-separated search lists are also allowed; hence &lt;code&gt;System:Modules&lt;/code&gt; is a valid filename, and the filesystem will prefix &lt;code&gt;Modules&lt;/code&gt; with each section of &lt;code&gt;System$Path&lt;/code&gt; until a name is made that points to an object on disk. Writing to a new file &lt;code&gt;System:Modules&lt;/code&gt; would be allowed only if &lt;code&gt;System$Path&lt;/code&gt; contains a single item list. The filesystem will also expand system variables in filenames if enclosed in angle brackets, so &lt;code&gt;&amp;lt;System$Dir&amp;gt;.Modules&lt;/code&gt; would look for the file &lt;code&gt;$ENV{'System$Dir'} . 'Modules'&lt;/code&gt; . The obvious implication of this is that &lt;b&gt;fully qualified filenames can start with &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; &lt;/b&gt; and should be protected when &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is used for input.</source>
          <target state="translated">也允许由包含逗号分隔的搜索列表的系统变量指定的逻辑路径；因此， &lt;code&gt;System:Modules&lt;/code&gt; 是有效的文件名，并且文件系统将在 &lt;code&gt;System$Path&lt;/code&gt; 每个部分之前为 &lt;code&gt;Modules&lt;/code&gt; 加上前缀，直到建立一个指向磁盘上对象的名称为止。仅当 &lt;code&gt;System$Path&lt;/code&gt; 包含单个项目列表时，才允许写入新文件 &lt;code&gt;System:Modules&lt;/code&gt; 。如果用尖括号括起来，文件系统还将在文件名中扩展系统变量，因此 &lt;code&gt;&amp;lt;System$Dir&amp;gt;.Modules&lt;/code&gt; 将查找文件 &lt;code&gt;$ENV{'System$Dir'} . 'Modules'&lt;/code&gt; 。明显的含义是&lt;b&gt;完全限定的文件名可以以&lt;/b&gt;&lt;b&gt; &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; &lt;/b&gt;&lt;b&gt;开头&lt;/b&gt;&lt;b&gt; &lt;/b&gt;并且在将 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 用于输入时应加以保护。</target>
        </trans-unit>
        <trans-unit id="79852f7a308fa757ef46ef50b492fb84497039eb" translate="yes" xml:space="preserve">
          <source>Logically joins the arguments into a single string, and returns its SHA-1/224/256/384/512 digest encoded as a Base64 string.</source>
          <target state="translated">将参数逻辑地连接成一个单一的字符串,并将其SHA-1/224/256/384/512摘要编码为Base64字符串返回。</target>
        </trans-unit>
        <trans-unit id="efb5f37aee3b9a117751bc32852449eef4e74e78" translate="yes" xml:space="preserve">
          <source>Logically joins the arguments into a single string, and returns its SHA-1/224/256/384/512 digest encoded as a binary string.</source>
          <target state="translated">将参数逻辑地连接成一个单一的字符串,并返回其SHA-1/224/256/384/512编码为二进制字符串的摘要。</target>
        </trans-unit>
        <trans-unit id="a5c5c8e8c0f54246b1b313dd050b036a30efb0a2" translate="yes" xml:space="preserve">
          <source>Logically joins the arguments into a single string, and returns its SHA-1/224/256/384/512 digest encoded as a hexadecimal string.</source>
          <target state="translated">将参数逻辑地连接成一个单一的字符串,并返回其SHA-1/224/256/384/512编码的十六进制字符串。</target>
        </trans-unit>
        <trans-unit id="04b474494be5436c1b0b4486d175dd6df25d94bc" translate="yes" xml:space="preserve">
          <source>Logically joins the arguments into a single string, and uses it to update the current digest state. In other words, the following statements have the same effect:</source>
          <target state="translated">在逻辑上将参数连接成一个单一的字符串,并使用它来更新当前的摘要状态。换句话说,下面的语句具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="aaef8ae01439927f0a6ee227f2d792c666fabc4e" translate="yes" xml:space="preserve">
          <source>Login name of the person who ran the Configure script and answered the questions. This is used to tag both</source>
          <target state="translated">运行配置脚本并回答问题的人的登录名。这将用于标记两个</target>
        </trans-unit>
        <trans-unit id="30c490b4b408ece1deda10e7b62b5b4cba9be12b" translate="yes" xml:space="preserve">
          <source>Logs will go on as long as they have to.</source>
          <target state="translated">日志只要有必要,就会继续下去。</target>
        </trans-unit>
        <trans-unit id="463552e32614f1099d813cd725ccdec3ad1aa628" translate="yes" xml:space="preserve">
          <source>Long Doubles on Tru64</source>
          <target state="translated">Tru64上的长双打</target>
        </trans-unit>
        <trans-unit id="943010215619f82aa64612ba50a6ccaed4ede293" translate="yes" xml:space="preserve">
          <source>Long Doubles.</source>
          <target state="translated">长双打。</target>
        </trans-unit>
        <trans-unit id="4d248c964e944a2e6c6cbd3e67c194423372f025" translate="yes" xml:space="preserve">
          <source>Long doubles</source>
          <target state="translated">长双打</target>
        </trans-unit>
        <trans-unit id="a209ad07aac520c10047b0552ae5c1c4441aaadc" translate="yes" xml:space="preserve">
          <source>Long integers. This is equivalent to T_IV but explicitly casts the return to type &lt;code&gt;long&lt;/code&gt; . The default typemap for &lt;code&gt;long&lt;/code&gt; is T_IV.</source>
          <target state="translated">长整数。这等效于T_IV，但显式将返回值强制转换为 &lt;code&gt;long&lt;/code&gt; 类型。 &lt;code&gt;long&lt;/code&gt; 的默认类型映射为T_IV。</target>
        </trans-unit>
        <trans-unit id="210129fcaec84064f201e7b1b9a66e1a7acd7738" translate="yes" xml:space="preserve">
          <source>Long lines broken after an operator (except &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; ).</source>
          <target state="translated">运算符后的长行（ &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;or&lt;/code&gt; 除外）。</target>
        </trans-unit>
        <trans-unit id="106ccce59a41316ca39a9a555b12f40ffd8ebb31" translate="yes" xml:space="preserve">
          <source>Long plaguing users of MakeMaker based modules has been the problem of getting basic information about the module out of the sources</source>
          <target state="translated">长期以来,困扰基于MakeMaker的模块用户的是如何从源头获取模块的基本信息的问题</target>
        </trans-unit>
        <trans-unit id="d680241590e9a19c54d2635978661f5bb8739734" translate="yes" xml:space="preserve">
          <source>Long regexps like this may impress your friends, but can be hard to decipher. In complex situations like this, the &lt;code&gt;//x&lt;/code&gt; modifier for a match is invaluable. It allows one to put nearly arbitrary whitespace and comments into a regexp without affecting their meaning. Using it, we can rewrite our 'extended' regexp in the more pleasing form</source>
          <target state="translated">像这样的长正则表达式可能会给您的朋友留下深刻的印象，但可能很难破译。在像这样的复杂情况下，匹配的 &lt;code&gt;//x&lt;/code&gt; 修饰符是无价的。它允许将几乎任意的空格和注释放入正则表达式中，而不会影响其含义。使用它，我们可以用更令人满意的形式重写&amp;ldquo;扩展&amp;rdquo;正则表达式</target>
        </trans-unit>
        <trans-unit id="4f9e2648c307f1adbbaa0fd205252907f8be6f2a" translate="yes" xml:space="preserve">
          <source>Long sequences of elsifs will turn into nested ternary operators, which B::Deparse doesn't know how to indent nicely.</source>
          <target state="translated">长长的 elsifs 序列会变成嵌套的三元运算符,而 B::Deparse 不知道如何很好地缩进。</target>
        </trans-unit>
        <trans-unit id="cf4ff04cfe182e8bc5dadb069506e27cabf50333" translate="yes" xml:space="preserve">
          <source>Look - search for key in dictionary file</source>
          <target state="translated">查找--在字典文件中搜索关键词</target>
        </trans-unit>
        <trans-unit id="2505a112819d0c19797962a0a34b656ddfcb7762" translate="yes" xml:space="preserve">
          <source>Look at &lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt; to find out. If you are not using the latest released version, please try to replicate your bug on the latest stable release.</source>
          <target state="translated">查看&lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt;进行查找。如果您使用的不是最新发布的版本，请尝试在最新的稳定版本上复制您的错误。</target>
        </trans-unit>
        <trans-unit id="1788237e2a2e0b7dbd5185705c7d994a905e8de0" translate="yes" xml:space="preserve">
          <source>Look for a POD document named &lt;code&gt;$name&lt;/code&gt; in the cache. Returns the reference to the corresponding Pod::Cache::Item object or undef if not found.</source>
          <target state="translated">在缓存中查找名为 &lt;code&gt;$name&lt;/code&gt; 的POD文档。返回对相应Pod :: Cache :: Item对象的引用；如果未找到，则返回undef。</target>
        </trans-unit>
        <trans-unit id="fbd0681ce0f07813305ee76bbda2b9bf4d9e94bf" translate="yes" xml:space="preserve">
          <source>Look for a node or index entry named &lt;code&gt;$name&lt;/code&gt; in the object. Returns the unique id of the node (i.e. the second element of the array stored in the node array) or undef if not found.</source>
          <target state="translated">在对象中查找名为 &lt;code&gt;$name&lt;/code&gt; 的节点或索引条目。返回节点的唯一ID（即，存储在节点数组中的数组的第二个元素）或undef（如果找不到）。</target>
        </trans-unit>
        <trans-unit id="123c1cf1f88ba14e6964d416656f6e7d8fd3e930" translate="yes" xml:space="preserve">
          <source>Look in &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s SEE ALSO for more testing modules.</source>
          <target state="translated">在&lt;a href=&quot;more&quot;&gt;Test :: More中&lt;/a&gt;查找更多的测试模块。</target>
        </trans-unit>
        <trans-unit id="0f1649ed1326706b3a529a44e1b35a34e5184e5a" translate="yes" xml:space="preserve">
          <source>Look up Perl documentation in Pod format.</source>
          <target state="translated">以Pod格式查找Perl文档。</target>
        </trans-unit>
        <trans-unit id="c69ec9ef84491acf135ee455e26c4726d6d3736b" translate="yes" xml:space="preserve">
          <source>Look up the entry in the cop hints hash</source>
          <target state="translated">查一下警察提示中的条目。</target>
        </trans-unit>
        <trans-unit id="67f3f361744fabd99e65f601642d504f07f990e2" translate="yes" xml:space="preserve">
          <source>Look up the hint entry in the cop</source>
          <target state="translated">查一下警察中的提示条目</target>
        </trans-unit>
        <trans-unit id="f10edb39dcb279e59fbd91c8271e8ebb8f360ce1" translate="yes" xml:space="preserve">
          <source>Look-around assertions are zero-width patterns which match a specific pattern without including it in &lt;code&gt;$&amp;amp;&lt;/code&gt; . Positive assertions match when their subpattern matches, negative assertions match when their subpattern fails. Look-behind matches text up to the current match position, look-ahead matches text following the current match position.</source>
          <target state="translated">环视断言是零宽度模式，该模式与特定模式匹配，但不包含在 &lt;code&gt;$&amp;amp;&lt;/code&gt; 中。正断言在子模式匹配时匹配，负断言在子模式失败时匹配。&amp;ldquo;后向匹配&amp;rdquo;匹配直到当前匹配位置的文本，&amp;ldquo;前瞻&amp;rdquo;匹配当前匹配位置之后的文本。</target>
        </trans-unit>
        <trans-unit id="724a065c84668bb1516bf7e41f33f4d7062d0ec4" translate="yes" xml:space="preserve">
          <source>Looking ahead and looking behind</source>
          <target state="translated">瞻前顾后</target>
        </trans-unit>
        <trans-unit id="ddd7aa41b84e676f5291b91d7146d3d34c4b037d" translate="yes" xml:space="preserve">
          <source>Looking at data and -w and v</source>
          <target state="translated">看数据和-w和v</target>
        </trans-unit>
        <trans-unit id="afd51bda07c9e5b3e347f595bec67763e831628e" translate="yes" xml:space="preserve">
          <source>Looking at it another way, writing portable code is usually about willfully limiting your available choices. Naturally, it takes discipline and sacrifice to do that. The product of portability and convenience may be a constant. You have been warned.</source>
          <target state="translated">从另一个角度来看,编写可移植的代码通常是故意限制你的可用选择。自然,要做到这一点需要纪律和牺牲。可移植性和便利性的产物可能是一个常态。你已经被警告过了。</target>
        </trans-unit>
        <trans-unit id="e8e461609613edac0a408d3ea9b1090c941ca168" translate="yes" xml:space="preserve">
          <source>Looking at your</source>
          <target state="translated">看着你的</target>
        </trans-unit>
        <trans-unit id="b9aa086b4410a1e5dda5b6bd9fecaa602b967f8c" translate="yes" xml:space="preserve">
          <source>Looking in to &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; and modern Perl web frameworks is highly recommended, though; web programming in Perl has evolved a long way from the old days of simple CGI scripts.</source>
          <target state="translated">展望到&lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;普拉克&lt;/a&gt;和现代的Perl Web框架强烈建议，虽然，Perl中的Web编程已从简单的CGI脚本的过去发展了很长的路要走。</target>
        </trans-unit>
        <trans-unit id="24076d6129adc62ded56328acb2536c0df4e3f06" translate="yes" xml:space="preserve">
          <source>Looking up every message is not the easiest way, so let perl to do it for you. Use the diagnostics pragma with turns perl's normal messages into longer discussions on the topic.</source>
          <target state="translated">查阅每一条消息并不是最简单的方法,所以让perl来帮你做。使用 diagnostics pragma 可以将 perl 的普通消息变成更长的主题讨论。</target>
        </trans-unit>
        <trans-unit id="0cda5c2d87b5464569d98d6b83dc0ced023afb49" translate="yes" xml:space="preserve">
          <source>Looking up module information / loading at runtime</source>
          <target state="translated">查询模块信息/在运行时加载</target>
        </trans-unit>
        <trans-unit id="747df9a5145420389182a3a0e2f8fb4f1afad4e4" translate="yes" xml:space="preserve">
          <source>Looks OK, after it's been through the syntax check (perl -c scriptname), we run it and all we get is a blank line again! Hmmmm.</source>
          <target state="translated">看起来没问题,在通过语法检查(perl -c scriptname)后,我们运行它,得到的又是一行空白。嗯。</target>
        </trans-unit>
        <trans-unit id="9e1ff3f5f8cd27194462e5af7c79ade692faba9a" translate="yes" xml:space="preserve">
          <source>Looks ahead one (Unicode) character in the text currently being lexed. Returns the codepoint (unsigned integer value) of the next character, or -1 if lexing has reached the end of the input text. To consume the peeked character, use &lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;.</source>
          <target state="translated">在当前被词法化的文本中向前看一个（Unicode）字符。返回下一个字符的代码点（无符号整数值）；如果词法到达输入文本的末尾，则返回-1。要使用偷看的字符，请使用&lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56a09e0b7dcffea4a7ed21e9b73140689a5030bc" translate="yes" xml:space="preserve">
          <source>Looks for MakeMaker-like</source>
          <target state="translated">寻找类似MakeMaker的产品</target>
        </trans-unit>
        <trans-unit id="f560b4b8c550fee26628fb62462e2a0f00ebfb7f" translate="yes" xml:space="preserve">
          <source>Looks for Perl DLL in the directory &lt;code&gt;$exedir/../dll&lt;/code&gt;;</source>
          <target state="translated">在 &lt;code&gt;$exedir/../dll&lt;/code&gt; 目录中寻找Perl DLL ；</target>
        </trans-unit>
        <trans-unit id="0e20c33c03f2909dd222479a34a94e62a5aa2710" translate="yes" xml:space="preserve">
          <source>Looks good, let's just continue off the end of the script:</source>
          <target state="translated">看起来不错,让我们继续从剧本的结尾开始。</target>
        </trans-unit>
        <trans-unit id="27da418dc7160824d1f1cea0c0a27285c46f89f4" translate="yes" xml:space="preserve">
          <source>Looks like this:</source>
          <target state="translated">看起来像这样。</target>
        </trans-unit>
        <trans-unit id="150d86722bc6a43c75ceadbe33863f7ae1a8f8cf" translate="yes" xml:space="preserve">
          <source>Looks up the type of the lexical variable at position</source>
          <target state="translated">查询位置上的词性变量的类型。</target>
        </trans-unit>
        <trans-unit id="7dba7dbb2ccc77afc11256e6171420abb3f68326" translate="yes" xml:space="preserve">
          <source>Lookup and return a reference to the entry for &lt;code&gt;MACHINE&lt;/code&gt; . If &lt;code&gt;LOGIN&lt;/code&gt; is given then the entry returned will have the given login. If &lt;code&gt;LOGIN&lt;/code&gt; is not given then the first entry in the .netrc file for &lt;code&gt;MACHINE&lt;/code&gt; will be returned.</source>
          <target state="translated">查找并返回对 &lt;code&gt;MACHINE&lt;/code&gt; 条目的引用。如果给出 &lt;code&gt;LOGIN&lt;/code&gt; ,则返回的条目将具有给定的登录名。如果未提供 &lt;code&gt;LOGIN&lt;/code&gt; ，则将返回.netrc文件中 &lt;code&gt;MACHINE&lt;/code&gt; 的第一个条目。</target>
        </trans-unit>
        <trans-unit id="e27af5395111fe3fb113c2e3d566816c9450bb06" translate="yes" xml:space="preserve">
          <source>Lookup for connect()</source>
          <target state="translated">查询连接()。</target>
        </trans-unit>
        <trans-unit id="cfef537fd2855cc3dbc568fc189f69bf8fa670d8" translate="yes" xml:space="preserve">
          <source>Loop Control</source>
          <target state="translated">环路控制</target>
        </trans-unit>
        <trans-unit id="4394b7785cf8e6687ab901e849d752a278fd046b" translate="yes" xml:space="preserve">
          <source>Loop control statements don't work in an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;unless&lt;/code&gt; , since they aren't loops. You can double the braces to make them such, though.</source>
          <target state="translated">循环控制语句不适用于 &lt;code&gt;if&lt;/code&gt; 或 &lt;code&gt;unless&lt;/code&gt; ，因为它们不是循环。但是，您可以将大括号加倍以使它们如此。</target>
        </trans-unit>
        <trans-unit id="ee5406a6fab87283992041afaf3d98b63358ce87" translate="yes" xml:space="preserve">
          <source>Losing Overloading</source>
          <target state="translated">损失超载</target>
        </trans-unit>
        <trans-unit id="255b929d8a79cd2d34f3195e7105f962e8ff4cfe" translate="yes" xml:space="preserve">
          <source>Loss of information</source>
          <target state="translated">信息损失</target>
        </trans-unit>
        <trans-unit id="cfc0d37079134dcffb425a52ede17bc5bc48e470" translate="yes" xml:space="preserve">
          <source>Lots of junk will go past as gdb reads in the relevant source files and libraries, and then:</source>
          <target state="translated">在gdb读取相关源文件和库的时候,很多垃圾会过去,然后。</target>
        </trans-unit>
        <trans-unit id="085dc9408c5b1c58693c372e333c4354a4cec51f" translate="yes" xml:space="preserve">
          <source>Lots of this documentation is duplicated from &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt;.</source>
          <target state="translated">本文档中的许多内容都是从&lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt;复制的。</target>
        </trans-unit>
        <trans-unit id="ab1f1ddd535328223bedffdfeaa44f30147b00a6" translate="yes" xml:space="preserve">
          <source>Lots. See</source>
          <target state="translated">很多。请看</target>
        </trans-unit>
        <trans-unit id="05699eeb34507ef8b7729483cad54f68e5da82dd" translate="yes" xml:space="preserve">
          <source>Low-Level Interface to bzip2 compression library</source>
          <target state="translated">bzip2压缩库的低级接口。</target>
        </trans-unit>
        <trans-unit id="daa6640df64c8d3fd04d48a86e9c6104202745fc" translate="yes" xml:space="preserve">
          <source>Low-Level Interface to zlib compression library</source>
          <target state="translated">zlib压缩库的低级接口</target>
        </trans-unit>
        <trans-unit id="a0c4ed2cdac85f3556324d12104692afb5867488" translate="yes" xml:space="preserve">
          <source>Low-level File Opens via sysopen</source>
          <target state="translated">通过sysopen打开低级文件</target>
        </trans-unit>
        <trans-unit id="bbbd1cb27a00deeb8c66f6ae061bb29e0862f1bd" translate="yes" xml:space="preserve">
          <source>Low-level access to Win32 system API calls for files/dirs.</source>
          <target state="translated">对Win32系统API调用文件/目录的低级访问。</target>
        </trans-unit>
        <trans-unit id="e8c85a684a62b80d06983e6e12e35335310bc09b" translate="yes" xml:space="preserve">
          <source>Low-level layer that calls &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;lseek&lt;/code&gt; , etc.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;lseek&lt;/code&gt; 等的低层。</target>
        </trans-unit>
        <trans-unit id="abf8ce4a5f4a2b06b346bb8ef9b168681a52fab2" translate="yes" xml:space="preserve">
          <source>Lowercase_Letter</source>
          <target state="translated">Lowercase_Letter</target>
        </trans-unit>
        <trans-unit id="a99d83c11e02cb19d312201ee35e6930d1ab9ee1" translate="yes" xml:space="preserve">
          <source>Lowers the reference count of the pad name list.</source>
          <target state="translated">降低垫名列表的引用次数。</target>
        </trans-unit>
        <trans-unit id="1b905a464c50eff889d1fabd4387275f0c86db4f" translate="yes" xml:space="preserve">
          <source>Lowers the reference count of the pad name.</source>
          <target state="translated">降低垫名的引用次数。</target>
        </trans-unit>
        <trans-unit id="64d41b1df2cdae534f1fdacc800338a809f214c6" translate="yes" xml:space="preserve">
          <source>Lowest level layer which provides basic PerlIO operations in terms of UNIX/POSIX numeric file descriptor calls (open(), read(), write(), lseek(), close()).</source>
          <target state="translated">最底层,以UNIX/POSIX数字文件描述符调用(open()、read()、write()、lseek()、close())的方式提供基本的PerlIO操作。</target>
        </trans-unit>
        <trans-unit id="16b73d35c25cb2d87aaa9bb21b4aedfa85686027" translate="yes" xml:space="preserve">
          <source>Luther Huffman, lutherh@stratcom.com, Strategic Computer Solutions, Inc.</source>
          <target state="translated">Luther Huffman,lutherh@stratcom.com,Strategic Computer Solutions,Inc.</target>
        </trans-unit>
        <trans-unit id="992354f36023a64134d9045affe474e73e18db31" translate="yes" xml:space="preserve">
          <source>Luvverly! and to fix this we declare all variables explicitly and now our script looks like this:</source>
          <target state="translated">Luvverly!为了解决这个问题,我们明确地声明所有变量,现在我们的脚本看起来是这样的。</target>
        </trans-unit>
        <trans-unit id="dc6aa5975bc24ec633f5fcc8f9ccf2766d7ad7e9" translate="yes" xml:space="preserve">
          <source>Lvalue casts</source>
          <target state="translated">L值投</target>
        </trans-unit>
        <trans-unit id="c819825aaf49d2c99e8f8f2add24599bfbddb1a0" translate="yes" xml:space="preserve">
          <source>Lvalue subroutines</source>
          <target state="translated">L值子程序</target>
        </trans-unit>
        <trans-unit id="a77fcba977d5eb923b72725f6d5dc4fe49dee064" translate="yes" xml:space="preserve">
          <source>Lvalue subroutines are convenient, but you have to keep in mind that, when used with objects, they may violate encapsulation. A normal mutator can check the supplied argument before setting the attribute it is protecting, an lvalue subroutine cannot. If you require any special processing when storing and retrieving the values, consider using the CPAN module Sentinel or something similar.</source>
          <target state="translated">L-value子程序很方便,但你必须记住,当与对象一起使用时,它们可能违反封装。普通的突变器可以在设置它所保护的属性之前检查所提供的参数,而lvalue子程序则不能。如果你在存储和检索值时需要任何特殊处理,可以考虑使用CPAN模块Sentinel或类似的东西。</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="15c8cbe6eb1479a64e132c9d7a73db9ce6a8aab3" translate="yes" xml:space="preserve">
          <source>MAILING LIST</source>
          <target state="translated">邮件列表</target>
        </trans-unit>
        <trans-unit id="f672ec1a25cdbb81af49b4e2e09eb665a197b037" translate="yes" xml:space="preserve">
          <source>MAIN METHODS</source>
          <target state="translated">主要方法</target>
        </trans-unit>
        <trans-unit id="7bee61cc4b2ff6ceaa5bf2c847f0465ac92786f6" translate="yes" xml:space="preserve">
          <source>MAIN SEARCH METHODS</source>
          <target state="translated">主要搜索方法</target>
        </trans-unit>
        <trans-unit id="b2bcf80339bb8c2f5b627482d7224ef03323abc9" translate="yes" xml:space="preserve">
          <source>MAINTAINER</source>
          <target state="translated">MAINTAINER</target>
        </trans-unit>
        <trans-unit id="572378cf179c50ade4591b0f42a539fe3de5c4ba" translate="yes" xml:space="preserve">
          <source>MAINTAINERS</source>
          <target state="translated">MAINTAINERS</target>
        </trans-unit>
        <trans-unit id="a573378dd124c5aff03b74a9a4dee3c0207dd14a" translate="yes" xml:space="preserve">
          <source>MAINTENANCE AND SUPPORT</source>
          <target state="translated">保养和支持</target>
        </trans-unit>
        <trans-unit id="381f8b8847a78b52a5c355f7a396ec94cdfb3fe2" translate="yes" xml:space="preserve">
          <source>MAINTENANCE BRANCHES</source>
          <target state="translated">维修分公司</target>
        </trans-unit>
        <trans-unit id="c8c08604e5e552ec9e9c63c71fc8f4ef53453d1a" translate="yes" xml:space="preserve">
          <source>MAKE ON CYGWIN</source>
          <target state="translated">制作CYGWIN</target>
        </trans-unit>
        <trans-unit id="1f0292102c8114ed4accdb4b3187dd3355fe606e" translate="yes" xml:space="preserve">
          <source>MAKE PROBLEMS.</source>
          <target state="translated">制造问题。</target>
        </trans-unit>
        <trans-unit id="606cfc5f8f22b0f666e90c16494ce8cfe5172b45" translate="yes" xml:space="preserve">
          <source>MAKE TEST</source>
          <target state="translated">制作测试</target>
        </trans-unit>
        <trans-unit id="d33b61e914eef018d44c2af2392dd8a8bb3f0814" translate="yes" xml:space="preserve">
          <source>MAKEMAKER: path to the MakeMaker module.</source>
          <target state="translated">MAKEMAKER:MakeMaker模块的路径。</target>
        </trans-unit>
        <trans-unit id="fba0fd0dd60434c9d108881cdd60c2cfbd09f893" translate="yes" xml:space="preserve">
          <source>MAN PAGES</source>
          <target state="translated">人页</target>
        </trans-unit>
        <trans-unit id="9ae61f13c66eb261147f9d4b1d89a27b5c697890" translate="yes" xml:space="preserve">
          <source>MANIFEST</source>
          <target state="translated">MANIFEST</target>
        </trans-unit>
        <trans-unit id="ee43e9094077d72c1da72a9a91b89d3593977bf3" translate="yes" xml:space="preserve">
          <source>MANIFEST ON CYGWIN</source>
          <target state="translated">MANIFEST ON CYGWIN</target>
        </trans-unit>
        <trans-unit id="99aec53b52aee7fd41e057b43112a2b07b20b1fa" translate="yes" xml:space="preserve">
          <source>MANIFEST.SKIP</source>
          <target state="translated">MANIFEST.SKIP</target>
        </trans-unit>
        <trans-unit id="93ba9a2acb7ece879d6eae4b3780b55ff65e53c6" translate="yes" xml:space="preserve">
          <source>MANIFEST.bak</source>
          <target state="translated">MANIFEST.bak</target>
        </trans-unit>
        <trans-unit id="b315cd523ae2ef826dbad53529ba6c9c2ad21ff1" translate="yes" xml:space="preserve">
          <source>MAPPING</source>
          <target state="translated">MAPPING</target>
        </trans-unit>
        <trans-unit id="34a4dfce34585d297b90edd353506556851a5017" translate="yes" xml:space="preserve">
          <source>MATH</source>
          <target state="translated">MATH</target>
        </trans-unit>
        <trans-unit id="72a965b84fe5d8bf2c44aadc341ef716b1bb9f90" translate="yes" xml:space="preserve">
          <source>MATH LIBRARY</source>
          <target state="translated">数学图书馆</target>
        </trans-unit>
        <trans-unit id="f4b1c471ce1efbe25d7232b293140a21b7fea826" translate="yes" xml:space="preserve">
          <source>MEMORY</source>
          <target state="translated">MEMORY</target>
        </trans-unit>
        <trans-unit id="cdf5b879eba064baae0d94237dbf7820fdcbb018" translate="yes" xml:space="preserve">
          <source>MEMORY DEBUGGERS</source>
          <target state="translated">存储器调试器</target>
        </trans-unit>
        <trans-unit id="e31b925235cc3be7fd5e0670fdc195273a9cff6f" translate="yes" xml:space="preserve">
          <source>MEMORY STORE</source>
          <target state="translated">存储器</target>
        </trans-unit>
        <trans-unit id="c459b150dd079f2662d2dc95f57ad127cc7aa8df" translate="yes" xml:space="preserve">
          <source>META CHARACTERS</source>
          <target state="translated">META CHARACTERS</target>
        </trans-unit>
        <trans-unit id="4a6da301633ce81aa21cac64ffb95d87c6894995" translate="yes" xml:space="preserve">
          <source>META.json</source>
          <target state="translated">META.json</target>
        </trans-unit>
        <trans-unit id="3b7f8f92275828b66b32cb6c6aeb61e73c1d7587" translate="yes" xml:space="preserve">
          <source>META.yml</source>
          <target state="translated">META.yml</target>
        </trans-unit>
        <trans-unit id="296be0aba5c6db10945a86505a9c35adbc0a5da7" translate="yes" xml:space="preserve">
          <source>METHOD CALLING</source>
          <target state="translated">调用方法</target>
        </trans-unit>
        <trans-unit id="7541f2ddbea83515621139a06393c2c41632b2df" translate="yes" xml:space="preserve">
          <source>METHODS</source>
          <target state="translated">METHODS</target>
        </trans-unit>
        <trans-unit id="3cb215be859943e6d7b15dec190189887d7849cd" translate="yes" xml:space="preserve">
          <source>METHODS FOR PARSING AND PROCESSING</source>
          <target state="translated">筛选和处理方法</target>
        </trans-unit>
        <trans-unit id="bac1668d54ba3469d07436c3cb4d6c63921e8439" translate="yes" xml:space="preserve">
          <source>MILLIONS OF MACROS</source>
          <target state="translated">数以百万计的MACROS</target>
        </trans-unit>
        <trans-unit id="8c54fa1663ec8e58feaa0f76d0ad16806f96497d" translate="yes" xml:space="preserve">
          <source>MIME 'B' and 'Q' header encoding</source>
          <target state="translated">MIME'B'和'Q'头编码。</target>
        </trans-unit>
        <trans-unit id="f0186eb413ae0fe1b04a58826d46062c8207cd98" translate="yes" xml:space="preserve">
          <source>MIME (Multipurpose Internet Mail Extensions)</source>
          <target state="translated">多用途邮件扩展项</target>
        </trans-unit>
        <trans-unit id="ced61424802296ffb38430fa8f0fab4da3883207" translate="yes" xml:space="preserve">
          <source>MIME::Base64</source>
          <target state="translated">MIME::Base64</target>
        </trans-unit>
        <trans-unit id="7fe3ea65bc04a88102c03df5c340d4e7c1520d18" translate="yes" xml:space="preserve">
          <source>MIME::Base64 - Encoding and decoding of base64 strings</source>
          <target state="translated">MIME::Base64-base64字符串的编码和解码。</target>
        </trans-unit>
        <trans-unit id="7ffae17f904a8de9b8c01b15e74d1504ffbc2043" translate="yes" xml:space="preserve">
          <source>MIME::QuotedPrint</source>
          <target state="translated">MIME::QuotedPrint</target>
        </trans-unit>
        <trans-unit id="65095920906e9bf0fe024eb72fdfbbe098341dd5" translate="yes" xml:space="preserve">
          <source>MIME::QuotedPrint - Encoding and decoding of quoted-printable strings</source>
          <target state="translated">MIME::QuotedPrint-可引用打印的字符串的编码和解码</target>
        </trans-unit>
        <trans-unit id="fbc28147d7dae55d07ef20379522673d2cd4aff7" translate="yes" xml:space="preserve">
          <source>MISCELLANEOUS</source>
          <target state="translated">MISCELLANEOUS</target>
        </trans-unit>
        <trans-unit id="0e2957d871def6ecf380e593a975af27f56d18ea" translate="yes" xml:space="preserve">
          <source>MISCELLANEOUS TRICKS</source>
          <target state="translated">杂七杂八的技巧</target>
        </trans-unit>
        <trans-unit id="8727bad0374de5d99b1e6473dee31baa8ae41493" translate="yes" xml:space="preserve">
          <source>MKTEMP FUNCTIONS</source>
          <target state="translated">MKTEMP功能</target>
        </trans-unit>
        <trans-unit id="38de91e68bd653a65240e9601577373f8b2878b4" translate="yes" xml:space="preserve">
          <source>MM_REVISION: ExtUtils::MakeMaker version control revision (for backwards compat)</source>
          <target state="translated">MM_REVISION:ExtUtils::MakeMaker版本控制修订版 (用于向后兼容)</target>
        </trans-unit>
        <trans-unit id="065dc1eef187bb989bef804cda0869075be856b3" translate="yes" xml:space="preserve">
          <source>MM_VERSION: ExtUtils::MakeMaker Version</source>
          <target state="translated">MM_VERSION:ExtUtils::MakeMaker 版本。</target>
        </trans-unit>
        <trans-unit id="b630876e2ee4a66e53ca42c0024ca639bccd9170" translate="yes" xml:space="preserve">
          <source>MM_VMS_REVISION is for backwards compatibility before MM_VMS had a $VERSION.</source>
          <target state="translated">MM_VMS_REVISION是为了在MM_VMS有$VERSION之前向后兼容。</target>
        </trans-unit>
        <trans-unit id="5a5019b6901ec4e0159788b99019a468b1278f03" translate="yes" xml:space="preserve">
          <source>MODE</source>
          <target state="translated">MODE</target>
        </trans-unit>
        <trans-unit id="11d727b07a2ef2f226c24b7b3ca7ffbcc8a440f3" translate="yes" xml:space="preserve">
          <source>MODIFICATION HISTORY</source>
          <target state="translated">修改历史</target>
        </trans-unit>
        <trans-unit id="66bffe2295ae671e5d45439c77216938c792414b" translate="yes" xml:space="preserve">
          <source>MODULE</source>
          <target state="translated">MODULE</target>
        </trans-unit>
        <trans-unit id="a3e25a142bc9338d99e21ddb92754631acdb233f" translate="yes" xml:space="preserve">
          <source>MODULENAME is the Perl module name, e.g. Devel::SelfStubber, NOT 'Devel/SelfStubber' or 'Devel/SelfStubber.pm'.</source>
          <target state="translated">MODULENAME是Perl模块的名称,例如:Devel::SelfStubber,而不是'Devel/SelfStubber'或'Devel/SelfStubber.pm'。</target>
        </trans-unit>
        <trans-unit id="479396de59be987e42108d35e44f4b59dc1b4a9e" translate="yes" xml:space="preserve">
          <source>MODULES</source>
          <target state="translated">MODULES</target>
        </trans-unit>
        <trans-unit id="630e8cd715da84adcb106243940c860db346e2eb" translate="yes" xml:space="preserve">
          <source>MODULES USED</source>
          <target state="translated">使用的模块</target>
        </trans-unit>
        <trans-unit id="c47b9589ffc380689e211aa66dac2ba8473cc24a" translate="yes" xml:space="preserve">
          <source>MONO CASE then sort data (for non-digits, non-underscore)</source>
          <target state="translated">MONO CASE 然后对数据进行排序(对于非数字、非下划线)。</target>
        </trans-unit>
        <trans-unit id="b537891a9c0b5c8f4e6ee16a9ec71caca75f6730" translate="yes" xml:space="preserve">
          <source>MORAL</source>
          <target state="translated">MORAL</target>
        </trans-unit>
        <trans-unit id="bc4fc594140fde77e059ad4498ad554e3cbee3e9" translate="yes" xml:space="preserve">
          <source>MORE ELABORATE RECORDS</source>
          <target state="translated">更多ELABORATE记录</target>
        </trans-unit>
        <trans-unit id="64bf6c143dc817670181bbd264688b3acbcd5d5a" translate="yes" xml:space="preserve">
          <source>MORE EXAMPLES</source>
          <target state="translated">更多例子</target>
        </trans-unit>
        <trans-unit id="9ad9881a7f17afaec8c4ae609d85b1187596ee5b" translate="yes" xml:space="preserve">
          <source>MORE INFORMATION</source>
          <target state="translated">更多信息</target>
        </trans-unit>
        <trans-unit id="76991e71012a76451fe2a0cc0849f44f697181ec" translate="yes" xml:space="preserve">
          <source>MORE READING FOR GUTS HACKERS</source>
          <target state="translated">更多GUTS HACKERS的阅读</target>
        </trans-unit>
        <trans-unit id="abdd28bdcd2ff588ed4391e2849b71273a64ab04" translate="yes" xml:space="preserve">
          <source>MRO Functions</source>
          <target state="translated">MRO功能</target>
        </trans-unit>
        <trans-unit id="304ff724cf80bd1102c4a52a83e37a5a11d51edf" translate="yes" xml:space="preserve">
          <source>MSG_BCAST, MSG_OOB, MSG_TRUNC, ...</source>
          <target state="translated">MSG_BCAST,MSG_OOB,MSG_TRUNC,...。</target>
        </trans-unit>
        <trans-unit id="95ed316aead6f0a90227220b98ed2c6a72173129" translate="yes" xml:space="preserve">
          <source>MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE, indicating the case significance when comparing file specifications. Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem. See &lt;a href=&quot;http://cygwin.com/ml/cygwin/2007-07/msg00891.html&quot;&gt;http://cygwin.com/ml/cygwin/2007-07/msg00891.html&lt;/a&gt; Default: 1</source>
          <target state="translated">MSWin32的区分大小写取决于GetVolumeInformation（）$ ouFsFlags == FS_CASE_SENSITIVE，指示在比较文件规范时区分大小写。由于XP FS_CASE_SENSITIVE已被NT子系统有效禁用。参见&lt;a href=&quot;http://cygwin.com/ml/cygwin/2007-07/msg00891.html&quot;&gt;http://cygwin.com/ml/cygwin/2007-07/msg00891.html&lt;/a&gt;默认值：1</target>
        </trans-unit>
        <trans-unit id="46b420891abbe816108b89b151663fa05cb3b237" translate="yes" xml:space="preserve">
          <source>MULTI-OCTET CHARACTER SETS</source>
          <target state="translated">多重八位数字符集。</target>
        </trans-unit>
        <trans-unit id="112f1bc5464cbf86ad8abc28805d58542d252dc7" translate="yes" xml:space="preserve">
          <source>MUST decode</source>
          <target state="translated">必须解码</target>
        </trans-unit>
        <trans-unit id="f3f97d4e65bbf8e05b9d2003dabed48039672a9b" translate="yes" xml:space="preserve">
          <source>MUST return the octet sequence representing</source>
          <target state="translated">必须返回代表</target>
        </trans-unit>
        <trans-unit id="f37495c410f3672ad3b7e5f75ff69fe1801eda14" translate="yes" xml:space="preserve">
          <source>MUST return the string representing the IANA charset name of the encoding.</source>
          <target state="translated">必须返回代表编码的IANA charset名称的字符串。</target>
        </trans-unit>
        <trans-unit id="df44e8bf9f5bb85b1c861873578524b02eaca16a" translate="yes" xml:space="preserve">
          <source>MUST return the string representing the canonical name of the encoding.</source>
          <target state="translated">必须返回代表编码规范名称的字符串。</target>
        </trans-unit>
        <trans-unit id="4a6d2a5fac9fc009e8ef2c66dccfa9c0e7765210" translate="yes" xml:space="preserve">
          <source>MUST return the string that</source>
          <target state="translated">必须返回的字符串是</target>
        </trans-unit>
        <trans-unit id="8a1a4fa060cab0b9420887b26bf1330d0275e0dd" translate="yes" xml:space="preserve">
          <source>MYMETA.json</source>
          <target state="translated">MYMETA.json</target>
        </trans-unit>
        <trans-unit id="2f5e6a42d1d484cbbde0efe806d130305e765ea2" translate="yes" xml:space="preserve">
          <source>MYMETA.yml</source>
          <target state="translated">MYMETA.yml</target>
        </trans-unit>
        <trans-unit id="c92b11ff7ab5a4c5fd081db7883c7b3a71c6ef70" translate="yes" xml:space="preserve">
          <source>MY_CXT REFERENCE</source>
          <target state="translated">MY_CXT REFERENCE</target>
        </trans-unit>
        <trans-unit id="61ad4287cd41e2e97ad96a7d5cba5a661af2c472" translate="yes" xml:space="preserve">
          <source>MY_LIB_DIR defaults to '.' if not present.</source>
          <target state="translated">如果没有,MY_LIB_DIR默认为'.'。</target>
        </trans-unit>
        <trans-unit id="9790a85a1a9e58a2ddd68bd085adb9c931b1b046" translate="yes" xml:space="preserve">
          <source>Mac OS 9 and earlier used &lt;code&gt;:&lt;/code&gt; as a path separator instead of &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">在Mac OS 9和更早的版本中，使用 &lt;code&gt;:&lt;/code&gt; 代替 &lt;code&gt;/&lt;/code&gt; 作为路径分隔符。</target>
        </trans-unit>
        <trans-unit id="9208982d7e71273ee9421bf88e0b53b6ad837f35" translate="yes" xml:space="preserve">
          <source>Mac OS X 10.5 &quot;Leopard&quot; and above do not require the 'u' variant.</source>
          <target state="translated">Mac OS X 10.5 &quot;Leopard &quot;及以上版本不需要 &quot;u &quot;版本。</target>
        </trans-unit>
        <trans-unit id="27e0400e4107eec8c9b3ecfab19987f0725198d4" translate="yes" xml:space="preserve">
          <source>Mac OS X documentation on syslog, &lt;a href=&quot;http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html&quot;&gt;http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html&lt;/a&gt;</source>
          <target state="translated">syslog上的Mac OS X文档，&lt;a href=&quot;http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html&quot;&gt;http：//developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a4c0bf3f7dab7b087f55de5614ca5cbaddeea9b9" translate="yes" xml:space="preserve">
          <source>Mac OS X ships with a dynamically-loaded libperl, but the default for this release is to compile a static libperl. The reason for this is pre-binding. Dynamic libraries can be pre-bound to a specific address in memory in order to decrease load time. To do this, one needs to be aware of the location and size of all previously-loaded libraries. Apple collects this information as part of their overall OS build process, and thus has easy access to it when building Perl, but ordinary users would need to go to a great deal of effort to obtain the information needed for pre-binding.</source>
          <target state="translated">Mac OS X 提供了一个动态加载的 libperl,但这个版本的默认值是编译一个静态 libperl。这样做的原因是预绑定。动态库可以预先绑定到内存中的特定地址,以减少加载时间。要做到这一点,需要了解所有之前加载的库的位置和大小。苹果公司将这些信息作为其整个操作系统构建过程的一部分进行收集,因此在构建Perl时很容易获得这些信息,但普通用户要想获得预绑定所需的信息,则需要花费很大的精力。</target>
        </trans-unit>
        <trans-unit id="0343b2a40016db738fa670b19df9f47fc227d16f" translate="yes" xml:space="preserve">
          <source>Mac OS X.</source>
          <target state="translated">Mac OS X。</target>
        </trans-unit>
        <trans-unit id="e813bad999ce5a75f4490c8ed14ec07ab9d63a2d" translate="yes" xml:space="preserve">
          <source>Macro to declare an XSUB and its C parameter list explicitly exporting the symbols.</source>
          <target state="translated">用于声明XSUB及其C参数列表的宏,明确导出符号。</target>
        </trans-unit>
        <trans-unit id="3f0040307b52caa52d747905fa724ed6b830cee4" translate="yes" xml:space="preserve">
          <source>Macro to declare an XSUB and its C parameter list without exporting the symbols. This is handled by &lt;code&gt;xsubpp&lt;/code&gt; and generally preferable over exporting the XSUB symbols unnecessarily.</source>
          <target state="translated">宏，用于声明XSUB及其C参数列表，而无需导出符号。这由 &lt;code&gt;xsubpp&lt;/code&gt; 处理，通常优于不必要地导出XSUB符号。</target>
        </trans-unit>
        <trans-unit id="1376083aeef8a0b2b3a5461de74e71c6974c467b" translate="yes" xml:space="preserve">
          <source>Macro to declare an XSUB and its C parameter list. This is handled by &lt;code&gt;xsubpp&lt;/code&gt; . It is the same as using the more explicit XS_EXTERNAL macro.</source>
          <target state="translated">宏，用于声明XSUB及其C参数列表。这由 &lt;code&gt;xsubpp&lt;/code&gt; 处理。它与使用更明确的XS_EXTERNAL宏相同。</target>
        </trans-unit>
        <trans-unit id="7aea32d1102862e7b6b0c8089588079d1bf46bd9" translate="yes" xml:space="preserve">
          <source>Macro to verify that a PM module's $VERSION variable matches the XS module's &lt;code&gt;XS_VERSION&lt;/code&gt; variable. This is usually handled automatically by &lt;code&gt;xsubpp&lt;/code&gt; . See &lt;a href=&quot;perlxs#The-VERSIONCHECK%3a-Keyword&quot;&gt;The VERSIONCHECK: Keyword in perlxs&lt;/a&gt;.</source>
          <target state="translated">用于验证PM模块的$ VERSION变量与XS模块的 &lt;code&gt;XS_VERSION&lt;/code&gt; 变量匹配的宏。这通常由 &lt;code&gt;xsubpp&lt;/code&gt; 自动处理。请参阅&lt;a href=&quot;perlxs#The-VERSIONCHECK%3a-Keyword&quot;&gt;VERSIONCHECK：perlxs中的关键字&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66fb64fe6d247cc13c8ba2ecc02f6b2d75c4b93f" translate="yes" xml:space="preserve">
          <source>Macro to verify that the perl api version an XS module has been compiled against matches the api version of the perl interpreter it's being loaded into.</source>
          <target state="translated">宏,用于验证XS模块所编译的perl api版本是否与被加载的perl解释器的api版本一致。</target>
        </trans-unit>
        <trans-unit id="8f66f4521e615face2c94f9f782a4b88e0deefae" translate="yes" xml:space="preserve">
          <source>Macros that have string constants and their arguments as substrings of the string constants</source>
          <target state="translated">将字符串常量及其参数作为字符串常量的子串的宏。</target>
        </trans-unit>
        <trans-unit id="696a489ce86f443d3bd7f260f57fe68b0f5e0740" translate="yes" xml:space="preserve">
          <source>Magic Autogeneration</source>
          <target state="translated">魔法自发电</target>
        </trans-unit>
        <trans-unit id="5b951438b2b5824d83645ebbc34942743d54e18e" translate="yes" xml:space="preserve">
          <source>Magic Variables</source>
          <target state="translated">魔法变量</target>
        </trans-unit>
        <trans-unit id="88fd65fe2e12d0229bfa9aa8c0f337c8c7a34525" translate="yes" xml:space="preserve">
          <source>Magic Virtual Tables</source>
          <target state="translated">魔法虚拟表</target>
        </trans-unit>
        <trans-unit id="2de64b7079eac3534ed35bf9a982a56cf8fb08a0" translate="yes" xml:space="preserve">
          <source>Magic autogeneration increases the potential for inadvertently creating self-referential structures. Currently Perl will not free self-referential structures until cycles are explicitly broken. For example,</source>
          <target state="translated">魔法自动生成增加了无意中创建自引用结构的可能性。目前Perl不会释放自引用结构,直到循环被显式打破。例如</target>
        </trans-unit>
        <trans-unit id="2e0ebd98fa5e6d797bebdd2c2d2dbacb085a7bcb" translate="yes" xml:space="preserve">
          <source>Magic constants</source>
          <target state="translated">魔法常数</target>
        </trans-unit>
        <trans-unit id="9331d05bb9a05caf542c2c62dec84da956dc266b" translate="yes" xml:space="preserve">
          <source>Magical Functions</source>
          <target state="translated">神奇的功能</target>
        </trans-unit>
        <trans-unit id="4bc605047ccd6740cec0a34132f6861a236ee5db" translate="yes" xml:space="preserve">
          <source>Magical values and references can be made into constants at compile time, allowing for way cool stuff like this. (These error numbers aren't totally portable, alas.)</source>
          <target state="translated">神奇的值和引用可以在编译时变成常量,从而实现像这样的酷炫的东西。(这些错误数字并不是完全可移植的,唉。)</target>
        </trans-unit>
        <trans-unit id="df66650e348a506121860cd76f075780d1c6aedd" translate="yes" xml:space="preserve">
          <source>Mail and Usenet News</source>
          <target state="translated">邮件和Usenet新闻</target>
        </trans-unit>
        <trans-unit id="c9124b10840a3572bd767d51874576c37a45a513" translate="yes" xml:space="preserve">
          <source>MailList.U</source>
          <target state="translated">MailList.U</target>
        </trans-unit>
        <trans-unit id="56482927c5fda76aa41942ba11941327d4620c99" translate="yes" xml:space="preserve">
          <source>Mailing Lists and Newsgroups</source>
          <target state="translated">邮件列表和新闻组</target>
        </trans-unit>
        <trans-unit id="d2a1123e6461654a07e49c2ea0e3f5b116e7bf06" translate="yes" xml:space="preserve">
          <source>Mailing list</source>
          <target state="translated">邮件列表</target>
        </trans-unit>
        <trans-unit id="d50c2a333e418a4af64720c969c0846d34975a97" translate="yes" xml:space="preserve">
          <source>Mailing list for Perl on OS/390</source>
          <target state="translated">OS/390上的Perl邮件列表</target>
        </trans-unit>
        <trans-unit id="8422598c648ad701facadb193807fe8a68e5374e" translate="yes" xml:space="preserve">
          <source>Mailing list: cpan-testers-discuss@perl.org</source>
          <target state="translated">邮寄名单:cpan-testers-discuss@perl.org</target>
        </trans-unit>
        <trans-unit id="e42a6ff891c095b97c9c8d1876b99ab388267a2b" translate="yes" xml:space="preserve">
          <source>Mainly listed here to shut up the pitiful screams of the pod coverage tests. They keep me awake at night.</source>
          <target state="translated">主要列在这里关闭可怜的尖叫声 荚覆盖测试。他们让我晚上睡不着觉。</target>
        </trans-unit>
        <trans-unit id="2a025894cae9180557ea2537add4f6943dbc4f8b" translate="yes" xml:space="preserve">
          <source>Mainly used to exclude version control administrative directories from installation.</source>
          <target state="translated">主要用于从安装中排除版本控制管理目录。</target>
        </trans-unit>
        <trans-unit id="af2040fc4cdf263d0853758e669e36927b733e94" translate="yes" xml:space="preserve">
          <source>Maintain Round Trip Integrity</source>
          <target state="translated">保持往返的完整性</target>
        </trans-unit>
        <trans-unit id="6cc92c03b00f2d20d0dd8de351bcdf848cd97ae9" translate="yes" xml:space="preserve">
          <source>Maintained by Ken Williams &amp;lt;KWILLIAMS@cpan.org&amp;gt;</source>
          <target state="translated">由Ken Williams维护&amp;lt;KWILLIAMS@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="809e72cee268c819612dba25360f847662fc4877" translate="yes" xml:space="preserve">
          <source>Maintained by Michael G Schwern</source>
          <target state="translated">由Michael G Schwern维护</target>
        </trans-unit>
        <trans-unit id="3d8d67b0bc713d08e1431289fef2c4da24e0a6d9" translate="yes" xml:space="preserve">
          <source>Maintained by Michael G Schwern &lt;code&gt;schwern@pobox.com&lt;/code&gt; within the ExtUtils-MakeMaker package and, as a separate CPAN package, by Randy Kobes &lt;code&gt;r.kobes@uwinnipeg.ca&lt;/code&gt; .</source>
          <target state="translated">由Michael G Schwern &lt;code&gt;schwern@pobox.com&lt;/code&gt; 维护在ExtUtils-MakeMaker软件包中，作为单独的CPAN软件包，由Randy Kobes &lt;code&gt;r.kobes@uwinnipeg.ca&lt;/code&gt; 维护。</target>
        </trans-unit>
        <trans-unit id="66e8214c4bf741c76a84a61b0611d2148c0182fd" translate="yes" xml:space="preserve">
          <source>Maintained by:</source>
          <target state="translated">维护者:</target>
        </trans-unit>
        <trans-unit id="0fb7ae643e6e22eda1f0c20766a595198d76696b" translate="yes" xml:space="preserve">
          <source>Maintained since 1996 by The Perl Porters &amp;lt;</source>
          <target state="translated">自1996年以来由Perl Porters进行维护&amp;lt;</target>
        </trans-unit>
        <trans-unit id="643bbd5f57059016b08fdfc7624d83297d263211" translate="yes" xml:space="preserve">
          <source>Maintainer note:</source>
          <target state="translated">维护者说明:</target>
        </trans-unit>
        <trans-unit id="8a3300746df857e116a8c0e1c6dce416561209ca" translate="yes" xml:space="preserve">
          <source>Maintainer of the CPAN release is Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;. Contact him with technical difficulties with respect to the packaging of the CPAN module.</source>
          <target state="translated">CPAN版本的维护者是Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;。有关CPAN模块包装方面的技术困难，请与他联系。</target>
        </trans-unit>
        <trans-unit id="430b90ac2c360a8a68d16871970bc138c6d2cbdd" translate="yes" xml:space="preserve">
          <source>Maintainer of the CPAN release is Steffen Mueller (smueller@cpan.org). Contact him with technical difficulties with respect to the packaging of the CPAN module.</source>
          <target state="translated">CPAN版本的维护者是Steffen Mueller (smueller@cpan.org)。如果在CPAN模块打包方面遇到技术困难,请与他联系。</target>
        </trans-unit>
        <trans-unit id="b4afb7f985f5bfec03da261851d526768b0a7bd1" translate="yes" xml:space="preserve">
          <source>Maintainer of the CPAN release: Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;</source>
          <target state="translated">CPAN版本的维护者：Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="53ca95cbad19caeb958b071a4ed842e8b82f2816" translate="yes" xml:space="preserve">
          <source>Maintainer: Alexandr Ciornii &amp;lt;alexchornyATgmail.com&amp;gt;.</source>
          <target state="translated">维护者：Alexandr Ciornii &amp;lt;alexchornyATgmail.com&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="619bd6770e2cd62e7bc43b49020d0710c816e356" translate="yes" xml:space="preserve">
          <source>Maintainer: The Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</source>
          <target state="translated">维护者：Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9c61980ffa7774c0d3835c4f170771e00a8354d6" translate="yes" xml:space="preserve">
          <source>Maintaining a bundle definition file means keeping track of two things: dependencies and interactivity. CPAN.pm sometimes fails on calculating dependencies because not all modules define all MakeMaker attributes correctly, so a bundle definition file should specify prerequisites as early as possible. On the other hand, it's annoying that so many distributions need some interactive configuring. So what you can try to accomplish in your private bundle file is to have the packages that need to be configured early in the file and the gentle ones later, so you can go out for coffee after a few minutes and leave CPAN.pm to churn away unattended.</source>
          <target state="translated">维护一个bundle定义文件意味着要跟踪两件事:依赖性和交互性。CPAN.pm有时会在计算依赖性时失败,因为并不是所有模块都能正确定义所有MakeMaker属性,所以bundle定义文件应该尽早指定前提条件。另一方面,很多发行版都需要一些交互式的配置,这很烦人。所以你可以尝试在你的私有捆绑文件中实现的是,把需要配置的包早早地放在文件中,温柔的包放在后面,这样你就可以在几分钟后出去喝咖啡,让CPAN.pm在无人看管的情况下搅局。</target>
        </trans-unit>
        <trans-unit id="683b0250521f89ab5a7d8609ffca71e78293a058" translate="yes" xml:space="preserve">
          <source>Maintaining a persistent interpreter</source>
          <target state="translated">维持一个持久的口译员</target>
        </trans-unit>
        <trans-unit id="e88a9990f5d2ac06c40799dcdbc0bd3efadf5b36" translate="yes" xml:space="preserve">
          <source>Maintaining multiple interpreter instances</source>
          <target state="translated">维护多个解释器实例</target>
        </trans-unit>
        <trans-unit id="b029f6d7dda6875610cf345a0d379a80456960cd" translate="yes" xml:space="preserve">
          <source>Maintaining the urllist parameter</source>
          <target state="translated">维护urllist参数</target>
        </trans-unit>
        <trans-unit id="ecb8b463e1c71f307f7fc72628792a15f4e1bd31" translate="yes" xml:space="preserve">
          <source>Maintenance is now done by the perl5-porters</source>
          <target state="translated">维护工作现在由perl5-porters完成。</target>
        </trans-unit>
        <trans-unit id="a94431ee22f05f141107f9355ed3127d0f0c4d5a" translate="yes" xml:space="preserve">
          <source>Make</source>
          <target state="translated">Make</target>
        </trans-unit>
        <trans-unit id="04eff5d74d7ffc64b3c7d9b1b09aff266f1e0a57" translate="yes" xml:space="preserve">
          <source>Make a bootstrap file for use by DynaLoader</source>
          <target state="translated">制作一个引导文件,供DynaLoader使用。</target>
        </trans-unit>
        <trans-unit id="5a9fad7783334940c292ba0169f35e46fcaae627" translate="yes" xml:space="preserve">
          <source>Make a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">进行轻量级回调。请参阅&lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcall中的轻量级回调&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b212bd484216f27062e119a0984e12eb2f1ca4b" translate="yes" xml:space="preserve">
          <source>Make a new &lt;a href=&quot;parser/grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt; object and return it. Passes through any arguments given.</source>
          <target state="translated">新建一个&lt;a href=&quot;parser/grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt;对象并返回它。传递给定的任何参数。</target>
        </trans-unit>
        <trans-unit id="d5ad132f57df20c380d03727edf6efc89d530812" translate="yes" xml:space="preserve">
          <source>Make a new &lt;a href=&quot;parser/iteratorfactory&quot;&gt;TAP::Parser::IteratorFactory&lt;/a&gt; object and return it. Passes through any arguments given.</source>
          <target state="translated">新建一个&lt;a href=&quot;parser/iteratorfactory&quot;&gt;TAP :: Parser :: IteratorFactory&lt;/a&gt;对象并返回它。传递给定的任何参数。</target>
        </trans-unit>
        <trans-unit id="fa28fa8c90cb86c9b3f8c83899652b5dd29ba4e0" translate="yes" xml:space="preserve">
          <source>Make a new &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object using the parser's &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt;, and return it. Passes through any arguments given.</source>
          <target state="translated">使用解析器的&lt;a href=&quot;parser/resultfactory&quot;&gt;TAP :: Parser :: ResultFactory&lt;/a&gt;新建一个&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;对象，然后将其返回。传递给定的任何参数。</target>
        </trans-unit>
        <trans-unit id="3a0cb5edb690cd6db709e001b8158abfba90d3f9" translate="yes" xml:space="preserve">
          <source>Make a new parser and display formatter session. Typically used and/or overridden in subclasses.</source>
          <target state="translated">制作一个新的解析器和显示formatter会话。通常在子类中使用和/或重写。</target>
        </trans-unit>
        <trans-unit id="f4f6bf31d70d3b5261f262791889974009fba962" translate="yes" xml:space="preserve">
          <source>Make and return a complete copy of the cop hints hash</source>
          <target state="translated">制作并返还一份完整的警察提示哈希。</target>
        </trans-unit>
        <trans-unit id="5b886b01d91d82d72977b5c37dc6c5f47e7167a8" translate="yes" xml:space="preserve">
          <source>Make bsd_glob() return an error (GLOB_NOSPACE) when the pattern expands to a size bigger than the system constant &lt;code&gt;ARG_MAX&lt;/code&gt; (usually found in limits.h). If your system does not define this constant, bsd_glob() uses &lt;code&gt;sysconf(_SC_ARG_MAX)&lt;/code&gt; or &lt;code&gt;_POSIX_ARG_MAX&lt;/code&gt; where available (in that order). You can inspect these values using the standard &lt;code&gt;POSIX&lt;/code&gt; extension.</source>
          <target state="translated">当模式扩展到大于系统常数 &lt;code&gt;ARG_MAX&lt;/code&gt; （通常在limits.h中找到）的大小时，使bsd_glob（）返回错误（GLOB_NOSPACE ）。如果您的系统未定义此常数，则bsd_glob（）使用 &lt;code&gt;sysconf(_SC_ARG_MAX)&lt;/code&gt; 或 &lt;code&gt;_POSIX_ARG_MAX&lt;/code&gt; （按该顺序）。您可以使用标准 &lt;code&gt;POSIX&lt;/code&gt; 扩展名检查这些值。</target>
        </trans-unit>
        <trans-unit id="08523af5b76fef9eaed2b77615eb4a213597d67b" translate="yes" xml:space="preserve">
          <source>Make functions faster by trading space for time</source>
          <target state="translated">以空间换时间,让功能更快</target>
        </trans-unit>
        <trans-unit id="4b434c4028abbf501b87f9ee8429bc6772c12c60" translate="yes" xml:space="preserve">
          <source>Make perl executable and create a symlink for libperl:</source>
          <target state="translated">使 perl 可执行,并为 libperl 创建一个符号链接。</target>
        </trans-unit>
        <trans-unit id="631c39697ec2fc47f9fdac3b73868b5eac8535e4" translate="yes" xml:space="preserve">
          <source>Make sure &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname()&lt;/a&gt;&lt;/code&gt; is called in SCALAR context and that its return value is checked for definedness.</source>
          <target state="translated">确保在SCALAR上下文中调用 &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname()&lt;/a&gt;&lt;/code&gt; ，并检查其返回值是否已定义。</target>
        </trans-unit>
        <trans-unit id="1af92bfd9067c908f166333d8740f6095af6a588" translate="yes" xml:space="preserve">
          <source>Make sure &lt;code&gt;&lt;a href=&quot;gethostbyname&quot;&gt;gethostbyname()&lt;/a&gt;&lt;/code&gt; is called in SCALAR context and that its return value is checked for definedness.</source>
          <target state="translated">确保在SCALAR上下文中调用 &lt;code&gt;&lt;a href=&quot;gethostbyname&quot;&gt;gethostbyname()&lt;/a&gt;&lt;/code&gt; ，并检查其返回值是否已定义。</target>
        </trans-unit>
        <trans-unit id="9aee806c3df793514446c4364ffe009cca7c0176" translate="yes" xml:space="preserve">
          <source>Make sure that &lt;code&gt;CPAN.pm&lt;/code&gt; can download files from CPAN. If not, you may need to manually install &lt;code&gt;Net::FTP&lt;/code&gt; .</source>
          <target state="translated">确保 &lt;code&gt;CPAN.pm&lt;/code&gt; 可以从CPAN下载文件。如果没有，您可能需要手动安装 &lt;code&gt;Net::FTP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d90bf5e032808a1790937eefc282a0216577eb91" translate="yes" xml:space="preserve">
          <source>Make sure that the directory &lt;b&gt;above&lt;/b&gt; the directory with manpages is on our &lt;code&gt;MANPATH&lt;/code&gt; , like this</source>
          <target state="translated">确保带有手册页的目录&lt;b&gt;上方&lt;/b&gt;的目录在我们的 &lt;code&gt;MANPATH&lt;/code&gt; 上，像这样</target>
        </trans-unit>
        <trans-unit id="6d62a68cc52f846e8b7cd7e34bad20513f656424" translate="yes" xml:space="preserve">
          <source>Make sure that the installed modules are actually installed in the location of the new Perl, and are not inherited from entries of @INC given for inheritance from the older versions of Perl: set &lt;code&gt;PERLLIB_582_PREFIX&lt;/code&gt; to redirect the new version of Perl to a new location, and copy the installed files to this new location. Redo the tests to make sure that the versions of modules inherited from older versions of Perl are not needed.</source>
          <target state="translated">确保已安装的模块实际上安装在新的Perl的位置，并且没有从为从旧版本的Perl继承而提供的@INC条目继承而来：设置 &lt;code&gt;PERLLIB_582_PREFIX&lt;/code&gt; 以将新版本的Perl重定向到新位置，并将安装的文件复制到此新位置。重做测试，以确保不需要从较早版本的Perl继承的模块版本。</target>
        </trans-unit>
        <trans-unit id="8e40ae3a79feffa50f9360f35cfc29b12c2563ad" translate="yes" xml:space="preserve">
          <source>Make sure that you &lt;code&gt;make realclean&lt;/code&gt; in your copy of Perl to remove any build artifacts, or you may get a confusing result.</source>
          <target state="translated">确保在Perl副本 &lt;code&gt;make realclean&lt;/code&gt; 删除所有构建构件，否则可能会导致混淆。</target>
        </trans-unit>
        <trans-unit id="c48620eee0813f53db06b1d13fb05c7d0b30ec92" translate="yes" xml:space="preserve">
          <source>Make sure that your module has a license, and that the full text of it is included in the distribution (unless it's a common one and the terms of the license don't require you to include it).</source>
          <target state="translated">确保你的模块有一个许可证,并且它的全文包含在发行版中(除非它是一个普通的许可证,并且许可证的条款不要求你包含它)。</target>
        </trans-unit>
        <trans-unit id="b4b22689c7f11757036113b227d7cdc8128156e0" translate="yes" xml:space="preserve">
          <source>Make sure the commit message describes your change in a single sentence. For example, &quot;Fixed spelling errors in perlhack.pod&quot;.</source>
          <target state="translated">确保提交信息用一句话来描述你的修改,比如 &quot;修正了perlhack.pod中的拼写错误&quot;。例如,&quot;修正了 perlhack.pod 中的拼写错误&quot;。</target>
        </trans-unit>
        <trans-unit id="31c004e759b68f9d5539083901242f08c624a89b" translate="yes" xml:space="preserve">
          <source>Make sure the newlines for the modules are in Mac format, not Unix format. If they are not then you might have decompressed them incorrectly. Check your decompression and unpacking utilities settings to make sure they are translating text files properly.</source>
          <target state="translated">确保模块的换行是Mac格式,而不是Unix格式。如果不是,那么你可能解压错误。检查你的解压和解压工具设置,以确保它们正确翻译文本文件。</target>
        </trans-unit>
        <trans-unit id="0da095bfcf60a5da0d5078d4fb200d212838fa47" translate="yes" xml:space="preserve">
          <source>Make sure the patch is not reversed (the first argument to diff is typically the original file, the second argument your changed file). Make sure you test your patch by applying it with &lt;code&gt;git am&lt;/code&gt; or the &lt;code&gt;patch&lt;/code&gt; program before you send it on its way. Try to follow the same style as the code you are trying to patch. Make sure your patch really does work (&lt;code&gt;make test&lt;/code&gt; , if the thing you're patching is covered by Perl's test suite).</source>
          <target state="translated">确保补丁没有反转（diff的第一个参数通常是原始文件，第二个参数是更改后的文件）。在发送 &lt;code&gt;patch&lt;/code&gt; 之前，请确保使用 &lt;code&gt;git am&lt;/code&gt; 或补丁程序对其进行测试。尝试遵循与您要修补的代码相同的样式。确保你的补丁确实工作（ &lt;code&gt;make test&lt;/code&gt; ，如果事情你是修补由Perl的测试套件覆盖）。</target>
        </trans-unit>
        <trans-unit id="6fe3ef49c50e09399f8e7e0ae50f650120ed9ba3" translate="yes" xml:space="preserve">
          <source>Make sure the path to the build directory does not contain spaces. The build usually works in this circumstance, but some tests will fail.</source>
          <target state="translated">确保通往构建目录的路径不包含空格。在这种情况下,构建通常会成功,但有些测试会失败。</target>
        </trans-unit>
        <trans-unit id="b25e9d6769a32bda0cb16adea51fc9a9577bd44e" translate="yes" xml:space="preserve">
          <source>Make sure to read about creating modules in &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; and the perils of indirect objects in &lt;a href=&quot;perlobj#Method-Invocation&quot;&gt;Method Invocation in perlobj&lt;/a&gt;.</source>
          <target state="translated">确保阅读有关在&lt;a href=&quot;perlmod&quot;&gt;perlmod中&lt;/a&gt;创建模块和在perlobj中的&lt;a href=&quot;perlobj#Method-Invocation&quot;&gt;Method Invocation中&lt;/a&gt;间接对象​​的风险的信息。</target>
        </trans-unit>
        <trans-unit id="c9bbcc12fd16263e19bc5318e960269249316b2e" translate="yes" xml:space="preserve">
          <source>Make sure you are in the &quot;win32&quot; subdirectory under the perl toplevel. This directory contains a &quot;Makefile&quot; that will work with versions of nmake that come with Visual C++ or the Windows SDK, and a dmake &quot;makefile.mk&quot; that will work for all supported compilers. The defaults in the dmake makefile are setup to build using MinGW/gcc.</source>
          <target state="translated">确保你在perl toplevel下的 &quot;win32 &quot;子目录中。这个目录包含了一个 &quot;Makefile&quot;,它可以和Visual C++或Windows SDK中的nmake版本一起使用,还有一个dmake &quot;makefile.mk&quot;,它可以和所有支持的编译器一起使用。dmake makefile中的默认设置是使用MinGW/gcc构建。</target>
        </trans-unit>
        <trans-unit id="b578a0bba566a5e009cf7a1e8f93afb16265f4fa" translate="yes" xml:space="preserve">
          <source>Make sure you choose an appropriate name for your module early on. This will help people find and remember your module, and make programming with your module more intuitive.</source>
          <target state="translated">确保你在早期为你的模块选择一个合适的名字。这将帮助人们找到并记住你的模块,并使你的模块编程更加直观。</target>
        </trans-unit>
        <trans-unit id="b8dca7eb87954059e67d6baf9d117854dccfc284" translate="yes" xml:space="preserve">
          <source>Make sure you have MMS (from Digital) or the freeware MMK ( available from MadGoat at &lt;a href=&quot;http://www.madgoat.com&quot;&gt;http://www.madgoat.com&lt;/a&gt; ). Then type this to create the DESCRIP.MMS for the module:</source>
          <target state="translated">确保您拥有MMS（来自Digital）或免费软件MMK（可从MadGoat &lt;a href=&quot;http://www.madgoat.com&quot;&gt;网站http://www.madgoat.com获得&lt;/a&gt;）。然后键入以下内容以为模块创建DESCRIP.MMS：</target>
        </trans-unit>
        <trans-unit id="45bcb550cc19143c5e8dd91291c0c6d1da90642e" translate="yes" xml:space="preserve">
          <source>Make sure you have the appropriate permissions to install the module in your Perl 5 library directory. Often, you'll need to be root.</source>
          <target state="translated">确保你有适当的权限在你的Perl 5库目录下安装该模块。通常情况下,你需要有root权限。</target>
        </trans-unit>
        <trans-unit id="8c6288609b67d4900e3a7acdb0708c647b7ddea0" translate="yes" xml:space="preserve">
          <source>Make sure you use a tab and not spaces on the lines beginning with &quot;$(AR)&quot; and &quot;$(RANLIB)&quot;. Make will not function properly if you use spaces. It has also been reported that the &quot;cr&quot; argument to $(AR) is unnecessary on Win32 systems.</source>
          <target state="translated">确保在&quot;$(AR)&quot;和&quot;$(RANLIB)&quot;开头的行上使用制表符而不是空格。如果你使用空格,Make将无法正常运行。也有报道称,在Win32系统上,$(AR)的 &quot;cr &quot;参数是不必要的。</target>
        </trans-unit>
        <trans-unit id="6aa0752b0b4c6627413012df0488bf1ad6b435f3" translate="yes" xml:space="preserve">
          <source>Make sure your PATH includes the compiler (/opt/SUNWspro/bin/ if you're using Sun's compiler) as well as /usr/ccs/bin/ to pick up the other development tools (such as make, ar, as, and ld). Make sure your path either doesn't include /usr/ucb or that it includes it after the compiler and compiler tools and other standard Solaris directories. You definitely don't want /usr/ucb/cc.</source>
          <target state="translated">确保你的PATH包括编译器(/opt/SUNWspro/bin/,如果你使用的是Sun的编译器),以及/usr/ccs/bin/来获取其他开发工具(如make、ar、as和ld)。确保你的路径要么不包括/usr/ucb,要么在编译器和编译工具以及其他标准的Solaris目录之后包括它。你肯定不想让/usr/ucb/cc。</target>
        </trans-unit>
        <trans-unit id="da98ff8151fcc7f9259493c3bc630b4f6abd18b6" translate="yes" xml:space="preserve">
          <source>Make sure your gcc is good for &lt;code&gt;-Zomf&lt;/code&gt; linking: run &lt;code&gt;omflibs&lt;/code&gt; script in</source>
          <target state="translated">确保您的gcc适合 &lt;code&gt;-Zomf&lt;/code&gt; 链接：在以下位置运行 &lt;code&gt;omflibs&lt;/code&gt; 脚本</target>
        </trans-unit>
        <trans-unit id="a248163580a9e29ef4a7312495856815f271337b" translate="yes" xml:space="preserve">
          <source>Make the first argument a copy of the second, then delete the original. The target SV physically takes over ownership of the body of the source SV and inherits its flags; however, the target keeps any magic it owns, and any magic in the source is discarded. Note that this is a rather specialist SV copying operation; most of the time you'll want to use &lt;code&gt;sv_setsv&lt;/code&gt; or one of its many macro front-ends.</source>
          <target state="translated">将第一个参数复制为第二个参数，然后删除原始参数。目标SV物理上接管源SV主体的所有权并继承其标志；但是，目标保留其拥有的所有魔咒，而源中的任何魔咒也会被丢弃。请注意，这是相当专业的SV复制操作。大多数时候，您会想使用 &lt;code&gt;sv_setsv&lt;/code&gt; 或它的许多宏前端之一。</target>
        </trans-unit>
        <trans-unit id="f4bb5d8584647cb5cbfe371da2ee93cc6742e08f" translate="yes" xml:space="preserve">
          <source>Make the most of the opportunity.</source>
          <target state="translated">充分利用机会。</target>
        </trans-unit>
        <trans-unit id="87a3a748935c5363a3cfdc69fbfc39c4592f4900" translate="yes" xml:space="preserve">
          <source>Make the string $content be the content for the file named $file.</source>
          <target state="translated">让字符串$content成为名为$file的文件的内容。</target>
        </trans-unit>
        <trans-unit id="b14a5a45500c708bfc2adecf45938f8ddfc95c0a" translate="yes" xml:space="preserve">
          <source>Make updating the '1..42' string unnecessary. Or make sure that you update it.</source>
          <target state="translated">让更新'1...42'这个字符串没有必要。或者确保你更新它。</target>
        </trans-unit>
        <trans-unit id="951e86d639f2ed613d02f1c077ce05396f017abb" translate="yes" xml:space="preserve">
          <source>MakeMaker (as of 6.31) and Module::Build (as of 0.28) both can install to the same locations using the &quot;install_base&quot; concept. See &lt;a href=&quot;../makemaker#INSTALL_BASE&quot;&gt;INSTALL_BASE in ExtUtils::MakeMaker&lt;/a&gt; for details. To get MM and MB to install to the same location simply set INSTALL_BASE in MM and &lt;code&gt;--install_base&lt;/code&gt; in MB to the same location.</source>
          <target state="translated">MakeMaker（自6.31起）和Module :: Build（自0.28起）都可以使用&amp;ldquo; install_base&amp;rdquo;概念安装到相同位置。有关详细信息，请参见&lt;a href=&quot;../makemaker#INSTALL_BASE&quot;&gt;ExtUtils :: MakeMaker中的INSTALL_BASE&lt;/a&gt;。要使MM和MB安装到同一位置，只需将MM中的INSTALL_BASE设置为MB，将MB中的 &lt;code&gt;--install_base&lt;/code&gt; 设置为相同位置。</target>
        </trans-unit>
        <trans-unit id="f57976a42f4d4f108960d3047b05d9b0bd7410ad" translate="yes" xml:space="preserve">
          <source>MakeMaker also checks for any files matching glob(&quot;t/*.t&quot;). It will execute all matching files in alphabetical order via the &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt; module with the &lt;code&gt;-I&lt;/code&gt; switches set correctly.</source>
          <target state="translated">MakeMaker还会检查是否有任何匹配glob（&amp;ldquo; t / *。t&amp;rdquo;）的文件。通过正确设置 &lt;code&gt;-I&lt;/code&gt; 开关的&lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness&lt;/a&gt;模块，它将按字母顺序执行所有匹配的文件。</target>
        </trans-unit>
        <trans-unit id="ea4d9ecb21fe83e2ef44aa02cc6eba3ee3c63cf7" translate="yes" xml:space="preserve">
          <source>MakeMaker also honors the MAKE environment variable. This parameter takes precedence.</source>
          <target state="translated">MakeMaker还尊重MAKE环境变量。这个参数优先。</target>
        </trans-unit>
        <trans-unit id="6ce95146fa946e6764eac19b0f7702edb2af3abd" translate="yes" xml:space="preserve">
          <source>MakeMaker can run programs to generate files for you at build time. By default any file named *.PL (except Makefile.PL and Build.PL) in the top level directory will be assumed to be a Perl program and run passing its own basename in as an argument. For example...</source>
          <target state="translated">MakeMaker可以在构建时运行程序为你生成文件。默认情况下,顶层目录下任何名为*.PL的文件(除了Makefile.PL和Build.PL)都会被假定为Perl程序,并通过自己的基名作为参数运行。例如...</target>
        </trans-unit>
        <trans-unit id="f4a59e2381035838e81553acd07a6dbd71a643d2" translate="yes" xml:space="preserve">
          <source>MakeMaker checks for the existence of a file named</source>
          <target state="translated">MakeMaker会检查是否存在一个名为</target>
        </trans-unit>
        <trans-unit id="7e46986c8cad84d029006573feccd2e12b58af53" translate="yes" xml:space="preserve">
          <source>MakeMaker comes with a default MANIFEST.SKIP to avoid things like version control directories and backup files. Specifying your own will override this default.</source>
          <target state="translated">MakeMaker自带一个默认的MANIFEST.SKIP,以避免版本控制目录和备份文件等事情。指定你自己的会覆盖这个默认值。</target>
        </trans-unit>
        <trans-unit id="9177c899e90b4ecb1a9e016234bba13b638eedd6" translate="yes" xml:space="preserve">
          <source>MakeMaker gives you much more freedom than needed to configure internal variables and get different results. It is worth mentioning that make(1) also lets you configure most of the variables that are used in the Makefile. But in the majority of situations this will not be necessary, and should only be done if the author of a package recommends it (or you know what you're doing).</source>
          <target state="translated">MakeMaker给了你比配置内部变量更多的自由度,并得到不同的结果。值得一提的是,make(1)还可以让你配置Makefile中使用的大部分变量。但在大多数情况下,这样做是没有必要的,只有在软件包的作者推荐的情况下(或者你知道自己在做什么)才应该这样做。</target>
        </trans-unit>
        <trans-unit id="666dfa9a2df2803aca52ee89b75129726d38981a" translate="yes" xml:space="preserve">
          <source>MakeMaker modules are installed using this simple mantra</source>
          <target state="translated">使用这个简单的口令安装MakeMaker模块。</target>
        </trans-unit>
        <trans-unit id="6eebe1cd37eee2ec321b36b14411ecc5f97674e6" translate="yes" xml:space="preserve">
          <source>MakeMaker needs to know, or to guess, where certain things are located. Especially INST_LIB and INST_ARCHLIB (where to put the files during the make(1) run), PERL_LIB and PERL_ARCHLIB (where to read existing modules from), and PERL_INC (header files and &lt;code&gt;libperl*.*&lt;/code&gt;).</source>
          <target state="translated">MakeMaker需要知道或猜测某些事物的位置。特别是INST_LIB和INST_ARCHLIB（在运行make（1）时将文件放在哪里），PERL_LIB和PERL_ARCHLIB（从中读取现有模块的地方）以及PERL_INC（头文件和 &lt;code&gt;libperl*.*&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="955e1b765c6718c7db11e68ac1240b76cf36838e" translate="yes" xml:space="preserve">
          <source>MakeMaker will figure out if an extension contains linkable code anywhere down the directory tree, and will set this variable accordingly, but you can speed it up a very little bit if you define this boolean variable yourself.</source>
          <target state="translated">MakeMaker会计算出一个扩展是否包含目录树下任何地方的可链接代码,并会相应地设置这个变量,但如果你自己定义这个布尔变量,可以加快一点速度。</target>
        </trans-unit>
        <trans-unit id="4bbacb6ac277a541e0abc4615218907895ae391a" translate="yes" xml:space="preserve">
          <source>MakeMaker will turn it into an array with one element.</source>
          <target state="translated">MakeMaker会把它变成一个有一个元素的数组。</target>
        </trans-unit>
        <trans-unit id="e6de50a7c31889077966d7620ec5db61a68c67cc" translate="yes" xml:space="preserve">
          <source>MakeMaker.pm uses the architecture-specific information from Config.pm. In addition it evaluates architecture specific hints files in a &lt;code&gt;hints/&lt;/code&gt; directory. The hints files are expected to be named like their counterparts in &lt;code&gt;PERL_SRC/hints&lt;/code&gt; , but with an &lt;code&gt;.pl&lt;/code&gt; file name extension (eg. &lt;code&gt;next_3_2.pl&lt;/code&gt; ). They are simply &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed by MakeMaker within the WriteMakefile() subroutine, and can be used to execute commands as well as to include special variables. The rules which hintsfile is chosen are the same as in Configure.</source>
          <target state="translated">MakeMaker.pm使用Config.pm中特定于体系结构的信息。此外，它还会在 &lt;code&gt;hints/&lt;/code&gt; 目录中评估特定于体系结构的提示文件。提示文件应像在 &lt;code&gt;PERL_SRC/hints&lt;/code&gt; 中的对应文件一样命名，但是文件扩展名为 &lt;code&gt;.pl&lt;/code&gt; （例如 &lt;code&gt;next_3_2.pl&lt;/code&gt; ）。它们只是 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ED由WriteMakefile（）子程序内MakeMaker的，并且可以用来执行命令，以及以包括特殊变量。选择提示文件的规则与&amp;ldquo;配置&amp;rdquo;中的规则相同。</target>
        </trans-unit>
        <trans-unit id="836efb6e25a091dcb4ff8e1dbb2f0be6a5cbf14c" translate="yes" xml:space="preserve">
          <source>Makefile</source>
          <target state="translated">Makefile</target>
        </trans-unit>
        <trans-unit id="a6a4139b0f32af1594c237ebe008acaf8217f505" translate="yes" xml:space="preserve">
          <source>Makefile.PL</source>
          <target state="translated">Makefile.PL</target>
        </trans-unit>
        <trans-unit id="7b63f64a9d58c97e157e981bc21fc3592f84d63a" translate="yes" xml:space="preserve">
          <source>Makefile.SH</source>
          <target state="translated">Makefile.SH</target>
        </trans-unit>
        <trans-unit id="7703506e8273da38efd2a8cfe539dd5151c3f507" translate="yes" xml:space="preserve">
          <source>Makefile.aperl</source>
          <target state="translated">Makefile.aperl</target>
        </trans-unit>
        <trans-unit id="c9fdff62ddc7b582d9333af8bb3618798e22507b" translate="yes" xml:space="preserve">
          <source>Makefile.ce</source>
          <target state="translated">Makefile.ce</target>
        </trans-unit>
        <trans-unit id="f59062c8b44c1bb393273cea0b6483c724adc359" translate="yes" xml:space="preserve">
          <source>Makes LZMA compression a lot slower, but a small compression gain.</source>
          <target state="translated">使得LZMA压缩速度慢了很多,但压缩增益很小。</target>
        </trans-unit>
        <trans-unit id="42141d0e6f7cf55bf1aa53a30a2f72e384ff774e" translate="yes" xml:space="preserve">
          <source>Makes a deep copy of the object.</source>
          <target state="translated">对对象进行深度复制。</target>
        </trans-unit>
        <trans-unit id="1ff909c4c06b83ac514fd30202e92170c2be88e6" translate="yes" xml:space="preserve">
          <source>Makes a distdir first, and runs a &lt;code&gt;perl Makefile.PL&lt;/code&gt; , a make, and a make test in that directory.</source>
          <target state="translated">首先创建一个distdir，然后在该目录中运行 &lt;code&gt;perl Makefile.PL&lt;/code&gt; ，一个make和一个make测试。</target>
        </trans-unit>
        <trans-unit id="0126aa7337111c40fd3d8ee768267099e88c4e18" translate="yes" xml:space="preserve">
          <source>Makes an idhash from the argument, which must be a hash.</source>
          <target state="translated">从参数中产生一个idhash,它必须是一个哈希值。</target>
        </trans-unit>
        <trans-unit id="0c2559af9d3a61aae60ee275b6a01f1105ed29e6" translate="yes" xml:space="preserve">
          <source>Makes files exist, with current timestamp</source>
          <target state="translated">使文件存在,有当前的时间戳。</target>
        </trans-unit>
        <trans-unit id="277c90e53937992c5799a554ef17ea6240ac0378" translate="yes" xml:space="preserve">
          <source>Makes sure at run time that the object file (derived from the &lt;code&gt;.xs&lt;/code&gt; file) and the &lt;code&gt;.pm&lt;/code&gt; files have the same version number. Default is true.</source>
          <target state="translated">确保在运行时目标文件（来自 &lt;code&gt;.xs&lt;/code&gt; 文件）和 &lt;code&gt;.pm&lt;/code&gt; 文件具有相同的版本号。默认为true。</target>
        </trans-unit>
        <trans-unit id="53d81221f3002a7a58139dee2348d32bcaf0b4e5" translate="yes" xml:space="preserve">
          <source>Makes the entry in the table completely ignorable; i.e. as if the weights were zero at all level.</source>
          <target state="translated">使得表中的条目完全可以忽略;即好像各级权重都是零一样。</target>
        </trans-unit>
        <trans-unit id="6ce592c7c5a83ac8509be2294340cdf6b4e97842" translate="yes" xml:space="preserve">
          <source>Makes the thread unjoinable, and causes any eventual return value to be discarded. When the program exits, any detached threads that are still running are silently terminated.</source>
          <target state="translated">使线程无法连接,并导致任何最终的返回值被丢弃。当程序退出时,任何仍在运行的分离线程都会被默默终止。</target>
        </trans-unit>
        <trans-unit id="f1346f72588900d324cb2f158adbed7a88d53077" translate="yes" xml:space="preserve">
          <source>Making</source>
          <target state="translated">Making</target>
        </trans-unit>
        <trans-unit id="c20d8b723d9ceaa1b7e38a56a86d1d8e27a837d5" translate="yes" xml:space="preserve">
          <source>Making Perl on AmigaOS</source>
          <target state="translated">在AmigaOS上制作Perl</target>
        </trans-unit>
        <trans-unit id="4fbad71d4049f75dae54b6a49e4082e7c3867bbe" translate="yes" xml:space="preserve">
          <source>Making References</source>
          <target state="translated">制作参考资料</target>
        </trans-unit>
        <trans-unit id="b3d460b24ff971356f57aa8043b7e5b49b73273b" translate="yes" xml:space="preserve">
          <source>Making a human-readable string out of an address</source>
          <target state="translated">从地址中提取人可读的字符串。</target>
        </trans-unit>
        <trans-unit id="ec8a39930df65d8d70bb72152bc2ebfcb5ef6f12" translate="yes" xml:space="preserve">
          <source>Making a system call for each byte you want to read is not very efficient (to put it mildly) but is the simplest to explain and works reasonably well.</source>
          <target state="translated">为每一个要读取的字节进行系统调用,虽然效率不高(说得轻巧),但却是最简单的解释,而且效果相当好。</target>
        </trans-unit>
        <trans-unit id="6bc23e8c3bea5e39366cc40e690baa6e822bc4b0" translate="yes" xml:space="preserve">
          <source>Making executables with a custom collection of statically loaded extensions</source>
          <target state="translated">使用自定义的静态加载扩展集合制作可执行文件。</target>
        </trans-unit>
        <trans-unit id="cebf6e10212157e6416340db92e3bf9d920a30bf" translate="yes" xml:space="preserve">
          <source>Making executables with a custom search-paths</source>
          <target state="translated">使用自定义搜索路径制作可执行文件。</target>
        </trans-unit>
        <trans-unit id="a0f26bb1828a797c6495fc430a1532f4f3524259" translate="yes" xml:space="preserve">
          <source>Making things worse is that UTF-8 support was a later addition to the regex engine (as it was to perl) and this necessarily made things a lot more complicated. Obviously it is easier to design a regex engine with Unicode support in mind from the beginning than it is to retrofit it to one that wasn't.</source>
          <target state="translated">更糟糕的是,UTF-8支持是后来才加入到regex引擎中的(就像perl一样),这必然使事情变得更加复杂。很明显,从一开始就设计一个支持Unicode的regex引擎要比改造一个不支持Unicode的引擎要容易得多。</target>
        </trans-unit>
        <trans-unit id="bf00c544b1ffc6b4c5073f7dd35eacd07c2aa8d1" translate="yes" xml:space="preserve">
          <source>Making your module threadsafe</source>
          <target state="translated">让你的模块线程安全</target>
        </trans-unit>
        <trans-unit id="24e9d209d23730e356bf6cdf6439fa711205639d" translate="yes" xml:space="preserve">
          <source>Malcolm Beattie, &lt;code&gt;mbeattie@sable.ox.ac.uk&lt;/code&gt;</source>
          <target state="translated">马尔科姆&amp;middot;比蒂（Malcolm Beattie）， &lt;code&gt;mbeattie@sable.ox.ac.uk&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b41df4a623efa0a4562a894886ab9c56b063a3e" translate="yes" xml:space="preserve">
          <source>Malcolm Beattie, &lt;code&gt;mbeattie@sable.ox.ac.uk&lt;/code&gt; Reini Urban &lt;code&gt;rurban@cpan.org&lt;/code&gt;</source>
          <target state="translated">马尔科姆&amp;middot;比蒂（Malcolm Beattie）， &lt;code&gt;mbeattie@sable.ox.ac.uk&lt;/code&gt; Reini Urban &lt;code&gt;rurban@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19631f035a3084a6fe635dc5c4bba7828f7afbd3" translate="yes" xml:space="preserve">
          <source>Malcolm Beattie, mbeattie@sable.ox.ac.uk.</source>
          <target state="translated">Malcolm Beattie,mbeattie@sable.ox.ac.uk。</target>
        </trans-unit>
        <trans-unit id="76d7492febbbbb102be4a6084b9574c6324cf62a" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8</source>
          <target state="translated">畸形的UTF-8</target>
        </trans-unit>
        <trans-unit id="1c0e8bc778fcc6e629304edc324bee00f7f54935" translate="yes" xml:space="preserve">
          <source>Malloc Issues with perl on Solaris.</source>
          <target state="translated">Solaris上perl的Malloc问题。</target>
        </trans-unit>
        <trans-unit id="118d45651d8f268c43f0d79ab0bbae66d29235b4" translate="yes" xml:space="preserve">
          <source>Malloc in Irix</source>
          <target state="translated">Irix中的Malloc</target>
        </trans-unit>
        <trans-unit id="25b61228c020a688cfd6c5a06fa24fca08bfdf7b" translate="yes" xml:space="preserve">
          <source>Manage .packlist files</source>
          <target state="translated">管理.packlist文件</target>
        </trans-unit>
        <trans-unit id="35931f68fb7263b16c5ab46a487b802fec9cd2f9" translate="yes" xml:space="preserve">
          <source>Managing Unknown Symbols</source>
          <target state="translated">管理未知符号</target>
        </trans-unit>
        <trans-unit id="04f195c5450e541e2f347f3f01dadb29f21cee9c" translate="yes" xml:space="preserve">
          <source>Mandatory section; should be a comma-separated list of programs or functions documented by this POD page, such as:</source>
          <target state="translated">必须填写的部分;应该是本POD页面所记录的程序或功能的逗号分隔的列表,例如:</target>
        </trans-unit>
        <trans-unit id="95b5420abf959d7eeb8c5172873e22e522cf809a" translate="yes" xml:space="preserve">
          <source>Manipulate @INC at compile time</source>
          <target state="translated">在编译时操纵@INC</target>
        </trans-unit>
        <trans-unit id="95363fed4c5c92c85bfefb937ad574a5059a5ae7" translate="yes" xml:space="preserve">
          <source>Manipulate Perl symbols and their names</source>
          <target state="translated">操作Perl符号和它们的名称</target>
        </trans-unit>
        <trans-unit id="a8c36443cbda2a6067ad5c937b50ce063c2df504" translate="yes" xml:space="preserve">
          <source>Manipulate threads in Perl (for old code only)</source>
          <target state="translated">在Perl中操纵线程(仅适用于旧代码)</target>
        </trans-unit>
        <trans-unit id="8a33f921aa98603ac2e48c7701dc159e3e29d6c1" translate="yes" xml:space="preserve">
          <source>Manipulating Opsets</source>
          <target state="translated">操纵Opsets</target>
        </trans-unit>
        <trans-unit id="2b13545245f98ef36404c536b49d9995e39a33e1" translate="yes" xml:space="preserve">
          <source>Manpages</source>
          <target state="translated">Manpages</target>
        </trans-unit>
        <trans-unit id="2c5bfd7444f7b80d647fb722cd55c67b0650aba4" translate="yes" xml:space="preserve">
          <source>Manpages for Perl on AmigaOS</source>
          <target state="translated">Manpages for Perl on AmigaOS</target>
        </trans-unit>
        <trans-unit id="d013bfb63d4447b01e40780ba1cecae093576e1b" translate="yes" xml:space="preserve">
          <source>Manual Pages</source>
          <target state="translated">手册页面</target>
        </trans-unit>
        <trans-unit id="9cec485eab07667ef580f14404756c7cdf469fd8" translate="yes" xml:space="preserve">
          <source>Manual binary installation</source>
          <target state="translated">手动二进制安装</target>
        </trans-unit>
        <trans-unit id="572276926686cc7cc3f5283d7ffd30b0fe5dbb1a" translate="yes" xml:space="preserve">
          <source>Manual page indexers are often extremely picky about the format of this section, so don't put anything in it except this line. Every program or function documented by this POD page should be listed, separated by a comma and a space. For a Perl module, just give the module name. A single dash, and only a single dash, should separate the list of programs or functions from the description. Do not use any markup such as C&amp;lt;&amp;gt; or B&amp;lt;&amp;gt; anywhere in this line. Functions should not be qualified with &lt;code&gt;()&lt;/code&gt; or the like. The description should ideally fit on a single line, even if a man program replaces the dash with a few tabs.</source>
          <target state="translated">手动页面索引器通常对本节的格式非常挑剔，因此除此行外，请勿在其中添加任何内容。应该列出此POD页面记录的每个程序或功能，并用逗号和空格分隔。对于Perl模块，只需提供模块名称。单个破折号和仅单个破折号应将程序或功能列表与描述分开。不要在此行中的任何地方使用任何标记，例如C &amp;lt;&amp;gt;或B &amp;lt;&amp;gt;。函数不应使用 &lt;code&gt;()&lt;/code&gt; 等限定。理想情况下，即使手动程序用一些选项卡代替破折号，该描述也应该适合一行。</target>
        </trans-unit>
        <trans-unit id="00b4c0e2070e1a2565707d57c993afbbae4c0c2e" translate="yes" xml:space="preserve">
          <source>Manual: FAQs</source>
          <target state="translated">手册:常见问题</target>
        </trans-unit>
        <trans-unit id="db75f57bcc4f9ed3d56d92896abd677a771bded6" translate="yes" xml:space="preserve">
          <source>Manual: Overview</source>
          <target state="translated">手册。概述</target>
        </trans-unit>
        <trans-unit id="950d94e419183f62360b7a18d309980db9dca27b" translate="yes" xml:space="preserve">
          <source>Manual: Tutorials</source>
          <target state="translated">手册:教程</target>
        </trans-unit>
        <trans-unit id="ac0e5ddc596dea92cba4c0e2c3555f39d4f7c5f0" translate="yes" xml:space="preserve">
          <source>Manually put</source>
          <target state="translated">手动放入</target>
        </trans-unit>
        <trans-unit id="c84207b4c45d8ef84a1d774f5c8bf8efd5fcd50a" translate="yes" xml:space="preserve">
          <source>Many &lt;code&gt;AUTOLOAD&lt;/code&gt; routines load in a definition for the requested subroutine using eval(), then execute that subroutine using a special form of goto() that erases the stack frame of the &lt;code&gt;AUTOLOAD&lt;/code&gt; routine without a trace. (See the source to the standard module documented in &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt;, for example.) But an &lt;code&gt;AUTOLOAD&lt;/code&gt; routine can also just emulate the routine and never define it. For example, let's pretend that a function that wasn't defined should just invoke &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; with those arguments. All you'd do is:</source>
          <target state="translated">许多 &lt;code&gt;AUTOLOAD&lt;/code&gt; 例程使用eval（）来为请求的子例程加载定义，然后使用特殊形式的goto（）执行该子例程，该形式将擦除 &lt;code&gt;AUTOLOAD&lt;/code&gt; 例程的堆栈帧而不会产生任何跟踪。（例如，请参见&lt;a href=&quot;autoloader&quot;&gt;AutoLoader中&lt;/a&gt;记录的标准模块的源代码。）但是， &lt;code&gt;AUTOLOAD&lt;/code&gt; 例程也只能模拟该例程，而不用对其进行定义。例如，让我们假设未定义的函数应仅使用这些参数调用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 。您要做的只是：</target>
        </trans-unit>
        <trans-unit id="077443aca86ab6f4e2738e61b48baa6af4d5929a" translate="yes" xml:space="preserve">
          <source>Many &lt;code&gt;TAP::*&lt;/code&gt; classes have a</source>
          <target state="translated">许多 &lt;code&gt;TAP::*&lt;/code&gt; 类都有一个</target>
        </trans-unit>
        <trans-unit id="d7a6d0011c1051ce0333abc0265080896a481453" translate="yes" xml:space="preserve">
          <source>Many Unicode properties have more than one name (or alias). &lt;code&gt;prop_invmap&lt;/code&gt; understands all of these, including Perl extensions to them. Ambiguities are resolved as described above for &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt;. The Perl internal property &quot;Perl_Decimal_Digit, described below, is also accepted. An empty list is returned if the property name is unknown. See &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;Properties accessible through Unicode::UCD in perluniprops&lt;/a&gt; for the properties acceptable as inputs to this function.</source>
          <target state="translated">许多Unicode属性具有多个名称（或别名）。 &lt;code&gt;prop_invmap&lt;/code&gt; 可以理解所有这些内容，包括对它们的Perl扩展。如上文对&lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases（）&lt;/a&gt;所述解决歧义。还接受下面描述的Perl内部属性&amp;ldquo; Perl_Decimal_Digit。如果属性名称未知，则返回一个空列表。请参见&lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;perluniprops中可通过Unicode :: UCD访问的属性，以获取&lt;/a&gt;可以用作此函数输入的属性。</target>
        </trans-unit>
        <trans-unit id="33c4abda8cada5094d54134f3094015df454f077" translate="yes" xml:space="preserve">
          <source>Many applications contain some Perl code that could be reused.</source>
          <target state="translated">许多应用程序包含一些可以重复使用的Perl代码。</target>
        </trans-unit>
        <trans-unit id="48c7aff02ac4959c101106add7455533fff396df" translate="yes" xml:space="preserve">
          <source>Many built-in functions may be overridden, though this should be tried only occasionally and for good reason. Typically this might be done by a package attempting to emulate missing built-in functionality on a non-Unix system.</source>
          <target state="translated">许多内置的功能可能会被覆盖,尽管这只应该偶尔尝试,并且有充分的理由。一般来说,这可能是由一个试图在非Unix系统上模拟缺失的内置功能的软件包完成的。</target>
        </trans-unit>
        <trans-unit id="294c60617a28cb2d00c28e138e9bdc873720df06" translate="yes" xml:space="preserve">
          <source>Many cases of using &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in a conditional can be written using &lt;code&gt;any&lt;/code&gt; instead, as it can short-circuit after the first true result.</source>
          <target state="translated">在条件中使用 &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 的许多情况都可以用 &lt;code&gt;any&lt;/code&gt; 代替，因为在第一个真实结果之后它可能会短路。</target>
        </trans-unit>
        <trans-unit id="c53c00d79c1b4a5caf2dbf3b1b3871ad968ba47e" translate="yes" xml:space="preserve">
          <source>Many cities around the world have local Perl Mongers chapters. A Perl Mongers chapter is a local user group which typically holds regular in-person meetings, both social and technical; helps organize local conferences, workshops, and hackathons; and provides a mailing list or other continual contact method for its members to keep in touch.</source>
          <target state="translated">世界上许多城市都有当地的 Perl Mongers 分会。Perl Mongers 分会是一个地方性的用户团体,它通常会定期举行社交和技术性的面对面会议;帮助组织地方性的会议、研讨会和黑客运动;并提供一个邮件列表或其他持续的联系方法让其成员保持联系。</target>
        </trans-unit>
        <trans-unit id="1333a5caee67ed3743b1573e310fc69a41dedbcf" translate="yes" xml:space="preserve">
          <source>Many forms are mutually un-intelligible in spoken media. Notable forms: {ar-ae} UAE Arabic; {ar-bh} Bahrain Arabic; {ar-dz} Algerian Arabic; {ar-eg} Egyptian Arabic; {ar-iq} Iraqi Arabic; {ar-jo} Jordanian Arabic; {ar-kw} Kuwait Arabic; {ar-lb} Lebanese Arabic; {ar-ly} Libyan Arabic; {ar-ma} Moroccan Arabic; {ar-om} Omani Arabic; {ar-qa} Qatari Arabic; {ar-sa} Sauda Arabic; {ar-sy} Syrian Arabic; {ar-tn} Tunisian Arabic; {ar-ye} Yemen Arabic.</source>
          <target state="translated">许多形式在口语媒体中是互不相识的。值得注意的形式:{ar-ae}。{ar-ae}阿联酋阿拉伯语;{ar-bh}巴林阿拉伯语;{ar-dz}阿尔及利亚阿拉伯语;{ar-eg}埃及阿拉伯语;{ar-iq}。伊拉克阿拉伯语;{ar-jo}约旦阿拉伯语;{ar-kw}科威特阿拉伯语;{ar-lb}黎巴嫩阿拉伯语;{ar-ly}利比亚阿拉伯语;{ar-ma}摩洛哥阿拉伯语;{ar-om}摩洛哥阿拉伯语。阿曼阿拉伯语;{ar-qa}。卡塔尔阿拉伯语;{ar-sa}。Sauda Arabic;{ar-sy}叙利亚阿拉伯语;{ar-tn}。突尼斯阿拉伯语;{ar-ye}也门阿拉伯语:</target>
        </trans-unit>
        <trans-unit id="22b65de1b1ff16b769feb6a461c534e2b3b49857" translate="yes" xml:space="preserve">
          <source>Many forms are mutually un-intelligible in spoken media. Notable forms: {zh-Hans} Chinese, in simplified script; {zh-Hant} Chinese, in traditional script; {zh-tw} Taiwan Chinese; {zh-cn} PRC Chinese; {zh-sg} Singapore Chinese; {zh-mo} Macau Chinese; {zh-hk} Hong Kong Chinese; {zh-guoyu} Mandarin [Putonghua/Guoyu]; {zh-hakka} Hakka [formerly &quot;i-hakka&quot;]; {zh-min} Hokkien; {zh-min-nan} Southern Hokkien; {zh-wuu} Shanghaiese; {zh-xiang} Hunanese; {zh-gan} Gan; {zh-yue} Cantonese.</source>
          <target state="translated">许多形式在口语媒体中是互不相识的。值得注意的形式:{zh-Hans}中文,简体字;{zh-Hant}中文,简体字。{zh-Hans}中文,简体字;{zh-Hant}。中文,繁体字;{zh-tw}。台湾人;{zh-cn}中国话;{zh-sg}新加坡华人;{zh-mo}澳门话;{zh-hk}香港中文;{zh-guoyu}普通话/国语;{zh-hakka}。客家[原 &quot;i-hakka&quot;];{zh-min}。福建;{zh-min-nan}福建南部;{zh-wuu}上海;{zh-xiang}。匈奴人;{zh-gan}甘;{zh-yue}广东人。</target>
        </trans-unit>
        <trans-unit id="ce036cf5b80f30684cc79c208c3479e5b4b012ed" translate="yes" xml:space="preserve">
          <source>Many good books have been written about Perl--see the section later in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; for more details.</source>
          <target state="translated">关于Perl的许多好书已经写出来了&amp;mdash; 有关更多详细信息，请参见&lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2的&lt;/a&gt;稍后部分。</target>
        </trans-unit>
        <trans-unit id="daec66bc8e44bcc2464b1a0d6c4a9145c9a7595a" translate="yes" xml:space="preserve">
          <source>Many members of the community have a Perl-related blog on this site. If you'd like to join them, you can sign up for free.</source>
          <target state="translated">许多社区成员在这个网站上都有一个与Perl相关的博客,如果你想加入他们,可以免费注册。如果你想加入他们,你可以免费注册。</target>
        </trans-unit>
        <trans-unit id="a71a9a58452bd2f82710c97492e2e55820847a42" translate="yes" xml:space="preserve">
          <source>Many modules are included in the Perl distribution. These are described below, and all end in</source>
          <target state="translated">Perl发行版中包含了许多模块。这些模块将在下面描述,所有模块都以</target>
        </trans-unit>
        <trans-unit id="1f04b4ad6b9470f5a4263506a665427c873dff64" translate="yes" xml:space="preserve">
          <source>Many modules make use of &lt;code&gt;AUTOLOAD&lt;/code&gt; ing for constant subroutines to avoid having to compile and waste memory on rarely used values (see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on constant subroutines). Calls to such constant subroutines are not optimized away at compile time because they can't be checked at compile time for constancy.</source>
          <target state="translated">许多模块对常 &lt;code&gt;AUTOLOAD&lt;/code&gt; 例程使用AUTOLOAD，以避免不得不编译和浪费很少使用的值的内存（有关常&lt;a href=&quot;perlsub&quot;&gt;量子&lt;/a&gt;例程的详细信息，请参见perlsub）。在编译时并不会优化对此类常量子例程的调用，因为无法在编译时检查它们的恒定性。</target>
        </trans-unit>
        <trans-unit id="bd64827a8fe9cbce8371a7bcfdacc99021bfba74" translate="yes" xml:space="preserve">
          <source>Many of Perl's syntactic elements are &lt;b&gt;optional&lt;/b&gt;. Rather than requiring you to put parentheses around every function call and declare every variable, you can often leave such explicit elements off and Perl will figure out what you meant. This is known as &lt;b&gt;Do What I Mean&lt;/b&gt;, abbreviated &lt;b&gt;DWIM&lt;/b&gt;. It allows programmers to be &lt;b&gt;lazy&lt;/b&gt; and to code in a style with which they are comfortable.</source>
          <target state="translated">Perl的许多语法元素都是&lt;b&gt;可选的&lt;/b&gt;。不必要求在每个函数调用前都加上括号并声明每个变量，您通常可以不使用此类显式元素，而Perl会弄清楚您的意思。这被称为&amp;ldquo;按&lt;b&gt;我的意思做&amp;rdquo;&lt;/b&gt;，简称&lt;b&gt;DWIM&lt;/b&gt;。它使程序员可以&lt;b&gt;懒惰，&lt;/b&gt;并以自己喜欢的风格进行编码。</target>
        </trans-unit>
        <trans-unit id="a80a79f26d84c2cb761d54166d1d73c391965f8f" translate="yes" xml:space="preserve">
          <source>Many of the comments in the existing code ignore the possibility of EBCDIC, and may be wrong therefore, even if the code works. This is actually a tribute to the successful transparent insertion of being able to handle EBCDIC without having to change pre-existing code.</source>
          <target state="translated">现有代码中的许多评论忽略了EBCDIC的可能性,因此即使代码有效,也可能是错误的。这实际上是对成功地透明插入能够处理EBCDIC而不必改变现有代码的一种赞誉。</target>
        </trans-unit>
        <trans-unit id="9898a42f1ac737909964257112ee94f7d9cf02b3" translate="yes" xml:space="preserve">
          <source>Many of the examples which follow will concentrate on creating an interface between Perl and the ONC+ RPC bind library functions. The rpcb_gettime() function is used to demonstrate many features of the XS language. This function has two parameters; the first is an input parameter and the second is an output parameter. The function also returns a status value.</source>
          <target state="translated">下面的许多例子将集中在创建Perl和ONC+RPC绑定库函数之间的接口。rpcb_gettime()函数用来演示XS语言的许多特性。这个函数有两个参数,第一个是输入参数,第二个是输出参数。该函数还返回一个状态值。</target>
        </trans-unit>
        <trans-unit id="921520a4912c2671d68673bde14f85005a75001d" translate="yes" xml:space="preserve">
          <source>Many of the functions and methods listed below take a list of operators as parameters. Most operator lists can be made up of several types of element. Each element can be one of</source>
          <target state="translated">下面列出的许多函数和方法都采用运算符列表作为参数。大多数运算符列表可以由几种类型的元素组成。每个元素都可以是以下类型之一</target>
        </trans-unit>
        <trans-unit id="7ce44f55ac189a65855572d397cff0134d70bf83" translate="yes" xml:space="preserve">
          <source>Many of the functions in this module return a Benchmark object, or in the case of &lt;code&gt;timethese()&lt;/code&gt; , a reference to a hash, the values of which are Benchmark objects. This is useful if you want to store or further process results from Benchmark functions.</source>
          <target state="translated">此模块中的许多函数返回Benchmark对象，或者在 &lt;code&gt;timethese()&lt;/code&gt; 的情况下，返回对哈希的引用，该哈希的值是Benchmark对象。如果您要存储或进一步处理基准功能的结果，这将很有用。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
