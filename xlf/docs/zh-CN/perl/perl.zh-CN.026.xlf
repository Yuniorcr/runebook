<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="6dabe892652409d7baaf4ea9766517a9552179bd" translate="yes" xml:space="preserve">
          <source>Here's another simplistic example that illustrates the use of thread signalling in conjunction with a semaphore to provide rudimentary</source>
          <target state="translated">下面是另一个简单的例子,它说明了线程信号与信号体的结合使用,以提供基本的</target>
        </trans-unit>
        <trans-unit id="de1305ff8bab2aad6bcd989ab04908e0dc517958" translate="yes" xml:space="preserve">
          <source>Here's another strategy: Open a pipe to yourself, using &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(MYSELF, &quot;|-&quot;)&lt;/code&gt; (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) and always write() to MYSELF instead of STDOUT. Have your child process massage its STDIN to rearrange headers and footers however you like. Not very convenient, but doable.</source>
          <target state="translated">这是另一种策略：使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(MYSELF, &quot;|-&quot;)&lt;/code&gt; （请参见&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;）打开一条通往自己的管道，并始终将（）写入MYSELF而不是STDOUT。让您的孩子按自己的意愿按摩其STDIN以重新排列页眉和页脚。不是很方便，但是可行。</target>
        </trans-unit>
        <trans-unit id="5ac230c93491a8097772635d05027ee087235965" translate="yes" xml:space="preserve">
          <source>Here's another way to check for sentences in a paragraph:</source>
          <target state="translated">这里还有一种检查段落中句子的方法。</target>
        </trans-unit>
        <trans-unit id="273a17fa15878be17fe206b05c8584be04a69acf" translate="yes" xml:space="preserve">
          <source>Here's another, slightly less painful, way to do it from Benjamin Goldberg, who uses a zero-width negative look-behind assertion.</source>
          <target state="translated">这里还有一种稍微不那么痛苦的方法,来自Benjamin Goldberg,他使用了一个零宽度的负面看后断言。</target>
        </trans-unit>
        <trans-unit id="0cddef9286505d532aaa041e36320e67de4b2c80" translate="yes" xml:space="preserve">
          <source>Here's another; let's compute spherical volumes:</source>
          <target state="translated">这里还有一个,我们来计算球面体积。</target>
        </trans-unit>
        <trans-unit id="15dc729f18ba699bddbeda2935fed34db64f6cdb" translate="yes" xml:space="preserve">
          <source>Here's code that finds everything between START and END in a paragraph:</source>
          <target state="translated">这里的代码可以找到段落中start和end之间的所有内容。</target>
        </trans-unit>
        <trans-unit id="26eff15275e0bc723eda9623b566a21d7d660ee9" translate="yes" xml:space="preserve">
          <source>Here's how a C programmer might code up a particular algorithm in Perl:</source>
          <target state="translated">下面是一个C程序员如何在Perl中编写一个特定算法的代码。</target>
        </trans-unit>
        <trans-unit id="c646f07c7dfa6ee86de30d8e7226eba37cb787f8" translate="yes" xml:space="preserve">
          <source>Here's how to do one operation using a loop. We'll assume an @AoA variable as before.</source>
          <target state="translated">下面是如何使用循环进行一个操作。我们和之前一样假设一个@AoA变量。</target>
        </trans-unit>
        <trans-unit id="268a5d49f5ba74b653796a536ebf6253b796189f" translate="yes" xml:space="preserve">
          <source>Here's how to perform each step for each operating system. This is &amp;lt;not&amp;gt; a substitute for reading the README and INSTALL files that might have come with your module!</source>
          <target state="translated">这是为每个操作系统执行每个步骤的方法。这不是替代读取模块随附的README和INSTALL文件的方法！</target>
        </trans-unit>
        <trans-unit id="f61d7cd6d889dcf489e482c04dbdd66a13cc2eb1" translate="yes" xml:space="preserve">
          <source>Here's how to use &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;\G&lt;/code&gt; :</source>
          <target state="translated">这是在 &lt;code&gt;\G&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="72b07fa8c9ee5cfa969d3c94936ee2dff05c5e76" translate="yes" xml:space="preserve">
          <source>Here's how to use our little example:</source>
          <target state="translated">下面是我们的小例子。</target>
        </trans-unit>
        <trans-unit id="f9a1c6d8d1b1e5ebc9092a952afe3520c4d3df94" translate="yes" xml:space="preserve">
          <source>Here's how we can make the first example safer:</source>
          <target state="translated">下面是我们如何让第一个例子更安全。</target>
        </trans-unit>
        <trans-unit id="1c3c6addf8c05cad39d9f725c53d0c79d67cc1b7" translate="yes" xml:space="preserve">
          <source>Here's how you might write a function that returns a list of keys occurring in all the hashes passed to it:</source>
          <target state="translated">下面是如何编写一个函数,返回所有传递给它的哈希值中出现的键的列表。</target>
        </trans-unit>
        <trans-unit id="ae2023d3bcf8a706017206316be16158eb0a8503" translate="yes" xml:space="preserve">
          <source>Here's how you'd compile the example in the next section, &lt;a href=&quot;#Adding-a-Perl-interpreter-to-your-C-program&quot;&gt;Adding a Perl interpreter to your C program&lt;/a&gt;, on my Linux box:</source>
          <target state="translated">在下一节&amp;ldquo; 在Linux盒子上&lt;a href=&quot;#Adding-a-Perl-interpreter-to-your-C-program&quot;&gt;向C程序中添加Perl解释器&amp;rdquo;中，您将按照&lt;/a&gt;以下方式编译示例：</target>
        </trans-unit>
        <trans-unit id="3c91b848d807e7b04b1ab06ec49ea4392d7ec7d3" translate="yes" xml:space="preserve">
          <source>Here's how, given a vector in &lt;code&gt;$vec&lt;/code&gt; , you can get those bits into your &lt;code&gt;@ints&lt;/code&gt; array:</source>
          <target state="translated">给定 &lt;code&gt;$vec&lt;/code&gt; 的向量，这是如何将这些位放入 &lt;code&gt;@ints&lt;/code&gt; 数组中的方法：</target>
        </trans-unit>
        <trans-unit id="22975b2012514ff308ba25754da36c22aeb6ce2b" translate="yes" xml:space="preserve">
          <source>Here's one strategy: If you have a fixed-size footer, you can get footers by checking $FORMAT_LINES_LEFT before each write() and print the footer yourself if necessary.</source>
          <target state="translated">这里有一个策略。如果你有一个固定大小的页脚,你可以在每次写()之前检查$FORMAT_LINES_LEFT来获取页脚,如果需要的话,你可以自己打印页脚。</target>
        </trans-unit>
        <trans-unit id="525e3062fa27a1689f30b9419dfa2b5e57815b15" translate="yes" xml:space="preserve">
          <source>Here's our &lt;code&gt;File&lt;/code&gt; class once more:</source>
          <target state="translated">这再次是我们的 &lt;code&gt;File&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="b1783e928a570b5dc6d74dafaff14364959e7e0f" translate="yes" xml:space="preserve">
          <source>Here's our &lt;code&gt;File&lt;/code&gt; class with &lt;code&gt;Class::Accessor&lt;/code&gt; :</source>
          <target state="translated">这是我们的带有 &lt;code&gt;Class::Accessor&lt;/code&gt; &lt;code&gt;File&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="57354b9e0e2f7e59368dea0a84947b0e2a0827cd" translate="yes" xml:space="preserve">
          <source>Here's some advice: supply a creation mode of &lt;code&gt;0666&lt;/code&gt; for regular files (in &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;) and one of &lt;code&gt;0777&lt;/code&gt; for directories (in &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt;) and executable files. This gives users the freedom of choice: if they want protected files, they might choose process umasks of &lt;code&gt;022&lt;/code&gt; , &lt;code&gt;027&lt;/code&gt; , or even the particularly antisocial mask of &lt;code&gt;077&lt;/code&gt; . Programs should rarely if ever make policy decisions better left to the user. The exception to this is when writing files that should be kept private: mail files, web browser cookies,</source>
          <target state="translated">这里是一些建议：为常规文件（在 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 中）提供 &lt;code&gt;0666&lt;/code&gt; 的创建模式，为目录（在 &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; 中）和可执行文件提供 &lt;code&gt;0777&lt;/code&gt; 的创建模式。这为用户提供了选择的自由：如果他们想要保护的文件，他们可能会选择的过程中使用umasks &lt;code&gt;022&lt;/code&gt; ， &lt;code&gt;027&lt;/code&gt; ，甚至反社会特别的面具 &lt;code&gt;077&lt;/code&gt; 。程序很少应该做出让用户更好地决策的决定。例外情况是在编写应保密的文件时：邮件文件，网络浏览器Cookie，</target>
        </trans-unit>
        <trans-unit id="e2752daa5f028f44257bc9623ea0f7f9230b9d85" translate="yes" xml:space="preserve">
          <source>Here's some advice: supply a creation mode of &lt;code&gt;0666&lt;/code&gt; for regular files (in &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;) and one of &lt;code&gt;0777&lt;/code&gt; for directories (in &lt;code&gt;&lt;a href=&quot;mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt;) and executable files. This gives users the freedom of choice: if they want protected files, they might choose process umasks of &lt;code&gt;022&lt;/code&gt; , &lt;code&gt;027&lt;/code&gt; , or even the particularly antisocial mask of &lt;code&gt;077&lt;/code&gt; . Programs should rarely if ever make policy decisions better left to the user. The exception to this is when writing files that should be kept private: mail files, web browser cookies,</source>
          <target state="translated">这里是一些建议：为常规文件（在 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 中）提供 &lt;code&gt;0666&lt;/code&gt; 的创建模式，为目录（在 &lt;code&gt;&lt;a href=&quot;mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; 中）和可执行文件提供 &lt;code&gt;0777&lt;/code&gt; 的创建模式。这为用户提供了选择的自由：如果他们想要保护的文件，他们可能会选择的过程中使用umasks &lt;code&gt;022&lt;/code&gt; ， &lt;code&gt;027&lt;/code&gt; ，甚至反社会特别的面具 &lt;code&gt;077&lt;/code&gt; 。程序很少应该做出让用户更好地决策的决定。例外情况是在编写应保密的文件时：邮件文件，网络浏览器Cookie，</target>
        </trans-unit>
        <trans-unit id="4ed39bdc449f7cf4b3c38e3ffdf7cd70fa08f940" translate="yes" xml:space="preserve">
          <source>Here's some code that finds sentences that begin with &quot;From &quot; (which would be mangled by many mailers):</source>
          <target state="translated">这里有一些代码可以找到以 &quot;From &quot;开头的句子(很多邮件会把这些句子弄乱)。</target>
        </trans-unit>
        <trans-unit id="aa42825d4fc178008e13f884fd63afc0d6bcd50d" translate="yes" xml:space="preserve">
          <source>Here's some entries from the output of the property &quot;Nv&quot;, which has format &lt;code&gt;&quot;ar&quot;&lt;/code&gt; .</source>
          <target state="translated">这是属性&amp;ldquo; Nv&amp;rdquo;的输出的一些条目，其格式为 &lt;code&gt;&quot;ar&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="983afceb3200f14ad7cf769e6f457a540b745124" translate="yes" xml:space="preserve">
          <source>Here's some more recommendations</source>
          <target state="translated">下面再给大家推荐一下</target>
        </trans-unit>
        <trans-unit id="425356b04c5e4659def26c3afe717def29a81e4c" translate="yes" xml:space="preserve">
          <source>Here's something Larry suggested: if a &lt;code&gt;U&lt;/code&gt; is the first active format during a &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, (for example, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; &quot;U3C8&quot;, @stuff&lt;/code&gt; ) then the resulting string should be treated as UTF-8 encoded.</source>
          <target state="translated">这是Larry建议的：如果 &lt;code&gt;U&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 期间的第一个活动格式（例如 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; &quot;U3C8&quot;, @stuff&lt;/code&gt; ），那么结果字符串应视为UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="b314a6f828aa6ba79d336b2bc1f9e451bb9826c7" translate="yes" xml:space="preserve">
          <source>Here's that program; tested on v5.14.</source>
          <target state="translated">这就是那个程序;在v5.14上测试。</target>
        </trans-unit>
        <trans-unit id="7c1fe856f88363dd186e2e7ada6054be89d9b374" translate="yes" xml:space="preserve">
          <source>Here's the answer to the problem I posed earlier, of reformatting a file of city and country names.</source>
          <target state="translated">这是我前面提出的问题的答案,即重新格式化一个城市和国家名称的文件。</target>
        </trans-unit>
        <trans-unit id="ec2064253b0b50a2575cd193f528ea54b5bba134" translate="yes" xml:space="preserve">
          <source>Here's the case of taking a reference to the same memory location again and again:</source>
          <target state="translated">这里的情况是,一次又一次地对同一个内存位置进行引用。</target>
        </trans-unit>
        <trans-unit id="687ec9bc2da6b7d16d8a23c230dfb7c1307404b0" translate="yes" xml:space="preserve">
          <source>Here's the code. We'll</source>
          <target state="translated">这是代码。我们将</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">这是代码。</target>
        </trans-unit>
        <trans-unit id="92d590121c2fc19f8a6623b373db411150058833" translate="yes" xml:space="preserve">
          <source>Here's the constructor:</source>
          <target state="translated">这是构造函数。</target>
        </trans-unit>
        <trans-unit id="67de0300ad7e657a8db469b4cb89cf11ed0c9b15" translate="yes" xml:space="preserve">
          <source>Here's the fetch for our DotFiles example.</source>
          <target state="translated">下面是我们的DotFiles例子的获取方法。</target>
        </trans-unit>
        <trans-unit id="ea37c8a435a5d1ae861daa3601c34204e044ad1a" translate="yes" xml:space="preserve">
          <source>Here's the general rule: When you approach a task commonly done using a whole range of platforms, think about writing portable code. That way, you don't sacrifice much by way of the implementation choices you can avail yourself of, and at the same time you can give your users lots of platform choices. On the other hand, when you have to take advantage of some unique feature of a particular platform, as is often the case with systems programming (whether for Unix, Windows, VMS, etc.), consider writing platform-specific code.</source>
          <target state="translated">这是一般规则。当你接近一个使用各种平台完成的任务时,要考虑编写可移植的代码。这样一来,你不会因为可以利用的实现选择而牺牲很多,同时你也可以给你的用户提供很多平台选择。另一方面,当你必须利用某个特定平台的一些独特功能时,就像系统编程中经常出现的情况一样(无论是Unix、Windows、VMS等),考虑编写特定平台的代码。</target>
        </trans-unit>
        <trans-unit id="b5763f4294d53b8fde1e0d145ff3e1ebda9932aa" translate="yes" xml:space="preserve">
          <source>Here's the start of</source>
          <target state="translated">这里是开始</target>
        </trans-unit>
        <trans-unit id="62dfcd0f3177b39de6db7b0fd66738d0abd59908" translate="yes" xml:space="preserve">
          <source>Here's two outputs (or 'renderings'), using the -exec and -basic (i.e. default) formatting conventions on the same code snippet.</source>
          <target state="translated">这是两个输出(或 &quot;渲染&quot;),使用-exec和-basic(即默认)格式约定在同一个代码片段上。</target>
        </trans-unit>
        <trans-unit id="b7e6198c27f03baf5a7cf4c101c7cbf2083f6919" translate="yes" xml:space="preserve">
          <source>Here's what happens: when Perl reads in a string literal, it sticks to 8 bit encoding as long as it can. (But perhaps originally it was internally encoded as UTF-8, when you dumped it.) When it has to give that up because other characters are added to the text string, it silently upgrades the string to UTF-8.</source>
          <target state="translated">事情是这样的:当Perl读入一个字符串文字时,它尽可能地坚持使用8位编码(但也许最初它的内部编码是UTF-8,当你转储它时)。(但也许最初它的内部编码是UTF-8,当你转储它的时候)。当它不得不放弃这一点时,因为其他字符被添加到文本字符串中,它就会默默地将字符串升级为 UTF-8。</target>
        </trans-unit>
        <trans-unit id="3d080817ae211b70ffb8548327b1435f255163a6" translate="yes" xml:space="preserve">
          <source>Here,</source>
          <target state="translated">Here,</target>
        </trans-unit>
        <trans-unit id="664fb069ea88b967ad1512f692644a45d6f7de10" translate="yes" xml:space="preserve">
          <source>Here, &quot;=head1 Foo&quot; and &quot;=cut&quot; are command paragraphs because the first line of each matches &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt;. &quot;</source>
          <target state="translated">这里，&amp;ldquo; = head1 Foo&amp;rdquo;和&amp;ldquo; = cut&amp;rdquo;是命令段落，因为每个的第一行都匹配 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0b2d91e5d5873ea3e50cabcf6bf495277d88e43b" translate="yes" xml:space="preserve">
          <source>Here, $subroutine is the function that the caller called (rather than the function containing the caller). Note that $subroutine may be &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; if the frame is not a subroutine call, but an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. In such a case additional elements $evaltext and &lt;code&gt;$is_require&lt;/code&gt; are set: &lt;code&gt;$is_require&lt;/code&gt; is true if the frame is created by a &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, $evaltext contains the text of the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; statement. In particular, for an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; statement, $subroutine is &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; , but $evaltext is undefined. (Note also that each &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement creates a &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame inside an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; frame.) $subroutine may also be &lt;code&gt;(unknown)&lt;/code&gt; if this particular subroutine happens to have been deleted from the symbol table. &lt;code&gt;$hasargs&lt;/code&gt; is true if a new instance of &lt;code&gt;@_&lt;/code&gt; was set up for the frame. &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; contain pragmatic hints that the caller was compiled with. &lt;code&gt;$hints&lt;/code&gt; corresponds to &lt;code&gt;$^H&lt;/code&gt; , and &lt;code&gt;$bitmask&lt;/code&gt; corresponds to &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; . The &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; values are subject to change between versions of Perl, and are not meant for external use.</source>
          <target state="translated">在这里，$ subroutine是调用者调用的函数（而不是包含调用者的函数）。请注意，如果框架不是子例程调用，而是 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，则$ subroutine可能是 &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; 。在这种情况下，将设置其他元素$ evaltext和 &lt;code&gt;$is_require&lt;/code&gt; ：如果框架是由 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句创建的，则 &lt;code&gt;$is_require&lt;/code&gt; 为true ，$ evaltext包含 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; EXPR语句的文本。特别是，对于 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; BLOCK语句，$ subroutine是 &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;），但是$ evaltext是未定义的。 （请注意，每次 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句在 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; EXPR框架内创建一个 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 框架。 &lt;code&gt;(unknown)&lt;/code&gt; 如果此子例程恰好已从符号表中删除，则$ subroutine也可能是（未知）。如果为框架设置了新的 &lt;code&gt;@_&lt;/code&gt; 实例，则 &lt;code&gt;$hasargs&lt;/code&gt; 为true 。 &lt;code&gt;$hints&lt;/code&gt; 和 &lt;code&gt;$bitmask&lt;/code&gt; 包含调用者编译时的实用提示。 &lt;code&gt;$hints&lt;/code&gt; 对应于 &lt;code&gt;$^H&lt;/code&gt; ， &lt;code&gt;$bitmask&lt;/code&gt; 对应于 &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; 。在 &lt;code&gt;$hints&lt;/code&gt; 和 &lt;code&gt;$bitmask&lt;/code&gt; 值在Perl版本之间可能会发生变化，并不表示供外部使用。</target>
        </trans-unit>
        <trans-unit id="0cf857d30373eeccb44d9f659b21b0118b696cbc" translate="yes" xml:space="preserve">
          <source>Here, $subroutine is the function that the caller called (rather than the function containing the caller). Note that $subroutine may be &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; if the frame is not a subroutine call, but an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. In such a case additional elements $evaltext and &lt;code&gt;$is_require&lt;/code&gt; are set: &lt;code&gt;$is_require&lt;/code&gt; is true if the frame is created by a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, $evaltext contains the text of the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; statement. In particular, for an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; statement, $subroutine is &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; , but $evaltext is undefined. (Note also that each &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement creates a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; frame.) $subroutine may also be &lt;code&gt;(unknown)&lt;/code&gt; if this particular subroutine happens to have been deleted from the symbol table. &lt;code&gt;$hasargs&lt;/code&gt; is true if a new instance of &lt;code&gt;@_&lt;/code&gt; was set up for the frame. &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; contain pragmatic hints that the caller was compiled with. &lt;code&gt;$hints&lt;/code&gt; corresponds to &lt;code&gt;$^H&lt;/code&gt; , and &lt;code&gt;$bitmask&lt;/code&gt; corresponds to &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; . The &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; values are subject to change between versions of Perl, and are not meant for external use.</source>
          <target state="translated">在这里，$ subroutine是调用者调用的函数（而不是包含调用者的函数）。请注意，如果框架不是子例程调用，而是 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，则$ subroutine可能是 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; 。在这种情况下，将设置其他元素$ evaltext和 &lt;code&gt;$is_require&lt;/code&gt; ：如果框架是由 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句创建的，则 &lt;code&gt;$is_require&lt;/code&gt; 为true ，$ evaltext包含 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; EXPR语句的文本。特别是，对于 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; BLOCK语句，$ subroutine是 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;），但是$ evaltext是未定义的。 （请注意，每次 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; EXPR框架内创建一个 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 框架。 &lt;code&gt;(unknown)&lt;/code&gt; 如果此子例程恰好已从符号表中删除，则$ subroutine也可能是（未知）。如果为框架设置了新的 &lt;code&gt;@_&lt;/code&gt; 实例，则 &lt;code&gt;$hasargs&lt;/code&gt; 为true 。 &lt;code&gt;$hints&lt;/code&gt; 和 &lt;code&gt;$bitmask&lt;/code&gt; 包含调用者编译时的实用提示。 &lt;code&gt;$hints&lt;/code&gt; 对应于 &lt;code&gt;$^H&lt;/code&gt; ， &lt;code&gt;$bitmask&lt;/code&gt; 对应于 &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; 。在 &lt;code&gt;$hints&lt;/code&gt; 和 &lt;code&gt;$bitmask&lt;/code&gt; 值在Perl版本之间可能会发生变化，并不表示供外部使用。</target>
        </trans-unit>
        <trans-unit id="caa26f85e260be75edcd0346a364ee2896d298ec" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(?&amp;gt;[^()]+)&lt;/code&gt; breaks the degeneracy of string partitioning by gobbling up as much of the string as possible and keeping it. Then match failures fail much more quickly.</source>
          <target state="translated">在这里， &lt;code&gt;(?&amp;gt;[^()]+)&lt;/code&gt; 通过尽可能多地吞噬并保留字符串来打破字符串分区的退化性。然后，匹配失败会更快地失败。</target>
        </trans-unit>
        <trans-unit id="a1b989b57eb518dccad89ad922a4fe2c3b8290b8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;.?&lt;/code&gt; eats its maximal one character at the earliest possible position in the string, &lt;code&gt;'a'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; , leaving &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; the opportunity to match both &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;'s. Finally,</source>
          <target state="translated">在这里 &lt;code&gt;.?&lt;/code&gt; 在 &lt;code&gt;programming&lt;/code&gt; 的字符串 &lt;code&gt;'a'&lt;/code&gt; 的最早位置处吃了最大的一个字符，从而使 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; 有机会匹配两个 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 。最后，</target>
        </trans-unit>
        <trans-unit id="a4a0735ee9beb6f441c46c7bd92351e785038614" translate="yes" xml:space="preserve">
          <source>Here, The earliest possible match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; is the first quantifier, so it gets to match a maximal &lt;code&gt;mm&lt;/code&gt; .</source>
          <target state="translated">这里，最早的可能的匹配是在第一 &lt;code&gt;'m'&lt;/code&gt; 中 &lt;code&gt;programming&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; 是第一个量词，因此它可以匹配最大 &lt;code&gt;mm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3716a6d294692219d3cd1801d8d99a5dbba94e08" translate="yes" xml:space="preserve">
          <source>Here, all the alternatives match at the first string position, so the first alternative is the one that matches. If some of the alternatives are truncations of the others, put the longest ones first to give them a chance to match.</source>
          <target state="translated">在这里,所有的备选方案都在第一个字符串位置匹配,所以第一个备选方案就是匹配的方案。如果有些选项是其他选项的截断,则把最长的选项放在前面,使它们有机会匹配。</target>
        </trans-unit>
        <trans-unit id="689480ae64fc1f47a0a934be3391ff1dd20b6f51" translate="yes" xml:space="preserve">
          <source>Here, code is written for all the currently linked extensions along with code for &lt;code&gt;DBI&lt;/code&gt; and &lt;code&gt;DBD::Oracle&lt;/code&gt; .</source>
          <target state="translated">在这里，将为所有当前链接的扩展编写代码，并为 &lt;code&gt;DBI&lt;/code&gt; 和 &lt;code&gt;DBD::Oracle&lt;/code&gt; 编写代码。</target>
        </trans-unit>
        <trans-unit id="6aaaa9a188728345ceda0023a2930141166a0d68" translate="yes" xml:space="preserve">
          <source>Here, the code points 0x964 and 0x965 are both used in Bengali, Devanagari, Gurmukhi, and Oriya, but no other scripts.</source>
          <target state="translated">这里,代码点0x964和0x965都用于孟加拉语、Devanagari、Gurmukhi和Oriya,但没有其他脚本。</target>
        </trans-unit>
        <trans-unit id="c6406af5e03eb4f4938f3da32dd26a4c74c548ed" translate="yes" xml:space="preserve">
          <source>Here, the regexp matches at the start of the string. The first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much as possible, leaving just a single &lt;code&gt;'m'&lt;/code&gt; for the second quantifier &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此处，正则表达式在字符串的开头匹配。第一个量词 &lt;code&gt;.*&lt;/code&gt; 尽可能地抓住，而第二个量词 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; 只留下一个 &lt;code&gt;'m'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d40285a9c3c8ccdbd6762112a10bef59352519d" translate="yes" xml:space="preserve">
          <source>Here, when the '$a' in the eval is being compiled, f() is not currently being executed, so its $a is not available for capture.</source>
          <target state="translated">在这里,当eval中的'$a'被编译时,f()当前并没有被执行,所以它的$a无法被捕获。</target>
        </trans-unit>
        <trans-unit id="dd7c1c3b995f345fd62ac66cfeb3e09d91946309" translate="yes" xml:space="preserve">
          <source>Here, when the '\&amp;amp;a' in the eval is being compiled, f() is not currently being executed, so its &amp;amp;a is not available for capture.</source>
          <target state="translated">在这里，当评估eval中的'\＆a'时，当前未执行f（），因此其＆a无法捕获。</target>
        </trans-unit>
        <trans-unit id="ede19d3c74e6b3a68c4bd3de5c03f1c72f2ba22c" translate="yes" xml:space="preserve">
          <source>Hex strings may only represent integers. Strings that would cause integer overflow trigger a warning. Leading whitespace is not stripped, unlike oct(). To present something as hex, look into &lt;a href=&quot;#printf&quot;&gt;printf&lt;/a&gt;, &lt;a href=&quot;#sprintf&quot;&gt;sprintf&lt;/a&gt;, and &lt;a href=&quot;#unpack&quot;&gt;unpack&lt;/a&gt;.</source>
          <target state="translated">十六进制字符串只能代表整数。可能导致整数溢出的字符串会触发警告。与oct（）不同，前导空格不会被剥离。要以十六进制形式显示内容，请查看&lt;a href=&quot;#printf&quot;&gt;printf&lt;/a&gt;，&lt;a href=&quot;#sprintf&quot;&gt;sprintf&lt;/a&gt;和&lt;a href=&quot;#unpack&quot;&gt;unpack&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4ab04b2f53a36bbb2dc5c2deb103b3c069c62c2" translate="yes" xml:space="preserve">
          <source>Hex strings may only represent integers. Strings that would cause integer overflow trigger a warning. Leading whitespace is not stripped, unlike oct(). To present something as hex, look into &lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;, &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;, and &lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;.</source>
          <target state="translated">十六进制字符串只能代表整数。可能导致整数溢出的字符串会触发警告。与oct（）不同，前导空格不会被剥离。要以十六进制形式显示内容，请查看&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;，&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;和&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f63676066d11c05b5d8b9b8be78e1e17f582eed6" translate="yes" xml:space="preserve">
          <source>Hexadecimal (prefixed with &quot;0x&quot;) and binary numbers (prefixed with &quot;0b&quot;) are accepted, too. Please note that octal numbers are not recognized by new(), so the following will print &quot;123&quot;:</source>
          <target state="translated">十六进制数(前缀为 &quot;0x&quot;)和二进制数(前缀为 &quot;0b&quot;)也被接受。请注意,new()不能识别八进制数,所以下面将打印 &quot;123&quot;。</target>
        </trans-unit>
        <trans-unit id="2486d235457d8e2812e9f4481543bdfa3dc85c5e" translate="yes" xml:space="preserve">
          <source>Hexadecimal Notation</source>
          <target state="translated">十六进制符号</target>
        </trans-unit>
        <trans-unit id="d754dce244e30fbc42722c0d0d3408fc0e8b5ff5" translate="yes" xml:space="preserve">
          <source>Hexadecimal escapes</source>
          <target state="translated">十六进制泄漏</target>
        </trans-unit>
        <trans-unit id="0055aac53ab95723749bf6b5bb8f9b5857c75d3e" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating point can start just like a hexadecimal literal, and it can be followed by an optional fractional hexadecimal part, but it must be followed by &lt;code&gt;p&lt;/code&gt; , an optional sign, and a power of two. The format is useful for accurately presenting floating point values, avoiding conversions to or from decimal floating point, and therefore avoiding possible loss in precision. Notice that while most current platforms use the 64-bit IEEE 754 floating point, not all do. Another potential source of (low-order) differences are the floating point rounding modes, which can differ between CPUs, operating systems, and compilers, and which Perl doesn't control.</source>
          <target state="translated">十六进制浮点可以像十六进制文字一样开始，并且可以跟一个可选的分数十六进制部分，但必须跟一个 &lt;code&gt;p&lt;/code&gt; ，一个可选符号以及2的幂。该格式对于准确显示浮点值，避免转换为十进制浮点数或从十进制浮点数进行转换非常有用，因此可以避免精度损失。请注意，尽管大多数当前平台都使用64位IEEE 754浮点，但并非所有平台都使用。另一个（低阶）差异的潜在来源是浮点舍入模式，该模式在CPU，操作系统和编译器之间可能会有所不同，而Perl无法控制这种模式。</target>
        </trans-unit>
        <trans-unit id="c5f839007ffa6c33e78ea32b2edbfe75db988fef" translate="yes" xml:space="preserve">
          <source>Hexadecimal, octal, or binary, representations in string literals (e.g. '0xff') are not automatically converted to their integer representation. The hex() and oct() functions make these conversions for you. See &lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt; and &lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt; for more details.</source>
          <target state="translated">字符串文字中的十六进制，八进制或二进制表示（例如&amp;ldquo; 0xff&amp;rdquo;）不会自动转换为整数表示。hex（）和oct（）函数为您进行了这些转换。有关更多详细信息，请参见&lt;a href=&quot;functions/hex&quot;&gt;十六进制&lt;/a&gt;和&lt;a href=&quot;functions/oct&quot;&gt;十进制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af0d47fb48d369e779ea66f99b77ac3ba09d56e3" translate="yes" xml:space="preserve">
          <source>Hey, isn't Perl supposed to make this sort of thing easy? Well, it does, if you use the right tools. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; are designed to help you out when dealing with fixed-width data like the above. Let's have a look at a solution with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">嘿，不是应该让Perl简化这种事情吗？好的，如果您使用正确的工具，那就可以了。 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 旨在帮助您处理上述固定宽度的数据。让我们看一下 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 的解决方案：</target>
        </trans-unit>
        <trans-unit id="38419124bd7b06ea4fc82f2ec5707cd4239617e6" translate="yes" xml:space="preserve">
          <source>Hiding Perl_</source>
          <target state="translated">隱藏Perl_</target>
        </trans-unit>
        <trans-unit id="1428b1718a9c369e65d9d918143e0a1d8ca542e9" translate="yes" xml:space="preserve">
          <source>Hiding or invalidating some other definition of the same name. (Not to be confused with &lt;b&gt;overloading&lt;/b&gt;, which adds definitions that must be disambiguated some other way.) To confuse the issue further, we use the word with two overloaded definitions: to describe how you can define your own &lt;b&gt;subroutine&lt;/b&gt; to hide a built-in &lt;b&gt;function&lt;/b&gt; of the same name (see the section &amp;ldquo;Overriding Built-in Functions&amp;rdquo; in Camel chapter 11, &amp;ldquo;Modules&amp;rdquo;), and to describe how you can define a replacement &lt;b&gt;method&lt;/b&gt; in a &lt;b&gt;derived class&lt;/b&gt; to hide a &lt;b&gt;base class&lt;/b&gt;&amp;rsquo;s method of the same name (see Camel chapter 12, &amp;ldquo;Objects&amp;rdquo;).</source>
          <target state="translated">隐藏或使其他相同名称的定义无效。（不要与&lt;b&gt;重载&lt;/b&gt;相混淆，&lt;b&gt;重载&lt;/b&gt;会增加必须以其他方式消除歧义的定义。）为了进一步混淆这个问题，我们使用带有两个重载定义的单词：描述如何定义自己的&lt;b&gt;子例程&lt;/b&gt;来隐藏内置函数。&lt;b&gt;具有&lt;/b&gt;相同名称的&lt;b&gt;函数&lt;/b&gt;（请参见Camel第11章&amp;ldquo;模块&amp;rdquo;中的&amp;ldquo;覆盖内置函数&amp;rdquo;一节），并描述如何在&lt;b&gt;派生类中&lt;/b&gt;定义替换&lt;b&gt;方法&lt;/b&gt;以隐藏&lt;b&gt;基类&lt;/b&gt;的方法。名称相同（请参见骆驼第12章，&amp;ldquo;对象&amp;rdquo;）。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c470287cb379da96c293a62fb8664cf2247d2b55" translate="yes" xml:space="preserve">
          <source>High Level</source>
          <target state="translated">高级别</target>
        </trans-unit>
        <trans-unit id="ad6c175822059b79229ebfc786ac972d1cc9dd61" translate="yes" xml:space="preserve">
          <source>High resolution alarm, sleep, gettimeofday, interval timers</source>
          <target state="translated">高分辨率闹钟、睡眠、gettimeofday、间隔定时器</target>
        </trans-unit>
        <trans-unit id="06ec56d2d4a59020901e32260159cfaa9fcc9ac8" translate="yes" xml:space="preserve">
          <source>High-level commands do such initializations automatically.</source>
          <target state="translated">高层命令会自动进行这种初始化。</target>
        </trans-unit>
        <trans-unit id="e29ea1646e3ae3268842b4efea0250df490ad525" translate="yes" xml:space="preserve">
          <source>Higher-Order Perl</source>
          <target state="translated">高阶Perl</target>
        </trans-unit>
        <trans-unit id="2f40e6c9a09885ca0cf7997c2375c0fe1fb31d9f" translate="yes" xml:space="preserve">
          <source>Hint: The &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; tutorial covers the T_INOUT, T_IN, and T_OUT XS types nicely.</source>
          <target state="translated">提示：&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;教程很好地介绍了T_INOUT，T_IN和T_OUT XS类型。</target>
        </trans-unit>
        <trans-unit id="e3d4d7c7e48bee9d90099bb119b39917c09def77" translate="yes" xml:space="preserve">
          <source>Hint: sometimes appending &lt;code&gt;&quot;, stopped&quot;&lt;/code&gt; to your message will cause it to make better sense when the string &lt;code&gt;&quot;at foo line 123&quot;&lt;/code&gt; is appended. Suppose you are running script &quot;canasta&quot;.</source>
          <target state="translated">提示：有时在消息中附加 &lt;code&gt;&quot;, stopped&quot;&lt;/code&gt; 会在附加字符串 &lt;code&gt;&quot;at foo line 123&quot;&lt;/code&gt; 时更有意义。假设您正在运行脚本&amp;ldquo; canasta&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2e7ad51592f12093f07f504091e6b4574d36b5ff" translate="yes" xml:space="preserve">
          <source>Hints for Writing Pod</source>
          <target state="translated">撰写播客的提示</target>
        </trans-unit>
        <trans-unit id="cd94510567b2e65da4d128c15c97d4b8bf6c814e" translate="yes" xml:space="preserve">
          <source>Hintsfile support</source>
          <target state="translated">支持Hints文件</target>
        </trans-unit>
        <trans-unit id="57ec96f40e52a96bf96bf4e1bcab6928fd860e76" translate="yes" xml:space="preserve">
          <source>Historical note: A few older Pod processors would not see a &quot;&amp;gt;&quot; as closing a &quot;C&amp;lt;&quot; code, if the &quot;&amp;gt;&quot; was immediately preceded by a &quot;-&quot;. This was so that this:</source>
          <target state="translated">历史记录：如果&amp;ldquo;&amp;gt;&amp;rdquo;前面紧跟一个&amp;ldquo;-&amp;rdquo;，则一些较旧的Pod处理器不会在关闭&amp;ldquo; C &amp;lt;&amp;rdquo;代码时看到&amp;ldquo;&amp;gt;&amp;rdquo;。这样做是这样的：</target>
        </trans-unit>
        <trans-unit id="456da061b07638f2efc60c23c53fa3c2c51535e7" translate="yes" xml:space="preserve">
          <source>Historical notes: 'die' used to be the default value of &lt;code&gt;$huge&lt;/code&gt; . Now, 'wrap' is the default value.</source>
          <target state="translated">历史记录：'die'曾经是 &lt;code&gt;$huge&lt;/code&gt; 的默认值。现在，&amp;ldquo; wrap&amp;rdquo;是默认值。</target>
        </trans-unit>
        <trans-unit id="a4bea0d3c8dc12ea86900e60a2460f211b081d43" translate="yes" xml:space="preserve">
          <source>Historically, any software that you give away, particularly if you make the source code available as well. Now often called &lt;b&gt;open source software&lt;/b&gt;. Recently there has been a trend to use the term in contradistinction to &lt;b&gt;open source software&lt;/b&gt;, to refer only to free software released under the Free Software Foundation&amp;rsquo;s GPL (General Public License), but this is difficult to justify etymologically.</source>
          <target state="translated">从历史上看，您赠送的任何软件，尤其是在您也提供源代码的情况下。现在经常被称为&lt;b&gt;开源软件&lt;/b&gt;。最近，有一种趋势是使用矛盾的术语来表示&lt;b&gt;开源软件&lt;/b&gt;，仅指在自由软件基金会的GPL（通用公共许可）下发布的自由软件，但这在词源上很难证明。</target>
        </trans-unit>
        <trans-unit id="97391b474b93a4ff5ad2004bc1c3d103a9fb4d4e" translate="yes" xml:space="preserve">
          <source>Historically, only the pumpking cherry-picked changes from bleadperl into maintperl. This has scaling problems. At the same time, maintenance branches of stable versions of Perl need to be treated with great care. To that end, as of Perl 5.12, we have a new process for maint branches.</source>
          <target state="translated">历史上,只有南瓜挑剔的从bleadperl改成maintperl。这存在着扩展问题。同时,Perl稳定版本的维护分支需要非常谨慎地对待。为此,从Perl 5.12开始,我们对maint分支进行了新的处理。</target>
        </trans-unit>
        <trans-unit id="a70077bc9082a3c8ea160dc01f918a3a65a6e212" translate="yes" xml:space="preserve">
          <source>Historically, these would be generated by the &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; tool, part of the standard perl distribution. This program converts &lt;code&gt;cpp(1)&lt;/code&gt; directives in C header files to files containing subroutine definitions, like &lt;code&gt;SYS_getitimer()&lt;/code&gt; , which you can use as arguments to your functions. It doesn't work perfectly, but it usually gets most of the job done. Simple files like</source>
          <target state="translated">从历史上看，这些将由&lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt;工具生成，它是标准perl发行版的一部分。该程序将C头文件中的 &lt;code&gt;cpp(1)&lt;/code&gt; 指令转换为包含子例程定义的文件，例如 &lt;code&gt;SYS_getitimer()&lt;/code&gt; ，您可以将其用作函数的参数。它不能完美运行，但通常可以完成大部分工作。像这样的简单文件</target>
        </trans-unit>
        <trans-unit id="723525aec4e05b078bfa1f7212775fddba5a19b2" translate="yes" xml:space="preserve">
          <source>Historically, we've held ourselves to a far higher standard than backward-compatibility -- bugward-compatibility. Any accident of implementation or unintentional side-effect of running some bit of code has been considered to be a feature of the language to be defended with the same zeal as any other feature or functionality. No matter how frustrating these unintentional features may be to us as we continue to improve Perl, these unintentional features often deserve our protection. It is very important that existing software written in Perl continue to work correctly. If end-user developers have adopted a bug as a feature, we need to treat it as such.</source>
          <target state="translated">从历史上看,我们对自己的要求比向后兼容的标准要高得多--向错误兼容。任何实现上的意外或运行某些代码时的无意副作用,都被认为是语言的一个特性,需要像维护其他特性或功能一样热情地维护。无论在我们继续改进Perl的过程中,这些无意的功能可能会让我们感到多么沮丧,这些无意的功能往往值得我们保护。现有的用Perl编写的软件能够继续正确地工作是非常重要的。如果终端用户开发者把一个错误当作一个特性,我们需要把它当作一个特性来对待。</target>
        </trans-unit>
        <trans-unit id="2e6d74e94851d72f49d2c6b59183be96d60c8e34" translate="yes" xml:space="preserve">
          <source>History and Background</source>
          <target state="translated">历史和背景</target>
        </trans-unit>
        <trans-unit id="ace535b09698d3ae2888504e132d0829ba6b4d7d" translate="yes" xml:space="preserve">
          <source>History of CPAN Meta Spec changes</source>
          <target state="translated">CPAN元规格变化的历史</target>
        </trans-unit>
        <trans-unit id="3e8e120f18fdbffd8b9be5d8fa532f5e8e03fa02" translate="yes" xml:space="preserve">
          <source>History of Middle Earth</source>
          <target state="translated">中土史</target>
        </trans-unit>
        <trans-unit id="9d34c3581dd43beee5ddd060d0bab25f439fd94b" translate="yes" xml:space="preserve">
          <source>History of WinCE port</source>
          <target state="translated">WinCE端口的历史</target>
        </trans-unit>
        <trans-unit id="9733ac081a67789bdb91140dbb2aaf4de5c5ec7b" translate="yes" xml:space="preserve">
          <source>Hmm. What happened here? If you've been following along, you know that the above pattern should be effectively (almost) the same as the last one; enclosing the &lt;code&gt;d&lt;/code&gt; in a character class isn't going to change what it matches. So why does the first not print while the second one does?</source>
          <target state="translated">嗯 这里发生了什么？如果您一直在遵循，那么您就会知道上述模式实际上（几乎）应该与最后一种模式相同；将 &lt;code&gt;d&lt;/code&gt; 括在字符类中不会改变其匹配项。那么为什么第一个不打印而第二个不打印呢？</target>
        </trans-unit>
        <trans-unit id="821ac8e428a38ddcf25e2027bc128ec6e743a489" translate="yes" xml:space="preserve">
          <source>Hmm... that's still a bit ugly. How about this:</source>
          <target state="translated">嗯......还是有点难看。那这个呢?</target>
        </trans-unit>
        <trans-unit id="511721548acc73e7ad2a7122ec29970e3c6188d3" translate="yes" xml:space="preserve">
          <source>Holds information on the longest string that must occur at a fixed offset from the start of the pattern, and the longest string that must occur at a floating offset from the start of the pattern. Used to do Fast-Boyer-Moore searches on the string to find out if its worth using the regex engine at all, and if so where in the string to search.</source>
          <target state="translated">保存从模式开始的固定偏移处出现的最长字符串和从模式开始的浮动偏移处出现的最长字符串的信息。用于对字符串进行Fast-Boyer-Moore搜索,以确定是否值得使用regex引擎,如果值得,则在字符串的哪个位置进行搜索。</target>
        </trans-unit>
        <trans-unit id="959988c98232c3eb8b17616f91948b459e04946f" translate="yes" xml:space="preserve">
          <source>Holds some explanation in the case of an error.</source>
          <target state="translated">在错误的情况下,持有一些解释。</target>
        </trans-unit>
        <trans-unit id="01443708f436be923f0aee8880549437dad1a448" translate="yes" xml:space="preserve">
          <source>Holds the last reported error. Kept for historical reasons, but its use is very much discouraged. Use the &lt;code&gt;error()&lt;/code&gt; method instead:</source>
          <target state="translated">保存上一次报告的错误。由于历史原因而保留，但不鼓励使用。请改用 &lt;code&gt;error()&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="c95db6ed76758307edcf864f1a4ab2acb112562d" translate="yes" xml:space="preserve">
          <source>Holds the output of the &lt;code&gt;date&lt;/code&gt; command when the configuration file was produced. This is used to tag both</source>
          <target state="translated">保留配置文件生成时 &lt;code&gt;date&lt;/code&gt; 命令的输出。这用于标记两个</target>
        </trans-unit>
        <trans-unit id="739c29f4f6f84e7a7eaff9a32fa3671bc3d08941" translate="yes" xml:space="preserve">
          <source>Holds the private path used by Configure to find out the libraries. Its value is prepend to libpth. This variable takes care of special machines, like the mips. Usually, it should be empty.</source>
          <target state="translated">保存Configure用来查找库的私有路径。它的值是libpth的前缀。这个变量用于处理特殊的机器,比如mips。通常情况下,它应该是空的。</target>
        </trans-unit>
        <trans-unit id="582b824400c82cf0f40f9f7c604827d48ea750f5" translate="yes" xml:space="preserve">
          <source>Holds the standard error of the executed command (or empty string if there was no STDERR output or if &lt;code&gt;discard_output&lt;/code&gt; was used; it's always defined!)</source>
          <target state="translated">保留已执行命令的标准错误（如果没有STDERR输出或使用 &lt;code&gt;discard_output&lt;/code&gt; ,则为空字符串；始终已定义！）</target>
        </trans-unit>
        <trans-unit id="7c3e4c3ddb7125c1c1e75cedd0d2a9c28f53291d" translate="yes" xml:space="preserve">
          <source>Holds the standard output and error of the executed command merged into one stream (or empty string if there was no output at all or if &lt;code&gt;discard_output&lt;/code&gt; was used; it's always defined!)</source>
          <target state="translated">保留合并到一个流中的标准输出和已执行命令的错误（如果根本没有输出或使用了 &lt;code&gt;discard_output&lt;/code&gt; 空字符串；始终已定义！）</target>
        </trans-unit>
        <trans-unit id="5f9c8ab4b280eb2c610d191400d239df37776272" translate="yes" xml:space="preserve">
          <source>Holds the standard output of the executed command (or empty string if there was no STDOUT output or if &lt;code&gt;discard_output&lt;/code&gt; was used; it's always defined!)</source>
          <target state="translated">保留已执行命令的标准输出（如果没有STDOUT输出或使用了 &lt;code&gt;discard_output&lt;/code&gt; 空字符串；始终已定义！）</target>
        </trans-unit>
        <trans-unit id="1f43fffdbf7b0c05af0b8fc8fcc67b1c8be39947" translate="yes" xml:space="preserve">
          <source>Home page for ISO 15924.</source>
          <target state="translated">ISO 15924的主页。</target>
        </trans-unit>
        <trans-unit id="1ba2fa3de9992cda18c006a91b37960fee16b9e0" translate="yes" xml:space="preserve">
          <source>Hook manipulation</source>
          <target state="translated">钩子操作</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="4b09a3b7ef7178d5866c8b4122a3b1b80e280cb2" translate="yes" xml:space="preserve">
          <source>Hopefully the contents of each of the filters should be self-explanatory. Both &quot;fetch&quot; filters remove the terminating NULL, and both &quot;store&quot; filters add a terminating NULL.</source>
          <target state="translated">希望每个过滤器的内容应该是不言自明的。两个 &quot;fetch &quot;过滤器都删除了终止的NULL,两个 &quot;store &quot;过滤器都增加了终止的NULL。</target>
        </trans-unit>
        <trans-unit id="b28755c4371822ab05bbd3edfbd84f8ae5c44516" translate="yes" xml:space="preserve">
          <source>How Do I Convert Binary Data Into a Particular Encoding, Or Vice Versa?</source>
          <target state="translated">我如何将二进制数据转换为特定的编码,或者反之亦然?</target>
        </trans-unit>
        <trans-unit id="5ec153ad02980479ddc59f23ab37e27027e62588" translate="yes" xml:space="preserve">
          <source>How Do I Detect Data That's Not Valid In a Particular Encoding?</source>
          <target state="translated">我如何检测在特定编码中无效的数据?</target>
        </trans-unit>
        <trans-unit id="83daa5c8b58e95efd16e89c69000aaf2de146549" translate="yes" xml:space="preserve">
          <source>How Do I Display Unicode? How Do I Input Unicode?</source>
          <target state="translated">我如何显示Unicode?我如何输入Unicode?</target>
        </trans-unit>
        <trans-unit id="eed7b35ef6f59f0cb6c635063802f8b69563cf7e" translate="yes" xml:space="preserve">
          <source>How Do I Find Out What Encoding a File Has?</source>
          <target state="translated">我如何找出一个文件的编码?</target>
        </trans-unit>
        <trans-unit id="87e4752c70fc96666a27cf0847bc95f48c8b5c9c" translate="yes" xml:space="preserve">
          <source>How Do I Know Whether My String Is In Unicode?</source>
          <target state="translated">我如何知道我的字符串是否使用Unicode?</target>
        </trans-unit>
        <trans-unit id="9a4dab32f52f3d5fb8384770ca50058013424c08" translate="yes" xml:space="preserve">
          <source>How Do I Make My Scripts Work With Unicode?</source>
          <target state="translated">我如何使我的脚本与Unicode一起工作?</target>
        </trans-unit>
        <trans-unit id="aa967413382158f18536864c2c5f2d495ed0e167" translate="yes" xml:space="preserve">
          <source>How Does Unicode Work With Traditional Locales?</source>
          <target state="translated">統一碼如何與傳統地區配合?</target>
        </trans-unit>
        <trans-unit id="ed7d6cb8e007f613e72e9f2c9f88a4738718ec79" translate="yes" xml:space="preserve">
          <source>How Lexical Warnings interact with &lt;b&gt;-w&lt;/b&gt;/&lt;code&gt;$^W&lt;/code&gt; :</source>
          <target state="translated">词汇警告如何与&lt;b&gt;-w&lt;/b&gt; / &lt;code&gt;$^W&lt;/code&gt; 交互：</target>
        </trans-unit>
        <trans-unit id="d1d502798bd5bd5bfc80ae2ff245f8510eaa3465" translate="yes" xml:space="preserve">
          <source>How Perl Chooses an Operator Implementation</source>
          <target state="translated">Perl如何选择操作符实现</target>
        </trans-unit>
        <trans-unit id="9d0dbe99bf0e202fd46e73a61d85e7d37d314d99" translate="yes" xml:space="preserve">
          <source>How PerlIO_apply_layera fits in, where its docs, was it made public?</source>
          <target state="translated">PerlIO_apply_layera如何配合,它的docs在哪里,是公开的吗?</target>
        </trans-unit>
        <trans-unit id="d5c739c2b8daeba650fc90008192e941caa8ca99" translate="yes" xml:space="preserve">
          <source>How SUPER is Resolved</source>
          <target state="translated">SUPER是如何解决的</target>
        </trans-unit>
        <trans-unit id="30ea041c36c78a4bf2e3a15655945d87e8d2b703" translate="yes" xml:space="preserve">
          <source>How To Write A Makefile.PL</source>
          <target state="translated">如何编写Makefile.PL</target>
        </trans-unit>
        <trans-unit id="4a252fc6f68b2a5fddacedeb60aa9691abebcc2a" translate="yes" xml:space="preserve">
          <source>How a piece of code actually goes about doing its job. Users of the code should not count on implementation details staying the same unless they are part of the published &lt;b&gt;interface&lt;/b&gt;.</source>
          <target state="translated">一段代码实际上是如何完成其​​工作的。代码的用户不应指望实现细节保持不变，除非它们是已发布&lt;b&gt;接口的&lt;/b&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="e2e38e1473acd589790c55670049e3a998855b25" translate="yes" xml:space="preserve">
          <source>How are you supposed to know what flavour of Make a Makefile has been generated for if you didn't specify a value explicitly? Search the generated Makefile for the definition of the MAKE variable, which is used to recursively invoke the Make utility. That will tell you what Make you're supposed to invoke the Makefile with.</source>
          <target state="translated">如果你没有明确地指定一个值,你怎么知道生成的Makefile是什么类型的?在生成的 Makefile 中搜索 MAKE 变量的定义,它是用来递归调用 Make 工具的。这将告诉你应该用什么Make来调用Makefile。</target>
        </trans-unit>
        <trans-unit id="411ad64f6dc4be13b3049742bd05bd21505c6bc7" translate="yes" xml:space="preserve">
          <source>How big is it?</source>
          <target state="translated">它有多大?</target>
        </trans-unit>
        <trans-unit id="27c74f66aeb35e0636195d822a7e3464616e6fc2" translate="yes" xml:space="preserve">
          <source>How can I access a dynamic variable while a similarly named lexical is in scope?</source>
          <target state="translated">当一个类似名称的词库在作用域内时,我如何访问一个动态变量?</target>
        </trans-unit>
        <trans-unit id="a4335b4f09781554b24ada06ac33e99c54ce3d7c" translate="yes" xml:space="preserve">
          <source>How can I access or change N characters of a string?</source>
          <target state="translated">如何访问或更改一个字符串的N个字符?</target>
        </trans-unit>
        <trans-unit id="5371ca66bd4ba8690a33a1384214275dda640111" translate="yes" xml:space="preserve">
          <source>How can I always keep my hash sorted?</source>
          <target state="translated">如何才能始终保持我的哈希分类?</target>
        </trans-unit>
        <trans-unit id="8584960f36ac9f047e34a3eda935743347b5f7f6" translate="yes" xml:space="preserve">
          <source>How can I call backticks without shell processing?</source>
          <target state="translated">如何在没有壳处理的情况下调用回拨?</target>
        </trans-unit>
        <trans-unit id="cd430257f97dbf507a96e7339aa72325a34a2ee9" translate="yes" xml:space="preserve">
          <source>How can I call my system's unique C functions from Perl?</source>
          <target state="translated">如何从Perl中调用系统特有的C函数?</target>
        </trans-unit>
        <trans-unit id="90f43bbd8d5db22db1ec788113816dce3fba1fdc" translate="yes" xml:space="preserve">
          <source>How can I capture STDERR from an external command?</source>
          <target state="translated">如何从外部命令中捕获STDERR?</target>
        </trans-unit>
        <trans-unit id="84907121b70e047be5c9daea9434199430d20e18" translate="yes" xml:space="preserve">
          <source>How can I catch accesses to undefined variables, functions, or methods?</source>
          <target state="translated">如何捕捉对未定义变量、函数或方法的访问?</target>
        </trans-unit>
        <trans-unit id="e13761e1cadfb4e6d275a8cd44df7f322009226b" translate="yes" xml:space="preserve">
          <source>How can I check if a key exists in a multilevel hash?</source>
          <target state="translated">如何检查多级哈希中是否存在密钥?</target>
        </trans-unit>
        <trans-unit id="9501d5027299df90931400bb41c70210a1c7aacf" translate="yes" xml:space="preserve">
          <source>How can I comment out a large block of Perl code?</source>
          <target state="translated">如何注释掉一大段Perl代码?</target>
        </trans-unit>
        <trans-unit id="639138b8959cf833940b74db28e00ac3d078eb9d" translate="yes" xml:space="preserve">
          <source>How can I compare two dates and find the difference?</source>
          <target state="translated">如何比较两个日期并找出差异?</target>
        </trans-unit>
        <trans-unit id="92731d0a16ed8941afe35ab6fae1c71e5ff73d63" translate="yes" xml:space="preserve">
          <source>How can I compile my Perl program into byte code or C?</source>
          <target state="translated">如何将我的Perl程序编译成字节码或C语言?</target>
        </trans-unit>
        <trans-unit id="f297bf1c9610312e098c5eff2eb10783e881e05c" translate="yes" xml:space="preserve">
          <source>How can I convert my shell script to perl?</source>
          <target state="translated">如何将我的shell脚本转换为perl?</target>
        </trans-unit>
        <trans-unit id="fc9934bcfd8649f3922c04fc5693703b33981e29" translate="yes" xml:space="preserve">
          <source>How can I convince others to use Perl?</source>
          <target state="translated">如何说服别人使用Perl?</target>
        </trans-unit>
        <trans-unit id="61781e6bf9642bee00811fb1e34ef7698e18ae20" translate="yes" xml:space="preserve">
          <source>How can I copy a file?</source>
          <target state="translated">如何复制文件?</target>
        </trans-unit>
        <trans-unit id="62ee42141b7c95a311d0f8cb97c8e383832868b4" translate="yes" xml:space="preserve">
          <source>How can I count the number of occurrences of a substring within a string?</source>
          <target state="translated">如何计算一个字符串中子串的出现次数?</target>
        </trans-unit>
        <trans-unit id="f0aa6516dbefab9dd5eb5222f4701f9c5f218b7c" translate="yes" xml:space="preserve">
          <source>How can I determine if a string is a text string or a binary string?</source>
          <target state="translated">如何判断一个字符串是文本字符串还是二进制字符串?</target>
        </trans-unit>
        <trans-unit id="218779f6e2b4819e8fa691d46344a18cc62cfb76" translate="yes" xml:space="preserve">
          <source>How can I do RPC in Perl?</source>
          <target state="translated">如何在Perl中进行RPC?</target>
        </trans-unit>
        <trans-unit id="67ea1bb995fcd1fc57c8e9b92a095f41d9b7834f" translate="yes" xml:space="preserve">
          <source>How can I do an atexit() or setjmp()/longjmp()? (Exception handling)</source>
          <target state="translated">如何进行texit()或setjmp()/longjmp()?(异常处理)</target>
        </trans-unit>
        <trans-unit id="5af190bbb735548d1facf32f768401f6d294971f" translate="yes" xml:space="preserve">
          <source>How can I do approximate matching?</source>
          <target state="translated">如何进行近似匹配?</target>
        </trans-unit>
        <trans-unit id="570f18a5d24dc2e398fe91082824106830a64146" translate="yes" xml:space="preserve">
          <source>How can I expand variables in text strings?</source>
          <target state="translated">如何在文本字符串中展开变量?</target>
        </trans-unit>
        <trans-unit id="79199189d2f681d40463922bceb5338164a11bf3" translate="yes" xml:space="preserve">
          <source>How can I find out my current or calling package?</source>
          <target state="translated">如何查询我的当前或通话套餐?</target>
        </trans-unit>
        <trans-unit id="2174489b130a993ef91515d9a1c4f01f1df7d31d" translate="yes" xml:space="preserve">
          <source>How can I find the Julian Day?</source>
          <target state="translated">如何找到朱利安日?</target>
        </trans-unit>
        <trans-unit id="b9735d79cbde5c76c3fddd9a7f2ea2d91841d1f1" translate="yes" xml:space="preserve">
          <source>How can I free an array or hash so my program shrinks?</source>
          <target state="translated">如何释放数组或哈希,使我的程序缩小?</target>
        </trans-unit>
        <trans-unit id="a65a81dcfe85675764c8fa953a5501143a7a4d4c" translate="yes" xml:space="preserve">
          <source>How can I get #!perl to work on [MS-DOS,NT,...]?</source>
          <target state="translated">如何让#!perl在[MS-DOS,NT,...]上工作?</target>
        </trans-unit>
        <trans-unit id="bf6b38eb1c743c27901f724e241bc103f6e22f1a" translate="yes" xml:space="preserve">
          <source>How can I get &lt;code&gt;#!perl&lt;/code&gt; to work on [MS-DOS,NT,...]?</source>
          <target state="translated">我如何获得 &lt;code&gt;#!perl&lt;/code&gt; 在[MS-DOS，NT，...]上工作？</target>
        </trans-unit>
        <trans-unit id="402e6fe7ce516fa4af09165ec04abd0ecfff56b0" translate="yes" xml:space="preserve">
          <source>How can I get a binary version of Perl?</source>
          <target state="translated">如何获得 Perl 的二进制版本?</target>
        </trans-unit>
        <trans-unit id="f01d20dc05214c47d4b244f669680dc5511e26c5" translate="yes" xml:space="preserve">
          <source>How can I get the unique keys from two hashes?</source>
          <target state="translated">如何从两个哈希值中获取唯一密钥?</target>
        </trans-unit>
        <trans-unit id="c41c416bf1bb0f25b4ae1ae9fd568032d02685fd" translate="yes" xml:space="preserve">
          <source>How can I hide the source for my Perl program?</source>
          <target state="translated">如何隐藏Perl程序的源代码?</target>
        </trans-unit>
        <trans-unit id="6c1e3d2428ca43719e62fc8b4685854b671a4efe" translate="yes" xml:space="preserve">
          <source>How can I hope to use regular expressions without creating illegible and unmaintainable code?</source>
          <target state="translated">我怎么能希望使用正则表达式而不产生难以辨认和不可维护的代码?</target>
        </trans-unit>
        <trans-unit id="b41e3d8caca6f525dc73482358563647f9033bf1" translate="yes" xml:space="preserve">
          <source>How can I know how many entries are in a hash?</source>
          <target state="translated">如何知道一个哈希中有多少个条目?</target>
        </trans-unit>
        <trans-unit id="91090b21439190b378705149c5300b111d7f99b3" translate="yes" xml:space="preserve">
          <source>How can I lock a file?</source>
          <target state="translated">如何锁定文件?</target>
        </trans-unit>
        <trans-unit id="2b525e6fbe8d4f65916593a6d6f3bcc00b55e5ee" translate="yes" xml:space="preserve">
          <source>How can I make &lt;code&gt;\w&lt;/code&gt; match national character sets?</source>
          <target state="translated">如何使 &lt;code&gt;\w&lt;/code&gt; 与国家字符集匹配？</target>
        </trans-unit>
        <trans-unit id="493e8171097525007801a396579dca3fc0ae7646" translate="yes" xml:space="preserve">
          <source>How can I make \w match national character sets?</source>
          <target state="translated">如何使\w符合国家字符集?</target>
        </trans-unit>
        <trans-unit id="8efd8bb825816036c83b0bc4f4bc86a0e0087ba8" translate="yes" xml:space="preserve">
          <source>How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?</source>
          <target state="translated">如何使文件柄成为子程序的本地文件柄?如何在子程序之间传递文件柄?如何制作一个文件柄数组?</target>
        </trans-unit>
        <trans-unit id="225121f6ad8826944237905943573b1a1ad7146a" translate="yes" xml:space="preserve">
          <source>How can I make my CGI script more efficient?</source>
          <target state="translated">如何让我的CGI脚本更有效率?</target>
        </trans-unit>
        <trans-unit id="aa449d7fc61d0c5f65c319dcdaf3c309d5a861d5" translate="yes" xml:space="preserve">
          <source>How can I make my Perl program run faster?</source>
          <target state="translated">如何让我的Perl程序运行得更快?</target>
        </trans-unit>
        <trans-unit id="da8314c9a027c83b1de3d8a02639e8b7fd488456" translate="yes" xml:space="preserve">
          <source>How can I make my Perl program take less memory?</source>
          <target state="translated">如何让我的Perl程序占用更少的内存?</target>
        </trans-unit>
        <trans-unit id="ab79906bd54ede65c9167982f83df39910ca41eb" translate="yes" xml:space="preserve">
          <source>How can I make my hash remember the order I put elements into it?</source>
          <target state="translated">如何让我的哈希记住我放入元素的顺序?</target>
        </trans-unit>
        <trans-unit id="eff3ee7a75a95b7dc6ebbcab6cdc87f62eaed0b6" translate="yes" xml:space="preserve">
          <source>How can I make the Perl equivalent of a C structure/C++ class/hash or array of hashes or arrays?</source>
          <target state="translated">如何使Perl相当于C结构/C++类/哈希或数组的哈希或数组?</target>
        </trans-unit>
        <trans-unit id="313eaa4ceba4000008228fa89da4dfffac4883cb" translate="yes" xml:space="preserve">
          <source>How can I manipulate fixed-record-length files?</source>
          <target state="translated">如何操作固定记录长度的文件?</target>
        </trans-unit>
        <trans-unit id="e9c4cf85e44267039f73e90a4005aa7e0fbde93f" translate="yes" xml:space="preserve">
          <source>How can I match a locale-smart version of /[a-zA-Z]/?</source>
          <target state="translated">如何匹配/[a-zA-Z]/的本地智能版本?</target>
        </trans-unit>
        <trans-unit id="a09d0b29b89d8c572780ffdaa75b2f1b8df250c7" translate="yes" xml:space="preserve">
          <source>How can I match a locale-smart version of &lt;code&gt;/[a-zA-Z]/&lt;/code&gt; ?</source>
          <target state="translated">如何匹配 &lt;code&gt;/[a-zA-Z]/&lt;/code&gt; 的语言环境智能版本？</target>
        </trans-unit>
        <trans-unit id="acc211b194ec96e0a9f39c2fc3c9760c5684f182" translate="yes" xml:space="preserve">
          <source>How can I match strings with multibyte characters?</source>
          <target state="translated">如何匹配带有多字节字符的字符串?</target>
        </trans-unit>
        <trans-unit id="77dcf6b0c4c91ea96666741c5ba2af5b17f44eab" translate="yes" xml:space="preserve">
          <source>How can I measure time under a second?</source>
          <target state="translated">如何测量一秒以下的时间?</target>
        </trans-unit>
        <trans-unit id="3db0de0b51e68209069c4bcced248be111e64bf1" translate="yes" xml:space="preserve">
          <source>How can I open a file with a leading &quot;&amp;gt;&quot; or trailing blanks?</source>
          <target state="translated">如何打开带有&amp;ldquo;&amp;gt;&amp;rdquo;或尾随空白的文件？</target>
        </trans-unit>
        <trans-unit id="2e27cd7875437a1d5b58c674aa20e1a1f445ed2f" translate="yes" xml:space="preserve">
          <source>How can I open a filehandle to a string?</source>
          <target state="translated">如何将文件柄打开为字符串?</target>
        </trans-unit>
        <trans-unit id="66bdbd7c5e5fc4cc3882f787c23fdf9783890787" translate="yes" xml:space="preserve">
          <source>How can I open a pipe both to and from a command?</source>
          <target state="translated">如何既能打开管道,又能从命令中打开?</target>
        </trans-unit>
        <trans-unit id="cc95647ff06623df9f3fe7b151e5174f6d8d433a" translate="yes" xml:space="preserve">
          <source>How can I output Roman numerals?</source>
          <target state="translated">如何输出罗马数字?</target>
        </trans-unit>
        <trans-unit id="e415a2ec1d5bacc294697e39127dad698ce08519" translate="yes" xml:space="preserve">
          <source>How can I output my numbers with commas added?</source>
          <target state="translated">如何输出加了逗号的数字?</target>
        </trans-unit>
        <trans-unit id="71d9df292afc1f28ab8d43537f9b2fc5e1d5e39d" translate="yes" xml:space="preserve">
          <source>How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?</source>
          <target state="translated">如何传递/返回一个{函数、FileHandle、数组、Hash、方法、Regex}?</target>
        </trans-unit>
        <trans-unit id="607da88807131fb0d75ed3b744e20b136c3c6945" translate="yes" xml:space="preserve">
          <source>How can I prevent addition of unwanted keys into a hash?</source>
          <target state="translated">如何防止在哈希中加入不需要的密钥?</target>
        </trans-unit>
        <trans-unit id="132c95be002620b77b84199839203d3bbecd265f" translate="yes" xml:space="preserve">
          <source>How can I print out a word-frequency or line-frequency summary?</source>
          <target state="translated">如何打印出字频或行频摘要?</target>
        </trans-unit>
        <trans-unit id="9b8afbc5c9adfffb10eaf9f9e73e6a5dd9a33727" translate="yes" xml:space="preserve">
          <source>How can I pull out lines between two patterns that are themselves on different lines?</source>
          <target state="translated">如何在两个本身就在不同线上的图案之间拉出线条?</target>
        </trans-unit>
        <trans-unit id="aa09f1e8ecf9751a8e601635407b1b85b484a991" translate="yes" xml:space="preserve">
          <source>How can I quote a variable to use in a regex?</source>
          <target state="translated">如何在regex中引用变量?</target>
        </trans-unit>
        <trans-unit id="5048ee292d54dc738c8b2e4a4e9d40ed88661804" translate="yes" xml:space="preserve">
          <source>How can I read a single character from a file? From the keyboard?</source>
          <target state="translated">如何从文件中读取单个字符?从键盘上读取?</target>
        </trans-unit>
        <trans-unit id="bd4bea532194d27e8f4c0167b3ea139fc3e738e8" translate="yes" xml:space="preserve">
          <source>How can I read in a file by paragraphs?</source>
          <target state="translated">如何在文件中按段落阅读?</target>
        </trans-unit>
        <trans-unit id="d86b23e0a7033694a41285ad01891788240ba487" translate="yes" xml:space="preserve">
          <source>How can I read in an entire file all at once?</source>
          <target state="translated">如何一次性读入整个文件?</target>
        </trans-unit>
        <trans-unit id="be068faf9cf22c97ef84fb173f7722fe689af084" translate="yes" xml:space="preserve">
          <source>How can I recognise a UTF-8 string?</source>
          <target state="translated">如何识别UTF-8字符串?</target>
        </trans-unit>
        <trans-unit id="28052c84845f30a6d5db733cf8047009c5a791db" translate="yes" xml:space="preserve">
          <source>How can I reliably rename a file?</source>
          <target state="translated">如何可靠地重命名一个文件?</target>
        </trans-unit>
        <trans-unit id="8a768c48e2e0b2fc34f88cb4e753c4bb5f8f926e" translate="yes" xml:space="preserve">
          <source>How can I remove duplicate elements from a list or array?</source>
          <target state="translated">如何从列表或数组中删除重复的元素?</target>
        </trans-unit>
        <trans-unit id="daff1cd30b2b776eb20a1e8ba332328966a941c8" translate="yes" xml:space="preserve">
          <source>How can I set up a footer format to be used with write()?</source>
          <target state="translated">如何设置与write()一起使用的页脚格式?</target>
        </trans-unit>
        <trans-unit id="e1d8eb9609efe77a17044341626f5d092fb4352d" translate="yes" xml:space="preserve">
          <source>How can I sleep() or alarm() for under a second?</source>
          <target state="translated">如何能在一秒内睡觉()或闹钟()?</target>
        </trans-unit>
        <trans-unit id="2e588f9010bcd10392f7edf040ae56a945189e99" translate="yes" xml:space="preserve">
          <source>How can I split a [character]-delimited string except when inside [character]?</source>
          <target state="translated">除了在[字符]内,如何分割一个[字符]限定的字符串?</target>
        </trans-unit>
        <trans-unit id="043a45581bbf861e01b6d8df458229f88cd7fe73" translate="yes" xml:space="preserve">
          <source>How can I store a multidimensional array in a DBM file?</source>
          <target state="translated">如何在DBM文件中存储一个多维数组?</target>
        </trans-unit>
        <trans-unit id="3e3f15708830cd90fcc2e8ed11e6fc04c0345d66" translate="yes" xml:space="preserve">
          <source>How can I take a string and turn it into epoch seconds?</source>
          <target state="translated">如何把一个字符串变成纪元秒?</target>
        </trans-unit>
        <trans-unit id="279887cb82cd1ebda6c6c1a0b09fc6f0014cb878" translate="yes" xml:space="preserve">
          <source>How can I tell if a variable is tainted?</source>
          <target state="translated">如何判断一个变量是否有污点?</target>
        </trans-unit>
        <trans-unit id="58516c6da782669b8d9c7cfc7d02262b3e4bb1bb" translate="yes" xml:space="preserve">
          <source>How can I tell whether a certain element is contained in a list or array?</source>
          <target state="translated">如何判断列表或数组中是否包含某个元素?</target>
        </trans-unit>
        <trans-unit id="81aaf6c4723167313d15ab1c5f7e5b530f8557ce" translate="yes" xml:space="preserve">
          <source>How can I tell whether there's a character waiting on a filehandle?</source>
          <target state="translated">如何判断一个文件柄上是否有字符在等待?</target>
        </trans-unit>
        <trans-unit id="b2fcf8739ca319f39af63e3ce5170d91f44f77f2" translate="yes" xml:space="preserve">
          <source>How can I translate tildes (~) in a filename?</source>
          <target state="translated">如何翻译文件名中的tildes(~)?</target>
        </trans-unit>
        <trans-unit id="881f014c19a83fce123198524d0af95f5abeddf7" translate="yes" xml:space="preserve">
          <source>How can I use Perl interactively?</source>
          <target state="translated">如何交互式地使用Perl?</target>
        </trans-unit>
        <trans-unit id="4822820e0cebd48f928eec2f020bfeb1c6c58fcc" translate="yes" xml:space="preserve">
          <source>How can I use Perl's -i option from within a program?</source>
          <target state="translated">如何在程序中使用 Perl 的 -i 选项?</target>
        </trans-unit>
        <trans-unit id="b59721a4c76a7fca29f80e903b0f2dded9b41579" translate="yes" xml:space="preserve">
          <source>How can I use Perl's &lt;code&gt;-i&lt;/code&gt; option from within a program?</source>
          <target state="translated">如何在程序中使用Perl的 &lt;code&gt;-i&lt;/code&gt; 选项？</target>
        </trans-unit>
        <trans-unit id="a0b830d488369e5b57f08961ae54b6541e391fcb" translate="yes" xml:space="preserve">
          <source>How can I use a filehandle indirectly?</source>
          <target state="translated">如何间接使用filehandle?</target>
        </trans-unit>
        <trans-unit id="2954afefc188233ca0982e40813f35aedafa9c02" translate="yes" xml:space="preserve">
          <source>How can I use a reference as a hash key?</source>
          <target state="translated">如何使用引用作为哈希键?</target>
        </trans-unit>
        <trans-unit id="1cd3f90234d9f2d28d7f7859571cd8142dbcb6f4" translate="yes" xml:space="preserve">
          <source>How can I use a variable as a variable name?</source>
          <target state="translated">如何使用变量作为变量名?</target>
        </trans-unit>
        <trans-unit id="0c905d4e5eee64ffc80c2808116d673741258304" translate="yes" xml:space="preserve">
          <source>How can I use curses with Perl?</source>
          <target state="translated">如何使用Perl中的咒语?</target>
        </trans-unit>
        <trans-unit id="50c6bbc4fb82176bf9d1327a643a764fb7e991f8" translate="yes" xml:space="preserve">
          <source>How can I write a GUI (X, Tk, Gtk, etc.) in Perl?</source>
          <target state="translated">如何用Perl写一个GUI(X、Tk、Gtk等)?</target>
        </trans-unit>
        <trans-unit id="81e8482ca19f1c03f3246a06ec608fbebf4e5f7c" translate="yes" xml:space="preserve">
          <source>How can I write expect in Perl?</source>
          <target state="translated">如何在 Perl 中写出 expect?</target>
        </trans-unit>
        <trans-unit id="1ed0197c720cb0aff97775cc40d6071cc2ec1d85" translate="yes" xml:space="preserve">
          <source>How can I write() into a string?</source>
          <target state="translated">如何将()写入字符串?</target>
        </trans-unit>
        <trans-unit id="ebe948a96ce8ed3fcef25d460b5826d6e46a03f1" translate="yes" xml:space="preserve">
          <source>How can you figure out what to add? Assuming your Perl is post-5.001, execute a &lt;code&gt;perl -V&lt;/code&gt; command and pay special attention to the &quot;cc&quot; and &quot;ccflags&quot; information.</source>
          <target state="translated">您如何找出要添加的内容？假设您的Perl为5.01之后，请执行 &lt;code&gt;perl -V&lt;/code&gt; 命令并特别注意&amp;ldquo; cc&amp;rdquo;和&amp;ldquo; ccflags&amp;rdquo;信息。</target>
        </trans-unit>
        <trans-unit id="7839a80cf8d473225aea7a22d12034d28e88fd87" translate="yes" xml:space="preserve">
          <source>How can you tell the difference between a non-zero status that is the result of a VMS native error status or an encoded Unix status? You can not unless you look at the ${^CHILD_ERROR_NATIVE} value. The ${^CHILD_ERROR_NATIVE} value returns the actual VMS status value and check the severity bits. If the severity bits are equal to 1, then if the numeric value for &lt;code&gt;$?&lt;/code&gt; is between 2 and 255 or 0, then &lt;code&gt;$?&lt;/code&gt; accurately reflects a value passed back from a Unix application. If &lt;code&gt;$?&lt;/code&gt; is 1, and the severity bits indicate a VMS error (2), then &lt;code&gt;$?&lt;/code&gt; is from a Unix application exit value.</source>
          <target state="translated">您如何分辨VMS本机错误状态或编码的Unix状态导致的非零状态之间的区别？除非您查看$ {^ CHILD_ERROR_NATIVE}值，否则您将无法这样做。$ {^ CHILD_ERROR_NATIVE}值返回实际的VMS状态值并检查严重性位。如果严重性位等于1，则 &lt;code&gt;$?&lt;/code&gt; 的数值是否为$？在2到255或0之间，然后 &lt;code&gt;$?&lt;/code&gt; 准确地反映从Unix应用程序传回的值。如果 &lt;code&gt;$?&lt;/code&gt; 为1，严重性位指示VMS错误（2），然后 &lt;code&gt;$?&lt;/code&gt; 来自Unix应用程序退出值。</target>
        </trans-unit>
        <trans-unit id="10e8b70e261dbd1684433d0e38a377a1e6c6f1bf" translate="yes" xml:space="preserve">
          <source>How come exec() doesn't return?</source>
          <target state="translated">为什么exec()不返回?</target>
        </trans-unit>
        <trans-unit id="642d4ca1dadf5e67b2382dbc957dee2d26101ca3" translate="yes" xml:space="preserve">
          <source>How come when I open a file read-write it wipes it out?</source>
          <target state="translated">为什么我打开一个文件读写的时候会把它抹掉?</target>
        </trans-unit>
        <trans-unit id="120ce3c4d0d569cc353775c742050f216df78c10" translate="yes" xml:space="preserve">
          <source>How come? Because once upon a time, the argument to push() had to be a real array, not just a reference to one. That's no longer true. In fact, the line marked &quot;implicit deref&quot; above works just fine--in this instance--to do what the one that says explicit deref did.</source>
          <target state="translated">怎么会这样呢?因为从前,push()的参数必须是一个真正的数组,而不仅仅是一个数组的引用。现在不再是这样了。事实上,上面标有 &quot;implicit deref &quot;的那行就很好用--在这个例子中--做了那个标有显式 deref 的那行。</target>
        </trans-unit>
        <trans-unit id="35cd8e41b71c05362e2e05b8fea674b5b9428071" translate="yes" xml:space="preserve">
          <source>How do I add a directory to my include path (@INC) at runtime?</source>
          <target state="translated">如何在运行时在我的include路径(@INC)中添加一个目录?</target>
        </trans-unit>
        <trans-unit id="a8c4b858302cc359dbd26e7a94330185357e2027" translate="yes" xml:space="preserve">
          <source>How do I add the directory my program lives in to the module/library search path?</source>
          <target state="translated">如何将我的程序所在的目录添加到模块/库搜索路径中?</target>
        </trans-unit>
        <trans-unit id="3767a07fd4ca1c10dc3a53f806060f350ef02ac9" translate="yes" xml:space="preserve">
          <source>How do I adopt or take over a module already on CPAN?</source>
          <target state="translated">我如何采用或接管CPAN上已有的模块?</target>
        </trans-unit>
        <trans-unit id="2b820f99468b1968d2885fc455211ce9aab00b68" translate="yes" xml:space="preserve">
          <source>How do I ask the user for a password?</source>
          <target state="translated">如何向用户索要密码?</target>
        </trans-unit>
        <trans-unit id="203a77501794721d243b497cab58f25f10122bf4" translate="yes" xml:space="preserve">
          <source>How do I automate an HTML form submission?</source>
          <target state="translated">如何自动提交HTML表格?</target>
        </trans-unit>
        <trans-unit id="b9487e21fcb84b27b564a1a52da3c445074087f9" translate="yes" xml:space="preserve">
          <source>How do I avoid zombies on a Unix system?</source>
          <target state="translated">如何在Unix系统上避免僵尸?</target>
        </trans-unit>
        <trans-unit id="f3a92921961d16b06b6e90c94b5e844a5163c8ba" translate="yes" xml:space="preserve">
          <source>How do I capitalize all the words on one line?</source>
          <target state="translated">如何将一行字全部大写?</target>
        </trans-unit>
        <trans-unit id="4bb5fa72780a70fbcd38ea05720abb4024270f79" translate="yes" xml:space="preserve">
          <source>How do I change the Nth occurrence of something?</source>
          <target state="translated">如何改变东西的第N次出现?</target>
        </trans-unit>
        <trans-unit id="bbe71d73de3e4f641a5e48b9cabe7daee1df1bb9" translate="yes" xml:space="preserve">
          <source>How do I change, delete, or insert a line in a file, or append to the beginning of a file?</source>
          <target state="translated">如何在文件中更改、删除、插入一行,或追加到文件的开头?</target>
        </trans-unit>
        <trans-unit id="26ebac281176cc167fc28682837fc8035f2df7f9" translate="yes" xml:space="preserve">
          <source>How do I check a valid mail address?</source>
          <target state="translated">如何查询有效的邮件地址?</target>
        </trans-unit>
        <trans-unit id="a6d4bc02f449734d8d38a8c79be0738d1807657b" translate="yes" xml:space="preserve">
          <source>How do I check whether input is ready on the keyboard?</source>
          <target state="translated">如何检查键盘上的输入是否就绪?</target>
        </trans-unit>
        <trans-unit id="e9d5289c1b2381a4bfc799f6d79379a45148a056" translate="yes" xml:space="preserve">
          <source>How do I clear a package?</source>
          <target state="translated">如何清除包裹?</target>
        </trans-unit>
        <trans-unit id="da64d3ab23e8dfda8ada8eca869e3e4304053e10" translate="yes" xml:space="preserve">
          <source>How do I clear the screen?</source>
          <target state="translated">如何清除屏幕?</target>
        </trans-unit>
        <trans-unit id="dc7b6aff1b04d81838ccfc000e127a9b49e09b59" translate="yes" xml:space="preserve">
          <source>How do I close a file descriptor by number?</source>
          <target state="translated">如何按编号关闭文件描述符?</target>
        </trans-unit>
        <trans-unit id="2102c2d58d3c697659db6f147f9c7750ead5e836" translate="yes" xml:space="preserve">
          <source>How do I close a process's filehandle without waiting for it to complete?</source>
          <target state="translated">如何在不等待进程完成的情况下关闭进程的文件柄?</target>
        </trans-unit>
        <trans-unit id="82c4851509fc2188559dfc3bbd26e54406e86a76" translate="yes" xml:space="preserve">
          <source>How do I compare strings?</source>
          <target state="translated">如何比较字符串?</target>
        </trans-unit>
        <trans-unit id="a5014833338499c76ba684cef2ad05a8939c7509" translate="yes" xml:space="preserve">
          <source>How do I compute the difference of two arrays? How do I compute the intersection of two arrays?</source>
          <target state="translated">如何计算两个数组的差?如何计算两个数组的交点?</target>
        </trans-unit>
        <trans-unit id="28baf17ec2f9a6ff5d6d17753e8bf70e57ef541a" translate="yes" xml:space="preserve">
          <source>How do I convert a string to UTF-8?</source>
          <target state="translated">如何将字符串转换为UTF-8?</target>
        </trans-unit>
        <trans-unit id="a1ff2698b449bb489c981be9b3dd682dc2dd11e3" translate="yes" xml:space="preserve">
          <source>How do I convert between numeric representations/bases/radixes?</source>
          <target state="translated">如何在数字表示法/基数/半径之间进行转换?</target>
        </trans-unit>
        <trans-unit id="0e154b3973b3e38c40dce2887c701eeb759ba7d9" translate="yes" xml:space="preserve">
          <source>How do I convert from encoding FOO to encoding BAR?</source>
          <target state="translated">如何将FOO编码转换为BAR编码?</target>
        </trans-unit>
        <trans-unit id="f9aa83752cb5484c41a1a794b8c3e92b85b90232" translate="yes" xml:space="preserve">
          <source>How do I copy an entire directory?</source>
          <target state="translated">如何复制整个目录?</target>
        </trans-unit>
        <trans-unit id="878e0980aa72aa1b56f3382c08eb0ae977818037" translate="yes" xml:space="preserve">
          <source>How do I count the number of lines in a file?</source>
          <target state="translated">如何计算一个文件的行数?</target>
        </trans-unit>
        <trans-unit id="86a1974c296e30057e2194a7ef2242b7c1cfd98c" translate="yes" xml:space="preserve">
          <source>How do I create a Module::Build based Build.PL derived from an ExtUtils::MakeMaker focused Makefile.PL?</source>
          <target state="translated">如何从ExtUtils::MakeMaker集中的Makefile.PL创建一个基于Module::Build的Build.PL?</target>
        </trans-unit>
        <trans-unit id="aa6bdbe546fadef34a6ec8c386dc99a9b330832e" translate="yes" xml:space="preserve">
          <source>How do I create a class?</source>
          <target state="translated">如何创建一个班级?</target>
        </trans-unit>
        <trans-unit id="4d74113d708c10f061b26ff7fcdab35341dbf82e" translate="yes" xml:space="preserve">
          <source>How do I create a module?</source>
          <target state="translated">如何创建模块?</target>
        </trans-unit>
        <trans-unit id="236c38bf7065e57bd631c8a83a8f5bfc130478e7" translate="yes" xml:space="preserve">
          <source>How do I create a static variable?</source>
          <target state="translated">如何创建一个静态变量?</target>
        </trans-unit>
        <trans-unit id="b74b37fe4636da83763c3e9df557c6184ae8c0f0" translate="yes" xml:space="preserve">
          <source>How do I create a switch or case statement?</source>
          <target state="translated">如何创建一个开关或case语句?</target>
        </trans-unit>
        <trans-unit id="87e0957c61f867da042ce74af89ed18af7f653b6" translate="yes" xml:space="preserve">
          <source>How do I cross-reference my Perl programs?</source>
          <target state="translated">如何交叉引用我的Perl程序?</target>
        </trans-unit>
        <trans-unit id="70f54b8026aba3fe0b07c960855d5b7aab7bb809" translate="yes" xml:space="preserve">
          <source>How do I debug my Perl programs?</source>
          <target state="translated">如何调试我的Perl程序?</target>
        </trans-unit>
        <trans-unit id="97378d9d3fe8991aaac89412355467232d0a4c27" translate="yes" xml:space="preserve">
          <source>How do I declare/create a structure?</source>
          <target state="translated">如何声明/创建一个结构?</target>
        </trans-unit>
        <trans-unit id="2f51e7bb07a2328659ee4f97c52bb6f158f54842" translate="yes" xml:space="preserve">
          <source>How do I decode a MIME/BASE64 string?</source>
          <target state="translated">如何对MIME/BASE64字符串进行解码?</target>
        </trans-unit>
        <trans-unit id="2cd19e271c87d62d106f8fec30b522eacf831c74" translate="yes" xml:space="preserve">
          <source>How do I decode encrypted password files?</source>
          <target state="translated">如何破解加密的密码文件?</target>
        </trans-unit>
        <trans-unit id="23d494744b67cf68faa6ba521e0dbfb0f945c204" translate="yes" xml:space="preserve">
          <source>How do I decode or create those %-encodings on the web?</source>
          <target state="translated">如何在网络上解码或创建这些%编码?</target>
        </trans-unit>
        <trans-unit id="ee2564195c16e10af1a2a54e803a2d5eaa4bba4a" translate="yes" xml:space="preserve">
          <source>How do I define methods for every class/object?</source>
          <target state="translated">如何为每个类/对象定义方法?</target>
        </trans-unit>
        <trans-unit id="65a1e2e0843b152e3e957dda320e2bd68a2d232e" translate="yes" xml:space="preserve">
          <source>How do I delete a directory tree?</source>
          <target state="translated">如何删除目录树?</target>
        </trans-unit>
        <trans-unit id="c6598461e8184a71f0045d1091c9275b621efb6c" translate="yes" xml:space="preserve">
          <source>How do I delete the last N lines from a file?</source>
          <target state="translated">如何删除文件中的最后N行?</target>
        </trans-unit>
        <trans-unit id="82c2c49b1820b2e4b306f272a2091aeedd8bf680" translate="yes" xml:space="preserve">
          <source>How do I determine whether a scalar is a number/whole/integer/float?</source>
          <target state="translated">如何确定一个标量是数字/整体/整数/浮点数?</target>
        </trans-unit>
        <trans-unit id="f65b76741f09d6f8756a10de0d88399c941d8dbe" translate="yes" xml:space="preserve">
          <source>How do I do (anything)?</source>
          <target state="translated">我怎么做(什么)?</target>
        </trans-unit>
        <trans-unit id="5a3899f947a018efe1a69e369cf5894457670072" translate="yes" xml:space="preserve">
          <source>How do I do a &lt;code&gt;tail -f&lt;/code&gt; in perl?</source>
          <target state="translated">如何在perl中执行 &lt;code&gt;tail -f&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="08d06a078c58ebbf0c5a4ee81c3c6214665f0e66" translate="yes" xml:space="preserve">
          <source>How do I do a tail -f in perl?</source>
          <target state="translated">如何在perl中做尾部-f?</target>
        </trans-unit>
        <trans-unit id="8a1d6beddae75cca1e0c47c227a5ded3e3a37f2c" translate="yes" xml:space="preserve">
          <source>How do I do fancy stuff with the keyboard/screen/mouse?</source>
          <target state="translated">如何用键盘/屏幕/鼠标做一些花哨的东西?</target>
        </trans-unit>
        <trans-unit id="beaabf13bf44c3d2a6f003d0da1ad9d016f78129" translate="yes" xml:space="preserve">
          <source>How do I dup() a filehandle in Perl?</source>
          <target state="translated">如何在Perl中dup()一个文件柄?</target>
        </trans-unit>
        <trans-unit id="c99c99752028698e07bd697c4f55f10aeb2574b2" translate="yes" xml:space="preserve">
          <source>How do I efficiently match many regular expressions at once?</source>
          <target state="translated">如何高效地同时匹配多个正则表达式?</target>
        </trans-unit>
        <trans-unit id="d8501dfb7a286a0bc3e79d726ff0aa33a83b4611" translate="yes" xml:space="preserve">
          <source>How do I expand function calls in a string?</source>
          <target state="translated">如何在字符串中展开函数调用?</target>
        </trans-unit>
        <trans-unit id="40ad9f6ac9837b05501210a465bcfa76304dce6b" translate="yes" xml:space="preserve">
          <source>How do I expand tabs in a string?</source>
          <target state="translated">如何在字符串中展开制表符?</target>
        </trans-unit>
        <trans-unit id="1794d4b7480b0f45fea6bded5c811dbf977507ba" translate="yes" xml:space="preserve">
          <source>How do I extract URLs?</source>
          <target state="translated">如何提取URL?</target>
        </trans-unit>
        <trans-unit id="4490e28bfd20b3131d4a6a9a43d5708c9217af3c" translate="yes" xml:space="preserve">
          <source>How do I extract selected columns from a string?</source>
          <target state="translated">如何从字符串中提取选定的列?</target>
        </trans-unit>
        <trans-unit id="5e9ce3143a0232dce445afb94a4cd2cbabc5866a" translate="yes" xml:space="preserve">
          <source>How do I fetch an HTML file?</source>
          <target state="translated">如何获取一个HTML文件?</target>
        </trans-unit>
        <trans-unit id="5874d66493051782bd5b330106175c43ebb7b6dd" translate="yes" xml:space="preserve">
          <source>How do I fetch/put an (S)FTP file?</source>
          <target state="translated">如何获取/投放(S)FTP文件?</target>
        </trans-unit>
        <trans-unit id="930fdbc050be8c4df7c4e53dd8aa59f284368264" translate="yes" xml:space="preserve">
          <source>How do I find matching/nesting anything?</source>
          <target state="translated">如何找到匹配/嵌套的东西?</target>
        </trans-unit>
        <trans-unit id="bc8fb538829e6c584fa0187f483d1bbaba9e7351" translate="yes" xml:space="preserve">
          <source>How do I find out if I'm running interactively or not?</source>
          <target state="translated">如何发现自己是否在交互式运行?</target>
        </trans-unit>
        <trans-unit id="67eefe0342c38d62f056273caef773f2b1d22382" translate="yes" xml:space="preserve">
          <source>How do I find out my hostname, domainname, or IP address?</source>
          <target state="translated">如何找到我的主机名、域名或IP地址?</target>
        </trans-unit>
        <trans-unit id="b35cce5c620df3c5213a5b63c9524655cbb9d4b9" translate="yes" xml:space="preserve">
          <source>How do I find out which operating system I'm running under?</source>
          <target state="translated">如何知道我在哪个操作系统下运行?</target>
        </trans-unit>
        <trans-unit id="01907eb2e6a268c88ab9c2c3bfb59105a7c7e3c4" translate="yes" xml:space="preserve">
          <source>How do I find the current century or millennium?</source>
          <target state="translated">如何找到当前的世纪或千年?</target>
        </trans-unit>
        <trans-unit id="3463510f64a1c5a49fcc37902eead9f9ac95605b" translate="yes" xml:space="preserve">
          <source>How do I find the day or week of the year?</source>
          <target state="translated">如何找到一年中的哪一天或哪一周?</target>
        </trans-unit>
        <trans-unit id="982d40212fc998a0686d78df9c4ba26898354f0e" translate="yes" xml:space="preserve">
          <source>How do I find the first array element for which a condition is true?</source>
          <target state="translated">如何找到第一个条件为真的数组元素?</target>
        </trans-unit>
        <trans-unit id="74e25e9ffe5b922252ebf9163105b704200cdbaf" translate="yes" xml:space="preserve">
          <source>How do I find the soundex value of a string?</source>
          <target state="translated">如何查找字符串的声母值?</target>
        </trans-unit>
        <trans-unit id="d5fb344779130b34177124faae9f510c7450c0be" translate="yes" xml:space="preserve">
          <source>How do I find the user's mail address?</source>
          <target state="translated">如何找到用户的邮件地址?</target>
        </trans-unit>
        <trans-unit id="9b5f48590c3589b927773b9f4489ef3e2df19ab7" translate="yes" xml:space="preserve">
          <source>How do I find which modules are installed on my system?</source>
          <target state="translated">如何查找系统中安装了哪些模块?</target>
        </trans-unit>
        <trans-unit id="db22bcad0e65ee82eb15cee813db7ad1bc862f74" translate="yes" xml:space="preserve">
          <source>How do I find yesterday's date?</source>
          <target state="translated">如何找到昨天的日期?</target>
        </trans-unit>
        <trans-unit id="f14d19d9f33ebecf97e59acd91f7a3e35d168a35" translate="yes" xml:space="preserve">
          <source>How do I flush/unbuffer an output filehandle? Why must I do this?</source>
          <target state="translated">如何刷新/取消缓冲一个输出文件柄?为什么我必须这样做?</target>
        </trans-unit>
        <trans-unit id="50ced00e1da5731e9f081395bef33daf71015cca" translate="yes" xml:space="preserve">
          <source>How do I fork a daemon process?</source>
          <target state="translated">如何fork一个守护进程?</target>
        </trans-unit>
        <trans-unit id="af1e555b8ad44f5ee09984b301d45f763b3ab693" translate="yes" xml:space="preserve">
          <source>How do I get a file's timestamp in perl?</source>
          <target state="translated">如何在perl中获取文件的时间戳?</target>
        </trans-unit>
        <trans-unit id="f416b305fcb8113d5bc19886df8b83bac5c89fb3" translate="yes" xml:space="preserve">
          <source>How do I get a random number between X and Y?</source>
          <target state="translated">如何获得X和Y之间的随机数?</target>
        </trans-unit>
        <trans-unit id="0f092c3cc9246e7de03f0d8e8c730fbe8df49215" translate="yes" xml:space="preserve">
          <source>How do I get the screen size?</source>
          <target state="translated">如何获得屏幕尺寸?</target>
        </trans-unit>
        <trans-unit id="c3313630d3f982060a390f5f1946717a57153c40" translate="yes" xml:space="preserve">
          <source>How do I handle binary data correctly?</source>
          <target state="translated">如何正确处理二进制数据?</target>
        </trans-unit>
        <trans-unit id="3d9eeab5302abcd051b9c7c58a10262f71b93d0d" translate="yes" xml:space="preserve">
          <source>How do I handle circular lists?</source>
          <target state="translated">如何处理循环列表?</target>
        </trans-unit>
        <trans-unit id="25bc3d27f1f1d3400779cec866f02e11e267bcde" translate="yes" xml:space="preserve">
          <source>How do I handle linked lists?</source>
          <target state="translated">如何处理链接列表?</target>
        </trans-unit>
        <trans-unit id="22ab3c17d49644f7643e768f33f866efb0521ae5" translate="yes" xml:space="preserve">
          <source>How do I install a &quot;DEVELOPER RELEASE&quot; of a module?</source>
          <target state="translated">如何安装模块的 &quot;Developer RELEASE&quot;?</target>
        </trans-unit>
        <trans-unit id="51ca5bd4b613176b7121cb512580f3d074cc9e12" translate="yes" xml:space="preserve">
          <source>How do I install a module and all its dependencies from the commandline, without being prompted for anything, despite my CPAN configuration (or lack thereof)?</source>
          <target state="translated">我如何从命令行安装一个模块及其所有的依赖关系,而不被提示任何内容,尽管我的CPAN配置(或没有)?</target>
        </trans-unit>
        <trans-unit id="332f266fa06f1a0ab802b1da5c10c6890675f4de" translate="yes" xml:space="preserve">
          <source>How do I install a module from CPAN?</source>
          <target state="translated">如何从CPAN安装模块?</target>
        </trans-unit>
        <trans-unit id="779b60119e9ac89f1b4bb8ccca7aa17790f78529" translate="yes" xml:space="preserve">
          <source>How do I keep my own module/library directory?</source>
          <target state="translated">如何保存自己的模块/库目录?</target>
        </trans-unit>
        <trans-unit id="712ff90db628f146b683448ab9a743ea57d1a8f1" translate="yes" xml:space="preserve">
          <source>How do I keep persistent data across program calls?</source>
          <target state="translated">如何在程序调用中保持数据的持久性?</target>
        </trans-unit>
        <trans-unit id="a20b09e11bad429f8e02c602624e45b441c22369" translate="yes" xml:space="preserve">
          <source>How do I look up a hash element by value?</source>
          <target state="translated">如何按值查询哈希元素?</target>
        </trans-unit>
        <trans-unit id="fc81f211ace7f04a35490b5be3fe4452ee1626e9" translate="yes" xml:space="preserve">
          <source>How do I make a system() exit on control-C?</source>
          <target state="translated">如何让control-C上的system()退出?</target>
        </trans-unit>
        <trans-unit id="58c641789837b76dd9abee18041837a328da4bf8" translate="yes" xml:space="preserve">
          <source>How do I make a temporary file name?</source>
          <target state="translated">如何制作临时文件名?</target>
        </trans-unit>
        <trans-unit id="f0fab6b039e898671e7205067775272f3896476e" translate="yes" xml:space="preserve">
          <source>How do I make sure users can't enter values into a form that causes my CGI script to do bad things?</source>
          <target state="translated">如何确保用户不能在表单中输入值,导致我的CGI脚本做坏事?</target>
        </trans-unit>
        <trans-unit id="9e83c97b2d0052618a071494ce58ad0aa5de46bd" translate="yes" xml:space="preserve">
          <source>How do I manipulate arrays of bits?</source>
          <target state="translated">如何操作比特数组?</target>
        </trans-unit>
        <trans-unit id="f91d0deef997d3bfa3ece796fb840e0045a0792b" translate="yes" xml:space="preserve">
          <source>How do I match XML, HTML, or other nasty, ugly things with a regex?</source>
          <target state="translated">如何用regex匹配XML、HTML或其他讨厌的、丑陋的东西?</target>
        </trans-unit>
        <trans-unit id="9e10d6b9fcc0dce9241e02f9e3f41bcdabf8cf6b" translate="yes" xml:space="preserve">
          <source>How do I match a regular expression that's in a variable?</source>
          <target state="translated">如何匹配变量中的正则表达式?</target>
        </trans-unit>
        <trans-unit id="5d4e304caa9da74ae39c7e0f1bc8a660a934e36b" translate="yes" xml:space="preserve">
          <source>How do I merge two hashes?</source>
          <target state="translated">如何合并两个哈希值?</target>
        </trans-unit>
        <trans-unit id="e98a867a19e12d012764c76bf6e04f0613af63d6" translate="yes" xml:space="preserve">
          <source>How do I modify the shadow password file on a Unix system?</source>
          <target state="translated">如何修改Unix系统上的影子密码文件?</target>
        </trans-unit>
        <trans-unit id="c7095e8729e8a7f2287429c858bc0e6162426248" translate="yes" xml:space="preserve">
          <source>How do I multiply matrices?</source>
          <target state="translated">矩阵怎么乘法?</target>
        </trans-unit>
        <trans-unit id="9460689c66cd7c2602f152fc7b62b5a75f54acdd" translate="yes" xml:space="preserve">
          <source>How do I open a file without blocking?</source>
          <target state="translated">如何不被屏蔽地打开文件?</target>
        </trans-unit>
        <trans-unit id="9724c57d7e62b1229f27e461cfe00d869c775e7e" translate="yes" xml:space="preserve">
          <source>How do I pack arrays of doubles or floats for XS code?</source>
          <target state="translated">如何在XS代码中打包双数组或浮动数组?</target>
        </trans-unit>
        <trans-unit id="4400dc02ad15b6fc00f373b7446035015d4ee6bf" translate="yes" xml:space="preserve">
          <source>How do I pad a string with blanks or pad a number with zeroes?</source>
          <target state="translated">如何在字符串中垫上空格或在数字中垫上零?</target>
        </trans-unit>
        <trans-unit id="d0e3e8a036359d14fc456cf2c14236b5f608bd62" translate="yes" xml:space="preserve">
          <source>How do I parse a mail header?</source>
          <target state="translated">如何解析邮件头?</target>
        </trans-unit>
        <trans-unit id="9e0cafd923d528d129dae6e8757b0045ebfe45d2" translate="yes" xml:space="preserve">
          <source>How do I perform an operation on a series of integers?</source>
          <target state="translated">如何对一系列整数进行操作?</target>
        </trans-unit>
        <trans-unit id="0ea5e302520f6bb39c41ab5c626ec6b77bff9c77" translate="yes" xml:space="preserve">
          <source>How do I permute N elements of a list?</source>
          <target state="translated">如何对一个列表中的N个元素进行置换?</target>
        </trans-unit>
        <trans-unit id="5b942fa715d105d63d048d010625e34a4e15cc06" translate="yes" xml:space="preserve">
          <source>How do I print out or copy a recursive data structure?</source>
          <target state="translated">如何打印出或复制递归数据结构?</target>
        </trans-unit>
        <trans-unit id="0cee12c0d629b76061795de4e8ea8e8aad20c9a2" translate="yes" xml:space="preserve">
          <source>How do I print something out in color?</source>
          <target state="translated">如何打印出彩色的东西?</target>
        </trans-unit>
        <trans-unit id="8c5e011ff87e317620443254f20726209e4d5142" translate="yes" xml:space="preserve">
          <source>How do I print to more than one file at once?</source>
          <target state="translated">如何同时打印到多个文件?</target>
        </trans-unit>
        <trans-unit id="8e6e30c99d7d46a63b6dd2a8de7f090b5c3b78f8" translate="yes" xml:space="preserve">
          <source>How do I process an entire hash?</source>
          <target state="translated">如何处理整个哈希值?</target>
        </trans-unit>
        <trans-unit id="271b9d3d652ec230aba0c388cad00cfb6ec4cadb" translate="yes" xml:space="preserve">
          <source>How do I process each word on each line?</source>
          <target state="translated">如何处理每一行的每个字?</target>
        </trans-unit>
        <trans-unit id="067d5b88bfca3ed1b6b7d97cd252f5dd16cbb5b2" translate="yes" xml:space="preserve">
          <source>How do I process/modify each element of an array?</source>
          <target state="translated">如何处理/修改数组中的每个元素?</target>
        </trans-unit>
        <trans-unit id="4b013be3c59b874a12db528d39cfb66ea2b4d285" translate="yes" xml:space="preserve">
          <source>How do I profile my Perl programs?</source>
          <target state="translated">如何对我的Perl程序进行配置文件?</target>
        </trans-unit>
        <trans-unit id="907ce6af6f55d655a78f0e8c0ae363954d37ba4f" translate="yes" xml:space="preserve">
          <source>How do I put a &quot;-?&quot; option into a Getopt::Long?</source>
          <target state="translated">如何在Getopt::Long中加入&quot;-?&quot;选项?</target>
        </trans-unit>
        <trans-unit id="c7fe97c54150572fb4431657021f14d59fd4861f" translate="yes" xml:space="preserve">
          <source>How do I put a password on my web pages?</source>
          <target state="translated">如何在网页上设置密码?</target>
        </trans-unit>
        <trans-unit id="aabceca15e4a4d5d9ca824c2b010057c5ffb938d" translate="yes" xml:space="preserve">
          <source>How do I randomly update a binary file?</source>
          <target state="translated">如何随机更新二进制文件?</target>
        </trans-unit>
        <trans-unit id="be52f21f6d10d6ab8f3f91d7f9754bf001810264" translate="yes" xml:space="preserve">
          <source>How do I read and write the serial port?</source>
          <target state="translated">如何对串口进行读写?</target>
        </trans-unit>
        <trans-unit id="88cf95522fd81b968df3c101e350990093c3aa09" translate="yes" xml:space="preserve">
          <source>How do I read email?</source>
          <target state="translated">如何阅读邮件?</target>
        </trans-unit>
        <trans-unit id="f7f8ec70d59120dd78e53b84aba791742e9edd1e" translate="yes" xml:space="preserve">
          <source>How do I read just one key without waiting for a return key?</source>
          <target state="translated">如何只读一个键而不等待返回键?</target>
        </trans-unit>
        <trans-unit id="90d36808740d961fdd3bc4db24c2ee814f31ee7c" translate="yes" xml:space="preserve">
          <source>How do I redefine a builtin function, operator, or method?</source>
          <target state="translated">如何重新定义一个内置函数、操作符或方法?</target>
        </trans-unit>
        <trans-unit id="64b8d2bb065ca77fe0dc5f5fef705f4b317c4fca" translate="yes" xml:space="preserve">
          <source>How do I redirect to another page?</source>
          <target state="translated">如何重定向到其他页面?</target>
        </trans-unit>
        <trans-unit id="0261e937b4173727b02c00645ba76e6a415fae20" translate="yes" xml:space="preserve">
          <source>How do I reformat a paragraph?</source>
          <target state="translated">如何重新安排段落的格式?</target>
        </trans-unit>
        <trans-unit id="0eeeab64d2dc7e3dd771f347a9a11591454f54b3" translate="yes" xml:space="preserve">
          <source>How do I remove HTML from a string?</source>
          <target state="translated">如何从字符串中删除HTML?</target>
        </trans-unit>
        <trans-unit id="7190f2c95452c7e338420c52915e20b7f528657f" translate="yes" xml:space="preserve">
          <source>How do I remove consecutive pairs of characters?</source>
          <target state="translated">如何删除连续的字符对?</target>
        </trans-unit>
        <trans-unit id="d5da8d0925bfcf1ec95ecac71470e320a20303f5" translate="yes" xml:space="preserve">
          <source>How do I reset an each() operation part-way through?</source>
          <target state="translated">如何在中途重置each()操作?</target>
        </trans-unit>
        <trans-unit id="344b42394088d6a1b32ccef3d8e8decb8e4c01b4" translate="yes" xml:space="preserve">
          <source>How do I reverse a string?</source>
          <target state="translated">如何反串?</target>
        </trans-unit>
        <trans-unit id="c109790cdec5d8d7c505dc674edb8df7914a81e2" translate="yes" xml:space="preserve">
          <source>How do I select a random element from an array?</source>
          <target state="translated">如何从一个数组中选择一个随机元素?</target>
        </trans-unit>
        <trans-unit id="199c93de57e75c85ebb9d101614dabcde24b6614" translate="yes" xml:space="preserve">
          <source>How do I select a random line from a file?</source>
          <target state="translated">如何从文件中随机选择一行?</target>
        </trans-unit>
        <trans-unit id="39ccafc4ea9b3fd7b952612609873f9c549c7c42" translate="yes" xml:space="preserve">
          <source>How do I send email?</source>
          <target state="translated">如何发送电子邮件?</target>
        </trans-unit>
        <trans-unit id="56fc4c1960e173cac75e9d994591b6be91c2c2f5" translate="yes" xml:space="preserve">
          <source>How do I set CPU limits?</source>
          <target state="translated">如何设置CPU限制?</target>
        </trans-unit>
        <trans-unit id="73ae95585e094adfdbb75ef9f256a18859cff476" translate="yes" xml:space="preserve">
          <source>How do I set a file's timestamp in perl?</source>
          <target state="translated">如何在perl中设置文件的时间戳?</target>
        </trans-unit>
        <trans-unit id="7015da22cf6dfd7afb1594ce5e8862f937d3b755" translate="yes" xml:space="preserve">
          <source>How do I set the time and date?</source>
          <target state="translated">如何设置时间和日期?</target>
        </trans-unit>
        <trans-unit id="36b77dc941cd48cd98a47f8dbd2c57de165d3aa2" translate="yes" xml:space="preserve">
          <source>How do I shuffle an array randomly?</source>
          <target state="translated">如何随机洗牌一个数组?</target>
        </trans-unit>
        <trans-unit id="c56fb4f98404c5161610269f73993e7de95a3de7" translate="yes" xml:space="preserve">
          <source>How do I skip some return values?</source>
          <target state="translated">如何跳过一些返回值?</target>
        </trans-unit>
        <trans-unit id="f999ee460d48e77fd71574c2f54756bd21091885" translate="yes" xml:space="preserve">
          <source>How do I sort a hash (optionally by value instead of key)?</source>
          <target state="translated">我如何对哈希进行排序(可以选择用值代替键)?</target>
        </trans-unit>
        <trans-unit id="3557025618ab23a2cf788475e1bcca26065db241" translate="yes" xml:space="preserve">
          <source>How do I sort an array by (anything)?</source>
          <target state="translated">如何通过(任何东西)对一个数组进行排序?</target>
        </trans-unit>
        <trans-unit id="11e9e959693213fc786f53e3eeef7ea5001cbb5a" translate="yes" xml:space="preserve">
          <source>How do I start a process in the background?</source>
          <target state="translated">如何在后台启动一个进程?</target>
        </trans-unit>
        <trans-unit id="e8df49adcf72001a3aba0a320e673d15d1fbff49" translate="yes" xml:space="preserve">
          <source>How do I store complex data structures with DB_File?</source>
          <target state="translated">如何使用DB_File存储复杂的数据结构?</target>
        </trans-unit>
        <trans-unit id="d0810d8592d3996c240e80dd3d6e5421e650a5a9" translate="yes" xml:space="preserve">
          <source>How do I strip blank space from the beginning/end of a string?</source>
          <target state="translated">如何从字符串的开头/结尾处去除空格?</target>
        </trans-unit>
        <trans-unit id="8ae8648605278dba0e8e66d1aa18bb02cd9cbee2" translate="yes" xml:space="preserve">
          <source>How do I substitute case-insensitively on the LHS while preserving case on the RHS?</source>
          <target state="translated">如何在保留RHS上的大小写的同时,在LHS上进行不敏感的替换?</target>
        </trans-unit>
        <trans-unit id="32d79b5f1ff74cbc3bfb77b42941e7971f7cd494" translate="yes" xml:space="preserve">
          <source>How do I tell the difference between errors from the shell and perl?</source>
          <target state="translated">如何区分shell和perl的错误?</target>
        </trans-unit>
        <trans-unit id="402cd06b394cf67e3d76498ee9b3e9b9d87437a0" translate="yes" xml:space="preserve">
          <source>How do I temporarily block warnings?</source>
          <target state="translated">如何临时屏蔽警告?</target>
        </trans-unit>
        <trans-unit id="c0789eca0c8fd61b4175e61db4aa71f599404e50" translate="yes" xml:space="preserve">
          <source>How do I test whether two arrays or hashes are equal?</source>
          <target state="translated">如何测试两个数组或哈希值是否相等?</target>
        </trans-unit>
        <trans-unit id="e84b81ceb7f858ca3fa98015c2c4dfea66af9e8b" translate="yes" xml:space="preserve">
          <source>How do I timeout a slow event?</source>
          <target state="translated">如何对慢速事件进行超时处理?</target>
        </trans-unit>
        <trans-unit id="e46e5cb6feaa9bdc58f6ceead41bdfe807157710" translate="yes" xml:space="preserve">
          <source>How do I trap control characters/signals?</source>
          <target state="translated">如何捕捉控制字符/信号?</target>
        </trans-unit>
        <trans-unit id="d2dd15b6c1b33b3c86eddf841d0c83120333ce34" translate="yes" xml:space="preserve">
          <source>How do I traverse a directory tree?</source>
          <target state="translated">如何遍历目录树?</target>
        </trans-unit>
        <trans-unit id="e9dd0c064f83a182ab0d7dad0b56b72fe36b708b" translate="yes" xml:space="preserve">
          <source>How do I unescape a string?</source>
          <target state="translated">如何解除对字符串的转义?</target>
        </trans-unit>
        <trans-unit id="de74f402e85f9eee7aa46222792929c66c3f3ab7" translate="yes" xml:space="preserve">
          <source>How do I use MIME to make an attachment to a mail message?</source>
          <target state="translated">我如何使用MIME来制作邮件附件?</target>
        </trans-unit>
        <trans-unit id="ec6da1c1f95c027b2d1444208c25f958dcd9f486" translate="yes" xml:space="preserve">
          <source>How do I use a regular expression to strip C-style comments from a file?</source>
          <target state="translated">如何使用正则表达式从文件中剥离C式注释?</target>
        </trans-unit>
        <trans-unit id="a8b6bf66c7856a15f241de6c0802175e07cd63b3" translate="yes" xml:space="preserve">
          <source>How do I use all this in extensions?</source>
          <target state="translated">如何在扩展中使用这些东西?</target>
        </trans-unit>
        <trans-unit id="b826b48e54f42be4d7b4af41a8de11eb743f6b7a" translate="yes" xml:space="preserve">
          <source>How do I use an SQL database?</source>
          <target state="translated">如何使用SQL数据库?</target>
        </trans-unit>
        <trans-unit id="2bdd87983f12ab09515439198b26c02b64e724f4" translate="yes" xml:space="preserve">
          <source>How do I validate input?</source>
          <target state="translated">如何验证输入?</target>
        </trans-unit>
        <trans-unit id="26964c4f36b19d9f1a78d8688cbdbdb4cea51cb7" translate="yes" xml:space="preserve">
          <source>How do I verify a credit card checksum?</source>
          <target state="translated">如何验证信用卡校验码?</target>
        </trans-unit>
        <trans-unit id="4f3796bf485f2eb722b7ed35a129d4469581633e" translate="yes" xml:space="preserve">
          <source>How do we do it? You might think first to use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;; however, since &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; collapses blank fields, you'll never know whether a record was income or expenditure. Oops. Well, you could always use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">我们该怎么做呢？您可能首先考虑使用 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; ; 但是，由于 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 折叠了空白字段，因此您永远不会知道记录是收入还是支出。哎呀。好吧，您可以始终使用 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="adb503b87f7ea09a8ed712efab2105d52de66798" translate="yes" xml:space="preserve">
          <source>How do we know if the &lt;code&gt;U&lt;/code&gt; is the first format in the &lt;code&gt;pat&lt;/code&gt; ? Well, if we have a pointer to the start of &lt;code&gt;pat&lt;/code&gt; then, if we see a &lt;code&gt;U&lt;/code&gt; we can test whether we're still at the start of the string. So, here's where &lt;code&gt;pat&lt;/code&gt; is set up:</source>
          <target state="translated">我们如何知道 &lt;code&gt;U&lt;/code&gt; 是否是 &lt;code&gt;pat&lt;/code&gt; 中的第一个格式？好吧，如果我们有一个指向 &lt;code&gt;pat&lt;/code&gt; 开头的指针，那么，如果看到一个 &lt;code&gt;U&lt;/code&gt; ,我们可以测试我们是否仍在字符串的开头。因此，这是 &lt;code&gt;pat&lt;/code&gt; 的设置位置：</target>
        </trans-unit>
        <trans-unit id="41c2d105be109eed3cac8eac59cfe5a2af927614" translate="yes" xml:space="preserve">
          <source>How do we prepare to fix this up? First we locate the code in question - the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; happens at runtime, so it's going to be in one of the</source>
          <target state="translated">我们如何准备解决此问题？首先，我们找到有问题的代码- &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 发生在运行时，因此它将位于其中一个</target>
        </trans-unit>
        <trans-unit id="24a7f470a36048c277bd60a862a28514c120a416" translate="yes" xml:space="preserve">
          <source>How do you know that you've made the right decisions? Have you picked an interface design that will cause problems later? Have you picked the most appropriate name? Do you have any questions?</source>
          <target state="translated">你怎么知道你的决策是正确的?你是否选择了一个以后会引起问题的界面设计?你选择了最合适的名字吗?你有什么问题吗?</target>
        </trans-unit>
        <trans-unit id="41a4f1d575f0f11ff6874b18c40b76daeb66d4c2" translate="yes" xml:space="preserve">
          <source>How do you print it out? Why can't you say just &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; @AoA&lt;/code&gt; ? How do you sort it? How can you pass it to a function or get one of these back from a function? Is it an object? Can you save it to disk to read back later? How do you access whole rows or columns of that matrix? Do all the values have to be numeric?</source>
          <target state="translated">您如何打印出来？为什么不说只 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; @AoA&lt;/code&gt; 呢？您如何排序？如何将其传递给函数或从函数中取回其中之一？是物体吗？您可以将其保存到磁盘以供日后阅读吗？您如何访问该矩阵的整个行或列？所有值都必须是数字吗？</target>
        </trans-unit>
        <trans-unit id="0db30a52c84584239974d26d09f54763e3e6b602" translate="yes" xml:space="preserve">
          <source>How do you want to capitalize those words?</source>
          <target state="translated">这些字要怎么大写?</target>
        </trans-unit>
        <trans-unit id="057ea76fe6b43747bac035e0aa618c75b67755d7" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;P&lt;/code&gt; work? Imagine some pointer in the buffer about to be unpacked: If it isn't the null pointer (which will smartly produce the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value) we have a start address - but then what? Perl has no way of knowing how long this &quot;fixed length string&quot; is, so it's up to you to specify the actual size as an explicit length after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">用 &lt;code&gt;P&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 如何工作？想象一下缓冲区中的一些指针即将被解包：如果它不是空指针（它将巧妙地产生 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值），我们就有一个起始地址-但是那又是什么呢？Perl无法知道此&amp;ldquo;固定长度字符串&amp;rdquo;有多长，因此由您决定将实际大小指定为 &lt;code&gt;P&lt;/code&gt; 之后的显式长度。</target>
        </trans-unit>
        <trans-unit id="9905196a168946e4c1e199eb5d4a39f1df926922" translate="yes" xml:space="preserve">
          <source>How does C3 work</source>
          <target state="translated">C3是如何工作的</target>
        </trans-unit>
        <trans-unit id="ec67f8e66f8cd607856093fe73d4e05432e16189" translate="yes" xml:space="preserve">
          <source>How does Perl compare with other languages like Java, Python, REXX, Scheme, or Tcl?</source>
          <target state="translated">Perl与Java、Python、REX、Scheme或Tcl等其他语言相比如何?</target>
        </trans-unit>
        <trans-unit id="1c4f7191bdf4e77d9f3df9d3633a24eb4798422b" translate="yes" xml:space="preserve">
          <source>How does Perl store UTF-8 strings?</source>
          <target state="translated">Perl如何存储UTF-8字符串?</target>
        </trans-unit>
        <trans-unit id="d6555d1bc4e0774734c01cf5a9778e9667013a49" translate="yes" xml:space="preserve">
          <source>How does UTF-8 represent Unicode characters?</source>
          <target state="translated">UTF-8如何表示Unicode字符?</target>
        </trans-unit>
        <trans-unit id="7cc6d699d794fc3ac271d46b893bbe5d8af9561d" translate="yes" xml:space="preserve">
          <source>How does the HAS_QUUX become defined where it needs to be? Well, if Foonix happens to be Unixy enough to be able to run the Configure script, and Configure has been taught about detecting and testing quux(), the HAS_QUUX will be correctly defined. In other platforms, the corresponding configuration step will hopefully do the same.</source>
          <target state="translated">如何定义HAS_QUUX?好吧,如果Foonix刚好是Unixy,能够运行Configure脚本,并且Configure已经学会了检测和测试quux(),HAS_QUUX就会被正确定义。在其他平台上,相应的配置步骤希望也能做到这一点。</target>
        </trans-unit>
        <trans-unit id="a7654b1f75662fbb39441273d3ed984d7a322d6a" translate="yes" xml:space="preserve">
          <source>How far up the call stack should &lt;code&gt;$Test&lt;/code&gt; look when reporting where the test failed.</source>
          <target state="translated">报告测试失败的位置时， &lt;code&gt;$Test&lt;/code&gt; 应该看多远的调用堆栈。</target>
        </trans-unit>
        <trans-unit id="085217ef4c6745e3415b3c7e78584430d39a3a20" translate="yes" xml:space="preserve">
          <source>How field hashes work</source>
          <target state="translated">字段哈希如何工作</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">运作方式</target>
        </trans-unit>
        <trans-unit id="0c8392c4bc182245c6112422d8ac379f29dc0269" translate="yes" xml:space="preserve">
          <source>How many days shall we keep statistics about downloads?</source>
          <target state="translated">我们要统计多少天的下载量?</target>
        </trans-unit>
        <trans-unit id="a2df7a98d6c586141cd04b6aa0105c17934a6b57" translate="yes" xml:space="preserve">
          <source>How many items shall we keep in the statistics about downloads?</source>
          <target state="translated">我们应该在下载统计中保留多少项目?</target>
        </trans-unit>
        <trans-unit id="a4c476d15c4f91ec82f82f8c5a4b611455926ad6" translate="yes" xml:space="preserve">
          <source>How many things you have to skip over when moving from the beginning of a string or array to a specific position within it. Thus, the minimum offset is zero, not one, because you don&amp;rsquo;t skip anything to get to the first item.</source>
          <target state="translated">从字符串或数组的开头移至字符串中的特定位置时，您必须跳过多少件事。因此，最小偏移量为零，而不是一个，因为您无需跳过任何内容即可获得第一项。</target>
        </trans-unit>
        <trans-unit id="06d061df76ab13c25cd39004271d0f48f24f772c" translate="yes" xml:space="preserve">
          <source>How multiple interpreters and concurrency are supported</source>
          <target state="translated">如何支持多解释器和并发性</target>
        </trans-unit>
        <trans-unit id="6077b2c6a621300c72c26286304312a48389905e" translate="yes" xml:space="preserve">
          <source>How often are new versions of Perl released?</source>
          <target state="translated">Perl 的新版本多久发布一次?</target>
        </trans-unit>
        <trans-unit id="09667313848c3831b4f83a58be79ca17489cfe27" translate="yes" xml:space="preserve">
          <source>How stable is Perl?</source>
          <target state="translated">Perl的稳定性如何?</target>
        </trans-unit>
        <trans-unit id="83c34a283446a710c37e72f2a9adb47d8902892c" translate="yes" xml:space="preserve">
          <source>How that string gets evaluated is entirely subject to the command interpreter on your system. On most platforms, you will have to protect shell metacharacters if you want them treated literally. This is in practice difficult to do, as it's unclear how to escape which characters. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for a clean and safe example of a manual &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; to emulate backticks safely.</source>
          <target state="translated">字符串的求值方式完全取决于系统上的命令解释器。在大多数平台上，如果要按字面意义对待外壳元字符，则必须保护它们。在实践中，这很难做到，因为尚不清楚如何转义哪些字符。请参阅&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;，以获取有关干净安全的手动 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 示例，以安全地模拟反引号。</target>
        </trans-unit>
        <trans-unit id="32e58ed61895689f9ea71e1d65dd7b363842c21f" translate="yes" xml:space="preserve">
          <source>How to Eat an Egg on a Net</source>
          <target state="translated">网购鸡蛋怎么吃</target>
        </trans-unit>
        <trans-unit id="1e92c63bea5bacbfe17288aa9b727bd5b57d76ef" translate="yes" xml:space="preserve">
          <source>How to Export</source>
          <target state="translated">如何出口</target>
        </trans-unit>
        <trans-unit id="c94aa75d1f562c0c7126364d18c31a48ccae10ce" translate="yes" xml:space="preserve">
          <source>How to Import</source>
          <target state="translated">如何导入</target>
        </trans-unit>
        <trans-unit id="66e5306e1ee37b9c8432fab22e675761fdae05d9" translate="yes" xml:space="preserve">
          <source>How to build it - possible changes to Makefile.PL etc.</source>
          <target state="translated">如何构建它--可能对Makefile.PL等进行修改。</target>
        </trans-unit>
        <trans-unit id="ca504da3ad384a1782b8a80c01519809d8213b8a" translate="yes" xml:space="preserve">
          <source>How to contribute to the perlfaq</source>
          <target state="translated">如何为perlfaq做贡献</target>
        </trans-unit>
        <trans-unit id="59750c3fc03389b5d7028878d6d502ec39f41a63" translate="yes" xml:space="preserve">
          <source>How to create a new module</source>
          <target state="translated">如何创建一个新模块</target>
        </trans-unit>
        <trans-unit id="117233b2c5097bb47b4e325f79c07984d73d5ef7" translate="yes" xml:space="preserve">
          <source>How to get a package, unwrap it, and make a change before building it?</source>
          <target state="translated">如何拿到包裹,拆开包装,进行修改后再建?</target>
        </trans-unit>
        <trans-unit id="581ecead393f1357725f2a7ad157c2752daf62ea" translate="yes" xml:space="preserve">
          <source>How to install it.</source>
          <target state="translated">如何安装。</target>
        </trans-unit>
        <trans-unit id="745ad195185248d449699ab965e2e195908cc3f7" translate="yes" xml:space="preserve">
          <source>How to release and distribute a module.</source>
          <target state="translated">如何发布和分发一个模块。</target>
        </trans-unit>
        <trans-unit id="fac65371d245ce74fd54b584511aa21b655f4973" translate="yes" xml:space="preserve">
          <source>How to report errors. &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; says to throw an exception on any POD formatting error. &lt;code&gt;stderr&lt;/code&gt; says to report errors on standard error, but not to throw an exception. &lt;code&gt;pod&lt;/code&gt; says to include a POD ERRORS section in the resulting documentation summarizing the errors. &lt;code&gt;none&lt;/code&gt; ignores POD errors entirely, as much as possible.</source>
          <target state="translated">如何报告错误。 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 说对任何POD格式化错误都抛出异常。 &lt;code&gt;stderr&lt;/code&gt; 说要报告有关标准错误的错误，但不要引发异常。 &lt;code&gt;pod&lt;/code&gt; 说在结果文档中包括POD ERRORS部分，以总结错误。 &lt;code&gt;none&lt;/code&gt; 完全忽略POD错误。</target>
        </trans-unit>
        <trans-unit id="d7d2e49b42408e54cf7a34c3e80635f480f9c4a8" translate="yes" xml:space="preserve">
          <source>How to use Field Hashes</source>
          <target state="translated">如何使用领域哈希值</target>
        </trans-unit>
        <trans-unit id="fc1ff928efd359368d94e6d36c9ac3ed9b57df61" translate="yes" xml:space="preserve">
          <source>How to use ppport.h</source>
          <target state="translated">如何使用pport.h</target>
        </trans-unit>
        <trans-unit id="76a1aee9e2d87dca5af8b9f3523a520421f66d36" translate="yes" xml:space="preserve">
          <source>How to use the perlfaq</source>
          <target state="translated">如何使用perlfaq</target>
        </trans-unit>
        <trans-unit id="3f24180ceba0ec0cc68f9d5c0e1e26d52c83ce1f" translate="yes" xml:space="preserve">
          <source>How you access/control keyboards, screens, and pointing devices (&quot;mice&quot;) is system-dependent. Try the following modules:</source>
          <target state="translated">如何访问/控制键盘、屏幕和指向设备(&quot;鼠标&quot;)取决于系统。请尝试以下模块。</target>
        </trans-unit>
        <trans-unit id="4bc300db17dcedeb6194b557a3ba400e45f35668" translate="yes" xml:space="preserve">
          <source>How you choose to license your work is a personal decision. The general mechanism is to assert your Copyright and then make a declaration of how others may copy/use/modify your work.</source>
          <target state="translated">你如何选择许可你的作品是个人的决定,一般的机制是维护你的版权,然后声明他人如何复制/使用/修改你的作品。一般的机制是维护您的版权,然后声明他人如何复制/使用/修改您的作品。</target>
        </trans-unit>
        <trans-unit id="eb2f13a23bf4830d2fc62239cefe549717cd58f6" translate="yes" xml:space="preserve">
          <source>How your various pieces of data relate to each other and what shape they make when you put them all together, as in a rectangular table or a triangular tree.</source>
          <target state="translated">你的各种数据之间的关系,以及当你把它们放在一起时,它们会变成什么形状,如长方形的表格或三角形的树。</target>
        </trans-unit>
        <trans-unit id="d3b89735ac32202767302de6090cfe3b522ac706" translate="yes" xml:space="preserve">
          <source>However adding a Time::Piece object to another Time::Piece object will cause a runtime error.</source>
          <target state="translated">然而,将一个Time::Piece对象添加到另一个Time::Piece对象中会导致运行时错误。</target>
        </trans-unit>
        <trans-unit id="30f041c654fc533b28dcc332c81f8669c3b80359" translate="yes" xml:space="preserve">
          <source>However any other combinations of &lt;code&gt;\&lt;/code&gt; followed by a character are not substituted but only skipped, in order to parse them as regular expressions at the following step. As &lt;code&gt;\c&lt;/code&gt; is skipped at this step, &lt;code&gt;@&lt;/code&gt; of &lt;code&gt;\c@&lt;/code&gt; in RE is possibly treated as an array symbol (for example &lt;code&gt;@foo&lt;/code&gt; ), even though the same text in &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; gives interpolation of &lt;code&gt;\c@&lt;/code&gt; .</source>
          <target state="translated">但是，不会替换 &lt;code&gt;\&lt;/code&gt; 后跟一个字符的任何其他组合，而是仅将其跳过，以便在下一步将它们解析为正则表达式。如 &lt;code&gt;\c&lt;/code&gt; 被跳过在该步骤中， &lt;code&gt;@&lt;/code&gt; 的 &lt;code&gt;\c@&lt;/code&gt; 在RE中可能视为一个阵列的符号（例如 &lt;code&gt;@foo&lt;/code&gt; ），即使在相同的文字 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; 给出了内插 &lt;code&gt;\c@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16e29f719714863d70b942d575046dbb5cba98f5" translate="yes" xml:space="preserve">
          <source>However calling these methods only affects the use of the methods above that can return a data connection. They have no effect on methods &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;put_unique&lt;/code&gt; and those that do not require data connections.</source>
          <target state="translated">但是，调用这些方法只会影响上面可以返回数据连接的方法的使用。它们对 &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;put&lt;/code&gt; ， &lt;code&gt;put_unique&lt;/code&gt; 方法以及不需要数据连接的方法没有影响。</target>
        </trans-unit>
        <trans-unit id="4dd9e96cfe2926dfabdbc85765517e42ef1d89e7" translate="yes" xml:space="preserve">
          <source>However if you use them for methods it is up to you to figure out how to make inheritance work.)</source>
          <target state="translated">然而,如果你把它们用于方法,那就得靠你自己去想办法让继承发挥作用了)。)</target>
        </trans-unit>
        <trans-unit id="3eb546f277a4853248567d6d99dbadcec1483c0f" translate="yes" xml:space="preserve">
          <source>However it is possible to :</source>
          <target state="translated">然而,它是可以:</target>
        </trans-unit>
        <trans-unit id="b048a4ce1b3f69d17018ba3c836a5e60080a819e" translate="yes" xml:space="preserve">
          <source>However the parent classes are set, the package's &lt;code&gt;@ISA&lt;/code&gt; variable will contain a list of those parents. This is simply a list of scalars, each of which is a string that corresponds to a package name.</source>
          <target state="translated">但是，设置了父类后，程序包的 &lt;code&gt;@ISA&lt;/code&gt; 变量将包含这些父类的列表。这只是一个标量列表，每个标量是一个与包名称相对应的字符串。</target>
        </trans-unit>
        <trans-unit id="ba3e62d1138ee32c59c072f255ef49bd8748a854" translate="yes" xml:space="preserve">
          <source>However the results of other styles of rounding differ if the digit immediately to the right of the rounding place (skipping the decimal point) is 5 and if there are no digits, or no digits other than 0, after that 5. In such cases:</source>
          <target state="translated">然而其他样式的四舍五入的结果是不一样的,如果紧靠四舍五入位右边的数字(跳过小数点)是5,如果5之后没有数字,或者没有0以外的数字,在这种情况下。</target>
        </trans-unit>
        <trans-unit id="4fbf8823a3b3cfa62eaf7d0dd429a9afbd37439d" translate="yes" xml:space="preserve">
          <source>However the test engine bleeds these message to screen in unexpected moments. Two messages of this kind</source>
          <target state="translated">然而测试引擎会在意想不到的时刻将这些消息流到屏幕上。这类信息有两条</target>
        </trans-unit>
        <trans-unit id="ef8fc937e43b67ff40714fcd8d7fd4e3c6c06fbf" translate="yes" xml:space="preserve">
          <source>However you should never rely on the numerical position of any opcode within the opset. In other words both sides of a bit vector operator should be opsets returned from Opcode functions.</source>
          <target state="translated">然而,你永远不应该依赖任何操作码在操作集中的数值位置。换句话说,位向量运算符的两边应该是Opcode函数返回的运算集。</target>
        </trans-unit>
        <trans-unit id="98648e73024116127cb39bd5de118b8a0a2cc6ca" translate="yes" xml:space="preserve">
          <source>However, Filter::Simple is smart enough to notice your existing &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; and Do The Right Thing with it. That is, if you explicitly define an &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine in a package that's using Filter::Simple, that &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine will still be invoked immediately after any filter you install.</source>
          <target state="translated">但是，Filter :: Simple足够聪明，可以注意到您现有的 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 并使用它来做正确的事。也就是说，如果您在使用Filter :: Simple的程序包中显式定义了 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程，则在安装任何过滤器后仍会立即调用该 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程。</target>
        </trans-unit>
        <trans-unit id="c4b48fb21a2bbb8cdba9c4ae239ab0a9635d85aa" translate="yes" xml:space="preserve">
          <source>However, Perl supports Unicode, see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">但是，Perl支持Unicode，请参阅&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6aacf8e8d0ef0c63358a4dd55406f6405076e03d" translate="yes" xml:space="preserve">
          <source>However, a dynamically loaded Perl extension is forced to use some symbols from the perl executable, e.g., to know how to find the arguments to the functions: the arguments live on the perl internal evaluation stack. The solution is to put the main code of the interpreter into a DLL, and make the</source>
          <target state="translated">然而,一个动态加载的Perl扩展不得不使用perl可执行文件中的一些符号,例如,要知道如何找到函数的参数:参数活在perl内部的评估栈中。解决的办法是把解释器的主要代码放到一个 DLL 中,然后把它的</target>
        </trans-unit>
        <trans-unit id="cb42fd65a00722a5c95e1e740839f3eb31964f36" translate="yes" xml:space="preserve">
          <source>However, a misapplied space-to-NBSP replacement could (wrongly) produce something equivalent to this:</source>
          <target state="translated">然而,错误地应用空间到NBSP的替换可能(错误地)产生与此相当的东西。</target>
        </trans-unit>
        <trans-unit id="81448f13f8166a4612eb5d956580cdb8ee3e6da5" translate="yes" xml:space="preserve">
          <source>However, a value assigned to &lt;code&gt;$(&lt;/code&gt; must be a single number used to set the real gid. So the value given by &lt;code&gt;$(&lt;/code&gt; should</source>
          <target state="translated">但是，分配给 &lt;code&gt;$(&lt;/code&gt; 的值必须是用于设置实际gid的单个数字。因此 &lt;code&gt;$(&lt;/code&gt; 给定的值应</target>
        </trans-unit>
        <trans-unit id="2623bb5aade26c0a0ddb97e7e99b8d0d79bed6e1" translate="yes" xml:space="preserve">
          <source>However, anyone particularly interested in getting the full value of the treelet, can just traverse the content of the treeleet @$treelet_object. To wit:</source>
          <target state="translated">然而,任何特别想得到树状小树的全部价值的人,可以直接遍历树状小树的内容@$treelet_object。即</target>
        </trans-unit>
        <trans-unit id="120fef724fd1ad9704e66311dce9e65e6c74f159" translate="yes" xml:space="preserve">
          <source>However, as an 80% solution it is still effective, as it has caught bugs in the past.</source>
          <target state="translated">不过,作为80%的解决方案,它还是很有效的,因为它过去也抓过BUG。</target>
        </trans-unit>
        <trans-unit id="dc3b493b7bf70efb7fa8d258ead45b41c49f7ae9" translate="yes" xml:space="preserve">
          <source>However, because there are</source>
          <target state="translated">然而,由于有</target>
        </trans-unit>
        <trans-unit id="fd72d7b069cc72d81b73b3f8597e881a55bd64a6" translate="yes" xml:space="preserve">
          <source>However, calling any &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; methods in such an &lt;code&gt;END&lt;/code&gt; block will most likely</source>
          <target state="translated">但是，最有可能在此类 &lt;code&gt;END&lt;/code&gt; 块中调用任何&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;方法</target>
        </trans-unit>
        <trans-unit id="c314b40d0f00ce73038bbcc98e7f0ca7b1457690" translate="yes" xml:space="preserve">
          <source>However, for the following, the items are already shared, so their references are added directly to the queue, and no cloning takes place:</source>
          <target state="translated">但是,对于下面的项目来说,这些项目已经是共享的,所以它们的引用会直接添加到队列中,而不会发生克隆。</target>
        </trans-unit>
        <trans-unit id="bdc1303f64a141ea4136f512c4911ecba9b92d10" translate="yes" xml:space="preserve">
          <source>However, for the one-off simple case where I don't want to pull out a full templating system, I'll use a string that has two Perl scalar variables in it. In this example, I want to expand &lt;code&gt;$foo&lt;/code&gt; and &lt;code&gt;$bar&lt;/code&gt; to their variable's values:</source>
          <target state="translated">但是，对于一次性的简单情况，我不想使用完整的模板系统，我将使用其中包含两个Perl标量变量的字符串。在此示例中，我想将 &lt;code&gt;$foo&lt;/code&gt; 和 &lt;code&gt;$bar&lt;/code&gt; 扩展为其变量的值：</target>
        </trans-unit>
        <trans-unit id="5ff029079aabc6f922c78c4701467310a318c5e3" translate="yes" xml:space="preserve">
          <source>However, if a Perl script begins with the Unicode &lt;code&gt;BOM&lt;/code&gt; (UTF-16LE, UTF16-BE, or UTF-8), or if the script looks like non-&lt;code&gt;BOM&lt;/code&gt; -marked UTF-16 of either endianness, Perl will correctly read in the script as the appropriate Unicode encoding. (&lt;code&gt;BOM&lt;/code&gt; -less UTF-8 cannot be effectively recognized or differentiated from ISO 8859-1 or other eight-bit encodings.)</source>
          <target state="translated">但是，如果Perl脚本以Unicode &lt;code&gt;BOM&lt;/code&gt; （UTF-16LE，UTF16-BE或UTF-8）开头，或者该脚本看起来像是非 &lt;code&gt;BOM&lt;/code&gt; 表标记的任一字节序的UTF-16，则Perl会正确读取脚本作为适当的Unicode编码。（无 &lt;code&gt;BOM&lt;/code&gt; 的 UTF-8无法有效识别或与ISO 8859-1或其他八位编码区分开。）</target>
        </trans-unit>
        <trans-unit id="7a530119f7016cecda2473b0ac614ce58e818515" translate="yes" xml:space="preserve">
          <source>However, if a particular species of quote character is included in the delimiter specification, then that type of quote will be correctly handled. for example, if &lt;code&gt;$text&lt;/code&gt; is:</source>
          <target state="translated">但是，如果定界符规范中包含特殊种类的引号字符，则将正确处理该类型的引号。例如，如果 &lt;code&gt;$text&lt;/code&gt; 为：</target>
        </trans-unit>
        <trans-unit id="9e2ebae72b3d33fdf44dedb85d641ca00f3f57a1" translate="yes" xml:space="preserve">
          <source>However, if all you want to do is change your time zone, you can probably get away with setting an environment variable:</source>
          <target state="translated">然而,如果你只想改变时区,你也许可以通过设置一个环境变量来解决。</target>
        </trans-unit>
        <trans-unit id="e12d8527d56fa8ab8e8667f75a93e6392109725d" translate="yes" xml:space="preserve">
          <source>However, if hitting EOF is an expected and normal event, you do not want to exit simply because you have run out of input. Instead, you probably just want to exit an input loop. You can then test to see if an actual error has caused the loop to terminate, and act accordingly:</source>
          <target state="translated">然而,如果打到EOF是一个预期和正常的事件,你不希望仅仅因为你已经用完了输入而退出。相反,你可能只是想退出一个输入循环。然后,您可以测试是否有实际错误导致循环终止,并采取相应的行动。</target>
        </trans-unit>
        <trans-unit id="29e1fafc250caebd597211caeac2164bfd06193d" translate="yes" xml:space="preserve">
          <source>However, if the &lt;code&gt;]&lt;/code&gt; is the</source>
          <target state="translated">但是，如果 &lt;code&gt;]&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="8b420ee9db4dd8d8741d24e9570ff42a7cdea42c" translate="yes" xml:space="preserve">
          <source>However, if the command contained arguments that contained whitespace, stringifying the command would lose the significance of the whitespace. Therefore, &lt;code&gt;IPC::Cmd&lt;/code&gt; will quote any arguments containing whitespace in your command if the command is passed as an arrayref and contains special characters.</source>
          <target state="translated">但是，如果命令包含包含空格的参数，则对命令进行字符串化将失去空格的意义。因此，如果命令作为arrayref传递并且包含特殊字符，则 &lt;code&gt;IPC::Cmd&lt;/code&gt; 将在命令中引用任何包含空格的参数。</target>
        </trans-unit>
        <trans-unit id="6cc1c4bf7e539678ba51b5fda046a8f31ec28dde" translate="yes" xml:space="preserve">
          <source>However, if the data can't be parsed as valid Perl, then it is passed as an uninterpreted string. For example:</source>
          <target state="translated">但是,如果数据不能被解析为有效的Perl,那么就会以未解释的字符串形式传递。例如</target>
        </trans-unit>
        <trans-unit id="713c4744650ad1f6870512c16d626634ea8370be" translate="yes" xml:space="preserve">
          <source>However, if the input text was passed in a variable, that variable's &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; value is updated to point at the first character after the extracted text. That means that in a list context the various subroutines can be used much like regular expressions. For example:</source>
          <target state="translated">但是，如果输入文本在变量中传递，则该变量的 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 值将更新为指向提取的文本之后的第一个字符。这意味着在列表上下文中，可以像正则表达式一样使用各种子例程。例如：</target>
        </trans-unit>
        <trans-unit id="755d5a289c3e42c14904a4a718307f0b6e480799" translate="yes" xml:space="preserve">
          <source>However, if the kernel set-id script feature isn't disabled, Perl will complain loudly that your set-id script is insecure. You'll need to either disable the kernel set-id script feature, or put a C wrapper around the script. A C wrapper is just a compiled program that does nothing except call your Perl program. Compiled programs are not subject to the kernel bug that plagues set-id scripts. Here's a simple wrapper, written in C:</source>
          <target state="translated">然而,如果内核的set-id脚本功能没有被禁用,Perl会大声抱怨你的set-id脚本不安全。你需要禁用内核 set-id 脚本功能,或者在脚本周围加上一个 C 封装器。C包装器只是一个编译程序,除了调用你的Perl程序之外,什么都不做。编译后的程序不会受到困扰set-id脚本的内核错误的影响。这里有一个简单的封装程序,用C语言写的。</target>
        </trans-unit>
        <trans-unit id="cbc9ddee054ab9351fcec45d24db4192d4d2775c" translate="yes" xml:space="preserve">
          <source>However, if the list element is itself a variable, it appears that you can change a list element. However, the list element is the variable, not the data. You're not changing the list element, but something the list element refers to. The list element itself doesn't change: it's still the same variable.</source>
          <target state="translated">但是,如果列表元素本身是一个变量,似乎可以改变列表元素。但是,列表元素是变量,而不是数据,你改变的不是列表元素,而是列表元素所引用的东西。你不是在改变列表元素,而是在改变列表元素所指向的东西。列表元素本身并没有改变:它仍然是同一个变量。</target>
        </trans-unit>
        <trans-unit id="1ff33c873357001776962a640d53584ca4867e68" translate="yes" xml:space="preserve">
          <source>However, if the string value associated with &amp;lt;reject&amp;gt; is &quot;MAX&quot;, then &lt;code&gt;extract_tagged&lt;/code&gt; returns the complete text up to the point of failure. If the string is &quot;PARA&quot;, &lt;code&gt;extract_tagged&lt;/code&gt; returns only the first paragraph after the tag (up to the first line that is either empty or contains only whitespace characters). If the string is &quot;&quot;, the the default behaviour (i.e. failure) is reinstated.</source>
          <target state="translated">但是，如果与&amp;lt;reject&amp;gt;关联的字符串值是&amp;ldquo; MAX&amp;rdquo;，则 &lt;code&gt;extract_tagged&lt;/code&gt; 返回直到失败点为止的完整文本。如果字符串为&amp;ldquo; PARA&amp;rdquo;，则 &lt;code&gt;extract_tagged&lt;/code&gt; 仅返回标记后的第一段（直到第一行为空或仅包含空格字符）。如果字符串为&amp;ldquo;&amp;rdquo;，则将恢复默认行为（即失败）。</target>
        </trans-unit>
        <trans-unit id="a40e24fb0252cc9815324344313381a888c122c8" translate="yes" xml:space="preserve">
          <source>However, if there is no matching &lt;code&gt;}&lt;/code&gt;, Perl doesn't know if it was mistakenly omitted, or if &lt;code&gt;[^\n]{&lt;/code&gt; was desired, and raises this error. If you meant the former, add the right brace; if you meant the latter, escape the brace with a backslash, like so: &lt;code&gt;\N\{&lt;/code&gt;</source>
          <target state="translated">但是，如果没有匹配的 &lt;code&gt;}&lt;/code&gt; ，Perl将不知道是否错误地省略了它，或者是否需要 &lt;code&gt;[^\n]{&lt;/code&gt; 并引发了此错误。如果您的意思是前者，请添加右大括号；如果您的意思是后者，请使用反斜杠将括号转义，例如： &lt;code&gt;\N\{&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4db7ce89f0ac0ff04237db2ffe65056106401da4" translate="yes" xml:space="preserve">
          <source>However, if you have fixed sized records, then you might do something more like this:</source>
          <target state="translated">然而,如果你有固定大小的记录,那么你可能会做一些更像这样的事情。</target>
        </trans-unit>
        <trans-unit id="f0a31e0971a11a0c1d822f02efd0eb4f79c74f3a" translate="yes" xml:space="preserve">
          <source>However, if you set &quot;_AUTO =&amp;gt; 1&quot; in the %Lexicon in, ThisProject/I18N/en.pm (assuming that English (en) is the language that all your programmers will be using for this project's internal message keys), then you don't ever have to go adding lines like this</source>
          <target state="translated">但是，如果在ThisProject / I18N / en.pm的％Lexicon中设置&amp;ldquo; _AUTO =&amp;gt; 1&amp;rdquo;（假设英语（en）是您的所有程序员将用于该项目的内部消息键的语言），则您不必去添加这样的行</target>
        </trans-unit>
        <trans-unit id="a09363cd76b1dde7e3a57d25fdf3272ced3af2ab" translate="yes" xml:space="preserve">
          <source>However, if you want the old behavior (and think carefully about that because it's a weird side effect), you can pass a hash slice instead. Perl 5.004 didn't make this a special case:</source>
          <target state="translated">然而,如果你想要旧的行为(仔细考虑一下,因为这是一个奇怪的副作用),你可以传递一个哈希片来代替。Perl 5.004并没有把这个作为特殊情况。</target>
        </trans-unit>
        <trans-unit id="c9bcfc80dafa07d27c313feb7344f54609aa72b0" translate="yes" xml:space="preserve">
          <source>However, if you're not using git, you can still produce a suitable patch. You'll need a pristine copy of the Perl source to diff against. The porters prefer unified diffs. Using GNU &lt;code&gt;diff&lt;/code&gt; , you can produce a diff like this:</source>
          <target state="translated">但是，如果您不使用git，仍然可以生成合适的补丁。您将需要Perl源的原始副本以进行比较。搬运工更喜欢统一的差异。使用GNU &lt;code&gt;diff&lt;/code&gt; ，您可以产生一个这样的差异：</target>
        </trans-unit>
        <trans-unit id="912422cfe6349f661271a697889a1ce04bbb7530" translate="yes" xml:space="preserve">
          <source>However, in list context, the line input operator returns all of the lines as a list. The first line goes into &lt;code&gt;@array[1]&lt;/code&gt; and the rest of the lines mysteriously disappear:</source>
          <target state="translated">但是，在列表上下文中，行输入运算符将所有行作为列表返回。第一行进入 &lt;code&gt;@array[1]&lt;/code&gt; ，其余各行神秘地消失：</target>
        </trans-unit>
        <trans-unit id="a4cbc737f6445190a51915b10ef52747baeb38d6" translate="yes" xml:space="preserve">
          <source>However, in the case you are using &lt;code&gt;LANGUAGE&lt;/code&gt; : it affects the language of informational, warning, and error messages output by commands (in other words, it's like &lt;code&gt;LC_MESSAGES&lt;/code&gt; ) but it has higher priority than &lt;code&gt;LC_ALL&lt;/code&gt; . Moreover, it's not a single value but instead a &quot;path&quot; (&quot;:&quot;-separated list) of</source>
          <target state="translated">但是，在使用 &lt;code&gt;LANGUAGE&lt;/code&gt; 的情况下：它会影响命令输出的信息性消息，警告消息和错误消息的语言（换句话说，它类似于 &lt;code&gt;LC_MESSAGES&lt;/code&gt; ），但它的优先级高于 &lt;code&gt;LC_ALL&lt;/code&gt; 。而且，它不是单个值，而是一个&amp;ldquo;路径&amp;rdquo;（&amp;ldquo;：&amp;rdquo;分隔列表）</target>
        </trans-unit>
        <trans-unit id="fdfb88ca6aeb7caca106e8a86ebad4a7bd611554" translate="yes" xml:space="preserve">
          <source>However, it does mean that functions like &lt;code&gt;is_deeply()&lt;/code&gt; cannot be used to test the internals of string overloaded objects. In this case I would suggest &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Deep&quot;&gt;Test::Deep&lt;/a&gt; which contains more flexible testing functions for complex data structures.</source>
          <target state="translated">但是，这确实意味着不能使用 &lt;code&gt;is_deeply()&lt;/code&gt; 之类的函数来测试字符串重载对象的内部。在这种情况下，我建议使用&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Deep&quot;&gt;Test :: Deep&lt;/a&gt;，它包含用于复杂数据结构的更灵活的测试功能。</target>
        </trans-unit>
        <trans-unit id="4b56d396ba6f1980056b816ee33f44e386574d54" translate="yes" xml:space="preserve">
          <source>However, it is important to remember that Perl threads cannot magically do things unless your operating system's threads allow it. So if your system blocks the entire process on &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt;, Perl usually will, as well.</source>
          <target state="translated">但是，重要的是要记住，除非操作系统的线程允许，否则Perl线程无法神奇地执行操作。因此，如果您的系统在 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 上阻止了整个过程，那么Perl通常也会这样做。</target>
        </trans-unit>
        <trans-unit id="9d9bc751c2a736800a6ded071584d5744291603c" translate="yes" xml:space="preserve">
          <source>However, it is possible to set up attribute handlers that are called at other points in the program's compilation or execution, by explicitly stating the phase (or phases) in which you wish the attribute handler to be called. For example:</source>
          <target state="translated">然而,可以通过明确说明希望调用属性处理程序的阶段,来设置在程序编译或执行的其他阶段调用的属性处理程序。例如</target>
        </trans-unit>
        <trans-unit id="495f4657c76d2b9516ad67652bc58b23f23940a2" translate="yes" xml:space="preserve">
          <source>However, it would be unwise to write tests such as:</source>
          <target state="translated">然而,编写这样的测试是不明智的。</target>
        </trans-unit>
        <trans-unit id="b30399fa602102d2334ab528f7c1b9ececea8d0d" translate="yes" xml:space="preserve">
          <source>However, it's impossible to &lt;b&gt;perform&lt;/b&gt; the operations in this order: you have to find the values of &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt; before you add them together, for instance. So, the other thread that runs through the op tree is the execution order: each op has a field &lt;code&gt;op_next&lt;/code&gt; which points to the next op to be run, so following these pointers tells us how perl executes the code. We can traverse the tree in this order using the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; option to &lt;code&gt;B::Terse&lt;/code&gt; :</source>
          <target state="translated">但是，不可能按此顺序&lt;b&gt;执行&lt;/b&gt;操作：例如，必须先找到 &lt;code&gt;$b&lt;/code&gt; 和 &lt;code&gt;$c&lt;/code&gt; 的值，然后再将它们加在一起。因此，运行op树的另一个线程是执行顺序：每个op都有一个 &lt;code&gt;op_next&lt;/code&gt; 字段，该字段指向要运行的下一个op，因此遵循这些指针可以告诉我们perl如何执行代码。我们可以使用 &lt;code&gt;B::Terse&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 选项以此顺序遍历树：</target>
        </trans-unit>
        <trans-unit id="5a3fd83f97cb972df229bb4d55a4c188b477d626" translate="yes" xml:space="preserve">
          <source>However, long experience has shown that many programming tasks may be significantly simplified by using repeated subexpressions that may match zero-length substrings. Here's a simple example being:</source>
          <target state="translated">然而,长期的经验表明,通过使用可能匹配零长度子串的重复子表达式,可以大大简化许多编程任务。这里有一个简单的例子是。</target>
        </trans-unit>
        <trans-unit id="ccc9947a9b58d2f4b1cd78cbf550721e43e5ecea" translate="yes" xml:space="preserve">
          <source>However, note that &lt;code&gt;sv_unmagic&lt;/code&gt; removes all magic of a certain &lt;code&gt;type&lt;/code&gt; from the &lt;code&gt;SV&lt;/code&gt; . If you want to remove only certain magic of a &lt;code&gt;type&lt;/code&gt; based on the magic virtual table, use &lt;code&gt;sv_unmagicext&lt;/code&gt; instead:</source>
          <target state="translated">但是，请注意， &lt;code&gt;sv_unmagic&lt;/code&gt; 从 &lt;code&gt;SV&lt;/code&gt; 中删除了某种特定 &lt;code&gt;type&lt;/code&gt; 所有魔法。如果只想删除基于魔术虚拟表的某种魔术 &lt;code&gt;type&lt;/code&gt; ，请改用 &lt;code&gt;sv_unmagicext&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3714710035618507b561178df5f82b541c8974c8" translate="yes" xml:space="preserve">
          <source>However, note that even as the specified layers are &quot;pushed on top&quot; for open() and binmode(), this doesn't mean that the effects are limited to the &quot;top&quot;: PerlIO layers can be very 'active' and inspect and affect layers also deeper in the stack. As an example there is a layer called &quot;raw&quot; which repeatedly &quot;pops&quot; layers until it reaches the first layer that has declared itself capable of handling binary data. The &quot;pushed&quot; layers are processed in left-to-right order.</source>
          <target state="translated">但是,请注意,即使指定的层被 &quot;推到 &quot;open()和binmode()的顶部,这并不意味着影响仅限于 &quot;顶部&quot;。PerlIO 层可以非常 &quot;活跃&quot;,并检查和影响堆栈深处的层。举个例子,有一个叫做 &quot;raw &quot;的层,它反复 &quot;弹出 &quot;层,直到它到达第一个声明自己能够处理二进制数据的层。被 &quot;弹出 &quot;的层按照从左到右的顺序进行处理。</target>
        </trans-unit>
        <trans-unit id="237e671ead4e4f448bac6dfef4927434cec18095" translate="yes" xml:space="preserve">
          <source>However, on earlier Perls, or if you pass strings to subroutines outside the feature's scope, you can force Unicode rules by changing the encoding to UTF-8 by doing &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; . This can be used safely on any string, as it checks and does not change strings that have already been upgraded.</source>
          <target state="translated">但是，在较早的Perls上，或者如果您将字符串传递给功能范围之外的子例程，则可以通过执行 &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; 将编码更改为UTF-8来强制执行Unicode规则。可以在任何字符串上安全地使用它，因为它可以检查并且不会更改已经升级的字符串。</target>
        </trans-unit>
        <trans-unit id="9d790ef4b7b652054f8ef9f08eabcfceb4c9c9d7" translate="yes" xml:space="preserve">
          <source>However, only double quotes &quot;interpolate&quot; variables and special characters such as newlines (&lt;code&gt;\n&lt;/code&gt; ):</source>
          <target state="translated">但是，只有双引号会&amp;ldquo;插值&amp;rdquo;变量和特殊字符，例如换行符（ &lt;code&gt;\n&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="5f40951889d3378b60336de3c7c19a48f84efe15" translate="yes" xml:space="preserve">
          <source>However, over the years, changes in gcc, GNU ld, and Solaris ld have made it difficult to automatically detect which ld ultimately gets called. You may have to manually edit config.sh and add the -Wl,-E flags yourself, or else run Configure interactively and add the flags at the appropriate prompts.</source>
          <target state="translated">然而,多年来,gcc、GNU ld和Solaris ld的变化使得自动检测最终被调用的ld变得很困难。你可能需要手动编辑config.sh,然后自己添加-Wl,-E标志,或者交互式运行Configure,在适当的提示下添加标志。</target>
        </trans-unit>
        <trans-unit id="7abae8990eb0eaeb22dbcaa2121181a9c3213635" translate="yes" xml:space="preserve">
          <source>However, since I am running a very recent Hurd snapshot, in which a lot of bugs that were exposed by the Perl test suite have been fixed, you may encounter more failures. Likely candidates are: &quot;op/stat&quot;, &quot;lib/io_pipe&quot;, &quot;lib/io_sock&quot;, &quot;lib/io_udp&quot; and &quot;lib/time&quot;.</source>
          <target state="translated">然而,由于我运行的是最近的Hurd快照,其中很多Perl测试套件暴露的bug已经被修复,你可能会遇到更多的故障。可能的原因是 &quot;op/stat&quot;,&quot;lib/io_pipe&quot;,&quot;lib/io_sock&quot;,&quot;lib/io_udp &quot;和 &quot;lib/time&quot;。</target>
        </trans-unit>
        <trans-unit id="0a2932991138cff6cda965e1aa59120419d51793" translate="yes" xml:space="preserve">
          <source>However, since prototype checking happens at compile time, the assignment above happens too late to be of much use. You could address this by putting the whole loop of assignments within a BEGIN block, forcing it to occur during compilation.</source>
          <target state="translated">然而,由于原型检查是在编译时进行的,所以上面的赋值发生得太晚,没有什么用处。你可以把整个赋值循环放在一个BEGIN块中,迫使它在编译时发生,来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="f5dc0373ab5a69dc9065fd1361f3fe68378bd857" translate="yes" xml:space="preserve">
          <source>However, some people find that code harder to read than writing it with parentheses:</source>
          <target state="translated">然而,有些人觉得这种代码比用括号写的更难读。</target>
        </trans-unit>
        <trans-unit id="e33f317ee43849ba21e4562b2cfcaf42b63f23a8" translate="yes" xml:space="preserve">
          <source>However, that doesn't work if the line ending isn't a newline. You might change that &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; so you can count the number of times the input record separator, &lt;code&gt;$/&lt;/code&gt; , shows up:</source>
          <target state="translated">但是，如果行尾不是换行符，那将不起作用。您可以将 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 更改为 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 这样就可以计算输入记录分隔符 &lt;code&gt;$/&lt;/code&gt; 出现的次数：</target>
        </trans-unit>
        <trans-unit id="ff8d86d9a6fdf31c1cce87bc99b477e123d4270e" translate="yes" xml:space="preserve">
          <source>However, the &lt;b&gt;.ph&lt;/b&gt; files almost double in size when built using &lt;b&gt;-h&lt;/b&gt;.</source>
          <target state="translated">但是，使用&lt;b&gt;-h&lt;/b&gt;构建时，&lt;b&gt;.ph&lt;/b&gt;文件的大小几乎增加了一倍。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dbf1c5152a0ddfa7cc0b45d1130d02f94e11246a" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;W&lt;/code&gt; specifier does operate on whole characters, as does the &lt;code&gt;U&lt;/code&gt; specifier.</source>
          <target state="translated">但是， &lt;code&gt;W&lt;/code&gt; 标识符和 &lt;code&gt;U&lt;/code&gt; 标识符对整个字符都起作用。</target>
        </trans-unit>
        <trans-unit id="3da026c415acace03626d9fb7e1ee90aa243fe42" translate="yes" xml:space="preserve">
          <source>However, the above usage will create global variables throughout your program, which is bad programming practice. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; creates lexically scoped variables instead. The variables are scoped to the block (i.e. a bunch of statements surrounded by curly-braces) in which they are defined.</source>
          <target state="translated">但是，以上用法将在整个程序中创建全局变量，这是不好的编程习惯。 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 创建了词法范围变量。变量的作用域是定义它们的块（即，用大括号括起来的一堆语句）。</target>
        </trans-unit>
        <trans-unit id="643bcb3d157afa153f651f6fc7ccfed78f3e704a" translate="yes" xml:space="preserve">
          <source>However, the call in:</source>
          <target state="translated">然而,叫进来的。</target>
        </trans-unit>
        <trans-unit id="30ecfcc25810d7a7cdf5b6a2a73a83af471c9442" translate="yes" xml:space="preserve">
          <source>However, the generated Perl function is called in very C-ish style:</source>
          <target state="translated">然而,生成的Perl函数是以非常C的风格调用的。</target>
        </trans-unit>
        <trans-unit id="be1c834c7d4d71f52243b42559f80aabe198a844" translate="yes" xml:space="preserve">
          <source>However, the matching position of the input variable would be set to &quot;exit;&quot; (i.e.</source>
          <target state="translated">然而,输入变量的匹配位置将被设置为 &quot;exit;&quot;(即。</target>
        </trans-unit>
        <trans-unit id="d95f0313fce5fa0d84ae8a729df3c8f4e82e2159" translate="yes" xml:space="preserve">
          <source>However, the result of such a slice cannot be localized, deleted or used in assignment. These are otherwise very much consistent with hash slices using the @ symbol.</source>
          <target state="translated">但是,这种分片的结果不能被局部化、删除或用于赋值。这些在其他方面与使用@符号的哈希分片非常一致。</target>
        </trans-unit>
        <trans-unit id="c017b28f94bbc1527d3a99433c0d70601c0484be" translate="yes" xml:space="preserve">
          <source>However, the shortcut requires that you specify exactly two command-line arguments, &lt;code&gt;indirs&lt;/code&gt; and &lt;code&gt;outdir&lt;/code&gt; .</source>
          <target state="translated">但是，快捷方式要求您准确指定两个命令行参数 &lt;code&gt;indirs&lt;/code&gt; 和 &lt;code&gt;outdir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="174d3b644e004445441e24cae4b9fd65f9fed124" translate="yes" xml:space="preserve">
          <source>However, their are many, many other differences. For example, this works in Perl 5:</source>
          <target state="translated">然而,他们还有很多很多的不同之处。例如,这在Perl 5中就可以工作。</target>
        </trans-unit>
        <trans-unit id="431ca5f68339a06fd3a547e35432cecf8dddda74" translate="yes" xml:space="preserve">
          <source>However, there are places where this breaks down. Certain Perl constructs are for Unicode only, such as &lt;code&gt;\p{Alpha}&lt;/code&gt; . They assume that 0xD7 always has its Unicode meaning (or the equivalent on EBCDIC platforms). Since Latin1 is a subset of Unicode and 0xD7 is the multiplication sign in both Latin1 and Unicode, &lt;code&gt;\p{Alpha}&lt;/code&gt; will never match it, regardless of locale. A similar issue occurs with &lt;code&gt;\N{...}&lt;/code&gt; . Prior to v5.20, It is therefore a bad idea to use &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\N{}&lt;/code&gt; under plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; --</source>
          <target state="translated">但是，在某些情况下，这种情况会恶化。某些Perl构造仅用于Unicode，例如 &lt;code&gt;\p{Alpha}&lt;/code&gt; 。他们假设0xD7始终具有其Unicode含义（或EBCDIC平台上的等效含义）。由于Latin1是Unicode的子集，而0xD7是Latin1和Unicode中的乘法符号，因此 &lt;code&gt;\p{Alpha}&lt;/code&gt; 将永远不会与之匹配，而与语言环境无关。 &lt;code&gt;\N{...}&lt;/code&gt; 也会发生类似的问题。在v5.20之前，因此在普通 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 区域设置中使用 &lt;code&gt;\p{}&lt;/code&gt; 或 &lt;code&gt;\N{}&lt;/code&gt; 是个坏主意-</target>
        </trans-unit>
        <trans-unit id="79a79d341666f9d08432041587a457666ea4e643" translate="yes" xml:space="preserve">
          <source>However, there is a third way: perl DLL exports the main() function and several callbacks to customize the search path. Below is a complete example of a &quot;Perl loader&quot; which</source>
          <target state="translated">然而,还有第三种方法:perl DLL导出main()函数和几个回调来定制搜索路径。下面是一个完整的 &quot;Perl加载器 &quot;的例子,它的作用是</target>
        </trans-unit>
        <trans-unit id="167fa8624f523d65d674923630d20eace6f440ad" translate="yes" xml:space="preserve">
          <source>However, there is one other function which manipulates the reference count of its argument. The &lt;code&gt;newRV_inc&lt;/code&gt; function, you will recall, creates a reference to the specified argument. As a side effect, it increments the argument's reference count. If this is not what you want, use &lt;code&gt;newRV_noinc&lt;/code&gt; instead.</source>
          <target state="translated">但是，还有另一个函数可操纵其参数的引用计数。该 &lt;code&gt;newRV_inc&lt;/code&gt; 功能，你会记得，创建到指定参数的引用。副作用是，它增加了参数的引用计数。如果这不是您想要的，请改用 &lt;code&gt;newRV_noinc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78acaa936efa9d2893b28f11a288123a0f9298ff" translate="yes" xml:space="preserve">
          <source>However, these two XSUBs provide almost identical generated C code: &lt;b&gt;xsubpp&lt;/b&gt; compiler is smart enough to figure out the &lt;code&gt;CODE:&lt;/code&gt; section from the first two lines of the description of XSUB. What about &lt;code&gt;OUTPUT:&lt;/code&gt; section? In fact, that is absolutely the same! The &lt;code&gt;OUTPUT:&lt;/code&gt; section can be removed as well,</source>
          <target state="translated">但是，这两个&lt;b&gt;XSUB&lt;/b&gt;提供了几乎相同的生成C代码：&lt;b&gt;xsubpp&lt;/b&gt;编译器足够聪明，可以从XSUB描述的前两行找出 &lt;code&gt;CODE:&lt;/code&gt; 部分。什么 &lt;code&gt;OUTPUT:&lt;/code&gt; 部分？实际上，那绝对是一样的！的 &lt;code&gt;OUTPUT:&lt;/code&gt; 部分也可被移除，</target>
        </trans-unit>
        <trans-unit id="8993e8546f1a446361af9208f62149f37c72c7da" translate="yes" xml:space="preserve">
          <source>However, this approach is limited to the first arguments following &quot;root&quot; (again, see &lt;code&gt;Unix-&amp;gt;canonpath()&lt;/code&gt; ). If there are more arguments that move up the directory tree, an invalid path going beyond root can be created.</source>
          <target state="translated">但是，这种方法仅限于&amp;ldquo; root&amp;rdquo;之后的第一个参数（同样，请参见 &lt;code&gt;Unix-&amp;gt;canonpath()&lt;/code&gt; ）。如果有更多的参数在目录树中上移，则可以创建超出根目录的无效路径。</target>
        </trans-unit>
        <trans-unit id="a498e0a44f0f9f8fbe6e40968d0b21c8d56b2479" translate="yes" xml:space="preserve">
          <source>However, this request is ignored, as the current code now uses the low-level math library for directly storing the number parts.</source>
          <target state="translated">但是,这个请求被忽略了,因为现在的代码使用低级数学库直接存储数字部分。</target>
        </trans-unit>
        <trans-unit id="1c442891dca9145a3b9c79c668f4b9ec23f39a60" translate="yes" xml:space="preserve">
          <source>However, this still does not guarantee that these DLL may be loaded. The reason is the mangling of the name of the</source>
          <target state="translated">但是,这仍然不能保证这些DLL可以被加载。其原因是将DLL的名称弄错了。</target>
        </trans-unit>
        <trans-unit id="2084b9ad89039a2ea6c4200ac2905bee170c22b7" translate="yes" xml:space="preserve">
          <source>However, to help ease understanding, it is suggested that you place a &quot;&amp;amp;&quot; next to the variable name and away from the variable type), and place a &quot;*&quot; near the variable type, but away from the variable name (as in the call to foo above). By doing so, it is easy to understand exactly what will be passed to the C function; it will be whatever is in the &quot;last column&quot;.</source>
          <target state="translated">但是，为帮助您理解，建议您在变量名旁边放置一个&amp;ldquo;＆&amp;rdquo;并远离变量类型），并在变量类型附近放置一个&amp;ldquo; *&amp;rdquo;，但要远离变量名称（例如上面对foo的调用）。这样，很容易准确地了解将传递给C函数的内容。这将是&amp;ldquo;最后一列&amp;rdquo;中的内容。</target>
        </trans-unit>
        <trans-unit id="ae3f94bdf7ac1269b60e51c2ce0911730992c14a" translate="yes" xml:space="preserve">
          <source>However, under some circumstances, this behavior may be excessively slow. For example, suppose you have a million-record file, and you want to do:</source>
          <target state="translated">然而,在某些情况下,这种行为可能会过于缓慢。例如,假设你有一个百万记录的文件,而你想做。</target>
        </trans-unit>
        <trans-unit id="37cab8dafbfef6134cbae52136465a602af12595" translate="yes" xml:space="preserve">
          <source>However, unless you tell &lt;code&gt;Memoize&lt;/code&gt; that these calls are equivalent, it will not know that, and it will compute the values for these invocations of your function separately, and store them separately.</source>
          <target state="translated">但是，除非您告诉 &lt;code&gt;Memoize&lt;/code&gt; 这些调用是等效的，否则它将不会知道，并且它将分别计算函数的这些调用的值，并将它们分别存储。</target>
        </trans-unit>
        <trans-unit id="142779c491fb94a0d076da32b3296ae6b26999c0" translate="yes" xml:space="preserve">
          <source>However, up through v5.20, Perl initialized things on start-up so that &lt;code&gt;LC_NUMERIC&lt;/code&gt; was set to the &quot;C&quot; locale. But if any code anywhere changed it, it would stay changed. This means that your module can't count on &lt;code&gt;LC_NUMERIC&lt;/code&gt; being something in particular, and you can't expect floating point numbers (including version strings) to have dots in them. If you don't allow for a non-dot, your code could break if anyone anywhere changed the locale. For this reason, v5.22 changed the behavior so that Perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; in the &quot;C&quot; locale except around the operations internally where it should be something else. Misbehaving XS code will always be able to change the locale anyway, but the most common instance of this is checked for and handled.</source>
          <target state="translated">但是，从v5.20开始，Perl在启动时初始化了事情，因此 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 设置为&amp;ldquo; C&amp;rdquo;语言环境。但是，如果任何代码在任何地方进行了更改，它将保持不变。这意味着您的模块不能指望 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 特别重要，并且您不能期望浮点数（包括版本字符串）中包含点。如果您不允许使用非圆点，那么任何地方的任何人更改语言环境都可能会破坏您的代码。因此，v5.22更改了行为，以使Perl尝试将 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 保留在&amp;ldquo; C&amp;rdquo;语言环境中，但内部操作周围应保留其他内容。行为不当的XS代码始终总是能够更改语言环境，但是会检查并处理这种情况的最常见实例。</target>
        </trans-unit>
        <trans-unit id="068b747d32004750485efe98f8d1cbafa2e0e35a" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;&amp;amp;&lt;/code&gt; in the call still overrides the prototype of &lt;code&gt;foo&lt;/code&gt; if present:</source>
          <target state="translated">但是，在调用中使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 仍会覆盖 &lt;code&gt;foo&lt;/code&gt; 的原型（如果存在）：</target>
        </trans-unit>
        <trans-unit id="f9fabcfc6b8511bdc0a7ecd34a3e04f701d2b56e" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;\015\012&lt;/code&gt; (or &lt;code&gt;\cM\cJ&lt;/code&gt; , or &lt;code&gt;\x0D\x0A&lt;/code&gt; ) can be tedious and unsightly, as well as confusing to those maintaining the code. As such, the &lt;code&gt;Socket&lt;/code&gt; module supplies the Right Thing for those who want it.</source>
          <target state="translated">但是，使用 &lt;code&gt;\015\012&lt;/code&gt; （或 &lt;code&gt;\cM\cJ&lt;/code&gt; 或 &lt;code&gt;\x0D\x0A&lt;/code&gt; ）可能既乏味又难看，并且会使维护代码的人感到困惑。因此， &lt;code&gt;Socket&lt;/code&gt; 模块为需要的人提供了正确的东西。</target>
        </trans-unit>
        <trans-unit id="163537b4f5c11cd47e9722700a60c6c7ea0ade4a" translate="yes" xml:space="preserve">
          <source>However, using the code requires that you have a working C compiler and can use it to build and install a CPAN module. Here's a solution using the standard &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module, which is already on your system (assuming your system supports POSIX).</source>
          <target state="translated">但是，使用代码要求您具有有效的C编译器，并且可以使用它来构建和安装CPAN模块。这是使用标准&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块的解决方案，该模块已经在您的系统上（假设您的系统支持POSIX）。</target>
        </trans-unit>
        <trans-unit id="a4350da00ad3028f4efc1846f8fc750c07ee286a" translate="yes" xml:space="preserve">
          <source>However, when it's a list-context assignment and you're trying to use &lt;code&gt;||&lt;/code&gt; for control flow, you probably need &lt;code&gt;&quot;or&quot;&lt;/code&gt; so that the assignment takes higher precedence.</source>
          <target state="translated">但是，当它是一个列表上下文分配并且您尝试使用 &lt;code&gt;||&lt;/code&gt; 时。对于控制流，您可能需要使用 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 以便分配具有更高的优先级。</target>
        </trans-unit>
        <trans-unit id="41f9727ede39a1ce5211e24f06cf1afdd8d7ee83" translate="yes" xml:space="preserve">
          <source>However, you can change the way an object is smartmatched by overloading the &lt;code&gt;~~&lt;/code&gt; operator. This is allowed to extend the usual smartmatch semantics. For objects that do have an &lt;code&gt;~~&lt;/code&gt; overload, see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;.</source>
          <target state="translated">但是，您可以通过重载 &lt;code&gt;~~&lt;/code&gt; 运算符来更改对象智能匹配的方式。这允许扩展通常的smartmatch语义。对于确实具有 &lt;code&gt;~~&lt;/code&gt; 重载的对象，请参见&lt;a href=&quot;overload&quot;&gt;重载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b89d0d284e64c095a60bef4f1dd049a654a9b8f4" translate="yes" xml:space="preserve">
          <source>However, you can suppress the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; by using an explicit, empty import list. Both of these still happen at compile-time:</source>
          <target state="translated">但是，可以抑制 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 通过使用一个明确的，空的导入列表。这两个仍然在编译时发生：</target>
        </trans-unit>
        <trans-unit id="2eb959e8b316e23c060bb14a1aa10ea6663e7a66" translate="yes" xml:space="preserve">
          <source>However, you have to be more cautious with namespace and variable scoping when using a persistent interpreter. In previous examples we've been using global variables in the default package &lt;code&gt;main&lt;/code&gt; . We knew exactly what code would be run, and assumed we could avoid variable collisions and outrageous symbol table growth.</source>
          <target state="translated">但是，在使用持久性解释器时，您必须对名称空间和变量作用域更加谨慎。在前面的示例中，我们一直在默认包 &lt;code&gt;main&lt;/code&gt; 中使用全局变量。我们确切地知道将运行什么代码，并假设我们可以避免变量冲突和令人讨厌的符号表增长。</target>
        </trans-unit>
        <trans-unit id="e66a879553ebe7b620fa37901232bfb863aa6d3d" translate="yes" xml:space="preserve">
          <source>However, you may know that you intend to use the results in a particular context, where some pragmas are already in scope. In this case, you use the &lt;b&gt;ambient_pragmas&lt;/b&gt; method to describe the assumptions you wish to make.</source>
          <target state="translated">但是，您可能知道您打算在特定的上下文中使用结果，其中某些杂物已经存在。在这种情况下，您可以使用&lt;b&gt;ambient_pragmas&lt;/b&gt;方法来描述您要进行的假设。</target>
        </trans-unit>
        <trans-unit id="56cfa87ada9834b01835bf9c64cf509441054b7b" translate="yes" xml:space="preserve">
          <source>However, you might be out of luck if you expect that means there is a real person on the other side. With the &lt;a href=&quot;http://search.cpan.org/perldoc/Expect&quot;&gt;Expect&lt;/a&gt; module, another program can pretend to be a person. The program might even come close to passing the Turing test.</source>
          <target state="translated">但是，如果您期望那意味着另一边有一个真实的人，那么您可能会不走运。使用&lt;a href=&quot;http://search.cpan.org/perldoc/Expect&quot;&gt;Expect&lt;/a&gt;模块，另一个程序可以伪装成一个人。该程序甚至可能接近通过图灵测试。</target>
        </trans-unit>
        <trans-unit id="a422dec568026043ae4e005023457a913a05b272" translate="yes" xml:space="preserve">
          <source>However, you must not do this, for example:</source>
          <target state="translated">但是,你千万不要这样做,比如说。</target>
        </trans-unit>
        <trans-unit id="e3a4e64a25b29be20841a60bc10f2c0bc37e06f9" translate="yes" xml:space="preserve">
          <source>However, you should &lt;b&gt;not&lt;/b&gt; blindly rely on perl always doing the right thing. Particularly, perl will mistakenly return true when you clear the hash by repeatedly calling DELETE until it is empty. You are therefore advised to supply your own SCALAR method when you want to be absolutely sure that your hash behaves nicely in scalar context.</source>
          <target state="translated">但是，你应该&lt;b&gt;不会&lt;/b&gt;一味依赖Perl的总是做正确的事。特别是，当您通过重复调用DELETE直到其为空而清除哈希时，perl将错误地返回true。因此，当您要绝对确保哈希在标量上下文中表现良好时，建议您提供自己的SCALAR方法。</target>
        </trans-unit>
        <trans-unit id="59d2100593fec39720245432930b526325693698" translate="yes" xml:space="preserve">
          <source>Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;</source>
          <target state="translated">雨果&amp;middot;范德&amp;middot;桑登&amp;lt;hv@crypt0.demon.co.uk&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9711a7cfeff071972d36fdd6050e80bc9d749c0b" translate="yes" xml:space="preserve">
          <source>Hyperlinks</source>
          <target state="translated">Hyperlinks</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="68ea31ac882843ca3bb7347afdcbec874605911e" translate="yes" xml:space="preserve">
          <source>I almost always use keys that are themselves valid lexicon values. One notable exception is when the value is quite long. For example, to get the screenful of data that a command-line program might return when given an unknown switch, I often just use a brief, self-explanatory key such as &quot;_USAGE_MESSAGE&quot;. At that point I then go and immediately to define that lexicon entry in the ProjectClass::L10N::en lexicon (since English is always my &quot;project language&quot;):</source>
          <target state="translated">我几乎总是使用本身就是有效词典值的键。一个明显的例外是当值相当长时。例如,为了得到命令行程序在给定一个未知开关时可能返回的满屏数据,我经常只使用一个简短的、不言自明的键,如&quot;_USAGE_MESSAGE&quot;。这时,我就会立即去在ProjectClass::L10N::en词库中定义该词条(因为英语一直是我的 &quot;项目语言&quot;)。</target>
        </trans-unit>
        <trans-unit id="a12498934a0d4cbe958ea9ae2277b44bccce11e2" translate="yes" xml:space="preserve">
          <source>I am not root, how can I install a module in a personal directory?</source>
          <target state="translated">我不是root,如何在个人目录下安装模块?</target>
        </trans-unit>
        <trans-unit id="720225fb87f4fceb999d3d3c67fa208ed54fe066" translate="yes" xml:space="preserve">
          <source>I am sure there are bugs in the code. If you do find any, or can suggest any enhancements, I would welcome your comments.</source>
          <target state="translated">我相信代码中一定会有错误。如果你确实发现了任何错误,或者可以提出任何改进建议,我欢迎你的评论。</target>
        </trans-unit>
        <trans-unit id="f822dc00911ca2b5b17523234c19e71174239e30" translate="yes" xml:space="preserve">
          <source>I assume that each language class derives (directly or indirectly) from your project class, and also defines its @ISA, its %Lexicon, or both. But I anticipate no dire consequences if these assumptions do not hold.</source>
          <target state="translated">我假设每个语言类都从你的项目类派生出来(直接或间接),并且也定义了它的@ISA,%Lexicon,或者两者都有。但如果这些假设不成立,我预计不会有什么可怕的后果。</target>
        </trans-unit>
        <trans-unit id="5f16057cfc74a8e91522c5a546d3a88bbd9af3c3" translate="yes" xml:space="preserve">
          <source>I can picture all sorts of circumstances where you just do not want lookup to be able to fail (since failing normally means that maketext throws a &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, although see the next section for greater control over that). But here's one circumstance where _AUTO lexicons are meant to be</source>
          <target state="translated">我可以想象各种各样的情况，在这些情况下，您只是不希望查找能够失败（因为失败通常意味着maketext会 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，尽管请参见下一节以更好地控制它）。但是在这种情况下，_AUTO词典应该是</target>
        </trans-unit>
        <trans-unit id="c4089c61d9307c046d40cd9abd561382f7f03ee3" translate="yes" xml:space="preserve">
          <source>I cannot embed perl into my program, or use</source>
          <target state="translated">我不能将perl嵌入到我的程序中,也不能使用</target>
        </trans-unit>
        <trans-unit id="31d3f8a1fa15d729190062c1ddc4f7dd97a4bdd9" translate="yes" xml:space="preserve">
          <source>I cannot embed perl into my program, or use _perl.dll_ from my program.</source>
          <target state="translated">我不能将perl嵌入到我的程序中,也不能从我的程序中使用_perl.dll_。</target>
        </trans-unit>
        <trans-unit id="0dfdb8e8d03951e17fc904de692bb5bbd7335317" translate="yes" xml:space="preserve">
          <source>I cannot run external programs</source>
          <target state="translated">我无法运行外部程序</target>
        </trans-unit>
        <trans-unit id="03ed42e550b2837d803cc938a5c931b4a08219dc" translate="yes" xml:space="preserve">
          <source>I copied the Perl binary from one machine to another, but scripts don't work.</source>
          <target state="translated">我把Perl的二进制文件从一台机器复制到另一台机器上,但是脚本不能用。</target>
        </trans-unit>
        <trans-unit id="9327e89bd234d7a986b2da9100760b6e37c4547a" translate="yes" xml:space="preserve">
          <source>I could start up faster by delaying compilation until it should be needed, but this gets a &quot;panic: top_level&quot; when using the pragma form in Perl 5.001e.</source>
          <target state="translated">我可以通过将编译延迟到应该需要的时候再启动更快,但在Perl 5.001e中使用pragma形式时,这会得到 &quot;panic:top_level&quot;。</target>
        </trans-unit>
        <trans-unit id="88a201ad71d898eadaddaac681114556a0d035b9" translate="yes" xml:space="preserve">
          <source>I do not anticipate that you will need (or particularly want) to nest bracket groups, but you are welcome to email me with convincing (real-life) arguments to the contrary.</source>
          <target state="translated">我不预计你会需要(或特别想要)嵌套括号组,但欢迎你给我发邮件,提出令人信服的(现实生活中)相反的论点。</target>
        </trans-unit>
        <trans-unit id="3bb5142da6ee5443fb8a1f91f511fc41a8d23e27" translate="yes" xml:space="preserve">
          <source>I don't have a C compiler. How can I build my own Perl interpreter?</source>
          <target state="translated">我没有C编译器。我怎样才能建立自己的Perl解释器?</target>
        </trans-unit>
        <trans-unit id="d6d0389812dedc1090c3af8ee3195c2e1255c8d3" translate="yes" xml:space="preserve">
          <source>I foresee no problems with having multiple inheritance in your hierarchy of language classes. (As usual, however, Perl will complain bitterly if you have a cycle in the hierarchy: i.e., if any class is its own ancestor.)</source>
          <target state="translated">我预见到在你的语言类的层次结构中拥有多重继承没有问题。(不过,和往常一样,如果你的层次结构中有一个循环,即任何一个类都是它自己的祖先,Perl就会痛苦地抱怨。)</target>
        </trans-unit>
        <trans-unit id="371ea8fdbc8bb052c307098a6984a7c87ed2802d" translate="yes" xml:space="preserve">
          <source>I get an error when I run this from my shell (which happens to be bash). That may look like perl forgot it has a &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; function, but my shebang line is not the path to perl, so the shell runs the script, and I get the error.</source>
          <target state="translated">当我从我的shell（恰好是bash）运行它时，我得到一个错误。看起来好像perl忘记了它具有 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 函数，但是我的shebang行不是perl的路径，因此shell运行脚本，但出现错误。</target>
        </trans-unit>
        <trans-unit id="25b36e7f52406231ec7c4381f27e5a02ba4d1de4" translate="yes" xml:space="preserve">
          <source>I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed. How do I make it work?</source>
          <target state="translated">我抓了源码并尝试编译,但gdbm/dynamic loading/malloc/linking/...失败了。我怎样才能让它工作?</target>
        </trans-unit>
        <trans-unit id="12aeb2257dccbb467ef10e49ef5687a5f072930e" translate="yes" xml:space="preserve">
          <source>I have no clue what this does. Strips function prefixes?</source>
          <target state="translated">我不知道这是干什么的。剥离函数前缀?</target>
        </trans-unit>
        <trans-unit id="fc30870b270d5fd5a0e0ca93284b0967a0e43a00" translate="yes" xml:space="preserve">
          <source>I have supposed that since this module is concerned with file I/O, almost all normal use of it will be heavily I/O bound. This means that the time to maintain complicated data structures inside the module will be dominated by the time to actually perform the I/O. When there was an opportunity to spend CPU time to avoid doing I/O, I usually tried to take it.</source>
          <target state="translated">我推测,由于这个模块关注的是文件I/O,所以几乎所有正常使用的模块都会有大量的I/O绑定,这意味着模块内部维护复杂数据结构的时间会被实际执行I/O的时间所占据。这意味着在模块内部维护复杂数据结构的时间将被实际执行I/O的时间所支配。当有机会花费CPU时间来避免做I/O的时候,我通常会尽量抓住这个机会。</target>
        </trans-unit>
        <trans-unit id="9f890badb47c01638de767ac6be14f492fbbfa01" translate="yes" xml:space="preserve">
          <source>I installed a Bundle and had a couple of fails. When I retried, everything resolved nicely. Can this be fixed to work on first try?</source>
          <target state="translated">我安装了一个Bundle,但出现了几次失败。当我重试时,一切都解决得很好。能否解决这个问题,使其在第一次尝试时就能正常工作?</target>
        </trans-unit>
        <trans-unit id="f93fb27a66a374179e4455b8d8985c2d226a8af1" translate="yes" xml:space="preserve">
          <source>I installed a new version of module X but CPAN keeps saying, I have the old version installed</source>
          <target state="translated">我安装了一个新版本的模块X,但CPAN一直说,我安装了旧版本的模块X</target>
        </trans-unit>
        <trans-unit id="ce465a8fc00712ba52e5306e95737f3b12576087" translate="yes" xml:space="preserve">
          <source>I know of no way to find out the state of popups</source>
          <target state="translated">我不知道如何找出弹出窗口的状态。</target>
        </trans-unit>
        <trans-unit id="50ca6fc19f7270831b580874499d55acf40e475f" translate="yes" xml:space="preserve">
          <source>I know of no way to find out the state of redirection of popups to the disk</source>
          <target state="translated">我不知道有什么办法可以查到弹出窗口的重定向到磁盘的状态。</target>
        </trans-unit>
        <trans-unit id="74eeceb13c393c687a92a5cda3bd40599b660cd1" translate="yes" xml:space="preserve">
          <source>I lost track; what encoding is the internal format really?</source>
          <target state="translated">我不知道,内部格式到底是什么编码?</target>
        </trans-unit>
        <trans-unit id="d25ced27930e65857371f29ffd1a913f02b5e4b7" translate="yes" xml:space="preserve">
          <source>I love it when a plan comes together</source>
          <target state="translated">我爱它,当一个计划一起</target>
        </trans-unit>
        <trans-unit id="606078fbab11616b11caaa1df541827c0df787a2" translate="yes" xml:space="preserve">
          <source>I maintain a mailing list on which I occasionally announce new versions of Memoize. The list is for announcements only, not discussion. To join, send an empty message to mjd-perl-memoize-request@Plover.com.</source>
          <target state="translated">我维护了一个邮件列表,偶尔会在上面公布Memoize的新版本。该列表只用于发布公告,不用于讨论。要加入,请发送空消息到 mjd-perl-memoize-request@Plover.com。</target>
        </trans-unit>
        <trans-unit id="92c1a5ec60a557a8f6b6b470a96e90910a56e1c7" translate="yes" xml:space="preserve">
          <source>I pointed out that &lt;code&gt;Memoize&lt;/code&gt; uses a hash, and that looking up a number in the hash is necessarily going to take a lot longer than a single multiplication. There really is no way to speed up the &lt;code&gt;square&lt;/code&gt; function.</source>
          <target state="translated">我指出， &lt;code&gt;Memoize&lt;/code&gt; 使用散列，并且在散列中查找数字必然比单倍乘法花费更长的时间。确实没有办法加快 &lt;code&gt;square&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="44584b7f38a4c7c497d3af92b7cb4267fde694f9" translate="yes" xml:space="preserve">
          <source>I promised to give you 90% of the benefit with 10% of the details, and that means I left out 90% of the details. Now that you have an overview of the important parts, it should be easier to read the &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; manual page, which discusses 100% of the details.</source>
          <target state="translated">我答应给您90％的收益以及10％的细节，这意味着我遗漏了90％的细节。现在，您已经掌握了重要部分的概述，应该更容易阅读&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;手册页面，该页面讨论了100％的详细信息。</target>
        </trans-unit>
        <trans-unit id="fe86a2ccd7bbbde333da23b987f2e2e4802f719a" translate="yes" xml:space="preserve">
          <source>I put a regular expression into $/ but it didn't work. What's wrong?</source>
          <target state="translated">我在$/中输入了一个正则表达式,但是没有成功。怎么了?</target>
        </trans-unit>
        <trans-unit id="73511fb1b7957dad066b5bf11010746dfb956b61" translate="yes" xml:space="preserve">
          <source>I recommend reading all of these:</source>
          <target state="translated">我推荐大家阅读这些。</target>
        </trans-unit>
        <trans-unit id="b7928600b482b60ec404a555ac7072bbe1486616" translate="yes" xml:space="preserve">
          <source>I say &quot;your portion of the stack&quot; above because PP code doesn't necessarily get the whole stack to itself: if your function calls another function, you'll only want to expose the arguments aimed for the called function, and not (necessarily) let it get at your own data. The way we do this is to have a &quot;virtual&quot; bottom-of-stack, exposed to each function. The mark stack keeps bookmarks to locations in the argument stack usable by each function. For instance, when dealing with a tied variable, (internally, something with &quot;P&quot; magic) Perl has to call methods for accesses to the tied variables. However, we need to separate the arguments exposed to the method to the argument exposed to the original function - the store or fetch or whatever it may be. Here's roughly how the tied &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is implemented; see &lt;code&gt;av_push&lt;/code&gt; in</source>
          <target state="translated">我之所以在上面说&amp;ldquo;堆栈的一部分&amp;rdquo;，是因为PP代码不一定会使整个堆栈成其自身：如果您的函数调用了另一个函数，则只希望公开针对被调用函数的参数，而不是（不必公开） ），让它获取您自己的数据。我们这样做的方法是让&amp;ldquo;虚拟&amp;rdquo;堆栈底部暴露于每个功能。标记堆栈将书签保留到每个函数可以使用的参数堆栈中的位置。例如，当处理绑定变量时（内部使用&amp;ldquo; P&amp;rdquo;魔术），Perl必须调用方法来访问绑定变量。但是，我们需要将公开给方法的参数与公开给原始函数的参数（存储或提取或任何可能的参数）分开。这里'大致如何实现捆绑 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; ；看到 &lt;code&gt;av_push&lt;/code&gt; in</target>
        </trans-unit>
        <trans-unit id="bd010707291df43195b163d13725276025549dad" translate="yes" xml:space="preserve">
          <source>I still don't get locking. I just want to increment the number in the file. How can I do this?</source>
          <target state="translated">我还是不明白锁定。我只是想增加文件中的数字。如何才能做到这一点?</target>
        </trans-unit>
        <trans-unit id="0c3fa205e2bf9a49a23f4b51209de0f9232902bf" translate="yes" xml:space="preserve">
          <source>I think it would help to give some concrete examples to make it easier to understand the API. Of course I agree that the API has to be concise, but since there is no second document that is more of a guide, I think that it'd make it easier to start with the doc which is an API, but has examples in it in places where things are unclear, to a person who is not a PerlIO guru (yet).</source>
          <target state="translated">我认为给出一些具体的例子会有助于让人们更容易理解API。当然,我同意 API 必须简明扼要,但由于没有第二份文档更像是一份指南,我认为对于一个不是 PerlIO 大师的人来说,从文档开始会更容易,因为文档是 API,但在不清楚的地方提供了例子。</target>
        </trans-unit>
        <trans-unit id="09ffd110a6022c3eacd4a506a275e7c45f272e0d" translate="yes" xml:space="preserve">
          <source>I think that keys as lexicon values makes the completed lexicon entries more readable:</source>
          <target state="translated">我认为将键作为词条值,可以使完成的词条更易读。</target>
        </trans-unit>
        <trans-unit id="794953983b61d639901830159ca78a40665adca3" translate="yes" xml:space="preserve">
          <source>I used 'lynx' to fetch a file, but its contents is all wrong!</source>
          <target state="translated">我用'猞猁'取了一个文件,但它的内容全错了!</target>
        </trans-unit>
        <trans-unit id="14dcb94db4c292bdfbf0b5c851ca4df4a4bf4c31" translate="yes" xml:space="preserve">
          <source>I want to clean up my mess, and install a new perl along with all modules I have. How do I go about it?</source>
          <target state="translated">我想清理一下我的烂摊子,然后把我所有的模块一起安装一个新的perl。我该怎么做呢?</target>
        </trans-unit>
        <trans-unit id="0c2d698fc768ffb8cd382c1370e66993c67187ee" translate="yes" xml:space="preserve">
          <source>I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?</source>
          <target state="translated">我在一个perl脚本中{改变了目录,修改了环境}。为什么我退出脚本的时候,修改就消失了?怎样才能让我的修改可见?</target>
        </trans-unit>
        <trans-unit id="8d4b0ae21d1479e72399aeb9631081d458e4ae16" translate="yes" xml:space="preserve">
          <source>I&amp;lt;bar&amp;gt;</source>
          <target state="translated">I&amp;lt;bar&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3bb667cf6d485cf87366e4fa5d3fb7627b160f2b" translate="yes" xml:space="preserve">
          <source>I'll define the</source>
          <target state="translated">我将定义</target>
        </trans-unit>
        <trans-unit id="5cc9daab4dbfbc15ce11a2a71cb8dfe5485782e2" translate="yes" xml:space="preserve">
          <source>I'm afraid that we're not quite through with the alignment catch yet. The hydra raises another ugly head when you pack arrays of structures:</source>
          <target state="translated">恐怕我们还没有完成对准的捕捉。九头蛇会在你装上数组结构的时候,提出另一个丑陋的头。</target>
        </trans-unit>
        <trans-unit id="f883cc87b6710df9317db1561fdc26ada281ddbe" translate="yes" xml:space="preserve">
          <source>I'm frequently irritated with the CPAN shell's inability to help me select a good mirror.</source>
          <target state="translated">我经常为CPAN壳无法帮助我选择好的镜子而恼火。</target>
        </trans-unit>
        <trans-unit id="70a3ef0517de91698e88a243cc2feee12ba385a3" translate="yes" xml:space="preserve">
          <source>I'm having trouble matching over more than one line. What's wrong?</source>
          <target state="translated">我在多条线上匹配有问题。怎么了?</target>
        </trans-unit>
        <trans-unit id="8b9d03c166b0dec7e59491eb481c804d58495438" translate="yes" xml:space="preserve">
          <source>I'm not totally sure that locale names map satisfactorily to language tags. Think REAL hard about how you use this. YOU HAVE BEEN WARNED.</source>
          <target state="translated">我不太确定locale名称是否能令人满意地映射到语言标签。仔细想想你如何使用这个。你已经被警告了。</target>
        </trans-unit>
        <trans-unit id="73daa2b6bdc84827d06ade0cf82b30946cb9ce40" translate="yes" xml:space="preserve">
          <source>I'm offering this port &quot;as is&quot;. You can ask me questions, but I can't guarantee I'll be able to answer them. There are some excellent books available on the Perl language; consult a book seller.</source>
          <target state="translated">我 &quot;原封不动 &quot;地提供这个端口。您可以向我提出问题,但我不能保证一定能回答。有一些关于 Perl 语言的优秀书籍,请向书商咨询。</target>
        </trans-unit>
        <trans-unit id="4357a589e4e3b7a00e21bb3c83ca3b640b5e0ab8" translate="yes" xml:space="preserve">
          <source>I'm ok, you're not ok.</source>
          <target state="translated">我没事,你有事。</target>
        </trans-unit>
        <trans-unit id="108bd315655f1ba897c01059e340ad678da6e2f4" translate="yes" xml:space="preserve">
          <source>I'm sure most of us have seen code which looks like, (or worse than), this:</source>
          <target state="translated">我相信我们大多数人都见过类似(或比这更糟糕)的代码。</target>
        </trans-unit>
        <trans-unit id="76c00e4567fd7637d5e9878ed4c5f66e616b88b8" translate="yes" xml:space="preserve">
          <source>I've considered making all the above functions that output language tags return all those tags strictly in lowercase. Having all your language tags in lowercase does make some things easier. But you might as well just lowercase as you like, or call &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; where appropriate.</source>
          <target state="translated">我考虑过将上述所有输出语言标签的函数严格地以小写形式返回所有这些标签。将所有语言标签都使用小写确实会使某些事情变得更容易。但是您也可以根据需要 &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; 小写字母，或者在适当的地方调用encode_language_tag（$ lang1）。</target>
        </trans-unit>
        <trans-unit id="88c5fcd7802546df837a3bf463ca41dcbe3c282a" translate="yes" xml:space="preserve">
          <source>I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?</source>
          <target state="translated">我看了perlembed、perlguts等,但我的C程序中无法嵌入perl,我到底做错了什么?</target>
        </trans-unit>
        <trans-unit id="c880785e491d41fc494e4fbfcd55e995f2687586" translate="yes" xml:space="preserve">
          <source>I/O Operators</source>
          <target state="translated">I/O操作员</target>
        </trans-unit>
        <trans-unit id="1fa930eaf91e1f81994700657728c3a757afb3cf" translate="yes" xml:space="preserve">
          <source>I/O flow (the actual 5 minute tutorial)</source>
          <target state="translated">I/O流程(实际5分钟教程)</target>
        </trans-unit>
        <trans-unit id="46fc5fcf49da9b0ec975af77958aa41975a1fe45" translate="yes" xml:space="preserve">
          <source>I/O redirection and backgrounding</source>
          <target state="translated">I/O重定向和背景</target>
        </trans-unit>
        <trans-unit id="8571fe32abe041d9dce3d7d7c47b858f248fa514" translate="yes" xml:space="preserve">
          <source>I18N AND L10N</source>
          <target state="translated">I18N和L10N</target>
        </trans-unit>
        <trans-unit id="e6b903dcac2bbc1b40e43d5e333946755137d36f" translate="yes" xml:space="preserve">
          <source>I18N::Charset</source>
          <target state="translated">I18N::Charset</target>
        </trans-unit>
        <trans-unit id="de5d730fbdbbf0183cf0f4683f1a73058ef3481c" translate="yes" xml:space="preserve">
          <source>I18N::Collate</source>
          <target state="translated">I18N::Collate</target>
        </trans-unit>
        <trans-unit id="01ad2dd6dde49d7565416cd97f4d499093f9d249" translate="yes" xml:space="preserve">
          <source>I18N::Collate - compare 8-bit scalar data according to the current locale</source>
          <target state="translated">I18N::Collate-根据当前locale比较8位标量数据。</target>
        </trans-unit>
        <trans-unit id="e106875b328699ace6767aa9c5ecab5bca3b0bd8" translate="yes" xml:space="preserve">
          <source>I18N::LangTags</source>
          <target state="translated">I18N::LangTags</target>
        </trans-unit>
        <trans-unit id="169f8297167d0e993d7316faae039b48a7c3bab1" translate="yes" xml:space="preserve">
          <source>I18N::LangTags - functions for dealing with RFC3066-style language tags</source>
          <target state="translated">I18N::LangTags-用于处理 RFC3066 风格的语言标签的函数。</target>
        </trans-unit>
        <trans-unit id="921275b7d99f260593561350c7678a20816444ed" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::Detect</source>
          <target state="translated">I18N::LangTags::Detect</target>
        </trans-unit>
        <trans-unit id="778875cc577b876aab7ab802d4648cdcd4ee6cae" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::Detect - detect the user's language preferences</source>
          <target state="translated">I18N::LangTags::Detect-检测用户的语言偏好。</target>
        </trans-unit>
        <trans-unit id="c04ea1622f377702e175508a3a481907575a2f47" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::List</source>
          <target state="translated">I18N::LangTags::List</target>
        </trans-unit>
        <trans-unit id="020bb812c335fc278093b15a03a292e40918c844" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::List -- tags and names for human languages</source>
          <target state="translated">I18N::LangTags::List ----人类语言的标签和名称。</target>
        </trans-unit>
        <trans-unit id="e3646198e54c82833384221bb49e8cf11f385f8f" translate="yes" xml:space="preserve">
          <source>I18N::Langinfo</source>
          <target state="translated">I18N::Langinfo</target>
        </trans-unit>
        <trans-unit id="75f77bed8de0aee0770843a55893169b79d25155" translate="yes" xml:space="preserve">
          <source>I18N::Langinfo - query locale information</source>
          <target state="translated">I18N::Langinfo-本地查询信息。</target>
        </trans-unit>
        <trans-unit id="fde9493a25e191231f11e09ab4dbdd30b2b2a8bf" translate="yes" xml:space="preserve">
          <source>I18N:Collate obsolete</source>
          <target state="translated">I18N:整理过时的</target>
        </trans-unit>
        <trans-unit id="0afef78a7afa599e29cd712fed951b6314ade53c" translate="yes" xml:space="preserve">
          <source>I18n and l10n</source>
          <target state="translated">I18n和l10n</target>
        </trans-unit>
        <trans-unit id="0e13c62333772940b082221be7ca7762de31a069" translate="yes" xml:space="preserve">
          <source>IBM XL C for AIX</source>
          <target state="translated">IBM XL C for AIX</target>
        </trans-unit>
        <trans-unit id="c8afdae11327e149f5501c448b30becf77bc4954" translate="yes" xml:space="preserve">
          <source>IBM XL C/C++ for AIX</source>
          <target state="translated">IBM XL C/C++for AIX</target>
        </trans-unit>
        <trans-unit id="90317bc062fe454cff88014258aea7e36e9b3afc" translate="yes" xml:space="preserve">
          <source>IBM calls its implementation of long doubles 128-bit, but it is not the IEEE 128-bit (&quot;quadruple precision&quot;) which would give 116 bit of mantissa (nor it is implemented in hardware), instead it's a special software implementation called &quot;double-double&quot;, which gives 106 bits of mantissa.</source>
          <target state="translated">IBM把它对长双倍的实现称为128位,但它并不是IEEE 128位(&quot;四倍精度&quot;),这样可以得到116位的口令(也不是在硬件中实现的),而是一种特殊的软件实现,称为 &quot;双倍&quot;,可以得到106位的口令。</target>
        </trans-unit>
        <trans-unit id="896c500f28ef7df0fbbd0268cb9652b7cfe0014c" translate="yes" xml:space="preserve">
          <source>IBM uses the AIX system Perl (V5.6.0 on AIX 5.1 and V5.8.2 on AIX 5.2 / 5.3 and 6.1; V5.8.8 on AIX 5.3 TL11 and AIX 6.1 TL4; V5.10.1 on AIX 7.1) for some AIX system scripts. If you switch the links in /usr/bin from the AIX system Perl (/usr/opt/perl5) to the newly build Perl then you get the same features as with the IBM AIX system Perl if the threaded options are used.</source>
          <target state="translated">IBM使用AIX系统Perl(AIX 5.1上的V5.6.0和AIX 5.2/5.3和6.1上的V5.8.2;AIX 5.3 TL11和AIX 6.1 TL4上的V5.8.8;AIX 7.1上的V5.10.1)来编写一些AIX系统脚本。如果将/usr/bin中的链接从AIX系统Perl(/usr/opt/perl5)切换到新构建的Perl中,那么如果使用线程选项,就可以获得与IBM AIX系统Perl相同的功能。</target>
        </trans-unit>
        <trans-unit id="ade9d724c5b212d6e78013557f35ac5c64927377" translate="yes" xml:space="preserve">
          <source>ICU Character Mapping Tables &lt;a href=&quot;http://site.icu-project.org/charts/charset&quot;&gt;http://site.icu-project.org/charts/charset&lt;/a&gt;</source>
          <target state="translated">ICU字符映射表&lt;a href=&quot;http://site.icu-project.org/charts/charset&quot;&gt;http://site.icu-project.org/charts/charset&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92d0be3756020c7fb70f5f8d43b6e18e96de1472" translate="yes" xml:space="preserve">
          <source>ICU Home Page &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;http://www.icu-project.org/&lt;/a&gt;</source>
          <target state="translated">ICU主页&lt;a href=&quot;http://www.icu-project.org/&quot;&gt;http://www.icu-project.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b3a4d066585cb49384b262b020e538f42a1f2ef" translate="yes" xml:space="preserve">
          <source>ICU:Conversion Data &lt;a href=&quot;http://www.icu-project.org/userguide/conversion-data.html&quot;&gt;http://www.icu-project.org/userguide/conversion-data.html&lt;/a&gt;</source>
          <target state="translated">ICU：转化数据&lt;a href=&quot;http://www.icu-project.org/userguide/conversion-data.html&quot;&gt;http://www.icu-project.org/userguide/conversion-data.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89f89c02cf47e091e726a4e07b88af0966806897" translate="yes" xml:space="preserve">
          <source>ID</source>
          <target state="translated">ID</target>
        </trans-unit>
        <trans-unit id="46c5f048dbe4176fe265d2a79feb829754221b1e" translate="yes" xml:space="preserve">
          <source>IDENTIFYING CHARACTER CODE SETS</source>
          <target state="translated">识别字符代码集。</target>
        </trans-unit>
        <trans-unit id="98eebf3bdf415d089af03ec0debc7c66f797a900" translate="yes" xml:space="preserve">
          <source>IETF Policy on Character Sets and Languages</source>
          <target state="translated">IETF字符集和语言政策</target>
        </trans-unit>
        <trans-unit id="6a5d66d70494ee5ff5a453f224b81868447c393b" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION</source>
          <target state="translated">IMPLEMENTATION</target>
        </trans-unit>
        <trans-unit id="282613097967896b3e57bca75eb0bce558486a26" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION DETAILS</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="0e35eae7c0731d3856fc41389b70ba2d34677ec0" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION NOTE</source>
          <target state="translated">执行说明</target>
        </trans-unit>
        <trans-unit id="00f6ac93461571c87bf08a0fa480109344a9be63" translate="yes" xml:space="preserve">
          <source>IMPLICIT LOADING</source>
          <target state="translated">暗示性加载</target>
        </trans-unit>
        <trans-unit id="926527594f94772fcf38d60a2b632b1bb4c3c38c" translate="yes" xml:space="preserve">
          <source>IMPORTANT!</source>
          <target state="translated">IMPORTANT!</target>
        </trans-unit>
        <trans-unit id="c2e68d710cae68fae1b4d1132f818132a6f1837f" translate="yes" xml:space="preserve">
          <source>IMPORTANT: if you use this &lt;code&gt;-S&lt;/code&gt; switch, be sure to delete the CONFIG environment variable before running the script:</source>
          <target state="translated">重要说明：如果使用此 &lt;code&gt;-S&lt;/code&gt; 开关，请确保在运行脚本之前删除CONFIG环境变量：</target>
        </trans-unit>
        <trans-unit id="7696e648752c3c28012375bdb960a19fe39b8205" translate="yes" xml:space="preserve">
          <source>IMPORTS THE FUNCTIONS</source>
          <target state="translated">导入功能</target>
        </trans-unit>
        <trans-unit id="6a09657af85954f963dea9fb1156c8ea7994677c" translate="yes" xml:space="preserve">
          <source>IN6ADDR_ANY, IN6ADDR_LOOPBACK</source>
          <target state="translated">IN6ADDR_ANY,IN6ADDR_LOOPBACK。</target>
        </trans-unit>
        <trans-unit id="8b4b83ea115334b0957635d43569bbc4350f1369" translate="yes" xml:space="preserve">
          <source>INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE</source>
          <target state="translated">INADDR_ANY,INADDR_BROADCAST,INADDR_LOOPBACK,INADDR_NONE。</target>
        </trans-unit>
        <trans-unit id="cbe356b54ea95780c909073ac988ee31715e5615" translate="yes" xml:space="preserve">
          <source>INDIVIDUAL RESULTS</source>
          <target state="translated">单独的结果</target>
        </trans-unit>
        <trans-unit id="87d0fcde0a601e06d986c8740283892296dbb885" translate="yes" xml:space="preserve">
          <source>INHERITANCE</source>
          <target state="translated">INHERITANCE</target>
        </trans-unit>
        <trans-unit id="bc46a4e0420d357db7bfbcb7b5fcbc613dc48c1b" translate="yes" xml:space="preserve">
          <source>INIT</source>
          <target state="translated">INIT</target>
        </trans-unit>
        <trans-unit id="c335a27a082cc8d17dd36dc0eda3086cb0c9baaa" translate="yes" xml:space="preserve">
          <source>INSTALL</source>
          <target state="translated">INSTALL</target>
        </trans-unit>
        <trans-unit id="bcfd83b3c8dcdbc242801037551b58c708467a92" translate="yes" xml:space="preserve">
          <source>INSTALL PERL ON CYGWIN</source>
          <target state="translated">在CYGWIN上安装PERL</target>
        </trans-unit>
        <trans-unit id="9d09dba09f4e15504911bf4a5e67189762904dd8" translate="yes" xml:space="preserve">
          <source>INSTALLATION</source>
          <target state="translated">INSTALLATION</target>
        </trans-unit>
        <trans-unit id="16fff6f9fc1411630b91667c135606baff1eac91" translate="yes" xml:space="preserve">
          <source>INSTALLING PERL IN OPENVOS</source>
          <target state="translated">在OPENVOS中安装PERL。</target>
        </trans-unit>
        <trans-unit id="df84db65783bcfd646d621819ed5a53534ed4081" translate="yes" xml:space="preserve">
          <source>INSTALLSITELIB=i:\perl\lib</source>
          <target state="translated">INSTALLSITELIB=i:\perl\lib</target>
        </trans-unit>
        <trans-unit id="f1bd7855c675170fd5743049f5030b83e6d9486c" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE</source>
          <target state="translated">INSTALL_BASE</target>
        </trans-unit>
        <trans-unit id="972644501aef360867a4520d3945803529f2cc3e" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE can be passed into Makefile.PL to change where your module will be installed. INSTALL_BASE is more like what everyone else calls &quot;prefix&quot; than PREFIX is.</source>
          <target state="translated">INSTALL_BASE 可以传递到 Makefile.PL 中来改变模块的安装位置。INSTALL_BASE比PREFIX更像大家所说的 &quot;前缀&quot;。</target>
        </trans-unit>
        <trans-unit id="964f70f55608056234ee8f272195661f239be038" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE in MakeMaker and &lt;code&gt;--install_base&lt;/code&gt; in Module::Build (as of 0.28) install to the same location. If you want MakeMaker and Module::Build to install to the same location simply set INSTALL_BASE and &lt;code&gt;--install_base&lt;/code&gt; to the same location.</source>
          <target state="translated">MakeMaker中的INSTALL_BASE和Module :: Build中的 &lt;code&gt;--install_base&lt;/code&gt; （自0.28起）安装到同一位置。如果要将MakeMaker和Module :: Build安装到同一位置，只需将INSTALL_BASE和 &lt;code&gt;--install_base&lt;/code&gt; 设置到同一位置。</target>
        </trans-unit>
        <trans-unit id="c3f863f63a3576929f3be4a5b8b4b41019807a08" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE tells these tools to put your modules into</source>
          <target state="translated">INSTALL_BASE会告诉这些工具把你的模块放到</target>
        </trans-unit>
        <trans-unit id="7b883de1f22bd64a8fb3db547deeba102b803a0e" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE was added in 6.31.</source>
          <target state="translated">在6.31中增加了INSTALL_BASE。</target>
        </trans-unit>
        <trans-unit id="6f436e25f27f33e27c6053472309a17baa61d133" translate="yes" xml:space="preserve">
          <source>INTERFACE</source>
          <target state="translated">INTERFACE</target>
        </trans-unit>
        <trans-unit id="325df994199a5a3b5bfde97c65a8f35d498e9bab" translate="yes" xml:space="preserve">
          <source>INTERNAL FORMAT</source>
          <target state="translated">内部格式</target>
        </trans-unit>
        <trans-unit id="f2ee4f9d199f048c10a5b49f80f81e925ff271d9" translate="yes" xml:space="preserve">
          <source>INTERNAL VARIABLE TYPES</source>
          <target state="translated">内部变量类型</target>
        </trans-unit>
        <trans-unit id="ae880205d974d478a4f8301ed9ed724acfe764dd" translate="yes" xml:space="preserve">
          <source>INTERNALS</source>
          <target state="translated">INTERNALS</target>
        </trans-unit>
        <trans-unit id="0270ca97abe5bddc53ed95fb7179da4406621a18" translate="yes" xml:space="preserve">
          <source>INTRODUCTION</source>
          <target state="translated">INTRODUCTION</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="9703b620b98df0424c1d2891029b0a53270adadc" translate="yes" xml:space="preserve">
          <source>IO - load various IO modules</source>
          <target state="translated">IO--加载各种IO模块</target>
        </trans-unit>
        <trans-unit id="8218c7c584e2e73f83429a7a715ed0c77b1e9143" translate="yes" xml:space="preserve">
          <source>IO Functions</source>
          <target state="translated">IO功能</target>
        </trans-unit>
        <trans-unit id="c2e82ec6ecdf1d506a4bc4471deaf660ec582141" translate="yes" xml:space="preserve">
          <source>IO:: style interface to &lt;a href=&quot;compress/zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="translated">IO ::样式接口到&lt;a href=&quot;compress/zlib&quot;&gt;Compress :: Zlib&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d76ad5f2ab8e85a14e373d86896f0b50ad94632d" translate="yes" xml:space="preserve">
          <source>IO::Compress::Base</source>
          <target state="translated">IO::Compress::Base</target>
        </trans-unit>
        <trans-unit id="f7a823195ba1022235bbaa930f5dacd9dcd2cde3" translate="yes" xml:space="preserve">
          <source>IO::Compress::Base - Base Class for IO::Compress modules</source>
          <target state="translated">IO::Compress::Base-IO::Compress模块的基类。</target>
        </trans-unit>
        <trans-unit id="2246092601d71db730b1277537bdfeb99922692b" translate="yes" xml:space="preserve">
          <source>IO::Compress::Bzip2</source>
          <target state="translated">IO::Compress::Bzip2</target>
        </trans-unit>
        <trans-unit id="4c110e2dd18855a5ac17fa0ff96df45279296253" translate="yes" xml:space="preserve">
          <source>IO::Compress::Bzip2 - Write bzip2 files/buffers</source>
          <target state="translated">IO::Compress::Bzip2-写入bzip2文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="faeedf86bc5c3bf443dc7cb32aca40a75c1a61b1" translate="yes" xml:space="preserve">
          <source>IO::Compress::Deflate</source>
          <target state="translated">IO::Compress::Deflate</target>
        </trans-unit>
        <trans-unit id="a24fa13516822c712bdf720b0c4b0786c457612f" translate="yes" xml:space="preserve">
          <source>IO::Compress::Deflate - Write RFC 1950 files/buffers</source>
          <target state="translated">IO::Compress::Deflate-写入RFC 1950文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="f27ab19280760fb919a1e3287acc4b2ced04c845" translate="yes" xml:space="preserve">
          <source>IO::Compress::FAQ</source>
          <target state="translated">IO::Compress::FAQ</target>
        </trans-unit>
        <trans-unit id="c7fa9683b439c9ad1a7266191cc46683626bdae6" translate="yes" xml:space="preserve">
          <source>IO::Compress::Gzip</source>
          <target state="translated">IO::Compress::Gzip</target>
        </trans-unit>
        <trans-unit id="9e41ceaa77fd713ed3c8d8b1bfe6a609a7ddcea6" translate="yes" xml:space="preserve">
          <source>IO::Compress::Gzip - Write RFC 1952 files/buffers</source>
          <target state="translated">IO::Compress::Gzip-写入RFC 1952文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="3205da05670e0698dd32ff4811dcf7e209aab757" translate="yes" xml:space="preserve">
          <source>IO::Compress::RawDeflate</source>
          <target state="translated">IO::Compress::RawDeflate</target>
        </trans-unit>
        <trans-unit id="94bf2f893b55a2f57dfacc0d6c1e83c0ef44793d" translate="yes" xml:space="preserve">
          <source>IO::Compress::RawDeflate - Write RFC 1951 files/buffers</source>
          <target state="translated">IO::Compress::RawDeflate-写入RFC 1951文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="7015e5f6eae1214c2df0155ccaef808cdc7d0769" translate="yes" xml:space="preserve">
          <source>IO::Compress::Zip</source>
          <target state="translated">IO::Compress::Zip</target>
        </trans-unit>
        <trans-unit id="b05cb1e00a4226cff2f721fcd3f609b4ad94b38c" translate="yes" xml:space="preserve">
          <source>IO::Compress::Zip - Write zip files/buffers</source>
          <target state="translated">IO::Compress::Zip-写入zip文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="4bf7c8cfd258e92c5a7a288432da2eb725c5d32c" translate="yes" xml:space="preserve">
          <source>IO::Dir</source>
          <target state="translated">IO::Dir</target>
        </trans-unit>
        <trans-unit id="f3b94128fba8d6583679638179ef4a0530bdd5d3" translate="yes" xml:space="preserve">
          <source>IO::Dir - supply object methods for directory handles</source>
          <target state="translated">IO::Dir-为目录句柄提供对象方法</target>
        </trans-unit>
        <trans-unit id="1287d92d070eaf8f54116ae56a21bfe69917a99d" translate="yes" xml:space="preserve">
          <source>IO::File</source>
          <target state="translated">IO::File</target>
        </trans-unit>
        <trans-unit id="aef399115f05d82a203fb89d5e657a748c3e82de" translate="yes" xml:space="preserve">
          <source>IO::File - supply object methods for filehandles</source>
          <target state="translated">IO::File-为filehandles提供对象方法。</target>
        </trans-unit>
        <trans-unit id="85678e755d6fdd386f63c43333047c282a85eb74" translate="yes" xml:space="preserve">
          <source>IO::Handle</source>
          <target state="translated">IO::Handle</target>
        </trans-unit>
        <trans-unit id="d2ccf931b06cca09cc21fc6e3f7adaeb42eedc30" translate="yes" xml:space="preserve">
          <source>IO::Handle - supply object methods for I/O handles</source>
          <target state="translated">IO::Handle-为I/O句柄提供对象方法。</target>
        </trans-unit>
        <trans-unit id="33e6674e03fd1f9387dffec88a9442f12eb239c1" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;format_formfeed(EXPR)</source>
          <target state="translated">IO::Handle-&amp;gt;format_formfeed(EXPR)</target>
        </trans-unit>
        <trans-unit id="4328314a142bc495dbcedc8dec821af05b31bc33" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;format_line_break_characters EXPR</source>
          <target state="translated">IO :: Handle-&amp;gt; format_line_break_characters EXPR</target>
        </trans-unit>
        <trans-unit id="6e5d46bf8e867cd748990f3121e29b41bc040337" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;input_record_separator( EXPR )</source>
          <target state="translated">IO :: Handle-&amp;gt; input_record_separator（EXPR）</target>
        </trans-unit>
        <trans-unit id="88d38bb7198b1035ad2fe3e3a4c8b631ea81ae89" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;output_field_separator( EXPR )</source>
          <target state="translated">IO :: Handle-&amp;gt; output_field_separator（EXPR）</target>
        </trans-unit>
        <trans-unit id="960c5c651b09566f1754a215a5295869a49e219e" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;output_record_separator( EXPR )</source>
          <target state="translated">IO :: Handle-&amp;gt; output_record_separator（EXPR）</target>
        </trans-unit>
        <trans-unit id="7d7436d4629d382e64fc528a233e4705d021fb55" translate="yes" xml:space="preserve">
          <source>IO::Pipe</source>
          <target state="translated">IO::Pipe</target>
        </trans-unit>
        <trans-unit id="00e90fb1e0a6527593ec48869ad8bdd4be4727ec" translate="yes" xml:space="preserve">
          <source>IO::Pipe - supply object methods for pipes</source>
          <target state="translated">IO::Pipe-为管道提供对象方法。</target>
        </trans-unit>
        <trans-unit id="7411852690ce77d3e52c0392cb140a1da3c8926a" translate="yes" xml:space="preserve">
          <source>IO::Poll</source>
          <target state="translated">IO::Poll</target>
        </trans-unit>
        <trans-unit id="4af10858345e94c5247f732b4f8aeefb3d3033f8" translate="yes" xml:space="preserve">
          <source>IO::Poll - Object interface to system poll call</source>
          <target state="translated">IO::Poll-系统轮询调用的对象接口。</target>
        </trans-unit>
        <trans-unit id="a68be240586077bf55c7114e0c2dd0a3089b0b00" translate="yes" xml:space="preserve">
          <source>IO::Seekable</source>
          <target state="translated">IO::Seekable</target>
        </trans-unit>
        <trans-unit id="aca83121c079f3f44793e1fb400037048e6c0ec3" translate="yes" xml:space="preserve">
          <source>IO::Seekable - supply seek based methods for I/O objects</source>
          <target state="translated">IO::Seekable-为I/O对象提供基于寻求的方法。</target>
        </trans-unit>
        <trans-unit id="a4d83b02d49f96871e2c2e3d92dc1e0d34ec01f3" translate="yes" xml:space="preserve">
          <source>IO::Select</source>
          <target state="translated">IO::Select</target>
        </trans-unit>
        <trans-unit id="f909f3c8685d0640556ffd855c6e6b3161826eb6" translate="yes" xml:space="preserve">
          <source>IO::Select - OO interface to the select system call</source>
          <target state="translated">IO::Select-用于选择系统调用的OO接口。</target>
        </trans-unit>
        <trans-unit id="77ccdb7781ae721df7a63530341f8d0e30eb9ba3" translate="yes" xml:space="preserve">
          <source>IO::Socket</source>
          <target state="translated">IO::Socket</target>
        </trans-unit>
        <trans-unit id="bcf86f1138a4fa3de29dc58d70750df124a76378" translate="yes" xml:space="preserve">
          <source>IO::Socket - Object interface to socket communications</source>
          <target state="translated">IO::Socket-套接字通信的对象接口。</target>
        </trans-unit>
        <trans-unit id="d9cad026ce1354129e7518abf6e60742a423f5cd" translate="yes" xml:space="preserve">
          <source>IO::Socket::INET</source>
          <target state="translated">IO::Socket::INET</target>
        </trans-unit>
        <trans-unit id="21c7e3d3993af799697bb17b584159010291f1ca" translate="yes" xml:space="preserve">
          <source>IO::Socket::INET - Object interface for AF_INET domain sockets</source>
          <target state="translated">IO::Socket::INET-AF_INET域套接字的对象接口。</target>
        </trans-unit>
        <trans-unit id="8d370bee8efab5b347f028125483323b0c8ed6d8" translate="yes" xml:space="preserve">
          <source>IO::Socket::UNIX</source>
          <target state="translated">IO::Socket::UNIX</target>
        </trans-unit>
        <trans-unit id="fd6fc205eb14f250173655f91ae8e3991e80a0fc" translate="yes" xml:space="preserve">
          <source>IO::Socket::UNIX - Object interface for AF_UNIX domain sockets</source>
          <target state="translated">IO::Socket::UNIX-AF_UNIX域套接字的对象接口。</target>
        </trans-unit>
        <trans-unit id="cc9efdf30a325c69f4eff01ffa74edfa8d13285c" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyInflate</source>
          <target state="translated">IO::Uncompress::AnyInflate</target>
        </trans-unit>
        <trans-unit id="3f52359b31109c62a3cfec4235eb32afa54b7e76" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyInflate - Uncompress zlib-based (zip, gzip) file/buffer</source>
          <target state="translated">IO::Uncompress::AnyInflate-解压基于zlib(zip,gzip)的文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="9bcf772c56ff61361b8adfe8ed0930e47dd806cc" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyUncompress</source>
          <target state="translated">IO::Uncompress::AnyUncompress</target>
        </trans-unit>
        <trans-unit id="da915e62cd2924afaf5bdf41d62bf124d1816c96" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyUncompress - Uncompress gzip, zip, bzip2 or lzop file/buffer</source>
          <target state="translated">IO::Uncompress::AnyUncompress-解压gzip、zip、bzip2或lzop文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="5b9d98befeabd4f68c0ee5ed490ad9ef9466ce0b" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Base</source>
          <target state="translated">IO::Uncompress::Base</target>
        </trans-unit>
        <trans-unit id="6dd0aef5e96daa96cabb662e679bcaf3f782ff34" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Base - Base Class for IO::Uncompress modules</source>
          <target state="translated">IO::Uncompress::Base-IO::Uncompress模块的基类。</target>
        </trans-unit>
        <trans-unit id="47626e73b0c552496671b93615517289c7a72139" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Bunzip2</source>
          <target state="translated">IO::Uncompress::Bunzip2</target>
        </trans-unit>
        <trans-unit id="558fc1d47555183743c62caa50f8fea7e57150e4" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Bunzip2 - Read bzip2 files/buffers</source>
          <target state="translated">IO::Uncompress::Bunzip2-读取bzip2文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="c56a044dac563ce20e270b6dad9d51e1ed4d67b5" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Gunzip</source>
          <target state="translated">IO::Uncompress::Gunzip</target>
        </trans-unit>
        <trans-unit id="6858dbc4b4fa294b4bc17de10e3aec6d95c7a29d" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Gunzip - Read RFC 1952 files/buffers</source>
          <target state="translated">IO::Uncompress::Gunzip-读取RFC 1952文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="bdd707a0a7c129500d87baf2238a9f12252dc1a6" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Inflate</source>
          <target state="translated">IO::Uncompress::Inflate</target>
        </trans-unit>
        <trans-unit id="9ea3fd5cd65551930396ea883f6b4523a57e56f5" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Inflate - Read RFC 1950 files/buffers</source>
          <target state="translated">IO::Uncompress::Inflate-读取RFC 1950文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="2387ca346858e6f631ae40207df5832845bfa4d3" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::RawInflate</source>
          <target state="translated">IO::Uncompress::RawInflate</target>
        </trans-unit>
        <trans-unit id="0d1105cd05d8ddcb7bbad73158149f37cd425d0a" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::RawInflate - Read RFC 1951 files/buffers</source>
          <target state="translated">IO::Uncompress::RawInflate-读取RFC1951文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="eb25986effc3adf3d081252f8af9cf0ffcfb3a8a" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Unzip</source>
          <target state="translated">IO::Uncompress::Unzip</target>
        </trans-unit>
        <trans-unit id="7aed8f7e034916e56f4674cc0310d37a446ee94f" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Unzip - Read zip files/buffers</source>
          <target state="translated">IO::Uncompress::Unzip-读取zip文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="f4c4eb93eddc35e78414020ae5db828e1e7864b8" translate="yes" xml:space="preserve">
          <source>IO::Zlib</source>
          <target state="translated">IO::Zlib</target>
        </trans-unit>
        <trans-unit id="d04446e459b1e71b578f998f8ab90764c4b0f8e3" translate="yes" xml:space="preserve">
          <source>IO::Zlib - IO:: style interface to &lt;a href=&quot;../compress/zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="translated">IO :: Zlib- &lt;a href=&quot;../compress/zlib&quot;&gt;压缩:: Zlib的&lt;/a&gt; IO ::样式接口</target>
        </trans-unit>
        <trans-unit id="e66f01e3abb1a4678f130fa0379ceec3adaec42e" translate="yes" xml:space="preserve">
          <source>IP protocol constants to use as the third argument to socket(), the level argument to getsockopt() or setsockopt(), or the value of the &lt;code&gt;SO_PROTOCOL&lt;/code&gt; socket option.</source>
          <target state="translated">IP协议常量，用作socket（）的第三个参数，getsockopt（）或setsockopt（）的level参数，或 &lt;code&gt;SO_PROTOCOL&lt;/code&gt; 套接字选项的值。</target>
        </trans-unit>
        <trans-unit id="25bb80888fafae35a8c04a482f4c52ba12354860" translate="yes" xml:space="preserve">
          <source>IPC::Cmd</source>
          <target state="translated">IPC::Cmd</target>
        </trans-unit>
        <trans-unit id="4aa727aa3bbf49a23200ff9a15dd661ace7ba750" translate="yes" xml:space="preserve">
          <source>IPC::Cmd - finding and running system commands made easy</source>
          <target state="translated">IPC::Cmd-让查找和运行系统命令变得更容易。</target>
        </trans-unit>
        <trans-unit id="9e94bec610bda8b6d6dba9768e7c89860ea7cbd2" translate="yes" xml:space="preserve">
          <source>IPC::Cmd allows you to run commands platform independently, interactively if desired, but have them still work.</source>
          <target state="translated">IPC::Cmd允许你独立地运行命令平台,如果需要的话,可以交互式地运行,但仍然可以工作。</target>
        </trans-unit>
        <trans-unit id="55a4e391e67ff1bdcc3e16ba0fb5ae458ce57904" translate="yes" xml:space="preserve">
          <source>IPC::Msg</source>
          <target state="translated">IPC::Msg</target>
        </trans-unit>
        <trans-unit id="6b32de39850adb752165f60b3bda5f0d97f34ff3" translate="yes" xml:space="preserve">
          <source>IPC::Msg - SysV Msg IPC object class</source>
          <target state="translated">IPC::Msg-SysV Msg IPC对象类</target>
        </trans-unit>
        <trans-unit id="9dd902f8639b58e7edb7b6f8c06c22ac41c9ca2e" translate="yes" xml:space="preserve">
          <source>IPC::Open2</source>
          <target state="translated">IPC::Open2</target>
        </trans-unit>
        <trans-unit id="699765d9577f1c1501174faba27f2ca1f61d47cd" translate="yes" xml:space="preserve">
          <source>IPC::Open2 - open a process for both reading and writing using open2()</source>
          <target state="translated">IPC::Open2-使用open2()打开一个读写进程。</target>
        </trans-unit>
        <trans-unit id="6e80951681402ceb79b82897f2cb2015d59ab625" translate="yes" xml:space="preserve">
          <source>IPC::Open3</source>
          <target state="translated">IPC::Open3</target>
        </trans-unit>
        <trans-unit id="cbebbea4476633d292dae0e9b37d3ff0220e8a12" translate="yes" xml:space="preserve">
          <source>IPC::Open3 - open a process for reading, writing, and error handling using open3()</source>
          <target state="translated">IPC::Open3-使用open3()打开一个进程进行读、写和错误处理。</target>
        </trans-unit>
        <trans-unit id="5696dbec647d54eae7948ff758da75aceb6e7bdd" translate="yes" xml:space="preserve">
          <source>IPC::Semaphore</source>
          <target state="translated">IPC::Semaphore</target>
        </trans-unit>
        <trans-unit id="4ac3e2f97ecebc0c9df272394b412c2bc0e4c139" translate="yes" xml:space="preserve">
          <source>IPC::Semaphore - SysV Semaphore IPC object class</source>
          <target state="translated">IPC::Semaphore-SysV Semaphore IPC对象类。</target>
        </trans-unit>
        <trans-unit id="eaac05351199d5338d0c67774a49f0ff5b08ddcd" translate="yes" xml:space="preserve">
          <source>IPC::SharedMem</source>
          <target state="translated">IPC::SharedMem</target>
        </trans-unit>
        <trans-unit id="b67329129b7437abd470390d9b8de8b506578731" translate="yes" xml:space="preserve">
          <source>IPC::SharedMem - SysV Shared Memory IPC object class</source>
          <target state="translated">IPC::SharedMem-SysV共享内存IPC对象类。</target>
        </trans-unit>
        <trans-unit id="cac6bf077ecf12b8c4774537cb90121c12f40546" translate="yes" xml:space="preserve">
          <source>IPC::SysV</source>
          <target state="translated">IPC::SysV</target>
        </trans-unit>
        <trans-unit id="4a65a5b9999ec2f5bcb9aefce9ed4d2ebb83e351" translate="yes" xml:space="preserve">
          <source>IPC::SysV - System V IPC constants and system calls</source>
          <target state="translated">IPC::SysV-系统 V IPC 常量和系统调用。</target>
        </trans-unit>
        <trans-unit id="eb04f21953f498789cba10742ad8acc6a3a6d8ee" translate="yes" xml:space="preserve">
          <source>IPC::[Run|Open3] will first read all of STDOUT, then all of STDERR, meaning the output looks like '13' on STDOUT and '24' on STDERR, instead of</source>
          <target state="translated">IPC::[Run|Open3]将首先读取所有的STDOUT,然后再读取所有的STDERR,这意味着输出在STDOUT上是'13',在STDERR上是'24',而非</target>
        </trans-unit>
        <trans-unit id="c31963d765721dcd50b3ac6ea7828e71081eb9d0" translate="yes" xml:space="preserve">
          <source>IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ...</source>
          <target state="translated">IPPROTO_IP,IPPROTO_IPV6,IPPROTO_TCP,...。</target>
        </trans-unit>
        <trans-unit id="d605f8c901e4d72b551c09d9a4925d13cd9fbbb6" translate="yes" xml:space="preserve">
          <source>IPTOS_LOWDELAY, IPTOS_THROUGHPUT, IPTOS_RELIABILITY, ...</source>
          <target state="translated">IPTOS_LOWDELAY,IPTOS_THROUGHPUT,IPTOS_RELIABILITY,...。</target>
        </trans-unit>
        <trans-unit id="b69eb35e4d4802a904ccf4f4eadf16b1c7831980" translate="yes" xml:space="preserve">
          <source>IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ...</source>
          <target state="translated">IPV6_ADD_MEMBERSHIP,IPV6_MTU,IPV6_V6ONLY,...</target>
        </trans-unit>
        <trans-unit id="5dcc16ca06e8e1e2d76e2715098a08de9cb62845" translate="yes" xml:space="preserve">
          <source>IP_OPTIONS, IP_TOS, IP_TTL, ...</source>
          <target state="translated">IP_OPTIONS,IP_TOS,IP_TTL,...</target>
        </trans-unit>
        <trans-unit id="a68fa8efe4a09d8c0c63ae60426d9366434bccb2" translate="yes" xml:space="preserve">
          <source>IRC</source>
          <target state="translated">IRC</target>
        </trans-unit>
        <trans-unit id="e845e309f2bc4605301c4c8195c02b9ee45aab86" translate="yes" xml:space="preserve">
          <source>IRIX 6.5 documentation on syslog, &lt;a href=&quot;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&quot;&gt;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&lt;/a&gt;</source>
          <target state="translated">Syslog上的IRIX 6.5文档，&lt;a href=&quot;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&quot;&gt;http：&lt;/a&gt; //techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi？coll = 0650＆db = man＆fname = 3c + syslog</target>
        </trans-unit>
        <trans-unit id="f776e0bcef88f6053e04b30cd9568a2f517c3848" translate="yes" xml:space="preserve">
          <source>ISO 6429 is available from ISO for a charge; the author of this module does not own a copy of it. Since the source material for ISO 6429 was ECMA-048 and the latter is available for free, there seems little reason to obtain the ISO standard.</source>
          <target state="translated">ISO 6429标准可向ISO收费索取;本单元的作者不拥有该标准的副本。由于ISO 6429的原始材料是ECMA-048,而后者是免费提供的,因此似乎没有什么理由获得ISO标准。</target>
        </trans-unit>
        <trans-unit id="3353e215f71b71f7414efad5057c41576384753e" translate="yes" xml:space="preserve">
          <source>ISO 8859</source>
          <target state="translated">ISO 8859</target>
        </trans-unit>
        <trans-unit id="8fb0773017f88d072a29c4af9bf4189cc9c9a466" translate="yes" xml:space="preserve">
          <source>ISO 8859-1 (Latin-1)</source>
          <target state="translated">ISO 8859-1(拉丁文-1)</target>
        </trans-unit>
        <trans-unit id="58189607ac5de761659ad85bfe08184fa60a5f97" translate="yes" xml:space="preserve">
          <source>ISO codes for country sub-divisions (states, counties, provinces, etc), as defined in ISO 3166-2. This module is not part of the Locale-Codes distribution, but is available from CPAN in CPAN/modules/by-module/Locale/</source>
          <target state="translated">ISO 3166-2中定义的国家分区(州、县、省等)的ISO代码。该模块不属于Locale-Codes发行版,但可从CPAN/modules/by-module/Locale/中获得。</target>
        </trans-unit>
        <trans-unit id="e2562b9e7af09019f9f6f2808d127ef571d29778" translate="yes" xml:space="preserve">
          <source>ISO-2022-JP-1 (RFC2237) is a superset of ISO-2022-JP (RFC1468) which adds support for JIS X 0212-1990. That means you can use the same code to decode to utf8 but not vice versa.</source>
          <target state="translated">ISO-2022-JP-1(RFC2237)是ISO-2022-JP(RFC1468)的超集,增加了对JIS X 0212-1990的支持。这意味着您可以使用相同的代码来解码到utf8,但不能反过来。</target>
        </trans-unit>
        <trans-unit id="13dc9cc90e3e41be961fd70df5f28ccfd86e620a" translate="yes" xml:space="preserve">
          <source>ISSUES</source>
          <target state="translated">ISSUES</target>
        </trans-unit>
        <trans-unit id="6c84053d4886e789ea8b111c5248970e59a2046c" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_NOT_INT will be set with IS_NUMBER_IN_UV if trailing decimals were seen (in which case *valuep gives the true value truncated to an integer), and IS_NUMBER_NEG if the number is negative (in which case *valuep holds the absolute value). IS_NUMBER_IN_UV is not set if e notation was used or the number is larger than a UV.</source>
          <target state="translated">如果看到尾数为小数,IS_NUMBER_NOT_INT将与IS_NUMBER_IN_UV一起设置(在这种情况下,*valuep给出了截断为整数的真值),如果数字为负数,IS_NUMBER_NEG将与IS_NUMBER_IN_UV一起设置(在这种情况下,*valuep持有绝对值)。如果使用了e符号或者数字大于UV,则不设置IS_NUMBER_IN_UV。</target>
        </trans-unit>
        <trans-unit id="e849c5f96439c1fe622e4ace3225dd079d5ce0bc" translate="yes" xml:space="preserve">
          <source>ITEM</source>
          <target state="translated">ITEM</target>
        </trans-unit>
        <trans-unit id="e98fda145e73c44d41ee1cf81a9942997f60dc03" translate="yes" xml:space="preserve">
          <source>ITEM...</source>
          <target state="translated">ITEM...</target>
        </trans-unit>
        <trans-unit id="81355db038b4c2e62588bc2f02426816803c8b50" translate="yes" xml:space="preserve">
          <source>ITEMHASH</source>
          <target state="translated">ITEMHASH</target>
        </trans-unit>
        <trans-unit id="932eaaf5a36529c34a7868b56cba634f534f39b4" translate="yes" xml:space="preserve">
          <source>IV</source>
          <target state="translated">IV</target>
        </trans-unit>
        <trans-unit id="3776b457f4a64c1c2e929c3beb97e225d7174238" translate="yes" xml:space="preserve">
          <source>Iain Truskett. Updated by the Perl 5 Porters.</source>
          <target state="translated">Iain Truskett。由 Perl 5 Porters 更新。</target>
        </trans-unit>
        <trans-unit id="d3280028436889a62f2d1e26e6623a3b63327bf8" translate="yes" xml:space="preserve">
          <source>Idea by Tony Bowden and Paul Johnson, code by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, wardrobe by Calvin Klein.</source>
          <target state="translated">Tony Bowden和Paul Johnson的创意，Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;的代码，Calvin Klein的衣柜。</target>
        </trans-unit>
        <trans-unit id="38eaa27bde2babc938a1d3f61f24a4c3c9ee9393" translate="yes" xml:space="preserve">
          <source>Ideally, all instances of &lt;code&gt;PL_sub_generation++&lt;/code&gt; in perl source outside of</source>
          <target state="translated">理想情况下，perl源代码中 &lt;code&gt;PL_sub_generation++&lt;/code&gt; 之外的所有实例</target>
        </trans-unit>
        <trans-unit id="b72ac1e7c6fddbcf97426592a619f53420c1c124" translate="yes" xml:space="preserve">
          <source>Ideally, someone who's slightly familiar with your module should be able to refresh their memory without hitting &quot;page down&quot;. As your reader continues through the document, they should receive a progressively greater amount of knowledge.</source>
          <target state="translated">理想的情况是,对你的模块稍微熟悉的人应该能够在不点击 &quot;向下翻页 &quot;的情况下刷新他们的记忆。当你的读者继续浏览文档时,他们应该会逐渐接受更多的知识。</target>
        </trans-unit>
        <trans-unit id="71c30d178b22c94b418adae6de96d27ac6651de9" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;#lrint&quot;&gt;lrint&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#lrint&quot;&gt;林特&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="189f7c8820b5d91329256424f9abd34533abf5d2" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;has_errors&lt;/code&gt; , but also returns true if any TODO tests unexpectedly succeeded. This is more akin to &quot;warnings&quot;.</source>
          <target state="translated">与 &lt;code&gt;has_errors&lt;/code&gt; 相同，但是如果任何TODO测试意外成功，也返回true。这更类似于&amp;ldquo;警告&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="725851e6339b491e1de8826e667b9695d8cea364" translate="yes" xml:space="preserve">
          <source>Identical to grok_number_flags() with flags set to zero.</source>
          <target state="translated">与grok_number_flags()相同,但flags设置为0。</target>
        </trans-unit>
        <trans-unit id="9052a2716f89fc7937386d07b0ec6eb570325f21" translate="yes" xml:space="preserve">
          <source>Identifier parsing</source>
          <target state="translated">识别解析</target>
        </trans-unit>
        <trans-unit id="96bd1c9d626bb40d98db0e06c9d88504407f597b" translate="yes" xml:space="preserve">
          <source>Identifies _POSIX_ARG_MAX as a constant sub, optimized to an IV. Although POSIX isn't entirely consistent across platforms, this is likely to be present in virtually all of them.</source>
          <target state="translated">将 _POSIX_ARG_MAX 识别为一个常量子,优化为 IV。虽然POSIX在各个平台上并不完全一致,但几乎所有的平台都可能存在这种情况。</target>
        </trans-unit>
        <trans-unit id="651807fc401b8332ec409deb81843bccbd052364" translate="yes" xml:space="preserve">
          <source>Identifies md5 as an XS function. The export is needed so that BC can find it in main.</source>
          <target state="translated">将md5标识为XS函数。需要导出,以便BC能在main中找到它。</target>
        </trans-unit>
        <trans-unit id="c85a93ef2b6eb1be3e8769838c333c812af4359a" translate="yes" xml:space="preserve">
          <source>Identify a remote machine name. The auto-login process searches the .netrc file for a machine token that matches the remote machine specified. Once a match is made, the subsequent .netrc tokens are processed, stopping when the end of file is reached or an- other machine or a default token is encountered.</source>
          <target state="translated">确定一个远程机器名称。自动登录过程会在.netrc文件中搜索与指定的远程机器相匹配的机器令牌,一旦匹配,就会处理后续的.netrc令牌,在文件结束或遇到其他机器或默认令牌时停止。一旦匹配,后续的.netrc标记就会被处理,当文件结束或遇到其他机器或默认标记时就会停止。</target>
        </trans-unit>
        <trans-unit id="ad36a5ddf7af0b9b2aadce75c61491b0c464af3b" translate="yes" xml:space="preserve">
          <source>Identify a user on the remote machine. If this token is present, the auto-login process will initiate a login using the specified name.</source>
          <target state="translated">识别远程机器上的用户。如果有此标记,自动登录过程将使用指定的名称发起登录。</target>
        </trans-unit>
        <trans-unit id="93ca58cc90c1952df3129b0ab2a244d796f9ba81" translate="yes" xml:space="preserve">
          <source>Identify and return the FQDN of the current host.</source>
          <target state="translated">识别并返回当前主机的FQDN。</target>
        </trans-unit>
        <trans-unit id="1b3b4987c2d4674f5207d125a1368bf151a6aeb4" translate="yes" xml:space="preserve">
          <source>Identify the C functions which use some inband info as an indication of failure. They may be candidates to return undef or an empty list in case of failure. If the failure may be detected without a call to the C function, you may want to use an INIT: section to report the failure. For failures detectable after the C function returns one may want to use a POSTCALL: section to process the failure. In more complicated cases use CODE: or PPCODE: sections.</source>
          <target state="translated">识别那些使用一些带内信息作为失败指示的C函数。它们可能是在失败时返回undef或空列表的候选函数。如果在没有调用C函数的情况下就能检测到失败,你可能需要使用INIT:部分来报告失败。对于在C函数返回后可以检测到的失败,可能要使用POSTCALL:部分来处理失败。在更复杂的情况下,使用CODE:或PPCODE:部分。</target>
        </trans-unit>
        <trans-unit id="b1d8de6657b1cd9ff03db4bb8c676352163c1ab9" translate="yes" xml:space="preserve">
          <source>Identify the C functions with input/output or output parameters. The XSUBs for these functions may be able to return lists to Perl.</source>
          <target state="translated">识别具有输入/输出或输出参数的C函数。这些函数的XSUB可以向Perl返回列表。</target>
        </trans-unit>
        <trans-unit id="90f84ba2bf147a844b20d38f482ee57bb2e58f7e" translate="yes" xml:space="preserve">
          <source>Identify the pointers in the C function parameter lists and return values. Some pointers may be used to implement input/output or output parameters, they can be handled in XS with the &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator, and, possibly, using the NO_INIT keyword. Some others will require handling of types like &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; , and one needs to decide what a useful Perl translation will do in such a case. When the semantic is clear, it is advisable to put the translation into a typemap file.</source>
          <target state="translated">在C函数参数列表中标识指针并返回值。某些指针可用于实现输入/输出或输出参数，它们可以在XS中使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 一元运算符进行处理，并且可能使用NO_INIT关键字进行处理。其他一些则需要处理 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; 之类的类型，并且需要确定在这种情况下有用的Perl转换将执行的操作。当语义清晰时，建议将翻译放入类型映射文件中。</target>
        </trans-unit>
        <trans-unit id="b3f574cc58fec6b5a326569871a9bc4c7e511150" translate="yes" xml:space="preserve">
          <source>Identify the structures used by the C functions. In many cases it may be helpful to use the T_PTROBJ typemap for these structures so they can be manipulated by Perl as blessed objects. (This is handled automatically by &lt;code&gt;h2xs -x&lt;/code&gt; .)</source>
          <target state="translated">确定C函数使用的结构。在许多情况下，将T_PTROBJ类型映射用于这些结构可能会有所帮助，以便Perl可以将它们作为受祝福的对象进行操作。（这由 &lt;code&gt;h2xs -x&lt;/code&gt; 自动处理。）</target>
        </trans-unit>
        <trans-unit id="7cadfb291553bfe2fe292f1f1bdcc23146b4ce0c" translate="yes" xml:space="preserve">
          <source>Identify which values are used by only the C and XSUB functions themselves, say, when a parameter to a function should be a contents of a global variable. If Perl does not need to access the contents of the value then it may not be necessary to provide a translation for that value from C to Perl.</source>
          <target state="translated">确定哪些值只被C和XSUB函数本身使用,比如说,当一个函数的参数应该是一个全局变量的内容时。如果Perl不需要访问该值的内容,那么可能不需要为该值提供从C到Perl的翻译。</target>
        </trans-unit>
        <trans-unit id="56f43be29163ab63b1344b6e022e099866950791" translate="yes" xml:space="preserve">
          <source>Identifying DLLs</source>
          <target state="translated">识别DLL</target>
        </trans-unit>
        <trans-unit id="322518cb4fde79b98b609332667667f3d3c4e560" translate="yes" xml:space="preserve">
          <source>Idhash-based inside-out implementation with explicit object registry. No destructor is needed and objects are thread safe.</source>
          <target state="translated">基于Idhash的内向外实现,具有显式对象注册表。不需要destructor,对象是线程安全的。</target>
        </trans-unit>
        <trans-unit id="bc58745f8a36f6c13d8394fd39a743ccc1e12aee" translate="yes" xml:space="preserve">
          <source>Idhash-based inside-out implementation. Like &lt;code&gt;Name_id&lt;/code&gt; it needs a &lt;code&gt;DESTROY&lt;/code&gt; method and would need &lt;code&gt;CLONE&lt;/code&gt; for thread support.</source>
          <target state="translated">基于Idhash的由内而外的实现。像 &lt;code&gt;Name_id&lt;/code&gt; 一样，它需要 &lt;code&gt;DESTROY&lt;/code&gt; 方法，并且需要 &lt;code&gt;CLONE&lt;/code&gt; 来支持线程。</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="37c8800e90368fca825ac19f3c1c00b3997debbb" translate="yes" xml:space="preserve">
          <source>If $ENV{'PERLIO_DEBUG'} is not set PerlIO_debug() is a no-op.</source>
          <target state="translated">如果 $ENV{'PERLIO_DEBUG'}没有被设置为 PerlIO_debug()则为无操作。</target>
        </trans-unit>
        <trans-unit id="34dc71088c30578327b9b7bd86a2add6dfe92c0b" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set (see below), it takes precedence over $Term::ANSIColor::AUTORESET, and the latter is ignored.</source>
          <target state="translated">如果$Term::ANSIColor::AUTOLOCAL被设置(见下文),它优先于$Term::ANSIColor::AUTORESET,并且后者被忽略。</target>
        </trans-unit>
        <trans-unit id="d7df1e43ea1f957f59393ae695f2cf9b6d2d606b" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set, each sequence of color constants will be implicitly preceded by LOCALCOLOR. In other words, the following:</source>
          <target state="translated">如果设置了$Term::ANSIColor::AUTOLOCAL,则每个颜色常量序列都会隐含在LOCALCOLOR前面。换句话说,如下。</target>
        </trans-unit>
        <trans-unit id="9886d30e7ae4310a71b5b389e615e24f477c9c12" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set, it takes precedence over $Term::ANSIColor::AUTORESET, and the latter is ignored.</source>
          <target state="translated">如果$Term::ANSIColor::AUTOLOCAL被设置,它优先于$Term::ANSIColor::AUTORESET,而后者被忽略。</target>
        </trans-unit>
        <trans-unit id="00b4b93a6e7c56aaf9898bc10e1ac72d3a78d804" translate="yes" xml:space="preserve">
          <source>If $base doesn't have a trailing colon, the last element of $base is assumed to be a filename. This filename is ignored. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">如果$base没有尾部的冒号,那么$base的最后一个元素被认为是一个文件名。这个文件名会被忽略。否则,所有的路径元素都被假定为目录。</target>
        </trans-unit>
        <trans-unit id="e44a850613a15c52040db7b75a563e3363f3a945" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then $base is set to the current working directory. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">如果$ base不存在或''，则$ base设置为当前工作目录。如果$ base是相对的，则使用 &lt;code&gt;rel2abs()&lt;/code&gt; 将其转换为绝对形式。这意味着它被认为是相对于当前工作目录的。</target>
        </trans-unit>
        <trans-unit id="845e455de01e5f024d6cd4c4973aa19e89db7d23" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt; is used. If $base is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="translated">如果不存在$ base或''，则使用&lt;a href=&quot;../../cwd&quot;&gt;cwd（）&lt;/a&gt;。如果$ base是相对的，则使用&lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs（）&lt;/a&gt;将其转换为绝对形式。这意味着它被认为是相对于&lt;a href=&quot;../../cwd&quot;&gt;cwd（）的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9272bd7bdd63c187d96603ba9d632df6f83a5a3" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then the current working directory is used. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">如果不存在$ base或''，则使用当前工作目录。如果$ base是相对的，则使用 &lt;code&gt;rel2abs()&lt;/code&gt; 将其转换为绝对形式。这意味着它被认为是相对于当前工作目录的。</target>
        </trans-unit>
        <trans-unit id="3eeec7a0508f8bfb175a7dfc1c9f776420700e6b" translate="yes" xml:space="preserve">
          <source>If $chld_out is a string (that is, a bareword filehandle rather than a glob or a reference) and it begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that file handle. If $chld_in is a string that begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; , then $chld_in will be closed in the parent, and the child will read from it directly. In both cases, there will be a dup(2) instead of a pipe(2) made.</source>
          <target state="translated">如果$ chld_out是字符串（即，裸字文件句柄而不是glob或引用），并且它以 &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; 开头，则子级将直接将输出发送到该文件句柄。如果$ chld_in是以 &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; 开头的字符串，则$ chld_in将在父级中关闭，而子级将直接从中读取。在这两种情况下，都将使用dup（2）而不是使用pipe（2）。</target>
        </trans-unit>
        <trans-unit id="44fc8fa9695e13537785e072991da9317e572016" translate="yes" xml:space="preserve">
          <source>If $device is given, this device is used to bind the source endpoint before sending the ping packet. I believe this only works with superuser privileges and with udp and icmp protocols at this time.</source>
          <target state="translated">如果给定了$device,则在发送ping包之前,用这个设备来绑定源端点。我相信目前只有超级用户权限和udp和icmp协议才能使用这个功能。</target>
        </trans-unit>
        <trans-unit id="c0ccd65f83616cd6cb2edfc67d2ca291d582e3dc" translate="yes" xml:space="preserve">
          <source>If $dont_execute is true it will only print what it was going to do without actually doing it. Default is false.</source>
          <target state="translated">如果$dont_execute为true,它将只打印它要做的事情,而不实际执行。默认为false。</target>
        </trans-unit>
        <trans-unit id="4487f23cdc43d77eefda03ffdb355fcd16d21554" translate="yes" xml:space="preserve">
          <source>If $dry_run is true it will only print what it was going to do without actually doing it. Default is false.</source>
          <target state="translated">如果$dry_run为true,它将只打印它要做的事情,而不实际做。默认为false。</target>
        </trans-unit>
        <trans-unit id="18c02a1762fa9a8596890767dac4fd996ccee7b8" translate="yes" xml:space="preserve">
          <source>If $file is not given, output goes to STDOUT.</source>
          <target state="translated">如果没有给定$file,输出将进入STDOUT。</target>
        </trans-unit>
        <trans-unit id="d0d307167134c6f267f7b1e5ea27d0a25a9d1edd" translate="yes" xml:space="preserve">
          <source>If $lang1 is not a valid language tag, returns empty-list in a list context, undef in a scalar context.</source>
          <target state="translated">如果$lang1不是有效的语言标签,在列表上下文中返回空列表,在标量上下文中返回undef。</target>
        </trans-unit>
        <trans-unit id="5ee23960e33f02c0ec76877b3b88bcea62b52eb5" translate="yes" xml:space="preserve">
          <source>If $options{allow_variables} is true it will leave &lt;code&gt;'$(FOO)'&lt;/code&gt; make variables untouched. If false they will be escaped like any other &lt;code&gt;$&lt;/code&gt; . Defaults to true.</source>
          <target state="translated">如果$ options {allow_variables}为true，它将使 &lt;code&gt;'$(FOO)'&lt;/code&gt; 使变量保持不变。如果为假，它们将像其他 &lt;code&gt;$&lt;/code&gt; 一样被转义。默认为true。</target>
        </trans-unit>
        <trans-unit id="7e4290bb3a94a4f28c693632b42d671f5b272d5b" translate="yes" xml:space="preserve">
          <source>If $opts{allow_variables} is true, make variables of the form &lt;code&gt;$(...)&lt;/code&gt; will not be escaped. Other &lt;code&gt;$&lt;/code&gt; will. Default is to escape all &lt;code&gt;$&lt;/code&gt; .</source>
          <target state="translated">如果$ opts {allow_variables}为true，将不会转义 &lt;code&gt;$(...)&lt;/code&gt; 形式的make变量。其他 &lt;code&gt;$&lt;/code&gt; 将。默认值是转义所有 &lt;code&gt;$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="855199c44e171a04babf60aa36fe8d5f139967b6" translate="yes" xml:space="preserve">
          <source>If $opts{append} is true the $file will be appended to rather than overwritten. Default is to overwrite.</source>
          <target state="translated">如果$opts{append}为真,则$file将被追加而不是覆盖。默认是覆盖。</target>
        </trans-unit>
        <trans-unit id="6f940e23e748b82cd99453c8e14fb88e03638ce9" translate="yes" xml:space="preserve">
          <source>If $path and $base appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return $path. Note that previous versions of this module ignored the volume of $base, which resulted in garbage results part of the time.</source>
          <target state="translated">如果$path和$base出现在两个不同的卷上,我们将不尝试解析这两个路径,而只是返回$path。需要注意的是,这个模块以前的版本忽略了$base的卷,这导致了部分时间的垃圾结果。</target>
        </trans-unit>
        <trans-unit id="850236350e7bb82f14f3904d51572fc6195796da" translate="yes" xml:space="preserve">
          <source>If $path is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath()&quot;&gt;canonpath()&lt;/a&gt;.</source>
          <target state="translated">如果$ path是绝对的，则将其清理并使用&lt;a href=&quot;#canonpath()&quot;&gt;canonpath（）&lt;/a&gt;返回。</target>
        </trans-unit>
        <trans-unit id="8dd162a4e3a5b7fb03319f43889033f3ce26c0ac" translate="yes" xml:space="preserve">
          <source>If $path is already absolute, it is returned and $base is ignored.</source>
          <target state="translated">如果$path已经是绝对值,则返回,忽略$base。</target>
        </trans-unit>
        <trans-unit id="777c7fd35866ed59635fd89f40d3d520a0dbf9c9" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="translated">如果$ path是相对的，则使用&lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs（）&lt;/a&gt;将其转换为绝对形式。这意味着它被认为是相对于&lt;a href=&quot;../../cwd&quot;&gt;cwd（）的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ca3a7041ed2c9c63e8a6e3a8ccf54b7c562514d" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">如果$ path是相对的，则使用 &lt;code&gt;rel2abs()&lt;/code&gt; 将其转换为绝对形式。这意味着它被认为是相对于当前工作目录的。</target>
        </trans-unit>
        <trans-unit id="5254527bc2e7fffb01bf04870bf9b3803ac84a3a" translate="yes" xml:space="preserve">
          <source>If $skip is undefined then the skip file will be autodetected and used if it is found. If $skip is a reference to an array then it is assumed the array contains the list of patterns, if $skip is a true non reference it is assumed to be the filename holding the list of patterns, any other value of $skip is taken to mean that no install filtering should occur.</source>
          <target state="translated">如果$skip是未定义的,那么跳过文件将被自动检测,并在找到时使用。如果$skip是一个数组的引用,那么它被认为是数组包含了模式列表,如果$skip是一个真正的非引用,那么它被认为是持有模式列表的文件名,任何其他的$skip值都被认为意味着不应该发生安装过滤。</target>
        </trans-unit>
        <trans-unit id="8fa5810ef2976d0d9f6da3cb5784a5117836d30e" translate="yes" xml:space="preserve">
          <source>If $tos is given, this ToS is configured into the socket.</source>
          <target state="translated">如果给定了$tos,这个ToS就会配置到socket中。</target>
        </trans-unit>
        <trans-unit id="92f994b9259d086e448ddc0c57c689110cb3a4ae" translate="yes" xml:space="preserve">
          <source>If $uninstall_shadows is true any differing versions throughout @INC will be uninstalled. This is &quot;make install UNINST=1&quot;</source>
          <target state="translated">如果$uninstall_shadows为真,那么整个@INC中任何不同的版本都会被卸载。这就是 &quot;make install UNINST=1&quot;</target>
        </trans-unit>
        <trans-unit id="d25dc89b5c8f1043b2555a0a5b1ef64713bc4410" translate="yes" xml:space="preserve">
          <source>If $verbose is true, will print out each file removed. Default is false.</source>
          <target state="translated">如果$verbose为true,将打印出每个被删除的文件。默认为false。</target>
        </trans-unit>
        <trans-unit id="bcca2238b940008ca2f6edea6b116ca4f08340a0" translate="yes" xml:space="preserve">
          <source>If $verbose is true, will print out each file removed. Default is false. This is &quot;make install VERBINST=1&quot;. $verbose values going up to 5 show increasingly more diagnostics output.</source>
          <target state="translated">如果$verbose为true,将打印出每个被删除的文件。默认为false。这就是 &quot;make install VERBINST=1&quot;。$verbose的值上升到5,会显示越来越多的诊断输出。</target>
        </trans-unit>
        <trans-unit id="fe6210a09cf838e292147ff60a09be55f53fc7bf" translate="yes" xml:space="preserve">
          <source>If 'pattern' is an empty string, the last</source>
          <target state="translated">如果'pattern'是一个空字符串,则最后的</target>
        </trans-unit>
        <trans-unit id="1ce161c1d1a95615015e87f6deb5c4e15fba876e" translate="yes" xml:space="preserve">
          <source>If 0, allows</source>
          <target state="translated">如果为0,允许</target>
        </trans-unit>
        <trans-unit id="e3e28f04766a1a5f37a30a978712cb8019a0f8ec" translate="yes" xml:space="preserve">
          <source>If 0, perl ignores setlocale() failing. May be useful with some strange</source>
          <target state="translated">如果为0,perl忽略setlocale()失败。可能对一些奇怪的</target>
        </trans-unit>
        <trans-unit id="0fcc1cd2f54ca974c2f03b70436631faa5fcbfff" translate="yes" xml:space="preserve">
          <source>If 0, perl would not warn of in case of unwarranted free(). With older perls this might be useful in conjunction with the module DB_File, which was buggy when dynamically linked and OMF-built.</source>
          <target state="translated">如果为0,那么perl就不会在出现不正当的free()时发出警告。对于旧版的perl来说,这个功能可能会和DB_File模块一起使用,因为DB_File模块在动态链接和OMF构建的时候是有bug的。</target>
        </trans-unit>
        <trans-unit id="0184b287a86a499460e472243734776163d62a28" translate="yes" xml:space="preserve">
          <source>If 0, then you have specified the G_DISCARD flag.</source>
          <target state="translated">如果为0,则说明你已经指定了G_DISCARD标志。</target>
        </trans-unit>
        <trans-unit id="59622b7a1ad0df9c79750964aae25dbf7a4a54d5" translate="yes" xml:space="preserve">
          <source>If 1, then the item actually returned by the Perl subroutine will be stored on the Perl stack - the section</source>
          <target state="translated">如果为1,那么Perl子程序实际返回的项目将被存储在Perl堆栈中----------------------------------段</target>
        </trans-unit>
        <trans-unit id="dea4460b4f37611ed7726bdc86a6a203f8857086" translate="yes" xml:space="preserve">
          <source>If 1. and 2. didn't work, the environment variables &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LANG&lt;/code&gt; (in that order) are matched for anything looking like UTF-8, and if any found, &lt;code&gt;:utf8&lt;/code&gt; is used as the default encoding for the open pragma.</source>
          <target state="translated">如果1.和2.不起作用，则将环境变量 &lt;code&gt;LC_ALL&lt;/code&gt; 和 &lt;code&gt;LANG&lt;/code&gt; （按此顺序）匹配看起来像UTF-8的任何内容，如果找到，则将 &lt;code&gt;:utf8&lt;/code&gt; 用作打开的编译指示的默认编码。</target>
        </trans-unit>
        <trans-unit id="564ba04f0c77bd18f1de6b5d8d1c4de41e90203f" translate="yes" xml:space="preserve">
          <source>If 1. didn't work but we are under the locale pragma, the environment variables &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LANG&lt;/code&gt; (in that order) are matched for encodings (the part after &quot;&lt;code&gt;.&lt;/code&gt;&quot;, if any), and if any found, that is used as the default encoding for the open pragma.</source>
          <target state="translated">如果1.无效，但我们在语言环境下进行编译，则将环境变量 &lt;code&gt;LC_ALL&lt;/code&gt; 和 &lt;code&gt;LANG&lt;/code&gt; （按此顺序）与编码（&amp;ldquo; &lt;code&gt;.&lt;/code&gt; &amp;rdquo; 后的部分，如果有的话）匹配，如果找到，则使用作为打开的编译指示的默认编码。</target>
        </trans-unit>
        <trans-unit id="5cc7e264f1e9eeedc8d7e2b14c1a68dd77cae7b4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt; is pointing to the very end of the current chunk (i.e., the current chunk has been entirely consumed), normally the current chunk will be discarded at the same time that the new chunk is read in. If</source>
          <target state="translated">如果&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt;指向当前块的末尾（即，当前块已被完全消耗），通常在读取新块的同时，将丢弃当前块。</target>
        </trans-unit>
        <trans-unit id="baa00f7897b1c66fe0a596f5bb93527533128be4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; cannot be found (or &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; if running under Windows) tests will be run without color.</source>
          <target state="translated">如果&lt;a href=&quot;../../term/ansicolor&quot;&gt;找不到Term :: ANSIColor&lt;/a&gt;（如果在Windows下运行则为&lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32 :: Console&lt;/a&gt;），则测试将无颜色运行。</target>
        </trans-unit>
        <trans-unit id="42a72e58cfc32531fbd4fab5178d34e628485bf7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN::Meta&lt;/a&gt; is installed, MakeMaker will automatically generate</source>
          <target state="translated">如果安装了&lt;a href=&quot;../cpan/meta&quot;&gt;CPAN :: Meta&lt;/a&gt;，MakeMaker将自动生成</target>
        </trans-unit>
        <trans-unit id="108eca6848696cd0de287a231d549cff82edd6aa" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;-t&lt;/b&gt; is given, &lt;b&gt;pod2text&lt;/b&gt; will take the current width of your screen from this environment variable, if available. It overrides terminal width information in TERMCAP.</source>
          <target state="translated">如果给出&lt;b&gt;-t&lt;/b&gt;，则&lt;b&gt;pod2text&lt;/b&gt;将使用此环境变量（如果可用）获取屏幕的当前宽度。它会覆盖TERMCAP中的端子宽度信息。</target>
        </trans-unit>
        <trans-unit id="fc2c6665b79caef5aa91e98d089e901b7263b1c2" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;-t&lt;/b&gt; is given, &lt;b&gt;pod2text&lt;/b&gt; will use the contents of this environment variable if available to determine the correct formatting sequences for your current terminal device.</source>
          <target state="translated">如果指定了&lt;b&gt;-t&lt;/b&gt;，则&lt;b&gt;pod2text&lt;/b&gt;将使用此环境变量的内容（如果有）来确定当前终端设备的正确格式顺序。</target>
        </trans-unit>
        <trans-unit id="9c867f84603d2f4182710d040ee18f9885c092cc" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;Locale::Maketext::Lexicon&lt;/b&gt; is not present, it implements a minimal localization function by simply interpolating &lt;code&gt;[_1]&lt;/code&gt; with the first argument, &lt;code&gt;[_2]&lt;/code&gt; with the second, etc. Interpolated function like &lt;code&gt;[quant,_1]&lt;/code&gt; are treated as &lt;code&gt;[_1]&lt;/code&gt; , with the sole exception of &lt;code&gt;[tense,_1,X]&lt;/code&gt; , which will append &lt;code&gt;ing&lt;/code&gt; to &lt;code&gt;_1&lt;/code&gt; when X is &lt;code&gt;present&lt;/code&gt; , or appending &lt;code&gt;ed&lt;/code&gt; to &amp;lt;_1&amp;gt; otherwise.</source>
          <target state="translated">如果不存在&lt;b&gt;Locale :: Maketext :: Lexicon&lt;/b&gt;，则它会通过将第一个参数的 &lt;code&gt;[_1]&lt;/code&gt; 插值，第二个参数的 &lt;code&gt;[_2]&lt;/code&gt; 插值来实现最小化的本地化功能。插值函数（如 &lt;code&gt;[quant,_1]&lt;/code&gt; )被视为 &lt;code&gt;[_1]&lt;/code&gt; ,具有唯一的例外 &lt;code&gt;[tense,_1,X]&lt;/code&gt; ，这将附加 &lt;code&gt;ing&lt;/code&gt; 到 &lt;code&gt;_1&lt;/code&gt; 当X是 &lt;code&gt;present&lt;/code&gt; ，或追加 &lt;code&gt;ed&lt;/code&gt; 到&amp;lt;_1&amp;gt;否则。</target>
        </trans-unit>
        <trans-unit id="3079127a0d6aa2996f8f83dac436403e0868d7e3" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;all&lt;/b&gt; of these are the case, then you need to set the &lt;code&gt;$eof&lt;/code&gt; parameter to true on the final call (and only the final call) to &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; .</source>
          <target state="translated">如果&lt;b&gt;所有&lt;/b&gt;这些都成立，那么您需要在 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 的最终调用（仅最终调用）上将 &lt;code&gt;$eof&lt;/code&gt; 参数设置为true 。</target>
        </trans-unit>
        <trans-unit id="1304e40e4e83fe3d3333f01173ec1c6d1e1c6f99" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2man&lt;/b&gt; fails with errors, see &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; and &lt;a href=&quot;pod/simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean.</source>
          <target state="translated">如果&lt;b&gt;pod2man&lt;/b&gt;因错误而失败，请参阅&lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt;和&lt;a href=&quot;pod/simple&quot;&gt;Pod :: Simple&lt;/a&gt;以获得有关这些错误可能意味着什么的信息。</target>
        </trans-unit>
        <trans-unit id="f4176eb0fb0948998c97b4edf835cbf5dcd8f3b5" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2text&lt;/b&gt; fails with errors, see &lt;a href=&quot;pod/text&quot;&gt;Pod::Text&lt;/a&gt; and &lt;a href=&quot;pod/simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean. Internally, it can also produce the following diagnostics:</source>
          <target state="translated">如果&lt;b&gt;pod2text&lt;/b&gt;因错误而失败，请参阅&lt;a href=&quot;pod/text&quot;&gt;Pod :: Text&lt;/a&gt;和&lt;a href=&quot;pod/simple&quot;&gt;Pod :: Simple&lt;/a&gt;以获得有关这些错误可能意味着的信息。在内部，它还可以产生以下诊断信息：</target>
        </trans-unit>
        <trans-unit id="988f5c207e367599a6818bf91e93811516af5517" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;/&quot;&lt;/code&gt; is the delimiter then the initial &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; is optional. With the &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; you can use any pair of non-whitespace (ASCII) characters as delimiters. This is particularly useful for matching path names that contain &lt;code&gt;&quot;/&quot;&lt;/code&gt; , to avoid LTS (leaning toothpick syndrome). If &lt;code&gt;&quot;?&quot;&lt;/code&gt; is the delimiter, then a match-only-once rule applies, described in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; below. If &lt;code&gt;&quot;'&quot;&lt;/code&gt; (single quote) is the delimiter, no interpolation is performed on the</source>
          <target state="translated">如果 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 是分隔符，则首字母 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 是可选的。使用 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 时,您可以将任意一对非空白（ASCII）字符用作分隔符。这对于匹配包含 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 路径名特别有用，以避免LTS（倾斜牙签综合症）。如果是 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 是定界符，则应用仅匹配一次规则，以 &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; 下面。如果 &lt;code&gt;&quot;'&quot;&lt;/code&gt; （单引号）是定界符，则不会对</target>
        </trans-unit>
        <trans-unit id="4134f85a82aca95ee568f43289ebb0ed4545d2aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$@&lt;/code&gt; is empty then the string &lt;code&gt;&quot;Died&quot;&lt;/code&gt; is used.</source>
          <target state="translated">如果 &lt;code&gt;$@&lt;/code&gt; 为空，则使用字符串 &lt;code&gt;&quot;Died&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1898954d30bb03694346f5c287c1a5d39827435" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$@&lt;/code&gt; is empty then the string &lt;code&gt;&quot;Warning: Something's wrong&quot;&lt;/code&gt; is used.</source>
          <target state="translated">如果 &lt;code&gt;$@&lt;/code&gt; 为空，则使用字符串 &lt;code&gt;&quot;Warning: Something's wrong&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8349dcfb4261ce55d683cb8a5fd2171cf0fa3a9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$Storable::Deparse&lt;/code&gt; and/or &lt;code&gt;$Storable::Eval&lt;/code&gt; are set to false values, then the value of &lt;code&gt;$Storable::forgive_me&lt;/code&gt; (see below) is respected while serializing and deserializing.</source>
          <target state="translated">如果 &lt;code&gt;$Storable::Deparse&lt;/code&gt; 和/或 &lt;code&gt;$Storable::Eval&lt;/code&gt; 设置为false值，则在序列化和反序列化时，将尊重 &lt;code&gt;$Storable::forgive_me&lt;/code&gt; 的值（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="e98020b671aa605e805711cb6bc682413e70f748" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct) then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; i.e., it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">如果 &lt;code&gt;$_&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 出现的范围内是词法（因为已经用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; 构造声明了它），则除了在列表元素上局部别名之外， &lt;code&gt;$_&lt;/code&gt; 还会在块内词法化；也就是说，从外面看不到它，避免了任何潜在的副作用。</target>
        </trans-unit>
        <trans-unit id="4f7113393512805f0f59fa7b96e8b849e1995d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct), then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; that is, it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">如果 &lt;code&gt;$_&lt;/code&gt; 是在该范围内的词汇 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 出现（因为它已被声明为不赞成 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; 结构），那么，除了在本地别名列表元素， &lt;code&gt;$_&lt;/code&gt; 一直是块内词汇; 也就是说，从外面看不到它，避免了任何潜在的副作用。</target>
        </trans-unit>
        <trans-unit id="cb93a45a461425fe55c63aa4556c32605c5c3edf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct) then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; i.e., it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">如果 &lt;code&gt;$_&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 出现的范围内是词法（因为已经用 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; 构造声明了它），则除了在列表元素上局部别名之外， &lt;code&gt;$_&lt;/code&gt; 还会在块内词法化；也就是说，从外面看不到它，避免了任何潜在的副作用。</target>
        </trans-unit>
        <trans-unit id="25899b6abc79ff8d8c10640cbdc4955bb3e63743" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct), then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; that is, it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">如果 &lt;code&gt;$_&lt;/code&gt; 是在该范围内的词汇 &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 出现（因为它已被声明为不赞成 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; 结构），那么，除了在本地别名列表元素， &lt;code&gt;$_&lt;/code&gt; 一直是块内词汇; 也就是说，从外面看不到它，避免了任何潜在的副作用。</target>
        </trans-unit>
        <trans-unit id="2bf18bea13d8e6a37cbbcfdc3ed1634945661fd3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are scalars then after these statements</source>
          <target state="translated">如果 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 是标量，则在这些语句之后</target>
        </trans-unit>
        <trans-unit id="92cf042152ebf0550f54e6d7d3ad9a3448e3c104" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$a&lt;/code&gt; pointed to an array of two elements then we would see the following.</source>
          <target state="translated">如果 &lt;code&gt;$a&lt;/code&gt; 指向两个元素的数组，那么我们将看到以下内容。</target>
        </trans-unit>
        <trans-unit id="fee2f2e0ebac86e4349ab49b826ea37defd988af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$aref&lt;/code&gt; holds a reference to an array, then &lt;code&gt;$aref-&amp;gt;[3]&lt;/code&gt; is the fourth element of the array. Don't confuse this with &lt;code&gt;$aref[3]&lt;/code&gt; , which is the fourth element of a totally different array, one deceptively named &lt;code&gt;@aref&lt;/code&gt; . &lt;code&gt;$aref&lt;/code&gt; and &lt;code&gt;@aref&lt;/code&gt; are unrelated the same way that &lt;code&gt;$item&lt;/code&gt; and &lt;code&gt;@item&lt;/code&gt; are.</source>
          <target state="translated">如果 &lt;code&gt;$aref&lt;/code&gt; 持有对数组的引用，则 &lt;code&gt;$aref-&amp;gt;[3]&lt;/code&gt; 是数组的第四个元素。不要将它与 &lt;code&gt;$aref[3]&lt;/code&gt; 混淆，后者是完全不同的数组的第四个元素，一个名为 &lt;code&gt;@aref&lt;/code&gt; 的数组。 &lt;code&gt;$aref&lt;/code&gt; 和 &lt;code&gt;@aref&lt;/code&gt; 是不相关的，就像 &lt;code&gt;$item&lt;/code&gt; 和 &lt;code&gt;@item&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="de74274409753dd786fd5d63e5d1412ca957382c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$base&lt;/code&gt; is not defined, Euler's number (e) is used:</source>
          <target state="translated">如果未定义 &lt;code&gt;$base&lt;/code&gt; ，则使用欧拉数（e）：</target>
        </trans-unit>
        <trans-unit id="0050f172fa605210fb670bacd9e4150d6ef91f04" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$base&lt;/code&gt; is not present or '', then &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt; is used. If &lt;code&gt;$base&lt;/code&gt; is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="translated">如果不存在 &lt;code&gt;$base&lt;/code&gt; 或''，则使用&lt;a href=&quot;../cwd&quot;&gt;Cwd :: cwd（）&lt;/a&gt;。如果 &lt;code&gt;$base&lt;/code&gt; 是相对的，则使用&lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs（）&lt;/a&gt;将其转换为绝对形式。这意味着它被认为是相对于&lt;a href=&quot;../cwd&quot;&gt;Cwd :: cwd（）的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7addd5930cc7a5f994dbe5d5d02d12cbcde98a29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$buffer&lt;/code&gt; consists of multiple concatenated gzip data streams only the first will be uncompressed. Use &lt;code&gt;gunzip&lt;/code&gt; with the &lt;code&gt;MultiStream&lt;/code&gt; option in the &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; module if you need to deal with concatenated data streams.</source>
          <target state="translated">如果 &lt;code&gt;$buffer&lt;/code&gt; 由多个串联的gzip数据流组成，则只有第一个将被解压缩。如果您需要处理串联的数据流，请在 &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; 模块中将 &lt;code&gt;gunzip&lt;/code&gt; 与 &lt;code&gt;MultiStream&lt;/code&gt; 选项一起使用。</target>
        </trans-unit>
        <trans-unit id="9c05ab0710c330ccfa58b05a1d99cb1930161cb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$fh&lt;/code&gt; is a filehandle, such as is returned by &lt;code&gt;IO::File&lt;/code&gt; or one of the other &lt;code&gt;IO&lt;/code&gt; modules, you may use:</source>
          <target state="translated">如果 &lt;code&gt;$fh&lt;/code&gt; 是文件句柄（例如 &lt;code&gt;IO::File&lt;/code&gt; 或其他 &lt;code&gt;IO&lt;/code&gt; 模块之一返回的），则可以使用：</target>
        </trans-unit>
        <trans-unit id="80cddfe7cac5da52e604c2e95ecabe44db020236" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$id&lt;/code&gt; is the id of a registered object (see &lt;a href=&quot;#register&quot;&gt;register&lt;/a&gt;), returns the object, otherwise an undefined value. For registered objects this is the inverse function of &lt;code&gt;id()&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;$id&lt;/code&gt; 是已注册对象的ID（请参见&lt;a href=&quot;#register&quot;&gt;register&lt;/a&gt;），则返回该对象，否则返回未定义的值。对于已注册的对象，这是 &lt;code&gt;id()&lt;/code&gt; 的反函数。</target>
        </trans-unit>
        <trans-unit id="cc434bb4b25d64e8d72b26a1167930b8ab9c02ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input&lt;/code&gt; is a scalar reference, the compressed data will be read from &lt;code&gt;$$input&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;$input&lt;/code&gt; 是标量引用，则将从 &lt;code&gt;$$input&lt;/code&gt; 读取压缩数据。</target>
        </trans-unit>
        <trans-unit id="1deee19e273a335c0c4f6a1643abcff33ad56b8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a scalar reference, the input data will be read from &lt;code&gt;$$input_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是标量引用，则将从 &lt;code&gt;$$input_filename_or_reference&lt;/code&gt; 读取输入数据。</target>
        </trans-unit>
        <trans-unit id="442fe7b0ca25d4c885c4e854d9668346a5bb7269" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;anyinflate&lt;/code&gt; 都会假定它是一个</target>
        </trans-unit>
        <trans-unit id="9aa314fdcd8580313e8abf8e02f29427ab27b460" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyuncompress&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;anyuncompress&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="18a54dcb23d30a160237fad9927225b0b52fd938" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bunzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，那么 &lt;code&gt;bunzip2&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="2674b9a8665c681ee519359fca9a33d0c649f2e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;bzip2&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="8d40f68b3835780881ecdd758b0745e5d0346006" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;deflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;deflate&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="4fe4284a3754ea968d5efe965b410a0bdc45da42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gunzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是一个由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串， &lt;code&gt;gunzip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="54bfc13f24ab6d2f1fe87f0e4095f9cb61a84059" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;gzip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="9bc5cf10f5ea974c9dba92b8ddcdee6c56efe154" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;inflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是受字符分隔的字符串&amp;ldquo;&amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo; &lt;code&gt;inflate&lt;/code&gt; 将假设它是一个</target>
        </trans-unit>
        <trans-unit id="8e074643e90fcbea02cb6c241eab28946a00d829" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawdeflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，那么 &lt;code&gt;rawdeflate&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="c17eec5153adb41349f1323f8a2716fe9be3d4a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串， &lt;code&gt;rawinflate&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="4ab52d4fbbd216b398b3cd45ad27a194f5b5a84f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;unzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;unzip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="35a8f72eaee6c21d9a2ad219023a7a4de0558584" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;zip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;zip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="2e1657129b850f80b9a61087ceca9451d92c60dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is an array reference, each element in the array must be a filename.</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是数组引用，则数组中的每个元素必须是文件名。</target>
        </trans-unit>
        <trans-unit id="9bbc80ca8dd7a56323169258329eaced7ec9500d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$n&lt;/code&gt; is negative, returns the digit counting from left.</source>
          <target state="translated">如果 &lt;code&gt;$n&lt;/code&gt; 为负，则返回从左开始计数的数字。</target>
        </trans-unit>
        <trans-unit id="320bf336e74d67e7ea69246db25f2a4bdd482c4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$num_tests&lt;/code&gt; is omitted, the number of tests run will be used, like no_plan.</source>
          <target state="translated">如果省略 &lt;code&gt;$num_tests&lt;/code&gt; ，将使用运行的测试数量，如no_plan。</target>
        </trans-unit>
        <trans-unit id="2d1acd93b6a6ef1f8b92bfb6d087b55815058f80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a buffer and &lt;code&gt;Append&lt;/code&gt; is enabled, all compressed data will be append to the end of &lt;code&gt;$output&lt;/code&gt; . Otherwise &lt;code&gt;$output&lt;/code&gt; will be cleared before any data is written to it.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 是缓冲区并且启用了 &lt;code&gt;Append&lt;/code&gt; ，则所有压缩数据将追加到 &lt;code&gt;$output&lt;/code&gt; 的末尾。否则，将在写入任何数据之前清除 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8582554c9105fe0c715aaa06eeaea2d3fcfc688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a file or a filehandle, it must be seekable.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 是文件或文件句柄，则它必须是可搜索的。</target>
        </trans-unit>
        <trans-unit id="430d11ebbae99eabba1b751c1fb7c8e38808dc22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a filehandle, the file pointer will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 是文件句柄，则通过调用将文件指针定位到文件末尾，以在将任何压缩数据写入到文件末尾之前进行 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 。否则，文件指针将不会移动。</target>
        </trans-unit>
        <trans-unit id="6f34a91ef18a1100dcab801875430fa2964155e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a filename and &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any compressed data is written to it.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 是文件名并且启用了 &lt;code&gt;Append&lt;/code&gt; ，则该文件将以追加模式打开。否则，在将任何压缩数据写入文件之前，文件的内容（如果有）将被截断。</target>
        </trans-unit>
        <trans-unit id="905a4b022cfd04d4344f06eb8d1d7814fe3b2e8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 是标量引用，则压缩后的数据将存储在 &lt;code&gt;$$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="130d5c72326e4e51651ab55caf6ff565c16bd2ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是标量引用，则压缩数据将存储在 &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6e6e43463d8cf9f8c4cc955f62290b2d79a9ce9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the uncompressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是一个标量引用，则未压缩的数据将存储在 &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffed2a8f82140ef8dc0c4ed699c9112d9f907c47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;anyinflate&lt;/code&gt; 都将假定它是一个</target>
        </trans-unit>
        <trans-unit id="b9f151907f2e5c73c6d5a7f5e3827d63f2d086e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyuncompress&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;anyuncompress&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="eb784e91a1d15b001b3d17241bbd0f023fa0db31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bunzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，那么 &lt;code&gt;bunzip2&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="308eaa4a6536e52e6cbbe3d9c09c32dfa80725fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;bzip2&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="632c19749781b38310b67e8cb7d2da8bcbd87fa7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;deflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;deflate&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="4846f7304e22cdc9a232215f9939eddfa8d9211d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gunzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，那么 &lt;code&gt;gunzip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="4f11ec72b95266da1fd717b81d461cc92a72f199" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;gzip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="f099e710944546f4f6281f3a2de13a8288ffdd0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;inflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是受字符分隔的字符串&amp;ldquo;&amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo; &lt;code&gt;inflate&lt;/code&gt; 将假设它是一个</target>
        </trans-unit>
        <trans-unit id="cceae651ad537fbe024d4ffd9a457c78fec4fbd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawdeflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;rawdeflate&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="767601b4f86c38e1ce00ed67d4e6753dd438a660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串， &lt;code&gt;rawinflate&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="c227dd1ee1e8b9659ffdea7cebe0fc1ef9dd1a51" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;unzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;unzip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="2ae55891ab5b00668d1e680f825b4abc927f84c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;zip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;zip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="a78a9fcfd00ce247c78fb42d76b95940b9310c9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an array reference, the compressed data will be pushed onto the array.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是数组引用，则压缩后的数据将被压入数组。</target>
        </trans-unit>
        <trans-unit id="37e6606fa0b627f8a29d46dde4b8ebad46bd51a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an array reference, the uncompressed data will be pushed onto the array.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是数组引用，则未压缩的数据将被压入数组。</target>
        </trans-unit>
        <trans-unit id="369470062bc6b67bd375785b11035d408478ab66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath&quot;&gt;canonpath&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$path&lt;/code&gt; 是绝对的，则将其清理并使用&lt;a href=&quot;#canonpath&quot;&gt;canonpath&lt;/a&gt;返回。</target>
        </trans-unit>
        <trans-unit id="8992ca77fb991d344a3dd6a4f26aedbf1b0f1d7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$path&lt;/code&gt; 是相对的，则使用&lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs（）&lt;/a&gt;将其转换为绝对形式。这意味着它被认为是相对于&lt;a href=&quot;../cwd&quot;&gt;Cwd :: cwd（）的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="529756014729906a36945c0c1d2b4d6306a5c66b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$potential_libs&lt;/code&gt; is empty, the return value will be empty. Otherwise, the libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; (see Config.pm) will be appended to the list of &lt;code&gt;$potential_libs&lt;/code&gt; . The libraries will be searched for in the directories specified in &lt;code&gt;$potential_libs&lt;/code&gt; , &lt;code&gt;$Config{libpth}&lt;/code&gt; , and in &lt;code&gt;$Config{installarchlib}/CORE&lt;/code&gt; . For each library that is found, a space-separated list of fully qualified library pathnames is generated.</source>
          <target state="translated">如果 &lt;code&gt;$potential_libs&lt;/code&gt; 为空，则返回值为空。否则， &lt;code&gt;$Config{perllibs}&lt;/code&gt; 指定的库（请参见Config.pm）将附加到 &lt;code&gt;$potential_libs&lt;/code&gt; 列表中。将在 &lt;code&gt;$potential_libs&lt;/code&gt; ， &lt;code&gt;$Config{libpth}&lt;/code&gt; 和 &lt;code&gt;$Config{installarchlib}/CORE&lt;/code&gt; 指定的目录中搜索这些库。对于找到的每个库，将生成一个用空格分隔的标准库路径名列表。</target>
        </trans-unit>
        <trans-unit id="6e553e7605e3100f0e3fcb5a8fa623376f34f081" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$priority&lt;/code&gt; permits, logs &lt;code&gt;$message&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;($format, @args)&lt;/code&gt; with the addition that &lt;code&gt;%m&lt;/code&gt; in $message or &lt;code&gt;$format&lt;/code&gt; is replaced with &lt;code&gt;&quot;$!&quot;&lt;/code&gt; (the latest error message).</source>
          <target state="translated">如果 &lt;code&gt;$priority&lt;/code&gt; 允许，则记录 &lt;code&gt;$message&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;($format, @args)&lt;/code&gt; ，并用$$ 替换$ message或 &lt;code&gt;$format&lt;/code&gt; 中的 &lt;code&gt;%m&lt;/code&gt; &lt;code&gt;&quot;$!&quot;&lt;/code&gt; （最新的错误消息）。</target>
        </trans-unit>
        <trans-unit id="9f52d52d1ba29c4eacb016d029d5d02c84a30a69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a blessed reference the name of the package that it is blessed into is returned. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;$ref&lt;/code&gt; 是一个受祝福的引用，则将其受祝福的包的名称返回。否则，将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79e261aa8c38ef64f4ef56cc680e427a28531090" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a reference the basic Perl type of the variable referenced is returned as a plain string (such as &lt;code&gt;ARRAY&lt;/code&gt; or &lt;code&gt;HASH&lt;/code&gt; ). Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;$ref&lt;/code&gt; 是引用，则所引用变量的基本Perl类型将以纯字符串形式返回（例如 &lt;code&gt;ARRAY&lt;/code&gt; 或 &lt;code&gt;HASH&lt;/code&gt; ）。否则，将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fac5930e7537a0d644cf3490408ca500262cfef0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is reference the internal memory address of the referenced value is returned as a plain integer. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;$ref&lt;/code&gt; 被引用，则引用值的内部存储器地址将以纯整数形式返回。否则，将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f2f6d4bd4dbef02b5adcb98b33be7311853de12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$result&lt;/code&gt; is undefined the corresponding parser has reached the end of its input (and will automatically be removed from the multiplexer).</source>
          <target state="translated">如果未定义 &lt;code&gt;$result&lt;/code&gt; 则相应的解析器已到达其输入的末尾（并将自动从多路复用器中删除）。</target>
        </trans-unit>
        <trans-unit id="3a340f9f260eea8720ddb9232a9ecfe918063812" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns &lt;code&gt;-1&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 任何部分都不匹配，则在标量上下文中返回 &lt;code&gt;-1&lt;/code&gt; ，在列表上下文中返回空列表。</target>
        </trans-unit>
        <trans-unit id="34f2ce5e748390e7ea9b7256361ae68fda804dd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 任何部分都不匹配，则在标量上下文中返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，在列表上下文中返回空列表。</target>
        </trans-unit>
        <trans-unit id="78ec8c638c3f85aaeb890b68130939aac53cb1a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns an empty list.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 任何部分都不匹配，则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="7dc9206b35b196b0963c771281e4b1c34fd9c295" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , all the occurrences of the matching part are replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则匹配部分的所有匹配项都将被 &lt;code&gt;$replacement&lt;/code&gt; （修改 &lt;code&gt;$string&lt;/code&gt; ）并返回 &lt;code&gt;$count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b46dcd3b846eff16d0953c63180197a9948d71b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , in scalar context, returns &lt;b&gt;a reference to&lt;/b&gt; the first occurrence of the matching part (&lt;code&gt;$match_ref&lt;/code&gt; is always true if matches, since every reference is &lt;b&gt;true&lt;/b&gt;); in list context, returns the first occurrence of the matching part.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则在标量上下文中，返回对匹配部分首次出现的&lt;b&gt;引用&lt;/b&gt;（如果匹配，则 &lt;code&gt;$match_ref&lt;/code&gt; 始终为true，因为每个引用均为&lt;b&gt;true&lt;/b&gt;）；在列表上下文中，返回匹配部分的第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="c160da8add608824da0efecdea8fe8dbd7d4c55a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , returns all the matching parts (or matching count in scalar context).</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则返回所有匹配的部分（或标量上下文中的匹配计数）。</target>
        </trans-unit>
        <trans-unit id="c10bc187ce931b2a7b22530d13ae4fe64805817c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , returns the position of the first occurrence of the matching part in scalar context; in list context, returns a two-element list of the position and the length of the matching part.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则返回标量上下文中匹配部分的第一个匹配项的位置；在列表上下文中，返回匹配部分的位置和长度的两元素列表。</target>
        </trans-unit>
        <trans-unit id="d649e7e5214d8eb5d7dfa63d2b26508aa3ec136c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , the first occurrence of the matching part is replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; (always equals to &lt;code&gt;1&lt;/code&gt; ) is returned.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则匹配部分的第一个匹配项将由 &lt;code&gt;$replacement&lt;/code&gt; （修改 &lt;code&gt;$string&lt;/code&gt; ），并返回 &lt;code&gt;$count&lt;/code&gt; （始终等于 &lt;code&gt;1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="923955b556ee1c107b87425fc0d239520dd618a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$thing&lt;/code&gt; refers to an object, then this function returns the name of the package the object has been blessed into. If &lt;code&gt;$thing&lt;/code&gt; doesn't contain a reference to a blessed object, the &lt;code&gt;blessed&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$thing&lt;/code&gt; 引用一个对象，则此函数返回该对象已被祝福的包的名称。如果 &lt;code&gt;$thing&lt;/code&gt; 不包含对受祝福对象的引用，则受 &lt;code&gt;blessed&lt;/code&gt; 函数返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62b5b827c9fa69b1b1193c08475c48b1b10adad6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$total-&amp;gt;{bad} == 0&lt;/code&gt; and &lt;code&gt;$total-&amp;gt;{max} &amp;gt; 0&lt;/code&gt; , you've got a successful test.</source>
          <target state="translated">如果 &lt;code&gt;$total-&amp;gt;{bad} == 0&lt;/code&gt; 且 &lt;code&gt;$total-&amp;gt;{max} &amp;gt; 0&lt;/code&gt; ，则测试成功。</target>
        </trans-unit>
        <trans-unit id="7e9127d14922a52db0d5d2508646de8dbb02dabc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$var&lt;/code&gt; is a scalar that has both numeric and string values, the result is true.</source>
          <target state="translated">如果 &lt;code&gt;$var&lt;/code&gt; 是同时具有数字和字符串值的标量，则结果为true。</target>
        </trans-unit>
        <trans-unit id="811b177adb678df1c7fcd2ebe9a8006c41328bc7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$var&lt;/code&gt; is a scalar which was coded as a vstring the result is true.</source>
          <target state="translated">如果 &lt;code&gt;$var&lt;/code&gt; 是标为vstring的标量，则结果为true。</target>
        </trans-unit>
        <trans-unit id="eea1e5cda1b021861102b8f6816c7f61a9adac01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are non-zero, they must be relative primes, i.e., &lt;code&gt;bgcd($y, $mod)==1&lt;/code&gt; . '&lt;code&gt;NaN&lt;/code&gt; ' is returned when no modular multiplicative inverse exists.</source>
          <target state="translated">如果 &lt;code&gt;$x&lt;/code&gt; 和 &lt;code&gt;$y&lt;/code&gt; 非零，则它们必须是相对质数，即 &lt;code&gt;bgcd($y, $mod)==1&lt;/code&gt; 。当不存在模乘逆时，将返回&amp;ldquo; &lt;code&gt;NaN&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f1241f2fba2bddba0f0228a9100bb47c11034264" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$z&lt;/code&gt; is associated with a buffer, this method has no effect and always returns &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$z&lt;/code&gt; 与缓冲区关联，则此方法无效，并且始终返回 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c2e0c2819ecb9af14cc06d8987b7eee133a60fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%-&lt;/code&gt; is being operated on, if any.</source>
          <target state="translated">如果正在运行 &lt;code&gt;%+&lt;/code&gt; 或 &lt;code&gt;%-&lt;/code&gt; （如果有）。</target>
        </trans-unit>
        <trans-unit id="33759bad70947890a80808b87beeb0ad07a9f99a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is overloaded then the same implementation is used for both the</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 被重载，则对于</target>
        </trans-unit>
        <trans-unit id="2655a0d13879bb1273409b47214e136f442c0716" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'-'&lt;/code&gt; is the first or last character in a character class, it is treated as an ordinary character.</source>
          <target state="translated">如果 &lt;code&gt;'-'&lt;/code&gt; 是字符类中的第一个或最后一个字符，则将其视为普通字符。</target>
        </trans-unit>
        <trans-unit id="3fbcc9b880c1850b742f9cae8dd87f58567ba57c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'-'&lt;/code&gt; is the first or last character in a character class, it is treated as an ordinary character; &lt;code&gt;[-ab]&lt;/code&gt; , &lt;code&gt;[ab-]&lt;/code&gt; and &lt;code&gt;[a\-b]&lt;/code&gt; are all equivalent.</source>
          <target state="translated">如果 &lt;code&gt;'-'&lt;/code&gt; 是字符类中的第一个或最后一个字符，则将其视为普通字符；否则，将其视为普通字符。 &lt;code&gt;[-ab]&lt;/code&gt; ， &lt;code&gt;[ab-]&lt;/code&gt; 和 &lt;code&gt;[a\-b]&lt;/code&gt; 都是等效的。</target>
        </trans-unit>
        <trans-unit id="8b4ef209f3736a149a4cf48e4ad6ea5f08cb5ced" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'fallback'&lt;/code&gt; is TRUE and no copy constructor is defined then, for objects not based on scalars, Perl may silently fall back on simple assignment - that is, assignment of the object reference. In effect, this disables the copy constructor mechanism since no new copy of the object data is created. This is almost certainly not what you want. (It is, however, consistent: for example, Perl's fallback for the &lt;code&gt;++&lt;/code&gt; operator is to increment the reference itself.)</source>
          <target state="translated">如果 &lt;code&gt;'fallback'&lt;/code&gt; 为TRUE且未定义副本构造函数，则对于不基于标量的对象，Perl可能会默默地退回给简单的赋值-即对象引用的赋值。实际上，这将禁用复制构造函数机制，因为没有创建对象数据的新副本。几乎可以肯定这不是您想要的。（但是，这是一致的：例如，Perl对于 &lt;code&gt;++&lt;/code&gt; 运算符的后备方法是增加引用本身。）</target>
        </trans-unit>
        <trans-unit id="f876580a65734a569954c7e1c0d71566801b2a2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'fallback'&lt;/code&gt; is undefined or TRUE then a copy constructor can be autogenerated, but only for objects based on scalars. In other cases it needs to be defined explicitly. Where an object's data is stored as, for example, an array of scalars, the following might be appropriate:</source>
          <target state="translated">如果未定义 &lt;code&gt;'fallback'&lt;/code&gt; 或TRUE，则可以自动生成副本构造函数，但仅适用于基于标量的对象。在其他情况下，需要明确定义。在将对象数据存储为例如标量数组的情况下，以下条件可能是合适的：</target>
        </trans-unit>
        <trans-unit id="aaf2bfa6a27ac22ef6886057189af7b7a1f09aa1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&amp;gt;offs[num].start&lt;/code&gt; or &lt;code&gt;-&amp;gt;offs[num].end&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; then that capture group did not match. &lt;code&gt;-&amp;gt;offs[0].start/end&lt;/code&gt; represents &lt;code&gt;$&amp;amp;&lt;/code&gt; (or &lt;code&gt;${^MATCH}&lt;/code&gt; under &lt;code&gt;//p&lt;/code&gt; ) and &lt;code&gt;-&amp;gt;offs[paren].end&lt;/code&gt; matches &lt;code&gt;$$paren&lt;/code&gt; where &lt;code&gt;$paren &lt;/code&gt; = 1&amp;gt;.</source>
          <target state="translated">如果 &lt;code&gt;-&amp;gt;offs[num].start&lt;/code&gt; 或 &lt;code&gt;-&amp;gt;offs[num].end&lt;/code&gt; 为 &lt;code&gt;-1&lt;/code&gt; ,则该捕获组不匹配。 &lt;code&gt;-&amp;gt;offs[0].start/end&lt;/code&gt; 表示 &lt;code&gt;$&amp;amp;&lt;/code&gt; （或 &lt;code&gt;//p&lt;/code&gt; 下的 &lt;code&gt;${^MATCH}&lt;/code&gt; ）， &lt;code&gt;-&amp;gt;offs[paren].end&lt;/code&gt; 匹配 &lt;code&gt;$$paren&lt;/code&gt; ，其中 &lt;code&gt;$paren &lt;/code&gt; = 1&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="c6203f8ab9db59ac080a4fb390ff800c0d1e53c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&lt;/code&gt; is not a recognized switch letter, getopts() supports arguments &lt;code&gt;--help&lt;/code&gt; and &lt;code&gt;--version&lt;/code&gt; . If &lt;code&gt;main::HELP_MESSAGE()&lt;/code&gt; and/or &lt;code&gt;main::VERSION_MESSAGE()&lt;/code&gt; are defined, they are called; the arguments are the output file handle, the name of option-processing package, its version, and the switches string. If the subroutines are not defined, an attempt is made to generate intelligent messages; for best results, define $main::VERSION.</source>
          <target state="translated">如果 &lt;code&gt;-&lt;/code&gt; 不是公认的切换字母，则getopts（）支持参数 &lt;code&gt;--help&lt;/code&gt; 和 &lt;code&gt;--version&lt;/code&gt; 。如果定义了 &lt;code&gt;main::HELP_MESSAGE()&lt;/code&gt; 和/或 &lt;code&gt;main::VERSION_MESSAGE()&lt;/code&gt; ，则将它们调用；否则，将调用它们。参数是输出文件句柄，选项处理程序包的名称，版本和开关字符串。如果未定义子例程，则尝试生成智能消息。为了获得最佳结果，请定义$ main :: VERSION。</target>
        </trans-unit>
        <trans-unit id="7069d110eb31ac59c5fa5654832fee9ae99f4bc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-Strict&lt;/code&gt; is disabled, then &lt;code&gt;$string&lt;/code&gt; can contain any character except NULL. If any null characters are present, the field will be truncated at the first NULL.</source>
          <target state="translated">如果禁用 &lt;code&gt;-Strict&lt;/code&gt; ，则 &lt;code&gt;$string&lt;/code&gt; 可以包含除NULL之外的任何字符。如果存在任何空字符，则该字段将在第一个NULL处被截断。</target>
        </trans-unit>
        <trans-unit id="72b90d51b78e3f86c015e424f0a9c82ae7cdd392" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:full&lt;/code&gt; is present, for expansion of &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt;, the string</source>
          <target state="translated">如果存在 &lt;code&gt;:full&lt;/code&gt; ，则对于 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 扩展，该字符串</target>
        </trans-unit>
        <trans-unit id="34845b5a7409ae2ff88602a784737cd832c5bd71" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:short&lt;/code&gt; is present, and</source>
          <target state="translated">如果 &lt;code&gt;:short&lt;/code&gt; 存在，并且</target>
        </trans-unit>
        <trans-unit id="51514fa7ee13d4abe63d9987d2badb1e9b04ad61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; winds up off the top of the stack it report the highest context.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 从堆栈顶部结束，则会报告最高上下文。</target>
        </trans-unit>
        <trans-unit id="b1ac9c6b50bb86cfe48d37ba1ee2e0f181649af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (not a string &lt;code&gt;&quot;undef&quot;&lt;/code&gt; ) is passed explicitly as the value for this key, any normalization is not carried out (this may make tailoring easier if any normalization is not desired). Under &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , only contiguous contractions are resolved; e.g. even if &lt;code&gt;A-ring&lt;/code&gt; (and &lt;code&gt;A-ring-cedilla&lt;/code&gt; ) is ordered after &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;A-cedilla-ring&lt;/code&gt; would be primary equal to &lt;code&gt;A&lt;/code&gt; . In this point, &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt;&lt;b&gt;is not&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; .</source>
          <target state="translated">如果将 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （不是字符串 &lt;code&gt;&quot;undef&quot;&lt;/code&gt; ）显式传递为此键的值，则不会执行任何规范化（如果不需要任何规范化，这可能会使剪裁更加容易）。在 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; ，仅解决了连续收缩；例如即使 &lt;code&gt;A-ring&lt;/code&gt; （和 &lt;code&gt;A-ring-cedilla&lt;/code&gt; ）的后有序 &lt;code&gt;Z&lt;/code&gt; ， &lt;code&gt;A-cedilla-ring&lt;/code&gt; 将初级等于 &lt;code&gt;A&lt;/code&gt; 。在这一点上， &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt; &lt;b&gt;不&lt;/b&gt;等于 &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa3ebd4a416f2ed67a7f6e0321914f19253d4061" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, no file is read (but you can define collation elements via &lt;code&gt;entry&lt;/code&gt; ).</source>
          <target state="translated">如果将 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 作为此键的值显式传递，则不会读取任何文件（但是您可以通过 &lt;code&gt;entry&lt;/code&gt; 定义归类元素）。</target>
        </trans-unit>
        <trans-unit id="311ed3b2b34ac0afe5f28bb9003642de34a3cf73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, weight for Hangul syllables is treated as undefined without decomposition into Hangul Jamo. But definition of weight for Hangul syllables in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid.</source>
          <target state="translated">如果将 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 作为此键的值显式传递，则将韩文音节的权重视为未定义，而不会分解为韩文Jamo。但是 &lt;code&gt;table&lt;/code&gt; 或 &lt;code&gt;entry&lt;/code&gt; 中韩语音节的权重定义仍然有效。</target>
        </trans-unit>
        <trans-unit id="a0847d602472c48d4557dcd264e5fd82c70ededc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Devel::Peek&lt;/code&gt; directive has a &lt;code&gt;:opd=FLAGS&lt;/code&gt; argument, this switches on debugging of opcode dispatch. &lt;code&gt;FLAGS&lt;/code&gt; should be a combination of &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; (see &lt;b&gt;-D&lt;/b&gt; flags in &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;). &lt;code&gt;:opd&lt;/code&gt; is a shortcut for &lt;code&gt;:opd=st&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Devel::Peek&lt;/code&gt; 指令具有 &lt;code&gt;:opd=FLAGS&lt;/code&gt; 参数，则将打开操作码调度的调试。 &lt;code&gt;FLAGS&lt;/code&gt; 应该是 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;t&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; 的组合（请参见&lt;a href=&quot;../perlrun&quot;&gt;perlrun中的&lt;/a&gt;&lt;b&gt;-D&lt;/b&gt;标志）。 &lt;code&gt;:opd&lt;/code&gt; 是 &lt;code&gt;:opd=st&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="dae0c23c00276e5219bdb2cdf7fffc6926c2f0f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; can read the file but cannot compile it, it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets an error message in &lt;code&gt;$@&lt;/code&gt; . If &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; cannot read the file, it returns undef and sets &lt;code&gt;$!&lt;/code&gt; to the error. Always check &lt;code&gt;$@&lt;/code&gt; first, as compilation could fail in a way that also sets &lt;code&gt;$!&lt;/code&gt; . If the file is successfully compiled, &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; returns the value of the last expression evaluated.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 可以读取文件但无法编译，则它将返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并在 &lt;code&gt;$@&lt;/code&gt; 设置错误消息。如果 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 无法读取文件，它将返回undef并设置 &lt;code&gt;$!&lt;/code&gt; 错误。请务必先检查 &lt;code&gt;$@&lt;/code&gt; ，因为编译可能会失败，同时也会设置 &lt;code&gt;$!&lt;/code&gt; 。如果文件已成功编译，则 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 返回最后计算的表达式的值。</target>
        </trans-unit>
        <trans-unit id="e753c27e9c7187898b162963067981265acf4ee7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; can read the file but cannot compile it, it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets an error message in &lt;code&gt;$@&lt;/code&gt; . If &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; cannot read the file, it returns undef and sets &lt;code&gt;$!&lt;/code&gt; to the error. Always check &lt;code&gt;$@&lt;/code&gt; first, as compilation could fail in a way that also sets &lt;code&gt;$!&lt;/code&gt; . If the file is successfully compiled, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; returns the value of the last expression evaluated.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 可以读取文件但无法编译，则它将返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并在 &lt;code&gt;$@&lt;/code&gt; 设置错误消息。如果 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 无法读取文件，它将返回undef并设置 &lt;code&gt;$!&lt;/code&gt; 错误。请务必先检查 &lt;code&gt;$@&lt;/code&gt; ，因为编译可能会失败，同时也会设置 &lt;code&gt;$!&lt;/code&gt; 。如果文件已成功编译，则 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 返回最后计算的表达式的值。</target>
        </trans-unit>
        <trans-unit id="a29f1441f3fe81108d43067a84beeb2b3df06a0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; really is needed, then consider using the following:</source>
          <target state="translated">如果确实需要 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; ，请考虑使用以下命令：</target>
        </trans-unit>
        <trans-unit id="fbdbd42df3d8a3289f178b0b712d70c88452aff7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; encounters an operating system error, &lt;code&gt;$!&lt;/code&gt; will be set with the corresponding error message. It can be helpful to check &lt;code&gt;$!&lt;/code&gt; when you are reading from filehandles you don't trust, such as a tty or a socket. The following example uses the operator form of &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; and dies if the result is not defined.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 遇到操作系统错误，则 &lt;code&gt;$!&lt;/code&gt; 将设置相应的错误消息。检查 &lt;code&gt;$!&lt;/code&gt; 可能会有帮助！当您从不信任的文件句柄（例如tty或套接字）中读取内容时。下面的示例使用 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 的运算符形式，如果未定义结果，则死亡。</target>
        </trans-unit>
        <trans-unit id="d241999daf1d6b5b1d790a94e12c3db4b7639b62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 指向格式不正确的UTF-8字符并且启用了UTF8警告，则返回零，并将 &lt;code&gt;*retlen&lt;/code&gt; 设置为-1 （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL）。如果关闭了这些警告，则将静默返回计算值（如果定义良好）（或Unicode REPLACEMENT CHARACTER，如果不是），并设置 &lt;code&gt;*retlen&lt;/code&gt; （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL），则（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 中的下一个可能位置，可以开始一个非格式字符。有关&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;何时&lt;/a&gt;返回REPLACEMENT CHARACTER的详细信息，请参见utf8n_to_uvchr。</target>
        </trans-unit>
        <trans-unit id="e0d74bacc686d5d25a69c27fe56691316eb86755" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value, if well-defined (or the Unicode REPLACEMENT CHARACTER if not), is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 指向格式不正确的UTF-8字符并且启用了UTF8警告，则返回零，并将 &lt;code&gt;*retlen&lt;/code&gt; 设置为-1 （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL）。如果关闭了这些警告，则将静默返回计算值（如果定义正确）（如果没有，则返回Unicode REPLACEMENT CHARACTER），并设置 &lt;code&gt;*retlen&lt;/code&gt; （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL），则（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 中的下一个可能位置，该位置可以开始一个格式正确的字符。有关&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;何时&lt;/a&gt;返回REPLACEMENT CHARACTER的详细信息，请参见utf8n_to_uvchr。</target>
        </trans-unit>
        <trans-unit id="bd7ce6c8380ad430d911ba4aeab09bd5672c569b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; doesn't point to NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 指向检测到的一种 &lt;code&gt;*retlen&lt;/code&gt; ，并且启用了UTF8警告，则返回零，并将* retlen设置为-1 （如果 &lt;code&gt;retlen&lt;/code&gt; 不指向NULL）。如果关闭了这些警告，则将静默返回计算值（如果定义良好）（或Unicode REPLACEMENT CHARACTER，如果不是），并设置 &lt;code&gt;*retlen&lt;/code&gt; （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL），则（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 中的下一个可能位置，可以开始一个非格式字符。有关&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;何时&lt;/a&gt;返回REPLACEMENT CHARACTER的详细信息，请参见utf8n_to_uvchr。</target>
        </trans-unit>
        <trans-unit id="f087a32f599c70b71522f617c69df5af3084d9d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 指向检测到的 &lt;code&gt;*retlen&lt;/code&gt; 之一，并且启用了UTF8警告，则返回零，并将* retlen设置为-1 （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL）。如果关闭了这些警告，则将静默返回计算值（如果定义良好）（或Unicode REPLACEMENT CHARACTER，如果不是），并设置 &lt;code&gt;*retlen&lt;/code&gt; （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL），则（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 中的下一个可能位置，可以开始一个非格式字符。有关&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;何时&lt;/a&gt;返回REPLACEMENT CHARACTER的详细信息，请参见utf8n_to_uvchr。</target>
        </trans-unit>
        <trans-unit id="5f4f6bcfdeca5ca3ce7d26db71a53789a3b67e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; is invoked as &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; or with no arguments (which really means &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(' ', $_)&lt;/code&gt; , see &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;), Perl will set this flag. The regex engine can then check for it and set the SKIPWHITE and WHITE extflags. To do this, the Perl engine does:</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 是作为 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; 或没有参数调用的（这实际上意味着 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(' ', $_)&lt;/code&gt; ，请参见&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;），Perl将设置此标志。然后，正则表达式引擎可以对其进行检查并设置SKIPWHITE和WHITE extflags。为此，Perl引擎执行以下操作：</target>
        </trans-unit>
        <trans-unit id="5670ad2e09b0f96c2653919425d0503ae94298b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; is not called explicitly, it is called implicitly without a parameter at the first use of the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; operator. However, there are a few situations where programs are likely to want to call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt;. One is for generating predictable results, generally for testing or debugging. There, you use &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt;, with the same &lt;code&gt;$seed&lt;/code&gt; each time. Another case is that you may want to call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; after a &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; to avoid child processes sharing the same seed value as the parent (and consequently each other).</source>
          <target state="translated">如果未显式调用 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; ，则在首次使用 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 运算符时将不带参数地隐式调用它。但是，在某些情况下，程序可能希望调用 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 。一种是生成可预测的结果，通常用于测试或调试。在这里，您使用 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt; ，每次都使用相同的 &lt;code&gt;$seed&lt;/code&gt; 。另一种情况是，您可能希望在 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 之后调用srand（），以避免子进程与父进程共享相同的种子值（因此彼此共享）。</target>
        </trans-unit>
        <trans-unit id="cccd9e31f8fdf12513d7e9607d1902ac2bd43369" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; is passed the special filehandle consisting of an underline, no stat is done, but the current contents of the stat structure from the last &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;, or filetest are returned. Example:</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 传递了包含下划线的特殊文件句柄，则不会执行任何stat，但是会返回最后 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 或filetest中stat结构的当前内容。例：</target>
        </trans-unit>
        <trans-unit id="3a943f3015131830c0ed79135dd6ffd5caeedbfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is specified as an argument to &lt;code&gt;autodie&lt;/code&gt; , then it uses &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; to do the heavy lifting. See the description of that module for more information.</source>
          <target state="translated">如果将 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 指定为 &lt;code&gt;autodie&lt;/code&gt; 的参数，则它将使用&lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC :: System :: Simple&lt;/a&gt;进行繁重的工作。有关更多信息，请参见该模块的描述。</target>
        </trans-unit>
        <trans-unit id="3a8b7802544453fc6ad5238177a90c2f0eccb634" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (including &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">如果有效的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （包括 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ）已被调用，则已格式化POSIF :: setlocale（）的字符将受 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境影响。参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;和&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="037fc9127a03dbcb60108531d797528430fc80ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; encounters an operating system error, &lt;code&gt;$!&lt;/code&gt; will be set with the corresponding error message. It can be helpful to check &lt;code&gt;$!&lt;/code&gt; when you are reading from filehandles you don't trust, such as a tty or a socket. The following example uses the operator form of &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; and dies if the result is not defined.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 遇到操作系统错误，则 &lt;code&gt;$!&lt;/code&gt; 将设置相应的错误消息。检查 &lt;code&gt;$!&lt;/code&gt; 可能会有帮助！当您从不信任的文件句柄（例如tty或套接字）中读取内容时。下面的示例使用 &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 的运算符形式，如果未定义结果，则死亡。</target>
        </trans-unit>
        <trans-unit id="2d7702ac9f2d2a81c61f2c22a4643a2b4934ac53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; is not called explicitly, it is called implicitly without a parameter at the first use of the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; operator. However, there are a few situations where programs are likely to want to call &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt;. One is for generating predictable results, generally for testing or debugging. There, you use &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt;, with the same &lt;code&gt;$seed&lt;/code&gt; each time. Another case is that you may want to call &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; after a &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; to avoid child processes sharing the same seed value as the parent (and consequently each other).</source>
          <target state="translated">如果未显式调用 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; ，则在首次使用 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 运算符时将不带参数地隐式调用它。但是，在某些情况下，程序可能希望调用 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 。一种是生成可预测的结果，通常用于测试或调试。在这里，您使用 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt; ，每次都使用相同的 &lt;code&gt;$seed&lt;/code&gt; 。另一种情况是，您可能希望在 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 之后调用srand（），以避免子进程与父进程共享相同的种子值（因此彼此共享）。</target>
        </trans-unit>
        <trans-unit id="0e39dea0f8d4bc40933767354a2f3ede98ed2f3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; is passed the special filehandle consisting of an underline, no stat is done, but the current contents of the stat structure from the last &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;, or filetest are returned. Example:</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 传递了包含下划线的特殊文件句柄，则不会执行任何stat，但是会返回最后 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 或filetest中stat结构的当前内容。例：</target>
        </trans-unit>
        <trans-unit id="4d0fc4f120e9a470fc6f07be480b6e3ed0441ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect:</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 有效：</target>
        </trans-unit>
        <trans-unit id="acafe9c3ebbd6459bfa75fbfb2c2b7c67ce9bcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (including &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">如果有效的 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （包括 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ）已被调用，则已格式化POSIF :: setlocale（）的字符将受 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境影响。参见&lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;和&lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fa0102bfd20d7fca81e7a9229fd0c15e53ef801" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@descriptions&lt;/code&gt; is given, these correspond to the keys used in each call to the add() method. Returns an array of the requested parsers (in the requested order) in list context or an array reference in scalar context.</source>
          <target state="translated">如果给出 &lt;code&gt;@descriptions&lt;/code&gt; ，则它们对应于对add（）方法的每次调用中使用的键。在列表上下文中返回请求的解析器​​数组（按请求的顺序），在标量上下文中返回数组引用。</target>
        </trans-unit>
        <trans-unit id="19fd000c86a54d51f5f77fda0d06393c9c4850ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A'&lt;/code&gt; coincide: &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;AB'&lt;/code&gt; if &lt;code&gt;B&lt;/code&gt; is a better match for &lt;code&gt;T&lt;/code&gt; than &lt;code&gt;B'&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;A'&lt;/code&gt; 重合： &lt;code&gt;AB&lt;/code&gt; 比更好的匹配 &lt;code&gt;AB'&lt;/code&gt; 如果 &lt;code&gt;B&lt;/code&gt; 为更好的匹配 &lt;code&gt;T&lt;/code&gt; 比 &lt;code&gt;B'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1cdd4b8faba979c10f3007699d2ae7796c4a29c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a better match for &lt;code&gt;S&lt;/code&gt; than &lt;code&gt;A'&lt;/code&gt;, &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;A'B'&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是更好的匹配 &lt;code&gt;S&lt;/code&gt; 比 &lt;code&gt;A'&lt;/code&gt; &lt;code&gt;AB&lt;/code&gt; 是不是更好的匹配 &lt;code&gt;A'B'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4156d315c54ceb2fee7698af8b63e714f0a2462c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, all compressed data will be append to the end of the output buffer. Otherwise the output buffer will be cleared before any compressed data is written to it.</source>
          <target state="translated">如果启用了 &lt;code&gt;Append&lt;/code&gt; ，则所有压缩数据将追加到输出缓冲区的末尾。否则，在将任何压缩数据写入输出缓冲区之前，将清除输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="949b457391fc5cf37099eaecff56b10b510ca113" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, all uncompressed data will be append to the end of the output buffer. Otherwise the output buffer will be cleared before any uncompressed data is written to it.</source>
          <target state="translated">如果启用了 &lt;code&gt;Append&lt;/code&gt; ，则所有未压缩的数据将追加到输出缓冲区的末尾。否则，在将任何未压缩的数据写入输出缓冲区之前，将清除输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="badd301fd65baa8719ba53ea1a80949656267442" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any compressed data is written to it.</source>
          <target state="translated">如果启用了 &lt;code&gt;Append&lt;/code&gt; ，则文件将以追加模式打开。否则，在将任何压缩数据写入文件之前，文件的内容（如果有）将被截断。</target>
        </trans-unit>
        <trans-unit id="1454be0505ecbcd6144a8007fb6e1b0593fddf1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any uncompressed data is written to it.</source>
          <target state="translated">如果启用了 &lt;code&gt;Append&lt;/code&gt; ，则文件将以追加模式打开。否则，在将任何未压缩的数据写入文件之前，文件的内容（如果有）将被截断。</target>
        </trans-unit>
        <trans-unit id="65081513c33900b0638266063d522dfa1dd85637" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">如果启用了&amp;ldquo; &lt;code&gt;Append&lt;/code&gt; ，则将通过调用将文件句柄定位到文件的末尾，以在向其写入任何压缩数据之前进行 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 。否则，文件指针将不会移动。</target>
        </trans-unit>
        <trans-unit id="26fb68f8b046494190d2e776943c032f469c5adb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any uncompressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">如果启用了&amp;ldquo; &lt;code&gt;Append&lt;/code&gt; ，则将通过调用将文件句柄定位到文件末尾，以在将任何未压缩的数据写入文件之前进行 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 。否则，文件指针将不会移动。</target>
        </trans-unit>
        <trans-unit id="a8cc3d0792e66bfb9901cb16087529158d209e53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;anyinflate&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则将在所有 &lt;code&gt;anyinflate&lt;/code&gt; 完成后关闭所有输入和/或输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="6e70bd36d1a537ad13b970c5e3018a8db164c8ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;anyuncompress&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则一旦完成 &lt;code&gt;anyuncompress&lt;/code&gt; ，将导致所有输入和/或输出文件句柄都被关闭。</target>
        </trans-unit>
        <trans-unit id="c9769aa738284afde961b2f9bd816825ddcd7550" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;bunzip2&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则将在 &lt;code&gt;bunzip2&lt;/code&gt; 完成后关闭所有输入和/或输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="45ce2b192ba4b06ccb81a9f97e89861c03acbbf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;bzip2&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则一旦 &lt;code&gt;bzip2&lt;/code&gt; 完成，它将导致所有输入和/或输出文件句柄都被关闭。</target>
        </trans-unit>
        <trans-unit id="931b26269125b502ee9a79f1079ca4ffe0db45ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;deflate&lt;/code&gt; has completed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 被指定，并且该值是真实的，它将导致所有的输入和/或输出的文件句柄一次被关闭 &lt;code&gt;deflate&lt;/code&gt; 已完成。</target>
        </trans-unit>
        <trans-unit id="e1fd436eb74e99c1011e676ef2d33a7ca8f221d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;gunzip&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则在 &lt;code&gt;gunzip&lt;/code&gt; 完成后，将关闭所有输入和/或输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="88e88b090b73765991b48faaa8220edbbe4df365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;gzip&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; 且值为true，则一旦 &lt;code&gt;gzip&lt;/code&gt; 完成，将导致所有输入和/或输出文件句柄被关闭。</target>
        </trans-unit>
        <trans-unit id="a90d9e6b94ea9918e75047142b2356a3ca3ce954" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;inflate&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则一旦完成 &lt;code&gt;inflate&lt;/code&gt; ，将导致所有输入和/或输出文件句柄被关闭。</target>
        </trans-unit>
        <trans-unit id="8a6b1372a509b879eaf5e2572538481635eccd1a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;rawdeflate&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则在 &lt;code&gt;rawdeflate&lt;/code&gt; 完成后，将关闭所有输入和/或输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="49cd128d450ba32be8b448e6b5ad08dbf2c6fedd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;rawinflate&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则将在 &lt;code&gt;rawinflate&lt;/code&gt; 完成后关闭所有输入和/或输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="c0389ec2b7c0d6d8486da6034ee7b237f00728a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;unzip&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则一旦完成 &lt;code&gt;unzip&lt;/code&gt; 将关闭所有输入和/或输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="b28f338327748e0ed3d3b45714c8c08b6240edf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;zip&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则在 &lt;code&gt;zip&lt;/code&gt; 完成后将关闭所有输入和/或输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="2f369078e4170f80457a1f35c7563da5a1cc6678" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Blocking&lt;/code&gt; is set to 0, the connection will be in nonblocking mode. If not specified it defaults to 1 (blocking mode).</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Blocking&lt;/code&gt; 设置为0，则连接将处于非阻止模式。如果未指定，则默认为1（阻止模式）。</target>
        </trans-unit>
        <trans-unit id="27ca4e9e26da273f75ec2f01acbae00f6340bacd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DATA&lt;/code&gt; is not specified then the result will indicate that the server wishes the data to be sent. The data must then be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods described in &lt;a href=&quot;cmd&quot;&gt;Net::Cmd&lt;/a&gt;.</source>
          <target state="translated">如果未指定 &lt;code&gt;DATA&lt;/code&gt; ,则结果将指示服务器希望发送数据。然后必须使用&lt;a href=&quot;cmd&quot;&gt;Net :: Cmd中&lt;/a&gt;描述的 &lt;code&gt;datasend&lt;/code&gt; 和 &lt;code&gt;dataend&lt;/code&gt; 方法发送数据。</target>
        </trans-unit>
        <trans-unit id="a2e077eab3d667c955449b8c582fa6b4685309db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ExactAddresses&lt;/code&gt; is passed to the constructor, then addresses should be a valid rfc2821-quoted address, although Net::SMTP will accept the address surrounded by angle brackets.</source>
          <target state="translated">如果将 &lt;code&gt;ExactAddresses&lt;/code&gt; 传递给构造函数，则尽管Net :: SMTP会接受用尖括号括起来的地址，但地址应该是用有效的rfc2821引用的地址。</target>
        </trans-unit>
        <trans-unit id="3d6f9a7de111ad6f15c5cac01bf2df035fda0020" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FH&lt;/code&gt; is specified then it is expected to be a valid filehandle and the result will be printed to it, on success a true value will be returned. If &lt;code&gt;FH&lt;/code&gt; is not specified then the return value, on success, will be a reference to an array containing the article requested, each entry in the array will contain one line of the article.</source>
          <target state="translated">如果指定了 &lt;code&gt;FH&lt;/code&gt; ，则它将被认为是有效的文件句柄，并且结果将被打印到该文件句柄，成功后将返回一个真值。如果未指定 &lt;code&gt;FH&lt;/code&gt; ,则成功返回值将是对包含所请求文章的数组的引用，该数组中的每个条目都将包含该文章的一行。</target>
        </trans-unit>
        <trans-unit id="dcf85df21ad4f13a17a67e275700748df1fd4365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Features&lt;/code&gt; method reports a feature &lt;code&gt;attribs&lt;/code&gt; as present, the method &lt;code&gt;Attribs&lt;/code&gt; is not dummy.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Features&lt;/code&gt; 方法报告存在的特征 &lt;code&gt;attribs&lt;/code&gt; ，则该方法 &lt;code&gt;Attribs&lt;/code&gt; 不是虚拟的。</target>
        </trans-unit>
        <trans-unit id="4e81c8aad04f59a1692e53f2e58534a0dee91bde" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; inherited from &lt;code&gt;DataSource&lt;/code&gt; , which inherited from &lt;code&gt;Thing&lt;/code&gt; , then Perl would keep looking &quot;up the chain&quot; if necessary.</source>
          <target state="translated">如果 &lt;code&gt;File&lt;/code&gt; 继承自 &lt;code&gt;DataSource&lt;/code&gt; ，而DataSource继承自 &lt;code&gt;Thing&lt;/code&gt; ，则Perl将在必要时继续查找&amp;ldquo;上链&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="871f80a19c627be0f52c1b6ef1cd6cbad1358e34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; operator. For convenience, &lt;code&gt;FileHandle::import&lt;/code&gt; tries to import the O_XXX constants from the Fcntl module. If dynamic loading is not available, this may fail, but the rest of FileHandle will still work.</source>
          <target state="translated">如果为 &lt;code&gt;FileHandle::open&lt;/code&gt; 提供了数字模式，它将把该模式和可选的权限值传递给Perl &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 运算符。为了方便起见， &lt;code&gt;FileHandle::import&lt;/code&gt; 尝试从Fcntl模块导入O_XXX常量。如果动态加载不可用，这可能会失败，但是FileHandle的其余部分仍然可以使用。</target>
        </trans-unit>
        <trans-unit id="bb1f139d098c0a906b0eeef1ef6e5dc6d9836cd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or a POSIX fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">如果 &lt;code&gt;FileHandle::open&lt;/code&gt; 接收到Perl模式字符串（&amp;ldquo;&amp;ldquo;&amp;gt;&amp;rdquo;，&amp;ldquo; + &amp;lt;&amp;rdquo;等）或POSIX fopen（）模式字符串（&amp;ldquo; w&amp;rdquo;，&amp;ldquo; r +&amp;rdquo;等），则使用基本的Perl &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 操作员。</target>
        </trans-unit>
        <trans-unit id="a2feaf81d0c85e64b59f8f9c85179dcb22ae1819" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GLOB_NOSORT&lt;/code&gt; is not in effect, sort filenames is alphabetical order (case does not matter) rather than in ASCII order.</source>
          <target state="translated">如果 &lt;code&gt;GLOB_NOSORT&lt;/code&gt; 无效，则排序文件名按字母顺序（大小写无关）而不是ASCII顺序。</target>
        </trans-unit>
        <trans-unit id="67e8ee96965d8f4239b93f54928c2446de8f1552" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable holds &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt; to indicate whether the compiler is version 1 or 2. This is used in setting some of the default cflags. It is set to '' if not gcc.</source>
          <target state="translated">如果使用 &lt;code&gt;GNU&lt;/code&gt; cc（gcc），则此变量保存 &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt; 以指示编译器是版本1还是2。这用于设置某些默认cflag。如果不是gcc，则设置为&amp;ldquo;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ee184683f7c3453d93a7bedbc7d10e7e2d4b99bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable holds the operating system and version used to compile gcc. It is set to '' if not gcc, or if nothing useful can be parsed as the os version.</source>
          <target state="translated">如果使用 &lt;code&gt;GNU&lt;/code&gt; cc（gcc），则此变量保存用于编译gcc的操作系统和版本。如果不是gcc，或者如果没有有用的东西可以解析为os版本，则将其设置为。</target>
        </trans-unit>
        <trans-unit id="c7c81dd0bd77cba1c688390cdf8b5eb031575d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable will enable (if set) the -ansi and -pedantic ccflags for building core files (through cflags script). (See</source>
          <target state="translated">如果使用了 &lt;code&gt;GNU&lt;/code&gt; cc（gcc），则此变量将启用（如果设置）-ansi和-pedantic ccflags以构建核心文件（通过cflags脚本）。（看到</target>
        </trans-unit>
        <trans-unit id="0efd17fe9103ee1aaae0dc765c4fdcda7599e53f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a mode that includes the &lt;code&gt;:&lt;/code&gt; character, it passes all the three arguments to the three-argument &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">如果给 &lt;code&gt;IO::File::open&lt;/code&gt; 一个包括 &lt;code&gt;:&lt;/code&gt; 字符的模式，它将所有三个参数传递给三参数 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="6b022840a97cd5dd7f3b791be6eab1e939aa4189" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; operator. The permissions default to 0666.</source>
          <target state="translated">如果 &lt;code&gt;IO::File::open&lt;/code&gt; 被赋予数字模式，它将把该模式和可选的权限值传递给Perl &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 运算符。权限默认为0666。</target>
        </trans-unit>
        <trans-unit id="53e83efe8c19dc0d9571afae7a20a9dcda69bd25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or an ANSI C fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator (but protects any special characters).</source>
          <target state="translated">如果 &lt;code&gt;IO::File::open&lt;/code&gt; 接收到Perl模式字符串（&amp;ldquo;&amp;gt;&amp;rdquo;，&amp;ldquo; + &amp;lt;&amp;rdquo;等）或ANSI C fopen（）模式字符串（&amp;ldquo; w&amp;rdquo;，&amp;ldquo; r +&amp;rdquo;等），则使用基本的Perl &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 运算符（但保护任何特殊字符）。</target>
        </trans-unit>
        <trans-unit id="25244641705396e9c5a0c603f886177852688f85" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LIST OF FILES TO TEST&lt;/code&gt; is omitted, the file list is obtained from the manifest. The file list may include shell wildcards which will be expanded out.</source>
          <target state="translated">如果省略要 &lt;code&gt;LIST OF FILES TO TEST&lt;/code&gt; 的文件列表，则从清单中获取文件列表。文件列表可能包含将扩展的外壳通配符。</target>
        </trans-unit>
        <trans-unit id="bc047fe00993cc36f1bde2a682c140574f3968b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Level =&amp;gt; Z_BEST_SPEED&lt;/code&gt; has been specified then XFL is set to 2. If &lt;code&gt;Level =&amp;gt; Z_BEST_COMPRESSION&lt;/code&gt; has been specified then XFL is set to 4. Otherwise XFL is set to 0.</source>
          <target state="translated">如果指定了 &lt;code&gt;Level =&amp;gt; Z_BEST_SPEED&lt;/code&gt; 则XFL设置为2。如果指定了 &lt;code&gt;Level =&amp;gt; Z_BEST_COMPRESSION&lt;/code&gt; 则XFL设置为4。否则，XFL设置为0。</target>
        </trans-unit>
        <trans-unit id="0aa2ad74e8011287eeea7635ab9b549166e0107b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LimitOutput&lt;/code&gt; is enabled, the &lt;code&gt;ConsumeInput&lt;/code&gt; option will also be enabled.</source>
          <target state="translated">如果启用 &lt;code&gt;LimitOutput&lt;/code&gt; ，则 &lt;code&gt;ConsumeInput&lt;/code&gt; 选项也将启用。</target>
        </trans-unit>
        <trans-unit id="6b5272a0252e677f68469c99e247e850a281513f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Listen&lt;/code&gt; is defined then a listen socket is created, else if the socket type, which is derived from the protocol, is SOCK_STREAM then connect() is called. If the &lt;code&gt;Listen&lt;/code&gt; argument is given, but false, the queue size will be set to 5.</source>
          <target state="translated">如果定义了 &lt;code&gt;Listen&lt;/code&gt; ,则创建一个监听套接字，否则，如果从协议派生的套接字类型为SOCK_STREAM，则调用connect（）。如果给出 &lt;code&gt;Listen&lt;/code&gt; 参数，但为false，则队列大小将设置为5。</target>
        </trans-unit>
        <trans-unit id="119d044a27ad244e9922efb2919b95739dfc6f48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MESSAGE-SPEC&lt;/code&gt; is a reference to a list of two message numbers and the second number in a range is less than or equal to the first then the range represents all messages in the group after the first message number.</source>
          <target state="translated">如果 &lt;code&gt;MESSAGE-SPEC&lt;/code&gt; 是对两个消息编号列表的引用，并且范围中的第二个编号小于或等于第一个，则范围表示第一个消息编号之后的组中的所有消息。</target>
        </trans-unit>
        <trans-unit id="8fae31070991ff1f03f3487ee3feed2b35c28afa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MESSAGE&lt;/code&gt; is not specified then the message must be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods from &lt;a href=&quot;cmd&quot;&gt;Net::Cmd&lt;/a&gt;</source>
          <target state="translated">如果未指定 &lt;code&gt;MESSAGE&lt;/code&gt; ,则必须使用&lt;a href=&quot;cmd&quot;&gt;Net :: Cmd&lt;/a&gt;的 &lt;code&gt;datasend&lt;/code&gt; 和 &lt;code&gt;dataend&lt;/code&gt; 方法发送消息</target>
        </trans-unit>
        <trans-unit id="b4f8b5e83cced9672fcf844844603c4b1519fbeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NEXT&lt;/code&gt; redispatching is used in the methods of a &quot;diamond&quot; class hierarchy:</source>
          <target state="translated">如果在&amp;ldquo;钻石&amp;rdquo;类层次结构的方法中使用了 &lt;code&gt;NEXT&lt;/code&gt; 重新分配：</target>
        </trans-unit>
        <trans-unit id="fa6cc1f17445fc581970662d0c27067922cd4606" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not specified and the &lt;code&gt;$input&lt;/code&gt; parameter is a filename, the value of &lt;code&gt;$input&lt;/code&gt; will be used for the zip filename header field.</source>
          <target state="translated">如果未指定 &lt;code&gt;Name&lt;/code&gt; 且 &lt;code&gt;$input&lt;/code&gt; 参数为文件名，则 &lt;code&gt;$input&lt;/code&gt; 的值将用于zip文件名头字段。</target>
        </trans-unit>
        <trans-unit id="16fa552eaed310969186dcb3a6fc9c674d262d84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not specified and the &lt;code&gt;$input&lt;/code&gt; parameter is not a filename, no zip filename field will be created.</source>
          <target state="translated">如果未指定 &lt;code&gt;Name&lt;/code&gt; 且 &lt;code&gt;$input&lt;/code&gt; 参数不是文件名，则不会创建zip文件名字段。</target>
        </trans-unit>
        <trans-unit id="35533bcb02c546225ef493f044a6f536db7a71c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_SCAN_ALLOW_UNDERSCORES&lt;/code&gt; is set in</source>
          <target state="translated">如果在 &lt;code&gt;PERL_SCAN_ALLOW_UNDERSCORES&lt;/code&gt; 位置设置了PERL_SCAN_ALLOW_UNDERSCORES</target>
        </trans-unit>
        <trans-unit id="52cb6eab9df9b80f7b8043595e084ea362a195f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; environment variable is set, it will be used as a command for comparing unexpected multiline results. If you have GNU diff installed, you might want to set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to &lt;code&gt;diff -u&lt;/code&gt; . If you don't have a suitable program, you might install the &lt;code&gt;Text::Diff&lt;/code&gt; module and then set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to be &lt;code&gt;perl
-MText::Diff -e 'print diff(@ARGV)'&lt;/code&gt; . If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; isn't set but the &lt;code&gt;Algorithm::Diff&lt;/code&gt; module is available, then it will be used to show the differences in multiline results.</source>
          <target state="translated">如果设置了 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 环境变量，它将用作比较意外多行结果的命令。如果安装了GNU diff，则可能需要将 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 设置为 &lt;code&gt;diff -u&lt;/code&gt; 。如果没有合适的程序，则可以安装 &lt;code&gt;Text::Diff&lt;/code&gt; 模块，然后将 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 设置为 &lt;code&gt;perl -MText::Diff -e 'print diff(@ARGV)'&lt;/code&gt; 。如果未设置 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; ,但是 &lt;code&gt;Algorithm::Diff&lt;/code&gt; 模块可用，那么它将用于显示多行结果中的差异。</target>
        </trans-unit>
        <trans-unit id="dee3b30e6a54d64d92736caa387fa1fa00014452" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PerlIO_push&lt;/code&gt; was performed and open has failed, it must &lt;code&gt;PerlIO_pop&lt;/code&gt; itself, since if it's not, the layer won't be removed and may cause bad problems.</source>
          <target state="translated">如果执行了 &lt;code&gt;PerlIO_push&lt;/code&gt; 并且打开失败，则它必须是 &lt;code&gt;PerlIO_pop&lt;/code&gt; 本身，因为如果没有，则不会删除该层，并且可能会导致严重问题。</target>
        </trans-unit>
        <trans-unit id="e92add0536c750719a7004e9b389b82f89f36216" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Proto&lt;/code&gt; is not given and you specify a symbolic &lt;code&gt;PeerPort&lt;/code&gt; port, then the constructor will try to derive &lt;code&gt;Proto&lt;/code&gt; from the service name. As a last resort &lt;code&gt;Proto&lt;/code&gt; &quot;tcp&quot; is assumed. The &lt;code&gt;Type&lt;/code&gt; parameter will be deduced from &lt;code&gt;Proto&lt;/code&gt; if not specified.</source>
          <target state="translated">如果未提供 &lt;code&gt;Proto&lt;/code&gt; 并指定了符号 &lt;code&gt;PeerPort&lt;/code&gt; 端口，则构造函数将尝试从服务名称派生 &lt;code&gt;Proto&lt;/code&gt; 。作为最后的手段，假定 &lt;code&gt;Proto&lt;/code&gt; &amp;ldquo; tcp&amp;rdquo;。该 &lt;code&gt;Type&lt;/code&gt; 参数将被推断 &lt;code&gt;Proto&lt;/code&gt; 如果没有指定。</target>
        </trans-unit>
        <trans-unit id="fe5b8d2d2cf1b0bc68bdf3e0b890723eb0712304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SkipBad&lt;/code&gt; is true the &lt;code&gt;recipient&lt;/code&gt; will not return an error when a bad address is encountered and it will return an array of addresses that did succeed.</source>
          <target state="translated">如果 &lt;code&gt;SkipBad&lt;/code&gt; 为true，则 &lt;code&gt;recipient&lt;/code&gt; 在遇到错误的地址时将不会返回错误，并且将返回成功的地址数组。</target>
        </trans-unit>
        <trans-unit id="d0468225999e79fdda0c8dc21ac9ecaa76acd0e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Strict&lt;/code&gt; is enabled the following behaviour will be policed:</source>
          <target state="translated">如果启用&amp;ldquo; &lt;code&gt;Strict&lt;/code&gt; 将警告以下行为：</target>
        </trans-unit>
        <trans-unit id="b96d3e92a2737a01f8355b6b1112adb835436235" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TIMEOUT&lt;/code&gt; is missing, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, or less than or equal to 0, then this call behaves the same as &lt;code&gt;dequeue_nb&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;TIMEOUT&lt;/code&gt; 丢失， &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或小于或等于0，则此调用的行为与 &lt;code&gt;dequeue_nb&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b3dbb2f4f8d2f84122800f9964093173fd31ae6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Tie::File&lt;/code&gt; 's memory limit is large enough, all the writing will done in memory. Then, when you call &lt;code&gt;-&amp;gt;flush&lt;/code&gt; , the entire file will be rewritten in a single pass.</source>
          <target state="translated">如果 &lt;code&gt;Tie::File&lt;/code&gt; 的内存限制足够大，则所有写入将在内存中完成。然后，当您调用 &lt;code&gt;-&amp;gt;flush&lt;/code&gt; 时，整个文件将被一次重写。</target>
        </trans-unit>
        <trans-unit id="717bb6fc0375ed7c5d36f69b6a41d7203067aa19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;UCA_Version&lt;/code&gt; is 26 or later, the &lt;code&gt;identical&lt;/code&gt; level is preferred; &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1)&lt;/code&gt; and &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1,&lt;/code&gt;&lt;code&gt;variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; should be used.</source>
          <target state="translated">如果 &lt;code&gt;UCA_Version&lt;/code&gt; 为26或更高版本，则首选 &lt;code&gt;identical&lt;/code&gt; 级别；否则，默认为0 。 &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1)&lt;/code&gt; 和 &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1,&lt;/code&gt; &lt;code&gt;variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02434c0e062f79bd3d8c8ef802e8385afcfb68a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;UCA_Version&lt;/code&gt; is equal to or greater than 14, default is &lt;code&gt;[]&lt;/code&gt; (i.e. no rearrangement).</source>
          <target state="translated">如果 &lt;code&gt;UCA_Version&lt;/code&gt; 等于或大于14，则默认值为 &lt;code&gt;[]&lt;/code&gt; （即不重新排列）。</target>
        </trans-unit>
        <trans-unit id="b309f1cb237c3cb1331fc5e7c80d1a3dc5b1ba82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;VALUE&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; then the debug level will be set to the default debug level for the class.</source>
          <target state="translated">如果 &lt;code&gt;VALUE&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ,则调试级别将设置为该类的默认调试级别。</target>
        </trans-unit>
        <trans-unit id="44072f8a4414482a73ce8e1b198996a838545678" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WHERE&lt;/code&gt; is given then the first &lt;code&gt;WHERE&lt;/code&gt; bytes of the file will not be transferred, and the remaining bytes will be appended to the local file if it already exists.</source>
          <target state="translated">如果 &lt;code&gt;WHERE&lt;/code&gt; 给出那么第一个 &lt;code&gt;WHERE&lt;/code&gt; 文件的字节将不得转让，如果它已经存在剩余字节将被追加到本地文件。</target>
        </trans-unit>
        <trans-unit id="3cdf8e9a5929ab26a43f519805188b99c5f0b522" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bunzip2 object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the uncompressed data is written to it.</source>
          <target state="translated">如果 &lt;code&gt;appendOutput&lt;/code&gt; 在构造函数bunzip2命令对象启用，未压缩数据将被追加到 &lt;code&gt;$output&lt;/code&gt; 。如果未启用，则将 &lt;code&gt;$output&lt;/code&gt; 截断，然后再将未压缩的数据写入其中。</target>
        </trans-unit>
        <trans-unit id="f450b4455b8d11ffbd473a1bb2010cafedaed33e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bzip2 object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the compressed data is written to it.</source>
          <target state="translated">如果在bzip2对象的构造函数中启用了 &lt;code&gt;appendOutput&lt;/code&gt; ，则压缩后的数据将附加到 &lt;code&gt;$output&lt;/code&gt; 。如果未启用，则在将压缩数据写入 &lt;code&gt;$output&lt;/code&gt; 之前将其截断。</target>
        </trans-unit>
        <trans-unit id="1b199e24b4ee7d3c552a01dcb6637c8cc3a9e1f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bundling_override&lt;/code&gt; is enabled, bundling is enabled as with &lt;code&gt;bundling&lt;/code&gt; but now long option names override option bundles.</source>
          <target state="translated">如果 &lt;code&gt;bundling_override&lt;/code&gt; 启用，捆绑与激活 &lt;code&gt;bundling&lt;/code&gt; ，但现在长选项名称覆盖选项包。</target>
        </trans-unit>
        <trans-unit id="e3dc97ff755fb934bfd6f1a8ed830ff62cc4e40b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;consumeInput&lt;/code&gt; is enabled in the constructor for the bunzip2 object, &lt;code&gt;$input&lt;/code&gt; will have all compressed data removed from it after uncompression. On &lt;code&gt;BZ_OK&lt;/code&gt; return this will mean that &lt;code&gt;$input&lt;/code&gt; will be an empty string; when &lt;code&gt;BZ_STREAM_END&lt;/code&gt;&lt;code&gt;$input&lt;/code&gt; will either be an empty string or will contain whatever data immediately followed the compressed data stream.</source>
          <target state="translated">如果 &lt;code&gt;consumeInput&lt;/code&gt; 在构造函数bunzip2命令对象启用， &lt;code&gt;$input&lt;/code&gt; 将解压缩之后，从它删除了所有的压缩数据。在 &lt;code&gt;BZ_OK&lt;/code&gt; 返回上，这意味着 &lt;code&gt;$input&lt;/code&gt; 将是一个空字符串；当 &lt;code&gt;BZ_STREAM_END&lt;/code&gt; &lt;code&gt;$input&lt;/code&gt; 将为空字符串或包含紧随压缩数据流之后的任何数据。</target>
        </trans-unit>
        <trans-unit id="d1dd05ec9d332008df8a7389201274fce30d7a10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cv&lt;/code&gt; is a constant sub eligible for inlining, returns the constant value returned by the sub. Otherwise, returns NULL.</source>
          <target state="translated">如果 &lt;code&gt;cv&lt;/code&gt; 是可以进行内联的常数子，则返回该子返回的常数值。否则，返回NULL。</target>
        </trans-unit>
        <trans-unit id="d37d86734f002378b0c0f7d856f9af361e68cbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;done_testing()&lt;/code&gt; is called twice, the second call will issue a failing test.</source>
          <target state="translated">如果两次调用 &lt;code&gt;done_testing()&lt;/code&gt; ，则第二次调用将发出失败的测试。</target>
        </trans-unit>
        <trans-unit id="a074a15a27ab0ac63397d85c19569d7f123797eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;down()&lt;/code&gt; attempts to decrement the counter below zero, it blocks until the counter is large enough. Note that while a semaphore can be created with a starting count of zero, any &lt;code&gt;up()&lt;/code&gt; or &lt;code&gt;down()&lt;/code&gt; always changes the counter by at least one, and so &lt;code&gt;$semaphore-&amp;gt;down(0)&lt;/code&gt; is the same as &lt;code&gt;$semaphore-&amp;gt;down(1)&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;down()&lt;/code&gt; 尝试将计数器减小到零以下，它将阻塞直到计数器足够大。请注意，虽然可以从零开始计数创建信号量，但是任何 &lt;code&gt;up()&lt;/code&gt; 或 &lt;code&gt;down()&lt;/code&gt; 始终会将计数器更改至少一个，因此 &lt;code&gt;$semaphore-&amp;gt;down(0)&lt;/code&gt; 与 &lt;code&gt;$semaphore-&amp;gt;down(1)&lt;/code&gt; 相同down（1）。</target>
        </trans-unit>
        <trans-unit id="40ba804a2596516d0c1570f7f282c973ab9c2345" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extract&lt;/code&gt; is called without a list of file names, the entire contents of the archive are extracted.</source>
          <target state="translated">如果在没有文件名列表的情况下调用了 &lt;code&gt;extract&lt;/code&gt; ，则将提取存档的全部内容。</target>
        </trans-unit>
        <trans-unit id="fd1942906fddd7c45d5614b21cfa194ab92d3708" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fallback&lt;/code&gt; is TRUE for both operands then perform the usual operation for the operator, treating the operands as numbers, strings, or booleans as appropriate for the operator (see note).</source>
          <target state="translated">如果两个操作数的 &lt;code&gt;fallback&lt;/code&gt; 均为TRUE，则对操作符执行通常的操作，将操作数视作适合操作符的数字，字符串或布尔值（请参见注释）。</target>
        </trans-unit>
        <trans-unit id="5fd52e0f8326669fc207b7050c548b0008ac0b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; &amp;amp; SV_SMAGIC is true, will call SvSETMAGIC. If &lt;code&gt;flags&lt;/code&gt; &amp;amp; SV_HAS_TRAILING_NUL is true, then &lt;code&gt;ptr[len]&lt;/code&gt; must be &lt;code&gt;NUL&lt;/code&gt; , and the realloc will be skipped (i.e. the buffer is actually at least 1 byte longer than &lt;code&gt;len&lt;/code&gt; , and already meets the requirements for storing in &lt;code&gt;SvPVX&lt;/code&gt; ).</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; ＆SV_SMAGIC为true，则将调用SvSETMAGIC。如果 &lt;code&gt;flags&lt;/code&gt; ＆SV_HAS_TRAILING_NUL为true，则 &lt;code&gt;ptr[len]&lt;/code&gt; 必须为 &lt;code&gt;NUL&lt;/code&gt; ，并且将跳过重新分配（即，缓冲区实际上比 &lt;code&gt;len&lt;/code&gt; 长至少1个字节，并且已经满足存储在 &lt;code&gt;SvPVX&lt;/code&gt; 中的要求）。</target>
        </trans-unit>
        <trans-unit id="0edc0d40cf1bae07e3194b59cda754464ac0af29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; does not include the &lt;code&gt;G_DISCARD&lt;/code&gt; flag then &lt;code&gt;hv_delete&lt;/code&gt; will create and return a mortal copy of the deleted value.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 不包括 &lt;code&gt;G_DISCARD&lt;/code&gt; 标志，则 &lt;code&gt;hv_delete&lt;/code&gt; 将创建并返回已删除值的最终副本。</target>
        </trans-unit>
        <trans-unit id="10df1aa8bd4f0824119d6cef9b8d19de3f0f48a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has SV_FORCE_UTF8_UPGRADE set, this function assumes that the PV will expand when converted to UTF-8, and skips the extra work of checking for that. Typically this flag is used by a routine that has already parsed the string and found such characters, and passes this information on so that the work doesn't have to be repeated.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 设置了SV_FORCE_UTF8_UPGRADE，则此函数假定PV转换为UTF-8时将展开，并跳过检查该标志的额外工作。通常，该标志由已解析字符串并找到此类字符的例程使用，并将此信息传递给该例程，因此不必重复工作。</target>
        </trans-unit>
        <trans-unit id="37b250f1c8aff9dcda9cab5ceb3c6ef02e048bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SV_SMAGIC&lt;/code&gt; bit set, will &lt;code&gt;mg_set&lt;/code&gt; on &lt;code&gt;dsv&lt;/code&gt; afterwards if appropriate. &lt;code&gt;sv_catpvn&lt;/code&gt; and &lt;code&gt;sv_catpvn_nomg&lt;/code&gt; are implemented in terms of this function.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 将 &lt;code&gt;SV_SMAGIC&lt;/code&gt; 位置1， &lt;code&gt;mg_set&lt;/code&gt; 在 &lt;code&gt;dsv&lt;/code&gt; 上进行mg_set（如果适用）。 &lt;code&gt;sv_catpvn&lt;/code&gt; 和 &lt;code&gt;sv_catpvn_nomg&lt;/code&gt; 是根据此功能实现的。</target>
        </trans-unit>
        <trans-unit id="3ef48bc44bf4f8b7aeee22cccd386b0d4dcfb8f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame &amp;amp; 4&lt;/code&gt; , arguments to functions are printed, plus context and caller info. If &lt;code&gt;frame &amp;amp; 8&lt;/code&gt; , overloaded &lt;code&gt;stringify&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;d &lt;code&gt;FETCH&lt;/code&gt; is enabled on the printed arguments. If &lt;code&gt;frame
&amp;amp; 16&lt;/code&gt; , the return value from the subroutine is printed.</source>
          <target state="translated">如果为 &lt;code&gt;frame &amp;amp; 4&lt;/code&gt; ，则输出函数的参数，以及上下文和调用者信息。如果为 &lt;code&gt;frame &amp;amp; 8&lt;/code&gt; ，则在打印的参数上启用重载的 &lt;code&gt;stringify&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; d &lt;code&gt;FETCH&lt;/code&gt; 。如果为 &lt;code&gt;frame &amp;amp; 16&lt;/code&gt; ，则打印子例程的返回值。</target>
        </trans-unit>
        <trans-unit id="b54e3981c02655a1fab1a806eaa02120a0c9bfed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;function&lt;/code&gt; was the name of a function, then &lt;code&gt;memoize&lt;/code&gt; hides the old version and installs the new memoized version under the old name, so that &lt;code&gt;&amp;amp;function(...)&lt;/code&gt; actually invokes the memoized version.</source>
          <target state="translated">如果 &lt;code&gt;function&lt;/code&gt; 是函数的名称，则 &lt;code&gt;memoize&lt;/code&gt; 隐藏旧版本，并以旧名称安装新的备忘录版本，以便 &lt;code&gt;&amp;amp;function(...)&lt;/code&gt; 实际上会调用备忘录版本。</target>
        </trans-unit>
        <trans-unit id="4823580da2e2f493ed7ea495228a6fb43531c2a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;get_handle&lt;/code&gt; senses that it's running in program that was invoked as a CGI, then it tries to get language-tags out of the environment variable &quot;HTTP_ACCEPT_LANGUAGE&quot;, and it pretends that those were the languages passed as parameters to &lt;code&gt;get_handle&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;get_handle&lt;/code&gt; 感觉到它正在作为CGI调用的程序中运行，则它将尝试从环境变量&amp;ldquo; HTTP_ACCEPT_LANGUAGE&amp;rdquo;中获取语言标签，并假装这些语言是作为参数传递给 &lt;code&gt;get_handle&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="0a5501c614e6eee43f2f2b50112bdb8a824a2fea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a completely empty typeglob, it is deleted from the stash.</source>
          <target state="translated">如果 &lt;code&gt;gv&lt;/code&gt; 是完全空的typeglob，则将其从存储中删除。</target>
        </trans-unit>
        <trans-unit id="171c792393c3bd16ce8492fbf51df1d34df47fa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a typeglob containing only a sufficiently-ordinary constant sub, the typeglob is replaced with a scalar-reference placeholder that more compactly represents the same thing.</source>
          <target state="translated">如果 &lt;code&gt;gv&lt;/code&gt; 是仅包含足够普通的常数sub的typeglob，则将typeglob替换为更紧凑地表示同一事物的标量引用占位符。</target>
        </trans-unit>
        <trans-unit id="15863e2e3bcfe9bf34415295eb886e40c8b84a73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a typeglob whose subroutine entry is a constant sub eligible for inlining, or &lt;code&gt;gv&lt;/code&gt; is a placeholder reference that would be promoted to such a typeglob, then returns the value returned by the sub. Otherwise, returns NULL.</source>
          <target state="translated">如果 &lt;code&gt;gv&lt;/code&gt; 是一个typeglob，其子例程条目是可以进行内联的常量子程序，或者 &lt;code&gt;gv&lt;/code&gt; 是一个占位符引用，将被提升为此类typeglob，则返回该子程序返回的值。否则，返回NULL。</target>
        </trans-unit>
        <trans-unit id="5b76926b7fe43456ac634077129deadebe6d1749" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignoreName&lt;/code&gt; or &lt;code&gt;undefName&lt;/code&gt; is used, character names should be specified as a comment (following &lt;code&gt;#&lt;/code&gt; ) on each line.</source>
          <target state="translated">如果使用 &lt;code&gt;ignoreName&lt;/code&gt; 或 &lt;code&gt;undefName&lt;/code&gt; ，则应在每行上将字符名称指定为注释（在 &lt;code&gt;#&lt;/code&gt; 之后）。</target>
        </trans-unit>
        <trans-unit id="606bfb04b8810dddbc165299090455517c6f31d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is 0, it will be calculated using &lt;code&gt;strlen(s)&lt;/code&gt; , (which means if you use this option, that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; can't have embedded &lt;code&gt;NUL&lt;/code&gt; characters and has to have a terminating &lt;code&gt;NUL&lt;/code&gt; byte).</source>
          <target state="translated">如果 &lt;code&gt;len&lt;/code&gt; 为0，则将使用 &lt;code&gt;strlen(s)&lt;/code&gt; 进行计算（这意味着，如果使用此选项，则 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 不能嵌入 &lt;code&gt;NUL&lt;/code&gt; 字符，而必须具有终止 &lt;code&gt;NUL&lt;/code&gt; 字节）。</target>
        </trans-unit>
        <trans-unit id="564f6927aa67faeb8390b79eb296fc0609382f07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;list_archive()&lt;/code&gt; is passed an array reference as its third argument it returns a list of hash references containing the requested properties of each file. The following list of properties is supported: full_path, name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type.</source>
          <target state="translated">如果将 &lt;code&gt;list_archive()&lt;/code&gt; 传递给数组引用作为其第三个参数，则它将返回包含每个文件的请求属性的哈希引用列表。支持以下属性列表：full_path，名称，大小，mtime（上次修改日期），模式，uid，gid，链接名，uname，gname，devmajor，devminor，前缀，类型。</target>
        </trans-unit>
        <trans-unit id="30b6892ba87f6c10d6419b32b55f7a86419b6ce9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;list_files()&lt;/code&gt; is passed an array reference as its first argument it returns a list of hash references containing the requested properties of each file. The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix.</source>
          <target state="translated">如果将 &lt;code&gt;list_files()&lt;/code&gt; 作为第一个参数传递给数组引用，则它将返回包含每个文件的请求属性的哈希引用列表。支持以下属性列表：名称，大小，mtime（上次修改日期），模式，uid，gid，链接名，uname，gname，devmajor，devminor，前缀。</target>
        </trans-unit>
        <trans-unit id="6b6ca16484970453642612331b9f95d68983da46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;make_path&lt;/code&gt; or &lt;code&gt;remove_tree&lt;/code&gt; encounter an error, a diagnostic message will be printed to &lt;code&gt;STDERR&lt;/code&gt; via &lt;code&gt;carp&lt;/code&gt; (for non-fatal errors), or via &lt;code&gt;croak&lt;/code&gt; (for fatal errors).</source>
          <target state="translated">如果 &lt;code&gt;make_path&lt;/code&gt; 或 &lt;code&gt;remove_tree&lt;/code&gt; 遇到错误，诊断消息将通过 &lt;code&gt;carp&lt;/code&gt; （对于非致命错误）或通过 &lt;code&gt;croak&lt;/code&gt; （对于致命错误）打印到 &lt;code&gt;STDERR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e12005256b82b7dbf15e43b617aa6446b9ea3caa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;merge&lt;/code&gt; is true the harness will create parsers that merge STDOUT and STDERR together for any processes they start.</source>
          <target state="translated">如果 &lt;code&gt;merge&lt;/code&gt; 为true，则线束将创建解析器，以将STDOUT和STDERR合并到一起以启动任何进程。</target>
        </trans-unit>
        <trans-unit id="a5a417a1f8bba03650439d46556e6b5e2f42cdc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;namlen&lt;/code&gt; is greater than zero then a &lt;code&gt;savepvn&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;namlen&lt;/code&gt; 大于零，则执行 &lt;code&gt;savepvn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5b4f60a5261a12c3ad5e79f21f3b4cceb3007ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new()&lt;/code&gt; is invoked with arguments and the &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; method fails for any reason, &lt;code&gt;new()&lt;/code&gt; returns undef.</source>
          <target state="translated">如果使用参数调用 &lt;code&gt;new()&lt;/code&gt; 且 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; 方法由于任何原因而失败，则 &lt;code&gt;new()&lt;/code&gt; 返回undef。</target>
        </trans-unit>
        <trans-unit id="14b4ce4ab1caa8905ea03f71030c64a0c404abbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pass_through&lt;/code&gt; is also enabled, options processing will terminate at the first unrecognized option, or non-option, whichever comes first.</source>
          <target state="translated">如果还启用了 &lt;code&gt;pass_through&lt;/code&gt; ，则选项处理将在第一个无法识别的选项或非选项（以先到者为准）处终止。</target>
        </trans-unit>
        <trans-unit id="c02b449190a1b90198a28e96aea10bbc105c7788" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pe1&lt;/code&gt; is non-NULL and the pointer it points to is not NULL, that pointer is considered an end pointer to the position 1 byte past the maximum point in &lt;code&gt;s1&lt;/code&gt; beyond which scanning will not continue under any circumstances. (This routine assumes that UTF-8 encoded input strings are not malformed; malformed input can cause it to read past &lt;code&gt;pe1&lt;/code&gt; ). This means that if both &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;pe1&lt;/code&gt; are specified, and &lt;code&gt;pe1&lt;/code&gt; is less than &lt;code&gt;s1&lt;/code&gt; +&lt;code&gt;l1&lt;/code&gt; , the match will never be successful because it can never get as far as its goal (and in fact is asserted against). Correspondingly for &lt;code&gt;pe2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;pe1&lt;/code&gt; 为非NULL，并且其指向的指针也不为NULL，则该指针将被视为指向 &lt;code&gt;s1&lt;/code&gt; 中最大点之后1​​个字节的位置的结束指针，在任何情况下，该点都将无法继续扫描。 （此例程假定UTF-8编码的输入字符串没有格式错误；格式错误的输入可能会导致它读取到 &lt;code&gt;pe1&lt;/code&gt; 之后）。这意味着，如果同时指定了 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;pe1&lt;/code&gt; ，并且 &lt;code&gt;pe1&lt;/code&gt; 小于 &lt;code&gt;s1&lt;/code&gt; + &lt;code&gt;l1&lt;/code&gt; ，则匹配将永远不会成功，因为它永远无法达到目标（实际上是反对）。相对于 &lt;code&gt;s2&lt;/code&gt; ,对应于 &lt;code&gt;pe2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5414852c94de9d937514c7b2ffd918737261abd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;permute&lt;/code&gt; is enabled, this means that</source>
          <target state="translated">如果启用了 &lt;code&gt;permute&lt;/code&gt; ，则意味着</target>
        </trans-unit>
        <trans-unit id="e47709e624b959c659a6f5424e397b7429bd08c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preprocess&lt;/code&gt; and/or &lt;code&gt;normalization&lt;/code&gt; is applied, the code points of the string after them (in NFD by default) are used.</source>
          <target state="translated">如果应用了 &lt;code&gt;preprocess&lt;/code&gt; 和/或 &lt;code&gt;normalization&lt;/code&gt; 则使用其后的字符串的代码点（默认为NFD）。</target>
        </trans-unit>
        <trans-unit id="c7a3e0b813ddb5c552aec4199fd49e48847ff2c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prompt()&lt;/code&gt; detects that it is not running interactively and there is nothing on STDIN or if the PERL_MM_USE_DEFAULT environment variable is set to true, the $default will be used without prompting. This prevents automated processes from blocking on user input.</source>
          <target state="translated">如果hint &lt;code&gt;prompt()&lt;/code&gt; 检测到它不是交互运行的，并且STDIN上没有任何内容，或者如果PERL_MM_USE_DEFAULT环境变量设置为true，则将使用$ default而不提示。这样可以防止自动过程阻止用户输入。</target>
        </trans-unit>
        <trans-unit id="9d8185228e8e06faca877b9d0926aab5904e951a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;require_order&lt;/code&gt; is enabled, options processing terminates when the first non-option is encountered.</source>
          <target state="translated">如果启用了 &lt;code&gt;require_order&lt;/code&gt; ，则遇到第一个非选项时，选项处理将终止。</target>
        </trans-unit>
        <trans-unit id="7ec89b0e13a7db5b1125011c45839f2c6cfb36ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;require_order&lt;/code&gt; is enabled, options processing will terminate at the first unrecognized option, or non-option, whichever comes first and all remaining arguments are passed to &lt;code&gt;@ARGV&lt;/code&gt; instead of the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present. However, if &lt;code&gt;permute&lt;/code&gt; is enabled instead, results can become confusing.</source>
          <target state="translated">如果启用了 &lt;code&gt;require_order&lt;/code&gt; ，则选项处理将在第一个无法识别的选项（或非选项）（以先到者为准）终止，并且所有剩余参数都传递给 &lt;code&gt;@ARGV&lt;/code&gt; 而不是catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; (如果存在）。但是，如果改为启用 &lt;code&gt;permute&lt;/code&gt; ，则结果可能会造成混淆。</target>
        </trans-unit>
        <trans-unit id="ba0fe2f6810522d3880f034d6ed2e0c1aaeec082" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_locale()&lt;/code&gt; fails for some reason (for example, an attempt to set to a locale unknown to the system), the locale for the category is not changed, and the function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;set_locale()&lt;/code&gt; 由于某种原因（例如，尝试设置为系统未知的语言环境）而失败，则该类别的语言环境不会更改，并且该函数将返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04ffb889ba3672c819c8ebc2556d3ca7f2216415" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sv&lt;/code&gt; is not already magical, Perl uses the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro to convert &lt;code&gt;sv&lt;/code&gt; to type &lt;code&gt;SVt_PVMG&lt;/code&gt; . Perl then continues by adding new magic to the beginning of the linked list of magical features. Any prior entry of the same type of magic is deleted. Note that this can be overridden, and multiple instances of the same type of magic can be associated with an SV.</source>
          <target state="translated">如果 &lt;code&gt;sv&lt;/code&gt; 并不是很神奇，则Perl使用 &lt;code&gt;SvUPGRADE&lt;/code&gt; 宏将 &lt;code&gt;sv&lt;/code&gt; 转换为 &lt;code&gt;SVt_PVMG&lt;/code&gt; 类型。然后，Perl继续，将新的魔术添加到魔术功能的链接列表的开头。之前所有相同类型的魔法条目都会被删除。请注意，这可以被覆盖，并且相同类型的魔术的多个实例可以与SV相关联。</target>
        </trans-unit>
        <trans-unit id="c5c3008df77cfa39eeaefce991da14fbe22117ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u1&lt;/code&gt; is true, the string &lt;code&gt;s1&lt;/code&gt; is assumed to be in UTF-8-encoded Unicode; otherwise it is assumed to be in native 8-bit encoding. Correspondingly for &lt;code&gt;u2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;u1&lt;/code&gt; 为true，则假定字符串 &lt;code&gt;s1&lt;/code&gt; 以UTF-8编码的Unicode编码；否则，假定为本地8位编码。相对于 &lt;code&gt;s2&lt;/code&gt; 对应于 &lt;code&gt;u2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcb599464a46f537e87d3017df24f3e8e2283ffd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uv&lt;/code&gt; is a Unicode surrogate code point and UNICODE_WARN_SURROGATE is set, the function will raise a warning, provided UTF8 warnings are enabled. If instead UNICODE_DISALLOW_SURROGATE is set, the function will fail and return NULL. If both flags are set, the function will both warn and return NULL.</source>
          <target state="translated">如果 &lt;code&gt;uv&lt;/code&gt; 是Unicode代理代码点，并且设置了UNICODE_WARN_SURROGATE，则在启用UTF8警告的情况下，该函数将发出警告。如果改为设置UNICODE_DISALLOW_SURROGATE，则该函数将失败并返回NULL。如果同时设置了两个标志，则该函数将同时发出警告并返回NULL。</target>
        </trans-unit>
        <trans-unit id="ae30129230a55488ef814c14253472811e67904d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; in</source>
          <target state="translated">如果 &lt;code&gt;value&lt;/code&gt; 在</target>
        </trans-unit>
        <trans-unit id="02c3454635e56b23178636e2bb6aec32fcd96776" translate="yes" xml:space="preserve">
          <source>If @DynaLoader::dl_resolve_using contains &lt;code&gt;-L*&lt;/code&gt; or &lt;code&gt;-l*&lt;/code&gt; entries then Mkbootstrap will automatically add a dl_findfile() call to the generated &lt;code&gt;*.bs&lt;/code&gt; file.</source>
          <target state="translated">如果@DynaLoader :: dl_resolve_using包含 &lt;code&gt;-L*&lt;/code&gt; 或 &lt;code&gt;-l*&lt;/code&gt; 条目，则Mkbootstrap将自动将dl_findfile（）调用添加到生成的 &lt;code&gt;*.bs&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="203a87ac5779da1d943be09c716f0304a892b601" translate="yes" xml:space="preserve">
          <source>If @args is not given, an empty list will be used.</source>
          <target state="translated">如果没有给定@args,将使用一个空列表。</target>
        </trans-unit>
        <trans-unit id="f3523d8b4dddaad91344458f88af994bb31e6c10" translate="yes" xml:space="preserve">
          <source>If @imports are given, they are passed through to the use. So this:</source>
          <target state="translated">如果给了@imports,就会传递给使用。所以这。</target>
        </trans-unit>
        <trans-unit id="649b9ffd5b70f81915b08f4bc8291a1a2ce523f9" translate="yes" xml:space="preserve">
          <source>If @suffixes are given each element is a pattern (either a string or a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) matched against the end of the $filename. The matching portion is removed and becomes the $suffix.</source>
          <target state="translated">如果给出了@后缀，则每个元素都是与$ filename末尾匹配的模式（字符串或 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ）。匹配部分将被删除并成为$后缀。</target>
        </trans-unit>
        <trans-unit id="e062bfde8c040f50084c09a806e3edbdcdba4c2d" translate="yes" xml:space="preserve">
          <source>If ATTR is not specified, coloralias() returns the standard color name to which ALIAS is aliased, if any, or undef if ALIAS does not exist.</source>
          <target state="translated">如果没有指定ATTR,coloralias()会返回ALIAS被别名的标准颜色名称(如果有),如果ALIAS不存在,则返回undef。</target>
        </trans-unit>
        <trans-unit id="f999d6f241c02db8ba7aa5052a43f699b6917b00" translate="yes" xml:space="preserve">
          <source>If ATTR is specified, coloralias() sets up an alias of ALIAS for the standard color ATTR. From that point forward, ALIAS can be passed into color(), colored(), and colorvalid() and will have the same meaning as ATTR. One possible use of this facility is to give more meaningful names to the 256-color RGB colors. Only alphanumerics, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt; , and &lt;code&gt;-&lt;/code&gt; are allowed in alias names.</source>
          <target state="translated">如果指定了ATTR，coloralias（）将为标准颜色ATTR设置ALIAS的别名。从那时起，可以将ALIAS传递到color（），colored（）和colorvalid（）中，并且将具有与ATTR相同的含义。该功能的一种可能用途是为256色RGB颜色赋予更有意义的名称。仅字母数字， &lt;code&gt;.&lt;/code&gt; ， &lt;code&gt;_&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 允许使用别名。</target>
        </trans-unit>
        <trans-unit id="ed33ee3bf815a6c3c728d6a64deacab551214ad3" translate="yes" xml:space="preserve">
          <source>If BITS is 16 or more, bytes of the input string are grouped into chunks of size BITS/8, and each group is converted to a number as with pack()/unpack() with big-endian formats &lt;code&gt;n&lt;/code&gt; /&lt;code&gt;N&lt;/code&gt; (and analogously for BITS==64). See &lt;a href=&quot;#pack&quot;&gt;pack&lt;/a&gt; for details.</source>
          <target state="translated">如果BITS为16或更大，则将输入字符串的字节分组为大小为BITS / 8的块，然后将每个组转换为数字，如pack（）/ unpack（）那样，使用大尾数格式 &lt;code&gt;n&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; （并且类似地）对于BITS == 64）。有关详细信息，请参见&lt;a href=&quot;#pack&quot;&gt;包装&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5890dee5bd815a9a6b870ab0d81456c70fdb6033" translate="yes" xml:space="preserve">
          <source>If BITS is 16 or more, bytes of the input string are grouped into chunks of size BITS/8, and each group is converted to a number as with pack()/unpack() with big-endian formats &lt;code&gt;n&lt;/code&gt; /&lt;code&gt;N&lt;/code&gt; (and analogously for BITS==64). See &lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt; for details.</source>
          <target state="translated">如果BITS为16或更大，则将输入字符串的字节分组为大小为BITS / 8的块，然后将每个组转换为数字，如pack（）/ unpack（）那样，使用大尾数格式 &lt;code&gt;n&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; （并且类似地）对于BITS == 64）。有关详细信息，请参见&lt;a href=&quot;pack&quot;&gt;包装&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eafc581ec466397a85b26357c350bc4ac6773df9" translate="yes" xml:space="preserve">
          <source>If BITS is 8, &quot;elements&quot; coincide with bytes of the input string.</source>
          <target state="translated">如果BITS为8,则 &quot;元素 &quot;与输入字符串的字节重合。</target>
        </trans-unit>
        <trans-unit id="1e3d642ff4115aae3b45ab10f3f174f7b8799465" translate="yes" xml:space="preserve">
          <source>If BUILD_REQUIRES is not empty, it will be dumped as $BUILD_REQUIRES hashref.</source>
          <target state="translated">如果BUILD_REQUIRES不是空的,它将被转储为$BUILD_REQUIRES hashref。</target>
        </trans-unit>
        <trans-unit id="2f52aed81a4b81abc4bfb5eb234cabe8285fe520" translate="yes" xml:space="preserve">
          <source>If CHLD_IN begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; , then CHLD_IN will be closed in the parent, and the child will read from it directly. If CHLD_OUT or CHLD_ERR begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that filehandle. In both cases, there will be a dup(2) instead of a pipe(2) made.</source>
          <target state="translated">如果CHLD_IN以 &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; 开头，则在父级中将关闭CHLD_IN，而子级将直接从中读取。如果CHLD_OUT或CHLD_ERR以 &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; 开头，则子代将直接将输出发送到该文件句柄。在这两种情况下，都将使用dup（2）而不是使用pipe（2）。</target>
        </trans-unit>
        <trans-unit id="7212fe99a84e995b8956769eedd21cc0b4318074" translate="yes" xml:space="preserve">
          <source>If Configure detects &lt;code&gt;mmap()&lt;/code&gt; functions this layer is provided (with &quot;perlio&quot; as a &quot;base&quot;) which does &quot;read&quot; operations by mmap()ing the file. Performance improvement is marginal on modern systems, so it is mainly there as a proof of concept. It is likely to be unbundled from the core at some point. The &quot;mmap&quot; layer is a reasonable model for a minimalist &quot;derived&quot; layer.</source>
          <target state="translated">如果Configure检测到 &lt;code&gt;mmap()&lt;/code&gt; 函数，则提供该层（以&amp;ldquo; perlio&amp;rdquo;作为&amp;ldquo;基础&amp;rdquo;），该层通过mmap（）处理文件来&amp;ldquo;读取&amp;rdquo;操作。在现代系统上，性能改进是微不足道的，因此主要是作为概念证明。在某个时候，它可能会从核心中解开。&amp;ldquo; mmap&amp;rdquo;层是极简&amp;ldquo;派生&amp;rdquo;层的合理模型。</target>
        </trans-unit>
        <trans-unit id="47e49834bb6e6d998b14887fad543f4fe5a1147b" translate="yes" xml:space="preserve">
          <source>If Configure detects this system has a signbit() that will work with our NVs, then we just use it via the #define in perl.h. Otherwise, fall back on this implementation. The main use of this function is catching -0.0.</source>
          <target state="translated">如果Configure检测到这个系统有一个可以和我们的NV一起工作的signbit(),那么我们只要通过perl.h中的#define来使用它。否则,就回落到这个实现上。这个函数的主要用途是捕捉-0.0。</target>
        </trans-unit>
        <trans-unit id="14abe49a0e4ae66bc9fb22dcac00158a0e0ddd4d" translate="yes" xml:space="preserve">
          <source>If D calls an autoloaded method 'foo' which is defined in class A, then the method is loaded into class A, then executed. If C then calls method 'foo', and that method was reimplemented in class B, but set to be autoloaded, then the lookup mechanism never gets to the AUTOLOAD mechanism in B because it first finds the method already loaded in A, and so erroneously uses that. If the method foo had been stubbed in B, then the lookup mechanism would have found the stub, and correctly loaded and used the sub from B.</source>
          <target state="translated">如果D调用一个在类A中定义的自动加载的方法'foo',那么该方法被加载到类A中,然后执行。如果C接着调用方法'foo',而该方法在类B中被重新实现,但被设置为自动加载,那么查找机制永远不会进入B中的AUTOLOAD机制,因为它首先发现A中已经加载的方法,所以错误地使用该方法。如果方法foo在B中被存根,那么查找机制就会找到存根,并正确加载和使用B中的子。</target>
        </trans-unit>
        <trans-unit id="91710ed7923201057d536dad32d2aa3d9a3bd35e" translate="yes" xml:space="preserve">
          <source>If DUCET is not installed, it is recommended to copy the file from &lt;a href=&quot;http://www.unicode.org/Public/UCA/latest/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/latest/allkeys.txt&lt;/a&gt; to &amp;lt;a place in @INC&amp;gt;/Unicode/Collate/allkeys.txt manually.</source>
          <target state="translated">如果未安装DUCET，建议手动将文件从&lt;a href=&quot;http://www.unicode.org/Public/UCA/latest/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/latest/allkeys.txt&lt;/a&gt;复制到&amp;lt;INC中的位置&amp;gt; /Unicode/Collat​​e/allkeys.txt 。</target>
        </trans-unit>
        <trans-unit id="63ee7188cb79ae72f03905ea0c72ed0cf711430e" translate="yes" xml:space="preserve">
          <source>If EVENT_MASK is given, then, if EVENT_MASK is non-zero, IO is added to the list of file descriptors and the next call to poll will check for any event specified in EVENT_MASK. If EVENT_MASK is zero then IO will be removed from the list of file descriptors.</source>
          <target state="translated">如果给定了EVENT_MASK,那么,如果EVENT_MASK为非零,IO将被添加到文件描述符列表中,下一次调用poll将检查EVENT_MASK中指定的任何事件。如果EVENT_MASK为零,那么IO将从文件描述符列表中删除。</target>
        </trans-unit>
        <trans-unit id="bd3d21a82a01626375b0a1ef9fd969a22666fce2" translate="yes" xml:space="preserve">
          <source>If EVENT_MASK is not given then the return value will be the current event mask value for IO.</source>
          <target state="translated">如果没有给出EVENT_MASK,那么返回值将是IO的当前事件掩码值。</target>
        </trans-unit>
        <trans-unit id="24c1cc8102964c640118dc422f140e282d6a071d" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; or &lt;code&gt;EXPR1 &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; EXPR2&lt;/code&gt; , the test is applied</source>
          <target state="translated">如果EXPR为 &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; 或 &lt;code&gt;EXPR1 &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; EXPR2&lt;/code&gt; ，则应用测试</target>
        </trans-unit>
        <trans-unit id="34b0086c490eacc160b851838628c17c1a42195c" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt; , &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; , or &lt;code&gt;EXPR1 &lt;a href=&quot;functions/or&quot;&gt;or&lt;/a&gt; EXPR2&lt;/code&gt; , the test is applied</source>
          <target state="translated">如果EXPR为 &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt; ， &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 或 &lt;code&gt;EXPR1 &lt;a href=&quot;functions/or&quot;&gt;or&lt;/a&gt; EXPR2&lt;/code&gt; ，将应用测试</target>
        </trans-unit>
        <trans-unit id="204a0454b1de60634e71646d68fb30fb2441fd3c" translate="yes" xml:space="preserve">
          <source>If EXPR is a bareword, the require assumes a &quot;</source>
          <target state="translated">如果EXPR是一个裸词,那么require就假定是一个&quot;</target>
        </trans-unit>
        <trans-unit id="9736cd87f1cff71e99f8827cbdbed7d4bb55c258" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; uses the current time (as returned by time(3)).</source>
          <target state="translated">如果省略EXPR，则 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 使用当前时间（由time（3）返回）。</target>
        </trans-unit>
        <trans-unit id="6546ecbea2a684b1dddb3701f62d17cc4c008989" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; uses the current time (as returned by time(3)).</source>
          <target state="translated">如果省略EXPR，则 &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 使用当前时间（由time（3）返回）。</target>
        </trans-unit>
        <trans-unit id="cc0b8d50332776e14a75cf158fdbe3c24ae9c657" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, stats &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">如果省略EXPR，则统计 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="456f6be70dd618e1ee3287e7f4f8da001e29c2cb" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, unpacks the &lt;code&gt;$_&lt;/code&gt; string. See &lt;a href=&quot;../perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; for an introduction to this function.</source>
          <target state="translated">如果省略EXPR，则将 &lt;code&gt;$_&lt;/code&gt; 字符串解压缩。有关此功能的介绍，请参见&lt;a href=&quot;../perlpacktut&quot;&gt;perlpacktut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b61a1720b65aee85f5ca14d3364f5d86fb223f23" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, unpacks the &lt;code&gt;$_&lt;/code&gt; string. See &lt;a href=&quot;perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; for an introduction to this function.</source>
          <target state="translated">如果省略EXPR，则将 &lt;code&gt;$_&lt;/code&gt; 字符串解压缩。有关此功能的介绍，请参见&lt;a href=&quot;perlpacktut&quot;&gt;perlpacktut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d36eccdc92b1d6936c118cc354859012973685d8" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">如果省略EXPR，则使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1172cb3a4a7f1f2dfc6dcf55076a98d031996813" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; . To go the other way (produce a number in octal), use sprintf() or printf():</source>
          <target state="translated">如果省略EXPR，则使用 &lt;code&gt;$_&lt;/code&gt; 。反之（使用八进制产生数字），请使用sprintf（）或printf（）：</target>
        </trans-unit>
        <trans-unit id="488f2cec4909ee80d1ac152c113a7f5b407ac400" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is an undefined scalar variable (or array or hash element), a new filehandle is autovivified, meaning that the variable is assigned a reference to a newly allocated anonymous filehandle. Otherwise if FILEHANDLE is an expression, its value is the real filehandle. (This is considered a symbolic reference, so &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; should</source>
          <target state="translated">如果FILEHANDLE是未定义的标量变量（或数组或哈希元素），则会自动生成新的文件句柄，这意味着该变量被分配了对新分配的匿名文件句柄的引用。否则，如果FILEHANDLE是一个表达式，则其值为真实的文件句柄。（这被认为是象征性的参考，所以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; 应该</target>
        </trans-unit>
        <trans-unit id="7bf316535c25573b5c20cc7acfbdffbec7d384a1" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is an undefined scalar variable (or array or hash element), a new filehandle is autovivified, meaning that the variable is assigned a reference to a newly allocated anonymous filehandle. Otherwise if FILEHANDLE is an expression, its value is the real filehandle. (This is considered a symbolic reference, so &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; should</source>
          <target state="translated">如果FILEHANDLE是未定义的标量变量（或数组或哈希元素），则会自动生成新的文件句柄，这意味着该变量被分配了对新分配的匿名文件句柄的引用。否则，如果FILEHANDLE是一个表达式，则其值为真实的文件句柄。（这被认为是象征性的参考，所以 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; 应该</target>
        </trans-unit>
        <trans-unit id="7edd9359c1108403094d8175c9c20835e326b96f" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is unspecified, output goes to the current default output channel, which starts out as STDOUT but may be changed by the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; operator. If the FILEHANDLE is an EXPR, then the expression is evaluated and the resulting string is used to look up the name of the FILEHANDLE at run time. For more on formats, see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">如果未指定FILEHANDLE，输出将转到当前的默认输出通道，该通道以STDOUT开头，但可以由 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 运算符更改。如果FILEHANDLE是EXPR，则将对表达式求值，并使用所得字符串在运行时查找FILEHANDLE的名称。有关格式的更多信息，请参见&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64a3c2a915faecffdca2e95dc4489ca8da06212f" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is unspecified, output goes to the current default output channel, which starts out as STDOUT but may be changed by the &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; operator. If the FILEHANDLE is an EXPR, then the expression is evaluated and the resulting string is used to look up the name of the FILEHANDLE at run time. For more on formats, see &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">如果未指定FILEHANDLE，输出将转到当前的默认输出通道，该通道以STDOUT开头，但可以由 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 运算符更改。如果FILEHANDLE是EXPR，则将对表达式求值，并使用所得字符串在运行时查找FILEHANDLE的名称。有关格式的更多信息，请参见&lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42bee98ad679afc0b47a6a37b45d0b7a351045fa" translate="yes" xml:space="preserve">
          <source>If FUNCTION is a string starting with &lt;code&gt;CORE::&lt;/code&gt; , the rest is taken as a name for a Perl builtin. If the builtin's arguments cannot be adequately expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;), prototype() returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, because the builtin does not really behave like a Perl function. Otherwise, the string describing the equivalent prototype is returned.</source>
          <target state="translated">如果FUNCTION是以 &lt;code&gt;CORE::&lt;/code&gt; 开头的字符串，则其余部分将作为Perl内置函数的名称。如果原型（例如 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ）无法充分表达内置参数，则prototype（）返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因为内置函数的行为实际上不像Perl函数。否则，返回描述等效原型的字符串。</target>
        </trans-unit>
        <trans-unit id="cae550505561d57b299b4a003dc8830ba8e1ee71" translate="yes" xml:space="preserve">
          <source>If FUNCTION is a string starting with &lt;code&gt;CORE::&lt;/code&gt; , the rest is taken as a name for a Perl builtin. If the builtin's arguments cannot be adequately expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;), prototype() returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, because the builtin does not really behave like a Perl function. Otherwise, the string describing the equivalent prototype is returned.</source>
          <target state="translated">如果FUNCTION是以 &lt;code&gt;CORE::&lt;/code&gt; 开头的字符串，则其余部分将作为Perl内置函数的名称。如果原型（例如 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ）无法充分表达内置参数，则prototype（）返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因为内置函数的行为实际上不像Perl函数。否则，返回描述等效原型的字符串。</target>
        </trans-unit>
        <trans-unit id="cc31873f684622a14f7af2ea2005b39a1781e830" translate="yes" xml:space="preserve">
          <source>If G_ARRAY is specified</source>
          <target state="translated">如果指定了G_ARRAY</target>
        </trans-unit>
        <trans-unit id="abc56a2d0a54c75c4dee47cdfefa046b0f36c198" translate="yes" xml:space="preserve">
          <source>If G_DISCARD is specified, the return value will always be 0.</source>
          <target state="translated">如果指定了G_DISCARD,则返回值将始终为0。</target>
        </trans-unit>
        <trans-unit id="61b15d293eca2c7db4238b66ac8714ddc363a1b1" translate="yes" xml:space="preserve">
          <source>If G_SCALAR is specified</source>
          <target state="translated">如果指定了G_SCALAR</target>
        </trans-unit>
        <trans-unit id="bd626ea4da9803c896a3f690bf6350bffa4a5047" translate="yes" xml:space="preserve">
          <source>If I don't see that &quot;Perl:&quot;, it's not from perl.</source>
          <target state="translated">如果我没有看到那个 &quot;Perl:&quot;,那就不是来自perl。</target>
        </trans-unit>
        <trans-unit id="7f881d9fe9fd9028d68d11b8271492af01bf7e3c" translate="yes" xml:space="preserve">
          <source>If ID is omitted, it defaults to &lt;code&gt;1&lt;/code&gt; . If a single character is given for ID, the numeric value of that character is used.</source>
          <target state="translated">如果省略ID，则默认为 &lt;code&gt;1&lt;/code&gt; 。如果为ID指定单个字符，则使用该字符的数字值。</target>
        </trans-unit>
        <trans-unit id="b781e9bc0c2157f6dabdbd2804f21e2dc4d3a773" translate="yes" xml:space="preserve">
          <source>If KEY starts and ends with a slash, the string in between is treated as a regular expression and only keys matching this regexp are displayed</source>
          <target state="translated">如果KEY以斜杠开头和结尾,则中间的字符串将被视为正则表达式,并且只显示与此regexp匹配的键。</target>
        </trans-unit>
        <trans-unit id="97bf7fa576e4d2080ce6127c0f4cd5a7adce4cf1" translate="yes" xml:space="preserve">
          <source>If LAYER is omitted or specified as &lt;code&gt;:raw&lt;/code&gt; the filehandle is made suitable for passing binary data. This includes turning off possible CRLF translation and marking it as bytes (as opposed to Unicode characters). Note that, despite what may be implied in</source>
          <target state="translated">如果省略LAYER或将其指定为 &lt;code&gt;:raw&lt;/code&gt; ,则文件句柄适合于传递二进制数据。这包括关闭可能的CRLF转换并将其标记为字节（与Unicode字符相对）。请注意，尽管可能暗示</target>
        </trans-unit>
        <trans-unit id="283b8c8f4ffd49cdc5f923f3f2b2ef054e93376f" translate="yes" xml:space="preserve">
          <source>If LAYER is present it is a single string, but may contain multiple directives. The directives alter the behaviour of the filehandle. When LAYER is present, using binmode on a text file makes sense.</source>
          <target state="translated">如果LAYER存在,它是一个单一的字符串,但可能包含多个指令。这些指令会改变文件柄的行为。当LAYER存在时,在文本文件上使用binmode是有意义的。</target>
        </trans-unit>
        <trans-unit id="bc78056370f87ab6c8598a43f74f4b98bd9074c2" translate="yes" xml:space="preserve">
          <source>If LIMIT is negative, it is treated as if it were instead arbitrarily large; as many fields as possible are produced.</source>
          <target state="translated">如果LIMIT为负值,它将被当作任意大的字段来处理;产生尽可能多的字段。</target>
        </trans-unit>
        <trans-unit id="0394dbfeda7095aa516dcefff51b8b66aab7006b" translate="yes" xml:space="preserve">
          <source>If LIMIT is omitted (or, equivalently, zero), then it is usually treated as if it were instead negative but with the exception that trailing empty fields are stripped (empty leading fields are always preserved); if all fields are empty, then all fields are considered to be trailing (and are thus stripped in this case). Thus, the following:</source>
          <target state="translated">如果LIMIT被省略(或者,等价于零),那么它通常被当作负值处理,但例外的是,尾部的空字段会被剥离(空的前导字段总是被保留);如果所有字段都是空的,那么所有字段都被认为是尾部的(因此在这种情况下会被剥离)。因此,以下是:</target>
        </trans-unit>
        <trans-unit id="ec1ca6d6c3c8c30d74e46da0d1f8dfee1a937ce1" translate="yes" xml:space="preserve">
          <source>If LIMIT is specified and positive, it represents the maximum number of fields into which the EXPR may be split; in other words, LIMIT is one greater than the maximum number of times EXPR may be split. Thus, the LIMIT value &lt;code&gt;1&lt;/code&gt; means that EXPR may be split a maximum of zero times, producing a maximum of one field (namely, the entire value of EXPR). For instance:</source>
          <target state="translated">如果指定LIMIT并且为正，则表示EXPR可拆分为的最大字段数；换句话说，LIMIT比EXPR可以分割的最大次数大一个。因此，LIMIT值 &lt;code&gt;1&lt;/code&gt; 意味着EXPR最多可被拆分零次，从而最多生成一个字段（即EXPR的整个值）。例如：</target>
        </trans-unit>
        <trans-unit id="a1e79f492508e7edc8814a0c2f8fb560a886956d" translate="yes" xml:space="preserve">
          <source>If LIST consists of the empty string, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; spawns an interactive DCL subprocess, in the same fashion as typing &lt;b&gt;SPAWN&lt;/b&gt; at the DCL prompt.</source>
          <target state="translated">如果LIST由空字符串组成，则 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 生成交互式DCL子&lt;b&gt;进程&lt;/b&gt;，其方式与在DCL提示符下键入&lt;b&gt;SPAWN&lt;/b&gt;相同。</target>
        </trans-unit>
        <trans-unit id="8af421f1352b89476d8e2fb680c100c5c55fb16a" translate="yes" xml:space="preserve">
          <source>If LIST is omitted, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">如果省略LIST，则 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15ba1dd13707a281770468c5a2f35927f1cf24ea" translate="yes" xml:space="preserve">
          <source>If LIST is omitted, &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">如果省略LIST，则 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8725f581ae126bd53637cc6004bb31b10e046db" translate="yes" xml:space="preserve">
          <source>If Mac::Files could not be loaded, the empty string is returned.</source>
          <target state="translated">如果Mac::Files不能被加载,则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="9556835597cabed412f1a27672edf9d6d8a5a68b" translate="yes" xml:space="preserve">
          <source>If N is &amp;gt; 0, rounds to the Nth digit from the left. If N &amp;lt; 0, rounds to the Nth digit after the dot. Since BigInts are integers, the case N &amp;lt; 0 is a no-op for them.</source>
          <target state="translated">如果N&amp;gt; 0，则从左舍入到第N个数字。如果N &amp;lt;0，则四舍五入到点后的第N位。由于BigInts是整数，因此N &amp;lt;0的情况对它们而言是空操作。</target>
        </trans-unit>
        <trans-unit id="809aa45c402e18c1090663e0bbd2fdac630054bb" translate="yes" xml:space="preserve">
          <source>If NUMBER is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">如果省略NUMBER，则使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e18ed7b6aa1dfe2acf7667704a25f494c6c53b1" translate="yes" xml:space="preserve">
          <source>If OFFSET and LENGTH specify a substring that is partly outside the string, only the part within the string is returned. If the substring is beyond either end of the string, substr() returns the undefined value and produces a warning. When used as an lvalue, specifying a substring that is entirely outside the string raises an exception. Here's an example showing the behavior for boundary cases:</source>
          <target state="translated">如果OFFSET和LENGTH指定的子串有一部分在字符串之外,那么只返回字符串内的部分。如果子串超出了字符串的任何一端,substr()将返回未定义的值并产生一个警告。当作为一个l值使用时,指定一个完全在字符串之外的子串会引发一个异常。这里有一个例子显示了边界情况下的行为。</target>
        </trans-unit>
        <trans-unit id="805a2c8a87b8f6b59ee6ee34433c46d30a4b7687" translate="yes" xml:space="preserve">
          <source>If PATTERN is &lt;code&gt;/^/&lt;/code&gt; , then it is treated as if it used the &lt;a href=&quot;../perlreref#OPERATORS&quot;&gt;multiline modifier&lt;/a&gt; (&lt;code&gt;/^/m&lt;/code&gt; ), since it isn't much use otherwise.</source>
          <target state="translated">如果PATTERN是 &lt;code&gt;/^/&lt;/code&gt; ，则将其视为使用了&lt;a href=&quot;../perlreref#OPERATORS&quot;&gt;多行修饰符&lt;/a&gt;（ &lt;code&gt;/^/m&lt;/code&gt; ），因为在其他情况下它并没有太多用处。</target>
        </trans-unit>
        <trans-unit id="f31e710fa5dc3bb0149beaea0c04322fd5b027e6" translate="yes" xml:space="preserve">
          <source>If PATTERN is &lt;code&gt;/^/&lt;/code&gt; , then it is treated as if it used the &lt;a href=&quot;perlreref#OPERATORS&quot;&gt;multiline modifier&lt;/a&gt; (&lt;code&gt;/^/m&lt;/code&gt; ), since it isn't much use otherwise.</source>
          <target state="translated">如果PATTERN是 &lt;code&gt;/^/&lt;/code&gt; ，则将其视为使用了&lt;a href=&quot;perlreref#OPERATORS&quot;&gt;多行修饰符&lt;/a&gt;（ &lt;code&gt;/^/m&lt;/code&gt; ），因为在其他情况下它并没有太多用处。</target>
        </trans-unit>
        <trans-unit id="8ab2206e4a8b71981bc3526b21e6f961d2fc978f" translate="yes" xml:space="preserve">
          <source>If PATTERN matches the empty string, the EXPR is split at the match position (between characters). As an example, the following:</source>
          <target state="translated">如果PATTERN与空字符串匹配,则EXPR在匹配位置(字符之间)被分割。举个例子,如下。</target>
        </trans-unit>
        <trans-unit id="d1b7e2477c70af9a1ce418a622d9557a0b72af87" translate="yes" xml:space="preserve">
          <source>If PERL5LIB is not defined, PERLLIB is used. Directories are separated (like in PATH) by a colon on Unixish platforms and by a semicolon on Windows (the proper path separator being given by the command &lt;code&gt;perl
-V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt;).</source>
          <target state="translated">如果未定义PERL5LIB，则使用PERLLIB。目录由Unixish平台上的冒号和Windows上的分号分隔（如PATH中的路径）（适当的路径分隔符由命令 &lt;code&gt;perl -V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e3cb4284864a564ca2b51274a4f3fa62dd73a592" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_ALL is set then all input chars will be output using &lt;code&gt;\x01F1&lt;/code&gt; style escapes, otherwise if PERL_PV_ESCAPE_NONASCII is set, only non-ASCII chars will be escaped using this style; otherwise, only chars above 255 will be so escaped; other non printable chars will use octal or common escaped patterns like &lt;code&gt;\n&lt;/code&gt; . Otherwise, if PERL_PV_ESCAPE_NOBACKSLASH then all chars below 255 will be treated as printable and will be output as literals.</source>
          <target state="translated">如果设置了PERL_PV_ESCAPE_ALL，则将使用 &lt;code&gt;\x01F1&lt;/code&gt; 样式转义符输出所有输入字符，否则，如果设置了PERL_PV_ESCAPE_NONASCII，将仅使用此样式转义非ASCII字符；否则，只有255以上的字符会被转义；其他不可打印的字符将使用八进制或常见的转义模式，例如 &lt;code&gt;\n&lt;/code&gt; 。否则，如果PERL_PV_ESCAPE_NOBACKSLASH，则所有低于255的字符都将被视为可打印，并将其输出为文字。</target>
        </trans-unit>
        <trans-unit id="03a5b31adb12c35d2862c64e653c8076e4f81a1b" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_FIRSTCHAR is set then only the first char of the string will be escaped, regardless of max. If the output is to be in hex, then it will be returned as a plain hex sequence. Thus the output will either be a single char, an octal escape sequence, a special escape like &lt;code&gt;\n&lt;/code&gt; or a hex value.</source>
          <target state="translated">如果设置了PERL_PV_ESCAPE_FIRSTCHAR，则无论最大字符数如何，仅字符串的第一个字符都将被转义。如果输出为十六进制，则将其作为普通十六进制序列返回。因此输出将是单个字符，八进制转义序列，特殊转义（如 &lt;code&gt;\n&lt;/code&gt; 或十六进制值）。</target>
        </trans-unit>
        <trans-unit id="4fd0e08a5001bbfc2db16575c706877131f99c11" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_RE is set then the escape char used will be a '%' and not a '\\'. This is because regexes very often contain backslashed sequences, whereas '%' is not a particularly common character in patterns.</source>
          <target state="translated">如果PERL_PV_ESCAPE_RE被设置,那么使用的转义字符将是'%'而不是'\\'。这是因为regexes经常包含反斜线序列,而'%'在模式中不是一个特别常见的字符。</target>
        </trans-unit>
        <trans-unit id="c327fff20e1a2d0d479391141282091e826a55c6" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_UNI is set then the input string is treated as UTF-8 if PERL_PV_ESCAPE_UNI_DETECT is set then the input string is scanned using &lt;code&gt;is_utf8_string()&lt;/code&gt; to determine if it is UTF-8.</source>
          <target state="translated">如果设置了PERL_PV_ESCAPE_UNI，则将输入字符串视为UTF-8；如果设置了PERL_PV_ESCAPE_UNI_DETECT，则将使用 &lt;code&gt;is_utf8_string()&lt;/code&gt; 扫描输入字符串，以确定其是否为UTF-8。</target>
        </trans-unit>
        <trans-unit id="19515a44b91c296bde08fb195c3206ce5ee06393" translate="yes" xml:space="preserve">
          <source>If PID is a subprocess started by a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;), &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; will wait for that subprocess, and return its final status value in &lt;code&gt;$?&lt;/code&gt; . If PID is a subprocess created in some other way (e.g. SPAWNed before Perl was invoked), &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; will simply check once per second whether the process has completed, and return when it has. (If PID specifies a process that isn't a subprocess of the current process, and you invoked Perl with the &lt;code&gt;-w&lt;/code&gt; switch, a warning will be issued.)</source>
          <target state="translated">如果PID是由管道 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 启动的子过程（请参见&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;），则 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 将等待该子过程，并以 &lt;code&gt;$?&lt;/code&gt; 返回其最终状态值。。如果PID是以其他方式创建的子进程（例如，在调用Perl之前被SPAWNed），则 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 将仅每秒检查一次该进程是否已完成，并在完成时返回。（如果PID指定的进程不是当前进程的子进程，并且您使用 &lt;code&gt;-w&lt;/code&gt; 开关调用了Perl，则会发出警告。）</target>
        </trans-unit>
        <trans-unit id="2833d231deee2ce7c48c3ef06baaabad2e5a0de9" translate="yes" xml:space="preserve">
          <source>If PPCODE: directive is not used, &lt;code&gt;void&lt;/code&gt; return value should be used only for subroutines which do not return a value,</source>
          <target state="translated">如果未使用PPCODE：指令，则 &lt;code&gt;void&lt;/code&gt; 返回值应仅用于不返回值的子例程，</target>
        </trans-unit>
        <trans-unit id="c393beed824f2acf513d9860e129eb5ffe2baeec" translate="yes" xml:space="preserve">
          <source>If PadnameOUTER is set on the pad name, then that slot in the frame AV is a REFCNT'ed reference to a lexical from &quot;outside&quot;. Such entries are sometimes referred to as 'fake'. In this case, the name does not use 'low' and 'high' to store a cop_seq range, since it is in scope throughout. Instead 'high' stores some flags containing info about the real lexical (is it declared in an anon, and is it capable of being instantiated multiple times?), and for fake ANONs, 'low' contains the index within the parent's pad where the lexical's value is stored, to make cloning quicker.</source>
          <target state="translated">如果PadnameOUTER被设置在垫名上,那么框架AV中的那个槽就是一个来自 &quot;外部 &quot;的词条的REFCNT'ed引用。这种条目有时被称为'假'。在这种情况下,名字没有使用'low'和'high'来存储cop_seq范围,因为它在整个范围内。相反,'high'存储了一些包含真实词库信息的标志(它是否在anon中声明,是否能够被多次实例化?),对于假的anon,'low'包含了父代pad内的索引,在那里存储了词库的值,以使克隆更快。</target>
        </trans-unit>
        <trans-unit id="40be3d27de878e5185ba9875f176a67d8334894d" translate="yes" xml:space="preserve">
          <source>If Perl cannot find the method in any of these classes, it will die with an error message.</source>
          <target state="translated">如果Perl找不到这些类中的任何一个方法,它就会以错误信息死亡。</target>
        </trans-unit>
        <trans-unit id="3a89c2d4d03a490ab54c26429553ad753f25a36f" translate="yes" xml:space="preserve">
          <source>If Perl finds that the found executable is of PM type when the current session is not, it will start the new process in a separate session of necessary type. Call via &lt;code&gt;OS2::Process&lt;/code&gt; to disable this magic.</source>
          <target state="translated">如果Perl在当前会话不在时发现找到的可执行文件是PM类型，它将在必要类型的单独会话中启动新进程。通过 &lt;code&gt;OS2::Process&lt;/code&gt; 调用以禁用此魔术。</target>
        </trans-unit>
        <trans-unit id="289a7b0542dd20aefdd9191d5f173083a238571f" translate="yes" xml:space="preserve">
          <source>If Perl has been compiled using Perl's malloc you can analyze Perl memory usage by setting $ENV{PERL_DEBUG_MSTATS}.</source>
          <target state="translated">如果Perl是使用Perl的malloc编译的,你可以通过设置$ENV{PERL_DEBUG_MSTATS}来分析Perl的内存使用情况。</target>
        </trans-unit>
        <trans-unit id="230e2bfc79d0ba462c1beaf813fc67b45a5f8378" translate="yes" xml:space="preserve">
          <source>If Perl is not built to use PerlIO as its IO system then only the two pseudo-layers &lt;code&gt;:bytes&lt;/code&gt; and &lt;code&gt;:crlf&lt;/code&gt; are available.</source>
          <target state="translated">如果未构建Perl来使用PerlIO作为其IO系统，则只有两个伪层 &lt;code&gt;:bytes&lt;/code&gt; 和 &lt;code&gt;:crlf&lt;/code&gt; 可用。</target>
        </trans-unit>
        <trans-unit id="6264d3e40b3079f00ff5fcba981797a472b669d0" translate="yes" xml:space="preserve">
          <source>If Perl was not built with socket support, the system call version of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; is not available at all. If socket support is present, then the system call version of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; functions only for file descriptors attached to sockets. It will not provide information about regular files or pipes, since the CRTL &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; routine does not provide this functionality.</source>
          <target state="translated">如果Perl不是由套接字支持构建的，则 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 的系统调用版本完全不可用。如果存在套接字支持，则 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 函数的系统调用版本仅适用于附加到套接字的文件描述符。它不会提供有关常规文件或管道的信息，因为CRTL &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 例程不提供此功能。</target>
        </trans-unit>
        <trans-unit id="f4a129f6da7edb3d3e9d992e64ee7ec5edc1382d" translate="yes" xml:space="preserve">
          <source>If Perldoc is running under MSWin and uses this class as a formatter, the output will be opened with</source>
          <target state="translated">如果Perldoc在MSWin下运行,并且使用这个类作为格式化器,那么输出将用以下方式打开</target>
        </trans-unit>
        <trans-unit id="48a7e7d61da87b6e49574cb96f576ab3af92a97c" translate="yes" xml:space="preserve">
          <source>If Pod::Man is given the &lt;code&gt;utf8&lt;/code&gt; option, the encoding of its output file handle will be forced to UTF-8 if possible, overriding any existing encoding. This will be done even if the file handle is not created by Pod::Man and was passed in from outside. This maintains consistency regardless of PERL_UNICODE and other settings.</source>
          <target state="translated">如果为Pod :: Man提供了 &lt;code&gt;utf8&lt;/code&gt; 选项，则在可能的情况下，其输出文件句柄的编码将被强制为UTF-8，从而覆盖任何现有编码。即使文件句柄不是由Pod :: Man创建的，也不是从外部传入的，也可以这样做。无论PERL_UNICODE和其他设置如何，都可以保持一致性。</target>
        </trans-unit>
        <trans-unit id="89e668a66a16049973d228d4291fce70e3c9695a" translate="yes" xml:space="preserve">
          <source>If Pod::Man is unavailable, this function will warn and return undef.</source>
          <target state="translated">如果Pod::Man不可用,该函数将发出警告并返回undef。</target>
        </trans-unit>
        <trans-unit id="0b2424487d45dbfa5c1b518ecd9497b822e7398c" translate="yes" xml:space="preserve">
          <source>If Pod::Simple sends an event where the element name has a dash, period, or colon, the corresponding method name will have a underscore in its place. For example, &quot;foo.bar:baz&quot; becomes start_foo_bar_baz and end_foo_bar_baz.</source>
          <target state="translated">如果Pod::Simple发送的事件中元素名有破折号、句号或冒号,那么对应的方法名就会有一个下划线。例如,&quot;foo.bar:baz &quot;会变成start_foo_bar_baz和end_foo_bar_baz。</target>
        </trans-unit>
        <trans-unit id="9e0153ee2898f6429d842dbcd6c0696456ff28ca" translate="yes" xml:space="preserve">
          <source>If Pod::Text is given the &lt;code&gt;utf8&lt;/code&gt; option, the encoding of its output file handle will be forced to UTF-8 if possible, overriding any existing encoding. This will be done even if the file handle is not created by Pod::Text and was passed in from outside. This maintains consistency regardless of PERL_UNICODE and other settings.</source>
          <target state="translated">如果为Pod :: Text提供了 &lt;code&gt;utf8&lt;/code&gt; 选项，则如果可能的话，其输出文件句柄的编码将被强制为UTF-8，从而覆盖任何现有编码。即使文件句柄不是由Pod :: Text创建的，也不是从外部传入的，也可以这样做。无论PERL_UNICODE和其他设置如何，都可以保持一致性。</target>
        </trans-unit>
        <trans-unit id="a28c6ae29cd39f20d43e841a87f74f6e887bacb7" translate="yes" xml:space="preserve">
          <source>If RXf_WHITE is set in addition to this flag, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; will behave like &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; &quot; &quot;&lt;/code&gt; under the Perl engine.</source>
          <target state="translated">如果除了此标志之外还设置了RXf_WHITE，则在Perl引擎下， &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 的行为将类似于 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; &quot; &quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03dddb9eda0980e6158ca2dd506258dca11f657b" translate="yes" xml:space="preserve">
          <source>If SIGNAL is either the number 0 or the string &lt;code&gt;ZERO&lt;/code&gt; (or &lt;code&gt;SIGZERO&lt;/code&gt; ), no signal is sent to the process, but &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks whether it's</source>
          <target state="translated">如果SIGNAL是数字0或字符串 &lt;code&gt;ZERO&lt;/code&gt; （或 &lt;code&gt;SIGZERO&lt;/code&gt; ），则不会向该进程发送任何信号，但是 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 检查它是否为</target>
        </trans-unit>
        <trans-unit id="a487625a13afee57a95232e398ffaae21162742b" translate="yes" xml:space="preserve">
          <source>If SIGNAL is either the number 0 or the string &lt;code&gt;ZERO&lt;/code&gt; (or &lt;code&gt;SIGZERO&lt;/code&gt; ), no signal is sent to the process, but &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks whether it's</source>
          <target state="translated">如果SIGNAL是数字0或字符串 &lt;code&gt;ZERO&lt;/code&gt; （或 &lt;code&gt;SIGZERO&lt;/code&gt; ），则不会向该进程发送任何信号，但是 &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 检查它是否为</target>
        </trans-unit>
        <trans-unit id="34e4af5120e01452063bdba16ab4dbac8800d707" translate="yes" xml:space="preserve">
          <source>If SUBNAME or BLOCK is omitted, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;s in standard string comparison order. If SUBNAME is specified, it gives the name of a subroutine that returns an integer less than, equal to, or greater than &lt;code&gt;0&lt;/code&gt; , depending on how the elements of the list are to be ordered. (The &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators are extremely useful in such routines.) SUBNAME may be a scalar variable name (unsubscripted), in which case the value provides the name of (or a reference to) the actual subroutine to use. In place of a SUBNAME, you can provide a BLOCK as an anonymous, in-line sort subroutine.</source>
          <target state="translated">如果省略SUBNAME或BLOCK，则按标准字符串比较顺序 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; s进行排序。如果指定了SUBNAME，它将给出一个子例程的名称，该子例程将返回一个小于，等于或大于 &lt;code&gt;0&lt;/code&gt; 的整数，具体取决于列表元素的排序方式。 （ &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 和 &lt;code&gt;cmp&lt;/code&gt; 运算符在此类例程中非常有用。）SUBNAME可能是标量变量名称（未下标），在这种情况下，该值提供要使用的实际子例程的名称（或引用）。您可以提供一个BLOCK作为匿名的内联排序子例程来代替SUBNAME。</target>
        </trans-unit>
        <trans-unit id="6247155ef0e0949eed5f5b9ad662fcdc5e0b1a55" translate="yes" xml:space="preserve">
          <source>If SUBNAME or BLOCK is omitted, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;s in standard string comparison order. If SUBNAME is specified, it gives the name of a subroutine that returns an integer less than, equal to, or greater than &lt;code&gt;0&lt;/code&gt; , depending on how the elements of the list are to be ordered. (The &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators are extremely useful in such routines.) SUBNAME may be a scalar variable name (unsubscripted), in which case the value provides the name of (or a reference to) the actual subroutine to use. In place of a SUBNAME, you can provide a BLOCK as an anonymous, in-line sort subroutine.</source>
          <target state="translated">如果省略SUBNAME或BLOCK，则按标准字符串比较顺序 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; s进行排序。如果指定了SUBNAME，它将给出一个子例程的名称，该子例程将返回一个小于，等于或大于 &lt;code&gt;0&lt;/code&gt; 的整数，具体取决于列表元素的排序方式。 （ &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 和 &lt;code&gt;cmp&lt;/code&gt; 运算符在此类例程中非常有用。）SUBNAME可能是标量变量名称（未下标），在这种情况下，该值提供要使用的实际子例程的名称（或引用）。您可以提供一个BLOCK作为匿名的内联排序子例程来代替SUBNAME。</target>
        </trans-unit>
        <trans-unit id="3a13dff4a6a23dd2b6f1693ccf60f7a4736231a4" translate="yes" xml:space="preserve">
          <source>If TEMPLATE requires more arguments than pack() is given, pack() assumes additional &lt;code&gt;&quot;&quot;&lt;/code&gt; arguments. If TEMPLATE requires fewer arguments than given, extra arguments are ignored.</source>
          <target state="translated">如果TEMPLATE需要的参数多于给定的pack（），则pack（）会采用其他 &lt;code&gt;&quot;&quot;&lt;/code&gt; 参数。如果TEMPLATE需要的参数少于给定的参数，则多余的参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="71eeb63629102190a2491abe8e8c2cd018b18803" translate="yes" xml:space="preserve">
          <source>If Unix level &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;lseek&lt;/code&gt; is not appropriate for (say) sockets then the &quot;unix&quot; layer can be replaced (at open time or even dynamically) with a &quot;socket&quot; layer.</source>
          <target state="translated">如果Unix级别的 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;lseek&lt;/code&gt; 不适合（例如）套接字，则&amp;ldquo; unix&amp;rdquo;层可以用&amp;ldquo; socket&amp;rdquo;层替换（在开放时间甚至动态地）。</target>
        </trans-unit>
        <trans-unit id="adc19b00b38eb533e11534d089e59dc6d18d7552" translate="yes" xml:space="preserve">
          <source>If VARIABLE is a hash, it chomps the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">如果VARIABLE是散列，则它将剔除散列的值而不是其键，从而重置进程中的 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 迭代器。</target>
        </trans-unit>
        <trans-unit id="dafdb7a192ed4ebf56859ae04ece9ebbc7f84c1d" translate="yes" xml:space="preserve">
          <source>If VARIABLE is a hash, it chomps the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">如果VARIABLE是散列，则它将剔除散列的值而不是其键，从而重置进程中的 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 迭代器。</target>
        </trans-unit>
        <trans-unit id="a9c742cbb93e88b3095e1366a5e0ca8820689343" translate="yes" xml:space="preserve">
          <source>If VERSION is provided, &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; sets the &lt;code&gt;$VERSION&lt;/code&gt; variable in the given namespace to a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object with the VERSION provided. VERSION must be a &quot;strict&quot; style version number as defined by the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module: a positive decimal number (integer or decimal-fraction) without exponentiation or else a dotted-decimal v-string with a leading 'v' character and at least three components. You should set &lt;code&gt;$VERSION&lt;/code&gt; only once per package.</source>
          <target state="translated">如果提供了VERSION，则 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; &lt;code&gt;$VERSION&lt;/code&gt; 给定名称空间中的$ VERSION变量设置为具有VERSION的&lt;a href=&quot;version&quot;&gt;版本&lt;/a&gt;对象。VERSION必须是&lt;a href=&quot;version&quot;&gt;版本&lt;/a&gt;模块所定义的&amp;ldquo;严格&amp;rdquo;样式版本号：不带幂的十进制正数（整数或十进制小数），或者是带小数点后的v字符串（带有前导&amp;ldquo; v&amp;rdquo;字符和至少三个）组件。每个软件包只应设置一次 &lt;code&gt;$VERSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bfad8b6a5366a04a7526e534903361716196c11" translate="yes" xml:space="preserve">
          <source>If VERSION is provided, &lt;code&gt;&lt;a href=&quot;package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; sets the &lt;code&gt;$VERSION&lt;/code&gt; variable in the given namespace to a &lt;a href=&quot;../version&quot;&gt;version&lt;/a&gt; object with the VERSION provided. VERSION must be a &quot;strict&quot; style version number as defined by the &lt;a href=&quot;../version&quot;&gt;version&lt;/a&gt; module: a positive decimal number (integer or decimal-fraction) without exponentiation or else a dotted-decimal v-string with a leading 'v' character and at least three components. You should set &lt;code&gt;$VERSION&lt;/code&gt; only once per package.</source>
          <target state="translated">如果提供了VERSION，则 &lt;code&gt;&lt;a href=&quot;package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; &lt;code&gt;$VERSION&lt;/code&gt; 给定名称空间中的$ VERSION变量设置为具有VERSION的&lt;a href=&quot;../version&quot;&gt;版本&lt;/a&gt;对象。VERSION必须是&lt;a href=&quot;../version&quot;&gt;版本&lt;/a&gt;模块所定义的&amp;ldquo;严格&amp;rdquo;样式版本号：不带幂的十进制正数（整数或十进制小数），或者是带小数点后的v字符串（带有前导&amp;ldquo; v&amp;rdquo;字符和至少三个）组件。每个软件包只应设置一次 &lt;code&gt;$VERSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">如果一个</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
