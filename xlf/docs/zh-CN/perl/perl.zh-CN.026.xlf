<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="595fc50992e17250599953061722960b35607014" translate="yes" xml:space="preserve">
          <source>Anything put here will be passed to MY::postamble() if you have one.</source>
          <target state="translated">如果你有MY::postamble()的话,放在这里的任何东西都会被传递给它。</target>
        </trans-unit>
        <trans-unit id="eb489bfffc02c3f32a21cb7909eae48c47e3d9b4" translate="yes" xml:space="preserve">
          <source>Anything that follows &lt;code&gt;#&lt;/code&gt; is treated as a comment.</source>
          <target state="translated">下面任何 &lt;code&gt;#&lt;/code&gt; 被视为注释。</target>
        </trans-unit>
        <trans-unit id="aaea73d52ae0a47a220342d260ea4c54a027d322" translate="yes" xml:space="preserve">
          <source>Anything you can legally say in a spot where a &lt;b&gt;value&lt;/b&gt; is required. Typically composed of &lt;b&gt;literals&lt;/b&gt;, &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;operators&lt;/b&gt;, &lt;b&gt;functions&lt;/b&gt;, and &lt;b&gt;subroutine&lt;/b&gt; calls, not necessarily in that order.</source>
          <target state="translated">您可以在需要&lt;b&gt;值&lt;/b&gt;的地方合法地说出任何话。通常由&lt;b&gt;文字&lt;/b&gt;，&lt;b&gt;变量&lt;/b&gt;，&lt;b&gt;运算符&lt;/b&gt;，&lt;b&gt;函数&lt;/b&gt;和&lt;b&gt;子例程&lt;/b&gt;调用组成，不一定&lt;b&gt;按此&lt;/b&gt;顺序。</target>
        </trans-unit>
        <trans-unit id="90ac4d3777dbcf43ec0f981e70e6cb4230e6e6f9" translate="yes" xml:space="preserve">
          <source>Anyway, here it is. Should run on perl v4 or greater. Maybe less.</source>
          <target state="translated">总之,它在这里。应该在perl v4或更高版本上运行。也许更少。</target>
        </trans-unit>
        <trans-unit id="2e755b3358691db1161de932e3c7e74daf5374dd" translate="yes" xml:space="preserve">
          <source>Anyway, this is what you can do if you can't help yourself.</source>
          <target state="translated">不管怎么说,这是你情不自禁的时候可以做的。</target>
        </trans-unit>
        <trans-unit id="61fbeb450419f819d1d3fb527e61bbd77f1f245b" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a BLOCK returning a reference of the correct type. In other words, the previous examples could be written like this:</source>
          <target state="translated">在你把一个标识符(或标识符链)作为变量或子程序名称的一部分的地方,你可以用一个返回正确类型引用的BLOCK来替换标识符。换句话说,前面的例子可以这样写。</target>
        </trans-unit>
        <trans-unit id="c4897c70becad60eb583b067e9239c22c138553c" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a simple scalar variable containing a reference of the correct type:</source>
          <target state="translated">在你将标识符(或标识符链)作为变量或子程序名称的一部分的地方,你可以用一个包含正确类型引用的简单标量变量来替换标识符。</target>
        </trans-unit>
        <trans-unit id="1152548ba48e279bc989a0c42814e21456001922" translate="yes" xml:space="preserve">
          <source>Apache::GZip Revisited</source>
          <target state="translated">Apache::GZip重温</target>
        </trans-unit>
        <trans-unit id="eef8ccdc1b5028a7590e9e7eb6807d9775169439" translate="yes" xml:space="preserve">
          <source>Apart from being non-portable to some operating systems, this made it difficult to use &lt;code&gt;gzopen&lt;/code&gt; in situations where you wanted to extract/create a gzip data stream that is embedded in a larger file, without having to resort to opening and closing the file multiple times.</source>
          <target state="translated">除了无法移植到某些操作系统之外，这使得在您要提取/创建嵌入到较大文件中的gzip数据流而不必求助于打开和关闭多个文件的情况下，很难使用 &lt;code&gt;gzopen&lt;/code&gt; 次。</target>
        </trans-unit>
        <trans-unit id="4e3144b6ad1fe422c840b3431e9e995cf1a334a3" translate="yes" xml:space="preserve">
          <source>Apart from discussing the C interface provided by Perl for writing callbacks the document uses a series of examples to show how the interface actually works in practice. In addition some techniques for coding callbacks are covered.</source>
          <target state="translated">除了讨论Perl提供的用于编写回调的C语言接口外,本文还使用了一系列的例子来展示该接口在实践中是如何工作的。此外,本文还介绍了一些回调的编码技术。</target>
        </trans-unit>
        <trans-unit id="6c594049f559b0aa030aaa7fc2712868c419ba1f" translate="yes" xml:space="preserve">
          <source>Apart from now being a boolean, the &lt;code&gt;$^W&lt;/code&gt; variable operates in exactly the same horrible uncontrolled global way, except that it cannot disable/enable default warnings.</source>
          <target state="translated">除了现在是布尔值之外， &lt;code&gt;$^W&lt;/code&gt; 变量以完全相同的可怕的不受控制的全局方式运行，除了它不能禁用/启用默认警告。</target>
        </trans-unit>
        <trans-unit id="03dfbadf395083cbac3ebe537f5fd26158769beb" translate="yes" xml:space="preserve">
          <source>Apart from resetting the iterator, &lt;code&gt;values @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt;. (We recommend that you use void context &lt;code&gt;keys @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;values @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">除了重置迭代器外，列表上下文中的 &lt;code&gt;values @array&lt;/code&gt; 与普通 &lt;code&gt;@array&lt;/code&gt; 相同。（我们建议您为此使用无效的上下文 &lt;code&gt;keys @array&lt;/code&gt; ，但是推断出将 &lt;code&gt;values @array&lt;/code&gt; 取出来的值比留在其中需要更多的文档。）</target>
        </trans-unit>
        <trans-unit id="177ebac14cb8719946f6e7935d5609a89f70ecb3" translate="yes" xml:space="preserve">
          <source>Apart from the behavior described above, Perl does not expand multiple levels of interpolation. In particular, contrary to the expectations of shell programmers, back-quotes do</source>
          <target state="translated">除了上述行为外,Perl并没有展开多级插值。特别是,与shell程序员的期望相反,反引号并没有</target>
        </trans-unit>
        <trans-unit id="5e5b5fcfebfb49c5cb95c4adedad19fe315234ce" translate="yes" xml:space="preserve">
          <source>Apart from the first parameter, import can accept an optional list of parameters. These can be used to pass parameters to the filter. For example:</source>
          <target state="translated">除了第一个参数之外,import还可以接受一个可选的参数列表。这些参数可以用来向过滤器传递参数。例如</target>
        </trans-unit>
        <trans-unit id="ea290b2592c04a29efbf4275fbffd4e15c783ad7" translate="yes" xml:space="preserve">
          <source>Apart from the overstrike, it in all ways functions like Pod::Text. See &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">除了过度罢工，它在所有方面都类似于Pod :: Text。有关详细信息和可用选项，请参见&lt;a href=&quot;../text&quot;&gt;Pod :: Text&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da695cf6105edcb1a8b40d8d706c52df71f42750" translate="yes" xml:space="preserve">
          <source>Apart from the overstrike, it in all ways functions like Pod::Text. See &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">除了过度罢工，它在所有方面都类似于Pod :: Text。有关详细信息和可用选项，请参见&lt;a href=&quot;Pod::Text&quot;&gt;Pod :: Text&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9828a7d2d366fc4b8702a1f03e94b53802450369" translate="yes" xml:space="preserve">
          <source>Apollo Domain/OS</source>
          <target state="translated">Apollo Domain/OS</target>
        </trans-unit>
        <trans-unit id="29f771942800f2d67122e33798021164ef80e3a2" translate="yes" xml:space="preserve">
          <source>App::Cpan</source>
          <target state="translated">App::Cpan</target>
        </trans-unit>
        <trans-unit id="5d59978967734805e51a9980657b59fbf6558d9e" translate="yes" xml:space="preserve">
          <source>App::Cpan - easily interact with CPAN from the command line</source>
          <target state="translated">App::Cpan-通过命令行轻松地与CPAN进行交互。</target>
        </trans-unit>
        <trans-unit id="59fd50fcdac085cfabfc65f7db775038f8cecc31" translate="yes" xml:space="preserve">
          <source>App::Prove</source>
          <target state="translated">App::Prove</target>
        </trans-unit>
        <trans-unit id="3a1656ea85b06be3923d0763368c6414c09514c6" translate="yes" xml:space="preserve">
          <source>App::Prove - Implements the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove-实现 &lt;code&gt;prove&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="7174791288d36e70929f8c68ba39037f796046e4" translate="yes" xml:space="preserve">
          <source>App::Prove::State</source>
          <target state="translated">App::Prove::State</target>
        </trans-unit>
        <trans-unit id="39ce25b85982de5bdaced90b86fd5469adc9a51a" translate="yes" xml:space="preserve">
          <source>App::Prove::State - State storage for the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove :: State- &lt;code&gt;prove&lt;/code&gt; 命令的状态存储。</target>
        </trans-unit>
        <trans-unit id="96f79883bf2f299a489c18241a0f9c3ce22137d2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result</source>
          <target state="translated">App::Prove::State::Result</target>
        </trans-unit>
        <trans-unit id="604c79e231e51591da6ce53e73549980b6c066b2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result - Individual test suite results.</source>
          <target state="translated">App::Prove::State::Result-单个测试套件的结果。</target>
        </trans-unit>
        <trans-unit id="83a53d94c22845a17e42b81ff706d21b9d9578b9" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test</source>
          <target state="translated">App::Prove::State::Result::Test</target>
        </trans-unit>
        <trans-unit id="dcd1440850fc9e2913d7cf105103afc698a85230" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test - Individual test results.</source>
          <target state="translated">App::Prove::State::Result::Test-单个测试结果。</target>
        </trans-unit>
        <trans-unit id="a04f6596455dd68a60a8ad9f2a7176ca7fb0ee44" translate="yes" xml:space="preserve">
          <source>Apparently, IBM used a compiler (for some period of time around '95?) which changes FP mask right and left. This is not</source>
          <target state="translated">显然,IBM使用的编译器(95年左右的一段时间?)会左右改变FP掩码。这不是</target>
        </trans-unit>
        <trans-unit id="3c4496c4495e5c99d047e29d461a211122789431" translate="yes" xml:space="preserve">
          <source>Appeal to their self interest! If Perl is new (and thus scary) to them, find something that Perl can do to solve one of their problems. That might mean that Perl either saves them something (time, headaches, money) or gives them something (flexibility, power, testability).</source>
          <target state="translated">吸引他们的自身利益! 如果Perl对他们来说是新的(因此也是可怕的),那么就找一些Perl可以解决他们的问题。这可能意味着Perl要么为他们节省了一些东西(时间、头痛、金钱),要么给了他们一些东西(灵活性、功能强大、可测试性)。</target>
        </trans-unit>
        <trans-unit id="7820ab67805cf1ba0f215418474bf3c391c0a394" translate="yes" xml:space="preserve">
          <source>Appearances can be deceptive, especially when it comes to emptiness. If you are scratching your head trying to work out why Test::Tester is saying that your diagnostics are wrong when they look perfectly right then the answer is probably whitespace. From version 0.10 on, Test::Tester surrounds the expected and got diag values with single quotes to make it easier to spot trailing whitespace. So in this example</source>
          <target state="translated">外表是有欺骗性的,尤其是在空虚的时候。如果您正在挠头想知道为什么Test::Tester在诊断结果看起来完全正确的时候却说它们是错误的,那么答案很可能是空格。从 0.10 版本开始,Test::Tester 用单引号包围预期值和得到的 diag 值,以使它更容易发现尾部的空白。所以在这个例子中</target>
        </trans-unit>
        <trans-unit id="b71dbc9f1f2c8f41b80953098f3e95dfa1012f02" translate="yes" xml:space="preserve">
          <source>Append an item to the list of ops contained directly within a list-type op, returning the lengthened list.</source>
          <target state="translated">将一个项目追加到直接包含在列表型操作中的操作列表中,返回加长后的列表。</target>
        </trans-unit>
        <trans-unit id="555e00ca2c34efb8f2b3198b481016b18bb0499c" translate="yes" xml:space="preserve">
          <source>Append an item to the list of ops contained directly within a list-type op, returning the lengthened list. &lt;code&gt;first&lt;/code&gt; is the list-type op, and &lt;code&gt;last&lt;/code&gt; is the op to append to the list. &lt;code&gt;optype&lt;/code&gt; specifies the intended opcode for the list. If &lt;code&gt;first&lt;/code&gt; is not already a list of the right type, it will be upgraded into one. If either &lt;code&gt;first&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; is null, the other is returned unchanged.</source>
          <target state="translated">将项目追加到直接包含在列表类型op中的op列表中，返回加长的列表。 &lt;code&gt;first&lt;/code&gt; 是列表类型的op， &lt;code&gt;last&lt;/code&gt; 是要追加到列表的op。 &lt;code&gt;optype&lt;/code&gt; 指定列表的预期操作码。如果 &lt;code&gt;first&lt;/code&gt; 还不是正确类型的列表，它将被升级为一个。如果 &lt;code&gt;first&lt;/code&gt; 或 &lt;code&gt;last&lt;/code&gt; 为空，则另一个不变。</target>
        </trans-unit>
        <trans-unit id="becdeb6adee05d280a8a50e1526a1a849bef0624" translate="yes" xml:space="preserve">
          <source>Append elements of</source>
          <target state="translated">添加以下元素</target>
        </trans-unit>
        <trans-unit id="7b02fe45aa574073ed825bd38be9577b88d0ca63" translate="yes" xml:space="preserve">
          <source>Append elements of LIST to the array.</source>
          <target state="translated">将LIST的元素追加到数组中。</target>
        </trans-unit>
        <trans-unit id="89394607a467e98868ad0332e6c7061404a979e4" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">附加运行时间以输出每个测试。使用&lt;a href=&quot;../../time/hires&quot;&gt;Time :: HiRes（&lt;/a&gt;如果可用）。</target>
        </trans-unit>
        <trans-unit id="f3320c1303317ee828f35f641012da0ef7ad78b8" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">附加运行时间以输出每个测试。使用&lt;a href=&quot;../time/hires&quot;&gt;Time :: HiRes（&lt;/a&gt;如果可用）。</target>
        </trans-unit>
        <trans-unit id="c0d38ef820bcef303880baae14bb62295e88bb8d" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">将每个测试的运行时间附加到输出。使用&lt;a href=&quot;Time::HiRes&quot;&gt;Time :: HiRes（&lt;/a&gt;如果可用）。</target>
        </trans-unit>
        <trans-unit id="115b06d7e965b2c8ec031641d6914969c4847565" translate="yes" xml:space="preserve">
          <source>Appending the G_KEEPERR flag, so that the</source>
          <target state="translated">添加G_KEEPERR标志,这样就可以使</target>
        </trans-unit>
        <trans-unit id="112a3bb05c1aa885c550b6193e7eaea408add2b6" translate="yes" xml:space="preserve">
          <source>Appends the given string or parse-tree or sequence object to the parse-tree of this interior sequence.</source>
          <target state="translated">将给定的字符串或解析树或序列对象附加到这个内部序列的解析树上。</target>
        </trans-unit>
        <trans-unit id="bc939bc86e4ec12055b78bc1367433c6c3dc048c" translate="yes" xml:space="preserve">
          <source>Apple Mac OS 8/9</source>
          <target state="translated">苹果Mac OS 8/9</target>
        </trans-unit>
        <trans-unit id="6dd82bd12d46344a2006677b750f75da928a5f51" translate="yes" xml:space="preserve">
          <source>Application of the patches</source>
          <target state="translated">补丁的应用</target>
        </trans-unit>
        <trans-unit id="e91f35534bce18d06e39334fde833d8a1d0115a1" translate="yes" xml:space="preserve">
          <source>Application release September 2001, HP-UX 11.00 is the first to ship with Perl. By the time it was perl-5.6.1 in /opt/perl. The first occurrence is on CD 5012-7954 and can be installed using</source>
          <target state="translated">应用发布2001年9月,HP-UX 11.00是第一个搭载Perl的版本。到时是perl-5.6.1在/opt/perl中。第一次出现在CD 5012-7954上,可以用它来安装。</target>
        </trans-unit>
        <trans-unit id="70dcb259ecf9216f358dc0f66966f145bfe54f70" translate="yes" xml:space="preserve">
          <source>Applies a syntactic context to an op tree representing an expression.</source>
          <target state="translated">将语法上下文应用到表示表达式的运算树上。</target>
        </trans-unit>
        <trans-unit id="4e768fecef5f9dd672611658c8743f59705b1284" translate="yes" xml:space="preserve">
          <source>Applies a syntactic context to an op tree representing an expression. &lt;code&gt;o&lt;/code&gt; is the op tree, and &lt;code&gt;context&lt;/code&gt; must be &lt;code&gt;G_SCALAR&lt;/code&gt;, &lt;code&gt;G_ARRAY&lt;/code&gt;, or &lt;code&gt;G_VOID&lt;/code&gt; to specify the context to apply. The modified op tree is returned.</source>
          <target state="translated">将语法上下文应用于表示表达式的操作树。 &lt;code&gt;o&lt;/code&gt; 是操作树，并且 &lt;code&gt;context&lt;/code&gt; 必须为 &lt;code&gt;G_SCALAR&lt;/code&gt; ， &lt;code&gt;G_ARRAY&lt;/code&gt; 或 &lt;code&gt;G_VOID&lt;/code&gt; 才能指定要应用的上下文。返回修改后的操作树。</target>
        </trans-unit>
        <trans-unit id="d5ed3f5653497e355ed136e0b7c54a5982ace7b4" translate="yes" xml:space="preserve">
          <source>Applies dl_find_symbol() to the members of @dl_librefs and returns the first match found.</source>
          <target state="translated">将 dl_find_symbol()应用于 @dl_librefs 的成员,并返回找到的第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="8f16d6f27d971ff843245cdc989aa538f3326e5f" translate="yes" xml:space="preserve">
          <source>Apply &lt;a href=&quot;#int-EXPR&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; to the value returned by &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">应用&lt;a href=&quot;#int-EXPR&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt;要返回的值&lt;a href=&quot;#rand-EXPR&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt;，如果你想随机整数，而不是随机小数。例如，</target>
        </trans-unit>
        <trans-unit id="197e68ad33f090de266ab7a82716d4dcf0c6223c" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">应用 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; 被返回的值 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; ，如果你想随机整数，而不是随机小数。例如，</target>
        </trans-unit>
        <trans-unit id="a60da6ae1477278e788b56dd12901cf6a9b5b818" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">应用 &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; 被返回的值 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; ，如果你想随机整数，而不是随机小数。例如，</target>
        </trans-unit>
        <trans-unit id="974cf6b03d0010e4742b565eeb776443fe41243e" translate="yes" xml:space="preserve">
          <source>Apply Perl-specific heuristics to find the correct PODs. This includes stripping Perl-like extensions, omitting subdirectories that are numeric but do</source>
          <target state="translated">应用Perl特有的启发式方法来寻找正确的POD。这包括剥离类似Perl的扩展,省略那些是数字的子目录,但确实是这样。</target>
        </trans-unit>
        <trans-unit id="baaa234761c2eef7e15c7c661df9bd832e32f420" translate="yes" xml:space="preserve">
          <source>Apply a list of switch options to the state, updating the internal object state as a result. Nothing is returned.</source>
          <target state="translated">将开关选项列表应用于状态,结果更新内部对象状态。不返回任何内容。</target>
        </trans-unit>
        <trans-unit id="7b0453d0169f10e0dd546ac420ad360f4311387a" translate="yes" xml:space="preserve">
          <source>Applying %s to %s will act on scalar(%s)</source>
          <target state="translated">将%s应用于%s将作用于标量(%s)</target>
        </trans-unit>
        <trans-unit id="c72c1cee8e4b08228a22dc9c5e025abf27a61b14" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;autodie&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; causes the exotic forms &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; to be considered a syntax error until the end of the lexical scope. If you really need to use the exotic form, you can call &lt;code&gt;CORE::system&lt;/code&gt; or &lt;code&gt;CORE::exec&lt;/code&gt; instead, or use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; before calling the exotic form.</source>
          <target state="translated">将 &lt;code&gt;autodie&lt;/code&gt; 应用于 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 会导致特殊形式的 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; 被视为语法错误，直到词法范围结束。如果确实需要使用奇异形式，则可以调用 &lt;code&gt;CORE::system&lt;/code&gt; 或 &lt;code&gt;CORE::exec&lt;/code&gt; 代替，或者在调用奇异形式之前 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; 使用autodie qw（system exec）。</target>
        </trans-unit>
        <trans-unit id="73c33410e3cd1ef38b870e6e841b6a111c44ea15" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;autodie&lt;/code&gt; to &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt; causes the exotic forms &lt;code&gt;system { $cmd } @args &lt;/code&gt; or &lt;code&gt;exec { $cmd } @args&lt;/code&gt; to be considered a syntax error until the end of the lexical scope. If you really need to use the exotic form, you can call &lt;code&gt;CORE::system&lt;/code&gt; or &lt;code&gt;CORE::exec&lt;/code&gt; instead, or use &lt;code&gt;no autodie qw(system exec)&lt;/code&gt; before calling the exotic form.</source>
          <target state="translated">将 &lt;code&gt;autodie&lt;/code&gt; 应用于 &lt;code&gt;system&lt;/code&gt; 或 &lt;code&gt;exec&lt;/code&gt; 会导致特殊形式的 &lt;code&gt;system { $cmd } @args &lt;/code&gt; 或 &lt;code&gt;exec { $cmd } @args&lt;/code&gt; 被视为语法错误，直到词法范围结束。如果确实需要使用奇异形式，则可以调用 &lt;code&gt;CORE::system&lt;/code&gt; 或 &lt;code&gt;CORE::exec&lt;/code&gt; 代替，或者在调用奇异形式之前 &lt;code&gt;no autodie qw(system exec)&lt;/code&gt; 使用autodie qw（system exec）。</target>
        </trans-unit>
        <trans-unit id="7b6bbaf0846e0f6542bb5b50d36df38212d67922" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; .</source>
          <target state="translated">Perl近似值： &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="255706027acb3bbb6c23a2beab5baa7da2561792" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</source>
          <target state="translated">Perl近似值： &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f08b9c9f0996e8f22c8e80713baa3b2c5d6b61a" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt;.</source>
          <target state="translated">Perl近似值： &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="171752021f257ea835e63866304a10e0627a5496" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;splice(@myarray, $key, 1, $val)&lt;/code&gt;.</source>
          <target state="translated">Perl近似值： &lt;code&gt;splice(@myarray, $key, 1, $val)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b7d5efdfeaa09de6b4d853375871c9207032b5a" translate="yes" xml:space="preserve">
          <source>April 04-07th, 1997: by Jarkko Hietaniemi, added the run-for-some-time functionality.</source>
          <target state="translated">1997年04月04日-07日:由Jarkko Hietaniemi编写,增加了运行时的功能。</target>
        </trans-unit>
        <trans-unit id="538beea89400340066f03de9b8531baacd233ee4" translate="yes" xml:space="preserve">
          <source>April 2010</source>
          <target state="translated">2010年4月</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="5383ba59b7a51b492dcc518df7e4190d4cdf46a1" translate="yes" xml:space="preserve">
          <source>Arbitrary big rational numbers</source>
          <target state="translated">任意大有理数</target>
        </trans-unit>
        <trans-unit id="d355876ea51e167fe43014294b56e66adbafd342" translate="yes" xml:space="preserve">
          <source>Arbitrary size floating point math package</source>
          <target state="translated">任意大小的浮点数学包。</target>
        </trans-unit>
        <trans-unit id="94977ff2a6f2fcf0486458c46c172275ed7d1a6e" translate="yes" xml:space="preserve">
          <source>Arbitrary size integer/float math package</source>
          <target state="translated">任意大小的整数/浮点数数学包。</target>
        </trans-unit>
        <trans-unit id="f96ddf323d8050458b6f5da00e7d15254e6e51f7" translate="yes" xml:space="preserve">
          <source>Arch</source>
          <target state="translated">Arch</target>
        </trans-unit>
        <trans-unit id="fa197ea9d1ebf357ab1895c0454edae5ed010094" translate="yes" xml:space="preserve">
          <source>Archive and test</source>
          <target state="translated">归档和测试</target>
        </trans-unit>
        <trans-unit id="ba6c5bbd1305838d356b1a16f613e5175253fc77" translate="yes" xml:space="preserve">
          <source>Archive::Tar</source>
          <target state="translated">Archive::Tar</target>
        </trans-unit>
        <trans-unit id="57cc32f42ad2d2bee580d99c3d374961c6559947" translate="yes" xml:space="preserve">
          <source>Archive::Tar - module for manipulations of tar archives</source>
          <target state="translated">Archive::Tar-用于操作tar存档的模块。</target>
        </trans-unit>
        <trans-unit id="987b760cdf9eb8e8f22f82c621b2dbe3ee552aeb" translate="yes" xml:space="preserve">
          <source>Archive::Tar provides an object oriented mechanism for handling tar files. It provides class methods for quick and easy files handling while also allowing for the creation of tar file objects for custom manipulation. If you have the IO::Zlib module installed, Archive::Tar will also support compressed or gzipped tar files.</source>
          <target state="translated">Archive::Tar 为处理 tar 文件提供了一个面向对象的机制。它提供了快速和简单的文件处理类方法,同时也允许创建tar文件对象进行自定义操作。如果您安装了 IO::Zlib 模块,Archive::Tar 也将支持压缩或 gzipped 的 tar 文件。</target>
        </trans-unit>
        <trans-unit id="2de9e103622352aeb9a5f8214ffe2d70dee8d73d" translate="yes" xml:space="preserve">
          <source>Archive::Tar will warn if you try to pass a bzip2 / xz compressed file and the IO::Uncompress::Bunzip2 / IO::Uncompress::UnXz are not available and simply return.</source>
          <target state="translated">Archive::Tar会在你试图传递一个bzip2/xz压缩文件,而IO::Uncompress::Bunzip2/IO::Uncompress::UnXz不可用时发出警告,并直接返回。</target>
        </trans-unit>
        <trans-unit id="7c0d8b6a96eeaeee2b14e15f99110273c20f8435" translate="yes" xml:space="preserve">
          <source>Archive::Tar will warn if you try to pass a bzip2 compressed file and the IO::Zlib / IO::Uncompress::Bunzip2 modules are not available and simply return.</source>
          <target state="translated">Archive::Tar 会在你试图传递一个 bzip2 压缩文件,而 IO::Zlib/IO::Uncompress::Bunzip2 模块不可用时发出警告,并简单地返回。</target>
        </trans-unit>
        <trans-unit id="ccbf19882dacfbec62ca802f4c207f93b26aac20" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;can_handle_compressed_files</source>
          <target state="translated">Archive::Tar-&amp;gt;can_handle_compressed_files</target>
        </trans-unit>
        <trans-unit id="3b7da738f6421ea5f244ab2a75337cb19a765083" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;create_archive($file, $compressed, @filelist)</source>
          <target state="translated">存档:: Tar-&amp;gt; create_archive（$ file，$ compressed，@filelist）</target>
        </trans-unit>
        <trans-unit id="1dcbd289acf336b4bc9986937face374b8265d16" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;extract_archive($file, $compressed)</source>
          <target state="translated">存档:: Tar-&amp;gt; extract_archive（$ file，$ compressed）</target>
        </trans-unit>
        <trans-unit id="8336b53d325ea70cb860e4292e999b5eb8ccc20b" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;iter( $filename, [ $compressed, {opt =&amp;gt; $val} ] )</source>
          <target state="translated">存档:: Tar-&amp;gt; iter（$ filename，[$ compressed，{opt =&amp;gt; $ val}]）</target>
        </trans-unit>
        <trans-unit id="7b5db2965e54185ceb8a82cfef6b3bcf83d67256" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;list_archive($file, $compressed, [\@properties])</source>
          <target state="translated">存档：： Tar-&amp;gt; list_archive（$ file，$ compressed，[\ @properties]）</target>
        </trans-unit>
        <trans-unit id="2b89433003c5207f03c7ec11ee01b11e8497bdb8" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;new( [$file, $compressed] )</source>
          <target state="translated">存档：： Tar-&amp;gt; new（[$ file，$ compressed]）</target>
        </trans-unit>
        <trans-unit id="3fdd79ccbef7cb27b73af9645a51c4748537632a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File</source>
          <target state="translated">Archive::Tar::File</target>
        </trans-unit>
        <trans-unit id="e4450126317363219e2891fd96c92d67bb8fdb14" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File - a subclass for in-memory extracted file from Archive::Tar</source>
          <target state="translated">Archive::Tar::File-从 Archive::Tar 中提取内存文件的子类。</target>
        </trans-unit>
        <trans-unit id="9bb643189669555fb8fc9a5ad660a12af02d7c6a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( chunk =&amp;gt; $chunk )</source>
          <target state="translated">存档:: Tar :: File-&amp;gt; new（chunk =&amp;gt; $ chunk）</target>
        </trans-unit>
        <trans-unit id="ba9618dfc7889be15218e3ccacc09c8bf242756f" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( data =&amp;gt; $path, $data, $opt )</source>
          <target state="translated">存档:: Tar :: File-&amp;gt; new（data =&amp;gt; $ path，$ data，$ opt）</target>
        </trans-unit>
        <trans-unit id="a50e4ac8ad32b339e1eb6dee5ec96a58d21300c3" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( file =&amp;gt; $path )</source>
          <target state="translated">存档:: Tar :: File-&amp;gt; new（file =&amp;gt; $ path）</target>
        </trans-unit>
        <trans-unit id="752ab891c175e9890243ad0568d1b63da7b75555" translate="yes" xml:space="preserve">
          <source>Archive::Tar::Files provides a neat little object layer for in-memory extracted files. It's mostly used internally in Archive::Tar to tidy up the code, but there's no reason users shouldn't use this API as well.</source>
          <target state="translated">Archive::Tar::Files 为内存中提取的文件提供了一个整洁的小对象层。它主要是在 Archive::Tar 中被内部用来整理代码,但用户没有理由不使用这个 API。</target>
        </trans-unit>
        <trans-unit id="2fa2e509f071fa28e01ed08cd42d1e6a982c1c93" translate="yes" xml:space="preserve">
          <source>Archiving and Compression</source>
          <target state="translated">归档和压缩</target>
        </trans-unit>
        <trans-unit id="470ed7908583fc807812b6f6f1c733d168001e41" translate="yes" xml:space="preserve">
          <source>Are Perl regexes DFAs or NFAs? Are they POSIX compliant?</source>
          <target state="translated">Perl 的 regexes 是 DFAs 还是 NFAs?它们是否符合 POSIX 标准?</target>
        </trans-unit>
        <trans-unit id="eb00fa046e6f0e29e318d2fe47833f95b6115931" translate="yes" xml:space="preserve">
          <source>Are These Threads The Same?</source>
          <target state="translated">这些线是一样的吗?</target>
        </trans-unit>
        <trans-unit id="4b1b74d280a485e3d6be58ac5945ac8cbddc5958" translate="yes" xml:space="preserve">
          <source>Are not yet implemented.</source>
          <target state="translated">尚未执行。</target>
        </trans-unit>
        <trans-unit id="37ca7d873908345ae9a97f86f6ad04967916d66e" translate="yes" xml:space="preserve">
          <source>Are we at end of file?</source>
          <target state="translated">我们已经到了文件的尽头了吗?</target>
        </trans-unit>
        <trans-unit id="1c7b6fd019a3db8f66c106580e36cbc2e27fdf91" translate="yes" xml:space="preserve">
          <source>Are you running Windows, and did you write</source>
          <target state="translated">你是否在运行Windows,你是否写了</target>
        </trans-unit>
        <trans-unit id="d10b1e8f0d25e8ced1066c8aec43c1966f5ae507" translate="yes" xml:space="preserve">
          <source>Are you running the latest released version of perl?</source>
          <target state="translated">你是否在运行最新发布的perl版本?</target>
        </trans-unit>
        <trans-unit id="c3fcfe8bf10e9354f16b7f74dc1d506d9b370761" translate="yes" xml:space="preserve">
          <source>Are you sure what you have is a bug?</source>
          <target state="translated">你确定你遇到的是个BUG吗?</target>
        </trans-unit>
        <trans-unit id="9835fff08898bf6d47cdf47b75c3d5a32e54abb7" translate="yes" xml:space="preserve">
          <source>Are you using a really old version of Perl?</source>
          <target state="translated">你使用的是非常老版本的Perl吗?</target>
        </trans-unit>
        <trans-unit id="1f76843fe2bb213b3ad1c4d889f7769d9611e0fa" translate="yes" xml:space="preserve">
          <source>Arg too short for msgsnd</source>
          <target state="translated">对msgsnd来说,arg太短了。</target>
        </trans-unit>
        <trans-unit id="354bf98925838ca68611b950e2a37ebd11c21640" translate="yes" xml:space="preserve">
          <source>Argentina</source>
          <target state="translated">Argentina</target>
        </trans-unit>
        <trans-unit id="6fa0e4cab9d0443ef8c9e6c56e4240cbc1230cdb" translate="yes" xml:space="preserve">
          <source>Arguably, these are the only routines you'll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;, and &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; to include external Perl files.</source>
          <target state="translated">可以说，这是从C程序中执行Perl代码段的唯一例程。您的代码可以是您想要的任何时间；它可以包含多个语句；它可以使用&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;，&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;和&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;来包含外部Perl文件。</target>
        </trans-unit>
        <trans-unit id="1bfedcdfdca0d5a6460d0d9a3f351f6cd3b4ab7e" translate="yes" xml:space="preserve">
          <source>Arguably, these are the only routines you'll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt;, &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt;, and &lt;a href=&quot;perlfunc#do&quot;&gt;&quot;do&quot; in perlfunc&lt;/a&gt; to include external Perl files.</source>
          <target state="translated">可以说，这些是从C程序中执行Perl代码段的唯一例程。您的代码可以是您想要的任何时间；它可以包含多个语句；它可以采用&lt;a href=&quot;perlfunc#use&quot;&gt;&amp;ldquo;使用&amp;rdquo;在perlfunc&lt;/a&gt;，&lt;a href=&quot;perlfunc#require&quot;&gt;&amp;ldquo;规定&amp;rdquo;在perlfunc&lt;/a&gt;，并&lt;a href=&quot;perlfunc#do&quot;&gt;在perlfunc&amp;ldquo;做&amp;rdquo;&lt;/a&gt;，包括外部的Perl文件。</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="a16749b15d046173fc9fcdf8d075749c151dba6a" translate="yes" xml:space="preserve">
          <source>Argument &quot;%s&quot; isn't numeric%s</source>
          <target state="translated">参数&quot;%s &quot;不是数字型%s</target>
        </trans-unit>
        <trans-unit id="c043537672dbd0f8f35895f8245f3c4e263a6c8f" translate="yes" xml:space="preserve">
          <source>Argument &quot;%s&quot; treated as 0 in increment (++)</source>
          <target state="translated">参数&quot;%s &quot;在递增中被视为0 (++)</target>
        </trans-unit>
        <trans-unit id="068c4f93ca844add9151394d87be6f0eff5098cb" translate="yes" xml:space="preserve">
          <source>Argument callback</source>
          <target state="translated">参数回调</target>
        </trans-unit>
        <trans-unit id="f421070543c0b96709c29a61e7bc0e29c9a6f773" translate="yes" xml:space="preserve">
          <source>Argument list not closed for PerlIO layer &quot;%s&quot;</source>
          <target state="translated">PerlIO层&quot;%s &quot;的参数列表未关闭</target>
        </trans-unit>
        <trans-unit id="becc16f3f9567f706b791b0867003075aa38f700" translate="yes" xml:space="preserve">
          <source>Argument stack</source>
          <target state="translated">参数堆栈</target>
        </trans-unit>
        <trans-unit id="9acc1ee24f849a6b6943c3856e23bafeb8ea115e" translate="yes" xml:space="preserve">
          <source>Argument stack manipulation in the core is exactly the same as it is in XSUBs - see &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for a longer description of the macros used in stack manipulation.</source>
          <target state="translated">内核中的参数堆栈操作与&lt;a href=&quot;perlguts&quot;&gt;XSUB&lt;/a&gt;中的参数完全相同-有关堆栈操作中使用的宏的详细说明，请参见&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;，&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;和perlguts。</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="1e682d21a155016274d4c0edada169602cf2db63" translate="yes" xml:space="preserve">
          <source>Arguments are case insensitive.</source>
          <target state="translated">参数不分大小写。</target>
        </trans-unit>
        <trans-unit id="f350823ca978137e84ceb658074c062e77adbc5a" translate="yes" xml:space="preserve">
          <source>Arguments are forced into the integer format if not strings.</source>
          <target state="translated">如果参数不是字符串,则强制采用整数格式。</target>
        </trans-unit>
        <trans-unit id="e574a112087c49e835619f8e2053ef81199f3165" translate="yes" xml:space="preserve">
          <source>Arguments are passed to PP code and returned from PP code using the argument stack, &lt;code&gt;ST&lt;/code&gt; . The typical way to handle arguments is to pop them off the stack, deal with them how you wish, and then push the result back onto the stack. This is how, for instance, the cosine operator works:</source>
          <target state="translated">使用参数堆栈 &lt;code&gt;ST&lt;/code&gt; 将参数传递到PP代码并从PP代码返回。处理参数的典型方法是将其弹出堆栈，按照需要进行处理，然后将结果推回堆栈。例如，余弦运算符的工作方式如下：</target>
        </trans-unit>
        <trans-unit id="ad4cbcd9603c1cc923fb5986131d15966c20d956" translate="yes" xml:space="preserve">
          <source>Arguments are passed to PP code and returned from PP code using the argument stack, &lt;code&gt;ST&lt;/code&gt;. The typical way to handle arguments is to pop them off the stack, deal with them how you wish, and then push the result back onto the stack. This is how, for instance, the cosine operator works:</source>
          <target state="translated">使用参数堆栈 &lt;code&gt;ST&lt;/code&gt; 将参数传递到PP代码并从PP代码返回。处理参数的典型方法是将其弹出堆栈，按照需要进行处理，然后将结果推回堆栈。例如，这是余弦运算符的工作方式：</target>
        </trans-unit>
        <trans-unit id="5fccb02bffe9af13a6b48fc881c2035657ec7bff" translate="yes" xml:space="preserve">
          <source>Arguments are usually formatted to be only as wide as required to display the given value. You can override the width by putting a number here, or get the width from the next argument (with &lt;code&gt;*&lt;/code&gt; ) or from a specified argument (e.g., with &lt;code&gt;*2$&lt;/code&gt;):</source>
          <target state="translated">参数通常被格式化为仅显示给定值所需的宽度。您可以通过在此处放置数字来覆盖宽度，或者从下一个参数（带有 &lt;code&gt;*&lt;/code&gt; ）或从指定的参数（例如带有 &lt;code&gt;*2$&lt;/code&gt; ）获取宽度：</target>
        </trans-unit>
        <trans-unit id="79b342195140d9018897c02d4477a0cd2a68bcbe" translate="yes" xml:space="preserve">
          <source>Arguments are usually formatted to be only as wide as required to display the given value. You can override the width by putting a number here, or get the width from the next argument (with &lt;code&gt;*&lt;/code&gt;) or from a specified argument (e.g., with &lt;code&gt;*2$&lt;/code&gt;):</source>
          <target state="translated">参数通常被格式化为仅显示给定值所需的宽度。您可以通过在此处放置数字来覆盖宽度，或者从下一个参数（带有 &lt;code&gt;*&lt;/code&gt; ）或从指定的参数（例如带有 &lt;code&gt;*2$&lt;/code&gt; ）获取宽度：</target>
        </trans-unit>
        <trans-unit id="4fb3861e253aa9c040fd66d90deafd1a6d71292f" translate="yes" xml:space="preserve">
          <source>Arguments of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive are (key, value) pairs. For the full set of legal keys, see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; below.</source>
          <target state="translated">该参数的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 指示是（键，值）对。有关完整的合法密钥集，请参阅下面的可&lt;a href=&quot;#Overloadable-Operations&quot;&gt;重载操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb61e5648eb703f1cc9dab71a052768830d8cd36" translate="yes" xml:space="preserve">
          <source>Arguments of the &lt;code&gt;use overload&lt;/code&gt; directive are (key, value) pairs. For the full set of legal keys, see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;&quot;Overloadable Operations&quot;&lt;/a&gt; below.</source>
          <target state="translated">该参数的 &lt;code&gt;use overload&lt;/code&gt; 指示是（键，值）对。有关完整的法律密钥，请参阅下面的&lt;a href=&quot;#Overloadable-Operations&quot;&gt;&amp;ldquo;可重载操作&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5141dae339b17f35a7a4380f8f719ce252ef43f8" translate="yes" xml:space="preserve">
          <source>Arguments that don't start with a hyphen are taken to be the names of subroutines or formats to render; if no such functions are specified, the main body of the program (outside any subroutines, and not including use'd or require'd files) is rendered. Passing &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , or &lt;code&gt;END&lt;/code&gt; will cause all of the corresponding special blocks to be printed. Arguments must follow options.</source>
          <target state="translated">不以连字符开头的参数被视为要渲染的子例程的名称或格式。如果未指定此类功能，则将呈现程序的主体（在任何子例程之外，并且不包括use'或require'd文件）。传递 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;UNITCHECK&lt;/code&gt; ， &lt;code&gt;CHECK&lt;/code&gt; ， &lt;code&gt;INIT&lt;/code&gt; 或 &lt;code&gt;END&lt;/code&gt; 将导致所有相应的特殊块被打印。参数必须遵循选项。</target>
        </trans-unit>
        <trans-unit id="c05d8fdf0d667d5e67ac75211debe610ccbb3189" translate="yes" xml:space="preserve">
          <source>Arguments that don't start with a hyphen are taken to be the names of subroutines or formats to render; if no such functions are specified, the main body of the program (outside any subroutines, and not including use'd or require'd files) is rendered. Passing &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, or &lt;code&gt;END&lt;/code&gt; will cause all of the corresponding special blocks to be printed. Arguments must follow options.</source>
          <target state="translated">不以连字符开头的参数将被视为要渲染的子例程的名称或格式。如果未指定此类功能，则呈现程序的主体（在任何子例程之外，并且不包括use'或require'd文件）。传递 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;UNITCHECK&lt;/code&gt; ， &lt;code&gt;CHECK&lt;/code&gt; ， &lt;code&gt;INIT&lt;/code&gt; 或 &lt;code&gt;END&lt;/code&gt; 将导致所有相应的特殊块被打印。参数必须遵循选项。</target>
        </trans-unit>
        <trans-unit id="ce73d1bc99ee20ea72fd21908b3617e55e0813cc" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; checked for taintedness.</source>
          <target state="translated">&lt;b&gt;不&lt;/b&gt;检查 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 的参数是否有污点。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4006b3311082c7bd892aab6f8d46c918fb22f118" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;syswrite&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; checked for taintedness.</source>
          <target state="translated">&lt;b&gt;不&lt;/b&gt;检查 &lt;code&gt;print&lt;/code&gt; 和 &lt;code&gt;syswrite&lt;/code&gt; 的参数是否有污点。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5b24aafc030974a768212046c7dad5ef0c74d247" translate="yes" xml:space="preserve">
          <source>Arguments to Tests</source>
          <target state="translated">测试的参数</target>
        </trans-unit>
        <trans-unit id="253657f116857073367b6474bc4203deb4236cb2" translate="yes" xml:space="preserve">
          <source>Arguments to be added to the command line</source>
          <target state="translated">要添加到命令行的参数</target>
        </trans-unit>
        <trans-unit id="ef74aa3554ce37f3e92c7ca867fc499504f0b195" translate="yes" xml:space="preserve">
          <source>Arguments to these commands are either strings exactly matching the identification string of an object, or regular expressions matched case-insensitively against various attributes of the objects. The parser only recognizes a regular expression when you enclose it with slashes.</source>
          <target state="translated">这些命令的参数要么是与对象的标识字符串完全匹配的字符串,要么是与对象的各种属性不分大小写地匹配的正则表达式。只有当你用斜杠括住正则表达式时,解析器才会识别它。</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="2007b9d426cd74d2705e9cb985a4b287291d5413" translate="yes" xml:space="preserve">
          <source>Arguments: COUNT is the number of times to run the loop, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">参数。COUNT是要运行循环的次数,CODE是要运行的代码。CODE可以是一个代码引用,也可以是一个字符串,无论哪种方式,它都会在调用者的包中运行。</target>
        </trans-unit>
        <trans-unit id="504073c25d9741031e514c8e9e91bef33965e548" translate="yes" xml:space="preserve">
          <source>Arguments: TIME is the minimum length of time to run CODE for, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">参数。TIME是运行CODE的最小时间长度,CODE是要运行的代码。CODE可以是一个代码引用,也可以是一个待评估的字符串;无论哪种方式,它都将在调用者的包中运行。</target>
        </trans-unit>
        <trans-unit id="38bfcf708d6931f7d42f920765aaabb5369a9058" translate="yes" xml:space="preserve">
          <source>Aristotle</source>
          <target state="translated">Aristotle</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="aa4a9120c32b4442874b4d46d816ed7dd9bbe6c6" translate="yes" xml:space="preserve">
          <source>Arithmetic methods</source>
          <target state="translated">算术方法</target>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="translated">算术运算符</target>
        </trans-unit>
        <trans-unit id="e6532be8ff2d954f60f4660f2c54f2ea6702b27e" translate="yes" xml:space="preserve">
          <source>Arithmetic operators during &lt;code&gt;use integer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;use integer&lt;/code&gt; 期间的算术运算符</target>
        </trans-unit>
        <trans-unit id="104fd3fd5302e037fb8d66ee6c616a71d0739a71" translate="yes" xml:space="preserve">
          <source>Arizona</source>
          <target state="translated">Arizona</target>
        </trans-unit>
        <trans-unit id="2dd1feda95af0eae16b44852b3e991a7320b9877" translate="yes" xml:space="preserve">
          <source>Arnold, Ken and James Gosling. The Java Programming Language, 2nd ed. Addison-Wesley, 1998, ISBN 0-201-31006-6.</source>
          <target state="translated">Arnold,Ken 和 James Gosling.The Java Programming Language,2nd ed.Addison-Wesley,1998,ISBN 0-201-31006-6.Addison-Wesley,1998年,ISBN 0-201-31006-6。</target>
        </trans-unit>
        <trans-unit id="f59bbf13db8733c389e26cc50790aefa49bd87eb" translate="yes" xml:space="preserve">
          <source>Around line 755:</source>
          <target state="translated">755线附近。</target>
        </trans-unit>
        <trans-unit id="c85b5fb626816d8525d58d40352050c4cc00a98a" translate="yes" xml:space="preserve">
          <source>Around line 804:</source>
          <target state="translated">围绕804线。</target>
        </trans-unit>
        <trans-unit id="5ab366efdd1504cdfaa681a633d790c9ce967f2c" translate="yes" xml:space="preserve">
          <source>Arranges for &lt;code&gt;sv&lt;/code&gt; to be shared between threads if a suitable module has been loaded.</source>
          <target state="translated">如果已加载合适的模块，则安排 &lt;code&gt;sv&lt;/code&gt; 在线程之间共享。</target>
        </trans-unit>
        <trans-unit id="f2eecdf1f299504d5505f21d414522aaf018f39c" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; (errno).</source>
          <target state="translated">安排在运行时库区分二进制文件和文本文件的系统上以&amp;ldquo;二进制&amp;rdquo;或&amp;ldquo;文本&amp;rdquo;模式读取或写入FILEHANDLE。如果FILEHANDLE是一个表达式，则将该值用作文件句柄的名称。成功返回true，否则返回&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;并设置&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;（errno）。</target>
        </trans-unit>
        <trans-unit id="41b85d47773b3148f4f3a1e9d404f9d2d3175fa5" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">安排在运行时库区分二进制文件和文本文件的系统上以&amp;ldquo;二进制&amp;rdquo;或&amp;ldquo;文本&amp;rdquo;模式读取或写入FILEHANDLE。如果FILEHANDLE是一个表达式，则将该值作为文件句柄的名称。成功返回true，否则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。</target>
        </trans-unit>
        <trans-unit id="1ffbadba9c3dce1044ad3f375a7830b9eb0ed44f" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">安排在运行时库区分二进制文件和文本文件的系统上以&amp;ldquo;二进制&amp;rdquo;或&amp;ldquo;文本&amp;rdquo;模式读取或写入FILEHANDLE。如果FILEHANDLE是一个表达式，则将该值作为文件句柄的名称。成功返回true，否则返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。</target>
        </trans-unit>
        <trans-unit id="9aa41e54fbd34ab084dcbe15fa8b4cafcc06eac6" translate="yes" xml:space="preserve">
          <source>Arranges for a mutual exclusion lock to be obtained on &lt;code&gt;sv&lt;/code&gt; if a suitable module has been loaded.</source>
          <target state="translated">如果已加载合适的模块，则安排在 &lt;code&gt;sv&lt;/code&gt; 上获取互斥锁。</target>
        </trans-unit>
        <trans-unit id="343c9f92b2508f5809b499c36c6237ee53dad8e9" translate="yes" xml:space="preserve">
          <source>Arranges for a mutual exclusion lock to be obtained on sv if a suitable module has been loaded.</source>
          <target state="translated">如果加载了合适的模块,安排在sv上获得互斥锁。</target>
        </trans-unit>
        <trans-unit id="a5173bbe458c53871d9b1f27fa09a96bfb62b86e" translate="yes" xml:space="preserve">
          <source>Arranges for sv to be shared between threads if a suitable module has been loaded.</source>
          <target state="translated">如果加载了合适的模块,安排线程之间共享sv。</target>
        </trans-unit>
        <trans-unit id="77504b93a8457067677bb3cc3aa5311d924675f5" translate="yes" xml:space="preserve">
          <source>Arranges to have a SIGALRM delivered to this process after the specified number of wallclock seconds has elapsed. If SECONDS is not specified, the value stored in &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; is used. (On some machines, unfortunately, the elapsed time may be up to one second less or more than you specified because of how seconds are counted, and process scheduling may delay the delivery of the signal even further.)</source>
          <target state="translated">在经过指定的时间后，安排将SIGALRM传送到此过程。如果未指定SECONDS，则使用&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;存储的值。（不幸的是，在某些机器上，经过的时间可能比您指定的时间少或多于一秒，这是因为秒的计数方式，并且进程调度可能会进一步延迟信号的传递。）</target>
        </trans-unit>
        <trans-unit id="5e55b4fcd8dbc2fd2ba6c045d961bacb9e292142" translate="yes" xml:space="preserve">
          <source>Arranges to have a SIGALRM delivered to this process after the specified number of wallclock seconds has elapsed. If SECONDS is not specified, the value stored in &lt;code&gt;$_&lt;/code&gt; is used. (On some machines, unfortunately, the elapsed time may be up to one second less or more than you specified because of how seconds are counted, and process scheduling may delay the delivery of the signal even further.)</source>
          <target state="translated">在经过指定数目的壁钟秒后，安排将SIGALRM交付给该过程。如果未指定SECONDS，则使用 &lt;code&gt;$_&lt;/code&gt; 存储的值。（不幸的是，在某些机器上，经过的时间可能比您指定的时间少一秒或更长时间，因为秒数是如何计算的，并且进程调度可能会进一步延迟信号的传递。）</target>
        </trans-unit>
        <trans-unit id="8d25b4a3297455b9e035c6b89f1c17b7c2bce696" translate="yes" xml:space="preserve">
          <source>Array (&lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt;)</source>
          <target state="translated">数组（ &lt;code&gt;'@'&lt;/code&gt; 或 &lt;code&gt;'*@'&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="fc39e6a09e8f437b433c2957e8745936c343df43" translate="yes" xml:space="preserve">
          <source>Array Interpolation</source>
          <target state="translated">阵列插值</target>
        </trans-unit>
        <trans-unit id="946f892404632d1e1ef312d460522dbcef0e5ca6" translate="yes" xml:space="preserve">
          <source>Array Manipulation Functions</source>
          <target state="translated">阵列操作函数</target>
        </trans-unit>
        <trans-unit id="380a0ee1c3f2add958e20ae4dd8479917cbbbae8" translate="yes" xml:space="preserve">
          <source>Array holding list of directories to be searched for</source>
          <target state="translated">包含要搜索的目录列表的数组。</target>
        </trans-unit>
        <trans-unit id="e55ce1c88c52594e868f7dcd4b7c1bf4e8ab55e6" translate="yes" xml:space="preserve">
          <source>Array of extension names to be included when doing a static build. MakeMaker will normally build with all of the installed extensions when doing a static build, and that is usually the desired behavior. If INCLUDE_EXT is present then MakeMaker will build only with those extensions which are explicitly mentioned. (e.g. [ qw( Socket POSIX ) ])</source>
          <target state="translated">在进行静态构建时要包含的扩展名的数组。当进行静态构建时,MakeMaker通常会与所有已安装的扩展一起构建,这通常是所需的行为。如果存在INCLUDE_EXT,那么MakeMaker将只构建那些明确提及的扩展。(例如[qw(Socket POSIX)])</target>
        </trans-unit>
        <trans-unit id="1a8fc45517962d9406be17b19c25fe3aa87b4fd8" translate="yes" xml:space="preserve">
          <source>Array of extension names to exclude when doing a static build. This is ignored if INCLUDE_EXT is present. Consult INCLUDE_EXT for more details. (e.g. [ qw( Socket POSIX ) ] )</source>
          <target state="translated">进行静态构建时要排除的扩展名数组。如果存在INCLUDE_EXT,则会被忽略。更多细节请参考INCLUDE_EXT。(例如:[qw(Socket POSIX )])</target>
        </trans-unit>
        <trans-unit id="ab0eedcb736c58c9e1bf3d9da5ea7d522b690f73" translate="yes" xml:space="preserve">
          <source>Array of strings containing name (and email address) of package author(s). Is used in CPAN Meta files (META.yml or META.json) and PPD (Perl Package Description) files for PPM (Perl Package Manager).</source>
          <target state="translated">包含包作者姓名(和电子邮件地址)的字符串数组。在 CPAN Meta 文件 (META.yml 或 META.json)和 PPM (Perl Package Manager)的 PPD (Perl Package Description)文件中使用。</target>
        </trans-unit>
        <trans-unit id="c57f3a7023d5d1d3793f2eb3d27a157609936e28" translate="yes" xml:space="preserve">
          <source>Array of symbol names for variables to be made available as universal symbols. Used only under AIX, OS/2, VMS and Win32 at present. Defaults to []. (e.g. [ qw(Foo_version Foo_numstreams Foo_tree ) ])</source>
          <target state="translated">变量的符号名称阵列,可作为通用符号使用。目前只在AIX、OS/2、VMS和Win32下使用。默认值为[]。(例如:[qw(Foo_version Foo_numstreams Foo_tree )])</target>
        </trans-unit>
        <trans-unit id="9ab44c94b1ea31feff632108e9870b5e1654c616" translate="yes" xml:space="preserve">
          <source>Array operations, which change the scalars, rearrange them, or add or subtract some scalars, only work on arrays. These can't work on a list, which is fixed. Array operations include &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">更改标量，重新排列标量或添加或减去某些标量的数组操作仅适用于数组。这些不能在固定的列表上使用。数组操作包括 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a460c81ea3de2b351104bc9016134c2ac95be02" translate="yes" xml:space="preserve">
          <source>Array operations, which change the scalars, rearrange them, or add or subtract some scalars, only work on arrays. These can't work on a list, which is fixed. Array operations include &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, and &lt;code&gt;splice&lt;/code&gt;.</source>
          <target state="translated">更改标量，重新排列标量或添加或减去某些标量的数组操作仅适用于数组。这些不能在固定的列表上使用。数组操作包括 &lt;code&gt;shift&lt;/code&gt; ， &lt;code&gt;unshift&lt;/code&gt; ， &lt;code&gt;push&lt;/code&gt; ， &lt;code&gt;pop&lt;/code&gt; 和 &lt;code&gt;splice&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78674941505b9a2d4a3ebcad653295e98eb9dd4f" translate="yes" xml:space="preserve">
          <source>Array passed to stat will be coerced to a scalar%s</source>
          <target state="translated">传递给stat的数组将被胁迫成一个标量%s。</target>
        </trans-unit>
        <trans-unit id="b9dd682c69e6440164f6188906ac10fd3b501a3b" translate="yes" xml:space="preserve">
          <source>Array reference of files to examine. May not be specified with &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="translated">要检查的文件的数组引用。可能没有用 &lt;code&gt;dir&lt;/code&gt; 指定。</target>
        </trans-unit>
        <trans-unit id="e4a46ecccd0814a0e990fda1f36238fc6513b396" translate="yes" xml:space="preserve">
          <source>Array refs</source>
          <target state="translated">阵列参考</target>
        </trans-unit>
        <trans-unit id="70c97244599437a3af8dc620ee670c18edb6906b" translate="yes" xml:space="preserve">
          <source>Array size can be obtained by doing:</source>
          <target state="translated">阵列大小可以通过做。</target>
        </trans-unit>
        <trans-unit id="4958f544bd9596999a8c5e79c668a1a1962b374e" translate="yes" xml:space="preserve">
          <source>Array, indexed by opcode, of functions that will be called for the &quot;check&quot; phase of optree building during compilation of Perl code. For most (but not all) types of op, once the op has been initially built and populated with child ops it will be filtered through the check function referenced by the appropriate element of this array. The new op is passed in as the sole argument to the check function, and the check function returns the completed op. The check function may (as the name suggests) check the op for validity and signal errors. It may also initialise or modify parts of the ops, or perform more radical surgery such as adding or removing child ops, or even throw the op away and return a different op in its place.</source>
          <target state="translated">在编译Perl代码的过程中,在建立optree的 &quot;检查 &quot;阶段会被调用的函数数组,以opcode为索引。对于大多数(但不是所有)类型的 op,一旦 op 被初始化并填充了子 op,就会通过这个数组中相应元素所引用的检查函数进行过滤。新的op作为唯一的参数传递给检查函数,检查函数返回完成的op。检查函数可以(顾名思义)检查 op 的有效性并发出错误信号。它也可以初始化或修改部分操作,或进行更彻底的手术,如添加或删除子操作,甚至扔掉操作并返回另一个操作。</target>
        </trans-unit>
        <trans-unit id="cbf55f45c7afc72d6bf912afc7befb393f385b76" translate="yes" xml:space="preserve">
          <source>Arrayref containing the facet-data hashes of events nested under this one.</source>
          <target state="translated">Arrayref包含了嵌套在这个事件下的面数据哈希。</target>
        </trans-unit>
        <trans-unit id="7622ad2f459420f8cf1278b446072cfedac9e366" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(archname manext)] defines ARCHNAME &amp;amp; MANEXT from config.sh. MakeMaker will add to CONFIG the following values anyway: ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</source>
          <target state="translated">Arrayref。例如，[qw（archname manext）]从config.sh定义ARCHNAME和MANEXT。MakeMaker仍将向CONFIG添加以下值：ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</target>
        </trans-unit>
        <trans-unit id="ac3c8cf1aba574321bc1f66afd6baee7d74ccdb5" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(name1 name2)] skip (do not write) sections of the Makefile. Caution! Do not use the SKIP attribute for the negligible speedup. It may seriously damage the resulting Makefile. Only use it if you really need it.</source>
          <target state="translated">Arrayref.例如[qw(name1 name2)]跳过(不写)Makefile的部分。注意!不要使用SKIP属性来达到可以忽略不计的速度。不要为了可以忽略的速度而使用 SKIP 属性。它可能会严重损坏生成的 Makefile。只有在真正需要的时候才使用它。</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="065b62648ae15e66467cb649a0f78784ebc20d69" translate="yes" xml:space="preserve">
          <source>Arrays and slices are interpolated into double-quoted strings by joining the elements with the delimiter specified in the &lt;code&gt;$&quot;&lt;/code&gt; variable (&lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; if &quot;use English;&quot; is specified), space by default. The following are equivalent:</source>
          <target state="translated">通过将元素与 &lt;code&gt;$&quot;&lt;/code&gt; 变量中指定的定界符（ &lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; 如果指定为&amp;rdquo; use English;&amp;ldquo;）连接在一起，将数组和切片插入双引号字符串中，默认情况下为空格。</target>
        </trans-unit>
        <trans-unit id="015aea03d19c4f5404b14d2e291f0bb807a559b3" translate="yes" xml:space="preserve">
          <source>Arrays are zero-indexed. Here's how you get at elements in an array:</source>
          <target state="translated">数组是零索引的。下面是如何获取数组中的元素。</target>
        </trans-unit>
        <trans-unit id="62a56f74931523c8c6be523e0f4189cd13f83348" translate="yes" xml:space="preserve">
          <source>Arrays index from 0. Likewise string positions in substr() and index().</source>
          <target state="translated">同样,在substr()和index()中的字符串位置也是如此。</target>
        </trans-unit>
        <trans-unit id="c6d4028b66a4b9402be627f34603725a671721e9" translate="yes" xml:space="preserve">
          <source>Arrays:</source>
          <target state="translated">Arrays:</target>
        </trans-unit>
        <trans-unit id="758bdbae166b00a3d8e1212d185299f382e9e26b" translate="yes" xml:space="preserve">
          <source>Arrow Notation</source>
          <target state="translated">箭头符号</target>
        </trans-unit>
        <trans-unit id="d88829ea9618170c7e2c7635ccc9b881ef3d9e85" translate="yes" xml:space="preserve">
          <source>Arrow Rule</source>
          <target state="translated">箭头规则</target>
        </trans-unit>
        <trans-unit id="59f3e01c7f1fff089e4fc72d78498e369ebc8aba" translate="yes" xml:space="preserve">
          <source>Article about software localization</source>
          <target state="translated">关于软件本地化的文章</target>
        </trans-unit>
        <trans-unit id="7c422841b7e3951946583038790545c4ed38481b" translate="yes" xml:space="preserve">
          <source>Articles</source>
          <target state="translated">Articles</target>
        </trans-unit>
        <trans-unit id="c2be5dffac8f664ad6e121cb0e6596d1cc2f8c20" translate="yes" xml:space="preserve">
          <source>Articles that are either about &lt;b&gt;DB_File&lt;/b&gt; or make use of it.</source>
          <target state="translated">有关&lt;b&gt;DB_File&lt;/b&gt;或使用它的文章。</target>
        </trans-unit>
        <trans-unit id="a75b4962c21a671a678a35a002d5a9cabe9f37df" translate="yes" xml:space="preserve">
          <source>Artistic License</source>
          <target state="translated">艺术授权</target>
        </trans-unit>
        <trans-unit id="5ec201db4d2d3c7be7bb34f8e626f24de679e0d7" translate="yes" xml:space="preserve">
          <source>Artur Bergman &amp;lt;sky AT crucially DOT net&amp;gt;</source>
          <target state="translated">Artur Bergman &amp;lt;sky AT至关重要的DOT网络&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8abf83e588a6f8dbd23df54124d573a8d6e50b02" translate="yes" xml:space="preserve">
          <source>Artur Bergman, &quot;Where Wizards Fear To Tread&quot;, June 11, 2002, &lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http://www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</source>
          <target state="translated">Artur Bergman，&amp;ldquo;巫师惧怕的地方&amp;rdquo;，2002年6月11日，&lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http：//www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d31985fda87b26d6554bcfbfe7dbc398b51917e" translate="yes" xml:space="preserve">
          <source>As</source>
          <target state="translated">As</target>
        </trans-unit>
        <trans-unit id="47c29ec0c3f7f05bae80de5283a0b030f441a291" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt; or &lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt; but with the access/modify/change file timestamps in subsecond resolution, if the operating system and the filesystem both support such timestamps. To override the standard stat():</source>
          <target state="translated">与&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;或&lt;a href=&quot;../functions/lstat&quot;&gt;lstat一样，&lt;/a&gt;但是如果操作系统和文件系统均支持此类时间戳，则访问/修改/更改文件时间戳的分辨率为亚秒级。要覆盖标准stat（）：</target>
        </trans-unit>
        <trans-unit id="cad0de4aeb2435c3e6250aa64da21872a52c4d61" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;perlfunc#stat&quot;&gt;&quot;stat&quot; in perlfunc&lt;/a&gt; or &lt;a href=&quot;perlfunc#lstat&quot;&gt;&quot;lstat&quot; in perlfunc&lt;/a&gt; but with the access/modify/change file timestamps in subsecond resolution, if the operating system and the filesystem both support such timestamps. To override the standard stat():</source>
          <target state="translated">如果操作系统和文件系统都支持这样的时间戳，则作为&lt;a href=&quot;perlfunc#stat&quot;&gt;perlfunc中的&amp;ldquo; stat&amp;rdquo;&lt;/a&gt;或perlfunc中的&lt;a href=&quot;perlfunc#lstat&quot;&gt;&amp;ldquo; lstat&amp;rdquo;，&lt;/a&gt;但是访问/修改/更改文件时间戳的分辨率为亚秒级。要覆盖标准stat（）：</target>
        </trans-unit>
        <trans-unit id="674c2b9678e49fe5c48ffe3cac937cee6706d2ff" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;perlfunc#utime&quot;&gt;&quot;utime&quot; in perlfunc&lt;/a&gt; but with the ability to set the access/modify file timestamps in subsecond resolution, if the operating system and the filesystem, and the mount options of the filesystem, all support such timestamps.</source>
          <target state="translated">作为&lt;a href=&quot;perlfunc#utime&quot;&gt;perlfunc中的&amp;ldquo; utime&amp;rdquo;，&lt;/a&gt;但如果操作系统和文件系统以及文件系统的安装选项都支持此类时间戳，则可以以亚秒级分辨率设置访问/修改文件时间戳。</target>
        </trans-unit>
        <trans-unit id="02b2b57eecbbd649395f996ef53060747f75fc9c" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-nok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">与&lt;b&gt;-nok一样，&lt;/b&gt;除了它将在较旧的系统上报告。</target>
        </trans-unit>
        <trans-unit id="4859922e8f70272693e823f3867ed24a92199eaa" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-ok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">与&lt;b&gt;-ok一样，&lt;/b&gt;除了它将在较旧的系统上报告。</target>
        </trans-unit>
        <trans-unit id="11468a3ea9b3583c1d2e6860cce82a44a9b04f63" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;$form_name&lt;/code&gt; , one of the following names must be given.</source>
          <target state="translated">作为 &lt;code&gt;$form_name&lt;/code&gt; ，必须提供以下名称之一。</target>
        </trans-unit>
        <trans-unit id="bdbf26fc42681222abf14a2b96b2aee6d500b3fc" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;$form_name&lt;/code&gt;, one of the following names must be given.</source>
          <target state="translated">作为 &lt;code&gt;$form_name&lt;/code&gt; ，必须提供以下名称之一。</target>
        </trans-unit>
        <trans-unit id="2779b0caf565b7a913bad43d8e6bc994f2a3b086" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;-Dm&lt;/code&gt; is using the PerlIO layer for output, it will by itself allocate quite a bunch of SVs, which are hidden to avoid recursion. You can bypass the PerlIO layer if you use the SV logging provided by &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; instead.</source>
          <target state="translated">由于 &lt;code&gt;-Dm&lt;/code&gt; 使用PerlIO层进行输出，因此它本身将分配大量的SV，这些SV被隐藏以避免递归。如果使用 &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; 提供的SV日志记录，则可以绕过PerlIO层。</target>
        </trans-unit>
        <trans-unit id="2a4f04aeb40af858ae530be27c732d3a12776244" translate="yes" xml:space="preserve">
          <source>As DSM is a trimmed-down Linux system, it lacks many of the tools and libraries commonly found on Linux. The basic tools like sh, cp, rm, etc. are implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/BusyBox&quot;&gt;BusyBox&lt;/a&gt;.</source>
          <target state="translated">由于DSM是精简的Linux系统，因此缺少许多Linux上常见的工具和库。sh，cp，rm等基本工具是使用&lt;a href=&quot;https://en.wikipedia.org/wiki/BusyBox&quot;&gt;BusyBox&lt;/a&gt;实现的。</target>
        </trans-unit>
        <trans-unit id="37a9797fcef19ae902b7dc1fdcbae68c956c3e1b" translate="yes" xml:space="preserve">
          <source>As I work on a particular part of my module it's most likely that the tests that cover that code will fail. I'd like to run the whole test suite but have it prioritize these 'hot' tests. I can tell prove to do this:</source>
          <target state="translated">当我在模块的某个特定部分工作时,涵盖该代码的测试很可能会失败。我想运行整个测试套件,但让它优先处理这些 &quot;热门 &quot;测试。我可以告诉证明来做这件事。</target>
        </trans-unit>
        <trans-unit id="3f4dc14381957936768414e0ffe59b0595e92060" translate="yes" xml:space="preserve">
          <source>As JSON cannot directly represent Perl objects, you have to choose between a pure JSON representation (without the ability to deserialise the object automatically again), and a nonstandard extension to the JSON syntax, tagged values.</source>
          <target state="translated">由于JSON不能直接表示Perl对象,所以你必须在纯JSON表示法(没有再次自动反序列化对象的能力)和JSON语法的非标准扩展--标记值之间做出选择。</target>
        </trans-unit>
        <trans-unit id="67afac02f586f9bebcefbfe5f3e2ccc5758a2739" translate="yes" xml:space="preserve">
          <source>As Perl is developed by a global team of volunteers, our documentation often contains spellings which look funny to</source>
          <target state="translated">由于Perl是由全球志愿者团队开发的,所以我们的文档中经常会出现一些在我们看来很有趣的拼写。</target>
        </trans-unit>
        <trans-unit id="56f06af6196a2958b2b24cc234e03f482b95a8e2" translate="yes" xml:space="preserve">
          <source>As Storable neither knows nor cares about character sets (although it does know that characters may be more than eight bits wide), any difference in the interpretation of character codes between a host and a target system is your problem. In particular, if host and target use different code points to represent the characters used in the text representation of floating-point numbers, you will not be able be able to exchange floating-point data, even with nstore().</source>
          <target state="translated">由于Storable既不知道也不关心字符集(尽管它知道字符的宽度可能超过8位),因此,主机和目标系统在字符代码的解释上的任何差异都是你的问题。尤其是,如果主机和目标系统使用不同的代码点来表示浮点数字的文本表示,那么即使使用nstore(),也无法交换浮点数据。</target>
        </trans-unit>
        <trans-unit id="4eb26264176ff313034cbea4b1e32ac9ca4ff4be" translate="yes" xml:space="preserve">
          <source>As a beginning Perl programmer, your most common use of OO Perl will be in using third-party modules, which are documented below.</source>
          <target state="translated">作为一个初级的Perl程序员,你最常见的OOPerl的使用将是在使用第三方模块,下面将对这些模块进行说明。</target>
        </trans-unit>
        <trans-unit id="053c80fe967b67f5a7cb2ee310e9489c54536633" translate="yes" xml:space="preserve">
          <source>As a code reference, e.g.:</source>
          <target state="translated">作为代码参考,例如:</target>
        </trans-unit>
        <trans-unit id="c668c33e20c8d7992e509e03d3adf2ab76f6474b" translate="yes" xml:space="preserve">
          <source>As a consequence of the fact that &lt;code&gt;:raw&lt;/code&gt; normally pops layers, it usually only makes sense to have it as the only or first element in a layer specification. When used as the first element it provides a known base on which to build e.g.</source>
          <target state="translated">由于 &lt;code&gt;:raw&lt;/code&gt; 通常会弹出图层，因此通常只有将其作为图层规范中的唯一元素或第一个元素才有意义。当用作第一个元素时，它提供了构建的已知基础，例如</target>
        </trans-unit>
        <trans-unit id="85a48b10d40e66cd4a8aedc3b80bf9f3898c7f18" translate="yes" xml:space="preserve">
          <source>As a consequence, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ignores any number or &lt;code&gt;*&lt;/code&gt; after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">因此， &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 忽略任何数字或 &lt;code&gt;*&lt;/code&gt; 后， &lt;code&gt;P&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="794de411ca7a9fef9a487a0fcead83c094be14c9" translate="yes" xml:space="preserve">
          <source>As a consequence, &lt;code&gt;pack&lt;/code&gt; ignores any number or &lt;code&gt;*&lt;/code&gt; after &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">因此， &lt;code&gt;pack&lt;/code&gt; 忽略任何数字或 &lt;code&gt;*&lt;/code&gt; 后， &lt;code&gt;P&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af58dfe35e68f1702e8805a513e543501b556b2f" translate="yes" xml:space="preserve">
          <source>As a consequence, the behavior of the operator % agrees with the behavior of Perl's built-in % operator (as documented in the perlop manpage), and the equation</source>
          <target state="translated">因此,操作符%的行为与Perl内置的%操作符的行为一致(如perlop手册中所描述的),而等式是</target>
        </trans-unit>
        <trans-unit id="b71d9a336a26729c423fab79edbbfcd18fbf6683" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt;'s setsockopt() method will convert a number into a packed byte buffer, and getsockopt() will unpack a byte buffer of the correct size back into a number.</source>
          <target state="translated">为方便起见，&lt;a href=&quot;IO::Socket&quot;&gt;IO :: Socket&lt;/a&gt;的setsockopt（）方法会将数字转换为打包的字节缓冲区，而getsockopt（）会将正确大小的字节缓冲区解压缩回数字。</target>
        </trans-unit>
        <trans-unit id="8ed20c41e94e838dcaa1f2e890809ac53aaadc11" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;io/socket&quot;&gt;IO::Socket&lt;/a&gt;'s setsockopt() method will convert a number into a packed byte buffer, and getsockopt() will unpack a byte buffer of the correct size back into a number.</source>
          <target state="translated">为方便起见，&lt;a href=&quot;io/socket&quot;&gt;IO :: Socket&lt;/a&gt;的setsockopt（）方法会将数字转换为打包的字节缓冲区，而getsockopt（）会将正确大小的字节缓冲区解压缩回数字。</target>
        </trans-unit>
        <trans-unit id="39dd3ca26236e47c7f0b84b7220b02b39c4ce6f1" translate="yes" xml:space="preserve">
          <source>As a convenience, if only one argument is passed then this argument is assumed to be the name of the test (as in the above examples.)</source>
          <target state="translated">为了方便起见,如果只传递一个参数,那么这个参数被认为是测试的名称(如上面的例子)。</target>
        </trans-unit>
        <trans-unit id="1cb03824a7a51fc71299760a7d72ef70c9f7d1d1" translate="yes" xml:space="preserve">
          <source>As a debugging aid, you can force Carp to treat a croak as a confess and a carp as a cluck across</source>
          <target state="translated">作为调试的辅助手段,你可以强行把呱呱当做告白,把鲤鱼当做对面的线索</target>
        </trans-unit>
        <trans-unit id="5de9c4f1738c3fbc65c8014410d9308c0bceec73" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Parser, Pod::PlainText supports the same methods and interfaces. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; and then calls either parse_from_filehandle() or parse_from_file().</source>
          <target state="translated">作为Pod :: Parser的派生类，Pod :: PlainText支持相同的方法和接口。有关所有详细信息，请参见&lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt;。简要地说，用 &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; 创建一个新的解析器，然后调用parse_from_filehandle（）或parse_from_file（）。</target>
        </trans-unit>
        <trans-unit id="64d726339f8e6e60df57582ad6893533391488ae" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Man supports the same methods and interfaces. See &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details.</source>
          <target state="translated">作为Pod :: Simple的派生类，Pod :: Man支持相同的方法和接口。有关所有详细信息，请参见&lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6ec952fc34afc28085390c8d52daf19e0a80643" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Man supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details.</source>
          <target state="translated">作为Pod :: Simple的派生类，Pod :: Man支持相同的方法和接口。有关所有详细信息，请参见&lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7614b2907ce626d34be33e5f930e92fbced576b9" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Text supports the same methods and interfaces. See &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; and then normally calls parse_file().</source>
          <target state="translated">作为Pod :: Simple的派生类，Pod :: Text支持相同的方法和接口。有关所有详细信息，请参见&lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt;。简要地讲，使用 &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; 创建一个新的解析器，然后通常调用parse_file（）。</target>
        </trans-unit>
        <trans-unit id="3e4fc5bdbe388e6ddf3cda0d8bc20220f607ea7d" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Text supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; and then normally calls parse_file().</source>
          <target state="translated">作为Pod :: Simple的派生类，Pod :: Text支持相同的方法和接口。有关所有详细信息，请参见&lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt;。简要地说，使用 &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; 创建一个新的解析器，然后通常调用parse_file（）。</target>
        </trans-unit>
        <trans-unit id="b23f74daa8f57475a4ba46fd4485f5b745823a7e" translate="yes" xml:space="preserve">
          <source>As a final remark, note that one can fill %subr by</source>
          <target state="translated">最后,请注意,可以用以下方法填充%subr</target>
        </trans-unit>
        <trans-unit id="4cc64b626e2a5166499114ddf2d5328e019929e3" translate="yes" xml:space="preserve">
          <source>As a final thought, remember that it's not (at the time of writing) possible to produce a useful program which will run in zero or negative time and this basic principle can be written as:</source>
          <target state="translated">最后想说的是,请记住,(在写这篇文章的时候)不可能产生一个有用的程序,它将在零时间或负时间内运行,这个基本原则可以写成。</target>
        </trans-unit>
        <trans-unit id="b93fce445dda74a4e62d212ddcfc5d79912e276b" translate="yes" xml:space="preserve">
          <source>As a final word of warning, if you're using adb, &lt;code&gt;make test&lt;/code&gt; may appear to hang; this is because it doesn't output anything until it finishes running all tests. You can check its progress by logging into the device, moving to</source>
          <target state="translated">最后警告一下，如果您使用的是adb， &lt;code&gt;make test&lt;/code&gt; 可能会挂起；这是因为在完成所有测试之前，它不会输出任何内容。您可以通过登录设备并移至来检查其进度。</target>
        </trans-unit>
        <trans-unit id="c76d7d0ab08773eceae9495e1336acd5bdc1e071" translate="yes" xml:space="preserve">
          <source>As a further example, this means that if you wanted to put these bits of code in &lt;code&gt;C&lt;/code&gt; (code) style:</source>
          <target state="translated">再举一个例子，这意味着如果您想将这些代码以 &lt;code&gt;C&lt;/code&gt; （代码）样式放置：</target>
        </trans-unit>
        <trans-unit id="a5d5c5dbed3ae73f59f4d512802a9cfe627521f0" translate="yes" xml:space="preserve">
          <source>As a further example: At time of writing, no &quot;biblio&quot; identifier is supported, but suppose some processor were written to recognize it as a way of (say) denoting a bibliographic reference (necessarily containing formatting codes in ordinary paragraphs). The fact that &quot;biblio&quot; paragraphs were meant for ordinary processing would be indicated by prefacing each &quot;biblio&quot; identifier with a colon:</source>
          <target state="translated">再举一个例子:在编写本报告时,不支持 &quot;书目 &quot;标识符。在编写本报告时,不支持 &quot;biblio &quot;标识符,但假设编写一些处理程序,将其识别为表示书目参考资料的一种方式(必须包含普通段落的格式代码)。在每个 &quot;书目 &quot;标识符前加一个冒号,就可以表明 &quot;书目 &quot;段落是用于普通处理的。</target>
        </trans-unit>
        <trans-unit id="32e712936b7f11c5ab2eb3ed80fcfadcc776b710" translate="yes" xml:space="preserve">
          <source>As a further optimisation, on exit from the eval block in the &lt;code&gt;FETCH&lt;/code&gt; , execution of the code following the block is still carried on in the inner loop. When an exception is raised, &lt;code&gt;docatch&lt;/code&gt; compares the &lt;code&gt;JMPENV&lt;/code&gt; level of the &lt;code&gt;CxEVAL&lt;/code&gt; with &lt;code&gt;PL_top_env&lt;/code&gt; and if they differ, just re-throws the exception. In this way any inner loops get popped.</source>
          <target state="translated">作为进一步的优化，在从 &lt;code&gt;FETCH&lt;/code&gt; 中的eval块退出时，仍在内部循环中继续执行该块之后的代码。引发异常时， &lt;code&gt;docatch&lt;/code&gt; 会将 &lt;code&gt;JMPENV&lt;/code&gt; 级别与 &lt;code&gt;CxEVAL&lt;/code&gt; 进行 &lt;code&gt;PL_top_env&lt;/code&gt; ，如果它们不同，则仅重新引发该异常。这样，任何内部循环都会弹出。</target>
        </trans-unit>
        <trans-unit id="52bd4fd38df2dbb2fd4340b3f74e473ef3bdf3bc" translate="yes" xml:space="preserve">
          <source>As a further optimisation, on exit from the eval block in the &lt;code&gt;FETCH&lt;/code&gt;, execution of the code following the block is still carried on in the inner loop. When an exception is raised, &lt;code&gt;docatch&lt;/code&gt; compares the &lt;code&gt;JMPENV&lt;/code&gt; level of the &lt;code&gt;CxEVAL&lt;/code&gt; with &lt;code&gt;PL_top_env&lt;/code&gt; and if they differ, just re-throws the exception. In this way any inner loops get popped.</source>
          <target state="translated">作为进一步的优化，在从 &lt;code&gt;FETCH&lt;/code&gt; 中的eval块退出时，仍在内部循环中继续执行该块之后的代码。引发异常时， &lt;code&gt;docatch&lt;/code&gt; 会将 &lt;code&gt;JMPENV&lt;/code&gt; 级别与 &lt;code&gt;CxEVAL&lt;/code&gt; 进行 &lt;code&gt;PL_top_env&lt;/code&gt; ，如果它们不同，则仅重新引发该异常。这样，任何内部循环都会弹出。</target>
        </trans-unit>
        <trans-unit id="3a1271bc4a381b470fd6a076ccacce4ffa6ad068" translate="yes" xml:space="preserve">
          <source>As a further performance optimisation, the various &lt;code&gt;PUSH&lt;/code&gt; macros all operate using a local variable &lt;code&gt;SP&lt;/code&gt;, rather than the interpreter-global variable &lt;code&gt;PL_stack_sp&lt;/code&gt;. This variable is declared by the &lt;code&gt;dSP&lt;/code&gt; macro - though it is normally implied by XSUBs and similar so it is rare you have to consider it directly. Once declared, the &lt;code&gt;PUSH&lt;/code&gt; macros will operate only on this local variable, so before invoking any other perl core functions you must use the &lt;code&gt;PUTBACK&lt;/code&gt; macro to return the value from the local &lt;code&gt;SP&lt;/code&gt; variable back to the interpreter variable. Similarly, after calling a perl core function which may have had reason to move the stack or push/pop values to it, you must use the &lt;code&gt;SPAGAIN&lt;/code&gt; macro which refreshes the local &lt;code&gt;SP&lt;/code&gt; value back from the interpreter one.</source>
          <target state="translated">为了进一步优化性能，各种 &lt;code&gt;PUSH&lt;/code&gt; 宏均使用局部变量 &lt;code&gt;SP&lt;/code&gt; 而不是解释器全局变量 &lt;code&gt;PL_stack_sp&lt;/code&gt; 进行操作。该变量由 &lt;code&gt;dSP&lt;/code&gt; 宏声明-尽管它通常由XSUB和类似的变量隐含，因此很少需要直接考虑它。声明后， &lt;code&gt;PUSH&lt;/code&gt; 宏将仅对此局部变量起作用，因此在调用任何其他perl核心函数之前，必须使用 &lt;code&gt;PUTBACK&lt;/code&gt; 宏从本地 &lt;code&gt;SP&lt;/code&gt; 返回值。变量返回解释器变量。同样，在调用可能有理由将堆栈或推入/弹出值移动到其的perl核心函数后，必须使用 &lt;code&gt;SPAGAIN&lt;/code&gt; 宏，该宏将从解释器中刷新回本地 &lt;code&gt;SP&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="23702715810537d7f01f041b430e67e396dff672" translate="yes" xml:space="preserve">
          <source>As a general rule of thumb, your commit message should help a programmer who knows the Perl core quickly understand what you were trying to do, how you were trying to do it, and why the change matters to Perl.</source>
          <target state="translated">一般来说,你的提交信息应该能够帮助了解 Perl 核心的程序员快速理解你要做什么,你是如何做的,以及为什么这个改变对 Perl 很重要。</target>
        </trans-unit>
        <trans-unit id="4e47a1601663426f056fd202a23442a94b37a934" translate="yes" xml:space="preserve">
          <source>As a general rule you should</source>
          <target state="translated">一般情况下,你应该</target>
        </trans-unit>
        <trans-unit id="f1a7ae8ef2fbb4b6cb7127db887caa429f079e93" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then &lt;code&gt;@EXPORT_OK&lt;/code&gt; anything but use &lt;code&gt;@EXPORT&lt;/code&gt; with caution. For function and method names use barewords in preference to names prefixed with ampersands for the export lists.</source>
          <target state="translated">通常，如果模块试图面向对象，则不导出任何内容。如果只是函数的集合，则 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 除了使用 &lt;code&gt;@EXPORT&lt;/code&gt; 时要小心。对于函数名和方法名，在导出列表中使用裸字优先于以&amp;ldquo;＆&amp;rdquo;开头的名称。</target>
        </trans-unit>
        <trans-unit id="e17549d186f2cd9b2973080585cd98536cba2f89" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then @EXPORT_OK anything but use @EXPORT with caution.</source>
          <target state="translated">一般来说,如果模块想面向对象,那么什么都不要导出。如果它只是一个函数的集合,那么@EXPORT_OK什么都可以,但是要谨慎使用@EXPORT。</target>
        </trans-unit>
        <trans-unit id="433c99eba76250876af9c971ad06d88a2549474f" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object-oriented then don't export anything. If it's just a collection of functions and variables, then you can export them via another array, called &lt;code&gt;@EXPORT_OK&lt;/code&gt; . This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done.</source>
          <target state="translated">通常，如果模块试图面向对象，则不要导出任何内容。如果它只是函数和变量的集合，则可以通过另一个数组 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 导出它们。除非用户明确要求这样做，否则该数组不会自动将其子例程和变量名放入名称空间。</target>
        </trans-unit>
        <trans-unit id="d1e3854176f62c2a9d9d5efd5fe3ab87123d6cec" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object-oriented then don't export anything. If it's just a collection of functions and variables, then you can export them via another array, called &lt;code&gt;@EXPORT_OK&lt;/code&gt;. This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done.</source>
          <target state="translated">通常，如果模块试图面向对象，则不要导出任何内容。如果它只是函数和变量的集合，则可以通过另一个数组 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 导出它们。除非用户明确要求这样做，否则该数组不会自动将其子例程和变量名放入名称空间。</target>
        </trans-unit>
        <trans-unit id="e7b6a2f89138fc36d28abf12c8042d8936138512" translate="yes" xml:space="preserve">
          <source>As a historical predecessor, Microsoft's variant probably has more rights for the name, though it may be objected that Microsoft shouldn't have used JIS as part of the name in the first place.</source>
          <target state="translated">作为历史上的前辈,微软的变体可能对这个名字拥有更多的权利,尽管有人可能会反对微软首先不应该使用JIS作为名字的一部分。</target>
        </trans-unit>
        <trans-unit id="a207991a7d026174ee51a8481f0b776cbc48b6ea" translate="yes" xml:space="preserve">
          <source>As a last resort, however:</source>
          <target state="translated">然而,作为最后的手段。</target>
        </trans-unit>
        <trans-unit id="3ab2161dda92a73d5893b103484d832131038b70" translate="yes" xml:space="preserve">
          <source>As a last resort, you can use the perl one-liner:</source>
          <target state="translated">作为最后的手段,你可以使用perl单行本。</target>
        </trans-unit>
        <trans-unit id="9a117b27b5618d5856aaaf26d908e957a310a377" translate="yes" xml:space="preserve">
          <source>As a last resort, you could also use &lt;code&gt;PERL5DB&lt;/code&gt; to customize the debugger by directly setting internal variables or calling debugger functions.</source>
          <target state="translated">作为最后的选择，您还可以使用 &lt;code&gt;PERL5DB&lt;/code&gt; 通过直接设置内部变量或调用调试器函数来定制调试器。</target>
        </trans-unit>
        <trans-unit id="3641087c3ef51813afe729b7c79e589f770bbb23" translate="yes" xml:space="preserve">
          <source>As a matter of policy we do &lt;b&gt;not&lt;/b&gt; edit the history of the blead and maint-* branches. If a typo (or worse) sneaks into a commit to blead or maint-*, we'll fix it in another commit. The only types of updates allowed on these branches are &quot;fast-forwards&quot;, where all history is preserved.</source>
          <target state="translated">出于政策考虑，我们&lt;b&gt;不&lt;/b&gt;编辑blead和maint- *分支的历史记录。如果输入错误（或更糟糕的情况）潜入了对blead或maint- *的提交中，我们将在另一个提交中对其进行修复。这些分支上唯一允许的更新类型是&amp;ldquo;快进&amp;rdquo;，其中保留了所有历史记录。</target>
        </trans-unit>
        <trans-unit id="04cbbe97dbf5020460c7615ae57692f7d59ba371" translate="yes" xml:space="preserve">
          <source>As a nonstandard extension to the JSON syntax that is enabled by the &lt;code&gt;relaxed&lt;/code&gt; setting, shell-style comments are allowed. They can start anywhere outside strings and go till the end of the line.</source>
          <target state="translated">作为 &lt;code&gt;relaxed&lt;/code&gt; 设置启用的JSON语法的非标准扩展，允许使用shell样式的注释。他们可以在字符串之外的任何地方开始，直到行的结尾。</target>
        </trans-unit>
        <trans-unit id="46efdbcc9fcabaefc1ffd7ba61888d42081d0818" translate="yes" xml:space="preserve">
          <source>As a noun, a piece of syntax made up of smaller pieces. As a transitive verb, to create an &lt;b&gt;object&lt;/b&gt; using a &lt;b&gt;constructor&lt;/b&gt;.</source>
          <target state="translated">作为名词，一种语法由较小的部分组成。作为及物动词，使用&lt;b&gt;构造函数&lt;/b&gt;创建&lt;b&gt;对象&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d308f1d2a7a4e49c9b329da294e48e6b1847ac8e" translate="yes" xml:space="preserve">
          <source>As a qr// compiled regular expression, e.g.:</source>
          <target state="translated">作为一个qr//编译的正则表达式,例如:。</target>
        </trans-unit>
        <trans-unit id="3f0cb7718076aa901719a5347944ab158c02cce2" translate="yes" xml:space="preserve">
          <source>As a result of these problems, starting in v5.20, what Perl does is to treat non-Unicode code points as just typical unassigned Unicode characters, and matches accordingly. (Note: Unicode has atypical unassigned code points. For example, it has noncharacter code points, and ones that, when they do get assigned, are destined to be written Right-to-left, as Arabic and Hebrew are. Perl assumes that no non-Unicode code point has any atypical properties.)</source>
          <target state="translated">由于这些问题,从v5.20开始,Perl所做的是将非Unicode码点视为典型的未分配Unicode字符,并进行相应的匹配。(注:Unicode有非典型的未分配码点。例如,它有一些非字符码点,而且当它们被分配时,注定要从右到左书写,就像阿拉伯语和希伯来语一样。Perl假设非Unicode码点没有任何非典型属性)。)</target>
        </trans-unit>
        <trans-unit id="dd723ff09f0dfd75022fcfe75451c37784da18b7" translate="yes" xml:space="preserve">
          <source>As a result, &lt;code&gt;$?&lt;/code&gt; will always be zero if the subprocess's exit status indicated successful completion, and non-zero if a warning or error occurred or a program compliant with encoding _POSIX_EXIT values was run and set a status.</source>
          <target state="translated">结果， &lt;code&gt;$?&lt;/code&gt; 如果子进程的退出状态指示成功完成，则将始终为零；如果发生警告或错误，或者运行了符合_POSIX_EXIT编码值的程序并设置了状态，则该值将始终为零。</target>
        </trans-unit>
        <trans-unit id="c26b5ebaa65b4ac15b7d233c58e1a9bb61162748" translate="yes" xml:space="preserve">
          <source>As a scalar operator:</source>
          <target state="translated">作为一个标量运算符。</target>
        </trans-unit>
        <trans-unit id="752c53cfef8630f9f583dd0b9dbea60f05156327" translate="yes" xml:space="preserve">
          <source>As a shortcut &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; can be written &lt;code&gt;(*:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="translated">作为快捷方式 &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; 可以被编写 &lt;code&gt;(*:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8274ec69a734737beb00f3f5313b731efea1dc76" translate="yes" xml:space="preserve">
          <source>As a shortcut &lt;code&gt;(*MARK:NAME)&lt;/code&gt; can be written &lt;code&gt;(*:NAME)&lt;/code&gt;.</source>
          <target state="translated">作为快捷方式 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 可以写为 &lt;code&gt;(*:NAME)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b9a135b5dd5e3840c9d7b2126bd8f1513618105" translate="yes" xml:space="preserve">
          <source>As a shortcut a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</source>
          <target state="translated">作为一个快捷方式,单参数调用从与文件柄同名的全局标量变量中获取文件名。</target>
        </trans-unit>
        <trans-unit id="039d51ec286cc421077f33a0f875e9f7cff415a2" translate="yes" xml:space="preserve">
          <source>As a shortcut, a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</source>
          <target state="translated">作为一个快捷方式,一个参数调用从与filehandle同名的全局标量变量中获取文件名。</target>
        </trans-unit>
        <trans-unit id="9baecd622ad6ae8ccb368a1f47c6a9f4ae3fac55" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can use the module &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;:</source>
          <target state="translated">作为快捷方式，您可以使用模块&lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="36ff34b524a3157846677e62919073347584851b" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can use the module &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;:</source>
          <target state="translated">作为快捷方式，您可以使用模块&lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="5b3e1134bf3b8109ecb5762080e2eff8e1996cc6" translate="yes" xml:space="preserve">
          <source>As a side effect, as &lt;code&gt;_&lt;/code&gt; doesn't work, stacked filetest operators (&lt;code&gt;-f -w $file&lt;/code&gt; ) won't work either.</source>
          <target state="translated">副作用是，由于 &lt;code&gt;_&lt;/code&gt; 不起作用，所以堆栈 &lt;code&gt;-f -w $file&lt;/code&gt; 测试运算符（-f -w $ file）也将不起作用。</target>
        </trans-unit>
        <trans-unit id="62159e969c4500e73917688c4b98b60605e2b166" translate="yes" xml:space="preserve">
          <source>As a side effect, as &lt;code&gt;_&lt;/code&gt; doesn't work, stacked filetest operators (&lt;code&gt;-f -w $file&lt;/code&gt;) won't work either.</source>
          <target state="translated">副作用是，由于 &lt;code&gt;_&lt;/code&gt; 不起作用，所以堆栈 &lt;code&gt;-f -w $file&lt;/code&gt; 测试运算符（-f -w $ file）也将不起作用。</target>
        </trans-unit>
        <trans-unit id="46d4d9254656022c6da49a40120c1e05ea2c02db" translate="yes" xml:space="preserve">
          <source>As a side effect, calling &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt;) before yielding the keys. In particular, calling &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; in void context resets the iterator with no other overhead.</source>
          <target state="translated">作为副作用，调用&lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;重置HASH或ARRAY的内部迭代（见&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;产生键之前）。特别是，在void上下文中调用&lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;重置迭代器，而没有其他开销。</target>
        </trans-unit>
        <trans-unit id="2e28725785d22d9074c048ed573cb348e22b3201" translate="yes" xml:space="preserve">
          <source>As a side effect, calling &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; resets the HASH or ARRAY's internal iterator (see &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt;) before yielding the values. In particular, calling &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; in void context resets the iterator with no other overhead.</source>
          <target state="translated">副作用是，调用&lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;在产生值之前重置HASH或ARRAY的内部迭代器（请参阅&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;）。特别是，在void上下文中调用&lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;重置迭代器，而没有其他开销。</target>
        </trans-unit>
        <trans-unit id="e67c2575fdaa4cadca39640f540c5c1c25ff2b7b" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">作为副作用，呼叫键（）复位的HASH或ARRAY的内部迭代（见&lt;a href=&quot;#each&quot;&gt;各&lt;/a&gt;）。特别是，在void上下文中调用keys（）会重置迭代器，而不会产生其他开销。</target>
        </trans-unit>
        <trans-unit id="c7b3fa9f58a42d510ccd961956edd3b53e1d0c57" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">作为副作用，呼叫键（）复位的HASH或ARRAY的内部迭代（见&lt;a href=&quot;each&quot;&gt;各&lt;/a&gt;）。特别是，在void上下文中调用keys（）会重置迭代器，而不会产生其他开销。</target>
        </trans-unit>
        <trans-unit id="aa184b78eeef36fa29a1577f9bf8458234354229" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">作为副作用，调用values（）会重置HASH或ARRAY的内部迭代器，请参见&lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;。 （特别是，在void上下文中调用values（）不会重置其他迭代器。除了重置迭代器之外，列表上下文中的 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;functions/values&quot;&gt;值&lt;/a&gt;与普通 &lt;code&gt;@array&lt;/code&gt; 相同。（我们建议您使用void上下文 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; 为此，但是有理由认为，将 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;functions/values&quot;&gt;值&lt;/a&gt;取出来比将其保留下来需要更多的文档。）</target>
        </trans-unit>
        <trans-unit id="a91a0923e5abea890fdc2bd22bb84126ade104fe" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">作为副作用，调用values（）会重置HASH或ARRAY的内部迭代器，请参见&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;。 （特别是，在void上下文中调用values（）不会重置其他迭代器。除了重置迭代器之外，列表上下文中的 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;values&quot;&gt;值&lt;/a&gt;与普通 &lt;code&gt;@array&lt;/code&gt; 相同。（我们建议您使用void上下文 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; 为此，但是有理由认为，将 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;values&quot;&gt;值&lt;/a&gt;取出来比将其保留下来需要更多的文档。）</target>
        </trans-unit>
        <trans-unit id="af3e12604d06f443cb762354f1d6409bffc768b2" translate="yes" xml:space="preserve">
          <source>As a side effect, the timestamps of the written specfiles reflect the linear order of all dependencies.</source>
          <target state="translated">作为一个副作用,写入规范文件的时间戳反映了所有依赖关系的线性顺序。</target>
        </trans-unit>
        <trans-unit id="cb674c50cbe5a1c37b1e7edbe788950bfe9342b0" translate="yes" xml:space="preserve">
          <source>As a simple string.</source>
          <target state="translated">作为一个简单的字符串。</target>
        </trans-unit>
        <trans-unit id="e8e57a1c04bdc517b9206bb149b8d52cd1b60750" translate="yes" xml:space="preserve">
          <source>As a special case</source>
          <target state="translated">作为一种特殊情况</target>
        </trans-unit>
        <trans-unit id="0643313e18655a38535055ff2dedcaffb5a9d742" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;, the empty pattern given in &lt;a href=&quot;perlop#m%2FPATTERN%2Fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt;) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">作为&lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt; &lt;code&gt;split&lt;/code&gt; 的&lt;/a&gt;一种特殊情况，&lt;a href=&quot;perlop#m%2FPATTERN%2Fmsixpodualngc&quot;&gt;匹配运算符&lt;/a&gt;语法（ &lt;code&gt;//&lt;/code&gt; ）中给出的空模式专门匹配空字符串，这与通常将其解释为最后一次成功匹配相反。</target>
        </trans-unit>
        <trans-unit id="17ea6c6f4727b11c2b48648599d60dd30f72b5e8" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">作为 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 的一种特殊情况，&lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;匹配运算符&lt;/a&gt;语法（ &lt;code&gt;//&lt;/code&gt; ）中给出的空模式专门匹配空字符串，这与通常将其解释为最后一次成功匹配相反。</target>
        </trans-unit>
        <trans-unit id="59db895ceb1feffbf61c972fbfef8ae7b61e3fff" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">作为 &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 的一种特殊情况，&lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;匹配运算符&lt;/a&gt;语法（ &lt;code&gt;//&lt;/code&gt; ）中给出的空模式专门匹配空字符串，这与通常将其解释为最后一次成功匹配相反。</target>
        </trans-unit>
        <trans-unit id="527a25823c5b741d3ca1303c6cacef3dfa61f467" translate="yes" xml:space="preserve">
          <source>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you're likely to get something that looks like &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; .</source>
          <target state="translated">在特殊情况下，如果重载返回对象本身，则将直接使用它。返回该对象的重载转换可能是一个错误，因为您可能会看到类似 &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="a27c6716a696c868b2b90bc0841f6de8cd23a521" translate="yes" xml:space="preserve">
          <source>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you're likely to get something that looks like &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt;.</source>
          <target state="translated">作为特殊情况，如果重载返回对象本身，则将直接使用它。返回该对象的重载转换可能是一个错误，因为您可能会看到类似 &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="6b483703a04a580981cff65069d8ecd06f49d995" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">作为一种特殊情况，具有读/写模式的三参数形式，而第三参数为&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="898fa8e40ea8bbaf82f7657e12c724a39a6b933a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">作为特殊情况，具有读/写模式的三参数形式，而第三参数为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bfe8944e96951a5268014155bb5ff3707aad862a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">作为特殊情况，具有读/写模式的三参数形式，而第三参数为 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="39d0f95cc62f9b7d251ca80f498d915dd0b1187f" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;\(@foo)&lt;/code&gt; returns a list of references to the contents of &lt;code&gt;@foo&lt;/code&gt; , not a reference to &lt;code&gt;@foo&lt;/code&gt; itself. Likewise for &lt;code&gt;%foo&lt;/code&gt; , except that the key references are to copies (since the keys are just strings rather than full-fledged scalars).</source>
          <target state="translated">作为一种特殊情况， &lt;code&gt;\(@foo)&lt;/code&gt; 返回一个对 &lt;code&gt;@foo&lt;/code&gt; 内容的引用列表，而不是对 &lt;code&gt;@foo&lt;/code&gt; 本身的引用。与 &lt;code&gt;%foo&lt;/code&gt; 相似，除了键引用是对副本的引用（因为键只是字符串而不是完整的标量）。</target>
        </trans-unit>
        <trans-unit id="783b2ec5714a2b5973ee8fd00ae088eee54cd571" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;\(@foo)&lt;/code&gt; returns a list of references to the contents of &lt;code&gt;@foo&lt;/code&gt;, not a reference to &lt;code&gt;@foo&lt;/code&gt; itself. Likewise for &lt;code&gt;%foo&lt;/code&gt;, except that the key references are to copies (since the keys are just strings rather than full-fledged scalars).</source>
          <target state="translated">作为一种特殊情况， &lt;code&gt;\(@foo)&lt;/code&gt; 返回一个对 &lt;code&gt;@foo&lt;/code&gt; 内容的引用列表，而不是对 &lt;code&gt;@foo&lt;/code&gt; 本身的引用。与 &lt;code&gt;%foo&lt;/code&gt; 相似，除了键引用是副本（因为键只是字符串而不是完整的标量）。</target>
        </trans-unit>
        <trans-unit id="e559b691f686abba65a2b1bdefbe0a3fb92d6845" translate="yes" xml:space="preserve">
          <source>As a special case, if the constructor is passed a single argument (as opposed to an even-sized list of key/value pairs), it is taken to be the value of the &lt;code&gt;PeerAddr&lt;/code&gt; parameter. This is parsed in the same way, according to the behaviour given in the &lt;code&gt;PeerHost&lt;/code&gt; AND &lt;code&gt;LocalHost&lt;/code&gt; PARSING section below.</source>
          <target state="translated">作为一种特殊情况，如果向构造函数传递单个参数（与键/值对的偶数大小列表相对），则将其视为 &lt;code&gt;PeerAddr&lt;/code&gt; 参数的值。根据下面的 &lt;code&gt;PeerHost&lt;/code&gt; 和 &lt;code&gt;LocalHost&lt;/code&gt; 解析部分中给出的行为，以相同的方式对此进行解析。</target>
        </trans-unit>
        <trans-unit id="9d3b4ecbd7d509c41643f820908fd45c356bb919" translate="yes" xml:space="preserve">
          <source>As a special case, if the test in the &lt;code&gt;for&lt;/code&gt; loop (or the corresponding &lt;code&gt;while&lt;/code&gt; loop) is empty, it is treated as true. That is, both</source>
          <target state="translated">作为一种特殊情况，如果 &lt;code&gt;for&lt;/code&gt; 循环（或相应的 &lt;code&gt;while&lt;/code&gt; 循环）中的测试为空，则将其视为true。也就是说，两者</target>
        </trans-unit>
        <trans-unit id="07d1fa15ef1af04fe7ac16e1712ceb861430b28a" translate="yes" xml:space="preserve">
          <source>As a special case, if the value of this variable is space-separated, the tail might be used to disable the ornaments by setting the tail to be &lt;code&gt;o=0&lt;/code&gt; or &lt;code&gt;ornaments=0&lt;/code&gt; . The head should be as described above, say</source>
          <target state="translated">作为特殊情况，如果此变量的值以空格分隔，则可以通过将尾部设置为 &lt;code&gt;o=0&lt;/code&gt; 或 &lt;code&gt;ornaments=0&lt;/code&gt; 来使用尾部来禁用装饰。头部应该如上所述，例如</target>
        </trans-unit>
        <trans-unit id="ea8552b1560e05c9733562fefc877a4a04a62b1f" translate="yes" xml:space="preserve">
          <source>As a special case, if the value of this variable is space-separated, the tail might be used to disable the ornaments by setting the tail to be &lt;code&gt;o=0&lt;/code&gt; or &lt;code&gt;ornaments=0&lt;/code&gt;. The head should be as described above, say</source>
          <target state="translated">在特殊情况下，如果此变量的值以空格分隔，则可以通过将尾部设置为 &lt;code&gt;o=0&lt;/code&gt; 或 &lt;code&gt;ornaments=0&lt;/code&gt; 来使用尾部来禁用装饰。头部应该如上所述，例如</target>
        </trans-unit>
        <trans-unit id="0fde23ad411d5b9ebf1966fbf214f46640cb22f9" translate="yes" xml:space="preserve">
          <source>As a special case, if you specify the module name &lt;code&gt;Unicode&lt;/code&gt; , you'll get the version number of the Unicode Character Database bundled with the requested perl versions.</source>
          <target state="translated">作为特殊情况，如果指定模块名称 &lt;code&gt;Unicode&lt;/code&gt; ，则将获得与请求的perl版本捆绑在一起的Unicode字符数据库的版本号。</target>
        </trans-unit>
        <trans-unit id="ed0f26789d5db7e7c0ccec99b141a92d811bb2de" translate="yes" xml:space="preserve">
          <source>As a special case, if you specify the module name &lt;code&gt;Unicode&lt;/code&gt;, you'll get the version number of the Unicode Character Database bundled with the requested perl versions.</source>
          <target state="translated">作为一种特殊情况，如果指定模块名称 &lt;code&gt;Unicode&lt;/code&gt; ，则将获得与请求的perl版本捆绑在一起的Unicode字符数据库的版本号。</target>
        </trans-unit>
        <trans-unit id="03f58faea796a1077f97500a4e213c983487f04c" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with a hash reference as the sole argument, this causes an assignment of the whole hash element. The object reference is returned.</source>
          <target state="translated">作为一种特殊的情况,当调用访问器时,将哈希引用作为唯一的参数,这会导致整个哈希元素的赋值。对象引用会被返回。</target>
        </trans-unit>
        <trans-unit id="d80964d39654d27c73a60223b4ebc15d6e6b2f91" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with an array reference as the sole argument, this causes an assignment of the whole array element. The object reference is returned.</source>
          <target state="translated">作为一种特殊情况,当访问器被调用时,唯一的参数是一个数组引用,这会导致整个数组元素的赋值。对象引用被返回。</target>
        </trans-unit>
        <trans-unit id="261536d85ff532107bd0e6c855c28c78277c6b3c" translate="yes" xml:space="preserve">
          <source>As a special exception, when you slice a list (but not an array or a hash), if the list evaluates to empty, then taking a slice of that empty list will always yield the empty list in turn. Thus:</source>
          <target state="translated">作为一个特殊的例外,当你对一个列表(但不是数组或哈希)进行分片时,如果列表评估为空,那么对这个空列表进行分片总是会反过来产生空列表。因此。</target>
        </trans-unit>
        <trans-unit id="267a52b216bf364239047183b439e3e80275f9ef" translate="yes" xml:space="preserve">
          <source>As a vendor, you may have a requirement to backport security fixes beyond our 3 year support commitment. We can provide limited support and advice to you as you do so and, where possible will try to apply those patches to the relevant -maint branches in git, though we may or may not choose to make numbered releases or &quot;official&quot; patches available. Contact us at &amp;lt;perl5-security-report@perl.org&amp;gt; to begin that process.</source>
          <target state="translated">作为供应商，您可能需要将安全修复程序反向移植到我们3年的支持承诺范围之外。我们会在您这样做时为您提供有限的支持和建议，并且在可能的情况下，我们将尝试将这些补丁应用于git中相关的-maint分支，尽管我们可能会或可能不会选择提供编号的发行版或&amp;ldquo;官方&amp;rdquo;补丁。通过&amp;lt;perl5-security-report@perl.org&amp;gt;与我们联系以开始该过程。</target>
        </trans-unit>
        <trans-unit id="f4351851a4bb7c858433022e707056375232e54d" translate="yes" xml:space="preserve">
          <source>As a vendor, you may have a requirement to backport security fixes beyond our 3 year support commitment. We can provide limited support and advice to you as you do so and, where possible will try to apply those patches to the relevant -maint branches in git, though we may or may not choose to make numbered releases or &quot;official&quot; patches available. See &lt;a href=&quot;perlsec#SECURITY-VULNERABILITY-CONTACT-INFORMATION&quot;&gt;&quot;SECURITY VULNERABILITY CONTACT INFORMATION&quot; in perlsec&lt;/a&gt; for details on how to begin that process.</source>
          <target state="translated">作为供应商，您可能需要将安全修复程序反向移植到我们三年的支持承诺范围之外。我们会在您这样做时为您提供有限的支持和建议，并且在可能的情况下，我们将尝试将这些补丁应用到git中相关的-maint分支，尽管我们可能会或可能不会选择提供编号的发行版或&amp;ldquo;官方&amp;rdquo;补丁。有关如何开始该过程的详细信息，请参见&lt;a href=&quot;perlsec#SECURITY-VULNERABILITY-CONTACT-INFORMATION&quot;&gt;perlsec中的&amp;ldquo;安全漏洞联系信息&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b767e1ab5bdc22f58c69583808a39ce8aa5393a" translate="yes" xml:space="preserve">
          <source>As a volunteer organization, the commitments we make are heavily dependent on the goodwill and hard work of individuals who have no obligation to contribute to Perl.</source>
          <target state="translated">作为一个志愿者组织,我们所做的承诺在很大程度上依赖于那些没有义务为 Perl 做贡献的个人的善意和努力工作。</target>
        </trans-unit>
        <trans-unit id="b55a4625fdc844badd446c13482f0c20c8caa1b5" translate="yes" xml:space="preserve">
          <source>As above, but the destination node text of the link.</source>
          <target state="translated">同上,但链接的目的节点文字。</target>
        </trans-unit>
        <trans-unit id="07731660b460e18f03465884e08d802967534966" translate="yes" xml:space="preserve">
          <source>As all values evaluate to true, a simple &lt;code&gt;if&lt;/code&gt; test is good enough to determine whether an extension is present.</source>
          <target state="translated">当所有值均评估为true时，简单的 &lt;code&gt;if&lt;/code&gt; 测试足以确定是否存在扩展。</target>
        </trans-unit>
        <trans-unit id="049e8d249c3ad3a2a8b180055568baa12252b047" translate="yes" xml:space="preserve">
          <source>As alluded to earlier you can also declare inlined subs dynamically at BEGIN time if their body consists of a lexically-scoped scalar which has no other references. Only the first example here will be inlined:</source>
          <target state="translated">如前所述,如果内联子的主体由一个没有其他引用的词法范围标量组成,你也可以在begin时动态声明内联子。这里只有第一个例子会被内联。</target>
        </trans-unit>
        <trans-unit id="40622c1595c0e7b33c82f810ddadd26599013393" translate="yes" xml:space="preserve">
          <source>As alternatives to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; when used for control flow, Perl provides the &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators (see below). The short-circuit behavior is identical. The precedence of &lt;code&gt;&quot;and&quot;&lt;/code&gt; and &lt;code&gt;&quot;or&quot;&lt;/code&gt; is much lower, however, so that you can safely use them after a list operator without the need for parentheses:</source>
          <target state="translated">作为 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 的替代 当用于控制流时，Perl提供 &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;or&lt;/code&gt; 运算符（请参见下文）。短路行为是相同的。但是， &lt;code&gt;&quot;and&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 的优先级要低得多，因此您可以在列表运算符之后安全地使用它们，而无需括号：</target>
        </trans-unit>
        <trans-unit id="c44b3a4add0c470afd83290fbaea5d47d3bf3bcb" translate="yes" xml:space="preserve">
          <source>As always with Perl there is more than one way to do it. Below are a few examples of approaches to making common conversions between number representations. This is intended to be representational rather than exhaustive.</source>
          <target state="translated">和Perl一样,有不止一种方法可以做到。下面是一些在数字表示法之间进行常见转换的方法的例子。这是为了表示而不是详尽的。</target>
        </trans-unit>
        <trans-unit id="a27e8bc51d6a9b14b4e2235fdc7ebedf28d134bc" translate="yes" xml:space="preserve">
          <source>As always, if any of these are ever officially declared as bugs, they'll be fixed and removed.</source>
          <target state="translated">和往常一样,如果有任何一个被官方宣布为bug,它们将被修复和删除。</target>
        </trans-unit>
        <trans-unit id="43d8cae7f79fc634e42b4fbb6869d40983003e1e" translate="yes" xml:space="preserve">
          <source>As always, setting up a server is little bit more involved than running a client. The model is that the server creates a special kind of socket that does nothing but listen on a particular port for incoming connections. It does this by calling the &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; method with slightly different arguments than the client did.</source>
          <target state="translated">与往常一样，设置服务器比运行客户端要复杂得多。该模型是服务器创建一种特殊的套接字，该套接字除了在特定端口上侦听传入连接外什么也不做。它通过调用 &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; 方法来实现此目的，该方法的参数与客户端的参数略有不同。</target>
        </trans-unit>
        <trans-unit id="b052d1d2bb45ec362535f92deef9adc1abd8b3f0" translate="yes" xml:space="preserve">
          <source>As an (ahem) accidental feature, &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines were looked up as methods (using the &lt;code&gt;@ISA&lt;/code&gt; hierarchy) even when the subroutines to be autoloaded were called as plain functions (e.g. &lt;code&gt;Foo::bar()&lt;/code&gt;), not as methods (e.g. &lt;code&gt;Foo-&amp;gt;bar()&lt;/code&gt; or &lt;code&gt;$obj-&amp;gt;bar()&lt;/code&gt;).</source>
          <target state="translated">作为（偶然的）偶然特性，即使将要自动加载的子例程称为普通函数（例如 &lt;code&gt;Foo::bar()&lt;/code&gt; ），而不是方法（例如 &lt;code&gt;Foo-&amp;gt;bar()&lt;/code&gt; ），也会将 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子例程作为方法（使用 &lt;code&gt;@ISA&lt;/code&gt; 层次结构）进行查找。-&amp;gt; bar（）或 &lt;code&gt;$obj-&amp;gt;bar()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="90ed318055b1f6119d9ba187aa6944aea5c29dbe" translate="yes" xml:space="preserve">
          <source>As an added convenience, the Digest::SHA module offers routines to calculate keyed hashes using the HMAC-SHA-1/224/256/384/512 algorithms. These services exist in functional form only, and mimic the style and behavior of the</source>
          <target state="translated">作为一个额外的方便,Digest::SHA模块提供了使用HMAC-SHA-1/224/256/384/512算法计算密钥哈希的例程。这些服务仅以功能形式存在,并且模仿了HMAC-SHA-1/224/256/384/512算法的风格和行为。</target>
        </trans-unit>
        <trans-unit id="d0e4684ebfef4659c7147a264548f0d1e61303df" translate="yes" xml:space="preserve">
          <source>As an aid in resetting colors, colored() takes a scalar as the first argument and any number of attribute strings as the second argument and returns the scalar wrapped in escape codes so that the attributes will be set as requested before the string and reset to normal after the string. Alternately, you can pass a reference to an array as the first argument, and then the contents of that array will be taken as attributes and color codes and the remainder of the arguments as text to colorize.</source>
          <target state="translated">作为重置颜色的辅助工具,colored()将一个标量作为第一个参数,将任意数量的属性字符串作为第二个参数,并返回用转义码包装的标量,这样属性将在字符串之前按要求设置,并在字符串之后重置为正常。或者,你可以传递一个数组的引用作为第一个参数,然后这个数组的内容将被当作属性和颜色代码,其余的参数将被当作文本进行着色。</target>
        </trans-unit>
        <trans-unit id="0317f97de63b01d4c67910fb17a2e6ee0d204ecf" translate="yes" xml:space="preserve">
          <source>As an alternative to subclassing the components I need to change I can attach callbacks to the default classes. TAP::Harness exposes these callbacks:</source>
          <target state="translated">作为一个替代方案,我可以将需要改变的组件子类化,我可以将回调附加到默认的类中。TAP::Harness公开了这些回调。</target>
        </trans-unit>
        <trans-unit id="9c1670ab0bb7042a354367f8f6979cab460d9b35" translate="yes" xml:space="preserve">
          <source>As an alternative to the above, you may prefer to throw exceptions using the Error module.</source>
          <target state="translated">作为上述方法的替代方案,你可能更喜欢使用Error模块来抛出异常。</target>
        </trans-unit>
        <trans-unit id="8f3dc04daa3638b5aaf1c862a68465a157788d9e" translate="yes" xml:space="preserve">
          <source>As an alternative to the named parameters usage, you may pass in an &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; object as first argument, a copy of which will be added to the typemap. In that case, only the &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt; named parameters may be used after the object. Example:</source>
          <target state="translated">作为命名参数用法的替代方法，您可以传入 &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; 对象作为第一个参数，该对象的副本将添加到typemap中。在那种情况下，仅 &lt;code&gt;replace&lt;/code&gt; 或 &lt;code&gt;skip&lt;/code&gt; 命名参数可以在对象之后使用。例子：</target>
        </trans-unit>
        <trans-unit id="f943c4f68c18459667f13d0990dfceca7c5ca2a9" translate="yes" xml:space="preserve">
          <source>As an alternative to the named parameters usage, you may pass in an &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; object as first argument, a copy of which will be added to the typemap. In that case, only the &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt; named parameters may be used after the object. Example:</source>
          <target state="translated">作为命名参数用法的替代方法，您可以传入 &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; 对象作为第一个参数，该对象的副本将添加到typemap中。在那种情况下，仅 &lt;code&gt;replace&lt;/code&gt; 或 &lt;code&gt;skip&lt;/code&gt; 命名参数可以在对象之后使用。例子：</target>
        </trans-unit>
        <trans-unit id="782eb5f652231f0fff9e780cbf2fef47e3527def" translate="yes" xml:space="preserve">
          <source>As an alternative, overloaded constants (see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;) provide a simple way to extend the functionality of the RE engine, by substituting one pattern for another.</source>
          <target state="translated">作为替代，重载常量（请参见&lt;a href=&quot;overload&quot;&gt;重载&lt;/a&gt;）提供了一种简单的方法，可以通过用一种模式替换另一种模式来扩展RE引擎的功能。</target>
        </trans-unit>
        <trans-unit id="18772395363d0e88e55df307a43fbfe2be745eba" translate="yes" xml:space="preserve">
          <source>As an alternative, specify a number instead of list of letters (e.g., &lt;b&gt;-D14&lt;/b&gt; is equivalent to &lt;b&gt;-Dtls&lt;/b&gt;):</source>
          <target state="translated">或者，指定数字而不是字母列表（例如，&lt;b&gt;-D14&lt;/b&gt;等效于&lt;b&gt;-Dtls&lt;/b&gt;）：</target>
        </trans-unit>
        <trans-unit id="8f4ba5d9ceee180216d44c33a248904b28bf93a4" translate="yes" xml:space="preserve">
          <source>As an alternative, to keep the case of the replacement word if it is longer than the original, you can use this code, by Jeff Pinyan:</source>
          <target state="translated">作为一个替代方案,如果替换的单词比原来的单词长,你可以使用Jeff Pinyan的这个代码来保留它的大小写。</target>
        </trans-unit>
        <trans-unit id="b70856a89ed6672d06c69a35074c3c6f2093e9dd" translate="yes" xml:space="preserve">
          <source>As an example consider the structure of a zip file. This is a well-defined file format that mixes both compressed and uncompressed sections of data in a single file.</source>
          <target state="translated">举个例子,考虑一个zip文件的结构。这是一种定义明确的文件格式,它将数据的压缩和非压缩部分混合在一个文件中。</target>
        </trans-unit>
        <trans-unit id="edc86b424441622df9f0c07df7eb59f80cab5da3" translate="yes" xml:space="preserve">
          <source>As an example of something that is caught under &lt;code&gt;&quot;strict'&lt;/code&gt; , but not otherwise, is the pattern</source>
          <target state="translated">例如，模式在 &lt;code&gt;&quot;strict'&lt;/code&gt; 下被捕获，但在其他情况下没有被捕获</target>
        </trans-unit>
        <trans-unit id="ec5fbaf06c5491bc9e0146955b6b1bccb85f04a8" translate="yes" xml:space="preserve">
          <source>As an example of something that is caught under &lt;code&gt;&quot;strict'&lt;/code&gt;, but not otherwise, is the pattern</source>
          <target state="translated">例如，模式在 &lt;code&gt;&quot;strict'&lt;/code&gt; 下被捕获，但在其他情况下没有被捕获</target>
        </trans-unit>
        <trans-unit id="52b1b17f0c5a778dad149ae64ff9d232a5d6120e" translate="yes" xml:space="preserve">
          <source>As an example of this case, this code prints the message &quot;Perl exited with active threads: 2 running and unjoined&quot;:</source>
          <target state="translated">以这种情况为例,这段代码打印了 &quot;Perl退出,有活动线程。2个线程正在运行且未连接&quot;。</target>
        </trans-unit>
        <trans-unit id="fd8cd6983452bdbcd828fbbb431f9c0eaf4c793d" translate="yes" xml:space="preserve">
          <source>As an example where a possessive quantifier is suitable we consider matching a quoted string, as it appears in several programming languages. The backslash is used as an escape character that indicates that the next character is to be taken literally, as another character for the string. Therefore, after the opening quote, we expect a (possibly empty) sequence of alternatives: either some character except an unescaped quote or backslash or an escaped character.</source>
          <target state="translated">作为一个适合使用占位定量符的例子,我们考虑匹配一个引号字符串,因为它出现在几种编程语言中。反斜杠作为一个转义字符,表示下一个字符将被按字面意思理解,作为字符串的另一个字符。因此,在开头的引号之后,我们希望有一个(可能是空的)替代序列:除了未转义的引号或反斜线或转义字符之外的一些字符。</target>
        </trans-unit>
        <trans-unit id="5cd508967ae1e206046e267640fdf9448ece0fe7" translate="yes" xml:space="preserve">
          <source>As an example, let's implement a &lt;code&gt;THAW&lt;/code&gt; function that regenerates the &lt;code&gt;My::Object&lt;/code&gt; from the &lt;code&gt;FREEZE&lt;/code&gt; example earlier:</source>
          <target state="translated">作为示例，让我们实现一个 &lt;code&gt;THAW&lt;/code&gt; 函数，该函数从之前的 &lt;code&gt;FREEZE&lt;/code&gt; 示例中重新生成 &lt;code&gt;My::Object&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="82731324b346859b9bccf9603560116021199d53" translate="yes" xml:space="preserve">
          <source>As an example, when Perl sees &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; , it encodes the character in UTF-8 and stores it in $x. Then it is marked as character data, so, for instance, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; . However, in the scope of the &lt;code&gt;bytes&lt;/code&gt; pragma, $x is treated as a series of bytes - the bytes that make up the UTF8 encoding - and &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt; :</source>
          <target state="translated">例如，当Perl看到 &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; ，它将字符编码为UTF-8并将其存储在$ x中。然后将其标记为字符数据，例如， &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt; 。但是，在 &lt;code&gt;bytes&lt;/code&gt; 编译指示的范围内，$ x被视为一系列字节-组成UTF8编码的字节- &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; 返回 &lt;code&gt;2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4cc20e99e2c8e44ee448eca66f36aaad208e30f4" translate="yes" xml:space="preserve">
          <source>As an example, when Perl sees &lt;code&gt;$x = chr(400)&lt;/code&gt;, it encodes the character in UTF-8 and stores it in &lt;code&gt;$x&lt;/code&gt;. Then it is marked as character data, so, for instance, &lt;code&gt;length $x&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;. However, in the scope of the &lt;code&gt;bytes&lt;/code&gt; pragma, &lt;code&gt;$x&lt;/code&gt; is treated as a series of bytes - the bytes that make up the UTF8 encoding - and &lt;code&gt;length $x&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;:</source>
          <target state="translated">例如，当Perl看到 &lt;code&gt;$x = chr(400)&lt;/code&gt; ，它将字符编码为UTF-8并将其存储在 &lt;code&gt;$x&lt;/code&gt; 。然后将其标记为字符数据，例如， &lt;code&gt;length $x&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt; 。但是，在 &lt;code&gt;bytes&lt;/code&gt; 编译指示的范围内， &lt;code&gt;$x&lt;/code&gt; 被视为一系列字节-组成UTF8编码的字节- &lt;code&gt;length $x&lt;/code&gt; 返回 &lt;code&gt;2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c313609d4ce2bde8a8cf3d1a920bc018f88eebaa" translate="yes" xml:space="preserve">
          <source>As an interim measure, you may either change the #! line of your scripts to specifically refer to the old perl version, e.g. on Solaris 9 use #!/usr/perl5/5.00503/bin/perl to use the perl version that was the default for Solaris 8, or if you have a large number of scripts it may be more convenient to make the old version of perl the default on your system. You can do this by changing the appropriate symlinks under /usr/perl5 as follows (example for Solaris 9):</source>
          <target state="translated">作为一项临时措施,你可以修改你的脚本中的#!行来特别引用旧的perl版本,例如在Solaris 9上使用#!/usr/perl5/5.00503/bin/perl来使用Solaris 8的默认perl版本,或者如果你有大量的脚本,将旧版本的perl作为系统的默认版本可能会更方便。您可以通过修改/usr/perl5下的相应符号链接来实现这一目的,具体如下(Solaris 9的例子)。</target>
        </trans-unit>
        <trans-unit id="373576f861e30b7c81e25bff74bee6e23c15298c" translate="yes" xml:space="preserve">
          <source>As an optimization, may not call the command shell specified in &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; spawns an external process and immediately returns its process designator, without waiting for it to terminate. Return value may be used subsequently in &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;. Failure to &lt;code&gt;spawn()&lt;/code&gt; a subprocess is indicated by setting &lt;code&gt;$?&lt;/code&gt; to &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; . &lt;code&gt;$?&lt;/code&gt; is set in a way compatible with Unix (i.e. the exitstatus of the subprocess is obtained by &lt;code&gt;&quot;$?&lt;/code&gt; 8&quot;&amp;gt;&amp;gt;, as described in the documentation). (Win32)</source>
          <target state="translated">作为优化，不得调用 &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; 指定的命令外壳。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; 产生一个外部进程并立即返回其进程指示符，而无需等待其终止。随后可以在 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 中使用返回值。设置 &lt;code&gt;$?&lt;/code&gt; 表示未能 &lt;code&gt;spawn()&lt;/code&gt; 子进程。改为 &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; 。 &lt;code&gt;$?&lt;/code&gt; 设置与Unix兼容的方式（即子进程的exitstatus通过 &lt;code&gt;&quot;$?&lt;/code&gt; 8&amp;rdquo; &amp;gt;&amp;gt;获得，如文档中所述）。 （Win32的）</target>
        </trans-unit>
        <trans-unit id="137d06b82a3cf943b3082535121ce9ca48c386c5" translate="yes" xml:space="preserve">
          <source>As another example, this Pod source:</source>
          <target state="translated">再举个例子,这个花苞源。</target>
        </trans-unit>
        <trans-unit id="24dac5f3b0ae02bfc967e018bd163c71db2de949" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a string composed of a single space character (such as &lt;code&gt;' '&lt;/code&gt; or &lt;code&gt;&quot;\x20&quot;&lt;/code&gt;, but not e.g. &lt;code&gt;/ /&lt;/code&gt;). In this case, any leading whitespace in EXPR is removed before splitting occurs, and the PATTERN is instead treated as if it were &lt;code&gt;/\s+/&lt;/code&gt;; in particular, this means that</source>
          <target state="translated">作为另一种特殊情况，当省略PATTERN或由单个空格字符组成的字符串（例如 &lt;code&gt;' '&lt;/code&gt; 或 &lt;code&gt;&quot;\x20&quot;&lt;/code&gt; ，但不包括 &lt;code&gt;/ /&lt;/code&gt; ）时，&lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt;模拟命令行工具&lt;b&gt;awk&lt;/b&gt;的默认行为。在这种情况下，EXPR中的任何前导空格都在拆分之前被删除，而PATTERN则被视为 &lt;code&gt;/\s+/&lt;/code&gt; ；特别是，这意味着</target>
        </trans-unit>
        <trans-unit id="38474bdd192558dcfa688dfaf6e45817a6f595ea" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">作为另一种特殊情况，当省略PATTERN或使用a时， &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 模拟命令行工具&lt;b&gt;awk&lt;/b&gt;的默认行为。</target>
        </trans-unit>
        <trans-unit id="aab9f2eadc04a37e669ffc31217a1ec91df2a94d" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">作为另一种特殊情况，当省略PATTERN或使用a时， &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 模拟命令行工具&lt;b&gt;awk&lt;/b&gt;的默认行为。</target>
        </trans-unit>
        <trans-unit id="46ab5c6135652ee2c4d494e00004b3edd1c35481" translate="yes" xml:space="preserve">
          <source>As another workaround for this problem, Perl 5.10.0 introduced &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , which are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , &lt;b&gt;except&lt;/b&gt; that they are only guaranteed to be defined after a successful match that was executed with the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation char equivalents, however at the trade-off that you have to tell perl when you want to use them. As of Perl 5.20, these three variables are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , and &lt;code&gt;/p&lt;/code&gt; is ignored.</source>
          <target state="translated">作为解决此问题的另一种方法，Perl 5.10.0引入了 &lt;code&gt;${^PREMATCH}&lt;/code&gt; ， &lt;code&gt;${^MATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; ，它们等效于 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 和 &lt;code&gt;$'&lt;/code&gt; ，&lt;b&gt;只是&lt;/b&gt;它们只能保证在使用 &lt;code&gt;/p&lt;/code&gt; （保留）修饰符执行的成功匹配之后定义。与标点字符等效项不同，使用这些变量不会引起全局性能损失，但是要权衡取舍，当您要使用它们时必须告诉perl。从Perl 5.20开始，这三个变量等效于 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 和 &lt;code&gt;$'&lt;/code&gt; 以及 &lt;code&gt;/p&lt;/code&gt; 被忽略。</target>
        </trans-unit>
        <trans-unit id="5306125a9b9482228b73d9001504cb8ff0235e3b" translate="yes" xml:space="preserve">
          <source>As another workaround for this problem, Perl 5.10.0 introduced &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt;, which are equivalent to &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt;, &lt;b&gt;except&lt;/b&gt; that they are only guaranteed to be defined after a successful match that was executed with the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation character equivalents, however at the trade-off that you have to tell perl when you want to use them. As of Perl 5.20, these three variables are equivalent to &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt;, and &lt;code&gt;/p&lt;/code&gt; is ignored.</source>
          <target state="translated">作为解决此问题的另一种方法，Perl 5.10.0引入了 &lt;code&gt;${^PREMATCH}&lt;/code&gt; ， &lt;code&gt;${^MATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; ，它们等效于 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 和 &lt;code&gt;$'&lt;/code&gt; ，&lt;b&gt;只是&lt;/b&gt;它们只能保证在使用 &lt;code&gt;/p&lt;/code&gt; （保留）修饰符执行的成功匹配之后定义。与标点字符等效项不同，使用这些变量不会引起全局性能损失，但是要权衡取舍，当您要使用它们时必须告诉perl。从Perl 5.20开始，这三个变量等效于 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 和 &lt;code&gt;$'&lt;/code&gt; 以及 &lt;code&gt;/p&lt;/code&gt; 被忽略。</target>
        </trans-unit>
        <trans-unit id="faf1880e6e4e5e1670571e23b070295ae744c1fc" translate="yes" xml:space="preserve">
          <source>As described &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;above&lt;/a&gt;, Perl may call methods for operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in the course of implementing missing operations like &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; , and &lt;code&gt;&amp;amp;=&lt;/code&gt; . While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</source>
          <target state="translated">如所描述的&lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;上面&lt;/a&gt;，Perl中可能需要运营商等方法 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 在执行像丢失操作过程 &lt;code&gt;++&lt;/code&gt; ， &lt;code&gt;+=&lt;/code&gt; ，和 &lt;code&gt;&amp;amp;=&lt;/code&gt; 。尽管这些方法可以通过测试第三个参数的定义来检测这种用法，但它们在所有情况下都应避免更改其操作数。这是因为Perl在调用这些方法之前不会调用复制构造函数。</target>
        </trans-unit>
        <trans-unit id="20dd96aab8100e801c2698dbb8e487016840bd2c" translate="yes" xml:space="preserve">
          <source>As described &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;above&lt;/a&gt;, Perl may call methods for operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in the course of implementing missing operations like &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, and &lt;code&gt;&amp;amp;=&lt;/code&gt;. While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</source>
          <target state="translated">如所描述的&lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;上面&lt;/a&gt;，Perl中可能需要运营商等方法 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 在执行像丢失操作过程 &lt;code&gt;++&lt;/code&gt; ， &lt;code&gt;+=&lt;/code&gt; ，和 &lt;code&gt;&amp;amp;=&lt;/code&gt; 。尽管这些方法可以通过测试第三个参数的定义来检测这种用法，但它们在所有情况下都应避免更改其操作数。这是因为Perl在调用这些方法之前不会调用复制构造函数。</target>
        </trans-unit>
        <trans-unit id="e9c1d88156738ffdc72a22d4eb2c079c412ad705" translate="yes" xml:space="preserve">
          <source>As described earlier, if there are many changes on your smoke-me branch then you should prepare a merge commit in which to give an overview of those changes by using the following command instead of the last command above:</source>
          <target state="translated">如前所述,如果你的 smoke-me 分支上有很多变化,那么你应该准备一个合并提交,用下面的命令来代替上面的最后一条命令,来概述这些变化。</target>
        </trans-unit>
        <trans-unit id="6ff132deadaac51720c9e117548f044618ad0a39" translate="yes" xml:space="preserve">
          <source>As discussed elsewhere, Perl has one foot (two hooves?) planted in each of two worlds: the old world of ASCII and single-byte locales, and the new world of Unicode, upgrading when necessary. If your legacy code does not explicitly use Unicode, no automatic switch-over to Unicode should happen.</source>
          <target state="translated">正如在其他地方所讨论的那样,Perl 在两个世界中各安插了一只脚(两只蹄子?):旧世界的 ASCII 和单字节编码,以及新世界的 Unicode,并在必要时进行升级。如果你的遗留代码没有明确使用Unicode,就不应该自动切换到Unicode。</target>
        </trans-unit>
        <trans-unit id="3a28f6e945d7b1d8cd9440551fcd17f03dc59837" translate="yes" xml:space="preserve">
          <source>As explained above, an anonymous function with access to the lexical variables visible when that function was compiled, creates a closure. It retains access to those variables even though it doesn't get run until later, such as in a signal handler or a Tk callback.</source>
          <target state="translated">如上所述,一个匿名函数在编译时可以访问该函数可见的词法变量,它创建了一个闭包。它保留了对这些变量的访问权,即使它直到后来才被运行,比如在信号处理程序或Tk回调中。</target>
        </trans-unit>
        <trans-unit id="03fe8a37ea6c568501bcfeecc21187a67095c9a8" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;&quot;ASCII Rules versus Unicode Rules&quot;&lt;/a&gt;, under ASCII rules, they are considered to be unassigned characters.</source>
          <target state="translated">如&lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;&amp;ldquo; ASCII规则与Unicode规则&amp;rdquo;中所述&lt;/a&gt;，在ASCII规则下，它们被视为未分配的字符。</target>
        </trans-unit>
        <trans-unit id="de6278f8e877d258b1f62760a70228a073ba24fd" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules&lt;/a&gt;, under ASCII rules, they are considered to be unassigned characters.</source>
          <target state="translated">如&lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII规则和Unicode规则中所述&lt;/a&gt;，在ASCII规则下，它们被视为未分配的字符。</target>
        </trans-unit>
        <trans-unit id="48e236093008993b6e4def956b958d0cb620db14" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#prop_invlist%28%29&quot;&gt;&quot;prop_invlist()&quot;&lt;/a&gt;, whether a code point is in the list or not depends on if the index is even (in) or odd (not in). And as explained in &lt;a href=&quot;#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot;&lt;/a&gt;, the index is used with the returned parallel array to find the mapping.</source>
          <target state="translated">如&lt;a href=&quot;#prop_invlist%28%29&quot;&gt;&amp;ldquo; prop_invlist（）&amp;rdquo;中所述&lt;/a&gt;，代码点是否在列表中取决于索引是偶数（in）还是奇数（not in）。如&lt;a href=&quot;#prop_invmap%28%29&quot;&gt;&amp;ldquo; prop_invmap（）&amp;rdquo;&lt;/a&gt;中所述，索引与返回的并行数组一起使用以查找映射。</target>
        </trans-unit>
        <trans-unit id="8ffaa22d40c8f644f2c59a68a07b28bdf08a1f8a" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist()&lt;/a&gt;, whether a code point is in the list or not depends on if the index is even (in) or odd (not in). And as explained in &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap()&lt;/a&gt;, the index is used with the returned parallel array to find the mapping.</source>
          <target state="translated">如&lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist（）中所述&lt;/a&gt;，代码点是否在列表中取决于索引是偶数（in）还是奇数（not in）。并且如&lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap（）&lt;/a&gt;中所述，索引与返回的并行数组一起使用以查找映射。</target>
        </trans-unit>
        <trans-unit id="bf0e7abd7a09ee9c2ba9a8344c5b618840f66e79" translate="yes" xml:space="preserve">
          <source>As far as creating the &lt;code&gt;$pOverlapped&lt;/code&gt; structure, you are currently on your own.</source>
          <target state="translated">至于创建 &lt;code&gt;$pOverlapped&lt;/code&gt; 结构，您目前是一个人。</target>
        </trans-unit>
        <trans-unit id="101540b4758da815d4da97e60284cb84f98af97f" translate="yes" xml:space="preserve">
          <source>As for new features and requests to change common behaviors, please ask the author of JSON::XS (Marc Lehmann, &amp;lt;schmorp[at]schmorp.de&amp;gt;) first, by email (important!), to keep compatibility among JSON.pm backends.</source>
          <target state="translated">至于新功能和更改常见行为的请求，请首先通过电子邮件（重要！）要求JSON :: XS的作者（Marc Lehmann，&amp;lt;schmorp [at] schmorp.de&amp;gt;），以保持JSON.pm之间的兼容性。后端。</target>
        </trans-unit>
        <trans-unit id="c53e475afb32fdd8296f1c9a917ef2e75b376078" translate="yes" xml:space="preserve">
          <source>As for other operations, the subroutine implementing '=' is passed three arguments, though the last two are always &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;''&lt;/code&gt; .</source>
          <target state="translated">对于其他操作，实现'='的子例程传递了三个参数，尽管最后两个始终是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;''&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf65c0259648a27866b59740e85994dce5ffc5e7" translate="yes" xml:space="preserve">
          <source>As for other operations, the subroutine implementing '=' is passed three arguments, though the last two are always &lt;code&gt;undef&lt;/code&gt; and &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">至于其他操作，实现'='的子例程会传递三个参数，尽管最后两个始终是 &lt;code&gt;undef&lt;/code&gt; 和 &lt;code&gt;''&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cf2ef2540039c1386257379903eff22c20c0bad" translate="yes" xml:space="preserve">
          <source>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form &lt;code&gt;[:&lt;i&gt;name&lt;/i&gt;:]&lt;/code&gt;, with</source>
          <target state="translated">好像所有这些类还不够，Perl还定义了POSIX样式的字符类。这些格式为 &lt;code&gt;[:&lt;i&gt;name&lt;/i&gt;:]&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="2f54bd3297d1b4b8911e3de6ffd9e1ee35795e3c" translate="yes" xml:space="preserve">
          <source>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form &lt;code&gt;[:name:]&lt;/code&gt;, with &lt;code&gt;name&lt;/code&gt; the name of the POSIX class. The POSIX classes are &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , and &lt;code&gt;xdigit&lt;/code&gt; , and two extensions, &lt;code&gt;word&lt;/code&gt; (a Perl extension to match &lt;code&gt;\w&lt;/code&gt; ), and &lt;code&gt;blank&lt;/code&gt; (a GNU extension). The &lt;code&gt;//a&lt;/code&gt; modifier restricts these to matching just in the ASCII range; otherwise they can match the same as their corresponding Perl Unicode classes: &lt;code&gt;[:upper:]&lt;/code&gt; is the same as &lt;code&gt;\p{IsUpper}&lt;/code&gt; , etc. (There are some exceptions and gotchas with this; see &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; for a full discussion.) The &lt;code&gt;[:digit:]&lt;/code&gt;, &lt;code&gt;[:word:]&lt;/code&gt;, and &lt;code&gt;[:space:]&lt;/code&gt; correspond to the familiar &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , and &lt;code&gt;\s&lt;/code&gt; character classes. To negate a POSIX class, put a &lt;code&gt;^&lt;/code&gt; in front of the name, so that, e.g., &lt;code&gt;[:^digit:]&lt;/code&gt; corresponds to &lt;code&gt;\D&lt;/code&gt; and, under Unicode, &lt;code&gt;\P{IsDigit}&lt;/code&gt; . The Unicode and POSIX character classes can be used just like &lt;code&gt;\d&lt;/code&gt; , with the exception that POSIX character classes can only be used inside of a character class:</source>
          <target state="translated">好像所有这些类还不够，Perl还定义了POSIX样式的字符类。这些具有形式 &lt;code&gt;[:name:]&lt;/code&gt; ，具有 &lt;code&gt;name&lt;/code&gt; 的POSIX类的名称。 POSIX类是 &lt;code&gt;alpha&lt;/code&gt; ， &lt;code&gt;alnum&lt;/code&gt; ， &lt;code&gt;ascii&lt;/code&gt; ， &lt;code&gt;cntrl&lt;/code&gt; ， &lt;code&gt;digit&lt;/code&gt; ， &lt;code&gt;graph&lt;/code&gt; ， &lt;code&gt;lower&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;punct&lt;/code&gt; ， &lt;code&gt;space&lt;/code&gt; ， &lt;code&gt;upper&lt;/code&gt; 和 &lt;code&gt;xdigit&lt;/code&gt; ，以及两个扩展名： &lt;code&gt;word&lt;/code&gt; （匹配 &lt;code&gt;\w&lt;/code&gt; 的Perl扩展名）和 &lt;code&gt;blank&lt;/code&gt; （GNU扩展名） ）。该 &lt;code&gt;//a&lt;/code&gt; 修饰符将它们限制为仅在ASCII范围内匹配；否则它们可以在同一匹配它们相应的Perl的Unicode类： &lt;code&gt;[:upper:]&lt;/code&gt; 是相同的 &lt;code&gt;\p{IsUpper}&lt;/code&gt; ，等。（有一些例外和陷阱与此;参见&lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;一个完整的讨论。）的 &lt;code&gt;[:digit:]&lt;/code&gt; ， &lt;code&gt;[:word:]&lt;/code&gt; 和 &lt;code&gt;[:space:]&lt;/code&gt; 对应于熟悉的 &lt;code&gt;\d&lt;/code&gt; ， &lt;code&gt;\w&lt;/code&gt; 和 &lt;code&gt;\s&lt;/code&gt; 字符类。要取消POSIX类，请在名称前加上 &lt;code&gt;^&lt;/code&gt; ，以便 &lt;code&gt;[:^digit:]&lt;/code&gt; 对应于 &lt;code&gt;\D&lt;/code&gt; ，而在Unicode下则对应 &lt;code&gt;\P{IsDigit}&lt;/code&gt; 。Unicode和POSIX字符类可以像 &lt;code&gt;\d&lt;/code&gt; 一样使用，但POSIX字符类只能在字符类内部使用：</target>
        </trans-unit>
        <trans-unit id="c16f46255f2c5b016b34cc67482e93dd7025a2f9" translate="yes" xml:space="preserve">
          <source>As implied above, the environment accessed through &lt;a href=&quot;perlvar#%25ENV&quot;&gt;&lt;code&gt;%ENV&lt;/code&gt;&lt;/a&gt; is global, and the convention is that program specific environment variables are of the form &lt;code&gt;Program$Name&lt;/code&gt;. Each filesystem maintains a current directory, and the current filesystem's current directory is the &lt;b&gt;global&lt;/b&gt; current directory. Consequently, sociable programs don't change the current directory but rely on full pathnames, and programs (and Makefiles) cannot assume that they can spawn a child process which can change the current directory without affecting its parent (and everyone else for that matter).</source>
          <target state="translated">如上所述，通过&lt;a href=&quot;perlvar#%25ENV&quot;&gt; &lt;code&gt;%ENV&lt;/code&gt; &lt;/a&gt;访问的环境是全局的，并且约定是特定于程序的环境变量的形式为 &lt;code&gt;Program$Name&lt;/code&gt; 。每个文件系统都维护一个当前目录，而当前文件系统的当前目录是&lt;b&gt;全局&lt;/b&gt;当前目录。因此，社交程序不会更改当前目录，而是依赖完整的路径名，并且程序（和Makefiles）不能假定它们可以生成一个子进程，该子进程可以更改当前目录而不影响其父目录（以及其他所有人）。 。</target>
        </trans-unit>
        <trans-unit id="460ff6781c9a7b0d42e2f096c304dc01b5296e55" translate="yes" xml:space="preserve">
          <source>As implied above, the environment accessed through &lt;code&gt;%ENV&lt;/code&gt; is global, and the convention is that program specific environment variables are of the form &lt;code&gt;Program$Name&lt;/code&gt; . Each filesystem maintains a current directory, and the current filesystem's current directory is the &lt;b&gt;global&lt;/b&gt; current directory. Consequently, sociable programs don't change the current directory but rely on full pathnames, and programs (and Makefiles) cannot assume that they can spawn a child process which can change the current directory without affecting its parent (and everyone else for that matter).</source>
          <target state="translated">如上所述，通过 &lt;code&gt;%ENV&lt;/code&gt; 访问的环境是全局的，并且约定是特定于程序的环境变量的形式为 &lt;code&gt;Program$Name&lt;/code&gt; 。每个文件系统都维护一个当前目录，而当前文件系统的当前目录是&lt;b&gt;全局&lt;/b&gt;当前目录。因此，社交程序不会更改当前目录，而是依赖完整的路径名，并且程序（和Makefiles）不能假定它们可以生成可以更改当前目录而不影响其父目录（以及其他所有人）的子进程。 。</target>
        </trans-unit>
        <trans-unit id="9cfe8ec9bce67c19def3a159ea6c0eb1d6dbe31c" translate="yes" xml:space="preserve">
          <source>As in some shells, you can enclose the variable name in braces to disambiguate it from following alphanumerics (and underscores). You must also do this when interpolating a variable into a string to separate the variable name from a following double-colon or an apostrophe, since these would be otherwise treated as a package separator:</source>
          <target state="translated">就像在某些shell中一样,你可以将变量名用大括号括起来,以便与后面的字母数字(和下划线)区分开来。当你把一个变量插值到一个字符串中时,你也必须这样做,以便把变量名与后面的双引号或省略号分开,因为它们会被当作包的分隔符。</target>
        </trans-unit>
        <trans-unit id="f260d12b5b1b7a497f5733dde8f966ff0dea7a60" translate="yes" xml:space="preserve">
          <source>As it stands it predates version.pm but has the same goal: make version strings visible and comparable.</source>
          <target state="translated">就目前而言,它比version.pm更早,但有同样的目标:使版本字符串可见且可比较。</target>
        </trans-unit>
        <trans-unit id="e22bdaf7af0b55a0257fbf249cc6b2acfdfc9220" translate="yes" xml:space="preserve">
          <source>As its name suggests, if your code tripped a mandatory warning, you would get a warning whether you wanted it or not. For example, the code below would always produce an &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; warning about the &quot;2:&quot;.</source>
          <target state="translated">顾名思义，如果您的代码遇到了强制性警告，则无论您是否需要它都会收到警告。例如，下面的代码将始终产生有关&amp;ldquo; 2：&amp;rdquo;的&amp;ldquo; &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="299f8da88c7d33c41fa9b9da7b25493959ed6b3c" translate="yes" xml:space="preserve">
          <source>As just mentioned, all variables are, by default, thread local. To use shared variables, you need to also load &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;:</source>
          <target state="translated">如前所述，默认情况下，所有变量都是线程局部的。要使用共享变量，您还需要加载&lt;a href=&quot;threads/shared&quot;&gt;thread :: shared&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="7273a25ae51ae519b823516d45a11747d27d1f68" translate="yes" xml:space="preserve">
          <source>As just mentioned, all variables are, by default, thread local. To use shared variables, you need to also load &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;:</source>
          <target state="translated">如前所述，默认情况下，所有变量都是线程局部的。要使用共享变量，您还需要加载&lt;a href=&quot;threads::shared&quot;&gt;thread :: shared&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="1b2545d2ff62a227583262bedb22954e6e8e3fc3" translate="yes" xml:space="preserve">
          <source>As locks are advisory, they do not prevent data access or modification by another thread that does not itself attempt to obtain a lock on the variable.</source>
          <target state="translated">由于锁是咨询性的,它们并不能阻止另一个线程访问或修改数据,而这个线程本身并没有试图获得变量的锁。</target>
        </trans-unit>
        <trans-unit id="3b3a54f56722c72f0cfe48a91b285385f9f3fe3e" translate="yes" xml:space="preserve">
          <source>As long as a context exists for a given hub, all tools that try to get a context will get the existing instance. If you try to store the context you will pollute other tools with incorrect context information.</source>
          <target state="translated">只要一个上下文存在于一个给定的中心,所有试图获得上下文的工具都将获得现有的实例。如果你试图存储上下文,你会用不正确的上下文信息污染其他工具。</target>
        </trans-unit>
        <trans-unit id="81ff74ffe73c98f024294d6b4b3ccdb104adb917" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2man&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2man&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2man&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">只要所有已处理的文档都产生某些输出，即使该输出包含勘误表（使用 &lt;code&gt;--errors=pod&lt;/code&gt; 生成的 &lt;code&gt;POD ERRORS&lt;/code&gt; 部分），&lt;b&gt;pod2man&lt;/b&gt;也将以状态0退出。如果任何正在处理的文档都不会导致输出文档，&lt;b&gt;pod2man&lt;/b&gt;将以状态1退出。如果正在处理的POD文档中存在语法错误，并且错误处理样式设置为默认值 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，则&lt;b&gt;pod2man&lt;/b&gt;将立即退出，退出状态为255。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="00a3a680bcee6a61521d2a5ef5058ff99a76856b" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2text&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2text&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2text&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">只要所有已处理的文档都产生某些输出，即使该输出包含勘误（使用 &lt;code&gt;--errors=pod&lt;/code&gt; 生成的 &lt;code&gt;POD ERRORS&lt;/code&gt; 节），&lt;b&gt;pod2text&lt;/b&gt;也会以状态0退出。如果任何正在处理的文档都不会导致输出文档&lt;b&gt;pod2text&lt;/b&gt;将以状态1退出。如果正在处理的POD文档中存在语法错误，并且错误处理样式设置为默认值 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，则&lt;b&gt;pod2text&lt;/b&gt;将立即终止，退出状态为255。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0269a38b4ec57ba243ba2782b49b270dd9c32426" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt;), &lt;b&gt;pod2man&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2man&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;die&lt;/code&gt;, &lt;b&gt;pod2man&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">只要所有已处理的文档都产生某些输出，即使该输出包含勘误（使用 &lt;code&gt;--errors=pod&lt;/code&gt; 生成的 &lt;code&gt;POD ERRORS&lt;/code&gt; 节），&lt;b&gt;pod2man&lt;/b&gt;也会以状态0退出。输出文档，&lt;b&gt;pod2man&lt;/b&gt;将以状态1退出。如果正在处理的POD文档中存在语法错误，并且错误处理样式设置为默认值 &lt;code&gt;die&lt;/code&gt; ，则&lt;b&gt;pod2man&lt;/b&gt;将立即退出，退出状态为255。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="03b9b379a8f2df5ad39a7bc04538ebad9bc6c049" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt;), &lt;b&gt;pod2text&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2text&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;die&lt;/code&gt;, &lt;b&gt;pod2text&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">只要所有已处理的文档都产生某种输出，即使该输出包含勘误表（使用 &lt;code&gt;--errors=pod&lt;/code&gt; 生成的 &lt;code&gt;POD ERRORS&lt;/code&gt; 部分），&lt;b&gt;pod2text&lt;/b&gt;也会以状态0退出。输出文档&lt;b&gt;pod2text&lt;/b&gt;将以状态1退出。如果正在处理的POD文档中有语法错误，并且错误处理样式设置为默认值 &lt;code&gt;die&lt;/code&gt; ，则&lt;b&gt;pod2text&lt;/b&gt;将立即终止，退出状态为255。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="89c56046221181f7e1bfa30bafe704cdc7899788" translate="yes" xml:space="preserve">
          <source>As long as the code inside the SKIP block at least compiles. Please don't ask how. No, it's not a filter.</source>
          <target state="translated">只要SKIP块里面的代码至少能编译。请不要问怎么编译。不,这不是一个过滤器。</target>
        </trans-unit>
        <trans-unit id="95c1aea5304f4de3806c6769617146a8ffc159e5" translate="yes" xml:space="preserve">
          <source>As long as the reference is never returned by any function within the module, no outside module can see the subroutine, because its name is not in any package's symbol table. Remember that it's not</source>
          <target state="translated">只要这个引用从未被模块内的任何函数返回,任何外部模块都无法看到这个子程序,因为它的名字不在任何包的符号表中。请记住,它不是</target>
        </trans-unit>
        <trans-unit id="9a46642b51b5bbcfbb8a5a0fab6a1a748c3835a7" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;#Mathemagic%2C-Mutators%2C-and-Copy-Constructors&quot;&gt;above&lt;/a&gt;, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if &lt;code&gt;$b&lt;/code&gt; is mathemagical, and &lt;code&gt;'++'&lt;/code&gt; is overloaded with &lt;code&gt;'incr'&lt;/code&gt;, and &lt;code&gt;'='&lt;/code&gt; is overloaded with &lt;code&gt;'clone'&lt;/code&gt;, then the code</source>
          <target state="translated">如所提到的&lt;a href=&quot;#Mathemagic%2C-Mutators%2C-and-Copy-Constructors&quot;&gt;上面&lt;/a&gt;，当增变被施加到参考该操作被称为共享其与一些其它参考对象。例如，如果 &lt;code&gt;$b&lt;/code&gt; 是数学的，并且 &lt;code&gt;'++'&lt;/code&gt; 被 &lt;code&gt;'incr'&lt;/code&gt; 重载，并且 &lt;code&gt;'='&lt;/code&gt; 被 &lt;code&gt;'clone'&lt;/code&gt; 重载，则代码</target>
        </trans-unit>
        <trans-unit id="958bb5f65d2f4962aaa4f5dd2b31857927db841a" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;above&lt;/a&gt;, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if &lt;code&gt;$b&lt;/code&gt; is mathemagical, and &lt;code&gt;'++'&lt;/code&gt; is overloaded with &lt;code&gt;'incr'&lt;/code&gt; , and &lt;code&gt;'='&lt;/code&gt; is overloaded with &lt;code&gt;'clone'&lt;/code&gt; , then the code</source>
          <target state="translated">如所提到的&lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;上面&lt;/a&gt;，当增变被施加到参考该操作被称为共享其与一些其它参考对象。例如，如果 &lt;code&gt;$b&lt;/code&gt; 是数学的，并且 &lt;code&gt;'++'&lt;/code&gt; 被 &lt;code&gt;'incr'&lt;/code&gt; 重载，并且 &lt;code&gt;'='&lt;/code&gt; 被 &lt;code&gt;'clone'&lt;/code&gt; 重载，则代码</target>
        </trans-unit>
        <trans-unit id="4a4d04edd6d111dfba357a91be03d0f8c653a2d2" translate="yes" xml:space="preserve">
          <source>As mentioned above under &lt;a href=&quot;#ALIASES&quot;&gt;&quot;ALIASES&quot;&lt;/a&gt;, Unicode 6.1 defines extra names (synonyms or aliases) for some code points, most of which were already available as Perl extensions. All these are accepted by &lt;code&gt;\N{...}&lt;/code&gt; and the other functions in this module, but &lt;code&gt;viacode&lt;/code&gt; has to choose which one name to return for a given input code point, so it returns the &quot;best&quot; name. To understand how this works, it is helpful to know more about the Unicode name properties. All code points actually have only a single name, which (starting in Unicode 2.0) can never change once a character has been assigned to the code point. But mistakes have been made in assigning names, for example sometimes a clerical error was made during the publishing of the Standard which caused words to be misspelled, and there was no way to correct those. The Name_Alias property was eventually created to handle these situations. If a name was wrong, a corrected synonym would be published for it, using Name_Alias. &lt;code&gt;viacode&lt;/code&gt; will return that corrected synonym as the &quot;best&quot; name for a code point. (It is even possible, though it hasn't happened yet, that the correction itself will need to be corrected, and so another Name_Alias can be created for that code point; &lt;code&gt;viacode&lt;/code&gt; will return the most recent correction.)</source>
          <target state="translated">如上文在&lt;a href=&quot;#ALIASES&quot;&gt;&amp;ldquo;别名&amp;rdquo;&lt;/a&gt;下所述，Unicode 6.1为某些代码点定义了额外的名称（同义词或别名），其中大多数已经作为Perl扩展提供。 &lt;code&gt;\N{...}&lt;/code&gt; 和该模块中的其他功能都接受所有这些，但是要通过 &lt;code&gt;viacode&lt;/code&gt; 必须为给定的输入代码点选择要返回的名称，因此它会返回&amp;ldquo;最佳&amp;rdquo;名称。要了解它是如何工作的，更多地了解Unicode名称属性是有帮助的。实际上，所有代码点都只有一个名称，一旦将字符分配给代码点，该名称（从Unicode 2.0开始）将永远不会更改。但是在分配名称时出现了错误，例如，有时在标准发布过程中发生了笔误，导致单词拼写错误，并且无法纠正这些错误。最终创建了Name_Alias属性来处理这些情况。如果名称错误，将使用Name_Alias为它发布更正的同义词。 &lt;code&gt;viacode&lt;/code&gt; 将返回该更正的同义词作为代码点的&amp;ldquo;最佳&amp;rdquo;名称。 （即使还没有发生，甚至有可能需要更正本身，因此可以为该代码点创建另一个Name_Alias； &lt;code&gt;viacode&lt;/code&gt; 将返回最近的更正。）</target>
        </trans-unit>
        <trans-unit id="6db309618dd0587d20027a36c5759130977518d4" translate="yes" xml:space="preserve">
          <source>As mentioned above under &lt;a href=&quot;#ALIASES&quot;&gt;ALIASES&lt;/a&gt;, Unicode 6.1 defines extra names (synonyms or aliases) for some code points, most of which were already available as Perl extensions. All these are accepted by &lt;code&gt;\N{...}&lt;/code&gt; and the other functions in this module, but &lt;code&gt;viacode&lt;/code&gt; has to choose which one name to return for a given input code point, so it returns the &quot;best&quot; name. To understand how this works, it is helpful to know more about the Unicode name properties. All code points actually have only a single name, which (starting in Unicode 2.0) can never change once a character has been assigned to the code point. But mistakes have been made in assigning names, for example sometimes a clerical error was made during the publishing of the Standard which caused words to be misspelled, and there was no way to correct those. The Name_Alias property was eventually created to handle these situations. If a name was wrong, a corrected synonym would be published for it, using Name_Alias. &lt;code&gt;viacode&lt;/code&gt; will return that corrected synonym as the &quot;best&quot; name for a code point. (It is even possible, though it hasn't happened yet, that the correction itself will need to be corrected, and so another Name_Alias can be created for that code point; &lt;code&gt;viacode&lt;/code&gt; will return the most recent correction.)</source>
          <target state="translated">如上文在&lt;a href=&quot;#ALIASES&quot;&gt;ALIASES&lt;/a&gt;下所述，Unicode 6.1为某些代码点定义了额外的名称（同义词或别名），其中大多数已作为Perl扩展提供。 &lt;code&gt;\N{...}&lt;/code&gt; 和该模块中的其他功能都接受所有这些，但是要通过 &lt;code&gt;viacode&lt;/code&gt; 必须为给定的输入代码点选择要返回的名称，因此它返回&amp;ldquo;最佳&amp;rdquo;名称。要了解它是如何工作的，更多地了解Unicode名称属性将很有帮助。实际上，所有代码点都只有一个名称，一旦将字符分配给代码点，该名称（从Unicode 2.0开始）将永远不会更改。但是在分配名称时出现了错误，例如，有时在标准发布期间发生了文书错误，导致单词拼写错误，并且无法纠正这些错误。最终创建了Name_Alias属性来处理这些情况。如果名称错误，将使用Name_Alias为它发布更正的同义词。 &lt;code&gt;viacode&lt;/code&gt; 将返回该更正的同义词作为代码点的&amp;ldquo;最佳&amp;rdquo;名称。 （即使还没有发生，甚至有可能需要更正本身，因此可以为该代码点创建另一个Name_Alias； &lt;code&gt;viacode&lt;/code&gt; 将返回最近的更正。）</target>
        </trans-unit>
        <trans-unit id="aa5ef151af9bb6073935edbcfff85b0147b33678" translate="yes" xml:space="preserve">
          <source>As mentioned above, UTF-8 uses a variable number of bytes to store a character. Characters with values 0...127 are stored in one byte, just like good ol' ASCII. Character 128 is stored as &lt;code&gt;v194.128&lt;/code&gt; ; this continues up to character 191, which is &lt;code&gt;v194.191&lt;/code&gt; . Now we've run out of bits (191 is binary &lt;code&gt;10111111&lt;/code&gt; ) so we move on; character 192 is &lt;code&gt;v195.128&lt;/code&gt; . And so it goes on, moving to three bytes at character 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;Unicode Encodings in perlunicode&lt;/a&gt; has pictures of how this works.</source>
          <target state="translated">如上所述，UTF-8使用可变数量的字节来存储字符。值0 ... 127的字符存储在一个字节中，就像ASCII一样。字符128被存储为 &lt;code&gt;v194.128&lt;/code&gt; ;这一直持续到字符191，即 &lt;code&gt;v194.191&lt;/code&gt; 。现在我们已经用完了（191是二进制 &lt;code&gt;10111111&lt;/code&gt; ），所以我们继续；字符192是 &lt;code&gt;v195.128&lt;/code&gt; 。如此下去，移动到字符2048处的三个字节&lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;。perlunicode中的Unicode编码&lt;/a&gt;提供了有关其工作原理的图片。</target>
        </trans-unit>
        <trans-unit id="6394bb5241172d16852f3bd3688b62b5907e9510" translate="yes" xml:space="preserve">
          <source>As mentioned above, UTF-8 uses a variable number of bytes to store a character. Characters with values 0...127 are stored in one byte, just like good ol' ASCII. Character 128 is stored as &lt;code&gt;v194.128&lt;/code&gt;; this continues up to character 191, which is &lt;code&gt;v194.191&lt;/code&gt;. Now we've run out of bits (191 is binary &lt;code&gt;10111111&lt;/code&gt;) so we move on; character 192 is &lt;code&gt;v195.128&lt;/code&gt;. And so it goes on, moving to three bytes at character 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;&quot;Unicode Encodings&quot; in perlunicode&lt;/a&gt; has pictures of how this works.</source>
          <target state="translated">如上所述，UTF-8使用可变数量的字节来存储字符。值0 ... 127的字符存储在一个字节中，就像ASCII一样。字符128被存储为 &lt;code&gt;v194.128&lt;/code&gt; ;这一直持续到字符191，即 &lt;code&gt;v194.191&lt;/code&gt; 。现在我们用完所有的位（191是二进制 &lt;code&gt;10111111&lt;/code&gt; ），所以我们继续；字符192是 &lt;code&gt;v195.128&lt;/code&gt; 。如此下去，移动到字符2048处的三个字节&lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;。perlunicode中的&amp;ldquo; Unicode编码&amp;rdquo;&lt;/a&gt;提供了有关其工作原理的图片。</target>
        </trans-unit>
        <trans-unit id="b80f86706a5e778489f2084a741a86389a8e67cd" translate="yes" xml:space="preserve">
          <source>As mentioned above, you can determine the context of the currently executing subroutine in Perl with</source>
          <target state="translated">如上所述,在Perl中,你可以通过使用</target>
        </trans-unit>
        <trans-unit id="00501a67a82ec0513abc29055abfbad02a55f669" translate="yes" xml:space="preserve">
          <source>As mentioned at the top of this document, if you are having problems with these example extensions, you might see if any of these help you.</source>
          <target state="translated">正如本文档顶部所提到的,如果你在使用这些示例扩展时遇到了问题,你可以看看这些是否对你有帮助。</target>
        </trans-unit>
        <trans-unit id="2746f2e141da00d82feca97a110b834cca59fd6d" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, Perl can store a number in any one of three formats, but most operators typically understand only one of those formats. When a numeric value is passed as an argument to such an operator, it will be converted to the format understood by the operator.</source>
          <target state="translated">如前所述,Perl可以用三种格式中的任何一种来存储一个数字,但大多数运算符通常只理解其中的一种格式。当一个数值作为参数传递给这样的运算符时,它将被转换为运算符理解的格式。</target>
        </trans-unit>
        <trans-unit id="77154bb24a38474664192f3ea13c3d83da99f57f" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a &quot;callback&quot; key may be added to the &lt;code&gt;TAP::Parser&lt;/code&gt; constructor. If present, each callback corresponding to a given result type will be called with the result as the argument if the &lt;code&gt;run&lt;/code&gt; method is used. The callback is expected to be a subroutine reference (or anonymous subroutine) which is invoked with the parser result as its argument.</source>
          <target state="translated">如前所述，可以将&amp;ldquo;回调&amp;rdquo;键添加到 &lt;code&gt;TAP::Parser&lt;/code&gt; 构造函数。如果存在，则使用给定结果类型的每个回调将被调用，并且如果使用 &lt;code&gt;run&lt;/code&gt; 方法，则将结果作为参数。该回调应该是一个子例程引用（或匿名子例程），该引用将以解析器结果作为其参数来调用。</target>
        </trans-unit>
        <trans-unit id="4ebe40c302b03d332e451ead97b5b34c4f2894b9" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, in the case of the default engines, the &lt;code&gt;pprivate&lt;/code&gt; will be a pointer to a regexp_internal structure which holds the compiled program and any additional data that is private to the regex engine implementation.</source>
          <target state="translated">如前所述，在默认引擎的情况下， &lt;code&gt;pprivate&lt;/code&gt; 将是指向regexp_internal结构的指针，该结构保存已编译的程序以及regex引擎实现专用的任何其他数据。</target>
        </trans-unit>
        <trans-unit id="05bef95fb25bb75da2eac006c647172d0c563725" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;, encodings are (in the current implementation at least) defined as objects. The mapping of encoding name to object is via the &lt;code&gt;%Encode::Encoding&lt;/code&gt; hash. Though you can directly manipulate this hash, it is strongly encouraged to use this base class module and add encode() and decode() methods.</source>
          <target state="translated">如&lt;a href=&quot;../encode&quot;&gt;Encode中所述&lt;/a&gt;，编码（至少在当前实现中）被定义为对象。编码名称到对象的映射是通过 &lt;code&gt;%Encode::Encoding&lt;/code&gt; 哈希值进行的。尽管您可以直接操纵此哈希，但强烈建议您使用此基类模块并添加encode（）和encode（）方法。</target>
        </trans-unit>
        <trans-unit id="4b732b611600d48e618ee4980714b28a0f9ad12e" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;, encodings are (in the current implementation at least) defined as objects. The mapping of encoding name to object is via the &lt;code&gt;%Encode::Encoding&lt;/code&gt; hash. Though you can directly manipulate this hash, it is strongly encouraged to use this base class module and add encode() and decode() methods.</source>
          <target state="translated">如&lt;a href=&quot;encode&quot;&gt;Encode所述&lt;/a&gt;，编码（至少在当前实现中）被定义为对象。编码名称到对象的映射是通过 &lt;code&gt;%Encode::Encoding&lt;/code&gt; 哈希值进行的。尽管您可以直接操作此哈希，但强烈建议您使用此基类模块并添加encode（）和encode（）方法。</target>
        </trans-unit>
        <trans-unit id="83fbfdaddc2272e65e0714e5d0f69ab35b42f974" translate="yes" xml:space="preserve">
          <source>As mentioned in the previous item, this still doesn't work when using socket I/O between Unix and Macintosh. You'll need to hard code your line terminators, in that case.</source>
          <target state="translated">正如上一条所提到的,当在Unix和Macintosh之间使用socket I/O时,这仍然是行不通的。在这种情况下,你需要硬编码你的行结束符。</target>
        </trans-unit>
        <trans-unit id="ed52abb82f45ac71a451aad1bb7530a654fe2ad3" translate="yes" xml:space="preserve">
          <source>As mentioned previously, dynamic loading isn't currently available nor is MakeMaker. Both are high-priority items.</source>
          <target state="translated">如前所述,动态加载目前还没有,MakeMaker也没有。两者都是高优先级的项目。</target>
        </trans-unit>
        <trans-unit id="9fbc47f4ab04b1b192086c459c88acf77887350f" translate="yes" xml:space="preserve">
          <source>As mentioned, the function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no name is known for the code point. In Unicode the proper name for these is the empty string, which &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; stringifies to. (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; plus a warning.)</source>
          <target state="translated">如前所述，如果代码点的名称未知，该函数将返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。在Unicode中，这些名称的正确名称是空字符串， &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 定义为该字符串。（如果您请求的代码点超出了未为其指定别名的合法Unicode最大U + 10FFFF，则将得到 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 加警告。）</target>
        </trans-unit>
        <trans-unit id="3d4ae46619b16556205991103a3ee51a24d3e1e6" translate="yes" xml:space="preserve">
          <source>As mentioned, the function returns &lt;code&gt;undef&lt;/code&gt; if no name is known for the code point. In Unicode the proper name for these is the empty string, which &lt;code&gt;undef&lt;/code&gt; stringifies to. (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &lt;code&gt;undef&lt;/code&gt; plus a warning.)</source>
          <target state="translated">如前所述，如果代码点的名称未知，则该函数将返回 &lt;code&gt;undef&lt;/code&gt; 。在Unicode中，这些名称的正确名称是空字符串， &lt;code&gt;undef&lt;/code&gt; 定义为该字符串。（如果您请求的代码点超出了未为其分配别名的合法Unicode最大U + 10FFFF，则将得到 &lt;code&gt;undef&lt;/code&gt; 加警告。）</target>
        </trans-unit>
        <trans-unit id="651eca43c6e2d73bc740fcae1016d17e36d82316" translate="yes" xml:space="preserve">
          <source>As most of the remaining expected output to the error stream will be created by &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;'s &lt;code&gt;diag&lt;/code&gt; function, &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; provides a convenience function &lt;code&gt;test_diag&lt;/code&gt; that you can use instead of &lt;code&gt;test_err&lt;/code&gt; .</source>
          <target state="translated">由于错误流的大多数剩余预期输出将由&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;的 &lt;code&gt;diag&lt;/code&gt; 函数创建，因此&lt;a href=&quot;tester&quot;&gt;Test :: Builder :: Tester&lt;/a&gt;提供了一个便捷函数 &lt;code&gt;test_diag&lt;/code&gt; ，您可以使用它代替 &lt;code&gt;test_err&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77c366c0e7fb4976a90caf137a45b2b3674180a3" translate="yes" xml:space="preserve">
          <source>As most of the remaining expected output to the error stream will be created by &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;'s &lt;code&gt;diag&lt;/code&gt; function, &lt;a href=&quot;Test::Builder::Tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; provides a convenience function &lt;code&gt;test_diag&lt;/code&gt; that you can use instead of &lt;code&gt;test_err&lt;/code&gt;.</source>
          <target state="translated">由于错误流的大多数剩余预期输出将由&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;的 &lt;code&gt;diag&lt;/code&gt; 函数创建，因此&lt;a href=&quot;Test::Builder::Tester&quot;&gt;Test :: Builder :: Tester&lt;/a&gt;提供了一个便捷函数 &lt;code&gt;test_diag&lt;/code&gt; ，您可以使用它代替 &lt;code&gt;test_err&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e01de119b6c27502755389f5ecb232b0f5fe3f3" translate="yes" xml:space="preserve">
          <source>As much as possible, the version.pm module remains compatible with all current code. However, if your module is using a module that has defined &lt;code&gt;$VERSION&lt;/code&gt; using the version class, there are a couple of things to be aware of. For purposes of discussion, we will assume that we have the following module installed:</source>
          <target state="translated">version.pm模块尽可能与所有当前代码兼容。但是，如果您的模块使用的模块使用version类定义了 &lt;code&gt;$VERSION&lt;/code&gt; ，则需要注意以下几点。为了便于讨论，我们将假定安装了以下模块：</target>
        </trans-unit>
        <trans-unit id="a3938aef953ff6d9fa864efd013ef275f9aaeca4" translate="yes" xml:space="preserve">
          <source>As noted above, if the file does not already exist, then the append-mode open will create it for you. But if the file does already exist, its contents are safe from harm because you will be adding your new text past the end of the old text.</source>
          <target state="translated">如上所述,如果文件还不存在,那么append-mode open将为你创建它。但如果文件确实已经存在,它的内容就不会受到伤害,因为你将在旧文本的结尾处添加新文本。</target>
        </trans-unit>
        <trans-unit id="a7e52b3ee94a5bcfcbfa100ffa60b7bfdd3a2e7b" translate="yes" xml:space="preserve">
          <source>As noted above, the &lt;code&gt;mark&lt;/code&gt; variable itself will point at the most recently pushed value on the value stack before the list begins, and so the list itself starts at &lt;code&gt;mark + 1&lt;/code&gt;. The values of the list may be iterated by code such as</source>
          <target state="translated">如上所述， &lt;code&gt;mark&lt;/code&gt; 变量本身将在列表开始之前指向值堆栈上最近推入的值，因此列表本身从 &lt;code&gt;mark + 1&lt;/code&gt; 开始。列表的值可以通过以下代码进行迭代：</target>
        </trans-unit>
        <trans-unit id="9988c3a40e007efc46894bc022da2f7d4a303e25" translate="yes" xml:space="preserve">
          <source>As noted above, xV references on the main value stack do not contribute to the reference count of an xV, and so another mechanism is used to track when temporary values which live on the stack must be released. This is the job of the temporaries stack.</source>
          <target state="translated">如上所述,主值堆栈上的xV引用并不对xV的引用计数做出贡献,因此使用另一种机制来跟踪何时必须释放活在堆栈上的临时值。这就是临时值栈的工作。</target>
        </trans-unit>
        <trans-unit id="aa50c7a75f631655fc7d60c7b218e502c8aba3fb" translate="yes" xml:space="preserve">
          <source>As noted earlier in this document, the scalar sense of list assignment is the number of elements on the right-hand side of the assignment. The null list contains no elements, so when the password file is exhausted, the result is 0, not 2.</source>
          <target state="translated">如本文前面所述,列表赋值的标量意义是赋值右侧的元素数。空列表不包含任何元素,所以当密码文件用完后,结果是0,而不是2。</target>
        </trans-unit>
        <trans-unit id="3e5e8b8f30fce2b639027bd3be7728c79d978675" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;#USING-LOCALES&quot;&gt;&quot;USING LOCALES&quot;&lt;/a&gt;, &lt;code&gt;cmp&lt;/code&gt; compares according to the current collation locale when &lt;code&gt;use locale&lt;/code&gt; is in effect, but falls back to a char-by-char comparison for strings that the locale says are equal. You can use &lt;code&gt;POSIX::strcoll()&lt;/code&gt; if you don't want this fall-back:</source>
          <target state="translated">如&lt;a href=&quot;#USING-LOCALES&quot;&gt;&amp;ldquo;使用局部&amp;rdquo;中&lt;/a&gt;所述，当 &lt;code&gt;use locale&lt;/code&gt; 生效时， &lt;code&gt;cmp&lt;/code&gt; 会根据当前的整理语言环境进行比较，但会回退到语言环境相等的字符串的逐字符比较。如果您不希望出现这种情况，可以使用 &lt;code&gt;POSIX::strcoll()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c32dd8a34a2658e1d2e1869aeb4cec0307b6493f" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt;, &lt;code&gt;cmp&lt;/code&gt; compares according to the current collation locale when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, but falls back to a char-by-char comparison for strings that the locale says are equal. You can use &lt;code&gt;POSIX::strcoll()&lt;/code&gt; if you don't want this fall-back:</source>
          <target state="translated">如&lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES中&lt;/a&gt;所述，当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境生效时， &lt;code&gt;cmp&lt;/code&gt; 会根据当前的整理语言环境进行比较，但会回退到语言环境相等的字符串的逐字符比较。如果您不希望发生这种情况，可以使用 &lt;code&gt;POSIX::strcoll()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="39a23dc03cf7dc5e3d6e19189da7b65ab7a30cf2" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;perlhack#TESTING&quot;&gt;&quot;TESTING&quot; in perlhack&lt;/a&gt;, when writing test scripts, the file</source>
          <target state="translated">如&lt;a href=&quot;perlhack#TESTING&quot;&gt;perlhack的&amp;ldquo; TESTING&amp;rdquo;中所述&lt;/a&gt;，编写测试脚本时，该文件</target>
        </trans-unit>
        <trans-unit id="eda06429df1073940e96ea523060e042021aeec8" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;perlhack#TESTING&quot;&gt;TESTING in perlhack&lt;/a&gt;, when writing test scripts, the file</source>
          <target state="translated">如&lt;a href=&quot;perlhack#TESTING&quot;&gt;perlhack的TESTING中所述&lt;/a&gt;，编写测试脚本时，该文件</target>
        </trans-unit>
        <trans-unit id="1655e6b218596b71d5606712f426706cfda24e83" translate="yes" xml:space="preserve">
          <source>As of 1.37_02 install() supports the use of a list of patterns to filter out files that shouldn't be installed. If $skip is omitted or undefined then install will try to read the list from INSTALL.SKIP in the CWD. This file is a list of regular expressions and is just like the MANIFEST.SKIP file used by &lt;a href=&quot;ExtUtils::Manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt;.</source>
          <target state="translated">从1.37_02版本开始，install（）支持使用一系列模式来过滤掉不应该安装的文件。如果$ skip被省略或未定义，则安装将尝试从CWD中的INSTALL.SKIP中读取列表。该文件是一个正则表达式的列表，就像&lt;a href=&quot;ExtUtils::Manifest&quot;&gt;ExtUtils :: Manifest&lt;/a&gt;使用的MANIFEST.SKIP文件一样。</target>
        </trans-unit>
        <trans-unit id="716cc3d3aff35fc6629ccc256677b64774af14df" translate="yes" xml:space="preserve">
          <source>As of 1.37_02 install() supports the use of a list of patterns to filter out files that shouldn't be installed. If $skip is omitted or undefined then install will try to read the list from INSTALL.SKIP in the CWD. This file is a list of regular expressions and is just like the MANIFEST.SKIP file used by &lt;a href=&quot;manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt;.</source>
          <target state="translated">从1.37_02开始，install（）支持使用一系列模式来过滤掉不应安装的文件。如果$ skip被省略或未定义，则安装将尝试从CWD中的INSTALL.SKIP中读取列表。该文件是一个正则表达式列表，就像&lt;a href=&quot;manifest&quot;&gt;ExtUtils :: Manifest&lt;/a&gt;使用的MANIFEST.SKIP文件一样。</target>
        </trans-unit>
        <trans-unit id="0f828a6d861469c7d75db52b836c69689c1760b7" translate="yes" xml:space="preserve">
          <source>As of 3.10, the internal data for all types of codes can be modified.</source>
          <target state="translated">从3.10开始,所有类型代码的内部数据都可以修改。</target>
        </trans-unit>
        <trans-unit id="4f51af2e950bc010c45298268ec1c3013383b233" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;a href=&quot;warnings&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">从5.14版本开始，如果您的平台不支持它们，则没有一个会引发异常。但是，如果启用了警告，则会在不支持的转换标志上发出&lt;a href=&quot;warnings&quot;&gt; &lt;code&gt;printf&lt;/code&gt; &lt;/a&gt;警告类的警告。相反，如果您更喜欢例外，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="1d399ef50aa4f86fbc538d8e5d435b672ada57b9" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">从5.14版本开始，如果您的平台不支持它们，则没有一个会引发异常。但是，如果启用了警告，则会在不支持的转换标志上发出 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 警告类的警告。如果您更喜欢例外，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="fd9213ca43980debccb984d13f9caaa2e79748be" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">从5.14版本开始，如果您的平台不支持它们，则没有一个会引发异常。但是，如果启用了警告，则会在不支持的转换标志上发出 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 警告类的警告。如果您更喜欢例外，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="6791199e3f80fe4bbb43c0eaff9608d527ada74b" translate="yes" xml:space="preserve">
          <source>As of 5.14, that can also be written this way:</source>
          <target state="translated">从5.14开始,也可以这样写。</target>
        </trans-unit>
        <trans-unit id="b37d45aa3fafa285df8c8611054589c583244ea5" translate="yes" xml:space="preserve">
          <source>As of 5.19.9 setting &lt;code&gt;$/&lt;/code&gt; to any other form of reference will throw a fatal exception. This is in preparation for supporting new ways to set &lt;code&gt;$/&lt;/code&gt; in the future.</source>
          <target state="translated">从5.19.9开始，将 &lt;code&gt;$/&lt;/code&gt; 设置为任何其他形式的引用将引发致命异常。这是为支持将来设置 &lt;code&gt;$/&lt;/code&gt; 新方法做准备。</target>
        </trans-unit>
        <trans-unit id="5090edb4c78c4b281b3a889d093a1c4d0aac43d2" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, long doubles are working if you use the Sun compilers (needed for additional math routines not included in libm).</source>
          <target state="translated">从5.8.1开始,如果你使用Sun编译器,长倍数就可以工作了(libm中没有包含的额外数学例程需要)。</target>
        </trans-unit>
        <trans-unit id="f508ee41697726e1567be3f0dd308006b0a11bbd" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, the &lt;b&gt;-C&lt;/b&gt; can be followed either by a number or a list of option letters. The letters, their numeric values, and effects are as follows; listing the letters is equal to summing the numbers.</source>
          <target state="translated">从5.8.1开始，&lt;b&gt;-C&lt;/b&gt;后面可以跟数字或选项字母列表。字母，它们的数值和效果如下：列出字母等于将数字相加。</target>
        </trans-unit>
        <trans-unit id="45cfda1b1b7f6423e5dd7ec6647effcbf0d30173" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as are the other directives. However they have both compile-time and run-time effects.</source>
          <target state="translated">从5.9.5版开始，伪指令 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; re'debug '及其等效项在词法范围内，其他伪指令也是如此。但是，它们同时具有编译时和运行时效果。</target>
        </trans-unit>
        <trans-unit id="d51f5d10f6eede269e073b2d28e8411b4b049f81" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as the other directives are. However they have both compile-time and run-time effects.</source>
          <target state="translated">从5.9.5版本开始，该指令 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; re'debug '及其等效项与其他指令一样在词法范围内。但是，它们同时具有编译时和运行时效果。</target>
        </trans-unit>
        <trans-unit id="88f554d7cda5067d9baf3d30fcba8c29b1dbb104" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;use re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as are the other directives. However they have both compile-time and run-time effects.</source>
          <target state="translated">从5.9.5版本开始，该指令 &lt;code&gt;use re 'debug'&lt;/code&gt; re'debug '及其等效项在词法范围内，其他指令也是如此。但是，它们同时具有编译时和运行时效果。</target>
        </trans-unit>
        <trans-unit id="6609b05c1701ded1ef1eec29d7bb5f4a5b93b02d" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;use re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as the other directives are. However they have both compile-time and run-time effects.</source>
          <target state="translated">从5.9.5版本开始，该指令 &lt;code&gt;use re 'debug'&lt;/code&gt; re'debug '及其等效项与其他指令一样在词法范围内。但是，它们同时具有编译时和运行时效果。</target>
        </trans-unit>
        <trans-unit id="8b5a3958e4abf52ef71b991a4f025f997262e7e8" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; 2.12, &lt;code&gt;CHECK&lt;/code&gt; can also be a code reference which takes the ordinal value of the unmapped character as an argument and returns octets that represent the fallback character. For instance:</source>
          <target state="translated">从 &lt;code&gt;Encode&lt;/code&gt; 2.12开始， &lt;code&gt;CHECK&lt;/code&gt; 也可以是一个代码引用，它以未映射字符的序数值作为参数并返回代表后备字符的八位字节。例如：</target>
        </trans-unit>
        <trans-unit id="b411b3efc2bae2399e243c4103628c18af471dad" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; version 2.21, a new method &lt;code&gt;mime_name()&lt;/code&gt; is therefore added.</source>
          <target state="translated">从 &lt;code&gt;Encode&lt;/code&gt; 版本2.21开始，因此添加了新方法 &lt;code&gt;mime_name()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="703e152d6b7fb820f5c3dbc21f352bf9bc7a9e95" translate="yes" xml:space="preserve">
          <source>As of CPAN 1.9463, if you do not have permission to write the default perl library directories, CPAN's configuration process will ask you whether you want to bootstrap &amp;lt;local::lib&amp;gt;, which makes keeping a personal perl library directory easy.</source>
          <target state="translated">从CPAN 1.9463开始，如果您无权编写默认的perl库目录，则CPAN的配置过程将询问您是否要引导&amp;lt;local :: lib&amp;gt;，这使保持个人perl库目录变得容易。</target>
        </trans-unit>
        <trans-unit id="07aaeb2f2c75fecbde3c90f6c2e907a83c502842" translate="yes" xml:space="preserve">
          <source>As of Encode 1.87, the older form</source>
          <target state="translated">从Encode 1.87开始,老式的</target>
        </trans-unit>
        <trans-unit id="b09ae12c2db054fb655cbb26f548a82db4c390c0" translate="yes" xml:space="preserve">
          <source>As of July 2002 (the Perl release 5.8.0), the following platforms were able to build Perl from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;</source>
          <target state="translated">从2002年7月开始（Perl版本5.8.0），以下平台能够从&lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/上&lt;/a&gt;提供的标准源代码发行版中构建Perl 。</target>
        </trans-unit>
        <trans-unit id="fcab0673d5c88e7554da234165f977684b228be3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, the &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables may be used. These are only set if the &lt;code&gt;/p&lt;/code&gt; modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; are available whether the &lt;code&gt;/p&lt;/code&gt; has been used or not (the modifier is ignored), and &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; and &lt;code&gt;$&amp;amp;&lt;/code&gt; do not cause any speed difference.</source>
          <target state="translated">从Perl 5.10开始，可以使用 &lt;code&gt;${^PREMATCH}&lt;/code&gt; ， &lt;code&gt;${^MATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 变量。仅当存在 &lt;code&gt;/p&lt;/code&gt; 修饰符时才设置。因此，它们不会惩罚程序的其余部分。在Perl 5.20中，无论是否使用 &lt;code&gt;/p&lt;/code&gt; （忽略修饰符），都可以使用 &lt;code&gt;${^PREMATCH}&lt;/code&gt; ， &lt;code&gt;${^MATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; ，而 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$'&lt;/code&gt; 和 &lt;code&gt;$&amp;amp;&lt;/code&gt; 则不可用造成任何速度差异。</target>
        </trans-unit>
        <trans-unit id="e79e99fb499b4f259d0eaa53033cd09b0a52555d" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, the &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables may be used. These are only set if the &lt;code&gt;/p&lt;/code&gt; modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; are available whether the &lt;code&gt;/p&lt;/code&gt; has been used or not (the modifier is ignored), and &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$'&lt;/code&gt; and &lt;code&gt;$&amp;amp;&lt;/code&gt; do not cause any speed difference.</source>
          <target state="translated">从Perl 5.10开始，可以使用 &lt;code&gt;${^PREMATCH}&lt;/code&gt; ， &lt;code&gt;${^MATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 变量。仅当存在 &lt;code&gt;/p&lt;/code&gt; 修饰符时才设置。因此，它们不会惩罚程序的其余部分。在Perl 5.20中，无论是否使用了 &lt;code&gt;/p&lt;/code&gt; （忽略修饰符），都可以使用 &lt;code&gt;${^PREMATCH}&lt;/code&gt; ， &lt;code&gt;${^MATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; ，而 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$'&lt;/code&gt; 和 &lt;code&gt;$&amp;amp;&lt;/code&gt; 则不可用造成任何速度差异。</target>
        </trans-unit>
        <trans-unit id="eafa84154e8f8c3596803a7b5e3904a497adc460" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, this pragma is lexically scoped and takes effect at compile time. In earlier versions its effect was global and took effect at run-time; the documentation suggested using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; to change the behaviour:</source>
          <target state="translated">从Perl 5.10开始，此编译指示在词法范围内有效，并在编译时生效。在早期版本中，它的影响是全局的，并在运行时生效。该文档建议使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 来更改行为：</target>
        </trans-unit>
        <trans-unit id="331b4594e4263cc88f44953b4d0b8305968e3f99" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, this pragma is lexically scoped and takes effect at compile time. In earlier versions its effect was global and took effect at run-time; the documentation suggested using &lt;code&gt;eval()&lt;/code&gt; to change the behaviour:</source>
          <target state="translated">从Perl 5.10开始，此编译指示已在词法范围内生效，并在编译时生效。在早期版本中，它的影响是全局的，并在运行时生效。该文档建议使用 &lt;code&gt;eval()&lt;/code&gt; 更改行为：</target>
        </trans-unit>
        <trans-unit id="86d4d0145ccce27050aa6a59ab5275c8b3a0cdb0" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, you can match balanced text with regular expressions using recursive patterns. Before Perl 5.10, you had to resort to various tricks such as using Perl code in &lt;code&gt;(??{})&lt;/code&gt; sequences.</source>
          <target state="translated">从Perl 5.10开始，您可以使用递归模式将平衡文本与正则表达式匹配。在Perl 5.10之前，您必须诉诸各种技巧，例如在 &lt;code&gt;(??{})&lt;/code&gt; 序列中使用Perl代码。</target>
        </trans-unit>
        <trans-unit id="eea5149372feb11e1db38e07d50576f276a6c743" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, Perl supports several Python/PCRE-specific extensions to the regex syntax. While Perl programmers are encouraged to use the Perl-specific syntax, the following are also accepted:</source>
          <target state="translated">从Perl 5.10.0开始,Perl支持几种Python/PCRE专用的扩展来扩展regex语法。我们鼓励Perl程序员使用Perl特有的语法,同时也接受以下语法。</target>
        </trans-unit>
        <trans-unit id="793e424fe5bef6967b0c0b6751f2a3b12bcf501f" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file test operators, in a way that &lt;code&gt;-f -w -x $file&lt;/code&gt; is equivalent to &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; . (This is only fancy syntax: if you use the return value of &lt;code&gt;-f $file&lt;/code&gt; as an argument to another filetest operator, no special magic will happen.)</source>
          <target state="translated">从Perl 5.10.0开始，作为一种纯粹的语法糖，您可以使用 &lt;code&gt;-f -w -x $file&lt;/code&gt; 等效于 &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; 的方式来堆叠文件测试运算符。（这只是花哨的语法：如果将 &lt;code&gt;-f $file&lt;/code&gt; 的返回值用作另一个filetest运算符的参数，则不会发生特殊的魔术。）</target>
        </trans-unit>
        <trans-unit id="03db908cbb1531eee3e0f01a16bb3f1d5ad12f15" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file test operators, in a way that &lt;code&gt;-f -w -x $file&lt;/code&gt; is equivalent to &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt;. (This is only fancy syntax: if you use the return value of &lt;code&gt;-f $file&lt;/code&gt; as an argument to another filetest operator, no special magic will happen.)</source>
          <target state="translated">从Perl 5.10.0开始，作为纯语法糖的一种形式，您可以使用 &lt;code&gt;-f -w -x $file&lt;/code&gt; 等效于 &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; 的方式来堆叠文件测试运算符。（这只是花哨的语法：如果将 &lt;code&gt;-f $file&lt;/code&gt; 的返回值用作另一个filetest运算符的参数，则不会发生特殊的魔术。）</target>
        </trans-unit>
        <trans-unit id="4eb7e07d934fae953d19f8161458d55420e41446" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, one can create custom regular expression engines. This is not for the faint of heart, as they have to plug in at the C level. See &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; for more details.</source>
          <target state="translated">从Perl 5.10.0开始，可以创建自定义正则表达式引擎。这不是出于胆小，因为他们必须在C级别插入。有关更多详细信息，请参见&lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c7a09399a8f27b12757a6f71f279fa17b42fdfd" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, you can also use the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers to force big- or little-endian byte-order. This is useful if you want to store signed integers or 64-bit integers, for example.</source>
          <target state="translated">从Perl 5.10.0开始，还可以使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&lt;/code&gt; 修饰符强制使用大尾数字节顺序。例如，如果要存储带符号整数或64位整数，此功能将非常有用。</target>
        </trans-unit>
        <trans-unit id="835734cf27f076a5a1e9340fb76782ceeb1a149b" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.1 there is a new interface for plugging and using method resolution orders other than the default (linear depth first search). The C3 method resolution order added in 5.10.0 has been re-implemented as a plugin, without changing its Perl-space interface.</source>
          <target state="translated">从 Perl 5.10.1 开始,有了一个新的接口,用于插入和使用除默认值(线性深度优先搜索)以外的方法解析顺序。5.10.0中添加的C3方法解析顺序已经作为一个插件重新实现,而没有改变它的Perl空间接口。</target>
        </trans-unit>
        <trans-unit id="ec3d8a5f4531571b478743636520cd49e4ac13cb" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; on every iteration. If either a &lt;code&gt;readdir&lt;/code&gt; expression or an explicit assignment of a &lt;code&gt;readdir&lt;/code&gt; expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="translated">从Perl 5.12开始，您可以在 &lt;code&gt;while&lt;/code&gt; 循环中使用裸&lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt; &lt;code&gt;readdir&lt;/code&gt; &lt;/a&gt;，这将在每次迭代中设置&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;。如果无论是 &lt;code&gt;readdir&lt;/code&gt; 的表达式或一个明确的分配 &lt;code&gt;readdir&lt;/code&gt; 表达一个标作为 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; 条件，则条件实际测试的表达式的值的definedness，不为其经常真值。</target>
        </trans-unit>
        <trans-unit id="4ca2607d4b8da91c9aab14d61ac0b65b288bfff7" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">从Perl 5.12开始，您可以在 &lt;code&gt;while&lt;/code&gt; 循环中使用裸 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; ，这将在每次迭代中设置 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ef4b7baf6bbb1a8636644643a30ec84c9a4f514" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">从Perl 5.12开始，您可以在 &lt;code&gt;while&lt;/code&gt; 循环中使用裸 &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; ，这将在每次迭代中设置 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9aad368f35112b0ebb60af7e4b6035d03ee10832" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12, deprecated features and modules warn the user as they're used. When a module is deprecated, it will also be made available on CPAN. Installing it from CPAN will silence deprecation warnings for that module.</source>
          <target state="translated">从Perl 5.12开始,废弃的功能和模块在使用时都会向用户发出警告。当一个模块被弃用时,它也会在CPAN上被提供。从CPAN上安装它,将使该模块的废弃警告沉默。</target>
        </trans-unit>
        <trans-unit id="7bc75da6cf8214f9a49a145ca7f1ff6dd1976a38" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 every hash has its own hash traversal order, and this order changes every time a new element is inserted into the hash. This functionality is provided by maintaining an unsigned integer mask (U32) which is xor'ed with the actual bucket id during a traversal of the hash buckets using keys(), values() or each().</source>
          <target state="translated">从Perl 5.18开始,每个哈希都有自己的哈希遍历顺序,而且这个顺序在每次有新元素插入哈希时都会改变。这个功能是通过维护一个无符号整数掩码 (U32)来提供的,这个掩码在使用 keys()、value()或 each()对哈希桶进行遍历时与实际的桶 ID 进行 xor'ed。</target>
        </trans-unit>
        <trans-unit id="52e65492e2356da13376652cd3b63537c008c53e" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; on every iteration. If either an &lt;code&gt;each&lt;/code&gt; expression or an explicit assignment of an &lt;code&gt;each&lt;/code&gt; expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="translated">从Perl 5.18开始，您可以在 &lt;code&gt;while&lt;/code&gt; 循环中使用裸露的&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;循环，这将在每次迭代中设置&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;。如果将 &lt;code&gt;each&lt;/code&gt; 表达式或 &lt;code&gt;each&lt;/code&gt; 表达式对标量的显式分配用作 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; 条件，则该条件实际上会测试表达式值的定义性，而不是其常规真值。</target>
        </trans-unit>
        <trans-unit id="a8b875400d906734f1b4f9f29eb27503d8a35f16" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">从Perl 5.18开始，您可以在 &lt;code&gt;while&lt;/code&gt; 循环中使用裸露的 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 循环，这将在每次迭代中设置 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="211e0f721f82a57a3e303b9bd4a37e7c878adb86" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">从Perl 5.18开始，您可以在 &lt;code&gt;while&lt;/code&gt; 循环中使用裸露的 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 循环，这将在每次迭代中设置 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c33c32e4c4b133822c39af8f8540bc2360a9b3e1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.20, instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; you can use:</source>
          <target state="translated">从Perl 5.20开始，代替 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; 您可以使用：</target>
        </trans-unit>
        <trans-unit id="9ee11b59ca6b84291fdd57fa90c4a5348d5dae02" translate="yes" xml:space="preserve">
          <source>As of Perl 5.20, instead of &lt;code&gt;use warnings FATAL =&amp;gt; 'all';&lt;/code&gt; you can use:</source>
          <target state="translated">从Perl 5.20开始，代替 &lt;code&gt;use warnings FATAL =&amp;gt; 'all';&lt;/code&gt; 您可以使用：</target>
        </trans-unit>
        <trans-unit id="c35a63f8082ff3fbb7b2bded313d23f6fdc3cfd9" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, there is an experimental variant of this loop that accepts a variable preceded by a backslash for VAR, in which case the items in the LIST must be references. The backslashed variable will become an alias to each referenced item in the LIST, which must be of the correct type. The variable needn't be a scalar in this case, and the backslash may be followed by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. To use this form, you must enable the &lt;code&gt;refaliasing&lt;/code&gt; feature via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. See also &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">从Perl 5.22开始，此循环有一个实验变体，它接受一个变量，在VAR之前加一个反斜杠，在这种情况下，LIST中的项目必须是引用。反斜杠变量将成为LIST中每个引用项目的别名，该项目的类型必须正确。在这种情况下，变量不必是标量，反斜杠后面可以加上 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 。要使用此表单，您必须通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; feature启用 &lt;code&gt;refaliasing&lt;/code&gt; 功能。 （请参阅&lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;。另请参见&lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;在perlref中分配给引用&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="4cc3a1608477d241ae1d9f45daf77429c175f625" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, there is an experimental variant of this loop that accepts a variable preceded by a backslash for VAR, in which case the items in the LIST must be references. The backslashed variable will become an alias to each referenced item in the LIST, which must be of the correct type. The variable needn't be a scalar in this case, and the backslash may be followed by &lt;code&gt;my&lt;/code&gt;. To use this form, you must enable the &lt;code&gt;refaliasing&lt;/code&gt; feature via &lt;code&gt;use feature&lt;/code&gt;. (See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. See also &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;&quot;Assigning to References&quot; in perlref&lt;/a&gt;.)</source>
          <target state="translated">从Perl 5.22开始，此循环有一个实验变体，它接受一个变量，在VAR之前加一个反斜杠，在这种情况下，LIST中的项目必须是引用。反斜杠变量将成为LIST中每个引用项目的别名，该项目必须是正确的类型。在这种情况下，该变量不必是标量，反斜杠后面可以加上 &lt;code&gt;my&lt;/code&gt; 。要使用此表单，您必须通过 &lt;code&gt;use feature&lt;/code&gt; 启用 &lt;code&gt;refaliasing&lt;/code&gt; 功能。 （请参阅&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。另请参见&lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;perlref中的&amp;ldquo;分配参考&amp;rdquo;&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="df42579e1cb5e3f110d0c1cf4c3bbc08eda67128" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, this buggy behavior, while preserved for backward compatibility, is detected and emits a deprecation warning. If you want the subroutine to be inlined (with no warning), make sure the variable is not used in a context where it could be modified aside from where it is declared.</source>
          <target state="translated">从Perl 5.22开始,这种错误的行为虽然是为了向后兼容而保留的,但会被检测到并发出废弃警告。如果你想让子程序内联(没有警告),请确保变量没有被用于除了声明的地方之外的其他地方。</target>
        </trans-unit>
        <trans-unit id="b18e8f64ae6fd8a43ee4372bec94f73e67d74058" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, you can also use &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (You can also do &lt;code&gt;($x) x 2&lt;/code&gt; , which is less useful, because it assigns to the same variable twice, clobbering the first value assigned.)</source>
          <target state="translated">从Perl 5.22开始，您还可以使用 &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; 代替 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。（您也可以执行 &lt;code&gt;($x) x 2&lt;/code&gt; ，这没什么用，因为它两次分配给同一变量两次，破坏了第一个分配的值。）</target>
        </trans-unit>
        <trans-unit id="adc72631156437f156fe787062790a9076462201" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, you can also use &lt;code&gt;(undef)x2&lt;/code&gt; instead of &lt;code&gt;undef, undef&lt;/code&gt;. (You can also do &lt;code&gt;($x) x 2&lt;/code&gt;, which is less useful, because it assigns to the same variable twice, clobbering the first value assigned.)</source>
          <target state="translated">从Perl 5.22开始，您还可以使用 &lt;code&gt;(undef)x2&lt;/code&gt; 代替 &lt;code&gt;undef, undef&lt;/code&gt; 。（您也可以执行 &lt;code&gt;($x) x 2&lt;/code&gt; ，这没什么用，因为它两次分配给同一变量两次，破坏了第一个分配的值。）</target>
        </trans-unit>
        <trans-unit id="485dbe5ed6cb5d47f12b9abb8eb25ef72fc078a7" translate="yes" xml:space="preserve">
          <source>As of Perl 5.24, use of this feature no longer triggers a warning, though the &lt;code&gt;experimental::postderef&lt;/code&gt; warning category still exists (for compatibility with code that disables it).</source>
          <target state="translated">从Perl 5.24开始，使用此功能不再触发警告，尽管 &lt;code&gt;experimental::postderef&lt;/code&gt; 警告类别仍然存在（以与禁用它的代码兼容）。</target>
        </trans-unit>
        <trans-unit id="795c67df489058534540e8b295b838da24c8850d" translate="yes" xml:space="preserve">
          <source>As of Perl 5.25 the return was changed to be the count of keys in the hash. If you need access to the old behavior you can use &lt;code&gt;Hash::Util::bucket_ratio()&lt;/code&gt; instead.</source>
          <target state="translated">从Perl 5.25开始，返回值已更改为哈希中的键计数。如果您需要访问旧行为，则可以使用 &lt;code&gt;Hash::Util::bucket_ratio()&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="9a4dc26e9cc8e6190d88b95c93b52fd5320659be" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26, the list-context range operator on strings works as expected in the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt;&lt;/a&gt;. In previous versions, and outside the scope of that feature, it exhibits &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;: its behavior depends on the internal encoding of the range endpoint.</source>
          <target state="translated">从Perl 5.26开始，字符串的list-context范围运算符在&lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; &lt;/a&gt;范围内按预期工作。在以前的版本中，在该功能的范围之外，它&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;在perlunicode中&lt;/a&gt;显示&amp;ldquo; The Unicode Bug&amp;rdquo;：其行为取决于范围端点的内部编码。</target>
        </trans-unit>
        <trans-unit id="f8155f16a3b816f25d3b7bda9eaf9e783e3bae93" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26, use of this feature no longer triggers a warning, though the &lt;code&gt;experimental::lexical_subs&lt;/code&gt; warning category still exists (for compatibility with code that disables it). In addition, this syntax is not only no longer experimental, but it is enabled for all Perl code, regardless of what feature declarations are in scope.</source>
          <target state="translated">从Perl 5.26开始，使用此功能不再触发警告，尽管 &lt;code&gt;experimental::lexical_subs&lt;/code&gt; 警告类别仍然存在（以与禁用它的代码兼容）。另外，此语法不仅不再是实验性的，而且对所有Perl代码都启用了此语法，而不管作用域中有哪些功能声明。</target>
        </trans-unit>
        <trans-unit id="644c2bcdf8b193d872fddb3b64677c202b8cacc1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26.0, this module has no effect. The internal Perl feature that was used to implement this module has been removed. In recent years, much work has been done on the Perl core to eliminate discrepancies in the treatment of upgraded versus downgraded strings. In addition, the &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma, which caused many of the problems, is no longer supported. Thus, the warnings this module produced are no longer necessary.</source>
          <target state="translated">从Perl 5.26.0开始，此模块无效。用于实现此模块的内部Perl功能已被删除。近年来，在消除Perl内核在升级和降级字符串处理方面的差异方面，已经进行了许多工作。此外，不再支持引起许多问题的&lt;a href=&quot;encoding&quot;&gt;编码&lt;/a&gt;用法。因此，不再需要该模块产生的警告。</target>
        </trans-unit>
        <trans-unit id="c1154c7dc017ae8cf6bc262f38694d16778c8f10" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, setting &lt;code&gt;$/&lt;/code&gt; to a reference of a non-positive integer throws a fatal error.</source>
          <target state="translated">从Perl 5.28开始，将 &lt;code&gt;$/&lt;/code&gt; 设置为非正整数的引用会引发致命错误。</target>
        </trans-unit>
        <trans-unit id="097112fced1ea44933320d3c2e627da3a57d8e96" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, these attributes are syntax errors. Since the attributes do not do anything, removing them from your code fixes the syntax error; and removing them will not influence the behaviour of your code.</source>
          <target state="translated">从Perl 5.28开始,这些属性属于语法错误。由于这些属性没有任何作用,从你的代码中删除它们可以修复语法错误;而且删除它们不会影响你的代码行为。</target>
        </trans-unit>
        <trans-unit id="4698cfe65801c463a3e671c9cf65833d68ff49ae" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, this special-cased whitespace splitting works as expected in the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt;&lt;/a&gt;. In previous versions, and outside the scope of that feature, it exhibits &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;: characters that are whitespace according to Unicode rules but not according to ASCII rules can be treated as part of fields rather than as field separators, depending on the string's internal encoding.</source>
          <target state="translated">从Perl 5.28开始，这种特殊情况下的空格分割按预期在&lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; &lt;/a&gt;范围内起作用。在以前的版本中，在该功能的范围之外，它&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;在perlunicode中&lt;/a&gt;显示&amp;ldquo;&amp;ldquo; Unicode Bug&amp;rdquo;&amp;rdquo;：根据Unicode规则为空白但不按照ASCII规则为空白的字符可以被视为字段的一部分，而不是字段分隔符，具体取决于字符串的内部编码。</target>
        </trans-unit>
        <trans-unit id="df44a28f7cb4ce868d57f8dd07bcda2680ebf3e0" translate="yes" xml:space="preserve">
          <source>As of Perl 5.30, use of delimiters which are non-standalone graphemes is fatal, in order to move the language to be able to accept multi-character graphemes as delimiters.</source>
          <target state="translated">从Perl 5.30开始,为了使语言能够接受多字符字符作为定界符,使用非独立字符的定界符是致命的。</target>
        </trans-unit>
        <trans-unit id="3dcb750cd92914748543d04c418a1857ae25be47" translate="yes" xml:space="preserve">
          <source>As of Perl 5.32, this message is no longer generated. Instead, see &lt;a href=&quot;#Non-octal-character-%27%25c%27-terminates-%5Co-early.-Resolved-as-%22%25s%22&quot;&gt;&quot;Non-octal character '%c' terminates \o early. Resolved as &quot;%s&quot;&quot;&lt;/a&gt;. (W misc, regexp) You wrote something like &lt;code&gt;\08&lt;/code&gt;, or &lt;code&gt;\179&lt;/code&gt; in a double-quotish string. All but the last digit is treated as a single character, specified in octal. The last digit is the next character in the string. To tell Perl that this is indeed what you want, you can use the &lt;code&gt;\o{ }&lt;/code&gt; syntax, or use exactly three digits to specify the octal for the character.</source>
          <target state="translated">从Perl 5.32开始，不再生成此消息。而是，请参见&lt;a href=&quot;#Non-octal-character-%27%25c%27-terminates-%5Co-early.-Resolved-as-%22%25s%22&quot;&gt;&amp;ldquo;非八进制字符'％c'提前\ o终止。解析为&amp;ldquo;％s&amp;rdquo;&amp;ldquo;&lt;/a&gt;。（W misc，regexp）您在双引号字符串中编写了 &lt;code&gt;\08&lt;/code&gt; 或 &lt;code&gt;\179&lt;/code&gt; 类的内容。除最后一位数字外，所有其他数字均被视为一个字符，以八进制指定。最后一位数字是字符串中的下一个字符。要告诉Perl这确实是您想要的，可以使用 &lt;code&gt;\o{ }&lt;/code&gt; 语法，或者恰好使用三个数字来指定字符的八进制。</target>
        </trans-unit>
        <trans-unit id="6f3aa7e1697ed4bbe63edb4cde5bc634c7d4943e" translate="yes" xml:space="preserve">
          <source>As of Perl 5.6, you can represent filehandles with scalar variables which you treat as any other scalar.</source>
          <target state="translated">在Perl 5.6中,你可以用标量变量来表示filehandle,你可以像对待其他标量一样对待它。</target>
        </trans-unit>
        <trans-unit id="90e7536680dcd18ada661ef157609a74a6cebee3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0 after using this module you cannot use the implicit &lt;code&gt;$_&lt;/code&gt; or the special filehandle &lt;code&gt;_&lt;/code&gt; with stat() or lstat(), trying to do so leads into strange errors. The workaround is for &lt;code&gt;$_&lt;/code&gt; to be explicit</source>
          <target state="translated">从使用此模块的Perl 5.8.0开始，您不能将隐式 &lt;code&gt;$_&lt;/code&gt; 或特殊文件句柄 &lt;code&gt;_&lt;/code&gt; 与stat（）或lstat（）一起使用，尝试这样做会导致奇怪的错误。解决方法是使 &lt;code&gt;$_&lt;/code&gt; 明确</target>
        </trans-unit>
        <trans-unit id="115a406a7271cc4332af7b8bb93f168d625583f1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, at least the following encodings are recognized. Note that unless otherwise specified, they are all case insensitive (via alias) and all occurrence of spaces are replaced with '-'. In other words, &quot;ISO 8859 1&quot; and &quot;iso-8859-1&quot; are identical.</source>
          <target state="translated">从Perl 5.8.0开始,至少可以识别以下编码。请注意,除非另有说明,否则它们都是不区分大小写的(通过别名),所有出现的空格都用'-'代替。换句话说,&quot;ISO 8859 1 &quot;和 &quot;iso-8859-1 &quot;是相同的。</target>
        </trans-unit>
        <trans-unit id="5fd0a9a99a09c2a713ff60adbdf886450b68308c" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, the &quot;Full&quot; case-folding of</source>
          <target state="translated">在Perl 5.8.0中,&quot;Full &quot;的大小写折叠为</target>
        </trans-unit>
        <trans-unit id="444326d8d5a5982dc22e2a52147d982ac07eb8e8" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with multiple arguments. Just like the list forms of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;, no shell escapes happen.</source>
          <target state="translated">从Perl 5.8.0开始，您可以将 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 与多个参数一起使用。就像 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 的列表形式一样，不会发生外壳转义。</target>
        </trans-unit>
        <trans-unit id="df8794a0813798e6a0cf5a13a0dc7223a79a0992" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, you can use &lt;code&gt;open()&lt;/code&gt; with multiple arguments. Just like the list forms of &lt;code&gt;system()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt;, no shell escapes happen.</source>
          <target state="translated">从Perl 5.8.0开始，您可以将 &lt;code&gt;open()&lt;/code&gt; 与多个参数一起使用。就像 &lt;code&gt;system()&lt;/code&gt; 和 &lt;code&gt;exec()&lt;/code&gt; 的列表形式一样，不会发生任何外壳转义。</target>
        </trans-unit>
        <trans-unit id="a68a3c591a49e26bfd6e1872f3f7a653d522ef71" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1 the dynamic loading of libraries (DynaLoader, XSLoader) also seems to have become broken in in SunOS 4.x. Therefore the default is to build Perl statically.</source>
          <target state="translated">在Perl 5.8.1中,动态加载库(DynaLoader、XSLoader)的功能在SunOS 4.x中似乎也被破坏了,因此默认是静态地构建Perl。</target>
        </trans-unit>
        <trans-unit id="ef5cb6c37e267f59227533f0250c84c8718b7076" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1, &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; also has the &lt;code&gt;utf8::is_utf8&lt;/code&gt; function.</source>
          <target state="translated">从Perl 5.8.1开始，&lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;还具有 &lt;code&gt;utf8::is_utf8&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="ab205322181f94cdf41d5eaaf572850bb63def33" translate="yes" xml:space="preserve">
          <source>As of Perl 5.9.5 there is a new interface for plugging and using regular expression engines other than the default one.</source>
          <target state="translated">在Perl 5.9.5中,除了默认的正则表达式引擎外,还有一个新的接口用于插入和使用正则表达式引擎。</target>
        </trans-unit>
        <trans-unit id="02c3c3ae5c3a1698c2091dbb44ff1c48ff7a71dd" translate="yes" xml:space="preserve">
          <source>As of Perl Symbian port version 0.4.1 any part of Perl's standard regression test suite has not been run on a real Symbian device using the ported Perl, so innumerable bugs may lie in wait. Therefore there is absolutely no warranty.</source>
          <target state="translated">从Perl Symbian 0.4.1版本开始,Perl标准回归测试套件的任何部分都没有在使用移植Perl的真实Symbian设备上运行过,所以可能会有无数的错误在等待。因此,我们绝对不作任何保证。</target>
        </trans-unit>
        <trans-unit id="470b823d90414a4ffaec0c54908966f5bb0b6779" translate="yes" xml:space="preserve">
          <source>As of Perl v5.16.0, it is implemented by the &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module.</source>
          <target state="translated">从Perl v5.16.0开始，它由&lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;模块实现。</target>
        </trans-unit>
        <trans-unit id="2a7301a461e47b0be61be125749323ecdfc5a92a" translate="yes" xml:space="preserve">
          <source>As of Perl v5.16.0, it is implemented by the &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module. See &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; for more details on its behaviour.</source>
          <target state="translated">从Perl v5.16.0开始，它由&lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;模块实现。有关其行为的更多详细信息，请参见&lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cf84017310ef88efe853e952dd2c6c52ce61386" translate="yes" xml:space="preserve">
          <source>As of Perl v5.30.0, or under &lt;code&gt;use v5.16&lt;/code&gt;, or &lt;code&gt;no feature &quot;array_base&quot;&lt;/code&gt;, &lt;code&gt;$[&lt;/code&gt; no longer has any effect, and always contains 0. Assigning 0 to it is permitted, but any other value will produce an error.</source>
          <target state="translated">从Perl v5.30.0开始，或正在 &lt;code&gt;use v5.16&lt;/code&gt; ，或 &lt;code&gt;no feature &quot;array_base&quot;&lt;/code&gt; ， &lt;code&gt;$[&lt;/code&gt; 不再具有任何作用，并且始终包含0。允许为其分配0，但是任何其他值都会产生错误。</target>
        </trans-unit>
        <trans-unit id="9f7c19e511eae81348e03d06d3194e0d82d15184" translate="yes" xml:space="preserve">
          <source>As of R2.5 of USS for OS/390 and Version 2.3 of VM/ESA these Unix sub-systems do not support the &lt;code&gt;#!&lt;/code&gt; shebang trick for script invocation. Hence, on OS/390 and VM/ESA Perl scripts can be executed with a header similar to the following simple script:</source>
          <target state="translated">从OSS的R2.5 / OS / 390版本和VM / ESA的2.3版开始，这些Unix子系统不支持 &lt;code&gt;#!&lt;/code&gt; shebang脚本调用技巧。因此，在OS / 390和VM / ESA上，可以使用类似于以下简单脚本的标头执行Perl脚本：</target>
        </trans-unit>
        <trans-unit id="4e29546f04e5cfe2122e46676161bb58e8a9f171" translate="yes" xml:space="preserve">
          <source>As of Unicode 6.0, this is always empty.</source>
          <target state="translated">在Unicode 6.0中,这个值总是空的。</target>
        </trans-unit>
        <trans-unit id="6be62dadd6bbd6b8a9fe9bd5f460bd2ea3dfc014" translate="yes" xml:space="preserve">
          <source>As of VERSION 1.18 all IO::Socket objects have autoflush turned on by default. This was not the case with earlier releases.</source>
          <target state="translated">从 1.18 版开始,所有 IO::Socket 对象的自动刷新功能默认为开启。在早期的版本中不是这样的。</target>
        </trans-unit>
        <trans-unit id="9b18b6d1424b74e3d0360d9f0334585a766708d3" translate="yes" xml:space="preserve">
          <source>As of db-4.2.x it is no longer needed to do this by hand. Sleepycat has changed the configuration process to add +z on HP-UX automatically.</source>
          <target state="translated">从db-4.2.x开始,不再需要手工操作了。Sleepycat已经改变了配置过程,在HP-UX上自动添加+z。</target>
        </trans-unit>
        <trans-unit id="d75d887c21a8a54a73e586867619f60f35cac751" translate="yes" xml:space="preserve">
          <source>As of libcrypt 1.3 (March 2016), you will need to install the libcrypt-devel package for Configure to detect crypt().</source>
          <target state="translated">从libcrypt 1.3(2016年3月)开始,你需要为Configure安装libcrypt-devel包来检测crypt()。</target>
        </trans-unit>
        <trans-unit id="ddb5b154eee158ecabd0abbac4ff1eab5e92e45f" translate="yes" xml:space="preserve">
          <source>As of perl 5.14 it is possible to hook into the compile-time lexical scope mechanism using &lt;code&gt;Perl_blockhook_register&lt;/code&gt; . This is used like this:</source>
          <target state="translated">从perl 5.14开始，可以使用 &lt;code&gt;Perl_blockhook_register&lt;/code&gt; 挂接到编译时词法范围机制。这样使用：</target>
        </trans-unit>
        <trans-unit id="ad95286c36cd410295b8a2ce1cb7201a227c4aba" translate="yes" xml:space="preserve">
          <source>As of perl 5.14 it is possible to hook into the compile-time lexical scope mechanism using &lt;code&gt;Perl_blockhook_register&lt;/code&gt;. This is used like this:</source>
          <target state="translated">从perl 5.14开始，可以使用 &lt;code&gt;Perl_blockhook_register&lt;/code&gt; 插入编译时词法作用域机制。这是这样使用的：</target>
        </trans-unit>
        <trans-unit id="11e27b1acb1512cd132ffd47cefd52584149d78c" translate="yes" xml:space="preserve">
          <source>As of perl 5.25 this function is used only for debugging purposes, and the number of used hash buckets is not in any way cached, thus this function can be costly to execute as it must iterate over all the buckets in the hash.</source>
          <target state="translated">在 perl 5.25 中,这个函数只用于调试目的,而且使用过的哈希桶的数量并没有以任何方式被缓存,因此这个函数的执行成本很高,因为必须对哈希中的所有桶进行迭代。</target>
        </trans-unit>
        <trans-unit id="283446be77b5c5650a7aade52dfb5d3e56c4e299" translate="yes" xml:space="preserve">
          <source>As of perl 5.9.5 're' debug contains a number of utility functions that may be optionally exported into the caller's namespace. They are listed below.</source>
          <target state="translated">从perl 5.9.5开始,'re'debug包含了一些实用函数,这些函数可以选择导出到调用者的命名空间中。下面列出了这些函数。</target>
        </trans-unit>
        <trans-unit id="e452fc188847c39d477f7724ca763c55646692fe" translate="yes" xml:space="preserve">
          <source>As of perl 5.9.5/Win32 0.27, these functions have been moved into the Win32 module. Win32CORE provides stubs for each of the former CORE Win32:: functions that internally just load the Win32 module and call it's version, and Win32CORE is statically linked to perl for both cygwin and regular win32 builds. This will permit these functions to be updated in the CPAN Win32 module independently of updating perl.</source>
          <target state="translated">从perl 5.9.5/Win32 0.27开始,这些函数已经被移到Win32模块中。Win32CORE为以前的CORE Win32::函数提供了存根,在内部只需加载Win32模块并调用它的版本,Win32CORE与perl静态链接,用于cygwin和普通的win32构建。这样就可以在CPAN Win32模块中独立更新这些函数,而不需要更新perl。</target>
        </trans-unit>
        <trans-unit id="5916c6705e19aa4737c1eaecb1fdda26e7395e63" translate="yes" xml:space="preserve">
          <source>As of perl5.6, open() autovivifies file and directory handles as references if you pass it an uninitialized scalar variable. You can then pass these references just like any other scalar, and use them in the place of named handles.</source>
          <target state="translated">从 perl5.6 开始,如果你传给它一个未初始化的标量变量,open()会自动将文件和目录句柄作为引用。然后你可以像传递其他标量一样传递这些引用,并在命名句柄的位置使用它们。</target>
        </trans-unit>
        <trans-unit id="0d06e02fdc69f862d76b045e6be72fc487c78e0b" translate="yes" xml:space="preserve">
          <source>As of perl5.7.2 all tests pass under:</source>
          <target state="translated">从perl5.7.2开始,所有的测试都通过了下。</target>
        </trans-unit>
        <trans-unit id="e7ebc726132cf88aa72c90598602d1b0ee48a664" translate="yes" xml:space="preserve">
          <source>As of perl5.8.1 there is at least one test still failing.</source>
          <target state="translated">截止到perl5.8.1,至少还有一个测试失败。</target>
        </trans-unit>
        <trans-unit id="1b82fd373dbd0883f99d276e806ca9d5f0a6e144" translate="yes" xml:space="preserve">
          <source>As of release 5 of Perl, assignment to &lt;code&gt;$[&lt;/code&gt; is treated as a compiler directive, and cannot influence the behavior of any other file. (That's why you can only assign compile-time constants to it.) Its use is highly discouraged.</source>
          <target state="translated">从Perl的第5版开始，分配给 &lt;code&gt;$[&lt;/code&gt; 被视为编译器指令，并且不会影响任何其他文件的行为。（这就是为什么您只能为其分配编译时常量的原因。）强烈建议不要使用它。</target>
        </trans-unit>
        <trans-unit id="1e2bbc98f0506e501d121cbf3463e0bb77e718b4" translate="yes" xml:space="preserve">
          <source>As of release 5.003_01 perl is linked to multithreaded C RTL DLL. If perl itself is not compiled multithread-enabled, so will not be perl's malloc(). However, extensions may use multiple thread on their own risk.</source>
          <target state="translated">从5.003_01版本开始,perl与多线程的C RTL DLL链接。如果perl本身没有编译为多线程启用,所以不会被perl的malloc()。但是,扩展可以使用多线程,风险自负。</target>
        </trans-unit>
        <trans-unit id="5dbdb753a9581b45c8e16e8caa7ad1fc9cd73184" translate="yes" xml:space="preserve">
          <source>As of right now, this returns 2 if the path is absolute with a volume, 1 if it's absolute with no volume, 0 otherwise.</source>
          <target state="translated">目前,如果路径是绝对的,有体积,则返回2,如果是绝对的,没有体积,则返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="cedde28f0889c00006609cd1f4e0ab992b6b315c" translate="yes" xml:space="preserve">
          <source>As of the date of this document's last update, the following systems contain PA-RISC 2.0 chips:</source>
          <target state="translated">截至本文档最后一次更新之日,以下系统包含PA-RISC 2.0芯片。</target>
        </trans-unit>
        <trans-unit id="361f300829fa013b44d60226e2c65866392ff21f" translate="yes" xml:space="preserve">
          <source>As of the date of this document, Perl is fully 64-bit compliant on HP-UX 11.00 and up for both cc- and gcc builds. If you are about to build a 64-bit perl with GNU gcc, please read the gcc section carefully.</source>
          <target state="translated">截至本文档发布之日,Perl在HP-UX 11.00及以上版本的cc-和gcc构建中已经完全兼容64位。如果你准备用GNU gcc构建64位的Perl,请仔细阅读gcc部分。</target>
        </trans-unit>
        <trans-unit id="6087654ae9665e2974920201f81ba084c4838564" translate="yes" xml:space="preserve">
          <source>As of the time this document was last revised, the following Perl functions were implemented in the VMS port of Perl (functions marked with * are discussed in more detail below):</source>
          <target state="translated">在本文档最后一次修订时,下列 Perl 函数在 Perl 的 VMS port 中实现了(标有*的函数将在下面详细讨论)。</target>
        </trans-unit>
        <trans-unit id="4d788164927e274de517225973608d97db84fe9f" translate="yes" xml:space="preserve">
          <source>As of this writing, any encoding whose class belongs to Encode::XS and Encode::Unicode works. The Encode module has a &lt;code&gt;perlio_ok&lt;/code&gt; method which you can use before applying PerlIO encoding to the filehandle. Here is an example:</source>
          <target state="translated">在撰写本文时，其类属于Encode :: XS和Encode :: Unicode的任何编码都可以使用。Encode模块具有 &lt;code&gt;perlio_ok&lt;/code&gt; 方法，您可以在将PerlIO编码应用于文件句柄之前使用该方法。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="2f434753b82171852395258695f5260796bd3e54" translate="yes" xml:space="preserve">
          <source>As of v5.14, Perl distinguishes three subclasses of UTF‑8 warnings.</source>
          <target state="translated">在5.14版本中,Perl区分了三个UTF-8警告的子类。</target>
        </trans-unit>
        <trans-unit id="3687eac7ed0d3e9a3819b6d8b59ffbbce6f96ce7" translate="yes" xml:space="preserve">
          <source>As of v5.18.0, both keys and values stored in &lt;code&gt;%ENV&lt;/code&gt; are stringified.</source>
          <target state="translated">从v5.18.0开始， &lt;code&gt;%ENV&lt;/code&gt; 中存储的键和值都被字符串化。</target>
        </trans-unit>
        <trans-unit id="068ae70c04574cc37cc34db842b7ac8d0c145fb6" translate="yes" xml:space="preserve">
          <source>As of version 1.01 of the AutoSplit module it is possible to have multiple packages within a single file. Both of the following cases are supported:</source>
          <target state="translated">从AutoSplit模块的1.01版本开始,它可以在一个文件中拥有多个包。支持以下两种情况。</target>
        </trans-unit>
        <trans-unit id="4d09237d697a620472d98ca9564ba252e7440a3a" translate="yes" xml:space="preserve">
          <source>As of version 1.02 (provided with perl 5.12) the object provides &lt;code&gt;&quot;-X&quot;&lt;/code&gt; overloading, so you can call filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on) on it. It also provides a &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method, called like</source>
          <target state="translated">从1.02版开始（由Perl 5.12提供），该对象提供了 &lt;code&gt;&quot;-X&quot;&lt;/code&gt; 重载，因此您可以在其上调用文件测试运算符（ &lt;code&gt;-f&lt;/code&gt; ， &lt;code&gt;-x&lt;/code&gt; 等）。它还提供了 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; 方法，称为</target>
        </trans-unit>
        <trans-unit id="3f4a112eabf93bbafc4bcc9a1025d0ef06b216ad" translate="yes" xml:space="preserve">
          <source>As of version 1.02 (provided with perl 5.12) the object provides &lt;code&gt;&quot;-X&quot;&lt;/code&gt; overloading, so you can call filetest operators (&lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;, and so on) on it. It also provides a &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method, called like</source>
          <target state="translated">从1.02版开始（由perl 5.12提供），该对象提供 &lt;code&gt;&quot;-X&quot;&lt;/code&gt; 重载，因此您可以在其上调用文件测试运算符（ &lt;code&gt;-f&lt;/code&gt; ， &lt;code&gt;-x&lt;/code&gt; 等）。它还提供了 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; 方法，称为</target>
        </trans-unit>
        <trans-unit id="39c91a8aec6b3b91e09f6a8bd53c1515a32cc61b" translate="yes" xml:space="preserve">
          <source>As of version 1.04 (Perl 5.10), strict verifies that it is used as &quot;strict&quot; to avoid the dreaded Strict trap on case insensitive file systems.</source>
          <target state="translated">从1.04版本(Perl 5.10)开始,strict验证了它是作为 &quot;strict &quot;来使用的,以避免在对大小写不敏感的文件系统上出现可怕的Strict陷阱。</target>
        </trans-unit>
        <trans-unit id="5750d09d680a68ca093b8cb502caecf523fc46de" translate="yes" xml:space="preserve">
          <source>As of version 1.32 of this module, constants can be defined in packages other than the caller, by including the package name in the name of the constant:</source>
          <target state="translated">从本模块的1.32版本开始,常量可以在调用者之外的包中定义,只要在常量的名称中加入包名即可。</target>
        </trans-unit>
        <trans-unit id="a9966baeb16dc71d9782450ad1960be303770497" translate="yes" xml:space="preserve">
          <source>As of version 1.47 the following additions were made to the install interface. Note that the new argument style and use of the %result hash is recommended.</source>
          <target state="translated">从1.47版本开始,安装界面增加了以下内容。请注意,建议使用新的参数样式和%result hash。</target>
        </trans-unit>
        <trans-unit id="e47319fd89f8639b4c6dc3d1dee645f4e3217716" translate="yes" xml:space="preserve">
          <source>As of version 2.12, &lt;code&gt;Encode&lt;/code&gt; supports coderef values for &lt;code&gt;CHECK&lt;/code&gt; ; see below.</source>
          <target state="translated">从2.12版开始， &lt;code&gt;Encode&lt;/code&gt; 支持 &lt;code&gt;CHECK&lt;/code&gt; 的 coderef值；见下文。</target>
        </trans-unit>
        <trans-unit id="ffc6a36f7c22fafbcd2974930b9d682b59ed0fd0" translate="yes" xml:space="preserve">
          <source>As of version 2.12, &lt;code&gt;Encode&lt;/code&gt; supports coderef values for &lt;code&gt;CHECK&lt;/code&gt;; see below.</source>
          <target state="translated">从2.12版开始， &lt;code&gt;Encode&lt;/code&gt; 支持 &lt;code&gt;CHECK&lt;/code&gt; 的coderef值；见下文。</target>
        </trans-unit>
        <trans-unit id="feaefe7da5a3f173789e3bc38d1cc052b48f0697" translate="yes" xml:space="preserve">
          <source>As of version 2.32 Getopt::Long provides auto-help, a quick and easy way to add the options --help and -? to your program, and handle them.</source>
          <target state="translated">从2.32版本开始,Getopt::Long提供了自动帮助,这是一种快速和简单的方法,可以将选项--help和--?添加到你的程序中,并处理它们。</target>
        </trans-unit>
        <trans-unit id="4961ac95a03fe72cd95305ebd10cd56767e6cd2e" translate="yes" xml:space="preserve">
          <source>As of version 5.00305, OS/2 perl binary distribution comes split into 11 components. Unfortunately, to enable configurable binary installation, the file paths in the zip files are not absolute, but relative to some directory.</source>
          <target state="translated">从5.00305版本开始,OS/2 perl二进制发行版被分成了11个组件。不幸的是,为了实现可配置的二进制安装,压缩文件中的文件路径不是绝对的,而是相对于某个目录的。</target>
        </trans-unit>
        <trans-unit id="0a03b6b4ddea7ad90c28bf2de5b6b3532c441bd5" translate="yes" xml:space="preserve">
          <source>As of version 5.12.0, perl has stopped using the time implementation of the operating system it's running on. Instead, it has its own implementation of those routines with a safe range of at least +/- 2**52 (about 142 million years)</source>
          <target state="translated">从5.12.0版本开始,perl已经停止使用它所运行的操作系统的时间实现。取而代之的是它自己的这些例程的实现,其安全范围至少为+/-2**52(约1.42亿年)。</target>
        </trans-unit>
        <trans-unit id="c5ef8d96f6d787f0f3cc3fb69a33144b75f432e6" translate="yes" xml:space="preserve">
          <source>As of version 5.12.0, perl has stopped using the underlying time library of the operating system it's running on and has its own implementation of those routines with a safe range of at least +/ 2**52 (about 142 million years).</source>
          <target state="translated">从5.12.0版本开始,perl已经不再使用它所运行的操作系统的底层时间库,而是有了自己的这些例程的实现,安全范围至少是+/2**52(约1.42亿年)。</target>
        </trans-unit>
        <trans-unit id="ede48005eab24777f4cf1c1c51404cc14a546bbe" translate="yes" xml:space="preserve">
          <source>As of writing (2010-09) only the</source>
          <target state="translated">截至编写本报告时(2010-09),只有</target>
        </trans-unit>
        <trans-unit id="9bba94e9dfeb863cebb5f1b8b07f6bae30ef1d7d" translate="yes" xml:space="preserve">
          <source>As opposed to &lt;a href=&quot;http://man.he.net/man3/atoi&quot;&gt;atoi(3)&lt;/a&gt; or &lt;a href=&quot;http://man.he.net/man3/strtol&quot;&gt;strtol(3)&lt;/a&gt;, &lt;code&gt;grok_atoUV&lt;/code&gt; does NOT allow optional leading whitespace, nor negative inputs. If such features are required, the calling code needs to explicitly implement those.</source>
          <target state="translated">与&lt;a href=&quot;http://man.he.net/man3/atoi&quot;&gt;atoi（3）&lt;/a&gt;或&lt;a href=&quot;http://man.he.net/man3/strtol&quot;&gt;strtol（3）相对&lt;/a&gt;， &lt;code&gt;grok_atoUV&lt;/code&gt; 不允许可选的前导空格，也不允许负输入。如果需要这些功能，则调用代码需要显式实现这些功能。</target>
        </trans-unit>
        <trans-unit id="53d68ae04ea90208ac09617d93481673c81dae0c" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;, in scalar context it should return the next line, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for no more data. In list context it should return all remaining lines, or an empty list for no more data. The strings returned should include the input record separator &lt;code&gt;$/&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), unless it is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (which means &quot;slurp&quot; mode).</source>
          <target state="translated">根据&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;，在标量上下文中，它应该返回下一行，或者为没有更多数据的 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。在列表上下文中，它应该返回所有剩余的行，或者返回一个空列表以容纳更多数据。返回的字符串应包括输入记录分隔符 &lt;code&gt;$/&lt;/code&gt; （请参阅&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;），除非它是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （表示&amp;ldquo; slurp&amp;rdquo;模式）。</target>
        </trans-unit>
        <trans-unit id="008a0000ee5b61a83c14df2cf7cee7f4e080298a" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;perlfunc#readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt;, in scalar context it should return the next line, or &lt;code&gt;undef&lt;/code&gt; for no more data. In list context it should return all remaining lines, or an empty list for no more data. The strings returned should include the input record separator &lt;code&gt;$/&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), unless it is &lt;code&gt;undef&lt;/code&gt; (which means &quot;slurp&quot; mode).</source>
          <target state="translated">按照&lt;a href=&quot;perlfunc#readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt;，在标量上下文中，它应该返回下一行，如果没有更多数据，则应返回 &lt;code&gt;undef&lt;/code&gt; 。在列表上下文中，它应该返回所有剩余的行，或者返回一个空列表以容纳更多数据。返回的字符串应包括输入记录分隔符 &lt;code&gt;$/&lt;/code&gt; （请参阅&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;），除非它是 &lt;code&gt;undef&lt;/code&gt; （表示&amp;ldquo; slurp&amp;rdquo;模式）。</target>
        </trans-unit>
        <trans-unit id="35db6e6083bf8853a0d7a773700bfc53f4f3833e" translate="yes" xml:space="preserve">
          <source>As per get(), but returns a tied filehandle. Reading from this filehandle returns the requested message. The filehandle will return EOF at the end of the message and should not be reused.</source>
          <target state="translated">和get()一样,但返回一个绑定的文件柄。从这个filehandle中读取会返回请求的消息。该filehandle将在消息结束时返回EOF,不应重复使用。</target>
        </trans-unit>
        <trans-unit id="f8d3cabb86865ec30b2f81b742c043bb4dfa0006" translate="yes" xml:space="preserve">
          <source>As perl does not use it, it is not well tested.</source>
          <target state="translated">由于perl没有使用它,所以不好测试。</target>
        </trans-unit>
        <trans-unit id="04f2eace94f5ec9fb309f7ef275b1f53f5b18652" translate="yes" xml:space="preserve">
          <source>As pragmata are implemented as modules, like any other module, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; becomes</source>
          <target state="translated">与其他模块一样， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; 实现为模块时，请使用 myint；变成</target>
        </trans-unit>
        <trans-unit id="95ffc5a9c7d9d21832644aa0005e8ab6e5d3fda8" translate="yes" xml:space="preserve">
          <source>As pragmata are implemented as modules, like any other module, &lt;code&gt;use myint;&lt;/code&gt; becomes</source>
          <target state="translated">与其他模块一样， &lt;code&gt;use myint;&lt;/code&gt; 实现为模块时，请使用myint。变成</target>
        </trans-unit>
        <trans-unit id="6ff69505257da499d009f94993a8c36d403bc517" translate="yes" xml:space="preserve">
          <source>As previously mentioned, the &quot;switch&quot; feature is considered highly experimental; it is subject to change with little notice. In particular, &lt;code&gt;when&lt;/code&gt; has tricky behaviours that are expected to change to become less tricky in the future. Do not rely upon its current (mis)implementation. Before Perl 5.18, &lt;code&gt;given&lt;/code&gt; also had tricky behaviours that you should still beware of if your code must run on older versions of Perl.</source>
          <target state="translated">如前所述，&amp;ldquo;开关&amp;rdquo;功能被认为是高度实验性的。它可能随时更改，恕不另行通知。特别是， &lt;code&gt;when&lt;/code&gt; 具有棘手的行为，并且这种行为有望在将来变得越来越棘手。不要依赖它的当前（错误）实现。 Perl的5.18之前， &lt;code&gt;given&lt;/code&gt; 也有棘手的行为，你还是应该提防如果你的代码必须在旧版本的Perl的运行。</target>
        </trans-unit>
        <trans-unit id="d4ddd43c6028587c10020a05414bb6d70c1790ee" translate="yes" xml:space="preserve">
          <source>As previously noted, individual entries (as opposed to the whole hash) are settable. Perl only cares about Boolean true here, although the values used by</source>
          <target state="translated">如前所述,单个条目(而不是整个哈希)是可以设置的。Perl在这里只关心布尔值true,虽然</target>
        </trans-unit>
        <trans-unit id="40863db850a5e2446412cc32d982d2e85c0c2a70" translate="yes" xml:space="preserve">
          <source>As setup, consider this (admittedly rather contrived) example of a tie; all it does is use a file to keep a log of the values assigned to a scalar.</source>
          <target state="translated">作为设置,考虑这个(公认的相当造作的)平局的例子;它所做的就是使用一个文件来保存分配给一个标量的值的日志。</target>
        </trans-unit>
        <trans-unit id="d5e7901b05cd99e70f1eb4d22405e5ec5c43c73a" translate="yes" xml:space="preserve">
          <source>As shipped, the only command-line history supplied is a simplistic one that checks for leading exclamation points. However, if you install the Term::ReadKey and Term::ReadLine modules from CPAN (such as Term::ReadLine::Gnu, Term::ReadLine::Perl, ...) you will have full editing capabilities much like those GNU</source>
          <target state="translated">在出厂时,唯一提供的命令行历史记录是一个简单的检查前导感叹号的记录。然而,如果您安装了 CPAN 的 Term::ReadKey 和 Term::ReadLine 模块 (如 Term::ReadLine::Gnu,Term::ReadLine::Perl,...),您将拥有完整的编辑功能,就像那些 GNU 的模块一样。</target>
        </trans-unit>
        <trans-unit id="3c7b29c9acaba84b5dfa9d94a08362e636c880e4" translate="yes" xml:space="preserve">
          <source>As shown above, Perl creates the backup file whether or not any output is actually changed. So this is just a fancy way to copy files:</source>
          <target state="translated">如上图所示,无论是否真的改变了任何输出,Perl都会创建备份文件。所以这只是一种花哨的复制文件的方式。</target>
        </trans-unit>
        <trans-unit id="cf827d39576175b49dc1a1c39fee2ddfa72908f4" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">如本例所示， &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 不受&amp;ldquo;看起来像函数&amp;rdquo;规则的约束。它后面的一对括号不会（必要）界定其参数。 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; 等同于 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; 。此外，与大多数命名运算符不同，此优先级与赋值相同。</target>
        </trans-unit>
        <trans-unit id="a246c967f8c44d960de455229b31b368ecdb7f4c" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">如本例所示， &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 不受&amp;ldquo;看起来像函数&amp;rdquo;规则的约束。它后面的一对括号不会（必要）界定其参数。 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; 等同于 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; 。此外，与大多数命名运算符不同，此优先级与赋值相同。</target>
        </trans-unit>
        <trans-unit id="69217332278a487735b9f765568e5e6b60cb13f1" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;goto EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/code&gt; is equivalent to &lt;code&gt;goto NEXT&lt;/code&gt;. Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">如本示例所示， &lt;code&gt;goto EXPR&lt;/code&gt; 不受&amp;ldquo;看起来像函数&amp;rdquo;规则的约束。它后面的一对括号没有（必要）定界其参数。 &lt;code&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/code&gt; 等同于 &lt;code&gt;goto NEXT&lt;/code&gt; 。另外，与大多数命名运算符不同，它的优先级与赋值相同。</target>
        </trans-unit>
        <trans-unit id="9bc78a790919531fd0718a68912f96b73236dccd" translate="yes" xml:space="preserve">
          <source>As some variables are reported by a different name in the output of &lt;code&gt;perl -V&lt;/code&gt; than their actual name in &lt;code&gt;%Config&lt;/code&gt;, I decided to leave the &lt;code&gt;config&lt;/code&gt; entry as close to reality as possible, and put in the entries that might have been guessed by the printed output in a separate block.</source>
          <target state="translated">由于一些变量在 &lt;code&gt;perl -V&lt;/code&gt; 的输出中报告的名称与 &lt;code&gt;%Config&lt;/code&gt; 中的实际名称不同，因此我决定使 &lt;code&gt;config&lt;/code&gt; 条目尽可能接近实际值，并输入可能由在单独的块中打印输出。</target>
        </trans-unit>
        <trans-unit id="48a035147de7a604eb6e8f9633c18d50b5e19c9b" translate="yes" xml:space="preserve">
          <source>As soon as one of my failing tests passes it will be removed from the list of failed tests. Eventually I fix them all and prove can find no failing tests to run:</source>
          <target state="translated">只要我的一个失败的测试通过,它就会从失败的测试列表中删除。最后我把它们全部修复,证明找不到失败的测试来运行。</target>
        </trans-unit>
        <trans-unit id="81930da4a8c9e7cfd6af4afe44478552245004db" translate="yes" xml:space="preserve">
          <source>As such, consumers may use this data for informational analysis, but presenting it to the user as canonical or relying on it as such is invariably the height of folly.</source>
          <target state="translated">因此,消费者可以利用这些数据进行信息分析,但把这些数据作为规范性的数据呈现给用户,或者把这些数据作为依赖性的数据,无形中是愚蠢的高度。</target>
        </trans-unit>
        <trans-unit id="6d2e840402d6fc0f9fee1fa99ab3b3ed1f5042e9" translate="yes" xml:space="preserve">
          <source>As such, signals that would normally not be appropriate to use in the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; command (e.g., &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ) are okay to use with the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; method (again, as illustrated above).</source>
          <target state="translated">这样，通常不适合在 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; 命令中使用的信号（例如， &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ）可以与 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 方法一起使用（同样，如上所示） 。</target>
        </trans-unit>
        <trans-unit id="2afd2bab6cbdd50c9685439c6b9fc8e46337a3ed" translate="yes" xml:space="preserve">
          <source>As such, signals that would normally not be appropriate to use in the &lt;code&gt;kill()&lt;/code&gt; command (e.g., &lt;code&gt;kill('KILL', $$)&lt;/code&gt;) are okay to use with the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; method (again, as illustrated above).</source>
          <target state="translated">这样，通常不适合在 &lt;code&gt;kill()&lt;/code&gt; 命令中使用的信号（例如， &lt;code&gt;kill('KILL', $$)&lt;/code&gt; ）可以与 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 方法一起使用（同样，如上所示） 。</target>
        </trans-unit>
        <trans-unit id="24bd5acc92d8894261d7ef9b04b6f856fb374ce1" translate="yes" xml:space="preserve">
          <source>As such, you open a pipe using the same &lt;code&gt;open&lt;/code&gt; call that you use for opening files, setting the second (&lt;code&gt;MODE&lt;/code&gt;) argument to special characters that indicate either an input or an output pipe. Use &lt;code&gt;&quot;-|&quot;&lt;/code&gt; for a filehandle that will let your Perl program read data from an external program, and &lt;code&gt;&quot;|-&quot;&lt;/code&gt; for a filehandle that will send data to that program instead.</source>
          <target state="translated">这样，您可以使用与 &lt;code&gt;open&lt;/code&gt; 文件相同的open调用来打开管道，将第二个（ &lt;code&gt;MODE&lt;/code&gt; ）参数设置为指示输入管道或输出管道的特殊字符。使用 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; 表示允许您的Perl程序从外部程序读取数据的文件句柄， &lt;code&gt;&quot;|-&quot;&lt;/code&gt; 表示将向该程序发送数据的文件句柄。</target>
        </trans-unit>
        <trans-unit id="a44ff5fd296684850a7eea8453ca8654e5ea2769" translate="yes" xml:space="preserve">
          <source>As system libraries (most notably glibc) are also triggering errors, valgrind allows to suppress such errors using suppression files. The default suppression file that comes with valgrind already catches a lot of them. Some additional suppressions are defined in</source>
          <target state="translated">由于系统库(最主要的是glibc)也会触发错误,valgrind允许使用抑制文件来抑制这些错误。valgrind默认的抑制文件已经捕捉到了很多错误。一些额外的抑制文件被定义在</target>
        </trans-unit>
        <trans-unit id="e1a99808d733ec0659b941748add22eaba940233" translate="yes" xml:space="preserve">
          <source>As that is multiple C statements it is quite common so see this idiom instead:</source>
          <target state="translated">因为那是多条C语句,很常见,所以请看这个成语代替。</target>
        </trans-unit>
        <trans-unit id="ac882702a8c758004edc0489caa0c38829169f81" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;'IGNORE'&lt;/code&gt; hook is not supported by &lt;code&gt;__WARN__&lt;/code&gt; , you can disable warnings using the empty subroutine:</source>
          <target state="translated">由于 &lt;code&gt;__WARN__&lt;/code&gt; 不支持 &lt;code&gt;'IGNORE'&lt;/code&gt; 挂钩，因此可以使用空子例程禁用警告：</target>
        </trans-unit>
        <trans-unit id="d759f2151ab12005046fd0fb7fc374d93cc7fcaa" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;'IGNORE'&lt;/code&gt; hook is not supported by &lt;code&gt;__WARN__&lt;/code&gt;, its effect is the same as using &lt;code&gt;'DEFAULT'&lt;/code&gt;. You can disable warnings using the empty subroutine:</source>
          <target state="translated">由于 &lt;code&gt;__WARN__&lt;/code&gt; 不支持 &lt;code&gt;'IGNORE'&lt;/code&gt; 挂钩，因此其效果与使用 &lt;code&gt;'DEFAULT'&lt;/code&gt; 相同。您可以使用空子例程禁用警告：</target>
        </trans-unit>
        <trans-unit id="481d1ba67f45c383e883a88846da2edc2a1775aa" translate="yes" xml:space="preserve">
          <source>As the Perl interpreter looks at signal flags only when it is about to execute a new opcode, a signal that arrives during a long-running opcode (e.g. a regular expression operation on a very large string) will not be seen until the current opcode completes.</source>
          <target state="translated">由于Perl解释器只有在即将执行一个新的操作码时才会查看信号标志,所以在一个长期运行的操作码期间(例如对一个很大的字符串进行正则表达式操作)到达的信号将在当前操作码完成之前不会被看到。</target>
        </trans-unit>
        <trans-unit id="f849d9355eec2f51b5cef2814ee106c18c309122" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO (bytes) internally, all this totally ignores things like the type of your filesystem (ASCII or EBCDIC).</source>
          <target state="translated">由于PerlIO层内部使用的是原始IO(字节),所有这些完全忽略了诸如你的文件系统类型(ASCII或EBCDIC)。</target>
        </trans-unit>
        <trans-unit id="ef5f3ccf5711fff6ab130d18e6106225adf61f56" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO internally, all this totally ignores the type of your filesystem (ASCII or EBCDIC) and the IO_CONVERSION environment variable. If you want to get the old behavior, that the BS2000 IO functions determine conversion depending on the filesystem PerlIO still is your friend. You use IO_CONVERSION as usual and tell Perl, that it should use the native IO layer:</source>
          <target state="translated">由于PerlIO层在内部使用原始IO,所有这些都完全忽略了你的文件系统的类型(ASCII或EBCDIC)和IO_CONVERSION环境变量。如果你想获得旧的行为,即BS2000 IO函数根据文件系统决定转换,PerlIO仍然是你的朋友。你可以像往常一样使用IO_CONVERSION,并告诉Perl,它应该使用本地IO层。</target>
        </trans-unit>
        <trans-unit id="20b8fc20101f3d438a32270dc2621c0dd14971b3" translate="yes" xml:space="preserve">
          <source>As the comment says, this is not a good way to implement accessors. It's slow and too clever by far. However, you may see this as a way to provide accessors in older Perl code. See &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for recommendations on OO coding in Perl.</source>
          <target state="translated">正如评论所言，这不是实现访问器的好方法。到目前为止，它很慢而且太聪明了。但是，您可能会将此视为以较旧的Perl代码提供访问器的方法。有关Perl中OO编码的建议，请参见&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1139ca2064130f83bd2fbbeaae8eb84583cc89ac" translate="yes" xml:space="preserve">
          <source>As the example in &lt;a href=&quot;#new%28%29&quot;&gt;&quot;new()&quot;&lt;/a&gt; shows, you can always create a copy of an existing version object with the same value by the very compact:</source>
          <target state="translated">如&lt;a href=&quot;#new%28%29&quot;&gt;&amp;ldquo; new（）&amp;rdquo;&lt;/a&gt;中的示例所示，您总是可以非常紧凑地创建具有相同值的现有版本对象的副本：</target>
        </trans-unit>
        <trans-unit id="4fca5f01eab824b22bb6b1905a8d483f37ad2ed6" translate="yes" xml:space="preserve">
          <source>As the example shows, if the second argument is an empty string, the category's locale is returned to the default specified by the corresponding environment variables. Generally, this results in a return to the default that was in force when Perl started up: changes to the environment made by the application after startup may or may not be noticed, depending on your system's C library.</source>
          <target state="translated">如本例所示,如果第二个参数是一个空字符串,那么类别的locale将返回到相应环境变量所指定的默认值。一般来说,这样做的结果是返回到Perl启动时有效的默认值:应用程序在启动后对环境的改变可能会被注意到,也可能不会被注意到,这取决于你系统的C库。</target>
        </trans-unit>
        <trans-unit id="1edaf8c27fdae81166329d8ebc45bdc56d4e0e72" translate="yes" xml:space="preserve">
          <source>As the final two examples above show, you can achieve portability to non-ASCII platforms by using the &lt;code&gt;\N{...}&lt;/code&gt; form for the range endpoints. These indicate that the specified range is to be interpreted using Unicode values, so &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; means to match &lt;code&gt;\N{U+27}&lt;/code&gt;, &lt;code&gt;\N{U+28}&lt;/code&gt;, &lt;code&gt;\N{U+29}&lt;/code&gt;, ..., &lt;code&gt;\N{U+3D}&lt;/code&gt;, &lt;code&gt;\N{U+3E}&lt;/code&gt;, and &lt;code&gt;\N{U+3F}&lt;/code&gt;, whatever the native code point versions for those are. These are called &quot;Unicode&quot; ranges. If either end is of the &lt;code&gt;\N{...}&lt;/code&gt; form, the range is considered Unicode. A &lt;code&gt;regexp&lt;/code&gt; warning is raised under &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; if the other endpoint is specified non-portably:</source>
          <target state="translated">如上面的最后两个示例所示，您可以通过将 &lt;code&gt;\N{...}&lt;/code&gt; 形式用于范围端点来实现对非ASCII平台的可移植性。这些指示将使用Unicode值解释指定范围，因此 &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; 表示要匹配 &lt;code&gt;\N{U+27}&lt;/code&gt; ， &lt;code&gt;\N{U+28}&lt;/code&gt; ， &lt;code&gt;\N{U+29}&lt;/code&gt; ，...， &lt;code&gt;\N{U+3D}&lt;/code&gt; ， &lt;code&gt;\N{U+3E}&lt;/code&gt; 和 &lt;code&gt;\N{U+3F}&lt;/code&gt; ，无论这些版本的本机代码点是什么。这些称为&amp;ldquo; Unicode&amp;rdquo;范围。如果任一端的格式为 &lt;code&gt;\N{...}&lt;/code&gt; ，则该范围被视为Unicode。一个 &lt;code&gt;regexp&lt;/code&gt; 警告下提出的 &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; 如果非便携式地指定了另一个端点：</target>
        </trans-unit>
        <trans-unit id="0a3da7dd18a3b2da7c7f36441b50e2eab858828a" translate="yes" xml:space="preserve">
          <source>As the final two examples above show, you can achieve portablity to non-ASCII platforms by using the &lt;code&gt;\N{...}&lt;/code&gt; form for the range endpoints. These indicate that the specified range is to be interpreted using Unicode values, so &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; means to match &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; , and &lt;code&gt;\N{U+3F}&lt;/code&gt; , whatever the native code point versions for those are. These are called &quot;Unicode&quot; ranges. If either end is of the &lt;code&gt;\N{...}&lt;/code&gt; form, the range is considered Unicode. A &lt;code&gt;regexp&lt;/code&gt; warning is raised under &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; if the other endpoint is specified non-portably:</source>
          <target state="translated">如上面的最后两个示例所示，您可以通过使用 &lt;code&gt;\N{...}&lt;/code&gt; 形式的范围端点来实现对非ASCII平台的可移植性。这些指示将使用Unicode值解释指定范围，因此 &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; 表示要匹配 &lt;code&gt;\N{U+27}&lt;/code&gt; ， &lt;code&gt;\N{U+28}&lt;/code&gt; ， &lt;code&gt;\N{U+29}&lt;/code&gt; ，...， &lt;code&gt;\N{U+3D}&lt;/code&gt; ， &lt;code&gt;\N{U+3E}&lt;/code&gt; 和 &lt;code&gt;\N{U+3F}&lt;/code&gt; ，无论它们的本机代码点版本如何。这些称为&amp;ldquo; Unicode&amp;rdquo;范围。如果两端采用 &lt;code&gt;\N{...}&lt;/code&gt; 格式，则该范围被视为Unicode。一个 &lt;code&gt;regexp&lt;/code&gt; 警告下提出的 &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; 如果非便携式地指定了另一个端点：</target>
        </trans-unit>
        <trans-unit id="17c70cf277254845a8ce88c971a047564a105d87" translate="yes" xml:space="preserve">
          <source>As the last character of a prototype, or just before a semicolon, a &lt;code&gt;@&lt;/code&gt; or a &lt;code&gt;%&lt;/code&gt; , you can use &lt;code&gt;_&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt; : if this argument is not provided, &lt;code&gt;$_&lt;/code&gt; will be used instead.</source>
          <target state="translated">作为原型的最后一个字符，或者在分号前 &lt;code&gt;@&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; 之前，可以使用 &lt;code&gt;_&lt;/code&gt; 代替 &lt;code&gt;$&lt;/code&gt; ：如果未提供此参数，则将使用 &lt;code&gt;$_&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="9cd30084251e957fbd55793c63ff1e2e0b66c3d5" translate="yes" xml:space="preserve">
          <source>As the last character of a prototype, or just before a semicolon, a &lt;code&gt;@&lt;/code&gt; or a &lt;code&gt;%&lt;/code&gt;, you can use &lt;code&gt;_&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt;: if this argument is not provided, &lt;code&gt;$_&lt;/code&gt; will be used instead.</source>
          <target state="translated">作为原型的最后一个字符，或者在分号前 &lt;code&gt;@&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; 之前，可以使用 &lt;code&gt;_&lt;/code&gt; 代替 &lt;code&gt;$&lt;/code&gt; ：如果未提供此参数，则将使用 &lt;code&gt;$_&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="4b123b1845e08fc58170e4c4c4ab5952b56ae816" translate="yes" xml:space="preserve">
          <source>As the last example indicates, a handler may be set up to be (re)called in two or more phases. The phase name is passed as the handler's final argument.</source>
          <target state="translated">如上一个例子所示,一个处理程序可以被设置为在两个或多个阶段中被(重新)调用。阶段名称作为处理程序的最后参数被传递。</target>
        </trans-unit>
        <trans-unit id="776d16ae4f440b015655f81050641c0ec6c3a0f2" translate="yes" xml:space="preserve">
          <source>As the parser reads the second and subsequent lines from the source stream, it feeds those lines through the &lt;code&gt;cpp&lt;/code&gt; source filter before processing them. The &lt;code&gt;cpp&lt;/code&gt; filter simply passes each line through the real C preprocessor. The output from the C preprocessor is then inserted back into the source stream by the filter.</source>
          <target state="translated">解析器从源流中读取第二行和后续行时，将在处理它们之前将这些行馈送通过 &lt;code&gt;cpp&lt;/code&gt; 源过滤器。该 &lt;code&gt;cpp&lt;/code&gt; 滤波器简单地通过实际C预处理器的每一行。然后，C预处理器的输出由过滤器插入回到源流中。</target>
        </trans-unit>
        <trans-unit id="de16f72d9bd04b071a155fd420870c413322270a" translate="yes" xml:space="preserve">
          <source>As the parser sees sections like:</source>
          <target state="translated">由于解析器看到这样的部分。</target>
        </trans-unit>
        <trans-unit id="b29477c3662cd388380e5f2f7edde392d4aa47d3" translate="yes" xml:space="preserve">
          <source>As the parser understands a Perl program, it builds up a tree of operations for the interpreter to perform during execution. The routines which construct and link together the various operations are to be found in</source>
          <target state="translated">当解析器理解一个Perl程序时,它建立了一个操作树,供解释器在执行过程中执行。构建和连接各种操作的例程可以在</target>
        </trans-unit>
        <trans-unit id="720247a05069501ddebd25eded634ebdeed59cfd" translate="yes" xml:space="preserve">
          <source>As the sorting is done in the JSON::PP scope, you usually need to prepend &lt;code&gt;JSON::PP::&lt;/code&gt; to the subroutine name, and the special variables &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; used in the subrontine used by &lt;code&gt;sort&lt;/code&gt; function.</source>
          <target state="translated">由于排序是在JSON :: PP范围内完成的，因此通常需要在子例程名称前加上 &lt;code&gt;JSON::PP::&lt;/code&gt; ，并在 &lt;code&gt;sort&lt;/code&gt; 函数使用的子子例程中使用特殊变量 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="059620d29d96cd6f5eb8cd327a9137c1f47169b5" translate="yes" xml:space="preserve">
          <source>As there are various Make programs with incompatible syntax, which use operating system shells, again with incompatible syntax, it is important for users of this module to know which flavour of Make a Makefile has been written for so they'll use the correct one and won't have to face the possibly bewildering errors resulting from using the wrong one.</source>
          <target state="translated">由于有各种语法不兼容的Make程序,这些程序使用的是操作系统的shell,同样也是语法不兼容,因此,对于本模块的用户来说,知道一个Makefile是为哪种味道而写的是很重要的,这样他们就会使用正确的Makefile,而不用面对因为使用错误的Makefile而可能产生的令人困惑的错误。</target>
        </trans-unit>
        <trans-unit id="036fd1e2507560ce47135587c83032ff17f1287e" translate="yes" xml:space="preserve">
          <source>As there is an overlap between the error numbers used by</source>
          <target state="translated">因为在使用的错误数字之间有重叠。</target>
        </trans-unit>
        <trans-unit id="267c472340bc23541eca7afc953c80b9af09e6af" translate="yes" xml:space="preserve">
          <source>As this callback gets called less often then the &lt;code&gt;filter_json_object&lt;/code&gt; one, decoding speed will not usually suffer as much. Therefore, single-key objects make excellent targets to serialise Perl objects into, especially as single-key JSON objects are as close to the type-tagged value concept as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not support this in any way, so you need to make sure your data never looks like a serialised Perl hash.</source>
          <target state="translated">由于此回调的调用频率比 &lt;code&gt;filter_json_object&lt;/code&gt; 调用的调用频率低，因此解码速度通常不会受到太大影响。因此，单键对象是将Perl对象序列化的极佳目标，尤其是当单键JSON对象与JSON获得的类型标记值概念非常接近时（基本上是ID / VALUE元组）。当然，JSON完全不支持此功能，因此您需要确保数据永远不会像序列化的Perl哈希那样。</target>
        </trans-unit>
        <trans-unit id="4ae4c3659f41e6ea72787219e7dd135169795201" translate="yes" xml:space="preserve">
          <source>As to how you'd implement the Russian example from the beginning of the article, well, There's More Than One Way To Do It, but it could be something like this (using English words for Russian, just so you know what's going on):</source>
          <target state="translated">至于你如何实现文章开头的俄语例子,好吧,There's More Than One Way To Do It,但它可以是这样的(用英语单词表示俄语,只是让你知道是怎么回事)。</target>
        </trans-unit>
        <trans-unit id="7c1931b1f7f35afcd5d7f66942f927b9ab23c40a" translate="yes" xml:space="preserve">
          <source>As to sharing of auxiliary functions, consider the problem of Russian numbers from the beginning of this article; obviously, you'd want to write only once the hairy code that, given a numeric value, would return some specification of which case and number a given quantified noun should use. But suppose that you discover, while localizing an interface for, say, Ukranian (a Slavic language related to Russian, spoken by several million people, many of whom would be relieved to find that your Web site's or software's interface is available in their language), that the rules in Ukranian are the same as in Russian for quantification, and probably for many other grammatical functions. While there may well be no phrases in common between Russian and Ukranian, you could still choose to have the Ukranian module inherit from the Russian module, just for the sake of inheriting all the various grammatical methods. Or, probably better organizationally, you could move those functions to a module called &lt;code&gt;_E_Slavic&lt;/code&gt; or something, which Russian and Ukrainian could inherit useful functions from, but which would (presumably) provide no lexicon.</source>
          <target state="translated">关于辅助功能的共享，请从本文开始就考虑俄语数字的问题。显然，您只想编写一次给定数值的多毛代码，该代码将返回给定量化名词应使用的大小写和数字的说明。但是，假设您在本地化乌克兰语（与俄语有关的斯拉夫语，数百万人说过，其中许多人会发现您的网站或软件的界面可以用他们的语言使用）时就发现了该界面， ，乌克兰语中的量化规则与俄语中的规则相同，并且可能还有许多其他语法功能。尽管俄语和乌克兰语之间可能没有共同的短语，但您仍然可以选择让乌克兰语模块继承于俄语模块，只是为了继承所有各种语法方法。或者，在组织上可能更好，您可以将这些功能移至名为 &lt;code&gt;_E_Slavic&lt;/code&gt; 之类的东西，俄语和乌克兰语可以从中继承有用的功能，但是（大概）不会提供任何词典。</target>
        </trans-unit>
        <trans-unit id="c2c40011ac031fbcf62ae0096c0f70fe3f04f6d4" translate="yes" xml:space="preserve">
          <source>As told above, Perl 5.6.1 was still good in AmigaOS, as was 5.7.2. After Perl 5.7.2 (change #11423, see the Changes file, and the file pod/perlhack.pod for how to get the individual changes) Perl dropped its internal support for vfork(), and that was very probably the step that broke AmigaOS (since the ixemul library has only vfork). The build finally fails when the ext/DynaLoader is being built, and PERL ends up as &quot;0&quot; in the produced Makefile, trying to run &quot;0&quot; does not quite work. Also, executing miniperl in backticks seems to generate nothing: very probably related to the (v)fork problems. &lt;b&gt;Fixing the breakage requires someone quite familiar with the ixemul library, and how one is supposed to run external commands in AmigaOS without fork().&lt;/b&gt;</source>
          <target state="translated">如上所述，Perl 5.6.1在AmigaOS中仍然不错，在5.7.2中也是如此。在Perl 5.7.2（更改为＃11423，请参阅&amp;ldquo;更改&amp;rdquo;文件，以及文件pod / perlhack.pod以获取有关如何进行单个更改）之后，Perl放弃了对vfork（）的内部支持，这很可能是打破了这一步AmigaOS（因为ixemul库只有vfork）。当构建ext / DynaLoader时，构建最终失败，并且PERL在生成的Makefile中最终显示为&amp;ldquo; 0&amp;rdquo;，试图运行&amp;ldquo; 0&amp;rdquo;并不太起作用。同样，在反引号中执行miniperl似乎什么也不会产生：很可能与（v）fork问题有关。&lt;b&gt;修复损坏需要熟悉ixemul库的人员，以及如何在不使用fork（）的情况下在AmigaOS中运行外部命令。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7df201bc839d821d3a7ec829e521380838b10cef" translate="yes" xml:space="preserve">
          <source>As usual, &lt;code&gt;PL_restartop&lt;/code&gt; is extracted from the &lt;code&gt;CxEVAL&lt;/code&gt; , and a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; done, which pops the C stack back to the docatch:</source>
          <target state="translated">像往常一样，从 &lt;code&gt;PL_restartop&lt;/code&gt; 中提取 &lt;code&gt;CxEVAL&lt;/code&gt; ，并完成 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; ，这会将C堆栈弹出回docatch：</target>
        </trans-unit>
        <trans-unit id="2a573f9f62b976f78c5ac59164a50ae13a402046" translate="yes" xml:space="preserve">
          <source>As usual, &lt;code&gt;PL_restartop&lt;/code&gt; is extracted from the &lt;code&gt;CxEVAL&lt;/code&gt;, and a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; done, which pops the C stack back to the docatch:</source>
          <target state="translated">像往常一样，从 &lt;code&gt;PL_restartop&lt;/code&gt; 中提取 &lt;code&gt;CxEVAL&lt;/code&gt; ，并完成 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; ，这会将C堆栈弹出回docatch：</target>
        </trans-unit>
        <trans-unit id="43f8dfff8ebd277fcb05688b6c5164a9ecb709ab" translate="yes" xml:space="preserve">
          <source>As usual, run</source>
          <target state="translated">像往常一样,运行</target>
        </trans-unit>
        <trans-unit id="6a12281792622fa54248b5b0512161ae986d73ec" translate="yes" xml:space="preserve">
          <source>As we have seen above, Principle 0 overrides the others. The regexp will be matched as early as possible, with the other principles determining how the regexp matches at that earliest character position.</source>
          <target state="translated">正如我们在上面看到的,原则0优先于其他原则。regexp将尽可能早地被匹配,其他原则决定了regexp在该最早字符位置的匹配方式。</target>
        </trans-unit>
        <trans-unit id="f24d0557480129d0bec98f1d07b3bc35225e11b2" translate="yes" xml:space="preserve">
          <source>As we mentioned before, Perl's built-in OO system is very minimal, but also quite flexible. Over the years, many people have developed systems which build on top of Perl's built-in system to provide more features and convenience.</source>
          <target state="translated">正如我们之前提到的,Perl的内置OO系统非常简陋,但也相当灵活。多年来,很多人开发的系统都是建立在Perl内置系统的基础上,提供更多的功能和便利。</target>
        </trans-unit>
        <trans-unit id="4f2e51cb7fb14eb8f1de406668bded94aec1752e" translate="yes" xml:space="preserve">
          <source>As we mentioned before, roles provide an alternative to inheritance, but Perl does not have any built-in role support. If you choose to use Moose, it comes with a full-fledged role implementation. However, if you use one of our other recommended OO modules, you can still use roles with &lt;a href=&quot;Role::Tiny&quot;&gt;Role::Tiny&lt;/a&gt;</source>
          <target state="translated">如前所述，角色提供了继承的替代方法，但是Perl没有任何内置的角色支持。如果您选择使用Moose，它将附带完整的角色实现。但是，如果您使用我们建议的其他其他OO模块之一，则仍可以将角色与&lt;a href=&quot;Role::Tiny&quot;&gt;Role :: Tiny一起使用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09f78df2a986a05b74a05b4840bd77f0745f303d" translate="yes" xml:space="preserve">
          <source>As we mentioned before, roles provide an alternative to inheritance, but Perl does not have any built-in role support. If you choose to use Moose, it comes with a full-fledged role implementation. However, if you use one of our other recommended OO modules, you can still use roles with &lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role::Tiny&lt;/a&gt;</source>
          <target state="translated">如前所述，角色提供了继承的替代方法，但是Perl没有任何内置的角色支持。如果您选择使用Moose，则它带有完整的角色实现。但是，如果您使用我们推荐的其他其他OO模块之一，则仍可以将角色与&lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role :: Tiny一起使用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f8a13dd0293aebd2b1466f31d349be90b2e062e" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, Perl provides no special constructor syntax. This means that a class must implement its own constructor. A constructor is simply a class method that returns a reference to a new object.</source>
          <target state="translated">正如我们前面提到的,Perl没有提供特殊的构造函数语法。这意味着一个类必须实现自己的构造函数。构造函数只是一个返回新对象引用的类方法。</target>
        </trans-unit>
        <trans-unit id="34cb600e9a3f6e5e075e857de4110b1ef2b3324a" translate="yes" xml:space="preserve">
          <source>As we return an empty list, everything is fine.</source>
          <target state="translated">由于我们返回的是一个空列表,所以一切正常。</target>
        </trans-unit>
        <trans-unit id="1bc0081962e83c9753eb5550755ad42af088433e" translate="yes" xml:space="preserve">
          <source>As we said before, Perl's minimal OO system has led to a profusion of OO systems on CPAN. While you can still drop down to the bare metal and write your classes by hand, there's really no reason to do that with modern Perl.</source>
          <target state="translated">正如我们之前所说,Perl的最小OO系统导致了CPAN上OO系统的泛滥。虽然你仍然可以降到最底层,用手写你的类,但对于现代Perl来说,真的没有理由这么做。</target>
        </trans-unit>
        <trans-unit id="7867c988c2c06b2c05fdddd86e23a3f47b3a2862" translate="yes" xml:space="preserve">
          <source>As we said earlier, most Perl objects are hashes, but an object can be an instance of any Perl data type (scalar, array, etc.). Turning a plain data structure into an object is done by &lt;b&gt;blessing&lt;/b&gt; that data structure using Perl's &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">如前所述，大多数Perl对象都是散列，但是对象可以是任何Perl数据类型（标量，数组等）的实例。通过使用Perl的 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 函数&lt;b&gt;祝福&lt;/b&gt;该数据结构，可以将一个普通的数据结构变成一个对象。</target>
        </trans-unit>
        <trans-unit id="4b99a5371cd1d193aeb40f1c8ec4bf090e8b2c97" translate="yes" xml:space="preserve">
          <source>As we said earlier, most Perl objects are hashes, but an object can be an instance of any Perl data type (scalar, array, etc.). Turning a plain data structure into an object is done by &lt;b&gt;blessing&lt;/b&gt; that data structure using Perl's &lt;code&gt;bless&lt;/code&gt; function.</source>
          <target state="translated">如前所述，大多数Perl对象都是散列，但是对象可以是任何Perl数据类型（标量，数组等）的实例。通过使用Perl的 &lt;code&gt;bless&lt;/code&gt; 函数&lt;b&gt;祝福&lt;/b&gt;该数据结构，可以将一个普通的数据结构变成一个对象。</target>
        </trans-unit>
        <trans-unit id="504d4df94aa612d7624624e4944523fc3497d648" translate="yes" xml:space="preserve">
          <source>As we saw earlier, an object is simply a data structure that has been blessed into a class via the &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function can take either one or two arguments:</source>
          <target state="translated">如前所述，对象只是通过 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 函数被祝福为类的数据结构。该 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 函数可以接受一个或两个参数：</target>
        </trans-unit>
        <trans-unit id="86afd7b293cb09c0f55f2b3f4442d25492c71a40" translate="yes" xml:space="preserve">
          <source>As we saw earlier, an object is simply a data structure that has been blessed into a class via the &lt;code&gt;bless&lt;/code&gt; function. The &lt;code&gt;bless&lt;/code&gt; function can take either one or two arguments:</source>
          <target state="translated">正如我们前面所看到的，对象只是一个通过 &lt;code&gt;bless&lt;/code&gt; 函数被祝福到一个类中的数据结构。该 &lt;code&gt;bless&lt;/code&gt; 函数可以接受一个或两个参数：</target>
        </trans-unit>
        <trans-unit id="a1d3a4a5afeb3f9e63b11e0b6c656dbcfa8f18b8" translate="yes" xml:space="preserve">
          <source>As we've already shown, &lt;code&gt;call_sv&lt;/code&gt; can be used to invoke an anonymous subroutine. However, our example showed a Perl script invoking an XSUB to perform this operation. Let's see how it can be done inside our C code:</source>
          <target state="translated">正如我们已经展示的， &lt;code&gt;call_sv&lt;/code&gt; 可用于调用匿名子例程。但是，我们的示例显示了Perl脚本调用XSUB来执行此操作。让我们看看如何在我们的C代码中完成它：</target>
        </trans-unit>
        <trans-unit id="96d58f32e93788e5dbef34c03d0df80dbd089dab" translate="yes" xml:space="preserve">
          <source>As well as accessing Berkeley DB using a tied hash or array, it is also possible to make direct use of most of the API functions defined in the Berkeley DB documentation.</source>
          <target state="translated">除了使用绑定的哈希或数组访问Berkeley DB外,还可以直接使用Berkeley DB文档中定义的大部分API函数。</target>
        </trans-unit>
        <trans-unit id="0237593efedf8b6eff88bac44019384e6b74f34f" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the array (like &lt;code&gt;av_clear()&lt;/code&gt;), this also frees the memory used by the av to store its list of scalars.</source>
          <target state="translated">除了释放数组的所有元素（如 &lt;code&gt;av_clear()&lt;/code&gt; ）之外，这还释放了av用于存储其标量列表的内存。</target>
        </trans-unit>
        <trans-unit id="9a89b3b004de95ce93de721c0f8e3cdeec13f545" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the hash (like &lt;code&gt;hv_clear()&lt;/code&gt;), this also frees any auxiliary data and storage associated with the hash.</source>
          <target state="translated">除了释放散列的所有元素（如 &lt;code&gt;hv_clear()&lt;/code&gt; ）之外，这还释放了与散列关联的所有辅助数据和存储。</target>
        </trans-unit>
        <trans-unit id="749b97b56149a492eb18a4cb65f04d306a596132" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the hash (like hv_clear()), this also frees any auxiliary data and storage associated with the hash.</source>
          <target state="translated">除了释放哈希的所有元素(像 hv_clear()一样),这也释放了与哈希相关的任何辅助数据和存储。</target>
        </trans-unit>
        <trans-unit id="2e0710bbe12c8de0ee3e47fce586245cf49652f2" translate="yes" xml:space="preserve">
          <source>As well as grouping, parentheses serve a second purpose. They can be used to capture the results of parts of the regexp match for later use. The results end up in &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; and so on.</source>
          <target state="translated">除了分组外，括号还有第二个目的。它们可用于捕获regexp匹配的部分结果以供以后使用。结果以 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等结束。</target>
        </trans-unit>
        <trans-unit id="3a1788b97e5572fb886ee20a2620cc1ef5c829d9" translate="yes" xml:space="preserve">
          <source>As well as grouping, parentheses serve a second purpose. They can be used to capture the results of parts of the regexp match for later use. The results end up in &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; and so on.</source>
          <target state="translated">除了分组外，括号还有第二个目的。它们可用于捕获regexp匹配的部分结果以供以后使用。结果以 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等结束。</target>
        </trans-unit>
        <trans-unit id="998a4f37f47dfa1a21fcb95591647fa7596884ba" translate="yes" xml:space="preserve">
          <source>As well as the following methods, this class inherits all the methods in &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt; and &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">与以下方法一样，此类继承&lt;a href=&quot;IO::Socket&quot;&gt;IO :: Socket&lt;/a&gt;和&lt;a href=&quot;IO::Handle&quot;&gt;IO :: Handle中的&lt;/a&gt;所有方法。</target>
        </trans-unit>
        <trans-unit id="7365f5053276b5ccb78d102d8d65d8a7cbb5a47c" translate="yes" xml:space="preserve">
          <source>As well as these two, there is another converter:</source>
          <target state="translated">除了这两个之外,还有一个转换器。</target>
        </trans-unit>
        <trans-unit id="79309f713ddbfafe2f6334a91eabf7f9425eca6b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#exit-EXPR&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; is set prior to unwinding the call stack; any &lt;code&gt;DESTROY&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; handlers can then alter this value, and thus Perl's exit code.</source>
          <target state="translated">与&lt;a href=&quot;#exit-EXPR&quot;&gt; &lt;code&gt;exit&lt;/code&gt; 一样&lt;/a&gt;，&lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; &lt;/a&gt;在展开调用堆栈之前设置；然后，任何 &lt;code&gt;DESTROY&lt;/code&gt; 或 &lt;code&gt;END&lt;/code&gt; 处理程序都可以更改此值，从而更改Perl的退出代码。</target>
        </trans-unit>
        <trans-unit id="5f09c013a494b22fb2c5704b9b33f8690cdb78ae" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairfirst&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 为列表元素别名 &lt;code&gt;$_&lt;/code&gt; ， &lt;code&gt;pairfirst&lt;/code&gt; 为给定列表元素别名 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 。代码块对其的任何修改对调用者都是可见的。</target>
        </trans-unit>
        <trans-unit id="6ccb264713980d688f5b35e3f78e5d8bcc1b34f2" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairgrep&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 为列表元素别名 &lt;code&gt;$_&lt;/code&gt; ， &lt;code&gt;pairgrep&lt;/code&gt; 为给定列表元素别名 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 。代码块对其的任何修改对调用者都是可见的。</target>
        </trans-unit>
        <trans-unit id="0e0ea04c8e6030abec75f8b13970784d2a0b7c8f" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairmap&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">正如 &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 别名 &lt;code&gt;$_&lt;/code&gt; 到列表中的元素， &lt;code&gt;pairmap&lt;/code&gt; 别名 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 给定列表的元素。代码块对其的任何修改对调用者都是可见的。</target>
        </trans-unit>
        <trans-unit id="fec85543ad9986bf912be9475be1ac989c167db7" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;PERL5OPT&lt;/code&gt;, a string of additional &lt;code&gt;cpan(1)&lt;/code&gt; options to add to those you specify on the command line.</source>
          <target state="translated">与 &lt;code&gt;PERL5OPT&lt;/code&gt; 一样，一串附加的 &lt;code&gt;cpan(1)&lt;/code&gt; 选项可添加到您在命令行上指定的选项。</target>
        </trans-unit>
        <trans-unit id="cc99e7ad503065bd82f24f799275058edae300da" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;grep&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairfirst&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">与 &lt;code&gt;grep&lt;/code&gt; 为列表元素别名 &lt;code&gt;$_&lt;/code&gt; ， &lt;code&gt;pairfirst&lt;/code&gt; 为给定列表元素别名 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 。代码块对它的任何修改对调用者都是可见的。</target>
        </trans-unit>
        <trans-unit id="4d482c5453c9dc11a8d1e3e4a1d4df1955e90671" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;grep&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairgrep&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">与 &lt;code&gt;grep&lt;/code&gt; 为列表元素别名 &lt;code&gt;$_&lt;/code&gt; ， &lt;code&gt;pairgrep&lt;/code&gt; 为给定列表元素别名 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 。代码块对它的任何修改对调用者都是可见的。</target>
        </trans-unit>
        <trans-unit id="852273f60001fb5cfcfc3f59c366b8a418d217ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;gzerror()&lt;/code&gt; it returns an error number in numeric context and an error message in string context. Unlike &lt;code&gt;gzerror()&lt;/code&gt; though, the error message will correspond to the</source>
          <target state="translated">与 &lt;code&gt;gzerror()&lt;/code&gt; 一样,它在数字上下文中返回错误号，在字符串上下文中返回错误消息。但是与 &lt;code&gt;gzerror()&lt;/code&gt; 不同，错误消息将与</target>
        </trans-unit>
        <trans-unit id="ad8ddc963c1faca12f5a1122723298a5bb8081cc" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;map&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairmap&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">正如 &lt;code&gt;map&lt;/code&gt; 别名 &lt;code&gt;$_&lt;/code&gt; 到列表中的元素， &lt;code&gt;pairmap&lt;/code&gt; 别名 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 给定列表的元素。代码块对它的任何修改对调用者都是可见的。</target>
        </trans-unit>
        <trans-unit id="89fce7a719c0828fb9010451c52ebed3b12f2d8d" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;mro::get_linear_isa&lt;/code&gt; above, &lt;code&gt;UNIVERSAL&lt;/code&gt; is special. &lt;code&gt;UNIVERSAL&lt;/code&gt; (and parents') isarev lists do not include every class in existence, even though all classes are effectively descendants for method inheritance purposes.</source>
          <target state="translated">与上面的 &lt;code&gt;mro::get_linear_isa&lt;/code&gt; ， &lt;code&gt;UNIVERSAL&lt;/code&gt; 也很特殊。即使所有类都是有效地继承方法的子类， &lt;code&gt;UNIVERSAL&lt;/code&gt; （和父母的）isarev列表也不包括每个存在的类。</target>
        </trans-unit>
        <trans-unit id="32eae94f86fad4a1553a0eb1f5e32221b0ef149f" translate="yes" xml:space="preserve">
          <source>As with CORE::utime(), passing undef as both the atime and mtime will call the syscall with a NULL argument.</source>
          <target state="translated">与CORE::utime()一样,将 undef 作为 atime 和 mtime 传递给系统调用时,将以 NULL 参数调用。</target>
        </trans-unit>
        <trans-unit id="1bfc8628cde1b50356023884cf039103db9706d2" translate="yes" xml:space="preserve">
          <source>As with G_SCALAR, this flag has 2 effects:</source>
          <target state="translated">和G_SCALAR一样,这个标志有2个效果。</target>
        </trans-unit>
        <trans-unit id="56fcac1f27b0d72bf38ecab8e2bf923c1135ad6d" translate="yes" xml:space="preserve">
          <source>As with GetOptionsFromArray, a first argument hash reference now becomes the second argument.</source>
          <target state="translated">与GetOptionsFromArray一样,第一个参数哈希引用现在变成了第二个参数。</target>
        </trans-unit>
        <trans-unit id="f5b2adb567968a40150b99a2b38e37687da34625" translate="yes" xml:space="preserve">
          <source>As with all &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directives, defining a constant happens at compile time. Thus, it's probably not correct to put a constant declaration inside of a conditional statement (like &lt;code&gt;if ($foo)
{ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ).</source>
          <target state="translated">与所有 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 指令一样，定义常量发生在编译时。因此，将常量声明放在条件语句内可能是不正确的（例如 &lt;code&gt;if ($foo) { &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5354f6304cc90aca1a4c69a0041cb7b6c7daa540" translate="yes" xml:space="preserve">
          <source>As with all &lt;code&gt;use&lt;/code&gt; directives, defining a constant happens at compile time. Thus, it's probably not correct to put a constant declaration inside of a conditional statement (like &lt;code&gt;if ($foo) { use constant ... }&lt;/code&gt;).</source>
          <target state="translated">与所有 &lt;code&gt;use&lt;/code&gt; 指令一样，定义常量发生在编译时。因此，将常量声明放在条件语句中可能是不正确的（例如 &lt;code&gt;if ($foo) { use constant ... }&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a9e166bc9c2d17d86e12b7d5456a5dc29e6460a0" translate="yes" xml:space="preserve">
          <source>As with all compiler backend options, these must follow directly after the '-MO=Deparse', separated by a comma but not any white space.</source>
          <target state="translated">和所有编译器后台选项一样,这些选项必须直接跟在'-MO=Deparse'后面,用逗号隔开,但不能用空格。</target>
        </trans-unit>
        <trans-unit id="dec6818f5ac3b2a14f0cdaa20965c7cdeed80414" translate="yes" xml:space="preserve">
          <source>As with all standard commands, a single-character switch may be clustered with the following switch, if any.</source>
          <target state="translated">与所有的标准命令一样,如果有的话,单字符开关可以与下面的开关聚在一起。</target>
        </trans-unit>
        <trans-unit id="3f95467f687ea8e2cde45cd2aae56d762c10d52a" translate="yes" xml:space="preserve">
          <source>As with all things in Perl,</source>
          <target state="translated">和Perl中的所有东西一样。</target>
        </trans-unit>
        <trans-unit id="d4bf4ba0005710853f921b26431dc8a4fd4165e9" translate="yes" xml:space="preserve">
          <source>As with any advisory locking scheme, the protection only works if you systematically use &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_retrieve&lt;/code&gt; . If one side of your application uses &lt;code&gt;store&lt;/code&gt; whilst the other uses &lt;code&gt;lock_retrieve&lt;/code&gt; , you will get no protection at all.</source>
          <target state="translated">与任何咨询锁定方案一样，仅当您系统地使用 &lt;code&gt;lock_store&lt;/code&gt; 和 &lt;code&gt;lock_retrieve&lt;/code&gt; 时，该保护才起作用。如果您的应用程序的一侧使用 &lt;code&gt;store&lt;/code&gt; ,而另一侧使用 &lt;code&gt;lock_retrieve&lt;/code&gt; ，那么您将一无所获。</target>
        </trans-unit>
        <trans-unit id="cbbf76ef92d8f729f36aea391937508d71d89ba4" translate="yes" xml:space="preserve">
          <source>As with any advisory locking scheme, the protection only works if you systematically use &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_retrieve&lt;/code&gt;. If one side of your application uses &lt;code&gt;store&lt;/code&gt; whilst the other uses &lt;code&gt;lock_retrieve&lt;/code&gt;, you will get no protection at all.</source>
          <target state="translated">与任何咨询锁定方案一样，仅当您系统地使用 &lt;code&gt;lock_store&lt;/code&gt; 和 &lt;code&gt;lock_retrieve&lt;/code&gt; 时，该保护才起作用。如果您的应用程序的一侧使用 &lt;code&gt;store&lt;/code&gt; ,而另一侧使用 &lt;code&gt;lock_retrieve&lt;/code&gt; ，那么您将一无所获。</target>
        </trans-unit>
        <trans-unit id="dfdecc72a46325c982361e944a60a5cc48397fb3" translate="yes" xml:space="preserve">
          <source>As with constructors, Perl provides no special accessor declaration syntax, so classes must provide explicitly written accessor methods. There are two common types of accessors, read-only and read-write.</source>
          <target state="translated">与构造函数一样,Perl也没有提供特殊的访问器声明语法,所以类必须提供显式编写的访问器方法。有两种常见的访问器类型,只读和读写。</target>
        </trans-unit>
        <trans-unit id="5d06ccd4ce0505718d0adf18033c22a5ca1bc63e" translate="yes" xml:space="preserve">
          <source>As with many unix ports, this one depends on a few &quot;standard&quot; unix utilities which are not necessarily standard for QNX4.</source>
          <target state="translated">与许多 unix 端口一样,该端口依赖于一些 &quot;标准 &quot;unix 实用程序,但这些程序不一定是 QNX4 的标准程序。</target>
        </trans-unit>
        <trans-unit id="522d69b5bf4a752ac2eed134a3a3d90b973940bc" translate="yes" xml:space="preserve">
          <source>As with normal Perl arrays, a RECNO array can be accessed using negative indexes. The index -1 refers to the last element of the array, -2 the second last, and so on. Attempting to access an element before the start of the array will raise a fatal run-time error.</source>
          <target state="translated">与普通的Perl数组一样,RECNO数组可以使用负数索引来访问。索引-1指的是数组的最后一个元素,-2指的是第二个最后的元素,以此类推。如果试图在数组开始之前访问一个元素,会引发一个致命的运行时错误。</target>
        </trans-unit>
        <trans-unit id="4f5b532a80f5e05a1cc6284ddbfce49edaec9bba" translate="yes" xml:space="preserve">
          <source>As with postfix array, postfix value slice dereferencing</source>
          <target state="translated">与postfix数组一样,postfix值分片去参照。</target>
        </trans-unit>
        <trans-unit id="5f2a0ee0b6d450a60b564dbded3394cc767489a2" translate="yes" xml:space="preserve">
          <source>As with subroutines, the type of value returned from a thread's entry point function may be determined by the thread's</source>
          <target state="translated">与子程序一样,从线程的入口点函数返回的值的类型可以由线程的</target>
        </trans-unit>
        <trans-unit id="b1cab3e1a5ac11251ae5d77c854023eac88d9ffb" translate="yes" xml:space="preserve">
          <source>As with the</source>
          <target state="translated">如同在《公约》中一样。</target>
        </trans-unit>
        <trans-unit id="cd7300c50635cef829928b369e4af967b57015fd" translate="yes" xml:space="preserve">
          <source>As with the DB_HASH format, it is possible to provide a user defined Perl routine to perform the comparison of keys. By default, though, the keys are stored in lexical order.</source>
          <target state="translated">与DB_HASH格式一样,可以提供一个用户定义的Perl例程来执行键的比较。但默认情况下,键是按词法顺序存储的。</target>
        </trans-unit>
        <trans-unit id="69ca9bf5a86e0011eab25710aa599ffe7224ff94" translate="yes" xml:space="preserve">
          <source>As with the append mode, when you open a file in write-only mode, you can now write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与附加模式一样，当您以只写模式打开文件时，现在可以使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 之一写入该文件句柄。</target>
        </trans-unit>
        <trans-unit id="d97479933fa1462fae02a9e50ede26b28a53d5f2" translate="yes" xml:space="preserve">
          <source>As with the append mode, when you open a file in write-only mode, you can now write to that filehandle using any of &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;say&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;syswrite&lt;/code&gt;.</source>
          <target state="translated">与添加模式一样，当您以只写模式打开文件时，现在可以使用 &lt;code&gt;print&lt;/code&gt; ， &lt;code&gt;printf&lt;/code&gt; ， &lt;code&gt;say&lt;/code&gt; ， &lt;code&gt;write&lt;/code&gt; 或 &lt;code&gt;syswrite&lt;/code&gt; 之一写入该文件句柄。</target>
        </trans-unit>
        <trans-unit id="166455d62d96ee30d0f7c0e9ebb9b193aa0e9037" translate="yes" xml:space="preserve">
          <source>As with the built-in &lt;code&gt;chmod()&lt;/code&gt;, &lt;code&gt;$file&lt;/code&gt; may be a filename or a file handle.</source>
          <target state="translated">与内置的 &lt;code&gt;chmod()&lt;/code&gt; 一样， &lt;code&gt;$file&lt;/code&gt; 可以是文件名或文件句柄。</target>
        </trans-unit>
        <trans-unit id="1061a3cd33d1bd9d36627a353371c49a4d11968d" translate="yes" xml:space="preserve">
          <source>As with the mark stack to the value stack, the scope stack forms a pair with the save stack. The scope stack stores the height of the save stack at which nested scopes begin, and allows the save stack to be unwound back to that point when the scope is left.</source>
          <target state="translated">与标记栈到值栈一样,作用域栈与保存栈形成一对。作用域堆栈存储了嵌套作用域开始的保存堆栈的高度,并允许保存堆栈在离开作用域时回卷到该点。</target>
        </trans-unit>
        <trans-unit id="2a73b99d56aa400ec87ca02454010bfda953deea" translate="yes" xml:space="preserve">
          <source>As with the match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; in list context returns the same thing as in scalar context, i.e., the number of matches.</source>
          <target state="translated">与match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 运算符一样， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 可以使用其他定界符，例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; ，甚至 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; 。如果使用单引号 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; ，则将regexp和replace视为单引号字符串，并且不存在变量替换。 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 在列表上下文中返回的内容与在标量上下文中相同，即匹配数。</target>
        </trans-unit>
        <trans-unit id="8a7f1aef7986985cb8cfbcb39be9e92c12b6802e" translate="yes" xml:space="preserve">
          <source>As with the match &lt;code&gt;m//&lt;/code&gt; operator, &lt;code&gt;s///&lt;/code&gt; can use other delimiters, such as &lt;code&gt;s!!!&lt;/code&gt; and &lt;code&gt;s{}{}&lt;/code&gt;, and even &lt;code&gt;s{}//&lt;/code&gt;. If single quotes are used &lt;code&gt;s'''&lt;/code&gt;, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. &lt;code&gt;s///&lt;/code&gt; in list context returns the same thing as in scalar context,</source>
          <target state="translated">与match &lt;code&gt;m//&lt;/code&gt; 运算符一样， &lt;code&gt;s///&lt;/code&gt; 可以使用其他定界符，例如 &lt;code&gt;s!!!&lt;/code&gt; 和 &lt;code&gt;s{}{}&lt;/code&gt; ，甚至 &lt;code&gt;s{}//&lt;/code&gt; 。如果使用单引号 &lt;code&gt;s'''&lt;/code&gt; ，则将regexp和replace视为单引号字符串，并且不存在变量替换。 &lt;code&gt;s///&lt;/code&gt; 在列表上下文中返回的内容与在标量上下文中相同，</target>
        </trans-unit>
        <trans-unit id="5751273786ef031d84398bd287378b577d2ec97d" translate="yes" xml:space="preserve">
          <source>As with the matching operator, the regexp quote can use different delimiters,</source>
          <target state="translated">与匹配操作符一样,regexp引号可以使用不同的定界符。</target>
        </trans-unit>
        <trans-unit id="9cd8fd98a0003315162b3999969a156676702a25" translate="yes" xml:space="preserve">
          <source>As with the matching operator, the regexp quote can use different delimiters, e.g., &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt;. Apostrophes as delimiters (&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt;) inhibit any interpolation.</source>
          <target state="translated">与匹配运算符一样，正则表达式引用可以使用不同的定界符，例如 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt; 。撇号作为定界符（ &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt; ）禁止任何插值。</target>
        </trans-unit>
        <trans-unit id="e11bb01f2bd8c076a80300f6980985d85bb41c1a" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. It may be appropriate to &quot;auto CLOSE&quot; when this occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">与其他类型的关系，当这种方法被称为 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 发生。发生这种情况时，最好使用&amp;ldquo;自动关闭&amp;rdquo;。请参阅&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;下面的解开陷阱&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afcbb54437173c8bdb1b71e9fdd8c918462556a8" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when &lt;code&gt;untie&lt;/code&gt; happens. It may be appropriate to &quot;auto CLOSE&quot; when this occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;&lt;/a&gt; below.</source>
          <target state="translated">与其他类型的关系，当这种方法被称为 &lt;code&gt;untie&lt;/code&gt; 发生。发生这种情况时，最好使用&amp;ldquo;自动关闭&amp;rdquo;。请参阅下面的&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&amp;ldquo; &lt;code&gt;untie&lt;/code&gt; 陷阱&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d1c8cd71dac7105bd6440effb2807ea501bbea1" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when the tied handle is about to be destroyed. This is useful for debugging and possibly cleaning up.</source>
          <target state="translated">和其他类型的绑定一样,当绑定的句柄即将被销毁时,这个方法将被调用。这对调试和可能的清理很有用。</target>
        </trans-unit>
        <trans-unit id="c8628e08c07475c8f2b1e6b9f5f0e7ba611079bf" translate="yes" xml:space="preserve">
          <source>As with the return stack, it would be possible (and a small performance win) to pre-extend the return array before pushing data into it, since we know how many elements we will return:</source>
          <target state="translated">与返回栈一样,在将数据推入返回数组之前,可以预先扩展返回数组(而且在性能上也有小的优势),因为我们知道我们将返回多少元素。</target>
        </trans-unit>
        <trans-unit id="3d4c99ea11e7c5fcd5dc736377914de3be4bac49" translate="yes" xml:space="preserve">
          <source>As with the shell, in Perl the &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; is used to open the file in read-only mode. If it succeeds, Perl allocates a brand new filehandle for you and fills in your previously undefined &lt;code&gt;$handle&lt;/code&gt; argument with a reference to that handle.</source>
          <target state="translated">与外壳程序一样，在Perl中， &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 用于以只读模式打开文件。如果成功，Perl将为您分配一个全新的文件句柄，并使用对该句柄的引用来填充以前未定义的 &lt;code&gt;$handle&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="7fd1e1a58893cf268ad48b11d78449c12dc31c5c" translate="yes" xml:space="preserve">
          <source>As you can see 3 records have been successfully created with key &lt;code&gt;Wall&lt;/code&gt; - the only thing is, when they are retrieved from the database they</source>
          <target state="translated">如您所见，已使用密钥 &lt;code&gt;Wall&lt;/code&gt; 成功创建了3条记录-唯一的是，从数据库中检索它们时，</target>
        </trans-unit>
        <trans-unit id="07a24c035647250238dd385e01e0859319d79ee5" translate="yes" xml:space="preserve">
          <source>As you can see both modules have a broadly similar structure. They both make use of the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module and both have an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method. The difference between them is that the</source>
          <target state="translated">如您所见，这两个模块的结构大致相似。它们都使用 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 模块，并且都有 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法。它们之间的区别在于</target>
        </trans-unit>
        <trans-unit id="6c90ba06fa5e1fe7496f3d2e8756e36b17de7ff3" translate="yes" xml:space="preserve">
          <source>As you can see both modules have a broadly similar structure. They both make use of the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module and both have an &lt;code&gt;import&lt;/code&gt; method. The difference between them is that the</source>
          <target state="translated">如您所见，这两个模块的结构大致相似。它们都使用 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 模块，并且都有 &lt;code&gt;import&lt;/code&gt; 方法。它们之间的区别在于</target>
        </trans-unit>
        <trans-unit id="8f994dc63d7341f367ad1cc1ffc63c6ff1af1973" translate="yes" xml:space="preserve">
          <source>As you can see in the synopsis, based on your template, the arguments provided will be validated.</source>
          <target state="translated">正如你在简介中看到的,根据你的模板,提供的参数将被验证。</target>
        </trans-unit>
        <trans-unit id="fc43df7357cab99ebecef48bb020a483deb5469e" translate="yes" xml:space="preserve">
          <source>As you can see,</source>
          <target state="translated">如你所见。</target>
        </trans-unit>
        <trans-unit id="ba5fcb84fa73471a91e0f59090740d9676a886a8" translate="yes" xml:space="preserve">
          <source>As you can see, a new stream has been created for reading the source from &lt;code&gt;Fred.pm&lt;/code&gt; . This stream will remain active until all of &lt;code&gt;Fred.pm&lt;/code&gt; has been parsed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; will still exist, but is inactive. Once the parser has finished reading Fred.pm, the source stream associated with it will be destroyed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; then becomes active again and the parser reads line 4 and subsequent lines from &lt;code&gt;cpp_test&lt;/code&gt; .</source>
          <target state="translated">如您所见，已经创建了一个新流，用于从 &lt;code&gt;Fred.pm&lt;/code&gt; 读取源。在解析 &lt;code&gt;Fred.pm&lt;/code&gt; 所有Fred.pm之前，此流将保持活动状态。对于源流 &lt;code&gt;cpp_test&lt;/code&gt; 将仍然存在，但处于非活动状态。一旦解析器完成读取Fred.pm，与之关联的源流将被销毁。然后， &lt;code&gt;cpp_test&lt;/code&gt; 的源流再次变为活动状态，并且解析器从 &lt;code&gt;cpp_test&lt;/code&gt; 读取第4行和后续行。</target>
        </trans-unit>
        <trans-unit id="d30857f7aa9b41378f7136a05fa07d62994d4300" translate="yes" xml:space="preserve">
          <source>As you can see, a new stream has been created for reading the source from &lt;code&gt;Fred.pm&lt;/code&gt;. This stream will remain active until all of &lt;code&gt;Fred.pm&lt;/code&gt; has been parsed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; will still exist, but is inactive. Once the parser has finished reading Fred.pm, the source stream associated with it will be destroyed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; then becomes active again and the parser reads line 4 and subsequent lines from &lt;code&gt;cpp_test&lt;/code&gt;.</source>
          <target state="translated">如您所见，已经创建了一个新流，用于从 &lt;code&gt;Fred.pm&lt;/code&gt; 读取源。在解析 &lt;code&gt;Fred.pm&lt;/code&gt; 所有Fred.pm之前，此流将保持活动状态。对于源流 &lt;code&gt;cpp_test&lt;/code&gt; 将仍然存在，但处于非活动状态。一旦解析器完成读取Fred.pm，与之关联的源流将被销毁。然后， &lt;code&gt;cpp_test&lt;/code&gt; 的源流再次变为活动状态，并且解析器从 &lt;code&gt;cpp_test&lt;/code&gt; 读取第4行和后续行。</target>
        </trans-unit>
        <trans-unit id="25de0c5886c2da663b8272fdb54e70c4ca6e8f92" translate="yes" xml:space="preserve">
          <source>As you can see, either a bare number or a quoted string can usually be used interchangeably, except in the case of a trailing zero, which must be quoted to be converted properly. For this reason, it is strongly recommended that all initializers to qv() be quoted strings instead of bare numbers.</source>
          <target state="translated">正如您所看到的,裸数或引号字符串通常可以互换使用,但尾部为零的情况除外,它必须被引号才能正确转换。因此,我们强烈建议所有qv()的初始化器都使用引号字符串而不是裸数。</target>
        </trans-unit>
        <trans-unit id="413492c2aba459a109ff8cf8bd650d35b867bf30" translate="yes" xml:space="preserve">
          <source>As you can see, even though we parsed out a branch and a piece, it was ultimately only an atom. The final program shows us how things work. We have an &lt;code&gt;EXACT&lt;/code&gt; regop, followed by an &lt;code&gt;END&lt;/code&gt; regop. The number in parens indicates where the &lt;code&gt;regnext&lt;/code&gt; of the node goes. The &lt;code&gt;regnext&lt;/code&gt; of an &lt;code&gt;END&lt;/code&gt; regop is unused, as &lt;code&gt;END&lt;/code&gt; regops mean we have successfully matched. The number on the left indicates the position of the regop in the regnode array.</source>
          <target state="translated">如您所见，即使我们解析出一个分支和一个片段，最终它也只是一个原子。最终程序向我们展示了事情是如何工作的。我们有一个 &lt;code&gt;EXACT&lt;/code&gt; 规则，然后是一个 &lt;code&gt;END&lt;/code&gt; 规则。括号中的数字表示节点的 &lt;code&gt;regnext&lt;/code&gt; 。该 &lt;code&gt;regnext&lt;/code&gt; 一个的 &lt;code&gt;END&lt;/code&gt; regop是未使用的，因为 &lt;code&gt;END&lt;/code&gt; regops意味着我们已经成功匹配。左侧的数字表示regop在regnode数组中的位置。</target>
        </trans-unit>
        <trans-unit id="a413e2eb7d932038f9ab1ac09695763b902b4d80" translate="yes" xml:space="preserve">
          <source>As you can see, it's getting a bit complicated. That's why sometimes is easier to take a temporary on your way through:</source>
          <target state="translated">如你所见,它变得有点复杂。所以有时候在你的路上临时抱佛脚是比较容易的。</target>
        </trans-unit>
        <trans-unit id="3fa1293b0c00ad3a76c1e01bf182a9e2122f9fdc" translate="yes" xml:space="preserve">
          <source>As you can see, the &quot;big end&quot; of the arrow touches the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is a nice way to remember that &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier. The same obviously works for &lt;code&gt;&amp;lt;&lt;/code&gt; , where the &quot;little end&quot; touches the code.</source>
          <target state="translated">如您所见，箭头的&amp;ldquo;大头&amp;rdquo;触及 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ，这是记住 &lt;code&gt;&amp;gt;&lt;/code&gt; 是big-endian修饰符的好方法。显然，对于 &lt;code&gt;&amp;lt;&lt;/code&gt; ，这同样适用，其中&amp;ldquo;小头&amp;rdquo;触及代码。</target>
        </trans-unit>
        <trans-unit id="e38e7377d2adf9700c078e4fa63c0bfa66881f41" translate="yes" xml:space="preserve">
          <source>As you can see, the &quot;big end&quot; of the arrow touches the &lt;code&gt;s&lt;/code&gt;, which is a nice way to remember that &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier. The same obviously works for &lt;code&gt;&amp;lt;&lt;/code&gt;, where the &quot;little end&quot; touches the code.</source>
          <target state="translated">如您所见，箭头的&amp;ldquo;大端&amp;rdquo;触及 &lt;code&gt;s&lt;/code&gt; ，这是记住 &lt;code&gt;&amp;gt;&lt;/code&gt; 是大端修饰符的好方法。显然，对于 &lt;code&gt;&amp;lt;&lt;/code&gt; ，这同样适用，其中&amp;ldquo;小头&amp;rdquo;触及代码。</target>
        </trans-unit>
        <trans-unit id="66163e2bfe72429a8264b60a772dffb530266b37" translate="yes" xml:space="preserve">
          <source>As you can see, the &lt;code&gt;&quot;|&quot;&lt;/code&gt; binds less tightly than a sequence of ordinary characters. We can override this by using the grouping metacharacters, the parentheses &lt;code&gt;&quot;(&quot;&lt;/code&gt; and &lt;code&gt;&quot;)&quot;&lt;/code&gt;.</source>
          <target state="translated">如您所见， &lt;code&gt;&quot;|&quot;&lt;/code&gt; 绑定不如普通字符序列那么紧密。我们可以通过使用分组元字符，括号 &lt;code&gt;&quot;(&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;)&quot;&lt;/code&gt; 来覆盖它。</target>
        </trans-unit>
        <trans-unit id="8d3da9040412695027bfa4b6fb728646046f3571" translate="yes" xml:space="preserve">
          <source>As you can see, the continuation bytes all begin with &lt;code&gt;&quot;10&quot;&lt;/code&gt; , and the leading bits of the start byte tell how many bytes there are in the encoded character.</source>
          <target state="translated">如您所见，连续字节都以 &lt;code&gt;&quot;10&quot;&lt;/code&gt; 开头，起始字节的前导位表明编码字符中有多少个字节。</target>
        </trans-unit>
        <trans-unit id="d1ec4366039f138acb113c4753f7ee644d2c9618" translate="yes" xml:space="preserve">
          <source>As you can see, the continuation bytes all begin with &lt;code&gt;&quot;10&quot;&lt;/code&gt;, and the leading bits of the start byte tell how many bytes there are in the encoded character.</source>
          <target state="translated">如您所见，连续字节都以 &lt;code&gt;&quot;10&quot;&lt;/code&gt; 开头，起始字节的前导位表明编码字符中有多少个字节。</target>
        </trans-unit>
        <trans-unit id="3abefb49e57cec4dd056d885964fc7e8cddbabc0" translate="yes" xml:space="preserve">
          <source>As you can see, we've stored the path and file data in the object itself. Remember, under the hood, this object is still just a hash. Later, we'll write accessors to manipulate this data.</source>
          <target state="translated">正如你所看到的,我们已经将路径和文件数据存储在对象本身。请记住,在外壳下,这个对象仍然只是一个哈希。稍后,我们将编写访问器来操作这些数据。</target>
        </trans-unit>
        <trans-unit id="5a6344bf7b33dbff5320cfc2c10a629a29808655" translate="yes" xml:space="preserve">
          <source>As you can tell from a glance at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;, the L&amp;lt;...&amp;gt; code is the most complex of the Pod formatting codes. The points below will hopefully clarify what it means and how processors should deal with it.</source>
          <target state="translated">正如你可以一目了然的告诉&lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;时，L &amp;lt;...&amp;gt;代码是最复杂的波德格式化代码。以下几点有望阐明其含义以及处理器应如何处理。</target>
        </trans-unit>
        <trans-unit id="9261097e2916c2cc0f66dd44d4a942cdcbac0f6d" translate="yes" xml:space="preserve">
          <source>As you craft each patch you intend to submit to the Perl core, it's important to write a good commit message. This is especially important if your submission will consist of a series of commits.</source>
          <target state="translated">当你精心设计你打算提交给 Perl 核心的每个补丁时,写好提交信息是很重要的。如果你的提交是由一系列的提交组成,那么这一点尤其重要。</target>
        </trans-unit>
        <trans-unit id="585d50527e778d78ffa867804e8d6039ce87d004" translate="yes" xml:space="preserve">
          <source>As you may have inferred from the above documentation and examples, &lt;code&gt;ok&lt;/code&gt; 's prototype is &lt;code&gt;($;$$)&lt;/code&gt; (and, incidentally, &lt;code&gt;skip&lt;/code&gt; 's is &lt;code&gt;($;$$$)&lt;/code&gt;). This means, for example, that you can do &lt;code&gt;ok @foo, @bar&lt;/code&gt; to compare the</source>
          <target state="translated">从上面的文档和示例中可以推断出， &lt;code&gt;ok&lt;/code&gt; 的原型是 &lt;code&gt;($;$$)&lt;/code&gt; （顺便说一下， &lt;code&gt;skip&lt;/code&gt; 的是 &lt;code&gt;($;$$$)&lt;/code&gt; ）。例如，这意味着您可以执行 &lt;code&gt;ok @foo, @bar&lt;/code&gt; 来比较</target>
        </trans-unit>
        <trans-unit id="60f0e85b8faee0b99818f50244dd5f18552cf61a" translate="yes" xml:space="preserve">
          <source>As you may have inferred from the above documentation and examples, &lt;code&gt;ok&lt;/code&gt;'s prototype is &lt;code&gt;($;$$)&lt;/code&gt; (and, incidentally, &lt;code&gt;skip&lt;/code&gt;'s is &lt;code&gt;($;$$$)&lt;/code&gt;). This means, for example, that you can do &lt;code&gt;ok @foo, @bar&lt;/code&gt; to compare the</source>
          <target state="translated">从上面的文档和示例中可以推断出， &lt;code&gt;ok&lt;/code&gt; 的原型是 &lt;code&gt;($;$$)&lt;/code&gt; （顺便说一下， &lt;code&gt;skip&lt;/code&gt; 的是 &lt;code&gt;($;$$$)&lt;/code&gt; ）。例如，这意味着您可以执行 &lt;code&gt;ok @foo, @bar&lt;/code&gt; 来比较</target>
        </trans-unit>
        <trans-unit id="d3a79c79e4e5a9fafc42ddaaf88736c1e2cc7621" translate="yes" xml:space="preserve">
          <source>As you may have noticed, the name of the FETCH method (et al.) is the same for all accesses, even though the constructors differ in names (TIESCALAR vs TIEARRAY). While in theory you could have the same class servicing several tied types, in practice this becomes cumbersome, and it's easiest to keep them at simply one tie type per class.</source>
          <target state="translated">正如你可能已经注意到的,FETCH方法(等)的名称对于所有的访问都是一样的,尽管构造函数的名称不同(TIESCALAR与TIEARRAY)。虽然理论上你可以让同一个类为多个绑定类型服务,但实际上这样做会变得很麻烦,最简单的做法是每个类只保留一个绑定类型。</target>
        </trans-unit>
        <trans-unit id="e80271d1fdc3feb0460f1e3a1704fc272e31f101" translate="yes" xml:space="preserve">
          <source>As you might know this calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function of &lt;code&gt;attributes&lt;/code&gt; at compile time with these parameters: 'attributes', the caller's package name, the reference to the code and 'method'.</source>
          <target state="translated">您可能知道，这会在编译时使用以下参数调用 &lt;code&gt;attributes&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 功能：&amp;ldquo;属性&amp;rdquo;，调用方的程序包名称，对代码的引用和&amp;ldquo;方法&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="62f1e6ecdd027dd1eaef3a110461833a51c5767e" translate="yes" xml:space="preserve">
          <source>As you might know this calls the &lt;code&gt;import&lt;/code&gt; function of &lt;code&gt;attributes&lt;/code&gt; at compile time with these parameters: 'attributes', the caller's package name, the reference to the code and 'method'.</source>
          <target state="translated">您可能知道，这会在编译时使用以下参数调用 &lt;code&gt;attributes&lt;/code&gt; 的 &lt;code&gt;import&lt;/code&gt; 功能：&amp;ldquo;属性&amp;rdquo;，调用者的程序包名称，对代码的引用和&amp;ldquo;方法&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0f14d6a62a3d5dfc412b082b83700a2aa2b31479" translate="yes" xml:space="preserve">
          <source>As you see from those examples, &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt; are output handles, and &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;ARGV&lt;/code&gt; are input handles. They are in all capital letters because they are reserved to Perl, much like the &lt;code&gt;@ARGV&lt;/code&gt; array and the &lt;code&gt;%ENV&lt;/code&gt; hash are. Their external associations were set up by your shell.</source>
          <target state="translated">从这些示例中可以看到， &lt;code&gt;STDOUT&lt;/code&gt; 和 &lt;code&gt;STDERR&lt;/code&gt; 是输出句柄，而 &lt;code&gt;STDIN&lt;/code&gt; 和 &lt;code&gt;ARGV&lt;/code&gt; 是输入句柄。它们全部用大写字母表示，因为它们保留给了Perl，就像 &lt;code&gt;@ARGV&lt;/code&gt; 数组和 &lt;code&gt;%ENV&lt;/code&gt; 哈希一样。它们的外部关联由您的shell设置。</target>
        </trans-unit>
        <trans-unit id="e27f616d9e27793d35d5e898cb0fead7ca633114" translate="yes" xml:space="preserve">
          <source>As you see, it's quite easy to become confused. While some small portion of the blame for this can be attributed to the reference-based implementation, it's really more due to a lack of existing documentation with examples designed for the beginner.</source>
          <target state="translated">正如你所看到的,这很容易让人感到困惑。虽然这其中有一小部分原因是由于基于参考的实现,但实际上更多的是由于缺乏为初学者设计的例子的现有文档。</target>
        </trans-unit>
        <trans-unit id="512c5953fca52adf9fe503c69215e4eb2353e34b" translate="yes" xml:space="preserve">
          <source>As you see, it's remarkably similar to the Internet domain TCP server, so much so, in fact, that we've omitted several duplicate functions--spawn(), logmsg(), ctime(), and REAPER()--which are the same as in the other server.</source>
          <target state="translated">正如你所看到的,它与Internet域TCP服务器非常相似,事实上,我们省略了几个重复的函数--spawn()、logmsg()、ctime()和REAPER()--这些函数与其他服务器中的函数相同。</target>
        </trans-unit>
        <trans-unit id="ea8178cd8e63a3e66a311fade3362af15d43aa5f" translate="yes" xml:space="preserve">
          <source>As you see, the name of the package is the name of the structure. Regular fields are just their own names. Plus the following accessor functions are provided for your convenience:</source>
          <target state="translated">如你所见,包的名称就是结构的名称。常规字段只是自己的名字。另外,为了方便大家,还提供了以下访问函数。</target>
        </trans-unit>
        <trans-unit id="1963330f0948df59dbdb1893ed34078a319f8af0" translate="yes" xml:space="preserve">
          <source>As you see, the next buffer begins with \x43. But \x43 is 'C' in ASCII, which is wrong in this case because we are now in JISX 0208 area so it has to convert \x43\x46, not \x43. Unlike utf8 and EUC, in escape-based encodings you can't tell if a given octet is a whole character or just part of it.</source>
          <target state="translated">如你所见,下一个缓冲区是以 \x43开头的。但是在ASCII码中,x43是'C',在这种情况下是错误的,因为我们现在是在JISX 0208区域,所以它必须转换x43/x46,而不是x43。与utf8和EUC不同的是,在基于转义的编码中,你无法判断一个给定的八位组是一个完整的字符还是只是其中的一部分。</target>
        </trans-unit>
        <trans-unit id="b457b60332a38dcdc3bc2fb765fda15f087f9402" translate="yes" xml:space="preserve">
          <source>As you see, there is one exception: in ASCII. That way you can assume Goal #1. And with &lt;code&gt;Encode&lt;/code&gt; , Goal #2 is assumed but you still have to be careful in the cases mentioned in the &lt;b&gt;CAVEAT&lt;/b&gt; paragraphs above.</source>
          <target state="translated">如您所见，有一个例外：ASCII。这样，您可以假设目标1。使用 &lt;code&gt;Encode&lt;/code&gt; 时，假设目标为＃2，但在上面&lt;b&gt;CAVEAT&lt;/b&gt;段落中提到的情况下，您仍然必须小心。</target>
        </trans-unit>
        <trans-unit id="7cc089f777993943781491fc9a72f85a9a2f245b" translate="yes" xml:space="preserve">
          <source>As you see, this can be a bit tricky. It's important to realize that a regular expression is merely a set of assertions that gives a definition of success. There may be 0, 1, or several different ways that the definition might succeed against a particular string. And if there are multiple ways it might succeed, you need to understand backtracking to know which variety of success you will achieve.</source>
          <target state="translated">如你所见,这可能有点棘手。重要的是要意识到正则表达式只是一组断言,它给出了成功的定义。可能有 0、1 或几种不同的方式让这个定义对一个特定的字符串成功。而如果有多种可能成功的方式,你需要了解回溯,以知道你将实现哪种品种的成功。</target>
        </trans-unit>
        <trans-unit id="f1ce088efa2db68e2d881f71961d1904be5d37ad" translate="yes" xml:space="preserve">
          <source>As you would expect, this modifier causes, for example, &lt;code&gt;\D&lt;/code&gt; to mean the same thing as &lt;code&gt;[^0-9]&lt;/code&gt; ; in fact, all non-ASCII characters match &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , and &lt;code&gt;\W&lt;/code&gt; . &lt;code&gt;\b&lt;/code&gt; still means to match at the boundary between &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt; , using the &lt;code&gt;/a&lt;/code&gt; definitions of them (similarly for &lt;code&gt;\B&lt;/code&gt; ).</source>
          <target state="translated">如您所料，此修饰符会导致 &lt;code&gt;\D&lt;/code&gt; 与 &lt;code&gt;[^0-9]&lt;/code&gt; 含义相同；事实上，所有非ASCII字符匹配 &lt;code&gt;\D&lt;/code&gt; ， &lt;code&gt;\S&lt;/code&gt; ，和 &lt;code&gt;\W&lt;/code&gt; 。 &lt;code&gt;\b&lt;/code&gt; 仍然意味着以匹配之间的边界 &lt;code&gt;\w&lt;/code&gt; 和 &lt;code&gt;\W&lt;/code&gt; ，使用 &lt;code&gt;/a&lt;/code&gt; 它们的定义（类似地对于 &lt;code&gt;\B&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="326d016c49ef7a973850d57e2bcbf3c0189253be" translate="yes" xml:space="preserve">
          <source>As you would expect, this modifier causes, for example, &lt;code&gt;\D&lt;/code&gt; to mean the same thing as &lt;code&gt;[^0-9]&lt;/code&gt;; in fact, all non-ASCII characters match &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt;. &lt;code&gt;\b&lt;/code&gt; still means to match at the boundary between &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt;, using the &lt;code&gt;/a&lt;/code&gt; definitions of them (similarly for &lt;code&gt;\B&lt;/code&gt;).</source>
          <target state="translated">如您所料，此修饰符使 &lt;code&gt;\D&lt;/code&gt; 与 &lt;code&gt;[^0-9]&lt;/code&gt; 含义相同；事实上，所有非ASCII字符匹配 &lt;code&gt;\D&lt;/code&gt; ， &lt;code&gt;\S&lt;/code&gt; ，和 &lt;code&gt;\W&lt;/code&gt; 。 &lt;code&gt;\b&lt;/code&gt; 仍然意味着以匹配之间的边界 &lt;code&gt;\w&lt;/code&gt; 和 &lt;code&gt;\W&lt;/code&gt; ，使用 &lt;code&gt;/a&lt;/code&gt; 它们的定义（类似地对于 &lt;code&gt;\B&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="26154301b1350500c1d0c8c752bea63ea6529192" translate="yes" xml:space="preserve">
          <source>As you're writing an application, you decide as you go what messages you need to emit. Normally you'd go to write this:</source>
          <target state="translated">当你在写一个应用程序的时候,你要决定你需要发出什么消息。通常你会去写这个。</target>
        </trans-unit>
        <trans-unit id="94a73ad4a31e87483d1616b8954f4b6c0ff428df" translate="yes" xml:space="preserve">
          <source>As you've seen, you can force &lt;code&gt;catdir()&lt;/code&gt; to create an absolute path by passing either an empty string or a path that begins with a volume name as the first argument. However, you are strongly encouraged not to do so, since this is done only for backward compatibility. Newer versions of File::Spec come with a method called &lt;code&gt;catpath()&lt;/code&gt; (see below), that is designed to offer a portable solution for the creation of absolute paths. It takes volume, directory and file portions and returns an entire path. While &lt;code&gt;catdir()&lt;/code&gt; is still suitable for the concatenation of</source>
          <target state="translated">如您所见，您可以通过传递空字符串或以卷名开头的路径作为第一个参数来强制 &lt;code&gt;catdir()&lt;/code&gt; 创建绝对路径。但是，强烈建议您不要这样做，因为这样做只是为了向后兼容。 File :: Spec的较新版本附带一个名为 &lt;code&gt;catpath()&lt;/code&gt; 的方法（请参见下文），该方法旨在为创建绝对路径提供一种可移植的解决方案。它需要卷，目录和文件部分，并返回完整路径。尽管 &lt;code&gt;catdir()&lt;/code&gt; 仍然适合于</target>
        </trans-unit>
        <trans-unit id="b050afe32e842917948687f3937c11147c83dc8c" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_bin()&lt;/code&gt;, but with a &quot;0b&quot; prefix.</source>
          <target state="translated">与 &lt;code&gt;to_bin()&lt;/code&gt; 相同，但前缀为&amp;ldquo; 0b&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="88a7400facc4c4fbcaa07e7c2bb5aa1602866660" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_hex()&lt;/code&gt;, but with a &quot;0x&quot; prefix.</source>
          <target state="translated">与 &lt;code&gt;to_hex()&lt;/code&gt; 相同，但前缀为&amp;ldquo; 0x&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="743f14ce73f3cd35ea5c0dbbced7d93ed35d470e" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_oct()&lt;/code&gt;, but with a &quot;0&quot; prefix.</source>
          <target state="translated">与 &lt;code&gt;to_oct()&lt;/code&gt; 一样，但前缀为&amp;ldquo; 0&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a173e725607d0f98c78ebac0b31138d8d136aa84" translate="yes" xml:space="preserve">
          <source>Asia</source>
          <target state="translated">Asia</target>
        </trans-unit>
        <trans-unit id="ef98034aa566e13ada7b3540ed05db8863763db2" translate="yes" xml:space="preserve">
          <source>Aside from an experimental facility (see &lt;a href=&quot;#Signatures&quot;&gt;&quot;Signatures&quot;&lt;/a&gt; below), Perl does not have named formal parameters. In practice all you do is assign to a &lt;code&gt;my()&lt;/code&gt; list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see &lt;a href=&quot;#Private-Variables-via-my%28%29&quot;&gt;&quot;Private Variables via my()&quot;&lt;/a&gt; and &lt;a href=&quot;#Temporary-Values-via-local%28%29&quot;&gt;&quot;Temporary Values via local()&quot;&lt;/a&gt;. To create protected environments for a set of functions in a separate package (and probably a separate file), see &lt;a href=&quot;perlmod#Packages&quot;&gt;&quot;Packages&quot; in perlmod&lt;/a&gt;.</source>
          <target state="translated">除了实验设施（请参见下面的&lt;a href=&quot;#Signatures&quot;&gt;&amp;ldquo;签名&amp;rdquo;&lt;/a&gt;）之外，Perl还没有命名形式参数。实际上，您要做的只是分配给这些的 &lt;code&gt;my()&lt;/code&gt; 列表。未声明为私有的变量是全局变量。有关创建私有变量的详细信息，请参见&lt;a href=&quot;#Private-Variables-via-my%28%29&quot;&gt;&amp;ldquo;通过my（）的私有变量&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;#Temporary-Values-via-local%28%29&quot;&gt;&amp;ldquo;通过local（）的临时值&amp;rdquo;&lt;/a&gt;。要在单独的程序包（可能还有单独的文件）中为一组功能创建受保护的环境，请参见&lt;a href=&quot;perlmod#Packages&quot;&gt;perlmod中的&amp;ldquo;程序包&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f22fac8ac4e191689a82159394064af8e931487a" translate="yes" xml:space="preserve">
          <source>Aside from an experimental facility (see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below), Perl does not have named formal parameters. In practice all you do is assign to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see &lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;Private Variables via my()&lt;/a&gt; and &lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;Temporary Values via local()&lt;/a&gt;. To create protected environments for a set of functions in a separate package (and probably a separate file), see &lt;a href=&quot;perlmod#Packages&quot;&gt;Packages in perlmod&lt;/a&gt;.</source>
          <target state="translated">除了实验设施（请参见下面的&lt;a href=&quot;#Signatures&quot;&gt;签名&lt;/a&gt;）之外，Perl还没有命名形式参数。实际上，您要做的只是分配给这些的 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; 列表。未声明为私有的变量是全局变量。有关创建私有变量的详细信息，请参见&lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;通过my（）的私有变量&lt;/a&gt;和&lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;通过local（）的临时值&lt;/a&gt;。要在单独的程序包（可能是单独的文件）中为一组功能创建受保护的环境，请参见&lt;a href=&quot;perlmod#Packages&quot;&gt;perlmod中的程序包&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0befd0a8afa8c19a870d175a4fdb840002143042" translate="yes" xml:space="preserve">
          <source>Ask it to create new Perl executable:</source>
          <target state="translated">要求它创建新的Perl可执行文件。</target>
        </trans-unit>
        <trans-unit id="06d5ff26b7db3df6b27e4da48afc0d8940af7b07" translate="yes" xml:space="preserve">
          <source>Ask the current maintainer to make you a co-maintainer or transfer the module to you.</source>
          <target state="translated">要求当前的维护者让你成为共同维护者,或者将模块转移给你。</target>
        </trans-unit>
        <trans-unit id="640918b79c5c24d060028d2fd27fecdba24558af" translate="yes" xml:space="preserve">
          <source>Ask the server for &quot;helpful information&quot; (that's what the RFC says) on the commands it accepts.</source>
          <target state="translated">向服务器询问它所接受的命令的 &quot;有用信息&quot;(这是RFC的说法)。</target>
        </trans-unit>
        <trans-unit id="29957267ee0cac223134add5f2b52ea620705c23" translate="yes" xml:space="preserve">
          <source>Ask them for it. There are so many email providers available that it's unlikely the local system has any idea how to determine a user's email address.</source>
          <target state="translated">问他们要。有这么多的电子邮件提供商,本地系统不可能知道如何确定用户的电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="8175f0d205c5d75254bfd57646dfed8cae5e64df" translate="yes" xml:space="preserve">
          <source>Assert that 2 strings are not the same.</source>
          <target state="translated">断定2个字符串是不一样的。</target>
        </trans-unit>
        <trans-unit id="105ecea82b3155461bbe416d044a05c528e58f67" translate="yes" xml:space="preserve">
          <source>Assert that 2 strings are the same.</source>
          <target state="translated">断定2个字符串是相同的。</target>
        </trans-unit>
        <trans-unit id="3cd83e9891bd9f5bea1baf962bedc44d308569ef" translate="yes" xml:space="preserve">
          <source>Assertion %s failed: file &quot;%s&quot;, line %d</source>
          <target state="translated">断言%s失败:文件&quot;%s&quot;,行%d。</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="00331b7ae6edef1dff40c7175d1e39fd7f33aa69" translate="yes" xml:space="preserve">
          <source>Assertions are conditions that have to be true; they don't actually match parts of the substring. There are six assertions that are written as backslash sequences.</source>
          <target state="translated">断言是必须为真的条件,它们实际上并不匹配子串的部分。有六个断言被写成反斜杠序列。</target>
        </trans-unit>
        <trans-unit id="ec473104d4054125a1271db8c3a3c454c061191a" translate="yes" xml:space="preserve">
          <source>Assigned Charset Names by IANA</source>
          <target state="translated">IANA分配的Charset名称</target>
        </trans-unit>
        <trans-unit id="6a86826951e8fe2168fef92e79a3e63e6f4fad1f" translate="yes" xml:space="preserve">
          <source>Assigned value is not %s reference</source>
          <target state="translated">指定值不是%s参考</target>
        </trans-unit>
        <trans-unit id="9f6fd2dd7df68753c5a7360c0d8b35ab5d159443" translate="yes" xml:space="preserve">
          <source>Assigned value is not a reference</source>
          <target state="translated">指定值不是参考值</target>
        </trans-unit>
        <trans-unit id="bc266cdcbb6ece4821fb3ad4912b26e12d68bda4" translate="yes" xml:space="preserve">
          <source>Assigning Magic</source>
          <target state="translated">分配魔法</target>
        </trans-unit>
        <trans-unit id="50bb715253aae843187816dcb0ecbb87efcdec5e" translate="yes" xml:space="preserve">
          <source>Assigning a filehandle to a bareword</source>
          <target state="translated">将文件柄分配给一个空字。</target>
        </trans-unit>
        <trans-unit id="5758c53717d47b26aecb2f1e95a4e608692a5e69" translate="yes" xml:space="preserve">
          <source>Assigning and Dereferencing Variables.</source>
          <target state="translated">分配和取消引用变量。</target>
        </trans-unit>
        <trans-unit id="9b18b9bc51526dfb449c1c7223109c18c9530a59" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to $[ is fatal</source>
          <target state="translated">将非零赋值给$[是致命的。</target>
        </trans-unit>
        <trans-unit id="a93015f6058ffbf0e4e5d995a578a534b1b45233" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to $[ is no longer possible</source>
          <target state="translated">不再可以将非零赋值给$[。</target>
        </trans-unit>
        <trans-unit id="39852930a7cbed0e34d5b478d338273371ea5664" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to &lt;code&gt;$[&lt;/code&gt; is fatal</source>
          <target state="translated">为 &lt;code&gt;$[&lt;/code&gt; 分配非零值是致命的</target>
        </trans-unit>
        <trans-unit id="d524a6069dcf850237db76c5b77de165e1b358ee" translate="yes" xml:space="preserve">
          <source>Assigning to References</source>
          <target state="translated">分配给参考资料</target>
        </trans-unit>
        <trans-unit id="c279a061dbc31dc7bee97d46022b90f62667a4ac" translate="yes" xml:space="preserve">
          <source>Assigning to a list of private variables to name your arguments:</source>
          <target state="translated">赋值给私有变量列表来命名你的参数。</target>
        </trans-unit>
        <trans-unit id="5095fe9fb68e9a62edc8c9686322a7856091bd87" translate="yes" xml:space="preserve">
          <source>Assigning to an entry in the hash will cause the time stamps of the file to be modified. If the file does not exist then it will be created. Assigning a single integer to a hash element will cause both the access and modification times to be changed to that value. Alternatively a reference to an array of two values can be passed. The first array element will be used to set the access time and the second element will be used to set the modification time.</source>
          <target state="translated">分配给哈希中的一个条目将导致文件的时间戳被修改。如果文件不存在,那么它将被创建。给哈希元素分配一个整数将导致访问和修改时间都改变为该值。另外,也可以传递一个包含两个值的数组的引用。第一个数组元素将用于设置访问时间,第二个元素将用于设置修改时间。</target>
        </trans-unit>
        <trans-unit id="7ca1018fbacf1aa9c5974935df5ed892f5691b8b" translate="yes" xml:space="preserve">
          <source>Assigning to the special variable $[</source>
          <target state="translated">赋值给特殊变量$[</target>
        </trans-unit>
        <trans-unit id="7bec00ae67953bf63f8b1b3f8ddf8f9255f79d82" translate="yes" xml:space="preserve">
          <source>Assignment Operators</source>
          <target state="translated">分配操作者</target>
        </trans-unit>
        <trans-unit id="91becff514df4bb52422a8c72ad2fa7e138a09c4" translate="yes" xml:space="preserve">
          <source>Assignment is a little bit special in that it uses its left argument to determine the context for the right argument. Assignment to a scalar evaluates the right-hand side in scalar context, while assignment to an array or hash evaluates the righthand side in list context. Assignment to a list (or slice, which is just a list anyway) also evaluates the right-hand side in list context.</source>
          <target state="translated">赋值有点特殊,它使用左参数来决定右参数的上下文。对一个标量的赋值是在标量上下文中评估右侧,而对一个数组或哈希的赋值是在列表上下文中评估右侧。对一个 list(或 slice,反正就是一个 list)的赋值也是在 list 上下文中评估右手边。</target>
        </trans-unit>
        <trans-unit id="eeb7b7ef33aeb4c3b9e41b0d3c8c37efe141de32" translate="yes" xml:space="preserve">
          <source>Assignment operators work as in C. That is,</source>
          <target state="translated">赋值运算符的工作原理与C中一样,即。</target>
        </trans-unit>
        <trans-unit id="e44ee3c1149f2c21100b91bdf4ef60fbcf7575f3" translate="yes" xml:space="preserve">
          <source>Assignment to a typeglob performs an aliasing operation, i.e.,</source>
          <target state="translated">赋值给一个类型球,执行一个别名操作,即。</target>
        </trans-unit>
        <trans-unit id="efdb1ec14f21e9ed5ad15f6e0bef5c8c9ed1a0b1" translate="yes" xml:space="preserve">
          <source>Assignment to both a list and a scalar</source>
          <target state="translated">同时对列表和标量进行赋值。</target>
        </trans-unit>
        <trans-unit id="101d3fe15227197bfb043f8902c240196099b710" translate="yes" xml:space="preserve">
          <source>Assignment to references and non-references may be combined in lists and conditional ternary expressions, as long as the values on the right-hand side are the right type for each element on the left, though this may make for obfuscated code:</source>
          <target state="translated">对引用和非引用的赋值可以结合在列表和条件三元表达式中,只要右侧的值是左侧每个元素的正确类型,尽管这可能会使代码变得模糊不清。</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="38be444e6e51033245feebeecd19c780a4190e4e" translate="yes" xml:space="preserve">
          <source>Associated with the matching variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... are the &lt;b&gt;backreferences&lt;/b&gt;&lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ... Backreferences are matching variables that can be used</source>
          <target state="translated">&lt;b&gt;向后引用&lt;/b&gt; &lt;code&gt;\g1&lt;/code&gt; ， &lt;code&gt;\g2&lt;/code&gt; ，... 与匹配变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ，...相关联... &lt;b&gt;向后引用&lt;/b&gt;是可以使用的匹配变量</target>
        </trans-unit>
        <trans-unit id="de3f3ea1d0b7efcc3a2ee5d6b60bcc68b1043b48" translate="yes" xml:space="preserve">
          <source>Associated with the matching variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, ... are the &lt;b&gt;backreferences&lt;/b&gt;&lt;code&gt;\g1&lt;/code&gt;, &lt;code&gt;\g2&lt;/code&gt;, ... Backreferences are matching variables that can be used</source>
          <target state="translated">后向&lt;b&gt;引用&lt;/b&gt; &lt;code&gt;\g1&lt;/code&gt; ， &lt;code&gt;\g2&lt;/code&gt; ，...与匹配变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ，...相关联...后向&lt;b&gt;引用&lt;/b&gt;是可以使用的匹配变量</target>
        </trans-unit>
        <trans-unit id="68987493bca5f5e7abadf4c61d3d6f22214b34fc" translate="yes" xml:space="preserve">
          <source>Associates an internal FILEHANDLE with the external file specified by EXPR. That filehandle will subsequently allow you to perform I/O operations on that file, such as reading from it or writing to it.</source>
          <target state="translated">将内部FILEHANDLE与EXPR指定的外部文件关联起来。该filehandle随后将允许您对该文件进行I/O操作,例如从它读取或向它写入。</target>
        </trans-unit>
        <trans-unit id="6addecb62c84d829e48e459ba05882e03a175023" translate="yes" xml:space="preserve">
          <source>Assume &lt;b&gt;anything&lt;/b&gt; about structs (especially the ones you don't control, like the ones coming from the system headers)</source>
          <target state="translated">假定有关结构的&lt;b&gt;任何&lt;/b&gt;内容（尤其是您不控制的结构，例如来自系统头文件的结构）</target>
        </trans-unit>
        <trans-unit id="9e766ffb9a2f9804774162774bb465b7a888d65a" translate="yes" xml:space="preserve">
          <source>Assume each sentence ends with two spaces and try to preserve that spacing. Without this option, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space.</source>
          <target state="translated">假设每个句子的结尾都有两个空格,并尽量保留这个间距。如果没有这个选项,非逐字记录段落中所有连续的空白都会被压缩成一个空格。</target>
        </trans-unit>
        <trans-unit id="eb29cb4a3a64a3e55d8f8b66fc5429f33cc90a54" translate="yes" xml:space="preserve">
          <source>Assume four classes, A,B,C &amp;amp; D.</source>
          <target state="translated">假设有A，B，C和D四类。</target>
        </trans-unit>
        <trans-unit id="52c1183f42274e0344acc650141fdfaebc8ac557" translate="yes" xml:space="preserve">
          <source>Assume no one is paying attention and skips prompts for distributions that do that correctly. &lt;code&gt;cpan(1)&lt;/code&gt; sets this to &lt;code&gt;1&lt;/code&gt; unless it already has a value (even if that value is false).</source>
          <target state="translated">假设没有人注意，并跳过提示正确执行分发的提示。 &lt;code&gt;cpan(1)&lt;/code&gt; 将此值设置为 &lt;code&gt;1&lt;/code&gt; ,除非它已经有一个值（即使该值为false）。</target>
        </trans-unit>
        <trans-unit id="2226e484e68600c3306101e70d0302d670391b19" translate="yes" xml:space="preserve">
          <source>Assume nothing about numerical values (&lt;a href=&quot;perlfunc#ord-EXPR&quot;&gt;&lt;code&gt;ord&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#chr-NUMBER&quot;&gt;&lt;code&gt;chr&lt;/code&gt;&lt;/a&gt;) of characters. Do not use explicit code point ranges (like &lt;code&gt;\xHH-\xHH)&lt;/code&gt;. However, starting in Perl v5.22, regular expression pattern bracketed character class ranges specified like &lt;code&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/code&gt; are portable, and starting in Perl v5.24, the same ranges are portable in &lt;a href=&quot;perlop#tr%2FSEARCHLIST%2FREPLACEMENTLIST%2Fcdsr&quot;&gt;&lt;code&gt;tr///&lt;/code&gt;&lt;/a&gt;. You can portably use symbolic character classes like &lt;code&gt;[:print:]&lt;/code&gt;.</source>
          <target state="translated">不假定&lt;a href=&quot;perlfunc#chr-NUMBER&quot;&gt; &lt;code&gt;chr&lt;/code&gt; &lt;/a&gt;数值（&lt;a href=&quot;perlfunc#ord-EXPR&quot;&gt; &lt;code&gt;ord&lt;/code&gt; &lt;/a&gt;，chr）。不要使用显式代码点范围（例如 &lt;code&gt;\xHH-\xHH)&lt;/code&gt; 。但是，从Perl v5.22开始，指定的正则表达式模式括起来的字符类范围（例如 &lt;code&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/code&gt; 是可移植的，而从Perl v5.24开始，相同范围可在&lt;a href=&quot;perlop#tr%2FSEARCHLIST%2FREPLACEMENTLIST%2Fcdsr&quot;&gt; &lt;code&gt;tr///&lt;/code&gt; &lt;/a&gt;中移植。您可以方便地使用 &lt;code&gt;[:print:]&lt;/code&gt; 之类的符号字符类。</target>
        </trans-unit>
        <trans-unit id="900f642b83bb773e589683695c3e83ec1e64d87c" translate="yes" xml:space="preserve">
          <source>Assume nothing about numerical values (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) of characters. Do not use explicit code point ranges (like &lt;code&gt;\xHH-\xHH)&lt;/code&gt; . However, starting in Perl v5.22, regular expression pattern bracketed character class ranges specified like &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; are portable. You can portably use symbolic character classes like &lt;code&gt;[:print:]&lt;/code&gt;.</source>
          <target state="translated">不假设 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 数值（ &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; ，chr）。不要使用显式代码点范围（例如 &lt;code&gt;\xHH-\xHH)&lt;/code&gt; 。但是，从Perl v5.22开始，指定的正则表达式模式括起来的字符类范围如 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; 是可移植的。您可以方便地使用 &lt;code&gt;[:print:]&lt;/code&gt; 之类的符号字符类。</target>
        </trans-unit>
        <trans-unit id="d225542d9c39b42f29197a0ce47f62fa7382a5c0" translate="yes" xml:space="preserve">
          <source>Assume that an integer cannot take less than 20 bytes of memory, a float cannot take less than 24 bytes, a string cannot take less than 32 bytes (all these examples assume 32-bit architectures, the result are quite a bit worse on 64-bit architectures). If a variable is accessed in two of three different ways (which require an integer, a float, or a string), the memory footprint may increase yet another 20 bytes. A sloppy malloc(3) implementation can inflate these numbers dramatically.</source>
          <target state="translated">假设一个整数不能占用少于20个字节的内存,一个浮点数不能占用少于24个字节,一个字符串不能占用少于32个字节(所有这些例子都是假设32位架构,在64位架构上的结果要差不少)。如果一个变量被以三种不同的方式中的两种方式访问(需要一个整数、一个浮点数或一个字符串),内存占用可能会再增加20个字节。一个粗心的 malloc(3)实现会使这些数字急剧膨胀。</target>
        </trans-unit>
        <trans-unit id="5cf62705d74f3464ae65764bb487f8249da94d46" translate="yes" xml:space="preserve">
          <source>Assume that the old DLL is named</source>
          <target state="translated">假设旧的DLL名为</target>
        </trans-unit>
        <trans-unit id="2605c8584b04c7bf0a2b7cc3badf48edb3bf06d0" translate="yes" xml:space="preserve">
          <source>Assume that you are a seasoned porter, so are sure that all the necessary tools are already present on your system, and you know how to get the Perl source distribution. Untar it, change to the extract directory, and</source>
          <target state="translated">假设你是一个经验丰富的搬运工,所以确信所有必要的工具都已经存在于你的系统中,并且你知道如何获得Perl的源代码发行版。解除tar,换到解压目录,然后</target>
        </trans-unit>
        <trans-unit id="111d847871723c094fda67b2b5bccd84d523f158" translate="yes" xml:space="preserve">
          <source>Assume this TAP version for &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; instead of default TAP version 12.</source>
          <target state="translated">假定此TAP版本是&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt;而不是默认的TAP版本12。</target>
        </trans-unit>
        <trans-unit id="aa1c680a74a55225e27707c2ac5fffa720c70f93" translate="yes" xml:space="preserve">
          <source>Assume this TAP version for &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; instead of default TAP version 12.</source>
          <target state="translated">假定此TAP版本是&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;而不是默认的TAP版本12。</target>
        </trans-unit>
        <trans-unit id="7fc8664d84c1446907ca24dadecd0bd664e1d82d" translate="yes" xml:space="preserve">
          <source>Assume very little about character sets.</source>
          <target state="translated">对字符集的假设非常少。</target>
        </trans-unit>
        <trans-unit id="14aa653264a55e7f75e0cffdf8147628d06e0a12" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;PL_op&lt;/code&gt; is the OP that originally triggered the error, and that &lt;code&gt;PL_comppad&lt;/code&gt;/&lt;code&gt;PL_curpad&lt;/code&gt; points to the currently executing pad.</source>
          <target state="translated">假定 &lt;code&gt;PL_op&lt;/code&gt; 是最初触发该错误的OP，并且 &lt;code&gt;PL_comppad&lt;/code&gt; / &lt;code&gt;PL_curpad&lt;/code&gt; 指向当前正在执行的pad。</target>
        </trans-unit>
        <trans-unit id="2b3c42e666c3f46061cf3e08ae5f736db9c6b58e" translate="yes" xml:space="preserve">
          <source>Assumes that PL_op is the op that originally triggered the error, and that PL_comppad/PL_curpad points to the currently executing pad.</source>
          <target state="translated">假设PL_op是最初触发错误的op,并且PL_comppad/PL_curpad指向当前执行的pad。</target>
        </trans-unit>
        <trans-unit id="40680f85edea3366c2b9e8f14183ac57a5e6081e" translate="yes" xml:space="preserve">
          <source>Assuming NOT a POSIX class since %s in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">假设自regex中的％s起，则不是POSIX类；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="85a92465c7801a7593ae125acb124d7a78d00d62" translate="yes" xml:space="preserve">
          <source>Assuming one can dereference any type of pointer for any type of data</source>
          <target state="translated">假设可以为任何类型的数据派生出任何类型的指针。</target>
        </trans-unit>
        <trans-unit id="3eba801518ac20c3e71b66588e69e8412d142226" translate="yes" xml:space="preserve">
          <source>Assuming sizeof(int) == sizeof(long)</source>
          <target state="translated">假设 sizeof(int)==sizeof(long)</target>
        </trans-unit>
        <trans-unit id="3b4336515b2aaf87ea7abdf5569d5fbbc17ae08d" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;man&lt;/code&gt; -files were put on an appropriate location, this completes the installation of minimal Perl system. (The binary distribution contains also a lot of additional modules, and the documentation in INF format.)</source>
          <target state="translated">假定将 &lt;code&gt;man&lt;/code&gt; 文件放在适当的位置，这将完成最小Perl系统的安装。（二进制发行版还包含许多其他模块，以及INF格式的文档。）</target>
        </trans-unit>
        <trans-unit id="d729092ca24191c5dd2dddf6e45eb913d7433329" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;man&lt;/code&gt;-files were put on an appropriate location, this completes the installation of minimal Perl system. (The binary distribution contains also a lot of additional modules, and the documentation in INF format.)</source>
          <target state="translated">假定将 &lt;code&gt;man&lt;/code&gt; 文件放在适当的位置，这将完成最小Perl系统的安装。（二进制发行版还包含许多其他模块，以及INF格式的文档。）</target>
        </trans-unit>
        <trans-unit id="1b3d48dcc2393b6165f22e974c8fe37cb11cfa92" translate="yes" xml:space="preserve">
          <source>Assuming that we have to match calendar dates which may be given in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three suitable patterns where we use 'd', 'm' and 'y' respectively as the names of the groups capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</source>
          <target state="translated">假设我们必须匹配可能以yyy-mm-dd、mm/dd/yyyy或dd.mm.yyyy三种格式之一给出的日历日期,我们可以写出三种合适的模式,分别使用'd'、'm'和'y'作为捕获日期相关组件的组名。匹配操作将这三种模式结合起来作为备选方案。</target>
        </trans-unit>
        <trans-unit id="391cee4ecd3812f9caf92f329d5fa158ab37c5f3" translate="yes" xml:space="preserve">
          <source>Assuming that we have to match calendar dates which may be given in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three suitable patterns where we use &lt;code&gt;'d'&lt;/code&gt;, &lt;code&gt;'m'&lt;/code&gt; and &lt;code&gt;'y'&lt;/code&gt; respectively as the names of the groups capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</source>
          <target state="translated">假设我们必须匹配可能以yyyy-mm-dd，mm / dd / yyyy或dd.mm.yyyy三种格式之一给出的日历日期，我们可以在使用 &lt;code&gt;'d'&lt;/code&gt; ， &lt;code&gt;'m'&lt;/code&gt; 和 &lt;code&gt;'y'&lt;/code&gt; 分别作为捕获日期相关组成部分的组的名称。匹配操作将三种模式结合在一起作为替代：</target>
        </trans-unit>
        <trans-unit id="31fc34e986ee3355963fe79a5b72db07365ea4e2" translate="yes" xml:space="preserve">
          <source>Assuming that you don't care about IEEE notations like &quot;NaN&quot; or &quot;Infinity&quot;, you probably just want to use a regular expression (see also &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;):</source>
          <target state="translated">假设您不关心&amp;ldquo; NaN&amp;rdquo;或&amp;ldquo; Infinity&amp;rdquo;之类的IEEE表示法，则可能只想使用正则表达式（另请参见&lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;和&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="0518d034f096809ab863fb80241126fe45a3c2bb" translate="yes" xml:space="preserve">
          <source>Assuming that you don't care about IEEE notations like &quot;NaN&quot; or &quot;Infinity&quot;, you probably just want to use a regular expression:</source>
          <target state="translated">假设你不关心 &quot;NaN &quot;或 &quot;Infinity &quot;这样的IEEE符号,你可能只想使用一个正则表达式。</target>
        </trans-unit>
        <trans-unit id="c5c2ab31ddb2d4e68552f61633bf186e98613579" translate="yes" xml:space="preserve">
          <source>Assuming the character set is ASCIIish</source>
          <target state="translated">假设字符集是ASCII码</target>
        </trans-unit>
        <trans-unit id="657e33b27d387873c824a6e9282e0d4e22ed782e" translate="yes" xml:space="preserve">
          <source>Assuming the character set is just ASCII</source>
          <target state="translated">假设字符集只是ASCII码</target>
        </trans-unit>
        <trans-unit id="f18b4264a48b77c77d31682d53d915137b1c2a2b" translate="yes" xml:space="preserve">
          <source>Assuming the contents of static memory pointed to by the return values of Perl wrappers for C library functions doesn't change. Many C library functions return pointers to static storage that can be overwritten by subsequent calls to the same or related functions. Perl has light-weight wrappers for some of these functions, and which don't make copies of the static memory. A good example is the interface to the environment variables that are in effect for the program. Perl has &lt;code&gt;PerlEnv_getenv&lt;/code&gt; to get values from the environment. But the return is a pointer to static memory in the C library. If you are using the value to immediately test for something, that's fine, but if you save the value and expect it to be unchanged by later processing, you would be wrong, but perhaps you wouldn't know it because different C library implementations behave differently, and the one on the platform you're testing on might work for your situation. But on some platforms, a subsequent call to &lt;code&gt;PerlEnv_getenv&lt;/code&gt; or related function WILL overwrite the memory that your first call points to. This has led to some hard-to-debug problems. Do a &lt;a href=&quot;perlapi#savepv&quot;&gt;&quot;savepv&quot; in perlapi&lt;/a&gt; to make a copy, thus avoiding these problems. You will have to free the copy when you're done to avoid memory leaks. If you don't have control over when it gets freed, you'll need to make the copy in a mortal scalar, like so:</source>
          <target state="translated">假定由Perl包装器的C库函数的返回值指向的静态内存的内容不变。许多C库函数将指针返回到静态存储，这些指针可以被后续对相同或相关函数的调用所覆盖。Perl具有一些此类功能的轻量级包装器，并且不会复制静态内存。一个很好的例子是对程序有效的环境变量的接口。Perl有 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; 从环境中获取价值。但是返回的是指向C库中静态内存的指针。如果您使用该值立即测试某些东西，那很好，但是如果您保存该值并期望它在以后的处理中保持不变，那将是错误的，但也许您不会知道，因为不同的C库实现会表现出不同的行为与此不同，您正在测试的平台上的那个可能会适合您的情况。但是在某些平台上，随后对 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; 或相关函数的调用将覆盖您的第一个调用所指向的内存。这导致了一些难以调试的问题。&lt;a href=&quot;perlapi#savepv&quot;&gt;在perlapi中&lt;/a&gt;做一个&amp;ldquo; savepv&amp;rdquo;进行复制，从而避免了这些问题。完成操作后，您将必须释放副本，以避免内存泄漏。如果您无法控制何时释放它，则需要使用凡人的标量制作该副本，如下所示：</target>
        </trans-unit>
        <trans-unit id="7e0c2159a115b592c79f24b1d84f43c005948de3" translate="yes" xml:space="preserve">
          <source>Assuming the contents of static memory pointed to by the return values of Perl wrappers for C library functions doesn't change. Many C library functions return pointers to static storage that can be overwritten by subsequent calls to the same or related functions. Perl has light-weight wrappers for some of these functions, and which don't make copies of the static memory. A good example is the interface to the environment variables that are in effect for the program. Perl has &lt;code&gt;PerlEnv_getenv&lt;/code&gt; to get values from the environment. But the return is a pointer to static memory in the C library. If you are using the value to immediately test for something, that's fine, but if you save the value and expect it to be unchanged by later processing, you would be wrong, but perhaps you wouldn't know it because different C library implementations behave differently, and the one on the platform you're testing on might work for your situation. But on some platforms, a subsequent call to &lt;code&gt;PerlEnv_getenv&lt;/code&gt; or related function WILL overwrite the memory that your first call points to. This has led to some hard-to-debug problems. Do a &lt;a href=&quot;perlapi#savepv&quot;&gt;savepv in perlapi&lt;/a&gt; to make a copy, thus avoiding these problems. You will have to free the copy when you're done to avoid memory leaks. If you don't have control over when it gets freed, you'll need to make the copy in a mortal scalar, like so:</source>
          <target state="translated">假定由Perl包装器的C库函数的返回值指向的静态内存的内容不变。许多C库函数将指针返回到静态存储，该指针可被后续对相同或相关函数的调用所覆盖。 Perl具有一些这类功能的轻量级包装器，并且不会复制静态内存。一个很好的例子是对程序有效的环境变量的接口。 Perl有 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; 从环境中获取价值。但是返回的是指向C库中静态内存的指针。如果您使用该值立即测试某些东西，那很好，但是如果您保存该值并期望它在以后的处理中保持不变，那将是错误的，但也许您不会知道，因为不同的C库实现会表现出来与此不同，您正在测试的平台上的那个可能会适合您的情况。但是在某些平台上，随后对 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; 或相关函数的调用将覆盖您的第一个调用所指向的内存。这导致了一些难以调试的问题。&lt;a href=&quot;perlapi#savepv&quot;&gt;在Perlapi中&lt;/a&gt;做一个savepv进行复制，从而避免了这些问题。完成操作后，您将必须释放副本以避免内存泄漏。如果您无法控制何时释放它，则需要使用凡人的标量制作该副本，如下所示：</target>
        </trans-unit>
        <trans-unit id="3368b5431ec704ea21f8185fe92770b3b042af71" translate="yes" xml:space="preserve">
          <source>Assuming the database from the previous example:</source>
          <target state="translated">假设是上一例的数据库。</target>
        </trans-unit>
        <trans-unit id="37f2465394b9cbdd91947c6e4e077a7d4b7dde8a" translate="yes" xml:space="preserve">
          <source>Assuming they are to behave analogously to Perl's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; , overloaded implementations of these operators are required to mutate their operands.</source>
          <target state="translated">假设它们的行为类似于Perl的 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; ，则需要对这些运算符的重载实现进行突变。</target>
        </trans-unit>
        <trans-unit id="3db726b30f88089aabcbf03ff0837b3e46de1fc1" translate="yes" xml:space="preserve">
          <source>Assuming they are to behave analogously to Perl's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, overloaded implementations of these operators are required to mutate their operands.</source>
          <target state="translated">假设它们的行为类似于Perl的 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; ，则需要对这些运算符的重载实现进行突变。</target>
        </trans-unit>
        <trans-unit id="6c0a71c399dfe91f864d3abd9d93805888be04d4" translate="yes" xml:space="preserve">
          <source>Assuming we are on the branch &lt;code&gt;blead&lt;/code&gt; immediately after a pull, this command would be more or less equivalent to:</source>
          <target state="translated">假设我们在拉动之后立即处于分支 &lt;code&gt;blead&lt;/code&gt; 上，此命令将大致等同于：</target>
        </trans-unit>
        <trans-unit id="23383c34471c75b25927cfad7162ad1979bea49b" translate="yes" xml:space="preserve">
          <source>Assuming you call your class Projname::L10N, create a class consisting minimally of:</source>
          <target state="translated">假设你调用你的类Projname::L10N,创建一个类,最小包括:。</target>
        </trans-unit>
        <trans-unit id="a8c3ccec4be1ea177d36a955790696ae747518f7" translate="yes" xml:space="preserve">
          <source>Assuming you have good test coverage, your tests should fail with missing dependencies informing the user more strongly that something is wrong. You can write a</source>
          <target state="translated">假设你有很好的测试覆盖率,你的测试应该会失败,因为缺失的依赖关系会更强烈地告知用户有问题。你可以写一个</target>
        </trans-unit>
        <trans-unit id="562091b17215c5d2dabd5a6d27106f5a063623cd" translate="yes" xml:space="preserve">
          <source>Assuming you know you're dealing with a UTF-8 string, you can find out how long the first character in it is with the &lt;code&gt;UTF8SKIP&lt;/code&gt; macro:</source>
          <target state="translated">假设您知道要处理的是UTF-8字符串，则可以使用 &lt;code&gt;UTF8SKIP&lt;/code&gt; 宏找出其中的第一个字符多长时间：</target>
        </trans-unit>
        <trans-unit id="9da798a9d5da7f2f9d9ef9e1b52ebf21c8c17dc7" translate="yes" xml:space="preserve">
          <source>Assuming you're running under sufficient permissions, you should be able to set the system-wide date and time by running the &lt;code&gt;date(1)&lt;/code&gt; program. (There is no way to set the time and date on a per-process basis.) This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">假设您在足够的权限下运行，则应该能够通过运行 &lt;code&gt;date(1)&lt;/code&gt; 程序来设置系统范围的日期和时间。（无法在每个进程的基础上设置时间和日期。）该机制适用于Unix，MS-DOS，Windows和NT。VMS等效 &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 是设置时间。</target>
        </trans-unit>
        <trans-unit id="02ec0a4ff8284bf3708641e3963c674ad5d28a0e" translate="yes" xml:space="preserve">
          <source>Assuming you're running under sufficient permissions, you should be able to set the system-wide date and time by running the &lt;code&gt;date(1)&lt;/code&gt; program. (There is no way to set the time and date on a per-process basis.) This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is &lt;code&gt;set time&lt;/code&gt;.</source>
          <target state="translated">假设您在足够的权限下运行，则应该能够通过运行 &lt;code&gt;date(1)&lt;/code&gt; 程序来设置系统范围的日期和时间。（无法在每个进程的基础上设置时间和日期。）该机制适用于Unix，MS-DOS，Windows和NT。VMS等效 &lt;code&gt;set time&lt;/code&gt; 是设置时间。</target>
        </trans-unit>
        <trans-unit id="a50f834fa5c7b73ada293aca740d6156afc09752" translate="yes" xml:space="preserve">
          <source>Assuming your system supports such things, just send an appropriate signal to the process (see &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;). It's common to first send a TERM signal, wait a little bit, and then send a KILL signal to finish it off.</source>
          <target state="translated">假设您的系统支持这些功能，只需向进程发送适当的信号即可（请参见&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;）。通常先发送一个TERM信号，稍等片刻，然后发送一个KILL信号来完成它。</target>
        </trans-unit>
        <trans-unit id="a095cda27752254d76d70e270420e5ff5d39b90c" translate="yes" xml:space="preserve">
          <source>Assuming your system supports such things, just send an appropriate signal to the process (see &lt;a href=&quot;perlfunc#kill&quot;&gt;&quot;kill&quot; in perlfunc&lt;/a&gt;). It's common to first send a TERM signal, wait a little bit, and then send a KILL signal to finish it off.</source>
          <target state="translated">假设您的系统支持这些功能，只需向进程发送适当的信号即可（请参阅&lt;a href=&quot;perlfunc#kill&quot;&gt;perlfunc中的&amp;ldquo; kill&amp;rdquo;&lt;/a&gt;）。通常先发送一个TERM信号，稍等片刻，然后发送一个KILL信号将其结束。</target>
        </trans-unit>
        <trans-unit id="489e70109e67cf9da0e282567e7dfa75ecfec0d5" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O.</source>
          <target state="translated">异步I/O。</target>
        </trans-unit>
        <trans-unit id="a34c6deba477e26d8810a3f5cd4114d33aa1e300" translate="yes" xml:space="preserve">
          <source>At 10:23, this function generates the 10th line of a data file; at 3:45 PM it generates the 15th line instead. By default, &lt;code&gt;Memoize&lt;/code&gt; will only see the $problem_type argument. To fix this, include the current hour in the normalizer:</source>
          <target state="translated">在10:23，此函数生成数据文件的第10行。在下午3:45，它将生成第15行。默认情况下， &lt;code&gt;Memoize&lt;/code&gt; 将仅看到$ problem_type参数。要解决此问题，请在规范化器中包括当前时间：</target>
        </trans-unit>
        <trans-unit id="0d3035d43f34a8f68a2af535ff4afe837cc1bf23" translate="yes" xml:space="preserve">
          <source>At a given character position, the first alternative that allows the regex match to succeed will be the one that matches. Here, all the alternatives match at the first string position, so the first matches.</source>
          <target state="translated">在给定的字符位置上,第一个让 regex 匹配成功的选项将是匹配的选项。在这里,所有的选项都在第一个字符串位置匹配,所以第一个匹配。</target>
        </trans-unit>
        <trans-unit id="35d56b3c766a2a7d81a6ef179791e69c5926ffe4" translate="yes" xml:space="preserve">
          <source>At any given time, exactly one of these modifiers is in effect. Their existence allows Perl to keep the originally compiled behavior of a regular expression, regardless of what rules are in effect when it is actually executed. And if it is interpolated into a larger regex, the original's rules continue to apply to it, and don't affect the other parts.</source>
          <target state="translated">在任何时候,这些修饰符中只有一个是有效的。它们的存在使得Perl能够保持正则表达式最初的编译行为,而不管实际执行时是什么规则在起作用。而如果它被内插到一个更大的 regex 中,原来的规则会继续适用于它,而不会影响其他部分。</target>
        </trans-unit>
        <trans-unit id="fa1efd2d4349c6ea79b9b9fc2089c111f8b1ca40" translate="yes" xml:space="preserve">
          <source>At any given time, exactly one of these modifiers is in effect. Their existence allows Perl to keep the originally compiled behavior of a regular expression, regardless of what rules are in effect when it is actually executed. And if it is interpolated into a larger regex, the original's rules continue to apply to it, and only it.</source>
          <target state="translated">在任何时候,这些修饰符中只有一个是有效的。它们的存在使得 Perl 能够保持正则表达式最初的编译行为,而不管实际执行时是什么规则在起作用。如果它被插值到一个更大的 regex 中,原始规则将继续适用于它,而且只适用于它。</target>
        </trans-unit>
        <trans-unit id="7593f9fb00e51f006212d276b2834d5cb1e7bd4c" translate="yes" xml:space="preserve">
          <source>At any rate, the very use of &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</source>
          <target state="translated">无论如何，对于Unicode字符， &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 使用非常成问题，因为您必须考虑字符宽度（即表意文字为双倍宽度）和方向（即BIDI对于阿拉伯语和希伯来语）。</target>
        </trans-unit>
        <trans-unit id="b3d5fa45c550ce1b12a041713732b9ad3afd79b2" translate="yes" xml:space="preserve">
          <source>At any rate, the very use of &lt;code&gt;format&lt;/code&gt; is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</source>
          <target state="translated">无论如何，在使用Unicode字符时， &lt;code&gt;format&lt;/code&gt; 使用非常成问题，因为必须考虑字符宽度（即表意文字为双倍宽度）和方向（即阿拉伯语和希伯来语为BIDI）之类的问题。</target>
        </trans-unit>
        <trans-unit id="40530b4cf9ab5b3f6391788f6f588ae031f72498" translate="yes" xml:space="preserve">
          <source>At deserialization time, you will be given back the same LIST, but all the extra references will be pointing into the deserialized structure.</source>
          <target state="translated">在反序列化的时候,你会得到同样的LIST,但所有额外的引用都会指向反序列化的结构。</target>
        </trans-unit>
        <trans-unit id="2359fa76d13a340de35eda7f896e38293fc5d5aa" translate="yes" xml:space="preserve">
          <source>At each stack level, the subroutine's name is displayed along with its parameters. For simple scalars, this is sufficient. For complex data types, such as objects and other references, this can simply display &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; .</source>
          <target state="translated">在每个堆栈级别，子例程的名称及其参数都会显示出来。对于简单的标量，这就足够了。对于复杂的数据类型，例如对象和其他引用，这可以简单地显示 &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3499c5b318f8c7ae1f2cab230c6e5e96c7a777c" translate="yes" xml:space="preserve">
          <source>At each stack level, the subroutine's name is displayed along with its parameters. For simple scalars, this is sufficient. For complex data types, such as objects and other references, this can simply display &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt;.</source>
          <target state="translated">在每个堆栈级别，子例程的名称及其参数都会显示出来。对于简单的标量，这就足够了。对于复杂的数据类型，例如对象和其他引用，这可以简单地显示 &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="396433f01b9bc30bd1dc987a608f2db8a7b54ded" translate="yes" xml:space="preserve">
          <source>At entry points to perl, such as &lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; and &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; each does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; , then enter a runops loop or whatever, and handle possible exception returns. For a 2 return, final cleanup is performed, such as popping stacks and calling &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; blocks. Amongst other things, this is how scope cleanup still occurs during an &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在perl的入口点，例如 &lt;code&gt;perl_parse()&lt;/code&gt; ， &lt;code&gt;perl_run()&lt;/code&gt; 和 &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; 各自执行 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; ，然后进入runops循环或其他操作，并处理可能的异常返回。对于2返回，将执行最终清除，例如弹出堆栈并调用 &lt;code&gt;CHECK&lt;/code&gt; 或 &lt;code&gt;END&lt;/code&gt; 块。除其他事项外，这就是在 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 期间仍然进行范围清理的方式。</target>
        </trans-unit>
        <trans-unit id="2c5843723152f1754465e406a2b90b574561ffc4" translate="yes" xml:space="preserve">
          <source>At entry points to perl, such as &lt;code&gt;perl_parse()&lt;/code&gt;, &lt;code&gt;perl_run()&lt;/code&gt; and &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; each does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt;, then enter a runops loop or whatever, and handle possible exception returns. For a 2 return, final cleanup is performed, such as popping stacks and calling &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; blocks. Amongst other things, this is how scope cleanup still occurs during an &lt;code&gt;exit&lt;/code&gt;.</source>
          <target state="translated">在perl的入口点，例如 &lt;code&gt;perl_parse()&lt;/code&gt; ， &lt;code&gt;perl_run()&lt;/code&gt; 和 &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; 都执行 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; ，然后进入runops循环或其他操作，并处理可能的异常返回。对于2返回，将执行最终清除，例如弹出堆栈并调用 &lt;code&gt;CHECK&lt;/code&gt; 或 &lt;code&gt;END&lt;/code&gt; 块。除其他事项外，这就是在 &lt;code&gt;exit&lt;/code&gt; 过程中仍然发生作用域清理的方式。</target>
        </trans-unit>
        <trans-unit id="3b52a6611c3d532a492a587178e19cf7d8fea481" translate="yes" xml:space="preserve">
          <source>At first glance, you'd think that it shouldn't print, because obviously the &lt;code&gt;ddd&lt;/code&gt; isn't going to match the target string. But look at this example:</source>
          <target state="translated">乍一看，您会认为它不应该打印，因为显然 &lt;code&gt;ddd&lt;/code&gt; 不会与目标字符串匹配。但是看这个例子：</target>
        </trans-unit>
        <trans-unit id="a20d2e5d0ab73a1c97b3463749bc6385228a9028" translate="yes" xml:space="preserve">
          <source>At least for consistency with WinNT, you should keep the recommended value.</source>
          <target state="translated">至少为了与WinNT保持一致,你应该保持推荐值。</target>
        </trans-unit>
        <trans-unit id="27bd45d9389cf551091228f338420922ea6613d9" translate="yes" xml:space="preserve">
          <source>At least in Unix you may be able to get past this by increasing your process datasize limits: in csh/tcsh use &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;limit datasize n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is the number of kilobytes) to check the current limits and change them, and in ksh/bash/zsh use &lt;code&gt;ulimit -a&lt;/code&gt; and &lt;code&gt;ulimit -d n&lt;/code&gt; , respectively.</source>
          <target state="translated">至少在Unix中，您可以通过增加进程数据大小限制来解决此问题：在csh / tcsh中，使用 &lt;code&gt;limit&lt;/code&gt; 和 &lt;code&gt;limit datasize n&lt;/code&gt; （其中 &lt;code&gt;n&lt;/code&gt; 是千字节数）来检查当前限制并更改它们，在ksh中/ bash / zsh分别使用 &lt;code&gt;ulimit -a&lt;/code&gt; 和 &lt;code&gt;ulimit -d n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66f7b8a4f3dad67cd26cb07eaab73c32a3b79d31" translate="yes" xml:space="preserve">
          <source>At least in Unix you may be able to get past this by increasing your process datasize limits: in csh/tcsh use &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;limit datasize n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is the number of kilobytes) to check the current limits and change them, and in ksh/bash/zsh use &lt;code&gt;ulimit -a&lt;/code&gt; and &lt;code&gt;ulimit -d n&lt;/code&gt;, respectively.</source>
          <target state="translated">至少在Unix中，您可以通过增加进程数据大小限制来解决此问题：在csh / tcsh中，使用 &lt;code&gt;limit&lt;/code&gt; 和 &lt;code&gt;limit datasize n&lt;/code&gt; （其中 &lt;code&gt;n&lt;/code&gt; 是千字节数）来检查当前限制并更改它们，在ksh中/ bash / zsh分别使用 &lt;code&gt;ulimit -a&lt;/code&gt; 和 &lt;code&gt;ulimit -d n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be275e2a07874324b642ea6224748e1cc7c92b91" translate="yes" xml:space="preserve">
          <source>At least it's backwards compatible in not doing much.</source>
          <target state="translated">至少在不做什么事的情况下,它是向后兼容的。</target>
        </trans-unit>
        <trans-unit id="9e14e0bb06602e8d806ecd5603df3d1331d55d06" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; must have a goal (at least one of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; must be non-zero), and if both do, both have to be reached for a successful match. Also, if the fold of a character is multiple characters, all of them must be matched (see tr21 reference below for 'folding').</source>
          <target state="translated">&lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 中的至少一个必须有一个目标（ &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt; 中的至少一个必须为非零），并且如果两者均存在，则必须同时达到一个目标才能成功进行比赛。同样，如果一个字符的折痕是多个字符，则所有字符都必须匹配（有关折叠的信息，请参见下面的tr21参考）。</target>
        </trans-unit>
        <trans-unit id="9972c1cfc00f54bc3d4bf6854c0d9453527f2493" translate="yes" xml:space="preserve">
          <source>At least the three builtin functions &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt;. We might someday add more of these later if we think of them.</source>
          <target state="translated">至少三个内建函数 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt; ，以及 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt; 。如果我们想到它们，有一天我们可能会在以后添加更多。</target>
        </trans-unit>
        <trans-unit id="36309277752b244d6584b5ffd8f2594deef16e94" translate="yes" xml:space="preserve">
          <source>At least the three builtin functions &lt;code&gt;defined(...)&lt;/code&gt;, &lt;code&gt;exists(...)&lt;/code&gt;, and &lt;code&gt;eof(...)&lt;/code&gt;. We might someday add more of these later if we think of them.</source>
          <target state="translated">至少三个内建函数 &lt;code&gt;defined(...)&lt;/code&gt; ， &lt;code&gt;exists(...)&lt;/code&gt; ，以及 &lt;code&gt;eof(...)&lt;/code&gt; 。如果我们想到它们，有一天我们可能会在以后添加更多。</target>
        </trans-unit>
        <trans-unit id="dc8bf4c3c86adf3ceb8a466491ba399fbc2b4c86" translate="yes" xml:space="preserve">
          <source>At line number 4 is a helpful pointer, that tells you where you are now. To see more code, type 'v' again:</source>
          <target state="translated">在第4行是一个有用的指针,它告诉你现在你在哪里。要查看更多的代码,再次输入'v'。</target>
        </trans-unit>
        <trans-unit id="0f8b916c14aa42230cca14b7fbe9aee5db398694" translate="yes" xml:space="preserve">
          <source>At one time, it was legal in some standards to have code points up to 0x7FFF_FFFF, but not higher, and this code point is higher.</source>
          <target state="translated">曾经,在一些标准中,码点最高为0x7FFF_FFFF是合法的,但不是更高,这个码点是更高的。</target>
        </trans-unit>
        <trans-unit id="3706bce960e08579e2a93b26085ef7458b3bba0d" translate="yes" xml:space="preserve">
          <source>At present that list is: weaken, isweak, dualvar, isvstring, set_prototype</source>
          <target state="translated">目前这个列表是:weaken,isweak,dualvar,isvstring,set_prototype。</target>
        </trans-unit>
        <trans-unit id="945b483b1ccbe65e925900ec39e83bbc97a9ab8a" translate="yes" xml:space="preserve">
          <source>At present the following compression methods are supported by IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and LZMA.</source>
          <target state="translated">目前IO::Compress::Zip支持的压缩方法有以下几种,分别是Store(完全不压缩)、Deflate、Bzip2和LZMA。</target>
        </trans-unit>
        <trans-unit id="a9a7ccc891020b1abe97ef7e238b5077a99ae99b" translate="yes" xml:space="preserve">
          <source>At present three compression methods are supported by IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and LZMA.</source>
          <target state="translated">目前IO::Compress::Zip支持三种压缩方式,分别是Store(完全不压缩)、Deflate、Bzip2和LZMA。</target>
        </trans-unit>
        <trans-unit id="c6f3b56326d807044d12f7fa90b19c7ea2469f7b" translate="yes" xml:space="preserve">
          <source>At present, the first time you iterate over %ENV using &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, you will incur a time penalty as all logical names are read, in order to fully populate %ENV. Subsequent iterations will not reread logical names, so they won't be as slow, but they also won't reflect any changes to logical name tables caused by other programs.</source>
          <target state="translated">目前，第一次使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 遍历％ENV 时，由于要完全填充％ENV会读取所有逻辑名称，因此会产生时间损失。随后的迭代将不会重新读取逻辑名，因此它们不会那么慢，但是它们也不会反映其他程序对逻辑名表的任何更改。</target>
        </trans-unit>
        <trans-unit id="214ce8ba80d0a179d1db87f227b4915a835aed62" translate="yes" xml:space="preserve">
          <source>At present, the first time you iterate over %ENV using &lt;code&gt;keys&lt;/code&gt;, or &lt;code&gt;values&lt;/code&gt;, you will incur a time penalty as all logical names are read, in order to fully populate %ENV. Subsequent iterations will not reread logical names, so they won't be as slow, but they also won't reflect any changes to logical name tables caused by other programs.</source>
          <target state="translated">目前，第一次使用 &lt;code&gt;keys&lt;/code&gt; 或 &lt;code&gt;values&lt;/code&gt; 遍历％ENV时，将读取所有逻辑名，这会产生时间损失，以便完全填充％ENV。随后的迭代将不会重新读取逻辑名，因此它们不会那么慢，但是它们也不会反映其他程序对逻辑名表的任何更改。</target>
        </trans-unit>
        <trans-unit id="25d8707372413087d65e69b61d9a6dc703b71cf2" translate="yes" xml:space="preserve">
          <source>At run time, each listed plugin is instantiated as a singleton object by running the equivalent of this pseudo code:</source>
          <target state="translated">在运行时,每一个列出的插件都会被实例化为一个单人对象,运行相当于这个伪代码。</target>
        </trans-unit>
        <trans-unit id="0346a8b0d676351a6882db32e2f71fe2cd6612af" translate="yes" xml:space="preserve">
          <source>At run-time you can use:</source>
          <target state="translated">在运行时,你可以使用。</target>
        </trans-unit>
        <trans-unit id="14c311a97bb302da658b5d5c146d94913481c6a7" translate="yes" xml:space="preserve">
          <source>At some moment the built may die, reporting a</source>
          <target state="translated">在某个时刻,建成可能会死掉,报告一个</target>
        </trans-unit>
        <trans-unit id="fdde3eae592d85a1bbf81dc1dcb5f03f478df9d3" translate="yes" xml:space="preserve">
          <source>At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agreed to use the CPAN Meta format to communicate post-configuration requirements between toolchain components. These files,</source>
          <target state="translated">在2008年奥斯陆的QA Hackathon上,Perl模块工具链的维护者们同意使用CPAN Meta格式来沟通工具链组件之间的配置后需求。这些文件。</target>
        </trans-unit>
        <trans-unit id="8f94eca0c2d56d19683ad85c3b3f54fed0ab0893" translate="yes" xml:space="preserve">
          <source>At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agrees to use the CPAN Meta format to communicate post-configuration requirements between toolchain components. These files,</source>
          <target state="translated">在2008年奥斯陆的QA Hackathon上,Perl模块工具链的维护者同意使用CPAN Meta格式来沟通工具链组件之间的配置后需求。这些文件。</target>
        </trans-unit>
        <trans-unit id="86950d72bad1114392fd499fea36a75e7faf16d6" translate="yes" xml:space="preserve">
          <source>At the cost of a slight header overhead, you may store to an already opened file descriptor using the &lt;code&gt;store_fd&lt;/code&gt; routine, and retrieve from a file via &lt;code&gt;fd_retrieve&lt;/code&gt; . Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</source>
          <target state="translated">您可能会花费一些头开销，但可以使用 &lt;code&gt;store_fd&lt;/code&gt; 例程将其存储到已打开的文件描述符中，然后通过 &lt;code&gt;fd_retrieve&lt;/code&gt; 从文件中检索。这些名称默认情况下不会被导入，因此如果需要这些例程，则必须明确地执行此操作。您提供的文件描述符必须已经打开，如果要检索则要读取，如果要存储则要写入。</target>
        </trans-unit>
        <trans-unit id="e5ffbd456858663ac301bf7789eac1b059f62c98" translate="yes" xml:space="preserve">
          <source>At the cost of a slight header overhead, you may store to an already opened file descriptor using the &lt;code&gt;store_fd&lt;/code&gt; routine, and retrieve from a file via &lt;code&gt;fd_retrieve&lt;/code&gt;. Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</source>
          <target state="translated">您可能会花费一些头开销，但可以使用 &lt;code&gt;store_fd&lt;/code&gt; 例程将其存储到已打开的文件描述符中，然后通过 &lt;code&gt;fd_retrieve&lt;/code&gt; 从文件中检索。这些名称默认情况下不会导入，因此如果需要这些例程，则必须明确地执行此操作。您提供的文件描述符必须已经打开，如果要检索则要读取，如果要存储则要写入。</target>
        </trans-unit>
        <trans-unit id="5655f269f9dae667811a30ef2f8f926fc9530ad6" translate="yes" xml:space="preserve">
          <source>At the end of</source>
          <target state="translated">在结束时</target>
        </trans-unit>
        <trans-unit id="9572ac86c1b1da5c7ab83dd35ce00912ee7e613d" translate="yes" xml:space="preserve">
          <source>At the end of all &lt;code&gt;when&lt;/code&gt; blocks, there is an implicit &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;. You can override that with an explicit &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; if you're interested in only the first match alone.</source>
          <target state="translated">在所有 &lt;code&gt;when&lt;/code&gt; 块的末尾，都有一个隐式的 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 。如果您仅对第一个比赛感兴趣，则可以用明确的 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 一个覆盖。</target>
        </trans-unit>
        <trans-unit id="1e41ae8e63f613457fbc688a05901eda0e76d2fb" translate="yes" xml:space="preserve">
          <source>At the end of all &lt;code&gt;when&lt;/code&gt; blocks, there is an implicit &lt;code&gt;next&lt;/code&gt;. You can override that with an explicit &lt;code&gt;last&lt;/code&gt; if you're interested in only the first match alone.</source>
          <target state="translated">在所有 &lt;code&gt;when&lt;/code&gt; 块的末尾，都有一个隐式的 &lt;code&gt;next&lt;/code&gt; 。如果您仅对第一个比赛感兴趣，则可以用明确的 &lt;code&gt;last&lt;/code&gt; 一个覆盖。</target>
        </trans-unit>
        <trans-unit id="ca6a702d6cdcdadecdbaeb43444eca515cc146c7" translate="yes" xml:space="preserve">
          <source>At the end of the parse, call &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; to get the tree's top node.</source>
          <target state="translated">在解析结束时，调用 &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; 以获取树的顶部节点。</target>
        </trans-unit>
        <trans-unit id="7dfefef1d68ca5b408b29dae9e3fff68c7b274a2" translate="yes" xml:space="preserve">
          <source>At the end of the subtest, the final &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2::Event::Subtest&lt;/a&gt; event is sent to the formatter.</source>
          <target state="translated">在子测试的末尾，最终的&lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2 :: Event :: Subtest&lt;/a&gt;事件被发送到格式化程序。</target>
        </trans-unit>
        <trans-unit id="07a9cc69765068861817ec41e4a7228bd113195b" translate="yes" xml:space="preserve">
          <source>At the lowest level, the macros new_SV() and del_SV() grab and free an SV head. (If debugging with -DD, del_SV() calls the function S_del_sv() to return the SV to the free list with error checking.) new_SV() calls more_sv() / sv_add_arena() to add an extra arena if the free list is empty. SVs in the free list have their SvTYPE field set to all ones.</source>
          <target state="translated">在最底层,宏new_SV()和del_SV()抓取并释放一个SV头。(如果使用-DD调试,del_SV()调用函数S_del_sv()将SV返回到空闲列表并进行错误检查。)new_SV()调用more_sv()/sv_add_arena()在空闲列表中增加一个额外的竞技场。空闲列表中的SV的SvTYPE字段被设置为所有的。</target>
        </trans-unit>
        <trans-unit id="6089cbc08fb43732445842a261366b161cee7872" translate="yes" xml:space="preserve">
          <source>At the moment of writing, AIX supports two different native C compilers, for which you have to pay: &lt;b&gt;xlC&lt;/b&gt; and &lt;b&gt;vac&lt;/b&gt;. If you decide to use either of these two (which is quite a lot easier than using gcc), be sure to upgrade to the latest available patch level. Currently:</source>
          <target state="translated">在撰写本文时，AIX支持两种不同的本机C编译器，您必须付费：&lt;b&gt;xlC&lt;/b&gt;和&lt;b&gt;vac&lt;/b&gt;。如果您决定使用这两种方法中的一种（比使用gcc容易得多），请确保升级到最新的可用补丁程序级别。目前：</target>
        </trans-unit>
        <trans-unit id="af7b9b33fafaf83f9420acb89bb16618e9123d52" translate="yes" xml:space="preserve">
          <source>At the risk of stating the obvious, modules are intended to be modular. A Perl developer should be able to use modules to put together the building blocks of their application. However, it's important that the blocks are the right shape, and that the developer shouldn't have to use a big block when all they need is a small one.</source>
          <target state="translated">冒昧地说一句,模块的目的是模块化的。一个Perl开发者应该能够使用模块来组合他们应用程序的构件。然而,重要的是模块的形状要正确,当开发者需要的是一个小模块时,他们不应该使用一个大模块。</target>
        </trans-unit>
        <trans-unit id="1014d039b0716d418675db8cd3420cc810aff463" translate="yes" xml:space="preserve">
          <source>At the same time, this pragma cannot detect when such a module has installed from CPAN to the core library, and so it would endlessly and uselessly exhort the user to upgrade.</source>
          <target state="translated">同时,这个pragma无法检测到这样的模块何时从CPAN安装到了核心库,所以它会无休止地、无用地劝告用户升级。</target>
        </trans-unit>
        <trans-unit id="d2c548d72452435d78a5e713661472ad87fa3347" translate="yes" xml:space="preserve">
          <source>At the time of this writing (2009-03) there are three YAML implementations working: YAML, YAML::Syck, and YAML::XS. The latter two are faster but need a C compiler installed on your system. There may be more alternative YAML conforming modules. When I tried two other players, YAML::Tiny and YAML::Perl, they seemed not powerful enough to work with CPAN.pm. This may have changed in the meantime.</source>
          <target state="translated">在写这篇文章的时候(2009-03),有三个YAML的实现在工作。YAML,YAML::Syck,和 YAML::XS。后两者速度更快,但需要在你的系统上安装一个C编译器。可能还有更多符合YAML的替代模块。当我尝试了另外两个播放器,YAML::Tiny和YAML::Perl,它们似乎不够强大,无法与CPAN.pm一起工作。在这期间,这种情况可能已经改变了。</target>
        </trans-unit>
        <trans-unit id="7ea634c02baa48b31e81ed3a00831f7dcbb2e678" translate="yes" xml:space="preserve">
          <source>At the time of this writing (June 2002), there is a known bug in the Tru64 libc printing of long doubles when not using &quot;e&quot; notation. The values are correct and usable, but you only get a limited number of digits displayed unless you force the issue by using &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;
&quot;%.33e&quot;,$num&lt;/code&gt; or the like. For Tru64 versions V5.0A through V5.1A, a patch is expected sometime after perl 5.8.0 is released. If your libc has not yet been patched, you'll get a warning from Configure when selecting long doubles.</source>
          <target state="translated">在撰写本文时（2002年6月），当不使用&amp;ldquo; e&amp;rdquo;表示法时，长双打的Tru64 libc打印中存在一个已知的错误。该值是正确且可用的，但是除非使用 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;%.33e&quot;,$num&lt;/code&gt; 等强制执行该问题，否则您只会显示有限的数字。对于Tru64版本V5.0A到V5.1A，预计在perl 5.8.0发布之后的某个时间会有补丁。如果您的libc尚未打补丁，则在选择长双打时会从Configure收到警告。</target>
        </trans-unit>
        <trans-unit id="cff077ec447ff4f924a23e0da4a7a4062c468c7a" translate="yes" xml:space="preserve">
          <source>At the time of this writing (June 2002), there is a known bug in the Tru64 libc printing of long doubles when not using &quot;e&quot; notation. The values are correct and usable, but you only get a limited number of digits displayed unless you force the issue by using &lt;code&gt;printf &quot;%.33e&quot;,$num&lt;/code&gt; or the like. For Tru64 versions V5.0A through V5.1A, a patch is expected sometime after perl 5.8.0 is released. If your libc has not yet been patched, you'll get a warning from Configure when selecting long doubles.</source>
          <target state="translated">在撰写本文时（2002年6月），当不使用&amp;ldquo; e&amp;rdquo;表示法时，长双打的Tru64 libc打印中存在一个已知的错误。该值是正确且可用的，但是除非使用 &lt;code&gt;printf &quot;%.33e&quot;,$num&lt;/code&gt; 等强制执行此问题，否则只能显示有限的数字。对于Tru64版本V5.0A到V5.1A，预计在perl 5.8.0发布之后的某个时间会有补丁。如果您的libc尚未打补丁，则在选择long double时会从Configure收到警告。</target>
        </trans-unit>
        <trans-unit id="1867a801fe6f9af5a7aceadb824f2be69014eb61" translate="yes" xml:space="preserve">
          <source>At the time of this writing, Perl 5.18.0 is considered to be well-hardened against algorithmic complexity attacks on its hash implementation. This is largely owed to the following measures mitigate attacks:</source>
          <target state="translated">在写这篇文章的时候,Perl 5.18.0被认为可以很好地抵御对其哈希实现的算法复杂性攻击。这主要归功于以下减轻攻击的措施。</target>
        </trans-unit>
        <trans-unit id="8a33c676d1f79e763827316ea86000a157f0da7a" translate="yes" xml:space="preserve">
          <source>At the time of very final cleanup, sv_free_arenas() is called from perl_destruct() to physically free all the arenas allocated since the start of the interpreter.</source>
          <target state="translated">在最后清理的时候,从perl_destruct()调用sv_free_arenas()来物理释放从解释器开始分配的所有区域。</target>
        </trans-unit>
        <trans-unit id="4ad7685293e30733157e0b0115df9c2bbc818321" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current &quot;a&quot; sub, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">在f被创建时,它不能捕获当前的 &quot;a &quot;子,因为匿名子程序还没有被创建。相反,下面的内容不会给出警告,因为匿名子程序现在已经被创建并且是实时的。</target>
        </trans-unit>
        <trans-unit id="c7f753fb79bacf696f44e6edc3ce403746b9d93b" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current value of $a, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">在f被创建的时候,它不能捕捉到$a的当前值,因为匿名子程序还没有被创建。相反,下面的内容不会给出警告,因为匿名子程序现在已经被创建并且是实时的。</target>
        </trans-unit>
        <trans-unit id="9d72f28fef349b76a0adf7f5f7156e5e3f38d89f" translate="yes" xml:space="preserve">
          <source>At the time this document was last updated, Cygwin 1.7.16 was current.</source>
          <target state="translated">在本文档最后更新时,Cygwin 1.7.16是最新版本。</target>
        </trans-unit>
        <trans-unit id="568132008f8ee29811084c20ba8f801b1aedb463" translate="yes" xml:space="preserve">
          <source>At the very least, this is useful to see what the SelfLoader thinks are stubs - in order to ensure future versions of the SelfStubber remain in step with the SelfLoader, the SelfStubber actually uses the SelfLoader to determine which stubs are needed.</source>
          <target state="translated">至少,这对查看SelfLoader认为哪些是存根是有用的--为了确保未来版本的SelfStubber与SelfLoader保持一致,SelfStubber实际上是使用SelfLoader来确定需要哪些存根。</target>
        </trans-unit>
        <trans-unit id="9d086f75055dc823d417d876f240b4ce1aa5f40a" translate="yes" xml:space="preserve">
          <source>At the very minimum, any subclass needs to provide its own &lt;code&gt;new()&lt;/code&gt; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</source>
          <target state="translated">至少，任何子类都需要提供自己的 &lt;code&gt;new()&lt;/code&gt; 并可以在对象中存储其他哈希键。还必须定义一些程序包全局变量，例如：</target>
        </trans-unit>
        <trans-unit id="4c88d3fd177dc36a169a0f390f88ed358e376c27" translate="yes" xml:space="preserve">
          <source>At the very minimum, any subclass will need to provide its own &lt;code&gt;new()&lt;/code&gt; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</source>
          <target state="translated">至少，任何子类都需要提供自己的 &lt;code&gt;new()&lt;/code&gt; 并可以在对象中存储其他哈希键。还必须定义一些程序包全局变量，例如：</target>
        </trans-unit>
        <trans-unit id="edcf8fa241edee8ba6be389a9320a43680a858f9" translate="yes" xml:space="preserve">
          <source>At this point, if you're using the</source>
          <target state="translated">此时,如果你使用的是</target>
        </trans-unit>
        <trans-unit id="5a6511c6f50957ea6c619917499bccc60b76c492" translate="yes" xml:space="preserve">
          <source>At this point, we have all the basic regexp concepts covered, so let's give a more involved example of a regular expression. We will build a regexp that matches numbers.</source>
          <target state="translated">到此为止,我们已经涵盖了所有基本的regexp概念,那么我们来举一个更复杂的正则表达式的例子。我们将建立一个匹配数字的regexp。</target>
        </trans-unit>
        <trans-unit id="370a5cf660692a42903691231af5dc8e0071bc25" translate="yes" xml:space="preserve">
          <source>At this point, xsubpp is doing very little work - the differences between Mytest.xs and Mytest.c are minimal.</source>
          <target state="translated">在这一点上,xsubpp做的工作很少--Mytest.xs和Mytest.c之间的差别很小。</target>
        </trans-unit>
        <trans-unit id="4cb351d8164d812dc7e335f6aa1c330c2f5b0d24" translate="yes" xml:space="preserve">
          <source>At this time, &lt;code&gt;study&lt;/code&gt; does nothing. This may change in the future.</source>
          <target state="translated">目前， &lt;code&gt;study&lt;/code&gt; 无所作为。将来可能会改变。</target>
        </trans-unit>
        <trans-unit id="6e93ae94dda2105286d8d2c3c0189888d8aa45b7" translate="yes" xml:space="preserve">
          <source>At time of writing, &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; values are of two types: either the name of a Pod page like &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; . In theory, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; in ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; code.</source>
          <target state="translated">在撰写本文时， &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; 值有两种类型：Pod页面的名称，例如 &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; （它可能是@ INC / PATH目录中的真实Perl模块或程序，或者.pod文件）；或Unix手册页的名称，例如 &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; 。从理论上讲， &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; 在称为&amp;ldquo; chmod&amp;rdquo;的Pod页面或Unix手册页&amp;ldquo; chmod&amp;rdquo;之间（在任何man-section中）都是模棱两可的。但是，如&amp;ldquo; crontab（5）&amp;rdquo;中的那样，parens中存在字符串就足以表明正在讨论的内容不是Pod页面，因此大概是Unix手册页。对于许多Pod处理器而言，这种区别并不重要，但是某些渲染为超文本格式的处理器可能需要区分它们，以便知道如何渲染给定的 &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; 代码。</target>
        </trans-unit>
        <trans-unit id="1402e155751b829c93df5128b5d19d797691621a" translate="yes" xml:space="preserve">
          <source>At time of writing, &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; values are of two types: either the name of a Pod page like &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt;. In theory, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; is ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; code.</source>
          <target state="translated">在撰写本文时， &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; 值有两种类型：Pod页面的名称，例如 &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; （它可能是@ INC / PATH目录中的真实Perl模块或程序，或者是.pod文件）；或Unix手册页的名称，例如 &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; 。从理论上讲， &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; 在称为&amp;ldquo; chmod&amp;rdquo;的Pod页面或Unix手册页&amp;ldquo; chmod&amp;rdquo;之间（在任何man-section中）都是模棱两可的。但是，如&amp;ldquo; crontab（5）&amp;rdquo;中的那样，parens中存在字符串就足以表明正在讨论的内容不是Pod页面，因此大概是Unix手册页。对于许多Pod处理器而言，这种区别并不重要，但是某些渲染为超文本格式的处理器可能需要区分它们，以便知道如何渲染给定的 &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; 代码。</target>
        </trans-unit>
        <trans-unit id="24f8d626a483cf6ebf2f3cd6cefe211ee98242ab" translate="yes" xml:space="preserve">
          <source>At time of writing, I don't think you'll need to use this.</source>
          <target state="translated">在写这篇文章的时候,我想你不需要用这个。</target>
        </trans-unit>
        <trans-unit id="6b127225208f5ac9bbb6a72b48b20b7d3616ff18" translate="yes" xml:space="preserve">
          <source>Atari MiNT</source>
          <target state="translated">Atari MiNT</target>
        </trans-unit>
        <trans-unit id="7f3342f30bf4c3977d537b68719b3f6636e25cb1" translate="yes" xml:space="preserve">
          <source>Athena</source>
          <target state="translated">Athena</target>
        </trans-unit>
        <trans-unit id="fb5b8f9948a5df2cd992c1e84448561317bc6a25" translate="yes" xml:space="preserve">
          <source>Atrributes such as package, file, and caller are determined automatically, and cannot be specified.</source>
          <target state="translated">包、文件、调用者等属性是自动确定的,不能指定。</target>
        </trans-unit>
        <trans-unit id="3493cb8763751f88e1926ab01085068e369734c9" translate="yes" xml:space="preserve">
          <source>Attach the shared memory segment identified by ID to the address space of the calling process. See &lt;a href=&quot;http://man.he.net/man2/shmat&quot;&gt;shmat(2)&lt;/a&gt;.</source>
          <target state="translated">将ID标识的共享内存段附加到调用进程的地址空间。参见&lt;a href=&quot;http://man.he.net/man2/shmat&quot;&gt;shmat（2）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d759da54d18d185bb5ccfc037b889a6ccc296532" translate="yes" xml:space="preserve">
          <source>Attach the shared memory segment identified by ID to the address space of the calling process. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;.</source>
          <target state="translated">将ID标识的共享内存段附加到调用进程的地址空间。参见&lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="225d31a7a030cd02427cb0b7456aa1f815b2914d" translate="yes" xml:space="preserve">
          <source>Attaching &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; to arrays is permissible but has no effect.</source>
          <target state="translated">将 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 附加到数组是允许的，但无效。</target>
        </trans-unit>
        <trans-unit id="d423c0cfec188bd6ee98e700b49e9beb58a1ac55" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication.</source>
          <target state="translated">尝试SASL认证。</target>
        </trans-unit>
        <trans-unit id="a57d83a2b0e335a567209ea75d9a6f7c18c72eb5" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication. Requires Authen::SASL module.</source>
          <target state="translated">试图进行SASL认证。需要 Authen::SASL 模块。</target>
        </trans-unit>
        <trans-unit id="ccd854e11a4d11e3e9e58ceb95944b13ef3a518a" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication. Requires Authen::SASL module. The first form constructs a new Authen::SASL object using the given username and password; the second form uses the given Authen::SASL object.</source>
          <target state="translated">试图进行SASL认证。需要 Authen::SASL 模块。第一个表单使用给定的用户名和密码构造一个新的 Authen::SASL 对象;第二个表单使用给定的 Authen::SASL 对象。</target>
        </trans-unit>
        <trans-unit id="883f5c19fa9ca67ce62c443fd2ce7bac60b6089d" translate="yes" xml:space="preserve">
          <source>Attempt to access disallowed key '%s' in a restricted hash</source>
          <target state="translated">试图访问受限哈希中不允许的密钥&quot;%s&quot;。</target>
        </trans-unit>
        <trans-unit id="5cf0ab65502bfcdd00cde497405332ccea4e648b" translate="yes" xml:space="preserve">
          <source>Attempt to bless into a freed package</source>
          <target state="translated">试图祝福到一个自由的包</target>
        </trans-unit>
        <trans-unit id="8614ea5fd745bc313cc5245a331edbc4dddec890" translate="yes" xml:space="preserve">
          <source>Attempt to bless into a reference</source>
          <target state="translated">试图祝福成参考</target>
        </trans-unit>
        <trans-unit id="0bfa31d2d4671313bd0af54f4bb1d33e8b3d1352" translate="yes" xml:space="preserve">
          <source>Attempt to change directory to the directory given in &lt;code&gt;$dir&lt;/code&gt; . If &lt;code&gt;$dir&lt;/code&gt; is &lt;code&gt;&quot;..&quot;&lt;/code&gt; , the FTP &lt;code&gt;CDUP&lt;/code&gt; command is used to attempt to move up one directory. If no directory is given then an attempt is made to change the directory to the root directory.</source>
          <target state="translated">尝试将目录更改为 &lt;code&gt;$dir&lt;/code&gt; 给定的目录。如果 &lt;code&gt;$dir&lt;/code&gt; 是 &lt;code&gt;&quot;..&quot;&lt;/code&gt; ，则FTP &lt;code&gt;CDUP&lt;/code&gt; 命令用于尝试向上移动一个目录。如果未提供目录，则尝试将目录更改为根目录。</target>
        </trans-unit>
        <trans-unit id="6f0b75ab4748fe5742f8fdfbfa72a1464729d3b5" translate="yes" xml:space="preserve">
          <source>Attempt to change directory to the directory given in &lt;code&gt;$dir&lt;/code&gt;. If &lt;code&gt;$dir&lt;/code&gt; is &lt;code&gt;&quot;..&quot;&lt;/code&gt;, the FTP &lt;code&gt;CDUP&lt;/code&gt; command is used to attempt to move up one directory. If no directory is given then an attempt is made to change the directory to the root directory.</source>
          <target state="translated">尝试将目录更改为 &lt;code&gt;$dir&lt;/code&gt; 给定的目录。如果 &lt;code&gt;$dir&lt;/code&gt; 为 &lt;code&gt;&quot;..&quot;&lt;/code&gt; ，则使用FTP &lt;code&gt;CDUP&lt;/code&gt; 命令尝试向上移动一个目录。如果未提供目录，则尝试将目录更改为根目录。</target>
        </trans-unit>
        <trans-unit id="c6aef18d28c95173a99a1a9cd9b174366e83e56c" translate="yes" xml:space="preserve">
          <source>Attempt to clear deleted array</source>
          <target state="translated">试图清除已删除的数组</target>
        </trans-unit>
        <trans-unit id="f1a553fb01152c680db2f1ac04b66addb3e1a32b" translate="yes" xml:space="preserve">
          <source>Attempt to convert an absolute file specification to a relative specification.</source>
          <target state="translated">试图将绝对文件规范转换为相对规范。</target>
        </trans-unit>
        <trans-unit id="2c4880c9fdd4f4d9c5b79e2c012fb0e250d383e7" translate="yes" xml:space="preserve">
          <source>Attempt to delete disallowed key '%s' from a restricted hash</source>
          <target state="translated">试图从限制性哈希中删除不允许的键&quot;%s&quot;。</target>
        </trans-unit>
        <trans-unit id="0798ebadbab9bffb1e99c85507d3edee83caa008" translate="yes" xml:space="preserve">
          <source>Attempt to delete readonly key '%s' from a restricted hash</source>
          <target state="translated">试图从受限哈希中删除只读键&quot;%s&quot;。</target>
        </trans-unit>
        <trans-unit id="c6a6104d31483a82798cc43a56c3040f5b0e5915" translate="yes" xml:space="preserve">
          <source>Attempt to destroy all objects not yet freed.</source>
          <target state="translated">试图摧毁所有尚未释放的物体。</target>
        </trans-unit>
        <trans-unit id="fe99a6ee8775c38ae61fdc7b8491eb15dc3ce181" translate="yes" xml:space="preserve">
          <source>Attempt to evaluate the current host's internet name and domain</source>
          <target state="translated">尝试评估当前主机的互联网名称和域名。</target>
        </trans-unit>
        <trans-unit id="80fda9c03868b272773d0d41887e0dbe18413719" translate="yes" xml:space="preserve">
          <source>Attempt to free non-arena SV: 0x%x</source>
          <target state="translated">试图释放非区域SV:0x%x。</target>
        </trans-unit>
        <trans-unit id="54d38b115a5aa938320799c6531228c69b9fa275" translate="yes" xml:space="preserve">
          <source>Attempt to free nonexistent shared string '%s'%s</source>
          <target state="translated">试图释放不存在的共享字符串'%s'%s。</target>
        </trans-unit>
        <trans-unit id="1b479273a362ea2e8c34f077e9e3c6360ab77808" translate="yes" xml:space="preserve">
          <source>Attempt to free temp prematurely: SV 0x%x</source>
          <target state="translated">试图过早释放温度。SV 0x%x</target>
        </trans-unit>
        <trans-unit id="a34a51b6be5af9431919f62ebe158c42fa203ea7" translate="yes" xml:space="preserve">
          <source>Attempt to free unreferenced glob pointers</source>
          <target state="translated">试图释放未引用的 glob 指针。</target>
        </trans-unit>
        <trans-unit id="40f310189c328c36df3675b24385fea4a52ffa6b" translate="yes" xml:space="preserve">
          <source>Attempt to free unreferenced scalar: SV 0x%x</source>
          <target state="translated">试图释放未引用的标量。SV 0x%x</target>
        </trans-unit>
        <trans-unit id="51aff28048c322c0b88140e9c1dcb9278d5b60c1" translate="yes" xml:space="preserve">
          <source>Attempt to pack pointer to temporary value</source>
          <target state="translated">试图将指针打包到临时值上。</target>
        </trans-unit>
        <trans-unit id="078cb982d4d92298b47355c08e74e2f224c181c7" translate="yes" xml:space="preserve">
          <source>Attempt to print summary information if run is interrupted by SIGINT (Ctrl-C).</source>
          <target state="translated">如果运行被SIGINT(Ctrl-C)打断,则尝试打印摘要信息。</target>
        </trans-unit>
        <trans-unit id="b914600bb82ac0ae87b3e9ab97d2d1c2f3efb3a8" translate="yes" xml:space="preserve">
          <source>Attempt to produce color output.</source>
          <target state="translated">试图产生彩色输出。</target>
        </trans-unit>
        <trans-unit id="efb3613b13587fe1f93cf60bf899f24390374124" translate="yes" xml:space="preserve">
          <source>Attempt to read &lt;code&gt;$length&lt;/code&gt; bytes of uncompressed data into &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">尝试将 &lt;code&gt;$length&lt;/code&gt; 个字节的未压缩数据读入 &lt;code&gt;$buffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09a9c5fb7a8cb670c472dd87151c6343a5662154" translate="yes" xml:space="preserve">
          <source>Attempt to read &lt;code&gt;$length&lt;/code&gt; bytes of uncompressed data into &lt;code&gt;$buffer&lt;/code&gt;.</source>
          <target state="translated">尝试将未压缩数据的 &lt;code&gt;$length&lt;/code&gt; 个字节读入 &lt;code&gt;$buffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e9d551547de808708f971d391e53086cf3f44fc" translate="yes" xml:space="preserve">
          <source>Attempt to reload %s aborted.</source>
          <target state="translated">试图重新加载%s中止。</target>
        </trans-unit>
        <trans-unit id="87c4ceba341469a694caa6a8c164987d97a35645" translate="yes" xml:space="preserve">
          <source>Attempt to set length of freed array</source>
          <target state="translated">试图设置释放的数组的长度</target>
        </trans-unit>
        <trans-unit id="cee621066cdf5eff50fe796c90fc14083ab2dd15" translate="yes" xml:space="preserve">
          <source>Attempt to use reference as lvalue in substr</source>
          <target state="translated">试图在substr中使用引用作为l值。</target>
        </trans-unit>
        <trans-unit id="5b92f951c7fd86ee7f7ec9db2ae7b702bd512a11" translate="yes" xml:space="preserve">
          <source>Attempting to inherit from yourself generates a warning.</source>
          <target state="translated">试图从自己那里继承会产生一个警告。</target>
        </trans-unit>
        <trans-unit id="940068c4484917346e58cd849ab63ab658a04374" translate="yes" xml:space="preserve">
          <source>Attempting to pack the special floating point values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity, also in negative, and not-a-number) into packed integer values (like &lt;code&gt;&quot;L&quot;&lt;/code&gt; ) is a fatal error. The reason for this is that there simply isn't any sensible mapping for these special values into integers.</source>
          <target state="translated">尝试将特殊的浮点值 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; （无穷大，也为负数，不是一个数字）压缩为压缩整数值（例如 &lt;code&gt;&quot;L&quot;&lt;/code&gt; ）是一个致命错误。这样做的原因是，对于这些特殊值到整数，根本没有任何明智的映射。</target>
        </trans-unit>
        <trans-unit id="d1f53d7ce9f579730ddb96734ab811ab0bbc0590" translate="yes" xml:space="preserve">
          <source>Attempting to pack the special floating point values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity, also in negative, and not-a-number) into packed integer values (like &lt;code&gt;&quot;L&quot;&lt;/code&gt;) is a fatal error. The reason for this is that there simply isn't any sensible mapping for these special values into integers.</source>
          <target state="translated">试图将特殊的浮点值 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; （无穷大，也为负数，不是一个数字）压缩为压缩整数值（例如 &lt;code&gt;&quot;L&quot;&lt;/code&gt; ）是致命错误。这样做的原因是，对于这些特殊值到整数，根本没有任何明智的映射。</target>
        </trans-unit>
        <trans-unit id="6015d4f519177c33ba06ab08404701540b4f2048" translate="yes" xml:space="preserve">
          <source>Attempting to reopen a database without closing it.</source>
          <target state="translated">试图在不关闭数据库的情况下重新打开数据库。</target>
        </trans-unit>
        <trans-unit id="0bedf74043c203b86c1b5363d305f57a4b0c5fcb" translate="yes" xml:space="preserve">
          <source>Attempts several methods of getting the system hostname and then caches the result. It tries the first available of the C library's gethostname(), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname(2), &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; , and the file</source>
          <target state="translated">尝试几种获取系统主机名的方法，然后缓存结果。它尝试C库的gethostname（）， &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; ，uname（2）， &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;`hostname`&lt;/code&gt; ， &lt;code&gt;`uname -n`&lt;/code&gt; 和文件中的第一个可用</target>
        </trans-unit>
        <trans-unit id="82ba9728173d7f6ba4ffa539ae706dc3eec02b8f" translate="yes" xml:space="preserve">
          <source>Attempts several methods of getting the system hostname and then caches the result. It tries the first available of the C library's gethostname(), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt;, uname(2), &lt;code&gt;syscall(SYS_gethostname)&lt;/code&gt;, &lt;code&gt;`hostname`&lt;/code&gt;, &lt;code&gt;`uname -n`&lt;/code&gt;, and the file</source>
          <target state="translated">尝试几种获取系统主机名的方法，然后缓存结果。它尝试C库的gethostname（）， &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; ，uname（2）， &lt;code&gt;syscall(SYS_gethostname)&lt;/code&gt; ， &lt;code&gt;`hostname`&lt;/code&gt; ， &lt;code&gt;`uname -n`&lt;/code&gt; 和文件中的第一个可用</target>
        </trans-unit>
        <trans-unit id="5ba76ae4290c1441342a9f4f7bc1b58233fe69fb" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like &lt;a href=&quot;http://man.he.net/man2/connect&quot;&gt;connect(2)&lt;/a&gt;. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="translated">尝试连接到远程套接字，就像&lt;a href=&quot;http://man.he.net/man2/connect&quot;&gt;connect（2）一样&lt;/a&gt;。如果成功，则返回true，否则返回false。 NAME应该是套接字的适当类型的压缩地址。请参阅&lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的&amp;ldquo;套接字：客户端/服务器通信&amp;rdquo;中的示例。</target>
        </trans-unit>
        <trans-unit id="f998d3cd38777ee213006cd15fb0e0f6d2ddc7f7" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">尝试连接到远程套接字，就像connect（2）一样。如果成功，则返回true，否则返回false。NAME应该是套接字的适当类型的压缩地址。请参阅&lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="64769a075153327a39fd4f2723d3853f980fe471" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">尝试连接到远程套接字，就像connect（2）一样。如果成功，则返回true，否则返回false。NAME应该是套接字的适当类型的压缩地址。请参阅&lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="4a0ddb935c0376b494edd76deb21d2e9aa4a1612" translate="yes" xml:space="preserve">
          <source>Attempts to convert in-place the octet sequence encoded as</source>
          <target state="translated">试图在原地转换编码为</target>
        </trans-unit>
        <trans-unit id="bd9b4f39078d108026008c73a3d153cb14bae4bd" translate="yes" xml:space="preserve">
          <source>Attempts to convert the PV of an SV from characters to bytes. If the PV contains a character that cannot fit in a byte, this conversion will fail; in this case, either returns false or, if &lt;code&gt;fail_ok&lt;/code&gt; is not true, croaks.</source>
          <target state="translated">尝试将SV的PV从字符转换为字节。如果PV包含不能容纳在字节中的字符，则此转换将失败；否则，转换将失败。在这种情况下，返回false，或者，如果 &lt;code&gt;fail_ok&lt;/code&gt; 不为true，则返回错误。</target>
        </trans-unit>
        <trans-unit id="64d7ec66819a9007136707554fdc8dbbef9567aa" translate="yes" xml:space="preserve">
          <source>Attempts to determine if a given host is outside your firewall. Possible return values are.</source>
          <target state="translated">试图确定某个主机是否在您的防火墙之外。可能的返回值是:</target>
        </trans-unit>
        <trans-unit id="015e99d4e0b5f5661a89b0c851595de01de6cc85" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH</source>
          <target state="translated">尝试阅读LENGTH</target>
        </trans-unit>
        <trans-unit id="c8be1bb9a549008dc0e0461ce94dfbc02a8ed8c1" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using &lt;a href=&quot;http://man.he.net/man2/read&quot;&gt;read(2)&lt;/a&gt;. It bypasses any &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; layers including buffered IO (but is affected by the presence of the &lt;code&gt;:utf8&lt;/code&gt; layer as described later), so mixing this with other kinds of reads, &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; can cause confusion because the &lt;code&gt;:perlio&lt;/code&gt; or &lt;code&gt;:crlf&lt;/code&gt; layers usually buffer data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">尝试使用&lt;a href=&quot;http://man.he.net/man2/read&quot;&gt;read（2）&lt;/a&gt;从指定的FILEHANDLE中将LENGTH个字节的数据读取到变量SCALAR中。它绕过包括缓冲IO在内的所有&lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;层（但会受到 &lt;code&gt;:utf8&lt;/code&gt; 层的影响，如稍后所述），因此将其与其他类型的读取，&lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#write-FILEHANDLE&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; 混合&lt;/a&gt;会引起混淆，因为 &lt;code&gt;:perlio&lt;/code&gt; 或 &lt;code&gt;:crlf&lt;/code&gt; crlf层通常缓冲数据。返回实际读取的字节数，在文件末尾返回 &lt;code&gt;0&lt;/code&gt; ，如果出现错误则返回undef（在后一种情况下&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;也已设置）。 SCALAR将增长或缩小，以便实际读取的最后一个字节是读取后标量的最后一个字节。</target>
        </trans-unit>
        <trans-unit id="623d8fbf82dc2fdc9694f6bbe91f1257bb25f69a" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">尝试使用read（2）从指定的FILEHANDLE将LENGTH个字节的数据读取到变量SCALAR中。它会绕过缓冲的IO，因此将其与其他类型的读取， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 混合使用会引起混乱，因为Perlio或stdio层通常会缓冲数据。返回实际读取的字节数，在文件末尾返回 &lt;code&gt;0&lt;/code&gt; ，如果出现错误则返回undef（在后一种情况下，还设置了 &lt;code&gt;$!&lt;/code&gt; ）。 SCALAR将增长或缩小，以便实际读取的最后一个字节是读取后标量的最后一个字节。</target>
        </trans-unit>
        <trans-unit id="321c64867646f812228d15e7d459f8fc1a5c1183" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">尝试使用read（2）从指定的FILEHANDLE将LENGTH个字节的数据读取到变量SCALAR中。它会绕过缓冲的IO，因此将其与其他类型的读取， &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 混合使用会引起混乱，因为Perlio或stdio层通常会缓冲数据。返回实际读取的字节数，在文件末尾返回 &lt;code&gt;0&lt;/code&gt; ，如果出现错误则返回undef（在后一种情况下，还设置了 &lt;code&gt;$!&lt;/code&gt; ）。 SCALAR将增长或缩小，以便实际读取的最后一个字节是读取后标量的最后一个字节。</target>
        </trans-unit>
        <trans-unit id="1a8348f0c0ac76ec0ef2040ebe72ee4d10ad1e13" translate="yes" xml:space="preserve">
          <source>Attempts to set_hints_for unidentifiable subroutine</source>
          <target state="translated">试图为不可识别的子程序设置_hints_。</target>
        </trans-unit>
        <trans-unit id="2e09b188ae4a3fab1a81562daadb429ed4fd7f6d" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using &lt;a href=&quot;http://man.he.net/man2/write&quot;&gt;write(2)&lt;/a&gt;. If LENGTH is not specified, writes whole SCALAR. It bypasses any &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; layers including buffered IO (but is affected by the presence of the &lt;code&gt;:utf8&lt;/code&gt; layer as described later), so mixing this with reads (other than &lt;code&gt;sysread)&lt;/code&gt;), &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; may cause confusion because the &lt;code&gt;:perlio&lt;/code&gt; and &lt;code&gt;:crlf&lt;/code&gt; layers usually buffer data. Returns the number of bytes actually written, or &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; if there was an error (in this case the errno variable &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">尝试使用&lt;a href=&quot;http://man.he.net/man2/write&quot;&gt;write（2）&lt;/a&gt;将变量SCALAR的LENGTH个字节写入指定的FILEHANDLE中。如果未指定LENGTH，则写入整个SCALAR。它绕过包括缓冲IO在内的所有&lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;层（但会受到 &lt;code&gt;:utf8&lt;/code&gt; 层的影响，如稍后所述），因此将其与读取（而不是 &lt;code&gt;sysread)&lt;/code&gt; 混合在一起），&lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#write-FILEHANDLE&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt;可能会造成混乱因为 &lt;code&gt;:perlio&lt;/code&gt; 和 &lt;code&gt;:crlf&lt;/code&gt; 层通常缓冲数据。返回实际写入的字节数，或&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;如果有错误（在这种情况下，还将设置errno变量&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;）。如果偏移后的长度大于标量中的可用数据，则只会写入尽可能多的数据。</target>
        </trans-unit>
        <trans-unit id="056c7c4b49d09bfb10b608aa560ae7f329c94639" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">尝试使用write（2）将变量SCALAR的LENGTH个字节写入指定的FILEHANDLE。如果未指定LENGTH，则写入整个SCALAR。它绕过缓冲的IO，因此将其与读取（而不是 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 混合使用可能会造成混乱，因为perlio和stdio层通常会缓冲数据。返回实际写入的字节数，如果有错误，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （在这种情况下，还将设置errno变量 &lt;code&gt;$!&lt;/code&gt; ）。如果偏移后的长度大于标量中的可用数据，则只会写入尽可能多的数据。</target>
        </trans-unit>
        <trans-unit id="bf935c85345c3169ffc0b395c956f17c45a9fe82" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">尝试使用write（2）将变量SCALAR的LENGTH个字节写入指定的FILEHANDLE。如果未指定LENGTH，则写入整个SCALAR。它绕过缓冲的IO，因此将其与读取（而不是 &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 混合使用可能会造成混乱，因为perlio和stdio层通常会缓冲数据。返回实际写入的字节数，如果有错误，则返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （在这种情况下，还将设置errno变量 &lt;code&gt;$!&lt;/code&gt; ）。如果偏移后的长度大于标量中的可用数据，则只会写入尽可能多的数据。</target>
        </trans-unit>
        <trans-unit id="cf2ad2263d9deded93137fc6e93270ce22633fb0" translate="yes" xml:space="preserve">
          <source>Attempts word completion. Cannot be changed.</source>
          <target state="translated">试图完成单词。不能更改。</target>
        </trans-unit>
        <trans-unit id="223e46f6b77744459f61cc252aea39f3bcaac056" translate="yes" xml:space="preserve">
          <source>Attribs</source>
          <target state="translated">Attribs</target>
        </trans-unit>
        <trans-unit id="295826f440604d6a675c4c66d0a324dc4eaca56b" translate="yes" xml:space="preserve">
          <source>Attribute prototype(%s) discards earlier prototype attribute in same sub</source>
          <target state="translated">属性prototype(%s)丢弃同一子项中的早期原型属性。</target>
        </trans-unit>
        <trans-unit id="402319da749127eab7373ce69945d35452ea82aa" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers</source>
          <target state="translated">Attribute::Handlers</target>
        </trans-unit>
        <trans-unit id="ab429cb97f17abf9bda7af427a4ab75a270a8eee" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers - Simpler definition of attribute handlers</source>
          <target state="translated">Attribute::Handlers-简化属性处理程序的定义。</target>
        </trans-unit>
        <trans-unit id="1c8c525e5ee86dfc71e9832b4cad7c5124dad809" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers makes strenuous efforts to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler (but see &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;Non-interpretive attribute handlers&lt;/a&gt;). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</source>
          <target state="translated">Attribute :: Handlers努力地将数据参数（ &lt;code&gt;$_[4]&lt;/code&gt; ）转换为可用形式，然后再将其传递给处理程序（但请参阅&lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;非解释性属性处理程序&lt;/a&gt;）。如果这些努力成功，则将解释后的数据传递到数组引用中；否则，将失败。如果它们失败，则原始数据将作为字符串传递。例如，所有这些：</target>
        </trans-unit>
        <trans-unit id="04790e00da71beac2f86333318faed6cfab890a0" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers makes strenuous efforts to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt;) to a usable form before passing it to the handler (but see &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;&quot;Non-interpretive attribute handlers&quot;&lt;/a&gt;). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</source>
          <target state="translated">Attribute :: Handlers努力地将数据参数（ &lt;code&gt;$_[4]&lt;/code&gt; ）转换为可用形式，然后再将其传递给处理程序（请参阅&lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;&amp;ldquo;非解释性属性处理程序&amp;rdquo;&lt;/a&gt;）。如果这些努力成功，则将解释后的数据传递到数组引用中；否则，将失败。如果它们失败，则原始数据将作为字符串传递。例如，所有这些：</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="4ce085fab8976266bb7771327c95a06a2d92883d" translate="yes" xml:space="preserve">
          <source>Attributes :locked and :unique</source>
          <target state="translated">属性:锁定和:唯一</target>
        </trans-unit>
        <trans-unit id="57744968c9ece6a6fd393a9a1f9a16852d8d26e2" translate="yes" xml:space="preserve">
          <source>Attributes &lt;code&gt;:locked&lt;/code&gt; and &lt;code&gt;:unique&lt;/code&gt;</source>
          <target state="translated">属性 &lt;code&gt;:locked&lt;/code&gt; 和 &lt;code&gt;:unique&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f65ce706012d5cc8515dbfba3f0c94b3cae90800" translate="yes" xml:space="preserve">
          <source>Attributes =&amp;gt; $sAttributes</source>
          <target state="translated">属性=&amp;gt; $ sAttributes</target>
        </trans-unit>
        <trans-unit id="7096373d5156eb6bd0032a6f3f3f6f2306181c31" translate="yes" xml:space="preserve">
          <source>Attributes are often stored in the object itself. For example, if the object is an anonymous hash, we can store the attribute values in the hash using the attribute name as the key.</source>
          <target state="translated">属性通常存储在对象本身中。例如,如果对象是一个匿名哈希,我们可以使用属性名作为键,在哈希中存储属性值。</target>
        </trans-unit>
        <trans-unit id="1ec0e5f9458a3d0b7666b49e580f1e144a9409de" translate="yes" xml:space="preserve">
          <source>Attributes are typically defined as read-only or read-write. Read-only attributes can only be set when the object is first created, while read-write attributes can be altered at any time.</source>
          <target state="translated">属性通常被定义为只读或读写。只读属性只能在第一次创建对象时设置,而读写属性可以在任何时候改变。</target>
        </trans-unit>
        <trans-unit id="e7c79e72c9cbf686713260fcf1aae8a2f9a1a49e" translate="yes" xml:space="preserve">
          <source>Attributes as &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; interfaces</source>
          <target state="translated">属性作为 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 界面</target>
        </trans-unit>
        <trans-unit id="dd541d956cc1115542e113d51d19e51923523667" translate="yes" xml:space="preserve">
          <source>Attributes as &lt;code&gt;tie&lt;/code&gt; interfaces</source>
          <target state="translated">属性作为 &lt;code&gt;tie&lt;/code&gt; 界面</target>
        </trans-unit>
        <trans-unit id="6e1c2a2200f4dc51bc987e61b1d0f256256aa8d5" translate="yes" xml:space="preserve">
          <source>Attributes as tie interfaces</source>
          <target state="translated">属性作为连接接口</target>
        </trans-unit>
        <trans-unit id="5d582f3d2d463609c927f60d4eb884597e89efea" translate="yes" xml:space="preserve">
          <source>Attributes make an excellent and intuitive interface through which to tie variables. For example:</source>
          <target state="translated">属性是一个很好的、直观的界面,通过它来绑定变量。例如:</target>
        </trans-unit>
        <trans-unit id="508a5aa4d3d540c30ef29d403ada44bf44ff7142" translate="yes" xml:space="preserve">
          <source>Attributes, once set, last until they are unset (by printing the attribute &lt;code&gt;clear&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt;). Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.</source>
          <target state="translated">属性一旦设置，将一直持续到取消设置为止（通过将属性打印为 &lt;code&gt;clear&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; ）。请小心执行此操作，否则，在脚本运行完成后，属性将继续存在，并且人们对将提示和键入更改为怪异的颜色感到非常恼火。</target>
        </trans-unit>
        <trans-unit id="8aad82b8fbc6c4c52822cc8ecd0cf935a1127780" translate="yes" xml:space="preserve">
          <source>Attributes, once set, last until they are unset (by printing the attribute &lt;code&gt;clear&lt;/code&gt; or &lt;code&gt;reset&lt;/code&gt;). Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.</source>
          <target state="translated">属性一旦设置，将一直持续到取消设置为止（通过将属性打印为 &lt;code&gt;clear&lt;/code&gt; 或 &lt;code&gt;reset&lt;/code&gt; ）。请小心执行此操作，否则，在脚本运行完成后，属性将继续存在，并且人们对将提示和键入更改为怪异的颜色感到非常恼火。</target>
        </trans-unit>
        <trans-unit id="d51da1fd65173253fff2051ffdb2fb4742bcd89d" translate="yes" xml:space="preserve">
          <source>Audrey Tang</source>
          <target state="translated">邓丽君</target>
        </trans-unit>
        <trans-unit id="1874e0336adde0a00ba3a60dae1dc775409600bd" translate="yes" xml:space="preserve">
          <source>Audrey Tang &amp;lt;cpan@audreyt.org&amp;gt;</source>
          <target state="translated">唐（Audrey Tang）&amp;lt;cpan@audreyt.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f2cb213ffe5688a539a9e042d127473bf2e3ad45" translate="yes" xml:space="preserve">
          <source>August 2005</source>
          <target state="translated">2005年8月</target>
        </trans-unit>
        <trans-unit id="7b22c9a35903363899da803d503fe897e1743fa7" translate="yes" xml:space="preserve">
          <source>August 23, 2005</source>
          <target state="translated">2005年8月23日</target>
        </trans-unit>
        <trans-unit id="ceafb51e2b0783d53dd620019dff3aa66708a26f" translate="yes" xml:space="preserve">
          <source>Australia</source>
          <target state="translated">Australia</target>
        </trans-unit>
        <trans-unit id="593905b31972f6ffe58325abf98595caf4ebf458" translate="yes" xml:space="preserve">
          <source>Austria</source>
          <target state="translated">Austria</target>
        </trans-unit>
        <trans-unit id="95786e021d4a315fb9439c8c152d524cf9f59cc3" translate="yes" xml:space="preserve">
          <source>Authen::SASL is required for AUTH support.</source>
          <target state="translated">Authen::SASL需要AUTH支持。</target>
        </trans-unit>
        <trans-unit id="21c24cd01488e77938199d2e43d1c1e07248317d" translate="yes" xml:space="preserve">
          <source>Authenticate with the server identifying as &lt;code&gt;USER&lt;/code&gt; with password &lt;code&gt;PASS&lt;/code&gt; . Similar to &lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt;, but the password is not sent in clear text.</source>
          <target state="translated">使用密码 &lt;code&gt;PASS&lt;/code&gt; 与标识为 &lt;code&gt;USER&lt;/code&gt; 的服务器进行身份验证。与&lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt;相似，但密码不是以明文形式发送。</target>
        </trans-unit>
        <trans-unit id="2d308c897b8201e557fb3734cdc42302c1f694dd" translate="yes" xml:space="preserve">
          <source>Authenticate with the server identifying as &lt;code&gt;USER&lt;/code&gt; with password &lt;code&gt;PASS&lt;/code&gt;. Similar to &lt;a href=&quot;#login&quot;&gt;&quot;login&quot;&lt;/a&gt;, but the password is not sent in clear text.</source>
          <target state="translated">使用密码 &lt;code&gt;PASS&lt;/code&gt; 对标识为 &lt;code&gt;USER&lt;/code&gt; 的服务器进行身份验证。与&lt;a href=&quot;#login&quot;&gt;&amp;ldquo; login&amp;rdquo;&lt;/a&gt;类似，但是密码不是以明文形式发送的。</target>
        </trans-unit>
        <trans-unit id="507f24ee32e393058ec2717e7ff642ddf8b1dd65" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the original AUTHINFO USER / AUTHINFO PASS form, defined in RFC2980) using the supplied username and password. Please note that the password is sent in clear text to the server. This command should not be used with valuable passwords unless the connection to the server is somehow protected.</source>
          <target state="translated">使用提供的用户名和密码对服务器进行身份验证(使用 RFC2980 中定义的原始 AUTHINFO USER/AUTHINFO PASS 表格)。请注意,密码是以明文形式发送给服务器的。除非与服务器的连接受到某种程度的保护,否则这个命令不应该与有价值的密码一起使用。</target>
        </trans-unit>
        <trans-unit id="4be2c3e4a055e66e61888715b3835a0acb5d7f3e" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form, defined and deprecated in RFC2980) using the supplied username and password. As with &lt;a href=&quot;#authinfo&quot;&gt;&quot;authinfo&quot;&lt;/a&gt; the password is sent in clear text.</source>
          <target state="translated">使用提供的用户名和密码对服务器进行身份验证（使用建议的NNTP V2 AUTHINFO SIMPLE表单（在RFC2980中定义和弃用））。与&lt;a href=&quot;#authinfo&quot;&gt;&amp;ldquo; authinfo&amp;rdquo;一样&lt;/a&gt;，密码以明文形式发送。</target>
        </trans-unit>
        <trans-unit id="6f9130bcae1a2dee757ab825f2972f22149b8d0e" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form, defined and deprecated in RFC2980) using the supplied username and password. As with &lt;a href=&quot;#authinfo&quot;&gt;authinfo&lt;/a&gt; the password is sent in clear text.</source>
          <target state="translated">使用提供的用户名和密码对服务器进行身份验证（使用建议的NNTP V2 AUTHINFO SIMPLE表单，该表单在RFC2980中定义和弃用）。与&lt;a href=&quot;#authinfo&quot;&gt;authinfo一样&lt;/a&gt;，密码以明文形式发送。</target>
        </trans-unit>
        <trans-unit id="561e59b47284192d792d6315e83a8df1bb4623e9" translate="yes" xml:space="preserve">
          <source>Authentication, Security, and Encryption</source>
          <target state="translated">认证、安全和加密</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="a250719f5509f4b060ed02cea92bc61a08d442f3" translate="yes" xml:space="preserve">
          <source>Author and Copyright Information</source>
          <target state="translated">作者和版权信息</target>
        </trans-unit>
        <trans-unit id="fd140dad60fa77aa1adfbcd64d1e9ea4bc89ff62" translate="yes" xml:space="preserve">
          <source>Author and Maintainer: The Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</source>
          <target state="translated">作者和维护者：Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e41e820954a6b297983a7b6986adfdc7c083ed60" translate="yes" xml:space="preserve">
          <source>Author and Modification History</source>
          <target state="translated">作者和修改历史</target>
        </trans-unit>
        <trans-unit id="dc4e711f40af1fee4327bcbd34d91d11e1b38a81" translate="yes" xml:space="preserve">
          <source>Author of this software makes no claim whatsoever about suitability, reliability, edability, editability or usability of this product, and should not be kept liable for any damage resulting from the use of it. If you can use it, you are in luck, if not, I should not be kept responsible. Keep a handy copy of your backup tape at hand.</source>
          <target state="translated">本软件的作者对本产品的适用性、可靠性、可编辑性、可用性不作任何声明,对因使用本产品而造成的任何损失不应承担任何责任。如果你能使用它,那是你的幸运,如果不能,我不应该承担任何责任。备用磁带随身携带。</target>
        </trans-unit>
        <trans-unit id="75a1f723a2c00ab3f9e540ebe5e3b630e531e2c3" translate="yes" xml:space="preserve">
          <source>Author: Mark Jason Dominus, Plover Systems (&lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; )</source>
          <target state="translated">作者：Plover Systems的Mark Jason Dominus（ &lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="b0d417f355d7d062d5dedda5f6e9d6e446d1132a" translate="yes" xml:space="preserve">
          <source>Author: Mark Jason Dominus, Plover Systems (&lt;code&gt;mjd-perl-ref+@plover.com&lt;/code&gt;)</source>
          <target state="translated">作者：Plover Systems的Mark Jason Dominus（ &lt;code&gt;mjd-perl-ref+@plover.com&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="4e4bc3d81e572248f45b55f87eb6a695cc5d7e17" translate="yes" xml:space="preserve">
          <source>Authors must not nest L&amp;lt;...&amp;gt; codes. For example, &quot;L&amp;lt;The L&amp;lt;Foo::Bar&amp;gt; man page&amp;gt;&quot; should be treated as an error.</source>
          <target state="translated">作者不得嵌套L &amp;lt;...&amp;gt;代码。例如，&amp;ldquo; L &amp;lt;L &amp;lt;Foo :: Bar&amp;gt;手册页&amp;gt;&amp;rdquo;应被视为错误。</target>
        </trans-unit>
        <trans-unit id="9a1f2888146e0b82120ccf28bf4584779813130b" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters are reminded that &quot;=over&quot; ... &quot;=back&quot; may map to several different constructs in your output format. For example, in converting Pod to (X)HTML, it can map to any of &amp;lt;ul&amp;gt;...&amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt;...&amp;lt;/ol&amp;gt;, &amp;lt;dl&amp;gt;...&amp;lt;/dl&amp;gt;, or &amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;. Similarly, &quot;=item&quot; can map to &amp;lt;li&amp;gt; or &amp;lt;dt&amp;gt;.</source>
          <target state="translated">提醒Pod格式化程序的作者，&amp;ldquo; = over&amp;rdquo; ...&amp;ldquo; = back&amp;rdquo;可能会映射到您输出格式中的几种不同结构。例如，在将Pod转换为（X）HTML时，它可以映射到&amp;lt;ul&amp;gt; ... &amp;lt;/ ul&amp;gt;，&amp;lt;ol&amp;gt; ... &amp;lt;/ ol&amp;gt;，&amp;lt;dl&amp;gt; ... &amp;lt;/ dl&amp;gt;中的任何一个或&amp;lt;blockquote&amp;gt; ... &amp;lt;/ blockquote&amp;gt;。同样，&amp;ldquo; = item&amp;rdquo;可以映射到&amp;lt;li&amp;gt;或&amp;lt;dt&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="80bad0a974c0d7ed8e69ae0a2451cf949509d806" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters should note that this construct:</source>
          <target state="translated">花苞格式化的作者应该注意到这个构造。</target>
        </trans-unit>
        <trans-unit id="0772af8ca884a475bc6c000e8a2e7ecd3771d821" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Parser, comes with modern versions of Perl.</source>
          <target state="translated">Pod格式化/处理器的作者应尽力避免编写自己的Pod解析器。在CPAN中已经有好几个,有各种不同的界面风格--其中一个Pod::Parser,是与现代版本的Perl一起出现的。</target>
        </trans-unit>
        <trans-unit id="ee6ba2eca154c452d912ba72284ef9425f5cac4c" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Simple, comes with modern versions of Perl.</source>
          <target state="translated">Pod格式化/处理器的作者应尽力避免编写自己的Pod解析器。在CPAN中已经有好几个,有各种各样的界面风格--其中一个,Pod::Simple,是与现代版本的Perl一起出现的。</target>
        </trans-unit>
        <trans-unit id="5f5a6b2c86d1c842fb78879cb9847a9b86de0e1d" translate="yes" xml:space="preserve">
          <source>Authors of formatter subclasses might find these methods useful to call on a parser object that you haven't started pulling tokens from yet:</source>
          <target state="translated">formatter子类的作者可能会发现,这些方法对你还没有开始从解析器对象中提取标记的解析器对象的调用很有用。</target>
        </trans-unit>
        <trans-unit id="ba749f31a8ceaa34419e1f1f52af7da1b1065181" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">自动递减SV中的值,必要时进行字符串到数字的转换。处理'get'魔术和操作符重载。</target>
        </trans-unit>
        <trans-unit id="cabef034701dc195b619657e11c47b3b4c7ed2cb" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">自动递减SV中的值,必要时进行字符串到数字的转换。处理运算符重载。跳过处理 &quot;get &quot;魔法。</target>
        </trans-unit>
        <trans-unit id="f8df54de50b8630f73dd7c3210d2ed53c7051734" translate="yes" xml:space="preserve">
          <source>Auto-increment and Auto-decrement</source>
          <target state="translated">自动递增和自动递减。</target>
        </trans-unit>
        <trans-unit id="9c2549c4f8e7b5156ddcd16c47fe624753b70037" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">自动递增SV中的值,必要时进行字符串到数字的转换。处理'get'魔术和操作符重载。</target>
        </trans-unit>
        <trans-unit id="11123412c221a7c2bf77f34ba93ea1498be1bd77" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">自动递增SV中的值,必要时进行字符串到数字的转换。处理运算符重载。跳过处理 &quot;get &quot;魔法。</target>
        </trans-unit>
        <trans-unit id="95b64723d9f40505396f5971cbc44d69372e59a7" translate="yes" xml:space="preserve">
          <source>Auto-upgrade</source>
          <target state="translated">Auto-upgrade</target>
        </trans-unit>
        <trans-unit id="57a4f42cae4d12771bda9f458a5b76498da8ce37" translate="yes" xml:space="preserve">
          <source>AutoLoader</source>
          <target state="translated">AutoLoader</target>
        </trans-unit>
        <trans-unit id="4bbd7ae289ef059e5890696f9cb149721a7b8e69" translate="yes" xml:space="preserve">
          <source>AutoLoader - load subroutines only on demand</source>
          <target state="translated">自动加载器--只在需要时加载子程序。</target>
        </trans-unit>
        <trans-unit id="6851ab5ce9e022d9cc5797875048cf4a3f08af3e" translate="yes" xml:space="preserve">
          <source>AutoLoader may fail to find the autosplit files (or even find the wrong ones) in cases where &lt;code&gt;@INC&lt;/code&gt; contains relative paths, &lt;b&gt;and&lt;/b&gt; the program does &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;@INC&lt;/code&gt; 包含相对路径，&lt;b&gt;并且&lt;/b&gt;程序执行 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; ，则AutoLoader可能无法找到自动分割的文件（甚至找不到错误的文件）。</target>
        </trans-unit>
        <trans-unit id="4651f865ebaf11dee249fb89b162cf3da62c9078" translate="yes" xml:space="preserve">
          <source>AutoLoader may fail to find the autosplit files (or even find the wrong ones) in cases where &lt;code&gt;@INC&lt;/code&gt; contains relative paths, &lt;b&gt;and&lt;/b&gt; the program does &lt;code&gt;chdir&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;@INC&lt;/code&gt; 包含相对路径，&lt;b&gt;并且&lt;/b&gt;程序执行 &lt;code&gt;chdir&lt;/code&gt; ，则AutoLoader可能无法找到自动分割的文件（甚至找不到错误的文件）。</target>
        </trans-unit>
        <trans-unit id="5080d78f65857a5bb4650061f6068b73782d0765" translate="yes" xml:space="preserve">
          <source>AutoLoader vs. SelfLoader</source>
          <target state="translated">自动加载器与自加载器</target>
        </trans-unit>
        <trans-unit id="8a635037412af6ace383fa21d0d50db8f0393e57" translate="yes" xml:space="preserve">
          <source>AutoLoaders prior to Perl 5.002 had a slightly different interface. Any old modules which use &lt;b&gt;AutoLoader&lt;/b&gt; should be changed to the new calling style. Typically this just means changing a require to a use, adding the explicit &lt;code&gt;'AUTOLOAD'&lt;/code&gt; import if needed, and removing &lt;b&gt;AutoLoader&lt;/b&gt; from &lt;code&gt;@ISA&lt;/code&gt; .</source>
          <target state="translated">Perl 5.002之前的AutoLoader界面略有不同。任何使用&lt;b&gt;AutoLoader的&lt;/b&gt;旧模块都应更改为新的调用样式。通常，这仅意味着将需求更改为使用，如果需要，添加显式的 &lt;code&gt;'AUTOLOAD'&lt;/code&gt; 导入，并从 &lt;code&gt;@ISA&lt;/code&gt; 删除&lt;b&gt;AutoLoader&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="7e1e103fc57cef534d77a1863a7beda04c276011" translate="yes" xml:space="preserve">
          <source>AutoLoaders prior to Perl 5.002 had a slightly different interface. Any old modules which use &lt;b&gt;AutoLoader&lt;/b&gt; should be changed to the new calling style. Typically this just means changing a require to a use, adding the explicit &lt;code&gt;'AUTOLOAD'&lt;/code&gt; import if needed, and removing &lt;b&gt;AutoLoader&lt;/b&gt; from &lt;code&gt;@ISA&lt;/code&gt;.</source>
          <target state="translated">Perl 5.002之前的AutoLoader界面略有不同。任何使用&lt;b&gt;AutoLoader的&lt;/b&gt;旧模块都应更改为新的调用样式。通常，这仅意味着将需求更改为使用，如果需要，添加显式的 &lt;code&gt;'AUTOLOAD'&lt;/code&gt; 导入，并从 &lt;code&gt;@ISA&lt;/code&gt; 删除&lt;b&gt;AutoLoader&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="56be52307d7f516628d0435d04dbf15ef2be8e1c" translate="yes" xml:space="preserve">
          <source>AutoSplit</source>
          <target state="translated">AutoSplit</target>
        </trans-unit>
        <trans-unit id="141ac9ea73e406af3a95ffd453d7845aea91bee3" translate="yes" xml:space="preserve">
          <source>AutoSplit - split a package for autoloading</source>
          <target state="translated">AutoSplit-分割一个包以实现自动加载。</target>
        </trans-unit>
        <trans-unit id="68a652cb711d8eb8f8b2dadb0dc16bdffbba498d" translate="yes" xml:space="preserve">
          <source>Autocreating constants</source>
          <target state="translated">自动创建常量</target>
        </trans-unit>
        <trans-unit id="52fe0335e51acfb62f3dfd3073b3227b5b8c4846" translate="yes" xml:space="preserve">
          <source>Autodeferring</source>
          <target state="translated">Autodeferring</target>
        </trans-unit>
        <trans-unit id="f3589c4e74b1463fb3c579cd588ce9598fdbe87e" translate="yes" xml:space="preserve">
          <source>Autodie uses a simple set of categories to group together similar built-ins. Requesting a category type (starting with a colon) will enable autodie for all built-ins beneath that category. For example, requesting &lt;code&gt;:file&lt;/code&gt; will enable autodie for &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Autodie使用一组简单的类别将相似的内置组件组合在一起。请求类别类型（以冒号开头）将为该类别下的所有内置插件启用自动diedie。例如，request &lt;code&gt;:file&lt;/code&gt; 将启用autodie的 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d86d0ceb4ab6dfa49a2928ed69a6b234345c4271" translate="yes" xml:space="preserve">
          <source>Autodie uses a simple set of categories to group together similar built-ins. Requesting a category type (starting with a colon) will enable autodie for all built-ins beneath that category. For example, requesting &lt;code&gt;:file&lt;/code&gt; will enable autodie for &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;fcntl&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt; and &lt;code&gt;sysopen&lt;/code&gt;.</source>
          <target state="translated">Autodie使用一组简单的类别将相似的内置组件组合在一起。请求类别类型（以冒号开头）将为该类别下的所有内置插件启用自动diedie。例如，请求 &lt;code&gt;:file&lt;/code&gt; 将启用autodie的 &lt;code&gt;close&lt;/code&gt; ， &lt;code&gt;fcntl&lt;/code&gt; ， &lt;code&gt;open&lt;/code&gt; 和 &lt;code&gt;sysopen&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f410fe9b046b8c8a478048e83efc2672d42d3c9c" translate="yes" xml:space="preserve">
          <source>Autodying &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; will generate an exception if &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns false with any other error.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 返回false以及其他任何错误，则自动染色的 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 将生成异常。</target>
        </trans-unit>
        <trans-unit id="dfa0c806bb2bafe199faa77554873951783b04df" translate="yes" xml:space="preserve">
          <source>Autodying &lt;code&gt;flock&lt;/code&gt; will generate an exception if &lt;code&gt;flock&lt;/code&gt; returns false with any other error.</source>
          <target state="translated">如果 &lt;code&gt;flock&lt;/code&gt; 返回false以及其他任何错误，则autodying &lt;code&gt;flock&lt;/code&gt; 将生成异常。</target>
        </trans-unit>
        <trans-unit id="3fa81ba949fafdad4688aed6d9380f82976ca9d7" translate="yes" xml:space="preserve">
          <source>Autoloading</source>
          <target state="translated">Autoloading</target>
        </trans-unit>
        <trans-unit id="a71f8461a563c747e56f2cb5fb124e64328506d5" translate="yes" xml:space="preserve">
          <source>Autoloading and package lexicals</source>
          <target state="translated">自动加载和包词法</target>
        </trans-unit>
        <trans-unit id="24023d5e4bccdad4a40c403d058e7c856f75ea71" translate="yes" xml:space="preserve">
          <source>Autoloading with XSUBs</source>
          <target state="translated">用XSUBs自动加载</target>
        </trans-unit>
        <trans-unit id="ea5735f59ad896a38c6b806f8d8b02abba9762e7" translate="yes" xml:space="preserve">
          <source>Automatic binary installation</source>
          <target state="translated">自动安装二进制文件</target>
        </trans-unit>
        <trans-unit id="e7b3540721074f2b16f8319edcdb7f16ebcac6ca" translate="yes" xml:space="preserve">
          <source>Automatic filehandle closure</source>
          <target state="translated">自动关闭文件手柄</target>
        </trans-unit>
        <trans-unit id="4347ed90164094c8291f74a6e4466cefbf468214" translate="yes" xml:space="preserve">
          <source>Automatic pipe flushing</source>
          <target state="translated">自动冲洗管道</target>
        </trans-unit>
        <trans-unit id="b890d9b67b4f885e928a5dbcadc3dec7cd34f3ad" translate="yes" xml:space="preserve">
          <source>Automatically generate XSUBs basing on function declarations in the header file. The package &lt;code&gt;C::Scan&lt;/code&gt; should be installed. If this option is specified, the name of the header file may look like &lt;code&gt;NAME1,NAME2&lt;/code&gt; . In this case NAME1 is used instead of the specified string, but XSUBs are emitted only for the declarations included from file NAME2.</source>
          <target state="translated">根据头文件中的函数声明自动生成XSUB。应该安装软件包 &lt;code&gt;C::Scan&lt;/code&gt; 。如果指定了此选项，则头文件的名称可能类似于 &lt;code&gt;NAME1,NAME2&lt;/code&gt; 。在这种情况下，将使用NAME1代替指定的字符串，但是仅针对文件NAME2中包含的声明发射XSUB。</target>
        </trans-unit>
        <trans-unit id="5d64745dc0e8fe8b3b6097336c3b9ed3a673cecd" translate="yes" xml:space="preserve">
          <source>Automatically generate XSUBs basing on function declarations in the header file. The package &lt;code&gt;C::Scan&lt;/code&gt; should be installed. If this option is specified, the name of the header file may look like &lt;code&gt;NAME1,NAME2&lt;/code&gt;. In this case NAME1 is used instead of the specified string, but XSUBs are emitted only for the declarations included from file NAME2.</source>
          <target state="translated">根据头文件中的函数声明自动生成XSUB。软件包 &lt;code&gt;C::Scan&lt;/code&gt; 应该被安装。如果指定了此选项，则头文件的名称可能类似于 &lt;code&gt;NAME1,NAME2&lt;/code&gt; 。在这种情况下，将使用NAME1代替指定的字符串，但是仅针对文件NAME2中包含的声明发射XSUB。</target>
        </trans-unit>
        <trans-unit id="974a6c8e46a4b4db1ad3a13139d3950f13a09a91" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--help&lt;/b&gt; and &lt;b&gt;-?&lt;/b&gt; options if the application did not specify a handler for this option itself.</source>
          <target state="translated">自动为&lt;b&gt;--help&lt;/b&gt;和&lt;b&gt;-？&lt;/b&gt;提供支持 如果应用程序未为此选项本身指定处理程序，则为options。</target>
        </trans-unit>
        <trans-unit id="909a15529b11dbad33480554d0c112bc56821029" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--version&lt;/b&gt; option if the application did not specify a handler for this option itself.</source>
          <target state="translated">如果应用程序未为此选项本身指定处理程序，则自动为&lt;b&gt;--version&lt;/b&gt;选项提供支持。</target>
        </trans-unit>
        <trans-unit id="859ddcc1d54c8f56f6fc79d681322ff6800ab918" translate="yes" xml:space="preserve">
          <source>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- &lt;code&gt;__CALLER__&lt;/code&gt; , which may be specified as the qualifier of an attribute:</source>
          <target state="translated">自动性通常在它们实际绑定的模块中最常用，并且需要将其属性导出到调用它们的任何模块。为方便 &lt;code&gt;__CALLER__&lt;/code&gt; ，Attribute :: Handlers识别一个特殊的&amp;ldquo;伪类&amp;rdquo; __CALLER__，可以将其指定为属性的限定符：</target>
        </trans-unit>
        <trans-unit id="caebe3a78fcebc80600d1c2befdf4f9537e79eaa" translate="yes" xml:space="preserve">
          <source>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- &lt;code&gt;__CALLER__&lt;/code&gt;, which may be specified as the qualifier of an attribute:</source>
          <target state="translated">自动性通常在它们实际绑定的模块中最常用，并且需要将其属性导出到调用它们的任何模块。为方便 &lt;code&gt;__CALLER__&lt;/code&gt; ，Attribute :: Handlers识别一个特殊的&amp;ldquo;伪类&amp;rdquo; __CALLER__，可以将其指定为属性的限定符：</target>
        </trans-unit>
        <trans-unit id="b404ad26695e85bc7cc28bdc0dded7208f879f3b" translate="yes" xml:space="preserve">
          <source>Autovivification</source>
          <target state="translated">Autovivification</target>
        </trans-unit>
        <trans-unit id="bf3b722c40bbbb50ad0fb62696f5d22f07dbb403" translate="yes" xml:space="preserve">
          <source>AvFILL</source>
          <target state="translated">AvFILL</target>
        </trans-unit>
        <trans-unit id="90bf7946c287adae3d715c64ee31d396014df2f6" translate="yes" xml:space="preserve">
          <source>AvFILLp</source>
          <target state="translated">AvFILLp</target>
        </trans-unit>
        <trans-unit id="c275699a9fcc5b1df221a4afe6ee0192241a51b8" translate="yes" xml:space="preserve">
          <source>Available Plugins</source>
          <target state="translated">可用的插件</target>
        </trans-unit>
        <trans-unit id="3f5fe2a468e50383b2ee86c82b0cbc98dd7d8c3d" translate="yes" xml:space="preserve">
          <source>Available Since 0.05.</source>
          <target state="translated">自0.05起可用。</target>
        </trans-unit>
        <trans-unit id="a1689bbab8d96444cb240ecc94b27e3bd6e1fa9d" translate="yes" xml:space="preserve">
          <source>Available Subroutines</source>
          <target state="translated">可用的子程序</target>
        </trans-unit>
        <trans-unit id="f8f5117038c185bf68b0bd33b349f9405e133955" translate="yes" xml:space="preserve">
          <source>Available exports</source>
          <target state="translated">现有出口</target>
        </trans-unit>
        <trans-unit id="00239624abff2fe9a2fd406296f776638259fff8" translate="yes" xml:space="preserve">
          <source>Available in Perls 5.8.1 and later. If set to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; , the pre-Perl-5.8.0 signal behaviour (which is immediate but unsafe) is restored. If set to &lt;code&gt;safe&lt;/code&gt; , then safe (but deferred) signals are used. See &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals) in perlipc&lt;/a&gt;.</source>
          <target state="translated">在Perls 5.8.1和更高版本中可用。如果设置为 &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; ，则将还原Perl-5.8.0之前的信号行为（立即但不安全）。如果设置为 &lt;code&gt;safe&lt;/code&gt; ，则使用安全（但延迟）信号。请参阅&lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;perlipc中的延迟信号（安全信号）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86ef598431b2f464d3fea7c4a79b483722ad9f02" translate="yes" xml:space="preserve">
          <source>Available in Perls 5.8.1 and later. If set to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt;, the pre-Perl-5.8.0 signal behaviour (which is immediate but unsafe) is restored. If set to &lt;code&gt;safe&lt;/code&gt;, then safe (but deferred) signals are used. See &lt;a href=&quot;perlipc#Deferred-Signals-%28Safe-Signals%29&quot;&gt;&quot;Deferred Signals (Safe Signals)&quot; in perlipc&lt;/a&gt;.</source>
          <target state="translated">在Perls 5.8.1和更高版本中可用。如果设置为 &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; ，则将还原Perl-5.8.0之前的信号行为（立即但不安全）。如果设置为 &lt;code&gt;safe&lt;/code&gt; ，则使用安全（但延迟）信号。请参阅&lt;a href=&quot;perlipc#Deferred-Signals-%28Safe-Signals%29&quot;&gt;perlipc中的&amp;ldquo;延迟信号（安全信号）&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06d7ad8e1c503f30109967f01a5055e60c428ad2" translate="yes" xml:space="preserve">
          <source>Available in version 2.22 and above.</source>
          <target state="translated">可在2.22及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="ca47c0994a656fab74100d8043c17430984bfc08" translate="yes" xml:space="preserve">
          <source>Available in version 2.32 and above</source>
          <target state="translated">可在2.32及以上版本中使用</target>
        </trans-unit>
        <trans-unit id="6a2ef8d70aa0a54d8ffae1859cac80b4b3ca0c60" translate="yes" xml:space="preserve">
          <source>Available in version 2.66 and above.</source>
          <target state="translated">可在2.66及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="46f1e6d4a99c839646d86f37c67e8ce5c790c2f7" translate="yes" xml:space="preserve">
          <source>Available in version 2.77 and above.</source>
          <target state="translated">可在2.77及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="1ee0ed3a84dce710c7a16f8db82978050c4d2850" translate="yes" xml:space="preserve">
          <source>Available in version 2.99 and above.</source>
          <target state="translated">可在2.99及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="d74a27e4b35b5f01b8ce5c3169c1b5a135f15fe4" translate="yes" xml:space="preserve">
          <source>Available in version 3.00 and above.</source>
          <target state="translated">可在3.00及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="a51b57f95b46e8e4e842d85639326f6206ff272d" translate="yes" xml:space="preserve">
          <source>Available in version 6.18 and above.</source>
          <target state="translated">可在6.18及以上版本使用。</target>
        </trans-unit>
        <trans-unit id="c501834b7b0b901f2df0d6603e7d6136330ca271" translate="yes" xml:space="preserve">
          <source>Available in version 6.30_01 and above.</source>
          <target state="translated">在6.30_01及以上版本中可用。</target>
        </trans-unit>
        <trans-unit id="fe2902c53bc06bcbcd50a3060b02d4d1a785d162" translate="yes" xml:space="preserve">
          <source>Available in version 6.30_02 and above.</source>
          <target state="translated">在6.30_02及以上版本中可用。</target>
        </trans-unit>
        <trans-unit id="eb07b303f6d617426c6371968300dfb4f3ae0614" translate="yes" xml:space="preserve">
          <source>Available in version 6.31 and above.</source>
          <target state="translated">可在6.31及以上版本使用。</target>
        </trans-unit>
        <trans-unit id="e2eb2ee2a8a2421e0f16491afdee27929c55a640" translate="yes" xml:space="preserve">
          <source>Available in version 6.46 and above.</source>
          <target state="translated">可在6.46及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="7b80e477803719c627e591ee3d93e9c48ad902d2" translate="yes" xml:space="preserve">
          <source>Available in version 6.48 and above.</source>
          <target state="translated">可在6.48及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="6813343f2b8479035fb49fea7be4fff847bf5d84" translate="yes" xml:space="preserve">
          <source>Available in version 6.51_01 and above.</source>
          <target state="translated">在6.51_01及以上版本中可用。</target>
        </trans-unit>
        <trans-unit id="aec275cec443caa644465799fc156b88fcadd8ce" translate="yes" xml:space="preserve">
          <source>Available in version 6.52 and above.</source>
          <target state="translated">可在6.52及以上版本使用。</target>
        </trans-unit>
        <trans-unit id="4c5736820a885b4b84bf41953dc520dbc9201d97" translate="yes" xml:space="preserve">
          <source>Available in version 6.5503 and above.</source>
          <target state="translated">可在6.5503及以上版本使用。</target>
        </trans-unit>
        <trans-unit id="50ef4d62519ad32b490887468033714841e5c394" translate="yes" xml:space="preserve">
          <source>Available in version 6.55_03 and above.</source>
          <target state="translated">在6.55_03及以上版本中可用。</target>
        </trans-unit>
        <trans-unit id="b94a4ea271ebeb34f1da9b94033460c66ab594da" translate="yes" xml:space="preserve">
          <source>Available in version 6.57_02 and above.</source>
          <target state="translated">在6.57_02及以上版本中可用。</target>
        </trans-unit>
        <trans-unit id="608b36cf2b4b343801fc146cfc4244281c6223d0" translate="yes" xml:space="preserve">
          <source>Available in version 6.64 and above.</source>
          <target state="translated">可在6.64及以上版本使用。</target>
        </trans-unit>
        <trans-unit id="35008f0927cc370d80fa1feb2cb101b493da804e" translate="yes" xml:space="preserve">
          <source>Available in version 6.7501 and above.</source>
          <target state="translated">可在6.7501及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="8a0f8c774f58768a8219ed32fc69bb6c645c818c" translate="yes" xml:space="preserve">
          <source>Available in version 6.8305 and above.</source>
          <target state="translated">可在6.8305及以上版本使用。</target>
        </trans-unit>
        <trans-unit id="b1a55162e32a4d313034aeda2facf36c09febf1e" translate="yes" xml:space="preserve">
          <source>Available in version 6.8502 and above.</source>
          <target state="translated">可在6.8502及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="3781d883fbe89e1fc4d95fc3c8a343771b42879b" translate="yes" xml:space="preserve">
          <source>Available in version 7.12 and above.</source>
          <target state="translated">可在7.12及以上版本使用。</target>
        </trans-unit>
        <trans-unit id="0d6ce3bbbc75b8e9071a24da666baed09d9b758d" translate="yes" xml:space="preserve">
          <source>Available on 64 bit OpenVMS 8.2 and later. (VMS)</source>
          <target state="translated">可在64位OpenVMS 8.2及以上版本上使用。(VMS)</target>
        </trans-unit>
        <trans-unit id="61cd670e85d7eb394067cdccaf9865a921e8dfe4" translate="yes" xml:space="preserve">
          <source>Available only for socket handles, and it does what the &lt;code&gt;ioctlsocket()&lt;/code&gt; call in the Winsock API does. (Win32)</source>
          <target state="translated">仅适用于套接字句柄，它执行Winsock API中的 &lt;code&gt;ioctlsocket()&lt;/code&gt; 调用。（Win32的）</target>
        </trans-unit>
        <trans-unit id="7ff7a29d7d279f81c65111e3969b0de8be5b1d10" translate="yes" xml:space="preserve">
          <source>Available only for socket handles. (RISC OS)</source>
          <target state="translated">仅适用于插座手柄。(RISC OS)</target>
        </trans-unit>
        <trans-unit id="9f1e3ff1138fe80a24c7ddf73407362168941db0" translate="yes" xml:space="preserve">
          <source>Available only under threaded builds, this function allocates an entry in &lt;code&gt;PL_stashpad&lt;/code&gt; for the stash passed to it.</source>
          <target state="translated">该函数仅在线程构建中可用，该函数在 &lt;code&gt;PL_stashpad&lt;/code&gt; 中为传递给它的存储空间分配一个条目。</target>
        </trans-unit>
        <trans-unit id="24db3617e94fd8213371a29596a3d186b94b903d" translate="yes" xml:space="preserve">
          <source>Available since 0.05.</source>
          <target state="translated">自0.05日起可使用。</target>
        </trans-unit>
        <trans-unit id="8904628a4cafc1997d22ed36de689160cc550e45" translate="yes" xml:space="preserve">
          <source>Available since 0.14.</source>
          <target state="translated">从0.14开始可用。</target>
        </trans-unit>
        <trans-unit id="47b9977311f14febdb908b3d7c8768e488ba1bdf" translate="yes" xml:space="preserve">
          <source>Available since 0.15.</source>
          <target state="translated">自0.15日起可使用。</target>
        </trans-unit>
        <trans-unit id="484973f71a15c235b16dffbc3bc34be0d16c15f0" translate="yes" xml:space="preserve">
          <source>Available since 0.19.</source>
          <target state="translated">自0.19日起可用。</target>
        </trans-unit>
        <trans-unit id="cf20cba49d40f80adc31be98bf7c874514e9c65b" translate="yes" xml:space="preserve">
          <source>Available since version 1.000020.</source>
          <target state="translated">自1.000020版本起可用。</target>
        </trans-unit>
        <trans-unit id="b4ebee27a76026f487f2506be21a330fd5bb55de" translate="yes" xml:space="preserve">
          <source>Available since version 2.141170.</source>
          <target state="translated">自2.141170版本起可用。</target>
        </trans-unit>
        <trans-unit id="04c0a2e766dbfbf8f4dc8178b6428ab302e4b061" translate="yes" xml:space="preserve">
          <source>Avar Arnfjord Bjarmason &amp;lt;avar@cpan.org&amp;gt;</source>
          <target state="translated">Avar Arnfjord Bjarmason &amp;lt;avar@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e829311778d72727fd390df6d086e72d016b6e9b" translate="yes" xml:space="preserve">
          <source>Avoid /usr/ucb/cc.</source>
          <target state="translated">避免使用/usr/ucb/cc。</target>
        </trans-unit>
        <trans-unit id="20382d66f57ab5b9e0eec4292fa20991e9ee50cf" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; where using &lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; and &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; would work.</source>
          <target state="translated">避免在使用 &lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; 和 &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; 情况下使用 &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="653557f5998e677614fe1c110b44a8530b1a3295" translate="yes" xml:space="preserve">
          <source>Avoid assignments in conditionals, but if they're unavoidable, use extra paren, e.g. &quot;if (a &amp;amp;&amp;amp; (b = c)) ...&quot;</source>
          <target state="translated">避免在条件条件中进行赋值，但是如果不可避免，请使用额外的括号，例如&amp;ldquo; if（a &amp;amp;&amp;amp;（b = c））...&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="12cd7881c58cc2ba233002bb3f616c6a3c8332a8" translate="yes" xml:space="preserve">
          <source>Avoid barewords if you can, especially all lowercase ones. You can't tell by just looking at it whether a bareword is a function or a string. By using quotes on strings and parentheses on function calls, you won't ever get them confused.</source>
          <target state="translated">尽量避免使用裸词,尤其是所有小写的裸词。仅仅看一眼,你就无法判断一个裸词是函数还是字符串。通过在字符串上使用引号,在函数调用上使用括号,你就不会把它们弄混了。</target>
        </trans-unit>
        <trans-unit id="a2c60caa765bc1191575d1eafdff1bfe2d3195d5" translate="yes" xml:space="preserve">
          <source>Avoid class name tests like: &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; . Generally you can delete the &lt;code&gt;eq 'FOO'&lt;/code&gt; part with no harm at all. Let the objects look after themselves! Generally, avoid hard-wired class names as far as possible.</source>
          <target state="translated">避免类名称测试，例如： &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; 。通常，您可以删除 &lt;code&gt;eq 'FOO'&lt;/code&gt; 部分而完全没有伤害。让物体照顾自己！通常，请尽量避免使用硬连线的类名。</target>
        </trans-unit>
        <trans-unit id="6c6177d46cc76c5db51cee88fceed0a2c4936349" translate="yes" xml:space="preserve">
          <source>Avoid class name tests like: &lt;code&gt;die &quot;Invalid&quot; unless ref $ref eq 'FOO'&lt;/code&gt;. Generally you can delete the &lt;code&gt;eq 'FOO'&lt;/code&gt; part with no harm at all. Let the objects look after themselves! Generally, avoid hard-wired class names as far as possible.</source>
          <target state="translated">避免类名称测试，例如： &lt;code&gt;die &quot;Invalid&quot; unless ref $ref eq 'FOO'&lt;/code&gt; 。通常，您可以删除 &lt;code&gt;eq 'FOO'&lt;/code&gt; 部分而完全没有伤害。让物体自己照顾自己！通常，请尽量避免使用硬连接的类名。</target>
        </trans-unit>
        <trans-unit id="98206b093bcf40d6e074eb698543fd4b6a25d539" translate="yes" xml:space="preserve">
          <source>Avoid keeping any state information in your packages. It makes it difficult for multiple other packages to use yours. Keep state information in objects.</source>
          <target state="translated">避免在你的软件包中保留任何状态信息。这使得其他多个包难以使用你的包。将状态信息保存在对象中。</target>
        </trans-unit>
        <trans-unit id="b40cce256d04ce45459ded87307f5f3e8ae2760b" translate="yes" xml:space="preserve">
          <source>Avoid libucb.</source>
          <target state="translated">避免libucb。</target>
        </trans-unit>
        <trans-unit id="b3ba9403766f60fa8e210155287efa18e1a9e739" translate="yes" xml:space="preserve">
          <source>Avoid starting a new top-level hierarchy, especially if a suitable hierarchy already exists under which you could place your module.</source>
          <target state="translated">避免建立一个新的顶层结构,特别是如果已经有一个合适的层次结构存在,你可以把你的模块放在这个层次结构下。</target>
        </trans-unit>
        <trans-unit id="e368cb46427a0a7114b3f3aa59a320144f3a18b6" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary quotes and stringification</source>
          <target state="translated">避免不必要的引号和字符串化</target>
        </trans-unit>
        <trans-unit id="fd4b693367a701b3345901dbd6d82b5f0d6ce929" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt;) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a &lt;code&gt;foreach()&lt;/code&gt; loop or the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; function instead.</source>
          <target state="translated">避免在无效的上下文中使用 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; ）或`backticks`，即当您丢弃它们的返回值时。这些函数都有返回值，因此请使用它们。否则，请改用 &lt;code&gt;foreach()&lt;/code&gt; 循环或 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="4d1b147c04752308a754e45a088f0a5ced1e3189" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;grep()&lt;/code&gt; (or &lt;code&gt;map()&lt;/code&gt;) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a &lt;code&gt;foreach()&lt;/code&gt; loop or the &lt;code&gt;system()&lt;/code&gt; function instead.</source>
          <target state="translated">避免在void上下文中使用 &lt;code&gt;grep()&lt;/code&gt; （或 &lt;code&gt;map()&lt;/code&gt; ）或`backticks`，即当您丢弃它们的返回值时。这些函数都有返回值，因此请使用它们。否则，请改用 &lt;code&gt;foreach()&lt;/code&gt; 循环或 &lt;code&gt;system()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="342c7154cb2c0ee3ba1afbccab12770600c98259" translate="yes" xml:space="preserve">
          <source>Avoid using hardcoded test numbers whenever possible (the EXPECTED/GOT found in t/op/tie.t is much more maintainable, and gives better failure reports).</source>
          <target state="translated">尽可能避免使用硬编码的测试号(在t/op/tie.t中找到的EXPECTED/GOT更容易维护,并且提供更好的故障报告)。</target>
        </trans-unit>
        <trans-unit id="67de3787b457172bffd90b9f3faae7435e0dae2f" translate="yes" xml:space="preserve">
          <source>Avoid using qx// and system() unless you are testing for them. If you do use them, make sure that you cover _all_ perl platforms.</source>
          <target state="translated">避免使用qx//和system(),除非你正在测试它们。如果你确实使用了它们,请确保你覆盖了所有的perl平台。</target>
        </trans-unit>
        <trans-unit id="0e92b74d5a979c26e7eb18be8603b8359a1d07fd" translate="yes" xml:space="preserve">
          <source>Avoiding Pipe Deadlocks</source>
          <target state="translated">避免管道僵局</target>
        </trans-unit>
        <trans-unit id="6e3313e507db79bbbaea78fb241509ccc328aba1" translate="yes" xml:space="preserve">
          <source>Avoiding repetitions</source>
          <target state="translated">避免重复</target>
        </trans-unit>
        <trans-unit id="3721e8be2f4b8bf2c63f63312cdfa53888d8430d" translate="yes" xml:space="preserve">
          <source>Awk Traps</source>
          <target state="translated">Awk Traps</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="960ee8c49bfa63dfbcee503c121c56c7a1e4101b" translate="yes" xml:space="preserve">
          <source>B *</source>
          <target state="translated">B *</target>
        </trans-unit>
        <trans-unit id="bd2b125cd8de6e0701cdac6ee17fd331ce4a27c2" translate="yes" xml:space="preserve">
          <source>B - The Perl Compiler Backend</source>
          <target state="translated">B-Perl编译器后端</target>
        </trans-unit>
        <trans-unit id="66cbfa5966aea2edc7cf64e032e34c46ba4f5e91" translate="yes" xml:space="preserve">
          <source>B line</source>
          <target state="translated">B线</target>
        </trans-unit>
        <trans-unit id="b918b0aa2af36ef03dc69f56d877870ae5fd0aee" translate="yes" xml:space="preserve">
          <source>B-regex</source>
          <target state="translated">B-regex</target>
        </trans-unit>
        <trans-unit id="19869e35c46a3e66430c519067a6d3e7137c0ed7" translate="yes" xml:space="preserve">
          <source>B. Execution</source>
          <target state="translated">B.执行</target>
        </trans-unit>
        <trans-unit id="f96bf8801b12adefc37c1e7fc962c4790aa5f3c1" translate="yes" xml:space="preserve">
          <source>B. K. Oxley (binkley),</source>
          <target state="translated">B.K.Oxley (binkley),</target>
        </trans-unit>
        <trans-unit id="4995b54293f85c5bb7976c9e655accd8fbd573ea" translate="yes" xml:space="preserve">
          <source>B. UNPACK</source>
          <target state="translated">B.拆包</target>
        </trans-unit>
        <trans-unit id="52b9020e3a04e67bbf5d1e8e1b850a5ce003849b" translate="yes" xml:space="preserve">
          <source>B::AV Methods</source>
          <target state="translated">B::AV方法</target>
        </trans-unit>
        <trans-unit id="dc2dfb25dd4ed2146470cd57ee95edac91f0306b" translate="yes" xml:space="preserve">
          <source>B::BINOP Method</source>
          <target state="translated">B::BINOP方法</target>
        </trans-unit>
        <trans-unit id="d151bd0866d55b4bfc156b14f486f63bf8d29ea8" translate="yes" xml:space="preserve">
          <source>B::BM Methods</source>
          <target state="translated">B::BM方法</target>
        </trans-unit>
        <trans-unit id="9055e894e201b212c293a29798f1091ff6d20491" translate="yes" xml:space="preserve">
          <source>B::COP Methods</source>
          <target state="translated">B::COP方法</target>
        </trans-unit>
        <trans-unit id="ad1f22ba3c95252a59969a1a218e1111bb139542" translate="yes" xml:space="preserve">
          <source>B::CV Methods</source>
          <target state="translated">B::CV方法</target>
        </trans-unit>
        <trans-unit id="c5987daa2aa6d7fac584555a51956a3b445f0843" translate="yes" xml:space="preserve">
          <source>B::Concise</source>
          <target state="translated">B::Concise</target>
        </trans-unit>
        <trans-unit id="0e99aa1c3be052d8105291584d6f4ee6b16f397c" translate="yes" xml:space="preserve">
          <source>B::Concise - Walk Perl syntax tree, printing concise info about ops</source>
          <target state="translated">B::Concise-漫步Perl语法树,打印关于操作的简洁信息。</target>
        </trans-unit>
        <trans-unit id="d98d2c8e235d9494074cb2fd60569e8b9c12b5d6" translate="yes" xml:space="preserve">
          <source>B::Concise::reset_sequence()</source>
          <target state="translated">B::Concise::reset_sequence()</target>
        </trans-unit>
        <trans-unit id="553185e97d716b58f74fa982526081cbc642ddf4" translate="yes" xml:space="preserve">
          <source>B::Debug</source>
          <target state="translated">B::Debug</target>
        </trans-unit>
        <trans-unit id="7b2b543f6bc70176bf812e6ac813955a4e8d32ab" translate="yes" xml:space="preserve">
          <source>B::Debug - Walk Perl syntax tree, printing debug info about ops</source>
          <target state="translated">B::Debug-漫步Perl语法树,打印关于OPS的调试信息。</target>
        </trans-unit>
        <trans-unit id="b2fba5e2c554e2a4492f4d6c8ba33e2e0b6a2475" translate="yes" xml:space="preserve">
          <source>B::Deparse</source>
          <target state="translated">B::Deparse</target>
        </trans-unit>
        <trans-unit id="45e0d250a6312bd5838511c6a45d0f47e7a90193" translate="yes" xml:space="preserve">
          <source>B::Deparse - Perl compiler backend to produce perl code</source>
          <target state="translated">B::Deparse-Perl编译器后端生成perl代码。</target>
        </trans-unit>
        <trans-unit id="ef79da6fd85d8fa02ee778f0544d6ba33e8b3b18" translate="yes" xml:space="preserve">
          <source>B::Deparse can also be used on a sub-by-sub basis from other perl programs.</source>
          <target state="translated">B::Deparse 也可以在其他 perl 程序的基础上逐一使用。</target>
        </trans-unit>
        <trans-unit id="187ec0fb4a4a04196e808c398a93708ba9275615" translate="yes" xml:space="preserve">
          <source>B::Deparse is a backend module for the Perl compiler that generates perl source code, based on the internal compiled structure that perl itself creates after parsing a program. The output of B::Deparse won't be exactly the same as the original source, since perl doesn't keep track of comments or whitespace, and there isn't a one-to-one correspondence between perl's syntactical constructions and their compiled form, but it will often be close. When you use the &lt;b&gt;-p&lt;/b&gt; option, the output also includes parentheses even when they are not required by precedence, which can make it easy to see if perl is parsing your expressions the way you intended.</source>
          <target state="translated">B :: Deparse是Perl编译器的后端模块，它基于perl自身在解析程序后创建的内部编译结构，生成perl源代码。 B :: Deparse的输出将与原始源不完全相同，因为perl不会跟踪注释或空格，并且perl的语法结构与其编译后的结构之间不存在一一对应的关系。形式，但通常会很接近。使用&lt;b&gt;-p&lt;/b&gt;选项时，即使优先级不需要括号，输出也会包含括号，这样可以很容易地查看perl是否按照您希望的方式解析表达式。</target>
        </trans-unit>
        <trans-unit id="fc31dbbc2ee8c07aa355011d5f82b2d63c5b6c00" translate="yes" xml:space="preserve">
          <source>B::GV Methods</source>
          <target state="translated">B::GV方法</target>
        </trans-unit>
        <trans-unit id="f507161ede02e20a9575d2189eb0e0194566355a" translate="yes" xml:space="preserve">
          <source>B::HV Methods</source>
          <target state="translated">B::HV方法</target>
        </trans-unit>
        <trans-unit id="e300bd8b4c95a3624e2aa219bf974f0118cef860" translate="yes" xml:space="preserve">
          <source>B::IO Methods</source>
          <target state="translated">B::IO方法</target>
        </trans-unit>
        <trans-unit id="35a3e95640c426b65cf8d850194a4f17b3215f07" translate="yes" xml:space="preserve">
          <source>B::IO objects derive from IO objects and you will get more information from the IO object itself.</source>
          <target state="translated">B::IO对象派生自IO对象,你将从IO对象本身获得更多信息。</target>
        </trans-unit>
        <trans-unit id="9329448ffaface57d41ef2b007c24eb18197a68b" translate="yes" xml:space="preserve">
          <source>B::IV Methods</source>
          <target state="translated">B::IV方法</target>
        </trans-unit>
        <trans-unit id="f3d775a1d64c4d9d033d742b01a011ef21c3139b" translate="yes" xml:space="preserve">
          <source>B::IV, B::NV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;:</source>
          <target state="translated">B::IV、B::NV、B::PV、B::PVIV、B::PVNV、B::PVMG、B::PVLV、B::AV、B::HV、B::CV、B::GV、B::FM、B::IO。这些类以明显的方式对应于名称相似的底层C结构。继承层次结构模仿了底层C语言的 &quot;继承&quot;。</target>
        </trans-unit>
        <trans-unit id="41ae1a755811beebf8ac2f49c8c1656753f2209c" translate="yes" xml:space="preserve">
          <source>B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;. For the 5.10.x branch, (</source>
          <target state="translated">B::IV、B::NV、B::RV、B::PV、B::PVIV、B::PVNV、B::PVMG、B::BM(5.9.5及更早)、B::PVLV、B::AV、B::HV、B::CV、B::GV、B::FM、B::IO。这些类以明显的方式对应于名称相似的底层C结构。继承层次结构模仿了底层C语言的 &quot;继承&quot;。对于5.10.x分支,(</target>
        </trans-unit>
        <trans-unit id="47e3586b1ed7a7d56d8afab1073b55905757ce29" translate="yes" xml:space="preserve">
          <source>B::LISTOP Method</source>
          <target state="translated">B::LISTOP方法</target>
        </trans-unit>
        <trans-unit id="04688acb0cbf70d25c11e0314b06463ce4bde512" translate="yes" xml:space="preserve">
          <source>B::LOGOP Method</source>
          <target state="translated">B::LOGOP方法</target>
        </trans-unit>
        <trans-unit id="7263ed2af022568be1b85d473eacf000486dd697" translate="yes" xml:space="preserve">
          <source>B::LOOP Methods</source>
          <target state="translated">B::LOOP方法</target>
        </trans-unit>
        <trans-unit id="83ceb8c6feb2e3fc2f3bf822a42dbcd07ff89ff2" translate="yes" xml:space="preserve">
          <source>B::MAGIC Methods</source>
          <target state="translated">B::MAGIC方法</target>
        </trans-unit>
        <trans-unit id="69a559c9b6f1bb1dde02c8b48310f4be42a91370" translate="yes" xml:space="preserve">
          <source>B::METHOP Methods (Since Perl 5.22)</source>
          <target state="translated">B::METHOP 方法 (自 Perl 5.22 起)</target>
        </trans-unit>
        <trans-unit id="ce0314b7717adf8f5e71d17e31bd593c95324507" translate="yes" xml:space="preserve">
          <source>B::NV Methods</source>
          <target state="translated">B::NV方法</target>
        </trans-unit>
        <trans-unit id="c0b4baaa7ca50074884462d7620fd16447077eec" translate="yes" xml:space="preserve">
          <source>B::OP Methods</source>
          <target state="translated">B::OP方法</target>
        </trans-unit>
        <trans-unit id="9f43dd0af65c2a7397a364fed7e94a6388954481" translate="yes" xml:space="preserve">
          <source>B::OP::terse</source>
          <target state="translated">B::OP::terse</target>
        </trans-unit>
        <trans-unit id="b8644ca464436a14d88fc7211463f2c65ed97695" translate="yes" xml:space="preserve">
          <source>B::Op_private</source>
          <target state="translated">B::Op_private</target>
        </trans-unit>
        <trans-unit id="67239ea053c2700f5ce63cb3454a4558b2cbf5e7" translate="yes" xml:space="preserve">
          <source>B::Op_private - OP op_private flag definitions</source>
          <target state="translated">B::Op_private-OP op_private标志定义</target>
        </trans-unit>
        <trans-unit id="5409024a3cb7db3e3ab0625fc65de3e420057bb4" translate="yes" xml:space="preserve">
          <source>B::PADLIST Methods</source>
          <target state="translated">B::PADLIST方法</target>
        </trans-unit>
        <trans-unit id="7aa1d371fde2d45d24f6903c528b83b6becc77cd" translate="yes" xml:space="preserve">
          <source>B::PADNAME Methods</source>
          <target state="translated">B::PADNAME方法</target>
        </trans-unit>
        <trans-unit id="f042ef0bca656a3a3db2a47dca50963fab567b10" translate="yes" xml:space="preserve">
          <source>B::PADNAMELIST Methods</source>
          <target state="translated">B::PADNAMELIST方法</target>
        </trans-unit>
        <trans-unit id="7fc794e6266342d3b9c5605f5dd3acf7f99c4eaf" translate="yes" xml:space="preserve">
          <source>B::PADOP Method</source>
          <target state="translated">B::PADOP方法</target>
        </trans-unit>
        <trans-unit id="3cfe6d3792643bf75e3768c357ceb15d1fcc2896" translate="yes" xml:space="preserve">
          <source>B::PMOP Methods</source>
          <target state="translated">B::PMOP方法</target>
        </trans-unit>
        <trans-unit id="935c8ee8b93bca030ffae3839fe2dd9b63ef8ee4" translate="yes" xml:space="preserve">
          <source>B::PV Methods</source>
          <target state="translated">B::PV方法</target>
        </trans-unit>
        <trans-unit id="2ae17602fe4096f70c3f88f15eb8e459f9c75ea9" translate="yes" xml:space="preserve">
          <source>B::PVLV Methods</source>
          <target state="translated">B::PVLV方法</target>
        </trans-unit>
        <trans-unit id="974a328507349d20edd58996d04366d5388a2f7c" translate="yes" xml:space="preserve">
          <source>B::PVMG Methods</source>
          <target state="translated">B::PVMG方法</target>
        </trans-unit>
        <trans-unit id="7210fef12d9bb7c60c3dee3ae3350db4f7b9f9ab" translate="yes" xml:space="preserve">
          <source>B::PVOP Method</source>
          <target state="translated">B::PVOP方法</target>
        </trans-unit>
        <trans-unit id="6455c3fb933990f5652e2d49c591cb379eb4bf8a" translate="yes" xml:space="preserve">
          <source>B::REGEXP Methods</source>
          <target state="translated">B::REGEXP方法</target>
        </trans-unit>
        <trans-unit id="5fb9902660751871b51829ac2f4124c1e0f71d1f" translate="yes" xml:space="preserve">
          <source>B::RV Methods</source>
          <target state="translated">B::RV方法</target>
        </trans-unit>
        <trans-unit id="1bc231286052c317542f678d841b72c83eca59c7" translate="yes" xml:space="preserve">
          <source>B::SV Methods</source>
          <target state="translated">B::SV方法</target>
        </trans-unit>
        <trans-unit id="ba72f1a9a3b75ef02445cdb3be5e5dfd9e626d0a" translate="yes" xml:space="preserve">
          <source>B::SVOP Methods</source>
          <target state="translated">B::SVOP方法</target>
        </trans-unit>
        <trans-unit id="6d49788efca655ce69693e7fc4afeb14e70c0677" translate="yes" xml:space="preserve">
          <source>B::Showlex</source>
          <target state="translated">B::Showlex</target>
        </trans-unit>
        <trans-unit id="950f98354a0be3d4d89c912c00828150ec365f96" translate="yes" xml:space="preserve">
          <source>B::Showlex - Show lexical variables used in functions or files</source>
          <target state="translated">B::Showlex-显示函数或文件中使用的词法变量。</target>
        </trans-unit>
        <trans-unit id="fdd28b59d6f44b83715e2f882acc2a2a5588e605" translate="yes" xml:space="preserve">
          <source>B::Terse</source>
          <target state="translated">B::Terse</target>
        </trans-unit>
        <trans-unit id="c493225f0157e4f61a98bb3974699f2af44cb46f" translate="yes" xml:space="preserve">
          <source>B::Terse - Walk Perl syntax tree, printing terse info about ops</source>
          <target state="translated">B::Terse-漫步在Perl语法树上,打印关于操作的简明信息。</target>
        </trans-unit>
        <trans-unit id="9f6685ca28bcfea09300907f0826a8f9a2c91850" translate="yes" xml:space="preserve">
          <source>B::UNOP Method</source>
          <target state="translated">B::UNOP方法</target>
        </trans-unit>
        <trans-unit id="69effd3b7e8802f540cc9b9e50328608e6736463" translate="yes" xml:space="preserve">
          <source>B::UNOP_AUX Methods (since 5.22)</source>
          <target state="translated">B::UNOP_AUX 方法 (自 5.22)</target>
        </trans-unit>
        <trans-unit id="c85e7a03e5bbe49c04256621164986ed11cb37ba" translate="yes" xml:space="preserve">
          <source>B::Xref</source>
          <target state="translated">B::Xref</target>
        </trans-unit>
        <trans-unit id="651c8208adb3fd49f31423f94f8ac43c0733aa36" translate="yes" xml:space="preserve">
          <source>B::Xref - Generates cross reference reports for Perl programs</source>
          <target state="translated">B::Xref-为Perl程序生成交叉引用报告。</target>
        </trans-unit>
        <trans-unit id="a61d2719382da67e2a1a2dbd76dd400accca9187" translate="yes" xml:space="preserve">
          <source>BACKWARD COMPATIBILITY AND DEPRECATION</source>
          <target state="translated">逆向相容性和去掉性</target>
        </trans-unit>
        <trans-unit id="e5b45b4fc983ac2702f9e777eee2ac1b1e5f0f20" translate="yes" xml:space="preserve">
          <source>BACKWARDS COMPATIBILITY</source>
          <target state="translated">逆向兼容性</target>
        </trans-unit>
        <trans-unit id="bef6eec96c16ae54f978beec72807557ca3a9eaf" translate="yes" xml:space="preserve">
          <source>BASIC METHODS</source>
          <target state="translated">基本方法</target>
        </trans-unit>
        <trans-unit id="aa6878b1c31a9420245df1daffb7b223338737a3" translate="yes" xml:space="preserve">
          <source>BBB</source>
          <target state="translated">BBB</target>
        </trans-unit>
        <trans-unit id="a76d28d6a4e36d4447b9f4c252abca9f3cac325b" translate="yes" xml:space="preserve">
          <source>BBEdit and TextWrangler</source>
          <target state="translated">BBEdit和TextWrangler</target>
        </trans-unit>
        <trans-unit id="8cf5cb57c99d3bbd6c48033a11d198c341ee5329" translate="yes" xml:space="preserve">
          <source>BEFORE YOU START WRITING A MODULE</source>
          <target state="translated">在你开始写一个模块之前。</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="d94255a33af2a233413bdca7bd8b5cd50ff62d1b" translate="yes" xml:space="preserve">
          <source>BEGIN blocks</source>
          <target state="translated">BEGIN块</target>
        </trans-unit>
        <trans-unit id="38cb5ebde363f32ca7879125654df658667bbf73" translate="yes" xml:space="preserve">
          <source>BEGIN failed--compilation aborted</source>
          <target state="translated">BEGIN failed--编译失败</target>
        </trans-unit>
        <trans-unit id="70821eae507ac85cc9e07ce2b4ef46d0ec3667a3" translate="yes" xml:space="preserve">
          <source>BEGIN not safe after errors--compilation aborted</source>
          <target state="translated">BEGIN出错后不安全--编译中止</target>
        </trans-unit>
        <trans-unit id="ed0ab3055b45605d8d3bfeee9675e3115e25dd63" translate="yes" xml:space="preserve">
          <source>BEGIN, UNITCHECK, CHECK, INIT and END</source>
          <target state="translated">BEGIN、UNITCHECK、CHECK、INIT和END。</target>
        </trans-unit>
        <trans-unit id="ee1ec7cf5d1203d7be37071bc2244af5ad59b465" translate="yes" xml:space="preserve">
          <source>BEHAVIOR HOOKS</source>
          <target state="translated">行为守则</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
