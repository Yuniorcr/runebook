<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="e8f4fc6abff769c701a3cd104bd7d5e13a65f76f" translate="yes" xml:space="preserve">
          <source>The configure phase occurs before any dynamic configuration has been attempted. Libraries required by the configure phase &lt;b&gt;must&lt;/b&gt; be available for use before the distribution building tool has been executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb35472fba52fde6c0d287b9880009008ce62bd4" translate="yes" xml:space="preserve">
          <source>The conformance test for the UCA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e8c71c043d1ee5895cf5c5a239168a7f0a8975" translate="yes" xml:space="preserve">
          <source>The confusion arises because people incorrectly assume that the sigil denotes the variable type.</source>
          <target state="translated">之所以出现这种混乱,是因为人们错误地认为sigil表示变量类型。</target>
        </trans-unit>
        <trans-unit id="72def2ab61e0c7e7dccd965b3f9393136d20aa03" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;pi&lt;/code&gt; and some handy multiples of it (pi2, pi4, and pip2 (pi/2) and pip4 (pi/4)) are also available if separately exported:</source>
          <target state="translated">如果单独导出，则常数 &lt;code&gt;pi&lt;/code&gt; 及其一些方便的倍数（pi2，pi4和pip2（pi / 2）和pip4（pi / 4））也可用：</target>
        </trans-unit>
        <trans-unit id="c81821f9e03375c52f91dde5667119328458dcfd" translate="yes" xml:space="preserve">
          <source>The constant function &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; returns a comparable number that represents the highest file version number that this version of Storable fully supports (but see discussion of &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; above). The constant &lt;code&gt;Storable::BIN_WRITE_VERSION_NV&lt;/code&gt; function returns what file version is written and might be less than &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; in some configurations.</source>
          <target state="translated">常量函数 &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; 返回一个可比较的数字，该数字表示该版本的Storable完全支持的最高文件版本号（但请参见上面有关 &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; 讨论）。常量 &lt;code&gt;Storable::BIN_WRITE_VERSION_NV&lt;/code&gt; 函数返回写入的文件版本，在某些配置中，该版本可能小于 &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1404d0959d5fe2f0dd1fe9c942e64fc147050eb7" translate="yes" xml:space="preserve">
          <source>The constants for specific &lt;code&gt;code&lt;/code&gt; values can be imported individually or using the &lt;code&gt;:signal_h_si_code&lt;/code&gt; tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9018d00ba0cf85500f9049cabc293077c6a815d2" translate="yes" xml:space="preserve">
          <source>The construct</source>
          <target state="translated">构造</target>
        </trans-unit>
        <trans-unit id="8226460345430ec3df47c2bd35c2d238766995a6" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;\$v{timep}=@{[$v{timep}=$arg]}&lt;/code&gt; used in the above example has a two-fold purpose: first, when this line is processed by &lt;b&gt;xsubpp&lt;/b&gt;, the Perl snippet &lt;code&gt;$v{timep}=$arg&lt;/code&gt; is evaluated. Second, the text of the evaluated snippet is output into the generated C file (inside a C comment)! During the processing of &lt;code&gt;char *host&lt;/code&gt; line, &lt;code&gt;$arg&lt;/code&gt; will evaluate to &lt;code&gt;ST(0)&lt;/code&gt; , and &lt;code&gt;$v{timep}&lt;/code&gt; will evaluate to &lt;code&gt;ST(1)&lt;/code&gt; .</source>
          <target state="translated">上例中使用的结构 &lt;code&gt;\$v{timep}=@{[$v{timep}=$arg]}&lt;/code&gt; 有两个目的：首先，当该行由&lt;b&gt;xsubpp&lt;/b&gt;处理时，Perl代码段 &lt;code&gt;$v{timep}=$arg&lt;/code&gt; 被求值。其次，将评估代码段的文本输出到生成的C文件中（在C注释内部）！在处理 &lt;code&gt;char *host&lt;/code&gt; 行时， &lt;code&gt;$arg&lt;/code&gt; 将评估为 &lt;code&gt;ST(0)&lt;/code&gt; ，而 &lt;code&gt;$v{timep}&lt;/code&gt; 将评估为 &lt;code&gt;ST(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f2f29b3b2c632054cc482de2585e44d1631920b" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;\$v{timep}=@{[$v{timep}=$arg]}&lt;/code&gt; used in the above example has a two-fold purpose: first, when this line is processed by &lt;b&gt;xsubpp&lt;/b&gt;, the Perl snippet &lt;code&gt;$v{timep}=$arg&lt;/code&gt; is evaluated. Second, the text of the evaluated snippet is output into the generated C file (inside a C comment)! During the processing of &lt;code&gt;char *host&lt;/code&gt; line, &lt;code&gt;$arg&lt;/code&gt; will evaluate to &lt;code&gt;ST(0)&lt;/code&gt;, and &lt;code&gt;$v{timep}&lt;/code&gt; will evaluate to &lt;code&gt;ST(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59007854896f819ee065a798da86e7867bce96e" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;new&lt;/code&gt; creates and returns an empty &lt;code&gt;TAP::Parser::YAMLish::Reader&lt;/code&gt; object.</source>
          <target state="translated">构造函数 &lt;code&gt;new&lt;/code&gt; 创建并返回一个空的 &lt;code&gt;TAP::Parser::YAMLish::Reader&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="1bad8668cdf1d431ad701326f6748ece18b79658" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;new&lt;/code&gt; creates and returns an empty &lt;code&gt;TAP::Parser::YAMLish::Writer&lt;/code&gt; object.</source>
          <target state="translated">构造函数 &lt;code&gt;new&lt;/code&gt; 创建并返回一个空的 &lt;code&gt;TAP::Parser::YAMLish::Writer&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="4c2fcf35a44aabf097cd59f3a3854953c70e5fcd" translate="yes" xml:space="preserve">
          <source>The constructor can also accept additional parameters that define the object. Let's write a real constructor for the &lt;code&gt;File&lt;/code&gt; class we used earlier:</source>
          <target state="translated">构造函数还可以接受定义该对象的其他参数。让我们为之前使用的 &lt;code&gt;File&lt;/code&gt; 类编写一个真正的构造函数：</target>
        </trans-unit>
        <trans-unit id="3a88176407788666ff0021721dd4e56b3400cf3f" translate="yes" xml:space="preserve">
          <source>The constructor creates a new object and optionally initialises it with a set of handles.</source>
          <target state="translated">构造函数创建一个新的对象,并可选择用一组句柄来初始化它。</target>
        </trans-unit>
        <trans-unit id="26002f2b8ad63b7adc28307355437aa48afa5d7b" translate="yes" xml:space="preserve">
          <source>The constructor for a &lt;code&gt;Net::Netrc&lt;/code&gt; object is not called new as it does not really create a new object. But instead is called &lt;code&gt;lookup&lt;/code&gt; as this is essentially what it does.</source>
          <target state="translated">&lt;code&gt;Net::Netrc&lt;/code&gt; 对象的构造函数未称为new，因为它实际上并未创建新对象。而是将其称为 &lt;code&gt;lookup&lt;/code&gt; 因为它本质上就是它的工作。</target>
        </trans-unit>
        <trans-unit id="5e4047980f5ac3eb3127d3d68b5f254e9299a0fd" translate="yes" xml:space="preserve">
          <source>The constructor for all the singletons used to represent modules, distributions, authors, and bundles. If the object already exists, this method returns the object; otherwise, it calls the constructor.</source>
          <target state="translated">用于表示模块、发行版、作者和捆绑的所有单子的构造函数。如果对象已经存在,本方法返回对象;否则,调用构造函数。</target>
        </trans-unit>
        <trans-unit id="392e17e9526fa6867e8438f1a219ca39e5568acc" translate="yes" xml:space="preserve">
          <source>The constructor must be passed a metadata structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54cf785d15de998f3ac18ade864f218319b1ee1" translate="yes" xml:space="preserve">
          <source>The constructor of a generated class can be passed a list of</source>
          <target state="translated">生成的类的构造函数可以传递一个列表,其中包括</target>
        </trans-unit>
        <trans-unit id="bb7df7aab984a9c0e691c8f805de279350cf56e0" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;Digest::MD5&lt;/code&gt; object which encapsulate the state of the MD5 message-digest algorithm.</source>
          <target state="translated">构造函数返回一个新的 &lt;code&gt;Digest::MD5&lt;/code&gt; 对象，该对象封装了MD5消息摘要算法的状态。</target>
        </trans-unit>
        <trans-unit id="2e6b2441df01bfc969fd7dfde15484f966dcaf52" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Color&lt;/code&gt; object. If &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; is not installed, returns undef.</source>
          <target state="translated">构造函数返回一个新的 &lt;code&gt;TAP::Formatter::Color&lt;/code&gt; 对象。如果未安装&lt;a href=&quot;../../term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt;，则返回undef。</target>
        </trans-unit>
        <trans-unit id="4747d0a8e21ed88de854df16a2a22a83e805b50c" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Color&lt;/code&gt; object. If &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term::ANSIColor&lt;/a&gt; is not installed, returns undef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972195b07373ba2fa384173c37fb399dc7626fb1" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Console::Session&lt;/code&gt; object.</source>
          <target state="translated">构造函数返回一个新的 &lt;code&gt;TAP::Formatter::Console::Session&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="64d08d3b354e3667ab5da2f82eaec44dd6d25ea5" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; object. If a &lt;a href=&quot;../harness&quot;&gt;TAP::Harness&lt;/a&gt; is created with no &lt;code&gt;formatter&lt;/code&gt; a &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; is automatically created. If any of the following options were given to TAP::Harness-&amp;gt;new they well be passed to this constructor which accepts an optional hashref whose allowed keys are:</source>
          <target state="translated">构造函数返回一个新的 &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; 对象。如果&lt;a href=&quot;../harness&quot;&gt;TAP ::线束&lt;/a&gt;与没有创建 &lt;code&gt;formatter&lt;/code&gt; 一个 &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; 自动创建。如果为TAP :: Harness-&amp;gt; new提供了以下任何选项，则可以将它们传递给此构造函数，该构造函数接受可选的hashref，其允许的键为：</target>
        </trans-unit>
        <trans-unit id="8909e70f1c9cdb1bc8623d8b0a2d889cffc98a88" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; object. If a &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; is created with no &lt;code&gt;formatter&lt;/code&gt; a &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; is automatically created. If any of the following options were given to TAP::Harness-&amp;gt;new they well be passed to this constructor which accepts an optional hashref whose allowed keys are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdf8ec5d8f9e8688b8b1e013d18928a0b5fdbbeb" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Harness&lt;/code&gt; object. It accepts an optional hashref whose allowed keys are:</source>
          <target state="translated">构造函数返回一个新的 &lt;code&gt;TAP::Harness&lt;/code&gt; 对象。它接受可选的hashref，其允许的键为：</target>
        </trans-unit>
        <trans-unit id="093c7ac00d4bfb4c1a8deee532d1b8ad2334e8c0" translate="yes" xml:space="preserve">
          <source>The constructor returns some object that encapsulate the state of the message-digest algorithm. You can add data to the object and finally ask for the digest. The &quot;XXX&quot; should of course be replaced by the proper name of the digest algorithm you want to use.</source>
          <target state="translated">构造函数返回一些封装了消息摘要算法状态的对象。你可以向该对象添加数据,最后要求得到摘要。当然,&quot;XXX &quot;应该用你要使用的摘要算法的正确名称来代替。</target>
        </trans-unit>
        <trans-unit id="b8c0174cc6aa4e80ad4122d0657361b0e191a979" translate="yes" xml:space="preserve">
          <source>The constructor should be passed a valid metadata structure but invalid structures are accepted. If no meta-spec version is provided, version 1.0 will be assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4929a7c6855e45789fbb16fa26a8399b54ccaf" translate="yes" xml:space="preserve">
          <source>The content from the __DATA__ block is not filtered. This is a serious limitation, e.g. for the &lt;a href=&quot;switch&quot;&gt;Switch&lt;/a&gt; module. See &lt;a href=&quot;http://search.cpan.org/perldoc?Switch#LIMITATIONS&quot;&gt;http://search.cpan.org/perldoc?Switch#LIMITATIONS&lt;/a&gt; for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ebdab724a22632fec3a1d054882b1bc817c7d6" translate="yes" xml:space="preserve">
          <source>The content of the here doc is treated just as it would be if the string were embedded in backticks. Thus the content is interpolated as though it were double quoted and then executed via the shell, with the results of the execution returned.</source>
          <target state="translated">Here doc的内容会被处理成和字符串被嵌入到反引号中一样。因此,内容会被插值,就像它是双引号一样,然后通过shell执行,并返回执行结果。</target>
        </trans-unit>
        <trans-unit id="2c33213d12b4d00abe49d77a5bff9aee654312d3" translate="yes" xml:space="preserve">
          <source>The content of the text chunk in the buffer is commonly exactly one complete line of input, up to and including a newline terminator, but there are situations where it is otherwise. The octets of the buffer may be intended to be interpreted as either UTF-8 or Latin-1. The function &lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt; tells you which. Do not use the &lt;code&gt;SvUTF8&lt;/code&gt; flag on this scalar, which may disagree with it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af50a9986dd8fc345d5bd2a482a8608eafdf212" translate="yes" xml:space="preserve">
          <source>The content of the text chunk in the buffer is commonly exactly one complete line of input, up to and including a newline terminator, but there are situations where it is otherwise. The octets of the buffer may be intended to be interpreted as either UTF-8 or Latin-1. The function &lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt; tells you which. Do not use the &lt;code&gt;SvUTF8&lt;/code&gt; flag on this scalar, which may disagree with it.</source>
          <target state="translated">缓冲区中文本块的内容通常恰好是一个完整的输入行，直到并包括换行符终止符，但是在某些情况下则不是这样。缓冲区的八位位组可以解释为UTF-8或Latin-1。函数&lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt;告诉您哪个。不要在此标量上使用 &lt;code&gt;SvUTF8&lt;/code&gt; 标志，这可能会与它不同。</target>
        </trans-unit>
        <trans-unit id="3c50b9c6cd39ffa60fa752e0357613216ec7e1d3" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;$/&lt;/code&gt; are used to determine what constitutes a line terminator.</source>
          <target state="translated">&lt;code&gt;$/&lt;/code&gt; 的内容用于确定什么构成行终止符。</target>
        </trans-unit>
        <trans-unit id="09777bcf55808641ba4d5a5b61fa0d9ce1740b32" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;$@&lt;/code&gt; immediately after autodie triggered an exception. This may be useful when dealing with modules such as &lt;a href=&quot;Text::Balanced&quot;&gt;Text::Balanced&lt;/a&gt; that set (but do not throw) &lt;code&gt;$@&lt;/code&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ca5978cb2d9772e7d9f41db4210fa03ba32d12" translate="yes" xml:space="preserve">
          <source>The contents of SVs may be printed using the &lt;code&gt;SVf&lt;/code&gt; format, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d18ed7c7a8db27a58a80fd58640cc3bbfe1bce" translate="yes" xml:space="preserve">
          <source>The contents of the Comment header field, if present. If no comment is present, the value will be undef. Note this is different from a zero length comment, which will return an empty string.</source>
          <target state="translated">评论头字段的内容(如果存在)。如果没有注释,值将为undef。注意,这与零长度的注释不同,后者将返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="f67589a8aeaaf0494de7c02234d42e486e771e87" translate="yes" xml:space="preserve">
          <source>The contents of the Name header field, if present. If no name is present, the value will be undef. Note this is different from a zero length name, which will return an empty string.</source>
          <target state="translated">Name头的内容(如果存在)。如果不存在名称,该值将为undef。注意,这与零长度的名称不同,后者将返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="9456b1413183ce2a7cacbf69ac958ec33df9e078" translate="yes" xml:space="preserve">
          <source>The contents of the above &quot;=begin :yetanotherformat&quot; ... &quot;=end :yetanotherformat&quot; region</source>
          <target state="translated">上述&quot;=begin :yetanotherformat&quot;...的内容。&quot;=end :yetanotherformat &quot;区域的内容。</target>
        </trans-unit>
        <trans-unit id="7bdc8b3d3c8ea3698e851bea6c870ef22be74842" translate="yes" xml:space="preserve">
          <source>The contents of the string are split into arguments using a call to &lt;code&gt;Text::ParseWords::shellwords&lt;/code&gt; . As with &lt;code&gt;GetOptionsFromArray&lt;/code&gt; , the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched.</source>
          <target state="translated">字符串的内容通过调用 &lt;code&gt;Text::ParseWords::shellwords&lt;/code&gt; 分为参数。与 &lt;code&gt;GetOptionsFromArray&lt;/code&gt; 一样，全局 &lt;code&gt;@ARGV&lt;/code&gt; 不会被触摸。</target>
        </trans-unit>
        <trans-unit id="07cf397badd80566fee8d86ba0e84ac06f7a748f" translate="yes" xml:space="preserve">
          <source>The contents of the string are split into arguments using a call to &lt;code&gt;Text::ParseWords::shellwords&lt;/code&gt;. As with &lt;code&gt;GetOptionsFromArray&lt;/code&gt;, the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0a191734836657a10b5b7b1f37002c95e61a13" translate="yes" xml:space="preserve">
          <source>The contents of the string changes, but not the nature of the string. Perl doesn't know any more after the call than before that the contents of the string indicates the affirmative.</source>
          <target state="translated">字符串的内容发生了变化,但字符串的性质没有改变。Perl在调用后并不比调用前更知道字符串的内容表示肯定。</target>
        </trans-unit>
        <trans-unit id="fa23695f3fe9b71ce5ed23d56ccd05be2c1e1b36" translate="yes" xml:space="preserve">
          <source>The contents should be an integer; different bits of it are used for different pragmatic flags. Here's an example:</source>
          <target state="translated">内容应该是一个整数;其中不同的位用于不同的实用性标志。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="29b067c45824f7dfd004988f65509a605101a269" translate="yes" xml:space="preserve">
          <source>The context (void, scalar or list) for the return value(s) for &lt;code&gt;-&amp;gt;join()&lt;/code&gt; is determined at the time of thread creation.</source>
          <target state="translated">&lt;code&gt;-&amp;gt;join()&lt;/code&gt; 的返回值的上下文（无效，标量或列表）是在创建线程时确定的。</target>
        </trans-unit>
        <trans-unit id="2981bb07b7171fe17187abbda366aca2482181b3" translate="yes" xml:space="preserve">
          <source>The context in which the subroutine was called by autodie; usually the same as the context in which you called the autodying subroutine. This can be 'list', 'scalar', or undefined (unknown). It will never be 'void', as &lt;code&gt;autodie&lt;/code&gt; always captures the return value in one way or another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecdacee8e16379859c5cc73f585093cfac3b0ac5" translate="yes" xml:space="preserve">
          <source>The context object has API compatible implementations of the following methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d48ce1ec215b9e3fdc0488fca135ada53527334" translate="yes" xml:space="preserve">
          <source>The context object is the primary interface for authors of testing tools written with &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;. The context object represents the context in which a test takes place (File and Line Number), and provides a quick way to generate events from that context. The context object also takes care of sending events to the correct &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafef0e58c037c46bb556fc0f1a1471183c9edb3" translate="yes" xml:space="preserve">
          <source>The context type may also be used as the</source>
          <target state="translated">该上下文类型也可以作为</target>
        </trans-unit>
        <trans-unit id="67c74c2a8a5b26d0759477b6c197cf9395cba8a0" translate="yes" xml:space="preserve">
          <source>The context-free version of Perl_warner is called Perl_warner_nocontext, and does not take the extra argument. Instead it does &lt;code&gt;dTHX;&lt;/code&gt; to get the context from thread-local storage. We &lt;code&gt;#define warner Perl_warner_nocontext&lt;/code&gt; so that extensions get source compatibility at the expense of performance. (Passing an arg is cheaper than grabbing it from thread-local storage.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3e46d3e11cb302e5746c299ddd22b0f06326e3" translate="yes" xml:space="preserve">
          <source>The context-free version of Perl_warner is called Perl_warner_nocontext, and does not take the extra argument. Instead it does dTHX; to get the context from thread-local storage. We &lt;code&gt;#define warner Perl_warner_nocontext&lt;/code&gt; so that extensions get source compatibility at the expense of performance. (Passing an arg is cheaper than grabbing it from thread-local storage.)</source>
          <target state="translated">Perl_warner的上下文无关版本称为Perl_warner_nocontext，并且不使用额外的参数。相反，它执行dTHX。从线程本地存储中获取上下文。我们 &lt;code&gt;#define warner Perl_warner_nocontext&lt;/code&gt; ,以便扩展获得源兼容性，但会降低性能。（传递一个arg比从线程本地存储中获取它便宜。）</target>
        </trans-unit>
        <trans-unit id="427dbaaec2be0f9303d86d3fada6d103291e20da" translate="yes" xml:space="preserve">
          <source>The contexts where no warnings or errors are raised are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a306525389293789c4d3b564d2695ad27f640911" translate="yes" xml:space="preserve">
          <source>The conversion from Perl to C is left as an exercise to the reader, but the prototype would be:</source>
          <target state="translated">从Perl到C的转换留给读者去练习,但原型将是。</target>
        </trans-unit>
        <trans-unit id="5dab7a329fdfbc3426218724b9a43e87edffc6ee" translate="yes" xml:space="preserve">
          <source>The copy constructor is called only before a call to a function declared to implement a mutator, for example, if &lt;code&gt;++$b;&lt;/code&gt; in the code above is effected via a method declared for key &lt;code&gt;'++'&lt;/code&gt; (or 'nomethod', passed &lt;code&gt;'++'&lt;/code&gt; as the fourth argument) or, by autogeneration, &lt;code&gt;'+='&lt;/code&gt; . It is not called if the increment operation is effected by a call to the method for &lt;code&gt;'+'&lt;/code&gt; since, in the equivalent code,</source>
          <target state="translated">复制构造函数仅在调用声明为实现可变器的函数之前被调用，例如 &lt;code&gt;++$b;&lt;/code&gt; 上面代码中的代码是通过为键 &lt;code&gt;'++'&lt;/code&gt; 声明的方法（或'nomethod'，将 &lt;code&gt;'++'&lt;/code&gt; 作为第四个参数传递）或自动生成的 &lt;code&gt;'+='&lt;/code&gt; 来实现的。如果增量操作是通过调用 &lt;code&gt;'+'&lt;/code&gt; 方法来实现的，则不会被调用，因为在等效代码中，</target>
        </trans-unit>
        <trans-unit id="1a338324ec1f9edaef696d6d917c941261b8a116" translate="yes" xml:space="preserve">
          <source>The copy constructor is called only before a call to a function declared to implement a mutator, for example, if &lt;code&gt;++$b;&lt;/code&gt; in the code above is effected via a method declared for key &lt;code&gt;'++'&lt;/code&gt; (or 'nomethod', passed &lt;code&gt;'++'&lt;/code&gt; as the fourth argument) or, by autogeneration, &lt;code&gt;'+='&lt;/code&gt;. It is not called if the increment operation is effected by a call to the method for &lt;code&gt;'+'&lt;/code&gt; since, in the equivalent code,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed73a5b2044d7fb703c52c07bf589cfde908abd5" translate="yes" xml:space="preserve">
          <source>The copy constructor is not called if Perl determines that it is unnecessary because there is no other reference to the data being modified.</source>
          <target state="translated">如果Perl认为不需要复制构造函数,因为没有其他被修改的数据的引用,那么复制构造函数就不会被调用。</target>
        </trans-unit>
        <trans-unit id="535c9ed5919c829adefa54d7a3ea16590ff263e1" translate="yes" xml:space="preserve">
          <source>The core &lt;a href=&quot;Devel::Peek&quot;&gt;Devel::Peek&lt;/a&gt; module lets us examine SVs from a Perl program. Let's see, for instance, how Perl treats the constant &lt;code&gt;&quot;hello&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc11db58db7976be6cbb0391f46874d6c6c0bdfd" translate="yes" xml:space="preserve">
          <source>The core &lt;a href=&quot;HTTP::Tiny&quot;&gt;HTTP::Tiny&lt;/a&gt; module can fetch web resources and give their content back to you as a string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd210b745dfa94e566cd092061cca3c4c3e619ac" translate="yes" xml:space="preserve">
          <source>The core &lt;a href=&quot;devel/peek&quot;&gt;Devel::Peek&lt;/a&gt; module lets us examine SVs from a Perl program. Let's see, for instance, how Perl treats the constant &lt;code&gt;&quot;hello&quot;&lt;/code&gt; .</source>
          <target state="translated">核心的&lt;a href=&quot;devel/peek&quot;&gt;Devel :: Peek&lt;/a&gt;模块使我们可以从Perl程序中检查SV。例如，让我们看看Perl如何对待常量 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="216872d0879be12be32ab51a2f74dd9e0b301e2c" translate="yes" xml:space="preserve">
          <source>The core development team (known as the Perl Porters) are a group of highly altruistic individuals committed to producing better software for free than you could hope to purchase for money. You may snoop on pending developments via the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.nntp.perl.org%2fgroup%2fperl.perl5.porters%2f&quot;&gt;archives&lt;/a&gt; or read the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fdev.perl.org%2fperl5%2fdocs%2fp5p-faq.html&quot;&gt;faq&lt;/a&gt;, or you can subscribe to the mailing list by sending perl5-porters-subscribe@perl.org a subscription request (an empty message with no subject is fine).</source>
          <target state="translated">核心开发团队（称为Perl Porters）是一群高度利他的人，他们致力于免费生产比您希望花钱买的更好的软件。您可以通过&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.nntp.perl.org%2fgroup%2fperl.perl5.porters%2f&quot;&gt;归档文件&lt;/a&gt;窥探未完成的开发或阅读&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fdev.perl.org%2fperl5%2fdocs%2fp5p-faq.html&quot;&gt;常见问题&lt;/a&gt;解答，也可以通过向perl5-porters-subscribe@perl.org发送订阅请求来订阅邮件列表（无主题的空消息是可以的）。</target>
        </trans-unit>
        <trans-unit id="722caaf3f888051207be247f57e2eb71f8ea20ba" translate="yes" xml:space="preserve">
          <source>The core development team (known as the Perl Porters) are a group of highly altruistic individuals committed to producing better software for free than you could hope to purchase for money. You may snoop on pending developments via the &lt;a href=&quot;http://www.nntp.perl.org/group/perl.perl5.porters/&quot;&gt;archives&lt;/a&gt; or you can subscribe to the mailing list by sending perl5-porters-subscribe@perl.org a subscription request (an empty message with no subject is fine).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd6f3115d2d6dbe91a070c10c729356bd227008" translate="yes" xml:space="preserve">
          <source>The core distribution can now run its regression tests in parallel on Unix-like platforms. Instead of running &lt;code&gt;make test&lt;/code&gt; , set &lt;code&gt;TEST_JOBS&lt;/code&gt; in your environment to the number of tests to run in parallel, and run &lt;code&gt;make test_harness&lt;/code&gt; . On a Bourne-like shell, this can be done as</source>
          <target state="translated">现在，核心发行版可以在类似Unix的平台上并行运行其回归测试。不必运行 &lt;code&gt;make test&lt;/code&gt; ， &lt;code&gt;TEST_JOBS&lt;/code&gt; 将环境中的TEST_JOBS设置为要并行运行的测试数，然后运行 &lt;code&gt;make test_harness&lt;/code&gt; 。在类似Bourne的外壳上，可以这样完成</target>
        </trans-unit>
        <trans-unit id="b674b66d3912143b8c38b5c16cba55bf33d927a4" translate="yes" xml:space="preserve">
          <source>The core distribution can now run its regression tests in parallel on Unix-like platforms. Instead of running &lt;code&gt;make test&lt;/code&gt;, set &lt;code&gt;TEST_JOBS&lt;/code&gt; in your environment to the number of tests to run in parallel, and run &lt;code&gt;make test_harness&lt;/code&gt;. On a Bourne-like shell, this can be done as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6cc3805e3a5e355489c3ee53c0ef93bf5066f34" translate="yes" xml:space="preserve">
          <source>The core provides a wrapper program,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e662bc8801eef788dff3d6316ec77e7ad811db79" translate="yes" xml:space="preserve">
          <source>The core uses the same testing style as the rest of Perl, a simple &quot;ok/not ok&quot; run through Test::Harness, but there are a few special considerations.</source>
          <target state="translated">该核心使用与Perl其他部分相同的测试风格,即通过Test::Harness运行简单的 &quot;ok/not ok&quot;,但有一些特殊的考虑。</target>
        </trans-unit>
        <trans-unit id="a3ac8ff08d630fcfeea5350e81e0c2b799df3c84" translate="yes" xml:space="preserve">
          <source>The corpse of a &lt;b&gt;process&lt;/b&gt;, in the form of a file left in the &lt;b&gt;working directory&lt;/b&gt; of the process, usually as a result of certain kinds of fatal errors.</source>
          <target state="translated">&lt;b&gt;进程&lt;/b&gt;的尸体，通常是某些致命错误的结果，以文件形式保留在进程的&lt;b&gt;工作目录&lt;/b&gt;中。</target>
        </trans-unit>
        <trans-unit id="ad72ec528dbf7e40ea844e46e3a129f3b3eadb6f" translate="yes" xml:space="preserve">
          <source>The correct code is &lt;code&gt;MAN3PODS =&amp;gt; { }&lt;/code&gt; .</source>
          <target state="translated">正确的代码是 &lt;code&gt;MAN3PODS =&amp;gt; { }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d267e23c37d16b49140100273b7c13b82e17e524" translate="yes" xml:space="preserve">
          <source>The correct code is &lt;code&gt;MAN3PODS =&amp;gt; { }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb7322d9e711d10a989215f61754b35fdcb57a5" translate="yes" xml:space="preserve">
          <source>The correct procedure, then, is to use &lt;code&gt;newRV_noinc&lt;/code&gt; instead of &lt;code&gt;newRV_inc&lt;/code&gt; . Then, if and when the last reference is destroyed, the reference count of the SV will go to zero and it will be destroyed, stopping any memory leak.</source>
          <target state="translated">因此，正确的过程是使用 &lt;code&gt;newRV_noinc&lt;/code&gt; 而不是 &lt;code&gt;newRV_inc&lt;/code&gt; 。然后，如果并且当最后一个引用被销毁时，SV的引用计数将变为零并被销毁，从而停止任何内存泄漏。</target>
        </trans-unit>
        <trans-unit id="e90480b056b891e1197a3bfca2f65f9341469925" translate="yes" xml:space="preserve">
          <source>The correspondence between OPs and</source>
          <target state="translated">业务方案和执行部分之间的对应关系</target>
        </trans-unit>
        <trans-unit id="3e632bae0f91b7fe9b42695b7f4eb9541547d7ab" translate="yes" xml:space="preserve">
          <source>The corresponding bright foreground color attributes (colors 8 to 15) are:</source>
          <target state="translated">对应的亮丽前景色属性(颜色8至15)为:。</target>
        </trans-unit>
        <trans-unit id="15d3a8f91abd0b678be46a5c74457eb9c1a22a59" translate="yes" xml:space="preserve">
          <source>The corresponding command to get the current value of &lt;code&gt;$version&lt;/code&gt; is:</source>
          <target state="translated">获取 &lt;code&gt;$version&lt;/code&gt; 当前值的相应命令是：</target>
        </trans-unit>
        <trans-unit id="05b1215b3085d02b291dbd96e47ab01de8dfb44a" translate="yes" xml:space="preserve">
          <source>The corresponding values are interpreted as regular expressions. The &lt;code&gt;distribution&lt;/code&gt; related one will be matched against the canonical distribution name, e.g. &quot;AUTHOR/Foo-Bar-3.14.tar.gz&quot;.</source>
          <target state="translated">相应的值被解释为正则表达式。与该 &lt;code&gt;distribution&lt;/code&gt; 相关的发行版将与规范的发行版名称匹配，例如&amp;ldquo; AUTHOR / Foo-Bar-3.14.tar.gz&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="128893376b086988df0b6fe82266dcff7ded3c2c" translate="yes" xml:space="preserve">
          <source>The corresponding values are references to functions which take three arguments: the first one is the</source>
          <target state="translated">相应的值是对函数的引用,这些函数有三个参数:第一个参数是</target>
        </trans-unit>
        <trans-unit id="6d3c7b629f0ebabb7666a1418d689e5fcefefd4a" translate="yes" xml:space="preserve">
          <source>The count of the saved lines in the history (assuming &lt;code&gt;HistFile&lt;/code&gt; above).</source>
          <target state="translated">历史记录中已保存的行数（假设上面的 &lt;code&gt;HistFile&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8a76e9ed23620e2d0138b893f98a44b589dac036" translate="yes" xml:space="preserve">
          <source>The cpd tool detects cut-and-paste coding. If one instance of the cut-and-pasted code changes, all the other spots should probably be changed, too. Therefore such code should probably be turned into a subroutine or a macro.</source>
          <target state="translated">cpd工具可以检测剪切和粘贴的代码。如果剪切和粘贴的代码的一个实例发生了变化,那么其他所有的点可能也应该被改变。因此,这样的代码可能应该变成一个子程序或一个宏。</target>
        </trans-unit>
        <trans-unit id="3e999a3fce2098896facdee408ae939b810f6fc0" translate="yes" xml:space="preserve">
          <source>The cperl PERL_PERTURB_KEYS_TOP hash strategy has a known problem with restricted hashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4315b91912980da8ee0d1d0ed73982372319566a" translate="yes" xml:space="preserve">
          <source>The critical thing when considering performance is to remember there is no such thing as a &lt;code&gt;Golden Bullet&lt;/code&gt; , which is why there are no rules, only guidelines.</source>
          <target state="translated">考虑性能时，关键是要记住没有&amp;ldquo; &lt;code&gt;Golden Bullet&lt;/code&gt; 类的东西，这就是为什么没有规则，只有准则的原因。</target>
        </trans-unit>
        <trans-unit id="fe5e8a5c2d99ce7c51902edfccff2bd041c5e28d" translate="yes" xml:space="preserve">
          <source>The critical thing when considering performance is to remember there is no such thing as a &lt;code&gt;Golden Bullet&lt;/code&gt;, which is why there are no rules, only guidelines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b2f6d378553efd3b9ab7bab3a4069e081f7b24e" translate="yes" xml:space="preserve">
          <source>The crucial thing to understand about the Windows environment is that the command line you type in is processed twice before Perl sees it. First, your command shell (usually CMD.EXE) preprocesses the command line, to handle redirection, environment variable expansion, and location of the executable to run. Then, the perl executable splits the remaining command line into individual arguments, using the C runtime library upon which Perl was built.</source>
          <target state="translated">关于Windows环境,最关键的一点是,你输入的命令行在Perl看到它之前会被处理两次。首先,你的命令壳(通常是 CMD.EXE)会对命令行进行预处理,以处理重定向、环境变量扩展和可执行文件的位置。然后,perl可执行文件将剩余的命令行分割成各个参数,使用Perl赖以建立的C运行库。</target>
        </trans-unit>
        <trans-unit id="1bc259f8a74780b8f0344bb67ea81414fbf6762f" translate="yes" xml:space="preserve">
          <source>The crypt package distributed with Cygwin is a Linux compatible 56-bit DES crypt port by Corinna Vinschen.</source>
          <target state="translated">与Cygwin一起发布的加密包是Corinna Vinschen的一个Linux兼容的56位DES加密端口。</target>
        </trans-unit>
        <trans-unit id="39208a8b75f909c397f1ded48c8402dc3fb7d1f8" translate="yes" xml:space="preserve">
          <source>The crypt() function is unimplemented due to excessive paranoia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831281b1eb1b6cf65cdf498d326c123b4d2ac980" translate="yes" xml:space="preserve">
          <source>The csh_glob() function can also be exported, but you should not use it directly unless you really know what you are doing. It splits the pattern into words and feeds each one to bsd_glob(). Perl's own glob() function uses this internally.</source>
          <target state="translated">csh_glob()函数也可以导出,但是你不应该直接使用它,除非你真的知道你在做什么。它将模式分割成单词,并将每个单词喂给bsd_glob()。Perl 自己的 glob()函数在内部使用了这个。</target>
        </trans-unit>
        <trans-unit id="bb0c5fc2762311ff2f0c2ca9c51463e63c575d45" translate="yes" xml:space="preserve">
          <source>The ctime() function provides a way of getting at the scalar sense of the original CORE::localtime() function.</source>
          <target state="translated">ctime()函数提供了一种获取原始CORE::localtime()函数的标量意义的方法。</target>
        </trans-unit>
        <trans-unit id="cc603efa123dedf5ee9218533c5f2218c02b0847" translate="yes" xml:space="preserve">
          <source>The cube root [C99].</source>
          <target state="translated">立方根【C99】。</target>
        </trans-unit>
        <trans-unit id="64bb5be49b5cecef1e72ffa347e55d8d7f71bf40" translate="yes" xml:space="preserve">
          <source>The current Unicode definition of a Word Boundary matches between every white space character. Perl tailors this, starting in version 5.24, to generally not break up spans of white space, just as plain &lt;code&gt;\b&lt;/code&gt; has always functioned. This allows &lt;code&gt;\b{wb}&lt;/code&gt; to be a drop-in replacement for &lt;code&gt;\b&lt;/code&gt;, but with generally better results for natural language processing. (The exception to this tailoring is when a span of white space is immediately followed by something like U+0303, COMBINING TILDE. If the final space character in the span is a horizontal white space, it is broken out so that it attaches instead to the combining character. To be precise, if a span of white space that ends in a horizontal space has the character immediately following it have any of the Word Boundary property values &quot;Extend&quot;, &quot;Format&quot; or &quot;ZWJ&quot;, the boundary between the final horizontal space character and the rest of the span matches &lt;code&gt;\b{wb}&lt;/code&gt;. In all other cases the boundary between two white space characters matches &lt;code&gt;\B{wb}&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64523d7c78b273edb939e95b2a44e78339d21a0e" translate="yes" xml:space="preserve">
          <source>The current format name is stored in the variable &lt;code&gt;$~&lt;/code&gt; (&lt;code&gt;$FORMAT_NAME&lt;/code&gt; ), and the current top of form format name is in &lt;code&gt;$^&lt;/code&gt; (&lt;code&gt;$FORMAT_TOP_NAME&lt;/code&gt; ). The current output page number is stored in &lt;code&gt;$%&lt;/code&gt; (&lt;code&gt;$FORMAT_PAGE_NUMBER&lt;/code&gt; ), and the number of lines on the page is in &lt;code&gt;$=&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_PER_PAGE&lt;/code&gt; ). Whether to autoflush output on this handle is stored in &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$OUTPUT_AUTOFLUSH&lt;/code&gt; ). The string output before each top of page (except the first) is stored in &lt;code&gt;$^L&lt;/code&gt; (&lt;code&gt;$FORMAT_FORMFEED&lt;/code&gt; ). These variables are set on a per-filehandle basis, so you'll need to select() into a different one to affect them:</source>
          <target state="translated">当前格式名称存储在变量 &lt;code&gt;$~&lt;/code&gt; （ &lt;code&gt;$FORMAT_NAME&lt;/code&gt; ）中，当前表单格式名称的顶部位于 &lt;code&gt;$^&lt;/code&gt; （ &lt;code&gt;$FORMAT_TOP_NAME&lt;/code&gt; ）中。当前输出页码存储在 &lt;code&gt;$%&lt;/code&gt; （ &lt;code&gt;$FORMAT_PAGE_NUMBER&lt;/code&gt; ）中，页面上的行数存储在 &lt;code&gt;$=&lt;/code&gt; （ &lt;code&gt;$FORMAT_LINES_PER_PAGE&lt;/code&gt; ）中。是否自动刷新此句柄上的输出存储在 &lt;code&gt;$|&lt;/code&gt; （ &lt;code&gt;$OUTPUT_AUTOFLUSH&lt;/code&gt; ）。每个页面顶部（第一个顶部除外）之前输出的字符串存储在 &lt;code&gt;$^L&lt;/code&gt; （ &lt;code&gt;$FORMAT_FORMFEED&lt;/code&gt; ）。这些变量是在每个文件句柄的基础上设置的，因此您需要将select（）放入另一个变量中以影响它们：</target>
        </trans-unit>
        <trans-unit id="15997f5af8679b322c9a721da40c3667459ea331" translate="yes" xml:space="preserve">
          <source>The current format name is stored in the variable &lt;code&gt;$~&lt;/code&gt; (&lt;code&gt;$FORMAT_NAME&lt;/code&gt;), and the current top of form format name is in &lt;code&gt;$^&lt;/code&gt; (&lt;code&gt;$FORMAT_TOP_NAME&lt;/code&gt;). The current output page number is stored in &lt;code&gt;$%&lt;/code&gt; (&lt;code&gt;$FORMAT_PAGE_NUMBER&lt;/code&gt;), and the number of lines on the page is in &lt;code&gt;$=&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_PER_PAGE&lt;/code&gt;). Whether to autoflush output on this handle is stored in &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$OUTPUT_AUTOFLUSH&lt;/code&gt;). The string output before each top of page (except the first) is stored in &lt;code&gt;$^L&lt;/code&gt; (&lt;code&gt;$FORMAT_FORMFEED&lt;/code&gt;). These variables are set on a per-filehandle basis, so you'll need to select() into a different one to affect them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbbf873260d45973f075c0f7d16575580f2c6333" translate="yes" xml:space="preserve">
          <source>The current hierarchy is:</source>
          <target state="translated">目前的等级制度是:</target>
        </trans-unit>
        <trans-unit id="824b38e0c77c472868114a17d1e97b269bb0ba11" translate="yes" xml:space="preserve">
          <source>The current implementation does not allow specification of the required version of the module.</source>
          <target state="translated">目前的实施方式不允许指定模块的所需版本。</target>
        </trans-unit>
        <trans-unit id="282bec354d0f4d4b762dd47ad0eb5b6ecfd1f6ce" translate="yes" xml:space="preserve">
          <source>The current input line is normally in $_, not $0. It generally does not have the newline stripped. ($0 is the name of the program executed.) See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">当前输入行通常在$ _中，而不是$ 0中。它通常不会删除换行符。（$ 0是执行的程序的名称。）请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18f618cc025364ce800e5f345611b3c1497a1ed6" translate="yes" xml:space="preserve">
          <source>The current kinds of Magic Virtual Tables are:</source>
          <target state="translated">目前魔幻虚拟表的种类有。</target>
        </trans-unit>
        <trans-unit id="5c4fde69768c885a1c05aaf0e69e2380f88e2b66" translate="yes" xml:space="preserve">
          <source>The current leading implementation of Perl 6, Rakudo, released a &quot;useful, usable, 'early adopter'&quot; distribution of Perl 6 (called Rakudo Star) in July of 2010. Please see &lt;a href=&quot;http://rakudo.org/&quot;&gt;http://rakudo.org/&lt;/a&gt; for more information.</source>
          <target state="translated">Perl 6 Rakudo的当前领先实现在2010年7月发布了Perl 6（称为Rakudo Star）的&amp;ldquo;有用，可用，'早期采用者'&amp;rdquo;发行版。有关更多信息，请访问&lt;a href=&quot;http://rakudo.org/&quot;&gt;http://rakudo.org/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ee5778fbc1ab8fe240410952dd5b9eaf045d059" translate="yes" xml:space="preserve">
          <source>The current line number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf758edb971b2b4dec99794c86a54d09eddea2b6" translate="yes" xml:space="preserve">
          <source>The current locale is exposed to XS code except possibly &lt;code&gt;LC_NUMERIC&lt;/code&gt; (explained in the next paragraph). There have not been reports of problems with the other categories. Perl initializes things on start-up so that the current locale is the one which is indicated by the user's environment in effect at that time. See &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot; in perllocale&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d3f495bb4240a9d3bab6ec75da601351d12c2b" translate="yes" xml:space="preserve">
          <source>The current locale is exposed to XS code except possibly &lt;code&gt;LC_NUMERIC&lt;/code&gt; (explained in the next paragraph). There have not been reports of problems with the other categories. Perl initializes things on start-up so that the current locale is the one which is indicated by the user's environment in effect at that time. See &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;ENVIRONMENT in perllocale&lt;/a&gt;.</source>
          <target state="translated">除了 &lt;code&gt;LC_NUMERIC&lt;/code&gt; （在下一段中说明）之外，当前语言环境都暴露于XS代码。尚未有其他类别问题的报告。Perl在启动时初始化事物，以便当前的语言环境是当时有效的用户环境所指示的语言环境。请参见&lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;perllocale中的环境&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06e14b6dd5c0c60379e0f9fc4367987da9456c3d" translate="yes" xml:space="preserve">
          <source>The current locale is set at execution time by &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; described below. If that function hasn't yet been called in the course of the program's execution, the current locale is that which was determined by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt; in effect at the start of the program. If there is no valid environment, the current locale is whatever the system default has been set to. On POSIX systems, it is likely, but not necessarily, the &quot;C&quot; locale. On Windows, the default is set via the computer's &lt;code&gt;Control Panel-&amp;gt;Regional and Language Options&lt;/code&gt; (or its current equivalent).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061c069ca3fcc48e2c1a6a5055f7be81ca6838c7" translate="yes" xml:space="preserve">
          <source>The current locale is set at execution time by &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; described below. If that function hasn't yet been called in the course of the program's execution, the current locale is that which was determined by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; in effect at the start of the program. If there is no valid environment, the current locale is whatever the system default has been set to. On POSIX systems, it is likely, but not necessarily, the &quot;C&quot; locale. On Windows, the default is set via the computer's &lt;code&gt;Control Panel-&amp;gt;Regional &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; Language Options&lt;/code&gt; (or its current equivalent).</source>
          <target state="translated">当前语言环境是在执行时通过以下描述的&lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale（）&lt;/a&gt;设置的。如果尚未在程序执行过程中调用该函数，则当前语言环境是由程序启动时有效的&lt;a href=&quot;#ENVIRONMENT&quot;&gt;环境&lt;/a&gt;确定的语言环境。如果没有有效的环境，则当前语言环境将是系统默认设置。在POSIX系统上，它可能是（但不一定是）&amp;ldquo; C&amp;rdquo;语言环境。在Windows上，默认值是通过计算机的&amp;ldquo; &lt;code&gt;Control Panel-&amp;gt;Regional &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; Language Options&lt;/code&gt; （或其当前等效项）设置的。</target>
        </trans-unit>
        <trans-unit id="b7f42f27fb52f98cb07c551fabc648053a689c30" translate="yes" xml:space="preserve">
          <source>The current locale is used when going outside of Perl with operations like &lt;a href=&quot;functions/system&quot;&gt;system LIST&lt;/a&gt; or &lt;a href=&quot;perlop#qx%2fSTRING%2f&quot;&gt;qx//&lt;/a&gt;, if those operations are locale-sensitive.</source>
          <target state="translated">如果在Perl之外进行&lt;a href=&quot;functions/system&quot;&gt;系统LIST&lt;/a&gt;或&lt;a href=&quot;perlop#qx%2fSTRING%2f&quot;&gt;qx //之类的&lt;/a&gt;操作，则使用当前语言环境（如果这些操作对语言环境敏感）。</target>
        </trans-unit>
        <trans-unit id="69e663f7c7a676b0d28d32e89828d9474ab1d29d" translate="yes" xml:space="preserve">
          <source>The current locale is used when going outside of Perl with operations like &lt;a href=&quot;perlfunc#system-LIST&quot;&gt;system()&lt;/a&gt; or &lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt;qx//&lt;/a&gt;, if those operations are locale-sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea51628874f50840c20248e49e31ecc39bc8aab0" translate="yes" xml:space="preserve">
          <source>The current major release of Perl is Perl 5, first released in 1994. It can run scripts from the previous major release, Perl 4 (March 1991), but has significant differences.</source>
          <target state="translated">目前Perl的主要版本是Perl 5,1994年首次发布。它可以运行前一个主要版本Perl 4(1991年3月)的脚本,但有重大区别。</target>
        </trans-unit>
        <trans-unit id="1ad75b57a59621fb77288b117b229032ac9f513f" translate="yes" xml:space="preserve">
          <source>The current naming convention is:</source>
          <target state="translated">目前的命名惯例是:</target>
        </trans-unit>
        <trans-unit id="b2e2b3b69c2218e4d8359acb1335a4024632d82a" translate="yes" xml:space="preserve">
          <source>The current offset on the Perl internal stack (cf. &lt;code&gt;SP&lt;/code&gt; ) is restored at the end of</source>
          <target state="translated">Perl内部堆栈（请参阅 &lt;code&gt;SP&lt;/code&gt; ）上的当前偏移量将在</target>
        </trans-unit>
        <trans-unit id="6ab9fb3b5f482c273ca6d801c743b02bcacec72c" translate="yes" xml:space="preserve">
          <source>The current offset on the Perl internal stack (cf. &lt;code&gt;SP&lt;/code&gt;) is restored at the end of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c030186501458b34adb46e2d42aa7b81f218a056" translate="yes" xml:space="preserve">
          <source>The current page length (printable lines) of the currently selected output channel. The default is 60.</source>
          <target state="translated">当前选定的输出通道的当前页长(可打印行数)。默认值为60。</target>
        </trans-unit>
        <trans-unit id="3d4eb19bb10369473283d32cc7dd71a86ff46c90" translate="yes" xml:space="preserve">
          <source>The current page number of the currently selected output channel.</source>
          <target state="translated">当前选择的输出通道的当前页码。</target>
        </trans-unit>
        <trans-unit id="770296232bd3d822ead8ffe492b7e0e282b9f95e" translate="yes" xml:space="preserve">
          <source>The current phase of the perl interpreter.</source>
          <target state="translated">当前阶段的perl解释器。</target>
        </trans-unit>
        <trans-unit id="2864f23a19f0c83d2f66d97a56cf54892b44918f" translate="yes" xml:space="preserve">
          <source>The current process identifier is normally also available via the predefined $$ variable. Under fork() emulation however $$ may contain a pseudo-process identifier that is only meaningful to the Perl kill(), wait() and waitpid() functions. The Win32::GetCurrentProcessId() function will always return the regular Windows process id, even when called from inside a pseudo-process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2857cd700aaf0537f04949257bdb10786ea5148" translate="yes" xml:space="preserve">
          <source>The current set of characters after which a string may be broken to fill continuation fields (starting with &lt;code&gt;^&lt;/code&gt;) in a format. The default is &quot; \n-&quot;, to break on a space, newline, or a hyphen.</source>
          <target state="translated">当前字符集，字符串之后可以被打断以填充格式中的连续字段（以 &lt;code&gt;^&lt;/code&gt; 开头）。默认值为&amp;ldquo; \ n-&amp;rdquo;，以空格，换行符或连字符开头。</target>
        </trans-unit>
        <trans-unit id="d0bc78c2888afaf94160d8cd4bd4fdc74663bf04" translate="yes" xml:space="preserve">
          <source>The current set of official keys is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981300e195cac4e7353f833304330d8ac58b67a9" translate="yes" xml:space="preserve">
          <source>The current set of warning checks enabled by the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma. It has the same scoping as the &lt;code&gt;$^H&lt;/code&gt; and &lt;code&gt;%^H&lt;/code&gt; variables. The exact values are considered internal to the &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; pragma and may change between versions of Perl.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译指示启用的当前警告检查集。它具有与 &lt;code&gt;$^H&lt;/code&gt; 和 &lt;code&gt;%^H&lt;/code&gt; 变量相同的作用域。确切的值被认为是&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;实用程序内部的值，并且可能在Perl版本之间发生变化。</target>
        </trans-unit>
        <trans-unit id="5ff870c28a76abb15c6ef8bc6c01da1732cfc87c" translate="yes" xml:space="preserve">
          <source>The current set of warning checks enabled by the &lt;code&gt;use warnings&lt;/code&gt; pragma. It has the same scoping as the &lt;code&gt;$^H&lt;/code&gt; and &lt;code&gt;%^H&lt;/code&gt; variables. The exact values are considered internal to the &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; pragma and may change between versions of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48b124af22e055d2f998460eddfa2b05c504d05" translate="yes" xml:space="preserve">
          <source>The current setting for a particular CV can be retrieved by &lt;a href=&quot;#cv_get_call_checker&quot;&gt;cv_get_call_checker&lt;/a&gt;.</source>
          <target state="translated">特定CV的当前设置可以通过&lt;a href=&quot;#cv_get_call_checker&quot;&gt;cv_get_call_checker&lt;/a&gt;检索。</target>
        </trans-unit>
        <trans-unit id="043e73127d721a29085be4df3900bb1371bf6328" translate="yes" xml:space="preserve">
          <source>The current setting for a particular CV can be retrieved by &lt;a href=&quot;#cv_get_call_checker_flags&quot;&gt;&quot;cv_get_call_checker_flags&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b952480064e555e874a4e5bab67374e0afa43170" translate="yes" xml:space="preserve">
          <source>The current state is quite close to this target. Known limitations:</source>
          <target state="translated">目前的状态与这个目标相当接近。已知的限制。</target>
        </trans-unit>
        <trans-unit id="ba6118e27828276e003be0b716e1e27e35775418" translate="yes" xml:space="preserve">
          <source>The current time, hires or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c893fdb58e68676d453e9772eca0458d9ee9ef15" translate="yes" xml:space="preserve">
          <source>The current value giving the maximum number of open but unclosed parenthetical groups there may be at any point during a regular expression compilation. The default is currently 1000 nested groups. You may adjust it depending on your needs and the amount of memory available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc73114057d5a2e203bbe1e6af0220ea5c0d6452" translate="yes" xml:space="preserve">
          <source>The current value of &lt;a href=&quot;perlvar#%24%2C&quot;&gt;&lt;code&gt;$,&lt;/code&gt;&lt;/a&gt; (if any) is printed between each LIST item. The current value of &lt;a href=&quot;perlvar#%24%5C&quot;&gt;&lt;code&gt;$\&lt;/code&gt;&lt;/a&gt; (if any) is printed after the entire LIST has been printed. Because print takes a LIST, anything in the LIST is evaluated in list context, including any subroutines whose return lists you pass to &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;. Be careful not to follow the print keyword with a left parenthesis unless you want the corresponding right parenthesis to terminate the arguments to the print; put parentheses around all arguments (or interpose a &lt;code&gt;+&lt;/code&gt;, but that doesn't look as good).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b45957d0c48ff5a61159add09d1cced4fe06354" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$,&lt;/code&gt; (if any) is printed between each LIST item. The current value of &lt;code&gt;$\&lt;/code&gt; (if any) is printed after the entire LIST has been printed. Because print takes a LIST, anything in the LIST is evaluated in list context, including any subroutines whose return lists you pass to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;. Be careful not to follow the print keyword with a left parenthesis unless you want the corresponding right parenthesis to terminate the arguments to the print; put parentheses around all arguments (or interpose a &lt;code&gt;+&lt;/code&gt; , but that doesn't look as good).</source>
          <target state="translated">&lt;code&gt;$,&lt;/code&gt; 的当前值（如果有）在每个LIST项目之间打印。 &lt;code&gt;$\&lt;/code&gt; （如果有的话）的当前值在打印整个LIST之后打印。因为print需要一个LIST，所以LIST中的所有内容都会在列表上下文中进行评估，包括将其返回列表传递给 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 的所有子例程。注意不要在print关键字后面加上左括号，除非您希望相应的右括号终止打印的参数。在所有参数周围加上括号（或插入 &lt;code&gt;+&lt;/code&gt; ，但这看起来不太好）。</target>
        </trans-unit>
        <trans-unit id="d3b381c8d22a96ce946901e90864741d92df1af5" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$,&lt;/code&gt; (if any) is printed between each LIST item. The current value of &lt;code&gt;$\&lt;/code&gt; (if any) is printed after the entire LIST has been printed. Because print takes a LIST, anything in the LIST is evaluated in list context, including any subroutines whose return lists you pass to &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;. Be careful not to follow the print keyword with a left parenthesis unless you want the corresponding right parenthesis to terminate the arguments to the print; put parentheses around all arguments (or interpose a &lt;code&gt;+&lt;/code&gt; , but that doesn't look as good).</source>
          <target state="translated">&lt;code&gt;$,&lt;/code&gt; 的当前值（如果有）在每个LIST项目之间打印。 &lt;code&gt;$\&lt;/code&gt; （如果有的话）的当前值在打印整个LIST之后打印。因为print需要一个LIST，所以LIST中的所有内容都会在列表上下文中进行评估，包括将其返回列表传递给 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 的所有子例程。注意不要在print关键字后面加上左括号，除非您希望相应的右括号终止打印的参数。在所有参数周围加上括号（或插入 &lt;code&gt;+&lt;/code&gt; ，但这看起来不太好）。</target>
        </trans-unit>
        <trans-unit id="16a7c40e8bbfe13e91d735da741af8520eabede2" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$archname&lt;/code&gt; can be found with this command:</source>
          <target state="translated">&lt;code&gt;$archname&lt;/code&gt; 的当前值可以通过以下命令找到：</target>
        </trans-unit>
        <trans-unit id="db4a25bfed587546962de5c8d6543f967c92521a" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; accumulator for &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; lines. A format contains &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; calls that put their result into &lt;code&gt;$^A&lt;/code&gt; . After calling its format, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; prints out the contents of &lt;code&gt;$^A&lt;/code&gt; and empties. So you never really see the contents of &lt;code&gt;$^A&lt;/code&gt; unless you call &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; yourself and then look at it. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; and &lt;a href=&quot;functions/formline&quot;&gt;formline PICTURE,LIST&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; 行的 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 累加器的当前值。一个格式包含 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; 是把他们的结果为调用 &lt;code&gt;$^A&lt;/code&gt; 。调用其格式后， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 打印 &lt;code&gt;$^A&lt;/code&gt; 的内容并为空。因此，除非您自己调用 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; 然后再查看它，否则您将永远看不到 &lt;code&gt;$^A&lt;/code&gt; 的内容。请参见&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;和&lt;a href=&quot;functions/formline&quot;&gt;formline PICTURE，LIST&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf446124f3a4c45cac5e41b4dd3df5f6adedf891" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;write()&lt;/code&gt; accumulator for &lt;code&gt;format()&lt;/code&gt; lines. A format contains &lt;code&gt;formline()&lt;/code&gt; calls that put their result into &lt;code&gt;$^A&lt;/code&gt;. After calling its format, &lt;code&gt;write()&lt;/code&gt; prints out the contents of &lt;code&gt;$^A&lt;/code&gt; and empties. So you never really see the contents of &lt;code&gt;$^A&lt;/code&gt; unless you call &lt;code&gt;formline()&lt;/code&gt; yourself and then look at it. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; and &lt;a href=&quot;perlfunc#formline-PICTURE%2CLIST&quot;&gt;&quot;formline PICTURE,LIST&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08cef4c84f23112c510335f5bb9c61930fcb65b7" translate="yes" xml:space="preserve">
          <source>The current value of the debugging flags. May be read or set. Like its &lt;a href=&quot;perlrun#-Dletters&quot;&gt;command-line equivalent&lt;/a&gt;, you can use numeric or symbolic values, e.g. &lt;code&gt;$^D = 10&lt;/code&gt; or &lt;code&gt;$^D = &quot;st&quot;&lt;/code&gt;. See &lt;a href=&quot;perlrun#-Dnumber&quot;&gt;&quot;&lt;b&gt;-D&lt;/b&gt;&lt;i&gt;number&lt;/i&gt;&quot; in perlrun&lt;/a&gt;. The contents of this variable also affects the debugger operation. See &lt;a href=&quot;perldebguts#Debugger-Internals&quot;&gt;&quot;Debugger Internals&quot; in perldebguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed07dc52d8f87fe5efbcd1795acd592cb2bcdd55" translate="yes" xml:space="preserve">
          <source>The current value of the debugging flags. May be read or set. Like its command-line equivalent, you can use numeric or symbolic values, eg &lt;code&gt;$^D = 10&lt;/code&gt; or &lt;code&gt;$^D = &quot;st&quot;&lt;/code&gt; .</source>
          <target state="translated">调试标志的当前值。可以读取或设置。像其命令行等效项一样，您可以使用数字或符号值，例如 &lt;code&gt;$^D = 10&lt;/code&gt; 或 &lt;code&gt;$^D = &quot;st&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="761048a9f6779920117c38b6975281ec2824cbaa" translate="yes" xml:space="preserve">
          <source>The current value of the flag associated with the &lt;b&gt;-c&lt;/b&gt; switch. Mainly of use with &lt;b&gt;-MO=...&lt;/b&gt; to allow code to alter its behavior when being compiled, such as for example to &lt;code&gt;AUTOLOAD&lt;/code&gt; at compile time rather than normal, deferred loading. Setting &lt;code&gt;$^C = 1&lt;/code&gt; is similar to calling &lt;code&gt;B::minus_c&lt;/code&gt; .</source>
          <target state="translated">与&lt;b&gt;-c&lt;/b&gt;开关关联的标志的当前值。主要与&lt;b&gt;-MO = ...&lt;/b&gt;一起使用，以允许代码在编译时更改其行为，例如在编译时更改为 &lt;code&gt;AUTOLOAD&lt;/code&gt; ，而不是正常的延迟加载。设置 &lt;code&gt;$^C = 1&lt;/code&gt; 类似于调用 &lt;code&gt;B::minus_c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8dafa28f68632a10855a57c5eacb6743b86c198f" translate="yes" xml:space="preserve">
          <source>The current value of the flag associated with the &lt;b&gt;-c&lt;/b&gt; switch. Mainly of use with &lt;b&gt;-MO=...&lt;/b&gt; to allow code to alter its behavior when being compiled, such as for example to &lt;code&gt;AUTOLOAD&lt;/code&gt; at compile time rather than normal, deferred loading. Setting &lt;code&gt;$^C = 1&lt;/code&gt; is similar to calling &lt;code&gt;B::minus_c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5468ce0ac69ee02e09a591df294df02b8e8e00dd" translate="yes" xml:space="preserve">
          <source>The current value of the inplace-edit extension. Use &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to disable inplace editing.</source>
          <target state="translated">Inplace-Edit扩展的当前值。使用 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 禁用就地编辑。</target>
        </trans-unit>
        <trans-unit id="eb25a57f6557411f85b4814f0d93efdbea2e3515" translate="yes" xml:space="preserve">
          <source>The current value of the inplace-edit extension. Use &lt;code&gt;undef&lt;/code&gt; to disable inplace editing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0d30902e8f62034444f0c46f34be59caec65d2" translate="yes" xml:space="preserve">
          <source>The current value of the regex debugging flags. Set to 0 for no debug output even when the &lt;code&gt;re 'debug'&lt;/code&gt; module is loaded. See &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; for details.</source>
          <target state="translated">regex调试标志的当前值。即使加载了 &lt;code&gt;re 'debug'&lt;/code&gt; 模块，也没有任何调试输出，设置为0 。有关详细信息，请参见&lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a22922d7a166dbc35ec6d0a0c534fd11892caf1b" translate="yes" xml:space="preserve">
          <source>The current value of the warning switch, initially true if &lt;b&gt;-w&lt;/b&gt; was used, false otherwise, but directly modifiable.</source>
          <target state="translated">警告开关的当前值，如果使用&lt;b&gt;-w&lt;/b&gt;，则最初为true ，否则为false，但可以直接修改。</target>
        </trans-unit>
        <trans-unit id="434ca8d76bd8ecc27a064789f98b19395ab4f212" translate="yes" xml:space="preserve">
          <source>The current version of the standards for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; is available at &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt;上提供了 &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; 标准的当前版本。</target>
        </trans-unit>
        <trans-unit id="2b563eb1b6cfef1294ee2d2ec105a8fc001fb852" translate="yes" xml:space="preserve">
          <source>The current version of the standards for &lt;code&gt;atan2&lt;/code&gt; is available at &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af70deb3b449e89c48e84135fbdeb7d79f07a9c" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/ansicolor/&quot;&gt;http://www.eyrie.org/~eagle/software/ansicolor/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">该模块的当前版本始终可以从其网站&lt;a href=&quot;http://www.eyrie.org/~eagle/software/ansicolor/&quot;&gt;http://www.eyrie.org/~eagle/software/ansicolor/中获得&lt;/a&gt;。从5.6.0版开始，它也是Perl核心发行版的一部分。</target>
        </trans-unit>
        <trans-unit id="b31c3cebc8faae4e8a4925e48535264d89073d95" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;.</source>
          <target state="translated">该模块的当前版本始终可以从其网站上获得，网址为&lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f5a8854edfd01b7a5e559e1a5294ccbba9d0afe6" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">该模块的当前版本始终可以从其网站上获得，网址为&lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;。从5.6.0版开始，它也是Perl核心发行版的一部分。</target>
        </trans-unit>
        <trans-unit id="cbd165143fe6d4a52227133b4ee1638e509ed516" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;https://www.eyrie.org/~eagle/software/ansicolor/&quot;&gt;https://www.eyrie.org/~eagle/software/ansicolor/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a674a12f3426ba3d689c7c921dc0c45b179571fc" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;https://www.eyrie.org/~eagle/software/podlators/&quot;&gt;https://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9c2bb6087cce8c28cf4e7d17487f87fbaa02086" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;https://www.eyrie.org/~eagle/software/podlators/&quot;&gt;https://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47cd4fd8d9bd245ee61848360efac4088607cb6" translate="yes" xml:space="preserve">
          <source>The current version of this script is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">该脚本的当前版本始终可以从其网站&lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/中获得&lt;/a&gt;。从5.6.0版开始，它也是Perl核心发行版的一部分。</target>
        </trans-unit>
        <trans-unit id="7b5c546ea518bb4350e7bf7b54f3310abe5cc06c" translate="yes" xml:space="preserve">
          <source>The current version of this script is always available from its web site at &lt;a href=&quot;https://www.eyrie.org/~eagle/software/podlators/&quot;&gt;https://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8fe5626c6979a9718f106c0652b7d905296f64" translate="yes" xml:space="preserve">
          <source>The current version was written by Graham Barr.</source>
          <target state="translated">目前的版本是由Graham Barr撰写的。</target>
        </trans-unit>
        <trans-unit id="7c32f08e82229236d88693ec9eaad5ec8a635209" translate="yes" xml:space="preserve">
          <source>The current working directory of the program is</source>
          <target state="translated">当前程序的工作目录是</target>
        </trans-unit>
        <trans-unit id="403572c903ddf0d90233f3ad9327b2e78dc32883" translate="yes" xml:space="preserve">
          <source>The currently active COP (control op) roughly representing the current statement in the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588f5e820c106e9822f858102bdf0e7ae9b574c7" translate="yes" xml:space="preserve">
          <source>The customary Perl approach for processing all the lines in a file is to do so one line at a time:</source>
          <target state="translated">习惯的Perl处理文件中所有行的方法是一次只处理一行。</target>
        </trans-unit>
        <trans-unit id="a4504c4a63cdd557da723133c8d2b75666dc8630" translate="yes" xml:space="preserve">
          <source>The cwd() is the most natural form for the current architecture. For most systems it is identical to `pwd` (but without the trailing line terminator).</source>
          <target state="translated">cwd()是当前结构中最自然的形式。对于大多数系统来说,它与 &quot;pwd &quot;相同(但没有尾行结束符)。</target>
        </trans-unit>
        <trans-unit id="40c9ebfbdf9a557c5ad182c1d60f03fd99fa74ef" translate="yes" xml:space="preserve">
          <source>The data argument passes in the value (if any) associated with the attribute. For example, if &lt;code&gt;&amp;amp;foo&lt;/code&gt; had been declared:</source>
          <target state="translated">数据参数传入与属性关联的值（如果有）。例如，如果已声明 &lt;code&gt;&amp;amp;foo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4057a2800ea2edef8acd376fce4a738947ca16f2" translate="yes" xml:space="preserve">
          <source>The data can be aggregated into obvious structures, especially if there's a large amount of data in each aggregate.</source>
          <target state="translated">可以将数据聚合成明显的结构,特别是当每个聚合中的数据量很大时。</target>
        </trans-unit>
        <trans-unit id="f1737bbb402e005395886a66a62fefd166798f8a" translate="yes" xml:space="preserve">
          <source>The data is stored as a list of values from the time and times functions:</source>
          <target state="translated">数据以时间和时间函数的值列表的形式存储。</target>
        </trans-unit>
        <trans-unit id="083ecdb4eb83b1283f9d7370b6905eb300e214e7" translate="yes" xml:space="preserve">
          <source>The data may be retrieved using the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; function if the underlying type of the byte stream is known.</source>
          <target state="translated">如果字节流的基础类型是已知的，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 函数来检索数据。</target>
        </trans-unit>
        <trans-unit id="71f7b6c4c962003ad0e8bfcff7666dfb17bf3d56" translate="yes" xml:space="preserve">
          <source>The data may be retrieved using the &lt;code&gt;unpack&lt;/code&gt; function if the underlying type of the byte stream is known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63af91535a394b6aa4a43c6ecef621c3c5bffb80" translate="yes" xml:space="preserve">
          <source>The data of the file is not immediately available. This attribute indicates that the file data has been physically moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management software. Applications should not arbitrarily change this attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bb2c0f943e4592858ab2d05373119174b2d2dda" translate="yes" xml:space="preserve">
          <source>The data was added as a Unicode string and when writing it out to disk, the &lt;code&gt;:utf8&lt;/code&gt; line discipline wasn't set by &lt;code&gt;Archive::Tar&lt;/code&gt; , so Perl tried to convert the string to ISO-8859 and failed. The written file now contains garbage.</source>
          <target state="translated">数据作为Unicode字符串添加，并且在将其写到磁盘时， &lt;code&gt;Archive::Tar&lt;/code&gt; 并未设置 &lt;code&gt;:utf8&lt;/code&gt; 行规则，因此Perl尝试将字符串转换为ISO-8859并失败。写入的文件现在包含垃圾。</target>
        </trans-unit>
        <trans-unit id="a586674f2132d76d932dd3ae8f2556dfbebc1fb6" translate="yes" xml:space="preserve">
          <source>The data was added as a Unicode string and when writing it out to disk, the &lt;code&gt;:utf8&lt;/code&gt; line discipline wasn't set by &lt;code&gt;Archive::Tar&lt;/code&gt;, so Perl tried to convert the string to ISO-8859 and failed. The written file now contains garbage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ccb288f67ba8fe0c8510721b3e70886d45432a" translate="yes" xml:space="preserve">
          <source>The date and day names in dates formatted by &lt;code&gt;strftime()&lt;/code&gt; could be manipulated to advantage by a malicious user able to subvert the &lt;code&gt;LC_DATE&lt;/code&gt; locale. (&quot;Look--it says I wasn't in the building on Sunday.&quot;)</source>
          <target state="translated">能够颠覆 &lt;code&gt;LC_DATE&lt;/code&gt; 区域设置的恶意用户可以利用 &lt;code&gt;strftime()&lt;/code&gt; 格式化的日期中的日期和日期名称加以利用。（&amp;ldquo;看，它说我星期天不在大楼里。&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="c40b16f78ce75cc859be91a0613f27d3f68c2364" translate="yes" xml:space="preserve">
          <source>The day of the year is in the list returned by the &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; function. Without an argument &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; uses the current time.</source>
          <target state="translated">一年中的哪一天在 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 函数返回的列表中。不带参数的 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 使用当前时间。</target>
        </trans-unit>
        <trans-unit id="1c7a95dfcca9858a8405f98faf2612dd1935a1f7" translate="yes" xml:space="preserve">
          <source>The day of the year is in the list returned by the &lt;code&gt;localtime&lt;/code&gt; function. Without an argument &lt;code&gt;localtime&lt;/code&gt; uses the current time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d7e957f2b60e8e8af1a45f78007f3a710223c2" translate="yes" xml:space="preserve">
          <source>The days of just flinging strings around are over. It's well established that modern programs need to be capable of communicating funny accented letters, and things like euro symbols. This means that programmers need new habits. It's easy to program Unicode capable software, but it does require discipline to do it right.</source>
          <target state="translated">仅仅是甩动字符串的日子已经结束了。现代程序需要能够交流有趣的重音字母,以及像欧元符号这样的东西,这是公认的。这意味着程序员需要新的习惯。编写具有Unicode功能的软件是很容易的,但要做好它确实需要纪律。</target>
        </trans-unit>
        <trans-unit id="7d9856be0d4d4aa47742843ac8ee15803c0a6dbf" translate="yes" xml:space="preserve">
          <source>The debugger does not currently work in conjunction with the &lt;b&gt;-W&lt;/b&gt; command-line switch, because it itself is not free of warnings.</source>
          <target state="translated">调试器当前不能与&lt;b&gt;-W&lt;/b&gt;命令行开关一起使用，因为它本身没有警告。</target>
        </trans-unit>
        <trans-unit id="bff20683f233c3b1a43e85dddcc26c68e9457e08" translate="yes" xml:space="preserve">
          <source>The debugger has numerous options settable using the &lt;code&gt;o&lt;/code&gt; command, either interactively or from the environment or an rc file. (./.perldb or ~/.perldb under Unix.)</source>
          <target state="translated">调试器具有可使用 &lt;code&gt;o&lt;/code&gt; 命令设置的众多选项，可以交互地或从环境或rc文件中设置。（./.perldb或Unix下的〜/ .perldb。）</target>
        </trans-unit>
        <trans-unit id="2b8f02d76c62b5ac783a580e7846d6536aa86d85" translate="yes" xml:space="preserve">
          <source>The debugger probably contains enough configuration hooks that you won't ever have to modify it yourself. You may change the behaviour of the debugger from within the debugger using its &lt;code&gt;o&lt;/code&gt; command, from the command line via the &lt;code&gt;PERLDB_OPTS&lt;/code&gt; environment variable, and from customization files.</source>
          <target state="translated">调试器可能包含足够的配置挂钩，您无需亲自对其进行修改。您可以使用调试器的 &lt;code&gt;o&lt;/code&gt; 命令在调试器中，通过 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 环境变量在命令行中以及在自定义文件中更改调试器的行为。</target>
        </trans-unit>
        <trans-unit id="24bc00b2a7165b041b9ffd101df7fc63fd2218dd" translate="yes" xml:space="preserve">
          <source>The debugger prompt is something like</source>
          <target state="translated">调试器的提示是这样的</target>
        </trans-unit>
        <trans-unit id="f8e855d0dba7087b2dc163f59ea22e7610600301" translate="yes" xml:space="preserve">
          <source>The debugging output at compile time looks like this:</source>
          <target state="translated">编译时的调试输出是这样的。</target>
        </trans-unit>
        <trans-unit id="5cc26823ddc27c25d44117d4b49405e558f3683c" translate="yes" xml:space="preserve">
          <source>The declared variable is not introduced (is not visible) until after the current statement. Thus,</source>
          <target state="translated">声明的变量在当前语句之后才会被引入(不可见)。因此:</target>
        </trans-unit>
        <trans-unit id="9ae51c467cb04a1b525475d0b1964978fbf97d39" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;:perlio&lt;/code&gt; layer retries &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; as described above; interrupted &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; calls will always be retried.</source>
          <target state="translated">默认的 &lt;code&gt;:perlio&lt;/code&gt; 层如上所述重试 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; ；中断的 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 调用将始终重试。</target>
        </trans-unit>
        <trans-unit id="cc07a8196664bfcb190df25e9665ffed3bb1d528" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;:perlio&lt;/code&gt; layer retries &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;close&lt;/code&gt; as described above; interrupted &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;waitpid&lt;/code&gt; calls will always be retried.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7af57631245798d230b9a42590aed5504edc7411" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;TIEHASH&lt;/code&gt; method stores &quot;extra&quot; arguments to tie() starting from offset 1 in the array referenced by &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt;; this is the same storage algorithm as in TIEHASH subroutine above. Hence, a typical package inheriting from &lt;b&gt;Tie::ExtraHash&lt;/b&gt; does not need to overwrite this method.</source>
          <target state="translated">缺省的 &lt;code&gt;TIEHASH&lt;/code&gt; 方法从&amp;ldquo; tie &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt; 引用的数组中的偏移量1开始，将&amp;ldquo;额外&amp;rdquo;参数存储到tie（）中。这与上面的TIEHASH子例程中的存储算法相同。因此，继承自&lt;b&gt;Tie :: ExtraHash&lt;/b&gt;的典型程序包不需要覆盖此方法。</target>
        </trans-unit>
        <trans-unit id="d8f318f7bfa1b89c48af52e1a8f99d1af186c96f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;TIEHASH&lt;/code&gt; method stores &quot;extra&quot; arguments to tie() starting from offset 1 in the array referenced by &lt;code&gt;tied(%tiedhash)&lt;/code&gt;; this is the same storage algorithm as in TIEHASH subroutine above. Hence, a typical package inheriting from &lt;b&gt;Tie::ExtraHash&lt;/b&gt; does not need to overwrite this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e1aaf469c61ad0505179ca4ef693920d67bf62" translate="yes" xml:space="preserve">
          <source>The default behavior for matching can be changed, using various modifiers. Modifiers that relate to the interpretation of the pattern are listed just below. Modifiers that alter the way a pattern is used by Perl are detailed in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt; and &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;&quot;Gory details of parsing quoted constructs&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bacf1d67275db56db4c207815d6942a42814176" translate="yes" xml:space="preserve">
          <source>The default behavior is restored with the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; pragma, or upon reaching the end of the block enclosing &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . Note that &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; calls may be nested, and that what is in effect within an inner scope will revert to the outer scope's rules at the end of the inner scope.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; 编译命令或在包含 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的块结束时恢复默认行为。请注意， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 调用可能是嵌套的，内部作用域内有效的内容将在内部作用域末尾恢复为外部作用域的规则。</target>
        </trans-unit>
        <trans-unit id="7e3af61d974b45e2899ef4868c4839bde44f6b43" translate="yes" xml:space="preserve">
          <source>The default behavior is restored with the &lt;code&gt;no locale&lt;/code&gt; pragma, or upon reaching the end of the block enclosing &lt;code&gt;use locale&lt;/code&gt;. Note that &lt;code&gt;use locale&lt;/code&gt; calls may be nested, and that what is in effect within an inner scope will revert to the outer scope's rules at the end of the inner scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc252c3cc028e1614732f1daa492845981dc49a" translate="yes" xml:space="preserve">
          <source>The default behavior is to allow either VMS or Unix syntax on input and to return VMS syntax on output unless Unix syntax has been explicitly requested via the &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; CRTL feature.</source>
          <target state="translated">缺省行为是允许在输入上使用VMS或Unix语法，并在输出上返回VMS语法，除非已通过 &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; CRTL功能明确请求Unix语法。</target>
        </trans-unit>
        <trans-unit id="d9abf79a3fe513de5ab5f6341a0a6954a2315c50" translate="yes" xml:space="preserve">
          <source>The default behaviour for what</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dccc7bf2df4ee545fc6ed04ddf3f01c1358bdf3" translate="yes" xml:space="preserve">
          <source>The default behaviour of file test operators is to use the simple mode bits as returned by the stat() family of system calls. However, many operating systems have additional features to define more complex access rights, for example ACLs (Access Control Lists). For such environments, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; may help the permission operators to return results more consistent with other tools.</source>
          <target state="translated">文件测试操作员的默认行为是使用stat（）系列系统调用返回的简单模式位。但是，许多操作系统具有其他功能来定义更复杂的访问权限，例如ACL（访问控制列表）。对于此类环境， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; 可以帮助权限操作员返回与其他工具更一致的结果。</target>
        </trans-unit>
        <trans-unit id="b1be0363bbe710d46dddb1e57d79fb15e7183b86" translate="yes" xml:space="preserve">
          <source>The default behaviour of file test operators is to use the simple mode bits as returned by the stat() family of system calls. However, many operating systems have additional features to define more complex access rights, for example ACLs (Access Control Lists). For such environments, &lt;code&gt;use filetest&lt;/code&gt; may help the permission operators to return results more consistent with other tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3d08e8e13d1af1b8292d5961459da70c0fafa4" translate="yes" xml:space="preserve">
          <source>The default blacklist for Locale::Maketext also prevents use of the following methods in bracket notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e443bdcb2163a4573139a1dc139dfc380443bd8" translate="yes" xml:space="preserve">
          <source>The default blacklist is [qw|ftp|], as &lt;code&gt;/bin/ftp&lt;/code&gt; is rather unreliable.</source>
          <target state="translated">默认的黑名单是[qw | ftp |]，因为 &lt;code&gt;/bin/ftp&lt;/code&gt; 相当不可靠。</target>
        </trans-unit>
        <trans-unit id="ed0767b7e5643475189138ab836319b55629d878" translate="yes" xml:space="preserve">
          <source>The default buffer size is 4096.</source>
          <target state="translated">默认的缓冲区大小为4096。</target>
        </trans-unit>
        <trans-unit id="8bc00fd19b1a0edf6b2c0d08377dcc6685c37357" translate="yes" xml:space="preserve">
          <source>The default can be overridden by setting the environment variable PERLIO to a space separated list of layers (&lt;code&gt;unix&lt;/code&gt; or platform low level layer is always pushed first).</source>
          <target state="translated">可以通过将环境变量PERLIO设置为以空格分隔的层列表来覆盖默认值（始终首先推送 &lt;code&gt;unix&lt;/code&gt; 或平台低层层）。</target>
        </trans-unit>
        <trans-unit id="34b91bbcac281ec343e20574aee63c504ba37c87" translate="yes" xml:space="preserve">
          <source>The default command shells on DOS descendant operating systems (such as they are) usually do not expand wildcard arguments supplied to programs. They consider it the application's job to handle that. This is commonly achieved by linking the application (in our case, perl) with startup code that the C runtime libraries usually provide. However, doing that results in incompatible perl versions (since the behavior of the argv expansion code differs depending on the compiler, and it is even buggy on some compilers). Besides, it may be a source of frustration if you use such a perl binary with an alternate shell that *does* expand wildcards.</source>
          <target state="translated">DOS后代操作系统上的默认命令壳(如它们)通常不会扩展提供给程序的通配符参数。它们认为处理这些参数是应用程序的工作。这通常是通过将应用程序(在我们的例子中,perl)与C运行时库通常提供的启动代码链接来实现的。然而,这样做会导致不兼容的perl版本(因为argv扩展代码的行为根据编译器的不同而不同,甚至在某些编译器上是错误的)。此外,如果你使用这样的perl二进制文件和一个替代的shell,而这个shell是*可以扩展通配符的,那么这可能是一个挫败感的来源。</target>
        </trans-unit>
        <trans-unit id="83afe3e15499ebffd14384524a4838c21ad9ac57" translate="yes" xml:space="preserve">
          <source>The default delivery policy of signals changed in Perl v5.8.0 from immediate (also known as &quot;unsafe&quot;) to deferred, also known as &quot;safe signals&quot;. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more information.</source>
          <target state="translated">信号的默认传递策略在Perl v5.8.0中从即时（也称为&amp;ldquo;不安全&amp;rdquo;）更改为递延（也称为&amp;ldquo;安全信号&amp;rdquo;）。有关更多信息，请参见&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0b1ff51c2db16d895d3583e8ea3357f71cb7399" translate="yes" xml:space="preserve">
          <source>The default directory for this is the &lt;code&gt;plugins/CPAN::Plugin::Specfile&lt;/code&gt; directory in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e779baf9efd4d9532a5adc61d0ecb2fb82fd6ccb" translate="yes" xml:space="preserve">
          <source>The default exports of &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; do a complicated calculation when given a year value less than 1000. This leads to surprising results in many cases. See &lt;a href=&quot;#Year-Value-Interpretation&quot;&gt;&quot;Year Value Interpretation&quot;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60de20ca32864441bb2ece16480b765adbc68d5" translate="yes" xml:space="preserve">
          <source>The default filename translation is roughly &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr|/.|./|;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">默认的文件名翻译大约是 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr|/.|./|;&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f540cdd4f440c064d7b134e9369a41da6337cfdb" translate="yes" xml:space="preserve">
          <source>The default filename translation is roughly &lt;code&gt;tr|/.|./|&lt;/code&gt;, swapping dots and slashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b0d8e26001e75f3757789c285eac1caf4919f4" translate="yes" xml:space="preserve">
          <source>The default for &lt;code&gt;$svShare&lt;/code&gt; is &lt;code&gt;&quot;rw&quot;&lt;/code&gt; which provides the same sharing as using regular perl &lt;code&gt;open()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="189d94e0a4457922028f86938b0ce7520f054dc0" translate="yes" xml:space="preserve">
          <source>The default for this field, if it cannot be extracted, is to copy &lt;code&gt;$Config{osname}&lt;/code&gt;. The two may be differing in casing (OpenBSD vs openbsd).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141616a08e099cc503e54695ac44f2c439029e1f" translate="yes" xml:space="preserve">
          <source>The default for this option is off.</source>
          <target state="translated">该选项的默认值为关闭。</target>
        </trans-unit>
        <trans-unit id="841e53532f4d336433d317d532f99affc692102b" translate="yes" xml:space="preserve">
          <source>The default hash function has been modified with the intention of making it harder to infer the hash seed.</source>
          <target state="translated">默认的哈希函数已经被修改,目的是为了增加推断哈希种子的难度。</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="translated">默认的实现什么也不做。</target>
        </trans-unit>
        <trans-unit id="ba4a564c2fb984db1b9ac70f6b103f10fd3f2c07" translate="yes" xml:space="preserve">
          <source>The default in Perl 5.8.0 and later is to automatically use the &lt;code&gt;:perlio&lt;/code&gt; layer.</source>
          <target state="translated">Perl 5.8.0和更高版本中的默认设置是自动使用 &lt;code&gt;:perlio&lt;/code&gt; 层。</target>
        </trans-unit>
        <trans-unit id="c5b539403338a04682d5065664097088c7ee8126" translate="yes" xml:space="preserve">
          <source>The default indent space length is three. You can use &lt;code&gt;indent_length&lt;/code&gt; to change the length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c034d8cea0ccefbe74b407c47763a2d7febf85bd" translate="yes" xml:space="preserve">
          <source>The default input &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is coming from. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDIN&lt;/code&gt; .</source>
          <target state="translated">程序的默认输入&lt;b&gt;流&lt;/b&gt;，如果可能的话，不要理会其数据来自何处。在Perl程序中由&lt;b&gt;文件句柄&lt;/b&gt; &lt;code&gt;STDIN&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="aeb8819256c2fefb2deae155f9c497a4ece2df39" translate="yes" xml:space="preserve">
          <source>The default input &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is coming from. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDIN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65b453abcd65763f1788a5bfac88b6cf8e06702" translate="yes" xml:space="preserve">
          <source>The default input and pattern-searching space. The following pairs are equivalent:</source>
          <target state="translated">默认的输入和模式搜索空间。以下对子是等价的。</target>
        </trans-unit>
        <trans-unit id="cea52ce10c001ee673712587e9b895266781fd26" translate="yes" xml:space="preserve">
          <source>The default installation directory of Perl under PASE is /QOpenSys/perl. This can be modified if needed with Configure parameter -Dprefix=/some/dir.</source>
          <target state="translated">PASE下Perl的默认安装目录是/QOpenSys/perl,如果需要,可以通过配置参数-Dprefix=/some/dir来修改。如果需要,可以通过配置参数-Dprefix=/some/dir来修改。</target>
        </trans-unit>
        <trans-unit id="c02bd4590e22b3fdced3d71cd3c3281cc1a0a660" translate="yes" xml:space="preserve">
          <source>The default installation location for this release uses the traditional UNIX directory layout under /usr/local. This is the recommended location for most users, and will leave the Apple-supplied Perl and its modules undisturbed.</source>
          <target state="translated">这个版本的默认安装位置使用传统的 UNIX 目录布局,在 /usr/local 下。对于大多数用户来说,这是推荐的安装位置,它将使 Apple 提供的 Perl 及其模块不受干扰。</target>
        </trans-unit>
        <trans-unit id="2cf27b908bba58a1adbe27495a165db5ad0a8770" translate="yes" xml:space="preserve">
          <source>The default is 0.</source>
          <target state="translated">默认为0。</target>
        </trans-unit>
        <trans-unit id="b6e007f998a46a63459c07f21e8e579bcd3ddb9e" translate="yes" xml:space="preserve">
          <source>The default is 0;</source>
          <target state="translated">默认为0。</target>
        </trans-unit>
        <trans-unit id="2fede1b14731afaa7b9b9368ecc641901f9fa509" translate="yes" xml:space="preserve">
          <source>The default is 1 when &lt;a href=&quot;../warnings&quot;&gt;warnings&lt;/a&gt; are enabled, 0 otherwise;</source>
          <target state="translated">启用&lt;a href=&quot;../warnings&quot;&gt;警告后&lt;/a&gt;，默认值为1 ；否则为0；否则为0。</target>
        </trans-unit>
        <trans-unit id="b58a909406f580df200ff808a155d67c594063fb" translate="yes" xml:space="preserve">
          <source>The default is 1 when &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; are enabled, 0 otherwise;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515832f976590cbb3c71bc0d7d3d0a86a107732b" translate="yes" xml:space="preserve">
          <source>The default is 1.</source>
          <target state="translated">默认为1。</target>
        </trans-unit>
        <trans-unit id="895305ba9904fa755bf8e86c105e9e415a01803b" translate="yes" xml:space="preserve">
          <source>The default is 15 seconds. If you set this value to 0, no timeout will occur, but this is not recommended.</source>
          <target state="translated">默认值是15秒。如果将此值设置为0,则不会发生超时,但不建议这样做。</target>
        </trans-unit>
        <trans-unit id="df47c42104d45d72a320a61c09a39d1b3d97871e" translate="yes" xml:space="preserve">
          <source>The default is 1;</source>
          <target state="translated">默认为1。</target>
        </trans-unit>
        <trans-unit id="f462ad28c3fd0db899a9c6ebf2e36d1b531777fa" translate="yes" xml:space="preserve">
          <source>The default is 4096.</source>
          <target state="translated">默认值为4096。</target>
        </trans-unit>
        <trans-unit id="32bc975de1e1a4635ed927b65955622d6412a442" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;0&lt;/code&gt; .</source>
          <target state="translated">默认值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d612105f440a62563ca32f22b838324e618ccdeb" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b05c3b862baf5dbb3b6628baf4b68b1570abdb4" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;1&lt;/code&gt; .</source>
          <target state="translated">默认值为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e7ce922e57105bce0e95e91cfca276a6a4bf1ac" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;1&lt;/code&gt; for the root user and &lt;code&gt;0&lt;/code&gt; for normal users.</source>
          <target state="translated">对于root用户，默认值为 &lt;code&gt;1&lt;/code&gt; ；对于普通用户，默认值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96a31382338c2cce7d4e50686f56e0e9ff7debef" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf2b1ea0900573472d5b071e3de19f7567ee6bd" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b961dbd8be6b25800dc4b37b67546efccad28f8e" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; .</source>
          <target state="translated">默认值为 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfbfc9925e2dd8470367ef4195617d71c6222d8e" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc194b0254a7cf1688815756a4f2837510b9b267" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; .</source>
          <target state="translated">默认值为 &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a908c10942fd5ae6b565f1ce15f1bbfadcedfbe1" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40557fe038c23288a394f8bc56206a7b66f1744c" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;die&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb390eebfd5c04071c6f9ae432a01e30ec460a80" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;pod&lt;/code&gt; .</source>
          <target state="translated">默认值为 &lt;code&gt;pod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a27550390154dabd1f6cbb3ac3486e6b597d5bd" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;pod&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0a0f1ca8eef2f6fbf6f39dbd7668ad5fbc612a" translate="yes" xml:space="preserve">
          <source>The default is Z_DEFAULT_COMPRESSION.</source>
          <target state="translated">默认为Z_DEFAULT_COMPRESSION。</target>
        </trans-unit>
        <trans-unit id="ae93ce6388b29eb983caf1def75b439a9873a0b9" translate="yes" xml:space="preserve">
          <source>The default is Z_DEFAULT_STRATEGY.</source>
          <target state="translated">默认为Z_DEFAULT_STRATEGY。</target>
        </trans-unit>
        <trans-unit id="c52e69ffb8153da22fcf2e0c6d6adcb6a6ff963d" translate="yes" xml:space="preserve">
          <source>The default is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30329767ad59c2dc5630061d1ce79106ced2716" translate="yes" xml:space="preserve">
          <source>The default is no dictionary.</source>
          <target state="translated">默认是没有字典。</target>
        </trans-unit>
        <trans-unit id="0eaff3b0b1b9eb661e7fc7bd656a07d77ba2a1ef" translate="yes" xml:space="preserve">
          <source>The default is not to cuddle.</source>
          <target state="translated">默认情况下是不抱团的。</target>
        </trans-unit>
        <trans-unit id="7226202181b27bad8c72a76152482ae3e839b2c6" translate="yes" xml:space="preserve">
          <source>The default is to simply return the event package name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c65dc0d3752b5562d0e04006d66de6352709010" translate="yes" xml:space="preserve">
          <source>The default is to try &lt;code&gt;native&lt;/code&gt; , &lt;code&gt;tcp&lt;/code&gt; , &lt;code&gt;udp&lt;/code&gt; , &lt;code&gt;unix&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;stream&lt;/code&gt; , &lt;code&gt;console&lt;/code&gt; . Under systems with the Win32 API, &lt;code&gt;eventlog&lt;/code&gt; will be added as the first mechanism to try if &lt;code&gt;Win32::EventLog&lt;/code&gt; is available.</source>
          <target state="translated">默认是尝试使用 &lt;code&gt;native&lt;/code&gt; ， &lt;code&gt;tcp&lt;/code&gt; ， &lt;code&gt;udp&lt;/code&gt; ， &lt;code&gt;unix&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;stream&lt;/code&gt; ， &lt;code&gt;console&lt;/code&gt; 。在使用Win32 API的系统下，将添加 &lt;code&gt;eventlog&lt;/code&gt; 作为尝试 &lt;code&gt;Win32::EventLog&lt;/code&gt; 是否可用的第一种机制。</target>
        </trans-unit>
        <trans-unit id="ae6954e08dfdc077f1f7dcc91f272e939cf877ea" translate="yes" xml:space="preserve">
          <source>The default is to try &lt;code&gt;native&lt;/code&gt;, &lt;code&gt;tcp&lt;/code&gt;, &lt;code&gt;udp&lt;/code&gt;, &lt;code&gt;unix&lt;/code&gt;, &lt;code&gt;pipe&lt;/code&gt;, &lt;code&gt;stream&lt;/code&gt;, &lt;code&gt;console&lt;/code&gt;. Under systems with the Win32 API, &lt;code&gt;eventlog&lt;/code&gt; will be added as the first mechanism to try if &lt;code&gt;Win32::EventLog&lt;/code&gt; is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bb3e1a426b5cc38eac62d98ea857e63ed9b5dd" translate="yes" xml:space="preserve">
          <source>The default iterator variable in a &lt;code&gt;foreach&lt;/code&gt; loop if no other variable is supplied.</source>
          <target state="translated">如果未提供其他变量，则为 &lt;code&gt;foreach&lt;/code&gt; 循环中的默认迭代器变量。</target>
        </trans-unit>
        <trans-unit id="375ddf0ab7799023484d02f8a221ca6afd3b2054" translate="yes" xml:space="preserve">
          <source>The default memory limit is 2Mib. You can adjust the maximum read cache size by supplying the &lt;code&gt;memory&lt;/code&gt; option. The argument is the desired cache size, in bytes.</source>
          <target state="translated">默认的内存限制是2Mib。您可以通过提供 &lt;code&gt;memory&lt;/code&gt; 选项来调整最大读取缓存大小。参数是所需的缓存大小，以字节为单位。</target>
        </trans-unit>
        <trans-unit id="97d617432e38273ff2337188090afe707d321e91" translate="yes" xml:space="preserve">
          <source>The default method is ZIP_CM_DEFLATE.</source>
          <target state="translated">默认的方法是ZIP_CM_DEFLATE。</target>
        </trans-unit>
        <trans-unit id="d06faea5104288d8b0b633dc0567b8b191f0df74" translate="yes" xml:space="preserve">
          <source>The default name of the new configuration file is &quot;libnet.cfg&quot;, and by default it is written to the current directory, unless otherwise specified using the -o option, &lt;code&gt;-o newfile&lt;/code&gt; .</source>
          <target state="translated">新的配置文件的默认名称为&amp;ldquo; libnet.cfg&amp;rdquo;，默认情况下，它将写入当前目录，除非使用-o选项 &lt;code&gt;-o newfile&lt;/code&gt; 另行指定。</target>
        </trans-unit>
        <trans-unit id="408dfa6f2b57602d832595e17787ee724e235423" translate="yes" xml:space="preserve">
          <source>The default name of the new configuration file is &quot;libnet.cfg&quot;, and by default it is written to the current directory, unless otherwise specified using the -o option, &lt;code&gt;-o newfile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5074809750e6c620d635552cb416989d3d15b2" translate="yes" xml:space="preserve">
          <source>The default name of the old configuration file is by default &quot;libnet.cfg&quot;, unless otherwise specified using the -i option, &lt;code&gt;-i oldfile&lt;/code&gt; , and it is searched first from the current directory, and then from your module path.</source>
          <target state="translated">除非使用-i选项 &lt;code&gt;-i oldfile&lt;/code&gt; 另行指定，否则旧配置文件的缺省名称默认为&amp;ldquo; libnet.cfg&amp;rdquo; ，并且首先从当前目录中搜索，然后从模块路径中搜索。</target>
        </trans-unit>
        <trans-unit id="1fef6f94288b1eff625c2f95ef7ecffd1ba05913" translate="yes" xml:space="preserve">
          <source>The default name of the old configuration file is by default &quot;libnet.cfg&quot;, unless otherwise specified using the -i option, &lt;code&gt;-i oldfile&lt;/code&gt;, and it is searched first from the current directory, and then from your module path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb6185afb472dae00827acf41154ba83b345446" translate="yes" xml:space="preserve">
          <source>The default normalizer just concatenates the arguments with character 28 in between. (In ASCII, this is called FS or control-\.) This always works correctly for functions with only one string argument, and also when the arguments never contain character 28. However, it can confuse certain argument lists:</source>
          <target state="translated">默认的规范化处理只是将参数与中间的字符28连在一起。(在ASCII码中,这被称为FS或control-\。)这对于只有一个字符串参数的函数总是正确的,而且当参数从不包含字符28时也是如此。然而,它可能会混淆某些参数列表。</target>
        </trans-unit>
        <trans-unit id="b39e82de8afe051a851d53770ae84cf3c68d41cb" translate="yes" xml:space="preserve">
          <source>The default normalizer will turn this into something like &lt;code&gt;&quot;13\034ARRAY(0x436c1f)&quot;&lt;/code&gt; . That would be all right, except that a subsequent array of numbers might be stored at a different location even though it contains the same data. If this happens, &lt;code&gt;Memoize&lt;/code&gt; will think that the arguments are different, even though they are equivalent. In this case, a normalizer like this is appropriate:</source>
          <target state="translated">默认的规范化器将把它变成类似 &lt;code&gt;&quot;13\034ARRAY(0x436c1f)&quot;&lt;/code&gt; 。没关系，除了后续的数字数组可能存储在不同的位置，即使它包含相同的数据也是如此。如果发生这种情况，即使它们等效， &lt;code&gt;Memoize&lt;/code&gt; 也会认为参数是不同的。在这种情况下，合适的标准化器是这样的：</target>
        </trans-unit>
        <trans-unit id="82517263c6d17f4e83cb2dad91556a271e1fb059" translate="yes" xml:space="preserve">
          <source>The default normalizer will turn this into something like &lt;code&gt;&quot;13\034ARRAY(0x436c1f)&quot;&lt;/code&gt;. That would be all right, except that a subsequent array of numbers might be stored at a different location even though it contains the same data. If this happens, &lt;code&gt;Memoize&lt;/code&gt; will think that the arguments are different, even though they are equivalent. In this case, a normalizer like this is appropriate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d60aed408340ddef56e731c14beba1f193a756" translate="yes" xml:space="preserve">
          <source>The default of building Perl statically may cause problems with complex applications like Tk: in that case consider building shared Perl</source>
          <target state="translated">默认的静态构建Perl可能会导致像Tk这样的复杂应用程序出现问题:在这种情况下,可以考虑构建共享的Perl。</target>
        </trans-unit>
        <trans-unit id="ac5f6413f6edd9db793b85ce42ea2d862be3c9a0" translate="yes" xml:space="preserve">
          <source>The default operator mask for a newly created compartment is the ':default' optag.</source>
          <target state="translated">新建隔间的默认操作符掩码是':default'opag。</target>
        </trans-unit>
        <trans-unit id="cd7a35f6ae99c836f5d425b35999dec2510b2218" translate="yes" xml:space="preserve">
          <source>The default options gathered by Configure with the assistance of</source>
          <target state="translated">配置收集到的默认选项,并借助于</target>
        </trans-unit>
        <trans-unit id="340bacd1cab82a806d284b26719b4d768c188a8d" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for nasty remarks that don&amp;rsquo;t belong in &lt;b&gt;standard output&lt;/b&gt;. Represented within a Perl program by the output&amp;gt; &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDERR&lt;/code&gt; . You can use this stream explicitly, but the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; built-ins write to your standard error stream automatically (unless trapped or otherwise intercepted).</source>
          <target state="translated">不属于&lt;b&gt;标准输出的&lt;/b&gt;令人讨厌的评论的默认输出&lt;b&gt;流&lt;/b&gt;。在Perl程序中由output&amp;gt; &lt;b&gt;文件句柄&lt;/b&gt; &lt;code&gt;STDERR&lt;/code&gt; 表示。您可以显式使用此流，但是 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 内置函数会自动写入标准错误流（除非被捕获或以其他方式拦截）。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9d2c9ac156cbf55108641e915b384d66d9246e77" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for nasty remarks that don&amp;rsquo;t belong in &lt;b&gt;standard output&lt;/b&gt;. Represented within a Perl program by the output&amp;gt; &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDERR&lt;/code&gt;. You can use this stream explicitly, but the &lt;code&gt;die&lt;/code&gt; and &lt;code&gt;warn&lt;/code&gt; built-ins write to your standard error stream automatically (unless trapped or otherwise intercepted).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa254ec270a416bb3ac03f5a884b155a435c80cb" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is going. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">程序的默认输出&lt;b&gt;流&lt;/b&gt;，如果可能的话，它不必理会数据的流向。在Perl程序中由&lt;b&gt;文件句柄&lt;/b&gt; &lt;code&gt;STDOUT&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="ce1dc62266e22cc3e68d183b4a85d64622b5e7d5" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is going. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDOUT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96d4d616212a6cfd4d2816b5ab3f17c9db66319" translate="yes" xml:space="preserve">
          <source>The default output of self-referential structures can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed, but the nested references to &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">可以对自引用结构的默认输出进行 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，但是对 &lt;code&gt;$VAR&lt;/code&gt; 的嵌套引用</target>
        </trans-unit>
        <trans-unit id="ab4464102ba1e6fbe0c2c60b9748efe43e91939d" translate="yes" xml:space="preserve">
          <source>The default output of self-referential structures can be &lt;code&gt;eval&lt;/code&gt;ed, but the nested references to &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f2d9e51d87e9b71a9bd992e69d11af3ccda88f" translate="yes" xml:space="preserve">
          <source>The default path for perl binary is /QOpenSys/perl/bin/perl. You'll want to symlink /QOpenSys/usr/bin/perl to this file so you don't have to modify your path.</source>
          <target state="translated">perl二进制文件的默认路径是/QOpenSys/perl/bin/perl。你需要将/QOpenSys/usr/bin/perl链接到这个文件,这样你就不用修改路径了。</target>
        </trans-unit>
        <trans-unit id="c0e7903465e131bba24e8f9fa0f5926ebf1b8dce" translate="yes" xml:space="preserve">
          <source>The default per-thread stack size for different platforms varies significantly, and is almost always far more than is needed for most applications. On Win32, Perl's makefile explicitly sets the default stack to 16 MB; on most other platforms, the system default is used, which again may be much larger than is needed.</source>
          <target state="translated">不同平台上默认的每线程堆栈大小差异很大,几乎总是远远超过大多数应用程序的需要。在Win32平台上,Perl的makefile明确地将默认栈设置为16MB;在其他大多数平台上,则使用系统默认值,但也可能比需要的大得多。</target>
        </trans-unit>
        <trans-unit id="02fbe3c9bc6d319100d5d82a643c83d45a2aaf27" translate="yes" xml:space="preserve">
          <source>The default per-thread stack size may be set at the start of the application through the use of the environment variable &lt;code&gt;PERL5_ITHREADS_STACK_SIZE&lt;/code&gt; :</source>
          <target state="translated">可以使用环境变量 &lt;code&gt;PERL5_ITHREADS_STACK_SIZE&lt;/code&gt; 在应用程序启动时设置默认的每线程堆栈大小：</target>
        </trans-unit>
        <trans-unit id="94af03e91a740f430511958dbcda39a82148e50f" translate="yes" xml:space="preserve">
          <source>The default per-thread stack size may be set at the start of the application through the use of the environment variable &lt;code&gt;PERL5_ITHREADS_STACK_SIZE&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17c04396f5d2338f66524479b64e4296e2bc5c4" translate="yes" xml:space="preserve">
          <source>The default perl executable is flexible enough to support most usages. However, one may want something yet more flexible; for example, one may want to find Perl DLL relatively to the location of the EXE file; or one may want to ignore the environment when setting the Perl-library search patch, etc.</source>
          <target state="translated">默认的perl可执行文件足够灵活,可以支持大多数用途。然而,人们可能想要一些更灵活的东西;例如,人们可能想要相对于EXE文件的位置来查找Perl DLL;或者人们可能想要在设置Perl库搜索补丁时忽略环境等等。</target>
        </trans-unit>
        <trans-unit id="7009bdcf386245a7873fc69dc2c48c3bfdcf71d9" translate="yes" xml:space="preserve">
          <source>The default permissions to use if a new file is created. The actual permissions will be modified by the user's umask, so you should probably use 0666 here. (See &lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;.)</source>
          <target state="translated">创建新文件时使用的默认权限。实际的权限将由用户的umask修改，因此您可能应该在此处使用0666。（请参见&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="81e2f33b41f0b680f7cab719bcc71740e182cd7b" translate="yes" xml:space="preserve">
          <source>The default permissions to use if a new file is created. The actual permissions will be modified by the user's umask, so you should probably use 0666 here. (See &lt;a href=&quot;perlfunc#umask&quot;&gt;&quot;umask&quot; in perlfunc&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af672db5716c0b823ab6d08666d2a653d572eae5" translate="yes" xml:space="preserve">
          <source>The default place to put the next value or input record when a &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; operation's result is tested by itself as the sole criterion of a &lt;code&gt;while&lt;/code&gt; test. Outside a &lt;code&gt;while&lt;/code&gt; test, this will not happen.</source>
          <target state="translated">当单独测试 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 操作的结果时，放置下一个值或输入记录的默认位置是 &lt;code&gt;while&lt;/code&gt; 测试的唯一标准。经过一段 &lt;code&gt;while&lt;/code&gt; 测试，这不会发生。</target>
        </trans-unit>
        <trans-unit id="d37b151c3f1ab65346e3808827390e5bd84764e9" translate="yes" xml:space="preserve">
          <source>The default place to put the next value or input record when a &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt;, &lt;code&gt;readline&lt;/code&gt;, &lt;code&gt;readdir&lt;/code&gt; or &lt;code&gt;each&lt;/code&gt; operation's result is tested by itself as the sole criterion of a &lt;code&gt;while&lt;/code&gt; test. Outside a &lt;code&gt;while&lt;/code&gt; test, this will not happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5df9208ed1f779ba0f9d5864d277d9b22483511" translate="yes" xml:space="preserve">
          <source>The default rendering is top-down, so they're not in execution order. This form reflects the way the stack is used to parse and evaluate expressions; the add operates on the two terms below it in the tree.</source>
          <target state="translated">默认的呈现方式是自上而下,所以它们的执行顺序并不一致。这种形式反映了堆栈用来解析和评估表达式的方式,添加是对树中它下面的两个项进行操作。</target>
        </trans-unit>
        <trans-unit id="2fc20ab6a2146e41cd4461ac23c56be7f29f5c25" translate="yes" xml:space="preserve">
          <source>The default rounding mode is 'even'. By using &lt;code&gt;Math::BigFloat-&amp;gt;round_mode($round_mode);&lt;/code&gt; you can get and set the default mode for subsequent rounding. The usage of &lt;code&gt;$Math::BigFloat::$round_mode&lt;/code&gt; is no longer supported. The second parameter to the round functions then overrides the default temporarily.</source>
          <target state="translated">默认舍入模式为&amp;ldquo;偶数&amp;rdquo;。通过使用 &lt;code&gt;Math::BigFloat-&amp;gt;round_mode($round_mode);&lt;/code&gt; 您可以获取并设置默认模式以进行后续舍入。不再支持 &lt;code&gt;$Math::BigFloat::$round_mode&lt;/code&gt; 的用法。然后，舍入函数的第二个参数临时覆盖默认值。</target>
        </trans-unit>
        <trans-unit id="0c0082ed0ee0f68ac7247af3405f6e36532a7d14" translate="yes" xml:space="preserve">
          <source>The default set of layers should give acceptable results on all platforms</source>
          <target state="translated">默认的图层集应该在所有平台上都能提供可接受的结果。</target>
        </trans-unit>
        <trans-unit id="df981f37a11491520138a9699f03c2d8e3a6701d" translate="yes" xml:space="preserve">
          <source>The default set of layers should give acceptable results on all platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f212f2163021f600388dfedb85757788b2ee77" translate="yes" xml:space="preserve">
          <source>The default sort function is cmp, string comparison, which would sort &lt;code&gt;(1, 2, 10)&lt;/code&gt; into &lt;code&gt;(1, 10, 2)&lt;/code&gt; . &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; , used above, is the numerical comparison operator.</source>
          <target state="translated">缺省排序功能是CMP，字符串比较，这将排序 &lt;code&gt;(1, 2, 10)&lt;/code&gt; 到 &lt;code&gt;(1, 10, 2)&lt;/code&gt; 。上面使用的 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 是数值比较运算符。</target>
        </trans-unit>
        <trans-unit id="353560b1cc4cc620cb2f91f0d6a0c54645b715f0" translate="yes" xml:space="preserve">
          <source>The default sort function is cmp, string comparison, which would sort &lt;code&gt;(1, 2, 10)&lt;/code&gt; into &lt;code&gt;(1, 10, 2)&lt;/code&gt;. &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;, used above, is the numerical comparison operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d032c7cba8f64635473f913417491617017d4ca8" translate="yes" xml:space="preserve">
          <source>The default stringification for version objects returns exactly the same string as was used to create it, whether you used &lt;code&gt;new()&lt;/code&gt; or &lt;code&gt;qv()&lt;/code&gt;, with one exception. The sole exception is if the object was created using &lt;code&gt;qv()&lt;/code&gt; and the initializer did not have two decimal places or a leading 'v' (both optional), then the stringified form will have a leading 'v' prepended, in order to support round-trip processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa9ec2a72f812d2fff5978a7051ec1d9ead2a46" translate="yes" xml:space="preserve">
          <source>The default subscript separator is &quot;\034&quot;, the same as SUBSEP in &lt;b&gt;awk&lt;/b&gt;.</source>
          <target state="translated">默认的下标分隔符为&amp;ldquo; \ 034&amp;rdquo;，与&lt;b&gt;awk中的&lt;/b&gt; SUBSEP相同。</target>
        </trans-unit>
        <trans-unit id="497fecb3c603ebf0c33d9ba37b78e38f23ed6d1f" translate="yes" xml:space="preserve">
          <source>The default text formatter is &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt;. The base class for Pod::Usage can be defined by pre-setting &lt;code&gt;$Pod::Usage::Formatter&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fedbef30ad12f7c78358c3195161f7bf65ed2265" translate="yes" xml:space="preserve">
          <source>The default text formatter is &lt;a href=&quot;text&quot;&gt;Pod::Text&lt;/a&gt;. The base class for Pod::Usage can be defined by pre-setting &lt;code&gt;$Pod::Usage::Formatter&lt;/code&gt;</source>
          <target state="translated">默认的文本格式为&lt;a href=&quot;text&quot;&gt;Pod :: Text&lt;/a&gt;。可以通过预先设置 &lt;code&gt;$Pod::Usage::Formatter&lt;/code&gt; 来定义Pod :: Usage的基类。</target>
        </trans-unit>
        <trans-unit id="2eca7e39567cc3a4e38f07441f8e4f7046f9b14f" translate="yes" xml:space="preserve">
          <source>The default type for the constants. If not specified &lt;code&gt;IV&lt;/code&gt; is assumed.</source>
          <target state="translated">常量的默认类型。如果未指定，则假定为 &lt;code&gt;IV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a6f652439685a6a403073936eade467faa79602" translate="yes" xml:space="preserve">
          <source>The default typemap in the</source>
          <target state="translated">中的默认类型图。</target>
        </trans-unit>
        <trans-unit id="82f3cb0c641077271c3068ea9c85e22ba715cfbb" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;div_scale&lt;/code&gt; is 40.</source>
          <target state="translated">&lt;code&gt;div_scale&lt;/code&gt; 的默认值为40。</target>
        </trans-unit>
        <trans-unit id="609bf4918ead31f720f19323f5cf2348643f6d2e" translate="yes" xml:space="preserve">
          <source>The default value for CCHOME in the makefiles for Visual C++ may not be correct for some versions. Make sure the default exists and is valid.</source>
          <target state="translated">在Visual C++的makefiles中,CCHOME的默认值对某些版本来说可能不正确。请确保默认值存在并且有效。</target>
        </trans-unit>
        <trans-unit id="80bc06aeaa38f855546b7a2a3a5c29a6a05fdf78" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;30&lt;/code&gt; seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f34862d6782defbe2c5b2a0445c8f00de39fa4d" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;XSINTERFACE_FUNC&lt;/code&gt; and &lt;code&gt;XSINTERFACE_FUNC_SET&lt;/code&gt; . An INTERFACE keyword with an empty list of functions can be omitted if INTERFACE_MACRO keyword is used.</source>
          <target state="translated">默认值为 &lt;code&gt;XSINTERFACE_FUNC&lt;/code&gt; 和 &lt;code&gt;XSINTERFACE_FUNC_SET&lt;/code&gt; 。如果使用INTERFACE_MACRO关键字，则可以省略带有空函数列表的INTERFACE关键字。</target>
        </trans-unit>
        <trans-unit id="32834cb885f5de67f85718b2d51a3b3a71e20354" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;XSINTERFACE_FUNC&lt;/code&gt; and &lt;code&gt;XSINTERFACE_FUNC_SET&lt;/code&gt;. An INTERFACE keyword with an empty list of functions can be omitted if INTERFACE_MACRO keyword is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae2f809fd681df4fcb45c0c13d99a0283fc66b8" translate="yes" xml:space="preserve">
          <source>The definition used for complex arguments of atan2() is</source>
          <target state="translated">用于atan2()的复杂参数的定义是</target>
        </trans-unit>
        <trans-unit id="6431fb44fb840f90a758f20a67dcf8b7a9374aa9" translate="yes" xml:space="preserve">
          <source>The del_dup() Method</source>
          <target state="translated">del_dup()方法</target>
        </trans-unit>
        <trans-unit id="4c063e0f96bfc07d5c7996a96961c2627b3a8bf5" translate="yes" xml:space="preserve">
          <source>The delimiter is used to determine the &lt;b&gt;exact&lt;/b&gt; whitespace to remove from the beginning of each line. All lines &lt;b&gt;must&lt;/b&gt; have at least the same starting whitespace (except lines only containing a newline) or perl will croak. Tabs and spaces can be mixed, but are matched exactly. One tab will not be equal to 8 spaces!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1ded41373481d9b3a2afdb892465f6f5d0d39d" translate="yes" xml:space="preserve">
          <source>The delimiter provided to &lt;code&gt;extract_bracketed&lt;/code&gt; was not one of &lt;code&gt;'()[]&amp;lt;&amp;gt;{}'&lt;/code&gt; .</source>
          <target state="translated">提供给 &lt;code&gt;extract_bracketed&lt;/code&gt; 的分隔符不是 &lt;code&gt;'()[]&amp;lt;&amp;gt;{}'&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="3c4b77b961d2e96dc174edd63ec1e4a27ffd7394" translate="yes" xml:space="preserve">
          <source>The delimiter provided to &lt;code&gt;extract_bracketed&lt;/code&gt; was not one of &lt;code&gt;'()[]&amp;lt;&amp;gt;{}'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e6b6844fe43a8d8ec1aad6ff952638a46635ab3" translate="yes" xml:space="preserve">
          <source>The denizens of makemaker@perl.org.</source>
          <target state="translated">makemaker@perl.org 的居民。</target>
        </trans-unit>
        <trans-unit id="04df92977d147f1a13e2b1c8b477d27313374630" translate="yes" xml:space="preserve">
          <source>The deprecated features will be grouped by the version of Perl in which they will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1156b058c0b8098efde49eb59cb1671d23c2fe" translate="yes" xml:space="preserve">
          <source>The dereferencing cases (as opposed to method-calling cases) are somewhat extended by the &lt;code&gt;postderef&lt;/code&gt; feature. For the details of that feature, consult &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;&quot;Postfix Dereference Syntax&quot; in perlref&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c12d31655a68b617bd8f8ac7d7b41ffa97d8df" translate="yes" xml:space="preserve">
          <source>The dereferencing cases (as opposed to method-calling cases) are somewhat extended by the experimental &lt;code&gt;postderef&lt;/code&gt; feature. For the details of that feature, consult &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;Postfix Dereference Syntax in perlref&lt;/a&gt;.</source>
          <target state="translated">取消引用的情况（与方法调用的情况相反）通过实验性的 &lt;code&gt;postderef&lt;/code&gt; 功能得到了扩展。有关该功能的详细信息，请参阅&lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;perlref中的Postfix Dereference Syntax&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e1ecac0ff0943f872a0e4773ff40533e7fc7967" translate="yes" xml:space="preserve">
          <source>The description will also include tags for other special editions, like &quot;R2&quot;, &quot;Media Center&quot;, &quot;Tablet PC&quot;, or &quot;Starter Edition&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06b4b9a1d8e7058531ada60d67614dbcf01dfd0" translate="yes" xml:space="preserve">
          <source>The deserializing hook called on the object during deserialization. But wait: if we're deserializing, there's no object yet... right?</source>
          <target state="translated">在反序列化过程中,反序列化钩子对对象进行了调用。但是等等:如果我们在反序列化,还没有对象......对吗?</target>
        </trans-unit>
        <trans-unit id="8a2f99ef5bda346c32f63e70a7361acb83da8b02" translate="yes" xml:space="preserve">
          <source>The design intent is for &lt;code&gt;\d&lt;/code&gt; to exactly match the set of characters that can safely be used with &quot;normal&quot; big-endian positional decimal syntax, where, for example 123 means one 'hundred', plus two 'tens', plus three 'ones'. This positional notation does not necessarily apply to characters that match the other type of &quot;digit&quot;, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , and so &lt;code&gt;\d&lt;/code&gt; doesn't match them.</source>
          <target state="translated">设计意图是使 &lt;code&gt;\d&lt;/code&gt; 完全匹配可以安全地与&amp;ldquo;常规&amp;rdquo;大端位置十进制语法一起使用的字符集，例如123表示一个&amp;ldquo;百&amp;rdquo;，两个&amp;ldquo;十&amp;rdquo;，三个&amp;ldquo;那些'。此位置标记不一定适用于与其他类型的&amp;ldquo;数字&amp;rdquo;匹配的字符 &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; ，因此 &lt;code&gt;\d&lt;/code&gt; 与它们不匹配。</target>
        </trans-unit>
        <trans-unit id="f61094774e8ce7d5c193ad9edc881d479e0d9584" translate="yes" xml:space="preserve">
          <source>The design intent is for &lt;code&gt;\d&lt;/code&gt; to exactly match the set of characters that can safely be used with &quot;normal&quot; big-endian positional decimal syntax, where, for example 123 means one 'hundred', plus two 'tens', plus three 'ones'. This positional notation does not necessarily apply to characters that match the other type of &quot;digit&quot;, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt;, and so &lt;code&gt;\d&lt;/code&gt; doesn't match them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a51af6f52e45aaf611688acf5b39dc61f9ae40" translate="yes" xml:space="preserve">
          <source>The desire of users to express filenames of the form &lt;code&gt;&amp;lt;Foo$Dir&amp;gt;.Bar&lt;/code&gt; on the command line unquoted causes problems, too: &lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt;&lt;code&gt;``&lt;/code&gt;&lt;/a&gt; command output capture has to perform a guessing game. It assumes that a string &lt;code&gt;&amp;lt;[^&amp;lt;&amp;gt;]+\$[^&amp;lt;&amp;gt;]&amp;gt;&lt;/code&gt; is a reference to an environment variable, whereas anything else involving &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; is redirection, and generally manages to be 99% right. Of course, the problem remains that scripts cannot rely on any Unix tools being available, or that any tools found have Unix-like command line arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ec3b1b57d74d9cf92c20c7537d430a4cb91982" translate="yes" xml:space="preserve">
          <source>The desire of users to express filenames of the form &lt;code&gt;&amp;lt;Foo$Dir&amp;gt;.Bar&lt;/code&gt; on the command line unquoted causes problems, too: &lt;code&gt;``&lt;/code&gt; command output capture has to perform a guessing game. It assumes that a string &lt;code&gt;&amp;lt;[^&amp;lt;&amp;gt;]+\$[^&amp;lt;&amp;gt;]&amp;gt;&lt;/code&gt; is a reference to an environment variable, whereas anything else involving &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; is redirection, and generally manages to be 99% right. Of course, the problem remains that scripts cannot rely on any Unix tools being available, or that any tools found have Unix-like command line arguments.</source>
          <target state="translated">用户希望以 &lt;code&gt;&amp;lt;Foo$Dir&amp;gt;.Bar&lt;/code&gt; 形式表示文件名而在命令行上未引用也会引起问题： &lt;code&gt;``&lt;/code&gt; 命令输出捕获必须执行猜测游戏。它假定字符串 &lt;code&gt;&amp;lt;[^&amp;lt;&amp;gt;]+\$[^&amp;lt;&amp;gt;]&amp;gt;&lt;/code&gt; 是对环境变量的引用，而涉及 &lt;code&gt;&amp;lt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;&lt;/code&gt; 的其他任何东西都是重定向的，通常正确率是99％。当然，问题仍然在于脚本不能依赖任何可用的Unix工具，或者找到的任何工具都具有类似Unix的命令行参数。</target>
        </trans-unit>
        <trans-unit id="a11af240187e8ce0ea57c0f5d9817fa72798ba59" translate="yes" xml:space="preserve">
          <source>The desired exit status to pass to the &lt;b&gt;exit()&lt;/b&gt; function. This should be an integer, or else the string &quot;NOEXIT&quot; to indicate that control should simply be returned without terminating the invoking process.</source>
          <target state="translated">所需的退出状态，以传递给&lt;b&gt;exit（）&lt;/b&gt;函数。它应该是一个整数，或者是字符串&amp;ldquo; NOEXIT&amp;rdquo;，以指示应该简单地返回控件而不终止调用过程。</target>
        </trans-unit>
        <trans-unit id="a47bdc95431692c8deb0f97084523a81a5887de3" translate="yes" xml:space="preserve">
          <source>The desired level of &quot;verboseness&quot; to use when printing the usage message. If the corresponding value is 0, then only the &quot;SYNOPSIS&quot; section of the pod documentation is printed. If the corresponding value is 1, then the &quot;SYNOPSIS&quot; section, along with any section entitled &quot;OPTIONS&quot;, &quot;ARGUMENTS&quot;, or &quot;OPTIONS AND ARGUMENTS&quot; is printed. If the corresponding value is 2 or more then the entire manpage is printed.</source>
          <target state="translated">打印使用信息时需要使用的 &quot;verboseness &quot;级别。如果对应的值为 0,则只打印 pod 文档的 &quot;SYNOPSIS &quot;部分。如果对应值为 1,则打印 &quot;SYNOPSIS &quot;部分,以及任何题为 &quot;OPTIONS&quot;、&quot;ARGUMENTS &quot;或 &quot;OPTIONS AND ARGUMENTS &quot;的部分。如果对应值为2或更多,则打印整个页面。</target>
        </trans-unit>
        <trans-unit id="a260934a8f226c98347f68c3fcc330ccf45f5926" translate="yes" xml:space="preserve">
          <source>The desired level of &quot;verboseness&quot; to use when printing the usage message. If the value is 0, then only the &quot;SYNOPSIS&quot; section of the pod documentation is printed. If the value is 1, then the &quot;SYNOPSIS&quot; section, along with any section entitled &quot;OPTIONS&quot;, &quot;ARGUMENTS&quot;, or &quot;OPTIONS AND ARGUMENTS&quot; is printed. If the corresponding value is 2 or more then the entire manpage is printed, using &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; if available; otherwise &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; is used for the formatting. For better readability, the all-capital headings are downcased, e.g. &lt;code&gt;SYNOPSIS&lt;/code&gt; =&amp;gt; &lt;code&gt;Synopsis&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3e64d006f3001c3df4472f5962fd664df30c48" translate="yes" xml:space="preserve">
          <source>The desired level of verbosity to use:</source>
          <target state="translated">所需使用的口头禅程度。</target>
        </trans-unit>
        <trans-unit id="d21703722988891fb3f110d6e6d4a04ddd13048a" translate="yes" xml:space="preserve">
          <source>The destination directory is C:\Symbian\perl\X.Y.Z. For more details, see</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f8c4d84dbcf0f5f2d69ca16b4ced3235af3fefd" translate="yes" xml:space="preserve">
          <source>The destination for the option must be an array or array reference.</source>
          <target state="translated">选项的目标必须是一个数组或数组引用。</target>
        </trans-unit>
        <trans-unit id="409e973fa41301f9011188be107ecc88ef0e437c" translate="yes" xml:space="preserve">
          <source>The details for those items which may deviate from what this emulation returns and what a native &lt;code&gt;nl_langinfo()&lt;/code&gt; would return are specified in &lt;a href=&quot;I18N::Langinfo&quot;&gt;I18N::Langinfo&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2940ce84da888fbb72c23c514c9cdd4e2c7bab4a" translate="yes" xml:space="preserve">
          <source>The detection algorithm works something like this:</source>
          <target state="translated">检测算法的工作原理是这样的。</target>
        </trans-unit>
        <trans-unit id="8e261118eabba6fd9f550b8549a8f692c8f65be6" translate="yes" xml:space="preserve">
          <source>The develop phase's prereqs are libraries needed to work on the distribution's source code as its author does. These tools might be needed to build a release tarball, to run author-only tests, or to perform other tasks related to developing new versions of the distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd0b50108607e59344e69b0de3bc9fd4f301247" translate="yes" xml:space="preserve">
          <source>The diagnostics Pragma</source>
          <target state="translated">诊断原则</target>
        </trans-unit>
        <trans-unit id="9e8272da23da05393615d77b37bcea56278deff5" translate="yes" xml:space="preserve">
          <source>The diagnostics of this test normally just refer to 'the object'. If you'd like them to be more specific, you can supply an $object_name (for example 'Test customer').</source>
          <target state="translated">这个测试的诊断程序通常只提到 &quot;对象&quot;。如果你想让它们更具体,你可以提供一个$object_name (例如'Test customer')。</target>
        </trans-unit>
        <trans-unit id="67027b213e7e98e89fd8e5ebf75f4789f0806d73" translate="yes" xml:space="preserve">
          <source>The diagram below represents a single source stream, with the flow of source from a Perl script file on the left into the Perl parser on the right. This is how Perl normally operates.</source>
          <target state="translated">下图表示一个单一的源流,源流从左边的Perl脚本文件进入右边的Perl解析器。这就是Perl的正常操作方式。</target>
        </trans-unit>
        <trans-unit id="09d12bc25e1c17128a784d1b2ff7f2b3ea6c5f9e" translate="yes" xml:space="preserve">
          <source>The die on line 4 pops the context stack back down to the CxEVAL, leaving it as:</source>
          <target state="translated">第4行的模子将上下文堆栈弹回CxEVAL,使其为。</target>
        </trans-unit>
        <trans-unit id="930610eed704196a6c02e9606fed36fd7cdf0a59" translate="yes" xml:space="preserve">
          <source>The die pops the first &lt;code&gt;CxEVAL&lt;/code&gt; off the context stack, sets &lt;code&gt;PL_restartop&lt;/code&gt; from it, does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; , and control returns to the top &lt;code&gt;docatch&lt;/code&gt; . This then starts another third-level runops level, which executes the nextstate, pushmark and die ops on line 4. At the point that the second &lt;code&gt;pp_die&lt;/code&gt; is called, the C call stack looks exactly like that above, even though we are no longer within an inner eval; this is because of the optimization mentioned earlier. However, the context stack now looks like this, ie with the top CxEVAL popped:</source>
          <target state="translated">模具将第一个 &lt;code&gt;CxEVAL&lt;/code&gt; 从上下文堆栈中弹出，从中设置 &lt;code&gt;PL_restartop&lt;/code&gt; ，执行 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; ，然后控制返回到顶部 &lt;code&gt;docatch&lt;/code&gt; 。然后，这将启动另一个第三级运行级别，该运行级别在第4行执行nextstate，pushmark和die ops。在第二个 &lt;code&gt;pp_die&lt;/code&gt; 被调用的时刻，C调用堆栈看起来与上面的完全一样，即使我们不再位于内部评估 这是由于前面提到的优化。但是，上下文堆栈现在看起来像这样，即弹出顶部的CxEVAL：</target>
        </trans-unit>
        <trans-unit id="bbbbc185d1013ac982e3992e43afeb11193aeae4" translate="yes" xml:space="preserve">
          <source>The die pops the first &lt;code&gt;CxEVAL&lt;/code&gt; off the context stack, sets &lt;code&gt;PL_restartop&lt;/code&gt; from it, does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt;, and control returns to the top &lt;code&gt;docatch&lt;/code&gt;. This then starts another third-level runops level, which executes the nextstate, pushmark and die ops on line 4. At the point that the second &lt;code&gt;pp_die&lt;/code&gt; is called, the C call stack looks exactly like that above, even though we are no longer within an inner eval; this is because of the optimization mentioned earlier. However, the context stack now looks like this, ie with the top CxEVAL popped:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed5acbfe1a4a69e2eecb34b13c8306880da82cf" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;extract_tagged&lt;/code&gt; and the anonymous subroutines generated by &lt;code&gt;gen_extract_tagged&lt;/code&gt; , is that those generated subroutines:</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; 和 &lt;code&gt;gen_extract_tagged&lt;/code&gt; 生成的匿名子例程之间的区别在于，这些子例程生成的：</target>
        </trans-unit>
        <trans-unit id="4192a9e6844188f610795705ae7b4477088fe04b" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;extract_tagged&lt;/code&gt; and the anonymous subroutines generated by &lt;code&gt;gen_extract_tagged&lt;/code&gt;, is that those generated subroutines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6f28f40692ae97e2ea2e8080e59d267505ccf0" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;minlen&lt;/code&gt; and &lt;code&gt;minlenret&lt;/code&gt; can be seen in the following pattern:</source>
          <target state="translated">&lt;code&gt;minlen&lt;/code&gt; 和 &lt;code&gt;minlenret&lt;/code&gt; 之间的差异可以通过以下模式看出：</target>
        </trans-unit>
        <trans-unit id="f8ae9fbf98646f2ef8526e7b39bf817f11262438" translate="yes" xml:space="preserve">
          <source>The difference between a block and a script is that scripts are closer to the linguistic notion of a set of code points required to represent languages, while block is more of an artifact of the Unicode code point numbering and separation into blocks of consecutive code points (so far the size of a block is some multiple of 16, like 128 or 256).</source>
          <target state="translated">块和脚本的区别在于,脚本更接近语言学上的概念,即表示语言所需的一组码点,而块更多的是Unicode码点编号和分离成连续码点块的产物(到目前为止,块的大小是16的某个倍数,比如128或256)。</target>
        </trans-unit>
        <trans-unit id="4e0fd5df1eb8c3e578915cd6f8934c4fe5cf676a" translate="yes" xml:space="preserve">
          <source>The difference between these two properties involves characters that are used in multiple scripts. For example the digits '0' through '9' are used in many parts of the world. These are placed in a script named &lt;code&gt;Common&lt;/code&gt; . Other characters are used in just a few scripts. For example, the &lt;code&gt;&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;&lt;/code&gt; is used in both Japanese scripts, Katakana and Hiragana, but nowhere else. The &lt;code&gt;Script&lt;/code&gt; property places all characters that are used in multiple scripts in the &lt;code&gt;Common&lt;/code&gt; script, while the &lt;code&gt;Script_Extensions&lt;/code&gt; property places those that are used in only a few scripts into each of those scripts; while still using &lt;code&gt;Common&lt;/code&gt; for those used in many scripts. Thus both these match:</source>
          <target state="translated">这两个属性之间的差异涉及在多个脚本中使用的字符。例如，数字'0'到'9'在世界许多地方使用。这些被放置在名为 &lt;code&gt;Common&lt;/code&gt; 的脚本中。其他字符仅在少数脚本中使用。例如，日文片假名和平假名都使用了 &lt;code&gt;&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;&lt;/code&gt; ，但其他地方都没有。该 &lt;code&gt;Script&lt;/code&gt; 属性放在那些在多个脚本中使用的所有字符， &lt;code&gt;Common&lt;/code&gt; 的脚本，而 &lt;code&gt;Script_Extensions&lt;/code&gt; 财产地方那些只有几个剧本到每个这些脚本的使用;同时仍将 &lt;code&gt;Common&lt;/code&gt; 用于许多脚本中使用的那些。因此，这两个匹配：</target>
        </trans-unit>
        <trans-unit id="6e605910d48501bdad38af7496eb4f572c4cfa33" translate="yes" xml:space="preserve">
          <source>The difference between these two properties involves characters that are used in multiple scripts. For example the digits '0' through '9' are used in many parts of the world. These are placed in a script named &lt;code&gt;Common&lt;/code&gt;. Other characters are used in just a few scripts. For example, the &lt;code&gt;&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;&lt;/code&gt; is used in both Japanese scripts, Katakana and Hiragana, but nowhere else. The &lt;code&gt;Script&lt;/code&gt; property places all characters that are used in multiple scripts in the &lt;code&gt;Common&lt;/code&gt; script, while the &lt;code&gt;Script_Extensions&lt;/code&gt; property places those that are used in only a few scripts into each of those scripts; while still using &lt;code&gt;Common&lt;/code&gt; for those used in many scripts. Thus both these match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc2b3e05da478b77fc3b12b2fa311b0e5889311" translate="yes" xml:space="preserve">
          <source>The difference here is the addition of the temporary variable &lt;code&gt;$data&lt;/code&gt;. This is used to store a copy of the compressed data while it is being uncompressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f324cedd823e628f1ed8025386bfb26cab3778ab" translate="yes" xml:space="preserve">
          <source>The difference is clear to see and the dereferencing approach is slower. While it managed to execute an average of 628,930 times a second during our test, the direct approach managed to run an additional 204,403 times, unfortunately. Unfortunately, because there are many examples of code written using the multiple layer direct variable access, and it's usually horrible. It is, however, minusculy faster. The question remains whether the minute gain is actually worth the eyestrain, or the loss of maintainability.</source>
          <target state="translated">差别显而易见,去参考方法的速度更慢。虽然在我们的测试过程中,它平均每秒能执行628,930次,但不幸的是,直接方法却能额外运行204,403次。不幸的是,因为有很多使用多层直接变量访问写的代码的例子,而且它通常是可怕的。然而,它的速度是迷你的。问题是,这一分钟的收益是否真的值得眼花缭乱,或者可维护性的损失。</target>
        </trans-unit>
        <trans-unit id="c9d466e6cdc3e3b171ba671cc22acace7243054b" translate="yes" xml:space="preserve">
          <source>The difference is the sigil, that special character in front of the array name. The &lt;code&gt;$&lt;/code&gt; sigil means &quot;exactly one item&quot;, while the &lt;code&gt;@&lt;/code&gt; sigil means &quot;zero or more items&quot;. The &lt;code&gt;$&lt;/code&gt; gets you a single scalar, while the &lt;code&gt;@&lt;/code&gt; gets you a list.</source>
          <target state="translated">区别在于符号，即数组名称前面的特殊字符。在 &lt;code&gt;$&lt;/code&gt; 印记的意思是&amp;ldquo;只有一个项目&amp;rdquo;，而 &lt;code&gt;@&lt;/code&gt; 印记的意思是&amp;ldquo;零个或多个项目&amp;rdquo;。在 &lt;code&gt;$&lt;/code&gt; 让你一个标，而 &lt;code&gt;@&lt;/code&gt; 让你列表。</target>
        </trans-unit>
        <trans-unit id="82ff75d7fe49900a75f8b7a1628df2b78931946c" translate="yes" xml:space="preserve">
          <source>The difference to &lt;code&gt;incr_reset&lt;/code&gt; is that only text until the parse error occurred is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b0921f524dbbf7564616e5853365d0c767bfc6" translate="yes" xml:space="preserve">
          <source>The digest can be delivered in three formats:</source>
          <target state="translated">文摘可以以三种格式提供。</target>
        </trans-unit>
        <trans-unit id="0155d0c091234cee22dc790957626f27306487e0" translate="yes" xml:space="preserve">
          <source>The direction you must follow the great circle (also known as</source>
          <target state="translated">你必须遵循的方向是大圆(又称 &quot;大圆&quot;)。</target>
        </trans-unit>
        <trans-unit id="03d134305af0df1045ab396312ef86cfab55c5d9" translate="yes" xml:space="preserve">
          <source>The direction you would have to go from London to Tokyo (in radians, straight north being zero, straight east being pi/2).</source>
          <target state="translated">从伦敦到东京的方向(以弧度为单位,直北为0,直东为pi/2)。</target>
        </trans-unit>
        <trans-unit id="9159a72a045b505fc788bec97c5202fb7f87247c" translate="yes" xml:space="preserve">
          <source>The directory portion may or may not be returned with a trailing '/'.</source>
          <target state="translated">目录部分可能会也可能不会以'/'结尾返回。</target>
        </trans-unit>
        <trans-unit id="efd54b0e8774d4521e37e9c7dad7074640dfad53" translate="yes" xml:space="preserve">
          <source>The directory you are put into when you log in. On a Unix system, the name is often placed into &lt;code&gt;$ENV{HOME}&lt;/code&gt; or &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; by</source>
          <target state="translated">登录时放置的目录。在Unix系统上，名称通常通过以下方式放置在 &lt;code&gt;$ENV{HOME}&lt;/code&gt; 或 &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0f834768c044521ed2139a347066ecd1f6fd454d" translate="yes" xml:space="preserve">
          <source>The directory, if specified, must appear immediately following the &lt;b&gt;-x&lt;/b&gt; with no intervening whitespace.</source>
          <target state="translated">如果指定了该目录，则该目录必须立即出现在&lt;b&gt;-x之后&lt;/b&gt;且中间没有空格。</target>
        </trans-unit>
        <trans-unit id="d7f8724048da79577878989633dd2a49c69c9ec2" translate="yes" xml:space="preserve">
          <source>The display name describes the native Windows version, so even on a 32-bit Perl this function may return a &quot;Windows ... (64-bit)&quot; name when running on a 64-bit Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33156bb6057d33c4b599fbfc979b33f776601d44" translate="yes" xml:space="preserve">
          <source>The distinction between &lt;code&gt;OBJECT&lt;/code&gt; and &lt;code&gt;LDFROM&lt;/code&gt;: &lt;code&gt;OBJECT&lt;/code&gt; is the make target, so make will try to build it. However, &lt;code&gt;LDFROM&lt;/code&gt; is what will actually be linked together to make the shared object or static library (SO/SL), so if you override it, make sure it includes what you want to make the final SO/SL, almost certainly including the XS basename with &lt;code&gt;$(OBJ_EXT)&lt;/code&gt; appended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52decfdd93c450a71874ee33c51b4afa2f1bd5c0" translate="yes" xml:space="preserve">
          <source>The distribution is distributed under the terms of the GNU General Public License version 2 (&lt;a href=&quot;http://opensource.org/licenses/GPL-2.0&quot;&gt;http://opensource.org/licenses/GPL-2.0&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cba2181eae9ea18443bd663a1f8c3a87fbabe62" translate="yes" xml:space="preserve">
          <source>The distribution is distributed under the terms of the GNU Lesser General Public License version 2 (&lt;a href=&quot;http://opensource.org/licenses/LGPL-2.1&quot;&gt;http://opensource.org/licenses/LGPL-2.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4888c0e08e74f6e2698369bc2f948843f746c57a" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under a license that is &lt;b&gt;not&lt;/b&gt; approved by &lt;a href=&quot;http://www.opensource.org/&quot;&gt;www.opensource.org&lt;/a&gt; but that allows distribution without restrictions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18e66ed77e39494025272eb1fa0055f83f4e24c" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under a license that is not approved by &lt;a href=&quot;http://www.opensource.org/&quot;&gt;www.opensource.org&lt;/a&gt; but that allows distribution without restrictions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f50f8aa35b8ab9124cad20b747796d784792a1" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under some other Open Source Initiative-approved license listed at &lt;a href=&quot;http://www.opensource.org/licenses/&quot;&gt;http://www.opensource.org/licenses/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78bde88df9f9ec717c7aea6abe37d463f7f3091" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the Apache Software License version 1.1 (&lt;a href=&quot;http://opensource.org/licenses/Apache-1.1&quot;&gt;http://opensource.org/licenses/Apache-1.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7de749c864adb80ca7d1e8d280af821d8d4c9935" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the Artistic License version 1, as specified by the Artistic file in the standard perl distribution (&lt;a href=&quot;http://opensource.org/licenses/Artistic-Perl-1.0&quot;&gt;http://opensource.org/licenses/Artistic-Perl-1.0&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ac3a668622bd0a049080f2c7b27295e3ec4b97" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the BSD 3-Clause License (&lt;a href=&quot;http://opensource.org/licenses/BSD-3-Clause&quot;&gt;http://opensource.org/licenses/BSD-3-Clause&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b566ce554e210d4ce11e3e299eeba816ff34110" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the MIT License (&lt;a href=&quot;http://opensource.org/licenses/MIT&quot;&gt;http://opensource.org/licenses/MIT&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aac6612aedc9abedbc7808782068e6b14c9dad1" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the Mozilla Public License. (&lt;a href=&quot;http://opensource.org/licenses/MPL-1.0&quot;&gt;http://opensource.org/licenses/MPL-1.0&lt;/a&gt; or &lt;a href=&quot;http://opensource.org/licenses/MPL-1.1&quot;&gt;http://opensource.org/licenses/MPL-1.1&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ec48fe5b9db3aa7699bae9e6f37f57f64c6873" translate="yes" xml:space="preserve">
          <source>The distribution may be copied and redistributed under the same terms as perl itself (this is by far the most common licensing option for modules on CPAN). This is a dual license, in which the user may choose between either the GPL or the Artistic license.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6a3b8d2999345748a288e76e75c0daa029db33" translate="yes" xml:space="preserve">
          <source>The distribution may be copied and redistributed under the same terms as perl itself (this is by far the most common licensing option for modules on CPAN). This is a dual license, in which the user may choose between either the GPL version 1 or the Artistic version 1 license.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68561decd1a625d00c793764ccc0278b512e1101" translate="yes" xml:space="preserve">
          <source>The distribution may not be redistributed without special permission from the author and/or copyright holder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b84d36cdfd8993b5da988b0d1072e922c4f772" translate="yes" xml:space="preserve">
          <source>The distribution metadata for a CPAN dist</source>
          <target state="translated">CPAN dist的分发元数据。</target>
        </trans-unit>
        <trans-unit id="36683b868091d21c8930b291476202549c6dcddb" translate="yes" xml:space="preserve">
          <source>The distribution of a bundle should follow the same convention as other distributions.</source>
          <target state="translated">捆绑的分布应遵循与其他分布相同的惯例。</target>
        </trans-unit>
        <trans-unit id="51432e8130a916aea0132035b34ce241b04f9cf8" translate="yes" xml:space="preserve">
          <source>The distroprefs system of &lt;code&gt;CPAN.pm&lt;/code&gt; addresses this problem by allowing the user to specify extra informations and recipes in YAML files to either</source>
          <target state="translated">&lt;code&gt;CPAN.pm&lt;/code&gt; 的distroprefs系统通过允许用户在YAML文件中指定额外的信息和配方来解决此问题，</target>
        </trans-unit>
        <trans-unit id="593a274a7d2141476dcb8b11db34f2f4536141e3" translate="yes" xml:space="preserve">
          <source>The division (/) and the following functions</source>
          <target state="translated">除法(/)和以下功能</target>
        </trans-unit>
        <trans-unit id="863f717363dbe8d220d352a111c6c709f1a560be" translate="yes" xml:space="preserve">
          <source>The djgpp environment for DOS, &lt;a href=&quot;http://www.delorie.com/djgpp/&quot;&gt;http://www.delorie.com/djgpp/&lt;/a&gt; and &lt;a href=&quot;perldos&quot;&gt;perldos&lt;/a&gt;.</source>
          <target state="translated">DOS的djgpp环境，&lt;a href=&quot;http://www.delorie.com/djgpp/&quot;&gt;http://www.delorie.com/djgpp/&lt;/a&gt;和&lt;a href=&quot;perldos&quot;&gt;perldos&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02d01132aeec36ca260315fce03b39bb29168535" translate="yes" xml:space="preserve">
          <source>The do-or-die equivalents are set up simply by calling Fatal's &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; routine, passing it the names of the functions to be replaced. You may wrap both user-defined functions and overridable CORE operators (except &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, or any other built-in that cannot be expressed via prototypes) in this way.</source>
          <target state="translated">只需通过调用Fatal的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 例程，并为其传递要替换的函数的名称，即可设置do-die的等效项。您可以通过这种方式包装用户定义的函数和可重写的CORE运算符（ &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 或任何其他无法通过原型表示的内置函数除外）。</target>
        </trans-unit>
        <trans-unit id="d89559d6a4bade96c4b212e54a4534bbb62aa15a" translate="yes" xml:space="preserve">
          <source>The do-or-die equivalents are set up simply by calling Fatal's &lt;code&gt;import&lt;/code&gt; routine, passing it the names of the functions to be replaced. You may wrap both user-defined functions and overridable CORE operators (except &lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;, or any other built-in that cannot be expressed via prototypes) in this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15384d55904491a7259b275ff7854d9b17c0ddff" translate="yes" xml:space="preserve">
          <source>The documentation below is only for the methods of the CPAN::Meta object. For information on the meaning of individual fields, consult the spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467707c3656000f994482e7ea5cafe87685ee6c8" translate="yes" xml:space="preserve">
          <source>The documentation for the Perl API explains what some of the internal functions do, as well as the many macros used in the source.</source>
          <target state="translated">Perl API 的文档解释了一些内部函数的作用,以及源代码中使用的许多宏。</target>
        </trans-unit>
        <trans-unit id="f1c9061e68c820097f175c9e3bd485176b2a01c2" translate="yes" xml:space="preserve">
          <source>The documentation of &lt;a href=&quot;Locale::Maketext&quot;&gt;Locale::Maketext&lt;/a&gt; advises that the standard bracket method &lt;code&gt;numf&lt;/code&gt; is limited and that you must override that for better results. It even suggests the use of &lt;a href=&quot;Number::Format&quot;&gt;Number::Format&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae102196b6b483518d27e0d97d3595cd35f7b66" translate="yes" xml:space="preserve">
          <source>The dot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f38f6b4980cd9d2e94100bc5fdda9f827f655ac" translate="yes" xml:space="preserve">
          <source>The dot (or period), &lt;code&gt;.&lt;/code&gt; is probably the most used, and certainly the most well-known character class. By default, a dot matches any character, except for the newline. That default can be changed to add matching the newline by using the</source>
          <target state="translated">点（或点） &lt;code&gt;.&lt;/code&gt; 是最常用的字符类，当然也是最著名的字符类。默认情况下，点与任何字符匹配，除了换行符。可以更改默认值，以使用来添加匹配的换行符</target>
        </trans-unit>
        <trans-unit id="a8d050074e0d8db225e0ced36924986b2d59e591" translate="yes" xml:space="preserve">
          <source>The dynamic nature of the regular expression variables means that their value is limited to the block that they are in, as demonstrated by this bit of code:</source>
          <target state="translated">正则表达式变量的动态性质意味着它们的值被限制在它们所在的块中,正如这段代码所示。</target>
        </trans-unit>
        <trans-unit id="4214b1d60eaaef0d8bb7337abe8a20ad57121d02" translate="yes" xml:space="preserve">
          <source>The earliest development of &lt;code&gt;newgetopt.pl&lt;/code&gt; started in 1990, with Perl version 4. As a result, its development, and the development of Getopt::Long, has gone through several stages. Since backward compatibility has always been extremely important, the current version of Getopt::Long still supports a lot of constructs that nowadays are no longer necessary or otherwise unwanted. This section describes briefly some of these 'features'.</source>
          <target state="translated">&lt;code&gt;newgetopt.pl&lt;/code&gt; 的最早开发始于1990年，当时是Perl版本4。因此，它的开发以及Getopt :: Long的开发经历了多个阶段。由于向后兼容性一直非常重要，因此，当前版本的Getopt :: Long仍然支持许多如今不再需要或不需要的构造。本节简要介绍其中一些&amp;ldquo;功能&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a629fbdcc51d0664a749c16709dba8d145f34d93" translate="yes" xml:space="preserve">
          <source>The easier it is to reproduce your bug, the more likely it will be fixed -- if nobody can duplicate your problem, it probably won't be addressed.</source>
          <target state="translated">越容易重现你的bug,它就越有可能被修复--如果没有人能够复制你的问题,它可能不会被解决。</target>
        </trans-unit>
        <trans-unit id="a0f603eb4b75174f5f5f8c92980d04d40846be1f" translate="yes" xml:space="preserve">
          <source>The easier it is to understand a reproducible bug, the more likely it will be fixed. Any insight you can provide into the problem will help a great deal. In other words, try to analyze the problem (to the extent you can) and report your discoveries.</source>
          <target state="translated">越容易理解一个可重现的bug,它就越有可能被修复。你能提供的任何关于问题的见解都会有很大的帮助。换句话说,尝试分析问题(在你能做到的范围内)并报告你的发现。</target>
        </trans-unit>
        <trans-unit id="affd4579291392539b898984b2d64fdfbc46e13c" translate="yes" xml:space="preserve">
          <source>The easiest and most portable option available for creating your own source filter is to write it completely in Perl. To distinguish this from the previous two techniques, I'll call it a Perl source filter.</source>
          <target state="translated">要创建自己的源码过滤器,最简单、最便携的选择是完全用Perl编写。为了区别于前面两种技术,我将其称为Perl源码过滤器。</target>
        </trans-unit>
        <trans-unit id="74aa13205a264868ad41eb543a1a088589f0736a" translate="yes" xml:space="preserve">
          <source>The easiest conceptual solution is to count the lines in the file then start at the beginning and print the number of lines (minus the last N) to a new file.</source>
          <target state="translated">最简单的概念性解决方案是计算文件中的行数,然后从头开始,将行数(减去最后的N行)打印到一个新文件中。</target>
        </trans-unit>
        <trans-unit id="06308af6d2242e4fa49dd6cd28115c9993df529e" translate="yes" xml:space="preserve">
          <source>The easiest way is to have a module also named CPAN do it for you by using the &lt;code&gt;cpan&lt;/code&gt; command that comes with Perl. You can give it a list of modules to install:</source>
          <target state="translated">最简单的方法是使用Perl随附的 &lt;code&gt;cpan&lt;/code&gt; 命令让一个也名为CPAN的模块为您完成此操作。您可以为其提供要安装的模块列表：</target>
        </trans-unit>
        <trans-unit id="2cfa0d7d193c99cb54063076caae508cae649aa1" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to read a key in nonblocking mode with the &lt;a href=&quot;Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, passing it an argument of -1 to indicate not to block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ecd0af899536563eb76ce8a93b28def2b41789" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to read a key in nonblocking mode with the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, passing it an argument of -1 to indicate not to block:</source>
          <target state="translated">最简单的方法是使用CPAN 的&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt;模块以非阻塞模式读取密钥，并向其传递参数-1表示不阻塞：</target>
        </trans-unit>
        <trans-unit id="3b2853b05b0394d3d1c3bfe698cbfe924daa1822" translate="yes" xml:space="preserve">
          <source>The easiest way to examine the op tree is to stop Perl after it has finished parsing, and get it to dump out the tree. This is exactly what the compiler backends &lt;a href=&quot;B::Terse&quot;&gt;B::Terse&lt;/a&gt;, &lt;a href=&quot;B::Concise&quot;&gt;B::Concise&lt;/a&gt; and CPAN module &amp;lt;B::Debug do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab82d3c686ea0162144c8d6cfd2e56593a5e530" translate="yes" xml:space="preserve">
          <source>The easiest way to examine the op tree is to stop Perl after it has finished parsing, and get it to dump out the tree. This is exactly what the compiler backends &lt;a href=&quot;b/terse&quot;&gt;B::Terse&lt;/a&gt;, &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt; and &lt;a href=&quot;b/debug&quot;&gt;B::Debug&lt;/a&gt; do.</source>
          <target state="translated">检查op树的最简单方法是在完成解析后停止Perl，然后将其转储到树中。这正是编译器后端&lt;a href=&quot;b/terse&quot;&gt;B :: Terse&lt;/a&gt;，&lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt;和&lt;a href=&quot;b/debug&quot;&gt;B :: Debug&lt;/a&gt;所做的工作。</target>
        </trans-unit>
        <trans-unit id="e420b4167196d87c0672e2ec36244ffaaeacf17d" translate="yes" xml:space="preserve">
          <source>The easiest way to get a template set of macros to use is by specifying the &lt;code&gt;-g&lt;/code&gt; (&lt;code&gt;--global&lt;/code&gt; ) option with h2xs (see &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;).</source>
          <target state="translated">获取要使用的宏的模板集的最简单方法是通过在h2xs中指定 &lt;code&gt;-g&lt;/code&gt; （-- &lt;code&gt;--global&lt;/code&gt; ）选项（请参阅&lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4c6326467cfffc66387125a93100da358b0b5c86" translate="yes" xml:space="preserve">
          <source>The easiest way to get a template set of macros to use is by specifying the &lt;code&gt;-g&lt;/code&gt; (&lt;code&gt;--global&lt;/code&gt;) option with h2xs (see &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c9c21dcd497445970db52d8583cffea3bdb68e" translate="yes" xml:space="preserve">
          <source>The easiest way to specify an individual typable character is to enclose it in brackets:</source>
          <target state="translated">指定单个可输入字符的最简单方法是用括号将其括起来。</target>
        </trans-unit>
        <trans-unit id="d739701e48fac0ec01f64967528c5978352a4aef" translate="yes" xml:space="preserve">
          <source>The easiest way to tell if a subroutine was inlined is by using &lt;a href=&quot;B::Deparse&quot;&gt;B::Deparse&lt;/a&gt;. Consider this example of two subroutines returning &lt;code&gt;1&lt;/code&gt;, one with a &lt;code&gt;()&lt;/code&gt; prototype causing it to be inlined, and one without (with deparse output truncated for clarity):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b4571e42b1eb8646fcc517dc4040a5571233f2" translate="yes" xml:space="preserve">
          <source>The easiest way to tell if a subroutine was inlined is by using &lt;a href=&quot;b/deparse&quot;&gt;B::Deparse&lt;/a&gt;. Consider this example of two subroutines returning &lt;code&gt;1&lt;/code&gt; , one with a &lt;code&gt;()&lt;/code&gt; prototype causing it to be inlined, and one without (with deparse output truncated for clarity):</source>
          <target state="translated">判断是否已内联子例程的最简单方法是使用&lt;a href=&quot;b/deparse&quot;&gt;B :: Deparse&lt;/a&gt;。考虑下面的示例，其中有两个子例程返回 &lt;code&gt;1&lt;/code&gt; ，一个子例程带有 &lt;code&gt;()&lt;/code&gt; 原型使其内联，而另一个子例程没有返回（为清楚起见，删节输出被截断）：</target>
        </trans-unit>
        <trans-unit id="0f8acfaed2cccc718ab47b22e571180e63f71aac" translate="yes" xml:space="preserve">
          <source>The easiest way to test is to do something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0eee7295ee278e006e907a6f9a925e3a5df708" translate="yes" xml:space="preserve">
          <source>The easist way to deal with this issue is to use the pre-defined &quot;utf8&quot; &lt;b&gt;DBM_Filter&lt;/b&gt; (see &lt;a href=&quot;dbm_filter&quot;&gt;DBM_Filter&lt;/a&gt;) that was designed to deal with this situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1861cd9be51843a146c51b85f741a8d483f14173" translate="yes" xml:space="preserve">
          <source>The easy answer is &quot;Don't do that!&quot;</source>
          <target state="translated">简单的答案是 &quot;不要这样做!&quot;</target>
        </trans-unit>
        <trans-unit id="8aef9d5f47b23df02c1f4b866ddffffba9a2ae25" translate="yes" xml:space="preserve">
          <source>The effect of &lt;code&gt;:std&lt;/code&gt; is not lexical as it modifies the layer stack of the global handles. If you wish to apply only this global effect and not the effect on handles that are opened in that scope, you can isolate the call to this pragma in its own lexical scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4605050fae7c9f6ca47b8c647d8260a448789c" translate="yes" xml:space="preserve">
          <source>The effect of multiple &lt;code&gt;-I&lt;/code&gt; options is to &lt;code&gt;unshift&lt;/code&gt; them onto &lt;code&gt;@INC&lt;/code&gt; from right to left. So for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0597cca28cb7230a0e356c17782e46be9384f5c8" translate="yes" xml:space="preserve">
          <source>The effect of using &quot;failure_auto_handler&quot; is like an AUTO lexicon, except that it 1) compiles $key even if it starts with &quot;_&quot;, and 2) you have a record in the new hashref $lh-&amp;gt;{'failure_lex'} of all the keys that have failed for this object. This should avoid your program dying -- as long as your keys aren't actually invalid as bracket code, and as long as they don't try calling methods that don't exist.</source>
          <target state="translated">使用&amp;ldquo; failure_auto_handler&amp;rdquo;的效果就像一个AUTO词典，除了它1）即使以&amp;ldquo; _&amp;rdquo;开头也编译$ key，并且2）您在新的hashref $ lh-&amp;gt; {'failure_lex'}中有一条记录。该对象失败的所有键中的一个。这应该避免您的程序死亡-只要您的键实际上不作为方括号代码无效，并且只要它们不尝试调用不存在的方法即可。</target>
        </trans-unit>
        <trans-unit id="e111bef16ba68c39a0b6040a000b635141c8f1f2" translate="yes" xml:space="preserve">
          <source>The effective gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getegid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">这个过程的有效指导。如果您使用的机器同时支持多个组的成员资格，请提供一个空格，分隔您所在的组的列表。第一个数字是 &lt;code&gt;getegid()&lt;/code&gt; 返回的数字，随后的是 &lt;code&gt;getgroups()&lt;/code&gt; 返回的数字，其中一个可能是与第一个数字相同。</target>
        </trans-unit>
        <trans-unit id="c57c7b93a855188d4ab0c627a896d86afd3718eb" translate="yes" xml:space="preserve">
          <source>The effective gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getegid()&lt;/code&gt;, and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt;, one of which may be the same as the first number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391c814eb86428160d8ecfb1e5d99a0a23856f18" translate="yes" xml:space="preserve">
          <source>The effective uid of this process. For example:</source>
          <target state="translated">这个过程的有效uid。例如:</target>
        </trans-unit>
        <trans-unit id="78e522cbb08752f888e4a4c422be723520118862" translate="yes" xml:space="preserve">
          <source>The element &lt;code&gt;$ENV{DEFAULT}&lt;/code&gt; is special: when read, it returns Perl's current default device and directory, and when set, it resets them, regardless of the definition of</source>
          <target state="translated">元素 &lt;code&gt;$ENV{DEFAULT}&lt;/code&gt; 是特殊的：读取时，它将返回Perl的当前默认设备和目录，并且在设置时，它将重置它们，而不管其定义如何。</target>
        </trans-unit>
        <trans-unit id="1927e85810982ff4bedcbd8fe6ac46c4f4acfd36" translate="yes" xml:space="preserve">
          <source>The element is a hash, initialized by default to &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">该元素是一个哈希，默认情况下初始化为 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff2bffd6b7ca0e9e867ed8229203222ba2cd6dd2" translate="yes" xml:space="preserve">
          <source>The element is a hash, initialized by default to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010155a37e502b613f4bf666146b070b50ac9cf2" translate="yes" xml:space="preserve">
          <source>The element is a scalar, and by default is initialized to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (but see &lt;a href=&quot;#Initializing-with-new&quot;&gt;Initializing with new&lt;/a&gt;).</source>
          <target state="translated">元素是一个标量，默认情况下被初始化为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （但请参见&lt;a href=&quot;#Initializing-with-new&quot;&gt;使用new初始化&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f75fd8ea331a93e38c3ea51d7c4505b3a3d036f7" translate="yes" xml:space="preserve">
          <source>The element is a scalar, and by default is initialized to &lt;code&gt;undef&lt;/code&gt; (but see &lt;a href=&quot;#Initializing-with-new&quot;&gt;&quot;Initializing with new&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7fe592a2def98474e3260c74013058ff355fc6" translate="yes" xml:space="preserve">
          <source>The element is an array, initialized by default to &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">元素是一个数组，默认情况下初始化为 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52aeddd404b7b928ef7ca86f1f29047b71eeb8ca" translate="yes" xml:space="preserve">
          <source>The element is an array, initialized by default to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942bdb865668cc5d25526303c780ec9824d73845" translate="yes" xml:space="preserve">
          <source>The element's value must be a reference blessed to the named class or to one of its subclasses. The element is not initialized by default.</source>
          <target state="translated">元素的值必须是对指定类或其子类的引用。该元素默认不初始化。</target>
        </trans-unit>
        <trans-unit id="96e4b34c1d85fc2315f1a2e433a4a09c9e1219d5" translate="yes" xml:space="preserve">
          <source>The elements must be identical</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb20ee6aa799cc8c00cade7ca9b921cb0624824" translate="yes" xml:space="preserve">
          <source>The elements we're getting from the array start with a &lt;code&gt;$&lt;/code&gt; because we're getting just a single value out of the array; you ask for a scalar, you get a scalar.</source>
          <target state="translated">我们从数组中获取的元素以 &lt;code&gt;$&lt;/code&gt; 开头，因为我们从数组中获取的只是一个值；你要求一个标量，你得到一个标量。</target>
        </trans-unit>
        <trans-unit id="c2d2a5272ddb492896f4b1aa2fdc89f7d8b57cf1" translate="yes" xml:space="preserve">
          <source>The elliptical statement cannot stand in for an expression that is part of a larger statement, since the &lt;code&gt;...&lt;/code&gt; is also the three-dot version of the flip-flop operator (see &lt;a href=&quot;perlop#Range-Operators&quot;&gt;Range Operators in perlop&lt;/a&gt;).</source>
          <target state="translated">椭圆语句不能代表较大语句的一部分，因为 &lt;code&gt;...&lt;/code&gt; 也是触发器运算&lt;a href=&quot;perlop#Range-Operators&quot;&gt;符的三点形式&lt;/a&gt;（请参见perlop中的Range运算符）。</target>
        </trans-unit>
        <trans-unit id="81b37f465ff28273358e52fdc4fa0d8ce3005267" translate="yes" xml:space="preserve">
          <source>The elliptical statement cannot stand in for an expression that is part of a larger statement. These examples of attempts to use an ellipsis are syntax errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545891d79255fc3bc69760f930c3f25bc8ae8965" translate="yes" xml:space="preserve">
          <source>The email you got when you received your CPAN ID will tell you how to log in to PAUSE, the Perl Authors Upload SErver. From the menus there, you can upload your module to CPAN.</source>
          <target state="translated">当您收到 CPAN ID 时,您收到的邮件会告诉您如何登录 PAUSE,即 Perl Authors Upload SErver。从那里的菜单中,你可以将你的模块上传到 CPAN。</target>
        </trans-unit>
        <trans-unit id="327ff1bdde855523cde51b50cbe96fda9133ba11" translate="yes" xml:space="preserve">
          <source>The empty pattern &lt;code&gt;//&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4129d1babbccbe45b1d8ec086eee7286a139eb46" translate="yes" xml:space="preserve">
          <source>The encoding being specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64546adcd99f15ed4491ee50ced298a5f03d14c6" translate="yes" xml:space="preserve">
          <source>The encoding event is generated when a test file wants to specify the encoding to be used when formatting its output. This event is intended to be produced by formatter classes and used for interpreting test names, message contents, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588a9b522600848c7a034e730acfdc94a0b61885" translate="yes" xml:space="preserve">
          <source>The encoding is assumed to be an Encode object, on entry the PV of the sv is assumed to be octets in that encoding, and the sv will be converted into Unicode (and UTF-8).</source>
          <target state="translated">编码被假定为Encode对象,输入时sv的PV被假定为该编码的八位数,sv将被转换为Unicode(和UTF-8)。</target>
        </trans-unit>
        <trans-unit id="2aac7e4350e18d454240d654ed5501855f5c3e7e" translate="yes" xml:space="preserve">
          <source>The encoding is assumed to be an Encode object, the PV of the ssv is assumed to be octets in that encoding and decoding the input starts from the position which (PV + *offset) pointed to. The dsv will be concatenated the decoded UTF-8 string from ssv. Decoding will terminate when the string tstr appears in decoding output or the input ends on the PV of the ssv. The value which the offset points will be modified to the last input position on the ssv.</source>
          <target state="translated">编码被假定为Encode对象,ssv的PV被假定为该编码的八位数,并从(PV+*offset)指向的位置开始解码输入。dsv将从ssv解码后的UTF-8字符串连接起来。当解码输出中出现字符串tstr或输入在ssv的PV上结束时,解码将终止。偏移量所指向的值将被修改为ssv的最后输入位置。</target>
        </trans-unit>
        <trans-unit id="e2d9b11db298559d7d705aec3e36d98ebb2389cc" translate="yes" xml:space="preserve">
          <source>The encoding name determined to be suitable for file system interfaces involving file names. &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; know this encoding as &quot;locale_fs&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050d2bf9033fce6c43078983175c16f9530f4831" translate="yes" xml:space="preserve">
          <source>The encoding name determined to be suitable for the current locale. &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; know this encoding as &quot;locale&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3062423073ff3110a760ac5983fd2a737512781" translate="yes" xml:space="preserve">
          <source>The encoding pragma is not supported on EBCDIC platforms.</source>
          <target state="translated">EBCDIC平台不支持编码原则。</target>
        </trans-unit>
        <trans-unit id="04abf26a5ca58977d603141fc0ef79876490369d" translate="yes" xml:space="preserve">
          <source>The encoding requested is not supported by the Encode module.</source>
          <target state="translated">Encode模块不支持要求的编码。</target>
        </trans-unit>
        <trans-unit id="dc406e81e6f88430afa8892d13871c0d72a82fe4" translate="yes" xml:space="preserve">
          <source>The encoding that corresponds to ANSI varies between different editions of Windows. For many western editions of Windows ANSI corresponds to CP-1252 which is a character set similar to ISO-8859-1. Conceptually the ANSI character set is a similar concept to the POSIX locale CODESET so this module figures out what the ANSI code page is and make this available as $ENCODING_LOCALE and the &quot;locale&quot; Encoding alias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b0be99c7e0fde92c59a2dde4b75bd2c5e6a66a" translate="yes" xml:space="preserve">
          <source>The encodings of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; are individually settable by parameters to the pragma:</source>
          <target state="translated">&lt;code&gt;STDIN&lt;/code&gt; 和 &lt;code&gt;STDOUT&lt;/code&gt; 的编码可分别通过编译指示参数设置：</target>
        </trans-unit>
        <trans-unit id="6d62118e6065a9d454aaecd74844f2def3aa8534" translate="yes" xml:space="preserve">
          <source>The encodings to be used for reading and writing output to the a console. &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; know these encodings as &quot;console_in&quot; and &quot;console_out&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d58ea5991c657606e31a1ebddfdcbdfe42b5a94" translate="yes" xml:space="preserve">
          <source>The end result of all this is a list of pairs of filenames. By default that is what is returned by &lt;code&gt;globmap&lt;/code&gt; . In this example the data structure returned will look like this</source>
          <target state="translated">所有这些的最终结果是文件名对列表。默认情况下，就是 &lt;code&gt;globmap&lt;/code&gt; 返回的内容。在此示例中，返回的数据结构将如下所示</target>
        </trans-unit>
        <trans-unit id="d6253ff05c4cc919ddf707ca73edb1a406fe9c35" translate="yes" xml:space="preserve">
          <source>The end result of all this is a list of pairs of filenames. By default that is what is returned by &lt;code&gt;globmap&lt;/code&gt;. In this example the data structure returned will look like this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fda9b67eec164f9ff303e259fb27be29ca04c85" translate="yes" xml:space="preserve">
          <source>The engine implementing &lt;code&gt;pack()&lt;/code&gt; Perl function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66180c8b26ee487f27a0dc49b26d2d5244b75b6e" translate="yes" xml:space="preserve">
          <source>The engine implementing &lt;code&gt;pack()&lt;/code&gt; Perl function. Note: parameters &lt;code&gt;next_in_list&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt; are not used. This call should not be used; use &lt;code&gt;packlist&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463670dd77f9d4b250cfbf1933d859da20649fdf" translate="yes" xml:space="preserve">
          <source>The engine implementing &lt;code&gt;unpack()&lt;/code&gt; Perl function. Note: parameters &lt;code&gt;strbeg&lt;/code&gt;, &lt;code&gt;new_s&lt;/code&gt; and &lt;code&gt;ocnt&lt;/code&gt; are not used. This call should not be used, use &lt;code&gt;unpackstring&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733a0f46f2e4433da326d8b3d8649ddcec9e6f67" translate="yes" xml:space="preserve">
          <source>The engine implementing pack() Perl function.</source>
          <target state="translated">实现pack()Perl函数的引擎。</target>
        </trans-unit>
        <trans-unit id="3347858c5b43f539e0e1c803ce10b0c1e284b3a5" translate="yes" xml:space="preserve">
          <source>The engine implementing pack() Perl function. Note: parameters next_in_list and flags are not used. This call should not be used; use packlist instead.</source>
          <target state="translated">实现pack()Perl函数的引擎。注意:没有使用参数 next_in_list 和 flags。这个调用不应该被使用,而应该使用packlist。</target>
        </trans-unit>
        <trans-unit id="1108f56aaa943f349a8b769e2a9d1fa1d3614cf4" translate="yes" xml:space="preserve">
          <source>The engine implementing the &lt;code&gt;unpack()&lt;/code&gt; Perl function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5023a760442586ad60fa18e526984ee22ee1b465" translate="yes" xml:space="preserve">
          <source>The engine implementing the unpack() Perl function.</source>
          <target state="translated">实现unpack()Perl函数的引擎。</target>
        </trans-unit>
        <trans-unit id="23836ad0aab663b81186836eab5aaaa304905073" translate="yes" xml:space="preserve">
          <source>The engine implementing unpack() Perl function. Note: parameters strbeg, new_s and ocnt are not used. This call should not be used, use unpackstring instead.</source>
          <target state="translated">实现unpack()Perl函数的引擎。注意:没有使用参数 strbeg、new_s 和 ocnt。这个调用不应该被使用,而应该使用unpackstring。</target>
        </trans-unit>
        <trans-unit id="d9382e3775d5db72bf3f9d8d46eb30460f658e51" translate="yes" xml:space="preserve">
          <source>The engine's private copy of the flags the pattern was compiled with. Usually this is the same as &lt;code&gt;extflags&lt;/code&gt; unless the engine chose to modify one of them.</source>
          <target state="translated">编译模式的标志的引擎的专用副本。通常，这与 &lt;code&gt;extflags&lt;/code&gt; 相同，除非引擎选择修改其中之一。</target>
        </trans-unit>
        <trans-unit id="9ce2a132adf5c2ffffe82f2f2320a1ff022e1a1c" translate="yes" xml:space="preserve">
          <source>The entire file system is compressed such as via &quot;DoubleSpace&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e628a3e380b1bb720e0473c9d50225fb2d2a7bf" translate="yes" xml:space="preserve">
          <source>The entire getaddrinfo() subsystem can be exported using the tag &lt;code&gt;:addrinfo&lt;/code&gt; ; this exports the getaddrinfo() and getnameinfo() functions, and all the &lt;code&gt;AI_*&lt;/code&gt; , &lt;code&gt;NI_*&lt;/code&gt; , &lt;code&gt;NIx_*&lt;/code&gt; and &lt;code&gt;EAI_*&lt;/code&gt; constants.</source>
          <target state="translated">可以使用标签 &lt;code&gt;:addrinfo&lt;/code&gt; 导出整个getaddrinfo（）子系统；这将导出getaddrinfo（）和getnameinfo（）函数，以及所有 &lt;code&gt;AI_*&lt;/code&gt; ， &lt;code&gt;NI_*&lt;/code&gt; ， &lt;code&gt;NIx_*&lt;/code&gt; 和 &lt;code&gt;EAI_*&lt;/code&gt; 常量。</target>
        </trans-unit>
        <trans-unit id="f9deffc2b03edaef07355a1dc99c65f075b4e32e" translate="yes" xml:space="preserve">
          <source>The entire getaddrinfo() subsystem can be exported using the tag &lt;code&gt;:addrinfo&lt;/code&gt;; this exports the getaddrinfo() and getnameinfo() functions, and all the &lt;code&gt;AI_*&lt;/code&gt;, &lt;code&gt;NI_*&lt;/code&gt;, &lt;code&gt;NIx_*&lt;/code&gt; and &lt;code&gt;EAI_*&lt;/code&gt; constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425561102978b28bf5fcfefe3513eb2739c2c06d" translate="yes" xml:space="preserve">
          <source>The entire hardware and software context in which a program runs. A program written in a platform-dependent language might break if you change any of the following: machine, operating system, libraries, compiler, or system configuration. The</source>
          <target state="translated">程序运行的整个硬件和软件环境。如果你改变了以下任何一项:机器、操作系统、库、编译器或系统配置,一个用平台依赖性语言编写的程序可能会崩溃。在这里,我想说的是,如果你改变了以下任何一个因素,那么用平台依赖型语言编写的程序可能会崩溃:机器、操作系统、库、编译器或系统配置。</target>
        </trans-unit>
        <trans-unit id="062ee9dd6945c627c0db8805ff34b8bebe56650f" translate="yes" xml:space="preserve">
          <source>The entire upgrading/downgrading is still experimental and might not work as you expect or may even have bugs. You might get errors like this:</source>
          <target state="translated">整个升级/降级仍是实验性的,可能无法按照你的预期工作,甚至可能有bug。你可能会得到这样的错误。</target>
        </trans-unit>
        <trans-unit id="5e462b82c7819411d2795ec13fd404d6485cf8ac" translate="yes" xml:space="preserve">
          <source>The environment is not automatically made available as separate scalar variables.</source>
          <target state="translated">环境不会自动作为单独的标量变量提供。</target>
        </trans-unit>
        <trans-unit id="4a714b26cc76c6e720a2c1944b7c3273669f5c69" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PERL_RL&lt;/code&gt; governs which ReadLine clone is loaded. If the value is false, a dummy interface is used. If the value is true, it should be tail of the name of the package to use, such as &lt;code&gt;Perl&lt;/code&gt; or &lt;code&gt;Gnu&lt;/code&gt; .</source>
          <target state="translated">环境变量 &lt;code&gt;PERL_RL&lt;/code&gt; 控制着加载哪个ReadLine克隆。如果该值为false，则使用虚拟接口。如果值为true，则应为要使用的软件包名称的 &lt;code&gt;Gnu&lt;/code&gt; ，例如 &lt;code&gt;Perl&lt;/code&gt; 或Gnu。</target>
        </trans-unit>
        <trans-unit id="390b6e9b1745d2d828a2345d3a86cf8b0b336f56" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PERL_RL&lt;/code&gt; governs which ReadLine clone is loaded. If the value is false, a dummy interface is used. If the value is true, it should be tail of the name of the package to use, such as &lt;code&gt;Perl&lt;/code&gt; or &lt;code&gt;Gnu&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee4db4f603bb2d952278fab3f0573c9f206b756" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PERL_SIGNALS&lt;/code&gt; is set to &lt;code&gt;unsafe&lt;/code&gt; (see &lt;a href=&quot;perlrun#PERL_SIGNALS&quot;&gt;&quot;PERL_SIGNALS&quot; in perlrun&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c8987c252d8945d5eef3157bdde1da3d4677a3" translate="yes" xml:space="preserve">
          <source>The error function [C99].</source>
          <target state="translated">误差函数[C99]。</target>
        </trans-unit>
        <trans-unit id="c03bfb5951202558a79d3146a129bcd7599c5997" translate="yes" xml:space="preserve">
          <source>The error level, should be 'WARNING' or 'ERROR'.</source>
          <target state="translated">错误级别,应该是 &quot;WARNING &quot;或 &quot;ERROR&quot;。</target>
        </trans-unit>
        <trans-unit id="489643f4ea640ba730461cfbd32bed09509bae25" translate="yes" xml:space="preserve">
          <source>The error message or object will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak_sv&lt;/code&gt; function never returns normally.</source>
          <target state="translated">错误消息或对象将用作异常，默认情况下将控制权返回到最近的封闭 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，但可能会被 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 处理程序进行修改。无论如何， &lt;code&gt;croak_sv&lt;/code&gt; 函数永远不会正常返回。</target>
        </trans-unit>
        <trans-unit id="4301dd87f0c694dc26ff0db9df44403205bacc19" translate="yes" xml:space="preserve">
          <source>The error message or object will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;eval&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak_sv&lt;/code&gt; function never returns normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="664a7836db566d6a3f4c07aec582c78faf8e8984" translate="yes" xml:space="preserve">
          <source>The error message or object will by default be written to standard error, but this is subject to modification by a &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handler.</source>
          <target state="translated">默认情况下，错误消息或对象将被写入标准错误，但这可以通过 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 处理程序进行修改。</target>
        </trans-unit>
        <trans-unit id="b67bc4e2f3fe19fc43d4ef72e9869cbd0c9674e2" translate="yes" xml:space="preserve">
          <source>The error message will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak&lt;/code&gt; function never returns normally.</source>
          <target state="translated">错误消息将用作异常，默认情况下会将控制权返回到最近的封闭 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，但可能会被 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 处理程序进行修改。无论如何， &lt;code&gt;croak&lt;/code&gt; 函数永远不会正常返回。</target>
        </trans-unit>
        <trans-unit id="b00b7771ac407f2dd89d3f22f11d4228e791df56" translate="yes" xml:space="preserve">
          <source>The error message will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;eval&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak&lt;/code&gt; function never returns normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900d77a6d61d64e8af52decba69cafd8be937ac1" translate="yes" xml:space="preserve">
          <source>The error number returned by a &lt;b&gt;syscall&lt;/b&gt; when it fails. Perl refers to the error by the name &lt;code&gt;$!&lt;/code&gt; (or &lt;code&gt;$OS_ERROR&lt;/code&gt; if you use the English module).</source>
          <target state="translated">失败时由&lt;b&gt;系统调用&lt;/b&gt;返回的错误号。Perl用 &lt;code&gt;$!&lt;/code&gt; 来指代错误。（如果使用英文模块， &lt;code&gt;$OS_ERROR&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4c482150704e0bf7cda4048aa90adb166f9af2aa" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EAI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. If no error occurred it will be zero numerically and an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b014cdbfece5798eb6937c7e465a37ae5041c3" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EAI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. The host and service names will be plain strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953076d4b6c381c0ffffe4399cd4fbc39f8ceb23" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. If no error occurred it will be zero numerically and an empty string.</source>
          <target state="translated">错误值将为对偶变量；可与 &lt;code&gt;EI_*&lt;/code&gt; 错误常量相比较，或可打印为人类可读的错误消息字符串。如果未发生错误，则数字将为零，并且为空字符串。</target>
        </trans-unit>
        <trans-unit id="4f48137cede1f63ecf865be7641415458ec370ab" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. The host and service names will be plain strings.</source>
          <target state="translated">错误值将为对偶变量；可与 &lt;code&gt;EI_*&lt;/code&gt; 错误常量相比较，或可打印为人类可读的错误消息字符串。主机名和服务名将为纯字符串。</target>
        </trans-unit>
        <trans-unit id="69f6f9a5df3062e908bd0165d9c2b9fe0563d15c" translate="yes" xml:space="preserve">
          <source>The errors facet is a list instead of a single item, any number of errors can be listed. In this facet &lt;code&gt;details&lt;/code&gt; describes the error, or may contain the raw error message itself (such as an exception). In perl exception may be blessed objects, as such the raw data for this facet may contain nested items which are blessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce05d758ea509461baa38b741595abae13996ba5" translate="yes" xml:space="preserve">
          <source>The escape is the beginning or final end point of a range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1c1519bb36749c3cad434bbe27ce9cca770380" translate="yes" xml:space="preserve">
          <source>The evaluation modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; wraps an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{...}&lt;/a&gt;&lt;/code&gt; around the replacement string and the evaluated result is substituted for the matched substring. Some examples:</source>
          <target state="translated">评估修饰符 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{...}&lt;/a&gt;&lt;/code&gt; 包裹在替换字符串周围，并将评估结果替换为匹配的子字符串。一些例子：</target>
        </trans-unit>
        <trans-unit id="acb75763cbe80034d5f373af05d3a0392a02769b" translate="yes" xml:space="preserve">
          <source>The evaluation modifier &lt;code&gt;s///e&lt;/code&gt; wraps an &lt;code&gt;eval{...}&lt;/code&gt; around the replacement string and the evaluated result is substituted for the matched substring. Some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfba3806303ac6dda3f30dd80fde49f7e2183210" translate="yes" xml:space="preserve">
          <source>The event from &lt;code&gt;ok(1, &quot;pass&quot;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863be168c93a9b4e951447892af8574c10035f63" translate="yes" xml:space="preserve">
          <source>The event of a plan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c657becf62f17dba34f2c0a7892b03eec9664a" translate="yes" xml:space="preserve">
          <source>The exact implementation of this macro varies by architecture and version of perl, and the return value may change per invocation, so the value is only valid for the duration of a single perl process.</source>
          <target state="translated">这个宏的具体实现因perl的架构和版本不同而不同,而且每次调用的返回值可能会改变,所以这个值只对单个perl进程的持续时间有效。</target>
        </trans-unit>
        <trans-unit id="77f569ab2ca56d55a753f65526e499d75cae3e5d" translate="yes" xml:space="preserve">
          <source>The exact line number may vary, but if the warning (W) comes from a line line this</source>
          <target state="translated">确切的行号可能会有所不同,但如果警告(W)来自于一行行的行号,这个</target>
        </trans-unit>
        <trans-unit id="995bdcd8d207fa374f9f43b6e279df6bd565026b" translate="yes" xml:space="preserve">
          <source>The exact line numbers may vary between Perl releases. The warnings are benign and can be ignored: in later C compiler releases the warnings should be gone.</source>
          <target state="translated">确切的行数在不同的Perl版本中可能会有所不同。这些警告是良性的,可以忽略:在以后的 C 编译版本中,这些警告应该会消失。</target>
        </trans-unit>
        <trans-unit id="44fc79e864b1257675cf101f1f7fd3a57bf639a9" translate="yes" xml:space="preserve">
          <source>The exact manner in which the address is returned in $symref is not currently defined. The only initial requirement is that $symref can be passed to, and understood by, dl_install_xsub().</source>
          <target state="translated">$symref中返回地址的具体方式目前还没有定义。唯一的初始要求是$symref可以传递给dl_install_xsub()并被其理解。</target>
        </trans-unit>
        <trans-unit id="e70c2ef4d5d588ebbe05350bafa35fc8f80a6a1c" translate="yes" xml:space="preserve">
          <source>The exact meaning of the $gcos field varies but it usually contains the real name of the user (as opposed to the login name) and other information pertaining to the user. Beware, however, that in many system users are able to change this information and therefore it cannot be trusted and therefore the $gcos is tainted (see &lt;a href=&quot;../perlsec&quot;&gt;perlsec&lt;/a&gt;). The $passwd and $shell, user's encrypted password and login shell, are also tainted, for the same reason.</source>
          <target state="translated">$ gcos字段的确切含义有所不同，但是它通常包含用户的真实姓名（与登录名相对）以及与该用户有关的其他信息。但是请注意，在许多系统中，用户都可以更改此信息，因此该信息不能被信任，因此$ gcos受到污染（请参阅&lt;a href=&quot;../perlsec&quot;&gt;perlsec&lt;/a&gt;）。由于相同的原因，用户的加密密码和登录外壳$ passwd和$ shell也被污染。</target>
        </trans-unit>
        <trans-unit id="d7d6887be4411b65036ddda7abbe1d73b16c3d9f" translate="yes" xml:space="preserve">
          <source>The exact meaning of the $gcos field varies but it usually contains the real name of the user (as opposed to the login name) and other information pertaining to the user. Beware, however, that in many system users are able to change this information and therefore it cannot be trusted and therefore the $gcos is tainted (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). The $passwd and $shell, user's encrypted password and login shell, are also tainted, for the same reason.</source>
          <target state="translated">$ gcos字段的确切含义有所不同，但是它通常包含用户的真实姓名（与登录名相对）以及与该用户有关的其他信息。但是请注意，在许多系统中，用户都可以更改此信息，因此该信息不能被信任，因此$ gcos受到污染（请参阅&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;）。由于相同的原因，用户的加密密码和登录外壳$ passwd和$ shell也被污染。</target>
        </trans-unit>
        <trans-unit id="6462c6eed55545498a4b1274ffec108a59806854" translate="yes" xml:space="preserve">
          <source>The exact rules for how often (??{}) and (?{}) are executed in a pattern are unspecified. In the case of a successful match you can assume that they DWIM and will be executed in left to right order the appropriate number of times in the accepting path of the pattern as would any other meta-pattern. How non-accepting pathways and match failures affect the number of times a pattern is executed is specifically unspecified and may vary depending on what optimizations can be applied to the pattern and is likely to change from version to version.</source>
          <target state="translated">模式中(??{})和(?{})被执行的频率的确切规则是没有规定的。在匹配成功的情况下,你可以假设它们DWIM,并将在模式的接受路径中按照从左到右的顺序执行适当的次数,就像任何其他元模式一样。非接受路径和匹配失败如何影响模式的执行次数是具体未说明的,可能会根据模式可以应用的优化而变化,并且很可能在不同版本之间发生变化。</target>
        </trans-unit>
        <trans-unit id="fdf1655ab3b8310f5b318568059958f807b33f0d" translate="yes" xml:space="preserve">
          <source>The exact rules for how often &lt;code&gt;(??{})&lt;/code&gt; and &lt;code&gt;(?{})&lt;/code&gt; are executed in a pattern are unspecified. In the case of a successful match you can assume that they DWIM and will be executed in left to right order the appropriate number of times in the accepting path of the pattern as would any other meta-pattern. How non-accepting pathways and match failures affect the number of times a pattern is executed is specifically unspecified and may vary depending on what optimizations can be applied to the pattern and is likely to change from version to version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7beaad311b9cd2e0a10bf6f8d5a018e83ebb91c" translate="yes" xml:space="preserve">
          <source>The exact same effect could, incidentally, be achieved with a single &quot;=for&quot; paragraph:</source>
          <target state="translated">顺便说一句,用一个&quot;=for &quot;段也可以达到完全相同的效果。</target>
        </trans-unit>
        <trans-unit id="fb72ca6692327d6fee94ee24d9e91cba6dc1e016" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma, and attributes are handled using the &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;a href=&quot;Attribute::Handlers&quot;&gt;Attribute::Handlers&lt;/a&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my%28%29&quot;&gt;&quot;Private Variables via my()&quot; in perlsub&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61acc8b78f6506711798cda20b87d0c0557e6d78" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;../fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE和ATTRS的确切语义和接口仍在不断发展。 TYPE当前绑定到 &lt;code&gt;fields&lt;/code&gt; pragma 的使用，并且使用 &lt;code&gt;attributes&lt;/code&gt; pragma 来处理属性，或者从Perl 5.8.0开始，也可以通过 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 模块来处理属性。有关详细信息以及&lt;a href=&quot;../fields&quot;&gt;字段&lt;/a&gt;，&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;和&lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute :: Handlers的&lt;/a&gt;信息，请参见&lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;perlsub中的my（）的私有变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90e321854a7d357a33050984753578010a7cc972" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE和ATTRS的确切语义和接口仍在不断发展。 TYPE当前绑定到 &lt;code&gt;fields&lt;/code&gt; pragma 的使用，并且使用 &lt;code&gt;attributes&lt;/code&gt; pragma 来处理属性，或者从Perl 5.8.0开始，也可以通过 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 模块来处理属性。有关详细信息以及&lt;a href=&quot;fields&quot;&gt;字段&lt;/a&gt;，&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;和&lt;a href=&quot;attribute/handlers&quot;&gt;Attribute :: Handlers的&lt;/a&gt;信息，请参见&lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;perlsub中的my（）的私有变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4b162d38593f0c61d02eda524507bf4fd01fab9" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;a href=&quot;constant&quot;&gt;&lt;code&gt;use constant&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#__PACKAGE__&quot;&gt;&lt;code&gt;__PACKAGE__&lt;/code&gt;&lt;/a&gt;. It is currently bound to the use of the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma, and attributes are handled using the &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; pragma, or starting from Perl 5.8.0 also via the &lt;a href=&quot;Attribute::Handlers&quot;&gt;Attribute::Handlers&lt;/a&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my%28%29&quot;&gt;&quot;Private Variables via my()&quot; in perlsub&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c046e7769f3ecfcaed8dd98a806a8be83eb888" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , or &lt;code&gt;__PACKAGE__&lt;/code&gt; . It is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or starting from Perl 5.8.0 also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE和ATTRS的确切语义和接口仍在不断发展。 TYPE可以是一个空词， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; 声明的常量或 &lt;code&gt;__PACKAGE__&lt;/code&gt; 。当前它绑定到 &lt;code&gt;fields&lt;/code&gt; pragma 的使用，并且使用 &lt;code&gt;attributes&lt;/code&gt; pragma 处理属性，或者也可以通过 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 模块从Perl 5.8.0开始处理属性。有关详细信息以及&lt;a href=&quot;fields&quot;&gt;字段&lt;/a&gt;，&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;和&lt;a href=&quot;attribute/handlers&quot;&gt;Attribute :: Handlers的&lt;/a&gt;信息，请参见&lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;perlsub中的my（）的私有变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8bfadb028cf247124d08e25f901567b324753c6" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;__package__&quot;&gt;__PACKAGE__&lt;/a&gt;&lt;/code&gt;. It is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or starting from Perl 5.8.0 also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;../fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE和ATTRS的确切语义和接口仍在不断发展。 TYPE可以是一个空词， &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; 声明的常量或 &lt;code&gt;&lt;a href=&quot;__package__&quot;&gt;__PACKAGE__&lt;/a&gt;&lt;/code&gt; 。当前它绑定到 &lt;code&gt;fields&lt;/code&gt; pragma 的使用，并且使用 &lt;code&gt;attributes&lt;/code&gt; pragma 来处理属性，或者也可以通过 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 模块从Perl 5.8.0开始。有关详细信息以及&lt;a href=&quot;../fields&quot;&gt;字段&lt;/a&gt;，&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;和&lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute :: Handlers的&lt;/a&gt;信息，请参见&lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;perlsub中的my（）的私有变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8d599de382831818fdc3314909d743d15fa4f85" translate="yes" xml:space="preserve">
          <source>The exact set of characters matched by &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; varies depending on various pragma and regular expression modifiers. It is possible to restrict the match to the ASCII range by using the &lt;code&gt;/a&lt;/code&gt; regular expression modifier. See &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; 和 &lt;code&gt;\w&lt;/code&gt; 匹配的确切字符集取决于各种编译指示和正则表达式修饰符。使用 &lt;code&gt;/a&lt;/code&gt; 正则表达式修饰符可以将匹配限制在ASCII范围内。参见&lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23a6f9e0bca7b676930bcaa64329c3c867e0685e" translate="yes" xml:space="preserve">
          <source>The exact set of characters matched by &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; varies depending on various pragma and regular expression modifiers. It is possible to restrict the match to the ASCII range by using the &lt;code&gt;/a&lt;/code&gt; regular expression modifier. See &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="319ae490a71e74c46be21bc09971371ff532d6a8" translate="yes" xml:space="preserve">
          <source>The example above uses &lt;code&gt;select()&lt;/code&gt;, but any similar mechanism should work analogously. &lt;code&gt;IO::Socket::IP&lt;/code&gt; takes care when creating new socket filehandles to preserve the actual file descriptor number, so such techniques as &lt;code&gt;poll&lt;/code&gt; or &lt;code&gt;epoll&lt;/code&gt; should be transparent to its reallocation of a different socket underneath, perhaps in order to switch protocol family between &lt;code&gt;PF_INET&lt;/code&gt; and &lt;code&gt;PF_INET6&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130d6baa202fd58693c4e06f24211f73d068ae4b" translate="yes" xml:space="preserve">
          <source>The example below illustrates this feature using the pattern for floating point numbers that was presented earlier on. The three subpatterns that are used more than once are the optional sign, the digit sequence for an integer and the decimal fraction. The &lt;code&gt;DEFINE&lt;/code&gt; group at the end of the pattern contains their definition. Notice that the decimal fraction pattern is the first place where we can reuse the integer pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c6e96fbcd4407d552a2d3c6f391d06e2768883" translate="yes" xml:space="preserve">
          <source>The example below illustrates this feature using the pattern for floating point numbers that was presented earlier on. The three subpatterns that are used more than once are the optional sign, the digit sequence for an integer and the decimal fraction. The DEFINE group at the end of the pattern contains their definition. Notice that the decimal fraction pattern is the first place where we can reuse the integer pattern.</source>
          <target state="translated">下面的例子用前面介绍的浮点数的模式来说明这个功能。三个被多次使用的子模式是可选符号、整数的数字序列和小数分数。模式末尾的DEFINE组包含了它们的定义。注意,小数分数模式是我们可以重复使用整数模式的第一个地方。</target>
        </trans-unit>
        <trans-unit id="c669b79bf926dbbee70a1aab0498c88f6e21bd08" translate="yes" xml:space="preserve">
          <source>The example below shows what you need if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95b2fc7c1cff73cb10b6820506fd203858d5dd0" translate="yes" xml:space="preserve">
          <source>The example does not untaint &lt;code&gt;$data&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, because the characters matched by &lt;code&gt;\w&lt;/code&gt; are determined by the locale. Perl considers that locale definitions are untrustworthy because they contain data from outside the program. If you are writing a locale-aware program, and want to launder data with a regular expression containing &lt;code&gt;\w&lt;/code&gt; , put &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; ahead of the expression in the same block. See &lt;a href=&quot;perllocale#SECURITY&quot;&gt;SECURITY in perllocale&lt;/a&gt; for further discussion and examples.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境有效，该示例不会取消 &lt;code&gt;$data&lt;/code&gt; 污染，因为 &lt;code&gt;\w&lt;/code&gt; 匹配的字符由语言环境决定。 Perl认为语言环境定义是不可信的，因为它们包含程序外部的数据。如果您正在编写一个可识别语言环境的程序，并希望使用包含 &lt;code&gt;\w&lt;/code&gt; 的正则表达式清洗数据，则在同一块中的表达式前 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; 放置任何语言环境。有关更多讨论和示例，请参见&lt;a href=&quot;perllocale#SECURITY&quot;&gt;perllocale中的SECURITY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36698f0de180b3f94fb468b665a41ca7be987afb" translate="yes" xml:space="preserve">
          <source>The example does not untaint &lt;code&gt;$data&lt;/code&gt; if &lt;code&gt;use locale&lt;/code&gt; is in effect, because the characters matched by &lt;code&gt;\w&lt;/code&gt; are determined by the locale. Perl considers that locale definitions are untrustworthy because they contain data from outside the program. If you are writing a locale-aware program, and want to launder data with a regular expression containing &lt;code&gt;\w&lt;/code&gt;, put &lt;code&gt;no locale&lt;/code&gt; ahead of the expression in the same block. See &lt;a href=&quot;perllocale#SECURITY&quot;&gt;&quot;SECURITY&quot; in perllocale&lt;/a&gt; for further discussion and examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd1c21f507054a9e5bf00808f679503b139b9cd1" translate="yes" xml:space="preserve">
          <source>The examples above use a relative path to the perl interpreter, getting whatever version is first in the user's path. If you want a specific version of Perl, say, perl5.14.1, you should place that directly in the &lt;code&gt;#!&lt;/code&gt; line's path.</source>
          <target state="translated">上面的示例使用到perl解释器的相对路径，获取用户路径中第一个版本的文件。如果要使用Perl的特定版本，例如perl5.14.1，则应将其直接放在 &lt;code&gt;#!&lt;/code&gt; 中。线的路径。</target>
        </trans-unit>
        <trans-unit id="ba7768ce3ab49f321e6775f2de42c2a895f7304f" translate="yes" xml:space="preserve">
          <source>The examples given at the start of the document (an error handler and an event driven program) are typical of the two main sorts of flow control that you are likely to encounter with callbacks. There is a very important distinction between them, so pay attention.</source>
          <target state="translated">本文开头给出的例子(一个错误处理程序和一个事件驱动程序)是典型的两种主要的流控制类型,你可能会遇到回调。它们之间有一个非常重要的区别,所以要注意。</target>
        </trans-unit>
        <trans-unit id="d5744c543ee5f3d510361cac5aaaa06664739511" translate="yes" xml:space="preserve">
          <source>The examples illustrate several aspects: the first three queries target modules, authors, or distros directly and yield exactly one result. The last two use regular expressions and yield several results. The last one targets all of bundles, modules, authors, and distros simultaneously. When more than one result is available, they are printed in one-line format.</source>
          <target state="translated">这些例子说明了几个方面:前三个查询直接以模块、作者或发行版为目标,只产生一个结果。后面两个使用正则表达式,产生了多个结果。最后一个是同时针对所有的bundles、模块、作者和发行版。当有一个以上的结果时,它们会以单行格式打印。</target>
        </trans-unit>
        <trans-unit id="ddf2315db7343aee83255d9099df21a0faac3030" translate="yes" xml:space="preserve">
          <source>The examples in the previous section display an annoying weakness. We were only matching 3-letter words, or chunks of words of 4 letters or less. We'd like to be able to match words or, more generally, strings of any length, without writing out tedious alternatives like &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt; .</source>
          <target state="translated">上一节中的示例显示了一个令人讨厌的弱点。我们只匹配3个字母的单词或4个字母以下的单词块。我们希望能够匹配单词，或更广泛地说，匹配任何长度的字符串，而无需写出诸如 &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt; 类的乏味选择。</target>
        </trans-unit>
        <trans-unit id="da6aadb818ba37828bf9750c2c1c42a56a0d0753" translate="yes" xml:space="preserve">
          <source>The examples in the previous section display an annoying weakness. We were only matching 3-letter words, or chunks of words of 4 letters or less. We'd like to be able to match words or, more generally, strings of any length, without writing out tedious alternatives like &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a56adef05fecf63fd9cba639dd925bcaf1cb87b" translate="yes" xml:space="preserve">
          <source>The examples show a very simple class that implements a</source>
          <target state="translated">这些例子展示了一个非常简单的类,它实现了一个非常简单的</target>
        </trans-unit>
        <trans-unit id="45802eeee4d1f7759548f95073ecb55a63eb7a92" translate="yes" xml:space="preserve">
          <source>The examples show this class implemented with different levels of support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; . All supported combinations are shown. The difference between implementations is often quite small. The implementations are:</source>
          <target state="translated">这些示例显示了 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 通过不同级别的支持实现的此类。显示所有受支持的组合。实现之间的差异通常很小。实现是：</target>
        </trans-unit>
        <trans-unit id="7cfc17e4302419b2090ffa8fca11900025b88c94" translate="yes" xml:space="preserve">
          <source>The examples show this class implemented with different levels of support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt;. All supported combinations are shown. The difference between implementations is often quite small. The implementations are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51ffd2e5bcc1a6d7d14bd6f95a324550850104d" translate="yes" xml:space="preserve">
          <source>The excellent Calendar FAQ at &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;</source>
          <target state="translated">出色的日历常见问题解答，&lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;网址&lt;/a&gt;为http://www.tondering.dk/claus/calendar.html</target>
        </trans-unit>
        <trans-unit id="b98aabfe9b6ba71ecfd39be082dced0eadaf1cc4" translate="yes" xml:space="preserve">
          <source>The excellent Filter::Util::Call module (by Paul Marquess) provides a usable Perl interface to source filtering, but it is often too powerful and not nearly as simple as it could be.</source>
          <target state="translated">优秀的Filter::Util::Call模块(由Paul Marquess编写)为源码过滤提供了一个可用的Perl接口,但它往往太强大了,而且也没有那么简单。</target>
        </trans-unit>
        <trans-unit id="52ea595fb3e7d2ce456e743df519b555912d5e12" translate="yes" xml:space="preserve">
          <source>The exception is for organization-specific email (e.g. foo@yourcompany.com) where policy can be codified in your program. In that case, you could look at $ENV{USER}, $ENV{LOGNAME}, and getpwuid($&amp;lt;) in scalar context, like so:</source>
          <target state="translated">特定于组织的电子邮件（例如foo@yourcompany.com）例外，可以在您的程序中编写策略。在这种情况下，您可以在标量上下文中查看$ ENV {USER}，$ ENV {LOGNAME}和getpwuid（$ &amp;lt;），如下所示：</target>
        </trans-unit>
        <trans-unit id="1b5fd23c00f654857837ce525e2feca5e5a60486" translate="yes" xml:space="preserve">
          <source>The exception to the above rule is when the left-hand string begins with &lt;code&gt;0&lt;/code&gt; and is longer than one character, in this case the magic increment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc87b76bc5dac6308b19a21f2fb89ffe909a88b" translate="yes" xml:space="preserve">
          <source>The exception to the principle of &quot;one tainted value taints the whole expression&quot; is with the ternary conditional operator &lt;code&gt;?:&lt;/code&gt;. Since code with a ternary conditional</source>
          <target state="translated">三元条件运算符 &lt;code&gt;?:&lt;/code&gt; 是&amp;ldquo;一个值污染整个表达式&amp;rdquo;原理的例外。由于代码具有三元条件</target>
        </trans-unit>
        <trans-unit id="5c4020c3e362c07677c68b98797130c8e33e53fa" translate="yes" xml:space="preserve">
          <source>The exception to this rule are</source>
          <target state="translated">这一规则的例外是</target>
        </trans-unit>
        <trans-unit id="06cb57f51318b2c753120a0083873c4679095e1b" translate="yes" xml:space="preserve">
          <source>The exception to this rule is if you are calling a Perl subroutine directly from an XSUB function. In this case it is not necessary to use the &lt;code&gt;dSP&lt;/code&gt; macro explicitly--it will be declared for you automatically.</source>
          <target state="translated">此规则的例外是，如果您直接从XSUB函数调用Perl子例程。在这种情况下，无需显式使用 &lt;code&gt;dSP&lt;/code&gt; 宏-它将自动为您声明。</target>
        </trans-unit>
        <trans-unit id="0d894dabcea23f9b036a1c82348cf80da10ab49b" translate="yes" xml:space="preserve">
          <source>The exceptions are:</source>
          <target state="translated">例外情况是:</target>
        </trans-unit>
        <trans-unit id="3e26c68194190c41dfdad74105f0e492dc235a18" translate="yes" xml:space="preserve">
          <source>The execution order is indicated by &lt;code&gt;===&amp;gt;&lt;/code&gt; marks, thus it is &lt;code&gt;3
4 5 6&lt;/code&gt; (node &lt;code&gt;6&lt;/code&gt; is not included into above listing), i.e., &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt; .</source>
          <target state="translated">执行顺序由 &lt;code&gt;===&amp;gt;&lt;/code&gt; 标记指示，因此它是 &lt;code&gt;3 4 5 6&lt;/code&gt; （上面的列表中未包括节点 &lt;code&gt;6&lt;/code&gt; ），即 &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db1745f72327cdbec0c0f35f7353b51ef20c7bd5" translate="yes" xml:space="preserve">
          <source>The execution order is indicated by &lt;code&gt;===&amp;gt;&lt;/code&gt; marks, thus it is &lt;code&gt;3 4 5 6&lt;/code&gt; (node &lt;code&gt;6&lt;/code&gt; is not included into above listing), i.e., &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a81e1fe7a2f079c1b9f8b207b9fe9d777e92c5" translate="yes" xml:space="preserve">
          <source>The executive summary: learn how your filesystem works. The permissions on a file say what can happen to the data in that file. The permissions on a directory say what can happen to the list of files in that directory. If you delete a file, you're removing its name from the directory (so the operation depends on the permissions of the directory, not of the file). If you try to write to the file, the permissions of the file govern whether you're allowed to.</source>
          <target state="translated">内容提要:了解你的文件系统如何工作。一个文件上的权限说的是该文件中的数据可以发生什么。一个目录上的权限说的是该目录中的文件列表可以发生什么。如果你删除一个文件,你就会从目录中删除它的名字(所以这个操作取决于目录的权限,而不是文件的权限)。如果你试图向文件写入,文件的权限支配你是否被允许。</target>
        </trans-unit>
        <trans-unit id="8bd1d5ba511947aaf27cf0898729cbcdb3363ec9" translate="yes" xml:space="preserve">
          <source>The existence of a rule does not imply selecting a test. You must still specify the tests to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29fc393062d8546f20ed1b167ba8df5f73019ce5" translate="yes" xml:space="preserve">
          <source>The exit code of the executed program.</source>
          <target state="translated">执行程序的退出代码。</target>
        </trans-unit>
        <trans-unit id="137ed18115f3228ba7f07a48e55913ee96e30593" translate="yes" xml:space="preserve">
          <source>The exit status value to return.</source>
          <target state="translated">要返回的退出状态值。</target>
        </trans-unit>
        <trans-unit id="0c5c8d24f00e7eedd0cb8f1fea1a1b90fbdc8c11" translate="yes" xml:space="preserve">
          <source>The exit() function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;code&gt;$?&lt;/code&gt; . If this is a problem, you can call &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; to avoid END and destructor processing. See &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="translated">exit（）函数并不总是立即退出。它首先调用任何已定义的 &lt;code&gt;END&lt;/code&gt; 例程，但是这些 &lt;code&gt;END&lt;/code&gt; 例程本身可能不会中止退出。同样，任何需要调用的对象析构函数都在实际出口之前被调用。 &lt;code&gt;END&lt;/code&gt; 例程和析构函数可以通过修改 &lt;code&gt;$?&lt;/code&gt; 来更改退出状态。。如果这是一个问题，则可以调用 &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; 以避免END和析构函数的处理。有关详细信息，请参见&lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="680c902ef0b900a40fad1c488731545af94f9d10" translate="yes" xml:space="preserve">
          <source>The exit() function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;code&gt;$?&lt;/code&gt; . If this is a problem, you can call &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; to avoid END and destructor processing. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="translated">exit（）函数并不总是立即退出。它首先调用任何已定义的 &lt;code&gt;END&lt;/code&gt; 例程，但是这些 &lt;code&gt;END&lt;/code&gt; 例程本身可能不会中止退出。同样，任何需要调用的对象析构函数都在实际出口之前被调用。 &lt;code&gt;END&lt;/code&gt; 例程和析构函数可以通过修改 &lt;code&gt;$?&lt;/code&gt; 来更改退出状态。。如果这是一个问题，则可以调用 &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; 以避免END和析构函数的处理。有关详细信息，请参见&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="878ff23487a7f8c43fec8d4483cc1765c4df9eb4" translate="yes" xml:space="preserve">
          <source>The experimental &lt;code&gt;given&lt;/code&gt; statement is</source>
          <target state="translated">实验 &lt;code&gt;given&lt;/code&gt; 语句是</target>
        </trans-unit>
        <trans-unit id="19bd303111f858742510d8d90c5638313c02c5ce" translate="yes" xml:space="preserve">
          <source>The experimental &lt;code&gt;legacy&lt;/code&gt; pragma was swallowed by the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;code&gt;feature&lt;/code&gt; 杂语淹没了实验性的 &lt;code&gt;legacy&lt;/code&gt; 杂语。</target>
        </trans-unit>
        <trans-unit id="52d7e8e19cc3efaf2aec8d989a33421d70ed317d" translate="yes" xml:space="preserve">
          <source>The experimental declared_refs feature is not enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccc48fde094b67b79701d699ac45d91d085adcc" translate="yes" xml:space="preserve">
          <source>The experimental feature &lt;code&gt;&quot;(?[...])&quot;&lt;/code&gt; starting in v5.18 accomplishes this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="868cc46704185b2a446e1b7a62d0312275a48c48" translate="yes" xml:space="preserve">
          <source>The explanation above has omitted some detail; refer to UAX#24 &quot;Unicode Script Property&quot;: &lt;a href=&quot;https://www.unicode.org/reports/tr24&quot;&gt;https://www.unicode.org/reports/tr24&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0349830ce8cbe97566441b2e1c5b4811ccfb44c1" translate="yes" xml:space="preserve">
          <source>The exponent is an &lt;code&gt;'e'&lt;/code&gt; or &lt;code&gt;'E'&lt;/code&gt;, followed by an integer. So the exponent regexp is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f321e42a52fdc6b5d89f69bf0fc91962da84c32f" translate="yes" xml:space="preserve">
          <source>The exponent is an &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt; , followed by an integer. So the exponent regexp is</source>
          <target state="translated">指数是 &lt;code&gt;e&lt;/code&gt; 或 &lt;code&gt;E&lt;/code&gt; ，后跟一个整数。所以指数正则表达式是</target>
        </trans-unit>
        <trans-unit id="dc560dadf22f2caa4887dcda366e49e8868f1d51" translate="yes" xml:space="preserve">
          <source>The exponentiation operator is &quot;**&quot;, not &quot;^&quot;. &quot;^&quot; is the XOR operator, as in C. (You know, one could get the feeling that &lt;b&gt;awk&lt;/b&gt; is basically incompatible with C.)</source>
          <target state="translated">取幂运算符是&amp;ldquo; **&amp;rdquo;，而不是&amp;ldquo; ^&amp;rdquo;。像C中一样，&amp;ldquo; ^&amp;rdquo;是XOR运算符（您可能会感觉到&lt;b&gt;awk&lt;/b&gt;与C基本不兼容。）</target>
        </trans-unit>
        <trans-unit id="009dcc9526e9f6902be1b067b6a2b9829ed8f757" translate="yes" xml:space="preserve">
          <source>The expression is evaluated in scalar context. So the following will work:</source>
          <target state="translated">表达式是在标量上下文中评估的。因此,下面的方法就可以了。</target>
        </trans-unit>
        <trans-unit id="09c23065a9eeac610af39d5a880a04c9ff912e79" translate="yes" xml:space="preserve">
          <source>The ext/ODBM_File/odbm is known to fail with static builds (Configure -Uusedl) due to a known bug in Tru64's static libdbm library. The good news is that you very probably don't need to ever use the ODBM_File extension since more advanced NDBM_File works fine, not to mention the even more advanced DB_File.</source>
          <target state="translated">已知 ext/ODBM_File/odbm 在静态构建时可能会失败 (Configure -Uusedl),这是因为 Tru64 的静态 libdbm 库存在一个已知的 bug。好消息是,你很可能不需要使用 ODBM_File 扩展,因为更高级的 NDBM_File 可以正常工作,更不用说更高级的 DB_File 了。</target>
        </trans-unit>
        <trans-unit id="31ec63f172c0fdca1326836d5d87e5fe035f0607" translate="yes" xml:space="preserve">
          <source>The extended filetest functionality is used by Perl only when the argument of the operators is a filename, not when it is a filehandle.</source>
          <target state="translated">扩展的filetest功能只有在运算符的参数是文件名时才会被Perl使用,而不是当它是一个文件手时。</target>
        </trans-unit>
        <trans-unit id="b669bdb080a6675f7c6ed5d24b2ef14539648c80" translate="yes" xml:space="preserve">
          <source>The extension is dynamically linked</source>
          <target state="translated">该扩展是动态链接的</target>
        </trans-unit>
        <trans-unit id="f990232badfb418cbf7dd0574833889e9f679aa9" translate="yes" xml:space="preserve">
          <source>The extension is pure perl, so doesn't need linking to the perl executable</source>
          <target state="translated">该扩展是纯perl的,所以不需要链接到perl可执行文件。</target>
        </trans-unit>
        <trans-unit id="13f70d182dd718c2ffdf92971d2248139cbe171e" translate="yes" xml:space="preserve">
          <source>The extension is statically linked to the perl binary</source>
          <target state="translated">扩展是静态地链接到perl二进制文件的</target>
        </trans-unit>
        <trans-unit id="b14db60112e20420246ea9d3dec3923a929f96a3" translate="yes" xml:space="preserve">
          <source>The extracted information is stored in 5 entries in the &lt;code&gt;build&lt;/code&gt; hash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1beda77ee5a84052f068e6757ef13cea3f36f8f" translate="yes" xml:space="preserve">
          <source>The extracted string, including the specified delimiters. If the extraction fails &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">提取的字符串，包括指定的定界符。如果提取失败，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2570abc8ab1be73d003248dd246a24a2fc5f319" translate="yes" xml:space="preserve">
          <source>The extracted string, including the specified delimiters. If the extraction fails &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3130a57897b10b0bc008c6b4f6ef79e3b3444412" translate="yes" xml:space="preserve">
          <source>The extracted termcap entry is available in the object as &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt; .</source>
          <target state="translated">提取的termcap条目在对象中可用为 &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adf0aca1542de815275e994553ee7120f60337c3" translate="yes" xml:space="preserve">
          <source>The extracted termcap entry is available in the object as &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c328df413a33fa608e46c6826495b03f8d0ee0f6" translate="yes" xml:space="preserve">
          <source>The extraction process works by applying each extractor in sequence to the text string.</source>
          <target state="translated">提取过程的工作原理是将每个提取器依次应用到文本字符串上。</target>
        </trans-unit>
        <trans-unit id="7ad2005947669b79c8509770fad3b2b296acf5fd" translate="yes" xml:space="preserve">
          <source>The fact that such a FILE * has been 'exported' is recorded, (normally by pushing a new :stdio &quot;layer&quot; onto the PerlIO *), which may affect future PerlIO operations on the original PerlIO *. You should not call &lt;code&gt;fclose()&lt;/code&gt; on the file unless you call &lt;code&gt;PerlIO_releaseFILE()&lt;/code&gt; to disassociate it from the PerlIO *. (Do not use PerlIO_importFILE() for doing the disassociation.)</source>
          <target state="translated">记录了这样一个FILE *已经被&amp;ldquo;导出&amp;rdquo;的事实（通常通过将新的：stdio&amp;ldquo;层&amp;rdquo;推入PerlIO *）来进行记录，这可能会影响将来在原始PerlIO *上进行的PerlIO操作。除非调用 &lt;code&gt;PerlIO_releaseFILE()&lt;/code&gt; 使其与PerlIO *解除关联，否则不应在文件上调用 &lt;code&gt;fclose()&lt;/code&gt; 。 （请勿使用PerlIO_importFILE（）进行取消关联。）</target>
        </trans-unit>
        <trans-unit id="357aafdac768e27bb52a043649452bd876a53d4d" translate="yes" xml:space="preserve">
          <source>The factory itself is never instantiated (this</source>
          <target state="translated">工厂本身从未被实例化(这个</target>
        </trans-unit>
        <trans-unit id="ee17924499933b661b8e0c34b82c36eff25eeaf5" translate="yes" xml:space="preserve">
          <source>The fastgetcwd() function is provided as a synonym for cwd().</source>
          <target state="translated">fastgetcwd()函数是作为cwd()的同义词提供的。</target>
        </trans-unit>
        <trans-unit id="3c06a8aa0a4d260ed2765600496ce1fc1ffcef9e" translate="yes" xml:space="preserve">
          <source>The feature logical name &lt;code&gt;PERL_VMS_VTF7_FILENAMES&lt;/code&gt; controls if UNICODE characters in Unix filenames are encoded in VTF-7 notation in the resulting OpenVMS file specification. [Currently under development]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="533f832808f430e9fde8557e2b27391f20356a2e" translate="yes" xml:space="preserve">
          <source>The feature logical name DECC$FILENAME_UNIX_REPORT modifies traditional Perl behavior in the conversion of file specifications from Unix to VMS format in order to follow the extended character handling rules now expected by the CRTL. Specifically, when this feature is in effect, the &lt;code&gt;./.../&lt;/code&gt; in a Unix path is now translated to &lt;code&gt;[.^.^.^.]&lt;/code&gt; instead of the traditional VMS &lt;code&gt;[...]&lt;/code&gt; . To be compatible with what MakeMaker expects, if a VMS path cannot be translated to a Unix path, it is passed through unchanged, so &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; will return &lt;code&gt;[...]&lt;/code&gt; .</source>
          <target state="translated">功能逻辑名称DECC $ FILENAME_UNIX_REPORT修改了将文件规范从Unix转换为VMS格式时的传统Perl行为，以便遵循CRTL现在期望的扩展字符处理规则。具体来说，当此功能生效时，Unix路径中的 &lt;code&gt;./.../&lt;/code&gt; 现在可以转换为 &lt;code&gt;[.^.^.^.]&lt;/code&gt; 而不是传统的VMS &lt;code&gt;[...]&lt;/code&gt; 。为了与MakeMaker期望的兼容，如果无法将VMS路径转换为Unix路径，则将其 &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; 传递，因此unixify（&amp;ldquo; [...]&amp;rdquo;）将返回 &lt;code&gt;[...]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd427ddb1d40a440a4569bc32b983da79c223869" translate="yes" xml:space="preserve">
          <source>The feature logical name DECC$FILENAME_UNIX_REPORT modifies traditional Perl behavior in the conversion of file specifications from Unix to VMS format in order to follow the extended character handling rules now expected by the CRTL. Specifically, when this feature is in effect, the &lt;code&gt;./.../&lt;/code&gt; in a Unix path is now translated to &lt;code&gt;[.^.^.^.]&lt;/code&gt; instead of the traditional VMS &lt;code&gt;[...]&lt;/code&gt;. To be compatible with what MakeMaker expects, if a VMS path cannot be translated to a Unix path, it is passed through unchanged, so &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; will return &lt;code&gt;[...]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ee4cd3c900fba7f346eaf4d73c2e59283171b2" translate="yes" xml:space="preserve">
          <source>The feature needs to be enabled with &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt; .</source>
          <target state="translated">该功能需要通过 &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt; 启用。</target>
        </trans-unit>
        <trans-unit id="6b1fe35afa1a3972e367d70f65936f774e7c1fb4" translate="yes" xml:space="preserve">
          <source>The feature needs to be enabled with &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9967e9df7e264da6bcdb44f5aee030bc917d02a" translate="yes" xml:space="preserve">
          <source>The features you got from your mother and father, mixed together unpredictably. (See also &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;single inheritance&lt;/b&gt;.) In computer languages (including Perl), it is the notion that a given class may have multiple direct ancestors or &lt;b&gt;base classes&lt;/b&gt;.</source>
          <target state="translated">您从母亲和父亲那里获得的功能是无法预测地融合在一起的。（另请参见&lt;b&gt;继承&lt;/b&gt;和&lt;b&gt;单继承&lt;/b&gt;。）在计算机语言（包括Perl）中，这是给定类可以具有多个直接祖先或&lt;b&gt;基类&lt;/b&gt;的观念。</target>
        </trans-unit>
        <trans-unit id="ddb61ef14874404dd766423660c7d397637ace24" translate="yes" xml:space="preserve">
          <source>The features you got from your mother, if she told you that you don&amp;rsquo;t have a father. (See also &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;multiple inheritance&lt;/b&gt;.) In computer languages, the idea that &lt;b&gt;classes&lt;/b&gt; reproduce asexually so that a given class can only have one direct ancestor or &lt;b&gt;base class&lt;/b&gt;. Perl supplies no such restriction, though you may certainly program Perl that way if you like.</source>
          <target state="translated">如果母亲告诉您您没有父亲，那么您从母亲那里获得的功能。（另请参见&lt;b&gt;继承&lt;/b&gt;和&lt;b&gt;多重继承&lt;/b&gt;。）在计算机语言中，&lt;b&gt;类&lt;/b&gt;的观念是无性繁殖的，因此给定的类只能具有一个直接祖先或&lt;b&gt;基类&lt;/b&gt;。Perl没有提供这样的限制，但是如果您愿意的话，您当然可以用这种方式编程Perl。</target>
        </trans-unit>
        <trans-unit id="587f845c68a8e5df6c3b5c11be163e859d4bde0c" translate="yes" xml:space="preserve">
          <source>The few places where stricter matching is used is in the middle of numbers, the &quot;name&quot; property, and in the Perl extension properties that begin or end with an underscore. Stricter matching cares about white space (except adjacent to non-word characters), hyphens, and non-interior underscores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3635eb281607d1f863de82b6a5a308964a4737" translate="yes" xml:space="preserve">
          <source>The field &quot;@*&quot; can be used for printing multi-line, nontruncated values; it should (but need not) appear by itself on a line. A final line feed is chomped off, but all other characters are emitted verbatim.</source>
          <target state="translated">字段&quot;@*&quot;可用于打印多行、非截断的值;它应该(但不需要)单独出现在一行上。最后的换行会被截断,但所有其他字符都会被逐字输出。</target>
        </trans-unit>
        <trans-unit id="90122eb3cf35f8e2aff21a4431fdb4311bb6f9c0" translate="yes" xml:space="preserve">
          <source>The field of Linguistics has expended a great deal of effort over the past century trying to find grammatical patterns which hold across languages; it's been a constant process of people making generalizations that should apply to all languages, only to find out that, all too often, these generalizations fail -- sometimes failing for just a few languages, sometimes whole classes of languages, and sometimes nearly every language in the world except English. Broad statistical trends are evident in what the &quot;average language&quot; is like as far as what its rules can look like, must look like, and cannot look like. But the &quot;average language&quot; is just as unreal a concept as the &quot;average person&quot; -- it runs up against the fact no language (or person) is, in fact, average. The wisdom of past experience leads us to believe that any given language can do whatever it wants, in any order, with appeal to any kind of grammatical categories wants -- case, number, tense, real or metaphoric characteristics of the things that words refer to, arbitrary or predictable classifications of words based on what endings or prefixes they can take, degree or means of certainty about the truth of statements expressed, and so on, ad infinitum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f6e6f64de0d391d989196e8ebb7ddb708ac60a" translate="yes" xml:space="preserve">
          <source>The fields are discussed in more detail below:</source>
          <target state="translated">下面将详细讨论这些领域。</target>
        </trans-unit>
        <trans-unit id="c46c3f9340cdb846123d0b6b0164cec0b439e50c" translate="yes" xml:space="preserve">
          <source>The fields are tab-separated. The first column is the depth (zero being the innermost non-skipped frame). In the hex:offset, the hex is where the program counter was in &lt;code&gt;S_parse_body&lt;/code&gt;, and the :offset (might be missing) tells how much inside the &lt;code&gt;S_parse_body&lt;/code&gt; the program counter was.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d21955b9d1337383a18b406fff73dac35d4d6488" translate="yes" xml:space="preserve">
          <source>The fields are tab-separated. The first column is the depth (zero being the innermost non-skipped frame). In the hex:offset, the hex is where the program counter was in S_parse_body, and the :offset (might be missing) tells how much inside the S_parse_body the program counter was.</source>
          <target state="translated">字段是以标签分隔的。第一列是深度(0是最里面的非跳转帧)。在hex:offset中,hex是程序计数器在S_parse_body中的位置,而:offset(可能会缺失)则是告诉程序计数器在S_parse_body里面的位置。</target>
        </trans-unit>
        <trans-unit id="f2427d714dfbcb812d5c2c0e464389b37b28e37a" translate="yes" xml:space="preserve">
          <source>The fields in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aabcb5c5289f7ad819b54aa9417f88080d7fec5" translate="yes" xml:space="preserve">
          <source>The fields of interest which may appear in this line are</source>
          <target state="translated">这一行可能出现的相关领域是:</target>
        </trans-unit>
        <trans-unit id="834f0bb251e57720466af45a551b7e653c4d2d6b" translate="yes" xml:space="preserve">
          <source>The fields of the context struct and the arguments to the &lt;code&gt;cx_*&lt;/code&gt; functions are subject to change between perl releases, representing whatever is convenient or efficient for that release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fbc7508d5d457aedc840547581d13fb785d13c" translate="yes" xml:space="preserve">
          <source>The file</source>
          <target state="translated">该文件</target>
        </trans-unit>
        <trans-unit id="99944ba23fa1671290cc70fdf7f917ecb5343db9" translate="yes" xml:space="preserve">
          <source>The file (name) the error occurred in.</source>
          <target state="translated">发生错误的文件(名称)。</target>
        </trans-unit>
        <trans-unit id="801d0d7bebcd5bd5a38aa07b4d567dc82dc85f4a" translate="yes" xml:space="preserve">
          <source>The file (name) the error occurred in. Defaults to the name of the current file being processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74280467b06cd39e1ebe6f256e50f06eca04fcbe" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;perlio.c&lt;/code&gt; provides the following layers:</source>
          <target state="translated">&lt;code&gt;perlio.c&lt;/code&gt; 文件提供以下层：</target>
        </trans-unit>
        <trans-unit id="b4bb1e7661bc100161f83c2b2d4bc9930cd6bed6" translate="yes" xml:space="preserve">
          <source>The file MANIFEST.SKIP may contain regular expressions of files that should be ignored by mkmanifest() and filecheck(). The regular expressions should appear one on each line. Blank lines and lines which start with &lt;code&gt;#&lt;/code&gt; are skipped. Use &lt;code&gt;\#&lt;/code&gt; if you need a regular expression to start with a &lt;code&gt;#&lt;/code&gt; .</source>
          <target state="translated">文件MANIFEST.SKIP可能包含mkmanifest（）和filecheck（）应该忽略的文件的正则表达式。正则表达式应在每一行上显示一个。空行和以 &lt;code&gt;#&lt;/code&gt; 开头的行将被跳过。如果您需要以 &lt;code&gt;#&lt;/code&gt; 开头的正则表达式，请使用 &lt;code&gt;\#&lt;/code&gt; ＃。</target>
        </trans-unit>
        <trans-unit id="5b4d65899438f61d608a7cb61bcc5fc30c8781c4" translate="yes" xml:space="preserve">
          <source>The file MANIFEST.SKIP may contain regular expressions of files that should be ignored by mkmanifest() and filecheck(). The regular expressions should appear one on each line. Blank lines and lines which start with &lt;code&gt;#&lt;/code&gt; are skipped. Use &lt;code&gt;\#&lt;/code&gt; if you need a regular expression to start with a &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2791b558da2cb7ec65180cdaeb2459b7a1726fa1" translate="yes" xml:space="preserve">
          <source>The file Makefile.PL should look something like this:</source>
          <target state="translated">文件Makefile.PL应该是这样的。</target>
        </trans-unit>
        <trans-unit id="76e388baaf2a00fb72a8272cf31814ec70994241" translate="yes" xml:space="preserve">
          <source>The file Mytest.pm should start with something like this:</source>
          <target state="translated">Mytest.pm文件的开头应该是这样的。</target>
        </trans-unit>
        <trans-unit id="a37078c2a2fb3ae7f022a61feee12e4a85c77a67" translate="yes" xml:space="preserve">
          <source>The file Unicode/Collate/allkeys.txt was copied verbatim from &lt;a href=&quot;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&lt;/a&gt;. For this file, Copyright (c) 2001-2012 Unicode, Inc. Distributed under the Terms of Use in &lt;a href=&quot;http://www.unicode.org/copyright.html&quot;&gt;http://www.unicode.org/copyright.html&lt;/a&gt;.</source>
          <target state="translated">文件Unicode / Collat​​e / allkeys.txt是从&lt;a href=&quot;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&lt;/a&gt;逐字复制的。对于此文件，版权所有（c）2001-2012 Unicode，Inc.。根据使用条款在&lt;a href=&quot;http://www.unicode.org/copyright.html&quot;&gt;http://www.unicode.org/copyright.html中&lt;/a&gt;分发。</target>
        </trans-unit>
        <trans-unit id="30a5f318824f5507113c28e19247cf8309413692" translate="yes" xml:space="preserve">
          <source>The file Unicode/Collate/allkeys.txt was copied verbatim from &lt;a href=&quot;http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt&lt;/a&gt;. For this file, Copyright (c) 2016 Unicode, Inc.; distributed under the Terms of Use in &lt;a href=&quot;http://www.unicode.org/terms_of_use.html&quot;&gt;http://www.unicode.org/terms_of_use.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588cd9780438caba5355d1e82516b077a96efe46" translate="yes" xml:space="preserve">
          <source>The file in which the error occurred (eg, &lt;code&gt;myscript.pl&lt;/code&gt; or &lt;code&gt;MyTest.pm&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1744236e794a4c53bf20da07fd1df8dc62fc8e81" translate="yes" xml:space="preserve">
          <source>The file is</source>
          <target state="translated">该文件是</target>
        </trans-unit>
        <trans-unit id="e4567b3de0171c763b083662777b94d3405e1c0f" translate="yes" xml:space="preserve">
          <source>The file is a sparse file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a1515b1fc6663ef9dea0c0281497256e9502ad" translate="yes" xml:space="preserve">
          <source>The file is being used for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is available, because often the application deletes the temporary file shortly after the handle is closed. In that case, the system can entirely avoid writing the data. Otherwise, the data will be written after the handle is closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a42520a58ddeeb12292112f2a308b0310a0a00" translate="yes" xml:space="preserve">
          <source>The file is removed when the filehandle is closed or when the program exits. No access to the filename is provided.</source>
          <target state="translated">当文件柄关闭或程序退出时,该文件将被删除。不提供对文件名的访问。</target>
        </trans-unit>
        <trans-unit id="5b68113e94418bbe01dba1e8408762baaba90492" translate="yes" xml:space="preserve">
          <source>The file must return true as the last statement to indicate successful execution of any initialization code, so it's customary to end such a file with &lt;code&gt;1;&lt;/code&gt; unless you're sure it'll return true otherwise. But it's better just to put the &lt;code&gt;1;&lt;/code&gt; , in case you add more statements.</source>
          <target state="translated">该文件必须作为最后一条语句返回true，以指示任何初始化代码的成功执行，因此习惯上以1结尾这样的文件 &lt;code&gt;1;&lt;/code&gt; 除非您确定否则它将返回true。但是最好只放 &lt;code&gt;1;&lt;/code&gt; ，以防添加更多语句。</target>
        </trans-unit>
        <trans-unit id="db479c8e212dd28f37cf11de532fb13a4706ab4c" translate="yes" xml:space="preserve">
          <source>The file must return true as the last statement to indicate successful execution of any initialization code, so it's customary to end such a file with &lt;code&gt;1;&lt;/code&gt; unless you're sure it'll return true otherwise. But it's better just to put the &lt;code&gt;1;&lt;/code&gt;, in case you add more statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda785c206d1d83026d51c7970996f0a544bbd22" translate="yes" xml:space="preserve">
          <source>The file named in VERSION_FROM is not added as a dependency to Makefile. This is not really correct, but it would be a major pain during development to have to rewrite the Makefile for any smallish change in that file. If you want to make sure that the Makefile contains the correct VERSION macro after any change of the file, you would have to do something like</source>
          <target state="translated">在 VERSION_FROM 中命名的文件没有被添加到 Makefile 中作为依赖关系。这其实并不正确,但在开发过程中,如果要为该文件的任何细微变化而重写Makefile,那将是一件非常痛苦的事情。如果你想确保在对文件进行任何修改后,Makefile 中包含正确的 VERSION 宏,你就必须做一些类似这样的事情</target>
        </trans-unit>
        <trans-unit id="1264aef66e240939ce372646b5dc5401497e1664" translate="yes" xml:space="preserve">
          <source>The file or directory has an associated reparse point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af548b827b63fa83aaea96b3b1471e3f70a720b8" translate="yes" xml:space="preserve">
          <source>The file or directory has no other attributes set. This attribute is valid only if used alone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a20833b40e53533fae911a70eb77893d34ddc0e" translate="yes" xml:space="preserve">
          <source>The file or directory is an archive file or directory. Applications use this attribute to mark files for backup or removal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a28a2595e27b62a75bd273e98ef20b3ef8db95b" translate="yes" xml:space="preserve">
          <source>The file or directory is compressed. For a file, this means that all of the data in the file is compressed. For a directory, this means that compression is the default for newly created files and subdirectories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d84e09e4ae07a74635af247678d4e0053654f7b" translate="yes" xml:space="preserve">
          <source>The file or directory is encrypted. For a file, this means that all data streams in the file are encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97235d485d43a9b6726df3990eccad2157355604" translate="yes" xml:space="preserve">
          <source>The file or directory is hidden. It is not included in an ordinary directory listing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511d8ef3c0880481e73ffbe5546aad0ca9af7623" translate="yes" xml:space="preserve">
          <source>The file or directory is part of, or is used exclusively by, the operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a862ef7b392abfc56ec7987f674bfc97e4e196" translate="yes" xml:space="preserve">
          <source>The file or directory is read-only. Applications can read the file but cannot write to it or delete it. In the case of a directory, applications cannot delete it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdaf2cba4d9764ecdf7f47c7aa146b4c33b7bbf0" translate="yes" xml:space="preserve">
          <source>The file redirection characters &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, and &quot;|&quot; can be quoted by double quotes (although there are suggestions that this may not always be true). Single quotes are not treated as quotes by the shell or the C runtime, they don't get stripped by the shell (just to make this type of quoting completely useless). The caret &quot;^&quot; has also been observed to behave as a quoting character, but this appears to be a shell feature, and the caret is not stripped from the command line, so Perl still sees it (and the C runtime phase does not treat the caret as a quote character).</source>
          <target state="translated">文件重定向字符&amp;ldquo; &amp;lt;&amp;rdquo;，&amp;ldquo;&amp;ldquo;&amp;gt;&amp;rdquo;和&amp;ldquo; |&amp;rdquo;可以用双引号引起来（尽管有些建议可能并不总是如此）。 shell或C运行时不会将单引号视为引号，它们不会被shell剥夺（只是使这种类型的引号完全无用）。还可以观察到插入符&amp;ldquo; ^&amp;rdquo;表现为引号字符，但这似乎是shell功能，并且没有从命令行中删除插入符，因此Perl仍然可以看到它（并且C运行时阶段不处理插入符号作为引号）。</target>
        </trans-unit>
        <trans-unit id="50901ff92251eec862c454e35476bb796a0417dd" translate="yes" xml:space="preserve">
          <source>The file returned by File::Temp will have been opened in binary mode if such a mode is available. If that is not correct, use the &lt;code&gt;binmode()&lt;/code&gt; function to change the mode of the filehandle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52fb6cb3aabc05d2c0113ff975b6b538671a53b3" translate="yes" xml:space="preserve">
          <source>The file returned by File::Temp will have been opened in binary mode if such a mode is available. If that is not correct, use the C</source>
          <target state="translated">File::Temp 返回的文件将以二进制模式打开,如果这种模式可用的话。如果不正确,请使用C</target>
        </trans-unit>
        <trans-unit id="ce9457f95e305ab599387997a39303f4f4596d9a" translate="yes" xml:space="preserve">
          <source>The file specifications of &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt; will be converted to &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[-]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1bf193f0391c5390c8fed583c48df05d19c307" translate="yes" xml:space="preserve">
          <source>The file system preserves Unicode in file names [true for &quot;NTFS&quot;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb5efb93d11a4fd3e9514acb9b3c301836d1d02" translate="yes" xml:space="preserve">
          <source>The file system preserves the case of file names [usually true]. That is, it doesn't change the case of file names such as forcing them to upper- or lower-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04a32c75b0e4d58abe85e387d4b6865a5c9ef55" translate="yes" xml:space="preserve">
          <source>The file system supports compression on a per-file basis [true for &quot;NTFS&quot;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d32a15b0b05b7bd2cbe516ad58a7e5b3062c6e8" translate="yes" xml:space="preserve">
          <source>The file system supports setting Access Control Lists on files [true for &quot;NTFS&quot;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78fe12a81a2024d0eb3a6b039559611ea6c933d5" translate="yes" xml:space="preserve">
          <source>The file system supports the ability to not ignore the case of file names [but might ignore case the way you are using it]. That is, the file system has the ability to force you to get the letter case of a file's name exactly right to be able to open it. This is true for &quot;NTFS&quot; file systems, even though case in file names is usually still ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3318e11fa92791fcdb7d551f55db23d41576d211" translate="yes" xml:space="preserve">
          <source>The file type, or extension, is always present in a VMS-format file specification even if it's zero-length. This means that, by default, &lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt; will return a trailing dot on a file with no extension, so where you would see &lt;code&gt;&quot;a&quot;&lt;/code&gt; on Unix you'll see &lt;code&gt;&quot;a.&quot;&lt;/code&gt; on VMS. However, the trailing dot may be suppressed by enabling the &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; feature in the environment (see the CRTL documentation on feature logical names).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c1f1869978b35696fb14c540a8ba10948b7605" translate="yes" xml:space="preserve">
          <source>The file type, or extension, is always present in a VMS-format file specification even if it's zero-length. This means that, by default, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; will return a trailing dot on a file with no extension, so where you would see &lt;code&gt;&quot;a&quot;&lt;/code&gt; on Unix you'll see &lt;code&gt;&quot;a.&quot;&lt;/code&gt; on VMS. However, the trailing dot may be suppressed by enabling the &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; feature in the environment (see the CRTL documentation on feature logical names).</source>
          <target state="translated">文件类型或扩展名始终存在于VMS格式的文件规范中，即使其长度为零。这意味着，默认情况下， &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 将在不带扩展名的文件上返回尾随点，因此在Unix上看到 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 地方将看到&amp;ldquo; a&amp;rdquo; &lt;code&gt;&quot;a.&quot;&lt;/code&gt; 在VMS上。但是，可以通过在环境中启用 &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; 功能来抑制尾随点（请参阅CRTL文档中的功能逻辑名）。</target>
        </trans-unit>
        <trans-unit id="4023271c9fc7425e571468846ea1d383c9d49eba" translate="yes" xml:space="preserve">
          <source>The file types are:</source>
          <target state="translated">文件类型有:</target>
        </trans-unit>
        <trans-unit id="913f7be6fa85f1e72e30e862d223c440b0b1e681" translate="yes" xml:space="preserve">
          <source>The file will not be indexed by the content indexing service.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43719b35ec87acc604024ce99c0c8fb60624b26e" translate="yes" xml:space="preserve">
          <source>The file's mode</source>
          <target state="translated">文件的模式</target>
        </trans-unit>
        <trans-unit id="a95c16ea1ecea8120f9e1164c67484d409f61395" translate="yes" xml:space="preserve">
          <source>The file's name</source>
          <target state="translated">文件的名称</target>
        </trans-unit>
        <trans-unit id="4b9a5685b1075bc4b20ae964579e2b1d813d620d" translate="yes" xml:space="preserve">
          <source>The filehandle behaves normally for the parent, but I/O to that filehandle is piped from/to the STDOUT/STDIN of the child process. In the child process, the filehandle isn't opened--I/O happens from/to the new STDOUT/STDIN. Typically this is used like the normal piped open when you want to exercise more control over just how the pipe command gets executed, such as when running setuid and you don't want to have to scan shell commands for metacharacters.</source>
          <target state="translated">filehandle对父进程来说是正常的,但对该filehandle的I/O是从/到子进程的STDOUT/STDIN的管道。在子进程中,文件柄并没有被打开--I/O是从/到新的STDOUT/STDIN的。通常,当你想对管道命令的执行方式进行更多的控制时,比如在运行setuid时,你不想扫描shell命令中的元字符时,就会像普通的管道打开一样使用这个方法。</target>
        </trans-unit>
        <trans-unit id="92ee26a1481d9c364e91c69e1999f81d1550b5da" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;a href=&quot;#my-VARLIST&quot;&gt;&lt;code&gt;my&lt;/code&gt;&lt;/a&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d3d5cbabb04fbe3144e08782ff5dbb8eaf643d" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="translated">当其引用计数达到零时，文件句柄将关闭。如果它是用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明的词法范围变量，则通常意味着封闭范围的结尾。但是，此自动关闭不会检查错误，因此最好显式关闭文件句柄，尤其是用于写入的文件句柄：</target>
        </trans-unit>
        <trans-unit id="c6da7495029a8eadd3a9c0429778422e3ffb1d61" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="translated">当其引用计数达到零时，文件句柄将关闭。如果它是用 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明的词法范围变量，则通常意味着封闭范围的结尾。但是，此自动关闭不会检查错误，因此最好显式关闭文件句柄，尤其是用于写入的文件句柄：</target>
        </trans-unit>
        <trans-unit id="f157c14e0e96a0cb19a8e1a0df5c9ee87ca4b5e2" translate="yes" xml:space="preserve">
          <source>The filehandles STDIN, STDOUT, and STDERR are predefined. (The filehandles &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , and &lt;code&gt;stderr&lt;/code&gt; will also work except in packages, where they would be interpreted as local identifiers rather than global.) Additional filehandles may be created with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function, amongst others. See &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; and &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for details on this.</source>
          <target state="translated">文件句柄STDIN，STDOUT和STDERR是预定义的。（除了包中的文件句柄 &lt;code&gt;stdin&lt;/code&gt; ， &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 还将起作用，在软件包中，它们将被解释为本地标识符而不是全局标识符。）可以使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 函数创建其他文件句柄。参见&lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;并&lt;a href=&quot;functions/open&quot;&gt;打开&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="dabead5f141fbdd7cbaf6b6ee9ed1c9d5ac4b10f" translate="yes" xml:space="preserve">
          <source>The filehandles STDIN, STDOUT, and STDERR are predefined. (The filehandles &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, and &lt;code&gt;stderr&lt;/code&gt; will also work except in packages, where they would be interpreted as local identifiers rather than global.) Additional filehandles may be created with the &lt;code&gt;open()&lt;/code&gt; function, amongst others. See &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; and &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; for details on this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="586bcd238ccd4b9fecd344d54e37e9531bdb9cd2" translate="yes" xml:space="preserve">
          <source>The filehandles may also be integers, in which case they are understood as file descriptors.</source>
          <target state="translated">文件柄也可以是整数,在这种情况下,它们被理解为文件描述符。</target>
        </trans-unit>
        <trans-unit id="66a7978092f9f45d843d817f4a627ae3fdb00a8b" translate="yes" xml:space="preserve">
          <source>The filename of the data store holding the data that App::Prove::State reads.</source>
          <target state="translated">持有App::Prove::State读取的数据的数据存储的文件名。</target>
        </trans-unit>
        <trans-unit id="6d594502076d5702a51ff03f260fd4c765a898ae" translate="yes" xml:space="preserve">
          <source>The filename of the perllibrary that will be used together with this extension. Defaults to libperl.a.</source>
          <target state="translated">与此扩展名一起使用的 perllibrary 的文件名。默认为libperl.a。</target>
        </trans-unit>
        <trans-unit id="76201dda41fb8f7d14160ae0f46e9ddf9f7d7f60" translate="yes" xml:space="preserve">
          <source>The filename passed to the one- and two-argument forms of &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will have leading and trailing whitespace deleted and normal redirection characters honored. This property, known as &quot;magic open&quot;, can often be used to good effect. A user could specify a filename of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b0656face1bd799f2d3aeeb4a33e8ccdb99fbf" translate="yes" xml:space="preserve">
          <source>The filename passed to the one- and two-argument forms of open() will have leading and trailing whitespace deleted and normal redirection characters honored. This property, known as &quot;magic open&quot;, can often be used to good effect. A user could specify a filename of</source>
          <target state="translated">传递给open()的单参数和双参数形式的文件名将删除前导空格和后导空格,并保留正常的重定向字符。这个属性,被称为 &quot;神奇的打开&quot;,经常被用来达到良好的效果。用户可以指定一个文件名为</target>
        </trans-unit>
        <trans-unit id="6d720ff4e8b207a8fa86d2d1f6ed053fe36cb247" translate="yes" xml:space="preserve">
          <source>The files</source>
          <target state="translated">文件</target>
        </trans-unit>
        <trans-unit id="5e8ac4ea16fdec255bb3d994323e38344f15cd1a" translate="yes" xml:space="preserve">
          <source>The files in the &quot;qnx&quot; directory are:</source>
          <target state="translated">&quot;qnx &quot;目录下的文件有:</target>
        </trans-unit>
        <trans-unit id="ccf1a34f9c5304eccd7056360fe19cfcc880dfc0" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither access timestamp nor change timestamp (meaning that about the only portable timestamp is the modification timestamp), or one second granularity of any timestamps (e.g. the FAT filesystem limits the time granularity to two seconds).</source>
          <target state="translated">文件系统可能既不支持访问时间戳,也不支持更改时间戳(也就是说,大约只有修改时间戳才是可移植的时间戳),或者支持一秒粒度的任何时间戳(例如FAT文件系统将时间粒度限制为两秒)。</target>
        </trans-unit>
        <trans-unit id="9640e3801c8da6fb8d4c4212946957e9fbfe8dbf" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither hard links (&lt;a href=&quot;perlfunc#link-OLDFILE%2CNEWFILE&quot;&gt;&lt;code&gt;link&lt;/code&gt;&lt;/a&gt;) nor symbolic links (&lt;a href=&quot;perlfunc#symlink-OLDFILE%2CNEWFILE&quot;&gt;&lt;code&gt;symlink&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#readlink-EXPR&quot;&gt;&lt;code&gt;readlink&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4acc2f4b822151bd730e57f84d225c79d062f507" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither hard links (&lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt;) nor symbolic links (&lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">文件系统可能既不支持硬链接（ &lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; ），也不支持符号链接（ &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="15629c3f6edb637003db8544e5aa317bc95e5e82" translate="yes" xml:space="preserve">
          <source>The filesystem of Symbian devices uses DOSish syntax, &quot;drives&quot; separated from paths by a colon, and backslashes for the path. The exact assignment of the drives probably varies between platforms, but for example in Series 60 you might see C: as the (flash) main memory, D: as the RAM drive, E: as the memory card (MMC), Z: as the ROM. In Series 80 D: is the memory card. As far the devices go the NUL: is the bit bucket, the COMx: are the serial lines, IRCOMx: are the IR ports, TMP: might be C:\System\Temp. Remember to double those backslashes in doublequoted strings.</source>
          <target state="translated">Symbian设备的文件系统使用DOS式语法,&quot;驱动器 &quot;与路径之间用冒号隔开,路径用反斜杠表示。驱动器的具体分配可能在不同的平台上有所不同,但例如在60系列中,你可能会看到C:作为(闪存)主存储器,D:作为RAM驱动器,E:作为存储卡(MMC),Z:作为ROM。在80系列中,D:是存储卡。至于设备中的NUL:是位桶,COMx:是串行线,IRCOMx:是红外端口,TMP:可能是C:\SystemTemp。记得在双引号的字符串中,这些反斜杠要双倍。</target>
        </trans-unit>
        <trans-unit id="60abfd860ab77072c0ffed33f686231d933f221b" translate="yes" xml:space="preserve">
          <source>The filetest operators &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are not implemented, as they require more information than just a stat buffer.</source>
          <target state="translated">未执行文件测试运算符 &lt;code&gt;-t&lt;/code&gt; ， &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; ，因为它们需要更多信息，而不仅仅是stat缓冲区。</target>
        </trans-unit>
        <trans-unit id="2f0292fee7197d3e8ac530c889c496fd989569af" translate="yes" xml:space="preserve">
          <source>The filetest operators &lt;code&gt;-t&lt;/code&gt;, &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are not implemented, as they require more information than just a stat buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32f19af093b1f7fb24c634263035e297b5a2ba3" translate="yes" xml:space="preserve">
          <source>The filter ensures that Perl parses the code between the &amp;lt;DEBUG_BEGIN&amp;gt; and &lt;code&gt;DEBUG_END&lt;/code&gt; markers only when the &lt;code&gt;DEBUG&lt;/code&gt; environment variable exists. That means that when &lt;code&gt;DEBUG&lt;/code&gt; does exist, the code above should be passed through the filter unchanged. The marker lines can also be passed through as-is, because the Perl parser will see them as comment lines. When &lt;code&gt;DEBUG&lt;/code&gt; isn't set, we need a way to disable the debug code. A simple way to achieve that is to convert the lines between the two markers into comments:</source>
          <target state="translated">过滤器确保仅当存在 &lt;code&gt;DEBUG&lt;/code&gt; 环境变量时，Perl才能解析&amp;lt;DEBUG_BEGIN&amp;gt;和 &lt;code&gt;DEBUG_END&lt;/code&gt; 标记之间的代码。这意味着当确实存在 &lt;code&gt;DEBUG&lt;/code&gt; 时，上面的代码应不更改地通过过滤器。标记行也可以按原样传递，因为Perl解析器会将其视为注释行。当未设置 &lt;code&gt;DEBUG&lt;/code&gt; 时，我们需要一种禁用调试代码的方法。一种简单的实现方法是将两个标记之间的线转换为注释：</target>
        </trans-unit>
        <trans-unit id="3cfa6a6fd2754ac19a694b001066c8361c789aec" translate="yes" xml:space="preserve">
          <source>The filter included are:</source>
          <target state="translated">包括的过滤器有:</target>
        </trans-unit>
        <trans-unit id="06dac022e678c85372a6fa4a8e6e10c155086a90" translate="yes" xml:space="preserve">
          <source>The filter is applied to</source>
          <target state="translated">该过滤器适用于</target>
        </trans-unit>
        <trans-unit id="6311b9692024a04fd6e913eb59f189ec85a241cf" translate="yes" xml:space="preserve">
          <source>The filter is applied to the key</source>
          <target state="translated">滤波器被应用到键</target>
        </trans-unit>
        <trans-unit id="edd6196707ee8763311d3aafd47d83821af190dd" translate="yes" xml:space="preserve">
          <source>The filter is applied to the value</source>
          <target state="translated">滤波器被应用于</target>
        </trans-unit>
        <trans-unit id="6693f0e2b9229e67ead2ac6746c8771a8ed55fa9" translate="yes" xml:space="preserve">
          <source>The final &lt;code&gt;PUTBACK&lt;/code&gt; is used to leave the Perl stack in a consistent state before exiting the function. This is necessary because when we popped the return value from the stack with &lt;code&gt;POPi&lt;/code&gt; it updated only our local copy of the stack pointer. Remember, &lt;code&gt;PUTBACK&lt;/code&gt; sets the global stack pointer to be the same as our local copy.</source>
          <target state="translated">最终的 &lt;code&gt;PUTBACK&lt;/code&gt; 用于在退出函数之前使Perl堆栈保持一致状态。这是必要的，因为当我们使用 &lt;code&gt;POPi&lt;/code&gt; 从堆栈中弹出返回值时，它仅更新了堆栈指针的本地副本。请记住， &lt;code&gt;PUTBACK&lt;/code&gt; 将全局堆栈指针设置为与本地副本相同。</target>
        </trans-unit>
        <trans-unit id="6d574089f345d41e6ac1476fc2b80885aa410f07" translate="yes" xml:space="preserve">
          <source>The final character can't be a hyphen, colon, or period. URLs ending with these characters, while allowed by XHTML, can be awkward to extract from plain text.</source>
          <target state="translated">最后一个字符不能是连字符、冒号或句号。以这些字符结尾的URL,虽然XHTML允许,但从纯文本中提取会很麻烦。</target>
        </trans-unit>
        <trans-unit id="0a99e11f3a928dd6413c811829c3b9af3764501f" translate="yes" xml:space="preserve">
          <source>The final difference between regular bracketed character classes and these, is that it is not possible to get these to match a multi-character fold. Thus,</source>
          <target state="translated">常规括号内的字符类与这些的最后区别,就是无法让这些字符与多字符折合。因此。</target>
        </trans-unit>
        <trans-unit id="cde87782285bb08650f77bdd2e4ce0e06adc25ff" translate="yes" xml:space="preserve">
          <source>The final element of a list assignment may be an array or a hash:</source>
          <target state="translated">列表赋值的最后一个元素可以是一个数组或哈希。</target>
        </trans-unit>
        <trans-unit id="bee7b4f4630bbb2daf491aa012bc945e164b3e70" translate="yes" xml:space="preserve">
          <source>The final example shows that the characters &lt;code&gt;&quot;{&quot;&lt;/code&gt; and &lt;code&gt;&quot;}&quot;&lt;/code&gt; are metacharacters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74663d384e88ec12c85ff6a9f4b23592b8a3858" translate="yes" xml:space="preserve">
          <source>The final line (with Index [242]) means that the value for all code points above the legal Unicode maximum code point have the value &quot;No_Block&quot;, which is the term Unicode uses for a non-existing block.</source>
          <target state="translated">最后一行(带索引[242])的意思是,所有超过Unicode法定最大码点的码点的值都有 &quot;No_Block&quot;,这是Unicode用来表示不存在的块的术语。</target>
        </trans-unit>
        <trans-unit id="e6811c076957053b2764757de731f2de38b4111a" translate="yes" xml:space="preserve">
          <source>The final operation uses the backslash character to invalidate the special meaning of an open square bracket &lt;code&gt;[&lt;/code&gt;, the asterisk, backslash or the question mark. Two backslashes in sequence will result in the evaluation of the backslash as a character with no special meaning.</source>
          <target state="translated">最后的操作使用反斜杠字符使方括号 &lt;code&gt;[&lt;/code&gt; ，星号，反斜杠或问号] 的特殊含义无效。顺序两个反斜杠将导致反斜杠作为没有特殊含义的字符进行评估。</target>
        </trans-unit>
        <trans-unit id="be0c78c80ebce8da51fa36633d30ae64f567f49f" translate="yes" xml:space="preserve">
          <source>The final semicolon in a block is optional, as is the final comma in a list. Good style (see &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;) says to put them in except for one-liners:</source>
          <target state="translated">块中的最后一个分号是可选的，列表中的最后一个逗号也是可选的。好的样式（请参阅&lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;）表示将它们放入，但单线除外：</target>
        </trans-unit>
        <trans-unit id="16f205f9e57e8503952af3471732d873e8a9fc93" translate="yes" xml:space="preserve">
          <source>The final semicolon, if any, may be omitted from the value of EXPR or within the BLOCK.</source>
          <target state="translated">如果有分号,最后的分号可以从EXPR的值中省略,也可以在BLOCK中省略。</target>
        </trans-unit>
        <trans-unit id="701bfb8c787a64e7b1b253a3f8fa1a79c79b9b4d" translate="yes" xml:space="preserve">
          <source>The final semicolon, if any, may be omitted from the value of EXPR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f49a63a6bf839dcb9a9ccbe0a34339c52904e4c" translate="yes" xml:space="preserve">
          <source>The final semicolon, if any, may be omitted from within the BLOCK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee4566a0600358ccd1fe8d6c5a93a6cd48a9d99" translate="yes" xml:space="preserve">
          <source>The final stage is to call &lt;code&gt;test_test&lt;/code&gt; that will simply compare what you predeclared to what &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; actually outputted, and report the results back with a &quot;ok&quot; or &quot;not ok&quot; (with debugging) to the normal output.</source>
          <target state="translated">最后 &lt;code&gt;test_test&lt;/code&gt; 是调用test_test，它将简单地将您预先声明的内容与&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;实际输出的内容进行比较，然后将结果以&amp;ldquo; ok&amp;rdquo;或&amp;ldquo; not ok&amp;rdquo;（通过调试）报告给正常输出。</target>
        </trans-unit>
        <trans-unit id="a77ba1afa8fadab31ac1c8125c1a4cf3b74fcb5e" translate="yes" xml:space="preserve">
          <source>The final stage is to call &lt;code&gt;test_test&lt;/code&gt; that will simply compare what you predeclared to what &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; actually outputted, and report the results back with a &quot;ok&quot; or &quot;not ok&quot; (with debugging) to the normal output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31473d1a074747714a49e0fc3e7edd46729c2ea4" translate="yes" xml:space="preserve">
          <source>The final step involves passing each filename matched by the &lt;code&gt;*.tar.gz&lt;/code&gt; file glob through the derived Perl regular expression in turn and expanding the output fileglob using it.</source>
          <target state="translated">最后一步包括依次将每个与 &lt;code&gt;*.tar.gz&lt;/code&gt; 文件glob 匹配的文件名传递给派生的Perl正则表达式，并使用它扩展输出fileglob。</target>
        </trans-unit>
        <trans-unit id="d96d9b1e4edc6c2a13a6362b88a7c6a709b1d43c" translate="yes" xml:space="preserve">
          <source>The final two modifiers we will discuss here, &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;//c&lt;/code&gt; , concern multiple matches. The modifier &lt;code&gt;//g&lt;/code&gt; stands for global matching and allows the matching operator to match within a string as many times as possible. In scalar context, successive invocations against a string will have &lt;code&gt;//g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">我们将在这里讨论的最后两个修饰符 &lt;code&gt;//g&lt;/code&gt; 和 &lt;code&gt;//c&lt;/code&gt; 涉及多个匹配项。修饰符 &lt;code&gt;//g&lt;/code&gt; 表示全局匹配，它允许匹配运算符在一个字符串内尽可能多地匹配。在标量上下文中，对字符串的连续调用将在匹配之间跳转 &lt;code&gt;//g&lt;/code&gt; ，从而跟踪字符串在字符串中的位置。您可以使用 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 函数获取或设置位置。</target>
        </trans-unit>
        <trans-unit id="789fdded843f5a388c6234d5037a293bfbacec0d" translate="yes" xml:space="preserve">
          <source>The final two modifiers we will discuss here, &lt;code&gt;/g&lt;/code&gt; and &lt;code&gt;/c&lt;/code&gt;, concern multiple matches. The modifier &lt;code&gt;/g&lt;/code&gt; stands for global matching and allows the matching operator to match within a string as many times as possible. In scalar context, successive invocations against a string will have &lt;code&gt;/g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;pos()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68bb0429a21250927b8f2328dd69f3ab3c62b7fa" translate="yes" xml:space="preserve">
          <source>The final, fourth element (index [3], assigned to &lt;code&gt;$default&lt;/code&gt; in the &quot;block&quot; example) in the four element list returned by this function is used with the &lt;code&gt;&quot;a&quot;&lt;/code&gt; format types; it may also be useful for applications that wish to convert the returned inversion map data structure into some other, such as a hash. It gives the mapping that most code points map to under the property. If you establish the convention that any code point not explicitly listed in your data structure maps to this value, you can potentially make your data structure much smaller. As you construct your data structure from the one returned by this function, simply ignore those ranges that map to this value. For example, to convert to the data structure searchable by &lt;a href=&quot;#charinrange%28%29&quot;&gt;&quot;charinrange()&quot;&lt;/a&gt;, you can follow this recipe for properties that don't require adjustments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b0c89da94c5764d6322358005c665b7a6ec505" translate="yes" xml:space="preserve">
          <source>The final, fourth element (index [3], assigned to &lt;code&gt;$default&lt;/code&gt; in the &quot;block&quot; example) in the four element list returned by this function is used with the &lt;code&gt;&quot;a&quot;&lt;/code&gt; format types; it may also be useful for applications that wish to convert the returned inversion map data structure into some other, such as a hash. It gives the mapping that most code points map to under the property. If you establish the convention that any code point not explicitly listed in your data structure maps to this value, you can potentially make your data structure much smaller. As you construct your data structure from the one returned by this function, simply ignore those ranges that map to this value. For example, to convert to the data structure searchable by &lt;a href=&quot;#charinrange()&quot;&gt;charinrange()&lt;/a&gt;, you can follow this recipe for properties that don't require adjustments:</source>
          <target state="translated">此函数返回的四元素列表中的最后一个第四元素（在[ block]示例中分配给 &lt;code&gt;$default&lt;/code&gt; 索引[3] ）与 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 格式类型一起使用；对于希望将返回的反转映射数据结构转换为其他值（例如哈希）的应用程序，它可能也很有用。它在属性下提供了大多数代码点映射到的映射。如果您建立了约定，即未在数据结构中明确列出的任何代码点都映射到该值，则有可能使数据结构更小。从此函数返回的数据结构构造数据结构时，只需忽略那些映射到该值的范围。例如，转换为&lt;a href=&quot;#charinrange()&quot;&gt;charinrange（）&lt;/a&gt;可搜索的数据结构，对于不需要调整的属性，可以遵循以下食谱：</target>
        </trans-unit>
        <trans-unit id="20c1b5c18477e5291b6b00c55abb0e8a3b781429" translate="yes" xml:space="preserve">
          <source>The find_dup() Method</source>
          <target state="translated">find_dup()方法</target>
        </trans-unit>
        <trans-unit id="a4105f4f4646c65f036c1e5edea46eddb3a8418a" translate="yes" xml:space="preserve">
          <source>The first (and now failed) goal of Unicode was to map all character repertoires into a fixed-length integer so that programmers are happy. Since each character is either a</source>
          <target state="translated">Unicode的第一个(现在已经失败了)目标是将所有字符集映射成一个固定长度的整数,这样程序员就会很高兴。由于每个字符要么是一个</target>
        </trans-unit>
        <trans-unit id="172226a1c7ce5a6d06797585142c70179c0ec58b" translate="yes" xml:space="preserve">
          <source>The first &lt;b&gt;PAUSE&lt;/b&gt; author to upload a &lt;b&gt;namespace&lt;/b&gt; automatically becomes the &lt;b&gt;primary maintainer&lt;/b&gt; for that namespace. The &amp;ldquo;first come&amp;rdquo; permissions distinguish a &lt;b&gt;primary maintainer&lt;/b&gt; who was assigned that role from one who received it automatically.</source>
          <target state="translated">第一个上载&lt;b&gt;名称空间的&lt;/b&gt;&lt;b&gt;PAUSE&lt;/b&gt;作者自动成为该&lt;b&gt;名称空间&lt;/b&gt;的&lt;b&gt;主要维护者&lt;/b&gt;。&amp;ldquo;先来者&amp;rdquo;权限将分配了该角色的&lt;b&gt;主要维护者&lt;/b&gt;与自动接收该角色的&lt;b&gt;主要维护者&lt;/b&gt;区分开。</target>
        </trans-unit>
        <trans-unit id="97526a10437e54c9f14361d8f57177e27604beab" translate="yes" xml:space="preserve">
          <source>The first Perl argument to this function would be treated as a char and assigned to the variable a, and its address would be passed into the function foo. The second Perl argument would be treated as a string pointer and assigned to the variable b. The</source>
          <target state="translated">这个函数的第一个Perl参数将被视为一个char,并分配给变量a,它的地址将被传递给函数foo。第二个Perl参数将被视为字符串指针并分配给变量b。</target>
        </trans-unit>
        <trans-unit id="c3453154bc2cd37e63c9b0f3f784faca750ac354" translate="yes" xml:space="preserve">
          <source>The first alternative includes everything from the last pattern delimiter (&lt;code&gt;&quot;(&quot;&lt;/code&gt;, &lt;code&gt;&quot;(?:&quot;&lt;/code&gt; (described later),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e4f6464deede9ad4eff50e6de5039522d07e08" translate="yes" xml:space="preserve">
          <source>The first and second arguments may be strings, typeglobs, typeglob references, or objects inheriting from IO::Handle; they are used in all cases to obtain the</source>
          <target state="translated">第一个和第二个参数可以是字符串、tyeglobs、tyeglob引用或继承自IO::Handle的对象;在所有情况下,它们都被用来获取</target>
        </trans-unit>
        <trans-unit id="f11ee434e9fca49f11d7860f46bcba7e793d3dea" translate="yes" xml:space="preserve">
          <source>The first and second forms explicitly identify the name of the class being created. The third form assumes the current package name as the class name.</source>
          <target state="translated">第一和第二种形式明确标识了正在创建的类的名称。第三种形式将当前的包名作为类名。</target>
        </trans-unit>
        <trans-unit id="1490a2bc188cd4f0f1d7d40df76c523f30ba9b64" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;pointer&lt;/code&gt; should be the name of a variable that will point to the newly allocated memory.</source>
          <target state="translated">第一个参数 &lt;code&gt;pointer&lt;/code&gt; 应该是将指向新分配的内存的变量的名称。</target>
        </trans-unit>
        <trans-unit id="80c48ff540490ea5dad5fc5e056d6677cb16264e" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;setlocale()&lt;/code&gt; gives the &lt;b&gt;category&lt;/b&gt;, the second the &lt;b&gt;locale&lt;/b&gt;. The category tells in what aspect of data processing you want to apply locale-specific rules. Category names are discussed in &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;&quot;LOCALE CATEGORIES&quot;&lt;/a&gt; and &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt;. The locale is the name of a collection of customization information corresponding to a particular combination of language, country or territory, and codeset. Read on for hints on the naming of locales: not all systems name locales as in the example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f43aa625d664f2ba3718ef0a1149ca5df8580dd" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;setlocale()&lt;/code&gt; gives the &lt;b&gt;category&lt;/b&gt;, the second the &lt;b&gt;locale&lt;/b&gt;. The category tells in what aspect of data processing you want to apply locale-specific rules. Category names are discussed in &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/a&gt; and &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;. The locale is the name of a collection of customization information corresponding to a particular combination of language, country or territory, and codeset. Read on for hints on the naming of locales: not all systems name locales as in the example.</source>
          <target state="translated">&lt;code&gt;setlocale()&lt;/code&gt; 的第一个参数给出&lt;b&gt;类别&lt;/b&gt;，第二个参数给出&lt;b&gt;locale&lt;/b&gt;。类别告诉您要在数据处理的哪个方面应用特定于语言环境的规则。类别名称在&amp;ldquo; &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;本地类别&lt;/a&gt;和&lt;a href=&quot;#ENVIRONMENT&quot;&gt;环境&amp;rdquo;中&lt;/a&gt;进行了讨论。语言环境是与语言，国家或地区和代码集的特定组合相对应的定制信息集合的名称。请继续阅读以获取有关语言环境命名的提示：并非所有系统都像示例中那样命名语言环境。</target>
        </trans-unit>
        <trans-unit id="fede859d91b131301182a8f517e78fcd79928ade" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;find()&lt;/code&gt; is either a code reference to your &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function, or a hash reference describing the operations to be performed for each file. The code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;&quot;The wanted function&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7b3a91ac2b665d00253c60dfd683fd8e3981ca" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;find()&lt;/code&gt; is either a code reference to your &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function, or a hash reference describing the operations to be performed for each file. The code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;The wanted function&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;find()&lt;/code&gt; 的第一个参数要么是对 &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 函数的代码引用，要么是描述每个文件要执行的操作的哈希引用。下面的&lt;a href=&quot;#The-wanted-function&quot;&gt;&amp;ldquo;所需功能&amp;rdquo;&lt;/a&gt;中介绍了代码参考。</target>
        </trans-unit>
        <trans-unit id="7c957468bac2255084a035a3220d83572a45006f" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;open&lt;/code&gt;, labeled FILEHANDLE in this reference, is usually a scalar variable. (Exceptions exist, described in &quot;Other considerations&quot;, below.) If the call to &lt;code&gt;open&lt;/code&gt; succeeds, then the expression provided as FILEHANDLE will get assigned an open</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cbf5c859ede86efd02d67b5ed562cbefaa9fa86" translate="yes" xml:space="preserve">
          <source>The first call creates a mortal SV (with no value), the second converts an existing SV to a mortal SV (and thus defers a call to &lt;code&gt;SvREFCNT_dec&lt;/code&gt; ), and the third creates a mortal copy of an existing SV. Because &lt;code&gt;sv_newmortal&lt;/code&gt; gives the new SV no value, it must normally be given one via &lt;code&gt;sv_setpv&lt;/code&gt; , &lt;code&gt;sv_setiv&lt;/code&gt; , etc. :</source>
          <target state="translated">第一个调用创建一个普通SV（无值），第二个调用将现有SV转换为普通SV（从而推迟对 &lt;code&gt;SvREFCNT_dec&lt;/code&gt; 的调用），第三个调用创建现有SV的普通副本。因为 &lt;code&gt;sv_newmortal&lt;/code&gt; 没有给新的SV值，所以通常必须通过 &lt;code&gt;sv_setpv&lt;/code&gt; ， &lt;code&gt;sv_setiv&lt;/code&gt; 等给它一个值：</target>
        </trans-unit>
        <trans-unit id="4477498f36568777dd7d39a288f8eb78c180c0b5" translate="yes" xml:space="preserve">
          <source>The first call will cache the result, say 37, in the scalar cache; the second will cach the list &lt;code&gt;(37)&lt;/code&gt; in the list cache. The third call doesn't call the real &lt;code&gt;complicated&lt;/code&gt; function; it gets the value 37 from the scalar cache.</source>
          <target state="translated">第一次调用会将结果（例如37）缓存在标量缓存中；第二个将缓存列表缓存中的列表 &lt;code&gt;(37)&lt;/code&gt; 。第三次调用不调用真正的 &lt;code&gt;complicated&lt;/code&gt; 函数；它从标量缓存中获取值37。</target>
        </trans-unit>
        <trans-unit id="cb2fb10ae2990b48a149ecb6c3ef672018aecbe1" translate="yes" xml:space="preserve">
          <source>The first call-back registered is the call back for waiting. It is expected that the callback will call the current event loop until there is something waiting to get on the input filehandle. The parameter passed in is the return value of the second call back.</source>
          <target state="translated">注册的第一个回调是等待的回调。预计该回调将调用当前的事件循环,直到在输入的文件handle上有等待得到的东西。传入的参数是第二个回调的返回值。</target>
        </trans-unit>
        <trans-unit id="356bc7c1108ec743988bf0e03b81bb507c0cc12b" translate="yes" xml:space="preserve">
          <source>The first code point of the foldcased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e0061b9a6b011cebcff05349c5ac1b63fa9755" translate="yes" xml:space="preserve">
          <source>The first code point of the foldcased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">折叠版本的第一个代码点被返回(但请注意,正如上面所解释的,可能有更多的代码点)。</target>
        </trans-unit>
        <trans-unit id="f94f6bc950fffc56630abef7e060753be71264b0" translate="yes" xml:space="preserve">
          <source>The first code point of the lowercased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e520b61d264ebe77754743fca0b946c106ddd342" translate="yes" xml:space="preserve">
          <source>The first code point of the lowercased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more). It will not attempt to read beyond &lt;code&gt;e - 1&lt;/code&gt;, provided that the constraint &lt;code&gt;s &amp;lt; e&lt;/code&gt; is true (this is asserted for in &lt;code&gt;-DDEBUGGING&lt;/code&gt; builds). If the UTF-8 for the input character is malformed in some way, the program may croak, or the function may return the REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to change in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff810cbc1a30c3df94411ded7219d0513e8678c" translate="yes" xml:space="preserve">
          <source>The first code point of the lowercased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">返回小写版本的第一个代码点(但请注意,如上所述,可能有更多的代码点)。</target>
        </trans-unit>
        <trans-unit id="d7f11b85b3fd5fa2f0a6c5645eeff96adc2054e0" translate="yes" xml:space="preserve">
          <source>The first code point of the titlecased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caeb3f58f789aa5ac3e09cf711fff7133bd0293e" translate="yes" xml:space="preserve">
          <source>The first code point of the titlecased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">返回titlecased版本的第一个代码点(但请注意,如上所述,可能会有更多。</target>
        </trans-unit>
        <trans-unit id="3acdfbd051e586c1763fcef89bd42028b50c7068" translate="yes" xml:space="preserve">
          <source>The first code point of the uppercased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa79c84ba894862a3bdfa5a898231ba1c669dc5c" translate="yes" xml:space="preserve">
          <source>The first code point of the uppercased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150061371074e1d388cb756c8513ea3bae095580" translate="yes" xml:space="preserve">
          <source>The first code point of the uppercased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">返回大写版本的第一个代码点(但请注意,如上所述,可能会有更多的代码点)。</target>
        </trans-unit>
        <trans-unit id="b31a69e396cbea336ac162c9e038d50204a60559" translate="yes" xml:space="preserve">
          <source>The first column gives the Unicode code point of the character (in hex format), the second column gives the (Unicode) name. The third column indicates by which class(es) the character is matched (assuming no locale is in effect that changes the &lt;code&gt;\s&lt;/code&gt; matching).</source>
          <target state="translated">第一列给出了字符的Unicode代码点（以十六进制格式），第二列给出了（Unicode）名称。第三列表示匹配字符的类别（假定没有有效的语言环境会更改 &lt;code&gt;\s&lt;/code&gt; 匹配）。</target>
        </trans-unit>
        <trans-unit id="8beadb10ab71cda6dd02fa1a65287381a215cc85" translate="yes" xml:space="preserve">
          <source>The first column in the table is a name for the property; the second column is an alternative name, if any, plus possibly some annotations. The alternative name is the property's full name, unless that would simply repeat the first column, in which case the second column indicates the property's short name (if different). The annotations are given only in the entry for the full name. If a property is obsolete, etc, the entry will be flagged with the same characters used in the table in the &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;section above&lt;/a&gt;, like &lt;b&gt;D&lt;/b&gt; or &lt;b&gt;S&lt;/b&gt;.</source>
          <target state="translated">表中的第一列是属性的名称；第二列是备用名称（如果有的话）以及可能的一些注释。替代名称是属性的全名，除非那会简单地重复第一列，在这种情况下，第二列表示属性的简称（如果不同）。注释仅在全名条目中给出。如果属性是过时的，等等，该条目将与在表中使用的相同的字符进行标记&lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;上面的部分&lt;/a&gt;，象&lt;b&gt;d&lt;/b&gt;或&lt;b&gt;小号&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="0a9e1d7bc901ecffb197db410cd69bf5871b1113" translate="yes" xml:space="preserve">
          <source>The first column in the table is a name for the property; the second column is an alternative name, if any, plus possibly some annotations. The alternative name is the property's full name, unless that would simply repeat the first column, in which case the second column indicates the property's short name (if different). The annotations are given only in the entry for the full name. The annotations for binary properties include a list of the first few ranges that the property matches. To avoid any ambiguity, the SPACE character is represented as &lt;code&gt;\x20&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eff62aa7ff2adaee41faf8fb6df470068a01954" translate="yes" xml:space="preserve">
          <source>The first column is a set of flags, the second column the return type, the third column the name. Columns after that are the arguments. The flags are documented at the top of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b11168c63a090c6a2f9c94f928cd13ec49996f7" translate="yes" xml:space="preserve">
          <source>The first command sends both standard out and standard error to the temporary file. The second command sends only the old standard output there, and the old standard error shows up on the old standard out.</source>
          <target state="translated">第一条命令将标准输出和标准错误都发送到临时文件中。第二条命令只将旧的标准输出发送到那里,而旧的标准错误则显示在旧的标准输出上。</target>
        </trans-unit>
        <trans-unit id="05c623db7c7d3a79e0f86ce6c1022ffde1e91677" translate="yes" xml:space="preserve">
          <source>The first element of @os_flavor is the major family (ie. Unix, Windows, VMS, OS/2, etc...) and the rest are sub families.</source>
          <target state="translated">@os_flavor的第一个元素是主要家族(即Unix、Windows、VMS、OS/2等),其余为子家族。</target>
        </trans-unit>
        <trans-unit id="bf7e5d87f2410537daa86408c9c3f1321c88ab2f" translate="yes" xml:space="preserve">
          <source>The first entry in the string will run all tests in the top-level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b34621cb98b9f5d1895e9bf56ac10c10fa486de" translate="yes" xml:space="preserve">
          <source>The first example will be driven by an object of the class CPAN::Module, the second by an object of class CPAN::Distribution.</source>
          <target state="translated">第一个例子将由CPAN::Module类的对象驱动,第二个例子由CPAN::Distribution类的对象驱动。</target>
        </trans-unit>
        <trans-unit id="0a27c7509a2d370dd780c83c9db9ebfcd9028447" translate="yes" xml:space="preserve">
          <source>The first extension is an embedded comment &lt;code&gt;(?#text)&lt;/code&gt;. This embeds a comment into the regular expression without affecting its meaning. The comment should not have any closing parentheses in the text. An example is</source>
          <target state="translated">第一个扩展是嵌入式注释 &lt;code&gt;(?#text)&lt;/code&gt; 。这会将注释嵌入到正则表达式中，而不会影响其含义。注释的文本中不应包含任何右括号。一个例子是</target>
        </trans-unit>
        <trans-unit id="222cb4b3d3e8dffe112445249bb168e941db04b2" translate="yes" xml:space="preserve">
          <source>The first extra instruction sets DJGPP's FNCASE environment variable so that the new perl binary which you must build for an XS-type module will build correctly. The second extra instruction re-builds the perl binary in your module directory before you run &quot;make test&quot;, so that you are testing with the new module code you built with &quot;make&quot;. The third extra instruction installs the perl binary from your module directory into the standard DJGPP binary directory, &lt;code&gt;($DJDIR)/bin&lt;/code&gt; , replacing your previous perl binary.</source>
          <target state="translated">第一条额外指令设置了DJGPP的FNCASE环境变量，以便您必须为XS类型的模块构建的新的perl二进制文件将正确构建。第二条额外的指令在运行&amp;ldquo; make test&amp;rdquo;之前在模块目录中重新构建perl二进制文件，以便使用由&amp;ldquo; make&amp;rdquo;构建的新模块代码进行测试。第三条额外的指令将perl二进制文件从模块目录安装到标准DJGPP二进制目录 &lt;code&gt;($DJDIR)/bin&lt;/code&gt; ，替换先前的perl二进制文件。</target>
        </trans-unit>
        <trans-unit id="238d815e97aa4aefd914191a6984e7eea1bebbe7" translate="yes" xml:space="preserve">
          <source>The first extra instruction sets DJGPP's FNCASE environment variable so that the new perl binary which you must build for an XS-type module will build correctly. The second extra instruction re-builds the perl binary in your module directory before you run &quot;make test&quot;, so that you are testing with the new module code you built with &quot;make&quot;. The third extra instruction installs the perl binary from your module directory into the standard DJGPP binary directory, &lt;code&gt;($DJDIR)/bin&lt;/code&gt;, replacing your previous perl binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae143bbfd14644c2528b32b8737fee2a5bff385" translate="yes" xml:space="preserve">
          <source>The first few lines tell you the modules that Net::FTP uses and their versions, this is useful data to me when a user reports a bug. The last seven lines show the communication with the server. Each line has three parts. The first part is the object itself, this is useful for separating the output if you are using multiple objects. The second part is either &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; to show data coming from the server or &lt;code&gt;&amp;amp;gt&amp;amp;gt&amp;amp;gt&amp;amp;gt&lt;/code&gt; to show data going to the server. The remainder of the line is the command being sent or response being received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b17d18688be07602898309d70943af3ccee567" translate="yes" xml:space="preserve">
          <source>The first few members of the struct give a function table size for compatibility check &quot;name&quot; for the layer, the size to &lt;code&gt;malloc&lt;/code&gt; for the per-instance data, and some flags which are attributes of the class as whole (such as whether it is a buffering layer), then follow the functions which fall into four basic groups:</source>
          <target state="translated">结构的前几个成员为层提供兼容性检查的功能表大小&amp;ldquo;名称&amp;rdquo;，针对每个实例数据的 &lt;code&gt;malloc&lt;/code&gt; 大小以及作为类整体属性的一些标志（例如是否为缓冲层），然后遵循分为四个基本组的功能：</target>
        </trans-unit>
        <trans-unit id="5570358324850dc9a5c098d989e656b82d59427c" translate="yes" xml:space="preserve">
          <source>The first five of these are like the escape sequences &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\F&lt;/code&gt; . For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;; For Foldcase, see &lt;a href=&quot;#Foldcase&quot;&gt;Foldcase&lt;/a&gt;.</source>
          <target state="translated">这些前五个就像是转义序列 &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\U&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; ，和 &lt;code&gt;\F&lt;/code&gt; 。有关Titlecase的信息，请参见&lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;。对于Foldcase，请参见&lt;a href=&quot;#Foldcase&quot;&gt;Foldcase&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="679923e26685f0bf8bfaf94ea7988b4c7276fdb8" translate="yes" xml:space="preserve">
          <source>The first five of these are like the escape sequences &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, and &lt;code&gt;\F&lt;/code&gt;. For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;&quot;Titlecase&quot;&lt;/a&gt;; For Foldcase, see &lt;a href=&quot;#Foldcase&quot;&gt;&quot;Foldcase&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056eb59b4cd627258e760e1417c53352badda0af" translate="yes" xml:space="preserve">
          <source>The first form causes the most-significant</source>
          <target state="translated">第一种形式造成最显著的。</target>
        </trans-unit>
        <trans-unit id="655fd20aca46eac1f13d92b5af802dc31b11d56c" translate="yes" xml:space="preserve">
          <source>The first form is used to request a</source>
          <target state="translated">第一张表格是用来申请</target>
        </trans-unit>
        <trans-unit id="37eddcbe0416a7dc5593d702e9505efc3b548dce" translate="yes" xml:space="preserve">
          <source>The first form lists all distribution files in and below an author's CPAN directory as stored in the CHECKSUMS files distributed on CPAN. The listing recurses into subdirectories.</source>
          <target state="translated">第一种形式列出了作者CPAN目录下的所有发行文件,这些文件存储在CPAN上发行的CHECKSUMS文件中。该列表循环到子目录中。</target>
        </trans-unit>
        <trans-unit id="46eae92ecd4f74796835635e06aeea1b041739b2" translate="yes" xml:space="preserve">
          <source>The first function calculates the length of the string to be appended by using &lt;code&gt;strlen&lt;/code&gt; . In the second, you specify the length of the string yourself. The third function processes its arguments like &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; and appends the formatted output. The fourth function works like &lt;code&gt;vsprintf&lt;/code&gt; . You can specify the address and length of an array of SVs instead of the va_list argument. The fifth function extends the string stored in the first SV with the string stored in the second SV. It also forces the second SV to be interpreted as a string.</source>
          <target state="translated">第一个函数使用 &lt;code&gt;strlen&lt;/code&gt; 计算要附加的字符串的长度。在第二个中，您自己指定字符串的长度。第三个函数处理其参数，如 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; ,并附加格式化的输出。第四个功能类似于 &lt;code&gt;vsprintf&lt;/code&gt; 。您可以指定SV数组的地址和长度，而不是va_list参数。第五功能用存储在第二SV中的字符串扩展存储在第一SV中的字符串。它还会强制将第二个SV解释为字符串。</target>
        </trans-unit>
        <trans-unit id="090b5d34cd572296fdf844e61d55479b085e6558" translate="yes" xml:space="preserve">
          <source>The first function calculates the length of the string to be appended by using &lt;code&gt;strlen&lt;/code&gt;. In the second, you specify the length of the string yourself. The third function processes its arguments like &lt;code&gt;sprintf&lt;/code&gt; and appends the formatted output. The fourth function works like &lt;code&gt;vsprintf&lt;/code&gt;. You can specify the address and length of an array of SVs instead of the va_list argument. The fifth function extends the string stored in the first SV with the string stored in the second SV. It also forces the second SV to be interpreted as a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f464748e3494ffffc2bddda9e0371a39740923" translate="yes" xml:space="preserve">
          <source>The first function takes a literal string, the second uses the string stored in the SV. Remember that a stash is just a hash table, so you get back an &lt;code&gt;HV*&lt;/code&gt; . The &lt;code&gt;flags&lt;/code&gt; flag will create a new package if it is set to GV_ADD.</source>
          <target state="translated">第一个函数使用文字字符串，第二个函数使用存储在SV中的字符串。请记住，存储只是一个哈希表，因此您将获得 &lt;code&gt;HV*&lt;/code&gt; 。如果将 &lt;code&gt;flags&lt;/code&gt; 标志设置为GV_ADD，它将创建一个新程序包。</target>
        </trans-unit>
        <trans-unit id="753de98607835382ac405aaaec94b8f9df443117" translate="yes" xml:space="preserve">
          <source>The first function takes a literal string, the second uses the string stored in the SV. Remember that a stash is just a hash table, so you get back an &lt;code&gt;HV*&lt;/code&gt;. The &lt;code&gt;flags&lt;/code&gt; flag will create a new package if it is set to GV_ADD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835ff098919bab433ee120cffa3fe9f71b92c1c9" translate="yes" xml:space="preserve">
          <source>The first gives data on bucket chain lengths and provides insight on how much work a fetch *miss* will take. In this case we have to inspect every item in a bucket before we can be sure the item is not in the list. The performance for an insert is equivalent to this case, as is a delete where the item is not in the hash.</source>
          <target state="translated">第一个给出了关于桶链长度的数据,并提供了关于取*漏的工作量的见解。在这种情况下,我们必须检查桶中的每一个项目,然后才能确定项目不在列表中。插入的性能等同于这种情况,项目不在哈希中的删除也是如此。</target>
        </trans-unit>
        <trans-unit id="44b1707c0aa3d824f6a27ecfef8a4304420287cd" translate="yes" xml:space="preserve">
          <source>The first interface is an object approach. &lt;code&gt;IO::Dir&lt;/code&gt; provides an object constructor and methods, which are just wrappers around perl's built in directory reading routines.</source>
          <target state="translated">第一个接口是一种对象方法。 &lt;code&gt;IO::Dir&lt;/code&gt; 提供了一个对象构造函数和方法，它们只是perl内置的目录读取例程的包装。</target>
        </trans-unit>
        <trans-unit id="f4941dd26bc8de71bda8bbde95f00b715fc9713b" translate="yes" xml:space="preserve">
          <source>The first is an asterisk &lt;code&gt;*&lt;/code&gt; to match any sequence of zero or more characters.</source>
          <target state="translated">第一个是星号 &lt;code&gt;*&lt;/code&gt; ,用于匹配零个或多个字符的任何序列。</target>
        </trans-unit>
        <trans-unit id="e06aed8ca3d744d52c854ac09d0dcc88676f13d3" translate="yes" xml:space="preserve">
          <source>The first is the '*' metacharacter. This will be replaced by the complete filename matched by the input file glob. So</source>
          <target state="translated">第一个是'*'元字符。这将被输入文件 glob 所匹配的完整文件名所取代。所以</target>
        </trans-unit>
        <trans-unit id="53f5cd295a83b9a3745b8897953b75db40666387" translate="yes" xml:space="preserve">
          <source>The first is the 'default' format, which is used in both basic and exec modes to print all opcodes. The 2nd, goto-format, is used in exec mode when branches are encountered. They're not real opcodes, and are inserted to look like a closing curly brace. The tree-format is tree specific.</source>
          <target state="translated">第一种是 &quot;默认 &quot;格式,在基本模式和执行模式下都用于打印所有操作码。第2种是goto-format,在执行模式中遇到分支时使用。它们并不是真正的操作码,而是被插入的,看起来像一个收尾的大括号。树格式是针对树的。</target>
        </trans-unit>
        <trans-unit id="32f6bb26a2f4ae1e809986ad78dbd60042fd1a3c" translate="yes" xml:space="preserve">
          <source>The first item is not fixable (except by upgrading to a later Visual Studio release), but it would be possible to work around the latter two items by using the Windows API functions &lt;code&gt;GetNumberFormat&lt;/code&gt; and &lt;code&gt;GetCurrencyFormat&lt;/code&gt;; patches welcome.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34237558f2321ff711f52a04588fb6ee8079ad92" translate="yes" xml:space="preserve">
          <source>The first line (with Index [0]) means that the value for code point 0 is &quot;Basic Latin&quot;. The entry &quot;0x0080&quot; in the @blocks_ranges column in the second line means that the value from the first line, &quot;Basic Latin&quot;, extends to all code points in the range from 0 up to but not including 0x0080, that is, through 127. In other words, the code points from 0 to 127 are all in the &quot;Basic Latin&quot; block. Similarly, all code points in the range from 0x0080 up to (but not including) 0x0100 are in the block named &quot;Latin-1 Supplement&quot;, etc. (Notice that the return is the old-style block names; see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style versus new-style block names&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40fe0d63874f53e08f9d51c255d101fe5f08a938" translate="yes" xml:space="preserve">
          <source>The first line (with Index [0]) means that the value for code point 0 is &quot;Basic Latin&quot;. The entry &quot;0x0080&quot; in the @blocks_ranges column in the second line means that the value from the first line, &quot;Basic Latin&quot;, extends to all code points in the range from 0 up to but not including 0x0080, that is, through 127. In other words, the code points from 0 to 127 are all in the &quot;Basic Latin&quot; block. Similarly, all code points in the range from 0x0080 up to (but not including) 0x0100 are in the block named &quot;Latin-1 Supplement&quot;, etc. (Notice that the return is the old-style block names; see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">第一行（索引为[0]）表示代码点0的值为&amp;ldquo;基本拉丁语&amp;rdquo;。第二行的@blocks_ranges列中的条目&amp;ldquo; 0x0080&amp;rdquo;表示第一行的值&amp;ldquo;基本拉丁语&amp;rdquo;扩展到从0到但不包括0x0080（即到127）的所有代码点换句话说，从0到127的代码点都在&amp;ldquo;基本拉丁语&amp;rdquo;块中。同样，从0x0080到（但不包括）0x0100范围内的所有代码点都在名为&amp;ldquo; Latin-1 Supplement&amp;rdquo;的块中，依此类推。（注意，返回的是旧样式的块名称；请参见&lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;旧样式与新样式的块名称&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0686c2b572c16f799b84765daa2d3e48250c69f7" translate="yes" xml:space="preserve">
          <source>The first line above defines &lt;code&gt;TIMESTAMP&lt;/code&gt; as a 9-element list, as returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; in list context. To set it to the string returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; in scalar context, an explicit &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; keyword is required.</source>
          <target state="translated">上面的第一行将 &lt;code&gt;TIMESTAMP&lt;/code&gt; 定义为由9个元素组成的列表，由 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 返回。要将其设置为标量上下文中 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 返回的字符串，需要一个显式的 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="69decd40a9a2c32528b6b5800434c2cba08678b1" translate="yes" xml:space="preserve">
          <source>The first line above defines &lt;code&gt;TIMESTAMP&lt;/code&gt; as a 9-element list, as returned by &lt;code&gt;localtime()&lt;/code&gt; in list context. To set it to the string returned by &lt;code&gt;localtime()&lt;/code&gt; in scalar context, an explicit &lt;code&gt;scalar&lt;/code&gt; keyword is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d82ab0cc733d5c69ba599aa083f54d41b0cd704" translate="yes" xml:space="preserve">
          <source>The first line ensures that the errors in your argument specification are found early. When you ship your application you should comment out the first line, since it makes the second one useless.</source>
          <target state="translated">第一行确保你的参数规范中的错误被尽早发现。当你发布你的应用程序时,你应该注释掉第一行,因为它使第二行毫无用处。</target>
        </trans-unit>
        <trans-unit id="1d816990178774f44d4b8769d3c845c853e30a87" translate="yes" xml:space="preserve">
          <source>The first line here indicates that the offset/length table contains 45 entries. Each entry is a pair of integers, denoted by &lt;code&gt;offset[&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;]&lt;/code&gt; . Entries are numbered starting with 1, so entry #1 here is &lt;code&gt;1[4]&lt;/code&gt; and entry #12 is &lt;code&gt;5[1]&lt;/code&gt; . &lt;code&gt;1[4]&lt;/code&gt; indicates that the node labeled &lt;code&gt;1:&lt;/code&gt; (the &lt;code&gt;1: ANYOF[bc]&lt;/code&gt;) begins at character position 1 in the pre-compiled form of the regex, and has a length of 4 characters. &lt;code&gt;5[1]&lt;/code&gt; in position 12 indicates that the node labeled &lt;code&gt;12:&lt;/code&gt; (the &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt;) begins at character position 5 in the pre-compiled form of the regex, and has a length of 1 character. &lt;code&gt;12[1]&lt;/code&gt; in position 14 indicates that the node labeled &lt;code&gt;14:&lt;/code&gt; (the &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt;) begins at character position 12 in the pre-compiled form of the regex, and has a length of 1 character---that is, it corresponds to the &lt;code&gt;+&lt;/code&gt; symbol in the precompiled regex.</source>
          <target state="translated">第一行表示偏移量/长度表包含45个条目。每个条目都是一对整数，由 &lt;code&gt;offset[&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;]&lt;/code&gt; 。条目从1开始编号，因此此处的条目＃1为 &lt;code&gt;1[4]&lt;/code&gt; ，条目＃12为 &lt;code&gt;5[1]&lt;/code&gt; 。 &lt;code&gt;1[4]&lt;/code&gt; 表示标记为 &lt;code&gt;1:&lt;/code&gt; 的节点（即 &lt;code&gt;1: ANYOF[bc]&lt;/code&gt; ）以正则表达式的预编译形式在字符位置1处开始，并且长度为4个字符。 &lt;code&gt;5[1]&lt;/code&gt; 中位置12表示该节点标记 &lt;code&gt;12:&lt;/code&gt; （在 &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt; ）在正则表达式的所述预编译的形式的字符位置5开始，并且具有1个字符的长度。 &lt;code&gt;12[1]&lt;/code&gt; 中位置14表示该节点标记 &lt;code&gt;14:&lt;/code&gt; （在 &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt; ）开始于该正则表达式的所述预编译的形式的字符位置12，且具有1个字符的长度---也就是说，它对应于预编译的正则表达式中的 &lt;code&gt;+&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="e2bf1de2c16e8c0adbab29364ba1219b9e1777c7" translate="yes" xml:space="preserve">
          <source>The first line here indicates that the offset/length table contains 45 entries. Each entry is a pair of integers, denoted by &lt;code&gt;offset[length]&lt;/code&gt;. Entries are numbered starting with 1, so entry #1 here is &lt;code&gt;1[4]&lt;/code&gt; and entry #12 is &lt;code&gt;5[1]&lt;/code&gt;. &lt;code&gt;1[4]&lt;/code&gt; indicates that the node labeled &lt;code&gt;1:&lt;/code&gt; (the &lt;code&gt;1: ANYOF[bc]&lt;/code&gt;) begins at character position 1 in the pre-compiled form of the regex, and has a length of 4 characters. &lt;code&gt;5[1]&lt;/code&gt; in position 12 indicates that the node labeled &lt;code&gt;12:&lt;/code&gt; (the &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt;) begins at character position 5 in the pre-compiled form of the regex, and has a length of 1 character. &lt;code&gt;12[1]&lt;/code&gt; in position 14 indicates that the node labeled &lt;code&gt;14:&lt;/code&gt; (the &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt;) begins at character position 12 in the pre-compiled form of the regex, and has a length of 1 character---that is, it corresponds to the &lt;code&gt;+&lt;/code&gt; symbol in the precompiled regex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3daa98ec524432df6c19e25f5089a0ae5fbe0898" translate="yes" xml:space="preserve">
          <source>The first line is an abbreviation for the following two lines, except that it doesn't create the superfluous array variable &lt;code&gt;@array&lt;/code&gt; .</source>
          <target state="translated">第一行是以下两行的缩写，不同之处在于它不会创建多余的数组变量 &lt;code&gt;@array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7be109e4ec8d67123623c616eb3634806eefdaf2" translate="yes" xml:space="preserve">
          <source>The first line is an abbreviation for the following two lines, except that it doesn't create the superfluous array variable &lt;code&gt;@array&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c7b267b0324e3ee08f49728c4657a96f3be74f" translate="yes" xml:space="preserve">
          <source>The first line is the plan - it specifies the number of tests I'm going to run so that it's easy to check that the test script didn't exit before running all the expected tests. The following lines are the test results - 'ok' for pass, 'not ok' for fail. Each test has a number and, optionally, a description. And that's it. Any language that can produce output like that on STDOUT can be used to write tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63cea67f4153eeb52ccd2e3da747660523e22317" translate="yes" xml:space="preserve">
          <source>The first line of a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f07b113f7912ed4a47b2646ff4b1fee0ebfd1d07" translate="yes" xml:space="preserve">
          <source>The first line of the commit message should be a short description without a period. It should be no longer than the subject line of an email, 50 characters being a good rule of thumb.</source>
          <target state="translated">提交信息的第一行应该是一个简短的描述,不要有句号。它不应该比电子邮件的主题行长,50个字符是一个好的经验法则。</target>
        </trans-unit>
        <trans-unit id="ae7ce29a18436b04a3b95f17b59a8ba620a5dab2" translate="yes" xml:space="preserve">
          <source>The first line shows the pre-compiled form of the regex. The second shows the size of the compiled form (in arbitrary units, usually 4-byte words) and the total number of bytes allocated for the offset/length table, usually 4+&lt;code&gt;size&lt;/code&gt; *8. The next line shows the label</source>
          <target state="translated">第一行显示了正则表达式的预编译形式。第二个显示了已编译表格的大小（以任意单位，通常为4个字节字），以及为偏移量/长度表分配的字节总数，通常为4+ &lt;code&gt;size&lt;/code&gt; * 8。下一行显示标签</target>
        </trans-unit>
        <trans-unit id="a20c750a487464791d892a303a995f218caaa79f" translate="yes" xml:space="preserve">
          <source>The first line shows the pre-compiled form of the regex. The second shows the size of the compiled form (in arbitrary units, usually 4-byte words) and the total number of bytes allocated for the offset/length table, usually 4+&lt;code&gt;size&lt;/code&gt;*8. The next line shows the label</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7723c265ae779d21866a1c9e48b6be3d9e2e441" translate="yes" xml:space="preserve">
          <source>The first method takes periodically samples of the CPU program counter, and since the program counter can be correlated with the code generated for functions, we get a statistical view of in which functions the program is spending its time. The caveats are that very small/fast functions have lower probability of showing up in the profile, and that periodically interrupting the program (this is usually done rather frequently, in the scale of milliseconds) imposes an additional overhead that may skew the results. The first problem can be alleviated by running the code for longer (in general this is a good idea for profiling), the second problem is usually kept in guard by the profiling tools themselves.</source>
          <target state="translated">第一种方法周期性地抽取CPU程序计数器的样本,由于程序计数器可以与函数生成的代码相关联,我们可以统计出程序在哪些函数中花费了时间。需要注意的是,非常小/快的函数在配置文件中出现的概率较低,而且周期性地中断程序(这通常是相当频繁的,以毫秒为单位)会带来额外的开销,可能会扭曲结果。第一个问题可以通过延长代码运行时间来缓解(一般来说,这对剖析来说是个好主意),第二个问题通常由剖析工具本身来把关。</target>
        </trans-unit>
        <trans-unit id="108fd116edbd3a8efddc6a912d5c851d634fe27e" translate="yes" xml:space="preserve">
          <source>The first name is called the</source>
          <target state="translated">第一个名字叫做</target>
        </trans-unit>
        <trans-unit id="0263570650724ebe71f62b454fad700a5d663c69" translate="yes" xml:space="preserve">
          <source>The first number doesn't really mean anything, but it has to be 1. It's the second number that's important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c95867addff6e3f2248f91516c23a2994856b3e" translate="yes" xml:space="preserve">
          <source>The first of the three available techniques is to write the filter completely in C. The external module you create interfaces directly with the source filter hooks provided by Perl.</source>
          <target state="translated">三种可用技术中的第一种是完全用C语言编写过滤器,你创建的外部模块直接与Perl提供的源过滤器钩子接口。</target>
        </trans-unit>
        <trans-unit id="2cf31ee7914fd21827d64f65da992c78e2dd2481" translate="yes" xml:space="preserve">
          <source>The first of these is the operand providing the overloaded operator implementation - in this case, the object whose &lt;code&gt;minus()&lt;/code&gt; method is being called.</source>
          <target state="translated">其中第一个是提供重载运算符实现的操作数-在这种情况下，将调用其 &lt;code&gt;minus()&lt;/code&gt; 方法的对象。</target>
        </trans-unit>
        <trans-unit id="32df19252ad74319d4ce1046b1c9ffb0a16536ba" translate="yes" xml:space="preserve">
          <source>The first of these two functions checks if a hash table entry exists, and the second deletes it.</source>
          <target state="translated">这两个函数中的第一个函数检查一个哈希表条目是否存在,第二个函数删除它。</target>
        </trans-unit>
        <trans-unit id="2baee74dbd5d9705ba409f49c41818c111db8f9c" translate="yes" xml:space="preserve">
          <source>The first one explicitly passes in the context, which is needed for e.g. threaded builds. The second one does that implicitly; do not get them mixed. If you are not passing in a aTHX_, you will need to do a dTHX (or a dVAR) as the first thing in the function.</source>
          <target state="translated">第一种是显式传递上下文,这对于线程构建等来说是需要的,第二种是隐式传递,不要把它们混为一谈。第二种是隐式的,不要把它们混为一谈。如果你没有传入 aTHX_,你需要在函数中首先做一个 dTHX (或 dVAR)。</target>
        </trans-unit>
        <trans-unit id="b5d9b746eaf9594387396efaab0691495a0a8b7a" translate="yes" xml:space="preserve">
          <source>The first one is &lt;code&gt;&quot;format&quot;&lt;/code&gt; , which is a sprintf()-style format string to be used for both numeric parts of the complex number(s). The is somewhat system-dependent but most often it corresponds to &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt; . You can revert to the default by setting the &lt;code&gt;&lt;a href=&quot;../functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">第一个是 &lt;code&gt;&quot;format&quot;&lt;/code&gt; ，它是sprintf（）样式的格式字符串，用于复数的两个数字部分。它在某种程度上取决于系统，但通常与 &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt; 相对应。您可以通过将 &lt;code&gt;&lt;a href=&quot;../functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 设置为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 来还原为默认值。</target>
        </trans-unit>
        <trans-unit id="51d3fa9f9095d6ba6fd87e541115beff9437b3d9" translate="yes" xml:space="preserve">
          <source>The first one is &lt;code&gt;&quot;format&quot;&lt;/code&gt;, which is a sprintf()-style format string to be used for both numeric parts of the complex number(s). The is somewhat system-dependent but most often it corresponds to &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt;. You can revert to the default by setting the &lt;code&gt;format&lt;/code&gt; to &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64110520d33c3683502b6895ec7f686e2b691a83" translate="yes" xml:space="preserve">
          <source>The first one is a B::PADNAMELIST under Perl 5.22, and a B::AV under earlier versions. The rest are currently B::AV objects, but that could change in future versions.</source>
          <target state="translated">第一个是Perl 5.22下的B::PADNAMELIST,以及早期版本下的B::AV。其余的目前是B::AV对象,但在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="094fe85cd4712afd8983c54311ea1fc6e32b5e2d" translate="yes" xml:space="preserve">
          <source>The first parameter is a scalar into which, upon success, the wide character represented by the multi-byte string contained in the second parameter is stored. The optional third parameter is ignored if it is larger than the actual length of the second parameter string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b59fd7f35cf6d9692928110737a220c45e66d67" translate="yes" xml:space="preserve">
          <source>The first parameter to &lt;code&gt;UTF8fARG&lt;/code&gt; is a boolean: 1 if the string is in UTF-8; 0 if string is in native byte encoding (Latin1). The second parameter is the number of bytes in the string to print. And the third and final parameter is a pointer to the first byte in the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ea0aa1b4ed42878caaa6bf56a3d5e35dfb1b12" translate="yes" xml:space="preserve">
          <source>The first parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;*.tar.gz&lt;/code&gt;, is an</source>
          <target state="translated">第一个参数 &lt;code&gt;globmap&lt;/code&gt; ， &lt;code&gt;*.tar.gz&lt;/code&gt; ，是</target>
        </trans-unit>
        <trans-unit id="bbc40cbdc77266be7323541d7a55e0277f7ff986" translate="yes" xml:space="preserve">
          <source>The first parameter to &lt;code&gt;globmap&lt;/code&gt;, &lt;code&gt;*.tar.gz&lt;/code&gt;, is an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7f0d7f3250dff196379a82ef1042cf92584eab" translate="yes" xml:space="preserve">
          <source>The first part of each item is the language tag, between {...}. It is followed by an English name for the language or language-group. Language tags that I judge to be not for general use, are bracketed.</source>
          <target state="translated">每个项目的第一部分是语言标签,位于{...}之间。后面是该语言或语言组的英文名称。我认为不适合一般使用的语言标签被放在括号里。</target>
        </trans-unit>
        <trans-unit id="2850ab20f1390861bb35445270293546335b53f4" translate="yes" xml:space="preserve">
          <source>The first part of the report already shows the critical information regarding which subroutines are using the most time. The next gives some statistics about the source files profiled.</source>
          <target state="translated">报告的第一部分已经显示了关于哪些子程序使用时间最多的关键信息。接下来给出了一些关于源文件的统计资料。</target>
        </trans-unit>
        <trans-unit id="397f188600044026c7930c78c4ec45f2d657488a" translate="yes" xml:space="preserve">
          <source>The first pass is finding the end of the quoted construct. This results in saving to a safe location a copy of the text (between the starting and ending delimiters), normalized as necessary to avoid needing to know what the original delimiters were.</source>
          <target state="translated">第一道是找到引用结构的结尾。这样做的结果是将文本的副本保存到一个安全的位置(在开始和结束定界符之间),必要时进行规范化处理,以避免需要知道原始定界符是什么。</target>
        </trans-unit>
        <trans-unit id="52dc28c1ba280be3247117e934caac44df1ea80f" translate="yes" xml:space="preserve">
          <source>The first portions of this document contains instructions to cross-compile Perl for Android 2.0 and later, using the binaries provided by Google. The latter portions describe how to build perl native using one of the toolchains available on the Play Store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fe7088bb4f27d081fbb7bc1dcf8f8999b582b8" translate="yes" xml:space="preserve">
          <source>The first quantifier '.*' starts out by matching the whole string 'the cat in the hat'.</source>
          <target state="translated">第一个量化符'.*'开始匹配整个字符串'the cat in the hat'。</target>
        </trans-unit>
        <trans-unit id="9c1c8c14ec1e3a07903d82f126aec6635328f772" translate="yes" xml:space="preserve">
          <source>The first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much of the string as possible while still having the regex match. The second quantifier &lt;code&gt;.*&lt;/code&gt; has no string left to it, so it matches 0 times.</source>
          <target state="translated">第一个量词 &lt;code&gt;.*&lt;/code&gt; 在保持正则表达式匹配的同时，尽可能多地捕获字符串。第二个量词 &lt;code&gt;.*&lt;/code&gt; 没有剩余的字符串，因此它匹配0次。</target>
        </trans-unit>
        <trans-unit id="6e528105bd9590f0533aed7b713042470a33b8f6" translate="yes" xml:space="preserve">
          <source>The first reason is that this technique</source>
          <target state="translated">第一个原因是,这种技术</target>
        </trans-unit>
        <trans-unit id="b01253c2ebd001b8b295bfdd61014e6f7807bcd2" translate="yes" xml:space="preserve">
          <source>The first regexp &lt;code&gt;world&lt;/code&gt; doesn't match because regexps are case-sensitive. The second regexp matches because the substring &lt;code&gt;'o W'&lt;/code&gt; occurs in the string &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; . The space character ' ' is treated like any other character in a regexp and is needed to match in this case. The lack of a space character is the reason the third regexp &lt;code&gt;'oW'&lt;/code&gt; doesn't match. The fourth regexp &lt;code&gt;'World '&lt;/code&gt; doesn't match because there is a space at the end of the regexp, but not at the end of the string. The lesson here is that regexps must match a part of the string</source>
          <target state="translated">第一个regexp &lt;code&gt;world&lt;/code&gt; 不匹配，因为regexp 区分大小写。第二个正则表达式匹配，因为子字符串 &lt;code&gt;'o W'&lt;/code&gt; 出现在字符串 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 。空格字符''就像正则表达式中的其他任何字符一样，在这种情况下需要匹配。缺少空格字符是第三个正则表达式 &lt;code&gt;'oW'&lt;/code&gt; 不匹配的原因。第四个regexp'World &lt;code&gt;'World '&lt;/code&gt; 不匹配，因为在regexp的末尾有一个空格，但在字符串的末尾没有空格。这里的教训是正则表达式必须与字符串的一部分匹配</target>
        </trans-unit>
        <trans-unit id="d791e1a0374a959ba40ed9f40fd370a5d5a456cb" translate="yes" xml:space="preserve">
          <source>The first regexp &lt;code&gt;world&lt;/code&gt; doesn't match because regexps are case-sensitive. The second regexp matches because the substring &lt;code&gt;'o W'&lt;/code&gt; occurs in the string &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;. The space character &lt;code&gt;' '&lt;/code&gt; is treated like any other character in a regexp and is needed to match in this case. The lack of a space character is the reason the third regexp &lt;code&gt;'oW'&lt;/code&gt; doesn't match. The fourth regexp &quot;&lt;code&gt;World &lt;/code&gt;&quot; doesn't match because there is a space at the end of the regexp, but not at the end of the string. The lesson here is that regexps must match a part of the string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddca4d833894463530776d04e09076c4eab205cd" translate="yes" xml:space="preserve">
          <source>The first regexp doesn't match because the string has more to it than &lt;code&gt;keep&lt;/code&gt; . Since the second regexp is exactly the string, it matches. Using both &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; in a regexp forces the complete string to match, so it gives you complete control over which strings match and which don't. Suppose you are looking for a fellow named bert, off in a string by himself:</source>
          <target state="translated">第一个regexp不匹配，因为该字符串比 &lt;code&gt;keep&lt;/code&gt; 具有更多的功能。由于第二个正则表达式恰好是字符串，因此它匹配。在正则表达式中同时使用 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 会强制匹配完整的字符串，因此可以完全控制哪些字符串匹配以及哪些字符串不匹配。假设您正在寻找一个名叫bert的家伙，他自己是一个字符串：</target>
        </trans-unit>
        <trans-unit id="467dd0993aab8207646a6fe07d7110c16e4ae880" translate="yes" xml:space="preserve">
          <source>The first regexp doesn't match because the string has more to it than &lt;code&gt;keep&lt;/code&gt;. Since the second regexp is exactly the string, it matches. Using both &lt;code&gt;'^'&lt;/code&gt; and &lt;code&gt;'$'&lt;/code&gt; in a regexp forces the complete string to match, so it gives you complete control over which strings match and which don't. Suppose you are looking for a fellow named bert, off in a string by himself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187948592e3895c96d921caa597048a315b504cd" translate="yes" xml:space="preserve">
          <source>The first reports that both those the hashes contain the same data, while the second reports that they do not. Which you prefer is left as an exercise to the reader.</source>
          <target state="translated">第一个报告说这两个哈希值包含相同的数据,而第二个报告说它们不包含相同的数据。你更喜欢哪种说法,留给读者去研究。</target>
        </trans-unit>
        <trans-unit id="8860a773058066d93bd3eee9e9232f1b245f86d6" translate="yes" xml:space="preserve">
          <source>The first section describes POSIX functions from the 1003.1 specification. The second section describes some classes for signal objects, TTY objects, and other miscellaneous objects. The remaining sections list various constants and macros in an organization which roughly follows IEEE Std 1003.1b-1993.</source>
          <target state="translated">第一节介绍了1003.1规范中的POSIX函数。第二节介绍了信号对象、TTY对象和其他杂项对象的一些类。其余部分列出了各种常量和宏,其组织结构大致遵循IEEE Std 1003.1b-1993。</target>
        </trans-unit>
        <trans-unit id="9a3305f1afd295681118d876dec01ed7a5b8a456" translate="yes" xml:space="preserve">
          <source>The first section maps various C data types to a name, which corresponds somewhat with the various Perl types. The second section contains C code which &lt;b&gt;xsubpp&lt;/b&gt; uses to handle input parameters. The third section contains C code which &lt;b&gt;xsubpp&lt;/b&gt; uses to handle output parameters.</source>
          <target state="translated">第一部分将各种C数据类型映射为一个名称，该名称在某种程度上与各种Perl类型相对应。第二部分包含&lt;b&gt;xsubpp&lt;/b&gt;用于处理输入参数的C代码。第三部分包含&lt;b&gt;xsubpp&lt;/b&gt;用于处理输出参数的C代码。</target>
        </trans-unit>
        <trans-unit id="5dec21809b3e94bb56bbf06b1ab08c273929b8df" translate="yes" xml:space="preserve">
          <source>The first section of this document provides an itemized checklist; subsequent sections provide a more detailed discussion of the items on the list. The final section, &quot;Common Pitfalls&quot;, describes some of the most popular mistakes made by CPAN authors.</source>
          <target state="translated">本文件的第一节提供了一个逐项核对清单;随后的章节对清单上的项目进行了更详细的讨论。最后一节 &quot;常见错误 &quot;描述了CPAN作者最常犯的一些错误。</target>
        </trans-unit>
        <trans-unit id="873fa0119aa76096529ccc05f5ae97f00f810fd3" translate="yes" xml:space="preserve">
          <source>The first set of stats gives some summary statistical information, including the quality score translated into &quot;Good&quot;, &quot;Poor&quot; and &quot;Bad&quot;, (score&amp;lt;=1.05, score&amp;lt;=1.2, score&amp;gt;1.2). See the documentation in bucket_stats() for more details.</source>
          <target state="translated">第一组统计信息提供了一些摘要统计信息，包括转换为&amp;ldquo;好&amp;rdquo;，&amp;ldquo;差&amp;rdquo;和&amp;ldquo;差&amp;rdquo;的质量得分（得分&amp;lt;= 1.05，得分&amp;lt;= 1.2，得分&amp;gt; 1.2）。有关更多详细信息，请参见bucket_stats（）中的文档。</target>
        </trans-unit>
        <trans-unit id="da5f31247c2eb407c67afefcfd779d23549ec3df" translate="yes" xml:space="preserve">
          <source>The first situation being much more frequent, it makes sense to rewrite the boilerplate as</source>
          <target state="translated">第一种情况比较多,所以将模板改写成这样是有道理的。</target>
        </trans-unit>
        <trans-unit id="ad55dcbd2815a02cf9af8564c1fdb6a55d76bf9e" translate="yes" xml:space="preserve">
          <source>The first state may happen in &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; and &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handlers.</source>
          <target state="translated">第一种状态可能发生在 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 和 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 处理程序中。</target>
        </trans-unit>
        <trans-unit id="470d1d04836c0a5dd42cc354e122ff4ddc8f36a3" translate="yes" xml:space="preserve">
          <source>The first step is to add this line:</source>
          <target state="translated">第一步是增加这一行。</target>
        </trans-unit>
        <trans-unit id="1d92a911344060c6031358fbe99f5d7b26fb10e8" translate="yes" xml:space="preserve">
          <source>The first step of processing such a line is the conversion, to binary, of the hexadecimal data, to obtain the four fields, while checking the checksum. No surprise here: we'll start with a simple &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; call to convert everything to binary:</source>
          <target state="translated">处理此类行的第一步是在检查校验和的同时，将十六进制数据转换为二进制，以获得四个字段。毫不奇怪：我们将从一个简单的 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 调用开始，将所有内容转换为二进制：</target>
        </trans-unit>
        <trans-unit id="3d051bbcc0b2bf5e763df328cc13763c82b21bfe" translate="yes" xml:space="preserve">
          <source>The first step of processing such a line is the conversion, to binary, of the hexadecimal data, to obtain the four fields, while checking the checksum. No surprise here: we'll start with a simple &lt;code&gt;pack&lt;/code&gt; call to convert everything to binary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2237935485a4e0e57cc8ab0badea71ce05f470d" translate="yes" xml:space="preserve">
          <source>The first string position that this regexp can match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; . At this position, the minimal &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}?&lt;/a&gt;&lt;/code&gt; matches just one &lt;code&gt;'m'&lt;/code&gt; . Although the second quantifier &lt;code&gt;.*?&lt;/code&gt; would prefer to match no characters, it is constrained by the end-of-string anchor &lt;code&gt;$&lt;/code&gt; to match the rest of the string.</source>
          <target state="translated">第一串中的位置，该正则表达式匹配可以是在第一 &lt;code&gt;'m'&lt;/code&gt; 中 &lt;code&gt;programming&lt;/code&gt; 。在这个位置，最小 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}?&lt;/a&gt;&lt;/code&gt; 仅匹配一个 &lt;code&gt;'m'&lt;/code&gt; 。虽然第二个量词 &lt;code&gt;.*?&lt;/code&gt; 宁愿不匹配任何字符，它受字符串结尾锚 &lt;code&gt;$&lt;/code&gt; 的约束，以匹配其余字符串。</target>
        </trans-unit>
        <trans-unit id="5f895607d70ebcfe9c61321d68de376e6e1b258c" translate="yes" xml:space="preserve">
          <source>The first string position that this regexp can match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt;. At this position, the minimal &lt;code&gt;m{1,2}?&lt;/code&gt; matches just one &lt;code&gt;'m'&lt;/code&gt;. Although the second quantifier &lt;code&gt;.*?&lt;/code&gt; would prefer to match no characters, it is constrained by the end-of-string anchor &lt;code&gt;'$'&lt;/code&gt; to match the rest of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fea599d468c324040fff443da5016a605f7268fd" translate="yes" xml:space="preserve">
          <source>The first task in building a regexp is to decide what we want to match and what we want to exclude. In our case, we want to match both integers and floating point numbers and we want to reject any string that isn't a number.</source>
          <target state="translated">构建一个regexp的首要任务是决定我们要匹配的内容和要排除的内容。在我们的例子中,我们希望同时匹配整数和浮点数,并拒绝任何非数字的字符串。</target>
        </trans-unit>
        <trans-unit id="a253a2302f0dd4214c0fa19a3c7600e1aeb7c19f" translate="yes" xml:space="preserve">
          <source>The first thing after the &quot;=over&quot; command should be an &quot;=item&quot;, unless there aren't going to be any items at all in this &quot;=over&quot; ... &quot;=back&quot; region.</source>
          <target state="translated">在&quot;=over &quot;命令之后的第一件事应该是&quot;=item&quot;,除非在这个&quot;=over&quot;...&quot;=back &quot;区域中根本不会有任何物品。&quot;=back &quot;区域。</target>
        </trans-unit>
        <trans-unit id="b4182d2194d7b0a192c4908dabaf70426956c4b1" translate="yes" xml:space="preserve">
          <source>The first thread will grab a lock on &lt;code&gt;$x&lt;/code&gt; , then, after a pause during which the second thread has probably had time to do some work, try to grab a lock on &lt;code&gt;$y&lt;/code&gt; . Meanwhile, the second thread grabs a lock on &lt;code&gt;$y&lt;/code&gt; , then later tries to grab a lock on &lt;code&gt;$x&lt;/code&gt; . The second lock attempt for both threads will block, each waiting for the other to release its lock.</source>
          <target state="translated">第一个线程将在 &lt;code&gt;$x&lt;/code&gt; 上锁定一个锁，然后，在第二个线程可能有时间做一些工作的暂停之后，尝试在 &lt;code&gt;$y&lt;/code&gt; 上锁定一个锁。同时，第二个线程抓住 &lt;code&gt;$y&lt;/code&gt; 的锁，然后稍后尝试抓住 &lt;code&gt;$x&lt;/code&gt; 的锁。两个线程的第二次锁定尝试都将阻塞，每个线程都在等待对方释放其锁定。</target>
        </trans-unit>
        <trans-unit id="1b0e5abdf339f37172dcc121e02e6f88bb538337" translate="yes" xml:space="preserve">
          <source>The first thread will grab a lock on &lt;code&gt;$x&lt;/code&gt;, then, after a pause during which the second thread has probably had time to do some work, try to grab a lock on &lt;code&gt;$y&lt;/code&gt;. Meanwhile, the second thread grabs a lock on &lt;code&gt;$y&lt;/code&gt;, then later tries to grab a lock on &lt;code&gt;$x&lt;/code&gt;. The second lock attempt for both threads will block, each waiting for the other to release its lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97805142bc0d01ba991305a8f5bc28f8f3fcba12" translate="yes" xml:space="preserve">
          <source>The first time through the loop, you will rewrite the entire file, from line 0 through the end. The second time through the loop, you will rewrite the entire file from line 1 through the end. The third time through the loop, you will rewrite the entire file from line 2 to the end. And so on.</source>
          <target state="translated">第一次通过循环,你将重写整个文件,从第0行到最后。第二次通过循环,你将重写整个文件,从第1行到最后。第三次通过循环,你将重写整个文件,从第2行到最后。以此类推。</target>
        </trans-unit>
        <trans-unit id="0d6a59a26170358aef33f4d3978afce2e252997e" translate="yes" xml:space="preserve">
          <source>The first two arguments taken by this method are the name of the symbol and the value which should be assigned to it. The optional third argument is a string specifying the symbol table to be used; 'GLOBAL' specifies the global symbol table, and any other string specifies the local symbol table. If this argument is omitted, the default symbol table for the object is used. &lt;code&gt;setsym&lt;/code&gt; returns TRUE if successful, and FALSE otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579873cee61866ba7eb29c6c1922769d306aac89" translate="yes" xml:space="preserve">
          <source>The first two fields give the total amount of memory perl sbrk(2)ed (ess-broken? :-) and number of sbrk(2)s used. The third number is what perl thinks about continuity of returned chunks. So long as this number is positive, malloc() will assume that it is probable that sbrk(2) will provide continuous memory.</source>
          <target state="translated">前两个字段给出了perl sbrk(2)ed的内存总量(ess-broken?:-)和使用的sbrk(2)的数量。第三个数字是perl认为返回的块的连续性。只要这个数字是正数,malloc()就会认为sbrk(2)很可能提供连续的内存。</target>
        </trans-unit>
        <trans-unit id="0819c6d2283041c7cfda116e5fb9ae13c3a8c8e6" translate="yes" xml:space="preserve">
          <source>The first two forms return &lt;b&gt;true&lt;/b&gt; if the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt; should not be produced by composition normalization. For the final two forms to return &lt;b&gt;true&lt;/b&gt;, it is additionally required that this fact not otherwise be determinable from the Unicode data base.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4becb05f0bd7170201aca65de03c239266000dbc" translate="yes" xml:space="preserve">
          <source>The first two forms return &lt;b&gt;true&lt;/b&gt; if the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; should not be produced by composition normalization. For the final two forms to return &lt;b&gt;true&lt;/b&gt;, it is additionally required that this fact not otherwise be determinable from the Unicode data base.</source>
          <target state="translated">如果不应通过合成规范化产生&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数，&lt;/a&gt;则前两种形式返回&lt;b&gt;true&lt;/b&gt;。为了使最后两种形式返回&lt;b&gt;true&lt;/b&gt;，还要求不能通过Unicode数据库确定此事实。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7edeb46a7cf77b29322b042169fd6545cca7858e" translate="yes" xml:space="preserve">
          <source>The first value to be substituted in the output string ( usually the column in a cursor addressing capability )</source>
          <target state="translated">在输出字符串中要替换的第一个值(通常是游标寻址能力中的列)。</target>
        </trans-unit>
        <trans-unit id="6c0a32c5664fb58c1965f29a470eb892918927d8" translate="yes" xml:space="preserve">
          <source>The first version of TAP to include an explicit version number is 13.</source>
          <target state="translated">TAP的第一个包含明确版本号的版本是13。</target>
        </trans-unit>
        <trans-unit id="23a0afbda307c4ae7b5c2196fca71616dba92438" translate="yes" xml:space="preserve">
          <source>The first version of this article originally appeared in The Perl Journal #11, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba908120df7bb5731ed530b89b4f89b55fe9cb39" translate="yes" xml:space="preserve">
          <source>The first version of this document appeared on Perl Monks, where several people had useful suggestions. Thank you, Perl Monks.</source>
          <target state="translated">本文档的第一版出现在 Perl Monks 上,有几个人提出了有用的建议。谢谢你,Perl Monks。</target>
        </trans-unit>
        <trans-unit id="af8e62f88abda0ab386f2cc101dff094b50fe117" translate="yes" xml:space="preserve">
          <source>The first version, the one without the indirect object, ran the</source>
          <target state="translated">第一个版本,没有间接对象的版本,运行的是</target>
        </trans-unit>
        <trans-unit id="6781fdff7b279779b03d140931fe35f9d498c177" translate="yes" xml:space="preserve">
          <source>The first will run all test files in all first-level subdirectories and all subdirectories they contain. The second will run tests in only the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf53ff13525a226bb832b26adcd06a8433dba05" translate="yes" xml:space="preserve">
          <source>The fix is to remove all Test::Builder1.5/2 related code. Either use the legacy Test::Builder API, or use Test2 directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2b513d7712476adb9fe5c913d728ae8bf500df8" translate="yes" xml:space="preserve">
          <source>The fix is to use the API specified in &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; to look at or modify state as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5db8a38d2c3f00c90a5e9484dd046d60b873cc" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt; . Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">用于逐字记录文本和代码的固定宽度字体。默认为 &lt;code&gt;CW&lt;/code&gt; 。某些系统可能需要 &lt;code&gt;CR&lt;/code&gt; 。仅对&lt;b&gt;troff&lt;/b&gt;输出有效。</target>
        </trans-unit>
        <trans-unit id="4411138b75b6f4d0eb399c58a09f8dac2bce859c" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt; . Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for troff(1) output.</source>
          <target state="translated">用于逐字记录文本和代码的固定宽度字体。默认为 &lt;code&gt;CW&lt;/code&gt; 。某些系统可能需要 &lt;code&gt;CR&lt;/code&gt; 。仅对troff（1）输出有效。</target>
        </trans-unit>
        <trans-unit id="e30f3c3943bfb47da6b22d33c6d6f3755c5c4c90" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt;. Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f14452e50daa176a2948e6c80e179269ad7ea89" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt;. Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for troff(1) output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ad2fb87b3a3c9138524933b76f13bbb404b147" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;SVs_PADSTALE&lt;/code&gt; is cleared on lexicals each time the &lt;code&gt;my()&lt;/code&gt; is executed, and set on scope exit. This allows the &lt;code&gt;&quot;Variable $x is not available&quot;&lt;/code&gt; warning to be generated in evals, such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239752a03e595c22089872230ac5d8660b72070d" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;UNICODE_WARN_ILLEGAL_INTERCHANGE&lt;/code&gt; selects all three of the above WARN flags; and &lt;code&gt;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt; selects all three DISALLOW flags. &lt;code&gt;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt; restricts the allowed inputs to the strict UTF-8 traditionally defined by Unicode. Similarly, &lt;code&gt;UNICODE_WARN_ILLEGAL_C9_INTERCHANGE&lt;/code&gt; and &lt;code&gt;UNICODE_DISALLOW_ILLEGAL_C9_INTERCHANGE&lt;/code&gt; are shortcuts to select the above-Unicode and surrogate flags, but not the non-character ones, as defined in &lt;a href=&quot;https://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode Corrigendum #9&lt;/a&gt;. See &lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;&quot;Noncharacter code points&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f7fca8c3cfcccf779409e2e759e639d09b18b3" translate="yes" xml:space="preserve">
          <source>The flag SVs_PADSTALE is cleared on lexicals each time the my() is executed, and set on scope exit. This allows the 'Variable $x is not available' warning to be generated in evals, such as</source>
          <target state="translated">每次执行my()时,标志SVs_PADSTALE在词法上被清除,并在作用域退出时设置。这允许在evals中生成 &quot;变量$x不可用 &quot;的警告,例如</target>
        </trans-unit>
        <trans-unit id="f2aaf40e59e4745cf25b943d852f6d075ba40074" translate="yes" xml:space="preserve">
          <source>The flags &lt;code&gt;UTF8_WARN_ILLEGAL_INTERCHANGE&lt;/code&gt;, &lt;code&gt;UTF8_WARN_ILLEGAL_C9_INTERCHANGE&lt;/code&gt;, &lt;code&gt;UTF8_WARN_SURROGATE&lt;/code&gt;, &lt;code&gt;UTF8_WARN_NONCHAR&lt;/code&gt;, and &lt;code&gt;UTF8_WARN_SUPER&lt;/code&gt; will cause warning messages to be raised for their respective categories, but otherwise the code points are considered valid (not malformations). To get a category to both be treated as a malformation and raise a warning, specify both the WARN and DISALLOW flags. (But note that warnings are not raised if lexically disabled nor if &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; is also specified.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78429f471bd064af1845edc82bca0aa6e6778ce" translate="yes" xml:space="preserve">
          <source>The flags UTF8_WARN_ILLEGAL_INTERCHANGE, UTF8_WARN_SURROGATE, UTF8_WARN_NONCHAR, and UTF8_WARN_SUPER will cause warning messages to be raised for their respective categories, but otherwise the code points are considered valid (not malformations). To get a category to both be treated as a malformation and raise a warning, specify both the WARN and DISALLOW flags. (But note that warnings are not raised if lexically disabled nor if UTF8_CHECK_ONLY is also specified.)</source>
          <target state="translated">标志UTF8_WARN_ILLEGAL_INTERCHANGE、UTF8_WARN_SURROGATE、UTF8_WARN_NONCHAR和UTF8_WARN_SUPER将导致各自类别的警告信息被引发,但除此之外,代码点被认为是有效的(不是畸形)。要想让一个类别既被视为畸形又引发警告,请同时指定WARN和DISALLOW标志。(但请注意,如果词法禁用或同时指定UTF8_CHECK_ONLY,则不会发出警告。)</target>
        </trans-unit>
        <trans-unit id="5e9a6e0acd0b69b277831006219122b07719e738" translate="yes" xml:space="preserve">
          <source>The flags default to zero, if you want something different you can either use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt; , or you can derive from POSIX::SigRt and define your own &lt;code&gt;new()&lt;/code&gt; (the tied hash STORE method of the &lt;code&gt;%SIGRT&lt;/code&gt; calls &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt; , where the &lt;code&gt;$rtsig&lt;/code&gt; ranges from zero to &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt; .</source>
          <target state="translated">这些标志默认为零，如果您想要不同的东西，可以在 &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt; 上使用 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ，也可以从POSIX :: SigRt派生并定义自己的 &lt;code&gt;new()&lt;/code&gt; （ &lt;code&gt;%SIGRT&lt;/code&gt; 调用 &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt; ，其中 &lt;code&gt;$rtsig&lt;/code&gt; 范围从零到 &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="723ee765d373688ffd88695151d122551f3cfc41" translate="yes" xml:space="preserve">
          <source>The flags default to zero, if you want something different you can either use &lt;code&gt;local&lt;/code&gt; on &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt;, or you can derive from POSIX::SigRt and define your own &lt;code&gt;new()&lt;/code&gt; (the tied hash STORE method of the &lt;code&gt;%SIGRT&lt;/code&gt; calls &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt;, where the &lt;code&gt;$rtsig&lt;/code&gt; ranges from zero to &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13aa1a177f443868b50bc938e7eaafe94399ebc" translate="yes" xml:space="preserve">
          <source>The flags parameter is mandatory. The valid flag values are R_CURSOR, R_FIRST, R_LAST, R_NEXT and R_PREV.</source>
          <target state="translated">flags参数是必须设置的,有效的flag值是R_CURSOR,R_FIRST,R_LAST,R_NEXT和R_PREV。有效的flag值是R_CURSOR,R_FIRST,R_LAST,R_NEXT和R_PREV。</target>
        </trans-unit>
        <trans-unit id="3f1710e98626f16d762b28b22c17439d043e302f" translate="yes" xml:space="preserve">
          <source>The flags specify dictionary order and case folding:</source>
          <target state="translated">标志指定字典顺序和大小写折叠。</target>
        </trans-unit>
        <trans-unit id="10543ef8424f431d7ff14981f10f88f0c585ac15" translate="yes" xml:space="preserve">
          <source>The flavor</source>
          <target state="translated">味道</target>
        </trans-unit>
        <trans-unit id="0aa322e2f3acfe06e30a26fc0d60aa65599ac7cd" translate="yes" xml:space="preserve">
          <source>The floating point infinity can be exported as a subroutine Inf():</source>
          <target state="translated">浮点无穷大可以导出为一个子程序Inf()。</target>
        </trans-unit>
        <trans-unit id="b219578f1fed53f8498341e6252dcc91a786ab6d" translate="yes" xml:space="preserve">
          <source>The floating point number is taken and split first on the single decimal place, then each group of three digits to the right of the decimal makes up the next digit, and so on until the number of significant digits is exhausted, &lt;b&gt;plus&lt;/b&gt; enough trailing zeros to reach the next multiple of three.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5e2b0312afcc71cd5da99161e1d75eaff20f77" translate="yes" xml:space="preserve">
          <source>The focus is on elements of style which are visible to the users of a module, rather than those parts which are only seen by the module's developers. However, many of the guidelines presented in this document can be extrapolated and applied successfully to a module's internals.</source>
          <target state="translated">本文档的重点是模块的用户可以看到的风格元素,而不是那些只有模块的开发者才能看到的部分。但是,本文中介绍的许多准则都可以外推并成功地应用于模块的内部。</target>
        </trans-unit>
        <trans-unit id="9981cb315250daca0797ec1ef39fd43f6c6f6a86" translate="yes" xml:space="preserve">
          <source>The following &quot;public&quot; global names can be read by clients of this API. Beware that these should be considered &quot;readonly&quot;.</source>
          <target state="translated">以下的 &quot;公共 &quot;全局名称可以被这个API的客户端读取。请注意,这些名称应被视为 &quot;只读&quot;。</target>
        </trans-unit>
        <trans-unit id="20617679e0f828efd3412a47a9694c121128bc85" translate="yes" xml:space="preserve">
          <source>The following &quot;virtual&quot; methods can be defined by the client. They will be called by the API at appropriate points. Note that unless specified otherwise, the debug API only defines empty, non-functional default versions of these methods.</source>
          <target state="translated">以下 &quot;虚拟 &quot;方法可以由客户端定义。它们将在适当的时候被API调用。请注意,除非另有规定,否则调试API只定义这些方法的空的、无功能的默认版本。</target>
        </trans-unit>
        <trans-unit id="74f1711fbc30180876f2a4788abe7e66574474a6" translate="yes" xml:space="preserve">
          <source>The following (inefficiently) deletes all the values of %HASH and @ARRAY:</source>
          <target state="translated">下面(低效地)删除%HASH和@ARRAY的所有值。</target>
        </trans-unit>
        <trans-unit id="d00c5dd059bf93f0972cfd4b44a56b57fd0caf81" translate="yes" xml:space="preserve">
          <source>The following API list contains functions, thus one needs to provide pointers to the modifiable data explicitly (either C pointers, or Perlish &lt;code&gt;GV *&lt;/code&gt; s). Where the above macros take &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;, a similar function takes &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; .</source>
          <target state="translated">以下API列表包含函数，因此需要明确提供指向可修改数据的指针（C指针或Perlish &lt;code&gt;GV *&lt;/code&gt; s）。上述宏采用 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 的地方，类似的函数采用 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; 的地方。</target>
        </trans-unit>
        <trans-unit id="d7722c25bc63a475d0687db360090ccce2f038b0" translate="yes" xml:space="preserve">
          <source>The following API list contains functions, thus one needs to provide pointers to the modifiable data explicitly (either C pointers, or Perlish &lt;code&gt;GV *&lt;/code&gt;s). Where the above macros take &lt;code&gt;int&lt;/code&gt;, a similar function takes &lt;code&gt;int *&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1909e3498aef1b158b54d7174bc50b2ee9e5d97" translate="yes" xml:space="preserve">
          <source>The following API uses parts of Perl's internals in the current implementation. As such, they are efficient but may change in a future release.</source>
          <target state="translated">下面的API使用了当前实现中Perl的部分内部结构。因此,它们是有效的,但在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="4a57e29ab087cd96e1aaf0f9eb948df8f4a4939a" translate="yes" xml:space="preserve">
          <source>The following CVE reports were previously filed against File-Path and are believed to have been addressed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cab3979d794d7afb5425a45a32e9d6f7ad6a57" translate="yes" xml:space="preserve">
          <source>The following NNTP command are unsupported by the package, and there are no plans to do so.</source>
          <target state="translated">下面的NNTP命令是软件包不支持的,目前也没有计划支持。</target>
        </trans-unit>
        <trans-unit id="2d9e72c95e25f90c1fd2f371c21c4c0499d49748" translate="yes" xml:space="preserve">
          <source>The following RFC959 commands have not been implemented:</source>
          <target state="translated">以下RFC959命令尚未实施。</target>
        </trans-unit>
        <trans-unit id="8ed1bcda5c1f977c3cd2bdcf823f30eee9e9931d" translate="yes" xml:space="preserve">
          <source>The following SDK and compiler configurations and Nokia phones were tested at some point in time (+ = compiled and PerlApp run, - = not), both for Perl 5.8.x and 5.9.x:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237479489ace35ae45dfd88db2279ca4abed31a5" translate="yes" xml:space="preserve">
          <source>The following VMS-specific information applies to the indicated &quot;special&quot; Perl variables, in addition to the general information in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. Where there is a conflict, this information takes precedence.</source>
          <target state="translated">除了&lt;a href=&quot;perlvar&quot;&gt;perlvar中&lt;/a&gt;的常规信息之外，以下特定于VMS的信息还适用于指示的&amp;ldquo;特殊&amp;rdquo; Perl变量。发生冲突时，此信息优先。</target>
        </trans-unit>
        <trans-unit id="a7dd0dcb80676e8669cc8ad178e5203d579a6cf3" translate="yes" xml:space="preserve">
          <source>The following Win32-Methods are built-in:</source>
          <target state="translated">以下是内置的Win32方法。</target>
        </trans-unit>
        <trans-unit id="1c76188e19e8645c61f6a21008485b728f914f68" translate="yes" xml:space="preserve">
          <source>The following XS code shows the getnetconfigent() function which is used with ONC+ TIRPC. The getnetconfigent() function will return a pointer to a C structure and has the C prototype shown below. The example will demonstrate how the C pointer will become a Perl reference. Perl will consider this reference to be a pointer to a blessed object and will attempt to call a destructor for the object. A destructor will be provided in the XS source to free the memory used by getnetconfigent(). Destructors in XS can be created by specifying an XSUB function whose name ends with the word &lt;b&gt;DESTROY&lt;/b&gt;. XS destructors can be used to free memory which may have been malloc'd by another XSUB.</source>
          <target state="translated">以下XS代码显示了与ONC + TIRPC一起使用的getnetconfigent（）函数。 getnetconfigent（）函数将返回一个指向C结构的指针，并具有如下所示的C原型。该示例将演示C指针将如何成为Perl引用。 Perl将认为此引用是指向受祝福对象的指针，并将尝试为该对象调用析构函数。 XS源中将提供一个析构函数，以释放getnetconfigent（）使用的内存。在XS析构函数可以通过指定XSUB函数，其名称端以单词来创建&lt;b&gt;DESTROY&lt;/b&gt;。 XS析构函数可用于释放可能已由另一个XSUB分配的内存。</target>
        </trans-unit>
        <trans-unit id="63aaf3d4311946370f948fe1a874ef3b8b5e106b" translate="yes" xml:space="preserve">
          <source>The following XS file shows an XS subroutine, or XSUB, which demonstrates one possible interface to the rpcb_gettime() function. This XSUB represents a direct translation between C and Perl and so preserves the interface even from Perl. This XSUB will be invoked from Perl with the usage shown above. Note that the first three #include statements, for &lt;code&gt;EXTERN.h&lt;/code&gt; , &lt;code&gt;perl.h&lt;/code&gt; , and &lt;code&gt;XSUB.h&lt;/code&gt; , will always be present at the beginning of an XS file. This approach and others will be expanded later in this document. A #define for &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; should be present to fetch the interpreter context more efficiently, see &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt; for details.</source>
          <target state="translated">以下XS文件显示了XS子例程或XSUB，该子例程演示了rpcb_gettime（）函数的一个可能接口。该XSUB表示C和Perl之间的直接转换，因此即使从Perl保留接口也是如此。将使用上面显示的用法从Perl调用此XSUB。请注意，对于 &lt;code&gt;EXTERN.h&lt;/code&gt; ， &lt;code&gt;perl.h&lt;/code&gt; 和 &lt;code&gt;XSUB.h&lt;/code&gt; ，前三个#include语句将始终出现在XS文件的开头。此方法和其他方法将在本文档的后面部分进行扩展。应该提供一个针对 &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; 的#define，以更有效地获取解释器上下文，有关详细信息，请参见&lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d04933d03d9fe0141ffb2c1060f6f198f4e41d2" translate="yes" xml:space="preserve">
          <source>The following XS file shows an XS subroutine, or XSUB, which demonstrates one possible interface to the rpcb_gettime() function. This XSUB represents a direct translation between C and Perl and so preserves the interface even from Perl. This XSUB will be invoked from Perl with the usage shown above. Note that the first three #include statements, for &lt;code&gt;EXTERN.h&lt;/code&gt;, &lt;code&gt;perl.h&lt;/code&gt;, and &lt;code&gt;XSUB.h&lt;/code&gt;, will always be present at the beginning of an XS file. This approach and others will be expanded later in this document. A #define for &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; should be present to fetch the interpreter context more efficiently, see &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47250eb8cd4ed87f2a860c613d9258f03e5ab61" translate="yes" xml:space="preserve">
          <source>The following XSUB allows a Perl program to access a C library function called sin(). The XSUB will imitate the C function which takes a single argument and returns a single value.</source>
          <target state="translated">下面的XSUB允许Perl程序访问C库的函数sin()。这个XSUB将模仿C函数,接受一个参数并返回一个值。</target>
        </trans-unit>
        <trans-unit id="71f3a3c3ea9ed7f75901c1ba18beceaf1cdd2fef" translate="yes" xml:space="preserve">
          <source>The following XSUB is for a C function which requires special handling of its parameters. The Perl usage is given first.</source>
          <target state="translated">下面的XSUB是一个C函数,需要对其参数进行特殊处理。先给出Perl的用法。</target>
        </trans-unit>
        <trans-unit id="4f90e96487752832ff267e1d1e37b8167fdf3f66" translate="yes" xml:space="preserve">
          <source>The following XSUB uses the &lt;code&gt;SV *&lt;/code&gt; return type as a mnemonic only, and uses a CODE: block to indicate to the compiler that the programmer has supplied all the necessary code. The sv_newmortal() call will initialize the return value to undef, making that the default return value.</source>
          <target state="translated">以下XSUB仅将 &lt;code&gt;SV *&lt;/code&gt; 返回类型用作助记符，并使用CODE：块向编译器指示程序员已提供了所有必需的代码。sv_newmortal（）调用会将返回值初始化为undef，使其成为默认返回值。</target>
        </trans-unit>
        <trans-unit id="a1bc7555b268b447bf525bbb361d23e74ba70916" translate="yes" xml:space="preserve">
          <source>The following XSUB will call the C rpcb_gettime() function and will return its two output values, timep and status, to Perl as a single list.</source>
          <target state="translated">下面的XSUB将调用C语言中的rpcb_gettime()函数,并将其两个输出值timep和status以一个列表的形式返回给Perl。</target>
        </trans-unit>
        <trans-unit id="a13ba96373d895202485d58b843fc94572bbb6f9" translate="yes" xml:space="preserve">
          <source>The following XSUB will generate incorrect C code. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; with parameters &lt;code&gt;(char
*host, time_t timep)&lt;/code&gt; , but the real &lt;code&gt;rpcb_gettime()&lt;/code&gt; wants the &lt;code&gt;timep&lt;/code&gt; parameter to be of type &lt;code&gt;time_t*&lt;/code&gt; rather than &lt;code&gt;time_t&lt;/code&gt; .</source>
          <target state="translated">下面的XSUB将生成不正确的C代码。该&lt;b&gt;xsubpp&lt;/b&gt;编译器将它变成它调用代码 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 与参数 &lt;code&gt;(char *host, time_t timep)&lt;/code&gt; ，但真正 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 希望 &lt;code&gt;timep&lt;/code&gt; 参数为类型 &lt;code&gt;time_t*&lt;/code&gt; ，而不是 &lt;code&gt;time_t&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="4d8ca7ce02dc17e5f491e4977939dfb34745c228" translate="yes" xml:space="preserve">
          <source>The following XSUB will generate incorrect C code. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; with parameters &lt;code&gt;(char *host, time_t timep)&lt;/code&gt;, but the real &lt;code&gt;rpcb_gettime()&lt;/code&gt; wants the &lt;code&gt;timep&lt;/code&gt; parameter to be of type &lt;code&gt;time_t*&lt;/code&gt; rather than &lt;code&gt;time_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e3e7ea3cadf3d440df4d4dd029f14c329e3532" translate="yes" xml:space="preserve">
          <source>The following are Win32 multilanguage editor/IDEs that support Perl:</source>
          <target state="translated">以下是支持Perl的Win32多语言编辑器/IDE。</target>
        </trans-unit>
        <trans-unit id="878ebe02234cd6605f8faf412927071c9b53a803" translate="yes" xml:space="preserve">
          <source>The following are additions that have been requested, but I have been reluctant to add due to them being very simple to implement in perl</source>
          <target state="translated">以下是一些被要求添加的内容,但我一直不愿意添加,因为它们在perl中很容易实现。</target>
        </trans-unit>
        <trans-unit id="f30d9daa89e8ddd37f1202a1d64d4bf0b2c5e1f9" translate="yes" xml:space="preserve">
          <source>The following are all accessor methods -- that is, they don't do anything on their own, but just alter the contents of the conversion object, which comprises the options for this particular batch conversion.</source>
          <target state="translated">以下都是访问器方法--也就是说,它们本身并不做任何事情,只是改变转换对象的内容,其中包括这个特定批次转换的选项。</target>
        </trans-unit>
        <trans-unit id="cd4d07e071310dab311d4b0da4565a6a9fb7c1f6" translate="yes" xml:space="preserve">
          <source>The following are also defined by POSIX/SUSv3, but unfortunately not very widely implemented:</source>
          <target state="translated">以下也是POSIX/SUSv3定义的,但遗憾的是没有得到很广泛的实现。</target>
        </trans-unit>
        <trans-unit id="5b36027844e4806a69f430d629440d5e7ecab300" translate="yes" xml:space="preserve">
          <source>The following are common causes of compilation and/or execution failures, not common to Perl as such. The C FAQ is good bedtime reading. Please test your changes with as many C compilers and platforms as possible; we will, anyway, and it's nice to save oneself from public embarrassment.</source>
          <target state="translated">以下是编译和/或执行失败的常见原因,并非Perl常见的原因。C FAQ是很好的睡前读物。请用尽可能多的 C 编译器和平台来测试你的修改;无论如何,我们都会这样做的,而且这样做也很好,可以免去自己在公众面前的尴尬。</target>
        </trans-unit>
        <trans-unit id="e2853c6c7f110e3e4c7ed324a99e91a718ca2300" translate="yes" xml:space="preserve">
          <source>The following are exported:</source>
          <target state="translated">以下是输出的内容:</target>
        </trans-unit>
        <trans-unit id="7791b6ab4309dfc3ea821f7f1d4091cb49b39854" translate="yes" xml:space="preserve">
          <source>The following are fast conversions from ISO 8859-1 (Latin-1) bytes to UTF-8 bytes and back, the code works even with older Perl 5 versions.</source>
          <target state="translated">以下是ISO 8859-1 (Latin-1)字节到UTF-8字节的快速转换,即使在旧的Perl 5版本中也能使用。</target>
        </trans-unit>
        <trans-unit id="c852e811877cc6e9c98b0f2d5fb593ccfc901a95" translate="yes" xml:space="preserve">
          <source>The following are methods in the DB base class. A client must access these methods by inheritance (*not* by calling them directly), since the API keeps track of clients through the inheritance mechanism.</source>
          <target state="translated">以下是DB基类中的方法。客户端必须通过继承来访问这些方法(*不是直接调用它们),因为API通过继承机制来跟踪客户端。</target>
        </trans-unit>
        <trans-unit id="10865635be3faf44cc57e9f25634d2220e52c67d" translate="yes" xml:space="preserve">
          <source>The following are such interfaces. Also, see &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot;&lt;/a&gt;. For all of these interfaces Perl currently (as of v5.16.0) simply assumes byte strings both as arguments and results, or UTF-8 strings if the (deprecated) &lt;code&gt;encoding&lt;/code&gt; pragma has been used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3c274cc89ec17e7b845a436f38d1540dbbe5c4" translate="yes" xml:space="preserve">
          <source>The following are such interfaces. Also, see &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;. For all of these interfaces Perl currently (as of v5.16.0) simply assumes byte strings both as arguments and results, or UTF-8 strings if the (deprecated) &lt;code&gt;encoding&lt;/code&gt; pragma has been used.</source>
          <target state="translated">以下是此类接口。另请参见&lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;Unicode错误&lt;/a&gt;。对于所有这些接口，Perl当前（自v5.16.0起）仅假设字节字符串作为参数和结果，如果使用（不推荐使用的） &lt;code&gt;encoding&lt;/code&gt; 编译指示，则假定UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="5bd9bb59d1e1fb0197ed7d9b93043408c8c9a510" translate="yes" xml:space="preserve">
          <source>The following are the built-in attributes for subroutines:</source>
          <target state="translated">以下是子程序的内置属性。</target>
        </trans-unit>
        <trans-unit id="e8e3f6674cdb74d0958b2c8c99d763306f790276" translate="yes" xml:space="preserve">
          <source>The following are the built-in attributes for variables:</source>
          <target state="translated">以下是变量的内置属性。</target>
        </trans-unit>
        <trans-unit id="ff4fdef880964ea16866f7dda3f218be964bbbac" translate="yes" xml:space="preserve">
          <source>The following are unsupported due to the lack of mapping data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d2f2e3af66effdb52e3d7832a18951cdcafd9d0" translate="yes" xml:space="preserve">
          <source>The following are valid ($t1 and $t2 are Time::Piece objects):</source>
          <target state="translated">以下是有效的($t1和$t2是Time::Piece对象)。</target>
        </trans-unit>
        <trans-unit id="cbc24e337c1d628f49530f574e24235d24a7392e" translate="yes" xml:space="preserve">
          <source>The following article by Sean M. Burke and Jordan Lachler first appeared in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5045c4560d45f5e572e375de5ca429c353310df0" translate="yes" xml:space="preserve">
          <source>The following assume that the error has been copied into a separate scalar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f353aa81f91d6dfefc37a9410a376bf8429ba4d4" translate="yes" xml:space="preserve">
          <source>The following attributes may be specified as arguments to WriteMakefile() or as NAME=VALUE pairs on the command line. Attributes that became available with later versions of MakeMaker are indicated.</source>
          <target state="translated">以下属性可以作为WriteMakefile()的参数或在命令行中作为NAME=VALUE对来指定。在MakeMaker的后期版本中,会显示出可用的属性。</target>
        </trans-unit>
        <trans-unit id="b84f68ccf7654a835d7d4e99c76422bf128a4813" translate="yes" xml:space="preserve">
          <source>The following blocks are more or less equivalent:</source>
          <target state="translated">以下各块内容或多或少是相当的。</target>
        </trans-unit>
        <trans-unit id="8676339e37a5a253bdb0cffb28423c7698d023a0" translate="yes" xml:space="preserve">
          <source>The following boolean methods are useful in determining the</source>
          <target state="translated">以下布尔方法可用于确定</target>
        </trans-unit>
        <trans-unit id="b20d8378cbbcad7ea8e16d1f3872a95fae060afe" translate="yes" xml:space="preserve">
          <source>The following bzip2 constants are exported by this module</source>
          <target state="translated">本模块导出了以下bzip2常量</target>
        </trans-unit>
        <trans-unit id="f401e4eb4fd748677014cc2aaf006246c60d726e" translate="yes" xml:space="preserve">
          <source>The following checks are currently performed:</source>
          <target state="translated">目前正在进行以下检查:</target>
        </trans-unit>
        <trans-unit id="a62f3d4985ed23dc7ef4b06d5778fb97c9f68862" translate="yes" xml:space="preserve">
          <source>The following code demonstrates how to supply initialization code for function parameters. The initialization code is eval'ed within double quotes by the compiler before it is added to the output so anything which should be interpreted literally [mainly &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , or &lt;code&gt;\\&lt;/code&gt; ] must be protected with backslashes. The variables &lt;code&gt;$var&lt;/code&gt; , &lt;code&gt;$arg&lt;/code&gt; , and &lt;code&gt;$type&lt;/code&gt; can be used as in typemaps.</source>
          <target state="translated">以下代码演示了如何为函数参数提供初始化代码。初始化代码被编译器双引号内eval'ed之前，它被添加到输出，所以，只要应字面解释[主要 &lt;code&gt;$&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; ，或 &lt;code&gt;\\&lt;/code&gt; ]必须用反斜杠保护。变量 &lt;code&gt;$var&lt;/code&gt; ， &lt;code&gt;$arg&lt;/code&gt; 和 &lt;code&gt;$type&lt;/code&gt; 可以在类型映射中使用。</target>
        </trans-unit>
        <trans-unit id="9746ef7b7145a5c34d6668413bb27b113b96441f" translate="yes" xml:space="preserve">
          <source>The following code demonstrates how to supply initialization code for function parameters. The initialization code is eval'ed within double quotes by the compiler before it is added to the output so anything which should be interpreted literally [mainly &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, or &lt;code&gt;\\&lt;/code&gt;] must be protected with backslashes. The variables &lt;code&gt;$var&lt;/code&gt;, &lt;code&gt;$arg&lt;/code&gt;, and &lt;code&gt;$type&lt;/code&gt; can be used as in typemaps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994718a63d0e6e92c9d2b82a651bf83693f2d577" translate="yes" xml:space="preserve">
          <source>The following code opens up an output handle that will convert any output to a hexadecimal dump of the output bytes: for example &quot;A&quot; will be converted to &quot;41&quot; (on ASCII-based machines, on EBCDIC platforms the &quot;A&quot; will become &quot;c1&quot;)</source>
          <target state="translated">下面的代码打开了一个输出句柄,它将把任何输出转换为输出字节的十六进制转储:例如 &quot;A &quot;将被转换为 &quot;41&quot;(在基于ASCII的机器上,在EBCDIC平台上,&quot;A &quot;将变成 &quot;c1&quot;)。</target>
        </trans-unit>
        <trans-unit id="b646612d9dad6d0db0d9ef47258da28b3b64f1c7" translate="yes" xml:space="preserve">
          <source>The following code will build up an ASCII string saying &lt;code&gt;'PerlPerlPerl'&lt;/code&gt; . The comments show the string after each step. Note that this code works in the same way on big-endian or little-endian machines.</source>
          <target state="translated">以下代码将构建一个 &lt;code&gt;'PerlPerlPerl'&lt;/code&gt; 的ASCII字符串。注释显示每个步骤之后的字符串。请注意，此代码在big-endian或little-endian机器上以相同的方式工作。</target>
        </trans-unit>
        <trans-unit id="036e8023d85aa6d81194f031f72a68fa7f59b794" translate="yes" xml:space="preserve">
          <source>The following code will build up an ASCII string saying &lt;code&gt;'PerlPerlPerl'&lt;/code&gt;. The comments show the string after each step. Note that this code works in the same way on big-endian or little-endian machines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67a84b8d82f9d95c5a2c0536fda7094ec319c8b" translate="yes" xml:space="preserve">
          <source>The following code works for single-level arrays. It uses a stringwise comparison, and does not distinguish defined versus undefined empty strings. Modify if you have other needs.</source>
          <target state="translated">以下代码适用于单层数组。它使用的是字符串比较,并且不区分定义的和未定义的空字符串。如果你有其他需要,请修改。</target>
        </trans-unit>
        <trans-unit id="b42ca297dfa48bfb8bd9e9eb19ab8d4d7764f6d5" translate="yes" xml:space="preserve">
          <source>The following collations all make sense and you may meet any of them if you &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; .</source>
          <target state="translated">下列排序规则都很有意义，如果您 &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; 则可能会遇到其中的任何一种。</target>
        </trans-unit>
        <trans-unit id="0c757c0b2a139bcc3c8432fda1a1f80dbad9e220" translate="yes" xml:space="preserve">
          <source>The following collations all make sense and you may meet any of them if you &lt;code&gt;&quot;use locale&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5819e2e60b0b7a2348ddc793c274025d6f7880f" translate="yes" xml:space="preserve">
          <source>The following command characters are defined:</source>
          <target state="translated">定义了以下命令字符。</target>
        </trans-unit>
        <trans-unit id="94b38038de165a0daa7082711aa19c3a2036cf7d" translate="yes" xml:space="preserve">
          <source>The following command line switches behave differently under VMS than described in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. Note also that in order to pass uppercase switches to Perl, you need to enclose them in double-quotes on the command line, since the CRTL downcases all unquoted strings.</source>
          <target state="translated">以下命令行开关在VMS下的行为不同于&lt;a href=&quot;perlrun&quot;&gt;perlrun中&lt;/a&gt;描述的行为。还要注意，为了将大写的开关传递给Perl，您需要在命令行上将它们用双引号引起来，因为CRTL会将所有未用引号引起来的字符串都转换为小写。</target>
        </trans-unit>
        <trans-unit id="52448ab44f7b84ff23c0bb42cd9a8e27687108c1" translate="yes" xml:space="preserve">
          <source>The following command shows how to compute digests for typical inputs such as the NIST test vector &quot;abc&quot;:</source>
          <target state="translated">下面的命令显示了如何计算典型输入的摘要,如NIST测试向量 &quot;abc&quot;。</target>
        </trans-unit>
        <trans-unit id="ab2ed20fd1e01c9d474d41404b2754af8ec50648" translate="yes" xml:space="preserve">
          <source>The following compilation warnings may happen in HP-UX releases earlier than 11.31 but are harmless:</source>
          <target state="translated">在11.31之前的HP-UX版本中可能会发生以下编译警告,但无害。</target>
        </trans-unit>
        <trans-unit id="3f82c625cf5e705c9b15fb1534c5c11410cab28f" translate="yes" xml:space="preserve">
          <source>The following compiler versions are currently supported by IBM:</source>
          <target state="translated">目前IBM支持以下编译器版本。</target>
        </trans-unit>
        <trans-unit id="f0ad64f79a84fc4d8e60a250b5c99592e7f5b9c7" translate="yes" xml:space="preserve">
          <source>The following compound statements may be used to control flow:</source>
          <target state="translated">以下复合语句可用于控制流量。</target>
        </trans-unit>
        <trans-unit id="a4b58da98f934bf4b5cdd1337624b0bd2ba9de07" translate="yes" xml:space="preserve">
          <source>The following compression formats are supported by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd012592d06772e0ce9bcaaa2cfc233e60576f7d" translate="yes" xml:space="preserve">
          <source>The following constants may be returned by getaddrinfo() or getnameinfo(). Others may be provided by the OS.</source>
          <target state="translated">以下常量可以由getaddrinfo()或getnameinfo()返回。其他常量可能由操作系统提供。</target>
        </trans-unit>
        <trans-unit id="b842779c0173418719ebe5c2a7970e42d7d014a5" translate="yes" xml:space="preserve">
          <source>The following constants may be supplied as $xflags.</source>
          <target state="translated">以下常量可以作为$xflags提供。</target>
        </trans-unit>
        <trans-unit id="1be3497b66f11b1f18ed534aa513910c71b80ff0" translate="yes" xml:space="preserve">
          <source>The following debugger is actually useful:</source>
          <target state="translated">下面的调试器其实很有用。</target>
        </trans-unit>
        <trans-unit id="becc45c3efb50622f9f813d964b04c0775034a75" translate="yes" xml:space="preserve">
          <source>The following describes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c779f6e32c9824a654c3d3bb9768a1c5fd1243ca" translate="yes" xml:space="preserve">
          <source>The following description of methods is still under development. Please refer to the code for not suitably documented sections and complain loudly to the makemaker@perl.org mailing list. Better yet, provide a patch.</source>
          <target state="translated">以下方法的描述仍在开发中。请参考代码中不合适的文档部分,并向 makemaker@perl.org 邮件列表大声抱怨。最好是提供一个补丁。</target>
        </trans-unit>
        <trans-unit id="b3965f0e7b97198aca0dad023bdfa649bc3d7a07" translate="yes" xml:space="preserve">
          <source>The following documentation describes how to use FATAL warnings but the perl5 porters strongly recommend that you understand the risks before doing so, especially for library code intended for use by others, as there is no way for downstream users to change the choice of fatal categories.</source>
          <target state="translated">下面的文档介绍了如何使用 fatal 警告,但 perl5 移植者强烈建议您在这样做之前先了解风险,尤其是对于打算给他人使用的库代码,因为下游用户没有办法更改 fatal 类别的选择。</target>
        </trans-unit>
        <trans-unit id="a7395fbf98116a6fe303ce2ccf2e783d73f2e981" translate="yes" xml:space="preserve">
          <source>The following efficiently counts the number of set bits in a bit vector:</source>
          <target state="translated">下面有效地计算一个位向量中的设置位数。</target>
        </trans-unit>
        <trans-unit id="b85e86d2a59836c1bf602fd66fd49161e113bc9d" translate="yes" xml:space="preserve">
          <source>The following encodings are always available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb10534c1168ba80ae676bc74fad8ea1b177125" translate="yes" xml:space="preserve">
          <source>The following encodings are not supported as yet; some because they are rarely used, some because of technical difficulties. They may be supported by external modules via CPAN in the future, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2679279cde508d70a24c6c066ec89faf688d0162" translate="yes" xml:space="preserve">
          <source>The following entries are used during installation &amp;amp; testing on the libnet package</source>
          <target state="translated">在libnet软件包的安装和测试过程中使用以下条目</target>
        </trans-unit>
        <trans-unit id="f9b777d6ecffc2871fa8ad1bd878e3ae6a3e84c6" translate="yes" xml:space="preserve">
          <source>The following environment variables are not specific to Perl: They are part of the standardized (ISO C, XPG4, POSIX 1.c) &lt;code&gt;setlocale()&lt;/code&gt; method for controlling an application's opinion on data. Windows is non-POSIX, but Perl arranges for the following to work as described anyway. If the locale given by an environment variable is not valid, Perl tries the next lower one in priority. If none are valid, on Windows, the system default locale is then tried. If all else fails, the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale is used. If even that doesn't work, something is badly broken, but Perl tries to forge ahead with whatever the locale settings might be.</source>
          <target state="translated">以下环境变量不是Perl特有的：它们是用于控制应用程序对数据的意见的标准化（ISO C，XPG4，POSIX 1.c） &lt;code&gt;setlocale()&lt;/code&gt; 方法的一部分。Windows不是POSIX，但是Perl仍然按照以下说明安排以下工作。如果环境变量给定的语言环境无效，则Perl优先尝试下一个较低的语言环境。如果没有一个有效，则在Windows上尝试系统默认语言环境。如果所有其他方法均失败，则使用 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 语言环境。即使不起作用，也会严重破坏某些内容，但是Perl会尝试使用任何区域设置进行尝试。</target>
        </trans-unit>
        <trans-unit id="ec33aa555d27541d5a7185de1c1d5ba6a82fafba" translate="yes" xml:space="preserve">
          <source>The following equivalences hold (assuming &lt;code&gt;$#a &amp;gt;= $i&lt;/code&gt; )</source>
          <target state="translated">保持以下等价关系（假设 &lt;code&gt;$#a &amp;gt;= $i&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="85ca43521cd7775d8d33759b4074f5573158c1e6" translate="yes" xml:space="preserve">
          <source>The following error handling mechanism is considered experimental and is subject to change pending feedback from users.</source>
          <target state="translated">以下错误处理机制被认为是试验性的,可能会根据用户的反馈进行修改。</target>
        </trans-unit>
        <trans-unit id="31f04627eff0a8273cc4b4ecad29c912ce9d0e0e" translate="yes" xml:space="preserve">
          <source>The following error handling mechanism is consistent throughout all code paths EXCEPT in cases where the ROOT node is nonexistent. In version 2.11 the maintainers attempted to rectify this inconsistency but too many downstream modules encountered problems. In such case, if you require root node evaluation or error checking prior to calling &lt;code&gt;make_path&lt;/code&gt; or &lt;code&gt;remove_tree&lt;/code&gt;, you should take additional precautions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd63c469244aad9fa5f13ff0ec636281c8ddaf6b" translate="yes" xml:space="preserve">
          <source>The following error occurs because of the Cygwin &lt;code&gt;#define&lt;/code&gt; of &lt;code&gt;_LONG_DOUBLE&lt;/code&gt; :</source>
          <target state="translated">由于 &lt;code&gt;_LONG_DOUBLE&lt;/code&gt; 的Cygwin &lt;code&gt;#define&lt;/code&gt; 而发生以下错误：</target>
        </trans-unit>
        <trans-unit id="21e6156937fd6a5960b9a95ea9a5b12a0208719f" translate="yes" xml:space="preserve">
          <source>The following error occurs because of the Cygwin &lt;code&gt;#define&lt;/code&gt; of &lt;code&gt;_LONG_DOUBLE&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8339d5177634294fee1f0a35f0053c9114caf8" translate="yes" xml:space="preserve">
          <source>The following errors were encountered while parsing the POD:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6803ff3ff7c0a56cc9e903a6a90daace782e458" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, and in transliterations whose delimiters aren't single quotes (&lt;code&gt;&quot;'&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e111335c40da2391bb6d2b1d90ed4f7cf911e6e5" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, and in transliterations:</source>
          <target state="translated">下列转义序列可用于内插的构造和转写中。</target>
        </trans-unit>
        <trans-unit id="82159e16248ad6f2c09cd225ffdcbbf320f234ef" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, but not in transliterations.</source>
          <target state="translated">以下转义序列在内插的结构中可用,但在转写中不可用。</target>
        </trans-unit>
        <trans-unit id="62d1bc8a7a340748e143b5a954b697a1e9a92d04" translate="yes" xml:space="preserve">
          <source>The following example contains all supported keywords and structures with the exception of &lt;code&gt;eexpect&lt;/code&gt; which can be used instead of &lt;code&gt;expect&lt;/code&gt; .</source>
          <target state="translated">下面的示例包含所有支持的关键字和结构的除外 &lt;code&gt;eexpect&lt;/code&gt; 可以用来代替 &lt;code&gt;expect&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8665fd8b339dfb9b20108d0f4ac2879711d7bca" translate="yes" xml:space="preserve">
          <source>The following example counts all the possible matching strings in a pattern (without actually matching any of them).</source>
          <target state="translated">下面的例子计算了一个模式中所有可能匹配的字符串(而不是实际匹配其中的任何一个)。</target>
        </trans-unit>
        <trans-unit id="b54547ad1ef83c76b354b1c5c3bcd26f7c112217" translate="yes" xml:space="preserve">
          <source>The following example implements a simple daemon, which restarts itself every time the &lt;code&gt;SIGHUP&lt;/code&gt; signal is received. The actual code is located in the subroutine &lt;code&gt;code()&lt;/code&gt; , which just prints some debugging info to show that it works; it should be replaced with the real code.</source>
          <target state="translated">以下示例实现了一个简单的守护程序，该守护程序在每次收到 &lt;code&gt;SIGHUP&lt;/code&gt; 信号时都会重新启动。实际的代码位于子例程 &lt;code&gt;code()&lt;/code&gt; 中，该子例程仅打印一些调试信息以表明其有效。应将其替换为真实代码。</target>
        </trans-unit>
        <trans-unit id="72ef6e9fa58ad7d92fd5d070a5b1ff44ddb10726" translate="yes" xml:space="preserve">
          <source>The following example implements a simple daemon, which restarts itself every time the &lt;code&gt;SIGHUP&lt;/code&gt; signal is received. The actual code is located in the subroutine &lt;code&gt;code()&lt;/code&gt;, which just prints some debugging info to show that it works; it should be replaced with the real code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db59d80ee391c290c8e0098f7b4cb5a921d343a" translate="yes" xml:space="preserve">
          <source>The following example shows a variation of the rpcb_gettime() function. This function uses the timep variable only as an output variable and does not care about its initial contents.</source>
          <target state="translated">下面的例子显示了rpcb_gettime()函数的一个变体。这个函数只使用timep变量作为输出变量,并不关心它的初始内容。</target>
        </trans-unit>
        <trans-unit id="6e5930c0e8a4086018f7b728e0496b7b5959e325" translate="yes" xml:space="preserve">
          <source>The following example shows how the input parameter &lt;code&gt;timep&lt;/code&gt; can be evaluated late, after a PREINIT.</source>
          <target state="translated">下面的示例示出了如何输入参数 &lt;code&gt;timep&lt;/code&gt; 可以后期进行评价，一个PREINIT之后。</target>
        </trans-unit>
        <trans-unit id="f2d336b88b655db564d2a7de7cc37f5570d6138e" translate="yes" xml:space="preserve">
          <source>The following example will create aliases &lt;code&gt;FOO::gettime()&lt;/code&gt; and &lt;code&gt;BAR::getit()&lt;/code&gt; for this function.</source>
          <target state="translated">下面的示例将为此函数创建别名 &lt;code&gt;FOO::gettime()&lt;/code&gt; 和 &lt;code&gt;BAR::getit()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97da872b2dd68324aaeb980a55e38dbf65cc1f09" translate="yes" xml:space="preserve">
          <source>The following example will import the &lt;code&gt;langinfo()&lt;/code&gt; function itself and three constants to be used as arguments to &lt;code&gt;langinfo()&lt;/code&gt; : a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="translated">下面的示例将导入 &lt;code&gt;langinfo()&lt;/code&gt; 函数本身和三个常量，这些变量将用作 &lt;code&gt;langinfo()&lt;/code&gt; 的参数：一个缩写为一周中第一天的常量（从星期日= 1开始编号），另一个为常量为常数和在当前语言环境中对是/否问题的否定答案。</target>
        </trans-unit>
        <trans-unit id="fa3452b428040cf2c56efc56c05eb14116e2d423" translate="yes" xml:space="preserve">
          <source>The following example will import the &lt;code&gt;langinfo()&lt;/code&gt; function itself and three constants to be used as arguments to &lt;code&gt;langinfo()&lt;/code&gt;: a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68fe38084e5e619d96b5a9797595ec407ba06c97" translate="yes" xml:space="preserve">
          <source>The following example will import the langinfo() function itself and three constants to be used as arguments to langinfo(): a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="translated">下面的例子将导入langinfo()函数本身和三个常量作为langinfo()的参数:一个常量用于表示一周中的第一天的缩写(编号从周日开始=1),另外两个常量用于表示当前语言环境下是/否问题的肯定和否定答案。</target>
        </trans-unit>
        <trans-unit id="1d1e35923d66b27df87bbd4951c7d28f5e911d07" translate="yes" xml:space="preserve">
          <source>The following example will start the XS code and will place all functions in a package named RPC.</source>
          <target state="translated">下面的例子将启动XS代码,并将所有函数放在一个名为RPC的包中。</target>
        </trans-unit>
        <trans-unit id="dcb1a8c644e732663ae2a1c5ba3b577a1beb1ffa" translate="yes" xml:space="preserve">
          <source>The following examples all demonstrate how &lt;code&gt;reduce&lt;/code&gt; could be used to implement the other list-reduction functions in this module. (They are not in fact implemented like this, but instead in a more efficient manner in individual C functions).</source>
          <target state="translated">以下示例均演示了如何使用 &lt;code&gt;reduce&lt;/code&gt; 来实现此模块中的其他列表缩减功能。（实际上并不是这样实现的，而是在各个C函数中以更有效的方式实现）。</target>
        </trans-unit>
        <trans-unit id="887954cfa884d676e908a97b64a1555b23e32dbf" translate="yes" xml:space="preserve">
          <source>The following examples are equivalent, but if the code is using complex typemaps then the first example is safer.</source>
          <target state="translated">下面的例子是等价的,但是如果代码使用的是复杂的类型图,那么第一个例子是比较安全的。</target>
        </trans-unit>
        <trans-unit id="49473e8ccd96036c2dcbbff4100727b567ca00bb" translate="yes" xml:space="preserve">
          <source>The following examples assume</source>
          <target state="translated">下面的例子假设</target>
        </trans-unit>
        <trans-unit id="c8963d9d7205dc5eeae0e9a51c29c23916de6bfc" translate="yes" xml:space="preserve">
          <source>The following examples don't attempt to show everything as that would be a monumental task, and, frankly, we don't want this manpage to be an internals document for Perl. The examples do demonstrate some basics of the raw Perl datatypes, and should suffice to get most determined people on their way. There are no guidewires or safety nets, nor blazed trails, so be prepared to travel alone from this point and on and, if at all possible, don't fall into the quicksand (it's bad for business).</source>
          <target state="translated">下面的例子并不试图展示所有的内容,因为那将是一项艰巨的任务,而且,坦率地说,我们不希望这个手册成为 Perl 的内部文档。这些例子确实展示了一些原始 Perl 数据类型的基础知识,应该足以让大多数有决心的人上路。这里没有导引线或安全网,也没有明文规定的小径,所以请准备好从这里开始独自旅行,如果可能的话,请不要掉进流沙中(这对生意不利)。</target>
        </trans-unit>
        <trans-unit id="6687cc4c1adb4921b8b4b2318949d366c6deb7ae" translate="yes" xml:space="preserve">
          <source>The following examples show standard binary, octal, decimal, and hexadecimal conversion. All examples return 250.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93e6ebc989a84ca950fac6b12d34738b1701d5f" translate="yes" xml:space="preserve">
          <source>The following extension layers are bundled with perl:</source>
          <target state="translated">以下扩展层与perl捆绑在一起。</target>
        </trans-unit>
        <trans-unit id="162be8fe3d219b0d9c97c2e524d7220d440e0dd3" translate="yes" xml:space="preserve">
          <source>The following extra flags are added:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7106b07b78b7a3440b3c0ad4f4323e11abe72903" translate="yes" xml:space="preserve">
          <source>The following extra operations are supported on both real and complex numbers:</source>
          <target state="translated">实数和复数都支持以下额外的操作。</target>
        </trans-unit>
        <trans-unit id="44559e75149012ee5d0aabd7169096ab8b9b70c9" translate="yes" xml:space="preserve">
          <source>The following feature bundles are available:</source>
          <target state="translated">可提供以下功能捆绑:</target>
        </trans-unit>
        <trans-unit id="bfb5fd7e91227c5f530d75f35f7920db7fa46141" translate="yes" xml:space="preserve">
          <source>The following file is certain to trigger a few errors at both runtime and compiletime:</source>
          <target state="translated">下面的文件肯定会在运行时和编译时引发一些错误。</target>
        </trans-unit>
        <trans-unit id="21aca79b002af6c026c59989c512a774a1e9d423" translate="yes" xml:space="preserve">
          <source>The following files were created.</source>
          <target state="translated">创建了以下文件:</target>
        </trans-unit>
        <trans-unit id="c2d8b9dded738fa01824e3880baab2ed9227058b" translate="yes" xml:space="preserve">
          <source>The following flag constants are recognised as $flags. Other flag constants may exist as provided by the OS.</source>
          <target state="translated">下列标志常量被认为是$flags。其他标志常量可能由操作系统提供。</target>
        </trans-unit>
        <trans-unit id="650acaa8d024a737244b8df389c437c35b54545d" translate="yes" xml:space="preserve">
          <source>The following flag constants are recognised in the $hints hash. Other flag constants may exist as provided by the OS.</source>
          <target state="translated">在$hints哈希中,以下标志常量被认可。其他标志常量可能由操作系统提供。</target>
        </trans-unit>
        <trans-unit id="8b04fa6f897518e44671c43d372c1d8cbb29d5b0" translate="yes" xml:space="preserve">
          <source>The following flag has been added in the Perl implementation for csh compatibility:</source>
          <target state="translated">为了与csh兼容,在Perl实现中加入了以下标志。</target>
        </trans-unit>
        <trans-unit id="50651d66e2238c03eee6171d8e3c138d824ff88d" translate="yes" xml:space="preserve">
          <source>The following flags and properties are for JSON::PP only. If you use any of these, you can't make your application run faster by replacing JSON::PP with JSON::XS. If you need these and also speed boost, you might want to try &lt;a href=&quot;Cpanel::JSON::XS&quot;&gt;Cpanel::JSON::XS&lt;/a&gt;, a fork of JSON::XS by Reini Urban, which supports some of these (with a different set of incompatibilities). Most of these historical flags are only kept for backward compatibility, and should not be used in a new application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd8e3861113caf88d2e286d8b55139fd349b7d0" translate="yes" xml:space="preserve">
          <source>The following flags would be nice to have but they would first need their own Augean stablemaster:</source>
          <target state="translated">以下旗帜是不错的选择,但它们首先需要自己的奥格马夫。</target>
        </trans-unit>
        <trans-unit id="e731ee95c2996f14c508bcbd1c142f7cd0808c33" translate="yes" xml:space="preserve">
          <source>The following four convenience wrappers may be used to obtain one of the two values returned here. If both host and service names are required, this method is preferable to the following wrappers, because it will call &lt;code&gt;getnameinfo(3)&lt;/code&gt; only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9100eb4e02b3634a97be9d3c35013fdbb0474e55" translate="yes" xml:space="preserve">
          <source>The following four files sum up all the details discussed so far.</source>
          <target state="translated">以下四个文件总结了迄今为止讨论的所有细节。</target>
        </trans-unit>
        <trans-unit id="c34a482a0a61764634c9a647354d1ae932661df4" translate="yes" xml:space="preserve">
          <source>The following function copies a string into an SV whose reference is &lt;code&gt;rv&lt;/code&gt; . Set length to 0 to let Perl calculate the string length. SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">以下函数将字符串复制到引用为 &lt;code&gt;rv&lt;/code&gt; 的SV中。将length设置为0可让Perl计算字符串长度。如果 &lt;code&gt;classname&lt;/code&gt; 不为null，则SV被祝福。</target>
        </trans-unit>
        <trans-unit id="d572303a215881dcd48f5b462f35572b6b301a6c" translate="yes" xml:space="preserve">
          <source>The following function copies a string into an SV whose reference is &lt;code&gt;rv&lt;/code&gt;. Set length to 0 to let Perl calculate the string length. SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c0cf226e396fa1b152052f0820e83e7d855fd95" translate="yes" xml:space="preserve">
          <source>The following function copies the pointer value (</source>
          <target state="translated">以下函数复制指针值(</target>
        </trans-unit>
        <trans-unit id="2e073fa19276cae1009d363a0e5463744a8cdb65" translate="yes" xml:space="preserve">
          <source>The following function is available on Perls built on 64 bit OpenVMS v8.2 with hard links enabled on an ODS-5 formatted build disk. CRTL support is in principle available as of OpenVMS v7.3-1, and better configuration support could detect this.</source>
          <target state="translated">以下功能在64位OpenVMS v8.2上构建的Perls上是可用的,并且在ODS-5格式化的构建盘上启用了硬链接。CRTL支持原则上在OpenVMS v7.3-1时就可以使用,更好的配置支持可以检测到这一点。</target>
        </trans-unit>
        <trans-unit id="1d791c23038d9fe8780d570ab1f25e41c2c30bfa" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is a reference to a blessed object.</source>
          <target state="translated">下面的函数测试SV是否是对受祝福对象的引用。</target>
        </trans-unit>
        <trans-unit id="e97d512753d6d3628f54f7cc67945848127ebcd9" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is blessed into the specified class. It does not check inheritance relationships.</source>
          <target state="translated">以下函数测试SV是否被祝福到指定的类中。它不检查继承关系。</target>
        </trans-unit>
        <trans-unit id="df3aa6043ddcb399a0be1d9f05fb30512b44c0e8" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is derived from the specified class. SV can be either a reference to a blessed object or a string containing a class name. This is the function implementing the &lt;code&gt;UNIVERSAL::isa&lt;/code&gt; functionality.</source>
          <target state="translated">以下函数测试SV是否从指定的类派生。SV可以是对祝福对象的引用，也可以是包含类名的字符串。这是实现 &lt;code&gt;UNIVERSAL::isa&lt;/code&gt; 功能的函数。</target>
        </trans-unit>
        <trans-unit id="f2556ab0e8df33f1383226a4c6f98cdd750d952a" translate="yes" xml:space="preserve">
          <source>The following function upgrades rv to reference if not already one. Creates a new SV for rv to point to. If &lt;code&gt;classname&lt;/code&gt; is non-null, the SV is blessed into the specified class. SV is returned.</source>
          <target state="translated">以下功能将rv升级为参考（如果尚未添加）。为rv指向创建一个新的SV。如果 &lt;code&gt;classname&lt;/code&gt; 为非null，则SV被祝福进入指定的类。SV返回。</target>
        </trans-unit>
        <trans-unit id="29dc5cc89743cc721a2ee3907403e1585ed5aaa4" translate="yes" xml:space="preserve">
          <source>The following functions</source>
          <target state="translated">职能如下</target>
        </trans-unit>
        <trans-unit id="d058fd87c96266d5fdc51527ace77cd0d78cdd43" translate="yes" xml:space="preserve">
          <source>The following functions all perform some useful activity on reference values.</source>
          <target state="translated">以下函数都对参考值进行了一些有用的操作。</target>
        </trans-unit>
        <trans-unit id="2911d89162772ba03d36f6973e469a4101bb2cc6" translate="yes" xml:space="preserve">
          <source>The following functions are Perl implementations of the mktemp() family of temp file generation system calls.</source>
          <target state="translated">下面的函数是Perl中mktemp()系列临时文件生成系统调用的实现。</target>
        </trans-unit>
        <trans-unit id="e0a3d6bc866a23a74bfc5cb99a24046225a27424" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on 64 bit OpenVMS v8.2 and later.</source>
          <target state="translated">以下功能在64位OpenVMS v8.2及以后版本的Perls中可用。</target>
        </trans-unit>
        <trans-unit id="c3192aa510cfad4d7ff0a5d49cbe59b87b3bf2ce" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on 64 bit OpenVMS v8.2 and later. CRTL support is in principle available as of OpenVMS v7.3-2, and better configuration support could detect this.</source>
          <target state="translated">以下功能在64位OpenVMS v8.2及以后版本的Perls上可用。CRTL支持原则上从OpenVMS v7.3-2开始就可以使用,更好的配置支持可以检测到这一点。</target>
        </trans-unit>
        <trans-unit id="9298194e3e006b8fbe7257f536dde080822b8c50" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on VMS 7.2 or greater:</source>
          <target state="translated">以下功能在VMS 7.2或更高版本的Perls上可用。</target>
        </trans-unit>
        <trans-unit id="5c953c5f1b476c550370e7b30065e8a151627682" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls compiled with Dec C 5.2 or greater and running VMS 7.0 or greater:</source>
          <target state="translated">以下函数在用Dec C 5.2或更高版本编译并运行VMS 7.0或更高版本的Perls中可用。</target>
        </trans-unit>
        <trans-unit id="1e205f409e70ccbdada46ad7374f5371cb998862" translate="yes" xml:space="preserve">
          <source>The following functions are available.</source>
          <target state="translated">有以下功能:</target>
        </trans-unit>
        <trans-unit id="5950979e93d5397c31fbc2a28b94b256eeabee34" translate="yes" xml:space="preserve">
          <source>The following functions are currently undocumented. If you use one of them, you may wish to consider creating and submitting documentation for it.</source>
          <target state="translated">以下功能目前还未被记录。如果您使用其中一个函数,您可能会考虑为其创建并提交文档。</target>
        </trans-unit>
        <trans-unit id="886ab3bb8b191680b7816c0256fd741faf8bc7ec" translate="yes" xml:space="preserve">
          <source>The following functions are defined in the &lt;code&gt;utf8::&lt;/code&gt; package by the Perl core. You do not need to say &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; to use these and in fact you should not say that unless you really want to have UTF-8 source code.</source>
          <target state="translated">Perl核心在 &lt;code&gt;utf8::&lt;/code&gt; 包中定义了以下功能。您不需要说 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 来使用它们，实际上，除非您真的想拥有UTF-8源代码，否则您不应该这样说。</target>
        </trans-unit>
        <trans-unit id="04035437cedd81d97c7436275ce862e9db956a98" translate="yes" xml:space="preserve">
          <source>The following functions are defined in the &lt;code&gt;utf8::&lt;/code&gt; package by the Perl core. You do not need to say &lt;code&gt;use utf8&lt;/code&gt; to use these and in fact you should not say that unless you really want to have UTF-8 source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d924d0242f33a4bd7b878adc5df25af14f3fc818" translate="yes" xml:space="preserve">
          <source>The following functions are exported by &lt;code&gt;Filter::Util::Call&lt;/code&gt; :</source>
          <target state="translated">以下函数由 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 导出：</target>
        </trans-unit>
        <trans-unit id="880d841885ac667bfdecc26d11ccfd01c2ab96a8" translate="yes" xml:space="preserve">
          <source>The following functions are exported by &lt;code&gt;Filter::Util::Call&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab0faf40d4a413b76ab20e1f7c9c1ce5f8e0b08" translate="yes" xml:space="preserve">
          <source>The following functions are exported by default.</source>
          <target state="translated">以下是默认导出的函数。</target>
        </trans-unit>
        <trans-unit id="f74d5f0be47eadceddfa059884e47684f407a94a" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module. Please note that these are functions (not methods) and therefore &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; not&lt;/code&gt; take an implicit first argument.</source>
          <target state="translated">以下功能由该模块导出。请注意，这些功能（而不是方法），因此 &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; not&lt;/code&gt; 采取隐式的第一个参数。</target>
        </trans-unit>
        <trans-unit id="ecbe41a265e73d2f25c7e96c76a4a747b067fbd6" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module: &lt;code&gt;share&lt;/code&gt; , &lt;code&gt;shared_clone&lt;/code&gt; , &lt;code&gt;is_shared&lt;/code&gt; , &lt;code&gt;cond_wait&lt;/code&gt; , &lt;code&gt;cond_timedwait&lt;/code&gt; , &lt;code&gt;cond_signal&lt;/code&gt; and &lt;code&gt;cond_broadcast&lt;/code&gt;</source>
          <target state="translated">下面的函数由该模块导出： &lt;code&gt;share&lt;/code&gt; ， &lt;code&gt;shared_clone&lt;/code&gt; ， &lt;code&gt;is_shared&lt;/code&gt; ， &lt;code&gt;cond_wait&lt;/code&gt; ， &lt;code&gt;cond_timedwait&lt;/code&gt; ， &lt;code&gt;cond_signal&lt;/code&gt; 和 &lt;code&gt;cond_broadcast&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a286ac22b6e657ba87cab3b6eff4036bd887933" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module: &lt;code&gt;share&lt;/code&gt;, &lt;code&gt;shared_clone&lt;/code&gt;, &lt;code&gt;is_shared&lt;/code&gt;, &lt;code&gt;cond_wait&lt;/code&gt;, &lt;code&gt;cond_timedwait&lt;/code&gt;, &lt;code&gt;cond_signal&lt;/code&gt; and &lt;code&gt;cond_broadcast&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="359dedf5643622ca4347a5ad1835485c0f626223" translate="yes" xml:space="preserve">
          <source>The following functions are exported only by request.</source>
          <target state="translated">以下函数仅应要求输出。</target>
        </trans-unit>
        <trans-unit id="6ff004aea51ff452f5a6a3680250ec66d08e006e" translate="yes" xml:space="preserve">
          <source>The following functions are not considered to be part of the public interface. They are documented here for the benefit of future maintainers of this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb1dbec7cc374a481e866646b73ca4b04e611a0" translate="yes" xml:space="preserve">
          <source>The following functions are now implemented in FastCalc.xs:</source>
          <target state="translated">以下函数现在在FastCalc.xs中实现。</target>
        </trans-unit>
        <trans-unit id="685959529a3484efa19ac7a3baaeafce45e37b9a" translate="yes" xml:space="preserve">
          <source>The following functions are provided by the &lt;code&gt;Digest::MD5&lt;/code&gt; module. None of these functions are exported by default.</source>
          <target state="translated">&lt;code&gt;Digest::MD5&lt;/code&gt; 模块提供以下功能。默认情况下，这些功能均不会导出。</target>
        </trans-unit>
        <trans-unit id="b8a73287c5b8efe7a8f104d252583b6712796202" translate="yes" xml:space="preserve">
          <source>The following functions are provided:</source>
          <target state="translated">提供了以下功能:</target>
        </trans-unit>
        <trans-unit id="cb80d66061f0196a6ca192d5341a430ee1b0eb26" translate="yes" xml:space="preserve">
          <source>The following functions are supported:</source>
          <target state="translated">支持以下功能:</target>
        </trans-unit>
        <trans-unit id="89bf61ba64cc618bf2874d4293a3aae6452f1aba" translate="yes" xml:space="preserve">
          <source>The following functions can be imported from this module. No functions are exported by default.</source>
          <target state="translated">以下函数可以从本模块导入。缺省情况下,没有函数被导出。</target>
        </trans-unit>
        <trans-unit id="76627ad7f894d0c3e9a81281fe41fe4c1c985047" translate="yes" xml:space="preserve">
          <source>The following functions check whether the string is in that normalization form.</source>
          <target state="translated">以下函数检查字符串是否为该规范化形式。</target>
        </trans-unit>
        <trans-unit id="a27da5eeba1599f572e14a8c9329aa08b0e2cd4f" translate="yes" xml:space="preserve">
          <source>The following functions convert between lists of Perl values and packed binary strings representing structures.</source>
          <target state="translated">以下函数在Perl值列表和代表结构的打包二进制字符串之间进行转换。</target>
        </trans-unit>
        <trans-unit id="2ccfd58b6052a416773b606e17f327b9dd3cd108" translate="yes" xml:space="preserve">
          <source>The following functions have been flagged as part of the public API, but are currently undocumented. Use them at your own risk, as the interfaces are subject to change. Functions that are not listed in this document are not intended for public use, and should NOT be used under any circumstances.</source>
          <target state="translated">以下函数已被标记为公共API的一部分,但目前还未被记录。由于接口可能会发生变化,因此使用这些函数时要自担风险。本文档中没有列出的函数不打算用于公共用途,在任何情况下都不应该使用。</target>
        </trans-unit>
        <trans-unit id="824636764a16367a90dfdeffbf74adccac69c5cb" translate="yes" xml:space="preserve">
          <source>The following functions in the &lt;code&gt;POSIX&lt;/code&gt; module are no longer available: &lt;code&gt;isalnum&lt;/code&gt;, &lt;code&gt;isalpha&lt;/code&gt;, &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;isgraph&lt;/code&gt;, &lt;code&gt;islower&lt;/code&gt;, &lt;code&gt;isprint&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, &lt;code&gt;isspace&lt;/code&gt;, &lt;code&gt;isupper&lt;/code&gt;, and &lt;code&gt;isxdigit&lt;/code&gt;. The functions are buggy and don't work on UTF-8 encoded strings. See their entries in &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f79fe7f0a766eea8a6363560d09b1b418f37a54" translate="yes" xml:space="preserve">
          <source>The following functions may or may not be implemented, depending on what type of socket support you've built into your copy of Perl:</source>
          <target state="translated">下面的函数可能会被实现,也可能不会被实现,这取决于你的Perl副本中内置了什么类型的socket支持。</target>
        </trans-unit>
        <trans-unit id="2d8b2c9f184b69863b362bc365b152ff7d6a2cc5" translate="yes" xml:space="preserve">
          <source>The following functions use &lt;code&gt;$_&lt;/code&gt; as a default argument:</source>
          <target state="translated">以下函数使用 &lt;code&gt;$_&lt;/code&gt; 作为默认参数：</target>
        </trans-unit>
        <trans-unit id="0dd434c67978a923f9ec0ee28d2a5538ba5682f6" translate="yes" xml:space="preserve">
          <source>The following functions were not implemented in the VMS port, and calling them produces a fatal error (usually) or undefined behavior (rarely, we hope):</source>
          <target state="translated">以下函数没有在 VMS port 中实现,而且调用它们会产生一个致命的错误 (通常)或未定义的行为 (我们希望很少)。</target>
        </trans-unit>
        <trans-unit id="cdfa439e416672c343b7c0368293d837f0c0576b" translate="yes" xml:space="preserve">
          <source>The following functions would all be inlined:</source>
          <target state="translated">以下功能将全部内联:</target>
        </trans-unit>
        <trans-unit id="f04cb90467492e19af66e5b899cfc303ddef4110" translate="yes" xml:space="preserve">
          <source>The following global variables are associated with arenas:</source>
          <target state="translated">以下全局变量与场馆有关:</target>
        </trans-unit>
        <trans-unit id="0d3412aee89bad6343f641caa3a5d4996443527e" translate="yes" xml:space="preserve">
          <source>The following illustrates use of the Benchmark object:</source>
          <target state="translated">下面说明Benchmark对象的使用。</target>
        </trans-unit>
        <trans-unit id="21c5c52868e5d5448c65efac8d8979602bb9419b" translate="yes" xml:space="preserve">
          <source>The following information applies to gcc version 2. Volunteers to update it as appropriately for gcc version 3 would be appreciated.</source>
          <target state="translated">以下信息适用于gcc版本2。如果有志愿者能根据gcc版本3适当地更新这些信息,将不胜感激。</target>
        </trans-unit>
        <trans-unit id="62ec6b5e797715143c688dee03c54b63962fd46a" translate="yes" xml:space="preserve">
          <source>The following interfaces are provided for compatibility with existing APIs. They should not be used in new code.</source>
          <target state="translated">提供以下接口是为了与现有API兼容。不应在新代码中使用。</target>
        </trans-unit>
        <trans-unit id="0bdb13054ff9ef26849b463627b5915db32807ca" translate="yes" xml:space="preserve">
          <source>The following is a long section of miscellaneous requirements and suggestions to do with Pod processing.</source>
          <target state="translated">下面长篇累牍地介绍与花苞加工有关的杂项要求和建议。</target>
        </trans-unit>
        <trans-unit id="9eebaea88bec8281bdda401db84ecb8529c5edbd" translate="yes" xml:space="preserve">
          <source>The following is an example of a typemap that could be used for this C++ example.</source>
          <target state="translated">下面是一个可以用于这个C++例子的类型映射的例子。</target>
        </trans-unit>
        <trans-unit id="a14c2ddd24e4bc7ed4b474606997260d2d723a26" translate="yes" xml:space="preserve">
          <source>The following is the old c2ph.doc documentation by Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt; Date: 25 Jul 91 08:10:21 GMT</source>
          <target state="translated">以下是Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;的旧c2ph.doc文档。日期：91 Jul 25 08:10:21 GMT</target>
        </trans-unit>
        <trans-unit id="838c8cc6acec4e734454e6016dba1f13113970de" translate="yes" xml:space="preserve">
          <source>The following is used to &lt;a href=&quot;deprecate&quot;&gt;deprecate&lt;/a&gt; core modules beyond a certain version of Perl:</source>
          <target state="translated">以下用于&lt;a href=&quot;deprecate&quot;&gt;淘汰&lt;/a&gt;某些版本的Perl之后的核心模块：</target>
        </trans-unit>
        <trans-unit id="0c3fbe199ab2c0c87ca2506f58ce4cc1ff1336a3" translate="yes" xml:space="preserve">
          <source>The following keys allowed for callbacks. These keys are case-sensitive.</source>
          <target state="translated">以下是允许回调的键。这些键是区分大小写的。</target>
        </trans-unit>
        <trans-unit id="ace2dc9ae3a6b314c56205001ea3e99826b29341" translate="yes" xml:space="preserve">
          <source>The following keys are optional.</source>
          <target state="translated">以下是可选的键:</target>
        </trans-unit>
        <trans-unit id="87593abf1938664ef0461a9fc202ad24f5f827db" translate="yes" xml:space="preserve">
          <source>The following keys are recognised in the option hash:</source>
          <target state="translated">在选项哈希中可以识别以下键。</target>
        </trans-unit>
        <trans-unit id="938c23249f0abe69d61c5caeb8c241a3b1c97b48" translate="yes" xml:space="preserve">
          <source>The following keys are valid, but only &lt;code&gt;version&lt;/code&gt; is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e29171b7f3395c93aba1c43b176e6a5f79f9da1" translate="yes" xml:space="preserve">
          <source>The following keys in the hash reference $CPAN::Config are currently defined:</source>
          <target state="translated">当前在哈希引用$CPAN::Config中定义了以下键。</target>
        </trans-unit>
        <trans-unit id="8faa1306b5e277a45ec730d9a598e8adafe08efc" translate="yes" xml:space="preserve">
          <source>The following layers are currently defined:</source>
          <target state="translated">目前定义的层级如下:</target>
        </trans-unit>
        <trans-unit id="d62e448414706bf58b56c68adcd155be3caa2f9f" translate="yes" xml:space="preserve">
          <source>The following license strings are also valid and indicate other licensing not described above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8819c5fc895570a060c0cc0274e5435ca8214190" translate="yes" xml:space="preserve">
          <source>The following line is taken from the testsuite for &lt;a href=&quot;http://search.cpan.org/perldoc/File::Map&quot;&gt;File::Map&lt;/a&gt;:</source>
          <target state="translated">以下行来自&lt;a href=&quot;http://search.cpan.org/perldoc/File::Map&quot;&gt;File :: Map&lt;/a&gt;的测试套件：</target>
        </trans-unit>
        <trans-unit id="b26a944c006c4ed66106c7db11bb76fd456329ff" translate="yes" xml:space="preserve">
          <source>The following lines are equivalent:</source>
          <target state="translated">以下行文相当于:</target>
        </trans-unit>
        <trans-unit id="f188bcdc507d79e65b8c87878e9261e514ba50b4" translate="yes" xml:space="preserve">
          <source>The following list of Unicode supported features for regular expressions describes all features currently directly supported by core Perl. The references to &quot;Level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27fa1a573ac1c2bd0bdaed0b154f8a047e4a778" translate="yes" xml:space="preserve">
          <source>The following list of Unicode supported features for regular expressions describes all features currently directly supported by core Perl. The references to &quot;Level N&quot; and the section numbers refer to the Unicode Technical Standard #18, &quot;Unicode Regular Expressions&quot;, version 13, from August 2008.</source>
          <target state="translated">下面的Unicode支持的正则表达式特性列表描述了目前核心Perl直接支持的所有特性。其中提到的 &quot;N级 &quot;和章节号指的是2008年8月的Unicode技术标准#18,&quot;Unicode正则表达式 &quot;第13版。</target>
        </trans-unit>
        <trans-unit id="fd9860b919a8b832481067980e3c3a381ec06f0c" translate="yes" xml:space="preserve">
          <source>The following list of license strings are valid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d2ac78ac8de1d9653897258388c5a4d402853b" translate="yes" xml:space="preserve">
          <source>The following macros must always be used to access the contents of hash entries. Note that the arguments to these macros must be simple variables, since they may get evaluated more than once. See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for detailed descriptions of these macros.</source>
          <target state="translated">必须始终使用以下宏来访问哈希条目的内容。请注意，这些宏的参数必须是简单变量，因为它们可能会被多次评估。有关这些宏的详细说明，请参见&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54cabd1569f977ca3a4b00bfe48c1954ef75d0d2" translate="yes" xml:space="preserve">
          <source>The following methods all return a boolean value and are to be overridden in the appropriate subclass.</source>
          <target state="translated">以下方法都返回一个布尔值,并在相应的子类中被重写。</target>
        </trans-unit>
        <trans-unit id="2e28c1a68a0ac1abaa1b238b7c5b433afa448fce" translate="yes" xml:space="preserve">
          <source>The following methods are available for all &lt;code&gt;Digest::&lt;/code&gt; modules:</source>
          <target state="translated">以下方法可用于所有 &lt;code&gt;Digest::&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="5d1a84015cfed0b396f9aadd71cc3704958e67dc" translate="yes" xml:space="preserve">
          <source>The following methods are available:</source>
          <target state="translated">可采用以下方法:</target>
        </trans-unit>
        <trans-unit id="9ab4dd7b2f4575f0fcc3274141eab6c5a7ca9278" translate="yes" xml:space="preserve">
          <source>The following methods are mandatory: _new(), _str(), _add(), and _sub(). However, computations will be very slow without _mul() and _div().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6f41c232d0f405651a2979e1a726ffd3fbd1cf" translate="yes" xml:space="preserve">
          <source>The following methods are not supported on a per-filehandle basis.</source>
          <target state="translated">以下方法不支持每个filehandle。</target>
        </trans-unit>
        <trans-unit id="e3dd1f8a67cafbd7d4b11fa3ef01a32bc5c44916" translate="yes" xml:space="preserve">
          <source>The following methods are ones you may wish to override if you want to subclass &lt;code&gt;TAP::Harness&lt;/code&gt; .</source>
          <target state="translated">如果要继承 &lt;code&gt;TAP::Harness&lt;/code&gt; 则可能希望覆盖以下方法。</target>
        </trans-unit>
        <trans-unit id="6e9f03dd5d9f58ae4081f60a8239d90f2810d056" translate="yes" xml:space="preserve">
          <source>The following methods are ones you may wish to override if you want to subclass &lt;code&gt;TAP::Harness&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679901c8aebeb73a7fa904b450ae5e241ed9cb03" translate="yes" xml:space="preserve">
          <source>The following methods are optional, and can be defined if the underlying lib has a fast way to do them. If undefined, Math::BigInt will use pure Perl (hence slow) fallback routines to emulate these:</source>
          <target state="translated">下面的方法是可选的,如果底层库有快速的方法,可以定义这些方法。如果未定义,Math::BigInt 将使用纯 Perl(因此速度很慢)的回退例程来模拟这些方法。</target>
        </trans-unit>
        <trans-unit id="d8157ae492dfb9da4aae902df688ee7d5be628f8" translate="yes" xml:space="preserve">
          <source>The following methods are provided in this module. Each one takes a reference to the object itself as an implicit first parameter.</source>
          <target state="translated">本模块提供了以下方法。每个方法都以对象本身的引用作为隐含的第一个参数。</target>
        </trans-unit>
        <trans-unit id="bde2e5da8041f121dd086d0f1594d72494846e0b" translate="yes" xml:space="preserve">
          <source>The following methods are provided:</source>
          <target state="translated">提供了以下方法:</target>
        </trans-unit>
        <trans-unit id="61fea790abe3137c314afb22029bb574c87067fd" translate="yes" xml:space="preserve">
          <source>The following methods are required for an API version of 2 or greater.</source>
          <target state="translated">以下方法是API版本2或更高版本所需要的。</target>
        </trans-unit>
        <trans-unit id="ec06d96f64f88685f2a77a047bae0d4b9b41fde8" translate="yes" xml:space="preserve">
          <source>The following methods are wrappers for the directory related functions built into perl (the trailing 'dir' has been removed from the names). See &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details of these functions.</source>
          <target state="translated">以下方法是perl内置的目录相关功能的包装器（名称中的尾部&amp;ldquo; dir&amp;rdquo;已删除）。有关这些功能的详细信息，请参见&lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ded7f0c3574ed832e686f908708c74d7bfabfc4b" translate="yes" xml:space="preserve">
          <source>The following methods are wrappers for the directory related functions built into perl (the trailing 'dir' has been removed from the names). See &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details of these functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570150b9609694e95e958423d380ac3c5369cdc3" translate="yes" xml:space="preserve">
          <source>The following methods can be used to manipulate items anywhere in a queue.</source>
          <target state="translated">以下方法可以用来操作队列中任何地方的项目。</target>
        </trans-unit>
        <trans-unit id="1cff87e9e5dce6950df4739edc1576de748d33e5" translate="yes" xml:space="preserve">
          <source>The following methods can be used to transfer files between two remote servers, providing that these two servers can connect directly to each other.</source>
          <target state="translated">以下方法可用于在两台远程服务器之间传输文件,前提是这两台服务器可以直接相互连接。</target>
        </trans-unit>
        <trans-unit id="d8f54c9acd776fdfe4ac513355a1096a098e49e7" translate="yes" xml:space="preserve">
          <source>The following methods can return different results depending on how they are called. If the user explicitly calls either of the &lt;code&gt;pasv&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; methods then these methods will return a</source>
          <target state="translated">以下方法可以根据调用方式返回不同的结果。如果用户显式调用 &lt;code&gt;pasv&lt;/code&gt; 或 &lt;code&gt;port&lt;/code&gt; 方法，则这些方法将返回一个</target>
        </trans-unit>
        <trans-unit id="48671c770c71c327c8f21494ae7c58eef76a7413" translate="yes" xml:space="preserve">
          <source>The following methods can then be used on the compartment object returned by the above constructor. The object argument is implicit in each case.</source>
          <target state="translated">然后,可以对上述构造函数返回的隔间对象使用以下方法。在每种情况下,对象参数都是隐式的。</target>
        </trans-unit>
        <trans-unit id="a9334f5feea4574b7400347c313e7ae3bde9f0a9" translate="yes" xml:space="preserve">
          <source>The following methods deal with queues on a FIFO basis.</source>
          <target state="translated">以下方法是在FIFO的基础上处理队列。</target>
        </trans-unit>
        <trans-unit id="1107701eeb6d8dce0fd7fc1f42599acf6178ec38" translate="yes" xml:space="preserve">
          <source>The following methods implement this incremental parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7cc6ee31a4cea12821df3d9ff6b6e073be7714" translate="yes" xml:space="preserve">
          <source>The following methods must be defined in order to support the use by Math::BigInt v1.70 or later.</source>
          <target state="translated">为了支持 Math::BigInt v1.70 或更高版本的使用,必须定义以下方法。</target>
        </trans-unit>
        <trans-unit id="280d5e97299a977b6fb2506b08e4d295925aa675" translate="yes" xml:space="preserve">
          <source>The following methods return a single value, which is the value for the corresponding entry in the distmeta structure. Values should be either undef or strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47bdf0bfe9cf16bdf842c1c20e389188ee7a3a8" translate="yes" xml:space="preserve">
          <source>The following methods upgrade themselves unconditionally; that is if upgrade is in effect, they always hands up their work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f23966e0bc23b8a5a278ce7e5e420b3556e28b8" translate="yes" xml:space="preserve">
          <source>The following methods upgrade themselves unconditionally; that is if upgrade is in effect, they will always hand up their work:</source>
          <target state="translated">以下方法是无条件升级自己的,也就是说如果升级生效,他们会一直交出自己的作品。</target>
        </trans-unit>
        <trans-unit id="4d85840c9544f4d1a9475cb2562273ab62746e95" translate="yes" xml:space="preserve">
          <source>The following methods, while usable from anywhere, are primarily intended for developers wishing to subclass &lt;code&gt;autodie::exception&lt;/code&gt;, write code that registers custom error messages, or otherwise work closely with the &lt;code&gt;autodie::exception&lt;/code&gt; model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="314022e0b634f0a33992a5bea72595f23a273937" translate="yes" xml:space="preserve">
          <source>The following modules are currently used by bigint:</source>
          <target state="translated">目前bigint使用的模块如下。</target>
        </trans-unit>
        <trans-unit id="086b35f723ebe590f75a1aea7b6b1150783292e6" translate="yes" xml:space="preserve">
          <source>The following modules are currently used by bignum:</source>
          <target state="translated">bignum目前使用的模块如下。</target>
        </trans-unit>
        <trans-unit id="d93609e5247b12617e4dd3f00cb7708916287a29" translate="yes" xml:space="preserve">
          <source>The following names have special meaning to Perl. Most punctuation names have reasonable mnemonics, or analogs in the shells. Nevertheless, if you wish to use long variable names, you need only say:</source>
          <target state="translated">以下名称对Perl有特殊意义。大多数标点符号名称都有合理的记忆符号,或者在shell中的类似符号。不过,如果你想使用长的变量名,你只需要说。</target>
        </trans-unit>
        <trans-unit id="8937b6a268204b01bd09b0791adaf0dc939c65b5" translate="yes" xml:space="preserve">
          <source>The following options affect what happens with &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;x&lt;/code&gt; commands:</source>
          <target state="translated">以下选项影响 &lt;code&gt;V&lt;/code&gt; ， &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 命令的操作：</target>
        </trans-unit>
        <trans-unit id="4a331658e3e1d7b8de900a2e68b72b832b1d4100" translate="yes" xml:space="preserve">
          <source>The following options affect what happens with &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ad7915cdbf5aabf9ec8f4e6f650717a3e51ad5" translate="yes" xml:space="preserve">
          <source>The following options are available:</source>
          <target state="translated">有以下选项:</target>
        </trans-unit>
        <trans-unit id="5530497eb21d4e6a6dcc738d7ea1b33bd3ad244e" translate="yes" xml:space="preserve">
          <source>The following options are pairwise exclusive.</source>
          <target state="translated">以下选项是成对的。</target>
        </trans-unit>
        <trans-unit id="82fa31556e7811972756a886a4cfa29a126dcd22" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the underlying text formatter. See the manual pages of these modules for more information.</source>
          <target state="translated">以下选项会传递给底层文本格式化器。更多信息请参见这些模块的手册页面。</target>
        </trans-unit>
        <trans-unit id="407cb3c611809d0d6a4a0229085dace99fab8aca" translate="yes" xml:space="preserve">
          <source>The following options are supported: center, date, fixed, fixedbold, fixeditalic, fixedbolditalic, quotes, release, section</source>
          <target state="translated">支持以下选项:居中、日期、固定、固定黑体、固定黑体、固定黑体、引号、发布、部分。</target>
        </trans-unit>
        <trans-unit id="7fa87a7b90e6843371b98a42bf443c041138aacf" translate="yes" xml:space="preserve">
          <source>The following pattern matches a function &lt;code&gt;foo()&lt;/code&gt; which may contain balanced parentheses as the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9719c919f328c184200e9a901169faf3fe1692f" translate="yes" xml:space="preserve">
          <source>The following pattern matches a function foo() which may contain balanced parentheses as the argument.</source>
          <target state="translated">下面的模式与函数foo()匹配,该函数可能包含平衡括号作为参数。</target>
        </trans-unit>
        <trans-unit id="88eac117835fd0d5e8fe0a92e17ee881d0f51bb6" translate="yes" xml:space="preserve">
          <source>The following pattern matches a parenthesized group:</source>
          <target state="translated">下面的模式与一个小括号组相匹配。</target>
        </trans-unit>
        <trans-unit id="22ee5be8d1198dc109b222871c61596812e4d6af" translate="yes" xml:space="preserve">
          <source>The following people have all contributed to this document in some way, even if only for review.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9261bf4cae54928a9960941cd2e6c763bb03b07b" translate="yes" xml:space="preserve">
          <source>The following platforms are known to build Perl 5.12 (as of April 2010, its release date) from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src&quot;&gt;http://www.cpan.org/src&lt;/a&gt;</source>
          <target state="translated">已知以下平台可从&lt;a href=&quot;http://www.cpan.org/src&quot;&gt;http://www.cpan.org/src上&lt;/a&gt;提供的标准源代码发行版中构建Perl 5.12（截至2010年4月，其发布日期）。</target>
        </trans-unit>
        <trans-unit id="6907367840204c62b96dad2c2b4daa026466da81" translate="yes" xml:space="preserve">
          <source>The following platforms have been known to build Perl from source in the past (5.005_03 and earlier), but we haven't been able to verify their status for the current release, either because the hardware/software platforms are rare or because we don't have an active champion on these platforms--or both. They used to work, though, so go ahead and try compiling them, and let &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; know of any trouble.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3340ff1c2b446edebeb559ea5dd147cf80639131" translate="yes" xml:space="preserve">
          <source>The following platforms have been known to build Perl from source in the past (5.005_03 and earlier), but we haven't been able to verify their status for the current release, either because the hardware/software platforms are rare or because we don't have an active champion on these platforms--or both. They used to work, though, so go ahead and try compiling them, and let perlbug@perl.org of any trouble.</source>
          <target state="translated">以下平台在过去(5.005_03及更早的版本)曾被认为可以从源码中构建Perl,但我们还无法验证它们在当前版本中的状态,这可能是因为这些硬件/软件平台很少,也可能是因为我们在这些平台上没有一个活跃的冠军--或者两者都有。不过,它们曾经是可以工作的,所以请继续尝试编译它们,如果有任何问题,请告诉perlbug@perl.org。</target>
        </trans-unit>
        <trans-unit id="8c95fcd90364c113c8743d95c16878f685bbdec9" translate="yes" xml:space="preserve">
          <source>The following platforms have only binaries available via &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; :</source>
          <target state="translated">以下平台只有通过&lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt;提供的二进制文件：</target>
        </trans-unit>
        <trans-unit id="17f6cd1b99f9d8c8f96a2484ba6123182c8c7ea5" translate="yes" xml:space="preserve">
          <source>The following platforms have their own source code distributions and binaries available via &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt;</source>
          <target state="translated">以下平台具有自己的源代码发行版和二进制文件，可通过&lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt;获得。</target>
        </trans-unit>
        <trans-unit id="ba4505bcfd3048861117fe3f1683581b473bc260" translate="yes" xml:space="preserve">
          <source>The following platforms were supported by a previous version of Perl but have been officially removed from Perl's source code as of 5.12:</source>
          <target state="translated">以前的Perl版本支持以下平台,但从5.12开始已经正式从Perl的源代码中删除。</target>
        </trans-unit>
        <trans-unit id="231bce91c0774cb9ac67f2e9bf6e077f99a9edec" translate="yes" xml:space="preserve">
          <source>The following platforms were supported by a previous version of Perl but have been officially removed from Perl's source code as of 5.20:</source>
          <target state="translated">以下平台在以前的Perl版本中是支持的,但从5.20开始已经正式从Perl的源代码中删除。</target>
        </trans-unit>
        <trans-unit id="ce7175eecbb5cf889a2f2cc3f026e2da7a9136e7" translate="yes" xml:space="preserve">
          <source>The following platforms were supported up to 5.10. They may still have worked in 5.12, but supporting code has been removed for 5.14:</source>
          <target state="translated">以下平台在5.10之前一直被支持。它们在5.12中可能还能使用,但5.14中的支持代码已被删除。</target>
        </trans-unit>
        <trans-unit id="446fc2176911919a5044a357259301549c936213" translate="yes" xml:space="preserve">
          <source>The following platforms worked with the previous releases (5.6 and 5.7), but we did not manage either to fix or to test these in time for the 5.8.0 release. There is a very good chance that many of these will work fine with the 5.8.0.</source>
          <target state="translated">以下平台在之前的版本(5.6和5.7)中可以使用,但我们没有及时修复或测试这些平台,以便在5.8.0版本中使用。这些平台中的许多平台很有可能在5.8.0版本中正常工作。</target>
        </trans-unit>
        <trans-unit id="637d6920710e051f990eceb2af393917b297b61a" translate="yes" xml:space="preserve">
          <source>The following pragmas are defined (and have their own documentation).</source>
          <target state="translated">定义了以下实用程序(并有自己的文档)。</target>
        </trans-unit>
        <trans-unit id="3e891a8176dfddab918a655b139307ab8b66b513" translate="yes" xml:space="preserve">
          <source>The following primary functions are provided:</source>
          <target state="translated">提供了以下主要功能:</target>
        </trans-unit>
        <trans-unit id="dcbd438c6b1158dced15757e5785975c49cf130b" translate="yes" xml:space="preserve">
          <source>The following probably doesn't do what you expect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf69375b2075818b8dae7a187b7c74a5295e91b" translate="yes" xml:space="preserve">
          <source>The following problems are encountered with Haiku revision 28311:</source>
          <target state="translated">俳优修订版28311遇到以下问题。</target>
        </trans-unit>
        <trans-unit id="d89ada30f3c9b0885c9f6f1b4c7448cd518fcaa4" translate="yes" xml:space="preserve">
          <source>The following returns the &lt;b&gt;names&lt;/b&gt; of the PerlIO layers on a filehandle.</source>
          <target state="translated">以下内容返回文件句柄上PerlIO层的&lt;b&gt;名称&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="1bc9e3e129e691ac04ecb6526cec5a595482fff6" translate="yes" xml:space="preserve">
          <source>The following revisions are supported. The default is 30.</source>
          <target state="translated">支持以下版本。默认值为30。</target>
        </trans-unit>
        <trans-unit id="4a818dfcd5c08f13e17285de1b0c0c9fdcdbac96" translate="yes" xml:space="preserve">
          <source>The following revisions are supported. The default is 36.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c446e9a76c2a849f3d9283f94a02c3c2d25e461d" translate="yes" xml:space="preserve">
          <source>The following routines will be exported into your namespace if you specifically ask that they be imported:</source>
          <target state="translated">如果您特别要求导入以下例程,它们将被导出到您的命名空间。</target>
        </trans-unit>
        <trans-unit id="019be2c4bd05e066f928aafadb59663b3afde865" translate="yes" xml:space="preserve">
          <source>The following routines will be exported into your namespace if you use the Benchmark module:</source>
          <target state="translated">如果你使用Benchmark模块,以下例程将被导出到你的命名空间。</target>
        </trans-unit>
        <trans-unit id="de855448328b5e9f80cc8ce9168a701f985757d7" translate="yes" xml:space="preserve">
          <source>The following rules apply:</source>
          <target state="translated">适用以下规则:</target>
        </trans-unit>
        <trans-unit id="c3f236092c86ae50065ffb55ca5283dcb8508783" translate="yes" xml:space="preserve">
          <source>The following rules are available:</source>
          <target state="translated">有以下规则:</target>
        </trans-unit>
        <trans-unit id="a8f5fc7c9bec47fa12d0874b935f8fd0b4ed0730" translate="yes" xml:space="preserve">
          <source>The following sample implementation of &lt;code&gt;minus()&lt;/code&gt; (which assumes that &lt;code&gt;Number&lt;/code&gt; objects are simply blessed references to scalars) illustrates the calling conventions:</source>
          <target state="translated">以下 &lt;code&gt;minus()&lt;/code&gt; 的示例实现（假设 &lt;code&gt;Number&lt;/code&gt; 对象只是对标量的简单引用）说明了调用约定：</target>
        </trans-unit>
        <trans-unit id="67999be44740f8addea9fce4caf76726233a8acf" translate="yes" xml:space="preserve">
          <source>The following sequences (except &lt;code&gt;\N&lt;/code&gt; ) work within or without a character class. The first six are locale aware, all are Unicode aware. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details.</source>
          <target state="translated">以下序列（ &lt;code&gt;\N&lt;/code&gt; 除外）可在字符类之内或之外使用。前六个是区域设置感知的，所有都是Unicode感知的。有关详细信息，请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;和&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d35a09553da6f576d42c5fa2490f9e35aa7f113" translate="yes" xml:space="preserve">
          <source>The following sequences (except &lt;code&gt;\N&lt;/code&gt;) work within or without a character class. The first six are locale aware, all are Unicode aware. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9540b293755f2d5620dc9acad2cd13cee9e2ef96" translate="yes" xml:space="preserve">
          <source>The following set of functions all apply a given block of code to a list of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6520d28097d378d9470274294d01c67b34c1c70f" translate="yes" xml:space="preserve">
          <source>The following set of functions all reduce a list down to a single value.</source>
          <target state="translated">以下一组函数都是将一个列表缩减为一个值。</target>
        </trans-unit>
        <trans-unit id="adf371bb48a28981de1ae9bebf30e1218065293c" translate="yes" xml:space="preserve">
          <source>The following set of functions, all inspired by &lt;a href=&quot;List::Pairwise&quot;&gt;List::Pairwise&lt;/a&gt;, consume an even-sized list of pairs. The pairs may be key/value associations from a hash, or just a list of values. The functions will all preserve the original ordering of the pairs, and will not be confused by multiple pairs having the same &quot;key&quot; value - nor even do they require that the first of each pair be a plain string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f700e59048089f2fca9626afc48c135af0fec0" translate="yes" xml:space="preserve">
          <source>The following set of functions, all inspired by &lt;a href=&quot;http://search.cpan.org/perldoc/List::Pairwise&quot;&gt;List::Pairwise&lt;/a&gt;, consume an even-sized list of pairs. The pairs may be key/value associations from a hash, or just a list of values. The functions will all preserve the original ordering of the pairs, and will not be confused by multiple pairs having the same &quot;key&quot; value - nor even do they require that the first of each pair be a plain string.</source>
          <target state="translated">以下所有受&lt;a href=&quot;http://search.cpan.org/perldoc/List::Pairwise&quot;&gt;List :: Pairwise&lt;/a&gt;启发的函数集消耗了偶数大小的对列表。这些对可以是哈希中的键/值关联，也可以只是值列表。这些函数将全部保留对的原始顺序，并且不会被具有相同&amp;ldquo;键&amp;rdquo;值的多个对所混淆-甚至它们都不需要每对中的第一对都是纯字符串。</target>
        </trans-unit>
        <trans-unit id="bf58c9289e75f1b85afc527d37ec88624aafe8e0" translate="yes" xml:space="preserve">
          <source>The following setting are currently preserved: history, breakpoints, actions, debugger options, and the Perl command-line options &lt;b&gt;-w&lt;/b&gt;, &lt;b&gt;-I&lt;/b&gt;, and &lt;b&gt;-e&lt;/b&gt;.</source>
          <target state="translated">当前保留以下设置：历史记录，断点，操作，调试器选项以及Perl命令行选项&lt;b&gt;-w&lt;/b&gt;，&lt;b&gt;-I&lt;/b&gt;和&lt;b&gt;-e&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2f9e7f8b992aecf2d6263a37f2844fd220110139" translate="yes" xml:space="preserve">
          <source>The following shows how using negative indexing can make it easier to embed recursive patterns inside of a &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; construct for later use:</source>
          <target state="translated">下面显示了使用负索引如何使将递归模式嵌入 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 构造内部以供以后使用变得更加容易：</target>
        </trans-unit>
        <trans-unit id="9b2c5c0c58ad6eab6d4bc5753a307f626a410d1e" translate="yes" xml:space="preserve">
          <source>The following shows how using negative indexing can make it easier to embed recursive patterns inside of a &lt;code&gt;qr//&lt;/code&gt; construct for later use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1462e7325e21b0e3087981f44f0af9a643d8599d" translate="yes" xml:space="preserve">
          <source>The following shows the raw form of a reference to a hash.</source>
          <target state="translated">下面显示了引用哈希的原始形式。</target>
        </trans-unit>
        <trans-unit id="967f133103c60d10e71b0c793260fc3ac77b40c4" translate="yes" xml:space="preserve">
          <source>The following single statement:</source>
          <target state="translated">以下单项声明:</target>
        </trans-unit>
        <trans-unit id="2e884b22f85adb1ade979bfac548d842a78ee34c" translate="yes" xml:space="preserve">
          <source>The following standard quantifiers are recognized:</source>
          <target state="translated">以下是公认的标准定量器:</target>
        </trans-unit>
        <trans-unit id="f4477e5386cec5d30c1ffdf2df262ef158032a46" translate="yes" xml:space="preserve">
          <source>The following structure is used as the &lt;code&gt;pprivate&lt;/code&gt; struct by perl's regex engine. Since it is specific to perl it is only of curiosity value to other engine implementations.</source>
          <target state="translated">以下结构被perl的regex引擎用作 &lt;code&gt;pprivate&lt;/code&gt; 结构。由于它特定于perl，因此仅对其他引擎实现具有好奇心。</target>
        </trans-unit>
        <trans-unit id="89e9367ea2c2e9bf561ef1309852d2cf7361c03c" translate="yes" xml:space="preserve">
          <source>The following subroutines are available for general use once this module has been loaded:</source>
          <target state="translated">本模块加载后,以下子程序可供一般使用。</target>
        </trans-unit>
        <trans-unit id="39addea572ccdb746968405797f7ed6ce1f71c76" translate="yes" xml:space="preserve">
          <source>The following subsections describe basic locale categories. Beyond these, some combination categories allow manipulation of more than one basic category at a time. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt; for a discussion of these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba25a356d8138d41be0a86a5f5fb1d08b7adedd8" translate="yes" xml:space="preserve">
          <source>The following subsections describe basic locale categories. Beyond these, some combination categories allow manipulation of more than one basic category at a time. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; for a discussion of these.</source>
          <target state="translated">以下小节介绍了基本的语言环境类别。除此之外，一些组合类别还允许一次操纵多个基本类别。有关这些的讨论，请参见&lt;a href=&quot;#ENVIRONMENT&quot;&gt;环境&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0dc5293bb808b42d229adc04604a47fcedbdefbc" translate="yes" xml:space="preserve">
          <source>The following symbolic constants for SHOWWINDOW are available (but not exported) from the Win32 module: SW_HIDE, SW_SHOWNORMAL, SW_SHOWMINIMIZED, SW_SHOWMAXIMIZED and SW_SHOWNOACTIVATE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00832acd024c7ea26f0714974719f6fe15f3259e" translate="yes" xml:space="preserve">
          <source>The following systems contain with PA-RISC 1.1 chips:</source>
          <target state="translated">以下系统含有PA-RISC 1.1芯片。</target>
        </trans-unit>
        <trans-unit id="6b127f4160144d76492f304d4812a08c409c1ee2" translate="yes" xml:space="preserve">
          <source>The following systems contained PA-RISC 1.0 chips:</source>
          <target state="translated">以下系统包含PA-RISC 1.0芯片:</target>
        </trans-unit>
        <trans-unit id="c10d1b335971cff8856d57f7108722f96d961255" translate="yes" xml:space="preserve">
          <source>The following table is a complete listing of characters matched by &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; as of Unicode 6.3.</source>
          <target state="translated">下表是从Unicode 6.3开始由 &lt;code&gt;\s&lt;/code&gt; ， &lt;code&gt;\h&lt;/code&gt; 和 &lt;code&gt;\v&lt;/code&gt; 匹配的字符的完整列表。</target>
        </trans-unit>
        <trans-unit id="b30fe71571a9a6420e717590392f76849f4888c3" translate="yes" xml:space="preserve">
          <source>The following table is from Unicode 3.2.</source>
          <target state="translated">下表来自Unicode 3.2。</target>
        </trans-unit>
        <trans-unit id="08ac1fd17048e5aaff438c3920650ea36fe28bd5" translate="yes" xml:space="preserve">
          <source>The following table shows the result of the division and the remainder, so that the equation above holds true. Some &quot;ordinary&quot; cases are strewn in to show more clearly the reasoning:</source>
          <target state="translated">下表显示了除法和余数的结果,所以上面的公式成立。为了更清楚地显示出其中的道理,还散布了一些 &quot;普通 &quot;的情况。</target>
        </trans-unit>
        <trans-unit id="3985fef65ba4e91f6d3780d0b3e49df58907d0ee" translate="yes" xml:space="preserve">
          <source>The following table summarizes the default layers on UNIX-like and DOS-like platforms and depending on the setting of &lt;code&gt;$ENV{PERLIO}&lt;/code&gt; :</source>
          <target state="translated">下表总结了类似UNIX和类似DOS的平台上的默认层，具体取决于 &lt;code&gt;$ENV{PERLIO}&lt;/code&gt; 的设置：</target>
        </trans-unit>
        <trans-unit id="54678528be44b1241458a1af21612f2f6f5f0793" translate="yes" xml:space="preserve">
          <source>The following table summarizes the default layers on UNIX-like and DOS-like platforms and depending on the setting of &lt;code&gt;$ENV{PERLIO}&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72667df1c110c1893cb08480bc1c250b48c0cb32" translate="yes" xml:space="preserve">
          <source>The following tables list the ASCII and Latin 1 ordered sets including the subsets: C0 controls (0..31), ASCII graphics (32..7e), delete (7f), C1 controls (80..9f), and Latin-1 (a.k.a. ISO 8859-1) (a0..ff). In the table names of the Latin 1 extensions to ASCII have been labelled with character names roughly corresponding to</source>
          <target state="translated">下表列出了包括子集在内的ASCII和拉丁文1的有序集,其中包括C0控制(0...31)、ASCII图形(32...7e)、删除(7f)、C1控制(80...9f)和拉丁文1(又称ISO 885)。C0控制(0...31)、ASCII图形(32...7e)、删除(7f)、C1控制(80...9f)和拉丁文1(又名ISO 8859-1)(a0...ff)。在表格中,对ASCII的拉丁文1扩展的名称已经用大致对应于以下的字符名称进行了标注</target>
        </trans-unit>
        <trans-unit id="a992ed291bf59a4f8c8642c8859ba903d7ab1f6d" translate="yes" xml:space="preserve">
          <source>The following tests are still failing for Perl 5.8.1 under QNX 6.2.0:</source>
          <target state="translated">在 QNX 6.2.0 下,Perl 5.8.1 的以下测试仍然失败。</target>
        </trans-unit>
        <trans-unit id="679b51afc9785d4ea117543e0a14a59d2cf8f5c2" translate="yes" xml:space="preserve">
          <source>The following tests may report errors under QNX4:</source>
          <target state="translated">下列测试可能会在 QNX4 下报告错误。</target>
        </trans-unit>
        <trans-unit id="3fcf934fd04c9d50192b3311166eff55a4dd9606" translate="yes" xml:space="preserve">
          <source>The following three functions copy integer, unsigned integer or double into an SV whose reference is &lt;code&gt;rv&lt;/code&gt; . SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">以下三个函数将整数，无符号整数或双精度型复制到引用为 &lt;code&gt;rv&lt;/code&gt; 的SV中。如果 &lt;code&gt;classname&lt;/code&gt; 不为null，则SV被祝福。</target>
        </trans-unit>
        <trans-unit id="9965745aff45be1a5967becd8cef0c33f9e335d4" translate="yes" xml:space="preserve">
          <source>The following three functions copy integer, unsigned integer or double into an SV whose reference is &lt;code&gt;rv&lt;/code&gt;. SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab708869e7683ae4c6749cf27fcceca80c5c3008" translate="yes" xml:space="preserve">
          <source>The following three macros are used to initially allocate memory :</source>
          <target state="translated">以下三个宏用于初始分配内存。</target>
        </trans-unit>
        <trans-unit id="2d49873237bd9d666bf47ecb1ff27e7adc795d90" translate="yes" xml:space="preserve">
          <source>The following two calls behave identically:</source>
          <target state="translated">以下两个调用的行为是相同的。</target>
        </trans-unit>
        <trans-unit id="2886be86660a6181dbf2332b9a39bde42d1bded2" translate="yes" xml:space="preserve">
          <source>The following types of change are NOT acceptable:</source>
          <target state="translated">以下类型的变更是不可接受的:</target>
        </trans-unit>
        <trans-unit id="000a0a677c5358a2d9618715cbd6c3b2ea88fed1" translate="yes" xml:space="preserve">
          <source>The following types of change may be considered acceptable, as long as they do not also fall into any of the &quot;unacceptable&quot; categories set out below:</source>
          <target state="translated">以下类型的变更可以被认为是可以接受的,只要它们不属于以下任何 &quot;不可接受 &quot;的类别:</target>
        </trans-unit>
        <trans-unit id="502bd00665528041c42b284ac29aaf12f2929946" translate="yes" xml:space="preserve">
          <source>The following values can be set by passing &lt;code&gt;config()&lt;/code&gt; a reference to a hash:</source>
          <target state="translated">可以通过向 &lt;code&gt;config()&lt;/code&gt; 传递对哈希的引用来设置以下值：</target>
        </trans-unit>
        <trans-unit id="93c42f22f8e09b7cd455ba48443cb114b75d6049" translate="yes" xml:space="preserve">
          <source>The following variables are 'defined' by B::Concise; when they are used in a style, their respective values are plugged into the rendering of each opcode.</source>
          <target state="translated">以下变量由B::Concise &quot;定义&quot;;当它们被用于一个样式时,它们各自的值被插入到每个操作码的渲染中。</target>
        </trans-unit>
        <trans-unit id="706034b4d6cc89451a1849a613921860ab0e5afc" translate="yes" xml:space="preserve">
          <source>The following variables need to be set &lt;b&gt;before&lt;/b&gt; the call to the -&amp;gt;new constructor.</source>
          <target state="translated">在调用-&amp;gt; new构造函数&lt;b&gt;之前&lt;/b&gt;，需要设置以下变量。</target>
        </trans-unit>
        <trans-unit id="182dfc2e543ebf62f55632eff4a16082cef70bfe" translate="yes" xml:space="preserve">
          <source>The following variables work differently:</source>
          <target state="translated">以下变量的工作方式不同:</target>
        </trans-unit>
        <trans-unit id="076a97e0e26cc34846172ca450710de9a3595069" translate="yes" xml:space="preserve">
          <source>The following were implemented with</source>
          <target state="translated">实施了以下措施</target>
        </trans-unit>
        <trans-unit id="79ed55c53c285526808c76c6e4fadf315b9d9ae9" translate="yes" xml:space="preserve">
          <source>The following will determine the maximum length of the longest allowable pathname on the filesystem which holds</source>
          <target state="translated">下面将确定在文件系统中,允许的最长路径名的最大长度,该路径名为</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
