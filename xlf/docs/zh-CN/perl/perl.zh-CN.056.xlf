<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="c2df33c30bd450c40b146c186ea09c6cab11e56c" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Session - Abstract base class for harness output delegate</source>
          <target state="translated">TAP::Formatter::Session-驾驭输出委托的抽象基类。</target>
        </trans-unit>
        <trans-unit id="93ebad31adfaf596a987126afe3d7a3f18d93c05" translate="yes" xml:space="preserve">
          <source>TAP::Harness</source>
          <target state="translated">TAP::Harness</target>
        </trans-unit>
        <trans-unit id="b7d5d266f7a8edc064e0b8c710521d51a2bc894a" translate="yes" xml:space="preserve">
          <source>TAP::Harness - Run test scripts with statistics</source>
          <target state="translated">TAP::Harness-使用统计数据运行测试脚本。</target>
        </trans-unit>
        <trans-unit id="a28a3f4d3229f49494c71baca96520e2ecfb6ce6" translate="yes" xml:space="preserve">
          <source>TAP::Harness::Env</source>
          <target state="translated">TAP::Harness::Env</target>
        </trans-unit>
        <trans-unit id="91f28a5a62ef8f799cd7525ba0b5759ca2448d9c" translate="yes" xml:space="preserve">
          <source>TAP::Harness::Env - Parsing harness related environmental variables where appropriate</source>
          <target state="translated">TAP::Harness::Env-在适当的时候解析与线束相关的环境变量。</target>
        </trans-unit>
        <trans-unit id="7a70a46bfa38bc1216fe94cb04afcea34c7e8685" translate="yes" xml:space="preserve">
          <source>TAP::Object</source>
          <target state="translated">TAP::Object</target>
        </trans-unit>
        <trans-unit id="f09e3a92ac29a0ecd8a4f02097d67c9251bfb4fd" translate="yes" xml:space="preserve">
          <source>TAP::Object - Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">TAP :: Object-为所有 &lt;code&gt;TAP::*&lt;/code&gt; 模块提供通用功能的基类</target>
        </trans-unit>
        <trans-unit id="73c55e213830c688e72c24e7e2dc38927a8f526e" translate="yes" xml:space="preserve">
          <source>TAP::Parser</source>
          <target state="translated">TAP::Parser</target>
        </trans-unit>
        <trans-unit id="f762f998d40c617b51b08688208676705b948fa6" translate="yes" xml:space="preserve">
          <source>TAP::Parser - Parse &lt;a href=&quot;Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; output</source>
          <target state="translated">TAP :: Parser-解析&lt;a href=&quot;Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt;输出</target>
        </trans-unit>
        <trans-unit id="2f07ed865105b4fe8e06f2ed0ef74d2249f0ce1b" translate="yes" xml:space="preserve">
          <source>TAP::Parser - Parse &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; output</source>
          <target state="translated">TAP :: Parser-解析&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt;输出</target>
        </trans-unit>
        <trans-unit id="947140d84d6dc3586ce66227c8fbf3b5502269bb" translate="yes" xml:space="preserve">
          <source>TAP::Parser also supports callbacks; bailout, comment, plan, test, unknown, version and yaml are called for the corresponding TAP result types, ALL is called for all results, ELSE is called for all results for which a named callback is not installed and EOF is called once at the end of each TAP stream.</source>
          <target state="translated">TAP::Parser还支持回调,bailout、comment、plan、test、unknown、version和yaml是针对相应的TAP结果类型调用的,ALL是针对所有结果调用的,ELSE是针对所有没有安装命名回调的结果调用的,EOF是在每个TAP流结束时调用一次。</target>
        </trans-unit>
        <trans-unit id="7a216f40bfe5d8c4e9f480503b3353a997f25d9e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Aggregator</source>
          <target state="translated">TAP::Parser::Aggregator</target>
        </trans-unit>
        <trans-unit id="29967243373ff3c2847efa03292cf1394ade91bf" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Aggregator - Aggregate TAP::Parser results</source>
          <target state="translated">TAP::Parser::Aggregator-Aggregate TAP::Parser results</target>
        </trans-unit>
        <trans-unit id="ea252a87adf45624e0915f082cf3a171691e2b87" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Grammar</source>
          <target state="translated">TAP::Parser::Grammar</target>
        </trans-unit>
        <trans-unit id="99d73c9149822b89f098465b0ef15b6e5e432ba4" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Grammar - A grammar for the Test Anything Protocol.</source>
          <target state="translated">TAP::Parser::Grammar-Test Anything Protocol 的语法。</target>
        </trans-unit>
        <trans-unit id="f66dcc18cf605bab72f282216bf437fafae85c73" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator</source>
          <target state="translated">TAP::Parser::Iterator</target>
        </trans-unit>
        <trans-unit id="d222e4542e0f93a9f4cabc8a65b724fcc86515cd" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator - Base class for TAP source iterators</source>
          <target state="translated">TAP::Parser::Iterator-TAP源迭代器的基类。</target>
        </trans-unit>
        <trans-unit id="599e631b6f320b3fc47ee504d90a3e175b821f4e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Array</source>
          <target state="translated">TAP::Parser::Iterator::Array</target>
        </trans-unit>
        <trans-unit id="8849b72265bccd1154b20c5bcfd79b6177e1d979" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Array - Iterator for array-based TAP sources</source>
          <target state="translated">TAP::Parser::Iterator::Array-基于数组的TAP源的迭代器。</target>
        </trans-unit>
        <trans-unit id="8afb640018f748c7abac8e508f78557fe8689509" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Process</source>
          <target state="translated">TAP::Parser::Iterator::Process</target>
        </trans-unit>
        <trans-unit id="ef61fd1ef2ee2ba4a706833aed0bb08fe84a24ba" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Process - Iterator for process-based TAP sources</source>
          <target state="translated">TAP::Parser::Iterator::Process-用于基于过程的TAP源的迭代器。</target>
        </trans-unit>
        <trans-unit id="c97751b26f9e6df1ee3c0a7feabeda4e0d9102c3" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Stream</source>
          <target state="translated">TAP::Parser::Iterator::Stream</target>
        </trans-unit>
        <trans-unit id="be38f68275dc99a67c8ac1d8cfd48bb032de4d4a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Stream - Iterator for filehandle-based TAP sources</source>
          <target state="translated">TAP::Parser::Iterator::Stream-用于基于文件柄的TAP源的迭代器。</target>
        </trans-unit>
        <trans-unit id="d89bed7b6f6d5d165f751cac2ac0a13e2dd7f697" translate="yes" xml:space="preserve">
          <source>TAP::Parser::IteratorFactory</source>
          <target state="translated">TAP::Parser::IteratorFactory</target>
        </trans-unit>
        <trans-unit id="8d39f8677b4d63ea3260e5507a930c994a438d70" translate="yes" xml:space="preserve">
          <source>TAP::Parser::IteratorFactory - Figures out which SourceHandler objects to use for a given Source</source>
          <target state="translated">TAP::Parser::IteratorFactory-计算出要为给定的Source使用哪些SourceHandler对象。</target>
        </trans-unit>
        <trans-unit id="6f50fafc730902e3aa24fa13c0c429b89a2cc1ff" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Multiplexer</source>
          <target state="translated">TAP::Parser::Multiplexer</target>
        </trans-unit>
        <trans-unit id="2da48d5d830b8cd9138d15d18237febc28e0b498" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Multiplexer - Multiplex multiple TAP::Parsers</source>
          <target state="translated">TAP::解析器::多路复用器-多路复用多个TAP::解析器。</target>
        </trans-unit>
        <trans-unit id="3c077c3ce874909f47ae77cbcca2c04344198e5b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result</source>
          <target state="translated">TAP::Parser::Result</target>
        </trans-unit>
        <trans-unit id="a422082a9e255b156b40569483bd6f50f2d5a284" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result - Base class for TAP::Parser output objects</source>
          <target state="translated">TAP::Parser::Result-TAP::Parser输出对象的基类。</target>
        </trans-unit>
        <trans-unit id="03b8058105031bc1095218a7667a2ea1b2512b1e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Bailout</source>
          <target state="translated">TAP::Parser::Result::Bailout</target>
        </trans-unit>
        <trans-unit id="00f4b677e9dddb24581e9ed004b7470cf77a617e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Bailout - Bailout result token.</source>
          <target state="translated">TAP::Parser::Result::Bailout-Bailout result token。</target>
        </trans-unit>
        <trans-unit id="afba56eaac641feaac3daf9f840411e87ecf1e14" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Comment</source>
          <target state="translated">TAP::Parser::Result::Comment</target>
        </trans-unit>
        <trans-unit id="15ac19d49aebc2fdbf7a430ac512a0c55bc03548" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Comment - Comment result token.</source>
          <target state="translated">TAP::Parser::Result::Comment-评论结果标记。</target>
        </trans-unit>
        <trans-unit id="8028e0720d8ec37d7287bdb1bc7450078b0bf251" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Plan</source>
          <target state="translated">TAP::Parser::Result::Plan</target>
        </trans-unit>
        <trans-unit id="4383859286c921d76add9716628e055668e9e51d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Plan - Plan result token.</source>
          <target state="translated">TAP::Parser::Result::Plan-计划结果标记。</target>
        </trans-unit>
        <trans-unit id="f69e80305022a26d3e2f7acc2b0ed1b953372499" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Pragma</source>
          <target state="translated">TAP::Parser::Result::Pragma</target>
        </trans-unit>
        <trans-unit id="14e0c88ebea6563cf55ee8c08b3b9ed300f0d20c" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Pragma - TAP pragma token.</source>
          <target state="translated">TAP::Parser::Result::Pragma-TAP pragma token。</target>
        </trans-unit>
        <trans-unit id="2c91344b1f933a9487eebefc220df8812b008445" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Test</source>
          <target state="translated">TAP::Parser::Result::Test</target>
        </trans-unit>
        <trans-unit id="edc9dae5ee4fae6dd91f0295f192573a8fb6a01a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Test - Test result token.</source>
          <target state="translated">TAP::Parser::Result::Test-测试结果标记。</target>
        </trans-unit>
        <trans-unit id="44c345b7d9dc9992b3e410debbb02b0d29d66e79" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Unknown</source>
          <target state="translated">TAP::Parser::Result::Unknown</target>
        </trans-unit>
        <trans-unit id="2943117d9510c588ee4451eb94edacf47000ab69" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Unknown - Unknown result token.</source>
          <target state="translated">TAP::Parser::Result::Unknown-未知结果标记。</target>
        </trans-unit>
        <trans-unit id="c6da177c03a14aa64f029674caca24adf3980051" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Version</source>
          <target state="translated">TAP::Parser::Result::Version</target>
        </trans-unit>
        <trans-unit id="57883e95518fac69c11831c9fff6d78815a22b85" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Version - TAP syntax version token.</source>
          <target state="translated">TAP::Parser::Result::Version-TAP语法版本标记。</target>
        </trans-unit>
        <trans-unit id="0f318e8c966222dedab8b0415294cae97d5f4f64" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::YAML</source>
          <target state="translated">TAP::Parser::Result::YAML</target>
        </trans-unit>
        <trans-unit id="68efbf9d5d727c77c2280206016668c939f6f897" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::YAML - YAML result token.</source>
          <target state="translated">TAP::Parser::Result::YAML-YAML结果标记。</target>
        </trans-unit>
        <trans-unit id="1a3c6d732b12248b1b6d9e14cf320584eb0a7af0" translate="yes" xml:space="preserve">
          <source>TAP::Parser::ResultFactory</source>
          <target state="translated">TAP::Parser::ResultFactory</target>
        </trans-unit>
        <trans-unit id="4f51e316d0426f94634c75bc33e9099d8d304e39" translate="yes" xml:space="preserve">
          <source>TAP::Parser::ResultFactory - Factory for creating TAP::Parser output objects</source>
          <target state="translated">TAP::Parser::ResultFactory-用于创建TAP::Parser输出对象的工厂。</target>
        </trans-unit>
        <trans-unit id="50d7a126914ae0138b7bdc512d9ccd5a5d77784d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler</source>
          <target state="translated">TAP::Parser::Scheduler</target>
        </trans-unit>
        <trans-unit id="6da57a5308e690ad2cdb39023741e3d016f8b96b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler - Schedule tests during parallel testing</source>
          <target state="translated">TAP::Parser::Scheduler-在并行测试中安排测试。</target>
        </trans-unit>
        <trans-unit id="81a373608790f502b94224968ea5fc04bfbb7622" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Job</source>
          <target state="translated">TAP::Parser::Scheduler::Job</target>
        </trans-unit>
        <trans-unit id="657d2fb895dc4c666b37510d12e2199629196955" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Job - A single testing job.</source>
          <target state="translated">TAP::Parser::Scheduler::Job-一个单一的测试作业。</target>
        </trans-unit>
        <trans-unit id="5f18e879edab289da9e626ab0da6617557a360e9" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Spinner</source>
          <target state="translated">TAP::Parser::Scheduler::Spinner</target>
        </trans-unit>
        <trans-unit id="73c0394de64be963748b5ce71edfd4ac21a6b40d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Spinner - A no-op job.</source>
          <target state="translated">TAP::Parser::Scheduler::Spinner-一个无操作的作业。</target>
        </trans-unit>
        <trans-unit id="223a37f35fb2a759c5993cb7f97ef9683ee5bef9" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Source</source>
          <target state="translated">TAP::Parser::Source</target>
        </trans-unit>
        <trans-unit id="ba1432bca02f36d9b7eb2dec89d208a92989961b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Source - a TAP source &amp;amp; meta data about it</source>
          <target state="translated">TAP :: Parser :: Source-TAP源和有关它的元数据</target>
        </trans-unit>
        <trans-unit id="b88d422ffa232da21769ecf23f36c9215fb7316d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler</source>
          <target state="translated">TAP::Parser::SourceHandler</target>
        </trans-unit>
        <trans-unit id="7a11e510cbf8229cb9deefa589961e1880c0ef0c" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler - Base class for different TAP source handlers</source>
          <target state="translated">TAP::Parser::SourceHandler-不同TAP源处理程序的基础类。</target>
        </trans-unit>
        <trans-unit id="567fb9a0760765f024156fd52b7260852fb83a9f" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Executable</source>
          <target state="translated">TAP::Parser::SourceHandler::Executable</target>
        </trans-unit>
        <trans-unit id="def5a816ec0112a978d703f8596c8df1a84fd5e0" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Executable - Stream output from an executable TAP source</source>
          <target state="translated">TAP::Parser::SourceHandler::Executable-来自可执行的TAP源的流输出。</target>
        </trans-unit>
        <trans-unit id="7855e6a236f3f1bba1561cccffbc0253a8b41c1a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::File</source>
          <target state="translated">TAP::Parser::SourceHandler::File</target>
        </trans-unit>
        <trans-unit id="c84a46ff700384567f810cc0dbe5e4d5b91c8613" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::File - Stream TAP from a text file.</source>
          <target state="translated">TAP::Parser::SourceHandler::File-从文本文件中流出TAP。</target>
        </trans-unit>
        <trans-unit id="f75757e90ca350dfe386979f74159d3e72435290" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Handle</source>
          <target state="translated">TAP::Parser::SourceHandler::Handle</target>
        </trans-unit>
        <trans-unit id="b6f0bcffb30af38c06936b6bf1545dd5a83277c1" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Handle - Stream TAP from an IO::Handle or a GLOB.</source>
          <target state="translated">TAP::Parser::SourceHandler::Handle-从一个IO::Handle或一个GLOB流TAP。</target>
        </trans-unit>
        <trans-unit id="4545cce101afaf68b0bd75f8cbbb180c6b160964" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Perl</source>
          <target state="translated">TAP::Parser::SourceHandler::Perl</target>
        </trans-unit>
        <trans-unit id="04e054f8c028c674d2c9287cae69082bbf9ce520" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Perl - Stream TAP from a Perl executable</source>
          <target state="translated">TAP::Parser::SourceHandler::Perl-来自Perl可执行文件的TAP流。</target>
        </trans-unit>
        <trans-unit id="849652a7b8f5b288e476708d89c71b634dc488c2" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::RawTAP</source>
          <target state="translated">TAP::Parser::SourceHandler::RawTAP</target>
        </trans-unit>
        <trans-unit id="7fe676e21d00db4b7e1f5adc9ab5a7fc5c10349f" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::RawTAP - Stream output from raw TAP in a scalar/array ref.</source>
          <target state="translated">TAP::Parser::SourceHandler::RawTAP-以标量/数组为单位的原始TAP流输出。</target>
        </trans-unit>
        <trans-unit id="f75366f8757d0c89dc67745e9e30ae921835fc92" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Reader</source>
          <target state="translated">TAP::Parser::YAMLish::Reader</target>
        </trans-unit>
        <trans-unit id="92a795f40e2bb73376fc045a4635f6fcf7d6a7de" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Reader - Read YAMLish data from iterator</source>
          <target state="translated">TAP::解析器::YAMLish::Reader-从迭代器中读取YAMLish数据。</target>
        </trans-unit>
        <trans-unit id="08d78eef616ac71669e623449566134b1c6d4b77" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Writer</source>
          <target state="translated">TAP::Parser::YAMLish::Writer</target>
        </trans-unit>
        <trans-unit id="662f33223b14be1ce958a19abee31b207588ba54" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Writer - Write YAMLish data</source>
          <target state="translated">TAP::Parser::YAMLish::Writer-写入YAMLish数据。</target>
        </trans-unit>
        <trans-unit id="5b754807c6604c3c6635f1f0f60d367a6cffd283" translate="yes" xml:space="preserve">
          <source>TAPx Developers.</source>
          <target state="translated">TAPx开发者。</target>
        </trans-unit>
        <trans-unit id="1c4682dfeedc4e9ca5c57ef7dd969ecc22339454" translate="yes" xml:space="preserve">
          <source>TARG</source>
          <target state="translated">TARG</target>
        </trans-unit>
        <trans-unit id="f762108ca727f0bcd961fc7467c248887dfa70dc" translate="yes" xml:space="preserve">
          <source>TARGET</source>
          <target state="translated">TARGET</target>
        </trans-unit>
        <trans-unit id="07ebecac9b2b06cf07f96beb0d4f2199e5361e7a" translate="yes" xml:space="preserve">
          <source>TARGLEN</source>
          <target state="translated">TARGLEN</target>
        </trans-unit>
        <trans-unit id="2bf1079e4526d76e12b857a04bc0e88e77c1a56e" translate="yes" xml:space="preserve">
          <source>TARGOFF</source>
          <target state="translated">TARGOFF</target>
        </trans-unit>
        <trans-unit id="20a7b118ffa37d6b7bbce47ab0257aa206e6a7b5" translate="yes" xml:space="preserve">
          <source>TBC: Remove the stringified coderef; while it provides a 'cookie' for each function rendered, the cookies used should be 1,2,3.. not a random hex-address. It also complicates string comparison of two different trees.</source>
          <target state="translated">TBC。删除字符串化的coderef;虽然它为每个函数提供了一个 &quot;cookie&quot;,但使用的cookie应该是1,2,3.而不是一个随机的十六进制地址。这也使两个不同树的字符串比较复杂化。</target>
        </trans-unit>
        <trans-unit id="75c76515695c04f9554f43d036ad1241bc04ca9e" translate="yes" xml:space="preserve">
          <source>TBC: a hookpoint (and an option to set it) for a user-supplied function to produce a banner appropriate for users needs. It's not ideal, because the rendering-state variables, which are a natural candidate for use in concise.t, are unavailable to the user.</source>
          <target state="translated">TBC:为用户提供的函数提供一个钩子点(以及设置钩子点的选项),以产生一个适合用户需求的横幅。这并不理想,因为用户无法使用concise.t中的渲染状态变量。</target>
        </trans-unit>
        <trans-unit id="f544fb304c83e23652a63e1bb1b28f4fcc7f6ac0" translate="yes" xml:space="preserve">
          <source>TCP</source>
          <target state="translated">TCP</target>
        </trans-unit>
        <trans-unit id="ccb92559aac4354578ea22eca45f6544e0875e36" translate="yes" xml:space="preserve">
          <source>TCP Clients with IO::Socket</source>
          <target state="translated">带有IO::Socket的TCP客户端</target>
        </trans-unit>
        <trans-unit id="90251fa6420d40cf40e1d413320c56543c05df3d" translate="yes" xml:space="preserve">
          <source>TCP Servers with IO::Socket</source>
          <target state="translated">带有IO::Socket的TCP服务器</target>
        </trans-unit>
        <trans-unit id="5f3be0b4f564336745c1f56bb30fefa5d6b55f59" translate="yes" xml:space="preserve">
          <source>TCP32IP</source>
          <target state="translated">TCP32IP</target>
        </trans-unit>
        <trans-unit id="930107c72c67f45aa5652e4a9e00965774f7a294" translate="yes" xml:space="preserve">
          <source>TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...</source>
          <target state="translated">TCP_CORK,TCP_KEEPALIVE,TCP_NODELAY,...。</target>
        </trans-unit>
        <trans-unit id="f903b5ea6b01e57df921d11ccc31344fae1a17ad" translate="yes" xml:space="preserve">
          <source>TECHNICAL NOTES</source>
          <target state="translated">技术说明</target>
        </trans-unit>
        <trans-unit id="b91007f005fd5b0e0252dbeed42578d0d3ba8fe5" translate="yes" xml:space="preserve">
          <source>TELL this</source>
          <target state="translated">告诉这个</target>
        </trans-unit>
        <trans-unit id="b0a2096b23211f0508d184fe8003d9fb843bbdcd" translate="yes" xml:space="preserve">
          <source>TEMPLATE available since 0.23</source>
          <target state="translated">TEMPLATE自0.23起可用</target>
        </trans-unit>
        <trans-unit id="9335e94443b7e72d405288dde6a7e324e2d4e0cd" translate="yes" xml:space="preserve">
          <source>TEMPLATE available since 0.23.</source>
          <target state="translated">TEMPLATE从0.23开始提供。</target>
        </trans-unit>
        <trans-unit id="b3db3af9a0e0243f28ed20fcc3b1d5d1faaafbb6" translate="yes" xml:space="preserve">
          <source>TERM</source>
          <target state="translated">TERM</target>
        </trans-unit>
        <trans-unit id="cfc996e2b0441d5f42e4bd8a622b4dd1b2f920a4" translate="yes" xml:space="preserve">
          <source>TERMCAP</source>
          <target state="translated">TERMCAP</target>
        </trans-unit>
        <trans-unit id="4baf6f46b36f22af80f6af8178fa1faa75a5a37d" translate="yes" xml:space="preserve">
          <source>TERMINOLOGY</source>
          <target state="translated">TERMINOLOGY</target>
        </trans-unit>
        <trans-unit id="201ab4b1fe261c4f44a8bfbbdafd62a7606acc46" translate="yes" xml:space="preserve">
          <source>TERMPATH</source>
          <target state="translated">TERMPATH</target>
        </trans-unit>
        <trans-unit id="feb84698a707a37aae3ea67dd9630a278a6ca8f5" translate="yes" xml:space="preserve">
          <source>TERTIARY METHODS</source>
          <target state="translated">第三阶段的方法</target>
        </trans-unit>
        <trans-unit id="984816fd329622876e14907634264e6f332e9fb3" translate="yes" xml:space="preserve">
          <source>TEST</source>
          <target state="translated">TEST</target>
        </trans-unit>
        <trans-unit id="16731ae62f4aed11f4e128609c52499c94df9c78" translate="yes" xml:space="preserve">
          <source>TEST ON CYGWIN</source>
          <target state="translated">在CYGWIN上测试</target>
        </trans-unit>
        <trans-unit id="6fc222312636989b4f87037a3c04ed0cc832a677" translate="yes" xml:space="preserve">
          <source>TEST RESULTS</source>
          <target state="translated">测试结果</target>
        </trans-unit>
        <trans-unit id="e01006d91764e5a9b5b7e2fa6b5505255129d446" translate="yes" xml:space="preserve">
          <source>TEST STATUS</source>
          <target state="translated">测试状态</target>
        </trans-unit>
        <trans-unit id="1aafa503ed48d02972e5772184ca513598703dbe" translate="yes" xml:space="preserve">
          <source>TEST TYPES</source>
          <target state="translated">测试类型</target>
        </trans-unit>
        <trans-unit id="0aec4d9bc52ab96e424cd057a59cc45eff314107" translate="yes" xml:space="preserve">
          <source>TEST2</source>
          <target state="translated">TEST2</target>
        </trans-unit>
        <trans-unit id="cb73eb0155af5a3da3bb4a63646b40201ab650c4" translate="yes" xml:space="preserve">
          <source>TESTING</source>
          <target state="translated">TESTING</target>
        </trans-unit>
        <trans-unit id="942de0a9a9abe9fb219e796c9c0f10b53d3c6b67" translate="yes" xml:space="preserve">
          <source>TESTING FRAMEWORKS</source>
          <target state="translated">测试框架</target>
        </trans-unit>
        <trans-unit id="0653969b83ac74a5d20cdc9c4494d4702f2fe66a" translate="yes" xml:space="preserve">
          <source>TESTING YOUR TOOLS</source>
          <target state="translated">测试您的工具</target>
        </trans-unit>
        <trans-unit id="0bee02d2a52a6eefa52f8e6c1723494db5b275c5" translate="yes" xml:space="preserve">
          <source>TEST_REQUIRES</source>
          <target state="translated">TEST_REQUIRES</target>
        </trans-unit>
        <trans-unit id="04209ee7219637d26ee9cd4fa722493ca838116d" translate="yes" xml:space="preserve">
          <source>THANK YOU</source>
          <target state="translated">谢谢你</target>
        </trans-unit>
        <trans-unit id="ffa4516bffdd79480b0ffbea2e99e02675eb3752" translate="yes" xml:space="preserve">
          <source>THANKS</source>
          <target state="translated">THANKS</target>
        </trans-unit>
        <trans-unit id="506d81bed6d3b4fa9b202f8f107ea34d18c6fadf" translate="yes" xml:space="preserve">
          <source>THE .netrc FILE</source>
          <target state="translated">.netrc文件</target>
        </trans-unit>
        <trans-unit id="2462f7724da7788ea62fc114cce4eab4e3339b38" translate="yes" xml:space="preserve">
          <source>THE API INTERFACE</source>
          <target state="translated">API接口</target>
        </trans-unit>
        <trans-unit id="eb466ef85e05d613480bb98bc1553047a2722184" translate="yes" xml:space="preserve">
          <source>THE CALL_ FUNCTIONS</source>
          <target state="translated">CALL_FUNCTIONS</target>
        </trans-unit>
        <trans-unit id="db00699a00a64bd8eb4f11307ac364af2186b3b7" translate="yes" xml:space="preserve">
          <source>THE Math::BigInt API</source>
          <target state="translated">Math::BigInt API</target>
        </trans-unit>
        <trans-unit id="5bf87badf6e989985ca5cde31b10d699fd946122" translate="yes" xml:space="preserve">
          <source>THE PERL ENCODING API</source>
          <target state="translated">PERL ENCODING API</target>
        </trans-unit>
        <trans-unit id="2036c7632dcc8e78c342e25b215c2cd28f8d5b22" translate="yes" xml:space="preserve">
          <source>THE PERL MODULE LIBRARY</source>
          <target state="translated">PERL MODULE LIBRARY</target>
        </trans-unit>
        <trans-unit id="a1c725e21d784bf655d9ab26a4cdce89326e975c" translate="yes" xml:space="preserve">
          <source>THE QUESTIONS</source>
          <target state="translated">问题:</target>
        </trans-unit>
        <trans-unit id="fb64ef2c36220a9cb84ef2e67b3a1343a0d67d4d" translate="yes" xml:space="preserve">
          <source>THE RULES OF SYS::SYSLOG</source>
          <target state="translated">SYS::SYSLOG的规则</target>
        </trans-unit>
        <trans-unit id="79e66f9682153b1fcc7f947e99f79c4de4e44b30" translate="yes" xml:space="preserve">
          <source>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</source>
          <target state="translated">本软件是 &quot;按原样 &quot;提供的,没有任何形式的明示或暗示的保证,包括但不限于适销性、特定用途的适用性和不侵权的保证。在任何情况下,作者或版权持有者均不对因本软件或本软件的使用或其他交易而引起的、因本软件的使用或与本软件有关的合同、侵权或其他行为的任何索赔、损害或其他责任负责。</target>
        </trans-unit>
        <trans-unit id="6c98c15d2eefa5232f6a2b60310fc78bdae1017e" translate="yes" xml:space="preserve">
          <source>THE dataconn CLASS</source>
          <target state="translated">数据采集类</target>
        </trans-unit>
        <trans-unit id="472f09c67477280b91b7ae79efeb4fde13fbb523" translate="yes" xml:space="preserve">
          <source>THING</source>
          <target state="translated">THING</target>
        </trans-unit>
        <trans-unit id="07b9eb014428dfb38549744f146d6c3dde1b5ea1" translate="yes" xml:space="preserve">
          <source>THINGS THAT BREAK</source>
          <target state="translated">破碎的东西</target>
        </trans-unit>
        <trans-unit id="2360380b4c35fa48f7e3a9f411a80f126b56989e" translate="yes" xml:space="preserve">
          <source>THINGS TO LOOK OUT FOR</source>
          <target state="translated">需要注意的事项</target>
        </trans-unit>
        <trans-unit id="89f30bff95de115f49eea92211c4131dff22eee2" translate="yes" xml:space="preserve">
          <source>THIRD PARTY META-DATA</source>
          <target state="translated">第三方元数据</target>
        </trans-unit>
        <trans-unit id="b8d962f5bb90637331652bdd7361911bfa4f11ec" translate="yes" xml:space="preserve">
          <source>THIS</source>
          <target state="translated">THIS</target>
        </trans-unit>
        <trans-unit id="1e38c114990518154ef0cedaa35a5bd37c0b3725" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.</source>
          <target state="translated">此功能只能在非常特殊的情况下使用。</target>
        </trans-unit>
        <trans-unit id="584497c8a870243751bafe0429bbe1f5826e0915" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Instead, &lt;b&gt;Almost all code should use &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; or &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;&lt;/b&gt;.</source>
          <target state="translated">只能在非常特殊的情况下使用此功能。相反，&lt;b&gt;几乎所有代码都应使用&lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt;或&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2fe768b556edf71a7a7285e6d6bd4d94874718c9" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Instead, &lt;b&gt;Almost all code should use &lt;a href=&quot;perlapi#uvchr_to_utf8&quot;&gt;&quot;uvchr_to_utf8&quot; in perlapi&lt;/a&gt; or &lt;a href=&quot;perlapi#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot; in perlapi&lt;/a&gt;&lt;/b&gt;.</source>
          <target state="translated">只能在非常特殊的情况下使用此功能。取而代之的是，&lt;b&gt;几乎所有的代码应该使用&lt;a href=&quot;perlapi#uvchr_to_utf8&quot;&gt;在负责填实perlapi&amp;ldquo;uvchr_to_utf8&amp;rdquo;&lt;/a&gt;或&lt;a href=&quot;perlapi#uvchr_to_utf8_flags&quot;&gt;在负责填实perlapi&amp;ldquo;uvchr_to_utf8_flags&amp;rdquo;&lt;/a&gt;&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="67e7f9968d3c36f671d0b0a315ac2b0ae68ef3cb" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Most code should use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;&quot;utf8_to_uvchr_buf&quot;&lt;/a&gt;() rather than call this directly.</source>
          <target state="translated">只能在非常特殊的情况下使用此功能。大多数代码应使用&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;&amp;ldquo; utf8_to_uvchr_buf&amp;rdquo;&lt;/a&gt;（），而不是直接调用此代码。</target>
        </trans-unit>
        <trans-unit id="331b8f63effc7e7d25ea524ca1aa92004125d86f" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Most code should use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;() rather than call this directly.</source>
          <target state="translated">只能在非常特殊的情况下使用此功能。大多数代码应使用&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;（）而不是直接调用它。</target>
        </trans-unit>
        <trans-unit id="e500f259933ce04e81376b9418761e8b6b63ca4b" translate="yes" xml:space="preserve">
          <source>THIS IS A BUNDLED COPY OF HASHBASE</source>
          <target state="translated">这是一个捆绑的HASHBASE的副本</target>
        </trans-unit>
        <trans-unit id="b87fa10ba30f21359cbeb956cb3e89adeb5a0009" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="translated">本软件是由本公司和供应商按 &quot;原样 &quot;提供的,任何明示或暗示的保证,包括但不限于暗示的适销性和特定用途的适用性保证,均不在此列。在任何情况下,即使已被告知可能发生此类损害,REGENTS或合作伙伴也不对因使用本软件而引起的任何直接的、间接的、偶然的、特殊的、例外的或后果性的损害(包括但不限于购买替代产品或服务;使用、数据或利润损失;或业务中断)负责,无论其原因如何,也不承担任何责任,无论是合同、严格责任还是侵权行为(包括过失或其他)。</target>
        </trans-unit>
        <trans-unit id="897ebd5219f0c5caa208699bd4713ae3b784c6e0" translate="yes" xml:space="preserve">
          <source>THREAD CONTEXT</source>
          <target state="translated">主题内容</target>
        </trans-unit>
        <trans-unit id="54e59b7bc3a2e96489d360a7b538367313e355dc" translate="yes" xml:space="preserve">
          <source>THREAD SIGNALLING</source>
          <target state="translated">线程信号</target>
        </trans-unit>
        <trans-unit id="60b08b8acc7a625b8f0d9d41c7e2c28fbb134428" translate="yes" xml:space="preserve">
          <source>THREAD STACK SIZE</source>
          <target state="translated">线程堆栈大小</target>
        </trans-unit>
        <trans-unit id="577fa2796ff34704e76d7424a53614775f345523" translate="yes" xml:space="preserve">
          <source>THREAD STATE</source>
          <target state="translated">线程状态</target>
        </trans-unit>
        <trans-unit id="bf2767662599be6d02741631f5d4e162d0241086" translate="yes" xml:space="preserve">
          <source>THREAD SUPPORT</source>
          <target state="translated">线程支持</target>
        </trans-unit>
        <trans-unit id="f8c7150e13e8ea5e3603e546c189035146b726df" translate="yes" xml:space="preserve">
          <source>THREADS</source>
          <target state="translated">THREADS</target>
        </trans-unit>
        <trans-unit id="7c9dadbfc59d969a1799e6be175b4787667674b0" translate="yes" xml:space="preserve">
          <source>TIEARRAY classname, LIST</source>
          <target state="translated">TIEARRAY类名,LIST</target>
        </trans-unit>
        <trans-unit id="f266b9c4765272a11c0ed3c20127bf1d201638dd" translate="yes" xml:space="preserve">
          <source>TIEHANDLE by Sven Verdoolaege &amp;lt;</source>
          <target state="translated">SIE Verdoolaege的TIEHANDLE &amp;lt;</target>
        </trans-unit>
        <trans-unit id="4347e3f18728473395d10013e97d93a913b225ef" translate="yes" xml:space="preserve">
          <source>TIEHANDLE classname, LIST</source>
          <target state="translated">TIEHANDLE类名,LIST</target>
        </trans-unit>
        <trans-unit id="e4d83af8a8f8d7e1fd18b5a0b52b5df410f197b9" translate="yes" xml:space="preserve">
          <source>TIEHASH</source>
          <target state="translated">TIEHASH</target>
        </trans-unit>
        <trans-unit id="114157a2500e26e12e9e4f96b1661f6f0fed2f32" translate="yes" xml:space="preserve">
          <source>TIEHASH classname, LIST</source>
          <target state="translated">TIEHASH类名,LIST</target>
        </trans-unit>
        <trans-unit id="5885b322f223d2e8e46e67617d8c4179f4469494" translate="yes" xml:space="preserve">
          <source>TIESCALAR classname, LIST</source>
          <target state="translated">TIESCALAR类名,LIST</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="6c2529a2a2e078590190100f8e1c4972e8846bc5" translate="yes" xml:space="preserve">
          <source>TIME is</source>
          <target state="translated">时间是</target>
        </trans-unit>
        <trans-unit id="cb08f6ca3aa0ce4fb2da7065815536bc05346689" translate="yes" xml:space="preserve">
          <source>TITLE specifies an optional window title. The default is &quot;Perl&quot;.</source>
          <target state="translated">TITLE 指定一个可选的窗口标题。默认为 &quot;Perl&quot;。</target>
        </trans-unit>
        <trans-unit id="6409a515d9fc80e579966498117e7281bd8b98a0" translate="yes" xml:space="preserve">
          <source>TMP or TEMP</source>
          <target state="translated">TMP或TEMP</target>
        </trans-unit>
        <trans-unit id="502251190f55377c3e1679cff641b5206ebe43aa" translate="yes" xml:space="preserve">
          <source>TMPDIR flag available since 0.19.</source>
          <target state="translated">TMPDIR标志从0.19开始可用。</target>
        </trans-unit>
        <trans-unit id="9767c08e2051436d891f79c96c59ac4496bdaece" translate="yes" xml:space="preserve">
          <source>TMTOWTDI</source>
          <target state="translated">TMTOWTDI</target>
        </trans-unit>
        <trans-unit id="47bd70df0e55aba216736b1db7710c6478ab9cbf" translate="yes" xml:space="preserve">
          <source>TO DO</source>
          <target state="translated">要做的事</target>
        </trans-unit>
        <trans-unit id="f8953b7e0e4beba3861ba1d10ca937f8f20fdfee" translate="yes" xml:space="preserve">
          <source>TO DO (maybe)</source>
          <target state="translated">要做的事(也许)</target>
        </trans-unit>
        <trans-unit id="b698c11e84460ed5999bfeb5cbf25b865c238f3c" translate="yes" xml:space="preserve">
          <source>TODO</source>
          <target state="translated">TODO</target>
        </trans-unit>
        <trans-unit id="87460dd609011b471c790d7cefae22bfe0f0c49f" translate="yes" xml:space="preserve">
          <source>TODO TESTS</source>
          <target state="translated">所有测试</target>
        </trans-unit>
        <trans-unit id="14081c923a6df4129e72afd1550fb67ed4989fb1" translate="yes" xml:space="preserve">
          <source>TODO all (most?) accessorized methods</source>
          <target state="translated">TODO所有(大部分?)接入方法</target>
        </trans-unit>
        <trans-unit id="a5b8170989f597b07b48f468f60223ae453a6cc5" translate="yes" xml:space="preserve">
          <source>TODO intro... mention that events are supplied for implicits, like for missing &amp;gt;'s</source>
          <target state="translated">TODO简介...提到事件是为隐式提供的，例如缺少&amp;gt;</target>
        </trans-unit>
        <trans-unit id="49b8285ed97f054a4aab1877c59b31a331177c3b" translate="yes" xml:space="preserve">
          <source>TODO plans</source>
          <target state="translated">所有计划</target>
        </trans-unit>
        <trans-unit id="bac7481b99347a289b8d37ae17bf40d2f44f1514" translate="yes" xml:space="preserve">
          <source>TODO tests are designed for maintaining an &lt;b&gt;executable TODO list&lt;/b&gt;. These tests are</source>
          <target state="translated">TODO测试旨在维护&lt;b&gt;可执行的TODO列表&lt;/b&gt;。这些测试是</target>
        </trans-unit>
        <trans-unit id="fd32d0b7a9d317be835f0befd340eb49cf589cff" translate="yes" xml:space="preserve">
          <source>TODO, see &lt;a href=&quot;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&lt;/a&gt;</source>
          <target state="translated">待办事项，请参阅&lt;a href=&quot;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74f7cfa4b2cac04f938a7033d590acfea7e8506e" translate="yes" xml:space="preserve">
          <source>TODO, see &lt;a href=&quot;https://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&lt;/a&gt;</source>
          <target state="translated">待办事项，请参阅&lt;a href=&quot;https://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd529f1aacfef198f05ec640f141ac5fe8d0a0d0" translate="yes" xml:space="preserve">
          <source>TODO...</source>
          <target state="translated">TODO...</target>
        </trans-unit>
        <trans-unit id="643a0382045e00a908788587a0d4b6d602741dc9" translate="yes" xml:space="preserve">
          <source>TODO: An example or two of =extend, then point to Pod::Simple::Subclassing</source>
          <target state="translated">TODO:一两个=extend的例子,然后指向Pod::Simple::Subclassing。</target>
        </trans-unit>
        <trans-unit id="b95da2f919c7ccb270ebcfb13598d7d2d8b6a01a" translate="yes" xml:space="preserve">
          <source>TODO: Document this</source>
          <target state="translated">待办事项:对此进行记录</target>
        </trans-unit>
        <trans-unit id="26dbb18df63ed25641cd65981a2bd8abf41c6420" translate="yes" xml:space="preserve">
          <source>TODO: Document those cases.</source>
          <target state="translated">待办事项:记录这些案件。</target>
        </trans-unit>
        <trans-unit id="503edd260136cc51f7d583a68da986091421e06f" translate="yes" xml:space="preserve">
          <source>TODO: a corpus of sample Pod input and HTML output? Or common idioms?</source>
          <target state="translated">TODO:花苞输入和HTML输出的样本语料库?或者常见的成语?</target>
        </trans-unit>
        <trans-unit id="2804185099bb0257ffff9bf0a6b003ba897a8c8c" translate="yes" xml:space="preserve">
          <source>TOGGLES</source>
          <target state="translated">TOGGLES</target>
        </trans-unit>
        <trans-unit id="fbc5612fa4f39d021c8212de6294e10fc0eb4c60" translate="yes" xml:space="preserve">
          <source>TOPMARK</source>
          <target state="translated">TOPMARK</target>
        </trans-unit>
        <trans-unit id="1b219778d2536bb7cb3443c1e48b1cdc6ec5bbcd" translate="yes" xml:space="preserve">
          <source>TOP_GV</source>
          <target state="translated">TOP_GV</target>
        </trans-unit>
        <trans-unit id="028dc78f2472e443fde9354a9093737ec708fdc1" translate="yes" xml:space="preserve">
          <source>TOP_NAME</source>
          <target state="translated">TOP_NAME</target>
        </trans-unit>
        <trans-unit id="767b9b1886f65db5d2c2efe4d311ec16282ddf3e" translate="yes" xml:space="preserve">
          <source>TOTAL RESULTS</source>
          <target state="translated">总结果</target>
        </trans-unit>
        <trans-unit id="e69a3c58feb4943f28d4f3916d734de76e706681" translate="yes" xml:space="preserve">
          <source>TR16 implies a method to extend UTF-EBCDIC to encode points up through &lt;code&gt;2 ** 31 - 1&lt;/code&gt;. Perl uses this method for code points up through &lt;code&gt;2 ** 30 - 1&lt;/code&gt;, but uses an incompatible method for larger ones, to enable it to handle much larger code points than otherwise.</source>
          <target state="translated">TR16表示一种扩展UTF-EBCDIC的方法，以编码直到 &lt;code&gt;2 ** 31 - 1&lt;/code&gt; 31-1的点。 Perl对最多 &lt;code&gt;2 ** 30 - 1&lt;/code&gt; 代码点使用此方法，但对较大的代码点使用不兼容的方法，以使其能够处理比其他方法大得多的代码点。</target>
        </trans-unit>
        <trans-unit id="6168d5c87ca259972f2a01ffcfd10f094db6e548" translate="yes" xml:space="preserve">
          <source>TRANSFORMATION FORMATS</source>
          <target state="translated">变换格式</target>
        </trans-unit>
        <trans-unit id="08e80e877114a02316e2a85c727dc2ec2e8d050b" translate="yes" xml:space="preserve">
          <source>TRANSLATIONS</source>
          <target state="translated">TRANSLATIONS</target>
        </trans-unit>
        <trans-unit id="881efc13a4ce5c9b7f10acdee48bdf35dab16bcd" translate="yes" xml:space="preserve">
          <source>TREE-BASED PARSING</source>
          <target state="translated">以树为基础的切菜</target>
        </trans-unit>
        <trans-unit id="8c6a137afc05b19ebfa9464a819fe4c729451ba3" translate="yes" xml:space="preserve">
          <source>TRIEC</source>
          <target state="translated">TRIEC</target>
        </trans-unit>
        <trans-unit id="4c899cd91fe33df0b8e34be446bc5d1535c00392" translate="yes" xml:space="preserve">
          <source>TRIEE</source>
          <target state="translated">TRIEE</target>
        </trans-unit>
        <trans-unit id="4e29af22b66831d0809f9ed161ff9fdacd21c3da" translate="yes" xml:space="preserve">
          <source>TRIEM</source>
          <target state="translated">TRIEM</target>
        </trans-unit>
        <trans-unit id="55c5fdc09a5315c1ab2a4b0b8470a49a53936b60" translate="yes" xml:space="preserve">
          <source>TRIGONOMETRIC FUNCTIONS</source>
          <target state="translated">触发函数</target>
        </trans-unit>
        <trans-unit id="fddf1df7c30cac7908d10246256efd264ce7aa32" translate="yes" xml:space="preserve">
          <source>TRUE</source>
          <target state="translated">TRUE</target>
        </trans-unit>
        <trans-unit id="d814d3e7d55ad64b9a68fdab60bd5741a6c86453" translate="yes" xml:space="preserve">
          <source>TUTORIAL</source>
          <target state="translated">TUTORIAL</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="fe62cb78f4ed9f61dd4406f0f3143d6f618cef25" translate="yes" xml:space="preserve">
          <source>TYPEMAPS</source>
          <target state="translated">TYPEMAPS</target>
        </trans-unit>
        <trans-unit id="40ea9041285003e004a8f6fe2dd14ebb07961af2" translate="yes" xml:space="preserve">
          <source>TYPES</source>
          <target state="translated">TYPES</target>
        </trans-unit>
        <trans-unit id="fcac4a88dd04636da037a74fcf1d813d6bb5c767" translate="yes" xml:space="preserve">
          <source>TYPES OF VERSION OBJECTS</source>
          <target state="translated">版本对象类型</target>
        </trans-unit>
        <trans-unit id="0cb5c671d380f7e563f1ea67cb13227761e097ff" translate="yes" xml:space="preserve">
          <source>T_ARRAY</source>
          <target state="translated">T_ARRAY</target>
        </trans-unit>
        <trans-unit id="5a44f0733ece8e94e30b4779d69997f4ee33c56f" translate="yes" xml:space="preserve">
          <source>T_AVREF</source>
          <target state="translated">T_AVREF</target>
        </trans-unit>
        <trans-unit id="20c8d07e48603a91f5ad0258a9d7260fecf703f4" translate="yes" xml:space="preserve">
          <source>T_AVREF_REFCOUNT_FIXED</source>
          <target state="translated">T_AVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="441dcc9bf7c8874857cd2f07add2544a7aa18348" translate="yes" xml:space="preserve">
          <source>T_BOOL</source>
          <target state="translated">T_BOOL</target>
        </trans-unit>
        <trans-unit id="c96681120818e54685540689763746057da6c711" translate="yes" xml:space="preserve">
          <source>T_CALLBACK</source>
          <target state="translated">T_CALLBACK</target>
        </trans-unit>
        <trans-unit id="1d4f3aa1dcbc52712656445982d93cb57df8eefd" translate="yes" xml:space="preserve">
          <source>T_CHAR</source>
          <target state="translated">T_CHAR</target>
        </trans-unit>
        <trans-unit id="619c206b9e7e1179f8c572c2e0bbd5418dcbcd9c" translate="yes" xml:space="preserve">
          <source>T_CVREF</source>
          <target state="translated">T_CVREF</target>
        </trans-unit>
        <trans-unit id="6bf16578ac0037942fb294227b378783d6417250" translate="yes" xml:space="preserve">
          <source>T_CVREF_REFCOUNT_FIXED</source>
          <target state="translated">T_CVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="ebd5f4b2b2cdf44ca91f90320178cc872c0e09c7" translate="yes" xml:space="preserve">
          <source>T_DATAUNIT</source>
          <target state="translated">T_DATAUNIT</target>
        </trans-unit>
        <trans-unit id="fe14988da15a2d4fcafb4d4c3fdba996b1d3919b" translate="yes" xml:space="preserve">
          <source>T_DOUBLE</source>
          <target state="translated">T_DOUBLE</target>
        </trans-unit>
        <trans-unit id="fc54a411f035f09e5b26e9d5967f486a6331f42c" translate="yes" xml:space="preserve">
          <source>T_ENUM</source>
          <target state="translated">T_ENUM</target>
        </trans-unit>
        <trans-unit id="d9144dfb59c0a6e098f071eb27226d345bb3b9a3" translate="yes" xml:space="preserve">
          <source>T_FLOAT</source>
          <target state="translated">T_FLOAT</target>
        </trans-unit>
        <trans-unit id="a488a491ef416eedb274173547cc94600a1c1be9" translate="yes" xml:space="preserve">
          <source>T_HVREF</source>
          <target state="translated">T_HVREF</target>
        </trans-unit>
        <trans-unit id="e9eb1cfbb5a736f4b47a7fce8d35e124bff4c588" translate="yes" xml:space="preserve">
          <source>T_HVREF_REFCOUNT_FIXED</source>
          <target state="translated">T_HVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="4baf8db3b4ede993cae1ba43114ca8ba3f059451" translate="yes" xml:space="preserve">
          <source>T_IN</source>
          <target state="translated">T_IN</target>
        </trans-unit>
        <trans-unit id="0d34ad725c5d489d88c10068319bbe41b1372c3f" translate="yes" xml:space="preserve">
          <source>T_INOUT</source>
          <target state="translated">T_INOUT</target>
        </trans-unit>
        <trans-unit id="c9ac30f3bfe7d2f1be494ab16cbb62e6b0281825" translate="yes" xml:space="preserve">
          <source>T_INT</source>
          <target state="translated">T_INT</target>
        </trans-unit>
        <trans-unit id="71be7a946c6f9c8f878e909304790177b9d9322d" translate="yes" xml:space="preserve">
          <source>T_IV</source>
          <target state="translated">T_IV</target>
        </trans-unit>
        <trans-unit id="eaf82e3c7e0aec5ed4944f8734b7934b5d7a9464" translate="yes" xml:space="preserve">
          <source>T_LONG</source>
          <target state="translated">T_LONG</target>
        </trans-unit>
        <trans-unit id="5b8224b3c1fe92d5bae70adacc8eac05fd9a5fda" translate="yes" xml:space="preserve">
          <source>T_NV</source>
          <target state="translated">T_NV</target>
        </trans-unit>
        <trans-unit id="a6b2c10bebc0632668de5a633339c42212334462" translate="yes" xml:space="preserve">
          <source>T_OPAQUE</source>
          <target state="translated">T_OPAQUE</target>
        </trans-unit>
        <trans-unit id="3409e584f0822b2e9f6e17cf539649bef61e2695" translate="yes" xml:space="preserve">
          <source>T_OPAQUE supports input and output of simple types. T_OPAQUEPTR can be used to pass these bytes back into C if a pointer is acceptable.</source>
          <target state="translated">T_OPAQUE支持简单类型的输入和输出。如果一个指针是可以接受的,那么T_OPAQUEPTR可以用来将这些字节传回C语言中。</target>
        </trans-unit>
        <trans-unit id="4d81bbcffee2d4d53636e0cfc38c1802b032ce1e" translate="yes" xml:space="preserve">
          <source>T_OPAQUEPTR</source>
          <target state="translated">T_OPAQUEPTR</target>
        </trans-unit>
        <trans-unit id="94ed49f0fcb197292e8b44f17a54e91c96dfd034" translate="yes" xml:space="preserve">
          <source>T_OUT</source>
          <target state="translated">T_OUT</target>
        </trans-unit>
        <trans-unit id="2a34e55dba9603dc2ed22d9cbacb17ec8fa3b7aa" translate="yes" xml:space="preserve">
          <source>T_PACKED</source>
          <target state="translated">T_PACKED</target>
        </trans-unit>
        <trans-unit id="57d9968b716d10e58d7663155b60bcfe636fd9da" translate="yes" xml:space="preserve">
          <source>T_PACKEDARRAY</source>
          <target state="translated">T_PACKEDARRAY</target>
        </trans-unit>
        <trans-unit id="2acdc87aba62301b1c46833bbb0d8a2ab24b5d4c" translate="yes" xml:space="preserve">
          <source>T_PACKEDARRAY is similar to T_PACKED. In fact, the &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) typemap is identical, but the &lt;code&gt;OUTPUT&lt;/code&gt; typemap passes an additional argument to the &lt;code&gt;XS_pack_$ntype&lt;/code&gt; function. This third parameter indicates the number of elements in the output so that the function can handle C arrays sanely. The variable needs to be declared by the user and must have the name &lt;code&gt;count_$ntype&lt;/code&gt; where &lt;code&gt;$ntype&lt;/code&gt; is the normalized C type name as explained above. The signature of the function would be for the example above and &lt;code&gt;foo_t **&lt;/code&gt; :</source>
          <target state="translated">T_PACKEDARRAY与T_PACKED类似。实际上， &lt;code&gt;INPUT&lt;/code&gt; （从Perl到XSUB）类型映射是相同的，但是 &lt;code&gt;OUTPUT&lt;/code&gt; 类型映射将附加参数传递给 &lt;code&gt;XS_pack_$ntype&lt;/code&gt; 函数。第三个参数指示输出中元素的数量，以便函数可以合理地处理C数组。该变量需要由用户声明，并且必须具有名称 &lt;code&gt;count_$ntype&lt;/code&gt; ，其中 &lt;code&gt;$ntype&lt;/code&gt; 是如上所述的规范化C类型名称。该函数的签名将用于上面的示例和 &lt;code&gt;foo_t **&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1c906d78fc823a0e9f29368dd513ce8a5418cee5" translate="yes" xml:space="preserve">
          <source>T_PACKEDARRAY is similar to T_PACKED. In fact, the &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) typemap is identical, but the &lt;code&gt;OUTPUT&lt;/code&gt; typemap passes an additional argument to the &lt;code&gt;XS_pack_$ntype&lt;/code&gt; function. This third parameter indicates the number of elements in the output so that the function can handle C arrays sanely. The variable needs to be declared by the user and must have the name &lt;code&gt;count_$ntype&lt;/code&gt; where &lt;code&gt;$ntype&lt;/code&gt; is the normalized C type name as explained above. The signature of the function would be for the example above and &lt;code&gt;foo_t **&lt;/code&gt;:</source>
          <target state="translated">T_PACKEDARRAY与T_PACKED类似。实际上， &lt;code&gt;INPUT&lt;/code&gt; （从Perl到XSUB）类型映射是相同的，但是 &lt;code&gt;OUTPUT&lt;/code&gt; 类型映射将附加参数传递给 &lt;code&gt;XS_pack_$ntype&lt;/code&gt; 函数。第三个参数指示输出中元素的数量，以便该函数可以合理地处理C数组。该变量需要由用户声明，并且必须具有名称 &lt;code&gt;count_$ntype&lt;/code&gt; ，其中 &lt;code&gt;$ntype&lt;/code&gt; 是如上所述的规范化C类型名称。该函数的签名将用于上面的示例和 &lt;code&gt;foo_t **&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e820d7c1bd9a291e980383d064a4e16d0aba0000" translate="yes" xml:space="preserve">
          <source>T_PTR</source>
          <target state="translated">T_PTR</target>
        </trans-unit>
        <trans-unit id="af1f6fafe92e003dd267b2be4f4b4ef95598f8ab" translate="yes" xml:space="preserve">
          <source>T_PTRDESC</source>
          <target state="translated">T_PTRDESC</target>
        </trans-unit>
        <trans-unit id="1dea827458dd7afc9afab55ca4ec0182c83a4fc4" translate="yes" xml:space="preserve">
          <source>T_PTROBJ</source>
          <target state="translated">T_PTROBJ</target>
        </trans-unit>
        <trans-unit id="1ee34e1644f9ab8be830a408f52ae4dc2849ef55" translate="yes" xml:space="preserve">
          <source>T_PTRREF</source>
          <target state="translated">T_PTRREF</target>
        </trans-unit>
        <trans-unit id="c8c1dc76ec8744f6cb9d9c795f9bfbc5484c1e4d" translate="yes" xml:space="preserve">
          <source>T_PV</source>
          <target state="translated">T_PV</target>
        </trans-unit>
        <trans-unit id="3a5d267dcac84a0b73c5ab78fe0237e26042a945" translate="yes" xml:space="preserve">
          <source>T_REFOBJ</source>
          <target state="translated">T_REFOBJ</target>
        </trans-unit>
        <trans-unit id="35b0d1f3ee1694c51f5d1834c393cb455273def0" translate="yes" xml:space="preserve">
          <source>T_REFREF</source>
          <target state="translated">T_REFREF</target>
        </trans-unit>
        <trans-unit id="784caeb6be6fa5307fa5f6a8479f73d2c2a7691b" translate="yes" xml:space="preserve">
          <source>T_REF_IV_PTR</source>
          <target state="translated">T_REF_IV_PTR</target>
        </trans-unit>
        <trans-unit id="b3253f9127be3bdfed118ec52937984abc7c698c" translate="yes" xml:space="preserve">
          <source>T_REF_IV_REF</source>
          <target state="translated">T_REF_IV_REF</target>
        </trans-unit>
        <trans-unit id="586e2f7a6caf54d31aba57fd6ffdf405333ef314" translate="yes" xml:space="preserve">
          <source>T_SHORT</source>
          <target state="translated">T_SHORT</target>
        </trans-unit>
        <trans-unit id="5e2b55747cebf0deadf14e37c20ac8ae0c863ea6" translate="yes" xml:space="preserve">
          <source>T_STDIO</source>
          <target state="translated">T_STDIO</target>
        </trans-unit>
        <trans-unit id="998ce6a132418997f012a8d95a08e955ec444167" translate="yes" xml:space="preserve">
          <source>T_SV</source>
          <target state="translated">T_SV</target>
        </trans-unit>
        <trans-unit id="f74fedb4d19c9aae5df1a9a2556f420561de423a" translate="yes" xml:space="preserve">
          <source>T_SVREF</source>
          <target state="translated">T_SVREF</target>
        </trans-unit>
        <trans-unit id="b31c4d98a369de70efd9e1e28b9897a696583da4" translate="yes" xml:space="preserve">
          <source>T_SVREF_FIXED</source>
          <target state="translated">T_SVREF_FIXED</target>
        </trans-unit>
        <trans-unit id="4512816ed0e7eedba9cb2a4f99052651f37fbd5b" translate="yes" xml:space="preserve">
          <source>T_SYSRET</source>
          <target state="translated">T_SYSRET</target>
        </trans-unit>
        <trans-unit id="fe86ffcf28dab8688bad0d5d6a6ff6be7af3bf8e" translate="yes" xml:space="preserve">
          <source>T_UV</source>
          <target state="translated">T_UV</target>
        </trans-unit>
        <trans-unit id="d8679fa31c93e6fb7cc082350054dc4f5ca62292" translate="yes" xml:space="preserve">
          <source>T_U_CHAR</source>
          <target state="translated">T_U_CHAR</target>
        </trans-unit>
        <trans-unit id="464c580d57f537b018efa810de5fcaf9cd86a995" translate="yes" xml:space="preserve">
          <source>T_U_INT</source>
          <target state="translated">T_U_INT</target>
        </trans-unit>
        <trans-unit id="1df30c0b01ecbd04a2bc7cb066c197a1ef8a203b" translate="yes" xml:space="preserve">
          <source>T_U_LONG</source>
          <target state="translated">T_U_LONG</target>
        </trans-unit>
        <trans-unit id="f31b217f3c82ab68ac7452146830667f22ddb6a9" translate="yes" xml:space="preserve">
          <source>T_U_LONG is used for type &lt;code&gt;U32&lt;/code&gt; in the standard typemap.</source>
          <target state="translated">T_U_LONG用于标准类型图中的 &lt;code&gt;U32&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="11359764d9baa3629eadc5745b2516619c5dfc84" translate="yes" xml:space="preserve">
          <source>T_U_SHORT</source>
          <target state="translated">T_U_SHORT</target>
        </trans-unit>
        <trans-unit id="067c0c90742a514deacd491758ccd4ba0e1d9275" translate="yes" xml:space="preserve">
          <source>T_U_SHORT is used for type &lt;code&gt;U16&lt;/code&gt; in the standard typemap.</source>
          <target state="translated">T_U_SHORT用于标准类型图中的 &lt;code&gt;U16&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="267d7ded4fb1f4fe830b757c69adcb120de3c36c" translate="yes" xml:space="preserve">
          <source>Table in hex, sorted in 1047 order</source>
          <target state="translated">十六进制表,按1047顺序排列。</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">目录</target>
        </trans-unit>
        <trans-unit id="f6f2ebfa1ea92516cffdbcabbc226ad6201fc14f" translate="yes" xml:space="preserve">
          <source>Tag Handling Utility Functions</source>
          <target state="translated">标签处理实用功能</target>
        </trans-unit>
        <trans-unit id="c4acb5d65a0f18ccc12ec4e74dc4599e0548b6c1" translate="yes" xml:space="preserve">
          <source>Tag that should prefix/identify the main text.</source>
          <target state="translated">应在正文前加注/标识的标签。</target>
        </trans-unit>
        <trans-unit id="8a6299767c14d608575e773d7c250b1dd1bef09f" translate="yes" xml:space="preserve">
          <source>Tags and names for human languages</source>
          <target state="translated">人类语言的标签和名称</target>
        </trans-unit>
        <trans-unit id="0caddaacf6ffdd3b4a1f2e6c28c9c60f84fe10e3" translate="yes" xml:space="preserve">
          <source>Tags for the Identification of Languages</source>
          <target state="translated">识别语言的标签</target>
        </trans-unit>
        <trans-unit id="3837bf859c22ab45640f5a47597c86d61ec1aac5" translate="yes" xml:space="preserve">
          <source>Tailoring is not maximum</source>
          <target state="translated">量体裁衣不是最大限度</target>
        </trans-unit>
        <trans-unit id="7dd10fdbdba33897c84afb3ba431dd5441966417" translate="yes" xml:space="preserve">
          <source>Tailoring tags provided by &lt;code&gt;Unicode::Collate&lt;/code&gt; are allowed as long as they are not used for &lt;code&gt;locale&lt;/code&gt; support. Esp. the &lt;code&gt;table&lt;/code&gt; tag is always untailorable, since it is reserved for DUCET.</source>
          <target state="translated">允许使用 &lt;code&gt;Unicode::Collate&lt;/code&gt; 提供的定制标签，只要它们不用于 &lt;code&gt;locale&lt;/code&gt; 支持即可。Esp。该 &lt;code&gt;table&lt;/code&gt; 标签总是untailorable，因为它被留作DUCET。</target>
        </trans-unit>
        <trans-unit id="40a3c4882101734d96d5257d2a74ae5e78eaf3de" translate="yes" xml:space="preserve">
          <source>Taint Mode</source>
          <target state="translated">污染模式</target>
        </trans-unit>
        <trans-unit id="f63611c6fa286ffcd2142b28c1284de824194c00" translate="yes" xml:space="preserve">
          <source>Taint an SV. Use &lt;code&gt;SvTAINTED_on&lt;/code&gt; instead.</source>
          <target state="translated">污染SV。请改用 &lt;code&gt;SvTAINTED_on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="413e513edb03310442a1614d65a7d4ad85d457e0" translate="yes" xml:space="preserve">
          <source>Taint checking is most useful when although you trust yourself not to have written a program to give away the farm, you don't necessarily trust those who end up using it not to try to trick it into doing something bad. This is the kind of security checking that's useful for set-id programs and programs launched on someone else's behalf, like CGI programs.</source>
          <target state="translated">污点检查最有用的情况是,虽然你相信自己没有写出一个程序来送农场,但你不一定相信那些最终使用它的人不会试图欺骗它去做一些坏事。这类安全检查对于设定好的程序和以别人的名义启动的程序,比如CGI程序,是很有用的。</target>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="translated">污染模式</target>
        </trans-unit>
        <trans-unit id="504eb6d55f3dd75624d53392fb2ec7ee299aa14f" translate="yes" xml:space="preserve">
          <source>Taint mode and @INC</source>
          <target state="translated">污染模式和@INC</target>
        </trans-unit>
        <trans-unit id="ca7cdb9c133f6b8c9e0adf757dd404ca3a0059a6" translate="yes" xml:space="preserve">
          <source>Taint mode is a funny thing. It's the globalest of all global features. Once you turn it on, it affects</source>
          <target state="translated">污点模式是个有趣的东西。它是所有全局功能中最全局的一个。一旦你打开它,它就会影响</target>
        </trans-unit>
        <trans-unit id="d6624f88ac2856ed8ccebfe23a63eebf43e447bd" translate="yes" xml:space="preserve">
          <source>Tainting is also likely if the pattern is to be matched case-insensitively (via &lt;code&gt;/i&lt;/code&gt;). The exception is if all the code points to be matched this way are above 255 and do not have folds under Unicode rules to below 256. Tainting is not done for these because Perl only uses Unicode rules for such code points, and those rules are the same no matter what the current locale.</source>
          <target state="translated">如果要不区分大小写地匹配模式（通过 &lt;code&gt;/i&lt;/code&gt; ），也可能会出现污点。唯一的例外是，如果所有要以此方式匹配的代码点都在255以上，并且在Unicode规则下没有折叠到256以下。由于Perl仅对此类代码点使用Unicode规则，因此不对此进行着色。无论当前语言环境如何，都一样。</target>
        </trans-unit>
        <trans-unit id="b1e437790166193a4c207aa58d0fb3a4d2a31ed7" translate="yes" xml:space="preserve">
          <source>Taints an SV if tainting is enabled, and if some input to the current expression is tainted--usually a variable, but possibly also implicit inputs such as locale settings. &lt;code&gt;SvTAINT&lt;/code&gt; propagates that taintedness to the outputs of an expression in a pessimistic fashion; i.e., without paying attention to precisely which outputs are influenced by which inputs.</source>
          <target state="translated">如果启用了污点并且对当前表达式的某些输入被污点（通常是变量），但也可能隐式输入（例如语言环境设置），会污染SV。 &lt;code&gt;SvTAINT&lt;/code&gt; 以悲观的方式将这种污点传播到表达式的输出中。即，无需精确注意哪些输出受哪些输入影响。</target>
        </trans-unit>
        <trans-unit id="094d515b3608fefc6759a36412cee467437417a5" translate="yes" xml:space="preserve">
          <source>Taiwan</source>
          <target state="translated">Taiwan</target>
        </trans-unit>
        <trans-unit id="750e96a06b9d3c66d6ca7a66a25a581164f0d409" translate="yes" xml:space="preserve">
          <source>Taiwan-based Chinese Encodings</source>
          <target state="translated">台湾中文编码</target>
        </trans-unit>
        <trans-unit id="721a6538b5b10ed9a1dc1b3ba2e846c06156cf4e" translate="yes" xml:space="preserve">
          <source>Take a look at &lt;a href=&quot;#Good-Practices&quot;&gt;&quot;Good Practices&quot;&lt;/a&gt; for some variants you will like to use in modern Perl code.</source>
          <target state="translated">查看一些您希望在现代Perl代码中使用的变体的&lt;a href=&quot;#Good-Practices&quot;&gt;&amp;ldquo;良好实践&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a5b403505c94cab4e9f224e4af932dc5aa9d4c7" translate="yes" xml:space="preserve">
          <source>Take a look at &lt;a href=&quot;#Good-Practices&quot;&gt;Good Practices&lt;/a&gt; for some variants you will like to use in modern Perl code.</source>
          <target state="translated">查看一些您希望在现代Perl代码中使用的变体的&lt;a href=&quot;#Good-Practices&quot;&gt;良好实践&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce0dca464ee27d4966793e761a9ad0e74805bf7a" translate="yes" xml:space="preserve">
          <source>Take a look at the line:</source>
          <target state="translated">看看这条线。</target>
        </trans-unit>
        <trans-unit id="0faa440c7d98bab2d9d32df3b6d3a1c7c9671be2" translate="yes" xml:space="preserve">
          <source>Take a sprintf-style format pattern and argument list. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;&quot;mess_sv&quot;&lt;/a&gt;.</source>
          <target state="translated">采取sprintf样式的格式模式和参数列表。这些用于生成字符串消息。如果消息不是以换行符结尾，则将使用代码中当前位置的某种指示来对其进行扩展，如针对&lt;a href=&quot;#mess_sv&quot;&gt;&amp;ldquo; mess_sv&amp;rdquo;所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e2b74024aba36db1a23fa804fd1c560d6088d9a" translate="yes" xml:space="preserve">
          <source>Take a sprintf-style format pattern and argument list. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt;.</source>
          <target state="translated">采用sprintf样式的格式模式和参数列表。这些用于生成字符串消息。如果消息不是以换行符结尾，则将使用代码中当前位置的某种指示来对其进行扩展，如&lt;a href=&quot;#mess_sv&quot;&gt;mess_sv所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb04817116fcc4f36afb8949c5edb0a2147a3489" translate="yes" xml:space="preserve">
          <source>Take care when changing a released module.</source>
          <target state="translated">更换已发布的模块时要注意。</target>
        </trans-unit>
        <trans-unit id="fcbbed68b647be19cced53ca66bc41d5fb7b63bd" translate="yes" xml:space="preserve">
          <source>Take care when using this function simply as a truth test (such as in &lt;code&gt;&lt;a href=&quot;../functions/if&quot;&gt;if&lt;/a&gt;(blessed $ref)...&lt;/code&gt; ) because the package name &lt;code&gt;&quot;0&quot;&lt;/code&gt; is defined yet false.</source>
          <target state="translated">在将此函数仅用作真值测试时（例如，在 &lt;code&gt;&lt;a href=&quot;../functions/if&quot;&gt;if&lt;/a&gt;(blessed $ref)...&lt;/code&gt; ），请小心，因为已定义包名称 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 但为false。</target>
        </trans-unit>
        <trans-unit id="ef3657e7016525093062a8f4afb4bc9e87224179" translate="yes" xml:space="preserve">
          <source>Take care when using this function simply as a truth test (such as in &lt;code&gt;if(blessed $ref)...&lt;/code&gt;) because the package name &lt;code&gt;&quot;0&quot;&lt;/code&gt; is defined yet false.</source>
          <target state="translated">当将此函数仅用作真值测试时（例如，在 &lt;code&gt;if(blessed $ref)...&lt;/code&gt; ），请小心，因为已定义包名称 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 但为false。</target>
        </trans-unit>
        <trans-unit id="c4c196051206e9d1dadde68b1305cdecd7c48024" translate="yes" xml:space="preserve">
          <source>Take the example case of trying to split a string that is comma-separated into its different fields. You can't use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split(/,/)&lt;/a&gt;&lt;/code&gt; because you shouldn't split if the comma is inside quotes. For example, take a data line like this:</source>
          <target state="translated">以尝试将以逗号分隔的字符串拆分为不同字段的示例为例。您不能使用 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split(/,/)&lt;/a&gt;&lt;/code&gt; ,因为如果逗号在引号内，则不应拆分。例如，采用如下数据线：</target>
        </trans-unit>
        <trans-unit id="5ea9de05e3ee1ea164412af8fdd54572b6cc0c61" translate="yes" xml:space="preserve">
          <source>Take the example case of trying to split a string that is comma-separated into its different fields. You can't use &lt;code&gt;split(/,/)&lt;/code&gt; because you shouldn't split if the comma is inside quotes. For example, take a data line like this:</source>
          <target state="translated">以尝试将以逗号分隔的字符串拆分为不同字段的示例为例。您不能使用 &lt;code&gt;split(/,/)&lt;/code&gt; ,因为如果逗号在引号内，则不应拆分。例如，采用如下数据线：</target>
        </trans-unit>
        <trans-unit id="4471e2b4acce8ca9f0f3bc156ed9ea2897b12f89" translate="yes" xml:space="preserve">
          <source>Take the opportunity to reconsider and redesign the interfaces.</source>
          <target state="translated">借此机会,重新考虑并重新设计接口。</target>
        </trans-unit>
        <trans-unit id="38337f43effe3e61774eb1d00c750689a8d079b1" translate="yes" xml:space="preserve">
          <source>Taken all together, XS code to hook an op checker should typically look something like this:</source>
          <target state="translated">综上所述,XS代码挂接运算检查器通常应该是这样的。</target>
        </trans-unit>
        <trans-unit id="8d9469ecd951c6dfc6bb0697f6f2439dea0638b6" translate="yes" xml:space="preserve">
          <source>Taken all together, XS code to install a keyword plugin should typically look something like this:</source>
          <target state="translated">综合来看,安装关键词插件的XS代码一般应该是这样的。</target>
        </trans-unit>
        <trans-unit id="891afd1ff7caaa23526c0cd4250f4fb5063fe719" translate="yes" xml:space="preserve">
          <source>Taken together, these features go a long way towards making Perl's regular expressions more readable. Here's an example:</source>
          <target state="translated">总的来说,这些特性对提高Perl的正则表达式的可读性有很大的帮助。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="4a4ea905801094be1d9ff65acd694844f81d1d62" translate="yes" xml:space="preserve">
          <source>Takes STRING and replaces all referenced environment variable names with their defined values. References to environment variables take the form &lt;code&gt;%VariableName%&lt;/code&gt;. Case is ignored when looking up the VariableName in the environment. If the variable is not found then the original &lt;code&gt;%VariableName%&lt;/code&gt; text is retained. Has the same effect as the following:</source>
          <target state="translated">采用STRING并将所有引用的环境变量名称替换为其定义的值。对环境变量的引用采用 &lt;code&gt;%VariableName%&lt;/code&gt; 的形式。在环境中查找VariableName时忽略大小写。如果找不到该 &lt;code&gt;%VariableName%&lt;/code&gt; 则保留原始％VariableName％文本。具有与以下相同的效果：</target>
        </trans-unit>
        <trans-unit id="d4622f933170417209394d51b607728c20fb64f4" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_in6&lt;/code&gt; structure. Returns a list of four elements: the port number, an opaque string representing the IPv6 address, the scope ID, and the flow label. (You can use inet_ntop() to convert the address to the usual string format). Will croak if the structure does not represent an &lt;code&gt;AF_INET6&lt;/code&gt; address.</source>
          <target state="translated">采用 &lt;code&gt;sockaddr_in6&lt;/code&gt; 结构。返回四个元素的列表：端口号，代表IPv6地址的不透明字符串，作用域ID和流标签。（您可以使用inet_ntop（）将地址转换为通常的字符串格式）。如果结构不代表 &lt;code&gt;AF_INET6&lt;/code&gt; 地址，则会发出嘶哑的声音。</target>
        </trans-unit>
        <trans-unit id="8ffd8f37fe17f4475f9ac3335803a5668dd9a5a9" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_in&lt;/code&gt; structure (as returned by pack_sockaddr_in(), getpeername() or recv()). Returns a list of two elements: the port and an opaque string representing the IP address (you can use inet_ntoa() to convert the address to the four-dotted numeric format). Will croak if the structure does not represent an &lt;code&gt;AF_INET&lt;/code&gt; address.</source>
          <target state="translated">采用 &lt;code&gt;sockaddr_in&lt;/code&gt; 结构（由pack_sockaddr_in（），getpeername（）或recv（）返回）。返回两个元素的列表：端口和代表IP地址的不透明字符串（可以使用inet_ntoa（）将地址转换为四点数字格式）。如果结构不代表 &lt;code&gt;AF_INET&lt;/code&gt; 地址，则会发出嘶哑的声音。</target>
        </trans-unit>
        <trans-unit id="0d55a321d267dd95843d2a82446b8e074d9b4482" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_un&lt;/code&gt; structure (as returned by pack_sockaddr_un(), getpeername() or recv()). Returns a list of one element: the pathname. Will croak if the structure does not represent an &lt;code&gt;AF_UNIX&lt;/code&gt; address.</source>
          <target state="translated">采用 &lt;code&gt;sockaddr_un&lt;/code&gt; 结构（由pack_sockaddr_un（），getpeername（）或recv（）返回）。返回一个元素的列表：路径名。如果结构不代表 &lt;code&gt;AF_UNIX&lt;/code&gt; 地址，则会发出嘶哑的声音。</target>
        </trans-unit>
        <trans-unit id="b39b8aaa0796e13f2d536ba4ee5000dfd3368b8e" translate="yes" xml:space="preserve">
          <source>Takes a LIST of values and converts it into a string using the rules given by the TEMPLATE. The resulting string is the concatenation of the converted values. Typically, each converted value looks like its machine-level representation. For example, on 32-bit machines an integer may be represented by a sequence of 4 bytes, which will in Perl be presented as a string that's 4 characters long.</source>
          <target state="translated">获取一个值的LIST,并使用TEMPLATE给出的规则将其转换为字符串。转换后的字符串是转换后的值的连接。通常情况下,每个转换后的值看起来像它的机器级表示。例如,在32位的机器上,一个整数可以用4个字节的序列来表示,在Perl中,它将以一个4个字符长的字符串来表示。</target>
        </trans-unit>
        <trans-unit id="5d9e5ca84b2f91280b89e01ed94d448f6437f46f" translate="yes" xml:space="preserve">
          <source>Takes a Perl file handle [like &lt;code&gt;STDIN&lt;/code&gt;] and returns the Win32 native file handle associated with it. See &lt;code&gt;FdGetOsFHandle&lt;/code&gt; for more information about Win32 native file handles.</source>
          <target state="translated">接受一个Perl文件句柄[如 &lt;code&gt;STDIN&lt;/code&gt; ]并返回与其关联的Win32本机文件句柄。有关Win32本机文件句柄的更多信息，请参见 &lt;code&gt;FdGetOsFHandle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5777f296cd09b6af58dac04faade91e80e2f742c" translate="yes" xml:space="preserve">
          <source>Takes a UTILITY name as an argument, returns the first perl version by release date where that utility was removed from core. Returns undef if the given utility was never in core or remains in core.</source>
          <target state="translated">以 UTILITY 名称为参数,返回该实用程序从 core 中删除的第一个 perl 版本的发布日期。如果给定的实用程序从未在core中出现过或仍在core中,则返回undef。</target>
        </trans-unit>
        <trans-unit id="4f7b238435e86c0619ef99b46a51606dfb01c0fc" translate="yes" xml:space="preserve">
          <source>Takes a UTILITY name as an argument, returns the first perl version where that utility was removed from core. Returns undef if the given utility was never in core or remains in core.</source>
          <target state="translated">以UTILITY名称作为参数,返回该实用程序从core中删除的第一个perl版本。如果给定的实用程序从来没有在核心中出现过或者仍然在核心中,则返回undef。</target>
        </trans-unit>
        <trans-unit id="4a15df0cc84f3e918f628b048394d65bbdcbb8c8" translate="yes" xml:space="preserve">
          <source>Takes a Win32 native file handle and returns a &lt;code&gt;FILE_TYPE_*&lt;/code&gt; constant indicating the type of the file opened on that handle:</source>
          <target state="translated">使用Win32本机文件句柄并返回 &lt;code&gt;FILE_TYPE_*&lt;/code&gt; 常量，指示在该句柄上打开的文件的类型：</target>
        </trans-unit>
        <trans-unit id="5bea2fb93e96bf3299efd7e7cc45533fa8e0d5df" translate="yes" xml:space="preserve">
          <source>Takes a destination path and an optional base path and returns a relative path from the base path to the destination path:</source>
          <target state="translated">取一个目标路径和一个可选的基本路径,并返回一个从基本路径到目标路径的相对路径。</target>
        </trans-unit>
        <trans-unit id="95774c404168139c6e80f1611020974553158f89" translate="yes" xml:space="preserve">
          <source>Takes a destination path and an optional base path returns a relative path from the base path to the destination path:</source>
          <target state="translated">取一个目标路径和一个可选的基本路径,返回一个从基本路径到目标路径的相对路径。</target>
        </trans-unit>
        <trans-unit id="d94b0d11d4ec10ac5d773f5e69a50730359dca25" translate="yes" xml:space="preserve">
          <source>Takes a filename, a scalar full of data and optionally a reference to a hash with specific options.</source>
          <target state="translated">取一个文件名,一个充满数据的标量和一个带有特定选项的哈希引用。</target>
        </trans-unit>
        <trans-unit id="ef9cdc80b0d99b082834a1fbb8d5a11a97402e97" translate="yes" xml:space="preserve">
          <source>Takes a list of capabilities as an argument and will croak if one is not found.</source>
          <target state="translated">以能力列表作为参数,如果没有找到能力列表,就会崩溃。</target>
        </trans-unit>
        <trans-unit id="2eadd3f3ba856c4409ed2499d0a3d0b488f0dfce" translate="yes" xml:space="preserve">
          <source>Takes a list of filenames and adds them to the in-memory archive.</source>
          <target state="translated">读取文件名列表,并将其添加到内存存档中。</target>
        </trans-unit>
        <trans-unit id="f1b41457fa3731d32047968d9b9c24bbf39e5764" translate="yes" xml:space="preserve">
          <source>Takes a module name as an argument, returns the first perl version by release date where that module was removed from core. Returns undef if the given module was never in core or remains in core.</source>
          <target state="translated">以模块名作为参数,返回该模块从core中删除的第一个perl版本的发布日期。如果给定的模块从未在core中出现过或者仍然在core中,则返回undef。</target>
        </trans-unit>
        <trans-unit id="f46e15336d9744fdb143311ac69c4190fa941309" translate="yes" xml:space="preserve">
          <source>Takes a module name as an argument, returns the first perl version where that module was removed from core. Returns undef if the given module was never in core or remains in core.</source>
          <target state="translated">以模块名作为参数,返回该模块从core中删除的第一个perl版本。如果给定的模块从未在core中出现过或者仍然在core中,则返回undef。</target>
        </trans-unit>
        <trans-unit id="b0cf83e512f827739a6bf491886eab3446e0a621" translate="yes" xml:space="preserve">
          <source>Takes a number, the value of the array base $[. Cannot be non-zero on Perl 5.15.3 or later.</source>
          <target state="translated">取一个数字,即数组基数$[.]的值。在Perl 5.15.3或更高版本中不能为非零。</target>
        </trans-unit>
        <trans-unit id="3cab02ff3e969b64dc6518292e8f9492855489a1" translate="yes" xml:space="preserve">
          <source>Takes a number, the value of the array base $[. Obsolete: cannot be non-zero.</source>
          <target state="translated">取一个数字,数组基数$[.的值。过时:不能为非零。</target>
        </trans-unit>
        <trans-unit id="4d4a8a89e95ecb8b9eb4bb3b63296961b32f06d1" translate="yes" xml:space="preserve">
          <source>Takes a numeric mode to apply to each created directory (not modified by the current &lt;code&gt;umask&lt;/code&gt;). If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="translated">采用数字模式以应用于每个创建的目录（当前 &lt;code&gt;umask&lt;/code&gt; 尚未修改）。如果目录已经存在（因此不需要创建），则不会修改权限。</target>
        </trans-unit>
        <trans-unit id="5735d53ded3f64fc817f32e6801f9c3332c8c742" translate="yes" xml:space="preserve">
          <source>Takes a packed binary address structure such as returned by unpack_sockaddr_in() (or a v-string representing the four octets of the IPv4 address in network order) and translates it into a string of the form &lt;code&gt;d.d.d.d&lt;/code&gt; where the &lt;code&gt;d&lt;/code&gt; s are numbers less than 256 (the normal human-readable four dotted number notation for Internet addresses).</source>
          <target state="translated">采用打包的二进制地址结构（例如unpack_sockaddr_in（）返回的值）（或按网络顺序表示IPv4地址的四个八位字节的v字符串），并将其转换为 &lt;code&gt;d.d.d.d&lt;/code&gt; 形式的字符串，其中 &lt;code&gt;d&lt;/code&gt; 是小于256的数字（互联网地址的普通人类可读的四点数字符号）。</target>
        </trans-unit>
        <trans-unit id="85cecd3a3130634b28d9c069ebd221905ff6684f" translate="yes" xml:space="preserve">
          <source>Takes a packed binary address structure such as returned by unpack_sockaddr_in() (or a v-string representing the four octets of the IPv4 address in network order) and translates it into a string of the form &lt;code&gt;d.d.d.d&lt;/code&gt; where the &lt;code&gt;d&lt;/code&gt;s are numbers less than 256 (the normal human-readable four dotted number notation for Internet addresses).</source>
          <target state="translated">采取打包的二进制地址结构（例如unpack_sockaddr_in（）返回的值）（或按网络顺序表示IPv4地址的四个八位字节的v字符串），并将其转换为 &lt;code&gt;d.d.d.d&lt;/code&gt; 形式的字符串，其中 &lt;code&gt;d&lt;/code&gt; 是小于256的数字（互联网地址的普通人类可读的四个点号表示法）。</target>
        </trans-unit>
        <trans-unit id="1a2abe4e916de97dcbd3a2d8761e95258307eb47" translate="yes" xml:space="preserve">
          <source>Takes a packed socket address (as returned by pack_sockaddr_in(), pack_sockaddr_un() or the perl builtin functions getsockname() and getpeername()). Returns the address family tag. This will be one of the &lt;code&gt;AF_*&lt;/code&gt; constants, such as &lt;code&gt;AF_INET&lt;/code&gt; for a &lt;code&gt;sockaddr_in&lt;/code&gt; addresses or &lt;code&gt;AF_UNIX&lt;/code&gt; for a &lt;code&gt;sockaddr_un&lt;/code&gt; . It can be used to figure out what unpack to use for a sockaddr of unknown type.</source>
          <target state="translated">接受一个压缩的套接字地址（由pack_sockaddr_in（），pack_sockaddr_un（）或perl内置函数getockname（）和getpeername（）返回）。返回地址族标签。这将是 &lt;code&gt;AF_*&lt;/code&gt; 常量之一，例如 &lt;code&gt;AF_INET&lt;/code&gt; 用于 &lt;code&gt;sockaddr_in&lt;/code&gt; 地址，或者 &lt;code&gt;AF_UNIX&lt;/code&gt; 用于 &lt;code&gt;sockaddr_un&lt;/code&gt; 。它可以用来找出对未知类型的sockaddr使用什么解压缩。</target>
        </trans-unit>
        <trans-unit id="00add5c8a4a149ed8051f75aa539f8eec919c737" translate="yes" xml:space="preserve">
          <source>Takes a packed socket address (as returned by pack_sockaddr_in(), pack_sockaddr_un() or the perl builtin functions getsockname() and getpeername()). Returns the address family tag. This will be one of the &lt;code&gt;AF_*&lt;/code&gt; constants, such as &lt;code&gt;AF_INET&lt;/code&gt; for a &lt;code&gt;sockaddr_in&lt;/code&gt; addresses or &lt;code&gt;AF_UNIX&lt;/code&gt; for a &lt;code&gt;sockaddr_un&lt;/code&gt;. It can be used to figure out what unpack to use for a sockaddr of unknown type.</source>
          <target state="translated">接受一个压缩的套接字地址（由pack_sockaddr_in（），pack_sockaddr_un（）或perl内置函数getockname（）和getpeername（）返回）。返回地址族标签。这将是 &lt;code&gt;AF_*&lt;/code&gt; 常量之一，例如 &lt;code&gt;AF_INET&lt;/code&gt; 代表 &lt;code&gt;sockaddr_in&lt;/code&gt; 地址， &lt;code&gt;AF_UNIX&lt;/code&gt; 代表 &lt;code&gt;sockaddr_un&lt;/code&gt; 。它可以用来找出对未知类型的sockaddr使用什么解压缩。</target>
        </trans-unit>
        <trans-unit id="ace3db72b47fd10c721426b5e390e2e0c6f992fc" translate="yes" xml:space="preserve">
          <source>Takes a partition type and returns whether that partition is a &quot;container&quot; partition that is supported under Win32, that is, whether it is an &quot;extended&quot; partition that can contain &quot;logical&quot; partitions. &lt;code&gt;$ivPartitonType&lt;/code&gt; is as for &lt;code&gt;IsRecognizedPartition&lt;/code&gt;.</source>
          <target state="translated">获取分区类型，并返回该分区是否是Win32支持的&amp;ldquo;容器&amp;rdquo;分区，即它是否是可以包含&amp;ldquo;逻辑&amp;rdquo;分区的&amp;ldquo;扩展&amp;rdquo;分区。 &lt;code&gt;$ivPartitonType&lt;/code&gt; 与 &lt;code&gt;IsRecognizedPartition&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="1d61f271c3866d065bf72b7810d6f1c5dfb4bf3f" translate="yes" xml:space="preserve">
          <source>Takes a partition type and returns whether that partition type is supported under Win32. &lt;code&gt;$ivPartitonType&lt;/code&gt; is an integer value as from the operating system byte of a hard disk's DOS-compatible partition table [that is, a partition table for x86-based Win32, not, for example, one used with Windows NT for Alpha processors]. For example, the &lt;code&gt;PartitionType&lt;/code&gt; member of the &lt;code&gt;PARTITION_INFORMATION&lt;/code&gt; structure.</source>
          <target state="translated">获取分区类型，并返回Win32是否支持该分区类型。 &lt;code&gt;$ivPartitonType&lt;/code&gt; 是从硬盘的DOS兼容分区表（即，基于x86的Win32的分区表，而不是与Windows NT一起用于Alpha处理器的分区表）的操作系统字节开始的整数值。例如， &lt;code&gt;PARTITION_INFORMATION&lt;/code&gt; 结构的 &lt;code&gt;PartitionType&lt;/code&gt; 成员。</target>
        </trans-unit>
        <trans-unit id="88fe4b00a1515bab6009cc465d438231923fa5fb" translate="yes" xml:space="preserve">
          <source>Takes a path string and returns an unsigned value with attribute flags. If it fails, it returns INVALID_FILE_ATTRIBUTES, otherwise it can be one or more of the following values:</source>
          <target state="translated">获取一个路径字符串,并返回一个带有属性标志的无符号值,如果失败,则返回INVALID_FILE_ATTRIBUTES。如果失败,则返回INVALID_FILE_ATTRIBUTES,否则可以是下面的一个或多个值。</target>
        </trans-unit>
        <trans-unit id="a13e8e801bfdc18ca93880299add6c6b51640d38" translate="yes" xml:space="preserve">
          <source>Takes a path to a file or dir and returns an empty string if we don't want to include this file in the library. Otherwise it returns the the $path unchanged.</source>
          <target state="translated">取一个文件或目录的路径,如果我们不想将这个文件包含在库中,则返回一个空字符串。否则,它将返回$path,保持不变。</target>
        </trans-unit>
        <trans-unit id="5857a3f9b8ca80529d602d68d365fa9061a89d78" translate="yes" xml:space="preserve">
          <source>Takes a perl version as an argument. Returns that perl version if it exists or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">以perl版本作为参数。返回该perl版本（如果存在），否则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d9afb26d884d8b2dac4569e9ebf9cb1409e2dee" translate="yes" xml:space="preserve">
          <source>Takes a perl version as an argument. Upon successful completion, returns a reference to a hash. Each element of that hash has a key which is the name of a module (</source>
          <target state="translated">取一个perl版本作为参数。成功完成后,返回一个哈希的引用。该哈希的每个元素都有一个键,这个键是一个模块的名称 (</target>
        </trans-unit>
        <trans-unit id="40ef5af0a7a23fbe908b8c6d6bfe7afebb158b73" translate="yes" xml:space="preserve">
          <source>Takes a quoted regular expression produced by &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, or a string representing a regular expression.</source>
          <target state="translated">接受由 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 产生的带引号的正则表达式，或代表正则表达式的字符串。</target>
        </trans-unit>
        <trans-unit id="1da3bec748134b01442fc634b8967f8ffc71be4b" translate="yes" xml:space="preserve">
          <source>Takes a quoted regular expression produced by &lt;code&gt;qr//&lt;/code&gt;, or a string representing a regular expression.</source>
          <target state="translated">接受由 &lt;code&gt;qr//&lt;/code&gt; 产生的带引号的正则表达式，或代表正则表达式的字符串。</target>
        </trans-unit>
        <trans-unit id="9f021fc102096073a09c0f85c8e63b62bb7905ee" translate="yes" xml:space="preserve">
          <source>Takes a reference to any Perl value, and turns the referred-to value into an object in the appropriate B::OP-derived or B::SV-derived class. Apart from functions such as &lt;code&gt;main_root&lt;/code&gt; , this is the primary way to get an initial &quot;handle&quot; on an internal perl data structure which can then be followed with the other access methods.</source>
          <target state="translated">引用任何Perl值，并将引用的值转换为相应的B :: OP派生或B :: SV派生类中的对象。除了诸如 &lt;code&gt;main_root&lt;/code&gt; 之类的函数外，这是在内部perl数据结构上获取初始&amp;ldquo;句柄&amp;rdquo;的主要方法，然后可以使用其他访问方法。</target>
        </trans-unit>
        <trans-unit id="e9bcf1191796c7d482572c3d5fd8f112b75e9de7" translate="yes" xml:space="preserve">
          <source>Takes a reference to any Perl value, and turns the referred-to value into an object in the appropriate B::OP-derived or B::SV-derived class. Apart from functions such as &lt;code&gt;main_root&lt;/code&gt;, this is the primary way to get an initial &quot;handle&quot; on an internal perl data structure which can then be followed with the other access methods.</source>
          <target state="translated">引用任何Perl值，并将引用的值转换为相应的B :: OP派生或B :: SV派生类中的对象。除了诸如 &lt;code&gt;main_root&lt;/code&gt; 之类的函数外，这是在内部perl数据结构上获取初始&amp;ldquo;句柄&amp;rdquo;的主要方法，然后可以使用其他访问方法。</target>
        </trans-unit>
        <trans-unit id="e41f495e23e8b7129fbf9bc3a9bb6ededd8628d3" translate="yes" xml:space="preserve">
          <source>Takes a regex as an argument, returns a list of modules that match the regex given. If only a regex is provided applies to all modules in all perl versions. Optionally you may provide a list of perl versions to limit the regex search.</source>
          <target state="translated">以一个regex作为参数,返回一个与给定的regex匹配的模块列表。如果只提供一个regex,则适用于所有perl版本的所有模块。你也可以提供一个perl版本的列表来限制regex的搜索。</target>
        </trans-unit>
        <trans-unit id="4409b17c674e2781e58d19f638d2dce9b604b410" translate="yes" xml:space="preserve">
          <source>Takes a sprintf-style format pattern and conventional (non-SV) arguments and returns the formatted string.</source>
          <target state="translated">取一个sprintf风格的格式模式和常规(非SV)参数,并返回格式化的字符串。</target>
        </trans-unit>
        <trans-unit id="33c7557687a090fd43bd56b07499b14fc80993e2" translate="yes" xml:space="preserve">
          <source>Takes a string giving the name of a host, or a textual representation of an IP address and translates that to an packed binary address structure suitable to pass to pack_sockaddr_in(). If passed a hostname that cannot be resolved, returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. For multi-homed hosts (hosts with more than one address), the first address found is returned.</source>
          <target state="translated">接受一个字符串，该字符串给出主机名或IP地址的文本表示形式，并将其转换为适合传递给pack_sockaddr_in（）的压缩二进制地址结构。如果传递了无法解析的主机名，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。对于多宿主主机（具有多个地址的主机），将返回找到的第一个地址。</target>
        </trans-unit>
        <trans-unit id="a5e03d93715b3e17db35edf143d3a334a6aaebce" translate="yes" xml:space="preserve">
          <source>Takes a string giving the name of a host, or a textual representation of an IP address and translates that to an packed binary address structure suitable to pass to pack_sockaddr_in(). If passed a hostname that cannot be resolved, returns &lt;code&gt;undef&lt;/code&gt;. For multi-homed hosts (hosts with more than one address), the first address found is returned.</source>
          <target state="translated">接受一个提供主机名或IP地址文本表示的字符串，并将其转换为适合传递给pack_sockaddr_in（）的压缩二进制地址结构。如果传递了无法解析的主机名，则返回 &lt;code&gt;undef&lt;/code&gt; 。对于多宿主主机（具有多个地址的主机），将返回找到的第一个地址。</target>
        </trans-unit>
        <trans-unit id="223ad84fa206d265b475ea00fd86ad6d14a4bf08" translate="yes" xml:space="preserve">
          <source>Takes a string giving the path to the root directory of a file system [called a &quot;drive&quot; because every file system is assigned a &quot;drive letter&quot;] and returns an unsigned value indicating the type of drive the file system is on. The return value should be one of:</source>
          <target state="translated">取一个字符串,给出文件系统根目录的路径[称为 &quot;drive&quot;,因为每个文件系统都被分配了一个 &quot;drive letter&quot;],并返回一个无符号值,表示文件系统所在的驱动器类型。返回的值应该是下列之一:</target>
        </trans-unit>
        <trans-unit id="1f86839b95b2c7ce0cd8df0fd7189ee9fa362403" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing a whitespace-separated list of values. The values &quot;all&quot; and &quot;none&quot; are special, again. It's also permissible to pass an array reference here.</source>
          <target state="translated">取一个字符串,可能包含一个用空格分隔的值列表。同样,&quot;all &quot;和 &quot;none &quot;是特殊值。这里也允许传递一个数组引用。</target>
        </trans-unit>
        <trans-unit id="4925dcea23e5ae74b5fce407317c9fa3709b6b25" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing a whitespace-separated list of values. The values &quot;all&quot; and &quot;none&quot; are special. It's also permissible to pass an array reference here.</source>
          <target state="translated">取一个字符串,可能包含一个用空格分隔的值列表。&quot;all &quot;和 &quot;none &quot;是特殊值。这里也允许传递一个数组引用。</target>
        </trans-unit>
        <trans-unit id="90662514b3c1c8b5cad150f77c448383f9911cee" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing several values separated by whitespace. The special values &quot;all&quot; and &quot;none&quot; mean what you'd expect.</source>
          <target state="translated">取一个字符串,可能包含几个用空格分隔的值。特殊值 &quot;all &quot;和 &quot;none &quot;的意思是你所期望的。</target>
        </trans-unit>
        <trans-unit id="8b8cbc4c6f861e88e0cc4c3970f3d7711c8f40ee" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ip_mreq&lt;/code&gt; structure. Returns a list of two elements; the IPv4 multicast address and interface address.</source>
          <target state="translated">采用 &lt;code&gt;ip_mreq&lt;/code&gt; 结构。返回两个元素的列表；IPv4组播地址和接口地址。</target>
        </trans-unit>
        <trans-unit id="04696d2255aec363ebf123f1adcef127402d7fca" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ip_mreq_source&lt;/code&gt; structure. Returns a list of three elements; the IPv4 multicast address, source address and interface address.</source>
          <target state="translated">采用 &lt;code&gt;ip_mreq_source&lt;/code&gt; 结构。返回三个元素的列表；IPv4组播地址，源地址和接口地址。</target>
        </trans-unit>
        <trans-unit id="8895fb55870fc5cb5b67d2b6b1ab10511fd087e6" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ipv6_mreq&lt;/code&gt; structure. Returns a list of two elements; the IPv6 address and an interface number.</source>
          <target state="translated">采用 &lt;code&gt;ipv6_mreq&lt;/code&gt; 结构。返回两个元素的列表；IPv6地址和接口号。</target>
        </trans-unit>
        <trans-unit id="ad12a7e2dccc21686af63739f893c4d2a53e4c04" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt; ). Returns the &lt;code&gt;ip_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">接受一个I​​Pv4组播地址和一个可选的接口地址（或 &lt;code&gt;INADDR_ANY&lt;/code&gt; ）。返回带有这些参数的 &lt;code&gt;ip_mreq&lt;/code&gt; 结构。适用于 &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; 和 &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; sockopts。</target>
        </trans-unit>
        <trans-unit id="daef79d0571cfe13a97a3c30841461dc9af70aa5" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt;). Returns the &lt;code&gt;ip_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">接受一个I​​Pv4组播地址，以及一个可选的接口地址（或 &lt;code&gt;INADDR_ANY&lt;/code&gt; ）。返回带有这些参数的 &lt;code&gt;ip_mreq&lt;/code&gt; 结构。适用于 &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; 和 &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; sockopts。</target>
        </trans-unit>
        <trans-unit id="e80cd3ce1fd8acb10289fb4bd58c0849f55a8d71" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address, source address, and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt; ). Returns the &lt;code&gt;ip_mreq_source&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">接受一个I​​Pv4组播地址，源地址，以及一个可选的接口地址（或 &lt;code&gt;INADDR_ANY&lt;/code&gt; ）。返回带有这些参数的 &lt;code&gt;ip_mreq_source&lt;/code&gt; 结构。适用于 &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; 和 &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts。</target>
        </trans-unit>
        <trans-unit id="0e03de7d098eab496f44ea7920e441314209dd86" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address, source address, and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt;). Returns the &lt;code&gt;ip_mreq_source&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">接受一个I​​Pv4组播地址，源地址，以及一个可选的接口地址（或 &lt;code&gt;INADDR_ANY&lt;/code&gt; ）。返回带有这些参数的 &lt;code&gt;ip_mreq_source&lt;/code&gt; 结构。适合与 &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; 和 &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts一起使用。</target>
        </trans-unit>
        <trans-unit id="414f4fb4a3a1f32b47a120675c30046be162adca" translate="yes" xml:space="preserve">
          <source>Takes an IPv6 multicast address and an interface number. Returns the &lt;code&gt;ipv6_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IPV6_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IPV6_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">获取IPv6组播地址和接口号。返回带有那些参数的 &lt;code&gt;ipv6_mreq&lt;/code&gt; 结构。适用于 &lt;code&gt;IPV6_ADD_MEMBERSHIP&lt;/code&gt; 和 &lt;code&gt;IPV6_DROP_MEMBERSHIP&lt;/code&gt; sockopts。</target>
        </trans-unit>
        <trans-unit id="84da4affe0802d1076fb7e8fa5b5ab6e38634ce8" translate="yes" xml:space="preserve">
          <source>Takes an address family (such as &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;AF_INET6&lt;/code&gt; ) and a string containing a textual representation of an address in that family and translates that to an packed binary address structure.</source>
          <target state="translated">接受一个地址族（例如 &lt;code&gt;AF_INET&lt;/code&gt; 或 &lt;code&gt;AF_INET6&lt;/code&gt; ）和一个包含该族中地址的文本表示形式的字符串，并将其转换为压缩的二进制地址结构。</target>
        </trans-unit>
        <trans-unit id="7c090993da78e7530e8d560d6312459708f8366d" translate="yes" xml:space="preserve">
          <source>Takes an address family (such as &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;AF_INET6&lt;/code&gt;) and a string containing a textual representation of an address in that family and translates that to an packed binary address structure.</source>
          <target state="translated">接受地址族（例如 &lt;code&gt;AF_INET&lt;/code&gt; 或 &lt;code&gt;AF_INET6&lt;/code&gt; ）和一个包含该族中地址的文本表示形式的字符串，并将其转换为压缩的二进制地址结构。</target>
        </trans-unit>
        <trans-unit id="185fc4d2aaf4353f2b2708aa34a24508e0a971cd" translate="yes" xml:space="preserve">
          <source>Takes an address family and a packed binary address structure and translates it into a human-readable textual representation of the address; typically in &lt;code&gt;d.d.d.d&lt;/code&gt; form for &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; form for &lt;code&gt;AF_INET6&lt;/code&gt; .</source>
          <target state="translated">采用地址族和压缩的二进制地址结构，并将其转换为地址的人类可读文本表示形式；通常 &lt;code&gt;d.d.d.d&lt;/code&gt; 形式 &lt;code&gt;AF_INET&lt;/code&gt; 或 &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; 的形式 &lt;code&gt;AF_INET6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67141b039613b21f893d0875c6a0c29a2e6abaca" translate="yes" xml:space="preserve">
          <source>Takes an address family and a packed binary address structure and translates it into a human-readable textual representation of the address; typically in &lt;code&gt;d.d.d.d&lt;/code&gt; form for &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; form for &lt;code&gt;AF_INET6&lt;/code&gt;.</source>
          <target state="translated">采用地址族和压缩的二进制地址结构，并将其转换为地址的人类可读文本表示形式；通常 &lt;code&gt;d.d.d.d&lt;/code&gt; 形式 &lt;code&gt;AF_INET&lt;/code&gt; 或 &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; 的形式 &lt;code&gt;AF_INET6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e77ed8250b0ab9eed8ffd2c4c006ad06b6129f6" translate="yes" xml:space="preserve">
          <source>Takes an array of items and turns them into a well-formatted list of arguments. In most cases this is simply something like:</source>
          <target state="translated">将一个项目数组转化为一个格式良好的参数列表。在大多数情况下,这只是一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="21d2a6e85e05ac293f43bf0aadd4c7b6d2f0e70c" translate="yes" xml:space="preserve">
          <source>Takes as argument a path and returns true if it is an absolute path.</source>
          <target state="translated">将一个路径作为参数,如果是绝对路径则返回true。</target>
        </trans-unit>
        <trans-unit id="6dc3e333ed2be58598d7c496ec3d73ebab444c2b" translate="yes" xml:space="preserve">
          <source>Takes as argument a path and returns true, if it is an absolute path. If the path has a leading &quot;:&quot;, it's a relative path. Otherwise, it's an absolute path, unless the path doesn't contain any colons, i.e. it's a name like &quot;a&quot;. In this particular case, the path is considered to be relative (i.e. it is considered to be a filename). Use &quot;:&quot; in the appropriate place in the path if you want to distinguish unambiguously. As a special case, the filename '' is always considered to be absolute. Note that with version 1.2 of File::Spec::Mac, this does no longer consult the local filesystem.</source>
          <target state="translated">取一个路径作为参数,如果是绝对路径,则返回true。如果路径前面有&quot;:&quot;,则是相对路径。否则,就是绝对路径,除非路径中不包含任何冒号,也就是像 &quot;a &quot;这样的名字。在这种特殊情况下,路径被认为是相对的(即它被认为是一个文件名)。如果你想毫不含糊地区分,请在路径的适当位置使用&quot;:&quot;。作为一种特殊情况,文件名''总是被认为是绝对的。请注意,在 File::Spec::Mac 的 1.2 版本中,它不再咨询本地文件系统。</target>
        </trans-unit>
        <trans-unit id="f927c21bb3e3c4ff729f953eef64006ef1f031a9" translate="yes" xml:space="preserve">
          <source>Takes as arguments a directory name and a regular expression. Returns all entries in the directory that match the regular expression.</source>
          <target state="translated">以一个目录名和一个正则表达式作为参数。返回目录中所有符合正则表达式的条目。</target>
        </trans-unit>
        <trans-unit id="6047190e6cf9ba865c7d15a28d5823f107249805" translate="yes" xml:space="preserve">
          <source>Takes as its argument a path, and returns true if it is an absolute path.</source>
          <target state="translated">将一个路径作为参数,如果是绝对路径则返回true。</target>
        </trans-unit>
        <trans-unit id="ff1dec49488d5f7d1892eedad0ad929bfc6263b5" translate="yes" xml:space="preserve">
          <source>Takes named parameters: If &lt;code&gt;shallow&lt;/code&gt; is true, the clone will share the actual individual type/input/outputmap objects, but not share their storage. Use with caution. Without &lt;code&gt;shallow&lt;/code&gt;, the clone will be fully independent.</source>
          <target state="translated">采用命名参数：如果 &lt;code&gt;shallow&lt;/code&gt; 为true，则克隆将共享实际的单个类型/输入/输出映射对象，但不共享其存储。请谨慎使用。没有 &lt;code&gt;shallow&lt;/code&gt; ，克隆将完全独立。</target>
        </trans-unit>
        <trans-unit id="29d3a8d482e59f44bd119209a124f4322f931d36" translate="yes" xml:space="preserve">
          <source>Takes no argument, returns the environment variable PATH as an array.</source>
          <target state="translated">不取参数,以数组形式返回环境变量PATH。</target>
        </trans-unit>
        <trans-unit id="fabbbd7a986855e1324a147a7f7a2a0ae979a9a1" translate="yes" xml:space="preserve">
          <source>Takes no argument. Returns the environment variable &lt;code&gt;PATH&lt;/code&gt; (or the local platform's equivalent) as a list.</source>
          <target state="translated">不用争论。以列表形式返回环境变量 &lt;code&gt;PATH&lt;/code&gt; （或本地平台的等效变量）。</target>
        </trans-unit>
        <trans-unit id="904758c12da1c3cf57f2a62e3976ec89f757603e" translate="yes" xml:space="preserve">
          <source>Takes one argument ( 'stdin' | 'stdout' | 'stderr' ) and returns true if the IoIFP of the object is equal to the handle whose name was passed as argument; i.e., $io-&amp;gt;IsSTD('stderr') is true if IoIFP($io) == PerlIO_stderr().</source>
          <target state="translated">接受一个参数（'stdin'|'stdout'|'stderr'），如果对象的IoIFP等于其名称作为参数传递的句柄，则返回true；否则，返回true。即，如果IoIFP（$ io）== PerlIO_stderr（），则$ io-&amp;gt; IsSTD（'stderr'）为true。</target>
        </trans-unit>
        <trans-unit id="2250c086cb14652296208baa0752736a068d5cdd" translate="yes" xml:space="preserve">
          <source>Takes one argument, a file name, and returns the file name, if the argument is likely to be a perl script. On MM_Unix this is true for any ordinary, readable file.</source>
          <target state="translated">取一个参数,即文件名,如果参数可能是一个perl脚本,则返回文件名。在MM_Unix上,这对任何普通的可读文件都是正确的。</target>
        </trans-unit>
        <trans-unit id="b67ed86e7a795bece24f2642cf574b99635c4b90" translate="yes" xml:space="preserve">
          <source>Takes one argument, a pathname. Returns the &lt;code&gt;sockaddr_un&lt;/code&gt; structure with that path packed in with &lt;code&gt;AF_UNIX&lt;/code&gt; filled in. For &lt;code&gt;PF_UNIX&lt;/code&gt; sockets, this structure is normally what you need for the arguments in bind(), connect(), and send().</source>
          <target state="translated">接受一个参数，即路径名。返回 &lt;code&gt;sockaddr_un&lt;/code&gt; 结构，其中的路径用 &lt;code&gt;AF_UNIX&lt;/code&gt; 填充。对于 &lt;code&gt;PF_UNIX&lt;/code&gt; 套接字，此结构通常是bind（），connect（）和send（）中的参数所需要的。</target>
        </trans-unit>
        <trans-unit id="5460ec5112334feb4ac9398f4b8e6e656f42cd55" translate="yes" xml:space="preserve">
          <source>Takes one argument: &lt;code&gt;$type&lt;/code&gt; . Returns the class for this $type, or &lt;code&gt;croak&lt;/code&gt; s with an error.</source>
          <target state="translated">接受一个参数： &lt;code&gt;$type&lt;/code&gt; 。返回此$ type的类，或者返回 &lt;code&gt;croak&lt;/code&gt; ,并显示错误。</target>
        </trans-unit>
        <trans-unit id="f924ea1eb572a2d6d41c219191b1f7ad36177be9" translate="yes" xml:space="preserve">
          <source>Takes one argument: &lt;code&gt;$type&lt;/code&gt;. Returns the class for this $type, or &lt;code&gt;croak&lt;/code&gt;s with an error.</source>
          <target state="translated">接受一个参数： &lt;code&gt;$type&lt;/code&gt; 。返回此$ type的类，或者返回 &lt;code&gt;croak&lt;/code&gt; ,并显示错误。</target>
        </trans-unit>
        <trans-unit id="16af72bfdf1441df18765f4029d283a1f7f95693" translate="yes" xml:space="preserve">
          <source>Takes the name of a package, which may be a nested package, in the form 'Foo/Bar.pm' and replaces the slash with &lt;code&gt;::&lt;/code&gt; or something else safe for a man page file name. Returns the replacement.</source>
          <target state="translated">以'Foo / Bar.pm'的形式获取包的名称（可能是嵌套的包），并将斜杠替换为 &lt;code&gt;::&lt;/code&gt; 或其他安全的手册页文件名。返回替换。</target>
        </trans-unit>
        <trans-unit id="778216c494c51654f317b1afb524185f02d3ff50" translate="yes" xml:space="preserve">
          <source>Takes the necessary steps (cache invalidations, mostly) when the &lt;code&gt;@ISA&lt;/code&gt; of the given package has changed. Invoked by the &lt;code&gt;setisa&lt;/code&gt; magic, should not need to invoke directly.</source>
          <target state="translated">当给定程序包的 &lt;code&gt;@ISA&lt;/code&gt; 更改时，采取必要的步骤（主要是缓存无效）。由 &lt;code&gt;setisa&lt;/code&gt; 魔术调用，不需要直接调用。</target>
        </trans-unit>
        <trans-unit id="ff0d6765017f7f35ad28bb62529040cd32d236cb" translate="yes" xml:space="preserve">
          <source>Takes the necessary steps (cache invalidations, mostly) when the @ISA of the given package has changed. Invoked by the &lt;code&gt;setisa&lt;/code&gt; magic, should not need to invoke directly.</source>
          <target state="translated">当给定程序包的@ISA更改时，采取必要的步骤（主要是缓存无效）。由 &lt;code&gt;setisa&lt;/code&gt; 魔术调用，不需要直接调用。</target>
        </trans-unit>
        <trans-unit id="1b306490f4adab44f2505affe31e89e35e98c934" translate="yes" xml:space="preserve">
          <source>Takes the object file as an argument, and returns the portion of compile command-line that will output to the specified object file.</source>
          <target state="translated">以对象文件为参数,返回编译命令行中输出到指定对象文件的部分。</target>
        </trans-unit>
        <trans-unit id="98237f7a990bc1f6af918e56a3b7b9f24407d459" translate="yes" xml:space="preserve">
          <source>Takes two arguments, a port number and an opaque string (as returned by inet_aton(), or a v-string). Returns the &lt;code&gt;sockaddr_in&lt;/code&gt; structure with those arguments packed in and &lt;code&gt;AF_INET&lt;/code&gt; filled in. For Internet domain sockets, this structure is normally what you need for the arguments in bind(), connect(), and send().</source>
          <target state="translated">接受两个参数，一个端口号和一个不透明的字符串（由inet_aton（）返回或v字符串）。返回 &lt;code&gt;sockaddr_in&lt;/code&gt; 结构，其中填充了这些参数，并填充了 &lt;code&gt;AF_INET&lt;/code&gt; 。对于Internet域套接字，此结构通常是bind（），connect（）和send（）中的参数所需要的。</target>
        </trans-unit>
        <trans-unit id="b14fed1e8f7026c1b53ef7c0d55d1e273446b0ea" translate="yes" xml:space="preserve">
          <source>Takes two arguments: &lt;code&gt;$type&lt;/code&gt; , &lt;code&gt;$class&lt;/code&gt;</source>
          <target state="translated">接受两个参数： &lt;code&gt;$type&lt;/code&gt; ， &lt;code&gt;$class&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55ed19e4eb2d24e5b863b8b237b5077e73ee7f56" translate="yes" xml:space="preserve">
          <source>Takes two arguments: &lt;code&gt;$type&lt;/code&gt;, &lt;code&gt;$class&lt;/code&gt;</source>
          <target state="translated">接受两个参数： &lt;code&gt;$type&lt;/code&gt; ， &lt;code&gt;$class&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a9f99285830e8621999fc816f54c6c6183fd552" translate="yes" xml:space="preserve">
          <source>Takes two to four arguments, a port number, an opaque string (as returned by inet_pton()), optionally a scope ID number, and optionally a flow label number. Returns the &lt;code&gt;sockaddr_in6&lt;/code&gt; structure with those arguments packed in and &lt;code&gt;AF_INET6&lt;/code&gt; filled in. IPv6 equivalent of pack_sockaddr_in().</source>
          <target state="translated">带两个到四个参数，一个端口号，一个不透明的字符串（由inet_pton（）返回），一个可选的作用域ID号和一个可选的流标签号。返回带有那些参数并填充了 &lt;code&gt;AF_INET6&lt;/code&gt; 的 &lt;code&gt;sockaddr_in6&lt;/code&gt; 结构。IPv6等效于pack_sockaddr_in（）。</target>
        </trans-unit>
        <trans-unit id="6768416e6b2dea0b5b355ce619b2d42c6c2f27cf" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. On Mac OS, $volume, $directory and $file are concatenated. A ':' is inserted if need be. You may pass an empty string for each portion. If all portions are empty, the empty string is returned. If $volume is empty, the result will be a relative path, beginning with a ':'. If $volume and $directory are empty, a leading &quot;:&quot; (if any) is removed form $file and the remainder is returned. If $file is empty, the resulting path will have a trailing ':'.</source>
          <target state="translated">取体积、目录和文件的一部分并返回整个路径。在 Mac OS 上,$volume、$directory 和 $file 是连在一起的。如果需要的话,会插入一个':'。你可以为每个部分传递一个空字符串。如果所有部分都是空的,则返回空字符串。如果$volume为空,结果将是一个相对路径,以':'开头。如果$volume和$directory是空的,$file中的前导符&quot;:&quot;(如果有的话)会被删除,剩余部分会被返回。如果$file为空,结果将是一个以':'开头的相对路径。</target>
        </trans-unit>
        <trans-unit id="03fb347623243a59c8c7215b498a631b05381519" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, $volume is ignored, and directory and file are concatenated. A '/' is inserted if needed (though if the directory portion doesn't start with '/' it is not added). On other OSs, $volume is significant.</source>
          <target state="translated">取卷、目录和文件的一部分并返回整个路径。在Unix下,$volume被忽略,目录和文件被连在一起。如果需要的话,会插入'/'(但如果目录部分不是以'/'开头,则不会添加)。在其他操作系统上,$volume是重要的。</target>
        </trans-unit>
        <trans-unit id="9945bfbc052c2b04dca187c3550c5f1feee8878d" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, $volume is ignored, and this is just like catfile(). On other OSs, the $volume become significant.</source>
          <target state="translated">取卷、目录和文件的一部分并返回整个路径。在Unix下,$volume被忽略,这就像catfile()一样。在其他操作系统上,$volume变得很重要。</target>
        </trans-unit>
        <trans-unit id="972a64a368ed52f92018a4453bba5f6c8e73cecd" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, &lt;code&gt;$volume&lt;/code&gt; is ignored, and directory and file are concatenated. A '/' is inserted if need be. On other OSes, &lt;code&gt;$volume&lt;/code&gt; is significant.</source>
          <target state="translated">获取卷，目录和文件部分，并返回完整路径。在Unix下， &lt;code&gt;$volume&lt;/code&gt; 被忽略，目录和文件被串联。如果需要，将插入&amp;ldquo; /&amp;rdquo;。在其他操作系统上， &lt;code&gt;$volume&lt;/code&gt; 很重要。</target>
        </trans-unit>
        <trans-unit id="510dd54f6700e32b2e33a7ae6bf0b69436048e78" translate="yes" xml:space="preserve">
          <source>Taking a pattern, usually a &lt;b&gt;regular expression&lt;/b&gt;, and trying the pattern various ways on a string to see whether there&amp;rsquo;s any way to make it fit. Often used to pick interesting tidbits out of a file.</source>
          <target state="translated">采取一个模式，通常是一个&lt;b&gt;正则表达式&lt;/b&gt;，然后对字符串进行各种方式的尝试，以查看是否有任何合适的方式。通常用于从文件中挑选有趣的花絮。</target>
        </trans-unit>
        <trans-unit id="71bab857be3a2f057d5a14d3b22be3dc59b9b4df" translate="yes" xml:space="preserve">
          <source>Taking a reference to an enumerated list is not the same as using square brackets--instead it's the same as creating a list of references!</source>
          <target state="translated">对一个枚举列表的引用与使用方括号是不一样的--相反,它与创建一个引用列表是一样的。</target>
        </trans-unit>
        <trans-unit id="15f9cd429dc93becd860c5d004ae9bccaf0f7bef" translate="yes" xml:space="preserve">
          <source>Taking references to the elements of shared arrays and hashes does not autovivify the elements, and neither does slicing a shared array/hash over non-existent indices/keys autovivify the elements.</source>
          <target state="translated">对共享数组和哈希的元素进行引用并不会自动激活元素,在不存在的索引/键上对共享数组/哈希进行分片也不会自动激活元素。</target>
        </trans-unit>
        <trans-unit id="4c38f4d8d122fb1493ff34d8747e9c4346d4b600" translate="yes" xml:space="preserve">
          <source>Tanenbaum, Andrew S. Distributed Operating Systems. Prentice Hall, 1995, ISBN 0-13-219908-4 (great textbook).</source>
          <target state="translated">Tanenbaum,Andrew S.Distributed Operating Systems.Prentice Hall,1995,ISBN 0-13-219908-4(伟大的教科书)。</target>
        </trans-unit>
        <trans-unit id="1dc610a84e3953106d973aac027936828f4fd583" translate="yes" xml:space="preserve">
          <source>TangutSources.txt</source>
          <target state="translated">TangutSources.txt</target>
        </trans-unit>
        <trans-unit id="2c7e55c8c22c8578371b576097055d97d0b00faf" translate="yes" xml:space="preserve">
          <source>Tar</source>
          <target state="translated">Tar</target>
        </trans-unit>
        <trans-unit id="6fa1266b6a5ee03e688676077ed07cbe3831ca7d" translate="yes" xml:space="preserve">
          <source>Tar command verbosity level (none or v or vv)?</source>
          <target state="translated">焦油命令动词级别(无或v或vv)?</target>
        </trans-unit>
        <trans-unit id="ad911c00bd7a291ef3efa483132270f4863e5d78" translate="yes" xml:space="preserve">
          <source>Tar magic string -- not useful for most users</source>
          <target state="translated">焦油魔绳 ----对大多数用户无用</target>
        </trans-unit>
        <trans-unit id="6c049aa004ef5f9f848604b292466698be913578" translate="yes" xml:space="preserve">
          <source>Tar version string -- not useful for most users</source>
          <target state="translated">焦油版本字符串--对大多数用户没有用处</target>
        </trans-unit>
        <trans-unit id="61ad50a9b9189cc3cf1874568e35e7901ff4c982" translate="yes" xml:space="preserve">
          <source>Target</source>
          <target state="translated">Target</target>
        </trans-unit>
        <trans-unit id="1826e633e69fd1415d51f9f2a918eb7307883a23" translate="yes" xml:space="preserve">
          <source>Target &lt;code&gt;dist&lt;/code&gt; prepares distribution file set. Target &lt;code&gt;zipdist&lt;/code&gt; performs same as &lt;code&gt;dist&lt;/code&gt; but additionally compresses distribution files into zip archive.</source>
          <target state="translated">目标 &lt;code&gt;dist&lt;/code&gt; 准备分发文件集。目标 &lt;code&gt;zipdist&lt;/code&gt; 的性能与 &lt;code&gt;dist&lt;/code&gt; 相同，但还会将分发文件压缩到zip存档中。</target>
        </trans-unit>
        <trans-unit id="3775eca859de6dcfb4c426728c102c801b4a309a" translate="yes" xml:space="preserve">
          <source>Target of goto is too deeply nested</source>
          <target state="translated">goto的目标嵌套太深</target>
        </trans-unit>
        <trans-unit id="d35260a00f655f27edcc35a7eb16da44a4f671a6" translate="yes" xml:space="preserve">
          <source>Targets</source>
          <target state="translated">Targets</target>
        </trans-unit>
        <trans-unit id="cb47f8fe09a055e30fa78d0ffd45295628f69b2c" translate="yes" xml:space="preserve">
          <source>Task-Oriented</source>
          <target state="translated">Task-Oriented</target>
        </trans-unit>
        <trans-unit id="a84eec2edc9ad24f299c8e16c921ff89b0a72d34" translate="yes" xml:space="preserve">
          <source>Tatsuhiko Miyagawa &amp;lt;miyagawa@bulknews.net&amp;gt;</source>
          <target state="translated">宫川达彦&amp;lt;miyagawa@bulknews.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="184d6c1f032beb495ac0920ba867a330761f1d3a" translate="yes" xml:space="preserve">
          <source>Tautologous boolean operators are still going to be optimized away. Don't be tempted to write</source>
          <target state="translated">同义布尔运算符还是要优化掉。不要被诱惑去写</target>
        </trans-unit>
        <trans-unit id="b7381d80f99d092ee04058e78cf491f1a66d6d65" translate="yes" xml:space="preserve">
          <source>Technical note</source>
          <target state="translated">技术说明</target>
        </trans-unit>
        <trans-unit id="3954704c666cb5b3d49966b92f96bca0955f9f5c" translate="yes" xml:space="preserve">
          <source>Technically speaking casting between function pointers and data pointers is unportable and undefined, but practically speaking it seems to work, but you should use the FPTR2DPTR() and DPTR2FPTR() macros. Sometimes you can also play games with unions.</source>
          <target state="translated">从技术上讲,函数指针和数据指针之间的转换是不可移植的,也是未定义的,但实际上,它似乎是可行的,但你应该使用FPTR2DPTR()和DPTR2FPTR()宏。有时你也可以用联合体来玩游戏。</target>
        </trans-unit>
        <trans-unit id="789a9f1903bc34d24a4cbcecb6e7df34821ef6e1" translate="yes" xml:space="preserve">
          <source>Technically speaking, any extra semantics attached to a variable such as &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;%ENV&lt;/code&gt; , or &lt;code&gt;%SIG&lt;/code&gt; , or to any tied variable. Magical things happen when you diddle those variables.</source>
          <target state="translated">从技术上讲，任何附加到变量（例如 &lt;code&gt;$!&lt;/code&gt; )的语义都包括在内！， &lt;code&gt;$0&lt;/code&gt; ， &lt;code&gt;%ENV&lt;/code&gt; 或 &lt;code&gt;%SIG&lt;/code&gt; 或任何绑定变量。欺骗这些变量会发生神奇的事情。</target>
        </trans-unit>
        <trans-unit id="37c0cdada9acbef172bbad2abeee43e9c265bf5f" translate="yes" xml:space="preserve">
          <source>Technically speaking, any extra semantics attached to a variable such as &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$0&lt;/code&gt;, &lt;code&gt;%ENV&lt;/code&gt;, or &lt;code&gt;%SIG&lt;/code&gt;, or to any tied variable. Magical things happen when you diddle those variables.</source>
          <target state="translated">从技术上讲，任何附加到变量（例如 &lt;code&gt;$!&lt;/code&gt; )的语义都包括在内！， &lt;code&gt;$0&lt;/code&gt; ， &lt;code&gt;%ENV&lt;/code&gt; 或 &lt;code&gt;%SIG&lt;/code&gt; 或任何绑定变量。当您欺骗这些变量时，就会发生神奇的事情。</target>
        </trans-unit>
        <trans-unit id="f6e2f047cca74ccc3c9d17a9bfaad25ab5dfd70e" translate="yes" xml:space="preserve">
          <source>Technically, or mathematically, speaking, a character set encoded in such a CES that maps character by character may form a CCS. EUC is such an example. The CES of EUC is as follows:</source>
          <target state="translated">从技术上或数学上讲,用这样的CES编码的字符集,逐个字符映射,可以形成CCS。EUC就是这样一个例子。EUC的CES如下:</target>
        </trans-unit>
        <trans-unit id="bceeda0d1cb49658a382ae82742f6ea314f38047" translate="yes" xml:space="preserve">
          <source>Tell</source>
          <target state="translated">Tell</target>
        </trans-unit>
        <trans-unit id="36cdc28b89efb53a06a6917a07b767fb68103199" translate="yes" xml:space="preserve">
          <source>Tell all procs/threads it is time to be done</source>
          <target state="translated">告诉所有的procs/线程该结束了。</target>
        </trans-unit>
        <trans-unit id="9278f94e7a82313efec40ca2dd22098d512b4425" translate="yes" xml:space="preserve">
          <source>Tell other processes and events that an event is pending. &lt;code&gt;$uniq_val&lt;/code&gt; should be a unique value no other thread/process will generate.</source>
          <target state="translated">告诉其他进程和事件某个事件正在等待中。 &lt;code&gt;$uniq_val&lt;/code&gt; 应该是其他线程/进程不会生成的唯一值。</target>
        </trans-unit>
        <trans-unit id="e7dda96092209462b6b29c0664b9391938707a82" translate="yes" xml:space="preserve">
          <source>Tell other processes and threads there is a pending event. &lt;code&gt;$val&lt;/code&gt; should be a unique value no other thread/process will generate.</source>
          <target state="translated">告诉其他进程和线程有一个未决事件。 &lt;code&gt;$val&lt;/code&gt; 应该是其他线程/进程不会生成的唯一值。</target>
        </trans-unit>
        <trans-unit id="b3fc1fc6f28fa057e70de617f17fd53df2eeea80" translate="yes" xml:space="preserve">
          <source>Tell the grammar which TAP syntax version to support. The lowest supported version is 12. Although 'TAP version' isn't valid version 12 syntax it is accepted so that higher version numbers may be parsed.</source>
          <target state="translated">告诉语法支持哪个TAP语法版本。最低支持的版本是12。虽然'TAP版本'不是有效的12版本语法,但它被接受了,所以更高的版本号可以被解析。</target>
        </trans-unit>
        <trans-unit id="bf7b0d797da557d31ab2a71f5864f39fe5a06aac" translate="yes" xml:space="preserve">
          <source>Tell the parser to ignore the exit status from the test when determining whether the test passed. Normally tests with non-zero exit status are considered to have failed even if all individual tests passed. In cases where it is not possible to control the exit value of the test script use this option to ignore it.</source>
          <target state="translated">告诉解析器在判断测试是否通过时忽略测试的退出状态。通常情况下,即使所有的测试都通过了,退出状态为非零的测试也会被认为是失败的。在无法控制测试脚本的退出值的情况下,使用这个选项来忽略它。</target>
        </trans-unit>
        <trans-unit id="bf2d615f3aae044f0b7af594b2368699ca553959" translate="yes" xml:space="preserve">
          <source>Tell the parser where should the output go. In this case it will be placed in the $html variable:</source>
          <target state="translated">告诉解析器输出的内容应该放在哪里。在这种情况下,它将被放置在$html变量中。</target>
        </trans-unit>
        <trans-unit id="29533c09561de1801d031a71f8c7c8a01e5f03c1" translate="yes" xml:space="preserve">
          <source>Tell the remote server that I am not a user client, but probably another news server.</source>
          <target state="translated">告诉远程服务器,我不是用户客户端,可能是另一个新闻服务器。</target>
        </trans-unit>
        <trans-unit id="08608b0e566d4fb7e89ec44318b59ab07dde69d0" translate="yes" xml:space="preserve">
          <source>Tell the remote server the mail domain which you are in using the EHLO command (or HELO if EHLO fails). Since this method is invoked automatically when the Net::SMTP object is constructed the user should normally not have to call it manually.</source>
          <target state="translated">使用 EHLO 命令(如果 EHLO 失败,则使用 HELO)告诉远程服务器你所处的邮件域。因为这个方法是在Net::SMTP对象被构造时自动调用的,所以用户通常不需要手动调用它。</target>
        </trans-unit>
        <trans-unit id="1f6b5a09a58a8567f17dcd614ece669f9d14b0d0" translate="yes" xml:space="preserve">
          <source>Tell the server that we want to append some data to the end of a file called &lt;code&gt;FILE&lt;/code&gt; . If this file does not exist then create it.</source>
          <target state="translated">告诉服务器，我们要将一些数据附加到名为 &lt;code&gt;FILE&lt;/code&gt; 的文件的末尾。如果该文件不存在，则创建它。</target>
        </trans-unit>
        <trans-unit id="8ff5b934cbf9d3fd05d80b879d5b2e694a3f82ae" translate="yes" xml:space="preserve">
          <source>Tell the server that we want to append some data to the end of a file called &lt;code&gt;FILE&lt;/code&gt;. If this file does not exist then create it.</source>
          <target state="translated">告诉服务器，我们要将一些数据附加到名为 &lt;code&gt;FILE&lt;/code&gt; 的文件的末尾。如果此文件不存在，则创建它。</target>
        </trans-unit>
        <trans-unit id="995cb880453aaa8bd60b7aae252f5462234be732" translate="yes" xml:space="preserve">
          <source>Tell the server that you are a reader and not another server.</source>
          <target state="translated">告诉服务器,你是一个读者,而不是另一个服务器。</target>
        </trans-unit>
        <trans-unit id="055d9e27b5b7d5b8f2d504557166da8931089570" translate="yes" xml:space="preserve">
          <source>Tell the server that you wish to store a file. &lt;code&gt;FILE&lt;/code&gt; is the name of the new file that should be created.</source>
          <target state="translated">告诉服务器您要存储文件。 &lt;code&gt;FILE&lt;/code&gt; 是应创建的新文件的名称。</target>
        </trans-unit>
        <trans-unit id="9366b9a09ea150c339542dc64664840e4fc85da8" translate="yes" xml:space="preserve">
          <source>Tell the server to go into passive mode (&lt;code&gt;pasv&lt;/code&gt; for IPv4, &lt;code&gt;epsv&lt;/code&gt; for IPv6). Returns the text that represents the port on which the server is listening, this text is in a suitable form to send to another ftp server using the &lt;code&gt;port&lt;/code&gt; or &lt;code&gt;eprt&lt;/code&gt; method.</source>
          <target state="translated">告诉服务器进入被动模式（对于IPv4， &lt;code&gt;pasv&lt;/code&gt; ，对于IPv6 ， &lt;code&gt;epsv&lt;/code&gt; ）。返回表示服务器正在侦听的端口的文本，此文本采用适当的形式，可以使用 &lt;code&gt;port&lt;/code&gt; 或 &lt;code&gt;eprt&lt;/code&gt; 方法发送到另一个ftp服务器。</target>
        </trans-unit>
        <trans-unit id="07221dbb3d1c9d6040ef943ff42c4107c54603a8" translate="yes" xml:space="preserve">
          <source>Telling &lt;a href=&quot;Email::Stuffer&quot;&gt;Email::Stuffer&lt;/a&gt; to use your transport is straightforward.</source>
          <target state="translated">告诉&lt;a href=&quot;Email::Stuffer&quot;&gt;电子邮件::充实&lt;/a&gt;使用您的传输非常简单。</target>
        </trans-unit>
        <trans-unit id="15d551aaf2266eb9d86adea81d4570cc191bb729" translate="yes" xml:space="preserve">
          <source>Telling &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; to use your transport is straightforward.</source>
          <target state="translated">告诉&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;电子邮件::发件人:: ::简单&lt;/a&gt;易用。</target>
        </trans-unit>
        <trans-unit id="dd2c3160deeb317e223ba57be41f996c28b1ec03" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the given string in scalar context and return an SV* result.</source>
          <target state="translated">告诉Perl 在标量上下文中 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 给定的字符串并返回SV *结果。</target>
        </trans-unit>
        <trans-unit id="d9e092fa3e1e256147594ca30bda8c3f4672e0ee" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the string in the SV. It supports the same flags as &lt;code&gt;call_sv&lt;/code&gt; , with the obvious exception of G_EVAL. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">告诉Perl 在SV中 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 字符串。它支持与 &lt;code&gt;call_sv&lt;/code&gt; 相同的标志，但G_EVAL明显例外。参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a71daae5e0e57d93d6228536edc45b69ba84a875" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; the file named by the string argument. It is analogous to the Perl code &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require '$file'&quot;&lt;/code&gt; . It's even implemented that way; consider using load_module instead.</source>
          <target state="translated">告诉Perl &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 使用字符串参数命名的文件。它类似于Perl代码 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require '$file'&quot;&lt;/code&gt; 。它甚至以这种方式实现；考虑改用load_module。</target>
        </trans-unit>
        <trans-unit id="1b1b082272b9bd4181468eabc6b8e44fc8fe6c64" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;eval&lt;/code&gt; the given string in scalar context and return an SV* result.</source>
          <target state="translated">告诉Perl在标量上下文中 &lt;code&gt;eval&lt;/code&gt; 给定的字符串，并返回SV *结果。</target>
        </trans-unit>
        <trans-unit id="4a3df8e8a89eba38389eed572b608ff46f9135ee" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;eval&lt;/code&gt; the string in the SV. It supports the same flags as &lt;code&gt;call_sv&lt;/code&gt;, with the obvious exception of &lt;code&gt;G_EVAL&lt;/code&gt;. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">告诉Perl在SV中 &lt;code&gt;eval&lt;/code&gt; 字符串。它支持相同的标志 &lt;code&gt;call_sv&lt;/code&gt; ，具有明显异常 &lt;code&gt;G_EVAL&lt;/code&gt; 。参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="835ee5f386d4eccf5016f84f3d99b790dcda5f79" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;require&lt;/code&gt; the file named by the string argument. It is analogous to the Perl code &lt;code&gt;eval &quot;require '$file'&quot;&lt;/code&gt;. It's even implemented that way; consider using load_module instead.</source>
          <target state="translated">告诉Perl &lt;code&gt;require&lt;/code&gt; 使用字符串参数命名的文件。它类似于Perl代码 &lt;code&gt;eval &quot;require '$file'&quot;&lt;/code&gt; 。它甚至是通过这种方式实现的。考虑改用load_module。</target>
        </trans-unit>
        <trans-unit id="e1bf556e6d9dede28e015a565e8d9027e099de7d" translate="yes" xml:space="preserve">
          <source>Tells Test::Builder what package you exported your functions to.</source>
          <target state="translated">告诉 Test::Builder 你的函数导出到什么包。</target>
        </trans-unit>
        <trans-unit id="21d8020c0986f9af967d2434489f1dff7dddc2b6" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to parse a Perl script. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">告诉Perl解释器解析Perl脚本。见&lt;a href=&quot;perlembed&quot;&gt;临危&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3fc8f2629186f20e45a65a6df178e8841854cf49" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to parse a Perl script. This performs most of the initialisation of a Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; for a tutorial.</source>
          <target state="translated">告诉Perl解释器解析Perl脚本。这将执行Perl解释器的大部分初始化。有关教程，请参见&lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8af02c41897ccb1ab6624206547ff7270321f616" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to run its main program. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; for a tutorial.</source>
          <target state="translated">告诉Perl解释器运行其主程序。有关教程，请参见&lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90de9fbbe619d0267fd7167e5dc1db64eb361247" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to run. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">告诉Perl解释器运行。见&lt;a href=&quot;perlembed&quot;&gt;临危&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2794a27373eb4499d2dd0fc224b3c502ced9a12f" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a double and disables all other OK bits.</source>
          <target state="translated">告诉SV是双倍,并禁用所有其他OK位。</target>
        </trans-unit>
        <trans-unit id="cde3486f8b34dcc836358775446f605a6e5f5219" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a double.</source>
          <target state="translated">告诉SV是双倍的。</target>
        </trans-unit>
        <trans-unit id="38d5abd50f24b07310ee29175bef33b4202c7809" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other &lt;code&gt;OK&lt;/code&gt; bits, and leaves the UTF-8 status as it was.</source>
          <target state="translated">告诉SV它是一个字符串，并禁用所有其他 &lt;code&gt;OK&lt;/code&gt; 位，并保持UTF-8状态不变。</target>
        </trans-unit>
        <trans-unit id="31fe87231b97a4e4ddb62ec499c5ee8942eac05a" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other &lt;code&gt;OK&lt;/code&gt; bits. Will also turn off the UTF-8 status.</source>
          <target state="translated">告诉SV这是一个字符串，并禁用所有其他 &lt;code&gt;OK&lt;/code&gt; 位。还将关闭UTF-8状态。</target>
        </trans-unit>
        <trans-unit id="d29a05e0eb81580dedcd3ec32c30e53e3f465ef8" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other OK bits, and leaves the UTF-8 status as it was.</source>
          <target state="translated">告诉SV是一个字符串,并禁用所有其他OK位,保持UTF-8状态不变。</target>
        </trans-unit>
        <trans-unit id="826cf5cb563ce76cd986386302e8a1a458503e48" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other OK bits. Will also turn off the UTF-8 status.</source>
          <target state="translated">告诉SV是一个字符串,并禁用所有其他OK位。也会关闭UTF-8状态。</target>
        </trans-unit>
        <trans-unit id="3a0e0af0ea20a9f25152c6d76518063affb1c7ae" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string.</source>
          <target state="translated">告诉SV是一个字符串。</target>
        </trans-unit>
        <trans-unit id="9359d018a66deddebc4670552c35dfa39c5db6a1" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an RV.</source>
          <target state="translated">告诉SV,它是一辆RV。</target>
        </trans-unit>
        <trans-unit id="6c3d42b807cb60d5c1d3b6f5a5dbefd19d80f738" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer and disables all other &lt;code&gt;OK&lt;/code&gt; bits.</source>
          <target state="translated">告诉SV它是一个整数，并禁用所有其他 &lt;code&gt;OK&lt;/code&gt; 位。</target>
        </trans-unit>
        <trans-unit id="a2ea638c533f4384730e93210ef4a899bb9d756b" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer and disables all other OK bits.</source>
          <target state="translated">告诉SV是一个整数,并禁用所有其他OK位。</target>
        </trans-unit>
        <trans-unit id="6d0dafe3ace125974c920e3d5dd9ad0e37849cd8" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer.</source>
          <target state="translated">告诉SV是一个整数。</target>
        </trans-unit>
        <trans-unit id="32b076858cb529d5d1d166704ef6d15c34643322" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an unsigned integer and disables all other &lt;code&gt;OK&lt;/code&gt; bits.</source>
          <target state="translated">通知SV这是一个无符号整数，并禁用所有其他 &lt;code&gt;OK&lt;/code&gt; 位。</target>
        </trans-unit>
        <trans-unit id="b0b98f3f753198e2b29067e4cd07e7535b94339d" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an unsigned integer and disables all other OK bits.</source>
          <target state="translated">告诉SV是一个无符号整数,并禁用所有其他OK位。</target>
        </trans-unit>
        <trans-unit id="2f015ae08c2ba0f00c29151908ca6bc489974130" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Implemented by calling &lt;code&gt;sv_usepvn_flags&lt;/code&gt; with &lt;code&gt;flags&lt;/code&gt; of 0, hence does not handle 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_usepvn_flags&quot;&gt;&quot;sv_usepvn_flags&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">告诉SV使用 &lt;code&gt;ptr&lt;/code&gt; 查找其字符串值。通过调用来实现 &lt;code&gt;sv_usepvn_flags&lt;/code&gt; 与 &lt;code&gt;flags&lt;/code&gt; 为0，因此不处理&amp;ldquo;设置&amp;rdquo;魔术。请参见 &lt;code&gt;&lt;a href=&quot;#sv_usepvn_flags&quot;&gt;&quot;sv_usepvn_flags&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98e3c3ca5f6df324b9d092553470d578100c40eb" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Implemented by calling &lt;code&gt;sv_usepvn_flags&lt;/code&gt; with &lt;code&gt;flags&lt;/code&gt; of 0, hence does not handle 'set' magic. See &lt;code&gt;sv_usepvn_flags&lt;/code&gt; .</source>
          <target state="translated">告诉SV使用 &lt;code&gt;ptr&lt;/code&gt; 查找其字符串值。通过调用来实现 &lt;code&gt;sv_usepvn_flags&lt;/code&gt; 与 &lt;code&gt;flags&lt;/code&gt; 为0，因此不处理&amp;ldquo;设置&amp;rdquo;魔术。参见 &lt;code&gt;sv_usepvn_flags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f1684ac88b387a920693532449fce7adef04529" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Normally the string is stored inside the SV, but sv_usepvn allows the SV to use an outside string. &lt;code&gt;ptr&lt;/code&gt; should point to memory that was allocated by &lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt;&lt;code&gt;Newx&lt;/code&gt;&lt;/a&gt;. It must be the start of a &lt;code&gt;Newx&lt;/code&gt;-ed block of memory, and not a pointer to the middle of it (beware of &lt;a href=&quot;perlguts#Offsets&quot;&gt;&lt;code&gt;OOK&lt;/code&gt;&lt;/a&gt; and copy-on-write), and not be from a non-&lt;code&gt;Newx&lt;/code&gt; memory allocator like &lt;code&gt;malloc&lt;/code&gt;. The string length, &lt;code&gt;len&lt;/code&gt;, must be supplied. By default this function will &lt;code&gt;Renew&lt;/code&gt; (i.e. realloc, move) the memory pointed to by &lt;code&gt;ptr&lt;/code&gt;, so that pointer should not be freed or used by the programmer after giving it to &lt;code&gt;sv_usepvn&lt;/code&gt;, and neither should any pointers from &quot;behind&quot; that pointer (e.g. ptr + 1) be used.</source>
          <target state="translated">告诉SV使用 &lt;code&gt;ptr&lt;/code&gt; 查找其字符串值。通常，字符串存储在SV内部，但是sv_usepvn允许SV使用外部字符串。 &lt;code&gt;ptr&lt;/code&gt; 应该指向&lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt; &lt;code&gt;Newx&lt;/code&gt; &lt;/a&gt;分配的内存。它必须是基于 &lt;code&gt;Newx&lt;/code&gt; 的内存块的开始，而不是指向其中间的指针（请注意&lt;a href=&quot;perlguts#Offsets&quot;&gt; &lt;code&gt;OOK&lt;/code&gt; &lt;/a&gt;和写时复制），并且不能来自非 &lt;code&gt;Newx&lt;/code&gt; 内存分配器（如 &lt;code&gt;malloc&lt;/code&gt; )。必须提供字符串长度 &lt;code&gt;len&lt;/code&gt; 。默认情况下，此函数将 &lt;code&gt;Renew&lt;/code&gt; （即重新分配，移动） &lt;code&gt;ptr&lt;/code&gt; 指向的内存，因此，在将指针赋予 &lt;code&gt;sv_usepvn&lt;/code&gt; 之后，程序员不应释放或使用该指针，也不应使用该指针&amp;ldquo;后面&amp;rdquo;的任何指针（例如ptr + 1）。</target>
        </trans-unit>
        <trans-unit id="898e0cc9cfb0dad2df7d68beacd47f39b7ca2406" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Normally the string is stored inside the SV, but sv_usepvn allows the SV to use an outside string. The &lt;code&gt;ptr&lt;/code&gt; should point to memory that was allocated by &lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt;Newx&lt;/a&gt;. It must be the start of a Newx-ed block of memory, and not a pointer to the middle of it (beware of &lt;a href=&quot;perlguts#Offsets&quot;&gt;OOK&lt;/a&gt; and copy-on-write), and not be from a non-Newx memory allocator like &lt;code&gt;malloc&lt;/code&gt; . The string length, &lt;code&gt;len&lt;/code&gt; , must be supplied. By default this function will &lt;code&gt;Renew&lt;/code&gt; (i.e. realloc, move) the memory pointed to by &lt;code&gt;ptr&lt;/code&gt; , so that pointer should not be freed or used by the programmer after giving it to sv_usepvn, and neither should any pointers from &quot;behind&quot; that pointer (e.g. ptr + 1) be used.</source>
          <target state="translated">告诉SV使用 &lt;code&gt;ptr&lt;/code&gt; 查找其字符串值。通常，字符串存储在SV内部，但是sv_usepvn允许SV使用外部字符串。在 &lt;code&gt;ptr&lt;/code&gt; 应该指向被分配的内存&lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt;下一页末&lt;/a&gt;。它必须是Newx版本的内存块的开始，而不是指向其中间的指针（请注意&lt;a href=&quot;perlguts#Offsets&quot;&gt;OOK&lt;/a&gt;和写时复制），并且不能来自非newx的内存分配器（如 &lt;code&gt;malloc&lt;/code&gt; )。必须提供字符串长度 &lt;code&gt;len&lt;/code&gt; 。默认情况下，此函数将 &lt;code&gt;Renew&lt;/code&gt; （即重新分配，移动） &lt;code&gt;ptr&lt;/code&gt; 指向的内存 ，因此程序员在将指针赋予sv_usepvn之后不应释放或使用该指针，也不应使用该指针&amp;ldquo;后面&amp;rdquo;的任何指针（例如ptr + 1）。</target>
        </trans-unit>
        <trans-unit id="fa94c122bdfc00ca551536773f45fe7b4444a81f" translate="yes" xml:space="preserve">
          <source>Tells the debugger that we'll want to pause execution when we reach either the named function (but see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;&quot;Internal Functions&quot; in perlguts&lt;/a&gt;!) or the given line in the named source file.</source>
          <target state="translated">告诉调试器，当我们到达命名函数（但请参见&lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;perlguts中的&amp;ldquo;内部函数&amp;rdquo;&lt;/a&gt;！）或命名源文件中的给定行时，我们将希望暂停执行。</target>
        </trans-unit>
        <trans-unit id="ea1983bb2952566f54d05f0ce7c7dc4c67383643" translate="yes" xml:space="preserve">
          <source>Tells the debugger that we'll want to pause execution when we reach either the named function (but see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Internal Functions in perlguts&lt;/a&gt;!) or the given line in the named source file.</source>
          <target state="translated">告诉调试器，当我们到达命名函数（但请参见&lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;perlguts中的Internal Functions&lt;/a&gt;）或命名源文件中的给定行时，我们将希望暂停执行。</target>
        </trans-unit>
        <trans-unit id="d14b1bd32ddb84a178c8e757f0eede95fcc4f56d" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on characters. The definition of character varies depending on if the target string is a UTF-8 string.</source>
          <target state="translated">指示分割操作者分割目标字符串的字符。字符的定义根据目标字符串是否是UTF-8字符串而不同。</target>
        </trans-unit>
        <trans-unit id="184bc1d12ee8da813cda422d2ca1e00df540f884" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on newlines (&lt;code&gt;\n&lt;/code&gt; ) without invoking the regex engine.</source>
          <target state="translated">告诉split运算符在不调用正则表达式引擎的情况下在换行符（ &lt;code&gt;\n&lt;/code&gt; ）上分割目标字符串。</target>
        </trans-unit>
        <trans-unit id="7add2a85af4113fd669c82c4ee4e7afc64bec786" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on newlines (&lt;code&gt;\n&lt;/code&gt;) without invoking the regex engine.</source>
          <target state="translated">告诉split运算符在不调用正则表达式引擎的情况下在换行符（ &lt;code&gt;\n&lt;/code&gt; ）上分割目标字符串。</target>
        </trans-unit>
        <trans-unit id="b48808542e716e16e3adb670d9889b9528897056" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on whitespace without invoking the regex engine. The definition of whitespace varies depending on if the target string is a UTF-8 string and on if RXf_PMf_LOCALE is set.</source>
          <target state="translated">指示分割操作者在不调用regex引擎的情况下分割目标字符串的whitespace。whitespace的定义取决于目标字符串是否是UTF-8,以及RXf_PMf_LOCALE是否被设置。</target>
        </trans-unit>
        <trans-unit id="e150384486349cedc8729ff69a3903d6982a4a60" translate="yes" xml:space="preserve">
          <source>Tells whether the object is renewed (and how many times). Some modules emit &lt;code&gt;Use of uninitialized value in null operation&lt;/code&gt; warning unless the value is numeric so return 0 for false.</source>
          <target state="translated">告诉对象是否被更新（以及更新了多少次）。某些模块会 &lt;code&gt;Use of uninitialized value in null operation&lt;/code&gt; 发出使用未初始化的值的警告，除非该值是数字，否则返回0表示false。</target>
        </trans-unit>
        <trans-unit id="fe08a0c4d36ed96cbb4447cc6f3eff3004614a0a" translate="yes" xml:space="preserve">
          <source>Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt; 2001-2009.</source>
          <target state="translated">电话&lt;a href=&quot;http://bloodgate.com/&quot;&gt;：http：&lt;/a&gt; //bloodgate.com/ 2001-2009。</target>
        </trans-unit>
        <trans-unit id="d7760f2328a8cb1216abc5d480c3f7c025535cee" translate="yes" xml:space="preserve">
          <source>Temp dir + Files concurrency model.</source>
          <target state="translated">临时文件夹+文件并发模型。</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="716ec42869a03408fcb77c9873e5ac4f7f2b0aad" translate="yes" xml:space="preserve">
          <source>Template Grouping</source>
          <target state="translated">模板分组</target>
        </trans-unit>
        <trans-unit id="c9f888d973643e39eea58ba0d4385df9a5d27ccf" translate="yes" xml:space="preserve">
          <source>Template code &lt;code&gt;P&lt;/code&gt; promises to pack a &quot;pointer to a fixed length string&quot;. Isn't this what we want? Let's try:</source>
          <target state="translated">模板代码 &lt;code&gt;P&lt;/code&gt; 承诺打包&amp;ldquo;指向固定长度字符串的指针&amp;rdquo;。这不是我们想要的吗？我们试试吧：</target>
        </trans-unit>
        <trans-unit id="a108586754857c54e59b71ddb85b8b2a3279733a" translate="yes" xml:space="preserve">
          <source>Template is the same as that required by mkstemp().</source>
          <target state="translated">模板与mkstemp()所要求的模板相同。</target>
        </trans-unit>
        <trans-unit id="3d3a072632618e86894944ff55a4538808fd8ea6" translate="yes" xml:space="preserve">
          <source>Temporaries Stack</source>
          <target state="translated">临时堆栈</target>
        </trans-unit>
        <trans-unit id="58aad47f3a12a51d4d52aa8432c69a9c8ebbb3e7" translate="yes" xml:space="preserve">
          <source>Temporarily disable a member of the XOP, by clearing the appropriate flag.</source>
          <target state="translated">通过清除相应的标志,暂时禁用XOP的一个成员。</target>
        </trans-unit>
        <trans-unit id="d80af7efaaaefafc73c5845cc5b267960e4626cc" translate="yes" xml:space="preserve">
          <source>Temporarily disable an entry in this BHK structure, by clearing the appropriate flag.</source>
          <target state="translated">通过清除相应的标志,暂时禁用该BHK结构中的一个条目。</target>
        </trans-unit>
        <trans-unit id="e7f1b0942dc03abbb9406810a4ca16b57247a87e" translate="yes" xml:space="preserve">
          <source>Temporarily disable an entry in this BHK structure, by clearing the appropriate flag. &lt;code&gt;which&lt;/code&gt; is a preprocessor token indicating which entry to disable.</source>
          <target state="translated">通过清除相应的标志，暂时禁用此BHK结构中的条目。 &lt;code&gt;which&lt;/code&gt; 是一个预处理器令牌，指示要禁用的条目。</target>
        </trans-unit>
        <trans-unit id="3e3f1700e4dfa66cdfab75739db179821b620308" translate="yes" xml:space="preserve">
          <source>Temporarily fixing locale problems</source>
          <target state="translated">暂时解决地域问题</target>
        </trans-unit>
        <trans-unit id="48915beb5208adc13703e622845e9d9286a425c6" translate="yes" xml:space="preserve">
          <source>Temporarily override assorted &lt;code&gt;CPAN.pm&lt;/code&gt; configuration variables.</source>
          <target state="translated">临时覆盖各种 &lt;code&gt;CPAN.pm&lt;/code&gt; 配置变量。</target>
        </trans-unit>
        <trans-unit id="8d8d27f44975a51a83ee576661872ef78010f131" translate="yes" xml:space="preserve">
          <source>Temporary (no file directory).</source>
          <target state="translated">临时性(无文件目录)。</target>
        </trans-unit>
        <trans-unit id="6563ecf47ef5662e753d4670106fb233c800e886" translate="yes" xml:space="preserve">
          <source>Temporary Values via local()</source>
          <target state="translated">通过local()的临时值</target>
        </trans-unit>
        <trans-unit id="966d13f8587efdadd4d1a975aa3423e8769b72b3" translate="yes" xml:space="preserve">
          <source>Temporary delete.</source>
          <target state="translated">临时删除。</target>
        </trans-unit>
        <trans-unit id="ab6577ed3ab16dc6a0a24e8a29b8f2320a3f1bea" translate="yes" xml:space="preserve">
          <source>Temporary files and NFS</source>
          <target state="translated">临时文件和NFS</target>
        </trans-unit>
        <trans-unit id="972e2ab11e7ed25c1af63f02f49c51ed09f64187" translate="yes" xml:space="preserve">
          <source>Tend to fail, not succeed.</source>
          <target state="translated">倾向于失败,而不是成功。</target>
        </trans-unit>
        <trans-unit id="81ac69447a0c644cecd1c09f31f389b73f4febee" translate="yes" xml:space="preserve">
          <source>Tenon Machten</source>
          <target state="translated">榫头动力</target>
        </trans-unit>
        <trans-unit id="038c9aeb7bb05d375a32b9ab2979691faa497330" translate="yes" xml:space="preserve">
          <source>Term used by language lawyers for a storage location you can assign a new &lt;b&gt;value&lt;/b&gt; to, such as a &lt;b&gt;variable&lt;/b&gt; or an element of an &lt;b&gt;array&lt;/b&gt;. The &amp;ldquo;l&amp;rdquo; is short for &amp;ldquo;left&amp;rdquo;, as in the left side of an assignment, a typical place for lvalues. An &lt;b&gt;lvaluable&lt;/b&gt; function or expression is one to which a value may be assigned, as in &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;($x) = 10&lt;/code&gt; .</source>
          <target state="translated">语言律师用于存储位置的术语，您可以为其分配新&lt;b&gt;值&lt;/b&gt;，例如&lt;b&gt;变量&lt;/b&gt;或&lt;b&gt;数组&lt;/b&gt;的元素。&amp;ldquo; l&amp;rdquo;是&amp;ldquo; left&amp;rdquo;的缩写，就像在赋值的左侧一样，是左值的典型位置。可&lt;b&gt;评估&lt;/b&gt;函数或表达式是可以为其分配值的函数或表达式，如 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;($x) = 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3570ded95db6a210fa183ad2282d08a349916fef" translate="yes" xml:space="preserve">
          <source>Term used by language lawyers for a storage location you can assign a new &lt;b&gt;value&lt;/b&gt; to, such as a &lt;b&gt;variable&lt;/b&gt; or an element of an &lt;b&gt;array&lt;/b&gt;. The &amp;ldquo;l&amp;rdquo; is short for &amp;ldquo;left&amp;rdquo;, as in the left side of an assignment, a typical place for lvalues. An &lt;b&gt;lvaluable&lt;/b&gt; function or expression is one to which a value may be assigned, as in &lt;code&gt;pos($x) = 10&lt;/code&gt;.</source>
          <target state="translated">语言律师用于存储位置的术语，您可以为其分配新&lt;b&gt;值&lt;/b&gt;，例如&lt;b&gt;变量&lt;/b&gt;或&lt;b&gt;数组&lt;/b&gt;的元素。&amp;ldquo; l&amp;rdquo;是&amp;ldquo; left&amp;rdquo;的缩写，就像在赋值的左侧一样，是lvalues的典型位置。可&lt;b&gt;评估&lt;/b&gt;函数或表达式是可以为其分配值的函数或表达式，如 &lt;code&gt;pos($x) = 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d0028d995c201a4db08a4f29da91c7c14dbfb31" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor</source>
          <target state="translated">Term::ANSIColor</target>
        </trans-unit>
        <trans-unit id="a16dc007b248f41d8a8b48934fc42c79241aa183" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor - Color screen output using ANSI escape sequences</source>
          <target state="translated">Term::ANSIColor-使用ANSI转义序列进行彩色屏幕输出。</target>
        </trans-unit>
        <trans-unit id="db406ea9117455f0b666b6ba8f4edfbd34a6728b" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor is used to get colors and therefore must be installed to use this module.</source>
          <target state="translated">Term::ANSIColor用于获取颜色,因此必须安装该模块才能使用。</target>
        </trans-unit>
        <trans-unit id="f7bdc8f03c4b5d2f5d03a99d6b589da67ba2844c" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor was first included with Perl in Perl 5.6.0.</source>
          <target state="translated">Term::ANSIColor在Perl 5.6.0中首次包含在Perl中。</target>
        </trans-unit>
        <trans-unit id="3973a6639b848462a9aba2fb3883fdeeeee93564" translate="yes" xml:space="preserve">
          <source>Term::Cap</source>
          <target state="translated">Term::Cap</target>
        </trans-unit>
        <trans-unit id="82cd629b4593ce6a72b220343056170a7eb3d545" translate="yes" xml:space="preserve">
          <source>Term::Cap - Perl termcap interface</source>
          <target state="translated">Term::Cap-Perl termcap接口</target>
        </trans-unit>
        <trans-unit id="3d3bfe455e655790515f3b006edeb99748236633" translate="yes" xml:space="preserve">
          <source>Term::Complete</source>
          <target state="translated">Term::Complete</target>
        </trans-unit>
        <trans-unit id="6d23da7c53fbf0f4faebaefa6851bd7ad00eee31" translate="yes" xml:space="preserve">
          <source>Term::Complete - Perl word completion module</source>
          <target state="translated">Term::Complete-Perl词语完成模块</target>
        </trans-unit>
        <trans-unit id="23ebd3bc9f5af49b1131c82bd5eefd1ac9f6bc11" translate="yes" xml:space="preserve">
          <source>Term::ReadLine</source>
          <target state="translated">Term::ReadLine</target>
        </trans-unit>
        <trans-unit id="bfadfd7a83f6920cfb9038f1942ac1ea2e3b25c1" translate="yes" xml:space="preserve">
          <source>Term::ReadLine - Perl interface to various &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; packages. If no real package is found, substitutes stubs instead of basic functions.</source>
          <target state="translated">Term :: ReadLine-各种 &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 包的Perl接口。如果找不到真正的程序包，则用存根代替基本功能。</target>
        </trans-unit>
        <trans-unit id="7113fd2a1763597777139799d4259876fd00d022" translate="yes" xml:space="preserve">
          <source>Term::ReadLine - Perl interface to various &lt;code&gt;readline&lt;/code&gt; packages. If no real package is found, substitutes stubs instead of basic functions.</source>
          <target state="translated">Term :: ReadLine-各种 &lt;code&gt;readline&lt;/code&gt; 包的Perl接口。如果找不到真正的程序包，则用存根代替基本功能。</target>
        </trans-unit>
        <trans-unit id="c8b36cab4785101b615f79c20885ccd2eda2f048" translate="yes" xml:space="preserve">
          <source>Terminal emulators that support color divide into four types: ones that support only eight colors, ones that support sixteen, ones that support 256, and ones that support 24-bit color. This module provides the ANSI escape codes for all of them. These colors are referred to as ANSI colors 0 through 7 (normal), 8 through 15 (16-color), 16 through 255 (256-color), and true color (called direct-color by &lt;b&gt;xterm&lt;/b&gt;).</source>
          <target state="translated">支持颜色的终端仿真器分为四种类型：仅支持八种颜色的仿真器，支持十六种颜色的仿真器，支持256种颜色的仿真器和支持24位颜色的仿真器。此模块为所有这些代码提供ANSI转义代码。这些颜色称为ANSI颜色0到7（正常），8到15（16色），16到255（256色）和真色（通过&lt;b&gt;xterm&lt;/b&gt;称为直接色）。</target>
        </trans-unit>
        <trans-unit id="eb8379c22e18e11951de951761db8a9d7c5f2195" translate="yes" xml:space="preserve">
          <source>Terminal emulators that support color divide into two types: ones that support only eight colors, ones that support sixteen, and ones that support 256. This module provides the ANSI escape codes all of them. These colors are referred to as ANSI colors 0 through 7 (normal), 8 through 15 (16-color), and 16 through 255 (256-color).</source>
          <target state="translated">支持颜色的终端仿真器分为两种类型:只支持8种颜色的,支持16种颜色的,以及支持256种颜色的。本模块提供了所有这些颜色的ANSI转义码。这些颜色被称为ANSI颜色0到7(正常),8到15(16色),16到255(256色)。</target>
        </trans-unit>
        <trans-unit id="06b99286ab352f9eeaab809a6a34ccd3528b3299" translate="yes" xml:space="preserve">
          <source>Terminal interface values</source>
          <target state="translated">终端接口值</target>
        </trans-unit>
        <trans-unit id="9b13399f2e2e5cbdb3d2ac7675630b976b3e5443" translate="yes" xml:space="preserve">
          <source>Terminate use of a parser. Typically used and/or overridden in subclasses. The parser isn't destroyed as a result of this.</source>
          <target state="translated">终止一个解析器的使用。通常在子类中使用和/或重写。解析器不会因此而被销毁。</target>
        </trans-unit>
        <trans-unit id="6b2081166b6ec9fa584db14b8bc64a4e53b287d9" translate="yes" xml:space="preserve">
          <source>Terminates the compressed data stream and flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">终止压缩数据流，并将所有未决的压缩数据刷新到 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2aa7fbea2d0e607309e315ba46eefb556163b2c8" translate="yes" xml:space="preserve">
          <source>Terminates the compressed data stream and flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt;.</source>
          <target state="translated">终止压缩数据流，并将所有未决的压缩数据刷新到 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="2c65f89cb90bf010c5c15d59ad7362f6575faeff" translate="yes" xml:space="preserve">
          <source>Terms and List Operators (Leftward)</source>
          <target state="translated">术语和列表操作符(向左</target>
        </trans-unit>
        <trans-unit id="aadfdbce37d51dbb8148884093a756d6e68d99bd" translate="yes" xml:space="preserve">
          <source>Termux</source>
          <target state="translated">Termux</target>
        </trans-unit>
        <trans-unit id="f7687808514bd6fdef254462f2ef21603ff94c5d" translate="yes" xml:space="preserve">
          <source>Ternary &lt;code&gt;&quot;?:&quot;&lt;/code&gt; is the conditional operator, just as in C. It works much like an if-then-else. If the argument before the &lt;code&gt;?&lt;/code&gt; is true, the argument before the &lt;code&gt;:&lt;/code&gt; is returned, otherwise the argument after the &lt;code&gt;:&lt;/code&gt; is returned. For example:</source>
          <target state="translated">与C中一样，三元 &lt;code&gt;&quot;?:&quot;&lt;/code&gt; 是条件运算符。它的工作方式非常类似于if-then-else。如果在论点之前 &lt;code&gt;?&lt;/code&gt; 如果为true，则返回 &lt;code&gt;:&lt;/code&gt; 之前的参数，否则返回 &lt;code&gt;:&lt;/code&gt; 之后的参数。例如：</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="a606ccac095617dc9512d70db5efd42e7bb98a43" translate="yes" xml:space="preserve">
          <source>Test - provides a simple framework for writing test scripts</source>
          <target state="translated">测试-为编写测试脚本提供了一个简单的框架。</target>
        </trans-unit>
        <trans-unit id="39cded9148b38cec922514bd35a2aef5469fc539" translate="yes" xml:space="preserve">
          <source>Test Status and Info</source>
          <target state="translated">测试状态和信息</target>
        </trans-unit>
        <trans-unit id="0f42e18af9e42f65883381d95b6da9a9beb625ba" translate="yes" xml:space="preserve">
          <source>Test _all_ behaviors of a given operator, library, or function.</source>
          <target state="translated">测试给定操作符、库或函数的所有行为。</target>
        </trans-unit>
        <trans-unit id="ccbf4ddf89827f1aef746e7810ae2a433cf06e90" translate="yes" xml:space="preserve">
          <source>Test all optional arguments.</source>
          <target state="translated">测试所有可选参数。</target>
        </trans-unit>
        <trans-unit id="ee2236a26189cf2bce4daa0c312f2ad998013277" translate="yes" xml:space="preserve">
          <source>Test an SV for taintedness. Use &lt;code&gt;SvTAINTED&lt;/code&gt; instead.</source>
          <target state="translated">测试SV的污点。请改用 &lt;code&gt;SvTAINTED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="435f6b9009ca18e663fe202fc1240deccf2b918a" translate="yes" xml:space="preserve">
          <source>Test building utility methods</source>
          <target state="translated">测试建筑实用方法</target>
        </trans-unit>
        <trans-unit id="b4b87c6940ff3faed10366f7a463d3bfb89e71a4" translate="yes" xml:space="preserve">
          <source>Test control</source>
          <target state="translated">测试控制</target>
        </trans-unit>
        <trans-unit id="5f7408dbafe0232db081d945ae171586f08aae05" translate="yes" xml:space="preserve">
          <source>Test files not found under</source>
          <target state="translated">下找不到测试文件</target>
        </trans-unit>
        <trans-unit id="10d741ad5424269aabb883c550c337fb9f577347" translate="yes" xml:space="preserve">
          <source>Test for Memoize expiration semantics</source>
          <target state="translated">Memoize过期语义测试</target>
        </trans-unit>
        <trans-unit id="f76975f4d894de42ed86a6b96159814a64e69414" translate="yes" xml:space="preserve">
          <source>Test for end of file.</source>
          <target state="translated">测试文件是否结束。</target>
        </trans-unit>
        <trans-unit id="79382a00ce637c0c3d356c1d16aa7f8ddce716b6" translate="yes" xml:space="preserve">
          <source>Test for the value of &amp;amp;Time::HiRes::d_hires_stat to find out whether the operating system supports subsecond file timestamps: a value larger than zero means yes. There are unfortunately no easy ways to find out whether the filesystem supports such timestamps. UNIX filesystems often do; NTFS does; FAT doesn't (FAT timestamp granularity is &lt;b&gt;two&lt;/b&gt; seconds).</source>
          <target state="translated">测试＆Time :: HiRes :: d_hires_stat的值，以了解操作系统是否支持亚秒级文件时间戳：大于零的值表示是。不幸的是，没有简单的方法来确定文件系统是否支持这种时间戳。UNIX文件系统经常这样做；NTFS可以；FAT没有（FAT时间戳粒度为&lt;b&gt;2&lt;/b&gt;秒）。</target>
        </trans-unit>
        <trans-unit id="feacda2f5709bb28aab0498393394934934708d7" translate="yes" xml:space="preserve">
          <source>Test for the value of &amp;amp;Time::HiRes::d_hires_utime to find out whether the operating system supports setting subsecond file timestamps.</source>
          <target state="translated">测试＆Time :: HiRes :: d_hires_utime的值，以了解操作系统是否支持设置亚秒级文件时间戳。</target>
        </trans-unit>
        <trans-unit id="58d9cdf0f1500007619c451c5eaa7ecb15e59b66" translate="yes" xml:space="preserve">
          <source>Test if the content of an SV looks like a number (or is a number). &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt; are treated as numbers (so will not issue a non-numeric warning), even if your &lt;code&gt;atof()&lt;/code&gt; doesn't grok them. Get-magic is ignored.</source>
          <target state="translated">测试SV的内容是否看起来像数字（或是数字）。 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;Infinity&lt;/code&gt; 被视为数字（因此不会发出非数字警告），即使您的 &lt;code&gt;atof()&lt;/code&gt; 不会忽略它们也是如此。Get-magic被忽略。</target>
        </trans-unit>
        <trans-unit id="7f831cc3a669b4e57bff2b2ef159b4ea5dded3cc" translate="yes" xml:space="preserve">
          <source>Test if the content of an SV looks like a number (or is a number). &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt; are treated as numbers (so will not issue a non-numeric warning), even if your atof() doesn't grok them. Get-magic is ignored.</source>
          <target state="translated">测试SV的内容是否看起来像数字（或是数字）。 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;Infinity&lt;/code&gt; 被视为数字（因此不会发出非数字警告），即使您的atof（）不会忽略它们也是如此。Get-magic被忽略。</target>
        </trans-unit>
        <trans-unit id="eff6484209621d4819416b73c20e645cef64569b" translate="yes" xml:space="preserve">
          <source>Test mode. Makes it possible to command perlbug from a pipe or file, for testing purposes.</source>
          <target state="translated">测试模式。使得它可以从管道或文件中命令perlbug,用于测试目的。</target>
        </trans-unit>
        <trans-unit id="7f13862d482c878134330e38991502bcc64e1f31" translate="yes" xml:space="preserve">
          <source>Test mode. The target address defaults to &lt;b&gt;perlbug-test@perl.org&lt;/b&gt;.</source>
          <target state="translated">测试模式。目标地址默认为&lt;b&gt;perlbug-test@perl.org&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="69080e5c49da5d3bba9b15a273b20b2df3903f2b" translate="yes" xml:space="preserve">
          <source>Test names</source>
          <target state="translated">测试名称</target>
        </trans-unit>
        <trans-unit id="06b20000ce74a97fae877b75a137b770c99da787" translate="yes" xml:space="preserve">
          <source>Test numbers out of sequence</source>
          <target state="translated">测试不按顺序的数字</target>
        </trans-unit>
        <trans-unit id="5df0db78620ddd32bfd4efd442e6b3f36d8261a7" translate="yes" xml:space="preserve">
          <source>Test result token.</source>
          <target state="translated">测试结果令牌。</target>
        </trans-unit>
        <trans-unit id="ee151a1ef75c0ed5024755e133172ea9006bb555" translate="yes" xml:space="preserve">
          <source>Test results vary depending on your host system and your Cygwin configuration. If a test can pass in some Cygwin setup, it is always attempted and explainable test failures are documented. It is possible for Perl to pass all the tests, but it is more likely that some tests will fail for one of the reasons listed below.</source>
          <target state="translated">测试结果根据您的主机系统和Cygwin配置的不同而不同。如果一个测试在某些Cygwin设置中可以通过,那么它总是会被尝试,并且会记录可解释的测试失败。Perl有可能通过所有的测试,但更有可能的是,有些测试会因为下面列出的原因而失败。</target>
        </trans-unit>
        <trans-unit id="a10b429173c58a1c6dcb960c4e6c1c09b38479a1" translate="yes" xml:space="preserve">
          <source>Test results will be added to the supplied &lt;a href=&quot;TAP::Parser::Aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;. &lt;code&gt;aggregate_tests&lt;/code&gt; may be called multiple times to run several sets of tests. Multiple &lt;code&gt;Test::Harness&lt;/code&gt; instances may be used to pass results to a single aggregator so that different parts of a complex test suite may be run using different &lt;code&gt;TAP::Harness&lt;/code&gt; settings. This is useful, for example, in the case where some tests should run in parallel but others are unsuitable for parallel execution.</source>
          <target state="translated">测试结果将添加到提供的&lt;a href=&quot;TAP::Parser::Aggregator&quot;&gt;TAP :: Parser :: Aggregator中&lt;/a&gt;。可以多次调用 &lt;code&gt;aggregate_tests&lt;/code&gt; 来运行几组测试。可以使用多个 &lt;code&gt;Test::Harness&lt;/code&gt; 实例将结果传递给单个聚合器，以便可以使用不同的 &lt;code&gt;TAP::Harness&lt;/code&gt; 设置来运行复杂测试套件的不同部分。例如，在某些测试应并行运行而其他测试不适合并行执行的情况下，这很有用。</target>
        </trans-unit>
        <trans-unit id="7aeb2301cd878b4bea322bf5867e98635082f17a" translate="yes" xml:space="preserve">
          <source>Test results will be added to the supplied &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;. &lt;code&gt;aggregate_tests&lt;/code&gt; may be called multiple times to run several sets of tests. Multiple &lt;code&gt;Test::Harness&lt;/code&gt; instances may be used to pass results to a single aggregator so that different parts of a complex test suite may be run using different &lt;code&gt;TAP::Harness&lt;/code&gt; settings. This is useful, for example, in the case where some tests should run in parallel but others are unsuitable for parallel execution.</source>
          <target state="translated">测试结果将添加到提供的&lt;a href=&quot;parser/aggregator&quot;&gt;TAP :: Parser :: Aggregator中&lt;/a&gt;。可以多次调用 &lt;code&gt;aggregate_tests&lt;/code&gt; 以运行几组测试。可以使用多个 &lt;code&gt;Test::Harness&lt;/code&gt; 实例将结果传递给单个聚合器，以便可以使用不同的 &lt;code&gt;TAP::Harness&lt;/code&gt; 设置来运行复杂测试套件的不同部分。例如，在某些测试应并行运行而其他测试不适合并行执行的情况下，这很有用。</target>
        </trans-unit>
        <trans-unit id="30bf8d2a1f537e3de40966fbaca2a259bafa1326" translate="yes" xml:space="preserve">
          <source>Test return values in various contexts (boolean, scalar, list, lvalue).</source>
          <target state="translated">测试各种情况下的返回值(布尔、标量、列表、lvalue)。</target>
        </trans-unit>
        <trans-unit id="87b25e7182a4957634bdf28eb60aa42f52a26bbf" translate="yes" xml:space="preserve">
          <source>Test style</source>
          <target state="translated">测试风格</target>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="translated">测试套件</target>
        </trans-unit>
        <trans-unit id="26b3f7125d4977a4c818431649628fa0924ccde1" translate="yes" xml:space="preserve">
          <source>Test testsuites that have been built with</source>
          <target state="translated">构建的测试套件。</target>
        </trans-unit>
        <trans-unit id="166736fddcc4133d965dff627cc8b8b46442426f" translate="yes" xml:space="preserve">
          <source>Test that a &lt;code&gt;long double&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;. Takes no arguments - the test value is hard-wired into the function (as &quot;7&quot;).</source>
          <target state="translated">测试 &lt;code&gt;long double&lt;/code&gt; 是否由 &lt;code&gt;printf&lt;/code&gt; 正确格式化。不带参数-测试值硬连线到函数中（如&amp;ldquo; 7&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="c0fd920652142c713f4086b5b623b0b9e9398272" translate="yes" xml:space="preserve">
          <source>Test that a double-precision floating point number is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">测试 &lt;code&gt;printf&lt;/code&gt; 是否正确格式化了双精度浮点数。</target>
        </trans-unit>
        <trans-unit id="aa8f9b4911bc55fcaaec09b2bda811ea7944f490" translate="yes" xml:space="preserve">
          <source>Test that a single-precision floating point number is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">测试 &lt;code&gt;printf&lt;/code&gt; 是否正确格式化了单精度浮点数。</target>
        </trans-unit>
        <trans-unit id="2b615cea701e2b923c5f71779b58c9f119e965fa" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;IV&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">测试 &lt;code&gt;printf&lt;/code&gt; 是否正确格式化了 &lt;code&gt;IV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb28175623956ac2c7f684099558f1e73fc257b6" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;NV&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">测试是否已通过 &lt;code&gt;printf&lt;/code&gt; 正确格式化了 &lt;code&gt;NV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb348ab3a2e878a4d2162fc950e38514289fa424" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;UV&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">测试 &lt;code&gt;printf&lt;/code&gt; 是否正确格式化了 &lt;code&gt;UV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62afa7b2c53f556142fec29768d4906ba6d2d520" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;int&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">测试 &lt;code&gt;int&lt;/code&gt; 是否由 &lt;code&gt;printf&lt;/code&gt; 正确格式化。</target>
        </trans-unit>
        <trans-unit id="9b3320bceb2035430c2e25314087b45b576a7104" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;long&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">测试 &lt;code&gt;long&lt;/code&gt; 是否由 &lt;code&gt;printf&lt;/code&gt; 正确格式化。</target>
        </trans-unit>
        <trans-unit id="5a8692c5f618e42142701d067170ebb338d0f048" translate="yes" xml:space="preserve">
          <source>Test that the given &lt;code&gt;pv&lt;/code&gt; (with length &lt;code&gt;len&lt;/code&gt;) doesn't contain any internal &lt;code&gt;NUL&lt;/code&gt; characters. If it does, set &lt;code&gt;errno&lt;/code&gt; to &lt;code&gt;ENOENT&lt;/code&gt;, optionally warn using the &lt;code&gt;syscalls&lt;/code&gt; category, and return FALSE.</source>
          <target state="translated">测试给定的 &lt;code&gt;pv&lt;/code&gt; （长度为 &lt;code&gt;len&lt;/code&gt; ）是否不包含任何内部 &lt;code&gt;NUL&lt;/code&gt; 字符。如果是这样，请将 &lt;code&gt;errno&lt;/code&gt; 设置为 &lt;code&gt;ENOENT&lt;/code&gt; ，可以选择使用 &lt;code&gt;syscalls&lt;/code&gt; 类别进行警告，然后返回FALSE。</target>
        </trans-unit>
        <trans-unit id="c743b9b50bdf1cbd4320751b7b3e3e77099e55b4" translate="yes" xml:space="preserve">
          <source>Test that the given &lt;code&gt;pv&lt;/code&gt; doesn't contain any internal &lt;code&gt;NUL&lt;/code&gt; characters. If it does, set &lt;code&gt;errno&lt;/code&gt; to ENOENT, optionally warn, and return FALSE.</source>
          <target state="translated">测试给定的 &lt;code&gt;pv&lt;/code&gt; 不包含任何内部 &lt;code&gt;NUL&lt;/code&gt; 字符。如果是这样，请将 &lt;code&gt;errno&lt;/code&gt; 设置为ENOENT，可以选择发出警告，然后返回FALSE。</target>
        </trans-unit>
        <trans-unit id="935dc1f2c1449831bdafed1f538dec539127ac6a" translate="yes" xml:space="preserve">
          <source>Test the manual</source>
          <target state="translated">测试手册</target>
        </trans-unit>
        <trans-unit id="e8e7a9e15ab34cf742c942e50d6aff3c06043d08" translate="yes" xml:space="preserve">
          <source>Test the perl C API</source>
          <target state="translated">测试perl C API</target>
        </trans-unit>
        <trans-unit id="1cda04f681171086e794af0b5d23d5d5ea0b6cdd" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if the first, &lt;code&gt;s1&lt;/code&gt;, is greater than or equal to the second, &lt;code&gt;s2&lt;/code&gt;. Returns true or false.</source>
          <target state="translated">测试两个以 &lt;code&gt;NUL&lt;/code&gt; 结尾的字符串，以查看第一个 &lt;code&gt;s1&lt;/code&gt; 是否大于或等于第二个 &lt;code&gt;s2&lt;/code&gt; 。返回true或false。</target>
        </trans-unit>
        <trans-unit id="08a2e1515505333499048cba86227c80971a3aef" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if the first, &lt;code&gt;s1&lt;/code&gt;, is greater than the second, &lt;code&gt;s2&lt;/code&gt;. Returns true or false.</source>
          <target state="translated">测试两个以 &lt;code&gt;NUL&lt;/code&gt; 结尾的字符串，以查看第一个 &lt;code&gt;s1&lt;/code&gt; 是否大于第二个 &lt;code&gt;s2&lt;/code&gt; 。返回true或false。</target>
        </trans-unit>
        <trans-unit id="7397a89d009fad58a08d3b40bff3d58047b11288" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if the first, &lt;code&gt;s1&lt;/code&gt;, is less than or equal to the second, &lt;code&gt;s2&lt;/code&gt;. Returns true or false.</source>
          <target state="translated">测试两个以 &lt;code&gt;NUL&lt;/code&gt; 结尾的字符串，以查看第一个 &lt;code&gt;s1&lt;/code&gt; 是否小于或等于第二个 &lt;code&gt;s2&lt;/code&gt; 。返回true或false。</target>
        </trans-unit>
        <trans-unit id="97a4b766ad17990b550cf6d6e46e8c56bae5a196" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if the first, &lt;code&gt;s1&lt;/code&gt;, is less than the second, &lt;code&gt;s2&lt;/code&gt;. Returns true or false.</source>
          <target state="translated">测试两个以 &lt;code&gt;NUL&lt;/code&gt; 结尾的字符串，以查看第一个字符串 &lt;code&gt;s1&lt;/code&gt; 是否小于第二个字符串 &lt;code&gt;s2&lt;/code&gt; 。返回true或false。</target>
        </trans-unit>
        <trans-unit id="c67520e6cf1cb4f8414cc48c33fe0e43d736ba00" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if they are different. Returns true or false.</source>
          <target state="translated">测试两个 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串，看它们是否不同。返回true或false。</target>
        </trans-unit>
        <trans-unit id="e07ce0712b3cc2e909c79e8b8e4be508ac97e959" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if they are different. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt;).</source>
          <target state="translated">测试两个 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串，看它们是否不同。该 &lt;code&gt;len&lt;/code&gt; 参数指示字节比较的数量。返回true或false。（ &lt;code&gt;strncmp&lt;/code&gt; 的包装器）。</target>
        </trans-unit>
        <trans-unit id="7a0d79dd5feda7353def275a91909ef78bf53ffc" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if they are equal. Returns true or false.</source>
          <target state="translated">测试两个 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串，看它们是否相等。返回true或false。</target>
        </trans-unit>
        <trans-unit id="1b1fdf525381a678ac204c899e59ed1ee66b437b" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt;).</source>
          <target state="translated">测试两个 &lt;code&gt;NUL&lt;/code&gt; 终止的字符串，看它们是否相等。该 &lt;code&gt;len&lt;/code&gt; 参数指示字节比较的数量。返回true或false。（ &lt;code&gt;strncmp&lt;/code&gt; 的包装器）。</target>
        </trans-unit>
        <trans-unit id="8c712f8219cebd35791babf9ed3b703a8351ea8b" translate="yes" xml:space="preserve">
          <source>Test two buffers (which may contain embedded &lt;code&gt;NUL&lt;/code&gt; characters, to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns zero if equal, or non-zero if non-equal.</source>
          <target state="translated">测试两个缓冲区（其中可能包含嵌入的 &lt;code&gt;NUL&lt;/code&gt; 字符，以查看它们是否相等 &lt;code&gt;len&lt;/code&gt; 参数指示要比较的字节数。如果相等，则返回零；如果不相等，则返回非零。</target>
        </trans-unit>
        <trans-unit id="aa66181e4ff9ebce0ccdea0d81358cf4b122fa39" translate="yes" xml:space="preserve">
          <source>Test two buffers (which may contain embedded &lt;code&gt;NUL&lt;/code&gt; characters, to see if they are not equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns zero if non-equal, or non-zero if equal.</source>
          <target state="translated">测试两个缓冲区（其中可能包含嵌入式 &lt;code&gt;NUL&lt;/code&gt; 字符，以查看它们是否不相等 &lt;code&gt;len&lt;/code&gt; 参数指示要比较的字节数。如果不相等，则返回零；如果相等，则返回非零。</target>
        </trans-unit>
        <trans-unit id="7588b6c061b826b0f7a0fe2738aa760c611f4b7d" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is greater than or equal to the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">测试两个字符串，以查看第一个字符串 &lt;code&gt;s1&lt;/code&gt; 是否大于或等于第二个字符串 &lt;code&gt;s2&lt;/code&gt; 。返回true或false。</target>
        </trans-unit>
        <trans-unit id="960024a856f809dce4509cd90004cd8da3ca6ba1" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is greater than the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">测试两个字符串，以查看第一个字符串 &lt;code&gt;s1&lt;/code&gt; 是否大于第二个字符串 &lt;code&gt;s2&lt;/code&gt; 。返回true或false。</target>
        </trans-unit>
        <trans-unit id="ee2367cd81142917d4f07c520dafb2f8d390eb84" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is less than or equal to the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">测试两个字符串，以查看第一个字符串 &lt;code&gt;s1&lt;/code&gt; 是否小于或等于第二个字符串 &lt;code&gt;s2&lt;/code&gt; 。返回true或false。</target>
        </trans-unit>
        <trans-unit id="57ddc2e399365a286280a07fe9ed50d6bfa9604c" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is less than the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">测试两个字符串，以查看第一个字符串 &lt;code&gt;s1&lt;/code&gt; 是否小于第二个字符串 &lt;code&gt;s2&lt;/code&gt; 。返回true或false。</target>
        </trans-unit>
        <trans-unit id="237ab8c0b99038db78a7c54fb0bfdbb2ab764cbb" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are different. Returns true or false.</source>
          <target state="translated">测试两个字符串是否不同。返回true或false。</target>
        </trans-unit>
        <trans-unit id="fb2934866aafd7ff65638c4caf1d299244cb4e65" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are different. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt; ).</source>
          <target state="translated">测试两个字符串以查看它们是否不同。该 &lt;code&gt;len&lt;/code&gt; 参数指示字节比较的数量。返回true或false。（ &lt;code&gt;strncmp&lt;/code&gt; 的包装器）。</target>
        </trans-unit>
        <trans-unit id="44326cf741b4ea53c3861e1c04224785c2787564" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are equal. Returns true or false.</source>
          <target state="translated">测试两个字符串是否相等。返回true或false。</target>
        </trans-unit>
        <trans-unit id="f0b60c1b2d7c48750566bd13231437cae4745024" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt; ).</source>
          <target state="translated">测试两个字符串，看它们是否相等。该 &lt;code&gt;len&lt;/code&gt; 参数指示字节比较的数量。返回true或false。（ &lt;code&gt;strncmp&lt;/code&gt; 的包装器）。</target>
        </trans-unit>
        <trans-unit id="5ea556cadafc54f605e5e63d55b8b6c8576ae334" translate="yes" xml:space="preserve">
          <source>Test your change</source>
          <target state="translated">测试你的变化</target>
        </trans-unit>
        <trans-unit id="368b5822e8d2728701a3f8f8b37d0363f9573092" translate="yes" xml:space="preserve">
          <source>Test.pl</source>
          <target state="translated">Test.pl</target>
        </trans-unit>
        <trans-unit id="2b84f621c0fd4ba8bd514c5c43ab9a897c8c014e" translate="yes" xml:space="preserve">
          <source>Test2</source>
          <target state="translated">Test2</target>
        </trans-unit>
        <trans-unit id="eda8c363c27f97460f067dbb6abdfc09dc29c0c8" translate="yes" xml:space="preserve">
          <source>Test2 - Framework for writing test tools that all work together.</source>
          <target state="translated">Test2-编写测试工具的框架,这些工具可以一起工作。</target>
        </trans-unit>
        <trans-unit id="a7914da6063f1d3eee08e8be56ecff6a038d13b7" translate="yes" xml:space="preserve">
          <source>Test2 based tools produce events which get passed through a processing system before being output by a formatter. This event system allows for rich plugin and extension support.</source>
          <target state="translated">基于Test2的工具会产生事件,这些事件在被格式化输出之前会通过一个处理系统。这个事件系统允许丰富的插件和扩展支持。</target>
        </trans-unit>
        <trans-unit id="398a86dff1e296880e5d0b4d74bd2ff1122d7b20" translate="yes" xml:space="preserve">
          <source>Test2 is a new testing framework produced by forking &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;, completely refactoring it, adding many new features and capabilities.</source>
          <target state="translated">Test2是一个新的测试框架，它通过分叉&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder生成&lt;/a&gt;，完全对其进行了重构，并添加了许多新功能。</target>
        </trans-unit>
        <trans-unit id="84ec663be5e2702eeee07b6691bdb59dd7f152b6" translate="yes" xml:space="preserve">
          <source>Test2 support for forking and threading can be turned on using &lt;a href=&quot;Test2::IPC&quot;&gt;Test2::IPC&lt;/a&gt;. Once turned on threading and forking operate sanely and work as one would expect.</source>
          <target state="translated">可以使用&lt;a href=&quot;Test2::IPC&quot;&gt;Test2 :: IPC&lt;/a&gt;来打开对分叉和线程的Test2支持。一旦启用，线程和分支将正常运行并按预期工作。</target>
        </trans-unit>
        <trans-unit id="85c00e9e770edcdcec782d15abea07abe8e90329" translate="yes" xml:space="preserve">
          <source>Test2 uses an &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt; object to track filename, line number, and tool details. This object greatly simplifies tracking for where errors should be reported.</source>
          <target state="translated">Test2使用&lt;a href=&quot;Test2::API::Context&quot;&gt;Test2 :: API :: Context&lt;/a&gt;对象跟踪文件名，行号和工具详细信息。此对象极大地简化了对应报告错误的位置的跟踪。</target>
        </trans-unit>
        <trans-unit id="e285ff9d0222e729d45ac11b2fa114520dbd2f49" translate="yes" xml:space="preserve">
          <source>Test2::</source>
          <target state="translated">Test2::</target>
        </trans-unit>
        <trans-unit id="aed608f477d17069118048380cb834a46100702e" translate="yes" xml:space="preserve">
          <source>Test2::API</source>
          <target state="translated">Test2::API</target>
        </trans-unit>
        <trans-unit id="b64e44401f91aa4335033516e0e358ab2918bb91" translate="yes" xml:space="preserve">
          <source>Test2::API - Primary interface for writing Test2 based testing tools.</source>
          <target state="translated">Test2::API-用于编写基于Test2的测试工具的主要接口。</target>
        </trans-unit>
        <trans-unit id="efd3f4fa6597ae4905596818a71dd6f194f5a192" translate="yes" xml:space="preserve">
          <source>Test2::API::</source>
          <target state="translated">Test2::API::</target>
        </trans-unit>
        <trans-unit id="823aa9e1a97b79904e6a3b276b63d70ac1eaf933" translate="yes" xml:space="preserve">
          <source>Test2::API::Breakage</source>
          <target state="translated">Test2::API::Breakage</target>
        </trans-unit>
        <trans-unit id="0861d9570e8c51fbb90b7b320182f504e2357c33" translate="yes" xml:space="preserve">
          <source>Test2::API::Breakage - What breaks at what version</source>
          <target state="translated">Test2::API::Breakage-在什么版本上出现了什么问题?</target>
        </trans-unit>
        <trans-unit id="5c2ccf18a794e7b19dd498228e83500720827311" translate="yes" xml:space="preserve">
          <source>Test2::API::Context</source>
          <target state="translated">Test2::API::Context</target>
        </trans-unit>
        <trans-unit id="6392ed68dbc48f41c56e98e3b78066ea6fd6f6e7" translate="yes" xml:space="preserve">
          <source>Test2::API::Context - Object to represent a testing context.</source>
          <target state="translated">Test2::API::Context-表示测试上下文的对象。</target>
        </trans-unit>
        <trans-unit id="8928930b42eb0f1f15f9f1786db57584d36450f7" translate="yes" xml:space="preserve">
          <source>Test2::API::Instance</source>
          <target state="translated">Test2::API::Instance</target>
        </trans-unit>
        <trans-unit id="e9d71ad619dcb1f03cb3d047e079b7b873049690" translate="yes" xml:space="preserve">
          <source>Test2::API::Instance - Object used by Test2::API under the hood</source>
          <target state="translated">Test2::API::Instance-Test2::API使用的对象。</target>
        </trans-unit>
        <trans-unit id="8c4ef69b915bbedef7a6aa2e3dfda1acb8e00023" translate="yes" xml:space="preserve">
          <source>Test2::API::Stack</source>
          <target state="translated">Test2::API::Stack</target>
        </trans-unit>
        <trans-unit id="db39e7f918f59026c6ba1b1479540073a74dbe65" translate="yes" xml:space="preserve">
          <source>Test2::API::Stack - Object to manage a stack of &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt; instances.</source>
          <target state="translated">Test2 :: API :: Stack-用于管理&lt;a href=&quot;Test2::Hub&quot;&gt;Test2 :: Hub&lt;/a&gt;实例堆栈的对象。</target>
        </trans-unit>
        <trans-unit id="4066ca94daf4532238cf36f016b1d069a5ab7793" translate="yes" xml:space="preserve">
          <source>Test2::Bundle::</source>
          <target state="translated">Test2::Bundle::</target>
        </trans-unit>
        <trans-unit id="f57cc1ec8f9d37fc1b16d1973aeb44165f00421d" translate="yes" xml:space="preserve">
          <source>Test2::Event</source>
          <target state="translated">Test2::Event</target>
        </trans-unit>
        <trans-unit id="c7ab55a64912c0845c79bb212cfd817d09025066" translate="yes" xml:space="preserve">
          <source>Test2::Event - Base class for events</source>
          <target state="translated">Test2::Event-事件的基类。</target>
        </trans-unit>
        <trans-unit id="8a208964b54ed95543dd315c416ecedfe690fe40" translate="yes" xml:space="preserve">
          <source>Test2::Event::</source>
          <target state="translated">Test2::Event::</target>
        </trans-unit>
        <trans-unit id="222da9b43da2c10e075571dbaaecb7acb8971f5c" translate="yes" xml:space="preserve">
          <source>Test2::Event::Bail</source>
          <target state="translated">Test2::Event::Bail</target>
        </trans-unit>
        <trans-unit id="c6639f4ee1d50a38a83d0aa08dbfdceab90fd9da" translate="yes" xml:space="preserve">
          <source>Test2::Event::Bail - Bailout!</source>
          <target state="translated">Test2::Event::Bail-Bailout!</target>
        </trans-unit>
        <trans-unit id="aa3e3ba5854331919870c8337d909e52e4a076b8" translate="yes" xml:space="preserve">
          <source>Test2::Event::Diag</source>
          <target state="translated">Test2::Event::Diag</target>
        </trans-unit>
        <trans-unit id="dccbb51341c8ea96ae5a977ee141eea8bc86dbe4" translate="yes" xml:space="preserve">
          <source>Test2::Event::Diag - Diag event type</source>
          <target state="translated">Test2::Event::Diag-Diag事件类型</target>
        </trans-unit>
        <trans-unit id="6b8ebae9408bcb7bc43915bb7a2b06de25a46dec" translate="yes" xml:space="preserve">
          <source>Test2::Event::Encoding</source>
          <target state="translated">Test2::Event::Encoding</target>
        </trans-unit>
        <trans-unit id="38074f2997521b7c59670e4af13f02f3260f0037" translate="yes" xml:space="preserve">
          <source>Test2::Event::Encoding - Set the encoding for the output stream</source>
          <target state="translated">Test2::Event::Encoding-设置输出流的编码。</target>
        </trans-unit>
        <trans-unit id="75cdd65e18d257d6b093ce75ab07ea83b0a1f0f3" translate="yes" xml:space="preserve">
          <source>Test2::Event::Exception</source>
          <target state="translated">Test2::Event::Exception</target>
        </trans-unit>
        <trans-unit id="4701028ce3df2eea964013cdb647d8bf16f01e39" translate="yes" xml:space="preserve">
          <source>Test2::Event::Exception - Exception event</source>
          <target state="translated">Test2::Event::Exception-异常事件。</target>
        </trans-unit>
        <trans-unit id="213b2187e0041e341c0be41fb190191567647040" translate="yes" xml:space="preserve">
          <source>Test2::Event::Fail</source>
          <target state="translated">Test2::Event::Fail</target>
        </trans-unit>
        <trans-unit id="aa94f0e56a9c0ead034b1b33c0cc1605dfbd21ef" translate="yes" xml:space="preserve">
          <source>Test2::Event::Fail - Event for a simple failed assertion</source>
          <target state="translated">Test2::Event::Fail-一个简单的失败断言事件。</target>
        </trans-unit>
        <trans-unit id="6fe59b86d85778b040125f222a3d01e10a712a40" translate="yes" xml:space="preserve">
          <source>Test2::Event::Generic</source>
          <target state="translated">Test2::Event::Generic</target>
        </trans-unit>
        <trans-unit id="dd44b53a7b2f21504f4c3cdcdd24bf5b428034bb" translate="yes" xml:space="preserve">
          <source>Test2::Event::Generic - Generic event type.</source>
          <target state="translated">Test2::Event::Generic-通用事件类型。</target>
        </trans-unit>
        <trans-unit id="5232466de0a182c8ac4368fe4af490d4cec125c5" translate="yes" xml:space="preserve">
          <source>Test2::Event::Note</source>
          <target state="translated">Test2::Event::Note</target>
        </trans-unit>
        <trans-unit id="2110f8724d8546b8c1bc6d82d78c7a0be5217629" translate="yes" xml:space="preserve">
          <source>Test2::Event::Note - Note event type</source>
          <target state="translated">Test2::Event::Note-Note事件类型</target>
        </trans-unit>
        <trans-unit id="413b4924db2b9633fc53631d16b5f8d56d2a8ec5" translate="yes" xml:space="preserve">
          <source>Test2::Event::Ok</source>
          <target state="translated">Test2::Event::Ok</target>
        </trans-unit>
        <trans-unit id="d26917c93a4a1ca59d02bfdcd1ca1e882315f897" translate="yes" xml:space="preserve">
          <source>Test2::Event::Ok - Ok event type</source>
          <target state="translated">Test2::Event::Ok-Ok事件类型</target>
        </trans-unit>
        <trans-unit id="e8166088489a5bc91739c87f976810c6ecf6646a" translate="yes" xml:space="preserve">
          <source>Test2::Event::Pass</source>
          <target state="translated">Test2::Event::Pass</target>
        </trans-unit>
        <trans-unit id="e2c3f6ccdfd606b354f26fb929f5aa4379851e17" translate="yes" xml:space="preserve">
          <source>Test2::Event::Pass - Event for a simple passing assertion</source>
          <target state="translated">Test2::Event::Pass-用于简单传递断言的事件。</target>
        </trans-unit>
        <trans-unit id="2baa0f71c7bde397357a6a05ab0a4b2170b6e32a" translate="yes" xml:space="preserve">
          <source>Test2::Event::Plan</source>
          <target state="translated">Test2::Event::Plan</target>
        </trans-unit>
        <trans-unit id="333336f9de46850c8a8c5e170a7fcf9c57fb3486" translate="yes" xml:space="preserve">
          <source>Test2::Event::Plan - The event of a plan</source>
          <target state="translated">Test2::Event::Plan-计划的事件。</target>
        </trans-unit>
        <trans-unit id="2f279cfd9072e8f5890e09755a89a14ab46a9338" translate="yes" xml:space="preserve">
          <source>Test2::Event::Skip</source>
          <target state="translated">Test2::Event::Skip</target>
        </trans-unit>
        <trans-unit id="523d29ebe5be339549d30bbd996c98332c98058b" translate="yes" xml:space="preserve">
          <source>Test2::Event::Skip - Skip event type</source>
          <target state="translated">Test2::Event::Skip-跳过事件类型。</target>
        </trans-unit>
        <trans-unit id="0daedf830e1bee09f664aaa317a6afed11518990" translate="yes" xml:space="preserve">
          <source>Test2::Event::Subtest</source>
          <target state="translated">Test2::Event::Subtest</target>
        </trans-unit>
        <trans-unit id="f8e158cbc6534e5249fe882a4e9a0da5cc30a140" translate="yes" xml:space="preserve">
          <source>Test2::Event::Subtest - Event for subtest types</source>
          <target state="translated">Test2::Event::Subtest-子测试类型的事件。</target>
        </trans-unit>
        <trans-unit id="bb06c64fdc632db67dc9bffd6c588a6a624ce76a" translate="yes" xml:space="preserve">
          <source>Test2::Event::TAP::Version</source>
          <target state="translated">Test2::Event::TAP::Version</target>
        </trans-unit>
        <trans-unit id="1c62f8d2de6366a8d87dd20fc3501e28352856dd" translate="yes" xml:space="preserve">
          <source>Test2::Event::TAP::Version - Event for TAP version.</source>
          <target state="translated">Test2::Event::TAP::Version-TAP版本的事件。</target>
        </trans-unit>
        <trans-unit id="adbc479c6c5dbbd07debac51d2e47f71debe301b" translate="yes" xml:space="preserve">
          <source>Test2::Event::V2</source>
          <target state="translated">Test2::Event::V2</target>
        </trans-unit>
        <trans-unit id="5d24bd5feb73d8653a7b629d67988cafd589322b" translate="yes" xml:space="preserve">
          <source>Test2::Event::V2 - Second generation event.</source>
          <target state="translated">Test2::Event::V2-第二代事件。</target>
        </trans-unit>
        <trans-unit id="e16dd367cf4872654a6dce5ce401595d087cd64a" translate="yes" xml:space="preserve">
          <source>Test2::Event::Waiting</source>
          <target state="translated">Test2::Event::Waiting</target>
        </trans-unit>
        <trans-unit id="db005487809f2d8acd788bd2d2dc8b6a91556697" translate="yes" xml:space="preserve">
          <source>Test2::Event::Waiting - Tell all procs/threads it is time to be done</source>
          <target state="translated">Test2::Event::Waiting-告诉所有的procs/线程该结束了。</target>
        </trans-unit>
        <trans-unit id="b43b423903d35c0f3149a55b5aa7482144c6e821" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet</source>
          <target state="translated">Test2::EventFacet</target>
        </trans-unit>
        <trans-unit id="c11dcded6ce506a6e2d04a5f680ab6b7c80a91eb" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet - Base class for all event facets.</source>
          <target state="translated">Test2::EventFacet-所有事件面的基础类。</target>
        </trans-unit>
        <trans-unit id="8d94b66b18c3d8c49c0f173453f4e670dd80f895" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::About</source>
          <target state="translated">Test2::EventFacet::About</target>
        </trans-unit>
        <trans-unit id="a7424501dd01bcb804f3da012e536a50271a2499" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::About - Facet with event details.</source>
          <target state="translated">Test2::EventFacet::About-包含事件细节的Facet。</target>
        </trans-unit>
        <trans-unit id="7721bca6966ae188d61ed02c3583a52be94f3308" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Amnesty</source>
          <target state="translated">Test2::EventFacet::Amnesty</target>
        </trans-unit>
        <trans-unit id="75a05106886d311b44b3bdfccd8778e0c3f3f498" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Amnesty - Facet for assertion amnesty.</source>
          <target state="translated">Test2::EventFacet::Amnesty-用于断言大赦的Facet。</target>
        </trans-unit>
        <trans-unit id="7f0d1e162c4b6553c9b71ed64f5b8b1f9ed0917c" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Assert</source>
          <target state="translated">Test2::EventFacet::Assert</target>
        </trans-unit>
        <trans-unit id="7920cf94c19ae0f16a489d74a6da88912a69561f" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Assert - Facet representing an assertion.</source>
          <target state="translated">Test2::EventFacet::Assert-代表断言的面片。</target>
        </trans-unit>
        <trans-unit id="0154d814220406d368d99e18a174a4dddfb3bcd5" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Control</source>
          <target state="translated">Test2::EventFacet::Control</target>
        </trans-unit>
        <trans-unit id="5bcc831f6a254f05cbb0f0fadb63ba1c90548e4a" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Control - Facet for hub actions and behaviors.</source>
          <target state="translated">Test2::EventFacet::Control-用于集线器动作和行为的Facet。</target>
        </trans-unit>
        <trans-unit id="b62ade42351eb9bb31e48e3b2e93713fe6baeef8" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Error</source>
          <target state="translated">Test2::EventFacet::Error</target>
        </trans-unit>
        <trans-unit id="94ed284eb9c51ff089cc0a134463bf0d7a5d9b9b" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Error - Facet for errors that need to be shown.</source>
          <target state="translated">Test2::EventFacet::Error-需要显示的错误的面。</target>
        </trans-unit>
        <trans-unit id="0b0f76e55accd6e82edf385f2c62f6f3fe2ff466" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Hub</source>
          <target state="translated">Test2::EventFacet::Hub</target>
        </trans-unit>
        <trans-unit id="ccf5d98be7eb2630ce4c2c621f114c26ae3ab3b1" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Hub - Facet for the hubs an event passes through.</source>
          <target state="translated">Test2::EventFacet::Hub-事件所经过的集线器的面。</target>
        </trans-unit>
        <trans-unit id="a3ac4e48a99349567b0a89ac444d73d09d49cdd1" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Info</source>
          <target state="translated">Test2::EventFacet::Info</target>
        </trans-unit>
        <trans-unit id="531a04a3d9a3002254fb82228c4742a0058169ae" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Info - Facet for information a developer might care about.</source>
          <target state="translated">Test2::EventFacet::Info-开发者可能关心的信息面。</target>
        </trans-unit>
        <trans-unit id="7657cf6e0d3cbe826429bd19cce6329342e8371e" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Info::Table</source>
          <target state="translated">Test2::EventFacet::Info::Table</target>
        </trans-unit>
        <trans-unit id="919c466811c6c1ce82b3d1a77373a5994bc4ad1d" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Info::Table - Intermediary representation of a table.</source>
          <target state="translated">Test2::EventFacet::Info::Table-表的中介表示。</target>
        </trans-unit>
        <trans-unit id="9e10762a18172dac09cb1485390bf5a8c468e654" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Meta</source>
          <target state="translated">Test2::EventFacet::Meta</target>
        </trans-unit>
        <trans-unit id="15764a4129b9ed520f0a3054a182ad077401eb37" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Meta - Facet for meta-data</source>
          <target state="translated">Test2::EventFacet::Meta-用于元数据的Facet。</target>
        </trans-unit>
        <trans-unit id="48ba28b1fef317b322342598dd7b5b1f2a0bfed2" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Parent</source>
          <target state="translated">Test2::EventFacet::Parent</target>
        </trans-unit>
        <trans-unit id="fc580dac3b702094a3a37054e781da56753a8202" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Parent - Facet for events contains other events</source>
          <target state="translated">Test2::EventFacet::Parent-事件的Facet包含其他事件。</target>
        </trans-unit>
        <trans-unit id="f017f4ef4b9f563bbf579d69dd0b07d01d083216" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Plan</source>
          <target state="translated">Test2::EventFacet::Plan</target>
        </trans-unit>
        <trans-unit id="1b853027bef935f244330f0dd4212616d550dd50" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Plan - Facet for setting the plan</source>
          <target state="translated">Test2::EventFacet::Plan-用于设置计划的面。</target>
        </trans-unit>
        <trans-unit id="b5beff3ccc1dfe7e21a8d1577127506388549038" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Render</source>
          <target state="translated">Test2::EventFacet::Render</target>
        </trans-unit>
        <trans-unit id="8fdb0b599c005170ba486c3ab26ed301b039dad4" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Render - Facet that dictates how to render an event.</source>
          <target state="translated">Test2::EventFacet::Render-决定如何渲染一个事件的面。</target>
        </trans-unit>
        <trans-unit id="f454a15df1938741674595a2355fd8747d3246c4" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Trace</source>
          <target state="translated">Test2::EventFacet::Trace</target>
        </trans-unit>
        <trans-unit id="68b35a88e0341af14e6394c735722451fceca859" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Trace - Debug information for events</source>
          <target state="translated">Test2::EventFacet::Trace-事件的调试信息。</target>
        </trans-unit>
        <trans-unit id="22810101357ee04450379aa51c30db96603d1bc0" translate="yes" xml:space="preserve">
          <source>Test2::Formatter</source>
          <target state="translated">Test2::Formatter</target>
        </trans-unit>
        <trans-unit id="24090f00c8f368b00c6a6e3049b282ad6483fd26" translate="yes" xml:space="preserve">
          <source>Test2::Formatter - Namespace for formatters.</source>
          <target state="translated">Test2::Formatter-formatters 的命名空间。</target>
        </trans-unit>
        <trans-unit id="3d7ad9843e47802da1064f10a6ed0f941b4c6996" translate="yes" xml:space="preserve">
          <source>Test2::Formatter::</source>
          <target state="translated">Test2::Formatter::</target>
        </trans-unit>
        <trans-unit id="d8aebf053e28ed7412794daf98128ef12f654d34" translate="yes" xml:space="preserve">
          <source>Test2::Formatter::TAP</source>
          <target state="translated">Test2::Formatter::TAP</target>
        </trans-unit>
        <trans-unit id="46b4d5b6e41ec7c63f10f2b81b8d25b6ad48c467" translate="yes" xml:space="preserve">
          <source>Test2::Formatter::TAP - Standard TAP formatter</source>
          <target state="translated">Test2::Formatter::TAP-标准的TAP格式化。</target>
        </trans-unit>
        <trans-unit id="eec1636c628a393391f1bd9b891d1aac73f6842e" translate="yes" xml:space="preserve">
          <source>Test2::Hub</source>
          <target state="translated">Test2::Hub</target>
        </trans-unit>
        <trans-unit id="9ef2e13502d5f0974e131f5f83a726361d1b54dd" translate="yes" xml:space="preserve">
          <source>Test2::Hub - The conduit through which all events flow.</source>
          <target state="translated">Test2::Hub-所有事件流动的管道。</target>
        </trans-unit>
        <trans-unit id="17e83b628262986793f10b10b71b5803fa827b55" translate="yes" xml:space="preserve">
          <source>Test2::Hub::</source>
          <target state="translated">Test2::Hub::</target>
        </trans-unit>
        <trans-unit id="d987d21918e08ef541654a1bdfad5ccaedf59e4f" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Interceptor</source>
          <target state="translated">Test2::Hub::Interceptor</target>
        </trans-unit>
        <trans-unit id="259de78dc48b81a26c6c8f30e8cd739349d3c52a" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Interceptor - Hub used by interceptor to grab results.</source>
          <target state="translated">Test2::Hub::Interceptor-拦截器用来抓取结果的枢纽。</target>
        </trans-unit>
        <trans-unit id="5bfea7d0c04ab6a462bbac2592d6b16be7ef2d79" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Interceptor::Terminator</source>
          <target state="translated">Test2::Hub::Interceptor::Terminator</target>
        </trans-unit>
        <trans-unit id="060da97eee8500d95c5711415f3dc7a4d015f4e9" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Interceptor::Terminator - Exception class used by Test2::Hub::Interceptor</source>
          <target state="translated">Test2::Hub::Interceptor::Terminator-Test2::Hub::Interceptor使用的异常类。</target>
        </trans-unit>
        <trans-unit id="3808bc674ba623811b11d43abef5d54200006dc8" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Subtest</source>
          <target state="translated">Test2::Hub::Subtest</target>
        </trans-unit>
        <trans-unit id="daea2dc40ad5baee611aefac07d76a5653258a74" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Subtest - Hub used by subtests</source>
          <target state="translated">Test2::Hub::Subtest-子测试所使用的枢纽。</target>
        </trans-unit>
        <trans-unit id="7e8f1da2d2d8e1dfdea6539c7c3b6cde2e255e80" translate="yes" xml:space="preserve">
          <source>Test2::IPC</source>
          <target state="translated">Test2::IPC</target>
        </trans-unit>
        <trans-unit id="259b7962c108b108b99848b7164604ace25b603c" translate="yes" xml:space="preserve">
          <source>Test2::IPC - Turn on IPC for threading or forking support.</source>
          <target state="translated">Test2::IPC-打开 IPC 以支持线程或分叉。</target>
        </trans-unit>
        <trans-unit id="5bae70236953a3ba88d368a2555897a3a683c900" translate="yes" xml:space="preserve">
          <source>Test2::IPC::</source>
          <target state="translated">Test2::IPC::</target>
        </trans-unit>
        <trans-unit id="2aa0e1ea9908aa1517ccfba9e9ebdec9f7fd42a9" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver</source>
          <target state="translated">Test2::IPC::Driver</target>
        </trans-unit>
        <trans-unit id="e89eb8d9a5b88689747eb6772d8891a3419ee002" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver - Base class for Test2 IPC drivers.</source>
          <target state="translated">Test2::IPC::Driver-Test2 IPC驱动的基础类。</target>
        </trans-unit>
        <trans-unit id="daa014e96987947baf8aa2b996530d5e78494607" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver has an &lt;code&gt;import()&lt;/code&gt; method. All drivers inherit this import method. This import method registers the driver.</source>
          <target state="translated">Test2 :: IPC :: Driver具有 &lt;code&gt;import()&lt;/code&gt; 方法。所有驱动程序都继承此导入方法。此导入方法注册驱动程序。</target>
        </trans-unit>
        <trans-unit id="6247baaa37b5aa0c0b858ebf17f525faa50a3a74" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver::</source>
          <target state="translated">Test2::IPC::Driver::</target>
        </trans-unit>
        <trans-unit id="df1632079981d93c731c27fbf0953b8c0110780f" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver::Files</source>
          <target state="translated">Test2::IPC::Driver::Files</target>
        </trans-unit>
        <trans-unit id="d766b8fd7d9bfdba9a657a1322fd6250e8131728" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver::Files - Temp dir + Files concurrency model.</source>
          <target state="translated">Test2::IPC::Driver::Files-Temp dir+Files并发模型。</target>
        </trans-unit>
        <trans-unit id="94b37bcccaea4a2ac8fe8762dc5b314baa0c51f3" translate="yes" xml:space="preserve">
          <source>Test2::Plugin::</source>
          <target state="translated">Test2::Plugin::</target>
        </trans-unit>
        <trans-unit id="d68f31cbce13d814ae88248b74be13195971bcb1" translate="yes" xml:space="preserve">
          <source>Test2::Require::</source>
          <target state="translated">Test2::Require::</target>
        </trans-unit>
        <trans-unit id="92e3f4464ca08722bdba5e6448503ce92bb9a7b7" translate="yes" xml:space="preserve">
          <source>Test2::Tools::</source>
          <target state="translated">Test2::Tools::</target>
        </trans-unit>
        <trans-unit id="9f1a4ef48602a8e2128f3a0e8099a06fc4b66142" translate="yes" xml:space="preserve">
          <source>Test2::Tools::Tiny</source>
          <target state="translated">Test2::Tools::Tiny</target>
        </trans-unit>
        <trans-unit id="79dcd377299ffd1fe20b0bcd73f822a0e9ace962" translate="yes" xml:space="preserve">
          <source>Test2::Tools::Tiny - Tiny set of tools for unfortunate souls who cannot use &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;.</source>
          <target state="translated">Test2 :: Tools :: Tiny-用于无法使用&lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite的&lt;/a&gt;不幸灵魂的微型工具集。</target>
        </trans-unit>
        <trans-unit id="90e2aa276cb0ac9a0d3011cd620cb67dae65f37b" translate="yes" xml:space="preserve">
          <source>Test2::Transition</source>
          <target state="translated">Test2::Transition</target>
        </trans-unit>
        <trans-unit id="c87fd265441b37b65c97051a7a8d33c3d3df3323" translate="yes" xml:space="preserve">
          <source>Test2::Transition - Transition notes when upgrading to Test2</source>
          <target state="translated">Test2::过渡-升级到Test2时的过渡说明</target>
        </trans-unit>
        <trans-unit id="e290a0acf731a8e4ae28c48d463af20b82b5a396" translate="yes" xml:space="preserve">
          <source>Test2::Util</source>
          <target state="translated">Test2::Util</target>
        </trans-unit>
        <trans-unit id="9916e2fd617bea077d82a5dd41a45672a41cb8fe" translate="yes" xml:space="preserve">
          <source>Test2::Util - Tools used by Test2 and friends.</source>
          <target state="translated">Test2::Util-Test2和朋友们使用的工具。</target>
        </trans-unit>
        <trans-unit id="df6eb9596151fedd72d3d41a6e72618282af596f" translate="yes" xml:space="preserve">
          <source>Test2::Util::</source>
          <target state="translated">Test2::Util::</target>
        </trans-unit>
        <trans-unit id="d73a9b09244115670914ff2509686dc192be586b" translate="yes" xml:space="preserve">
          <source>Test2::Util::ExternalMeta</source>
          <target state="translated">Test2::Util::ExternalMeta</target>
        </trans-unit>
        <trans-unit id="4ce376298fd6e6528e5f02c77d1d3b4e0a46cece" translate="yes" xml:space="preserve">
          <source>Test2::Util::ExternalMeta - Allow third party tools to safely attach meta-data to your instances.</source>
          <target state="translated">Test2::Util::ExternalMeta-允许第三方工具安全地将元数据附加到您的实例中。</target>
        </trans-unit>
        <trans-unit id="7604014ee8769c4f1c915fbdad0d5f25e9283637" translate="yes" xml:space="preserve">
          <source>Test2::Util::Facets2Legacy</source>
          <target state="translated">Test2::Util::Facets2Legacy</target>
        </trans-unit>
        <trans-unit id="8247e29b1a8250a4ea6c8a5f5a060d7f0399d878" translate="yes" xml:space="preserve">
          <source>Test2::Util::Facets2Legacy - Convert facet data to the legacy event API.</source>
          <target state="translated">Test2::Util::Facets2Legacy-将面数据转换为传统的事件API。</target>
        </trans-unit>
        <trans-unit id="0178a14e7a539df0e8eac67b9f265a91905f03e7" translate="yes" xml:space="preserve">
          <source>Test2::Util::HashBase</source>
          <target state="translated">Test2::Util::HashBase</target>
        </trans-unit>
        <trans-unit id="e3d53ed10a22c3962563aa98b744234fa941f302" translate="yes" xml:space="preserve">
          <source>Test2::Util::HashBase - Build hash based classes.</source>
          <target state="translated">Test2::Util::HashBase-构建基于哈希的类。</target>
        </trans-unit>
        <trans-unit id="304c4e0ff5d5cb770757f774f08ee2ed78611096" translate="yes" xml:space="preserve">
          <source>Test2::Util::HashBase provides a function for retrieving a list of attributes for an Test2::Util::HashBase class.</source>
          <target state="translated">Test2::Util::HashBase 提供了一个用于检索 Test2::Util::HashBase 类的属性列表的函数。</target>
        </trans-unit>
        <trans-unit id="8df7257ba0ff26dcc04c2983cb8974045fd2c82f" translate="yes" xml:space="preserve">
          <source>Test2::Util::Trace</source>
          <target state="translated">Test2::Util::Trace</target>
        </trans-unit>
        <trans-unit id="30e52b1d2e0031f38bdbbe2f1f65a20ef1bbc1b0" translate="yes" xml:space="preserve">
          <source>Test2::Util::Trace - Legacy wrapper fro &lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2::EventFacet::Trace&lt;/a&gt;.</source>
          <target state="translated">Test2 :: Util :: Trace-来自&lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2 :: EventFacet :: Trace的&lt;/a&gt;旧式包装器。</target>
        </trans-unit>
        <trans-unit id="2534f8dc09bc938850916623cc51a245fb3b04e8" translate="yes" xml:space="preserve">
          <source>Test::Able</source>
          <target state="translated">Test::Able</target>
        </trans-unit>
        <trans-unit id="1136a495270cb45dd3267352c039b37399d8bfdd" translate="yes" xml:space="preserve">
          <source>Test::Aggregate</source>
          <target state="translated">Test::Aggregate</target>
        </trans-unit>
        <trans-unit id="193904736b8940fdc2ba17861b0cc502cad2d12e" translate="yes" xml:space="preserve">
          <source>Test::Builder</source>
          <target state="translated">Test::Builder</target>
        </trans-unit>
        <trans-unit id="ab9974f668e2c6c0ffc2992746669dd361b94a4d" translate="yes" xml:space="preserve">
          <source>Test::Builder - Backend for building test libraries</source>
          <target state="translated">Test::Builder-用于构建测试库的后端。</target>
        </trans-unit>
        <trans-unit id="5111b242105d59084cb31e09df1b0f811c5f66e6" translate="yes" xml:space="preserve">
          <source>Test::Builder assumed everything would end up as TAP. Test2 makes no such assumption. Test2 provides ways for you to specify alternative and custom formatters.</source>
          <target state="translated">Test::Builder 假设所有的东西最后都会变成 TAP。Test2 不做这样的假设。Test2 为您提供了指定替代和自定义格式的方法。</target>
        </trans-unit>
        <trans-unit id="b3b54af1fc0cfa765b71e78e4e18039fd43150ca" translate="yes" xml:space="preserve">
          <source>Test::Builder is only thread-aware if threads.pm is loaded</source>
          <target state="translated">Test::Builder只有在加载了threads.pm的情况下才会有线程感知。</target>
        </trans-unit>
        <trans-unit id="882498aa0deee0eaf2786e1c013e62fc64bca99d" translate="yes" xml:space="preserve">
          <source>Test::Builder only provided a handful of methods for generating lines of TAP. Test2 took inventory of everything people were doing with Test::Builder that required hacking it up. Test2 made public API functions for nearly all the desired functionality people didn't previously have.</source>
          <target state="translated">Test::Builder只提供了少量的生成TAP行的方法。Test2 盘点了人们使用 Test::Builder 所做的一切需要黑客操作的事情。Test2为几乎所有人们之前没有的所需功能制作了公共API函数。</target>
        </trans-unit>
        <trans-unit id="60f281cea5cb958fbaba27c76fd1089904c4d2e8" translate="yes" xml:space="preserve">
          <source>Test::Builder subclass of Test2::Event::Diag</source>
          <target state="translated">Test::Builder是Test2::Event::Diag的子类。</target>
        </trans-unit>
        <trans-unit id="23e1fd996c21804da41e7fd365d9b5baae50ea4e" translate="yes" xml:space="preserve">
          <source>Test::Builder subclass of Test2::Formatter::TAP</source>
          <target state="translated">Test::Builder 是 Test2::Formatter::TAP 的子类。</target>
        </trans-unit>
        <trans-unit id="a49fdf2299317bf9d9dff7fce116cd0d0e8a3c2b" translate="yes" xml:space="preserve">
          <source>Test::Builder.</source>
          <target state="translated">Test::Builder.</target>
        </trans-unit>
        <trans-unit id="79c6ceab8e308a67e42d8cf4c5b83ab3491afc98" translate="yes" xml:space="preserve">
          <source>Test::Builder1.5/2 conditionals</source>
          <target state="translated">Test::Builder1.5/2条件。</target>
        </trans-unit>
        <trans-unit id="08b68144843ad4490acc1cceea81edee533ae15a" translate="yes" xml:space="preserve">
          <source>Test::Builder::Clutch</source>
          <target state="translated">Test::Builder::Clutch</target>
        </trans-unit>
        <trans-unit id="c2aadab602bd18d0f63c1096df14d2661c5c645e" translate="yes" xml:space="preserve">
          <source>Test::Builder::Formatter</source>
          <target state="translated">Test::Builder::Formatter</target>
        </trans-unit>
        <trans-unit id="b65d47cb23a2aae086b24a276b41605a5607bc8a" translate="yes" xml:space="preserve">
          <source>Test::Builder::Formatter - Test::Builder subclass of Test2::Formatter::TAP</source>
          <target state="translated">Test::Builder::Formatter-Test::Builder 是 Test2::Formatter::TAP 的子类。</target>
        </trans-unit>
        <trans-unit id="6a921037b78151ec674b9e8b2042772f638e1ae3" translate="yes" xml:space="preserve">
          <source>Test::Builder::IO::Scalar</source>
          <target state="translated">Test::Builder::IO::Scalar</target>
        </trans-unit>
        <trans-unit id="8598b4873ed01a8a8a65021f790976f5909cde97" translate="yes" xml:space="preserve">
          <source>Test::Builder::IO::Scalar - A copy of IO::Scalar for Test::Builder</source>
          <target state="translated">Test::Builder::IO::Scalar-Test::Builder的IO::Scalar副本。</target>
        </trans-unit>
        <trans-unit id="a007e7488b132a0e9d1aa8009a01ac991651ac14" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module</source>
          <target state="translated">Test::Builder::Module</target>
        </trans-unit>
        <trans-unit id="3ed23c6a90bd99e62a3c52acce5c4439a1d74951" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module - Base class for test modules</source>
          <target state="translated">Test::Builder::Module-测试模块的基础类。</target>
        </trans-unit>
        <trans-unit id="cc216e7a80df8491f0b761fca22c7d52cff231ca" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module is a subclass of &lt;a href=&quot;../../exporter&quot;&gt;Exporter&lt;/a&gt; which means your module is also a subclass of Exporter. @EXPORT, @EXPORT_OK, etc... all act normally.</source>
          <target state="translated">Test :: Builder :: Module是&lt;a href=&quot;../../exporter&quot;&gt;Exporter&lt;/a&gt;的子类，这意味着您的模块也是Exporter的子类。@ EXPORT，@ EXPORT_OK等...均正常运行。</target>
        </trans-unit>
        <trans-unit id="beddeafc2200fcc739f218f443081251d72a00e9" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module is a subclass of &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; which means your module is also a subclass of Exporter. @EXPORT, @EXPORT_OK, etc... all act normally.</source>
          <target state="translated">Test :: Builder :: Module是&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;的子类，这意味着您的模块也是Exporter的子类。@ EXPORT，@ EXPORT_OK等...均正常运行。</target>
        </trans-unit>
        <trans-unit id="59c85c34391e2a59a9a1aebf543278d41eaede1e" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; method which acts in the same basic way as &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt;'s, setting the plan and controlling exporting of functions and variables. This allows your module to set the plan independent of &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt;.</source>
          <target state="translated">Test :: Builder :: Module提供了一个 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 方法，该方法的行为与&lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt;的基本方法相同，用于设置计划并控制函数和变量的导出。这使您的模块可以独立于&lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt;来设置计划。</target>
        </trans-unit>
        <trans-unit id="8f6c2ece6f56adee6a05f3b497d85cec7b976b9a" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides an &lt;code&gt;import()&lt;/code&gt; method which acts in the same basic way as &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;'s, setting the plan and controlling exporting of functions and variables. This allows your module to set the plan independent of &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;.</source>
          <target state="translated">Test :: Builder :: Module提供了一个 &lt;code&gt;import()&lt;/code&gt; 方法，该方法的行为与&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt;的基本方法相同，用于设置计划并控制函数和变量的导出。这使您的模块可以独立于&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt;来设置计划。</target>
        </trans-unit>
        <trans-unit id="1860964402a6fbbf4a8ee83b8ff81c101e436168" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides some methods of getting at the underlying Test::Builder object.</source>
          <target state="translated">Test::Builder::Module 提供了一些获取底层 Test::Builder 对象的方法。</target>
        </trans-unit>
        <trans-unit id="dfe8750e469aab07b5d8dadae68c198e1a6ea505" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester</source>
          <target state="translated">Test::Builder::Tester</target>
        </trans-unit>
        <trans-unit id="99afed4f8190d67c7ca9fceff64feafac8a2c27f" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester - test testsuites that have been built with Test::Builder</source>
          <target state="translated">Test::Builder::Tester-使用 Test::Builder 建立的测试套件。</target>
        </trans-unit>
        <trans-unit id="a5daa4b264c9be76b3e43bc5b6e1208a2a0f3088" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester does not handle plans well. It has never done anything special with plans. This means that plans from outside Test::Builder::Tester will effect Test::Builder::Tester, worse plans when using Test::Builder::Tester will effect overall testing. At this point there are no plans to fix this bug as people have come to depend on it, and Test::Builder::Tester is now discouraged in favor of &lt;code&gt;Test2::API::intercept()&lt;/code&gt;. See &lt;a href=&quot;https://github.com/Test-More/test-more/issues/667&quot;&gt;https://github.com/Test-More/test-more/issues/667&lt;/a&gt;</source>
          <target state="translated">Test :: Builder :: Tester不能很好地处理计划。它从未对计划做任何特别的事情。这意味着来自外部Test :: Builder :: Tester的计划会影响Test :: Builder :: Tester，而使用Test :: Builder :: Tester时更糟糕的计划会影响整体测试。由于人们开始依赖此错误，因此目前尚无修复此错误的计划，现在不鼓励使用Test :: Builder :: Tester，而推荐使用 &lt;code&gt;Test2::API::intercept()&lt;/code&gt; 。参见&lt;a href=&quot;https://github.com/Test-More/test-more/issues/667&quot;&gt;https://github.com/Test-More/test-more/issues/667&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21b5ba34db69a6e0e7e2db842da88dc2874db319" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester::Color</source>
          <target state="translated">Test::Builder::Tester::Color</target>
        </trans-unit>
        <trans-unit id="2d500c7bf4e510506ebc84f5c768b05a6cccce1c" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester::Color - turn on colour in Test::Builder::Tester</source>
          <target state="translated">Test::Builder::Tester::Color-在 Test::Builder::Tester 中打开颜色。</target>
        </trans-unit>
        <trans-unit id="53667487e4c182cc6c194b110fdd4bf8602e9ca2" translate="yes" xml:space="preserve">
          <source>Test::Builder::TodoDiag</source>
          <target state="translated">Test::Builder::TodoDiag</target>
        </trans-unit>
        <trans-unit id="3002af054c03a9c23ba9d877d3c154ef71a2f214" translate="yes" xml:space="preserve">
          <source>Test::Builder::TodoDiag - Test::Builder subclass of Test2::Event::Diag</source>
          <target state="translated">Test::Builder::TodoDiag-Test2::Event::Diag的Test::Builder子类。</target>
        </trans-unit>
        <trans-unit id="6c62394a96db894e9826fa86cbfb9739d5ef32c0" translate="yes" xml:space="preserve">
          <source>Test::DBIx::Class::Schema</source>
          <target state="translated">Test::DBIx::Class::Schema</target>
        </trans-unit>
        <trans-unit id="5b5ccd27092122c879d215a96c52ebaf02aa4964" translate="yes" xml:space="preserve">
          <source>Test::Dist::VersionSync</source>
          <target state="translated">Test::Dist::VersionSync</target>
        </trans-unit>
        <trans-unit id="8c38eb7023c514bb86f58038021705c167c2100e" translate="yes" xml:space="preserve">
          <source>Test::Exception</source>
          <target state="translated">Test::Exception</target>
        </trans-unit>
        <trans-unit id="fa3770b25c372094da5ee1db5052ae09e83ef8c9" translate="yes" xml:space="preserve">
          <source>Test::FITesque</source>
          <target state="translated">Test::FITesque</target>
        </trans-unit>
        <trans-unit id="a7d826918b9640ee5aefda9817fc5812e0f756da" translate="yes" xml:space="preserve">
          <source>Test::Flatten</source>
          <target state="translated">Test::Flatten</target>
        </trans-unit>
        <trans-unit id="3a3efe85ae6b44923e15a1815a66c74e76451413" translate="yes" xml:space="preserve">
          <source>Test::Group</source>
          <target state="translated">Test::Group</target>
        </trans-unit>
        <trans-unit id="d22ac9fb1a5b65be8b995c5c95d6e3ef8ecf556f" translate="yes" xml:space="preserve">
          <source>Test::Harness</source>
          <target state="translated">Test::Harness</target>
        </trans-unit>
        <trans-unit id="999566fc7acbd2379a803a5571ff7ae9c8a53f12" translate="yes" xml:space="preserve">
          <source>Test::Harness - Run Perl standard test scripts with statistics</source>
          <target state="translated">Test::Harness-通过统计数据运行Perl标准测试脚本。</target>
        </trans-unit>
        <trans-unit id="468e0078216124f369b31903b11b8bc081cc36e2" translate="yes" xml:space="preserve">
          <source>Test::Harness is responsible for running test scripts, analysing their output and reporting success or failure. When I type</source>
          <target state="translated">Test::Harness负责运行测试脚本,分析它们的输出并报告成功或失败。当我输入</target>
        </trans-unit>
        <trans-unit id="a6a7d2d4bb460e39ef11a61cdb53eb1618e9aac3" translate="yes" xml:space="preserve">
          <source>Test::Harness::Beyond</source>
          <target state="translated">Test::Harness::Beyond</target>
        </trans-unit>
        <trans-unit id="710da8f3b5001dc747ab1add20a7485f6580ee6f" translate="yes" xml:space="preserve">
          <source>Test::Harness::Beyond - Beyond make test</source>
          <target state="translated">Test::Harness::Beyond-Beyond make test</target>
        </trans-unit>
        <trans-unit id="a575600ccb79ef75baad46fa5507b8a5c4e30ec7" translate="yes" xml:space="preserve">
          <source>Test::Kit</source>
          <target state="translated">Test::Kit</target>
        </trans-unit>
        <trans-unit id="e0d9d27235388a3f369fc7bba1f8eedaa8e97fe0" translate="yes" xml:space="preserve">
          <source>Test::Modern</source>
          <target state="translated">Test::Modern</target>
        </trans-unit>
        <trans-unit id="192bb93f9defdd2612446bcb1a3d05713afa6106" translate="yes" xml:space="preserve">
          <source>Test::Module::Used</source>
          <target state="translated">Test::Module::Used</target>
        </trans-unit>
        <trans-unit id="ba56db031e8622af899875ba4ed0dd10651ade7c" translate="yes" xml:space="preserve">
          <source>Test::Moose::More</source>
          <target state="translated">Test::Moose::More</target>
        </trans-unit>
        <trans-unit id="8bc418104ff43998dd3e36faf2584e579de681bc" translate="yes" xml:space="preserve">
          <source>Test::More</source>
          <target state="translated">Test::More</target>
        </trans-unit>
        <trans-unit id="6bfa9c991e549bd99bf8bd638cf1236dd03e5675" translate="yes" xml:space="preserve">
          <source>Test::More - yet another framework for writing test scripts</source>
          <target state="translated">Test::More-又一个编写测试脚本的框架。</target>
        </trans-unit>
        <trans-unit id="09cadd12e0ce824bc15b5cc2302b3277911f9d5d" translate="yes" xml:space="preserve">
          <source>Test::More is loaded. This is ok:</source>
          <target state="translated">Test::More已加载。这是好的。</target>
        </trans-unit>
        <trans-unit id="298bd3075d22676dbcd8f6e949f1684dca1178d5" translate="yes" xml:space="preserve">
          <source>Test::More will only be aware of threads if &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; has been done</source>
          <target state="translated">Test :: More将仅在 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 完成后才意识到线程</target>
        </trans-unit>
        <trans-unit id="196636e03a49e3d95a68eb5d1e772f5b446bf075" translate="yes" xml:space="preserve">
          <source>Test::More will only be aware of threads if &lt;code&gt;use threads&lt;/code&gt; has been done</source>
          <target state="translated">Test :: More将仅在 &lt;code&gt;use threads&lt;/code&gt; 完成后才意识到线程</target>
        </trans-unit>
        <trans-unit id="71a20537d51a274a0fa5bf1a1b0842f5d372eac9" translate="yes" xml:space="preserve">
          <source>Test::More works with Perls as old as 5.8.1.</source>
          <target state="translated">Test::More可以在5.8.1版本的Perls中使用。</target>
        </trans-unit>
        <trans-unit id="8218b4a58d60c04b93980b51121cc27fdf92c29b" translate="yes" xml:space="preserve">
          <source>Test::More::Prefix</source>
          <target state="translated">Test::More::Prefix</target>
        </trans-unit>
        <trans-unit id="ec61f56547ff7cd28c4fd12d8d489f875c46dac9" translate="yes" xml:space="preserve">
          <source>Test::ParallelSubtest</source>
          <target state="translated">Test::ParallelSubtest</target>
        </trans-unit>
        <trans-unit id="b9283666c0f7ee8bee524021520b4a58fc6faf53" translate="yes" xml:space="preserve">
          <source>Test::Pretty</source>
          <target state="translated">Test::Pretty</target>
        </trans-unit>
        <trans-unit id="6b788f39836a6b433e5df6d0783c10c859e93117" translate="yes" xml:space="preserve">
          <source>Test::SharedFork</source>
          <target state="translated">Test::SharedFork</target>
        </trans-unit>
        <trans-unit id="1daa106bfbe0f2bf149e9e695740563a8ed4ebb6" translate="yes" xml:space="preserve">
          <source>Test::Simple</source>
          <target state="translated">Test::Simple</target>
        </trans-unit>
        <trans-unit id="3b9ad9cea20f592f35fa16d26cd1276645b8b0c3" translate="yes" xml:space="preserve">
          <source>Test::Simple - Basic utilities for writing tests.</source>
          <target state="translated">Test::Simple-编写测试的基本工具。</target>
        </trans-unit>
        <trans-unit id="475687d59b9799eb28a9bf920c296a61e431b89f" translate="yes" xml:space="preserve">
          <source>Test::Simple is &lt;b&gt;explicitly&lt;/b&gt; tested all the way back to perl 5.6.0.</source>
          <target state="translated">自从Perl 5.6.0以来，对Test :: Simple进行了&lt;b&gt;明确的&lt;/b&gt;测试。</target>
        </trans-unit>
        <trans-unit id="5f28cc996a292888e74e1d0b0e1cee8d8ca4199f" translate="yes" xml:space="preserve">
          <source>Test::Simple is thread-safe in perl 5.8.1 and up.</source>
          <target state="translated">Test::Simple在perl 5.8.1及以上版本中是线程安全的。</target>
        </trans-unit>
        <trans-unit id="73bb7e431ecc9d090ef6327ee2db2dd9ad7a8638" translate="yes" xml:space="preserve">
          <source>Test::Simple will only report a maximum of 254 failures in its exit code. If this is a problem, you probably have a huge test script. Split it into multiple files. (Otherwise blame the Unix folks for using an unsigned short integer as the exit status).</source>
          <target state="translated">Test::Simple在其退出代码中最多只能报告254次失败。如果这是一个问题,你可能有一个巨大的测试脚本。将它分割成多个文件。(否则就怪Unix的人使用一个无符号短整数作为退出状态)。</target>
        </trans-unit>
        <trans-unit id="8aa960dec0e59265b42ae7c53ff6c2bb33cb537d" translate="yes" xml:space="preserve">
          <source>Test::Simple will start by printing number of tests run in the form &quot;1..M&quot; (so &quot;1..5&quot; means you're going to run 5 tests). This strange format lets &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; know how many tests you plan on running in case something goes horribly wrong.</source>
          <target state="translated">Test :: Simple将从打印以&amp;ldquo; 1..M&amp;rdquo;形式运行的测试数量开始（因此&amp;ldquo; 1..5&amp;rdquo;表示您将要运行5个测试）。这种奇怪的格式可以让&lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt;知道您计划在运行中进行多少测试，以防万一出现严重错误。</target>
        </trans-unit>
        <trans-unit id="7410d0684050e7e2cf37f448e25d1181f683a339" translate="yes" xml:space="preserve">
          <source>Test::Simple will start by printing number of tests run in the form &quot;1..M&quot; (so &quot;1..5&quot; means you're going to run 5 tests). This strange format lets &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; know how many tests you plan on running in case something goes horribly wrong.</source>
          <target state="translated">Test :: Simple将从打印以&amp;ldquo; 1..M&amp;rdquo;形式运行的测试数量开始（因此&amp;ldquo; 1..5&amp;rdquo;表示您将要运行5个测试）。这种奇怪的格式可以让&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;知道您计划在运行中进行多少测试，以防万一出了什么问题。</target>
        </trans-unit>
        <trans-unit id="dad41aad99148e817cb791ab1874c49f4dd7b526" translate="yes" xml:space="preserve">
          <source>Test::Tester</source>
          <target state="translated">Test::Tester</target>
        </trans-unit>
        <trans-unit id="8acb8c70dcb4cd96a3e80ad8c60dfdc954c732ae" translate="yes" xml:space="preserve">
          <source>Test::Tester - Ease testing test modules built with Test::Builder</source>
          <target state="translated">Test::Tester-轻松测试用Test::Builder构建的测试模块。</target>
        </trans-unit>
        <trans-unit id="9c807179d1ac6c0d1012cd2c0455c92e0bc574a1" translate="yes" xml:space="preserve">
          <source>Test::Tester::Capture</source>
          <target state="translated">Test::Tester::Capture</target>
        </trans-unit>
        <trans-unit id="34d5b01db7ffd8049c2fce4af0432b62a248b560" translate="yes" xml:space="preserve">
          <source>Test::Tester::Capture - Help testing test modules built with Test::Builder</source>
          <target state="translated">Test::Tester::Capture-帮助测试用Test::Builder构建的测试模块。</target>
        </trans-unit>
        <trans-unit id="9a458c6dc8e9ff30e8f733b126620031229080ac" translate="yes" xml:space="preserve">
          <source>Test::Tester::Capture is a cut down and hacked up version of Test::Builder. Test::Builder was written by chromatic &amp;lt;chromatic@wgz.org&amp;gt; and Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;.</source>
          <target state="translated">Test :: Tester :: Capture是Test :: Builder的精简版和黑名单版。Test :: Builder是由chromium &amp;lt;chromatical@wgz.org&amp;gt;和Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;编写的。</target>
        </trans-unit>
        <trans-unit id="c9e02cff79037d04f0d5bb99326725d2ece3d0d2" translate="yes" xml:space="preserve">
          <source>Test::Tester::CaptureRunner</source>
          <target state="translated">Test::Tester::CaptureRunner</target>
        </trans-unit>
        <trans-unit id="91c101deb36c07d85cffc331897f08c9b07bf3e8" translate="yes" xml:space="preserve">
          <source>Test::Tester::CaptureRunner - Help testing test modules built with Test::Builder</source>
          <target state="translated">Test::Tester::CaptureRunner-帮助测试用Test::Builder构建的测试模块。</target>
        </trans-unit>
        <trans-unit id="f26dc9e7487fca0c9f4cffd8168312e798d0afc9" translate="yes" xml:space="preserve">
          <source>Test::Tutorial</source>
          <target state="translated">Test::Tutorial</target>
        </trans-unit>
        <trans-unit id="02f397dd5054f86d8966d3c1290f138f6ebe0f4c" translate="yes" xml:space="preserve">
          <source>Test::Tutorial - A tutorial about writing really basic tests</source>
          <target state="translated">Test::Tutorial-一个关于编写真正的基础测试的教程。</target>
        </trans-unit>
        <trans-unit id="a895a2ec6601bf0432d22dd921492b16b90ab206" translate="yes" xml:space="preserve">
          <source>Test::UseAllModules</source>
          <target state="translated">Test::UseAllModules</target>
        </trans-unit>
        <trans-unit id="bf429510e44f5fd6da7cc7782aa21fed2fafa3e5" translate="yes" xml:space="preserve">
          <source>Test::Wrapper</source>
          <target state="translated">Test::Wrapper</target>
        </trans-unit>
        <trans-unit id="2041e8b48dd73d1c03506e63605772b484021ff1" translate="yes" xml:space="preserve">
          <source>Test::use::ok</source>
          <target state="translated">Test::use::ok</target>
        </trans-unit>
        <trans-unit id="85de35d70454052811bfbba08699cf789b433ab6" translate="yes" xml:space="preserve">
          <source>Test::use::ok - Alternative to Test::More::use_ok</source>
          <target state="translated">Test::use::ok-Test::More::use_ok的替代方案。</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="df0cbdcfcbefab8ee9cdb49385d677707edb64f0" translate="yes" xml:space="preserve">
          <source>Testing Anomalies with Perl on OS/390</source>
          <target state="translated">在OS/390上使用Perl测试异常情况</target>
        </trans-unit>
        <trans-unit id="5570491e686f99f120f682632ae7878ad3d5e6f3" translate="yes" xml:space="preserve">
          <source>Testing Perl on AmigaOS</source>
          <target state="translated">在AmigaOS上测试Perl</target>
        </trans-unit>
        <trans-unit id="8fcfced2bef4012741d97c1ae50789df4c2ca1a7" translate="yes" xml:space="preserve">
          <source>Testing Perl on BS2000</source>
          <target state="translated">在BS2000上测试Perl</target>
        </trans-unit>
        <trans-unit id="d2f23703acfdab063aa7e2b458c49da1d7edf65c" translate="yes" xml:space="preserve">
          <source>Testing Perl on DOS</source>
          <target state="translated">在DOS上测试Perl</target>
        </trans-unit>
        <trans-unit id="06d9fe11979b660c9a4ee9181d453bdc4d62d418" translate="yes" xml:space="preserve">
          <source>Testing Perl on Tru64</source>
          <target state="translated">在 Tru64 上测试 Perl</target>
        </trans-unit>
        <trans-unit id="ad2407f8ab58aad232d3d10c4a28600678ba9ac4" translate="yes" xml:space="preserve">
          <source>Testing Perl on Windows</source>
          <target state="translated">在Windows上测试Perl</target>
        </trans-unit>
        <trans-unit id="77bcc7871b8f58fd20b1c5a5350ee1211c163038" translate="yes" xml:space="preserve">
          <source>Testing for broken locales</source>
          <target state="translated">测试破损的区域</target>
        </trans-unit>
        <trans-unit id="8a625de0654c02e74db29ae73bd5e3bde68f2ba9" translate="yes" xml:space="preserve">
          <source>Testing for exact floating-point equality or inequality is not a good idea. Here's a (relatively expensive) work-around to compare whether two floating-point numbers are equal to a particular number of decimal places. See Knuth, volume II, for a more robust treatment of this topic.</source>
          <target state="translated">测试精确的浮点数相等或不相等不是一个好主意。这里有一个(相对昂贵的)变通方法,用来比较两个浮点数是否等于特定的小数点位数。参见Knuth,第二卷,关于这个主题的更强大的处理方法。</target>
        </trans-unit>
        <trans-unit id="ce74fac01896559c610eb3a5a4dbe52a84d8dafc" translate="yes" xml:space="preserve">
          <source>Testing for operating systems or versions when should be testing for features</source>
          <target state="translated">测试操作系统或版本的时候应该测试功能</target>
        </trans-unit>
        <trans-unit id="2d25b81a3e33ddcbb9c9dc8657d0fadaaa4f4848" translate="yes" xml:space="preserve">
          <source>Testing lots of values</source>
          <target state="translated">测试大量数值</target>
        </trans-unit>
        <trans-unit id="e225b583da27a200eb4cb29e5d543c5d33dff11a" translate="yes" xml:space="preserve">
          <source>Testing results: &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt;</source>
          <target state="translated">测试结果：&lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http&lt;/a&gt; : //www.cpantesters.org/</target>
        </trans-unit>
        <trans-unit id="7fb7daa9466444fb2d40197eaff882519cbfe5af" translate="yes" xml:space="preserve">
          <source>Testing results: &lt;a href=&quot;https://www.cpantesters.org/&quot;&gt;https://www.cpantesters.org/&lt;/a&gt;</source>
          <target state="translated">测试结果：&lt;a href=&quot;https://www.cpantesters.org/&quot;&gt;https&lt;/a&gt; : //www.cpantesters.org/</target>
        </trans-unit>
        <trans-unit id="062a3b44009f84b9f2800778be4849f48c73f2e1" translate="yes" xml:space="preserve">
          <source>Testing the patch</source>
          <target state="translated">测试补丁</target>
        </trans-unit>
        <trans-unit id="3d3998625037d01c3f0c18b46c8e2f6a0db08edf" translate="yes" xml:space="preserve">
          <source>Testing tools</source>
          <target state="translated">测试工具</target>
        </trans-unit>
        <trans-unit id="73860e29950984e7ebc73550412c5d939d1b2f02" translate="yes" xml:space="preserve">
          <source>Testing with taint mode.</source>
          <target state="translated">用污点模式测试。</target>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">Tests</target>
        </trans-unit>
        <trans-unit id="16d924262049c4868fcbd9b1e4dbe661fd3a3f60" translate="yes" xml:space="preserve">
          <source>Tests are run from the top level of your distribution. So inside a test you would refer to ./lib to enter the lib directory, for example.</source>
          <target state="translated">测试是在你的发行版的顶层运行的。因此,在一个测试中,你会引用./lib来进入lib目录,例如。</target>
        </trans-unit>
        <trans-unit id="f8610f229cb8bffff5963f6ac85b8ed60c32307d" translate="yes" xml:space="preserve">
          <source>Tests break due to subtest indentation.</source>
          <target state="translated">测试因子测试缩进而中断。</target>
        </trans-unit>
        <trans-unit id="54a6b8165e3eb024d50e4aac5941e40919fd1c85" translate="yes" xml:space="preserve">
          <source>Tests for basic control structures, &lt;code&gt;if/else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; , subroutines, etc.</source>
          <target state="translated">测试基本控制结构， &lt;code&gt;if/else&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; ，子例程等。</target>
        </trans-unit>
        <trans-unit id="43a6cf885d16a46b82e0be5400cae40cc21567ca" translate="yes" xml:space="preserve">
          <source>Tests for basic control structures, &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, subroutines, etc.</source>
          <target state="translated">测试基本控制结构， &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; ，子例程等。</target>
        </trans-unit>
        <trans-unit id="d23a0f9aaa05867bc6031160779c65549d0d4574" translate="yes" xml:space="preserve">
          <source>Tests for basic issues of how Perl parses and compiles itself.</source>
          <target state="translated">测试Perl如何解析和编译的基本问题。</target>
        </trans-unit>
        <trans-unit id="308c251d349eaa69d0bf0cd8f27225db41d2132b" translate="yes" xml:space="preserve">
          <source>Tests for built-in IO functions, including command line arguments.</source>
          <target state="translated">测试内置IO函数,包括命令行参数。</target>
        </trans-unit>
        <trans-unit id="19b2942a8db27974454d5941c50ac27e7e57bf55" translate="yes" xml:space="preserve">
          <source>Tests for core modules in the</source>
          <target state="translated">核心模块的测试</target>
        </trans-unit>
        <trans-unit id="b5bc9dd6c6b565df077d3e101f86339fa68c2de9" translate="yes" xml:space="preserve">
          <source>Tests for features of how perl actually runs, including exit codes and handling of PERL* environment variables.</source>
          <target state="translated">测试perl实际运行的特性,包括退出代码和PERL*环境变量的处理。</target>
        </trans-unit>
        <trans-unit id="3267c94afb370d057a2cbf7d80804c00a071b8c7" translate="yes" xml:space="preserve">
          <source>Tests for modules in</source>
          <target state="translated">模块测试</target>
        </trans-unit>
        <trans-unit id="546a42daa356e4d754d8415b0cf28f28144cb38f" translate="yes" xml:space="preserve">
          <source>Tests for perl's built in functions that don't fit into any of the other directories.</source>
          <target state="translated">测试perl的内置函数,这些函数不适合任何其他目录。</target>
        </trans-unit>
        <trans-unit id="7dde17b953b0dbe2392223a460035fd53ab6fcb8" translate="yes" xml:space="preserve">
          <source>Tests for perl's built in functions which, like those in</source>
          <target state="translated">测试perl的内置函数,就像在</target>
        </trans-unit>
        <trans-unit id="cee38a612a6bf39e0ad8abf7e176cb7eb3696a9c" translate="yes" xml:space="preserve">
          <source>Tests for perl's method resolution order implementations (see &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt;).</source>
          <target state="translated">测试perl的方法解析顺序实现（请参阅&lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="20b59967ab49cfe543876fa9d6d79f51e0848a3e" translate="yes" xml:space="preserve">
          <source>Tests for regex related functions or behaviour. (These used to live in t/op).</source>
          <target state="translated">测试与regex相关的功能或行为。(这些以前在t/op中)。</target>
        </trans-unit>
        <trans-unit id="9a9539800599d59b0f69e2e288d490ed3068858e" translate="yes" xml:space="preserve">
          <source>Tests for the absolute basic functionality of Perl. This includes &lt;code&gt;if&lt;/code&gt; , basic file reads and writes, simple regexes, etc. These are run first in the test suite and if any of them fail, something is</source>
          <target state="translated">测试Perl的绝对基本功能。这包括 &lt;code&gt;if&lt;/code&gt; ，基本文件读写，简单的正则表达式等。它们首先在测试套件中运行，如果其中任何一个失败，则说明存在某些问题。</target>
        </trans-unit>
        <trans-unit id="8ad550acb94fcd95cceafdb6277d5fdd95b24d49" translate="yes" xml:space="preserve">
          <source>Tests for the absolute basic functionality of Perl. This includes &lt;code&gt;if&lt;/code&gt;, basic file reads and writes, simple regexes, etc. These are run first in the test suite and if any of them fail, something is</source>
          <target state="translated">测试Perl的绝对基本功能。这包括 &lt;code&gt;if&lt;/code&gt; ，基本文件读写，简单的正则表达式等。它们首先在测试套件中运行，如果它们中的任何一个失败，则说明存在某些问题。</target>
        </trans-unit>
        <trans-unit id="4c72675b2d7c270a253600fe2e92bb83c326034f" translate="yes" xml:space="preserve">
          <source>Tests for the core support of Unicode.</source>
          <target state="translated">测试对Unicode的核心支持。</target>
        </trans-unit>
        <trans-unit id="5399480a16c4de144214dd4ce3a72127bb1a23c7" translate="yes" xml:space="preserve">
          <source>Tests for your modules go here. Each test filename ends with a .t. So</source>
          <target state="translated">你的模块的测试可以在这里进行。每个测试文件名都以.t结尾,所以</target>
        </trans-unit>
        <trans-unit id="3b09fe0c89b9d62c4f3f3bd0ca9b2eec4dcf9e3b" translate="yes" xml:space="preserve">
          <source>Tests if a directory exists.</source>
          <target state="translated">测试目录是否存在。</target>
        </trans-unit>
        <trans-unit id="46dcf6b14fde2f007d3642aeb765c51b6d6d9ef7" translate="yes" xml:space="preserve">
          <source>Tests if a file exists and is not empty (size &amp;gt; 0).</source>
          <target state="translated">测试文件是否存在并且不为空（大小&amp;gt; 0）。</target>
        </trans-unit>
        <trans-unit id="6b574534ebbfa4f25620de8b753e474bc0774320" translate="yes" xml:space="preserve">
          <source>Tests if a file exists.</source>
          <target state="translated">测试文件是否存在。</target>
        </trans-unit>
        <trans-unit id="cbd83d5913990ad1027b8f9518f00ff7c97af8a7" translate="yes" xml:space="preserve">
          <source>Tests if some arbitrary number of bytes begins in a valid UTF-8 character. Note that an INVARIANT (i.e. ASCII on non-EBCDIC machines) character is a valid UTF-8 character. The actual number of bytes in the UTF-8 character will be returned if it is valid, otherwise 0.</source>
          <target state="translated">测试任意数量的字节是否以有效的UTF-8字符开始。请注意,一个INVARIANT(即非EBCDIC机器上的ASCII码)字符是一个有效的UTF-8字符,如果有效,则返回UTF-8字符的实际字节数,否则为0。如果UTF-8字符是有效的,则返回实际的字节数,否则为0。</target>
        </trans-unit>
        <trans-unit id="44e861c8808d6c4fdc4afa5679c3cee1a9b5d6ca" translate="yes" xml:space="preserve">
          <source>Tests if the SV is an RV.</source>
          <target state="translated">测试SV是否为RV。</target>
        </trans-unit>
        <trans-unit id="e941f360f3702d2e201c15e9113b9156e131c64f" translate="yes" xml:space="preserve">
          <source>Tests if the source file exists and is not empty (size &amp;gt; 0). If it is not empty it copies it to the given destination with the given permissions.</source>
          <target state="translated">测试源文件是否存在并且不为空（大小&amp;gt; 0）。如果不为空，它将使用给定的权限将其复制到给定的目的地。</target>
        </trans-unit>
        <trans-unit id="8add41d28c736769282eb5984bc3956add793925" translate="yes" xml:space="preserve">
          <source>Tests if two threads objects are the same thread or not. This is overloaded to the more natural forms:</source>
          <target state="translated">测试两个线程对象是否为同一线程。这是重载到更自然的形式。</target>
        </trans-unit>
        <trans-unit id="374b92e6c8d9a3ee7da76fc28e0b35de614ef062" translate="yes" xml:space="preserve">
          <source>Tests that have never failed will not be selected. To run all tests with the most recently failed first use</source>
          <target state="translated">从未失败过的测试将不会被选中。要运行所有最近失败的测试,首先使用</target>
        </trans-unit>
        <trans-unit id="0b32728377a8f935217ef765a504aecedda1d3ff" translate="yes" xml:space="preserve">
          <source>Tests the SigSet object to see if it contains a specific signal.</source>
          <target state="translated">测试SigSet对象是否包含一个特定的信号。</target>
        </trans-unit>
        <trans-unit id="018f42b8eff88fccb00a8501792db561a99e45b3" translate="yes" xml:space="preserve">
          <source>Tests the state of the source tree for various common errors. For example, it tests that everyone who is listed in the git log has a corresponding entry in the</source>
          <target state="translated">测试源代码树的各种常见错误状态。例如,它测试git日志中列出的每个人是否在</target>
        </trans-unit>
        <trans-unit id="ea2ffd035ac28e433a00f696dde2f14824fdd414" translate="yes" xml:space="preserve">
          <source>Tests will be run in the order found.</source>
          <target state="translated">测试将按照找到的顺序进行。</target>
        </trans-unit>
        <trans-unit id="98125dc77105eee722883e53962bb713d1532fbc" translate="yes" xml:space="preserve">
          <source>Texas</source>
          <target state="translated">Texas</target>
        </trans-unit>
        <trans-unit id="e7d8144d0e2f5125039e56e9f410b15ff3f27544" translate="yes" xml:space="preserve">
          <source>Texas Instruments</source>
          <target state="translated">德州仪器</target>
        </trans-unit>
        <trans-unit id="c1c3994d542e6e140e686559285de68d361dbc43" translate="yes" xml:space="preserve">
          <source>Text Fields</source>
          <target state="translated">文本字段</target>
        </trans-unit>
        <trans-unit id="5295b0156f97937927214f3e61425549fb5528ba" translate="yes" xml:space="preserve">
          <source>Text after __DATA__ may be read via the filehandle &lt;code&gt;PACKNAME::DATA&lt;/code&gt; , where &lt;code&gt;PACKNAME&lt;/code&gt; is the package that was current when the __DATA__ token was encountered. The filehandle is left open pointing to the line after __DATA__. The program should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; DATA&lt;/code&gt; when it is done reading from it. (Leaving it open leaks filehandles if the module is reloaded for any reason, so it's a safer practice to close it.) For compatibility with older scripts written before __DATA__ was introduced, __END__ behaves like __DATA__ in the top level script (but not in files loaded with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;) and leaves the remaining contents of the file accessible via &lt;code&gt;main::DATA&lt;/code&gt; .</source>
          <target state="translated">__DATA__之后的文本可以通过文件句柄 &lt;code&gt;PACKNAME::DATA&lt;/code&gt; 读取，其中 &lt;code&gt;PACKNAME&lt;/code&gt; 是遇到__DATA__令牌时的当前包。文件句柄保持打开状态，指向__DATA__之后的行。从 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; DATA&lt;/code&gt; 读取完成后，程序应&lt;a href=&quot;functions/close&quot;&gt;关闭&lt;/a&gt; DATA。 （如果出于某种原因重新加载该模块，则将其保持打开状态会泄漏文件句柄，因此关闭它是一种更安全的做法。）为了与引入__DATA__之前编写的旧脚本兼容，__ END__的行为类似于顶级脚本中的__DATA__（但不在文件中）加载了 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; ），并通过 &lt;code&gt;main::DATA&lt;/code&gt; 访问文件的其余内容。</target>
        </trans-unit>
        <trans-unit id="3842cca55ef2d8dd670adcc834aa3853a804149a" translate="yes" xml:space="preserve">
          <source>Text after __DATA__ may be read via the filehandle &lt;code&gt;PACKNAME::DATA&lt;/code&gt;, where &lt;code&gt;PACKNAME&lt;/code&gt; is the package that was current when the __DATA__ token was encountered. The filehandle is left open pointing to the line after __DATA__. The program should &lt;code&gt;close DATA&lt;/code&gt; when it is done reading from it. (Leaving it open leaks filehandles if the module is reloaded for any reason, so it's a safer practice to close it.) For compatibility with older scripts written before __DATA__ was introduced, __END__ behaves like __DATA__ in the top level script (but not in files loaded with &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt;) and leaves the remaining contents of the file accessible via &lt;code&gt;main::DATA&lt;/code&gt;.</source>
          <target state="translated">__DATA__之后的文本可以通过文件句柄 &lt;code&gt;PACKNAME::DATA&lt;/code&gt; 读取，其中 &lt;code&gt;PACKNAME&lt;/code&gt; 是遇到__DATA__令牌时的当前包。文件句柄保持打开状态，指向__DATA__之后的行。从 &lt;code&gt;close DATA&lt;/code&gt; 读取完成后，程序应关闭DATA。 （如果出于某种原因重新加载该模块，则将其保持打开状态会泄漏文件句柄，因此关闭它是一种更安全的做法。）为了与引入__DATA__之前编写的旧脚本兼容，__ END__的行为类似于顶级脚本中的__DATA__（但不在文件中）加载了 &lt;code&gt;require&lt;/code&gt; 或 &lt;code&gt;do&lt;/code&gt; ），并使文件的其余内容可通过 &lt;code&gt;main::DATA&lt;/code&gt; 访问。</target>
        </trans-unit>
        <trans-unit id="14b961306ccde8b23c4b7e5620da4263be5fc453" translate="yes" xml:space="preserve">
          <source>Text from a &lt;code&gt;&quot;#&quot;&lt;/code&gt; character until the end of the line is a comment, and is ignored. Exceptions include &lt;code&gt;&quot;#&quot;&lt;/code&gt; inside a string or regular expression.</source>
          <target state="translated">从 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 字符到行尾的文本是注释，将被忽略。例外包括字符串或正则表达式中的 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="612222022f1b46958ab65767470934164201705e" translate="yes" xml:space="preserve">
          <source>Text sorted by numeric codepoint follows no reasonable alphabetic order; use the UCA for sorting text.</source>
          <target state="translated">按数字码点排序的文本不遵循合理的字母顺序,使用UCA对文本进行排序。</target>
        </trans-unit>
        <trans-unit id="2c6fa58228dea3c204f1dbf0a6dfadcd17082dee" translate="yes" xml:space="preserve">
          <source>Text strings (character strings)</source>
          <target state="translated">文本串(字符串</target>
        </trans-unit>
        <trans-unit id="3b64142186315d3b56e626d60aec3cca8845fddf" translate="yes" xml:space="preserve">
          <source>Text-mode filehandles</source>
          <target state="translated">文本模式的文件柄</target>
        </trans-unit>
        <trans-unit id="5f66be9f33facdd2db9a099e59f4d627dc79cb6a" translate="yes" xml:space="preserve">
          <source>Text-tokens from Pod::Simple::PullParser</source>
          <target state="translated">来自Pod::Simple::PullParser的文本标记。</target>
        </trans-unit>
        <trans-unit id="538841f5b8d0f8755431ba6c721b56da44fdedea" translate="yes" xml:space="preserve">
          <source>Text/Binary</source>
          <target state="translated">Text/Binary</target>
        </trans-unit>
        <trans-unit id="0ff712854e85b7ca719cd920d585fda4d395d5a6" translate="yes" xml:space="preserve">
          <source>Text/Soundex.pm</source>
          <target state="translated">Text/Soundex.pm</target>
        </trans-unit>
        <trans-unit id="e496659a9c65305c9d5cc245d38c0b1cea09e5cd" translate="yes" xml:space="preserve">
          <source>Text2</source>
          <target state="translated">Text2</target>
        </trans-unit>
        <trans-unit id="76fdd8573b883583b24f2ee565ca6b0eb2a5486b" translate="yes" xml:space="preserve">
          <source>Text::Abbrev</source>
          <target state="translated">Text::Abbrev</target>
        </trans-unit>
        <trans-unit id="2068aa4164bd7ee8a2ded8f7cd23b18d6c9d99cd" translate="yes" xml:space="preserve">
          <source>Text::Abbrev - abbrev - create an abbreviation table from a list</source>
          <target state="translated">Text::Abbrev-abbrev-从列表中创建一个缩写表。</target>
        </trans-unit>
        <trans-unit id="3fa2f6e623c8f3b7b036f20657d7a8f10bb6417e" translate="yes" xml:space="preserve">
          <source>Text::Balanced</source>
          <target state="translated">Text::Balanced</target>
        </trans-unit>
        <trans-unit id="ed925f6d474c4516a347932710d3ebe30e7e56cb" translate="yes" xml:space="preserve">
          <source>Text::Balanced - Extract delimited text sequences from strings.</source>
          <target state="translated">Text::Balanced-从字符串中提取分隔的文本序列。</target>
        </trans-unit>
        <trans-unit id="e4b49cafa2ac97b401d3d68d8bed306fe21eb79b" translate="yes" xml:space="preserve">
          <source>Text::ParseWords</source>
          <target state="translated">Text::ParseWords</target>
        </trans-unit>
        <trans-unit id="4524c2c613f4d738713e1d030d34e60049e80d95" translate="yes" xml:space="preserve">
          <source>Text::ParseWords - parse text into an array of tokens or array of arrays</source>
          <target state="translated">Text::ParseWords-将文本解析为一个标记数组或数组。</target>
        </trans-unit>
        <trans-unit id="bdadcd3fc912962eb41c1688bb499f95c2ac99b6" translate="yes" xml:space="preserve">
          <source>Text::Tabs</source>
          <target state="translated">Text::Tabs</target>
        </trans-unit>
        <trans-unit id="d895b382c2e881055f9eeb7a0411fad11058bd8a" translate="yes" xml:space="preserve">
          <source>Text::Tabs - expand and unexpand tabs like unix expand(1) and unexpand(1)</source>
          <target state="translated">Text::Tabs-像unix expand(1)和unexpand(1)一样展开和不展开标签。</target>
        </trans-unit>
        <trans-unit id="4b087dde2df1e77a15a3f15af552e2d614eda1ab" translate="yes" xml:space="preserve">
          <source>Text::Tabs does most of what the unix utilities expand(1) and unexpand(1) do. Given a line with tabs in it, &lt;code&gt;expand&lt;/code&gt; replaces those tabs with the appropriate number of spaces. Given a line with or without tabs in it, &lt;code&gt;unexpand&lt;/code&gt; adds tabs when it can save bytes by doing so, like the &lt;code&gt;unexpand -a&lt;/code&gt; command.</source>
          <target state="translated">Text :: Tabs可以完成unix实用工具expand（1）和unexpand（1）的大部分工作。给定其中带有选项卡的行， &lt;code&gt;expand&lt;/code&gt; 将使用适当数量的空格替换这些选项卡。给定其中包含或不包含制表符的行，当 &lt;code&gt;unexpand&lt;/code&gt; 可以这样做保存字节时，它会像 &lt;code&gt;unexpand -a&lt;/code&gt; 命令一样添加制表符。</target>
        </trans-unit>
        <trans-unit id="f269210fd9d87098c23ad7f43c52bf42decefb07" translate="yes" xml:space="preserve">
          <source>Text::Tabs handles only tabs (&lt;code&gt;&quot;\t&quot;&lt;/code&gt; ) and combining characters (&lt;code&gt;/\pM/&lt;/code&gt; ). It doesn't count backwards for backspaces (&lt;code&gt;&quot;\t&quot;&lt;/code&gt; ), omit other non-printing control characters (&lt;code&gt;/\pC/&lt;/code&gt; ), or otherwise deal with any other zero-, half-, and full-width characters.</source>
          <target state="translated">Text :: Tabs仅处理制表符（ &lt;code&gt;&quot;\t&quot;&lt;/code&gt; ）和组合字符（ &lt;code&gt;/\pM/&lt;/code&gt; ）。对于空格，它不会向后计数（ &lt;code&gt;&quot;\t&quot;&lt;/code&gt; ），不会忽略其他非打印控制字符（ &lt;code&gt;/\pC/&lt;/code&gt; ），也不会处理任何其他零，半角和全角字符。</target>
        </trans-unit>
        <trans-unit id="b575607717c2ca75293a1a2f973ea2178607244e" translate="yes" xml:space="preserve">
          <source>Text::Tabs handles only tabs (&lt;code&gt;&quot;\t&quot;&lt;/code&gt;) and combining characters (&lt;code&gt;/\pM/&lt;/code&gt;). It doesn't count backwards for backspaces (&lt;code&gt;&quot;\t&quot;&lt;/code&gt;), omit other non-printing control characters (&lt;code&gt;/\pC/&lt;/code&gt;), or otherwise deal with any other zero-, half-, and full-width characters.</source>
          <target state="translated">Text :: Tabs仅处理选项卡（ &lt;code&gt;&quot;\t&quot;&lt;/code&gt; ）和组合字符（ &lt;code&gt;/\pM/&lt;/code&gt; ）。对于空格，它不会向后计数（ &lt;code&gt;&quot;\t&quot;&lt;/code&gt; ），不会省略其他非打印控制字符（ &lt;code&gt;/\pC/&lt;/code&gt; ），也不会处理任何其他零，半角和全角字符。</target>
        </trans-unit>
        <trans-unit id="b226bf7a7ae42bd7cbd6a0b3ba78466abba19e61" translate="yes" xml:space="preserve">
          <source>Text::Wrap</source>
          <target state="translated">Text::Wrap</target>
        </trans-unit>
        <trans-unit id="8aabd1ad489c52bb200edd21bc6dce9b91083963" translate="yes" xml:space="preserve">
          <source>Text::Wrap - line wrapping to form simple paragraphs</source>
          <target state="translated">Text::Wrap-通过换行形成简单的段落。</target>
        </trans-unit>
        <trans-unit id="f934f68f6305075635ab21032f0c6eb35d0fa39c" translate="yes" xml:space="preserve">
          <source>Thai encoding TCVN</source>
          <target state="translated">泰语编码TCVN</target>
        </trans-unit>
        <trans-unit id="6b50e31a7e1337db9ecb0e2fcb6e65ca27f57df5" translate="yes" xml:space="preserve">
          <source>Thank you</source>
          <target state="translated">谢谢你啊</target>
        </trans-unit>
        <trans-unit id="f8e8cd6c504322691d26989da020afe0ebedb22f" translate="yes" xml:space="preserve">
          <source>Thank you to (in chronological order):</source>
          <target state="translated">感谢(按时间顺序):</target>
        </trans-unit>
        <trans-unit id="b05872aaf946f643e0804715742f143fabda127d" translate="yes" xml:space="preserve">
          <source>Thanks (in no particular order) to Chaim Frenkel, Steve Fink, Gurusamy Sarathy, Ilya Zakharevich, Benjamin Sugars, J&amp;uuml;rgen Christoffel, Joshua Pritikin, and Alan Burlison, for their help in reality-checking and polishing this article. Big thanks to Tom Christiansen for his rewrite of the prime number generator.</source>
          <target state="translated">感谢（以不特殊的顺序）感谢Chaim Frenkel，Steve Fink，Gurusamy Sarathy，Ilya Zakharevich，Benjamin Sugars，J&amp;uuml;rgenChristoffel，Joshua Pritikin和Alan Burlison，他们为检查和完善本文提供了帮助。非常感谢Tom Christiansen重写了素数生成器。</target>
        </trans-unit>
        <trans-unit id="624dc0ad0c4a285c56d022996d1083a11fac8944" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://he.net/&quot;&gt;Hurricane Electric&lt;/a&gt; for permission to use its &lt;a href=&quot;http://man.he.net/&quot;&gt;Linux man pages online&lt;/a&gt; site for man page links.</source>
          <target state="translated">感谢&lt;a href=&quot;http://he.net/&quot;&gt;Hurricane Electric&lt;/a&gt;允许将其&lt;a href=&quot;http://man.he.net/&quot;&gt;Linux手册页在线&lt;/a&gt;站点用于手册页链接。</target>
        </trans-unit>
        <trans-unit id="52d197026943bb6167685c48d3d3074cfb2a40bd" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/&quot;&gt;search.cpan.org&lt;/a&gt; for permission to use the site for Perl module links.</source>
          <target state="translated">感谢&lt;a href=&quot;http://search.cpan.org/&quot;&gt;search.cpan.org&lt;/a&gt;允许使用该站点进行Perl模块链接。</target>
        </trans-unit>
        <trans-unit id="515198f3ec489e991661ee9be0d3531260928534" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fhe.net%2f&quot;&gt;Hurricane Electric&lt;/a&gt; for permission to use its &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net%2f&quot;&gt;Linux man pages online&lt;/a&gt; site for man page links.</source>
          <target state="translated">感谢&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fhe.net%2f&quot;&gt;Hurricane Electric&lt;/a&gt;允许将其&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net%2f&quot;&gt;Linux手册页在线&lt;/a&gt;站点用于手册页链接。</target>
        </trans-unit>
        <trans-unit id="4a56281c4f40d78c915f83cd7dcb75140989545c" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2f&quot;&gt;search.cpan.org&lt;/a&gt; for permission to use the site for Perl module links.</source>
          <target state="translated">感谢&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2f&quot;&gt;search.cpan.org&lt;/a&gt;允许将站点用于Perl模块链接。</target>
        </trans-unit>
        <trans-unit id="444d0503771db0d31f8257285cffffd1831b8683" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;https://he.net/&quot;&gt;Hurricane Electric&lt;/a&gt; for permission to use its &lt;a href=&quot;http://man.he.net/&quot;&gt;Linux man pages online&lt;/a&gt; site for man page links.</source>
          <target state="translated">感谢&lt;a href=&quot;https://he.net/&quot;&gt;Hurricane Electric&lt;/a&gt;允许将其&lt;a href=&quot;http://man.he.net/&quot;&gt;Linux手册页在线&lt;/a&gt;站点用于手册页链接。</target>
        </trans-unit>
        <trans-unit id="3cf7d45d74afe72eed5d28a1078191c21d4ed94f" translate="yes" xml:space="preserve">
          <source>Thanks to Chia-Liang Kao for suggesting &lt;code&gt;Path&lt;/code&gt; and &lt;code&gt;loc_lang&lt;/code&gt; .</source>
          <target state="translated">感谢Chia-Liang Kao建议 &lt;code&gt;Path&lt;/code&gt; 和 &lt;code&gt;loc_lang&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1eb6da0d25f176736a52f5327efe1222256fcc7" translate="yes" xml:space="preserve">
          <source>Thanks to Chia-Liang Kao for suggesting &lt;code&gt;Path&lt;/code&gt; and &lt;code&gt;loc_lang&lt;/code&gt;.</source>
          <target state="translated">感谢Chia-Liang Kao提出 &lt;code&gt;Path&lt;/code&gt; 和 &lt;code&gt;loc_lang&lt;/code&gt; 的建议。</target>
        </trans-unit>
        <trans-unit id="28343241fc627e1ddfa37f27bcd25a3afbba56c2" translate="yes" xml:space="preserve">
          <source>Thanks to Gerard Goossen from TTY. His presentation &quot;UTF-8 in the wild&quot; (Dutch Perl Workshop 2006) inspired me to publish my thoughts and write this tutorial.</source>
          <target state="translated">感谢来自 TTY 的 Gerard Goossen。他的演讲 &quot;UTF-8 in the wild&quot;(2006年荷兰Perl研讨会)启发我发表了我的想法,并写了这个教程。</target>
        </trans-unit>
        <trans-unit id="eebcdc028466185c372d461642a6d1089c91d63f" translate="yes" xml:space="preserve">
          <source>Thanks to Graham Barr for contributing the following paragraphs about the interaction between perl, and various firewall configurations. For further information on firewalls, it is recommended to consult the documentation that comes with the</source>
          <target state="translated">感谢 Graham Barr 提供了以下关于 perl 和各种防火墙配置之间的交互的段落。关于防火墙的更多信息,建议查阅随同</target>
        </trans-unit>
        <trans-unit id="4ae64bcb3e2de31c99abdd50b43bda8476faf81d" translate="yes" xml:space="preserve">
          <source>Thanks to James Mastros and Martijn van der Streek for their help in getting &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; to behave nicely.</source>
          <target state="translated">感谢James Mastros和Martijn van der Streek为使&lt;a href=&quot;IPC::Open3&quot;&gt;IPC :: Open3&lt;/a&gt;表现良好而提供的帮助。</target>
        </trans-unit>
        <trans-unit id="d6d72a4f35680c5e9eebf1d781be27639e4c1c23" translate="yes" xml:space="preserve">
          <source>Thanks to James Mastros and Martijn van der Streek for their help in getting &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt; to behave nicely.</source>
          <target state="translated">感谢James Mastros和Martijn van der Streek为使&lt;a href=&quot;open3&quot;&gt;IPC :: Open3&lt;/a&gt;表现良好而提供的帮助。</target>
        </trans-unit>
        <trans-unit id="7dd46c60691bdec97830a740ba5397edf654eae8" translate="yes" xml:space="preserve">
          <source>Thanks to Johan Vromans from Squirrel Consultancy. His UTF-8 rants during the Amsterdam Perl Mongers meetings got me interested and determined to find out how to use character encodings in Perl in ways that don't break easily.</source>
          <target state="translated">感谢 Squirrel Consultancy 的 Johan Vromans。他在阿姆斯特丹Perl Mongers会议上的UTF-8咆哮让我产生了浓厚的兴趣,并决心找出如何在Perl中使用字符编码而不容易损坏的方法。</target>
        </trans-unit>
        <trans-unit id="6253d9253e0f2874bf9d499be7a8e0251aa0083e" translate="yes" xml:space="preserve">
          <source>Thanks to Jonas B. Nielsen for making explicit imports work.</source>
          <target state="translated">感谢Jonas B.Nielsen让显式导入变得有效。</target>
        </trans-unit>
        <trans-unit id="485f1de2dc0f3f17fa293a32651cd066b318634d" translate="yes" xml:space="preserve">
          <source>Thanks to Jos I. Boumans for suggesting this module to be written.</source>
          <target state="translated">感谢Jos I.Boumans建议编写这个模块。</target>
        </trans-unit>
        <trans-unit id="5e83291fa2c7af3f2f4cad5da93414b81429569b" translate="yes" xml:space="preserve">
          <source>Thanks to Petya Kohts for the &lt;code&gt;run_forked&lt;/code&gt; code.</source>
          <target state="translated">感谢Petya Kohts提供的 &lt;code&gt;run_forked&lt;/code&gt; 代码。</target>
        </trans-unit>
        <trans-unit id="c916a51d90472cf9a92ff461a1e0369e54a45763" translate="yes" xml:space="preserve">
          <source>Thanks to Richard Clamp &amp;lt;richardc@unixbeard.net&amp;gt; for letting me use his testing system to try this module out on.</source>
          <target state="translated">感谢Richard Clamp &amp;lt;richardc@unixbeard.net&amp;gt;让我使用他的测试系统来试用该模块。</target>
        </trans-unit>
        <trans-unit id="d8791cdde7f82c928089217628fa54dbdfb5e400" translate="yes" xml:space="preserve">
          <source>Thanks to Richard Soderberg for his performance improvements.</source>
          <target state="translated">感谢Richard Soderberg对其性能的改进。</target>
        </trans-unit>
        <trans-unit id="1d0320e05ae32871d886bed9f5bf625ba37f166b" translate="yes" xml:space="preserve">
          <source>Thanks to Sean Burke, Chris Nandor, Chip Salzenberg, Tim Heaney, Gisle Aas, Rainer Tammer and especially Andrew Savige for their help and suggestions.</source>
          <target state="translated">感谢Sean Burke、Chris Nandor、Chip Salzenberg、Tim Heaney、Gisle Aas、Rainer Tammer,特别是Andrew Savige的帮助和建议。</target>
        </trans-unit>
        <trans-unit id="3c490099b710a18daaafdd3d9d34a147de5b78a3" translate="yes" xml:space="preserve">
          <source>Thanks to Tom Christiansen for suggesting that this module should be written and providing ideas for code improvements and security enhancements.</source>
          <target state="translated">感谢Tom Christiansen提出编写这个模块的建议,并提供了改进代码和加强安全的想法。</target>
        </trans-unit>
        <trans-unit id="243da9ccc28383d127f497ef267f78f655f69ef4" translate="yes" xml:space="preserve">
          <source>Thanks to overloading, the handling of arithmetics with complex numbers is simple and almost transparent.</source>
          <target state="translated">由于有了重载,对复杂数字的算术处理变得简单而几乎透明。</target>
        </trans-unit>
        <trans-unit id="e1237be2e8e888521e762a958f2915acb036e56d" translate="yes" xml:space="preserve">
          <source>Thanks to the kind readers of the perl5-porters@perl.org, perl-unicode@perl.org, linux-utf8@nl.linux.org, and unicore@unicode.org mailing lists for their valuable feedback.</source>
          <target state="translated">感谢perl5-porters@perl.org、perl-unicode@perl.org、linux-utf8@nl.linux.org 和 unicore@unicode.org 邮件列表的好心读者的宝贵反馈。</target>
        </trans-unit>
        <trans-unit id="895e96674a21c983f493504acc0807a09ac741d7" translate="yes" xml:space="preserve">
          <source>Thanks to the people who asked about this kind of stuff in several Perl IRC channels, and have constantly reminded me that a simpler explanation was needed.</source>
          <target state="translated">感谢在多个Perl IRC频道中询问这种东西的人,并不断提醒我,需要一个更简单的解释。</target>
        </trans-unit>
        <trans-unit id="5daafe91df31a9585afc5052640e7074b414f20e" translate="yes" xml:space="preserve">
          <source>Thanks to the people who reviewed this document for me, before it went public. They are: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans, Lukas Mai, Nathan Gray.</source>
          <target state="translated">感谢在公开之前为我审查这份文件的人。他们是:Benjamin Smith、Jan-Bieter Cornet、Johan Vromans、Lukas Mai、Nathan Gray。本杰明-史密斯、扬-彼得-科内特、约翰-弗罗曼斯、卢卡斯-麦、内森-格雷。</target>
        </trans-unit>
        <trans-unit id="e2ecff3d05e183be8e4afb3075781b60cf077a08" translate="yes" xml:space="preserve">
          <source>Thanks to these efforts most encodings that come with Encode support PerlIO but that still leaves following encodings.</source>
          <target state="translated">得益于这些努力,Encode中的大部分编码都支持PerlIO,但仍有以下编码。</target>
        </trans-unit>
        <trans-unit id="01f69c9fb3b65301a9a56633220645f84a279dc1" translate="yes" xml:space="preserve">
          <source>That a certain field exists in a struct</source>
          <target state="translated">某一字段存在于结构中</target>
        </trans-unit>
        <trans-unit id="13e180f49380db1e610eb63f2836d65fe6a7ff96" translate="yes" xml:space="preserve">
          <source>That a field is of certain signedness, sizeof, or type</source>
          <target state="translated">一个字段具有一定的符号性、大小或类型。</target>
        </trans-unit>
        <trans-unit id="ba8c7890c4018f7372ea3dd0b44efd4aac702fe3" translate="yes" xml:space="preserve">
          <source>That being said, there are several ways to approach this. If you are going to make this query many times over arbitrary string values, the fastest way is probably to invert the original array and maintain a hash whose keys are the first array's values:</source>
          <target state="translated">也就是说,有几种方法可以解决这个问题。如果你要对任意字符串值进行多次查询,最快的方法可能是对原始数组进行反转,并维护一个哈希,其键是第一个数组的值。</target>
        </trans-unit>
        <trans-unit id="f34dd8b430aa837e89a7b0c15eb719863c536f5a" translate="yes" xml:space="preserve">
          <source>That being said, there are several ways to approach this. In Perl 5.10 and later, you can use the smart match operator to check that an item is contained in an array or a hash:</source>
          <target state="translated">也就是说,有几种方法可以解决这个问题。在Perl 5.10及以后的版本中,你可以使用智能匹配操作符来检查一个项目是否包含在一个数组或哈希中。</target>
        </trans-unit>
        <trans-unit id="0c260ee0a50dde66d3ef426f496fd0710d1eecdf" translate="yes" xml:space="preserve">
          <source>That being said, we value Perl's stability and security and have long had an unwritten covenant with the broader Perl community to support and maintain releases of Perl.</source>
          <target state="translated">也就是说,我们重视Perl的稳定性和安全性,并且长期以来与广大的Perl社区有一个不成文的约定,即支持和维护Perl的发布。</target>
        </trans-unit>
        <trans-unit id="bbe53d4c6627e25c7f5c04a5ce2e7f7fde39b418" translate="yes" xml:space="preserve">
          <source>That block is a proper block like any other, so you can put more complicated code there. This sends the message out to one of two places:</source>
          <target state="translated">这个块和其他块一样,是一个适当的块,所以你可以在那里放更复杂的代码。这将信息发送到两个地方之一。</target>
        </trans-unit>
        <trans-unit id="b8b88815853e7b011e14c857de7c3f74f6afc9bd" translate="yes" xml:space="preserve">
          <source>That build was a portable hppa-1.1 multithread build that supports large files compiled with gcc-2.9-hppa-991112.</source>
          <target state="translated">那个构建是一个可移植的hppa-1.1多线程构建,支持用gcc-2.9-hppa-991112编译的大文件。</target>
        </trans-unit>
        <trans-unit id="a5173e93037f4e02bac658ae6058928a497347a4" translate="yes" xml:space="preserve">
          <source>That can be achieved by overriding &lt;code&gt;init&lt;/code&gt; in your class and working on the main lexicon with code like that:</source>
          <target state="translated">这可以通过重写类中的 &lt;code&gt;init&lt;/code&gt; 并使用如下代码在主要词典上进行操作来实现：</target>
        </trans-unit>
        <trans-unit id="51461163b856a03794ba96810bf1373b9d61492c" translate="yes" xml:space="preserve">
          <source>That clarifies the situation with regards Berkeley DB itself. What about &lt;b&gt;DB_File&lt;/b&gt;? Well, the behavior defined in the quote above is quite useful, so &lt;b&gt;DB_File&lt;/b&gt; conforms to it.</source>
          <target state="translated">这就澄清了有关Berkeley DB本身的情况。什么&lt;b&gt;DB_File&lt;/b&gt;？好吧，上面引用中定义的行为非常有用，因此&lt;b&gt;DB_File&lt;/b&gt;符合它。</target>
        </trans-unit>
        <trans-unit id="e4e253e3979e75b31e42c03e2604d27318e57461" translate="yes" xml:space="preserve">
          <source>That does the same thing as the previous code. &lt;code&gt;ok()&lt;/code&gt; is the backbone of Perl testing, and we'll be using it instead of roll-your-own from here on. If &lt;code&gt;ok()&lt;/code&gt; gets a true value, the test passes. False, it fails.</source>
          <target state="translated">这样做与以前的代码相同。 &lt;code&gt;ok()&lt;/code&gt; 是Perl测试的基础，从现在开始，我们将使用它而不是&amp;ldquo;一劳永逸&amp;rdquo;。如果 &lt;code&gt;ok()&lt;/code&gt; 获得真实值，则测试通过。错误，失败。</target>
        </trans-unit>
        <trans-unit id="42854bfa17d6ca63556d6a3b16e69afee421b58e" translate="yes" xml:space="preserve">
          <source>That example prints something like &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt; , because the &lt;code&gt;=&amp;gt;&lt;/code&gt; implicitly quotes the &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; immediately on its left, ignoring the fact that &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time.shift&lt;/a&gt;&lt;/code&gt; is the entire left operand.</source>
          <target state="translated">该示例将输出类似于 &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt; ，因为 &lt;code&gt;=&amp;gt;&lt;/code&gt; 隐式地在 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 引用了shift，而忽略了 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time.shift&lt;/a&gt;&lt;/code&gt; 是整个左操作数的事实。</target>
        </trans-unit>
        <trans-unit id="159d20ef613406bd732f05ac0e1faa07f34a47ec" translate="yes" xml:space="preserve">
          <source>That example prints something like &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt;, because the &lt;code&gt;=&amp;gt;&lt;/code&gt; implicitly quotes the &lt;code&gt;shift&lt;/code&gt; immediately on its left, ignoring the fact that &lt;code&gt;time.shift&lt;/code&gt; is the entire left operand.</source>
          <target state="translated">该示例将输出类似于 &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt; ，因为 &lt;code&gt;=&amp;gt;&lt;/code&gt; 隐式地在其左侧立即引用了 &lt;code&gt;shift&lt;/code&gt; ，而忽略了 &lt;code&gt;time.shift&lt;/code&gt; 是整个左侧操作数的事实。</target>
        </trans-unit>
        <trans-unit id="435a3c58eaf95bd7ca9114e558f52a39c1b31273" translate="yes" xml:space="preserve">
          <source>That example will print &quot;I like dogs. I like cats&quot;. Notice the original &lt;code&gt;$x&lt;/code&gt; variable has not been affected. The overall result of the substitution is instead stored in &lt;code&gt;$y&lt;/code&gt; . If the substitution doesn't affect anything then the original string is returned:</source>
          <target state="translated">该示例将显示&amp;ldquo;我喜欢狗，我喜欢猫&amp;rdquo;。请注意，原始 &lt;code&gt;$x&lt;/code&gt; 变量未受影响。替换的总体结果存储在 &lt;code&gt;$y&lt;/code&gt; 。如果替换不影响任何内容，则返回原始字符串：</target>
        </trans-unit>
        <trans-unit id="7278130041b031a5215a18d766074e98a320d921" translate="yes" xml:space="preserve">
          <source>That example will print &quot;I like dogs. I like cats&quot;. Notice the original &lt;code&gt;$x&lt;/code&gt; variable has not been affected. The overall result of the substitution is instead stored in &lt;code&gt;$y&lt;/code&gt;. If the substitution doesn't affect anything then the original string is returned:</source>
          <target state="translated">该示例将显示&amp;ldquo;我喜欢狗，我喜欢猫&amp;rdquo;。注意原始的 &lt;code&gt;$x&lt;/code&gt; 变量没有受到影响。替换的总体结果存储在 &lt;code&gt;$y&lt;/code&gt; 。如果替换不影响任何内容，则返回原始字符串：</target>
        </trans-unit>
        <trans-unit id="8395ebcf27841eba05938be973987efc8d458043" translate="yes" xml:space="preserve">
          <source>That explicit association is created by the built-in &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function, which is typically used within the</source>
          <target state="translated">显式关联是由内置的 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 功能创建的，通常在</target>
        </trans-unit>
        <trans-unit id="27b1cd2c668785cd9bb2dd2e3093b4e98220cdc9" translate="yes" xml:space="preserve">
          <source>That explicit association is created by the built-in &lt;code&gt;bless&lt;/code&gt; function, which is typically used within the</source>
          <target state="translated">显式关联是由内置的 &lt;code&gt;bless&lt;/code&gt; 功能创建的，通常在</target>
        </trans-unit>
        <trans-unit id="c2ec0978d45de2f32fa9de32d3062c113e6a14e6" translate="yes" xml:space="preserve">
          <source>That extra space comes from the interpolation of the array. If you don't want to put anything between your array elements, don't use the array in double quotes. You can send it to print without them:</source>
          <target state="translated">额外的空间来自于数组的插值。如果你不想在数组元素之间加入任何东西,不要用双引号来表示数组。你可以不用双引号发送打印。</target>
        </trans-unit>
        <trans-unit id="9b298824efc1a224419fada1ed430ca9a977cee5" translate="yes" xml:space="preserve">
          <source>That function can be called with either of the following statements. Note the different argument lists.</source>
          <target state="translated">该函数可以用以下任一语句调用。注意不同的参数列表。</target>
        </trans-unit>
        <trans-unit id="5a589d98a381dc121a0ca9e45213c36fe88d4b95" translate="yes" xml:space="preserve">
          <source>That gives you a parse-tree for each paragraph - so now all you need is an ordered list of paragraphs. You can maintain that yourself as a data element in the object/hash. The most straightforward way would be simply to use an array-ref, with the desired set of custom &quot;options&quot; for each invocation of &lt;b&gt;parse_text&lt;/b&gt;. Let's assume the desired option-set is given by the hash &lt;code&gt;%options&lt;/code&gt; . Then we might do something like the following:</source>
          <target state="translated">这样就为每个段落提供了一个分析树-因此，现在您需要的只是段落的有序列表。您可以将自己保留为对象/哈希中的数据元素。最直接的方法就是简单地使用array-ref，并为每次&lt;b&gt;parse_text&lt;/b&gt;调用提供所需的一组自定义&amp;ldquo;选项&amp;rdquo; 。假设所需的选项集由哈希 &lt;code&gt;%options&lt;/code&gt; 给出。然后，我们可能会执行以下操作：</target>
        </trans-unit>
        <trans-unit id="64f729272f1f6cba682dfada58129c0e19d1beec" translate="yes" xml:space="preserve">
          <source>That has historically been Perl's notion of UTF-8, as that is how UTF-8 was first conceived by Ken Thompson when he invented it. However, thanks to later revisions to the applicable standards, official UTF-8 is now rather stricter than that. For example, its range is much narrower (0 .. 0x10_FFFF to cover only 21 bits instead of 32 or 64 bits) and some sequences are not allowed, like those used in surrogate pairs, the 31 non-character code points 0xFDD0 .. 0xFDEF, the last two code points in</source>
          <target state="translated">这在历史上一直是Perl的UTF-8概念,因为Ken Thompson在发明UTF-8时就是这么设想的。然而,由于后来对适用标准的修订,现在官方的UTF-8比这要严格得多。例如,它的范围要窄得多(0 ...0x10_FFFF只覆盖21位,而不是32位或64位),而且有些序列是不允许的,比如那些在代用对中使用的序列,31个非字符码点0xFDD0 ...0xFDEF,最后的两个码点在 &quot;0 &quot;和 &quot;0 &quot;之间。</target>
        </trans-unit>
        <trans-unit id="d65679687da0ceb818cf54be11aba010b00841bb" translate="yes" xml:space="preserve">
          <source>That has the same effect as</source>
          <target state="translated">这与</target>
        </trans-unit>
        <trans-unit id="70ca5d290cf7d16b2ad0d56ac0c8bb778d981254" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. Perl is C89. Using the //-comments is silently allowed by many C compilers but cranking up the ANSI C89 strictness (which we like to do) causes the compilation to fail.</source>
          <target state="translated">那是C99或C++。Perl是C89。使用 //-注释是许多 C 编译器默默允许的,但调高 ANSI C89 的严格程度(我们喜欢这样做)会导致编译失败。</target>
        </trans-unit>
        <trans-unit id="fbc80ae07cc14a3e9ed515ddb417d3903b3e2d4c" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. Some C compilers allow that, but you shouldn't.</source>
          <target state="translated">那是C99或C++。有些C编译器允许这样做,但你不应该这样做。</target>
        </trans-unit>
        <trans-unit id="828feba24600ccd2337dfee90dbb710d49a4eff3" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. While it would indeed be awfully nice to have that also in C89, to limit the scope of the loop variable, alas, we cannot.</source>
          <target state="translated">那是C99或C++。虽然如果在C89中也能有这样的功能确实非常好,但为了限制循环变量的范围,可惜,我们不能。</target>
        </trans-unit>
        <trans-unit id="7473aa8c2d92485250630b49f5d5752d8eea9b3d" translate="yes" xml:space="preserve">
          <source>That is all covered in the documentation for Locale::Maketext and the modules that come with it, available in CPAN. After having read this article, which covers the why's of Maketext, the documentation, which covers the how's of it, should be quite straightforward.</source>
          <target state="translated">这些都在CPAN中的Locale::Maketext和附带的模块的文档中有所涉及。在读完这篇文章(包括为什么要使用Maketext)之后,文档(包括如何使用它)应该是很直接的。</target>
        </trans-unit>
        <trans-unit id="17c6f4c7bbbd6286d0fe21947d2ba8ade38beb92" translate="yes" xml:space="preserve">
          <source>That is because the translation from EBCDIC to ASCII is done by the web server in this case. Consult your web server's documentation for further details.</source>
          <target state="translated">这是因为在这种情况下,EBCDIC到ASCII的翻译是由Web服务器完成的。更多细节请参考您的网络服务器文档。</target>
        </trans-unit>
        <trans-unit id="942bc883ec6c98a20c711318e17853f42162c195" translate="yes" xml:space="preserve">
          <source>That is exactly equivalent to</source>
          <target state="translated">这完全等同于</target>
        </trans-unit>
        <trans-unit id="755dfd149254cee016be67859ecceb8b680f03fe" translate="yes" xml:space="preserve">
          <source>That is fine as far as it goes. The thing is, the Perl subroutine can be specified as only a string, however, Perl allows references to subroutines and anonymous subroutines. This is where</source>
          <target state="translated">就目前而言,这是很好的。问题是,Perl的子程序只能指定为一个字符串,但是,Perl允许引用子程序和匿名子程序。这就是</target>
        </trans-unit>
        <trans-unit id="f6e51945777f4de56dfd6b06b12bc029f8de1ebc" translate="yes" xml:space="preserve">
          <source>That is just short for this:</source>
          <target state="translated">这只是简称。</target>
        </trans-unit>
        <trans-unit id="48a322119a3ce010a99cb16daaa24fe8a2a63a40" translate="yes" xml:space="preserve">
          <source>That is, a &quot;start&quot; character followed by any number of &quot;continue&quot; characters. Perl requires every character in an identifier to also match &lt;code&gt;\w&lt;/code&gt; (this prevents some problematic cases); and Perl additionally accepts identfier names beginning with an underscore.</source>
          <target state="translated">即，一个&amp;ldquo;开始&amp;rdquo;字符，后跟任意数量的&amp;ldquo;继续&amp;rdquo;字符。Perl要求标识符中的每个字符都必须与 &lt;code&gt;\w&lt;/code&gt; 匹配（这可以防止出现一些问题）；Perl还接受以下划线开头的标识符名称。</target>
        </trans-unit>
        <trans-unit id="6558436d977d36dc225d2cf7090e600f732d6f4d" translate="yes" xml:space="preserve">
          <source>That is, a &lt;code&gt;'code...'&lt;/code&gt; filter</source>
          <target state="translated">也就是说，一个 &lt;code&gt;'code...'&lt;/code&gt; 过滤器</target>
        </trans-unit>
        <trans-unit id="1f4f6b5b263faf39b0387453cc01be5508d1f769" translate="yes" xml:space="preserve">
          <source>That is, a complex number with the real part of approximately &lt;code&gt;1.571&lt;/code&gt; and the imaginary part of approximately &lt;code&gt;-1.317&lt;/code&gt; .</source>
          <target state="translated">即，具有大约实部的复数 &lt;code&gt;1.571&lt;/code&gt; 和大约虚部 &lt;code&gt;-1.317&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="482980394273a0467a584ab6d2a57dbf1c99aa5d" translate="yes" xml:space="preserve">
          <source>That is, a complex number with the real part of approximately &lt;code&gt;1.571&lt;/code&gt; and the imaginary part of approximately &lt;code&gt;-1.317&lt;/code&gt;.</source>
          <target state="translated">即，具有大约实部的复数 &lt;code&gt;1.571&lt;/code&gt; 和大约虚部 &lt;code&gt;-1.317&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0eeeaa892b3243ba38eb1a4d1d75a40e3e83e990" translate="yes" xml:space="preserve">
          <source>That is, any word character in the ASCII range, as long as the first character is not a digit.</source>
          <target state="translated">也就是说,在ASCII码范围内的任何字字符,只要第一个字符不是数字就可以。</target>
        </trans-unit>
        <trans-unit id="36c759497b0b38fb79d0c364113b1512a2c43723" translate="yes" xml:space="preserve">
          <source>That is, both are like this:</source>
          <target state="translated">就是说,两者都是这样的。</target>
        </trans-unit>
        <trans-unit id="cbeb96e56e49bccd6548d94f7137868a0f109bb7" translate="yes" xml:space="preserve">
          <source>That is, fetch the &lt;code&gt;a&lt;/code&gt; entry from the main symbol table, and then look at the scalar component of it: &lt;code&gt;gvsv&lt;/code&gt; (&lt;code&gt;pp_gvsv&lt;/code&gt; in</source>
          <target state="translated">也就是说，从主符号表中获取 &lt;code&gt;a&lt;/code&gt; 条目，然后查看它的标量组件： &lt;code&gt;gvsv&lt;/code&gt; （ &lt;code&gt;pp_gvsv&lt;/code&gt; in</target>
        </trans-unit>
        <trans-unit id="75581dadc9573c00040ace36ddd58570a8c1a03a" translate="yes" xml:space="preserve">
          <source>That is, fetch the &lt;code&gt;a&lt;/code&gt; entry from the main symbol table, and then look at the scalar component of it: &lt;code&gt;gvsv&lt;/code&gt; (&lt;code&gt;pp_gvsv&lt;/code&gt; into</source>
          <target state="translated">也就是说，从主符号表中获取 &lt;code&gt;a&lt;/code&gt; 条目，然后查看它的标量组件： &lt;code&gt;gvsv&lt;/code&gt; （ &lt;code&gt;pp_gvsv&lt;/code&gt; into</target>
        </trans-unit>
        <trans-unit id="f3442fe5454be65a5f12295c4981af0a997452b8" translate="yes" xml:space="preserve">
          <source>That is, instead of writing this:</source>
          <target state="translated">就是说,而不是写这个。</target>
        </trans-unit>
        <trans-unit id="fe7215514db7a28aa89b16be5f49f87245a3434d" translate="yes" xml:space="preserve">
          <source>That is, it creates a region consisting of a single paragraph; that paragraph is to be treated as a normal paragraph if &quot;formatname&quot; begins with a &quot;:&quot;; if &quot;formatname&quot;</source>
          <target state="translated">也就是说,它创建了一个由单个段落组成的区域;如果 &quot;formatname &quot;以&quot;:&quot;开头,则该段落将被视为普通段落;如果 &quot;formatname&quot;</target>
        </trans-unit>
        <trans-unit id="7678e34c3ebdef14cc53701ea7fd891c9a91f614" translate="yes" xml:space="preserve">
          <source>That is, it runs a conversion with default options, for whatever inputdirs and output dir you specify.</source>
          <target state="translated">也就是说,无论你指定了什么输入目录和输出目录,它都会用默认的选项进行转换。</target>
        </trans-unit>
        <trans-unit id="27a7e3645a7eb93795bc368264f8f8cb79cd561d" translate="yes" xml:space="preserve">
          <source>That is, it treated both matches as undefined, and converted that to false (raising a warning on each). The first case is the expected result, but the second is likely counterintuitive: &quot;How could both be false when they are complements?&quot; Another problem was that the implementation optimized many Unicode property matches down to already existing simpler, faster operations, which don't raise the warning. We chose to not forgo those optimizations, which help the vast majority of matches, just to generate a warning for the unlikely event that an above-Unicode code point is being matched against.</source>
          <target state="translated">也就是说,它将两个匹配都视为未定义,并将其转换为false(对每个匹配都提出警告)。第一种情况是预期的结果,但第二种情况很可能是反直觉的:&quot;既然是补码,怎么可能都是false呢?&quot; 另一个问题是,实现将许多Unicode属性匹配优化为已经存在的更简单、更快速的操作,这些操作不会引发警告。我们选择不放弃这些对绝大多数匹配有帮助的优化,只是为了在不太可能发生的事件中产生警告,即上面的Unicode码点被匹配。</target>
        </trans-unit>
        <trans-unit id="b2448cc58794e445286f5f6bd3ff90ad3138eeba" translate="yes" xml:space="preserve">
          <source>That is, there should be (at least roughly) equal spacing between items as between paragraphs (although that spacing may well be less than the full height of a line of text). This leaves it to the reader to use (con)textual cues to figure out whether the &quot;Qui dolorem ipsum...&quot; paragraph applies to the &quot;Quisquam Est&quot; item or to all three items &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;. While not an ideal situation, this is preferable to providing formatting cues that may be actually contrary to the author's intent.</source>
          <target state="translated">也就是说,各项目之间的间距应与各段之间的间距相等(至少是大致相等)(尽管这种间距很可能小于一行文字的全高)。这样,读者就可以利用(con)文字提示来弄清 &quot;Qui dolorem ipsum......&quot;段是适用于 &quot;Quisquam Est &quot;项目,还是适用于 &quot;Neque&quot;、&quot;Porro &quot;和 &quot;Quisquam Est &quot;这三个项目。虽然这不是一种理想的情况,但这比提供可能实际上违背作者意图的格式提示要好。</target>
        </trans-unit>
        <trans-unit id="1e5a6f76070bd03364763274b3558ec3c231e14e" translate="yes" xml:space="preserve">
          <source>That is, they all produce the same event structure (for the most part), namely:</source>
          <target state="translated">也就是说,它们都会产生相同的事件结构(大多数情况下),即。</target>
        </trans-unit>
        <trans-unit id="d2a300a2c4d8d472deffaf92f425ba9342ddb708" translate="yes" xml:space="preserve">
          <source>That is, to get a number between 10 and 15, inclusive, you want a random number between 0 and 5 that you can then add to 10.</source>
          <target state="translated">也就是说,要想得到一个介于10和15(含)之间的数字,你要的是一个0和5之间的随机数,然后你可以把它加到10上。</target>
        </trans-unit>
        <trans-unit id="951f36d3e716f12408c22757558026bf31602523" translate="yes" xml:space="preserve">
          <source>That is, with &quot;=for&quot;, you can have only one paragraph's worth of text (i.e., the text in &quot;=foo targetname text...&quot;), but with &quot;=begin targetname&quot; ... &quot;=end targetname&quot;, you can have any amount of stuff in between. (Note that there still must be a blank line after the &quot;=begin&quot; command and a blank line before the &quot;=end&quot; command.)</source>
          <target state="translated">也就是说,使用&quot;=for&quot;,你只能有一段文字(即&quot;=foo targetname text...&quot;中的文字),但使用&quot;=begin targetname&quot;...&quot;=end targetname&quot;,你可以有任何数量的文字。&quot;=end targetname&quot;,你可以有任何数量的东西在中间。(请注意,在&quot;=begin &quot;命令后仍然必须有一个空行,在&quot;=end &quot;命令前必须有一个空行。)</target>
        </trans-unit>
        <trans-unit id="bc1a3360b8c34a0baef326cea1af80815467c26c" translate="yes" xml:space="preserve">
          <source>That last test line above should have the number '3' instead of '2'.</source>
          <target state="translated">上面最后一行测试应该是数字 &quot;3 &quot;而不是 &quot;2&quot;。</target>
        </trans-unit>
        <trans-unit id="c5a055a52b37b46f2d6c0e63eaf4e182af37b495" translate="yes" xml:space="preserve">
          <source>That looks a bit nicer; but we've got to take apart that weird template. Where did I pull that out of?</source>
          <target state="translated">这看起来有点好,但我们得把那个奇怪的模板拆开。我从哪里弄出来的?</target>
        </trans-unit>
        <trans-unit id="61626fcd66a349166c06495de786a6747ef2482c" translate="yes" xml:space="preserve">
          <source>That may be what you want, but if what you really want is</source>
          <target state="translated">这可能是你想要的,但如果你真正想要的是。</target>
        </trans-unit>
        <trans-unit id="c566d34d221f1316f52ee4a141ea9a232b591ec1" translate="yes" xml:space="preserve">
          <source>That means all the gzip support has to be done by hand - in this case by creating a tied filehandle to deal with creating the gzip header and trailer.</source>
          <target state="translated">这意味着所有的 gzip 支持都必须由人工完成--在本例中,通过创建一个绑定的 filehandle 来处理创建 gzip 头和预告片。</target>
        </trans-unit>
        <trans-unit id="1d5efec9cd6d8da4fb36301f3de63b6888e753f1" translate="yes" xml:space="preserve">
          <source>That means that the address comes back in binary for the host functions, and as a regular perl integer for the net ones. This seems a bug, but here's how to deal with it:</source>
          <target state="translated">这意味着主机函数的地址是二进制的,而net函数的地址是一个普通的perl整数。这似乎是一个bug,但这里有一个处理方法。</target>
        </trans-unit>
        <trans-unit id="f3988f8ba5df3605cc3a35c620ff3fb6ee001ddb" translate="yes" xml:space="preserve">
          <source>That means that the inheritance tree of the object is traversed breadth-first and the resulting order of classes is used as the sequence in which methods are called. However, that sequence is modified by imposing a rule that the appropriate method of a derived class must be called before the same method of any ancestral class. That's why, in the above example, &lt;code&gt;X::foo&lt;/code&gt; is called before &lt;code&gt;D::foo&lt;/code&gt; , even though &lt;code&gt;D&lt;/code&gt; comes before &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;@B::ISA&lt;/code&gt; .</source>
          <target state="translated">这意味着对象的继承树被广度优先地遍历，并且类的结果顺序被用作调用方法的顺序。但是，通过施加以下规则来修改该序列：必须在任何祖先类的相同方法之前调用派生类的适当方法。这就是为什么，在上面的例子中， &lt;code&gt;X::foo&lt;/code&gt; 之前被调用 &lt;code&gt;D::foo&lt;/code&gt; ，即使 &lt;code&gt;D&lt;/code&gt; 到来之前 &lt;code&gt;X&lt;/code&gt; 在 &lt;code&gt;@B::ISA&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5e47decd3f17a0dbcacce7016d0aedaa3f7c7e2" translate="yes" xml:space="preserve">
          <source>That means that the inheritance tree of the object is traversed breadth-first and the resulting order of classes is used as the sequence in which methods are called. However, that sequence is modified by imposing a rule that the appropriate method of a derived class must be called before the same method of any ancestral class. That's why, in the above example, &lt;code&gt;X::foo&lt;/code&gt; is called before &lt;code&gt;D::foo&lt;/code&gt;, even though &lt;code&gt;D&lt;/code&gt; comes before &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;@B::ISA&lt;/code&gt;.</source>
          <target state="translated">这意味着对象的继承树被广度优先地遍历，并且所得到的类的顺序被用作调用方法的顺序。但是，通过强加一个规则，即必须在任何祖先类的相同方法之前调用派生类的适当方法，来修改该序列。这就是为什么，在上面的例子中， &lt;code&gt;X::foo&lt;/code&gt; 之前被调用 &lt;code&gt;D::foo&lt;/code&gt; ，即使 &lt;code&gt;D&lt;/code&gt; 到来之前 &lt;code&gt;X&lt;/code&gt; 在 &lt;code&gt;@B::ISA&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02a75b8fa4871b84e34a76476fddd056744d525a" translate="yes" xml:space="preserve">
          <source>That means that you can specify other options (e.g. cachesize) and still have bval default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; for variable length records, and space for fixed length records.</source>
          <target state="translated">这意味着您可以指定其他选项（例如，cachesize），并且对于可变长度记录，bval默认设置为 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; ，对于固定长度记录，其空间设置为空格。</target>
        </trans-unit>
        <trans-unit id="7045c7edb73bdaec4db668503265f3c3aee4ce06" translate="yes" xml:space="preserve">
          <source>That means you can only use this function to look at or manipulate text before or after complete JSON objects, not while the parser is in the middle of parsing a JSON object.</source>
          <target state="translated">这意味着你只能在完整的JSON对象之前或之后使用这个函数来查看或操作文本,而不能在解析器正在解析JSON对象的时候使用。</target>
        </trans-unit>
        <trans-unit id="96f3ac9162c57e4899c7d0b17b547a39f0dc6701" translate="yes" xml:space="preserve">
          <source>That means, for example, that you can freely add or remove white space adjacent to (but within) the braces and the colon or equal sign.</source>
          <target state="translated">例如,这意味着你可以自由地添加或删除括号和冒号或等号附近(但在括号和冒号内)的白色空间。</target>
        </trans-unit>
        <trans-unit id="0ccd6e36decb0fa14e4cd9ccfdb15ab74bfe0e9c" translate="yes" xml:space="preserve">
          <source>That means, for example, that you can freely add or remove white space adjacent to (but within) the braces without affecting the meaning.</source>
          <target state="translated">这意味着,例如,你可以自由地添加或删除括号附近(但在括号内)的白色空间,而不影响其含义。</target>
        </trans-unit>
        <trans-unit id="ef48d86c4cc8b17f43db860898bcc6635d718b02" translate="yes" xml:space="preserve">
          <source>That method may be best because otherwise you won't treat IEEE notations like &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt; properly. At other times, you might prefer to determine whether string data can be used numerically by calling the POSIX::strtod() function or by inspecting your string with a regular expression (as documented in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;).</source>
          <target state="translated">该方法可能是最好的，因为否则您将无法正确处理 &lt;code&gt;NaN&lt;/code&gt; 或 &lt;code&gt;Infinity&lt;/code&gt; 等IEEE符号。在其他时候，您可能更喜欢通过调用POSIX :: strtod（）函数或通过使用正则表达式检查字符串（如&lt;a href=&quot;perlre&quot;&gt;perlre中所述&lt;/a&gt;）来确定是否可以数字方式使用字符串数据。</target>
        </trans-unit>
        <trans-unit id="6fd672a313da74831278f92221ca3146d4b9f20c" translate="yes" xml:space="preserve">
          <source>That no other fields exist besides the ones you know of</source>
          <target state="translated">除了你所知道的领域,没有其他领域的存在</target>
        </trans-unit>
        <trans-unit id="5527de36ef73a03f5b5a63ba8cbaf8b4f3a8fcb3" translate="yes" xml:space="preserve">
          <source>That now parses as you'd expect, but you still ought to get in the habit of using parentheses in that situation. For more on prototypes, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">现在可以按照您的期望进行解析了，但是您仍然应该养成在这种情况下使用括号的习惯。有关原型的更多信息，请参见&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7cb196541b3b7a98e0a23cefd4f853e129fa465" translate="yes" xml:space="preserve">
          <source>That output isn't terribly descriptive, is it? When you have two tests you can figure out which one is #2, but what if you have 102 tests?</source>
          <target state="translated">这个输出并不能很好的说明问题,是吗?当你有两个测试时,你可以计算出哪个是第2个,但如果你有102个测试呢?</target>
        </trans-unit>
        <trans-unit id="d37fa65fedd67f278b74cbc5a381d76fb677b39a" translate="yes" xml:space="preserve">
          <source>That prints &lt;code&gt;&quot;unphooey&quot;&lt;/code&gt; . (Yes, there are still unresolved issues having to do with visibility of &lt;code&gt;@_&lt;/code&gt; . I'm ignoring that question for the moment. (But note that if we make &lt;code&gt;@_&lt;/code&gt; lexically scoped, those anonymous subroutines can act like closures... (Gee, is this sounding a little Lispish? (Never mind.))))</source>
          <target state="translated">上面 &lt;code&gt;&quot;unphooey&quot;&lt;/code&gt; 。（是的，仍有一些尚未解决的问题与 &lt;code&gt;@_&lt;/code&gt; 的可见性有关。我暂时暂时不考虑这个问题。（但请注意，如果我们将 &lt;code&gt;@_&lt;/code&gt; 进行词法范围划分，则这些匿名子例程可以像闭包一样起作用...（哎呀，这听起来有点话语吗（没关系））））</target>
        </trans-unit>
        <trans-unit id="b70a77bf7cab1beed053568dab5acfb8d2eb3eda" translate="yes" xml:space="preserve">
          <source>That prints &lt;code&gt;&quot;unphooey&quot;&lt;/code&gt;. (Yes, there are still unresolved issues having to do with visibility of &lt;code&gt;@_&lt;/code&gt;. I'm ignoring that question for the moment. (But note that if we make &lt;code&gt;@_&lt;/code&gt; lexically scoped, those anonymous subroutines can act like closures... (Gee, is this sounding a little Lispish? (Never mind.))))</source>
          <target state="translated">上面 &lt;code&gt;&quot;unphooey&quot;&lt;/code&gt; 。（是的，仍有一些尚未解决的问题与 &lt;code&gt;@_&lt;/code&gt; 的可见性有关。我暂时忽略了这个问题。（但请注意，如果我们将 &lt;code&gt;@_&lt;/code&gt; 进行词法作用域限定，则这些匿名子例程可以像闭包一样起作用...（哎呀，这听起来有点话语吗（没关系））））</target>
        </trans-unit>
        <trans-unit id="b8f34b1d00199940c59db31a2c92190f8c2d18ac" translate="yes" xml:space="preserve">
          <source>That prints out: &lt;code&gt;&quot;The third fish is a red one.&quot;&lt;/code&gt; You can also use a repetition count and repeated pattern like this:</source>
          <target state="translated">打印出来： &lt;code&gt;&quot;The third fish is a red one.&quot;&lt;/code&gt; 您还可以使用重复计数和重复模式，如下所示：</target>
        </trans-unit>
        <trans-unit id="efe950f82cdddb13c9f97d9e858479f8a7148487" translate="yes" xml:space="preserve">
          <source>That problem is corrected by using the &lt;code&gt;&amp;amp;&lt;/code&gt; operator. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will now turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; correctly with parameters &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; . It does this by carrying the &lt;code&gt;&amp;amp;&lt;/code&gt; through, so the function call looks like &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt; .</source>
          <target state="translated">通过使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符可以解决该问题。该&lt;b&gt;xsubpp&lt;/b&gt;编译器现在会变成它调用这个代码 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 与参数正确 &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; 。它通过携带 &lt;code&gt;&amp;amp;&lt;/code&gt; 来做到这一点，因此函数调用看起来像 &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cdeebf2bdaf24e4c227b81d4e7ade3f1477fb5b" translate="yes" xml:space="preserve">
          <source>That problem is corrected by using the &lt;code&gt;&amp;amp;&lt;/code&gt; operator. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will now turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; correctly with parameters &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt;. It does this by carrying the &lt;code&gt;&amp;amp;&lt;/code&gt; through, so the function call looks like &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt;.</source>
          <target state="translated">通过使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符可以解决该问题。该&lt;b&gt;xsubpp&lt;/b&gt;编译器现在会变成它调用这个代码 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 与参数正确 &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; 。它通过携带 &lt;code&gt;&amp;amp;&lt;/code&gt; 来完成此操作，因此函数调用看起来像 &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd92600acf1aacb4bb45d3c98acc1cde89639e0e" translate="yes" xml:space="preserve">
          <source>That produces a new perl binary in the current directory with all extensions linked in that can be found in INST_ARCHLIB, SITELIBEXP, and PERL_ARCHLIB. To do that, MakeMaker writes a new Makefile, on UNIX, this is called</source>
          <target state="translated">这将在当前目录下生成一个新的perl二进制文件,其中链接了所有可以在INST_ARCHLIB、SITELIBEXP和PERL_ARCHLIB中找到的扩展。要做到这一点,MakeMaker会写一个新的Makefile,在UNIX上,这叫做</target>
        </trans-unit>
        <trans-unit id="4fc05162b844f86aa42257bcfb3642341ec2e119" translate="yes" xml:space="preserve">
          <source>That sadly does not (yet) work on QorIQ. At the moment of writing, the supported architectures are armv5, armv7, mipsel, wl500g, x86_32, and x86_64. Check &lt;a href=&quot;https://pkg.entware.net/binaries/&quot;&gt;here&lt;/a&gt; for supported platforms.</source>
          <target state="translated">遗憾的是，这还没有在QorIQ上奏效。在撰写本文时，支持的体系结构是armv5，armv7，mipsel，wl500g，x86_32和x86_64。请&lt;a href=&quot;https://pkg.entware.net/binaries/&quot;&gt;点击这里&lt;/a&gt;了解支持的平台。</target>
        </trans-unit>
        <trans-unit id="2351c4ce268ed6ae21d8f1fadbceac3b965331bf" translate="yes" xml:space="preserve">
          <source>That said, &lt;code&gt;miniperl -Ilib -MConfig -we 1&lt;/code&gt; should report an error, because it can not find</source>
          <target state="translated">就是说， &lt;code&gt;miniperl -Ilib -MConfig -we 1&lt;/code&gt; 应该报告一个错误，因为它找不到</target>
        </trans-unit>
        <trans-unit id="55a11affd308eca30c6c076da831e9e75ab6c62b" translate="yes" xml:space="preserve">
          <source>That said, be aware that Perl version 5.14 introduces an exception to the rule, for syntactic convenience. Experimental array and hash container function behavior allows array and hash references to be handled by Perl as if they had been explicitly syntactically dereferenced. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl5140delta.html#Syntactical-Enhancements&quot;&gt;Syntactical Enhancements in perl5140delta&lt;/a&gt; and &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details.</source>
          <target state="translated">就是说，请注意，为方便语法，Perl版本5.14引入了该规则的例外。实验性的数组和哈希容器功能行为允许Perl处理数组和哈希引用，就好像它们已在语法上显式取消引用一样。有关详细信息，请参见&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl5140delta.html#Syntactical-Enhancements&quot;&gt;perl5140delta&lt;/a&gt;和&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中的&lt;/a&gt;语法增强。</target>
        </trans-unit>
        <trans-unit id="dd96836988cad318a9323c182f881952adb3274c" translate="yes" xml:space="preserve">
          <source>That said, there are a number of steps that can be taken to make life difficult for the potential cracker. The most important: Write your decryption filter in C and statically link the decryption module into the Perl binary. For further tips to make life difficult for the potential cracker, see the file</source>
          <target state="translated">也就是说,有很多步骤可以让潜在的破解者难以下手。最重要的是:用C语言编写你的解密过滤器,并将解密模块静态地链接到Perl二进制中。更多让潜在的破解者难以下手的技巧,请参见文件</target>
        </trans-unit>
        <trans-unit id="6ebc1959c7e697a446f0d0678eca3b28f8c37055" translate="yes" xml:space="preserve">
          <source>That said, there will always be small, focused, special-purpose languages dedicated to a specific problem domain that are simply more convenient for certain kinds of problems. Perl tries to be all things to all people, but nothing special to anyone. Examples of specialized languages that come to mind include prolog and matlab.</source>
          <target state="translated">也就是说,总有一些小型的、专注的、专门用于特定问题领域的特殊用途语言,它们只是对某些类型的问题更方便。Perl试图成为所有人的一切,但对任何人来说都没有什么特别之处。我想到的专门语言的例子包括prolog和matlab。</target>
        </trans-unit>
        <trans-unit id="e78afc53e325aea84cf9c7e198003b89094d500a" translate="yes" xml:space="preserve">
          <source>That same loop could be replaced with a slice operation:</source>
          <target state="translated">同样的循环可以用分片操作代替。</target>
        </trans-unit>
        <trans-unit id="c28091748ec2b3306715e341483bb158b9c0cd3f" translate="yes" xml:space="preserve">
          <source>That second argument may be either a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt;'d regular expression (which is then used to match the terminator line), or a defined false value (which indicates that no terminator line should be looked for), or a reference to a hash (in which case the terminator is the value associated with the key &lt;code&gt;'terminator'&lt;/code&gt; .</source>
          <target state="translated">第二个参数可以是 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt; 'd正则表达式（然后用于匹配终止符行），也可以是定义的假值（指示不应查找终止符行），也可以是对哈希的引用（以在这种情况下，终止符是与键 &lt;code&gt;'terminator'&lt;/code&gt; 关联的值。</target>
        </trans-unit>
        <trans-unit id="75416fa5f847a38d5ad02218210c2358173e5f41" translate="yes" xml:space="preserve">
          <source>That second argument may be either a &lt;code&gt;qr&lt;/code&gt;'d regular expression (which is then used to match the terminator line), or a defined false value (which indicates that no terminator line should be looked for), or a reference to a hash (in which case the terminator is the value associated with the key &lt;code&gt;'terminator'&lt;/code&gt;.</source>
          <target state="translated">第二个参数可以是 &lt;code&gt;qr&lt;/code&gt; 'd正则表达式（然后用于匹配终止符行），也可以是定义的假值（指示不应查找终止符行），也可以是对哈希的引用（以在这种情况下，终止符是与键 &lt;code&gt;'terminator'&lt;/code&gt; 关联的值。</target>
        </trans-unit>
        <trans-unit id="0abf2ef0e2b7f166486ede4264164097c7510116" translate="yes" xml:space="preserve">
          <source>That should be written:</source>
          <target state="translated">应该这样写。</target>
        </trans-unit>
        <trans-unit id="21e34acb57e36768d34631cec4d8c18d970f96ef" translate="yes" xml:space="preserve">
          <source>That should probably be written more simply as:</source>
          <target state="translated">也许应该更简单地写成:</target>
        </trans-unit>
        <trans-unit id="6c2b874251fc59b8ebf4af56444c528d2be2ade1" translate="yes" xml:space="preserve">
          <source>That shows the &lt;code&gt;UTF8&lt;/code&gt; flag in FLAGS and both the UTF-8 bytes and Unicode characters in &lt;code&gt;PV&lt;/code&gt; . See also later in this document the discussion about the &lt;code&gt;utf8::is_utf8()&lt;/code&gt; function.</source>
          <target state="translated">这在FLAGS中显示 &lt;code&gt;UTF8&lt;/code&gt; 标志，在 &lt;code&gt;PV&lt;/code&gt; 中显示UTF-8字节和Unicode字符。另请参见本文档后面有关 &lt;code&gt;utf8::is_utf8()&lt;/code&gt; 函数的讨论。</target>
        </trans-unit>
        <trans-unit id="85f3321460ffe7c824d8d5e2118a4e8f2a1ba235" translate="yes" xml:space="preserve">
          <source>That shows the &lt;code&gt;UTF8&lt;/code&gt; flag in FLAGS and both the UTF-8 bytes and Unicode characters in &lt;code&gt;PV&lt;/code&gt;. See also later in this document the discussion about the &lt;code&gt;utf8::is_utf8()&lt;/code&gt; function.</source>
          <target state="translated">这在FLAGS中显示 &lt;code&gt;UTF8&lt;/code&gt; 标志，在 &lt;code&gt;PV&lt;/code&gt; 中显示UTF-8字节和Unicode字符。另请参见本文档后面有关 &lt;code&gt;utf8::is_utf8()&lt;/code&gt; 函数的讨论。</target>
        </trans-unit>
        <trans-unit id="90310d92761cded68c459a20fa9fa044cf2b05ae" translate="yes" xml:space="preserve">
          <source>That speeds things up but I have to make a note of which tests are failing and make sure that I run those tests. Instead I can use prove's --state switch and have it keep track of failing tests for me. First I do a complete run of the test suite and tell prove to save the results:</source>
          <target state="translated">这加快了速度,但我必须记录下哪些测试是失败的,并确保我运行这些测试。相反,我可以使用 prove 的 -状态开关,让它为我跟踪失败的测试。首先,我对测试套件进行一次完整的运行,然后告诉 prove 保存结果。</target>
        </trans-unit>
        <trans-unit id="38f7e088596d63a221ae18b14ab5e5b19e9feddc" translate="yes" xml:space="preserve">
          <source>That stores a machine readable summary of the test run in a file called '.prove' in the current directory. If I have failures I can then run just the failing scripts like this:</source>
          <target state="translated">它将测试运行的机器可读摘要存储在当前目录下一个名为'.province'的文件中。如果我的测试失败了,我可以像这样只运行失败的脚本。</target>
        </trans-unit>
        <trans-unit id="032b01f3384ab611cdf4fd40994fa76549ad8c4f" translate="yes" xml:space="preserve">
          <source>That syntax simply won't work. It sets just &lt;code&gt;@a&lt;/code&gt; or &lt;code&gt;%a&lt;/code&gt; and clears the &lt;code&gt;@b&lt;/code&gt; or &lt;code&gt;%b&lt;/code&gt; . Plus the function didn't get passed into two separate arrays or hashes: it got one long list in &lt;code&gt;@_&lt;/code&gt; , as always.</source>
          <target state="translated">该语法根本行不通。它仅设置 &lt;code&gt;@a&lt;/code&gt; 或 &lt;code&gt;%a&lt;/code&gt; 并清除 &lt;code&gt;@b&lt;/code&gt; 或 &lt;code&gt;%b&lt;/code&gt; 。另外，该函数没有传递到两个单独的数组或哈希中：与往常一样，它在 &lt;code&gt;@_&lt;/code&gt; 中有一个很长的列表。</target>
        </trans-unit>
        <trans-unit id="129289f49f37b2d5f60aa742ea447f8c63a26d22" translate="yes" xml:space="preserve">
          <source>That syntax simply won't work. It sets just &lt;code&gt;@a&lt;/code&gt; or &lt;code&gt;%a&lt;/code&gt; and clears the &lt;code&gt;@b&lt;/code&gt; or &lt;code&gt;%b&lt;/code&gt;. Plus the function didn't get passed into two separate arrays or hashes: it got one long list in &lt;code&gt;@_&lt;/code&gt;, as always.</source>
          <target state="translated">该语法根本行不通。它仅设置 &lt;code&gt;@a&lt;/code&gt; 或 &lt;code&gt;%a&lt;/code&gt; 并清除 &lt;code&gt;@b&lt;/code&gt; 或 &lt;code&gt;%b&lt;/code&gt; 。另外，该函数没有传递到两个单独的数组或哈希中：与往常一样，它在 &lt;code&gt;@_&lt;/code&gt; 中有一个很长的列表。</target>
        </trans-unit>
        <trans-unit id="d7adc8c9bedd29857f8a7951c4ad397c707680f4" translate="yes" xml:space="preserve">
          <source>That temporarily undefs your record separator, and will automatically close the file at block exit. If the file is already open, just use this:</source>
          <target state="translated">这将暂时取消你的记录分隔符,并将在块退出时自动关闭文件。如果文件已经打开,就用这个。</target>
        </trans-unit>
        <trans-unit id="e79dac633171d977159db125388db2bf16415ce0" translate="yes" xml:space="preserve">
          <source>That the fields are in a certain order</source>
          <target state="translated">字段按一定顺序排列</target>
        </trans-unit>
        <trans-unit id="5adec0092e434c8b7770e6ed721609aafb6fb0d1" translate="yes" xml:space="preserve">
          <source>That the sizeof(struct) or the alignments are the same everywhere</source>
          <target state="translated">sizeof(struct)或对齐方式在任何地方都是一样的。</target>
        </trans-unit>
        <trans-unit id="ff9ccf09dc2dc150e284071ebd76e3a60583513f" translate="yes" xml:space="preserve">
          <source>That third argument tests the byte size of the data on the &lt;code&gt;$fh&lt;/code&gt; filehandle and reads that many bytes into the buffer &lt;code&gt;$var&lt;/code&gt; .</source>
          <target state="translated">第三个参数测试 &lt;code&gt;$fh&lt;/code&gt; 文件句柄上数据的字节大小，并将那么多字节读入缓冲区 &lt;code&gt;$var&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="949fbe166b991dbecc0e8400e8a8c343a056cb09" translate="yes" xml:space="preserve">
          <source>That third argument tests the byte size of the data on the &lt;code&gt;$fh&lt;/code&gt; filehandle and reads that many bytes into the buffer &lt;code&gt;$var&lt;/code&gt;.</source>
          <target state="translated">第三个参数测试 &lt;code&gt;$fh&lt;/code&gt; 文件句柄上数据的字节大小，并将那么多字节读取到缓冲区 &lt;code&gt;$var&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38036119f27283dda19af4e5c3596941c97c5a13" translate="yes" xml:space="preserve">
          <source>That way, quant just has to chose which form it needs, without having to look up or generate anything. While possibly not optimal for Russian, this should work well for most other languages, where quantification is not as complicated an operation.</source>
          <target state="translated">这样一来,quant只需要选择它需要的形式,而不需要查找或生成任何东西。虽然这对俄语来说可能不是最理想的,但对大多数其他语言来说应该是很好的,因为在这些语言中,量化的操作没有那么复杂。</target>
        </trans-unit>
        <trans-unit id="f38824e1c7c399bcd876c5d796e89f3c65e609e8" translate="yes" xml:space="preserve">
          <source>That will efficiently match a nonempty group with matching parentheses two levels deep or less. However, if there is no such group, it will take virtually forever on a long string. That's because there are so many different ways to split a long string into several substrings. This is what &lt;code&gt;(.+)+&lt;/code&gt; is doing, and &lt;code&gt;(.+)+&lt;/code&gt; is similar to a subpattern of the above pattern. Consider how the pattern above detects no-match on &lt;code&gt;((()aaaaaaaaaaaaaaaaaa&lt;/code&gt; in several seconds, but that each extra letter doubles this time. This exponential performance will make it appear that your program has hung. However, a tiny change to this pattern</source>
          <target state="translated">这样可以有效地将一个非空组与两个或两个以下级别的括号匹配。但是，如果没有这样的组，那么长串实际上将永远占据一席之地。那是因为有很多不同的方法可以将一个长字符串分成几个子字符串。这就是 &lt;code&gt;(.+)+&lt;/code&gt; 的工作，并且 &lt;code&gt;(.+)+&lt;/code&gt; 与上述模式的子模式类似。考虑一下上面的模式如何在几秒钟内检测到 &lt;code&gt;((()aaaaaaaaaaaaaaaaaa&lt;/code&gt; aaaa</target>
        </trans-unit>
        <trans-unit id="d2c33811186783297750533407ae69a2c30dbe1c" translate="yes" xml:space="preserve">
          <source>That will print out &lt;code&gt;20&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt; .</source>
          <target state="translated">那将打印出 &lt;code&gt;20&lt;/code&gt; 和 &lt;code&gt;10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e40934849066a98371a45c630d963f7be828b226" translate="yes" xml:space="preserve">
          <source>That will print out &lt;code&gt;20&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">那将打印出 &lt;code&gt;20&lt;/code&gt; 和 &lt;code&gt;10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="844b1a95e3bd3c94e0935eae872c27cb6a3ae275" translate="yes" xml:space="preserve">
          <source>That will print out:</source>
          <target state="translated">这将打印出来。</target>
        </trans-unit>
        <trans-unit id="05490647754607e7eecb9c45fdd4f2b090c65042" translate="yes" xml:space="preserve">
          <source>That will run all tests in</source>
          <target state="translated">这将运行所有的测试,在</target>
        </trans-unit>
        <trans-unit id="3d6db72df23e281596a803d5b93d6efaedb2438e" translate="yes" xml:space="preserve">
          <source>That will run the script &lt;b&gt;myprogram&lt;/b&gt; without human intervention, printing out the call tree with entry and exit points. Note that &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; is equivalent to &lt;code&gt;N f=2&lt;/code&gt; , and that originally, options could be uniquely abbreviated by the first letter (modulo the &lt;code&gt;Dump*&lt;/code&gt; options). It is nevertheless recommended that you always spell them out in full for legibility and future compatibility.</source>
          <target state="translated">这将在无需人工干预的情况下运行脚本&lt;b&gt;myprogram&lt;/b&gt;，并打印出带有入口和出口点的调用树。请注意， &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; 等效于 &lt;code&gt;N f=2&lt;/code&gt; ，并且最初，选项可以唯一地缩写首字母（以 &lt;code&gt;Dump*&lt;/code&gt; 选项为模）。但是，建议您始终完整地拼写它们，以提高可读性和将来的兼容性。</target>
        </trans-unit>
        <trans-unit id="9b8798239553ae3afadcaa20b0a364d6ef25290e" translate="yes" xml:space="preserve">
          <source>That will run the script &lt;b&gt;myprogram&lt;/b&gt; without human intervention, printing out the call tree with entry and exit points. Note that &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; is equivalent to &lt;code&gt;N f=2&lt;/code&gt;, and that originally, options could be uniquely abbreviated by the first letter (modulo the &lt;code&gt;Dump*&lt;/code&gt; options). It is nevertheless recommended that you always spell them out in full for legibility and future compatibility.</source>
          <target state="translated">这将在没有人为干预的情况下运行脚本&lt;b&gt;myprogram&lt;/b&gt;，并打印出带有入口和出口点的调用树。请注意， &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; 等效于 &lt;code&gt;N f=2&lt;/code&gt; ，并且最初，选项可以唯一地缩写为第一个字母（以 &lt;code&gt;Dump*&lt;/code&gt; 选项为模）。但是，建议您始终完整地拼写它们，以提高可读性和将来的兼容性。</target>
        </trans-unit>
        <trans-unit id="d06ee710fae521075f5d16e4386c06facdb36dbc" translate="yes" xml:space="preserve">
          <source>That won't work at all, because &lt;code&gt;.*&lt;/code&gt; was greedy and gobbled up the whole string. As &lt;code&gt;\d*&lt;/code&gt; can match on an empty string the complete regular expression matched successfully.</source>
          <target state="translated">那根本行不通，因为 &lt;code&gt;.*&lt;/code&gt; 很贪婪，吞噬了整个字符串。由于 &lt;code&gt;\d*&lt;/code&gt; 可以匹配空字符串，因此可以成功匹配完整的正则表达式。</target>
        </trans-unit>
        <trans-unit id="cf6d51f1f160810f3ac3cc94b21320c749d1f295" translate="yes" xml:space="preserve">
          <source>That'll get you scolded on perl5-porters, so don't do that. Be Awesome.</source>
          <target state="translated">这会让你在perl5-porters上被骂,所以不要这么做。厉害点吧。</target>
        </trans-unit>
        <trans-unit id="025065d41f91f68021f87b4bc88af80b714297bb" translate="yes" xml:space="preserve">
          <source>That's a bit better, but we still have that last column which needs to be moved further over. There's an easy way to fix this up: unfortunately, we can't get &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; to right-justify our fields, but we can get &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; to do it:</source>
          <target state="translated">更好一点，但是我们还有最后一列，需要进一步介绍。有一个简单的方法可以解决此问题：不幸的是，我们无法正确 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 我们的字段，但我们可以让 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 做到这一点：</target>
        </trans-unit>
        <trans-unit id="28a77e110fbf943f3cd364152b5e3d00190d5f60" translate="yes" xml:space="preserve">
          <source>That's a bit better, but we still have that last column which needs to be moved further over. There's an easy way to fix this up: unfortunately, we can't get &lt;code&gt;pack&lt;/code&gt; to right-justify our fields, but we can get &lt;code&gt;sprintf&lt;/code&gt; to do it:</source>
          <target state="translated">更好一点，但是我们还有最后一列，需要进一步介绍。有一个简单的方法可以解决此问题：不幸的是，我们无法正确 &lt;code&gt;pack&lt;/code&gt; 我们的字段，但我们可以让 &lt;code&gt;sprintf&lt;/code&gt; 做到这一点：</target>
        </trans-unit>
        <trans-unit id="85ac81e130e91631a9d78d2d6a68196fcf7146e7" translate="yes" xml:space="preserve">
          <source>That's about all there is to it. Actually, it's more than all there is to it, because we've done a few nice things here for the sake of completeness, robustness, and general aesthetics. Simpler TIESCALAR classes are certainly possible.</source>
          <target state="translated">这就是它的全部内容了。事实上,这不仅仅是所有的东西,因为我们在这里做了一些很好的事情,为了完整性,健壮性,和一般的美学。更简单的TIESCALAR类当然也是可以的。</target>
        </trans-unit>
        <trans-unit id="eb3acd01c2e3336fdfd272a108c9af206f049bc1" translate="yes" xml:space="preserve">
          <source>That's all that's strictly necessary. There's additional files you might want:</source>
          <target state="translated">这就是所有严格必要的东西。还有一些额外的文件你可能需要。</target>
        </trans-unit>
        <trans-unit id="f4b60ee9e69236a73adb2c3c53252dab7254d2c9" translate="yes" xml:space="preserve">
          <source>That's all well and good for declaration of a fixed data structure, but what if you wanted to add new elements on the fly, or build it up entirely from scratch?</source>
          <target state="translated">对于固定数据结构的声明来说,这一切都很好,但如果你想在飞行中添加新的元素,或者完全从头开始建立它呢?</target>
        </trans-unit>
        <trans-unit id="10d195eb40678f2e435ff6368a25ea9770d7ae62" translate="yes" xml:space="preserve">
          <source>That's all you need to do on Unix systems with dynamic linking. Most Unix systems have dynamic linking. If yours doesn't, or if for another reason you have a statically-linked perl, &lt;b&gt;and&lt;/b&gt; the module requires compilation, you'll need to build a new Perl binary that includes the module. Again, you'll probably need to be root.</source>
          <target state="translated">这就是在带有动态链接的Unix系统上要做的所有事情。大多数Unix系统具有动态链接。如果没有，或者由于其他原因您拥有静态链接的perl，&lt;b&gt;并且&lt;/b&gt;模块需要编译，则需要构建一个包含该模块的新Perl二进制文件。同样，您可能需要成为root用户。</target>
        </trans-unit>
        <trans-unit id="a00ede3b70bdf4862c08ec2dce8548cbf40dc38c" translate="yes" xml:space="preserve">
          <source>That's all. Similarly for ncftp or ftp, you would configure something like</source>
          <target state="translated">就是这样。同样的,对于ncftp或ftp,你可以配置一些东西,比如说</target>
        </trans-unit>
        <trans-unit id="6a90902fefb78efc91bb4045efc7ccd96cd2b158" translate="yes" xml:space="preserve">
          <source>That's autovivification. You can get around this in a few ways. The easiest way is to just turn it off. The lexical &lt;code&gt;autovivification&lt;/code&gt; pragma is available on CPAN. Now you don't add to the hash:</source>
          <target state="translated">那就是自我生存。您可以通过几种方式解决此问题。最简单的方法是将其关闭。词汇自动 &lt;code&gt;autovivification&lt;/code&gt; 编译指示可在CPAN上找到。现在，您无需添加哈希：</target>
        </trans-unit>
        <trans-unit id="9f49d51a5d99f95a36f28eae4b0601a8a32ea05a" translate="yes" xml:space="preserve">
          <source>That's because &lt;code&gt;.*&lt;/code&gt; was greedy, so you get everything between the</source>
          <target state="translated">这是因为 &lt;code&gt;.*&lt;/code&gt; 很贪婪，因此您可以在</target>
        </trans-unit>
        <trans-unit id="1b898ba735cd15a6bd993ec3d75a6b0058359915" translate="yes" xml:space="preserve">
          <source>That's because Perl doesn't (ever) implicitly dereference your variables. If you want to get at the thing a reference is referring to, then you have to do this yourself using either prefix typing indicators, like &lt;code&gt;${$blah}&lt;/code&gt; , &lt;code&gt;@{$blah}&lt;/code&gt; , &lt;code&gt;@{$blah[$i]}&lt;/code&gt; , or else postfix pointer arrows, like &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt; , &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt; , or even &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt; .</source>
          <target state="translated">这是因为Perl不会（永远）隐式取消引用变量。如果您想了解引用所指的东西，那么您必须自己使用前缀输入指示符来完成此操作，例如 &lt;code&gt;${$blah}&lt;/code&gt; ， &lt;code&gt;@{$blah}&lt;/code&gt; ， &lt;code&gt;@{$blah[$i]}&lt;/code&gt; 。或者后缀指针箭头，例如 &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt; a- &amp;gt; [3]， &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt; ，甚至 &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7a4a3776ff01d004644640252dd53fc3704e0e2" translate="yes" xml:space="preserve">
          <source>That's because Perl doesn't (ever) implicitly dereference your variables. If you want to get at the thing a reference is referring to, then you have to do this yourself using either prefix typing indicators, like &lt;code&gt;${$blah}&lt;/code&gt;, &lt;code&gt;@{$blah}&lt;/code&gt;, &lt;code&gt;@{$blah[$i]}&lt;/code&gt;, or else postfix pointer arrows, like &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt;, &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt;, or even &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt;.</source>
          <target state="translated">这是因为Perl不会（永远）隐式取消引用您的变量。如果您想了解引用所指的内容，则必须自己使用前缀输入指示符来完成此操作，例如 &lt;code&gt;${$blah}&lt;/code&gt; ， &lt;code&gt;@{$blah}&lt;/code&gt; ， &lt;code&gt;@{$blah[$i]}&lt;/code&gt; 。或者后缀指针箭头，例如 &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt; a- &amp;gt; [3]， &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt; 甚至 &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07d4ba2bfdf5f5b21a00717fd39047d39da3c192" translate="yes" xml:space="preserve">
          <source>That's because Perl's precedence rules on its five prefix dereferencers (which look like someone swearing: &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt; ) make them bind more tightly than the postfix subscripting brackets or braces! This will no doubt come as a great shock to the C or C++ programmer, who is quite accustomed to using &lt;code&gt;*a[i]&lt;/code&gt; to mean what's pointed to by the</source>
          <target state="translated">这是因为Perl在其五个前缀解引用器上的优先级规则（看起来像在骂人： &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt; ）使它们的绑定比后缀下标括号或花括号更紧密！毫无疑问，这将给C或C ++程序员带来极大的震撼，他们相当习惯于使用 &lt;code&gt;*a[i]&lt;/code&gt; 来表示C语言所指的内容。</target>
        </trans-unit>
        <trans-unit id="41187fe54a62e820e1df501181075a2f61202104" translate="yes" xml:space="preserve">
          <source>That's because Perl's precedence rules on its five prefix dereferencers (which look like someone swearing: &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt;) make them bind more tightly than the postfix subscripting brackets or braces! This will no doubt come as a great shock to the C or C++ programmer, who is quite accustomed to using &lt;code&gt;*a[i]&lt;/code&gt; to mean what's pointed to by the</source>
          <target state="translated">这是因为Perl在其五个前缀解引用器上的优先级规则（看起来像在骂人： &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt; ）使它们的绑定比后缀下标括号或花括号更紧密！毫无疑问，这将给C或C ++程序员带来极大的冲击，他们非常习惯于使用 &lt;code&gt;*a[i]&lt;/code&gt; 来表示C语言所指的内容。</target>
        </trans-unit>
        <trans-unit id="0f393c4bb027f44afad135cf4530852dabaa1d38" translate="yes" xml:space="preserve">
          <source>That's because it treats &lt;code&gt;$fh&lt;/code&gt; as a string like &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt; , then pattern matches against that.</source>
          <target state="translated">这是因为它将 &lt;code&gt;$fh&lt;/code&gt; 视为类似于 &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt; 的字符串，然后对其进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="e5243109f1982ab10b2f341fa04b05232d301e22" translate="yes" xml:space="preserve">
          <source>That's because it treats &lt;code&gt;$fh&lt;/code&gt; as a string like &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt;, then pattern matches against that.</source>
          <target state="translated">这是因为它将 &lt;code&gt;$fh&lt;/code&gt; 视为类似于 &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt; 的字符串，然后对其进行模式匹配。</target>
        </trans-unit>
        <trans-unit id="5ef987861945b1d2e7a185649ce3d062e04bb5bf" translate="yes" xml:space="preserve">
          <source>That's because my() is more of a run-time statement than it is a compile-time declaration</source>
          <target state="translated">这是因为my()更像是一个运行时的语句,而不是编译时的声明。</target>
        </trans-unit>
        <trans-unit id="62587e053e8900b6dd6dfce6fa04010b4761573b" translate="yes" xml:space="preserve">
          <source>That's certainly better, but we still have to know how long all the integers are, and portability is far away. Rather than &lt;code&gt;2&lt;/code&gt; , for instance, we want to say &quot;however long a short is&quot;. But this can be done by enclosing the appropriate pack code in brackets: &lt;code&gt;[s]&lt;/code&gt;. So, here's the very best we can do:</source>
          <target state="translated">那当然更好，但是我们仍然必须知道所有整数有多长，并且可移植性还很遥远。例如，我们要说&amp;ldquo; 而不是 &lt;code&gt;2&lt;/code&gt; &amp;rdquo;，而不是2。但这可以通过将适当的包装代码放在方括号中来完成： &lt;code&gt;[s]&lt;/code&gt; 。因此，这是我们能做的最好的事情：</target>
        </trans-unit>
        <trans-unit id="d3165047d193a37d5ff71109d566914086cc04dd" translate="yes" xml:space="preserve">
          <source>That's certainly better, but we still have to know how long all the integers are, and portability is far away. Rather than &lt;code&gt;2&lt;/code&gt;, for instance, we want to say &quot;however long a short is&quot;. But this can be done by enclosing the appropriate pack code in brackets: &lt;code&gt;[s]&lt;/code&gt;. So, here's the very best we can do:</source>
          <target state="translated">那当然更好，但是我们仍然必须知道所有整数有多长时间，并且可移植性还很遥远。例如，我们要说&amp;ldquo;而不是 &lt;code&gt;2&lt;/code&gt; &amp;rdquo;，而不是2。但这可以通过将相应的包装代码括在方括号中来完成： &lt;code&gt;[s]&lt;/code&gt; 。因此，这是我们能做的最好的事情：</target>
        </trans-unit>
        <trans-unit id="0971c7f378d8883abc6949fc548118faa7827c21" translate="yes" xml:space="preserve">
          <source>That's faster, cleaner, and safer than the previous approach. Of course, you don't need to use a dollar sign. You could use your own scheme to make it less confusing, like bracketed percent symbols, etc.</source>
          <target state="translated">这比之前的方法更快、更干净、更安全。当然,你不需要用美元符号。你可以使用你自己的方案,让它不那么混乱,比如括号里的百分比符号等。</target>
        </trans-unit>
        <trans-unit id="c29a101730c3253b24f4d81e9d501b9e43d3a5b6" translate="yes" xml:space="preserve">
          <source>That's fine for Internet-domain clients and servers, but what about local communications? While you can use the same setup, sometimes you don't want to. Unix-domain sockets are local to the current host, and are often used internally to implement pipes. Unlike Internet domain sockets, Unix domain sockets can show up in the file system with an ls(1) listing.</source>
          <target state="translated">对于互联网域名的客户端和服务器来说,这很好,但是本地通信呢?虽然你可以使用同样的设置,但有时你并不想这样做。Unix域套接字是当前主机的本地套接字,经常被内部用来实现管道。与Internet域套接字不同,Unix域套接字可以通过ls(1)列表显示在文件系统中。</target>
        </trans-unit>
        <trans-unit id="931aa8f88f4f387e1b11a09a91636eb5c2525c4d" translate="yes" xml:space="preserve">
          <source>That's how Perl parsed the program, from top to bottom:</source>
          <target state="translated">这就是Perl对程序的解析,从上到下。</target>
        </trans-unit>
        <trans-unit id="8a9ad9d817fc65f643335d0c0e239182a33f908e" translate="yes" xml:space="preserve">
          <source>That's how it works. It's pretty simple; as with many Perl programs, the explanation is much longer than the program.</source>
          <target state="translated">这就是它的工作原理。很简单,和很多Perl程序一样,解释的时间比程序长很多。</target>
        </trans-unit>
        <trans-unit id="a4ec64876254c2b08386415f463aa4c3731a3571" translate="yes" xml:space="preserve">
          <source>That's how the &lt;code&gt;*PL_keyword_plugin&lt;/code&gt; function needs to behave overall. Conventionally, however, one does not completely replace the existing handler function. Instead, take a copy of &lt;code&gt;PL_keyword_plugin&lt;/code&gt; before assigning your own function pointer to it. Your handler function should look for keywords that it is interested in and handle those. Where it is not interested, it should call the saved plugin function, passing on the arguments it received. Thus &lt;code&gt;PL_keyword_plugin&lt;/code&gt; actually points at a chain of handler functions, all of which have an opportunity to handle keywords, and only the last function in the chain (built into the Perl core) will normally return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; .</source>
          <target state="translated">这就是 &lt;code&gt;*PL_keyword_plugin&lt;/code&gt; 函数需要整体表现的方式。但是，按照惯例，不能完全取代现有的处理函数。相反，在 &lt;code&gt;PL_keyword_plugin&lt;/code&gt; 分配自己的函数指针之前，请复制PL_keyword_plugin。您的处理程序函数应查找它感兴趣的关键字并进行处理。如果不感兴趣，则应调用已保存的插件函数，并传递其收到的参数。因此， &lt;code&gt;PL_keyword_plugin&lt;/code&gt; 实际上指向处理程序函数链，所有这些处理函数都有机会处理关键字，并且只有该链中的最后一个函数（内置在Perl内核中）通常会返回 &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b08fbd323cdcfc2a59e5f4cc2312d748230aa97" translate="yes" xml:space="preserve">
          <source>That's how the &lt;code&gt;*PL_keyword_plugin&lt;/code&gt; function needs to behave overall. Conventionally, however, one does not completely replace the existing handler function. Instead, take a copy of &lt;code&gt;PL_keyword_plugin&lt;/code&gt; before assigning your own function pointer to it. Your handler function should look for keywords that it is interested in and handle those. Where it is not interested, it should call the saved plugin function, passing on the arguments it received. Thus &lt;code&gt;PL_keyword_plugin&lt;/code&gt; actually points at a chain of handler functions, all of which have an opportunity to handle keywords, and only the last function in the chain (built into the Perl core) will normally return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt;.</source>
          <target state="translated">这就是 &lt;code&gt;*PL_keyword_plugin&lt;/code&gt; 函数需要整体表现的方式。但是，按照惯例，不能完全取代现有的处理程序功能。相反，在 &lt;code&gt;PL_keyword_plugin&lt;/code&gt; 分配自己的函数指针之前，请复制PL_keyword_plugin。您的处理程序函数应查找它感兴趣的关键字并进行处理。如果对它不感兴趣，则应调用已保存的插件函数，并传递其收到的参数。因此， &lt;code&gt;PL_keyword_plugin&lt;/code&gt; 实际上指向处理程序函数链，所有这些处理函数都有机会处理关键字，并且只有该链中的最后一个函数（内置在Perl内核中）通常会返回 &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="417bb675fe45cc9c0d3fa87fb632598764e6a64d" translate="yes" xml:space="preserve">
          <source>That's it for creating references. By now you're probably dying to know how to use references to get back to your long-lost data. There are several basic methods.</source>
          <target state="translated">创建引用的方法就到这里了。现在你可能已经迫不及待地想知道如何使用引用来找回你久违的数据了。有几种基本方法。</target>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">就是这样!</target>
        </trans-unit>
        <trans-unit id="4ad43787f3a61735da906162ae4566f1716a8e9d" translate="yes" xml:space="preserve">
          <source>That's it, you're back on home turf again.</source>
          <target state="translated">就这样,你又回到了主场。</target>
        </trans-unit>
        <trans-unit id="ad818b8edee0b9dd293a16c07bd537675f5226f7" translate="yes" xml:space="preserve">
          <source>That's just the simple case of assigning an array to a scalar and getting its element count. If that's what you really and truly want, then you might do well to consider being a tad more explicit about it, like this:</source>
          <target state="translated">这只是简单的将一个数组赋值给一个标量并获取其元素数的例子。如果这就是你真正想要的,那么你可以考虑更明确一点,比如这样。</target>
        </trans-unit>
        <trans-unit id="64d9d2742b71e9220af551f7c7046f7f081af6aa" translate="yes" xml:space="preserve">
          <source>That's not much help, a couple of welcomes in there, but no indication of which are keys, and which are values, it's just a listed array dump and, in this case, not particularly helpful. The trick here, is to use a &lt;b&gt;reference&lt;/b&gt; to the data structure:</source>
          <target state="translated">并没有太大的帮助，在这里受到了几次欢迎，但是没有迹象表明哪些是键，哪些是值，它只是列出的数组转储，在这种情况下并不是特别有用。这里的技巧是使用对数据结构的&lt;b&gt;引用&lt;/b&gt;：</target>
        </trans-unit>
        <trans-unit id="33e7ab43a8b3ad63335115c42e08832229acf410" translate="yes" xml:space="preserve">
          <source>That's not particularly efficient. It would be more space-efficient to use:</source>
          <target state="translated">这不是特别有效率。使用起来会更节省空间。</target>
        </trans-unit>
        <trans-unit id="69885b7848b259e032939450164926f255956e80" translate="yes" xml:space="preserve">
          <source>That's pretty much it. Now write</source>
          <target state="translated">这就是差不多了。现在写</target>
        </trans-unit>
        <trans-unit id="0e0f898332e33495bcec31fc5e9658f137da2c67" translate="yes" xml:space="preserve">
          <source>That's probably because you forgot libraries, or library paths differ. You really should build the whole distribution on the machine it will eventually live on, and then type &lt;code&gt;make install&lt;/code&gt; . Most other approaches are doomed to failure.</source>
          <target state="translated">那可能是因为您忘记了库，或者库路径不同。您确实应该在最终将运行的机器上构建整个发行版，然后键入 &lt;code&gt;make install&lt;/code&gt; 。大多数其他方法注定要失败。</target>
        </trans-unit>
        <trans-unit id="bd1f4414e3c5b98a871dc22bff9ce2a5552a8c42" translate="yes" xml:space="preserve">
          <source>That's probably because you forgot libraries, or library paths differ. You really should build the whole distribution on the machine it will eventually live on, and then type &lt;code&gt;make install&lt;/code&gt;. Most other approaches are doomed to failure.</source>
          <target state="translated">那可能是因为您忘记了库，或者库路径不同。您确实应该在最终将运行的机器上构建整个发行版，然后键入 &lt;code&gt;make install&lt;/code&gt; 。大多数其他方法注定要失败。</target>
        </trans-unit>
        <trans-unit id="a1f563351f204013afa271606ba9bd745aa56dda" translate="yes" xml:space="preserve">
          <source>That's shown below, in a program I'll call</source>
          <target state="translated">如下图所示,在一个程序中,我称之为</target>
        </trans-unit>
        <trans-unit id="651cfe39b8f69bca0fd98eae5d4edf4fd6370a67" translate="yes" xml:space="preserve">
          <source>That's where the glue code can be inserted to create the initial contact between Perl and linked C/C++ routines. Let's take a look some pieces of</source>
          <target state="translated">这就是可以插入胶水代码的地方,以建立Perl和链接的C/C++例程之间的初始接触。让我们来看看一些</target>
        </trans-unit>
        <trans-unit id="9608b4f77e4cb870b25879f8aef6ee06bf6a1b9f" translate="yes" xml:space="preserve">
          <source>That's why &lt;code&gt;STORABLE_freeze&lt;/code&gt; lets you provide a list of references to serialize. The engine guarantees that those will be serialized in the same context as the other objects, and therefore that shared objects will stay shared.</source>
          <target state="translated">这就是为什么 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 允许您提供要序列化的引用列表。引擎保证将在与其他对象相同的上下文中序列化这些对象，因此共享对象将保持共享状态。</target>
        </trans-unit>
        <trans-unit id="735b594fd42209c8688db3bd34982beb910ab493" translate="yes" xml:space="preserve">
          <source>That's why they're called 'options'.</source>
          <target state="translated">这就是为什么他们被称为 &quot;选项&quot;。</target>
        </trans-unit>
        <trans-unit id="8301b3f815f17c3dd7076e96039e1678841b82a4" translate="yes" xml:space="preserve">
          <source>Thatclassname</source>
          <target state="translated">Thatclassname</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="2ebc0d199c8eb44a7ac92ea22e10498f30092a55" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; above stands for some Unicode version number, such as &lt;code&gt;1.1&lt;/code&gt; or &lt;code&gt;12.0&lt;/code&gt;; or the &quot;*&quot; can also be &lt;code&gt;Unassigned&lt;/code&gt;. This property will match the code points whose final disposition has been settled as of the Unicode release given by the version number; &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; will match those code points whose meaning has yet to be assigned.</source>
          <target state="translated">上面的&amp;ldquo; *&amp;rdquo;代表一些Unicode版本号，例如 &lt;code&gt;1.1&lt;/code&gt; 或 &lt;code&gt;12.0&lt;/code&gt; ；或&amp;ldquo; *&amp;rdquo;也可以是 &lt;code&gt;Unassigned&lt;/code&gt; 。此属性将匹配由版本号指定的Unicode发行版中已确定最终处置的代码点； &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; 将匹配尚未分配其含义的那些代码点。</target>
        </trans-unit>
        <trans-unit id="6f203dc849e9f4f723b6a77e413f463ccf14a492" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; above stands for some two digit Unicode version number, such as &lt;code&gt;1.1&lt;/code&gt; or &lt;code&gt;4.0&lt;/code&gt; ; or the &quot;*&quot; can also be &lt;code&gt;Unassigned&lt;/code&gt; . This property will match the code points whose final disposition has been settled as of the Unicode release given by the version number; &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; will match those code points whose meaning has yet to be assigned.</source>
          <target state="translated">上面的&amp;ldquo; *&amp;rdquo;代表两位数字的Unicode版本号，例如 &lt;code&gt;1.1&lt;/code&gt; 或 &lt;code&gt;4.0&lt;/code&gt; ；或&amp;ldquo; *&amp;rdquo;也可以是 &lt;code&gt;Unassigned&lt;/code&gt; 。此属性将匹配由版本号指定的Unicode版本中已确定最终处置的代码点； &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; 将匹配那些尚未分配其含义的代码点。</target>
        </trans-unit>
        <trans-unit id="a22d3668e744bc1f40c2f7d6bd90a8803737c69c" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; character will be replaced with the complete input filename.</source>
          <target state="translated">&quot;*&quot;字符将被替换为完整的输入文件名。</target>
        </trans-unit>
        <trans-unit id="3b9595dacd7d80fdab60d4dc5871376b0675fb8c" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; quantifier is equivalent to &lt;code&gt;{0,}&lt;/code&gt; , the &quot;+&quot; quantifier to &lt;code&gt;{1,}&lt;/code&gt; , and the &quot;?&quot; quantifier to &lt;code&gt;{0,1}&lt;/code&gt; . n and m are limited to non-negative integral values less than a preset limit defined when perl is built. This is usually 32766 on the most common platforms. The actual limit can be seen in the error message generated by code such as this:</source>
          <target state="translated">&amp;ldquo; *&amp;rdquo;量词等效于 &lt;code&gt;{0,}&lt;/code&gt; ，&amp;ldquo; +&amp;rdquo;量词等效于 &lt;code&gt;{1,}&lt;/code&gt; ，而&amp;ldquo;？&amp;rdquo; &lt;code&gt;{0,1}&lt;/code&gt; 的量词。n和m限于非负整数值，该值小于构建perl时定义的预设极限。在最常见的平台上，通常为32766。实际限制可以在由以下代码生成的错误消息中看到：</target>
        </trans-unit>
        <trans-unit id="ef1a900f188939b7338bcc6047d7f99f423bcf86" translate="yes" xml:space="preserve">
          <source>The &quot;:&quot; on these identifiers means simply &quot;process this stuff normally, even though the result will be for some special target&quot;. I suggest that parser APIs report &quot;biblio&quot; as the target identifier, but also report that it had a &quot;:&quot; prefix. (And similarly, with the above &quot;html&quot;, report &quot;html&quot; as the target identifier, and note the</source>
          <target state="translated">这些标识符上的&quot;:&quot;的意思只是 &quot;正常处理这个东西,尽管结果会是为了某个特殊的目标&quot;。我建议解析器API报告 &quot;biblio &quot;作为目标标识符,但也报告它有一个&quot;:&quot;前缀。(同样的,上面的 &quot;html&quot;,报告 &quot;html &quot;作为目标标识符,并注意到它的</target>
        </trans-unit>
        <trans-unit id="64b5d9da126d3d99727eec1708f648b1bd4f7983" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;rules&lt;/code&gt; &quot; data structure is the the heart of the scheduler. It allows you to express simple rules like &quot;run all tests in sequence&quot; or &quot;run all tests in parallel except these five tests.&quot;. However, the rules structure also supports glob-style pattern matching and recursive definitions, so you can also express arbitarily complicated patterns.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;rules&lt;/code&gt; &amp;rdquo;数据结构是调度程序的核心。它允许您表达一些简单的规则，例如&amp;ldquo;依次运行所有测试&amp;rdquo;或&amp;ldquo;并行运行除这五个测试以外的所有测试&amp;rdquo;。但是，规则结构还支持全局样式模式匹配和递归定义，因此您还可以表达任意复杂的模式。</target>
        </trans-unit>
        <trans-unit id="2ed0d091df98bc8db977a3f32a7cda06b5707b99" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;rules&lt;/code&gt;&quot; data structure is the the heart of the scheduler. It allows you to express simple rules like &quot;run all tests in sequence&quot; or &quot;run all tests in parallel except these five tests.&quot;. However, the rules structure also supports glob-style pattern matching and recursive definitions, so you can also express arbitarily complicated patterns.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;rules&lt;/code&gt; &amp;rdquo;数据结构是调度程序的核心。它允许您表达简单的规则，例如&amp;ldquo;依次运行所有测试&amp;rdquo;或&amp;ldquo;并行运行除这五个测试以外的所有测试&amp;rdquo;。但是，规则结构还支持glob样式的模式匹配和递归定义，因此您还可以表达任意复杂的模式。</target>
        </trans-unit>
        <trans-unit id="1074d5a9a7dcd2040a3f0c45e46a4676237c27c8" translate="yes" xml:space="preserve">
          <source>The &quot;=begin</source>
          <target state="translated">的&quot;=begin</target>
        </trans-unit>
        <trans-unit id="15a448a46373702e33d38bd4498490c44fd2b70f" translate="yes" xml:space="preserve">
          <source>The &quot;=item [text]&quot; paragraph should not match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\*\s*\z/&lt;/a&gt;&lt;/code&gt;, nor should it match just &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s*\z/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; = item [text]&amp;rdquo;段不应与 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\*\s*\z/&lt;/a&gt;&lt;/code&gt; 匹配，也不得与它应该只匹配 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s*\z/&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb00107a8cd7306f310a4e41cd2188b092574511" translate="yes" xml:space="preserve">
          <source>The &quot;=item [text]&quot; paragraph should not match &lt;code&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/code&gt; or &lt;code&gt;m/\A=item\s+\*\s*\z/&lt;/code&gt;, nor should it match just &lt;code&gt;m/\A=item\s*\z/&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; = item [text]&amp;rdquo;段不应与 &lt;code&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/code&gt; 或 &lt;code&gt;m/\A=item\s+\*\s*\z/&lt;/code&gt; 匹配，也不得与它应该只匹配 &lt;code&gt;m/\A=item\s*\z/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66cea2af4ab6ab309f2a49ef717323c3929bef20" translate="yes" xml:space="preserve">
          <source>The &quot;=pod&quot; command by itself doesn't do much of anything, but it signals to Perl (and Pod formatters) that a Pod block starts here. A Pod block starts with</source>
          <target state="translated">&quot;=pod &quot;命令本身并没有什么作用,但它向Perl(和Pod格式化器)发出了一个Pod块从这里开始的信号。一个Pod块的开头是</target>
        </trans-unit>
        <trans-unit id="45c9bcf242eeaf20585053facd6dddbfcd2e77f0" translate="yes" xml:space="preserve">
          <source>The &quot;English&quot; operators (&lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt; , and &lt;code&gt;not&lt;/code&gt; ) deliberately have precedence lower than that of list operators for just such situations as the one above.</source>
          <target state="translated">在&amp;ldquo;英语&amp;rdquo;运营商（ &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;xor&lt;/code&gt; ，而 &lt;code&gt;not&lt;/code&gt; ）故意具有优先级比列表操作为这样的情况，如上图所示的低。</target>
        </trans-unit>
        <trans-unit id="c776db1d67057122c329ee64bd76a151ecfea104" translate="yes" xml:space="preserve">
          <source>The &quot;English&quot; operators (&lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;xor&lt;/code&gt;, and &lt;code&gt;not&lt;/code&gt;) deliberately have precedence lower than that of list operators for just such situations as the one above.</source>
          <target state="translated">在&amp;ldquo;英语&amp;rdquo;运营商（ &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;xor&lt;/code&gt; ，而 &lt;code&gt;not&lt;/code&gt; ）故意具有优先级比列表操作为这样的情况，如上图所示的低。</target>
        </trans-unit>
        <trans-unit id="00c4bf3828130bdd16f6f681093f66656168cc64" translate="yes" xml:space="preserve">
          <source>The &quot;MIT&quot; License</source>
          <target state="translated">&quot;MIT &quot;许可证</target>
        </trans-unit>
        <trans-unit id="809b368cf33985ff1e068eaf70e57337041ab266" translate="yes" xml:space="preserve">
          <source>The &quot;Tree&quot; subsubsection in XML::Parser</source>
          <target state="translated">XML::Parser中的 &quot;Tree &quot;子节。</target>
        </trans-unit>
        <trans-unit id="f6804bf4d1b752ec09b4b554040a4294aa2c28e2" translate="yes" xml:space="preserve">
          <source>The &quot;U&quot; mode is modeled on Python's &quot;Universal Newlines&quot; concept, whereby DOS and Mac OS line terminators are converted internally to UNIX newlines before processing. This ensures consistent digest values when working simultaneously across multiple file systems. &lt;b&gt;The &quot;U&quot; mode influences only text files&lt;/b&gt;, namely those passing Perl's</source>
          <target state="translated">&amp;ldquo; U&amp;rdquo;模式以Python的&amp;ldquo; Universal Newlines&amp;rdquo;概念为模型，在此之前，DOS和Mac OS行终止符在处理之前在内部转换为UNIX换行符。这样可以确保在多个文件系统中同时工作时摘要值保持一致。&lt;b&gt;&amp;ldquo; U&amp;rdquo;模式仅影响文本文件&lt;/b&gt;，即那些通过Perl的文件</target>
        </trans-unit>
        <trans-unit id="3825414166fcae7ca1f01fa808eb7b2edebcc1b6" translate="yes" xml:space="preserve">
          <source>The &quot;Unicode Bug&quot;</source>
          <target state="translated">&quot;Unicode Bug&quot;</target>
        </trans-unit>
        <trans-unit id="0ec3a96aade5dbc6ee323c533eb4507821e58ebe" translate="yes" xml:space="preserve">
          <source>The &quot;access&quot; sub-pragma</source>
          <target state="translated">&quot;访问 &quot;子原则</target>
        </trans-unit>
        <trans-unit id="c5bfb037ae6662a8b7a6614931ff100518e1954f" translate="yes" xml:space="preserve">
          <source>The &quot;bad interpreter&quot; message comes from the shell, not perl. The actual message may vary depending on your platform, shell, and locale settings.</source>
          <target state="translated">坏的解释器 &quot;消息来自shell,而不是perl。实际的消息可能会根据你的平台、shell和locale设置而有所不同。</target>
        </trans-unit>
        <trans-unit id="7324c65fe364cafe1f0b648f9b09ee839b62c197" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;else&quot;&gt;else&lt;/a&gt; &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;&lt;/code&gt; either. It does parse &lt;code&gt;&lt;a href=&quot;elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="translated">在Perl中，&amp;ldquo; else if&amp;rdquo;关键字拼写为 &lt;code&gt;elsif&lt;/code&gt; 。没有 &lt;code&gt;elif&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;else&quot;&gt;else&lt;/a&gt; &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;&lt;/code&gt; 没有。它会解析 &lt;code&gt;&lt;a href=&quot;elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt; ，但是只是警告您不要使用它。</target>
        </trans-unit>
        <trans-unit id="dcec7b786aaf98a8eb4d77d89e7fe0ef405e7fc1" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;else if&lt;/code&gt; either. It does parse &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="translated">在Perl中，&amp;ldquo; else if&amp;rdquo;关键字拼写为 &lt;code&gt;elsif&lt;/code&gt; 。没有 &lt;code&gt;elif&lt;/code&gt; ， &lt;code&gt;else if&lt;/code&gt; 没有。它会解析 &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt; ，但是只是警告您不要使用它。</target>
        </trans-unit>
        <trans-unit id="376964f7b7dc051fc5e877b839e65e771ea6ae93" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;else if&lt;/code&gt; either. It does parse &lt;code&gt;elseif&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="translated">&amp;ldquo; else if&amp;rdquo;关键字在Perl中拼写为 &lt;code&gt;elsif&lt;/code&gt; 。没有 &lt;code&gt;elif&lt;/code&gt; ， &lt;code&gt;else if&lt;/code&gt; 没有。它会解析 &lt;code&gt;elseif&lt;/code&gt; ，但是只是警告您不要使用它。</target>
        </trans-unit>
        <trans-unit id="de0a3bbed813bc00b5b829d702e3237f3e106a1b" translate="yes" xml:space="preserve">
          <source>The &quot;fail&quot; attribute can be accessed with the &lt;code&gt;fail_with&lt;/code&gt; method:</source>
          <target state="translated">可以使用 &lt;code&gt;fail_with&lt;/code&gt; 方法访问&amp;ldquo; fail&amp;rdquo;属性：</target>
        </trans-unit>
        <trans-unit id="f145fe55bdca7d5323b2fa4d4c3d2d68727a4e71" translate="yes" xml:space="preserve">
          <source>The &quot;grab all you can, and do not give anything back&quot; semantic is desirable in many situations where on the first sight a simple &lt;code&gt;()*&lt;/code&gt; looks like the correct solution. Suppose we parse text with comments being delimited by &lt;code&gt;&quot;#&quot;&lt;/code&gt; followed by some optional (horizontal) whitespace. Contrary to its appearance, &lt;code&gt;#[ \t]*&lt;/code&gt;</source>
          <target state="translated">在许多情况下，&amp;ldquo;乍看之下，尽力而为，不要回馈&amp;rdquo;语义是可取的，这些情况乍一看，简单的 &lt;code&gt;()*&lt;/code&gt; 似乎是正确的解决方案。假设我们解析文本时，注释以 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 分隔，后面是一些可选的（水平）空格。与外观相反， &lt;code&gt;#[ \t]*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3cfcc407b9b43637eb6bd977679586bbeebf2328" translate="yes" xml:space="preserve">
          <source>The &quot;grab all you can, and do not give anything back&quot; semantic is desirable in many situations where on the first sight a simple &lt;code&gt;()*&lt;/code&gt; looks like the correct solution. Suppose we parse text with comments being delimited by &lt;code&gt;#&lt;/code&gt; followed by some optional (horizontal) whitespace. Contrary to its appearance, &lt;code&gt;#[ \t]*&lt;/code&gt;</source>
          <target state="translated">在许多情况下，&amp;ldquo;乍看之下，尽力而为，不要回馈&amp;rdquo;语义是可取的，这些情况乍一看，简单的 &lt;code&gt;()*&lt;/code&gt; 看起来像是正确的解决方案。假设我们用 &lt;code&gt;#&lt;/code&gt; 分隔注释，然后加上一些可选的（水平）空格，来解析文本。与外观相反， &lt;code&gt;#[ \t]*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43c9200741055f798210ca5b9a02d181e70102c1" translate="yes" xml:space="preserve">
          <source>The &quot;in most cases&quot; hedge is because local TCP state machine behavior may depend on the peer's socket options. In particular, if the peer socket has &lt;code&gt;SO_LINGER&lt;/code&gt; enabled with a zero timeout, then the peer's &lt;code&gt;close&lt;/code&gt; will generate a &lt;code&gt;RST&lt;/code&gt; segment. Upon receipt of that segment, the local TCP transitions immediately to &lt;b&gt;CLOSED&lt;/b&gt;, and in that state, this method</source>
          <target state="translated">&amp;ldquo;在大多数情况下&amp;rdquo;对冲是因为本地TCP状态机的行为可能取决于对等方的套接字选项。特别是，如果对等套接字启用了 &lt;code&gt;SO_LINGER&lt;/code&gt; 且超时为零，则对等套接字的 &lt;code&gt;close&lt;/code&gt; 将生成 &lt;code&gt;RST&lt;/code&gt; 段。收到该段后，本地TCP立即转换为&lt;b&gt;CLOSED&lt;/b&gt;，在该状态下，此方法</target>
        </trans-unit>
        <trans-unit id="a64504831dda4d8442cac5969f1512970ea2ab8e" translate="yes" xml:space="preserve">
          <source>The &quot;in most cases&quot; hedge is because local TCP state machine behavior may depend on the peer's socket options. In particular, if the peer socket has SO_LINGER enabled with a zero timeout, then the peer's close() will generate a RST segment, upon receipt of which the local TCP transitions immediately to &lt;b&gt;CLOSED&lt;/b&gt;, and in that state, connected()</source>
          <target state="translated">&amp;ldquo;在大多数情况下&amp;rdquo;对冲是因为本地TCP状态机的行为可能取决于对等方的套接字选项。特别是，如果对等套接字启用了SO_LINGER且超时为零，则对等方的close（）将生成一个RST段，在接收到该段后，本地TCP会立即转换为&lt;b&gt;CLOSED&lt;/b&gt;，并且在该状态下为connected（）</target>
        </trans-unit>
        <trans-unit id="191bee2290fcd83ba60b79d930b2194e317ac84f" translate="yes" xml:space="preserve">
          <source>The &quot;inode change timestamp&quot; (the &lt;a href=&quot;perlfunc#-X-FILEHANDLE&quot;&gt;&lt;code&gt;-C&lt;/code&gt;&lt;/a&gt; filetest) may really be the &quot;creation timestamp&quot; (which it is not in Unix).</source>
          <target state="translated">&amp;ldquo; inode更改时间戳&amp;rdquo;（&lt;a href=&quot;perlfunc#-X-FILEHANDLE&quot;&gt; &lt;code&gt;-C&lt;/code&gt; &lt;/a&gt; filetest）实际上可能是&amp;ldquo;创建时间戳&amp;rdquo;（在Unix中不是）。</target>
        </trans-unit>
        <trans-unit id="97ff934381d4470548d727908956bd70f3d20831" translate="yes" xml:space="preserve">
          <source>The &quot;inode change timestamp&quot; (the &lt;code&gt;-C&lt;/code&gt; filetest) may really be the &quot;creation timestamp&quot; (which it is not in Unix).</source>
          <target state="translated">&amp;ldquo; inode更改时间戳&amp;rdquo;（ &lt;code&gt;-C&lt;/code&gt; filetest）实际上可能是&amp;ldquo;创建时间戳&amp;rdquo;（在Unix中不是）。</target>
        </trans-unit>
        <trans-unit id="d5dae6e25029009f346d93a94005c0b2df86ea03" translate="yes" xml:space="preserve">
          <source>The &quot;interpreter-based threads&quot; provided by Perl are not the fast, lightweight system for multitasking that one might expect or hope for. Threads are implemented in a way that make them easy to misuse. Few people know how to use them correctly or will be able to provide help.</source>
          <target state="translated">Perl提供的 &quot;基于解释器的线程 &quot;并不是人们所期待或希望的快速、轻量级的多任务系统。线程的实现方式使得它们很容易被滥用。很少有人知道如何正确使用它们,或者能够提供帮助。</target>
        </trans-unit>
        <trans-unit id="17303b20d10d9ca1d72a771659e0ed0ddf3d30b9" translate="yes" xml:space="preserve">
          <source>The &quot;interpreter-based threads&quot; provided by Perl are not the fast, lightweight system for multitasking that one might expect or hope for. Threads are implemented in a way that makes them easy to misuse. Few people know how to use them correctly or will be able to provide help.</source>
          <target state="translated">Perl提供的 &quot;基于解释器的线程 &quot;并不是人们所期待或希望的快速、轻量级的多任务系统。线程的实现方式使得它们很容易被滥用。很少有人知道如何正确使用它们,或者能够提供帮助。</target>
        </trans-unit>
        <trans-unit id="611cc4fe5613cabb6ac2b4cb6c84bf4897881a2a" translate="yes" xml:space="preserve">
          <source>The &quot;like&quot; code entry is not always an exact rendition. For example, the smartmatch operator short-circuits whenever possible, but &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; does not. Also, &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in scalar context returns the number of matches, but &lt;code&gt;~~&lt;/code&gt; returns only true or false.</source>
          <target state="translated">&amp;ldquo; like&amp;rdquo;代码条目并不总是精确的表示形式。例如，smartmatch运算符会在可能的情况下短路，但 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 不会。同样，标量上下文中的 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 返回匹配的数量，但是 &lt;code&gt;~~&lt;/code&gt; 仅返回true或false。</target>
        </trans-unit>
        <trans-unit id="6ea890b70f56a5f9e0d36cf926a8647084d27520" translate="yes" xml:space="preserve">
          <source>The &quot;like&quot; code entry is not always an exact rendition. For example, the smartmatch operator short-circuits whenever possible, but &lt;code&gt;grep&lt;/code&gt; does not. Also, &lt;code&gt;grep&lt;/code&gt; in scalar context returns the number of matches, but &lt;code&gt;~~&lt;/code&gt; returns only true or false.</source>
          <target state="translated">&amp;ldquo; like&amp;rdquo;代码条目并不总是精确的表示形式。例如，smartmatch运算符会在可能的情况下短路，但 &lt;code&gt;grep&lt;/code&gt; 不会。同样，标量上下文中的 &lt;code&gt;grep&lt;/code&gt; 返回匹配的数量，但是 &lt;code&gt;~~&lt;/code&gt; 仅返回true或false。</target>
        </trans-unit>
        <trans-unit id="812d0b36924ed8327e26e7bd66db9f34693b1e0d" translate="yes" xml:space="preserve">
          <source>The &quot;locked&quot; attribute is deprecated, and has no effect in 5.10.0 and later. It was used as part of the now-removed &quot;Perl 5.005 threads&quot;.</source>
          <target state="translated">&quot;locked &quot;属性已被废弃,在5.10.0及以后的版本中没有效果。它曾被用作现已被移除的 &quot;Perl 5.005线程 &quot;的一部分。</target>
        </trans-unit>
        <trans-unit id="9dcce4d393c04df7e129e843600a4cbb41352ba2" translate="yes" xml:space="preserve">
          <source>The &quot;make test&quot; step runs a Perl Verification Procedure, usually before installation. You might encounter STDERR messages even during a successful run of &quot;make test&quot;. Here is a guide to some of the more commonly seen anomalies:</source>
          <target state="translated">&quot;make test &quot;步骤通常在安装前运行Perl验证过程。即使在成功运行 &quot;make test &quot;期间,你也可能会遇到STDERR消息。下面是一些比较常见的异常情况的指南。</target>
        </trans-unit>
        <trans-unit id="c90503a55170e15efc4d9ae431c0e36ee6a25e33" translate="yes" xml:space="preserve">
          <source>The &quot;maketext&quot; Method</source>
          <target state="translated">&quot;maketext &quot;方法</target>
        </trans-unit>
        <trans-unit id="7968697304f2035aa2639422d611288498d75cab" translate="yes" xml:space="preserve">
          <source>The &quot;mro&quot; namespace provides several utilities for dealing with method resolution order and method caching in general.</source>
          <target state="translated">mro &quot;命名空间为处理方法解析顺序和一般的方法缓存提供了几个实用程序。</target>
        </trans-unit>
        <trans-unit id="71bf414e13a483c3f8866e169ca7ae68644d2c78" translate="yes" xml:space="preserve">
          <source>The &quot;next&quot; pointers of all regops except &lt;code&gt;BRANCH&lt;/code&gt; implement concatenation; a &quot;next&quot; pointer with a &lt;code&gt;BRANCH&lt;/code&gt; on both ends of it is connecting two alternatives. [Here we have one of the subtle syntax dependencies: an individual &lt;code&gt;BRANCH&lt;/code&gt; (as opposed to a collection of them) is never concatenated with anything because of operator precedence.]</source>
          <target state="translated">除 &lt;code&gt;BRANCH&lt;/code&gt; 之外，所有重新绑定的&amp;ldquo; next&amp;rdquo;指针都实现了串联。两端带有 &lt;code&gt;BRANCH&lt;/code&gt; 的&amp;ldquo;下一个&amp;rdquo;指针正在连接两个替代项。[这里我们有一个微妙的语法依赖关系：由于运算符的优先级，单个 &lt;code&gt;BRANCH&lt;/code&gt; （而不是它们的集合）从未与任何东西连接在一起。</target>
        </trans-unit>
        <trans-unit id="7475859558b8ac99b6dbae28949b5ee5991af403" translate="yes" xml:space="preserve">
          <source>The &quot;p&quot; mode differs from &quot;U&quot; only in that it treats &quot;\r\r\n&quot; as a single newline, a quirky feature designed to accommodate legacy applications that occasionally added an extra carriage return before DOS line terminators. The &quot;p&quot; mode will be phased out eventually in favor of the cleaner and more well-established Universal Newlines concept.</source>
          <target state="translated">&quot;p &quot;模式与 &quot;U &quot;模式的不同之处仅在于它将&quot;/rr/rr/n &quot;作为一个新行来处理,这是一个奇特的功能,目的是为了适应传统的应用程序,这些应用程序有时会在DOS行结束符前增加一个额外的回车。&quot;p &quot;模式最终将被淘汰,取而代之的是更简洁、更完善的通用新行概念。</target>
        </trans-unit>
        <trans-unit id="21a4e20c8659f7cc84f2dc6e2b2235449667f421" translate="yes" xml:space="preserve">
          <source>The &quot;prototype&quot; attribute is an alternate means of specifying a prototype on a sub. The desired prototype is within the parens.</source>
          <target state="translated">prototype &quot;属性是在子上指定原型的另一种方式。所需的原型在parens中。</target>
        </trans-unit>
        <trans-unit id="dd5b998a91e6bf19722acfe03146f25538072352" translate="yes" xml:space="preserve">
          <source>The &quot;quality&quot; of a hash is defined as the total number of comparisons needed to access every element once, relative to the expected number needed for a random hash. The value can go over 100%.</source>
          <target state="translated">哈希的 &quot;质量 &quot;定义为:相对于随机哈希所需的预期数量,每一个元素访问一次所需的比较总数。该值可以超过100%。</target>
        </trans-unit>
        <trans-unit id="0fa71c4992e21ca9d0f8816931658731741f8823" translate="yes" xml:space="preserve">
          <source>The &quot;root&quot; of the namespace (i.e. &quot;main::&quot;) is changed to a different package and code evaluated in the compartment cannot refer to variables outside this namespace, even with run-time glob lookups and other tricks.</source>
          <target state="translated">命名空间的 &quot;根&quot;(即 &quot;main::&quot;)被改成了不同的包,在分格中评估的代码不能引用这个命名空间之外的变量,即使使用运行时的glob查找和其他技巧。</target>
        </trans-unit>
        <trans-unit id="40e9eeb816659a4d78537c8ea14e7c775679daaf" translate="yes" xml:space="preserve">
          <source>The &quot;status value&quot; returned in &lt;code&gt;$?&lt;/code&gt; is synthesized from the actual exit status of the subprocess in a way that approximates POSIX wait(5) semantics, in order to allow Perl programs to portably test for successful completion of subprocesses. The low order 8 bits of &lt;code&gt;$?&lt;/code&gt; are always 0 under VMS, since the termination status of a process may or may not have been generated by an exception.</source>
          <target state="translated">以&amp;ldquo; &lt;code&gt;$?&lt;/code&gt; &amp;rdquo;返回的&amp;ldquo;状态值&amp;rdquo; ？通过近似于POSIX wait（5）语义的方式，从子流程的实际退出状态中合成出来，以允许Perl程序可移植地测试子流程的成功完成。 &lt;code&gt;$?&lt;/code&gt; 的低8位 在VMS下，始终为0，因为异常可能已生成或可能未生成进程的终止状态。</target>
        </trans-unit>
        <trans-unit id="9220e93c05c2e58fcb6c44f1b19d591bad6f075c" translate="yes" xml:space="preserve">
          <source>The &quot;unique&quot; attribute is deprecated, and has no effect in 5.10.0 and later. It used to indicate that a single copy of an &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; variable was to be used by all interpreters should the program happen to be running in a multi-interpreter environment.</source>
          <target state="translated">&amp;ldquo; unique&amp;rdquo;属性已弃用，在5.10.0及更高版本中无效。它曾经表示如果程序恰好在多解释器环境中运行，则所有解释器都将使用 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 变量的单个副本。</target>
        </trans-unit>
        <trans-unit id="72e1eabd61e84fec8e9b71e8964b6733954ac85d" translate="yes" xml:space="preserve">
          <source>The &quot;use locale&quot; pragma</source>
          <target state="translated">&quot;使用locale &quot;pragma</target>
        </trans-unit>
        <trans-unit id="ec6d1363cbbe06a4225f4f4c8cb504676b9d9ab8" translate="yes" xml:space="preserve">
          <source>The &quot;version&quot; key has a reference to an AV as its value</source>
          <target state="translated">&quot;版本 &quot;键的值是对AV的引用。</target>
        </trans-unit>
        <trans-unit id="127c26381686cdc6cb6db8e06a75ac1b05a13d0e" translate="yes" xml:space="preserve">
          <source>The #endif and #else cannot portably have anything non-comment after them. If you want to document what is going (which is a good idea especially if the branches are long), use (C) comments:</source>
          <target state="translated">在#endif和#else后面不能有任何非注释的东西。如果你想记录正在发生的事情(这是一个好主意,尤其是当分支很长的时候),使用(C)注释。</target>
        </trans-unit>
        <trans-unit id="6d394482dea20b84087d97ed59f1a7ab0353698f" translate="yes" xml:space="preserve">
          <source>The $algorithm is a string like &quot;MD2&quot;, &quot;MD5&quot;, &quot;SHA-1&quot;, &quot;SHA-512&quot;. Additional arguments are passed to the constructor for the implementation of the given algorithm.</source>
          <target state="translated">算法是一个字符串,如 &quot;MD2&quot;、&quot;MD5&quot;、&quot;SHA-1&quot;、&quot;SHA-512&quot;。额外的参数被传递给构造函数,用于实现给定算法。</target>
        </trans-unit>
        <trans-unit id="060c7393d1a230b15152f168cb6702d886a2c8e8" translate="yes" xml:space="preserve">
          <source>The $always_copy parameter which when true causes files to be updated regardless as to whether they have changed, if it is defined but false then copies are made only if the files have changed, if it is undefined then the value of the environment variable EU_INSTALL_ALWAYS_COPY is used as default.</source>
          <target state="translated">当$always_copy参数为true时,无论文件是否发生变化都会被更新,如果定义为false,那么只有当文件发生变化时才会进行拷贝,如果未定义,那么环境变量EU_INSTALL_ALWAYS的值为默认值。</target>
        </trans-unit>
        <trans-unit id="2195889fc63370a441ff8bf1c8a9db960470ff14" translate="yes" xml:space="preserve">
          <source>The $buffer should be a Storable image or the first few bytes of it. If $buffer starts with a Storable header, then a hash describing the image is returned, otherwise &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">$ buffer应该是可存储映像或它的前几个字节。如果$ buffer以Storable头开头，则返回描述该图像的哈希，否则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78cacc3a4b41df98d6d490128b52baa4b5d2d0fc" translate="yes" xml:space="preserve">
          <source>The $buffer should be a Storable image or the first few bytes of it. If $buffer starts with a Storable header, then a hash describing the image is returned, otherwise &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">$ buffer应该是可存储映像或它的前几个字节。如果$ buffer以Storable头开头，则返回描述该图像的哈希，否则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f90557aa2dce112e348d655279a7a2af9b8d9198" translate="yes" xml:space="preserve">
          <source>The $chld_in filehandle will have autoflush turned on.</source>
          <target state="translated">$chld_in文件柄将开启自动刷新功能。</target>
        </trans-unit>
        <trans-unit id="45f3f95232308dda6cf28aa29e85f72c7757c618" translate="yes" xml:space="preserve">
          <source>The $data provided as argument are appended to the message we calculate the digest for. The return value is the $md5 object itself.</source>
          <target state="translated">作为参数提供的$data被附加到我们计算摘要的消息中。返回值是$md5对象本身。</target>
        </trans-unit>
        <trans-unit id="0b852897867aa68fb0b59cef6457c36880f5fe89" translate="yes" xml:space="preserve">
          <source>The $f that has &quot;bar&quot; added to it three times should be a new &lt;code&gt;$f&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; should create a new lexical variable each time through the loop. The expected output is:</source>
          <target state="translated">添加了&amp;ldquo; bar&amp;rdquo; 3次的 &lt;code&gt;$f&lt;/code&gt; 应该是一个新的$ f &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; 应该在循环中每次创建一个新的词法变量。预期的输出是：</target>
        </trans-unit>
        <trans-unit id="9804e7c51be3b218136a0732d780cc554d28fa80" translate="yes" xml:space="preserve">
          <source>The $f that has &quot;bar&quot; added to it three times should be a new &lt;code&gt;$f&lt;/code&gt;&lt;code&gt;my $f&lt;/code&gt; should create a new lexical variable each time through the loop. The expected output is:</source>
          <target state="translated">添加了&amp;ldquo; bar&amp;rdquo; 3次的 &lt;code&gt;$f&lt;/code&gt; 应该是一个新的$ f &lt;code&gt;my $f&lt;/code&gt; 应该在整个循环中每次创建一个新的词法变量。预期的输出是：</target>
        </trans-unit>
        <trans-unit id="1718e632a613e4c3f044b1d3a129d6229eab251a" translate="yes" xml:space="preserve">
          <source>The $filename parameter is used by Perl to identify the source file for the function if required by die(), caller() or the debugger. If $filename is not defined then &quot;DynaLoader&quot; will be used.</source>
          <target state="translated">如果die()、caller()或debugger需要,$filename参数被Perl用来识别函数的源文件。如果没有定义$filename,那么将使用 &quot;DynaLoader&quot;。</target>
        </trans-unit>
        <trans-unit id="84c0a13d8949255c1b3abd5830e5bb4ca9af26b0" translate="yes" xml:space="preserve">
          <source>The $flags argument to alters dl_load_file behaviour. Assigned bits:</source>
          <target state="translated">改变dl_load_file行为的$flags参数。赋值位。</target>
        </trans-unit>
        <trans-unit id="533efbe36456ad5f0b2eb4a7940fb956d6dc8359" translate="yes" xml:space="preserve">
          <source>The $host argument can be omitted when specifying the &lt;code&gt;host&lt;/code&gt; option to new().</source>
          <target state="translated">在为new（）指定 &lt;code&gt;host&lt;/code&gt; 选项时，可以省略$ host参数。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
