<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="abdb50fe44b0e7ab1495a77ca76309d394c16e26" translate="yes" xml:space="preserve">
          <source>The next example show how to use the &lt;code&gt;LimitOutput&lt;/code&gt; option. Notice the use of two nested loops in this case. The outer loop reads the data from the input source - STDIN and the inner loop repeatedly calls &lt;code&gt;inflate&lt;/code&gt; until &lt;code&gt;$input&lt;/code&gt; is exhausted, we get an error, or the end of the stream is reached. One point worth remembering is by using the &lt;code&gt;LimitOutput&lt;/code&gt; option you also get &lt;code&gt;ConsumeInput&lt;/code&gt; set as well - this makes the code below much simpler.</source>
          <target state="translated">下一个示例显示如何使用 &lt;code&gt;LimitOutput&lt;/code&gt; 选项。注意在这种情况下使用两个嵌套循环。外循环从输入源-STDIN读取数据，内循环重复调用 &lt;code&gt;inflate&lt;/code&gt; ,直到 &lt;code&gt;$input&lt;/code&gt; 耗尽，我们得到一个错误，或到达流的末尾。值得记住的一点是，通过使用 &lt;code&gt;LimitOutput&lt;/code&gt; 选项，您还可以设置 &lt;code&gt;ConsumeInput&lt;/code&gt; ，这使下面的代码更加简单。</target>
        </trans-unit>
        <trans-unit id="a73f1f7691d7497b711d0f4bac2e881b3c885873" translate="yes" xml:space="preserve">
          <source>The next example shows each input parameter evaluated late.</source>
          <target state="translated">下一个例子显示了每一个输入参数的后期评估。</target>
        </trans-unit>
        <trans-unit id="def9f1245a38d3c5116ce761f9376e6f2078f597" translate="yes" xml:space="preserve">
          <source>The next examples will use the following C++ class.</source>
          <target state="translated">接下来的例子将使用以下C++类。</target>
        </trans-unit>
        <trans-unit id="6c82e2eba4791c1303c10eb37d70a72bf59badcd" translate="yes" xml:space="preserve">
          <source>The next option deals with the charset (a.k.a. character set) your terminal supports. In general, CPAN is English speaking territory, so the charset does not matter much but some CPAN have names that are outside the ASCII range. If your terminal supports UTF-8, you should say no to the next question. If it expects ISO-8859-1 (also known as LATIN1) then you should say yes. If it supports neither, your answer does not matter because you will not be able to read the names of some authors anyway. If you answer no, names will be output in UTF-8.</source>
          <target state="translated">下一個選項是關於你的終端機所支援的字符集(charset)。一般來說,CPAN 是英文的領域,所以字符集並不重要,但有些 CPAN 的名稱是在 ASCII 範圍之外的,如果你的終端支援 UTF-8,你應該對下一個問題說不。如果您的终端支持UTF-8,您应该对下一个问题说不。如果您的终端支持ISO-8859-1(也称为LATIN1),那么您应该说 &quot;是&quot;。如果两者都不支持,您的回答就不重要了,因为您无论如何都无法读取某些作者的名字。如果您回答 &quot;否&quot;,名字将以UTF-8输出。</target>
        </trans-unit>
        <trans-unit id="128477608ba084f3baead065e12f71790ccb5def" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt; es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="translated">&lt;code&gt;BRANCH&lt;/code&gt; es 的下一个指针很有趣，因为它指向分支失败时应该执行的位置。执行时，如果引擎尝试从分支遍历到不是分支的 &lt;code&gt;regnext&lt;/code&gt; ，则引擎将知道整个分支集都已失败。</target>
        </trans-unit>
        <trans-unit id="49d098f677fc7d28016366882913ea295f0ea710" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt;es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="translated">&lt;code&gt;BRANCH&lt;/code&gt; es的下一个指针很有趣，因为它指向分支失败时应该执行的位置。执行时，如果引擎尝试从分支遍历到不是分支的 &lt;code&gt;regnext&lt;/code&gt; ，则引擎将知道整个分支集都已失败。</target>
        </trans-unit>
        <trans-unit id="8b56244f1caeaf0b5b4e0b479de80d44c501b35d" translate="yes" xml:space="preserve">
          <source>The next step is interpolation in the text obtained, which is now delimiter-independent. There are multiple cases.</source>
          <target state="translated">下一步是在得到的文本中进行插值,现在的文本与分隔符无关。有多种情况。</target>
        </trans-unit>
        <trans-unit id="2e9d420a49c5570abf7ae9f3e075e9465afea859" translate="yes" xml:space="preserve">
          <source>The next step is the type-specific context processing; in this case &lt;code&gt;cx_popsub&lt;/code&gt;. In part, this looks like:</source>
          <target state="translated">下一步是特定于类型的上下文处理；在这种情况下为 &lt;code&gt;cx_popsub&lt;/code&gt; 。在某种程度上，这看起来像：</target>
        </trans-unit>
        <trans-unit id="b245543afec9985d508833acde280bdb2e09df89" translate="yes" xml:space="preserve">
          <source>The next step is to add some symlinks to system libraries. For example, the development software expect a library &lt;code&gt;libm.so&lt;/code&gt; that normally is a symlink to &lt;code&gt;libm.so.6&lt;/code&gt;. Synology only provides the latter and not the symlink.</source>
          <target state="translated">下一步是向系统库添加一些符号链接。例如，开发软件需要一个库 &lt;code&gt;libm.so&lt;/code&gt; ，它通常是 &lt;code&gt;libm.so.6&lt;/code&gt; 的符号链接。 Synology仅提供后者而不提供符号链接。</target>
        </trans-unit>
        <trans-unit id="d0e87f516f02471787ab2f018e28d7851e0ac5f9" translate="yes" xml:space="preserve">
          <source>The next step is to pop savestack entries: &lt;code&gt;CX_LEAVE_SCOPE(cx)&lt;/code&gt; is just defined as &lt;code&gt;LEAVE_SCOPE(cx-&amp;gt;blk_oldsaveix)&lt;/code&gt;. Note that during the popping, it's possible for perl to call destructors, call &lt;code&gt;STORE&lt;/code&gt; to undo localisations of tied vars, and so on. Any of these can die or call &lt;code&gt;exit()&lt;/code&gt;. In this case, &lt;code&gt;dounwind()&lt;/code&gt; will be called, and the current context stack frame will be re-processed. Thus it is vital that all steps in popping a context are done in such a way to support reentrancy. The other alternative, of decrementing &lt;code&gt;cxstack_ix&lt;/code&gt;</source>
          <target state="translated">下一步是弹出保存堆栈条目： &lt;code&gt;CX_LEAVE_SCOPE(cx)&lt;/code&gt; 仅定义为 &lt;code&gt;LEAVE_SCOPE(cx-&amp;gt;blk_oldsaveix)&lt;/code&gt; 。请注意，在弹出过程中，perl可能会调用析构函数，调用 &lt;code&gt;STORE&lt;/code&gt; 来撤消绑定var的本地化等等。这些都可以死亡或调用 &lt;code&gt;exit()&lt;/code&gt; 。在这种情况下，将调用 &lt;code&gt;dounwind()&lt;/code&gt; ，并将重新处理当前的上下文堆栈帧。因此，至关重要的是，弹出上下文中的所有步骤都必须以支持重入的方式完成。另一种选择，递减 &lt;code&gt;cxstack_ix&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99d612978700e6928f957643eba3d0d61622b6ed" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system via email.</source>
          <target state="translated">下一步是通过电子邮件向Perl核心票务系统提交你的补丁。</target>
        </trans-unit>
        <trans-unit id="c53212a853da747bb753ac0eb206bd02a60002ca" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system.</source>
          <target state="translated">下一步是将你的补丁提交到Perl核心票务系统。</target>
        </trans-unit>
        <trans-unit id="82a6f456a2c90d50e2abfb7f37ee6f9a4299445f" translate="yes" xml:space="preserve">
          <source>The next task is to break the problem down into smaller problems that are easily converted into a regexp.</source>
          <target state="translated">接下来的任务是将问题分解成容易转换为regexp的小问题。</target>
        </trans-unit>
        <trans-unit id="c9e21bae9fb5eef63978dcfa71c7a0d3cb21ec24" translate="yes" xml:space="preserve">
          <source>The next time you wish to make a patch, you need to start from the latest perl in a pristine state. Check you don't have any local changes or added files in your perl check-out which you wish to keep, then run these commands:</source>
          <target state="translated">下一次你想打补丁的时候,你需要从最新的perl原始状态开始。检查你的 perl check-out 中没有任何你希望保留的本地修改或添加的文件,然后运行这些命令。</target>
        </trans-unit>
        <trans-unit id="79f58ceb3f799f52310d0fb9160eed5d3d3eaba7" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is it's like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="translated">todo测试的好处是,相对于简单地注释出一个测试块,它就像拥有一个程序化的todo列表。你知道还有多少工作要做,你知道有哪些错误,而且你会立即知道它们何时被修复。</target>
        </trans-unit>
        <trans-unit id="93f6c477375802df02f9578f889b424f60ac9928" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is that it is like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="translated">todo测试的好处是,相对于简单地注释出一个测试块,它就像拥有一个程序化的todo列表。你知道还有多少工作要做,你知道有哪些错误,而且你会立即知道它们何时被修复。</target>
        </trans-unit>
        <trans-unit id="92737be37077b1e4ee6685cd7da7d12b0a775c27" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C requires that certain things be set up in the console before Visual C will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run the &lt;code&gt;vcvars32.bat&lt;/code&gt; file to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; or &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; . On a typical install of a Microsoft C compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files\Microsoft Visual Studio\VC98\Bin. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="translated">Visual C ++附带的nmake足以满足构建要求。 Visual C要求成功运行Visual C之前，必须在控制台中进行某些设置。要使控制台能够运行C编译器，您需要事先运行 &lt;code&gt;vcvars32.bat&lt;/code&gt; 文件以针对x86-32和x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; 或 &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; 进行编译。在典型安装的Microsoft C编译器产品上，这些批处理文件将已经在 &lt;code&gt;PATH&lt;/code&gt; 中环境变量，因此您可以在控制台中输入它们而无需绝对路径。如果您需要找到批处理文件的绝对路径，通常可以在C：\ Program Files \ Microsoft Visual Studio \ VC98 \ Bin之类的位置找到它。对于某些较新的Micrsoft C产品（〜2004年以后发行），安装程序将在开始菜单中放置一个快捷方式，以启动新的控制台窗口，并已为目标体系结构设置了控制台（x86-32或x86-64或IA64）。 。对于较新的编译器，您可以选择使用较旧的批处理文件。</target>
        </trans-unit>
        <trans-unit id="74b0871cc8ecf5b8ec07f0886c93ea7f99f29900" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C++ requires that certain things be set up in the console before Visual C++ will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run &lt;code&gt;vcvarsall.bat x86&lt;/code&gt; to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat amd64&lt;/code&gt;. On a typical install of a Microsoft C++ compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="translated">Visual C ++附带的nmake足以满足构建要求。 Visual C ++要求在成功运行Visual C ++之前，必须在控制台中进行某些设置。为了使控制台能够运行C编译器，您需要预先运行 &lt;code&gt;vcvarsall.bat x86&lt;/code&gt; 才能针对x86-32和x86-64 &lt;code&gt;vcvarsall.bat amd64&lt;/code&gt; 进行编译。在典型安装的Microsoft C ++编译器产品上，这些批处理文件将已经在 &lt;code&gt;PATH&lt;/code&gt; 中环境变量，因此您无需在控制台中输入绝对路径即可输入它们。如果您需要找到批处理文件的绝对路径，通常可以在C：\ Program Files（x86）\ Microsoft Visual Studio 14.0 \ VC之类的位置找到它。对于某些较新的Micrsoft C产品（〜2004年之后发布），安装程序将在开始菜单中放置一个快捷方式，以启动新的控制台窗口，并已为目标体系结构设置了控制台（x86-32或x86-64或IA64）。 。对于较新的编译器，您可以选择使用较旧的批处理文件。</target>
        </trans-unit>
        <trans-unit id="d92d9609b16a9236c6b0750e878097cebaf141fa" translate="yes" xml:space="preserve">
          <source>The nmake that comes with the Platform SDK will suffice for building Perl. Make sure you are building within one of the &quot;Build Environment&quot; shells available after you install the Platform SDK from the Start Menu.</source>
          <target state="translated">平台SDK自带的nmake就可以满足构建Perl的需要。确保你是在从开始菜单安装Platform SDK后,在 &quot;Build Environment &quot;shell中进行编译。</target>
        </trans-unit>
        <trans-unit id="4cf437af831d898cd280f5f9fa16e3b19f38db9a" translate="yes" xml:space="preserve">
          <source>The node type, either &lt;code&gt;section&lt;/code&gt; or &lt;code&gt;item&lt;/code&gt; . As an unofficial type, there is also &lt;code&gt;hyperlink&lt;/code&gt; , derived from e.g. &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">节点类型，可以是 &lt;code&gt;section&lt;/code&gt; 或 &lt;code&gt;item&lt;/code&gt; 。作为非官方类型，还存在 &lt;code&gt;hyperlink&lt;/code&gt; ，例如从 &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; &lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt; &amp;gt;派生而来。</target>
        </trans-unit>
        <trans-unit id="9d0e0bd31f6a31a67e6263a3a5396fe920511c99" translate="yes" xml:space="preserve">
          <source>The non-ASCII characters below 256 can have various meanings, depending on various things. (See, most notably, &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) But usually the whole range can be referred to as ISO-8859-1. Often, the term &quot;Latin-1&quot; (or &quot;Latin1&quot;) is used as an equivalent for ISO-8859-1. But some people treat &quot;Latin1&quot; as referring just to the characters in the range 128 through 255, or somethimes from 160 through 255. This documentation uses &quot;Latin1&quot; and &quot;Latin-1&quot; to refer to all 256 characters.</source>
          <target state="translated">低于256的非ASCII字符可能具有不同的含义，具体取决于各种因素。（请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。）但是通常整个范围都可以称为ISO-8859-1。通常，术语&amp;ldquo; Latin-1&amp;rdquo;（或&amp;ldquo; Latin1&amp;rdquo;）与ISO-8859-1等效。但是有些人认为&amp;ldquo; Latin1&amp;rdquo;仅指代128到255范围内的字符，或者指160到255之间的某些字符。本文档使用&amp;ldquo; Latin1&amp;rdquo;和&amp;ldquo; Latin-1&amp;rdquo;来指代所有256个字符。</target>
        </trans-unit>
        <trans-unit id="6361a2e3097d12a5b1db2175b6f9b22e2b4e005e" translate="yes" xml:space="preserve">
          <source>The non-blocking behaviour is an extension of the &lt;code&gt;IO::Socket::INET&lt;/code&gt; API, unique to &lt;code&gt;IO::Socket::IP&lt;/code&gt;, because the former does not support multi-homed non-blocking connect.</source>
          <target state="translated">非阻塞行为是 &lt;code&gt;IO::Socket::INET&lt;/code&gt; API的扩展，是IO :: Socket &lt;code&gt;IO::Socket::IP&lt;/code&gt; 唯一的，因为前者不支持多宿主非阻塞连接。</target>
        </trans-unit>
        <trans-unit id="8827c5b69a11959983a358ee79f064e14c978f0c" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt; ):</source>
          <target state="translated">非破坏性修饰符 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 导致返回替换结果，而不是修改 &lt;code&gt;$_&lt;/code&gt; （或使用 &lt;code&gt;=~&lt;/code&gt; 绑定到替换变量的任何变量）：</target>
        </trans-unit>
        <trans-unit id="33ea7bc6a1364954efde1784eb70e926a46ab789" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;s///r&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt;):</source>
          <target state="translated">非破坏性修饰符 &lt;code&gt;s///r&lt;/code&gt; 导致返回替换结果，而不是修改 &lt;code&gt;$_&lt;/code&gt; （或使用 &lt;code&gt;=~&lt;/code&gt; 绑定到替换变量的任何变量）：</target>
        </trans-unit>
        <trans-unit id="d3e24c19053882dd3539c4f0f017c48b302d8630" translate="yes" xml:space="preserve">
          <source>The non-zero numeric</source>
          <target state="translated">非零数字</target>
        </trans-unit>
        <trans-unit id="ed0d308e2d36922ca367c5db784707665a50eda8" translate="yes" xml:space="preserve">
          <source>The normal Makefile.PL that h2xs generates doesn't know about the mylib directory. We need to tell it that there is a subdirectory and that we will be generating a library in it. Let's add the argument MYEXTLIB to the WriteMakefile call so that it looks like this:</source>
          <target state="translated">h2xs生成的普通Makefile.PL不知道mylib目录。我们需要告诉它有一个子目录,并且我们将在其中生成一个库。让我们在WriteMakefile调用中添加参数MYEXTLIB,这样它看起来就像这样。</target>
        </trans-unit>
        <trans-unit id="b1469f4963ec233a67445e77b1dc5adf4ccf9ab7" translate="yes" xml:space="preserve">
          <source>The normal course of action is to call:</source>
          <target state="translated">正常的做法是打电话。</target>
        </trans-unit>
        <trans-unit id="32723b8237682738b9e39db42e26b25a535a8b05" translate="yes" xml:space="preserve">
          <source>The normal return provided by &lt;code&gt;scalar(%hash)&lt;/code&gt; is not available. What this means is that using %tied_hash in boolean context doesn't work right (currently this always tests false, regardless of whether the hash is empty or hash elements). [ This paragraph needs review in light of changes in 5.25 ]</source>
          <target state="translated">&lt;code&gt;scalar(%hash)&lt;/code&gt; 提供的正常回报率不可用。这意味着在布尔上下文中使用％tied_hash不能正常工作（当前，无论哈希为空还是哈希元素，它始终测试为false）。[本段需要根据5.25中的更改进行审核]</target>
        </trans-unit>
        <trans-unit id="ecf683f52c0f42f564cf7e0ed381f4bb97cc8438" translate="yes" xml:space="preserve">
          <source>The normal use of this class is like so:</source>
          <target state="translated">这个类的正常使用是这样的。</target>
        </trans-unit>
        <trans-unit id="1ac2010e9cf7828bd4211d3176636428b6a9a255" translate="yes" xml:space="preserve">
          <source>The normal way to run a Perl program is by making it directly executable, or else by passing the name of the source file as an argument on the command line. (An interactive Perl environment is also possible--see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; for details on how to do that.) Upon startup, Perl looks for your program in one of the following places:</source>
          <target state="translated">运行Perl程序的通常方法是使其直接可执行，或者通过在命令行上传递源文件的名称作为参数。（也可以使用交互式Perl环境- 有关如何执行此&lt;a href=&quot;perldebug&quot;&gt;操作&lt;/a&gt;的详细信息，请参见perldebug。）启动后，Perl在以下位置之一查找程序：</target>
        </trans-unit>
        <trans-unit id="42b613b12f582e26d7e800d066ea1eb52e714a90" translate="yes" xml:space="preserve">
          <source>The not-a-number as a constant:</source>
          <target state="translated">非数为常数。</target>
        </trans-unit>
        <trans-unit id="46672cb58512b6dfcf1bfa852b6fb1012267b6a3" translate="yes" xml:space="preserve">
          <source>The notation still looks a little cumbersome, so there's one more abbreviation:</source>
          <target state="translated">符号还是显得有些繁琐,所以多了一个缩写。</target>
        </trans-unit>
        <trans-unit id="faf2109c5b26dde1813deee78331f15408acfe4a" translate="yes" xml:space="preserve">
          <source>The notion that an empty &lt;b&gt;derived class&lt;/b&gt; should behave exactly like its &lt;b&gt;base class&lt;/b&gt;.</source>
          <target state="translated">空&lt;b&gt;派生类的&lt;/b&gt;行为应与其&lt;b&gt;基类&lt;/b&gt;完全相同的概念。</target>
        </trans-unit>
        <trans-unit id="d26e84b13c8c8748080fe4085da63e6e9ef520f9" translate="yes" xml:space="preserve">
          <source>The notion that you can tell an &lt;b&gt;object&lt;/b&gt; to do something generic, and the object will interpret the command in different ways depending on its type. [&amp;lt; Greek &amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, many forms.]</source>
          <target state="translated">您可以告诉&lt;b&gt;对象&lt;/b&gt;执行通用操作的概念，并且对象将根据其类型以不同的方式解释命令。[&amp;lt;希腊语&amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;-+ &amp;mu;&amp;omicron;&amp;rho;ϕή，有多种形式。]</target>
        </trans-unit>
        <trans-unit id="ad272f88bed19c2e6cec366907b96e0baf112d7c" translate="yes" xml:space="preserve">
          <source>The notion that, with a complete set of simple tools that work well together, you can build almost anything you want. Which is fine if you&amp;rsquo;re assembling a tricycle, but if you&amp;rsquo;re building a defranishizing comboflux regurgalator, you really want your own machine shop in which to build special tools. Perl is sort of a machine shop.</source>
          <target state="translated">有了一套完整的简单工具，它们可以很好地协同工作，您可以构建几乎任何想要的东西。如果您要组装三轮车，那很好，但是如果您要制造脱色的康菲斯回流调节器，那么您真的希望自己的机械车间可以制造特殊的工具。Perl就像是一家机械厂。</target>
        </trans-unit>
        <trans-unit id="d8cd6888cbc4c56537079a3ca6af05881fde2aca" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt; , which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="translated">空文件句柄 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 是特殊的：它可用于模拟&lt;b&gt;sed&lt;/b&gt;和&lt;b&gt;awk&lt;/b&gt;以及其他任何使用文件名列表的Unix过滤器程序的行为，对所有文件名的每一行都执行相同的操作。来自 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 的输入或者来自标准输入，或者来自命令行上列出的每个文件。它是这样工作的：第一次计算 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 时，将检查 &lt;code&gt;@ARGV&lt;/code&gt; 数组，如果它为空，则 &lt;code&gt;$ARGV[0]&lt;/code&gt; 设置为 &lt;code&gt;&quot;-&quot;&lt;/code&gt; ，当打开时会为您提供标准输入。然后，将 &lt;code&gt;@ARGV&lt;/code&gt; 数组作为文件名列表进行处理。循环</target>
        </trans-unit>
        <trans-unit id="2eb5648c665e9498b1d4e1c662b451796e069c6c" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt;, which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="translated">空文件句柄 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 是特殊的：它可以用来模拟&lt;b&gt;sed&lt;/b&gt;和&lt;b&gt;awk&lt;/b&gt;以及其他任何使用文件名列表的Unix过滤器程序的行为，对所有文件名的每一行都执行相同的操作。来自 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 的输入要么来自标准输入，要么来自命令行上列出的每个文件。它是这样工作的：第一次评估 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 时，将检查 &lt;code&gt;@ARGV&lt;/code&gt; 数组，如果它为空，则 &lt;code&gt;$ARGV[0]&lt;/code&gt; 设置为 &lt;code&gt;&quot;-&quot;&lt;/code&gt; ，当打开时会为您提供标准输入。然后，将 &lt;code&gt;@ARGV&lt;/code&gt; 数组作为文件名列表进行处理。循环</target>
        </trans-unit>
        <trans-unit id="6d22af8d2b7cf7cf2c570f3f335ab2a750c99b68" translate="yes" xml:space="preserve">
          <source>The null list is represented by (). Interpolating it in a list has no effect. Thus ((),(),()) is equivalent to (). Similarly, interpolating an array with no elements is the same as if no array had been interpolated at that point.</source>
          <target state="translated">空列表用()表示。在列表中对其进行插值,没有效果。因此((),(),())相当于()。同理,对一个没有元素的数组进行插值,与此时没有数组插值是一样的。</target>
        </trans-unit>
        <trans-unit id="1797c45a73a5a87e1dcbfe3ceafa93cc5c4f9d01" translate="yes" xml:space="preserve">
          <source>The null loop times can be cached, the key being the number of rounds. The caching can be controlled using calls like these:</source>
          <target state="translated">可以缓存空循环时间,关键是轮数。缓存可以使用这样的调用来控制。</target>
        </trans-unit>
        <trans-unit id="c43d1fda274f03a112b4082e8056292b9c40d862" translate="yes" xml:space="preserve">
          <source>The number 0, the strings &lt;code&gt;'0'&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , the empty list &lt;code&gt;()&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; are all false in a boolean context. All other values are true. Negation of a true value by &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; returns a special false value. When evaluated as a string it is treated as &lt;code&gt;&quot;&quot;&lt;/code&gt; , but as a number, it is treated as 0. Most Perl operators that return true or false behave this way.</source>
          <target state="translated">在布尔上下文中，数字0，字符串 &lt;code&gt;'0'&lt;/code&gt; 和 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，空列表 &lt;code&gt;()&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 均为false。所有其他值都是正确的。否定真值 &lt;code&gt;!&lt;/code&gt; 或 &lt;code&gt;not&lt;/code&gt; 返回特殊的false值。以字符串形式求值时，将其视为 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，而将其视为数字，则将其视为0。大多数返回true或false的Perl运算符都将以这种方式运行。</target>
        </trans-unit>
        <trans-unit id="692f2a5740e6be2f2f4c50b1195b7318b218c93b" translate="yes" xml:space="preserve">
          <source>The number after Perl (i.e. the 5 after Perl 5) is the major release of the perl interpreter as well as the version of the language. Each major version has significant differences that earlier versions cannot support.</source>
          <target state="translated">Perl后面的数字(即Perl 5后面的5)是perl解释器的主要版本以及语言的版本。每一个主要版本都有早期版本无法支持的重大差异。</target>
        </trans-unit>
        <trans-unit id="3191b134cb3717b47b8c71b05a1d940752bad987" translate="yes" xml:space="preserve">
          <source>The number for the &quot;generation&quot; of the test run. The first generation is 1 (one) and subsequent generations are 2, 3, etc.</source>
          <target state="translated">测试运行的 &quot;代数&quot;。第一代为1(1),以后的代数为2、3等。</target>
        </trans-unit>
        <trans-unit id="2535d279c5200f7be07d31d15ce44068cdb20ffd" translate="yes" xml:space="preserve">
          <source>The number of &quot;hidden&quot; sectors for this partition. Actually this is the number of sectors found prior to this partition, that is, the starting offset [as found in &lt;code&gt;$uStartLow&lt;/code&gt; and &lt;code&gt;$ivStartHigh&lt;/code&gt;] divided by the number of bytes per sector.</source>
          <target state="translated">此分区的&amp;ldquo;隐藏&amp;rdquo;扇区数。实际上，这是在此分区之前找到的扇区数，即，起始偏移量（如在 &lt;code&gt;$uStartLow&lt;/code&gt; 和 &lt;code&gt;$ivStartHigh&lt;/code&gt; ）除以每个扇区的字节数。</target>
        </trans-unit>
        <trans-unit id="f0a9d7413ce0d5ac2d4144491992bf44868224aa" translate="yes" xml:space="preserve">
          <source>The number of bytes in each sector.</source>
          <target state="translated">每个扇区的字节数。</target>
        </trans-unit>
        <trans-unit id="fa99ba7fda4b251af40087fa9ad0d33252bbd195" translate="yes" xml:space="preserve">
          <source>The number of concurrent jobs this formatter will handle.</source>
          <target state="translated">该表格器将处理的并发作业数量。</target>
        </trans-unit>
        <trans-unit id="36ffefa76cdb58a51fa74dc31caa513844b361e2" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after &lt;code&gt;av_fill()&lt;/code&gt; returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;av_fill()&lt;/code&gt; 返回后，数组中元素的数量将为 &lt;code&gt;fill + 1&lt;/code&gt; 。如果数组以前较短，则附加的其他元素将设置为NULL。如果数组较长，则释放多余的元素。 &lt;code&gt;av_fill(av, -1)&lt;/code&gt; 与 &lt;code&gt;av_clear(av)&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="5d2ba45a48d3868e33de1ec7e956df019e81e42a" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after av_fill() returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt; .</source>
          <target state="translated">av_fill（）返回后，数组中的元素数将为 &lt;code&gt;fill + 1&lt;/code&gt; 。如果数组以前较短，则附加的其他元素将设置为NULL。如果数组较长，则释放多余的元素。 &lt;code&gt;av_fill(av, -1)&lt;/code&gt; 与 &lt;code&gt;av_clear(av)&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b9161f7d8230483ece3123e0d04957cb7a945f72" translate="yes" xml:space="preserve">
          <source>The number of items in a hash can be obtained by doing:</source>
          <target state="translated">可以通过做获得哈希中的项目数。</target>
        </trans-unit>
        <trans-unit id="e4c9a33204f057eb951c01e0df7449caf0e7389f" translate="yes" xml:space="preserve">
          <source>The number of lines left on the page of the currently selected output channel.</source>
          <target state="translated">当前选择的输出通道的页面剩余行数。</target>
        </trans-unit>
        <trans-unit id="8b661ef45c3e83256fc7a63d23f91b2343af29ac" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt; . The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) variable. Many error messages report both values, if available.</source>
          <target state="translated">在此之前读取的行数加1。Perl为打开的每个源文件或输入文件保留一个单独的行号。当前源文件的行号由 &lt;code&gt;__LINE__&lt;/code&gt; 表示。当前输入行号（对于最近通过 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; 读取的文件）用 &lt;code&gt;$.&lt;/code&gt; 表示。（ &lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ）变量。许多错误消息报告两个值（如果有）。</target>
        </trans-unit>
        <trans-unit id="2c32dc65a0983301d8b932b2ff7d13fbe8041de2" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt;. The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt;) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt;) variable. Many error messages report both values, if available.</source>
          <target state="translated">在此之前读取的行数加1。Perl为打开的每个源文件或输入文件保留一个单独的行号。当前源文件的行号由 &lt;code&gt;__LINE__&lt;/code&gt; 表示。当前输入行号（对于最近通过 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; 读取的文件）用 &lt;code&gt;$.&lt;/code&gt; 表示。（ &lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ）变量。许多错误消息都报告两个值（如果有）。</target>
        </trans-unit>
        <trans-unit id="4c26ea7021e22061094b1160120712623c26587e" translate="yes" xml:space="preserve">
          <source>The number of retrieval pointers that RMS has to maintain (0 to 127255)</source>
          <target state="translated">RMS需要维护的检索指针数量(0到127255)。</target>
        </trans-unit>
        <trans-unit id="7adfc7b3eafb7c58d678ada0cc8dfa22b0798638" translate="yes" xml:space="preserve">
          <source>The number of seconds the program ran for before being terminated, or 0 if no timeout occurred.</source>
          <target state="translated">终止前程序运行的秒数,如果没有超时,则为0。</target>
        </trans-unit>
        <trans-unit id="3f0ee453c0514a141454bf624811de74f7121fbc" translate="yes" xml:space="preserve">
          <source>The number of sectors in each track.</source>
          <target state="translated">每个轨道上的扇区数量。</target>
        </trans-unit>
        <trans-unit id="701c3dee8ddb529dd17cdf0b20bfe4db85c06698" translate="yes" xml:space="preserve">
          <source>The number of spaces to indent regular text, and the default indentation for &lt;code&gt;=over&lt;/code&gt; blocks. Defaults to 4.</source>
          <target state="translated">要缩进常规文本的空格数，以及 &lt;code&gt;=over&lt;/code&gt; 块的默认缩进。默认为4。</target>
        </trans-unit>
        <trans-unit id="e68baf88a8ecb32bf1315047769f8d0e186bb5f6" translate="yes" xml:space="preserve">
          <source>The number of tests actually seen</source>
          <target state="translated">实际看到的测试次数</target>
        </trans-unit>
        <trans-unit id="65eb3487d858db8bd02f6c81679897d6d005441b" translate="yes" xml:space="preserve">
          <source>The number of tests in your script. This means all ok() and skip() calls.</source>
          <target state="translated">脚本中的测试次数。这意味着所有的ok()和skip()调用。</target>
        </trans-unit>
        <trans-unit id="7a3c79429902da3d2d3d81b8c529fe97388165ba" translate="yes" xml:space="preserve">
          <source>The number of tests that were planned</source>
          <target state="translated">计划进行的测试次数</target>
        </trans-unit>
        <trans-unit id="34e2b7e50e91d743cd4a7b27aa45939dc1c6581f" translate="yes" xml:space="preserve">
          <source>The number of tests which failed</source>
          <target state="translated">不合格的测试次数</target>
        </trans-unit>
        <trans-unit id="c2e318858e274a3b2d56e4e8546a3453a590b339" translate="yes" xml:space="preserve">
          <source>The number of tests with TODO directives.</source>
          <target state="translated">有TODO指令的测试数量。</target>
        </trans-unit>
        <trans-unit id="134bbf3c12ccdb3b17c2429c883dacdca5457a57" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;&quot;comp&quot;&lt;/a&gt; routine.</source>
          <target state="translated">引用结构的次数。当该值降至0时，通过调用pregfree自动释放regexp。在每个引擎的&lt;a href=&quot;#comp&quot;&gt;&amp;ldquo; comp&amp;rdquo;&lt;/a&gt;例程中应将其设置为1 。</target>
        </trans-unit>
        <trans-unit id="c43b06bec0238ed7c22fd0d6e38144c2bb8f0d70" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; routine.</source>
          <target state="translated">引用结构的次数。当它降至0时，通过调用pregfree自动释放regexp。在每个引擎的&lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt;例程中应将其设置为1 。</target>
        </trans-unit>
        <trans-unit id="c7aa069edb979af7f298ec7da8f6245a682e62f6" translate="yes" xml:space="preserve">
          <source>The number of times the test has failed.</source>
          <target state="translated">测试失败的次数。</target>
        </trans-unit>
        <trans-unit id="f294a946b3a2f3d15985548e48a89b85b334300e" translate="yes" xml:space="preserve">
          <source>The number of times the test has passed.</source>
          <target state="translated">测试通过的次数。</target>
        </trans-unit>
        <trans-unit id="1ea0b9d7d53aa08d0e622974bcb543d8e9e34567" translate="yes" xml:space="preserve">
          <source>The number of tracks in each cylinder.</source>
          <target state="translated">每个圆柱体的轨道数;</target>
        </trans-unit>
        <trans-unit id="6ecf3312d862847aadfe59c31f3bcfa85cc3016b" translate="yes" xml:space="preserve">
          <source>The numbering within each branch will be as normal, and any groups following this construct will be numbered as though the construct contained only one branch, that being the one with the most capture groups in it.</source>
          <target state="translated">每个分支内的编号将与正常情况一样,该构造后的任何组将被编号,就好像该构造只包含一个分支,即其中有最多捕获组的那个分支。</target>
        </trans-unit>
        <trans-unit id="d3f5b7856c836d8ae15bae5d2911f695737356ba" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigFloat. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">数字以对象的形式存储,其内部可能随时发生变化,特别是在数学运算之间。这些对象也可能属于不同的类,比如Math::BigInt,或者Math::BigFloat。将它们混合在一起,即使是普通的标量,也不是什么特别的事情,而是正常的,也是意料之中的事情。</target>
        </trans-unit>
        <trans-unit id="0d52076285e4f235f1d8532711b46d3578467720" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigInt::Lite. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">数字以对象的形式存储,其内部可能随时发生变化,特别是在数学运算之间。这些对象也可能属于不同的类,比如Math::BigInt,或者Math::BigInt::Lite。将它们混合在一起,即使是普通的标量,也不是什么特别的事情,而是正常的,也是意料之中的事情。</target>
        </trans-unit>
        <trans-unit id="d62316f7524c3cde4e634f1fd21e7ac49fd46233" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to 0777), to be modified by the current &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="translated">应用于每个已创建目录的数字权限模式（默认为0777），由当前 &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 修改。如果目录已经存在（因此不需要创建），则不会修改权限。</target>
        </trans-unit>
        <trans-unit id="5dffd7d41fb958bc0c87e558861a514e1606e35f" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to &lt;code&gt;0777&lt;/code&gt;), to be modified by the current &lt;code&gt;umask&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="translated">应用于每个已创建目录的数字权限模式（默认为 &lt;code&gt;0777&lt;/code&gt; ），由当前 &lt;code&gt;umask&lt;/code&gt; 修改。如果目录已经存在（因此不需要创建），则不会修改权限。</target>
        </trans-unit>
        <trans-unit id="41e019f9571f72909dc6712d8ba72dd87f1a9db6" translate="yes" xml:space="preserve">
          <source>The numeric value of the COP's hint flags, or an empty string if this is not a COP.</source>
          <target state="translated">COP的提示标志的数值,如果不是COP,则为空字符串。</target>
        </trans-unit>
        <trans-unit id="419fea734cd75b36bfd625f906eafadf3594cbdf" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's flags.</source>
          <target state="translated">OP标志的数值。</target>
        </trans-unit>
        <trans-unit id="e13f8ed0a121e4b7f2050aa9d7bd9bd36bdb9772" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's private flags.</source>
          <target state="translated">OP的私有标志的数值。</target>
        </trans-unit>
        <trans-unit id="afdb5b0bce9be5274063464faba90d66849c8cbe" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's targ.</source>
          <target state="translated">上文中的targ的数值。</target>
        </trans-unit>
        <trans-unit id="e4bd78ffa7c276231e5c09572ec79b0007d54b06" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's type, in decimal.</source>
          <target state="translated">OP类型的数值,以十进制表示。</target>
        </trans-unit>
        <trans-unit id="38a4063b54e70e2579ef41b45391d9edbcb80e9f" translate="yes" xml:space="preserve">
          <source>The object actually used is of the class &lt;a href=&quot;ExtUtils::MY&quot;&gt;MY&lt;/a&gt; which allows you to override bits of MakeMaker inside your Makefile.PL by declaring MY::foo() methods.</source>
          <target state="translated">实际使用的对象属于&lt;a href=&quot;ExtUtils::MY&quot;&gt;MY&lt;/a&gt;类，它允许您通过声明MY :: foo（）方法来覆盖Makefile.PL中的MakeMaker位。</target>
        </trans-unit>
        <trans-unit id="4a6a6fda3b81e72660dadfe40e0c6cbbf8b62d9b" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">该对象被重新赋予 &lt;code&gt;IO::Handle&lt;/code&gt; 的子类，并成为管道读取端的句柄。如果给出了 &lt;code&gt;ARGS&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ，并将 &lt;code&gt;ARGS&lt;/code&gt; 传递给exec。</target>
        </trans-unit>
        <trans-unit id="7b25df29627971e66202a04141c07ea01261d426" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">该对象被重新赋予 &lt;code&gt;IO::Handle&lt;/code&gt; 的子类，并成为管道写入端的句柄。如果给出了 &lt;code&gt;ARGS&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ，并将 &lt;code&gt;ARGS&lt;/code&gt; 传递给exec。</target>
        </trans-unit>
        <trans-unit id="fc8e459a67162585ed649c073732c1f153656661" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt;, and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;fork&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">该对象被重新赋予 &lt;code&gt;IO::Handle&lt;/code&gt; 的子类，并成为管道读取端的句柄。如果给出了 &lt;code&gt;ARGS&lt;/code&gt; ，则调用 &lt;code&gt;fork&lt;/code&gt; ，并将 &lt;code&gt;ARGS&lt;/code&gt; 传递给exec。</target>
        </trans-unit>
        <trans-unit id="960d4697beb3f7754f165a72fa86b9e206ef71bf" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt;, and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;fork&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">该对象被重新赋予 &lt;code&gt;IO::Handle&lt;/code&gt; 的子类，并成为管道写入端的句柄。如果给出了 &lt;code&gt;ARGS&lt;/code&gt; ，则调用 &lt;code&gt;fork&lt;/code&gt; ，并将 &lt;code&gt;ARGS&lt;/code&gt; 传递给exec。</target>
        </trans-unit>
        <trans-unit id="40e63c161da60788dfbf25012eced379198e6461" translate="yes" xml:space="preserve">
          <source>The object or class on which a method is called is passed as one of the method's arguments, not as a separate &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="translated">调用方法的对象或类作为方法的参数之一传递，而不是作为单独的 &lt;code&gt;this&lt;/code&gt; 值传递。</target>
        </trans-unit>
        <trans-unit id="ac2428a9234f597f267cadbd7f0f16da4708e348" translate="yes" xml:space="preserve">
          <source>The object oriented interface lets you configure your own encoding or decoding style, within the limits of supported formats.</source>
          <target state="translated">面向对象的接口可以让你在支持的格式范围内配置自己的编码或解码风格。</target>
        </trans-unit>
        <trans-unit id="15b98c3fd23a1ef70ae8197a79094d62be1e4c5c" translate="yes" xml:space="preserve">
          <source>The object oriented interface to &lt;code&gt;Digest::MD5&lt;/code&gt; is described in this section. After a &lt;code&gt;Digest::MD5&lt;/code&gt; object has been created, you will add data to it and finally ask for the digest in a suitable format. A single object can be used to calculate multiple digests.</source>
          <target state="translated">本节介绍了 &lt;code&gt;Digest::MD5&lt;/code&gt; 面向对象的接口。一个经过 &lt;code&gt;Digest::MD5&lt;/code&gt; 对象已经创建，您将数据添加到它，最后以合适的格式要求的摘要。单个对象可用于计算多个摘要。</target>
        </trans-unit>
        <trans-unit id="e33be9a872157d87d04d9ab372ad71b851a50cce" translate="yes" xml:space="preserve">
          <source>The object registry is also used to repair a field hash after thread cloning. Here, the entire object registry is processed. For every reference found there, the field hashes it has used are visited and the entry is updated.</source>
          <target state="translated">对象注册表也是用来修复线程克隆后的字段哈希。在这里,整个对象注册表都会被处理。对于在那里发现的每一个引用,都会访问它所使用的字段哈希,并更新条目。</target>
        </trans-unit>
        <trans-unit id="90c880f65630ae33e5e929b9f5badc61ea20d016" translate="yes" xml:space="preserve">
          <source>The object registry keeps track of references that have been used as field hash keys. The keys are generated from the reference address like in a field hash (though the registry isn't a field hash). Each value is a weak copy of the original reference, stored in an &lt;code&gt;SV&lt;/code&gt; that is itself magical (&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; again). The magical structure holds a list (another hash, really) of field hashes that the reference has been used with. When the weakref becomes stale, the magic is activated and uses the list to delete the reference from all field hashes it has been used with. After that, the entry is removed from the object registry itself. Implicitly, that frees the magic structure and the storage it has been using.</source>
          <target state="translated">对象注册表跟踪已用作字段哈希键的引用。键是从参考地址生成的，就像在字段哈希中一样（尽管注册表不是字段哈希）。每个值都是原始参考的弱副本，存储在本身就是魔术的 &lt;code&gt;SV&lt;/code&gt; 中（再次是 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; ）。神奇的结构保存了与引用一起使用的字段哈希的列表（实际上是另一个哈希）。当weakref变得陈旧时，魔术会被激活并使用该列表从与之一起使用的所有字段散列中删除引用。之后，该条目将从对象注册表本身中删除。隐式地，这释放了魔术结构及其一直在使用的存储空间。</target>
        </trans-unit>
        <trans-unit id="d72391ab64988da73b0a894ff996ef426650aa27" translate="yes" xml:space="preserve">
          <source>The object returned by &lt;code&gt;builder()&lt;/code&gt; may change at runtime so you should call &lt;code&gt;builder()&lt;/code&gt; inside each function rather than store it in a global.</source>
          <target state="translated">&lt;code&gt;builder()&lt;/code&gt; 返回的对象可能会在运行时更改，因此您应该在每个函数内调用 &lt;code&gt;builder()&lt;/code&gt; 而不是将其存储在全局函数中。</target>
        </trans-unit>
        <trans-unit id="0c2931896c0ae38a7dcf1ceb36dc3228043fb889" translate="yes" xml:space="preserve">
          <source>The object will be serialised as a JSON null value.</source>
          <target state="translated">该对象将被序列化为JSON空值。</target>
        </trans-unit>
        <trans-unit id="dce4a435aaab3b8ce3beeeab8876d2f9007b9517" translate="yes" xml:space="preserve">
          <source>The object will be serialised as a JSON number value.</source>
          <target state="translated">该对象将被序列化为一个JSON编号值。</target>
        </trans-unit>
        <trans-unit id="afec221431749f399e52c9677871688987dfbb46" translate="yes" xml:space="preserve">
          <source>The oct() function is commonly used when a string such as &lt;code&gt;644&lt;/code&gt; needs to be converted into a file mode, for example. Although Perl automatically converts strings into numbers as needed, this automatic conversion assumes base 10.</source>
          <target state="translated">例如，当需要将诸如 &lt;code&gt;644&lt;/code&gt; 之类的字符串转换为文件模式时，通常使用oct（）函数。尽管Perl会根据需要自动将字符串转换为数字，但是此自动转换假定以10为底。</target>
        </trans-unit>
        <trans-unit id="09c9c348da6207c41e75d17f6b539e26d9c4cd1f" translate="yes" xml:space="preserve">
          <source>The official (threaded) builds from HP, as they are shipped on the Application DVD/CD's are available on &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt; for both PA-RISC and IPF (Itanium Processor Family). They are built with the HP ANSI-C compiler. Up till 5.8.8 that was done by ActiveState.</source>
          <target state="translated">对于HP 和PA-RISC ，官方的（线程化的）构建都来自应用DVD / CD上的出厂版本，可从&lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt;获得。和IPF（Itanium处理器系列）。它们是使用HP ANSI-C编译器构建的。直到5.8.8由ActiveState完成。</target>
        </trans-unit>
        <trans-unit id="94afd3df7a7936cd7021df875b7cc881f99b3a21" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at GitHub. Posting to the list and the bugtracker is not a right: all participants in discussion are expected to adhere to a standard of conduct.</source>
          <target state="translated">开发 perl 的官方论坛是上面提到的 perl5-porters 邮件列表,以及 GitHub 上的 bugtracker。在邮件列表和错误跟踪器上发帖并不是一种权利:所有参与讨论的人都应该遵守行为标准。</target>
        </trans-unit>
        <trans-unit id="122c2a7e4876853c52ff4c6bbc23491cac5b2166" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at rt.perl.org. All participants in discussion there are expected to adhere to a standard of conduct.</source>
          <target state="translated">开发perl的官方论坛是上面提到的perl5-porters邮件列表,以及它的bug跟踪器rt.perl.org。所有参与讨论的人都应该遵守行为标准。</target>
        </trans-unit>
        <trans-unit id="206093c38ad914ff8435f60fe865bef14dbff945" translate="yes" xml:space="preserve">
          <source>The official home of this project on the web.</source>
          <target state="translated">这个项目在网络上的官方主页。</target>
        </trans-unit>
        <trans-unit id="318a2a25e89f6df5d0fee0930895c69196eba39a" translate="yes" xml:space="preserve">
          <source>The official name of VMS as of this writing is OpenVMS.</source>
          <target state="translated">截至目前,VMS的正式名称是OpenVMS。</target>
        </trans-unit>
        <trans-unit id="9e04119b1083995ffa8b809847e51388388f1606" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is</source>
          <target state="translated">Berkeley DB的官方网站是</target>
        </trans-unit>
        <trans-unit id="9ae89a7a7356b47202ed85668f00ace437b2ed69" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is &lt;a href=&quot;http://www.oracle.com/technology/products/berkeley-db/db/index.html&quot;&gt;http://www.oracle.com/technology/products/berkeley-db/db/index.html&lt;/a&gt;. All versions of Berkeley DB are available there.</source>
          <target state="translated">Berkeley DB的官方网站是&lt;a href=&quot;http://www.oracle.com/technology/products/berkeley-db/db/index.html&quot;&gt;http://www.oracle.com/technology/products/berkeley-db/db/index.html&lt;/a&gt;。那里提供了所有版本的Berkeley DB。</target>
        </trans-unit>
        <trans-unit id="5b569f6bcadd4a6fd7badb484a162b25dd85b5b2" translate="yes" xml:space="preserve">
          <source>The offset from the start of the file in hex.</source>
          <target state="translated">从文件开始的偏移量,用十六进制表示。</target>
        </trans-unit>
        <trans-unit id="d8ba5881483f263a1268bc8d8cd7d41b8c76ce28" translate="yes" xml:space="preserve">
          <source>The old behavior is currently retained, warts and all, for backwards compatibility, but users are encouraged to change any code that tests &lt;code&gt;$!&lt;/code&gt; against &lt;code&gt;E*&lt;/code&gt; constants for Winsock errors to instead test &lt;code&gt;$^E&lt;/code&gt; against &lt;code&gt;WSAE*&lt;/code&gt; constants. After a suitable deprecation period, which started with Perl 5.24, the old behavior may be removed, leaving &lt;code&gt;$!&lt;/code&gt; unchanged after Winsock function calls, to avoid any possible confusion over which error variable to check.</source>
          <target state="translated">为了保持向后兼容性，目前保留了旧行为（包括疣和所有行为），但是鼓励用户更改任何测试 &lt;code&gt;$!&lt;/code&gt; 的代码。针对Winsock错误的 &lt;code&gt;E*&lt;/code&gt; 常量，而针对 &lt;code&gt;WSAE*&lt;/code&gt; 常量测试 &lt;code&gt;$^E&lt;/code&gt; 在一个适当的弃用期（从Perl 5.24开始）之后，可以删除旧的行为，并保留 &lt;code&gt;$!&lt;/code&gt; 。Winsock函数调用后保持不变，以避免对要检查的错误变量进行任何可能的混淆。</target>
        </trans-unit>
        <trans-unit id="065d987b91e5e5831e84ee6eb6792bbd1900fe0e" translate="yes" xml:space="preserve">
          <source>The old behaviour of immediate croaking can be re-instated by setting &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; to some &lt;code&gt;FALSE&lt;/code&gt; value.</source>
          <target state="translated">立即呱呱叫的旧行为可以通过设置重新设置 &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; 一些 &lt;code&gt;FALSE&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="5b386f850ac3d208fd4890f0e6e16aecfa5e9221" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt; , can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">可以使用 &lt;code&gt;&quot;style&quot;&lt;/code&gt; 参数更改可以具有 &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;polar&quot;&lt;/code&gt; 值的旧显示格式样式。</target>
        </trans-unit>
        <trans-unit id="e9569a2edc0d7e856dea14bff6ac690edcc52042" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt;, can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">可以使用 &lt;code&gt;&quot;style&quot;&lt;/code&gt; 参数更改可以具有 &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;polar&quot;&lt;/code&gt; 值的旧显示格式样式。</target>
        </trans-unit>
        <trans-unit id="4ffd1da07401f04d08ba15b9c723b21da5d25d24" translate="yes" xml:space="preserve">
          <source>The old form of &lt;code&gt;gv_init_pvn()&lt;/code&gt;. It does not work with UTF-8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the &lt;code&gt;GV_ADDMULTI&lt;/code&gt; flag will be passed to &lt;code&gt;gv_init_pvn()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gv_init_pvn()&lt;/code&gt; 的旧形式。它不支持UTF-8字符串，因为它没有flags参数。如果设置了 &lt;code&gt;multi&lt;/code&gt; 参数，则 &lt;code&gt;GV_ADDMULTI&lt;/code&gt; 标志将传递给 &lt;code&gt;gv_init_pvn()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3404a80aca7096e4f7cc6df65a56468be124f24" translate="yes" xml:space="preserve">
          <source>The old form of gv_init_pvn(). It does not work with UTF8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the GV_ADDMULTI flag will be passed to gv_init_pvn().</source>
          <target state="translated">gv_init_pvn（）的旧形式。它不具有UTF8字符串，因为它没有flags参数。如果设置了 &lt;code&gt;multi&lt;/code&gt; 参数，则GV_ADDMULTI标志将传递给gv_init_pvn（）。</target>
        </trans-unit>
        <trans-unit id="79188e84f37b880e4a772b5ff3206627de3b874e" translate="yes" xml:space="preserve">
          <source>The old home for the module tests, you shouldn't put anything new in here. There are still some bits and pieces hanging around in here that need to be moved. Perhaps you could move them? Thanks!</source>
          <target state="translated">模块测试的老家,你不应该在这里放任何新东西。还有一些零碎的东西挂在这里,需要移动。也许你可以把它们搬走?谢谢你!</target>
        </trans-unit>
        <trans-unit id="37d530fbe2e5d190496e0bd800701dfa6c514e1c" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; , you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt; ; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt; , which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; .</source>
          <target state="translated">旧的包定界符是单引号，但现在双冒号是首选的定界符，部分原因是它对人类更易读，部分原因是对&lt;b&gt;emacs&lt;/b&gt;宏更易读。这也使C ++程序员感到自己知道发生了什么&amp;mdash;而不是使用单引号作为分隔符，这使Ada程序员感到自己知道发生了什么。因为仍然支持老式语法以实现向后兼容性，所以如果您尝试使用诸如 &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; 类的字符串，则将访问 &lt;code&gt;$owner::s&lt;/code&gt; ;也就是说，包 &lt;code&gt;owner&lt;/code&gt; 的$ s变量可能不是您的意思。使用括号消除歧义，例如 &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="511ae26f8725e1c7736ec75894aed8905e42064b" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt;, you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt;; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt;, which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt;.</source>
          <target state="translated">旧的包定界符是单引号，但现在双冒号是首选的定界符，部分原因是它对人类更易读，而部分原因是对&lt;b&gt;emacs&lt;/b&gt;宏更易&lt;b&gt;理解&lt;/b&gt;。这也使C ++程序员感到自己知道发生了什么&amp;mdash;而不是使用单引号作为分隔符，这使Ada程序员感到自己知道发生了什么。因为仍然支持老式语法以实现向后兼容性，所以如果您尝试使用诸如 &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; 类的字符串，则将访问 &lt;code&gt;$owner::s&lt;/code&gt; ;也就是说，包 &lt;code&gt;owner&lt;/code&gt; 的$ s变量可能不是您的意思。使用括号消除歧义，例如 &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9379928fc066063abf44caaff061ee5071ad9c7" translate="yes" xml:space="preserve">
          <source>The old style indented the note:</source>
          <target state="translated">旧式缩进注。</target>
        </trans-unit>
        <trans-unit id="3d9dec9262d361c18938bccf6c6a18acfa10894f" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="translated">较旧（且可能已过时）的库&lt;a href=&quot;Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;，&lt;a href=&quot;Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e6c9fb581904d8c9128af585c935239bf8557de2" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="translated">较旧（且可能已过时）的库&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf3a69ba409143423723e457fea838a29577af44" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="translated">较旧的库&lt;a href=&quot;Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;，&lt;a href=&quot;Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;，&lt;a href=&quot;Pod::SAX&quot;&gt;Pod :: SAX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da753c735f79a0349646d5159490ba674b8d624f" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="translated">较旧的库&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod :: SAX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="995ae7aa276ffe30824f52880be0efab53f1e92d" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;,
$bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; .</source>
          <target state="translated">add_bits（）的一个参数形式采用$ bitstring的&amp;ldquo; 1&amp;rdquo;和&amp;ldquo; 0&amp;rdquo;字符作为参数。这是 &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;, $bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="1b86570e54f795ca97d5fe14e7650da16943e0a5" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(pack(&quot;B*&quot;, $bitstring), length($bitstring))&lt;/code&gt;.</source>
          <target state="translated">add_bits（）的一个参数形式采用$ bitstring的&amp;ldquo; 1&amp;rdquo;和&amp;ldquo; 0&amp;rdquo;字符作为参数。这是 &lt;code&gt;$ctx-&amp;gt;add_bits(pack(&quot;B*&quot;, $bitstring), length($bitstring))&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="7fb0ed6067910ab4f7c54b4b88cf43df00178824" translate="yes" xml:space="preserve">
          <source>The one parameter calling convention also still works.</source>
          <target state="translated">一个参数的调用惯例也依然有效。</target>
        </trans-unit>
        <trans-unit id="80912f94b4001d6702c4a5ac8c13128730d9bdf7" translate="yes" xml:space="preserve">
          <source>The one user (apart from the superuser) who has absolute control over a &lt;b&gt;file&lt;/b&gt;. A file may also have a &lt;b&gt;group&lt;/b&gt; of users who may exercise joint ownership if the real owner permits it. See &lt;b&gt;permission bits&lt;/b&gt;.</source>
          <target state="translated">对&lt;b&gt;文件&lt;/b&gt;具有绝对控制权的一个用户（超级用户除外）。文件也可以有一&lt;b&gt;组&lt;/b&gt;用户，如果真实所有者允许，则可以行使共同所有权。请参阅&lt;b&gt;权限位&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="ecb6da0a473e0cefde4e91abce89bab9a6e1b78a" translate="yes" xml:space="preserve">
          <source>The one-shot interface allows you to force the creation of a zip64 zip file by including the &lt;code&gt;Zip64&lt;/code&gt; option.</source>
          <target state="translated">一键式界面允许您通过包含 &lt;code&gt;Zip64&lt;/code&gt; 选项来强制创建zip64 zip文件。</target>
        </trans-unit>
        <trans-unit id="bf794f433c5b5ee5b62cabad4f9e0efe662e76bb" translate="yes" xml:space="preserve">
          <source>The only absolutely mandatory method. Called when the layer is pushed onto the stack. The &lt;code&gt;mode&lt;/code&gt; argument may be NULL if this occurs post-open. The &lt;code&gt;arg&lt;/code&gt; will be non-&lt;code&gt;NULL&lt;/code&gt; if an argument string was passed. In most cases this should call &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; to convert &lt;code&gt;mode&lt;/code&gt; into the appropriate &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; flags in addition to any actions the layer itself takes. If a layer is not expecting an argument it need neither save the one passed to it, nor provide &lt;code&gt;Getarg()&lt;/code&gt; (it could perhaps &lt;code&gt;Perl_warn&lt;/code&gt; that the argument was un-expected).</source>
          <target state="translated">唯一绝对强制的方法。在将层推入堆栈时调用。该 &lt;code&gt;mode&lt;/code&gt; 参数可以为NULL，如果发生这种情况后开放。该 &lt;code&gt;arg&lt;/code&gt; 将非 &lt;code&gt;NULL&lt;/code&gt; 如果参数字符串传递。在大多数情况下，除了层本身执行的任何操作之外，还应该调用 &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; 将 &lt;code&gt;mode&lt;/code&gt; 转换为适当的 &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; 标志。如果某个层不希望有参数，则它既不需要保存传递​​给它的参数，也不需要提供 &lt;code&gt;Getarg()&lt;/code&gt; （它可能会 &lt;code&gt;Perl_warn&lt;/code&gt; 指出该参数是意外的）。</target>
        </trans-unit>
        <trans-unit id="90a79e3c54ca5ed09d00dcfacad6096dece33202" translate="yes" xml:space="preserve">
          <source>The only characters this accepts are the decimal digits '0'..'9'.</source>
          <target state="translated">它只接受十进制数字'0'...'9'。</target>
        </trans-unit>
        <trans-unit id="8efd8a42e658c0f7e91c83e2d2d53f100f4033a8" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt; , (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="translated">唯一的区别是由于 &lt;code&gt;string_vianame&lt;/code&gt; 是运行时，而 &lt;code&gt;\N{}&lt;/code&gt; 是编译时。您不能在 &lt;code&gt;\N{}&lt;/code&gt; 内插值（因此 &lt;code&gt;\N{$variable}&lt;/code&gt; 不起作用）；如果输入名称未知，则 &lt;code&gt;string_vianame&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 而不是语法错误。</target>
        </trans-unit>
        <trans-unit id="77845b478b84dee4e594bd5bbec241147d4e6e80" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt;, (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;undef&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="translated">唯一的区别是由于 &lt;code&gt;string_vianame&lt;/code&gt; 是运行时，而 &lt;code&gt;\N{}&lt;/code&gt; 是编译时。您不能在 &lt;code&gt;\N{}&lt;/code&gt; 内插值（因此 &lt;code&gt;\N{$variable}&lt;/code&gt; 不起作用）；如果输入名称未知，则 &lt;code&gt;string_vianame&lt;/code&gt; 返回 &lt;code&gt;undef&lt;/code&gt; 而不是语法错误。</target>
        </trans-unit>
        <trans-unit id="341b8df1dab5c18fe08d27199395d7d12fe5908e" translate="yes" xml:space="preserve">
          <source>The only flag specified this time was G_SCALAR. That means that the &lt;code&gt;@_&lt;/code&gt; array will be created and that the value returned by</source>
          <target state="translated">这次指定的唯一标志是G_SCALAR。这意味着将创建 &lt;code&gt;@_&lt;/code&gt; 数组，并且由返回的值</target>
        </trans-unit>
        <trans-unit id="1be9c07fcdeba873e922d933912b59d6dffd7f9b" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt; . Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">唯一的插值是从 &lt;code&gt;\\&lt;/code&gt; 对中删除 &lt;code&gt;\&lt;/code&gt; 。因此， &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; 中的 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 实际上被视为连字符，并且没有可用的字符范围。替换 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; 中的 &lt;code&gt;\1&lt;/code&gt; 不能用作 &lt;code&gt;$1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02eece87de941c6c62eda48e906abba6c3ece7c9" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt;. Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;tr'''&lt;/code&gt; and &lt;code&gt;y'''&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;s'''&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt;.</source>
          <target state="translated">唯一的插值是从 &lt;code&gt;\\&lt;/code&gt; 对中删除 &lt;code&gt;\&lt;/code&gt; 。因此， &lt;code&gt;tr'''&lt;/code&gt; 和 &lt;code&gt;y'''&lt;/code&gt; 中的 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 在字面上被视为连字符，并且没有可用的字符范围。替换 &lt;code&gt;s'''&lt;/code&gt; 中的 &lt;code&gt;\1&lt;/code&gt; 不能用作 &lt;code&gt;$1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12717cd3a47ff8f730f2ca2276f3a722ee0a85b7" translate="yes" xml:space="preserve">
          <source>The only issue left is to how to bootstrap</source>
          <target state="translated">唯一剩下的问题是如何启动</target>
        </trans-unit>
        <trans-unit id="77cda32153e2808e7ed17b43ef801a42c30a29bd" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; that</source>
          <target state="translated">唯一一种简单的语句是评估其副作用的表达式。每个简单的语句都必须以分号结尾，除非它是一个块中的最终语句，在这种情况下，分号是可选的。但是，如果该块占用多于一行，则无论如何都应使用分号，因为您最终可能会添加另一行。需要注意的是有像运营商 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; ，并 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; 这</target>
        </trans-unit>
        <trans-unit id="f705477ccbb186a38ab86005af82f68dd900e475" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;eval {}&lt;/code&gt;, &lt;code&gt;sub {}&lt;/code&gt;, and &lt;code&gt;do {}&lt;/code&gt; that</source>
          <target state="translated">唯一一种简单的语句是评估其副作用的表达式。每个简单的语句都必须以分号结尾，除非它是一个块中的最终语句，在这种情况下，分号是可选的。但是，如果该块占用多于一行，则无论如何都应使用分号，因为您最终可能会添加另一行。需要注意的是有像运营商 &lt;code&gt;eval {}&lt;/code&gt; ， &lt;code&gt;sub {}&lt;/code&gt; ，并 &lt;code&gt;do {}&lt;/code&gt; 这</target>
        </trans-unit>
        <trans-unit id="e309b7f80a25c25de4d7facad82c2d1078752823" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;&quot;Prior to Perl v5.22&quot;&lt;/a&gt;).</source>
          <target state="translated">几乎可以肯定，此编译指示的唯一合法使用是每个文件只有一个文件（在顶部，具有文件范围），因为该文件很可能只会以一种编码来编写。在v5.22&lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;之前的&lt;/a&gt;Perls中将应用更多限制（请参阅&amp;ldquo; Perl v5.22之前的版本&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="3f747c4ca5428591254eb88eeb68548667575b4e" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;Prior to Perl v5.22&lt;/a&gt;).</source>
          <target state="translated">几乎可以肯定，此编译指示的唯一合法使用是每个文件只有一个文件（在顶部，具有文件范围），因为该文件很可能只会以一种编码来编写。在v5.22 &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;之前的&lt;/a&gt; Perls中有更多限制（请参阅Perl v5.22之前的版本）。</target>
        </trans-unit>
        <trans-unit id="34c58516de1f8035b02dd5ba10465691170b3177" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt; . To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt; . Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt; , which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="translated">Perl可能支持的唯一多字节（或宽字符）语言环境是UTF-8。这是由于实施的困难，高质量的UTF-8语言环境现已在世界上的每个地区（&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;）发布的事实所致。可以使用&lt;a href=&quot;encode&quot;&gt;编码&lt;/a&gt;转换为您的语言环境的模块。因此，如果您使用这些语言环境之一（例如Big5或Shift JIS），则必须执行这些操作之一。对于UTF-8语言环境，在没有完全UTF-8语言环境支持的Perls（v5.20之前）中，它们可能工作得相当好（取决于您的C库实现），只是因为它们和Perl都存储了占用字符的字符多个字节以相同的方式。但是，即使不是大多数，某些C库实现也可能无法在 &lt;code&gt;LC_CTYPE&lt;/code&gt; 下正确处理Latin-1范围（128-255）中上半部分的字符。要查看某个字符在语言环境下是否为特定类型，Perl使用了 &lt;code&gt;isalnum()&lt;/code&gt; 之类的函数。您的C库可能不适用于具有这些功能的UTF-8语言环境，而是只能在较新的广泛库函数下工作，例如 &lt;code&gt;iswalnum()&lt;/code&gt; ，Perl不使用。这些多字节语言环境被视为单字节语言环境，并且将具有以下限制。从Perl v5.22开始，当Perl检测到它不完全支持的多字节语言环境时，将引发警告消息。</target>
        </trans-unit>
        <trans-unit id="18871d07c0f1be22042f9cbee3498004b8a18ce9" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;https://unicode.org/Public/cldr/2.0.1/&quot;&gt;https://unicode.org/Public/cldr/2.0.1/&lt;/a&gt; for ones that are already set-up, but from an earlier version; &lt;a href=&quot;https://unicode.org/Public/cldr/latest/&quot;&gt;https://unicode.org/Public/cldr/latest/&lt;/a&gt; for the most up-to-date, but you have to extract the POSIX information yourself), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt;. To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt;. Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt;, which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="translated">Perl可能唯一支持的多字节（或宽字符）语言环境是UTF-8。这是由于实施困难，事实是，现已为世界每个地区发布了高质量的UTF-8语言环境（对于已设置的语言环境，则为&lt;a href=&quot;https://unicode.org/Public/cldr/2.0.1/&quot;&gt;https://unicode.org/Public/cldr/2.0.1/&lt;/a&gt; -，但来自较早的版本；&lt;a href=&quot;https://unicode.org/Public/cldr/latest/&quot;&gt;https：//unicode.org/Public/cldr/latest/&lt;/a&gt;是最新的，但是您必须自己提取POSIX信息），否则您将无法全部提取使用&lt;a href=&quot;encode&quot;&gt;编码&lt;/a&gt;转换为/来自您的语言环境的模块。因此，如果您使用这些语言环境之一（例如Big5或Shift JIS），则必须执行其中一项操作。对于UTF-8语言环境，在没有完全UTF-8语言环境支持的Perls（v5.20之前）中，它们可能工作得相当好（取决于您的C库实现），仅因为它们和Perl都存储占用字符的原因多个字节以相同的方式。但是，即使不是大多数，某些C库实现也可能无法在 &lt;code&gt;LC_CTYPE&lt;/code&gt; 下正确处理Latin-1范围（128-255）中上半部分的字符。为了查看某个字符在语言环境下是否为特定类型，Perl使用了 &lt;code&gt;isalnum()&lt;/code&gt; 之类的函数。您的C库可能不适用于具有这些功能的UTF-8语言环境，而只能在诸如以下的较新的宽库函数下工作 &lt;code&gt;iswalnum()&lt;/code&gt; ，Perl不使用。这些多字节语言环境被视为单字节语言环境，并且具有以下描述的限制。从Perl v5.22开始，当Perl检测到它不完全支持的多字节语言环境时，将引发警告消息。</target>
        </trans-unit>
        <trans-unit id="5c17b3d145791de4c679a21722f34ee793cec0ff" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3A%3Astring_vianame%28name%29&quot;&gt;&quot;charnames::string_vianame(name)&quot; in charnames&lt;/a&gt;, and &lt;a href=&quot;Unicode::UCD#namedseq%28%29&quot;&gt;&quot;namedseq()&quot; in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Perl当前支持的唯一非字符属性是&amp;ldquo;命名序列&amp;rdquo;，其中代码点序列被赋予一个名称，通常被视为单个实体。（Perl通过 &lt;code&gt;\N{...}&lt;/code&gt; 双引号结构，&lt;a href=&quot;charnames#charnames%3A%3Astring_vianame%28name%29&quot;&gt;charnames中的&amp;ldquo; charnames :: string_vianame（name）&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;Unicode::UCD#namedseq%28%29&quot;&gt;Unicode :: UCD中的&amp;ldquo; namedseq（）&amp;rdquo;来支持这些功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81ecbc2496d990405244fb5517f23afeb52e9228" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame(name) in charnames&lt;/a&gt;, and &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Perl当前支持的唯一非字符属性是&amp;ldquo;命名序列&amp;rdquo;，其中代码点序列被赋予一个名称，通常被视为单个实体。（Perl通过 &lt;code&gt;\N{...}&lt;/code&gt; 双引号结构，&lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames中的charnames :: string_vianame（name）&lt;/a&gt;和&lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;Unicode :: UCD中的namedseq（）&lt;/a&gt;支持这些功能。</target>
        </trans-unit>
        <trans-unit id="4392ba6f21132243d1d665e363dbf9f2d5cd7f44" translate="yes" xml:space="preserve">
          <source>The only non-single-byte locale Perl supports is (starting in v5.20) UTF-8. This means that code points above 255 are treated as Unicode no matter what locale is in effect (since UTF-8 implies Unicode).</source>
          <target state="translated">Perl 唯一支持的非单字节语言是 UTF-8(从 v5.20 开始)。这意味着,无论使用的是哪种locale,255以上的代码点都会被视为Unicode(因为UTF-8意味着Unicode)。</target>
        </trans-unit>
        <trans-unit id="9a67bc69297226e55a92fe7a2acd416579cf6146" translate="yes" xml:space="preserve">
          <source>The only objective benefit to using &lt;code&gt;DirHandle&lt;/code&gt; is that it avoids namespace pollution by creating globs to hold directory handles.</source>
          <target state="translated">使用 &lt;code&gt;DirHandle&lt;/code&gt; 的唯一客观好处是，它通过创建glob来保存目录句柄来避免名称空间污染。</target>
        </trans-unit>
        <trans-unit id="29b92533d26d29124ecd17a1f17bcca141dd3115" translate="yes" xml:space="preserve">
          <source>The only other constraint is you must pre-declare how many tests you plan to run. This is in case something goes horribly wrong during the test and your test program aborts, or skips a test or whatever. You do this like so:</source>
          <target state="translated">唯一的限制是你必须预先声明你计划运行多少测试。这是为了防止在测试过程中出现可怕的错误,你的测试程序中止,或跳过一个测试或其他什么。你可以这样做。</target>
        </trans-unit>
        <trans-unit id="c629e4aca342ff5d679b1354d5badb624d786fd5" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; . Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="translated">可能不应该发出警告的唯一地方是，如果优化导致甚至完全不尝试整个模式匹配。例如，Perl可能会发现，要使字符串与某个正则表达式模式匹配，该字符串必须包含子字符串 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 。在尝试进行匹配之前，Perl可能会寻找该子字符串，如果找不到该子字符串，则在没有实际尝试的情况下立即使匹配失败。因此即使字符串包含高于Unicode的代码点，也不会生成警告。</target>
        </trans-unit>
        <trans-unit id="2a1424cb465056db403b0376b90df7285a39a496" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt;. Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="translated">可能不应该发出警告的唯一地方是，如果优化导致甚至完全不尝试整个模式匹配。例如，Perl可能会发现，要使字符串与某个正则表达式模式匹配，该字符串必须包含子字符串 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 。在尝试进行匹配之前，Perl可能会寻找该子字符串，如果找不到该子字符串，则会立即使匹配失败，而无需实际尝试。因此，即使字符串包含高于Unicode的代码点，也不会生成警告。</target>
        </trans-unit>
        <trans-unit id="3f03961d151195642787106427ad37fb0df08a21" translate="yes" xml:space="preserve">
          <source>The only pragmas to be completely supported are: &lt;code&gt;use warnings&lt;/code&gt;, &lt;code&gt;use strict&lt;/code&gt;, &lt;code&gt;use bytes&lt;/code&gt;, &lt;code&gt;use integer&lt;/code&gt; and &lt;code&gt;use feature&lt;/code&gt;.</source>
          <target state="translated">唯一要完全支持的编译指示是： &lt;code&gt;use warnings&lt;/code&gt; ， &lt;code&gt;use strict&lt;/code&gt; ， &lt;code&gt;use bytes&lt;/code&gt; ， &lt;code&gt;use integer&lt;/code&gt; 和 &lt;code&gt;use feature&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7dc3eb2b3b66b20134df38443b06998c7b78e71" translate="yes" xml:space="preserve">
          <source>The only purpose of this step is to create the needed directories, and let you know the names of these directories. From the output you can see that the directory for the extension is</source>
          <target state="translated">这一步的唯一目的是创建需要的目录,并让你知道这些目录的名称。从输出中你可以看到,扩展的目录是</target>
        </trans-unit>
        <trans-unit id="e4350c2629055827ad3a8b68cc619a2e785707ba" translate="yes" xml:space="preserve">
          <source>The only required argument is &lt;a href=&quot;IO::Socket#Domain&quot;&gt;&quot;Domain&quot; in IO::Socket&lt;/a&gt;.</source>
          <target state="translated">唯一需要的参数是&lt;a href=&quot;IO::Socket#Domain&quot;&gt;IO :: Socket中的&amp;ldquo;域&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b743cce5d7490a9e24b6e3b1af9c9095cbf1cfd" translate="yes" xml:space="preserve">
          <source>The only required part is the first field, the name of a module (e.g. Foo::Bar, i.e.</source>
          <target state="translated">唯一需要的部分是第一个字段,即一个模块的名称(如Foo::Bar,即。</target>
        </trans-unit>
        <trans-unit id="18bf9d2d31226fde65cb844d15b4e9ac5dd2e6d9" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are &lt;code&gt;GV_SUPER&lt;/code&gt; and &lt;code&gt;SVf_UTF8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 的唯一有效值是 &lt;code&gt;GV_SUPER&lt;/code&gt; 和 &lt;code&gt;SVf_UTF8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a47d064470efbb85a4c64c4b51a76380fc85cda0" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are GV_SUPER and SVf_UTF8.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 的唯一有效值为GV_SUPER和SVf_UTF8。</target>
        </trans-unit>
        <trans-unit id="27c03514e890f7e1e455be24f92d8de38867990a" translate="yes" xml:space="preserve">
          <source>The only thing to note is that, in both the static and virtual methods, the method name is not passed via the stack--it is used as the first parameter to</source>
          <target state="translated">唯一需要注意的是,在静态和虚拟方法中,方法名不是通过堆栈传递的--它是作为</target>
        </trans-unit>
        <trans-unit id="9a6d4c47eb4eb3548f61bca4b08d9e197f6e1287" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine</source>
          <target state="translated">您唯一需要记住的是 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程</target>
        </trans-unit>
        <trans-unit id="3a8286223f476561d867d00238ced07bc0080bf9" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;import&lt;/code&gt; subroutine</source>
          <target state="translated">您唯一需要记住的是 &lt;code&gt;import&lt;/code&gt; 子例程</target>
        </trans-unit>
        <trans-unit id="befc7f9200d677e41e635df70642f3120f18f3ee" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. When used as a number, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt; ; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt; ; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="translated">在Perl中需要声明的唯一内容是报表格式和子例程（有时甚至不是子例程）。标量变量将保留未定义的值（ &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），直到为其分配了已定义的值为止，该值不是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。当用作数字时， &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 被视为 &lt;code&gt;0&lt;/code&gt; ；当用作字符串时，将其视为空字符串 &lt;code&gt;&quot;&quot;&lt;/code&gt; ；当用作未分配的参考时，将其视为错误。如果启用警告，则在将 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 视为字符串或数字时，系统会通知您未初始化的值。好吧，通常。布尔上下文，例如：</target>
        </trans-unit>
        <trans-unit id="8063526283668c78bfe80f0053d75f81f3e00c7f" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;undef&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;undef&lt;/code&gt;. When used as a number, &lt;code&gt;undef&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt;; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt;; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;undef&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="translated">在Perl中需要声明的唯一内容是报表格式和子例程（有时甚至不是子例程）。标量变量将保留未定义的值（ &lt;code&gt;undef&lt;/code&gt; ），直到为其分配了已定义的值为止，该值不是 &lt;code&gt;undef&lt;/code&gt; 。当用作数字时， &lt;code&gt;undef&lt;/code&gt; 被视为 &lt;code&gt;0&lt;/code&gt; ；当用作字符串时，将其视为空字符串 &lt;code&gt;&quot;&quot;&lt;/code&gt; ；当用作未分配的参考时，将被视为错误。如果启用警告，则在将 &lt;code&gt;undef&lt;/code&gt; 视为字符串或数字时，系统会通知您未初始化的值。好吧，通常。布尔上下文，例如：</target>
        </trans-unit>
        <trans-unit id="31db2a79cbb61c12ae686554ebaa8cf24c12eba8" translate="yes" xml:space="preserve">
          <source>The only times that you absolutely</source>
          <target state="translated">只有在你绝对</target>
        </trans-unit>
        <trans-unit id="cdb480d4e9cef712b05b3e3ca053bd2714b2800c" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt; .</source>
          <target state="translated">更改此设置的唯一方法是为 &lt;code&gt;'|'&lt;/code&gt; 提供您自己的子例程 。</target>
        </trans-unit>
        <trans-unit id="cc6185c346e8349db594c7e55f3c51f34e33f48b" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt;.</source>
          <target state="translated">更改此设置的唯一方法是为 &lt;code&gt;'|'&lt;/code&gt; 提供您自己的子例程 。</target>
        </trans-unit>
        <trans-unit id="c65da34730ca57e068ebb9d99972660fe1a63a25" translate="yes" xml:space="preserve">
          <source>The only way to override a lexical warnings setting is with the &lt;b&gt;-W&lt;/b&gt; or &lt;b&gt;-X&lt;/b&gt; command line flags.</source>
          <target state="translated">覆盖词法警告设置的唯一方法是使用&lt;b&gt;-W&lt;/b&gt;或&lt;b&gt;-X&lt;/b&gt;命令行标志。</target>
        </trans-unit>
        <trans-unit id="7ea2eaf8e5a3a274ae0f1dbb910613954b91ee9b" translate="yes" xml:space="preserve">
          <source>The only way you will ever be allowed to rebase or modify the history of a pushed branch is to delete it and push it as a new branch under the same name. Please think carefully about doing this. It may be better to sequentially rename your branches so that it is easier for others working with you to cherry-pick their local changes onto the new version. (XXX: needs explanation).</source>
          <target state="translated">唯一允许您重写或修改已推送分支历史的方法是删除它,然后以相同的名称推送一个新的分支。请仔细考虑这样做。最好的办法是按顺序重命名您的分支,这样其他与您一起工作的人就能更容易地将他们的本地修改挑到新版本上。(XXX:需要解释)。</target>
        </trans-unit>
        <trans-unit id="cbd9c5131dd8145825db3c00e95fdf65545c95f3" translate="yes" xml:space="preserve">
          <source>The op tree is connected in two ways: you can imagine that there are two &quot;routes&quot; through it, two orders in which you can traverse the tree. First, parse order reflects how the parser understood the code, and secondly, execution order tells perl what order to perform the operations in.</source>
          <target state="translated">op树有两种连接方式:你可以想象有两条 &quot;路线 &quot;穿过它,有两种顺序可以遍历这棵树。首先,解析顺序反映了解析器如何理解代码,其次,执行顺序告诉perl以什么顺序执行操作。</target>
        </trans-unit>
        <trans-unit id="87587f650625db0a4ecb1818a87bdf007aa521f9" translate="yes" xml:space="preserve">
          <source>The op tree representing the code block is returned. This is always a real op, never a null pointer. It will normally be a &lt;code&gt;lineseq&lt;/code&gt; list, including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops. No ops to construct any kind of runtime scope are included by virtue of it being a block.</source>
          <target state="translated">返回表示代码块的操作树。这始终是一个真实的操作，绝不是空指针。它通常是一个 &lt;code&gt;lineseq&lt;/code&gt; 列表，包括 &lt;code&gt;nextstate&lt;/code&gt; 或等效的操作。由于它是一个块，因此不包含任何构造任何类型的运行时范围的操作。</target>
        </trans-unit>
        <trans-unit id="0ada1b492ff1e32feecd23ad2e48d8b585f13df5" translate="yes" xml:space="preserve">
          <source>The op tree representing the expression is returned. If an optional expression is absent, a null pointer is returned, otherwise the pointer will be non-null.</source>
          <target state="translated">返回代表表达式的操作树。如果没有可选的表达式,则返回一个空指针,否则指针将是非空的。</target>
        </trans-unit>
        <trans-unit id="e036bcd0d780fe688c97dce4eafd340bcf362abb" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;&quot;newSTATEOP&quot;&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="translated">返回表示该语句的操作树。如果该语句为空，则可能为空指针，例如，如果该语句实际上是子例程定义（具有编译时的副作用）。如果不为null，则将由ops直接执行该语句，适合传递给&lt;a href=&quot;#newSTATEOP&quot;&gt;&amp;ldquo; newSTATEOP&amp;rdquo;&lt;/a&gt;。它通常不会包含 &lt;code&gt;nextstate&lt;/code&gt; 或等效操作（除了那些完全包含在语句内的作用域中嵌入的操作）。</target>
        </trans-unit>
        <trans-unit id="b8ec717bc605b587bc78dee46e74bc74f77b59be" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="translated">返回表示该语句的操作树。如果语句为空，则可能为空指针，例如，如果该语句实际上是子例程定义（具有编译时的副作用）。如果不为null，则将由ops直接实现该语句，适合传递给&lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;。它通常不会包含 &lt;code&gt;nextstate&lt;/code&gt; 或等效操作（除了那些完全包含在语句内的作用域中嵌入的操作）。</target>
        </trans-unit>
        <trans-unit id="2254139a8dcdd28ca766e4d41d0739d872c7e21b" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;&quot;newSTATEOP&quot;&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="translated">返回表示该语句的操作树。如果该语句为空，则可能为空指针，例如，如果该语句实际上是子例程定义（具有编译时的副作用）。如果不为null，则它将是&lt;a href=&quot;#newSTATEOP&quot;&gt;&amp;ldquo; newSTATEOP&amp;rdquo;&lt;/a&gt;调用的结果，通常包括 &lt;code&gt;nextstate&lt;/code&gt; 或等效的op。</target>
        </trans-unit>
        <trans-unit id="55a48ae410aca9d3fe9a16a19fa26233018ca671" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="translated">返回表示该语句的操作树。如果语句为空，则可能为空指针，例如，如果该语句实际上是子例程定义（具有编译时的副作用）。如果不为null，则它将是&lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;调用的结果，通常包括 &lt;code&gt;nextstate&lt;/code&gt; 或等效的op。</target>
        </trans-unit>
        <trans-unit id="80258368ca90132ffffe94b685646de5d3e0a9ff" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement sequence is returned. This may be a null pointer if the statements were all null, for example if there were no statements or if there were only subroutine definitions (which have compile-time side effects). If not null, it will be a &lt;code&gt;lineseq&lt;/code&gt; list, normally including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops.</source>
          <target state="translated">返回表示语句序列的操作树。如果语句全为空，则可能为空指针，例如，如果不存在任何语句，或者仅存在子例程定义（具有编译时副作用）。如果不为null，它将是一个 &lt;code&gt;lineseq&lt;/code&gt; 列表，通常包括 &lt;code&gt;nextstate&lt;/code&gt; 或等效的ops。</target>
        </trans-unit>
        <trans-unit id="535ccca6a54b74bb28aa7a40bc1a8b66e55f76db" translate="yes" xml:space="preserve">
          <source>The op tree to unpack the arguments from the stack at runtime is returned. This op tree should appear at the beginning of the compiled function. The caller may wish to use &lt;a href=&quot;#op_append_list&quot;&gt;&quot;op_append_list&quot;&lt;/a&gt; to build their function body after it, or splice it together with the body before calling &lt;a href=&quot;#newATTRSUB&quot;&gt;&quot;newATTRSUB&quot;&lt;/a&gt;.</source>
          <target state="translated">返回在运行时从堆栈解压缩参数的op树。该操作树应出现在已编译函数的开头。调用者可能希望使用&lt;a href=&quot;#op_append_list&quot;&gt;&amp;ldquo; op_append_list&amp;rdquo;&lt;/a&gt;在其之后构建其函数主体，或者在调用&lt;a href=&quot;#newATTRSUB&quot;&gt;&amp;ldquo; newATTRSUB&amp;rdquo;&lt;/a&gt;之前将其与主体拼接在一起。</target>
        </trans-unit>
        <trans-unit id="c35c6433e7899b6be9854e9907788616c4dfa0ff" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;&quot;OP flags abbreviations&quot;&lt;/a&gt;).</source>
          <target state="translated">在（&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;&amp;ldquo; OP标志缩写&amp;rdquo;&lt;/a&gt;）中描述了op标志（例如&lt;b&gt;'sK / 2'&lt;/b&gt;）。</target>
        </trans-unit>
        <trans-unit id="ee004e116194c04a5a9d3789b699d566539ba78d" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP flags abbreviations&lt;/a&gt;).</source>
          <target state="translated">op标志（&lt;b&gt;ex'sK / 2'&lt;/b&gt;）在（&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP标志缩写&lt;/a&gt;）中进行了描述。</target>
        </trans-unit>
        <trans-unit id="8eec999d2cf9d026309d4e24a85ebd9a75290847" translate="yes" xml:space="preserve">
          <source>The open source license that Larry Wall created for Perl, maximizing Perl&amp;rsquo;s usefulness, availability, and modifiability. The current version is 2. (&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;).</source>
          <target state="translated">拉里&amp;middot;沃尔（Larry Wall）为Perl创建的开源许可证，使Perl的有用性，可用性和可修改性最大化。当前版本为2。（&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d076872f9624d7a17cf4c11c33523c71a8396f8e" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given $cmd and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="translated">open2()函数运行给定的$cmd,并连接$chld_out进行读取和$chld_in进行写入。这就是你认为应该工作的东西,当你尝试的时候</target>
        </trans-unit>
        <trans-unit id="2904189d67cdca2709e7a78ebf9563187c0c5785" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given command and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="translated">open2()函数运行给定的命令,并连接$chld_out进行读取,$chld_in进行写入。这就是你认为应该工作的东西,当你尝试</target>
        </trans-unit>
        <trans-unit id="793bd01a6b2dc5e14b8e95bd14b22d7c8c213b3b" translate="yes" xml:space="preserve">
          <source>The operand of some types of regop is a literal string; for others, it is a regop leading into a sub-program. In particular, the operand of a &lt;code&gt;BRANCH&lt;/code&gt; node is the first regop of the branch.</source>
          <target state="translated">某些类型的regop的操作数是文字字符串；对于其他人来说，这是导致子程序重新使用的方法。特别是， &lt;code&gt;BRANCH&lt;/code&gt; 节点的操作数是分支的第一个重新操作。</target>
        </trans-unit>
        <trans-unit id="cf8df21203ce7e715434391039cee96dd7ffc65d" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt; ) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="translated">操作系统，设备驱动程序，C库和Perl运行时系统都共同使程序员能够将单个字符（ &lt;code&gt;\n&lt;/code&gt; ）视为行终止符，而无需考虑外部表示形式。在许多操作系统上，本机文本文件表示形式与内部表示形式匹配，但是在某些平台上， &lt;code&gt;\n&lt;/code&gt; 的外部表示形式由多个字符组成。</target>
        </trans-unit>
        <trans-unit id="3f9b4af2476a3677a8d756957b80eb4422b5ccdb" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt;) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="translated">操作系统，设备驱动程序，C库和Perl运行时系统都共同使程序员可以将单个字符（ &lt;code&gt;\n&lt;/code&gt; ）视为行终止符，而无需考虑外部表示形式。在许多操作系统上，本机文本文件表示形式与内部表示形式匹配，但是在某些平台上， &lt;code&gt;\n&lt;/code&gt; 的外部表示形式由多个字符组成。</target>
        </trans-unit>
        <trans-unit id="8c6975d92732aba7cc117877a890c8662a217abc" translate="yes" xml:space="preserve">
          <source>The operation of the &lt;code&gt;%ENV&lt;/code&gt; array depends on the translation of the logical name</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; 数组的操作取决于逻辑名的转换</target>
        </trans-unit>
        <trans-unit id="1fcdc1a8281a2698369d4d0c5ac8331125832af5" translate="yes" xml:space="preserve">
          <source>The operation of the bval option warrants some discussion. Here is the definition of bval from the Berkeley DB 1.85 recno manual page:</source>
          <target state="translated">bval选项的操作值得讨论。以下是Berkeley DB 1.85 recno手册中对bval的定义。</target>
        </trans-unit>
        <trans-unit id="f8261c0231b653877a248b54abf80f0b93e9f204" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; , and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">此方法的操作还受 &lt;code&gt;archlibexp&lt;/code&gt; ， &lt;code&gt;cccdlflags&lt;/code&gt; ， &lt;code&gt;ccflags&lt;/code&gt; ， &lt;code&gt;optimize&lt;/code&gt; 和 &lt;code&gt;cc&lt;/code&gt; 条目 &lt;code&gt;Config.pm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebf43357cdf326de3a784f122cc30174e4d696c9" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt;, &lt;code&gt;cccdlflags&lt;/code&gt;, &lt;code&gt;ccflags&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt;, and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt;.</source>
          <target state="translated">此方法的操作还受 &lt;code&gt;archlibexp&lt;/code&gt; ， &lt;code&gt;cccdlflags&lt;/code&gt; ， &lt;code&gt;ccflags&lt;/code&gt; ， &lt;code&gt;optimize&lt;/code&gt; 和 &lt;code&gt;cc&lt;/code&gt; 条目 &lt;code&gt;Config.pm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ea94336b097e013eb83f32bbba38514d8eaa887" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; , and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">此方法的操作还受 &lt;code&gt;lddlflags&lt;/code&gt; ， &lt;code&gt;shrpenv&lt;/code&gt; 和 &lt;code&gt;ld&lt;/code&gt; 条目 &lt;code&gt;Config.pm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9af43d4cfed7d96567a247c3d560f72f4c234173" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt;, &lt;code&gt;shrpenv&lt;/code&gt;, and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt;.</source>
          <target state="translated">此方法的操作还受 &lt;code&gt;lddlflags&lt;/code&gt; ， &lt;code&gt;shrpenv&lt;/code&gt; 和 &lt;code&gt;ld&lt;/code&gt; 条目 &lt;code&gt;Config.pm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cf8b3d14dd93250118a75dcead35353084d8d3c" translate="yes" xml:space="preserve">
          <source>The operations that are affected by locale are:</source>
          <target state="translated">受地域影响的业务有:</target>
        </trans-unit>
        <trans-unit id="4ea8be07a0890d457a63bbbdc0361b2f2a0630bf" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="translated">运算符 &lt;code&gt;not&lt;/code&gt; 不是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 的有效键。但是，如果运算符 &lt;code&gt;!&lt;/code&gt; 过载则该相同的实现将被用于 &lt;code&gt;not&lt;/code&gt; （因为两个操作符的优先仅不同）。</target>
        </trans-unit>
        <trans-unit id="e62d966af3836010344e801b17dfde35cf80a445" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;use overload&lt;/code&gt;. However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="translated">运算符 &lt;code&gt;not&lt;/code&gt; 不是 &lt;code&gt;use overload&lt;/code&gt; 的有效键。但是，如果运算符 &lt;code&gt;!&lt;/code&gt; 过载则该相同的实现将被用于 &lt;code&gt;not&lt;/code&gt; （因为两个操作符的优先仅不同）。</target>
        </trans-unit>
        <trans-unit id="78cd830e88c435efad5c7c64c9421f0a7b44115d" translate="yes" xml:space="preserve">
          <source>The operator may be assigned to if both the 2nd and 3rd arguments are legal lvalues (meaning that you can assign to them):</source>
          <target state="translated">如果第2个和第3个参数都是合法的l值(意味着你可以对它们进行赋值),则可以对该运算符进行赋值。</target>
        </trans-unit>
        <trans-unit id="5904b513e41f7f0a3948a698bdf838835b48e7f3" translate="yes" xml:space="preserve">
          <source>The opname, as in &lt;b&gt;'add[t1]'&lt;/b&gt;, may be followed by op-specific information in parentheses or brackets (ex &lt;b&gt;'[t1]'&lt;/b&gt;).</source>
          <target state="translated">与&lt;b&gt;&amp;ldquo; add [t1]&amp;rdquo;中的操作名一样&lt;/b&gt;，可以在括号或方括号（例如&lt;b&gt;&amp;ldquo; [t1]&amp;rdquo;&lt;/b&gt;）后跟操作特定的信息。</target>
        </trans-unit>
        <trans-unit id="4a764821c24945c6b9d29fb8f23336e4895936b8" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;&quot;catdir&quot;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#catdir&quot;&gt;&amp;ldquo; catdir&amp;rdquo;&lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="18a01865affffe01d68458832d996fae1c28b752" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;.</source>
          <target state="translated">的相对&lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da407a5a37cdd431c49815120665c0495df714be" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir%28%29&quot;&gt;&quot;catdir()&quot;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#catdir%28%29&quot;&gt;&amp;ldquo; catdir（）&amp;rdquo;&lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="e8b12f229c6486073ad774a1dc49a9e1e9fe1afd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir()&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#catdir()&quot;&gt;catdir（）&lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="cd5ab607bfc9b28a62d0ee095cfa34da1a0a1edd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;../spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;../spec#catdir&quot;&gt;catdir（）&lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="72e60997864c75a6b42c630a5cd3b7d0d96cb145" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;File::Spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;File::Spec#catdir&quot;&gt;catdir（）&lt;/a&gt;的反义词。</target>
        </trans-unit>
        <trans-unit id="1ebefb2669972c85d8b9e00b79503067268d1b9d" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt; .</source>
          <target state="translated">与 &lt;code&gt;catdir()&lt;/code&gt; 相反。</target>
        </trans-unit>
        <trans-unit id="ce2ff0fee10bb0851a17501763837139e03ed67c" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;catdir()&lt;/code&gt; 的反义词。</target>
        </trans-unit>
        <trans-unit id="9a36830f45796b87c226ab6318291313f5d62c75" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;encode&lt;/code&gt;: expects a JSON text and tries to parse it, returning the resulting simple scalar or reference. Croaks on error.</source>
          <target state="translated">相反的 &lt;code&gt;encode&lt;/code&gt; ：需要一个JSON文本并尝试解析它，返回生成的简单标量或引用。出错时发出嘶哑的声音。</target>
        </trans-unit>
        <trans-unit id="f81bb459c3e1d2a0353a3947d9d6ef14ef3f4c25" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;encode_json&lt;/code&gt;: expects an UTF-8 (binary) string and tries to parse that as an UTF-8 encoded JSON text, returning the resulting reference. Croaks on error.</source>
          <target state="translated">与 &lt;code&gt;encode_json&lt;/code&gt; 相反：需要一个UTF-8（二进制）字符串，并尝试将其解析为UTF-8编码的JSON文本，并返回结果引用。出错时发出嘶哑的声音。</target>
        </trans-unit>
        <trans-unit id="9058f904dc63789872dd9542a7b1316b89449f40" translate="yes" xml:space="preserve">
          <source>The opset and opset_to_ops functions can be used to convert from a list of operators to an opset and</source>
          <target state="translated">opset和opset_to_ops函数可以用来将运算符列表转换为OPSET和</target>
        </trans-unit>
        <trans-unit id="e0e7014b5567d7771bd0933f5acd1310aac22e0f" translate="yes" xml:space="preserve">
          <source>The optag name used must not be defined already (define_optag will croak if it is already defined). Optag names are global to the perl process and optag definitions cannot be altered or deleted once defined.</source>
          <target state="translated">所使用的optag名称不能是已经定义好的 (如果已经定义好了,define_optag就会崩溃)。optag名称是全局性的,一旦定义了optag,就不能更改或删除。</target>
        </trans-unit>
        <trans-unit id="16ae99f8eb8c5eb6cf77bcb07b90faddacb6b646" translate="yes" xml:space="preserve">
          <source>The optimizer-specific information is used to avoid entering (a slow) regex engine on strings that will not definitely match. If the &lt;code&gt;isall&lt;/code&gt; flag is set, a call to the regex engine may be avoided even when the optimizer found an appropriate place for the match.</source>
          <target state="translated">优化程序特定的信息用于避免在肯定不会匹配的字符串上输入（缓慢的）正则表达式引擎。如果设置了 &lt;code&gt;isall&lt;/code&gt; 标志，即使优化器找到了合适的匹配位置，也可以避免对正则表达式引擎的调用。</target>
        </trans-unit>
        <trans-unit id="c2bcebf69d65f38d819f2ef47d3870130b4b4a34" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="translated">该选项不带参数，可以通过在其前面加上&amp;ldquo; no&amp;rdquo;或&amp;ldquo; no-&amp;rdquo;来取反。例如 &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; 将允许 &lt;code&gt;--foo&lt;/code&gt; （值1将被分配），以及 &lt;code&gt;--nofoo&lt;/code&gt; 和 &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; （值0将被分配）。如果该选项具有别名，则这也适用于别名。</target>
        </trans-unit>
        <trans-unit id="d9db329442e437205bd55b086c5b9e99baf5686d" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--no-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="translated">该选项不带参数，可以通过在其前面加上&amp;ldquo; no&amp;rdquo;或&amp;ldquo; no-&amp;rdquo;来取反。例如 &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; 将允许 &lt;code&gt;--foo&lt;/code&gt; （将分配值1）以及 &lt;code&gt;--nofoo&lt;/code&gt; 和 &lt;code&gt;--no-foo&lt;/code&gt; （将分配值0）。如果该选项具有别名，则这也适用于别名。</target>
        </trans-unit>
        <trans-unit id="05bc04ade0e6f0bfb276419b00c5f9d55f933117" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt; , when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="translated">该选项不带参数，并且每次出现在命令行中时都将增加1。例如， &lt;code&gt;&quot;more+&quot;&lt;/code&gt; 与 &lt;code&gt;--more --more --more&lt;/code&gt; 一起使用时，将使该值增加3倍，从而得出3的值（前提是该值是0或首先未定义）。</target>
        </trans-unit>
        <trans-unit id="d8e253e20697ea76ff418e0292092a5b47f9f4f6" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt;, when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="translated">该选项不带参数，并且每次出现在命令行中时都将增加1。例如， &lt;code&gt;&quot;more+&quot;&lt;/code&gt; 与 &lt;code&gt;--more --more --more&lt;/code&gt; 一起使用时，将使该值增加3倍，从而得出3的值（前提是该值是0或首先是未定义的）。</target>
        </trans-unit>
        <trans-unit id="e6c73626524fd7b39cf23cb6ceb0594624a4560f" translate="yes" xml:space="preserve">
          <source>The option name as specified to the GetOptions() function is called the option</source>
          <target state="translated">在GetOptions()函数中指定的选项名称被称为选项。</target>
        </trans-unit>
        <trans-unit id="28e883d6a03c91177fe93b06a907181312e7662a" translate="yes" xml:space="preserve">
          <source>The option names defined below are case insensitive and can be optionally prefixed by a '-'. So all of the following are valid</source>
          <target state="translated">下面定义的选项名不区分大小写,可以选择在前面加上'-'。所以以下所有选项都是有效的</target>
        </trans-unit>
        <trans-unit id="24d6abd722573e6cae42881df7cf4d56ac582b1b" translate="yes" xml:space="preserve">
          <source>The option requires an argument of the given type. Supported types are:</source>
          <target state="translated">该选项需要一个给定类型的参数。支持的类型有:</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">可选的</target>
        </trans-unit>
        <trans-unit id="3cb07c5a1f900e41d71b7af9007db9793c77a65e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;rules&lt;/code&gt; attribute provides direction on which tests should be run in parallel and which should be run sequentially. If no rule data structure is provided, a default data structure is used which makes every test eligible to be run in parallel:</source>
          <target state="translated">可选的 &lt;code&gt;rules&lt;/code&gt; 属性提供了应该并行运行测试以及应该顺序运行测试的方向。如果没有提供规则数据结构，则使用默认数据结构，该结构使每个测试都可以并行运行：</target>
        </trans-unit>
        <trans-unit id="0a173dcd400a0274b32b98f040a162b1b1782227" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt; , in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="translated">可选参数被视为文字字符串，除非它们以 &lt;code&gt;~&lt;/code&gt; 或 &lt;code&gt;!&lt;/code&gt; 开头。，在这种情况下，它们被解释为正则表达式（可能取反）。</target>
        </trans-unit>
        <trans-unit id="cf1d2e0ff9c2439cc3ca174e85a170cee0c435c9" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;, in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="translated">可选参数被视为文字字符串，除非它们以 &lt;code&gt;~&lt;/code&gt; 或 &lt;code&gt;!&lt;/code&gt; 开头。，在这种情况下，它们被解释为正则表达式（可能取反）。</target>
        </trans-unit>
        <trans-unit id="2a457723dc3fc51f575186932ad8e9bfa084daea" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;anyinflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">&lt;code&gt;anyinflate&lt;/code&gt; 函数anyinflate的可选参数（在大多数情况下）与&lt;a href=&quot;#Constructor-Options&quot;&gt;&amp;ldquo;构造函数选项&amp;rdquo;&lt;/a&gt;部分中定义的OO接口所使用的参数相同。下面列出了例外情况</target>
        </trans-unit>
        <trans-unit id="caed88218bf3ae5d8b6dcab0958f36fc2927ec02" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;anyuncompress&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">单次函数 &lt;code&gt;anyuncompress&lt;/code&gt; 的可选参数（在大多数情况下）与&lt;a href=&quot;#Constructor-Options&quot;&gt;&amp;ldquo;构造函数选项&amp;rdquo;&lt;/a&gt;部分中定义的OO接口所使用的参数相同。下面列出了例外情况</target>
        </trans-unit>
        <trans-unit id="131098ff902c48e8458d96c59269d22ab860e8b2" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;bunzip2&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">一键式功能 &lt;code&gt;bunzip2&lt;/code&gt; 的可选参数（在大多数情况下）与&lt;a href=&quot;#Constructor-Options&quot;&gt;&amp;ldquo;构造函数选项&amp;rdquo;&lt;/a&gt;部分中定义的OO接口所使用的参数相同。下面列出了例外情况</target>
        </trans-unit>
        <trans-unit id="6198111cc9801f305996de3eeaa06e0db91b4218" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;bzip2&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">一键式功能 &lt;code&gt;bzip2&lt;/code&gt; 的可选参数（在大多数情况下）与&lt;a href=&quot;#Constructor-Options&quot;&gt;&amp;ldquo;构造函数选项&amp;rdquo;&lt;/a&gt;部分中定义的OO接口所使用的参数相同。下面列出了例外情况</target>
        </trans-unit>
        <trans-unit id="38c4c457d99260789b76c08eab24f06adc17d2c1" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;deflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">单发函数 &lt;code&gt;deflate&lt;/code&gt; 的可选参数（在大多数情况下）与&lt;a href=&quot;#Constructor-Options&quot;&gt;&amp;ldquo;构造函数选项&amp;rdquo;&lt;/a&gt;部分中定义的OO接口所使用的参数相同。下面列出了例外情况</target>
        </trans-unit>
        <trans-unit id="aa1a96727af7ce5f83a4cb5ede379486da415347" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;gunzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">一次性功能 &lt;code&gt;gunzip&lt;/code&gt; 的可选参数（在大多数情况下）与&lt;a href=&quot;#Constructor-Options&quot;&gt;&amp;ldquo;构造函数选项&amp;rdquo;&lt;/a&gt;部分中定义的OO接口所使用的参数相同。下面列出了例外情况</target>
        </trans-unit>
        <trans-unit id="32a1759e80fa595487da188a1ae20babdbb62651" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;gzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">一键式功能 &lt;code&gt;gzip&lt;/code&gt; 的可选参数（在大多数情况下）与&lt;a href=&quot;#Constructor-Options&quot;&gt;&amp;ldquo;构造函数选项&amp;rdquo;&lt;/a&gt;部分中定义的OO接口所使用的参数相同。下面列出了例外情况</target>
        </trans-unit>
        <trans-unit id="81f90f77041e19f7f96b84e59406c9ba0fcd6ff0" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;inflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">单次函数 &lt;code&gt;inflate&lt;/code&gt; 的可选参数在大多数情况下与&lt;a href=&quot;#Constructor-Options&quot;&gt;&amp;ldquo;构造函数选项&amp;rdquo;&lt;/a&gt;部分中定义的OO接口所使用的参数相同。下面列出了例外情况</target>
        </trans-unit>
        <trans-unit id="d34c4bd457be8b3eca1d1b50327dc8555ebf3e0c" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;rawdeflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">一次性函数 &lt;code&gt;rawdeflate&lt;/code&gt; 的可选参数（在大多数情况下）与&lt;a href=&quot;#Constructor-Options&quot;&gt;&amp;ldquo;构造函数选项&amp;rdquo;&lt;/a&gt;部分中定义的OO接口所使用的参数相同。下面列出了例外情况</target>
        </trans-unit>
        <trans-unit id="da3088b2b3f74fb962460f08bf6c521a6489c8dc" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;rawinflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">一键式函数 &lt;code&gt;rawinflate&lt;/code&gt; 的可选参数（在大多数情况下）与&lt;a href=&quot;#Constructor-Options&quot;&gt;&amp;ldquo;构造函数选项&amp;rdquo;&lt;/a&gt;部分中定义的OO接口所使用的参数相同。下面列出了例外情况</target>
        </trans-unit>
        <trans-unit id="564a4703e441e1aa249188b7a46aeee40f3cb3e0" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;unzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">一键式功能 &lt;code&gt;unzip&lt;/code&gt; 的可选参数（在大多数情况下）与&lt;a href=&quot;#Constructor-Options&quot;&gt;&amp;ldquo;构造函数选项&amp;rdquo;&lt;/a&gt;部分中定义的OO接口所使用的参数相同。下面列出了例外情况</target>
        </trans-unit>
        <trans-unit id="e1bd6c00e2144ea2637c42a56845ca5419370d66" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;zip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">一键式功能 &lt;code&gt;zip&lt;/code&gt; 的可选参数（在大多数情况下）与&lt;a href=&quot;#Constructor-Options&quot;&gt;&amp;ldquo;构造函数选项&amp;rdquo;&lt;/a&gt;部分中定义的OO接口所使用的参数相同。下面列出了例外情况</target>
        </trans-unit>
        <trans-unit id="b6ca67d9f48cf9586e57f2ed1e1217218181099d" translate="yes" xml:space="preserve">
          <source>The optional second parameter is ignored if it is larger than the actual length of the first parameter string.</source>
          <target state="translated">如果可选的第二个参数大于第一个参数字符串的实际长度,则会被忽略。</target>
        </trans-unit>
        <trans-unit id="a213bd4ecadb16ed12c21fa427d78bb53fa09a37" translate="yes" xml:space="preserve">
          <source>The options listed above customize parts of the default header, but setting &lt;code&gt;html_header&lt;/code&gt; or &lt;code&gt;html_footer&lt;/code&gt; completely overrides the built-in header or footer. These may be useful if you want to use template tags instead of literal HTML headers and footers or are integrating converted POD pages in a larger website.</source>
          <target state="translated">上面列出的选项可自定义默认标题的各个部分，但是设置 &lt;code&gt;html_header&lt;/code&gt; 或 &lt;code&gt;html_footer&lt;/code&gt; 会完全覆盖内置的标题或页脚。如果您要使用模板标签而不是原义的HTML标头和页脚，或者将转换后的POD页面集成到较大的网站中，则这些选项可能很有用。</target>
        </trans-unit>
        <trans-unit id="01a4d13b9aa02b31aa3157b7bf6c6d232ea80269" translate="yes" xml:space="preserve">
          <source>The options listed in this section control how the</source>
          <target state="translated">本节中列出的选项可以控制</target>
        </trans-unit>
        <trans-unit id="73d081dbc5fcc08b3b44f6576034c6838b070bec" translate="yes" xml:space="preserve">
          <source>The options to this argument is a list of either directories that are searched recursively, or files. (Usually you wouldn't specify files, but just dirs.) Or you can just specify an empty-list, as in $name2path; with the &lt;code&gt;inc&lt;/code&gt; option on, as it is by default.</source>
          <target state="translated">该参数的选项是递归搜索目录或文件的列表。（通常，您将不指定文件，而仅指定目录。）或者您可以仅指定一个空列表，如$ name2path中所示；与 &lt;code&gt;inc&lt;/code&gt; 上，因为它是默认选项。</target>
        </trans-unit>
        <trans-unit id="f0865be52cedbd9c729cf95a5b09eba31832648b" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">optree在线程之间共享。这意味着optree有可能会超过创建它的特定线程（因此是解释器实例）的寿命，因此真正的Perl标量不能存储在optree中。而是使用紧凑形式，该形式只能存储整数（有符号和无符号），字符串或 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 的值-引用和浮点值是字符串化的。如果需要存储多个值或复杂的结构，则应序列化它们，例如使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 。记录了从 &lt;code&gt;%^H&lt;/code&gt; 删除哈希键的过程，并且可以 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; undef值的key区别开来。</target>
        </trans-unit>
        <trans-unit id="758267caaf6c4060844acf8b5ceecd9fefe29a51" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;undef&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;pack&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;undef&lt;/code&gt; with &lt;code&gt;exists&lt;/code&gt;.</source>
          <target state="translated">optree在线程之间共享。这意味着optree有可能会超过创建它的特定线程（因此是解释器实例）的寿命，因此真正的Perl标量不能存储在optree中。而是使用紧凑形式，该形式只能存储整数（有符号和无符号），字符串或 &lt;code&gt;undef&lt;/code&gt; 的值-引用和浮点值是字符串化的。如果您需要存储多个值或复杂的结构，则应序列化它们，例如使用 &lt;code&gt;pack&lt;/code&gt; 。记录了从 &lt;code&gt;%^H&lt;/code&gt; 删除哈希键的过程，并且可以 &lt;code&gt;undef&lt;/code&gt; 与 &lt;code&gt;exists&lt;/code&gt; 值undef和存在的键区分开来。</target>
        </trans-unit>
        <trans-unit id="96c80c62d3615e8dcdce9b967100a640447d19ae" translate="yes" xml:space="preserve">
          <source>The order in which objects are destroyed during the global destruction before the program exits is unpredictable. This means that any objects contained by your object may already have been destroyed. You should check that a contained object is defined before calling a method on it:</source>
          <target state="translated">在程序退出前的全局销毁过程中,对象被销毁的顺序是不可预测的。这意味着你的对象所包含的任何对象可能已经被销毁了。在调用对象的方法之前,你应该先检查是否定义了一个包含的对象。</target>
        </trans-unit>
        <trans-unit id="1362f44821baf70a0c53e26c223d4e933d506d90" translate="yes" xml:space="preserve">
          <source>The order in which this test was run for the given test suite result.</source>
          <target state="translated">对于给定的测试套件结果,该测试的运行顺序。</target>
        </trans-unit>
        <trans-unit id="49bfec1872d74cc3aa3b51bdca30781b5d81ee87" translate="yes" xml:space="preserve">
          <source>The order into which &lt;b&gt;characters&lt;/b&gt; sort. This is used by &lt;b&gt;string&lt;/b&gt; comparison routines to decide, for example, where in this glossary to put &amp;ldquo;collating sequence&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;字符&lt;/b&gt;排序的顺序。这是使用&lt;b&gt;字符串&lt;/b&gt;比较例程来决定，例如，在本词汇表中把&amp;ldquo;排序序列&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="90461643a4b9bcbbb16f181372c5e7705b398666" translate="yes" xml:space="preserve">
          <source>The order of any groups including scripts is not changed.</source>
          <target state="translated">包括脚本在内的任何组的顺序都不会改变。</target>
        </trans-unit>
        <trans-unit id="717cecbd54045d9533e4eb5b41c7c271d10ce913" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open2().</source>
          <target state="translated">参数的顺序与open2()不同。</target>
        </trans-unit>
        <trans-unit id="1338c98402171198f17cc3c818e89af7db3bfea3" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open3().</source>
          <target state="translated">参数的顺序与open3()不同。</target>
        </trans-unit>
        <trans-unit id="c7058991786845d90ace9e46987253e3ce531354" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of</source>
          <target state="translated">顺序与正则表达式相同,正则表达式的结果是</target>
        </trans-unit>
        <trans-unit id="e57a83be29caa0cba0eac2c66aec01c8ecc059c8" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of EXPR, or the pattern contained by capture group</source>
          <target state="translated">顺序与EXPR的结果的正则表达式或捕获组所包含的模式相同。</target>
        </trans-unit>
        <trans-unit id="0f9c7f78b473deec8b2b7b3c5ae964aaebd4ae76" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ).</source>
          <target state="translated">原始的 &lt;code&gt;MD5&lt;/code&gt; 接口是由尼尔&amp;middot;温顿（ &lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; Winton）（N.Winton@axion.bt.co.uk）编写的。</target>
        </trans-unit>
        <trans-unit id="a967938ebcc10e8da7bfe2a06eaff58eb4186ec0" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt;).</source>
          <target state="translated">原始的 &lt;code&gt;MD5&lt;/code&gt; 接口是由尼尔&amp;middot;温顿（ &lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; Winton）（N.Winton@axion.bt.co.uk）编写的。</target>
        </trans-unit>
        <trans-unit id="7eb97de2fdb41a38605a8a09e6520652a52c56e7" translate="yes" xml:space="preserve">
          <source>The original Dylan paper</source>
          <target state="translated">原版迪伦纸</target>
        </trans-unit>
        <trans-unit id="50fea78ce2537fb78816d81a4d2374f6c7eff868" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">原始的Pod :: Text包含通过termcap序列进行格式化的代码，尽管默认情况下未启用该代码，并且使其完全无法正常工作。此重写甚至没有尝试执行此操作，但是它的子类可以执行。寻找&lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af612d63faee2dc3856c86fd5cc671079598e557" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">原始的Pod :: Text包含通过termcap序列进行格式化的代码，尽管默认情况下未启用它，并且使其完全无法正常工作。此重写甚至都没有尝试这样做，但是它的一个子类可以。寻找&lt;a href=&quot;text/termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07dd5b1a0e82d303f2b0b28746eab063467b6ba7" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; . Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden.</source>
          <target state="translated">原始UTF-8规范最多允许6个字节，以允许对最大 &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; 的数字进行编码。Perl继续允许这样做，并已将其扩展到最多13个字节，以对代码点进行编码，直到可以容纳64位字为止。但是，如果您将其中的任何一项输出为不可移植的，Perl将发出警告。并且在严格的UTF-8输入协议下，它们是禁止的。</target>
        </trans-unit>
        <trans-unit id="00b0e9de1cd640deb40f9e9ac2ea76a7fdd363f8" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt;. Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden. In addition, it is now illegal to use a code point larger than what a signed integer variable on your system can hold. On 32-bit ASCII systems, this means &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; is the legal maximum (much higher on 64-bit systems).</source>
          <target state="translated">原始UTF-8规范最多允许6个字节，以允许对最大 &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; 的数字进行编码。 Perl继续允许这样做，并已将其扩展到最多13个字节，以将代码点编码到64位字所能容纳的范围。但是，如果您将其中的任何一项输出为不可移植的，Perl将发出警告。并且在严格的UTF-8输入协议下，它们是禁止的。另外，现在使用大于系统上带符号整数变量可以容纳的代码点的非法行为。在32位ASCII系统上，这意味着 &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; 是合法的最大值（在64位系统上更高）。</target>
        </trans-unit>
        <trans-unit id="a0e54c9386e1df6efdb32bc51b43d382c1fa2bb3" translate="yes" xml:space="preserve">
          <source>The original culture of the pre-populist Internet and the deeply-held beliefs of Perl's author, Larry Wall, gave rise to the free and open distribution policy of Perl. Perl is supported by its users. The core, the standard Perl library, the optional modules, and the documentation you're reading now were all written by volunteers.</source>
          <target state="translated">在互联网流行前的原始文化和Perl作者Larry Wall深深的信念,造就了Perl的免费开放发行政策。Perl得到了用户的支持。核心、标准的Perl库、可选模块以及你现在阅读的文档都是由志愿者编写的。</target>
        </trans-unit>
        <trans-unit id="12a169f5e5252000915162d740c1f7fb51701fdf" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_get_call_checker_flags&quot;&gt;&quot;cv_get_call_checker_flags&quot;&lt;/a&gt;, which does not return checker flags. When using a checker function returned by this function, it is only safe to call it with a genuine GV as its &lt;code&gt;namegv&lt;/code&gt; argument.</source>
          <target state="translated">&lt;a href=&quot;#cv_get_call_checker_flags&quot;&gt;&amp;ldquo; cv_get_call_checker_flags&amp;rdquo;&lt;/a&gt;的原始形式，不返回检查器标志。使用此函数返回的检查器函数时，仅可以使用真正的GV作为其 &lt;code&gt;namegv&lt;/code&gt; 参数来调用它。</target>
        </trans-unit>
        <trans-unit id="eb0e3050b313150315f2790edd37f73f93a916ca" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;&quot;cv_set_call_checker_flags&quot;&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility. The effect of that flag setting is that the check function is guaranteed to get a genuine GV as its &lt;code&gt;namegv&lt;/code&gt; argument.</source>
          <target state="translated">原始形式的&lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;&amp;ldquo; cv_set_call_checker_flags&amp;rdquo;&lt;/a&gt;，将其传递给 &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; 标志以实现向后兼容。该标志设置的作用是确保check函数可以获取真正的GV作为其 &lt;code&gt;namegv&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="124cee86525fe9ae3fd7e1b40184ae6b8c5be548" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility.</source>
          <target state="translated">&lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;的原始形式，将其传递给 &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; 标志以实现向后兼容。</target>
        </trans-unit>
        <trans-unit id="03b164c5369f7a3512c3a8ff6e7ba584a97c85cb" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="translated">CPAN Meta文件的原始格式为&lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt;，相应的文件名为</target>
        </trans-unit>
        <trans-unit id="12304d794d559e0c5fe4691017042f08f8d52e43" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;yaml&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="translated">CPAN Meta文件的原始格式为&lt;a href=&quot;yaml&quot;&gt;YAML&lt;/a&gt;，相应的文件名为</target>
        </trans-unit>
        <trans-unit id="cc0efcec67bc372bca64df41283c31757275dca6" translate="yes" xml:space="preserve">
          <source>The original impetus for &lt;code&gt;Perl_langinfo()&lt;/code&gt; was so that code that needs to find out the current currency symbol, floating point radix character, or digit grouping separator can use, on all systems, the simpler and more thread-friendly &lt;code&gt;nl_langinfo&lt;/code&gt; API instead of &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt; which is a pain to make thread-friendly. For other fields returned by &lt;code&gt;localeconv&lt;/code&gt;, it is better to use the methods given in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; to call &lt;a href=&quot;posix#localeconv&quot;&gt;&lt;code&gt;POSIX::localeconv()&lt;/code&gt;&lt;/a&gt;, which is thread-friendly.</source>
          <target state="translated">&lt;code&gt;Perl_langinfo()&lt;/code&gt; 的原始动力是，需要查找当前货币符号，浮点基数字符或数字分组分隔符的代码可以在所有系统上使用更简单，更线程友好的 &lt;code&gt;nl_langinfo&lt;/code&gt; API，而不是 &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt; 这是使线程友好的痛苦。对于 &lt;code&gt;localeconv&lt;/code&gt; 返回的其他字段，最好使用&lt;a href=&quot;perlcall&quot;&gt;perlcall中&lt;/a&gt;给出的方法来调用&lt;a href=&quot;posix#localeconv&quot;&gt; &lt;code&gt;POSIX::localeconv()&lt;/code&gt; &lt;/a&gt;，该方法是线程友好的。</target>
        </trans-unit>
        <trans-unit id="3411d71283c2f07e45c5a35c0fcbe60c51f6b9bb" translate="yes" xml:space="preserve">
          <source>The original purpose of source filters was to let you encrypt your program source to prevent casual piracy. This isn't all they can do, as you'll soon learn. But first, the basics.</source>
          <target state="translated">源码过滤器的最初目的是让你对程序源码进行加密,以防止随意盗版。这并不是它们能做的全部,你很快就会知道。但首先,是基础知识。</target>
        </trans-unit>
        <trans-unit id="af210dcaae99ceb3aa829035af3557a9ff65ef3a" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;&lt;a href=&quot;#dORIGMARK&quot;&gt;&quot;dORIGMARK&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">XSUB的原始堆栈标记。参见 &lt;code&gt;&lt;a href=&quot;#dORIGMARK&quot;&gt;&quot;dORIGMARK&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a310ea971545c067e472063428469fc1fad9aa30" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;dORIGMARK&lt;/code&gt; .</source>
          <target state="translated">XSUB的原始堆栈标记。参见 &lt;code&gt;dORIGMARK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9fdbd5653ee6341eabe4730cc34935e3db7a992" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt; ), like so:</source>
          <target state="translated">原始样式在块名称中使用空格和连字符（ &lt;code&gt;No_Block&lt;/code&gt; 除外），如下所示：</target>
        </trans-unit>
        <trans-unit id="5c736b5ceaedaf0c5b862acefcb315ae2bd5b9ab" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt;), like so:</source>
          <target state="translated">原始样式在块名称中使用空格和连字符（ &lt;code&gt;No_Block&lt;/code&gt; 除外），如下所示：</target>
        </trans-unit>
        <trans-unit id="8dcbc33a95cd67473b45a522488fc8cc805a4f47" translate="yes" xml:space="preserve">
          <source>The original title was</source>
          <target state="translated">原标题为</target>
        </trans-unit>
        <trans-unit id="07db5f54ef4c59c897a817d5ccebc37f60d9a5b6" translate="yes" xml:space="preserve">
          <source>The original true/false value of whatever was passed into the event (but reduced down to 1 or 0).</source>
          <target state="translated">传入事件中的真/假值(但缩小为1或0)。</target>
        </trans-unit>
        <trans-unit id="9e60244f8f199981b052b42233461b69e602ecf3" translate="yes" xml:space="preserve">
          <source>The original usage can be accomplished by explicit (rather than this pragma's implicit) encoding using the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module:</source>
          <target state="translated">原始用法可以使用&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;模块通过显式（而不是此编译指示的隐式）编码来实现：</target>
        </trans-unit>
        <trans-unit id="7ea4b9a6cd75e55515170d81fe9ec6a923c1c00a" translate="yes" xml:space="preserve">
          <source>The original version of B::Terse was written by Malcolm Beattie, &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;. This wrapper was written by Stephen McCamant, &amp;lt;smcc@MIT.EDU&amp;gt;.</source>
          <target state="translated">B :: Terse的原始版本由Malcolm Beattie撰写，&amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;。该包装由Stephen McCamant，&amp;lt;smcc@MIT.EDU&amp;gt;编写。</target>
        </trans-unit>
        <trans-unit id="ba66fcf36669927e93622e0a65ee5e2d5c9bffdb" translate="yes" xml:space="preserve">
          <source>The original version of PA-RISC, HP no longer sells any system with this chip.</source>
          <target state="translated">PA-RISC的原始版本,惠普已经不再销售任何带有该芯片的系统。</target>
        </trans-unit>
        <trans-unit id="0705420ac769cdd445f5fb673329007ec7bccb68" translate="yes" xml:space="preserve">
          <source>The original version of this article originally appeared in The Perl Journal #10, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">本文的原始版本最初出现在 The Perl Journal #10,版权归 The Perl Journal 1998 所有。本文由 Jon Orwant 和 The Perl Journal 提供。本文档可以在与Perl本身相同的条款下发布。</target>
        </trans-unit>
        <trans-unit id="9009e0d18f1d5f332e2819aa4a5b08efaa84ba15" translate="yes" xml:space="preserve">
          <source>The original was written by Andy Dougherty</source>
          <target state="translated">原著作者是Andy Dougherty。</target>
        </trans-unit>
        <trans-unit id="ac8cde9199e82022f2799533159dbf659a64016b" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;OA_*&lt;/code&gt; constants should not be used.</source>
          <target state="translated">不应使用其他 &lt;code&gt;OA_*&lt;/code&gt; 常量。</target>
        </trans-unit>
        <trans-unit id="e99c9d2a05f195a52a6e3dccd804ac6a0edaa601" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">其他 &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; 方法意味着每个 &lt;code&gt;$parser&lt;/code&gt; 对象仅调用一次；但是只要最后一次调用（并且只有最后一次调用）以 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值结尾，就可以根据需要为每个 &lt;code&gt;$parser&lt;/code&gt; 对象多次调用 &lt;code&gt;parse_lines&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c95c0f77be936d4feacc6aa823fe8dfa8595f61" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;undef&lt;/code&gt; value.</source>
          <target state="translated">其他 &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; 方法意味着每个 &lt;code&gt;$parser&lt;/code&gt; 对象仅被调用一次；但是只要最后一次调用（并且只有最后一次调用）以 &lt;code&gt;undef&lt;/code&gt; 值结尾，就可以根据需要为每个 &lt;code&gt;$parser&lt;/code&gt; 对象多次调用 &lt;code&gt;parse_lines&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0806e4bd09cd5bd6dbaceaf9c0baff74d032490" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt; :</source>
          <target state="translated">如果您知道 &lt;code&gt;STORABLE_freeze&lt;/code&gt; ，其他参数应该看起来很熟悉：</target>
        </trans-unit>
        <trans-unit id="6d6b16332403f12890e319d0cef347a3dc9b9bef" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt;:</source>
          <target state="translated">如果您知道 &lt;code&gt;STORABLE_freeze&lt;/code&gt; ,则其他参数应该看起来很熟悉：</target>
        </trans-unit>
        <trans-unit id="407b63c5d1d6303ca3afdf08c491fa75e0221db1" translate="yes" xml:space="preserve">
          <source>The other big problem with &lt;code&gt;$^W&lt;/code&gt; is the way you can inadvertently change the warning setting in unexpected places in your code. For example, when the code below is run (without the &lt;b&gt;-w&lt;/b&gt; flag), the second call to &lt;code&gt;doit&lt;/code&gt; will trip a &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; warning, whereas the first will not.</source>
          <target state="translated">&lt;code&gt;$^W&lt;/code&gt; 的另一个大问题是您无意中在代码中意外位置更改警告设置的方式。例如，当下面的代码运行（不&lt;b&gt;-w&lt;/b&gt;标志），到第二呼叫 &lt;code&gt;doit&lt;/code&gt; 将跳闸一个 &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; 的警告，而第一不会。</target>
        </trans-unit>
        <trans-unit id="fc649a384c23c44b5ba2efe0b85df4a20e6ec321" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt; , so the executables are named accordingly.</source>
          <target state="translated">其他情况需要更多复杂的过程。下面，我假设Perl的当前版本是 &lt;code&gt;5.8.2&lt;/code&gt; ，因此可执行文件将相应地命名。</target>
        </trans-unit>
        <trans-unit id="427a9edc8baf371e22d2821e2812db4f5b95659f" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt;, so the executables are named accordingly.</source>
          <target state="translated">其他情况需要更多复杂的过程。下面，我假设Perl的当前版本是 &lt;code&gt;5.8.2&lt;/code&gt; ，因此可执行文件将相应地命名。</target>
        </trans-unit>
        <trans-unit id="97290d4117a272682128f8d28555111afe13c240" translate="yes" xml:space="preserve">
          <source>The other common cause is for the characters</source>
          <target state="translated">另一个常见的原因是对于人物</target>
        </trans-unit>
        <trans-unit id="c457b75f143400140761950573f5b842848c756c" translate="yes" xml:space="preserve">
          <source>The other counterpart, in the column labelled &quot;Full-range Unicode&quot;, matches any appropriate characters in the full Unicode character set. For example, &lt;code&gt;\p{Alpha}&lt;/code&gt; matches not just the ASCII alphabetic characters, but any character in the entire Unicode character set considered alphabetic. An entry in the column labelled &quot;backslash sequence&quot; is a (short) equivalent.</source>
          <target state="translated">在标记为&amp;ldquo;全范围Unicode&amp;rdquo;的列中，另一个匹配项与完整Unicode字符集中的任何适当字符匹配。例如， &lt;code&gt;\p{Alpha}&lt;/code&gt; 匹配ASCII字母字符，而且匹配整个Unicode字符集中被视为字母的任何字符。标记为&amp;ldquo;反斜杠序列&amp;rdquo;的列中的条目是（短）等效项。</target>
        </trans-unit>
        <trans-unit id="f185e517dca4682b63e353adac3daa559be38725" translate="yes" xml:space="preserve">
          <source>The other form is called &quot;block eval&quot;. It is less general than string eval, but the code within the BLOCK is parsed only once (at the same time the code surrounding the &lt;code&gt;eval&lt;/code&gt; itself was parsed) and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first, while also providing the benefit of checking the code within BLOCK at compile time. BLOCK is parsed and compiled just once. Since errors are trapped, it often is used to check if a given feature is available.</source>
          <target state="translated">另一种形式称为&amp;ldquo;块评估&amp;rdquo;。它不如字符串eval通用，但是BLOCK中的代码仅解析一次（同时解析 &lt;code&gt;eval&lt;/code&gt; 本身的代码）并在当前Perl程序的上下文中执行。这种形式通常比第一种形式更有效地捕获异常，同时还提供了在编译时检查BLOCK中的代码的好处。 BLOCK仅被解析和编译一次。由于错误被捕获，因此通常用于检查给定功能是否可用。</target>
        </trans-unit>
        <trans-unit id="ece66aa413156fc84b73d204d2d9bbbf0fe1c18a" translate="yes" xml:space="preserve">
          <source>The other hack is to restore FP flags after a call to dlopen(). This helps against similar damage done by DLLs _DLLInitTerm() at runtime. Currently no way to switch these hacks off is provided.</source>
          <target state="translated">另一个黑客是在调用dlopen()后恢复FP标志。这有助于防止DLLs _DLLInitTerm()在运行时造成类似的破坏。目前还没有提供关闭这些黑客的方法。</target>
        </trans-unit>
        <trans-unit id="9303fbfd8a21fb685b416cbb44c3a447eed84853" translate="yes" xml:space="preserve">
          <source>The other is to install the module in a temporary location.</source>
          <target state="translated">另一种是将模块安装在一个临时的位置。</target>
        </trans-unit>
        <trans-unit id="7370aa653e76af4b47e0ca0cfb340c944499961e" translate="yes" xml:space="preserve">
          <source>The other modification made is that</source>
          <target state="translated">另一个修改是</target>
        </trans-unit>
        <trans-unit id="5eaa26235f36f66db1f5d49d6f66d3b1d7e346a6" translate="yes" xml:space="preserve">
          <source>The other one is &quot;Common&quot;. This consists of mostly punctuation, emoji, and characters used in mathematics and music, the ASCII digits &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt;, and full-width forms of these digits. These characters can appear intermixed in text in many of the world's scripts. These also don't cause a script run to not match. But like other scripts, all digits in a run must come from the same set of 10.</source>
          <target state="translated">另一个是&amp;ldquo;通用&amp;rdquo;。它主要由数学和音乐中使用的标点符号，表情符号和字符， &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;9&lt;/code&gt; 的ASCII数字以及这些数字的全角形式组成。这些字符可以在世界上许多脚本中的文本中混合出现。这些也不会导致脚本运行不匹配。但是，与其他脚本一样，一次运行中的所有数字都必须来自同一组10。</target>
        </trans-unit>
        <trans-unit id="52e0e078ed7f59ceb7388f298d1ea1da0c3bdb08" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt; ) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="translated">使用变量来保存另一个变量的名称的另一个不好的主意是，该问题通常是由于对Perl数据结构缺乏理解，尤其是哈希。通过使用符号引用，您只是在使用包的符号表哈希（例如 &lt;code&gt;%main::&lt;/code&gt; 而不是用户定义的哈希。解决方案是使用您自己的哈希或真实引用。</target>
        </trans-unit>
        <trans-unit id="14e65562914f1eda6c3850757c3e36b8e4c292d5" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt;) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="translated">使用变量来保存另一个变量的名称的另一个不好的主意是，该问题通常是由于对Perl数据结构（尤其是哈希）缺乏理解而引起的。通过使用符号引用，您只是在使用程序包的符号表哈希（例如 &lt;code&gt;%main::&lt;/code&gt; 而不是用户定义的哈希。解决方案是改用您自己的哈希或真实引用。</target>
        </trans-unit>
        <trans-unit id="d23447e512ad32c2037041f02596c75ecf1a5899" translate="yes" xml:space="preserve">
          <source>The other scalar-returning list reduction functions are all specialisations of this generic idea.</source>
          <target state="translated">其他的标量返回列表还原函数都是这种通用思想的特殊化。</target>
        </trans-unit>
        <trans-unit id="5743b7f731fc10e9d1778f5bba7c58560baf6a5c" translate="yes" xml:space="preserve">
          <source>The other structure is pointed to by the &lt;code&gt;regexp&lt;/code&gt; struct's &lt;code&gt;pprivate&lt;/code&gt; and is in addition to &lt;code&gt;intflags&lt;/code&gt; in the same struct considered to be the property of the regex engine which compiled the regular expression;</source>
          <target state="translated">&lt;code&gt;regexp&lt;/code&gt; 结构的 &lt;code&gt;pprivate&lt;/code&gt; 指向其他结构，除了该结构中的intflags之外， &lt;code&gt;intflags&lt;/code&gt; 被认为是编译正则表达式的regex引擎的属性。</target>
        </trans-unit>
        <trans-unit id="5b612d86c256526a7120d0f540436c62b7f8f79b" translate="yes" xml:space="preserve">
          <source>The other synchronization primitives described below can suffer from similar problems.</source>
          <target state="translated">下面描述的其他同步基元也会出现类似的问题。</target>
        </trans-unit>
        <trans-unit id="375bee995645e81f309660da902b757d6a8e656a" translate="yes" xml:space="preserve">
          <source>The other way works too, especially if you are sure that all your data are under the same encoding, or if compatibility with older versions of Perl is desired.</source>
          <target state="translated">另一种方法也可以,特别是当你确定所有的数据都是在相同的编码下,或者希望与旧版本的Perl兼容时。</target>
        </trans-unit>
        <trans-unit id="46a4f63ad2418ff7f127884608b4d5e8c00d7b27" translate="yes" xml:space="preserve">
          <source>The others shouldn't be used in a threaded application.</source>
          <target state="translated">其他的不应该用在螺纹应用中。</target>
        </trans-unit>
        <trans-unit id="a811a8ea9dab8327d772322e2e441ab82ca0e86f" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">打印操作符的输出字段分隔符。如果定义，则在每个print参数之间打印该值。默认值为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdf1adf4fd2953bb9b8993988459b89f053c2344" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">打印操作符的输出字段分隔符。如果定义，则在每个print参数之间打印该值。默认值为 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e6a9347f20222b252ad3782a91c8dbdeaeb1ab5" translate="yes" xml:space="preserve">
          <source>The output file to print to. If the special names &quot;-&quot; or &quot;&amp;gt;&amp;amp;1&quot; or &quot;&amp;gt;&amp;amp;STDOUT&quot; are used then standard output is used. If &quot;&amp;gt;&amp;amp;2&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot; is used then standard error is used.</source>
          <target state="translated">要输出到的输出文件。如果使用特殊名称&amp;ldquo;-&amp;rdquo;或&amp;ldquo;&amp;gt;＆1&amp;rdquo;或&amp;ldquo;&amp;gt;＆STDOUT&amp;rdquo;，则使用标准输出。如果使用&amp;ldquo;&amp;gt;＆2&amp;rdquo;或&amp;ldquo;&amp;gt;＆STDERR&amp;rdquo;，则使用标准错误。</target>
        </trans-unit>
        <trans-unit id="cf7f158841e06623182985de04b67d3455d986ee" translate="yes" xml:space="preserve">
          <source>The output files are placed in the hierarchy rooted at Perl's architecture dependent library directory. You can specify a different hierarchy with a &lt;b&gt;-d&lt;/b&gt; switch.</source>
          <target state="translated">输出文件放置在根于Perl依赖于体系结构的库目录的层次结构中。您可以使用&lt;b&gt;-d&lt;/b&gt;开关指定其他层次结构。</target>
        </trans-unit>
        <trans-unit id="c27fbec04d459297ba3b8649872110c7c0d3d15a" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;&quot;Configurable Options&quot;&lt;/a&gt;.</source>
          <target state="translated">输出格式由&lt;a href=&quot;#Configurable-Options&quot;&gt;&amp;ldquo;可配置选项&amp;rdquo;&lt;/a&gt;下所述的多个选项控制。</target>
        </trans-unit>
        <trans-unit id="5d7376e07f79489cad7f31d1cda9c5ba04d798cb" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;Configurable Options&lt;/a&gt;.</source>
          <target state="translated">输出格式由&amp;ldquo;可&lt;a href=&quot;#Configurable-Options&quot;&gt;配置选项&amp;rdquo;&lt;/a&gt;下所述的多个选项控制。</target>
        </trans-unit>
        <trans-unit id="99376109c851932f74197e279ea101a89b6befe6" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; is within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , not whether the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; is.</source>
          <target state="translated">&lt;a href=&quot;functions/write&quot;&gt;写入&lt;/a&gt;的输出格式由更早的格式声明（&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;）确定，因此输出是否受语言环境的影响取决于 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; 是否在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的范围内，而不取决于 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 是。</target>
        </trans-unit>
        <trans-unit id="c1530099f7317e5e8334f8069b6bb6b27df102d4" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;perlfunc#write&quot;&gt;write()&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;perlfunc#format&quot;&gt;&quot;format&quot; in perlfunc&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;format()&lt;/code&gt; is within the scope of a &lt;code&gt;use locale&lt;/code&gt;, not whether the &lt;code&gt;write()&lt;/code&gt; is.</source>
          <target state="translated">&lt;a href=&quot;perlfunc#write&quot;&gt;write（）&lt;/a&gt;的输出格式由更早的格式声明（&lt;a href=&quot;perlfunc#format&quot;&gt;perlfunc中的&amp;ldquo; format&amp;rdquo;&lt;/a&gt;）确定，因此，输出是否受语言环境的影响取决于 &lt;code&gt;format()&lt;/code&gt; 是否在 &lt;code&gt;use locale&lt;/code&gt; 的范围内，不是 &lt;code&gt;write()&lt;/code&gt; 是否。</target>
        </trans-unit>
        <trans-unit id="821335e2d4cef7b064fd271a1052ad49bb811014" translate="yes" xml:space="preserve">
          <source>The output from an XSUB which uses something like the T_PTRREF map, which doesn't bless the object, might look something like this:</source>
          <target state="translated">使用类似T_PTRREF映射的XSUB的输出,不祝福对象,可能是这样的。</target>
        </trans-unit>
        <trans-unit id="0f57dea9a1d29f634f6f112b3d23937584062d88" translate="yes" xml:space="preserve">
          <source>The output from that will be</source>
          <target state="translated">其输出将是</target>
        </trans-unit>
        <trans-unit id="489ef92ce8f286ef5d6d82e8d178af124ae1bd61" translate="yes" xml:space="preserve">
          <source>The output is untainted. If you don't know what tainting is, don't worry about it.</source>
          <target state="translated">输出是没有污染的。如果你不知道什么是污点,就不要担心。</target>
        </trans-unit>
        <trans-unit id="74b4c8cfc7182db2977001aba6ce4cd0c9c3eff4" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">输出行可以用作 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 调用中的模板：</target>
        </trans-unit>
        <trans-unit id="ff265796f887227add453069160ce81043ae2ad9" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;pack&lt;/code&gt; or &lt;code&gt;unpack&lt;/code&gt; call:</source>
          <target state="translated">输出行可以用作 &lt;code&gt;pack&lt;/code&gt; 或 &lt;code&gt;unpack&lt;/code&gt; 调用中的模板：</target>
        </trans-unit>
        <trans-unit id="628776c99f7feeea9f3047213f9a74832f55bae9" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;uname -a&lt;/code&gt; if available, otherwise the hostname. The whole thing is then lower-cased and slashes and single quotes are removed.</source>
          <target state="translated">&lt;code&gt;uname -a&lt;/code&gt; 的输出（如果可用），否则为主机名。然后将整个内容小写，并删除斜杠和单引号。</target>
        </trans-unit>
        <trans-unit id="b50cc56cf670c43f6be20602b16c39970c70b1a0" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">打印操作员的输出记录分隔符。如果定义，则在打印的最后一个参数之后打印此值。默认值为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bed1b55192d15d86c0d4204e8c0dbb14dedd4354" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">打印操作员的输出记录分隔符。如果已定义，则在打印的最后一个参数之后打印此值。默认值为 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8366e38dbe1255a05a31be8b8ca8cff24bae31ce" translate="yes" xml:space="preserve">
          <source>The output shows all of the groups. The outermost matches show up first and the nested matches show up later:</source>
          <target state="translated">输出显示所有的组。最外层的匹配项先显示,嵌套的匹配项后显示。</target>
        </trans-unit>
        <trans-unit id="61a2ac718a159127bd64e67ec39c4e8e007d9514" translate="yes" xml:space="preserve">
          <source>The output shows that Perl found the two major groups:</source>
          <target state="translated">输出显示,Perl找到了两大组。</target>
        </trans-unit>
        <trans-unit id="eb272330b66e99a860c17d412be21e54b237263f" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt; . Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt; , but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="translated">输出显示，在 &lt;code&gt;OUTER&lt;/code&gt; 块中， &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 的值来自与 &lt;code&gt;$outer&lt;/code&gt; 的匹配。在 &lt;code&gt;INNER&lt;/code&gt; 块内部， &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 的值来自与 &lt;code&gt;$inner&lt;/code&gt; 的匹配，但仅直到块的末尾（即动态范围）为止。后 &lt;code&gt;INNER&lt;/code&gt; 块完成，值 &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 回报为反对这门亲事值 &lt;code&gt;$outer&lt;/code&gt; ，即使我们还没有做出其他比赛：</target>
        </trans-unit>
        <trans-unit id="3aeb115218152011de3493e1c2fea22949664e64" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt;. Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt;, but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="translated">输出显示，在 &lt;code&gt;OUTER&lt;/code&gt; 块中， &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 的值来自与 &lt;code&gt;$outer&lt;/code&gt; 的匹配。在 &lt;code&gt;INNER&lt;/code&gt; 块内部， &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 的值来自与 &lt;code&gt;$inner&lt;/code&gt; 的匹配，但仅直到块结束（即动态范围）为止。后 &lt;code&gt;INNER&lt;/code&gt; 块完成，值 &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 回报为反对这门亲事值 &lt;code&gt;$outer&lt;/code&gt; ，即使我们还没有做出其他比赛：</target>
        </trans-unit>
        <trans-unit id="43b62e463d3539b36d5bc54872fb60071ea829c7" translate="yes" xml:space="preserve">
          <source>The output shows the constant() subroutine we're testing being replaced with the value of the &lt;code&gt;DEBUG&lt;/code&gt; constant: zero. The line to be tested has been completely optimized away, and you can't get much more efficient than that.</source>
          <target state="translated">输出显示我们正在测试的constant（）子例程已被 &lt;code&gt;DEBUG&lt;/code&gt; 常量的值替换为零。要测试的生产线已经完全优化，您将无法获得比这更高的效率。</target>
        </trans-unit>
        <trans-unit id="223632d9e65a77def5c7f3d1e26472458213d8c9" translate="yes" xml:space="preserve">
          <source>The output string will be returned.</source>
          <target state="translated">将返回输出字符串。</target>
        </trans-unit>
        <trans-unit id="5b1aa869d1f21ede1a6455013df56f91d9ec5d9c" translate="yes" xml:space="preserve">
          <source>The output strings for &lt;b&gt;Tputs&lt;/b&gt; are cached for counts of 1 for performance. &lt;b&gt;Tgoto&lt;/b&gt; and &lt;b&gt;Tpad&lt;/b&gt; do not cache. &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; is the raw termcap data and &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; is the cached version.</source>
          <target state="translated">&lt;b&gt;Tputs&lt;/b&gt;的输出字符串缓存为1，以提高性能。&lt;b&gt;Tgoto&lt;/b&gt;和&lt;b&gt;Tpad&lt;/b&gt;不缓存。 &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; 是原始termcap数据， &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; 是缓存的版本。</target>
        </trans-unit>
        <trans-unit id="5e7202107b643ac3d564aacb4d094eef76b947a2" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="translated">输出值及其符号,必须是1,2,...,OBJ2-1范围内的正值,或者是减去OBJ2的相同值。例如,如果输入参数是代表数字7和5的对象,则该方法必须返回一个代表数字3和 &quot;+&quot;号的对象,因为(3*7)% 5=1 % 5,或者返回一个代表数字2和&quot;-&quot;号的对象,因为(-2*7)% 5=1 % 5。</target>
        </trans-unit>
        <trans-unit id="3b69a10a3a50934e50dc62235290b18744d8011f" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and a &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="translated">输出值及其符号,必须是1,2,...,OBJ2-1范围内的正值,或者是减去OBJ2的相同值。例如,如果输入参数是代表数字7和5的对象,则该方法必须返回一个代表数字3的对象和 &quot;+&quot;号,因为(3*7)% 5=1 % 5,或者返回一个代表数字2的对象和&quot;-&quot;号,因为(-2*7)% 5=1 % 5。</target>
        </trans-unit>
        <trans-unit id="1eef73c78f4ba8f7baa5a469f4fff0d89cabb26a" translate="yes" xml:space="preserve">
          <source>The output you'll get when the script is executed:</source>
          <target state="translated">当脚本被执行时,你将得到的输出。</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">的输出。</target>
        </trans-unit>
        <trans-unit id="0dc65b45e14d95f10af2c76613db8f6869035f53" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 与终止时间之间的总时间或挂钟时间。经过的时间包括用户和系统时间，以及等待系统上其他用户和进程所花费的时间。不可避免地，这是给出的最近似的测量值。</target>
        </trans-unit>
        <trans-unit id="9571b6fa38431ae0c0fee13dd1186fe4dbf0046f" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;time&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="translated">调用 &lt;code&gt;time&lt;/code&gt; 与终止时间之间的总时间（即挂钟）。经过的时间包括用户和系统时间，以及等待系统上其他用户和进程所花费的时间。不可避免地，这是给出的最近似的测量值。</target>
        </trans-unit>
        <trans-unit id="5407cf16873f519751b5a5a5e241e60dd7a6b88b" translate="yes" xml:space="preserve">
          <source>The pTHX_ symbol in the definition is a macro used by Perl under threading to provide an extra argument to the routine holding a pointer back to the interpreter that is executing the regexp. So under threading all routines get an extra argument.</source>
          <target state="translated">定义中的pTHX_符号是Perl在线程化下使用的一个宏,用于为例程提供一个额外的参数,该参数持有一个指向正在执行regexp的解释器的指针。所以在线程下,所有的例程都会得到一个额外的参数。</target>
        </trans-unit>
        <trans-unit id="f3fe23968698971d8ab162ac70a7f7b71df42802" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;A*&lt;/code&gt; gobbles up all remaining bytes, and &lt;code&gt;$prio&lt;/code&gt; remains undefined! Before we let disappointment dampen the morale: Perl's got the trump card to make this trick too, just a little further up the sleeve. Watch this:</source>
          <target state="translated">打包代码 &lt;code&gt;A*&lt;/code&gt; 吞噬了所有剩余字节，而 &lt;code&gt;$prio&lt;/code&gt; 仍未定义！在我们失望之前挫败士气：Perl也获得了王牌来做这个技巧，只是袖手旁观。看这个：</target>
        </trans-unit>
        <trans-unit id="7933b3c7848d20de1a22817261c68e6d7c53c8c0" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="translated">添加了打包代码 &lt;code&gt;w&lt;/code&gt; 以支持一种便携式二进制数据编码方案，该方案远远超出了简单的整数。 （有关详细信息，请访问Scarab项目的&lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;。）BER（二进制编码表示）压缩的无符号整数存储基数128位，最高有效位在前，并且位数越少越好。除最后一个字节外，每个字节均设置位八（高位）。 BER编码没有大小限制，但是Perl不会极端。</target>
        </trans-unit>
        <trans-unit id="b79ab5606b336d2e61cfa7238de19673ec485cc8" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&quot;&gt;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="translated">添加了打包代码 &lt;code&gt;w&lt;/code&gt; 以支持可移植的二进制数据编码方案，该方案远远超出了简单的整数。（有关详细信息，&lt;a href=&quot;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&quot;&gt;请&lt;/a&gt;访问Scarab项目，网址为https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt。）BER（二进制编码表示）压缩的无符号整数存储基数128位，最高有效位在前，位数越少越好。除最后一个字节外，每个字节均设置位八（高位）。BER编码没有大小限制，但是Perl不会极端。</target>
        </trans-unit>
        <trans-unit id="1cf9569df81623b7e7940e6c5aeacc511770e43a" translate="yes" xml:space="preserve">
          <source>The pack code for big-endian (high order byte at the lowest address) is &lt;code&gt;n&lt;/code&gt; for 16 bit and &lt;code&gt;N&lt;/code&gt; for 32 bit integers. You use these codes if you know that your data comes from a compliant architecture, but, surprisingly enough, you should also use these pack codes if you exchange binary data, across the network, with some system that you know next to nothing about. The simple reason is that this order has been chosen as the</source>
          <target state="translated">big-endian（最低地址的高位字节）的打包代码对于16位是 &lt;code&gt;n&lt;/code&gt; ，对于32位整数是 &lt;code&gt;N&lt;/code&gt; 。如果您知道数据来自兼容体系结构，则可以使用这些代码，但是，令人惊讶的是，如果您要通过网络与几乎一无所知的系统交换二进制数据，那么也应该使用这些打包代码。原因很简单，该订单已被选择为</target>
        </trans-unit>
        <trans-unit id="57fad0d4b36d335f1fb095e9863848e373754e9c" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 之前的打包代码可以是任何适合表示数字的代码：所有数字二进制打包代码，甚至是文本代码，例如 &lt;code&gt;A4&lt;/code&gt; 或 &lt;code&gt;Z*&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="65094bdd21f0a1919cd6838b37b6c0d3bbee3405" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 之前的打包代码可以是任何适合表示数字的代码：所有数字二进制打包代码，甚至是文本代码，例如 &lt;code&gt;A4&lt;/code&gt; 或 &lt;code&gt;Z*&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7172e02890f0d23e60cb06f72d229c969bc3f33e" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="translated">包装格式 &lt;code&gt;A&lt;/code&gt; 表示&amp;ldquo;任何字符&amp;rdquo;；如果你是 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ING和你的东西用完了收拾， &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 将填补剩下了空间。</target>
        </trans-unit>
        <trans-unit id="44495eb674e0583287f2264fa02ffed62c8c4074" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;pack&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;pack&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="translated">包装格式 &lt;code&gt;A&lt;/code&gt; 表示&amp;ldquo;任何字符&amp;rdquo;；如果你是 &lt;code&gt;pack&lt;/code&gt; ING和你的东西用完了收拾， &lt;code&gt;pack&lt;/code&gt; 将填补剩下了空间。</target>
        </trans-unit>
        <trans-unit id="9582d05d51afa98d043db268f238bb511bec0a17" translate="yes" xml:space="preserve">
          <source>The package contains a session manager and a cache manager. The session manager keeps track of what has been fetched, built, and installed in the current session. The cache manager keeps track of the disk space occupied by the make processes and deletes excess space using a simple FIFO mechanism.</source>
          <target state="translated">该包包含一个会话管理器和一个缓存管理器。会话管理器会跟踪当前会话中已经获取、构建和安装的内容,缓存管理器会跟踪make进程占用的磁盘空间,并使用简单的FIFO机制删除多余的空间。缓存管理器跟踪make进程占用的磁盘空间,并使用简单的FIFO机制删除多余的空间。</target>
        </trans-unit>
        <trans-unit id="f2c3c65c0d45b6b1fe4dfd7fdaf1376fd647a40b" translate="yes" xml:space="preserve">
          <source>The package from which the exceptional subroutine was called.</source>
          <target state="translated">特殊子程序被调用的包。</target>
        </trans-unit>
        <trans-unit id="fdc4d85fb172b2eb58f10fb1bda38f21c477922a" translate="yes" xml:space="preserve">
          <source>The package name argument will typically be the name of the class into which the subroutine was declared, but it may also be the name of a derived class (since handlers are inherited).</source>
          <target state="translated">包名参数通常是子程序被声明成的类的名称,但也可能是派生类的名称(因为处理程序是继承的)。</target>
        </trans-unit>
        <trans-unit id="91efffdbf8c7db0b4f5430206e2d6e6cd3563e8f" translate="yes" xml:space="preserve">
          <source>The package name uses the &lt;code&gt;DBM_Filter::&lt;/code&gt; prefix.</source>
          <target state="translated">程序包名称使用 &lt;code&gt;DBM_Filter::&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="61ad7bd19c49da733338e6250d6950f088f8b981" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt;).</source>
          <target state="translated">表示发行版的软件包。例如， &lt;code&gt;Test::More&lt;/code&gt; 或 &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 。它将用于派生有关分发的信息，例如&lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;，Perl库中的安装位置以及默认情况下将在其中查找XS文件的位置（请参阅&lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cf847620b5ea5a28241ef80f16dce588c1976c67" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;. It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;&quot;DISTNAME&quot;&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;&quot;XS&quot;&lt;/a&gt;).</source>
          <target state="translated">代表发行版的软件包。例如， &lt;code&gt;Test::More&lt;/code&gt; 或 &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 。它将用于派生有关分发的信息，例如&lt;a href=&quot;#DISTNAME&quot;&gt;&amp;ldquo; DISTNAME&amp;rdquo;&lt;/a&gt;，Perl库中的安装位置以及默认情况下将在其中查找XS文件的位置（请参阅&lt;a href=&quot;#XS&quot;&gt;&amp;ldquo; XS&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4576d414ced67927c5747f7cd9e683dea9105380" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;
qr//&lt;/code&gt; ). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="translated">qr //魔术对象的软件包被祝福（如 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; qr//&lt;/code&gt; ）。建议引擎将其更改为其程序包名称以进行标识，无论它们是否在对象上实现方法。</target>
        </trans-unit>
        <trans-unit id="3eb8be4161caf31aed9851aac09981f2dc091cb7" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;ref qr//&lt;/code&gt;). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="translated">qr //魔术对象包被祝福（如 &lt;code&gt;ref qr//&lt;/code&gt; ）。建议引擎将其更改为其程序包名称以进行标识，无论它们是否在对象上实现方法。</target>
        </trans-unit>
        <trans-unit id="73079d10e9cd577552c5b87cfb22afa1b7851691" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="translated">此方法返回的包的 &lt;code&gt;@ISA&lt;/code&gt; 中还应该具有内部 &lt;code&gt;Regexp&lt;/code&gt; 包。无论使用什么引擎， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; 都应始终为true。</target>
        </trans-unit>
        <trans-unit id="890f0468ce1dfbaa3a848480f6a3e9f003f8a19f" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt;. &lt;code&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="translated">此方法返回的包还应在其 &lt;code&gt;@ISA&lt;/code&gt; 中具有内部 &lt;code&gt;Regexp&lt;/code&gt; 包。无论使用什么引擎， &lt;code&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/code&gt; 都应始终为true。</target>
        </trans-unit>
        <trans-unit id="7b32ac926fcc794f5f7982e502e4686af4c595bf" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt; , on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="translated">当调用者简单地说 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; Net :: Acme时，包变量 &lt;code&gt;@EXPORT&lt;/code&gt; 将确定将导出哪些符号-您几乎不需要在其中放置任何内容。另一方面，@ &lt;code&gt;@EXPORT_OK&lt;/code&gt; 指定您要导出的符号。如果确实要导出一堆符号，请使用 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 并定义一个标准导出集- 有关更多详细信息，请参见&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d8ef2409327fe0b3b34e7e40584004dedfbd9fc" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;use Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt;, on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="translated">当调用者简单地说 &lt;code&gt;use Net::Acme&lt;/code&gt; 时，包变量 &lt;code&gt;@EXPORT&lt;/code&gt; 将确定将导出哪些符号-您几乎不需要在其中放置任何内容。另一方面，@ &lt;code&gt;@EXPORT_OK&lt;/code&gt; 指定您要导出的符号。如果确实要导出一堆符号，请使用 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 并定义一个标准导出集-有关更多详细信息，请参见&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="650111e5202c538679780ce9ea893a905f97b0fc" translate="yes" xml:space="preserve">
          <source>The packages relating to various DBM-related implementations (</source>
          <target state="translated">与各种DBM相关的实施方案相关的包()。</target>
        </trans-unit>
        <trans-unit id="02ef2277604c9b31476ae26defa7602571798335" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The &lt;code&gt;COP_SEQ_RANGE_LOW&lt;/code&gt; and &lt;code&gt;_HIGH&lt;/code&gt; fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="translated">PADNAMELIST中的填充名称具有保存变量名称的PV。的 &lt;code&gt;COP_SEQ_RANGE_LOW&lt;/code&gt; 和 &lt;code&gt;_HIGH&lt;/code&gt; 字段形成cop_seq数的量，名称是有效的范围（低+ 1..high含）。在编译期间，这些字段可以保存特殊值PERL_PADSEQ_INTRO以指示各个阶段：</target>
        </trans-unit>
        <trans-unit id="c94813a5310ff08ec4ccbc37cd40783e0084e83e" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The COP_SEQ_RANGE_LOW and _HIGH fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="translated">PADNAMELIST中的焊盘名称有其PV,持有变量的名称。COP_SEQ_RANGE_LOW和_HIGH字段形成了一个cop_seq数字的范围(low+1...high包括在内),这个名字是有效的。在编译过程中,这些字段可以持有特殊值PERL_PADSEQ_INTRO来表示不同的阶段。</target>
        </trans-unit>
        <trans-unit id="ad69ddb72e9f5b5565c26efc4eeac2130e2ed028" translate="yes" xml:space="preserve">
          <source>The padded $string is returned.</source>
          <target state="translated">返回填充的$string。</target>
        </trans-unit>
        <trans-unit id="d3a360c727f09061a32c58fb443bedffc200fc64" translate="yes" xml:space="preserve">
          <source>The paper &quot;How to Break MD5 and Other Hash Functions&quot; by Xiaoyun Wang and Hongbo Yu.</source>
          <target state="translated">王晓云、于洪波的论文《如何破解MD5等哈希函数》。</target>
        </trans-unit>
        <trans-unit id="9446a617fdf40553874ee589e7fc235690a0bb87" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="translated">您提供给&lt;a href=&quot;Text::Wrap&quot;&gt;Text :: Wrap&lt;/a&gt;的段落不应包含嵌入的换行符。&lt;a href=&quot;Text::Wrap&quot;&gt;Text :: Wrap&lt;/a&gt;无法对齐行（右对齐）。</target>
        </trans-unit>
        <trans-unit id="6bcc7e86c6ab48d9801f437d7ce277bb0ef436bb" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="translated">您提供给&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt;的段落不应包含嵌入式换行符。&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt;无法对齐行（右对齐）。</target>
        </trans-unit>
        <trans-unit id="0d3c20158693e8f7ad6ce14151f5e71a493b3128" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">参数 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 用于控制压缩数据的目的地。该参数可以采用以下形式之一。</target>
        </trans-unit>
        <trans-unit id="2a2ee58982c19a9868c4499e7bd1b9d1531f2904" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the uncompressed data. This parameter can take one of these forms.</source>
          <target state="translated">参数 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 用于控制未压缩数据的目的地。该参数可以采用以下形式之一。</target>
        </trans-unit>
        <trans-unit id="4380851c25da81befd83447bad55f6f9f369b966" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$text&lt;/code&gt; is a string or block of text to be parsed for interior sequences; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number corresponding to the beginning of &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">参数 &lt;code&gt;$text&lt;/code&gt; 是要为内部序列解析的字符串或文本块；参数 &lt;code&gt;$line_num&lt;/code&gt; 是与 &lt;code&gt;$text&lt;/code&gt; 开头相对应的行号。</target>
        </trans-unit>
        <trans-unit id="175733e4967510eadb5d4ab18e962461101eaed6" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;extra_libs&lt;/code&gt; can be used to specify &lt;b&gt;additional&lt;/b&gt; paths to search for installed modules. For instance</source>
          <target state="translated">参数 &lt;code&gt;extra_libs&lt;/code&gt; 可用于指定&lt;b&gt;其他&lt;/b&gt;路径以搜索已安装的模块。例如</target>
        </trans-unit>
        <trans-unit id="76679b1c7056137b35154fa4603dcc56a2e17eed" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;type&lt;/code&gt; is an enumeration which specifies which of the 3 interface methods (DB_HASH, DB_BTREE or DB_RECNO) is to be used. Depending on which of these is actually chosen, the final parameter,</source>
          <target state="translated">参数 &lt;code&gt;type&lt;/code&gt; 是一个枚举，它指定要使用三种接口方法（DB_HASH，DB_BTREE或DB_RECNO）中的哪一种。根据实际选择的参数，最终参数</target>
        </trans-unit>
        <trans-unit id="6df79d8edafef2b8d47fc8b433ceb1dac071556d" translate="yes" xml:space="preserve">
          <source>The parameter list to my() may be assigned to if desired, which allows you to initialize your variables. (If no initializer is given for a particular variable, it is created with the undefined value.) Commonly this is used to name input parameters to a subroutine. Examples:</source>
          <target state="translated">如果需要的话,可以将参数列表分配给my(),这样可以让你初始化你的变量。(如果没有为某个变量提供初始化器,则会以未定义的值创建。)通常这用来命名子程序的输入参数。例子。</target>
        </trans-unit>
        <trans-unit id="42306ba107d404a6932eda2f03148007a2382a8a" translate="yes" xml:space="preserve">
          <source>The parameter's default value will still be evaluated if the corresponding argument isn't supplied, even though the value won't be stored anywhere. This is in case evaluating it has important side effects. However, it will be evaluated in void context, so if it doesn't have side effects and is not trivial it will generate a warning if the &quot;void&quot; warning category is enabled. If a nameless optional parameter's default value is not important, it may be omitted just as the parameter's name was:</source>
          <target state="translated">如果没有提供相应的参数,参数的默认值仍然会被评估,即使该值不会被存储在任何地方。这是在评估它有重要副作用的情况下。然而,它将在void上下文中被评估,所以如果它没有副作用,而且不是琐碎的,如果启用了 &quot;void &quot;警告类别,它将产生一个警告。如果一个无名可选参数的默认值并不重要,那么它可以像参数的名称一样被省略。</target>
        </trans-unit>
        <trans-unit id="59f23da7798f0b234972a256a92c78bcfb8c2aa3" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the compressed data.</source>
          <target state="translated">参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 用来定义压缩数据的源。</target>
        </trans-unit>
        <trans-unit id="ed835ab2fa9d34eac4fd3a603940891a0a5eef62" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the uncompressed data.</source>
          <target state="translated">参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 用来定义未压缩数据的源。</target>
        </trans-unit>
        <trans-unit id="4cb5c66abe58beef181f4c5d5c5b7b8d0a8b5206" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt;, is used to define the source of the compressed data.</source>
          <target state="translated">参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 用来定义压缩数据的源。</target>
        </trans-unit>
        <trans-unit id="c7a676729b0be9ab28de0e8dc42a59d230912658" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt;, is used to define the source of the uncompressed data.</source>
          <target state="translated">参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 用来定义未压缩数据的源。</target>
        </trans-unit>
        <trans-unit id="2e0cab04bcd8cbbda8dd4d2c9ce2cf18535f80ac" translate="yes" xml:space="preserve">
          <source>The parameters it accepts are:</source>
          <target state="translated">它接受的参数有:</target>
        </trans-unit>
        <trans-unit id="a830abc7b9d4b876164e2805f5f239e46c825485" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; 的参数添加到perl搜索路径的开头。说</target>
        </trans-unit>
        <trans-unit id="735cc433a3b6580bd3067e26aea227e52cc434e6" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;use lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="translated">将 &lt;code&gt;use lib&lt;/code&gt; 的参数添加到perl搜索路径的开头。说</target>
        </trans-unit>
        <trans-unit id="ea253e51dc3b40387e985b7980c9898cef5a3467" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="translated">关于括号 &lt;code&gt;XSLoader::load()&lt;/code&gt; ，因为我们更换需要的参数 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ，所以编译器不知道的功能 &lt;code&gt;XSLoader::load()&lt;/code&gt; 是存在的。</target>
        </trans-unit>
        <trans-unit id="0d68003766a6505369e854c0eee6d10a747bd253" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;use XSLoader&lt;/code&gt; by &lt;code&gt;require&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="translated">由于我们将 &lt;code&gt;use XSLoader&lt;/code&gt; 替换为 &lt;code&gt;require&lt;/code&gt; ，因此需要使用 &lt;code&gt;XSLoader::load()&lt;/code&gt; 参数的括号，因此编译器不知道存在函数 &lt;code&gt;XSLoader::load()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f992098d3a5a843dac6b8ae9c7b69d4a2fac46e8" translate="yes" xml:space="preserve">
          <source>The parse proceeds pretty much exactly as it does during the construction phase, except that most routines are short-circuited to change the size field &lt;code&gt;RExC_size&lt;/code&gt; and not do anything else.</source>
          <target state="translated">解析的进行过程几乎与构造阶段完全相同，只是大多数例程被短路以更改大小字段 &lt;code&gt;RExC_size&lt;/code&gt; 且不执行其他任何操作。</target>
        </trans-unit>
        <trans-unit id="ce842c5dcf2b13fb8c9e8394fe72be9c8b2663ca" translate="yes" xml:space="preserve">
          <source>The parser is heavily inspired from the one in &lt;a href=&quot;ExtUtils::ParseXS&quot;&gt;ExtUtils::ParseXS&lt;/a&gt;.</source>
          <target state="translated">该解析器的灵感来自&lt;a href=&quot;ExtUtils::ParseXS&quot;&gt;ExtUtils :: ParseXS中的解析器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="93ac900e49339cc6ef6dea21ed4478644c93af89" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt; , and that and its associated routines can be found in</source>
          <target state="translated">语法分析器得到了词法分析器的大力支持，该词法分析器将您的输入分块成令牌，并确定每个令牌是什么类型的东西：变量名，运算符，空字，子例程，核心函数，等等。词法分析器的主要入口点是 &lt;code&gt;yylex&lt;/code&gt; ，它及其相关的例程可以在下面找到。</target>
        </trans-unit>
        <trans-unit id="22cd9c89b1bd366e42455f5006c44969bcb5bdee" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt;, and that and its associated routines can be found in</source>
          <target state="translated">语法分析器得到了词法分析器的辅助，词法分析器将您的输入分块成令牌，并确定每个令牌是什么类型的东西：变量名，运算符，空字，子例程，核心函数，等等。词法分析器的主要入口点是 &lt;code&gt;yylex&lt;/code&gt; ，它及其相关的例程可以在下面找到。</target>
        </trans-unit>
        <trans-unit id="c291c44225b529aa63eb30ed6a4d6cbe06294dcd" translate="yes" xml:space="preserve">
          <source>The parser then sees the following code:</source>
          <target state="translated">然后,解析器会看到以下代码。</target>
        </trans-unit>
        <trans-unit id="d30f0f58beb42ee5cf5d76db1412cac91e934bb2" translate="yes" xml:space="preserve">
          <source>The part of an Email address which follows the @ is not necessarily a hostname, it is a mail domain. To find the name of a host to connect for a mail domain you need to do a DNS MX lookup</source>
          <target state="translated">Email地址中@后面的部分不一定是主机名,而是一个邮件域。要找到一个主机名来连接一个邮件域,你需要进行DNS MX查询</target>
        </trans-unit>
        <trans-unit id="09f50fcb4a70f717d3ac7b5f391fbd97a01ce899" translate="yes" xml:space="preserve">
          <source>The part of the address of a TCP or UDP socket that directs packets to the correct process after finding the right machine, something like the phone extension you give when you reach the company operator. Also the result of converting code to run on a different platform than originally intended, or the verb denoting this conversion.</source>
          <target state="translated">TCP或UDP套接字的地址部分,在找到正确的机器后,将数据包引导到正确的进程,就像你联系公司接线员时给出的电话分机一样。也是指将代码转换为在不同的平台上运行的结果,或表示这种转换的动词。</target>
        </trans-unit>
        <trans-unit id="ae986ba9c61f4a263f7b3033ed66b7a9c47ca2ea" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use does not support the specified signal being used in a &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; call.</source>
          <target state="translated">您尝试使用的特定Perl副本不支持在 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 调用中使用的指定信号。</target>
        </trans-unit>
        <trans-unit id="24e4beb9cede37117dbc38642ef9d4cdf73ef0f4" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use was not built using the &lt;code&gt;useithreads&lt;/code&gt; configuration option.</source>
          <target state="translated">您要使用的Perl特定副本不是使用 &lt;code&gt;useithreads&lt;/code&gt; 配置选项构建的。</target>
        </trans-unit>
        <trans-unit id="e133c3129f1a418b83b69fbe9affe042d494a52e" translate="yes" xml:space="preserve">
          <source>The particular macro you must use depends on which &lt;code&gt;sv_set*v&lt;/code&gt; routine you called first. This is because every &lt;code&gt;sv_set*v&lt;/code&gt; routine turns on only the bit for the particular type of data being set, and turns off all the rest.</source>
          <target state="translated">您必须使用的特定宏取决于您首先调用的 &lt;code&gt;sv_set*v&lt;/code&gt; 例程。这是因为每个 &lt;code&gt;sv_set*v&lt;/code&gt; 例程仅打开所设置的特定数据类型的位，而关闭其余所有位。</target>
        </trans-unit>
        <trans-unit id="9a1356c02587b997ee27ddf50eebcf831988fbcb" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&quot;prop_aliases()&quot;&lt;/a&gt;.</source>
          <target state="translated">可以将传递的属性指定为&lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&amp;ldquo; prop_aliases（）&amp;rdquo;&lt;/a&gt;返回的任何同义词。</target>
        </trans-unit>
        <trans-unit id="1c24d584fffb94c2e195393379212bd0e772bba9" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt;.</source>
          <target state="translated">可以将传递的属性指定为&lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases（）&lt;/a&gt;返回的任何同义词。</target>
        </trans-unit>
        <trans-unit id="515ad1971581ebeed29e0dfbff2e2ca6f9f34b5c" translate="yes" xml:space="preserve">
          <source>The patchlevel level of this package. The value of patchlevel comes from the</source>
          <target state="translated">这个软件包的补丁级别。补丁级别的值来自于</target>
        </trans-unit>
        <trans-unit id="6c9c1991e5426882e512831205056ad8d0cb53e5" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt; . By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt; . However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt; .</source>
          <target state="translated">Perl通过 &lt;code&gt;@INC&lt;/code&gt; 的路径。默认情况下，这是双重深度优先搜索，一次查找定义的方法，一次查找 &lt;code&gt;AUTOLOAD&lt;/code&gt; 。但是，Perl允许您使用 &lt;code&gt;mro&lt;/code&gt; 进行配置。</target>
        </trans-unit>
        <trans-unit id="bfd87cb3c63ce818c0482394b6803650584202ed" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt;. By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt;. However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt;.</source>
          <target state="translated">Perl通过 &lt;code&gt;@INC&lt;/code&gt; 的路径。默认情况下，这是两次深度优先搜索，一次查找定义的方法，一次查找 &lt;code&gt;AUTOLOAD&lt;/code&gt; 。但是，Perl允许您使用 &lt;code&gt;mro&lt;/code&gt; 进行配置。</target>
        </trans-unit>
        <trans-unit id="97b7ffc6783961615c324915aaa3803b45441d58" translate="yes" xml:space="preserve">
          <source>The path from the uri, will be at least a single '/'.</source>
          <target state="translated">从uri的路径,将至少是一个'/'。</target>
        </trans-unit>
        <trans-unit id="935a26d686af6b04ea7fea8358669d0caebc7249" translate="yes" xml:space="preserve">
          <source>The path of the file from which the history (assuming a usable Term::ReadLine backend) will be read on the debugger's startup, and to which it will be saved on shutdown (for persistence across sessions). Similar in concept to Bash's &lt;code&gt;.bash_history&lt;/code&gt; file.</source>
          <target state="translated">历史记录（假设可用的Term :: ReadLine后端）将在调试器启动时从中读取，并且在关机时将其保存到该文件的路径（以确保跨会话的持久性）。在概念上与Bash的 &lt;code&gt;.bash_history&lt;/code&gt; 文件类似。</target>
        </trans-unit>
        <trans-unit id="b7867a311910479846a23412feb4307a4674c491" translate="yes" xml:space="preserve">
          <source>The path to the &lt;code&gt;git&lt;/code&gt; binary to use for the Git features. The default is &lt;code&gt;/usr/local/bin/git&lt;/code&gt;.</source>
          <target state="translated">用于Git功能的 &lt;code&gt;git&lt;/code&gt; 二进制文件的路径。默认值为 &lt;code&gt;/usr/local/bin/git&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f73d1d0634237caab821e6e9c8fad9914a18a73" translate="yes" xml:space="preserve">
          <source>The path to the file is automatically converted to a Unix like equivalent for use in the archive, and, if on MacOS, the file's modification time is converted from the MacOS epoch to the Unix epoch. So tar archives created on MacOS with &lt;b&gt;Archive::Tar&lt;/b&gt; can be read both with</source>
          <target state="translated">文件的路径会自动转换为Unix之类的文件，以供存档使用；如果在MacOS上，则文件的修改时间将从MacOS时代转换为Unix时代。因此，在MacOS上使用&lt;b&gt;Archive :: Tar&lt;/b&gt;创建的tar存档可以通过</target>
        </trans-unit>
        <trans-unit id="2ab24d7b050cb5882eec74eec0cbc6ea2a2768dd" translate="yes" xml:space="preserve">
          <source>The pathname of a POD file to syntax-check (defaults to standard input).</source>
          <target state="translated">要进行语法检查的POD文件的路径名(默认为标准输入)。</target>
        </trans-unit>
        <trans-unit id="3091661abc10e8b933048a63287800c8286b8cec" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing pod documentation to be output in usage message format (defaults to standard input).</source>
          <target state="translated">包含要以使用信息格式输出的 pod 文档的文件路径名(默认为标准输入)。</target>
        </trans-unit>
        <trans-unit id="5506a685c5fca482706d4108f11645e50bb17fd9" translate="yes" xml:space="preserve">
          <source>The pathname of a file from which to select sections of pod documentation (defaults to standard input).</source>
          <target state="translated">文件的路径名,用于选择 pod 文档的部分(默认为标准输入)。</target>
        </trans-unit>
        <trans-unit id="64067e36292a9c79bf92f0c4d392216daafe926d" translate="yes" xml:space="preserve">
          <source>The pattern begins with a class matching a subset of letters. Whenever this matches, a statement like &lt;code&gt;$count{'a'}++;&lt;/code&gt; is executed, incrementing the letter's counter. Then &lt;code&gt;(*FAIL)&lt;/code&gt; does what it says, and the regexp engine proceeds according to the book: as long as the end of the string hasn't been reached, the position is advanced before looking for another vowel. Thus, match or no match makes no difference, and the regexp engine proceeds until the entire string has been inspected. (It's remarkable that an alternative solution using something like</source>
          <target state="translated">模式以匹配字母子集的类开头。只要匹配，就使用 &lt;code&gt;$count{'a'}++;&lt;/code&gt; 类的语句；被执行，增加字母的计数器。然后 &lt;code&gt;(*FAIL)&lt;/code&gt; 进行说明，然后正则表达式引擎根据该书继续进行：只要未到达字符串的末尾，在寻找另一个元音之前，该位置将前进。因此，匹配或不匹配没有区别，并且正则表达式引擎继续进行直到检查了整个字符串。 （值得注意的是，替代解决方案使用类似</target>
        </trans-unit>
        <trans-unit id="a027102deb051cbffb2428b7b7a47e74a500b189" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;a href=&quot;#defined-EXPR&quot;&gt;&lt;code&gt;defined&lt;/code&gt;&lt;/a&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">模式匹配成功并且 &lt;code&gt;$1&lt;/code&gt; 被定义，尽管它匹配&amp;ldquo; nothing&amp;rdquo;。它确实没有匹配任何东西。相反，它匹配的东西恰好是零个字符。这一切都是非常坦率和诚实的。当一个函数返回一个未定义的值时，就表示它不能给您一个诚实的答案。因此，仅在质疑您要执行的操作的完整性时，才应使用&lt;a href=&quot;#defined-EXPR&quot;&gt; &lt;code&gt;defined&lt;/code&gt; &lt;/a&gt;。在其他时候，您想要的是与 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;&quot;&quot;&lt;/code&gt; 的简单比较。</target>
        </trans-unit>
        <trans-unit id="194b10f85ac928e670426276285fc77367b6bf3e" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">模式匹配成功并且 &lt;code&gt;$1&lt;/code&gt; 被定义，尽管它匹配&amp;ldquo; nothing&amp;rdquo;。它确实没有匹配任何东西。相反，它匹配的东西恰好是零个字符。这一切都是坦率和诚实的。当一个函数返回一个未定义的值时，就表示它不能给您一个诚实的答案。因此，仅在质疑您要执行的操作的完整性时，才应使用 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 。在其他时候，您想要的是与 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;&quot;&quot;&lt;/code&gt; 的简单比较。</target>
        </trans-unit>
        <trans-unit id="6ccde9606e998bb56b83482fdb0ce2d1cd2b87e5" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">模式匹配成功并且 &lt;code&gt;$1&lt;/code&gt; 被定义，尽管它匹配&amp;ldquo; nothing&amp;rdquo;。它确实没有匹配任何东西。相反，它匹配的东西恰好是零个字符。这一切都是坦率和诚实的。当一个函数返回一个未定义的值时，就表示它不能给您一个诚实的答案。因此，仅在质疑您要执行的操作的完整性时，才应使用 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 。在其他时候，您想要的是与 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;&quot;&quot;&lt;/code&gt; 的简单比较。</target>
        </trans-unit>
        <trans-unit id="00e74cbb0f8570bc720cdf9f1dc73c5533c198b5" translate="yes" xml:space="preserve">
          <source>The pattern matching metacharacters &quot;(&quot;, &quot;)&quot;, and &quot;|&quot; do not have backslashes in front.</source>
          <target state="translated">模式匹配的元字符&quot;(&quot;、&quot;)&quot;和&quot;|&quot;前面没有反斜杠。</target>
        </trans-unit>
        <trans-unit id="8647f015f186197cabe9c1508a8d5b1dddf875e9" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="translated">在不使用 &lt;code&gt;=~&lt;/code&gt; 运算符的情况下使用模式匹配操作 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; （aka &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="86784bd21e39089878c5197cae9b26fe435b4866" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt; and &lt;code&gt;tr///&lt;/code&gt; (aka &lt;code&gt;y///&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="translated">在不使用 &lt;code&gt;=~&lt;/code&gt; 运算符的情况下使用模式匹配操作 &lt;code&gt;m//&lt;/code&gt; ， &lt;code&gt;s///&lt;/code&gt; 和 &lt;code&gt;tr///&lt;/code&gt; （aka &lt;code&gt;y///&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="216352b3a9f025091614aa329a166fdb30a18a8e" translate="yes" xml:space="preserve">
          <source>The pattern modifiers:</source>
          <target state="translated">模式修改器。</target>
        </trans-unit>
        <trans-unit id="a2c1a780666383b49402abd005e8fafffcab62b8" translate="yes" xml:space="preserve">
          <source>The pattern of macro calls is like this:</source>
          <target state="translated">宏调用的模式是这样的。</target>
        </trans-unit>
        <trans-unit id="3569af6a782c9884f9c5e89ba969f12fe42cf2da" translate="yes" xml:space="preserve">
          <source>The pattern really,</source>
          <target state="translated">这个模式真的。</target>
        </trans-unit>
        <trans-unit id="f373f7a0e4daf869b86fcbb5c4b5b4f2ee465c22" translate="yes" xml:space="preserve">
          <source>The pattern will be used as a Perl regular expression (as opposed to a simple grep regex).</source>
          <target state="translated">这个模式将被用作Perl的正则表达式(相对于简单的grep regex)。</target>
        </trans-unit>
        <trans-unit id="8a46001019582eae5c4e5728c4a3fb31cd3dbf38" translate="yes" xml:space="preserve">
          <source>The patterns used in Perl pattern matching evolved from those supplied in the Version 8 regex routines. (The routines are derived (distantly) from Henry Spencer's freely redistributable reimplementation of the V8 routines.) See &lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;Version 8 Regular Expressions&lt;/a&gt; for details.</source>
          <target state="translated">Perl模式匹配中使用的模式是从版本8 regex例程中提供的模式演变而来的。（这些例程（从（远处）派生自Henry Spencer的V8例程的可自由重新分配的重新实现。）有关详细信息，请参见&lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;版本8正则表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e790c64d043de1336b86cfb89ee718b54cb057cd" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;&quot;Compile pass 3: peephole optimization&quot; in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;&quot;PL_rpeepp&quot;&lt;/a&gt; hook.</source>
          <target state="translated">窥孔优化器绝对不能完全更换。而是通过包装现有的优化器向其添加代码。可以&lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;在perlguts的&amp;ldquo;编译通道3：窥孔优化&amp;rdquo;中&lt;/a&gt;看到执行此操作的基本方法。如果新代码希望在整个子例程的结构上而不是仅在顶层上对ops进行操作，则包装&lt;a href=&quot;#PL_rpeepp&quot;&gt;&amp;ldquo; PL_rpeepp&amp;rdquo;&lt;/a&gt;钩子可能会更方便。</target>
        </trans-unit>
        <trans-unit id="8569c5379da2f4cde343faebf02e081c76fc9c06" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;&quot;Compile pass 3: peephole optimization&quot; in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;&quot;PL_peepp&quot;&lt;/a&gt; hook.</source>
          <target state="translated">窥孔优化器绝对不能完全更换。而是通过包装现有的优化器向其添加代码。可以&lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;在perlguts的&amp;ldquo;编译通道3：窥孔优化&amp;rdquo;中&lt;/a&gt;看到执行此操作的基本方法。如果新代码只希望在子例程的顶层操作而不是在整个结构中操作，则包装&lt;a href=&quot;#PL_peepp&quot;&gt;&amp;ldquo; PL_peepp&amp;rdquo;&lt;/a&gt;钩子可能会更方便。</target>
        </trans-unit>
        <trans-unit id="dac0ad9b1d3df00129661ed1e95ffc2c13f0c968" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt; hook.</source>
          <target state="translated">窥孔优化器绝对不能完全更换。而是通过包装现有的优化器向其添加代码。在&lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3：perlguts中的窥孔优化中&lt;/a&gt;可以看到执行此操作的基本方法。如果新代码希望在整个子例程的结构上而不是仅在顶层上对ops进行操作，则包装&lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt;钩子可能会更方便。</target>
        </trans-unit>
        <trans-unit id="db43041726026c591925cfc25e5688f00dc4bbac" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt; hook.</source>
          <target state="translated">窥孔优化器绝对不能完全更换。而是通过包装现有的优化器向其添加代码。在&lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3：perlguts中的窥孔优化中&lt;/a&gt;可以看到执行此操作的基本方法。如果新代码只希望在子例程的顶层操作而不是在整个结构中操作，则包装&lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt;钩子可能会更方便。</target>
        </trans-unit>
        <trans-unit id="ace3f1e6483238aa81eb601036e5dcd7d2b38b3a" translate="yes" xml:space="preserve">
          <source>The per-instance data are held in memory beyond the basic PerlIOl struct, by making a PerlIOl the first member of the layer's struct thus:</source>
          <target state="translated">每个实例的数据被保存在基本的PerlIOl结构之外的内存中,通过使PerlIOl成为层结构的第一个成员,这样。</target>
        </trans-unit>
        <trans-unit id="467fb902a44226db21d27e75dc641b031d86cd72" translate="yes" xml:space="preserve">
          <source>The per-instance data for a particular handle.</source>
          <target state="translated">特定手柄的每个实例数据。</target>
        </trans-unit>
        <trans-unit id="85e58f1f52dd9a0e84852e44b90f48bbed040fce" translate="yes" xml:space="preserve">
          <source>The per-record overhead will limit the maximum number of records you can access per file. Note that</source>
          <target state="translated">每条记录的开销将限制你在每个文件中可以访问的最大记录数。请注意</target>
        </trans-unit>
        <trans-unit id="874d7f7aa12fc5ea3bd61b16d41289fe642a630c" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot;</source>
          <target state="translated">除了&quot;...&quot;之外,句号&quot;...&quot;与任何字符相匹配。</target>
        </trans-unit>
        <trans-unit id="e038fd297e6c1d463ecc98d5fcaacd0e4180bccd" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot; (unless the modifier &lt;code&gt;//s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="translated">时期 '。' 匹配除&amp;ldquo; \ n&amp;rdquo;以外的任何字符（除非修饰符 &lt;code&gt;//s&lt;/code&gt; 有效，如下所述）。</target>
        </trans-unit>
        <trans-unit id="bc11993ee6fae379fe2dbc40f494f74a38651177" translate="yes" xml:space="preserve">
          <source>The period &lt;code&gt;'.'&lt;/code&gt; matches any character but &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (unless the modifier &lt;code&gt;/s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="translated">句号 &lt;code&gt;'.'&lt;/code&gt; 匹配除 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 任何字符（除非修饰符 &lt;code&gt;/s&lt;/code&gt; 有效，如下所述）。</target>
        </trans-unit>
        <trans-unit id="50625043a5bdab5548c251e25233bc0e03a34159" translate="yes" xml:space="preserve">
          <source>The perl code in PerlIO.pm then attempts to locate a layer by doing</source>
          <target state="translated">然后,PerlIO.pm中的perl代码试图通过以下操作来定位一个层</target>
        </trans-unit>
        <trans-unit id="634e60cc8e248b9b7ce51ac444bfec05dc82ef31" translate="yes" xml:space="preserve">
          <source>The perl command to use is determined by &lt;a href=&quot;#get_perl&quot;&gt;&quot;get_perl&quot;&lt;/a&gt;. The command generated is guaranteed to preserve:</source>
          <target state="translated">要使用的perl命令由&lt;a href=&quot;#get_perl&quot;&gt;&amp;ldquo; get_perl&amp;rdquo;&lt;/a&gt;确定。确保生成的命令可以保留：</target>
        </trans-unit>
        <trans-unit id="16b7e5af7739f86fd0e9e79d11ca97ac5649e9b1" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt; . The basic rule of perl exceptions is that &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (in the absence of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; , while &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; .</source>
          <target state="translated">perl核心将 &lt;code&gt;setjmp()&lt;/code&gt; 等包装在宏 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 和 &lt;code&gt;JMPENV_JUMP&lt;/code&gt; 中。perl的异常的基本规则是， &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; ，和 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; （在不存在的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ）执行 &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; ，而 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 内 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 做了 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6c71858536e734e97d2970ba2f758d971d8a580" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt;. The basic rule of perl exceptions is that &lt;code&gt;exit&lt;/code&gt;, and &lt;code&gt;die&lt;/code&gt; (in the absence of &lt;code&gt;eval&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt;, while &lt;code&gt;die&lt;/code&gt; within &lt;code&gt;eval&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt;.</source>
          <target state="translated">perl核心将 &lt;code&gt;setjmp()&lt;/code&gt; 等包装在宏 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 和 &lt;code&gt;JMPENV_JUMP&lt;/code&gt; 中。perl的异常的基本规则是， &lt;code&gt;exit&lt;/code&gt; ，和 &lt;code&gt;die&lt;/code&gt; （在不存在的 &lt;code&gt;eval&lt;/code&gt; ）执行 &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; ，而 &lt;code&gt;die&lt;/code&gt; 内 &lt;code&gt;eval&lt;/code&gt; 做了 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fdbc7e5dc74277662b153d8f95c93e631321b8b" translate="yes" xml:space="preserve">
          <source>The perl equivalent is &lt;code&gt;$sv = undef;&lt;/code&gt;. Note that it doesn't free any string buffer, unlike &lt;code&gt;undef $sv&lt;/code&gt;.</source>
          <target state="translated">Perl等效为 &lt;code&gt;$sv = undef;&lt;/code&gt; 。请注意，它不释放任何字符串缓冲区，这与 &lt;code&gt;undef $sv&lt;/code&gt; 不同。</target>
        </trans-unit>
        <trans-unit id="6c474186075797ee40452934f04a51f573b827bb" translate="yes" xml:space="preserve">
          <source>The perl executable is obtained by linking</source>
          <target state="translated">perl可执行文件可以通过链接到</target>
        </trans-unit>
        <trans-unit id="1d8ff0cddfb59dc7ae9ad6feb4a5e65da142f6d6" translate="yes" xml:space="preserve">
          <source>The perl history contains one mistake which was not caught in the conversion: a merge was recorded in the history between blead and maint-5.10 where no merge actually occurred. Due to the nature of git, this is now impossible to fix in the public repository. You can remove this mis-merge locally by adding the following line to your &lt;code&gt;.git/info/grafts&lt;/code&gt; file:</source>
          <target state="translated">Perl的历史记录包含一个转换中未发现的错误：在blead和maint-5.10之间的历史记录中记录了合并，但实际上没有发生合并。由于git的性质，现在无法在公共存储库中解决此问题。您可以通过在 &lt;code&gt;.git/info/grafts&lt;/code&gt; 文件中添加以下行来在本地消除这种错误合并：</target>
        </trans-unit>
        <trans-unit id="06ded168a76972d517d9136275d2690412f2929f" translate="yes" xml:space="preserve">
          <source>The perl message comes out with &quot;Perl&quot; in front. The &lt;code&gt;BEGIN&lt;/code&gt; block works at compile time so all of the compilation errors and warnings get the &quot;Perl:&quot; prefix too.</source>
          <target state="translated">perl消息前面带有&amp;ldquo; Perl&amp;rdquo;。该 &lt;code&gt;BEGIN&lt;/code&gt; 在编译时块的工作，因此所有的编译错误和警告得到&amp;ldquo;的Perl：&amp;rdquo;前缀了。</target>
        </trans-unit>
        <trans-unit id="b63df2b573a7b7008051f6d3411e1d7de7dd31b6" translate="yes" xml:space="preserve">
          <source>The perl source is in a git repository. You can clone the repository with the following command:</source>
          <target state="translated">perl源代码在git仓库中。你可以用下面的命令来克隆仓库。</target>
        </trans-unit>
        <trans-unit id="c5f10541bc3ed7ff03899b584c515233e642fba7" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;&quot;Calling Perl Routines from within C Programs&quot;&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">perl tie函数将变量与实现各种GET，SET等方法的对象相关联。若要执行等效于XSUB的perl tie功能，您必须模仿此行为。下面的代码执行必要的步骤-首先创建一个新的哈希，然后创建第二个哈希，并将其加到将实现tie方法的类中。最后，它将两个哈希绑定在一起，并返回对新绑定哈希的引用。请注意，下面的代码不会调用MyTie类中的TIEHASH方法-有关如何执行此操作的详细信息，请参见&lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;&amp;ldquo;从C程序中调用Perl例程&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="327d340c9d37adf78ea3fa44d3b1c6e9e8b77c71" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Calling Perl Routines from within C Programs&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">perl tie函数将变量与实现各种GET，SET等方法的对象相关联。若要执行等效于XSUB的perl tie功能，您必须模仿此行为。下面的代码执行必要的步骤-首先创建一个新的哈希，然后创建第二个哈希，并将其加到要实现tie方法的类中。最后，它将两个哈希绑定在一起，并返回对新绑定哈希的引用。请注意，下面的代码不会调用MyTie类中的TIEHASH方法- 有关如何执行此操作的详细信息，请参见&lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;从C程序中调用Perl例程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="123c31a7a632081aa07f5ab58c14ca27dc4643f2" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt; .</source>
          <target state="translated">生成的XS子例程的Perl可见名称，它将返回常量。默认为 &lt;code&gt;constant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be6633f7068d6499b516b1dff2ff6cfb89ba5f0c" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt;.</source>
          <target state="translated">生成的XS子例程的perl可见名称，该子例程将返回常量。默认值是 &lt;code&gt;constant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87baa838c319b67b0a259076dbfb27270de34c58" translate="yes" xml:space="preserve">
          <source>The perl-mvs@perl.org list is for discussion of porting issues as well as general usage issues for all EBCDIC Perls. Send a message body of &quot;subscribe perl-mvs&quot; to majordomo@perl.org.</source>
          <target state="translated">perl-mvs@perl.org 列表用于讨论所有 EBCDIC Perls 的移植问题以及一般使用问题。发送 &quot;订阅perl-mvs &quot;的消息到majordomo@perl.org。</target>
        </trans-unit>
        <trans-unit id="5ba3dea55a126a532be4f9eaeca0422de96d0827" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="translated">perl5-changes邮件列表会收到每个修补程序的副本，该副本将提交给perl存储库的维护和开发分支。有关订阅和存档信息，请参见&lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ba06e1bf85435dc89a1bc7a3e1228003027ef95" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;https://lists.perl.org/list/perl5-changes.html&quot;&gt;https://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="translated">perl5-changes邮件列表接收每个补丁的副本，该副本已提交给perl存储库的维护和开发分支。有关订阅和存档信息，请参见&lt;a href=&quot;https://lists.perl.org/list/perl5-changes.html&quot;&gt;https://lists.perl.org/list/perl5-changes.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c029dc7e52d0d0d6369cc3ff0e62686a113c165" translate="yes" xml:space="preserve">
          <source>The perl5-porters (p5p) mailing list is where the Perl standard distribution is maintained and developed. The people who maintain Perl are also referred to as the &quot;Perl 5 Porters&quot;, &quot;p5p&quot; or just the &quot;porters&quot;.</source>
          <target state="translated">perl5-porters (p5p)邮件列表是维护和开发 Perl 标准发行版的地方。维护Perl的人也被称为 &quot;Perl 5 Porters&quot;、&quot;p5p &quot;或只是 &quot;porters&quot;。</target>
        </trans-unit>
        <trans-unit id="3a8b72ced5fe1018b53d36c163e0f112a1621d18" translate="yes" xml:space="preserve">
          <source>The perlXYZ.sis includes only the Perl DLL: to create an additional SIS file which includes some of the standard (pure) Perl libraries, issue the command</source>
          <target state="translated">perlXYZ.sis只包括Perl DLL:要创建一个额外的SIS文件,其中包括一些标准的(纯)Perl库,请发送命令</target>
        </trans-unit>
        <trans-unit id="8239507ba48e88fe2cac6b5f08faa6b68602a3e2" translate="yes" xml:space="preserve">
          <source>The perlapp.sis (11 kB -&amp;gt; 16 kB) will be built in the symbian subdirectory, but a copy will also be made to the main directory.</source>
          <target state="translated">perlapp.sis（11 kB-&amp;gt; 16 kB）将建立在symbian子目录中，但是也会将其复制到主目录中。</target>
        </trans-unit>
        <trans-unit id="55339a112f571a65cc173aaae9b60118d4926fb7" translate="yes" xml:space="preserve">
          <source>The perlbug program will ask you a few questions about your email address and the patch you're submitting. Once you've answered them it will submit your patch via email.</source>
          <target state="translated">perlbug 程序会问你一些关于你的电子邮件地址和你要提交的补丁的问题。一旦你回答了这些问题,它就会通过电子邮件提交你的补丁。</target>
        </trans-unit>
        <trans-unit id="a319a07f2540ad16252f1fe55565bcf46c56c4bb" translate="yes" xml:space="preserve">
          <source>The perldoc for utime also has an example that has the same effect as touch(1) on files that</source>
          <target state="translated">utime的perldoc中也有一个例子,它与touch(1)对以下文件有同样的效果。</target>
        </trans-unit>
        <trans-unit id="ed575d398752b423e73c91acec2e13e6122dc7e1" translate="yes" xml:space="preserve">
          <source>The perlfaq comprises several documents that answer the most commonly asked questions about Perl and Perl programming. It's divided by topic into nine major sections outlined in this document.</source>
          <target state="translated">perlfaq由几个文档组成,回答了关于Perl和Perl编程最常见的问题。它按主题分为本文档概述的九个主要部分。</target>
        </trans-unit>
        <trans-unit id="bf571460e6819407bba20acb1eb1771f32d393cd" translate="yes" xml:space="preserve">
          <source>The perlfaq is an evolving document. Read the latest version at &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;. It is also included in the standard Perl distribution.</source>
          <target state="translated">perlfaq是一份不断发展的文档。请访问&lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;阅读最新版本。它也包含在标准Perl发行版中。</target>
        </trans-unit>
        <trans-unit id="f61ce2c3cec8ab2b0fa16fba7a8409cd6e94fd03" translate="yes" xml:space="preserve">
          <source>The perlfaq is an evolving document. Read the latest version at &lt;a href=&quot;https://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;. It is also included in the standard Perl distribution.</source>
          <target state="translated">perlfaq是一份不断发展的文档。阅读最新版本，&lt;a href=&quot;https://learn.perl.org/faq/&quot;&gt;网址&lt;/a&gt;为http://learn.perl.org/faq/。它也包含在标准Perl发行版中。</target>
        </trans-unit>
        <trans-unit id="d8ba3c9bbcf37ca492d8ac656f9c49509454f36e" translate="yes" xml:space="preserve">
          <source>The perlpod spec for a Verbatim paragraph is &quot;It should be reproduced exactly...&quot;, which means that the whitespace you've used to indent your verbatim blocks will be preserved in the output. This can be annoying for outputs such as HTML, where that whitespace will remain in front of every line. It's an unfortunate case where syntax is turned into semantics.</source>
          <target state="translated">perlpod对逐字段的规范是 &quot;它应该被精确地复制......&quot;,这意味着你用来缩进逐字段的空白将被保留在输出中。这对于像HTML这样的输出来说是很烦人的,因为在这些输出中,每行前面都会保留空白。这是一个不幸的例子,语法变成了语义。</target>
        </trans-unit>
        <trans-unit id="d320cdc510ba6fe180a797e4852d051df0ce9e8c" translate="yes" xml:space="preserve">
          <source>The perlstyle manual supplied with Perl has many helpful points.</source>
          <target state="translated">Perl附带的perlstyle手册中有很多有用的地方。</target>
        </trans-unit>
        <trans-unit id="f61630dfa6a2b75f5a9ee952e22583e2bdae4aef" translate="yes" xml:space="preserve">
          <source>The person whom the &lt;b&gt;operating system&lt;/b&gt; will let do almost anything. Typically your system administrator or someone pretending to be your system administrator. On Unix systems, the &lt;b&gt;root&lt;/b&gt; user. On Windows systems, usually the Administrator user.</source>
          <target state="translated">&lt;b&gt;操作系统&lt;/b&gt;会让任何人做的人。通常，您的系统管理员或冒充您的系统管理员的人。在Unix系统上，是&lt;b&gt;root&lt;/b&gt;用户。在Windows系统上，通常是管理员用户。</target>
        </trans-unit>
        <trans-unit id="4a687dacf6873e351f87d30c48226233e28a0761" translate="yes" xml:space="preserve">
          <source>The pinyin ordering includes some characters that are not CJK Unified Ideographs and can't utilize &lt;code&gt;weightPinyin()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="translated">拼音排序包含一些不是CJK统一表意字符的字符，并且不能利用 &lt;code&gt;weightPinyin()&lt;/code&gt; 进行校对。对于他们，请改用 &lt;code&gt;entry&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="674e8f557a9263711bdd1bff3bb098f69b9e9b84" translate="yes" xml:space="preserve">
          <source>The pipeline model divides up a task into a series of steps, and passes the results of one step on to the thread processing the next. Each thread does one thing to each piece of data and passes the results to the next thread in line.</source>
          <target state="translated">管道模型将一个任务分为一系列步骤,并将一个步骤的结果传递给下一个处理的线程。每个线程对每一个数据做一件事,并将结果传递给下一个线程。</target>
        </trans-unit>
        <trans-unit id="e5963c8e8de82f4449d7ed9e1e51afdf5f459ee1" translate="yes" xml:space="preserve">
          <source>The pl2pm utility will get you started.</source>
          <target state="translated">pl2pm工具将让你开始使用。</target>
        </trans-unit>
        <trans-unit id="1d36c8a340c756f47102c1832b54cb16f13c0c7c" translate="yes" xml:space="preserve">
          <source>The plan (for example, '1..5'), must only come at the beginning or end of the TAP output.</source>
          <target state="translated">计划(例如'1...5'),只能在TAP输出的开头或结尾出现。</target>
        </trans-unit>
        <trans-unit id="b8f929ee511ca422d9eb63d2f4f5d86c27217779" translate="yes" xml:space="preserve">
          <source>The plan event for the subtest</source>
          <target state="translated">子测试的计划事件</target>
        </trans-unit>
        <trans-unit id="4326b3bc4ca816f9708e08eacb7250e5b64a4e86" translate="yes" xml:space="preserve">
          <source>The plugin system in the CPAN shell was introduced in version 2.07 and is still considered experimental.</source>
          <target state="translated">CPAN shell中的插件系统是在2.07版本中引入的,目前仍被认为是实验性的。</target>
        </trans-unit>
        <trans-unit id="b09a69221209bb270cc3034edeb1fb83d92c2242" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; function so that &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">该函数的重点是&amp;ldquo;植入&amp;rdquo; &lt;a href=&quot;#rand-EXPR&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt;函数，以便每次运行程序时&lt;a href=&quot;#rand-EXPR&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt;都能产生不同的序列。当使用参数调用时，&lt;a href=&quot;#srand-EXPR&quot;&gt; &lt;code&gt;srand&lt;/code&gt; &lt;/a&gt;将其用作种子；否则，srand将其用作种子。否则（半）随机选择种子。无论哪种情况，从Perl 5.14开始，它都会返回种子。表示您的代码可以工作</target>
        </trans-unit>
        <trans-unit id="4fc2d017a3ab4b5deac17556464426823c475059" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">该函数的重点是&amp;ldquo;植入&amp;rdquo; &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 函数，以便每次运行程序时 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 都能产生不同的序列。当使用参数调用时， &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 将其用作种子；否则（半）随机选择种子。无论哪种情况，从Perl 5.14开始，它都会返回种子。表示您的代码可以工作</target>
        </trans-unit>
        <trans-unit id="2e1f3e31ba6a1b36a8c681657ab8caf017949b14" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">该函数的重点是&amp;ldquo;植入&amp;rdquo; &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 函数，以便每次运行程序时 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 都能产生不同的序列。当使用参数调用时， &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 将其用作种子；否则（半）随机选择种子。无论哪种情况，从Perl 5.14开始，它都会返回种子。表示您的代码可以工作</target>
        </trans-unit>
        <trans-unit id="d8e49cca1375307d0cbb7648d543980bc0807cf4" translate="yes" xml:space="preserve">
          <source>The pointer is blessed into a class that is derived from the name of type of the pointer but with all '*' in the name replaced with 'Ptr'.</source>
          <target state="translated">指针被祝福成一个类,这个类是由指针的类型名派生出来的,但名字中的'*'都被替换成'Ptr'。</target>
        </trans-unit>
        <trans-unit id="549bcd1d7ae81c0474487c42c591f283db8f5fed" translate="yes" xml:space="preserve">
          <source>The pointer to the PV of the &lt;code&gt;dsv&lt;/code&gt; is returned.</source>
          <target state="translated">返回指向 &lt;code&gt;dsv&lt;/code&gt; PV的指针。</target>
        </trans-unit>
        <trans-unit id="7ab31953e34eba90fc36ab51df0189b64f65aae0" translate="yes" xml:space="preserve">
          <source>The points to note are</source>
          <target state="translated">需要注意的是</target>
        </trans-unit>
        <trans-unit id="c1fdc510fd28f743532d0f8810f2c036e2bf9b84" translate="yes" xml:space="preserve">
          <source>The polar notation (also known as the trigonometric representation) is much more handy for performing multiplications and divisions of complex numbers, whilst the cartesian notation is better suited for additions and subtractions. Real numbers are on the</source>
          <target state="translated">极坐标符号(也称为三角符号)在进行复数的乘法和除法时更为方便,而卡提斯符号则更适合于加减法。实数是在</target>
        </trans-unit>
        <trans-unit id="b5ec1158a1165100647b29065f9f5443b0e8eb69" translate="yes" xml:space="preserve">
          <source>The polar style attempts to emphasize arguments like</source>
          <target state="translated">两极风格试图强调这样的论点,如</target>
        </trans-unit>
        <trans-unit id="69fec36a5f0f42b7b7ddc49268b5d8cea58e3639" translate="yes" xml:space="preserve">
          <source>The popular tool &lt;code&gt;sudo&lt;/code&gt; provides a controlled way for users to be able to run programs as other users. It sanitises the execution environment to some extent, and will avoid the &lt;a href=&quot;#Shebang-Race-Condition&quot;&gt;shebang race condition&lt;/a&gt;. If you don't have the safe version of set-id scripts, then &lt;code&gt;sudo&lt;/code&gt; may be a more convenient way of executing a script as another user than writing a C wrapper would be.</source>
          <target state="translated">流行的工具 &lt;code&gt;sudo&lt;/code&gt; 为用户提供了一种受控方式，使其能够像其他用户一样运行程序。它在某种程度上卫生了执行环境，并避免了&lt;a href=&quot;#Shebang-Race-Condition&quot;&gt;shebang竞赛条件&lt;/a&gt;。如果您没有安全的set-id脚本版本，那么 &lt;code&gt;sudo&lt;/code&gt; 可能是比其他C语言编写者更方便的以另一个用户身份执行脚本的方式。</target>
        </trans-unit>
        <trans-unit id="9c2c870c4a68cedcedbfdb919f7afe57be993942" translate="yes" xml:space="preserve">
          <source>The port for Win32 was used as a reference.</source>
          <target state="translated">Win32的端口被用作参考。</target>
        </trans-unit>
        <trans-unit id="e9a7460e24d0700d3e12dc5c76ead4d814126aa5" translate="yes" xml:space="preserve">
          <source>The port of Perl to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="translated">从Perl 5.12开始,Perl到Mac OS的移植正式被移除,不过MacPerl最后一个正式生产版本对应的是Perl 5.6。虽然Perl 5.10包含了对Mac OS的移植,但ExtUtils::MakeMaker作为Perl模块安装基础架构的核心部分,在2004年4月正式放弃了对Mac OS的支持。</target>
        </trans-unit>
        <trans-unit id="9181a3290f36ca81b3bb6720fe9893dc45df567f" translate="yes" xml:space="preserve">
          <source>The port of Perl to to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="translated">从Perl 5.12开始,Perl到Mac OS的移植被正式取消,不过MacPerl的最后一个正式生产版本对应的是Perl 5.6。虽然Perl 5.10包含了对Mac OS的移植,但ExtUtils::MakeMaker,作为Perl模块安装基础架构的核心部分,在2004年4月正式取消了对Mac OS的支持。</target>
        </trans-unit>
        <trans-unit id="f4180538d74696f5817f3f6feca9a1c65e2c02f2" translate="yes" xml:space="preserve">
          <source>The porters appreciate the time you spent helping to make Perl better. Thank you!</source>
          <target state="translated">搬运工感谢你花时间帮助Perl变得更好。谢谢你们</target>
        </trans-unit>
        <trans-unit id="54bd391c46a02c41cb9ecadecb266d6444c3a53a" translate="yes" xml:space="preserve">
          <source>The portion of the extension provided by the XS code may be connected to the rest of Perl in either of two ways. In the &lt;b&gt;static&lt;/b&gt; configuration, the object code for the extension is linked directly into</source>
          <target state="translated">XS代码提供的扩展部分可以通过两种方式之一连接到Perl的其余部分。在&lt;b&gt;静态&lt;/b&gt;配置中，扩展的目标代码直接链接到</target>
        </trans-unit>
        <trans-unit id="2605e3cd341c048b0037bbd123fa8ea2ca949be7" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="translated">FILEHANDLE在文件中的位置保持不变。您可能要在写入文件之前调用&lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;查找&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c71fa06187e2cb76d45cf6769bdd2d2cbe65fe5" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="translated">FILEHANDLE在文件中的位置保持不变。您可能要在写入文件之前调用&lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;查找&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efdfff91986b015ed9943f5eed1ac7ffd6711ca2" translate="yes" xml:space="preserve">
          <source>The possessive forms (new in Perl 5.10) prevent backtracking: what gets matched by a pattern with a possessive quantifier will not be backtracked into, even if that causes the whole match to fail.</source>
          <target state="translated">占有式(Perl 5.10 中新增的)可以防止回溯:被带有占有式量化符的模式匹配的内容不会被回溯到,即使这会导致整个匹配失败。</target>
        </trans-unit>
        <trans-unit id="5eab19b8b748f65afb0049c25c884441fbae1bc8" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="translated">可能的类别是：： &lt;code&gt;:collate&lt;/code&gt; ， &lt;code&gt;:ctype&lt;/code&gt; ， &lt;code&gt;:messages&lt;/code&gt; ， &lt;code&gt;:monetary&lt;/code&gt; ， &lt;code&gt;:numeric&lt;/code&gt; ， &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 和伪类别 &lt;code&gt;:characters&lt;/code&gt; （如下所述）。</target>
        </trans-unit>
        <trans-unit id="b9cec0c735ea3bb0489e4ea0d12dfd9112e5e476" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt;, &lt;code&gt;:ctype&lt;/code&gt;, &lt;code&gt;:messages&lt;/code&gt;, &lt;code&gt;:monetary&lt;/code&gt;, &lt;code&gt;:numeric&lt;/code&gt;, &lt;code&gt;:time&lt;/code&gt;, and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="translated">可能的类别是：： &lt;code&gt;:collate&lt;/code&gt; ， &lt;code&gt;:ctype&lt;/code&gt; ， &lt;code&gt;:messages&lt;/code&gt; ， &lt;code&gt;:monetary&lt;/code&gt; ， &lt;code&gt;:numeric&lt;/code&gt; ， &lt;code&gt;:time&lt;/code&gt; 和伪类别 &lt;code&gt;:characters&lt;/code&gt; （如下所述）。</target>
        </trans-unit>
        <trans-unit id="00fdb180b333447352b78de9f2313423642a41c9" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;a href=&quot;fcntl&quot;&gt;&lt;code&gt;Fcntl&lt;/code&gt;&lt;/a&gt;. See the documentation of your operating system's &lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open(2)&lt;/a&gt; syscall to see which values and flag bits are available. You may combine several flags using the &lt;code&gt;|&lt;/code&gt;-operator.</source>
          <target state="translated">MODE参数的可能值和标志位取决于系统。它们可以通过标准模块&lt;a href=&quot;fcntl&quot;&gt; &lt;code&gt;Fcntl&lt;/code&gt; 获得&lt;/a&gt;。请参阅操作系统的&lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open（2）&lt;/a&gt; syscall的文档，以查看哪些值和标志位可用。您可以使用 &lt;code&gt;|&lt;/code&gt; 组合多个标志。-操作员。</target>
        </trans-unit>
        <trans-unit id="d6655e8efe41a46d2438d144ed4d6129c437e80b" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;code&gt;Fcntl&lt;/code&gt; . See the documentation of your operating system's</source>
          <target state="translated">MODE参数的可能值和标志位取决于系统。可通过标准模块 &lt;code&gt;Fcntl&lt;/code&gt; 使用它们。请参阅您操作系统的文档</target>
        </trans-unit>
        <trans-unit id="f5b739ecc638266d58487c7c88c27f4bcc3311ca" translate="yes" xml:space="preserve">
          <source>The possibly inferred link-text; i.e., if there was no real link text, then this is the text that we'll infer in its place. (E.g., for &quot;L&amp;lt;Getopt::Std&amp;gt;&quot;, the inferred link text is &quot;Getopt::Std&quot;.)</source>
          <target state="translated">可能推断出的链接文本；即，如果没有真正的链接文本，那么这就是我们将在其位置推断的文本。（例如，对于&amp;ldquo; L &amp;lt;Getopt :: Std&amp;gt;&amp;rdquo;，推断的链接文本为&amp;ldquo; Getopt :: Std&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="4e5ec7c69ae0bd18f551874e75cc4c912902b3a0" translate="yes" xml:space="preserve">
          <source>The practice of saying, &amp;ldquo;If I had to do it all over, I&amp;rsquo;d do it differently,&amp;rdquo; and then actually going back and doing it all over differently. Mathematically speaking, it&amp;rsquo;s returning from an unsuccessful recursion on a tree of possibilities. Perl backtracks when it attempts to match patterns with a &lt;b&gt;regular expression&lt;/b&gt;, and its earlier attempts don&amp;rsquo;t pan out. See the section &amp;ldquo;The Little Engine That /Couldn(n&amp;rsquo;t)&amp;rdquo; in Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">这样说：&amp;ldquo;如果我必须一遍又一遍，我会以不同的方式来做&amp;rdquo;，然后实际上回头并以不同的方式来做一遍。从数学上讲，它是从对可能性树的不成功递归中返回的。当Perl尝试使用&lt;b&gt;正则表达式&lt;/b&gt;匹配模式时，它会回溯，并且其较早的尝试不会成功。请参阅骆驼第5章&amp;ldquo;模式匹配&amp;rdquo;中的&amp;ldquo; /无法（启用）的小引擎&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="03599d25f97c0e2d0192955c405d8519204aa81e" translate="yes" xml:space="preserve">
          <source>The practice of shifting an alphabet one or more characters for encipherment dates back thousands of years and was explicitly detailed by Gaius Julius Caesar in his &lt;b&gt;Gallic Wars&lt;/b&gt; text. A single alphabet shift is sometimes referred to as a rotation and the shift amount is given as a number $n after the string 'rot' or &quot;rot$n&quot;. Rot0 and rot26 would designate identity maps on the 26-letter English version of the Latin alphabet. Rot13 has the interesting property that alternate subsequent invocations are identity maps (thus rot13 is its own non-trivial inverse in the group of 26 alphabet rotations). Hence the following is a rot13 encoder and decoder that will work on ASCII and EBCDIC platforms:</source>
          <target state="translated">将字母转换为一个或多个字符进行加密的做法可以追溯到数千年前，盖乌斯&amp;middot;朱利叶斯&amp;middot;凯撒（Gaius Julius Caesar）在他的《&lt;b&gt;高卢战争》（Gallic Wars）&lt;/b&gt;文字中对此进行了详细说明。有时将单个字母移位称为旋转，并将移位量表示为字符串&amp;ldquo; rot&amp;rdquo;或&amp;ldquo; rot $ n&amp;rdquo;之后的数字$ n。 Rot0和rot26将在拉丁字母的26个字母的英语版本上指定身份映射。 Rot13具有有趣的特性，即交替的后续调用是身份映射（因此rot13是其自身在26个字母旋转的组中的非平凡逆）。因此，以下是适用于ASCII和EBCDIC平台的rot13编码器和解码器：</target>
        </trans-unit>
        <trans-unit id="a4931fe0eefec05b185de502969d863746246773" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="translated">在编译 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ，使 &lt;code&gt;$?&lt;/code&gt; 反映实际的VMS退出状态，而不是上述的POSIX状态的默认模拟。设置 &lt;code&gt;$?&lt;/code&gt; 时，该实用程序还会禁止将非零值转换为SS $ _ABORT 。在END块中（但零仍将转换为SS $ _NORMAL）。</target>
        </trans-unit>
        <trans-unit id="91d3ea3fbae8cd7072d27f773df4ade3db8e3a56" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="translated">在编译 &lt;code&gt;use vmsish 'status'&lt;/code&gt; ，使 &lt;code&gt;$?&lt;/code&gt; 反映实际的VMS退出状态，而不是上述的POSIX状态的默认模拟。设置 &lt;code&gt;$?&lt;/code&gt; 时，该实用程序还会禁止将非零值转换为SS $ _ABORT 。在END块中（但零仍将转换为SS $ _NORMAL）。</target>
        </trans-unit>
        <trans-unit id="36ba59d998f30d35a2800e28be03d01cb711ce6c" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; pragma was supported and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="translated">编译指示是每个脚本而不是每个块的词汇。只有最后 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; 重要，它影响&lt;b&gt;了整个脚本&lt;/b&gt;。但是， &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; 杂乱码受支持，并且 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 可以在给定脚本中出现任意多次（尽管只有最后一个有效）。</target>
        </trans-unit>
        <trans-unit id="9e7b1da1b87c8f47d3de1bab74d0b204e260e393" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;use encoding&lt;/code&gt; or &lt;code&gt;no encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;no encoding&lt;/code&gt; pragma was supported and &lt;code&gt;use encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="translated">编译指示是针对每个脚本的，而不是针对每个块的词汇。只有最后 &lt;code&gt;use encoding&lt;/code&gt; 或 &lt;code&gt;no encoding&lt;/code&gt; 重要，它影响&lt;b&gt;了整个脚本&lt;/b&gt;。但是， &lt;code&gt;no encoding&lt;/code&gt; 杂乱码受支持，并且 &lt;code&gt;use encoding&lt;/code&gt; 可以在给定脚本中出现任意多次（尽管只有最后一个有效）。</target>
        </trans-unit>
        <trans-unit id="f8b4d970b42fbff322fe3d169272f393cc128f89" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="translated">编译指示&lt;a href=&quot;../bignum&quot;&gt;BIGNUM&lt;/a&gt;，&lt;a href=&quot;../bigint&quot;&gt;BIGINT&lt;/a&gt;和&lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt;因为他们解决autoupgrading /降级问题，至少部分也可能会感兴趣。</target>
        </trans-unit>
        <trans-unit id="76569ddba56c9f99056592d21ac1b2ff490f26ec" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="translated">编译指示&lt;a href=&quot;bignum&quot;&gt;BIGNUM&lt;/a&gt;，&lt;a href=&quot;bigint&quot;&gt;BIGINT&lt;/a&gt;和&lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt;因为他们解决autoupgrading /降级问题，至少部分也可能会感兴趣。</target>
        </trans-unit>
        <trans-unit id="984c1d7b1bad11977f9a25ba621b51c787c8e6c4" translate="yes" xml:space="preserve">
          <source>The preamble added to each output file is rather verbose, and most of it is only necessary in the presence of non-ASCII characters. It would ideally be nice if all of those definitions were only output if needed, perhaps on the fly as the characters are used.</source>
          <target state="translated">添加到每个输出文件中的序言相当啰嗦,而且大多数序言只有在出现非ASCII字符时才是必要的。如果所有这些定义只在需要的时候才输出,或许在使用字符的过程中即时输出,那就更好了。</target>
        </trans-unit>
        <trans-unit id="45357f49e477501b84ee9e2077b2244c8a2bb54d" translate="yes" xml:space="preserve">
          <source>The preamble code for the class is as follows:</source>
          <target state="translated">该类的前言代码如下。</target>
        </trans-unit>
        <trans-unit id="b4c4542a57f99c1f10f3ac073718f1821e067ea0" translate="yes" xml:space="preserve">
          <source>The preference of the &lt;b&gt;regular expression&lt;/b&gt; engine to match the leftmost occurrence of a &lt;b&gt;pattern&lt;/b&gt;, then given a position at which a match will occur, the preference for the longest match (presuming the use of a &lt;b&gt;greedy&lt;/b&gt; quantifier). See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo; for</source>
          <target state="translated">所述的优先级&lt;b&gt;的正则表达式&lt;/b&gt;引擎匹配的最左边的发生&lt;b&gt;模式&lt;/b&gt;，然后在给定的其中一个匹配会发生位置，为最长匹配偏好（假设使用的&lt;b&gt;贪婪&lt;/b&gt;量词）。有关信息，请参见骆驼第5章&amp;ldquo;模式匹配&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="fb28a274f1049ea39bf5f7992f63f38b064b26ab" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; .</source>
          <target state="translated">首选的方法是在 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; 时声明一个计划。</target>
        </trans-unit>
        <trans-unit id="5006ab06a26ab8e5eca93c03d0291151f3f3136d" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;use Test::More&lt;/code&gt;.</source>
          <target state="translated">执行此操作的首选方法是在 &lt;code&gt;use Test::More&lt;/code&gt; 时声明一个计划。</target>
        </trans-unit>
        <trans-unit id="a070b02ec3ff7789ebf48e13bc147cc73129be84" translate="yes" xml:space="preserve">
          <source>The prefix specified by &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; will be used with a numeric suffix if the name for a value is undefined.</source>
          <target state="translated">如果未定义值的名称，则 &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; 指定的前缀将带有数字后缀。</target>
        </trans-unit>
        <trans-unit id="47b994ba12e424b0e632ed96c89a1498fbc470f8" translate="yes" xml:space="preserve">
          <source>The presence of the word &quot;FATAL&quot; in the category list will escalate warnings in those categories into fatal errors in that lexical scope.</source>
          <target state="translated">在类别列表中出现 &quot;FATAL &quot;一词,将把这些类别中的警告升级为该词法范围内的致命错误。</target>
        </trans-unit>
        <trans-unit id="7069f5b0b1dc1568e108cd084477a400c3f8668e" translate="yes" xml:space="preserve">
          <source>The previous assignments are exactly equivalent to</source>
          <target state="translated">前面的作业完全等同于</target>
        </trans-unit>
        <trans-unit id="131e26e34a6a280e8d155fa06c2fe106438c82bd" translate="yes" xml:space="preserve">
          <source>The previous behavior of putting the errors (converted to POSIX-style &lt;code&gt;E*&lt;/code&gt; error codes since Perl 5.20.0) into &lt;code&gt;$!&lt;/code&gt; was buggy due to the non-equivalence of like-named Winsock and POSIX error constants, a relationship between which has unfortunately been established in one way or another since Perl 5.8.0.</source>
          <target state="translated">将错误（自Perl 5.20.0起已转换为POSIX样式的 &lt;code&gt;E*&lt;/code&gt; 错误代码）放入 &lt;code&gt;$!&lt;/code&gt; 的先前行为。由于同名的Winsock和POSIX错误常数不相等，所以它是错误的，不幸的是，自Perl 5.8.0起，它们之间的关系已经以一种或另一种方式建立。</target>
        </trans-unit>
        <trans-unit id="8d4bba88bb17e91a3967206974b895243970981e" translate="yes" xml:space="preserve">
          <source>The previous example was not particularly useful. To make it more general purpose we will make use of the context data and allow any arbitrary</source>
          <target state="translated">前面的例子不是特别有用。为了使其更加通用,我们将利用上下文数据,允许任意的</target>
        </trans-unit>
        <trans-unit id="e9b3a0712244fd40d4ef0fb4f6b05e3de06f443f" translate="yes" xml:space="preserve">
          <source>The previous paragraph is applicable verbatim to tied hash access using the &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; functions as well.</source>
          <target state="translated">上一段同样适用于使用 &lt;code&gt;hv_store&lt;/code&gt; 和 &lt;code&gt;hv_store_ent&lt;/code&gt; 函数的绑定哈希访问。</target>
        </trans-unit>
        <trans-unit id="dd2b650563ddd2d2b6e29ef9f64d0b20b2f5e086" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any text. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="translated">上一节（由 &lt;code&gt;=head&lt;/code&gt; 命令引入）不包含任何文本。这通常表示缺少某些东西。注： &lt;code&gt;=head1&lt;/code&gt; ，紧接着 &lt;code&gt;=head2&lt;/code&gt; 不会触发此警告。</target>
        </trans-unit>
        <trans-unit id="b2d4d760a41ac2c4684274cd24041bdb5438342a" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any valid content. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="translated">上一节（由 &lt;code&gt;=head&lt;/code&gt; 命令引入）不包含任何有效内容。这通常表示缺少某些内容。注： &lt;code&gt;=head1&lt;/code&gt; ，紧接着 &lt;code&gt;=head2&lt;/code&gt; 不会触发此警告。</target>
        </trans-unit>
        <trans-unit id="186c5466a670230e882670fbcd9b5aa0c0353eb4" translate="yes" xml:space="preserve">
          <source>The previous step created</source>
          <target state="translated">上一步创建了</target>
        </trans-unit>
        <trans-unit id="d900c388659851ed663901ca396af85f982c5cba" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;&quot;LD_LIBRARY_PATH&quot;&lt;/a&gt; above.</source>
          <target state="translated">&amp;ldquo; dlopen：存根拦截失败&amp;rdquo;消息的主要原因是LD_LIBRARY_PATH环境变量包含一个目录，该目录是/ usr / lib（例如/ lib）的符号链接。请参阅上方的&lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;&amp;ldquo; LD_LIBRARY_PATH&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="340b1d36d10dcf0bc3c98148a5a96864b33866c8" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt; above.</source>
          <target state="translated">&amp;ldquo; dlopen：存根拦截失败&amp;rdquo;消息的主要原因是LD_LIBRARY_PATH环境变量包含一个目录，该目录是/ usr / lib（例如/ lib）的符号链接。请参阅上面的&lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b0f3d276de0b395d904df1ee65d02fbb91e800c" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; .</source>
          <target state="translated">该模块的主要目的是提供对zip文件和缓冲区的流写入访问。它不是通用文件存档器。如果这是您想要的，请签出 &lt;code&gt;Archive::Zip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7109b8aae18759607febf6d98f672f7929c0c0ad" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; or &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt;.</source>
          <target state="translated">该模块的主要目的是提供对zip文件和缓冲区的流式写访问。它不是通用文件存档器。如果这是您想要的，请签出 &lt;code&gt;Archive::Zip&lt;/code&gt; 或 &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3562a709266ee6938735493658a732dcdd3f50d6" translate="yes" xml:space="preserve">
          <source>The primary reference for Zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;.</source>
          <target state="translated">Zip文件的主要参考是&lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT上&lt;/a&gt;的&amp;ldquo; appnote&amp;rdquo;文档。</target>
        </trans-unit>
        <trans-unit id="b5865d60bf4675397309adf39254a9c20e60ce62" translate="yes" xml:space="preserve">
          <source>The primary reference for Zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;https://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;.</source>
          <target state="translated">Zip文件的主要参考是&lt;a href=&quot;https://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT上&lt;/a&gt;的&amp;ldquo; appnote&amp;rdquo;文档。</target>
        </trans-unit>
        <trans-unit id="adaddbe76e40b85855bdb3acd3e478586223f423" translate="yes" xml:space="preserve">
          <source>The primary reference for gzip files is RFC 1952 &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1952.html&quot;&gt;http://www.faqs.org/rfcs/rfc1952.html&lt;/a&gt;</source>
          <target state="translated">gzip文件的主要参考是RFC 1952 &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1952.html&quot;&gt;http://www.faqs.org/rfcs/rfc1952.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc24d550b4fe8851d0897e687949d42067e8b5a9" translate="yes" xml:space="preserve">
          <source>The primary reference for zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;</source>
          <target state="translated">zip文件的主要参考是&lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT上&lt;/a&gt;的&amp;ldquo; appnote&amp;rdquo;文档。</target>
        </trans-unit>
        <trans-unit id="172150eb79f9c57ed50477a5e17aef4d85de5065" translate="yes" xml:space="preserve">
          <source>The primary reference for zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;https://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;</source>
          <target state="translated">zip文件的主要参考是&lt;a href=&quot;https://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT上&lt;/a&gt;的&amp;ldquo; appnote&amp;rdquo;文档。</target>
        </trans-unit>
        <trans-unit id="1bcb3725358ae123bceedddb8d71ef7119024583" translate="yes" xml:space="preserve">
          <source>The primary site for bzip2 is &lt;a href=&quot;http://www.bzip.org&quot;&gt;http://www.bzip.org&lt;/a&gt;.</source>
          <target state="translated">bzip2的主要站点是&lt;a href=&quot;http://www.bzip.org&quot;&gt;http://www.bzip.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d840d1ff084fc0827d16e21e7b3094c84c9a7a3" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is</source>
          <target state="translated">gzip的主要站点是</target>
        </trans-unit>
        <trans-unit id="e859dd2ba7bc9bbaa39a1807494221205b0a4770" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is &lt;a href=&quot;http://www.gzip.org&quot;&gt;http://www.gzip.org&lt;/a&gt;.</source>
          <target state="translated">gzip的主要网站是&lt;a href=&quot;http://www.gzip.org&quot;&gt;http://www.gzip.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76b9d6c85592a8675b44ceb172e5fcc460f2a10f" translate="yes" xml:space="preserve">
          <source>The primary site for the</source>
          <target state="translated">的主要场所。</target>
        </trans-unit>
        <trans-unit id="dff39311adfb064fbb523d321b7e4b3dbea2499f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is</source>
          <target state="translated">bzip2程序的主要站点是</target>
        </trans-unit>
        <trans-unit id="6d5111f3cd60b1576c60bc8b7e186e70a9cf368f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is &lt;a href=&quot;https://sourceware.org/bzip2/&quot;&gt;https://sourceware.org/bzip2/&lt;/a&gt;.</source>
          <target state="translated">bzip2程序的主要站点是&lt;a href=&quot;https://sourceware.org/bzip2/&quot;&gt;https://sourceware.org/bzip2/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20a7ebabe8aa28f193ee803e7dabf5b8ae97c28d" translate="yes" xml:space="preserve">
          <source>The principal value of the arc tangent of y/x</source>
          <target state="translated">y/x的弧切线的主值</target>
        </trans-unit>
        <trans-unit id="c3a6a975854cac68d0d2fce1f652f0011a15276f" translate="yes" xml:space="preserve">
          <source>The principle is that the number of objects found influences how an item is displayed. If the search finds one item, the result is displayed with the rather verbose method &lt;code&gt;as_string&lt;/code&gt; , but if more than one is found, each object is displayed with the terse method &lt;code&gt;as_glimpse&lt;/code&gt; .</source>
          <target state="translated">原理是找到的对象数量会影响项目的显示方式。如果搜索找到一项，则使用相当冗长的方法 &lt;code&gt;as_string&lt;/code&gt; 显示结果，但是如果找到多个项，则使用简洁的方法 &lt;code&gt;as_glimpse&lt;/code&gt; 显示每个对象。</target>
        </trans-unit>
        <trans-unit id="febd9a2b7b0ebfb667a62ab220755a864d89456a" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; . You can set $OFS and $ORS if you're using the English module.</source>
          <target state="translated">除非您设置 &lt;code&gt;$,&lt;/code&gt; 和 &lt;code&gt;$\&lt;/code&gt; ，否则print（）语句不会添加字段和记录分隔符。如果使用英语模块，则可以设置$ OFS和$ ORS。</target>
        </trans-unit>
        <trans-unit id="2da7e391c9fd1ea8ee0cde415f9757d6cf29bace" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt;. You can set $OFS and $ORS if you're using the English module.</source>
          <target state="translated">除非您设置 &lt;code&gt;$,&lt;/code&gt; 和 &lt;code&gt;$\&lt;/code&gt; ，否则print（）语句不会添加字段和记录分隔符。如果使用英语模块，则可以设置$ OFS和$ ORS。</target>
        </trans-unit>
        <trans-unit id="e38b92f2492beff5f39d922c93e2a6ed6bba00e9" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;_installed_file_for_module&lt;/code&gt; method may be replaced with other methods for locating a module in &lt;code&gt;@INC&lt;/code&gt;.</source>
          <target state="translated">专用 &lt;code&gt;_installed_file_for_module&lt;/code&gt; 方法可以用其他方法替换，以便在 &lt;code&gt;@INC&lt;/code&gt; 中定位模块。</target>
        </trans-unit>
        <trans-unit id="39cbd438adc424d857eb231b91cd98738e10a91c" translate="yes" xml:space="preserve">
          <source>The private data cache will take ownership of a reference to private_sv, much the same way that &lt;code&gt;hv_store()&lt;/code&gt; takes ownership of a reference to the value that you pass it.</source>
          <target state="translated">私有数据缓存将拥有对private_sv的引用的所有权，与 &lt;code&gt;hv_store()&lt;/code&gt; 拥有对您传递的值的引用的所有权的方式几乎相同。</target>
        </trans-unit>
        <trans-unit id="7c29fbafe2b5b36ada501a03eca4a2fd699c674d" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; .</source>
          <target state="translated">诸如 &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; 类的私有对象哈希键可能不会更改，但可以添加其他键，如 &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22731711df90de28382d892b4f249e651429dc6f" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt;.</source>
          <target state="translated">诸如 &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; 类的私有对象哈希键可能不会更改，但可以添加其他键，如 &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="660e221c9f99f43f8d3110d11068349758eb697d" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;&quot;RESTORE_LC_NUMERIC&quot;&lt;/a&gt; can restore it.</source>
          <target state="translated">专用变量用于保存当前的语言环境状态，以便对&lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;&amp;ldquo; RESTORE_LC_NUMERIC&amp;rdquo;&lt;/a&gt;进行必要的匹配调用可以将其还原。</target>
        </trans-unit>
        <trans-unit id="9da35a7db7a9991be43f0a35bab375b2fa2f7661" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; can restore it.</source>
          <target state="translated">private变量用于保存当前的语言环境状态，以便对&lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt;进行必要的匹配调用可以恢复它。</target>
        </trans-unit>
        <trans-unit id="2ca51914e8f8318dafeffce74323b676d587ba34" translate="yes" xml:space="preserve">
          <source>The private_use feature is experimental</source>
          <target state="translated">私人使用功能是试验性的</target>
        </trans-unit>
        <trans-unit id="5290ff0dba8c2d4696fae469f418160732641247" translate="yes" xml:space="preserve">
          <source>The problem can be further examined in a roughly equivalent C program:</source>
          <target state="translated">这个问题可以在一个大致相当的C程序中进一步研究。</target>
        </trans-unit>
        <trans-unit id="13328591f6760dcc09259e6c0b9735e71fa4da38" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt; :</source>
          <target state="translated">当您从Perl认为是字符串的东西中获取数字时（例如 &lt;code&gt;@ARGV&lt;/code&gt; 中的命令行参数），就会出现问题：</target>
        </trans-unit>
        <trans-unit id="2c1b07cc8bfa77fdc4b2aa2cb8ca8cba9947e03f" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt;:</source>
          <target state="translated">当您从Perl认为是字符串的东西中获取数字时，例如 &lt;code&gt;@ARGV&lt;/code&gt; 中的命令行参数，就会出现问题：</target>
        </trans-unit>
        <trans-unit id="cd8bb5622c99567256e6a98501e22410a2a7900d" translate="yes" xml:space="preserve">
          <source>The problem comes when you have, for instance, a string that isn't flagged as UTF-8, and contains a byte sequence that could be UTF-8 -- especially when combining non-UTF-8 and UTF-8 strings.</source>
          <target state="translated">例如,当你有一个没有标记为UTF-8的字符串,并且包含一个可能是UTF-8的字节序列时,问题就来了--特别是当你把非UTF-8和UTF-8的字符串结合起来时。</target>
        </trans-unit>
        <trans-unit id="e918e6ad2cf12f5152c6540799f1ea5ccc7d457e" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="translated">存在该问题是因为分配给 &lt;code&gt;*Foo::foo&lt;/code&gt; glob 的匿名子例程将在调用堆栈中显示为被称为 &lt;code&gt;__ANON__&lt;/code&gt; 而不是您期望的 &lt;code&gt;foo&lt;/code&gt; 。由于 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 程序查找被调用的方法的名称，因此在这种情况下将失败。</target>
        </trans-unit>
        <trans-unit id="f6e3278fa9663415debfd4e39d0b068a1659902a" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;next::method&lt;/code&gt; uses &lt;code&gt;caller&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="translated">存在该问题是因为分配给 &lt;code&gt;*Foo::foo&lt;/code&gt; glob的匿名子例程将在调用堆栈中显示为被称为 &lt;code&gt;__ANON__&lt;/code&gt; 而不是您期望的 &lt;code&gt;foo&lt;/code&gt; 。由于 &lt;code&gt;next::method&lt;/code&gt; 使用 &lt;code&gt;caller&lt;/code&gt; 程序查找被调用的方法的名称，因此在这种情况下将失败。</target>
        </trans-unit>
        <trans-unit id="aea1a84a6e43b26958b1598b1f93e9a632b83a16" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="translated">这里的问题是，Uid_t可能不仅在 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 范围内，而且可能没有符号，在这种情况下，大的uid将被打印为负值。</target>
        </trans-unit>
        <trans-unit id="27a99efdaf6b6471f2df947f1f817dd0e909810c" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;int&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="translated">这里的问题是，Uid_t可能不仅在 &lt;code&gt;int&lt;/code&gt; 范围内，而且还可能是无符号的，在这种情况下，大的uid将被打印为负值。</target>
        </trans-unit>
        <trans-unit id="56bc12834cd035d1009997925f3d7abe998a9788" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">这里的问题是，名为 &lt;code&gt;a&lt;/code&gt; 的组和名为 &lt;code&gt;b&lt;/code&gt; 的组都是属于 &lt;code&gt;$1&lt;/code&gt; 的组的别名。</target>
        </trans-unit>
        <trans-unit id="b18408c3bf47516e5c9af25c6047a1bd86154733" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt;.</source>
          <target state="translated">这里的问题是，名为 &lt;code&gt;a&lt;/code&gt; 的组和名为 &lt;code&gt;b&lt;/code&gt; 的组都是属于 &lt;code&gt;$1&lt;/code&gt; 的组的别名。</target>
        </trans-unit>
        <trans-unit id="dda9a4d26fe1b0eb3aeffd7cffb748b622bb8f5f" translate="yes" xml:space="preserve">
          <source>The problem is that Perl has both compile-time and run-time warnings. To disable compile-time warnings you need to rewrite the code like this:</source>
          <target state="translated">问题是Perl有编译时和运行时的警告。要禁用编译时警告,你需要重写这样的代码。</target>
        </trans-unit>
        <trans-unit id="000d776ae8231195ffb025ac77c4f425f1c2ff6f" translate="yes" xml:space="preserve">
          <source>The problem is that both &lt;code&gt;rp&lt;/code&gt; and &lt;code&gt;dp&lt;/code&gt; are pointers to the same location in memory! In C, you'd have to remember to malloc() yourself some new memory. In Perl, you'll want to use the array constructor &lt;code&gt;[]&lt;/code&gt; or the hash constructor &lt;code&gt;{}&lt;/code&gt; instead. Here's the right way to do the preceding broken code fragments:</source>
          <target state="translated">问题在于 &lt;code&gt;rp&lt;/code&gt; 和 &lt;code&gt;dp&lt;/code&gt; 都是指向内存中相同位置的指针！在C语言中，您必须记住自己给malloc（）一些新的内存。在Perl中，您将要使用数组构造函数 &lt;code&gt;[]&lt;/code&gt; 或哈希构造函数 &lt;code&gt;{}&lt;/code&gt; 。这是执行前面的破碎代码片段的正确方法：</target>
        </trans-unit>
        <trans-unit id="44e0ee462b8e8a33d77de1117d49fdbd0c841da5" translate="yes" xml:space="preserve">
          <source>The problem is that grep builds a return list, regardless of the context. This means you're making Perl go to the trouble of building a list that you then just throw away. If the list is large, you waste both time and space. If your intent is to iterate over the list, then use a for loop for this purpose.</source>
          <target state="translated">问题是 grep 会建立一个返回列表,而不管上下文如何。这意味着你让Perl费尽心思建立一个列表,然后你就把它扔掉。如果列表很大,你会浪费时间和空间。如果你的目的是在列表上进行迭代,那么就使用 for 循环来实现这个目的。</target>
        </trans-unit>
        <trans-unit id="6df859dc8cac16c31baff14e80c7d840e1cb3153" translate="yes" xml:space="preserve">
          <source>The problem is that none of these examples are reliable: they depend on the command interpreter. Under Unix, the first two often work. Under DOS, it's entirely possible that neither works. If 4DOS was the command shell, you'd probably have better luck like this:</source>
          <target state="translated">问题是,这些例子都不可靠:它们取决于命令解释器。在Unix下,前两个经常能用。在DOS下,完全有可能两个都不行。如果4DOS是命令外壳,你可能会有更好的运气,像这样。</target>
        </trans-unit>
        <trans-unit id="95485cb814321ef14b952e45ddf9a35301af1a5e" translate="yes" xml:space="preserve">
          <source>The problem is that none of this is reliable: it depends on the command and it is entirely possible neither works. If</source>
          <target state="translated">问题是这些都不靠谱:它取决于命令,完全有可能两个都不管用。如果</target>
        </trans-unit>
        <trans-unit id="88377fbeaf8b4fab35329a7e374ea24a4795a7c5" translate="yes" xml:space="preserve">
          <source>The problem is that this code will always be parsed and executed, even when the debug level set in the logging configuration file is zero. Once the debug() subroutine has been entered, and the internal &lt;code&gt;$debug&lt;/code&gt; variable confirmed to be zero, for example, the message which has been sent in will be discarded and the program will continue. In the example given though, the &lt;code&gt;\%INC&lt;/code&gt; hash will already have been dumped, and the message string constructed, all of which work could be bypassed by a debug variable at the statement level, like this:</source>
          <target state="translated">问题在于，即使在日志配置文件中设置的调试级别为零时，也始终将解析并执行此代码。例如，一旦输入debug（）子例程，并且内部 &lt;code&gt;$debug&lt;/code&gt; 变量确认为零，已发送的消息将被丢弃，程序将继续。在给出的示例中， &lt;code&gt;\%INC&lt;/code&gt; 哈希将已经被转储，并且构造了消息字符串，所有这些工作都可以由语句级别的调试变量绕过，如下所示：</target>
        </trans-unit>
        <trans-unit id="73cae6ed898e3261e96216aa07490bc469dc51e8" translate="yes" xml:space="preserve">
          <source>The problem is that this code would</source>
          <target state="translated">问题是,这段代码将</target>
        </trans-unit>
        <trans-unit id="e6af2011607132108daf874aceb7c74f8abf4357" translate="yes" xml:space="preserve">
          <source>The problem is that those double-quotes force stringification--coercing numbers and references into strings--even when you don't want them to be strings. Think of it this way: double-quote expansion is used to produce new strings. If you already have a string, why do you need more?</source>
          <target state="translated">问题是,这些双引号强迫字符串化--强迫数字和引用成为字符串--即使你不希望它们成为字符串。可以这样想:双引号扩展是用来产生新的字符串的。如果你已经有了一个字符串,为什么还需要更多?</target>
        </trans-unit>
        <trans-unit id="d0f76e9ccc888898fb7c8d297bdf6217c3b3b765" translate="yes" xml:space="preserve">
          <source>The problem is that various structures visible via procfs use off_t, and if you compile with largefile support these change from 32 bits to 64 bits. Thus what you get back from procfs doesn't match up with the structures in perl, resulting in garbage. See proc(4) for further discussion.</source>
          <target state="translated">问题是通过procfs可见的各种结构都使用off_t,如果编译时支持largefile,这些结构就会从32位变为64位。因此,你从 procfs 得到的东西与 perl 中的结构不匹配,导致垃圾。更多讨论请参见 proc(4)。</target>
        </trans-unit>
        <trans-unit id="36b3f29973dcb4084c4233c180d15ad0f5ad2090" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;'*'&lt;/code&gt;: one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n,</source>
          <target state="translated">问题是嵌套的不确定量词。在 &lt;code&gt;'+'&lt;/code&gt; 和 &lt;code&gt;'*'&lt;/code&gt; 之间划分长度为n的字符串有很多不同的方法：一个重复的 &lt;code&gt;b+&lt;/code&gt; 长度为n，两个重复的第一个 &lt;code&gt;b+&lt;/code&gt; 长度为k，第二个重复的长度为nk，m个重复，其位加直到长度n，</target>
        </trans-unit>
        <trans-unit id="fc4b1a9098877c5f0dfd053c053f3947a9421580" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; : one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n, etc. In fact there are an exponential number of ways to partition a string as a function of its length. A regexp may get lucky and match early in the process, but if there is no match, Perl will try</source>
          <target state="translated">问题是嵌套的不确定量词。在 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt; 之间划分长度为n的字符串有很多不同的方法：一个重复的 &lt;code&gt;b+&lt;/code&gt; 长度为n，两个重复的第一个 &lt;code&gt;b+&lt;/code&gt; 长度为k，第二个重复的长度为nk，m个重复，其位的总和为n等等。实际上，根据字符串的长度，有成千上万种方式对字符串进行分区。正则表达式可能会很幸运，并且可以在此过程的早期进行匹配，但是如果没有匹配项，Perl会尝试</target>
        </trans-unit>
        <trans-unit id="57ef8306dabb66b8a3dd5849936f56c155cd391f" translate="yes" xml:space="preserve">
          <source>The problem is usually that the command interpreters on those systems have rather different ideas about quoting than the Unix shells under which the one-liners were created. On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">问题通常是这些系统上的命令解释器与创建单引号的Unix shell有相当不同的想法。在某些系统上,你可能不得不将单引号改为双引号,你必须要用</target>
        </trans-unit>
        <trans-unit id="814a82003c2ef63857b1187789261eb0a14ef57b" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;$writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="translated">问题在于缓冲确实会毁了您的一天。即使 &lt;code&gt;$writer&lt;/code&gt; 文件句柄被自动刷新，以便另一端的过程可以及时获取数据，您通常也无法采取任何措施强制该过程以类似的快速方式将其数据提供给您。在这种特殊情况下，我们实际上可以这样做，因为我们给了</target>
        </trans-unit>
        <trans-unit id="5ee9f00b1299262770f29ccbf33382cfb01278a2" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;Writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="translated">问题在于缓冲确实会破坏您的一天。即使您的 &lt;code&gt;Writer&lt;/code&gt; 文件句柄已自动刷新，以便另一端的进程及时获取数据，您通常也无法采取任何措施强制该进程以类似的快速方式将其数据提供给您。在这种特殊情况下，我们实际上可以这样做，因为</target>
        </trans-unit>
        <trans-unit id="f6f3b81b70ac61e4574d6ebcd3e976b1d72049f0" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt; . It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="translated">垃圾回收和线程安全的问题都可以通过函数 &lt;code&gt;register()&lt;/code&gt; 来解决。它将对象与任何数量的哈希一起注册。注册表意味着当对象死亡时，将删除该对象的引用地址下任何哈希中的条目。这样可以保证在这些哈希中收集垃圾。这也意味着在线程克隆时，已注册哈希中的对象条目将替换为更新的条目，其键为克隆对象的引用地址。因此，对象数据关联变为线程安全的。</target>
        </trans-unit>
        <trans-unit id="d49a5cf6f714984f5d4aa1ae27ae4adaa45ad30d" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt;. It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="translated">垃圾回收和线程安全的问题都可以通过函数 &lt;code&gt;register()&lt;/code&gt; 来解决。它将对象与任何数量的哈希一起注册。注册表意味着当对象死亡时，该对象的引用地址下的任何哈希中的条目都将被删除。这样可以保证在这些哈希中收集垃圾。这也意味着在线程克隆中，已注册哈希中的对象条目将被更新的条目替换，更新的条目的键为所克隆对象的引用地址。因此，对象数据关联变为线程安全的。</target>
        </trans-unit>
        <trans-unit id="4aef2d934929be669275ad225ef041e450d29108" translate="yes" xml:space="preserve">
          <source>The procedure for doing this is roughly as follows (using the example of tonyc's smoke-me branch called win32stat):</source>
          <target state="translated">其操作过程大致如下(以tonyc的smoke-me分支win32stat为例)。</target>
        </trans-unit>
        <trans-unit id="9452ac7ff4d68965b2304a021a3f491d59cd9f05" translate="yes" xml:space="preserve">
          <source>The process ID in which the event was generated.</source>
          <target state="translated">事件产生的过程ID。</target>
        </trans-unit>
        <trans-unit id="95e6fb31b348934a4b1c0d293aa560867eaa2c02" translate="yes" xml:space="preserve">
          <source>The process number of the Perl running this script. Though you</source>
          <target state="translated">运行这个脚本的Perl的进程号。虽然你</target>
        </trans-unit>
        <trans-unit id="b93ffa0ee1718038fedc8009038c2d7f70371455" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">将字符串转换为四个Unicode &lt;b&gt;casemap&lt;/b&gt;之一的&lt;b&gt;过程&lt;/b&gt; ;在Perl中，它是通过 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; 函数实现的。</target>
        </trans-unit>
        <trans-unit id="7b3ce77cc42e100f56e2fb73208b06058b72b962" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;fc&lt;/code&gt;, &lt;code&gt;lc&lt;/code&gt;, &lt;code&gt;ucfirst&lt;/code&gt;, and &lt;code&gt;uc&lt;/code&gt; functions.</source>
          <target state="translated">将字符串转换为四个Unicode &lt;b&gt;casemap&lt;/b&gt;之一的&lt;b&gt;过程&lt;/b&gt;;在Perl中，它是通过 &lt;code&gt;fc&lt;/code&gt; ， &lt;code&gt;lc&lt;/code&gt; ， &lt;code&gt;ucfirst&lt;/code&gt; 和 &lt;code&gt;uc&lt;/code&gt; 函数实现的。</target>
        </trans-unit>
        <trans-unit id="2cf36cd26c284e1c84d9c66a1a4b1fbb69c4ead2" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt; , its only parent is &lt;code&gt;File&lt;/code&gt; . If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">确定应使用哪种方法的过程称为&lt;b&gt;方法解析&lt;/b&gt;。Perl要做的是首先 &lt;code&gt;File::MP3&lt;/code&gt; 对象的类（在这种情况下为File :: MP3）。如果该类定义了方法，则将调用该类的方法版本。如果不是，Perl依次检查每个父类。对于 &lt;code&gt;File::MP3&lt;/code&gt; ，其唯一的父对象是 &lt;code&gt;File&lt;/code&gt; 。如果 &lt;code&gt;File::MP3&lt;/code&gt; 没有定义方法，但是 &lt;code&gt;File&lt;/code&gt; 定义了，则Perl在 &lt;code&gt;File&lt;/code&gt; 中调用该方法。</target>
        </trans-unit>
        <trans-unit id="2d45b13e98be85d3a3cff56a4de1619efcb5c0e5" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt;, its only parent is &lt;code&gt;File&lt;/code&gt;. If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="translated">确定应使用哪种方法的过程称为&lt;b&gt;方法解析&lt;/b&gt;。Perl要做的是首先 &lt;code&gt;File::MP3&lt;/code&gt; 对象的类（在这种情况下为File :: MP3）。如果该类定义了方法，则将调用该类的方法版本。如果不是，则Perl依次检查每个父类。对于 &lt;code&gt;File::MP3&lt;/code&gt; ，其唯一的父对象是 &lt;code&gt;File&lt;/code&gt; 。如果 &lt;code&gt;File::MP3&lt;/code&gt; 没有定义方法，但是 &lt;code&gt;File&lt;/code&gt; 定义了方法，则Perl在 &lt;code&gt;File&lt;/code&gt; 中调用该方法。</target>
        </trans-unit>
        <trans-unit id="080ae8ae51ff51ae8e5ac989879f84eb0a78985b" translate="yes" xml:space="preserve">
          <source>The process of gluing one cat&amp;rsquo;s nose to another cat&amp;rsquo;s tail. Also a similar operation on two &lt;b&gt;strings&lt;/b&gt;.</source>
          <target state="translated">将一只猫的鼻子粘到另一只猫的尾巴上的过程。对两个&lt;b&gt;字符串&lt;/b&gt;也有类似的操作。</target>
        </trans-unit>
        <trans-unit id="908f91e0beaa0a05d55f4dc47581a39df63d9d61" translate="yes" xml:space="preserve">
          <source>The process of producing a &lt;b&gt;string&lt;/b&gt; representation of an abstract object.</source>
          <target state="translated">产生抽象对象的&lt;b&gt;字符串&lt;/b&gt;表示的过程。</target>
        </trans-unit>
        <trans-unit id="3e1e79f73acf8d324572f017b3dffb010974336f" translate="yes" xml:space="preserve">
          <source>The process of trying one alternative, seeing if it matches, and moving on to the next alternative, while going back in the string from where the previous alternative was tried, if it doesn't, is called</source>
          <target state="translated">尝试一个备选方案,看是否匹配,然后转到下一个备选方案,如果不匹配,则从上一个备选方案所在的字符串返回,这个过程称为</target>
        </trans-unit>
        <trans-unit id="74fa9d2e4258275e6ce9c275f9e0e82d2661aeb2" translate="yes" xml:space="preserve">
          <source>The process of turning source code into a machine-usable form. See &lt;b&gt;compile phase&lt;/b&gt;.</source>
          <target state="translated">将源代码转换为机器可用形式的过程。参见&lt;b&gt;编译阶段&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2c86388b6b25502da94ef398d94ba381de4e7acd" translate="yes" xml:space="preserve">
          <source>The program assumes prior understanding of the internal structure of a Zip file. You should have a copy of the Zip APPNOTE file at hand to help understand the output from this program (&lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; for details).</source>
          <target state="translated">该程序假定您事先了解Zip文件的内部结构。您应该手头有一个Zip APPNOTE文件的副本，以帮助理解该程序的输出（有关详细信息，请&lt;a href=&quot;#SEE-ALSO&quot;&gt;参见&amp;ldquo;&lt;/a&gt;另请参阅&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="cc5a52491b0f391cb1ad331e975b3decd008b51b" translate="yes" xml:space="preserve">
          <source>The program can be made to run by &quot;laundering&quot; the tainted value through a regular expression: the second example--which still ignores locale information--runs, creating the file named on its command line if it can.</source>
          <target state="translated">通过正则表达式 &quot;洗白 &quot;污点值,可以使程序运行:第二个例子--仍然忽略locale信息--运行,如果可以的话,在其命令行上创建命名的文件。</target>
        </trans-unit>
        <trans-unit id="71e8e6b13bea2c8688fa8edfd4a4d7df9ffed609" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt; , the log is over.</source>
          <target state="translated">该程序崩溃， &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; S，调用 &lt;code&gt;closelog&lt;/code&gt; ，日志就结束了。</target>
        </trans-unit>
        <trans-unit id="acb249bf3e58472d9c05a98a3d9fd3a22a634ed9" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;die&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt;, the log is over.</source>
          <target state="translated">该程序崩溃， &lt;code&gt;die&lt;/code&gt; S，调用 &lt;code&gt;closelog&lt;/code&gt; ，日志就结束了。</target>
        </trans-unit>
        <trans-unit id="9f6e033c5ffe643ac5235dd0c4de96e8993b109b" translate="yes" xml:space="preserve">
          <source>The program h2xs is the starting point for creating extensions. In later examples we'll see how we can use h2xs to read header files and generate templates to connect to C routines.</source>
          <target state="translated">程序h2xs是创建扩展的起点。在后面的例子中,我们将看到如何使用h2xs读取头文件并生成模板来连接C例程。</target>
        </trans-unit>
        <trans-unit id="6480e775a128a11d00bdb33611f7cc04c69a6a31" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2--7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt; , whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="translated">该程序分为两部分：第2--7行读取输入并建立数据结构，第8-13行分析数据并打印出报告。我们将有一个哈希 &lt;code&gt;%table&lt;/code&gt; ，其键是国家名称，其值是对城市名称数组的引用。数据结构将如下所示：</target>
        </trans-unit>
        <trans-unit id="467c57531a345de9ffd810bfeb5971919e96c865" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2-7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt;, whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="translated">该程序分为两部分：第2-7行读取输入并构建数据结构，第8-13行分析数据并打印出报告。我们将有一个哈希 &lt;code&gt;%table&lt;/code&gt; ，其键是国家/地区名称，其值是对城市名称数组的引用。数据结构将如下所示：</target>
        </trans-unit>
        <trans-unit id="d46a6e0b6bbf3d5823709dce22271813109f1ce6" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures.</source>
          <target state="translated">该程序由一组 &lt;code&gt;regnode&lt;/code&gt; 结构表示，其中一个或多个代表程序的单个Regop。结构 &lt;code&gt;regnode&lt;/code&gt; 是所需的最小结构，并具有与所有其他较大结构共享的字段结构。</target>
        </trans-unit>
        <trans-unit id="3ea55b0618cf1b22588d3366ef69169df7ae378e" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures. (Outside this document, the term &quot;regnode&quot; is sometimes used to mean &quot;regop&quot;, which could be confusing.)</source>
          <target state="translated">该程序由一组 &lt;code&gt;regnode&lt;/code&gt; 结构表示，其中一个或多个代表程序的单个regop。结构 &lt;code&gt;regnode&lt;/code&gt; 是所需的最小结构，并具有与所有其他较大结构共享的字段结构。（在本文档之外，术语&amp;ldquo; regnode&amp;rdquo;有时用于表示&amp;ldquo; regop&amp;rdquo;，这可能会造成混淆。）</target>
        </trans-unit>
        <trans-unit id="135fe1206adbfe007b6735c772853b1eaf66848e" translate="yes" xml:space="preserve">
          <source>The program must take care to ensure that this takes place</source>
          <target state="translated">该计划必须注意确保这种情况的发生。</target>
        </trans-unit>
        <trans-unit id="c1da64105b623d7426e31c12654e36ae7053e949" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="translated">该程序仅花了17多个时钟运行。注意 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 输出的值不同，重要的是始终使用相同的值，并且不要混淆每个值的含义。</target>
        </trans-unit>
        <trans-unit id="453564270c1c0cd5131ab07331c35f9b9398730b" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;time&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="translated">该程序仅花了17多个时钟运行。注意 &lt;code&gt;time&lt;/code&gt; 输出的值不同，重要的是始终使用相同的值，并且不要混淆每个值的含义。</target>
        </trans-unit>
        <trans-unit id="8912a00ba87d6cbf5df35a3207c6a72bfeb3c965" translate="yes" xml:space="preserve">
          <source>The program will halt</source>
          <target state="translated">该程序将停止</target>
        </trans-unit>
        <trans-unit id="267c6b23ea1ed3936b0ecbfc44abd9e2d8aa3502" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;md5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="translated">编程界面易于使用：与CPAN的&lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt;模块中的编程界面相同。因此，如果您的应用程序当前使用&lt;a href=&quot;md5&quot;&gt;Digest :: MD5，&lt;/a&gt;并且您希望SHA的安全性更高，则转换它们很简单。</target>
        </trans-unit>
        <trans-unit id="7b1493356cb4a3eba009f1a11b50de871f482665" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;Digest::MD5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="translated">编程界面易于使用：与CPAN的&lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt;模块中的编程界面相同。因此，如果您的应用程序当前使用&lt;a href=&quot;Digest::MD5&quot;&gt;Digest :: MD5，&lt;/a&gt;并且您希望SHA的安全性更高，则转换它们很简单。</target>
        </trans-unit>
        <trans-unit id="d0f12348b1996ab0ae0eb3467409b46f3ff517e5" translate="yes" xml:space="preserve">
          <source>The programs and documentation in this dist are distributed in the hope that they will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</source>
          <target state="translated">本远端中的程序和文档是以有用为目的而分发的,但不作任何保证,甚至不对某一特定目的的适销性或适用性作默示保证。</target>
        </trans-unit>
        <trans-unit id="3b63891b0a81b9b51c173bac879417506124032c" translate="yes" xml:space="preserve">
          <source>The prompt of the cpan shell can contain the current command number for easier tracking of the session or be a plain string.</source>
          <target state="translated">cpan shell的提示符可以包含当前的命令号,以便于跟踪会话,也可以是一个普通的字符串。</target>
        </trans-unit>
        <trans-unit id="a9cf8b59c024e83e18267b0f8a6518d4ffcc35fc" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt; ) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="translated">EBCDIC中大写字母之前的小写属性甚至被带到拉丁语1 EBCDIC页面上，例如0037和1047。例如，&amp;ldquo;&amp;Euml;&amp;rdquo;（ &lt;code&gt;E WITH DIAERESIS&lt;/code&gt; ，203）在&amp;ldquo;&amp;euml;&amp;rdquo;之前（ &lt;code&gt;e WITH DIAERESIS&lt;/code&gt; ，235） ）在ASCII平台上，但后者（83）在EBCDIC平台上位于前者（115）之前。（精明的读者会注意到，&amp;ldquo;&amp;szlig;&amp;rdquo; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; 字母SHARP S的大写字母只是&amp;ldquo; SS&amp;rdquo;，而&amp;ldquo;&amp;yuml;&amp;rdquo;（小 &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; 的大写字母）和&amp;ldquo; &amp;micro;&amp;rdquo;（ &lt;code&gt;MICRO SIGN&lt;/code&gt; ）不在大写字母中0..255范围，但使用Unicode（在启用Unicode的Perl中）。</target>
        </trans-unit>
        <trans-unit id="d068c61e1d2738a4b949032692f164ea749e79a4" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt;, 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt;, 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt;) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="translated">EBCDIC中大写字母之前的小写属性甚至被带到拉丁语1 EBCDIC页面上，例如0037和1047。例如，&amp;ldquo;&amp;Euml;&amp;rdquo;（ &lt;code&gt;E WITH DIAERESIS&lt;/code&gt; ，203）在&amp;ldquo;&amp;euml;&amp;rdquo;之前（ &lt;code&gt;e WITH DIAERESIS&lt;/code&gt; ，235） ）在ASCII平台上，但后者（83）在EBCDIC平台上比前者（115）早。（精明的读者会注意到，&amp;ldquo;&amp;szlig;&amp;rdquo; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; 字母SHARP S的大写字母只是&amp;ldquo; SS&amp;rdquo;，而&amp;ldquo;&amp;yuml;&amp;rdquo;（小 &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; 的大写字母）和&amp;ldquo; &amp;micro;&amp;rdquo;（ &lt;code&gt;MICRO SIGN&lt;/code&gt; ）不在大写字母中0..255范围，但使用Unicode（在启用Unicode的Perl中）。</target>
        </trans-unit>
        <trans-unit id="09b7c3443c95713bb7f5c3a34ea900a666d3209c" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</source>
          <target state="translated">协议（例如 &lt;code&gt;IPPROTO_TCP&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1d688930b159b0de8e063999fc12f1fc3e668a59" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt;)</source>
          <target state="translated">协议（例如 &lt;code&gt;IPPROTO_TCP&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="16c98cd2a0bd15be4f172d1ada9a2ed6c4ba31c3" translate="yes" xml:space="preserve">
          <source>The protocol also defines several standard &lt;b&gt;translations&lt;/b&gt; which the file can undergo during transfer. These are ASCII, EBCDIC, binary, and byte. ASCII is the default type, and indicates that the sender of files will translate the ends of lines to a standard representation which the receiver will then translate back into their local representation. EBCDIC indicates the file being transferred is in EBCDIC format. Binary (also known as image) format sends the data as a contiguous bit stream. Byte format transfers the data as bytes, the values of which remain the same regardless of differences in byte size between the two machines (in theory - in practice you should only use this if you really know what you're doing). This class does not support the EBCDIC or byte formats, and will default to binary instead if they are attempted.</source>
          <target state="translated">该协议还定义了几种标准&lt;b&gt;翻译&lt;/b&gt;文件在传输过程中会受到的影响。这些是ASCII，EBCDIC，二进制和字节。 ASCII是默认类型，它表示文件的发送方会将行尾转换为标准表示，然后接收方会将其转换回其本地表示。 EBCDIC表示正在传输的文件为EBCDIC格式。二进制（也称为图像）格式将数据作为连续的位流发送。字节格式将数据传输为字节，无论两台计算机之间的字节大小如何，其值都将保持不变（理论上-实际上，只有在真正知道自己在做什么的情况下，才应使用此格式）。此类不支持EBCDIC或字节格式，并且如果尝试使用它们，则默认为二进制。</target>
        </trans-unit>
        <trans-unit id="3e54303b3641a865f35ca39d2a398386ca07567a" translate="yes" xml:space="preserve">
          <source>The prototype CV for a 'my' sub.</source>
          <target state="translated">我的 &quot;子的原型简历。</target>
        </trans-unit>
        <trans-unit id="11a1d81ab8f0f4c68c1c261efa58242791ed97cf" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, come after the signature.</source>
          <target state="translated">原型属性和其他任何属性都在签名之后。</target>
        </trans-unit>
        <trans-unit id="571effb91670d02136e12104ead995a6cc16a1c2" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, must come before the signature. The signature always immediately precedes the block of the subroutine's body.</source>
          <target state="translated">原型属性,以及其他任何属性,必须在签名之前。签名总是紧接在子程序的主体块之前。</target>
        </trans-unit>
        <trans-unit id="420268bbe69f10bd1b6ed7fa6d80a149e32d8a64" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt; .</source>
          <target state="translated">属性中的原型将在从子类中获取的原型之后立即分配给子，这意味着如果同时声明了两者，则传统定义的原型将被忽略。换句话说， &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; 与 &lt;code&gt;sub foo(@){}&lt;/code&gt; 是无法区分的。</target>
        </trans-unit>
        <trans-unit id="a9e026f2d40529605b03137d9a9ed6ef4bb374c7" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt;.</source>
          <target state="translated">属性中的原型将在从子类中获取的原型之后立即分配给子，这意味着如果同时声明了两者，则传统定义的原型将被忽略。换句话说， &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; 与 &lt;code&gt;sub foo(@){}&lt;/code&gt; 是无法区分的。</target>
        </trans-unit>
        <trans-unit id="d6eb998a9749fabedff565e15bacf235434a61b2" translate="yes" xml:space="preserve">
          <source>The provided argument MUST be equal to the string for the validation to pass.</source>
          <target state="translated">提供的参数必须等于要通过验证的字符串。</target>
        </trans-unit>
        <trans-unit id="113c257205a6110f9be3ea8173531d90a26a925b" translate="yes" xml:space="preserve">
          <source>The provided argument MUST equal one of the elements of the array ref for the validation to pass. An array ref can hold all the above values.</source>
          <target state="translated">提供的参数必须等于数组ref中的一个元素,才能通过验证。一个数组 ref 可以容纳上述所有的值。</target>
        </trans-unit>
        <trans-unit id="f0175fe813dc359c6d5d92da9a9b07e142152ec0" translate="yes" xml:space="preserve">
          <source>The provided argument MUST match the regular expression for the validation to pass.</source>
          <target state="translated">提供的参数必须与正则表达式相匹配,才能通过验证。</target>
        </trans-unit>
        <trans-unit id="7028c08ff6edd9122ed07f747d04ab21bb6b6da9" translate="yes" xml:space="preserve">
          <source>The provided subroutine MUST return true in order for the validation to pass and the argument accepted.</source>
          <target state="translated">所提供的子程序必须返回true,以使验证通过并接受参数。</target>
        </trans-unit>
        <trans-unit id="93c41fbabb74d3c7cddc4b5e78899f8faa1b1f17" translate="yes" xml:space="preserve">
          <source>The pseudo-hash feature was an experimental feature introduced in earlier versions of Perl and removed in 5.10.0. A pseudo-hash is an array reference which can be accessed using named keys like a hash. You may run in to some code in the wild which uses it. See the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma for more information.</source>
          <target state="translated">伪哈希功能是在Perl的早期版本中引入的实验性功能，在5.10.0中已删除。伪哈希是一个数组引用，可以使用诸如哈希之类的命名键进行访问。您可能会在野外运行一些使用它的代码。有关更多信息，请参见&lt;a href=&quot;fields&quot;&gt;字段&lt;/a&gt;编译指示。</target>
        </trans-unit>
        <trans-unit id="2c3bf5ebc790603d27cda992131fe6f16a627371" translate="yes" xml:space="preserve">
          <source>The public API must remain consistent, i.e. if a sub-class is overloading addition, the sub-class must use the same name, in this case badd(). The reason for this is that Math::BigInt is optimized to call the object methods directly.</source>
          <target state="translated">公共API必须保持一致,即如果一个子类重载了加法,子类必须使用相同的名称,本例中是badd()。原因是Math::BigInt经过优化,可以直接调用对象方法。</target>
        </trans-unit>
        <trans-unit id="dc2995512c58b9b2e35d09bc546dc5a7fbc84663" translate="yes" xml:space="preserve">
          <source>The purpose of the macro &lt;code&gt;SPAGAIN&lt;/code&gt; is to refresh the local copy of the stack pointer. This is necessary because it is possible that the memory allocated to the Perl stack has been reallocated during the</source>
          <target state="translated">宏 &lt;code&gt;SPAGAIN&lt;/code&gt; 的目的是刷新堆栈指针的本地副本。这是必要的，因为分配给Perl堆栈的内存可能已在重新分配期间重新分配。</target>
        </trans-unit>
        <trans-unit id="211ca4f47d195354704ae118cbe1d64c1c871ea0" translate="yes" xml:space="preserve">
          <source>The purpose of the pragma is to alert users to the status of such a module by issuing a warning that encourages them to install the module from CPAN, so that a future upgrade to a perl which omits the module will not break their code.</source>
          <target state="translated">这个pragma的目的是通过发出警告来提醒用户这种模块的状态,鼓励用户从CPAN中安装该模块,这样将来升级到一个省略了该模块的perl时就不会破坏他们的代码。</target>
        </trans-unit>
        <trans-unit id="b29cd6102fd964c85b9f311d0c28db3fab69123d" translate="yes" xml:space="preserve">
          <source>The purpose of the testing is twofold: one, to help developers fix any problems in their code that crop up because of lack of testing on other platforms; two, to provide users with information about whether a given module works on a given platform.</source>
          <target state="translated">测试的目的有两个:一是帮助开发者修复代码中因缺乏在其他平台上的测试而产生的问题;二是为用户提供某个模块是否在某个平台上工作的信息。</target>
        </trans-unit>
        <trans-unit id="a5dd5b4e9fced711b08542f3e0ab81c18273f9bd" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to document what has been deprecated in Perl, and by which version the deprecated feature will disappear, or, for already removed features, when it was removed.</source>
          <target state="translated">本文档的目的是记录在Perl中哪些功能已经被废弃,以及被废弃的功能将在哪个版本中消失,或者,对于已经被删除的功能,何时被删除。</target>
        </trans-unit>
        <trans-unit id="843821edac19011f1a6d1c830e78298f0013f7a5" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to show you how to call Perl subroutines directly from C, i.e., how to write</source>
          <target state="translated">本文档的目的是告诉你如何从C语言中直接调用Perl子程序,即如何编写</target>
        </trans-unit>
        <trans-unit id="414e7fd5b34fea33393baf5db076f7ff8658e79f" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to provide a wide range of testing utilities. Various ways to say &quot;ok&quot; with better diagnostics, facilities to skip tests, test future features and compare complicated data structures. While you can do almost anything with a simple &lt;code&gt;ok()&lt;/code&gt; function, it doesn't provide good diagnostic output.</source>
          <target state="translated">该模块的目的是提供广泛的测试实用程序。具有更好的诊断能力的各种说法都可以，可以跳过测试，测试将来的功能并比较复杂的数据结构。尽管您可以使用简单的 &lt;code&gt;ok()&lt;/code&gt; 函数执行几乎所有操作，但它不能提供良好的诊断输出。</target>
        </trans-unit>
        <trans-unit id="9bfc8ef428f97c3f3e1176a68cf8e1112929bebf" translate="yes" xml:space="preserve">
          <source>The purpose, scope and target applications of your module</source>
          <target state="translated">您的模块的目的、范围和目标应用。</target>
        </trans-unit>
        <trans-unit id="cb81c6a18976d12ebe998a0a0b9af8a1bf213151" translate="yes" xml:space="preserve">
          <source>The pyramids.</source>
          <target state="translated">金字塔。</target>
        </trans-unit>
        <trans-unit id="ddc9dd67da090624c445edfafa6830e5bccd4e64" translate="yes" xml:space="preserve">
          <source>The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful, and then document what you wrote so you don&amp;rsquo;t have to answer so many questions about it. Hence, the first great virtue of a programmer. Also hence, this book. See also &lt;b&gt;impatience&lt;/b&gt; and &lt;b&gt;hubris&lt;/b&gt;.</source>
          <target state="translated">使您全力以赴降低总能耗的质量。它使您可以编写其他人会发现有用的省力程序，然后记录您所写的内容，因此您不必回答那么多问题。因此，程序员的第一大美德。因此，这本书也是。另请参见&lt;b&gt;不耐烦&lt;/b&gt;和&lt;b&gt;自大&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="52d7089e85ac35a7092bc58942f32bee7ca90b8d" translate="yes" xml:space="preserve">
          <source>The question of string equivalence turns somewhat complicated in Unicode: what do you mean by &quot;equal&quot;?</source>
          <target state="translated">字符串等价的问题在Unicode中变得有些复杂:什么叫 &quot;等价&quot;?</target>
        </trans-unit>
        <trans-unit id="f2a24b3b2648553142b8c5a0c4598996a73f792a" translate="yes" xml:space="preserve">
          <source>The question remains on when the SVs which are</source>
          <target state="translated">问题仍然是,什么时候才会有特别提款权?</target>
        </trans-unit>
        <trans-unit id="099c0ce39a19f948a86d0ea40fc49e8ea2b14385" translate="yes" xml:space="preserve">
          <source>The question, of course, is why would you do something like this? Why create a semaphore with a starting count that's not one, or why decrement or increment it by more than one? The answer is resource availability. Many resources that you want to manage access for can be safely used by more than one thread at once.</source>
          <target state="translated">当然,问题是,你为什么要做这样的事情?为什么要创建一个起始数不是1的旗语,或者为什么要将其递减或递增超过1?答案是资源可用性。许多你想管理访问的资源可以被多个线程同时安全使用。</target>
        </trans-unit>
        <trans-unit id="7e4709a385e818a7adc04721b36836ff38439abe" translate="yes" xml:space="preserve">
          <source>The quick answer is because they are easy to implement yourself. The long answer is that to write these in such a way that multiple platforms are supported correctly would just require too much code. Below are some examples how you can implement these yourself.</source>
          <target state="translated">快速的答案是,因为它们很容易自己实现。长的答案是,如果要以正确支持多个平台的方式来写这些东西,就需要太多的代码。下面是一些你如何自己实现这些的例子。</target>
        </trans-unit>
        <trans-unit id="551d1aa8a1248eaf53c1cd9d606d72ab7488cd21" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty method only works well when you don't plan to leave the commented code in the source. If a Pod parser comes along, your multiline comment is going to show up in the Pod translation. A better way hides it from Pod parsers as well.</source>
          <target state="translated">这种快刀斩乱麻的方法只有在你不打算在源码中留下注释的时候才好用,如果有Pod解析器出现,你的多行注释就会显示在Pod翻译中。如果Pod解析器出现,你的多行注释就会出现在Pod翻译中。一个更好的方法是把它也隐藏起来,不让Pod解析器发现。</target>
        </trans-unit>
        <trans-unit id="a41d7294035834639b17968992ffda16ae85e9a1" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt; , ending the Pod section:</source>
          <target state="translated">注释掉多行Perl的一种简单方法是用Pod指令包围这些行。您必须将这些指令放在行的开头，以及Perl期望有新语句的位置（因此，不要放在诸如 &lt;code&gt;#&lt;/code&gt; 注释之类的语句中间）。您以 &lt;code&gt;=cut&lt;/code&gt; 结束注释，从而结束Pod部分：</target>
        </trans-unit>
        <trans-unit id="d90a105b257205ce48226d803e75858a07587fa6" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt;, ending the Pod section:</source>
          <target state="translated">注释掉多行Perl的一种简单方法是用Pod指令将这些行括起来。您必须将这些指令放在行的开头以及Perl希望有新语句的位置（因此，不要放在诸如 &lt;code&gt;#&lt;/code&gt; 注释的语句中间）。您以 &lt;code&gt;=cut&lt;/code&gt; 结束注释，从而结束Pod部分：</target>
        </trans-unit>
        <trans-unit id="0c2f3594848e5558e5b1bcd7932b24c116883439" translate="yes" xml:space="preserve">
          <source>The quotient is always the greatest integer less than or equal to the real-valued quotient of the two operands, and the remainder (when it is non-zero) always has the same sign as the second operand; so, for example,</source>
          <target state="translated">商数总是小于或等于两个操作数的实值商的最大整数,余数(当它是非零时)总是与第二个操作数具有相同的符号;所以,例如。</target>
        </trans-unit>
        <trans-unit id="04db20aec07e3c7b83de9b23243f0bb2ef9f279e" translate="yes" xml:space="preserve">
          <source>The random characters are provided by File::Temp and ensure that each module's individual build directory is unique. This makes running CPAN.pm in concurrent processes simultaneously safe.</source>
          <target state="translated">随机字符由File::Temp提供,确保每个模块的单独构建目录是唯一的。这使得在并发进程中同时运行CPAN.pm是安全的。</target>
        </trans-unit>
        <trans-unit id="054e3d7058644b114207f253c83eb2c8a141a8e1" translate="yes" xml:space="preserve">
          <source>The range operator (in list context) makes use of the magical auto-increment algorithm if the operands are strings. You can say</source>
          <target state="translated">如果操作数是字符串,那么范围操作符(在列表上下文中)就会使用神奇的自动递增算法。你可以说</target>
        </trans-unit>
        <trans-unit id="4828534433b64aecd95537d37d705a006ad5851e" translate="yes" xml:space="preserve">
          <source>The range operator &lt;code&gt;..&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">范围运算符 &lt;code&gt;..&lt;/code&gt; 不能重载。</target>
        </trans-unit>
        <trans-unit id="bc508fe7a659eeced29e856ebc7b8d62470c6bbb" translate="yes" xml:space="preserve">
          <source>The range operator also works on strings, using the magical auto-increment, see below.</source>
          <target state="translated">范围运算符也适用于字符串,使用神奇的自动增量,见下文。</target>
        </trans-unit>
        <trans-unit id="31d3e334c25d2382911ee65d3fae61de81e23584" translate="yes" xml:space="preserve">
          <source>The range operator in list context can make use of the magical auto-increment algorithm if both operands are strings, subject to the following rules:</source>
          <target state="translated">如果两个操作数都是字符串,列表上下文中的范围操作符可以使用神奇的自动递增算法,但要符合以下规则。</target>
        </trans-unit>
        <trans-unit id="e7f8ca3eb25d07981f64e697003d81f247478aa9" translate="yes" xml:space="preserve">
          <source>The range operator is &quot;..&quot;, not comma. The comma operator works as in C.</source>
          <target state="translated">范围运算符是&quot;.&quot;,不是逗号。逗号运算符的工作原理和C语言一样。</target>
        </trans-unit>
        <trans-unit id="6b43593ef7e3f96c529ec6f6490c77d15e8ee949" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt; , rather than comma.</source>
          <target state="translated">范围运算符是 &lt;code&gt;...&lt;/code&gt; ，而不是逗号。</target>
        </trans-unit>
        <trans-unit id="6702b09bbe69f958fa5f9869c6ae81b0c789760d" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt;, rather than comma.</source>
          <target state="translated">范围运算符是 &lt;code&gt;...&lt;/code&gt; ，而不是逗号。</target>
        </trans-unit>
        <trans-unit id="41fb6d64bc39d2dbbf811ff985ded944bd6951e6" translate="yes" xml:space="preserve">
          <source>The rationale for inclusion in this module is that the function performs some work for which an XS implementation is essential because it cannot be implemented in Pure Perl, and which is sufficiently-widely used across CPAN that its popularity warrants inclusion in a core module, which this is.</source>
          <target state="translated">在这个模块中包含的理由是,这个函数执行了一些工作,而XS的实现是必不可少的,因为它无法在Pure Perl中实现,而且它在CPAN中被广泛使用,它的流行程度证明它有理由被包含在一个核心模块中,这就是核心模块。</target>
        </trans-unit>
        <trans-unit id="272be5d09f375bcf2f8787674ae6b79aa38f8abf" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="translated">要求这样做的理由是不破坏依赖于Unicode出现之前工作方式的较旧程序。这些较旧的程序仅了解ASCII字符集，因此对于其他字符可能无法正常工作。当字符串以UTF-8编码时，Perl假定程序已准备好处理Unicode，但是当字符串不是时，Perl假定只需要ASCII，因此那些不是ASCII字符的字符就不再公认它们在Unicode中将是什么。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 告诉Perl将所有字符都视为Unicode，无论字符串是否使用UTF-8编码，都可以避免此问题。</target>
        </trans-unit>
        <trans-unit id="cd600fcbf1a6b70419da39d25dfcf62c3af89b3f" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="translated">要求这样做的理由是不破坏依赖于Unicode出现之前工作方式的较旧程序。这些较旧的程序仅了解ASCII字符集，因此对于其他字符可能无法正常工作。当字符串以UTF-8编码时，Perl假定程序已准备好处理Unicode，但是当字符串不是时，Perl假定只需要ASCII，因此那些不是ASCII字符的字符就不再知道它们在Unicode中的含义 &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; 告诉Perl将所有字符都视为Unicode，无论字符串是否使用UTF-8编码，都可以避免此问题。</target>
        </trans-unit>
        <trans-unit id="062d7f6e6f9ffa42523f91b3b98af5b6e21dddc1" translate="yes" xml:space="preserve">
          <source>The raw floppy disk. Doesn't work under Windows 95. This allows you to read or write raw sectors of the floppy disk and to use &lt;code&gt;DeviceIoControl&lt;/code&gt; to perform miscellaneous queries and operations to the floppy disk or drive.</source>
          <target state="translated">原始软盘。在Windows 95下不起作用。这使您可以读取或写入软盘的原始扇区，并可以使用 &lt;code&gt;DeviceIoControl&lt;/code&gt; 对软盘或驱动器执行其他查询和操作。</target>
        </trans-unit>
        <trans-unit id="62a00a9112198d60e9e6e148f4efbf8b5c8bde2f" translate="yes" xml:space="preserve">
          <source>The raw original L&amp;lt;...&amp;gt; content, before text is split on &quot;|&quot;, &quot;/&quot;, etc, and before E&amp;lt;...&amp;gt; codes are expanded.</source>
          <target state="translated">原始原始L &amp;lt;...&amp;gt;内容，在&amp;ldquo; |&amp;rdquo;，&amp;ldquo; /&amp;rdquo;等上分割文本之前，以及在扩展E &amp;lt;...&amp;gt;代码之前。</target>
        </trans-unit>
        <trans-unit id="16f6921cb27bb9d796f9843804daa8d9f88db314" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;), and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="translated">只读魔术变量 &lt;code&gt;${^UNICODE}&lt;/code&gt; 反映此设置的数值。此变量在Perl启动期间设置，此后为只读。如果需要运行时效果，请使用三个参数的open（）（请参见&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;），两个参数的binmode（）（请参见&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;）和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译指示（请参见&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7133d99787afc8bed88333155f330e0814f3badc" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt;), and the &lt;code&gt;open&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="translated">只读魔术变量 &lt;code&gt;${^UNICODE}&lt;/code&gt; 反映此设置的数值。此变量在Perl启动期间设置，此后为只读。如果需要运行时效果，请使用三个参数的open（）（请参阅&lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc中的&amp;ldquo; open&amp;rdquo;&lt;/a&gt;），两个参数的binmode（）（请参阅&lt;a href=&quot;perlfunc#binmode&quot;&gt;perlfunc中的&amp;ldquo; binmode&amp;rdquo;&lt;/a&gt;）和 &lt;code&gt;open&lt;/code&gt; 编译指示（请参见&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8ac185b6e70958a0bc2daae47b4a77ca571d1fad" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">这个过程的真正向导。如果您使用的计算机同时支持多个组的成员资格，请使用空格将您所在的组列表分开。第一个数字是 &lt;code&gt;getgid()&lt;/code&gt; 返回的数字，随后的是 &lt;code&gt;getgroups()&lt;/code&gt; 返回的数字，其中一个可能是与第一个数字相同。</target>
        </trans-unit>
        <trans-unit id="1b0d46bf2b89fe3b91282dbaf19dbfd7a631baf9" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt;, and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt;, one of which may be the same as the first number.</source>
          <target state="translated">这个过程的真正向导。如果您使用的机器同时支持多个组的成员资格，请使用空格将您所在的组列表分开。第一个数字是 &lt;code&gt;getgid()&lt;/code&gt; 返回的数字，随后的是 &lt;code&gt;getgroups()&lt;/code&gt; 返回的数字，其中一个可能是与第一个数字相同。</target>
        </trans-unit>
        <trans-unit id="c41410f8fa129356669d6ff84f5e22cd64e4d0cb" translate="yes" xml:space="preserve">
          <source>The real sequence number of the OP, as a regular number and not adjusted to be relative to the start of the real program. (This will generally be a fairly large number because all of &lt;b&gt;B::Concise&lt;/b&gt; is compiled before your program is).</source>
          <target state="translated">OP的实际序号，作为常规编号，并且未调整为相对于实际程序的开始。（这通常是一个相当大的数字，因为所有&lt;b&gt;B :: Concise&lt;/b&gt;都在程序编写之前进行了编译）。</target>
        </trans-unit>
        <trans-unit id="520aa3cfc6d3d06d2079bcf3cd80538cdc94136b" translate="yes" xml:space="preserve">
          <source>The real time timing is done using time(2) and the granularity is therefore only one second.</source>
          <target state="translated">实时计时是用time(2)来完成的,因此颗粒度只有一秒。</target>
        </trans-unit>
        <trans-unit id="000f9aa1d39e9791c956bd280884dcab10bddcf9" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="translated">此过程的真正uid。您可以使用 &lt;code&gt;POSIX::setuid()&lt;/code&gt; 同时更改实际uid和有效uid 。由于对 &lt;code&gt;$&amp;lt;&lt;/code&gt; 更改需要系统调用，因此请检查 &lt;code&gt;$!&lt;/code&gt; 进行更改后尝试检测任何可能的错误。</target>
        </trans-unit>
        <trans-unit id="2ac048e62e66a7879f9411bea5e557339bb43fff" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt;. Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="translated">此过程的真正uid。您可以使用 &lt;code&gt;POSIX::setuid()&lt;/code&gt; 同时更改实际uid和有效uid 。由于对 &lt;code&gt;$&amp;lt;&lt;/code&gt; 更改需要系统调用，因此请检查 &lt;code&gt;$!&lt;/code&gt; 进行更改后尝试检测任何可能的错误。</target>
        </trans-unit>
        <trans-unit id="226998a781d1d6550060a07be6fe5dd8d2b4b4b4" translate="yes" xml:space="preserve">
          <source>The real work is done in the standard typemap.</source>
          <target state="translated">真正的工作是在标准类型图中完成的。</target>
        </trans-unit>
        <trans-unit id="c08e193bbc2bcd92c562519697a3487f212bcddb" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt; , but consider this situation:</source>
          <target state="translated">存在 &lt;code&gt;encode_language_tag&lt;/code&gt; 的原因是因为不同的语言标签可能表示相同的语言。通常可以使用 &lt;code&gt;same_language_tag&lt;/code&gt; 进行处理，但请考虑以下情况：</target>
        </trans-unit>
        <trans-unit id="3ce46cd4af70310d3ca26a396ea6fdf7fb3672f3" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt;, but consider this situation:</source>
          <target state="translated">存在 &lt;code&gt;encode_language_tag&lt;/code&gt; 的原因是因为不同的语言标签可能表示相同的语言。通常可以使用 &lt;code&gt;same_language_tag&lt;/code&gt; 进行处理，但请考虑以下情况：</target>
        </trans-unit>
        <trans-unit id="ca772eb153fd56cb7e89f09b86319ec24565520e" translate="yes" xml:space="preserve">
          <source>The reason I said &quot;in this instance&quot; is because that</source>
          <target state="translated">我之所以说 &quot;在这种情况下&quot;,是因为这</target>
        </trans-unit>
        <trans-unit id="739ee83789116c83fd6d7b4456cdd5e4f5143663" translate="yes" xml:space="preserve">
          <source>The reason for not checking the return value from print() is because of pipe buffering; physical writes are delayed. That won't blow up until the close, and it will blow up with a SIGPIPE. To catch it, you could use this:</source>
          <target state="translated">不检查print()的返回值是因为管道缓冲,物理写入是有延迟的。那要到关闭的时候才会炸开,而且会炸开一个SIGPIPE。要想抓住它,可以用这个办法。</target>
        </trans-unit>
        <trans-unit id="5243164bf937a2da41254af85f8953f57eda8b63" translate="yes" xml:space="preserve">
          <source>The reason for the bailout.</source>
          <target state="translated">救市的原因。</target>
        </trans-unit>
        <trans-unit id="ff2ad92ed56d2b83c1783a3daf037c2fcef9e124" translate="yes" xml:space="preserve">
          <source>The reason for the exception.</source>
          <target state="translated">异常的原因。</target>
        </trans-unit>
        <trans-unit id="58e74d3011543f0cacc6e865a92179ab3feabba8" translate="yes" xml:space="preserve">
          <source>The reason for the skip, todo etc. See &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; for more details.</source>
          <target state="translated">跳过，待办事项等的原因。有关更多详细信息，请参见&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3e75d2f4213b8c35d2937b292cccac3d8a1e38d" translate="yes" xml:space="preserve">
          <source>The reason for this is that CPAN does not know the dependencies of all modules when it starts out. To decide about the additional items to install, it just uses data found in the META.yml file or the generated Makefile. An undetected missing piece breaks the process. But it may well be that your Bundle installs some prerequisite later than some depending item and thus your second try is able to resolve everything. Please note, CPAN.pm does not know the dependency tree in advance and cannot sort the queue of things to install in a topologically correct order. It resolves perfectly well &lt;b&gt;if&lt;/b&gt; all modules declare the prerequisites correctly with the PREREQ_PM attribute to MakeMaker or the &lt;code&gt;requires&lt;/code&gt; stanza of Module::Build. For bundles which fail and you need to install often, it is recommended to sort the Bundle definition file manually.</source>
          <target state="translated">原因是CPAN在启动时并不知道所有模块的依赖性。要决定要安装的其他项目，它仅使用在META.yml文件或生成的Makefile中找到的数据。未检测到的丢失片段会中断该过程。但是，很可能是您的捆绑软件在安装某些先决条件之后，再安装某些依赖项，因此您的第二次尝试就能解决所有问题。请注意，CPAN.pm事先不知道依赖关系树，因此无法按拓扑正确的顺序对要安装的事物队列进行排序。它解决得很好&lt;b&gt;，如果&lt;/b&gt;所有模块与PREREQ_PM属性MakeMaker的或正确申报的先决条件的 &lt;code&gt;requires&lt;/code&gt; Module :: Build的节。对于失败的捆绑软件，您需要经常安装，建议手动对捆绑软件定义文件进行排序。</target>
        </trans-unit>
        <trans-unit id="9dfe6b3d7e7af99fa8c5c069ac28ca23f9e16764" translate="yes" xml:space="preserve">
          <source>The reason for this is that the &lt;a href=&quot;version#numify%28%29&quot;&gt;numify()&lt;/a&gt; operator will turn &quot;v1.0&quot; into the equivalent string &quot;1.000000&quot;. Forcing the outer version object to &lt;a href=&quot;version#normal%28%29&quot;&gt;normal()&lt;/a&gt; form will display the mathematically equivalent &quot;v1.0.0&quot;.</source>
          <target state="translated">原因是&lt;a href=&quot;version#numify%28%29&quot;&gt;numify（）&lt;/a&gt;运算符会将&amp;ldquo; v1.0&amp;rdquo;转换为等效的字符串&amp;ldquo; 1.000000&amp;rdquo;。将外部版本对象强制为&lt;a href=&quot;version#normal%28%29&quot;&gt;normal（）&lt;/a&gt;形式将显示数学上等效的&amp;ldquo; v1.0.0&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5fa379384b7d494ede930080ac4d01947c2521a8" translate="yes" xml:space="preserve">
          <source>The reason for this unusability is that a fundamental assumption of Perl is that the characters it cares about for parsing and lexical analysis are the same whether or not the text is in UTF-8. For example, Perl expects the character &lt;code&gt;&quot;[&quot;&lt;/code&gt; to have the same representation, no matter if the string containing it (or program text) is UTF-8 encoded or not. To ensure this, Perl adapts UTF-EBCDIC to the particular code page so that all characters it expects to be UTF-8 invariant are in fact UTF-8 invariant. This means that text generated on a computer running one version of Perl's UTF-EBCDIC has to be translated to be intelligible to a computer running another.</source>
          <target state="translated">之所以无法使用，是因为Perl的基本假设是，无论文本是否使用UTF-8，它关心的用于分析和词法分析的字符都是相同的。例如，Perl期望字符 &lt;code&gt;&quot;[&quot;&lt;/code&gt; 具有相同的表示形式，无论包含它的字符串（或程序文本）是否经过UTF-8编码。为了确保这一点，Perl使UTF-EBCDIC适应特定的代码页，以便它期望为UTF-8不变的所有字符实际上都是UTF-8不变的。这意味着在运行一种版本的Perl UTF-EBCDIC的计算机上生成的文本必须经过翻译才能理解为运行另一种版本的计算机。</target>
        </trans-unit>
        <trans-unit id="148e8f8b4033e043ed0349ade3e3972ed042dff2" translate="yes" xml:space="preserve">
          <source>The reason is that Encode::Guess guesses encoding by trial and error. It first splits $data into lines and tries to decode the line for each suspect. It keeps it going until all but one encoding is eliminated out of suspects list. ISO-8859 series is just too successful for most cases (because it fills almost all code points in \x00-\xff).</source>
          <target state="translated">原因是 Encode::Guess 通过试错来猜测编码。它首先将$data分割成一行行,并尝试为每个嫌疑人解码。它一直持续下去,直到除了一个编码之外,所有的编码都被排除在嫌疑人列表之外。ISO-8859系列在大多数情况下都太成功了(因为它几乎填满了所有的编码点\x00-\xff)。</target>
        </trans-unit>
        <trans-unit id="94742df1b378e1ee0c32933e905c9b3866f15f37" translate="yes" xml:space="preserve">
          <source>The reason is that variable interpolation and code expressions together pose a security risk. The combination is dangerous because many programmers who write search engines often take user input and plug it directly into a regexp:</source>
          <target state="translated">原因是变量插值和代码表达式一起构成了安全风险。这种组合是很危险的,因为很多编写搜索引擎的程序员经常把用户的输入直接插入到regexp中。</target>
        </trans-unit>
        <trans-unit id="c8fa70ef72504bbb3f7d6986506b4705b0ceb70a" translate="yes" xml:space="preserve">
          <source>The reason is that vendor encoding is usually a superset of national standard so it becomes too ambiguous for most cases.</source>
          <target state="translated">原因是厂商的编码通常是国家标准的超集,所以对于大多数情况下,它变得过于模糊。</target>
        </trans-unit>
        <trans-unit id="76e332a13c138bbbc50c17d9967b9928970c16a2" translate="yes" xml:space="preserve">
          <source>The reason it isn't quite a drop-in replacement is actually an advantage. The only difference is that it returns &lt;code&gt;const char *&lt;/code&gt;, whereas plain &lt;code&gt;nl_langinfo()&lt;/code&gt; returns &lt;code&gt;char *&lt;/code&gt;, but you are (only by documentation) forbidden to write into the buffer. By declaring this &lt;code&gt;const&lt;/code&gt;, the compiler enforces this restriction, so if it is violated, you know at compilation time, rather than getting segfaults at runtime.</source>
          <target state="translated">它不是直接替代的原因实际上是一个优势。唯一的区别是它返回 &lt;code&gt;const char *&lt;/code&gt; ，而普通的 &lt;code&gt;nl_langinfo()&lt;/code&gt; 返回 &lt;code&gt;char *&lt;/code&gt; ，但是（仅根据文档）您被禁止写入缓冲区。通过声明此 &lt;code&gt;const&lt;/code&gt; ，编译器将强制执行此限制，因此，如果违反此限制，则可以在编译时知道，而不必在运行时获取segfaults。</target>
        </trans-unit>
        <trans-unit id="2e0f1d70e28ee48bb2440f0dfad9e2b39b29922f" translate="yes" xml:space="preserve">
          <source>The reason that &lt;code&gt;host $failed_ack_host&lt;/code&gt; did not receive a valid ACK. Useful to find out why when &lt;code&gt;ack($fail_ack_host)&lt;/code&gt; returns a false value.</source>
          <target state="translated">究其原因是 &lt;code&gt;host $failed_ack_host&lt;/code&gt; 没有收到有效的ACK。有助于找出为什么 &lt;code&gt;ack($fail_ack_host)&lt;/code&gt; 返回错误值的原因。</target>
        </trans-unit>
        <trans-unit id="fedf7056008fbc98297422a200d9b784c0b8db45" translate="yes" xml:space="preserve">
          <source>The reason that doesn't do what you want is because assigning a named array like that to a scalar is taking an array in scalar context, which means just counts the number of elements in @tmp.</source>
          <target state="translated">之所以不能如你所愿,是因为把这样一个命名的数组赋给一个标量,就是在标量上下文中取一个数组,也就是只计算@tmp中的元素数。</target>
        </trans-unit>
        <trans-unit id="550ff1bc08b0298c35cdd00d235a478cadb820d7" translate="yes" xml:space="preserve">
          <source>The reason that host $failed_ack_host did not receive a valid ACK. Useful to find out why when ack( $fail_ack_host ) returns a false value.</source>
          <target state="translated">主机$failed_ack_host没有收到有效ACK的原因。当ack($fail_ack_host )返回一个false值时,可以用来找出原因。</target>
        </trans-unit>
        <trans-unit id="761e66631890fba3f96026c5ab632825150c6b23" translate="yes" xml:space="preserve">
          <source>The reason that using gettext runs into walls (as in the above second-person horror story) is that you're trying to use a string (or worse, a choice among a bunch of strings) to do what you really need a function for -- which is futile. Preforming (s)printf interpolation on the strings which you get back from gettext does allow you to do</source>
          <target state="translated">使用 gettext 碰壁的原因 (就像上面的第二人称恐怖故事一样),是因为你试图使用一个字符串 (或者更糟的是,在一堆字符串中进行选择)来做你真正需要的函数 --这是徒劳的。对从gettext中得到的字符串进行(s)printf插值,确实可以让你做以下事情</target>
        </trans-unit>
        <trans-unit id="251bb3c15e15e0ec21516300833b60efe1125c75" translate="yes" xml:space="preserve">
          <source>The reason this function has &quot;_strictly&quot; in its name is that when you're processing an Accept-Language list according to the RFCs, if you interpret the RFCs quite strictly, then you would use implicate_supers_strictly, but for normal use (i.e., common-sense use, as far as I'm concerned) you'd use implicate_supers.</source>
          <target state="translated">这个函数名称中带有&quot;_strictly &quot;的原因是,当你根据RFCs处理Accept-Language列表时,如果你对RFCs的解释相当严格,那么你会使用 implicate_supers_strictly,但对于正常使用(即常识性使用,就我而言),你会使用 implicate_supers。</target>
        </trans-unit>
        <trans-unit id="00e0d83a9d5edf83f32ea0d0701c8b2f4b38f236" translate="yes" xml:space="preserve">
          <source>The reason this is considered to be only partially implemented is that Perl has &lt;a href=&quot;perlrebackslash#%5Cb%7Blb%7D&quot;&gt;&lt;code&gt;qr/\b{lb}/&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt;&lt;/code&gt; that are conformant with &lt;a href=&quot;https://www.unicode.org/reports/tr14&quot;&gt;UAX#14 &quot;Unicode Line Breaking Algorithm&quot;&lt;/a&gt;. The regular expression construct provides default behavior, while the heavier-weight module provides customizable line breaking.</source>
          <target state="translated">认为仅部分实现了该功能的原因是Perl具有符合&lt;a href=&quot;https://www.unicode.org/reports/tr14&quot;&gt;UAX＃14&amp;ldquo; Unicode换行算法&amp;rdquo;的&lt;/a&gt;&lt;a href=&quot;perlrebackslash#%5Cb%7Blb%7D&quot;&gt; &lt;code&gt;qr/\b{lb}/&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;&lt;a href=&quot;Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt;&lt;/code&gt; 。正则表达式构造提供默认行为，而较重的模块提供可自定义的换行符。</target>
        </trans-unit>
        <trans-unit id="e1005d9c83a9fa9fcbc88e4d2084838b8de52293" translate="yes" xml:space="preserve">
          <source>The reason this is necessary is that the area of the Perl stack which held them will very likely have been overwritten by something else by the time control returns from</source>
          <target state="translated">之所以需要这样做,是因为当控制从</target>
        </trans-unit>
        <trans-unit id="7f8610d66bd9a8ef9ccb75cedd8c737641eb770d" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because RFC 1951 content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">之所以不是默认行为,是因为RFC 1951内容只能通过尝试解压来检测。这个过程很容易出错,可能会导致误报。</target>
        </trans-unit>
        <trans-unit id="19bd78bd51bc1c56b13d7881beac1baa5b73fb31" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because lzma_alone content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">这不是默认行为的原因是lzma_alone内容只能通过尝试解压来检测。这个过程很容易出错,可能会导致误报。</target>
        </trans-unit>
        <trans-unit id="28f02f8a8e5a76ee5006992d613d3802d772737a" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt; , it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt; . This is particularly true for these cases:</source>
          <target state="translated">究其原因，这是不对的是，由你来使用指针的时候 &lt;code&gt;rememberSub&lt;/code&gt; 在 &lt;code&gt;CallSavedSub1&lt;/code&gt; ，它可能会或可能不会仍然指的是被记录在Perl子 &lt;code&gt;SaveSub1&lt;/code&gt; 。在以下情况下尤其如此：</target>
        </trans-unit>
        <trans-unit id="e2bf2d952027d4fe995c4250ed0910c8a499fa98" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt;, it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt;. This is particularly true for these cases:</source>
          <target state="translated">究其原因，这是不对的是，由你来使用指针的时候 &lt;code&gt;rememberSub&lt;/code&gt; 在 &lt;code&gt;CallSavedSub1&lt;/code&gt; ，它可能会或可能不会仍然指的是被记录在Perl子 &lt;code&gt;SaveSub1&lt;/code&gt; 。在以下情况下尤其如此：</target>
        </trans-unit>
        <trans-unit id="1fc61e22be627df80a7651746e52decec2ded90a" translate="yes" xml:space="preserve">
          <source>The reasons for most important skipped tests are:</source>
          <target state="translated">大多数重要的跳过测试的原因是:</target>
        </trans-unit>
        <trans-unit id="cc1622b786a9a5b8c43f01f8734a1a12e356f528" translate="yes" xml:space="preserve">
          <source>The recognized bright background color attributes (colors 8 to 15) are:</source>
          <target state="translated">公认的亮色背景色属性(颜色8至15)为:。</target>
        </trans-unit>
        <trans-unit id="6c5d4a5f4c9a09fda354809420b2cbe2f30c42f0" translate="yes" xml:space="preserve">
          <source>The recognized normal background color attributes (colors 0 to 7) are:</source>
          <target state="translated">认可的正常背景色属性(颜色0至7)为:。</target>
        </trans-unit>
        <trans-unit id="4a93814d53d2a583e73a218be86053c6699847f6" translate="yes" xml:space="preserve">
          <source>The recognized normal foreground color attributes (colors 0 to 7) are:</source>
          <target state="translated">识别的普通前景色属性(颜色0至7)为:。</target>
        </trans-unit>
        <trans-unit id="c8d8fb33b8f8ad299c896b38af940448a2194ca3" translate="yes" xml:space="preserve">
          <source>The recognized options to new() are as follows. All options take a single argument.</source>
          <target state="translated">new()的公认选项如下。所有选项都只取一个参数。</target>
        </trans-unit>
        <trans-unit id="1e562f76f9cdb0ef2aab453d2c38556cc6a6334d" translate="yes" xml:space="preserve">
          <source>The recommended compiler to use in Tru64 is the native C compiler. The native compiler produces much faster code (the speed difference is noticeable: several dozen percentages) and also more correct code: if you are considering using the GNU C compiler you should use at the very least the release of 2.95.3 since all older gcc releases are known to produce broken code when compiling Perl. One manifestation of this brokenness is the lib/sdbm test dumping core; another is many of the op/regexp and op/pat, or ext/Storable tests dumping core (the exact pattern of failures depending on the GCC release and optimization flags).</source>
          <target state="translated">建议在Tru64中使用的编译器是本地C编译器。原生编译器产生的代码要快得多(速度上的差异很明显:几十个百分点),而且代码也更正确:如果您考虑使用 GNU C 编译器,您至少应该使用 2.95.3 版本,因为所有旧的 gcc 版本在编译 Perl 时都会产生破损的代码。这种破绽的一个表现是lib/sdbm测试转储核心;另一个表现是许多op/regexp和op/pat,或者ext/Storable测试转储核心(具体的失败模式取决于gcc版本和优化标志)。</target>
        </trans-unit>
        <trans-unit id="a954751580ed0f6e74f6ae52a458e3decc2b6782" translate="yes" xml:space="preserve">
          <source>The recommended order of sections in Perl module documentation is:</source>
          <target state="translated">在Perl模块文档中,推荐的章节顺序是。</target>
        </trans-unit>
        <trans-unit id="da2bd70489cefb603292ce8b5cfe4c6cae04aaf7" translate="yes" xml:space="preserve">
          <source>The recommended way to build Perl for the OS/400 PASE is to build the Perl 5 source code (release 5.8.1 or later) under AIX.</source>
          <target state="translated">为OS/400 PASE构建Perl的推荐方法是在AIX下构建Perl 5源代码(5.8.1或更高版本)。</target>
        </trans-unit>
        <trans-unit id="e06b04ad5d41fce493c0b00ecf1ca37dfa5afcff" translate="yes" xml:space="preserve">
          <source>The red() and green() functions would be similar. To create these, we'll assign a closure to a typeglob of the name of the function we're trying to build.</source>
          <target state="translated">red()和green()函数也类似。为了创建这两个函数,我们将为我们试图构建的函数名称的类型球分配一个闭包。</target>
        </trans-unit>
        <trans-unit id="f9a173256f222e6807faedf390f953793a1d344d" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; will be decremented at the end of</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 的引用数将在末尾递减</target>
        </trans-unit>
        <trans-unit id="1d461f380b420e2f92a59ecbfaa16c7256f214ff" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; would be decremented at the end of</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 的引用计数将在末尾减少</target>
        </trans-unit>
        <trans-unit id="aa0554de1d883a744516c47aa9649afa91c2844b" translate="yes" xml:space="preserve">
          <source>The reference count for each specified &lt;code&gt;SV*&lt;/code&gt; parameter is decremented.</source>
          <target state="translated">每个指定的 &lt;code&gt;SV*&lt;/code&gt; 参数的参考计数都会减少。</target>
        </trans-unit>
        <trans-unit id="2beb795bee8f23385c682524158dfa3883714ef0" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name list.</source>
          <target state="translated">垫名列表的引用次数。</target>
        </trans-unit>
        <trans-unit id="ed87a4c5aaea6eeced4317ed59578fe0847b6b0f" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name.</source>
          <target state="translated">垫名的引用次数。</target>
        </trans-unit>
        <trans-unit id="0f3b4f395e70b832ec180500f62bfe30abfdf04c" translate="yes" xml:space="preserve">
          <source>The reference count of the padlist. Currently this is always 1.</source>
          <target state="translated">垫表的引用次数。目前总是1。</target>
        </trans-unit>
        <trans-unit id="b9e9c4a001467c1b7e5e43bb821f471e292d9d31" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;$foo&lt;/code&gt; 到 &lt;code&gt;$bar&lt;/code&gt; 的引用已被削弱。当 &lt;code&gt;$bar&lt;/code&gt; 变量超出范围时，将被垃圾回收。下次查看 &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; 键的值时，它将为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1de879124c2751ad3ecd4b63c57cecfe27d3f64" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;$foo&lt;/code&gt; 到 &lt;code&gt;$bar&lt;/code&gt; 的引用已被削弱。当 &lt;code&gt;$bar&lt;/code&gt; 变量超出范围时，将被垃圾回收。下次查看 &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; 键的值时，它将为 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fc857a94806f2c57cbbf2e2dd2d2b88b08c2fe6" translate="yes" xml:space="preserve">
          <source>The reference is truly dumped and we can finally see what we're dealing with. Our quoting was perfectly valid but wrong for our purposes, with 'and jerry' being treated as 2 separate words rather than a phrase, thus throwing the evenly paired hash structure out of alignment.</source>
          <target state="translated">引用真正被甩掉了,我们终于可以看到我们在处理什么了。我们的引用是完全有效的,但对于我们的目的来说是错误的,'和jerry'被当作2个独立的单词而不是一个短语,从而使偶数配对的哈希结构失准。</target>
        </trans-unit>
        <trans-unit id="4adfd6b1f7abb309b66c9315a05ff37197f3a0fe" translate="yes" xml:space="preserve">
          <source>The references you get from rule 2 are the same kind of references that you get from rule 1:</source>
          <target state="translated">你从规则2中得到的参考资料和从规则1中得到的参考资料是一样的。</target>
        </trans-unit>
        <trans-unit id="4f2739050aee8d49851e25b790d128e1ca19fbde" translate="yes" xml:space="preserve">
          <source>The regex_sets feature is experimental</source>
          <target state="translated">regex_sets功能是试验性的。</target>
        </trans-unit>
        <trans-unit id="4c14a48971a0368f8bbf545f9e2905f7ac019ed5" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations,</source>
          <target state="translated">regexp有一个单一的分组,它考虑4个字母的组合,然后是3个字母的组合。</target>
        </trans-unit>
        <trans-unit id="168bedf74d17b291ff7d2c437f9134d9006e0ffe" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations, etc., and uses &lt;code&gt;\g1&lt;/code&gt; to look for a repeat. Although &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;\g1&lt;/code&gt; represent the same thing, care should be taken to use matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... only</source>
          <target state="translated">regexp具有单个分组，该分组考虑4个字母的组合，然后考虑3个字母的组合等，并使用 &lt;code&gt;\g1&lt;/code&gt; 查找重复。尽管 &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;\g1&lt;/code&gt; 代表同一件事，但应注意仅使用匹配的变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ，...。</target>
        </trans-unit>
        <trans-unit id="d1eb9cbcdcc85f0afd97e3812b595b9e1f6b3fd8" translate="yes" xml:space="preserve">
          <source>The regexp matches an open parenthesis, one or more copies of an alternation, and a close parenthesis. The alternation is two-way, with the first alternative &lt;code&gt;[^()]+&lt;/code&gt; matching a substring with no parentheses and the second alternative &lt;code&gt;\([^()]*\)&lt;/code&gt; matching a substring delimited by parentheses. The problem with this regexp is that it is pathological: it has nested indeterminate quantifiers of the form &lt;code&gt;(a+|b)+&lt;/code&gt;. We discussed in Part 1 how nested quantifiers like this could take an exponentially long time to execute if there was no match possible. To prevent the exponential blowup, we need to prevent useless backtracking at some point. This can be done by enclosing the inner quantifier as an independent subexpression:</source>
          <target state="translated">正则表达式匹配一个开放的括号，一个或多个交替的副本以及一个封闭的括号。交替是双向的，第一种选择 &lt;code&gt;[^()]+&lt;/code&gt; 匹配没有括号的子字符串，第二种选择 &lt;code&gt;\([^()]*\)&lt;/code&gt; 匹配用括号定界的子字符串。此正则表达式的问题在于它是病理性的：它嵌套了 &lt;code&gt;(a+|b)+&lt;/code&gt; 形式的不确定量词。在第1部分中，我们讨论了如果没有匹配的可能，那么像这样的嵌套量词如何需要花费指数级的时间才能执行。为防止指数爆炸，我们需要在某些时候防止无用的回溯。这可以通过将内部量词括起来作为独立的子表达式来完成：</target>
        </trans-unit>
        <trans-unit id="368bf455728e0cc079751b44e9fea4161849b273" translate="yes" xml:space="preserve">
          <source>The regexp structure contains all the data that perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts such as is the pattern anchored in some way, or what flags were used during the compile, or whether the program contains special constructs that perl needs to be aware of.</source>
          <target state="translated">regexp结构包含了所有perl需要知道的数据,以便正确使用正则表达式。它包含了关于优化的数据,perl可以使用这些数据来确定是否真的应该使用regex引擎,以及在各种情况下正确执行模式所需要的各种其他控制信息,例如模式是否以某种方式被锚定,或者在编译过程中使用了什么标志,或者程序是否包含perl需要注意的特殊结构。</target>
        </trans-unit>
        <trans-unit id="c3c54f92228f6f05bcc0bda8517b5a88720264e3" translate="yes" xml:space="preserve">
          <source>The regexp without the &lt;code&gt;//x&lt;/code&gt; modifier is</source>
          <target state="translated">没有 &lt;code&gt;//x&lt;/code&gt; 修饰符的正则表达式是</target>
        </trans-unit>
        <trans-unit id="cd0504e6dcc01ce1582fd08d19ab6d72b18efd43" translate="yes" xml:space="preserve">
          <source>The regops are defined in</source>
          <target state="translated">regops定义在</target>
        </trans-unit>
        <trans-unit id="398b15f4cf9df5e68a324633c771b534053133cc" translate="yes" xml:space="preserve">
          <source>The regression tests for each operator live in</source>
          <target state="translated">每个运营商的回归测试活在</target>
        </trans-unit>
        <trans-unit id="1185c36b91985e4291f68ed8a08b57d301b0c6f7" translate="yes" xml:space="preserve">
          <source>The regular expression engine can be a weighty tool to wield. On long strings and complex patterns it can end up having to do a lot of work to find a match, and even more to decide that no match is possible. Consider a situation like the following pattern.</source>
          <target state="translated">正则表达式引擎可能是一个重量级的工具。对于长字符串和复杂的模式,它可能最终不得不做很多工作来寻找匹配,甚至更多的工作是决定不可能匹配。考虑一下像下面这种模式的情况。</target>
        </trans-unit>
        <trans-unit id="550e74d9d02bffd01cf3b652c4e172b2d8cb3f39" translate="yes" xml:space="preserve">
          <source>The regular expression to execute.</source>
          <target state="translated">要执行的正则表达式。</target>
        </trans-unit>
        <trans-unit id="8c3b3408d3eb9771532acb10a043be225a8f7a49" translate="yes" xml:space="preserve">
          <source>The regular expression to match the balanced text uses two new (to Perl 5.10) regular expression features. These are covered in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and this example is a modified version of one in that documentation.</source>
          <target state="translated">匹配平衡文本的正则表达式使用两个新的（对Perl 5.10而言）正则表达式功能。这些内容在&lt;a href=&quot;perlre&quot;&gt;perlre中进行了介绍&lt;/a&gt;，本示例是该文档中的内容的修改版本。</target>
        </trans-unit>
        <trans-unit id="7b89c7165c60ab0797d1970f7d1380e29eaa0008" translate="yes" xml:space="preserve">
          <source>The related &lt;code&gt;base&lt;/code&gt; pragma will combine fields from base classes and any fields declared using the &lt;code&gt;fields&lt;/code&gt; pragma. This enables field inheritance to work properly. Inherited fields can be overridden but will generate a warning if warnings are enabled.</source>
          <target state="translated">相关的 &lt;code&gt;base&lt;/code&gt; 杂注将结合基类中的字段和使用 &lt;code&gt;fields&lt;/code&gt; 杂注声明的任何字段。这使字段继承能够正常工作。继承的字段可以被覆盖，但是如果启用了警告，则会生成警告。</target>
        </trans-unit>
        <trans-unit id="31c9eb432cfde9dbb8b6575337f7f66a6d53cbda" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Perl_pp_regcomp&lt;/code&gt; 中的相关代码段：</target>
        </trans-unit>
        <trans-unit id="86d45b748524cf3c3ed19b4942d99f6682b785f8" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Perl_pp_regcomp&lt;/code&gt; 中的相关代码段：</target>
        </trans-unit>
        <trans-unit id="99cbb925914614f38c9cb5913b1dca990337342e" translate="yes" xml:space="preserve">
          <source>The remainder of the input string (i.e. the characters after the extracted string). On failure, the entire string is returned.</source>
          <target state="translated">输入字符串的剩余部分(即提取字符串后的字符)。如果失败,将返回整个字符串。</target>
        </trans-unit>
        <trans-unit id="efbd63ef88d15920cb0b989c9bf11dcb1d2eacf4" translate="yes" xml:space="preserve">
          <source>The remaining arguments list the files to be included in the tar file. These files must all exist. Any files which don't exist or can't be read are silently ignored.</source>
          <target state="translated">其余参数列出了要包含在 tar 文件中的文件,这些文件必须全部存在。这些文件必须全部存在。任何不存在或无法读取的文件都会被忽略。</target>
        </trans-unit>
        <trans-unit id="f73744579f886d96e9ed158f08b1414dc3c821e4" translate="yes" xml:space="preserve">
          <source>The remaining fields specify the starting and ending cylinder and head of the range of tracks to be formatted.</source>
          <target state="translated">其余字段指定要格式化的轨道范围的起始和终止气缸和磁头。</target>
        </trans-unit>
        <trans-unit id="1833f6078478dddd497b7e7b088899346fc9339d" translate="yes" xml:space="preserve">
          <source>The remaining list-reduction functions are all specialisations of this generic idea.</source>
          <target state="translated">其余的列表还原函数都是这个通用思想的特殊化。</target>
        </trans-unit>
        <trans-unit id="5790bf8249cfb740e1105f12c204270f7d624a65" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt; . If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="translated">其余语言环境类别当前未由Perl本身使用。但要再次注意，Perl与之交互的事物可能会使用它们，包括标准Perl发行版之外的扩展以及操作系统及其实用程序。请特别注意 &lt;code&gt;$!&lt;/code&gt; 的字符串值！ &lt;code&gt;LC_MESSAGES&lt;/code&gt; 可能会更改外部实用程序给出的错误消息。如果要使用可移植的错误代码，请使用 &lt;code&gt;%!&lt;/code&gt; 。参见&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c93d95569d58cc954c309a9c37710dcae16b378b" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt;. If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt;. See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="translated">其余的语言环境类别当前未由Perl本身使用。但要再次注意，Perl与之交互的事物可能会使用它们，包括标准Perl发行版之外的扩展以及操作系统及其实用程序。请特别注意 &lt;code&gt;$!&lt;/code&gt; 的字符串值！ &lt;code&gt;LC_MESSAGES&lt;/code&gt; 可能会更改外部实用程序给出的错误消息。如果要使用可移植的错误代码，请使用 &lt;code&gt;%!&lt;/code&gt; 。参见&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f593d82b22de04a34fb6b00553893736966b088" translate="yes" xml:space="preserve">
          <source>The remaining three arguments to &lt;code&gt;autosplit&lt;/code&gt; govern other options to the autosplitter.</source>
          <target state="translated">自动 &lt;code&gt;autosplit&lt;/code&gt; 的其余三个参数控制着自动拆分器的其他选项。</target>
        </trans-unit>
        <trans-unit id="359f225886acbac14791dc5bc2f8daf71a950d7f" translate="yes" xml:space="preserve">
          <source>The remaining transformations (e.g. hex -&amp;gt; oct, bin -&amp;gt; hex, etc.) are left as an exercise to the inclined reader.</source>
          <target state="translated">其余的转换（例如，十六进制-&amp;gt; oct，bin-&amp;gt;十六进制等）作为练习留给倾斜的读者。</target>
        </trans-unit>
        <trans-unit id="24d565f51a3155e5d1586b0499680351e5378dc6" translate="yes" xml:space="preserve">
          <source>The repeat count for &lt;code&gt;u&lt;/code&gt; is interpreted as the maximal number of bytes to encode per line of output, with 0, 1 and 2 replaced by 45. The repeat count should not be more than 65.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 的重复计数被解释为每行输出要编码的最大字节数，其中0、1和2替换为45。重复计数不应超过65。</target>
        </trans-unit>
        <trans-unit id="f593cdc0477b84a5d137272da930d89fe6995081" translate="yes" xml:space="preserve">
          <source>The repertoire of characters that Perl can represent is a superset of those defined by the Unicode Consortium. On most platforms the ordinal values of a character as returned by &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; is the</source>
          <target state="translated">Perl可以代表的字符表是Unicode联盟定义的那些字符的超集。在大多数平台如通过返回一个字符的顺序值 &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="b4becab04b9eae1dfa2922434e872f92f0ca7ffd" translate="yes" xml:space="preserve">
          <source>The replacement UNIVERSAL::VERSION, when used as a function, like this:</source>
          <target state="translated">UNIVERSAL::VERSION,当作为一个函数使用时,就像这样。</target>
        </trans-unit>
        <trans-unit id="2b90d7584bfb12af61e5f1ab0554e525a346ffd6" translate="yes" xml:space="preserve">
          <source>The report generated is in the following format:</source>
          <target state="translated">生成的报告格式如下:</target>
        </trans-unit>
        <trans-unit id="c18cb003bcf6566604f8240405fff42c4ea43f6c" translate="yes" xml:space="preserve">
          <source>The report is then grouped by the &lt;b&gt;Package&lt;/b&gt; of each variable, subroutine or format with the special case &quot;(lexicals)&quot; meaning lexical variables. Each &lt;b&gt;object&lt;/b&gt; name (implicitly qualified by its containing &lt;b&gt;Package&lt;/b&gt;) includes its type character(s) at the beginning where possible. Lexical variables are easier to track and even included dereferencing information where possible.</source>
          <target state="translated">然后，将报告按每个变量，子例程或格式的&lt;b&gt;包&lt;/b&gt;进行分组，并以特殊情况&amp;ldquo;（词法）&amp;rdquo;表示词法变量。每个&lt;b&gt;对象&lt;/b&gt;名称（由其包含的&lt;b&gt;Package&lt;/b&gt;隐式限定）在可能的开头都包括其类型字符。词法变量更容易跟踪，甚至在可能的情况下甚至包括取消引用信息。</target>
        </trans-unit>
        <trans-unit id="a2f4b71d3df1e22731185a4eb5f4e73af9bf14da" translate="yes" xml:space="preserve">
          <source>The report with</source>
          <target state="translated">该报告附有</target>
        </trans-unit>
        <trans-unit id="32baff471ed8eb8f5ceead8f0fa06a41ab81b875" translate="yes" xml:space="preserve">
          <source>The request was judged to be small, so the possibility to trap it depends on the way perl was compiled. By default it is not trappable. However, if compiled for this, Perl may use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency pool after die()ing with this message. In this case the error is trappable</source>
          <target state="translated">该请求被判断为很小，因此捕获该请求的可能性取决于perl的编译方式。默认情况下，它是不可捕获的。但是，如果为此编译，Perl可能会在die（）处理此消息后将 &lt;code&gt;$^M&lt;/code&gt; 的内容用作紧急池。在这种情况下，错误是可捕获的</target>
        </trans-unit>
        <trans-unit id="e06f7be9330cffa7a55aee96bfbe8c1e1072f6a9" translate="yes" xml:space="preserve">
          <source>The requests do not necessarily go always all the way down to the operating system: that's where PerlIO buffering comes into play.</source>
          <target state="translated">请求不一定总是一路传到操作系统:这就是PerlIO缓冲的作用。</target>
        </trans-unit>
        <trans-unit id="c2923a29c348a827f2ff3da1221b43b0a603bfa9" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the</source>
          <target state="translated">require函数实际上将寻找</target>
        </trans-unit>
        <trans-unit id="d362ada26ee954875bdcbdb4ef3110ff77e350ef" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the &quot;</source>
          <target state="translated">实际上,require函数将寻找&quot;</target>
        </trans-unit>
        <trans-unit id="437fdd0ce3dd49b0cb6d8dbfa1617238f6bfc689" translate="yes" xml:space="preserve">
          <source>The require function will look for the</source>
          <target state="translated">require函数将查找</target>
        </trans-unit>
        <trans-unit id="7925470de731575e163d706573142112baceaaab" translate="yes" xml:space="preserve">
          <source>The require function will look for the &quot;</source>
          <target state="translated">require函数将寻找&quot;</target>
        </trans-unit>
        <trans-unit id="a4dd4536ee0a716833e52164851f465f831c0d1d" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt; ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 期间所需的参数是哈希，程序包以及对 &lt;code&gt;FETCH&lt;/code&gt; ing函数的引用。可选参数是任意标量$ data，对 &lt;code&gt;EXISTS&lt;/code&gt; 函数的引用以及哈希和存在缓存的初始值。</target>
        </trans-unit>
        <trans-unit id="72b681659bb57f7021407ce5fd3ac4d104c48565" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;tie&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt;ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="translated">&lt;code&gt;tie&lt;/code&gt; 期间所需的参数是哈希，程序包以及对 &lt;code&gt;FETCH&lt;/code&gt; ing函数的引用。可选参数是任意标量$ data，对 &lt;code&gt;EXISTS&lt;/code&gt; 函数的引用以及哈希和存在缓存的初始值。</target>
        </trans-unit>
        <trans-unit id="37cc4a6beddbd481d62d1aa4fb0c7078c9745a11" translate="yes" xml:space="preserve">
          <source>The requires and build_requires dependency declarations</source>
          <target state="translated">requires和build_requires的依赖性声明。</target>
        </trans-unit>
        <trans-unit id="68eca29cf3cefa1ee83b5c875c176fa92ac4b217" translate="yes" xml:space="preserve">
          <source>The rest is duplicate code from MM_Unix. Should move the linker code to its own method.</source>
          <target state="translated">其余的都是MM_Unix的重复代码。应该把链接器的代码移到自己的方法中。</target>
        </trans-unit>
        <trans-unit id="5f0ee77d23f152cd1591836db1cbf485219544f6" translate="yes" xml:space="preserve">
          <source>The rest is for internal usage of this package. In particular, if TIEHASH is overwritten, it should call SUPER::TIEHASH.</source>
          <target state="translated">其余的是本包的内部使用。特别是,如果TIEHASH被覆盖,应该调用SUPER::TIEHASH。</target>
        </trans-unit>
        <trans-unit id="fe2906e8b2561874cbab3bd035dddc47777e922a" translate="yes" xml:space="preserve">
          <source>The rest of the</source>
          <target state="translated">其余的</target>
        </trans-unit>
        <trans-unit id="bf6a19c74f24c99c3610c0c4323af3d860d85c2f" translate="yes" xml:space="preserve">
          <source>The rest of the .pm file contains sample code for providing documentation for the extension.</source>
          <target state="translated">.pm文件的其余部分包含为扩展名提供文档的示例代码。</target>
        </trans-unit>
        <trans-unit id="7c74ae28959473b4a69a8f31fe847650cadce3cf" translate="yes" xml:space="preserve">
          <source>The rest of the META.yml file is one big YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt;, whose keys are described here.</source>
          <target state="translated">META.yml文件的其余部分是一个大的YAML&lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;映射&lt;/a&gt;，此处描述了其键。</target>
        </trans-unit>
        <trans-unit id="6a0a96f4412d084abe1abbbb705cc005b4d7612f" translate="yes" xml:space="preserve">
          <source>The rest of the function description may be indented or left-adjusted. The following example shows a function with its body left-adjusted. Most examples in this document will indent the body for better readability.</source>
          <target state="translated">函数描述的其余部分可以缩进或左调整。下面的例子显示了一个函数,它的正文是向左调整的。本文档中的大多数例子都会对正文进行缩进以提高可读性。</target>
        </trans-unit>
        <trans-unit id="4748c8c8a6af67adc5b974371e823f12ce953a5d" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please email comments to &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;.</source>
          <target state="translated">本节的其余部分可能需要更新，但是我们不知道该说些什么。请通过电子邮件将评论发送至&lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6c6c6a28aca9f64e81536b5041a7bd3a852dd99" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please submit comments to &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="translated">本节的其余部分可能需要更新，但是我们不知道该说些什么。请向&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;提交评论。</target>
        </trans-unit>
        <trans-unit id="fd5215ed25fc6b559f1f45b7ad436f4f9831272e" translate="yes" xml:space="preserve">
          <source>The rest which are already available are based upon the vendor mappings at &lt;a href=&quot;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&lt;/a&gt; .</source>
          <target state="translated">其余的已经可用，基于&lt;a href=&quot;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&lt;/a&gt;上的供应商映射。</target>
        </trans-unit>
        <trans-unit id="f01295182848e9dbbe34960bfb27f883cc4035bb" translate="yes" xml:space="preserve">
          <source>The rest which are already available are based upon the vendor mappings at &lt;a href=&quot;https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&lt;/a&gt; .</source>
          <target state="translated">其余的已经可用，基于&lt;a href=&quot;https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&lt;/a&gt;上的供应商映射。</target>
        </trans-unit>
        <trans-unit id="a3cb44cf97eef964df25c82472ad386e80122021" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt; .</source>
          <target state="translated">重新启动是使用先前实施 &lt;code&gt;longjmp&lt;/code&gt; 的在 &lt;code&gt;regatom()&lt;/code&gt; 返回一个 &lt;code&gt;setjmp&lt;/code&gt; 的在 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; ，但是这被证明是有问题的，因为后者是含有许多自动变量，大量功能，它们相互作用严重与紧急控制流程 &lt;code&gt;setjmp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cb3a75ceb2d2ee1d3bf90c88d2151a6541e047d" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt;, but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt;.</source>
          <target state="translated">重新启动是使用先前实施 &lt;code&gt;longjmp&lt;/code&gt; 的在 &lt;code&gt;regatom()&lt;/code&gt; 返回一个 &lt;code&gt;setjmp&lt;/code&gt; 的在 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; ，但是这被证明是有问题的，因为后者是含有许多自动变量，大量功能，它们相互作用严重与紧急控制流程 &lt;code&gt;setjmp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e8310b48c79e713f14decd4088c7da40b8f8d5f" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt; . In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="translated">比较操作的限制是，即使例如 &lt;code&gt;cmp&lt;/code&gt; 应该返回一个有福的引用，自动生成的 &lt;code&gt;lt&lt;/code&gt; 函数也将基于 &lt;code&gt;cmp&lt;/code&gt; 结果的数值仅生成标准逻辑值。特别是在这种情况下，需要进行有效的数值转换（可能用其他转换形式表示）。</target>
        </trans-unit>
        <trans-unit id="f937ca260b1eebc06f72a3641b2c030503e4317b" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt;. In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="translated">比较操作的限制是，即使例如 &lt;code&gt;cmp&lt;/code&gt; 应该返回一个有福的引用，自动生成的 &lt;code&gt;lt&lt;/code&gt; 函数也将基于 &lt;code&gt;cmp&lt;/code&gt; 结果的数值仅生成一个标准逻辑值。特别是在这种情况下，需要进行有效的数值转换（可能以其他转换形式表示）。</target>
        </trans-unit>
        <trans-unit id="17095fb32ad5dc43587aca28eee99cc6fee8a6b5" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;$^R&lt;/code&gt; is automatically localized, so that it will behave properly in the presence of backtracking.</source>
          <target state="translated">结果 &lt;code&gt;$^R&lt;/code&gt; 会自动进行本地化，因此在存在回溯的情况下它将正常运行。</target>
        </trans-unit>
        <trans-unit id="917b4b2d464d47448ca46f205a594a1f2094a00d" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">结果 &lt;code&gt;Regexp&lt;/code&gt; 表示该参数是由 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 生成的正则表达式。</target>
        </trans-unit>
        <trans-unit id="1beec82c5ad986daa3005ca6feae967035c22b78" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">结果 &lt;code&gt;Regexp&lt;/code&gt; 表示该参数是由 &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 生成的正则表达式。</target>
        </trans-unit>
        <trans-unit id="fa60f0453236256bf9eae460e1101cb5ebaf3da0" translate="yes" xml:space="preserve">
          <source>The result has a dual nature: it is a NaN, but it also carries the integer inside it. The integer can be retrieved with &lt;a href=&quot;#getpayload&quot;&gt;&quot;getpayload&quot;&lt;/a&gt;. Note, though, that the payload is not propagated, not even on copies, and definitely not in arithmetic operations.</source>
          <target state="translated">结果具有双重性质：它是NaN，但其中还携带整数。可以使用&lt;a href=&quot;#getpayload&quot;&gt;&amp;ldquo; getpayload&amp;rdquo;&lt;/a&gt;检索整数。但是请注意，有效负载不会传播，甚至不会在副本上传播，并且绝对不会在算术运算中传播。</target>
        </trans-unit>
        <trans-unit id="413c5704399ec4e320c4b4de62416c60414146e3" translate="yes" xml:space="preserve">
          <source>The result is returned as two arguments. If the modular multiplicative inverse does not exist, both arguments are undefined. Otherwise, the arguments are a number (object) and its sign (&quot;+&quot; or &quot;-&quot;).</source>
          <target state="translated">结果作为两个参数返回。如果模块乘法逆不存在,则两个参数都是未定义的,否则,参数是数字(对象)和它的符号(&quot;+&quot;或&quot;-&quot;)。否则,参数是一个数字(对象)和它的符号(&quot;+&quot;或&quot;-&quot;)。</target>
        </trans-unit>
        <trans-unit id="e2176289afdf7f655c62c369888f79d214a9f024" translate="yes" xml:space="preserve">
          <source>The result is that the contents of line 17 of the file will be replaced with &quot;Cherry pie&quot;; a newline character will separate line 17 from line 18. This means that this code will do nothing:</source>
          <target state="translated">结果是文件第17行的内容将被替换为 &quot;Cherry pie&quot;;一个换行符将第17行和第18行分开。这意味着这段代码什么都不会做。</target>
        </trans-unit>
        <trans-unit id="f863b8e99992f5c2a779d9ed98aecf9cef5b7a84" translate="yes" xml:space="preserve">
          <source>The result is the Unicode character or character sequence given by</source>
          <target state="translated">其结果是Unicode字符或字符序列,给出了</target>
        </trans-unit>
        <trans-unit id="f066226510a6a63558092d6e0a75383b46653b7b" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由括号之间的十六进制数字指定的字符。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5B8%5D&quot;&gt;&amp;ldquo; [8]&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17faf27e0d190c0297fec9a5baff8ccb279e91a8" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由括号之间的十六进制数字指定的字符。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7238c8e2e1333323c2dd62857b981306a7706e6a" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由十六进制数字指定的字符，范围为​​0x00至0xFF。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5B8%5D&quot;&gt;&amp;ldquo; [8]&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1743ff5152c2110b7544e70901f154f3b6b46b92" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由十六进制数字指定的字符，范围为​​0x00至0xFF。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d86f6bbcc0ec2a19c70956057e4d3cc4063fc333" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由括号之间的八进制数字指定的字符。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5B8%5D&quot;&gt;&amp;ldquo; [8]&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6bbe820fb63fd799e4d92d37fd1768342fc0ad13" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由括号之间的八进制数字指定的字符。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ca77b886ca2262e5c2630425a0b7e07037d32d3" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由三位数的八进制数字指定的字符，范围在000到777之间（但最好不要在077以上使用，请参阅下一段）。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5B8%5D&quot;&gt;&amp;ldquo; [8]&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5d07b8bddc1c5dd823f98677754aff0c68b0c00" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由三位数的八进制数指定的字符，范围在000到777之间（但最好不要在077以上使用，请参阅下一段）。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d2ac189a7b892d497c3a957f821832172806b14" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;code&gt;xhdr&lt;/code&gt; except the is will be restricted to headers where the text of the header matches &lt;code&gt;PATTERN&lt;/code&gt;</source>
          <target state="translated">结果与 &lt;code&gt;xhdr&lt;/code&gt; 相同，除了仅限于标头文本与 &lt;code&gt;PATTERN&lt;/code&gt; 匹配的标头</target>
        </trans-unit>
        <trans-unit id="37186ac3e81998654b9034f359d33c97b138b201" translate="yes" xml:space="preserve">
          <source>The result may be used as a subpattern in a match:</source>
          <target state="translated">其结果可作为匹配中的子模式使用。</target>
        </trans-unit>
        <trans-unit id="aea5a1ac74300d067b63729d12ad0881314aa59c" translate="yes" xml:space="preserve">
          <source>The result of each test is captured in a hash. These hashes are the same as the hashes returned by Test::Builder-&amp;gt;details but with a couple of extra fields.</source>
          <target state="translated">每个测试的结果都存储在哈希中。这些散列与Test :: Builder-&amp;gt; details返回的散列相同，但有几个额外的字段。</target>
        </trans-unit>
        <trans-unit id="30a38c7996159062562ab2957a6c23713b7a1d86" translate="yes" xml:space="preserve">
          <source>The result of evaluation of the last successful &lt;code&gt;(?{ code })&lt;/code&gt; regular expression assertion (see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). May be written to.</source>
          <target state="translated">最后一个成功的 &lt;code&gt;(?{ code })&lt;/code&gt; 正则表达式断言的求值结果（请参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;）。可能被写入。</target>
        </trans-unit>
        <trans-unit id="66611e861a602cfa60591a93b737577becd37f08" translate="yes" xml:space="preserve">
          <source>The result of great_circle_direction is in radians, zero indicating straight north, pi or -pi straight south, pi/2 straight west, and -pi/2 straight east.</source>
          <target state="translated">great_circle_direction的结果以弧度为单位,0表示直北,pi或-pi直南,pi/2直西,-pi/2直东。</target>
        </trans-unit>
        <trans-unit id="f6846ed84b71cca2d8b5fb5477773187fbddddb3" translate="yes" xml:space="preserve">
          <source>The result of md5(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) will be exactly the same as the result of md5(&quot;abc&quot;).</source>
          <target state="translated">md5(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)的结果将与md5(&quot;abc&quot;)的结果完全相同。</target>
        </trans-unit>
        <trans-unit id="641d055cafe1e1ee3cae38ce56b7935f5d3bc2b3" translate="yes" xml:space="preserve">
          <source>The result of overflowing the range of the integers is undefined because it is undefined also in C. In other words, using 32-bit integers, &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; is undefined. Shifting by a negative number of bits is also undefined.</source>
          <target state="translated">整数范围溢出的结果是不确定的，因为在C语言中也未定义。换句话说，使用32位整数， &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; 是不确定的。移位为负数位也是不确定的。</target>
        </trans-unit>
        <trans-unit id="00de3247a1fa0dbaa5340672e75fce7f76fa569f" translate="yes" xml:space="preserve">
          <source>The result of this scenario is at best a database that doesn't contain what you expect. At worst the database will corrupt.</source>
          <target state="translated">这种情况的结果是,最好的情况是数据库中没有你所期望的内容。最坏的情况是数据库会损坏。</target>
        </trans-unit>
        <trans-unit id="f6de57c3d8ec6b1611fc0077d370dda9fed1574d" translate="yes" xml:space="preserve">
          <source>The result returned will be one of the following:</source>
          <target state="translated">返回的结果将是以下之一:</target>
        </trans-unit>
        <trans-unit id="0b8a9a1357d52322f675cb2cb87488ac744f63b6" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="translated">如果包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 形式有效，则包含插值材料的结果字符串将被污染。</target>
        </trans-unit>
        <trans-unit id="dc181363eb40ff0bd863bde77567e9656e7a29d5" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;use locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="translated">如果包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的 &lt;code&gt;use locale&lt;/code&gt; 形式有效，则包含插值材料的结果字符串将被污染。</target>
        </trans-unit>
        <trans-unit id="51fb17ca190a73d84710650cb1a592da2c670185" translate="yes" xml:space="preserve">
          <source>The result will be an array of 3 elements, each a reference to an array which will hold the handles that are ready for reading, writing and have exceptions respectively. Upon error an empty list is returned.</source>
          <target state="translated">结果将是一个由3个元素组成的数组,每个元素都是一个数组的引用,数组中分别存放着准备好读、写和有异常的句柄。一旦出错,将返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="a68ddca584ffd166b11e615f1b961f7dd364600e" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="translated">结果最多是层数的三倍：第一个元素是名称，第二个元素是参数（未指定的参数是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），第三个元素是标志，第四个元素再次是名称，依此类推向前。</target>
        </trans-unit>
        <trans-unit id="3e9d88696af53de04206c2554e1cd6a14550e72c" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;undef&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="translated">结果将是层数的三倍：第一个元素是名称，第二个元素是参数（未指定的参数是 &lt;code&gt;undef&lt;/code&gt; ），第三个元素是标志，第四个元素再次是名称，依此类推向前。</target>
        </trans-unit>
        <trans-unit id="e6e0c7dba94f1684aba5f4cd6501d599a99358de" translate="yes" xml:space="preserve">
          <source>The resulting $subdir_cmd has no leading tab nor trailing newline. This makes it easier to embed in a make string. For example.</source>
          <target state="translated">产生的$subdir_cmd没有前导符,也没有尾部的换行。这使得它更容易嵌入到make字符串中。例如</target>
        </trans-unit>
        <trans-unit id="5f6fcb4f54789b9c880bc0144fb1cf2ebd3b3159" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; values of this string's bytes - the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="translated">生成的字节序列最方便用于检查校验和。不要通过for循环添加此字符串字节的 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 值来减慢程序的速度- &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 代码 &lt;code&gt;%&lt;/code&gt; 是用于计算所有字节的8位总和的东西，该总和必须等于零：</target>
        </trans-unit>
        <trans-unit id="7e685873aa2576bcd6d048591b67cf99d300730d" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;ord&lt;/code&gt; values of this string's bytes - the &lt;code&gt;unpack&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="translated">生成的字节序列最方便用于检查校验和。不要通过for循环添加该字符串字节的 &lt;code&gt;ord&lt;/code&gt; 值来减慢程序的速度- &lt;code&gt;unpack&lt;/code&gt; 代码 &lt;code&gt;%&lt;/code&gt; 是用于计算所有字节的8位总和的东西，该总和必须等于零：</target>
        </trans-unit>
        <trans-unit id="421b5462923e8d16da2f8509620d57a56b898133" translate="yes" xml:space="preserve">
          <source>The resulting path is relative by default, i.e. the resulting path will have a leading colon.</source>
          <target state="translated">默认情况下,生成的路径是相对的,也就是说,生成的路径会有一个前导的冒号。</target>
        </trans-unit>
        <trans-unit id="d4b19b5c805ca56f431cfbcdeba1af9f3a6200a3" translate="yes" xml:space="preserve">
          <source>The resulting program then looks like:</source>
          <target state="translated">然后,产生的程序就像。</target>
        </trans-unit>
        <trans-unit id="e4aa8c76073812eb40b9e292fb100c683926c76e" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;&quot;catpath&quot;&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">可以将结果传递给&lt;a href=&quot;#catpath&quot;&gt;&amp;ldquo; catpath&amp;rdquo;，&lt;/a&gt;以获取与原始路径相同（通常相同）的路径。</target>
        </trans-unit>
        <trans-unit id="bd638c59c5752a7ccfc83a3bf825d1784299cda6" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">可以将结果传递到&lt;a href=&quot;#catpath&quot;&gt;catpath，&lt;/a&gt;以获取与原始路径相同（通常相同）的路径。</target>
        </trans-unit>
        <trans-unit id="156c1084cc95fa3e7b597345b8d09fde064a081b" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath%28%29&quot;&gt;&quot;catpath()&quot;&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">可以将结果传递给&lt;a href=&quot;#catpath%28%29&quot;&gt;&amp;ldquo; catpath（）&amp;rdquo;&lt;/a&gt;以获取与原始路径相同（通常与原始路径相同）的路径。</target>
        </trans-unit>
        <trans-unit id="fbae74b52e9e1a2f4034868dc967236dfb097109" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath()&quot;&gt;catpath()&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">可以将结果传递到&lt;a href=&quot;#catpath()&quot;&gt;catpath（）&lt;/a&gt;以获取与原始路径等效（通常相同）的路径。</target>
        </trans-unit>
        <trans-unit id="9fd6f04fef4668c0fb9b5436580855adbbe256e9" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;code&gt;catpath()&lt;/code&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">可以将结果传递到 &lt;code&gt;catpath()&lt;/code&gt; 以获取与原始路径等效（通常相同）的路径。</target>
        </trans-unit>
        <trans-unit id="7b48baa73a171c70124bb46d586398a253fc305f" translate="yes" xml:space="preserve">
          <source>The results follow ASCII rules. Only the characters &lt;code&gt;A-Z&lt;/code&gt; change, to &lt;code&gt;a-z&lt;/code&gt; respectively.</source>
          <target state="translated">结果遵循ASCII规则。仅字符 &lt;code&gt;A-Z&lt;/code&gt; 更改为 &lt;code&gt;a-z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6e1386230ca5a3e137558786aef0b9ef4ab7b59" translate="yes" xml:space="preserve">
          <source>The results of creating new symbol table entries directly or modifying any entries that are not already typeglobs are undefined and subject to change between releases of perl.</source>
          <target state="translated">直接创建新的符号表条目或修改任何还没有 typeglobs 的条目的结果都是未定义的,并且在 perl 的不同版本之间会发生变化。</target>
        </trans-unit>
        <trans-unit id="7c1728e8e43393222dde9f78fe3123aaa1846fe7" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt; , use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="translated">从 &lt;code&gt;VERSION&lt;/code&gt; 返回的内容实际上是使用 &lt;code&gt;$VERSION&lt;/code&gt; 标量包的字符串化版本对象，该对象保证是等效的，但可能与 &lt;code&gt;$VERSION&lt;/code&gt; 标量的内容不完全相同。如果您需要 &lt;code&gt;$VERSION&lt;/code&gt; 的实际内容，请改用 &lt;code&gt;$CLASS::VERSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95e455ea284fe76f90c5b0d39ee105831c2e5eaa" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt;, use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="translated">使用包 &lt;code&gt;$VERSION&lt;/code&gt; 标量，从 &lt;code&gt;VERSION&lt;/code&gt; 返回的内容实际上是字符串化的版本对象，该对象可以保证是等效的，但可能不完全是 &lt;code&gt;$VERSION&lt;/code&gt; 标量的内容。如果您需要 &lt;code&gt;$VERSION&lt;/code&gt; 的实际内容，请改用 &lt;code&gt;$CLASS::VERSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94b2a16af23a66e19e44621474dc0fa990710d75" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="translated">生成的Perl函数的返回列表由该函数的C返回值组成（除非XSUB为 &lt;code&gt;void&lt;/code&gt; 返回类型或 &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; ），然后是所有 &lt;code&gt;OUTLIST&lt;/code&gt; 和 &lt;code&gt;IN_OUTLIST&lt;/code&gt; 参数（按出现的顺序）。从XSUB返回时，将修改 &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; Perl参数，使其具有C函数写入的值。</target>
        </trans-unit>
        <trans-unit id="44655e68104aa5b50fd85988b88ae70262129b43" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="translated">生成的Perl函数的返回列表由该函数的C返回值组成（除非XSUB为 &lt;code&gt;void&lt;/code&gt; 返回类型或 &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; ），然后是所有 &lt;code&gt;OUTLIST&lt;/code&gt; 和 &lt;code&gt;IN_OUTLIST&lt;/code&gt; 参数（按出现的顺序）。从XSUB返回时，将修改 &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; Perl参数，使其具有C函数写入的值。</target>
        </trans-unit>
        <trans-unit id="d71452936695d00a40f619faefe33e6d1a6ac20b" translate="yes" xml:space="preserve">
          <source>The return may be incorrect for those rare locales where the currency symbol replaces the radix character. Send email to &lt;a href=&quot;mailto:perlbug@perl.org&quot;&gt;mailto:perlbug@perl.org&lt;/a&gt; if you have examples of it needing to work differently.</source>
          <target state="translated">对于那些用货币符号替换基数字符的罕见语言环境，返回值可能不正确。如果您有需要以其他方式工作的示例，请发送电子邮件至&lt;a href=&quot;mailto:perlbug@perl.org&quot;&gt;mailto：perlbug@perl.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0420f753fa3324f9eec48f35a50efc8cee6a049e" translate="yes" xml:space="preserve">
          <source>The return points to a per-thread static buffer, which is overwritten the next time &lt;code&gt;Perl_setlocale&lt;/code&gt; is called from the same thread.</source>
          <target state="translated">返回指向每个线程的静态缓冲区，下次从同一线程调用 &lt;code&gt;Perl_setlocale&lt;/code&gt; 时，该缓冲区将被覆盖。</target>
        </trans-unit>
        <trans-unit id="a21da59cc5c1c0e700b109e9dda17411cbacb1df" translate="yes" xml:space="preserve">
          <source>The return true when the argument satisfies the condition. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; are not integers and are neither odd nor even.</source>
          <target state="translated">当参数满足条件时返回true。 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;+inf&lt;/code&gt; ， &lt;code&gt;-inf&lt;/code&gt; 不是整数，也不是奇数也不是偶数。</target>
        </trans-unit>
        <trans-unit id="b8bfaca788fa3c0ddbe45ea5ad9f0da16e79efb8" translate="yes" xml:space="preserve">
          <source>The return value (if defined) is a Perl object, of class &lt;code&gt;PerlIO::Layer&lt;/code&gt; which is created by the C code in</source>
          <target state="translated">返回值（如果已定义）是 &lt;code&gt;PerlIO::Layer&lt;/code&gt; 类的Perl对象，该对象由C语言中的C创建</target>
        </trans-unit>
        <trans-unit id="45642a1469744a5e7107d7873a8272d52cfce5d2" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">返回值 &lt;code&gt;LVALUE&lt;/code&gt; 表示对不是变量的左值的引用。您可以通过引用函数调用（例如 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; )来实现。如果引用指向&lt;a href=&quot;perldata#Version-Strings&quot;&gt;版本字符串，&lt;/a&gt;则返回 &lt;code&gt;VSTRING&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68a59800451bff6b585d75aa0febce039f889432" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">返回值 &lt;code&gt;LVALUE&lt;/code&gt; 表示对不是变量的左值的引用。您可以通过引用函数调用（例如 &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; )来实现。如果引用指向&lt;a href=&quot;../perldata#Version-Strings&quot;&gt;版本字符串，&lt;/a&gt;则返回 &lt;code&gt;VSTRING&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1b1a3b59d37e5fda7fca51bd6d7cc822e1098fc" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="translated">可以 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 返回值以获取原始引用结构的相同副本。（请务必考虑从不受信任的来源评估代码的安全性！）</target>
        </trans-unit>
        <trans-unit id="341077e987e38231c6848bd510801f6ac305a364" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;eval&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="translated">可以 &lt;code&gt;eval&lt;/code&gt; 返回值以获取原始参考结构的相同副本。（请务必考虑从不受信任的来源评估代码的安全性！）</target>
        </trans-unit>
        <trans-unit id="5ce36c299811e6d9af00c0cefc9c75e073456ac7" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; 的返回值是实现定义的；有关更多信息，请查阅您的atan2（3）联机帮助页。</target>
        </trans-unit>
        <trans-unit id="769d902022de1a90d1cd24370f703e7b45d5dad4" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; 的返回值是实现定义的；有关更多信息，请查阅您的atan2（3）联机帮助页。</target>
        </trans-unit>
        <trans-unit id="3f7e47c80e390cbc99d4bd2d52e4ac31f1eae4a5" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;atan2(0,0)&lt;/code&gt; is implementation-defined; consult your &lt;a href=&quot;http://man.he.net/man3/atan2&quot;&gt;atan2(3)&lt;/a&gt; manpage for more information.</source>
          <target state="translated">&lt;code&gt;atan2(0,0)&lt;/code&gt; 的返回值是实现定义的；有关更多信息，请查阅您的&lt;a href=&quot;http://man.he.net/man3/atan2&quot;&gt;atan2（3）&lt;/a&gt;联机帮助页。</target>
        </trans-unit>
        <trans-unit id="7fa7da95c4b58e8bb23e135f8795df5f9ac97aa0" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">返回值是 &lt;code&gt;true&lt;/code&gt; ，如果这是一个有效的原型， &lt;code&gt;false&lt;/code&gt; 如果不是，不论 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c3cd7efde35a3e831a5bdd29d0ed5265715cc55" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;warn&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">返回值是 &lt;code&gt;true&lt;/code&gt; ，如果这是一个有效的原型， &lt;code&gt;false&lt;/code&gt; 如果不是，不论 &lt;code&gt;warn&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd97a8975a72082d0544ff1e498721e427862ae3" translate="yes" xml:space="preserve">
          <source>The return value is POSIX-like (shifted up by 8 bits), which only allows room for a made-up value derived from the severity bits of the native 32-bit condition code (unless overridden by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ). If the native condition code is one that has a POSIX value encoded, the POSIX value will be decoded to extract the expected exit value. For more details see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt;. (VMS)</source>
          <target state="translated">返回值是POSIX样（移由8位），只允许室用于从本地32位条件代码的严重性位（除非由重写衍生的虚构的值 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ）。如果本地条件代码是已编码POSIX值的代码，则POSIX值将被解码以提取预期的退出值。有关更多详细信息，请参见&lt;a href=&quot;perlvms#%24%3f&quot;&gt;$？在perlvms中&lt;/a&gt;。（VMS）</target>
        </trans-unit>
        <trans-unit id="38f16262d38a09b1b50bf9932e5e395bae210a67" translate="yes" xml:space="preserve">
          <source>The return value is a boolean: TRUE if the global locale at the time of call was in effect; and FALSE if a per-thread locale was in effect. This can be used by the caller that needs to restore things as-they-were to decide whether or not to call &lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt;&lt;code&gt;Perl_switch_to_global_locale&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回值是一个布尔值：如果调用时的全局语言环境有效，则为TRUE；否则为TRUE。如果每个线程的语言环境生效，则为FALSE。调用者可以使用它来恢复事物，从而决定是否调用&lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt; &lt;code&gt;Perl_switch_to_global_locale&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7f3af5a62c5a74bbd990f1648eb2762ff5d0f59" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="translated">返回值始终是标量，可以是字符串或数字。对于具有值同义词的属性，此函数返回的同义词是最长，最具描述性的形式，当在标量上下文中调用时，由&lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&amp;ldquo; prop_value_aliases（）&amp;rdquo;&lt;/a&gt;返回的形式。当然，您可以在结果上调用&lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&amp;ldquo; prop_value_aliases（）&amp;rdquo;&lt;/a&gt;以获取其他同义词。</target>
        </trans-unit>
        <trans-unit id="43901da674d6737b62ebf11f4c04c938005307af" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="translated">返回值始终是标量，可以是字符串或数字。对于具有值同义词的属性，此函数返回的同义词是最长，最具描述性的形式，当在标量上下文中调用时，&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;返回的形式。当然，您可以在结果上调用&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;以获取其他同义词。</target>
        </trans-unit>
        <trans-unit id="897578330f8509b5163b4447af0b4daff044a33c" translate="yes" xml:space="preserve">
          <source>The return value is formatted according to OLE conventions, as groups of hex digits with surrounding braces. For example:</source>
          <target state="translated">返回值的格式是按照OLE惯例,以十六进制数字为一组,周围加括号。例如:</target>
        </trans-unit>
        <trans-unit id="01e2753bab1a4f25f52114a02dccb7b840c45d95" translate="yes" xml:space="preserve">
          <source>The return value is the $ctx object itself.</source>
          <target state="translated">返回值是$ctx对象本身。</target>
        </trans-unit>
        <trans-unit id="437a2be9f2de32d0576eb59aa85a5731812472a7" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt;. This is</source>
          <target state="translated">返回值是&lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;调用返回的程序的退出状态。要获得实际的退出值，请向右右移8个（请参见下文）。另请参阅&lt;a href=&quot;#exec-LIST&quot;&gt; &lt;code&gt;exec&lt;/code&gt; &lt;/a&gt;。这是</target>
        </trans-unit>
        <trans-unit id="52ee5d406f163544969cdcc538ef722336dcb763" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">返回值是 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 调用返回的程序的退出状态。要获得实际的退出值，请向右移动八位（请参见下文）。另请参阅&lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;。这是</target>
        </trans-unit>
        <trans-unit id="aadd087b1069c48b3ff2e37ed0925a6bb732b05e" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">返回值是 &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 调用返回的程序的退出状态。要获得实际的退出值，请向右移动八位（请参见下文）。另请参阅&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;。这是</target>
        </trans-unit>
        <trans-unit id="28ff84250f55ab2bea98fda52eb0b62db0c2d4bd" translate="yes" xml:space="preserve">
          <source>The return value is the total length &lt;code&gt;src&lt;/code&gt; would be if the copy completely succeeded. If it is larger than &lt;code&gt;size&lt;/code&gt;, the excess was not copied.</source>
          <target state="translated">如果复制完全成功，则返回值为 &lt;code&gt;src&lt;/code&gt; 的总长度。如果它大于 &lt;code&gt;size&lt;/code&gt; ，则多余的不会被复制。</target>
        </trans-unit>
        <trans-unit id="db618f76ec023ae4b98dae939007dd3399a79764" translate="yes" xml:space="preserve">
          <source>The return value is the total length that &lt;code&gt;dst&lt;/code&gt; would have if &lt;code&gt;size&lt;/code&gt; is sufficiently large. Thus it is the initial length of &lt;code&gt;dst&lt;/code&gt; plus the length of &lt;code&gt;src&lt;/code&gt;. If &lt;code&gt;size&lt;/code&gt; is smaller than the return, the excess was not appended.</source>
          <target state="translated">返回值是该总长度 &lt;code&gt;dst&lt;/code&gt; 如果本来 &lt;code&gt;size&lt;/code&gt; 足够大。因此，它是 &lt;code&gt;dst&lt;/code&gt; 的初始长度加上 &lt;code&gt;src&lt;/code&gt; 的长度。如果 &lt;code&gt;size&lt;/code&gt; 小于返回值，则不会附加多余的部分。</target>
        </trans-unit>
        <trans-unit id="857262cdace40b471947bb6d3b761ee596eafe64" translate="yes" xml:space="preserve">
          <source>The return value is the updated object itself.</source>
          <target state="translated">返回值是更新后的对象本身。</target>
        </trans-unit>
        <trans-unit id="7f93f7b8be78580a6fdb8b5153d679ad923050d6" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回值可以是包含零个或多个arrayref，一个整数或 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="3f37d26524cdd675f6f08be05c61f9223fd0378a" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">返回值可以是包含零个或多个arrayref，一个整数或 &lt;code&gt;undef&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="36fd088c56b8f88cc2d2e8985a8fda08a71a63d3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="translated">返回值可以是第1到第4权重的arrayref，如上所示。返回值可以是整数作为主要权重，如下所示。如果返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则将使用默认的派生排序规则元素。</target>
        </trans-unit>
        <trans-unit id="68d7e0ec957990f452acfaa57c18c8410bd4dda3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;undef&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="translated">如上所示，返回值可以是第1到第4权重的arrayref。返回值可以是整数作为主要权重，如下所示。如果返回 &lt;code&gt;undef&lt;/code&gt; ，则将使用默认的派生排序规则元素。</target>
        </trans-unit>
        <trans-unit id="222fe952afa9c24172c89b0f769d4878a2ea7ad7" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;ioctl&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;fcntl&lt;/code&gt;&lt;/a&gt;) is as follows:</source>
          <target state="translated">&lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt; &lt;code&gt;ioctl&lt;/code&gt; &lt;/a&gt;（和&lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt; &lt;code&gt;fcntl&lt;/code&gt; &lt;/a&gt;）的返回值如下：</target>
        </trans-unit>
        <trans-unit id="a717c20899094357a3bea685885351b6040d8de0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; on pipes, fifos, and sockets usually returns -1.</source>
          <target state="translated">对于像STDIN这样的标准流，&lt;a href=&quot;#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;的返回值取决于操作系统：它可能返回-1或其他值。在管道，fifos和套接字上&lt;a href=&quot;#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;通常返回-1。</target>
        </trans-unit>
        <trans-unit id="9d5675dc8f958bc8634e0a1b5851a8577fc5c3bc" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; （和 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ）的返回值如下：</target>
        </trans-unit>
        <trans-unit id="03abb254ae6958b0d4d3e3d838f5570ae93832e6" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; （和 &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ）的返回值如下：</target>
        </trans-unit>
        <trans-unit id="16085bf8175ff49a2dcc989db1bc66f5346f4ab0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;INLINED&lt;/code&gt; in this example will always be 54321, regardless of later modifications to $x. You can also put any arbitrary code inside the sub, at it will be executed immediately and its return value captured the same way.</source>
          <target state="translated">在此示例中， &lt;code&gt;INLINED&lt;/code&gt; 的返回值将始终为54321，而不管以后对$ x的修改如何。您还可以将任意代码放入子代码中，然后立即执行该子代码，并以相同的方式捕获其返回值。</target>
        </trans-unit>
        <trans-unit id="f23542316437f18c2dc0de0ad16ae0deb404671a" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;survey&lt;/code&gt; is two hashes:</source>
          <target state="translated">&lt;code&gt;survey&lt;/code&gt; 的返回值是两个散列：</target>
        </trans-unit>
        <trans-unit id="6c7d2d6bce6775764986b9434f93f3fd3d99f22b" translate="yes" xml:space="preserve">
          <source>The return value of Pod::Perldoc::GetOptsOO::getopts is true if no errors, otherwise it's false.</source>
          <target state="translated">如果没有错误,Pod::Perldoc::GetOptsOO::getopts的返回值为true,否则为false。</target>
        </trans-unit>
        <trans-unit id="57cb77ff2698d7727be628530d185f8aa579f00d" translate="yes" xml:space="preserve">
          <source>The return value of tell() for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. tell() on pipes, fifos, and sockets usually returns -1.</source>
          <target state="translated">tell()对标准流(如STDIN)的返回值取决于操作系统:它可能返回-1或其他值。在管道、fifos和套接字上的tell()通常返回-1。</target>
        </trans-unit>
        <trans-unit id="d4713d5655dc6e9b8c7a80e55df87e6a297b0b32" translate="yes" xml:space="preserve">
          <source>The return value will be &lt;code&gt;NULL&lt;/code&gt; if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt;. Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned &lt;code&gt;NULL&lt;/code&gt;. Effectively a successful &lt;code&gt;hv_store&lt;/code&gt; takes ownership of one reference to &lt;code&gt;val&lt;/code&gt;. This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, &lt;code&gt;hv_store&lt;/code&gt; will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. &lt;code&gt;hv_store&lt;/code&gt; is not implemented as a call to &lt;code&gt;hv_store_ent&lt;/code&gt;, and does not create a temporary SV for the key, so if your key data is not already in SV form then use &lt;code&gt;hv_store&lt;/code&gt; in preference to &lt;code&gt;hv_store_ent&lt;/code&gt;.</source>
          <target state="translated">如果操作失败或如果不需要将该值实际存储在散列中（如绑定散列的情况），则返回值将为 &lt;code&gt;NULL&lt;/code&gt; 。否则，可以取消引用以获取原始 &lt;code&gt;SV*&lt;/code&gt; 。注意，调用者负责在调用之前适当地增加 &lt;code&gt;val&lt;/code&gt; 的引用计数，并在函数返回 &lt;code&gt;NULL&lt;/code&gt; 时递减它。实际上，成功的 &lt;code&gt;hv_store&lt;/code&gt; 拥有对 &lt;code&gt;val&lt;/code&gt; 的一个引用的所有权。这通常是您想要的；新创建的SV的引用计数为1，因此，如果您执行的所有代码都是创建SV，则将其存储在哈希值 &lt;code&gt;hv_store&lt;/code&gt; 中将拥有对新SV的唯一引用，并且您的代码不需要做任何进一步的整理。 &lt;code&gt;hv_store&lt;/code&gt; 未实现为对 &lt;code&gt;hv_store_ent&lt;/code&gt; 的调用，并且不会为密钥创建临时SV，因此，如果您的密钥数据尚未采用SV格式，则优先使用 &lt;code&gt;hv_store&lt;/code&gt; 而不是 &lt;code&gt;hv_store_ent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="972da9f747345510c81b2dc820fd0994a9799509" translate="yes" xml:space="preserve">
          <source>The return value will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt; . Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">如果操作失败或如果不需要将该值实际存储在散列中（如绑定散列的情况），则返回值将为NULL。否则，可以取消引用以获取原始 &lt;code&gt;SV*&lt;/code&gt; 。注意，调用者负责在调用之前适当地增加 &lt;code&gt;val&lt;/code&gt; 的引用计数，并在函数返回NULL时递减它。实际上，成功的hv_store拥有对 &lt;code&gt;val&lt;/code&gt; 的一个引用的所有权。这通常是您想要的；新创建的SV的引用计数为1，因此，如果您所有的代码都是创建SV，然后将它们存储在哈希中，则hv_store将拥有对新SV的唯一引用，并且您的代码无需执行任何其他操作即可整理。 hv_store未实现为对hv_store_ent的调用，并且不会为密钥创建临时SV，因此，如果您的密钥数据尚未采用SV格式，则优先使用hv_store而不是hv_store_ent。</target>
        </trans-unit>
        <trans-unit id="9bfc61e3c5920efd0c58d16c1ed44649d2d5bb7c" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error condition, followed by the hostname and service name.</source>
          <target state="translated">返回值将是一个列表;第一个值是错误条件,后面是主机名和服务名。</target>
        </trans-unit>
        <trans-unit id="080fb2b25b92c9701522bdcbe08ea5301edb65d9" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error indication, followed by a list of address structures (if no error occurred).</source>
          <target state="translated">返回值将是一个列表;第一个值是一个错误指示,后面是一个地址结构的列表(如果没有发生错误)。</target>
        </trans-unit>
        <trans-unit id="e58ba0106a37355ff008e5789a74611883b7e6cc" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains a reference to an array which contains the overview fields for that message.</source>
          <target state="translated">返回值将是对哈希的引用,其中键是消息编号,每个值包含对数组的引用,数组中包含该消息的概览字段。</target>
        </trans-unit>
        <trans-unit id="c8d88b4235e896d1cdf2637f38fe289f36609de1" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains the text of the requested header for that message.</source>
          <target state="translated">返回值将是对哈希的引用,其中键是消息号码,每个值包含该消息的请求头的文本。</target>
        </trans-unit>
        <trans-unit id="7ff5356b785d18cf62379ed63c212e5a8a9ffb9a" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="translated">返回值比&lt;a href=&quot;#charinfo%28%29&quot;&gt;&amp;ldquo; charinfo（）&amp;rdquo;&lt;/a&gt;更&amp;ldquo;煮熟&amp;rdquo; 。例如， &lt;code&gt;&quot;uc&quot;&lt;/code&gt; 属性值是包含输入代码点的完整大写字母映射的实际字符串。当完整映射与简单映射不同时，必须麻烦使用 &lt;code&gt;charinfo&lt;/code&gt; 才能从其 &lt;code&gt;upper&lt;/code&gt; 哈希元素获取此值。</target>
        </trans-unit>
        <trans-unit id="17d18fcb9f371a15bbc60a7727df47264e8d90a5" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="translated">返回值比&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;更&amp;ldquo;煮熟&amp;rdquo; 。例如， &lt;code&gt;&quot;uc&quot;&lt;/code&gt; 属性值是包含输入代码点的完整大写字母映射的实际字符串。当完整映射与简单映射不同时，必须麻烦 &lt;code&gt;charinfo&lt;/code&gt; 才能从其 &lt;code&gt;upper&lt;/code&gt; 哈希元素获取此值。</target>
        </trans-unit>
        <trans-unit id="a0c27b1b52fce6c8f2f090cdffac0089b776c9ec" translate="yes" xml:space="preserve">
          <source>The returned NaN is always a</source>
          <target state="translated">返回的NaN总是一个</target>
        </trans-unit>
        <trans-unit id="e761cd70527853f3676a64d7d2be637d80127b77" translate="yes" xml:space="preserve">
          <source>The returned hash consists of 4 parts:</source>
          <target state="translated">返回的哈希值由4部分组成。</target>
        </trans-unit>
        <trans-unit id="ac925fdbc70f038b7d79d3f22cbbb8542015b931" translate="yes" xml:space="preserve">
          <source>The returned list will begin with the initial value for &lt;code&gt;$a&lt;/code&gt;, followed by each return value from the block in order. The final value of the result will be identical to what the &lt;code&gt;reduce&lt;/code&gt; function would have returned given the same block and list.</source>
          <target state="translated">返回的列表将从 &lt;code&gt;$a&lt;/code&gt; 的初始值开始，然后依次按顺序返回该块中的每个返回值。结果的最终值将与给定相同块和列表的 &lt;code&gt;reduce&lt;/code&gt; 函数返回的值相同。</target>
        </trans-unit>
        <trans-unit id="3df12c311a5affa1878c7637ef497a0992643ca1" translate="yes" xml:space="preserve">
          <source>The returned object will only be valid as long as the underlying OPs and SVs continue to exist. Do not attempt to use the object after the underlying structures are freed.</source>
          <target state="translated">只有在底层OP和SV继续存在的情况下,返回的对象才会有效。在底层结构被释放后,不要试图使用该对象。</target>
        </trans-unit>
        <trans-unit id="27c81be6b30926294699f4659627b6ffa79304d4" translate="yes" xml:space="preserve">
          <source>The returned script will be &lt;code&gt;SCX_Inherited&lt;/code&gt; iff all the code points in it are from the Inherited script.</source>
          <target state="translated">如果返回的脚本中的所有代码点均来自Inherited脚本，则返回的脚本将为 &lt;code&gt;SCX_Inherited&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c9c36a9cfb66d7244d884d86187f93dbed4c9d0" translate="yes" xml:space="preserve">
          <source>The returned value will have the characters that can't be decoded replaced by &quot;\x{FFFD}&quot;, the Unicode replacement character.</source>
          <target state="translated">返回的值会将无法解码的字符替换为&quot;\x{FFFD}&quot;,即Unicode替换字符。</target>
        </trans-unit>
        <trans-unit id="afb88fca63fb7d940d0f8f78e07d1c80fa709c01" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">返回的值是哈希中原始键的副本，因此修改它们将不会影响原始哈希。比较&lt;a href=&quot;#values&quot;&gt;值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3aac40383199a850fb451c54d0b1c983a804515" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回的值是哈希中原始键的副本，因此修改它们不会影响原始哈希。比较&lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d53dad6b674af04a6d84ac0aee48048c271fdde" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">返回的值是哈希中原始键的副本，因此修改它们将不会影响原始哈希。比较&lt;a href=&quot;values&quot;&gt;值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21a00c167788624d4ca90d4b617125a344dae47a" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot; in a Perl regular rexpression for these, like &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ,</source>
          <target state="translated">Perl扩展属性（例如 &lt;code&gt;Any&lt;/code&gt; 和 &lt;code&gt;Greek&lt;/code&gt; )的返回值有些误导。值为 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;N&lt;/code&gt; &amp;rdquo;。所有Unicode属性都是两部分的，因此您实际上可以在Perl常规表达式中使用 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;N&lt;/code&gt; &amp;rdquo;，例如 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt; 。但是，并不是以这种方式指定Perl扩展名，仅像 &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="0b00496e0ac48606a2b2f5ade4900470b3e5cc37" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt;&quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt;&quot; in a Perl regular expression for these, like &lt;code&gt;qr/\p{ID_Start=Y/}&lt;/code&gt; or &lt;code&gt;qr/\p{Upper=N/}&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt;,</source>
          <target state="translated">Perl扩展属性（例如 &lt;code&gt;Any&lt;/code&gt; 和 &lt;code&gt;Greek&lt;/code&gt; )的返回值有些误导。值为 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;N&lt;/code&gt; &amp;rdquo;。所有Unicode属性都是两部分的，因此您实际上可以在Perl正则表达式中使用 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;N&lt;/code&gt; &amp;rdquo;，例如 &lt;code&gt;qr/\p{ID_Start=Y/}&lt;/code&gt; 或 &lt;code&gt;qr/\p{Upper=N/}&lt;/code&gt; 。但是，并不是以这种方式指定Perl扩展名，仅像 &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="f5eea968d1f523529d28fcd024fbb7e15c83c048" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object.</source>
          <target state="translated">Perl解释器的修订版，版本和子版本，表示为&lt;a href=&quot;version&quot;&gt;版本&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="85e9edc5bb272a0ee91c10e7c6d3172fdb763afd" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a decimal of the form 5.XXXYYY, where XXX is the version / 1e3 and YYY is the subversion / 1e6. For example, Perl v5.10.1 would be &quot;5.010001&quot;.</source>
          <target state="translated">Perl 解释器的修订版、版本和子版本,用小数表示,形式为 5.XXXYYY,其中 XXX 是版本/1e3,YYY 是子版本/1e6。例如,Perl v5.10.1就是 &quot;5.010001&quot;。</target>
        </trans-unit>
        <trans-unit id="66e488be2f8483df95b9f037ffeda3de74384599" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt; . The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="translated">在某些操作上，例如 &lt;code&gt;new()&lt;/code&gt; ， &lt;code&gt;bstr()&lt;/code&gt; 和 &lt;code&gt;numify()&lt;/code&gt; ，此模块的重写版本（vs. v0.01）速度较慢。原因是它现在做更多的工作并处理更多的案件。通常在其他数学运算中会花费在这些运算上的时间，因此平均而言，代码应该（快得多）快得多。如果没有，请与作者联系。</target>
        </trans-unit>
        <trans-unit id="d648a5385a086d97fdf940828d9fd6d003974ab0" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt;, &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt;. The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="translated">在某些操作上，例如 &lt;code&gt;new()&lt;/code&gt; ， &lt;code&gt;bstr()&lt;/code&gt; 和 &lt;code&gt;numify()&lt;/code&gt; ，此模块的重写版本（vs. v0.01）速度较慢。原因是它现在可以做更多的工作并处理更多的案件。通常在其他数学运算中获得在这些运算上花费的时间，因此平均而言，代码应更快（快得多）。如果没有，请与作者联系。</target>
        </trans-unit>
        <trans-unit id="23622f986ab9be80262d33005c6066bc0cc050da" translate="yes" xml:space="preserve">
          <source>The right column will also caution you if a property means something different than what might normally be expected.</source>
          <target state="translated">如果一个属性的含义与通常预期的不同,右栏也会提醒你。</target>
        </trans-unit>
        <trans-unit id="ae21a75ed2b2f6ef4dbb92843a55ab639a296c6c" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt; also in</source>
          <target state="translated">从第5行开始，右侧类似于我们刚刚看到的内容：我们有 &lt;code&gt;add&lt;/code&gt; op（ &lt;code&gt;pp_add&lt;/code&gt; 也位于</target>
        </trans-unit>
        <trans-unit id="a97b5a9d26a8152b03235a227c2f7630aad78c10" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt;, also in</source>
          <target state="translated">从第5行开始，右侧类似于我们刚刚看到的内容：我们有 &lt;code&gt;add&lt;/code&gt; op（ &lt;code&gt;pp_add&lt;/code&gt; ，也位于</target>
        </trans-unit>
        <trans-unit id="88e3fe5f1905fd5d0642f37b1a353b457c2b5b66" translate="yes" xml:space="preserve">
          <source>The right operand is not evaluated while the operator is in the &quot;false&quot; state, and the left operand is not evaluated while the operator is in the &quot;true&quot; state. The precedence is a little lower than || and &amp;amp;&amp;amp;. The value returned is either the empty string for false, or a sequence number (beginning with 1) for true. The sequence number is reset for each range encountered. The final sequence number in a range has the string &lt;code&gt;&quot;E0&quot;&lt;/code&gt; appended to it, which doesn't affect its numeric value, but gives you something to search for if you want to exclude the endpoint. You can exclude the beginning point by waiting for the sequence number to be greater than 1.</source>
          <target state="translated">当运算符处于&amp;ldquo; false&amp;rdquo;状态时，不评估右侧操作数，而当运算符处于&amp;ldquo; true&amp;rdquo;状态时，不评估左侧操作数。优先级略低于|| 和&amp;amp;&amp;amp;。返回的值要么为空字符串（为false），要么为序列号（从1开始）为true。将为遇到的每个范围重置序列号。范围中的最后一个序列号附加了字符串 &lt;code&gt;&quot;E0&quot;&lt;/code&gt; ，这不会影响其数值，但是如果您要排除端点，则会为您提供一些搜索内容。您可以通过等待序列号大于1来排除起点。</target>
        </trans-unit>
        <trans-unit id="712b7dd783ec62d03111b67512c4c71fb70fa066" translate="yes" xml:space="preserve">
          <source>The rightmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;gt;&quot;).</source>
          <target state="translated">最右边的定界符从参数文本开始到内部序列（应为&amp;ldquo;&amp;gt;&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="f1b13ab5c99b5028d035c2e34026b78f830a5ce1" translate="yes" xml:space="preserve">
          <source>The rmtree() function provide the legacy interface of remove_tree() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to remove_tree().</source>
          <target state="translated">rmtree()函数提供了传统的remove_tree()的接口,但对传递的参数有不同的解释。该函数的行为和返回值与 remove_tree()完全相同。</target>
        </trans-unit>
        <trans-unit id="97d9690fe48f5ed9ac8be9b70513653d3ab42339" translate="yes" xml:space="preserve">
          <source>The rot13 example was a trivial example. Here's another demonstration that shows off a few more features.</source>
          <target state="translated">rot13的例子是一个微不足道的例子。下面是另一个演示,展示了一些更多的功能。</target>
        </trans-unit>
        <trans-unit id="4a28f646da84403da9a05e371721d016d1168285" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$idx]&lt;/code&gt; .</source>
          <target state="translated">perl的大致等效项是 &lt;code&gt;$myarray[$idx]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b4a8606a49a46444c3a9ed277908732090e4141" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$key]&lt;/code&gt;.</source>
          <target state="translated">perl的大致等效项是 &lt;code&gt;$myarray[$key]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07cb0ce6d373861ed9384fe1d2dba7e82ae7d7eb" translate="yes" xml:space="preserve">
          <source>The routine &lt;code&gt;regtail()&lt;/code&gt; is called by both &lt;code&gt;reg()&lt;/code&gt; and &lt;code&gt;regbranch()&lt;/code&gt; in order to &quot;set the tail pointer&quot; correctly. When executing and we get to the end of a branch, we need to go to the node following the grouping parens. When parsing, however, we don't know where the end will be until we get there, so when we do we must go back and update the offsets as appropriate. &lt;code&gt;regtail&lt;/code&gt; is used to make this easier.</source>
          <target state="translated">&lt;code&gt;reg()&lt;/code&gt; 和 &lt;code&gt;regbranch()&lt;/code&gt; 都调用例程 &lt;code&gt;regtail()&lt;/code&gt; ，以便正确地&amp;ldquo;设置尾部指针&amp;rdquo;。执行时，我们到达分支的末尾，我们需要转到分组parens之后的节点。但是，在解析时，直到到达终点，我们才知道终点在哪里，所以当我们这样做时，我们必须返回并适当地更新偏移量。 &lt;code&gt;regtail&lt;/code&gt; 用于简化此过程。</target>
        </trans-unit>
        <trans-unit id="96fb8a6192d6d2137dae358308fab281f2803684" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; , a loop exit, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt; .</source>
          <target state="translated">当即将引发致命异常时，将调用 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 指示的例程。错误消息将作为第一个参数传递。当 &lt;code&gt;__DIE__&lt;/code&gt; 钩子例程返回时，异常处理将像没有钩子时一样继续进行，除非钩子例程本身通过 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; ，循环出口或 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 退出。该 &lt;code&gt;__DIE__&lt;/code&gt; 处理程序在通话过程中明确禁用，这样就可以从一个死 &lt;code&gt;__DIE__&lt;/code&gt; 处理程序。 &lt;code&gt;__WARN__&lt;/code&gt; 同样。</target>
        </trans-unit>
        <trans-unit id="a3747082bcec8b320b157ca0f6db8a2c2a773d76" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;goto &amp;amp;sub&lt;/code&gt;, a loop exit, or a &lt;code&gt;die()&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt;.</source>
          <target state="translated">当即将引发致命异常时，将调用 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 指示的例程。错误消息将作为第一个参数传递。当 &lt;code&gt;__DIE__&lt;/code&gt; 钩子例程返回时，异常处理将像没有钩子时一样继续进行，除非钩子例程本身通过 &lt;code&gt;goto &amp;amp;sub&lt;/code&gt; ，循环出口或 &lt;code&gt;die()&lt;/code&gt; 退出。该 &lt;code&gt;__DIE__&lt;/code&gt; 处理程序在通话过程中明确禁用，这样就可以从一个死 &lt;code&gt;__DIE__&lt;/code&gt; 处理程序。 &lt;code&gt;__WARN__&lt;/code&gt; 的情况与此类似。</target>
        </trans-unit>
        <trans-unit id="c23e498d9e0f7b9916602bb81bb457e05dc15d28" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt; . The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="translated">最常用的例程是 &lt;code&gt;call_sv&lt;/code&gt; 。在 &lt;code&gt;SV*&lt;/code&gt; 参数中包含的任何Perl函数的名称叫，或者给子程序的引用。第二个参数由标志组成，这些标志控制在其中调用子例程的上下文，是否正在传递子例程参数，应如何捕获错误以及如何处理返回值。</target>
        </trans-unit>
        <trans-unit id="8b9d3fc2ab950a51903275842538b6aa8532b735" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt;. The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="translated">最常用的例程是 &lt;code&gt;call_sv&lt;/code&gt; 。在 &lt;code&gt;SV*&lt;/code&gt; 参数中包含的任何Perl函数的名称叫，或者给子程序的引用。第二个参数由标志组成，这些标志控制在其中调用子例程的上下文，是否正在传递子例程参数，应如何捕获错误以及如何处理返回值。</target>
        </trans-unit>
        <trans-unit id="02aa17c916dde6540e50fc69118a82269239b3fa" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;b&gt;false&lt;/b&gt; otherwise.</source>
          <target state="translated">否则，该例程返回&lt;b&gt;false&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2a6f415596eaaeb6ae6674de29690a406129631d" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; exception.</source>
          <target state="translated">例程针对I / O问题或其他内部错误返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，否则返回true。严重的错误将作为 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 传播。</target>
        </trans-unit>
        <trans-unit id="274062f280eff9b69a72565df5a686a0a630e507" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;undef&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;die&lt;/code&gt; exception.</source>
          <target state="translated">该例程针对I / O问题或其他内部错误返回 &lt;code&gt;undef&lt;/code&gt; ，否则返回true。严重的错误会作为 &lt;code&gt;die&lt;/code&gt; 异常传播。</target>
        </trans-unit>
        <trans-unit id="30cd5a5724b0cdff1db0ded8bf4cad313b5d3163" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;reftype&lt;/code&gt; are exportable.</source>
          <target state="translated">例程 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;reftype&lt;/code&gt; 可导出。</target>
        </trans-unit>
        <trans-unit id="7978092db3768ef7e6d213d57a05b4b46c4c1d11" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; exported by default. You must specify which ones you want to use.</source>
          <target state="translated">该程序 &lt;code&gt;make_path&lt;/code&gt; 和 &lt;code&gt;remove_tree&lt;/code&gt; 都&lt;b&gt;不会&lt;/b&gt;默认被导出。您必须指定要使用的那些。</target>
        </trans-unit>
        <trans-unit id="5f252df425e68241a153a06fc0e9c8513b5f1aa7" translate="yes" xml:space="preserve">
          <source>The routines are called in string comparison order of KEY.</source>
          <target state="translated">例程按KEY的字符串比较顺序调用。</target>
        </trans-unit>
        <trans-unit id="74358fa70816b0be14690b88380765bc85d1b11f" translate="yes" xml:space="preserve">
          <source>The routines provided are:</source>
          <target state="translated">提供的例行程序是:</target>
        </trans-unit>
        <trans-unit id="258695837b0d342f488ae3724d49cf11d73778d9" translate="yes" xml:space="preserve">
          <source>The rule by which Digest::SHA handles a Unicode string is easy to state, but potentially confusing to grasp: the string is interpreted as a sequence of byte values, where each byte value is equal to the ordinal value (viz. code point) of its corresponding Unicode character. That way, the Unicode string 'abc' has exactly the same digest value as the ordinary string 'abc'.</source>
          <target state="translated">Digest::SHA处理Unicode字符串的规则很容易说明,但可能会让人感到困惑:字符串被解释为一个字节值序列,其中每个字节值等于其对应Unicode字符的序数值(即码点)。这样一来,Unicode字符串'abc'与普通字符串'abc'具有完全相同的数字值。</target>
        </trans-unit>
        <trans-unit id="6b4e5af62f9d03a0b5c8d39854ce10f47d56d0b1" translate="yes" xml:space="preserve">
          <source>The rule must only have one top level key: either 'par' for &quot;parallel&quot; or 'seq' for &quot;sequence&quot;.</source>
          <target state="translated">规则必须只有一个顶层键:&quot;parallel &quot;的'par'或 &quot;sequence &quot;的'seq'。</target>
        </trans-unit>
        <trans-unit id="2858e68dbb1d52d413ae8f5dae1d589d672ac788" translate="yes" xml:space="preserve">
          <source>The rule of thumb for portable code is: Do it all in portable Perl, or use a module (that may internally implement it with platform-specific code, but exposes a common interface).</source>
          <target state="translated">可移植代码的经验法则是。全部用可移植的Perl来做,或者使用一个模块(可以在内部用特定平台的代码来实现,但要暴露一个通用接口)。</target>
        </trans-unit>
        <trans-unit id="242ca7a8186e9298403d04b4bfd265a295183ebf" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;UTF-8&lt;/code&gt; unless you know what you're doing and unless you really benefit from using &lt;code&gt;UTF-16&lt;/code&gt;.</source>
          <target state="translated">经验法则是使用 &lt;code&gt;UTF-8&lt;/code&gt; ,除非您知道自己在做什么，并且除非真正受益于使用 &lt;code&gt;UTF-16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d771186d9f060b8e39d56f4b8de80fe1694de984" translate="yes" xml:space="preserve">
          <source>The rules data structure is documented more in the next section.</source>
          <target state="translated">规则数据结构在下一节会有更多的记载。</target>
        </trans-unit>
        <trans-unit id="b2b47541d9fe53d041ea0cd594a357e270362960" translate="yes" xml:space="preserve">
          <source>The rules determining what it is are quite simple: if the character following the backslash is an ASCII punctuation (non-word) character (that is, anything that is not a letter, digit, or underscore), then the backslash just takes away any special meaning of the character following it.</source>
          <target state="translated">决定它是什么的规则很简单:如果反斜线后面的字符是ASCII标点符号(非单词)字符(即任何不是字母、数字或下划线的字符),那么反斜线只是带走了它后面字符的任何特殊意义。</target>
        </trans-unit>
        <trans-unit id="f747d6278f9a09b6ca106424547e7e55bc600835" translate="yes" xml:space="preserve">
          <source>The rules of conduct that, in the absence of other guidance, determine what should happen first. For example, in the absence of parentheses, you always do multiplication before addition.</source>
          <target state="translated">在没有其他指导意见的情况下,决定应该先做什么的行为规则。例如,在没有括号的情况下,你总是先做乘法再做加法。</target>
        </trans-unit>
        <trans-unit id="ba784b5f42a3cdb9214cd0e95e0cb55e8afe477c" translate="yes" xml:space="preserve">
          <source>The rules used by &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict&lt;/code&gt;&lt;/a&gt; apply to this construct.</source>
          <target state="translated">&lt;a href=&quot;re#%27strict%27-mode&quot;&gt; &lt;code&gt;use re 'strict&lt;/code&gt; &lt;/a&gt;所使用的规则适用于此构造。</target>
        </trans-unit>
        <trans-unit id="903df1a17859e1fa3a6b96e5e64488aec405db63" translate="yes" xml:space="preserve">
          <source>The rules used for matching decimal digits are slightly stricter. Many scripts have their own sets of digits equivalent to the Western &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt; ones. A few, such as Arabic, have more than one set. For a string to be considered a script run, all digits in it must come from the same set of ten, as determined by the first digit encountered. As an example,</source>
          <target state="translated">用于匹配十进制数字的规则稍微严格一些。许多脚本都有自己的数字集，相当于西方的 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;9&lt;/code&gt; 。少数语言（例如阿拉伯语）有一套以上。要将字符串视为脚本运行，字符串中的所有数字必须来自十个相同的集合，这由遇到的第一个数字确定。举个例子，</target>
        </trans-unit>
        <trans-unit id="4ac2685482eb75c8db66c436a646aa6e3d97f9ed" translate="yes" xml:space="preserve">
          <source>The runtime component should have the name</source>
          <target state="translated">运行时组件的名称应该是</target>
        </trans-unit>
        <trans-unit id="9ac33bbce70d7ec48c4fcab9365b96ff1ebc5597" translate="yes" xml:space="preserve">
          <source>The runtime phase refers not only to when the distribution's contents are installed, but also to its continued use. Any library that is a prerequisite for regular use of this distribution should be indicated here.</source>
          <target state="translated">运行阶段不仅指安装发行版的内容时,还指继续使用它。任何作为正常使用该发行版的先决条件的库都应在此注明。</target>
        </trans-unit>
        <trans-unit id="763ace778385d85ae756e3844782d5cfee6e0e05" translate="yes" xml:space="preserve">
          <source>The same approach as a command line:</source>
          <target state="translated">与命令行的方法相同。</target>
        </trans-unit>
        <trans-unit id="9976b6a81a6abb21b7cab5b632b4ad690c05665b" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 相同，但是如果无法自动生成丢失的运算符，则可以在不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 指令的情况下，允许Perl还原为对该运算符执行的操作，而不是发出错误消息。</target>
        </trans-unit>
        <trans-unit id="aff3ca408715d6ed9bbfe43d93b70be580afe993" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;undef&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;use overload&lt;/code&gt; directive.</source>
          <target state="translated">与 &lt;code&gt;undef&lt;/code&gt; 相同，但是如果不能自动生成丢失的运算符，则可以在不 &lt;code&gt;use overload&lt;/code&gt; 指令的情况下，允许Perl还原为对该运算符执行的操作，而不是发出错误消息。</target>
        </trans-unit>
        <trans-unit id="4c7d5583bb4c7bf75d630d65c93bc37b198d69e0" translate="yes" xml:space="preserve">
          <source>The same caveats as the previous form apply: The non-graphic characters are no longer allowed with &quot;use utf8&quot;, it is unwise to use this form at all, and utf8ness makes a big difference.</source>
          <target state="translated">和以前的形式一样的注意事项。非图形字符不再允许使用 &quot;使用utf8&quot;,完全使用这种形式是不明智的,utf8性有很大的区别。</target>
        </trans-unit>
        <trans-unit id="286499ca118e6aee1159ad012e0d0c293bc05679" translate="yes" xml:space="preserve">
          <source>The same checksum can also be calculated in OO style:</source>
          <target state="translated">同样的校验和也可以用OO式计算。</target>
        </trans-unit>
        <trans-unit id="e7121397996c97368f3bf5006e5d7cf5183183f6" translate="yes" xml:space="preserve">
          <source>The same effect as the example above in a different way. The coderef takes the alias name as an argument and returns a canonical name on success or undef if not. Note the second argument is ignored if provided. Use this with even more caution than the regex version.</source>
          <target state="translated">与上面的例子效果相同,但方式不同。coderef将别名作为参数,并在成功时返回一个规范的名称,如果不成功则返回undef。注意,如果提供了第二个参数,则会被忽略。使用这个方法要比使用 regex 版本更加谨慎。</target>
        </trans-unit>
        <trans-unit id="e43451146d37e633afabe95e907553562bae7cb9" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">对于包含子例程或当前正在执行的评估字符串也是如此。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 字符串的$ filename 看起来像 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bfd670d25b13b1b3ec948c8f09f21523b3aecf7" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;eval&lt;/code&gt;ed strings looks like &lt;code&gt;(eval 34)&lt;/code&gt;.</source>
          <target state="translated">对于包含子例程或当前正在执行的评估字符串，也是如此。 &lt;code&gt;eval&lt;/code&gt; 字符串的$ filename看起来像 &lt;code&gt;(eval 34)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a048bf53e27173e747513cb4000a6c6bd711ca9e" translate="yes" xml:space="preserve">
          <source>The same information is displayed at the end of the output from the command</source>
          <target state="translated">同样的信息也会显示在命令</target>
        </trans-unit>
        <trans-unit id="fe72bff5d187e52fa5d199f09887af6af2e32815" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; : these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="translated">对于 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 的实现，情况并非如此：期望它们修改其操作数。的适当实现 &lt;code&gt;--&lt;/code&gt; 可能看起来像</target>
        </trans-unit>
        <trans-unit id="07cb6e84563964c1b3fb8a6ff37a2b4286b6b128" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;: these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="translated">对于 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 的实现，情况并非如此：期望它们修改其操作数。的适当实现 &lt;code&gt;--&lt;/code&gt; 可能看起来像</target>
        </trans-unit>
        <trans-unit id="b9889316caadba38254c295ba1f667d08e692e37" translate="yes" xml:space="preserve">
          <source>The same might happen to AIX 5.1 or other OS levels. As a side note, Perl cannot be built without bos.adt.syscalls and bos.adt.libm installed</source>
          <target state="translated">同样的情况也可能发生在AIX 5.1或其他级别的操作系统上。另外,如果没有安装bos.adt.syscalls和bos.adt.libm,Perl是无法构建的。</target>
        </trans-unit>
        <trans-unit id="2d3beec233d4767fecd283497936fe00947a8d1a" translate="yes" xml:space="preserve">
          <source>The same package name can be used more than once, allowing for non-contiguous code. This is useful if you have a stronger ordering principle than package names.</source>
          <target state="translated">同一个包名可以使用一次以上,允许使用不相邻的代码。如果你有比包名更强的排序原则,这很有用。</target>
        </trans-unit>
        <trans-unit id="adf0ce12f9a7b11a4e4d148adc2353bc6022f25b" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="translated">如果在非ISO8859-1和非UTF-8语言环境中启用标准文件句柄，默认 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 层和 &lt;code&gt;@ARGV&lt;/code&gt; 的自动UTF-8化，则会出现相同的问题（通过使用&lt;b&gt;-C&lt;/b&gt;命令行或 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 环境变量；请参见&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;）。事物以UTF-8的形式读入，这通常意味着使用Unicode解释，但是语言环境的存在会导致它们在该语言环境中进行解释。例如，Unicode输入中的0xD7代码点（应表示乘法符号）在希腊语环境下不会被Perl那样解释。这不是问题</target>
        </trans-unit>
        <trans-unit id="44e618a0d24868bdeb405a4592271ed0ce58faad" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;open()&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="translated">如果在非ISO8859-1和非UTF-8语言环境中启用标准文件句柄，默认 &lt;code&gt;open()&lt;/code&gt; 层和 &lt;code&gt;@ARGV&lt;/code&gt; 的自动UTF-8化，则会出现相同的问题（通过使用&lt;b&gt;-C&lt;/b&gt;命令行或 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 环境变量；请参见&lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;perlrun&lt;/a&gt;）。事物以UTF-8的形式读入，这通常意味着使用Unicode解释，但是语言环境的存在会导致它们在该语言环境中进行解释。例如，Unicode输入中的0xD7代码点（应表示乘法符号）在希腊语环境下不会被Perl解释。这不是问题</target>
        </trans-unit>
        <trans-unit id="8104fdf41371cefa43c656a17bffde6b62386dd0" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from BigInt.</source>
          <target state="translated">如果将它们传递给Math :: BigInt-&amp;gt; binf（）对象，则会发生相同的问题。由于不可能重载这些例程，因此无法通过BigInt进行修复。</target>
        </trans-unit>
        <trans-unit id="7dc30b04b9083d2f8edd85ddb5597b7e64cf1167" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from Math::BigInt.</source>
          <target state="translated">如果将它们传递给Math :: BigInt-&amp;gt; binf（）对象，则会发生相同的问题。由于不可能重载这些例程，因此无法通过Math :: BigInt进行修复。</target>
        </trans-unit>
        <trans-unit id="fd308e84d4bbc13d1645c341d0f0d15e57ef77b4" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常，也可以在&lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt;使用相同的模板。</target>
        </trans-unit>
        <trans-unit id="70e999fed9c0e326d353539553d4a7555374fd82" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in unpack().</source>
          <target state="translated">同样的模板一般也可以用在unpack()中。</target>
        </trans-unit>
        <trans-unit id="6b6c7f4b6ab698dbba6b63d74e5bcb57fa5d9973" translate="yes" xml:space="preserve">
          <source>The same tests are run both times, but more information is provided when running as &lt;code&gt;./perl harness&lt;/code&gt;.</source>
          <target state="translated">两次都运行相同的测试，但是以 &lt;code&gt;./perl harness&lt;/code&gt; 运行时会提供更多信息。</target>
        </trans-unit>
        <trans-unit id="1f4add58be52aaba625e5f7ff33a20f204714d58" translate="yes" xml:space="preserve">
          <source>The sample program:</source>
          <target state="translated">样板程序。</target>
        </trans-unit>
        <trans-unit id="81ca6bed72a326bbf775e3304829aa324851950b" translate="yes" xml:space="preserve">
          <source>The save stack is used by perl to implement the &lt;code&gt;local&lt;/code&gt; keyword and other similar behaviours; any cleanup operations that need to be performed when leaving the current scope. Items pushed to this stack generally capture the current value of some internal variable or state, which will be restored when the scope is unwound due to leaving, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;die&lt;/code&gt;, &lt;code&gt;goto&lt;/code&gt; or other reasons.</source>
          <target state="translated">perl使用保存堆栈来实现 &lt;code&gt;local&lt;/code&gt; 关键字和其他类似的行为；离开当前范围时需要执行的任何清理操作。推送到此堆栈的项目通常捕获某些内部变量或状态的当前值，当由于离开， &lt;code&gt;return&lt;/code&gt; ， &lt;code&gt;die&lt;/code&gt; ， &lt;code&gt;goto&lt;/code&gt; 或其他原因而取消作用域时，这些值将被恢复。</target>
        </trans-unit>
        <trans-unit id="f745bb5cbca08197cbed6d6403139abf437a8fa9" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt; .</source>
          <target state="translated">标量 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值存储在称为 &lt;code&gt;PL_sv_undef&lt;/code&gt; 的SV实例中。</target>
        </trans-unit>
        <trans-unit id="7d200dc97f6deaa66b9415179bc13a97fa0cc3da" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;undef&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt;.</source>
          <target state="translated">标量 &lt;code&gt;undef&lt;/code&gt; 值存储在称为 &lt;code&gt;PL_sv_undef&lt;/code&gt; 的SV实例中。</target>
        </trans-unit>
        <trans-unit id="6e858b562140c68ce32ea23e2b6e666b2e82798f" translate="yes" xml:space="preserve">
          <source>The scalar/list context for the subroutine and for the right-hand side of assignment is determined as if the subroutine call is replaced by a scalar. For example, consider:</source>
          <target state="translated">子程序和赋值右侧的标量/列表上下文的确定,就像子程序调用被标量代替一样。例如,考虑:</target>
        </trans-unit>
        <trans-unit id="6c0b56c4841154473a184d3770a4651387051abe" translate="yes" xml:space="preserve">
          <source>The scalars for in-memory files are treated as octet strings: unless the file is being opened with truncation the scalar may not contain any code points over 0xFF.</source>
          <target state="translated">内存文件的标量被视为八位数字符串:除非文件被截断打开,否则标量不得包含任何超过0xFF的代码点。</target>
        </trans-unit>
        <trans-unit id="8a59c0bcb531b15ec7601a5c46eda41a994dbd08" translate="yes" xml:space="preserve">
          <source>The scheme above allows interpretation of a wide range of dates, particularly if 4-digit years are used.</source>
          <target state="translated">上述方案允许对广泛的日期进行解释,特别是在使用4位数年份时。</target>
        </trans-unit>
        <trans-unit id="3fc0ce48ddfa00a9f249dd98501d09516efb57c0" translate="yes" xml:space="preserve">
          <source>The scheme from the uri (like 'file', 'http', etc)</source>
          <target state="translated">来自uri的方案(如'file'、'http'等)。</target>
        </trans-unit>
        <trans-unit id="73f8b37079fc67e2d535d7e2f263c71e4f89003f" translate="yes" xml:space="preserve">
          <source>The scope of the &lt;code&gt;package&lt;/code&gt; declaration is from the declaration itself through the end of the enclosing block, &lt;code&gt;eval&lt;/code&gt;, or file, whichever comes first (the same scope as the my(), our(), state(), and local() operators, and also the effect of the experimental &quot;reference aliasing,&quot; which may change), or until the next &lt;code&gt;package&lt;/code&gt; declaration. Unqualified dynamic identifiers will be in this namespace, except for those few identifiers that, if unqualified, default to the main package instead of the current one as described below. A &lt;code&gt;package&lt;/code&gt; statement affects only dynamic global symbols, including subroutine names, and variables you've used local() on, but</source>
          <target state="translated">&lt;code&gt;package&lt;/code&gt; 声明的范围是从声明本身到封闭的块， &lt;code&gt;eval&lt;/code&gt; 或文件的末尾，以先到者为准（与my（），our（），state（）和local（）运算符相同） ，以及实验性的&amp;ldquo;引用别名&amp;rdquo;（可能会更改）的效果，或者直到下一个 &lt;code&gt;package&lt;/code&gt; 声明为止。不合格的动态标识符将在此命名空间中，除了少数几个标识符（如果不合格的话）默认为主程序包，而不是当前程序包，如下所述。一个 &lt;code&gt;package&lt;/code&gt; 语句只影响动态全局符号，包括子程序名，和你使用的局部变量（），但</target>
        </trans-unit>
        <trans-unit id="49277474cf2c3fa04e4e431396fc13bca0311697" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 的作用域已将 &lt;code&gt;void&lt;/code&gt; warnings类别升级为致命错误，因此程序在遇到警告时会立即终止。</target>
        </trans-unit>
        <trans-unit id="3dbfebc1570cc3ef48ec03f51a2706061f280881" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;length&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="translated">使用 &lt;code&gt;length&lt;/code&gt; 的作用域已将 &lt;code&gt;void&lt;/code&gt; warnings类别升级为致命错误，因此程序在遇到警告时会立即终止。</target>
        </trans-unit>
        <trans-unit id="62f56ab0ebe6cfd894b851115a602d7f9f59ed1f" translate="yes" xml:space="preserve">
          <source>The script exits with zero if it thinks that everything worked, or a positive number if it thinks that something failed. Note, however, that in some cases it has to divine a failure by the output of things it does not control. For now, the exit codes are vague:</source>
          <target state="translated">如果脚本认为一切正常,则以零退出,如果认为有什么地方失败,则以正数退出。但是,请注意,在某些情况下,它必须通过它无法控制的东西的输出来判断是否失败。目前,退出代码是模糊的。</target>
        </trans-unit>
        <trans-unit id="05dbbff48c1e514e522b4520f47f1f9d051aaac1" translate="yes" xml:space="preserve">
          <source>The script first verifies the function of the &lt;code&gt;Name&lt;/code&gt; class.</source>
          <target state="translated">该脚本首先验证 &lt;code&gt;Name&lt;/code&gt; 类的功能。</target>
        </trans-unit>
        <trans-unit id="bab70c074a8060d72a4a917d75cb758f3fdbebe9" translate="yes" xml:space="preserve">
          <source>The script is available from &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt;</source>
          <target state="translated">该脚本可从&lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877获得&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63775c5f58b6e8ca06f6c938a637be34887e3ffd" translate="yes" xml:space="preserve">
          <source>The script of a character is determined by the &lt;code&gt;Script_Extensions&lt;/code&gt; property as modified by UTS 39 (&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;), as described above.</source>
          <target state="translated">如上所述，字符的脚本由UTS 39（&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;）修改的 &lt;code&gt;Script_Extensions&lt;/code&gt; 属性确定。</target>
        </trans-unit>
        <trans-unit id="496da3e22e1e3340caf097640e4353358048134f" translate="yes" xml:space="preserve">
          <source>The sdbm file format was designed for speed and convenience, not for portability or security. A maliciously crafted file might cause perl to crash or even expose a security vulnerability.</source>
          <target state="translated">sdbm文件格式是为了速度和方便而设计的,而不是为了便携性和安全性。一个恶意制作的文件可能会导致perl崩溃,甚至暴露出安全漏洞。</target>
        </trans-unit>
        <trans-unit id="bc3001b62b3120b5e625f2291ab08a912ad78b79" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt; ) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="translated">搜索引擎最初会将 &lt;code&gt;\D*&lt;/code&gt; 与&amp;ldquo; ABC&amp;rdquo; 匹配。然后它将尝试将 &lt;code&gt;(?!123)&lt;/code&gt; 与&amp;ldquo; 123&amp;rdquo; 匹配，但失败。但是，由于在正则表达式中使用了一个量词（ &lt;code&gt;\D*&lt;/code&gt; ），因此搜索引擎可以回溯和重试匹配项，从而希望匹配整个正则表达式。</target>
        </trans-unit>
        <trans-unit id="2dd6a24dc0c40439966d70dfb7faeebd4df837f5" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt;) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="translated">搜索引擎最初会将 &lt;code&gt;\D*&lt;/code&gt; 与&amp;ldquo; ABC&amp;rdquo;匹配。然后它将尝试将 &lt;code&gt;(?!123)&lt;/code&gt; 与&amp;ldquo; 123&amp;rdquo;匹配，但失败。但是，由于在正则表达式中使用了量词（ &lt;code&gt;\D*&lt;/code&gt; ），因此搜索引擎可以回溯和重试匹配项，以期匹配完整的正则表达式。</target>
        </trans-unit>
        <trans-unit id="4989338d675235ed7afc62322345e940a111f8d8" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;//p&lt;/code&gt; , which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="translated">第二个优点是嵌入式修饰符（ &lt;code&gt;//p&lt;/code&gt; 除外，它修改了整个正则表达式）仅影响包含修饰符的组中的正则表达式。因此可以使用分组来定位修饰符的效果：</target>
        </trans-unit>
        <trans-unit id="344654afee619df186bd5aa49c470902771a22f7" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;/p&lt;/code&gt;, which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="translated">第二个优点是嵌入式修饰符（ &lt;code&gt;/p&lt;/code&gt; 除外，它修改了整个正则表达式）仅影响包含修饰符的组中的正则表达式。因此可以使用分组来定位修饰符的效果：</target>
        </trans-unit>
        <trans-unit id="e6b19a99a58715509197b4fd3bb055452f4e6bb8" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt; . The final argument to &lt;code&gt;Newxc&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; , should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="translated">第二个和第三个参数 &lt;code&gt;number&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 指定应分配多少个指定类型的数据结构。参数 &lt;code&gt;type&lt;/code&gt; 传递给 &lt;code&gt;sizeof&lt;/code&gt; 。最后一个参数到 &lt;code&gt;Newxc&lt;/code&gt; ， &lt;code&gt;cast&lt;/code&gt; ，如果使用，应 &lt;code&gt;pointer&lt;/code&gt; 参数是从所述不同 &lt;code&gt;type&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="fea027e954f4ec8636256c0b94ce6f7f44ab6c0c" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt;. The final argument to &lt;code&gt;Newxc&lt;/code&gt;, &lt;code&gt;cast&lt;/code&gt;, should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="translated">第二个和第三个参数 &lt;code&gt;number&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 指定应分配多少个指定类型的数据结构。参数 &lt;code&gt;type&lt;/code&gt; 传递给 &lt;code&gt;sizeof&lt;/code&gt; 。最后一个参数到 &lt;code&gt;Newxc&lt;/code&gt; ， &lt;code&gt;cast&lt;/code&gt; ，如果使用，应 &lt;code&gt;pointer&lt;/code&gt; 参数是从所述不同 &lt;code&gt;type&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="1b7128198e8ffe79d47674dc971b588a148d07fe" translate="yes" xml:space="preserve">
          <source>The second and third highest priorities are to look in the parent of the current directory and a directory called</source>
          <target state="translated">排名第二和第三的优先级是在当前目录的父目录和一个叫做</target>
        </trans-unit>
        <trans-unit id="9372cc26ce11f225b78cb9001dded71987be37ab" translate="yes" xml:space="preserve">
          <source>The second argument ($eol) is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. Every occurrence of &quot;\n&quot; is replaced with this string, and it is also used for additional &quot;soft line breaks&quot; to ensure that no line end up longer than 76 characters. Pass it as &quot;\015\012&quot; to produce data suitable for external consumption. The string &quot;\r\n&quot; produces the same result on many platforms, but not all.</source>
          <target state="translated">第二个参数($eol)是要使用的行尾序列。它是可选的,默认为&quot;\n&quot;。每一次出现&quot;\/n &quot;都会被替换为这个字符串,它也用于额外的 &quot;软换行&quot;,以确保没有一行超过76个字符。将其传递为&quot;\015\012&quot;,以产生适合外部消费的数据。字符串&quot;\r\n &quot;在许多平台上产生相同的结果,但不是所有平台。</target>
        </trans-unit>
        <trans-unit id="691db7e7ba5b2eef57391203c3fd8b3455b42a9c" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">第二个参数可以是带有选项的哈希引用，该选项与传递给 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; 的参数相同。</target>
        </trans-unit>
        <trans-unit id="d9356e806771df85496c708eb7a467795a26a60f" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;read()&lt;/code&gt;.</source>
          <target state="translated">第二个参数可以是带有选项的哈希引用，该选项与传递给 &lt;code&gt;read()&lt;/code&gt; 的参数相同。</target>
        </trans-unit>
        <trans-unit id="36e7dec2e6aed1723cd212b39460017f8772c38b" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="translated">第二个参数是一个正则表达式。它可以作为正则表达式参考（即 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ）或（为了更好地与旧的perls兼容）作为看起来像正则表达式的字符串给出（当前不支持替代定界符）：</target>
        </trans-unit>
        <trans-unit id="851ff1e7afee5d9f26155a298af3215064fbafc8" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;qr//&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="translated">第二个参数是一个正则表达式。它可以作为正则表达式参考（即 &lt;code&gt;qr//&lt;/code&gt; ）或（为了更好地与旧的perls兼容）作为看起来像正则表达式的字符串给出（当前不支持替代定界符）：</target>
        </trans-unit>
        <trans-unit id="e9cd8da657568e7bbba17b34028b2178bd5abb57" translate="yes" xml:space="preserve">
          <source>The second argument is considered a regex if it is either a regex object or a string that looks like a regex. Regex objects are constructed with the qr// operator in recent versions of perl. A string is considered to look like a regex if its first and last characters are &quot;/&quot;, or if the first character is &quot;m&quot; and its second and last characters are both the same non-alphanumeric non-whitespace character. These regexp</source>
          <target state="translated">第二个参数如果是一个regex对象或一个看起来像regex的字符串,则被认为是一个regex。在最近的perl版本中,Regex对象是用qr//运算符构造的。如果一个字符串的第一个和最后一个字符是&quot;/&quot;,或者第一个字符是 &quot;m&quot;,第二个和最后一个字符都是相同的非字母数字非空格字符,那么这个字符串就被认为是一个regex对象。这些regexp</target>
        </trans-unit>
        <trans-unit id="ffe3c605f37afcab4c8601d801b588d13a566637" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in the case of a unary operator.</source>
          <target state="translated">第二个参数是另一个操作数，如果是一元运算符，则为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4f1fa234686b49496c4cac025cf1d9ea03f5c52" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;undef&lt;/code&gt; in the case of a unary operator.</source>
          <target state="translated">第二个参数是另一个操作数，如果是一元运算符，则为 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8f0c3f0ec389d3780a678c2cc02cdb14b452933" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can compress using &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;bzip2&lt;/code&gt; or &lt;code&gt;xz&lt;/code&gt;. If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="translated">第二个参数用于指示压缩。您可以使用 &lt;code&gt;gzip&lt;/code&gt; ， &lt;code&gt;bzip2&lt;/code&gt; 或 &lt;code&gt;xz&lt;/code&gt; 进行压缩。如果您传递一个数字，则假定它是 &lt;code&gt;gzip&lt;/code&gt; 压缩级别（介于1和9之间），但是最好使用常量：</target>
        </trans-unit>
        <trans-unit id="e99835175d57940dd272e3dc71fc2882ef5b0d66" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can either compress using &lt;code&gt;gzip&lt;/code&gt; or &lt;code&gt;bzip2&lt;/code&gt; . If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="translated">第二个参数用于指示压缩。您可以使用 &lt;code&gt;gzip&lt;/code&gt; 或 &lt;code&gt;bzip2&lt;/code&gt; 进行压缩。如果您传递数字，则假定它是 &lt;code&gt;gzip&lt;/code&gt; 压缩级别（介于1和9之间），但最好使用常量：</target>
        </trans-unit>
        <trans-unit id="a0c730e612ef3dd802df3a15f52c50f234217ccd" translate="yes" xml:space="preserve">
          <source>The second argument may be considered optional, but remains for backwards compatibility. Archive::Tar now looks at the file magic to determine what class should be used to open the file and will transparently Do The Right Thing.</source>
          <target state="translated">第二个参数可能被认为是可选的,但为了向后的兼容性而保留。Archive::Tar 现在会根据文件的魔力来决定应该用什么类来打开文件,并且会透明地做正确的事情。</target>
        </trans-unit>
        <trans-unit id="fc50752077e3b12e3cd10f78b06bb8c9b8f956b4" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt; 's. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="translated">第二个参数指向包含 &lt;code&gt;num&lt;/code&gt; &lt;code&gt;SV*&lt;/code&gt; 的数组。创建AV后，可以根据需要销毁SV。</target>
        </trans-unit>
        <trans-unit id="51ba89f615646daa0a3b0a56db80558ec7c78c30" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt;'s. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="translated">第二个参数指向包含 &lt;code&gt;num&lt;/code&gt; &lt;code&gt;SV*&lt;/code&gt; 的数组。创建AV后，可以根据需要销毁SV。</target>
        </trans-unit>
        <trans-unit id="ae8c79378da8449512fbe01727cd6ac969d7ae7c" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;&quot;-|&quot;&lt;/code&gt;, makes it a read-pipe into a separate program, rather than an ordinary filehandle into a file.</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 的第二个参数， &lt;code&gt;&quot;-|&quot;&lt;/code&gt; ，使其成为单独程序的读取管道，而不是普通文件句柄的文件。</target>
        </trans-unit>
        <trans-unit id="241df4a30fc4febc2cd9ef098abdb1cdbc871750" translate="yes" xml:space="preserve">
          <source>The second call to hex() will warn about a non-portable constant.</source>
          <target state="translated">第二个对hex()的调用将对一个非可移植常量发出警告。</target>
        </trans-unit>
        <trans-unit id="52f5fb6e434df4bf3ba2648b67634f2b93cdc1b5" translate="yes" xml:space="preserve">
          <source>The second call-back is optional if the call back is registered prior to the call to $term-&amp;gt;readline.</source>
          <target state="translated">如果在调用$ term-&amp;gt; readline之前注册了回调，则第二个回调是可选的。</target>
        </trans-unit>
        <trans-unit id="104d457b0581ca75e5a33a6cc382aa3d75495d54" translate="yes" xml:space="preserve">
          <source>The second call-back registered is the call back for registration. The input filehandle (often STDIN, but not necessarily) will be passed in.</source>
          <target state="translated">注册的第二个回调是注册的回调。输入的文件柄(通常是STDIN,但不一定)将被传递进来。</target>
        </trans-unit>
        <trans-unit id="8a9a833fe2a8c9894ba16f1673e04b6df3b8c78c" translate="yes" xml:space="preserve">
          <source>The second case often turns out to have identical results to the first case, albeit only by accident.</source>
          <target state="translated">第二种情况往往会出现与第一种情况相同的结果,尽管只是偶然。</target>
        </trans-unit>
        <trans-unit id="9a2db73bb8959c9504bedfb024b1f19ea96655cb" translate="yes" xml:space="preserve">
          <source>The second class of portable ranges is invoked when one or both of the range's end points are expressed as &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="translated">当范围端点的一个或两个端点表示为 &lt;code&gt;\N{...}&lt;/code&gt; 时，将调用第二类可移植范围</target>
        </trans-unit>
        <trans-unit id="0d9c1d1eb4a7fe50e319b8d6cb4e544cda2638c9" translate="yes" xml:space="preserve">
          <source>The second column is the return type, the third column the name. Columns after that are the arguments. The first column is a set of flags:</source>
          <target state="translated">第二列是返回类型,第三列是名称。之后的列是参数。第一列是一组标志。</target>
        </trans-unit>
        <trans-unit id="833ac465c5bc76260e3533a8f5293c1a6cc4e353" translate="yes" xml:space="preserve">
          <source>The second example in the synopsis does something equivalent to this:</source>
          <target state="translated">概要中的第二个例子做的事情与此相当。</target>
        </trans-unit>
        <trans-unit id="f7f8f6797190b2ee94971db1ba0f6aeb4ac8dc06" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt; , and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt; , or are shorter than 5 chars.</source>
          <target state="translated">第二个示例打印名称为 &lt;code&gt;foo&lt;/code&gt; 的条目，以及名称结尾为 &lt;code&gt;bar&lt;/code&gt; 或少于5个字符的条目。</target>
        </trans-unit>
        <trans-unit id="ff08cd3ad532db8c5d5dd8a872abb6c4f322ba5e" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt;, and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt;, or are shorter than 5 chars.</source>
          <target state="translated">第二个示例显示名称为 &lt;code&gt;foo&lt;/code&gt; 的条目，以及名称以 &lt;code&gt;bar&lt;/code&gt; 结束或少于5个字符的名称的条目。</target>
        </trans-unit>
        <trans-unit id="6b7ec951497cf0073403b17626a675e036c31257" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt; .</source>
          <target state="translated">如果留在输入缓冲区中的所有数据的第二出口点的测试， &lt;code&gt;$input&lt;/code&gt; -记得 &lt;code&gt;ConsumeInput&lt;/code&gt; 选项时，将自动启用 &lt;code&gt;LimitOutput&lt;/code&gt; 使用。输入缓冲区用完后，外部循环可以再次运行并覆盖现在为空的 &lt;code&gt;$input&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cea8aa29f5d1b03f7b0a4cb746f125b76bdff01" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt;.</source>
          <target state="translated">如果留在输入缓冲区中的所有数据的第二出口点的测试， &lt;code&gt;$input&lt;/code&gt; -记得 &lt;code&gt;ConsumeInput&lt;/code&gt; 选项时，将自动启用 &lt;code&gt;LimitOutput&lt;/code&gt; 使用。输入缓冲区用完后，外部循环可以再次运行并覆盖现在为空的 &lt;code&gt;$input&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dba4d9ed358b9b1b26a10b82c95880d18ef1ec5" translate="yes" xml:space="preserve">
          <source>The second form allows the filter to hold state information using a closure, thus:</source>
          <target state="translated">第二种形式允许过滤器使用闭合来保存状态信息,因此。</target>
        </trans-unit>
        <trans-unit id="204d9fcc358796976a40cb62f3873844790ea690" translate="yes" xml:space="preserve">
          <source>The second form is strongly discouraged, because it breaks the ability of a subclass to reuse the parent's constructor, but you may still run across it in existing code.</source>
          <target state="translated">第二种形式是不被鼓励的,因为它破坏了子类重用父类构造函数的能力,但你仍然可能在现有的代码中遇到它。</target>
        </trans-unit>
        <trans-unit id="0819d819ae212b8e1bcdb9b5bc6d671458a8958e" translate="yes" xml:space="preserve">
          <source>The second form limits or expands the output with shell globbing as in the following examples:</source>
          <target state="translated">第二种形式通过shell globbing限制或扩展输出,如下面的例子。</target>
        </trans-unit>
        <trans-unit id="c407c89499b72c27a5a072472ddedf2b307bb4f0" translate="yes" xml:space="preserve">
          <source>The second form takes an ASCII string of &quot;0&quot; and &quot;1&quot; characters as its argument. It's equivalent to</source>
          <target state="translated">第二种形式以 &quot;0 &quot;和 &quot;1 &quot;字符的ASCII字符串作为参数。它相当于</target>
        </trans-unit>
        <trans-unit id="653b770c920437547bfd253af4e36f98e0dbfce5" translate="yes" xml:space="preserve">
          <source>The second form, for convenience, simply calls the &lt;code&gt;new&lt;/code&gt; method on its arguments before dumping the object immediately.</source>
          <target state="translated">为了方便起见，第二种形式只是在立即转储对象之前对其参数调用 &lt;code&gt;new&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="dc711c3d286876153bcbf61db541b42c9a9350fc" translate="yes" xml:space="preserve">
          <source>The second gives data on how many keys are at each depth in the chain, and gives an idea of how much work a fetch *hit* will take. The performance for an update or delete of an item in the hash is equivalent to this case.</source>
          <target state="translated">第二个给出了链中每个深度有多少个键的数据,并给出了一个取*命中需要多少工作的概念。在哈希中更新或删除一个项目的性能相当于这种情况。</target>
        </trans-unit>
        <trans-unit id="5995436678b8ce31e572994a72a1c15e94c7f93e" translate="yes" xml:space="preserve">
          <source>The second is</source>
          <target state="translated">二是</target>
        </trans-unit>
        <trans-unit id="3d4dc00d964c0b0076b393752a2dfc8106f40760" translate="yes" xml:space="preserve">
          <source>The second is a question mark &lt;code&gt;?&lt;/code&gt; to match any single character. The third specifies a specific set of characters.</source>
          <target state="translated">第二个是问号 &lt;code&gt;?&lt;/code&gt; 匹配任何单个字符。第三个指定一组特定的字符。</target>
        </trans-unit>
        <trans-unit id="86badbc4e990f49a4a0e0309ce3e34af3acb8215" translate="yes" xml:space="preserve">
          <source>The second is, in short, more readable. In particular, it's obvious that the number of parameters you're feeding to that phrase (two) is the number of parameters that it</source>
          <target state="translated">第二种,简而言之,更有可读性。特别是,很明显,你给那个短语输入的参数数(两个)就是它的参数数。</target>
        </trans-unit>
        <trans-unit id="7d7dcadbcc9256c73e53e45ca4167a8f00171936" translate="yes" xml:space="preserve">
          <source>The second method both creates the AV and initially populates it with SVs:</source>
          <target state="translated">第二种方法既创建了AV,又初步填充了SV。</target>
        </trans-unit>
        <trans-unit id="5a04571edd1042cba183eaac5eb081daffd5163c" translate="yes" xml:space="preserve">
          <source>The second method divides up the generated code into</source>
          <target state="translated">第二种方法是将生成的代码划分为</target>
        </trans-unit>
        <trans-unit id="30b5717864fa144252bae28ce0e68e9e2886c509" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; , which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="translated">第二个新的显示参数是 &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; ，可以将其设置为true或false，默认值为true。请参阅上一节了解这意味着什么。</target>
        </trans-unit>
        <trans-unit id="a8d5bb3a74ae14b7cc834ba7cb47fc90749857de" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt;, which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="translated">第二个新的显示参数是 &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; ，可以将其设置为true或false，默认值为true。请参阅上一节了解这意味着什么。</target>
        </trans-unit>
        <trans-unit id="105094491ac9a931737afcae5ec00cc67ecea83f" translate="yes" xml:space="preserve">
          <source>The second option is to explicitly instruct Configure to detect the newer Berkeley DB installation, by supplying the right directories with &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; and &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt;&lt;b&gt;and&lt;/b&gt; before running &quot;make test&quot; setting your LD_LIBRARY_PATH to</source>
          <target state="translated">第二个选项是通过向正确的目录提供 &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; 和 &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt; &lt;b&gt;并&lt;/b&gt;在运行&amp;ldquo; make test&amp;rdquo;之前将LD_LIBRARY_PATH设置为，以明确指示Configure来检测更新的Berkeley DB安装。</target>
        </trans-unit>
        <trans-unit id="b104d0289f2a63192d73ded4515b99bcffef5da9" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt; , is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt; , so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="translated">第二个参数 &lt;code&gt;$mode&lt;/code&gt; 用于指定是打开文件进行读取还是写入，并在写入时选择指定压缩级别和压缩策略。 &lt;code&gt;$mode&lt;/code&gt; 参数的格式类似于'C'函数 &lt;code&gt;fopen&lt;/code&gt; 的mode参数，因此&amp;ldquo; rb&amp;rdquo;用于打开以供读取，&amp;ldquo; wb&amp;rdquo;用于写入，而&amp;ldquo; ab&amp;rdquo;用于附加（在末尾写入）文件）。</target>
        </trans-unit>
        <trans-unit id="40f3477c6f4b0d20844832da1b4bf48b8115879e" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt;, is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt;, so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="translated">第二个参数 &lt;code&gt;$mode&lt;/code&gt; 用于指定是打开文件进行读取还是写入，并在写入时选择指定压缩级别和压缩策略。 &lt;code&gt;$mode&lt;/code&gt; 参数的格式类似于'C'函数 &lt;code&gt;fopen&lt;/code&gt; 的mode参数，因此&amp;ldquo; rb&amp;rdquo;用于打开以供读取，&amp;ldquo; wb&amp;rdquo;用于写入，而&amp;ldquo; ab&amp;rdquo;用于附加（在末尾写入）文件）。</target>
        </trans-unit>
        <trans-unit id="3411b2ade45037b8736308e07cf74ad1d92df3ee" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;'^'&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;'$'&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="translated">第二个正则表达式不匹配，因为 &lt;code&gt;'^'&lt;/code&gt; 限制了 &lt;code&gt;keeper&lt;/code&gt; 仅在字符串的开头进行匹配，但是 &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; keeper在中间开始。第三个regexp确实匹配，因为 &lt;code&gt;'$'&lt;/code&gt; 限制了 &lt;code&gt;keeper&lt;/code&gt; 仅在字符串的末尾匹配。</target>
        </trans-unit>
        <trans-unit id="9eae2bfeb40a7aaf7114e7fd8256ee81caccdbd3" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;^&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;$&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="translated">第二个正则表达式不匹配，因为 &lt;code&gt;^&lt;/code&gt; 限制了 &lt;code&gt;keeper&lt;/code&gt; 只能在字符串的开头进行匹配，但是 &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; keeper在中间开始。第三个正则表达式确实匹配，因为 &lt;code&gt;$&lt;/code&gt; 约束 &lt;code&gt;keeper&lt;/code&gt; 仅在字符串的末尾匹配。</target>
        </trans-unit>
        <trans-unit id="733da91fc44d8ab5e75ced78a6cc48a582c7d7b0" translate="yes" xml:space="preserve">
          <source>The second returned item and &lt;code&gt;$!&lt;/code&gt; can be used to check for valid input:</source>
          <target state="translated">第二个返回的项目和 &lt;code&gt;$!&lt;/code&gt; 可用于检查有效输入：</target>
        </trans-unit>
        <trans-unit id="2c1496bf9c5a01143ce96b1f9c010fe32e40f772" translate="yes" xml:space="preserve">
          <source>The second sentence is wrong. In actual fact bval will only default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when the openinfo parameter in dbopen is NULL. If a non-NULL openinfo parameter is used at all, the value that happens to be in bval will be used. That means you always have to specify bval when making use of any of the options in the openinfo parameter. This documentation error will be fixed in the next release of Berkeley DB.</source>
          <target state="translated">第二句话是错误的。实际上，只有当dbopen中的openinfo参数为NULL时，bval 才会默认为 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。如果完全使用了非NULL的openinfo参数，则将使用恰好在bval中的值。这意味着在使用openinfo参数中的任何选项时，您始终必须指定bval。此文档错误将在下一版Berkeley DB中修复。</target>
        </trans-unit>
        <trans-unit id="aaad1f57fe700f2a9b2dd58ec708684feaf8128f" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a lexical subroutine that has gone out of scope, for example,</source>
          <target state="translated">第二种情况是由eval访问一个已经超出范围的词汇子程序造成的,例如。</target>
        </trans-unit>
        <trans-unit id="9ade278ee614d31e9547b1781d35dc6ff90a8980" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a variable that has gone out of scope, for example,</source>
          <target state="translated">第二种情况是由eval访问一个已经超出范围的变量引起的,例如。</target>
        </trans-unit>
        <trans-unit id="b47d8c8a23f4e0d763e99999d69c0c5eb0cb3a92" translate="yes" xml:space="preserve">
          <source>The second style of bundling lifts this restriction. It can be enabled with:</source>
          <target state="translated">第二种捆绑方式解除了这一限制。它可以通过以下方式启用:</target>
        </trans-unit>
        <trans-unit id="ab8073e684e0f88cfe3fd5f9716b9c696bbef27e" translate="yes" xml:space="preserve">
          <source>The second value to be substituted in the output string (usually the row in cursor addressing capabilities)</source>
          <target state="translated">在输出字符串中替换的第二个值(通常是游标寻址能力中的行)。</target>
        </trans-unit>
        <trans-unit id="72ec171fc6e9d8dd4e1917d8ba0d47a2f390d23d" translate="yes" xml:space="preserve">
          <source>The second, more efficient way is to use the following template for your Foo.xs:</source>
          <target state="translated">第二种更有效的方法是为你的Foo.xs使用以下模板。</target>
        </trans-unit>
        <trans-unit id="ea8fa202ee5b9df3dfb7272625ecae21681f7d7d" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="translated">该部分（旧版本中又称为&amp;ldquo;项目&amp;rdquo;），如果没有则为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。例如，在&amp;ldquo; L &amp;lt;Getopt :: Std / DESCRIPTION&amp;gt;&amp;rdquo;中，&amp;ldquo; DESCRIPTION&amp;rdquo;是该部分。 （请注意，这与联机帮助页部分不同，如&amp;ldquo; man 5 crontab&amp;rdquo;中的&amp;ldquo; 5&amp;rdquo;。Pod意义上的&amp;ldquo; Section Foo&amp;rdquo;是指标题或项目所引入的文本部分，其文字为&amp;ldquo; Foo&amp;rdquo; &amp;ldquo;。）</target>
        </trans-unit>
        <trans-unit id="cd89b9d74f7d870dca4a759e8ab8f51f0dc1f9b2" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;undef&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="translated">该部分（旧版本中又称为&amp;ldquo;项目&amp;rdquo;），如果没有则为 &lt;code&gt;undef&lt;/code&gt; 。例如，在&amp;ldquo; L &amp;lt;Getopt :: Std / DESCRIPTION&amp;gt;&amp;rdquo;中，&amp;ldquo; DESCRIPTION&amp;rdquo;是该部分。 （请注意，这与联机帮助页部分不同，如&amp;ldquo; man 5 crontab&amp;rdquo;中的&amp;ldquo; 5&amp;rdquo;。Pod含义中的&amp;ldquo; Section Foo&amp;rdquo;是指标题或项目所引入的文本部分，其文字为&amp;ldquo; Foo&amp;rdquo; &amp;ldquo;。）</target>
        </trans-unit>
        <trans-unit id="592a5f44132e9a3aa5e9a10cfa07afacf196746b" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;&quot;safe_level&quot;&lt;/a&gt; for more information.</source>
          <target state="translated">强调临时文件创建的安全性，以便将文件句柄和文件名一起返回。这有助于确保在检查文件存在与打开之间通过另一个过程创建临时文件的情况下不会发生竞争状况。提供了附加的安全级别，例如，检查是否在世界可写目录上设置了粘性位。有关更多信息，请参见&lt;a href=&quot;#safe_level&quot;&gt;&amp;ldquo; safe_level&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d5faf936bbea0ef6b4af3b53c6607ced9b3cdea" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt; for more information.</source>
          <target state="translated">强调临时文件创建的安全性，以便将文件句柄和文件名一起返回。这有助于确保在检查文件存在与打开之间通过另一个过程创建临时文件的情况下不会发生竞争状况。提供了附加的安全级别，例如，检查是否在世界可写目录上设置了粘性位。有关更多信息，请参见&lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02ef1170c6c4276366f2c9602e48f300db3d9145" translate="yes" xml:space="preserve">
          <source>The seemingly equivalent construct in Perl, &lt;code&gt;$$aref[$i]&lt;/code&gt; first does the deref of $aref, making it take $aref as a reference to an array, and then dereference that, and finally tell you the</source>
          <target state="translated">在Perl中看似等效的构造函数 &lt;code&gt;$$aref[$i]&lt;/code&gt; 首先对$ aref进行解引用，使它以$ aref作为对数组的引用，然后对其进行解引用，最后告诉您</target>
        </trans-unit>
        <trans-unit id="5ae490ef8bae426993ed6639b51d33e36f67a5f8" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;a href=&quot;setitimer(2)&quot;&gt;&lt;code&gt;setitimer(2)&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">多线程程序的间隔计时器的语义是特定于系统的，某些系统可能支持其他间隔计时器。例如，未指定哪个线程获取信号。请参阅您的&lt;a href=&quot;setitimer(2)&quot;&gt; &lt;code&gt;setitimer(2)&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="5d3a7adddb69f2204deb61bd662439aeebd384d4" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;code&gt;setitimer()&lt;/code&gt; documentation.</source>
          <target state="translated">多线程程序的间隔计时器的语义是特定于系统的，某些系统可能支持其他间隔计时器。例如，未指定哪个线程获取信号。请参阅您的 &lt;code&gt;setitimer()&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="65ef3e0624e679879b7ce02cec7d6809073f165d" translate="yes" xml:space="preserve">
          <source>The sense of the match can be reversed by using &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">可以使用 &lt;code&gt;!~&lt;/code&gt; 运算符反转匹配的含义：</target>
        </trans-unit>
        <trans-unit id="571f2b8a003669439aca5df927f2bc3b59493e17" translate="yes" xml:space="preserve">
          <source>The sequence &lt;code&gt;\b&lt;/code&gt; is special inside a bracketed character class. While outside the character class, &lt;code&gt;\b&lt;/code&gt; is an assertion indicating a point that does not have either two word characters or two non-word characters on either side, inside a bracketed character class, &lt;code&gt;\b&lt;/code&gt; matches a backspace character.</source>
          <target state="translated">序列 &lt;code&gt;\b&lt;/code&gt; 在带括号的字符类中是特殊的。在字符类之外， &lt;code&gt;\b&lt;/code&gt; 是一个断言，指示在括号字符类内，点的任一侧都没有两个单词字符或两个非单词字符的点， &lt;code&gt;\b&lt;/code&gt; 匹配一个退格字符。</target>
        </trans-unit>
        <trans-unit id="2e682f0e9f09d4fac48ccdb6cb912af9bfeddf7f" translate="yes" xml:space="preserve">
          <source>The sequence can also be extended to negative index n using the re-arranged recurrence relation</source>
          <target state="translated">序列也可以利用重新排列的递归关系扩展到负指数n。</target>
        </trans-unit>
        <trans-unit id="6b263532d25e62f98e230387976bd3e1a8c5cb59" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP's next OP.</source>
          <target state="translated">OP的下一个OP的序列号。</target>
        </trans-unit>
        <trans-unit id="b45bacc53a5ed1f0afceaa4ff3006834edab117c" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP, or a hyphen if it doesn't have one.</source>
          <target state="translated">上位机的序列号,如果没有序列号,则为连字符。</target>
        </trans-unit>
        <trans-unit id="4f0a83d5889e74bacf92e475321b6ad01721beb5" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP. Note that this is a sequence number generated by B::Concise.</source>
          <target state="translated">OP的序列号。注意,这是一个由 B::Concise 生成的序列号。</target>
        </trans-unit>
        <trans-unit id="a1e46d38c7dda11bf03f174aca8ec057ac38a288" translate="yes" xml:space="preserve">
          <source>The sequence number of this partition. Partitions are numbered starting as &lt;code&gt;1&lt;/code&gt; [with &quot;partition 0&quot; meaning the entire disk]. Sometimes this field may be &lt;code&gt;0&lt;/code&gt; and you'll have to infer the partition sequence number from how many partitions precede it on the disk.</source>
          <target state="translated">该分区的序列号。分区的编号从 &lt;code&gt;1&lt;/code&gt; 开始（[partition 0&amp;rdquo;表示整个磁盘）。有时，该字段可能为 &lt;code&gt;0&lt;/code&gt; ，您必须从磁盘上的多少个分区中推断出分区序列号。</target>
        </trans-unit>
        <trans-unit id="c10dc949f49eb3d32cdb0534e93e9f1fddb641e8" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="translated">&lt;code&gt;\a&lt;/code&gt; ， &lt;code&gt;\c&lt;/code&gt; ， &lt;code&gt;\e&lt;/code&gt; ， &lt;code&gt;\f&lt;/code&gt; ， &lt;code&gt;\n&lt;/code&gt; ， &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; ， &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; ， &lt;code&gt;\r&lt;/code&gt; ， &lt;code&gt;\t&lt;/code&gt; 和 &lt;code&gt;\x&lt;/code&gt; 序列也很特殊，它们的含义相同在方括号类之外做。</target>
        </trans-unit>
        <trans-unit id="90a0a5f9a35ae3ea0a297068e4b1bab795815fcf" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\c&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="translated">&lt;code&gt;\a&lt;/code&gt; ， &lt;code&gt;\c&lt;/code&gt; ， &lt;code&gt;\e&lt;/code&gt; ， &lt;code&gt;\f&lt;/code&gt; ， &lt;code&gt;\n&lt;/code&gt; ， &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; ， &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; ， &lt;code&gt;\r&lt;/code&gt; ， &lt;code&gt;\t&lt;/code&gt; 和 &lt;code&gt;\x&lt;/code&gt; 的序列也很特殊，它们的含义相同在方括号类之外执行。</target>
        </trans-unit>
        <trans-unit id="899a56478deaf614d4bf9d04537d9557616e32cf" translate="yes" xml:space="preserve">
          <source>The serialized structure will include a &lt;code&gt;x_serialization_backend&lt;/code&gt; entry giving the package and version used to serialize. Any existing key in the given &lt;code&gt;$meta&lt;/code&gt; object will be clobbered.</source>
          <target state="translated">序列化的结构将包括 &lt;code&gt;x_serialization_backend&lt;/code&gt; 条目，该条目提供用于序列化的包和版本。给定的 &lt;code&gt;$meta&lt;/code&gt; 对象中的任何现有密钥将被破坏。</target>
        </trans-unit>
        <trans-unit id="0d53186f69243fe4e7fc81db07bccfc51f977e9e" translate="yes" xml:space="preserve">
          <source>The serializing hook, called on the object during serialization. It can be inherited, or defined in the class itself, like any other method.</source>
          <target state="translated">序列化钩子,在序列化过程中对对象进行调用。它可以被继承,也可以像其他方法一样在类本身中定义。</target>
        </trans-unit>
        <trans-unit id="4e9ebcecc7a860f145ea8f9108514a4fa8316dfb" translate="yes" xml:space="preserve">
          <source>The service name supplied to getaddrinfo() is not available for the socket type given in the $hints.</source>
          <target state="translated">提供给getaddrinfo()的服务名对于$hints中给出的socket类型是不可用的。</target>
        </trans-unit>
        <trans-unit id="ba23ccf9d34101355ab34a3727e24a0a0f7b250a" translate="yes" xml:space="preserve">
          <source>The services a piece of code promises to provide forever, in contrast to its &lt;b&gt;implementation&lt;/b&gt;, which it should feel free to change whenever it likes.</source>
          <target state="translated">与它的&lt;b&gt;实现&lt;/b&gt;相反，一段代码承诺可以永远提供这些服务，并且可以随时随意更改。</target>
        </trans-unit>
        <trans-unit id="32c78a4d560dbf4474d5f3b5cef5e0e631bdf4c5" translate="yes" xml:space="preserve">
          <source>The set is specified as a list of characters, or as a range of characters where the beginning and end of the range are separated by a minus (or dash) character, or as any combination of lists and ranges. The dash can also be included in the set as a character it if is the beginning or end of the set. This set is enclosed in square brackets. The close square bracket &lt;code&gt;]&lt;/code&gt; may be used in a set if it is the first character in the set.</source>
          <target state="translated">该集合被指定为一个字符列表，或一个字符范围，其中范围的开始和结尾用减号（或破折号）分隔，或者指定为列表和范围的任何组合。破折号也可以作为字符包含在集合中，如果它是集合的开始或结尾。这套放在方括号中。紧密括号 &lt;code&gt;]&lt;/code&gt; 可以在一组中使用，如果它是该组中的第一个字符。</target>
        </trans-unit>
        <trans-unit id="271c11282a628a982454242ec29109ed2ea23f1d" translate="yes" xml:space="preserve">
          <source>The set of characters that are deemed whitespace are those that Unicode calls &quot;Pattern White Space&quot;, namely:</source>
          <target state="translated">被认为是空白的一组字符是Unicode称为 &quot;模式白色空间 &quot;的字符,即:</target>
        </trans-unit>
        <trans-unit id="5e7d4549f7a90817f3e92cc9271f629864ca580a" translate="yes" xml:space="preserve">
          <source>The setlocale function</source>
          <target state="translated">setlocale函数</target>
        </trans-unit>
        <trans-unit id="6cd53441a7a72535c4ff8e055f31a3a3fc042379" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="translated">子例程属性的设置在编译时发生。 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明中的变量属性也将在编译时应用。但是， &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 变量会在运行时应用其属性。这意味着您必须</target>
        </trans-unit>
        <trans-unit id="229ecae54cd846eee20b1cbee543175ec9cd197e" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;our&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;my&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="translated">子例程属性的设置在编译时发生。 &lt;code&gt;our&lt;/code&gt; 声明中的变量属性也将在编译时应用。但是， &lt;code&gt;my&lt;/code&gt; 变量会在运行时应用其属性。这意味着您必须</target>
        </trans-unit>
        <trans-unit id="ab1edc3ed4db36281da6290a4a02b6bb1d2f2a9a" translate="yes" xml:space="preserve">
          <source>The seven routines are:</source>
          <target state="translated">这七项常规是:</target>
        </trans-unit>
        <trans-unit id="7db711982141cfb12b9e3602192ccba86ac4d921" translate="yes" xml:space="preserve">
          <source>The sheet</source>
          <target state="translated">该表</target>
        </trans-unit>
        <trans-unit id="67100f7fba2fe91ac3115331e86988966a0f9ad9" translate="yes" xml:space="preserve">
          <source>The shell offers to run in</source>
          <target state="translated">外壳提供运行在</target>
        </trans-unit>
        <trans-unit id="d2a4c575dba49342e824220d900f0c783780f4b9" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="translated">Shell的 &lt;code&gt;test&lt;/code&gt; 使用&amp;ldquo; =&amp;rdquo;，&amp;ldquo;！=&amp;rdquo;，&amp;ldquo; &amp;lt;&amp;rdquo;等进行字符串比较，并使用&amp;ldquo; -eq&amp;rdquo;，&amp;ldquo;-ne&amp;rdquo;，&amp;ldquo;-lt&amp;rdquo;等进行数字比较。这与Perl相反，后者使用 &lt;code&gt;eq&lt;/code&gt; ， &lt;code&gt;ne&lt;/code&gt; ， &lt;code&gt;lt&lt;/code&gt; 进行字符串比较，并使用 &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; 等进行数字比较。</target>
        </trans-unit>
        <trans-unit id="a4421a2ab5bd2e622c5d0a683eecbd4f08bbe24b" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="translated">Shell的 &lt;code&gt;test&lt;/code&gt; 使用&amp;ldquo; =&amp;rdquo;，&amp;ldquo;！=&amp;ldquo;，&amp;ldquo; &amp;lt;&amp;rdquo;等进行字符串比较，并使用&amp;ldquo; -eq&amp;rdquo;，&amp;ldquo;-ne&amp;rdquo;，&amp;ldquo;-lt&amp;rdquo;等进行数字比较。这与Perl相反，后者使用 &lt;code&gt;eq&lt;/code&gt; ， &lt;code&gt;ne&lt;/code&gt; ， &lt;code&gt;lt&lt;/code&gt; 进行字符串比较，并使用 &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; 等进行数字比较。</target>
        </trans-unit>
        <trans-unit id="fe36cec28443e99377776c6efc56682531e56f06" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; ) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="translated">简短的答案是，默认情况下，Perl 仅根据字符的代码点比较等效项（ &lt;code&gt;eq&lt;/code&gt; ， &lt;code&gt;ne&lt;/code&gt; ）。在上述情况下，答案为否（因为0x00C1！= 0x0041）。但有时，任何大写字母A都应视为相等，甚至在任何情况下都应视为A。</target>
        </trans-unit>
        <trans-unit id="84602cf60297d60acdefd80efdd1c60462b73b9b" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="translated">简短的答案是，默认情况下，Perl仅根据字符的代码点比较等效项（ &lt;code&gt;eq&lt;/code&gt; ， &lt;code&gt;ne&lt;/code&gt; ）。在上述情况下，答案为否（因为0x00C1！= 0x0041）。但有时，任何大写字母A都应被视为相等，甚至在任何情况下都应被视为A。</target>
        </trans-unit>
        <trans-unit id="b57501930c25501b20f82b569d1ea16761a497e6" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; ) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; .</source>
          <target state="translated">简短的答案是，默认情况下，Perl 仅根据字符的代码点比较字符串（ &lt;code&gt;lt&lt;/code&gt; ， &lt;code&gt;le&lt;/code&gt; ， &lt;code&gt;cmp&lt;/code&gt; ， &lt;code&gt;ge&lt;/code&gt; ， &lt;code&gt;gt&lt;/code&gt; ）。在上述情况下，答案是&amp;ldquo;之后&amp;rdquo;，因为 &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d67ccb6666f81cda59931fcf7ad032ead024bc41" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt;, &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt;.</source>
          <target state="translated">简短的答案是，默认情况下，Perl仅根据字符的代码点比较字符串（ &lt;code&gt;lt&lt;/code&gt; ， &lt;code&gt;le&lt;/code&gt; ， &lt;code&gt;cmp&lt;/code&gt; ， &lt;code&gt;ge&lt;/code&gt; ， &lt;code&gt;gt&lt;/code&gt; ）。在上述情况下，答案是&amp;ldquo;之后&amp;rdquo;，因为 &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ace0e0cec639bb708cb2cf532e982971dd3748da" translate="yes" xml:space="preserve">
          <source>The short name of the general category of</source>
          <target state="translated">的总称。</target>
        </trans-unit>
        <trans-unit id="02c6ec10d109a1b719286e329258adf56d502cef" translate="yes" xml:space="preserve">
          <source>The short story</source>
          <target state="translated">小故事</target>
        </trans-unit>
        <trans-unit id="eb4d2d85d25fb4d71e2225f2e7a3eb6515112128" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="translated">简而言之，您可能应该只在标量或函数上使用定义，而不能在集合（数组和哈希）上使用。有关更多详细信息，请参见Perl 5.004版本或更高版本中的&lt;a href=&quot;functions/defined&quot;&gt;定义&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53f5dab7a291daa9043df504d583260ae569f535" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;perlfunc#defined&quot;&gt;&quot;defined&quot; in perlfunc&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="translated">简而言之，您可能应该只在标量或函数上使用定义，而不能在集合（数组和哈希）上使用。有关更多详细信息，请参见5.004版本或更高版本的Perl&lt;a href=&quot;perlfunc#defined&quot;&gt;中的perlfunc&lt;/a&gt;中的&amp;ldquo; defined&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="be047f864fccecb4801e21c3ca26d33faa969dbf" translate="yes" xml:space="preserve">
          <source>The sign &lt;code&gt;/^[+-]$/&lt;/code&gt; is stored separately. The string 'NaN' is used to represent the result when input arguments are not numbers, as well as the result of dividing by zero.</source>
          <target state="translated">符号 &lt;code&gt;/^[+-]$/&lt;/code&gt; 是分开存储的。字符串'NaN'用于表示输入参数不是数字时的结果以及除以零的结果。</target>
        </trans-unit>
        <trans-unit id="5d535efa9748a7b51984807c3b0e47062fc14e19" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf' and stored separately. You can access it with the sign() method.</source>
          <target state="translated">符号是'+'、'-'、'NaN'、'+inf'或'-inf',并单独存储。你可以用sign()方法访问它。</target>
        </trans-unit>
        <trans-unit id="be8bba598ba0bfbad37b038eb92c99bbb5b687ac" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'.</source>
          <target state="translated">符号是'+'、'-'、'NaN'、'+inf'或'-inf'。</target>
        </trans-unit>
        <trans-unit id="32ee9fc8e75a1189426734a34b70183ae0bf5e08" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'. You can access it with the sign() method.</source>
          <target state="translated">符号是'+'、'-'、'NaN'、'+inf'或'-inf'。你可以通过sign()方法访问它。</target>
        </trans-unit>
        <trans-unit id="11646904ceab245420048654e9bde4a41bb7ec59" translate="yes" xml:space="preserve">
          <source>The signal Exec signal mask</source>
          <target state="translated">信号Exec信号掩码</target>
        </trans-unit>
        <trans-unit id="104ebb4db613ce634a3b75383995774c2e797f04" translate="yes" xml:space="preserve">
          <source>The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="translated">签名声明了该块范围内的词汇变量。当子程序被调用时,签名会首先控制。它从传递的参数列表中填充签名变量。如果参数列表不符合签名的要求,那么它将抛出一个异常。当签名处理完成后,控制权就会传递给块。</target>
        </trans-unit>
        <trans-unit id="1d781ab42c79199084a9c305d1ab2ed6d80e787b" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code, but when using a signature, the signature is a parenthesised list that goes immediately before the block, after any name or attributes.</source>
          <target state="translated">签名是子程序主体的一部分。通常一个子程序的主体只是一个括号内的代码块,但是当使用签名时,签名是一个括号内的列表,紧接在代码块之前,任何名称或属性之后。</target>
        </trans-unit>
        <trans-unit id="d68142e064ec1d6e704c7c13d44f8b02e77345ce" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code. When using a signature, the signature is a parenthesised list that goes immediately after the subroutine name. The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="translated">签名是子程序主体的一部分。通常一个子程序的主体是一个简单的括号内的代码块。当使用签名时,签名是一个紧跟在子程序名称之后的括号列表。签名声明了该代码块范围内的词汇变量。当子程序被调用时,签名会首先控制该子程序。它从传递的参数列表中填充签名变量。如果参数列表不符合签名的要求,那么它将抛出一个异常。当签名处理完成后,控制权就会传递给块。</target>
        </trans-unit>
        <trans-unit id="8bf79dd34df166da1a0a362d8a7c14bc52139481" translate="yes" xml:space="preserve">
          <source>The signatures feature is experimental</source>
          <target state="translated">签名功能是试验性的</target>
        </trans-unit>
        <trans-unit id="ebf9d6090863be01051258238bf3ef2c8b46c7c9" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched as-is by putting a backslash before it:</source>
          <target state="translated">每一个字的意义将在本教程的其余部分解释,但现在,重要的是要知道,一个元字符可以通过在它前面加上反斜杠来进行匹配。</target>
        </trans-unit>
        <trans-unit id="2444d6c2a6baf7e1580c4abcb9b61735a0532f35" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">每一个字的意义将在本教程的其他部分解释,但现在,只需知道一个元字符可以通过在它前面加上反斜杠来匹配。</target>
        </trans-unit>
        <trans-unit id="d05188639d7fd13d368b039de9eab91f22380450" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt; , matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; . That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="translated">类似命名的属性 &lt;code&gt;\p{Punct}&lt;/code&gt; 匹配ASCII范围内的一个稍有不同的集合，即 &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; 。也就是说，它缺少9个字符 &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; ，这是因为Unicode将POSIX认为是标点的东西分为两类，标点符号和符号。</target>
        </trans-unit>
        <trans-unit id="8cd091ac264b3ba5cf264f4cd380086afff2aabf" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt;, matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt;. That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt;. This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="translated">类似命名的属性 &lt;code&gt;\p{Punct}&lt;/code&gt; 匹配ASCII范围内的一个稍有不同的集合，即 &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; 。也就是说，它缺少9个字符 &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; ，这是因为Unicode将POSIX认为是标点的东西分为两类，标点符号和符号。</target>
        </trans-unit>
        <trans-unit id="a851643ae5a58ccc6f3ce68bfdab3a7ef68d1794" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt; , execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="translated">简单的规则是：自动加载非方法时，继承将不起作用。对旧代码的简单修复方法是：在以前依赖于从名为 &lt;code&gt;BaseClass&lt;/code&gt; 的基类继承非方法的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 的任何模块中，在启动过程中执行 &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="145065cb1f22a69e2ed6682015cb7947554b75d7" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt;, execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="translated">简单的规则是：自动加载非方法时，继承将不起作用。修改旧代码的简单方法是：在以前依赖于从名为 &lt;code&gt;BaseClass&lt;/code&gt; 的基类继承非方法的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 的任何模块中，在启动过程中执行 &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5af89b6d15a00a979315dfddae0b5f323e4af12" translate="yes" xml:space="preserve">
          <source>The simple rule to remember, if you want to match a literal &lt;code&gt;{&lt;/code&gt; character (U+007B &lt;code&gt;LEFT CURLY BRACKET&lt;/code&gt;) in a regular expression pattern, is to escape each literal instance of it in some way. Generally easiest is to precede it with a backslash, like &lt;code&gt;\{&lt;/code&gt; or enclose it in square brackets (&lt;code&gt;[{]&lt;/code&gt;). If the pattern delimiters are also braces, any matching right brace (&lt;code&gt;}&lt;/code&gt;) should also be escaped to avoid confusing the parser, for example,</source>
          <target state="translated">如果要在正则表达式模式中匹配文字 &lt;code&gt;{&lt;/code&gt; 字符（U + 007B &lt;code&gt;LEFT CURLY BRACKET&lt;/code&gt; ），那么要记住的简单规则是，以某种方式转义每个文字实例。通常最简单的方法是在其前面加上反斜杠，例如 &lt;code&gt;\{&lt;/code&gt; 或将其括在方括号（ &lt;code&gt;[{]&lt;/code&gt; ）中。如果模式定界符也是大括号，则也应转义任何匹配的右大括号（ &lt;code&gt;}&lt;/code&gt; ），以避免混淆解析器，例如，</target>
        </trans-unit>
        <trans-unit id="41d909120b343bfa9af89dc978321448d395292c" translate="yes" xml:space="preserve">
          <source>The simple stdio implementation creates the files</source>
          <target state="translated">简单的stdio实现会创建文件</target>
        </trans-unit>
        <trans-unit id="f2a9e9b7a3c97685eea0b1595b9417bb605f6809" translate="yes" xml:space="preserve">
          <source>The simplest XSUBs consist of 3 parts: a description of the return value, the name of the XSUB routine and the names of its arguments, and a description of types or formats of the arguments.</source>
          <target state="translated">最简单的XSUB包括3个部分:返回值的描述,XSUB例程的名称和参数的名称,以及参数的类型或格式的描述。</target>
        </trans-unit>
        <trans-unit id="5cfe5e43e01ddc5838feef9195e0126bb74ada96" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt; . Thus the integer regexp is</source>
          <target state="translated">最简单的情况是整数。这些由数字序列组成，前面有一个可选的符号。我们可以用 &lt;code&gt;\d+&lt;/code&gt; 表示的数字和符号可以与 &lt;code&gt;[+-]&lt;/code&gt; 匹配。因此，整数regexp为</target>
        </trans-unit>
        <trans-unit id="16ed7663dd31b0d719b95952e4dbcc002ac1e075" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt;. Thus the integer regexp is</source>
          <target state="translated">最简单的情况是整数。这些由一个数字序列组成，前面有一个可选的符号。我们可以用 &lt;code&gt;\d+&lt;/code&gt; 表示的数字和符号可以与 &lt;code&gt;[+-]&lt;/code&gt; 匹配。因此，整数regexp为</target>
        </trans-unit>
        <trans-unit id="f5ce4a00629ba2eb87550ae04e313683cd18e39d" translate="yes" xml:space="preserve">
          <source>The simplest format for a Version Range is just the version number itself, e.g. &lt;code&gt;2.4&lt;/code&gt;. This means that &lt;b&gt;at least&lt;/b&gt; version 2.4 must be present. To indicate that &lt;b&gt;any&lt;/b&gt; version of a prerequisite is okay, even if the prerequisite doesn't define a version at all, use the version &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">版本范围的最简单格式只是版本号本身，例如 &lt;code&gt;2.4&lt;/code&gt; 。这意味着&lt;b&gt;至少&lt;/b&gt;必须存在版本2.4。为了表明前提条件的&lt;b&gt;任何&lt;/b&gt;版本都可以，即使前提条件根本没有定义版本，也可以使用version &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="205579583087d3f83514fed292a979acc1fd2056" translate="yes" xml:space="preserve">
          <source>The simplest format for a version specification is just the version number itself, e.g. &lt;code&gt;2.4&lt;/code&gt;. This means that &lt;b&gt;at least&lt;/b&gt; version 2.4 must be present. To indicate that &lt;b&gt;any&lt;/b&gt; version of a prerequisite is okay, even if the prerequisite doesn't define a version at all, use the version &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">版本说明的最简单格式只是版本号本身，例如 &lt;code&gt;2.4&lt;/code&gt; 。这意味着&lt;b&gt;至少&lt;/b&gt;必须存在版本2.4。为了表明前提条件的&lt;b&gt;任何&lt;/b&gt;版本都可以，即使前提条件根本没有定义版本，也可以使用version &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90f647a57152f0376dead3744742f9e10945d73a" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt; .</source>
          <target state="translated">最简单的方法使用 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 函数。它可以在左侧或右侧填充空格，在左侧填充零，并且不会截断结果。该 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 功能只能用空格右边垫字符串，它会结果截到的最大长度 &lt;code&gt;$pad_len&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60ef9faadf39e8b6092ce866661076ad7721c8c1" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;sprintf&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;pack&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt;.</source>
          <target state="translated">最简单的方法使用 &lt;code&gt;sprintf&lt;/code&gt; 函数。它可以在左边或右边用空格填充，在左边用零填充，并且不会截断结果。该 &lt;code&gt;pack&lt;/code&gt; 功能只能用空格右边垫字符串，它会结果截到的最大长度 &lt;code&gt;$pad_len&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc3e208a9819c2ed872df1040ec4eed39730cc50" translate="yes" xml:space="preserve">
          <source>The simplest regex is simply a word, or more generally, a string of characters. A regex consisting of a word matches any string that contains that word:</source>
          <target state="translated">最简单的regex只是一个单词,或者更一般的是一串字符。由一个词组成的regex可以匹配任何包含该词的字符串。</target>
        </trans-unit>
        <trans-unit id="e7349953e0f225a36578668e9ad5be25a2093d5b" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of a word matches any string that contains that word:</source>
          <target state="translated">最简单的regexp就是一个单词,或者更普遍的是一个字符串。由一个词组成的regexp可以匹配任何包含该词的字符串。</target>
        </trans-unit>
        <trans-unit id="0eaf5ad324e3121e2a83d8b08987e28055dbf879" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of just a word matches any string that contains that word:</source>
          <target state="translated">最简单的regexp就是一个单词,或者更普遍的是一个字符串。由一个单词组成的regexp可以匹配任何包含该单词的字符串。</target>
        </trans-unit>
        <trans-unit id="f93ecdae42936826d9c1b25b5229a95d439104b0" translate="yes" xml:space="preserve">
          <source>The simplest style of bundling can be enabled with:</source>
          <target state="translated">最简单的捆绑方式可以通过以下方式启用。</target>
        </trans-unit>
        <trans-unit id="7cd479644d912e323fa369ec3403c930944ff04b" translate="yes" xml:space="preserve">
          <source>The simplest two-level data structure to build in Perl is an array of arrays, sometimes casually called a list of lists. It's reasonably easy to understand, and almost everything that applies here will also be applicable later on with the fancier data structures.</source>
          <target state="translated">在Perl中构建的最简单的两级数据结构是一个数组,有时也会被随便称为列表的列表。它相当容易理解,几乎这里适用的所有内容也都适用于后面的更高级的数据结构。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
