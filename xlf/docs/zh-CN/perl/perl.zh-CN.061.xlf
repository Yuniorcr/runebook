<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="065d987b91e5e5831e84ee6eb6792bbd1900fe0e" translate="yes" xml:space="preserve">
          <source>The old behaviour of immediate croaking can be re-instated by setting &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; to some &lt;code&gt;FALSE&lt;/code&gt; value.</source>
          <target state="translated">立即呱呱叫的旧行为可以通过设置重新设置 &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; 一些 &lt;code&gt;FALSE&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="5b386f850ac3d208fd4890f0e6e16aecfa5e9221" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt; , can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">可以使用 &lt;code&gt;&quot;style&quot;&lt;/code&gt; 参数更改可以具有 &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;polar&quot;&lt;/code&gt; 值的旧显示格式样式。</target>
        </trans-unit>
        <trans-unit id="e9569a2edc0d7e856dea14bff6ac690edcc52042" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt;, can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ffd1da07401f04d08ba15b9c723b21da5d25d24" translate="yes" xml:space="preserve">
          <source>The old form of &lt;code&gt;gv_init_pvn()&lt;/code&gt;. It does not work with UTF-8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the &lt;code&gt;GV_ADDMULTI&lt;/code&gt; flag will be passed to &lt;code&gt;gv_init_pvn()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3404a80aca7096e4f7cc6df65a56468be124f24" translate="yes" xml:space="preserve">
          <source>The old form of gv_init_pvn(). It does not work with UTF8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the GV_ADDMULTI flag will be passed to gv_init_pvn().</source>
          <target state="translated">gv_init_pvn（）的旧形式。它不具有UTF8字符串，因为它没有flags参数。如果设置了 &lt;code&gt;multi&lt;/code&gt; 参数，则GV_ADDMULTI标志将传递给gv_init_pvn（）。</target>
        </trans-unit>
        <trans-unit id="79188e84f37b880e4a772b5ff3206627de3b874e" translate="yes" xml:space="preserve">
          <source>The old home for the module tests, you shouldn't put anything new in here. There are still some bits and pieces hanging around in here that need to be moved. Perhaps you could move them? Thanks!</source>
          <target state="translated">模块测试的老家,你不应该在这里放任何新东西。还有一些零碎的东西挂在这里,需要移动。也许你可以把它们搬走?谢谢你!</target>
        </trans-unit>
        <trans-unit id="37d530fbe2e5d190496e0bd800701dfa6c514e1c" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; , you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt; ; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt; , which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; .</source>
          <target state="translated">旧的包定界符是单引号，但现在双冒号是首选的定界符，部分原因是它对人类更易读，部分原因是对&lt;b&gt;emacs&lt;/b&gt;宏更易读。这也使C ++程序员感到自己知道发生了什么&amp;mdash;而不是使用单引号作为分隔符，这使Ada程序员感到自己知道发生了什么。因为仍然支持老式语法以实现向后兼容性，所以如果您尝试使用诸如 &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; 类的字符串，则将访问 &lt;code&gt;$owner::s&lt;/code&gt; ;也就是说，包 &lt;code&gt;owner&lt;/code&gt; 的$ s变量可能不是您的意思。使用括号消除歧义，例如 &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="511ae26f8725e1c7736ec75894aed8905e42064b" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt;, you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt;; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt;, which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9379928fc066063abf44caaff061ee5071ad9c7" translate="yes" xml:space="preserve">
          <source>The old style indented the note:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9dec9262d361c18938bccf6c6a18acfa10894f" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c9fb581904d8c9128af585c935239bf8557de2" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="translated">较旧（且可能已过时）的库&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf3a69ba409143423723e457fea838a29577af44" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da753c735f79a0349646d5159490ba674b8d624f" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="translated">较旧的库&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod :: SAX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="995ae7aa276ffe30824f52880be0efab53f1e92d" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;,
$bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; .</source>
          <target state="translated">add_bits（）的一个参数形式采用$ bitstring的&amp;ldquo; 1&amp;rdquo;和&amp;ldquo; 0&amp;rdquo;字符作为参数。这是 &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;, $bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="1b86570e54f795ca97d5fe14e7650da16943e0a5" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(pack(&quot;B*&quot;, $bitstring), length($bitstring))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb0ed6067910ab4f7c54b4b88cf43df00178824" translate="yes" xml:space="preserve">
          <source>The one parameter calling convention also still works.</source>
          <target state="translated">一个参数的调用惯例也依然有效。</target>
        </trans-unit>
        <trans-unit id="80912f94b4001d6702c4a5ac8c13128730d9bdf7" translate="yes" xml:space="preserve">
          <source>The one user (apart from the superuser) who has absolute control over a &lt;b&gt;file&lt;/b&gt;. A file may also have a &lt;b&gt;group&lt;/b&gt; of users who may exercise joint ownership if the real owner permits it. See &lt;b&gt;permission bits&lt;/b&gt;.</source>
          <target state="translated">对&lt;b&gt;文件&lt;/b&gt;具有绝对控制权的一个用户（超级用户除外）。文件也可以有一&lt;b&gt;组&lt;/b&gt;用户，如果真实所有者允许，则可以行使共同所有权。请参阅&lt;b&gt;权限位&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="ecb6da0a473e0cefde4e91abce89bab9a6e1b78a" translate="yes" xml:space="preserve">
          <source>The one-shot interface allows you to force the creation of a zip64 zip file by including the &lt;code&gt;Zip64&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf794f433c5b5ee5b62cabad4f9e0efe662e76bb" translate="yes" xml:space="preserve">
          <source>The only absolutely mandatory method. Called when the layer is pushed onto the stack. The &lt;code&gt;mode&lt;/code&gt; argument may be NULL if this occurs post-open. The &lt;code&gt;arg&lt;/code&gt; will be non-&lt;code&gt;NULL&lt;/code&gt; if an argument string was passed. In most cases this should call &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; to convert &lt;code&gt;mode&lt;/code&gt; into the appropriate &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; flags in addition to any actions the layer itself takes. If a layer is not expecting an argument it need neither save the one passed to it, nor provide &lt;code&gt;Getarg()&lt;/code&gt; (it could perhaps &lt;code&gt;Perl_warn&lt;/code&gt; that the argument was un-expected).</source>
          <target state="translated">唯一绝对强制的方法。在将层推入堆栈时调用。该 &lt;code&gt;mode&lt;/code&gt; 参数可以为NULL，如果发生这种情况后开放。该 &lt;code&gt;arg&lt;/code&gt; 将非 &lt;code&gt;NULL&lt;/code&gt; 如果参数字符串传递。在大多数情况下，除了层本身执行的任何操作之外，还应该调用 &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; 将 &lt;code&gt;mode&lt;/code&gt; 转换为适当的 &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; 标志。如果某个层不希望有参数，则它既不需要保存传递​​给它的参数，也不需要提供 &lt;code&gt;Getarg()&lt;/code&gt; （它可能会 &lt;code&gt;Perl_warn&lt;/code&gt; 指出该参数是意外的）。</target>
        </trans-unit>
        <trans-unit id="90a79e3c54ca5ed09d00dcfacad6096dece33202" translate="yes" xml:space="preserve">
          <source>The only characters this accepts are the decimal digits '0'..'9'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efd8a42e658c0f7e91c83e2d2d53f100f4033a8" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt; , (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="translated">唯一的区别是由于 &lt;code&gt;string_vianame&lt;/code&gt; 是运行时，而 &lt;code&gt;\N{}&lt;/code&gt; 是编译时。您不能在 &lt;code&gt;\N{}&lt;/code&gt; 内插值（因此 &lt;code&gt;\N{$variable}&lt;/code&gt; 不起作用）；如果输入名称未知，则 &lt;code&gt;string_vianame&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 而不是语法错误。</target>
        </trans-unit>
        <trans-unit id="77845b478b84dee4e594bd5bbec241147d4e6e80" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt;, (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;undef&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="341b8df1dab5c18fe08d27199395d7d12fe5908e" translate="yes" xml:space="preserve">
          <source>The only flag specified this time was G_SCALAR. That means that the &lt;code&gt;@_&lt;/code&gt; array will be created and that the value returned by</source>
          <target state="translated">这次指定的唯一标志是G_SCALAR。这意味着将创建 &lt;code&gt;@_&lt;/code&gt; 数组，并且由返回的值</target>
        </trans-unit>
        <trans-unit id="1be9c07fcdeba873e922d933912b59d6dffd7f9b" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt; . Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">唯一的插值是从 &lt;code&gt;\\&lt;/code&gt; 对中删除 &lt;code&gt;\&lt;/code&gt; 。因此， &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; 中的 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 实际上被视为连字符，并且没有可用的字符范围。替换 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; 中的 &lt;code&gt;\1&lt;/code&gt; 不能用作 &lt;code&gt;$1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02eece87de941c6c62eda48e906abba6c3ece7c9" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt;. Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;tr'''&lt;/code&gt; and &lt;code&gt;y'''&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;s'''&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12717cd3a47ff8f730f2ca2276f3a722ee0a85b7" translate="yes" xml:space="preserve">
          <source>The only issue left is to how to bootstrap</source>
          <target state="translated">唯一剩下的问题是如何启动</target>
        </trans-unit>
        <trans-unit id="77cda32153e2808e7ed17b43ef801a42c30a29bd" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; that</source>
          <target state="translated">唯一一种简单的语句是评估其副作用的表达式。每个简单的语句都必须以分号结尾，除非它是一个块中的最终语句，在这种情况下，分号是可选的。但是，如果该块占用多于一行，则无论如何都应使用分号，因为您最终可能会添加另一行。需要注意的是有像运营商 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; ，并 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; 这</target>
        </trans-unit>
        <trans-unit id="f705477ccbb186a38ab86005af82f68dd900e475" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;eval {}&lt;/code&gt;, &lt;code&gt;sub {}&lt;/code&gt;, and &lt;code&gt;do {}&lt;/code&gt; that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e309b7f80a25c25de4d7facad82c2d1078752823" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;&quot;Prior to Perl v5.22&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f747c4ca5428591254eb88eeb68548667575b4e" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;Prior to Perl v5.22&lt;/a&gt;).</source>
          <target state="translated">几乎可以肯定，此编译指示的唯一合法使用是每个文件只有一个文件（在顶部，具有文件范围），因为该文件很可能只会以一种编码来编写。在v5.22 &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;之前的&lt;/a&gt; Perls中有更多限制（请参阅Perl v5.22之前的版本）。</target>
        </trans-unit>
        <trans-unit id="34c58516de1f8035b02dd5ba10465691170b3177" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt; . To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt; . Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt; , which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="translated">Perl可能支持的唯一多字节（或宽字符）语言环境是UTF-8。这是由于实施的困难，高质量的UTF-8语言环境现已在世界上的每个地区（&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;）发布的事实所致。可以使用&lt;a href=&quot;encode&quot;&gt;编码&lt;/a&gt;转换为您的语言环境的模块。因此，如果您使用这些语言环境之一（例如Big5或Shift JIS），则必须执行这些操作之一。对于UTF-8语言环境，在没有完全UTF-8语言环境支持的Perls（v5.20之前）中，它们可能工作得相当好（取决于您的C库实现），只是因为它们和Perl都存储了占用字符的字符多个字节以相同的方式。但是，即使不是大多数，某些C库实现也可能无法在 &lt;code&gt;LC_CTYPE&lt;/code&gt; 下正确处理Latin-1范围（128-255）中上半部分的字符。要查看某个字符在语言环境下是否为特定类型，Perl使用了 &lt;code&gt;isalnum()&lt;/code&gt; 之类的函数。您的C库可能不适用于具有这些功能的UTF-8语言环境，而是只能在较新的广泛库函数下工作，例如 &lt;code&gt;iswalnum()&lt;/code&gt; ，Perl不使用。这些多字节语言环境被视为单字节语言环境，并且将具有以下限制。从Perl v5.22开始，当Perl检测到它不完全支持的多字节语言环境时，将引发警告消息。</target>
        </trans-unit>
        <trans-unit id="18871d07c0f1be22042f9cbee3498004b8a18ce9" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;https://unicode.org/Public/cldr/2.0.1/&quot;&gt;https://unicode.org/Public/cldr/2.0.1/&lt;/a&gt; for ones that are already set-up, but from an earlier version; &lt;a href=&quot;https://unicode.org/Public/cldr/latest/&quot;&gt;https://unicode.org/Public/cldr/latest/&lt;/a&gt; for the most up-to-date, but you have to extract the POSIX information yourself), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt;. To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt;. Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt;, which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c17b3d145791de4c679a21722f34ee793cec0ff" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3A%3Astring_vianame%28name%29&quot;&gt;&quot;charnames::string_vianame(name)&quot; in charnames&lt;/a&gt;, and &lt;a href=&quot;Unicode::UCD#namedseq%28%29&quot;&gt;&quot;namedseq()&quot; in Unicode::UCD&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ecbc2496d990405244fb5517f23afeb52e9228" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame(name) in charnames&lt;/a&gt;, and &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Perl当前支持的唯一非字符属性是&amp;ldquo;命名序列&amp;rdquo;，其中代码点序列被赋予一个名称，通常被视为单个实体。（Perl通过 &lt;code&gt;\N{...}&lt;/code&gt; 双引号结构，&lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames中的charnames :: string_vianame（name）&lt;/a&gt;和&lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;Unicode :: UCD中的namedseq（）&lt;/a&gt;支持这些功能。</target>
        </trans-unit>
        <trans-unit id="4392ba6f21132243d1d665e363dbf9f2d5cd7f44" translate="yes" xml:space="preserve">
          <source>The only non-single-byte locale Perl supports is (starting in v5.20) UTF-8. This means that code points above 255 are treated as Unicode no matter what locale is in effect (since UTF-8 implies Unicode).</source>
          <target state="translated">Perl 唯一支持的非单字节语言是 UTF-8(从 v5.20 开始)。这意味着,无论使用的是哪种locale,255以上的代码点都会被视为Unicode(因为UTF-8意味着Unicode)。</target>
        </trans-unit>
        <trans-unit id="9a67bc69297226e55a92fe7a2acd416579cf6146" translate="yes" xml:space="preserve">
          <source>The only objective benefit to using &lt;code&gt;DirHandle&lt;/code&gt; is that it avoids namespace pollution by creating globs to hold directory handles.</source>
          <target state="translated">使用 &lt;code&gt;DirHandle&lt;/code&gt; 的唯一客观好处是，它通过创建glob来保存目录句柄来避免名称空间污染。</target>
        </trans-unit>
        <trans-unit id="29b92533d26d29124ecd17a1f17bcca141dd3115" translate="yes" xml:space="preserve">
          <source>The only other constraint is you must pre-declare how many tests you plan to run. This is in case something goes horribly wrong during the test and your test program aborts, or skips a test or whatever. You do this like so:</source>
          <target state="translated">唯一的限制是你必须预先声明你计划运行多少测试。这是为了防止在测试过程中出现可怕的错误,你的测试程序中止,或跳过一个测试或其他什么。你可以这样做。</target>
        </trans-unit>
        <trans-unit id="c629e4aca342ff5d679b1354d5badb624d786fd5" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; . Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="translated">可能不应该发出警告的唯一地方是，如果优化导致甚至完全不尝试整个模式匹配。例如，Perl可能会发现，要使字符串与某个正则表达式模式匹配，该字符串必须包含子字符串 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 。在尝试进行匹配之前，Perl可能会寻找该子字符串，如果找不到该子字符串，则在没有实际尝试的情况下立即使匹配失败。因此即使字符串包含高于Unicode的代码点，也不会生成警告。</target>
        </trans-unit>
        <trans-unit id="2a1424cb465056db403b0376b90df7285a39a496" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt;. Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f03961d151195642787106427ad37fb0df08a21" translate="yes" xml:space="preserve">
          <source>The only pragmas to be completely supported are: &lt;code&gt;use warnings&lt;/code&gt;, &lt;code&gt;use strict&lt;/code&gt;, &lt;code&gt;use bytes&lt;/code&gt;, &lt;code&gt;use integer&lt;/code&gt; and &lt;code&gt;use feature&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7dc3eb2b3b66b20134df38443b06998c7b78e71" translate="yes" xml:space="preserve">
          <source>The only purpose of this step is to create the needed directories, and let you know the names of these directories. From the output you can see that the directory for the extension is</source>
          <target state="translated">这一步的唯一目的是创建需要的目录,并让你知道这些目录的名称。从输出中你可以看到,扩展的目录是</target>
        </trans-unit>
        <trans-unit id="e4350c2629055827ad3a8b68cc619a2e785707ba" translate="yes" xml:space="preserve">
          <source>The only required argument is &lt;a href=&quot;IO::Socket#Domain&quot;&gt;&quot;Domain&quot; in IO::Socket&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b743cce5d7490a9e24b6e3b1af9c9095cbf1cfd" translate="yes" xml:space="preserve">
          <source>The only required part is the first field, the name of a module (e.g. Foo::Bar, i.e.</source>
          <target state="translated">唯一需要的部分是第一个字段,即一个模块的名称(如Foo::Bar,即。</target>
        </trans-unit>
        <trans-unit id="18bf9d2d31226fde65cb844d15b4e9ac5dd2e6d9" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are &lt;code&gt;GV_SUPER&lt;/code&gt; and &lt;code&gt;SVf_UTF8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47d064470efbb85a4c64c4b51a76380fc85cda0" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are GV_SUPER and SVf_UTF8.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 的唯一有效值为GV_SUPER和SVf_UTF8。</target>
        </trans-unit>
        <trans-unit id="27c03514e890f7e1e455be24f92d8de38867990a" translate="yes" xml:space="preserve">
          <source>The only thing to note is that, in both the static and virtual methods, the method name is not passed via the stack--it is used as the first parameter to</source>
          <target state="translated">唯一需要注意的是,在静态和虚拟方法中,方法名不是通过堆栈传递的--它是作为</target>
        </trans-unit>
        <trans-unit id="9a6d4c47eb4eb3548f61bca4b08d9e197f6e1287" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine</source>
          <target state="translated">您唯一需要记住的是 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程</target>
        </trans-unit>
        <trans-unit id="3a8286223f476561d867d00238ced07bc0080bf9" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;import&lt;/code&gt; subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="befc7f9200d677e41e635df70642f3120f18f3ee" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. When used as a number, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt; ; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt; ; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="translated">在Perl中需要声明的唯一内容是报表格式和子例程（有时甚至不是子例程）。标量变量将保留未定义的值（ &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），直到为其分配了已定义的值为止，该值不是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。当用作数字时， &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 被视为 &lt;code&gt;0&lt;/code&gt; ；当用作字符串时，将其视为空字符串 &lt;code&gt;&quot;&quot;&lt;/code&gt; ；当用作未分配的参考时，将其视为错误。如果启用警告，则在将 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 视为字符串或数字时，系统会通知您未初始化的值。好吧，通常。布尔上下文，例如：</target>
        </trans-unit>
        <trans-unit id="8063526283668c78bfe80f0053d75f81f3e00c7f" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;undef&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;undef&lt;/code&gt;. When used as a number, &lt;code&gt;undef&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt;; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt;; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;undef&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31db2a79cbb61c12ae686554ebaa8cf24c12eba8" translate="yes" xml:space="preserve">
          <source>The only times that you absolutely</source>
          <target state="translated">只有在你绝对</target>
        </trans-unit>
        <trans-unit id="cdb480d4e9cef712b05b3e3ca053bd2714b2800c" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt; .</source>
          <target state="translated">更改此设置的唯一方法是为 &lt;code&gt;'|'&lt;/code&gt; 提供您自己的子例程 。</target>
        </trans-unit>
        <trans-unit id="cc6185c346e8349db594c7e55f3c51f34e33f48b" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65da34730ca57e068ebb9d99972660fe1a63a25" translate="yes" xml:space="preserve">
          <source>The only way to override a lexical warnings setting is with the &lt;b&gt;-W&lt;/b&gt; or &lt;b&gt;-X&lt;/b&gt; command line flags.</source>
          <target state="translated">覆盖词法警告设置的唯一方法是使用&lt;b&gt;-W&lt;/b&gt;或&lt;b&gt;-X&lt;/b&gt;命令行标志。</target>
        </trans-unit>
        <trans-unit id="7ea2eaf8e5a3a274ae0f1dbb910613954b91ee9b" translate="yes" xml:space="preserve">
          <source>The only way you will ever be allowed to rebase or modify the history of a pushed branch is to delete it and push it as a new branch under the same name. Please think carefully about doing this. It may be better to sequentially rename your branches so that it is easier for others working with you to cherry-pick their local changes onto the new version. (XXX: needs explanation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd9c5131dd8145825db3c00e95fdf65545c95f3" translate="yes" xml:space="preserve">
          <source>The op tree is connected in two ways: you can imagine that there are two &quot;routes&quot; through it, two orders in which you can traverse the tree. First, parse order reflects how the parser understood the code, and secondly, execution order tells perl what order to perform the operations in.</source>
          <target state="translated">op树有两种连接方式:你可以想象有两条 &quot;路线 &quot;穿过它,有两种顺序可以遍历这棵树。首先,解析顺序反映了解析器如何理解代码,其次,执行顺序告诉perl以什么顺序执行操作。</target>
        </trans-unit>
        <trans-unit id="87587f650625db0a4ecb1818a87bdf007aa521f9" translate="yes" xml:space="preserve">
          <source>The op tree representing the code block is returned. This is always a real op, never a null pointer. It will normally be a &lt;code&gt;lineseq&lt;/code&gt; list, including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops. No ops to construct any kind of runtime scope are included by virtue of it being a block.</source>
          <target state="translated">返回表示代码块的操作树。这始终是一个真实的操作，绝不是空指针。它通常是一个 &lt;code&gt;lineseq&lt;/code&gt; 列表，包括 &lt;code&gt;nextstate&lt;/code&gt; 或等效的操作。由于它是一个块，因此不包含任何构造任何类型的运行时范围的操作。</target>
        </trans-unit>
        <trans-unit id="0ada1b492ff1e32feecd23ad2e48d8b585f13df5" translate="yes" xml:space="preserve">
          <source>The op tree representing the expression is returned. If an optional expression is absent, a null pointer is returned, otherwise the pointer will be non-null.</source>
          <target state="translated">返回代表表达式的操作树。如果没有可选的表达式,则返回一个空指针,否则指针将是非空的。</target>
        </trans-unit>
        <trans-unit id="e036bcd0d780fe688c97dce4eafd340bcf362abb" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;&quot;newSTATEOP&quot;&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ec717bc605b587bc78dee46e74bc74f77b59be" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="translated">返回表示该语句的操作树。如果语句为空，则可能为空指针，例如，如果该语句实际上是子例程定义（具有编译时的副作用）。如果不为null，则将由ops直接实现该语句，适合传递给&lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;。它通常不会包含 &lt;code&gt;nextstate&lt;/code&gt; 或等效操作（除了那些完全包含在语句内的作用域中嵌入的操作）。</target>
        </trans-unit>
        <trans-unit id="2254139a8dcdd28ca766e4d41d0739d872c7e21b" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;&quot;newSTATEOP&quot;&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a48ae410aca9d3fe9a16a19fa26233018ca671" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="translated">返回表示该语句的操作树。如果语句为空，则可能为空指针，例如，如果该语句实际上是子例程定义（具有编译时的副作用）。如果不为null，则它将是&lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;调用的结果，通常包括 &lt;code&gt;nextstate&lt;/code&gt; 或等效的op。</target>
        </trans-unit>
        <trans-unit id="80258368ca90132ffffe94b685646de5d3e0a9ff" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement sequence is returned. This may be a null pointer if the statements were all null, for example if there were no statements or if there were only subroutine definitions (which have compile-time side effects). If not null, it will be a &lt;code&gt;lineseq&lt;/code&gt; list, normally including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops.</source>
          <target state="translated">返回表示语句序列的操作树。如果语句全为空，则可能为空指针，例如，如果不存在任何语句，或者仅存在子例程定义（具有编译时副作用）。如果不为null，它将是一个 &lt;code&gt;lineseq&lt;/code&gt; 列表，通常包括 &lt;code&gt;nextstate&lt;/code&gt; 或等效的ops。</target>
        </trans-unit>
        <trans-unit id="535ccca6a54b74bb28aa7a40bc1a8b66e55f76db" translate="yes" xml:space="preserve">
          <source>The op tree to unpack the arguments from the stack at runtime is returned. This op tree should appear at the beginning of the compiled function. The caller may wish to use &lt;a href=&quot;#op_append_list&quot;&gt;&quot;op_append_list&quot;&lt;/a&gt; to build their function body after it, or splice it together with the body before calling &lt;a href=&quot;#newATTRSUB&quot;&gt;&quot;newATTRSUB&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35c6433e7899b6be9854e9907788616c4dfa0ff" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;&quot;OP flags abbreviations&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee004e116194c04a5a9d3789b699d566539ba78d" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP flags abbreviations&lt;/a&gt;).</source>
          <target state="translated">op标志（&lt;b&gt;ex'sK / 2'&lt;/b&gt;）在（&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP标志缩写&lt;/a&gt;）中进行了描述。</target>
        </trans-unit>
        <trans-unit id="8eec999d2cf9d026309d4e24a85ebd9a75290847" translate="yes" xml:space="preserve">
          <source>The open source license that Larry Wall created for Perl, maximizing Perl&amp;rsquo;s usefulness, availability, and modifiability. The current version is 2. (&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;).</source>
          <target state="translated">拉里&amp;middot;沃尔（Larry Wall）为Perl创建的开源许可证，使Perl的有用性，可用性和可修改性最大化。当前版本为2。（&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d076872f9624d7a17cf4c11c33523c71a8396f8e" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given $cmd and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="translated">open2()函数运行给定的$cmd,并连接$chld_out进行读取和$chld_in进行写入。这就是你认为应该工作的东西,当你尝试的时候</target>
        </trans-unit>
        <trans-unit id="2904189d67cdca2709e7a78ebf9563187c0c5785" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given command and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793bd01a6b2dc5e14b8e95bd14b22d7c8c213b3b" translate="yes" xml:space="preserve">
          <source>The operand of some types of regop is a literal string; for others, it is a regop leading into a sub-program. In particular, the operand of a &lt;code&gt;BRANCH&lt;/code&gt; node is the first regop of the branch.</source>
          <target state="translated">某些类型的regop的操作数是文字字符串；对于其他人来说，这是导致子程序重新使用的方法。特别是， &lt;code&gt;BRANCH&lt;/code&gt; 节点的操作数是分支的第一个重新操作。</target>
        </trans-unit>
        <trans-unit id="cf8df21203ce7e715434391039cee96dd7ffc65d" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt; ) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="translated">操作系统，设备驱动程序，C库和Perl运行时系统都共同使程序员能够将单个字符（ &lt;code&gt;\n&lt;/code&gt; ）视为行终止符，而无需考虑外部表示形式。在许多操作系统上，本机文本文件表示形式与内部表示形式匹配，但是在某些平台上， &lt;code&gt;\n&lt;/code&gt; 的外部表示形式由多个字符组成。</target>
        </trans-unit>
        <trans-unit id="3f9b4af2476a3677a8d756957b80eb4422b5ccdb" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt;) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6975d92732aba7cc117877a890c8662a217abc" translate="yes" xml:space="preserve">
          <source>The operation of the &lt;code&gt;%ENV&lt;/code&gt; array depends on the translation of the logical name</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; 数组的操作取决于逻辑名的转换</target>
        </trans-unit>
        <trans-unit id="1fcdc1a8281a2698369d4d0c5ac8331125832af5" translate="yes" xml:space="preserve">
          <source>The operation of the bval option warrants some discussion. Here is the definition of bval from the Berkeley DB 1.85 recno manual page:</source>
          <target state="translated">bval选项的操作值得讨论。以下是Berkeley DB 1.85 recno手册中对bval的定义。</target>
        </trans-unit>
        <trans-unit id="f8261c0231b653877a248b54abf80f0b93e9f204" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; , and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">此方法的操作还受 &lt;code&gt;archlibexp&lt;/code&gt; ， &lt;code&gt;cccdlflags&lt;/code&gt; ， &lt;code&gt;ccflags&lt;/code&gt; ， &lt;code&gt;optimize&lt;/code&gt; 和 &lt;code&gt;cc&lt;/code&gt; 条目 &lt;code&gt;Config.pm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebf43357cdf326de3a784f122cc30174e4d696c9" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt;, &lt;code&gt;cccdlflags&lt;/code&gt;, &lt;code&gt;ccflags&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt;, and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea94336b097e013eb83f32bbba38514d8eaa887" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; , and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">此方法的操作还受 &lt;code&gt;lddlflags&lt;/code&gt; ， &lt;code&gt;shrpenv&lt;/code&gt; 和 &lt;code&gt;ld&lt;/code&gt; 条目 &lt;code&gt;Config.pm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9af43d4cfed7d96567a247c3d560f72f4c234173" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt;, &lt;code&gt;shrpenv&lt;/code&gt;, and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf8b3d14dd93250118a75dcead35353084d8d3c" translate="yes" xml:space="preserve">
          <source>The operations that are affected by locale are:</source>
          <target state="translated">受地域影响的业务有:</target>
        </trans-unit>
        <trans-unit id="4ea8be07a0890d457a63bbbdc0361b2f2a0630bf" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="translated">运算符 &lt;code&gt;not&lt;/code&gt; 不是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 的有效键。但是，如果运算符 &lt;code&gt;!&lt;/code&gt; 过载则该相同的实现将被用于 &lt;code&gt;not&lt;/code&gt; （因为两个操作符的优先仅不同）。</target>
        </trans-unit>
        <trans-unit id="e62d966af3836010344e801b17dfde35cf80a445" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;use overload&lt;/code&gt;. However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cd830e88c435efad5c7c64c9421f0a7b44115d" translate="yes" xml:space="preserve">
          <source>The operator may be assigned to if both the 2nd and 3rd arguments are legal lvalues (meaning that you can assign to them):</source>
          <target state="translated">如果第2个和第3个参数都是合法的l值(意味着你可以对它们进行赋值),则可以对该运算符进行赋值。</target>
        </trans-unit>
        <trans-unit id="5904b513e41f7f0a3948a698bdf838835b48e7f3" translate="yes" xml:space="preserve">
          <source>The opname, as in &lt;b&gt;'add[t1]'&lt;/b&gt;, may be followed by op-specific information in parentheses or brackets (ex &lt;b&gt;'[t1]'&lt;/b&gt;).</source>
          <target state="translated">与&lt;b&gt;&amp;ldquo; add [t1]&amp;rdquo;中的操作名一样&lt;/b&gt;，可以在括号或方括号（例如&lt;b&gt;&amp;ldquo; [t1]&amp;rdquo;&lt;/b&gt;）后跟操作特定的信息。</target>
        </trans-unit>
        <trans-unit id="4a764821c24945c6b9d29fb8f23336e4895936b8" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;&quot;catdir&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a01865affffe01d68458832d996fae1c28b752" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;.</source>
          <target state="translated">的相对&lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da407a5a37cdd431c49815120665c0495df714be" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir%28%29&quot;&gt;&quot;catdir()&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b12f229c6486073ad774a1dc49a9e1e9fe1afd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir()&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#catdir()&quot;&gt;catdir（）&lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="cd5ab607bfc9b28a62d0ee095cfa34da1a0a1edd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;../spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;../spec#catdir&quot;&gt;catdir（）&lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="72e60997864c75a6b42c630a5cd3b7d0d96cb145" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;File::Spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebefb2669972c85d8b9e00b79503067268d1b9d" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt; .</source>
          <target state="translated">与 &lt;code&gt;catdir()&lt;/code&gt; 相反。</target>
        </trans-unit>
        <trans-unit id="ce2ff0fee10bb0851a17501763837139e03ed67c" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a36830f45796b87c226ab6318291313f5d62c75" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;encode&lt;/code&gt;: expects a JSON text and tries to parse it, returning the resulting simple scalar or reference. Croaks on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81bb459c3e1d2a0353a3947d9d6ef14ef3f4c25" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;encode_json&lt;/code&gt;: expects an UTF-8 (binary) string and tries to parse that as an UTF-8 encoded JSON text, returning the resulting reference. Croaks on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9058f904dc63789872dd9542a7b1316b89449f40" translate="yes" xml:space="preserve">
          <source>The opset and opset_to_ops functions can be used to convert from a list of operators to an opset and</source>
          <target state="translated">opset和opset_to_ops函数可以用来将运算符列表转换为OPSET和</target>
        </trans-unit>
        <trans-unit id="e0e7014b5567d7771bd0933f5acd1310aac22e0f" translate="yes" xml:space="preserve">
          <source>The optag name used must not be defined already (define_optag will croak if it is already defined). Optag names are global to the perl process and optag definitions cannot be altered or deleted once defined.</source>
          <target state="translated">所使用的optag名称不能是已经定义好的 (如果已经定义好了,define_optag就会崩溃)。optag名称是全局性的,一旦定义了optag,就不能更改或删除。</target>
        </trans-unit>
        <trans-unit id="16ae99f8eb8c5eb6cf77bcb07b90faddacb6b646" translate="yes" xml:space="preserve">
          <source>The optimizer-specific information is used to avoid entering (a slow) regex engine on strings that will not definitely match. If the &lt;code&gt;isall&lt;/code&gt; flag is set, a call to the regex engine may be avoided even when the optimizer found an appropriate place for the match.</source>
          <target state="translated">优化程序特定的信息用于避免在肯定不会匹配的字符串上输入（缓慢的）正则表达式引擎。如果设置了 &lt;code&gt;isall&lt;/code&gt; 标志，即使优化器找到了合适的匹配位置，也可以避免对正则表达式引擎的调用。</target>
        </trans-unit>
        <trans-unit id="c2bcebf69d65f38d819f2ef47d3870130b4b4a34" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="translated">该选项不带参数，可以通过在其前面加上&amp;ldquo; no&amp;rdquo;或&amp;ldquo; no-&amp;rdquo;来取反。例如 &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; 将允许 &lt;code&gt;--foo&lt;/code&gt; （值1将被分配），以及 &lt;code&gt;--nofoo&lt;/code&gt; 和 &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; （值0将被分配）。如果该选项具有别名，则这也适用于别名。</target>
        </trans-unit>
        <trans-unit id="d9db329442e437205bd55b086c5b9e99baf5686d" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--no-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05bc04ade0e6f0bfb276419b00c5f9d55f933117" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt; , when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="translated">该选项不带参数，并且每次出现在命令行中时都将增加1。例如， &lt;code&gt;&quot;more+&quot;&lt;/code&gt; 与 &lt;code&gt;--more --more --more&lt;/code&gt; 一起使用时，将使该值增加3倍，从而得出3的值（前提是该值是0或首先未定义）。</target>
        </trans-unit>
        <trans-unit id="d8e253e20697ea76ff418e0292092a5b47f9f4f6" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt;, when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c73626524fd7b39cf23cb6ceb0594624a4560f" translate="yes" xml:space="preserve">
          <source>The option name as specified to the GetOptions() function is called the option</source>
          <target state="translated">在GetOptions()函数中指定的选项名称被称为选项。</target>
        </trans-unit>
        <trans-unit id="28e883d6a03c91177fe93b06a907181312e7662a" translate="yes" xml:space="preserve">
          <source>The option names defined below are case insensitive and can be optionally prefixed by a '-'. So all of the following are valid</source>
          <target state="translated">下面定义的选项名不区分大小写,可以选择在前面加上'-'。所以以下所有选项都是有效的</target>
        </trans-unit>
        <trans-unit id="24d6abd722573e6cae42881df7cf4d56ac582b1b" translate="yes" xml:space="preserve">
          <source>The option requires an argument of the given type. Supported types are:</source>
          <target state="translated">该选项需要一个给定类型的参数。支持的类型有:</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">可选的</target>
        </trans-unit>
        <trans-unit id="3cb07c5a1f900e41d71b7af9007db9793c77a65e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;rules&lt;/code&gt; attribute provides direction on which tests should be run in parallel and which should be run sequentially. If no rule data structure is provided, a default data structure is used which makes every test eligible to be run in parallel:</source>
          <target state="translated">可选的 &lt;code&gt;rules&lt;/code&gt; 属性提供了应该并行运行测试以及应该顺序运行测试的方向。如果没有提供规则数据结构，则使用默认数据结构，该结构使每个测试都可以并行运行：</target>
        </trans-unit>
        <trans-unit id="0a173dcd400a0274b32b98f040a162b1b1782227" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt; , in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="translated">可选参数被视为文字字符串，除非它们以 &lt;code&gt;~&lt;/code&gt; 或 &lt;code&gt;!&lt;/code&gt; 开头。，在这种情况下，它们被解释为正则表达式（可能取反）。</target>
        </trans-unit>
        <trans-unit id="cf1d2e0ff9c2439cc3ca174e85a170cee0c435c9" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;, in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a457723dc3fc51f575186932ad8e9bfa084daea" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;anyinflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caed88218bf3ae5d8b6dcab0958f36fc2927ec02" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;anyuncompress&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="131098ff902c48e8458d96c59269d22ab860e8b2" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;bunzip2&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6198111cc9801f305996de3eeaa06e0db91b4218" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;bzip2&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c4c457d99260789b76c08eab24f06adc17d2c1" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;deflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1a96727af7ce5f83a4cb5ede379486da415347" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;gunzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a1759e80fa595487da188a1ae20babdbb62651" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;gzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f90f77041e19f7f96b84e59406c9ba0fcd6ff0" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;inflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34c4bd457be8b3eca1d1b50327dc8555ebf3e0c" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;rawdeflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da3088b2b3f74fb962460f08bf6c521a6489c8dc" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;rawinflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564a4703e441e1aa249188b7a46aeee40f3cb3e0" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;unzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1bd6c00e2144ea2637c42a56845ca5419370d66" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;zip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ca67d9f48cf9586e57f2ed1e1217218181099d" translate="yes" xml:space="preserve">
          <source>The optional second parameter is ignored if it is larger than the actual length of the first parameter string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a213bd4ecadb16ed12c21fa427d78bb53fa09a37" translate="yes" xml:space="preserve">
          <source>The options listed above customize parts of the default header, but setting &lt;code&gt;html_header&lt;/code&gt; or &lt;code&gt;html_footer&lt;/code&gt; completely overrides the built-in header or footer. These may be useful if you want to use template tags instead of literal HTML headers and footers or are integrating converted POD pages in a larger website.</source>
          <target state="translated">上面列出的选项可自定义默认标题的各个部分，但是设置 &lt;code&gt;html_header&lt;/code&gt; 或 &lt;code&gt;html_footer&lt;/code&gt; 会完全覆盖内置的标题或页脚。如果您要使用模板标签而不是原义的HTML标头和页脚，或者将转换后的POD页面集成到较大的网站中，则这些选项可能很有用。</target>
        </trans-unit>
        <trans-unit id="01a4d13b9aa02b31aa3157b7bf6c6d232ea80269" translate="yes" xml:space="preserve">
          <source>The options listed in this section control how the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d081dbc5fcc08b3b44f6576034c6838b070bec" translate="yes" xml:space="preserve">
          <source>The options to this argument is a list of either directories that are searched recursively, or files. (Usually you wouldn't specify files, but just dirs.) Or you can just specify an empty-list, as in $name2path; with the &lt;code&gt;inc&lt;/code&gt; option on, as it is by default.</source>
          <target state="translated">该参数的选项是递归搜索目录或文件的列表。（通常，您将不指定文件，而仅指定目录。）或者您可以仅指定一个空列表，如$ name2path中所示；与 &lt;code&gt;inc&lt;/code&gt; 上，因为它是默认选项。</target>
        </trans-unit>
        <trans-unit id="f0865be52cedbd9c729cf95a5b09eba31832648b" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">optree在线程之间共享。这意味着optree有可能会超过创建它的特定线程（因此是解释器实例）的寿命，因此真正的Perl标量不能存储在optree中。而是使用紧凑形式，该形式只能存储整数（有符号和无符号），字符串或 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 的值-引用和浮点值是字符串化的。如果需要存储多个值或复杂的结构，则应序列化它们，例如使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 。记录了从 &lt;code&gt;%^H&lt;/code&gt; 删除哈希键的过程，并且可以 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; undef值的key区别开来。</target>
        </trans-unit>
        <trans-unit id="758267caaf6c4060844acf8b5ceecd9fefe29a51" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;undef&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;pack&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;undef&lt;/code&gt; with &lt;code&gt;exists&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c80c62d3615e8dcdce9b967100a640447d19ae" translate="yes" xml:space="preserve">
          <source>The order in which objects are destroyed during the global destruction before the program exits is unpredictable. This means that any objects contained by your object may already have been destroyed. You should check that a contained object is defined before calling a method on it:</source>
          <target state="translated">在程序退出前的全局销毁过程中,对象被销毁的顺序是不可预测的。这意味着你的对象所包含的任何对象可能已经被销毁了。在调用对象的方法之前,你应该先检查是否定义了一个包含的对象。</target>
        </trans-unit>
        <trans-unit id="1362f44821baf70a0c53e26c223d4e933d506d90" translate="yes" xml:space="preserve">
          <source>The order in which this test was run for the given test suite result.</source>
          <target state="translated">对于给定的测试套件结果,该测试的运行顺序。</target>
        </trans-unit>
        <trans-unit id="49bfec1872d74cc3aa3b51bdca30781b5d81ee87" translate="yes" xml:space="preserve">
          <source>The order into which &lt;b&gt;characters&lt;/b&gt; sort. This is used by &lt;b&gt;string&lt;/b&gt; comparison routines to decide, for example, where in this glossary to put &amp;ldquo;collating sequence&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;字符&lt;/b&gt;排序的顺序。这是使用&lt;b&gt;字符串&lt;/b&gt;比较例程来决定，例如，在本词汇表中把&amp;ldquo;排序序列&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="90461643a4b9bcbbb16f181372c5e7705b398666" translate="yes" xml:space="preserve">
          <source>The order of any groups including scripts is not changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717cecbd54045d9533e4eb5b41c7c271d10ce913" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open2().</source>
          <target state="translated">参数的顺序与open2()不同。</target>
        </trans-unit>
        <trans-unit id="1338c98402171198f17cc3c818e89af7db3bfea3" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open3().</source>
          <target state="translated">参数的顺序与open3()不同。</target>
        </trans-unit>
        <trans-unit id="c7058991786845d90ace9e46987253e3ce531354" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57a83be29caa0cba0eac2c66aec01c8ecc059c8" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of EXPR, or the pattern contained by capture group</source>
          <target state="translated">顺序与EXPR的结果的正则表达式或捕获组所包含的模式相同。</target>
        </trans-unit>
        <trans-unit id="0f9c7f78b473deec8b2b7b3c5ae964aaebd4ae76" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ).</source>
          <target state="translated">原始的 &lt;code&gt;MD5&lt;/code&gt; 接口是由尼尔&amp;middot;温顿（ &lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; Winton）（N.Winton@axion.bt.co.uk）编写的。</target>
        </trans-unit>
        <trans-unit id="a967938ebcc10e8da7bfe2a06eaff58eb4186ec0" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb97de2fdb41a38605a8a09e6520652a52c56e7" translate="yes" xml:space="preserve">
          <source>The original Dylan paper</source>
          <target state="translated">原版迪伦纸</target>
        </trans-unit>
        <trans-unit id="50fea78ce2537fb78816d81a4d2374f6c7eff868" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af612d63faee2dc3856c86fd5cc671079598e557" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">原始的Pod :: Text包含通过termcap序列进行格式化的代码，尽管默认情况下未启用它，并且使其完全无法正常工作。此重写甚至都没有尝试这样做，但是它的一个子类可以。寻找&lt;a href=&quot;text/termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07dd5b1a0e82d303f2b0b28746eab063467b6ba7" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; . Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden.</source>
          <target state="translated">原始UTF-8规范最多允许6个字节，以允许对最大 &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; 的数字进行编码。Perl继续允许这样做，并已将其扩展到最多13个字节，以对代码点进行编码，直到可以容纳64位字为止。但是，如果您将其中的任何一项输出为不可移植的，Perl将发出警告。并且在严格的UTF-8输入协议下，它们是禁止的。</target>
        </trans-unit>
        <trans-unit id="00b0e9de1cd640deb40f9e9ac2ea76a7fdd363f8" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt;. Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden. In addition, it is now illegal to use a code point larger than what a signed integer variable on your system can hold. On 32-bit ASCII systems, this means &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; is the legal maximum (much higher on 64-bit systems).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e54c9386e1df6efdb32bc51b43d382c1fa2bb3" translate="yes" xml:space="preserve">
          <source>The original culture of the pre-populist Internet and the deeply-held beliefs of Perl's author, Larry Wall, gave rise to the free and open distribution policy of Perl. Perl is supported by its users. The core, the standard Perl library, the optional modules, and the documentation you're reading now were all written by volunteers.</source>
          <target state="translated">在互联网流行前的原始文化和Perl作者Larry Wall深深的信念,造就了Perl的免费开放发行政策。Perl得到了用户的支持。核心、标准的Perl库、可选模块以及你现在阅读的文档都是由志愿者编写的。</target>
        </trans-unit>
        <trans-unit id="12a169f5e5252000915162d740c1f7fb51701fdf" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_get_call_checker_flags&quot;&gt;&quot;cv_get_call_checker_flags&quot;&lt;/a&gt;, which does not return checker flags. When using a checker function returned by this function, it is only safe to call it with a genuine GV as its &lt;code&gt;namegv&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0e3050b313150315f2790edd37f73f93a916ca" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;&quot;cv_set_call_checker_flags&quot;&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility. The effect of that flag setting is that the check function is guaranteed to get a genuine GV as its &lt;code&gt;namegv&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124cee86525fe9ae3fd7e1b40184ae6b8c5be548" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility.</source>
          <target state="translated">&lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;的原始形式，将其传递给 &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; 标志以实现向后兼容。</target>
        </trans-unit>
        <trans-unit id="03b164c5369f7a3512c3a8ff6e7ba584a97c85cb" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="translated">CPAN Meta文件的原始格式为&lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt;，相应的文件名为</target>
        </trans-unit>
        <trans-unit id="12304d794d559e0c5fe4691017042f08f8d52e43" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;yaml&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0efcec67bc372bca64df41283c31757275dca6" translate="yes" xml:space="preserve">
          <source>The original impetus for &lt;code&gt;Perl_langinfo()&lt;/code&gt; was so that code that needs to find out the current currency symbol, floating point radix character, or digit grouping separator can use, on all systems, the simpler and more thread-friendly &lt;code&gt;nl_langinfo&lt;/code&gt; API instead of &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt; which is a pain to make thread-friendly. For other fields returned by &lt;code&gt;localeconv&lt;/code&gt;, it is better to use the methods given in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; to call &lt;a href=&quot;posix#localeconv&quot;&gt;&lt;code&gt;POSIX::localeconv()&lt;/code&gt;&lt;/a&gt;, which is thread-friendly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3411d71283c2f07e45c5a35c0fcbe60c51f6b9bb" translate="yes" xml:space="preserve">
          <source>The original purpose of source filters was to let you encrypt your program source to prevent casual piracy. This isn't all they can do, as you'll soon learn. But first, the basics.</source>
          <target state="translated">源码过滤器的最初目的是让你对程序源码进行加密,以防止随意盗版。这并不是它们能做的全部,你很快就会知道。但首先,是基础知识。</target>
        </trans-unit>
        <trans-unit id="af210dcaae99ceb3aa829035af3557a9ff65ef3a" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;&lt;a href=&quot;#dORIGMARK&quot;&gt;&quot;dORIGMARK&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a310ea971545c067e472063428469fc1fad9aa30" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;dORIGMARK&lt;/code&gt; .</source>
          <target state="translated">XSUB的原始堆栈标记。参见 &lt;code&gt;dORIGMARK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9fdbd5653ee6341eabe4730cc34935e3db7a992" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt; ), like so:</source>
          <target state="translated">原始样式在块名称中使用空格和连字符（ &lt;code&gt;No_Block&lt;/code&gt; 除外），如下所示：</target>
        </trans-unit>
        <trans-unit id="5c736b5ceaedaf0c5b862acefcb315ae2bd5b9ab" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt;), like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dcbc33a95cd67473b45a522488fc8cc805a4f47" translate="yes" xml:space="preserve">
          <source>The original title was</source>
          <target state="translated">原标题为</target>
        </trans-unit>
        <trans-unit id="07db5f54ef4c59c897a817d5ccebc37f60d9a5b6" translate="yes" xml:space="preserve">
          <source>The original true/false value of whatever was passed into the event (but reduced down to 1 or 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e60244f8f199981b052b42233461b69e602ecf3" translate="yes" xml:space="preserve">
          <source>The original usage can be accomplished by explicit (rather than this pragma's implicit) encoding using the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea4b9a6cd75e55515170d81fe9ec6a923c1c00a" translate="yes" xml:space="preserve">
          <source>The original version of B::Terse was written by Malcolm Beattie, &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;. This wrapper was written by Stephen McCamant, &amp;lt;smcc@MIT.EDU&amp;gt;.</source>
          <target state="translated">B :: Terse的原始版本由Malcolm Beattie撰写，&amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;。该包装由Stephen McCamant，&amp;lt;smcc@MIT.EDU&amp;gt;编写。</target>
        </trans-unit>
        <trans-unit id="ba66fcf36669927e93622e0a65ee5e2d5c9bffdb" translate="yes" xml:space="preserve">
          <source>The original version of PA-RISC, HP no longer sells any system with this chip.</source>
          <target state="translated">PA-RISC的原始版本,惠普已经不再销售任何带有该芯片的系统。</target>
        </trans-unit>
        <trans-unit id="0705420ac769cdd445f5fb673329007ec7bccb68" translate="yes" xml:space="preserve">
          <source>The original version of this article originally appeared in The Perl Journal #10, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">本文的原始版本最初出现在 The Perl Journal #10,版权归 The Perl Journal 1998 所有。本文由 Jon Orwant 和 The Perl Journal 提供。本文档可以在与Perl本身相同的条款下发布。</target>
        </trans-unit>
        <trans-unit id="9009e0d18f1d5f332e2819aa4a5b08efaa84ba15" translate="yes" xml:space="preserve">
          <source>The original was written by Andy Dougherty</source>
          <target state="translated">原著作者是Andy Dougherty。</target>
        </trans-unit>
        <trans-unit id="ac8cde9199e82022f2799533159dbf659a64016b" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;OA_*&lt;/code&gt; constants should not be used.</source>
          <target state="translated">不应使用其他 &lt;code&gt;OA_*&lt;/code&gt; 常量。</target>
        </trans-unit>
        <trans-unit id="e99c9d2a05f195a52a6e3dccd804ac6a0edaa601" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">其他 &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; 方法意味着每个 &lt;code&gt;$parser&lt;/code&gt; 对象仅调用一次；但是只要最后一次调用（并且只有最后一次调用）以 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值结尾，就可以根据需要为每个 &lt;code&gt;$parser&lt;/code&gt; 对象多次调用 &lt;code&gt;parse_lines&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c95c0f77be936d4feacc6aa823fe8dfa8595f61" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;undef&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0806e4bd09cd5bd6dbaceaf9c0baff74d032490" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt; :</source>
          <target state="translated">如果您知道 &lt;code&gt;STORABLE_freeze&lt;/code&gt; ，其他参数应该看起来很熟悉：</target>
        </trans-unit>
        <trans-unit id="6d6b16332403f12890e319d0cef347a3dc9b9bef" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407b63c5d1d6303ca3afdf08c491fa75e0221db1" translate="yes" xml:space="preserve">
          <source>The other big problem with &lt;code&gt;$^W&lt;/code&gt; is the way you can inadvertently change the warning setting in unexpected places in your code. For example, when the code below is run (without the &lt;b&gt;-w&lt;/b&gt; flag), the second call to &lt;code&gt;doit&lt;/code&gt; will trip a &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; warning, whereas the first will not.</source>
          <target state="translated">&lt;code&gt;$^W&lt;/code&gt; 的另一个大问题是您无意中在代码中意外位置更改警告设置的方式。例如，当下面的代码运行（不&lt;b&gt;-w&lt;/b&gt;标志），到第二呼叫 &lt;code&gt;doit&lt;/code&gt; 将跳闸一个 &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; 的警告，而第一不会。</target>
        </trans-unit>
        <trans-unit id="fc649a384c23c44b5ba2efe0b85df4a20e6ec321" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt; , so the executables are named accordingly.</source>
          <target state="translated">其他情况需要更多复杂的过程。下面，我假设Perl的当前版本是 &lt;code&gt;5.8.2&lt;/code&gt; ，因此可执行文件将相应地命名。</target>
        </trans-unit>
        <trans-unit id="427a9edc8baf371e22d2821e2812db4f5b95659f" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt;, so the executables are named accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97290d4117a272682128f8d28555111afe13c240" translate="yes" xml:space="preserve">
          <source>The other common cause is for the characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c457b75f143400140761950573f5b842848c756c" translate="yes" xml:space="preserve">
          <source>The other counterpart, in the column labelled &quot;Full-range Unicode&quot;, matches any appropriate characters in the full Unicode character set. For example, &lt;code&gt;\p{Alpha}&lt;/code&gt; matches not just the ASCII alphabetic characters, but any character in the entire Unicode character set considered alphabetic. An entry in the column labelled &quot;backslash sequence&quot; is a (short) equivalent.</source>
          <target state="translated">在标记为&amp;ldquo;全范围Unicode&amp;rdquo;的列中，另一个匹配项与完整Unicode字符集中的任何适当字符匹配。例如， &lt;code&gt;\p{Alpha}&lt;/code&gt; 匹配ASCII字母字符，而且匹配整个Unicode字符集中被视为字母的任何字符。标记为&amp;ldquo;反斜杠序列&amp;rdquo;的列中的条目是（短）等效项。</target>
        </trans-unit>
        <trans-unit id="f185e517dca4682b63e353adac3daa559be38725" translate="yes" xml:space="preserve">
          <source>The other form is called &quot;block eval&quot;. It is less general than string eval, but the code within the BLOCK is parsed only once (at the same time the code surrounding the &lt;code&gt;eval&lt;/code&gt; itself was parsed) and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first, while also providing the benefit of checking the code within BLOCK at compile time. BLOCK is parsed and compiled just once. Since errors are trapped, it often is used to check if a given feature is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece66aa413156fc84b73d204d2d9bbbf0fe1c18a" translate="yes" xml:space="preserve">
          <source>The other hack is to restore FP flags after a call to dlopen(). This helps against similar damage done by DLLs _DLLInitTerm() at runtime. Currently no way to switch these hacks off is provided.</source>
          <target state="translated">另一个黑客是在调用dlopen()后恢复FP标志。这有助于防止DLLs _DLLInitTerm()在运行时造成类似的破坏。目前还没有提供关闭这些黑客的方法。</target>
        </trans-unit>
        <trans-unit id="9303fbfd8a21fb685b416cbb44c3a447eed84853" translate="yes" xml:space="preserve">
          <source>The other is to install the module in a temporary location.</source>
          <target state="translated">另一种是将模块安装在一个临时的位置。</target>
        </trans-unit>
        <trans-unit id="7370aa653e76af4b47e0ca0cfb340c944499961e" translate="yes" xml:space="preserve">
          <source>The other modification made is that</source>
          <target state="translated">另一个修改是</target>
        </trans-unit>
        <trans-unit id="5eaa26235f36f66db1f5d49d6f66d3b1d7e346a6" translate="yes" xml:space="preserve">
          <source>The other one is &quot;Common&quot;. This consists of mostly punctuation, emoji, and characters used in mathematics and music, the ASCII digits &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt;, and full-width forms of these digits. These characters can appear intermixed in text in many of the world's scripts. These also don't cause a script run to not match. But like other scripts, all digits in a run must come from the same set of 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e0e078ed7f59ceb7388f298d1ea1da0c3bdb08" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt; ) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="translated">使用变量来保存另一个变量的名称的另一个不好的主意是，该问题通常是由于对Perl数据结构缺乏理解，尤其是哈希。通过使用符号引用，您只是在使用包的符号表哈希（例如 &lt;code&gt;%main::&lt;/code&gt; 而不是用户定义的哈希。解决方案是使用您自己的哈希或真实引用。</target>
        </trans-unit>
        <trans-unit id="14e65562914f1eda6c3850757c3e36b8e4c292d5" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt;) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23447e512ad32c2037041f02596c75ecf1a5899" translate="yes" xml:space="preserve">
          <source>The other scalar-returning list reduction functions are all specialisations of this generic idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5743b7f731fc10e9d1778f5bba7c58560baf6a5c" translate="yes" xml:space="preserve">
          <source>The other structure is pointed to by the &lt;code&gt;regexp&lt;/code&gt; struct's &lt;code&gt;pprivate&lt;/code&gt; and is in addition to &lt;code&gt;intflags&lt;/code&gt; in the same struct considered to be the property of the regex engine which compiled the regular expression;</source>
          <target state="translated">&lt;code&gt;regexp&lt;/code&gt; 结构的 &lt;code&gt;pprivate&lt;/code&gt; 指向其他结构，除了该结构中的intflags之外， &lt;code&gt;intflags&lt;/code&gt; 被认为是编译正则表达式的regex引擎的属性。</target>
        </trans-unit>
        <trans-unit id="5b612d86c256526a7120d0f540436c62b7f8f79b" translate="yes" xml:space="preserve">
          <source>The other synchronization primitives described below can suffer from similar problems.</source>
          <target state="translated">下面描述的其他同步基元也会出现类似的问题。</target>
        </trans-unit>
        <trans-unit id="375bee995645e81f309660da902b757d6a8e656a" translate="yes" xml:space="preserve">
          <source>The other way works too, especially if you are sure that all your data are under the same encoding, or if compatibility with older versions of Perl is desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a4f63ad2418ff7f127884608b4d5e8c00d7b27" translate="yes" xml:space="preserve">
          <source>The others shouldn't be used in a threaded application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a811a8ea9dab8327d772322e2e441ab82ca0e86f" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">打印操作符的输出字段分隔符。如果定义，则在每个print参数之间打印该值。默认值为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdf1adf4fd2953bb9b8993988459b89f053c2344" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e6a9347f20222b252ad3782a91c8dbdeaeb1ab5" translate="yes" xml:space="preserve">
          <source>The output file to print to. If the special names &quot;-&quot; or &quot;&amp;gt;&amp;amp;1&quot; or &quot;&amp;gt;&amp;amp;STDOUT&quot; are used then standard output is used. If &quot;&amp;gt;&amp;amp;2&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot; is used then standard error is used.</source>
          <target state="translated">要输出到的输出文件。如果使用特殊名称&amp;ldquo;-&amp;rdquo;或&amp;ldquo;&amp;gt;＆1&amp;rdquo;或&amp;ldquo;&amp;gt;＆STDOUT&amp;rdquo;，则使用标准输出。如果使用&amp;ldquo;&amp;gt;＆2&amp;rdquo;或&amp;ldquo;&amp;gt;＆STDERR&amp;rdquo;，则使用标准错误。</target>
        </trans-unit>
        <trans-unit id="cf7f158841e06623182985de04b67d3455d986ee" translate="yes" xml:space="preserve">
          <source>The output files are placed in the hierarchy rooted at Perl's architecture dependent library directory. You can specify a different hierarchy with a &lt;b&gt;-d&lt;/b&gt; switch.</source>
          <target state="translated">输出文件放置在根于Perl依赖于体系结构的库目录的层次结构中。您可以使用&lt;b&gt;-d&lt;/b&gt;开关指定其他层次结构。</target>
        </trans-unit>
        <trans-unit id="c27fbec04d459297ba3b8649872110c7c0d3d15a" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;&quot;Configurable Options&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d7376e07f79489cad7f31d1cda9c5ba04d798cb" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;Configurable Options&lt;/a&gt;.</source>
          <target state="translated">输出格式由&amp;ldquo;可&lt;a href=&quot;#Configurable-Options&quot;&gt;配置选项&amp;rdquo;&lt;/a&gt;下所述的多个选项控制。</target>
        </trans-unit>
        <trans-unit id="99376109c851932f74197e279ea101a89b6befe6" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; is within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , not whether the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; is.</source>
          <target state="translated">&lt;a href=&quot;functions/write&quot;&gt;写入&lt;/a&gt;的输出格式由更早的格式声明（&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;）确定，因此输出是否受语言环境的影响取决于 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; 是否在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的范围内，而不取决于 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 是。</target>
        </trans-unit>
        <trans-unit id="c1530099f7317e5e8334f8069b6bb6b27df102d4" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;perlfunc#write&quot;&gt;write()&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;perlfunc#format&quot;&gt;&quot;format&quot; in perlfunc&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;format()&lt;/code&gt; is within the scope of a &lt;code&gt;use locale&lt;/code&gt;, not whether the &lt;code&gt;write()&lt;/code&gt; is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821335e2d4cef7b064fd271a1052ad49bb811014" translate="yes" xml:space="preserve">
          <source>The output from an XSUB which uses something like the T_PTRREF map, which doesn't bless the object, might look something like this:</source>
          <target state="translated">使用类似T_PTRREF映射的XSUB的输出,不祝福对象,可能是这样的。</target>
        </trans-unit>
        <trans-unit id="0f57dea9a1d29f634f6f112b3d23937584062d88" translate="yes" xml:space="preserve">
          <source>The output from that will be</source>
          <target state="translated">其输出将是</target>
        </trans-unit>
        <trans-unit id="489ef92ce8f286ef5d6d82e8d178af124ae1bd61" translate="yes" xml:space="preserve">
          <source>The output is untainted. If you don't know what tainting is, don't worry about it.</source>
          <target state="translated">输出是没有污染的。如果你不知道什么是污点,就不要担心。</target>
        </trans-unit>
        <trans-unit id="74b4c8cfc7182db2977001aba6ce4cd0c9c3eff4" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">输出行可以用作 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 调用中的模板：</target>
        </trans-unit>
        <trans-unit id="ff265796f887227add453069160ce81043ae2ad9" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;pack&lt;/code&gt; or &lt;code&gt;unpack&lt;/code&gt; call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628776c99f7feeea9f3047213f9a74832f55bae9" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;uname -a&lt;/code&gt; if available, otherwise the hostname. The whole thing is then lower-cased and slashes and single quotes are removed.</source>
          <target state="translated">&lt;code&gt;uname -a&lt;/code&gt; 的输出（如果可用），否则为主机名。然后将整个内容小写，并删除斜杠和单引号。</target>
        </trans-unit>
        <trans-unit id="b50cc56cf670c43f6be20602b16c39970c70b1a0" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">打印操作员的输出记录分隔符。如果定义，则在打印的最后一个参数之后打印此值。默认值为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bed1b55192d15d86c0d4204e8c0dbb14dedd4354" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8366e38dbe1255a05a31be8b8ca8cff24bae31ce" translate="yes" xml:space="preserve">
          <source>The output shows all of the groups. The outermost matches show up first and the nested matches show up later:</source>
          <target state="translated">输出显示所有的组。最外层的匹配项先显示,嵌套的匹配项后显示。</target>
        </trans-unit>
        <trans-unit id="61a2ac718a159127bd64e67ec39c4e8e007d9514" translate="yes" xml:space="preserve">
          <source>The output shows that Perl found the two major groups:</source>
          <target state="translated">输出显示,Perl找到了两大组。</target>
        </trans-unit>
        <trans-unit id="eb272330b66e99a860c17d412be21e54b237263f" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt; . Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt; , but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="translated">输出显示，在 &lt;code&gt;OUTER&lt;/code&gt; 块中， &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 的值来自与 &lt;code&gt;$outer&lt;/code&gt; 的匹配。在 &lt;code&gt;INNER&lt;/code&gt; 块内部， &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 的值来自与 &lt;code&gt;$inner&lt;/code&gt; 的匹配，但仅直到块的末尾（即动态范围）为止。后 &lt;code&gt;INNER&lt;/code&gt; 块完成，值 &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 回报为反对这门亲事值 &lt;code&gt;$outer&lt;/code&gt; ，即使我们还没有做出其他比赛：</target>
        </trans-unit>
        <trans-unit id="3aeb115218152011de3493e1c2fea22949664e64" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt;. Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt;, but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b62e463d3539b36d5bc54872fb60071ea829c7" translate="yes" xml:space="preserve">
          <source>The output shows the constant() subroutine we're testing being replaced with the value of the &lt;code&gt;DEBUG&lt;/code&gt; constant: zero. The line to be tested has been completely optimized away, and you can't get much more efficient than that.</source>
          <target state="translated">输出显示我们正在测试的constant（）子例程已被 &lt;code&gt;DEBUG&lt;/code&gt; 常量的值替换为零。要测试的生产线已经完全优化，您将无法获得比这更高的效率。</target>
        </trans-unit>
        <trans-unit id="223632d9e65a77def5c7f3d1e26472458213d8c9" translate="yes" xml:space="preserve">
          <source>The output string will be returned.</source>
          <target state="translated">将返回输出字符串。</target>
        </trans-unit>
        <trans-unit id="5b1aa869d1f21ede1a6455013df56f91d9ec5d9c" translate="yes" xml:space="preserve">
          <source>The output strings for &lt;b&gt;Tputs&lt;/b&gt; are cached for counts of 1 for performance. &lt;b&gt;Tgoto&lt;/b&gt; and &lt;b&gt;Tpad&lt;/b&gt; do not cache. &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; is the raw termcap data and &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; is the cached version.</source>
          <target state="translated">&lt;b&gt;Tputs&lt;/b&gt;的输出字符串缓存为1，以提高性能。&lt;b&gt;Tgoto&lt;/b&gt;和&lt;b&gt;Tpad&lt;/b&gt;不缓存。 &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; 是原始termcap数据， &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; 是缓存的版本。</target>
        </trans-unit>
        <trans-unit id="5e7202107b643ac3d564aacb4d094eef76b947a2" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="translated">输出值及其符号,必须是1,2,...,OBJ2-1范围内的正值,或者是减去OBJ2的相同值。例如,如果输入参数是代表数字7和5的对象,则该方法必须返回一个代表数字3和 &quot;+&quot;号的对象,因为(3*7)% 5=1 % 5,或者返回一个代表数字2和&quot;-&quot;号的对象,因为(-2*7)% 5=1 % 5。</target>
        </trans-unit>
        <trans-unit id="3b69a10a3a50934e50dc62235290b18744d8011f" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and a &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eef73c78f4ba8f7baa5a469f4fff0d89cabb26a" translate="yes" xml:space="preserve">
          <source>The output you'll get when the script is executed:</source>
          <target state="translated">当脚本被执行时,你将得到的输出。</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">的输出。</target>
        </trans-unit>
        <trans-unit id="0dc65b45e14d95f10af2c76613db8f6869035f53" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 与终止时间之间的总时间或挂钟时间。经过的时间包括用户和系统时间，以及等待系统上其他用户和进程所花费的时间。不可避免地，这是给出的最近似的测量值。</target>
        </trans-unit>
        <trans-unit id="9571b6fa38431ae0c0fee13dd1186fe4dbf0046f" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;time&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5407cf16873f519751b5a5a5e241e60dd7a6b88b" translate="yes" xml:space="preserve">
          <source>The pTHX_ symbol in the definition is a macro used by Perl under threading to provide an extra argument to the routine holding a pointer back to the interpreter that is executing the regexp. So under threading all routines get an extra argument.</source>
          <target state="translated">定义中的pTHX_符号是Perl在线程化下使用的一个宏,用于为例程提供一个额外的参数,该参数持有一个指向正在执行regexp的解释器的指针。所以在线程下,所有的例程都会得到一个额外的参数。</target>
        </trans-unit>
        <trans-unit id="f3fe23968698971d8ab162ac70a7f7b71df42802" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;A*&lt;/code&gt; gobbles up all remaining bytes, and &lt;code&gt;$prio&lt;/code&gt; remains undefined! Before we let disappointment dampen the morale: Perl's got the trump card to make this trick too, just a little further up the sleeve. Watch this:</source>
          <target state="translated">打包代码 &lt;code&gt;A*&lt;/code&gt; 吞噬了所有剩余字节，而 &lt;code&gt;$prio&lt;/code&gt; 仍未定义！在我们失望之前挫败士气：Perl也获得了王牌来做这个技巧，只是袖手旁观。看这个：</target>
        </trans-unit>
        <trans-unit id="7933b3c7848d20de1a22817261c68e6d7c53c8c0" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="translated">添加了打包代码 &lt;code&gt;w&lt;/code&gt; 以支持一种便携式二进制数据编码方案，该方案远远超出了简单的整数。 （有关详细信息，请访问Scarab项目的&lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;。）BER（二进制编码表示）压缩的无符号整数存储基数128位，最高有效位在前，并且位数越少越好。除最后一个字节外，每个字节均设置位八（高位）。 BER编码没有大小限制，但是Perl不会极端。</target>
        </trans-unit>
        <trans-unit id="b79ab5606b336d2e61cfa7238de19673ec485cc8" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&quot;&gt;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf9569df81623b7e7940e6c5aeacc511770e43a" translate="yes" xml:space="preserve">
          <source>The pack code for big-endian (high order byte at the lowest address) is &lt;code&gt;n&lt;/code&gt; for 16 bit and &lt;code&gt;N&lt;/code&gt; for 32 bit integers. You use these codes if you know that your data comes from a compliant architecture, but, surprisingly enough, you should also use these pack codes if you exchange binary data, across the network, with some system that you know next to nothing about. The simple reason is that this order has been chosen as the</source>
          <target state="translated">big-endian（最低地址的高位字节）的打包代码对于16位是 &lt;code&gt;n&lt;/code&gt; ，对于32位整数是 &lt;code&gt;N&lt;/code&gt; 。如果您知道数据来自兼容体系结构，则可以使用这些代码，但是，令人惊讶的是，如果您要通过网络与几乎一无所知的系统交换二进制数据，那么也应该使用这些打包代码。原因很简单，该订单已被选择为</target>
        </trans-unit>
        <trans-unit id="57fad0d4b36d335f1fb095e9863848e373754e9c" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 之前的打包代码可以是任何适合表示数字的代码：所有数字二进制打包代码，甚至是文本代码，例如 &lt;code&gt;A4&lt;/code&gt; 或 &lt;code&gt;Z*&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="65094bdd21f0a1919cd6838b37b6c0d3bbee3405" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7172e02890f0d23e60cb06f72d229c969bc3f33e" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="translated">包装格式 &lt;code&gt;A&lt;/code&gt; 表示&amp;ldquo;任何字符&amp;rdquo;；如果你是 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ING和你的东西用完了收拾， &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 将填补剩下了空间。</target>
        </trans-unit>
        <trans-unit id="44495eb674e0583287f2264fa02ffed62c8c4074" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;pack&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;pack&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9582d05d51afa98d043db268f238bb511bec0a17" translate="yes" xml:space="preserve">
          <source>The package contains a session manager and a cache manager. The session manager keeps track of what has been fetched, built, and installed in the current session. The cache manager keeps track of the disk space occupied by the make processes and deletes excess space using a simple FIFO mechanism.</source>
          <target state="translated">该包包含一个会话管理器和一个缓存管理器。会话管理器会跟踪当前会话中已经获取、构建和安装的内容,缓存管理器会跟踪make进程占用的磁盘空间,并使用简单的FIFO机制删除多余的空间。缓存管理器跟踪make进程占用的磁盘空间,并使用简单的FIFO机制删除多余的空间。</target>
        </trans-unit>
        <trans-unit id="f2c3c65c0d45b6b1fe4dfd7fdaf1376fd647a40b" translate="yes" xml:space="preserve">
          <source>The package from which the exceptional subroutine was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc4d85fb172b2eb58f10fb1bda38f21c477922a" translate="yes" xml:space="preserve">
          <source>The package name argument will typically be the name of the class into which the subroutine was declared, but it may also be the name of a derived class (since handlers are inherited).</source>
          <target state="translated">包名参数通常是子程序被声明成的类的名称,但也可能是派生类的名称(因为处理程序是继承的)。</target>
        </trans-unit>
        <trans-unit id="91efffdbf8c7db0b4f5430206e2d6e6cd3563e8f" translate="yes" xml:space="preserve">
          <source>The package name uses the &lt;code&gt;DBM_Filter::&lt;/code&gt; prefix.</source>
          <target state="translated">程序包名称使用 &lt;code&gt;DBM_Filter::&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="61ad7bd19c49da733338e6250d6950f088f8b981" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt;).</source>
          <target state="translated">表示发行版的软件包。例如， &lt;code&gt;Test::More&lt;/code&gt; 或 &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 。它将用于派生有关分发的信息，例如&lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;，Perl库中的安装位置以及默认情况下将在其中查找XS文件的位置（请参阅&lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cf847620b5ea5a28241ef80f16dce588c1976c67" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;. It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;&quot;DISTNAME&quot;&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;&quot;XS&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4576d414ced67927c5747f7cd9e683dea9105380" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;
qr//&lt;/code&gt; ). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="translated">qr //魔术对象的软件包被祝福（如 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; qr//&lt;/code&gt; ）。建议引擎将其更改为其程序包名称以进行标识，无论它们是否在对象上实现方法。</target>
        </trans-unit>
        <trans-unit id="3eb8be4161caf31aed9851aac09981f2dc091cb7" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;ref qr//&lt;/code&gt;). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73079d10e9cd577552c5b87cfb22afa1b7851691" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="translated">此方法返回的包的 &lt;code&gt;@ISA&lt;/code&gt; 中还应该具有内部 &lt;code&gt;Regexp&lt;/code&gt; 包。无论使用什么引擎， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; 都应始终为true。</target>
        </trans-unit>
        <trans-unit id="890f0468ce1dfbaa3a848480f6a3e9f003f8a19f" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt;. &lt;code&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b32ac926fcc794f5f7982e502e4686af4c595bf" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt; , on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="translated">当调用者简单地说 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; Net :: Acme时，包变量 &lt;code&gt;@EXPORT&lt;/code&gt; 将确定将导出哪些符号-您几乎不需要在其中放置任何内容。另一方面，@ &lt;code&gt;@EXPORT_OK&lt;/code&gt; 指定您要导出的符号。如果确实要导出一堆符号，请使用 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 并定义一个标准导出集- 有关更多详细信息，请参见&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d8ef2409327fe0b3b34e7e40584004dedfbd9fc" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;use Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt;, on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650111e5202c538679780ce9ea893a905f97b0fc" translate="yes" xml:space="preserve">
          <source>The packages relating to various DBM-related implementations (</source>
          <target state="translated">与各种DBM相关的实施方案相关的包()。</target>
        </trans-unit>
        <trans-unit id="02ef2277604c9b31476ae26defa7602571798335" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The &lt;code&gt;COP_SEQ_RANGE_LOW&lt;/code&gt; and &lt;code&gt;_HIGH&lt;/code&gt; fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c94813a5310ff08ec4ccbc37cd40783e0084e83e" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The COP_SEQ_RANGE_LOW and _HIGH fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="translated">PADNAMELIST中的焊盘名称有其PV,持有变量的名称。COP_SEQ_RANGE_LOW和_HIGH字段形成了一个cop_seq数字的范围(low+1...high包括在内),这个名字是有效的。在编译过程中,这些字段可以持有特殊值PERL_PADSEQ_INTRO来表示不同的阶段。</target>
        </trans-unit>
        <trans-unit id="ad69ddb72e9f5b5565c26efc4eeac2130e2ed028" translate="yes" xml:space="preserve">
          <source>The padded $string is returned.</source>
          <target state="translated">返回填充的$string。</target>
        </trans-unit>
        <trans-unit id="d3a360c727f09061a32c58fb443bedffc200fc64" translate="yes" xml:space="preserve">
          <source>The paper &quot;How to Break MD5 and Other Hash Functions&quot; by Xiaoyun Wang and Hongbo Yu.</source>
          <target state="translated">王晓云、于洪波的论文《如何破解MD5等哈希函数》。</target>
        </trans-unit>
        <trans-unit id="9446a617fdf40553874ee589e7fc235690a0bb87" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcc7e86c6ab48d9801f437d7ce277bb0ef436bb" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="translated">您提供给&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt;的段落不应包含嵌入式换行符。&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt;无法对齐行（右对齐）。</target>
        </trans-unit>
        <trans-unit id="0d3c20158693e8f7ad6ce14151f5e71a493b3128" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">参数 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 用于控制压缩数据的目的地。该参数可以采用以下形式之一。</target>
        </trans-unit>
        <trans-unit id="2a2ee58982c19a9868c4499e7bd1b9d1531f2904" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the uncompressed data. This parameter can take one of these forms.</source>
          <target state="translated">参数 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 用于控制未压缩数据的目的地。该参数可以采用以下形式之一。</target>
        </trans-unit>
        <trans-unit id="4380851c25da81befd83447bad55f6f9f369b966" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$text&lt;/code&gt; is a string or block of text to be parsed for interior sequences; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number corresponding to the beginning of &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">参数 &lt;code&gt;$text&lt;/code&gt; 是要为内部序列解析的字符串或文本块；参数 &lt;code&gt;$line_num&lt;/code&gt; 是与 &lt;code&gt;$text&lt;/code&gt; 开头相对应的行号。</target>
        </trans-unit>
        <trans-unit id="175733e4967510eadb5d4ab18e962461101eaed6" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;extra_libs&lt;/code&gt; can be used to specify &lt;b&gt;additional&lt;/b&gt; paths to search for installed modules. For instance</source>
          <target state="translated">参数 &lt;code&gt;extra_libs&lt;/code&gt; 可用于指定&lt;b&gt;其他&lt;/b&gt;路径以搜索已安装的模块。例如</target>
        </trans-unit>
        <trans-unit id="76679b1c7056137b35154fa4603dcc56a2e17eed" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;type&lt;/code&gt; is an enumeration which specifies which of the 3 interface methods (DB_HASH, DB_BTREE or DB_RECNO) is to be used. Depending on which of these is actually chosen, the final parameter,</source>
          <target state="translated">参数 &lt;code&gt;type&lt;/code&gt; 是一个枚举，它指定要使用三种接口方法（DB_HASH，DB_BTREE或DB_RECNO）中的哪一种。根据实际选择的参数，最终参数</target>
        </trans-unit>
        <trans-unit id="6df79d8edafef2b8d47fc8b433ceb1dac071556d" translate="yes" xml:space="preserve">
          <source>The parameter list to my() may be assigned to if desired, which allows you to initialize your variables. (If no initializer is given for a particular variable, it is created with the undefined value.) Commonly this is used to name input parameters to a subroutine. Examples:</source>
          <target state="translated">如果需要的话,可以将参数列表分配给my(),这样可以让你初始化你的变量。(如果没有为某个变量提供初始化器,则会以未定义的值创建。)通常这用来命名子程序的输入参数。例子。</target>
        </trans-unit>
        <trans-unit id="42306ba107d404a6932eda2f03148007a2382a8a" translate="yes" xml:space="preserve">
          <source>The parameter's default value will still be evaluated if the corresponding argument isn't supplied, even though the value won't be stored anywhere. This is in case evaluating it has important side effects. However, it will be evaluated in void context, so if it doesn't have side effects and is not trivial it will generate a warning if the &quot;void&quot; warning category is enabled. If a nameless optional parameter's default value is not important, it may be omitted just as the parameter's name was:</source>
          <target state="translated">如果没有提供相应的参数,参数的默认值仍然会被评估,即使该值不会被存储在任何地方。这是在评估它有重要副作用的情况下。然而,它将在void上下文中被评估,所以如果它没有副作用,而且不是琐碎的,如果启用了 &quot;void &quot;警告类别,它将产生一个警告。如果一个无名可选参数的默认值并不重要,那么它可以像参数的名称一样被省略。</target>
        </trans-unit>
        <trans-unit id="59f23da7798f0b234972a256a92c78bcfb8c2aa3" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the compressed data.</source>
          <target state="translated">参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 用来定义压缩数据的源。</target>
        </trans-unit>
        <trans-unit id="ed835ab2fa9d34eac4fd3a603940891a0a5eef62" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the uncompressed data.</source>
          <target state="translated">参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 用来定义未压缩数据的源。</target>
        </trans-unit>
        <trans-unit id="4cb5c66abe58beef181f4c5d5c5b7b8d0a8b5206" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt;, is used to define the source of the compressed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a676729b0be9ab28de0e8dc42a59d230912658" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt;, is used to define the source of the uncompressed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0cab04bcd8cbbda8dd4d2c9ce2cf18535f80ac" translate="yes" xml:space="preserve">
          <source>The parameters it accepts are:</source>
          <target state="translated">它接受的参数有:</target>
        </trans-unit>
        <trans-unit id="a830abc7b9d4b876164e2805f5f239e46c825485" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; 的参数添加到perl搜索路径的开头。说</target>
        </trans-unit>
        <trans-unit id="735cc433a3b6580bd3067e26aea227e52cc434e6" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;use lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea253e51dc3b40387e985b7980c9898cef5a3467" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="translated">关于括号 &lt;code&gt;XSLoader::load()&lt;/code&gt; ，因为我们更换需要的参数 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ，所以编译器不知道的功能 &lt;code&gt;XSLoader::load()&lt;/code&gt; 是存在的。</target>
        </trans-unit>
        <trans-unit id="0d68003766a6505369e854c0eee6d10a747bd253" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;use XSLoader&lt;/code&gt; by &lt;code&gt;require&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f992098d3a5a843dac6b8ae9c7b69d4a2fac46e8" translate="yes" xml:space="preserve">
          <source>The parse proceeds pretty much exactly as it does during the construction phase, except that most routines are short-circuited to change the size field &lt;code&gt;RExC_size&lt;/code&gt; and not do anything else.</source>
          <target state="translated">解析的进行过程几乎与构造阶段完全相同，只是大多数例程被短路以更改大小字段 &lt;code&gt;RExC_size&lt;/code&gt; 且不执行其他任何操作。</target>
        </trans-unit>
        <trans-unit id="ce842c5dcf2b13fb8c9e8394fe72be9c8b2663ca" translate="yes" xml:space="preserve">
          <source>The parser is heavily inspired from the one in &lt;a href=&quot;ExtUtils::ParseXS&quot;&gt;ExtUtils::ParseXS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ac900e49339cc6ef6dea21ed4478644c93af89" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt; , and that and its associated routines can be found in</source>
          <target state="translated">语法分析器得到了词法分析器的大力支持，该词法分析器将您的输入分块成令牌，并确定每个令牌是什么类型的东西：变量名，运算符，空字，子例程，核心函数，等等。词法分析器的主要入口点是 &lt;code&gt;yylex&lt;/code&gt; ，它及其相关的例程可以在下面找到。</target>
        </trans-unit>
        <trans-unit id="22cd9c89b1bd366e42455f5006c44969bcb5bdee" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt;, and that and its associated routines can be found in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c291c44225b529aa63eb30ed6a4d6cbe06294dcd" translate="yes" xml:space="preserve">
          <source>The parser then sees the following code:</source>
          <target state="translated">然后,解析器会看到以下代码。</target>
        </trans-unit>
        <trans-unit id="d30f0f58beb42ee5cf5d76db1412cac91e934bb2" translate="yes" xml:space="preserve">
          <source>The part of an Email address which follows the @ is not necessarily a hostname, it is a mail domain. To find the name of a host to connect for a mail domain you need to do a DNS MX lookup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f50fcb4a70f717d3ac7b5f391fbd97a01ce899" translate="yes" xml:space="preserve">
          <source>The part of the address of a TCP or UDP socket that directs packets to the correct process after finding the right machine, something like the phone extension you give when you reach the company operator. Also the result of converting code to run on a different platform than originally intended, or the verb denoting this conversion.</source>
          <target state="translated">TCP或UDP套接字的地址部分,在找到正确的机器后,将数据包引导到正确的进程,就像你联系公司接线员时给出的电话分机一样。也是指将代码转换为在不同的平台上运行的结果,或表示这种转换的动词。</target>
        </trans-unit>
        <trans-unit id="ae986ba9c61f4a263f7b3033ed66b7a9c47ca2ea" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use does not support the specified signal being used in a &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; call.</source>
          <target state="translated">您尝试使用的特定Perl副本不支持在 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 调用中使用的指定信号。</target>
        </trans-unit>
        <trans-unit id="24e4beb9cede37117dbc38642ef9d4cdf73ef0f4" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use was not built using the &lt;code&gt;useithreads&lt;/code&gt; configuration option.</source>
          <target state="translated">您要使用的Perl特定副本不是使用 &lt;code&gt;useithreads&lt;/code&gt; 配置选项构建的。</target>
        </trans-unit>
        <trans-unit id="e133c3129f1a418b83b69fbe9affe042d494a52e" translate="yes" xml:space="preserve">
          <source>The particular macro you must use depends on which &lt;code&gt;sv_set*v&lt;/code&gt; routine you called first. This is because every &lt;code&gt;sv_set*v&lt;/code&gt; routine turns on only the bit for the particular type of data being set, and turns off all the rest.</source>
          <target state="translated">您必须使用的特定宏取决于您首先调用的 &lt;code&gt;sv_set*v&lt;/code&gt; 例程。这是因为每个 &lt;code&gt;sv_set*v&lt;/code&gt; 例程仅打开所设置的特定数据类型的位，而关闭其余所有位。</target>
        </trans-unit>
        <trans-unit id="9a1356c02587b997ee27ddf50eebcf831988fbcb" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&quot;prop_aliases()&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c24d584fffb94c2e195393379212bd0e772bba9" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt;.</source>
          <target state="translated">可以将传递的属性指定为&lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases（）&lt;/a&gt;返回的任何同义词。</target>
        </trans-unit>
        <trans-unit id="515ad1971581ebeed29e0dfbff2e2ca6f9f34b5c" translate="yes" xml:space="preserve">
          <source>The patchlevel level of this package. The value of patchlevel comes from the</source>
          <target state="translated">这个软件包的补丁级别。补丁级别的值来自于</target>
        </trans-unit>
        <trans-unit id="6c9c1991e5426882e512831205056ad8d0cb53e5" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt; . By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt; . However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt; .</source>
          <target state="translated">Perl通过 &lt;code&gt;@INC&lt;/code&gt; 的路径。默认情况下，这是双重深度优先搜索，一次查找定义的方法，一次查找 &lt;code&gt;AUTOLOAD&lt;/code&gt; 。但是，Perl允许您使用 &lt;code&gt;mro&lt;/code&gt; 进行配置。</target>
        </trans-unit>
        <trans-unit id="bfd87cb3c63ce818c0482394b6803650584202ed" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt;. By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt;. However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b7ffc6783961615c324915aaa3803b45441d58" translate="yes" xml:space="preserve">
          <source>The path from the uri, will be at least a single '/'.</source>
          <target state="translated">从uri的路径,将至少是一个'/'。</target>
        </trans-unit>
        <trans-unit id="935a26d686af6b04ea7fea8358669d0caebc7249" translate="yes" xml:space="preserve">
          <source>The path of the file from which the history (assuming a usable Term::ReadLine backend) will be read on the debugger's startup, and to which it will be saved on shutdown (for persistence across sessions). Similar in concept to Bash's &lt;code&gt;.bash_history&lt;/code&gt; file.</source>
          <target state="translated">历史记录（假设可用的Term :: ReadLine后端）将在调试器启动时从中读取，并且在关机时将其保存到该文件的路径（以确保跨会话的持久性）。在概念上与Bash的 &lt;code&gt;.bash_history&lt;/code&gt; 文件类似。</target>
        </trans-unit>
        <trans-unit id="b7867a311910479846a23412feb4307a4674c491" translate="yes" xml:space="preserve">
          <source>The path to the &lt;code&gt;git&lt;/code&gt; binary to use for the Git features. The default is &lt;code&gt;/usr/local/bin/git&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f73d1d0634237caab821e6e9c8fad9914a18a73" translate="yes" xml:space="preserve">
          <source>The path to the file is automatically converted to a Unix like equivalent for use in the archive, and, if on MacOS, the file's modification time is converted from the MacOS epoch to the Unix epoch. So tar archives created on MacOS with &lt;b&gt;Archive::Tar&lt;/b&gt; can be read both with</source>
          <target state="translated">文件的路径会自动转换为Unix之类的文件，以供存档使用；如果在MacOS上，则文件的修改时间将从MacOS时代转换为Unix时代。因此，在MacOS上使用&lt;b&gt;Archive :: Tar&lt;/b&gt;创建的tar存档可以通过</target>
        </trans-unit>
        <trans-unit id="2ab24d7b050cb5882eec74eec0cbc6ea2a2768dd" translate="yes" xml:space="preserve">
          <source>The pathname of a POD file to syntax-check (defaults to standard input).</source>
          <target state="translated">要进行语法检查的POD文件的路径名(默认为标准输入)。</target>
        </trans-unit>
        <trans-unit id="3091661abc10e8b933048a63287800c8286b8cec" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing pod documentation to be output in usage message format (defaults to standard input).</source>
          <target state="translated">包含要以使用信息格式输出的 pod 文档的文件路径名(默认为标准输入)。</target>
        </trans-unit>
        <trans-unit id="5506a685c5fca482706d4108f11645e50bb17fd9" translate="yes" xml:space="preserve">
          <source>The pathname of a file from which to select sections of pod documentation (defaults to standard input).</source>
          <target state="translated">文件的路径名,用于选择 pod 文档的部分(默认为标准输入)。</target>
        </trans-unit>
        <trans-unit id="64067e36292a9c79bf92f0c4d392216daafe926d" translate="yes" xml:space="preserve">
          <source>The pattern begins with a class matching a subset of letters. Whenever this matches, a statement like &lt;code&gt;$count{'a'}++;&lt;/code&gt; is executed, incrementing the letter's counter. Then &lt;code&gt;(*FAIL)&lt;/code&gt; does what it says, and the regexp engine proceeds according to the book: as long as the end of the string hasn't been reached, the position is advanced before looking for another vowel. Thus, match or no match makes no difference, and the regexp engine proceeds until the entire string has been inspected. (It's remarkable that an alternative solution using something like</source>
          <target state="translated">模式以匹配字母子集的类开头。只要匹配，就使用 &lt;code&gt;$count{'a'}++;&lt;/code&gt; 类的语句；被执行，增加字母的计数器。然后 &lt;code&gt;(*FAIL)&lt;/code&gt; 进行说明，然后正则表达式引擎根据该书继续进行：只要未到达字符串的末尾，在寻找另一个元音之前，该位置将前进。因此，匹配或不匹配没有区别，并且正则表达式引擎继续进行直到检查了整个字符串。 （值得注意的是，替代解决方案使用类似</target>
        </trans-unit>
        <trans-unit id="a027102deb051cbffb2428b7b7a47e74a500b189" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;a href=&quot;#defined-EXPR&quot;&gt;&lt;code&gt;defined&lt;/code&gt;&lt;/a&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="194b10f85ac928e670426276285fc77367b6bf3e" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">模式匹配成功并且 &lt;code&gt;$1&lt;/code&gt; 被定义，尽管它匹配&amp;ldquo; nothing&amp;rdquo;。它确实没有匹配任何东西。相反，它匹配的东西恰好是零个字符。这一切都是坦率和诚实的。当一个函数返回一个未定义的值时，就表示它不能给您一个诚实的答案。因此，仅在质疑您要执行的操作的完整性时，才应使用 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 。在其他时候，您想要的是与 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;&quot;&quot;&lt;/code&gt; 的简单比较。</target>
        </trans-unit>
        <trans-unit id="6ccde9606e998bb56b83482fdb0ce2d1cd2b87e5" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">模式匹配成功并且 &lt;code&gt;$1&lt;/code&gt; 被定义，尽管它匹配&amp;ldquo; nothing&amp;rdquo;。它确实没有匹配任何东西。相反，它匹配的东西恰好是零个字符。这一切都是坦率和诚实的。当一个函数返回一个未定义的值时，就表示它不能给您一个诚实的答案。因此，仅在质疑您要执行的操作的完整性时，才应使用 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 。在其他时候，您想要的是与 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;&quot;&quot;&lt;/code&gt; 的简单比较。</target>
        </trans-unit>
        <trans-unit id="00e74cbb0f8570bc720cdf9f1dc73c5533c198b5" translate="yes" xml:space="preserve">
          <source>The pattern matching metacharacters &quot;(&quot;, &quot;)&quot;, and &quot;|&quot; do not have backslashes in front.</source>
          <target state="translated">模式匹配的元字符&quot;(&quot;、&quot;)&quot;和&quot;|&quot;前面没有反斜杠。</target>
        </trans-unit>
        <trans-unit id="8647f015f186197cabe9c1508a8d5b1dddf875e9" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="translated">在不使用 &lt;code&gt;=~&lt;/code&gt; 运算符的情况下使用模式匹配操作 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; （aka &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="86784bd21e39089878c5197cae9b26fe435b4866" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt; and &lt;code&gt;tr///&lt;/code&gt; (aka &lt;code&gt;y///&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216352b3a9f025091614aa329a166fdb30a18a8e" translate="yes" xml:space="preserve">
          <source>The pattern modifiers:</source>
          <target state="translated">模式修改器。</target>
        </trans-unit>
        <trans-unit id="a2c1a780666383b49402abd005e8fafffcab62b8" translate="yes" xml:space="preserve">
          <source>The pattern of macro calls is like this:</source>
          <target state="translated">宏调用的模式是这样的。</target>
        </trans-unit>
        <trans-unit id="3569af6a782c9884f9c5e89ba969f12fe42cf2da" translate="yes" xml:space="preserve">
          <source>The pattern really,</source>
          <target state="translated">这个模式真的。</target>
        </trans-unit>
        <trans-unit id="f373f7a0e4daf869b86fcbb5c4b5b4f2ee465c22" translate="yes" xml:space="preserve">
          <source>The pattern will be used as a Perl regular expression (as opposed to a simple grep regex).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a46001019582eae5c4e5728c4a3fb31cd3dbf38" translate="yes" xml:space="preserve">
          <source>The patterns used in Perl pattern matching evolved from those supplied in the Version 8 regex routines. (The routines are derived (distantly) from Henry Spencer's freely redistributable reimplementation of the V8 routines.) See &lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;Version 8 Regular Expressions&lt;/a&gt; for details.</source>
          <target state="translated">Perl模式匹配中使用的模式是从版本8 regex例程中提供的模式演变而来的。（这些例程（从（远处）派生自Henry Spencer的V8例程的可自由重新分配的重新实现。）有关详细信息，请参见&lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;版本8正则表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e790c64d043de1336b86cfb89ee718b54cb057cd" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;&quot;Compile pass 3: peephole optimization&quot; in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;&quot;PL_rpeepp&quot;&lt;/a&gt; hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8569c5379da2f4cde343faebf02e081c76fc9c06" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;&quot;Compile pass 3: peephole optimization&quot; in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;&quot;PL_peepp&quot;&lt;/a&gt; hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dac0ad9b1d3df00129661ed1e95ffc2c13f0c968" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt; hook.</source>
          <target state="translated">窥孔优化器绝对不能完全更换。而是通过包装现有的优化器向其添加代码。在&lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3：perlguts中的窥孔优化中&lt;/a&gt;可以看到执行此操作的基本方法。如果新代码希望在整个子例程的结构上而不是仅在顶层上对ops进行操作，则包装&lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt;钩子可能会更方便。</target>
        </trans-unit>
        <trans-unit id="db43041726026c591925cfc25e5688f00dc4bbac" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt; hook.</source>
          <target state="translated">窥孔优化器绝对不能完全更换。而是通过包装现有的优化器向其添加代码。在&lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3：perlguts中的窥孔优化中&lt;/a&gt;可以看到执行此操作的基本方法。如果新代码只希望在子例程的顶层操作而不是在整个结构中操作，则包装&lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt;钩子可能会更方便。</target>
        </trans-unit>
        <trans-unit id="ace3f1e6483238aa81eb601036e5dcd7d2b38b3a" translate="yes" xml:space="preserve">
          <source>The per-instance data are held in memory beyond the basic PerlIOl struct, by making a PerlIOl the first member of the layer's struct thus:</source>
          <target state="translated">每个实例的数据被保存在基本的PerlIOl结构之外的内存中,通过使PerlIOl成为层结构的第一个成员,这样。</target>
        </trans-unit>
        <trans-unit id="467fb902a44226db21d27e75dc641b031d86cd72" translate="yes" xml:space="preserve">
          <source>The per-instance data for a particular handle.</source>
          <target state="translated">特定手柄的每个实例数据。</target>
        </trans-unit>
        <trans-unit id="85e58f1f52dd9a0e84852e44b90f48bbed040fce" translate="yes" xml:space="preserve">
          <source>The per-record overhead will limit the maximum number of records you can access per file. Note that</source>
          <target state="translated">每条记录的开销将限制你在每个文件中可以访问的最大记录数。请注意</target>
        </trans-unit>
        <trans-unit id="874d7f7aa12fc5ea3bd61b16d41289fe642a630c" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot;</source>
          <target state="translated">除了&quot;...&quot;之外,句号&quot;...&quot;与任何字符相匹配。</target>
        </trans-unit>
        <trans-unit id="e038fd297e6c1d463ecc98d5fcaacd0e4180bccd" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot; (unless the modifier &lt;code&gt;//s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="translated">时期 '。' 匹配除&amp;ldquo; \ n&amp;rdquo;以外的任何字符（除非修饰符 &lt;code&gt;//s&lt;/code&gt; 有效，如下所述）。</target>
        </trans-unit>
        <trans-unit id="bc11993ee6fae379fe2dbc40f494f74a38651177" translate="yes" xml:space="preserve">
          <source>The period &lt;code&gt;'.'&lt;/code&gt; matches any character but &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (unless the modifier &lt;code&gt;/s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50625043a5bdab5548c251e25233bc0e03a34159" translate="yes" xml:space="preserve">
          <source>The perl code in PerlIO.pm then attempts to locate a layer by doing</source>
          <target state="translated">然后,PerlIO.pm中的perl代码试图通过以下操作来定位一个层</target>
        </trans-unit>
        <trans-unit id="634e60cc8e248b9b7ce51ac444bfec05dc82ef31" translate="yes" xml:space="preserve">
          <source>The perl command to use is determined by &lt;a href=&quot;#get_perl&quot;&gt;&quot;get_perl&quot;&lt;/a&gt;. The command generated is guaranteed to preserve:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b7e5af7739f86fd0e9e79d11ca97ac5649e9b1" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt; . The basic rule of perl exceptions is that &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (in the absence of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; , while &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; .</source>
          <target state="translated">perl核心将 &lt;code&gt;setjmp()&lt;/code&gt; 等包装在宏 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 和 &lt;code&gt;JMPENV_JUMP&lt;/code&gt; 中。perl的异常的基本规则是， &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; ，和 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; （在不存在的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ）执行 &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; ，而 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 内 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 做了 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6c71858536e734e97d2970ba2f758d971d8a580" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt;. The basic rule of perl exceptions is that &lt;code&gt;exit&lt;/code&gt;, and &lt;code&gt;die&lt;/code&gt; (in the absence of &lt;code&gt;eval&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt;, while &lt;code&gt;die&lt;/code&gt; within &lt;code&gt;eval&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fdbc7e5dc74277662b153d8f95c93e631321b8b" translate="yes" xml:space="preserve">
          <source>The perl equivalent is &lt;code&gt;$sv = undef;&lt;/code&gt;. Note that it doesn't free any string buffer, unlike &lt;code&gt;undef $sv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c474186075797ee40452934f04a51f573b827bb" translate="yes" xml:space="preserve">
          <source>The perl executable is obtained by linking</source>
          <target state="translated">perl可执行文件可以通过链接到</target>
        </trans-unit>
        <trans-unit id="1d8ff0cddfb59dc7ae9ad6feb4a5e65da142f6d6" translate="yes" xml:space="preserve">
          <source>The perl history contains one mistake which was not caught in the conversion: a merge was recorded in the history between blead and maint-5.10 where no merge actually occurred. Due to the nature of git, this is now impossible to fix in the public repository. You can remove this mis-merge locally by adding the following line to your &lt;code&gt;.git/info/grafts&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ded168a76972d517d9136275d2690412f2929f" translate="yes" xml:space="preserve">
          <source>The perl message comes out with &quot;Perl&quot; in front. The &lt;code&gt;BEGIN&lt;/code&gt; block works at compile time so all of the compilation errors and warnings get the &quot;Perl:&quot; prefix too.</source>
          <target state="translated">perl消息前面带有&amp;ldquo; Perl&amp;rdquo;。该 &lt;code&gt;BEGIN&lt;/code&gt; 在编译时块的工作，因此所有的编译错误和警告得到&amp;ldquo;的Perl：&amp;rdquo;前缀了。</target>
        </trans-unit>
        <trans-unit id="b63df2b573a7b7008051f6d3411e1d7de7dd31b6" translate="yes" xml:space="preserve">
          <source>The perl source is in a git repository. You can clone the repository with the following command:</source>
          <target state="translated">perl源代码在git仓库中。你可以用下面的命令来克隆仓库。</target>
        </trans-unit>
        <trans-unit id="c5f10541bc3ed7ff03899b584c515233e642fba7" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;&quot;Calling Perl Routines from within C Programs&quot;&lt;/a&gt; for details on how to do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327d340c9d37adf78ea3fa44d3b1c6e9e8b77c71" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Calling Perl Routines from within C Programs&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">perl tie函数将变量与实现各种GET，SET等方法的对象相关联。若要执行等效于XSUB的perl tie功能，您必须模仿此行为。下面的代码执行必要的步骤-首先创建一个新的哈希，然后创建第二个哈希，并将其加到要实现tie方法的类中。最后，它将两个哈希绑定在一起，并返回对新绑定哈希的引用。请注意，下面的代码不会调用MyTie类中的TIEHASH方法- 有关如何执行此操作的详细信息，请参见&lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;从C程序中调用Perl例程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="123c31a7a632081aa07f5ab58c14ca27dc4643f2" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt; .</source>
          <target state="translated">生成的XS子例程的Perl可见名称，它将返回常量。默认为 &lt;code&gt;constant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be6633f7068d6499b516b1dff2ff6cfb89ba5f0c" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87baa838c319b67b0a259076dbfb27270de34c58" translate="yes" xml:space="preserve">
          <source>The perl-mvs@perl.org list is for discussion of porting issues as well as general usage issues for all EBCDIC Perls. Send a message body of &quot;subscribe perl-mvs&quot; to majordomo@perl.org.</source>
          <target state="translated">perl-mvs@perl.org 列表用于讨论所有 EBCDIC Perls 的移植问题以及一般使用问题。发送 &quot;订阅perl-mvs &quot;的消息到majordomo@perl.org。</target>
        </trans-unit>
        <trans-unit id="5ba3dea55a126a532be4f9eaeca0422de96d0827" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="translated">perl5-changes邮件列表会收到每个修补程序的副本，该副本将提交给perl存储库的维护和开发分支。有关订阅和存档信息，请参见&lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ba06e1bf85435dc89a1bc7a3e1228003027ef95" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;https://lists.perl.org/list/perl5-changes.html&quot;&gt;https://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c029dc7e52d0d0d6369cc3ff0e62686a113c165" translate="yes" xml:space="preserve">
          <source>The perl5-porters (p5p) mailing list is where the Perl standard distribution is maintained and developed. The people who maintain Perl are also referred to as the &quot;Perl 5 Porters&quot;, &quot;p5p&quot; or just the &quot;porters&quot;.</source>
          <target state="translated">perl5-porters (p5p)邮件列表是维护和开发 Perl 标准发行版的地方。维护Perl的人也被称为 &quot;Perl 5 Porters&quot;、&quot;p5p &quot;或只是 &quot;porters&quot;。</target>
        </trans-unit>
        <trans-unit id="3a8b72ced5fe1018b53d36c163e0f112a1621d18" translate="yes" xml:space="preserve">
          <source>The perlXYZ.sis includes only the Perl DLL: to create an additional SIS file which includes some of the standard (pure) Perl libraries, issue the command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8239507ba48e88fe2cac6b5f08faa6b68602a3e2" translate="yes" xml:space="preserve">
          <source>The perlapp.sis (11 kB -&amp;gt; 16 kB) will be built in the symbian subdirectory, but a copy will also be made to the main directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55339a112f571a65cc173aaae9b60118d4926fb7" translate="yes" xml:space="preserve">
          <source>The perlbug program will ask you a few questions about your email address and the patch you're submitting. Once you've answered them it will submit your patch via email.</source>
          <target state="translated">perlbug 程序会问你一些关于你的电子邮件地址和你要提交的补丁的问题。一旦你回答了这些问题,它就会通过电子邮件提交你的补丁。</target>
        </trans-unit>
        <trans-unit id="a319a07f2540ad16252f1fe55565bcf46c56c4bb" translate="yes" xml:space="preserve">
          <source>The perldoc for utime also has an example that has the same effect as touch(1) on files that</source>
          <target state="translated">utime的perldoc中也有一个例子,它与touch(1)对以下文件有同样的效果。</target>
        </trans-unit>
        <trans-unit id="ed575d398752b423e73c91acec2e13e6122dc7e1" translate="yes" xml:space="preserve">
          <source>The perlfaq comprises several documents that answer the most commonly asked questions about Perl and Perl programming. It's divided by topic into nine major sections outlined in this document.</source>
          <target state="translated">perlfaq由几个文档组成,回答了关于Perl和Perl编程最常见的问题。它按主题分为本文档概述的九个主要部分。</target>
        </trans-unit>
        <trans-unit id="bf571460e6819407bba20acb1eb1771f32d393cd" translate="yes" xml:space="preserve">
          <source>The perlfaq is an evolving document. Read the latest version at &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;. It is also included in the standard Perl distribution.</source>
          <target state="translated">perlfaq是一份不断发展的文档。请访问&lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;阅读最新版本。它也包含在标准Perl发行版中。</target>
        </trans-unit>
        <trans-unit id="d8ba3c9bbcf37ca492d8ac656f9c49509454f36e" translate="yes" xml:space="preserve">
          <source>The perlpod spec for a Verbatim paragraph is &quot;It should be reproduced exactly...&quot;, which means that the whitespace you've used to indent your verbatim blocks will be preserved in the output. This can be annoying for outputs such as HTML, where that whitespace will remain in front of every line. It's an unfortunate case where syntax is turned into semantics.</source>
          <target state="translated">perlpod对逐字段的规范是 &quot;它应该被精确地复制......&quot;,这意味着你用来缩进逐字段的空白将被保留在输出中。这对于像HTML这样的输出来说是很烦人的,因为在这些输出中,每行前面都会保留空白。这是一个不幸的例子,语法变成了语义。</target>
        </trans-unit>
        <trans-unit id="d320cdc510ba6fe180a797e4852d051df0ce9e8c" translate="yes" xml:space="preserve">
          <source>The perlstyle manual supplied with Perl has many helpful points.</source>
          <target state="translated">Perl附带的perlstyle手册中有很多有用的地方。</target>
        </trans-unit>
        <trans-unit id="f61630dfa6a2b75f5a9ee952e22583e2bdae4aef" translate="yes" xml:space="preserve">
          <source>The person whom the &lt;b&gt;operating system&lt;/b&gt; will let do almost anything. Typically your system administrator or someone pretending to be your system administrator. On Unix systems, the &lt;b&gt;root&lt;/b&gt; user. On Windows systems, usually the Administrator user.</source>
          <target state="translated">&lt;b&gt;操作系统&lt;/b&gt;会让任何人做的人。通常，您的系统管理员或冒充您的系统管理员的人。在Unix系统上，是&lt;b&gt;root&lt;/b&gt;用户。在Windows系统上，通常是管理员用户。</target>
        </trans-unit>
        <trans-unit id="4a687dacf6873e351f87d30c48226233e28a0761" translate="yes" xml:space="preserve">
          <source>The pinyin ordering includes some characters that are not CJK Unified Ideographs and can't utilize &lt;code&gt;weightPinyin()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674e8f557a9263711bdd1bff3bb098f69b9e9b84" translate="yes" xml:space="preserve">
          <source>The pipeline model divides up a task into a series of steps, and passes the results of one step on to the thread processing the next. Each thread does one thing to each piece of data and passes the results to the next thread in line.</source>
          <target state="translated">管道模型将一个任务分为一系列步骤,并将一个步骤的结果传递给下一个处理的线程。每个线程对每一个数据做一件事,并将结果传递给下一个线程。</target>
        </trans-unit>
        <trans-unit id="e5963c8e8de82f4449d7ed9e1e51afdf5f459ee1" translate="yes" xml:space="preserve">
          <source>The pl2pm utility will get you started.</source>
          <target state="translated">pl2pm工具将让你开始使用。</target>
        </trans-unit>
        <trans-unit id="1d36c8a340c756f47102c1832b54cb16f13c0c7c" translate="yes" xml:space="preserve">
          <source>The plan (for example, '1..5'), must only come at the beginning or end of the TAP output.</source>
          <target state="translated">计划(例如'1...5'),只能在TAP输出的开头或结尾出现。</target>
        </trans-unit>
        <trans-unit id="b8f929ee511ca422d9eb63d2f4f5d86c27217779" translate="yes" xml:space="preserve">
          <source>The plan event for the subtest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4326b3bc4ca816f9708e08eacb7250e5b64a4e86" translate="yes" xml:space="preserve">
          <source>The plugin system in the CPAN shell was introduced in version 2.07 and is still considered experimental.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09a69221209bb270cc3034edeb1fb83d92c2242" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; function so that &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc2d017a3ab4b5deac17556464426823c475059" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">该函数的重点是&amp;ldquo;植入&amp;rdquo; &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 函数，以便每次运行程序时 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 都能产生不同的序列。当使用参数调用时， &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 将其用作种子；否则（半）随机选择种子。无论哪种情况，从Perl 5.14开始，它都会返回种子。表示您的代码可以工作</target>
        </trans-unit>
        <trans-unit id="2e1f3e31ba6a1b36a8c681657ab8caf017949b14" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">该函数的重点是&amp;ldquo;植入&amp;rdquo; &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 函数，以便每次运行程序时 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 都能产生不同的序列。当使用参数调用时， &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 将其用作种子；否则（半）随机选择种子。无论哪种情况，从Perl 5.14开始，它都会返回种子。表示您的代码可以工作</target>
        </trans-unit>
        <trans-unit id="d8e49cca1375307d0cbb7648d543980bc0807cf4" translate="yes" xml:space="preserve">
          <source>The pointer is blessed into a class that is derived from the name of type of the pointer but with all '*' in the name replaced with 'Ptr'.</source>
          <target state="translated">指针被祝福成一个类,这个类是由指针的类型名派生出来的,但名字中的'*'都被替换成'Ptr'。</target>
        </trans-unit>
        <trans-unit id="549bcd1d7ae81c0474487c42c591f283db8f5fed" translate="yes" xml:space="preserve">
          <source>The pointer to the PV of the &lt;code&gt;dsv&lt;/code&gt; is returned.</source>
          <target state="translated">返回指向 &lt;code&gt;dsv&lt;/code&gt; PV的指针。</target>
        </trans-unit>
        <trans-unit id="7ab31953e34eba90fc36ab51df0189b64f65aae0" translate="yes" xml:space="preserve">
          <source>The points to note are</source>
          <target state="translated">需要注意的是</target>
        </trans-unit>
        <trans-unit id="c1fdc510fd28f743532d0f8810f2c036e2bf9b84" translate="yes" xml:space="preserve">
          <source>The polar notation (also known as the trigonometric representation) is much more handy for performing multiplications and divisions of complex numbers, whilst the cartesian notation is better suited for additions and subtractions. Real numbers are on the</source>
          <target state="translated">极坐标符号(也称为三角符号)在进行复数的乘法和除法时更为方便,而卡提斯符号则更适合于加减法。实数是在</target>
        </trans-unit>
        <trans-unit id="b5ec1158a1165100647b29065f9f5443b0e8eb69" translate="yes" xml:space="preserve">
          <source>The polar style attempts to emphasize arguments like</source>
          <target state="translated">两极风格试图强调这样的论点,如</target>
        </trans-unit>
        <trans-unit id="69fec36a5f0f42b7b7ddc49268b5d8cea58e3639" translate="yes" xml:space="preserve">
          <source>The popular tool &lt;code&gt;sudo&lt;/code&gt; provides a controlled way for users to be able to run programs as other users. It sanitises the execution environment to some extent, and will avoid the &lt;a href=&quot;#Shebang-Race-Condition&quot;&gt;shebang race condition&lt;/a&gt;. If you don't have the safe version of set-id scripts, then &lt;code&gt;sudo&lt;/code&gt; may be a more convenient way of executing a script as another user than writing a C wrapper would be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2c870c4a68cedcedbfdb919f7afe57be993942" translate="yes" xml:space="preserve">
          <source>The port for Win32 was used as a reference.</source>
          <target state="translated">Win32的端口被用作参考。</target>
        </trans-unit>
        <trans-unit id="e9a7460e24d0700d3e12dc5c76ead4d814126aa5" translate="yes" xml:space="preserve">
          <source>The port of Perl to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9181a3290f36ca81b3bb6720fe9893dc45df567f" translate="yes" xml:space="preserve">
          <source>The port of Perl to to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="translated">从Perl 5.12开始,Perl到Mac OS的移植被正式取消,不过MacPerl的最后一个正式生产版本对应的是Perl 5.6。虽然Perl 5.10包含了对Mac OS的移植,但ExtUtils::MakeMaker,作为Perl模块安装基础架构的核心部分,在2004年4月正式取消了对Mac OS的支持。</target>
        </trans-unit>
        <trans-unit id="f4180538d74696f5817f3f6feca9a1c65e2c02f2" translate="yes" xml:space="preserve">
          <source>The porters appreciate the time you spent helping to make Perl better. Thank you!</source>
          <target state="translated">搬运工感谢你花时间帮助Perl变得更好。谢谢你们</target>
        </trans-unit>
        <trans-unit id="54bd391c46a02c41cb9ecadecb266d6444c3a53a" translate="yes" xml:space="preserve">
          <source>The portion of the extension provided by the XS code may be connected to the rest of Perl in either of two ways. In the &lt;b&gt;static&lt;/b&gt; configuration, the object code for the extension is linked directly into</source>
          <target state="translated">XS代码提供的扩展部分可以通过两种方式之一连接到Perl的其余部分。在&lt;b&gt;静态&lt;/b&gt;配置中，扩展的目标代码直接链接到</target>
        </trans-unit>
        <trans-unit id="2605e3cd341c048b0037bbd123fa8ea2ca949be7" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c71fa06187e2cb76d45cf6769bdd2d2cbe65fe5" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="translated">FILEHANDLE在文件中的位置保持不变。您可能要在写入文件之前调用&lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;查找&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efdfff91986b015ed9943f5eed1ac7ffd6711ca2" translate="yes" xml:space="preserve">
          <source>The possessive forms (new in Perl 5.10) prevent backtracking: what gets matched by a pattern with a possessive quantifier will not be backtracked into, even if that causes the whole match to fail.</source>
          <target state="translated">占有式(Perl 5.10 中新增的)可以防止回溯:被带有占有式量化符的模式匹配的内容不会被回溯到,即使这会导致整个匹配失败。</target>
        </trans-unit>
        <trans-unit id="5eab19b8b748f65afb0049c25c884441fbae1bc8" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="translated">可能的类别是：： &lt;code&gt;:collate&lt;/code&gt; ， &lt;code&gt;:ctype&lt;/code&gt; ， &lt;code&gt;:messages&lt;/code&gt; ， &lt;code&gt;:monetary&lt;/code&gt; ， &lt;code&gt;:numeric&lt;/code&gt; ， &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 和伪类别 &lt;code&gt;:characters&lt;/code&gt; （如下所述）。</target>
        </trans-unit>
        <trans-unit id="b9cec0c735ea3bb0489e4ea0d12dfd9112e5e476" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt;, &lt;code&gt;:ctype&lt;/code&gt;, &lt;code&gt;:messages&lt;/code&gt;, &lt;code&gt;:monetary&lt;/code&gt;, &lt;code&gt;:numeric&lt;/code&gt;, &lt;code&gt;:time&lt;/code&gt;, and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fdb180b333447352b78de9f2313423642a41c9" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;a href=&quot;fcntl&quot;&gt;&lt;code&gt;Fcntl&lt;/code&gt;&lt;/a&gt;. See the documentation of your operating system's &lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open(2)&lt;/a&gt; syscall to see which values and flag bits are available. You may combine several flags using the &lt;code&gt;|&lt;/code&gt;-operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6655e8efe41a46d2438d144ed4d6129c437e80b" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;code&gt;Fcntl&lt;/code&gt; . See the documentation of your operating system's</source>
          <target state="translated">MODE参数的可能值和标志位取决于系统。可通过标准模块 &lt;code&gt;Fcntl&lt;/code&gt; 使用它们。请参阅您操作系统的文档</target>
        </trans-unit>
        <trans-unit id="f5b739ecc638266d58487c7c88c27f4bcc3311ca" translate="yes" xml:space="preserve">
          <source>The possibly inferred link-text; i.e., if there was no real link text, then this is the text that we'll infer in its place. (E.g., for &quot;L&amp;lt;Getopt::Std&amp;gt;&quot;, the inferred link text is &quot;Getopt::Std&quot;.)</source>
          <target state="translated">可能推断出的链接文本；即，如果没有真正的链接文本，那么这就是我们将在其位置推断的文本。（例如，对于&amp;ldquo; L &amp;lt;Getopt :: Std&amp;gt;&amp;rdquo;，推断的链接文本为&amp;ldquo; Getopt :: Std&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="4e5ec7c69ae0bd18f551874e75cc4c912902b3a0" translate="yes" xml:space="preserve">
          <source>The practice of saying, &amp;ldquo;If I had to do it all over, I&amp;rsquo;d do it differently,&amp;rdquo; and then actually going back and doing it all over differently. Mathematically speaking, it&amp;rsquo;s returning from an unsuccessful recursion on a tree of possibilities. Perl backtracks when it attempts to match patterns with a &lt;b&gt;regular expression&lt;/b&gt;, and its earlier attempts don&amp;rsquo;t pan out. See the section &amp;ldquo;The Little Engine That /Couldn(n&amp;rsquo;t)&amp;rdquo; in Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">这样说：&amp;ldquo;如果我必须一遍又一遍，我会以不同的方式来做&amp;rdquo;，然后实际上回头并以不同的方式来做一遍。从数学上讲，它是从对可能性树的不成功递归中返回的。当Perl尝试使用&lt;b&gt;正则表达式&lt;/b&gt;匹配模式时，它会回溯，并且其较早的尝试不会成功。请参阅骆驼第5章&amp;ldquo;模式匹配&amp;rdquo;中的&amp;ldquo; /无法（启用）的小引擎&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="03599d25f97c0e2d0192955c405d8519204aa81e" translate="yes" xml:space="preserve">
          <source>The practice of shifting an alphabet one or more characters for encipherment dates back thousands of years and was explicitly detailed by Gaius Julius Caesar in his &lt;b&gt;Gallic Wars&lt;/b&gt; text. A single alphabet shift is sometimes referred to as a rotation and the shift amount is given as a number $n after the string 'rot' or &quot;rot$n&quot;. Rot0 and rot26 would designate identity maps on the 26-letter English version of the Latin alphabet. Rot13 has the interesting property that alternate subsequent invocations are identity maps (thus rot13 is its own non-trivial inverse in the group of 26 alphabet rotations). Hence the following is a rot13 encoder and decoder that will work on ASCII and EBCDIC platforms:</source>
          <target state="translated">将字母转换为一个或多个字符进行加密的做法可以追溯到数千年前，盖乌斯&amp;middot;朱利叶斯&amp;middot;凯撒（Gaius Julius Caesar）在他的《&lt;b&gt;高卢战争》（Gallic Wars）&lt;/b&gt;文字中对此进行了详细说明。有时将单个字母移位称为旋转，并将移位量表示为字符串&amp;ldquo; rot&amp;rdquo;或&amp;ldquo; rot $ n&amp;rdquo;之后的数字$ n。 Rot0和rot26将在拉丁字母的26个字母的英语版本上指定身份映射。 Rot13具有有趣的特性，即交替的后续调用是身份映射（因此rot13是其自身在26个字母旋转的组中的非平凡逆）。因此，以下是适用于ASCII和EBCDIC平台的rot13编码器和解码器：</target>
        </trans-unit>
        <trans-unit id="a4931fe0eefec05b185de502969d863746246773" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="translated">在编译 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ，使 &lt;code&gt;$?&lt;/code&gt; 反映实际的VMS退出状态，而不是上述的POSIX状态的默认模拟。设置 &lt;code&gt;$?&lt;/code&gt; 时，该实用程序还会禁止将非零值转换为SS $ _ABORT 。在END块中（但零仍将转换为SS $ _NORMAL）。</target>
        </trans-unit>
        <trans-unit id="91d3ea3fbae8cd7072d27f773df4ade3db8e3a56" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ba59d998f30d35a2800e28be03d01cb711ce6c" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; pragma was supported and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="translated">编译指示是每个脚本而不是每个块的词汇。只有最后 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; 重要，它影响&lt;b&gt;了整个脚本&lt;/b&gt;。但是， &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; 杂乱码受支持，并且 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 可以在给定脚本中出现任意多次（尽管只有最后一个有效）。</target>
        </trans-unit>
        <trans-unit id="9e7b1da1b87c8f47d3de1bab74d0b204e260e393" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;use encoding&lt;/code&gt; or &lt;code&gt;no encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;no encoding&lt;/code&gt; pragma was supported and &lt;code&gt;use encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b4d970b42fbff322fe3d169272f393cc128f89" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="translated">编译指示&lt;a href=&quot;../bignum&quot;&gt;BIGNUM&lt;/a&gt;，&lt;a href=&quot;../bigint&quot;&gt;BIGINT&lt;/a&gt;和&lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt;因为他们解决autoupgrading /降级问题，至少部分也可能会感兴趣。</target>
        </trans-unit>
        <trans-unit id="76569ddba56c9f99056592d21ac1b2ff490f26ec" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984c1d7b1bad11977f9a25ba621b51c787c8e6c4" translate="yes" xml:space="preserve">
          <source>The preamble added to each output file is rather verbose, and most of it is only necessary in the presence of non-ASCII characters. It would ideally be nice if all of those definitions were only output if needed, perhaps on the fly as the characters are used.</source>
          <target state="translated">添加到每个输出文件中的序言相当啰嗦,而且大多数序言只有在出现非ASCII字符时才是必要的。如果所有这些定义只在需要的时候才输出,或许在使用字符的过程中即时输出,那就更好了。</target>
        </trans-unit>
        <trans-unit id="45357f49e477501b84ee9e2077b2244c8a2bb54d" translate="yes" xml:space="preserve">
          <source>The preamble code for the class is as follows:</source>
          <target state="translated">该类的前言代码如下。</target>
        </trans-unit>
        <trans-unit id="b4c4542a57f99c1f10f3ac073718f1821e067ea0" translate="yes" xml:space="preserve">
          <source>The preference of the &lt;b&gt;regular expression&lt;/b&gt; engine to match the leftmost occurrence of a &lt;b&gt;pattern&lt;/b&gt;, then given a position at which a match will occur, the preference for the longest match (presuming the use of a &lt;b&gt;greedy&lt;/b&gt; quantifier). See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo; for</source>
          <target state="translated">所述的优先级&lt;b&gt;的正则表达式&lt;/b&gt;引擎匹配的最左边的发生&lt;b&gt;模式&lt;/b&gt;，然后在给定的其中一个匹配会发生位置，为最长匹配偏好（假设使用的&lt;b&gt;贪婪&lt;/b&gt;量词）。有关信息，请参见骆驼第5章&amp;ldquo;模式匹配&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="fb28a274f1049ea39bf5f7992f63f38b064b26ab" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; .</source>
          <target state="translated">首选的方法是在 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; 时声明一个计划。</target>
        </trans-unit>
        <trans-unit id="5006ab06a26ab8e5eca93c03d0291151f3f3136d" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;use Test::More&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a070b02ec3ff7789ebf48e13bc147cc73129be84" translate="yes" xml:space="preserve">
          <source>The prefix specified by &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; will be used with a numeric suffix if the name for a value is undefined.</source>
          <target state="translated">如果未定义值的名称，则 &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; 指定的前缀将带有数字后缀。</target>
        </trans-unit>
        <trans-unit id="47b994ba12e424b0e632ed96c89a1498fbc470f8" translate="yes" xml:space="preserve">
          <source>The presence of the word &quot;FATAL&quot; in the category list will escalate warnings in those categories into fatal errors in that lexical scope.</source>
          <target state="translated">在类别列表中出现 &quot;FATAL &quot;一词,将把这些类别中的警告升级为该词法范围内的致命错误。</target>
        </trans-unit>
        <trans-unit id="7069f5b0b1dc1568e108cd084477a400c3f8668e" translate="yes" xml:space="preserve">
          <source>The previous assignments are exactly equivalent to</source>
          <target state="translated">前面的作业完全等同于</target>
        </trans-unit>
        <trans-unit id="131e26e34a6a280e8d155fa06c2fe106438c82bd" translate="yes" xml:space="preserve">
          <source>The previous behavior of putting the errors (converted to POSIX-style &lt;code&gt;E*&lt;/code&gt; error codes since Perl 5.20.0) into &lt;code&gt;$!&lt;/code&gt; was buggy due to the non-equivalence of like-named Winsock and POSIX error constants, a relationship between which has unfortunately been established in one way or another since Perl 5.8.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4bba88bb17e91a3967206974b895243970981e" translate="yes" xml:space="preserve">
          <source>The previous example was not particularly useful. To make it more general purpose we will make use of the context data and allow any arbitrary</source>
          <target state="translated">前面的例子不是特别有用。为了使其更加通用,我们将利用上下文数据,允许任意的</target>
        </trans-unit>
        <trans-unit id="e9b3a0712244fd40d4ef0fb4f6b05e3de06f443f" translate="yes" xml:space="preserve">
          <source>The previous paragraph is applicable verbatim to tied hash access using the &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; functions as well.</source>
          <target state="translated">上一段同样适用于使用 &lt;code&gt;hv_store&lt;/code&gt; 和 &lt;code&gt;hv_store_ent&lt;/code&gt; 函数的绑定哈希访问。</target>
        </trans-unit>
        <trans-unit id="dd2b650563ddd2d2b6e29ef9f64d0b20b2f5e086" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any text. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="translated">上一节（由 &lt;code&gt;=head&lt;/code&gt; 命令引入）不包含任何文本。这通常表示缺少某些东西。注： &lt;code&gt;=head1&lt;/code&gt; ，紧接着 &lt;code&gt;=head2&lt;/code&gt; 不会触发此警告。</target>
        </trans-unit>
        <trans-unit id="b2d4d760a41ac2c4684274cd24041bdb5438342a" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any valid content. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186c5466a670230e882670fbcd9b5aa0c0353eb4" translate="yes" xml:space="preserve">
          <source>The previous step created</source>
          <target state="translated">上一步创建了</target>
        </trans-unit>
        <trans-unit id="d900c388659851ed663901ca396af85f982c5cba" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;&quot;LD_LIBRARY_PATH&quot;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="340b1d36d10dcf0bc3c98148a5a96864b33866c8" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt; above.</source>
          <target state="translated">&amp;ldquo; dlopen：存根拦截失败&amp;rdquo;消息的主要原因是LD_LIBRARY_PATH环境变量包含一个目录，该目录是/ usr / lib（例如/ lib）的符号链接。请参阅上面的&lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b0f3d276de0b395d904df1ee65d02fbb91e800c" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; .</source>
          <target state="translated">该模块的主要目的是提供对zip文件和缓冲区的流写入访问。它不是通用文件存档器。如果这是您想要的，请签出 &lt;code&gt;Archive::Zip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7109b8aae18759607febf6d98f672f7929c0c0ad" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; or &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3562a709266ee6938735493658a732dcdd3f50d6" translate="yes" xml:space="preserve">
          <source>The primary reference for Zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adaddbe76e40b85855bdb3acd3e478586223f423" translate="yes" xml:space="preserve">
          <source>The primary reference for gzip files is RFC 1952 &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1952.html&quot;&gt;http://www.faqs.org/rfcs/rfc1952.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc24d550b4fe8851d0897e687949d42067e8b5a9" translate="yes" xml:space="preserve">
          <source>The primary reference for zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcb3725358ae123bceedddb8d71ef7119024583" translate="yes" xml:space="preserve">
          <source>The primary site for bzip2 is &lt;a href=&quot;http://www.bzip.org&quot;&gt;http://www.bzip.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d840d1ff084fc0827d16e21e7b3094c84c9a7a3" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is</source>
          <target state="translated">gzip的主要站点是</target>
        </trans-unit>
        <trans-unit id="e859dd2ba7bc9bbaa39a1807494221205b0a4770" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is &lt;a href=&quot;http://www.gzip.org&quot;&gt;http://www.gzip.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b9d6c85592a8675b44ceb172e5fcc460f2a10f" translate="yes" xml:space="preserve">
          <source>The primary site for the</source>
          <target state="translated">的主要场所。</target>
        </trans-unit>
        <trans-unit id="dff39311adfb064fbb523d321b7e4b3dbea2499f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is</source>
          <target state="translated">bzip2程序的主要站点是</target>
        </trans-unit>
        <trans-unit id="6d5111f3cd60b1576c60bc8b7e186e70a9cf368f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is &lt;a href=&quot;https://sourceware.org/bzip2/&quot;&gt;https://sourceware.org/bzip2/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a7ebabe8aa28f193ee803e7dabf5b8ae97c28d" translate="yes" xml:space="preserve">
          <source>The principal value of the arc tangent of y/x</source>
          <target state="translated">y/x的弧切线的主值</target>
        </trans-unit>
        <trans-unit id="c3a6a975854cac68d0d2fce1f652f0011a15276f" translate="yes" xml:space="preserve">
          <source>The principle is that the number of objects found influences how an item is displayed. If the search finds one item, the result is displayed with the rather verbose method &lt;code&gt;as_string&lt;/code&gt; , but if more than one is found, each object is displayed with the terse method &lt;code&gt;as_glimpse&lt;/code&gt; .</source>
          <target state="translated">原理是找到的对象数量会影响项目的显示方式。如果搜索找到一项，则使用相当冗长的方法 &lt;code&gt;as_string&lt;/code&gt; 显示结果，但是如果找到多个项，则使用简洁的方法 &lt;code&gt;as_glimpse&lt;/code&gt; 显示每个对象。</target>
        </trans-unit>
        <trans-unit id="febd9a2b7b0ebfb667a62ab220755a864d89456a" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; . You can set $OFS and $ORS if you're using the English module.</source>
          <target state="translated">除非您设置 &lt;code&gt;$,&lt;/code&gt; 和 &lt;code&gt;$\&lt;/code&gt; ，否则print（）语句不会添加字段和记录分隔符。如果使用英语模块，则可以设置$ OFS和$ ORS。</target>
        </trans-unit>
        <trans-unit id="2da7e391c9fd1ea8ee0cde415f9757d6cf29bace" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt;. You can set $OFS and $ORS if you're using the English module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38b92f2492beff5f39d922c93e2a6ed6bba00e9" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;_installed_file_for_module&lt;/code&gt; method may be replaced with other methods for locating a module in &lt;code&gt;@INC&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39cbd438adc424d857eb231b91cd98738e10a91c" translate="yes" xml:space="preserve">
          <source>The private data cache will take ownership of a reference to private_sv, much the same way that &lt;code&gt;hv_store()&lt;/code&gt; takes ownership of a reference to the value that you pass it.</source>
          <target state="translated">私有数据缓存将拥有对private_sv的引用的所有权，与 &lt;code&gt;hv_store()&lt;/code&gt; 拥有对您传递的值的引用的所有权的方式几乎相同。</target>
        </trans-unit>
        <trans-unit id="7c29fbafe2b5b36ada501a03eca4a2fd699c674d" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; .</source>
          <target state="translated">诸如 &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; 类的私有对象哈希键可能不会更改，但可以添加其他键，如 &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22731711df90de28382d892b4f249e651429dc6f" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660e221c9f99f43f8d3110d11068349758eb697d" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;&quot;RESTORE_LC_NUMERIC&quot;&lt;/a&gt; can restore it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da35a7db7a9991be43f0a35bab375b2fa2f7661" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; can restore it.</source>
          <target state="translated">private变量用于保存当前的语言环境状态，以便对&lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt;进行必要的匹配调用可以恢复它。</target>
        </trans-unit>
        <trans-unit id="2ca51914e8f8318dafeffce74323b676d587ba34" translate="yes" xml:space="preserve">
          <source>The private_use feature is experimental</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5290ff0dba8c2d4696fae469f418160732641247" translate="yes" xml:space="preserve">
          <source>The problem can be further examined in a roughly equivalent C program:</source>
          <target state="translated">这个问题可以在一个大致相当的C程序中进一步研究。</target>
        </trans-unit>
        <trans-unit id="13328591f6760dcc09259e6c0b9735e71fa4da38" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt; :</source>
          <target state="translated">当您从Perl认为是字符串的东西中获取数字时（例如 &lt;code&gt;@ARGV&lt;/code&gt; 中的命令行参数），就会出现问题：</target>
        </trans-unit>
        <trans-unit id="2c1b07cc8bfa77fdc4b2aa2cb8ca8cba9947e03f" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8bb5622c99567256e6a98501e22410a2a7900d" translate="yes" xml:space="preserve">
          <source>The problem comes when you have, for instance, a string that isn't flagged as UTF-8, and contains a byte sequence that could be UTF-8 -- especially when combining non-UTF-8 and UTF-8 strings.</source>
          <target state="translated">例如,当你有一个没有标记为UTF-8的字符串,并且包含一个可能是UTF-8的字节序列时,问题就来了--特别是当你把非UTF-8和UTF-8的字符串结合起来时。</target>
        </trans-unit>
        <trans-unit id="e918e6ad2cf12f5152c6540799f1ea5ccc7d457e" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="translated">存在该问题是因为分配给 &lt;code&gt;*Foo::foo&lt;/code&gt; glob 的匿名子例程将在调用堆栈中显示为被称为 &lt;code&gt;__ANON__&lt;/code&gt; 而不是您期望的 &lt;code&gt;foo&lt;/code&gt; 。由于 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 程序查找被调用的方法的名称，因此在这种情况下将失败。</target>
        </trans-unit>
        <trans-unit id="f6e3278fa9663415debfd4e39d0b068a1659902a" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;next::method&lt;/code&gt; uses &lt;code&gt;caller&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea1a84a6e43b26958b1598b1f93e9a632b83a16" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="translated">这里的问题是，Uid_t可能不仅在 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 范围内，而且可能没有符号，在这种情况下，大的uid将被打印为负值。</target>
        </trans-unit>
        <trans-unit id="27a99efdaf6b6471f2df947f1f817dd0e909810c" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;int&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56bc12834cd035d1009997925f3d7abe998a9788" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">这里的问题是，名为 &lt;code&gt;a&lt;/code&gt; 的组和名为 &lt;code&gt;b&lt;/code&gt; 的组都是属于 &lt;code&gt;$1&lt;/code&gt; 的组的别名。</target>
        </trans-unit>
        <trans-unit id="b18408c3bf47516e5c9af25c6047a1bd86154733" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda9a4d26fe1b0eb3aeffd7cffb748b622bb8f5f" translate="yes" xml:space="preserve">
          <source>The problem is that Perl has both compile-time and run-time warnings. To disable compile-time warnings you need to rewrite the code like this:</source>
          <target state="translated">问题是Perl有编译时和运行时的警告。要禁用编译时警告,你需要重写这样的代码。</target>
        </trans-unit>
        <trans-unit id="000d776ae8231195ffb025ac77c4f425f1c2ff6f" translate="yes" xml:space="preserve">
          <source>The problem is that both &lt;code&gt;rp&lt;/code&gt; and &lt;code&gt;dp&lt;/code&gt; are pointers to the same location in memory! In C, you'd have to remember to malloc() yourself some new memory. In Perl, you'll want to use the array constructor &lt;code&gt;[]&lt;/code&gt; or the hash constructor &lt;code&gt;{}&lt;/code&gt; instead. Here's the right way to do the preceding broken code fragments:</source>
          <target state="translated">问题在于 &lt;code&gt;rp&lt;/code&gt; 和 &lt;code&gt;dp&lt;/code&gt; 都是指向内存中相同位置的指针！在C语言中，您必须记住自己给malloc（）一些新的内存。在Perl中，您将要使用数组构造函数 &lt;code&gt;[]&lt;/code&gt; 或哈希构造函数 &lt;code&gt;{}&lt;/code&gt; 。这是执行前面的破碎代码片段的正确方法：</target>
        </trans-unit>
        <trans-unit id="44e0ee462b8e8a33d77de1117d49fdbd0c841da5" translate="yes" xml:space="preserve">
          <source>The problem is that grep builds a return list, regardless of the context. This means you're making Perl go to the trouble of building a list that you then just throw away. If the list is large, you waste both time and space. If your intent is to iterate over the list, then use a for loop for this purpose.</source>
          <target state="translated">问题是 grep 会建立一个返回列表,而不管上下文如何。这意味着你让Perl费尽心思建立一个列表,然后你就把它扔掉。如果列表很大,你会浪费时间和空间。如果你的目的是在列表上进行迭代,那么就使用 for 循环来实现这个目的。</target>
        </trans-unit>
        <trans-unit id="6df859dc8cac16c31baff14e80c7d840e1cb3153" translate="yes" xml:space="preserve">
          <source>The problem is that none of these examples are reliable: they depend on the command interpreter. Under Unix, the first two often work. Under DOS, it's entirely possible that neither works. If 4DOS was the command shell, you'd probably have better luck like this:</source>
          <target state="translated">问题是,这些例子都不可靠:它们取决于命令解释器。在Unix下,前两个经常能用。在DOS下,完全有可能两个都不行。如果4DOS是命令外壳,你可能会有更好的运气,像这样。</target>
        </trans-unit>
        <trans-unit id="95485cb814321ef14b952e45ddf9a35301af1a5e" translate="yes" xml:space="preserve">
          <source>The problem is that none of this is reliable: it depends on the command and it is entirely possible neither works. If</source>
          <target state="translated">问题是这些都不靠谱:它取决于命令,完全有可能两个都不管用。如果</target>
        </trans-unit>
        <trans-unit id="88377fbeaf8b4fab35329a7e374ea24a4795a7c5" translate="yes" xml:space="preserve">
          <source>The problem is that this code will always be parsed and executed, even when the debug level set in the logging configuration file is zero. Once the debug() subroutine has been entered, and the internal &lt;code&gt;$debug&lt;/code&gt; variable confirmed to be zero, for example, the message which has been sent in will be discarded and the program will continue. In the example given though, the &lt;code&gt;\%INC&lt;/code&gt; hash will already have been dumped, and the message string constructed, all of which work could be bypassed by a debug variable at the statement level, like this:</source>
          <target state="translated">问题在于，即使在日志配置文件中设置的调试级别为零时，也始终将解析并执行此代码。例如，一旦输入debug（）子例程，并且内部 &lt;code&gt;$debug&lt;/code&gt; 变量确认为零，已发送的消息将被丢弃，程序将继续。在给出的示例中， &lt;code&gt;\%INC&lt;/code&gt; 哈希将已经被转储，并且构造了消息字符串，所有这些工作都可以由语句级别的调试变量绕过，如下所示：</target>
        </trans-unit>
        <trans-unit id="73cae6ed898e3261e96216aa07490bc469dc51e8" translate="yes" xml:space="preserve">
          <source>The problem is that this code would</source>
          <target state="translated">问题是,这段代码将</target>
        </trans-unit>
        <trans-unit id="e6af2011607132108daf874aceb7c74f8abf4357" translate="yes" xml:space="preserve">
          <source>The problem is that those double-quotes force stringification--coercing numbers and references into strings--even when you don't want them to be strings. Think of it this way: double-quote expansion is used to produce new strings. If you already have a string, why do you need more?</source>
          <target state="translated">问题是,这些双引号强迫字符串化--强迫数字和引用成为字符串--即使你不希望它们成为字符串。可以这样想:双引号扩展是用来产生新的字符串的。如果你已经有了一个字符串,为什么还需要更多?</target>
        </trans-unit>
        <trans-unit id="d0f76e9ccc888898fb7c8d297bdf6217c3b3b765" translate="yes" xml:space="preserve">
          <source>The problem is that various structures visible via procfs use off_t, and if you compile with largefile support these change from 32 bits to 64 bits. Thus what you get back from procfs doesn't match up with the structures in perl, resulting in garbage. See proc(4) for further discussion.</source>
          <target state="translated">问题是通过procfs可见的各种结构都使用off_t,如果编译时支持largefile,这些结构就会从32位变为64位。因此,你从 procfs 得到的东西与 perl 中的结构不匹配,导致垃圾。更多讨论请参见 proc(4)。</target>
        </trans-unit>
        <trans-unit id="36b3f29973dcb4084c4233c180d15ad0f5ad2090" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;'*'&lt;/code&gt;: one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4b1a9098877c5f0dfd053c053f3947a9421580" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; : one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n, etc. In fact there are an exponential number of ways to partition a string as a function of its length. A regexp may get lucky and match early in the process, but if there is no match, Perl will try</source>
          <target state="translated">问题是嵌套的不确定量词。在 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt; 之间划分长度为n的字符串有很多不同的方法：一个重复的 &lt;code&gt;b+&lt;/code&gt; 长度为n，两个重复的第一个 &lt;code&gt;b+&lt;/code&gt; 长度为k，第二个重复的长度为nk，m个重复，其位的总和为n等等。实际上，根据字符串的长度，有成千上万种方式对字符串进行分区。正则表达式可能会很幸运，并且可以在此过程的早期进行匹配，但是如果没有匹配项，Perl会尝试</target>
        </trans-unit>
        <trans-unit id="57ef8306dabb66b8a3dd5849936f56c155cd391f" translate="yes" xml:space="preserve">
          <source>The problem is usually that the command interpreters on those systems have rather different ideas about quoting than the Unix shells under which the one-liners were created. On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">问题通常是这些系统上的命令解释器与创建单引号的Unix shell有相当不同的想法。在某些系统上,你可能不得不将单引号改为双引号,你必须要用</target>
        </trans-unit>
        <trans-unit id="814a82003c2ef63857b1187789261eb0a14ef57b" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;$writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee9f00b1299262770f29ccbf33382cfb01278a2" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;Writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="translated">问题在于缓冲确实会破坏您的一天。即使您的 &lt;code&gt;Writer&lt;/code&gt; 文件句柄已自动刷新，以便另一端的进程及时获取数据，您通常也无法采取任何措施强制该进程以类似的快速方式将其数据提供给您。在这种特殊情况下，我们实际上可以这样做，因为</target>
        </trans-unit>
        <trans-unit id="f6f3b81b70ac61e4574d6ebcd3e976b1d72049f0" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt; . It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="translated">垃圾回收和线程安全的问题都可以通过函数 &lt;code&gt;register()&lt;/code&gt; 来解决。它将对象与任何数量的哈希一起注册。注册表意味着当对象死亡时，将删除该对象的引用地址下任何哈希中的条目。这样可以保证在这些哈希中收集垃圾。这也意味着在线程克隆时，已注册哈希中的对象条目将替换为更新的条目，其键为克隆对象的引用地址。因此，对象数据关联变为线程安全的。</target>
        </trans-unit>
        <trans-unit id="d49a5cf6f714984f5d4aa1ae27ae4adaa45ad30d" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt;. It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aef2d934929be669275ad225ef041e450d29108" translate="yes" xml:space="preserve">
          <source>The procedure for doing this is roughly as follows (using the example of tonyc's smoke-me branch called win32stat):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9452ac7ff4d68965b2304a021a3f491d59cd9f05" translate="yes" xml:space="preserve">
          <source>The process ID in which the event was generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e6fb31b348934a4b1c0d293aa560867eaa2c02" translate="yes" xml:space="preserve">
          <source>The process number of the Perl running this script. Though you</source>
          <target state="translated">运行这个脚本的Perl的进程号。虽然你</target>
        </trans-unit>
        <trans-unit id="b93ffa0ee1718038fedc8009038c2d7f70371455" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">将字符串转换为四个Unicode &lt;b&gt;casemap&lt;/b&gt;之一的&lt;b&gt;过程&lt;/b&gt; ;在Perl中，它是通过 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; 函数实现的。</target>
        </trans-unit>
        <trans-unit id="7b3ce77cc42e100f56e2fb73208b06058b72b962" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;fc&lt;/code&gt;, &lt;code&gt;lc&lt;/code&gt;, &lt;code&gt;ucfirst&lt;/code&gt;, and &lt;code&gt;uc&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf36cd26c284e1c84d9c66a1a4b1fbb69c4ead2" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt; , its only parent is &lt;code&gt;File&lt;/code&gt; . If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">确定应使用哪种方法的过程称为&lt;b&gt;方法解析&lt;/b&gt;。Perl要做的是首先 &lt;code&gt;File::MP3&lt;/code&gt; 对象的类（在这种情况下为File :: MP3）。如果该类定义了方法，则将调用该类的方法版本。如果不是，Perl依次检查每个父类。对于 &lt;code&gt;File::MP3&lt;/code&gt; ，其唯一的父对象是 &lt;code&gt;File&lt;/code&gt; 。如果 &lt;code&gt;File::MP3&lt;/code&gt; 没有定义方法，但是 &lt;code&gt;File&lt;/code&gt; 定义了，则Perl在 &lt;code&gt;File&lt;/code&gt; 中调用该方法。</target>
        </trans-unit>
        <trans-unit id="2d45b13e98be85d3a3cff56a4de1619efcb5c0e5" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt;, its only parent is &lt;code&gt;File&lt;/code&gt;. If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080ae8ae51ff51ae8e5ac989879f84eb0a78985b" translate="yes" xml:space="preserve">
          <source>The process of gluing one cat&amp;rsquo;s nose to another cat&amp;rsquo;s tail. Also a similar operation on two &lt;b&gt;strings&lt;/b&gt;.</source>
          <target state="translated">将一只猫的鼻子粘到另一只猫的尾巴上的过程。对两个&lt;b&gt;字符串&lt;/b&gt;也有类似的操作。</target>
        </trans-unit>
        <trans-unit id="908f91e0beaa0a05d55f4dc47581a39df63d9d61" translate="yes" xml:space="preserve">
          <source>The process of producing a &lt;b&gt;string&lt;/b&gt; representation of an abstract object.</source>
          <target state="translated">产生抽象对象的&lt;b&gt;字符串&lt;/b&gt;表示的过程。</target>
        </trans-unit>
        <trans-unit id="3e1e79f73acf8d324572f017b3dffb010974336f" translate="yes" xml:space="preserve">
          <source>The process of trying one alternative, seeing if it matches, and moving on to the next alternative, while going back in the string from where the previous alternative was tried, if it doesn't, is called</source>
          <target state="translated">尝试一个备选方案,看是否匹配,然后转到下一个备选方案,如果不匹配,则从上一个备选方案所在的字符串返回,这个过程称为</target>
        </trans-unit>
        <trans-unit id="74fa9d2e4258275e6ce9c275f9e0e82d2661aeb2" translate="yes" xml:space="preserve">
          <source>The process of turning source code into a machine-usable form. See &lt;b&gt;compile phase&lt;/b&gt;.</source>
          <target state="translated">将源代码转换为机器可用形式的过程。参见&lt;b&gt;编译阶段&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2c86388b6b25502da94ef398d94ba381de4e7acd" translate="yes" xml:space="preserve">
          <source>The program assumes prior understanding of the internal structure of a Zip file. You should have a copy of the Zip APPNOTE file at hand to help understand the output from this program (&lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5a52491b0f391cb1ad331e975b3decd008b51b" translate="yes" xml:space="preserve">
          <source>The program can be made to run by &quot;laundering&quot; the tainted value through a regular expression: the second example--which still ignores locale information--runs, creating the file named on its command line if it can.</source>
          <target state="translated">通过正则表达式 &quot;洗白 &quot;污点值,可以使程序运行:第二个例子--仍然忽略locale信息--运行,如果可以的话,在其命令行上创建命名的文件。</target>
        </trans-unit>
        <trans-unit id="71e8e6b13bea2c8688fa8edfd4a4d7df9ffed609" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt; , the log is over.</source>
          <target state="translated">该程序崩溃， &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; S，调用 &lt;code&gt;closelog&lt;/code&gt; ，日志就结束了。</target>
        </trans-unit>
        <trans-unit id="acb249bf3e58472d9c05a98a3d9fd3a22a634ed9" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;die&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt;, the log is over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6e033c5ffe643ac5235dd0c4de96e8993b109b" translate="yes" xml:space="preserve">
          <source>The program h2xs is the starting point for creating extensions. In later examples we'll see how we can use h2xs to read header files and generate templates to connect to C routines.</source>
          <target state="translated">程序h2xs是创建扩展的起点。在后面的例子中,我们将看到如何使用h2xs读取头文件并生成模板来连接C例程。</target>
        </trans-unit>
        <trans-unit id="6480e775a128a11d00bdb33611f7cc04c69a6a31" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2--7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt; , whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="translated">该程序分为两部分：第2--7行读取输入并建立数据结构，第8-13行分析数据并打印出报告。我们将有一个哈希 &lt;code&gt;%table&lt;/code&gt; ，其键是国家名称，其值是对城市名称数组的引用。数据结构将如下所示：</target>
        </trans-unit>
        <trans-unit id="467c57531a345de9ffd810bfeb5971919e96c865" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2-7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt;, whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46a6e0b6bbf3d5823709dce22271813109f1ce6" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures.</source>
          <target state="translated">该程序由一组 &lt;code&gt;regnode&lt;/code&gt; 结构表示，其中一个或多个代表程序的单个Regop。结构 &lt;code&gt;regnode&lt;/code&gt; 是所需的最小结构，并具有与所有其他较大结构共享的字段结构。</target>
        </trans-unit>
        <trans-unit id="3ea55b0618cf1b22588d3366ef69169df7ae378e" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures. (Outside this document, the term &quot;regnode&quot; is sometimes used to mean &quot;regop&quot;, which could be confusing.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="135fe1206adbfe007b6735c772853b1eaf66848e" translate="yes" xml:space="preserve">
          <source>The program must take care to ensure that this takes place</source>
          <target state="translated">该计划必须注意确保这种情况的发生。</target>
        </trans-unit>
        <trans-unit id="c1da64105b623d7426e31c12654e36ae7053e949" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="translated">该程序仅花了17多个时钟运行。注意 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 输出的值不同，重要的是始终使用相同的值，并且不要混淆每个值的含义。</target>
        </trans-unit>
        <trans-unit id="453564270c1c0cd5131ab07331c35f9b9398730b" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;time&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8912a00ba87d6cbf5df35a3207c6a72bfeb3c965" translate="yes" xml:space="preserve">
          <source>The program will halt</source>
          <target state="translated">该程序将停止</target>
        </trans-unit>
        <trans-unit id="267c6b23ea1ed3936b0ecbfc44abd9e2d8aa3502" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;md5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="translated">编程界面易于使用：与CPAN的&lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt;模块中的编程界面相同。因此，如果您的应用程序当前使用&lt;a href=&quot;md5&quot;&gt;Digest :: MD5，&lt;/a&gt;并且您希望SHA的安全性更高，则转换它们很简单。</target>
        </trans-unit>
        <trans-unit id="7b1493356cb4a3eba009f1a11b50de871f482665" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;Digest::MD5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0f12348b1996ab0ae0eb3467409b46f3ff517e5" translate="yes" xml:space="preserve">
          <source>The programs and documentation in this dist are distributed in the hope that they will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</source>
          <target state="translated">本远端中的程序和文档是以有用为目的而分发的,但不作任何保证,甚至不对某一特定目的的适销性或适用性作默示保证。</target>
        </trans-unit>
        <trans-unit id="3b63891b0a81b9b51c173bac879417506124032c" translate="yes" xml:space="preserve">
          <source>The prompt of the cpan shell can contain the current command number for easier tracking of the session or be a plain string.</source>
          <target state="translated">cpan shell的提示符可以包含当前的命令号,以便于跟踪会话,也可以是一个普通的字符串。</target>
        </trans-unit>
        <trans-unit id="a9cf8b59c024e83e18267b0f8a6518d4ffcc35fc" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt; ) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="translated">EBCDIC中大写字母之前的小写属性甚至被带到拉丁语1 EBCDIC页面上，例如0037和1047。例如，&amp;ldquo;&amp;Euml;&amp;rdquo;（ &lt;code&gt;E WITH DIAERESIS&lt;/code&gt; ，203）在&amp;ldquo;&amp;euml;&amp;rdquo;之前（ &lt;code&gt;e WITH DIAERESIS&lt;/code&gt; ，235） ）在ASCII平台上，但后者（83）在EBCDIC平台上位于前者（115）之前。（精明的读者会注意到，&amp;ldquo;&amp;szlig;&amp;rdquo; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; 字母SHARP S的大写字母只是&amp;ldquo; SS&amp;rdquo;，而&amp;ldquo;&amp;yuml;&amp;rdquo;（小 &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; 的大写字母）和&amp;ldquo; &amp;micro;&amp;rdquo;（ &lt;code&gt;MICRO SIGN&lt;/code&gt; ）不在大写字母中0..255范围，但使用Unicode（在启用Unicode的Perl中）。</target>
        </trans-unit>
        <trans-unit id="d068c61e1d2738a4b949032692f164ea749e79a4" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt;, 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt;, 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt;) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b7c3443c95713bb7f5c3a34ea900a666d3209c" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</source>
          <target state="translated">协议（例如 &lt;code&gt;IPPROTO_TCP&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1d688930b159b0de8e063999fc12f1fc3e668a59" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c98cd2a0bd15be4f172d1ada9a2ed6c4ba31c3" translate="yes" xml:space="preserve">
          <source>The protocol also defines several standard &lt;b&gt;translations&lt;/b&gt; which the file can undergo during transfer. These are ASCII, EBCDIC, binary, and byte. ASCII is the default type, and indicates that the sender of files will translate the ends of lines to a standard representation which the receiver will then translate back into their local representation. EBCDIC indicates the file being transferred is in EBCDIC format. Binary (also known as image) format sends the data as a contiguous bit stream. Byte format transfers the data as bytes, the values of which remain the same regardless of differences in byte size between the two machines (in theory - in practice you should only use this if you really know what you're doing). This class does not support the EBCDIC or byte formats, and will default to binary instead if they are attempted.</source>
          <target state="translated">该协议还定义了几种标准&lt;b&gt;翻译&lt;/b&gt;文件在传输过程中会受到的影响。这些是ASCII，EBCDIC，二进制和字节。 ASCII是默认类型，它表示文件的发送方会将行尾转换为标准表示，然后接收方会将其转换回其本地表示。 EBCDIC表示正在传输的文件为EBCDIC格式。二进制（也称为图像）格式将数据作为连续的位流发送。字节格式将数据传输为字节，无论两台计算机之间的字节大小如何，其值都将保持不变（理论上-实际上，只有在真正知道自己在做什么的情况下，才应使用此格式）。此类不支持EBCDIC或字节格式，并且如果尝试使用它们，则默认为二进制。</target>
        </trans-unit>
        <trans-unit id="3e54303b3641a865f35ca39d2a398386ca07567a" translate="yes" xml:space="preserve">
          <source>The prototype CV for a 'my' sub.</source>
          <target state="translated">我的 &quot;子的原型简历。</target>
        </trans-unit>
        <trans-unit id="11a1d81ab8f0f4c68c1c261efa58242791ed97cf" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, come after the signature.</source>
          <target state="translated">原型属性和其他任何属性都在签名之后。</target>
        </trans-unit>
        <trans-unit id="571effb91670d02136e12104ead995a6cc16a1c2" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, must come before the signature. The signature always immediately precedes the block of the subroutine's body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420268bbe69f10bd1b6ed7fa6d80a149e32d8a64" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt; .</source>
          <target state="translated">属性中的原型将在从子类中获取的原型之后立即分配给子，这意味着如果同时声明了两者，则传统定义的原型将被忽略。换句话说， &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; 与 &lt;code&gt;sub foo(@){}&lt;/code&gt; 是无法区分的。</target>
        </trans-unit>
        <trans-unit id="a9e026f2d40529605b03137d9a9ed6ef4bb374c7" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6eb998a9749fabedff565e15bacf235434a61b2" translate="yes" xml:space="preserve">
          <source>The provided argument MUST be equal to the string for the validation to pass.</source>
          <target state="translated">提供的参数必须等于要通过验证的字符串。</target>
        </trans-unit>
        <trans-unit id="113c257205a6110f9be3ea8173531d90a26a925b" translate="yes" xml:space="preserve">
          <source>The provided argument MUST equal one of the elements of the array ref for the validation to pass. An array ref can hold all the above values.</source>
          <target state="translated">提供的参数必须等于数组ref中的一个元素,才能通过验证。一个数组 ref 可以容纳上述所有的值。</target>
        </trans-unit>
        <trans-unit id="f0175fe813dc359c6d5d92da9a9b07e142152ec0" translate="yes" xml:space="preserve">
          <source>The provided argument MUST match the regular expression for the validation to pass.</source>
          <target state="translated">提供的参数必须与正则表达式相匹配,才能通过验证。</target>
        </trans-unit>
        <trans-unit id="7028c08ff6edd9122ed07f747d04ab21bb6b6da9" translate="yes" xml:space="preserve">
          <source>The provided subroutine MUST return true in order for the validation to pass and the argument accepted.</source>
          <target state="translated">所提供的子程序必须返回true,以使验证通过并接受参数。</target>
        </trans-unit>
        <trans-unit id="93c41fbabb74d3c7cddc4b5e78899f8faa1b1f17" translate="yes" xml:space="preserve">
          <source>The pseudo-hash feature was an experimental feature introduced in earlier versions of Perl and removed in 5.10.0. A pseudo-hash is an array reference which can be accessed using named keys like a hash. You may run in to some code in the wild which uses it. See the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma for more information.</source>
          <target state="translated">伪哈希功能是在Perl的早期版本中引入的实验性功能，在5.10.0中已删除。伪哈希是一个数组引用，可以使用诸如哈希之类的命名键进行访问。您可能会在野外运行一些使用它的代码。有关更多信息，请参见&lt;a href=&quot;fields&quot;&gt;字段&lt;/a&gt;编译指示。</target>
        </trans-unit>
        <trans-unit id="2c3bf5ebc790603d27cda992131fe6f16a627371" translate="yes" xml:space="preserve">
          <source>The public API must remain consistent, i.e. if a sub-class is overloading addition, the sub-class must use the same name, in this case badd(). The reason for this is that Math::BigInt is optimized to call the object methods directly.</source>
          <target state="translated">公共API必须保持一致,即如果一个子类重载了加法,子类必须使用相同的名称,本例中是badd()。原因是Math::BigInt经过优化,可以直接调用对象方法。</target>
        </trans-unit>
        <trans-unit id="dc2995512c58b9b2e35d09bc546dc5a7fbc84663" translate="yes" xml:space="preserve">
          <source>The purpose of the macro &lt;code&gt;SPAGAIN&lt;/code&gt; is to refresh the local copy of the stack pointer. This is necessary because it is possible that the memory allocated to the Perl stack has been reallocated during the</source>
          <target state="translated">宏 &lt;code&gt;SPAGAIN&lt;/code&gt; 的目的是刷新堆栈指针的本地副本。这是必要的，因为分配给Perl堆栈的内存可能已在重新分配期间重新分配。</target>
        </trans-unit>
        <trans-unit id="211ca4f47d195354704ae118cbe1d64c1c871ea0" translate="yes" xml:space="preserve">
          <source>The purpose of the pragma is to alert users to the status of such a module by issuing a warning that encourages them to install the module from CPAN, so that a future upgrade to a perl which omits the module will not break their code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29cd6102fd964c85b9f311d0c28db3fab69123d" translate="yes" xml:space="preserve">
          <source>The purpose of the testing is twofold: one, to help developers fix any problems in their code that crop up because of lack of testing on other platforms; two, to provide users with information about whether a given module works on a given platform.</source>
          <target state="translated">测试的目的有两个:一是帮助开发者修复代码中因缺乏在其他平台上的测试而产生的问题;二是为用户提供某个模块是否在某个平台上工作的信息。</target>
        </trans-unit>
        <trans-unit id="a5dd5b4e9fced711b08542f3e0ab81c18273f9bd" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to document what has been deprecated in Perl, and by which version the deprecated feature will disappear, or, for already removed features, when it was removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843821edac19011f1a6d1c830e78298f0013f7a5" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to show you how to call Perl subroutines directly from C, i.e., how to write</source>
          <target state="translated">本文档的目的是告诉你如何从C语言中直接调用Perl子程序,即如何编写</target>
        </trans-unit>
        <trans-unit id="414e7fd5b34fea33393baf5db076f7ff8658e79f" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to provide a wide range of testing utilities. Various ways to say &quot;ok&quot; with better diagnostics, facilities to skip tests, test future features and compare complicated data structures. While you can do almost anything with a simple &lt;code&gt;ok()&lt;/code&gt; function, it doesn't provide good diagnostic output.</source>
          <target state="translated">该模块的目的是提供广泛的测试实用程序。具有更好的诊断能力的各种说法都可以，可以跳过测试，测试将来的功能并比较复杂的数据结构。尽管您可以使用简单的 &lt;code&gt;ok()&lt;/code&gt; 函数执行几乎所有操作，但它不能提供良好的诊断输出。</target>
        </trans-unit>
        <trans-unit id="9bfc8ef428f97c3f3e1176a68cf8e1112929bebf" translate="yes" xml:space="preserve">
          <source>The purpose, scope and target applications of your module</source>
          <target state="translated">您的模块的目的、范围和目标应用。</target>
        </trans-unit>
        <trans-unit id="cb81c6a18976d12ebe998a0a0b9af8a1bf213151" translate="yes" xml:space="preserve">
          <source>The pyramids.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc9dd67da090624c445edfafa6830e5bccd4e64" translate="yes" xml:space="preserve">
          <source>The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful, and then document what you wrote so you don&amp;rsquo;t have to answer so many questions about it. Hence, the first great virtue of a programmer. Also hence, this book. See also &lt;b&gt;impatience&lt;/b&gt; and &lt;b&gt;hubris&lt;/b&gt;.</source>
          <target state="translated">使您全力以赴降低总能耗的质量。它使您可以编写其他人会发现有用的省力程序，然后记录您所写的内容，因此您不必回答那么多问题。因此，程序员的第一大美德。因此，这本书也是。另请参见&lt;b&gt;不耐烦&lt;/b&gt;和&lt;b&gt;自大&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="52d7089e85ac35a7092bc58942f32bee7ca90b8d" translate="yes" xml:space="preserve">
          <source>The question of string equivalence turns somewhat complicated in Unicode: what do you mean by &quot;equal&quot;?</source>
          <target state="translated">字符串等价的问题在Unicode中变得有些复杂:什么叫 &quot;等价&quot;?</target>
        </trans-unit>
        <trans-unit id="f2a24b3b2648553142b8c5a0c4598996a73f792a" translate="yes" xml:space="preserve">
          <source>The question remains on when the SVs which are</source>
          <target state="translated">问题仍然是,什么时候才会有特别提款权?</target>
        </trans-unit>
        <trans-unit id="099c0ce39a19f948a86d0ea40fc49e8ea2b14385" translate="yes" xml:space="preserve">
          <source>The question, of course, is why would you do something like this? Why create a semaphore with a starting count that's not one, or why decrement or increment it by more than one? The answer is resource availability. Many resources that you want to manage access for can be safely used by more than one thread at once.</source>
          <target state="translated">当然,问题是,你为什么要做这样的事情?为什么要创建一个起始数不是1的旗语,或者为什么要将其递减或递增超过1?答案是资源可用性。许多你想管理访问的资源可以被多个线程同时安全使用。</target>
        </trans-unit>
        <trans-unit id="7e4709a385e818a7adc04721b36836ff38439abe" translate="yes" xml:space="preserve">
          <source>The quick answer is because they are easy to implement yourself. The long answer is that to write these in such a way that multiple platforms are supported correctly would just require too much code. Below are some examples how you can implement these yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551d1aa8a1248eaf53c1cd9d606d72ab7488cd21" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty method only works well when you don't plan to leave the commented code in the source. If a Pod parser comes along, your multiline comment is going to show up in the Pod translation. A better way hides it from Pod parsers as well.</source>
          <target state="translated">这种快刀斩乱麻的方法只有在你不打算在源码中留下注释的时候才好用,如果有Pod解析器出现,你的多行注释就会显示在Pod翻译中。如果Pod解析器出现,你的多行注释就会出现在Pod翻译中。一个更好的方法是把它也隐藏起来,不让Pod解析器发现。</target>
        </trans-unit>
        <trans-unit id="a41d7294035834639b17968992ffda16ae85e9a1" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt; , ending the Pod section:</source>
          <target state="translated">注释掉多行Perl的一种简单方法是用Pod指令包围这些行。您必须将这些指令放在行的开头，以及Perl期望有新语句的位置（因此，不要放在诸如 &lt;code&gt;#&lt;/code&gt; 注释之类的语句中间）。您以 &lt;code&gt;=cut&lt;/code&gt; 结束注释，从而结束Pod部分：</target>
        </trans-unit>
        <trans-unit id="d90a105b257205ce48226d803e75858a07587fa6" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt;, ending the Pod section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2f3594848e5558e5b1bcd7932b24c116883439" translate="yes" xml:space="preserve">
          <source>The quotient is always the greatest integer less than or equal to the real-valued quotient of the two operands, and the remainder (when it is non-zero) always has the same sign as the second operand; so, for example,</source>
          <target state="translated">商数总是小于或等于两个操作数的实值商的最大整数,余数(当它是非零时)总是与第二个操作数具有相同的符号;所以,例如。</target>
        </trans-unit>
        <trans-unit id="04db20aec07e3c7b83de9b23243f0bb2ef9f279e" translate="yes" xml:space="preserve">
          <source>The random characters are provided by File::Temp and ensure that each module's individual build directory is unique. This makes running CPAN.pm in concurrent processes simultaneously safe.</source>
          <target state="translated">随机字符由File::Temp提供,确保每个模块的单独构建目录是唯一的。这使得在并发进程中同时运行CPAN.pm是安全的。</target>
        </trans-unit>
        <trans-unit id="054e3d7058644b114207f253c83eb2c8a141a8e1" translate="yes" xml:space="preserve">
          <source>The range operator (in list context) makes use of the magical auto-increment algorithm if the operands are strings. You can say</source>
          <target state="translated">如果操作数是字符串,那么范围操作符(在列表上下文中)就会使用神奇的自动递增算法。你可以说</target>
        </trans-unit>
        <trans-unit id="4828534433b64aecd95537d37d705a006ad5851e" translate="yes" xml:space="preserve">
          <source>The range operator &lt;code&gt;..&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">范围运算符 &lt;code&gt;..&lt;/code&gt; 不能重载。</target>
        </trans-unit>
        <trans-unit id="bc508fe7a659eeced29e856ebc7b8d62470c6bbb" translate="yes" xml:space="preserve">
          <source>The range operator also works on strings, using the magical auto-increment, see below.</source>
          <target state="translated">范围运算符也适用于字符串,使用神奇的自动增量,见下文。</target>
        </trans-unit>
        <trans-unit id="31d3e334c25d2382911ee65d3fae61de81e23584" translate="yes" xml:space="preserve">
          <source>The range operator in list context can make use of the magical auto-increment algorithm if both operands are strings, subject to the following rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f8ca3eb25d07981f64e697003d81f247478aa9" translate="yes" xml:space="preserve">
          <source>The range operator is &quot;..&quot;, not comma. The comma operator works as in C.</source>
          <target state="translated">范围运算符是&quot;.&quot;,不是逗号。逗号运算符的工作原理和C语言一样。</target>
        </trans-unit>
        <trans-unit id="6b43593ef7e3f96c529ec6f6490c77d15e8ee949" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt; , rather than comma.</source>
          <target state="translated">范围运算符是 &lt;code&gt;...&lt;/code&gt; ，而不是逗号。</target>
        </trans-unit>
        <trans-unit id="6702b09bbe69f958fa5f9869c6ae81b0c789760d" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt;, rather than comma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41fb6d64bc39d2dbbf811ff985ded944bd6951e6" translate="yes" xml:space="preserve">
          <source>The rationale for inclusion in this module is that the function performs some work for which an XS implementation is essential because it cannot be implemented in Pure Perl, and which is sufficiently-widely used across CPAN that its popularity warrants inclusion in a core module, which this is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272be5d09f375bcf2f8787674ae6b79aa38f8abf" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="translated">要求这样做的理由是不破坏依赖于Unicode出现之前工作方式的较旧程序。这些较旧的程序仅了解ASCII字符集，因此对于其他字符可能无法正常工作。当字符串以UTF-8编码时，Perl假定程序已准备好处理Unicode，但是当字符串不是时，Perl假定只需要ASCII，因此那些不是ASCII字符的字符就不再公认它们在Unicode中将是什么。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 告诉Perl将所有字符都视为Unicode，无论字符串是否使用UTF-8编码，都可以避免此问题。</target>
        </trans-unit>
        <trans-unit id="cd600fcbf1a6b70419da39d25dfcf62c3af89b3f" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062d7f6e6f9ffa42523f91b3b98af5b6e21dddc1" translate="yes" xml:space="preserve">
          <source>The raw floppy disk. Doesn't work under Windows 95. This allows you to read or write raw sectors of the floppy disk and to use &lt;code&gt;DeviceIoControl&lt;/code&gt; to perform miscellaneous queries and operations to the floppy disk or drive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a00a9112198d60e9e6e148f4efbf8b5c8bde2f" translate="yes" xml:space="preserve">
          <source>The raw original L&amp;lt;...&amp;gt; content, before text is split on &quot;|&quot;, &quot;/&quot;, etc, and before E&amp;lt;...&amp;gt; codes are expanded.</source>
          <target state="translated">原始原始L &amp;lt;...&amp;gt;内容，在&amp;ldquo; |&amp;rdquo;，&amp;ldquo; /&amp;rdquo;等上分割文本之前，以及在扩展E &amp;lt;...&amp;gt;代码之前。</target>
        </trans-unit>
        <trans-unit id="16f6921cb27bb9d796f9843804daa8d9f88db314" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;), and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="translated">只读魔术变量 &lt;code&gt;${^UNICODE}&lt;/code&gt; 反映此设置的数值。此变量在Perl启动期间设置，此后为只读。如果需要运行时效果，请使用三个参数的open（）（请参见&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;），两个参数的binmode（）（请参见&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;）和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译指示（请参见&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7133d99787afc8bed88333155f330e0814f3badc" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt;), and the &lt;code&gt;open&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac185b6e70958a0bc2daae47b4a77ca571d1fad" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">这个过程的真正向导。如果您使用的计算机同时支持多个组的成员资格，请使用空格将您所在的组列表分开。第一个数字是 &lt;code&gt;getgid()&lt;/code&gt; 返回的数字，随后的是 &lt;code&gt;getgroups()&lt;/code&gt; 返回的数字，其中一个可能是与第一个数字相同。</target>
        </trans-unit>
        <trans-unit id="1b0d46bf2b89fe3b91282dbaf19dbfd7a631baf9" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt;, and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt;, one of which may be the same as the first number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41410f8fa129356669d6ff84f5e22cd64e4d0cb" translate="yes" xml:space="preserve">
          <source>The real sequence number of the OP, as a regular number and not adjusted to be relative to the start of the real program. (This will generally be a fairly large number because all of &lt;b&gt;B::Concise&lt;/b&gt; is compiled before your program is).</source>
          <target state="translated">OP的实际序号，作为常规编号，并且未调整为相对于实际程序的开始。（这通常是一个相当大的数字，因为所有&lt;b&gt;B :: Concise&lt;/b&gt;都在程序编写之前进行了编译）。</target>
        </trans-unit>
        <trans-unit id="520aa3cfc6d3d06d2079bcf3cd80538cdc94136b" translate="yes" xml:space="preserve">
          <source>The real time timing is done using time(2) and the granularity is therefore only one second.</source>
          <target state="translated">实时计时是用time(2)来完成的,因此颗粒度只有一秒。</target>
        </trans-unit>
        <trans-unit id="000f9aa1d39e9791c956bd280884dcab10bddcf9" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="translated">此过程的真正uid。您可以使用 &lt;code&gt;POSIX::setuid()&lt;/code&gt; 同时更改实际uid和有效uid 。由于对 &lt;code&gt;$&amp;lt;&lt;/code&gt; 更改需要系统调用，因此请检查 &lt;code&gt;$!&lt;/code&gt; 进行更改后尝试检测任何可能的错误。</target>
        </trans-unit>
        <trans-unit id="2ac048e62e66a7879f9411bea5e557339bb43fff" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt;. Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226998a781d1d6550060a07be6fe5dd8d2b4b4b4" translate="yes" xml:space="preserve">
          <source>The real work is done in the standard typemap.</source>
          <target state="translated">真正的工作是在标准类型图中完成的。</target>
        </trans-unit>
        <trans-unit id="c08e193bbc2bcd92c562519697a3487f212bcddb" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt; , but consider this situation:</source>
          <target state="translated">存在 &lt;code&gt;encode_language_tag&lt;/code&gt; 的原因是因为不同的语言标签可能表示相同的语言。通常可以使用 &lt;code&gt;same_language_tag&lt;/code&gt; 进行处理，但请考虑以下情况：</target>
        </trans-unit>
        <trans-unit id="3ce46cd4af70310d3ca26a396ea6fdf7fb3672f3" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt;, but consider this situation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca772eb153fd56cb7e89f09b86319ec24565520e" translate="yes" xml:space="preserve">
          <source>The reason I said &quot;in this instance&quot; is because that</source>
          <target state="translated">我之所以说 &quot;在这种情况下&quot;,是因为这</target>
        </trans-unit>
        <trans-unit id="739ee83789116c83fd6d7b4456cdd5e4f5143663" translate="yes" xml:space="preserve">
          <source>The reason for not checking the return value from print() is because of pipe buffering; physical writes are delayed. That won't blow up until the close, and it will blow up with a SIGPIPE. To catch it, you could use this:</source>
          <target state="translated">不检查print()的返回值是因为管道缓冲,物理写入是有延迟的。那要到关闭的时候才会炸开,而且会炸开一个SIGPIPE。要想抓住它,可以用这个办法。</target>
        </trans-unit>
        <trans-unit id="5243164bf937a2da41254af85f8953f57eda8b63" translate="yes" xml:space="preserve">
          <source>The reason for the bailout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2ad92ed56d2b83c1783a3daf037c2fcef9e124" translate="yes" xml:space="preserve">
          <source>The reason for the exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e74d3011543f0cacc6e865a92179ab3feabba8" translate="yes" xml:space="preserve">
          <source>The reason for the skip, todo etc. See &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e75d2f4213b8c35d2937b292cccac3d8a1e38d" translate="yes" xml:space="preserve">
          <source>The reason for this is that CPAN does not know the dependencies of all modules when it starts out. To decide about the additional items to install, it just uses data found in the META.yml file or the generated Makefile. An undetected missing piece breaks the process. But it may well be that your Bundle installs some prerequisite later than some depending item and thus your second try is able to resolve everything. Please note, CPAN.pm does not know the dependency tree in advance and cannot sort the queue of things to install in a topologically correct order. It resolves perfectly well &lt;b&gt;if&lt;/b&gt; all modules declare the prerequisites correctly with the PREREQ_PM attribute to MakeMaker or the &lt;code&gt;requires&lt;/code&gt; stanza of Module::Build. For bundles which fail and you need to install often, it is recommended to sort the Bundle definition file manually.</source>
          <target state="translated">原因是CPAN在启动时并不知道所有模块的依赖性。要决定要安装的其他项目，它仅使用在META.yml文件或生成的Makefile中找到的数据。未检测到的丢失片段会中断该过程。但是，很可能是您的捆绑软件在安装某些先决条件之后，再安装某些依赖项，因此您的第二次尝试就能解决所有问题。请注意，CPAN.pm事先不知道依赖关系树，因此无法按拓扑正确的顺序对要安装的事物队列进行排序。它解决得很好&lt;b&gt;，如果&lt;/b&gt;所有模块与PREREQ_PM属性MakeMaker的或正确申报的先决条件的 &lt;code&gt;requires&lt;/code&gt; Module :: Build的节。对于失败的捆绑软件，您需要经常安装，建议手动对捆绑软件定义文件进行排序。</target>
        </trans-unit>
        <trans-unit id="9dfe6b3d7e7af99fa8c5c069ac28ca23f9e16764" translate="yes" xml:space="preserve">
          <source>The reason for this is that the &lt;a href=&quot;version#numify%28%29&quot;&gt;numify()&lt;/a&gt; operator will turn &quot;v1.0&quot; into the equivalent string &quot;1.000000&quot;. Forcing the outer version object to &lt;a href=&quot;version#normal%28%29&quot;&gt;normal()&lt;/a&gt; form will display the mathematically equivalent &quot;v1.0.0&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa379384b7d494ede930080ac4d01947c2521a8" translate="yes" xml:space="preserve">
          <source>The reason for this unusability is that a fundamental assumption of Perl is that the characters it cares about for parsing and lexical analysis are the same whether or not the text is in UTF-8. For example, Perl expects the character &lt;code&gt;&quot;[&quot;&lt;/code&gt; to have the same representation, no matter if the string containing it (or program text) is UTF-8 encoded or not. To ensure this, Perl adapts UTF-EBCDIC to the particular code page so that all characters it expects to be UTF-8 invariant are in fact UTF-8 invariant. This means that text generated on a computer running one version of Perl's UTF-EBCDIC has to be translated to be intelligible to a computer running another.</source>
          <target state="translated">之所以无法使用，是因为Perl的基本假设是，无论文本是否使用UTF-8，它关心的用于分析和词法分析的字符都是相同的。例如，Perl期望字符 &lt;code&gt;&quot;[&quot;&lt;/code&gt; 具有相同的表示形式，无论包含它的字符串（或程序文本）是否经过UTF-8编码。为了确保这一点，Perl使UTF-EBCDIC适应特定的代码页，以便它期望为UTF-8不变的所有字符实际上都是UTF-8不变的。这意味着在运行一种版本的Perl UTF-EBCDIC的计算机上生成的文本必须经过翻译才能理解为运行另一种版本的计算机。</target>
        </trans-unit>
        <trans-unit id="148e8f8b4033e043ed0349ade3e3972ed042dff2" translate="yes" xml:space="preserve">
          <source>The reason is that Encode::Guess guesses encoding by trial and error. It first splits $data into lines and tries to decode the line for each suspect. It keeps it going until all but one encoding is eliminated out of suspects list. ISO-8859 series is just too successful for most cases (because it fills almost all code points in \x00-\xff).</source>
          <target state="translated">原因是 Encode::Guess 通过试错来猜测编码。它首先将$data分割成一行行,并尝试为每个嫌疑人解码。它一直持续下去,直到除了一个编码之外,所有的编码都被排除在嫌疑人列表之外。ISO-8859系列在大多数情况下都太成功了(因为它几乎填满了所有的编码点\x00-\xff)。</target>
        </trans-unit>
        <trans-unit id="94742df1b378e1ee0c32933e905c9b3866f15f37" translate="yes" xml:space="preserve">
          <source>The reason is that variable interpolation and code expressions together pose a security risk. The combination is dangerous because many programmers who write search engines often take user input and plug it directly into a regexp:</source>
          <target state="translated">原因是变量插值和代码表达式一起构成了安全风险。这种组合是很危险的,因为很多编写搜索引擎的程序员经常把用户的输入直接插入到regexp中。</target>
        </trans-unit>
        <trans-unit id="c8fa70ef72504bbb3f7d6986506b4705b0ceb70a" translate="yes" xml:space="preserve">
          <source>The reason is that vendor encoding is usually a superset of national standard so it becomes too ambiguous for most cases.</source>
          <target state="translated">原因是厂商的编码通常是国家标准的超集,所以对于大多数情况下,它变得过于模糊。</target>
        </trans-unit>
        <trans-unit id="76e332a13c138bbbc50c17d9967b9928970c16a2" translate="yes" xml:space="preserve">
          <source>The reason it isn't quite a drop-in replacement is actually an advantage. The only difference is that it returns &lt;code&gt;const char *&lt;/code&gt;, whereas plain &lt;code&gt;nl_langinfo()&lt;/code&gt; returns &lt;code&gt;char *&lt;/code&gt;, but you are (only by documentation) forbidden to write into the buffer. By declaring this &lt;code&gt;const&lt;/code&gt;, the compiler enforces this restriction, so if it is violated, you know at compilation time, rather than getting segfaults at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0f1d70e28ee48bb2440f0dfad9e2b39b29922f" translate="yes" xml:space="preserve">
          <source>The reason that &lt;code&gt;host $failed_ack_host&lt;/code&gt; did not receive a valid ACK. Useful to find out why when &lt;code&gt;ack($fail_ack_host)&lt;/code&gt; returns a false value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fedf7056008fbc98297422a200d9b784c0b8db45" translate="yes" xml:space="preserve">
          <source>The reason that doesn't do what you want is because assigning a named array like that to a scalar is taking an array in scalar context, which means just counts the number of elements in @tmp.</source>
          <target state="translated">之所以不能如你所愿,是因为把这样一个命名的数组赋给一个标量,就是在标量上下文中取一个数组,也就是只计算@tmp中的元素数。</target>
        </trans-unit>
        <trans-unit id="550ff1bc08b0298c35cdd00d235a478cadb820d7" translate="yes" xml:space="preserve">
          <source>The reason that host $failed_ack_host did not receive a valid ACK. Useful to find out why when ack( $fail_ack_host ) returns a false value.</source>
          <target state="translated">主机$failed_ack_host没有收到有效ACK的原因。当ack($fail_ack_host )返回一个false值时,可以用来找出原因。</target>
        </trans-unit>
        <trans-unit id="761e66631890fba3f96026c5ab632825150c6b23" translate="yes" xml:space="preserve">
          <source>The reason that using gettext runs into walls (as in the above second-person horror story) is that you're trying to use a string (or worse, a choice among a bunch of strings) to do what you really need a function for -- which is futile. Preforming (s)printf interpolation on the strings which you get back from gettext does allow you to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="251bb3c15e15e0ec21516300833b60efe1125c75" translate="yes" xml:space="preserve">
          <source>The reason this function has &quot;_strictly&quot; in its name is that when you're processing an Accept-Language list according to the RFCs, if you interpret the RFCs quite strictly, then you would use implicate_supers_strictly, but for normal use (i.e., common-sense use, as far as I'm concerned) you'd use implicate_supers.</source>
          <target state="translated">这个函数名称中带有&quot;_strictly &quot;的原因是,当你根据RFCs处理Accept-Language列表时,如果你对RFCs的解释相当严格,那么你会使用 implicate_supers_strictly,但对于正常使用(即常识性使用,就我而言),你会使用 implicate_supers。</target>
        </trans-unit>
        <trans-unit id="00e0d83a9d5edf83f32ea0d0701c8b2f4b38f236" translate="yes" xml:space="preserve">
          <source>The reason this is considered to be only partially implemented is that Perl has &lt;a href=&quot;perlrebackslash#%5Cb%7Blb%7D&quot;&gt;&lt;code&gt;qr/\b{lb}/&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt;&lt;/code&gt; that are conformant with &lt;a href=&quot;https://www.unicode.org/reports/tr14&quot;&gt;UAX#14 &quot;Unicode Line Breaking Algorithm&quot;&lt;/a&gt;. The regular expression construct provides default behavior, while the heavier-weight module provides customizable line breaking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1005d9c83a9fa9fcbc88e4d2084838b8de52293" translate="yes" xml:space="preserve">
          <source>The reason this is necessary is that the area of the Perl stack which held them will very likely have been overwritten by something else by the time control returns from</source>
          <target state="translated">之所以需要这样做,是因为当控制从</target>
        </trans-unit>
        <trans-unit id="7f8610d66bd9a8ef9ccb75cedd8c737641eb770d" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because RFC 1951 content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">之所以不是默认行为,是因为RFC 1951内容只能通过尝试解压来检测。这个过程很容易出错,可能会导致误报。</target>
        </trans-unit>
        <trans-unit id="19bd78bd51bc1c56b13d7881beac1baa5b73fb31" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because lzma_alone content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">这不是默认行为的原因是lzma_alone内容只能通过尝试解压来检测。这个过程很容易出错,可能会导致误报。</target>
        </trans-unit>
        <trans-unit id="28f02f8a8e5a76ee5006992d613d3802d772737a" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt; , it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt; . This is particularly true for these cases:</source>
          <target state="translated">究其原因，这是不对的是，由你来使用指针的时候 &lt;code&gt;rememberSub&lt;/code&gt; 在 &lt;code&gt;CallSavedSub1&lt;/code&gt; ，它可能会或可能不会仍然指的是被记录在Perl子 &lt;code&gt;SaveSub1&lt;/code&gt; 。在以下情况下尤其如此：</target>
        </trans-unit>
        <trans-unit id="e2bf2d952027d4fe995c4250ed0910c8a499fa98" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt;, it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt;. This is particularly true for these cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc61e22be627df80a7651746e52decec2ded90a" translate="yes" xml:space="preserve">
          <source>The reasons for most important skipped tests are:</source>
          <target state="translated">大多数重要的跳过测试的原因是:</target>
        </trans-unit>
        <trans-unit id="cc1622b786a9a5b8c43f01f8734a1a12e356f528" translate="yes" xml:space="preserve">
          <source>The recognized bright background color attributes (colors 8 to 15) are:</source>
          <target state="translated">公认的亮色背景色属性(颜色8至15)为:。</target>
        </trans-unit>
        <trans-unit id="6c5d4a5f4c9a09fda354809420b2cbe2f30c42f0" translate="yes" xml:space="preserve">
          <source>The recognized normal background color attributes (colors 0 to 7) are:</source>
          <target state="translated">认可的正常背景色属性(颜色0至7)为:。</target>
        </trans-unit>
        <trans-unit id="4a93814d53d2a583e73a218be86053c6699847f6" translate="yes" xml:space="preserve">
          <source>The recognized normal foreground color attributes (colors 0 to 7) are:</source>
          <target state="translated">识别的普通前景色属性(颜色0至7)为:。</target>
        </trans-unit>
        <trans-unit id="c8d8fb33b8f8ad299c896b38af940448a2194ca3" translate="yes" xml:space="preserve">
          <source>The recognized options to new() are as follows. All options take a single argument.</source>
          <target state="translated">new()的公认选项如下。所有选项都只取一个参数。</target>
        </trans-unit>
        <trans-unit id="1e562f76f9cdb0ef2aab453d2c38556cc6a6334d" translate="yes" xml:space="preserve">
          <source>The recommended compiler to use in Tru64 is the native C compiler. The native compiler produces much faster code (the speed difference is noticeable: several dozen percentages) and also more correct code: if you are considering using the GNU C compiler you should use at the very least the release of 2.95.3 since all older gcc releases are known to produce broken code when compiling Perl. One manifestation of this brokenness is the lib/sdbm test dumping core; another is many of the op/regexp and op/pat, or ext/Storable tests dumping core (the exact pattern of failures depending on the GCC release and optimization flags).</source>
          <target state="translated">建议在Tru64中使用的编译器是本地C编译器。原生编译器产生的代码要快得多(速度上的差异很明显:几十个百分点),而且代码也更正确:如果您考虑使用 GNU C 编译器,您至少应该使用 2.95.3 版本,因为所有旧的 gcc 版本在编译 Perl 时都会产生破损的代码。这种破绽的一个表现是lib/sdbm测试转储核心;另一个表现是许多op/regexp和op/pat,或者ext/Storable测试转储核心(具体的失败模式取决于gcc版本和优化标志)。</target>
        </trans-unit>
        <trans-unit id="a954751580ed0f6e74f6ae52a458e3decc2b6782" translate="yes" xml:space="preserve">
          <source>The recommended order of sections in Perl module documentation is:</source>
          <target state="translated">在Perl模块文档中,推荐的章节顺序是。</target>
        </trans-unit>
        <trans-unit id="da2bd70489cefb603292ce8b5cfe4c6cae04aaf7" translate="yes" xml:space="preserve">
          <source>The recommended way to build Perl for the OS/400 PASE is to build the Perl 5 source code (release 5.8.1 or later) under AIX.</source>
          <target state="translated">为OS/400 PASE构建Perl的推荐方法是在AIX下构建Perl 5源代码(5.8.1或更高版本)。</target>
        </trans-unit>
        <trans-unit id="e06b04ad5d41fce493c0b00ecf1ca37dfa5afcff" translate="yes" xml:space="preserve">
          <source>The red() and green() functions would be similar. To create these, we'll assign a closure to a typeglob of the name of the function we're trying to build.</source>
          <target state="translated">red()和green()函数也类似。为了创建这两个函数,我们将为我们试图构建的函数名称的类型球分配一个闭包。</target>
        </trans-unit>
        <trans-unit id="f9a173256f222e6807faedf390f953793a1d344d" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; will be decremented at the end of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d461f380b420e2f92a59ecbfaa16c7256f214ff" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; would be decremented at the end of</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 的引用计数将在末尾减少</target>
        </trans-unit>
        <trans-unit id="aa0554de1d883a744516c47aa9649afa91c2844b" translate="yes" xml:space="preserve">
          <source>The reference count for each specified &lt;code&gt;SV*&lt;/code&gt; parameter is decremented.</source>
          <target state="translated">每个指定的 &lt;code&gt;SV*&lt;/code&gt; 参数的参考计数都会减少。</target>
        </trans-unit>
        <trans-unit id="2beb795bee8f23385c682524158dfa3883714ef0" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name list.</source>
          <target state="translated">垫名列表的引用次数。</target>
        </trans-unit>
        <trans-unit id="ed87a4c5aaea6eeced4317ed59578fe0847b6b0f" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name.</source>
          <target state="translated">垫名的引用次数。</target>
        </trans-unit>
        <trans-unit id="0f3b4f395e70b832ec180500f62bfe30abfdf04c" translate="yes" xml:space="preserve">
          <source>The reference count of the padlist. Currently this is always 1.</source>
          <target state="translated">垫表的引用次数。目前总是1。</target>
        </trans-unit>
        <trans-unit id="b9e9c4a001467c1b7e5e43bb821f471e292d9d31" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;$foo&lt;/code&gt; 到 &lt;code&gt;$bar&lt;/code&gt; 的引用已被削弱。当 &lt;code&gt;$bar&lt;/code&gt; 变量超出范围时，将被垃圾回收。下次查看 &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; 键的值时，它将为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1de879124c2751ad3ecd4b63c57cecfe27d3f64" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc857a94806f2c57cbbf2e2dd2d2b88b08c2fe6" translate="yes" xml:space="preserve">
          <source>The reference is truly dumped and we can finally see what we're dealing with. Our quoting was perfectly valid but wrong for our purposes, with 'and jerry' being treated as 2 separate words rather than a phrase, thus throwing the evenly paired hash structure out of alignment.</source>
          <target state="translated">引用真正被甩掉了,我们终于可以看到我们在处理什么了。我们的引用是完全有效的,但对于我们的目的来说是错误的,'和jerry'被当作2个独立的单词而不是一个短语,从而使偶数配对的哈希结构失准。</target>
        </trans-unit>
        <trans-unit id="4adfd6b1f7abb309b66c9315a05ff37197f3a0fe" translate="yes" xml:space="preserve">
          <source>The references you get from rule 2 are the same kind of references that you get from rule 1:</source>
          <target state="translated">你从规则2中得到的参考资料和从规则1中得到的参考资料是一样的。</target>
        </trans-unit>
        <trans-unit id="4f2739050aee8d49851e25b790d128e1ca19fbde" translate="yes" xml:space="preserve">
          <source>The regex_sets feature is experimental</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c14a48971a0368f8bbf545f9e2905f7ac019ed5" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168bedf74d17b291ff7d2c437f9134d9006e0ffe" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations, etc., and uses &lt;code&gt;\g1&lt;/code&gt; to look for a repeat. Although &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;\g1&lt;/code&gt; represent the same thing, care should be taken to use matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... only</source>
          <target state="translated">regexp具有单个分组，该分组考虑4个字母的组合，然后考虑3个字母的组合等，并使用 &lt;code&gt;\g1&lt;/code&gt; 查找重复。尽管 &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;\g1&lt;/code&gt; 代表同一件事，但应注意仅使用匹配的变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ，...。</target>
        </trans-unit>
        <trans-unit id="d1eb9cbcdcc85f0afd97e3812b595b9e1f6b3fd8" translate="yes" xml:space="preserve">
          <source>The regexp matches an open parenthesis, one or more copies of an alternation, and a close parenthesis. The alternation is two-way, with the first alternative &lt;code&gt;[^()]+&lt;/code&gt; matching a substring with no parentheses and the second alternative &lt;code&gt;\([^()]*\)&lt;/code&gt; matching a substring delimited by parentheses. The problem with this regexp is that it is pathological: it has nested indeterminate quantifiers of the form &lt;code&gt;(a+|b)+&lt;/code&gt;. We discussed in Part 1 how nested quantifiers like this could take an exponentially long time to execute if there was no match possible. To prevent the exponential blowup, we need to prevent useless backtracking at some point. This can be done by enclosing the inner quantifier as an independent subexpression:</source>
          <target state="translated">正则表达式匹配一个开放的括号，一个或多个交替的副本以及一个封闭的括号。交替是双向的，第一种选择 &lt;code&gt;[^()]+&lt;/code&gt; 匹配没有括号的子字符串，第二种选择 &lt;code&gt;\([^()]*\)&lt;/code&gt; 匹配用括号定界的子字符串。此正则表达式的问题在于它是病理性的：它嵌套了 &lt;code&gt;(a+|b)+&lt;/code&gt; 形式的不确定量词。在第1部分中，我们讨论了如果没有匹配的可能，那么像这样的嵌套量词如何需要花费指数级的时间才能执行。为防止指数爆炸，我们需要在某些时候防止无用的回溯。这可以通过将内部量词括起来作为独立的子表达式来完成：</target>
        </trans-unit>
        <trans-unit id="368bf455728e0cc079751b44e9fea4161849b273" translate="yes" xml:space="preserve">
          <source>The regexp structure contains all the data that perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts such as is the pattern anchored in some way, or what flags were used during the compile, or whether the program contains special constructs that perl needs to be aware of.</source>
          <target state="translated">regexp结构包含了所有perl需要知道的数据,以便正确使用正则表达式。它包含了关于优化的数据,perl可以使用这些数据来确定是否真的应该使用regex引擎,以及在各种情况下正确执行模式所需要的各种其他控制信息,例如模式是否以某种方式被锚定,或者在编译过程中使用了什么标志,或者程序是否包含perl需要注意的特殊结构。</target>
        </trans-unit>
        <trans-unit id="c3c54f92228f6f05bcc0bda8517b5a88720264e3" translate="yes" xml:space="preserve">
          <source>The regexp without the &lt;code&gt;//x&lt;/code&gt; modifier is</source>
          <target state="translated">没有 &lt;code&gt;//x&lt;/code&gt; 修饰符的正则表达式是</target>
        </trans-unit>
        <trans-unit id="cd0504e6dcc01ce1582fd08d19ab6d72b18efd43" translate="yes" xml:space="preserve">
          <source>The regops are defined in</source>
          <target state="translated">regops定义在</target>
        </trans-unit>
        <trans-unit id="398b15f4cf9df5e68a324633c771b534053133cc" translate="yes" xml:space="preserve">
          <source>The regression tests for each operator live in</source>
          <target state="translated">每个运营商的回归测试活在</target>
        </trans-unit>
        <trans-unit id="1185c36b91985e4291f68ed8a08b57d301b0c6f7" translate="yes" xml:space="preserve">
          <source>The regular expression engine can be a weighty tool to wield. On long strings and complex patterns it can end up having to do a lot of work to find a match, and even more to decide that no match is possible. Consider a situation like the following pattern.</source>
          <target state="translated">正则表达式引擎可能是一个重量级的工具。对于长字符串和复杂的模式,它可能最终不得不做很多工作来寻找匹配,甚至更多的工作是决定不可能匹配。考虑一下像下面这种模式的情况。</target>
        </trans-unit>
        <trans-unit id="550e74d9d02bffd01cf3b652c4e172b2d8cb3f39" translate="yes" xml:space="preserve">
          <source>The regular expression to execute.</source>
          <target state="translated">要执行的正则表达式。</target>
        </trans-unit>
        <trans-unit id="8c3b3408d3eb9771532acb10a043be225a8f7a49" translate="yes" xml:space="preserve">
          <source>The regular expression to match the balanced text uses two new (to Perl 5.10) regular expression features. These are covered in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and this example is a modified version of one in that documentation.</source>
          <target state="translated">匹配平衡文本的正则表达式使用两个新的（对Perl 5.10而言）正则表达式功能。这些内容在&lt;a href=&quot;perlre&quot;&gt;perlre中进行了介绍&lt;/a&gt;，本示例是该文档中的内容的修改版本。</target>
        </trans-unit>
        <trans-unit id="7b89c7165c60ab0797d1970f7d1380e29eaa0008" translate="yes" xml:space="preserve">
          <source>The related &lt;code&gt;base&lt;/code&gt; pragma will combine fields from base classes and any fields declared using the &lt;code&gt;fields&lt;/code&gt; pragma. This enables field inheritance to work properly. Inherited fields can be overridden but will generate a warning if warnings are enabled.</source>
          <target state="translated">相关的 &lt;code&gt;base&lt;/code&gt; 杂注将结合基类中的字段和使用 &lt;code&gt;fields&lt;/code&gt; 杂注声明的任何字段。这使字段继承能够正常工作。继承的字段可以被覆盖，但是如果启用了警告，则会生成警告。</target>
        </trans-unit>
        <trans-unit id="31c9eb432cfde9dbb8b6575337f7f66a6d53cbda" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Perl_pp_regcomp&lt;/code&gt; 中的相关代码段：</target>
        </trans-unit>
        <trans-unit id="86d45b748524cf3c3ed19b4942d99f6682b785f8" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99cbb925914614f38c9cb5913b1dca990337342e" translate="yes" xml:space="preserve">
          <source>The remainder of the input string (i.e. the characters after the extracted string). On failure, the entire string is returned.</source>
          <target state="translated">输入字符串的剩余部分(即提取字符串后的字符)。如果失败,将返回整个字符串。</target>
        </trans-unit>
        <trans-unit id="efbd63ef88d15920cb0b989c9bf11dcb1d2eacf4" translate="yes" xml:space="preserve">
          <source>The remaining arguments list the files to be included in the tar file. These files must all exist. Any files which don't exist or can't be read are silently ignored.</source>
          <target state="translated">其余参数列出了要包含在 tar 文件中的文件,这些文件必须全部存在。这些文件必须全部存在。任何不存在或无法读取的文件都会被忽略。</target>
        </trans-unit>
        <trans-unit id="f73744579f886d96e9ed158f08b1414dc3c821e4" translate="yes" xml:space="preserve">
          <source>The remaining fields specify the starting and ending cylinder and head of the range of tracks to be formatted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1833f6078478dddd497b7e7b088899346fc9339d" translate="yes" xml:space="preserve">
          <source>The remaining list-reduction functions are all specialisations of this generic idea.</source>
          <target state="translated">其余的列表还原函数都是这个通用思想的特殊化。</target>
        </trans-unit>
        <trans-unit id="5790bf8249cfb740e1105f12c204270f7d624a65" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt; . If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="translated">其余语言环境类别当前未由Perl本身使用。但要再次注意，Perl与之交互的事物可能会使用它们，包括标准Perl发行版之外的扩展以及操作系统及其实用程序。请特别注意 &lt;code&gt;$!&lt;/code&gt; 的字符串值！ &lt;code&gt;LC_MESSAGES&lt;/code&gt; 可能会更改外部实用程序给出的错误消息。如果要使用可移植的错误代码，请使用 &lt;code&gt;%!&lt;/code&gt; 。参见&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c93d95569d58cc954c309a9c37710dcae16b378b" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt;. If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt;. See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f593d82b22de04a34fb6b00553893736966b088" translate="yes" xml:space="preserve">
          <source>The remaining three arguments to &lt;code&gt;autosplit&lt;/code&gt; govern other options to the autosplitter.</source>
          <target state="translated">自动 &lt;code&gt;autosplit&lt;/code&gt; 的其余三个参数控制着自动拆分器的其他选项。</target>
        </trans-unit>
        <trans-unit id="359f225886acbac14791dc5bc2f8daf71a950d7f" translate="yes" xml:space="preserve">
          <source>The remaining transformations (e.g. hex -&amp;gt; oct, bin -&amp;gt; hex, etc.) are left as an exercise to the inclined reader.</source>
          <target state="translated">其余的转换（例如，十六进制-&amp;gt; oct，bin-&amp;gt;十六进制等）作为练习留给倾斜的读者。</target>
        </trans-unit>
        <trans-unit id="24d565f51a3155e5d1586b0499680351e5378dc6" translate="yes" xml:space="preserve">
          <source>The repeat count for &lt;code&gt;u&lt;/code&gt; is interpreted as the maximal number of bytes to encode per line of output, with 0, 1 and 2 replaced by 45. The repeat count should not be more than 65.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 的重复计数被解释为每行输出要编码的最大字节数，其中0、1和2替换为45。重复计数不应超过65。</target>
        </trans-unit>
        <trans-unit id="f593cdc0477b84a5d137272da930d89fe6995081" translate="yes" xml:space="preserve">
          <source>The repertoire of characters that Perl can represent is a superset of those defined by the Unicode Consortium. On most platforms the ordinal values of a character as returned by &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; is the</source>
          <target state="translated">Perl可以代表的字符表是Unicode联盟定义的那些字符的超集。在大多数平台如通过返回一个字符的顺序值 &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="b4becab04b9eae1dfa2922434e872f92f0ca7ffd" translate="yes" xml:space="preserve">
          <source>The replacement UNIVERSAL::VERSION, when used as a function, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b90d7584bfb12af61e5f1ab0554e525a346ffd6" translate="yes" xml:space="preserve">
          <source>The report generated is in the following format:</source>
          <target state="translated">生成的报告格式如下:</target>
        </trans-unit>
        <trans-unit id="c18cb003bcf6566604f8240405fff42c4ea43f6c" translate="yes" xml:space="preserve">
          <source>The report is then grouped by the &lt;b&gt;Package&lt;/b&gt; of each variable, subroutine or format with the special case &quot;(lexicals)&quot; meaning lexical variables. Each &lt;b&gt;object&lt;/b&gt; name (implicitly qualified by its containing &lt;b&gt;Package&lt;/b&gt;) includes its type character(s) at the beginning where possible. Lexical variables are easier to track and even included dereferencing information where possible.</source>
          <target state="translated">然后，将报告按每个变量，子例程或格式的&lt;b&gt;包&lt;/b&gt;进行分组，并以特殊情况&amp;ldquo;（词法）&amp;rdquo;表示词法变量。每个&lt;b&gt;对象&lt;/b&gt;名称（由其包含的&lt;b&gt;Package&lt;/b&gt;隐式限定）在可能的开头都包括其类型字符。词法变量更容易跟踪，甚至在可能的情况下甚至包括取消引用信息。</target>
        </trans-unit>
        <trans-unit id="a2f4b71d3df1e22731185a4eb5f4e73af9bf14da" translate="yes" xml:space="preserve">
          <source>The report with</source>
          <target state="translated">该报告附有</target>
        </trans-unit>
        <trans-unit id="32baff471ed8eb8f5ceead8f0fa06a41ab81b875" translate="yes" xml:space="preserve">
          <source>The request was judged to be small, so the possibility to trap it depends on the way perl was compiled. By default it is not trappable. However, if compiled for this, Perl may use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency pool after die()ing with this message. In this case the error is trappable</source>
          <target state="translated">该请求被判断为很小，因此捕获该请求的可能性取决于perl的编译方式。默认情况下，它是不可捕获的。但是，如果为此编译，Perl可能会在die（）处理此消息后将 &lt;code&gt;$^M&lt;/code&gt; 的内容用作紧急池。在这种情况下，错误是可捕获的</target>
        </trans-unit>
        <trans-unit id="e06f7be9330cffa7a55aee96bfbe8c1e1072f6a9" translate="yes" xml:space="preserve">
          <source>The requests do not necessarily go always all the way down to the operating system: that's where PerlIO buffering comes into play.</source>
          <target state="translated">请求不一定总是一路传到操作系统:这就是PerlIO缓冲的作用。</target>
        </trans-unit>
        <trans-unit id="c2923a29c348a827f2ff3da1221b43b0a603bfa9" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d362ada26ee954875bdcbdb4ef3110ff77e350ef" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the &quot;</source>
          <target state="translated">实际上,require函数将寻找&quot;</target>
        </trans-unit>
        <trans-unit id="437fdd0ce3dd49b0cb6d8dbfa1617238f6bfc689" translate="yes" xml:space="preserve">
          <source>The require function will look for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7925470de731575e163d706573142112baceaaab" translate="yes" xml:space="preserve">
          <source>The require function will look for the &quot;</source>
          <target state="translated">require函数将寻找&quot;</target>
        </trans-unit>
        <trans-unit id="a4dd4536ee0a716833e52164851f465f831c0d1d" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt; ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 期间所需的参数是哈希，程序包以及对 &lt;code&gt;FETCH&lt;/code&gt; ing函数的引用。可选参数是任意标量$ data，对 &lt;code&gt;EXISTS&lt;/code&gt; 函数的引用以及哈希和存在缓存的初始值。</target>
        </trans-unit>
        <trans-unit id="72b681659bb57f7021407ce5fd3ac4d104c48565" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;tie&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt;ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37cc4a6beddbd481d62d1aa4fb0c7078c9745a11" translate="yes" xml:space="preserve">
          <source>The requires and build_requires dependency declarations</source>
          <target state="translated">requires和build_requires的依赖性声明。</target>
        </trans-unit>
        <trans-unit id="68eca29cf3cefa1ee83b5c875c176fa92ac4b217" translate="yes" xml:space="preserve">
          <source>The rest is duplicate code from MM_Unix. Should move the linker code to its own method.</source>
          <target state="translated">其余的都是MM_Unix的重复代码。应该把链接器的代码移到自己的方法中。</target>
        </trans-unit>
        <trans-unit id="5f0ee77d23f152cd1591836db1cbf485219544f6" translate="yes" xml:space="preserve">
          <source>The rest is for internal usage of this package. In particular, if TIEHASH is overwritten, it should call SUPER::TIEHASH.</source>
          <target state="translated">其余的是本包的内部使用。特别是,如果TIEHASH被覆盖,应该调用SUPER::TIEHASH。</target>
        </trans-unit>
        <trans-unit id="fe2906e8b2561874cbab3bd035dddc47777e922a" translate="yes" xml:space="preserve">
          <source>The rest of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6a19c74f24c99c3610c0c4323af3d860d85c2f" translate="yes" xml:space="preserve">
          <source>The rest of the .pm file contains sample code for providing documentation for the extension.</source>
          <target state="translated">.pm文件的其余部分包含为扩展名提供文档的示例代码。</target>
        </trans-unit>
        <trans-unit id="7c74ae28959473b4a69a8f31fe847650cadce3cf" translate="yes" xml:space="preserve">
          <source>The rest of the META.yml file is one big YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt;, whose keys are described here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0a96f4412d084abe1abbbb705cc005b4d7612f" translate="yes" xml:space="preserve">
          <source>The rest of the function description may be indented or left-adjusted. The following example shows a function with its body left-adjusted. Most examples in this document will indent the body for better readability.</source>
          <target state="translated">函数描述的其余部分可以缩进或左调整。下面的例子显示了一个函数,它的正文是向左调整的。本文档中的大多数例子都会对正文进行缩进以提高可读性。</target>
        </trans-unit>
        <trans-unit id="4748c8c8a6af67adc5b974371e823f12ce953a5d" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please email comments to &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;.</source>
          <target state="translated">本节的其余部分可能需要更新，但是我们不知道该说些什么。请通过电子邮件将评论发送至&lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6c6c6a28aca9f64e81536b5041a7bd3a852dd99" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please submit comments to &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5215ed25fc6b559f1f45b7ad436f4f9831272e" translate="yes" xml:space="preserve">
          <source>The rest which are already available are based upon the vendor mappings at &lt;a href=&quot;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cb44cf97eef964df25c82472ad386e80122021" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt; .</source>
          <target state="translated">重新启动是使用先前实施 &lt;code&gt;longjmp&lt;/code&gt; 的在 &lt;code&gt;regatom()&lt;/code&gt; 返回一个 &lt;code&gt;setjmp&lt;/code&gt; 的在 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; ，但是这被证明是有问题的，因为后者是含有许多自动变量，大量功能，它们相互作用严重与紧急控制流程 &lt;code&gt;setjmp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cb3a75ceb2d2ee1d3bf90c88d2151a6541e047d" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt;, but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8310b48c79e713f14decd4088c7da40b8f8d5f" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt; . In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="translated">比较操作的限制是，即使例如 &lt;code&gt;cmp&lt;/code&gt; 应该返回一个有福的引用，自动生成的 &lt;code&gt;lt&lt;/code&gt; 函数也将基于 &lt;code&gt;cmp&lt;/code&gt; 结果的数值仅生成标准逻辑值。特别是在这种情况下，需要进行有效的数值转换（可能用其他转换形式表示）。</target>
        </trans-unit>
        <trans-unit id="f937ca260b1eebc06f72a3641b2c030503e4317b" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt;. In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17095fb32ad5dc43587aca28eee99cc6fee8a6b5" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;$^R&lt;/code&gt; is automatically localized, so that it will behave properly in the presence of backtracking.</source>
          <target state="translated">结果 &lt;code&gt;$^R&lt;/code&gt; 会自动进行本地化，因此在存在回溯的情况下它将正常运行。</target>
        </trans-unit>
        <trans-unit id="917b4b2d464d47448ca46f205a594a1f2094a00d" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">结果 &lt;code&gt;Regexp&lt;/code&gt; 表示该参数是由 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 生成的正则表达式。</target>
        </trans-unit>
        <trans-unit id="1beec82c5ad986daa3005ca6feae967035c22b78" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">结果 &lt;code&gt;Regexp&lt;/code&gt; 表示该参数是由 &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 生成的正则表达式。</target>
        </trans-unit>
        <trans-unit id="fa60f0453236256bf9eae460e1101cb5ebaf3da0" translate="yes" xml:space="preserve">
          <source>The result has a dual nature: it is a NaN, but it also carries the integer inside it. The integer can be retrieved with &lt;a href=&quot;#getpayload&quot;&gt;&quot;getpayload&quot;&lt;/a&gt;. Note, though, that the payload is not propagated, not even on copies, and definitely not in arithmetic operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413c5704399ec4e320c4b4de62416c60414146e3" translate="yes" xml:space="preserve">
          <source>The result is returned as two arguments. If the modular multiplicative inverse does not exist, both arguments are undefined. Otherwise, the arguments are a number (object) and its sign (&quot;+&quot; or &quot;-&quot;).</source>
          <target state="translated">结果作为两个参数返回。如果模块乘法逆不存在,则两个参数都是未定义的,否则,参数是数字(对象)和它的符号(&quot;+&quot;或&quot;-&quot;)。否则,参数是一个数字(对象)和它的符号(&quot;+&quot;或&quot;-&quot;)。</target>
        </trans-unit>
        <trans-unit id="e2176289afdf7f655c62c369888f79d214a9f024" translate="yes" xml:space="preserve">
          <source>The result is that the contents of line 17 of the file will be replaced with &quot;Cherry pie&quot;; a newline character will separate line 17 from line 18. This means that this code will do nothing:</source>
          <target state="translated">结果是文件第17行的内容将被替换为 &quot;Cherry pie&quot;;一个换行符将第17行和第18行分开。这意味着这段代码什么都不会做。</target>
        </trans-unit>
        <trans-unit id="f863b8e99992f5c2a779d9ed98aecf9cef5b7a84" translate="yes" xml:space="preserve">
          <source>The result is the Unicode character or character sequence given by</source>
          <target state="translated">其结果是Unicode字符或字符序列,给出了</target>
        </trans-unit>
        <trans-unit id="f066226510a6a63558092d6e0a75383b46653b7b" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17faf27e0d190c0297fec9a5baff8ccb279e91a8" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由括号之间的十六进制数字指定的字符。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7238c8e2e1333323c2dd62857b981306a7706e6a" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1743ff5152c2110b7544e70901f154f3b6b46b92" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由十六进制数字指定的字符，范围为​​0x00至0xFF。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d86f6bbcc0ec2a19c70956057e4d3cc4063fc333" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bbe820fb63fd799e4d92d37fd1768342fc0ad13" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由括号之间的八进制数字指定的字符。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ca77b886ca2262e5c2630425a0b7e07037d32d3" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d07b8bddc1c5dd823f98677754aff0c68b0c00" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由三位数的八进制数指定的字符，范围在000到777之间（但最好不要在077以上使用，请参阅下一段）。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d2ac189a7b892d497c3a957f821832172806b14" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;code&gt;xhdr&lt;/code&gt; except the is will be restricted to headers where the text of the header matches &lt;code&gt;PATTERN&lt;/code&gt;</source>
          <target state="translated">结果与 &lt;code&gt;xhdr&lt;/code&gt; 相同，除了仅限于标头文本与 &lt;code&gt;PATTERN&lt;/code&gt; 匹配的标头</target>
        </trans-unit>
        <trans-unit id="37186ac3e81998654b9034f359d33c97b138b201" translate="yes" xml:space="preserve">
          <source>The result may be used as a subpattern in a match:</source>
          <target state="translated">其结果可作为匹配中的子模式使用。</target>
        </trans-unit>
        <trans-unit id="aea5a1ac74300d067b63729d12ad0881314aa59c" translate="yes" xml:space="preserve">
          <source>The result of each test is captured in a hash. These hashes are the same as the hashes returned by Test::Builder-&amp;gt;details but with a couple of extra fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a38c7996159062562ab2957a6c23713b7a1d86" translate="yes" xml:space="preserve">
          <source>The result of evaluation of the last successful &lt;code&gt;(?{ code })&lt;/code&gt; regular expression assertion (see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). May be written to.</source>
          <target state="translated">最后一个成功的 &lt;code&gt;(?{ code })&lt;/code&gt; 正则表达式断言的求值结果（请参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;）。可能被写入。</target>
        </trans-unit>
        <trans-unit id="66611e861a602cfa60591a93b737577becd37f08" translate="yes" xml:space="preserve">
          <source>The result of great_circle_direction is in radians, zero indicating straight north, pi or -pi straight south, pi/2 straight west, and -pi/2 straight east.</source>
          <target state="translated">great_circle_direction的结果以弧度为单位,0表示直北,pi或-pi直南,pi/2直西,-pi/2直东。</target>
        </trans-unit>
        <trans-unit id="f6846ed84b71cca2d8b5fb5477773187fbddddb3" translate="yes" xml:space="preserve">
          <source>The result of md5(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) will be exactly the same as the result of md5(&quot;abc&quot;).</source>
          <target state="translated">md5(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)的结果将与md5(&quot;abc&quot;)的结果完全相同。</target>
        </trans-unit>
        <trans-unit id="641d055cafe1e1ee3cae38ce56b7935f5d3bc2b3" translate="yes" xml:space="preserve">
          <source>The result of overflowing the range of the integers is undefined because it is undefined also in C. In other words, using 32-bit integers, &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; is undefined. Shifting by a negative number of bits is also undefined.</source>
          <target state="translated">整数范围溢出的结果是不确定的，因为在C语言中也未定义。换句话说，使用32位整数， &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; 是不确定的。移位为负数位也是不确定的。</target>
        </trans-unit>
        <trans-unit id="00de3247a1fa0dbaa5340672e75fce7f76fa569f" translate="yes" xml:space="preserve">
          <source>The result of this scenario is at best a database that doesn't contain what you expect. At worst the database will corrupt.</source>
          <target state="translated">这种情况的结果是,最好的情况是数据库中没有你所期望的内容。最坏的情况是数据库会损坏。</target>
        </trans-unit>
        <trans-unit id="f6de57c3d8ec6b1611fc0077d370dda9fed1574d" translate="yes" xml:space="preserve">
          <source>The result returned will be one of the following:</source>
          <target state="translated">返回的结果将是以下之一:</target>
        </trans-unit>
        <trans-unit id="0b8a9a1357d52322f675cb2cb87488ac744f63b6" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="translated">如果包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 形式有效，则包含插值材料的结果字符串将被污染。</target>
        </trans-unit>
        <trans-unit id="dc181363eb40ff0bd863bde77567e9656e7a29d5" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;use locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fb17ca190a73d84710650cb1a592da2c670185" translate="yes" xml:space="preserve">
          <source>The result will be an array of 3 elements, each a reference to an array which will hold the handles that are ready for reading, writing and have exceptions respectively. Upon error an empty list is returned.</source>
          <target state="translated">结果将是一个由3个元素组成的数组,每个元素都是一个数组的引用,数组中分别存放着准备好读、写和有异常的句柄。一旦出错,将返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="a68ddca584ffd166b11e615f1b961f7dd364600e" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="translated">结果最多是层数的三倍：第一个元素是名称，第二个元素是参数（未指定的参数是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），第三个元素是标志，第四个元素再次是名称，依此类推向前。</target>
        </trans-unit>
        <trans-unit id="3e9d88696af53de04206c2554e1cd6a14550e72c" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;undef&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e0c7dba94f1684aba5f4cd6501d599a99358de" translate="yes" xml:space="preserve">
          <source>The resulting $subdir_cmd has no leading tab nor trailing newline. This makes it easier to embed in a make string. For example.</source>
          <target state="translated">产生的$subdir_cmd没有前导符,也没有尾部的换行。这使得它更容易嵌入到make字符串中。例如</target>
        </trans-unit>
        <trans-unit id="5f6fcb4f54789b9c880bc0144fb1cf2ebd3b3159" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; values of this string's bytes - the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="translated">生成的字节序列最方便用于检查校验和。不要通过for循环添加此字符串字节的 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 值来减慢程序的速度- &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 代码 &lt;code&gt;%&lt;/code&gt; 是用于计算所有字节的8位总和的东西，该总和必须等于零：</target>
        </trans-unit>
        <trans-unit id="7e685873aa2576bcd6d048591b67cf99d300730d" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;ord&lt;/code&gt; values of this string's bytes - the &lt;code&gt;unpack&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421b5462923e8d16da2f8509620d57a56b898133" translate="yes" xml:space="preserve">
          <source>The resulting path is relative by default, i.e. the resulting path will have a leading colon.</source>
          <target state="translated">默认情况下,生成的路径是相对的,也就是说,生成的路径会有一个前导的冒号。</target>
        </trans-unit>
        <trans-unit id="d4b19b5c805ca56f431cfbcdeba1af9f3a6200a3" translate="yes" xml:space="preserve">
          <source>The resulting program then looks like:</source>
          <target state="translated">然后,产生的程序就像。</target>
        </trans-unit>
        <trans-unit id="e4aa8c76073812eb40b9e292fb100c683926c76e" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;&quot;catpath&quot;&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd638c59c5752a7ccfc83a3bf825d1784299cda6" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">可以将结果传递到&lt;a href=&quot;#catpath&quot;&gt;catpath，&lt;/a&gt;以获取与原始路径相同（通常相同）的路径。</target>
        </trans-unit>
        <trans-unit id="156c1084cc95fa3e7b597345b8d09fde064a081b" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath%28%29&quot;&gt;&quot;catpath()&quot;&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbae74b52e9e1a2f4034868dc967236dfb097109" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath()&quot;&gt;catpath()&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">可以将结果传递到&lt;a href=&quot;#catpath()&quot;&gt;catpath（）&lt;/a&gt;以获取与原始路径等效（通常相同）的路径。</target>
        </trans-unit>
        <trans-unit id="9fd6f04fef4668c0fb9b5436580855adbbe256e9" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;code&gt;catpath()&lt;/code&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">可以将结果传递到 &lt;code&gt;catpath()&lt;/code&gt; 以获取与原始路径等效（通常相同）的路径。</target>
        </trans-unit>
        <trans-unit id="7b48baa73a171c70124bb46d586398a253fc305f" translate="yes" xml:space="preserve">
          <source>The results follow ASCII rules. Only the characters &lt;code&gt;A-Z&lt;/code&gt; change, to &lt;code&gt;a-z&lt;/code&gt; respectively.</source>
          <target state="translated">结果遵循ASCII规则。仅字符 &lt;code&gt;A-Z&lt;/code&gt; 更改为 &lt;code&gt;a-z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6e1386230ca5a3e137558786aef0b9ef4ab7b59" translate="yes" xml:space="preserve">
          <source>The results of creating new symbol table entries directly or modifying any entries that are not already typeglobs are undefined and subject to change between releases of perl.</source>
          <target state="translated">直接创建新的符号表条目或修改任何还没有 typeglobs 的条目的结果都是未定义的,并且在 perl 的不同版本之间会发生变化。</target>
        </trans-unit>
        <trans-unit id="7c1728e8e43393222dde9f78fe3123aaa1846fe7" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt; , use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="translated">从 &lt;code&gt;VERSION&lt;/code&gt; 返回的内容实际上是使用 &lt;code&gt;$VERSION&lt;/code&gt; 标量包的字符串化版本对象，该对象保证是等效的，但可能与 &lt;code&gt;$VERSION&lt;/code&gt; 标量的内容不完全相同。如果您需要 &lt;code&gt;$VERSION&lt;/code&gt; 的实际内容，请改用 &lt;code&gt;$CLASS::VERSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95e455ea284fe76f90c5b0d39ee105831c2e5eaa" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt;, use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b2a16af23a66e19e44621474dc0fa990710d75" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="translated">生成的Perl函数的返回列表由该函数的C返回值组成（除非XSUB为 &lt;code&gt;void&lt;/code&gt; 返回类型或 &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; ），然后是所有 &lt;code&gt;OUTLIST&lt;/code&gt; 和 &lt;code&gt;IN_OUTLIST&lt;/code&gt; 参数（按出现的顺序）。从XSUB返回时，将修改 &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; Perl参数，使其具有C函数写入的值。</target>
        </trans-unit>
        <trans-unit id="44655e68104aa5b50fd85988b88ae70262129b43" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71452936695d00a40f619faefe33e6d1a6ac20b" translate="yes" xml:space="preserve">
          <source>The return may be incorrect for those rare locales where the currency symbol replaces the radix character. Send email to &lt;a href=&quot;mailto:perlbug@perl.org&quot;&gt;mailto:perlbug@perl.org&lt;/a&gt; if you have examples of it needing to work differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0420f753fa3324f9eec48f35a50efc8cee6a049e" translate="yes" xml:space="preserve">
          <source>The return points to a per-thread static buffer, which is overwritten the next time &lt;code&gt;Perl_setlocale&lt;/code&gt; is called from the same thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21da59cc5c1c0e700b109e9dda17411cbacb1df" translate="yes" xml:space="preserve">
          <source>The return true when the argument satisfies the condition. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; are not integers and are neither odd nor even.</source>
          <target state="translated">当参数满足条件时返回true。 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;+inf&lt;/code&gt; ， &lt;code&gt;-inf&lt;/code&gt; 不是整数，也不是奇数也不是偶数。</target>
        </trans-unit>
        <trans-unit id="b8bfaca788fa3c0ddbe45ea5ad9f0da16e79efb8" translate="yes" xml:space="preserve">
          <source>The return value (if defined) is a Perl object, of class &lt;code&gt;PerlIO::Layer&lt;/code&gt; which is created by the C code in</source>
          <target state="translated">返回值（如果已定义）是 &lt;code&gt;PerlIO::Layer&lt;/code&gt; 类的Perl对象，该对象由C语言中的C创建</target>
        </trans-unit>
        <trans-unit id="45642a1469744a5e7107d7873a8272d52cfce5d2" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">返回值 &lt;code&gt;LVALUE&lt;/code&gt; 表示对不是变量的左值的引用。您可以通过引用函数调用（例如 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; )来实现。如果引用指向&lt;a href=&quot;perldata#Version-Strings&quot;&gt;版本字符串，&lt;/a&gt;则返回 &lt;code&gt;VSTRING&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68a59800451bff6b585d75aa0febce039f889432" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">返回值 &lt;code&gt;LVALUE&lt;/code&gt; 表示对不是变量的左值的引用。您可以通过引用函数调用（例如 &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; )来实现。如果引用指向&lt;a href=&quot;../perldata#Version-Strings&quot;&gt;版本字符串，&lt;/a&gt;则返回 &lt;code&gt;VSTRING&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1b1a3b59d37e5fda7fca51bd6d7cc822e1098fc" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="translated">可以 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 返回值以获取原始引用结构的相同副本。（请务必考虑从不受信任的来源评估代码的安全性！）</target>
        </trans-unit>
        <trans-unit id="341077e987e38231c6848bd510801f6ac305a364" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;eval&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce36c299811e6d9af00c0cefc9c75e073456ac7" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; 的返回值是实现定义的；有关更多信息，请查阅您的atan2（3）联机帮助页。</target>
        </trans-unit>
        <trans-unit id="769d902022de1a90d1cd24370f703e7b45d5dad4" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; 的返回值是实现定义的；有关更多信息，请查阅您的atan2（3）联机帮助页。</target>
        </trans-unit>
        <trans-unit id="3f7e47c80e390cbc99d4bd2d52e4ac31f1eae4a5" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;atan2(0,0)&lt;/code&gt; is implementation-defined; consult your &lt;a href=&quot;http://man.he.net/man3/atan2&quot;&gt;atan2(3)&lt;/a&gt; manpage for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa7da95c4b58e8bb23e135f8795df5f9ac97aa0" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">返回值是 &lt;code&gt;true&lt;/code&gt; ，如果这是一个有效的原型， &lt;code&gt;false&lt;/code&gt; 如果不是，不论 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c3cd7efde35a3e831a5bdd29d0ed5265715cc55" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;warn&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd97a8975a72082d0544ff1e498721e427862ae3" translate="yes" xml:space="preserve">
          <source>The return value is POSIX-like (shifted up by 8 bits), which only allows room for a made-up value derived from the severity bits of the native 32-bit condition code (unless overridden by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ). If the native condition code is one that has a POSIX value encoded, the POSIX value will be decoded to extract the expected exit value. For more details see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt;. (VMS)</source>
          <target state="translated">返回值是POSIX样（移由8位），只允许室用于从本地32位条件代码的严重性位（除非由重写衍生的虚构的值 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ）。如果本地条件代码是已编码POSIX值的代码，则POSIX值将被解码以提取预期的退出值。有关更多详细信息，请参见&lt;a href=&quot;perlvms#%24%3f&quot;&gt;$？在perlvms中&lt;/a&gt;。（VMS）</target>
        </trans-unit>
        <trans-unit id="38f16262d38a09b1b50bf9932e5e395bae210a67" translate="yes" xml:space="preserve">
          <source>The return value is a boolean: TRUE if the global locale at the time of call was in effect; and FALSE if a per-thread locale was in effect. This can be used by the caller that needs to restore things as-they-were to decide whether or not to call &lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt;&lt;code&gt;Perl_switch_to_global_locale&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f3af5a62c5a74bbd990f1648eb2762ff5d0f59" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43901da674d6737b62ebf11f4c04c938005307af" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="translated">返回值始终是标量，可以是字符串或数字。对于具有值同义词的属性，此函数返回的同义词是最长，最具描述性的形式，当在标量上下文中调用时，&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;返回的形式。当然，您可以在结果上调用&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;以获取其他同义词。</target>
        </trans-unit>
        <trans-unit id="897578330f8509b5163b4447af0b4daff044a33c" translate="yes" xml:space="preserve">
          <source>The return value is formatted according to OLE conventions, as groups of hex digits with surrounding braces. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e2753bab1a4f25f52114a02dccb7b840c45d95" translate="yes" xml:space="preserve">
          <source>The return value is the $ctx object itself.</source>
          <target state="translated">返回值是$ctx对象本身。</target>
        </trans-unit>
        <trans-unit id="437a2be9f2de32d0576eb59aa85a5731812472a7" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt;. This is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ee5d406f163544969cdcc538ef722336dcb763" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">返回值是 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 调用返回的程序的退出状态。要获得实际的退出值，请向右移动八位（请参见下文）。另请参阅&lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;。这是</target>
        </trans-unit>
        <trans-unit id="aadd087b1069c48b3ff2e37ed0925a6bb732b05e" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">返回值是 &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 调用返回的程序的退出状态。要获得实际的退出值，请向右移动八位（请参见下文）。另请参阅&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;。这是</target>
        </trans-unit>
        <trans-unit id="28ff84250f55ab2bea98fda52eb0b62db0c2d4bd" translate="yes" xml:space="preserve">
          <source>The return value is the total length &lt;code&gt;src&lt;/code&gt; would be if the copy completely succeeded. If it is larger than &lt;code&gt;size&lt;/code&gt;, the excess was not copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db618f76ec023ae4b98dae939007dd3399a79764" translate="yes" xml:space="preserve">
          <source>The return value is the total length that &lt;code&gt;dst&lt;/code&gt; would have if &lt;code&gt;size&lt;/code&gt; is sufficiently large. Thus it is the initial length of &lt;code&gt;dst&lt;/code&gt; plus the length of &lt;code&gt;src&lt;/code&gt;. If &lt;code&gt;size&lt;/code&gt; is smaller than the return, the excess was not appended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857262cdace40b471947bb6d3b761ee596eafe64" translate="yes" xml:space="preserve">
          <source>The return value is the updated object itself.</source>
          <target state="translated">返回值是更新后的对象本身。</target>
        </trans-unit>
        <trans-unit id="7f93f7b8be78580a6fdb8b5153d679ad923050d6" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回值可以是包含零个或多个arrayref，一个整数或 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="3f37d26524cdd675f6f08be05c61f9223fd0378a" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36fd088c56b8f88cc2d2e8985a8fda08a71a63d3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="translated">返回值可以是第1到第4权重的arrayref，如上所示。返回值可以是整数作为主要权重，如下所示。如果返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则将使用默认的派生排序规则元素。</target>
        </trans-unit>
        <trans-unit id="68d7e0ec957990f452acfaa57c18c8410bd4dda3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;undef&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222fe952afa9c24172c89b0f769d4878a2ea7ad7" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;ioctl&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;fcntl&lt;/code&gt;&lt;/a&gt;) is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a717c20899094357a3bea685885351b6040d8de0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; on pipes, fifos, and sockets usually returns -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d5675dc8f958bc8634e0a1b5851a8577fc5c3bc" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; （和 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ）的返回值如下：</target>
        </trans-unit>
        <trans-unit id="03abb254ae6958b0d4d3e3d838f5570ae93832e6" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; （和 &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ）的返回值如下：</target>
        </trans-unit>
        <trans-unit id="16085bf8175ff49a2dcc989db1bc66f5346f4ab0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;INLINED&lt;/code&gt; in this example will always be 54321, regardless of later modifications to $x. You can also put any arbitrary code inside the sub, at it will be executed immediately and its return value captured the same way.</source>
          <target state="translated">在此示例中， &lt;code&gt;INLINED&lt;/code&gt; 的返回值将始终为54321，而不管以后对$ x的修改如何。您还可以将任意代码放入子代码中，然后立即执行该子代码，并以相同的方式捕获其返回值。</target>
        </trans-unit>
        <trans-unit id="f23542316437f18c2dc0de0ad16ae0deb404671a" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;survey&lt;/code&gt; is two hashes:</source>
          <target state="translated">&lt;code&gt;survey&lt;/code&gt; 的返回值是两个散列：</target>
        </trans-unit>
        <trans-unit id="6c7d2d6bce6775764986b9434f93f3fd3d99f22b" translate="yes" xml:space="preserve">
          <source>The return value of Pod::Perldoc::GetOptsOO::getopts is true if no errors, otherwise it's false.</source>
          <target state="translated">如果没有错误,Pod::Perldoc::GetOptsOO::getopts的返回值为true,否则为false。</target>
        </trans-unit>
        <trans-unit id="57cb77ff2698d7727be628530d185f8aa579f00d" translate="yes" xml:space="preserve">
          <source>The return value of tell() for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. tell() on pipes, fifos, and sockets usually returns -1.</source>
          <target state="translated">tell()对标准流(如STDIN)的返回值取决于操作系统:它可能返回-1或其他值。在管道、fifos和套接字上的tell()通常返回-1。</target>
        </trans-unit>
        <trans-unit id="d4713d5655dc6e9b8c7a80e55df87e6a297b0b32" translate="yes" xml:space="preserve">
          <source>The return value will be &lt;code&gt;NULL&lt;/code&gt; if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt;. Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned &lt;code&gt;NULL&lt;/code&gt;. Effectively a successful &lt;code&gt;hv_store&lt;/code&gt; takes ownership of one reference to &lt;code&gt;val&lt;/code&gt;. This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, &lt;code&gt;hv_store&lt;/code&gt; will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. &lt;code&gt;hv_store&lt;/code&gt; is not implemented as a call to &lt;code&gt;hv_store_ent&lt;/code&gt;, and does not create a temporary SV for the key, so if your key data is not already in SV form then use &lt;code&gt;hv_store&lt;/code&gt; in preference to &lt;code&gt;hv_store_ent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972da9f747345510c81b2dc820fd0994a9799509" translate="yes" xml:space="preserve">
          <source>The return value will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt; . Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">如果操作失败或如果不需要将该值实际存储在散列中（如绑定散列的情况），则返回值将为NULL。否则，可以取消引用以获取原始 &lt;code&gt;SV*&lt;/code&gt; 。注意，调用者负责在调用之前适当地增加 &lt;code&gt;val&lt;/code&gt; 的引用计数，并在函数返回NULL时递减它。实际上，成功的hv_store拥有对 &lt;code&gt;val&lt;/code&gt; 的一个引用的所有权。这通常是您想要的；新创建的SV的引用计数为1，因此，如果您所有的代码都是创建SV，然后将它们存储在哈希中，则hv_store将拥有对新SV的唯一引用，并且您的代码无需执行任何其他操作即可整理。 hv_store未实现为对hv_store_ent的调用，并且不会为密钥创建临时SV，因此，如果您的密钥数据尚未采用SV格式，则优先使用hv_store而不是hv_store_ent。</target>
        </trans-unit>
        <trans-unit id="9bfc61e3c5920efd0c58d16c1ed44649d2d5bb7c" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error condition, followed by the hostname and service name.</source>
          <target state="translated">返回值将是一个列表;第一个值是错误条件,后面是主机名和服务名。</target>
        </trans-unit>
        <trans-unit id="080fb2b25b92c9701522bdcbe08ea5301edb65d9" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error indication, followed by a list of address structures (if no error occurred).</source>
          <target state="translated">返回值将是一个列表;第一个值是一个错误指示,后面是一个地址结构的列表(如果没有发生错误)。</target>
        </trans-unit>
        <trans-unit id="e58ba0106a37355ff008e5789a74611883b7e6cc" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains a reference to an array which contains the overview fields for that message.</source>
          <target state="translated">返回值将是对哈希的引用,其中键是消息编号,每个值包含对数组的引用,数组中包含该消息的概览字段。</target>
        </trans-unit>
        <trans-unit id="c8d88b4235e896d1cdf2637f38fe289f36609de1" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains the text of the requested header for that message.</source>
          <target state="translated">返回值将是对哈希的引用,其中键是消息号码,每个值包含该消息的请求头的文本。</target>
        </trans-unit>
        <trans-unit id="7ff5356b785d18cf62379ed63c212e5a8a9ffb9a" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d18fcb9f371a15bbc60a7727df47264e8d90a5" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="translated">返回值比&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;更&amp;ldquo;煮熟&amp;rdquo; 。例如， &lt;code&gt;&quot;uc&quot;&lt;/code&gt; 属性值是包含输入代码点的完整大写字母映射的实际字符串。当完整映射与简单映射不同时，必须麻烦 &lt;code&gt;charinfo&lt;/code&gt; 才能从其 &lt;code&gt;upper&lt;/code&gt; 哈希元素获取此值。</target>
        </trans-unit>
        <trans-unit id="a0c27b1b52fce6c8f2f090cdffac0089b776c9ec" translate="yes" xml:space="preserve">
          <source>The returned NaN is always a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e761cd70527853f3676a64d7d2be637d80127b77" translate="yes" xml:space="preserve">
          <source>The returned hash consists of 4 parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac925fdbc70f038b7d79d3f22cbbb8542015b931" translate="yes" xml:space="preserve">
          <source>The returned list will begin with the initial value for &lt;code&gt;$a&lt;/code&gt;, followed by each return value from the block in order. The final value of the result will be identical to what the &lt;code&gt;reduce&lt;/code&gt; function would have returned given the same block and list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df12c311a5affa1878c7637ef497a0992643ca1" translate="yes" xml:space="preserve">
          <source>The returned object will only be valid as long as the underlying OPs and SVs continue to exist. Do not attempt to use the object after the underlying structures are freed.</source>
          <target state="translated">只有在底层OP和SV继续存在的情况下,返回的对象才会有效。在底层结构被释放后,不要试图使用该对象。</target>
        </trans-unit>
        <trans-unit id="27c81be6b30926294699f4659627b6ffa79304d4" translate="yes" xml:space="preserve">
          <source>The returned script will be &lt;code&gt;SCX_Inherited&lt;/code&gt; iff all the code points in it are from the Inherited script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9c36a9cfb66d7244d884d86187f93dbed4c9d0" translate="yes" xml:space="preserve">
          <source>The returned value will have the characters that can't be decoded replaced by &quot;\x{FFFD}&quot;, the Unicode replacement character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb88fca63fb7d940d0f8f78e07d1c80fa709c01" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">返回的值是哈希中原始键的副本，因此修改它们将不会影响原始哈希。比较&lt;a href=&quot;#values&quot;&gt;值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3aac40383199a850fb451c54d0b1c983a804515" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d53dad6b674af04a6d84ac0aee48048c271fdde" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">返回的值是哈希中原始键的副本，因此修改它们将不会影响原始哈希。比较&lt;a href=&quot;values&quot;&gt;值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21a00c167788624d4ca90d4b617125a344dae47a" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot; in a Perl regular rexpression for these, like &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ,</source>
          <target state="translated">Perl扩展属性（例如 &lt;code&gt;Any&lt;/code&gt; 和 &lt;code&gt;Greek&lt;/code&gt; )的返回值有些误导。值为 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;N&lt;/code&gt; &amp;rdquo;。所有Unicode属性都是两部分的，因此您实际上可以在Perl常规表达式中使用 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;N&lt;/code&gt; &amp;rdquo;，例如 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt; 。但是，并不是以这种方式指定Perl扩展名，仅像 &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="0b00496e0ac48606a2b2f5ade4900470b3e5cc37" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt;&quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt;&quot; in a Perl regular expression for these, like &lt;code&gt;qr/\p{ID_Start=Y/}&lt;/code&gt; or &lt;code&gt;qr/\p{Upper=N/}&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5eea968d1f523529d28fcd024fbb7e15c83c048" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object.</source>
          <target state="translated">Perl解释器的修订版，版本和子版本，表示为&lt;a href=&quot;version&quot;&gt;版本&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="85e9edc5bb272a0ee91c10e7c6d3172fdb763afd" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a decimal of the form 5.XXXYYY, where XXX is the version / 1e3 and YYY is the subversion / 1e6. For example, Perl v5.10.1 would be &quot;5.010001&quot;.</source>
          <target state="translated">Perl 解释器的修订版、版本和子版本,用小数表示,形式为 5.XXXYYY,其中 XXX 是版本/1e3,YYY 是子版本/1e6。例如,Perl v5.10.1就是 &quot;5.010001&quot;。</target>
        </trans-unit>
        <trans-unit id="66e488be2f8483df95b9f037ffeda3de74384599" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt; . The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="translated">在某些操作上，例如 &lt;code&gt;new()&lt;/code&gt; ， &lt;code&gt;bstr()&lt;/code&gt; 和 &lt;code&gt;numify()&lt;/code&gt; ，此模块的重写版本（vs. v0.01）速度较慢。原因是它现在做更多的工作并处理更多的案件。通常在其他数学运算中会花费在这些运算上的时间，因此平均而言，代码应该（快得多）快得多。如果没有，请与作者联系。</target>
        </trans-unit>
        <trans-unit id="d648a5385a086d97fdf940828d9fd6d003974ab0" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt;, &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt;. The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23622f986ab9be80262d33005c6066bc0cc050da" translate="yes" xml:space="preserve">
          <source>The right column will also caution you if a property means something different than what might normally be expected.</source>
          <target state="translated">如果一个属性的含义与通常预期的不同,右栏也会提醒你。</target>
        </trans-unit>
        <trans-unit id="ae21a75ed2b2f6ef4dbb92843a55ab639a296c6c" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt; also in</source>
          <target state="translated">从第5行开始，右侧类似于我们刚刚看到的内容：我们有 &lt;code&gt;add&lt;/code&gt; op（ &lt;code&gt;pp_add&lt;/code&gt; 也位于</target>
        </trans-unit>
        <trans-unit id="a97b5a9d26a8152b03235a227c2f7630aad78c10" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt;, also in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e3fe5f1905fd5d0642f37b1a353b457c2b5b66" translate="yes" xml:space="preserve">
          <source>The right operand is not evaluated while the operator is in the &quot;false&quot; state, and the left operand is not evaluated while the operator is in the &quot;true&quot; state. The precedence is a little lower than || and &amp;amp;&amp;amp;. The value returned is either the empty string for false, or a sequence number (beginning with 1) for true. The sequence number is reset for each range encountered. The final sequence number in a range has the string &lt;code&gt;&quot;E0&quot;&lt;/code&gt; appended to it, which doesn't affect its numeric value, but gives you something to search for if you want to exclude the endpoint. You can exclude the beginning point by waiting for the sequence number to be greater than 1.</source>
          <target state="translated">当运算符处于&amp;ldquo; false&amp;rdquo;状态时，不评估右侧操作数，而当运算符处于&amp;ldquo; true&amp;rdquo;状态时，不评估左侧操作数。优先级略低于|| 和&amp;amp;&amp;amp;。返回的值要么为空字符串（为false），要么为序列号（从1开始）为true。将为遇到的每个范围重置序列号。范围中的最后一个序列号附加了字符串 &lt;code&gt;&quot;E0&quot;&lt;/code&gt; ，这不会影响其数值，但是如果您要排除端点，则会为您提供一些搜索内容。您可以通过等待序列号大于1来排除起点。</target>
        </trans-unit>
        <trans-unit id="712b7dd783ec62d03111b67512c4c71fb70fa066" translate="yes" xml:space="preserve">
          <source>The rightmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;gt;&quot;).</source>
          <target state="translated">最右边的定界符从参数文本开始到内部序列（应为&amp;ldquo;&amp;gt;&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="f1b13ab5c99b5028d035c2e34026b78f830a5ce1" translate="yes" xml:space="preserve">
          <source>The rmtree() function provide the legacy interface of remove_tree() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to remove_tree().</source>
          <target state="translated">rmtree()函数提供了传统的remove_tree()的接口,但对传递的参数有不同的解释。该函数的行为和返回值与 remove_tree()完全相同。</target>
        </trans-unit>
        <trans-unit id="97d9690fe48f5ed9ac8be9b70513653d3ab42339" translate="yes" xml:space="preserve">
          <source>The rot13 example was a trivial example. Here's another demonstration that shows off a few more features.</source>
          <target state="translated">rot13的例子是一个微不足道的例子。下面是另一个演示,展示了一些更多的功能。</target>
        </trans-unit>
        <trans-unit id="4a28f646da84403da9a05e371721d016d1168285" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$idx]&lt;/code&gt; .</source>
          <target state="translated">perl的大致等效项是 &lt;code&gt;$myarray[$idx]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b4a8606a49a46444c3a9ed277908732090e4141" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$key]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07cb0ce6d373861ed9384fe1d2dba7e82ae7d7eb" translate="yes" xml:space="preserve">
          <source>The routine &lt;code&gt;regtail()&lt;/code&gt; is called by both &lt;code&gt;reg()&lt;/code&gt; and &lt;code&gt;regbranch()&lt;/code&gt; in order to &quot;set the tail pointer&quot; correctly. When executing and we get to the end of a branch, we need to go to the node following the grouping parens. When parsing, however, we don't know where the end will be until we get there, so when we do we must go back and update the offsets as appropriate. &lt;code&gt;regtail&lt;/code&gt; is used to make this easier.</source>
          <target state="translated">&lt;code&gt;reg()&lt;/code&gt; 和 &lt;code&gt;regbranch()&lt;/code&gt; 都调用例程 &lt;code&gt;regtail()&lt;/code&gt; ，以便正确地&amp;ldquo;设置尾部指针&amp;rdquo;。执行时，我们到达分支的末尾，我们需要转到分组parens之后的节点。但是，在解析时，直到到达终点，我们才知道终点在哪里，所以当我们这样做时，我们必须返回并适当地更新偏移量。 &lt;code&gt;regtail&lt;/code&gt; 用于简化此过程。</target>
        </trans-unit>
        <trans-unit id="96fb8a6192d6d2137dae358308fab281f2803684" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; , a loop exit, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt; .</source>
          <target state="translated">当即将引发致命异常时，将调用 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 指示的例程。错误消息将作为第一个参数传递。当 &lt;code&gt;__DIE__&lt;/code&gt; 钩子例程返回时，异常处理将像没有钩子时一样继续进行，除非钩子例程本身通过 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; ，循环出口或 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 退出。该 &lt;code&gt;__DIE__&lt;/code&gt; 处理程序在通话过程中明确禁用，这样就可以从一个死 &lt;code&gt;__DIE__&lt;/code&gt; 处理程序。 &lt;code&gt;__WARN__&lt;/code&gt; 同样。</target>
        </trans-unit>
        <trans-unit id="a3747082bcec8b320b157ca0f6db8a2c2a773d76" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;goto &amp;amp;sub&lt;/code&gt;, a loop exit, or a &lt;code&gt;die()&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23e498d9e0f7b9916602bb81bb457e05dc15d28" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt; . The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="translated">最常用的例程是 &lt;code&gt;call_sv&lt;/code&gt; 。在 &lt;code&gt;SV*&lt;/code&gt; 参数中包含的任何Perl函数的名称叫，或者给子程序的引用。第二个参数由标志组成，这些标志控制在其中调用子例程的上下文，是否正在传递子例程参数，应如何捕获错误以及如何处理返回值。</target>
        </trans-unit>
        <trans-unit id="8b9d3fc2ab950a51903275842538b6aa8532b735" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt;. The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02aa17c916dde6540e50fc69118a82269239b3fa" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;b&gt;false&lt;/b&gt; otherwise.</source>
          <target state="translated">否则，该例程返回&lt;b&gt;false&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2a6f415596eaaeb6ae6674de29690a406129631d" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; exception.</source>
          <target state="translated">例程针对I / O问题或其他内部错误返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，否则返回true。严重的错误将作为 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 传播。</target>
        </trans-unit>
        <trans-unit id="274062f280eff9b69a72565df5a686a0a630e507" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;undef&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;die&lt;/code&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30cd5a5724b0cdff1db0ded8bf4cad313b5d3163" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;reftype&lt;/code&gt; are exportable.</source>
          <target state="translated">例程 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;reftype&lt;/code&gt; 可导出。</target>
        </trans-unit>
        <trans-unit id="7978092db3768ef7e6d213d57a05b4b46c4c1d11" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; exported by default. You must specify which ones you want to use.</source>
          <target state="translated">该程序 &lt;code&gt;make_path&lt;/code&gt; 和 &lt;code&gt;remove_tree&lt;/code&gt; 都&lt;b&gt;不会&lt;/b&gt;默认被导出。您必须指定要使用的那些。</target>
        </trans-unit>
        <trans-unit id="5f252df425e68241a153a06fc0e9c8513b5f1aa7" translate="yes" xml:space="preserve">
          <source>The routines are called in string comparison order of KEY.</source>
          <target state="translated">例程按KEY的字符串比较顺序调用。</target>
        </trans-unit>
        <trans-unit id="74358fa70816b0be14690b88380765bc85d1b11f" translate="yes" xml:space="preserve">
          <source>The routines provided are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258695837b0d342f488ae3724d49cf11d73778d9" translate="yes" xml:space="preserve">
          <source>The rule by which Digest::SHA handles a Unicode string is easy to state, but potentially confusing to grasp: the string is interpreted as a sequence of byte values, where each byte value is equal to the ordinal value (viz. code point) of its corresponding Unicode character. That way, the Unicode string 'abc' has exactly the same digest value as the ordinary string 'abc'.</source>
          <target state="translated">Digest::SHA处理Unicode字符串的规则很容易说明,但可能会让人感到困惑:字符串被解释为一个字节值序列,其中每个字节值等于其对应Unicode字符的序数值(即码点)。这样一来,Unicode字符串'abc'与普通字符串'abc'具有完全相同的数字值。</target>
        </trans-unit>
        <trans-unit id="6b4e5af62f9d03a0b5c8d39854ce10f47d56d0b1" translate="yes" xml:space="preserve">
          <source>The rule must only have one top level key: either 'par' for &quot;parallel&quot; or 'seq' for &quot;sequence&quot;.</source>
          <target state="translated">规则必须只有一个顶层键:&quot;parallel &quot;的'par'或 &quot;sequence &quot;的'seq'。</target>
        </trans-unit>
        <trans-unit id="2858e68dbb1d52d413ae8f5dae1d589d672ac788" translate="yes" xml:space="preserve">
          <source>The rule of thumb for portable code is: Do it all in portable Perl, or use a module (that may internally implement it with platform-specific code, but exposes a common interface).</source>
          <target state="translated">可移植代码的经验法则是。全部用可移植的Perl来做,或者使用一个模块(可以在内部用特定平台的代码来实现,但要暴露一个通用接口)。</target>
        </trans-unit>
        <trans-unit id="242ca7a8186e9298403d04b4bfd265a295183ebf" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;UTF-8&lt;/code&gt; unless you know what you're doing and unless you really benefit from using &lt;code&gt;UTF-16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d771186d9f060b8e39d56f4b8de80fe1694de984" translate="yes" xml:space="preserve">
          <source>The rules data structure is documented more in the next section.</source>
          <target state="translated">规则数据结构在下一节会有更多的记载。</target>
        </trans-unit>
        <trans-unit id="b2b47541d9fe53d041ea0cd594a357e270362960" translate="yes" xml:space="preserve">
          <source>The rules determining what it is are quite simple: if the character following the backslash is an ASCII punctuation (non-word) character (that is, anything that is not a letter, digit, or underscore), then the backslash just takes away any special meaning of the character following it.</source>
          <target state="translated">决定它是什么的规则很简单:如果反斜线后面的字符是ASCII标点符号(非单词)字符(即任何不是字母、数字或下划线的字符),那么反斜线只是带走了它后面字符的任何特殊意义。</target>
        </trans-unit>
        <trans-unit id="f747d6278f9a09b6ca106424547e7e55bc600835" translate="yes" xml:space="preserve">
          <source>The rules of conduct that, in the absence of other guidance, determine what should happen first. For example, in the absence of parentheses, you always do multiplication before addition.</source>
          <target state="translated">在没有其他指导意见的情况下,决定应该先做什么的行为规则。例如,在没有括号的情况下,你总是先做乘法再做加法。</target>
        </trans-unit>
        <trans-unit id="ba784b5f42a3cdb9214cd0e95e0cb55e8afe477c" translate="yes" xml:space="preserve">
          <source>The rules used by &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict&lt;/code&gt;&lt;/a&gt; apply to this construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903df1a17859e1fa3a6b96e5e64488aec405db63" translate="yes" xml:space="preserve">
          <source>The rules used for matching decimal digits are slightly stricter. Many scripts have their own sets of digits equivalent to the Western &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt; ones. A few, such as Arabic, have more than one set. For a string to be considered a script run, all digits in it must come from the same set of ten, as determined by the first digit encountered. As an example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac2685482eb75c8db66c436a646aa6e3d97f9ed" translate="yes" xml:space="preserve">
          <source>The runtime component should have the name</source>
          <target state="translated">运行时组件的名称应该是</target>
        </trans-unit>
        <trans-unit id="9ac33bbce70d7ec48c4fcab9365b96ff1ebc5597" translate="yes" xml:space="preserve">
          <source>The runtime phase refers not only to when the distribution's contents are installed, but also to its continued use. Any library that is a prerequisite for regular use of this distribution should be indicated here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763ace778385d85ae756e3844782d5cfee6e0e05" translate="yes" xml:space="preserve">
          <source>The same approach as a command line:</source>
          <target state="translated">与命令行的方法相同。</target>
        </trans-unit>
        <trans-unit id="9976b6a81a6abb21b7cab5b632b4ad690c05665b" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 相同，但是如果无法自动生成丢失的运算符，则可以在不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 指令的情况下，允许Perl还原为对该运算符执行的操作，而不是发出错误消息。</target>
        </trans-unit>
        <trans-unit id="aff3ca408715d6ed9bbfe43d93b70be580afe993" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;undef&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;use overload&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7d5583bb4c7bf75d630d65c93bc37b198d69e0" translate="yes" xml:space="preserve">
          <source>The same caveats as the previous form apply: The non-graphic characters are no longer allowed with &quot;use utf8&quot;, it is unwise to use this form at all, and utf8ness makes a big difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286499ca118e6aee1159ad012e0d0c293bc05679" translate="yes" xml:space="preserve">
          <source>The same checksum can also be calculated in OO style:</source>
          <target state="translated">同样的校验和也可以用OO式计算。</target>
        </trans-unit>
        <trans-unit id="e7121397996c97368f3bf5006e5d7cf5183183f6" translate="yes" xml:space="preserve">
          <source>The same effect as the example above in a different way. The coderef takes the alias name as an argument and returns a canonical name on success or undef if not. Note the second argument is ignored if provided. Use this with even more caution than the regex version.</source>
          <target state="translated">与上面的例子效果相同,但方式不同。coderef将别名作为参数,并在成功时返回一个规范的名称,如果不成功则返回undef。注意,如果提供了第二个参数,则会被忽略。使用这个方法要比使用 regex 版本更加谨慎。</target>
        </trans-unit>
        <trans-unit id="e43451146d37e633afabe95e907553562bae7cb9" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">对于包含子例程或当前正在执行的评估字符串也是如此。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 字符串的$ filename 看起来像 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bfd670d25b13b1b3ec948c8f09f21523b3aecf7" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;eval&lt;/code&gt;ed strings looks like &lt;code&gt;(eval 34)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a048bf53e27173e747513cb4000a6c6bd711ca9e" translate="yes" xml:space="preserve">
          <source>The same information is displayed at the end of the output from the command</source>
          <target state="translated">同样的信息也会显示在命令</target>
        </trans-unit>
        <trans-unit id="fe72bff5d187e52fa5d199f09887af6af2e32815" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; : these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="translated">对于 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 的实现，情况并非如此：期望它们修改其操作数。的适当实现 &lt;code&gt;--&lt;/code&gt; 可能看起来像</target>
        </trans-unit>
        <trans-unit id="07cb6e84563964c1b3fb8a6ff37a2b4286b6b128" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;: these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9889316caadba38254c295ba1f667d08e692e37" translate="yes" xml:space="preserve">
          <source>The same might happen to AIX 5.1 or other OS levels. As a side note, Perl cannot be built without bos.adt.syscalls and bos.adt.libm installed</source>
          <target state="translated">同样的情况也可能发生在AIX 5.1或其他级别的操作系统上。另外,如果没有安装bos.adt.syscalls和bos.adt.libm,Perl是无法构建的。</target>
        </trans-unit>
        <trans-unit id="2d3beec233d4767fecd283497936fe00947a8d1a" translate="yes" xml:space="preserve">
          <source>The same package name can be used more than once, allowing for non-contiguous code. This is useful if you have a stronger ordering principle than package names.</source>
          <target state="translated">同一个包名可以使用一次以上,允许使用不相邻的代码。如果你有比包名更强的排序原则,这很有用。</target>
        </trans-unit>
        <trans-unit id="adf0ce12f9a7b11a4e4d148adc2353bc6022f25b" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="translated">如果在非ISO8859-1和非UTF-8语言环境中启用标准文件句柄，默认 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 层和 &lt;code&gt;@ARGV&lt;/code&gt; 的自动UTF-8化，则会出现相同的问题（通过使用&lt;b&gt;-C&lt;/b&gt;命令行或 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 环境变量；请参见&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;）。事物以UTF-8的形式读入，这通常意味着使用Unicode解释，但是语言环境的存在会导致它们在该语言环境中进行解释。例如，Unicode输入中的0xD7代码点（应表示乘法符号）在希腊语环境下不会被Perl那样解释。这不是问题</target>
        </trans-unit>
        <trans-unit id="44e618a0d24868bdeb405a4592271ed0ce58faad" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;open()&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8104fdf41371cefa43c656a17bffde6b62386dd0" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from BigInt.</source>
          <target state="translated">如果将它们传递给Math :: BigInt-&amp;gt; binf（）对象，则会发生相同的问题。由于不可能重载这些例程，因此无法通过BigInt进行修复。</target>
        </trans-unit>
        <trans-unit id="7dc30b04b9083d2f8edd85ddb5597b7e64cf1167" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from Math::BigInt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd308e84d4bbc13d1645c341d0f0d15e57ef77b4" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e999fed9c0e326d353539553d4a7555374fd82" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in unpack().</source>
          <target state="translated">同样的模板一般也可以用在unpack()中。</target>
        </trans-unit>
        <trans-unit id="6b6c7f4b6ab698dbba6b63d74e5bcb57fa5d9973" translate="yes" xml:space="preserve">
          <source>The same tests are run both times, but more information is provided when running as &lt;code&gt;./perl harness&lt;/code&gt;.</source>
          <target state="translated">两次都运行相同的测试，但是以 &lt;code&gt;./perl harness&lt;/code&gt; 运行时会提供更多信息。</target>
        </trans-unit>
        <trans-unit id="1f4add58be52aaba625e5f7ff33a20f204714d58" translate="yes" xml:space="preserve">
          <source>The sample program:</source>
          <target state="translated">样板程序。</target>
        </trans-unit>
        <trans-unit id="81ca6bed72a326bbf775e3304829aa324851950b" translate="yes" xml:space="preserve">
          <source>The save stack is used by perl to implement the &lt;code&gt;local&lt;/code&gt; keyword and other similar behaviours; any cleanup operations that need to be performed when leaving the current scope. Items pushed to this stack generally capture the current value of some internal variable or state, which will be restored when the scope is unwound due to leaving, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;die&lt;/code&gt;, &lt;code&gt;goto&lt;/code&gt; or other reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f745bb5cbca08197cbed6d6403139abf437a8fa9" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt; .</source>
          <target state="translated">标量 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值存储在称为 &lt;code&gt;PL_sv_undef&lt;/code&gt; 的SV实例中。</target>
        </trans-unit>
        <trans-unit id="7d200dc97f6deaa66b9415179bc13a97fa0cc3da" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;undef&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e858b562140c68ce32ea23e2b6e666b2e82798f" translate="yes" xml:space="preserve">
          <source>The scalar/list context for the subroutine and for the right-hand side of assignment is determined as if the subroutine call is replaced by a scalar. For example, consider:</source>
          <target state="translated">子程序和赋值右侧的标量/列表上下文的确定,就像子程序调用被标量代替一样。例如,考虑:</target>
        </trans-unit>
        <trans-unit id="6c0b56c4841154473a184d3770a4651387051abe" translate="yes" xml:space="preserve">
          <source>The scalars for in-memory files are treated as octet strings: unless the file is being opened with truncation the scalar may not contain any code points over 0xFF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a59c0bcb531b15ec7601a5c46eda41a994dbd08" translate="yes" xml:space="preserve">
          <source>The scheme above allows interpretation of a wide range of dates, particularly if 4-digit years are used.</source>
          <target state="translated">上述方案允许对广泛的日期进行解释,特别是在使用4位数年份时。</target>
        </trans-unit>
        <trans-unit id="3fc0ce48ddfa00a9f249dd98501d09516efb57c0" translate="yes" xml:space="preserve">
          <source>The scheme from the uri (like 'file', 'http', etc)</source>
          <target state="translated">来自uri的方案(如'file'、'http'等)。</target>
        </trans-unit>
        <trans-unit id="73f8b37079fc67e2d535d7e2f263c71e4f89003f" translate="yes" xml:space="preserve">
          <source>The scope of the &lt;code&gt;package&lt;/code&gt; declaration is from the declaration itself through the end of the enclosing block, &lt;code&gt;eval&lt;/code&gt;, or file, whichever comes first (the same scope as the my(), our(), state(), and local() operators, and also the effect of the experimental &quot;reference aliasing,&quot; which may change), or until the next &lt;code&gt;package&lt;/code&gt; declaration. Unqualified dynamic identifiers will be in this namespace, except for those few identifiers that, if unqualified, default to the main package instead of the current one as described below. A &lt;code&gt;package&lt;/code&gt; statement affects only dynamic global symbols, including subroutine names, and variables you've used local() on, but</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49277474cf2c3fa04e4e431396fc13bca0311697" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 的作用域已将 &lt;code&gt;void&lt;/code&gt; warnings类别升级为致命错误，因此程序在遇到警告时会立即终止。</target>
        </trans-unit>
        <trans-unit id="3dbfebc1570cc3ef48ec03f51a2706061f280881" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;length&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f56ab0ebe6cfd894b851115a602d7f9f59ed1f" translate="yes" xml:space="preserve">
          <source>The script exits with zero if it thinks that everything worked, or a positive number if it thinks that something failed. Note, however, that in some cases it has to divine a failure by the output of things it does not control. For now, the exit codes are vague:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05dbbff48c1e514e522b4520f47f1f9d051aaac1" translate="yes" xml:space="preserve">
          <source>The script first verifies the function of the &lt;code&gt;Name&lt;/code&gt; class.</source>
          <target state="translated">该脚本首先验证 &lt;code&gt;Name&lt;/code&gt; 类的功能。</target>
        </trans-unit>
        <trans-unit id="bab70c074a8060d72a4a917d75cb758f3fdbebe9" translate="yes" xml:space="preserve">
          <source>The script is available from &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt;</source>
          <target state="translated">该脚本可从&lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877获得&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63775c5f58b6e8ca06f6c938a637be34887e3ffd" translate="yes" xml:space="preserve">
          <source>The script of a character is determined by the &lt;code&gt;Script_Extensions&lt;/code&gt; property as modified by UTS 39 (&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;), as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="496da3e22e1e3340caf097640e4353358048134f" translate="yes" xml:space="preserve">
          <source>The sdbm file format was designed for speed and convenience, not for portability or security. A maliciously crafted file might cause perl to crash or even expose a security vulnerability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3001b62b3120b5e625f2291ab08a912ad78b79" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt; ) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="translated">搜索引擎最初会将 &lt;code&gt;\D*&lt;/code&gt; 与&amp;ldquo; ABC&amp;rdquo; 匹配。然后它将尝试将 &lt;code&gt;(?!123)&lt;/code&gt; 与&amp;ldquo; 123&amp;rdquo; 匹配，但失败。但是，由于在正则表达式中使用了一个量词（ &lt;code&gt;\D*&lt;/code&gt; ），因此搜索引擎可以回溯和重试匹配项，从而希望匹配整个正则表达式。</target>
        </trans-unit>
        <trans-unit id="2dd6a24dc0c40439966d70dfb7faeebd4df837f5" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt;) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4989338d675235ed7afc62322345e940a111f8d8" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;//p&lt;/code&gt; , which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="translated">第二个优点是嵌入式修饰符（ &lt;code&gt;//p&lt;/code&gt; 除外，它修改了整个正则表达式）仅影响包含修饰符的组中的正则表达式。因此可以使用分组来定位修饰符的效果：</target>
        </trans-unit>
        <trans-unit id="344654afee619df186bd5aa49c470902771a22f7" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;/p&lt;/code&gt;, which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b19a99a58715509197b4fd3bb055452f4e6bb8" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt; . The final argument to &lt;code&gt;Newxc&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; , should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="translated">第二个和第三个参数 &lt;code&gt;number&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 指定应分配多少个指定类型的数据结构。参数 &lt;code&gt;type&lt;/code&gt; 传递给 &lt;code&gt;sizeof&lt;/code&gt; 。最后一个参数到 &lt;code&gt;Newxc&lt;/code&gt; ， &lt;code&gt;cast&lt;/code&gt; ，如果使用，应 &lt;code&gt;pointer&lt;/code&gt; 参数是从所述不同 &lt;code&gt;type&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="fea027e954f4ec8636256c0b94ce6f7f44ab6c0c" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt;. The final argument to &lt;code&gt;Newxc&lt;/code&gt;, &lt;code&gt;cast&lt;/code&gt;, should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7128198e8ffe79d47674dc971b588a148d07fe" translate="yes" xml:space="preserve">
          <source>The second and third highest priorities are to look in the parent of the current directory and a directory called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9372cc26ce11f225b78cb9001dded71987be37ab" translate="yes" xml:space="preserve">
          <source>The second argument ($eol) is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. Every occurrence of &quot;\n&quot; is replaced with this string, and it is also used for additional &quot;soft line breaks&quot; to ensure that no line end up longer than 76 characters. Pass it as &quot;\015\012&quot; to produce data suitable for external consumption. The string &quot;\r\n&quot; produces the same result on many platforms, but not all.</source>
          <target state="translated">第二个参数($eol)是要使用的行尾序列。它是可选的,默认为&quot;\n&quot;。每一次出现&quot;\/n &quot;都会被替换为这个字符串,它也用于额外的 &quot;软换行&quot;,以确保没有一行超过76个字符。将其传递为&quot;\015\012&quot;,以产生适合外部消费的数据。字符串&quot;\r\n &quot;在许多平台上产生相同的结果,但不是所有平台。</target>
        </trans-unit>
        <trans-unit id="691db7e7ba5b2eef57391203c3fd8b3455b42a9c" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">第二个参数可以是带有选项的哈希引用，该选项与传递给 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; 的参数相同。</target>
        </trans-unit>
        <trans-unit id="d9356e806771df85496c708eb7a467795a26a60f" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;read()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e7dec2e6aed1723cd212b39460017f8772c38b" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="translated">第二个参数是一个正则表达式。它可以作为正则表达式参考（即 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ）或（为了更好地与旧的perls兼容）作为看起来像正则表达式的字符串给出（当前不支持替代定界符）：</target>
        </trans-unit>
        <trans-unit id="851ff1e7afee5d9f26155a298af3215064fbafc8" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;qr//&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9cd8da657568e7bbba17b34028b2178bd5abb57" translate="yes" xml:space="preserve">
          <source>The second argument is considered a regex if it is either a regex object or a string that looks like a regex. Regex objects are constructed with the qr// operator in recent versions of perl. A string is considered to look like a regex if its first and last characters are &quot;/&quot;, or if the first character is &quot;m&quot; and its second and last characters are both the same non-alphanumeric non-whitespace character. These regexp</source>
          <target state="translated">第二个参数如果是一个regex对象或一个看起来像regex的字符串,则被认为是一个regex。在最近的perl版本中,Regex对象是用qr//运算符构造的。如果一个字符串的第一个和最后一个字符是&quot;/&quot;,或者第一个字符是 &quot;m&quot;,第二个和最后一个字符都是相同的非字母数字非空格字符,那么这个字符串就被认为是一个regex对象。这些regexp</target>
        </trans-unit>
        <trans-unit id="ffe3c605f37afcab4c8601d801b588d13a566637" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in the case of a unary operator.</source>
          <target state="translated">第二个参数是另一个操作数，如果是一元运算符，则为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4f1fa234686b49496c4cac025cf1d9ea03f5c52" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;undef&lt;/code&gt; in the case of a unary operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f0c3f0ec389d3780a678c2cc02cdb14b452933" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can compress using &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;bzip2&lt;/code&gt; or &lt;code&gt;xz&lt;/code&gt;. If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99835175d57940dd272e3dc71fc2882ef5b0d66" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can either compress using &lt;code&gt;gzip&lt;/code&gt; or &lt;code&gt;bzip2&lt;/code&gt; . If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="translated">第二个参数用于指示压缩。您可以使用 &lt;code&gt;gzip&lt;/code&gt; 或 &lt;code&gt;bzip2&lt;/code&gt; 进行压缩。如果您传递数字，则假定它是 &lt;code&gt;gzip&lt;/code&gt; 压缩级别（介于1和9之间），但最好使用常量：</target>
        </trans-unit>
        <trans-unit id="a0c730e612ef3dd802df3a15f52c50f234217ccd" translate="yes" xml:space="preserve">
          <source>The second argument may be considered optional, but remains for backwards compatibility. Archive::Tar now looks at the file magic to determine what class should be used to open the file and will transparently Do The Right Thing.</source>
          <target state="translated">第二个参数可能被认为是可选的,但为了向后的兼容性而保留。Archive::Tar 现在会根据文件的魔力来决定应该用什么类来打开文件,并且会透明地做正确的事情。</target>
        </trans-unit>
        <trans-unit id="fc50752077e3b12e3cd10f78b06bb8c9b8f956b4" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt; 's. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="translated">第二个参数指向包含 &lt;code&gt;num&lt;/code&gt; &lt;code&gt;SV*&lt;/code&gt; 的数组。创建AV后，可以根据需要销毁SV。</target>
        </trans-unit>
        <trans-unit id="51ba89f615646daa0a3b0a56db80558ec7c78c30" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt;'s. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8c79378da8449512fbe01727cd6ac969d7ae7c" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;&quot;-|&quot;&lt;/code&gt;, makes it a read-pipe into a separate program, rather than an ordinary filehandle into a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241df4a30fc4febc2cd9ef098abdb1cdbc871750" translate="yes" xml:space="preserve">
          <source>The second call to hex() will warn about a non-portable constant.</source>
          <target state="translated">第二个对hex()的调用将对一个非可移植常量发出警告。</target>
        </trans-unit>
        <trans-unit id="52f5fb6e434df4bf3ba2648b67634f2b93cdc1b5" translate="yes" xml:space="preserve">
          <source>The second call-back is optional if the call back is registered prior to the call to $term-&amp;gt;readline.</source>
          <target state="translated">如果在调用$ term-&amp;gt; readline之前注册了回调，则第二个回调是可选的。</target>
        </trans-unit>
        <trans-unit id="104d457b0581ca75e5a33a6cc382aa3d75495d54" translate="yes" xml:space="preserve">
          <source>The second call-back registered is the call back for registration. The input filehandle (often STDIN, but not necessarily) will be passed in.</source>
          <target state="translated">注册的第二个回调是注册的回调。输入的文件柄(通常是STDIN,但不一定)将被传递进来。</target>
        </trans-unit>
        <trans-unit id="8a9a833fe2a8c9894ba16f1673e04b6df3b8c78c" translate="yes" xml:space="preserve">
          <source>The second case often turns out to have identical results to the first case, albeit only by accident.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2db73bb8959c9504bedfb024b1f19ea96655cb" translate="yes" xml:space="preserve">
          <source>The second class of portable ranges is invoked when one or both of the range's end points are expressed as &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9c1d1eb4a7fe50e319b8d6cb4e544cda2638c9" translate="yes" xml:space="preserve">
          <source>The second column is the return type, the third column the name. Columns after that are the arguments. The first column is a set of flags:</source>
          <target state="translated">第二列是返回类型,第三列是名称。之后的列是参数。第一列是一组标志。</target>
        </trans-unit>
        <trans-unit id="833ac465c5bc76260e3533a8f5293c1a6cc4e353" translate="yes" xml:space="preserve">
          <source>The second example in the synopsis does something equivalent to this:</source>
          <target state="translated">概要中的第二个例子做的事情与此相当。</target>
        </trans-unit>
        <trans-unit id="f7f8f6797190b2ee94971db1ba0f6aeb4ac8dc06" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt; , and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt; , or are shorter than 5 chars.</source>
          <target state="translated">第二个示例打印名称为 &lt;code&gt;foo&lt;/code&gt; 的条目，以及名称结尾为 &lt;code&gt;bar&lt;/code&gt; 或少于5个字符的条目。</target>
        </trans-unit>
        <trans-unit id="ff08cd3ad532db8c5d5dd8a872abb6c4f322ba5e" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt;, and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt;, or are shorter than 5 chars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7ec951497cf0073403b17626a675e036c31257" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt; .</source>
          <target state="translated">如果留在输入缓冲区中的所有数据的第二出口点的测试， &lt;code&gt;$input&lt;/code&gt; -记得 &lt;code&gt;ConsumeInput&lt;/code&gt; 选项时，将自动启用 &lt;code&gt;LimitOutput&lt;/code&gt; 使用。输入缓冲区用完后，外部循环可以再次运行并覆盖现在为空的 &lt;code&gt;$input&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cea8aa29f5d1b03f7b0a4cb746f125b76bdff01" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dba4d9ed358b9b1b26a10b82c95880d18ef1ec5" translate="yes" xml:space="preserve">
          <source>The second form allows the filter to hold state information using a closure, thus:</source>
          <target state="translated">第二种形式允许过滤器使用闭合来保存状态信息,因此。</target>
        </trans-unit>
        <trans-unit id="204d9fcc358796976a40cb62f3873844790ea690" translate="yes" xml:space="preserve">
          <source>The second form is strongly discouraged, because it breaks the ability of a subclass to reuse the parent's constructor, but you may still run across it in existing code.</source>
          <target state="translated">第二种形式是不被鼓励的,因为它破坏了子类重用父类构造函数的能力,但你仍然可能在现有的代码中遇到它。</target>
        </trans-unit>
        <trans-unit id="0819d819ae212b8e1bcdb9b5bc6d671458a8958e" translate="yes" xml:space="preserve">
          <source>The second form limits or expands the output with shell globbing as in the following examples:</source>
          <target state="translated">第二种形式通过shell globbing限制或扩展输出,如下面的例子。</target>
        </trans-unit>
        <trans-unit id="c407c89499b72c27a5a072472ddedf2b307bb4f0" translate="yes" xml:space="preserve">
          <source>The second form takes an ASCII string of &quot;0&quot; and &quot;1&quot; characters as its argument. It's equivalent to</source>
          <target state="translated">第二种形式以 &quot;0 &quot;和 &quot;1 &quot;字符的ASCII字符串作为参数。它相当于</target>
        </trans-unit>
        <trans-unit id="653b770c920437547bfd253af4e36f98e0dbfce5" translate="yes" xml:space="preserve">
          <source>The second form, for convenience, simply calls the &lt;code&gt;new&lt;/code&gt; method on its arguments before dumping the object immediately.</source>
          <target state="translated">为了方便起见，第二种形式只是在立即转储对象之前对其参数调用 &lt;code&gt;new&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="dc711c3d286876153bcbf61db541b42c9a9350fc" translate="yes" xml:space="preserve">
          <source>The second gives data on how many keys are at each depth in the chain, and gives an idea of how much work a fetch *hit* will take. The performance for an update or delete of an item in the hash is equivalent to this case.</source>
          <target state="translated">第二个给出了链中每个深度有多少个键的数据,并给出了一个取*命中需要多少工作的概念。在哈希中更新或删除一个项目的性能相当于这种情况。</target>
        </trans-unit>
        <trans-unit id="5995436678b8ce31e572994a72a1c15e94c7f93e" translate="yes" xml:space="preserve">
          <source>The second is</source>
          <target state="translated">二是</target>
        </trans-unit>
        <trans-unit id="3d4dc00d964c0b0076b393752a2dfc8106f40760" translate="yes" xml:space="preserve">
          <source>The second is a question mark &lt;code&gt;?&lt;/code&gt; to match any single character. The third specifies a specific set of characters.</source>
          <target state="translated">第二个是问号 &lt;code&gt;?&lt;/code&gt; 匹配任何单个字符。第三个指定一组特定的字符。</target>
        </trans-unit>
        <trans-unit id="86badbc4e990f49a4a0e0309ce3e34af3acb8215" translate="yes" xml:space="preserve">
          <source>The second is, in short, more readable. In particular, it's obvious that the number of parameters you're feeding to that phrase (two) is the number of parameters that it</source>
          <target state="translated">第二种,简而言之,更有可读性。特别是,很明显,你给那个短语输入的参数数(两个)就是它的参数数。</target>
        </trans-unit>
        <trans-unit id="7d7dcadbcc9256c73e53e45ca4167a8f00171936" translate="yes" xml:space="preserve">
          <source>The second method both creates the AV and initially populates it with SVs:</source>
          <target state="translated">第二种方法既创建了AV,又初步填充了SV。</target>
        </trans-unit>
        <trans-unit id="5a04571edd1042cba183eaac5eb081daffd5163c" translate="yes" xml:space="preserve">
          <source>The second method divides up the generated code into</source>
          <target state="translated">第二种方法是将生成的代码划分为</target>
        </trans-unit>
        <trans-unit id="30b5717864fa144252bae28ce0e68e9e2886c509" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; , which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="translated">第二个新的显示参数是 &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; ，可以将其设置为true或false，默认值为true。请参阅上一节了解这意味着什么。</target>
        </trans-unit>
        <trans-unit id="a8d5bb3a74ae14b7cc834ba7cb47fc90749857de" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt;, which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105094491ac9a931737afcae5ec00cc67ecea83f" translate="yes" xml:space="preserve">
          <source>The second option is to explicitly instruct Configure to detect the newer Berkeley DB installation, by supplying the right directories with &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; and &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt;&lt;b&gt;and&lt;/b&gt; before running &quot;make test&quot; setting your LD_LIBRARY_PATH to</source>
          <target state="translated">第二个选项是通过向正确的目录提供 &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; 和 &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt; &lt;b&gt;并&lt;/b&gt;在运行&amp;ldquo; make test&amp;rdquo;之前将LD_LIBRARY_PATH设置为，以明确指示Configure来检测更新的Berkeley DB安装。</target>
        </trans-unit>
        <trans-unit id="b104d0289f2a63192d73ded4515b99bcffef5da9" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt; , is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt; , so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="translated">第二个参数 &lt;code&gt;$mode&lt;/code&gt; 用于指定是打开文件进行读取还是写入，并在写入时选择指定压缩级别和压缩策略。 &lt;code&gt;$mode&lt;/code&gt; 参数的格式类似于'C'函数 &lt;code&gt;fopen&lt;/code&gt; 的mode参数，因此&amp;ldquo; rb&amp;rdquo;用于打开以供读取，&amp;ldquo; wb&amp;rdquo;用于写入，而&amp;ldquo; ab&amp;rdquo;用于附加（在末尾写入）文件）。</target>
        </trans-unit>
        <trans-unit id="40f3477c6f4b0d20844832da1b4bf48b8115879e" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt;, is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt;, so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3411b2ade45037b8736308e07cf74ad1d92df3ee" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;'^'&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;'$'&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eae2bfeb40a7aaf7114e7fd8256ee81caccdbd3" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;^&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;$&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="translated">第二个正则表达式不匹配，因为 &lt;code&gt;^&lt;/code&gt; 限制了 &lt;code&gt;keeper&lt;/code&gt; 只能在字符串的开头进行匹配，但是 &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; keeper在中间开始。第三个正则表达式确实匹配，因为 &lt;code&gt;$&lt;/code&gt; 约束 &lt;code&gt;keeper&lt;/code&gt; 仅在字符串的末尾匹配。</target>
        </trans-unit>
        <trans-unit id="733da91fc44d8ab5e75ced78a6cc48a582c7d7b0" translate="yes" xml:space="preserve">
          <source>The second returned item and &lt;code&gt;$!&lt;/code&gt; can be used to check for valid input:</source>
          <target state="translated">第二个返回的项目和 &lt;code&gt;$!&lt;/code&gt; 可用于检查有效输入：</target>
        </trans-unit>
        <trans-unit id="2c1496bf9c5a01143ce96b1f9c010fe32e40f772" translate="yes" xml:space="preserve">
          <source>The second sentence is wrong. In actual fact bval will only default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when the openinfo parameter in dbopen is NULL. If a non-NULL openinfo parameter is used at all, the value that happens to be in bval will be used. That means you always have to specify bval when making use of any of the options in the openinfo parameter. This documentation error will be fixed in the next release of Berkeley DB.</source>
          <target state="translated">第二句话是错误的。实际上，只有当dbopen中的openinfo参数为NULL时，bval 才会默认为 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。如果完全使用了非NULL的openinfo参数，则将使用恰好在bval中的值。这意味着在使用openinfo参数中的任何选项时，您始终必须指定bval。此文档错误将在下一版Berkeley DB中修复。</target>
        </trans-unit>
        <trans-unit id="aaad1f57fe700f2a9b2dd58ec708684feaf8128f" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a lexical subroutine that has gone out of scope, for example,</source>
          <target state="translated">第二种情况是由eval访问一个已经超出范围的词汇子程序造成的,例如。</target>
        </trans-unit>
        <trans-unit id="9ade278ee614d31e9547b1781d35dc6ff90a8980" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a variable that has gone out of scope, for example,</source>
          <target state="translated">第二种情况是由eval访问一个已经超出范围的变量引起的,例如。</target>
        </trans-unit>
        <trans-unit id="b47d8c8a23f4e0d763e99999d69c0c5eb0cb3a92" translate="yes" xml:space="preserve">
          <source>The second style of bundling lifts this restriction. It can be enabled with:</source>
          <target state="translated">第二种捆绑方式解除了这一限制。它可以通过以下方式启用:</target>
        </trans-unit>
        <trans-unit id="ab8073e684e0f88cfe3fd5f9716b9c696bbef27e" translate="yes" xml:space="preserve">
          <source>The second value to be substituted in the output string (usually the row in cursor addressing capabilities)</source>
          <target state="translated">在输出字符串中替换的第二个值(通常是游标寻址能力中的行)。</target>
        </trans-unit>
        <trans-unit id="72ec171fc6e9d8dd4e1917d8ba0d47a2f390d23d" translate="yes" xml:space="preserve">
          <source>The second, more efficient way is to use the following template for your Foo.xs:</source>
          <target state="translated">第二种更有效的方法是为你的Foo.xs使用以下模板。</target>
        </trans-unit>
        <trans-unit id="ea8fa202ee5b9df3dfb7272625ecae21681f7d7d" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="translated">该部分（旧版本中又称为&amp;ldquo;项目&amp;rdquo;），如果没有则为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。例如，在&amp;ldquo; L &amp;lt;Getopt :: Std / DESCRIPTION&amp;gt;&amp;rdquo;中，&amp;ldquo; DESCRIPTION&amp;rdquo;是该部分。 （请注意，这与联机帮助页部分不同，如&amp;ldquo; man 5 crontab&amp;rdquo;中的&amp;ldquo; 5&amp;rdquo;。Pod意义上的&amp;ldquo; Section Foo&amp;rdquo;是指标题或项目所引入的文本部分，其文字为&amp;ldquo; Foo&amp;rdquo; &amp;ldquo;。）</target>
        </trans-unit>
        <trans-unit id="cd89b9d74f7d870dca4a759e8ab8f51f0dc1f9b2" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;undef&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592a5f44132e9a3aa5e9a10cfa07afacf196746b" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;&quot;safe_level&quot;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5faf936bbea0ef6b4af3b53c6607ced9b3cdea" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt; for more information.</source>
          <target state="translated">强调临时文件创建的安全性，以便将文件句柄和文件名一起返回。这有助于确保在检查文件存在与打开之间通过另一个过程创建临时文件的情况下不会发生竞争状况。提供了附加的安全级别，例如，检查是否在世界可写目录上设置了粘性位。有关更多信息，请参见&lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02ef1170c6c4276366f2c9602e48f300db3d9145" translate="yes" xml:space="preserve">
          <source>The seemingly equivalent construct in Perl, &lt;code&gt;$$aref[$i]&lt;/code&gt; first does the deref of $aref, making it take $aref as a reference to an array, and then dereference that, and finally tell you the</source>
          <target state="translated">在Perl中看似等效的构造函数 &lt;code&gt;$$aref[$i]&lt;/code&gt; 首先对$ aref进行解引用，使它以$ aref作为对数组的引用，然后对其进行解引用，最后告诉您</target>
        </trans-unit>
        <trans-unit id="5ae490ef8bae426993ed6639b51d33e36f67a5f8" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;a href=&quot;setitimer(2)&quot;&gt;&lt;code&gt;setitimer(2)&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3a7adddb69f2204deb61bd662439aeebd384d4" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;code&gt;setitimer()&lt;/code&gt; documentation.</source>
          <target state="translated">多线程程序的间隔计时器的语义是特定于系统的，某些系统可能支持其他间隔计时器。例如，未指定哪个线程获取信号。请参阅您的 &lt;code&gt;setitimer()&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="65ef3e0624e679879b7ce02cec7d6809073f165d" translate="yes" xml:space="preserve">
          <source>The sense of the match can be reversed by using &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">可以使用 &lt;code&gt;!~&lt;/code&gt; 运算符反转匹配的含义：</target>
        </trans-unit>
        <trans-unit id="571f2b8a003669439aca5df927f2bc3b59493e17" translate="yes" xml:space="preserve">
          <source>The sequence &lt;code&gt;\b&lt;/code&gt; is special inside a bracketed character class. While outside the character class, &lt;code&gt;\b&lt;/code&gt; is an assertion indicating a point that does not have either two word characters or two non-word characters on either side, inside a bracketed character class, &lt;code&gt;\b&lt;/code&gt; matches a backspace character.</source>
          <target state="translated">序列 &lt;code&gt;\b&lt;/code&gt; 在带括号的字符类中是特殊的。在字符类之外， &lt;code&gt;\b&lt;/code&gt; 是一个断言，指示在括号字符类内，点的任一侧都没有两个单词字符或两个非单词字符的点， &lt;code&gt;\b&lt;/code&gt; 匹配一个退格字符。</target>
        </trans-unit>
        <trans-unit id="2e682f0e9f09d4fac48ccdb6cb912af9bfeddf7f" translate="yes" xml:space="preserve">
          <source>The sequence can also be extended to negative index n using the re-arranged recurrence relation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b263532d25e62f98e230387976bd3e1a8c5cb59" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP's next OP.</source>
          <target state="translated">OP的下一个OP的序列号。</target>
        </trans-unit>
        <trans-unit id="b45bacc53a5ed1f0afceaa4ff3006834edab117c" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP, or a hyphen if it doesn't have one.</source>
          <target state="translated">上位机的序列号,如果没有序列号,则为连字符。</target>
        </trans-unit>
        <trans-unit id="4f0a83d5889e74bacf92e475321b6ad01721beb5" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP. Note that this is a sequence number generated by B::Concise.</source>
          <target state="translated">OP的序列号。注意,这是一个由 B::Concise 生成的序列号。</target>
        </trans-unit>
        <trans-unit id="a1e46d38c7dda11bf03f174aca8ec057ac38a288" translate="yes" xml:space="preserve">
          <source>The sequence number of this partition. Partitions are numbered starting as &lt;code&gt;1&lt;/code&gt; [with &quot;partition 0&quot; meaning the entire disk]. Sometimes this field may be &lt;code&gt;0&lt;/code&gt; and you'll have to infer the partition sequence number from how many partitions precede it on the disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10dc949f49eb3d32cdb0534e93e9f1fddb641e8" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="translated">&lt;code&gt;\a&lt;/code&gt; ， &lt;code&gt;\c&lt;/code&gt; ， &lt;code&gt;\e&lt;/code&gt; ， &lt;code&gt;\f&lt;/code&gt; ， &lt;code&gt;\n&lt;/code&gt; ， &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; ， &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; ， &lt;code&gt;\r&lt;/code&gt; ， &lt;code&gt;\t&lt;/code&gt; 和 &lt;code&gt;\x&lt;/code&gt; 序列也很特殊，它们的含义相同在方括号类之外做。</target>
        </trans-unit>
        <trans-unit id="90a0a5f9a35ae3ea0a297068e4b1bab795815fcf" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\c&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899a56478deaf614d4bf9d04537d9557616e32cf" translate="yes" xml:space="preserve">
          <source>The serialized structure will include a &lt;code&gt;x_serialization_backend&lt;/code&gt; entry giving the package and version used to serialize. Any existing key in the given &lt;code&gt;$meta&lt;/code&gt; object will be clobbered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d53186f69243fe4e7fc81db07bccfc51f977e9e" translate="yes" xml:space="preserve">
          <source>The serializing hook, called on the object during serialization. It can be inherited, or defined in the class itself, like any other method.</source>
          <target state="translated">序列化钩子,在序列化过程中对对象进行调用。它可以被继承,也可以像其他方法一样在类本身中定义。</target>
        </trans-unit>
        <trans-unit id="4e9ebcecc7a860f145ea8f9108514a4fa8316dfb" translate="yes" xml:space="preserve">
          <source>The service name supplied to getaddrinfo() is not available for the socket type given in the $hints.</source>
          <target state="translated">提供给getaddrinfo()的服务名对于$hints中给出的socket类型是不可用的。</target>
        </trans-unit>
        <trans-unit id="ba23ccf9d34101355ab34a3727e24a0a0f7b250a" translate="yes" xml:space="preserve">
          <source>The services a piece of code promises to provide forever, in contrast to its &lt;b&gt;implementation&lt;/b&gt;, which it should feel free to change whenever it likes.</source>
          <target state="translated">与它的&lt;b&gt;实现&lt;/b&gt;相反，一段代码承诺可以永远提供这些服务，并且可以随时随意更改。</target>
        </trans-unit>
        <trans-unit id="32c78a4d560dbf4474d5f3b5cef5e0e631bdf4c5" translate="yes" xml:space="preserve">
          <source>The set is specified as a list of characters, or as a range of characters where the beginning and end of the range are separated by a minus (or dash) character, or as any combination of lists and ranges. The dash can also be included in the set as a character it if is the beginning or end of the set. This set is enclosed in square brackets. The close square bracket &lt;code&gt;]&lt;/code&gt; may be used in a set if it is the first character in the set.</source>
          <target state="translated">该集合被指定为一个字符列表，或一个字符范围，其中范围的开始和结尾用减号（或破折号）分隔，或者指定为列表和范围的任何组合。破折号也可以作为字符包含在集合中，如果它是集合的开始或结尾。这套放在方括号中。紧密括号 &lt;code&gt;]&lt;/code&gt; 可以在一组中使用，如果它是该组中的第一个字符。</target>
        </trans-unit>
        <trans-unit id="271c11282a628a982454242ec29109ed2ea23f1d" translate="yes" xml:space="preserve">
          <source>The set of characters that are deemed whitespace are those that Unicode calls &quot;Pattern White Space&quot;, namely:</source>
          <target state="translated">被认为是空白的一组字符是Unicode称为 &quot;模式白色空间 &quot;的字符,即:</target>
        </trans-unit>
        <trans-unit id="5e7d4549f7a90817f3e92cc9271f629864ca580a" translate="yes" xml:space="preserve">
          <source>The setlocale function</source>
          <target state="translated">setlocale函数</target>
        </trans-unit>
        <trans-unit id="6cd53441a7a72535c4ff8e055f31a3a3fc042379" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="translated">子例程属性的设置在编译时发生。 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明中的变量属性也将在编译时应用。但是， &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 变量会在运行时应用其属性。这意味着您必须</target>
        </trans-unit>
        <trans-unit id="229ecae54cd846eee20b1cbee543175ec9cd197e" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;our&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;my&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1edc3ed4db36281da6290a4a02b6bb1d2f2a9a" translate="yes" xml:space="preserve">
          <source>The seven routines are:</source>
          <target state="translated">这七项常规是:</target>
        </trans-unit>
        <trans-unit id="7db711982141cfb12b9e3602192ccba86ac4d921" translate="yes" xml:space="preserve">
          <source>The sheet</source>
          <target state="translated">该表</target>
        </trans-unit>
        <trans-unit id="67100f7fba2fe91ac3115331e86988966a0f9ad9" translate="yes" xml:space="preserve">
          <source>The shell offers to run in</source>
          <target state="translated">外壳提供运行在</target>
        </trans-unit>
        <trans-unit id="d2a4c575dba49342e824220d900f0c783780f4b9" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="translated">Shell的 &lt;code&gt;test&lt;/code&gt; 使用&amp;ldquo; =&amp;rdquo;，&amp;ldquo;！=&amp;rdquo;，&amp;ldquo; &amp;lt;&amp;rdquo;等进行字符串比较，并使用&amp;ldquo; -eq&amp;rdquo;，&amp;ldquo;-ne&amp;rdquo;，&amp;ldquo;-lt&amp;rdquo;等进行数字比较。这与Perl相反，后者使用 &lt;code&gt;eq&lt;/code&gt; ， &lt;code&gt;ne&lt;/code&gt; ， &lt;code&gt;lt&lt;/code&gt; 进行字符串比较，并使用 &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; 等进行数字比较。</target>
        </trans-unit>
        <trans-unit id="a4421a2ab5bd2e622c5d0a683eecbd4f08bbe24b" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe36cec28443e99377776c6efc56682531e56f06" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; ) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="translated">简短的答案是，默认情况下，Perl 仅根据字符的代码点比较等效项（ &lt;code&gt;eq&lt;/code&gt; ， &lt;code&gt;ne&lt;/code&gt; ）。在上述情况下，答案为否（因为0x00C1！= 0x0041）。但有时，任何大写字母A都应视为相等，甚至在任何情况下都应视为A。</target>
        </trans-unit>
        <trans-unit id="84602cf60297d60acdefd80efdd1c60462b73b9b" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b57501930c25501b20f82b569d1ea16761a497e6" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; ) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; .</source>
          <target state="translated">简短的答案是，默认情况下，Perl 仅根据字符的代码点比较字符串（ &lt;code&gt;lt&lt;/code&gt; ， &lt;code&gt;le&lt;/code&gt; ， &lt;code&gt;cmp&lt;/code&gt; ， &lt;code&gt;ge&lt;/code&gt; ， &lt;code&gt;gt&lt;/code&gt; ）。在上述情况下，答案是&amp;ldquo;之后&amp;rdquo;，因为 &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d67ccb6666f81cda59931fcf7ad032ead024bc41" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt;, &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace0e0cec639bb708cb2cf532e982971dd3748da" translate="yes" xml:space="preserve">
          <source>The short name of the general category of</source>
          <target state="translated">的总称。</target>
        </trans-unit>
        <trans-unit id="02c6ec10d109a1b719286e329258adf56d502cef" translate="yes" xml:space="preserve">
          <source>The short story</source>
          <target state="translated">小故事</target>
        </trans-unit>
        <trans-unit id="eb4d2d85d25fb4d71e2225f2e7a3eb6515112128" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="translated">简而言之，您可能应该只在标量或函数上使用定义，而不能在集合（数组和哈希）上使用。有关更多详细信息，请参见Perl 5.004版本或更高版本中的&lt;a href=&quot;functions/defined&quot;&gt;定义&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53f5dab7a291daa9043df504d583260ae569f535" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;perlfunc#defined&quot;&gt;&quot;defined&quot; in perlfunc&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be047f864fccecb4801e21c3ca26d33faa969dbf" translate="yes" xml:space="preserve">
          <source>The sign &lt;code&gt;/^[+-]$/&lt;/code&gt; is stored separately. The string 'NaN' is used to represent the result when input arguments are not numbers, as well as the result of dividing by zero.</source>
          <target state="translated">符号 &lt;code&gt;/^[+-]$/&lt;/code&gt; 是分开存储的。字符串'NaN'用于表示输入参数不是数字时的结果以及除以零的结果。</target>
        </trans-unit>
        <trans-unit id="5d535efa9748a7b51984807c3b0e47062fc14e19" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf' and stored separately. You can access it with the sign() method.</source>
          <target state="translated">符号是'+'、'-'、'NaN'、'+inf'或'-inf',并单独存储。你可以用sign()方法访问它。</target>
        </trans-unit>
        <trans-unit id="be8bba598ba0bfbad37b038eb92c99bbb5b687ac" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'.</source>
          <target state="translated">符号是'+'、'-'、'NaN'、'+inf'或'-inf'。</target>
        </trans-unit>
        <trans-unit id="32ee9fc8e75a1189426734a34b70183ae0bf5e08" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'. You can access it with the sign() method.</source>
          <target state="translated">符号是'+'、'-'、'NaN'、'+inf'或'-inf'。你可以通过sign()方法访问它。</target>
        </trans-unit>
        <trans-unit id="11646904ceab245420048654e9bde4a41bb7ec59" translate="yes" xml:space="preserve">
          <source>The signal Exec signal mask</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104ebb4db613ce634a3b75383995774c2e797f04" translate="yes" xml:space="preserve">
          <source>The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d781ab42c79199084a9c305d1ab2ed6d80e787b" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code, but when using a signature, the signature is a parenthesised list that goes immediately before the block, after any name or attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68142e064ec1d6e704c7c13d44f8b02e77345ce" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code. When using a signature, the signature is a parenthesised list that goes immediately after the subroutine name. The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="translated">签名是子程序主体的一部分。通常一个子程序的主体是一个简单的括号内的代码块。当使用签名时,签名是一个紧跟在子程序名称之后的括号列表。签名声明了该代码块范围内的词汇变量。当子程序被调用时,签名会首先控制该子程序。它从传递的参数列表中填充签名变量。如果参数列表不符合签名的要求,那么它将抛出一个异常。当签名处理完成后,控制权就会传递给块。</target>
        </trans-unit>
        <trans-unit id="8bf79dd34df166da1a0a362d8a7c14bc52139481" translate="yes" xml:space="preserve">
          <source>The signatures feature is experimental</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf9d6090863be01051258238bf3ef2c8b46c7c9" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched as-is by putting a backslash before it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2444d6c2a6baf7e1580c4abcb9b61735a0532f35" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">每一个字的意义将在本教程的其他部分解释,但现在,只需知道一个元字符可以通过在它前面加上反斜杠来匹配。</target>
        </trans-unit>
        <trans-unit id="d05188639d7fd13d368b039de9eab91f22380450" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt; , matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; . That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="translated">类似命名的属性 &lt;code&gt;\p{Punct}&lt;/code&gt; 匹配ASCII范围内的一个稍有不同的集合，即 &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; 。也就是说，它缺少9个字符 &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; ，这是因为Unicode将POSIX认为是标点的东西分为两类，标点符号和符号。</target>
        </trans-unit>
        <trans-unit id="8cd091ac264b3ba5cf264f4cd380086afff2aabf" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt;, matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt;. That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt;. This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a851643ae5a58ccc6f3ce68bfdab3a7ef68d1794" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt; , execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="translated">简单的规则是：自动加载非方法时，继承将不起作用。对旧代码的简单修复方法是：在以前依赖于从名为 &lt;code&gt;BaseClass&lt;/code&gt; 的基类继承非方法的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 的任何模块中，在启动过程中执行 &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="145065cb1f22a69e2ed6682015cb7947554b75d7" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt;, execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5af89b6d15a00a979315dfddae0b5f323e4af12" translate="yes" xml:space="preserve">
          <source>The simple rule to remember, if you want to match a literal &lt;code&gt;{&lt;/code&gt; character (U+007B &lt;code&gt;LEFT CURLY BRACKET&lt;/code&gt;) in a regular expression pattern, is to escape each literal instance of it in some way. Generally easiest is to precede it with a backslash, like &lt;code&gt;\{&lt;/code&gt; or enclose it in square brackets (&lt;code&gt;[{]&lt;/code&gt;). If the pattern delimiters are also braces, any matching right brace (&lt;code&gt;}&lt;/code&gt;) should also be escaped to avoid confusing the parser, for example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d909120b343bfa9af89dc978321448d395292c" translate="yes" xml:space="preserve">
          <source>The simple stdio implementation creates the files</source>
          <target state="translated">简单的stdio实现会创建文件</target>
        </trans-unit>
        <trans-unit id="f2a9e9b7a3c97685eea0b1595b9417bb605f6809" translate="yes" xml:space="preserve">
          <source>The simplest XSUBs consist of 3 parts: a description of the return value, the name of the XSUB routine and the names of its arguments, and a description of types or formats of the arguments.</source>
          <target state="translated">最简单的XSUB包括3个部分:返回值的描述,XSUB例程的名称和参数的名称,以及参数的类型或格式的描述。</target>
        </trans-unit>
        <trans-unit id="5cfe5e43e01ddc5838feef9195e0126bb74ada96" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt; . Thus the integer regexp is</source>
          <target state="translated">最简单的情况是整数。这些由数字序列组成，前面有一个可选的符号。我们可以用 &lt;code&gt;\d+&lt;/code&gt; 表示的数字和符号可以与 &lt;code&gt;[+-]&lt;/code&gt; 匹配。因此，整数regexp为</target>
        </trans-unit>
        <trans-unit id="16ed7663dd31b0d719b95952e4dbcc002ac1e075" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt;. Thus the integer regexp is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ce4a00629ba2eb87550ae04e313683cd18e39d" translate="yes" xml:space="preserve">
          <source>The simplest format for a Version Range is just the version number itself, e.g. &lt;code&gt;2.4&lt;/code&gt;. This means that &lt;b&gt;at least&lt;/b&gt; version 2.4 must be present. To indicate that &lt;b&gt;any&lt;/b&gt; version of a prerequisite is okay, even if the prerequisite doesn't define a version at all, use the version &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205579583087d3f83514fed292a979acc1fd2056" translate="yes" xml:space="preserve">
          <source>The simplest format for a version specification is just the version number itself, e.g. &lt;code&gt;2.4&lt;/code&gt;. This means that &lt;b&gt;at least&lt;/b&gt; version 2.4 must be present. To indicate that &lt;b&gt;any&lt;/b&gt; version of a prerequisite is okay, even if the prerequisite doesn't define a version at all, use the version &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f647a57152f0376dead3744742f9e10945d73a" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt; .</source>
          <target state="translated">最简单的方法使用 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 函数。它可以在左侧或右侧填充空格，在左侧填充零，并且不会截断结果。该 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 功能只能用空格右边垫字符串，它会结果截到的最大长度 &lt;code&gt;$pad_len&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60ef9faadf39e8b6092ce866661076ad7721c8c1" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;sprintf&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;pack&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3e208a9819c2ed872df1040ec4eed39730cc50" translate="yes" xml:space="preserve">
          <source>The simplest regex is simply a word, or more generally, a string of characters. A regex consisting of a word matches any string that contains that word:</source>
          <target state="translated">最简单的regex只是一个单词,或者更一般的是一串字符。由一个词组成的regex可以匹配任何包含该词的字符串。</target>
        </trans-unit>
        <trans-unit id="e7349953e0f225a36578668e9ad5be25a2093d5b" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of a word matches any string that contains that word:</source>
          <target state="translated">最简单的regexp就是一个单词,或者更普遍的是一个字符串。由一个词组成的regexp可以匹配任何包含该词的字符串。</target>
        </trans-unit>
        <trans-unit id="0eaf5ad324e3121e2a83d8b08987e28055dbf879" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of just a word matches any string that contains that word:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93ecdae42936826d9c1b25b5229a95d439104b0" translate="yes" xml:space="preserve">
          <source>The simplest style of bundling can be enabled with:</source>
          <target state="translated">最简单的捆绑方式可以通过以下方式启用。</target>
        </trans-unit>
        <trans-unit id="7cd479644d912e323fa369ec3403c930944ff04b" translate="yes" xml:space="preserve">
          <source>The simplest two-level data structure to build in Perl is an array of arrays, sometimes casually called a list of lists. It's reasonably easy to understand, and almost everything that applies here will also be applicable later on with the fancier data structures.</source>
          <target state="translated">在Perl中构建的最简单的两级数据结构是一个数组,有时也会被随便称为列表的列表。它相当容易理解,几乎这里适用的所有内容也都适用于后面的更高级的数据结构。</target>
        </trans-unit>
        <trans-unit id="6e9b91e3cec9f10bb3ce35088b75f0be6c8e9b0d" translate="yes" xml:space="preserve">
          <source>The simplest type of op structure is &lt;code&gt;OP&lt;/code&gt; : this has no children. Unary operators, &lt;code&gt;UNOP&lt;/code&gt; s, have one child, and this is pointed to by the &lt;code&gt;op_first&lt;/code&gt; field. Binary operators (&lt;code&gt;BINOP&lt;/code&gt; s) have not only an &lt;code&gt;op_first&lt;/code&gt; field but also an &lt;code&gt;op_last&lt;/code&gt; field. The most complex type of op is a &lt;code&gt;LISTOP&lt;/code&gt; , which has any number of children. In this case, the first child is pointed to by &lt;code&gt;op_first&lt;/code&gt; and the last child by &lt;code&gt;op_last&lt;/code&gt; . The children in between can be found by iteratively following the &lt;code&gt;OpSIBLING&lt;/code&gt; pointer from the first child to the last (but see below).</source>
          <target state="translated">&lt;code&gt;OP&lt;/code&gt; 结构的最简单类型是OP：它没有子代。一元运算符 &lt;code&gt;UNOP&lt;/code&gt; 拥有一个孩子，这由 &lt;code&gt;op_first&lt;/code&gt; 字段指出。二进制运算符（ &lt;code&gt;BINOP&lt;/code&gt; ）不仅具有 &lt;code&gt;op_first&lt;/code&gt; 字段，而且具有 &lt;code&gt;op_last&lt;/code&gt; 字段。 op的最复杂类型是 &lt;code&gt;LISTOP&lt;/code&gt; ，它可以有任意数量的子代。在这种情况下，第一个孩子由 &lt;code&gt;op_first&lt;/code&gt; 指向，最后一个孩子由 &lt;code&gt;op_last&lt;/code&gt; 指向。可以通过从第一个孩子到最后一个孩子反复跟踪 &lt;code&gt;OpSIBLING&lt;/code&gt; 指针来找到中间的孩子（但请参见下文）。</target>
        </trans-unit>
        <trans-unit id="ffb373ae1dc958f6e57c2a91fb253380e617f734" translate="yes" xml:space="preserve">
          <source>The simplest type of op structure is &lt;code&gt;OP&lt;/code&gt;: this has no children. Unary operators, &lt;code&gt;UNOP&lt;/code&gt;s, have one child, and this is pointed to by the &lt;code&gt;op_first&lt;/code&gt; field. Binary operators (&lt;code&gt;BINOP&lt;/code&gt;s) have not only an &lt;code&gt;op_first&lt;/code&gt; field but also an &lt;code&gt;op_last&lt;/code&gt; field. The most complex type of op is a &lt;code&gt;LISTOP&lt;/code&gt;, which has any number of children. In this case, the first child is pointed to by &lt;code&gt;op_first&lt;/code&gt; and the last child by &lt;code&gt;op_last&lt;/code&gt;. The children in between can be found by iteratively following the &lt;code&gt;OpSIBLING&lt;/code&gt; pointer from the first child to the last (but see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48570eadf16f561f7ed2c5fd05e1b77f1b97a0a9" translate="yes" xml:space="preserve">
          <source>The simplest way to build up a decent testing suite is to just test what the manual says it does. [3] Let's pull something out of the &lt;a href=&quot;Date::ICal#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot; in Date::ICal&lt;/a&gt; and test that all its bits work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2054b09e7b3505e051c925e118baa9402ac5d4ec" translate="yes" xml:space="preserve">
          <source>The simplest way to do this is:</source>
          <target state="translated">最简单的方法就是。</target>
        </trans-unit>
        <trans-unit id="388dab005124e81f16d269b4ee944aa3b8003908" translate="yes" xml:space="preserve">
          <source>The simplest way to use this library is to import the md5_hex() function (or one of its cousins):</source>
          <target state="translated">使用这个库最简单的方法是导入md5_hex()函数(或它的一个表兄弟)。</target>
        </trans-unit>
        <trans-unit id="5ecd63cfa076538859f9d50a754ce0ea42b734ec" translate="yes" xml:space="preserve">
          <source>The simplest, most straightforward way to create a thread is with &lt;code&gt;create()&lt;/code&gt; :</source>
          <target state="translated">创建线程的最简单，最直接的方法是使用 &lt;code&gt;create()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="aedaa034bc02c59e2080c491aee6d14703ba3b58" translate="yes" xml:space="preserve">
          <source>The simplest, most straightforward way to create a thread is with &lt;code&gt;create()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="142891f6dfc36054413e16ddc5cd0b102274ac48" translate="yes" xml:space="preserve">
          <source>The single parameter &lt;code&gt;cb1&lt;/code&gt; is a pointer to a function, so you must have defined &lt;code&gt;cb1&lt;/code&gt; in your code, say something like this</source>
          <target state="translated">单个参数 &lt;code&gt;cb1&lt;/code&gt; 是指向函数的指针，因此您必须在代码中定义 &lt;code&gt;cb1&lt;/code&gt; ，这样说</target>
        </trans-unit>
        <trans-unit id="c390613e0b451f9ebc65ddd44ea3f2cbf88c23f5" translate="yes" xml:space="preserve">
          <source>The situation in which an &lt;b&gt;expression&lt;/b&gt; is expected by its surroundings (the code calling it) to return a list of values rather than a single value. Functions that want a</source>
          <target state="translated">其中的情形&lt;b&gt;表达&lt;/b&gt;是通过其周围预期（代码调用它）返回值的列表，而不是一个单一的值。需要一个功能</target>
        </trans-unit>
        <trans-unit id="d86701b02acab027c0d49bd429316b14b358d71d" translate="yes" xml:space="preserve">
          <source>The situation in which an &lt;b&gt;expression&lt;/b&gt; is expected by its surroundings (the code calling it) to return a single &lt;b&gt;value&lt;/b&gt; rather than a &lt;b&gt;list&lt;/b&gt; of values. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;list context&lt;/b&gt;. A scalar context sometimes imposes additional constraints on the return value&amp;mdash;see &lt;b&gt;string context&lt;/b&gt; and &lt;b&gt;numeric context&lt;/b&gt;. Sometimes we talk about a &lt;b&gt;Boolean context&lt;/b&gt; inside conditionals, but this imposes no additional constraints, since any scalar value, whether numeric or &lt;b&gt;string&lt;/b&gt;, is already true or false.</source>
          <target state="translated">其中的情形&lt;b&gt;表达&lt;/b&gt;是通过其周围预期（代码调用它）返回单个&lt;b&gt;值&lt;/b&gt;，而不是一个&lt;b&gt;列表&lt;/b&gt;值。另请参阅&lt;b&gt;上下文&lt;/b&gt;和&lt;b&gt;列表上下文&lt;/b&gt;。标量上下文有时会对返回值施加额外的约束-请参见&lt;b&gt;字符串上下文&lt;/b&gt;和&lt;b&gt;数字上下文&lt;/b&gt;。有时我们谈论条件条件中的&lt;b&gt;布尔上下文&lt;/b&gt;，但这没有附加任何约束，因为任何标量值（无论是数字还是&lt;b&gt;字符串&lt;/b&gt;）都已经是true或false。</target>
        </trans-unit>
        <trans-unit id="5bf519df1d56695e3fe7b5f2cac71014a6a10291" translate="yes" xml:space="preserve">
          <source>The situation in which an expression is expected by its surroundings (the code calling it) to return a &lt;b&gt;string&lt;/b&gt;. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;numeric context&lt;/b&gt;.</source>
          <target state="translated">表达式被周围环境（调用它的代码）期望返回&lt;b&gt;字符串的情况&lt;/b&gt;。另请参阅&lt;b&gt;上下文&lt;/b&gt;和&lt;b&gt;数字上下文&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d5278b812a3307d0ee6951ce2678ae1eab81add9" translate="yes" xml:space="preserve">
          <source>The situation in which an expression is expected by its surroundings (the code calling it) to return a number. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;string context&lt;/b&gt;.</source>
          <target state="translated">表达式被其周围环境（调用它的代码）期望返回数字的情况。另请参见&lt;b&gt;context&lt;/b&gt;和&lt;b&gt;string context&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="1778a01cc57bbb1bfba8f72e778c79445c3a36bf" translate="yes" xml:space="preserve">
          <source>The situation is even less clear for tools such as MakeMaker that can be used to install additional modules into non-standard places. For example, if a user intends to install a module into a private directory (perhaps by setting &lt;code&gt;PREFIX&lt;/code&gt; on the</source>
          <target state="translated">对于诸如MakeMaker之类的可用于将其他模块安装到非标准位置的工具而言，情况甚至还不清楚。例如，如果用户打算通过设置安装模块为一体的民营目录（也许 &lt;code&gt;PREFIX&lt;/code&gt; 上</target>
        </trans-unit>
        <trans-unit id="9a9c38132104cf7801e22419b38670f4a24614fb" translate="yes" xml:space="preserve">
          <source>The situation where this is necessary, is presumably quite rare.</source>
          <target state="translated">必须这样做的情况,大概是相当罕见的。</target>
        </trans-unit>
        <trans-unit id="5a9a5af0a6298739507c5ced21852b79711a0a57" translate="yes" xml:space="preserve">
          <source>The situation with matching Unicode properties in regular expressions, the &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs, against these code points is not as clear cut, and how these are handled has changed as we've gained experience.</source>
          <target state="translated">对于这些代码点，在正则表达式 &lt;code&gt;\p{}&lt;/code&gt; 和 &lt;code&gt;\P{}&lt;/code&gt; 构造中具有匹配的Unicode属性的情况并没有那么明确，随着经验的积累，如何处理它们也发生了变化。</target>
        </trans-unit>
        <trans-unit id="88e6088a9ab77ba2f6a1ec54ad364f7fffa87f43" translate="yes" xml:space="preserve">
          <source>The size of the file will be determined, and sent to the server automatically for normal files so that this method need only be called if you are transferring data from a socket, named pipe, or other stream not associated with a normal file.</source>
          <target state="translated">文件的大小将被确定,对于普通文件,将自动发送到服务器,因此,只有当你从一个套接字、命名的管道或其他不与普通文件相关联的流中传输数据时,才需要调用这个方法。</target>
        </trans-unit>
        <trans-unit id="87d9309a72cdac9a52fd9593050f47fe997d18b5" translate="yes" xml:space="preserve">
          <source>The size of the per-instance data structure, e.g.:</source>
          <target state="translated">每个实例数据结构的大小,例如:。</target>
        </trans-unit>
        <trans-unit id="52d0fd0e1a020955cbd4dc92e53211189e24cb93" translate="yes" xml:space="preserve">
          <source>The size of the perlXYZ.SIS is about 370 kB but once it is in the device it is about one 750 kB (according to the application manager).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5877446a070972ed92cd79aed206f27b2111d714" translate="yes" xml:space="preserve">
          <source>The size of the pieces you&amp;rsquo;re dealing with, mentally speaking.</source>
          <target state="translated">从心理上讲，您正在处理的作品的大小。</target>
        </trans-unit>
        <trans-unit id="1656b4f2fdda6835a902c9679ea0caaf9c6c13e1" translate="yes" xml:space="preserve">
          <source>The size specifier &lt;code&gt;V&lt;/code&gt; has no effect for Perl code, but is supported for compatibility with XS code. It means &quot;use the standard size for a Perl integer or floating-point number&quot;, which is the default.</source>
          <target state="translated">大小说明符 &lt;code&gt;V&lt;/code&gt; 对Perl代码无效，但受支持以与XS代码兼容。它的意思是&amp;ldquo;对Perl整数或浮点数使用标准大小&amp;rdquo;，这是默认设置。</target>
        </trans-unit>
        <trans-unit id="0b86c8f6fcdbd6b3e5e7fca2359cdc4a25ce8c43" translate="yes" xml:space="preserve">
          <source>The skipped prefix (i.e. the characters before the extracted string). On failure, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">跳过的前缀（即，提取的字符串之前的字符）。失败时，将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="954e32bdd5f83008c8f605b9e8dd386da5c77fb4" translate="yes" xml:space="preserve">
          <source>The skipped prefix (i.e. the characters before the extracted string). On failure, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ee3229175e42949ed9e43940ba571b504d8485" translate="yes" xml:space="preserve">
          <source>The slab allocator puts the ops at the end of the slab first. This will tend to allocate the leaves of the op tree first, and the layout will therefore hopefully be cache-friendly. In addition, this means that there's no need to store the size of the slab (see below on why slabs vary in size), because Perl can follow pointers to find the last op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca8448b9d4d7f08ec6d38447f60e1a5ccb09b43" translate="yes" xml:space="preserve">
          <source>The slower but superior fixes are when you may be able to yourself fix the misconfiguration of your own environment variables. The mis(sing)configuration of the whole system's locales usually requires the help of your friendly system administrator.</source>
          <target state="translated">较慢但较好的修复方法是,你可能会自己修复自己的环境变量的错误配置。整个系统的错误配置通常需要你友好的系统管理员的帮助。</target>
        </trans-unit>
        <trans-unit id="0fbe962e06d42462e7c0e18bd04f3db25354c94a" translate="yes" xml:space="preserve">
          <source>The smaller and more localized the change, the better. Similarly, a series of small patches is greatly preferred over a single large patch.</source>
          <target state="translated">变化越小、越局部越好。同样,一系列的小补丁比单一的大补丁要好得多。</target>
        </trans-unit>
        <trans-unit id="f4b9fc3a5444ff6c99460c86f0eae40188849994" translate="yes" xml:space="preserve">
          <source>The smallest individual element of a string. Computers store characters as integers, but Perl lets you operate on them as text. The integer used to represent a particular character is called that character&amp;rsquo;s &lt;b&gt;codepoint&lt;/b&gt;.</source>
          <target state="translated">字符串的最小单个元素。计算机将字符存储为整数，但是Perl允许您将它们作为文本进行操作。用于表示特定字符​​的整数称为该字符的&lt;b&gt;代码点&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="743692cb1b17807cb7e732ecae2c349fdebd6008" translate="yes" xml:space="preserve">
          <source>The smart match stops when it finds a match, so it doesn't have to try every expression.</source>
          <target state="translated">智能匹配在找到匹配项时就会停止,所以它不必尝试每个表达式。</target>
        </trans-unit>
        <trans-unit id="936144db8d649469afd4d348dac4550c6a90cbd0" translate="yes" xml:space="preserve">
          <source>The smartmatch implicitly dereferences any non-blessed hash or array reference, so the &lt;code&gt;&lt;i&gt;HASH&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;&lt;i&gt;ARRAY&lt;/i&gt;&lt;/code&gt; entries apply in those cases. For blessed references, the &lt;code&gt;&lt;i&gt;Object&lt;/i&gt;&lt;/code&gt; entries apply. Smartmatches involving hashes only consider hash keys, never hash values.</source>
          <target state="translated">smartmatch隐式取消引用任何非祝福的哈希或数组引用，因此 &lt;code&gt;&lt;i&gt;HASH&lt;/i&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;i&gt;ARRAY&lt;/i&gt;&lt;/code&gt; 条目在这些情况下适用。对于有祝福的引用，将应用&amp;ldquo; &lt;code&gt;&lt;i&gt;Object&lt;/i&gt;&lt;/code&gt; 条目。涉及哈希的智能匹配仅考虑哈希键，而不考虑哈希值。</target>
        </trans-unit>
        <trans-unit id="d02f6728ba4dcd43d024dc500f10ccfe28692eeb" translate="yes" xml:space="preserve">
          <source>The smartmatch operator is most often used as the implicit operator of a &lt;code&gt;when&lt;/code&gt; clause. See the section on &quot;Switch Statements&quot; in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;.</source>
          <target state="translated">smartmatch运算符最常用作 &lt;code&gt;when&lt;/code&gt; 子句的隐式运算符。请参阅&lt;a href=&quot;perlsyn&quot;&gt;perlsyn中的&lt;/a&gt; &amp;ldquo;切换语句&amp;rdquo; 部分。</target>
        </trans-unit>
        <trans-unit id="1dbe6ac71d39b0bf15f7bc2e7a951d76ec82915a" translate="yes" xml:space="preserve">
          <source>The socket domain will define which subclass of &lt;code&gt;IO::Socket&lt;/code&gt; to use. The two options available along with this distribution are &lt;code&gt;AF_INET&lt;/code&gt; and &lt;code&gt;AF_UNIX&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538eac64870e76a04cefadec7560ac9099d4a644" translate="yes" xml:space="preserve">
          <source>The socket tests may fail if the network is not configured. You have to make &quot;/hurd/pfinet&quot; the translator for &quot;/servers/socket/2&quot;, giving it the right arguments. Try &quot;/hurd/pfinet --help&quot; for more information.</source>
          <target state="translated">如果网络没有配置好,套接字测试可能会失败,你必须让&quot;/hurd/pfinet &quot;成为&quot;/servers/socket/2 &quot;的翻译器。你必须让&quot;/hurd/pfinet &quot;成为&quot;/servers/socket/2 &quot;的翻译器,给它正确的参数。试试&quot;/hurd/pfinet --help &quot;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="127dbba60bbfba8c121a95d45a5b1267637cec67" translate="yes" xml:space="preserve">
          <source>The socket type (e.g. &lt;code&gt;SOCK_STREAM&lt;/code&gt; )</source>
          <target state="translated">套接字类型（例如 &lt;code&gt;SOCK_STREAM&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="efab1ba183171d21de2ceaf72d5458d5f4bc8140" translate="yes" xml:space="preserve">
          <source>The socket type (e.g. &lt;code&gt;SOCK_STREAM&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da232edd2d10d943e919b3b650a030d3ad1934c2" translate="yes" xml:space="preserve">
          <source>The socket type that will be used. These are usually &lt;code&gt;SOCK_STREAM&lt;/code&gt;, &lt;code&gt;SOCK_DGRAM&lt;/code&gt;, or &lt;code&gt;SOCK_RAW&lt;/code&gt;. If this argument is left undefined an attempt will be made to infer the type from the service name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab88d47102ad5dc69b949fcce35b1a58247bf52" translate="yes" xml:space="preserve">
          <source>The socket type to pass to &lt;code&gt;getaddrinfo&lt;/code&gt; (e.g. &lt;code&gt;SOCK_STREAM&lt;/code&gt;, &lt;code&gt;SOCK_DGRAM&lt;/code&gt;). Normally defined by the caller; if left undefined &lt;code&gt;getaddrinfo&lt;/code&gt; may attempt to infer the type from the service name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10c516fba6283faccc420f0f1f0ddca597fd882" translate="yes" xml:space="preserve">
          <source>The sole purpose of this module is to enable colour highlighting from the command line.</source>
          <target state="translated">该模块的唯一目的是在命令行中启用颜色高亮。</target>
        </trans-unit>
        <trans-unit id="165006648b6cdcfa730ff63bd97b9430605a3ca6" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; out of the child directory to a place outside the directory tree to be removed.</source>
          <target state="translated">解决方案是将 &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 从子目录中移到要删除的目录树之外的位置。</target>
        </trans-unit>
        <trans-unit id="25857c787c988fd69fb48ac1af38665d7f387a1d" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;code&gt;chdir&lt;/code&gt; out of the child directory to a place outside the directory tree to be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7391f9903f693d17725f8ae77b7a179797082b4" translate="yes" xml:space="preserve">
          <source>The solution is to use &lt;a href=&quot;perlfunc#__SUB__&quot;&gt;&lt;code&gt;__SUB__&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd1e61d4eb0bbe0f75b3581782eef3e8dfaf4b4" translate="yes" xml:space="preserve">
          <source>The sort of characters we put into words. In Unicode, this is all letters including all ideographs and certain diacritics, letter numbers like Roman numerals, and various combining marks.</source>
          <target state="translated">我们在文字中放入的那种字符。在Unicode中,这是所有的字母,包括所有的表意文字和某些双音字,字母数字如罗马数字,以及各种组合标记。</target>
        </trans-unit>
        <trans-unit id="a1d44ffc9ae032aff54b02af9e8455f31b34d012" translate="yes" xml:space="preserve">
          <source>The sort order will cause differences between results obtained on ASCII platforms versus EBCDIC platforms. What follows are some suggestions on how to deal with these differences.</source>
          <target state="translated">排序顺序会导致在ASCII平台和EBCDIC平台上得到的结果不同。下面是关于如何处理这些差异的一些建议。</target>
        </trans-unit>
        <trans-unit id="89da5c4101906ac148b9121db995bfdaa11ef39f" translate="yes" xml:space="preserve">
          <source>The source buffer can either be a scalar or a scalar reference.</source>
          <target state="translated">源缓冲区可以是一个标量,也可以是一个标量参考。</target>
        </trans-unit>
        <trans-unit id="67687b08f8914b53b7f3846fac38e3b4363d7a5e" translate="yes" xml:space="preserve">
          <source>The source buffer, &lt;code&gt;$source&lt;/code&gt; , can either be a scalar or a scalar reference.</source>
          <target state="translated">源缓冲区 &lt;code&gt;$source&lt;/code&gt; 可以是标量或标量引用。</target>
        </trans-unit>
        <trans-unit id="8ca49df053b6c5ef6b6ff31bd8c0aacb4709988b" translate="yes" xml:space="preserve">
          <source>The source buffer, &lt;code&gt;$source&lt;/code&gt;, can either be a scalar or a scalar reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7e9fa2ae5c5f428ffd5cfef77286b08b69792f" translate="yes" xml:space="preserve">
          <source>The source code for an extension usually resides in its own directory. At least three files are generally provided:</source>
          <target state="translated">一个扩展的源代码通常驻扎在自己的目录中。一般至少提供三个文件。</target>
        </trans-unit>
        <trans-unit id="1e4ee98da0c8794c248be818bce3b87507488dbe" translate="yes" xml:space="preserve">
          <source>The source code includes multiple hash algorithms to choose from. While we believe that the default perl hash is robust to attack, we have included the hash function Siphash as a fall-back option. At the time of release of Perl 5.18.0 Siphash is believed to be of cryptographic strength. This is not the default as it is much slower than the default hash.</source>
          <target state="translated">源代码中包含了多种哈希算法可供选择。虽然我们相信默认的perl哈希算法对攻击是稳健的,但我们还是包含了哈希函数Siphash作为后备选项。在Perl 5.18.0发布时,Siphash被认为是具有加密强度的。这不是默认的,因为它比默认的哈希慢得多。</target>
        </trans-unit>
        <trans-unit id="7a62a8b0275fb02e9e7293cb89d71dd692b01164" translate="yes" xml:space="preserve">
          <source>The source code is available on Git Hub: &lt;a href=&quot;https://github.com/maddingue/Sys-Syslog/&quot;&gt;https://github.com/maddingue/Sys-Syslog/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0caf29be420bbd199849ea512093a83580509aa" translate="yes" xml:space="preserve">
          <source>The source code locations are supported &lt;b&gt;only&lt;/b&gt; if you have the Developer Tools installed. (BFD is &lt;b&gt;not&lt;/b&gt; needed.)</source>
          <target state="translated">&lt;b&gt;仅&lt;/b&gt;当您安装了开发人员工具时，&lt;b&gt;才&lt;/b&gt;支持源代码位置。（BFD是&lt;b&gt;不&lt;/b&gt;需要的。）</target>
        </trans-unit>
        <trans-unit id="077f75395915a901ad7c5804374f7d2b053abae0" translate="yes" xml:space="preserve">
          <source>The source code repository for HashBase can be found at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b90b5da908771ba4301d860153882353d321fc" translate="yes" xml:space="preserve">
          <source>The source code repository for Test2 can be found at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb2a3de91b362ca2b61febe5041a5a32501556d" translate="yes" xml:space="preserve">
          <source>The source code repository for Test::More can be found at</source>
          <target state="translated">Test::More的源代码库可以在以下地址找到</target>
        </trans-unit>
        <trans-unit id="cf7f81d91f75175f1d8405190d2d3c385759d791" translate="yes" xml:space="preserve">
          <source>The source code repository for Time-Local can be found at &lt;a href=&quot;https://github.com/houseabsolute/Time-Local&quot;&gt;https://github.com/houseabsolute/Time-Local&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="449ffcdb319b9addd8fd6dc6fc9226340b95b72f" translate="yes" xml:space="preserve">
          <source>The source filter distribution includes two modules that simplify this task: &lt;code&gt;Filter::exec&lt;/code&gt; and &lt;code&gt;Filter::sh&lt;/code&gt; . Both allow you to run any external executable. Both use a coprocess to control the flow of data into and out of the external executable. (For details on coprocesses, see Stephens, W.R., &quot;Advanced Programming in the UNIX Environment.&quot; Addison-Wesley, ISBN 0-210-56317-7, pages 441-445.) The difference between them is that &lt;code&gt;Filter::exec&lt;/code&gt; spawns the external command directly, while &lt;code&gt;Filter::sh&lt;/code&gt; spawns a shell to execute the external command. (Unix uses the Bourne shell; NT uses the cmd shell.) Spawning a shell allows you to make use of the shell metacharacters and redirection facilities.</source>
          <target state="translated">源过滤器分发包含两个简化此任务的模块： &lt;code&gt;Filter::exec&lt;/code&gt; 和 &lt;code&gt;Filter::sh&lt;/code&gt; 。两者都允许您运行任何外部可执行文件。两者都使用协同处理来控制数据流入和流出外部可执行文件的过程。 （有关协同处理的详细信息，请参见Stephens，WR，&amp;ldquo; UNIX环境中的高级编程。&amp;rdquo; Addison-Wesley，ISBN 0-210-56317-7，第441-445页。）它们之间的区别在于 &lt;code&gt;Filter::exec&lt;/code&gt; 产生了直接使用外部命令，而 &lt;code&gt;Filter::sh&lt;/code&gt; 生成一个shell来执行外部命令。 （Unix使用Bourne外壳； NT使用cmd外壳。）生成外壳可以使您利用外壳的元字符和重定向功能。</target>
        </trans-unit>
        <trans-unit id="806a2d069e5b8127ce418989da98faab2d6211ce" translate="yes" xml:space="preserve">
          <source>The source filter distribution includes two modules that simplify this task: &lt;code&gt;Filter::exec&lt;/code&gt; and &lt;code&gt;Filter::sh&lt;/code&gt;. Both allow you to run any external executable. Both use a coprocess to control the flow of data into and out of the external executable. (For details on coprocesses, see Stephens, W.R., &quot;Advanced Programming in the UNIX Environment.&quot; Addison-Wesley, ISBN 0-210-56317-7, pages 441-445.) The difference between them is that &lt;code&gt;Filter::exec&lt;/code&gt; spawns the external command directly, while &lt;code&gt;Filter::sh&lt;/code&gt; spawns a shell to execute the external command. (Unix uses the Bourne shell; NT uses the cmd shell.) Spawning a shell allows you to make use of the shell metacharacters and redirection facilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0efb50a1d96794619b6be6780ccfe01a3a3f70" translate="yes" xml:space="preserve">
          <source>The source has to be set before you can parse anything. The lowest-level way is to call &lt;code&gt;set_source&lt;/code&gt; :</source>
          <target state="translated">必须先设置源，然后才能解析任何内容。最低级别的方法是调用 &lt;code&gt;set_source&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="25772fbca2fac712b2b730121903ca4af8245b2c" translate="yes" xml:space="preserve">
          <source>The source has to be set before you can parse anything. The lowest-level way is to call &lt;code&gt;set_source&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a7a830852a264986b70187999506a317874b7f" translate="yes" xml:space="preserve">
          <source>The source of ISO 3166-1 two-letter codes used by this module.</source>
          <target state="translated">本模块使用的ISO 3166-1双字母代码的来源。</target>
        </trans-unit>
        <trans-unit id="26888526042c45b79818c80cb5da539324a9402b" translate="yes" xml:space="preserve">
          <source>The source of the official ISO 3166-1 three-letter codes and three-digit codes.</source>
          <target state="translated">正式的ISO 3166-1三字母代码和三位数代码的来源。</target>
        </trans-unit>
        <trans-unit id="047e8113455a3b20776511dcfa749213b66f27f0" translate="yes" xml:space="preserve">
          <source>The source used to be tracked separately in another GitHub repo, but the canonical source is now in the above repo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454a907e32531c807293e3735238b43baf267920" translate="yes" xml:space="preserve">
          <source>The special argument of &lt;code&gt;h h&lt;/code&gt; produces the entire help page, which is quite long.</source>
          <target state="translated">&lt;code&gt;h h&lt;/code&gt; 的特殊参数生成整个帮助页面，该页面很长。</target>
        </trans-unit>
        <trans-unit id="c6f65c11625ca6f6efd4fce69ae54247f9d5fb65" translate="yes" xml:space="preserve">
          <source>The special bookkeeping Perl does to track the flow of external data through your program and disallow their use in system commands.</source>
          <target state="translated">Perl做的特殊记账工作是为了跟踪外部数据在你的程序中的流动,并禁止在系统命令中使用它们。</target>
        </trans-unit>
        <trans-unit id="fbeef28b2f2c3763e9cdd6d44783f63733b4347f" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that a contiguous set of characters can be written as a range. With ranges, the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; . Some examples are</source>
          <target state="translated">特殊字符 &lt;code&gt;'-'&lt;/code&gt; 在字符类中充当范围运算符，因此可以将连续的一组字符写为范围。有了范围，笨拙的 &lt;code&gt;[0123456789]&lt;/code&gt; 和 &lt;code&gt;[abc...xyz]&lt;/code&gt; 成为苗条的 &lt;code&gt;[0-9]&lt;/code&gt; 和 &lt;code&gt;[a-z]&lt;/code&gt; 。一些例子是</target>
        </trans-unit>
        <trans-unit id="51484dcb28cfa30c1085fd011a68713265cc9b21" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that a contiguous set of characters can be written as a range. With ranges, the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt;. Some examples are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a71b165b4e188832e186d5361505b47059b1afc" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; :</source>
          <target state="translated">特殊字符 &lt;code&gt;'-'&lt;/code&gt; 在字符类中充当范围运算符，因此笨拙的 &lt;code&gt;[0123456789]&lt;/code&gt; 和 &lt;code&gt;[abc...xyz]&lt;/code&gt; 成为苗条的 &lt;code&gt;[0-9]&lt;/code&gt; 和 &lt;code&gt;[a-z]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="283724a0a196c8e1912b746979d3d1ad3654c817" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3d6c0c10b1c629e2125d262c610ffe5039c3e0" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'^'&lt;/code&gt; in the first position of a character class denotes a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d9d9306fb9aa515c3bd892587a0587d3baf9f6" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;^&lt;/code&gt; in the first position of a character class denotes a</source>
          <target state="translated">字符类第一位置的特殊字符 &lt;code&gt;^&lt;/code&gt; 表示</target>
        </trans-unit>
        <trans-unit id="8afc59f37c7b54c4d8a636841474cf58beb13e84" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;^&lt;/code&gt; in the first position of a character class denotes a &lt;b&gt;negated character class&lt;/b&gt;, which matches any character but those in the brackets. Both &lt;code&gt;[...]&lt;/code&gt; and &lt;code&gt;[^...]&lt;/code&gt; must match a character, or the match fails. Then</source>
          <target state="translated">字符类的第一个位置中的特殊字符 &lt;code&gt;^&lt;/code&gt; 表示&lt;b&gt;否定的字符类&lt;/b&gt;，它与除方括号中的字符以外的任何字符匹配。无论 &lt;code&gt;[...]&lt;/code&gt; 和 &lt;code&gt;[^...]&lt;/code&gt; 必须一个字符匹配，否则匹配失败。然后</target>
        </trans-unit>
        <trans-unit id="94d7fdb99f703e5dc3a7ffcb7bb005616b504881" translate="yes" xml:space="preserve">
          <source>The special filehandle that iterates over command-line filenames in &lt;code&gt;@ARGV&lt;/code&gt; . Usually written as the null filehandle in the angle operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Note that currently &lt;code&gt;ARGV&lt;/code&gt; only has its magical effect within the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator; elsewhere it is just a plain filehandle corresponding to the last file opened by &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . In particular, passing &lt;code&gt;\*ARGV&lt;/code&gt; as a parameter to a function that expects a filehandle may not cause your function to automatically read the contents of all the files in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">遍历 &lt;code&gt;@ARGV&lt;/code&gt; 中的命令行文件名的特殊文件句柄。通常写为角度运算符 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 中的空文件句柄。注意，当前 &lt;code&gt;ARGV&lt;/code&gt; 仅在 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符内具有神奇的作用；在其他地方，它只是一个普通文件句柄，对应于 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 打开的最后一个文件。特别是，将 &lt;code&gt;\*ARGV&lt;/code&gt; 作为参数传递给需要文件句柄的函数，可能不会导致函数自动读取 &lt;code&gt;@ARGV&lt;/code&gt; 中所有文件的内容。</target>
        </trans-unit>
        <trans-unit id="ac1da88fc9d1c37eca9b801363ceb623fe61bad6" translate="yes" xml:space="preserve">
          <source>The special filehandle that iterates over command-line filenames in &lt;code&gt;@ARGV&lt;/code&gt;. Usually written as the null filehandle in the angle operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. Note that currently &lt;code&gt;ARGV&lt;/code&gt; only has its magical effect within the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator; elsewhere it is just a plain filehandle corresponding to the last file opened by &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. In particular, passing &lt;code&gt;\*ARGV&lt;/code&gt; as a parameter to a function that expects a filehandle may not cause your function to automatically read the contents of all the files in &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f805e5a7fa6e6a7379f92a69ce80440a9d42a7c7" translate="yes" xml:space="preserve">
          <source>The special filehandle that points to the currently open output file when doing edit-in-place processing with &lt;b&gt;-i&lt;/b&gt;. Useful when you have to do a lot of inserting and don't want to keep modifying &lt;code&gt;$_&lt;/code&gt; . See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the &lt;b&gt;-i&lt;/b&gt; switch.</source>
          <target state="translated">使用&lt;b&gt;-i&lt;/b&gt;进行就地编辑时，指向当前打开的输出文件的特殊文件句柄。当您必须进行大量插入并且不想继续修改 &lt;code&gt;$_&lt;/code&gt; 时很有用。参见&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;对于&lt;b&gt;-i&lt;/b&gt;开关。</target>
        </trans-unit>
        <trans-unit id="b0f0f7c3f4bb49e8602e83db9899cb43d8c4eab1" translate="yes" xml:space="preserve">
          <source>The special filehandle that points to the currently open output file when doing edit-in-place processing with &lt;b&gt;-i&lt;/b&gt;. Useful when you have to do a lot of inserting and don't want to keep modifying &lt;code&gt;$_&lt;/code&gt;. See &lt;a href=&quot;perlrun#-i%5Bextension%5D&quot;&gt;perlrun&lt;/a&gt; for the &lt;b&gt;-i&lt;/b&gt; switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c54707234ac101d1520e7aec3c57187de852952" translate="yes" xml:space="preserve">
          <source>The special filename &quot;-&quot; can be used as a standin for both &lt;code&gt;\*STDIN&lt;/code&gt; and &lt;code&gt;\*STDOUT&lt;/code&gt;, so the above can be rewritten as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d2e9e8733979d7b1492fbdd9a7cb623d57628f" translate="yes" xml:space="preserve">
          <source>The special literals __FILE__, __LINE__, and __PACKAGE__ represent the current filename, line number, and package name at that point in your program. __SUB__ gives a reference to the current subroutine. They may be used only as separate tokens; they will not be interpolated into strings. If there is no current package (due to an empty &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; directive), __PACKAGE__ is the undefined value. (But the empty &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; is no longer supported, as of version 5.10.) Outside of a subroutine, __SUB__ is the undefined value. __SUB__ is only available in 5.16 or higher, and only with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;current_sub&quot;&lt;/code&gt; declaration.</source>
          <target state="translated">特殊文字__FILE __，__ LINE__和__PACKAGE__表示程序中该点的当前文件名，行号和程序包名称。 __SUB__提供对当前子例程的引用。它们只能用作单独的令牌；它们不会插值到字符串中。如果没有当前包（由于为空 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; 指令），则__PACKAGE__是未定义的值。 （但是从5.10版开始，不再支持空 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; ）在子例程之外，__SUB__是未定义的值。 __SUB__仅在5.16或更高版本中可用，并且仅在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;current_sub&quot;&lt;/code&gt; 声明时可用。</target>
        </trans-unit>
        <trans-unit id="320950a977dc3e4b6b51f0cd126847e374ebbae7" translate="yes" xml:space="preserve">
          <source>The special literals __FILE__, __LINE__, and __PACKAGE__ represent the current filename, line number, and package name at that point in your program. __SUB__ gives a reference to the current subroutine. They may be used only as separate tokens; they will not be interpolated into strings. If there is no current package (due to an empty &lt;code&gt;package;&lt;/code&gt; directive), __PACKAGE__ is the undefined value. (But the empty &lt;code&gt;package;&lt;/code&gt; is no longer supported, as of version 5.10.) Outside of a subroutine, __SUB__ is the undefined value. __SUB__ is only available in 5.16 or higher, and only with a &lt;code&gt;use v5.16&lt;/code&gt; or &lt;code&gt;use feature &quot;current_sub&quot;&lt;/code&gt; declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af0b63b67806c6dfb7b9ddb2d398096248ddab4" translate="yes" xml:space="preserve">
          <source>The special mark that tells the operating system it can run this program. There are actually three execute bits under Unix, and which bit gets used depends on whether you own the file singularly, collectively, or not at all.</source>
          <target state="translated">告诉操作系统可以运行这个程序的特殊标志。在Unix下其实有三个执行位,使用哪个位取决于你是单一拥有、集体拥有还是完全不拥有文件。</target>
        </trans-unit>
        <trans-unit id="6429c59caa249ed4d6719a4eab753f28d6cfd25d" translate="yes" xml:space="preserve">
          <source>The special methods &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::can&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;maybe::next::method&lt;/code&gt; are not available until this &lt;code&gt;mro&lt;/code&gt; module has been loaded via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 加载此 &lt;code&gt;mro&lt;/code&gt; 模块之前， &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::can&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;maybe::next::method&lt;/code&gt; 的特殊方法不可用。</target>
        </trans-unit>
        <trans-unit id="cc7c3c8f9444854b13225185a30e005803243a24" translate="yes" xml:space="preserve">
          <source>The special methods &lt;code&gt;next::method&lt;/code&gt;, &lt;code&gt;next::can&lt;/code&gt;, and &lt;code&gt;maybe::next::method&lt;/code&gt; are not available until this &lt;code&gt;mro&lt;/code&gt; module has been loaded via &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41f3d15a857df9bc04fff7f6a7434b18442c584" translate="yes" xml:space="preserve">
          <source>The special quoting behavior ignores precedence, and hence may apply to</source>
          <target state="translated">特殊的引用行为忽略了优先性,因此可能适用于</target>
        </trans-unit>
        <trans-unit id="6bd162b2c252e6c76a44c9033fc601bb11a084ee" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is exempt from &lt;a href=&quot;perldiag#Argument-%22%25s%22-isn%27t-numeric%25s&quot;&gt;&lt;code&gt;Argument &quot;...&quot; isn't numeric&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; on improper numeric conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a2544429fe460799a8292535fcaefc5e4c6c60" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is exempt from &lt;b&gt;-w&lt;/b&gt; complaints about improper numeric conversions.</source>
          <target state="translated">对于特殊的数字转换，&lt;b&gt;-w&lt;/b&gt;投诉可免除特殊字符串 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="026f6dfd3d9c99c5a9bfd6afe8ee0f79daedf36d" translate="yes" xml:space="preserve">
          <source>The special symbol &lt;code&gt;__PACKAGE__&lt;/code&gt; contains the current package, but cannot (easily) be used to construct variable names.</source>
          <target state="translated">特殊符号 &lt;code&gt;__PACKAGE__&lt;/code&gt; 包含当前程序包，但不能（轻松）用于构造变量名。</target>
        </trans-unit>
        <trans-unit id="ec16f658ce9778430c3bc19ca22d2cf08596e063" translate="yes" xml:space="preserve">
          <source>The special symbol &lt;code&gt;__PACKAGE__&lt;/code&gt; contains the current package, but cannot (easily) be used to construct variable names. After &lt;code&gt;my($foo)&lt;/code&gt; has hidden package variable &lt;code&gt;$foo&lt;/code&gt;, it can still be accessed, without knowing what package you are in, as &lt;code&gt;${__PACKAGE__.'::foo'}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f36c55aa844c8a0dac4156e30712cffbcd8a9f0" translate="yes" xml:space="preserve">
          <source>The special two-argument form of Perl's open() function ignores trailing blanks in filenames and infers the mode from certain leading characters (or a trailing &quot;|&quot;). In older versions of Perl this was the only version of open() and so it is prevalent in old code and books.</source>
          <target state="translated">Perl 的 open()函数的特殊的双参数形式忽略了文件名中的尾部空白,并从某些前导字符 (或尾部的 &quot;|&quot;)来推断模式。在旧版本的Perl中,这是open()的唯一版本,因此在旧的代码和书籍中很常见。</target>
        </trans-unit>
        <trans-unit id="161a5a9075bb6b7595615ee16fc183085e48d829" translate="yes" xml:space="preserve">
          <source>The special value 00 will cause Perl to slurp files in paragraph mode. Any value 0400 or above will cause Perl to slurp files whole, but by convention the value 0777 is the one normally used for this purpose.</source>
          <target state="translated">特殊的值 00 将使 Perl 以段落模式吞吐文件。任何 0400 或以上的值都会使 Perl 读取整个文件,但按照惯例,通常用于此目的的值是 0777。</target>
        </trans-unit>
        <trans-unit id="510ff7ba673af9c07da4bdf1546cce9f48d4aa9d" translate="yes" xml:space="preserve">
          <source>The special variable &lt;code&gt;$#array&lt;/code&gt; tells you the index of the last element of an array:</source>
          <target state="translated">特殊变量 &lt;code&gt;$#array&lt;/code&gt; 告诉您数组最后一个元素的索引：</target>
        </trans-unit>
        <trans-unit id="7bf5f587af4320b4f6a337ef8e71a1acc59dbd84" translate="yes" xml:space="preserve">
          <source>The special variable &lt;code&gt;${^ENCODING}&lt;/code&gt; was used to implement the &lt;code&gt;encoding&lt;/code&gt; pragma. Setting this variable to anything other than &lt;code&gt;undef&lt;/code&gt; was deprecated in Perl 5.22. Full deprecation of the variable happened in Perl 5.25.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848d9f1e6794b744b742b40d6e30625dbd74dd9d" translate="yes" xml:space="preserve">
          <source>The special variables for formats are a subset of those for filehandles. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for more information about Perl's formats.</source>
          <target state="translated">格式的特殊变量是文件句柄的特殊变量。有关Perl格式的更多信息，请参见&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d50e7fd9df415ed27a91da10839b57126db4d317" translate="yes" xml:space="preserve">
          <source>The special verbosity level 99 requires to also specify the -sections parameter; then these sections are extracted and printed.</source>
          <target state="translated">特殊的verbosity级别99要求同时指定-sections参数,然后提取并打印这些章节。</target>
        </trans-unit>
        <trans-unit id="79d7da7f02ba1ece997a8e1f533d9c05c192eb59" translate="yes" xml:space="preserve">
          <source>The specific task here is to sort the 286,525 lines of this file by Response Code, Query, Browser, Referring Url, and lastly Date. One solution might be to use the following code, which iterates over the files given on the command-line.</source>
          <target state="translated">这里的具体任务是将这个文件的286,525行按响应代码、查询、浏览器、引用Url和最后的日期进行排序。一个解决方案可能是使用下面的代码,它在命令行给出的文件上进行迭代。</target>
        </trans-unit>
        <trans-unit id="ec45d65d2602c92bff90edfa34bc341572780991" translate="yes" xml:space="preserve">
          <source>The specification of ISO-2022 is available from the link above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61bf1ad08824c740b76048cd4f454fa0d05ebcf4" translate="yes" xml:space="preserve">
          <source>The specification which tar derives from; &lt;code&gt; &lt;a href=&quot;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;&gt;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">tar源自的规范； &lt;code&gt; &lt;a href=&quot;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;&gt;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6cea1ce6b94b1cce0327c439743891bfb6f47d86" translate="yes" xml:space="preserve">
          <source>The specification which tar derives from; &lt;code&gt; http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="040046de0f6316ea231530079dbf44ad18b9f542" translate="yes" xml:space="preserve">
          <source>The specifications are returned in increasing order of arguments starting at 0 (e.g. ';$') or 1 (e.g. '$@'). Note that if the prototype is &quot;slurpy&quot; (e.g. ends with a &quot;@&quot;), the number of arguments for the last specification is a &quot;minimum&quot; number rather than an exact number. This can be detected by the last member of the last specification matching m/[@#]_/.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5249ead0cea582438ce306dee2ff065c9121394e" translate="yes" xml:space="preserve">
          <source>The specified</source>
          <target state="translated">指定的</target>
        </trans-unit>
        <trans-unit id="0bbf6ce071adc9bbc621e13b2eb0c9adb5ed909d" translate="yes" xml:space="preserve">
          <source>The specified filtering subroutine is called every time a &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG&lt;/code&gt; is encountered, and passed all the source code following that call, up to either the next &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; (or whatever terminator you've set) or the end of the source file, whichever occurs first. By default, any &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;
BANG;&lt;/code&gt; call must appear by itself on a separate line, or it is ignored.</source>
          <target state="translated">每次遇到 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG&lt;/code&gt; 时，都会调用指定的过滤子例程，并在该调用之后将所有源代码传递给下一个 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; （或您设置的终止符）或源文件的末尾，以先到者为准。默认情况下，任何 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; 呼叫必须单独出现在单独的行上，否则将被忽略。</target>
        </trans-unit>
        <trans-unit id="4c32a119deb019c17dccde9cf5e6d747da8ced23" translate="yes" xml:space="preserve">
          <source>The specified filtering subroutine is called every time a &lt;code&gt;use BANG&lt;/code&gt; is encountered, and passed all the source code following that call, up to either the next &lt;code&gt;no BANG;&lt;/code&gt; (or whatever terminator you've set) or the end of the source file, whichever occurs first. By default, any &lt;code&gt;no BANG;&lt;/code&gt; call must appear by itself on a separate line, or it is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="888fda8ce1b72f373cbaac5341a6655b0d4c64f9" translate="yes" xml:space="preserve">
          <source>The splain Program</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52324d25d30fa15232ecb990b5648a4dcfeb28a" translate="yes" xml:space="preserve">
          <source>The split function</source>
          <target state="translated">拆分功能</target>
        </trans-unit>
        <trans-unit id="ddfcdc05a5251df7fbf9a8a775f1e8025aac3f91" translate="yes" xml:space="preserve">
          <source>The split operator</source>
          <target state="translated">拆分运算符</target>
        </trans-unit>
        <trans-unit id="62b2eb8876cf935a6917a946dbc16da0fe289ddf" translate="yes" xml:space="preserve">
          <source>The square brackets explicitly turn a list value into a scalar value, while parentheses do not. So when a parenthesized list is evaluated in a scalar context, the comma is treated like C's comma operator, which throws away the left argument, which is not what you want. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for more on this.</source>
          <target state="translated">方括号将列表值显式转换为标量值，而括号则不然。因此，当在标量上下文中对带括号的列表求值时，逗号就像C的逗号运算符一样处理，该运算符会丢弃左参数，这不是您想要的。有关更多信息，请参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="daa1d51a4ab5d5dc2b248180c01a452f38c9d08d" translate="yes" xml:space="preserve">
          <source>The square brackets make a reference to a new array with a</source>
          <target state="translated">方括号中是对新数组的引用,方括号中是对新数组的引用。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
