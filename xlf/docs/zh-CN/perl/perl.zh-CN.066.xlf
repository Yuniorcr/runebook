<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="f206c1bcae194bffc342770e7b420f8da8111044" translate="yes" xml:space="preserve">
          <source>This namespace is for plugins. Plugins are modules that change or enhance the behavior of Test2. An example of a plugin is a module that sets the encoding to utf8 globally. Another example is a module that causes a bail-out event after the first test failure.</source>
          <target state="translated">这个命名空间是用于插件的。插件是改变或增强Test2行为的模块。插件的一个例子是全局设置编码为utf8的模块。另一个例子是一个在第一次测试失败后引起保释事件的模块。</target>
        </trans-unit>
        <trans-unit id="2bf32d61a54ff1e8a671180167e4172f9902a980" translate="yes" xml:space="preserve">
          <source>This namespace is for sets of tools. Modules in this namespace should export tools like &lt;code&gt;ok()&lt;/code&gt; and &lt;code&gt;is()&lt;/code&gt;. Most things written for Test2 should go here. Modules in this namespace &lt;b&gt;MUST NOT&lt;/b&gt; export subs from other tools. See the &lt;a href=&quot;#Test2%3A%3ABundle%3A%3A&quot;&gt;&quot;Test2::Bundle::&quot;&lt;/a&gt; namespace if you want to do that.</source>
          <target state="translated">该名称空间用于工具集。此命名空间中的模块应导出 &lt;code&gt;ok()&lt;/code&gt; 和 &lt;code&gt;is()&lt;/code&gt; 之类的工具。为Test2编写的大多数内容都应该放在这里。在这个命名空间模块&lt;b&gt;不得&lt;/b&gt;从其他工具出口潜艇。如果要这样做，请参见&lt;a href=&quot;#Test2%3A%3ABundle%3A%3A&quot;&gt;&amp;ldquo; Test2 :: Bundle ::&amp;rdquo;&lt;/a&gt;名称空间。</target>
        </trans-unit>
        <trans-unit id="0e4e24a5df257f50d009292829b2bfd20798df4c" translate="yes" xml:space="preserve">
          <source>This newer style is consistent with the values of other Unicode properties. To preserve backward compatibility, all the functions in Unicode::UCD that return block names (except as noted) return the old-style ones. &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; returns the new-style and can be used to convert from old-style to new-style:</source>
          <target state="translated">这种较新的样式与其他Unicode属性的值一致。为了保持向后兼容性，Unicode :: UCD中所有返回块名称（除非另有说明）的函数均返回旧样式。&lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&amp;ldquo; prop_value_aliases（）&amp;rdquo;&lt;/a&gt;返回新样式，可用于从旧样式转换为新样式：</target>
        </trans-unit>
        <trans-unit id="64f3b2bdf54de52b80ace773443b078978c32943" translate="yes" xml:space="preserve">
          <source>This newer style is consistent with the values of other Unicode properties. To preserve backward compatibility, all the functions in Unicode::UCD that return block names (except as noted) return the old-style ones. &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; returns the new-style and can be used to convert from old-style to new-style:</source>
          <target state="translated">这种较新的样式与其他Unicode属性的值一致。为了保持向后兼容性，Unicode :: UCD中所有返回块名称（除非另有说明）的函数均返回旧样式。&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;返回新样式，可用于从旧样式转换为新样式：</target>
        </trans-unit>
        <trans-unit id="00215ed790925e9c90e37af405255e37b3a2b3c0" translate="yes" xml:space="preserve">
          <source>This normalizer function will store scalar context return values in the disk file under keys that begin with &lt;code&gt;S:&lt;/code&gt; , and list context return values under keys that begin with &lt;code&gt;L:&lt;/code&gt; .</source>
          <target state="translated">此规范化函数将标量上下文返回值存储在磁盘文件中以 &lt;code&gt;S:&lt;/code&gt; 开头的键下，并列出上下文返回值在以 &lt;code&gt;L:&lt;/code&gt; 开头的键下。</target>
        </trans-unit>
        <trans-unit id="565b14e4a137ea8e183d1678fe124d67dbe415ce" translate="yes" xml:space="preserve">
          <source>This normalizer function will store scalar context return values in the disk file under keys that begin with &lt;code&gt;S:&lt;/code&gt;, and list context return values under keys that begin with &lt;code&gt;L:&lt;/code&gt;.</source>
          <target state="translated">此规范化函数将标量上下文返回值存储在磁盘文件中以 &lt;code&gt;S:&lt;/code&gt; 开头的键下，并列出上下文返回值在以 &lt;code&gt;L:&lt;/code&gt; 开头的键下。</target>
        </trans-unit>
        <trans-unit id="af82ed0821cc193322bac301a4efb5cd0be9cd17" translate="yes" xml:space="preserve">
          <source>This normally doesn't happen at the Perl level unless a variable is undef'ed or the last variable holding a reference to it is changed or overwritten. At the internal level, however, reference counts can be manipulated with the following macros:</source>
          <target state="translated">通常在Perl中不会发生这种情况,除非一个变量未被定义,或者最后一个持有引用的变量被改变或覆盖。然而,在内部层面上,引用计数可以通过下面的宏来操作。</target>
        </trans-unit>
        <trans-unit id="3b1609ead2a84dd600fa52f07b23743e8e94c4e5" translate="yes" xml:space="preserve">
          <source>This notes a problem in the Pod, which will be reported in the &quot;Pod Errors&quot; section of the document and/or sent to STDERR, depending on the values of the attributes &lt;code&gt;no_whining&lt;/code&gt;, &lt;code&gt;no_errata_section&lt;/code&gt;, and &lt;code&gt;complain_stderr&lt;/code&gt;.</source>
          <target state="translated">这说明了Pod中的问题，具体取决于属性 &lt;code&gt;no_whining&lt;/code&gt; ， &lt;code&gt;no_errata_section&lt;/code&gt; 和 &lt;code&gt;complain_stderr&lt;/code&gt; _stderr的值，该问题将在文档的&amp;ldquo; Pod错误&amp;rdquo;部分中报告和/或发送至STDERR 。</target>
        </trans-unit>
        <trans-unit id="7a84db8c8f72a870ae46a23a931a2d5e7928615c" translate="yes" xml:space="preserve">
          <source>This notes an error like &lt;code&gt;whine&lt;/code&gt; does, except that it is not suppressible with &lt;code&gt;no_whining&lt;/code&gt;. This should be used only for very serious errors.</source>
          <target state="translated">这注意到一个类似于 &lt;code&gt;whine&lt;/code&gt; 的错误，除了使用 &lt;code&gt;no_whining&lt;/code&gt; 无法将其抑制。仅应将其用于非常严重的错误。</target>
        </trans-unit>
        <trans-unit id="781831a4fcab5b31277395d81bbf01ada61ab8de" translate="yes" xml:space="preserve">
          <source>This number describes the earliest compatible &lt;code&gt;PERL_REVISION&lt;/code&gt; of Perl (&lt;code&gt;compatibility&lt;/code&gt; here being defined as sufficient</source>
          <target state="translated">此数字描述了Perl 的最早兼容 &lt;code&gt;PERL_REVISION&lt;/code&gt; （此处将 &lt;code&gt;compatibility&lt;/code&gt; 定义为足够</target>
        </trans-unit>
        <trans-unit id="0c3631049473f76e2dd0f9b657a8b5bb99ef0ce8" translate="yes" xml:space="preserve">
          <source>This number describes the earliest compatible &lt;code&gt;PERL_SUBVERSION&lt;/code&gt; of Perl (&lt;code&gt;compatibility&lt;/code&gt; here being defined as sufficient</source>
          <target state="translated">此数字描述了Perl 的最早兼容 &lt;code&gt;PERL_SUBVERSION&lt;/code&gt; （此处将 &lt;code&gt;compatibility&lt;/code&gt; 定义为足够</target>
        </trans-unit>
        <trans-unit id="74feee9a515674df1fbf3fa550f4ebde2a393edc" translate="yes" xml:space="preserve">
          <source>This number describes the earliest compatible &lt;code&gt;PERL_VERSION&lt;/code&gt; of Perl (&lt;code&gt;compatibility&lt;/code&gt; here being defined as sufficient</source>
          <target state="translated">此数字描述了Perl 的最早兼容 &lt;code&gt;PERL_VERSION&lt;/code&gt; （此处将 &lt;code&gt;compatibility&lt;/code&gt; 定义为足够</target>
        </trans-unit>
        <trans-unit id="091c6d1236713704a5d644b59c4d940e46aa2271" translate="yes" xml:space="preserve">
          <source>This object consumes &lt;a href=&quot;Test2::Util::ExternalMeta&quot;&gt;Test2::Util::ExternalMeta&lt;/a&gt; which provides a consistent way for you to attach meta-data to instances of this class. This is useful for tools, plugins, and other extensions.</source>
          <target state="translated">该对象使用&lt;a href=&quot;Test2::Util::ExternalMeta&quot;&gt;Test2 :: Util :: ExternalMeta&lt;/a&gt;，它为您提供了一种将元数据附加到此类实例的一致方法。这对于工具，插件和其他扩展很有用。</target>
        </trans-unit>
        <trans-unit id="3daf144ec9102bb41c4b3e85d9d925806042ef77" translate="yes" xml:space="preserve">
          <source>This object corresponds to a tree of parsed POD text. As POD text is scanned from left to right, it is parsed into an ordered list of text-strings and &lt;b&gt;Pod::InteriorSequence&lt;/b&gt; objects (in order of appearance). A &lt;b&gt;Pod::ParseTree&lt;/b&gt; object corresponds to this list of strings and sequences. Each interior sequence in the parse-tree may itself contain a parse-tree (since interior sequences may be nested).</source>
          <target state="translated">该对象对应于已解析的POD文本树。从左向右扫描POD文本时，会将其解析为文本字符串和&lt;b&gt;Pod :: InteriorSequence&lt;/b&gt;对象（按出现顺序）的有序列表。一个&lt;b&gt;波德::分析树&lt;/b&gt;对象所对应的字符串和序列名单。解析树中的每个内部序列本身都可以包含一个解析树（因为内部序列可以嵌套）。</target>
        </trans-unit>
        <trans-unit id="bf5376f8ad113b045fd4b2cd36ed30b7f5f4f548" translate="yes" xml:space="preserve">
          <source>This object encapsulates the global shared state tracked by &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;. A single global instance of this package is stored (and obscured) by the &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; package.</source>
          <target state="translated">该对象封装了&lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;跟踪的全局共享状态。该包的单个全局实例由&lt;a href=&quot;Test2::API&quot;&gt;Test2 :: API&lt;/a&gt;包存储（并遮盖）。</target>
        </trans-unit>
        <trans-unit id="c65aad4d731c650bf589bf8e7d6030572457b243" translate="yes" xml:space="preserve">
          <source>This object model leads to a tight coupling between subclasses. If one class wants to inherit from another (and both classes access object data), the classes must agree about implementation details. Inheritance can only be used among classes that are maintained together, in a single source or not.</source>
          <target state="translated">这种对象模型导致了子类之间的紧密耦合。如果一个类想从另一个类继承(并且两个类都访问对象数据),那么两个类必须就实现细节达成一致。继承只能在一起维护的类之间使用,无论是否在一个源中。</target>
        </trans-unit>
        <trans-unit id="ddb04c604b2d23c57bcc7ab2aed8669980c3ec14" translate="yes" xml:space="preserve">
          <source>This obviously matches, but in the process of matching, the subexpression &lt;code&gt;a*&lt;/code&gt; first grabbed the &lt;code&gt;'a'&lt;/code&gt;. Doing so, however, wouldn't allow the whole regexp to match, so after backtracking, &lt;code&gt;a*&lt;/code&gt; eventually gave back the &lt;code&gt;'a'&lt;/code&gt; and matched the empty string. Here, what &lt;code&gt;a*&lt;/code&gt; matched was</source>
          <target state="translated">这显然是匹配的，但是在匹配过程中，子表达式 &lt;code&gt;a*&lt;/code&gt; 首先抢占了 &lt;code&gt;'a'&lt;/code&gt; 。但是，这样做将不允许整个正则表达式匹配，因此在回溯之后， &lt;code&gt;a*&lt;/code&gt; 最终会返回 &lt;code&gt;'a'&lt;/code&gt; 并匹配空字符串。在这里， &lt;code&gt;a*&lt;/code&gt; 匹配的是</target>
        </trans-unit>
        <trans-unit id="75906e4fa98bc1c55561b974f97399cf50b738ce" translate="yes" xml:space="preserve">
          <source>This obviously matches, but in the process of matching, the subexpression &lt;code&gt;a*&lt;/code&gt; first grabbed the &lt;code&gt;a&lt;/code&gt; . Doing so, however, wouldn't allow the whole regexp to match, so after backtracking, &lt;code&gt;a*&lt;/code&gt; eventually gave back the &lt;code&gt;a&lt;/code&gt; and matched the empty string. Here, what &lt;code&gt;a*&lt;/code&gt; matched was</source>
          <target state="translated">这显然是匹配的，但是在匹配过程中，子表达式 &lt;code&gt;a*&lt;/code&gt; 首先抓取了 &lt;code&gt;a&lt;/code&gt; 。但是，这样做将不允许整个正则表达式匹配，因此在回溯之后， &lt;code&gt;a*&lt;/code&gt; 最终会返回 &lt;code&gt;a&lt;/code&gt; 并匹配空字符串。在这里， &lt;code&gt;a*&lt;/code&gt; 匹配的是</target>
        </trans-unit>
        <trans-unit id="fb797c4ef105afbc7e6f092d57da0886c5342624" translate="yes" xml:space="preserve">
          <source>This one is not a name of encoding but a utility that lets you pick up the most appropriate encoding for a data out of given</source>
          <target state="translated">这个不是一个编码的名字,而是一个实用工具,让你从给定的数据中挑选出最合适的编码。</target>
        </trans-unit>
        <trans-unit id="ce31346ef13bdd3b410f6693045b75e1d727f213" translate="yes" xml:space="preserve">
          <source>This one works differently from normal strings:</source>
          <target state="translated">这个和普通的手串工作原理不同。</target>
        </trans-unit>
        <trans-unit id="d8b038e9ce5b7ad8b326d48a0c12f7a1a65ddb76" translate="yes" xml:space="preserve">
          <source>This opens the UTF8-encoded file containing Unicode characters; see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;. Note that if layers are specified in the three-argument form, then default layers stored in &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt;&lt;code&gt;${^OPEN}&lt;/code&gt;&lt;/a&gt; (usually set by the &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma or the switch &lt;code&gt;-CioD&lt;/code&gt;) are ignored. Those layers will also be ignored if you specify a colon with no name following it. In that case the default layer for the operating system (:raw on Unix, :crlf on Windows) is used.</source>
          <target state="translated">这将打开包含Unicode字符的UTF8编码文件；参见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;。请注意，如果以三参数形式指定了图层，则将忽略&lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt; &lt;code&gt;${^OPEN}&lt;/code&gt; &lt;/a&gt;存储的默认图层（通常由&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma或switch &lt;code&gt;-CioD&lt;/code&gt; 设置）。如果您在其后指定一个没有名称的冒号，则这些图层也将被忽略。在这种情况下，将使用操作系统的默认层（在Unix上为：raw，在Windows上为：crlf）。</target>
        </trans-unit>
        <trans-unit id="8dceabe6741f9e9be624acb0758d7a05df91f7b1" translate="yes" xml:space="preserve">
          <source>This operates as above, but the &lt;code&gt;Filter&lt;/code&gt; argument with a non-zero value causes the entire script, and not just literals, to be translated from the encoding into UTF-8. This allows identifiers in the source to be in that encoding as well. (Problems may occur if the encoding is not a superset of ASCII; imagine all your semi-colons being translated into something different.) One can use this form to make</source>
          <target state="translated">此操作如上所述，但是具有非零值的 &lt;code&gt;Filter&lt;/code&gt; 参数导致整个脚本（不只是文字）从编码转换为UTF-8。这也允许源中的标识符也采用该编码。（如果编码不是ASCII的超集，则可能会出现问题；想像一下您所有的分号都被翻译成其他不同的东西了。）</target>
        </trans-unit>
        <trans-unit id="bafbb273ef65724f67929789d4cf1821d369332e" translate="yes" xml:space="preserve">
          <source>This operator changes only the modification time of the file (VMS revision date) on ODS-2 volumes and ODS-5 volumes without access dates enabled. On ODS-5 volumes with access dates enabled, the true access time is modified.</source>
          <target state="translated">该操作者只改变ODS-2卷和ODS-5卷上未启用访问日期的文件修改时间(VMS修改日期)。在启用访问日期的ODS-5卷上,真正的访问时间被修改。</target>
        </trans-unit>
        <trans-unit id="ffba20ee3390ab6f7cdbeb9ab15cfb5e9016cca0" translate="yes" xml:space="preserve">
          <source>This operator is also handy for inverting a hash, although there are some caveats. If a value is duplicated in the original hash, only one of those can be represented as a key in the inverted hash. Also, this has to unwind one hash and build a whole new one, which may take some time on a large hash, such as from a DBM file.</source>
          <target state="translated">这个运算符对于反转哈希也很方便,不过也有一些注意事项。如果一个值在原始哈希中是重复的,那么在倒置的哈希中只能用其中一个来表示。另外,这必须解开一个哈希值,并建立一个全新的哈希值,这在一个大的哈希值上可能会花费一些时间,比如从一个DBM文件中提取。</target>
        </trans-unit>
        <trans-unit id="0b8267c16c345a02931d07745eab202ccd1416fa" translate="yes" xml:space="preserve">
          <source>This operator is implemented using the standard &lt;code&gt;File::Glob&lt;/code&gt; extension. See &lt;a href=&quot;../file/glob&quot;&gt;File::Glob&lt;/a&gt; for details, including &lt;code&gt;bsd_glob&lt;/code&gt; which does not treat whitespace as a pattern separator.</source>
          <target state="translated">该操作符使用标准 &lt;code&gt;File::Glob&lt;/code&gt; 扩展名实现。有关详细信息，请参见&lt;a href=&quot;../file/glob&quot;&gt;File :: Glob&lt;/a&gt;，包括 &lt;code&gt;bsd_glob&lt;/code&gt; ，它不将空格视为模式分隔符。</target>
        </trans-unit>
        <trans-unit id="6603facafeb0ca27618f690e983e8f47ba2f8982" translate="yes" xml:space="preserve">
          <source>This operator is implemented using the standard &lt;code&gt;File::Glob&lt;/code&gt; extension. See &lt;a href=&quot;File::Glob&quot;&gt;File::Glob&lt;/a&gt; for details, including &lt;a href=&quot;File::Glob#bsd_glob&quot;&gt;&lt;code&gt;bsd_glob&lt;/code&gt;&lt;/a&gt;, which does not treat whitespace as a pattern separator.</source>
          <target state="translated">使用标准 &lt;code&gt;File::Glob&lt;/code&gt; 扩展名实现此运算符。有关详细信息，请参见&lt;a href=&quot;File::Glob&quot;&gt;File :: Glob&lt;/a&gt;，包括&lt;a href=&quot;File::Glob#bsd_glob&quot;&gt; &lt;code&gt;bsd_glob&lt;/code&gt; &lt;/a&gt;，它不会将空格视为模式分隔符。</target>
        </trans-unit>
        <trans-unit id="157d8ec0928a934391402a13da061adc37466e6a" translate="yes" xml:space="preserve">
          <source>This operator is implemented using the standard &lt;code&gt;File::Glob&lt;/code&gt; extension. See &lt;a href=&quot;file/glob&quot;&gt;File::Glob&lt;/a&gt; for details, including &lt;code&gt;bsd_glob&lt;/code&gt; which does not treat whitespace as a pattern separator.</source>
          <target state="translated">该操作符使用标准 &lt;code&gt;File::Glob&lt;/code&gt; 扩展名实现。有关详细信息，请参见&lt;a href=&quot;file/glob&quot;&gt;File :: Glob&lt;/a&gt;，包括 &lt;code&gt;bsd_glob&lt;/code&gt; ，它不将空格视为模式分隔符。</target>
        </trans-unit>
        <trans-unit id="6deb73d137130c497b09a54c077553c29fbcaf55" translate="yes" xml:space="preserve">
          <source>This operator is implemented via the &lt;a href=&quot;File::Glob&quot;&gt;&lt;code&gt;File::Glob&lt;/code&gt;&lt;/a&gt; extension on most platforms. See &lt;a href=&quot;File::Glob&quot;&gt;File::Glob&lt;/a&gt; for portability information.</source>
          <target state="translated">在大多数平台上，该操作符都是通过&lt;a href=&quot;File::Glob&quot;&gt; &lt;code&gt;File::Glob&lt;/code&gt; &lt;/a&gt;扩展名实现的。有关可移植性信息，请参见&lt;a href=&quot;File::Glob&quot;&gt;File :: Glob&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a18ef89c767fe3092cd7cbf7617a73212c9cedcd" translate="yes" xml:space="preserve">
          <source>This operator is implemented via the &lt;code&gt;File::Glob&lt;/code&gt; extension on most platforms. See &lt;a href=&quot;file/glob&quot;&gt;File::Glob&lt;/a&gt; for portability information.</source>
          <target state="translated">在大多数平台上，该操作符都是通过 &lt;code&gt;File::Glob&lt;/code&gt; 扩展名实现的。有关可移植性信息，请参见&lt;a href=&quot;file/glob&quot;&gt;File :: Glob&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f61ddb296f9de510c527089fa0d0e6f18a12bcc4" translate="yes" xml:space="preserve">
          <source>This operator quotes (and possibly compiles) its</source>
          <target state="translated">这个运算符引用(也可能是编译)它的</target>
        </trans-unit>
        <trans-unit id="54ff6006dac029e4037de4f8be15a2519fa996e2" translate="yes" xml:space="preserve">
          <source>This option allow the</source>
          <target state="translated">该选项允许</target>
        </trans-unit>
        <trans-unit id="00bfef75bba78bb67546c7867c9c5ceacd8cc589" translate="yes" xml:space="preserve">
          <source>This option allow the filename field in the zip header to be modified before it is written to the zip file.</source>
          <target state="translated">这个选项允许在压缩文件写入之前修改压缩文件头的文件名。</target>
        </trans-unit>
        <trans-unit id="31a1073c0be295447c4fa6a92df15986893583ac" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;anyinflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于任何输入或输出数据流 &lt;code&gt;anyinflate&lt;/code&gt; 是文件句柄。</target>
        </trans-unit>
        <trans-unit id="f9285c30af9b4fbbee720f406a006d97f4010015" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;anyuncompress&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于任何以文件句柄 &lt;code&gt;anyuncompress&lt;/code&gt; 输入或输出数据流。</target>
        </trans-unit>
        <trans-unit id="e84a1d77a7ad064325b540c87fc270941af6172d" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;bunzip2&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于文件处理程序 &lt;code&gt;bunzip2&lt;/code&gt; 的任何输入或输出数据流。</target>
        </trans-unit>
        <trans-unit id="991318af65c036237347589558cc5bbc7b747313" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;bzip2&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于文件句柄到 &lt;code&gt;bzip2&lt;/code&gt; 的任何输入或输出数据流。</target>
        </trans-unit>
        <trans-unit id="e3937b065e9e10f42a614e20da537cf76f206b09" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;deflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于所有要 &lt;code&gt;deflate&lt;/code&gt; 输入或输出数据流，即文件句柄。</target>
        </trans-unit>
        <trans-unit id="7597a37aa86998ead804f6646d406a8232322d5c" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;gunzip&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于文件句柄的所有输入或输出到 &lt;code&gt;gunzip&lt;/code&gt; 的数据流。</target>
        </trans-unit>
        <trans-unit id="3b1d88507893c4f30c1f99b3dd08ad9bcc7749d4" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;gzip&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于任何输入或输出数据流 &lt;code&gt;gzip&lt;/code&gt; 的是文件句柄。</target>
        </trans-unit>
        <trans-unit id="197d2e92c12a668b61b45cede98ce89082acf98a" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;inflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于任何要 &lt;code&gt;inflate&lt;/code&gt; 输入或输出数据流，即文件句柄。</target>
        </trans-unit>
        <trans-unit id="11085e39e2558052d844319712c721f6cf03a406" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;rawdeflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于任何要作为文件句柄进行 &lt;code&gt;rawdeflate&lt;/code&gt; 的输入或输出数据流。</target>
        </trans-unit>
        <trans-unit id="5edfb063fb42d1f72af8e3277ad4716ba885c487" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;rawinflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于任何 &lt;code&gt;rawinflate&lt;/code&gt; 的文件句柄输入或输出数据流。</target>
        </trans-unit>
        <trans-unit id="8b0f73e1567ccae83577dd7200eae7bda2188288" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;unzip&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于任何要 &lt;code&gt;unzip&lt;/code&gt; 输入或输出数据流，即文件句柄。</target>
        </trans-unit>
        <trans-unit id="295f0cfd4ded98b9574af22ae3b9d33935ef4669" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;zip&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于所有作为文件句柄的 &lt;code&gt;zip&lt;/code&gt; 输入或输出数据流。</target>
        </trans-unit>
        <trans-unit id="1b0f39997327947c35396eb3046f132a2237f087" translate="yes" xml:space="preserve">
          <source>This option assumes that the formatter (see above) understands the option &quot;utf8&quot;. It turns on generation of utf8 output.</source>
          <target state="translated">该选项假定格式化器(见上文)理解 &quot;utf8 &quot;选项。它开启了生成utf8输出的功能。</target>
        </trans-unit>
        <trans-unit id="2812ec45ee9aa481cedeafcd91c6fd310ce87a63" translate="yes" xml:space="preserve">
          <source>This option can be used when there is useful information immediately following the compressed data stream, and you don't know the length of the compressed data stream.</source>
          <target state="translated">当压缩数据流之后紧接着有有用的信息,而你又不知道压缩数据流的长度时,可以使用这个选项。</target>
        </trans-unit>
        <trans-unit id="96e75df71c1bf6e90ec730c6cdd32614d5b40bf0" translate="yes" xml:space="preserve">
          <source>This option can be useful when the compressed data is embedded in another file/data structure and it is not possible to work out where the compressed data begins without having to read the first few bytes. If this is the case, the uncompression can be</source>
          <target state="translated">当压缩的数据被嵌入到另一个文件/数据结构中,如果不读取前几个字节,就不可能找出压缩数据的起点时,这个选项就很有用。在这种情况下,解压缩可以是</target>
        </trans-unit>
        <trans-unit id="ae71b12d470fda92f5396caeec200106ff4f6bc5" translate="yes" xml:space="preserve">
          <source>This option can be useful when you are processing compressed data that is embedded in another file/buffer. In this case the data that immediately follows the compressed stream will be left in the input buffer.</source>
          <target state="translated">当你在处理嵌入在另一个文件/缓冲区中的压缩数据时,这个选项很有用。在这种情况下,紧接着压缩流的数据将被留在输入缓冲区中。</target>
        </trans-unit>
        <trans-unit id="05c5aace4afdf3704689266ed36cfe4a30bb343e" translate="yes" xml:space="preserve">
          <source>This option causes all configuration options to be reset to their default values as if the environment variable POSIXLY_CORRECT had been set.</source>
          <target state="translated">这个选项会使所有的配置选项重置为默认值,就像设置了环境变量POSIXLY_CORRECT一样。</target>
        </trans-unit>
        <trans-unit id="0bb7609607b04e591708c21193516c45ee13b415" translate="yes" xml:space="preserve">
          <source>This option causes all configuration options to be reset to their default values.</source>
          <target state="translated">该选项将使所有配置选项重置为默认值。</target>
        </trans-unit>
        <trans-unit id="96a82215c08e826a1eb80ae96999f098e98a4ee7" translate="yes" xml:space="preserve">
          <source>This option controls how data is written to the output buffer by the &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; and &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; methods.</source>
          <target state="translated">此选项控制如何通过 &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; 和 &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; 方法将数据写入输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="c90b7070ba70482f3b4e42afba1dbe1ff165436c" translate="yes" xml:space="preserve">
          <source>This option controls how data is written to the output buffer by the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method.</source>
          <target state="translated">此选项控制如何通过 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 方法将数据写入输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="f091361d33604fb6b604c6198e130966342f9758" translate="yes" xml:space="preserve">
          <source>This option controls setting of the &quot;Language Encoding Flag&quot; (EFS) in the zip archive. When set, the filename and comment fields for the zip archive MUST be valid UTF-8.</source>
          <target state="translated">这个选项控制压缩包中 &quot;语言编码标志&quot;(EFS)的设置。设置后,压缩包的文件名和注释字段必须是有效的UTF-8。</target>
        </trans-unit>
        <trans-unit id="59041bc47f2bcbc25e18c7446422e8f7a244ca3a" translate="yes" xml:space="preserve">
          <source>This option controls the &quot;external file attributes&quot; field in the central header of the zip file. This is a 4 byte field.</source>
          <target state="translated">这个选项控制了压缩文件中心头的 &quot;外部文件属性 &quot;字段。这是一个4字节的字段。</target>
        </trans-unit>
        <trans-unit id="fe53ff997f22ee3b8e3b5b499037b30213ed7a2b" translate="yes" xml:space="preserve">
          <source>This option controls what the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method does with uncompressed data.</source>
          <target state="translated">此选项控制 &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 方法对未压缩数据的处理方式。</target>
        </trans-unit>
        <trans-unit id="6b761971204df65aacb52bae227edf353dc4466e" translate="yes" xml:space="preserve">
          <source>This option controls what the &lt;code&gt;read&lt;/code&gt; method does with uncompressed data.</source>
          <target state="translated">此选项控制 &lt;code&gt;read&lt;/code&gt; 方法对未压缩数据的处理方式。</target>
        </trans-unit>
        <trans-unit id="de120c739ea57e22d8c4d48b8a92202db6758c8d" translate="yes" xml:space="preserve">
          <source>This option controls whether the</source>
          <target state="translated">该选项控制是否在</target>
        </trans-unit>
        <trans-unit id="2fd5bc077a448b0ac8688176c0355190f56eee1f" translate="yes" xml:space="preserve">
          <source>This option controls whether the extra checks defined below are used when carrying out the decompression. When Strict is on, the extra tests are carried out, when Strict is off they are not.</source>
          <target state="translated">这个选项控制在进行减压时是否使用下面定义的额外检查。当Strict开启时,会进行额外的检查,当Strict关闭时,则不会进行额外的检查。</target>
        </trans-unit>
        <trans-unit id="e8f91b605f96e49eba45a2533f216bb9aa5630d4" translate="yes" xml:space="preserve">
          <source>This option controls whether the filename field in the zip header is</source>
          <target state="translated">这个选项可以控制zip头中的文件名字段是否是</target>
        </trans-unit>
        <trans-unit id="c9ccbe84ff4c87c8d1938d3fb3bc36c35924a163" translate="yes" xml:space="preserve">
          <source>This option controls whether the zip file/buffer output is created in streaming mode.</source>
          <target state="translated">该选项控制是否在流媒体模式下创建zip文件/缓冲区输出。</target>
        </trans-unit>
        <trans-unit id="25df283cc49b2b02eee383b551fc895c82bca588" translate="yes" xml:space="preserve">
          <source>This option defaults to 1.</source>
          <target state="translated">此选项默认为1。</target>
        </trans-unit>
        <trans-unit id="34b650f76678c6a01e22f15770dea69e53718082" translate="yes" xml:space="preserve">
          <source>This option defaults to 4096.</source>
          <target state="translated">这个选项的默认值是4096。</target>
        </trans-unit>
        <trans-unit id="d5f2929171736f86edabd8e4e81e6b76f585f308" translate="yes" xml:space="preserve">
          <source>This option defaults to &lt;b&gt;false&lt;/b&gt;.</source>
          <target state="translated">此选项默认为&lt;b&gt;false&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="0fe4b53be5e0e4b306e7b8817dee109e7d56e3b6" translate="yes" xml:space="preserve">
          <source>This option defaults to false.</source>
          <target state="translated">该选项默认为false。</target>
        </trans-unit>
        <trans-unit id="3c17c5d6de4659d46fac1329201d45aebab6728c" translate="yes" xml:space="preserve">
          <source>This option defaults to off.</source>
          <target state="translated">该选项默认为关闭。</target>
        </trans-unit>
        <trans-unit id="5b6fb11ab3c3f09a5247ca571c81e532a6439637" translate="yes" xml:space="preserve">
          <source>This option defaults to true.</source>
          <target state="translated">该选项默认为 &quot;true&quot;。</target>
        </trans-unit>
        <trans-unit id="624b5280811765e3f408f9a93ba973e345e22b11" translate="yes" xml:space="preserve">
          <source>This option does not affect &lt;code&gt;decode&lt;/code&gt; in any way, and it is recommended to leave it off unless you know your communications partner.</source>
          <target state="translated">此选项不会以任何方式影响 &lt;code&gt;decode&lt;/code&gt; ，除非您知道您的通讯伙伴，否则建议将其保留。</target>
        </trans-unit>
        <trans-unit id="a49b3dde1d982fff6659af9dbc370e4c81b2a251" translate="yes" xml:space="preserve">
          <source>This option expects an array reference with exactly three elements: &lt;code&gt;$atime&lt;/code&gt; , &lt;code&gt;mtime&lt;/code&gt; and &lt;code&gt;$ctime&lt;/code&gt; . These correspond to the last access time, last modification time and creation time respectively.</source>
          <target state="translated">该选项期望一个数组引用完全包含三个元素： &lt;code&gt;$atime&lt;/code&gt; ， &lt;code&gt;mtime&lt;/code&gt; 和 &lt;code&gt;$ctime&lt;/code&gt; 。这些分别对应于最后访问时间，最后修改时间和创建时间。</target>
        </trans-unit>
        <trans-unit id="c2b6d8d1bd2aae66f05f52544cf5abb5b8808045" translate="yes" xml:space="preserve">
          <source>This option expects an array reference with exactly three elements: &lt;code&gt;$atime&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt; and &lt;code&gt;$ctime&lt;/code&gt;. These correspond to the last access time, last modification time and creation time respectively.</source>
          <target state="translated">该选项期望一个数组引用具有正好三个元素： &lt;code&gt;$atime&lt;/code&gt; ， &lt;code&gt;mtime&lt;/code&gt; 和 &lt;code&gt;$ctime&lt;/code&gt; 。这些分别对应于最后访问时间，最后修改时间和创建时间。</target>
        </trans-unit>
        <trans-unit id="d7b61a9548815335c12044934c6edf6afc0fade2" translate="yes" xml:space="preserve">
          <source>This option expects an array reference with exactly two elements: &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . These values correspond to the numeric User ID (UID) and Group ID (GID) of the owner of the files respectively.</source>
          <target state="translated">该选项期望一个数组引用具有两个元素： &lt;code&gt;$uid&lt;/code&gt; 和 &lt;code&gt;$gid&lt;/code&gt; 。这些值分别对应于文件所有者的数字用户ID（UID）和组ID（GID）。</target>
        </trans-unit>
        <trans-unit id="d0b2b2035706e5f13fabb6689eb4b2eb10e5bd8d" translate="yes" xml:space="preserve">
          <source>This option expects an array reference with exactly two elements: &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt;. These values correspond to the numeric User ID (UID) and Group ID (GID) of the owner of the files respectively.</source>
          <target state="translated">该选项需要一个数组引用，其中包含两个元素： &lt;code&gt;$uid&lt;/code&gt; 和 &lt;code&gt;$gid&lt;/code&gt; 。这些值分别对应于文件所有者的数字用户ID（UID）和组ID（GID）。</target>
        </trans-unit>
        <trans-unit id="f5e3123268242816c97985ddf2abce0d046136ba" translate="yes" xml:space="preserve">
          <source>This option is a no-op.</source>
          <target state="translated">这个选项是一个无选项。</target>
        </trans-unit>
        <trans-unit id="1144456033d4b378e77675f24087a7a175d1be93" translate="yes" xml:space="preserve">
          <source>This option is case-insensitive.</source>
          <target state="translated">此选项不区分大小写。</target>
        </trans-unit>
        <trans-unit id="2511f05b6374c7879cb361cf57c595c2e2f72590" translate="yes" xml:space="preserve">
          <source>This option is checked when you write out the tarfile using &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;create_archive&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;create_archive&lt;/code&gt; 写入 tarfile时，将选中此选项。</target>
        </trans-unit>
        <trans-unit id="af51699e95a4be95b5bd98b672ad39e412c5139b" translate="yes" xml:space="preserve">
          <source>This option is checked when you write out the tarfile using &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;create_archive&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;write&lt;/code&gt; 或 &lt;code&gt;create_archive&lt;/code&gt; 写入tarfile时，将选中此选项。</target>
        </trans-unit>
        <trans-unit id="1b2a2a4f5928dc68068bb78c6282de092775a8e0" translate="yes" xml:space="preserve">
          <source>This option is enabled by default.</source>
          <target state="translated">该选项默认为启用。</target>
        </trans-unit>
        <trans-unit id="4549d37c19966c81c9e8c6bc7457a6a5da6fd6d3" translate="yes" xml:space="preserve">
          <source>This option is mostly used when reading from a filehandle, in which case the file pointer will be left pointing to the first byte directly after the compressed data stream.</source>
          <target state="translated">这个选项主要用于从文件柄读取时,在这种情况下,文件指针将直接指向压缩数据流后的第一个字节。</target>
        </trans-unit>
        <trans-unit id="da3c768aaf3f5e035f976487f87837b11b5b30c6" translate="yes" xml:space="preserve">
          <source>This option is no longer supported. It is still documented only to aid in the debugging of old programs that use it. Old programs should be converted to use the &lt;code&gt;HASH&lt;/code&gt; option instead.</source>
          <target state="translated">不再支持此选项。它仍然被记录只是为了帮助调试使用它的旧程序。应将旧程序转换为使用 &lt;code&gt;HASH&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="fccd188df214a961ab3c96d3b8cb198aeb990733" translate="yes" xml:space="preserve">
          <source>This option is now a no-op. All files will be read in binmode.</source>
          <target state="translated">这个选项现在是一个无选项。所有文件都将以binmode方式读取。</target>
        </trans-unit>
        <trans-unit id="4b63a00edd9e5158832afdb166a9cf7c92fa6736" translate="yes" xml:space="preserve">
          <source>This option is now a no-op. All files will be written in binmode.</source>
          <target state="translated">这个选项现在是一个无选项。所有文件都将以binmode方式写入。</target>
        </trans-unit>
        <trans-unit id="a4a6ba823380e81c3792a98e87160d5e375b14e6" translate="yes" xml:space="preserve">
          <source>This option is obscure and discouraged.</source>
          <target state="translated">这个方案晦涩难懂,不鼓励。</target>
        </trans-unit>
        <trans-unit id="42ae6c8b76763d5e46a026474b931ab7a98558cf" translate="yes" xml:space="preserve">
          <source>This option is only useful when you also enable &lt;code&gt;indent&lt;/code&gt; or &lt;code&gt;pretty&lt;/code&gt;.</source>
          <target state="translated">仅当您还启用 &lt;code&gt;indent&lt;/code&gt; 或 &lt;code&gt;pretty&lt;/code&gt; 时，此选项才有用。</target>
        </trans-unit>
        <trans-unit id="c86f3c4424a2a7c5541c3bc97e781d1a1d2bf31e" translate="yes" xml:space="preserve">
          <source>This option is only valid if the &lt;code&gt;Method&lt;/code&gt; is ZIP_CM_BZIP2. It is ignored otherwise.</source>
          <target state="translated">仅当 &lt;code&gt;Method&lt;/code&gt; 为ZIP_CM_BZIP2时，此选项才有效。否则将被忽略。</target>
        </trans-unit>
        <trans-unit id="e287076e946d3a88fdf8e217ada09ffe773941d3" translate="yes" xml:space="preserve">
          <source>This option is only valid if the &lt;code&gt;Method&lt;/code&gt; is ZIP_CM_LZMA. It is ignored otherwise.</source>
          <target state="translated">仅当 &lt;code&gt;Method&lt;/code&gt; 为ZIP_CM_LZMA时，此选项才有效。否则将被忽略。</target>
        </trans-unit>
        <trans-unit id="e47f433c8815bcca005cf8fc1f8f226523161029" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::AnyInflate object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定且值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁IO :: Uncompress :: AnyInflate对象，将导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="4c7afb5a8e42acbe0e34fc5f5b8fc4326a8529d5" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::AnyUncompress object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定且值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁IO :: Uncompress :: AnyUncompress对象，将导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="4c90c6efe9d75228bc8980202147dbd8e5b1d098" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::Bunzip2 object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁IO :: Uncompress :: Bunzip2对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="1a0451d52242cab341bf29b753116dd306cc10b7" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::Gunzip object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定且值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁IO :: Uncompress :: Gunzip对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="c6cccd64b3f769d6fde655234d1c117fd17fbdc4" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::Inflate object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且其值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁IO :: Uncompress :: Inflate对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="a026bdcb25c56dbca754467a3829013c39db31ac" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::RawInflate object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁IO :: Uncompress :: RawInflate对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="f4a3d8b2fb37fa80663bb31ac23a1f0cc61d52e6" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::Unzip object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定且值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁IO :: Uncompress :: Unzip对象，将导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="7d5c3c251f79fe2eaa4fe4d7a23aa2a6bca07482" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;close&lt;/code&gt; method is called or the IO::Uncompress::AnyInflate object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;close&lt;/code&gt; 方法或销毁IO :: Uncompress :: AnyInflate对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="3d188554dc39b169a30f806b5e23d40f7a99eb7b" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;close&lt;/code&gt; method is called or the IO::Uncompress::AnyUncompress object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;close&lt;/code&gt; 方法或销毁IO :: Uncompress :: AnyUncompress对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="3f4a9ffa852a02dca76d7971b32b9b03b1b0548e" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;close&lt;/code&gt; method is called or the IO::Uncompress::Bunzip2 object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;close&lt;/code&gt; 方法或销毁IO :: Uncompress :: Bunzip2对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="c5731a807a44b0efd83e01b27cd42579c0decc4f" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;close&lt;/code&gt; method is called or the IO::Uncompress::Gunzip object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，则该值为true，则一旦调用 &lt;code&gt;close&lt;/code&gt; 方法或销毁IO :: Uncompress :: Gunzip对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="c914c62b296246924f7d16024e2d19fb089beb85" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;close&lt;/code&gt; method is called or the IO::Uncompress::Inflate object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定且值为true，则一旦调用 &lt;code&gt;close&lt;/code&gt; 方法或销毁IO :: Uncompress :: Inflate对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="f153a0b32df251638a7035a515776badf9702bbd" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;close&lt;/code&gt; method is called or the IO::Uncompress::RawInflate object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;close&lt;/code&gt; 方法或销毁IO :: Uncompress :: RawInflate对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="f93ba06c93cb1edfc319d39e770c284a6a951d1c" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;close&lt;/code&gt; method is called or the IO::Uncompress::Unzip object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;close&lt;/code&gt; 方法或销毁IO :: Uncompress :: Unzip对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="a47e1179435d09c1507a883d5e990db962771a45" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="97fb53611300748a1b7f47bb19f220d7d3bb2490" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="258816e7ba3830736405fb29e1fd5aa78fa1b61a" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，则该值为true，一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="33f553ec8eed6ca2655d0af84e094c777ea4ac37" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且其值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="29176bb9d55bdad6e9210947b4806edcc6d975b2" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Zip&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且其值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="cd203a3578c6d44aadc174b3929c5c881fa57c87" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;close&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果已指定，且值为true，则一旦调用 &lt;code&gt;close&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="56da4e99c55becf3b53cd4d42c1b2e502f1ea8c7" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;close&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;close&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="0cc6b1d042bb75b4b7fcc3f65e4f36863f08ff6d" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;close&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;close&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="c22a83808dec6742b1149a03e8a657bbf97e963e" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;close&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;close&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="333c8c80db020065477b7b5bfd9c001421d17d16" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;close&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Zip&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;close&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="4776439da220ae2064b194f480e3edc29818500b" translate="yes" xml:space="preserve">
          <source>This option is probably not useful when converting multiple POD files at once.</source>
          <target state="translated">当一次转换多个POD文件时,这个选项可能没有用。</target>
        </trans-unit>
        <trans-unit id="f4da7e81811658139a241d2fcf49caaf6fc6d794" translate="yes" xml:space="preserve">
          <source>This option is significantly slower than the other one.</source>
          <target state="translated">这个方案比另一个方案要慢很多。</target>
        </trans-unit>
        <trans-unit id="43ce55b0c5bee0085af75b3bb5923ccf3a65b644" translate="yes" xml:space="preserve">
          <source>This option is used to compress input data and append it to an existing compressed data stream in &lt;code&gt;$output&lt;/code&gt; . The end result is a single compressed data stream stored in &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">此选项用于压缩输入数据并将其附加到 &lt;code&gt;$output&lt;/code&gt; 现有的压缩数据流中。最终结果是存储在 &lt;code&gt;$output&lt;/code&gt; 的单个压缩数据流。</target>
        </trans-unit>
        <trans-unit id="089ecebdfe8e9a90db3b6de20d411724738cdf04" translate="yes" xml:space="preserve">
          <source>This option is used to compress input data and append it to an existing compressed data stream in &lt;code&gt;$output&lt;/code&gt;. The end result is a single compressed data stream stored in &lt;code&gt;$output&lt;/code&gt;.</source>
          <target state="translated">此选项用于压缩输入数据并将其附加到 &lt;code&gt;$output&lt;/code&gt; 现有的压缩数据流中。最终结果是将单个压缩数据流存储在 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad95728c1dff8ec162453b97551677cbbf3088e0" translate="yes" xml:space="preserve">
          <source>This option is used to explicitly set the</source>
          <target state="translated">此选项用于明确设置</target>
        </trans-unit>
        <trans-unit id="4f49f5c4b9fe97ea0c9160e42ef7f17004bd5369" translate="yes" xml:space="preserve">
          <source>This option is useful if you want the same data structure to be encoded as the same JSON text (given the same overall settings). If it is disabled, the same hash might be encoded differently even if contains the same data, as key-value pairs have no inherent ordering in Perl.</source>
          <target state="translated">如果你想让相同的数据结构被编码为相同的JSON文本(给定相同的整体设置),这个选项是有用的。如果禁用该选项,即使包含相同的数据,相同的散列也可能会有不同的编码,因为在Perl中键值对没有固有的排序。</target>
        </trans-unit>
        <trans-unit id="2784a12c385481925ffdf8f295738fd39dfe4239" translate="yes" xml:space="preserve">
          <source>This option may be useful when you embed JSON in HTML, but embedding arbitrary JSON in HTML (by some HTML template toolkit or by string interpolation) is risky in general. You must escape necessary characters in correct order, depending on the context.</source>
          <target state="translated">当你在HTML中嵌入JSON时,这个选项可能很有用,但在HTML中嵌入任意JSON(通过一些HTML模板工具包或通过字符串插值)一般来说是有风险的。你必须根据上下文,以正确的顺序转义必要的字符。</target>
        </trans-unit>
        <trans-unit id="c905ba8910d975a79e749c35e513e95ca43f84ed" translate="yes" xml:space="preserve">
          <source>This option means that you want to limit the results just to items whose podnames match the given glob/wildcard expression. For example, you might limit your search to just &quot;LWP::*&quot;, to search only for modules starting with &quot;LWP::*&quot; (but not including the module &quot;LWP&quot; itself); or you might limit your search to &quot;LW*&quot; to see only modules whose (full) names begin with &quot;LW&quot;; or you might search for &quot;*Find*&quot; to search for all modules with &quot;Find&quot; somewhere in their full name. (You can also use &quot;?&quot; in a glob expression; so &quot;DB?&quot; will match &quot;DBI&quot; and &quot;DBD&quot;.)</source>
          <target state="translated">这个选项的意思是,你想把搜索结果限制在podnames符合给定的glob/wildcard表达式的项目上。例如,您可以将搜索结果限制为 &quot;LWP::*&quot;,只搜索以 &quot;LWP::*&quot;开头的模块(但不包括 &quot;LWP &quot;模块本身);或者您可以将搜索结果限制为 &quot;LW*&quot;。(但不包括模块 &quot;LWP &quot;本身);或者您可以将搜索范围限制为 &quot;LW*&quot;,只看到全名以 &quot;LW &quot;开头的模块;或者您可以搜索 &quot;*Find*&quot;,以搜索所有全名中带有 &quot;Find &quot;的模块。(您也可以在 glob 表达式中使用&quot;?&quot;;所以 &quot;DB? &quot;将匹配 &quot;DBI &quot;和 &quot;DBD&quot;)。</target>
        </trans-unit>
        <trans-unit id="20360642d3c9e99dc2a287f8242c272ca5705a34" translate="yes" xml:space="preserve">
          <source>This option says to instead output literal UTF-8 characters. If your *roff implementation can handle it, this is the best output format to use and avoids corruption of documents containing non-ASCII characters. However, be warned that *roff source with literal UTF-8 characters is not supported by many implementations and may even result in segfaults and other bad behavior.</source>
          <target state="translated">这个选项说,而是输出UTF-8字样的字符。如果你的*roff实现能够处理它,这是最好的输出格式,可以避免包含非ASCII字符的文档损坏。但是,要注意的是,许多实现并不支持使用UTF-8字符的*roff源码,甚至可能导致segfaults和其他不良行为。</target>
        </trans-unit>
        <trans-unit id="198821065f8114e37c282b1dc5e2e1e562fb79c1" translate="yes" xml:space="preserve">
          <source>This option takes a parameter that must be a reference to a sub. On entry to the sub the &lt;code&gt;$_&lt;/code&gt; variable will contain the name to be filtered. If no filename is available &lt;code&gt;$_&lt;/code&gt; will contain an empty string.</source>
          <target state="translated">此选项采用的参数必须是对子项的引用。在进入子目录时， &lt;code&gt;$_&lt;/code&gt; 变量将包含要过滤的名称。如果没有可用的文件名， &lt;code&gt;$_&lt;/code&gt; 将包含一个空字符串。</target>
        </trans-unit>
        <trans-unit id="3c97397612f397cc9803106ff617ed57fcd7bbdd" translate="yes" xml:space="preserve">
          <source>This option was introduced to let you easily customize which</source>
          <target state="translated">这个选项的引入是为了让您轻松地定制哪些</target>
        </trans-unit>
        <trans-unit id="478ef92f533a2a64ed38715adae3641923596540" translate="yes" xml:space="preserve">
          <source>This option will uncompress the contents of &lt;code&gt;$string&lt;/code&gt; before processing the input file/buffer.</source>
          <target state="translated">此选项将在处理输入文件/缓冲区之前解压缩 &lt;code&gt;$string&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="94e79c8cc707f4d220ebc5676b2e7c094b43e26e" translate="yes" xml:space="preserve">
          <source>This option, if set to a true value, suppresses the URL when anchor text is given, so this example would be formatted as just &lt;code&gt;foo&lt;/code&gt; . This can produce less cluttered output in cases where the URLs are not particularly important.</source>
          <target state="translated">如果将此选项设置为true值，则在给出锚文本时将禁止显示URL，因此此示例的格式将仅为 &lt;code&gt;foo&lt;/code&gt; 。在URL不是特别重要的情况下，这可以减少混乱的输出。</target>
        </trans-unit>
        <trans-unit id="3c093990608ad560cd2156838664c1a41d4353f2" translate="yes" xml:space="preserve">
          <source>This option, if set to a true value, suppresses the URL when anchor text is given, so this example would be formatted as just &lt;code&gt;foo&lt;/code&gt;. This can produce less cluttered output in cases where the URLs are not particularly important.</source>
          <target state="translated">如果将此选项设置为true值，则在给出锚文本时将禁止显示URL，因此此示例的格式将仅为 &lt;code&gt;foo&lt;/code&gt; 。在URL不是特别重要的情况下，这可以减少混乱的输出。</target>
        </trans-unit>
        <trans-unit id="d73e8a9fe84394bb733d349d80f809abc0c71549" translate="yes" xml:space="preserve">
          <source>This overload was introduced in Perl 5.12.</source>
          <target state="translated">这个重载是在Perl 5.12中引入的。</target>
        </trans-unit>
        <trans-unit id="80f1948b993b572ddd0ded00367d4480f0e1a9dd" translate="yes" xml:space="preserve">
          <source>This overrides all the default install locations. Man pages, libraries, scripts, etc... MakeMaker will try to make an educated guess about where to place things under the new PREFIX based on your Config defaults. Failing that, it will fall back to a structure which should be sensible for your platform.</source>
          <target state="translated">这将覆盖所有默认的安装位置。Man pages,libraries,scripts,etc...。MakeMaker会根据你的Config默认值来猜测新的Prefix的位置。如果做不到这一点,它将回到一个对你的平台来说应该是合理的结构。</target>
        </trans-unit>
        <trans-unit id="444e5337bdc60ac371985ae433717f80c0fb2273" translate="yes" xml:space="preserve">
          <source>This overrides the default behavior of &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; inside the newly created thread only.</source>
          <target state="translated">这将仅覆盖新创建的线程内 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 的默认行为。</target>
        </trans-unit>
        <trans-unit id="24a3ff23ecaa6a599f398f1b05a599f96ef89aff" translate="yes" xml:space="preserve">
          <source>This overrides the default behavior of &lt;code&gt;exit()&lt;/code&gt; inside the newly created thread only.</source>
          <target state="translated">这将仅覆盖新创建的线程内 &lt;code&gt;exit()&lt;/code&gt; 的默认行为。</target>
        </trans-unit>
        <trans-unit id="54817ecdea72dd0f8dad14e4e986821245f79bb0" translate="yes" xml:space="preserve">
          <source>This package &lt;code&gt;ISA&lt;/code&gt; IO::File, so that you can call IO::File methods on the handles returned by &lt;code&gt;vmsopen&lt;/code&gt; and &lt;code&gt;vmssysopen&lt;/code&gt;. The IO::File package is not initialized, however, until you actually call a method that VMS::Stdio doesn't provide. This is done to save startup time for users who don't wish to use the IO::File methods.</source>
          <target state="translated">该软件包 &lt;code&gt;ISA&lt;/code&gt; IO :: File，以便您可以在 &lt;code&gt;vmsopen&lt;/code&gt; 和 &lt;code&gt;vmssysopen&lt;/code&gt; 返回的句柄上调用IO :: File方法。但是，直到您实际调用VMS :: Stdio不提供的方法之前，IO :: File包才被初始化。这样做是为了为不希望使用IO :: File方法的用户节省启动时间。</target>
        </trans-unit>
        <trans-unit id="519b8612e911f1f56d7cf335d416b8b3e0b034ae" translate="yes" xml:space="preserve">
          <source>This package allows a tied hash to autoload its values on the first access, and to use the cached value on the following accesses.</source>
          <target state="translated">这个包允许绑定哈希在第一次访问时自动加载其值,并在随后的访问中使用缓存的值。</target>
        </trans-unit>
        <trans-unit id="0dd12631c6783b870d8636d280593396cecef2aa" translate="yes" xml:space="preserve">
          <source>This package assumes your instances are blessed hashrefs, it will not work if that is not true. It will store all meta-data in the &lt;code&gt;_meta&lt;/code&gt; key on your objects hash. If your object makes use of the &lt;code&gt;_meta&lt;/code&gt; key in its underlying hash, then there is a conflict and you cannot use this package.</source>
          <target state="translated">该程序包假定您的实例是有福的hashref，如果不正确，它将无法正常工作。它将所有元数据存储在对象哈希的 &lt;code&gt;_meta&lt;/code&gt; 键中。如果您的对象在其基础哈希中使用 &lt;code&gt;_meta&lt;/code&gt; 键，则存在冲突，您将无法使用此包。</target>
        </trans-unit>
        <trans-unit id="27ef3cf0031676169d1650659bd8ca01863df483" translate="yes" xml:space="preserve">
          <source>This package exports all the functions necessary to write and/or verify testing tools. Using these building blocks you can begin writing test tools very quickly. You are also provided with tools that help you to test the tools you write.</source>
          <target state="translated">该包导出了编写和/或验证测试工具所需的所有功能。使用这些构件,你可以很快地开始编写测试工具。同时,我们还为您提供了一些工具,帮助您测试您所编写的工具。</target>
        </trans-unit>
        <trans-unit id="24fee1df4d3c220048420e934bfa1571230d5dc6" translate="yes" xml:space="preserve">
          <source>This package gives Perl scripts access via VMS extensions to several C stdio operations not available through Perl's CORE I/O functions. The specific routines are described below. These functions are prototyped as unary operators, with the exception of &lt;code&gt;vmsopen&lt;/code&gt; and &lt;code&gt;vmssysopen&lt;/code&gt;, which can take any number of arguments, and &lt;code&gt;tmpnam&lt;/code&gt;, which takes none.</source>
          <target state="translated">该软件包使Perl脚本可以通过VMS扩展访问Perl的CORE I / O函数无法使用的几个C stdio操作。具体例程如下所述。这些函数被原型化为一元运算符，但 &lt;code&gt;vmsopen&lt;/code&gt; 和 &lt;code&gt;vmssysopen&lt;/code&gt; 除外，它们可以接受任意数量的参数，而 &lt;code&gt;tmpnam&lt;/code&gt; 则不包含任何参数。</target>
        </trans-unit>
        <trans-unit id="117523179eb4686be1091dc68328b55978f9a6f5" translate="yes" xml:space="preserve">
          <source>This package has an END block. This END block is responsible for setting the exit code based on the test results. This end block also calls the callbacks that can be added to this package.</source>
          <target state="translated">这个包有一个END块。这个END块负责根据测试结果设置退出代码。这个END块还调用了可以添加到这个包中的回调。</target>
        </trans-unit>
        <trans-unit id="52216942838934faafa12f993b9e33de2dc6a37f" translate="yes" xml:space="preserve">
          <source>This package has been part of the perl core since perl 5.001. It has been released separately to CPAN so older installations can benefit from bug fixes.</source>
          <target state="translated">这个软件包从perl 5.001开始就是perl核心的一部分。它已经单独发布到CPAN中,所以老版本的安装可以从错误修复中受益。</target>
        </trans-unit>
        <trans-unit id="a2c6b0ed0d74189431901579ee94937bb8d4ce64" translate="yes" xml:space="preserve">
          <source>This package has been part of the perl core since the first release of perl5. It has been released separately to CPAN so older installations can benefit from bug fixes.</source>
          <target state="translated">自 perl5 的第一个版本发布以来,这个软件包一直是 perl 核心的一部分。它已经单独发布到CPAN中,所以老版本的安装可以从错误修复中受益。</target>
        </trans-unit>
        <trans-unit id="8604a04f6b263dfa751e272224470b230a03d1e8" translate="yes" xml:space="preserve">
          <source>This package has the same copyright and license as the perl core.</source>
          <target state="translated">这个软件包的版权和许可证与perl核心相同。</target>
        </trans-unit>
        <trans-unit id="5b6805fe29e54bd4efe3c6b5cfa333a68b6dd7e7" translate="yes" xml:space="preserve">
          <source>This package has the same copyright and license as the perl core:</source>
          <target state="translated">这个软件包的版权和许可证与perl核心相同。</target>
        </trans-unit>
        <trans-unit id="3dd0926d44817739b9d6d9f6b9c878553eedc873" translate="yes" xml:space="preserve">
          <source>This package has the same functionality as CPAN.pm, but tries to prevent the usage of compiled extensions during its own execution. Its primary purpose is a rescue in case you upgraded perl and broke binary compatibility somehow.</source>
          <target state="translated">这个包的功能和CPAN.pm一样,但是试图防止在自己的执行过程中使用编译后的扩展。它的主要目的是在你升级perl并破坏了二进制兼容性的情况下进行拯救。</target>
        </trans-unit>
        <trans-unit id="5ec260b88b13584e3875f1a95d421c8de3085165" translate="yes" xml:space="preserve">
          <source>This package is free software and is provided &quot;as is&quot; without express or implied warranty. It may be used, redistributed and/or modified under the same terms as Perl itself.</source>
          <target state="translated">本软件包是免费软件,按 &quot;原样 &quot;提供,不做任何明示或暗示的保证。它可以在与Perl本身相同的条款下使用、重新分配和/或修改。</target>
        </trans-unit>
        <trans-unit id="8d169e6cde7a05a46328dee15bc92ea9fbd31c5a" translate="yes" xml:space="preserve">
          <source>This package is just a front end to some other packages. It's a stub to set up a common interface to the various ReadLine implementations found on CPAN (under the &lt;code&gt;Term::ReadLine::*&lt;/code&gt; namespace).</source>
          <target state="translated">该软件包只是其他一些软件包的前端。为CPAN上的各种ReadLine实现（在 &lt;code&gt;Term::ReadLine::*&lt;/code&gt; 名称空间下）建立通用接口是一个存根。</target>
        </trans-unit>
        <trans-unit id="b1ade6c9a8f018d0fad6780df5d177f32fbb0e0d" translate="yes" xml:space="preserve">
          <source>This package is meant as a base of Pod::Perldoc formatters, like &lt;a href=&quot;Pod::Perldoc::ToText&quot;&gt;Pod::Perldoc::ToText&lt;/a&gt;, &lt;a href=&quot;Pod::Perldoc::ToMan&quot;&gt;Pod::Perldoc::ToMan&lt;/a&gt;, etc.</source>
          <target state="translated">该软件包是Pod :: Perldoc格式化程序的基础，例如&lt;a href=&quot;Pod::Perldoc::ToText&quot;&gt;Pod :: Perldoc :: ToText&lt;/a&gt;，&lt;a href=&quot;Pod::Perldoc::ToMan&quot;&gt;Pod :: Perldoc :: ToMan&lt;/a&gt;等。</target>
        </trans-unit>
        <trans-unit id="ce76c6c4371370495517baf3705b461101fff8c7" translate="yes" xml:space="preserve">
          <source>This package is meant as a base of Pod::Perldoc formatters, like &lt;a href=&quot;totext&quot;&gt;Pod::Perldoc::ToText&lt;/a&gt;, &lt;a href=&quot;toman&quot;&gt;Pod::Perldoc::ToMan&lt;/a&gt;, etc.</source>
          <target state="translated">该软件包是Pod :: Perldoc格式化程序的基础，例如&lt;a href=&quot;totext&quot;&gt;Pod :: Perldoc :: ToText&lt;/a&gt;，&lt;a href=&quot;toman&quot;&gt;Pod :: Perldoc :: ToMan&lt;/a&gt;等。</target>
        </trans-unit>
        <trans-unit id="9180a230452e68871f0598e03ac17371f08687f4" translate="yes" xml:space="preserve">
          <source>This package is still a work in progress. ;-)</source>
          <target state="translated">这个包还在开发中;-)</target>
        </trans-unit>
        <trans-unit id="e14216db6d6f543013d22d6e863cfe0d56fedf31" translate="yes" xml:space="preserve">
          <source>This package is used to generate classes based on hashrefs. Using this class will give you a &lt;code&gt;new()&lt;/code&gt; method, as well as generating accessors you request. Generated accessors will be getters, &lt;code&gt;set_ACCESSOR&lt;/code&gt; setters will also be generated for you. You also get constants for each accessor (all caps) which return the key into the hash for that accessor. Single inheritance is also supported.</source>
          <target state="translated">该包用于基于哈希引用生成类。使用此类将为您提供 &lt;code&gt;new()&lt;/code&gt; 方法，并生成您请求的访问器。生成的访问器将是getters，还将为您生成 &lt;code&gt;set_ACCESSOR&lt;/code&gt; setters。您还可以获得每个访问器（所有大写字母）的常量，这些常量将密钥返回到该访问器的哈希中。还支持单继承。</target>
        </trans-unit>
        <trans-unit id="5132ab88c97f356a0cb81785c11fd445555c2f78" translate="yes" xml:space="preserve">
          <source>This package lets you create and manipulate complex numbers. By default,</source>
          <target state="translated">这个软件包可以让你创建和操作复杂的数字。默认情况下。</target>
        </trans-unit>
        <trans-unit id="a170bd1eff2041ac0d0ac79f2c0ec18d1fc8c0b5" translate="yes" xml:space="preserve">
          <source>This package lets you define a clear, and consistent way to allow third party tools to attach meta-data to your instances. If your object consumes this package, and imports its methods, then third party meta-data has a safe place to live.</source>
          <target state="translated">这个包可以让你定义一个清晰的、一致的方式来允许第三方工具将元数据附加到你的实例上。如果你的对象消费了这个包,并导入了它的方法,那么第三方元数据就有了一个安全的归宿。</target>
        </trans-unit>
        <trans-unit id="c027490dcb5b2efb5529d5116c08443a95ca1c4a" translate="yes" xml:space="preserve">
          <source>This package provides routines to simplify conversion between VMS and Unix syntax when processing file specifications. This is useful when porting scripts designed to run under either OS, and also allows you to take advantage of conveniences provided by either syntax (</source>
          <target state="translated">这个软件包提供了一些例程来简化处理文件规格时VMS和Unix语法之间的转换。这在移植设计为在任何一个操作系统下运行的脚本时都很有用,而且还允许你利用任何一种语法提供的便利条件 (</target>
        </trans-unit>
        <trans-unit id="11a96a3b10a148099f0b7f72edfecfa081ed012b" translate="yes" xml:space="preserve">
          <source>This package represents what is expected in units of amnesty.</source>
          <target state="translated">这套方案代表了预期的赦免单位。</target>
        </trans-unit>
        <trans-unit id="733cf8ccc54fc2caec2b129c7f9c3b8fe256f776" translate="yes" xml:space="preserve">
          <source>This package supplies the following functions, all of which should be called as methods.</source>
          <target state="translated">这个包提供了以下函数,所有这些函数都应该作为方法调用。</target>
        </trans-unit>
        <trans-unit id="3cfaecafb317f7a283c4d709b1fe33fabf00ba94" translate="yes" xml:space="preserve">
          <source>This package variable is used by code which needs to generate random numbers (such as the &lt;a href=&quot;#shuffle&quot;&gt;&quot;shuffle&quot;&lt;/a&gt; and &lt;a href=&quot;#sample&quot;&gt;&quot;sample&quot;&lt;/a&gt; functions). If set to a CODE reference it provides an alternative to perl's builtin &lt;code&gt;rand()&lt;/code&gt; function. When a new random number is needed this function will be invoked with no arguments and is expected to return a floating-point value, of which only the fractional part will be used.</source>
          <target state="translated">此程序包变量由需要生成随机数的代码使用（例如&lt;a href=&quot;#shuffle&quot;&gt;&amp;ldquo;随机播放&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;#sample&quot;&gt;&amp;ldquo;样本&amp;rdquo;&lt;/a&gt;函数）。如果设置为CODE引用，它可以替代perl的内置 &lt;code&gt;rand()&lt;/code&gt; 函数。当需要一个新的随机数时，该函数将不带任何参数地被调用，并期望返回一个浮点值，其中仅使用小数部分。</target>
        </trans-unit>
        <trans-unit id="0502ae210c839a0d5612b4c49c9ee0a00914b58d" translate="yes" xml:space="preserve">
          <source>This packs &lt;code&gt;3*@buffer&lt;/code&gt; bytes, but it turns out that the size of &lt;code&gt;buffer_t&lt;/code&gt; is four times &lt;code&gt;BUFLEN&lt;/code&gt; ! The moral of the story is that the required alignment of a structure or array is propagated to the next higher level where we have to consider padding</source>
          <target state="translated">这组 &lt;code&gt;3*@buffer&lt;/code&gt; 的字节，但事实证明，大小 &lt;code&gt;buffer_t&lt;/code&gt; 四倍 &lt;code&gt;BUFLEN&lt;/code&gt; ！这个故事的寓意是，将结构或数组的所需对齐方式传播到了我们必须考虑填充的下一个更高层次</target>
        </trans-unit>
        <trans-unit id="e53c590bd241b677c54acd7fcca9e80edc4d08e4" translate="yes" xml:space="preserve">
          <source>This packs &lt;code&gt;3*@buffer&lt;/code&gt; bytes, but it turns out that the size of &lt;code&gt;buffer_t&lt;/code&gt; is four times &lt;code&gt;BUFLEN&lt;/code&gt;! The moral of the story is that the required alignment of a structure or array is propagated to the next higher level where we have to consider padding</source>
          <target state="translated">这组 &lt;code&gt;3*@buffer&lt;/code&gt; 的字节，但事实证明，大小 &lt;code&gt;buffer_t&lt;/code&gt; 四倍 &lt;code&gt;BUFLEN&lt;/code&gt; ！这个故事的寓意是，将结构或数组的所需对齐方式传播到了我们必须考虑填充的下一个更高层次</target>
        </trans-unit>
        <trans-unit id="d6a4741dfc9d84d06564831e13aad41055715be9" translate="yes" xml:space="preserve">
          <source>This page assumes you already know things, like what a &quot;pattern&quot; is, and the basic syntax of using them. If you don't, see &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;.</source>
          <target state="translated">该页面假定您已经知道一些东西，例如&amp;ldquo;模式&amp;rdquo;是什么，以及使用它们的基本语法。如果不这样做，请参阅&lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="946e326f892b4b8b1ddce244173724cf9a7d1bb8" translate="yes" xml:space="preserve">
          <source>This page covers the very basics of understanding, creating and using regular expressions ('regexes') in Perl.</source>
          <target state="translated">本页介绍了如何理解、创建和使用Perl中的正则表达式('regexes')的基础知识。</target>
        </trans-unit>
        <trans-unit id="dce9886ab9b0a9a0def511caa51f7fe80e84aea2" translate="yes" xml:space="preserve">
          <source>This page describes the syntax of regular expressions in Perl.</source>
          <target state="translated">本页介绍Perl中正则表达式的语法。</target>
        </trans-unit>
        <trans-unit id="317e90a756283c2e548a97a6d078f31d1baf3825" translate="yes" xml:space="preserve">
          <source>This page provides a basic tutorial on understanding, creating and using regular expressions in Perl. It serves as a complement to the reference page on regular expressions &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;. Regular expressions are an integral part of the &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; operators and so this tutorial also overlaps with &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt; and &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">该页面提供了有关在Perl中理解，创建和使用正则表达式的基础教程。它是对正则表达式&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;的参考页的补充。正则表达式是 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 运算符的组成部分，因此本教程&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;在perlop&lt;/a&gt;和&lt;a href=&quot;functions/split&quot;&gt;split中&lt;/a&gt;也与Regexp Quote-Like运算符重叠。</target>
        </trans-unit>
        <trans-unit id="7d5a131e3270619460abdb9845cd688fb5a50600" translate="yes" xml:space="preserve">
          <source>This page provides a basic tutorial on understanding, creating and using regular expressions in Perl. It serves as a complement to the reference page on regular expressions &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;. Regular expressions are an integral part of the &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt;, &lt;code&gt;qr//&lt;/code&gt; and &lt;code&gt;split&lt;/code&gt; operators and so this tutorial also overlaps with &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt; and &lt;a href=&quot;perlfunc#split&quot;&gt;&quot;split&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">该页面提供了有关在Perl中理解，创建和使用正则表达式的基础教程。它是对正则表达式&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;的参考页的补充。正则表达式是 &lt;code&gt;m//&lt;/code&gt; ， &lt;code&gt;s///&lt;/code&gt; ， &lt;code&gt;qr//&lt;/code&gt; 和 &lt;code&gt;split&lt;/code&gt; 运算符的组成部分，因此本教程还与&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop中的&amp;ldquo; Regexp Quote-Like运算符&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;perlfunc#split&quot;&gt;perlfunc中的&amp;ldquo; split&amp;rdquo;&lt;/a&gt;重叠。</target>
        </trans-unit>
        <trans-unit id="5dd11d6815b6bbd5757b2908c5f7f36d9fc65ef7" translate="yes" xml:space="preserve">
          <source>This parameter allows additional metadata to be stored in the ExtraField in the gzip header. An RFC 1952 compliant ExtraField consists of zero or more subfields. Each subfield consists of a two byte header followed by the subfield data.</source>
          <target state="translated">该参数允许在gzip头的ExtraField中存储额外的元数据。符合RFC 1952标准的ExtraField由零个或多个子字段组成。每个子字段由一个两个字节的头和子字段数据组成。</target>
        </trans-unit>
        <trans-unit id="6c5f89c77abee951f08c51fc642a03fa6b870eac" translate="yes" xml:space="preserve">
          <source>This parameter controls the setting of a bit in the zip central header. It is used to signal that the data stored in the zip file/buffer is probably text.</source>
          <target state="translated">这个参数控制了zip中央头的一个位的设置。它用来提示存储在zip文件/缓冲区中的数据大概是文本。</target>
        </trans-unit>
        <trans-unit id="f7ab5c8a3bc9a88a9534a62193fcda4a2a345ca3" translate="yes" xml:space="preserve">
          <source>This parameter controls the setting of the FLG.FTEXT bit in the gzip header. It is used to signal that the data stored in the gzip file/buffer is probably text.</source>
          <target state="translated">这个参数控制gzip头中FLG.FTEXT位的设置。它用来表示存储在gzip文件/缓冲区中的数据可能是文本。</target>
        </trans-unit>
        <trans-unit id="1d135fdd7e0c9609625dc055c076f0bab706088f" translate="yes" xml:space="preserve">
          <source>This parameter defaults to 0.</source>
          <target state="translated">此参数默认为0。</target>
        </trans-unit>
        <trans-unit id="a954f8a244020c9f424e9822cfad5459a2f5fec4" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
          <target state="translated">该参数被忽略。</target>
        </trans-unit>
        <trans-unit id="3095070e85d1a1b0788b86dc1c47569b11d0ecb4" translate="yes" xml:space="preserve">
          <source>This parameter is used to specify the ambient pragmas which are stored in the special hash %^H.</source>
          <target state="translated">这个参数用于指定存储在特殊哈希%^H中的环境语法。</target>
        </trans-unit>
        <trans-unit id="aaafa45d95b04bd8c01708fb5fdd297ddbefc3b4" translate="yes" xml:space="preserve">
          <source>This parameter takes precedence over the &lt;code&gt;Local*&lt;/code&gt;, &lt;code&gt;Family&lt;/code&gt;, &lt;code&gt;Type&lt;/code&gt; and &lt;code&gt;Proto&lt;/code&gt; arguments.</source>
          <target state="translated">此参数优先于 &lt;code&gt;Local*&lt;/code&gt; ， &lt;code&gt;Family&lt;/code&gt; ， &lt;code&gt;Type&lt;/code&gt; 和 &lt;code&gt;Proto&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="144cb2f166d202c7f6fa31b74b5f72c47f93cb09" translate="yes" xml:space="preserve">
          <source>This parameter takes precedence over the &lt;code&gt;Peer*&lt;/code&gt;, &lt;code&gt;Family&lt;/code&gt;, &lt;code&gt;Type&lt;/code&gt; and &lt;code&gt;Proto&lt;/code&gt; arguments.</source>
          <target state="translated">此参数优先于 &lt;code&gt;Peer*&lt;/code&gt; ， &lt;code&gt;Family&lt;/code&gt; ， &lt;code&gt;Type&lt;/code&gt; 和 &lt;code&gt;Proto&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="e57f8e4024e58b80873e8cbfaa23d47d4d596bfc" translate="yes" xml:space="preserve">
          <source>This parameter works like &lt;code&gt;overrideCJK&lt;/code&gt; , so see there for examples.</source>
          <target state="translated">此参数的工作方式类似于 &lt;code&gt;overrideCJK&lt;/code&gt; ，因此请参见示例。</target>
        </trans-unit>
        <trans-unit id="51565d89891bf2948d91c1cc64dabcc98c8f8a0a" translate="yes" xml:space="preserve">
          <source>This parameter works like &lt;code&gt;overrideCJK&lt;/code&gt;, so see there for examples.</source>
          <target state="translated">此参数的工作方式类似于 &lt;code&gt;overrideCJK&lt;/code&gt; ，因此请参见示例。</target>
        </trans-unit>
        <trans-unit id="ac9494fe5df3170e77a2748f1c2b29eb01128b21" translate="yes" xml:space="preserve">
          <source>This pattern matches nothing and always fails. It can be used to force the engine to backtrack. It is equivalent to &lt;code&gt;(?!)&lt;/code&gt;, but easier to read. In fact, &lt;code&gt;(?!)&lt;/code&gt; gets optimised into &lt;code&gt;(*FAIL)&lt;/code&gt; internally.</source>
          <target state="translated">此模式不匹配，并且总是失败。它可以用来迫使引擎后退。它等效于 &lt;code&gt;(?!)&lt;/code&gt; ，但更易于阅读。实际上， &lt;code&gt;(?!)&lt;/code&gt; &lt;code&gt;(*FAIL)&lt;/code&gt; 内部被优化为（* FAIL）。</target>
        </trans-unit>
        <trans-unit id="6fc6c7ad71aa7736bfa3c0da48319c974555eb05" translate="yes" xml:space="preserve">
          <source>This pattern matches nothing and always fails. It can be used to force the engine to backtrack. It is equivalent to &lt;code&gt;(?!)&lt;/code&gt;, but easier to read. In fact, &lt;code&gt;(?!)&lt;/code&gt; gets optimised into &lt;code&gt;(*FAIL)&lt;/code&gt; internally. You can provide an argument so that if the match fails because of this &lt;code&gt;FAIL&lt;/code&gt; directive the argument can be obtained from &lt;code&gt;$REGERROR&lt;/code&gt;.</source>
          <target state="translated">此模式不匹配任何内容，并且始终失败。它可以用来迫使引擎后退。它等效于 &lt;code&gt;(?!)&lt;/code&gt; ，但更易于阅读。实际上， &lt;code&gt;(?!)&lt;/code&gt; &lt;code&gt;(*FAIL)&lt;/code&gt; 内部被优化为（* FAIL）。您可以提供一个参数，以便如果由于此 &lt;code&gt;FAIL&lt;/code&gt; 指令而导致匹配失败，则可以从 &lt;code&gt;$REGERROR&lt;/code&gt; 获得该参数。</target>
        </trans-unit>
        <trans-unit id="9d7331a8c75f2ab7015003fc1a186b402d4f4b0f" translate="yes" xml:space="preserve">
          <source>This pattern matches nothing and causes the end of successful matching at the point at which the &lt;code&gt;(*ACCEPT)&lt;/code&gt; pattern was encountered, regardless of whether there is actually more to match in the string. When inside of a nested pattern, such as recursion, or in a subpattern dynamically generated via &lt;code&gt;(??{})&lt;/code&gt; , only the innermost pattern is ended immediately.</source>
          <target state="translated">此模式不匹配任何内容，并导致在遇到 &lt;code&gt;(*ACCEPT)&lt;/code&gt; 模式时成功匹配结束，而不管字符串中实际上是否还有更多要匹配的内容。当在嵌套模式（例如递归）中或在通过 &lt;code&gt;(??{})&lt;/code&gt; 动态生成的子模式中时，仅最里面的模式立即结束。</target>
        </trans-unit>
        <trans-unit id="67ca6793aa1baf492f23da59c43d48ed60e5c55a" translate="yes" xml:space="preserve">
          <source>This pattern matches nothing and causes the end of successful matching at the point at which the &lt;code&gt;(*ACCEPT)&lt;/code&gt; pattern was encountered, regardless of whether there is actually more to match in the string. When inside of a nested pattern, such as recursion, or in a subpattern dynamically generated via &lt;code&gt;(??{})&lt;/code&gt;, only the innermost pattern is ended immediately.</source>
          <target state="translated">此模式不匹配任何内容，并导致在遇到 &lt;code&gt;(*ACCEPT)&lt;/code&gt; 模式时成功匹配的结束，而不管字符串中实际上是否还有更多要匹配的内容。当在嵌套模式（例如递归）中或在通过 &lt;code&gt;(??{})&lt;/code&gt; 动态生成的子模式中时，仅最里面的模式立即结束。</target>
        </trans-unit>
        <trans-unit id="19f045887dd160fbc7bf52fef1325dee9e3b92d8" translate="yes" xml:space="preserve">
          <source>This perl distribution comes with a tremendous amount of documentation. To add these to the built-in manuals that come with Plan 9, from /sys/src/cmd/perl/5.00301 (adjust version appropriately) run:</source>
          <target state="translated">这个perl发行版自带了大量的文档。要将这些文件添加到Plan 9的内置手册中,请从/sys/src/cmd/perl/5.00301(适当调整版本)运行。</target>
        </trans-unit>
        <trans-unit id="faaee2dbff571e442cc459d64235bf7e75251410" translate="yes" xml:space="preserve">
          <source>This phase is not called &quot;BEGIN&quot; to avoid confusion with &lt;code&gt;BEGIN&lt;/code&gt; -blocks, as those are executed during compile-time of any compilation unit, not just the top-level program. A new, localised compile-time entered at run-time, for example by constructs as &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;use SomeModule&quot;&lt;/code&gt; are not global interpreter phases, and therefore aren't reflected by &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; .</source>
          <target state="translated">为了避免与 &lt;code&gt;BEGIN&lt;/code&gt; 块混淆，此阶段不称为&amp;ldquo; BEGIN&amp;rdquo; ，因为这些块在任何编译单元（而不仅仅是顶层程序）的编译期间执行。在运行时（例如，通过 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;use SomeModule&quot;&lt;/code&gt; 的构造）输入的新的本地化编译时不是全局解释器阶段，因此不会被 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 反映。</target>
        </trans-unit>
        <trans-unit id="5c6076111df5ac2088f7c60ba538962c1ba1518f" translate="yes" xml:space="preserve">
          <source>This phase is not called &quot;BEGIN&quot; to avoid confusion with &lt;code&gt;BEGIN&lt;/code&gt;-blocks, as those are executed during compile-time of any compilation unit, not just the top-level program. A new, localised compile-time entered at run-time, for example by constructs as &lt;code&gt;eval &quot;use SomeModule&quot;&lt;/code&gt; are not global interpreter phases, and therefore aren't reflected by &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt;.</source>
          <target state="translated">为了避免与 &lt;code&gt;BEGIN&lt;/code&gt; 块混淆，此阶段不称为&amp;ldquo; BEGIN&amp;rdquo; ，因为它们在任何编译单元（而不仅仅是顶层程序）的编译期间执行。在运行时（例如，通过 &lt;code&gt;eval &quot;use SomeModule&quot;&lt;/code&gt; 的构造）输入的新的本地化编译时不是全局解释器阶段，因此不会被 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 反映。</target>
        </trans-unit>
        <trans-unit id="38d412691b698918f3fb521b6c5dd0a3a033324a" translate="yes" xml:space="preserve">
          <source>This pipes &quot;foo&quot; to the &quot;less&quot; pager and prints &quot;bar&quot; on the console:</source>
          <target state="translated">这将 &quot;foo &quot;管到 &quot;少 &quot;的寻呼机,并在控制台上打印 &quot;bar&quot;。</target>
        </trans-unit>
        <trans-unit id="aa4d6fbd955f7e5cef0d107f07af92fd7a485df2" translate="yes" xml:space="preserve">
          <source>This pipes &quot;foo&quot; to the pager and writes &quot;bar&quot; in the file &quot;blurch&quot;:</source>
          <target state="translated">这将 &quot;foo &quot;管到寻呼机,并将 &quot;bar &quot;写入文件 &quot;blurch &quot;中。</target>
        </trans-unit>
        <trans-unit id="f5e952eb46ee9ecbd24ef00bffe49334d2cc3dad" translate="yes" xml:space="preserve">
          <source>This pipes &quot;foo\nbar\n&quot; to the less pager:</source>
          <target state="translated">这管 &quot;foo/nbarbar/n &quot;的少呼机。</target>
        </trans-unit>
        <trans-unit id="9ef24b3495020011602b2e6eab8942a1d3d9b7c9" translate="yes" xml:space="preserve">
          <source>This port can also be built on IA64/AMD64 using:</source>
          <target state="translated">这个 port 也可以在 IA64/AMD64 上使用。</target>
        </trans-unit>
        <trans-unit id="ca794b2a97ff2f3e9f3ab8b1358dfca57eef50e2" translate="yes" xml:space="preserve">
          <source>This port currently supports MakeMaker (the set of modules that is used to build extensions to perl). Therefore, you should be able to build and install most extensions found in the CPAN sites.</source>
          <target state="translated">此 port 目前支持 MakeMaker (用于为 perl 建立扩展的一组模块)。因此,您应该能够联编和安装 CPAN 站点中的大多数扩展。</target>
        </trans-unit>
        <trans-unit id="793aa06cc8a67a48ad4353d4f7baf40b5e8a8732" translate="yes" xml:space="preserve">
          <source>This port fully supports MakeMaker (the set of modules that is used to build extensions to perl). Therefore, you should be able to build and install most extensions found in the CPAN sites. See &lt;a href=&quot;#Usage-Hints-for-Perl-on-Windows&quot;&gt;&quot;Usage Hints for Perl on Windows&quot;&lt;/a&gt; below for general hints about this.</source>
          <target state="translated">此端口完全支持MakeMaker（用于构建perl扩展的模块集）。因此，您应该能够构建和安装在CPAN站点中找到的大多数扩展。有关此方面的一般提示，请参见下面的&lt;a href=&quot;#Usage-Hints-for-Perl-on-Windows&quot;&gt;&amp;ldquo; Windows Perl的使用提示&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da8d54e517da55f89f98bd5f4b007e4f6e30203a" translate="yes" xml:space="preserve">
          <source>This port fully supports MakeMaker (the set of modules that is used to build extensions to perl). Therefore, you should be able to build and install most extensions found in the CPAN sites. See &lt;a href=&quot;#Usage-Hints-for-Perl-on-Windows&quot;&gt;Usage Hints for Perl on Windows&lt;/a&gt; below for general hints about this.</source>
          <target state="translated">此端口完全支持MakeMaker（用于构建perl扩展的模块集）。因此，您应该能够构建和安装在CPAN站点中找到的大多数扩展。有关此方面的一般提示，请参见下面的&lt;a href=&quot;#Usage-Hints-for-Perl-on-Windows&quot;&gt;Windows Perl使用提示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eca5da1d69d15505d5dfe7b2200728b9e2a69857" translate="yes" xml:space="preserve">
          <source>This port of Perl also uses Unix-epoch date values internally. As long as you are dealing with ASCII character string representations of dates, this should not be an issue. The supported epoch is January 1, 1980 to January 17, 2038.</source>
          <target state="translated">这个 Perl 的 port 也在内部使用了 Unix-epoch 日期值。只要您使用的是 ASCII 字符串表示的日期,就不会有问题。支持的年代是 1980 年 1 月 1 日至 2038 年 1 月 17 日。</target>
        </trans-unit>
        <trans-unit id="3b59478e1d9adc5bbc9ae74efe6d7c2a8e595477" translate="yes" xml:space="preserve">
          <source>This port of Perl version 5 prefers Unix-style, slash-separated pathnames over OpenVOS-style greater-than-separated pathnames. OpenVOS-style pathnames should work in most contexts, but if you have trouble, replace all greater-than characters by slash characters. Because the slash character is used as a pathname delimiter, Perl cannot process OpenVOS pathnames containing a slash character in a directory or file name; these must be renamed.</source>
          <target state="translated">这个Perl第5版的移植版本更倾向于使用Unix风格的、以斜线分隔的路径名,而不是OpenVOS风格的大于分隔的路径名。OpenVOS 风格的路径名在大多数情况下都可以使用,但如果您遇到了问题,可以用斜线字符来代替所有的大于字符。由于斜线字符被用作路径名的分隔符,Perl 无法处理目录或文件名中包含斜线字符的 OpenVOS 路径名;这些路径名必须重新命名。</target>
        </trans-unit>
        <trans-unit id="5661c31774bac29706eeedad5ca0b82e3ef23fed" translate="yes" xml:space="preserve">
          <source>This port was originally contributed by Gary Ng around 5.003_24, and borrowed from the Hip Communications port that was available at the time. Various people have made numerous and sundry hacks since then.</source>
          <target state="translated">这个端口最初是由Gary Ng在5.003_24左右贡献的,借鉴了当时的Hip Communications端口。从那以后,不同的人做了许多各种各样的黑客。</target>
        </trans-unit>
        <trans-unit id="791faea88ef9fd32067c73f960fb805edbc087f6" translate="yes" xml:space="preserve">
          <source>This port will support dynamic loading, but it is not selected by default. If you would like to experiment with dynamic loading then be sure to specify -Dusedl in the arguments to the Configure script. See the comments in hints/os390.sh for more information on dynamic loading. If you build with dynamic loading then you will need to add the $archlibexp/CORE directory to your LIBPATH environment variable in order for perl to work. See the config.sh file for the value of $archlibexp. If in trying to use Perl you see an error message similar to:</source>
          <target state="translated">这个 port 将支持动态加载,但默认情况下并没有选择它。如果您想尝试使用动态加载,请务必在配置脚本的参数中指定 -Dusedl。请参阅 hints/os390.sh 中的注释以获得更多关于动态加载的信息。如果你使用动态加载,那么你需要将 $archlibexp/CORE 目录添加到你的 LIBPATH 环境变量中,以便 perl 工作。请参阅config.sh文件以了解$archlibexp的值。如果在尝试使用Perl时看到类似的错误信息。</target>
        </trans-unit>
        <trans-unit id="9ea06585be873f55abde4de83dd620970030f924" translate="yes" xml:space="preserve">
          <source>This pragma allows overloading of Perl's operators for a class. To overload built-in functions, see &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;&quot;Overriding Built-in Functions&quot; in perlsub&lt;/a&gt; instead.</source>
          <target state="translated">这种语用允许Perl的运算符重载一个类。要重载内置函数，请参阅&lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;perlsub中的&amp;ldquo;覆盖内置函数&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66e0b9c8e30e0b67210d260345f05889e99ff243" translate="yes" xml:space="preserve">
          <source>This pragma allows overloading of Perl's operators for a class. To overload built-in functions, see &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;Overriding Built-in Functions in perlsub&lt;/a&gt; instead.</source>
          <target state="translated">这种语用允许Perl的运算符重载一个类。要重载内置函数，请参阅&lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;替代在perlsub中覆盖内置函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca794d61d2dfe5a76e1bb77807f394d0b2d09964" translate="yes" xml:space="preserve">
          <source>This pragma allows you to declare constants at compile-time.</source>
          <target state="translated">这个pragma允许你在编译时声明常量。</target>
        </trans-unit>
        <trans-unit id="2c01b8b1ad50eec7e989d0f266d4a4fc89f5d88b" translate="yes" xml:space="preserve">
          <source>This pragma allows you to lexically disable or enable overloading.</source>
          <target state="translated">这个pragma允许你用词法禁用或启用超载。</target>
        </trans-unit>
        <trans-unit id="c428d7745a523c21e13cd202bfe44587bda59ff5" translate="yes" xml:space="preserve">
          <source>This pragma also affects encoding of the 0x80..0xFF code point range: normally characters in that range are left as eight-bit bytes (unless they are combined with characters with code points 0x100 or larger, in which case all characters need to become UTF-8 encoded), but if the &lt;code&gt;encoding&lt;/code&gt; pragma is present, even the 0x80..0xFF range always gets UTF-8 encoded.</source>
          <target state="translated">此编译指示还会影响0x80..0xFF代码点范围的编码：通常该范围内的字符保留为八位字节（除非它们与代码点为0x100或更大的字符组合在一起，在这种情况下，所有字符都必须变为UTF -8编码），但是如果存在 &lt;code&gt;encoding&lt;/code&gt; 编译指示，则即使0x80..0xFF范围也始终获得UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="d924aa9de8af230a322065eb09c25f0d879f8eac" translate="yes" xml:space="preserve">
          <source>This pragma arranges for all inputs from files to be translated into Unicode from the current locale as specified in the environment (see &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt;), and all outputs to files to be translated back into the locale. (See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;). On a per-filehandle basis, you can instead use the &lt;a href=&quot;PerlIO::locale&quot;&gt;PerlIO::locale&lt;/a&gt; module, or the &lt;a href=&quot;Encode::Locale&quot;&gt;Encode::Locale&lt;/a&gt; module, both available from CPAN. The latter module also has methods to ease the handling of &lt;code&gt;ARGV&lt;/code&gt; and environment variables, and can be used on individual strings. If you know that all your locales will be UTF-8, as many are these days, you can use the &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&lt;b&gt;-C&lt;/b&gt;&lt;/a&gt; command line switch.</source>
          <target state="translated">此编译指示将文件中的所有输入都按照环境中指定的方式从当前语言环境转换为Unicode（请参阅&lt;a href=&quot;#ENVIRONMENT&quot;&gt;&amp;ldquo;环境&amp;rdquo;&lt;/a&gt;），并将所有文件的输出转换回该语言环境。 （请参阅&lt;a href=&quot;open&quot;&gt;打开&lt;/a&gt;）。在每个文件句柄的基础上，您可以改用&lt;a href=&quot;PerlIO::locale&quot;&gt;PerlIO :: locale&lt;/a&gt;模块或&lt;a href=&quot;Encode::Locale&quot;&gt;Encode :: Locale&lt;/a&gt;模块，这两个都可以从CPAN获得。后一个模块还具有简化 &lt;code&gt;ARGV&lt;/code&gt; 和环境变量处理的方法，并且可以在单个字符串上使用。如果您知道所有语言环境都将是UTF-8（如今已经很多），则可以使用&lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&lt;b&gt;-C&lt;/b&gt;&lt;/a&gt;命令行开关。</target>
        </trans-unit>
        <trans-unit id="cd54481ef89d3dcd2f0d998cbd0de47400ae94c4" translate="yes" xml:space="preserve">
          <source>This pragma arranges for all inputs from files to be translated into Unicode from the current locale as specified in the environment (see &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;), and all outputs to files to be translated back into the locale. (See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;). On a per-filehandle basis, you can instead use the &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::locale&quot;&gt;PerlIO::locale&lt;/a&gt; module, or the &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::Locale&quot;&gt;Encode::Locale&lt;/a&gt; module, both available from CPAN. The latter module also has methods to ease the handling of &lt;code&gt;ARGV&lt;/code&gt; and environment variables, and can be used on individual strings. If you know that all your locales will be UTF-8, as many are these days, you can use the &lt;a href=&quot;perlrun#-C&quot;&gt;-C&lt;/a&gt; command line switch.</source>
          <target state="translated">此编译指示将文件中的所有输入从环境中指定的当前语言环境转换为Unicode（请参阅&lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;），并将文件的所有输出转换回语言环境。 （请参阅&lt;a href=&quot;open&quot;&gt;打开&lt;/a&gt;）。在每个文件句柄的基础上，您可以改用&lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::locale&quot;&gt;PerlIO :: locale&lt;/a&gt;模块或&lt;a href=&quot;http://search.cpan.org/perldoc/Encode::Locale&quot;&gt;Encode :: Locale&lt;/a&gt;模块，这两个都可以从CPAN获得。后一个模块还具有简化 &lt;code&gt;ARGV&lt;/code&gt; 和环境变量处理的方法，并且可以在单个字符串上使用。如果您知道所有语言环境都将是UTF-8，那么现在可以使用&lt;a href=&quot;perlrun#-C&quot;&gt;-C&lt;/a&gt;命令行开关。</target>
        </trans-unit>
        <trans-unit id="37ed3079bf4bc6e6eae888371e167c272116e8dd" translate="yes" xml:space="preserve">
          <source>This pragma dates from the days when UTF-8-enabled editors were uncommon. But that was long ago, and the need for it is greatly diminished. That, coupled with the fact that it doesn't work with threads, along with other problems, (see &lt;a href=&quot;#BUGS&quot;&gt;&quot;BUGS&quot;&lt;/a&gt;) have led to its being deprecated. It is planned to remove this pragma in a future Perl version. New code should be written in UTF-8, and the &lt;code&gt;use utf8&lt;/code&gt; pragma used instead (see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; and &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; for details). Old code should be converted to UTF-8, via something like the recipe in the &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;&lt;/a&gt; (though this simple approach may require manual adjustments afterwards).</source>
          <target state="translated">这种语用可追溯到启用UTF-8的编辑器罕见的日子。但这是很久以前的事了，对它的需求大大减少了。那，再加上它不能与线程一起使用，以及其他问题（请参阅&lt;a href=&quot;#BUGS&quot;&gt;&amp;ldquo; BUGS&amp;rdquo;&lt;/a&gt;），导致它被弃用了。计划在将来的Perl版本中删除此杂注。新代码应使用UTF-8编写，而应 &lt;code&gt;use utf8&lt;/code&gt; 编译指示（有关详细信息，请参见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;和&lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;）。应该通过&lt;a href=&quot;#SYNOPSIS&quot;&gt;&amp;ldquo;概要&amp;rdquo;中&lt;/a&gt;的配方将旧代码转换为UTF-8 （尽管此简单方法可能需要随后进行手动调整）。</target>
        </trans-unit>
        <trans-unit id="34db7e44f64dc2e33987c7fbd44c07e44789bfa8" translate="yes" xml:space="preserve">
          <source>This pragma dates from the days when UTF-8-enabled editors were uncommon. But that was long ago, and the need for it is greatly diminished. That, coupled with the fact that it doesn't work with threads, along with other problems, (see &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;) have led to its being deprecated. It is planned to remove this pragma in a future Perl version. New code should be written in UTF-8, and the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma used instead (see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; and &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; for details). Old code should be converted to UTF-8, via something like the recipe in the &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; (though this simple approach may require manual adjustments afterwards).</source>
          <target state="translated">这种语用可追溯到启用UTF-8的编辑器罕见的日子。但这是很久以前的事，对它的需求已大大减少。这样，再加上它不能与线程一起使用，以及其他问题（请参阅&lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;），导致其已被弃用。计划在将来的Perl版本中删除此杂注。新代码应使用UTF-8编写，而应 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma代替（有关详细信息，请参见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;和&lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;）。旧代码应转换为UTF-8，通过类似的配方&lt;a href=&quot;#SYNOPSIS&quot;&gt;概要&lt;/a&gt;（尽管这种简单的方法可能需要手动调整之后）。</target>
        </trans-unit>
        <trans-unit id="4adb9dc70f3c9381053e6cf64fee4c07c531fe57" translate="yes" xml:space="preserve">
          <source>This pragma doesn't affect I/O. Nor does it change the internal representation of strings, only their interpretation. There are still several places where Unicode isn't fully supported, such as in filenames.</source>
          <target state="translated">这个pragma不影响I/O。它也不会改变字符串的内部表示,只是改变它们的解释。还有一些地方没有完全支持Unicode,比如在文件名中。</target>
        </trans-unit>
        <trans-unit id="d0a1053bcb46765bc08bab8c76c7daf170b6ab41" translate="yes" xml:space="preserve">
          <source>This pragma doesn't work well with &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; because PerlIO does not get along very well with it. When &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; contains non-ASCII characters it prints funny or gets &quot;wide character warnings&quot;. To understand it, try the code below.</source>
          <target state="translated">这种编译指示不适用于 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 因为PerlIO不能很好地与它相处。当 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 包含非ASCII字符时，它会打印出有趣的文字或显示&amp;ldquo;宽字符警告&amp;rdquo;。要了解它，请尝试下面的代码。</target>
        </trans-unit>
        <trans-unit id="63bc5c639e862260de54994e4a3fd753cd2d30e7" translate="yes" xml:space="preserve">
          <source>This pragma doesn't work well with &lt;code&gt;format&lt;/code&gt; because PerlIO does not get along very well with it. When &lt;code&gt;format&lt;/code&gt; contains non-ASCII characters it prints funny or gets &quot;wide character warnings&quot;. To understand it, try the code below.</source>
          <target state="translated">这种编译指示不适用于 &lt;code&gt;format&lt;/code&gt; 因为PerlIO不能很好地与它相处。当 &lt;code&gt;format&lt;/code&gt; 包含非ASCII字符时，它会打印出有趣的字样或显示&amp;ldquo;宽字符警告&amp;rdquo;。要了解它，请尝试下面的代码。</target>
        </trans-unit>
        <trans-unit id="842309da32a571cffd281160b3136685717f49db" translate="yes" xml:space="preserve">
          <source>This pragma first appeared in Perl v5.8.0. It has been enhanced in later releases as specified above.</source>
          <target state="translated">这个pragma最早出现在Perl v5.8.0中。在后来的版本中,它已经按照上述规定得到了加强。</target>
        </trans-unit>
        <trans-unit id="ea296547782279e5c0e53a333818543fc8821038" translate="yes" xml:space="preserve">
          <source>This pragma is used to enable a Perl script to be written in encodings that aren't strictly ASCII nor UTF-8. It translates all or portions of the Perl program script from a given encoding into UTF-8, and changes the PerlIO layers of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; to the encoding specified.</source>
          <target state="translated">使用此编译指示可以使Perl脚本以严格不是ASCII或UTF-8的编码来编写。它将全部或部分Perl程序脚本从给定编码转换为UTF-8，并将 &lt;code&gt;STDIN&lt;/code&gt; 和 &lt;code&gt;STDOUT&lt;/code&gt; 的PerlIO层更改为指定的编码。</target>
        </trans-unit>
        <trans-unit id="b2499dd223fe6da7fc3aa8e53b4286111a638895" translate="yes" xml:space="preserve">
          <source>This pragma lets you switch to the &quot;C3&quot; resolution order. In simple terms, &quot;C3&quot; order ensures that shared parent classes are never searched before child classes, so Perl will now search: &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt;&lt;code&gt;MaternalGrandparent&lt;/code&gt; , and finally &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; . Note however that this is not &quot;breadth-first&quot; searching: All the &lt;code&gt;Father&lt;/code&gt; ancestors (except the common ancestor) are searched before any of the &lt;code&gt;Mother&lt;/code&gt; ancestors are considered.</source>
          <target state="translated">此实用程序可让您切换到&amp;ldquo; C3&amp;rdquo;分辨率顺序。简单来说，&amp;ldquo;C3&amp;rdquo;为了确保共享父类从不子类之前搜索，这样的Perl现在搜索： &lt;code&gt;Child&lt;/code&gt; ， &lt;code&gt;Father&lt;/code&gt; ， &lt;code&gt;PaternalGrandparent&lt;/code&gt; ， &lt;code&gt;Mother&lt;/code&gt; &lt;code&gt;MaternalGrandparent&lt;/code&gt; ，最后 &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; 。但是请注意，这不是&amp;ldquo;先行搜索&amp;rdquo;：在考虑任何 &lt;code&gt;Mother&lt;/code&gt; 祖先之前，将搜索所有 &lt;code&gt;Father&lt;/code&gt; 祖先（公共祖先除外）。</target>
        </trans-unit>
        <trans-unit id="2c6a561743b48f6917f3de6223e944d7c22b30aa" translate="yes" xml:space="preserve">
          <source>This pragma lets you switch to the &quot;C3&quot; resolution order. In simple terms, &quot;C3&quot; order ensures that shared parent classes are never searched before child classes, so Perl will now search: &lt;code&gt;Child&lt;/code&gt;, &lt;code&gt;Father&lt;/code&gt;, &lt;code&gt;PaternalGrandparent&lt;/code&gt;, &lt;code&gt;Mother&lt;/code&gt;&lt;code&gt;MaternalGrandparent&lt;/code&gt;, and finally &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;. Note however that this is not &quot;breadth-first&quot; searching: All the &lt;code&gt;Father&lt;/code&gt; ancestors (except the common ancestor) are searched before any of the &lt;code&gt;Mother&lt;/code&gt; ancestors are considered.</source>
          <target state="translated">此实用程序可让您切换到&amp;ldquo; C3&amp;rdquo;分辨率顺序。简单来说，&amp;ldquo;C3&amp;rdquo;为了确保共享父类从不子类之前搜索，这样的Perl现在搜索： &lt;code&gt;Child&lt;/code&gt; ， &lt;code&gt;Father&lt;/code&gt; ， &lt;code&gt;PaternalGrandparent&lt;/code&gt; ， &lt;code&gt;Mother&lt;/code&gt; &lt;code&gt;MaternalGrandparent&lt;/code&gt; ，最后 &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; 。但是请注意，这不是&amp;ldquo;先行搜索&amp;rdquo;：在考虑任何 &lt;code&gt;Mother&lt;/code&gt; 祖先之前，将搜索所有 &lt;code&gt;Father&lt;/code&gt; 祖先（公共祖先除外）。</target>
        </trans-unit>
        <trans-unit id="7563cc6ded71ab7f47219e909773301db6c2d889" translate="yes" xml:space="preserve">
          <source>This pragma provides an easy and convenient way to enable or disable experimental features.</source>
          <target state="translated">这个pragma提供了一个简单方便的方法来启用或禁用实验性功能。</target>
        </trans-unit>
        <trans-unit id="2063e0ed31e4ca83c59af99843b134e51c1d67ca" translate="yes" xml:space="preserve">
          <source>This pragma reflects early attempts to incorporate Unicode into perl and has since been superseded. It breaks encapsulation (i.e. it exposes the innards of how the perl executable currently happens to store a string), and use of this module for anything other than debugging purposes is strongly discouraged. If you feel that the functions here within might be useful for your application, this possibly indicates a mismatch between your mental model of Perl Unicode and the current reality. In that case, you may wish to read some of the perl Unicode documentation: &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;, &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;, &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">这种实用性反映了将Unicode整合到perl中的早期尝试，此后已被取代。它破坏了封装（即，暴露了perl可执行文件当前如何存储字符串的内幕），并且强烈建议不要将此模块用于除调试目的以外的其他用途。如果您认为其中的功能可能对您的应用程序有用，则可能表明您的Perl Unicode心理模型与当前现实不匹配。在这种情况下，您可能希望阅读一些perl Unicode文档：&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;，&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;，&lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt;和&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17b8d23d839b79073aa5a07e1c3b5c9898bf0286" translate="yes" xml:space="preserve">
          <source>This pragma simplifies the maintenance of dual-life modules that will no longer be included in the Perl core in a future Perl release, but are still included currently.</source>
          <target state="translated">这个pragma简化了双寿命模块的维护,这些模块在未来的Perl版本中不再包含在Perl核心中,但目前仍然包含在其中。</target>
        </trans-unit>
        <trans-unit id="c260c6accbf395dcf89666ab18de9cc81ef025ab" translate="yes" xml:space="preserve">
          <source>This pragma tells the compiler to change the behaviour of the filetest permission operators, &lt;code&gt;-r&lt;/code&gt;&lt;code&gt;-w&lt;/code&gt;&lt;code&gt;-x&lt;/code&gt;&lt;code&gt;-R&lt;/code&gt;&lt;code&gt;-W&lt;/code&gt;&lt;code&gt;-X&lt;/code&gt; (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;).</source>
          <target state="translated">此实用程序告诉编译器更改filetest许可权运算符 &lt;code&gt;-r&lt;/code&gt; &lt;code&gt;-w&lt;/code&gt; &lt;code&gt;-x&lt;/code&gt; &lt;code&gt;-R&lt;/code&gt; &lt;code&gt;-W&lt;/code&gt; &lt;code&gt;-X&lt;/code&gt; 的行为（请参阅&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2ef074ee97cc67ce380e960a125c4b931d1340ce" translate="yes" xml:space="preserve">
          <source>This pragma tells the compiler to change the behaviour of the filetest permission operators, &lt;code&gt;-r&lt;/code&gt;&lt;code&gt;-w&lt;/code&gt;&lt;code&gt;-x&lt;/code&gt;&lt;code&gt;-R&lt;/code&gt;&lt;code&gt;-W&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;).</source>
          <target state="translated">此实用程序指示编译器更改filetest许可权运算符 &lt;code&gt;-r&lt;/code&gt; &lt;code&gt;-w&lt;/code&gt; &lt;code&gt;-x&lt;/code&gt; &lt;code&gt;-R&lt;/code&gt; &lt;code&gt;-W&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 的行为（请参阅&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="221ed9ae1b0c79e2438890e0d6c973d357078c4b" translate="yes" xml:space="preserve">
          <source>This pragma tells the compiler to enable (or disable) the use of POSIX locales for built-in operations (for example, LC_CTYPE for regular expressions, LC_COLLATE for string comparison, and LC_NUMERIC for number formatting). Each &quot;use locale&quot; or &quot;no locale&quot; affects statements to the end of the enclosing BLOCK.</source>
          <target state="translated">这个pragma告诉编译器启用(或禁用)内置操作的POSIX locale(例如,LC_CTYPE用于正则表达式,LC_COLLATE用于字符串比较,LC_NUMERIC用于数字格式化)。每一个 &quot;使用locale &quot;或 &quot;不使用locale &quot;都会影响到括号BLOCK末尾的语句。</target>
        </trans-unit>
        <trans-unit id="aeeaf592fadd170ef60bd36772264838afffed60" translate="yes" xml:space="preserve">
          <source>This pragma was created so you can explicitly tell Perl that operations executed within its scope are to use Unicode rules. More operations are affected with newer perls. See &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot;&lt;/a&gt;.</source>
          <target state="translated">创建此编译指示是为了使您可以明确地告诉Perl，在其范围内执行的操作将使用Unicode规则。更多的操作会受到更新的Perl的影响。请参见&lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&amp;ldquo;&amp;ldquo; Unicode错误&amp;rdquo;&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e609830a837e5307b3fb39be2d58dc9501e3994d" translate="yes" xml:space="preserve">
          <source>This pragma was created so you can explicitly tell Perl that operations executed within its scope are to use Unicode rules. More operations are affected with newer perls. See &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;.</source>
          <target state="translated">创建此编译指示是为了让您可以明确告诉Perl在其范围内执行的操作将使用Unicode规则。更多的操作会受到更新的Perl的影响。请参阅&lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;Unicode错误&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c932803f2c5c4b2cf5c88433b729097c2569d39" translate="yes" xml:space="preserve">
          <source>This pragma will predeclare all the variables whose names are in the list, allowing you to use them under &lt;code&gt;use strict&lt;/code&gt;, and disabling any typo warnings for them.</source>
          <target state="translated">此实用程序将预先声明名称在列表中的所有变量，从而允许您在 &lt;code&gt;use strict&lt;/code&gt; 情况下使用它们，并为它们禁用任何错字警告。</target>
        </trans-unit>
        <trans-unit id="700e6f2388b406cbe201cbb98323ed5f25c8d4b4" translate="yes" xml:space="preserve">
          <source>This pragma works just like the &lt;code&gt;strict&lt;/code&gt; pragma. This means that the scope of the warning pragma is limited to the enclosing block. It also means that the pragma setting will not leak across files (via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;). This allows authors to independently define the degree of warning checks that will be applied to their module.</source>
          <target state="translated">此实用程序的工作原理与 &lt;code&gt;strict&lt;/code&gt; 实用程序一样。这意味着警告语用范围仅限于封闭块。这也意味着编译指示设置不会在文件之间泄漏（通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; ）。这使作者可以独立定义将应用于其模块的警告检查的程度。</target>
        </trans-unit>
        <trans-unit id="efd21a83903c74ae90d870a3df25547a1a2130d8" translate="yes" xml:space="preserve">
          <source>This pragma works just like the &lt;code&gt;strict&lt;/code&gt; pragma. This means that the scope of the warning pragma is limited to the enclosing block. It also means that the pragma setting will not leak across files (via &lt;code&gt;use&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt;). This allows authors to independently define the degree of warning checks that will be applied to their module.</source>
          <target state="translated">此实用程序的工作就像 &lt;code&gt;strict&lt;/code&gt; 实用程序一样。这意味着警告语用范围仅限于封闭块。这也意味着编译指示设置不会在文件之间泄漏（通过 &lt;code&gt;use&lt;/code&gt; ， &lt;code&gt;require&lt;/code&gt; 或 &lt;code&gt;do&lt;/code&gt; ）。这使作者可以独立定义将应用于其模块的警告检查的程度。</target>
        </trans-unit>
        <trans-unit id="30a2879d5d48273acab2ab3a9f22c1edf08032e3" translate="yes" xml:space="preserve">
          <source>This prints</source>
          <target state="translated">此印刷品</target>
        </trans-unit>
        <trans-unit id="b6e212e7ef6ac1844cda369639e0440d069cad8b" translate="yes" xml:space="preserve">
          <source>This prints &quot;bar&quot; and writes &quot;foo&quot; into the file &quot;blurch&quot;:</source>
          <target state="translated">这将打印 &quot;bar &quot;并将 &quot;foo &quot;写入文件 &quot;blurch &quot;中。</target>
        </trans-unit>
        <trans-unit id="d54bfbbae93113b4950fc2d869fb4754b9ce7e99" translate="yes" xml:space="preserve">
          <source>This prints &quot;bar&quot; and writes &quot;foo&quot; to the file &quot;blurch&quot;:</source>
          <target state="translated">这将打印 &quot;bar &quot;并将 &quot;foo &quot;写入文件 &quot;blurch&quot;。</target>
        </trans-unit>
        <trans-unit id="efd4b33e8216cea60a6219dc7e5bd98ac5e87040" translate="yes" xml:space="preserve">
          <source>This prints &quot;foo&quot; (&quot;bar&quot; disappears into nowhereland):</source>
          <target state="translated">这样就会打印出 &quot;foo&quot;(&quot;bar &quot;消失在nowhereland)。</target>
        </trans-unit>
        <trans-unit id="41ff0d603c865bec8366dedecbae0223cb1c3622" translate="yes" xml:space="preserve">
          <source>This prints &lt;code&gt;2.7&lt;/code&gt; .</source>
          <target state="translated">打印 &lt;code&gt;2.7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5884fb8d5912977dd4b38b66daf68b4ce0bb0d83" translate="yes" xml:space="preserve">
          <source>This prints &lt;code&gt;2.7&lt;/code&gt;.</source>
          <target state="translated">打印 &lt;code&gt;2.7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb91200cd90a472a1ae9cb007ac03043f56be426" translate="yes" xml:space="preserve">
          <source>This prints out the name and version of all modules used and then exits.</source>
          <target state="translated">这将打印出所有使用的模块的名称和版本,然后退出。</target>
        </trans-unit>
        <trans-unit id="0f904b0830f014f8a9104235a42d06c972150632" translate="yes" xml:space="preserve">
          <source>This prints out your environment like the &lt;a href=&quot;http://man.he.net/man1/printenv&quot;&gt;printenv(1)&lt;/a&gt; program, but in a different order:</source>
          <target state="translated">这会像&lt;a href=&quot;http://man.he.net/man1/printenv&quot;&gt;printenv（1）&lt;/a&gt;程序那样打印出您的环境，但是顺序不同：</target>
        </trans-unit>
        <trans-unit id="f686232da2ac609974851dce432c4e1340ec7365" translate="yes" xml:space="preserve">
          <source>This prints out your environment like the printenv(1) program, but in a different order:</source>
          <target state="translated">这和 printenv(1)程序一样可以打印出你的环境,但顺序不同。</target>
        </trans-unit>
        <trans-unit id="04d447d63dbf460d4723e288297a46d354df3e2a" translate="yes" xml:space="preserve">
          <source>This prints two doublequotes:</source>
          <target state="translated">这样可以打印出两个双引号。</target>
        </trans-unit>
        <trans-unit id="345205710c1209079bdf05b4d146f25fe0a01f36" translate="yes" xml:space="preserve">
          <source>This prints:</source>
          <target state="translated">这个指纹。</target>
        </trans-unit>
        <trans-unit id="468d6d44762bf30d6816e393a8ba4eeeb6a7be16" translate="yes" xml:space="preserve">
          <source>This probably does nothing.</source>
          <target state="translated">这大概没有什么作用。</target>
        </trans-unit>
        <trans-unit id="d21d1db17e4be9e2f5e50a54879f0a7c98d4455f" translate="yes" xml:space="preserve">
          <source>This probably isn't as useful as you might think. Normally, you shouldn't need to.</source>
          <target state="translated">这可能没有你想象的那么有用。通常情况下,你不应该需要这样做。</target>
        </trans-unit>
        <trans-unit id="341bfd19674c6dfeba3ffe584bfdf82c2776cb1e" translate="yes" xml:space="preserve">
          <source>This probably makes more sense for a human: enter a block, start a statement. Get the values of &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt; , and add them together. Find &lt;code&gt;$a&lt;/code&gt; , and assign one to the other. Then leave.</source>
          <target state="translated">这对人类可能更有意义：输入一个块，开始一个语句。获取 &lt;code&gt;$b&lt;/code&gt; 和 &lt;code&gt;$c&lt;/code&gt; 的值，并将它们加在一起。找到 &lt;code&gt;$a&lt;/code&gt; ，并将一个分配给另一个。然后离开。</target>
        </trans-unit>
        <trans-unit id="a4586de2c445b95b021af0b04d69fb01ba89d45c" translate="yes" xml:space="preserve">
          <source>This probably makes more sense for a human: enter a block, start a statement. Get the values of &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt;, and add them together. Find &lt;code&gt;$a&lt;/code&gt;, and assign one to the other. Then leave.</source>
          <target state="translated">这对于人类可能更有意义：输入一个块，开始一个语句。获取 &lt;code&gt;$b&lt;/code&gt; 和 &lt;code&gt;$c&lt;/code&gt; 的值，并将它们加在一起。找到 &lt;code&gt;$a&lt;/code&gt; ，并将一个分配给另一个。然后离开了。</target>
        </trans-unit>
        <trans-unit id="d9d98988085b44026120bb435150bffabf68b9c3" translate="yes" xml:space="preserve">
          <source>This probably sounds a bit more confusing than it really is, so let's go through this program piece by piece and see what it does. (For those of you who might be trying to remember exactly what a prime number is, it's a number that's only evenly divisible by itself and 1.)</source>
          <target state="translated">这可能听起来比实际情况更让人困惑,所以让我们逐一看一下这个程序,看看它的作用。(对于那些可能试图记住什么是质数的人来说,它是一个只能被它自己和1偶数分割的数字。)</target>
        </trans-unit>
        <trans-unit id="8ac64410a0a0c80ce97774854ab9fa0ae7c24c64" translate="yes" xml:space="preserve">
          <source>This probing and the checks we performed have some limitations:</source>
          <target state="translated">这种探究和我们进行的检查有一定的局限性。</target>
        </trans-unit>
        <trans-unit id="e016023303c59d801c6e740a285fec3afa4a6473" translate="yes" xml:space="preserve">
          <source>This problem can usually be solved by making the inner subroutine anonymous, using the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; syntax. When inner anonymous subs that reference lexical subroutines in outer subroutines are created, they are automatically rebound to the current values of such lexical subs.</source>
          <target state="translated">通常可以通过使用 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; 语法使内部子例程匿名来解决此问题。当创建引用外部子例程中的词法子例程的内部匿名子例程时，它们将自动反弹到此类词法子例程的当前值。</target>
        </trans-unit>
        <trans-unit id="b60e9bed0f73061b937a8fe5fecd9ad0d49454e0" translate="yes" xml:space="preserve">
          <source>This problem can usually be solved by making the inner subroutine anonymous, using the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; syntax. When inner anonymous subs that reference variables in outer subroutines are created, they are automatically rebound to the current values of such variables.</source>
          <target state="translated">通常可以通过使用 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; 语法使内部子例程匿名来解决此问题。当创建引用外部子例程中变量的内部匿名子例程时，它们将自动反弹到此类变量的当前值。</target>
        </trans-unit>
        <trans-unit id="57123e780f962baab766839b9fcf02a5c2e726f1" translate="yes" xml:space="preserve">
          <source>This problem can usually be solved by making the inner subroutine anonymous, using the &lt;code&gt;sub {}&lt;/code&gt; syntax. When inner anonymous subs that reference lexical subroutines in outer subroutines are created, they are automatically rebound to the current values of such lexical subs.</source>
          <target state="translated">通常可以通过使用 &lt;code&gt;sub {}&lt;/code&gt; 语法使内部子例程匿名来解决此问题。创建引用外部子例程中的词法子例程的内部匿名子句时，它们会自动回弹到此类词法子句的当前值。</target>
        </trans-unit>
        <trans-unit id="8b0f22c9ea1e13dec6b01b469b5a53003b6ea76c" translate="yes" xml:space="preserve">
          <source>This problem can usually be solved by making the inner subroutine anonymous, using the &lt;code&gt;sub {}&lt;/code&gt; syntax. When inner anonymous subs that reference variables in outer subroutines are created, they are automatically rebound to the current values of such variables.</source>
          <target state="translated">通常可以通过使用 &lt;code&gt;sub {}&lt;/code&gt; 语法使内部子例程匿名来解决此问题。创建引用外部子例程中的变量的内部匿名子时，它们将自动反弹到此类变量的当前值。</target>
        </trans-unit>
        <trans-unit id="30e5c26de90551718f152502391c103ab788e07b" translate="yes" xml:space="preserve">
          <source>This problem usually involves one of the Perl built-ins that has the same name a Unix command that uses octal numbers as arguments on the command line. In this example, &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; on the command line knows that its first argument is octal because that's what it does:</source>
          <target state="translated">此问题通常涉及与Unix命令同名的Perl内置程序之一，该命令使用八进制数字作为命令行上的参数。在此示例中，命令行上的 &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; 知道其第一个参数是八进制的，因为这就是它的作用：</target>
        </trans-unit>
        <trans-unit id="d33a707f660fda2085139973d7ad824dc2ab179f" translate="yes" xml:space="preserve">
          <source>This problem usually involves one of the Perl built-ins that has the same name a Unix command that uses octal numbers as arguments on the command line. In this example, &lt;code&gt;chmod&lt;/code&gt; on the command line knows that its first argument is octal because that's what it does:</source>
          <target state="translated">此问题通常涉及与Unix命令同名的Perl内置程序之一，该命令在命令行上使用八进制数作为参数。在此示例中，命令行上的 &lt;code&gt;chmod&lt;/code&gt; 知道其第一个参数是八进制的，因为这就是它的作用：</target>
        </trans-unit>
        <trans-unit id="78b6c2ab73ee787f434ee0ce1c24dc74fd9f5055" translate="yes" xml:space="preserve">
          <source>This problem was fixed in perl 5.004_05, so preventing it means upgrading your version of perl. ;)</source>
          <target state="translated">这个问题在perl 5.004_05中已经被修复了,所以要防止这个问题就需要升级你的perl版本。)</target>
        </trans-unit>
        <trans-unit id="149ef363e988711abf3a930d8381275df0baf405" translate="yes" xml:space="preserve">
          <source>This processes the lines in &lt;code&gt;@lines&lt;/code&gt; (where each list item must be a defined value, and must contain exactly one line of content -- so no items like &lt;code&gt;&quot;foo\nbar&quot;&lt;/code&gt; are allowed). The final &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is used to indicate the end of document being parsed.</source>
          <target state="translated">这将处理 &lt;code&gt;@lines&lt;/code&gt; 中的行（每个列表项必须为已定义的值，并且必须仅包含一行内容-因此不允许使用诸如 &lt;code&gt;&quot;foo\nbar&quot;&lt;/code&gt; 类的项）。最终的 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 用于指示要解析的文档的结尾。</target>
        </trans-unit>
        <trans-unit id="688ef3f8e6f5eaf3a51865a695b77382ce66b228" translate="yes" xml:space="preserve">
          <source>This processes the lines in &lt;code&gt;@lines&lt;/code&gt; (where each list item must be a defined value, and must contain exactly one line of content -- so no items like &lt;code&gt;&quot;foo\nbar&quot;&lt;/code&gt; are allowed). The final &lt;code&gt;undef&lt;/code&gt; is used to indicate the end of document being parsed.</source>
          <target state="translated">这将处理 &lt;code&gt;@lines&lt;/code&gt; 中的行（每个列表项必须是已定义的值，并且必须仅包含一行内容-因此不允许使用诸如 &lt;code&gt;&quot;foo\nbar&quot;&lt;/code&gt; 类的项）。最终的 &lt;code&gt;undef&lt;/code&gt; 用于指示要解析的文档的末尾。</target>
        </trans-unit>
        <trans-unit id="6c20dce79362eb3c48b58c8e5bc86aad6133c323" translate="yes" xml:space="preserve">
          <source>This produces a patch based on the difference between blead and your current branch. It's important to make sure that blead is up to date before producing the diff, that's why we call &lt;code&gt;git pull&lt;/code&gt; first.</source>
          <target state="translated">这将根据blead和您当前分支之间的差异生成一个补丁。在生成差异之前，确保blead是最新的很重要，这就是为什么我们首先调用 &lt;code&gt;git pull&lt;/code&gt; 的原因。</target>
        </trans-unit>
        <trans-unit id="5a3bf030e7bf490188072c702d468c0925c814bb" translate="yes" xml:space="preserve">
          <source>This produces the Perl docs online book &lt;code&gt;perl.INF&lt;/code&gt; . Install in on &lt;code&gt;BOOKSHELF&lt;/code&gt; path.</source>
          <target state="translated">这将产生Perl docs在线图书 &lt;code&gt;perl.INF&lt;/code&gt; 。在 &lt;code&gt;BOOKSHELF&lt;/code&gt; 路径中安装。</target>
        </trans-unit>
        <trans-unit id="b1d23f3b834b32d7a55e6f86f555013820b4d006" translate="yes" xml:space="preserve">
          <source>This produces the Perl docs online book &lt;code&gt;perl.INF&lt;/code&gt;. Install in on &lt;code&gt;BOOKSHELF&lt;/code&gt; path.</source>
          <target state="translated">这将产生Perl docs在线图书 &lt;code&gt;perl.INF&lt;/code&gt; 。在 &lt;code&gt;BOOKSHELF&lt;/code&gt; 路径中安装。</target>
        </trans-unit>
        <trans-unit id="7a75bb1a7c7847916a1dc3b67dbf0cb3e9f1aba1" translate="yes" xml:space="preserve">
          <source>This produces the default error string for the given exception,</source>
          <target state="translated">这将产生给定异常的默认错误字符串。</target>
        </trans-unit>
        <trans-unit id="2c9c734dac073d3001ca1ea5f8fa8cfb8daa173b" translate="yes" xml:space="preserve">
          <source>This program is Copyright 1990,2015 by Johan Vromans. This program is free software; you can redistribute it and/or modify it under the terms of the Perl Artistic License or the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</source>
          <target state="translated">本程序版权归Johan Vromans所有,1990,2015。本程序是自由软件;您可以在Perl Artistic License或自由软件基金会发布的GNU通用公共许可证(GNU General Public License)的条款下重新发布和/或修改它;该许可证的第2版或(由您选择)任何更新的版本。</target>
        </trans-unit>
        <trans-unit id="26f7f8dba51ed564d4c376a299ad1ccb7d59f62d" translate="yes" xml:space="preserve">
          <source>This program is designed to help you generate and send bug reports (and thank-you notes) about perl5 and the modules which ship with it.</source>
          <target state="translated">这个程序是用来帮助你生成和发送关于perl5和它的模块的错误报告(和感谢信)。</target>
        </trans-unit>
        <trans-unit id="95c0f8377730d3f4d0f475e508c5eeed353ea1d3" translate="yes" xml:space="preserve">
          <source>This program is designed to help you generate bug reports (and thank-you notes) about perl5 and the modules which ship with it.</source>
          <target state="translated">这个程序的设计是为了帮助你生成关于perl5和它所附带的模块的错误报告(和感谢信)。</target>
        </trans-unit>
        <trans-unit id="04d3efb8a4ca3ef394388570fac127108dc6a9fe" translate="yes" xml:space="preserve">
          <source>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See either the GNU General Public License or the Artistic License for more details.</source>
          <target state="translated">本程序发布的目的是希望它是有用的,但没有任何保证,甚至没有默示的适销性或适合特定用途的保证。更多细节请参见GNU通用公共许可证或艺术许可证。</target>
        </trans-unit>
        <trans-unit id="2cac2059d04ed459899445fb7d4adafed92ceb31" translate="yes" xml:space="preserve">
          <source>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</source>
          <target state="translated">本程序发布的目的是希望它是有用的,但没有任何保证,甚至没有默示的适销性或适合特定用途的保证。更多细节请参见GNU通用公共许可证。</target>
        </trans-unit>
        <trans-unit id="d8761e66f0aa0865d7b8a0fad53a385acc12de1d" translate="yes" xml:space="preserve">
          <source>This program is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</source>
          <target state="translated">本程序发布的目的是希望它是有用的,但不作任何保证,甚至不对适销性或特定用途的适用性作默示保证。</target>
        </trans-unit>
        <trans-unit id="2b736eab48b8800afefb519e32bdf619448f2254" translate="yes" xml:space="preserve">
          <source>This program is distributed under the Artistic License.</source>
          <target state="translated">本程序采用Artistic License发布。</target>
        </trans-unit>
        <trans-unit id="d1d0a6a12423ce6569360d8955fb54c14fc9d18b" translate="yes" xml:space="preserve">
          <source>This program is distributed under the same terms as perl itself. See &lt;a href=&quot;http://perl.org/&quot;&gt;http://perl.org/&lt;/a&gt; or &lt;a href=&quot;http://cpan.org/&quot;&gt;http://cpan.org/&lt;/a&gt; for more info on that.</source>
          <target state="translated">该程序以与perl本身相同的术语分发。有关更多信息，请参见&lt;a href=&quot;http://perl.org/&quot;&gt;http://perl.org/&lt;/a&gt;或&lt;a href=&quot;http://cpan.org/&quot;&gt;http://cpan.org/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f880f2d75284047b0b3ca19e5c220c8ba58fc91" translate="yes" xml:space="preserve">
          <source>This program is distributed under the same terms as perl itself. See http://perl.org/ or http://cpan.org/ for more info on that.</source>
          <target state="translated">这个程序的发布条款和perl本身是一样的。参见http://perl.org/或 http://cpan.org/了解更多信息。</target>
        </trans-unit>
        <trans-unit id="c09da468beec666c3faa34069fc9e34aec608126" translate="yes" xml:space="preserve">
          <source>This program is easy to understand. &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; is the standard way to invoke a perl program from the shell. &lt;code&gt;$regexp = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; saves the first command line argument as the regexp to be used, leaving the rest of the command line arguments to be treated as files. &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loops over all the lines in all the files. For each line, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; if /$regexp/;&lt;/code&gt; prints the line if the regexp matches the line. In this line, both &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;/$regexp/&lt;/code&gt; use the default variable &lt;code&gt;$_&lt;/code&gt; implicitly.</source>
          <target state="translated">这个程序很容易理解。 &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; 是从shell调用perl程序的标准方法。 &lt;code&gt;$regexp = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; 将第一个命令行参数保存为要使用的regexp，其余命令行参数则视为文件。 &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; 循环遍历所有文件中的所有行。对于每行， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; if /$regexp/;&lt;/code&gt; ，则&lt;a href=&quot;functions/print&quot;&gt;打印&lt;/a&gt;；如果正则表达式匹配该行，则打印该行。在此行中， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;/$regexp/&lt;/code&gt; 隐式使用默认变量 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1261f166c54df8049e546eae1262e6a9cada525" translate="yes" xml:space="preserve">
          <source>This program is easy to understand. &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; is the standard way to invoke a perl program from the shell. &lt;code&gt;$regexp = shift;&lt;/code&gt; saves the first command line argument as the regexp to be used, leaving the rest of the command line arguments to be treated as files. &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loops over all the lines in all the files. For each line, &lt;code&gt;print if /$regexp/;&lt;/code&gt; prints the line if the regexp matches the line. In this line, both &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;/$regexp/&lt;/code&gt; use the default variable &lt;code&gt;$_&lt;/code&gt; implicitly.</source>
          <target state="translated">这个程序很容易理解。 &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; 是从shell调用perl程序的标准方法。 &lt;code&gt;$regexp = shift;&lt;/code&gt; 将第一个命令行参数保存为要使用的regexp，其余命令行参数则视为文件。 &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; 循环遍历所有文件中的所有行。对于每一行， &lt;code&gt;print if /$regexp/;&lt;/code&gt; ，则打印；如果正则表达式与该行匹配，则打印该行。在此行中， &lt;code&gt;print&lt;/code&gt; 和 &lt;code&gt;/$regexp/&lt;/code&gt; 隐式使用默认变量 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3f9820f4fcf840eefdc1fac524d68220274e583" translate="yes" xml:space="preserve">
          <source>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself</source>
          <target state="translated">本程序是自由软件;你可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="46aefc944a8368be1c5041bb6eeeeb6f411fe967" translate="yes" xml:space="preserve">
          <source>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">这个程序是自由软件;你可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="ef7753908303851a8d71edec5d567bdf9359f255" translate="yes" xml:space="preserve">
          <source>This program is free software; you can redistribute it and/or modify it under the terms of either:</source>
          <target state="translated">本程序是自由软件;您可以根据任一条款重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="d232685400a50b411b31a9d8b5d5d46e7d1e5a7e" translate="yes" xml:space="preserve">
          <source>This program is free software; you can redistribute it and/or modify it under the terms of either: the GNU General Public License as published by the Free Software Foundation; or the Artistic License.</source>
          <target state="translated">本程序是自由软件;您可以根据以下条款重新发布和/或修改它:自由软件基金会发布的GNU通用公共许可证;或艺术许可证。</target>
        </trans-unit>
        <trans-unit id="eda486acda27bdf9cd66949e1266b5a78cb661d8" translate="yes" xml:space="preserve">
          <source>This program is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">本程序是自由软件;您可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="49a9ebce432bc6f7a5abfa1673ae23d082772d50" translate="yes" xml:space="preserve">
          <source>This program is maintained by the Perl 5 Porters. The CPAN distribution is maintained by S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;</source>
          <target state="translated">该程序由Perl 5 Porters维护。CPAN分布由S&amp;eacute;bastienAperghis-Tramoni &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d98f469a4bef1492cbd51567cf72d3226f5fb0a1" translate="yes" xml:space="preserve">
          <source>This program provides an easy way to send a thank-you message back to the authors and maintainers of perl. It's just</source>
          <target state="translated">这个程序提供了一个简单的方法来给perl的作者和维护者发送感谢信息。它只是</target>
        </trans-unit>
        <trans-unit id="474e6c18a35ba4d4e6ef7db0a92aa1f2c8019fc7" translate="yes" xml:space="preserve">
          <source>This program uses the pipeline model to generate prime numbers. Each thread in the pipeline has an input queue that feeds numbers to be checked, a prime number that it's responsible for, and an output queue into which it funnels numbers that have failed the check. If the thread has a number that's failed its check and there's no child thread, then the thread must have found a new prime number. In that case, a new child thread is created for that prime and stuck on the end of the pipeline.</source>
          <target state="translated">这个程序使用管道模型来生成质数。管道中的每一个线程都有一个输入队列,用来输入要检查的数字,一个它负责的质数,以及一个输出队列,将检查失败的数字漏入其中。如果该线程有一个未能通过检查的数字,而且没有子线程,那么该线程一定是找到了一个新的质数。在这种情况下,将为该质数创建一个新的子线程,并卡在流水线的末端。</target>
        </trans-unit>
        <trans-unit id="9bd07d758efadc42857a5a0bab51cd8a077edefd" translate="yes" xml:space="preserve">
          <source>This program will print only the line containing &quot;Bar&quot;. If the range operator is changed to &lt;code&gt;...&lt;/code&gt; , it will also print the &quot;Baz&quot; line.</source>
          <target state="translated">该程序将仅打印包含&amp;ldquo; Bar&amp;rdquo;的行。如果将范围运算符更改为 &lt;code&gt;...&lt;/code&gt; ，则还将打印&amp;ldquo; Baz&amp;rdquo;行。</target>
        </trans-unit>
        <trans-unit id="30db2380e071100cd380f37fbfe50881aec4a9f3" translate="yes" xml:space="preserve">
          <source>This program will print only the line containing &quot;Bar&quot;. If the range operator is changed to &lt;code&gt;...&lt;/code&gt;, it will also print the &quot;Baz&quot; line.</source>
          <target state="translated">该程序将仅打印包含&amp;ldquo; Bar&amp;rdquo;的行。如果将范围运算符更改为 &lt;code&gt;...&lt;/code&gt; ，还将打印&amp;ldquo; Baz&amp;rdquo;行。</target>
        </trans-unit>
        <trans-unit id="f91a32c34a450fa3aaeea5e09b4bf9753a0de2ef" translate="yes" xml:space="preserve">
          <source>This program will probably hang until you kill it. The only way it won't hang is if one of the two threads acquires both locks first. A guaranteed-to-hang version is more complicated, but the principle is the same.</source>
          <target state="translated">这个程序可能会挂起,直到你杀死它。唯一不会挂起的方法是两个线程中的一个先获得两个锁。保证挂起的版本比较复杂,但原理是一样的。</target>
        </trans-unit>
        <trans-unit id="5342717fe0bceba26cbcb8fb4ec4c851e52a537d" translate="yes" xml:space="preserve">
          <source>This project was originated by the late Nick Ing-Simmons and later maintained by Dan Kogai</source>
          <target state="translated">该项目由已故的Nick Ing-Simmons发起,后来由Dan Kogai维护。</target>
        </trans-unit>
        <trans-unit id="9118e7dccf4093710a6ee14c8c47816f5d4b16b0" translate="yes" xml:space="preserve">
          <source>This property is always written in the compound form. For example, &lt;code&gt;\p{Bidi_Class:R}&lt;/code&gt; matches characters that are normally written right to left. Unlike the &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;&quot;General_Category&quot;&lt;/a&gt;&lt;/code&gt; property, this property can have more values added in a future Unicode release. Those listed above comprised the complete set for many Unicode releases, but others were added in Unicode 6.3; you can always find what the current ones are in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. And &lt;a href=&quot;https://www.unicode.org/reports/tr9/&quot;&gt;https://www.unicode.org/reports/tr9/&lt;/a&gt; describes how to use them.</source>
          <target state="translated">此属性始终以复合形式编写。例如， &lt;code&gt;\p{Bidi_Class:R}&lt;/code&gt; 匹配通常从右到左书写的字符。与 &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;&quot;General_Category&quot;&lt;/a&gt;&lt;/code&gt; 属性不同，此属性可以在将来的Unicode版本中添加更多值。上面列出的内容构成了许多Unicode版本的完整集，但其他内容是在Unicode 6.3中添加的；您始终可以在&lt;a href=&quot;perluniprops&quot;&gt;perluniprops中&lt;/a&gt;找到当前的内容。而&lt;a href=&quot;https://www.unicode.org/reports/tr9/&quot;&gt;https://www.unicode.org/reports/tr9/&lt;/a&gt;介绍了如何使用它们。</target>
        </trans-unit>
        <trans-unit id="d353efbbda92520a2429ad4f8535f649667e5952" translate="yes" xml:space="preserve">
          <source>This property is always written in the compound form. For example, &lt;code&gt;\p{Bidi_Class:R}&lt;/code&gt; matches characters that are normally written right to left. Unlike the &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; property, this property can have more values added in a future Unicode release. Those listed above comprised the complete set for many Unicode releases, but others were added in Unicode 6.3; you can always find what the current ones are in in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. And &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; describes how to use them.</source>
          <target state="translated">此属性始终以复合形式编写。例如， &lt;code&gt;\p{Bidi_Class:R}&lt;/code&gt; 匹配通常从右到左书写的字符。与 &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; 属性不同，此属性可以在将来的Unicode版本中添加更多值。上面列出的内容构成了许多Unicode版本的完整集，但其他内容是在Unicode 6.3中添加的；您总是可以在&lt;a href=&quot;perluniprops&quot;&gt;perluniprops中&lt;/a&gt;找到当前的内容。而&lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt;介绍了如何使用它们。</target>
        </trans-unit>
        <trans-unit id="9d34b69b565209c628e5e765cbc6639e949afb7e" translate="yes" xml:space="preserve">
          <source>This property is used when you need to know in what Unicode version(s) a character is.</source>
          <target state="translated">当你需要知道一个字符的Unicode版本时,就会用到这个属性。</target>
        </trans-unit>
        <trans-unit id="ba740c0026c45f2093377326c9e21d5c765b2b70" translate="yes" xml:space="preserve">
          <source>This provides access to most of the Win32 GUI widgets from Perl. Obviously, it only runs under Win32, and uses native widgets. The Perl interface doesn't really follow the C interface: it's been made more Perlish, and the documentation is pretty good. More advanced stuff may require familiarity with the C Win32 APIs, or reference to MSDN.</source>
          <target state="translated">它提供了从Perl中访问大多数Win32 GUI widget的机会。很明显,它只在Win32下运行,并且使用本地的widget。Perl界面并没有真正遵循C界面:它被做得更像Perlish,而且文档非常好。更高级的东西可能需要熟悉C Win32 APIs,或者参考MSDN。</target>
        </trans-unit>
        <trans-unit id="05ed7360b5662052cf8df531a4821820675f5a90" translate="yes" xml:space="preserve">
          <source>This provides an alternate means to specify function names to be exported from the extension. Its value is a reference to an array of function names to be exported by the extension. These names are passed through unaltered to the linker options file.</source>
          <target state="translated">这提供了一种替代方法来指定要从扩展中导出的函数名称。它的值是对扩展要导出的函数名数组的引用。这些名称将不加修改地传递到链接器选项文件中。</target>
        </trans-unit>
        <trans-unit id="b6d4501c0d8df55386bc41a04cfb00e365ded86e" translate="yes" xml:space="preserve">
          <source>This provides an alternate means to specify function names to be exported from the extension. Its value is a reference to an array of function names to be exported by the extension. These names are passed through unaltered to the linker options file. Specifying a value for the FUNCLIST attribute suppresses automatic generation of the bootstrap function for the package. To still create the bootstrap name you have to specify the package name in the DL_FUNCS hash:</source>
          <target state="translated">这提供了一种替代方法来指定要从扩展中导出的函数名称。它的值是对扩展要导出的函数名数组的引用。这些名称将不加修改地传递到链接器选项文件中。为FUNCLIST属性指定一个值会抑制包的引导函数的自动生成。为了继续创建引导名,你必须在DL_FUNCS哈希中指定包名。</target>
        </trans-unit>
        <trans-unit id="e5949eb8258f363515432b75a3130bd3950de7ae" translate="yes" xml:space="preserve">
          <source>This provides console orientated output formatting for &lt;a href=&quot;../../harness&quot;&gt;TAP::Harness&lt;/a&gt; when run with multiple &lt;a href=&quot;../../harness#jobs&quot;&gt;jobs in TAP::Harness&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;../../harness#jobs&quot;&gt;在TAP :: Harness中&lt;/a&gt;有多个作业运行时，这将为&lt;a href=&quot;../../harness&quot;&gt;TAP :: Harness&lt;/a&gt;提供面向控制台的输出格式。</target>
        </trans-unit>
        <trans-unit id="5c754e200bc077c2bf6996a1253c57ba0690ec6b" translate="yes" xml:space="preserve">
          <source>This provides console orientated output formatting for &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; when run with multiple &lt;a href=&quot;TAP::Harness#jobs&quot;&gt;&quot;jobs&quot; in TAP::Harness&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;TAP::Harness#jobs&quot;&gt;在TAP :: Harness中&lt;/a&gt;使用多个&amp;ldquo;作业&amp;rdquo;运行时，这将为&lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness&lt;/a&gt;提供面向控制台的输出格式。</target>
        </trans-unit>
        <trans-unit id="9181d13c6755b2d2d5fcc68549a86008e0459f52" translate="yes" xml:space="preserve">
          <source>This provides console orientated output formatting for TAP::Harness.</source>
          <target state="translated">这为TAP::Harness提供了面向控制台的输出格式。</target>
        </trans-unit>
        <trans-unit id="cb848608e40dafbcfe04519def93d68a46db285b" translate="yes" xml:space="preserve">
          <source>This provides fairly low-level access to the Win32 System API calls dealing with files and directories.</source>
          <target state="translated">它提供了对Win32系统API调用的相当低级的访问,以处理文件和目录。</target>
        </trans-unit>
        <trans-unit id="d034d371e8adbdcae6dcc8b5f1035f643b009166" translate="yes" xml:space="preserve">
          <source>This provides file orientated output formatting for &lt;a href=&quot;../../harness&quot;&gt;TAP::Harness&lt;/a&gt;. It is particularly important when running with parallel tests, as it ensures that test results are not interleaved, even when run verbosely.</source>
          <target state="translated">这为&lt;a href=&quot;../../harness&quot;&gt;TAP :: Harness&lt;/a&gt;提供了面向文件的输出格式。在并行测试中运行时，这一点尤其重要，因为即使在冗长的运行中，它也可以确保测试结果不会交错。</target>
        </trans-unit>
        <trans-unit id="41a1e8e2958aae247fdb0f251950cd9259ec4e20" translate="yes" xml:space="preserve">
          <source>This provides file orientated output formatting for &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt;. It is particularly important when running with parallel tests, as it ensures that test results are not interleaved, even when run verbosely.</source>
          <target state="translated">这为&lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness&lt;/a&gt;提供了面向文件的输出格式。在并行测试中运行时，这一点尤其重要，因为即使在冗长的运行中，它也可以确保测试结果不会交错。</target>
        </trans-unit>
        <trans-unit id="be3613f62ba727bb8044f064f871c5a2ffe96d89" translate="yes" xml:space="preserve">
          <source>This provides file orientated output formatting for TAP::Harness.</source>
          <target state="translated">这为TAP::Harness提供了面向文件的输出格式。</target>
        </trans-unit>
        <trans-unit id="e79f6eddf4d757dda9eee150d598652b5e165fe6" translate="yes" xml:space="preserve">
          <source>This provides the &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; token that returns a reference to the current subroutine or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">这提供了 &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; 令牌，该令牌返回对当前子例程的引用或在子例程外部的 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e44b62c4658b0866a101af4ad0e69174b50a666" translate="yes" xml:space="preserve">
          <source>This provides the &lt;code&gt;__SUB__&lt;/code&gt; token that returns a reference to the current subroutine or &lt;code&gt;undef&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">这提供了 &lt;code&gt;__SUB__&lt;/code&gt; 令牌，该令牌返回对当前子例程的引用或在子例程外部的 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="224c6e548e4884dfbdfe2ac071bf15dda7c825fc" translate="yes" xml:space="preserve">
          <source>This puts the executables in f:/perllib/bin. Manually move them to the &lt;code&gt;PATH&lt;/code&gt; , manually move the built</source>
          <target state="translated">这会将可执行文件放在f：/ perllib / bin中。手动将其移动到 &lt;code&gt;PATH&lt;/code&gt; ，手动将已构建的</target>
        </trans-unit>
        <trans-unit id="0f078af34eb1808b4b8645c105ffb896a2e3287b" translate="yes" xml:space="preserve">
          <source>This puts the executables in f:/perllib/bin. Manually move them to the &lt;code&gt;PATH&lt;/code&gt;, manually move the built</source>
          <target state="translated">这会将可执行文件放在f：/ perllib / bin中。手动将其移至 &lt;code&gt;PATH&lt;/code&gt; ，手动将已构建的</target>
        </trans-unit>
        <trans-unit id="d9a0cac7b723579ba6e539b4576a4997c5b49e8f" translate="yes" xml:space="preserve">
          <source>This read-only variable contains a reference to the last-read filehandle. This is set by &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;. This is the same handle that &lt;code&gt;$.&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without arguments use. It is also the handle used when Perl appends &quot;, &amp;lt;STDIN&amp;gt; line 1&quot; to an error or warning message.</source>
          <target state="translated">该只读变量包含对最后读取的文件句柄的引用。这是由 &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; 设置的， &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 。这与 &lt;code&gt;$.&lt;/code&gt; 相同。并在不使用参数的情况下 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 。它也是Perl在错误或警告消息后附加&amp;ldquo; &amp;lt;STDIN&amp;gt;第1行&amp;rdquo;的句柄。</target>
        </trans-unit>
        <trans-unit id="be43d29d7cb60d0bb5d93c01c4c8424abbd333f2" translate="yes" xml:space="preserve">
          <source>This read-only variable contains a reference to the last-read filehandle. This is set by &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt;, &lt;code&gt;readline&lt;/code&gt;, &lt;code&gt;tell&lt;/code&gt;, &lt;code&gt;eof&lt;/code&gt; and &lt;code&gt;seek&lt;/code&gt;. This is the same handle that &lt;code&gt;$.&lt;/code&gt; and &lt;code&gt;tell&lt;/code&gt; and &lt;code&gt;eof&lt;/code&gt; without arguments use. It is also the handle used when Perl appends &quot;, &amp;lt;STDIN&amp;gt; line 1&quot; to an error or warning message.</source>
          <target state="translated">此只读变量包含对最后读取的文件句柄的引用。这是由 &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; 设置的， &lt;code&gt;readline&lt;/code&gt; ， &lt;code&gt;tell&lt;/code&gt; ， &lt;code&gt;eof&lt;/code&gt; 和 &lt;code&gt;seek&lt;/code&gt; 。这与 &lt;code&gt;$.&lt;/code&gt; 相同。并 &lt;code&gt;tell&lt;/code&gt; 和 &lt;code&gt;eof&lt;/code&gt; 不带参数的使用。它也是Perl在错误或警告消息中附加&amp;ldquo; &amp;lt;STDIN&amp;gt;第1行&amp;rdquo;时使用的句柄。</target>
        </trans-unit>
        <trans-unit id="36a8564c99d9b70452198f29efc00c01b42f3989" translate="yes" xml:space="preserve">
          <source>This readonly SV has a zero numeric value and a &lt;code&gt;&quot;0&quot;&lt;/code&gt; string value. It's similar to &lt;code&gt;&lt;a href=&quot;#PL_sv_no&quot;&gt;&quot;PL_sv_no&quot;&lt;/a&gt;&lt;/code&gt; except for its string value. Can be used as a cheap alternative to &lt;code&gt;mXPUSHi(0)&lt;/code&gt; for example. Always refer to this as &lt;code&gt;&amp;amp;PL_sv_zero&lt;/code&gt;. Introduced in 5.28.</source>
          <target state="translated">该只读SV的数值为零，字符串值为 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 。除了其字符串值外，它与 &lt;code&gt;&lt;a href=&quot;#PL_sv_no&quot;&gt;&quot;PL_sv_no&quot;&lt;/a&gt;&lt;/code&gt; 相似。例如，可以用作 &lt;code&gt;mXPUSHi(0)&lt;/code&gt; 的廉价替代品。始终将此称为 &lt;code&gt;&amp;amp;PL_sv_zero&lt;/code&gt; 。在5.28中引入。</target>
        </trans-unit>
        <trans-unit id="2e9c374af25573cbb8a011c91df0b5de175403d9" translate="yes" xml:space="preserve">
          <source>This reads the Pod content of the file (or filehandle) that you specify, and processes it with that &lt;code&gt;$parser&lt;/code&gt; object, according to however &lt;code&gt;$parser&lt;/code&gt; 's class works, and according to whatever parser options you have set up for this &lt;code&gt;$parser&lt;/code&gt; object.</source>
          <target state="translated">这种读取您指定的文件（或文件句柄）的波德内容，并与处理它 &lt;code&gt;$parser&lt;/code&gt; 对象，但是，根据 &lt;code&gt;$parser&lt;/code&gt; 的一流作品，并按照任何解析器选项已就此成立 &lt;code&gt;$parser&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="a26e710e2e27380d631c3ef937b2b0240e77b996" translate="yes" xml:space="preserve">
          <source>This reads the Pod content of the file (or filehandle) that you specify, and processes it with that &lt;code&gt;$parser&lt;/code&gt; object, according to however &lt;code&gt;$parser&lt;/code&gt;'s class works, and according to whatever parser options you have set up for this &lt;code&gt;$parser&lt;/code&gt; object.</source>
          <target state="translated">这种读取您指定的文件（或文件句柄）的波德内容，并与处理它 &lt;code&gt;$parser&lt;/code&gt; 对象，但是，根据 &lt;code&gt;$parser&lt;/code&gt; 的一流作品，并按照任何解析器选项已就此成立 &lt;code&gt;$parser&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="49bb05c8de9876d308efc2608bb9d89029538d52" translate="yes" xml:space="preserve">
          <source>This refers to a namespace declared with the Perl &lt;code&gt;package&lt;/code&gt; statement. In Perl, packages often have a version number property given by the &lt;code&gt;$VERSION&lt;/code&gt; variable in the namespace.</source>
          <target state="translated">这是指用Perl &lt;code&gt;package&lt;/code&gt; 语句声明的名称空间。在Perl中，包通常具有名称空间中 &lt;code&gt;$VERSION&lt;/code&gt; 变量给定的版本号属性。</target>
        </trans-unit>
        <trans-unit id="b4ff270630232407257920d032001ef8966fbd15" translate="yes" xml:space="preserve">
          <source>This refers to a reusable library of code contained in a single file. Modules usually contain one or more packages and are often referred to by the name of a primary package that can be mapped to the file name. For example, one might refer to &lt;code&gt;File::Spec&lt;/code&gt; instead of</source>
          <target state="translated">这是指单个文件中包含的可重用代码库。模块通常包含一个或多个程序包，并且通常由可以映射到文件名的主程序包的名称来引用。例如，可能引用 &lt;code&gt;File::Spec&lt;/code&gt; 而不是</target>
        </trans-unit>
        <trans-unit id="e8d7cb3ad9af8785004d6aea2c58d998c7c43122" translate="yes" xml:space="preserve">
          <source>This refers to a reusable library of code typically contained in a single file. Currently, we primarily talk of perl modules, but this specification should be open enough to apply to other languages as well (ex. python, ruby).</source>
          <target state="translated">这指的是一个可重用的代码库,通常包含在一个文件中。目前,我们主要讨论的是perl模块,但这个规范应该是开放的,足以适用于其他语言(例如python,ruby)。</target>
        </trans-unit>
        <trans-unit id="eced75506fbb27c39fc8e3e1e378940cf07d3648" translate="yes" xml:space="preserve">
          <source>This refers to a reusable library of code typically contained in a single file. Currently, we primarily talk of perl modules, but this specification should be open enough to apply to other languages as well (ex. python, ruby). Examples of modules are &lt;code&gt;Class::Container&lt;/code&gt;, &lt;code&gt;LWP::Simple&lt;/code&gt;, or &lt;code&gt;DBD::File&lt;/code&gt;.</source>
          <target state="translated">这是指通常包含在单个文件中的可重用代码库。当前，我们主要谈论perl模块，但是该规范应该足够开放以适用于其他语言（例如python，ruby）。模块的示例是 &lt;code&gt;Class::Container&lt;/code&gt; ， &lt;code&gt;LWP::Simple&lt;/code&gt; 或 &lt;code&gt;DBD::File&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="738d39668fa39fd446be00455410afcfca770f3c" translate="yes" xml:space="preserve">
          <source>This refers to code that constructs a metadata data structure, serializes into a bytestream and/or writes it to disk.</source>
          <target state="translated">这指的是构建元数据结构、序列化为bytestream和/或写入磁盘的代码。</target>
        </trans-unit>
        <trans-unit id="fdbb6deaa19e9a370f00c7ae0865d9d2054ba9d5" translate="yes" xml:space="preserve">
          <source>This refers to code that reads a metadata file, deserializes it into a data structure in memory, or interprets a data structure of metadata elements.</source>
          <target state="translated">这指的是读取元数据文件,将其反序列化为内存中的数据结构,或解释元数据元素的数据结构的代码。</target>
        </trans-unit>
        <trans-unit id="c31dda74f7214f2c1e1f0e262ad534c6710776eb" translate="yes" xml:space="preserve">
          <source>This regex from Benjamin Goldberg will add commas to numbers:</source>
          <target state="translated">这个来自Benjamin Goldberg的regex可以在数字上添加逗号。</target>
        </trans-unit>
        <trans-unit id="056a5755811e26e84ba66501ddc6e8aa83e0239e" translate="yes" xml:space="preserve">
          <source>This regexp covers a much more limited set of formats and constitutes the best practices for initializing version objects. Whether you choose to employ decimal or dotted-decimal for is a personal preference however.</source>
          <target state="translated">这个 regexp 涵盖了更有限的格式集,并构成了初始化版本对象的最佳实践。然而,您选择使用十进制还是点阵十进制是个人的偏好。</target>
        </trans-unit>
        <trans-unit id="d63b86d7679f940ac8c61114c80aac9d0dbe5e33" translate="yes" xml:space="preserve">
          <source>This regexp covers all of the legal forms allowed under the current version string parser. This is not to say that all of these forms are recommended, and some of them can only be used when quoted.</source>
          <target state="translated">这个regexp涵盖了当前版本字符串解析器下允许的所有合法形式。这并不是说所有这些形式都是推荐的,其中一些形式只能在引用时使用。</target>
        </trans-unit>
        <trans-unit id="ba5402a82ba706913f690e8b3975f67ccd9cac88" translate="yes" xml:space="preserve">
          <source>This regexp displays a common task: perform a case-insensitive match. Perl provides a way of avoiding all those brackets by simply appending an &lt;code&gt;'i'&lt;/code&gt; to the end of the match. Then &lt;code&gt;/[yY][eE][sS]/;&lt;/code&gt; can be rewritten as &lt;code&gt;/yes/i;&lt;/code&gt; . The &lt;code&gt;'i'&lt;/code&gt; stands for case-insensitive and is an example of a</source>
          <target state="translated">此正则表达式显示一项常见任务：执行不区分大小写的匹配。Perl提供了一种避免所有这些括号的方法，只需在比赛的末尾附加一个 &lt;code&gt;'i'&lt;/code&gt; 即可。然后 &lt;code&gt;/[yY][eE][sS]/;&lt;/code&gt; 可以改写为 &lt;code&gt;/yes/i;&lt;/code&gt; 。所述 &lt;code&gt;'i'&lt;/code&gt; 表示不区分大小写的，并且是的一个例子</target>
        </trans-unit>
        <trans-unit id="3a214c88f7b6824fbb7ccf51b387a9a746e2ab88" translate="yes" xml:space="preserve">
          <source>This regexp displays a common task: perform a case-insensitive match. Perl provides a way of avoiding all those brackets by simply appending an &lt;code&gt;'i'&lt;/code&gt; to the end of the match. Then &lt;code&gt;/[yY][eE][sS]/;&lt;/code&gt; can be rewritten as &lt;code&gt;/yes/i;&lt;/code&gt;. The &lt;code&gt;'i'&lt;/code&gt; stands for case-insensitive and is an example of a</source>
          <target state="translated">此正则表达式显示一项常见任务：执行不区分大小写的匹配。Perl提供了一种避免所有这些括号的方法，只需在比赛的末尾附加一个 &lt;code&gt;'i'&lt;/code&gt; 即可。然后 &lt;code&gt;/[yY][eE][sS]/;&lt;/code&gt; 可以改写为 &lt;code&gt;/yes/i;&lt;/code&gt; 。所述 &lt;code&gt;'i'&lt;/code&gt; 表示不区分大小写的，并且是的一个例子</target>
        </trans-unit>
        <trans-unit id="f039b2c10f0c743bc7161531bc5bb4ee7cf32e0f" translate="yes" xml:space="preserve">
          <source>This regexp matches at the earliest string position, &lt;code&gt;'T'&lt;/code&gt; . One might think that &lt;code&gt;e&lt;/code&gt; , being leftmost in the alternation, would be matched, but &lt;code&gt;r&lt;/code&gt; produces the longest string in the first quantifier.</source>
          <target state="translated">此正则表达式在最早的字符串位置 &lt;code&gt;'T'&lt;/code&gt; 匹配。可能会认为 &lt;code&gt;e&lt;/code&gt; 在交替中最左端会被匹配，但是 &lt;code&gt;r&lt;/code&gt; 在第一个量词中产生最长的字符串。</target>
        </trans-unit>
        <trans-unit id="18bc3044ad1a70322cf6bfca75dfe2f27fadde89" translate="yes" xml:space="preserve">
          <source>This regexp matches at the earliest string position, &lt;code&gt;'T'&lt;/code&gt;. One might think that &lt;code&gt;'e'&lt;/code&gt;, being leftmost in the alternation, would be matched, but &lt;code&gt;'r'&lt;/code&gt; produces the longest string in the first quantifier.</source>
          <target state="translated">此正则表达式在最早的字符串位置 &lt;code&gt;'T'&lt;/code&gt; 匹配。有人可能会认为交替出现的最左边的 &lt;code&gt;'e'&lt;/code&gt; 会被匹配，但是 &lt;code&gt;'r'&lt;/code&gt; 会在第一个量词中产生最长的字符串。</target>
        </trans-unit>
        <trans-unit id="b2afed8f05eefbd66a6b4b21a4dd6dc09f86be3d" translate="yes" xml:space="preserve">
          <source>This regexp without the &lt;code&gt;/x&lt;/code&gt; modifier is</source>
          <target state="translated">不带 &lt;code&gt;/x&lt;/code&gt; 修饰符的正则表达式为</target>
        </trans-unit>
        <trans-unit id="a7d61ce1428d48124b4e47e558b037fdd3f04877" translate="yes" xml:space="preserve">
          <source>This registers warning categories for the given names and is primarily for use by the warnings::register pragma.</source>
          <target state="translated">它为给定的名字注册警告类别,主要用于警告::register pragma。</target>
        </trans-unit>
        <trans-unit id="ac7da667100d67a773306ce2d3526ac0aaefa222" translate="yes" xml:space="preserve">
          <source>This release (5.14) uses &lt;code&gt;unix&lt;/code&gt; as the bottom layer on Win32, and so still uses the C compiler's numeric file descriptor routines. There is an experimental native &lt;code&gt;win32&lt;/code&gt; layer, which is expected to be enhanced and should eventually become the default under Win32.</source>
          <target state="translated">此版本（5.14）使用 &lt;code&gt;unix&lt;/code&gt; 作为Win32的底层，因此仍使用C编译器的数字文件描述符例程。有一个实验性的本机 &lt;code&gt;win32&lt;/code&gt; 层，有望得到增强，最终应成为Win32下的默认层。</target>
        </trans-unit>
        <trans-unit id="e97366cc6c8c908874e040814cdab3c3ba7152dc" translate="yes" xml:space="preserve">
          <source>This release (5.30) uses &lt;code&gt;:unix&lt;/code&gt; as the bottom layer on Win32, and so still uses the C compiler's numeric file descriptor routines. There is an experimental native &lt;code&gt;:win32&lt;/code&gt; layer, which is expected to be enhanced and may eventually become the default under Win32.</source>
          <target state="translated">此版本（5.30）使用 &lt;code&gt;:unix&lt;/code&gt; 作为Win32的底层，因此仍使用C编译器的数字文件描述符例程。有一个实验性的本机 &lt;code&gt;:win32&lt;/code&gt; 层，有望得到增强，并最终可能成为Win32下的默认层。</target>
        </trans-unit>
        <trans-unit id="08e93ba339b839f549405138c86c3e7a085e38a6" translate="yes" xml:space="preserve">
          <source>This release of Storable can be used on a newer version of Perl to serialize data which is not supported by earlier Perls. By default, Storable will attempt to do the right thing, by &lt;code&gt;croak()&lt;/code&gt; ing if it encounters data that it cannot deserialize. However, the defaults can be changed as follows:</source>
          <target state="translated">可以在较新版本的Perl上使用此版本的Storable来序列化早期Perls不支持的数据。默认情况下，如果Storable 遇到无法反序列化的数据，它将通过 &lt;code&gt;croak()&lt;/code&gt; 尝试做正确的事情。但是，可以如下更改默认值：</target>
        </trans-unit>
        <trans-unit id="7ffdd0bf1fbd694aafba1b69b74908623d9b39e0" translate="yes" xml:space="preserve">
          <source>This release of Storable can be used on a newer version of Perl to serialize data which is not supported by earlier Perls. By default, Storable will attempt to do the right thing, by &lt;code&gt;croak()&lt;/code&gt;ing if it encounters data that it cannot deserialize. However, the defaults can be changed as follows:</source>
          <target state="translated">可以在较新版本的Perl上使用此版本的Storable来序列化早期Perls不支持的数据。默认情况下，如果Storable遇到无法反序列化的数据，它将通过 &lt;code&gt;croak()&lt;/code&gt; 尝试做正确的事情。但是，可以如下更改默认值：</target>
        </trans-unit>
        <trans-unit id="224448a00c11022eb7a054d96b5b7887fe965764" translate="yes" xml:space="preserve">
          <source>This relied on &lt;code&gt;Test::Builder-&amp;gt;_try()&lt;/code&gt; which was a private method, documented as something nobody should use. This was fixed by using a different tool.</source>
          <target state="translated">这依赖于 &lt;code&gt;Test::Builder-&amp;gt;_try()&lt;/code&gt; ，这是一个私有方法，被记录为任何人都不应使用的东西。这是通过使用其他工具解决的。</target>
        </trans-unit>
        <trans-unit id="1df9abd6e13cb17537a033c0a98a21365649ee63" translate="yes" xml:space="preserve">
          <source>This relies on the fact that uninitialized array elements are set to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">这取决于未初始化的数组元素设置为 &lt;code&gt;NULL&lt;/code&gt; 的事实。</target>
        </trans-unit>
        <trans-unit id="2d1b77b3467fa5b58df05f447b8e32028382b1ea" translate="yes" xml:space="preserve">
          <source>This relies on the fact that uninitialized array elements are set to NULL.</source>
          <target state="translated">这依赖于未初始化的数组元素被设置为NULL的事实。</target>
        </trans-unit>
        <trans-unit id="44ecfba29c712b60c9051df87b6cdce165f041c1" translate="yes" xml:space="preserve">
          <source>This removes the requirement for a given module from the object.</source>
          <target state="translated">这就从对象中删除了对某个模块的要求。</target>
        </trans-unit>
        <trans-unit id="9d7d55aad79de70107f3e8211b62fbf8c98570e5" translate="yes" xml:space="preserve">
          <source>This renders a print statement, which includes a call to the function. It's identical to rendering a file with a use call and that single statement, except for the filename which appears in the nextstate ops.</source>
          <target state="translated">这将渲染一条打印语句,其中包括对函数的调用。这与渲染一个带有使用调用和单一语句的文件是一样的,只是文件名会出现在 nextstate ops 中。</target>
        </trans-unit>
        <trans-unit id="ea6f5b9409b135d9fd2914f5e9712bb211e3d415" translate="yes" xml:space="preserve">
          <source>This renders all functions in the B::Concise package with the source lines. It eschews the O framework so that the stashref can be passed directly to B::Concise::compile(). See -stash option for a more convenient way to render a package.</source>
          <target state="translated">它可以渲染 B::Concise 包中的所有函数的源代码行。它避开了 O 框架,因此 stashref 可以直接传递给 B::Concise::compile()。参见 -stash 选项以获得更方便的渲染包的方法。</target>
        </trans-unit>
        <trans-unit id="32554955438229712c4cac893fa9122a188f77ea" translate="yes" xml:space="preserve">
          <source>This replaces any read-only SV with a fresh SV and removes any magic.</source>
          <target state="translated">这将用一个新鲜的SV替换任何只读SV,并删除任何魔法。</target>
        </trans-unit>
        <trans-unit id="e348cbe59c03a2464d04a9305501c3c5773cd34e" translate="yes" xml:space="preserve">
          <source>This replaces any read-only SV with a fresh writable copy and removes any magic.</source>
          <target state="translated">这将用一个新的可写副本替换任何只读SV,并删除任何魔法。</target>
        </trans-unit>
        <trans-unit id="4e89c15d6e7988885e07ca54d3050b10693c573d" translate="yes" xml:space="preserve">
          <source>This reports whether the VMS process has been set to a case tolerant state, and returns true when the process is in the traditional case tolerant mode and false when case sensitivity has been enabled for the process. It is intended for use by the File::Spec::VMS-&amp;gt;case_tolerant method only, and it is recommended that you only use File::Spec-&amp;gt;case_tolerant.</source>
          <target state="translated">这将报告VMS进程是否已设置为区分大小写的状态，并且当该进程处于传统的区分大小写模式时返回true，而当为该进程启用区分大小写时返回false。它仅适用于File :: Spec :: VMS-&amp;gt; case_tolerant方法，建议您仅使用File :: Spec-&amp;gt; case_tolerant。</target>
        </trans-unit>
        <trans-unit id="65869e50f6892b08c4cf7dcb78cc5963bf748c6b" translate="yes" xml:space="preserve">
          <source>This requires &lt;code&gt;perl-5.8&lt;/code&gt; or higher, compiled with &lt;code&gt;perlio&lt;/code&gt;</source>
          <target state="translated">这需要 &lt;code&gt;perl-5.8&lt;/code&gt; 或更高版本（使用 &lt;code&gt;perlio&lt;/code&gt; 编译）</target>
        </trans-unit>
        <trans-unit id="cf4909d18f4323c37d07bae96a1d0080562f63f5" translate="yes" xml:space="preserve">
          <source>This requires require a 64-bit MIPS CPU (R8000, R10000, ...)</source>
          <target state="translated">这需要一个64位的MIPS CPU (R8000,R10000,...)</target>
        </trans-unit>
        <trans-unit id="f7da7513031db644267fa4b13fabe99ed2a030c7" translate="yes" xml:space="preserve">
          <source>This restores one of the standard line-styles: &lt;code&gt;terse&lt;/code&gt; , &lt;code&gt;concise&lt;/code&gt; , &lt;code&gt;linenoise&lt;/code&gt; , &lt;code&gt;debug&lt;/code&gt; , &lt;code&gt;env&lt;/code&gt; , into effect. It also accepts style names previously defined with add_style().</source>
          <target state="translated">这将恢复标准线样式之一： &lt;code&gt;terse&lt;/code&gt; ， &lt;code&gt;concise&lt;/code&gt; ， &lt;code&gt;linenoise&lt;/code&gt; ， &lt;code&gt;debug&lt;/code&gt; ， &lt;code&gt;env&lt;/code&gt; ，生效。它还接受以前用add_style（）定义的样式名称。</target>
        </trans-unit>
        <trans-unit id="36fc0f09fd582998b2f90539bd1668c94507a44b" translate="yes" xml:space="preserve">
          <source>This restores one of the standard line-styles: &lt;code&gt;terse&lt;/code&gt;, &lt;code&gt;concise&lt;/code&gt;, &lt;code&gt;linenoise&lt;/code&gt;, &lt;code&gt;debug&lt;/code&gt;, &lt;code&gt;env&lt;/code&gt;, into effect. It also accepts style names previously defined with add_style().</source>
          <target state="translated">这将恢复标准线样式之一： &lt;code&gt;terse&lt;/code&gt; ， &lt;code&gt;concise&lt;/code&gt; ， &lt;code&gt;linenoise&lt;/code&gt; ， &lt;code&gt;debug&lt;/code&gt; ， &lt;code&gt;env&lt;/code&gt; ，生效。它还接受先前用add_style（）定义的样式名称。</target>
        </trans-unit>
        <trans-unit id="f0559182bda8492a3ca4dae9b14b73dc55291956" translate="yes" xml:space="preserve">
          <source>This restores the default behavior after you've changed it with '-main' (it's not normally needed). If no subroutine name/ref is given, main is rendered, regardless of this flag.</source>
          <target state="translated">当你用'-main'改变了默认行为后,它将恢复默认行为(通常不需要)。如果没有给出子程序的名称/引用,则不管这个标志如何,main都会被渲染。</target>
        </trans-unit>
        <trans-unit id="f49545d47b4c2e67130feb223d7916803e2151e7" translate="yes" xml:space="preserve">
          <source>This restores the token object(s) to the front of the parser stream.</source>
          <target state="translated">这将令牌对象还原到解析器流的前面。</target>
        </trans-unit>
        <trans-unit id="bc16a591c72f30b96574184a49591c3cb8b3396e" translate="yes" xml:space="preserve">
          <source>This results in checking out the median commit between &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;perl-5.10.0&lt;/code&gt;. You can then run the bisecting process with:</source>
          <target state="translated">这导致检出 &lt;code&gt;HEAD&lt;/code&gt; 和 &lt;code&gt;perl-5.10.0&lt;/code&gt; 之间的中位数提交。然后，您可以使用以下方法运行平分过程：</target>
        </trans-unit>
        <trans-unit id="abc61a1506f4a52166fcca29cd0724a61c00502b" translate="yes" xml:space="preserve">
          <source>This returns -1 if it is not possible to know.</source>
          <target state="translated">如果不可能知道,则返回-1。</target>
        </trans-unit>
        <trans-unit id="7c7a366a88c90193129d1a95d7e39c2f2c494051" translate="yes" xml:space="preserve">
          <source>This returns -1 if there is no way to check (assume yes)</source>
          <target state="translated">如果没有办法检查,则返回-1(假设是)。</target>
        </trans-unit>
        <trans-unit id="cc21f44beb4322ca69654d9019b9237853614328" translate="yes" xml:space="preserve">
          <source>This returns 0 if there are (most likely) no pending events.</source>
          <target state="translated">如果没有(很可能)待处理事件,则返回0。</target>
        </trans-unit>
        <trans-unit id="8bd0398abb2c08261b0415684f65513126559e63" translate="yes" xml:space="preserve">
          <source>This returns 0 if there are no pending events.</source>
          <target state="translated">如果没有未决事件,则返回0。</target>
        </trans-unit>
        <trans-unit id="9e5a3b4ddffecb8501f761fb971c3b2d6c7162bb" translate="yes" xml:space="preserve">
          <source>This returns 1 if there are (likely) pending events. Upon return it will reset, nothing else will be able to see that there were pending events.</source>
          <target state="translated">如果有(可能)待处理的事件,则返回1。返回后将重置,其他任何东西都无法看到有待处理的事件。</target>
        </trans-unit>
        <trans-unit id="aa266181f0344e330298c3c78c5770ba393e0756" translate="yes" xml:space="preserve">
          <source>This returns 1 if there are pending events.</source>
          <target state="translated">如果有未决事件,则返回1。</target>
        </trans-unit>
        <trans-unit id="438306ebd9d1acbe91b86dc11907f9e6dab643b7" translate="yes" xml:space="preserve">
          <source>This returns NULL if the variable does not exist.</source>
          <target state="translated">如果变量不存在,则返回NULL。</target>
        </trans-unit>
        <trans-unit id="7a696a06774c6f3002eeb51ec2f2001513d53029" translate="yes" xml:space="preserve">
          <source>This returns a data structure containing the version requirements for a given module or undef if the given module has no requirements. This should not be used for version checks (see &lt;a href=&quot;#accepts_module&quot;&gt;&quot;accepts_module&quot;&lt;/a&gt; instead).</source>
          <target state="translated">这将返回一个数据结构，其中包含给定模块的版本要求；如果给定模块没有要求，则返回undef。不应将其用于版本检查（请参阅&lt;a href=&quot;#accepts_module&quot;&gt;&amp;ldquo; accepts_module&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c37bfa051bc09e91f6aa8c8e068658f22a9b05b4" translate="yes" xml:space="preserve">
          <source>This returns a glob reference for the symbol table entry of VARNAME in the package of the compartment. VARNAME must be the &lt;b&gt;name&lt;/b&gt; of a variable without any leading type marker. For example:</source>
          <target state="translated">这将返回隔离专区包中VARNAME的符号表条目的全局引用。VARNAME必须是没有任何前导类型标记的变量的&lt;b&gt;名称&lt;/b&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="4846a06785f0daaeee2213d80f23082c8fa4965c" translate="yes" xml:space="preserve">
          <source>This returns a handy stringified value of this object. This is useful for debugging, as in:</source>
          <target state="translated">这将返回这个对象的一个方便的字符串化值。这对调试很有用,比如说。</target>
        </trans-unit>
        <trans-unit id="ed3e8770a5f12bfd2e6e0013e9c81234e1f2fd4f" translate="yes" xml:space="preserve">
          <source>This returns a list of all facets that have been loaded using the &lt;code&gt;load_facet()&lt;/code&gt; method. This will not return any classes that have not been loaded, or have been loaded directly without a call to &lt;code&gt;load_facet()&lt;/code&gt;.</source>
          <target state="translated">这将返回已使用 &lt;code&gt;load_facet()&lt;/code&gt; 方法加载的所有构面的列表。这将不会返回任何尚未加载的类，或者不调用 &lt;code&gt;load_facet()&lt;/code&gt; 而直接加载的任何类。</target>
        </trans-unit>
        <trans-unit id="b1ea704d04f7c3ec75b7f4e64aa2fc6d627bedce" translate="yes" xml:space="preserve">
          <source>This returns a list of the elements of the op's aux data structure, or a null list if there is no aux. What will be returned depends on the object's type, but will typically be a collection of &lt;code&gt;B::IV&lt;/code&gt; , &lt;code&gt;B::GV&lt;/code&gt; , etc. objects. &lt;code&gt;cv&lt;/code&gt; is the &lt;code&gt;B::CV&lt;/code&gt; object representing the sub that the op is contained within.</source>
          <target state="translated">这将返回op的aux数据结构的元素列表，如果没有aux，则返回空列表。返回的内容取决于对象的类型，但通常是 &lt;code&gt;B::IV&lt;/code&gt; ， &lt;code&gt;B::GV&lt;/code&gt; 等对象的集合。 &lt;code&gt;cv&lt;/code&gt; 是 &lt;code&gt;B::CV&lt;/code&gt; 对象，表示op所包含的子对象。</target>
        </trans-unit>
        <trans-unit id="18b3e284330afc61e3a6c84779d9500461f4397e" translate="yes" xml:space="preserve">
          <source>This returns a list of the elements of the op's aux data structure, or a null list if there is no aux. What will be returned depends on the object's type, but will typically be a collection of &lt;code&gt;B::IV&lt;/code&gt;, &lt;code&gt;B::GV&lt;/code&gt;, etc. objects. &lt;code&gt;cv&lt;/code&gt; is the &lt;code&gt;B::CV&lt;/code&gt; object representing the sub that the op is contained within.</source>
          <target state="translated">这将返回op的aux数据结构的元素的列表，如果没有aux，则返回空列表。返回的内容取决于对象的类型，但通常是 &lt;code&gt;B::IV&lt;/code&gt; ， &lt;code&gt;B::GV&lt;/code&gt; 等对象的集合。 &lt;code&gt;cv&lt;/code&gt; 是 &lt;code&gt;B::CV&lt;/code&gt; 对象，表示op所包含的子对象。</target>
        </trans-unit>
        <trans-unit id="78c4d2eacb966527e478f0083cb85da673514051" translate="yes" xml:space="preserve">
          <source>This returns a list of the names of all the installed modules. The perl 'core' is given the special name 'Perl'.</source>
          <target state="translated">这将返回一个所有安装模块的名称列表。perl的 &quot;core &quot;被赋予了特殊的名称 &quot;Perl&quot;。</target>
        </trans-unit>
        <trans-unit id="14379e40e50bf7d9283b3df7b37c3928bd424f74" translate="yes" xml:space="preserve">
          <source>This returns a new CPAN::Meta::Requirements object. It takes an optional hash reference argument. Currently, only one key is supported:</source>
          <target state="translated">返回一个新的 CPAN::Meta::Requirements 对象。它需要一个可选的哈希引用参数。目前只支持一个键。</target>
        </trans-unit>
        <trans-unit id="531b8c5d5e45b476d43548e396af61e47ca0e014" translate="yes" xml:space="preserve">
          <source>This returns a new Feature object. The &lt;code&gt;%spec&lt;/code&gt; argument to the constructor should be the same as the value of the &lt;code&gt;optional_feature&lt;/code&gt; entry in the distmeta. It must contain entries for &lt;code&gt;description&lt;/code&gt; and &lt;code&gt;prereqs&lt;/code&gt;.</source>
          <target state="translated">这将返回一个新的Feature对象。构造函数的 &lt;code&gt;%spec&lt;/code&gt; 参数应与distmeta中的 &lt;code&gt;optional_feature&lt;/code&gt; 条目的值相同。它必须包含用于 &lt;code&gt;description&lt;/code&gt; 和 &lt;code&gt;prereqs&lt;/code&gt; 的条目。</target>
        </trans-unit>
        <trans-unit id="a39fe91e6096e4528d2eface949d54878f13adb3" translate="yes" xml:space="preserve">
          <source>This returns a new parser object, where</source>
          <target state="translated">这将返回一个新的解析器对象,其中的</target>
        </trans-unit>
        <trans-unit id="c0e359e0a6bfe07d5ae556f45550772e1dc21138" translate="yes" xml:space="preserve">
          <source>This returns a normal Perl scalar from $x. It is used automatically whenever a scalar is needed, for instance in array index operations.</source>
          <target state="translated">这个函数从$x返回一个普通的Perl标量。每当需要标量的时候,比如在数组索引操作中,就会自动使用它。</target>
        </trans-unit>
        <trans-unit id="39af602c2add0567b4eacfb622fe97070c79fecd" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash describing the requirements using the strings in the &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt; specification.</source>
          <target state="translated">这将返回对哈希的引用，该哈希使用&lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN :: Meta :: Spec&lt;/a&gt;规范中的字符串描述了需求。</target>
        </trans-unit>
        <trans-unit id="4bedda000844c8f0e165c8e9491e25dc6f787dac" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash which has short general category names (such as &lt;code&gt;Lu&lt;/code&gt; , &lt;code&gt;Nd&lt;/code&gt; , &lt;code&gt;Zs&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; ) as keys and long names (such as &lt;code&gt;UppercaseLetter&lt;/code&gt; , &lt;code&gt;DecimalNumber&lt;/code&gt; , &lt;code&gt;SpaceSeparator&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; ) as values. The hash is reversible in case you need to go from the long names to the short names. The general category is the one returned from &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; under the &lt;code&gt;category&lt;/code&gt; key.</source>
          <target state="translated">这将返回对哈希的引用，该哈希具有短的常规类别名称（例如 &lt;code&gt;Lu&lt;/code&gt; ， &lt;code&gt;Nd&lt;/code&gt; ， &lt;code&gt;Zs&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; ）作为键，而长名称（例如 &lt;code&gt;UppercaseLetter&lt;/code&gt; ， &lt;code&gt;DecimalNumber&lt;/code&gt; ， &lt;code&gt;SpaceSeparator&lt;/code&gt; ， &lt;code&gt;Symbol&lt;/code&gt; ）作为值。如果您需要从长名称到短名称，则哈希是可逆的。常规类别是在 &lt;code&gt;category&lt;/code&gt; 键下从&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;返回的类别。</target>
        </trans-unit>
        <trans-unit id="039f30ebcd1468ad00dd473984fb486ddd84fa51" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash which has short general category names (such as &lt;code&gt;Lu&lt;/code&gt;, &lt;code&gt;Nd&lt;/code&gt;, &lt;code&gt;Zs&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;) as keys and long names (such as &lt;code&gt;UppercaseLetter&lt;/code&gt;, &lt;code&gt;DecimalNumber&lt;/code&gt;, &lt;code&gt;SpaceSeparator&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;) as values. The hash is reversible in case you need to go from the long names to the short names. The general category is the one returned from &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt; under the &lt;code&gt;category&lt;/code&gt; key.</source>
          <target state="translated">这将返回对哈希的引用，该哈希具有短的常规类别名称（例如 &lt;code&gt;Lu&lt;/code&gt; ， &lt;code&gt;Nd&lt;/code&gt; ， &lt;code&gt;Zs&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; ）作为键，而长名称（例如 &lt;code&gt;UppercaseLetter&lt;/code&gt; ， &lt;code&gt;DecimalNumber&lt;/code&gt; ， &lt;code&gt;SpaceSeparator&lt;/code&gt; ， &lt;code&gt;Symbol&lt;/code&gt; ）作为值。如果您需要将长名称更改为短名称，则哈希是可逆的。常规类别是 &lt;code&gt;category&lt;/code&gt; 键下从&lt;a href=&quot;#charinfo%28%29&quot;&gt;&amp;ldquo; charinfo（）&amp;rdquo;&lt;/a&gt;返回的类别。</target>
        </trans-unit>
        <trans-unit id="88c58feecc3765e5c4080f925afe0ce2010395de" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash which has the short bidi (bidirectional) type names (such as &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; ) as keys and long names (such as &lt;code&gt;Left-to-Right&lt;/code&gt; , &lt;code&gt;Right-to-Left&lt;/code&gt; ) as values. The hash is reversible in case you need to go from the long names to the short names. The bidi type is the one returned from &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; under the &lt;code&gt;bidi&lt;/code&gt; key. For the exact meaning of the various bidi classes the Unicode TR9 is recommended reading: &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; (as of Unicode 5.0.0)</source>
          <target state="translated">这将返回对哈希的引用，该哈希的简称为双向（即双向）类型名称（例如 &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;R&lt;/code&gt; ），而长名称（例如 &lt;code&gt;Left-to-Right&lt;/code&gt; ， &lt;code&gt;Right-to-Left&lt;/code&gt; ）为值。如果您需要从长名称到短名称，则哈希是可逆的。 bidi类型是在 &lt;code&gt;bidi&lt;/code&gt; 键下从&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;返回的类型。对于各种比迪烟类的确切含义，建议阅读Unicode TR9：&lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http&lt;/a&gt; : //www.unicode.org/reports/tr9/（从Unicode 5.0.0开始）</target>
        </trans-unit>
        <trans-unit id="48267796da0925cc66914e24ff7b670270826077" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash which has the short bidi (bidirectional) type names (such as &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;) as keys and long names (such as &lt;code&gt;Left-to-Right&lt;/code&gt;, &lt;code&gt;Right-to-Left&lt;/code&gt;) as values. The hash is reversible in case you need to go from the long names to the short names. The bidi type is the one returned from &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt; under the &lt;code&gt;bidi&lt;/code&gt; key. For the exact meaning of the various bidi classes the Unicode TR9 is recommended reading: &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; (as of Unicode 5.0.0)</source>
          <target state="translated">这将返回对哈希的引用，该哈希的简称为双向（B双向）类型名称（例如 &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;R&lt;/code&gt; ），而长名称（例如 &lt;code&gt;Left-to-Right&lt;/code&gt; ， &lt;code&gt;Right-to-Left&lt;/code&gt; ）为值。如果您需要将长名称更改为短名称，则哈希是可逆的。 bidi类型是在 &lt;code&gt;bidi&lt;/code&gt; 键下从&lt;a href=&quot;#charinfo%28%29&quot;&gt;&amp;ldquo; charinfo（）&amp;rdquo;&lt;/a&gt;返回的类型。对于各种比迪烟类的确切含义，建议阅读Unicode TR9：&lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http&lt;/a&gt; : //www.unicode.org/reports/tr9/（从Unicode 5.0.0开始）</target>
        </trans-unit>
        <trans-unit id="f75d5049d79453d5b8c6ef528d7b4bbb5dbbb29f" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash which has the short bidi (bidirectional) type names (such as &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;) as keys and long names (such as &lt;code&gt;Left-to-Right&lt;/code&gt;, &lt;code&gt;Right-to-Left&lt;/code&gt;) as values. The hash is reversible in case you need to go from the long names to the short names. The bidi type is the one returned from &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt; under the &lt;code&gt;bidi&lt;/code&gt; key. For the exact meaning of the various bidi classes the Unicode TR9 is recommended reading: &lt;a href=&quot;https://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; (as of Unicode 5.0.0)</source>
          <target state="translated">这将返回对哈希的引用，该哈希的简称为双向（B双向）类型名称（例如 &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;R&lt;/code&gt; ），而长名称（例如 &lt;code&gt;Left-to-Right&lt;/code&gt; ， &lt;code&gt;Right-to-Left&lt;/code&gt; ）为值。如果您需要将长名称更改为短名称，则哈希是可逆的。 bidi类型是在 &lt;code&gt;bidi&lt;/code&gt; 键下从&lt;a href=&quot;#charinfo%28%29&quot;&gt;&amp;ldquo; charinfo（）&amp;rdquo;&lt;/a&gt;返回的类型。对于各种比迪烟类的确切含义，建议阅读Unicode TR9：&lt;a href=&quot;https://www.unicode.org/reports/tr9/&quot;&gt;http&lt;/a&gt; : //www.unicode.org/reports/tr9/（从Unicode 5.0.0开始）</target>
        </trans-unit>
        <trans-unit id="1e684e737bcd2717e8bbc64c2a24292cf8407953" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash whose keys are all the distinct Unicode (no Perl extension) properties, and whose values are the respective values for those properties for the input &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;.</source>
          <target state="translated">这将返回对哈希的引用，该哈希的键都是唯一的Unicode（无Perl扩展名）属性，并且其值是输入&lt;a href=&quot;#code-point-argument&quot;&gt;&amp;ldquo;代码点参数&amp;rdquo;的&lt;/a&gt;这些属性的相应值。</target>
        </trans-unit>
        <trans-unit id="9b6e4381af622706d0b561391364ef549fe16051" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash whose keys are all the distinct Unicode (no Perl extension) properties, and whose values are the respective values for those properties for the input &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;.</source>
          <target state="translated">这将返回对哈希的引用，该哈希的键都是唯一的Unicode（无Perl扩展名）属性，其值是输入&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数的&lt;/a&gt;那些属性的相应值。</target>
        </trans-unit>
        <trans-unit id="92aa49cb1c3f622edac6a155f13e38f83b6dfb08" translate="yes" xml:space="preserve">
          <source>This returns a scalar reference to the string that this token holds. This can be useful if you don't want to memory-copy the potentially large text value (well, as large as a paragraph or a verbatim block) as calling $token-&amp;gt;text would do.</source>
          <target state="translated">这将返回对该令牌保存的字符串的标量引用。如果您不希望像调用$ token-&amp;gt; text那样，对内存中潜在的大文本值（以及与段落或逐字记录块一样大）进行内存复制，则此功能很有用。</target>
        </trans-unit>
        <trans-unit id="34145279dcfb22813c0a829b74bb6750ab581547" translate="yes" xml:space="preserve">
          <source>This returns a string containing the version requirements for a given module in the format described in &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt; or undef if the given module has no requirements. This should only be used for informational purposes such as error messages and should not be interpreted or used for comparison (see &lt;a href=&quot;#accepts_module&quot;&gt;&quot;accepts_module&quot;&lt;/a&gt; instead).</source>
          <target state="translated">这将以&lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN :: Meta :: Spec中&lt;/a&gt;描述的格式返回包含给定模块的版本要求的字符串，如果给定模块没有要求，则返回undef。仅应将其用于提供信息，例如错误消息，并且不得解释或用于比较（请参见&lt;a href=&quot;#accepts_module&quot;&gt;&amp;ldquo; accepts_module&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2ab22c2c85c0520c74858caf823a5761f4144c2f" translate="yes" xml:space="preserve">
          <source>This returns a string of the form &quot;AUTHORID/TARBALL&quot;. If you want the full path and filename to this distribution on a CPAN mirror, then it is &lt;code&gt;.../authors/id/A/AU/AUTHORID/TARBALL&lt;/code&gt;.</source>
          <target state="translated">这将返回形式为&amp;ldquo; AUTHORID / TARBALL&amp;rdquo;的字符串。如果要在CPAN镜像上获取此分发的完整路径和文件名，则为 &lt;code&gt;.../authors/id/A/AU/AUTHORID/TARBALL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ddd7e0058fbe245746ba269fcc6ddbdc3f189037" translate="yes" xml:space="preserve">
          <source>This returns a string reporting the $VERSION value from your module (and its classname) as well as the $VERSION value of Pod::Simple. Note that &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; requires output formats (wherever possible) to note this detail in a comment in the output format. For example, for some kind of SGML output format:</source>
          <target state="translated">这将返回一个字符串，报告来自模块（及其类名）的$ VERSION值以及Pod :: Simple的$ VERSION值。请注意，&lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;需要输出格式（在可能的情况下），以便在输出格式的注释中注明此详细信息。例如，对于某种SGML输出格式：</target>
        </trans-unit>
        <trans-unit id="78d7fbfdd37ad836b426c426d9f57674d28b607c" translate="yes" xml:space="preserve">
          <source>This returns a textual representation of the object (likely to b useful for deparsing and debugging), or an empty string if the op type doesn't support this. &lt;code&gt;cv&lt;/code&gt; is the &lt;code&gt;B::CV&lt;/code&gt; object representing the sub that the op is contained within.</source>
          <target state="translated">这将返回对象的文本表示形式（可能对于b的解析和调试很有用），或者如果op类型不支持此字符串，则返回空字符串。 &lt;code&gt;cv&lt;/code&gt; 是 &lt;code&gt;B::CV&lt;/code&gt; 对象，表示op所包含的子对象。</target>
        </trans-unit>
        <trans-unit id="589c10ddf68513d199db67a67a86aebabd06473d" translate="yes" xml:space="preserve">
          <source>This returns all the case foldings in the current version of Unicode in the form of a reference to a hash. Each key to the hash is the decimal representation of a Unicode character that has a casefold to other than itself. The casefold of a semi-colon is itself, so it isn't in the hash; likewise for a lowercase &quot;a&quot;, but there is an entry for a capital &quot;A&quot;. The hash value for each key is another hash, identical to what is returned by &lt;a href=&quot;#casefold%28%29&quot;&gt;&quot;casefold()&quot;&lt;/a&gt; if called with that code point as its argument. So the value &lt;code&gt;all_casefolds()-&amp;gt;{ord(&quot;A&quot;)}'&lt;/code&gt; is equivalent to &lt;code&gt;casefold(ord(&quot;A&quot;))&lt;/code&gt;;</source>
          <target state="translated">这将以对哈希的引用形式返回当前版本Unicode中的所有大小写折叠。哈希的每个键都是Unicode字符的十进制表示形式，除了自身以外，还有其他大小写。分号的大小写是其自身，因此不在哈希表中。小写字母&amp;ldquo; a&amp;rdquo;也是如此，但是大写字母&amp;ldquo; A&amp;rdquo;存在一个条目。每个键的哈希值是另一个哈希，如果以该代码点作为其参数调用，则与&lt;a href=&quot;#casefold%28%29&quot;&gt;&amp;ldquo; casefold（）&amp;rdquo;&lt;/a&gt;返回的哈希值相同。因此，值 &lt;code&gt;all_casefolds()-&amp;gt;{ord(&quot;A&quot;)}'&lt;/code&gt; 等于 &lt;code&gt;casefold(ord(&quot;A&quot;))&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="5163e24143304da0c24ab6f05ddab5463a924808" translate="yes" xml:space="preserve">
          <source>This returns all the case foldings in the current version of Unicode in the form of a reference to a hash. Each key to the hash is the decimal representation of a Unicode character that has a casefold to other than itself. The casefold of a semi-colon is itself, so it isn't in the hash; likewise for a lowercase &quot;a&quot;, but there is an entry for a capital &quot;A&quot;. The hash value for each key is another hash, identical to what is returned by &lt;a href=&quot;#casefold()&quot;&gt;casefold()&lt;/a&gt; if called with that code point as its argument. So the value &lt;code&gt;all_casefolds()-&amp;gt;{&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;)}'&lt;/code&gt; is equivalent to &lt;code&gt;casefold(&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;))&lt;/code&gt; ;</source>
          <target state="translated">这将以对哈希的引用形式返回当前版本Unicode中的所有大小写折叠。哈希的每个键都是Unicode字符的十进制表示形式，除了自身以外，还有其他大小写。分号的大小写是其自身，因此不在哈希表中。小写字母&amp;ldquo; a&amp;rdquo;也是如此，但是大写字母&amp;ldquo; A&amp;rdquo;存在一个条目。每个键的哈希值是另一个哈希，如果以该代码点作为其参数调用，则与&lt;a href=&quot;#casefold()&quot;&gt;casefold（）&lt;/a&gt;返回的哈希相同。因此，值 &lt;code&gt;all_casefolds()-&amp;gt;{&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;)}'&lt;/code&gt; 等同于 &lt;code&gt;casefold(&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;))&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="b91ef374b2d4fc8d006452914a0d544355b3b1bb" translate="yes" xml:space="preserve">
          <source>This returns information about the input &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt; as a reference to a hash of fields as defined by the Unicode standard. If the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt; is not assigned in the standard (i.e., has the general category &lt;code&gt;Cn&lt;/code&gt; meaning &lt;code&gt;Unassigned&lt;/code&gt;) or is a non-character (meaning it is guaranteed to never be assigned in the standard), &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">这将返回有关输入&lt;a href=&quot;#code-point-argument&quot;&gt;&amp;ldquo;代码点参数&amp;rdquo;的信息，&lt;/a&gt;作为对Unicode标准定义的字段哈希的引用。如果未在标准中分配&lt;a href=&quot;#code-point-argument&quot;&gt;&amp;ldquo;代码点参数&amp;rdquo;&lt;/a&gt;（即，通用类别 &lt;code&gt;Cn&lt;/code&gt; 表示 &lt;code&gt;Unassigned&lt;/code&gt; ）或为非字符（表示保证从不在标准中分配），则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc96752d9a4198cd2cf54c44f2b3b5b10b6e33c5" translate="yes" xml:space="preserve">
          <source>This returns information about the input &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; as a reference to a hash of fields as defined by the Unicode standard. If the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; is not assigned in the standard (i.e., has the general category &lt;code&gt;Cn&lt;/code&gt; meaning &lt;code&gt;Unassigned&lt;/code&gt; ) or is a non-character (meaning it is guaranteed to never be assigned in the standard), &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">这将返回有关输入&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数的&lt;/a&gt;信息，作为对Unicode标准定义的字段哈希的引用。如果&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt;未在标准中分配（即，通用类别 &lt;code&gt;Cn&lt;/code&gt; 表示 &lt;code&gt;Unassigned&lt;/code&gt; ）或为非字符（表示保证从不在标准中分配），则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="720b1f4304617aafa21c73583795df1e0c36847e" translate="yes" xml:space="preserve">
          <source>This returns key/value pairs. The key is the module name, the value is the version number. If the installed version of the module is at or below the specified one then an upgrade is required for the module to work properly.</source>
          <target state="translated">该函数返回键/值对。键是模块名称,值是版本号。如果模块的安装版本低于或等于指定的版本,则需要进行升级才能正常工作。</target>
        </trans-unit>
        <trans-unit id="d4b8690d330c57f118fa7767021e234753523c18" translate="yes" xml:space="preserve">
          <source>This returns key/value pairs. The key is the module name, the value is the version number. If the installed version of the module is at or below the specified one then an upgrade would be a good idea, but not strictly necessary.</source>
          <target state="translated">该函数返回键/值对。key是模块名称,value是版本号。如果模块的安装版本在指定的版本之上或之下,那么升级是个好主意,但并不是绝对必要的。</target>
        </trans-unit>
        <trans-unit id="c8f9c7b3513420a38f5822d9d3cf20a8ca38b03e" translate="yes" xml:space="preserve">
          <source>This returns key/value pairs. The key is the module name, the value is the version number. If the installed version of the module is at or below the specified one then the module will not work. A newer version may work, but is not tested or verified.</source>
          <target state="translated">该函数返回键/值对。key是模块名称,value是版本号。如果模块安装的版本低于或等于指定的版本,那么该模块将无法工作。较新的版本可能会工作,但没有经过测试或验证。</target>
        </trans-unit>
        <trans-unit id="69bdf5cea17e905e3d66cdc8ddc0f9c868e3cf58" translate="yes" xml:space="preserve">
          <source>This returns the (almost) locale-independent case folding of the character specified by the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;. (Starting in Perl v5.16, the core function &lt;code&gt;fc()&lt;/code&gt; returns the &lt;code&gt;full&lt;/code&gt; mapping (described below) faster than this does, and for entire strings.)</source>
          <target state="translated">这将返回由&lt;a href=&quot;#code-point-argument&quot;&gt;&amp;ldquo;代码点参数&amp;rdquo;&lt;/a&gt;指定的字符的（几乎）与语言环境无关的大小写折叠。（从Perl v5.16开始，核心函数 &lt;code&gt;fc()&lt;/code&gt; 返回 &lt;code&gt;full&lt;/code&gt; 映射（如下所述）的速度比这样做更快，并且返回的是整个字符串。）</target>
        </trans-unit>
        <trans-unit id="eb91ab331ab9de210b4db7e921e9ff160732003a" translate="yes" xml:space="preserve">
          <source>This returns the (almost) locale-independent case folding of the character specified by the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;. (Starting in Perl v5.16, the core function &lt;code&gt;&lt;a href=&quot;../functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt; returns the &lt;code&gt;full&lt;/code&gt; mapping (described below) faster than this does, and for entire strings.)</source>
          <target state="translated">这将返回由&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt;指定的字符的（几乎）与语言环境无关的大小写折叠。（从Perl v5.16开始，核心函数 &lt;code&gt;&lt;a href=&quot;../functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;full&lt;/code&gt; 映射（如下所述）的速度比这样做更快，并且返回的是整个字符串。）</target>
        </trans-unit>
        <trans-unit id="91677229ee695edb8db59966a9bf52f69db7141f" translate="yes" xml:space="preserve">
          <source>This returns the ExtUtils::Packlist object for the specified module.</source>
          <target state="translated">返回指定模块的ExtUtils::Packlist对象。</target>
        </trans-unit>
        <trans-unit id="dffc96fcce0657afd70270ea32ed9cfdcbbe0c11" translate="yes" xml:space="preserve">
          <source>This returns the arguments that should be used to construct the proper &lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2::EventFacet::Info&lt;/a&gt; structure.</source>
          <target state="translated">这将返回用于构造适当的&lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2 :: EventFacet :: Info&lt;/a&gt;结构的参数。</target>
        </trans-unit>
        <trans-unit id="dc91311f7c5bdfc09fe1efb765e76b3d3c015ee2" translate="yes" xml:space="preserve">
          <source>This returns the count of Pod paragraphs seen so far.</source>
          <target state="translated">这将返回到目前为止看到的Pod段数。</target>
        </trans-unit>
        <trans-unit id="ccaab350d04c0aa0ce59d8ea55f9203083f5944f" translate="yes" xml:space="preserve">
          <source>This returns the data structure used for tables by &lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2::EventFacet::Info&lt;/a&gt;.</source>
          <target state="translated">这将返回&lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2 :: EventFacet :: Info&lt;/a&gt;用于表的数据结构。</target>
        </trans-unit>
        <trans-unit id="91c8292002290e5d7ad79eff5f6aca62a17b0302" translate="yes" xml:space="preserve">
          <source>This returns the file format version as number. It is a string like &quot;2.007&quot;. This value is suitable for numeric comparisons.</source>
          <target state="translated">这将以数字形式返回文件格式版本。它是一个字符串,如 &quot;2.007&quot;。这个值适合于数字比较。</target>
        </trans-unit>
        <trans-unit id="b28a3d3b844d30822d117ab98847259c42e20f28" translate="yes" xml:space="preserve">
          <source>This returns the file format version. It is a string like &quot;2.7&quot;.</source>
          <target state="translated">这将返回文件格式版本。它是一个字符串,如 &quot;2.7&quot;。</target>
        </trans-unit>
        <trans-unit id="88abd5e16e9b3ba61f0f89ea977172fa6b064d17" translate="yes" xml:space="preserve">
          <source>This returns the filename that this parser object was set to read from.</source>
          <target state="translated">返回这个解析器对象被设置为读取的文件名。</target>
        </trans-unit>
        <trans-unit id="bccff29a1ac784a814e5e53a8041bdec5c902b0f" translate="yes" xml:space="preserve">
          <source>This returns the full path of the first occurrence to the file. Package names (eg 'A::B') are automatically converted to directory names in the selected directory. Additionally, '.pm', '.pl' and '.pod' are automatically appended to the search as required. (So, for example, under Unix, &quot;A::B&quot; is converted to &quot;somedir/A/B.pm&quot;, &quot;somedir/A/B.pod&quot;, or &quot;somedir/A/B.pl&quot;, as appropriate.)</source>
          <target state="translated">这将返回第一次出现的文件的完整路径。包名(例如'A::B')会自动转换为所选目录中的目录名。此外,'.pm'、'.pl'和'.pod'会根据需要自动附加到搜索中。(所以,例如,在 Unix 下,&quot;A::B &quot;会被转换为 &quot;somedir/A/B.pm&quot;、&quot;somedir/A/B.pod &quot;或 &quot;somedir/A/B.pl&quot;,视情况而定。)</target>
        </trans-unit>
        <trans-unit id="2a501f04d237b4afdc751c24d97b1564c6c9be99" translate="yes" xml:space="preserve">
          <source>This returns the function name as a string (e.g. &quot;PL_ppaddr[OP_ADD]&quot;, &quot;PL_ppaddr[OP_RV2AV]&quot;).</source>
          <target state="translated">这将返回一个字符串的函数名称(例如 &quot;PL_ppaddr[OP_ADD]&quot;,&quot;PL_ppaddr[OP_RV2AV]&quot;)。</target>
        </trans-unit>
        <trans-unit id="a6c7ba8cdf1911985e871524f867f03a73878f39" translate="yes" xml:space="preserve">
          <source>This returns the given noun form which is appropriate for the quantity &lt;code&gt;$number&lt;/code&gt; according to this language's conventions. &lt;code&gt;numerate&lt;/code&gt; is used internally by &lt;code&gt;quant&lt;/code&gt; to quantify nouns. Use it directly -- usually from bracket notation -- to avoid &lt;code&gt;quant&lt;/code&gt; 's implicit call to &lt;code&gt;numf&lt;/code&gt; and output of a numeric quantity.</source>
          <target state="translated">根据该语言的约定，这将返回给定的名词形式，该形式适合于数量 &lt;code&gt;$number&lt;/code&gt; 。 &lt;code&gt;numerate&lt;/code&gt; 在内部由 &lt;code&gt;quant&lt;/code&gt; 用来量化名词。直接使用它-通常从方括号符号起-避免 &lt;code&gt;quant&lt;/code&gt; 对 &lt;code&gt;numf&lt;/code&gt; 的隐式调用和数字量的输出。</target>
        </trans-unit>
        <trans-unit id="f3221ea44d138b99a98ddd26d5fa0b5a10d585e1" translate="yes" xml:space="preserve">
          <source>This returns the given noun form which is appropriate for the quantity &lt;code&gt;$number&lt;/code&gt; according to this language's conventions. &lt;code&gt;numerate&lt;/code&gt; is used internally by &lt;code&gt;quant&lt;/code&gt; to quantify nouns. Use it directly -- usually from bracket notation -- to avoid &lt;code&gt;quant&lt;/code&gt;'s implicit call to &lt;code&gt;numf&lt;/code&gt; and output of a numeric quantity.</source>
          <target state="translated">这将根据该语言的约定返回给定的名词形式，该形式适合于数量 &lt;code&gt;$number&lt;/code&gt; 。 &lt;code&gt;numerate&lt;/code&gt; 在内部由 &lt;code&gt;quant&lt;/code&gt; 用来量化名词。直接使用它-通常从方括号符号起-避免 &lt;code&gt;quant&lt;/code&gt; 对 &lt;code&gt;numf&lt;/code&gt; 的隐式调用和数字量的输出。</target>
        </trans-unit>
        <trans-unit id="9ecd76e9b7635df85484a01189e6a2f492cf6d79" translate="yes" xml:space="preserve">
          <source>This returns the given number formatted nicely according to this language's conventions. Maketext's default method is mostly to just take the normal string form of the number (applying sprintf &quot;%G&quot; for only very large numbers), and then to add commas as necessary. (Except that we apply &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr/,./.,/&lt;/a&gt;&lt;/code&gt; if $language-&amp;gt;{'numf_comma'} is true; that's a bit of a hack that's useful for languages that express two million as &quot;2.000.000&quot; and not as &quot;2,000,000&quot;).</source>
          <target state="translated">这将返回给定的数字，该数字按照该语言的约定很好地格式化。Maketext的默认方法主要是采用数字的常规字符串形式（仅对非常大的数字应用sprintf&amp;ldquo;％G&amp;rdquo;），然后根据需要添加逗号。（除了如果$ language-&amp;gt; {'numf_comma'}为true时，我们将应用 &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr/,./.,/&lt;/a&gt;&lt;/code&gt; ；这是一个小技巧，对于将200万表示为&amp;ldquo; 2.000.000&amp;rdquo;而不是&amp;ldquo; 2,000,000&amp;ldquo;）。</target>
        </trans-unit>
        <trans-unit id="05a83ab19e6c9cde5d56340c6947ca203501a3b8" translate="yes" xml:space="preserve">
          <source>This returns the given number formatted nicely according to this language's conventions. Maketext's default method is mostly to just take the normal string form of the number (applying sprintf &quot;%G&quot; for only very large numbers), and then to add commas as necessary. (Except that we apply &lt;code&gt;tr/,./.,/&lt;/code&gt; if $language-&amp;gt;{'numf_comma'} is true; that's a bit of a hack that's useful for languages that express two million as &quot;2.000.000&quot; and not as &quot;2,000,000&quot;).</source>
          <target state="translated">这将返回给定的数字，该数字按照该语言的约定很好地格式化。Maketext的默认方法主要是采用数字的常规字符串形式（仅对非常大的数字应用sprintf&amp;ldquo;％G&amp;rdquo;），然后根据需要添加逗号。（除非$ language-&amp;gt; {'numf_comma'}为true，否则我们将应用 &lt;code&gt;tr/,./.,/&lt;/code&gt; 2,000,000&amp;ldquo;）。</target>
        </trans-unit>
        <trans-unit id="025fac90217d4ce617ea39a22bf3a99d01ca61a8" translate="yes" xml:space="preserve">
          <source>This returns the hashref that is the attribute set for this start-token. This is useful if (for example) you want to ask what all the attributes are -- you can just do &lt;code&gt;&lt;a href=&quot;../../functions/keys&quot;&gt;keys&lt;/a&gt; %{$token-&amp;gt;attr_hash}&lt;/code&gt;</source>
          <target state="translated">这将返回hashref，它是为此起始令牌设置的属性。如果（例如）您想询问所有属性是什么，这很有用-您可以只做 &lt;code&gt;&lt;a href=&quot;../../functions/keys&quot;&gt;keys&lt;/a&gt; %{$token-&amp;gt;attr_hash}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c00d82623e18153d6a353f47395dae6583b5a22" translate="yes" xml:space="preserve">
          <source>This returns the hashref that is the attribute set for this start-token. This is useful if (for example) you want to ask what all the attributes are -- you can just do &lt;code&gt;keys %{$token-&amp;gt;attr_hash}&lt;/code&gt;</source>
          <target state="translated">这将返回hashref，它是为此起始令牌设置的属性。如果（例如）您要询问所有属性是什么，则这很有用-您可以只执行 &lt;code&gt;keys %{$token-&amp;gt;attr_hash}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26a1d54ba9e2a0e72117dea2ff05555485f06342" translate="yes" xml:space="preserve">
          <source>This returns the name of the associated .packlist file</source>
          <target state="translated">这将返回相关的.packlist文件的名称。</target>
        </trans-unit>
        <trans-unit id="1e09dcd49b996b5c9c29c7bd188efbeaabae3afb" translate="yes" xml:space="preserve">
          <source>This returns the next token object (which will be of a subclass of &lt;a href=&quot;Pod::Simple::PullParserToken&quot;&gt;Pod::Simple::PullParserToken&lt;/a&gt;), or undef if the parser-stream has hit the end of the document.</source>
          <target state="translated">这将返回下一个令牌对象（将是&lt;a href=&quot;Pod::Simple::PullParserToken&quot;&gt;Pod :: Simple :: PullParserToken&lt;/a&gt;的子类），如果解析器流到达文档的末尾，则返回undef。</target>
        </trans-unit>
        <trans-unit id="8714a4ea9c89be9e02bb0a484046217a2fdc2659" translate="yes" xml:space="preserve">
          <source>This returns the next token object (which will be of a subclass of &lt;a href=&quot;pullparsertoken&quot;&gt;Pod::Simple::PullParserToken&lt;/a&gt;), or undef if the parser-stream has hit the end of the document.</source>
          <target state="translated">这将返回下一个标记对象（将是&lt;a href=&quot;pullparsertoken&quot;&gt;Pod :: Simple :: PullParserToken&lt;/a&gt;的子类），如果解析器流到达文档的末尾，则返回undef。</target>
        </trans-unit>
        <trans-unit id="db9439ac80b35bc802acd8f20ce2c7390e307d09" translate="yes" xml:space="preserve">
          <source>This returns the op description from the global C PL_op_desc array (e.g. &quot;addition&quot; &quot;array deref&quot;).</source>
          <target state="translated">返回全局C语言PL_op_desc数组中的操作描述(例如 &quot;addition&quot;&quot;array deref&quot;)。</target>
        </trans-unit>
        <trans-unit id="5681c12774f7d1547e4176d6eccb3ccd12074a1f" translate="yes" xml:space="preserve">
          <source>This returns the op name as a string (e.g. &quot;add&quot;, &quot;rv2av&quot;).</source>
          <target state="translated">这将返回一个字符串的操作名称(例如 &quot;add&quot;,&quot;rv2av&quot;)。</target>
        </trans-unit>
        <trans-unit id="c03ab2186d312ee9f05759433ffaba12c8dd3636" translate="yes" xml:space="preserve">
          <source>This returns the potentially locale-dependent case mappings of the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;. The mappings may be longer than a single code point (which the basic Unicode case mappings as returned by &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt; never are).</source>
          <target state="translated">这将返回&lt;a href=&quot;#code-point-argument&quot;&gt;&amp;ldquo;代码点参数&amp;rdquo;&lt;/a&gt;的可能依赖于语言环境的大小写映射。映射可能比单个代码点长（&lt;a href=&quot;#charinfo%28%29&quot;&gt;&amp;ldquo; charinfo（）&amp;rdquo;&lt;/a&gt;返回的基本Unicode大小写映射永远不会）。</target>
        </trans-unit>
        <trans-unit id="7c24d1c30b8541d36722cb533fdf5d0b9d4b051d" translate="yes" xml:space="preserve">
          <source>This returns the potentially locale-dependent case mappings of the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;. The mappings may be longer than a single code point (which the basic Unicode case mappings as returned by &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; never are).</source>
          <target state="translated">这将返回&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt;的可能与语言环境相关的大小写映射。映射可能比单个代码点长（&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;返回的基本Unicode大小写映射从来都不是）。</target>
        </trans-unit>
        <trans-unit id="64bc8ef0666e73530b9a3f2cd195ef738c2d8851" translate="yes" xml:space="preserve">
          <source>This returns the string form of the table if it was set, otherwise it returns the string &lt;code&gt;&quot;&amp;lt;TABLE NOT DISPLAYED&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">如果设置了表，则返回表的字符串形式，否则返回字符串 &lt;code&gt;&quot;&amp;lt;TABLE NOT DISPLAYED&amp;gt;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e407d9572ab9c5f99771767ba652986d36609117" translate="yes" xml:space="preserve">
          <source>This returns the tagname for this end-token object. For example, parsing a &quot;=head1 ...&quot; line will give you a start-token with the tagname of &quot;head1&quot;, token(s) for its content, and then an end-token with the tagname of &quot;head1&quot;.</source>
          <target state="translated">这将返回这个结束标记对象的tagname。例如,解析&quot;=head1 ...&quot;行,会得到一个带有 &quot;head1 &quot;tagname的起始标记、内容的标记,以及带有 &quot;head1 &quot;tagname的结束标记。</target>
        </trans-unit>
        <trans-unit id="1457f9cf582cb43f3b8ece06b77a4a774ea5edd5" translate="yes" xml:space="preserve">
          <source>This returns the tagname for this start-token object. For example, parsing a &quot;=head1 ...&quot; line will give you a start-token with the tagname of &quot;head1&quot;, token(s) for its content, and then an end-token with the tagname of &quot;head1&quot;.</source>
          <target state="translated">这将返回这个起始标记对象的tagname。例如,解析&quot;=head1 ...&quot;行会得到一个带有 &quot;head1 &quot;tagname的起始标记、内容的标记,以及带有 &quot;head1 &quot;tagname的结束标记。</target>
        </trans-unit>
        <trans-unit id="a92df26815537e43f9c0925776fd61d439836096" translate="yes" xml:space="preserve">
          <source>This returns the text that this token holds. For example, parsing C&amp;lt;foo&amp;gt; will return a C start-token, a text-token, and a C end-token. And if you want to get the &quot;foo&quot; out of the text-token, call &lt;code&gt;$token-&amp;gt;text&lt;/code&gt;</source>
          <target state="translated">这将返回该令牌保存的文本。例如，解析C &amp;lt;foo&amp;gt;将返回C起始令牌，文本令牌和C终止令牌。如果 &lt;code&gt;$token-&amp;gt;text&lt;/code&gt; 令牌中删除&amp;ldquo; foo&amp;rdquo;，请调用$ token-&amp;gt; text</target>
        </trans-unit>
        <trans-unit id="37adaa267b32499cf66804411e8414b1ad1805e1" translate="yes" xml:space="preserve">
          <source>This returns the thread's context in the same manner as &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;.</source>
          <target state="translated">这将以与&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;相同的方式返回线程的上下文。</target>
        </trans-unit>
        <trans-unit id="cadb33aaeb1401584260a466e314c67532c002d6" translate="yes" xml:space="preserve">
          <source>This returns the thread's context in the same manner as &lt;a href=&quot;perlfunc#wantarray&quot;&gt;wantarray()&lt;/a&gt;.</source>
          <target state="translated">这将以与&lt;a href=&quot;perlfunc#wantarray&quot;&gt;wantarray（）&lt;/a&gt;相同的方式返回线程的上下文。</target>
        </trans-unit>
        <trans-unit id="e65fe0dbb6e214f3cd7dbd02a6dc6c382b0c30da" translate="yes" xml:space="preserve">
          <source>This returns the type of the token. This will be either the string &quot;start&quot;, the string &quot;text&quot;, or the string &quot;end&quot;.</source>
          <target state="translated">返回token的类型,可以是字符串 &quot;start&quot;、字符串 &quot;text &quot;或字符串 &quot;end&quot;。可以是字符串 &quot;start&quot;、字符串 &quot;text &quot;或字符串 &quot;end&quot;。</target>
        </trans-unit>
        <trans-unit id="11b6f6f063cb5805a948af38969c126392d218a6" translate="yes" xml:space="preserve">
          <source>This returns the value of the</source>
          <target state="translated">这将返回</target>
        </trans-unit>
        <trans-unit id="58c9aa25d44f77824a03159b1475adf1a9714a16" translate="yes" xml:space="preserve">
          <source>This returns the value of the Unicode property given by the second parameter for the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt; given by the first.</source>
          <target state="translated">对于第一个给出的&lt;a href=&quot;#code-point-argument&quot;&gt;&amp;ldquo;代码点参数&amp;rdquo;，&lt;/a&gt;这将返回第二个参数给出的Unicode属性的值。</target>
        </trans-unit>
        <trans-unit id="6e7567ac847e3dd9703ee4f767f192a1f4433a0b" translate="yes" xml:space="preserve">
          <source>This returns the value of the Unicode property given by the second parameter for the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; given by the first.</source>
          <target state="translated">这将为第&lt;a href=&quot;#code-point-argument&quot;&gt;一个参数&lt;/a&gt;指定的代码点参数返回第二个参数指定的Unicode属性值。</target>
        </trans-unit>
        <trans-unit id="00254886c0f76de134b6342f6c209f119eee2c52" translate="yes" xml:space="preserve">
          <source>This returns the version number for the specified module.</source>
          <target state="translated">返回指定模块的版本号。</target>
        </trans-unit>
        <trans-unit id="28cb21f0ce04fc34237dafa4d05afb66efd55c58" translate="yes" xml:space="preserve">
          <source>This returns the version of the Unicode Character Database, in other words, the version of the Unicode standard the database implements. The version is a string of numbers delimited by dots (&lt;code&gt;'.'&lt;/code&gt; ).</source>
          <target state="translated">这将返回Unicode字符数据库的版本，换句话说，即数据库实现的Unicode标准的版本。版本是一串由点（ &lt;code&gt;'.'&lt;/code&gt; ）分隔的数字。</target>
        </trans-unit>
        <trans-unit id="a289cd11d045f8591acb29dd41933e8954d58596" translate="yes" xml:space="preserve">
          <source>This returns the version of the Unicode Character Database, in other words, the version of the Unicode standard the database implements. The version is a string of numbers delimited by dots (&lt;code&gt;'.'&lt;/code&gt;).</source>
          <target state="translated">这将返回Unicode字符数据库的版本，换句话说，即数据库实现的Unicode标准的版本。版本是一串由点（ &lt;code&gt;'.'&lt;/code&gt; ）分隔的数字。</target>
        </trans-unit>
        <trans-unit id="0537cb9604bd46fdc53aedf1ef4d31156ea69d21" translate="yes" xml:space="preserve">
          <source>This returns true if &lt;code&gt;$parser&lt;/code&gt; has read from a source, and come to the end of that source.</source>
          <target state="translated">如果 &lt;code&gt;$parser&lt;/code&gt; 已从某个源中读取并到达该源的末尾，则返回true 。</target>
        </trans-unit>
        <trans-unit id="d892085e64119e5b73847e052d7936e4ec27fd45" translate="yes" xml:space="preserve">
          <source>This returns true if &lt;code&gt;$parser&lt;/code&gt; has read from a source, and has seen Pod content in it.</source>
          <target state="translated">如果 &lt;code&gt;$parser&lt;/code&gt; 已从源中读取并看到其中的Pod内容，则返回true 。</target>
        </trans-unit>
        <trans-unit id="0b811ea00850392c2bee3b4f40af1e1b677b7142" translate="yes" xml:space="preserve">
          <source>This returns true only if there has been any real content seen for this document. Returns false in cases where the document contains content, but does not make use of any Pod markup.</source>
          <target state="translated">只有当这个文档有真正的内容时,才返回true。如果文档包含内容,但没有使用任何Pod标记,则返回false。</target>
        </trans-unit>
        <trans-unit id="e28605a00b749132376858f485353c17ca2a0f0d" translate="yes" xml:space="preserve">
          <source>This routine also returns a different number of arguments depending on the success or failure of the call to statfs. If there is an error, the error number is returned as a single-element array. If the call is successful, then a 7-element array is returned. Since only one argument is passed into this function, we need room on the stack to hold the 7 values which may be returned.</source>
          <target state="translated">这个例程也会根据调用statfs的成功或失败返回不同数量的参数。如果出现错误,错误号将作为一个单元素数组返回。如果调用成功,则返回一个7元素数组。由于只有一个参数被传递到这个函数中,我们需要在堆栈中留出空间来容纳可能被返回的7个值。</target>
        </trans-unit>
        <trans-unit id="5b820e747b00eb7161f8b3a6555a694bd263c329" translate="yes" xml:space="preserve">
          <source>This routine behaves identically to the final two forms. That is, it does not return &lt;b&gt;true&lt;/b&gt; if the code point has a decomposition consisting of another single code point, nor if its decomposition starts with a code point whose combining class is non-zero. Code points that meet either of these conditions should also not be produced by composition normalization, which is probably why you should use the &lt;code&gt;Full_Composition_Exclusion&lt;/code&gt; property instead, as shown above.</source>
          <target state="translated">此例程的行为与最后两种形式相同。也就是说，如果代码点具有由另一个单个代码点组成的分解，或者其分解开始于其组合类别为非零的代码点，则它不会返回&lt;b&gt;true&lt;/b&gt;。满足上述任一条件的代码点也不应通过合成规范化来生成，这可能就是为什么您应该改用 &lt;code&gt;Full_Composition_Exclusion&lt;/code&gt; 属性的原因，如上所示。</target>
        </trans-unit>
        <trans-unit id="e6cbcd70e8dd9e2b5edee3c69038ed73e9a903ad" translate="yes" xml:space="preserve">
          <source>This routine checks to see what types of magic &lt;code&gt;sv&lt;/code&gt; has. If the mg_type field is an uppercase letter, then the mg_obj is copied to &lt;code&gt;nsv&lt;/code&gt; , but the mg_type field is changed to be the lowercase letter.</source>
          <target state="translated">该例程检查以查看魔术 &lt;code&gt;sv&lt;/code&gt; 的类型。如果mg_type字段是大写字母，则mg_obj将被复制到 &lt;code&gt;nsv&lt;/code&gt; ，但mg_type字段将变为小写字母。</target>
        </trans-unit>
        <trans-unit id="e4ebc0f1624cad62f6320cad80e7fcee1daed490" translate="yes" xml:space="preserve">
          <source>This routine checks to see what types of magic &lt;code&gt;sv&lt;/code&gt; has. If the mg_type field is an uppercase letter, then the mg_obj is copied to &lt;code&gt;nsv&lt;/code&gt;, but the mg_type field is changed to be the lowercase letter.</source>
          <target state="translated">此例程检查以查看魔术 &lt;code&gt;sv&lt;/code&gt; 类型。如果mg_type字段是大写字母，则mg_obj将被复制到 &lt;code&gt;nsv&lt;/code&gt; ，但是mg_type字段将变为小写字母。</target>
        </trans-unit>
        <trans-unit id="1147ded4271f3785411e40a784f62228ae86794d" translate="yes" xml:space="preserve">
          <source>This routine expects a single parameter--a reference to a subroutine or variable. It returns a list of attributes, which may be empty. If passed invalid arguments, it uses die() (via &lt;a href=&quot;carp&quot;&gt;Carp::croak&lt;/a&gt;) to raise a fatal exception. If it can find an appropriate package name for a class method lookup, it will include the results from a &lt;code&gt;FETCH_&lt;i&gt;type&lt;/i&gt;_ATTRIBUTES&lt;/code&gt; call in its return list, as described in &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;&quot;Package-specific Attribute Handling&quot;&lt;/a&gt; below. Otherwise, only &lt;a href=&quot;#Built-in-Attributes&quot;&gt;built-in attributes&lt;/a&gt; will be returned.</source>
          <target state="translated">该例程需要一个参数-对子例程或变量的引用。它返回属性列表，该列表可能为空。如果传递了无效的参数，它将使用die（）（通过&lt;a href=&quot;carp&quot;&gt;Carp :: croak&lt;/a&gt;）引发致命异常。如果它可以为类方法查找找到合适的包名称，则它将在其返回列表中包含来自 &lt;code&gt;FETCH_&lt;i&gt;type&lt;/i&gt;_ATTRIBUTES&lt;/code&gt; 调用的结果，如下面的&lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;&amp;ldquo;特定&lt;/a&gt;于包的属性处理&amp;rdquo;中所述。否则，将仅返回&lt;a href=&quot;#Built-in-Attributes&quot;&gt;内置属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="156fe43e5f5152548ce6f33bee1b7f0723071b2f" translate="yes" xml:space="preserve">
          <source>This routine expects a single parameter--a reference to a subroutine or variable. It returns a list of attributes, which may be empty. If passed invalid arguments, it uses die() (via &lt;a href=&quot;carp&quot;&gt;Carp::croak&lt;/a&gt;) to raise a fatal exception. If it can find an appropriate package name for a class method lookup, it will include the results from a &lt;code&gt;FETCH_&lt;i&gt;type&lt;/i&gt;_ATTRIBUTES&lt;/code&gt; call in its return list, as described in &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Package-specific Attribute Handling&lt;/a&gt; below. Otherwise, only &lt;a href=&quot;#Built-in-Attributes&quot;&gt;built-in attributes&lt;/a&gt; will be returned.</source>
          <target state="translated">该例程需要一个参数-对子例程或变量的引用。它返回属性列表，该列表可能为空。如果传递了无效的参数，它将使用die（）（通过&lt;a href=&quot;carp&quot;&gt;Carp :: croak&lt;/a&gt;）引发致命异常。如果它可以为类方法查找找到合适的包名称，则它将在其返回列表中包括来自 &lt;code&gt;FETCH_&lt;i&gt;type&lt;/i&gt;_ATTRIBUTES&lt;/code&gt; 调用的结果，如下面&lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;的特定&lt;/a&gt;于包的属性处理中所述。否则，将仅返回&lt;a href=&quot;#Built-in-Attributes&quot;&gt;内置属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1cbd8c6e15630953581b673b778fa0654a81555" translate="yes" xml:space="preserve">
          <source>This routine expects a single parameter--a reference to a subroutine or variable. It returns the built-in type of the referenced variable, ignoring any package into which it might have been blessed. This can be useful for determining the</source>
          <target state="translated">这个例程只需要一个参数--一个对子程序或变量的引用,它返回被引用变量的内置类型,忽略任何可能被祝福的包。它返回被引用变量的内置类型,忽略它可能已经被装入的任何包。这对于确定变量的</target>
        </trans-unit>
        <trans-unit id="a441bbdb5a22183756c86532b0bd8538c60db634" translate="yes" xml:space="preserve">
          <source>This routine is automatically used whenever a scalar is required:</source>
          <target state="translated">每当需要标量时,就会自动使用这个例程。</target>
        </trans-unit>
        <trans-unit id="9d5c36985c03c1b5c7bc41a618c507ece2116559" translate="yes" xml:space="preserve">
          <source>This routine is just a simple interface into GetOSVersion(). More specific or demanding situations should use that instead. Another option would be to use POSIX::uname(), however the latter appears to report only the OS family name and not the specific OS. In scalar context it returns just the ID.</source>
          <target state="translated">这个例程只是GetOSVersion()的一个简单接口。更具体或要求更高的情况应该用它来代替。另一个选择是使用POSIX::uname(),然而后者似乎只报告OS系列名称,而不是具体的OS。在标量上下文中,它只返回ID。</target>
        </trans-unit>
        <trans-unit id="af05f40d5a349a9cf28386764e38317c02e23a0c" translate="yes" xml:space="preserve">
          <source>This routine provides word completion on the list of words in the array (or array ref).</source>
          <target state="translated">这个例程为数组(或数组ref)中的单词列表提供单词完成。</target>
        </trans-unit>
        <trans-unit id="a12916af343198cbe644e34418361cddb6245ff7" translate="yes" xml:space="preserve">
          <source>This routine returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the Unicode version being used is so early that it doesn't have this property.</source>
          <target state="translated">如果所使用的Unicode版本太早以至于它没有此属性，则此例程将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f4e8ad32963f7898d4d526c86c643ef2d8a5ac8" translate="yes" xml:space="preserve">
          <source>This routine returns &lt;code&gt;undef&lt;/code&gt; if the Unicode version being used is so early that it doesn't have this property.</source>
          <target state="translated">如果所使用的Unicode版本太早以至于它没有此属性，则此例程将返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="101ceccec63478c5c011c3caa8244abb6108d41c" translate="yes" xml:space="preserve">
          <source>This routine returns a pointer to a &lt;code&gt;MAGIC&lt;/code&gt; structure stored in the SV. If the SV does not have that magical feature, &lt;code&gt;NULL&lt;/code&gt; is returned. If the SV has multiple instances of that magical feature, the first one will be returned. &lt;code&gt;mg_findext&lt;/code&gt; can be used to find a &lt;code&gt;MAGIC&lt;/code&gt; structure of an SV based on both its magic type and its magic virtual table:</source>
          <target state="translated">该例程返回指向存储在SV中的 &lt;code&gt;MAGIC&lt;/code&gt; 结构的指针。如果SV不具备该功能，则返回 &lt;code&gt;NULL&lt;/code&gt; 。如果SV具有该魔术功能的多个实例，则将返回第一个。 &lt;code&gt;mg_findext&lt;/code&gt; 可用于根据其魔术类型和魔术虚拟表查找SV 的 &lt;code&gt;MAGIC&lt;/code&gt; 结构：</target>
        </trans-unit>
        <trans-unit id="be064f7d7fc8c5c81c03e6f7693444f3da761d4d" translate="yes" xml:space="preserve">
          <source>This runs all the given</source>
          <target state="translated">这将运行所有给定的</target>
        </trans-unit>
        <trans-unit id="5f9d330768a086b11c3fee8aaebb21d2fcbcb969" translate="yes" xml:space="preserve">
          <source>This runs some basic sanity tests on the source tree and helps catch basic errors before you submit a patch.</source>
          <target state="translated">这将在源代码树上运行一些基本的理智性测试,有助于在提交补丁之前发现基本错误。</target>
        </trans-unit>
        <trans-unit id="b456dbbb28104ac1fe79034d2719d013d951db2d" translate="yes" xml:space="preserve">
          <source>This safer version of &lt;a href=&quot;#chop&quot;&gt;chop&lt;/a&gt; removes any trailing string that corresponds to the current value of &lt;code&gt;$/&lt;/code&gt; (also known as $INPUT_RECORD_SEPARATOR in the &lt;code&gt;English&lt;/code&gt; module). It returns the total number of characters removed from all its arguments. It's often used to remove the newline from the end of an input record when you're worried that the final record may be missing its newline. When in paragraph mode (&lt;code&gt;$/ = ''&lt;/code&gt; ), it removes all trailing newlines from the string. When in slurp mode (&lt;code&gt;$/ = &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) or fixed-length record mode (&lt;code&gt;$/&lt;/code&gt; is a reference to an integer or the like; see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;) chomp() won't remove anything. If VARIABLE is omitted, it chomps &lt;code&gt;$_&lt;/code&gt; . Example:</source>
          <target state="translated">此更安全的&lt;a href=&quot;#chop&quot;&gt;印章&lt;/a&gt;版本将删除任何与 &lt;code&gt;$/&lt;/code&gt; 当前值相对应的结尾字符串（在 &lt;code&gt;English&lt;/code&gt; 模块中也称为$ INPUT_RECORD_SEPARATOR ）。它返回从其所有参数中删除的字符总数。当您担心最终记录可能缺少其换行符时，通常用于从输入记录的末尾删除换行符。在段落模式下（ &lt;code&gt;$/ = ''&lt;/code&gt; ），它将从字符串中删除所有结尾的换行符。当处于slurp模式（ &lt;code&gt;$/ = &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ）或固定长度记录模式（ &lt;code&gt;$/&lt;/code&gt; 是对整数等的引用；请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;）时，chomp（）不会删除任何内容。如果省略了VARIABLE，它将砍掉 &lt;code&gt;$_&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="f11cb2092730214fd2c5570df1288f5c170ff762" translate="yes" xml:space="preserve">
          <source>This safer version of &lt;a href=&quot;#chop-VARIABLE&quot;&gt;&lt;code&gt;chop&lt;/code&gt;&lt;/a&gt; removes any trailing string that corresponds to the current value of &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; (also known as &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; in the &lt;a href=&quot;english&quot;&gt;&lt;code&gt;English&lt;/code&gt;&lt;/a&gt; module). It returns the total number of characters removed from all its arguments. It's often used to remove the newline from the end of an input record when you're worried that the final record may be missing its newline. When in paragraph mode (&lt;code&gt;$/ = ''&lt;/code&gt;), it removes all trailing newlines from the string. When in slurp mode (&lt;code&gt;$/ = undef&lt;/code&gt;) or fixed-length record mode (&lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; is a reference to an integer or the like; see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), &lt;a href=&quot;#chomp-VARIABLE&quot;&gt;&lt;code&gt;chomp&lt;/code&gt;&lt;/a&gt; won't remove anything. If VARIABLE is omitted, it chomps &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;. Example:</source>
          <target state="translated">此安全版本的&lt;a href=&quot;#chop-VARIABLE&quot;&gt; &lt;code&gt;chop&lt;/code&gt; &lt;/a&gt;删除了与&lt;a href=&quot;perlvar#%24%2F&quot;&gt; &lt;code&gt;$/&lt;/code&gt; &lt;/a&gt;当前值相对应的任何结尾字符串（在&lt;a href=&quot;english&quot;&gt; &lt;code&gt;English&lt;/code&gt; &lt;/a&gt;模块中也称为 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ）。它返回从其所有参数中删除的字符总数。当您担心最终记录可能缺少其换行符时，通常用于从输入记录的末尾删除换行符。在段落模式下（ &lt;code&gt;$/ = ''&lt;/code&gt; ），它将删除字符串中所有尾随的换行符。当处于slurp模式（ &lt;code&gt;$/ = undef&lt;/code&gt; ）或固定长度记录模式（&lt;a href=&quot;perlvar#%24%2F&quot;&gt; &lt;code&gt;$/&lt;/code&gt; &lt;/a&gt;是对整数等的引用；请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;）时，&lt;a href=&quot;#chomp-VARIABLE&quot;&gt; &lt;code&gt;chomp&lt;/code&gt; &lt;/a&gt;不会删除任何东西。如果省略了VARIABLE，它将砍掉&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;。例子：</target>
        </trans-unit>
        <trans-unit id="ade7671cda06ea60596db7de673c42e7e9809682" translate="yes" xml:space="preserve">
          <source>This safer version of &lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt; removes any trailing string that corresponds to the current value of &lt;code&gt;$/&lt;/code&gt; (also known as $INPUT_RECORD_SEPARATOR in the &lt;code&gt;English&lt;/code&gt; module). It returns the total number of characters removed from all its arguments. It's often used to remove the newline from the end of an input record when you're worried that the final record may be missing its newline. When in paragraph mode (&lt;code&gt;$/ = ''&lt;/code&gt; ), it removes all trailing newlines from the string. When in slurp mode (&lt;code&gt;$/ = &lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) or fixed-length record mode (&lt;code&gt;$/&lt;/code&gt; is a reference to an integer or the like; see &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt;) chomp() won't remove anything. If VARIABLE is omitted, it chomps &lt;code&gt;$_&lt;/code&gt; . Example:</source>
          <target state="translated">此更安全的&lt;a href=&quot;chop&quot;&gt;印章&lt;/a&gt;版本将删除任何与 &lt;code&gt;$/&lt;/code&gt; 当前值相对应的结尾字符串（在 &lt;code&gt;English&lt;/code&gt; 模块中也称为$ INPUT_RECORD_SEPARATOR ）。它返回从其所有参数中删除的字符总数。当您担心最终记录可能缺少其换行符时，通常用于从输入记录的末尾删除换行符。在段落模式下（ &lt;code&gt;$/ = ''&lt;/code&gt; ），它将从字符串中删除所有结尾的换行符。当处于slurp模式（ &lt;code&gt;$/ = &lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ）或固定长度记录模式（ &lt;code&gt;$/&lt;/code&gt; 是对整数等的引用；请参见&lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt;）时，chomp（）不会删除任何内容。如果省略了VARIABLE，它将砍掉 &lt;code&gt;$_&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="29322e1fae611c7a4ec6b18f01c0e5539c007dbe" translate="yes" xml:space="preserve">
          <source>This same method is available from pure perl via, &lt;code&gt;mro::method_changed_in(classname)&lt;/code&gt; .</source>
          <target state="translated">可以从纯perl通过 &lt;code&gt;mro::method_changed_in(classname)&lt;/code&gt; 获得相同的方法。</target>
        </trans-unit>
        <trans-unit id="3881ba4a6ee9c9f7a39f8b6e30cf077c3df62fb1" translate="yes" xml:space="preserve">
          <source>This same method is available from pure perl via, &lt;code&gt;mro::method_changed_in(classname)&lt;/code&gt;.</source>
          <target state="translated">可以从纯perl通过 &lt;code&gt;mro::method_changed_in(classname)&lt;/code&gt; 获得相同的方法。</target>
        </trans-unit>
        <trans-unit id="e7a4db1ab47139698e5958a2175645481a1041ec" translate="yes" xml:space="preserve">
          <source>This says &lt;code&gt;$a&lt;/code&gt; is a reference (ROK), which points to another SV which is a PVAV, an array. The array has one element, element zero, which is another SV. The field &lt;code&gt;FILL&lt;/code&gt; above indicates the last element in the array, similar to &lt;code&gt;$#$a&lt;/code&gt; .</source>
          <target state="translated">这表示 &lt;code&gt;$a&lt;/code&gt; 是引用（ROK），它指向另一个SV，即PVAV，即数组。该数组有一个元素，元素零，这是另一个SV。上方的字段 &lt;code&gt;FILL&lt;/code&gt; 表示数组中的最后一个元素，类似于 &lt;code&gt;$#$a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9184d54b5dc37c9e6366802801d705be70172a95" translate="yes" xml:space="preserve">
          <source>This says &lt;code&gt;$a&lt;/code&gt; is a reference (ROK), which points to another SV which is a PVAV, an array. The array has one element, element zero, which is another SV. The field &lt;code&gt;FILL&lt;/code&gt; above indicates the last element in the array, similar to &lt;code&gt;$#$a&lt;/code&gt;.</source>
          <target state="translated">这表示 &lt;code&gt;$a&lt;/code&gt; 是引用（ROK），它指向另一个SV，即PVAV，即数组。该数组有一个元素，元素零，这是另一个SV。上方的 &lt;code&gt;FILL&lt;/code&gt; 字段表示数组中的最后一个元素，类似于 &lt;code&gt;$#$a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="036ebde834d76ddc89809412a48e08bc1aad5dd1" translate="yes" xml:space="preserve">
          <source>This says &lt;code&gt;$a&lt;/code&gt; is an SV, a scalar. The scalar is an IV, a number. Its reference count is 1. It has the &lt;code&gt;IOK&lt;/code&gt; flag set, meaning it is currently being evaluated as a number. Because IOK is set we look at the IV item to see what is in the scalar.</source>
          <target state="translated">这表示 &lt;code&gt;$a&lt;/code&gt; 是SV，一个标量。标量是一个IV，一个数字。它的参考计数为1。它设置了 &lt;code&gt;IOK&lt;/code&gt; 标志，表示当前正在将其评估为数字。因为设置了IOK，所以我们查看IV项以查看标量中的内容。</target>
        </trans-unit>
        <trans-unit id="2536195f9e270d7a0608ccd9b92c67b39acf3e86" translate="yes" xml:space="preserve">
          <source>This says &lt;code&gt;$a&lt;/code&gt; is an SV, a scalar. The scalar type is a PVIV, which is capable of holding an integer (IV) and/or a string (PV) value. The scalar's head is allocated at address 0xbe9a8, while the body is at 0xbc288. Its reference count is 1. It has the &lt;code&gt;POK&lt;/code&gt; flag set, meaning its current PV field is valid. Because POK is set we look at the PV item to see what is in the scalar. The \0 at the end indicate that this PV is properly NUL-terminated. Note that the IV field still contains its old numeric value, but because FLAGS doesn't have IOK set, we must ignore the IV item. CUR indicates the number of characters in the PV. LEN indicates the number of bytes allocated for the PV (at least one more than CUR, because LEN includes an extra byte for the end-of-string marker, then usually rounded up to some efficient allocation unit).</source>
          <target state="translated">这表示 &lt;code&gt;$a&lt;/code&gt; 是SV，一个标量。标量类型是PVIV，它可以保存整数（IV）和/或字符串（PV）值。标量头分配在地址0xbe9a8上，而主体分配在0xbc288上。它的参考计数为1。它具有 &lt;code&gt;POK&lt;/code&gt; 标志设置，表示其当前PV字段有效。由于已设置POK，因此我们查看PV项以查看标量中的内容。末尾的\ 0表示此PV已正确NUL端接。请注意，IV字段仍然包含其旧数值，但是由于FLAGS没有设置IOK，因此我们必须忽略IV项。CUR表示PV中的字符数。LEN指示为PV分配的字节数（至少比CUR多一个，因为LEN为字符串结尾标记包括一个额外的字节，然后通常向上舍入为一个有效的分配单元）。</target>
        </trans-unit>
        <trans-unit id="d4038eb2f65cf90ff5c5db0ff06612a08d942853" translate="yes" xml:space="preserve">
          <source>This says that records are delimited by the string &lt;code&gt;es&lt;/code&gt; . If the file contained the following data:</source>
          <target state="translated">这表示记录由字符串 &lt;code&gt;es&lt;/code&gt; 分隔。如果文件包含以下数据：</target>
        </trans-unit>
        <trans-unit id="e7ff66ceeac2fbc00d45f5c00f7c3466cddbfb77" translate="yes" xml:space="preserve">
          <source>This says that records are delimited by the string &lt;code&gt;es&lt;/code&gt;. If the file contained the following data:</source>
          <target state="translated">这表示记录由字符串 &lt;code&gt;es&lt;/code&gt; 分隔。如果文件包含以下数据：</target>
        </trans-unit>
        <trans-unit id="c3f732b3da7c2a158f6a684ddbc311ca908a5e5b" translate="yes" xml:space="preserve">
          <source>This says what packages are internal to Perl. &lt;code&gt;Carp&lt;/code&gt; will never report an error as being from a line in a package that is internal to Perl. For example:</source>
          <target state="translated">这说明了Perl内部有哪些软件包。 &lt;code&gt;Carp&lt;/code&gt; 决不会报告错误，因为它来自Perl内部软件包中的一行。例如：</target>
        </trans-unit>
        <trans-unit id="94c9a814257648d20b0d4f2bf7acb2782a18b6ea" translate="yes" xml:space="preserve">
          <source>This says which packages are internal to Perl's warning system. For generating a full stack backtrace this is the same as being internal to Perl, the stack backtrace will not start inside packages that are listed in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; . But it is slightly different for the summary message generated by &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; . There errors will not be reported on any lines that are calling packages in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; .</source>
          <target state="translated">这说明了哪些软件包是Perl的警告系统内部的。为了生成完整的堆栈回溯，这与Perl内部相同，堆栈回溯将不会在 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 中列出的包内开始。但它是由所生成的摘要信息略有不同 &lt;code&gt;carp&lt;/code&gt; 或 &lt;code&gt;croak&lt;/code&gt; 。在 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 中调用软件包的任何行上都不会报告错误。</target>
        </trans-unit>
        <trans-unit id="84798169adfcecd51c1ec3874bbf65c79b20278e" translate="yes" xml:space="preserve">
          <source>This says which packages are internal to Perl's warning system. For generating a full stack backtrace this is the same as being internal to Perl, the stack backtrace will not start inside packages that are listed in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt;. But it is slightly different for the summary message generated by &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt;. There errors will not be reported on any lines that are calling packages in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt;.</source>
          <target state="translated">这说明了Perl的警告系统内部包含哪些软件包。为了生成完整的堆栈回溯，这与Perl内部相同，堆栈回溯将不会在 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 中列出的包内开始。但它是由所生成的摘要信息略有不同 &lt;code&gt;carp&lt;/code&gt; 或 &lt;code&gt;croak&lt;/code&gt; 。在 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 中调用软件包的任何行上都不会报告错误。</target>
        </trans-unit>
        <trans-unit id="31106a1a20d4ea51da0f7d90c3fe4fb2b5ff8f01" translate="yes" xml:space="preserve">
          <source>This scenario will mostly be applicable to code that is meant to be called from within destructors, asynchronous callbacks, and signal handlers. In such situations, where the code being called has little relation to the surrounding dynamic context, the main program needs to be insulated from errors in the called code, even if they can't be handled intelligently. It may also be useful to do this with code for &lt;code&gt;__DIE__&lt;/code&gt; or &lt;code&gt;__WARN__&lt;/code&gt; hooks, and &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">这种情况将最适用于要从析构函数，异步回调和信号处理程序中调用的代码。在这种情况下，被调用的代码与周围的动态上下文关系不大，因此即使无法智能地处理主程序，也需要将主程序与被调用的代码中的错误隔离开来。使用 &lt;code&gt;__DIE__&lt;/code&gt; 或 &lt;code&gt;__WARN__&lt;/code&gt; 钩子以及 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数的代码执行此操作也可能很有用。</target>
        </trans-unit>
        <trans-unit id="36ac4667cace4096dfbe5b4c50d550b72cbd4224" translate="yes" xml:space="preserve">
          <source>This scenario will mostly be applicable to code that is meant to be called from within destructors, asynchronous callbacks, and signal handlers. In such situations, where the code being called has little relation to the surrounding dynamic context, the main program needs to be insulated from errors in the called code, even if they can't be handled intelligently. It may also be useful to do this with code for &lt;code&gt;__DIE__&lt;/code&gt; or &lt;code&gt;__WARN__&lt;/code&gt; hooks, and &lt;code&gt;tie&lt;/code&gt; functions.</source>
          <target state="translated">这种情况将最适用于要从析构函数，异步回调和信号处理程序中调用的代码。在这种情况下，被调用的代码与周围的动态上下文几乎没有关系，因此即使无法智能处理主程序，也需要将主程序与被调用的代码中的错误隔离开来。使用 &lt;code&gt;__DIE__&lt;/code&gt; 或 &lt;code&gt;__WARN__&lt;/code&gt; 钩子的代码以及 &lt;code&gt;tie&lt;/code&gt; 函数执行此操作也可能很有用。</target>
        </trans-unit>
        <trans-unit id="e1df3253c4ccef59169cb5ac31f3ae1f9a3a9a53" translate="yes" xml:space="preserve">
          <source>This script provides a command interface (not a shell) to CPAN. At the moment it uses CPAN.pm to do the work, but it is not a one-shot command runner for CPAN.pm.</source>
          <target state="translated">这个脚本为CPAN提供了一个命令接口(不是shell)。目前它使用CPAN.pm来完成工作,但它不是CPAN.pm的一次性命令运行器。</target>
        </trans-unit>
        <trans-unit id="e17cbd723cbdc191dc4fdc562d2ff451e857ff96" translate="yes" xml:space="preserve">
          <source>This script shows how to override the default sorting algorithm that BTREE uses. Instead of using the normal lexical ordering, a case insensitive compare function will be used.</source>
          <target state="translated">这个脚本展示了如何覆盖 BTREE 使用的默认排序算法。我们将使用一个对大小写不敏感的比较函数,而不是使用正常的词法排序。</target>
        </trans-unit>
        <trans-unit id="af317b7379a832e3b0678b6eea769f242beb3e07" translate="yes" xml:space="preserve">
          <source>This script,</source>
          <target state="translated">这个剧本。</target>
        </trans-unit>
        <trans-unit id="86ea44fa36ed41d21548135cdfb2e7b1ad994fbc" translate="yes" xml:space="preserve">
          <source>This searches the directories given in</source>
          <target state="translated">这将搜索在</target>
        </trans-unit>
        <trans-unit id="cc448c949fa2502c3de5bd50cf25e079f49a973e" translate="yes" xml:space="preserve">
          <source>This section also applies to other overloaded math packages, like Math::String.</source>
          <target state="translated">本节也适用于其他重载数学包,如Math::String。</target>
        </trans-unit>
        <trans-unit id="ef6d18fe35323b673cf86ded4be1699795588d00" translate="yes" xml:space="preserve">
          <source>This section applies fully to Perls starting with v5.22. Various caveats for earlier releases are in the &lt;a href=&quot;#Earlier-releases-caveats&quot;&gt;&quot;Earlier releases caveats&quot;&lt;/a&gt; subsection below.</source>
          <target state="translated">本部分完全适用于从v5.22开始的Perls。下面的&lt;a href=&quot;#Earlier-releases-caveats&quot;&gt;&amp;ldquo;早期版本警告&amp;rdquo;&lt;/a&gt;小节中提供了有关早期版本的各种警告。</target>
        </trans-unit>
        <trans-unit id="be390d54ea95c83e1fca1268a1911351d2f7df4c" translate="yes" xml:space="preserve">
          <source>This section applies fully to Perls starting with v5.22. Various caveats for earlier releases are in the &lt;a href=&quot;#Earlier-releases-caveats&quot;&gt;Earlier releases caveats&lt;/a&gt; subsection below.</source>
          <target state="translated">本部分完全适用于从v5.22开始的Perls。下面的&amp;ldquo; &lt;a href=&quot;#Earlier-releases-caveats&quot;&gt;早期版本警告&amp;rdquo;&lt;/a&gt;小节中提供了有关早期版本的各种警告。</target>
        </trans-unit>
        <trans-unit id="56dd90ab92335c6f36e8ed1d4a60c84c97df21db" translate="yes" xml:space="preserve">
          <source>This section concerns the lookahead and lookbehind assertions. First, a little background.</source>
          <target state="translated">本节涉及lookahead和lookbehind断言。首先,介绍一下背景。</target>
        </trans-unit>
        <trans-unit id="ab4a7c816ed65ffc082450cf0217f6cf1db2cf6e" translate="yes" xml:space="preserve">
          <source>This section deals with I/O and the &quot;f&quot; issues: filehandles, flushing, formats, and footers.</source>
          <target state="translated">本节涉及I/O和 &quot;f &quot;的问题:文件柄、刷新、格式和页脚。</target>
        </trans-unit>
        <trans-unit id="c67dd2be244aa67b2c3982a2251efd0aba82da6e" translate="yes" xml:space="preserve">
          <source>This section deals with general Perl language issues that don't clearly fit into any of the other sections.</source>
          <target state="translated">本节讨论的是一般的Perl语言问题,这些问题显然不属于其他任何一节。</target>
        </trans-unit>
        <trans-unit id="4dacb0d5b8529783cda24f9a101a291fd790bb1b" translate="yes" xml:space="preserve">
          <source>This section deals with questions related to running web sites, sending and receiving email as well as general networking.</source>
          <target state="translated">本节涉及与运行网站、收发电子邮件以及一般网络有关的问题。</target>
        </trans-unit>
        <trans-unit id="b8c7e75fcfcb79fa2aefcfcb9d7bd00c769af0ac" translate="yes" xml:space="preserve">
          <source>This section defines an interface that allows in-memory compression using the</source>
          <target state="translated">本节定义了一个接口,允许在内存中使用</target>
        </trans-unit>
        <trans-unit id="07d89dd508bd9a1955f604c65746a72fe10cd652" translate="yes" xml:space="preserve">
          <source>This section defines an interface that allows in-memory uncompression using the</source>
          <target state="translated">本节定义了一个接口,允许在内存中使用</target>
        </trans-unit>
        <trans-unit id="574b76a7c21f5d83dd373c1961cc34e2c0747c9f" translate="yes" xml:space="preserve">
          <source>This section defines the Version type, used by several fields in the CPAN Meta Spec.</source>
          <target state="translated">本节定义了CPAN元规范中多个字段使用的版本类型。</target>
        </trans-unit>
        <trans-unit id="3243853ef1a289c9e89d976c5c5c21cc63e5a678" translate="yes" xml:space="preserve">
          <source>This section defines the interface available that allows in-memory uncompression using the</source>
          <target state="translated">本节定义了可用的接口,该接口允许在内存中使用</target>
        </trans-unit>
        <trans-unit id="8adf59417e2d7f3c501610b406a6fa8b838974b3" translate="yes" xml:space="preserve">
          <source>This section describes how JSON::PP maps Perl values to JSON values and vice versa. These mappings are designed to &quot;do the right thing&quot; in most circumstances automatically, preserving round-tripping characteristics (what you put in comes out as something equivalent).</source>
          <target state="translated">本节介绍了JSON::PP如何将Perl值映射到JSON值,反之亦然。这些映射被设计成在大多数情况下自动 &quot;做正确的事&quot;,保留了round-tripping的特性(你输入的东西出来是等价的)。</target>
        </trans-unit>
        <trans-unit id="95a0852ba843f17dcbe1940f17029f381d5d77f9" translate="yes" xml:space="preserve">
          <source>This section describes the accuracy/precision handling in Math::Big* as it used to be and as it is now, complete with an explanation of all terms and abbreviations.</source>
          <target state="translated">本节介绍了 Math::Big*中过去和现在的准确度/精度处理,并对所有术语和缩写进行了解释。</target>
        </trans-unit>
        <trans-unit id="06b4644a1d0abd71307ee2e3605d7fc2e4535b4d" translate="yes" xml:space="preserve">
          <source>This section describes the accuracy/precision handling in Math::BigInt and Math::BigFloat as it used to be and as it is now, complete with an explanation of all terms and abbreviations.</source>
          <target state="translated">本节描述了 Math::BigInt 和 Math::BigFloat 中过去和现在的精度/精度处理,并对所有术语和缩写进行了解释。</target>
        </trans-unit>
        <trans-unit id="ec789fa26c9d8dfd2479d175b7e934018d065eea" translate="yes" xml:space="preserve">
          <source>This section describes the re-implementation of the tmpnam() and tmpfile() functions described in &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; using the mkstemp() from this module.</source>
          <target state="translated">本节描述了使用此模块中的mkstemp（）重新实现&lt;a href=&quot;posix&quot;&gt;POSIX中&lt;/a&gt;描述的tmpnam（）和tmpfile（）函数的方法。</target>
        </trans-unit>
        <trans-unit id="39aef7a353c321f38285ab3f99461b24884c7fa4" translate="yes" xml:space="preserve">
          <source>This section describes the re-implementation of the tmpnam() and tmpfile() functions described in L</source>
          <target state="translated">这一节介绍了在 L.D.C.中描述的 tmpnam()和 tmpfile()函数的重新实现。</target>
        </trans-unit>
        <trans-unit id="5b6ee285a0e0ef806b91b3b763a8498277e66885" translate="yes" xml:space="preserve">
          <source>This section describes the recommended interface for generating temporary files and directories.</source>
          <target state="translated">本节介绍生成临时文件和目录的推荐界面。</target>
        </trans-unit>
        <trans-unit id="69aa90134b4dce1d696ebb05a6dbb67cf8770a91" translate="yes" xml:space="preserve">
          <source>This section describes the steps to be performed to build PerlCE. You may find additional information about building perl for WinCE at &lt;a href=&quot;http://perlce.sourceforge.net&quot;&gt;http://perlce.sourceforge.net&lt;/a&gt; and some pre-built binaries.</source>
          <target state="translated">本节介绍了构建PerlCE的步骤。您可以在&lt;a href=&quot;http://perlce.sourceforge.net&quot;&gt;http://perlce.sourceforge.net上&lt;/a&gt;找到有关为WinCE构建perl的其他信息以及一些预构建的二进制文件。</target>
        </trans-unit>
        <trans-unit id="11f3d56c367a6b305dcc2c5edd92d44276e1ff5b" translate="yes" xml:space="preserve">
          <source>This section describes the steps to be performed to build a Perl NLM and other associated NLMs.</source>
          <target state="translated">本节介绍了构建Perl NLM和其他相关NLM所要执行的步骤。</target>
        </trans-unit>
        <trans-unit id="1019c06c85688bbdf3af5c6e3b95950cdf59effc" translate="yes" xml:space="preserve">
          <source>This section describes ways to call &lt;code&gt;open&lt;/code&gt; outside of best practices; you may encounter these uses in older code. Perl does not consider their use deprecated, exactly, but neither is it recommended in new code, for the sake of clarity and readability.</source>
          <target state="translated">本节描述了在最佳实践之外进行 &lt;code&gt;open&lt;/code&gt; 调用的方法。您可能会在较旧的代码中遇到这些用法。Perl并不认为它们的使用已被完全弃用，但是出于清晰性和可读性的考虑，在新代码中也不建议使用Perl。</target>
        </trans-unit>
        <trans-unit id="73c6a4b67a7eaa7527571d5faec72b4bfebc75e4" translate="yes" xml:space="preserve">
          <source>This section documents functions to manipulate CVs which are code-values, or subroutines. For more information, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">本节介绍了操作CV的功能，这些CV是代码值或子例程。有关更多信息，请参见&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33ac896f6350aabd5af3622467a85a4b6b744251" translate="yes" xml:space="preserve">
          <source>This section gives some details on all extensions that aren't just synonyms for compound-form Unicode properties (for those properties, you'll have to refer to the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">本部分提供了所有扩展的详细信息，这些扩展不仅是复合格式Unicode属性的同义词（对于这些属性，您必须引用&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44&quot;&gt;Unicode Standard&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9319fc0cf40bc57d3c32a473ab7229f4845e3419" translate="yes" xml:space="preserve">
          <source>This section gives some details on all extensions that aren't just synonyms for compound-form Unicode properties (for those properties, you'll have to refer to the &lt;a href=&quot;https://www.unicode.org/reports/tr44&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">本节提供了所有扩展的详细信息，这些扩展不仅是复合格式Unicode属性的同义词（对于这些属性，您必须引用&lt;a href=&quot;https://www.unicode.org/reports/tr44&quot;&gt;Unicode Standard&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="954cb379e9610eb88d0cd37b6e5358601612440b" translate="yes" xml:space="preserve">
          <source>This section hopes to clarify how Perl handles quoted constructs. Although the most common reason to learn this is to unravel labyrinthine regular expressions, because the initial steps of parsing are the same for all quoting operators, they are all discussed together.</source>
          <target state="translated">本节希望能阐明Perl是如何处理引号结构的。虽然学习这一点最常见的原因是为了解开迷宫般的正则表达式,但由于解析的初始步骤对所有引号操作符都是一样的,所以将它们放在一起讨论。</target>
        </trans-unit>
        <trans-unit id="536fa6406d989d8eb5028cec20788cbdc6568c11" translate="yes" xml:space="preserve">
          <source>This section is about functions (really macros) that classify characters into types, such as punctuation versus alphabetic, etc. Most of these are analogous to regular expression character classes. (See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.) There are several variants for each class. (Not all macros have all variants; each item below lists the ones valid for it.) None are affected by &lt;code&gt;use bytes&lt;/code&gt;, and only the ones with &lt;code&gt;LC&lt;/code&gt; in the name are affected by the current locale.</source>
          <target state="translated">本节介绍将字符分类为各种类型的函数（真正的宏），例如标点符号与字母等。大多数此类函数与正则表达式字符类类似。（请参阅&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass中的&amp;ldquo; POSIX字符类&amp;rdquo;&lt;/a&gt;。）每种类都有几种变体。（并非所有宏都具有所有变体；下面的每一项都列出了对其有效的变体。）没有任何一个受 &lt;code&gt;use bytes&lt;/code&gt; 影响，并且只有名称中带有 &lt;code&gt;LC&lt;/code&gt; 的那些才受当前语言环境的影响。</target>
        </trans-unit>
        <trans-unit id="7547891b2c07526eb3624e622a75bf7d7cccf2c6" translate="yes" xml:space="preserve">
          <source>This section is about functions (really macros) that classify characters into types, such as punctuation versus alphabetic, etc. Most of these are analogous to regular expression character classes. (See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.) There are several variants for each class. (Not all macros have all variants; each item below lists the ones valid for it.) None are affected by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; , and only the ones with &lt;code&gt;LC&lt;/code&gt; in the name are affected by the current locale.</source>
          <target state="translated">本节介绍将字符分类为各种类型的函数（真正的宏），例如标点符号与字母等。大多数此类函数与正则表达式字符类类似。（请参阅&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass中的POSIX字符类&lt;/a&gt;。）每个类都有几种变体。（并非所有宏都具有所有变体；下面的每一项都列出了对其有效的变体。）没有任何一个受 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 影响，并且只有名称中带有 &lt;code&gt;LC&lt;/code&gt; 的那些才受当前语言环境的影响。</target>
        </trans-unit>
        <trans-unit id="e9ab2821650c93c09f64d44ff30564f17238787a" translate="yes" xml:space="preserve">
          <source>This section is also taken from JSON::XS.</source>
          <target state="translated">本节内容也取自JSON::XS。</target>
        </trans-unit>
        <trans-unit id="ddeda1d72fad19d0a6a9f82fe55d9f33ab10382a" translate="yes" xml:space="preserve">
          <source>This section is intended to supplement and clarify the discussion in &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;&quot;Command Paragraph&quot; in perlpod&lt;/a&gt;. These are the currently recognized Pod commands:</source>
          <target state="translated">本节旨在补充和阐明&lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;Perlpod&lt;/a&gt;中&amp;ldquo;命令段落&amp;rdquo;中的讨论。这些是当前公认的Pod命令：</target>
        </trans-unit>
        <trans-unit id="d919f2203b8f136316a99d5a21a115c2a5759b1a" translate="yes" xml:space="preserve">
          <source>This section is intended to supplement and clarify the discussion in &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. These are the currently recognized Pod commands:</source>
          <target state="translated">本节旨在补充和阐明&lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;Perlpod&lt;/a&gt;中&amp;ldquo; 命令段落&amp;rdquo;中的讨论。这些是当前公认的Pod命令：</target>
        </trans-unit>
        <trans-unit id="12d39af9317de3b208731a0e9f6172ef3ca0985f" translate="yes" xml:space="preserve">
          <source>This section is just an outline of some of the things code in a compartment might do (intentionally or unintentionally) which can have an effect outside the compartment.</source>
          <target state="translated">本节只是概述了隔间中的代码可能做的一些事情(有意或无意),这些事情可能会对隔间外部产生影响。</target>
        </trans-unit>
        <trans-unit id="afce53c6f9505fd215e3565d5b9cbd7590482493" translate="yes" xml:space="preserve">
          <source>This section is only necessary for those who want to write a compiler backend module that can be used via this module.</source>
          <target state="translated">本节仅对那些想写一个编译器后台模块的人来说是必要的,可以通过这个模块来使用。</target>
        </trans-unit>
        <trans-unit id="1d2dead1ebaa9a0daf17a7735104700bab6a62c1" translate="yes" xml:space="preserve">
          <source>This section is only relevant if you want to use the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; together with the &lt;b&gt;SelfLoader&lt;/b&gt;.</source>
          <target state="translated">仅当您想将 &lt;code&gt;FOOBAR::DATA&lt;/code&gt; 与&lt;b&gt;SelfLoader&lt;/b&gt;一起使用时，此部分才有意义。</target>
        </trans-unit>
        <trans-unit id="6b8111cc382b6e222eab22ae8b7285382f21bba0" translate="yes" xml:space="preserve">
          <source>This section is surprisingly small because the rest of the FAQ is littered with answers involving regular expressions. For example, decoding a URL and checking whether something is a number can be handled with regular expressions, but those answers are found elsewhere in this document (in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;: &quot;How do I decode or create those %-encodings on the web&quot; and &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;: &quot;How do I determine whether a scalar is a number/whole/integer/float&quot;, to be precise).</source>
          <target state="translated">本节之所以小，是因为该FAQ的其余部分充斥着涉及正则表达式的答案。例如，可以使用正则表达式处理URL解码并检查是否为数字，但是这些答案可以在本文档的其他地方找到（在&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9中&lt;/a&gt;：&amp;ldquo;我如何在网络上解码或创建这些％编码&amp;rdquo;和&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;：&amp;ldquo;精确地说，&amp;ldquo;如何确定标量是数字/整数/整数/浮点数&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e488b03478a9d4c34a486aa35881d2d7c336d0b6" translate="yes" xml:space="preserve">
          <source>This section is surprisingly small because the rest of the FAQ is littered with answers involving regular expressions. For example, decoding a URL and checking whether something is a number can be handled with regular expressions, but those answers are found elsewhere in this document (in perlfaq9 : &quot;How do I decode or create those %-encodings on the web&quot; and perlfaq4 : &quot;How do I determine whether a scalar is a number/whole/integer/float&quot;, to be precise).</source>
          <target state="translated">这一节的内容出奇的少,因为在FAQ的其他部分,涉及到正则表达式的答案比比皆是。例如,解码一个URL和检查某个东西是否是一个数字可以用正则表达式来处理,但是这些答案在这个文档的其他地方都可以找到(准确地说,在perlfaq9:&quot;我如何在网络上解码或创建那些%编码 &quot;和perlfaq4:&quot;我如何确定一个标量是一个数字/整体/整数/浮点数&quot;)。</target>
        </trans-unit>
        <trans-unit id="732c1a0656cc78e70f97a666a29ecd78fe5a04dd" translate="yes" xml:space="preserve">
          <source>This section is taken from JSON::XS almost verbatim. &lt;code&gt;encode_json&lt;/code&gt; and &lt;code&gt;decode_json&lt;/code&gt; are exported by default.</source>
          <target state="translated">本节几乎逐字取自JSON :: XS。默认情况下， &lt;code&gt;encode_json&lt;/code&gt; 和 &lt;code&gt;decode_json&lt;/code&gt; 被导出。</target>
        </trans-unit>
        <trans-unit id="94d687991685902a3cbba9421e6e5a504f1cdd17" translate="yes" xml:space="preserve">
          <source>This section is taken from JSON::XS.</source>
          <target state="translated">本节内容取自JSON::XS。</target>
        </trans-unit>
        <trans-unit id="94757c3cee869d3cff315104b19f6299d40770f6" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers questions about where to find source and documentation for Perl, support, and related matters.</source>
          <target state="translated">FAQ的这一部分回答了关于在哪里可以找到Perl的源代码和文档、支持和相关事宜的问题。</target>
        </trans-unit>
        <trans-unit id="dd108d0d127c5d70473c9d7274a370ea63329739" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers questions related to manipulating numbers, dates, strings, arrays, hashes, and miscellaneous data issues.</source>
          <target state="translated">这一部分的常见问题回答了与操作数字、日期、字符串、数组、散列和其他数据问题有关的问题。</target>
        </trans-unit>
        <trans-unit id="43d6c325f900a7d6a933d383734e7454f02fa808" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers questions related to programmer tools and programming support.</source>
          <target state="translated">本节常见问题回答了有关程序员工具和编程支持的问题。</target>
        </trans-unit>
        <trans-unit id="8c63d2f74bc0df3e2938dcd3a6724a679f1d5b9f" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers very general, high-level questions about Perl.</source>
          <target state="translated">FAQ的这一部分回答了关于Perl的一般性、高级别的问题。</target>
        </trans-unit>
        <trans-unit id="f91732cbb36111757913713f2dd27264f7f4075b" translate="yes" xml:space="preserve">
          <source>This section of the Perl FAQ covers questions involving operating system interaction. Topics include interprocess communication (IPC), control over the user-interface (keyboard, screen and pointing devices), and most anything else not related to data manipulation.</source>
          <target state="translated">Perl FAQ 的这一部分涵盖了涉及操作系统交互的问题。主题包括进程间通信(IPC)、对用户界面(键盘、屏幕和指向设备)的控制,以及其他大多数与数据操作无关的问题。</target>
        </trans-unit>
        <trans-unit id="d25ee711a891d2493e43b730a8ee5f38afba1662" translate="yes" xml:space="preserve">
          <source>This section only applies to you if you have existing data written out by Storable 2.02 or earlier on perl 5.6.0 or 5.6.1 on Unix or Linux which has been configured with 64 bit integer support (not the default) If you got a precompiled perl, rather than running Configure to build your own perl from source, then it almost certainly does not affect you, and you can stop reading now (unless you're curious). If you're using perl on Windows it does not affect you.</source>
          <target state="translated">本节只适用于你,如果你在Unix或Linux上的perl 5.6.0或5.6.1上有Storable 2.02或更早写出的现有数据,而这些数据已被配置为64位整数支持(不是默认的)如果你得到了一个预编译的perl,而不是运行Configure从源头构建你自己的perl,那么几乎可以肯定它不会影响你,你可以停止阅读了(除非你很好奇)。如果你在Windows上使用perl,它不会影响你。</target>
        </trans-unit>
        <trans-unit id="8ecf28b7a887ea07f287d9185e0392b617b15554" translate="yes" xml:space="preserve">
          <source>This section only considers the tagged value case: a tagged JSON object is encountered during decoding and &lt;code&gt;allow_tags&lt;/code&gt; is disabled, a parse error will result (as if tagged values were not part of the grammar).</source>
          <target state="translated">本节仅考虑标记值的情况：在解码过程中遇到标记的JSON对象，并且禁用 &lt;code&gt;allow_tags&lt;/code&gt; 时，将导致解析错误（就像标记的值不属于语法的一部分一样）。</target>
        </trans-unit>
        <trans-unit id="df773f3e4810bcca716d1f76438458e235350349" translate="yes" xml:space="preserve">
          <source>This section tries to classify the supported encodings by their applicability for information exchange over the Internet and to choose the most suitable aliases to name them in the context of such communication.</source>
          <target state="translated">本节试图根据所支持的编码对互联网上信息交换的适用性进行分类,并选择最合适的别名来命名这些编码。</target>
        </trans-unit>
        <trans-unit id="9863e5d9d88cf88755191633db565f4fe6bf163c" translate="yes" xml:space="preserve">
          <source>This sends an &lt;a href=&quot;Test2::Event::Bail&quot;&gt;Test2::Event::Bail&lt;/a&gt; event. This event will completely terminate all testing.</source>
          <target state="translated">这将发送一个&lt;a href=&quot;Test2::Event::Bail&quot;&gt;Test2 :: Event :: Bail&lt;/a&gt;事件。此事件将完全终止所有测试。</target>
        </trans-unit>
        <trans-unit id="5b9a6489148fff3cc80ff958733f7f998b0b3cdf" translate="yes" xml:space="preserve">
          <source>This server accepts one of five different commands, sending output back to the client. Unlike most network servers, this one handles only one incoming client at a time. Multitasking servers are covered in Chapter 16 of the Camel.</source>
          <target state="translated">这台服务器接受五种不同的命令之一,将输出送回客户端。与大多数网络服务器不同的是,这个服务器一次只处理一个传入的客户端。多任务服务器在《骆驼》第16章中有所介绍。</target>
        </trans-unit>
        <trans-unit id="ffb206fa8662fa49c173d5f9d350cc23a1d8b5c6" translate="yes" xml:space="preserve">
          <source>This server takes the trouble to clone off a child version via fork() for each incoming request. That way it can handle many requests at once, which you might not always want. Even if you don't fork(), the listen() will allow that many pending connections. Forking servers have to be particularly careful about cleaning up their dead children (called &quot;zombies&quot; in Unix parlance), because otherwise you'll quickly fill up your process table. The REAPER subroutine is used here to call waitpid() for any child processes that have finished, thereby ensuring that they terminate cleanly and don't join the ranks of the living dead.</source>
          <target state="translated">这个服务器很麻烦,对每个传入的请求都会通过fork()克隆出一个子版本。这样一来,它就可以同时处理许多请求,而你可能并不总是想要这样。即使你不fork(),listen()也会允许那么多待处理的连接。fork服务器必须特别小心清理它们死去的子程序(在Unix的术语中称为 &quot;僵尸&quot;),因为否则你会很快填满你的进程表。REAPER子程序在这里用于调用waitpid()来处理任何已经结束的子进程,从而确保它们干净利落地终止,不会加入活死人的行列。</target>
        </trans-unit>
        <trans-unit id="3c5ebe323e1cea15acbe8beafe841f6d123af5cf" translate="yes" xml:space="preserve">
          <source>This set of instructions is meant to describe a so-called &quot;native&quot; port of Perl to the Windows platform. This includes both 32-bit and 64-bit Windows operating systems. The resulting Perl requires no additional software to run (other than what came with your operating system). Currently, this port is capable of using one of the following compilers on the Intel x86 architecture:</source>
          <target state="translated">这组指令旨在描述所谓的 &quot;原生 &quot;Perl到Windows平台的移植。这包括32位和64位Windows操作系统。由此产生的Perl不需要额外的软件来运行(除了您的操作系统自带的软件)。目前,这个移植能够在 Intel x86 架构上使用下列编译器之一。</target>
        </trans-unit>
        <trans-unit id="8777023fd72f0e0c5194df7056fed5f92ab1ed79" translate="yes" xml:space="preserve">
          <source>This sets &lt;code&gt;$\&lt;/code&gt; to newline and then sets &lt;code&gt;$/&lt;/code&gt; to the null character.</source>
          <target state="translated">这会将 &lt;code&gt;$\&lt;/code&gt; 设置为换行符，然后将 &lt;code&gt;$/&lt;/code&gt; 设置为空字符。</target>
        </trans-unit>
        <trans-unit id="4549dd71bcce8b09d1c070ffac130c9cb9eed0b2" translate="yes" xml:space="preserve">
          <source>This sets a variable in op/numconvert.t.</source>
          <target state="translated">这个变量在op/numconvert.t中设置。</target>
        </trans-unit>
        <trans-unit id="df79d9971c873dd56e1affe3565f833f5f4ef4be" translate="yes" xml:space="preserve">
          <source>This sets the</source>
          <target state="translated">这设置了</target>
        </trans-unit>
        <trans-unit id="cc422551baf5bd378e1441e1ffd937104c35c5d0" translate="yes" xml:space="preserve">
          <source>This sets the accuracy for all math operations. The argument must be greater than or equal to zero. See Math::BigInt's bround() function for details.</source>
          <target state="translated">此项设置所有数学运算的精度。参数必须大于或等于零。详见 Math::BigInt 的 bround()函数。</target>
        </trans-unit>
        <trans-unit id="3b2057b585966ee5e34a71b1fcc4af8dffd8aef3" translate="yes" xml:space="preserve">
          <source>This sets the default per-thread stack size at the start of the application.</source>
          <target state="translated">这将在应用程序开始时设置默认的每线程栈大小。</target>
        </trans-unit>
        <trans-unit id="d80f3ae97beba02bd7de41d9d2bef09e8032704e" translate="yes" xml:space="preserve">
          <source>This sets the filehandle that &lt;code&gt;$parser&lt;/code&gt; 's output will be written to. You can pass &lt;code&gt;*STDOUT&lt;/code&gt; or &lt;code&gt;*STDERR&lt;/code&gt; , otherwise you should probably do something like this:</source>
          <target state="translated">这将设置 &lt;code&gt;$parser&lt;/code&gt; 的输出将被写入的文件句柄。您可以传递 &lt;code&gt;*STDOUT&lt;/code&gt; 或 &lt;code&gt;*STDERR&lt;/code&gt; ，否则您可能应该执行以下操作：</target>
        </trans-unit>
        <trans-unit id="2f62f85bc91a48745c4461c85cd5655d80de88af" translate="yes" xml:space="preserve">
          <source>This sets the filehandle that &lt;code&gt;$parser&lt;/code&gt;'s output will be written to. You can pass &lt;code&gt;*STDOUT&lt;/code&gt; or &lt;code&gt;*STDERR&lt;/code&gt;, otherwise you should probably do something like this:</source>
          <target state="translated">这将设置 &lt;code&gt;$parser&lt;/code&gt; 的输出将被写入的文件句柄。您可以传递 &lt;code&gt;*STDOUT&lt;/code&gt; 或 &lt;code&gt;*STDERR&lt;/code&gt; ，否则您可能应该执行以下操作：</target>
        </trans-unit>
        <trans-unit id="af102c7f2132a623b34e9347ca5e8597fbe36895" translate="yes" xml:space="preserve">
          <source>This sets the language code to tag this document as being in. By default, it is currently the value of the environment variable &lt;code&gt;RTFDEFLANG&lt;/code&gt; , or if that's not set, then the value 1033 (for US English).</source>
          <target state="translated">这将设置用于标记该文档所在语言的语言代码。默认情况下，当前它是环境变量 &lt;code&gt;RTFDEFLANG&lt;/code&gt; 的值，如果未设置，则为1033（对于美国英语）。</target>
        </trans-unit>
        <trans-unit id="38b3389f1a148c762d20dbeefeec456038d65737" translate="yes" xml:space="preserve">
          <source>This sets the language code to tag this document as being in. By default, it is currently the value of the environment variable &lt;code&gt;RTFDEFLANG&lt;/code&gt;, or if that's not set, then the value 1033 (for US English).</source>
          <target state="translated">这将设置用于标记该文档所在语言的语言代码。默认情况下，当前它是环境变量 &lt;code&gt;RTFDEFLANG&lt;/code&gt; 的值，或者，如果未设置，则为1033（对于美国英语）。</target>
        </trans-unit>
        <trans-unit id="529a10bfb87aaa836949c559d932aa868d0ea517" translate="yes" xml:space="preserve">
          <source>This sets the precision for all math operations. The argument can be any integer. Negative values mean a fixed number of digits after the dot, and are &amp;lt;B&amp;gt;ignored&amp;lt;/B&amp;gt; since all operations happen in integer space. A positive value rounds to this digit left from the dot. 0 or 1 mean round to integer and are ignore like negative values.</source>
          <target state="translated">这将设置所有数学运算的精度。参数可以是任何整数。负值表示点后的位数固定，并且&amp;lt;B&amp;gt;被忽略&amp;lt;/ B&amp;gt;，因为所有运算都在整数空间中进行。正值会四舍五入到该点左边的数字。0或1表示四舍五入为整数，并且像负值一样被忽略。</target>
        </trans-unit>
        <trans-unit id="674e5733f608427771b5b90d6f64c3b452aa5b35" translate="yes" xml:space="preserve">
          <source>This sets the precision for all math operations. The argument can be any integer. Negative values mean a fixed number of digits after the dot, while a positive value rounds to this digit left from the dot. 0 or 1 mean round to integer. See Math::BigInt's bfround() function for details.</source>
          <target state="translated">该函数设置所有数学运算的精度。参数可以是任何整数。负值意味着点后固定的数字,而正值则四舍五入到点后左边的这个数字。0或1意味着四舍五入到整数。详见 Math::BigInt 的 bfround()函数。</target>
        </trans-unit>
        <trans-unit id="7b5668a047104c30653c0804d67e484bf29d90cb" translate="yes" xml:space="preserve">
          <source>This sets the soft and hard limits to 10 and 20 seconds, respectively. After 10 seconds of time spent running on the CPU (not &quot;wall&quot; time), the process will be sent a signal (XCPU on some systems) which, if not trapped, will cause the process to terminate. If that signal is trapped, then after 10 more seconds (20 seconds in total) the process will be killed with a non-trappable signal.</source>
          <target state="translated">这将软限制和硬限制分别设置为10秒和20秒。在CPU上运行10秒的时间(不是 &quot;墙 &quot;的时间)后,进程将被发送一个信号(某些系统上的XCPU),如果该信号没有被捕获,将导致进程终止。如果该信号被捕获,那么再过10秒(共20秒)后,该进程将被一个不可捕获的信号杀死。</target>
        </trans-unit>
        <trans-unit id="130c125b35cf3d3da34044cd207b5628dc2ffac8" translate="yes" xml:space="preserve">
          <source>This sets the string that &lt;code&gt;$parser&lt;/code&gt; 's output will be sent to, instead of any filehandle.</source>
          <target state="translated">这将设置 &lt;code&gt;$parser&lt;/code&gt; 的输出将发送到的字符串，而不是任何文件句柄。</target>
        </trans-unit>
        <trans-unit id="11dc24aa23b6cf452f77c63ea5e698909de49109" translate="yes" xml:space="preserve">
          <source>This sets the string that &lt;code&gt;$parser&lt;/code&gt;'s output will be sent to, instead of any filehandle.</source>
          <target state="translated">这将设置 &lt;code&gt;$parser&lt;/code&gt; 的输出将发送到的字符串，而不是任何文件句柄。</target>
        </trans-unit>
        <trans-unit id="6b4632ee2d247f3c071c82005711a1c83db25822" translate="yes" xml:space="preserve">
          <source>This sets the version required for the given module to</source>
          <target state="translated">这将指定模块所需的版本设置为</target>
        </trans-unit>
        <trans-unit id="ce02c4df1fe3dcc67a7d36b7b1e441cff60cc978" translate="yes" xml:space="preserve">
          <source>This sets what class is used for rendering the files. The default is &quot;Pod::Simple::HTML&quot;. If you set it to something else, it should probably be a subclass of Pod::Simple::HTML, and you should &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; that class so that's it's loaded before Pod::Simple::HTMLBatch tries loading it.</source>
          <target state="translated">设置用于渲染文件的类。默认值为&amp;ldquo; Pod :: Simple :: HTML&amp;rdquo;。如果您将其设置为其他内容，则它可能应该是Pod :: Simple :: HTML的子类，并且您应该 &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 该类，以便在Pod :: Simple :: HTMLBatch尝试加载它之前就将其加载。</target>
        </trans-unit>
        <trans-unit id="5cfda4b2fca350828dd5a1ac91438eac5b206248" translate="yes" xml:space="preserve">
          <source>This sets what class is used for rendering the files. The default is &quot;Pod::Simple::HTML&quot;. If you set it to something else, it should probably be a subclass of Pod::Simple::HTML, and you should &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; that class so that's it's loaded before Pod::Simple::HTMLBatch tries loading it.</source>
          <target state="translated">设置用于渲染文件的类。默认值为&amp;ldquo; Pod :: Simple :: HTML&amp;rdquo;。如果您将其设置为其他内容，则它可能应该是Pod :: Simple :: HTML的子类，并且您应该 &lt;code&gt;require&lt;/code&gt; 或 &lt;code&gt;use&lt;/code&gt; 该类，以便在Pod :: Simple :: HTMLBatch尝试加载它之前就将其加载。</target>
        </trans-unit>
        <trans-unit id="ec1e3d22ca8911a43038e77812f3f3938f114390" translate="yes" xml:space="preserve">
          <source>This sets what class is used for searching for the files. The default is &quot;Pod::Simple::Search&quot;. If you set it to something else, it should probably be a subclass of Pod::Simple::Search, and you should &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; that class so that's it's loaded before Pod::Simple::HTMLBatch tries loading it.</source>
          <target state="translated">设置用于搜索文件的类。默认值为&amp;ldquo; Pod :: Simple :: Search&amp;rdquo;。如果将其设置为其他内容，则它可能应该是Pod :: Simple :: Search的子类，并且您应该 &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 该类，以便在Pod :: Simple :: HTMLBatch尝试加载它之前就已加载该类。</target>
        </trans-unit>
        <trans-unit id="7237f6ff3ed8efb498d362dab04bc50228f211f0" translate="yes" xml:space="preserve">
          <source>This sets what class is used for searching for the files. The default is &quot;Pod::Simple::Search&quot;. If you set it to something else, it should probably be a subclass of Pod::Simple::Search, and you should &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; that class so that's it's loaded before Pod::Simple::HTMLBatch tries loading it.</source>
          <target state="translated">设置用于搜索文件的类。默认值为&amp;ldquo; Pod :: Simple :: Search&amp;rdquo;。如果将其设置为其他内容，则它可能应该是Pod :: Simple :: Search的子类，并且您应该 &lt;code&gt;require&lt;/code&gt; 或 &lt;code&gt;use&lt;/code&gt; 该类，以便在Pod :: Simple :: HTMLBatch尝试加载它之前就已加载该类。</target>
        </trans-unit>
        <trans-unit id="c9cf2efded42d8cb56f73f264ab95aef6e9febaa" translate="yes" xml:space="preserve">
          <source>This setting has currently no effect on tied hashes.</source>
          <target state="translated">该设置目前对绑定哈希没有影响。</target>
        </trans-unit>
        <trans-unit id="52c8e9c991aed7d8a50a93d4bed0eb71bffb9b06" translate="yes" xml:space="preserve">
          <source>This setting has no effect on &lt;code&gt;decode&lt;/code&gt;.</source>
          <target state="translated">此设置对 &lt;code&gt;decode&lt;/code&gt; 没有影响。</target>
        </trans-unit>
        <trans-unit id="c8d1b9e8622b5f2ff4cb6a55e0533419d19af149" translate="yes" xml:space="preserve">
          <source>This setting has no effect when decoding JSON texts.</source>
          <target state="translated">此设置在解码JSON文本时没有效果。</target>
        </trans-unit>
        <trans-unit id="03e68aea7378a9d8770b734fa44395aeb3e883a4" translate="yes" xml:space="preserve">
          <source>This setting has no effect when decoding JSON texts. You will also most likely combine this setting with &lt;code&gt;space_after&lt;/code&gt;.</source>
          <target state="translated">解码JSON文本时，此设置无效。您也很可能将此设置与 &lt;code&gt;space_after&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="40822cd1e25ae559171a5c38a63f3fa78270123b" translate="yes" xml:space="preserve">
          <source>This setting needs to be in effect while Perl is built, but also when the programs are run.</source>
          <target state="translated">这个设置需要在Perl构建时生效,但在程序运行时也要生效。</target>
        </trans-unit>
        <trans-unit id="0ef0f761ac69580bceb47730cfb76aca36efdbeb" translate="yes" xml:space="preserve">
          <source>This shares the variable(s) in the argument list with the compartment. This is almost identical to exporting variables using the &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; module.</source>
          <target state="translated">这将与隔离专区共享参数列表中的变量。这几乎与使用&amp;ldquo; &lt;a href=&quot;exporter&quot;&gt;导出器&amp;rdquo;&lt;/a&gt;模块导出变量相同。</target>
        </trans-unit>
        <trans-unit id="d152c0ad7d6bcbd14fe51b7170fea53d971e63b6" translate="yes" xml:space="preserve">
          <source>This shifts the burden of complexity off to the quant method. That method's parameters are: the numeric value it's going to use to quantify something; the Russian word it's going to quantify; and the parameter &quot;accusative&quot;, which you're using to mean that this sentence's syntax wants a noun in the accusative case there, although that quantification method may have to overrule, for grammatical reasons you may recall from the beginning of this article.</source>
          <target state="translated">这就把复杂的负担转嫁到了量化方法上。这个方法的参数是:它要用来量化某件事情的数值;它要量化的俄语单词;以及 &quot;指称 &quot;这个参数,你用它来表示这个句子的语法要在那里用指称的名词,尽管这个量化方法可能要推翻,出于语法上的原因,你可能还记得本文开头的内容。</target>
        </trans-unit>
        <trans-unit id="6847db733d896a734ef92c2af3a111d1b507ced6" translate="yes" xml:space="preserve">
          <source>This should &lt;b&gt;ONLY&lt;/b&gt; be used on memory obtained using &lt;a href=&quot;#Newx&quot;&gt;&quot;Newx&quot;&lt;/a&gt; and friends.</source>
          <target state="translated">&lt;b&gt;仅&lt;/b&gt;应将其用于使用&lt;a href=&quot;#Newx&quot;&gt;&amp;ldquo; Newx&amp;rdquo;&lt;/a&gt;和朋友获得的内存。</target>
        </trans-unit>
        <trans-unit id="3d3464b620ba9f7ef03d81ee4683ae7ba242d757" translate="yes" xml:space="preserve">
          <source>This should &lt;b&gt;ONLY&lt;/b&gt; be used on memory obtained using &lt;a href=&quot;#Newx&quot;&gt;Newx&lt;/a&gt; and friends.</source>
          <target state="translated">&lt;b&gt;仅&lt;/b&gt;应将其用于使用&lt;a href=&quot;#Newx&quot;&gt;Newx&lt;/a&gt;和friends 获得的内存。</target>
        </trans-unit>
        <trans-unit id="d79a68f01e1702d7ec1c9976d188db9c7f2aece8" translate="yes" xml:space="preserve">
          <source>This should allow read/write access to any files that are extracted from the zip file/buffer`.</source>
          <target state="translated">这应该允许读/写访问任何从zip文件/缓冲区提取的文件。</target>
        </trans-unit>
        <trans-unit id="38a7ea1ad739ecad0857da6650e530f48bc66f62" translate="yes" xml:space="preserve">
          <source>This should be completely transparent to any applications written entirely in Perl (minus a few rarely encountered caveats given in the &lt;a href=&quot;#Multi-threaded&quot;&gt;&quot;Multi-threaded&quot;&lt;/a&gt; section). Information for XS module writers is given in &lt;a href=&quot;perlxs#Locale-aware-XS-code&quot;&gt;&quot;Locale-aware XS code&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">对于完全用Perl编写的任何应用程序，这应该是完全透明的（减去&lt;a href=&quot;#Multi-threaded&quot;&gt;&amp;ldquo;多线程&amp;rdquo;&lt;/a&gt;部分中给出的一些很少遇到的警告）。XS模块编写者的信息&lt;a href=&quot;perlxs#Locale-aware-XS-code&quot;&gt;在perlxs中的&amp;ldquo;可识别区域设置的XS代码&amp;rdquo;中给出&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4bc0e6df3ccf75b9d4b22bada1e150f1c0bf5e1" translate="yes" xml:space="preserve">
          <source>This should be fixed already.</source>
          <target state="translated">这点应该已经解决了。</target>
        </trans-unit>
        <trans-unit id="f1709f85224b4fc47c42955a5583dcda72fcf36e" translate="yes" xml:space="preserve">
          <source>This should be fixed.</source>
          <target state="translated">这应该是固定的。</target>
        </trans-unit>
        <trans-unit id="d375da43f6c63dd4302e9f62a049ebffa1351990" translate="yes" xml:space="preserve">
          <source>This should be interpreted as '&lt;code&gt;PVOP&lt;/code&gt; ' only. The &lt;code&gt;_OR_SVOP&lt;/code&gt; is because the only core &lt;code&gt;PVOP&lt;/code&gt; , &lt;code&gt;OP_TRANS&lt;/code&gt; , can sometimes be a &lt;code&gt;SVOP&lt;/code&gt; instead.</source>
          <target state="translated">仅应将其解释为&amp;ldquo; &lt;code&gt;PVOP&lt;/code&gt; &amp;rdquo;。该 &lt;code&gt;_OR_SVOP&lt;/code&gt; 是因为只有核心 &lt;code&gt;PVOP&lt;/code&gt; ， &lt;code&gt;OP_TRANS&lt;/code&gt; ，有时是 &lt;code&gt;SVOP&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="55cb7fd92e54949da6a1f17f8e9cc521852ab737" translate="yes" xml:space="preserve">
          <source>This should be interpreted as '&lt;code&gt;PVOP&lt;/code&gt;' only. The &lt;code&gt;_OR_SVOP&lt;/code&gt; is because the only core &lt;code&gt;PVOP&lt;/code&gt;, &lt;code&gt;OP_TRANS&lt;/code&gt;, can sometimes be a &lt;code&gt;SVOP&lt;/code&gt; instead.</source>
          <target state="translated">仅应将其解释为&amp;ldquo; &lt;code&gt;PVOP&lt;/code&gt; &amp;rdquo;。该 &lt;code&gt;_OR_SVOP&lt;/code&gt; 是因为只有核心 &lt;code&gt;PVOP&lt;/code&gt; ， &lt;code&gt;OP_TRANS&lt;/code&gt; ，有时是 &lt;code&gt;SVOP&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="13a5db63688f7fa372582799c1bd3dfdaa3ba0cd" translate="yes" xml:space="preserve">
          <source>This should be replaced by the full path to your clang executable if it is not in your path.</source>
          <target state="translated">如果你的路径中没有clang可执行文件的完整路径,则应该用它来代替。</target>
        </trans-unit>
        <trans-unit id="87cbf40ae5f30dda5d9df6e6dea667727ea90c08" translate="yes" xml:space="preserve">
          <source>This should be set for non debug messages that are still important enough to show when a formatter is in quiet mode. A formatter should send these to STDOUT not STDERR, but should show them even in non-verbose mode.</source>
          <target state="translated">这应该是为非调试信息设置的,这些信息在格式化器处于安静模式时仍然足够重要,可以显示出来。格式化程序应该将这些信息发送到STDOUT,而不是STDERR,但即使是在非verbose模式下也应该显示这些信息。</target>
        </trans-unit>
        <trans-unit id="b5a95a55a5803d791f964bba2e2a1d75b4c88370" translate="yes" xml:space="preserve">
          <source>This should be the first thing you call in your test script. It declares your testing plan, how many there will be, if any of them should be allowed to fail, and so on.</source>
          <target state="translated">这应该是你在测试脚本中调用的第一件事。它声明了你的测试计划,将有多少测试,是否允许任何测试失败,等等。</target>
        </trans-unit>
        <trans-unit id="c0f01ea79ad3c782b34e1c39edb42ab144bd80b0" translate="yes" xml:space="preserve">
          <source>This should build everything. Specifically, it will create perl.exe, perl522.dll at the perl toplevel, and various other extension dll's under the lib\auto directory. If the build fails for any reason, make sure you have done the previous steps correctly.</source>
          <target state="translated">这应该可以建立所有的东西。具体来说,它将创建perl.exe,perl522.dll在perl toplevel,以及其他各种扩展dll在lib/auto目录下。如果编译失败,请确保你正确地完成了前面的步骤。</target>
        </trans-unit>
        <trans-unit id="3a62d97effee732e54e0d1504511279a90715573" translate="yes" xml:space="preserve">
          <source>This should build everything. Specifically, it will create perl.exe, perl532.dll at the perl toplevel, and various other extension dll's under the lib\auto directory. If the build fails for any reason, make sure you have done the previous steps correctly.</source>
          <target state="translated">这应该可以建立所有的东西。具体来说,它会创建perl.exe,perltoplevel的perl532.dll,以及lib/auto目录下的其他各种扩展dll。如果编译失败,请确保你正确地完成了前面的步骤。</target>
        </trans-unit>
        <trans-unit id="30ba9060ffc1293bd461e0db035bb80a563a059f" translate="yes" xml:space="preserve">
          <source>This should build miniperl and then fail when it tries to run it.</source>
          <target state="translated">这应该会构建miniperl,然后在尝试运行它时失败。</target>
        </trans-unit>
        <trans-unit id="db496c0536d24209950a452554a51ec2ca77e58c" translate="yes" xml:space="preserve">
          <source>This should contain a URI where the exact terms of the license may be found.</source>
          <target state="translated">这应该包含一个URI,可以找到许可证的确切条款。</target>
        </trans-unit>
        <trans-unit id="678375f3c34a52f1c875afc4e9a5d9d1a7cc959a" translate="yes" xml:space="preserve">
          <source>This should create an executable</source>
          <target state="translated">这将创建一个可执行的</target>
        </trans-unit>
        <trans-unit id="0343ed053df7e2ae641054c461a6d9ef120ebfaa" translate="yes" xml:space="preserve">
          <source>This should match any sequences of characters that aren't &lt;code&gt;\xDF&lt;/code&gt; nor what &lt;code&gt;\xDF&lt;/code&gt; matches under &lt;code&gt;/i&lt;/code&gt;. &lt;code&gt;&quot;s&quot;&lt;/code&gt; isn't &lt;code&gt;\xDF&lt;/code&gt; , but Unicode says that &lt;code&gt;&quot;ss&quot;&lt;/code&gt; is what &lt;code&gt;\xDF&lt;/code&gt; matches under &lt;code&gt;/i&lt;/code&gt;. So which one &quot;wins&quot;? Do you fail the match because the string has &lt;code&gt;ss&lt;/code&gt; or accept it because it has an &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; followed by another &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;? Perl has chosen the latter. (See note in &lt;a href=&quot;#Bracketed-Character-Classes&quot;&gt;Bracketed Character Classes&lt;/a&gt; above.)</source>
          <target state="translated">这应该匹配不是 &lt;code&gt;\xDF&lt;/code&gt; 也不是 &lt;code&gt;/i&lt;/code&gt; 下 &lt;code&gt;\xDF&lt;/code&gt; 匹配的任何字符序列。 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 不是 &lt;code&gt;\xDF&lt;/code&gt; ，但是Unicode表示 &lt;code&gt;\xDF&lt;/code&gt; 在 &lt;code&gt;/i&lt;/code&gt; 下匹配的是 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 。那么哪一个&amp;ldquo;获胜&amp;rdquo;呢？你无法匹配，因为字符串有 &lt;code&gt;ss&lt;/code&gt; 或者接受它，因为它有一个 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 紧接着又 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ？ Perl选择了后者。 （请参阅上面&lt;a href=&quot;#Bracketed-Character-Classes&quot;&gt;括号字符类中的&lt;/a&gt;注释。）</target>
        </trans-unit>
        <trans-unit id="eb02f2a8ec63111dfc588d8b17a8d6fb2096fcb5" translate="yes" xml:space="preserve">
          <source>This should match any sequences of characters that aren't &lt;code&gt;\xDF&lt;/code&gt; nor what &lt;code&gt;\xDF&lt;/code&gt; matches under &lt;code&gt;/i&lt;/code&gt;. &lt;code&gt;&quot;s&quot;&lt;/code&gt; isn't &lt;code&gt;\xDF&lt;/code&gt;, but Unicode says that &lt;code&gt;&quot;ss&quot;&lt;/code&gt; is what &lt;code&gt;\xDF&lt;/code&gt; matches under &lt;code&gt;/i&lt;/code&gt;. So which one &quot;wins&quot;? Do you fail the match because the string has &lt;code&gt;ss&lt;/code&gt; or accept it because it has an &lt;code&gt;s&lt;/code&gt; followed by another &lt;code&gt;s&lt;/code&gt;? Perl has chosen the latter. (See note in &lt;a href=&quot;#Bracketed-Character-Classes&quot;&gt;&quot;Bracketed Character Classes&quot;&lt;/a&gt; above.)</source>
          <target state="translated">这应该匹配不是 &lt;code&gt;\xDF&lt;/code&gt; 也不是 &lt;code&gt;/i&lt;/code&gt; 下 &lt;code&gt;\xDF&lt;/code&gt; 匹配的任何字符序列。 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 不是 &lt;code&gt;\xDF&lt;/code&gt; ，但是Unicode表示 &lt;code&gt;\xDF&lt;/code&gt; 在 &lt;code&gt;/i&lt;/code&gt; 下匹配的是 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 。那么哪一个&amp;ldquo;获胜&amp;rdquo;呢？你无法匹配，因为字符串有 &lt;code&gt;ss&lt;/code&gt; 或者接受它，因为它有一个 &lt;code&gt;s&lt;/code&gt; 紧接着又 &lt;code&gt;s&lt;/code&gt; ？ Perl选择了后者。 （请参见上面的&lt;a href=&quot;#Bracketed-Character-Classes&quot;&gt;&amp;ldquo;括号内的字符类&amp;rdquo;中的&lt;/a&gt;注释。）</target>
        </trans-unit>
        <trans-unit id="050396cf8762718cb34435af8d06d17eb8dd7bc6" translate="yes" xml:space="preserve">
          <source>This should not be used to supply default values for parameters. One would normally use this when a function parameter must be processed by another library function before it can be used. Default parameters are covered in the next section.</source>
          <target state="translated">这不应该被用来提供参数的默认值。通常,当一个函数参数必须由另一个库函数处理后才能使用时,才会使用这个选项。默认参数将在下一节介绍。</target>
        </trans-unit>
        <trans-unit id="8b1ca7922101edcce2a492b3a6c129abd8a583e6" translate="yes" xml:space="preserve">
          <source>This should only be necessary if</source>
          <target state="translated">只有在以下情况下才需要这样做</target>
        </trans-unit>
        <trans-unit id="598f32a1125324d2a241a1c920bc050b40fac3d7" translate="yes" xml:space="preserve">
          <source>This should rarely be necessary, as the Perl &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; function is to be used for things that Perl opened itself, even if it was a dup of a numeric descriptor as with &lt;code&gt;MHCONTEXT&lt;/code&gt; above. But if you really have to, you may be able to do this:</source>
          <target state="translated">这几乎没有必要，因为Perl &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 函数将用于Perl打开的东西，即使它是如上面的 &lt;code&gt;MHCONTEXT&lt;/code&gt; 那样的数字描述符的复制。但是，如果确实需要，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="81e177911fc8ed26557ec26b5355ec1390d9f4d0" translate="yes" xml:space="preserve">
          <source>This should rarely be necessary, as the Perl &lt;code&gt;close()&lt;/code&gt; function is to be used for things that Perl opened itself, even if it was a dup of a numeric descriptor as with &lt;code&gt;MHCONTEXT&lt;/code&gt; above. But if you really have to, you may be able to do this:</source>
          <target state="translated">这几乎是没有必要的，因为Perl &lt;code&gt;close()&lt;/code&gt; 函数将用于Perl打开的东西，即使它像上面的 &lt;code&gt;MHCONTEXT&lt;/code&gt; 一样是数字描述符的复制。但是，如果确实需要，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="4d79cf36faa3af81e4bd5bbe5c4a98d13ad84be9" translate="yes" xml:space="preserve">
          <source>This should return true if the driver works in the current environment. This should return false if it does not. This is a CLASS method.</source>
          <target state="translated">如果驱动程序在当前环境中工作,则应返回true。如果驱动在当前环境中不能工作,则应返回false。这是一个CLASS方法。</target>
        </trans-unit>
        <trans-unit id="cf1ab6069990fc4ba153fc0e586880eb88157c07" translate="yes" xml:space="preserve">
          <source>This shows &lt;code&gt;$a&lt;/code&gt; is a reference pointing to an SV. That SV is a PVHV, a hash.</source>
          <target state="translated">这表明 &lt;code&gt;$a&lt;/code&gt; 是指向SV的引用。那个SV是PVHV，是一个哈希。</target>
        </trans-unit>
        <trans-unit id="b7c7e9b83cb4841b6e6724c1f7e531bbbc2b68cb" translate="yes" xml:space="preserve">
          <source>This shows &lt;code&gt;$a&lt;/code&gt; is a reference pointing to an SV. That SV is a PVHV, a hash. Fields RITER and EITER are used by &lt;code&gt;&lt;a href=&quot;../functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这表明 &lt;code&gt;$a&lt;/code&gt; 是指向SV的引用。那个SV是PVHV，一个哈希。 &lt;code&gt;&lt;a href=&quot;../functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 字段都使用RITER和EITER字段。</target>
        </trans-unit>
        <trans-unit id="4544b90fccd9dc8117d7d96fcbc15a1ca629dfae" translate="yes" xml:space="preserve">
          <source>This shows that</source>
          <target state="translated">这表明</target>
        </trans-unit>
        <trans-unit id="d012fb20c34f9ef1051349030cb25501698029ec" translate="yes" xml:space="preserve">
          <source>This shows that there were changes to this document staged for commit, and that there were further changes in the working directory not yet staged. It also shows that there was an untracked file in the working directory, and as you can see shows how to change all of this. It also shows that there is one commit on the working branch &lt;code&gt;blead&lt;/code&gt; which has not been pushed to the &lt;code&gt;origin&lt;/code&gt; remote yet. &lt;b&gt;NOTE&lt;/b&gt;: This output is also what you see as a template if you do not provide a message to &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">这表明此文档已暂存以进行提交的更改，并且工作目录中尚未暂存的其他更改。它还显示工作目录中存在一个未跟踪的文件，并且如您所见，显示了如何更改所有这些文件。它也表明，有一个承诺在工作分支 &lt;code&gt;blead&lt;/code&gt; 尚未推到 &lt;code&gt;origin&lt;/code&gt; 远程呢。&lt;b&gt;注意&lt;/b&gt;：如果不向 &lt;code&gt;git commit&lt;/code&gt; 提供消息，则此输出也将作为模板显示。</target>
        </trans-unit>
        <trans-unit id="b55aa05d72ea8d4828d039cb967e2a4c2c9f3f35" translate="yes" xml:space="preserve">
          <source>This shows that we have an SV which is a reference, which points at another SV. In this case that second SV is a PVMG, a blessed scalar. Because it is blessed it has the &lt;code&gt;OBJECT&lt;/code&gt; flag set. Note that an SV which holds a C pointer also has the &lt;code&gt;IOK&lt;/code&gt; flag set. The &lt;code&gt;STASH&lt;/code&gt; is set to the package name which this SV was blessed into.</source>
          <target state="translated">这表明我们有一个SV作为参考，它指向另一个SV。在这种情况下，第二个SV是PVMG，即祝福的标量。因为它很幸运，所以它设置了 &lt;code&gt;OBJECT&lt;/code&gt; 标志。注意，持有C指针的SV也设置了 &lt;code&gt;IOK&lt;/code&gt; 标志。该 &lt;code&gt;STASH&lt;/code&gt; 被设定成这个SV很幸运进入包名。</target>
        </trans-unit>
        <trans-unit id="d6b36418bf4797a5df13199701553bd6ebeff202" translate="yes" xml:space="preserve">
          <source>This shows the sorts of output the &lt;code&gt;l&lt;/code&gt; command can produce:</source>
          <target state="translated">这显示了 &lt;code&gt;l&lt;/code&gt; 命令可以产生的各种输出：</target>
        </trans-unit>
        <trans-unit id="220ae5d1e65680423ed0fee8d1ae71265a4673d1" translate="yes" xml:space="preserve">
          <source>This shows the variables used in the subroutine &lt;code&gt;clear_noremap&lt;/code&gt; . The variable &lt;code&gt;$ready_to_print&lt;/code&gt; is a my() (lexical) variable, &lt;b&gt;i&lt;/b&gt;ntroduced (first declared with my()) on line 1069, and used on line 1079. The variable &lt;code&gt;$&amp;amp;&lt;/code&gt; from the main package is used on 1086, and so on.</source>
          <target state="translated">这显示了子例程 &lt;code&gt;clear_noremap&lt;/code&gt; 中使用的变量。变量 &lt;code&gt;$ready_to_print&lt;/code&gt; 是我的（）（词法）变量，&lt;b&gt;我&lt;/b&gt; ntroduced上线1069，并在线路1079的可变使用（第一与我的（）中声明） &lt;code&gt;$&amp;amp;&lt;/code&gt; 从主包装上使用1086，等。</target>
        </trans-unit>
        <trans-unit id="69445b30eafff7b7c0b6c3e36cb0b52aa8e5353f" translate="yes" xml:space="preserve">
          <source>This shows the variables used in the subroutine &lt;code&gt;clear_noremap&lt;/code&gt;. The variable &lt;code&gt;$ready_to_print&lt;/code&gt; is a my() (lexical) variable, &lt;b&gt;i&lt;/b&gt;ntroduced (first declared with my()) on line 1069, and used on line 1079. The variable &lt;code&gt;$&amp;amp;&lt;/code&gt; from the main package is used on 1086, and so on.</source>
          <target state="translated">这显示了子例程 &lt;code&gt;clear_noremap&lt;/code&gt; 中使用的变量。变量 &lt;code&gt;$ready_to_print&lt;/code&gt; 是我的（）（词法）变量，&lt;b&gt;我&lt;/b&gt;ntroduced上线1069，并在线路1079的可变使用（第一与我的（）中声明） &lt;code&gt;$&amp;amp;&lt;/code&gt; 从主包装上使用1086，等。</target>
        </trans-unit>
        <trans-unit id="e3a1a612c118404300b4fc88e912d956be940f47" translate="yes" xml:space="preserve">
          <source>This shows us two libraries being updated and two being added, one of which has an undefined version in the right-hand side version.</source>
          <target state="translated">这表明我们有两个库在更新,两个库在添加,其中一个库的右侧版本有一个未定义的版本。</target>
        </trans-unit>
        <trans-unit id="a9392876266258935c97915a0016be1ab3e077a8" translate="yes" xml:space="preserve">
          <source>This shows what a reference looks like when it references a simple scalar.</source>
          <target state="translated">这显示了引用一个简单标量时的样子。</target>
        </trans-unit>
        <trans-unit id="62c1dd6d2092bdafabfdd27d34aabe7eb07a45cc" translate="yes" xml:space="preserve">
          <source>This shows what a reference to an array looks like.</source>
          <target state="translated">这显示了一个数组引用的样子。</target>
        </trans-unit>
        <trans-unit id="5af0b0f40fa34ec87e6b5d92094f2a134fbd1781" translate="yes" xml:space="preserve">
          <source>This signifies that this entry should be replaced by the decompositions for all the code points whose decomposition is algorithmically calculated. (All of them are currently in one range and no others outside the range are likely to ever be added to Unicode; the &lt;code&gt;&quot;n&quot;&lt;/code&gt; format has this same entry.) These can be generated via the function &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize::NFD()&lt;/a&gt;.</source>
          <target state="translated">这表示对于分解是通过算法计算的所有代码点，该条目应由分解替换。（它们当前都在一个范围内，并且该范围之外的其他任何对象都不可能添加到Unicode； &lt;code&gt;&quot;n&quot;&lt;/code&gt; 格式具有相同的条目。）可以通过函数&lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode :: Normalize :: NFD（ ）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="19b0c298e2bbc25317cee46892abecba84a7892d" translate="yes" xml:space="preserve">
          <source>This signifies that this entry should be replaced by the decompositions for all the code points whose decomposition is algorithmically calculated. (All of them are currently in one range and no others outside the range are likely to ever be added to Unicode; the &lt;code&gt;&quot;n&quot;&lt;/code&gt; format has this same entry.) These can be generated via the function &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize::NFD()&lt;/a&gt;.</source>
          <target state="translated">这表示该条目应由分解算法计算出的所有代码点的分解代替。（它们当前都在一个范围内，并且该范围之外的任何其他对象都不可能添加到Unicode； &lt;code&gt;&quot;n&quot;&lt;/code&gt; 格式具有相同的条目。）这些可以通过函数&lt;a href=&quot;normalize&quot;&gt;Unicode :: Normalize :: NFD（ ）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a3ee18b62d8c4cf82c2682ec3f88357d163d3e8" translate="yes" xml:space="preserve">
          <source>This silent implicit decoding is known as &quot;upgrading&quot;. That may sound positive, but it's best to avoid it.</source>
          <target state="translated">这种无声的隐性解码被称为 &quot;升级&quot;。这听起来似乎很积极,但最好还是避免。</target>
        </trans-unit>
        <trans-unit id="75ceec87638702fc9211fcbb47c663ad2b557d5f" translate="yes" xml:space="preserve">
          <source>This simplifies the reverse operation as the number of repetitions can be unpacked with the &lt;code&gt;/&lt;/code&gt; code:</source>
          <target state="translated">这可以简化反向操作，因为可以使用 &lt;code&gt;/&lt;/code&gt; 代码解开重复的次数：</target>
        </trans-unit>
        <trans-unit id="c76a52e49b25fb93c5814da39f8a0ca4f090ec45" translate="yes" xml:space="preserve">
          <source>This simply calls &lt;code&gt;sv_magic&lt;/code&gt; and coerces the &lt;code&gt;gv&lt;/code&gt; argument into an &lt;code&gt;SV&lt;/code&gt; .</source>
          <target state="translated">这只是调用 &lt;code&gt;sv_magic&lt;/code&gt; 并将 &lt;code&gt;gv&lt;/code&gt; 参数强制转换为 &lt;code&gt;SV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37a8b66b66bc575f562e00ecf205b1032d87cf22" translate="yes" xml:space="preserve">
          <source>This simply calls &lt;code&gt;sv_magic&lt;/code&gt; and coerces the &lt;code&gt;gv&lt;/code&gt; argument into an &lt;code&gt;SV&lt;/code&gt;.</source>
          <target state="translated">这只是调用 &lt;code&gt;sv_magic&lt;/code&gt; 并将 &lt;code&gt;gv&lt;/code&gt; 参数强制转换为 &lt;code&gt;SV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15c5bc95dce18ddda2693ffc0b4a16e21790eea4" translate="yes" xml:space="preserve">
          <source>This simply evaluates any expression (&lt;code&gt;$got eq $expected&lt;/code&gt; is just a simple example) and uses that to determine if the test succeeded or failed. A true expression passes, a false one fails. Very simple.</source>
          <target state="translated">这只是对任何表达式求值（ &lt;code&gt;$got eq $expected&lt;/code&gt; 只是一个简单的示例），并使用该表达式确定测试是成功还是失败。正确的表达式通过，错误的表达式通过。很简单。</target>
        </trans-unit>
        <trans-unit id="3d969d8fe90ed0cdf3881a37bda779e5984f6b64" translate="yes" xml:space="preserve">
          <source>This simply passes the C representation of the Perl variable (an SV*) in and out of the XS layer. This can be used if the C code wants to deal directly with the Perl variable.</source>
          <target state="translated">这只是简单地将Perl变量的C表示(一个SV*)传入和传出XS层。如果C代码想直接处理Perl变量,可以使用这个方法。</target>
        </trans-unit>
        <trans-unit id="2e6d63f50f6edf8d1ca7caa25f784dd03a42ad6f" translate="yes" xml:space="preserve">
          <source>This simultaneously affects all threads of the program, so it may be problematic to use locales in threaded applications except where there is a single locale applicable to all threads.</source>
          <target state="translated">这同时会影响到程序的所有线程,所以在线程应用程序中使用locale可能会有问题,除非有一个适用于所有线程的单一locale。</target>
        </trans-unit>
        <trans-unit id="cd936fff6e8f9ae7642c5c6dc94b4b5fc101a895" translate="yes" xml:space="preserve">
          <source>This situation can happen, for example, in</source>
          <target state="translated">例如,这种情况可能发生在</target>
        </trans-unit>
        <trans-unit id="39e7f436f0844c6bf989784164030c8f8ea5c91c" translate="yes" xml:space="preserve">
          <source>This software enables you to upgrade software on your computer and so is inherently dangerous because the newly installed software may contain bugs and may alter the way your computer works or even make it unusable. Please consider backing up your data before every upgrade.</source>
          <target state="translated">该软件可以让你升级电脑上的软件,因此具有内在的危险性,因为新安装的软件可能包含错误,可能会改变你的电脑的工作方式,甚至使其无法使用。在每次升级前,请考虑备份您的数据。</target>
        </trans-unit>
        <trans-unit id="95b86ac068430d7abe3629291f82ebff76fb040f" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 1996- by Andreas Koenig.</source>
          <target state="translated">本软件的版权是 (c)1996-by Andreas Koenig.</target>
        </trans-unit>
        <trans-unit id="dfe6bc95971d9555fd4a070b4a33ad4fd59cb09c" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 1997 - 2018 by Graham Barr &amp;amp; Dave Rolsky.</source>
          <target state="translated">该软件的版权归Graham Barr＆Dave Rolsky所有（c）1997-2018。</target>
        </trans-unit>
        <trans-unit id="b21371f38c12dbc9248a71f0465727bfaee148a3" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2002 by Ilya Zakharevich.</source>
          <target state="translated">本软件版权(c)2002年由Ilya Zakharevich所有。</target>
        </trans-unit>
        <trans-unit id="3c8d4de71ea698d046dd2d94f72a8a7fd4559231" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2010 by Adam Kennedy.</source>
          <target state="translated">本软件的版权(c)2010由亚当-肯尼迪。</target>
        </trans-unit>
        <trans-unit id="af578baff649ee012be86b76b46b21b70df94c94" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2010 by David Golden and Ricardo Signes.</source>
          <target state="translated">本软件版权(c)2010年由David Golden和Ricardo Signes所有。</target>
        </trans-unit>
        <trans-unit id="e8bb5af5fa084e557d0f3cc7f0b45662d3a55d8f" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2010 by David Golden, Ricardo Signes, Adam Kennedy and Contributors.</source>
          <target state="translated">本软件版权(c)2010由David Golden、Ricardo Signes、Adam Kennedy和贡献者所有。</target>
        </trans-unit>
        <trans-unit id="e377a624f20232cdb4cb749fe2907f2c5ef396be" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2013 by Leon Timmermans.</source>
          <target state="translated">本软件的版权(c)2013由Leon Timmermans拥有。</target>
        </trans-unit>
        <trans-unit id="67032da8813d4f4a0a08f93013ebb3760de4d75d" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2013 by Tim Jenness and the UK Particle Physics and Astronomy Research Council.</source>
          <target state="translated">本软件版权(c)2013年由Tim Jenness和英国粒子物理和天文学研究委员会版权所有。</target>
        </trans-unit>
        <trans-unit id="ff5cf6253d3c58ee0e8370fe0b1014e17ef0f493" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2014 by Adam Kennedy and Contributors.</source>
          <target state="translated">本软件版权(c)2014年由亚当-肯尼迪和贡献者所有。</target>
        </trans-unit>
        <trans-unit id="66f85f97c6d8584288b7cc1e27089a6848dac19e" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2016 by David Golden.</source>
          <target state="translated">本软件的版权(c)2016年由David Golden所有。</target>
        </trans-unit>
        <trans-unit id="d3e0edd840c94a8b44ae9918823591f4112c67a4" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2018 by Christian Hansen.</source>
          <target state="translated">本软件版权(c)2018年由Christian Hansen拥有。</target>
        </trans-unit>
        <trans-unit id="9071214c3f60bf69bb79c3a0e0a801662f73777b" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2019 by Tim Jenness and the UK Particle Physics and Astronomy Research Council.</source>
          <target state="translated">这个软件的版权(c)2019年由Tim Jenness和英国粒子物理和天文学研究委员会。</target>
        </trans-unit>
        <trans-unit id="5fb28093815e879710a9bb0a4ef5d290c79e5b95" translate="yes" xml:space="preserve">
          <source>This software is free software and can be modified and distributed under the same terms as Perl itself.</source>
          <target state="translated">该软件是自由软件,可以在与Perl本身相同的条款下进行修改和发布。</target>
        </trans-unit>
        <trans-unit id="0dbd632224b5aa617ba78b7d9260ccc05095f469" translate="yes" xml:space="preserve">
          <source>This software is released under the MIT license cited below. Additionally, when this software is distributed with &lt;b&gt;Perl Kit, Version 5&lt;/b&gt;, you may also redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">该软件根据以下引用的MIT许可证发布。此外，当此软件与&lt;b&gt;Perl Kit版本5一起&lt;/b&gt;分发时，您还可以按照与Perl本身相同的条款重新分发和/或修改它。</target>
        </trans-unit>
        <trans-unit id="b8cc7587a3592d000978422dcd1052715c6866c6" translate="yes" xml:space="preserve">
          <source>This software pattern is so widely applicable that Attribute::Handlers provides a way to automate it: specifying &lt;code&gt;'autotie'&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Attribute::Handlers&lt;/code&gt; statement. So, the cycling example, could also be written:</source>
          <target state="translated">该软件模式的适用范围非常广泛，以致Attribute :: Handlers提供了一种自动化的方式：在 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Attribute::Handlers&lt;/code&gt; Attribute :: Handlers语句中指定 &lt;code&gt;'autotie'&lt;/code&gt; 。因此，循环示例也可以写成：</target>
        </trans-unit>
        <trans-unit id="d91e373183a0a3faaf1f65e220cc6670b2950cfc" translate="yes" xml:space="preserve">
          <source>This software pattern is so widely applicable that Attribute::Handlers provides a way to automate it: specifying &lt;code&gt;'autotie'&lt;/code&gt; in the &lt;code&gt;use Attribute::Handlers&lt;/code&gt; statement. So, the cycling example, could also be written:</source>
          <target state="translated">这种软件模式的适用范围非常广泛，以致Attribute :: Handlers提供了一种自动化的方式：在 &lt;code&gt;use Attribute::Handlers&lt;/code&gt; 语句中指定 &lt;code&gt;'autotie'&lt;/code&gt; 。因此，循环示例也可以写成：</target>
        </trans-unit>
        <trans-unit id="89832468782e8e99834462aa8eda8b90c2a987a8" translate="yes" xml:space="preserve">
          <source>This somewhat unpredictable behavior can be avoided with the &quot;bitwise&quot; feature, new in Perl 5.22. You can enable it via &lt;code&gt;use feature 'bitwise'&lt;/code&gt; or &lt;code&gt;use v5.28&lt;/code&gt;. Before Perl 5.28, it used to emit a warning in the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; category. Under this feature, the four standard bitwise operators (&lt;code&gt;~ | &amp;amp; ^&lt;/code&gt;) are always numeric. Adding a dot after each operator (&lt;code&gt;~. |. &amp;amp;. ^.&lt;/code&gt;) forces it to treat its operands as strings:</source>
          <target state="translated">使用Perl 5.22中新增的&amp;ldquo;按位&amp;rdquo;功能可以避免这种无法预料的行为。您可以通过 &lt;code&gt;use feature 'bitwise'&lt;/code&gt; 或 &lt;code&gt;use v5.28&lt;/code&gt; 启用它。在Perl 5.28之前，它曾经在 &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; 类别中发出警告。在此功能下，四个标准的按位运算符（ &lt;code&gt;~ | &amp;amp; ^&lt;/code&gt; ）始终是数字。在每个运算符（ &lt;code&gt;~. |. &amp;amp;. ^.&lt;/code&gt; ）之后添加一个点，将其强制将其操作数视为字符串：</target>
        </trans-unit>
        <trans-unit id="8e4e18e30d88ab31167f2d6596e06fcdc6dfcfae" translate="yes" xml:space="preserve">
          <source>This somewhat unpredictable behavior can be avoided with the experimental &quot;bitwise&quot; feature, new in Perl 5.22. You can enable it via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'bitwise'&lt;/code&gt; . By default, it will warn unless the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; warnings category has been disabled. (&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; experimental 'bitwise'&lt;/code&gt; will enable the feature and disable the warning.) Under this feature, the four standard bitwise operators (&lt;code&gt;~ | &amp;amp; ^&lt;/code&gt;) are always numeric. Adding a dot after each operator (&lt;code&gt;~. |. &amp;amp;. ^.&lt;/code&gt; ) forces it to treat its operands as strings:</source>
          <target state="translated">Perl 5.22中新增的实验性&amp;ldquo;按位&amp;rdquo;功能可以避免这种无法预测的行为。您可以通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'bitwise'&lt;/code&gt; 启用它。默认情况下，它将警告，除非已禁用 &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; 警告类别。 （ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; experimental 'bitwise'&lt;/code&gt; 将启用该功能并禁用警告。）在此功能下，四个标准按位运算符（ &lt;code&gt;~ | &amp;amp; ^&lt;/code&gt; ）始终为数字。在每个运算符（ &lt;code&gt;~. |. &amp;amp;. ^.&lt;/code&gt; ）之后添加一个点，将其强制将其操作数视为字符串：</target>
        </trans-unit>
        <trans-unit id="c23e7895c905e61a802fac11e961fcc5116c44d1" translate="yes" xml:space="preserve">
          <source>This sort of code can be a real eyesore to read, as well as being very sensitive to typos, and it's much clearer to dereference the variable explicitly. We're side-stepping the issue of working with object-oriented programming techniques to encapsulate variable access via methods, only accessible through an object. Here we're just discussing the technical implementation of choice, and whether this has an effect on performance. We can see whether this dereferencing operation, has any overhead by putting comparative code in a file and running a &lt;code&gt;Benchmark&lt;/code&gt; test.</source>
          <target state="translated">这类代码可能真是让人讨厌阅读，并且对错别字非常敏感，并且显式取消对变量的引用更加清晰。我们正在回避使用面向对象的编程技术来封装只能通过对象访问的方法访问变量的问题。在这里，我们只是在讨论选择的技术实现，以及这是否会对性能产生影响。通过将比较代码放在文件中并运行 &lt;code&gt;Benchmark&lt;/code&gt; 测试，我们可以查看此取消引用操作是否有任何开销。</target>
        </trans-unit>
        <trans-unit id="30f7b19aa0a9a6b3365d27ee63f89751c7ffa5a4" translate="yes" xml:space="preserve">
          <source>This special value becomes JSON null.</source>
          <target state="translated">这个特殊的值成为JSON空值。</target>
        </trans-unit>
        <trans-unit id="a97c4e8f1d7ea6446c4098759acfa71805444e34" translate="yes" xml:space="preserve">
          <source>This special variable is correctly set to the pseudo-process ID. It can be used to identify pseudo-processes within a particular session. Note that this value is subject to recycling if any pseudo-processes are launched after others have been wait()-ed on.</source>
          <target state="translated">这个特殊变量被正确地设置为伪进程ID。它可以用来识别特定会话中的伪进程。请注意,如果任何伪进程在其他伪进程被wait()-ed后启动,这个值会被回收。</target>
        </trans-unit>
        <trans-unit id="d6c4aceca7fa6325a5de35ebe0aa5f8ca9090348" translate="yes" xml:space="preserve">
          <source>This specifies a search for library &lt;code&gt;gl&lt;/code&gt; as before. If that search fails to find the library, it looks at the next item in the list. The &lt;code&gt;:nosearch&lt;/code&gt; flag will prevent searching for the libraries that follow, so it simply returns the value as &lt;code&gt;-Ld:\mesalibs -lmesa -luser32&lt;/code&gt;, since GCC can use that value as is with its linker.</source>
          <target state="translated">与以前一样，这指定了对库 &lt;code&gt;gl&lt;/code&gt; 的搜索。如果该搜索找不到图书馆，它将查看列表中的下一项。的 &lt;code&gt;:nosearch&lt;/code&gt; 标志将阻止搜索后面的库，所以它只是返回值 &lt;code&gt;-Ld:\mesalibs -lmesa -luser32&lt;/code&gt; ，因为GCC可以使用该值作为与它的连接。</target>
        </trans-unit>
        <trans-unit id="15c61edb09c43955982bc45d6acb4f0c4af7b4ab" translate="yes" xml:space="preserve">
          <source>This specifies an option to call the formatter &lt;b&gt;w&lt;/b&gt;ith. For example, &lt;code&gt;-w textsize:15&lt;/code&gt; will call &lt;code&gt;$formatter-&amp;gt;textsize(15)&lt;/code&gt; on the formatter object before it is used to format the object. For this to be valid, the formatter class must provide such a method, and the value you pass should be valid. (So if &lt;code&gt;textsize&lt;/code&gt; expects an integer, and you do &lt;code&gt;-w textsize:big&lt;/code&gt;, expect trouble.)</source>
          <target state="translated">这是选项调用格式化&lt;b&gt;W&amp;macr;&amp;macr;&lt;/b&gt;第i个。例如， &lt;code&gt;-w textsize:15&lt;/code&gt; 在用于格式化对象之前将在格式化程序对象上调用 &lt;code&gt;$formatter-&amp;gt;textsize(15)&lt;/code&gt; 。为使此方法有效，格式化程序类必须提供这样的方法，并且您传递的值必须有效。（因此，如果 &lt;code&gt;textsize&lt;/code&gt; 需要一个整数，而您执行 &lt;code&gt;-w textsize:big&lt;/code&gt; ，则会遇到麻烦。）</target>
        </trans-unit>
        <trans-unit id="68a43776b3796bfc1e7b13ea689fcb5185c15c99" translate="yes" xml:space="preserve">
          <source>This specifies code that should be called when a code line is seen (i.e., a line outside of the Pod). Normally this is undef, meaning that no code should be called. If you provide a routine, it should start out like this:</source>
          <target state="translated">这指定了当看到一行代码(即Pod外的一行)时应该被调用的代码。通常这是undef,意味着不应该调用任何代码。如果你提供了一个例程,它应该像这样开始。</target>
        </trans-unit>
        <trans-unit id="14a814b946e54a59ba68d016b5b039bbdb959679" translate="yes" xml:space="preserve">
          <source>This specifies that the director &quot;somedir&quot; is the input. (This can be an absolute or relative path, it doesn't matter.)</source>
          <target state="translated">这指定了导演 &quot;somedir &quot;是输入。可以是绝对路径或相对路径,这并不重要)。</target>
        </trans-unit>
        <trans-unit id="6e3a29e95276948f0b11420f703cc3aaddffd6ef" translate="yes" xml:space="preserve">
          <source>This specifies that the input directories are the items in the arrayref &lt;code&gt;\@dirs&lt;/code&gt; .</source>
          <target state="translated">这指定输入目录是arrayref &lt;code&gt;\@dirs&lt;/code&gt; 中的项目。</target>
        </trans-unit>
        <trans-unit id="1655aff188e0c2a28c8b5f646e8ad62ec66c5897" translate="yes" xml:space="preserve">
          <source>This specifies that the input directories are the items in the arrayref &lt;code&gt;\@dirs&lt;/code&gt;.</source>
          <target state="translated">这指定输入目录是arrayref &lt;code&gt;\@dirs&lt;/code&gt; 中的项目。</target>
        </trans-unit>
        <trans-unit id="63679666659be8466fb9bd4dddfdca5063fd3f26" translate="yes" xml:space="preserve">
          <source>This specifies that the output is not to be sent to a pager, but is to be sent directly to STDOUT.</source>
          <target state="translated">这指定了输出不会被发送到寻呼机,而是直接发送到STDOUT。</target>
        </trans-unit>
        <trans-unit id="b1a8fe6a04c1ca76ee22b76d1682c8136ef9711f" translate="yes" xml:space="preserve">
          <source>This specifies that the output is to be sent neither to a pager nor to STDOUT, but is to be saved to the specified filename. Example: &lt;code&gt;perldoc -oLaTeX -dtextwrapdocs.tex Text::Wrap&lt;/code&gt;</source>
          <target state="translated">这指定输出既不发送到寻呼机也不发送到STDOUT，而是保存到指定的文件名。示例： &lt;code&gt;perldoc -oLaTeX -dtextwrapdocs.tex Text::Wrap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45d4b28c13ac9c0ec2726a96f6188b8beab502af" translate="yes" xml:space="preserve">
          <source>This specifies that you want Perldoc to try using a Pod-formatting class for the output format that you specify. For example: &lt;code&gt;-oman&lt;/code&gt; . This is actually just a wrapper around the &lt;code&gt;-M&lt;/code&gt; switch; using &lt;code&gt;-o&lt;i&gt;formatname&lt;/i&gt;&lt;/code&gt; just looks for a loadable class by adding that format name (with different capitalizations) to the end of different classname prefixes.</source>
          <target state="translated">这指定您希望Perldoc尝试对指定的输出格式使用Pod格式的类。例如： &lt;code&gt;-oman&lt;/code&gt; 。实际上，这只是 &lt;code&gt;-M&lt;/code&gt; 开关的包装。使用 &lt;code&gt;-o&lt;i&gt;formatname&lt;/i&gt;&lt;/code&gt; 只是通过将格式名称（大小写不同）添加到不同的类名前缀的末尾来查找可加载的类。</target>
        </trans-unit>
        <trans-unit id="010d97695be94f0fec9f8d59b9e5f92e8321d055" translate="yes" xml:space="preserve">
          <source>This specifies that you want Perldoc to try using a Pod-formatting class for the output format that you specify. For example: &lt;code&gt;-oman&lt;/code&gt;. This is actually just a wrapper around the &lt;code&gt;-M&lt;/code&gt; switch; using &lt;code&gt;-o&lt;i&gt;formatname&lt;/i&gt;&lt;/code&gt; just looks for a loadable class by adding that format name (with different capitalizations) to the end of different classname prefixes.</source>
          <target state="translated">这指定您希望Perldoc尝试对指定的输出格式使用Pod格式的类。例如： &lt;code&gt;-oman&lt;/code&gt; 。实际上，这只是 &lt;code&gt;-M&lt;/code&gt; 开关的包装。使用 &lt;code&gt;-o&lt;i&gt;formatname&lt;/i&gt;&lt;/code&gt; 只是通过将格式名称（大小写不同）添加到不同的类名前缀的末尾来查找可加载的类。</target>
        </trans-unit>
        <trans-unit id="9e4b01265a71898dfb9f81df9b68ddce9ce51346" translate="yes" xml:space="preserve">
          <source>This specifies that you want the HTML output to go into the current directory.</source>
          <target state="translated">这说明你希望HTML输出进入当前目录。</target>
        </trans-unit>
        <trans-unit id="2ae7a3e343e7bbeb0dfb1ab04a69a9932581a88b" translate="yes" xml:space="preserve">
          <source>This specifies that you want the HTML output to go into the directory 'somedir'. (This can be an absolute or relative path, it doesn't matter.)</source>
          <target state="translated">这说明你希望HTML输出进入'somedir'目录。这可以是一个绝对或相对的路径,这并不重要。</target>
        </trans-unit>
        <trans-unit id="e7729b553095fc163c271a3e43dbeb5e583f17f6" translate="yes" xml:space="preserve">
          <source>This specifies that you want the dirs &quot;somedir&quot;, &quot;someother&quot;, and &quot;also&quot; scanned, just as if you'd passed the arrayref &lt;code&gt;[qw( somedir someother also)]&lt;/code&gt; . Note that a &quot;:&quot;-separator is normal under Unix, but Under MSWin, you'll need &lt;code&gt;'somedir;someother;also'&lt;/code&gt; instead, since the pathsep on MSWin is &quot;;&quot; instead of &quot;:&quot;. (And</source>
          <target state="translated">这指定您要扫描目录&amp;ldquo; somedir&amp;rdquo;，&amp;ldquo; someother&amp;rdquo;和&amp;ldquo; also&amp;rdquo;，就像传递了arrayref &lt;code&gt;[qw( somedir someother also)]&lt;/code&gt; 。请注意，&amp;ldquo;：&amp;rdquo;-分隔符在Unix下是正常的，但在MSWin下，您将需要 &lt;code&gt;'somedir;someother;also'&lt;/code&gt; ，因为MSWin上的pathep是&amp;ldquo;;&amp;rdquo;。代替 &amp;rdquo;：&amp;rdquo;。（和</target>
        </trans-unit>
        <trans-unit id="4d5774ca5649a7d9fa31c36d1f9fa10a02babb34" translate="yes" xml:space="preserve">
          <source>This specifies that you want the dirs &quot;somedir&quot;, &quot;someother&quot;, and &quot;also&quot; scanned, just as if you'd passed the arrayref &lt;code&gt;[qw( somedir someother also)]&lt;/code&gt;. Note that a &quot;:&quot;-separator is normal under Unix, but Under MSWin, you'll need &lt;code&gt;'somedir;someother;also'&lt;/code&gt; instead, since the pathsep on MSWin is &quot;;&quot; instead of &quot;:&quot;. (And</source>
          <target state="translated">这指定您要扫描目录&amp;ldquo; somedir&amp;rdquo;，&amp;ldquo; someother&amp;rdquo;和&amp;ldquo; also&amp;rdquo;，就像传递了arrayref &lt;code&gt;[qw( somedir someother also)]&lt;/code&gt; 。请注意，&amp;ldquo;：&amp;rdquo;-分隔符在Unix下是正常的，但是在MSWin下，您将需要 &lt;code&gt;'somedir;someother;also'&lt;/code&gt; ，因为MSWin上的pathep是&amp;ldquo;;&amp;rdquo;。代替 &amp;rdquo;：&amp;rdquo;。（和</target>
        </trans-unit>
        <trans-unit id="b8852ab4d60e276583c1dd4292c015bb068208e6" translate="yes" xml:space="preserve">
          <source>This specifies the module that you want to try using for formatting the pod. The class must at least provide a &lt;code&gt;parse_from_file&lt;/code&gt; method. For example: &lt;code&gt;perldoc -MPod::Perldoc::ToChecker&lt;/code&gt; .</source>
          <target state="translated">这指定您要尝试用于格式化容器的模块。该类至少必须提供 &lt;code&gt;parse_from_file&lt;/code&gt; 方法。例如： &lt;code&gt;perldoc -MPod::Perldoc::ToChecker&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9860d4fcf1674e2b5833d10a9182c9c5be14d26" translate="yes" xml:space="preserve">
          <source>This specifies the module that you want to try using for formatting the pod. The class must at least provide a &lt;code&gt;parse_from_file&lt;/code&gt; method. For example: &lt;code&gt;perldoc -MPod::Perldoc::ToChecker&lt;/code&gt;.</source>
          <target state="translated">这指定您要尝试用于格式化容器的模块。该类至少必须提供 &lt;code&gt;parse_from_file&lt;/code&gt; 方法。例如： &lt;code&gt;perldoc -MPod::Perldoc::ToChecker&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be95e643e0441d56be0f4bdb53c658cbf47d5fc4" translate="yes" xml:space="preserve">
          <source>This specifies what string should be put at the beginning of the contents page. The default is a string more or less like this:</source>
          <target state="translated">这指定了内容页的开头应该放什么字符串。默认情况下是一个类似于这样的字符串。</target>
        </trans-unit>
        <trans-unit id="9c8f94ea33d23c19ce77204a84bf9dc0e745ad73" translate="yes" xml:space="preserve">
          <source>This specifies what string should be put at the end of the contents page. The default is a string more or less like this:</source>
          <target state="translated">这指定了内容页的结尾应该放什么字符串。默认的是一个类似于这样的字符串。</target>
        </trans-unit>
        <trans-unit id="6917d9958e46c59dbadffa0d75ffc8ead9eeb027" translate="yes" xml:space="preserve">
          <source>This specifies where to find a YAML file of test scheduling rules. If not provided, it looks for a default file to use. It first checks for a file given in the &lt;code&gt;HARNESS_RULESFILE&lt;/code&gt; environment variable, then it checks for</source>
          <target state="translated">这指定在哪里可以找到测试计划规则的YAML文件。如果未提供，它将查找要使用的默认文件。它首先检查在 &lt;code&gt;HARNESS_RULESFILE&lt;/code&gt; 环境变量中给定的文件，然后检查</target>
        </trans-unit>
        <trans-unit id="ad18b67d60ebc32fa32a162a7cf995a9a7c75509" translate="yes" xml:space="preserve">
          <source>This stack stores the values that regular perl code is operating on, usually intermediate values of expressions within a statement. The stack itself is formed of an array of SV pointers.</source>
          <target state="translated">这个堆栈存储了常规perl代码正在操作的值,通常是语句中表达式的中间值。栈本身是由SV指针数组组成的。</target>
        </trans-unit>
        <trans-unit id="c702c584a5b241344dd398527ce50b4bfbe9b63e" translate="yes" xml:space="preserve">
          <source>This stage is controlled by the macro &lt;code&gt;SIZE_ONLY&lt;/code&gt; being set.</source>
          <target state="translated">该阶段由设置的宏 &lt;code&gt;SIZE_ONLY&lt;/code&gt; 控制。</target>
        </trans-unit>
        <trans-unit id="bad4c7bd6149d53fef7284ef08f67b09b3206bd8" translate="yes" xml:space="preserve">
          <source>This statement is not a legal contract. This statement is not a legal document in any way, shape, or form. Perl is distributed under the GNU Public License and under the Artistic License; those are the precise legal terms. This statement isn't about the law or licenses. It's about community, mutual respect, trust, and good-faith cooperation.</source>
          <target state="translated">本声明不是法律合同。本声明不是以任何方式、形状或形式的法律文件。Perl 是在 GNU Public License 和 Artistic License 下发布的;这些都是准确的法律条款。本声明不是关于法律或许可证的,而是关于社区、相互尊重。它是关于社区、相互尊重、信任和善意的合作。</target>
        </trans-unit>
        <trans-unit id="5a98c55935426becf715b954b892501f79db080b" translate="yes" xml:space="preserve">
          <source>This statement should at least appear in the README file. You may also wish to include it in a Copying file and your source files. Remember to include the other words in addition to the Copyright.</source>
          <target state="translated">这个声明至少应该出现在 README 文件中。您可能也希望在复制文件和您的源文件中包含它。记住,除了版权之外,还要包括其他文字。</target>
        </trans-unit>
        <trans-unit id="5584a0e56dfda5fbec4748cd6a50bc455909922d" translate="yes" xml:space="preserve">
          <source>This step is listed for completeness only. Since it does not change semantics, details of this step are not documented and are subject to change without notice. This step is performed over the finite automaton that was generated during the previous pass.</source>
          <target state="translated">列举这一步只是为了完整性。因为它不改变语义,所以这一步的细节没有被记录下来,可能会在不通知的情况下发生变化。这一步是在上一次生成的有限自动机上进行的。</target>
        </trans-unit>
        <trans-unit id="54c5eb8ed193c34bf7512d41b140b26cac84363b" translate="yes" xml:space="preserve">
          <source>This step is the last one for all constructs except regular expressions, which are processed further.</source>
          <target state="translated">这一步是除正则表达式以外的所有构造体的最后一步,它将被进一步处理。</target>
        </trans-unit>
        <trans-unit id="821b4588528e230329db6b553dfd4048a67b80be" translate="yes" xml:space="preserve">
          <source>This still doesn't guarantee that a real person is answering your prompts or reading your output.</source>
          <target state="translated">这仍然不能保证有真人在回答你的提示或阅读你的输出。</target>
        </trans-unit>
        <trans-unit id="a7c9161f97b6f8900f13bf7304c1db4d0488adaf" translate="yes" xml:space="preserve">
          <source>This stores the number of eval groups in the pattern. This is used for security purposes when embedding compiled regexes into larger patterns with &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这将在模式中存储评估组的数量。当使用 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 将已编译的正则表达式嵌入较大的模式时，这出于安全目的使用。</target>
        </trans-unit>
        <trans-unit id="fc862416697ee8a2c0658635a4952465e7e9a208" translate="yes" xml:space="preserve">
          <source>This stores the number of eval groups in the pattern. This is used for security purposes when embedding compiled regexes into larger patterns with &lt;code&gt;qr//&lt;/code&gt;.</source>
          <target state="translated">这将在模式中存储评估组的数量。当使用 &lt;code&gt;qr//&lt;/code&gt; 将已编译的正则表达式嵌入较大的模式时，这出于安全目的使用。</target>
        </trans-unit>
        <trans-unit id="fc38633b5aabfda04a32707218d9bef85297337b" translate="yes" xml:space="preserve">
          <source>This strategy can employ a network connection. As such it would be computationally expensive.</source>
          <target state="translated">这种策略可以采用网络连接。因此,它在计算上会很昂贵。</target>
        </trans-unit>
        <trans-unit id="55b6f7ba63a618224a4b898bcbb27d9706c30d52" translate="yes" xml:space="preserve">
          <source>This string tells Perl to consult the CRTL's internal &lt;code&gt;environ&lt;/code&gt; array of key-value pairs, using</source>
          <target state="translated">该字符串告诉Perl使用以下命令查询CRTL的键值对的内部 &lt;code&gt;environ&lt;/code&gt; 数组</target>
        </trans-unit>
        <trans-unit id="7ae6448a0aa9566553b6817c071e02a343cc087d" translate="yes" xml:space="preserve">
          <source>This struct typedef</source>
          <target state="translated">该结构类型ef</target>
        </trans-unit>
        <trans-unit id="f1bc15138286b1a37e209e8a6243ffb9f2ea5373" translate="yes" xml:space="preserve">
          <source>This structure is used for handling data structures that the regex engine needs to handle specially during a clone or free operation on the compiled product. Each element in the data array has a corresponding element in the what array. During compilation regops that need special structures stored will add an element to each array using the add_data() routine and then store the index in the regop.</source>
          <target state="translated">该结构用于处理regex引擎在对编译产品进行克隆或释放操作时需要特别处理的数据结构。数据数组中的每个元素在what数组中都有一个对应的元素。在编译过程中,需要存储特殊结构的regop会使用add_data()例程向每个数组中添加一个元素,然后将索引存储在regop中。</target>
        </trans-unit>
        <trans-unit id="313e4efa9f1c4a624d38d9de85969d28133dcf4f" translate="yes" xml:space="preserve">
          <source>This stuff if needed to allow me to play with other ways of monitoring the test results.</source>
          <target state="translated">这个东西如果需要的话,可以让我玩其他的方式来监测测试结果。</target>
        </trans-unit>
        <trans-unit id="d78d4b0d4925694b27ab08d1c6e58334dc8e28bc" translate="yes" xml:space="preserve">
          <source>This style of commenting has been largely superseded by the raw, freeform commenting that is allowed with the &lt;code&gt;//x&lt;/code&gt; modifier.</source>
          <target state="translated">这种注释风格已被 &lt;code&gt;//x&lt;/code&gt; 修饰符允许的原始的自由格式注释所取代。</target>
        </trans-unit>
        <trans-unit id="057805a7554b8dd392dcf60ed8e3b1750c015cb9" translate="yes" xml:space="preserve">
          <source>This style of commenting has been largely superseded by the raw, freeform commenting that is allowed with the &lt;code&gt;/x&lt;/code&gt; modifier.</source>
          <target state="translated">这种注释风格已被 &lt;code&gt;/x&lt;/code&gt; 修饰符允许的原始的，自由格式的注释所取代。</target>
        </trans-unit>
        <trans-unit id="9149446c6e172d289bce208ab7502a726c607dbb" translate="yes" xml:space="preserve">
          <source>This subkey gives the integer</source>
          <target state="translated">这个子键给出了整数</target>
        </trans-unit>
        <trans-unit id="97f344b018a57310e7df154cc09c4a4c8ffc8347" translate="yes" xml:space="preserve">
          <source>This subroutine accepts a new style name and three style arguments as above, and creates, registers, and selects the newly named style. It is an error to re-add a style; call set_style_standard() to switch between several styles.</source>
          <target state="translated">这个子程序像上面一样接受一个新的样式名称和三个样式参数,并创建、注册和选择新命名的样式。重新添加一个样式是错误的,调用set_style_standard()可以在多个样式之间切换。</target>
        </trans-unit>
        <trans-unit id="d4edd10fd3d7f6f2e8552ea6e5bfd25a981a931d" translate="yes" xml:space="preserve">
          <source>This subroutine produces a standard help message, derived from the program's POD section SYNOPSIS using &lt;a href=&quot;../pod/usage&quot;&gt;Pod::Usage&lt;/a&gt;. It takes the same arguments as VersionMessage(). In particular, you cannot tie it directly to an option, e.g.:</source>
          <target state="translated">该子例程生成标准帮助消息，该消息是使用&lt;a href=&quot;../pod/usage&quot;&gt;Pod :: Usage&lt;/a&gt;从程序的POD部分SYNOPSIS派生的。它采用与VersionMessage（）相同的参数。特别是，您不能将其直接绑定到选项，例如：</target>
        </trans-unit>
        <trans-unit id="9b889ca4ce29aee9a3861172160f0fc1f9aa54f8" translate="yes" xml:space="preserve">
          <source>This subroutine produces a standard help message, derived from the program's POD section SYNOPSIS using &lt;a href=&quot;Pod::Usage&quot;&gt;Pod::Usage&lt;/a&gt;. It takes the same arguments as VersionMessage(). In particular, you cannot tie it directly to an option, e.g.:</source>
          <target state="translated">该子例程生成标准帮助消息，该消息是使用&lt;a href=&quot;Pod::Usage&quot;&gt;Pod :: Usage&lt;/a&gt;从程序的POD部分SYNOPSIS派生的。它采用与VersionMessage（）相同的参数。特别是，您不能将其直接绑定到选项，例如：</target>
        </trans-unit>
        <trans-unit id="5689fa040b7fc66f95972afdb83490d423250c81" translate="yes" xml:space="preserve">
          <source>This subroutine provides a standard version message. Its argument can be:</source>
          <target state="translated">这个子程序提供了一个标准版本信息。其参数可以是:</target>
        </trans-unit>
        <trans-unit id="8ecee5dd8e0a61ddae4c3d45c386aa7954dd0f33" translate="yes" xml:space="preserve">
          <source>This subroutine will add commas to your number:</source>
          <target state="translated">这个子程序将在你的数字上添加逗号。</target>
        </trans-unit>
        <trans-unit id="f33530c08d2ea0b801b43fac5cff8bb563110c57" translate="yes" xml:space="preserve">
          <source>This succeeds if the &quot;martian&quot; character GX is in the string, and fails otherwise. If you don't like using (?&amp;lt;!), a zero-width negative look-behind assertion, you can replace (?&amp;lt;![A-Z]) with (?:^|[^A-Z]).</source>
          <target state="translated">如果字符串中的&amp;ldquo;火星人&amp;rdquo;字符GX成功，则成功，否则失败。如果您不喜欢使用（？&amp;lt;！）（零宽度的负后向断言），则可以将（？&amp;lt;！[AZ]）替换为（？：^ | [^ AZ]）。</target>
        </trans-unit>
        <trans-unit id="85a98330f72d7fa29e768ec7aa2344fb1a20cbca" translate="yes" xml:space="preserve">
          <source>This suppresses printing of VMS status messages to SYS$OUTPUT and SYS$ERROR if Perl terminates with an error status, and allows programs that are expecting &quot;unix-style&quot; Perl to avoid having to parse VMS error messages. It does not suppress any messages from Perl itself, just the messages generated by DCL after Perl exits. The DCL symbol $STATUS will still have the termination status, but with a high-order bit set:</source>
          <target state="translated">如果Perl以错误状态结束,它将抑制向SYS$OUTPUT和SYS$ERROR打印VMS状态信息,并允许那些期望使用 &quot;unix-style &quot;Perl的程序避免解析VMS错误信息。它不会抑制Perl本身的任何消息,只是在Perl退出后DCL产生的消息。DCL符号$STATUS仍将具有终止状态,但设置了一个高阶位。</target>
        </trans-unit>
        <trans-unit id="a73c08f06f0acf42846845d03633aa9b47905a33" translate="yes" xml:space="preserve">
          <source>This surprising autovivification in what does not at first--or even second--glance appear to be an lvalue context may be fixed in a future release.</source>
          <target state="translated">这种出人意料的自动进化,乍看之下甚至不像是一个l值上下文,可能会在未来的版本中得到修正。</target>
        </trans-unit>
        <trans-unit id="e56b6634af06492105c8150cce8eec38c642722a" translate="yes" xml:space="preserve">
          <source>This switch causes Perl to dump core after compiling your program. You can then in theory take this core dump and turn it into an executable file by using the</source>
          <target state="translated">这个开关会让Perl在编译你的程序后转储核心。理论上,你可以通过使用</target>
        </trans-unit>
        <trans-unit id="cdeac32803cbaac383dc34d3e5d5f188b61766f8" translate="yes" xml:space="preserve">
          <source>This switch really just enables the global &lt;code&gt;$^W&lt;/code&gt; variable; normally, the lexically scoped &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma is preferred. You can disable or promote into fatal errors specific warnings using &lt;code&gt;__WARN__&lt;/code&gt; hooks, as described in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; and &lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;. See also &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; and &lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt;. A fine-grained warning facility is also available if you want to manipulate entire classes of warnings; see &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">这个开关实际上只是启用了全局 &lt;code&gt;$^W&lt;/code&gt; 变量。通常，首选词法范围的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 。您可以使用 &lt;code&gt;__WARN__&lt;/code&gt; 挂钩将特定的警告禁用或升级为致命错误，如&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;和&lt;a href=&quot;functions/warn&quot;&gt;warn中所述&lt;/a&gt;。另请参见&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;和&lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt;。如果您要操纵整个警告类别，还可以使用细粒度的警告工具。看到&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1eec8c1e53eca861ae72403ed034c71d15de36a4" translate="yes" xml:space="preserve">
          <source>This switch really just enables the global &lt;code&gt;$^W&lt;/code&gt; variable; normally, the lexically scoped &lt;code&gt;use warnings&lt;/code&gt; pragma is preferred. You can disable or promote into fatal errors specific warnings using &lt;code&gt;__WARN__&lt;/code&gt; hooks, as described in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; and &lt;a href=&quot;perlfunc#warn&quot;&gt;&quot;warn&quot; in perlfunc&lt;/a&gt;. See also &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; and &lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt;. A fine-grained warning facility is also available if you want to manipulate entire classes of warnings; see &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">这个开关实际上只是启用了全局 &lt;code&gt;$^W&lt;/code&gt; 变量。通常，首选词法范围的 &lt;code&gt;use warnings&lt;/code&gt; 。您可以使用 &lt;code&gt;__WARN__&lt;/code&gt; 挂钩将特定的警告禁用或升级为致命错误，如&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;和&lt;a href=&quot;perlfunc#warn&quot;&gt;perlfunc中的&amp;ldquo; warn&amp;rdquo;中所述&lt;/a&gt;。另请参见&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;和&lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt;。如果您要操纵整个警告类别，还可以使用细粒度的警告工具。看到&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9aace5953cb75e0bd50c74f57a0b38f9c0103c2" translate="yes" xml:space="preserve">
          <source>This symbol conditionally defines the symbol &lt;code&gt;BSD&lt;/code&gt; when running on a &lt;code&gt;BSD&lt;/code&gt; system.</source>
          <target state="translated">在 &lt;code&gt;BSD&lt;/code&gt; 系统上运行时，该符号有条件地定义了 &lt;code&gt;BSD&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="9dffb9b12a2139e8c4c666d76c2bbb94b410515d" translate="yes" xml:space="preserve">
          <source>This symbol contains the type of pointer returned by mmap() (and simultaneously the type of the first argument). It can be &lt;code&gt;void *&lt;/code&gt; or &lt;code&gt;caddr_t&lt;/code&gt; .</source>
          <target state="translated">该符号包含mmap（）返回的指针类型（以及第一个参数的类型）。它可以是 &lt;code&gt;void *&lt;/code&gt; 或 &lt;code&gt;caddr_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82fb35656fbf4e4b9cf3733e209ae82b04049909" translate="yes" xml:space="preserve">
          <source>This symbol contains the type of pointer returned by mmap() (and simultaneously the type of the first argument). It can be &lt;code&gt;void *&lt;/code&gt; or &lt;code&gt;caddr_t&lt;/code&gt;.</source>
          <target state="translated">该符号包含mmap（）返回的指针类型（以及第一个参数的类型）。它可以是 &lt;code&gt;void *&lt;/code&gt; 或 &lt;code&gt;caddr_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e78cc593a5e3d5f9580ef534ee09e8fe0d641140" translate="yes" xml:space="preserve">
          <source>This symbol contains the type of pointer returned by shmat(). It can be &lt;code&gt;void *&lt;/code&gt; or &lt;code&gt;char *&lt;/code&gt; .</source>
          <target state="translated">该符号包含shmat（）返回的指针的类型。它可以是 &lt;code&gt;void *&lt;/code&gt; 或 &lt;code&gt;char *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="784f8163b2c96f5e1ad2d33b1877166fe69ae941" translate="yes" xml:space="preserve">
          <source>This symbol contains the type of pointer returned by shmat(). It can be &lt;code&gt;void *&lt;/code&gt; or &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">该符号包含shmat（）返回的指针的类型。它可以为 &lt;code&gt;void *&lt;/code&gt; 或 &lt;code&gt;char *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="584f3ba36a4f3dda7bd8acb2eea24bb10daa748c" translate="yes" xml:space="preserve">
          <source>This symbol is defined if using the &lt;code&gt;FILE_ptr&lt;/code&gt; macro as an lvalue to increase the pointer by n has the side effect of decreasing the value of File_cnt(fp) by n.</source>
          <target state="translated">如果使用 &lt;code&gt;FILE_ptr&lt;/code&gt; 宏作为左值将指针增加n，则具有将File_cnt（fp）的值减少n的副作用，则定义此符号。</target>
        </trans-unit>
        <trans-unit id="0683919acfce603ad7685e97943788fb4e37c119" translate="yes" xml:space="preserve">
          <source>This symbol is defined if using the &lt;code&gt;FILE_ptr&lt;/code&gt; macro as an lvalue to increase the pointer by n leaves File_cnt(fp) unchanged.</source>
          <target state="translated">如果使用 &lt;code&gt;FILE_ptr&lt;/code&gt; 宏作为左值将指针增加n，而File_cnt（fp）保持不变，则定义此符号。</target>
        </trans-unit>
        <trans-unit id="93f9dcbec7fb63d67f75a0e1d4dc9ae41d2b59f2" translate="yes" xml:space="preserve">
          <source>This symbol is set to &lt;code&gt;struct direct&lt;/code&gt; or &lt;code&gt;struct dirent&lt;/code&gt; depending on whether dirent is available or not. You should use this pseudo type to portably declare your directory entries.</source>
          <target state="translated">根据是否可用 &lt;code&gt;struct dirent&lt;/code&gt; 将此符号设置为 &lt;code&gt;struct direct&lt;/code&gt; 或struct dirent。您应该使用此伪类型来可移植地声明您的目录条目。</target>
        </trans-unit>
        <trans-unit id="ac5221df55c0b6f88cbdccf1d492a80ec8b042ec" translate="yes" xml:space="preserve">
          <source>This symbol reflects the patchlevel, if available. Will usually come from the</source>
          <target state="translated">这个符号反映了补丁级别(如果有的话)。通常会来自于</target>
        </trans-unit>
        <trans-unit id="b709a76faa1011cf3f1c524bd59100484a2a8c2a" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports fpos64_t.</source>
          <target state="translated">如果C编译器支持fpos64_t,这个符号将被定义。</target>
        </trans-unit>
        <trans-unit id="343c9a95f0e1882d7b8de9c8d965312cb38ddb59" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports int64_t.</source>
          <target state="translated">如果C编译器支持int64_t,这个符号将被定义。</target>
        </trans-unit>
        <trans-unit id="9fabec6c07d2b2eb93287e97cce2db59d9d91ab9" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports off64_t.</source>
          <target state="translated">如果C编译器支持off64_t,这个符号将被定义。</target>
        </trans-unit>
        <trans-unit id="425b3d025cac3f927d48be352caec0255a6ff1f6" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports ptrdiff_t.</source>
          <target state="translated">如果C编译器支持ptrdiff_t,这个符号将被定义。</target>
        </trans-unit>
        <trans-unit id="8b08c311a150e9da2b658a2599a4ffb33ccacd56" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports socklen_t.</source>
          <target state="translated">如果C编译器支持socklen_t,这个符号将被定义。</target>
        </trans-unit>
        <trans-unit id="025aea88f0880f5a01a7cfa41a1296fe3bb5e473" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the malloc_good_size routine is available for use.</source>
          <target state="translated">如果定义了这个符号,表示malloc_good_size例程可以使用。</target>
        </trans-unit>
        <trans-unit id="8a656f9000aaa7b4a0b80166141d60895ed70146" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the malloc_size routine is available for use.</source>
          <target state="translated">如果定义了这个符号,则表示malloc_size例程可以使用。</target>
        </trans-unit>
        <trans-unit id="9f16a25b173530b121560b8b39634ea26912b006" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the system provides a prototype for the modfl() function. Otherwise, it is up to the program to supply one. C99 says it should be long double modfl(long double, long double *);</source>
          <target state="translated">如果定义了这个符号,则表示系统为modfl()函数提供了一个原型。否则,就要由程序提供一个原型。C99说应该是long double modfl(long double,long double *)。</target>
        </trans-unit>
        <trans-unit id="46fd1ea7339001ddcefcaaf1e70c3783b77303d2" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the system stores the variable argument list datatype, va_list, in a format that cannot be copied by simple assignment, so that some other means must be used when copying is required. As such systems vary in their provision (or non-provision) of copying mechanisms,</source>
          <target state="translated">如果定义了这个符号,则表示系统存储的变量参数列表数据类型va_list的格式不能通过简单的赋值来复制,因此在需要复制时必须使用其他手段。由于这种系统在提供(或不提供)复制机制方面各不相同。</target>
        </trans-unit>
        <trans-unit id="33cfc6c8458868fdba1853ad63d6a5ab248c80dd" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that we can use _NSGetExecutablePath and realpath to get a full path for the executable, and hence convert $^X to an absolute path.</source>
          <target state="translated">如果定义了这个符号,表示我们可以使用_NSGetExecutablePath和realpath来获取可执行文件的完整路径,从而将$^X转换为绝对路径。</target>
        </trans-unit>
        <trans-unit id="c755fed5c388f41a69a9c083b151ea18f5a79b60" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates to the C program that it should include &amp;lt;xlocale.h&amp;gt; to get uselocale() and its friends</source>
          <target state="translated">如果定义了此符号，则向C程序指示它应包括&amp;lt;xlocale.h&amp;gt;以获得uselocale（）及其朋友</target>
        </trans-unit>
        <trans-unit id="46cca9096a2b0dd91e445763521373111ae6cf7d" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, tells how many mantissa bits there are in double precision floating point format. Note that this is usually &lt;code&gt;DBL_MANT_DIG&lt;/code&gt; minus one, since with the standard &lt;code&gt;IEEE&lt;/code&gt; 754 formats &lt;code&gt;DBL_MANT_DIG&lt;/code&gt; includes the implicit bit which doesn't really exist.</source>
          <target state="translated">如果定义了此符号，则以双精度浮点格式告诉您有多少个尾数位。请注意，这通常是 &lt;code&gt;DBL_MANT_DIG&lt;/code&gt; 减1，因为对于标准 &lt;code&gt;IEEE&lt;/code&gt; 754格式， &lt;code&gt;DBL_MANT_DIG&lt;/code&gt; 包含不存在的隐式位。</target>
        </trans-unit>
        <trans-unit id="60cda7b3100613ca1663cb55bf36b335f38c04e0" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, tells how many mantissa bits there are in long double precision floating point format. Note that this can be &lt;code&gt;LDBL_MANT_DIG&lt;/code&gt; minus one, since &lt;code&gt;LDBL_MANT_DIG&lt;/code&gt; can include the &lt;code&gt;IEEE&lt;/code&gt; 754 implicit bit. The common x86-style 80-bit long double does not have an implicit bit.</source>
          <target state="translated">如果定义了此符号，则将以长双精度浮点格式告诉您有多少个尾数位。请注意，这可以是 &lt;code&gt;LDBL_MANT_DIG&lt;/code&gt; 减1，因为 &lt;code&gt;LDBL_MANT_DIG&lt;/code&gt; 可以包含 &lt;code&gt;IEEE&lt;/code&gt; 754隐式位。常见的x86样式的80位长双精度型没有隐式位。</target>
        </trans-unit>
        <trans-unit id="1e5579cd2141da02375bbc1afc9cdf3e216d16eb" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, tells that fflush(&lt;code&gt;NULL&lt;/code&gt; ) correctly flushes all pending stdio output without side effects. In particular, on some platforms calling fflush(&lt;code&gt;NULL&lt;/code&gt; ) *still* corrupts &lt;code&gt;STDIN&lt;/code&gt; if it is a pipe.</source>
          <target state="translated">如果定义了此符号，则表明fflush（ &lt;code&gt;NULL&lt;/code&gt; ）正确刷新了所有未处理的stdio输出，而没有副作用。特别是，在某些平台上，如果fflush（ &lt;code&gt;NULL&lt;/code&gt; ）* still * 是管道，则它仍然会破坏 &lt;code&gt;STDIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="864f27e3d5797754ededc663f882621f2b6e62f1" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, tells that fflush(&lt;code&gt;NULL&lt;/code&gt;) correctly flushes all pending stdio output without side effects. In particular, on some platforms calling fflush(&lt;code&gt;NULL&lt;/code&gt;) *still* corrupts &lt;code&gt;STDIN&lt;/code&gt; if it is a pipe.</source>
          <target state="translated">如果定义了此符号，则表明fflush（ &lt;code&gt;NULL&lt;/code&gt; ）正确刷新了所有未处理的stdio输出，而没有副作用。特别是，在某些平台上，如果fflush（ &lt;code&gt;NULL&lt;/code&gt; ）* still *是管道，则它仍然会破坏 &lt;code&gt;STDIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="345492b736fde856a18832ea228dc15b7f57e1fd" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, tells that to flush all pending stdio output one must loop through all the stdio file handles stored in an array and fflush them. Note that if fflushNULL is defined, fflushall will not even be probed for and will be left undefined.</source>
          <target state="translated">如果定义了这个符号,则说明要刷新所有待处理的stdio输出,必须循环检查所有存储在数组中的stdio文件句柄,并将其fflush。请注意,如果定义了flushNULL,那么flushall甚至不会被探测到,而是未定义。</target>
        </trans-unit>
        <trans-unit id="dcd9bfb79795353183cc954075073576d42a4a96" translate="yes" xml:space="preserve">
          <source>This syntax can be used with any class or object method:</source>
          <target state="translated">这种语法可以用于任何类或对象方法。</target>
        </trans-unit>
        <trans-unit id="361a88cbd3ef11a7c4b058ea6f65a1768cf1bf06" translate="yes" xml:space="preserve">
          <source>This syntax make the caret a special character inside a bracketed character class, but only if it is the first character of the class. So if you want the caret as one of the characters to match, either escape the caret or else don't list it first.</source>
          <target state="translated">这个语法使小括号成为一个特殊的字符,但前提是它是该类的第一个字符。因此,如果你想让小括号作为字符之一来匹配,要么转义小括号,要么不要把它列在第一位。</target>
        </trans-unit>
        <trans-unit id="cf8882c6e41ea0e436011545b6eac42846ae64e6" translate="yes" xml:space="preserve">
          <source>This syntax must be enabled with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'postderef'&lt;/code&gt; . It is experimental, and will warn by default unless &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
'experimental::postderef'&lt;/code&gt; is in effect.</source>
          <target state="translated">必须 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'postderef'&lt;/code&gt; 启用此语法。它是实验性的，除非 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::postderef'&lt;/code&gt; 有效，否则它将默认发出警告。</target>
        </trans-unit>
        <trans-unit id="2448d5ee0ab20cace7d0d694356cb8b018b6fff7" translate="yes" xml:space="preserve">
          <source>This syntax must be enabled with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'refaliasing'&lt;/code&gt; . It is experimental, and will warn by default unless &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
'experimental::refaliasing'&lt;/code&gt; is in effect.</source>
          <target state="translated">必须 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'refaliasing'&lt;/code&gt; 启用此语法。这是实验性的，并且默认情况下会发出警告，除非 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::refaliasing'&lt;/code&gt; 生效。</target>
        </trans-unit>
        <trans-unit id="287e0462bd1d909a19c1388821cda96b1374549b" translate="yes" xml:space="preserve">
          <source>This syntax must be enabled with &lt;code&gt;use feature 'refaliasing'&lt;/code&gt;. It is experimental, and will warn by default unless &lt;code&gt;no warnings 'experimental::refaliasing'&lt;/code&gt; is in effect.</source>
          <target state="translated">必须 &lt;code&gt;use feature 'refaliasing'&lt;/code&gt; 启用此语法。这是实验性的，默认情况下会发出警告，除非 &lt;code&gt;no warnings 'experimental::refaliasing'&lt;/code&gt; 生效。</target>
        </trans-unit>
        <trans-unit id="17f3dce1b8ffb69288b5e7233eedf50e51bf6d28" translate="yes" xml:space="preserve">
          <source>This table should give some indication on the relative speed of different algorithms. It is sorted by throughput based on a benchmark done with of some implementations of this API:</source>
          <target state="translated">这个表格应该可以提供一些关于不同算法的相对速度的指示。它是根据这个API的一些实现的基准,按吞吐量排序的。</target>
        </trans-unit>
        <trans-unit id="dd4da486347f5d466977ce9a1a1aa8289c5632b1" translate="yes" xml:space="preserve">
          <source>This table summarizes the mapping of the encodings set up by the &lt;code&gt;Encode::Locale&lt;/code&gt; module:</source>
          <target state="translated">下表总结了由 &lt;code&gt;Encode::Locale&lt;/code&gt; 模块设置的编码的映射：</target>
        </trans-unit>
        <trans-unit id="61e7d00a447b322e0b6281e41be210174353561f" translate="yes" xml:space="preserve">
          <source>This tag holds groups of assorted specialist opcodes that don't warrant having optags defined for them.</source>
          <target state="translated">该标签保存了一组不需要为其定义光学标签的各种专业操作码。</target>
        </trans-unit>
        <trans-unit id="4b596b3ecff7c84a2d9f652cda2f444e71a7c9fa" translate="yes" xml:space="preserve">
          <source>This tag holds opcodes related to loading modules and getting information about calling environment and args.</source>
          <target state="translated">这个标签持有与加载模块和获取调用环境和args信息有关的操作码。</target>
        </trans-unit>
        <trans-unit id="04ae009bf5132dad193828814ac61d5405735292" translate="yes" xml:space="preserve">
          <source>This tag is simply a bucket for opcodes that are unlikely to be used via a tag name but need to be tagged for completeness and documentation.</source>
          <target state="translated">这个标签只是一个操作码的桶,这些操作码不太可能通过标签名称使用,但为了完整性和文档的需要,需要对其进行标记。</target>
        </trans-unit>
        <trans-unit id="2f05cedd800de4070129a2009cffd984beb3db08" translate="yes" xml:space="preserve">
          <source>This takes a list of operator names and returns the corresponding list of operator descriptions.</source>
          <target state="translated">这需要一个操作者名称列表,并返回相应的操作者描述列表。</target>
        </trans-unit>
        <trans-unit id="7c7d2a6226efbfa63a2425be94ed3ca13dcfd261" translate="yes" xml:space="preserve">
          <source>This takes a list of strings (which are presumed to be language-tags; strings that aren't, are ignored); and after each one, this function inserts super-ordinate forms that don't already appear in the list. The original list, plus these insertions, is returned.</source>
          <target state="translated">这个函数接收一个字符串列表(假定这些字符串是语言标记;不是语言标记的字符串将被忽略);在每一个字符串之后,这个函数插入列表中还没有出现的上位形式。返回的是原始列表,加上这些插入的内容。</target>
        </trans-unit>
        <trans-unit id="13fd8ee50911015c2027466ceb16f127d689e9d2" translate="yes" xml:space="preserve">
          <source>This takes a locale name (like &quot;en&quot;, &quot;en_US&quot;, or &quot;en_US.ISO8859-1&quot;) and maps it to a language tag. If it's not mappable (as with, notably, &quot;C&quot; and &quot;POSIX&quot;), this returns empty-list in a list context, or undef in a scalar context.</source>
          <target state="translated">它接收一个locale名称(如 &quot;en&quot;、&quot;en_US &quot;或 &quot;en_US.ISO8859-1&quot;),并将其映射到一个语言标记。如果它不可映射 (如 &quot;C &quot;和 &quot;POSIX&quot;),在列表上下文中返回 empty-list,在标量上下文中返回 undef。</target>
        </trans-unit>
        <trans-unit id="bec8c5f2b922f1fda3abe6ef42f1ed85d0f41b3d" translate="yes" xml:space="preserve">
          <source>This takes an optional parameter, the name of a .packlist. If the file exists, it will be opened and the contents of the file will be read. The new() method returns a reference to a hash. This hash holds an entry for each line in the .packlist. In the case of old-style .packlists, the value associated with each key is undef. In the case of new-style .packlists, the value associated with each key is a hash containing the key=value pairs following the filename in the .packlist.</source>
          <target state="translated">它需要一个可选的参数,即.packlist的名称。如果文件存在,它将被打开并读取文件的内容。new()方法返回一个哈希的引用。这个哈希包含了.packlist中每一行的条目。在旧式.packlists的情况下,与每个键相关的值是undef。在新样式的 .packlists 中,与每个键相关联的值是一个哈希,包含 .packlist 中文件名后的 key=value 对。</target>
        </trans-unit>
        <trans-unit id="cc773e12adc99441c781ca39ab744dcff4457a5a" translate="yes" xml:space="preserve">
          <source>This takes an optional parameter, the name of the .packlist to be read. If no file is specified, the .packlist specified to new() will be read. If the .packlist does not exist, Carp::croak will be called.</source>
          <target state="translated">这个参数是一个可选的参数,即要读取的.packlist的名称。如果没有指定文件,将读取new()指定的.packlist。如果.packlist不存在,Carp::croak将被调用。</target>
        </trans-unit>
        <trans-unit id="1a1bc9e2453dd25ae8b25a05301cb1b80e688d4f" translate="yes" xml:space="preserve">
          <source>This takes an optional parameter, the name of the .packlist to be written. If no file is specified, the .packlist specified to new() will be overwritten.</source>
          <target state="translated">这需要一个可选的参数,即要写入的.packlist的名称。如果没有指定文件,那么指定给new()的.packlist将被覆盖。</target>
        </trans-unit>
        <trans-unit id="71c865c7274d3c7e5bfe698effd4f04214f7cd15" translate="yes" xml:space="preserve">
          <source>This takes name/value pairs that effect how the test is run.</source>
          <target state="translated">这需要影响测试运行方式的名称/值对。</target>
        </trans-unit>
        <trans-unit id="cc76b10f19749554379a021ff3eedaa58c818a23" translate="yes" xml:space="preserve">
          <source>This takes one mandatory parameter, the name of a module. It checks that all the files listed in the modules .packlist actually exist, and returns a list of any missing files. If an optional second argument which evaluates to true is given any missing files will be removed from the .packlist</source>
          <target state="translated">这个函数需要一个强制性的参数,即模块的名称,它检查模块.packlist中列出的所有文件是否存在,并返回一个缺少的文件列表。它检查模块.packlist中列出的所有文件是否真实存在,并返回一个缺少的文件列表。如果给定一个可选的第二个参数,该参数的值为true,则任何丢失的文件将从.packlist中删除。</target>
        </trans-unit>
        <trans-unit id="5b5d51a829067c0f74043220e1f7dc0a082fd9a1" translate="yes" xml:space="preserve">
          <source>This takes one mandatory parameter, the name of a module. It returns a list of all the directories from the package. Additional parameters are allowed. The first is one of the strings &quot;prog&quot;, &quot;doc&quot; or &quot;all&quot;, to select either just program directories, just manual directories or all directories. The remaining parameters are a list of directories. The directories returned will be restricted to those under the specified directories. This method returns only the leaf directories that contain files from the specified module.</source>
          <target state="translated">它需要一个强制性参数,即模块的名称。它返回的是包中所有目录的列表。允许使用额外的参数,第一个参数是 &quot;prog&quot;、&quot;doc &quot;或 &quot;all &quot;中的一个。第一个参数是 &quot;prog&quot;、&quot;doc &quot;或 &quot;all &quot;中的一个,用来选择仅仅是程序目录、仅仅是手册目录或所有目录。剩下的参数是一个目录列表。返回的目录将被限制在指定目录下的目录。本方法只返回包含指定模块文件的叶目录。</target>
        </trans-unit>
        <trans-unit id="d2af5c7a635840c9a764106b51edcb4ae7965f15" translate="yes" xml:space="preserve">
          <source>This takes one mandatory parameter, the name of a module. It returns a list of all the filenames from the package. To obtain a list of core perl files, use the module name 'Perl'. Additional parameters are allowed. The first is one of the strings &quot;prog&quot;, &quot;doc&quot; or &quot;all&quot;, to select either just program files, just manual files or all files. The remaining parameters are a list of directories. The filenames returned will be restricted to those under the specified directories.</source>
          <target state="translated">这个函数需要一个强制性的参数,即模块的名称。它返回一个包中所有文件名的列表。要获得核心 perl 文件的列表,请使用模块名 'Perl'。允许使用额外的参数。第一个参数是 &quot;prog&quot;、&quot;doc &quot;或 &quot;all &quot;中的一个,可以选择只选程序文件、只选手动文件或所有文件。剩下的参数是一个目录列表。返回的文件名将被限制在指定目录下的文件名。</target>
        </trans-unit>
        <trans-unit id="c87f6895af9c38d5c250f2c66fe4725760f823f0" translate="yes" xml:space="preserve">
          <source>This takes optional named parameters. Without parameters, this searches for all the installed .packlists on the system using information from &lt;code&gt;%Config::Config&lt;/code&gt; and the default module search paths &lt;code&gt;@INC&lt;/code&gt; . The packlists are read using the &lt;a href=&quot;packlist&quot;&gt;ExtUtils::Packlist&lt;/a&gt; module.</source>
          <target state="translated">这需要可选的命名参数。如果没有参数，它将使用 &lt;code&gt;%Config::Config&lt;/code&gt; 和默认模块搜索路径 &lt;code&gt;@INC&lt;/code&gt; 来搜索系统上所有已安装的.packlists 。使用&lt;a href=&quot;packlist&quot;&gt;ExtUtils :: Packlist&lt;/a&gt;模块读取包装清单。</target>
        </trans-unit>
        <trans-unit id="af5e8e4c803265793609442c474430cf073a9f84" translate="yes" xml:space="preserve">
          <source>This takes optional named parameters. Without parameters, this searches for all the installed .packlists on the system using information from &lt;code&gt;%Config::Config&lt;/code&gt; and the default module search paths &lt;code&gt;@INC&lt;/code&gt;. The packlists are read using the &lt;a href=&quot;ExtUtils::Packlist&quot;&gt;ExtUtils::Packlist&lt;/a&gt; module.</source>
          <target state="translated">这需要可选的命名参数。如果没有参数，它将使用 &lt;code&gt;%Config::Config&lt;/code&gt; 以及默认的模块搜索路径 &lt;code&gt;@INC&lt;/code&gt; 来搜索系统上所有已安装的.packlists 。使用&lt;a href=&quot;ExtUtils::Packlist&quot;&gt;ExtUtils :: Packlist&lt;/a&gt;模块读取包装清单。</target>
        </trans-unit>
        <trans-unit id="ac00ded61272ff3715863e3d3dc5ed285ce52be5" translate="yes" xml:space="preserve">
          <source>This takes the hashref from &lt;code&gt;facet_data()&lt;/code&gt; and blesses each facet into the proper &lt;code&gt;Test2::EventFacet::*&lt;/code&gt; subclass. If no class can be found for any given facet it will be passed along unchanged.</source>
          <target state="translated">这将从 &lt;code&gt;facet_data()&lt;/code&gt; 中获取hashref并将每个方面都祝福到适当的 &lt;code&gt;Test2::EventFacet::*&lt;/code&gt; 子类中。如果找不到任何给定构面的类，则将按原样传递。</target>
        </trans-unit>
        <trans-unit id="0811a32d0bc5998774816ef12efb4252ce7381da" translate="yes" xml:space="preserve">
          <source>This talk of parameters and arbitrary complexity is just another way to say that an entry in a phrasebook is what in a programming language would be called a &quot;function&quot;. Just so you don't miss it, this is the crux of this article:</source>
          <target state="translated">这些关于参数和任意复杂度的谈话只是另一种说法,即短语手册中的条目在编程语言中被称为 &quot;函数&quot;。为了不让你错过,这就是本文的核心。</target>
        </trans-unit>
        <trans-unit id="9a03ab8b368c68d278641fea23e27727f8dbba74" translate="yes" xml:space="preserve">
          <source>This target is stubbed out. Not sure why.</source>
          <target state="translated">这个目标被捅破了。不知道为什么。</target>
        </trans-unit>
        <trans-unit id="fab4c4b22d474c11e9a11868afc03c97140845f1" translate="yes" xml:space="preserve">
          <source>This technique is most useful when you have a project that uses a lot of third-party modules. You can define all your possible hints in one-place. This can even be in a sub-class of autodie. For example:</source>
          <target state="translated">当你的项目中使用了大量的第三方模块时,这种技术是最有用的。你可以在一个地方定义所有可能的提示。这甚至可以放在autodie的一个子类中。例如,你可以在一个子类中定义所有可能的提示。</target>
        </trans-unit>
        <trans-unit id="f1ca50a85da91c16a0a908f36c57ff992ef7c02c" translate="yes" xml:space="preserve">
          <source>This technique of separation of the glue part from the workhorse part has obvious tradeoffs: if you want to change a Perl interface, you need to change two places in your code. However, it removes a lot of clutter, and makes the workhorse part independent from idiosyncrasies of Perl calling convention. (In fact, there is nothing Perl-specific in the above description, a different version of &lt;b&gt;xsubpp&lt;/b&gt; might have translated this to TCL glue or Python glue as well.)</source>
          <target state="translated">这种将胶水部分与主力部分分开的技术具有明显的权衡：如果要更改Perl接口，则需要在代码中更改两个位置。但是，它消除了很多混乱，并使主力部件独立于Perl调用约定的特质。（实际上，上面的描述中没有Perl特定的内容，不同版本的&lt;b&gt;xsubpp&lt;/b&gt;可能也已将其翻译为TCL胶水或Python胶水。）</target>
        </trans-unit>
        <trans-unit id="579494abf777c1edad219e4e3e72f24bade80f1c" translate="yes" xml:space="preserve">
          <source>This technique was popular for a while (and was recommended in Damian Conway's</source>
          <target state="translated">这种技术曾流行过一段时间(在Damian Conway的</target>
        </trans-unit>
        <trans-unit id="5e8f5ce6d67f7bf4b479db2dfff968206c152d0a" translate="yes" xml:space="preserve">
          <source>This tells the compiler to use integer operations from here to the end of the enclosing BLOCK. On many machines, this doesn't matter a great deal for most computations, but on those without floating point hardware, it can make a big difference in performance.</source>
          <target state="translated">这告诉编译器,从这里到包围BLOCK的末尾都要使用整数运算。在许多机器上,这对大多数计算来说并不重要,但在那些没有浮点硬件的机器上,它可以使性能有很大的不同。</target>
        </trans-unit>
        <trans-unit id="661943b2ace4b2cbd0e7c782744a83d712cb4bd1" translate="yes" xml:space="preserve">
          <source>This tells the parser that you accept additional formatting codes, beyond just the standard ones (I B C L F S X, plus the two weird ones you don't actually see in the parse tree, Z and E). For example, to also accept codes &quot;N&quot;, &quot;R&quot;, and &quot;W&quot;:</source>
          <target state="translated">这将告诉解析器,除了标准代码(I B C L F S X,再加上两个在解析树中看不到的奇怪代码Z和E)之外,您还接受额外的格式化代码。例如,也接受代码 &quot;N&quot;、&quot;R &quot;和 &quot;W&quot;。</target>
        </trans-unit>
        <trans-unit id="5c227c573c801b67ab844d5a781ca2d861b5ad11" translate="yes" xml:space="preserve">
          <source>This test harness is the same as &lt;a href=&quot;../harness&quot;&gt;TAP::Harness&lt;/a&gt;, but test results are output in color. Passing tests are printed in green. Failing tests are in red. Skipped tests are blue on a white background and TODO tests are printed in white.</source>
          <target state="translated">该测试工具与&lt;a href=&quot;../harness&quot;&gt;TAP :: Harness&lt;/a&gt;相同，但是测试结果以彩色输出。通过测试以绿色打印。测试失败为红色。跳过的测试在白色背景上为蓝色，TODO测试以白色打印。</target>
        </trans-unit>
        <trans-unit id="5aeeba01de86baa7b8993aef4f94514bdbb7f537" translate="yes" xml:space="preserve">
          <source>This test harness is the same as &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt;, but test results are output in color. Passing tests are printed in green. Failing tests are in red. Skipped tests are blue on a white background and TODO tests are printed in white.</source>
          <target state="translated">该测试工具与&lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness&lt;/a&gt;相同，但是测试结果以彩色输出。通过测试以绿色打印。测试失败为红色。跳过的测试在白色背景上为蓝色，TODO测试以白色打印。</target>
        </trans-unit>
        <trans-unit id="56c5da5399251bb5e1db8f624c5839bd6c16417b" translate="yes" xml:space="preserve">
          <source>This test not coming out ok could indicate that you have in fact installed a bLuRfle.pm module or that the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot; require \&quot;$module_name.pm\&quot;; &quot;&lt;/code&gt; test may give misleading results with your installation of perl. If yours is the latter case then please let the author know.</source>
          <target state="translated">该测试无法正常进行，这可能表明您实际上已经安装了bLuRfle.pm模块，或者 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot; require \&quot;$module_name.pm\&quot;; &quot;&lt;/code&gt; 测试可能会给安装Perl带来误导的结果。如果您属于后一种情况，请告知作者。</target>
        </trans-unit>
        <trans-unit id="f1a47c3ed2c720af6cbbff7d8f1fba90981d6cf7" translate="yes" xml:space="preserve">
          <source>This test not coming out ok could indicate that you have in fact installed a bLuRfle.pm module or that the &lt;code&gt;eval &quot; require \&quot;$module_name.pm\&quot;; &quot;&lt;/code&gt; test may give misleading results with your installation of perl. If yours is the latter case then please let the author know.</source>
          <target state="translated">该测试无法正常进行，这可能表明您实际上已经安装了bLuRfle.pm模块，或者 &lt;code&gt;eval &quot; require \&quot;$module_name.pm\&quot;; &quot;&lt;/code&gt; 测试可能会给安装Perl带来误导的结果。如果您属于后一种情况，请告知作者。</target>
        </trans-unit>
        <trans-unit id="d7779eb97d1704eb5b38f4af625c19d04da87929" translate="yes" xml:space="preserve">
          <source>This third program fails to run because &lt;code&gt;$&amp;amp;&lt;/code&gt; is tainted: it is the result of a match involving &lt;code&gt;\w&lt;/code&gt; while &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect.</source>
          <target state="translated">由于 &lt;code&gt;$&amp;amp;&lt;/code&gt; 被污染，该第三个程序无法运行：这是在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境有效时涉及 &lt;code&gt;\w&lt;/code&gt; 的匹配的结果。</target>
        </trans-unit>
        <trans-unit id="d68ad58afc351b6be0d95c3d8369561b57239182" translate="yes" xml:space="preserve">
          <source>This third program fails to run because &lt;code&gt;$&amp;amp;&lt;/code&gt; is tainted: it is the result of a match involving &lt;code&gt;\w&lt;/code&gt; while &lt;code&gt;use locale&lt;/code&gt; is in effect.</source>
          <target state="translated">由于 &lt;code&gt;$&amp;amp;&lt;/code&gt; 被污染，该第三个程序无法运行：这是在 &lt;code&gt;use locale&lt;/code&gt; 情况下，涉及 &lt;code&gt;\w&lt;/code&gt; 的匹配的结果。</target>
        </trans-unit>
        <trans-unit id="1dae3d33db186460fb270be827c017862ed6f4c9" translate="yes" xml:space="preserve">
          <source>This thread can change the locale all it wants and it won't affect any other thread, except any that also have been switched to the global locale. This means that a multi-threaded application can have a single thread using an alien library without a problem; but no more than a single thread can be so-occupied. Bad results likely will happen.</source>
          <target state="translated">这个线程可以随意更改locale,而且不会影响任何其他线程,除了同样已经切换到全局locale的线程。这意味着,一个多线程的应用程序可以让一个线程使用一个外来库,而不会有问题;但不能超过一个线程被如此占用。很可能会发生不好的结果。</target>
        </trans-unit>
        <trans-unit id="a3af2bc97cd9f37316fc3da9caf4914a2a7462bf" translate="yes" xml:space="preserve">
          <source>This threshold can be changed from 100, by recompiling the</source>
          <target state="translated">这个阈值可以从100开始改变,通过重新编译的方式。</target>
        </trans-unit>
        <trans-unit id="e43eef0f764abc7110894418223db6c40d531f70" translate="yes" xml:space="preserve">
          <source>This throws an exception at the frame (filename and line number where errors should be reported).</source>
          <target state="translated">这将在框架处抛出一个异常(文件名和应报告错误的行号)。</target>
        </trans-unit>
        <trans-unit id="2a47e3515c81e527144a0c9b60fab0d504885832" translate="yes" xml:space="preserve">
          <source>This tie class has chosen to return an error rather than raising an exception if its constructor should fail. While this is how dbmopen() works, other classes may well not wish to be so forgiving. It checks the global variable &lt;code&gt;$^W&lt;/code&gt; to see whether to emit a bit of noise anyway.</source>
          <target state="translated">如果其构造函数应该失败，则该tie类选择返回错误而不是引发异常。尽管dbmopen（）是这样工作的，但其他类可能不希望如此宽容。它检查全局变量 &lt;code&gt;$^W&lt;/code&gt; 看看是否仍然发出一点噪声。</target>
        </trans-unit>
        <trans-unit id="65215d2823f33c6578d2c1ee584a26f404ed972a" translate="yes" xml:space="preserve">
          <source>This time only two filters have been used -- we only need to manipulate the contents of the key, so it wasn't necessary to install any value filters.</source>
          <target state="translated">这次只使用了两个过滤器--我们只需要操作键的内容,所以没有必要安装任何值过滤器。</target>
        </trans-unit>
        <trans-unit id="ce475e5b88de267f8c35364dcce4ac0349ad1b9f" translate="yes" xml:space="preserve">
          <source>This time only two filters have been used; we only need to manipulate the contents of the key, so it wasn't necessary to install any value filters.</source>
          <target state="translated">这次只使用了两个过滤器,我们只需要操作键的内容,所以没有必要安装任何值过滤器。</target>
        </trans-unit>
        <trans-unit id="33080a774d1683a847960294bf99870a610d6d24" translate="yes" xml:space="preserve">
          <source>This time we get the right answer:</source>
          <target state="translated">这一次我们得到了正确的答案。</target>
        </trans-unit>
        <trans-unit id="de132ff4c4de4a8dae8876bdea9d65e3845d2e34" translate="yes" xml:space="preserve">
          <source>This time we have got all the key/value pairs, including the multiple values associated with the key &lt;code&gt;Wall&lt;/code&gt; .</source>
          <target state="translated">这次，我们获得了所有键/值对，包括与键 &lt;code&gt;Wall&lt;/code&gt; 相关联的多个值。</target>
        </trans-unit>
        <trans-unit id="dc46887a2d3ce4b75ca14523b77c1875e5b5f923" translate="yes" xml:space="preserve">
          <source>This time we have got all the key/value pairs, including the multiple values associated with the key &lt;code&gt;Wall&lt;/code&gt;.</source>
          <target state="translated">这次，我们获得了所有键/值对，包括与键 &lt;code&gt;Wall&lt;/code&gt; 相关联的多个值。</target>
        </trans-unit>
        <trans-unit id="549daec07a3febc80783db85efb5cb76a1300cf5" translate="yes" xml:space="preserve">
          <source>This time we've decided to blow up (raise an exception) if the renice fails--there's no place for us to return an error otherwise, and it's probably the right thing to do.</source>
          <target state="translated">这次我们决定,如果renice失败,就炸掉(引发异常)--否则没有地方让我们返回错误,这可能是正确的做法。</target>
        </trans-unit>
        <trans-unit id="e8220bb1a44581d2e3ca1f66709b3d28e4dca5ce" translate="yes" xml:space="preserve">
          <source>This time whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it will execute the Perl subroutine &lt;code&gt;joe&lt;/code&gt; (assuming it exists) rather than &lt;code&gt;fred&lt;/code&gt; as was originally requested in the call to &lt;code&gt;SaveSub1&lt;/code&gt; .</source>
          <target state="translated">每次 &lt;code&gt;CallSavedSub1&lt;/code&gt; 时，它将执行Perl子例程 &lt;code&gt;joe&lt;/code&gt; （假设它存在），而不是像最初对 &lt;code&gt;SaveSub1&lt;/code&gt; 的调用中所要求的那样执行 &lt;code&gt;fred&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9585799a0bb025c0fc2a5fb468e2e0510621cfe4" translate="yes" xml:space="preserve">
          <source>This time whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it will execute the Perl subroutine &lt;code&gt;joe&lt;/code&gt; (assuming it exists) rather than &lt;code&gt;fred&lt;/code&gt; as was originally requested in the call to &lt;code&gt;SaveSub1&lt;/code&gt;.</source>
          <target state="translated">每次 &lt;code&gt;CallSavedSub1&lt;/code&gt; 时，它将执行Perl子例程 &lt;code&gt;joe&lt;/code&gt; （假定它存在），而不是像最初对 &lt;code&gt;SaveSub1&lt;/code&gt; 的调用中所要求的那样执行 &lt;code&gt;fred&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f97f664a05e05836532f171c31abc8294dc4fa2e" translate="yes" xml:space="preserve">
          <source>This timeout prevents CPAN from hanging when trying to parse a pathologically coded $VERSION from a module.</source>
          <target state="translated">当CPAN试图从一个模块中解析一个病理编码的$VERSION时,这个超时可以防止CPAN挂起。</target>
        </trans-unit>
        <trans-unit id="818cb77ceebe03d7349ba167c3cce5e948a3bb9b" translate="yes" xml:space="preserve">
          <source>This tip has been brought to you by Nick Ing-Simmons and Stas Bekman.</source>
          <target state="translated">这个提示是由Nick Ing-Simmons和Stas Bekman带来的。</target>
        </trans-unit>
        <trans-unit id="d27a6342f3cf97c393debaf5d2880083dadfb79d" translate="yes" xml:space="preserve">
          <source>This toggle lets you turn off the abort logic for the hub. When this is toggled to true &lt;b&gt;you&lt;/b&gt; are responsible for ensuring no additional events are generated.</source>
          <target state="translated">此切换使您可以关闭集线器的中止逻辑。将此选项设置为true时，&lt;b&gt;您&lt;/b&gt;有责任确保不会生成其他事件。</target>
        </trans-unit>
        <trans-unit id="1ad35df16ed4d238965d8000164af0c76d6be400" translate="yes" xml:space="preserve">
          <source>This token is only available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or the &quot;current_sub&quot; feature. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">该令牌仅在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 或&amp;ldquo; current_sub&amp;rdquo;功能下可用。请参阅&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35716269721e35aed3ed9931d09baf8957f4a7d8" translate="yes" xml:space="preserve">
          <source>This token is only available under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or the &quot;current_sub&quot; feature. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">该令牌仅在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 或&amp;ldquo; current_sub&amp;rdquo;功能下可用。请参阅&lt;a href=&quot;../feature&quot;&gt;功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8782e676913565f7b95bd8b849e9d4513a4cab5" translate="yes" xml:space="preserve">
          <source>This token is only available under &lt;code&gt;use v5.16&lt;/code&gt; or the &lt;a href=&quot;feature#The-%27current_sub%27-feature&quot;&gt;&lt;code&gt;&quot;current_sub&quot;&lt;/code&gt; feature&lt;/a&gt;. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">该令牌仅在 &lt;code&gt;use v5.16&lt;/code&gt; 或&lt;a href=&quot;feature#The-%27current_sub%27-feature&quot;&gt; &lt;code&gt;&quot;current_sub&quot;&lt;/code&gt; 功能&lt;/a&gt;下可用。请参阅&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a442863544084141507fc6b9cc253372f4528af" translate="yes" xml:space="preserve">
          <source>This token tells &lt;b&gt;sigtrap&lt;/b&gt; to install handlers for all subsequently listed signals. This is the default behavior.</source>
          <target state="translated">该令牌告诉&lt;b&gt;sigtrap&lt;/b&gt;为随后列出的所有信号安装处理程序。这是默认行为。</target>
        </trans-unit>
        <trans-unit id="563416938874462a6a3a7e213b018a4bbf3569b4" translate="yes" xml:space="preserve">
          <source>This token tells &lt;b&gt;sigtrap&lt;/b&gt; to install handlers only for subsequently listed signals which aren't already trapped or ignored.</source>
          <target state="translated">此令牌告诉&lt;b&gt;sigtrap&lt;/b&gt;仅为随后列出的尚未被捕获或忽略的信号安装处理程序。</target>
        </trans-unit>
        <trans-unit id="0c3e36d66e90a38e2c172eb5380aff092f3d8aff" translate="yes" xml:space="preserve">
          <source>This tool is most useful when you want to return the value you get from calling a function that needs to see the current context:</source>
          <target state="translated">当你想返回从调用一个需要查看当前上下文的函数中得到的值时,这个工具是最有用的。</target>
        </trans-unit>
        <trans-unit id="dbef2365e83f0b66bb2b5afb7a58a64a398a46f8" translate="yes" xml:space="preserve">
          <source>This tool isn't appropriate for reporting bugs in any version prior to Perl 5.0.</source>
          <target state="translated">这个工具不适合用于报告Perl 5.0之前任何版本的错误。</target>
        </trans-unit>
        <trans-unit id="5b1f48f2009eaba595386dfcdaf2125e0a97a308" translate="yes" xml:space="preserve">
          <source>This tool will hide a context for the provided block of code. This means any tools run inside the block will get a completely new context if they acquire one. The new context will be inherited by tools nested below the one that acquired it.</source>
          <target state="translated">这个工具将隐藏所提供的代码块的上下文。这意味着任何在该代码块中运行的工具,如果它们获得了一个全新的上下文,将获得一个全新的上下文。新的上下文将被嵌套在获得该上下文的工具下面的工具所继承。</target>
        </trans-unit>
        <trans-unit id="88cd36d63ba450353c54dc7196ff92a040ad99b2" translate="yes" xml:space="preserve">
          <source>This translates as &quot;set &lt;code&gt;TARG&lt;/code&gt; to 10, push a pointer to &lt;code&gt;TARG&lt;/code&gt; onto the stack; set &lt;code&gt;TARG&lt;/code&gt; to 20, push a pointer to &lt;code&gt;TARG&lt;/code&gt; onto the stack&quot;. At the end of the operation, the stack does not contain the values 10 and 20, but actually contains two pointers to &lt;code&gt;TARG&lt;/code&gt; , which we have set to 20.</source>
          <target state="translated">这表示为&amp;ldquo;将 &lt;code&gt;TARG&lt;/code&gt; 设置为10，将指向 &lt;code&gt;TARG&lt;/code&gt; 的指针推到堆栈上；将 &lt;code&gt;TARG&lt;/code&gt; 设置为20，将指向 &lt;code&gt;TARG&lt;/code&gt; 的指针推到堆栈上&amp;rdquo;。在操作结束时，堆栈不包含值10和20，但实际上包含指向 &lt;code&gt;TARG&lt;/code&gt; 的两个指针，我们已将其设置为20。</target>
        </trans-unit>
        <trans-unit id="b327555f1c252fbe229268edcab000a9e602b1a9" translate="yes" xml:space="preserve">
          <source>This translates as &quot;set &lt;code&gt;TARG&lt;/code&gt; to 10, push a pointer to &lt;code&gt;TARG&lt;/code&gt; onto the stack; set &lt;code&gt;TARG&lt;/code&gt; to 20, push a pointer to &lt;code&gt;TARG&lt;/code&gt; onto the stack&quot;. At the end of the operation, the stack does not contain the values 10 and 20, but actually contains two pointers to &lt;code&gt;TARG&lt;/code&gt;, which we have set to 20.</source>
          <target state="translated">这表示为&amp;ldquo;将 &lt;code&gt;TARG&lt;/code&gt; 设置为10，将指向 &lt;code&gt;TARG&lt;/code&gt; 的指针推到堆栈上；将 &lt;code&gt;TARG&lt;/code&gt; 设置为20，将指向 &lt;code&gt;TARG&lt;/code&gt; 的指针推到堆栈上&amp;rdquo;。在操作结束时，堆栈不包含值10和20，但实际上包含两个指向 &lt;code&gt;TARG&lt;/code&gt; 的指针，我们已将其设置为20。</target>
        </trans-unit>
        <trans-unit id="ba94eb90171beedcd9bec6456a8694f27844f356" translate="yes" xml:space="preserve">
          <source>This transport contacts a remote SMTP server over TCP. It optionally uses SSL and can authenticate to the server via SASL.</source>
          <target state="translated">该传输通过TCP与远程SMTP服务器联系。它可以选择使用SSL,并可以通过SASL对服务器进行验证。</target>
        </trans-unit>
        <trans-unit id="e40f9d55c5ee498252f4f99087dcea386954252b" translate="yes" xml:space="preserve">
          <source>This transport contacts a remote SMTP server over TCP. It optionally uses TLS or SSL and can authenticate to the server via SASL.</source>
          <target state="translated">该传输通过TCP与远程SMTP服务器联系。它可以选择使用TLS或SSL,并可以通过SASL对服务器进行验证。</target>
        </trans-unit>
        <trans-unit id="c5f84e699be8b82423bdf0c8efc71c8b6cffc002" translate="yes" xml:space="preserve">
          <source>This tree has 5 nodes (one per &lt;code&gt;TYPE&lt;/code&gt; specifier), only 3 of them are not optimized away (one per number in the left column). The immediate children of the given node correspond to &lt;code&gt;{}&lt;/code&gt; pairs on the same level of indentation, thus this listing corresponds to the tree:</source>
          <target state="translated">该树有5个节点（每个 &lt;code&gt;TYPE&lt;/code&gt; 说明符一个），其中只有3个尚未优化（左侧列中每个数字一个）。给定节点的直接子级对应于相同缩进级别上的 &lt;code&gt;{}&lt;/code&gt; 对，因此此清单对应于树：</target>
        </trans-unit>
        <trans-unit id="10bdb23da270b66c79801ca69744614d31056771" translate="yes" xml:space="preserve">
          <source>This tries loading classes based on the language-tags you give (like &lt;code&gt;(&quot;en-US&quot;, &quot;sk&quot;, &quot;kon&quot;, &quot;es-MX&quot;, &quot;ja&quot;, &quot;i-klingon&quot;)&lt;/code&gt; , and for the first class that succeeds, returns YourProjClass::</source>
          <target state="translated">这会尝试根据您提供的语言标签（例如 &lt;code&gt;(&quot;en-US&quot;, &quot;sk&quot;, &quot;kon&quot;, &quot;es-MX&quot;, &quot;ja&quot;, &quot;i-klingon&quot;)&lt;/code&gt; ，成功的类，返回YourProjClass ::</target>
        </trans-unit>
        <trans-unit id="babb439fd1f2025fd1dc37240e930742af072a8e" translate="yes" xml:space="preserve">
          <source>This tries loading classes based on the language-tags you give (like &lt;code&gt;(&quot;en-US&quot;, &quot;sk&quot;, &quot;kon&quot;, &quot;es-MX&quot;, &quot;ja&quot;, &quot;i-klingon&quot;)&lt;/code&gt;, and for the first class that succeeds, returns YourProjClass::</source>
          <target state="translated">这会尝试根据您提供的语言标签（例如 &lt;code&gt;(&quot;en-US&quot;, &quot;sk&quot;, &quot;kon&quot;, &quot;es-MX&quot;, &quot;ja&quot;, &quot;i-klingon&quot;)&lt;/code&gt; ，成功的类，返回YourProjClass ::</target>
        </trans-unit>
        <trans-unit id="2350736fbbdb09c3e03af560458218f7c39a0887" translate="yes" xml:space="preserve">
          <source>This tries to get the title string out of $parser, by getting some tokens, and scanning them for the title, and then ungetting them so that you can process the token-stream from the beginning.</source>
          <target state="translated">这将尝试从$parser中获取标题字符串,通过获取一些tokens,并扫描它们以获取标题,然后解除它们,这样你就可以从头开始处理token-stream。</target>
        </trans-unit>
        <trans-unit id="a7a0a5100eb7d660c79e344156a06e5739ae3e99" translate="yes" xml:space="preserve">
          <source>This turns</source>
          <target state="translated">这使</target>
        </trans-unit>
        <trans-unit id="2c43b29369b0643df2b475c636f7ba4a7760104c" translate="yes" xml:space="preserve">
          <source>This tutorial assumes that the make program that Perl is configured to use is called &lt;code&gt;make&lt;/code&gt; . Instead of running &quot;make&quot; in the examples that follow, you may have to substitute whatever make program Perl has been configured to use. Running &lt;b&gt;perl -V:make&lt;/b&gt; should tell you what it is.</source>
          <target state="translated">本教程假定Perl配置为使用的make程序称为 &lt;code&gt;make&lt;/code&gt; 。您可能必须替换配置为使用Perl的任何make程序，而不是在下面的示例中运行&amp;ldquo; make&amp;rdquo;。运行&lt;b&gt;perl -V：make&lt;/b&gt;应该告诉您它是什么。</target>
        </trans-unit>
        <trans-unit id="99b5d150876f05176f523c02a4521b0203e2d731" translate="yes" xml:space="preserve">
          <source>This tutorial assumes that the make program that Perl is configured to use is called &lt;code&gt;make&lt;/code&gt;. Instead of running &quot;make&quot; in the examples that follow, you may have to substitute whatever make program Perl has been configured to use. Running &lt;b&gt;perl -V:make&lt;/b&gt; should tell you what it is.</source>
          <target state="translated">本教程假定将Perl配置为使用的make程序称为 &lt;code&gt;make&lt;/code&gt; 。您可能必须替换配置为使用Perl的任何make程序，而不是在下面的示例中运行&amp;ldquo; make&amp;rdquo;。运行&lt;b&gt;perl -V：make&lt;/b&gt;应该告诉您它是什么。</target>
        </trans-unit>
        <trans-unit id="8c02c1e1c4554cfc38ab4519576c46376d729f42" translate="yes" xml:space="preserve">
          <source>This tutorial can still be used on such a system. The XSUB build mechanism will check the system and build a dynamically-loadable library if possible, or else a static library and then, optionally, a new statically-linked executable with that static library linked in.</source>
          <target state="translated">本教程仍然可以在这样的系统上使用。XSUB的构建机制会检查系统,如果可能的话,会构建一个可动态加载的库,否则就会构建一个静态库,然后,再选择性地构建一个新的静态链接的可执行文件,并将该静态库链接进去。</target>
        </trans-unit>
        <trans-unit id="042a6a29ffea342487866bd18b2ff67e8550a4e6" translate="yes" xml:space="preserve">
          <source>This tutorial describes the use of Perl interpreter threads (sometimes referred to as</source>
          <target state="translated">本教程介绍了Perl解释器线程(有时被称为 &quot;线程&quot;)的使用。</target>
        </trans-unit>
        <trans-unit id="584c62ddbbc858e85333edcc1d7b6494d833b45b" translate="yes" xml:space="preserve">
          <source>This tutorial flattens the learning curve by discussing regular expression concepts, along with their notation, one at a time and with many examples. The first part of the tutorial will progress from the simplest word searches to the basic regular expression concepts. If you master the first part, you will have all the tools needed to solve about 98% of your needs. The second part of the tutorial is for those comfortable with the basics and hungry for more power tools. It discusses the more advanced regular expression operators and introduces the latest cutting-edge innovations.</source>
          <target state="translated">本教程通过逐一讨论正则表达式的概念以及它们的符号,并结合许多实例,使学习曲线变得平坦。本教程的第一部分将从最简单的单词搜索发展到基本的正则表达式概念。如果你掌握了第一部分,你将拥有解决大约98%需求的所有工具。教程的第二部分是为那些对基础知识感到舒适并渴望获得更多强大工具的人准备的。它讨论了更高级的正则表达式运算符,并介绍了最新的前沿创新。</target>
        </trans-unit>
        <trans-unit id="09418d1e9dc1ccd649181b2ae1d0e9cc30227030" translate="yes" xml:space="preserve">
          <source>This tutorial speaks in rather absolute terms, and provides only a limited view of the wealth of character string related features that Perl has to offer. For most projects, this information will probably suffice.</source>
          <target state="translated">本教程以相当绝对的术语来说明,并且只提供了Perl所提供的与字符字符串相关的丰富功能的有限视图。对于大多数项目来说,这些信息可能已经足够了。</target>
        </trans-unit>
        <trans-unit id="5a1babab3f5740242709a97dfef0170b83cfd116" translate="yes" xml:space="preserve">
          <source>This tutorial starts with very simple examples and becomes more complex, with each new example adding new features. Certain concepts may not be completely explained until later in the tutorial in order to slowly ease the reader into building extensions.</source>
          <target state="translated">本教程从非常简单的例子开始,然后变得越来越复杂,每个新的例子都会增加新的功能。某些概念可能要到教程的后面才会完全解释清楚,以便让读者慢慢地了解如何构建扩展。</target>
        </trans-unit>
        <trans-unit id="513743e90a808d724cf722e256c18c6a577aed36" translate="yes" xml:space="preserve">
          <source>This tutorial was written from a Unix point of view. Where I know them to be otherwise different for other platforms (e.g. Win32), I will list them. If you find something that was missed, please let me know.</source>
          <target state="translated">本教程是从Unix的角度来写的。如果我知道它们与其他平台(如Win32)不同,我将列出它们。如果你发现有遗漏的地方,请告诉我。</target>
        </trans-unit>
        <trans-unit id="2d3bc7e20dd6d03170372006d4bcd471be2b1a05" translate="yes" xml:space="preserve">
          <source>This tutorial will educate the reader on the steps involved in creating a Perl extension. The reader is assumed to have access to &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;, &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; and &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">本教程将向读者介绍创建Perl扩展所涉及的步骤。假定读者可以访问&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;，&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;和&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="73d6133ba18859a5eaedd64f01ef459aa33a4f61" translate="yes" xml:space="preserve">
          <source>This ucfirst form of #var generates a tag-value form of itself for display; it converts '#Var' into a 'Var =&amp;gt; #var' style, which is then handled as described above. (Imp-note: #Vars cannot be used for conditional-fills, because the =&amp;gt; #var transform is done after the check for #Var's value).</source>
          <target state="translated">#var的第一种形式生成其自身的标签值形式以供显示；它将&amp;ldquo; #Var&amp;rdquo;转换为&amp;ldquo; Var =&amp;gt; #var&amp;rdquo;样式，然后按上述说明进行处理。（提示：#Vars不能用于条件填充，因为=&amp;gt; #var变换是在检查#Var的值之后完成的）。</target>
        </trans-unit>
        <trans-unit id="e1c48ccdb02bacfa9c7db277adb42c2586c3c859" translate="yes" xml:space="preserve">
          <source>This unloading is usually necessary when embedding a shared-object perl (e.g. one configured with -Duseshrplib) within a larger application, and the perl interpreter is created and destroyed several times within the lifetime of the application. In this case it is possible that the system dynamic linker will unload and then subsequently reload the shared libperl without relocating any references to it from any files DynaLoaded by the previous incarnation of the interpreter. As a result, any shared objects opened by DynaLoader may point to a now invalid 'ghost' of the libperl shared object, causing apparently random memory corruption and crashes. This behaviour is most commonly seen when using Apache and mod_perl built with the APXS mechanism.</source>
          <target state="translated">这种卸载通常是必要的,当把一个共享对象perl(例如用-Duseshrplib配置的)嵌入到一个较大的应用程序中,并且perl解释器在应用程序的生命周期内被创建和销毁了好几次。在这种情况下,系统动态链接器有可能会卸载,然后再重新加载共享的libperl,而不会从解释器的前一个化身DynaLoaded的任何文件中重新定位对它的任何引用。因此,任何由DynaLoader打开的共享对象可能会指向一个现在无效的libperl共享对象的 &quot;幽灵&quot;,导致明显的随机内存损坏和崩溃。这种行为最常见于使用APXS机制构建的Apache和mod_perl。</target>
        </trans-unit>
        <trans-unit id="1b13f3deb5370e5675a9d76c565d42ae5d602f71" translate="yes" xml:space="preserve">
          <source>This usage is deprecated, because the behavior is likely to change in a future version of Perl.</source>
          <target state="translated">这个用法已经被废弃了,因为在未来的Perl版本中,这种行为可能会改变。</target>
        </trans-unit>
        <trans-unit id="f8cc0202ec780bce218b4e5dcccd13c92cdafc61" translate="yes" xml:space="preserve">
          <source>This usage was deprecated and as of Perl 5.32 is no longer allowed.</source>
          <target state="translated">这个用法已经被废弃,并且从Perl 5.32开始不再允许使用。</target>
        </trans-unit>
        <trans-unit id="f8628227b2034eb7bb5d1a38319f1096e92570eb" translate="yes" xml:space="preserve">
          <source>This usage was deprecated, and as of Perl 5.32 is no longer allowed, making it possible to change the behavior in the future.</source>
          <target state="translated">这种用法已经被废弃,从Perl 5.32开始,不再允许使用这种用法,这使得将来可以改变行为。</target>
        </trans-unit>
        <trans-unit id="f2bf7571677624aefcaac6c0acb5fa38635561cd" translate="yes" xml:space="preserve">
          <source>This use of &lt;code&gt;my()&lt;/code&gt; in a false conditional has been deprecated since Perl 5.10, and it will become a fatal error in Perl 5.30.</source>
          <target state="translated">自Perl 5.10起已不建议在错误条件中使用 &lt;code&gt;my()&lt;/code&gt; ，它将在Perl 5.30中成为致命错误。</target>
        </trans-unit>
        <trans-unit id="dbb7ee3adb793d7785e44f4cd1c475bc562072ff" translate="yes" xml:space="preserve">
          <source>This use of &lt;code&gt;my()&lt;/code&gt; in a false conditional was deprecated beginning in Perl 5.10 and became a fatal error in Perl 5.30.</source>
          <target state="translated">这种利用 &lt;code&gt;my()&lt;/code&gt; 在一个虚假的条件是在Perl 5.10废弃的开始，成为了一个致命的错误在Perl 5.30。</target>
        </trans-unit>
        <trans-unit id="0fa749e21deac96525cb24d3358da4f7fb5f0d24" translate="yes" xml:space="preserve">
          <source>This use of my() in false conditional is no longer allowed</source>
          <target state="translated">不再允许在虚假条件下使用my()。</target>
        </trans-unit>
        <trans-unit id="d8b6fb62901deb9e84ba258e77b4c4979b396131" translate="yes" xml:space="preserve">
          <source>This used to provide support for the old 5.005 threading module. It now does nothing.</source>
          <target state="translated">这曾经为旧的5.005线程模块提供支持。现在它什么也不做。</target>
        </trans-unit>
        <trans-unit id="ad74ce7c330e222ac3a23c23df9097ca9cc782c1" translate="yes" xml:space="preserve">
          <source>This uses &lt;code&gt;[...]&lt;/code&gt; notation to create a new anonymous array, and &lt;code&gt;$aref2&lt;/code&gt; is assigned a reference to the new array. The new array is initialized with the contents of the array referred to by &lt;code&gt;$aref1&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;[...]&lt;/code&gt; 这将使用符号创建一个新的匿名数组，并 &lt;code&gt;$aref2&lt;/code&gt; 分配一个对该新数组的引用。新数组使用 &lt;code&gt;$aref1&lt;/code&gt; 引用的数组的内容初始化。</target>
        </trans-unit>
        <trans-unit id="f780e61f5be8b67d8a73b7a70cd2de66ca725d92" translate="yes" xml:space="preserve">
          <source>This uses &lt;code&gt;[...]&lt;/code&gt; notation to create a new anonymous array, and &lt;code&gt;$aref2&lt;/code&gt; is assigned a reference to the new array. The new array is initialized with the contents of the array referred to by &lt;code&gt;$aref1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[...]&lt;/code&gt; 这将使用符号创建一个新的匿名数组，并 &lt;code&gt;$aref2&lt;/code&gt; 分配一个对新数组的引用。daccess-ods.un.org daccess-ods.un.org 新数组用 &lt;code&gt;$aref1&lt;/code&gt; 引用的数组的内容初始化。</target>
        </trans-unit>
        <trans-unit id="0ec25d0bdb752659175b1040a999aeb2b6d490b8" translate="yes" xml:space="preserve">
          <source>This uses a comment character so that we can distinguish a &lt;code&gt;set&lt;/code&gt; value (from a previous</source>
          <target state="translated">它使用注释字符，以便我们可以区分 &lt;code&gt;set&lt;/code&gt; 值（与上一个</target>
        </trans-unit>
        <trans-unit id="cc1cad67a921e3eb4640eba7ead1b7740937eea5" translate="yes" xml:space="preserve">
          <source>This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">它使用文件描述符，例如通过调用 &lt;code&gt;POSIX::open&lt;/code&gt; 获得的文件描述符。</target>
        </trans-unit>
        <trans-unit id="ef0715f911bf2d7dde414c04ee4f2d77679374e6" translate="yes" xml:space="preserve">
          <source>This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt;.</source>
          <target state="translated">它使用文件描述符，例如通过调用 &lt;code&gt;POSIX::open&lt;/code&gt; 获得的文件描述符。</target>
        </trans-unit>
        <trans-unit id="eb8309f8b6f133836961834b1a77c15524062381" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;LIB$FID_TO_NAME&lt;/code&gt; run-time library call to find the name of the primary link to a file, and returns the filename in VMS format. This function is not available on non-VMS systems.</source>
          <target state="translated">这使用 &lt;code&gt;LIB$FID_TO_NAME&lt;/code&gt; 运行时库调用来查找文件的主链接的名称，并以VMS格式返回文件名。此功能在非VMS系统上不可用。</target>
        </trans-unit>
        <trans-unit id="1c7665ba2d9d5783e7fcf462d2624ff87c082afc" translate="yes" xml:space="preserve">
          <source>This uses the git protocol (port 9418).</source>
          <target state="translated">这使用了git协议(9418端口)。</target>
        </trans-unit>
        <trans-unit id="4f46aaaf1565e8957012263096fadaa9a048c4d5" translate="yes" xml:space="preserve">
          <source>This utility allows you to apply pattern matching to &lt;b&gt;the contents&lt;/b&gt; of files contained in a tar archive. You might use this to identify all files in an archive which contain lines matching the specified pattern and either print out the pathnames or extract the files.</source>
          <target state="translated">此实用程序允许您将模式匹配应用于tar归档文件中包含的文件&lt;b&gt;的内容&lt;/b&gt;。您可以使用它来识别归档文件中的所有文件，这些文件包含与指定模式匹配的行，并打印出路径名或提取文件。</target>
        </trans-unit>
        <trans-unit id="5a9ad1aba7c9a639b483b1f8f929290363dd11bd" translate="yes" xml:space="preserve">
          <source>This utility is designed to write a Makefile for an extension module from a Makefile.PL. It is based on the Makefile.SH model provided by Andy Dougherty and the perl5-porters.</source>
          <target state="translated">这个工具是用来为扩展模块从Makefile.PL中写一个Makefile。它是基于Andy Dougherty和perl5-porters提供的Makefile.SH模型。</target>
        </trans-unit>
        <trans-unit id="b24b7df29646f7c014772e5059f3068df5bbacbd" translate="yes" xml:space="preserve">
          <source>This utility takes a list of libraries in the form &lt;code&gt;-llib1 -llib2
-llib3&lt;/code&gt; and returns lines suitable for inclusion in an extension Makefile. Extra library paths may be included with the form &lt;code&gt;-L/another/path&lt;/code&gt; this will affect the searches for all subsequent libraries.</source>
          <target state="translated">该实用程序采用 &lt;code&gt;-llib1 -llib2 -llib3&lt;/code&gt; 形式的库列表，并返回适合包含在扩展Makefile中的行。 &lt;code&gt;-L/another/path&lt;/code&gt; 格式可能包含额外的库路径，这将影响对所有后续库的搜索。</target>
        </trans-unit>
        <trans-unit id="b766c16803f46a0ae895c110a4b6edf915519f91" translate="yes" xml:space="preserve">
          <source>This utility will read *.pl files (given as parameters) and write corresponding *.pm files. The pl2pm utilities does the following:</source>
          <target state="translated">这个实用程序将读取*.pl文件(以参数形式给出)并写入相应的*.pm文件。pl2pm实用程序可以完成以下工作。</target>
        </trans-unit>
        <trans-unit id="a410c695becbafd5bc2593139ba56b80c63242e8" translate="yes" xml:space="preserve">
          <source>This utility, that comes with the &lt;code&gt;Digest::SHA&lt;/code&gt; module, is used to print or verify SHA checksums.</source>
          <target state="translated">&lt;code&gt;Digest::SHA&lt;/code&gt; 模块随附的此实用程序用于打印或验证SHA校验和。</target>
        </trans-unit>
        <trans-unit id="3f272981cac4ae61e9e9e8d75fb4dc12762de509" translate="yes" xml:space="preserve">
          <source>This value can be adjusted to reduce security checking if required. The value is only relevant when &lt;code&gt;safe_level&lt;/code&gt; is set to MEDIUM or higher.</source>
          <target state="translated">如果需要，可以调整该值以减少安全检查。仅当 &lt;code&gt;safe_level&lt;/code&gt; 设置为MEDIUM或更高时，该值才有意义。</target>
        </trans-unit>
        <trans-unit id="fa4ff7242b8a2fd67b36df12914e2cc6d1af606d" translate="yes" xml:space="preserve">
          <source>This value can be adjusted to reduce security checking if required. The value is only relevant when C</source>
          <target state="translated">如果需要,可以调整该值以减少安全检查。该值仅在C</target>
        </trans-unit>
        <trans-unit id="cdc136e48e274a6f45986365041835b0a320611a" translate="yes" xml:space="preserve">
          <source>This value may be set when embedding for full cleanup.</source>
          <target state="translated">嵌入时可设置此值,以便进行全面清理。</target>
        </trans-unit>
        <trans-unit id="7591c615f6c14e41979e1eaadb2f09a869a865a0" translate="yes" xml:space="preserve">
          <source>This value overrides any &lt;code&gt;stack_size&lt;/code&gt; parameter given to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; . Its primary purpose is to permit setting the per-thread stack size for legacy threaded applications.</source>
          <target state="translated">该值将覆盖为 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; thread而给定的所有 &lt;code&gt;stack_size&lt;/code&gt; 参数。其主要目的是允许为遗留线程应用程序设置每个线程的堆栈大小。</target>
        </trans-unit>
        <trans-unit id="c8d10aaff4c3d6cbb1dc6581ac92ed77de4530c0" translate="yes" xml:space="preserve">
          <source>This value overrides any &lt;code&gt;stack_size&lt;/code&gt; parameter given to &lt;code&gt;use threads&lt;/code&gt;. Its primary purpose is to permit setting the per-thread stack size for legacy threaded applications.</source>
          <target state="translated">该值将覆盖为 &lt;code&gt;use threads&lt;/code&gt; 指定的所有 &lt;code&gt;stack_size&lt;/code&gt; 参数。其主要目的是允许为遗留线程应用程序设置每个线程的堆栈大小。</target>
        </trans-unit>
        <trans-unit id="f89d32d5d5695a0582f22913b8f68fcff2f07a33" translate="yes" xml:space="preserve">
          <source>This variable (and the corresponding &lt;code&gt;array_base&lt;/code&gt; feature and &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module) allowed changing the base for array and string indexing operations.</source>
          <target state="translated">此变量（以及相应的 &lt;code&gt;array_base&lt;/code&gt; 功能和&lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;模块）允许更改数组和字符串索引操作的基数。</target>
        </trans-unit>
        <trans-unit id="41ecf008113019e40a6e54f73ff5a98b48282c9e" translate="yes" xml:space="preserve">
          <source>This variable (default is 1) controls whether to enforce the contents of $^E to start with &lt;code&gt;SYS0003&lt;/code&gt; -like id. If set to 0, then the string value of $^E is what is available from the OS/2 message file. (Some messages in this file have an &lt;code&gt;SYS0003&lt;/code&gt; -like id prepended, some not.)</source>
          <target state="translated">此变量（默认值为1）控制是否强制$ ^ E的内容以 &lt;code&gt;SYS0003&lt;/code&gt; 的id 开头。如果设置为0，则$ ^ E字符串值是OS / 2消息文件中可用的值。（此文件中的某些消息带有 &lt;code&gt;SYS0003&lt;/code&gt; 的ID，有些则没有。）</target>
        </trans-unit>
        <trans-unit id="0e88ea105d4b7ad833e8f62738de77591c442f12" translate="yes" xml:space="preserve">
          <source>This variable (default is 1) controls whether to enforce the contents of $^E to start with &lt;code&gt;SYS0003&lt;/code&gt;-like id. If set to 0, then the string value of $^E is what is available from the OS/2 message file. (Some messages in this file have an &lt;code&gt;SYS0003&lt;/code&gt;-like id prepended, some not.)</source>
          <target state="translated">此变量（默认为1）控制是否强制$ ^ E的内容以 &lt;code&gt;SYS0003&lt;/code&gt; 的id开头。如果设置为0，则$ ^ E的字符串值是OS / 2消息文件中可用的值。（此文件中的某些消息带有 &lt;code&gt;SYS0003&lt;/code&gt; 的ID，有些则没有。）</target>
        </trans-unit>
        <trans-unit id="16732492f2d070676c6f99bbc0efae47b95f7071" translate="yes" xml:space="preserve">
          <source>This variable bears the symbol value to be used during open() or fcntl() to turn on non-blocking I/O for a file descriptor. If you wish to switch between blocking and non-blocking, you may try ioctl(&lt;code&gt;FIOSNBIO&lt;/code&gt; ) instead, but that is only supported by some devices.</source>
          <target state="translated">此变量带有将在open（）或fcntl（）期间用于打开文件描述符的非阻塞I / O的符号值。如果希望在阻止和非阻止之间切换，则可以尝试使用ioctl（ &lt;code&gt;FIOSNBIO&lt;/code&gt; ），但这仅在某些设备上支持。</target>
        </trans-unit>
        <trans-unit id="15ff3c0604e1d75a5342996d8934873f8d50aeb1" translate="yes" xml:space="preserve">
          <source>This variable bears the symbol value to be used during open() or fcntl() to turn on non-blocking I/O for a file descriptor. If you wish to switch between blocking and non-blocking, you may try ioctl(&lt;code&gt;FIOSNBIO&lt;/code&gt;) instead, but that is only supported by some devices.</source>
          <target state="translated">此变量带有在open（）或fcntl（）期间用于打开文件描述符的非阻塞I / O的符号值。如果希望在阻止和非阻止之间切换，则可以尝试使用ioctl（ &lt;code&gt;FIOSNBIO&lt;/code&gt; ）来代替，但这仅在某些设备上支持。</target>
        </trans-unit>
        <trans-unit id="cca2eeea3350d961dcaad04aa855c2a1f247bac2" translate="yes" xml:space="preserve">
          <source>This variable bears the symbolic errno code set by read() when no data is present on the file and non-blocking I/O was enabled (otherwise, read() blocks naturally).</source>
          <target state="translated">当文件上没有数据并且启用了非阻塞I/O时,这个变量带有由read()设置的符号errno代码(否则,read()会自然阻塞)。</target>
        </trans-unit>
        <trans-unit id="248382abe33b16964803e73f6ecfb34faabcc93f" translate="yes" xml:space="preserve">
          <source>This variable can be used to determine whether the Perl interpreter executing a script is in the right range of versions:</source>
          <target state="translated">这个变量可以用来确定执行脚本的Perl解释器是否在正确的版本范围内。</target>
        </trans-unit>
        <trans-unit id="dfea1020f3dea68d67242c313286038f4a0d0e35" translate="yes" xml:space="preserve">
          <source>This variable can be used to establish a fallthrough for the cases where nm fails to find a symbol. If usenm is false or usenm is true and mistrustnm is false, this variable has no effect. If usenm is true and mistrustnm is &lt;code&gt;compile&lt;/code&gt; , a test program will be compiled to try to find any symbol that can't be located via nm lookup. If mistrustnm is &lt;code&gt;run&lt;/code&gt; , the test program will be run as well as being compiled.</source>
          <target state="translated">对于nm无法找到符号的情况，可以使用此变量来建立过渡。如果usenm为false或usenm为true且mistrustnm为false，则此变量无效。如果usenm为true且mistrustnm为 &lt;code&gt;compile&lt;/code&gt; ，则将编译测试程序以尝试找到任何无法通过nm查找定位的符号。如果mistrustnm被 &lt;code&gt;run&lt;/code&gt; ，则测试程序将被运行以及被编译。</target>
        </trans-unit>
        <trans-unit id="4b3e9ceee71cdc320b5939b5ceda3cad1b31e64c" translate="yes" xml:space="preserve">
          <source>This variable can be used to establish a fallthrough for the cases where nm fails to find a symbol. If usenm is false or usenm is true and mistrustnm is false, this variable has no effect. If usenm is true and mistrustnm is &lt;code&gt;compile&lt;/code&gt;, a test program will be compiled to try to find any symbol that can't be located via nm lookup. If mistrustnm is &lt;code&gt;run&lt;/code&gt;, the test program will be run as well as being compiled.</source>
          <target state="translated">对于nm找不到符号的情况，可以使用此变量来建立过渡。如果usenm为false或usenm为true且mistrustnm为false，则此变量无效。如果usenm为true且mistrustnm为 &lt;code&gt;compile&lt;/code&gt; ，则将编译测试程序以尝试查找无法通过nm查找定位的任何符号。如果mistrustnm被 &lt;code&gt;run&lt;/code&gt; ，则测试程序将被运行以及被编译。</target>
        </trans-unit>
        <trans-unit id="4b0fbadd8567e78cf31399e6a2260ad4aafcd61e" translate="yes" xml:space="preserve">
          <source>This variable combines api_revision, api_version, and api_subversion in a format such as 5.6.1 (or 5_6_1) suitable for use as a directory name. This is filesystem dependent.</source>
          <target state="translated">这个变量结合了 api_revision、api_version 和 api_subversion,其格式为 5.6.1 (或 5_6_1),适合用作目录名。这与文件系统有关。</target>
        </trans-unit>
        <trans-unit id="3a2c3f8de756634885e7def1800fcfd4dd0d57a3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defined &lt;code&gt;PERL_VENDORARCH&lt;/code&gt; .</source>
          <target state="translated">此变量有条件地定义了 &lt;code&gt;PERL_VENDORARCH&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0b791466461b0141a9f42bfce168d808b632ccd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defined &lt;code&gt;PERL_VENDORARCH&lt;/code&gt;.</source>
          <target state="translated">此变量有条件地定义了 &lt;code&gt;PERL_VENDORARCH&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efd929c3d0bcbeeec8636fa669401d4e86c870d3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;ARCHLIB&lt;/code&gt; to hold the pathname of architecture-dependent library files for $package. If $archlib is the same as $privlib, then this is set to undef.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;ARCHLIB&lt;/code&gt; 来保存$ package依赖于体系结构的库文件的路径名。如果$ archlib与$ privlib相同，则将其设置为undef。</target>
        </trans-unit>
        <trans-unit id="ef97d2a231904adfc4265eba4006701690eed6ca" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CAN_VAPROTO&lt;/code&gt; on systems supporting prototype declaration of functions with a variable number of arguments. See also prototype.</source>
          <target state="translated">该变量在支持带有可变数量参数的函数原型声明的系统上有条件地定义 &lt;code&gt;CAN_VAPROTO&lt;/code&gt; 。另请参见原型。</target>
        </trans-unit>
        <trans-unit id="980485e36e7b05790618d387e3c7b5f9dffdd4ab" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CASTNEG&lt;/code&gt; , which indicates whether the C compiler can cast negative float to unsigned.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;CASTNEG&lt;/code&gt; ，它指示C编译器是否可以将负浮点数强制转换为无符号。</target>
        </trans-unit>
        <trans-unit id="e6c288a30b9263a34f361a5d921f5d74655c9671" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CASTNEG&lt;/code&gt;, which indicates whether the C compiler can cast negative float to unsigned.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;CASTNEG&lt;/code&gt; ，它指示C编译器是否可以将负浮点数强制转换为无符号。</target>
        </trans-unit>
        <trans-unit id="6a2c21b1fb400d236c7f8b93084483db1894c446" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CHARVSPRINTF&lt;/code&gt; if this system has vsprintf returning type (char*). The trend seems to be to declare it as &quot;int vsprintf()&quot;.</source>
          <target state="translated">如果此系统具有vsprintf返回类型（char *），则此变量有条件地定义 &lt;code&gt;CHARVSPRINTF&lt;/code&gt; 。趋势似乎是将其声明为&amp;ldquo; int vsprintf（）&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5078955ce08b58cadcdb20d3c38df82d26ee60ff" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CTERMID&lt;/code&gt; if ctermid() is available to generate filename for terminal.</source>
          <target state="translated">如果ctermid（）可用于为终端生成文件名，则此变量有条件地定义 &lt;code&gt;CTERMID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="978df228f8d800c08979baf4f0b9bb0fc46ebfa9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;DIRNAMLEN&lt;/code&gt; , which indicates to the C program that the length of directory entry names is provided by a d_namelen field.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;DIRNAMLEN&lt;/code&gt; ，它向C程序指示目录条目名称的长度由d_namelen字段提供。</target>
        </trans-unit>
        <trans-unit id="dc998e2c8c6e574860ee6fbf06818e7c667f7aa2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;DIRNAMLEN&lt;/code&gt;, which indicates to the C program that the length of directory entry names is provided by a d_namelen field.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;DIRNAMLEN&lt;/code&gt; ，它向C程序指示目录条目名称的长度由d_namelen字段提供。</target>
        </trans-unit>
        <trans-unit id="df3c72fff3ec53eb910b33c4d8de7ba859b22249" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;DLSYM_NEEDS_UNDERSCORE&lt;/code&gt; , which indicates that we need to prepend an underscore to the symbol name before calling dlsym().</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;DLSYM_NEEDS_UNDERSCORE&lt;/code&gt; ，这表明在调用dlsym（）之前，我们需要在符号名称前添加下划线。</target>
        </trans-unit>
        <trans-unit id="8582344f9c7c22d7833d9ec106477884283a6de7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;DLSYM_NEEDS_UNDERSCORE&lt;/code&gt;, which indicates that we need to prepend an underscore to the symbol name before calling dlsym().</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;DLSYM_NEEDS_UNDERSCORE&lt;/code&gt; ，这表明我们需要在调用dlsym（）之前在符号名称前添加下划线。</target>
        </trans-unit>
        <trans-unit id="49b013eda5d273dde0c71244769fe3ad52ab910f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;EBCDIC&lt;/code&gt; if this system uses &lt;code&gt;EBCDIC&lt;/code&gt; encoding.</source>
          <target state="translated">如果此系统使用 &lt;code&gt;EBCDIC&lt;/code&gt; 编码，则此变量有条件地定义 &lt;code&gt;EBCDIC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95f5847b07ee6a0574affcb0afba6691ba0cb5dc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;EOF_NONBLOCK&lt;/code&gt; if &lt;code&gt;EOF&lt;/code&gt; can be seen when reading from a non-blocking I/O source.</source>
          <target state="translated">如果从非阻塞I / O源读取时可以看到 &lt;code&gt;EOF&lt;/code&gt; ,则此变量有条件地定义 &lt;code&gt;EOF_NONBLOCK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0af8dac12168ddb05c87d99076fc3d364dbfc497" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;GRPASSWD&lt;/code&gt; , which indicates that struct group in &amp;lt;grp.h&amp;gt; contains gr_passwd.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;GRPASSWD&lt;/code&gt; ，它指示&amp;lt;grp.h&amp;gt;中的结构组包含gr_passwd。</target>
        </trans-unit>
        <trans-unit id="cca67ae13cb5b5216b026f087e4c9cd2724e9abd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;GRPASSWD&lt;/code&gt;, which indicates that struct group in &amp;lt;grp.h&amp;gt; contains gr_passwd.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;GRPASSWD&lt;/code&gt; ，它指示&amp;lt;grp.h&amp;gt;中的结构组包含gr_passwd。</target>
        </trans-unit>
        <trans-unit id="e239460b32f067f0e57a573c2a38cc269c4e8cf6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_DEPRECATED&lt;/code&gt; , which indicates that &lt;code&gt;GCC&lt;/code&gt; can handle the attribute for marking deprecated APIs</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HASATTRIBUTE_DEPRECATED&lt;/code&gt; ，这表明 &lt;code&gt;GCC&lt;/code&gt; 可以处理用于标记不赞成使用的API的属性</target>
        </trans-unit>
        <trans-unit id="8a3ce902111f1fb6ddfbb032a62404920f5f0a69" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_DEPRECATED&lt;/code&gt;, which indicates that &lt;code&gt;GCC&lt;/code&gt; can handle the attribute for marking deprecated APIs</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HASATTRIBUTE_DEPRECATED&lt;/code&gt; ，这表明 &lt;code&gt;GCC&lt;/code&gt; 可以处理用于标记不赞成使用的API的属性</target>
        </trans-unit>
        <trans-unit id="096a4e7335c9e97171f7b50c60f3c4f1d139650c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_FORMAT&lt;/code&gt; , which indicates the C compiler can check for printf-like formats.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASATTRIBUTE_FORMAT&lt;/code&gt; ，它指示C编译器可以检查类似printf的格式。</target>
        </trans-unit>
        <trans-unit id="f0f60c4dd5eeeaebaa985d1b6354c9a991633b8e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_FORMAT&lt;/code&gt;, which indicates the C compiler can check for printf-like formats.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASATTRIBUTE_FORMAT&lt;/code&gt; ，它指示C编译器可以检查类似printf的格式。</target>
        </trans-unit>
        <trans-unit id="0fc32aff59b98aa4940aa65546e2ce2f0bae5f6b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_MALLOC&lt;/code&gt; , which indicates the C compiler can understand functions as having malloc-like semantics.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASATTRIBUTE_MALLOC&lt;/code&gt; ，这表明C编译器可以将函数理解为具有类似malloc的语义。</target>
        </trans-unit>
        <trans-unit id="bf5374f94e92fd1cc3e01675dd69dfccafafe1cf" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_MALLOC&lt;/code&gt;, which indicates the C compiler can understand functions as having malloc-like semantics.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASATTRIBUTE_MALLOC&lt;/code&gt; ，这表明C编译器可以将函数理解为具有类似malloc的语义。</target>
        </trans-unit>
        <trans-unit id="cc77040e22d8dbd38fd3bdef2b4c807ff2648d0f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_NONNULL&lt;/code&gt; , which indicates that the C compiler can know that certain arguments must not be &lt;code&gt;NULL&lt;/code&gt; , and will check accordingly at compile time.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HASATTRIBUTE_NONNULL&lt;/code&gt; ，这表明C编译器可以知道某些参数一定不能为 &lt;code&gt;NULL&lt;/code&gt; ，并将在编译时进行相应检查。</target>
        </trans-unit>
        <trans-unit id="0d008cebd99a9203bb4aed19e68f0fe934a519a6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_NONNULL&lt;/code&gt;, which indicates that the C compiler can know that certain arguments must not be &lt;code&gt;NULL&lt;/code&gt;, and will check accordingly at compile time.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HASATTRIBUTE_NONNULL&lt;/code&gt; ，这表明C编译器可以知道某些参数一定不能为 &lt;code&gt;NULL&lt;/code&gt; ，并将在编译时进行相应检查。</target>
        </trans-unit>
        <trans-unit id="c1ca1b192eaeeef39ff342721f49f9732f5c25b0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_NORETURN&lt;/code&gt; , which indicates that the C compiler can know that certain functions are guaranteed never to return.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASATTRIBUTE_NORETURN&lt;/code&gt; ，这表明C编译器可以知道某些函数可以保证永远不会返回。</target>
        </trans-unit>
        <trans-unit id="db7d6ff22150607f2faf6e212132ffd7e2e815da" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_NORETURN&lt;/code&gt;, which indicates that the C compiler can know that certain functions are guaranteed never to return.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HASATTRIBUTE_NORETURN&lt;/code&gt; ，这表明C编译器可以知道某些函数可以保证永远不会返回。</target>
        </trans-unit>
        <trans-unit id="35f0cde07593cb535b92fefc63eb7d81d46fe8bb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_PURE&lt;/code&gt; , which indicates that the C compiler can know that certain functions are &lt;code&gt;pure&lt;/code&gt; functions, meaning that they have no side effects, and only rely on function input</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASATTRIBUTE_PURE&lt;/code&gt; ，这表明C编译器可以知道某些函数是 &lt;code&gt;pure&lt;/code&gt; 函数，这意味着它们没有副作用，仅依赖于函数输入</target>
        </trans-unit>
        <trans-unit id="17b724553d5b8a923ac88e7dad14f63c4b3879af" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_PURE&lt;/code&gt;, which indicates that the C compiler can know that certain functions are &lt;code&gt;pure&lt;/code&gt; functions, meaning that they have no side effects, and only rely on function input</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HASATTRIBUTE_PURE&lt;/code&gt; ，这表明C编译器可以知道某些函数是 &lt;code&gt;pure&lt;/code&gt; 函数，这意味着它们没有副作用，仅依赖于函数输入</target>
        </trans-unit>
        <trans-unit id="420fa8e106aa6be346627e32f034151a52362ffe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_UNUSED&lt;/code&gt; , which indicates that the C compiler can know that certain variables and arguments may not always be used, and to not throw warnings if they don't get used.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASATTRIBUTE_UNUSED&lt;/code&gt; ，这表明C编译器可以知道某些变量和参数可能不总是被使用，并且如果不使用它们就不会发出警告。</target>
        </trans-unit>
        <trans-unit id="dd8f83fc842425448043adda2ad084876969855e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_UNUSED&lt;/code&gt;, which indicates that the C compiler can know that certain variables and arguments may not always be used, and to not throw warnings if they don't get used.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HASATTRIBUTE_UNUSED&lt;/code&gt; ，这表明C编译器可以知道某些变量和参数可能不总是被使用，并且如果不使用它们就不会发出警告。</target>
        </trans-unit>
        <trans-unit id="ddcad35f0c318736909295f4f6cd964d37f1a53f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_WARN_UNUSED_RESULT&lt;/code&gt; , which indicates that the C compiler can know that certain functions have a return values that must not be ignored, such as malloc() or open().</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HASATTRIBUTE_WARN_UNUSED_RESULT&lt;/code&gt; ，这表明C编译器可以知道某些函数具有不可忽略的返回值，例如malloc（）或open（）。</target>
        </trans-unit>
        <trans-unit id="b236732aa4e34a009b54dcede2dfd55e746dc6ee" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_WARN_UNUSED_RESULT&lt;/code&gt;, which indicates that the C compiler can know that certain functions have a return values that must not be ignored, such as malloc() or open().</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HASATTRIBUTE_WARN_UNUSED_RESULT&lt;/code&gt; ，这表明C编译器可以知道某些函数具有不可忽略的返回值，例如malloc（）或open（）。</target>
        </trans-unit>
        <trans-unit id="4f215b234b46ef7c56eb723ad08f919ae0a7c950" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ACCESS&lt;/code&gt; if the access() system call is available to check for access permissions using real IDs.</source>
          <target state="translated">如果access（）系统调用可用于使用真实ID检查访问权限，则此变量有条件地定义 &lt;code&gt;HAS_ACCESS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79fed26f317480a67e604252b89c9e7cd20f70a5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_BUILTIN_ADD_OVERFLOW&lt;/code&gt;, which indicates that the compiler supports __builtin_add_overflow(x,y,&amp;amp;z) for safely adding x and y into z while checking for overflow.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_BUILTIN_ADD_OVERFLOW&lt;/code&gt; ，这表明编译器支持__builtin_add_overflow（x，y，＆z），用于在检查溢出时安全地将x和y添加到z中。</target>
        </trans-unit>
        <trans-unit id="a6ffb21d9b86f1027201a5668c38e081eccafe1d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_BUILTIN_MUL_OVERFLOW&lt;/code&gt;, which indicates that the compiler supports __builtin_mul_overflow(x,y,&amp;amp;z) for safely multiplying x and y into z while checking for overflow.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_BUILTIN_MUL_OVERFLOW&lt;/code&gt; ，这表明编译器支持__builtin_mul_overflow（x，y，＆z），用于在检查溢出时安全地将x和y乘以z。</target>
        </trans-unit>
        <trans-unit id="45b292063a7933d4c21b5fe0bdc942a12c561f5a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_BUILTIN_SUB_OVERFLOW&lt;/code&gt;, which indicates that the compiler supports __builtin_sub_overflow(x,y,&amp;amp;z) for safely subtracting y from x into z while checking for overflow.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_BUILTIN_SUB_OVERFLOW&lt;/code&gt; ，这表示编译器支持__builtin_sub_overflow（x，y，＆z），用于在检查溢出时将x中的y安全地减去y。</target>
        </trans-unit>
        <trans-unit id="7c105d4e6058827fec8056bf20316718cbab9faa" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_CLOSEDIR&lt;/code&gt; if closedir() is available.</source>
          <target state="translated">如果closedir（）可用，则此变量有条件地定义 &lt;code&gt;HAS_CLOSEDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8654218934b9b6758432460c578cc5a644b91d92" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDHOSTENT&lt;/code&gt; if endhostent() is available to close whatever was being used for host queries.</source>
          <target state="translated">如果可以使用endhostent（）关闭用于主机查询的 &lt;code&gt;HAS_ENDHOSTENT&lt;/code&gt; 则此变量有条件地定义HAS_ENDHOSTENT。</target>
        </trans-unit>
        <trans-unit id="79e5c8edfd4691e1b4f25bb1c714fe1507e829f4" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDNETENT&lt;/code&gt; if endnetent() is available to close whatever was being used for network queries.</source>
          <target state="translated">如果endnetent（）可用于关闭用于网络查询的 &lt;code&gt;HAS_ENDNETENT&lt;/code&gt; 则此变量有条件地定义HAS_ENDNETENT。</target>
        </trans-unit>
        <trans-unit id="23979ba16f9e3dd7409c1aeb4d7d4d5911e864e5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDPROTOENT&lt;/code&gt; if endprotoent() is available to close whatever was being used for protocol queries.</source>
          <target state="translated">如果可以使用endprotoent（）关闭用于协议查询的 &lt;code&gt;HAS_ENDPROTOENT&lt;/code&gt; 则此变量有条件地定义HAS_ENDPROTOENT。</target>
        </trans-unit>
        <trans-unit id="1f85023e116dfb459bcb6c6b9ea107e1880da801" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDSERVENT&lt;/code&gt; if endservent() is available to close whatever was being used for service queries.</source>
          <target state="translated">如果可以使用endservent（）关闭用于服务查询的 &lt;code&gt;HAS_ENDSERVENT&lt;/code&gt; 则此变量有条件地定义HAS_ENDSERVENT。</target>
        </trans-unit>
        <trans-unit id="9026ce557a983587089262cdc30c657f39523536" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FEGETROUND&lt;/code&gt; if fegetround() is available to get the floating point rounding mode.</source>
          <target state="translated">如果fegetround（）可用于获取浮点舍入模式，则此变量有条件地定义 &lt;code&gt;HAS_FEGETROUND&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5695e9822f626cc75613841b734f1880b97e1cd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FGETPOS&lt;/code&gt; if fgetpos() is available to get the file position indicator.</source>
          <target state="translated">如果fgetpos（）可用于获取文件位置指示符，则此变量有条件地定义 &lt;code&gt;HAS_FGETPOS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ecd11d67113d55076e38c3f87fbec174b96046c1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FLOCK&lt;/code&gt; if flock() is available to do file locking.</source>
          <target state="translated">如果flock（）可用于执行文件锁定，则此变量有条件地定义 &lt;code&gt;HAS_FLOCK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d12df32e7c3e2769df2173cc4aeba55819c508b3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FPGETROUND&lt;/code&gt; if fpgetround() is available to get the floating point rounding mode.</source>
          <target state="translated">如果fpgetround（）可用于获取浮点舍入模式，则此变量有条件地定义 &lt;code&gt;HAS_FPGETROUND&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7caed5a67bbd1068f15dc1afc8a52fbcbb8a3a6c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FSETPOS&lt;/code&gt; if fsetpos() is available to set the file position indicator.</source>
          <target state="translated">如果fsetpos（）可用于设置文件位置指示符，则此变量有条件地定义 &lt;code&gt;HAS_FSETPOS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ca1f26e1ee2a6d6b7bcc20d2c601de0d8652782" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETESPWNAM&lt;/code&gt; if getespwnam() is available to retrieve enhanced (shadow) password entries by name.</source>
          <target state="translated">如果getespwnam（）可用于按名称检索增强的（影子）密码条目，则此变量有条件地定义 &lt;code&gt;HAS_GETESPWNAM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="523b849ed0e10fbdf244f4e8cd77184e7b2e7e2e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETHOSTENT&lt;/code&gt; if gethostent() is available to look up host names in some data base or another.</source>
          <target state="translated">如果gethostent（）可用于在某些数据库或其他数据库中查找主机名，则此变量有条件地定义 &lt;code&gt;HAS_GETHOSTENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c477102d11cefe29ba1af921e3e01940cce25886" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETNETENT&lt;/code&gt; if getnetent() is available to look up network names in some data base or another.</source>
          <target state="translated">如果getnetent（）可用于在某些数据库或其他数据库中查找网络名称，则此变量有条件地定义 &lt;code&gt;HAS_GETNETENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3dd4221c56df17e7463336ebb61e6a0a59685106" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPAGESIZE&lt;/code&gt; if getpagesize() is available to get the system page size.</source>
          <target state="translated">如果getpagesize（）可用于获取系统页面大小，则此变量有条件地定义 &lt;code&gt;HAS_GETPAGESIZE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="008f90e9dce5e248f0a062499f460cbfe1316a70" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPGRP&lt;/code&gt; if getpgrp() is available to get the current process group.</source>
          <target state="translated">如果getpgrp（）可用于获取当前进程组，则此变量有条件地定义 &lt;code&gt;HAS_GETPGRP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="466f30d3944227e178d079578b5e186c11b86479" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPRIORITY&lt;/code&gt; if getpriority() is available to get a process's priority.</source>
          <target state="translated">如果getpriority（）可用于获取进程的优先级，则此变量有条件地定义 &lt;code&gt;HAS_GETPRIORITY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8a60b1d5d8d846ce3f5e6fe4d7b072471b5e6c6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPROTOENT&lt;/code&gt; if getprotoent() is available to look up protocols in some data base or another.</source>
          <target state="translated">如果getprotoent（）可用于在某些数据库或其他数据库中查找协议，则此变量有条件地定义 &lt;code&gt;HAS_GETPROTOENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="703bdebcae3a9b18831e785584b8e179d8f5569d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPRPWNAM&lt;/code&gt; if getprpwnam() is available to retrieve protected (shadow) password entries by name.</source>
          <target state="translated">如果getprpwnam（）可用于按名称检索受保护的（影子）密码条目，则此变量有条件地定义 &lt;code&gt;HAS_GETPRPWNAM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d470dbda91b75051a9116195c5471b4cc0a994bc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETSERVENT&lt;/code&gt; if getservent() is available to look up network services in some data base or another.</source>
          <target state="translated">如果可以使用getservent（）在某些数据库或其他数据库中查找网络服务，则此变量有条件地定义 &lt;code&gt;HAS_GETSERVENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f1532a01e5d8ec8dbefe92231b99738657124d6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETSPNAM&lt;/code&gt; if getspnam() is available to retrieve SysV shadow password entries by name.</source>
          <target state="translated">如果getspnam（）可用于按名称检索SysV影子密码条目，则此变量有条件地定义 &lt;code&gt;HAS_GETSPNAM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfad68a688a0a88c6b15faed3a855ee7ed81db88" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_HTONL&lt;/code&gt; if htonl() and its friends are available to do network order byte swapping.</source>
          <target state="translated">如果htonl（）及其朋友可用于进行网络顺序字节交换，则此变量有条件地定义 &lt;code&gt;HAS_HTONL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36ae55fc8ab6d9db052670febb9d6c73ffc9c7fe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_HYPOT&lt;/code&gt; if hypot is available for numerically stable hypotenuse function.</source>
          <target state="translated">如果 &lt;code&gt;HAS_HYPOT&lt;/code&gt; 可用于数值稳定的斜边函数，则此变量有条件地定义HAS_HYPOT。</target>
        </trans-unit>
        <trans-unit id="1c8f906308fe5425fd5dc9fc6c65283219211f28" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_INDEX&lt;/code&gt; if index() and rindex() are available for string searching.</source>
          <target state="translated">如果index（）和rindex（）可用于字符串搜索，则此变量有条件地定义 &lt;code&gt;HAS_INDEX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f58665b1066bffd31d93be9865becf02e07fbc33" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LINK&lt;/code&gt; if link() is available to create hard links.</source>
          <target state="translated">如果link（）可用于创建硬链接，则此变量有条件地定义 &lt;code&gt;HAS_LINK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7aaa9b5790c7fed2f4557a1b76230d9dee2b872" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LOCALECONV&lt;/code&gt; if localeconv() is available for numeric and monetary formatting conventions.</source>
          <target state="translated">如果localeconv（）可用于数字和货币格式约定，则此变量有条件地定义 &lt;code&gt;HAS_LOCALECONV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3c4adc80b08fec49de9e85a9758844bbed93d4f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LOCKF&lt;/code&gt; if lockf() is available to do file locking.</source>
          <target state="translated">如果lockf（）可用于进行文件锁定，则此变量有条件地定义 &lt;code&gt;HAS_LOCKF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3309e731f7ec54de80f5709f885fa11f752d281" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LONG_DOUBLE&lt;/code&gt; if the long double type is supported.</source>
          <target state="translated">如果支持long double类型，则此变量有条件地定义 &lt;code&gt;HAS_LONG_DOUBLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f96dc22b2fabc7d6becfede8302b062283c67511" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LONG_LONG&lt;/code&gt; if the long long type is supported.</source>
          <target state="translated">如果支持long long类型，则此变量有条件地定义 &lt;code&gt;HAS_LONG_LONG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bde46e5f10d187a1e49089e8f14937e758db8660" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LSTAT&lt;/code&gt; if lstat() is available to do file stats on symbolic links.</source>
          <target state="translated">如果lstat（）可用于执行符号链接上的文件统计，则此变量有条件地定义 &lt;code&gt;HAS_LSTAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c29d2f5108f120fc070de1998bbec52bcea01c7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MADVISE&lt;/code&gt; if madvise() is available to map a file into memory.</source>
          <target state="translated">如果madvise（）可用于将文件映射到内存，则此变量有条件地定义 &lt;code&gt;HAS_MADVISE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0176dd527685bd6e90190916167c20eaf54f9cf" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MKOSTEMP&lt;/code&gt; if mkostemp() is available to exclusively create and open a uniquely named (with a suffix) temporary file.</source>
          <target state="translated">如果mkostemp（）可用于以独占方式创建和打开一个唯一命名（带有后缀）的临时文件，则此变量有条件地定义 &lt;code&gt;HAS_MKOSTEMP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9773977cefbb09ffe9bf40f7bdd75aa66788128d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MMAP&lt;/code&gt; if mmap() is available to map a file into memory.</source>
          <target state="translated">如果mmap（）可用于将文件映射到内存，则此变量有条件地定义 &lt;code&gt;HAS_MMAP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e49a09fbe97831dedb0097fc04c353ecd4fdc497" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MPROTECT&lt;/code&gt; if mprotect() is available to modify the access protection of a memory mapped file.</source>
          <target state="translated">如果mprotect（）可用于修改内存映射文件的访问保护，则此变量有条件地定义 &lt;code&gt;HAS_MPROTECT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d39b4760c4a7ddea99da224cda29212d2ef99aed" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MSYNC&lt;/code&gt; if msync() is available to synchronize a mapped file.</source>
          <target state="translated">如果msync（）可用于同步映射的文件，则此变量有条件地定义 &lt;code&gt;HAS_MSYNC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="542bb319608c7eec938e5b98398f37ee190044a7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MUNMAP&lt;/code&gt; if munmap() is available to unmap a region mapped by mmap().</source>
          <target state="translated">如果munmap（）可用于取消映射由mmap（）映射的区域，则此变量有条件地定义 &lt;code&gt;HAS_MUNMAP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02d3878b96b9be7c2121b2227ea0c924b133a4a0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NAN&lt;/code&gt; if nan() is available to generate NaN.</source>
          <target state="translated">如果nan（）可用于生成NaN，则此变量有条件地定义 &lt;code&gt;HAS_NAN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ac0a1512388c05f6e3f6942497c27a45e8e3efe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NANOSLEEP&lt;/code&gt; if nanosleep() is available to sleep with 1E-9 sec accuracy.</source>
          <target state="translated">如果nanosleep（）可用于以1E-9秒的精度进入睡眠状态，则此变量有条件地定义 &lt;code&gt;HAS_NANOSLEEP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b6ab26a7e66c25dc87e4ed8365e14b5b776d611" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NEARBYINT&lt;/code&gt; if nearbyint() is available to return the integral value closest to (according to the current rounding mode) to x.</source>
          <target state="translated">如果 &lt;code&gt;HAS_NEARBYINT&lt;/code&gt; （）可用于将最接近（根据当前舍入模式）的整数值返回到x，则此变量有条件地定义HAS_NEARBYINT。</target>
        </trans-unit>
        <trans-unit id="9de8df4ca9d3107d7b5e197ebc2f8b56f2a456de" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NEXTAFTER&lt;/code&gt; if nextafter() is available to return the next machine representable double from x in direction y.</source>
          <target state="translated">如果nextafter（）可用于从y方向从x返回下一个可表示的double值，则此变量有条件地定义 &lt;code&gt;HAS_NEXTAFTER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09cc9884f832b1e2f2ad4607b97076420d46d665" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NEXTTOWARD&lt;/code&gt; if nexttoward() is available to return the next machine representable long double from x in direction y.</source>
          <target state="translated">如果nexttoward（）可用于从y方向从x返回下一个机器可表示的长双 &lt;code&gt;HAS_NEXTTOWARD&lt;/code&gt; 则此变量有条件地定义HAS_NEXTTOWARD。</target>
        </trans-unit>
        <trans-unit id="e84d3a1694bc236dbf1d7993a1d2c9255724da86" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_PTHREAD_ATTR_SETSCOPE&lt;/code&gt; if pthread_attr_setscope() is available to set the contention scope attribute of a thread attribute object.</source>
          <target state="translated">如果pthread_attr_setscope（）可用于设置线程属性对象的竞争作用域属性，则此变量有条件地定义 &lt;code&gt;HAS_PTHREAD_ATTR_SETSCOPE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca9e53f6ec390b98dfba5bb4f284367970f8d262" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_READDIR&lt;/code&gt; if readdir() is available to read directory entries.</source>
          <target state="translated">如果readdir（）可用于读取目录条目，则此变量有条件地定义 &lt;code&gt;HAS_READDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c772ddc21b6658b7802061d88a44caa292765ab3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_REWINDDIR&lt;/code&gt; if rewinddir() is available.</source>
          <target state="translated">如果rewinddir（）可用，则此变量有条件地定义 &lt;code&gt;HAS_REWINDDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="102609636e6adf43c7c619fd51b5305af390db97" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_RMDIR&lt;/code&gt; if rmdir() is available to remove directories.</source>
          <target state="translated">如果rmdir（）可用于删除目录，则此变量有条件地定义 &lt;code&gt;HAS_RMDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="887794d99137721bdeb0c86f2844b40ead019692" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SEEKDIR&lt;/code&gt; if seekdir() is available.</source>
          <target state="translated">如果seekdir（）可用，则此变量有条件地定义 &lt;code&gt;HAS_SEEKDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eabab054867a6e7a1fda52591f68108f354fff8a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SELECT&lt;/code&gt; if select() is available to select active file descriptors. A &amp;lt;sys/time.h&amp;gt; inclusion may be necessary for the timeout field.</source>
          <target state="translated">如果select（）可用于选择活动文件描述符，则此变量有条件地定义 &lt;code&gt;HAS_SELECT&lt;/code&gt; 。超时字段可能需要包含&amp;lt;sys / time.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="bc33f5c99454e91ae2ee5c0078387d95e7d2e9a2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETHOSTENT&lt;/code&gt; if sethostent() is available.</source>
          <target state="translated">如果sethostent（）可用，则此变量有条件地定义 &lt;code&gt;HAS_SETHOSTENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75151e22ebcabc154ea71d8ff2b10a358ed030a2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETLOCALE&lt;/code&gt; if setlocale() is available to handle locale-specific ctype implementations.</source>
          <target state="translated">如果setlocale（）可用于处理特定于语言环境的ctype实现，则此变量有条件地定义 &lt;code&gt;HAS_SETLOCALE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d673facbb75d108913e27f1a2486a73d55d0236" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETNETENT&lt;/code&gt; if setnetent() is available.</source>
          <target state="translated">如果setnetent（）可用，则此变量有条件地定义 &lt;code&gt;HAS_SETNETENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7914dcc37c31303f3da0f6e201df5d765f8aa85c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETPGRP&lt;/code&gt; if setpgrp() is available to set the current process group.</source>
          <target state="translated">如果setpgrp（）可用于设置当前进程组，则此变量有条件地定义 &lt;code&gt;HAS_SETPGRP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2002a17a2c2a55f6f40172b2b8fb58d5b76cdd2a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETPRIORITY&lt;/code&gt; if setpriority() is available to set a process's priority.</source>
          <target state="translated">如果setpriority（）可用于设置进程的优先级，则此变量有条件地定义 &lt;code&gt;HAS_SETPRIORITY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c631092c3030de3575c0a7a87bf0eb17b021238" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETPROTOENT&lt;/code&gt; if setprotoent() is available.</source>
          <target state="translated">如果setprotoent（）可用，则此变量有条件地定义 &lt;code&gt;HAS_SETPROTOENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f78400a8b12f8656f01ebbdf5086223548e1e83" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETREGID&lt;/code&gt; if setregid() is available to change the real and effective gid of the current process.</source>
          <target state="translated">如果setregid（）可用于更改当前进程的实际和有效gid，则此变量有条件地定义 &lt;code&gt;HAS_SETREGID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30c69bd63c2acea93583c8f9220b4a879c50d781" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETRESGID&lt;/code&gt; if setresgid() is available to change the real, effective and saved gid of the current process.</source>
          <target state="translated">如果setresgid（）可用于更改当前进程的实际，有效和保存的gid，则此变量有条件地定义 &lt;code&gt;HAS_SETRESGID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35485f4098b6c1c258054bdb628277a4ccf112e2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETREUID&lt;/code&gt; if setresuid() is available to change the real, effective and saved uid of the current process.</source>
          <target state="translated">如果setresuid（）可用于更改当前进程的实际，有效和已保存的uid，则此变量有条件地定义 &lt;code&gt;HAS_SETREUID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aba8a0bc40989a1ca38df2aae3c387f371d5192b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETREUID&lt;/code&gt; if setreuid() is available to change the real and effective uid of the current process.</source>
          <target state="translated">如果setreuid（）可用于更改当前进程的实际和有效uid，则此变量有条件地定义 &lt;code&gt;HAS_SETREUID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb6783028c86e7bf10a2b92123734f47a7944fac" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETSERVENT&lt;/code&gt; if setservent() is available.</source>
          <target state="translated">如果setservent（）可用，则此变量有条件地定义 &lt;code&gt;HAS_SETSERVENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56d4df6b62a7f4a67414b6f9ecb8ddad65efc719" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETSID&lt;/code&gt; if setsid() is available to set the process group &lt;code&gt;ID&lt;/code&gt; .</source>
          <target state="translated">如果setsid（）可用于设置进程组 &lt;code&gt;ID&lt;/code&gt; ,则此变量有条件地定义 &lt;code&gt;HAS_SETSID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ef408c79ac243069730beb417294ee15f89a8da" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETSID&lt;/code&gt; if setsid() is available to set the process group &lt;code&gt;ID&lt;/code&gt;.</source>
          <target state="translated">如果setsid（）可用于设置进程组 &lt;code&gt;ID&lt;/code&gt; ,则此变量有条件地定义 &lt;code&gt;HAS_SETSID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a53a8b438b669e85e8dac90bda9a163f72b38dcd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SIGPROCMASK&lt;/code&gt; if sigprocmask() is available to examine or change the signal mask of the calling process.</source>
          <target state="translated">如果sigprocmask（）可用于检查或更改调用过程的信号掩码，则此变量有条件地定义 &lt;code&gt;HAS_SIGPROCMASK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fedaa514d1228b3cb8d459d4c50ec34f00f6ac02" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SOCKET&lt;/code&gt; , which indicates that the &lt;code&gt;BSD&lt;/code&gt; socket interface is supported.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_SOCKET&lt;/code&gt; ，它指示支持 &lt;code&gt;BSD&lt;/code&gt; 套接字接口。</target>
        </trans-unit>
        <trans-unit id="d90f4b16cfc328489f9f3e006e37192e3670ab4a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SOCKET&lt;/code&gt;, which indicates that the &lt;code&gt;BSD&lt;/code&gt; socket interface is supported.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_SOCKET&lt;/code&gt; ，它指示支持 &lt;code&gt;BSD&lt;/code&gt; 套接字接口。</target>
        </trans-unit>
        <trans-unit id="5acf41a0b06778d8de2ab0c3e21b6db83e6e1a26" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STAT&lt;/code&gt; if stat() is available to get file status.</source>
          <target state="translated">如果stat（）可用于获取文件状态，则此变量有条件地定义 &lt;code&gt;HAS_STAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="104dec5b82fbc045989fe3c8c4ef8fa75c373740" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRCHR&lt;/code&gt; if strchr() and strrchr() are available for string searching.</source>
          <target state="translated">如果strchr（）和strrchr（）可用于字符串搜索，则此变量有条件地定义 &lt;code&gt;HAS_STRCHR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66c65e480ececd2a54e0b9068f9890c68b2b94ad" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRCOLL&lt;/code&gt; if strcoll() is available to compare strings using collating information.</source>
          <target state="translated">如果 &lt;code&gt;HAS_STRCOLL&lt;/code&gt; （）可用于使用整理信息比较字符串，则此变量有条件地定义HAS_STRCOLL。</target>
        </trans-unit>
        <trans-unit id="b82eb75e3b5d7a021a62e68340d85ee6ee407d5d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRERROR&lt;/code&gt; if strerror() is available to translate error numbers to strings.</source>
          <target state="translated">如果strerror（）可用于将错误号转换为字符串，则此变量有条件地定义 &lt;code&gt;HAS_STRERROR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="157fd2966246701c1e0fd97cb121f370d5243dfd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRXFRM&lt;/code&gt; if strxfrm() is available to transform strings.</source>
          <target state="translated">如果strxfrm（）可用于转换字符串，则此变量有条件地定义 &lt;code&gt;HAS_STRXFRM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f665cc4a3804d1cfbb21ea5e1e553f34ba0001f3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYSCALL&lt;/code&gt; if syscall() is available call arbitrary system calls.</source>
          <target state="translated">如果syscall（）可用，则此变量有条件地定义 &lt;code&gt;HAS_SYSCALL&lt;/code&gt; ，以调用任意系统调用。</target>
        </trans-unit>
        <trans-unit id="76958e03c19c57ba5daadf788ceb559703fda4a7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYSTEM&lt;/code&gt; if system() is available to issue a shell command.</source>
          <target state="translated">如果system（）可用于发出Shell命令，则此变量有条件地定义 &lt;code&gt;HAS_SYSTEM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fba0f75ab5519c316f7379166065cac7a0fa0f08" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYS_ERRLIST&lt;/code&gt; if sys_errlist[] is available to translate error numbers to strings.</source>
          <target state="translated">如果sys_errlist []可用于将错误号转换为字符串，则此变量有条件地定义 &lt;code&gt;HAS_SYS_ERRLIST&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3133e51b2626aefa90c83a60c2bc07b45364f9d8" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYS_ERRNOLIST&lt;/code&gt; if sys_errnolist[] is available to translate error numbers to the symbolic name.</source>
          <target state="translated">如果sys_errnolist []可用于将错误编号转换为符号名称，则此变量有条件地定义 &lt;code&gt;HAS_SYS_ERRNOLIST&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b6cc938eb6588fef7831af7c25c38df6b393dba" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TELLDIR&lt;/code&gt; if telldir() is available.</source>
          <target state="translated">如果telldir（）可用，则此变量有条件地定义 &lt;code&gt;HAS_TELLDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13376d783be11f279f6a31e5dca53c18c5518beb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TM_TM_GMTOFF&lt;/code&gt; , which indicates indicates to the C program that the struct tm has the tm_gmtoff field.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_TM_TM_GMTOFF&lt;/code&gt; ，它向C程序指示结构tm具有tm_gmtoff字段。</target>
        </trans-unit>
        <trans-unit id="1086cb9c5e3f467454832b8b12812058cd92e06e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TM_TM_GMTOFF&lt;/code&gt;, which indicates to the C program that the struct tm has the tm_gmtoff field.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_TM_TM_GMTOFF&lt;/code&gt; ，它向C程序指示结构tm具有tm_gmtoff字段。</target>
        </trans-unit>
        <trans-unit id="a5fdffc25ffd7e4584eb45e68410699ffcf4500b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TM_TM_ZONE&lt;/code&gt; , which indicates indicates to the C program that the struct tm has the tm_zone field.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_TM_TM_ZONE&lt;/code&gt; ，它向C程序指示struct tm具有tm_zone字段。</target>
        </trans-unit>
        <trans-unit id="c04ef66c28333bfa29c16eb97a4f1bf1a07a865b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TM_TM_ZONE&lt;/code&gt;, which indicates to the C program that the struct tm has the tm_zone field.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_TM_TM_ZONE&lt;/code&gt; ，它向C程序指示struct tm具有tm_zone字段。</target>
        </trans-unit>
        <trans-unit id="56c5c15d4eddf8d206488d6739d6fd8de91eb4bc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TRUNCATE&lt;/code&gt; if truncate() is available to truncate files.</source>
          <target state="translated">如果truncate（）可用于截断文件，则此变量有条件地定义 &lt;code&gt;HAS_TRUNCATE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2b911e2460cf128e44ed370b2980c2209097f87" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TZNAME&lt;/code&gt; if tzname[] is available to access timezone names.</source>
          <target state="translated">如果tzname []可用于访问时区名称，则此变量有条件地定义 &lt;code&gt;HAS_TZNAME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d2899983d1ce6900d5663872bcf0fe4bc31fe25" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_UNION_SEMUN&lt;/code&gt; if the union semun is defined by including &amp;lt;sys/sem.h&amp;gt;.</source>
          <target state="translated">如果通过包含&amp;lt;sys / sem.h&amp;gt;来定义联合semun，则此变量有条件地定义 &lt;code&gt;HAS_UNION_SEMUN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dbad1c6f722a7fb60b2580c6825a89a0875ea78" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_USLEEP&lt;/code&gt; if usleep() is available to do high granularity sleeps.</source>
          <target state="translated">如果usleep（）可用于执行高粒度睡眠，则此变量有条件地定义 &lt;code&gt;HAS_USLEEP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62fcdd3f292691fc949ae90083b1d7e19d396383" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_USTAT&lt;/code&gt; if ustat() is available to query file system statistics by dev_t.</source>
          <target state="translated">如果ustat（）可用于dev_t查询文件系统统计信息，则此变量有条件地定义 &lt;code&gt;HAS_USTAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6da30a5484ed0715193a06b75bbdc0f387b14b5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_WAITPID&lt;/code&gt; if waitpid() is available to wait for child process.</source>
          <target state="translated">如果waitpid（）可用于等待子进程，则此变量有条件地定义 &lt;code&gt;HAS_WAITPID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea1ebdb3e07eb3cfa8774547eb7eca99b9cbda6a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS__FWALK&lt;/code&gt; if _fwalk() is available to apply a function to all the file handles.</source>
          <target state="translated">如果_fwalk（）可用于将函数应用于所有文件句柄，则此变量有条件地定义 &lt;code&gt;HAS__FWALK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccfbe62640f2e7f4d3f434546f57dde1c801c589" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_DIRENT&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;dirent.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_DIRENT&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;dirent.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="a9a787f2a18f3b44e560a5f3940cd8e2d3a4e477" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_DIRENT&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;dirent.h&amp;gt;.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;I_DIRENT&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;dirent.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="b09b17b8feebed4fb31ad1053dd929b31fc1552d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_NETINET_IN&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;netinet/in.h&amp;gt;. Otherwise, you may try &amp;lt;sys/in.h&amp;gt;.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;I_NETINET_IN&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;netinet / in.h&amp;gt;。否则，您可以尝试&amp;lt;sys / in.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="6229f1fa60966db3808987381a186cc7f8635df8" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_NETINET_IN&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;netinet/in.h&amp;gt;. Otherwise, you may try &amp;lt;sys/in.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_NETINET_IN&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;netinet / in.h&amp;gt;。否则，您可以尝试&amp;lt;sys / in.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="18545a27b23f4ec408fe168cb07019ddd52aeb9d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_PWD&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;pwd.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_PWD&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;pwd.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="bb803936d76c5aab724f9475cc78845aadf9c816" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_PWD&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;pwd.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_PWD&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;pwd.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="3999885997764e29fe1e4dcd432c1a48f0dbd137" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_QUADMATH&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;quadmath.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_QUADMATH&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;quadmath.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="84ed6ce0c86d5ff27c690b2ddda9c899654179c0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_QUADMATH&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;quadmath.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_QUADMATH&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;quadmath.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="2a59b19169614e1208d6a92cb8cd08ec908a8e0b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_IN&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/in.h&amp;gt; instead of &amp;lt;netinet/in.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_IN&lt;/code&gt; ，它向C程序指示它应包括&amp;lt;sys / in.h&amp;gt;而不是&amp;lt;netinet / in.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="03b21042961935fbfbefec3a909d5794f5de25f0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_IN&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;sys/in.h&amp;gt; instead of &amp;lt;netinet/in.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_IN&lt;/code&gt; ，它向C程序指示它应包括&amp;lt;sys / in.h&amp;gt;而不是&amp;lt;netinet / in.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="b72fad23f2686fa8a3b7ba796dba5e928d3c1193" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_SELECT&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/select.h&amp;gt; in order to get the definition of struct timeval.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;I_SYS_SELECT&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;sys / select.h&amp;gt;以便获取struct timeval的定义。</target>
        </trans-unit>
        <trans-unit id="be7898505b9471576bb5b430ec24e9c34c7b1a55" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_SELECT&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;sys/select.h&amp;gt; in order to get the definition of struct timeval.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;I_SYS_SELECT&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;sys / select.h&amp;gt;以便获取struct timeval的定义。</target>
        </trans-unit>
        <trans-unit id="46b3e1dfb1e11c227d687db5d0baaa2e450457de" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_SOCKIO&lt;/code&gt; to indicate to the C program that socket ioctl codes may be found in &amp;lt;sys/sockio.h&amp;gt; instead of &amp;lt;sys/ioctl.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_SOCKIO&lt;/code&gt; ，以向C程序指示可以在&amp;lt;sys / sockio.h&amp;gt;中而不是&amp;lt;sys / ioctl.h&amp;gt;中找到套接字ioctl代码。</target>
        </trans-unit>
        <trans-unit id="abc49b9ac08dff6a9f6857ae04835d4e61d8c3d9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_TIME&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/time.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_TIME&lt;/code&gt; ，它向C程序指示它应包括&amp;lt;sys / time.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="a05fce4796eb0a468ac066cc59e0a4dc57538112" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_TIME&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;sys/time.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_TIME&lt;/code&gt; ，它向C程序指示它应包括&amp;lt;sys / time.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="134ce192071bcaa440fc2e6dd10833f44f8a3750" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_TIME_KERNEL&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/time.h&amp;gt; with &lt;code&gt;KERNEL&lt;/code&gt; defined.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_TIME_KERNEL&lt;/code&gt; ，它向C程序指示它应包含定义了 &lt;code&gt;KERNEL&lt;/code&gt; 的 &amp;lt;sys / time.h&amp;gt; 。</target>
        </trans-unit>
        <trans-unit id="f179c336e76408f1f071c7e6f1d598b7e1ea26ef" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_TIME_KERNEL&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;sys/time.h&amp;gt; with &lt;code&gt;KERNEL&lt;/code&gt; defined.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_TIME_KERNEL&lt;/code&gt; ，它向C程序指示它应包括已定义 &lt;code&gt;KERNEL&lt;/code&gt; 的&amp;lt;sys / time.h&amp;gt; 。</target>
        </trans-unit>
        <trans-unit id="939cb7b0620edee4edc61983e7278fc31a5c1093" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_UN&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/un.h&amp;gt; to get &lt;code&gt;UNIX&lt;/code&gt; domain socket definitions.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_UN&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;sys / un.h&amp;gt;以获得 &lt;code&gt;UNIX&lt;/code&gt; 域套接字定义。</target>
        </trans-unit>
        <trans-unit id="9ff1d57c77149a8f8965a9ee33bf60883847c53e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_UN&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;sys/un.h&amp;gt; to get &lt;code&gt;UNIX&lt;/code&gt; domain socket definitions.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_UN&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;sys / un.h&amp;gt;以获得 &lt;code&gt;UNIX&lt;/code&gt; 域套接字定义。</target>
        </trans-unit>
        <trans-unit id="d05b60d3b34826e6947a78549014fc461f91e426" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_WAIT&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/wait.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_WAIT&lt;/code&gt; ，它向C程序指示它应包括&amp;lt;sys / wait.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="f8afd487363c7052289252816c4039d5e7259ee5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_WAIT&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;sys/wait.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_WAIT&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;sys / wait.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="cbee00fea0a0e43a823409e3c9ea7ecbe6db0995" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_TIME&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;time.h&amp;gt;.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;I_TIME&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;time.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="5e26138c57947cb8f890b9cb6f5d5a73c355cb2b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_VARARGS&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;varargs.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_VARARGS&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;varargs.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="adacd8529d588003400a218d9efa8778e7c5a4a0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;LONG_DOUBLE_STYLE_IEEE&lt;/code&gt; if the long double is any of the &lt;code&gt;IEEE&lt;/code&gt; 754 style long doubles: &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_STD&lt;/code&gt;, &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_EXTENDED&lt;/code&gt;, &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_DOUBLEDOUBLE&lt;/code&gt;.</source>
          <target state="translated">如果long double是 &lt;code&gt;IEEE&lt;/code&gt; 754样式的long double中的任何一个，则此变量有条件地定义 &lt;code&gt;LONG_DOUBLE_STYLE_IEEE&lt;/code&gt; ： &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_STD&lt;/code&gt; ， &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_EXTENDED&lt;/code&gt; ， &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_DOUBLEDOUBLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f34f3c21fd0b8ede657c0701ed24331b130440cd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_DOUBLEDOUBLE&lt;/code&gt; if the long double is the 128-bit &lt;code&gt;IEEE&lt;/code&gt; 754 double-double.</source>
          <target state="translated">如果long double是128位 &lt;code&gt;IEEE&lt;/code&gt; 754 double-double，则此变量有条件地定义 &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_DOUBLEDOUBLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="756980c20db36fe0dd46d4db8127dd1afbfcd959" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_EXTENDED&lt;/code&gt; if the long double is the 80-bit &lt;code&gt;IEEE&lt;/code&gt; 754 extended precision. Note that despite the &lt;code&gt;extended&lt;/code&gt; this is less than the &lt;code&gt;std&lt;/code&gt;, since thisis an extension of the double precision.</source>
          <target state="translated">如果long double是80位 &lt;code&gt;IEEE&lt;/code&gt; 754扩展精度，则此变量有条件地定义 &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_EXTENDED&lt;/code&gt; 。请注意，尽管这是 &lt;code&gt;extended&lt;/code&gt; ，但它小于 &lt;code&gt;std&lt;/code&gt; ，因为这是double precision的扩展。</target>
        </trans-unit>
        <trans-unit id="83aa1379dea829947822c99c195a810d06bb4a38" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_STD&lt;/code&gt; if the long double is the 128-bit &lt;code&gt;IEEE&lt;/code&gt; 754.</source>
          <target state="translated">如果long double是128位 &lt;code&gt;IEEE&lt;/code&gt; 754，则此变量有条件地定义 &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_STD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce75ff7631bbaf803d0ace7a33143e12192218ef" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;LONG_DOUBLE_STYLE_VAX&lt;/code&gt; if the long double is the 128-bit &lt;code&gt;VAX&lt;/code&gt; format H.</source>
          <target state="translated">如果long double是128位 &lt;code&gt;VAX&lt;/code&gt; 格式H，则此变量有条件地定义 &lt;code&gt;LONG_DOUBLE_STYLE_VAX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58139b2e3b281a9a118c344ae314fa19f7ef819b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;MYMALLOC&lt;/code&gt; in case other parts of the source want to take special action if &lt;code&gt;MYMALLOC&lt;/code&gt; is used. This may include different sorts of profiling or error detection.</source>
          <target state="translated">如果使用 &lt;code&gt;MYMALLOC&lt;/code&gt; 时源的其他部分想要采取特殊措施，则此变量有条件地定义 &lt;code&gt;MYMALLOC&lt;/code&gt; 。这可能包括不同种类的分析或错误检测。</target>
        </trans-unit>
        <trans-unit id="2c8fdadfdd30950a7b700d396be77876a6f4c5f5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; . It is set to undef when &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; is empty.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; 。当 &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; 为空时，将其设置为undef 。</target>
        </trans-unit>
        <trans-unit id="7b135860345eb1cb4ecb8f5dbf25f3b80d9663cd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt;. It is set to undef when &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; is empty.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; 。当 &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; 为空时，将其设置为undef 。</target>
        </trans-unit>
        <trans-unit id="4ff46e0082d05a29ab6252efc4bd771d18d5878f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_OTHERLIBDIRS&lt;/code&gt; , which contains a colon-separated set of paths for the perl binary to include in @&lt;code&gt;INC&lt;/code&gt; . See also otherlibdirs.</source>
          <target state="translated">此变量有条件定义 &lt;code&gt;PERL_OTHERLIBDIRS&lt;/code&gt; ，其中包含一个冒号分隔的一组路径用于Perl二进制到在@包括 &lt;code&gt;INC&lt;/code&gt; 。另请参见otherlibdirs。</target>
        </trans-unit>
        <trans-unit id="792edce2f8757d59c45987f57e7fea3d6b286f1e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_OTHERLIBDIRS&lt;/code&gt;, which contains a colon-separated set of paths for the perl binary to include in @&lt;code&gt;INC&lt;/code&gt;. See also otherlibdirs.</source>
          <target state="translated">此变量有条件定义 &lt;code&gt;PERL_OTHERLIBDIRS&lt;/code&gt; ，其中包含一个冒号分隔的一组路径用于Perl二进制到在@包括 &lt;code&gt;INC&lt;/code&gt; 。另请参见otherlibdirs。</target>
        </trans-unit>
        <trans-unit id="caef6d2331c84b17275d3f9012789c819b377ba9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORBIN&lt;/code&gt; .</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PERL_VENDORBIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d76f60666c8aecb525e5906ff962481dc318171" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORBIN&lt;/code&gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PERL_VENDORBIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="533111c8d8f10b6751abb6a1a0088f4c19073d3e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORLIB&lt;/code&gt; .</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PERL_VENDORLIB&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="871a0cb0554ef284df45b5e6ac6f30c717bd50ad" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORLIB&lt;/code&gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PERL_VENDORLIB&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="177a5dd44b77ca5ced87275d19c31e96d16bc7b0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORSCRIPT&lt;/code&gt; .</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PERL_VENDORSCRIPT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7969ccc81d5cd924a862496e98d359f5c4fdb7ba" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORSCRIPT&lt;/code&gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PERL_VENDORSCRIPT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cc9c3d91fb6f28bed8329dae1d992b2ddc3b88b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PRINTF_FORMAT_NULL_OK&lt;/code&gt; , which indicates the C compiler allows printf-like formats to be null.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PRINTF_FORMAT_NULL_OK&lt;/code&gt; ，这表明C编译器允许类似printf的格式为null。</target>
        </trans-unit>
        <trans-unit id="a63de281be650d131b0dada057dda3c788db87bb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PRINTF_FORMAT_NULL_OK&lt;/code&gt;, which indicates the C compiler allows printf-like formats to be null.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PRINTF_FORMAT_NULL_OK&lt;/code&gt; ，这表明C编译器允许类似printf的格式为null。</target>
        </trans-unit>
        <trans-unit id="1b45d18a0fa0b9cd91b944a53b1e7323f8adc333" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWAGE&lt;/code&gt; , which indicates that struct passwd contains pw_age.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWAGE&lt;/code&gt; ，它指示结构passwd包含pw_age。</target>
        </trans-unit>
        <trans-unit id="8f93b894ca294b4b089fefb4c8e130735fcaeb5c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWAGE&lt;/code&gt;, which indicates that struct passwd contains pw_age.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;PWAGE&lt;/code&gt; ，它指示结构passwd包含pw_age。</target>
        </trans-unit>
        <trans-unit id="6b184e19c4dcc5f872f5344f6afc9d5aa8890c36" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCHANGE&lt;/code&gt; , which indicates that struct passwd contains pw_change.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWCHANGE&lt;/code&gt; ，它指示结构passwd包含pw_change。</target>
        </trans-unit>
        <trans-unit id="8441cd9467c256bdc9b09035b7b1876a361955b4" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCHANGE&lt;/code&gt;, which indicates that struct passwd contains pw_change.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWCHANGE&lt;/code&gt; ，它指示结构passwd包含pw_change。</target>
        </trans-unit>
        <trans-unit id="da5fb50ace415a9312b25c289ac7ee228f0dd1f8" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCLASS&lt;/code&gt; , which indicates that struct passwd contains pw_class.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWCLASS&lt;/code&gt; ，它指示struct passwd包含pw_class。</target>
        </trans-unit>
        <trans-unit id="bf37296a4f626e5d681b9f335125151376abd8ce" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCLASS&lt;/code&gt;, which indicates that struct passwd contains pw_class.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWCLASS&lt;/code&gt; ，它指示struct passwd包含pw_class。</target>
        </trans-unit>
        <trans-unit id="9f567085df536f85d28a3794c7c79c2f135c39fc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCOMMENT&lt;/code&gt; , which indicates that struct passwd contains pw_comment.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWCOMMENT&lt;/code&gt; ，它指示结构passwd包含pw_comment。</target>
        </trans-unit>
        <trans-unit id="d446c0dd2bd7215acf1c8d761e1c367d9b022427" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCOMMENT&lt;/code&gt;, which indicates that struct passwd contains pw_comment.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWCOMMENT&lt;/code&gt; ，它指示struct passwd包含pw_comment。</target>
        </trans-unit>
        <trans-unit id="2223305749b21469a0762164dc8dc0df3aaa8c7f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWEXPIRE&lt;/code&gt; , which indicates that struct passwd contains pw_expire.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWEXPIRE&lt;/code&gt; ，指示结构passwd包含pw_expire。</target>
        </trans-unit>
        <trans-unit id="9992e4d0615a9aacf641f7f53cfe12ded3beec47" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWEXPIRE&lt;/code&gt;, which indicates that struct passwd contains pw_expire.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWEXPIRE&lt;/code&gt; ，指示结构passwd包含pw_expire。</target>
        </trans-unit>
        <trans-unit id="ebf2af3d9e7342f5f1fe442fb4ba6590cba3aeaf" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWGECOS&lt;/code&gt; , which indicates that struct passwd contains pw_gecos.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;PWGECOS&lt;/code&gt; ，它指示结构passwd包含pw_gecos。</target>
        </trans-unit>
        <trans-unit id="3b8016818095e885888a0aca57a1a20c790843e4" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWGECOS&lt;/code&gt;, which indicates that struct passwd contains pw_gecos.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWGECOS&lt;/code&gt; ，它指示struct passwd包含pw_gecos。</target>
        </trans-unit>
        <trans-unit id="e4df7b4ce4ecdac74c8fac53257d7c54e9e2b1d2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWPASSWD&lt;/code&gt; , which indicates that struct passwd contains pw_passwd.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWPASSWD&lt;/code&gt; ，它指示结构passwd包含pw_passwd。</target>
        </trans-unit>
        <trans-unit id="abe328a44bbcae89a29efb7320b5f4698e2f3a19" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWPASSWD&lt;/code&gt;, which indicates that struct passwd contains pw_passwd.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWPASSWD&lt;/code&gt; ，它指示结构passwd包含pw_passwd。</target>
        </trans-unit>
        <trans-unit id="f6f5c85237fcc07cb2101d49b94de63960320aab" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWQUOTA&lt;/code&gt; , which indicates that struct passwd contains pw_quota.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWQUOTA&lt;/code&gt; ，它指示结构passwd包含pw_quota。</target>
        </trans-unit>
        <trans-unit id="9226e8f3babf511a24917282807de2e020e40767" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWQUOTA&lt;/code&gt;, which indicates that struct passwd contains pw_quota.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWQUOTA&lt;/code&gt; ，它指示结构passwd包含pw_quota。</target>
        </trans-unit>
        <trans-unit id="d7b4b9ba5cff92bc6dcdb8d6c8455ba666662fc3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;SETLOCALE_ACCEPTS_ANY_LOCALE_NAME&lt;/code&gt; if setlocale() accepts any locale name.</source>
          <target state="translated">如果setlocale（）接受任何语言环境名称，则此变量有条件地定义 &lt;code&gt;SETLOCALE_ACCEPTS_ANY_LOCALE_NAME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e6dc66871cca735678df0954175fa95cf018eb7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;SETUID_SCRIPTS_ARE_SECURE_NOW&lt;/code&gt; if setuid scripts can be secure. This test looks in</source>
          <target state="translated">如果setuid脚本可以安全，则此变量有条件地定义 &lt;code&gt;SETUID_SCRIPTS_ARE_SECURE_NOW&lt;/code&gt; 。该测试在</target>
        </trans-unit>
        <trans-unit id="81f004e1abf850968e0e52c15f9f6cad13d862f0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;SITEARCH&lt;/code&gt; to hold the pathname of architecture-dependent library files for $package. If $sitearch is the same as $archlib, then this is set to undef.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;SITEARCH&lt;/code&gt; 来保存$ package依赖于体系结构的库文件的路径名。如果$ sitearch与$ archlib相同，则将其设置为undef。</target>
        </trans-unit>
        <trans-unit id="8b1027f2dc2d15c75eedea147e9dd18e08a6014d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;STDCHAR&lt;/code&gt; to be the type of char used in</source>
          <target state="translated">此变量有条件地将 &lt;code&gt;STDCHAR&lt;/code&gt; 定义为用于</target>
        </trans-unit>
        <trans-unit id="f33764730e4076b75f7a54ca0311a31df43bbaae" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;STDIO_CNT_LVALUE&lt;/code&gt; if the &lt;code&gt;FILE_cnt&lt;/code&gt; macro can be used as an lvalue.</source>
          <target state="translated">如果 &lt;code&gt;FILE_cnt&lt;/code&gt; 宏可用作左值，则此变量有条件地定义 &lt;code&gt;STDIO_CNT_LVALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e69f3a8bd1de18db50aaf0b9ef5033e3dafd978" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;STDIO_PTR_LVALUE&lt;/code&gt; if the &lt;code&gt;FILE_ptr&lt;/code&gt; macro can be used as an lvalue.</source>
          <target state="translated">如果 &lt;code&gt;FILE_ptr&lt;/code&gt; 宏可用作左值，则此变量有条件地定义 &lt;code&gt;STDIO_PTR_LVALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7bc8c4e73c6aaa4fc8b7bd3db1eed9675bd50c1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_BSD_GETPGRP&lt;/code&gt; if getpgrp needs one arguments whereas &lt;code&gt;USG&lt;/code&gt; one needs none.</source>
          <target state="translated">如果getpgrp需要一个参数而 &lt;code&gt;USG&lt;/code&gt; 一个不需要，则此变量有条件地定义 &lt;code&gt;USE_BSD_GETPGRP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4cb9da0f1f2c05f27c0a4f7de8f8706f136adf70" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_BSD_SETPGRP&lt;/code&gt; if setpgrp needs two arguments whereas &lt;code&gt;USG&lt;/code&gt; one needs none. See also d_setpgid for a &lt;code&gt;POSIX&lt;/code&gt; interface.</source>
          <target state="translated">如果setpgrp需要两个参数，而 &lt;code&gt;USG&lt;/code&gt; 一个不需要，则此变量有条件地定义 &lt;code&gt;USE_BSD_SETPGRP&lt;/code&gt; 。关于 &lt;code&gt;POSIX&lt;/code&gt; 接口，另请参见d_setpgid 。</target>
        </trans-unit>
        <trans-unit id="f057b25789e3d0c0c978f875ab711fef26822396" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_IOCNOTTY&lt;/code&gt; to indicate that the ioctl() call with &lt;code&gt;TIOCNOTTY&lt;/code&gt; should be used to void tty association. Otherwise (on &lt;code&gt;USG&lt;/code&gt; probably), it is enough to close the standard file descriptors and do a setpgrp().</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;USE_IOCNOTTY&lt;/code&gt; ,以指示应该将带有 &lt;code&gt;TIOCNOTTY&lt;/code&gt; 的ioctl（）调用用于使tty关联无效。否则（可能在 &lt;code&gt;USG&lt;/code&gt; 上），足以关闭标准文件描述符并执行setpgrp（）。</target>
        </trans-unit>
        <trans-unit id="c86f9683041fce14f0acc7f22e22cb66e7ecf21d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_SEMCTL_SEMID_DS&lt;/code&gt; , which indicates that struct semid_ds * is to be used for semctl &lt;code&gt;IPC_STAT&lt;/code&gt; .</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;USE_SEMCTL_SEMID_DS&lt;/code&gt; ，这表明struct semid_ds *将用于semctl &lt;code&gt;IPC_STAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1109513dd38439e5fff1a28d882ff5dff7ec9cbf" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_SEMCTL_SEMID_DS&lt;/code&gt;, which indicates that struct semid_ds * is to be used for semctl &lt;code&gt;IPC_STAT&lt;/code&gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;USE_SEMCTL_SEMID_DS&lt;/code&gt; ，这表明struct semid_ds *将用于semctl &lt;code&gt;IPC_STAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="165216a22f48262f27b72dd85b30d1c442227e08" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_SEMCTL_SEMUN&lt;/code&gt; , which indicates that union semun is to be used for semctl &lt;code&gt;IPC_STAT&lt;/code&gt; .</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;USE_SEMCTL_SEMUN&lt;/code&gt; ，这指示将联合semun用于semctl &lt;code&gt;IPC_STAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4aafdea14d415917179c68732185373f4c70028" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_SEMCTL_SEMUN&lt;/code&gt;, which indicates that union semun is to be used for semctl &lt;code&gt;IPC_STAT&lt;/code&gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;USE_SEMCTL_SEMUN&lt;/code&gt; ，这指示将联合semun用于semctl &lt;code&gt;IPC_STAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d946a174db1c59c6d451a81dd08b793b70e50298" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_STAT_BLOCKS&lt;/code&gt; if this system has a stat structure declaring st_blksize and st_blocks.</source>
          <target state="translated">此变量有条件定义 &lt;code&gt;USE_STAT_BLOCKS&lt;/code&gt; 如果该系统具有一个stat结构声明st_blksize和的st_blocks。</target>
        </trans-unit>
        <trans-unit id="4f2a34f2d97a9448f367a3e7dc94f6a98d0c8541" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_STDIO_BASE&lt;/code&gt; if this system has a &lt;code&gt;FILE&lt;/code&gt; structure declaring a usable _base field (or equivalent) in</source>
          <target state="translated">如果此系统具有 &lt;code&gt;FILE&lt;/code&gt; 结构，该文件声明了一个可用的_base字段（或等效项），则此变量有条件地定义 &lt;code&gt;USE_STDIO_BASE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="884014009e45fc4b799369297408405b825f05ec" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_STDIO_PTR&lt;/code&gt; if this system has a &lt;code&gt;FILE&lt;/code&gt; structure declaring usable _ptr and _cnt fields (or equivalent) in</source>
          <target state="translated">如果此系统具有 &lt;code&gt;FILE&lt;/code&gt; 结构，该文件声明了以下文件中的可用_ptr和_cnt字段（或等效项），则此变量有条件地定义 &lt;code&gt;USE_STDIO_PTR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2ce6f3e2ba733cc080d545a7f5345eaada6b53b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;VOIDSIG&lt;/code&gt; if this system declares &quot;void (*signal(...))()&quot; in</source>
          <target state="translated">如果此系统在其中声明&amp;ldquo; void（* signal（...））（）&amp;rdquo;，则此变量有条件地定义 &lt;code&gt;VOIDSIG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1b1eb5455ff0e45585c738f286f73520d2bda4a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;VOID_CLOSEDIR&lt;/code&gt; if closedir() does not return a value.</source>
          <target state="translated">如果closedir（）不返回值，则此变量有条件地定义 &lt;code&gt;VOID_CLOSEDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f67d5b9663b7f0f671bc57d6208cef2ecf39a7bd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines CASTI32, which indicates whether the C compiler can cast large floats to 32-bit ints.</source>
          <target state="translated">这个变量有条件地定义了CASTI32,它表示C编译器是否可以将大的float转换为32位的ints。</target>
        </trans-unit>
        <trans-unit id="01b443cab6a6f837f35bbd4a8391036b60139696" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines HAS_ACCEPT4 if accept4() is available to accept socket connections.</source>
          <target state="translated">如果accept4()可以接受socket连接,这个变量就会有条件地定义HAS_ACCEPT4。</target>
        </trans-unit>
        <trans-unit id="1e0e56548eb03f6bba0bfbdaf1893bfedf8b743e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines HAS_DUP2 if dup2() is available to duplicate file descriptors.</source>
          <target state="translated">如果dup2()可用于复制文件描述符,则这个变量有条件地定义HAS_DUP2。</target>
        </trans-unit>
        <trans-unit id="b26b7adde106aa6278ad18ec71be8d927043d6fd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines HAS_DUP3 if dup3() is available to duplicate file descriptors.</source>
          <target state="translated">如果dup3()可以复制文件描述符,这个变量就有条件地定义HAS_DUP3。</target>
        </trans-unit>
        <trans-unit id="439c57e77afcdbc973932168c0d12a970d487a4f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines HAS_LC_MONETARY_2008 if libc has the international currency locale rules from &lt;code&gt;POSIX&lt;/code&gt; 1003.1-2008.</source>
          <target state="translated">如果libc具有 &lt;code&gt;POSIX&lt;/code&gt; 1003.1-2008中的国际货币语言环境规则，则此变量有条件地定义HAS_LC_MONETARY_2008。</target>
        </trans-unit>
        <trans-unit id="3d55d58456df494116e8e08588b498d9a5a4a48d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines d_dbl_dig if this system's header files provide &lt;code&gt;DBL_DIG&lt;/code&gt; , which is the number of significant digits in a double precision number.</source>
          <target state="translated">如果此系统的头文件提供 &lt;code&gt;DBL_DIG&lt;/code&gt; ，则此变量有条件地定义d_dbl_dig ，这是双精度数字中的有效位数。</target>
        </trans-unit>
        <trans-unit id="26943f542b57e3d665241442f5609c91f668a2bc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines d_ldbl_dig if this system's header files provide &lt;code&gt;LDBL_DIG&lt;/code&gt; , which is the number of significant digits in a long double precision number.</source>
          <target state="translated">如果此系统的头文件提供 &lt;code&gt;LDBL_DIG&lt;/code&gt; ，则此变量有条件地定义d_ldbl_dig ，这是长双精度数字中的有效位数。</target>
        </trans-unit>
        <trans-unit id="0899cdd5463edd7d47e779f47e9d996e29a1d596" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines d_ldbl_dig if this system's header files provide &lt;code&gt;LDBL_DIG&lt;/code&gt;, which is the number of significant digits in a long double precision number.</source>
          <target state="translated">如果此系统的头文件提供 &lt;code&gt;LDBL_DIG&lt;/code&gt; ，则此变量有条件地定义d_ldbl_dig ，这是长双精度数字中的有效位数。</target>
        </trans-unit>
        <trans-unit id="41d4367b100c21704ff1afa07d5fcbbbff3622b5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines pthread_create_joinable. undef if</source>
          <target state="translated">这个变量有条件地定义了pthread_create_joinable。</target>
        </trans-unit>
        <trans-unit id="4e65c9696692a1039d19a96f88bbb8715e74549c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;CHSIZE&lt;/code&gt; symbol, which indicates to the C program that the chsize() routine is available to truncate files. You might need a -lx to get this routine.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;CHSIZE&lt;/code&gt; 符号，该符号向C程序表明chsize（）例程可用于截断文件。您可能需要-lx才能获取此例程。</target>
        </trans-unit>
        <trans-unit id="846b0e7427992bb9738c034b084170cbd17a9268" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;CRYPT&lt;/code&gt; symbol, which indicates to the C program that the crypt() routine is available to encrypt passwords and the like.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;CRYPT&lt;/code&gt; 符号，该符号向C程序指示crypt（）例程可用于加密密码等。</target>
        </trans-unit>
        <trans-unit id="357bf08dc30645376499e133bedc6c5b51689b15" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;CSH&lt;/code&gt; symbol, which indicates to the C program that the C-shell exists.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;CSH&lt;/code&gt; 符号，该符号向C程序指示C-shell存在。</target>
        </trans-unit>
        <trans-unit id="e54e9f341c505bb1d2ec118651994c8e65d0f811" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;FCNTL_CAN_LOCK&lt;/code&gt; symbol and indicates whether file locking with fcntl() works.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;FCNTL_CAN_LOCK&lt;/code&gt; 符号，并指示使用fcntl（）锁定文件是否有效。</target>
        </trans-unit>
        <trans-unit id="02d3adba206dca72cb969c2114087d914736e57e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;FLEXFILENAMES&lt;/code&gt; symbol, which indicates that the system supports filenames longer than 14 characters.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;FLEXFILENAMES&lt;/code&gt; 符号，该符号表示系统支持长度超过14个字符的文件名。</target>
        </trans-unit>
        <trans-unit id="b6165df6dc3c074b8386cff10673ed582f2313bf" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HASCONST&lt;/code&gt; symbol, which indicates to the C program that this C compiler knows about the const type.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASCONST&lt;/code&gt; 符号，该符号向C程序表明该C编译器知道const类型。</target>
        </trans-unit>
        <trans-unit id="514ce51d44fd8efc6f22a726ff2d864524dc5927" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HASVOLATILE&lt;/code&gt; symbol, which indicates to the C program that this C compiler knows about the volatile declaration.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASVOLATILE&lt;/code&gt; 符号，该符号向C程序表明该C编译器知道有关volatile声明的信息。</target>
        </trans-unit>
        <trans-unit id="3baa45e96d482436f92754c7ebdc6a73550f0eae" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ACCESSX&lt;/code&gt; symbol, which indicates to the C program that the accessx() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ACCESSX&lt;/code&gt; 符号，该符号向C程序表明accessx（）例程可用。</target>
        </trans-unit>
        <trans-unit id="12a76ff5170c955de143e03f08fd4db9b4437e7b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ACOSH&lt;/code&gt; symbol, which indicates to the C program that the acosh() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ACOSH&lt;/code&gt; 符号，该符号向C程序指示acosh（）例程可用。</target>
        </trans-unit>
        <trans-unit id="3bbc6bd18282fbbaa0a5df512d46d448872f79f0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_AINTL&lt;/code&gt; symbol, which indicates to the C program that the aintl() routine is available. If copysignl is also present we can emulate modfl.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_AINTL&lt;/code&gt; 符号，该符号向C程序指示aintl（）例程可用。如果copysignl也存在，我们可以模拟modfl。</target>
        </trans-unit>
        <trans-unit id="ac4f3fc539e3b11a8b62b87684564e56d5832bdb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ALARM&lt;/code&gt; symbol, which indicates to the C program that the alarm() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ALARM&lt;/code&gt; 符号，该符号向C程序指示alarm（）例程可用。</target>
        </trans-unit>
        <trans-unit id="393748ad8a6e58564f59c88a5a65a0fccff40956" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ASCTIME_R&lt;/code&gt; symbol, which indicates to the C program that the asctime_r() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_ASCTIME_R&lt;/code&gt; 符号，该符号向C程序指示asctime_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="e6240de5e54fe3a786d797ae169f9a039181d8e9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ASINH&lt;/code&gt; symbol, which indicates to the C program that the asinh() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ASINH&lt;/code&gt; 符号，该符号向C程序指示asinh（）例程可用。</target>
        </trans-unit>
        <trans-unit id="968fc15f09fb64edc7440ecd0aed6b099eb7c13a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ATANH&lt;/code&gt; symbol, which indicates to the C program that the atanh() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ATANH&lt;/code&gt; 符号，该符号向C程序表明atanh（）例程可用。</target>
        </trans-unit>
        <trans-unit id="0b6ee241d9266a7948fd72b86cd3046b1822d99c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ATOLF&lt;/code&gt; symbol, which indicates to the C program that the atolf() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_ATOLF&lt;/code&gt; 符号，该符号向C程序指示atolf（）例程可用。</target>
        </trans-unit>
        <trans-unit id="7f44fe9ea95c9ae1f907047c17022ef03aa1acbb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ATOLL&lt;/code&gt; symbol, which indicates to the C program that the atoll() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_ATOLL&lt;/code&gt; 符号，该符号向C程序指示atoll（）例程可用。</target>
        </trans-unit>
        <trans-unit id="d5e0162b328b8a9b754dac6231795ba2f27a65bb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BACKTRACE&lt;/code&gt; symbol, which indicates to the C program that the backtrace() routine is available to get a stack trace.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_BACKTRACE&lt;/code&gt; 符号，该符号向C程序指示backtrace（）例程可用于获取堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="e96fa08dff1194cea11b6b542d4bb635e9998fe7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BCMP&lt;/code&gt; symbol if the bcmp() routine is available to compare strings.</source>
          <target state="translated">如果bcmp（）例程可用于比较字符串，则此变量有条件地定义 &lt;code&gt;HAS_BCMP&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="2c3a347a1f168f38f12b42fec82e5a9d4a71e447" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BCOPY&lt;/code&gt; symbol if the bcopy() routine is available to copy strings.</source>
          <target state="translated">如果bcopy（）例程可用于复制字符串，则此变量有条件地定义 &lt;code&gt;HAS_BCOPY&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="fe7d21ac1bac028a9a4864da166ebd5752380e71" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BZERO&lt;/code&gt; symbol if the bzero() routine is available to set memory to 0.</source>
          <target state="translated">如果bzero（）例程可用于将内存设置为0，则此变量有条件地定义 &lt;code&gt;HAS_BZERO&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="6ca90016e7f6abf49f24d5147f764f4e266fad51" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CBRT&lt;/code&gt; symbol, which indicates to the C program that the cbrt() (cube root) function is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_CBRT&lt;/code&gt; 符号，该符号向C程序指示cbrt（）（多维数据集根）功能可用。</target>
        </trans-unit>
        <trans-unit id="9190489c62bb031470f6a8b4f7cd7a1825719930" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CHOWN&lt;/code&gt; symbol, which indicates to the C program that the chown() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_CHOWN&lt;/code&gt; 符号，该符号向C程序指示chown（）例程可用。</target>
        </trans-unit>
        <trans-unit id="ab782a1830d8f2fd000403d6b221d923f1975987" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CHROOT&lt;/code&gt; symbol, which indicates to the C program that the chroot() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_CHROOT&lt;/code&gt; 符号，该符号向C程序表明chroot（）例程可用。</target>
        </trans-unit>
        <trans-unit id="32e6c736a6ca4ad0fe4ee89e271bd5cc262bc051" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CLASS&lt;/code&gt; symbol, which indicates to the C program that the class() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_CLASS&lt;/code&gt; 符号，该符号向C程序指示class（）例程可用。</target>
        </trans-unit>
        <trans-unit id="a075a89328697cbb603b70b3c6d8d110f118b481" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CLEARENV&lt;/code&gt; symbol, which indicates to the C program that the clearenv () routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_CLEARENV&lt;/code&gt; 符号，该符号向C程序表明clearenv（）例程可用。</target>
        </trans-unit>
        <trans-unit id="74f77f33bb77370820b1492e4169ae2248f4c8c7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_COPYSIGN&lt;/code&gt; symbol, which indicates to the C program that the copysign() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_COPYSIGN&lt;/code&gt; 符号，该符号向C程序指示copysign（）例程可用。</target>
        </trans-unit>
        <trans-unit id="98b66499ba2e3361546a98261177f15a6de1a0f6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_COPYSIGNL&lt;/code&gt; symbol, which indicates to the C program that the copysignl() routine is available. If aintl is also present we can emulate modfl.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_COPYSIGNL&lt;/code&gt; 符号，该符号向C程序指示copysignl（）例程可用。如果还存在aintl，我们可以模拟modfl。</target>
        </trans-unit>
        <trans-unit id="df0f6e4346afa66f63cca26a76d791fade6366c0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CRYPT_R&lt;/code&gt; symbol, which indicates to the C program that the crypt_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_CRYPT_R&lt;/code&gt; 符号，该符号向C程序指示crypt_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="953edbb919ba277a0602d4f2fae83655b7094d65" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CTERMID_R&lt;/code&gt; symbol, which indicates to the C program that the ctermid_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_CTERMID_R&lt;/code&gt; 符号，该符号向C程序表明ctermid_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="88f0e31c279f299ee13d676f3280ed80bdc1ec78" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CTIME_R&lt;/code&gt; symbol, which indicates to the C program that the ctime_r() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_CTIME_R&lt;/code&gt; 符号，该符号向C程序指示ctime_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="f94152d7278e725fe89c658a702df792c385b802" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CUSERID&lt;/code&gt; symbol, which indicates to the C program that the cuserid() routine is available to get character login names.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_CUSERID&lt;/code&gt; 符号，该符号向C程序表明cuserid（）例程可用于获取字符登录名。</target>
        </trans-unit>
        <trans-unit id="ce2c192cea1c48bf6a95dcfd9e173ca30310cf0e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DBMINIT_PROTO&lt;/code&gt; symbol, which indicates to the C program that the system provides a prototype for the dbminit() function. Otherwise, it is up to the program to supply one.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_DBMINIT_PROTO&lt;/code&gt; 符号，该符号向C程序表明系统为dbminit（）函数提供了原型。否则，由程序提供一个。</target>
        </trans-unit>
        <trans-unit id="9f277ae3e34118b1fe4f7a94827507d1e32928ea" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DIFFTIME&lt;/code&gt; symbol, which indicates to the C program that the difftime() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_DIFFTIME&lt;/code&gt; 符号，该符号向C程序指示difftime（）例程可用。</target>
        </trans-unit>
        <trans-unit id="a13740603c74d16121c0903202111151cb13d77c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DIRFD&lt;/code&gt; constant, which indicates to the C program that dirfd() is available to return the file descriptor of a directory stream.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_DIRFD&lt;/code&gt; 常量，该常量向C程序指示dirfd（）可用于返回目录流的文件描述符。</target>
        </trans-unit>
        <trans-unit id="87bbbc4e9449012cc05f3e6c9ced36d1a9bc5f01" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DIR_DD_FD&lt;/code&gt; symbol, which indicates that the &lt;code&gt;DIR&lt;/code&gt; directory stream type contains a member variable called dd_fd.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_DIR_DD_FD&lt;/code&gt; 符号，该符号指示 &lt;code&gt;DIR&lt;/code&gt; 目录流类型包含一个名为dd_fd的成员变量。</target>
        </trans-unit>
        <trans-unit id="ca28447a8986907b62f8a42e124cc4cf1327b826" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DLADDR&lt;/code&gt; symbol, which indicates to the C program that the dladdr() routine is available to get a stack trace.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_DLADDR&lt;/code&gt; 符号，该符号向C程序表明dladdr（）例程可用于获取堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="44450e1cdbf629ec9119c59c9f90d2b874b7e95d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DLERROR&lt;/code&gt; symbol, which indicates to the C program that the dlerror() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_DLERROR&lt;/code&gt; 符号，该符号向C程序指示dlerror（）例程可用。</target>
        </trans-unit>
        <trans-unit id="ed1d2043eb098d6534774a50acff39bfc0910625" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DLOPEN&lt;/code&gt; symbol, which indicates to the C program that the dlopen() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_DLOPEN&lt;/code&gt; 符号，该符号向C程序指示dlopen（）例程可用。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
