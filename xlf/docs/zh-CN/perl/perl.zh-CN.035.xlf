<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="231784d11e2ac3af47374629249969cb6df988d0" translate="yes" xml:space="preserve">
          <source>Getopt::Std</source>
          <target state="translated">Getopt::Std</target>
        </trans-unit>
        <trans-unit id="703b8d06dd815db9f4b95873fa7d356dd5900693" translate="yes" xml:space="preserve">
          <source>Getopt::Std - Process single-character switches with switch clustering</source>
          <target state="translated">Getopt::Std-使用开关簇处理单字符开关。</target>
        </trans-unit>
        <trans-unit id="622ba9888f87bde337d7026005408ee58ef615b1" translate="yes" xml:space="preserve">
          <source>Gets information about a file system volume, returning a true value if successful. On failure, returns a false value and sets &lt;code&gt;fileLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt;.</source>
          <target state="translated">获取有关文件系统卷的信息，如果成功，则返回一个真值。如果失败，返回一个错误的值，并将 &lt;code&gt;fileLastError()&lt;/code&gt; 和 &lt;code&gt;$^E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="050f7a7a02c0f512f89945ac517880bcdb5ae514" translate="yes" xml:space="preserve">
          <source>Gets or sets the number of concurrent test runs the harness is handling. By default, this value is 1 -- for parallel testing, this should be set higher.</source>
          <target state="translated">获取或设置线束正在处理的并发测试运行次数。默认情况下,这个值是1--对于并行测试,这个值应该设置得更高。</target>
        </trans-unit>
        <trans-unit id="daa629c55c1f0a45358dee6010d69ea52181b0b2" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;mro_isarev&lt;/code&gt; for this class, returned as an arrayref of class names. These are every class that &quot;isa&quot; the given class name, even if the isa relationship is indirect. This is used internally by the MRO code to keep track of method/MRO cache invalidations.</source>
          <target state="translated">获取 &lt;code&gt;mro_isarev&lt;/code&gt; 的mro_isarev，以类名称的arrayref返回。这些都是&amp;ldquo; isa&amp;rdquo;给定类名的每个类，即使isa关系是间接的。MRO代码在内部使用它来跟踪方法/ MRO缓存无效。</target>
        </trans-unit>
        <trans-unit id="70c3b8c2ec32f2ee2102b43f1e6dd3a00777d348" translate="yes" xml:space="preserve">
          <source>Gets the version of Perl currently running the test suite.</source>
          <target state="translated">获取当前运行测试套件的Perl版本。</target>
        </trans-unit>
        <trans-unit id="fd14d8ab490abe0a698ffc2511ce53075831cc54" translate="yes" xml:space="preserve">
          <source>Gets/sets the current test number we're on. You usually shouldn't have to set this.</source>
          <target state="translated">Gets/sets the current test number we're on.通常情况下,你不应该设置这个。</target>
        </trans-unit>
        <trans-unit id="3706dd8132de9e8897f7e90d7114484c9d4b2bb9" translate="yes" xml:space="preserve">
          <source>Gets/sets the number of tests we expect this test to run and prints out the appropriate headers.</source>
          <target state="translated">Gets/sets the number of tests we expect this test to run and printts out the appropriate headers.</target>
        </trans-unit>
        <trans-unit id="e92d34d8c771c7a84b714ba45ff28d98b8c6322f" translate="yes" xml:space="preserve">
          <source>Getter, used to get the value of the &lt;code&gt;foo&lt;/code&gt; field.</source>
          <target state="translated">Getter，用于获取 &lt;code&gt;foo&lt;/code&gt; 字段的值。</target>
        </trans-unit>
        <trans-unit id="f884a4b1be1eb753e1154cd093d629796012ffc9" translate="yes" xml:space="preserve">
          <source>Getter/setter for frontend object. Method just allows to subclass CPAN.pm.</source>
          <target state="translated">前台对象的getter/setter。该方法只允许子类CPAN.pm.Getter/setter。</target>
        </trans-unit>
        <trans-unit id="1acf2787a8aee315df9ae150576ddc4f44be77a7" translate="yes" xml:space="preserve">
          <source>Getter/setter for the &quot;generation&quot; of the test suite run. The first generation is 1 (one) and subsequent generations are 2, 3, etc.</source>
          <target state="translated">测试套件运行的 &quot;代 &quot;的getter/setter。第一代是1(1),随后的世代是2、3等。</target>
        </trans-unit>
        <trans-unit id="df0821c683786b3a185e90a15a8887e90823f964" translate="yes" xml:space="preserve">
          <source>Getter/setter for the instance of the &lt;code&gt;state_class&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;state_class&lt;/code&gt; 实例的Getter / setter 。</target>
        </trans-unit>
        <trans-unit id="5bf05902357ec950c574054f51b64aa64104327d" translate="yes" xml:space="preserve">
          <source>Getter/setter for the instance of the &lt;code&gt;state_class&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;state_class&lt;/code&gt; 实例的Getter / setter 。</target>
        </trans-unit>
        <trans-unit id="9d0a2a42561baa9a96f6b60d628e8035a5add88f" translate="yes" xml:space="preserve">
          <source>Getter/setter for the name of the class used for maintaining state. This class should either subclass from &lt;code&gt;App::Prove::State&lt;/code&gt; or provide an identical interface.</source>
          <target state="translated">获取器/设置器，用于维护状态的类的名称。此类应为 &lt;code&gt;App::Prove::State&lt;/code&gt; 子类，或提供相同的接口。</target>
        </trans-unit>
        <trans-unit id="f5b0e960fe4e828ae0c4af986bdc86fc8e330536" translate="yes" xml:space="preserve">
          <source>Getter/setter for the name of the class used for tracking test results. This class should either subclass from &lt;code&gt;App::Prove::State::Result&lt;/code&gt; or provide an identical interface.</source>
          <target state="translated">用于跟踪测试结果的类的名称的Getter / setter。此类应为 &lt;code&gt;App::Prove::State::Result&lt;/code&gt; 子类，或提供相同的接口。</target>
        </trans-unit>
        <trans-unit id="eabe8c9a6205eacd9d12103fd632a371642529ec" translate="yes" xml:space="preserve">
          <source>Getter/setter for the time of the test suite run.</source>
          <target state="translated">测试套件运行时间的getter/setter。</target>
        </trans-unit>
        <trans-unit id="6796c34d6d781e2d3a0ac04017b688fdbad6d325" translate="yes" xml:space="preserve">
          <source>Getting Started with Getopt::Long</source>
          <target state="translated">Getopt::Long入门</target>
        </trans-unit>
        <trans-unit id="efdcb676f7e4576e5bad658605652f36207e9edd" translate="yes" xml:space="preserve">
          <source>Getting Support</source>
          <target state="translated">获得支持</target>
        </trans-unit>
        <trans-unit id="1252190bfc7e0e95dec199e97b41cd19bd2e58b1" translate="yes" xml:space="preserve">
          <source>Getting changes into a maint branch</source>
          <target state="translated">将变更纳入主分支</target>
        </trans-unit>
        <trans-unit id="d63959139747b55549aaec776baaded768ee26b5" translate="yes" xml:space="preserve">
          <source>Getting every available name</source>
          <target state="translated">获取所有可用的名称</target>
        </trans-unit>
        <trans-unit id="36235f076eea8a428b643f4a70d6dbb8c2bed724" translate="yes" xml:space="preserve">
          <source>Getting perl source</source>
          <target state="translated">获取perl源代码</target>
        </trans-unit>
        <trans-unit id="dfa7f5176d7ce9da792b1bc4befb42509ca613ce" translate="yes" xml:space="preserve">
          <source>Getting the Perl Source for AmigaOS</source>
          <target state="translated">获取AmigaOS的Perl源代码</target>
        </trans-unit>
        <trans-unit id="ca13f2cfdfff6452c98f50feff43bb9608b60008" translate="yes" xml:space="preserve">
          <source>Getting the fat out of XSUBs</source>
          <target state="translated">去除XSUB的脂肪</target>
        </trans-unit>
        <trans-unit id="1e5b964707fd03837f1c6270f09aa1a8d502762e" translate="yes" xml:space="preserve">
          <source>Getting this message indicates that the outcome of the match arguably should have been the opposite of what actually happened. If you think that is the case, you may wish to make the &lt;code&gt;non_unicode&lt;/code&gt; warnings category fatal; if you agree with Perl's decision, you may wish to turn off this category.</source>
          <target state="translated">收到此消息表明，比赛的结果可能与实际发生的情况相反。如果您认为是这种情况，则不妨将 &lt;code&gt;non_unicode&lt;/code&gt; 警告类别设为致命类别；如果您同意Perl的决定，则不妨关闭此类别。</target>
        </trans-unit>
        <trans-unit id="c57b1bd007b42e02300f16d8e99034836448a153" translate="yes" xml:space="preserve">
          <source>Getting your patch accepted</source>
          <target state="translated">让您的补丁被接受</target>
        </trans-unit>
        <trans-unit id="80db569e43bb9df0657e208673f0728aa476a744" translate="yes" xml:space="preserve">
          <source>Gigantic thanks to Jarkko Hietaniemi, for agreeing to put this in the core when I hadn't written it yet, and for generally being helpful, supportive, and competent. (Usually the rule is &quot;choose any one.&quot;) Also big thanks to Abhijit Menon-Sen for all of the same things.</source>
          <target state="translated">非常感谢Jarkko Hietaniemi,在我还没有写的时候,他同意把这个放在核心区,并感谢他的帮助、支持和称职。(通常的规则是 &quot;任选其一&quot;。)也非常感谢Abhijit Menon-Sen,感谢他所做的同样的事情。</target>
        </trans-unit>
        <trans-unit id="c447f4baf429b1b41a12ae13b0f7bf296acd86b4" translate="yes" xml:space="preserve">
          <source>Gisle Aas &amp;lt;gisle@aas.no&amp;gt;</source>
          <target state="translated">吉斯尔&amp;middot;亚斯（Gisle Aas）&amp;lt;gisle@aas.no&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e2bf29bf784713e55d54fd683f2ddb22d16ebc1e" translate="yes" xml:space="preserve">
          <source>Gisle Aas made a number of improvements to the documentation for 2.07 and his advice and assistance is also greatly appreciated.</source>
          <target state="translated">Gisle Aas对2.07版本的文档做了一些改进,他的建议和帮助也非常感谢。</target>
        </trans-unit>
        <trans-unit id="d5205d4410276cc0ebead8a23281418d320e5d50" translate="yes" xml:space="preserve">
          <source>Gisle Aas's &quot;illustrated perlguts&quot;, also known as</source>
          <target state="translated">Gisle Aas的 &quot;插图perlguts&quot;,也就是所谓的</target>
        </trans-unit>
        <trans-unit id="8a1336646a79e293474d5da63f8a9e49f7c504c4" translate="yes" xml:space="preserve">
          <source>Give a seed the pseudorandom number generator, see &lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;.</source>
          <target state="translated">给种子提供伪随机数生成器，请参阅&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="111eb8faa37551d29f6ef39dc427825af2b24320" translate="yes" xml:space="preserve">
          <source>Give a seed the pseudorandom number generator, see &lt;a href=&quot;perlfunc#srand&quot;&gt;&quot;srand&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">给种子提供伪随机数生成器，请参阅&lt;a href=&quot;perlfunc#srand&quot;&gt;perlfunc中的&amp;ldquo; srand&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecbf54e25625127b374bd97fb6bf30d58f7f39f4" translate="yes" xml:space="preserve">
          <source>Give examples of use in your documentation</source>
          <target state="translated">举例说明在您的文件中的使用情况</target>
        </trans-unit>
        <trans-unit id="576b2bd7a5f1aafe83cdf1ff1d6086595bd3253e" translate="yes" xml:space="preserve">
          <source>Give meaningful error messages when a test fails.</source>
          <target state="translated">当测试失败时,给出有意义的错误信息。</target>
        </trans-unit>
        <trans-unit id="22362db21ca02fd220365037ef3ce1c3ae84669f" translate="yes" xml:space="preserve">
          <source>Give some example uses of the program or function. Don't skimp; users often find this the most useful part of the documentation. The examples are generally given as verbatim paragraphs.</source>
          <target state="translated">给出一些程序或函数的使用实例。不要吝啬;用户往往发现这是文档中最有用的部分。例子一般以逐字段的形式给出。</target>
        </trans-unit>
        <trans-unit id="50b41e662ea9282912cd0935127aa4fdcf1ffa2b" translate="yes" xml:space="preserve">
          <source>Give the module a version/issue/release number.</source>
          <target state="translated">给予该模块一个版本/问题/发布号。</target>
        </trans-unit>
        <trans-unit id="280f5d0aaefd1eefc611f50ae84a5b211fd8c124" translate="yes" xml:space="preserve">
          <source>Given 'tests' and optional 'rules' as input, returns a new &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; object. Each member of &lt;code&gt;@tests&lt;/code&gt; should be either a a test file name, or a two element arrayref, where the first element is a test file name, and the second element is a test description. By default, we'll use the test name as the description.</source>
          <target state="translated">给定&amp;ldquo;测试&amp;rdquo;和可选的&amp;ldquo;规则&amp;rdquo;作为输入，返回一个新的 &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; 对象。 &lt;code&gt;@tests&lt;/code&gt; 的每个成员应该是一个测试文件名，或者是两个元素的arrayref，其中第一个元素是测试文件名，第二个元素是测试描述。默认情况下，我们将测试名称用作描述。</target>
        </trans-unit>
        <trans-unit id="c200e634889ae19cc0bdab66baa6f148654f222f" translate="yes" xml:space="preserve">
          <source>Given -n, if there's a opt_n_with, it'll call $object-&amp;gt;opt_n_with( ARGUMENT ) (e.g., &quot;-n foo&quot; =&amp;gt; $object-&amp;gt;opt_n_with('foo'). Ditto &quot;-nfoo&quot;)</source>
          <target state="translated">给定-n，如果有opt_n_with，它将调用$ object-&amp;gt; opt_n_with（ARGUMENT）（例如，&amp;ldquo;-n foo&amp;rdquo; =&amp;gt; $ object-&amp;gt; opt_n_with（'foo'）。同上&amp;ldquo; -nfoo&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="88ad438932c9bdde0a7a6699aa6fd02d2661a215" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, returns the value &lt;code&gt;x - n*y&lt;/code&gt; , where &lt;code&gt;n&lt;/code&gt; is the integer closest to &lt;code&gt;&lt;a href=&quot;functions/x&quot;&gt;x/y&lt;/a&gt;&lt;/code&gt;. [C99]</source>
          <target state="translated">给定 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; ，返回值 &lt;code&gt;x - n*y&lt;/code&gt; ，其中 &lt;code&gt;n&lt;/code&gt; 是最接近 &lt;code&gt;&lt;a href=&quot;functions/x&quot;&gt;x/y&lt;/a&gt;&lt;/code&gt; 的整数。[C99]</target>
        </trans-unit>
        <trans-unit id="0a44544bbb8d81a603f952dfb3c5683ac4205665" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, returns the value &lt;code&gt;x - n*y&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the integer closest to &lt;code&gt;x&lt;/code&gt;/&lt;code&gt;y&lt;/code&gt;. [C99]</source>
          <target state="translated">给定 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; ，返回值 &lt;code&gt;x - n*y&lt;/code&gt; ，其中 &lt;code&gt;n&lt;/code&gt; 是最接近 &lt;code&gt;x&lt;/code&gt; / &lt;code&gt;y&lt;/code&gt; 的整数。[C99]</target>
        </trans-unit>
        <trans-unit id="4516641ce73c8bc0e4fc5ba5d53992584effc072" translate="yes" xml:space="preserve">
          <source>Given a $parser that's an object of class Pod::Simple::PullParser (or a subclass)...</source>
          <target state="translated">给定一个$parser是类Pod::Simple::PullParser(或子类)的对象...。</target>
        </trans-unit>
        <trans-unit id="29437e7d43f3cc0c11b41ed388b862563ac2a62f" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP::Parser::Source&lt;/a&gt;, detects what kind of source it is and returns</source>
          <target state="translated">给定&lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt;，检测它是哪种类型的源并返回</target>
        </trans-unit>
        <trans-unit id="8e13613226c18b55f5220f10848d744fb0086077" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP::Parser::Source&lt;/a&gt;, finds the most suitable &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; to use to create a &lt;a href=&quot;TAP::Parser::Iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt; (see &lt;a href=&quot;#detect_source&quot;&gt;&quot;detect_source&quot;&lt;/a&gt;). Dies on error.</source>
          <target state="translated">给定一个&lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP ::分析器::源&lt;/a&gt;，找到最合适的&lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP ::分析器:: SourceHandler&lt;/a&gt;用来创建一个&lt;a href=&quot;TAP::Parser::Iterator&quot;&gt;TAP ::分析器::迭代器&lt;/a&gt;（参见&lt;a href=&quot;#detect_source&quot;&gt;&amp;ldquo;detect_source&amp;rdquo;&lt;/a&gt;）。死于错误。</target>
        </trans-unit>
        <trans-unit id="8f7ab85a46c82118f02884a07c3492a612ad0bc1" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;source&quot;&gt;TAP::Parser::Source&lt;/a&gt;, detects what kind of source it is and returns</source>
          <target state="translated">给定&lt;a href=&quot;source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt;，检测它是哪种类型的源并返回</target>
        </trans-unit>
        <trans-unit id="b116ea0f536335d3865a0d04bc8e08d1c2acb6e8" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;source&quot;&gt;TAP::Parser::Source&lt;/a&gt;, finds the most suitable &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; to use to create a &lt;a href=&quot;iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt; (see &lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt;). Dies on error.</source>
          <target state="translated">给定&lt;a href=&quot;source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt;，找到最合适的&lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;来创建&lt;a href=&quot;iterator&quot;&gt;TAP :: Parser :: Iterator&lt;/a&gt;（请参见&lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt;）。死于错误。</target>
        </trans-unit>
        <trans-unit id="2fa07acc92ca3a34b050a1779c443de025ad8957" translate="yes" xml:space="preserve">
          <source>Given a Perl subroutine prototype, return a list of invocation specifications. Each specification is a listref, where the first member is the (minimum) number of arguments for this invocation specification. The remaining arguments are a string representation of how to pass the arguments correctly to a sub with the given prototype, when called with the given number of arguments.</source>
          <target state="translated">给定一个Perl子程序原型,返回一个调用规范的列表。每个规范是一个listref,其中第一个成员是这个调用规范的(最小)参数数。其余的参数是一个字符串表示,当用给定的参数数调用给定原型的子程序时,如何正确地将参数传递给该子程序。</target>
        </trans-unit>
        <trans-unit id="b30c1dfc72170a71448f9b395e9b03e816f03b3d" translate="yes" xml:space="preserve">
          <source>Given a PerlIO * create a 'native' FILE * suitable for passing to code expecting to be compiled and linked with ANSI C</source>
          <target state="translated">给定一个PerlIO *创建一个 &quot;native &quot;FILE *适合传递给期望被编译并与ANSI C链接的代码。</target>
        </trans-unit>
        <trans-unit id="34f965aed65d5f567330c1f887c60f3d7277e8d9" translate="yes" xml:space="preserve">
          <source>Given a chunk of memory, link it to the head of the list of arenas, and split it into a list of free SVs.</source>
          <target state="translated">给定一块内存,将其链接到场馆列表的头部,并将其分割成一个自由SV的列表。</target>
        </trans-unit>
        <trans-unit id="ea0db9ec916b80f6d45682cc0643494437b81c63" translate="yes" xml:space="preserve">
          <source>Given a function argument and the corresponding function value, store them into the cache.</source>
          <target state="translated">给定一个函数参数和相应的函数值,将它们存储到缓存中。</target>
        </trans-unit>
        <trans-unit id="368b29d6322d5568fa6515033d024e6d8d044278" translate="yes" xml:space="preserve">
          <source>Given a function argument, is the corresponding function value in the cache, and if so, is it fresh enough to use?</source>
          <target state="translated">给定一个函数参数,缓存中是否有相应的函数值,如果有,是否新鲜到可以使用?</target>
        </trans-unit>
        <trans-unit id="f996cfe932df1fdf5f95873d9c8a6b9f9b2d54ff" translate="yes" xml:space="preserve">
          <source>Given a function argument, look up the corresponding function value in the cache and return it.</source>
          <target state="translated">给定一个函数参数,在缓存中查找对应的函数值并返回。</target>
        </trans-unit>
        <trans-unit id="c3509e606900720895e02d9e89cbafec46d210bc" translate="yes" xml:space="preserve">
          <source>Given a key (&lt;code&gt;$key&lt;/code&gt; ) this method reads the value associated with it from the database. The value read from the database is returned in the &lt;code&gt;$value&lt;/code&gt; parameter.</source>
          <target state="translated">给定一个键（ &lt;code&gt;$key&lt;/code&gt; ），此方法从数据库中读取与其关联的值。从数据库读取的值将在 &lt;code&gt;$value&lt;/code&gt; 参数中返回。</target>
        </trans-unit>
        <trans-unit id="0a67beacc3582ff6ab21ef53a13b990116854b74" translate="yes" xml:space="preserve">
          <source>Given a key (&lt;code&gt;$key&lt;/code&gt;) this method reads the value associated with it from the database. The value read from the database is returned in the &lt;code&gt;$value&lt;/code&gt; parameter.</source>
          <target state="translated">给定一个键（ &lt;code&gt;$key&lt;/code&gt; ），此方法从数据库中读取与其关联的值。从数据库读取的值将在 &lt;code&gt;$value&lt;/code&gt; 参数中返回。</target>
        </trans-unit>
        <trans-unit id="e7f4f0181b47fc4d73d9cd3bbfb5acee403880eb" translate="yes" xml:space="preserve">
          <source>Given a list of args get the names of tests that should run</source>
          <target state="translated">给定一个args列表,得到应该运行的测试名称。</target>
        </trans-unit>
        <trans-unit id="16258c75193474948085fd76ec96dab72f546f03" translate="yes" xml:space="preserve">
          <source>Given a list of file names, strip out those that refer to a parent directory. (Does not strip symlinks, only '.', '..', and equivalents.)</source>
          <target state="translated">给定一个文件名列表,剥离那些指向父目录的文件。(不删除符号链接,只删除'.'、'.'和等价物。)</target>
        </trans-unit>
        <trans-unit id="9ef7fd99b0e4a8aa29f6aa6041cd8f8921cd8d25" translate="yes" xml:space="preserve">
          <source>Given a list of files in a directory (such as from &lt;code&gt;readdir()&lt;/code&gt;), strip out &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;'..'&lt;/code&gt;.</source>
          <target state="translated">给定目录中的文件列表（例如来自 &lt;code&gt;readdir()&lt;/code&gt; ），请删除 &lt;code&gt;'.'&lt;/code&gt; 和 &lt;code&gt;'..'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3018b6ffb20dcac62489facac809bddacf5bfb4" translate="yes" xml:space="preserve">
          <source>Given a list of identifiers, &lt;code&gt;embeddable_typemap&lt;/code&gt; tries to load typemaps from a file of the given name(s), or from a module that is an &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; subclass.</source>
          <target state="translated">给定一个标识符列表， &lt;code&gt;embeddable_typemap&lt;/code&gt; 尝试从给定名称的文件或 &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; 子类的模块中加载typemap。</target>
        </trans-unit>
        <trans-unit id="3f60dd44db71eb2a881f946f782f7b4489542b29" translate="yes" xml:space="preserve">
          <source>Given a list of scalars or reference variables, writes out their contents in perl syntax. The references can also be objects. The content of each variable is output in a single Perl statement. Handles self-referential structures correctly.</source>
          <target state="translated">给定一个标量或引用变量列表,用perl语法写出其内容。引用也可以是对象。每个变量的内容都会在一条Perl语句中输出。正确处理自引用结构。</target>
        </trans-unit>
        <trans-unit id="3e530c4f306640476d631e5c36d6a2f051774865" translate="yes" xml:space="preserve">
          <source>Given a name or number that could appear in a &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; sequence, this returns the number of the Unicode character that this stands for. For example, &lt;code&gt;e2char('sol')&lt;/code&gt; , &lt;code&gt;e2char('47')&lt;/code&gt; , &lt;code&gt;e2char('0x2F')&lt;/code&gt; , and &lt;code&gt;e2char('057')&lt;/code&gt; all return 47, because &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; , and &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; , all mean &quot;/&quot;, whose Unicode number is 47. If the name has no known value (as with a name of &quot;qacute&quot;) or is syntactically invalid (as with a name of &quot;1/4&quot;), this returns undef.</source>
          <target state="translated">给定一个可能以 &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; 序列出现的名称或数字，这将返回其代表的Unicode字符的编号。例如， &lt;code&gt;e2char('sol')&lt;/code&gt; ， &lt;code&gt;e2char('47')&lt;/code&gt; ， &lt;code&gt;e2char('0x2F')&lt;/code&gt; 和 &lt;code&gt;e2char('057')&lt;/code&gt; 都返回47，因为 &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; 和 &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; 均表示&amp;ldquo; /&amp;rdquo;，其Unicode编号为47。如果该名称没有已知值（如名称&amp;ldquo; qacute&amp;rdquo;）或在语法上无效（如名称&amp;ldquo; 1/4&amp;rdquo;） &amp;rdquo;），则返回undef。</target>
        </trans-unit>
        <trans-unit id="af20a3b02e35b18386f4530792c069877997ab32" translate="yes" xml:space="preserve">
          <source>Given a name or number that could appear in a &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; sequence, this returns the number of the Unicode character that this stands for. For example, &lt;code&gt;e2char('sol')&lt;/code&gt;, &lt;code&gt;e2char('47')&lt;/code&gt;, &lt;code&gt;e2char('0x2F')&lt;/code&gt;, and &lt;code&gt;e2char('057')&lt;/code&gt; all return 47, because &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt;, &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt;, &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt;, and &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt;, all mean &quot;/&quot;, whose Unicode number is 47. If the name has no known value (as with a name of &quot;qacute&quot;) or is syntactically invalid (as with a name of &quot;1/4&quot;), this returns undef.</source>
          <target state="translated">给定一个可能以 &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; 序列出现的名称或数字，这将返回其代表的Unicode字符的编号。例如， &lt;code&gt;e2char('sol')&lt;/code&gt; ， &lt;code&gt;e2char('47')&lt;/code&gt; ， &lt;code&gt;e2char('0x2F')&lt;/code&gt; 和 &lt;code&gt;e2char('057')&lt;/code&gt; 都返回47，因为 &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; 和 &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; 均表示&amp;ldquo; /&amp;rdquo;，其Unicode编号为47。如果该名称没有已知值（如名称&amp;ldquo; qacute&amp;rdquo;）或在语法上无效（如名称&amp;ldquo; 1/4&amp;rdquo;） &amp;rdquo;），则返回undef。</target>
        </trans-unit>
        <trans-unit id="2023da106c6aa26bd0acc5076b02991c20277361" translate="yes" xml:space="preserve">
          <source>Given a name or number that could appear in a &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; sequence, this returns the string that it stands for. For example, &lt;code&gt;e2char('sol')&lt;/code&gt; , &lt;code&gt;e2char('47')&lt;/code&gt; , &lt;code&gt;e2char('0x2F')&lt;/code&gt; , and &lt;code&gt;e2char('057')&lt;/code&gt; all return &quot;/&quot;, because &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; , and &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; , all mean &quot;/&quot;. If the name has no known value (as with a name of &quot;qacute&quot;) or is syntactically invalid (as with a name of &quot;1/4&quot;), this returns undef.</source>
          <target state="translated">给定可能以 &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; 序列出现的名称或数字，这将返回其代表的字符串。例如， &lt;code&gt;e2char('sol')&lt;/code&gt; ， &lt;code&gt;e2char('47')&lt;/code&gt; ， &lt;code&gt;e2char('0x2F')&lt;/code&gt; 和 &lt;code&gt;e2char('057')&lt;/code&gt; 都返回&amp;ldquo; /&amp;rdquo;，因为 &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; 和 &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; 均表示&amp;ldquo; /&amp;rdquo;。如果名称没有已知值（如名称&amp;ldquo; qacute&amp;rdquo;）或语法上无效（如名称&amp;ldquo; 1/4&amp;rdquo;），则返回undef。</target>
        </trans-unit>
        <trans-unit id="d6238b6c70a7beedaa2b47d1c70942578995fe2d" translate="yes" xml:space="preserve">
          <source>Given a name or number that could appear in a &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; sequence, this returns the string that it stands for. For example, &lt;code&gt;e2char('sol')&lt;/code&gt;, &lt;code&gt;e2char('47')&lt;/code&gt;, &lt;code&gt;e2char('0x2F')&lt;/code&gt;, and &lt;code&gt;e2char('057')&lt;/code&gt; all return &quot;/&quot;, because &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt;, &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt;, &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt;, and &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt;, all mean &quot;/&quot;. If the name has no known value (as with a name of &quot;qacute&quot;) or is syntactically invalid (as with a name of &quot;1/4&quot;), this returns undef.</source>
          <target state="translated">给定一个可能以 &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; 序列出现的名称或数字，这将返回其代表的字符串。例如， &lt;code&gt;e2char('sol')&lt;/code&gt; ， &lt;code&gt;e2char('47')&lt;/code&gt; ， &lt;code&gt;e2char('0x2F')&lt;/code&gt; ，和 &lt;code&gt;e2char('057')&lt;/code&gt; 的所有返回&amp;ldquo;/&amp;rdquo;，因为 &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; 和 &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; 均表示&amp;ldquo; /&amp;rdquo;。如果名称没有已知值（如名称&amp;ldquo; qacute&amp;rdquo;）或语法上无效（如名称&amp;ldquo; 1/4&amp;rdquo;），则返回undef。</target>
        </trans-unit>
        <trans-unit id="f8fab49b7e67f8e8512bb770d5fecfb47a79348d" translate="yes" xml:space="preserve">
          <source>Given a package name and a hashref mapping names to a subroutine reference (or &lt;code&gt;undef&lt;/code&gt;), this subroutine will install said subroutines on their given name in that module. If a name mapes to &lt;code&gt;undef&lt;/code&gt;, any subroutine with that name in the target module will be remove (possibly &quot;unshadowing&quot; a CORE sub of same name).</source>
          <target state="translated">给定包名和将hashref映射到子例程引用（或 &lt;code&gt;undef&lt;/code&gt; ）的名称，此子例程将在所述模块中的给定名称上安装所述子例程。如果名称映射到 &lt;code&gt;undef&lt;/code&gt; ，则将删除目标模块中具有该名称的任何子例程（可能会&amp;ldquo;取消阴影化&amp;rdquo;具有相同名称的CORE子例程）。</target>
        </trans-unit>
        <trans-unit id="68ff8a7e4af810b7a363c9f43756d64a041cba7a" translate="yes" xml:space="preserve">
          <source>Given a packed socket address (such as from getsockname(), getpeername(), or returned by getaddrinfo() in a &lt;code&gt;addr&lt;/code&gt; field), returns the hostname and symbolic service name it represents. $flags may be a bitmask of &lt;code&gt;NI_*&lt;/code&gt; constants, or defaults to 0 if unspecified.</source>
          <target state="translated">给定一个压缩的套接字地址（例如从getsockname（），getpeername（）或在 &lt;code&gt;addr&lt;/code&gt; 字段中由getaddrinfo（）返回），返回其表示的主机名和符号服务名。$ flags可以是 &lt;code&gt;NI_*&lt;/code&gt; 常量的位掩码，如果未指定，则默认为0。</target>
        </trans-unit>
        <trans-unit id="51657afc8f82d4e3d689a9ad42ae81c82da15acf" translate="yes" xml:space="preserve">
          <source>Given a pathname to a file containing metadata, this deserializes the file according to its file suffix and constructs a new &lt;code&gt;CPAN::Meta&lt;/code&gt; object, just like &lt;code&gt;new()&lt;/code&gt;. It will die if the deserialized version fails to validate against its stated specification version.</source>
          <target state="translated">给定包含元数据的文件的路径名，这将根据文件的文件后缀反序列化该文件，并构造一个新的 &lt;code&gt;CPAN::Meta&lt;/code&gt; 对象，就像 &lt;code&gt;new()&lt;/code&gt; 一样。如果反序列化版本未能根据其指定的规范版本进行验证，则它将死亡。</target>
        </trans-unit>
        <trans-unit id="b3ab833b08cd320284ae184893dbedaee3a8efff" translate="yes" xml:space="preserve">
          <source>Given a pointer to an &lt;code&gt;SV&lt;/code&gt; and an &lt;code&gt;=~&lt;/code&gt; operation (e.g., &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/bob/robert/g&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[A-Z][a-z]&lt;/a&gt;&lt;/code&gt;), substitute() modifies the string within the &lt;code&gt;SV&lt;/code&gt; as according to the operation, returning the number of substitutions made.</source>
          <target state="translated">给定指向 &lt;code&gt;SV&lt;/code&gt; 的指针和 &lt;code&gt;=~&lt;/code&gt; 操作（例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/bob/robert/g&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[A-Z][a-z]&lt;/a&gt;&lt;/code&gt; ），replace（）会根据该操作修改 &lt;code&gt;SV&lt;/code&gt; 中的字符串，并返回替换。</target>
        </trans-unit>
        <trans-unit id="dde32d4642dd76d6903ddcba2cd4f3588999395c" translate="yes" xml:space="preserve">
          <source>Given a pointer to an &lt;code&gt;SV&lt;/code&gt; and an &lt;code&gt;=~&lt;/code&gt; operation (e.g., &lt;code&gt;s/bob/robert/g&lt;/code&gt; or &lt;code&gt;tr[A-Z][a-z]&lt;/code&gt;), substitute() modifies the string within the &lt;code&gt;SV&lt;/code&gt; as according to the operation, returning the number of substitutions made.</source>
          <target state="translated">给定指向 &lt;code&gt;SV&lt;/code&gt; 的指针和 &lt;code&gt;=~&lt;/code&gt; 操作（例如 &lt;code&gt;s/bob/robert/g&lt;/code&gt; 或 &lt;code&gt;tr[A-Z][a-z]&lt;/code&gt; ），replace（）根据该操作修改 &lt;code&gt;SV&lt;/code&gt; 中的字符串，并返回替换。</target>
        </trans-unit>
        <trans-unit id="7df1b1c7c83c78e200c9f9cd553763264fc01f76" translate="yes" xml:space="preserve">
          <source>Given a string and a pattern (e.g., &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/clasp/&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;/\b\w*\b/&lt;/code&gt; , which in your C program might appear as &quot;/\\b\\w*\\b/&quot;), match() returns 1 if the string matches the pattern and 0 otherwise.</source>
          <target state="translated">给定一个字符串和一个模式（例如 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/clasp/&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;/\b\w*\b/&lt;/code&gt; ，在您的C程序中可能会显示为&amp;ldquo; / \\ b \\ w * \\ b /&amp;rdquo;），match（ ）如果字符串与模式匹配，则返回1，否则返回0。</target>
        </trans-unit>
        <trans-unit id="c421180a417152f6c0674618188b29d3743dbc39" translate="yes" xml:space="preserve">
          <source>Given a string and a pattern (e.g., &lt;code&gt;m/clasp/&lt;/code&gt; or &lt;code&gt;/\b\w*\b/&lt;/code&gt;, which in your C program might appear as &quot;/\\b\\w*\\b/&quot;), match() returns 1 if the string matches the pattern and 0 otherwise.</source>
          <target state="translated">给定一个字符串和一个模式（例如 &lt;code&gt;m/clasp/&lt;/code&gt; 或 &lt;code&gt;/\b\w*\b/&lt;/code&gt; ，在您的C程序中可能会显示为&amp;ldquo; / \\ b \\ w * \\ b /&amp;rdquo;），match（ ）如果字符串与模式匹配，则返回1，否则返回0。</target>
        </trans-unit>
        <trans-unit id="c8f74abc4a59a56ab26c7b6afd4629bc292ce127" translate="yes" xml:space="preserve">
          <source>Given a string, a base, and an optional collation sequence, interpret the string as a number in the given base. The collation sequence describes the value of each character in the string.</source>
          <target state="translated">给定一个字符串、一个基数和一个可选的整理序列,将字符串解释为给定基数中的一个数字。整理序列描述了字符串中每个字符的值。</target>
        </trans-unit>
        <trans-unit id="cb2d005ca978881d5ba03242206b93769db89d30" translate="yes" xml:space="preserve">
          <source>Given a template, returns a filehandle to the temporary file and the name of the file.</source>
          <target state="translated">给定一个模板,返回一个临时文件的文件柄和文件名。</target>
        </trans-unit>
        <trans-unit id="f3247eafd3bd6b87dad8bb050e03ecb6550fab7f" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;SV&lt;/code&gt; , a pattern, and a pointer to an empty &lt;code&gt;AV&lt;/code&gt; , matches() evaluates &lt;code&gt;$string =~ $pattern&lt;/code&gt; in a list context, and fills in</source>
          <target state="translated">给定一个 &lt;code&gt;SV&lt;/code&gt; ，一个模式和一个指向空 &lt;code&gt;AV&lt;/code&gt; 的指针，matches（）在列表上下文中计算 &lt;code&gt;$string =~ $pattern&lt;/code&gt; ，并填写</target>
        </trans-unit>
        <trans-unit id="34e4f6e5dbaf1b34751d051563b1ed427ee41229" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;SV&lt;/code&gt;, a pattern, and a pointer to an empty &lt;code&gt;AV&lt;/code&gt;, matches() evaluates &lt;code&gt;$string =~ $pattern&lt;/code&gt; in a list context, and fills in</source>
          <target state="translated">给定一个 &lt;code&gt;SV&lt;/code&gt; ，一个模式和一个指向空 &lt;code&gt;AV&lt;/code&gt; 的指针，matches（）在列表上下文中计算 &lt;code&gt;$string =~ $pattern&lt;/code&gt; ，并填写</target>
        </trans-unit>
        <trans-unit id="30244b464969efb78e9259f1691d48f7c1b175b6" translate="yes" xml:space="preserve">
          <source>Given an OS type and OS name, returns true or false if the OS name is of the given type. As with &lt;code&gt;os_type&lt;/code&gt;, it will use the current operating system as a default if no OS name is provided.</source>
          <target state="translated">给定操作系统类型和操作系统名称，如果操作系统名称为给定类型，则返回true或false。与 &lt;code&gt;os_type&lt;/code&gt; 一样，如果未提供OS名称，它将使用当前操作系统作为默认操作系统。</target>
        </trans-unit>
        <trans-unit id="d73be34ecb8afbc83a1abc326b027cd0e5ff7367" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies an element of a hash, returns true if the specified element in the hash has ever been initialized, even if the corresponding value is undefined.</source>
          <target state="translated">给定一个表达式,指定一个哈希元素,如果哈希中指定的元素曾经被初始化,则返回true,即使对应的值是未定义的。</target>
        </trans-unit>
        <trans-unit id="7378726c80d5aab2e860c98baf7c2cd0aceca44a" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies an element or slice of a hash, &lt;a href=&quot;#delete-EXPR&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; deletes the specified elements from that hash so that &lt;a href=&quot;#exists-EXPR&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; on that element no longer returns true. Setting a hash element to the undefined value does not remove its key, but deleting it does; see &lt;a href=&quot;#exists-EXPR&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">给定一个指定散列元素或切片的表达式，&lt;a href=&quot;#delete-EXPR&quot;&gt; &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt;将从该散列中删除指定的元素，以便该元素上&lt;a href=&quot;#exists-EXPR&quot;&gt; &lt;code&gt;exists&lt;/code&gt; &lt;/a&gt;元素不再返回true。将哈希元素设置为未定义的值不会删除其键，但是删除它会删除它。看到&lt;a href=&quot;#exists-EXPR&quot;&gt; &lt;code&gt;exists&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3860c44bdd22a4566d9e655bb9fabca95c5a3818" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies an element or slice of a hash, &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; deletes the specified elements from that hash so that exists() on that element no longer returns true. Setting a hash element to the undefined value does not remove its key, but deleting it does; see &lt;a href=&quot;exists&quot;&gt;exists&lt;/a&gt;.</source>
          <target state="translated">给定一个指定元素或哈希切片的表达式， &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 将从该哈希中删除指定的元素，以便该元素上的exist（）不再返回true。将哈希元素设置为未定义的值不会删除其键，但是删除它会删除它。看到&lt;a href=&quot;exists&quot;&gt;存在&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c148d1ff0a7aebcb28822b3e1311889c861ad3aa" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies an element or slice of a hash, &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; deletes the specified elements from that hash so that exists() on that element no longer returns true. Setting a hash element to the undefined value does not remove its key, but deleting it does; see &lt;a href=&quot;#exists&quot;&gt;exists&lt;/a&gt;.</source>
          <target state="translated">给定一个指定元素或哈希切片的表达式， &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 将从该哈希中删除指定的元素，以便该元素上的exist（）不再返回true。将哈希元素设置为未定义的值不会删除其键，但是删除它会删除它。看到&lt;a href=&quot;#exists&quot;&gt;存在&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b769dfb6b889a385d12cb35d230597545507bff1" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies the name of a subroutine, returns true if the specified subroutine has ever been declared, even if it is undefined. Mentioning a subroutine name for exists or defined does not count as declaring it. Note that a subroutine that does not exist may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;../perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">给定一个指定子例程名称的表达式，即使已声明了指定的子例程，即使未定义，也返回true。提及存在或已定义的子例程名称不算作声明它。请注意，不存在的子例程可能仍然可以调用：其程序包可能具有 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法，该方法使它在第一次调用时就存在；参见&lt;a href=&quot;../perlsub&quot;&gt;perlsub&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e2f23a5798654b28edd73d121507fc1d6cf61ce" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies the name of a subroutine, returns true if the specified subroutine has ever been declared, even if it is undefined. Mentioning a subroutine name for exists or defined does not count as declaring it. Note that a subroutine that does not exist may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">给定一个指定子例程名称的表达式，即使已声明了指定的子例程，即使未定义，也返回true。提及存在或已定义的子例程名称不算作声明它。请注意，不存在的子例程可能仍然可以调用：其程序包可能具有 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法，该方法使它在第一次调用时就存在；参见&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6382657811b5dffd947e094b3c4ab1d16ffe89f3" translate="yes" xml:space="preserve">
          <source>Given an module and version, this method returns true if the version specification for the module accepts the provided version. In other words, given:</source>
          <target state="translated">给定一个模块和版本,如果模块的版本规范接受所提供的版本,本方法返回true。换句话说,如果给定。</target>
        </trans-unit>
        <trans-unit id="ec3e095107124a6ef85e395cac4af42d46355e9a" translate="yes" xml:space="preserve">
          <source>Given an object, return a Perl scalar number (int/float) representing this number.</source>
          <target state="translated">给定一个对象,返回一个代表这个数字的Perl标量数(int/float)。</target>
        </trans-unit>
        <trans-unit id="870f76963fd88871e6f7f23d8316a36c5a9dba60" translate="yes" xml:space="preserve">
          <source>Given an op, determine what type of struct it has been allocated as. Returns one of the OPclass enums, such as OPclass_LISTOP.</source>
          <target state="translated">给定一个 op,确定它被分配为什么类型的结构。返回OPclass的一个枚举,如OPclass_LISTOP。</target>
        </trans-unit>
        <trans-unit id="798afe5be4d4f8caba61172a6204d0e7a4433382" translate="yes" xml:space="preserve">
          <source>Given an open filehandle and the associated filename, make a safe unlink. This is achieved by first checking that the filename and filehandle initially point to the same file and that the number of links to the file is 1 (all fields returned by stat() are compared). Then the filename is unlinked and the filehandle checked once again to verify that the number of links on that file is now 0. This is the closest you can come to making sure that the filename unlinked was the same as the file whose descriptor you hold.</source>
          <target state="translated">给定一个打开的文件柄和相关的文件名,进行安全的解除链接。首先检查文件名和filehandle最初是否指向同一个文件,并且该文件的链接数为1(比较stat()返回的所有字段)。然后解除文件名的链接,并再次检查filehandle,以验证该文件上的链接数现在为0。这是最接近于确保被解除链接的文件名与你持有的描述符的文件相同的方法。</target>
        </trans-unit>
        <trans-unit id="7c8d7de16830e305c76870f7520f278ced8e53b9" translate="yes" xml:space="preserve">
          <source>Given both a hostname and service name, this function attempts to resolve the host name into a list of network addresses, and the service name into a protocol and port number, and then returns a list of address structures suitable to connect() to it.</source>
          <target state="translated">给定主机名和服务名,该函数试图将主机名解析为网络地址列表,将服务名解析为协议和端口号,然后返回适合连接()到它的地址结构列表。</target>
        </trans-unit>
        <trans-unit id="ef7becd595d52be668be1e1f52b6edfa071be390" translate="yes" xml:space="preserve">
          <source>Given just a host name, this function attempts to resolve it to a list of network addresses, and then returns a list of address structures giving these addresses.</source>
          <target state="translated">只给定一个主机名,这个函数试图将其解析为一个网络地址列表,然后返回一个给出这些地址的地址结构列表。</target>
        </trans-unit>
        <trans-unit id="df00cd802473947a22a033a5fee10eaeb326c652" translate="yes" xml:space="preserve">
          <source>Given just a service name, this function attempts to resolve it to a protocol and port number, and then returns a list of address structures that represent it suitable to bind() to. This use should be combined with the &lt;code&gt;AI_PASSIVE&lt;/code&gt; flag; see below.</source>
          <target state="translated">仅提供服务名称，此函数尝试将其解析为协议和端口号，然后返回表示适合将其绑定到的地址结构的列表。此用法应与 &lt;code&gt;AI_PASSIVE&lt;/code&gt; 标志结合使用；见下文。</target>
        </trans-unit>
        <trans-unit id="47c398084bf96dcff46eefda9cdadf3fedccfe90" translate="yes" xml:space="preserve">
          <source>Given neither name, it generates an error.</source>
          <target state="translated">给定两个名字都没有,就会产生一个错误。</target>
        </trans-unit>
        <trans-unit id="f45002ae2a4c5c351051e308f1722b6d19c35a8d" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;IO::Socket&lt;/code&gt; doesn't have attributes in the traditional sense, the following arguments, rather than attributes, can be passed into the constructor.</source>
          <target state="translated">鉴于 &lt;code&gt;IO::Socket&lt;/code&gt; 没有传统意义上的属性，可以将以下参数（而不是属性）传递给构造函数。</target>
        </trans-unit>
        <trans-unit id="4946a614ce699917e8a48264ad588e74a71edfe3" translate="yes" xml:space="preserve">
          <source>Given that the file glob is just a cut-down regular expression and that it has already done a lot of the hard work in pattern matching the filenames, wouldn't it be handy to be able to use the patterns in the fileglob to drive the new filename?</source>
          <target state="translated">考虑到文件glob只是一个裁剪下来的正则表达式,而且它已经在模式匹配文件名方面做了很多艰苦的工作,如果能够使用文件glob中的模式来驱动新的文件名,是不是很方便呢?</target>
        </trans-unit>
        <trans-unit id="1a0688e5deb209d4898cf79e8c4e93da364593b3" translate="yes" xml:space="preserve">
          <source>Given that we failed to load &lt;code&gt;Compress::Zlib&lt;/code&gt; and that the use of an external</source>
          <target state="translated">鉴于我们未能加载 &lt;code&gt;Compress::Zlib&lt;/code&gt; 并且使用了外部</target>
        </trans-unit>
        <trans-unit id="5ce5ab9c8a60a3017b27b9d131c486b0a52e2973" translate="yes" xml:space="preserve">
          <source>Given the filename and description of a test as scalars, returns a new &lt;a href=&quot;TAP::Parser::Scheduler::Job&quot;&gt;TAP::Parser::Scheduler::Job&lt;/a&gt; object.</source>
          <target state="translated">给定文件名和描述为标量的测试，返回一个新的&lt;a href=&quot;TAP::Parser::Scheduler::Job&quot;&gt;TAP :: Parser :: Scheduler :: Job&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="25d0946db041e6b8ec000e3934554230eea3d997" translate="yes" xml:space="preserve">
          <source>Given the filename and description of a test as scalars, returns a new &lt;a href=&quot;job&quot;&gt;TAP::Parser::Scheduler::Job&lt;/a&gt; object.</source>
          <target state="translated">给定文件名和描述为标量的测试，返回一个新的&lt;a href=&quot;job&quot;&gt;TAP :: Parser :: Scheduler :: Job&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="8321e912ffb7fc1712a163f5114b8b8cfc71ea6c" translate="yes" xml:space="preserve">
          <source>Given the following module, PerlIO::via::Hex :</source>
          <target state="translated">给出以下模块,PerlIO::via::Hex 。</target>
        </trans-unit>
        <trans-unit id="b1732b671f9a08843781c433880de7a9be2cae19" translate="yes" xml:space="preserve">
          <source>Given the following notations:</source>
          <target state="translated">鉴于以下记述:</target>
        </trans-unit>
        <trans-unit id="d2cba25d77a3267a4c7e81b67be7cfba4a549ed5" translate="yes" xml:space="preserve">
          <source>Given the name of a lexical variable, find its position in the currently-compiling pad.</source>
          <target state="translated">给定一个词汇变量的名称,找到它在当前编译垫中的位置。</target>
        </trans-unit>
        <trans-unit id="ddfa3d7772a86897b1ef912922a5efcc3e61e15d" translate="yes" xml:space="preserve">
          <source>Given the name of a lexical variable, find its position in the currently-compiling pad. &lt;code&gt;namepv&lt;/code&gt;/&lt;code&gt;namelen&lt;/code&gt; specify the variable's name, including leading sigil. &lt;code&gt;flags&lt;/code&gt; is reserved and must be zero. If it is not in the current pad but appears in the pad of any lexically enclosing scope, then a pseudo-entry for it is added in the current pad. Returns the offset in the current pad, or &lt;code&gt;NOT_IN_PAD&lt;/code&gt; if no such lexical is in scope.</source>
          <target state="translated">给定一个词法变量的名称，在当前编译区中找到它的位置。 &lt;code&gt;namepv&lt;/code&gt; / &lt;code&gt;namelen&lt;/code&gt; 指定变量的名称，包括前导符号。 &lt;code&gt;flags&lt;/code&gt; 是保留的，并且必须为零。如果它不在当前填充板中，但出现在任何词法包围范围的填充板中，则将其伪条目添加到当前填充板中。返回当前填充中的偏移量；如果范围内没有此类词汇，则返回 &lt;code&gt;NOT_IN_PAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e332da4ace4bc5d01c9ceda2ce9f67dcc253135" translate="yes" xml:space="preserve">
          <source>Given the root of an optree, link the tree in execution order using the &lt;code&gt;op_next&lt;/code&gt; pointers and return the first op executed. If this has already been done, it will not be redone, and &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; will be returned. If &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; is not already set,</source>
          <target state="translated">给定optree的根，使用 &lt;code&gt;op_next&lt;/code&gt; 指针按执行顺序链接树，并返回第一个执行的op。如果已经完成，则不会重做，并且将返回 &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; 。如果尚未设置 &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="97fc21e2d92a8ed7b6cc7a68fbab927d533b3225" translate="yes" xml:space="preserve">
          <source>Given the root of an optree, link the tree in execution order using the &lt;code&gt;op_next&lt;/code&gt; pointers and return the first op executed. If this has already been done, it will not be redone, and &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; will be returned. If &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; is not already set, &lt;code&gt;o&lt;/code&gt; should be at least an &lt;code&gt;UNOP&lt;/code&gt;.</source>
          <target state="translated">给定操作树的根，使用 &lt;code&gt;op_next&lt;/code&gt; 指针按执行顺序链接树，并返回第一个执行的操作。如果已经完成，则不会重做，并且将返回 &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; 。如果尚未设置 &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; ，则 &lt;code&gt;o&lt;/code&gt; 至少应为 &lt;code&gt;UNOP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="084725aa23e7fe3c0d543b97b1c7320210101746" translate="yes" xml:space="preserve">
          <source>Given the sheer volume of Perl documentation, this isn't a trivial undertaking, but if you can point to documentation that suggests the behaviour you're seeing is</source>
          <target state="translated">考虑到Perl文档的数量,这并不是一项简单的工作,但如果你能指出你所看到的行为属于</target>
        </trans-unit>
        <trans-unit id="a51193d192cf9332f4f5d4257e036cab9b0cff3c" translate="yes" xml:space="preserve">
          <source>Given this as an input string in a scalar context, &lt;code&gt;extract_quotelike&lt;/code&gt; would correctly return the string &quot;&amp;lt;&amp;lt;'EOMSG'\nThis is the message.\nEOMSG&quot;, leaving the string &quot; || die;\nexit;&quot; in the original variable. In other words, the two separate pieces of the here document are successfully extracted and concatenated.</source>
          <target state="translated">将此作为标量上下文中的输入字符串， &lt;code&gt;extract_quotelike&lt;/code&gt; 将正确返回字符串&amp;ldquo; &amp;lt;&amp;lt;'EOMSG'\ n这是消息。\ nEOMSG&amp;rdquo;，保留字符串&amp;ldquo; || die; \ nexit;&amp;rdquo; 在原始变量中。换句话说，此处文档的两个单独部分已成功提取并连接在一起。</target>
        </trans-unit>
        <trans-unit id="a8255eb67db18215cafd66b8bf6854ff058e58c2" translate="yes" xml:space="preserve">
          <source>Given two perl versions, this returns a list of pairs describing the changes in core module content between them. The list is suitable for storing in a hash. The keys are library names and the values are hashrefs. Each hashref has an entry for one or both of &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; , giving the versions of the library in each of the left and right perl distributions.</source>
          <target state="translated">给定两个perl版本，这将返回一对列表，描述它们之间核心模块内容的变化。该列表适合存储在哈希中。键是库名，值是哈希引用。每个hashref都有一个用于 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 中的一个或两个的条目，从而在左侧和右侧的perl发行版中提供库的版本。</target>
        </trans-unit>
        <trans-unit id="5524306bde34808c7bf3694140f34edc02ea15fa" translate="yes" xml:space="preserve">
          <source>Given two perl versions, this returns a list of pairs describing the changes in core module content between them. The list is suitable for storing in a hash. The keys are library names and the values are hashrefs. Each hashref has an entry for one or both of &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;, giving the versions of the library in each of the left and right perl distributions.</source>
          <target state="translated">给定两个perl版本，这将返回一对列表，描述它们之间核心模块内容的变化。该列表适合存储在哈希中。键是库名，值是哈希引用。每个hashref都有一个用于 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 之一或二者的条目，从而在左侧和右侧的perl发行版中提供库的版本。</target>
        </trans-unit>
        <trans-unit id="d3e8e0d7ce171e4fc80eeb08f47d5a4cc76a6ae2" translate="yes" xml:space="preserve">
          <source>Given two versions of perl, this prints a human-readable table of all module changes between the two. The output format may change in the future, and is meant for</source>
          <target state="translated">给定两个版本的perl,这将打印出两个版本之间所有模块变化的可读表。输出格式可能会在将来发生变化,并且是用于</target>
        </trans-unit>
        <trans-unit id="d8e6036259b26c2d9989b981df7306264ca46f69" translate="yes" xml:space="preserve">
          <source>Gives a description of each test prior to performing it.</source>
          <target state="translated">在进行每项测试之前,对其进行描述。</target>
        </trans-unit>
        <trans-unit id="95e8be14901e94fb491dfdf5b70ee1b95c0f63d7" translate="yes" xml:space="preserve">
          <source>Gives more detailed information about each test, after it has been performed. Note that any failed tests ought to print out some extra information whether or not -v is thrown.</source>
          <target state="translated">在每个测试完成后,提供更详细的信息。注意,无论是否抛出-v,任何失败的测试都应该打印出一些额外的信息。</target>
        </trans-unit>
        <trans-unit id="8cd5accb9bbe824d3f2172984bdf0c7f749a0330" translate="yes" xml:space="preserve">
          <source>Gives the information about the Perl DLL or the DLL containing the C function bound to by &lt;code&gt;&amp;amp;xsub&lt;/code&gt; . The meaning of &lt;code&gt;how&lt;/code&gt; is: default (2): full name; 0: handle; 1: module name.</source>
          <target state="translated">提供有关Perl DLL或包含 &lt;code&gt;&amp;amp;xsub&lt;/code&gt; 绑定的C函数的DLL的信息。的含义 &lt;code&gt;how&lt;/code&gt; 为：默认（2）：全名; 0：句柄；1：模块名称。</target>
        </trans-unit>
        <trans-unit id="1bcbcfb87cf34f833fbb8de6ef0d85359b318960" translate="yes" xml:space="preserve">
          <source>Gives the information about the Perl DLL or the DLL containing the C function bound to by &lt;code&gt;&amp;amp;xsub&lt;/code&gt;. The meaning of &lt;code&gt;how&lt;/code&gt; is: default (2): full name; 0: handle; 1: module name.</source>
          <target state="translated">提供有关Perl DLL或包含 &lt;code&gt;&amp;amp;xsub&lt;/code&gt; 绑定的C函数的DLL的信息。的含义 &lt;code&gt;how&lt;/code&gt; 为：默认（2）：全名; 0：句柄；1：模块名称。</target>
        </trans-unit>
        <trans-unit id="9ce00937b225bda0f6de7705049c711ca2d0c0b1" translate="yes" xml:space="preserve">
          <source>Gives the string value of &lt;code&gt;arg&lt;/code&gt; as in the absence of stringify overloading. If you are using this to get the address of a reference (useful for checking if two references point to the same thing) then you may be better off using &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; , which is faster.</source>
          <target state="translated">在没有字符串化重载的情况下，给出 &lt;code&gt;arg&lt;/code&gt; 的字符串值。如果您使用它来获取引用的地址（用于检查两个引用是否指向同一事物），那么使用 &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; 可能会更好。</target>
        </trans-unit>
        <trans-unit id="775ccd199d054693bedf24e4232707e8971068ab" translate="yes" xml:space="preserve">
          <source>Gives the string value of &lt;code&gt;arg&lt;/code&gt; as in the absence of stringify overloading. If you are using this to get the address of a reference (useful for checking if two references point to the same thing) then you may be better off using &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt;, which is faster.</source>
          <target state="translated">在没有字符串化重载的情况下，给出 &lt;code&gt;arg&lt;/code&gt; 的字符串值。如果您使用它来获取引用的地址（用于检查两个引用是否指向同一事物），则最好使用 &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; ，它速度更快。</target>
        </trans-unit>
        <trans-unit id="cfe98f7aeaa456c4237c94f0fd4653d71593c9bc" translate="yes" xml:space="preserve">
          <source>Gives the type of hints used for previous answers. May be one of &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;recommended&lt;/code&gt; or &lt;code&gt;previous&lt;/code&gt; .</source>
          <target state="translated">提供用于先前答案的提示类型。可以是 &lt;code&gt;default&lt;/code&gt; ， &lt;code&gt;recommended&lt;/code&gt; 或 &lt;code&gt;previous&lt;/code&gt; 的值之一。</target>
        </trans-unit>
        <trans-unit id="7d2e6ac68dbbd284c2f353cd0f92f42c6bd450f0" translate="yes" xml:space="preserve">
          <source>Gives the type of hints used for previous answers. May be one of &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;recommended&lt;/code&gt; or &lt;code&gt;previous&lt;/code&gt;.</source>
          <target state="translated">提供用于先前答案的提示类型。可以是 &lt;code&gt;default&lt;/code&gt; ， &lt;code&gt;recommended&lt;/code&gt; 或 &lt;code&gt;previous&lt;/code&gt; 的值之一。</target>
        </trans-unit>
        <trans-unit id="d71dccbe06d617b4160092d77a20fffa36b965b4" translate="yes" xml:space="preserve">
          <source>Giving a struct element a class type that is also a struct is how structs are nested. Here, &lt;code&gt;Timeval&lt;/code&gt; represents a time (seconds and microseconds), and &lt;code&gt;Rusage&lt;/code&gt; has two elements, each of which is of type &lt;code&gt;Timeval&lt;/code&gt; .</source>
          <target state="translated">给struct元素一个也是struct的类类型是struct嵌套的方式。在这里， &lt;code&gt;Timeval&lt;/code&gt; 表示一个时间（秒和微秒），而 &lt;code&gt;Rusage&lt;/code&gt; 具有两个元素，每个元素都是 &lt;code&gt;Timeval&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="c05c0b34dc6bfd6214a8b97afd38b066294f5abb" translate="yes" xml:space="preserve">
          <source>Giving a struct element a class type that is also a struct is how structs are nested. Here, &lt;code&gt;Timeval&lt;/code&gt; represents a time (seconds and microseconds), and &lt;code&gt;Rusage&lt;/code&gt; has two elements, each of which is of type &lt;code&gt;Timeval&lt;/code&gt;.</source>
          <target state="translated">给struct元素一个也是struct的类类型是struct嵌套的方式。在这里， &lt;code&gt;Timeval&lt;/code&gt; 表示一个时间（秒和微秒），而 &lt;code&gt;Rusage&lt;/code&gt; 具有两个元素，每个元素都是 &lt;code&gt;Timeval&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="d166f9da4bac6d857f7dc131be5d65de1b02def6" translate="yes" xml:space="preserve">
          <source>Giving additional meanings to a symbol or construct. Actually, all languages do overloading to one extent or another, since people are good at figuring out things from &lt;b&gt;context&lt;/b&gt;.</source>
          <target state="translated">为符号或构造赋予其他含义。实际上，所有语言都会在某种程度上超载，因为人们善于从&lt;b&gt;上下文&lt;/b&gt;中找出事物。</target>
        </trans-unit>
        <trans-unit id="e8b8f975ca429de01bb46828d5e9ad364deeb90c" translate="yes" xml:space="preserve">
          <source>Giving an invalid value for &lt;code&gt;$sock_type&lt;/code&gt; will &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">为 &lt;code&gt;$sock_type&lt;/code&gt; 赋予无效值将导致 &lt;code&gt;croak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10109e20d3ef4e69e4ba1f7e5c674f9df95fc01e" translate="yes" xml:space="preserve">
          <source>Giving an invalid value for &lt;code&gt;$sock_type&lt;/code&gt; will &lt;code&gt;croak&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;$sock_type&lt;/code&gt; 赋予无效值将导致 &lt;code&gt;croak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f57f0ea36677c92cf9afe99cb8959d03cc0961e" translate="yes" xml:space="preserve">
          <source>Giving up control</source>
          <target state="translated">放弃控制权</target>
        </trans-unit>
        <trans-unit id="ac34b82dc93bde9b29a5a3004c3ddbeef7e257a6" translate="yes" xml:space="preserve">
          <source>Glob elements can be extracted through the postfix dereferencing feature:</source>
          <target state="translated">Glob元素可以通过后缀去参考功能来提取。</target>
        </trans-unit>
        <trans-unit id="f6641c458cc0583d3613a6a86e40173a73aab142" translate="yes" xml:space="preserve">
          <source>Glob not terminated</source>
          <target state="translated">Glob未终止</target>
        </trans-unit>
        <trans-unit id="a2bba5393d5751445bbbac73e8d2d26ee97a6c53" translate="yes" xml:space="preserve">
          <source>Glob-style pattern matching for rules</source>
          <target state="translated">规则的Glob式模式匹配</target>
        </trans-unit>
        <trans-unit id="586c371162ed972fff02dbee194ab54579306095" translate="yes" xml:space="preserve">
          <source>Global DLLs</source>
          <target state="translated">全球DLLs</target>
        </trans-unit>
        <trans-unit id="f4853985ae8961c644b701f3a4211e427659afca" translate="yes" xml:space="preserve">
          <source>Global Destruction</source>
          <target state="translated">全球毁灭</target>
        </trans-unit>
        <trans-unit id="d4326c5fc3d6b26143e4368742fe314ae01c47ca" translate="yes" xml:space="preserve">
          <source>Global Overriding</source>
          <target state="translated">全球覆盖</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">全局变量</target>
        </trans-unit>
        <trans-unit id="2cbdcda340ba1e2e7ca0ffb07cf96cf77ae074ef" translate="yes" xml:space="preserve">
          <source>Global buffers requested for the file</source>
          <target state="translated">为文件申请的全局缓冲区</target>
        </trans-unit>
        <trans-unit id="c74b56bb1057578230abe272aa56e202301adbc0" translate="yes" xml:space="preserve">
          <source>Global destruction.</source>
          <target state="translated">全球毁灭。</target>
        </trans-unit>
        <trans-unit id="e7f5c9eb53159b83da104e3bda376cd7346692a8" translate="yes" xml:space="preserve">
          <source>Global matching</source>
          <target state="translated">全球匹配</target>
        </trans-unit>
        <trans-unit id="a872e74ca2223071a991a7dc6c5ea6db791004e6" translate="yes" xml:space="preserve">
          <source>Global state maintained by XSUBs</source>
          <target state="translated">全局状态由XSUBs维护</target>
        </trans-unit>
        <trans-unit id="4e13a92f72eb76d8c508c2dc21b04feb11b16eff" translate="yes" xml:space="preserve">
          <source>Global symbol &quot;%s&quot; requires explicit package name (did you forget to declare &quot;my %s&quot;?)</source>
          <target state="translated">全局符号&quot;%s &quot;需要明确的包名(你忘了声明 &quot;我的%s &quot;吗?</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="3650821866c81f2ac2894b41d87da9c715e1e8ce" translate="yes" xml:space="preserve">
          <source>Glue to provide EXISTS for AnyDBM_File for Storable use</source>
          <target state="translated">为AnyDBM_File提供EXISTS胶水,以便存储使用。</target>
        </trans-unit>
        <trans-unit id="4909b3a46d83dbbf52b8710b4dc26c66ca78944e" translate="yes" xml:space="preserve">
          <source>Glue to provide EXISTS for NDBM_File for Storable use</source>
          <target state="translated">为NDBM_File提供EXISTS胶水,以供存储使用。</target>
        </trans-unit>
        <trans-unit id="d57f000cec87f12e43b8b27b36323279bd6bf351" translate="yes" xml:space="preserve">
          <source>Glue to provide EXISTS for SDBM_File for Storable use</source>
          <target state="translated">为SDBM_File提供EXISTS胶水,以供存储使用。</target>
        </trans-unit>
        <trans-unit id="1ef566e266fcd5938f2e20f4951576b582c8951b" translate="yes" xml:space="preserve">
          <source>Go and write your program. Everywhere in your program where you would say:</source>
          <target state="translated">去写你的程序。在你的程序中,凡是你会说的地方。</target>
        </trans-unit>
        <trans-unit id="17a5012f10d8e9cdb0ba165e243a06151fb8f234" translate="yes" xml:space="preserve">
          <source>Go into the newly-created directory and type:</source>
          <target state="translated">进入新创建的目录,并输入。</target>
        </trans-unit>
        <trans-unit id="bb969927295c4c8629a766337faf9d2987763158" translate="yes" xml:space="preserve">
          <source>Goal #1:</source>
          <target state="translated">目标1:</target>
        </trans-unit>
        <trans-unit id="efa364708854c41e2aaf01b89a8ca544d0591051" translate="yes" xml:space="preserve">
          <source>Goal #2:</source>
          <target state="translated">目标2:</target>
        </trans-unit>
        <trans-unit id="05beafe9dca70a4a92356525cf080da1fcabd65d" translate="yes" xml:space="preserve">
          <source>Goal #3:</source>
          <target state="translated">目标3:</target>
        </trans-unit>
        <trans-unit id="ba9eecdd12afc7f1400662096cf586f7f0a2f8e4" translate="yes" xml:space="preserve">
          <source>Goal #4:</source>
          <target state="translated">目标4:</target>
        </trans-unit>
        <trans-unit id="e84961568f47f9182f766681bff3b6dd90dcc10a" translate="yes" xml:space="preserve">
          <source>Going forward, specification version numbers will be integers and decimal portions will correspond to a release date for the CPAN::Meta library.</source>
          <target state="translated">今后,规范版本号将是整数,十进制部分将对应CPAN::Meta库的发布日期。</target>
        </trans-unit>
        <trans-unit id="29c6ec10417b35abc144d3f4a0729c76abf5e284" translate="yes" xml:space="preserve">
          <source>Going past the 70th column in a verbatim block might be ungracefully wrapped by some formatters.</source>
          <target state="translated">在逐字块中走过第70列,可能会被一些格式化的人不雅观地包装。</target>
        </trans-unit>
        <trans-unit id="4a647f902e0d765ea12195a96e4829f8b1e8aa9f" translate="yes" xml:space="preserve">
          <source>Good Practices</source>
          <target state="translated">良好做法</target>
        </trans-unit>
        <trans-unit id="7d80a18b9b9c68e6a7c1c8a8d0dbf303700b7763" translate="yes" xml:space="preserve">
          <source>Good example:</source>
          <target state="translated">好的例子。</target>
        </trans-unit>
        <trans-unit id="4143405b286941b2e4ea2b9f669d260327d04f9b" translate="yes" xml:space="preserve">
          <source>Good for tracking down why things don't work with your particular setup.</source>
          <target state="translated">很好地追踪为什么你的特定设置不能工作。</target>
        </trans-unit>
        <trans-unit id="f73c69efaf3df1b92a97b27aa347eb13fea306c3" translate="yes" xml:space="preserve">
          <source>Good patches (tight code, complete, correct) stand more chance of going in. Sloppy or incorrect patches might be placed on the back burner until the pumpking has time to fix, or might be discarded altogether without further notice.</source>
          <target state="translated">好的补丁(代码严密、完整、正确)有更多机会进入。马虎或不正确的补丁可能会被放在后面,直到南瓜有时间修复,或者可能会被完全丢弃而不另行通知。</target>
        </trans-unit>
        <trans-unit id="96e99dfa2e51dca66243d416a2cf4eff66499d06" translate="yes" xml:space="preserve">
          <source>Good places to look for pre-existing modules include &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; and &lt;a href=&quot;https://metacpan.org&quot;&gt;https://metacpan.org&lt;/a&gt; and asking on &lt;code&gt;module-authors@perl.org&lt;/code&gt; (&lt;a href=&quot;http://lists.perl.org/list/module-authors.html&quot;&gt;http://lists.perl.org/list/module-authors.html&lt;/a&gt;).</source>
          <target state="translated">寻找预先存在的模块的好地方包括&lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt;和&lt;a href=&quot;https://metacpan.org&quot;&gt;https://metacpan.org&lt;/a&gt;并询问 &lt;code&gt;module-authors@perl.org&lt;/code&gt; （&lt;a href=&quot;http://lists.perl.org/list/module-authors.html&quot;&gt;http://lists.perl.org/list /module-authors.html&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2204cbb75fbcc2f7a7c3bd131ef1fc6ce9423848" translate="yes" xml:space="preserve">
          <source>Good places to look for pre-existing modules include &lt;a href=&quot;https://metacpan.org&quot;&gt;MetaCPAN&lt;/a&gt; and &lt;a href=&quot;http://prepan.org&quot;&gt;PrePAN&lt;/a&gt; and asking on &lt;code&gt;module-authors@perl.org&lt;/code&gt; (&lt;a href=&quot;https://lists.perl.org/list/module-authors.html&quot;&gt;https://lists.perl.org/list/module-authors.html&lt;/a&gt;).</source>
          <target state="translated">寻找预先存在的模块的好地方包括&lt;a href=&quot;https://metacpan.org&quot;&gt;MetaCPAN&lt;/a&gt;和&lt;a href=&quot;http://prepan.org&quot;&gt;PrePAN&lt;/a&gt;并询问 &lt;code&gt;module-authors@perl.org&lt;/code&gt; （&lt;a href=&quot;https://lists.perl.org/list/module-authors.html&quot;&gt;https://lists.perl.org/list/module-authors.html&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1707029b59612c93d147b82e0c5b435886ce180c" translate="yes" xml:space="preserve">
          <source>Gory details of parsing quoted constructs</source>
          <target state="translated">解析引用结构的血腥细节</target>
        </trans-unit>
        <trans-unit id="bbd8ec1cd2d79b0a075cc6f6de1b4a7f725a4726" translate="yes" xml:space="preserve">
          <source>Got an error from DosAllocMem</source>
          <target state="translated">从DosAllocMem那里得到了一个错误。</target>
        </trans-unit>
        <trans-unit id="23f16c19388eabd103562554c9bfa091b6dac302" translate="yes" xml:space="preserve">
          <source>Got that? As of Perl 5.8.7, &lt;b&gt;&quot;UTF-8&quot;&lt;/b&gt; means UTF-8 in its current sense, which is conservative and strict and security-conscious, whereas &lt;b&gt;&quot;utf8&quot;&lt;/b&gt; means UTF-8 in its former sense, which was liberal and loose and lax. &lt;code&gt;Encode&lt;/code&gt; version 2.10 or later thus groks this subtle but critically important distinction between &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; and &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; .</source>
          <target state="translated">了解？从Perl 5.8.7开始，&lt;b&gt;&amp;ldquo; UTF-8&amp;rdquo;&lt;/b&gt;在当前意义上表示UTF-8，这是保守，严格和安全意识的，而&lt;b&gt;&amp;ldquo; utf8&amp;rdquo;&lt;/b&gt;在以前意义上表示UTF-8，其含义是自由，宽松和松懈。因此，对版本2.10或更高版本进行 &lt;code&gt;Encode&lt;/code&gt; 在 &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 之间产生这种微妙但至关重要的区别。</target>
        </trans-unit>
        <trans-unit id="90ebaa561920aa9c2dc9e089697bca34ce37bae3" translate="yes" xml:space="preserve">
          <source>Got that? As of Perl 5.8.7, &lt;b&gt;&quot;UTF-8&quot;&lt;/b&gt; means UTF-8 in its current sense, which is conservative and strict and security-conscious, whereas &lt;b&gt;&quot;utf8&quot;&lt;/b&gt; means UTF-8 in its former sense, which was liberal and loose and lax. &lt;code&gt;Encode&lt;/code&gt; version 2.10 or later thus groks this subtle but critically important distinction between &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; and &lt;code&gt;&quot;utf8&quot;&lt;/code&gt;.</source>
          <target state="translated">知道了？从Perl 5.8.7开始，&lt;b&gt;&amp;ldquo; UTF-8&amp;rdquo;&lt;/b&gt;在目前的意义上表示UTF-8，这是保守，严格和安全意识的，而&lt;b&gt;&amp;ldquo; utf8&amp;rdquo;&lt;/b&gt;在以前的意义上表示UTF-8，其含义是自由，宽松和松懈。因此，对版本2.10或更高版本进行 &lt;code&gt;Encode&lt;/code&gt; 在 &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 之间产生这种微妙但至关重要的区别。</target>
        </trans-unit>
        <trans-unit id="0b4fc0a0d78b25de463f95089769282373893971" translate="yes" xml:space="preserve">
          <source>Got that? Larry is always right, even when he was wrong. It's rare to see either Rule exercised, but they are often alluded to.</source>
          <target state="translated">明白了吗?拉里总是对的,即使他是错的。很少看到任何一条规则被执行,但它们经常被提及。</target>
        </trans-unit>
        <trans-unit id="0a9ffc4a328e6d21b11f3b8312d08e5b413aec49" translate="yes" xml:space="preserve">
          <source>Goto</source>
          <target state="translated">Goto</target>
        </trans-unit>
        <trans-unit id="ca69ac23523fe10118230a18e01d42c76c8abcda" translate="yes" xml:space="preserve">
          <source>Goto celib-palm-3.0\inc\cewin32.h, search for</source>
          <target state="translated">Goto celib-palm-3.0\inc\cewin32.h,搜索</target>
        </trans-unit>
        <trans-unit id="a85e9c5d6dac87806ef2eaf1d93698fc48760a76" translate="yes" xml:space="preserve">
          <source>Goto undefined subroutine%s</source>
          <target state="translated">转到未定义的子程序%s。</target>
        </trans-unit>
        <trans-unit id="5890e910925d55654694f7ac1d42c03b68abbff2" translate="yes" xml:space="preserve">
          <source>Gotta have a plan!</source>
          <target state="translated">得有个计划!</target>
        </trans-unit>
        <trans-unit id="df8da02e8026798b67902a6787a5e32f5d1a8e68" translate="yes" xml:space="preserve">
          <source>Gprof Profiling</source>
          <target state="translated">Gprof Profiling</target>
        </trans-unit>
        <trans-unit id="55ce61dea540285b5729c947a17f82efa2f6d1fa" translate="yes" xml:space="preserve">
          <source>Grafts</source>
          <target state="translated">Grafts</target>
        </trans-unit>
        <trans-unit id="3259bccd5547a6fb8f77a4aaea022a14a41cb136" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;</source>
          <target state="translated">格雷厄姆&amp;middot;巴尔&amp;lt;</target>
        </trans-unit>
        <trans-unit id="42879164d6188855410d722427bd053e05e54ab7" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;</source>
          <target state="translated">格雷厄姆&amp;middot;巴尔&amp;lt;gbarr@pobox.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3732fa7e665009645e9e3e4379dd15edc1deb872" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Marcus Holland-Moritz &amp;lt;mhx@cpan.org&amp;gt;</source>
          <target state="translated">格雷厄姆&amp;middot;巴尔（Graham Barr）&amp;lt;gbarr@pobox.com&amp;gt;，贾科（Jarkko Hietaniemi）&amp;lt;jhi@iki.fi&amp;gt;，马库斯&amp;middot;荷兰（Marcus Holland-Moritz）&amp;lt;mhx@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="04f7ed11e65f8179b2c21de31c70c0e5a2b54f2f" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Marcus Holland-Moritz &amp;lt;mhx@cpan.org&amp;gt;</source>
          <target state="translated">格雷厄姆&amp;middot;巴尔&amp;lt;gbarr@pobox.com&amp;gt;，马库斯&amp;middot;荷兰&amp;middot;莫里茨&amp;lt;mhx@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7820aa7c6db183e706a7e84c2116e052f42811c0" translate="yes" xml:space="preserve">
          <source>Graham Barr, the original Configure script of libnet.</source>
          <target state="translated">Graham Barr,libnet的原始配置脚本。</target>
        </trans-unit>
        <trans-unit id="6433e49daadbc911a68d39c3c194d36d03e3dce3" translate="yes" xml:space="preserve">
          <source>Graham Barr. Currently maintained by the Perl Porters. Please report all bugs to &amp;lt;perlbug@perl.org&amp;gt;.</source>
          <target state="translated">格雷厄姆&amp;middot;巴尔（Graham Barr）。目前由Perl Porters维护。请将所有错误报告给&amp;lt;perlbug@perl.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="87a1ea2f5e9ab380ccaeb3b75aeec67585ecc358" translate="yes" xml:space="preserve">
          <source>Graham Barr. atmark() by Lincoln Stein. Currently maintained by the Perl Porters. Please report all bugs to &amp;lt;perlbug@perl.org&amp;gt;.</source>
          <target state="translated">格雷厄姆&amp;middot;巴尔（Graham Barr）。林肯&amp;middot;斯坦（Lincoln Stein）的atmark（）。目前由Perl Porters维护。请将所有错误报告给&amp;lt;perlbug@perl.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="851fd61fa3fb1f5808ef8c8f9dd236974160fdad" translate="yes" xml:space="preserve">
          <source>Graham Knop &amp;lt;haarg@haarg.org&amp;gt;</source>
          <target state="translated">格雷厄姆&amp;middot;诺普（Graham Knop）&amp;lt;haarg@haarg.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6fb9ba6977c2fe4e9f6adc9a0ece5aa2b87ae637" translate="yes" xml:space="preserve">
          <source>Graham Ollis &amp;lt;plicease@cpan.org&amp;gt;</source>
          <target state="translated">格雷厄姆&amp;middot;奥尔利斯（Graham Ollis）&amp;lt;plicease@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="ca8c988917ca583e838e2647bffdc0dd152b9fb8" translate="yes" xml:space="preserve">
          <source>Grammatical note on local()</source>
          <target state="translated">关于local()的语法说明</target>
        </trans-unit>
        <trans-unit id="2299a70876b7b20196c0e232824b6e303cf0f817" translate="yes" xml:space="preserve">
          <source>Grapheme_Link</source>
          <target state="translated">Grapheme_Link</target>
        </trans-unit>
        <trans-unit id="844b43fd71cbef7f18e867fe292f5c5684e1ab12" translate="yes" xml:space="preserve">
          <source>Great care is necessary when defining the command if quoting needs to be done. For instance, you would need to say:</source>
          <target state="translated">在定义命令时,如果需要引用,就需要非常小心。例如,你需要说</target>
        </trans-unit>
        <trans-unit id="4902a456caa9a4eab463ce526c9df0f6180be184" translate="yes" xml:space="preserve">
          <source>Greece</source>
          <target state="translated">Greece</target>
        </trans-unit>
        <trans-unit id="aacdfd21674e83c3c0b99f5359b19144d7666c82" translate="yes" xml:space="preserve">
          <source>Gregor Hermann &amp;lt;gregoa@debian.org&amp;gt;</source>
          <target state="translated">格雷戈尔&amp;middot;赫尔曼（Gregor Hermann）&amp;lt;gregoa@debian.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8c5e7d8a89c7b18aac43a9485b1546ac5b284f75" translate="yes" xml:space="preserve">
          <source>Group ID&amp;mdash;in Unix, the numeric group ID that the &lt;b&gt;operating system&lt;/b&gt; uses to identify you and members of your &lt;b&gt;group&lt;/b&gt;.</source>
          <target state="translated">组ID-在Unix中，是&lt;b&gt;操作系统&lt;/b&gt;用来标识您和您的&lt;b&gt;组&lt;/b&gt;成员的数字组ID 。</target>
        </trans-unit>
        <trans-unit id="16a718e915556d62f893e87ee82787d36995c7e4" translate="yes" xml:space="preserve">
          <source>Group Perl's functions a la perlfunc.pod</source>
          <target state="translated">将Perl的函数进行分组,如perlfunc.pod。</target>
        </trans-unit>
        <trans-unit id="893d792c6d1b1a9f4d49b51e99c5345d804a3939" translate="yes" xml:space="preserve">
          <source>Group name must start with a non-digit word character in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">组名必须以正则表达式中的非数字字字符开头；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="ba2d2b2b97d3fc7cff00f1012c3e7d17c04c2768" translate="yes" xml:space="preserve">
          <source>Group of languages collectively called &quot;Otom&amp;iacute;&quot;.</source>
          <target state="translated">一组语言统称为&amp;ldquo;Otom&amp;iacute;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2bfcba6c579bd2ce1f3564ea422bb81f6281834e" translate="yes" xml:space="preserve">
          <source>Group ownership of directories that already exist will not be changed.</source>
          <target state="translated">已经存在的目录的组所有权将不会改变。</target>
        </trans-unit>
        <trans-unit id="cb77c777665eaa5c9fc03cd1712f2d2993483948" translate="yes" xml:space="preserve">
          <source>Group ownwership of directories that already exist will not be changed.</source>
          <target state="translated">已经存在的目录的群组所有权将不会被改变。</target>
        </trans-unit>
        <trans-unit id="fc00408fdf05ce5150089b75b75b23c46962261d" translate="yes" xml:space="preserve">
          <source>Grouping things and hierarchical matching</source>
          <target state="translated">事物的分组和层次的匹配</target>
        </trans-unit>
        <trans-unit id="fee5f710c9ba7310f55f4c68e3911ad898f334f8" translate="yes" xml:space="preserve">
          <source>Growing Your Own</source>
          <target state="translated">自己种植</target>
        </trans-unit>
        <trans-unit id="fe293b21525de44a2e12eb8c0027d2290b7e1a71" translate="yes" xml:space="preserve">
          <source>Gtk and Gtk2</source>
          <target state="translated">Gtk和Gtk2</target>
        </trans-unit>
        <trans-unit id="7864c5c65bb01ac0a14a3115852b7c02219c584f" translate="yes" xml:space="preserve">
          <source>Guaran&amp;iacute;</source>
          <target state="translated">Guaran&amp;iacute;</target>
        </trans-unit>
        <trans-unit id="23ca9988de5733d8c8247a3e4e4982df4f209ed4" translate="yes" xml:space="preserve">
          <source>Guess the name of this package by examining the working directory's name. MakeMaker calls this only if the developer has not supplied a NAME attribute.</source>
          <target state="translated">通过检查工作目录的名称来猜测这个包的名称。只有当开发者没有提供NAME属性时,MakeMaker才会调用这个功能。</target>
        </trans-unit>
        <trans-unit id="07aa51a012723e8368dc093b343c1ff642baa052" translate="yes" xml:space="preserve">
          <source>Guess.U</source>
          <target state="translated">Guess.U</target>
        </trans-unit>
        <trans-unit id="b6684e2eba17124bde1d0355e24c5684aef1bed6" translate="yes" xml:space="preserve">
          <source>Guesses encoding from data</source>
          <target state="translated">从数据中猜测编码</target>
        </trans-unit>
        <trans-unit id="73b139c37c0097cfe3599d3082c96b0c2aee8d6a" translate="yes" xml:space="preserve">
          <source>Guidelines for Converting Perl 4 Library Scripts into Modules</source>
          <target state="translated">将Perl 4库脚本转换为模块的指南</target>
        </trans-unit>
        <trans-unit id="c758bdbdcf1ca454825428e4f69546fbfdaf18d9" translate="yes" xml:space="preserve">
          <source>Guidelines for Module Creation</source>
          <target state="translated">模块创建指南</target>
        </trans-unit>
        <trans-unit id="5fc6aecec704586c9198ddc6d24910690ea4c4e4" translate="yes" xml:space="preserve">
          <source>Guidelines for Reusing Application Code</source>
          <target state="translated">应用程序代码的再利用指南</target>
        </trans-unit>
        <trans-unit id="b1f36e56060bf112e405cf82b761c5b4b96e7caf" translate="yes" xml:space="preserve">
          <source>Guillem Jover &amp;lt;guillem@hadrons.org&amp;gt;</source>
          <target state="translated">吉列姆&amp;middot;乔佛（Guillem Jover）&amp;lt;guillem@hadrons.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9f22068b470b55c5659b24a529d486d165efe1e8" translate="yes" xml:space="preserve">
          <source>Gulliver's Travels</source>
          <target state="translated">格列佛游记</target>
        </trans-unit>
        <trans-unit id="d3d42475682a0666adb5abe77243023160ef0a45" translate="yes" xml:space="preserve">
          <source>Gunzip/gzip for OS/390 is discussed at:</source>
          <target state="translated">关于OS/390的Gunzip/gzip的讨论见:</target>
        </trans-unit>
        <trans-unit id="93a0fe097041b93e0be65ee154daffc6b1381bc9" translate="yes" xml:space="preserve">
          <source>Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;</source>
          <target state="translated">Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d960951b2cdfc9f9204beae43f12a4a11b295b41" translate="yes" xml:space="preserve">
          <source>Gurusamy Sarathy gsar@activestate.com</source>
          <target state="translated">Gurusamy Sarathy gsar@activestate.com</target>
        </trans-unit>
        <trans-unit id="7c88e96e80542c5ab8c25d94ba78c38a9434f36e" translate="yes" xml:space="preserve">
          <source>GvAV</source>
          <target state="translated">GvAV</target>
        </trans-unit>
        <trans-unit id="93e9014719ba7dd6bd9c9a5946fe1b93538edf1f" translate="yes" xml:space="preserve">
          <source>GvCV</source>
          <target state="translated">GvCV</target>
        </trans-unit>
        <trans-unit id="aafef8d6561e3651edafc5890e67e14dff424872" translate="yes" xml:space="preserve">
          <source>GvHV</source>
          <target state="translated">GvHV</target>
        </trans-unit>
        <trans-unit id="f991fe9870fc45fa7b0143b9ae1b6bc1ca3392d4" translate="yes" xml:space="preserve">
          <source>GvREFCNT</source>
          <target state="translated">GvREFCNT</target>
        </trans-unit>
        <trans-unit id="f6f249bdd6a51ddf7f142e9b9a80faa131f6974a" translate="yes" xml:space="preserve">
          <source>GvSV</source>
          <target state="translated">GvSV</target>
        </trans-unit>
        <trans-unit id="ddf1c563576d03de876ebbb0aae2f006c136dc9f" translate="yes" xml:space="preserve">
          <source>Gv_AMupdate</source>
          <target state="translated">Gv_AMupdate</target>
        </trans-unit>
        <trans-unit id="5351767f64737ac06c8bff705b0350e3b12bf9fe" translate="yes" xml:space="preserve">
          <source>Gzip Resources</source>
          <target state="translated">Gzip资源</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="db954ca5c29d07dccf4b2cd89bd036d330b99ae8" translate="yes" xml:space="preserve">
          <source>H -number</source>
          <target state="translated">H-数量</target>
        </trans-unit>
        <trans-unit id="c6779059ab26129a6e380e0ef513d4df3cbdbef7" translate="yes" xml:space="preserve">
          <source>H.Merijn Brand &amp;lt;h.m.brand@xs4all.nl&amp;gt;</source>
          <target state="translated">H.Merijn Brand &amp;lt;h.m.brand@xs4all.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="58edf605e14f939b5061c16becc3c237b2cf3c47" translate="yes" xml:space="preserve">
          <source>H.Merijn Brand &amp;lt;h.m.brand@xs4all.nl&amp;gt; Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;</source>
          <target state="translated">H.Merijn Brand &amp;lt;hmbrand@xs4all.nl&amp;gt; Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="47ce9e7227c5c88413414b245a64737d1d7aa032" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;autoflush( EXPR )</source>
          <target state="translated">处理-&amp;gt;自动冲洗（EXPR）</target>
        </trans-unit>
        <trans-unit id="e39692187e35b8d86da8462f683967a48317dea2" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_lines_left(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_lines_left(EXPR)</target>
        </trans-unit>
        <trans-unit id="209a918918c25cd99d83f2f0dbbc4f467dc693f1" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_lines_per_page(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_lines_per_page(EXPR)</target>
        </trans-unit>
        <trans-unit id="f1d2f9361bebc33157aeedef49dc5f8e73598847" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_name(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_name(EXPR)</target>
        </trans-unit>
        <trans-unit id="0c9bdf53fa0c2bc01c5c44ec8066b07d741898ab" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_page_number(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_page_number(EXPR)</target>
        </trans-unit>
        <trans-unit id="7462f62c1d1e40bafc8b07b413de84a660ada74e" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_top_name(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_top_name(EXPR)</target>
        </trans-unit>
        <trans-unit id="69f09f09d96a3982a3608cf0a03c946ae72aee61" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;input_line_number( EXPR )</source>
          <target state="translated">HANDLE-&amp;gt; input_line_number（EXPR）</target>
        </trans-unit>
        <trans-unit id="db41c0239e45c0e3b7059c151c4adb6338795f77" translate="yes" xml:space="preserve">
          <source>HANDLE_FLAG_INHERIT</source>
          <target state="translated">HANDLE_FLAG_INHERIT</target>
        </trans-unit>
        <trans-unit id="c8a128a1c9ef12c12e3c9fff40e91e634c10d778" translate="yes" xml:space="preserve">
          <source>HANDLE_FLAG_PROTECT_FROM_CLOSE</source>
          <target state="translated">HANDLE_FLAG_PROTECT_FROM_CLOSE</target>
        </trans-unit>
        <trans-unit id="f8435efca06ef2ecdd8e0b507cc5cef4ba204c42" translate="yes" xml:space="preserve">
          <source>HARDLINK</source>
          <target state="translated">HARDLINK</target>
        </trans-unit>
        <trans-unit id="789c59b41e5418de142d321c95b023de4bdfe79e" translate="yes" xml:space="preserve">
          <source>HASHES OF ARRAYS</source>
          <target state="translated">阵列的ASHES</target>
        </trans-unit>
        <trans-unit id="530c7188bb0935938e3b58577815f4334a49e6ef" translate="yes" xml:space="preserve">
          <source>HASHES OF HASHES</source>
          <target state="translated">HASHES OF HASHES</target>
        </trans-unit>
        <trans-unit id="d3053d5db9cc8cb93b26db3c26c76bdfdff06ace" translate="yes" xml:space="preserve">
          <source>HEADER</source>
          <target state="translated">HEADER</target>
        </trans-unit>
        <trans-unit id="a880c390a6cf41f70f9a43af2b194442bbe8c615" translate="yes" xml:space="preserve">
          <source>HEY</source>
          <target state="translated">HEY</target>
        </trans-unit>
        <trans-unit id="b9cd18c768bfd2083a9ac760b8041edbaa72c7c4" translate="yes" xml:space="preserve">
          <source>HEf_SVKEY</source>
          <target state="translated">HEf_SVKEY</target>
        </trans-unit>
        <trans-unit id="fc5d4b9117ba9e87388174aee4f4970bdfe8d066" translate="yes" xml:space="preserve">
          <source>HH</source>
          <target state="translated">HH</target>
        </trans-unit>
        <trans-unit id="5b8cce18efcb259ac8ee29e1cd21dcc198081fdb" translate="yes" xml:space="preserve">
          <source>HHHH</source>
          <target state="translated">HHHH</target>
        </trans-unit>
        <trans-unit id="d77d0b27955f008358918e195742c4c8208699e1" translate="yes" xml:space="preserve">
          <source>HIGH</source>
          <target state="translated">HIGH</target>
        </trans-unit>
        <trans-unit id="9c2ea135ec1db4f446c806f7895ae6f2c302104a" translate="yes" xml:space="preserve">
          <source>HINTS AND TIPS</source>
          <target state="translated">提示和技巧</target>
        </trans-unit>
        <trans-unit id="f6dc58f5e8036353a7ac15516c30ac562e23dc26" translate="yes" xml:space="preserve">
          <source>HISTORY</source>
          <target state="translated">HISTORY</target>
        </trans-unit>
        <trans-unit id="d0e8f9a5a2dbdd8722af6ec7f2972e1375fb801e" translate="yes" xml:space="preserve">
          <source>HMAC-SHA-1/224/256/384/512</source>
          <target state="translated">HMAC-SHA-1/224/256/384/512</target>
        </trans-unit>
        <trans-unit id="7731962fb19e09fff22c1be46abc4b02e9ff78eb" translate="yes" xml:space="preserve">
          <source>HOME</source>
          <target state="translated">HOME</target>
        </trans-unit>
        <trans-unit id="687695890e9e2ec947fdeb9bf817e5fc0911f2bf" translate="yes" xml:space="preserve">
          <source>HOOKS</source>
          <target state="translated">HOOKS</target>
        </trans-unit>
        <trans-unit id="a76f8ee2872265eb6fe359928ee6904e71dc9d05" translate="yes" xml:space="preserve">
          <source>HOW IT WORKS</source>
          <target state="translated">如何工作</target>
        </trans-unit>
        <trans-unit id="e600c98fe8777fa43cea8c7f053ad797f5be4db6" translate="yes" xml:space="preserve">
          <source>HOW TO USE (THE EASY WAY)</source>
          <target state="translated">如何使用(简单的方法)</target>
        </trans-unit>
        <trans-unit id="cc39d7b9b79bc6d75414a8ad9ee6ee875828738b" translate="yes" xml:space="preserve">
          <source>HOW TO USE (THE HARD WAY)</source>
          <target state="translated">如何使用(艰难的方法)</target>
        </trans-unit>
        <trans-unit id="eab9f433c21086a197b4e1c36ca01d70a2e0dffa" translate="yes" xml:space="preserve">
          <source>HOW TO USE MAKETEXT</source>
          <target state="translated">如何使用MAKETEXT</target>
        </trans-unit>
        <trans-unit id="6ab52b908787e3ae467e585a2243118089d23d99" translate="yes" xml:space="preserve">
          <source>HP Itanium 2 systems are usually referred to with model description &quot;HP Integrity&quot;.</source>
          <target state="translated">HP Itanium 2系统通常以型号说明 &quot;HP Integrity &quot;来表示。</target>
        </trans-unit>
        <trans-unit id="a35088083875e2de4dedaf2dca0ae84350b5e92b" translate="yes" xml:space="preserve">
          <source>HP PA-RISC systems are usually referred to with model description &quot;HP 9000&quot;. The last CPU in this series is the PA-8900. Support for PA-RISC architectured machines officially ended as shown in the following table:</source>
          <target state="translated">HP PA-RISC系统通常以型号说明 &quot;HP 9000 &quot;来表示。这个系列的最后一款CPU是PA-8900。对PA-RISC架构机器的支持正式结束,如下表所示。</target>
        </trans-unit>
        <trans-unit id="9e3417f4faadcebc07bb9497031485b632cc05e1" translate="yes" xml:space="preserve">
          <source>HP also ships servers with the 128-bit Itanium processor(s). The cx26x0 is told to have Madison 6. As of the date of this document's last update, the following systems contain Itanium or Itanium 2 chips (this is likely to be out of date):</source>
          <target state="translated">惠普公司还推出了采用128位Itanium处理器的服务器。据悉,cx26x0采用了Madison 6。截至本文档最后一次更新的日期,以下系统包含Itanium或Itanium 2芯片(这很可能是过时的)。</target>
        </trans-unit>
        <trans-unit id="8d4391f0427fa0cb914bda064998c9b6cf7d23d3" translate="yes" xml:space="preserve">
          <source>HP has a C/C++ static analyzer product for HP-UX caller Code Advisor. (Link not given here because the URL is horribly long and seems horribly unstable; use the search engine of your choice to find it.) The use of the &lt;code&gt;cadvise_cc&lt;/code&gt; recipe with &lt;code&gt;Configure ... -Dcc=./cadvise_cc&lt;/code&gt; (see cadvise &quot;User Guide&quot;) is recommended; as is the use of &lt;code&gt;+wall&lt;/code&gt;.</source>
          <target state="translated">HP有一个用于HP-UX调用程序Code Advisor的C / C ++静态分析器产品。（此处未提供链接，因为URL太长且看起来非常不稳定；请使用您选择的搜索引擎来查找它。） &lt;code&gt;cadvise_cc&lt;/code&gt; 配方与 &lt;code&gt;Configure ... -Dcc=./cadvise_cc&lt;/code&gt; （请参阅cadvise&amp;ldquo;用户建议使用指南&amp;rdquo;）；以及 &lt;code&gt;+wall&lt;/code&gt; 的用法。</target>
        </trans-unit>
        <trans-unit id="2d0a2c854fdfe25037f6f2462163a3677a8c0d9a" translate="yes" xml:space="preserve">
          <source>HP has asked the porting centre to move Open Source binaries from /opt to /usr/local, so binaries produced since the start of July 2002 are located in /usr/local.</source>
          <target state="translated">HP已经要求移植中心将开放源码的二进制文件从/opt移到/usr/local,所以2002年7月开始制作的二进制文件位于/usr/local。</target>
        </trans-unit>
        <trans-unit id="a764a39116b67d584d0e922398f34d8a6157ce49" translate="yes" xml:space="preserve">
          <source>HP porting centre tries to keep up with customer demand and release updates from the Open Source community. Having precompiled Perl binaries available is obvious, though &quot;up-to-date&quot; is something relative. At the moment of writing only perl-5.10.1 was available (with 5.16.3 being the latest stable release from the porters point of view).</source>
          <target state="translated">HP 移植中心试图跟上客户的需求,并发布来自开源社区的更新。拥有预编译的Perl二进制文件是显而易见的,尽管 &quot;最新 &quot;是相对的。在写这篇文章的时候,只有 perl-5.10.1 是可用的 (从移植者的角度来看,5.16.3 是最新的稳定版本)。</target>
        </trans-unit>
        <trans-unit id="add793b4cd90e315447341dd87e2674b6f6bf947" translate="yes" xml:space="preserve">
          <source>HP porting centre tries to keep up with customer demand and release updates from the Open Source community. Having precompiled Perl binaries available is obvious, though &quot;up-to-date&quot; is something relative. At the moment of writing perl-5.10.1 and 5.28.0 were available.</source>
          <target state="translated">HP 移植中心试图跟上客户的需求,并发布来自开源社区的更新。拥有预编译的Perl二进制文件是显而易见的,尽管 &quot;最新 &quot;是相对的。在写这篇文章的时候,perl-5.10.1和5.28.0是可用的。</target>
        </trans-unit>
        <trans-unit id="9dbd2af4559edefe4dd19c07c7c19b95825a0430" translate="yes" xml:space="preserve">
          <source>HP's HP9000 Unix systems run on HP's own Precision Architecture (PA-RISC) chip. HP-UX used to run on the Motorola MC68000 family of chips, but any machine with this chip in it is quite obsolete and this document will not attempt to address issues for compiling Perl on the Motorola chipset.</source>
          <target state="translated">HP公司的HP9000 Unix系统运行在HP公司自己的Precision Architecture(PA-RISC)芯片上。HP-UX曾经运行在Motorola MC68000系列芯片上,但任何装有这种芯片的机器都已经相当过时了,本文档将不试图解决在Motorola芯片组上编译Perl的问题。</target>
        </trans-unit>
        <trans-unit id="880e3ff3e606f859fc4dde60cd558255e131f001" translate="yes" xml:space="preserve">
          <source>HP's HP9000 Unix systems run on HP's own Precision Architecture (PA-RISC) chip. HP-UX used to run on the Motorola MC68000 family of chips, but any machine with this chip in it is quite obsolete and this document will not attempt to address issues for compiling Perl on the Motorola chipset. Even though PA-RISC hardware is not sold anymore, a lot of machines still running on these CPU's can be found in the wild.</source>
          <target state="translated">HP公司的HP9000 Unix系统运行在HP公司自己的Precision Architecture(PA-RISC)芯片上。HP-UX曾经运行在Motorola MC68000系列芯片上,但任何装有这种芯片的机器都已经相当陈旧了,本文档不会试图解决在Motorola芯片组上编译Perl的问题。尽管PA-RISC硬件已经不再出售,但在野外可以找到很多仍在这些CPU上运行的机器。</target>
        </trans-unit>
        <trans-unit id="c305ce22fa1ddad5ff6a9a241e6067a9f35cad67" translate="yes" xml:space="preserve">
          <source>HP-UX</source>
          <target state="translated">HP-UX</target>
        </trans-unit>
        <trans-unit id="5d006886dc4fd65e0adca5c8c02c5767eb4d1359" translate="yes" xml:space="preserve">
          <source>HP-UX 11 Y2K patch &quot;Y2K-1100 B.11.00.B0125 HP-UX Core OS Year 2000 Patch Bundle&quot; has been reported to break the io/fs test #18 which tests whether utime() can change timestamps. The Y2K patch seems to break utime() so that over NFS the timestamps do not get changed (on local filesystems utime() still works). This has probably been fixed on your system by now.</source>
          <target state="translated">HP-UX 11 Y2K 补丁 &quot;Y2K-1100 B.11.00.B0125 HP-UX Core OS Year 2000 补丁包 &quot;被报告破坏了测试 utime()是否能改变时间戳的 io/fs 测试 #18。Y2K 补丁似乎破坏了 utime(),因此在 NFS 上时间戳不会被改变 (在本地文件系统上 utime()仍然有效)。这个问题在你的系统上可能已经被解决了。</target>
        </trans-unit>
        <trans-unit id="97187cfde6c75a8b8deebd75a13a60ae1c81f420" translate="yes" xml:space="preserve">
          <source>HP-UX 11i documentation on syslog, &lt;a href=&quot;http://docs.hp.com/en/B2355-60130/syslog.3C.html&quot;&gt;http://docs.hp.com/en/B2355-60130/syslog.3C.html&lt;/a&gt;</source>
          <target state="translated">有关syslog的HP-UX 11i文档，&lt;a href=&quot;http://docs.hp.com/en/B2355-60130/syslog.3C.html&quot;&gt;http：//docs.hp.com/en/B2355-60130/syslog.3C.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed2a9bb260e4ae72bbe1af113a3b7bdf4f05246c" translate="yes" xml:space="preserve">
          <source>HP-UX Kernel Parameters (maxdsiz) for Compiling Perl</source>
          <target state="translated">HP-UX编译Perl的内核参数(maxdsiz)</target>
        </trans-unit>
        <trans-unit id="83019d5a780dd0ff3c9db7fabc3a90c74127c6c2" translate="yes" xml:space="preserve">
          <source>HP-UX also runs on the new Itanium processor. This requires the use of a different version of HP-UX (currently 11.23 or 11i v2), and with the exception of a few differences detailed below and in later sections, Perl should compile with no problems.</source>
          <target state="translated">HP-UX还可以在新的Itanium处理器上运行。这就需要使用不同版本的HP-UX(目前是11.23或11i v2),除了下面和后面的章节中详述的一些差异外,Perl的编译应该没有问题。</target>
        </trans-unit>
        <trans-unit id="1d125d82d143012eb929f6160766c96e578f0298" translate="yes" xml:space="preserve">
          <source>HP-UX also runs on the newer Itanium processor. This requires the use of HP-UX version 11.23 (11i v2) or 11.31 (11i v3), and with the exception of a few differences detailed below and in later sections, Perl should compile with no problems.</source>
          <target state="translated">HP-UX也可以在较新的Itanium处理器上运行。这需要使用HP-UX的11.23(11i v2)或11.31(11i v3)版本,除了下面和后面的章节中详述的一些差异外,Perl的编译应该没有问题。</target>
        </trans-unit>
        <trans-unit id="0fc19e78ac072e943aed407c41f2503cdb482688" translate="yes" xml:space="preserve">
          <source>HP-UX cadvise (Code Advisor)</source>
          <target state="translated">HP-UX cadvise (Code Advisor)</target>
        </trans-unit>
        <trans-unit id="6054c4b79943ef67e4dcb28eb588b66781f366f6" translate="yes" xml:space="preserve">
          <source>HP-UX supports dynamically loadable libraries (shared libraries). Shared libraries end with the suffix .sl. On Itanium systems, they end with the suffix .so.</source>
          <target state="translated">HP-UX支持动态加载库(共享库)。共享库以后缀.sl结尾,在Itanium系统中,它们以后缀.so结尾。在Itanium系统中,它们以后缀.so结尾。</target>
        </trans-unit>
        <trans-unit id="b4319bb42f0da477a0906018447c3096d305eb37" translate="yes" xml:space="preserve">
          <source>HP-UX versions</source>
          <target state="translated">HP-UX版本</target>
        </trans-unit>
        <trans-unit id="0c355dad6ecf8b6970623574fcecedac49554b22" translate="yes" xml:space="preserve">
          <source>HP-UX versions before 10.30 require a separate installation of a POSIX threads library package. Two examples are the HP DCE package, available on &quot;HP-UX Hardware Extensions 3.0, Install and Core OS, Release 10.20, April 1999 (B3920-13941)&quot; or the Freely available PTH package, available on H.Merijn's site (&lt;a href=&quot;http://mirrors.develooper.com/hpux/&quot;&gt;http://mirrors.develooper.com/hpux/&lt;/a&gt;). The use of PTH will be unsupported in perl-5.12 and up and is rather buggy in 5.11.x.</source>
          <target state="translated">10.30之前的HP-UX版本需要单独安装POSIX线程库软件包。两个示例是可在&amp;ldquo; HP-UX硬件扩展3.0，安装和核心操作系统，版本10.20，1999年4月（B3920-13941）&amp;rdquo;上获得的HP DCE软件包，或可在H.Merijn的网站上获得的免费PTH软件包（&lt;a href=&quot;http://mirrors.develooper.com/hpux/&quot;&gt;http： //mirrors.develooper.com/hpux/&lt;/a&gt;）。在Perl-5.12及更高版本中将不支持PTH的使用，而在5.11.x中则相当容易出错。</target>
        </trans-unit>
        <trans-unit id="6300aa55afa8bf02e973bd6a558a179a30e1f585" translate="yes" xml:space="preserve">
          <source>HPFS</source>
          <target state="translated">HPFS</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="ae70bc50ce534eb0105058b7b1522f4597dc620f" translate="yes" xml:space="preserve">
          <source>HTML charref mode (</source>
          <target state="translated">HTML charref模式 (</target>
        </trans-unit>
        <trans-unit id="fb2be72b2d469286542425f84d15023962183962" translate="yes" xml:space="preserve">
          <source>HTML_string</source>
          <target state="translated">HTML_string</target>
        </trans-unit>
        <trans-unit id="64e75e01631bde6e4c66cc0848e48e0e81e21b3e" translate="yes" xml:space="preserve">
          <source>HTTP &amp;amp; NETWORK</source>
          <target state="translated">HTTP和网络</target>
        </trans-unit>
        <trans-unit id="b9d1305b7d421bfab1c584e1b3a7cf4b5ad6100e" translate="yes" xml:space="preserve">
          <source>HTTP::Tiny</source>
          <target state="translated">HTTP::Tiny</target>
        </trans-unit>
        <trans-unit id="1593daf90ee92997798e7c9ba64487e429248ed3" translate="yes" xml:space="preserve">
          <source>HTTP::Tiny - A small, simple, correct HTTP/1.1 client</source>
          <target state="translated">HTTP::Tiny-一个小巧、简单、正确的HTTP/1.1客户端。</target>
        </trans-unit>
        <trans-unit id="6de96c82ab1c9cdb371d5db2534e8dba3e300f4b" translate="yes" xml:space="preserve">
          <source>HTTP::Tiny can proxy both &lt;code&gt;http&lt;/code&gt; and &lt;code&gt;https&lt;/code&gt; requests. Only Basic proxy authorization is supported and it must be provided as part of the proxy URL: &lt;code&gt;http://user:pass@proxy.example.com/&lt;/code&gt;.</source>
          <target state="translated">HTTP :: Tiny可以代理 &lt;code&gt;http&lt;/code&gt; 和 &lt;code&gt;https&lt;/code&gt; 请求。仅支持基本代理授权，并且必须将其作为代理URL的一部分提供： &lt;code&gt;http://user:pass@proxy.example.com/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb7c104dfa49bc8b7e9fbf8a2bf935e253a788eb" translate="yes" xml:space="preserve">
          <source>HTTP::Tiny focuses on correct transport. Users are responsible for ensuring that user-defined headers and content are compliant with the HTTP/1.1 specification.</source>
          <target state="translated">HTTP::Tiny专注于正确的传输。用户有责任确保用户定义的头和内容符合HTTP/1.1规范。</target>
        </trans-unit>
        <trans-unit id="b38d4dd8a81a735c3930f7b6f2dc55fa797343ae" translate="yes" xml:space="preserve">
          <source>HTTP::Tiny is</source>
          <target state="translated">HTTP::Tiny是</target>
        </trans-unit>
        <trans-unit id="fb10b64b6b7cee3af9f574696e99543d15e2129d" translate="yes" xml:space="preserve">
          <source>HTTP::Tiny supports the following proxy environment variables:</source>
          <target state="translated">HTTP::Tiny支持以下代理环境变量。</target>
        </trans-unit>
        <trans-unit id="2af40fad62df82d3c206edc7b46390ba49959a8f" translate="yes" xml:space="preserve">
          <source>HV</source>
          <target state="translated">HV</target>
        </trans-unit>
        <trans-unit id="9386c18987cda4e4b47eab3b2d462dd758250ce8" translate="yes" xml:space="preserve">
          <source>Ha! Try that with your garden variety regexp package...</source>
          <target state="translated">哈! 试试用你的花园品种regexp包...试着用你的花园品种regexp包......</target>
        </trans-unit>
        <trans-unit id="d88e3f220c919ffbf868396a7d774a5334f737c8" translate="yes" xml:space="preserve">
          <source>Hack, hack, hack. Keep in mind that Perl runs on many different platforms, with different operating systems that have different capabilities, different filesystem organizations, and even different character sets. &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; gives advice on this.</source>
          <target state="translated">哈克，哈克，哈克。请记住，Perl在许多不同的平台上运行，具有不同的操作系统，这些操作系统具有不同的功能，不同的文件系统组织，甚至不同的字符集。&lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips对此&lt;/a&gt;提供了建议。</target>
        </trans-unit>
        <trans-unit id="aa83b6b9d8de018c03b6e14834f7dbb735668abf" translate="yes" xml:space="preserve">
          <source>Hackathons</source>
          <target state="translated">Hackathons</target>
        </trans-unit>
        <trans-unit id="70b5ad218deb587375e9d9ea493155e8eea890e8" translate="yes" xml:space="preserve">
          <source>Hackathons are a very different kind of gathering where Perl hackers gather to do just that, hack nonstop for an extended (several day) period on a specific project or projects. Information about hackathons can be located in the same place as information about &lt;a href=&quot;#Workshops&quot;&gt;workshops&lt;/a&gt; as well as in &lt;a href=&quot;irc://irc.perl.org/#perl&quot;&gt;irc://irc.perl.org/#perl&lt;/a&gt;.</source>
          <target state="translated">黑客马拉松是一种非常不同的聚会，Perl黑客聚集在一起做，在一个或多个特定项目上长时间（几天）不间断地进行黑客入侵。关于这种形式的比赛信息可以位于同一地点的有关信息&lt;a href=&quot;#Workshops&quot;&gt;研讨会&lt;/a&gt;，以及在&lt;a href=&quot;irc://irc.perl.org/#perl&quot;&gt;IRC：//irc.perl.org/#perl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5b2f425b8ec6dc0f52bcfb2fe8c13331b8f6480" translate="yes" xml:space="preserve">
          <source>Hacking Perl to work on earlier Unicode versions (for very serious hackers only)</source>
          <target state="translated">黑进Perl,使其能在早期的Unicode版本上工作(仅供非常认真的黑客使用</target>
        </trans-unit>
        <trans-unit id="c241df4cb37e7ba32f33cd5ab23a83488a78b7ae" translate="yes" xml:space="preserve">
          <source>Hacking tools and documentation</source>
          <target state="translated">黑客工具和文件</target>
        </trans-unit>
        <trans-unit id="602beba2438c01897c485451edb2f2cc86633c34" translate="yes" xml:space="preserve">
          <source>Had to create %s unexpectedly</source>
          <target state="translated">不得不意外地创建%s</target>
        </trans-unit>
        <trans-unit id="86df64465c5e97b2cf5ef681688c0680e733d5cf" translate="yes" xml:space="preserve">
          <source>Haiku</source>
          <target state="translated">Haiku</target>
        </trans-unit>
        <trans-unit id="2cd3bee34e1e2aafe8cc6f8bcda061ef9d49610f" translate="yes" xml:space="preserve">
          <source>Half a &lt;b&gt;byte&lt;/b&gt;, equivalent to one &lt;b&gt;hexadecimal&lt;/b&gt; digit, and worth four &lt;b&gt;bits&lt;/b&gt;.</source>
          <target state="translated">半&lt;b&gt;字节&lt;/b&gt;，相当于一个&lt;b&gt;十六进制&lt;/b&gt;数字，值4 &lt;b&gt;位&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="6d8ab5e201dd91380811a77b55a7a931f3d5eee4" translate="yes" xml:space="preserve">
          <source>Halfway between &lt;code&gt;ok()&lt;/code&gt; and &lt;code&gt;is()&lt;/code&gt; lies &lt;code&gt;cmp_ok()&lt;/code&gt; . This allows you to compare two arguments using any binary perl operator. The test passes if the comparison is true and fails otherwise.</source>
          <target state="translated">在 &lt;code&gt;ok()&lt;/code&gt; 和 &lt;code&gt;is()&lt;/code&gt; 之间的 &lt;code&gt;cmp_ok()&lt;/code&gt; 是cmp_ok（）。这使您可以使用任何二进制perl运算符比较两个参数。如果比较为真，则测试通过，否则为失败。</target>
        </trans-unit>
        <trans-unit id="cfee9331a26c8019adee0d29a9ba050dd1ac3641" translate="yes" xml:space="preserve">
          <source>Halfway between &lt;code&gt;ok()&lt;/code&gt; and &lt;code&gt;is()&lt;/code&gt; lies &lt;code&gt;cmp_ok()&lt;/code&gt;. This allows you to compare two arguments using any binary perl operator. The test passes if the comparison is true and fails otherwise.</source>
          <target state="translated">在 &lt;code&gt;ok()&lt;/code&gt; 和 &lt;code&gt;is()&lt;/code&gt; 之间的 &lt;code&gt;cmp_ok()&lt;/code&gt; 是cmp_ok（）。这使您可以使用任何二进制perl运算符比较两个参数。如果比较为真，则测试通过，否则为失败。</target>
        </trans-unit>
        <trans-unit id="86179df6c35646296ecd922e347bf8fb4cdc3c6c" translate="yes" xml:space="preserve">
          <source>Hand-editing</source>
          <target state="translated">Hand-editing</target>
        </trans-unit>
        <trans-unit id="2243466296e92364f7bf27ac345ae2a71eab76a8" translate="yes" xml:space="preserve">
          <source>Handle is open.</source>
          <target state="translated">手柄是打开的。</target>
        </trans-unit>
        <trans-unit id="9bb0ae5137688cc1b8e62808a86d332a61061726" translate="yes" xml:space="preserve">
          <source>Handles compile-time scope entry. Arranges for hints to be restored on block exit and also handles pad sequence numbers to make lexical variables scope right. Returns a savestack index for use with &lt;code&gt;block_end&lt;/code&gt; .</source>
          <target state="translated">处理编译时范围条目。安排在块退出时恢复提示，并处理填充序列号以使词汇变量作用域正确。返回与使用savestack指数 &lt;code&gt;block_end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab1b19f04bb1317fba3f910449270efd5565be88" translate="yes" xml:space="preserve">
          <source>Handles compile-time scope entry. Arranges for hints to be restored on block exit and also handles pad sequence numbers to make lexical variables scope right. Returns a savestack index for use with &lt;code&gt;block_end&lt;/code&gt;.</source>
          <target state="translated">处理编译时范围条目。安排在块退出时恢复提示，并处理填充序列号以使词汇变量作用域正确。返回一个与 &lt;code&gt;block_end&lt;/code&gt; 一起使用的保存堆栈索引。</target>
        </trans-unit>
        <trans-unit id="aadca6115d853e86175413031bcfebcbec35442a" translate="yes" xml:space="preserve">
          <source>Handles compile-time scope exit.</source>
          <target state="translated">处理编译时的作用域退出。</target>
        </trans-unit>
        <trans-unit id="8e7e0dd257d42c19a22d84dd680aab03b4645ae7" translate="yes" xml:space="preserve">
          <source>Handles compile-time scope exit. &lt;code&gt;floor&lt;/code&gt; is the savestack index returned by &lt;code&gt;block_start&lt;/code&gt;, and &lt;code&gt;seq&lt;/code&gt; is the body of the block. Returns the block, possibly modified.</source>
          <target state="translated">处理编译时范围退出。 &lt;code&gt;floor&lt;/code&gt; 是由 &lt;code&gt;block_start&lt;/code&gt; 返回的savestack索引，而 &lt;code&gt;seq&lt;/code&gt; 是该块的主体。返回该块，可能已修改。</target>
        </trans-unit>
        <trans-unit id="dbbfa1a57fe1955a23aba6a4d759ffdeff314724" translate="yes" xml:space="preserve">
          <source>Handles copying &lt;code&gt;$(MYEXTLIB)&lt;/code&gt; as starter for final static library that then gets added to.</source>
          <target state="translated">处理将 &lt;code&gt;$(MYEXTLIB)&lt;/code&gt; 复制为最终静态库的启动器，然后将其添加到该库中。</target>
        </trans-unit>
        <trans-unit id="a78a213e08f22079d0727d65ee7cd82040828af3" translate="yes" xml:space="preserve">
          <source>Handles that were opened write-only won't work. Handles that were opened read-only will work as long as you don't try to modify the array. Handles must be attached to seekable sources of data---that means no pipes or sockets. If &lt;code&gt;Tie::File&lt;/code&gt; can detect that you supplied a non-seekable handle, the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call will throw an exception. (On Unix systems, it can detect this.)</source>
          <target state="translated">打开的只写句柄将不起作用。只要您不尝试修改数组，以只读方式打开的句柄就可以工作。必须将句柄附加到可搜索的数据源上，这意味着没有管道或插座。如果 &lt;code&gt;Tie::File&lt;/code&gt; 可以检测到您提供了不可搜索的句柄，则 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用将引发异常。（在Unix系统上，它可以检测到这一点。）</target>
        </trans-unit>
        <trans-unit id="5f2455dc72c01e04f7cb2a120d3caf4c7e83b89d" translate="yes" xml:space="preserve">
          <source>Handles that were opened write-only won't work. Handles that were opened read-only will work as long as you don't try to modify the array. Handles must be attached to seekable sources of data---that means no pipes or sockets. If &lt;code&gt;Tie::File&lt;/code&gt; can detect that you supplied a non-seekable handle, the &lt;code&gt;tie&lt;/code&gt; call will throw an exception. (On Unix systems, it can detect this.)</source>
          <target state="translated">打开的只写句柄将不起作用。只要您不尝试修改数组，以只读方式打开的句柄就可以工作。必须将句柄附加到可搜索的数据源上，这意味着没有管道或插座。如果 &lt;code&gt;Tie::File&lt;/code&gt; 可以检测到您提供了不可搜索的句柄，则 &lt;code&gt;tie&lt;/code&gt; 调用将引发异常。（在Unix系统上，它可以检测到这一点。）</target>
        </trans-unit>
        <trans-unit id="3dca08a90c7ec673523c972aeb9655cc6ba04e87" translate="yes" xml:space="preserve">
          <source>Handles the installing and uninstalling of perl modules, scripts, man pages, etc...</source>
          <target state="translated">处理perl模块、脚本、man页等的安装和卸载。</target>
        </trans-unit>
        <trans-unit id="caa1714db5e5ddfa607afe3449dc66f6283180d0" translate="yes" xml:space="preserve">
          <source>Handling Duplicate Keys</source>
          <target state="translated">处理重复的钥匙</target>
        </trans-unit>
        <trans-unit id="0f01c504507d7832a1cac719e698e1e7e8a378a8" translate="yes" xml:space="preserve">
          <source>Handling Malformed Data</source>
          <target state="translated">处理畸形数据</target>
        </trans-unit>
        <trans-unit id="f0f0fc76a1e441991cde68774fcefb6a0861fb18" translate="yes" xml:space="preserve">
          <source>Handling Unicode</source>
          <target state="translated">处理Unicode</target>
        </trans-unit>
        <trans-unit id="5c331b1b1b146d85b0798abcb652f4dbd9cc2a65" translate="yes" xml:space="preserve">
          <source>Handling Unicode is for the most part transparent: just use the strings as usual. Functions like &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; will work on the Unicode characters; regular expressions will work on the Unicode characters (see &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;).</source>
          <target state="translated">处理Unicode在大多数情况下是透明的：只需照常使用字符串即可。诸如 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; 之类的函数将对Unicode字符起作用；正则表达式适用于Unicode字符（请参阅&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;和&lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b53b68423a2d10312f79c4e7788b10fc80971e39" translate="yes" xml:space="preserve">
          <source>Handling Unicode is for the most part transparent: just use the strings as usual. Functions like &lt;code&gt;index()&lt;/code&gt;, &lt;code&gt;length()&lt;/code&gt;, and &lt;code&gt;substr()&lt;/code&gt; will work on the Unicode characters; regular expressions will work on the Unicode characters (see &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;).</source>
          <target state="translated">处理Unicode在大多数情况下是透明的：只需照常使用字符串即可。诸如 &lt;code&gt;index()&lt;/code&gt; ， &lt;code&gt;length()&lt;/code&gt; 和 &lt;code&gt;substr()&lt;/code&gt; 之类的函数将对Unicode字符起作用；正则表达式将适用于Unicode字符（请参阅&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;和&lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="88d69acff614c1d827ede2f260f6a46a48647c42" translate="yes" xml:space="preserve">
          <source>Handling simple options is straightforward:</source>
          <target state="translated">处理简单的选项是直接的。</target>
        </trans-unit>
        <trans-unit id="8e71d792bc3c7ca46b9ebe6e4e08dc39ffe6877b" translate="yes" xml:space="preserve">
          <source>Handling the SIGHUP Signal in Daemons</source>
          <target state="translated">处理Daemons中的SIGHUP信号</target>
        </trans-unit>
        <trans-unit id="6e120aed62a343cea2462c78b0c345bd93d57340" translate="yes" xml:space="preserve">
          <source>Handy Values</source>
          <target state="translated">便利值</target>
        </trans-unit>
        <trans-unit id="049503c569a7548e0e0aaf7ff650cdb7e260c634" translate="yes" xml:space="preserve">
          <source>Handy for putting in notes which might be useful for debugging, but don't indicate a problem.</source>
          <target state="translated">便于放入可能对调试有用的注释,但不表明问题。</target>
        </trans-unit>
        <trans-unit id="57d70b3a1b3e8f06b27f21ad6f5e77255bd44b1f" translate="yes" xml:space="preserve">
          <source>Handy for things like...</source>
          <target state="translated">方便的事情,如...</target>
        </trans-unit>
        <trans-unit id="04a45a64a65bd1462cbe3b6ef2c3619b7fc7d816" translate="yes" xml:space="preserve">
          <source>Handy for this sort of thing:</source>
          <target state="translated">对这种事情很方便。</target>
        </trans-unit>
        <trans-unit id="eb631afbbf9621a14aebc98eacec8ff594f19f3b" translate="yes" xml:space="preserve">
          <source>Handy tip: put &lt;code&gt;set PERLDOC=-ortf&lt;/code&gt; in your</source>
          <target state="translated">实用提示：将 &lt;code&gt;set PERLDOC=-ortf&lt;/code&gt; 放入您的</target>
        </trans-unit>
        <trans-unit id="506eecb432a2c8fe45656c023dac6e502795db55" translate="yes" xml:space="preserve">
          <source>Hangul Syllable Type</source>
          <target state="translated">韩语音节类型</target>
        </trans-unit>
        <trans-unit id="951499a6cfa4736aa7a1d36a7019e79078429a7e" translate="yes" xml:space="preserve">
          <source>HangulSyllableType.txt</source>
          <target state="translated">HangulSyllableType.txt</target>
        </trans-unit>
        <trans-unit id="7cf3612d90dc653542fad94e9962eab0afe4c4ac" translate="yes" xml:space="preserve">
          <source>Hans Dieter Pearcey &lt;code&gt;hdp@cpan.org&lt;/code&gt;</source>
          <target state="translated">汉斯&amp;middot;迪特&amp;middot;皮尔斯（Hans Dieter Pearcey） &lt;code&gt;hdp@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc5f45cb92e25fd3e9f4ed85dddd70a19341bbf4" translate="yes" xml:space="preserve">
          <source>Hard and symbolic (&quot;soft&quot;) links; linkname should specify target.</source>
          <target state="translated">硬链接和符号链接(&quot;软&quot;);链接名应指定目标。</target>
        </trans-unit>
        <trans-unit id="cdae1ec5d05114509a53fe67f0320c6eadea6400" translate="yes" xml:space="preserve">
          <source>Hard links are implemented on Win32 under NTFS only. They are natively supported on Windows 2000 and later. On Windows NT they are implemented using the Windows POSIX subsystem support and the Perl process will need Administrator or Backup Operator privileges to create hard links.</source>
          <target state="translated">硬链接仅在NTFS下的Win32上实现。在Windows 2000及以后的版本中,硬链接是本地支持的。在Windows NT上,它们是通过Windows POSIX子系统支持来实现的,Perl进程需要管理员或备份操作员权限来创建硬链接。</target>
        </trans-unit>
        <trans-unit id="fd756d3e871622cf9bdef94fc2aa35729d65f76a" translate="yes" xml:space="preserve">
          <source>Hard references are smart--they keep track of reference counts for you, automatically freeing the thing referred to when its reference count goes to zero. (Reference counts for values in self-referential or cyclic data structures may not go to zero without a little help; see &lt;a href=&quot;#Circular-References&quot;&gt;&quot;Circular References&quot;&lt;/a&gt; for a detailed explanation.) If that thing happens to be an object, the object is destructed. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more about objects. (In a sense, everything in Perl is an object, but we usually reserve the word for references to objects that have been officially &quot;blessed&quot; into a class package.)</source>
          <target state="translated">硬引用很聪明-他们会为您跟踪引用计数，当引用计数变为零时会自动释放所引用的对象。 （自引用或循环数据结构中的值的引用计数在没有一点帮助的情况下可能不会为零；有关详细说明，请参见&lt;a href=&quot;#Circular-References&quot;&gt;&amp;ldquo;循环引用&amp;rdquo;&lt;/a&gt;。）如果该对象碰巧是一个对象，则该对象将被破坏。有关对象的更多信息，请参见&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。 （从某种意义上说，Perl中的所有内容都是一个对象，但是我们通常保留这个词来表示对已经被正式&amp;ldquo;祝福&amp;rdquo;到一个类包中的对象的引用。）</target>
        </trans-unit>
        <trans-unit id="7cec0c304aaf210bfe25cbb78814c09191b199ee" translate="yes" xml:space="preserve">
          <source>Hard references are smart--they keep track of reference counts for you, automatically freeing the thing referred to when its reference count goes to zero. (Reference counts for values in self-referential or cyclic data structures may not go to zero without a little help; see &lt;a href=&quot;#Circular-References&quot;&gt;Circular References&lt;/a&gt; for a detailed explanation.) If that thing happens to be an object, the object is destructed. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more about objects. (In a sense, everything in Perl is an object, but we usually reserve the word for references to objects that have been officially &quot;blessed&quot; into a class package.)</source>
          <target state="translated">硬引用很聪明-他们为您跟踪引用计数，当引用计数变为零时会自动释放所引用的对象。（自引用或循环数据结构中值的引用计数在没有一点帮助的情况下可能不会为零；有关详细说明，请参见&lt;a href=&quot;#Circular-References&quot;&gt;循环引用&lt;/a&gt;。）如果该对象碰巧是一个对象，则该对象将被破坏。有关对象的更多信息，请参见&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。（从某种意义上说，Perl中的所有内容都是一个对象，但是我们通常保留该词用于引用已被正式&amp;ldquo;祝福&amp;rdquo;到类包中的对象。）</target>
        </trans-unit>
        <trans-unit id="66e944742ea0249f6f2a6fd52c3e9e415e65aaeb" translate="yes" xml:space="preserve">
          <source>Harness output delegate for default console output</source>
          <target state="translated">驾驭输出委托,实现默认的控制台输出</target>
        </trans-unit>
        <trans-unit id="2dd2c2e596e19cb5f6f12eac61588cccdf06ec03" translate="yes" xml:space="preserve">
          <source>Harness output delegate for file output</source>
          <target state="translated">驾驭输出委托,用于文件输出</target>
        </trans-unit>
        <trans-unit id="363bd8bca1592722722a3ac3fe8ee3189add2d7b" translate="yes" xml:space="preserve">
          <source>Harness output delegate for parallel console output</source>
          <target state="translated">驾驭输出委托,实现并行控制台输出</target>
        </trans-unit>
        <trans-unit id="ba951792ddfec9b17fd8944b4026a028108c3aa1" translate="yes" xml:space="preserve">
          <source>Has already been</source>
          <target state="translated">已经</target>
        </trans-unit>
        <trans-unit id="d8861f9d9089d32f3fb836f33024a00d9824a27b" translate="yes" xml:space="preserve">
          <source>Has global effect, persists after the application exits.</source>
          <target state="translated">具有全局性效果,在应用程序退出后持续存在。</target>
        </trans-unit>
        <trans-unit id="d791fc07c3f03c0d15e5cd282a309f1887be4bb0" translate="yes" xml:space="preserve">
          <source>Has it been done before?</source>
          <target state="translated">以前有做过吗?</target>
        </trans-unit>
        <trans-unit id="2929382f580bfdd31a77bfbbda12fefbb2e9c2b6" translate="yes" xml:space="preserve">
          <source>Has the same behavior as the match operator. Also, the left operand of &lt;code&gt;=~&lt;/code&gt; becomes tainted when a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect, if modified as a result of a substitution based on a regular expression match involving any of the things mentioned in the previous item, or of case-mapping, such as &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; ,&lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , or &lt;code&gt;\F&lt;/code&gt; .</source>
          <target state="translated">具有与match运算符相同的行为。同样，当包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境形式生效时， &lt;code&gt;=~&lt;/code&gt; 的左操作数也会受到污染，如果是基于涉及上一项提到的任何事情的正则表达式匹配的替换结果而进行修改的话， -mapping，如 &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; ， &lt;code&gt;\U&lt;/code&gt; ，或 &lt;code&gt;\F&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0b06c2eb9bde536e47408d65b8dbc18da216062" translate="yes" xml:space="preserve">
          <source>Has the same behavior as the match operator. Also, the left operand of &lt;code&gt;=~&lt;/code&gt; becomes tainted when a &lt;code&gt;use locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect, if modified as a result of a substitution based on a regular expression match involving any of the things mentioned in the previous item, or of case-mapping, such as &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;,&lt;code&gt;\u&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, or &lt;code&gt;\F&lt;/code&gt;.</source>
          <target state="translated">具有与match运算符相同的行为。另外，当包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的 &lt;code&gt;use locale&lt;/code&gt; 形式有效时， &lt;code&gt;=~&lt;/code&gt; 的左操作数也会受到污染，如果是基于涉及上一项提到的任何事情的正则表达式匹配的替换结果而进行修改的话， -mapping，如 &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; ， &lt;code&gt;\U&lt;/code&gt; ，或 &lt;code&gt;\F&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cd8a4f5a97ed6a865ef03c82bac1954b46e0a68" translate="yes" xml:space="preserve">
          <source>Hash (&lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt;)</source>
          <target state="translated">哈希（ &lt;code&gt;'%'&lt;/code&gt; 或 &lt;code&gt;'*%'&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e2e911d125c069efa7d913b344e0f08f8969421a" translate="yes" xml:space="preserve">
          <source>Hash API Extensions</source>
          <target state="translated">哈希API扩展</target>
        </trans-unit>
        <trans-unit id="ffc5f6e94a276eeaf94de20a0e4f426d64a6723d" translate="yes" xml:space="preserve">
          <source>Hash Algorithm - Hash algorithms like the one used in Perl are well known to be vulnerable to collision attacks on their hash function. Such attacks involve constructing a set of keys which collide into the same bucket producing inefficient behavior. Such attacks often depend on discovering the seed of the hash function used to map the keys to buckets. That seed is then used to brute-force a key set which can be used to mount a denial of service attack. In Perl 5.8.1 changes were introduced to harden Perl to such attacks, and then later in Perl 5.18.0 these features were enhanced and additional protections added.</source>
          <target state="translated">散列算法-众所周知,像Perl中使用的散列算法在其散列函数上容易受到碰撞攻击。这种攻击涉及到构建一组密钥,这些密钥会碰撞到同一个桶中,从而产生低效率的行为。这种攻击通常依赖于发现用于将密钥映射到桶的哈希函数的种子。然后,这个种子就会被用来粗暴地强制执行一个密钥集,而这个密钥集可以用来发动拒绝服务攻击。在Perl 5.8.1中,我们引入了一些变化,以使Perl能够抵御这种攻击,后来在Perl 5.18.0中,这些功能得到了加强,并增加了额外的保护措施。</target>
        </trans-unit>
        <trans-unit id="f61062d96868959d8bad3f3f9d8706be2a8eb3f6" translate="yes" xml:space="preserve">
          <source>Hash Manipulation Functions</source>
          <target state="translated">哈希操作函数</target>
        </trans-unit>
        <trans-unit id="722f31dda86bb5212ab7b2c1afdf8b00513530ac" translate="yes" xml:space="preserve">
          <source>Hash Seed Randomization</source>
          <target state="translated">哈希种子随机化</target>
        </trans-unit>
        <trans-unit id="7a28810109f74274cf74cf5b33143c35d878dd91" translate="yes" xml:space="preserve">
          <source>Hash Traversal Randomization</source>
          <target state="translated">哈希遍历随机化</target>
        </trans-unit>
        <trans-unit id="eacc32410490d8f503c47a016128793f41b30f3f" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;&quot;Algorithmic Complexity Attacks&quot; in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl.</source>
          <target state="translated">哈希条目以明显随机的顺序返回。实际的随机顺序特定于给定的哈希。在两个哈希上执行的完全相同的一系列操作可能会导致每个哈希的顺序不同。哈希中的任何插入都可以更改顺序，删除操作也可以更改顺序，不同之处在于可以删除&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;或键返回的最新键，而无需更改顺序。只要给定的哈希是未修改的，您就可以依赖&lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;来重复地返回彼此相同的顺序。请参见&lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec中的&amp;ldquo;算法复杂度攻击&amp;rdquo;&lt;/a&gt;有关为何随机化哈希顺序的详细信息。除了此处提供的保证外，在任何Perl版本中，Perl哈希算法的确切详细信息和哈希遍历顺序均可能发生变化。</target>
        </trans-unit>
        <trans-unit id="431e8961d246bf31774f7d0fd18486a3592113ae" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;&quot;Algorithmic Complexity Attacks&quot; in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl. Tied hashes may behave differently to Perl's hashes with respect to changes in order on insertion and deletion of items.</source>
          <target state="translated">哈希条目以明显随机的顺序返回。实际的随机顺序特定于给定的哈希。在两个哈希上执行的完全相同的一系列操作可能会导致每个哈希的顺序不同。哈希中的任何插入都可以更改顺序，删除操作也可以更改顺序，不同之处在于可以删除&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;或键返回的最新键，而无需更改顺序。只要给定的哈希是未修改的，您就可以依赖&lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;来重复地返回彼此相同的顺序。请参见&lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec中的&amp;ldquo;算法复杂度攻击&amp;rdquo;&lt;/a&gt;有关为何随机化哈希顺序的详细信息。除了此处提供的保证外，在任何Perl版本中，Perl哈希算法的确切详细信息和哈希遍历顺序均可能发生变化。在项插入和删除的顺序更改方面，绑定的哈希行为可能与Perl的哈希行为不同。</target>
        </trans-unit>
        <trans-unit id="305905caf9fb73ce326146ab6da346f5a44d3d5e" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl.</source>
          <target state="translated">哈希条目以明显随机的顺序返回。实际的随机顺序特定于给定的哈希。对两个散列进行完全相同的一系列操作可能会导致每个散列的顺序不同。散列中的任何插入都可以更改顺序，删除操作也可以更改顺序，不同之处在于， &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 返回的最新密钥可以在不更改顺序的情况下被删除。只要给定的哈希是未修改的，您就可以依赖 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 来重复返回彼此相同的顺序。请参阅&lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec中的算法复杂度攻击&lt;/a&gt;有关为何哈希顺序随机化的详细信息。除了此处提供的保证外，在任何Perl版本中，Perl哈希算法的确切详细信息和哈希遍历顺序均可能发生变化。</target>
        </trans-unit>
        <trans-unit id="38990845f56b0504f14a42e264d2e90a4529057f" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl. Tied hashes may behave differently to Perl's hashes with respect to changes in order on insertion and deletion of items.</source>
          <target state="translated">哈希条目以明显随机的顺序返回。实际的随机顺序特定于给定的哈希。对两个散列进行完全相同的一系列操作可能会导致每个散列的顺序不同。散列中的任何插入都可以更改顺序，删除操作也可以更改顺序，不同之处在于， &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 返回的最新密钥可以在不更改顺序的情况下被删除。只要给定的哈希是未修改的，您就可以依赖 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 来重复返回彼此相同的顺序。请参阅&lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec中的算法复杂度攻击&lt;/a&gt;有关为何哈希顺序随机化的详细信息。除了此处提供的保证外，在任何Perl版本中，Perl哈希算法的确切详细信息和哈希遍历顺序均可能发生变化。在项的插入和删除方面，绑定的哈希行为可能与Perl的哈希有所不同。</target>
        </trans-unit>
        <trans-unit id="e9c5186b59e1d86cc131a1fce52452e4e4a1c3b7" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl.</source>
          <target state="translated">哈希条目以明显随机的顺序返回。实际的随机顺序特定于给定的哈希。对两个散列进行完全相同的一系列操作可能会导致每个散列的顺序不同。散列中的任何插入都可以更改顺序，删除操作也可以更改顺序，不同之处在于， &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 返回的最新密钥可以在不更改顺序的情况下被删除。只要给定的哈希是未修改的，您就可以依赖 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 来重复返回彼此相同的顺序。请参阅&lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec中的算法复杂度攻击&lt;/a&gt;有关为何哈希顺序随机化的详细信息。除了此处提供的保证外，在任何Perl版本中，Perl哈希算法的确切详细信息和哈希遍历顺序均可能发生变化。</target>
        </trans-unit>
        <trans-unit id="c3ca36bf1a5daf8ef9f034a1d277717a3712e5c2" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl. Tied hashes may behave differently to Perl's hashes with respect to changes in order on insertion and deletion of items.</source>
          <target state="translated">哈希条目以明显随机的顺序返回。实际的随机顺序特定于给定的哈希。对两个散列进行完全相同的一系列操作可能会导致每个散列的顺序不同。散列中的任何插入都可以更改顺序，删除操作也可以更改顺序，不同之处在于， &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 返回的最新密钥可以在不更改顺序的情况下被删除。只要给定的哈希是未修改的，您就可以依赖 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 来重复返回彼此相同的顺序。请参阅&lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec中的算法复杂度攻击&lt;/a&gt;有关为何哈希顺序随机化的详细信息。除了此处提供的保证外，在任何Perl版本中，Perl哈希算法的确切详细信息和哈希遍历顺序均可能发生变化。在项的插入和删除方面，绑定的哈希行为可能与Perl的哈希有所不同。</target>
        </trans-unit>
        <trans-unit id="450c7d18d41b71db86a014ec4874cb370e9139cb" translate="yes" xml:space="preserve">
          <source>Hash keys are &lt;b&gt;never&lt;/b&gt; tainted.</source>
          <target state="translated">哈希键&lt;b&gt;永远不会&lt;/b&gt;被污染。</target>
        </trans-unit>
        <trans-unit id="d3bb008d092d1635eab043a4b8199104071bf333" translate="yes" xml:space="preserve">
          <source>Hash keys are strings, so you can't really use a reference as the key. When you try to do that, perl turns the reference into its stringified form (for instance, &lt;code&gt;HASH(0xDEADBEEF)&lt;/code&gt; ). From there you can't get back the reference from the stringified form, at least without doing some extra work on your own.</source>
          <target state="translated">哈希键是字符串，因此您不能真正使用引用作为键。当您尝试执行此操作时，perl会将引用转换为它的字符串化形式（例如 &lt;code&gt;HASH(0xDEADBEEF)&lt;/code&gt; ）。从那里，您至少不能自己做一些额外的工作，就无法从字符串化形式中获取引用。</target>
        </trans-unit>
        <trans-unit id="256656f318911c4b99b0f0616a83baa9886ad936" translate="yes" xml:space="preserve">
          <source>Hash keys are strings, so you can't really use a reference as the key. When you try to do that, perl turns the reference into its stringified form (for instance, &lt;code&gt;HASH(0xDEADBEEF)&lt;/code&gt;). From there you can't get back the reference from the stringified form, at least without doing some extra work on your own.</source>
          <target state="translated">哈希键是字符串，因此您不能真正使用引用作为键。当您尝试执行此操作时，perl会将引用转换为它的字符串化形式（例如 &lt;code&gt;HASH(0xDEADBEEF)&lt;/code&gt; ）。从那里，您至少无法自己做一些额外的工作，就无法从字符串化形式中获取引用。</target>
        </trans-unit>
        <trans-unit id="81c6d3b1e20fc06f0ae8fafd3e33b459483ea84f" translate="yes" xml:space="preserve">
          <source>Hash lookup of which core extensions were built.</source>
          <target state="translated">哈希查找哪些核心扩展是建立的。</target>
        </trans-unit>
        <trans-unit id="a78b3989df5bd5b4bee3a8e811b9eb95d6fd1010" translate="yes" xml:space="preserve">
          <source>Hash refs</source>
          <target state="translated">哈希裁判</target>
        </trans-unit>
        <trans-unit id="28bd740a5fed92f4652182fc91352eb825ae6b82" translate="yes" xml:space="preserve">
          <source>Hash subscripts are similar, only instead of square brackets curly brackets are used. For example:</source>
          <target state="translated">哈希下标也是类似的,只是不用方括号,而是用大括号。例如:</target>
        </trans-unit>
        <trans-unit id="0f05d6e4a748b9c8f33a3dd349b88ed9bc020a76" translate="yes" xml:space="preserve">
          <source>Hash values do not spring into existence upon mere reference.</source>
          <target state="translated">哈希值不会因为单纯的引用而产生。</target>
        </trans-unit>
        <trans-unit id="060e2951a35019d6292c77892149e6ae4655ab4b" translate="yes" xml:space="preserve">
          <source>Hash::Util</source>
          <target state="translated">Hash::Util</target>
        </trans-unit>
        <trans-unit id="6df60ce76a6dd2245295b960eb619bae5a40a333" translate="yes" xml:space="preserve">
          <source>Hash::Util - A selection of general-utility hash subroutines</source>
          <target state="translated">Hash::Util-一个通用的哈希子程序选择。</target>
        </trans-unit>
        <trans-unit id="fc6dfd7516cd148dfcfbc9b4b53977f84b109b02" translate="yes" xml:space="preserve">
          <source>Hash::Util::FieldHash</source>
          <target state="translated">Hash::Util::FieldHash</target>
        </trans-unit>
        <trans-unit id="2761eb764ac1f31cb8db8bfca9f4810ccd72d904" translate="yes" xml:space="preserve">
          <source>Hash::Util::FieldHash - Support for Inside-Out Classes</source>
          <target state="translated">Hash::Util::FieldHash-支持内外类。</target>
        </trans-unit>
        <trans-unit id="7586bfa5dab5c10b087765f9a931752b869fef56" translate="yes" xml:space="preserve">
          <source>HashBase will not export &lt;code&gt;new()&lt;/code&gt; if there is already a &lt;code&gt;new()&lt;/code&gt; method in your packages inheritance chain.</source>
          <target state="translated">如果您的包继承链中已经存在 &lt;code&gt;new()&lt;/code&gt; 方法，则HashBase将不会导出 &lt;code&gt;new()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5551ebd48f7eaa66477f72c449e4b2ccfc0f9609" translate="yes" xml:space="preserve">
          <source>Hashes</source>
          <target state="translated">Hashes</target>
        </trans-unit>
        <trans-unit id="5003cfd9a645097d80f1b1984336d3badcf5c150" translate="yes" xml:space="preserve">
          <source>Hashes contain pairs of scalars: the first is the key, the second is the value. The key will be coerced to a string, although the value can be any kind of scalar: string, number, or reference. If a key &lt;code&gt;$key&lt;/code&gt; is present in %hash, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($hash{$key})&lt;/a&gt;&lt;/code&gt; will return true. The value for a given key can be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, in which case &lt;code&gt;$hash{$key}&lt;/code&gt; will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; while &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $hash{$key}&lt;/code&gt; will return true. This corresponds to (&lt;code&gt;$key&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) being in the hash.</source>
          <target state="translated">散列包含成对的标量：第一个是键，第二个是值。尽管值可以是任何标量：字符串，数字或引用，但键将强制为字符串。如果％hash中 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($hash{$key})&lt;/a&gt;&lt;/code&gt; 键 &lt;code&gt;$key&lt;/code&gt; ，则exist（$ hash {$ key}）将返回true。给定键的值可以是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，在这种情况下 &lt;code&gt;$hash{$key}&lt;/code&gt; 将是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ,而 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $hash{$key}&lt;/code&gt; 将返回true。这对应于（ &lt;code&gt;$key&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ）在哈希中。</target>
        </trans-unit>
        <trans-unit id="ed15845c84e91acb212b68d97fc5cccfa145f86e" translate="yes" xml:space="preserve">
          <source>Hashes contain pairs of scalars: the first is the key, the second is the value. The key will be coerced to a string, although the value can be any kind of scalar: string, number, or reference. If a key &lt;code&gt;$key&lt;/code&gt; is present in %hash, &lt;code&gt;exists($hash{$key})&lt;/code&gt; will return true. The value for a given key can be &lt;code&gt;undef&lt;/code&gt;, in which case &lt;code&gt;$hash{$key}&lt;/code&gt; will be &lt;code&gt;undef&lt;/code&gt; while &lt;code&gt;exists $hash{$key}&lt;/code&gt; will return true. This corresponds to (&lt;code&gt;$key&lt;/code&gt;, &lt;code&gt;undef&lt;/code&gt;) being in the hash.</source>
          <target state="translated">散列包含成对的标量：第一个是键，第二个是值。尽管值可以是任何类型的标量：字符串，数字或引用，但键将被强制为字符串。如果％hash中 &lt;code&gt;exists($hash{$key})&lt;/code&gt; 键 &lt;code&gt;$key&lt;/code&gt; ，则exist（$ hash {$ key}）将返回true。给定键的值可以是 &lt;code&gt;undef&lt;/code&gt; ，在这种情况下 &lt;code&gt;$hash{$key}&lt;/code&gt; 将是 &lt;code&gt;undef&lt;/code&gt; ,而 &lt;code&gt;exists $hash{$key}&lt;/code&gt; 将返回true。这对应于（ &lt;code&gt;$key&lt;/code&gt; ， &lt;code&gt;undef&lt;/code&gt; ）在哈希中。</target>
        </trans-unit>
        <trans-unit id="a5674cfb04f68937d23325c6f7c4d9203e5e6faf" translate="yes" xml:space="preserve">
          <source>Hashes have no particular internal order, though you can sort the keys and loop through them.</source>
          <target state="translated">哈希值没有特定的内部顺序,尽管你可以对键进行排序和循环。</target>
        </trans-unit>
        <trans-unit id="11d64fa5d0ff2f867536af648f416f1c5edf27d3" translate="yes" xml:space="preserve">
          <source>Hashes were the first Perl data type to be tied (see dbmopen()). A class implementing a tied hash should define the following methods: TIEHASH is the constructor. FETCH and STORE access the key and value pairs. EXISTS reports whether a key is present in the hash, and DELETE deletes one. CLEAR empties the hash by deleting all the key and value pairs. FIRSTKEY and NEXTKEY implement the keys() and each() functions to iterate over all the keys. SCALAR is triggered when the tied hash is evaluated in scalar context, and in 5.28 onwards, by &lt;code&gt;keys&lt;/code&gt; in boolean context. UNTIE is called when &lt;code&gt;untie&lt;/code&gt; happens, and DESTROY is called when the tied variable is garbage collected.</source>
          <target state="translated">哈希是第一个要绑定的Perl数据类型（请参见dbmopen（））。实现绑定哈希的类应定义以下方法：TIEHASH是构造函数。 FETCH和STORE访问键和值对。 EXISTS报告哈希中是否存在一个密钥，DELETE删除一个密钥。 CLEAR通过删除所有键和值对来清空哈希。 FIRSTKEY和NEXTKEY实现keys（）和each（）函数以迭代所有键。当在标量上下文中以及从5.28开始，通过布尔上下文中的 &lt;code&gt;keys&lt;/code&gt; 对绑定哈希进行求值时，将触发SCALAR 。发生 &lt;code&gt;untie&lt;/code&gt; 时调用UNTIE ，并在垃圾回收到绑定变量时调用DESTROY。</target>
        </trans-unit>
        <trans-unit id="11a5b7f57189106155ae1686164009308c7fb48e" translate="yes" xml:space="preserve">
          <source>Hashes were the first Perl data type to be tied (see dbmopen()). A class implementing a tied hash should define the following methods: TIEHASH is the constructor. FETCH and STORE access the key and value pairs. EXISTS reports whether a key is present in the hash, and DELETE deletes one. CLEAR empties the hash by deleting all the key and value pairs. FIRSTKEY and NEXTKEY implement the keys() and each() functions to iterate over all the keys. SCALAR is triggered when the tied hash is evaluated in scalar context. UNTIE is called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens, and DESTROY is called when the tied variable is garbage collected.</source>
          <target state="translated">哈希是第一个要绑定的Perl数据类型（请参见dbmopen（））。实现绑定哈希的类应定义以下方法：TIEHASH是构造函数。 FETCH和STORE访问键和值对。 EXISTS报告哈希中是否存在密钥，DELETE删除密钥。 CLEAR通过删除所有键和值对来清空哈希。 FIRSTKEY和NEXTKEY实现keys（）和each（）函数以迭代所有键。当在标量上下文中计算绑定哈希时，将触发SCALAR。发生 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 绑时调用UNTIE ，并在对绑定变量进行垃圾回收时调用DESTROY。</target>
        </trans-unit>
        <trans-unit id="00ee967aadbfebd86b3235daf9d26b53205682c3" translate="yes" xml:space="preserve">
          <source>Hashing order and checksums</source>
          <target state="translated">散列顺序和校验和</target>
        </trans-unit>
        <trans-unit id="3f4d761db68098a751847d9083882bbf309c01a1" translate="yes" xml:space="preserve">
          <source>Hashref of .pm files and *.pl files to be installed. e.g.</source>
          <target state="translated">要安装的.pm文件和*.pl文件的Hashref,如</target>
        </trans-unit>
        <trans-unit id="e654482e1464037d016cd8389b44c8067b3f7edd" translate="yes" xml:space="preserve">
          <source>Hashref of .xs files. MakeMaker will default this. e.g.</source>
          <target state="translated">.xs文件的Hashref。MakeMaker会默认这样做,例如:。</target>
        </trans-unit>
        <trans-unit id="54306e4b7a73d064c3f0a92d38a328cc3c6fc248" translate="yes" xml:space="preserve">
          <source>Hashref of pod-containing files. MakeMaker will default this to all EXE_FILES files that include POD directives. The files listed here will be converted to man pages and installed as was requested at Configure time.</source>
          <target state="translated">包含pod的文件的Hashref。MakeMaker将默认为所有包含POD指令的EXE_FILES文件。这里列出的文件将被转换为man页,并按照配置时的要求进行安装。</target>
        </trans-unit>
        <trans-unit id="e03929c9c89c518c1a46f519dc21b0db453de58a" translate="yes" xml:space="preserve">
          <source>Hashref of symbol names for routines to be made available as universal symbols. Each key/value pair consists of the package name and an array of routine names in that package. Used only under AIX, OS/2, VMS and Win32 at present. The routine names supplied will be expanded in the same way as XSUB names are expanded by the XS() macro. Defaults to</source>
          <target state="translated">将作为通用符号提供的例程的符号名称的哈希夫。每个键/值对由软件包名称和该软件包中的例程名称数组组成。目前只在AIX、OS/2、VMS和Win32下使用。提供的例程名称将以XSUB名称被XS()宏扩展的方式进行扩展。默认值为</target>
        </trans-unit>
        <trans-unit id="0e5b1d03af67cbc5ad483521c6061ce63fe7c5e2" translate="yes" xml:space="preserve">
          <source>Hashref that assigns to *.pm and *.pod files the files into which the manpages are to be written. MakeMaker parses all *.pod and *.pm files for POD directives. Files that contain POD will be the default keys of the MAN3PODS hashref. These will then be converted to man pages during &lt;code&gt;make&lt;/code&gt; and will be installed during &lt;code&gt;make install&lt;/code&gt; .</source>
          <target state="translated">分配给* .pm和* .pod的Hashref文件将要写入手册页的文件。MakeMaker解析所有* .pod和* .pm文件以获取POD指令。包含POD的文件将是MAN3PODS hashref的默认键。然后，这些文件将在 &lt;code&gt;make&lt;/code&gt; 期间转换为手册页，并将在 &lt;code&gt;make install&lt;/code&gt; 期间安装。</target>
        </trans-unit>
        <trans-unit id="e298a85cf0430820689a9fd4666229176cc4269d" translate="yes" xml:space="preserve">
          <source>Hashref that assigns to *.pm and *.pod files the files into which the manpages are to be written. MakeMaker parses all *.pod and *.pm files for POD directives. Files that contain POD will be the default keys of the MAN3PODS hashref. These will then be converted to man pages during &lt;code&gt;make&lt;/code&gt; and will be installed during &lt;code&gt;make install&lt;/code&gt;.</source>
          <target state="translated">分配给* .pm和* .pod的Hashref文件将要写入手册页的文件。MakeMaker解析所有* .pod和* .pm文件以获取POD指令。包含POD的文件将是MAN3PODS hashref的默认键。然后，这些文件将在 &lt;code&gt;make&lt;/code&gt; 期间转换为手册页，并在 &lt;code&gt;make install&lt;/code&gt; 期间安装。</target>
        </trans-unit>
        <trans-unit id="a765c84d56e0aa5f774648e2602400523cde1aca" translate="yes" xml:space="preserve">
          <source>Hashref with options controlling the operation of &lt;code&gt;XSMULTI&lt;/code&gt;:</source>
          <target state="translated">具有控制 &lt;code&gt;XSMULTI&lt;/code&gt; 操作的选项的Hashref：</target>
        </trans-unit>
        <trans-unit id="b7c40a20db4b296ec67dfa94b908457cfde4c540" translate="yes" xml:space="preserve">
          <source>Have a .ucm file ready. You can get it from somewhere or you can write your own from scratch or you can grab one from the Encode distribution and customize it. For the UCM format, see the next Chapter. In the example below, I'll call my theoretical encoding myascii, defined in</source>
          <target state="translated">准备好一个.ucm文件。你可以从某个地方得到它,或者你可以从头开始写你自己的文件,或者你可以从Encode发行版中抓取一个文件并进行定制。关于ucm格式,请看下一章。在下面的例子中,我将把我的理论编码称为myascii,定义为</target>
        </trans-unit>
        <trans-unit id="7e1aafb3365aa620ad71622b6d9e66ff51332860" translate="yes" xml:space="preserve">
          <source>Have a look at the &lt;code&gt;look&lt;/code&gt; (!) command.</source>
          <target state="translated">看一下 &lt;code&gt;look&lt;/code&gt; （！）命令。</target>
        </trans-unit>
        <trans-unit id="8d27c15838302800e87f5a9ade00864fd9b117bc" translate="yes" xml:space="preserve">
          <source>Have a look at the CPAN::Site module.</source>
          <target state="translated">请看一下CPAN::Site模块。</target>
        </trans-unit>
        <trans-unit id="2682f428ec2cd20e9cdf6753b7db50d45fa0c287" translate="yes" xml:space="preserve">
          <source>Have you got it right?</source>
          <target state="translated">你说对了吗?</target>
        </trans-unit>
        <trans-unit id="60004c6dbf1e8f9315ee254f18d4e8b2a9fce3c6" translate="yes" xml:space="preserve">
          <source>Have you included all relevant information?</source>
          <target state="translated">你是否包括所有相关信息?</target>
        </trans-unit>
        <trans-unit id="3d1c0002422cc934d4f43ea061dac2a317b36bcc" translate="yes" xml:space="preserve">
          <source>Have you looked at CPAN (see &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;)? The chances are that someone has already written a module that can solve your problem. Have you read the appropriate manpages? Here's a brief index:</source>
          <target state="translated">您是否看过CPAN（请参阅&lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;）？可能是有人已经编写了可以解决您的问题的模块。您已阅读适当的手册页吗？这是一个简短的索引：</target>
        </trans-unit>
        <trans-unit id="4732d1c70c9c00b316d946047ce44e3469a4a557" translate="yes" xml:space="preserve">
          <source>Having 57 modules all called Sort will not make life easy for anyone (though having 23 called Sort::Quick is only marginally better :-). Imagine someone trying to install your module alongside many others.</source>
          <target state="translated">有57个模块都叫Sort,不会让任何人的生活变得轻松(虽然有23个叫Sort::Quick的模块只是稍微好一点:-)。想象一下,如果有人想把你的模块和其他许多模块一起安装,你会怎么做?</target>
        </trans-unit>
        <trans-unit id="fea81edd1a4ca564780d9031bb647dc99cf58fa7" translate="yes" xml:space="preserve">
          <source>Having 57 modules all called Sort will not make life easy for anyone (though having 23 called Sort::Quick is only marginally better :-). Imagine someone trying to install your module alongside many others. If in any doubt ask for suggestions in comp.lang.perl.misc.</source>
          <target state="translated">有57个模块都叫Sort,不会让任何人的生活变得轻松(虽然有23个叫Sort::Quick的模块只是稍微好一点:-)。想象一下,如果有人想把你的模块和其他许多模块一起安装,那就会很麻烦。如果有任何疑问,请在comp.lang.perl.misc.中寻求建议。</target>
        </trans-unit>
        <trans-unit id="d5c3a74f90c179abbbb2a8aabfd9df58154dbdba" translate="yes" xml:space="preserve">
          <source>Having PERLDOCDEBUG set to a positive integer will make perldoc emit even more descriptive output than the &lt;code&gt;-D&lt;/code&gt; switch does; the higher the number, the more it emits.</source>
          <target state="translated">将PERLDOCDEBUG设置为正整数将使perldoc发出比 &lt;code&gt;-D&lt;/code&gt; 开关更具描述性的输出。数字越高，它发出的光越多。</target>
        </trans-unit>
        <trans-unit id="475dd7f4c80bb5dca06b4bee66ecdd1370715023" translate="yes" xml:space="preserve">
          <source>Having RSX and the latest</source>
          <target state="translated">拥有RSX和最新的</target>
        </trans-unit>
        <trans-unit id="831389895e5cb7d92cb0b30b5f20a040e5b28ad0" translate="yes" xml:space="preserve">
          <source>Having a comma after the last element of an enum list</source>
          <target state="translated">在枚举列表的最后一个元素后面加上逗号。</target>
        </trans-unit>
        <trans-unit id="eb3a777ac79c8871a640c69bcf5b76d7b538148e" translate="yes" xml:space="preserve">
          <source>Having a meaning. Perl thinks that some of the things people try to do are devoid of meaning; in particular, making use of variables that have never been given a &lt;b&gt;value&lt;/b&gt; and performing certain operations on data that isn&amp;rsquo;t there. For example, if you try to read data past the end of a file, Perl will hand you back an undefined value. See also &lt;b&gt;false&lt;/b&gt; and the &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; entry in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">有意思。Perl认为人们试图做的某些事情没有意义。特别是，利用从未被赋予&lt;b&gt;值&lt;/b&gt;的变量并对不存在的数据执行某些操作。例如，如果您尝试读取文件末尾的数据，Perl将为您提供未定义的值。另请参见&lt;b&gt;false&lt;/b&gt;和Camel第27章&amp;ldquo;函数&amp;rdquo;中的已 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="d814a7a08cc6adb5ea05a2df41a45594d3bcb67b" translate="yes" xml:space="preserve">
          <source>Having a meaning. Perl thinks that some of the things people try to do are devoid of meaning; in particular, making use of variables that have never been given a &lt;b&gt;value&lt;/b&gt; and performing certain operations on data that isn&amp;rsquo;t there. For example, if you try to read data past the end of a file, Perl will hand you back an undefined value. See also &lt;b&gt;false&lt;/b&gt; and the &lt;code&gt;defined&lt;/code&gt; entry in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">有一个意义。Perl认为人们试图做的某些事情没有意义。特别是，利用从未被赋予&lt;b&gt;值&lt;/b&gt;的变量并对不存在的数据执行某些操作。例如，如果您尝试读取文件末尾的数据，Perl将为您提供未定义的值。另请参见Camel第27章&amp;ldquo;函数&amp;rdquo;中的&lt;b&gt;false&lt;/b&gt;和已 &lt;code&gt;defined&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="cf9f1d17b3780ae4ae6a7c92cd0343417040db2e" translate="yes" xml:space="preserve">
          <source>Having done your bit, please be prepared to wait, to be told the bug is in your code, or possibly to get no reply at all. The volunteers who maintain Perl are busy folks, so if your problem is an obvious bug in your own code, is difficult to understand or is a duplicate of an existing report, you may not receive a personal reply.</source>
          <target state="translated">在做了您的工作之后,请准备好等待,被告知错误在您的代码中,或者可能根本没有得到回复。维护Perl的志愿者们都很忙,所以如果你的问题是你自己的代码中的一个明显的bug,很难理解,或者是与现有的报告重复,你可能不会收到个人回复。</target>
        </trans-unit>
        <trans-unit id="61dfbdc92422646f02edc5b064d4a445a5156276" translate="yes" xml:space="preserve">
          <source>Having multiple DBM implementations makes it trivial to copy database formats:</source>
          <target state="translated">有了多个DBM实现,复制数据库格式就变得轻而易举了。</target>
        </trans-unit>
        <trans-unit id="0a36716594c37d5edd82c337ce9f21f289c12c13" translate="yes" xml:space="preserve">
          <source>Having pseudo-process IDs be negative integers breaks down for the integer &lt;code&gt;-1&lt;/code&gt; because the wait() and waitpid() functions treat this number as being special. The tacit assumption in the current implementation is that the system never allocates a thread ID of &lt;code&gt;1&lt;/code&gt; for user threads. A better representation for pseudo-process IDs will be implemented in future.</source>
          <target state="translated">伪进程ID为负整数会分解为整数 &lt;code&gt;-1&lt;/code&gt; ,因为wait（）和waitpid（）函数将此数字视为特殊数字。当前实现中的默认假设是系统从不为用户线程分配线程ID &lt;code&gt;1&lt;/code&gt; 。将来将实现对伪进程ID的更好表示。</target>
        </trans-unit>
        <trans-unit id="fff5183df30472b7e88394295e20e9d8990e8e07" translate="yes" xml:space="preserve">
          <source>Having read &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; you will probably have already guessed that the error is caused by the extra copy of the tied object stored in &lt;code&gt;$X&lt;/code&gt; . If you haven't, then the problem boils down to the fact that the &lt;b&gt;DB_File&lt;/b&gt; destructor, DESTROY, will not be called until</source>
          <target state="translated">阅读&lt;a href=&quot;perltie&quot;&gt;perltie之后，&lt;/a&gt;您可能已经猜到该错误是由 &lt;code&gt;$X&lt;/code&gt; 存储的附加对象的额外副本引起的。如果您还没有这样做，那么问题就归结为以下事实：直到调用&lt;b&gt;DB_File&lt;/b&gt;析构函数DESTROY，</target>
        </trans-unit>
        <trans-unit id="5c1e2b19d7b5e00f5d0c88fd12f5698cccf89784" translate="yes" xml:space="preserve">
          <source>Having read &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; you will probably have already guessed that the error is caused by the extra copy of the tied object stored in &lt;code&gt;$X&lt;/code&gt;. If you haven't, then the problem boils down to the fact that the &lt;b&gt;DB_File&lt;/b&gt; destructor, DESTROY, will not be called until</source>
          <target state="translated">阅读&lt;a href=&quot;perltie&quot;&gt;perltie之后，&lt;/a&gt;您可能已经猜到该错误是由 &lt;code&gt;$X&lt;/code&gt; 存储的附加对象的额外副本引起的。如果您还没有这样做，那么问题就归结为以下事实：只有在以下情况下，才会调用&lt;b&gt;DB_File&lt;/b&gt;析构函数DESTROY：</target>
        </trans-unit>
        <trans-unit id="690025fd44237769b46324cf68642f14ae190ff2" translate="yes" xml:space="preserve">
          <source>Having the SDK installed also means that you need to have either the Metrowerks CodeWarrior installed (2.8 and 3.0 were used in testing) or the Microsoft Visual C++ 6.0 installed (SP3 minimum, SP5 recommended).</source>
          <target state="translated">安装了SDK还意味着你需要安装Metrowerks CodeWarrior(测试中使用的是2.8和3.0)或安装Microsoft Visual C++6.0(最低SP3,建议SP5)。</target>
        </trans-unit>
        <trans-unit id="893bf15d4ad790d3a646d05f171a2db30641c0d1" translate="yes" xml:space="preserve">
          <source>Having threads support requires all of Perl and all of the XS modules in the Perl installation to be rebuilt; it is not just a question of adding the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module (i.e., threaded and non-threaded Perls are binary incompatible).</source>
          <target state="translated">要获得线程支持，需要重建Perl安装中的所有Perl和所有XS模块。这不仅仅是添加&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;模块的问题（即，线程和非线程Perls是二进制不兼容的）。</target>
        </trans-unit>
        <trans-unit id="123977c7eddfac195115408ec1d6b6b93c199204" translate="yes" xml:space="preserve">
          <source>Having to do with numbers represented in base 2. That means there&amp;rsquo;s basically two numbers: 0 and 1. Also used to describe a file of &amp;ldquo;nontext&amp;rdquo;, presumably because such a file makes full use of all the binary bits in its bytes. With the advent of &lt;b&gt;Unicode&lt;/b&gt;, this distinction, already suspect, loses even more of its meaning.</source>
          <target state="translated">与基数2中表示的数字有关。这意味着基本上有两个数字：0和1。还用于描述&amp;ldquo;非文本&amp;rdquo;文件，大概是因为此类文件充分利用了其字节中的所有二进制位。随着&lt;b&gt;Unicode&lt;/b&gt;的出现，这种已经被怀疑的区别甚至失去了更多的含义。</target>
        </trans-unit>
        <trans-unit id="2a50b726078402c27e07b8c0e368389163cec09c" translate="yes" xml:space="preserve">
          <source>Having to even think about the &lt;code&gt;$^S&lt;/code&gt; variable in your exception handlers is simply wrong. &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; as currently implemented invites grievous and difficult to track down errors. Avoid it and use an &lt;code&gt;END{}&lt;/code&gt; or CORE::GLOBAL::die override instead.</source>
          <target state="translated">甚至必须在异常处理程序中考虑 &lt;code&gt;$^S&lt;/code&gt; 变量是完全错误的。当前实施的 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 且难以追踪错误。避免使用它，而是使用 &lt;code&gt;END{}&lt;/code&gt; 或CORE :: GLOBAL :: die替代。</target>
        </trans-unit>
        <trans-unit id="1824af5feb4f3df315f45b16c88c9796572c2341" translate="yes" xml:space="preserve">
          <source>Having zero modifiers makes this a no-op (so why did you specify it, unless it's generated code), and starting in v5.30, warns under &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict'&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">拥有零修饰符使它成为无操作（因此，为什么要指定它，除非它是生成的代码），并且从v5.30开始，在&lt;a href=&quot;re#%27strict%27-mode&quot;&gt; &lt;code&gt;use re 'strict'&lt;/code&gt; &lt;/a&gt;re'strict '时发出警告。</target>
        </trans-unit>
        <trans-unit id="9dd5e433024c5701e895446816548ab95da2bc1b" translate="yes" xml:space="preserve">
          <source>Hawai'ian</source>
          <target state="translated">Hawai'ian</target>
        </trans-unit>
        <trans-unit id="172ba6a86380c5b6896beb3518c06339ca0edf94" translate="yes" xml:space="preserve">
          <source>He elaborates: In &quot;I scanned %g directories&quot;, you'd</source>
          <target state="translated">他阐述了。在 &quot;我扫描了%g的目录 &quot;中,你将会</target>
        </trans-unit>
        <trans-unit id="b9670c78ad31649495cc9999c8a7211c06bd1e87" translate="yes" xml:space="preserve">
          <source>HeHASH</source>
          <target state="translated">HeHASH</target>
        </trans-unit>
        <trans-unit id="c5e6018dcb2cae886c9d1c47690a4c54c44362c1" translate="yes" xml:space="preserve">
          <source>HeKEY</source>
          <target state="translated">HeKEY</target>
        </trans-unit>
        <trans-unit id="9b0c456032d23a1f8428e404c8fc000632b68f15" translate="yes" xml:space="preserve">
          <source>HeKLEN</source>
          <target state="translated">HeKLEN</target>
        </trans-unit>
        <trans-unit id="381f36fe8447fe95ed079c250bb4b4ea3d7e634b" translate="yes" xml:space="preserve">
          <source>HePV</source>
          <target state="translated">HePV</target>
        </trans-unit>
        <trans-unit id="fdb5f6488be2e53e093eac0872e26f417981c939" translate="yes" xml:space="preserve">
          <source>HeSVKEY</source>
          <target state="translated">HeSVKEY</target>
        </trans-unit>
        <trans-unit id="447de7df6f86d340b3c07a2481291e089c189a73" translate="yes" xml:space="preserve">
          <source>HeSVKEY_force</source>
          <target state="translated">HeSVKEY_force</target>
        </trans-unit>
        <trans-unit id="4dfba14a02b68cc98a5e87bdeb926ccb87da936c" translate="yes" xml:space="preserve">
          <source>HeSVKEY_set</source>
          <target state="translated">HeSVKEY_set</target>
        </trans-unit>
        <trans-unit id="4067c20911f4da7e02f3110fa44de6d983420d3a" translate="yes" xml:space="preserve">
          <source>HeUTF8</source>
          <target state="translated">HeUTF8</target>
        </trans-unit>
        <trans-unit id="9335e04810db397c2e35f214a69df586b346125d" translate="yes" xml:space="preserve">
          <source>HeVAL</source>
          <target state="translated">HeVAL</target>
        </trans-unit>
        <trans-unit id="fec5f9830205e3861054b7879046770547986753" translate="yes" xml:space="preserve">
          <source>Head.U</source>
          <target state="translated">Head.U</target>
        </trans-unit>
        <trans-unit id="0c0e898a8ae956ef15e057a684b77851cb08216e" translate="yes" xml:space="preserve">
          <source>Head1 through head4 produce headings, head1 being the highest level. The text in the rest of this paragraph is the content of the heading. For example:</source>
          <target state="translated">头1至头4产生标题,头1为最高级别。本段其余部分的文字就是标题的内容。例如:</target>
        </trans-unit>
        <trans-unit id="a96c65c60dd2beb6caf0aeaa3157c363f099df86" translate="yes" xml:space="preserve">
          <source>Headers mentioned in the RFCs and some other, well-known headers are generated with their canonical case. Other headers are sent in the case provided by the user. Except for control headers (which are sent first), headers are sent in arbitrary order.</source>
          <target state="translated">RFCs中提到的头文件和一些其他著名的头文件都是用它们的标准格式生成的。其他头文件则以用户提供的情况发送。除了控制头(先发),其他头的发送顺序是任意的。</target>
        </trans-unit>
        <trans-unit id="967ca9215da8ba98cad45c97fab5f98884cce72e" translate="yes" xml:space="preserve">
          <source>Heading Content&quot; command or to a &quot;=item Item Content&quot; command. This specification does not specify what behavior should be in the case of a given document having several things all seeming to produce the same</source>
          <target state="translated">Heading Content &quot;命令或&quot;=item Item Content &quot;命令。本规范没有指定在给定的文档中,如果有几个东西看起来都产生相同的内容,应该采取什么行为。</target>
        </trans-unit>
        <trans-unit id="7a7c06f07a69ec449fd37c3b79a4e6409f1c6971" translate="yes" xml:space="preserve">
          <source>Hearing the word &quot;in&quot; is an</source>
          <target state="translated">听到 &quot;在 &quot;字是一个</target>
        </trans-unit>
        <trans-unit id="7801d25365100494fe3fa68254035e723fdad847" translate="yes" xml:space="preserve">
          <source>Hebrew; now it doesn't.</source>
          <target state="translated">希伯来语;现在没有了。</target>
        </trans-unit>
        <trans-unit id="84135281bd9f7278283b58aab96226bf3b6fa87a" translate="yes" xml:space="preserve">
          <source>Heed the moderators.</source>
          <target state="translated">听从主持人的安排。</target>
        </trans-unit>
        <trans-unit id="a675c00310a9bb5810f1eb379886d21c46bbc50c" translate="yes" xml:space="preserve">
          <source>Help save the world! Share your code in a form that makes it easy to reuse.</source>
          <target state="translated">帮助拯救世界! 以易于重用的形式分享您的代码。</target>
        </trans-unit>
        <trans-unit id="72b65259063cf5501bdb369bad55680bb3e05273" translate="yes" xml:space="preserve">
          <source>Help testing test modules built with Test::Builder</source>
          <target state="translated">帮助测试用Test::Builder构建的测试模块。</target>
        </trans-unit>
        <trans-unit id="dfa0352ee0b635278bac396dced255cafcd73368" translate="yes" xml:space="preserve">
          <source>HelpMessage</source>
          <target state="translated">HelpMessage</target>
        </trans-unit>
        <trans-unit id="b604e9e00b8aff400d6b282c4559d7681123e27e" translate="yes" xml:space="preserve">
          <source>Helper class for PerlIO layers implemented in perl</source>
          <target state="translated">用perl实现的PerlIO层的辅助类。</target>
        </trans-unit>
        <trans-unit id="d26b8b46f8f2af4fb8c967fdcb3034722b09bfec" translate="yes" xml:space="preserve">
          <source>Helper for &lt;code&gt;grok_number()&lt;/code&gt;, accepts various ways of spelling &quot;infinity&quot; or &quot;not a number&quot;, and returns one of the following flag combinations:</source>
          <target state="translated">&lt;code&gt;grok_number()&lt;/code&gt; 的帮助器，接受各种拼写&amp;ldquo; infinity&amp;rdquo;或&amp;ldquo; not a number&amp;rdquo;的方式，并返回以下标志组合之一：</target>
        </trans-unit>
        <trans-unit id="4057a75cb8ff5877d986e9f1a93f90da05a4393c" translate="yes" xml:space="preserve">
          <source>Helper for grok_number(), accepts various ways of spelling &quot;infinity&quot; or &quot;not a number&quot;, and returns one of the following flag combinations:</source>
          <target state="translated">grok_number()的帮助程序,接受 &quot;infinity &quot;或 &quot;not a number &quot;的各种拼写方式,并返回以下标志组合之一。</target>
        </trans-unit>
        <trans-unit id="5d886854c3e45c23f2a67ad8886bba6332d21933" translate="yes" xml:space="preserve">
          <source>Helper functions for ExtUtils::Constant</source>
          <target state="translated">ExtUtils::Constant的辅助函数。</target>
        </trans-unit>
        <trans-unit id="2ec89dcb4b12d932844486071240245216868013" translate="yes" xml:space="preserve">
          <source>Helper routine for &lt;a href=&quot;ExtUtils::MM_Unix#fixin&quot;&gt;MM-&amp;gt;fixin()&lt;/a&gt;, overridden because there's no such thing as an actual shebang line that will be interpreted by the shell, so we just prepend $Config{startperl} and preserve the shebang line argument for any switches it may contain.</source>
          <target state="translated">&lt;a href=&quot;ExtUtils::MM_Unix#fixin&quot;&gt;MM-&amp;gt; fixin（）的&lt;/a&gt;帮助程序，已被覆盖，因为没有诸如shell会解释的实际shebang行之类的东西，因此我们只在$ Config {startperl}前面加上shebang line参数作为它可能包含的任何开关的参数。</target>
        </trans-unit>
        <trans-unit id="537e8e5aa520f3bdee23b191d8b4efb107769f00" translate="yes" xml:space="preserve">
          <source>Helper routine for MM-&amp;gt;fixin(), overridden because there's no such thing as an actual shebang line that will be interpreted by the shell, so we just prepend $Config{startperl} and preserve the shebang line argument for any switches it may contain.</source>
          <target state="translated">MM-&amp;gt; fixin（）的帮助程序，已被覆盖，因为没有诸如shell会解释的实际shebang行之类的东西，因此我们只需在$ Config {startperl}前面加上shebang line参数作为它可能包含的任何开关的参数。</target>
        </trans-unit>
        <trans-unit id="754ebef25d2322da9a737d155f7bf715f1ba74eb" translate="yes" xml:space="preserve">
          <source>Helper subroutine for subdirs</source>
          <target state="translated">子目录的辅助子程序。</target>
        </trans-unit>
        <trans-unit id="8a7149426bc5c4ad71c933b4d1d21cfffd9c3bea" translate="yes" xml:space="preserve">
          <source>Helpers for POD parsing and conversion</source>
          <target state="translated">POD解析和转换的辅助工具</target>
        </trans-unit>
        <trans-unit id="a1d186be4c77271bc365d307a5b69f017e030f41" translate="yes" xml:space="preserve">
          <source>Hence the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;unimport&lt;/code&gt; routines are called at &lt;b&gt;compile time&lt;/b&gt; for the user's code.</source>
          <target state="translated">因此，在&lt;b&gt;编译时会&lt;/b&gt;为用户代码调用 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;unimport&lt;/code&gt; 导入例程。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e2cc4b7767688df7b44bdf876b726e44848c3c3c" translate="yes" xml:space="preserve">
          <source>Hence the &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;unimport&lt;/code&gt; routines are called at &lt;b&gt;compile time&lt;/b&gt; for the user's code.</source>
          <target state="translated">因此，在&lt;b&gt;编译时会&lt;/b&gt;为用户代码调用 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;unimport&lt;/code&gt; 导入例程。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1698c95c1d69a8153fa73a579994fee537ea27f4" translate="yes" xml:space="preserve">
          <source>Hence you derive the following simple function to abstract that. It selects a random integer between the two given integers (inclusive). For example: &lt;code&gt;random_int_between(50,120)&lt;/code&gt; .</source>
          <target state="translated">因此，您可以导出以下简单函数来抽象该函数。它在两个给定的整数（包括两个整数）之间选择一个随机整数。例如： &lt;code&gt;random_int_between(50,120)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4370860a4cda36f4a61b51bfe47376529e7c3d64" translate="yes" xml:space="preserve">
          <source>Hence you derive the following simple function to abstract that. It selects a random integer between the two given integers (inclusive). For example: &lt;code&gt;random_int_between(50,120)&lt;/code&gt;.</source>
          <target state="translated">因此，您可以导出以下简单函数来抽象该函数。它在两个给定的整数（包括两个整数）之间选择一个随机整数。例如： &lt;code&gt;random_int_between(50,120)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc265d279911dd3bbb1e57f33ddb7cc94242a04f" translate="yes" xml:space="preserve">
          <source>Hence, at this point, the start of the buffer that we allocated lives at &lt;code&gt;SvPVX(sv) - SvIV(sv)&lt;/code&gt; in memory and the PV pointer is pointing into the middle of this allocated storage.</source>
          <target state="translated">因此，在这一点上，我们分配的缓冲区的起始位置位于内存中的 &lt;code&gt;SvPVX(sv) - SvIV(sv)&lt;/code&gt; ，PV指针指向此已分配存储的中间位置。</target>
        </trans-unit>
        <trans-unit id="045ed35d9ead65236dd53e0cae88ac0c2f700143" translate="yes" xml:space="preserve">
          <source>Hence, checking &lt;code&gt;SvTYPE(sv) &amp;lt; SVt_PVAV&lt;/code&gt; is the best way to see whether something is a scalar.</source>
          <target state="translated">因此，检查 &lt;code&gt;SvTYPE(sv) &amp;lt; SVt_PVAV&lt;/code&gt; 是查看某物是否为标量的最佳方法。</target>
        </trans-unit>
        <trans-unit id="556105a47e879b5cd197003b03f2c9d9168ed783" translate="yes" xml:space="preserve">
          <source>Hence, if you load this module on Perl 5.26.0, you will get one warning that the module is no longer supported; and the module will do nothing thereafter.</source>
          <target state="translated">因此,如果你在Perl 5.26.0上加载这个模块,你会得到一个警告,即该模块不再被支持;而此后该模块将无所作为。</target>
        </trans-unit>
        <trans-unit id="cb8da77ebcbcb4587ef2329234538c69cccafa62" translate="yes" xml:space="preserve">
          <source>Hence, on Mac OS, both</source>
          <target state="translated">因此,在Mac OS上,无论是</target>
        </trans-unit>
        <trans-unit id="28d05e677bb92a81e181eb6f8a5252850baf1f6f" translate="yes" xml:space="preserve">
          <source>Hence, putting it all together:</source>
          <target state="translated">因此,把这一切。</target>
        </trans-unit>
        <trans-unit id="78ae19820d96f656888a032f8938f666eaec4599" translate="yes" xml:space="preserve">
          <source>Hence, the aim of of a call to &lt;code&gt;extract_multiple&lt;/code&gt; in a list context is to split the processed string into as many non-overlapping fields as possible, by repeatedly applying each of the specified extractors to the remainder of the string. Thus &lt;code&gt;extract_multiple&lt;/code&gt; is a generalized form of Perl's &lt;code&gt;&lt;a href=&quot;../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; subroutine.</source>
          <target state="translated">因此，在列表上下文中调用 &lt;code&gt;extract_multiple&lt;/code&gt; 的目的是通过将每个指定的提取器重复应用到字符串的其余部分，将处理后的字符串分成尽可能多的非重叠字段。因此 &lt;code&gt;extract_multiple&lt;/code&gt; 是Perl的 &lt;code&gt;&lt;a href=&quot;../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 子例程的通用形式。</target>
        </trans-unit>
        <trans-unit id="0323aa4fd2151904fef4f800f370657ab5f29a7a" translate="yes" xml:space="preserve">
          <source>Hence, the aim of of a call to &lt;code&gt;extract_multiple&lt;/code&gt; in a list context is to split the processed string into as many non-overlapping fields as possible, by repeatedly applying each of the specified extractors to the remainder of the string. Thus &lt;code&gt;extract_multiple&lt;/code&gt; is a generalized form of Perl's &lt;code&gt;split&lt;/code&gt; subroutine.</source>
          <target state="translated">因此，在列表上下文中调用 &lt;code&gt;extract_multiple&lt;/code&gt; 的目的是通过将每个指定的提取器重复应用到字符串的其余部分，从而将处理后的字符串拆分为尽可能多的非重叠字段。因此， &lt;code&gt;extract_multiple&lt;/code&gt; 是Perl的 &lt;code&gt;split&lt;/code&gt; 子例程的通用形式。</target>
        </trans-unit>
        <trans-unit id="6e76b82b230d1b216ea5fc74faa050d88bd7bb1a" translate="yes" xml:space="preserve">
          <source>Henk P. Penning maintains a site that collects data about CPAN sites:</source>
          <target state="translated">Henk P.Penning维护着一个收集CPAN网站数据的网站。</target>
        </trans-unit>
        <trans-unit id="7f6138ce4b63e599ea6c8a23a9a9d862a811b01c" translate="yes" xml:space="preserve">
          <source>Henry Gabryjelski &amp;lt;henryg@WPI.EDU&amp;gt; - for the suggestion of creating directories recursively.</source>
          <target state="translated">Henry Gabryjelski &amp;lt;henryg@WPI.EDU&amp;gt;-关于递归创建目录的建议。</target>
        </trans-unit>
        <trans-unit id="7a134925882ae538ad42b93b5979387207fbfb32" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;$ARTICLE&lt;/code&gt; must be a global (package) scalar variable - not one declared with &lt;a href=&quot;#my-VARLIST&quot;&gt;&lt;code&gt;my&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#state-VARLIST&quot;&gt;&lt;code&gt;state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这里 &lt;code&gt;$ARTICLE&lt;/code&gt; 必须是一个全局（包）标量变量-不能用&lt;a href=&quot;#my-VARLIST&quot;&gt; &lt;code&gt;my&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#state-VARLIST&quot;&gt; &lt;code&gt;state&lt;/code&gt; &lt;/a&gt;声明。</target>
        </trans-unit>
        <trans-unit id="1f2206fdca717cfb115864c58cfc1242ec1e8f30" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;$ARTICLE&lt;/code&gt; must be a global (package) scalar variable - not one declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这里 &lt;code&gt;$ARTICLE&lt;/code&gt; 必须是一个全局（包）标量变量-不能用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="8ff0824227f04d195446a9ca4c80c3a2f4841adc" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;$ARTICLE&lt;/code&gt; must be a global (package) scalar variable - not one declared with &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这里 &lt;code&gt;$ARTICLE&lt;/code&gt; 必须是一个全局（包）标量变量-不能用 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="7adfbace1a84aad46b6dc65bb49ec212586f4854" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;--verbose&lt;/code&gt; and &lt;code&gt;--quiet&lt;/code&gt; control the same variable &lt;code&gt;$verbose&lt;/code&gt; , but with opposite values.</source>
          <target state="translated">在这里 &lt;code&gt;--verbose&lt;/code&gt; 和 &lt;code&gt;--quiet&lt;/code&gt; 控制相同的变量 &lt;code&gt;$verbose&lt;/code&gt; ，但值相反。</target>
        </trans-unit>
        <trans-unit id="d3f64a7bd9317a944a7376aabb90068d62d19a13" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;--verbose&lt;/code&gt; and &lt;code&gt;--quiet&lt;/code&gt; control the same variable &lt;code&gt;$verbose&lt;/code&gt;, but with opposite values.</source>
          <target state="translated">在这里 &lt;code&gt;--verbose&lt;/code&gt; 和 &lt;code&gt;--quiet&lt;/code&gt; 控制相同的变量 &lt;code&gt;$verbose&lt;/code&gt; ，但值相反。</target>
        </trans-unit>
        <trans-unit id="869e9b788a94b86ab899941e02856974518155a7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;\G&lt;/code&gt; create a 'tag team' handoff of the string from one regexp to the other. Regexps with an independent subexpression are much like this, with a handoff of the string to the independent subexpression, and a handoff of the string back to the enclosing regexp.</source>
          <target state="translated">&lt;code&gt;//g&lt;/code&gt; 和 &lt;code&gt;\G&lt;/code&gt; 在这里创建字符串的&amp;ldquo;标签组&amp;rdquo;切换，从一个正则表达式到另一个正则表达式。具有独立子表达式的正则表达式很像这样，将字符串移交给独立子表达式，然后将字符串移交给封闭的正则表达式。</target>
        </trans-unit>
        <trans-unit id="71e7bd7e0715889b83b0e1df6c21eb89086431d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;/g&lt;/code&gt; and &lt;code&gt;\G&lt;/code&gt; create a &quot;tag team&quot; handoff of the string from one regexp to the other. Regexps with an independent subexpression are much like this, with a handoff of the string to the independent subexpression, and a handoff of the string back to the enclosing regexp.</source>
          <target state="translated">在这里 &lt;code&gt;/g&lt;/code&gt; 和 &lt;code&gt;\G&lt;/code&gt; 创建了从一个正则表达式到另一个正则表达式的字符串&amp;ldquo;标记组&amp;rdquo;切换。具有独立子表达式的正则表达式非常类似于此，将字符串移交给独立子表达式，然后将字符串移交给封闭的正则表达式。</target>
        </trans-unit>
        <trans-unit id="4b495cc26b10b4cfa7edd523e971b1223bc39631" translate="yes" xml:space="preserve">
          <source>Here again Perl works just like the shell in that the &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; clobbers an existing file.</source>
          <target state="translated">在这里，Perl再次像shell一样工作，因为 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 替换了现有文件。</target>
        </trans-unit>
        <trans-unit id="0b249e3305de27f4ee7d8f5a9ef3f95983593269" translate="yes" xml:space="preserve">
          <source>Here are Perl's functions (including things that look like functions, like some keywords and named operators) arranged by category. Some functions appear in more than one place.</source>
          <target state="translated">这里是Perl的函数(包括看起来像函数的东西,比如一些关键字和命名运算符),按类别排列。有些函数出现在多个地方。</target>
        </trans-unit>
        <trans-unit id="ce8540faf1c5c6c5be2f416cad08509fdda29d23" translate="yes" xml:space="preserve">
          <source>Here are Perl's functions (including things that look like functions, like some keywords and named operators) arranged by category. Some functions appear in more than one place. Any warnings, including those produced by keywords, are described in &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">这是按类别排列的Perl函数（包括看起来像函数的东西，例如一些关键字和命名的运算符）。某些功能出现在一个以上的位置。&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;和&lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;中描述了任何警告，包括由关键字产生的警告。</target>
        </trans-unit>
        <trans-unit id="86585cb3324adc532f3c4c9a1e007eedd102a2eb" translate="yes" xml:space="preserve">
          <source>Here are a collection of (possibly) useful canned recipes for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">这里是（可能）有用罐装配方集合 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ，并 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6b2a8b8e88687652afd4febd5437e6847aab7c6e" translate="yes" xml:space="preserve">
          <source>Here are a collection of (possibly) useful canned recipes for &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt;:</source>
          <target state="translated">这里是（可能）有用罐装配方集合 &lt;code&gt;pack&lt;/code&gt; ，并 &lt;code&gt;unpack&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="213525a9716fa0289377679cccd7e684d87732e5" translate="yes" xml:space="preserve">
          <source>Here are a couple of possibilities:</source>
          <target state="translated">这里有几种可能性。</target>
        </trans-unit>
        <trans-unit id="bc67517efb30f9fba9421a6919635fb13eb305fb" translate="yes" xml:space="preserve">
          <source>Here are a few example that show the capabilities of the module.</source>
          <target state="translated">这里有几个例子可以展示该模块的功能。</target>
        </trans-unit>
        <trans-unit id="de690581aef8b0c61e87b43058be3d94a077aff4" translate="yes" xml:space="preserve">
          <source>Here are a few examples to demonstrate usage of Perl's benchmarking tools.</source>
          <target state="translated">下面是几个例子来演示Perl基准测试工具的使用。</target>
        </trans-unit>
        <trans-unit id="a8331c63f719d3fa459c3be0fc4500f91a2bc542" translate="yes" xml:space="preserve">
          <source>Here are a few examples which illustrate the key concepts - as such most of them are of little practical use.</source>
          <target state="translated">这里有几个例子可以说明关键的概念------因此,它们中的大多数都没有什么实际用途。</target>
        </trans-unit>
        <trans-unit id="6d45496eb99d38ab7ab859d9d23312ec9997a265" translate="yes" xml:space="preserve">
          <source>Here are a few hints for creating high-quality patches:</source>
          <target state="translated">这里有几个创建高质量补丁的提示。</target>
        </trans-unit>
        <trans-unit id="ee5bae63f174379946589f4804bf6cb746e57ff8" translate="yes" xml:space="preserve">
          <source>Here are a few notes on the C function</source>
          <target state="translated">下面是关于C函数的一些说明</target>
        </trans-unit>
        <trans-unit id="4cf9a82c924ee686ad6e561bd6e1b0affa2a2991" translate="yes" xml:space="preserve">
          <source>Here are a few simple examples. First, let's pass in several arrays to a function and have it &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; all of then, returning a new list of all their former last elements:</source>
          <target state="translated">这里有一些简单的例子。首先，让我们将几个数组传递给一个函数，然后将其 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; ，然后返回所有其前最后一个元素的新列表：</target>
        </trans-unit>
        <trans-unit id="07bc756b4525b03a743a457897293bde8f42d28d" translate="yes" xml:space="preserve">
          <source>Here are a few simple examples. First, let's pass in several arrays to a function and have it &lt;code&gt;pop&lt;/code&gt; all of then, returning a new list of all their former last elements:</source>
          <target state="translated">这里有一些简单的例子。首先，让我们将几个数组传递给一个函数，然后将其 &lt;code&gt;pop&lt;/code&gt; ，然后返回所有其前最后一个元素的新列表：</target>
        </trans-unit>
        <trans-unit id="778c5e77d32e09526eea8078cdc25093f593316e" translate="yes" xml:space="preserve">
          <source>Here are a few ways, all painful, to deal with it:</source>
          <target state="translated">这里有几个方法,都是痛苦的处理方法。</target>
        </trans-unit>
        <trans-unit id="4d368f7513a7890d1d9530618552892450a6a185" translate="yes" xml:space="preserve">
          <source>Here are a few words taken from the Berkeley DB FAQ (at</source>
          <target state="translated">以下是伯克利DB常见问题中的一些话(在</target>
        </trans-unit>
        <trans-unit id="dbcbf329948c2249a19622b8073b1367ff9cb194" translate="yes" xml:space="preserve">
          <source>Here are a few words taken from the Berkeley DB FAQ (at &lt;a href=&quot;http://www.oracle.com/technology/products/berkeley-db/db/index.html&quot;&gt;http://www.oracle.com/technology/products/berkeley-db/db/index.html&lt;/a&gt;) regarding the license:</source>
          <target state="translated">以下是有关许可的Berkeley DB FAQ（位于&lt;a href=&quot;http://www.oracle.com/technology/products/berkeley-db/db/index.html&quot;&gt;http://www.oracle.com/technology/products/berkeley-db/db/index.html&lt;/a&gt;）中的几句话：</target>
        </trans-unit>
        <trans-unit id="3de0d7b44e720bda0c9a25fbb58e38764c2a5fa0" translate="yes" xml:space="preserve">
          <source>Here are examples of &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//m&lt;/code&gt; in action:</source>
          <target state="translated">这是实际中 &lt;code&gt;//s&lt;/code&gt; 和 &lt;code&gt;//m&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="019f88f2ee6b0e36fd2598271f5d4aac4291dbff" translate="yes" xml:space="preserve">
          <source>Here are examples of &lt;code&gt;/s&lt;/code&gt; and &lt;code&gt;/m&lt;/code&gt; in action:</source>
          <target state="translated">这是 &lt;code&gt;/s&lt;/code&gt; 和 &lt;code&gt;/m&lt;/code&gt; 实际使用的示例：</target>
        </trans-unit>
        <trans-unit id="b13167d0662ec600bc247b1050d48340c5a1f9fa" translate="yes" xml:space="preserve">
          <source>Here are examples of many kinds of file opens. Those using &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; all assume that you've pulled in the constants from &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt;:</source>
          <target state="translated">以下是许多文件打开示例。那些使用 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 的人都假定您已经从&lt;a href=&quot;fcntl&quot;&gt;Fcntl中&lt;/a&gt;提取了常量：</target>
        </trans-unit>
        <trans-unit id="285c2ac838211f7ab63456da8593b46a7ba8d4ec" translate="yes" xml:space="preserve">
          <source>Here are examples of many kinds of file opens. Those using &lt;code&gt;sysopen&lt;/code&gt; all assume that you've pulled in the constants from &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt;:</source>
          <target state="translated">以下是许多文件打开示例。那些使用 &lt;code&gt;sysopen&lt;/code&gt; 的人都假定您已经从&lt;a href=&quot;fcntl&quot;&gt;Fcntl中&lt;/a&gt;提取了常量：</target>
        </trans-unit>
        <trans-unit id="1b269a27d981a83ad06f7f43ed4b5271ebb95e10" translate="yes" xml:space="preserve">
          <source>Here are examples of the constructors and the valid options available for DB_HASH, DB_BTREE and DB_RECNO respectively.</source>
          <target state="translated">下面分别是DB_HASH、DB_BTREE和DB_RECNO的构造函数和有效选项的例子。</target>
        </trans-unit>
        <trans-unit id="feffd8fe1a5cbaddbff753bfdc84e56b03609303" translate="yes" xml:space="preserve">
          <source>Here are some code samples showing a possible usage of Storable:</source>
          <target state="translated">以下是一些代码示例,展示了Storable的可能用法。</target>
        </trans-unit>
        <trans-unit id="b97373427a9280cf0da7790f9dd7dc5b0d29339d" translate="yes" xml:space="preserve">
          <source>Here are some concerns to keep in mind when using an endianness modifier:</source>
          <target state="translated">以下是使用endianness修饰语时需要注意的一些问题。</target>
        </trans-unit>
        <trans-unit id="c18e94a9efc11f05f3d5f2b6edc571204b41c5d4" translate="yes" xml:space="preserve">
          <source>Here are some examples of how that works on an ASCII platform:</source>
          <target state="translated">下面是一些在ASCII平台上如何工作的例子。</target>
        </trans-unit>
        <trans-unit id="ca06cec84a9ef5e9ca766f7b0195777a639a43ed" translate="yes" xml:space="preserve">
          <source>Here are some examples of how to use these:</source>
          <target state="translated">下面是一些如何使用这些的例子。</target>
        </trans-unit>
        <trans-unit id="84bd37d6cce9f50a387d161b1db1876dd2e66de5" translate="yes" xml:space="preserve">
          <source>Here are some examples of that:</source>
          <target state="translated">下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="eb016178c05ee24cc48ff8dddc178e709d61edd0" translate="yes" xml:space="preserve">
          <source>Here are some examples of usage of the &quot;cmd&quot; shell:</source>
          <target state="translated">下面是一些使用 &quot;cmd &quot;shell的例子。</target>
        </trans-unit>
        <trans-unit id="b17211739968de398ac6cabe7b5c9c6e7b2ffe53" translate="yes" xml:space="preserve">
          <source>Here are some examples that explain the reasons why certain results occur while handling infinity:</source>
          <target state="translated">下面是一些例子,解释了为什么在处理无穷大时出现某些结果的原因。</target>
        </trans-unit>
        <trans-unit id="5a87004d684b1273adb1c5dad1a3b884a901f693" translate="yes" xml:space="preserve">
          <source>Here are some examples that you should be able to type into your command shell:</source>
          <target state="translated">下面是一些例子,你应该可以在命令壳中输入。</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="1ffece14922bda83136b1a5ca004aee395c4815b" translate="yes" xml:space="preserve">
          <source>Here are some further observations based on experiments: The C runtime breaks arguments at spaces and passes them to programs in argc/argv. Double quotes can be used to prevent arguments with spaces in them from being split up. You can put a double quote in an argument by escaping it with a backslash and enclosing the whole argument within double quotes. The backslash and the pair of double quotes surrounding the argument will be stripped by the C runtime.</source>
          <target state="translated">下面是基于实验的一些进一步的观察。C语言的运行时会在空格处拆分参数,并将它们以argc/argv的形式传递给程序。双引号可以用来防止带空格的参数被拆分。你可以在一个参数中放入双引号,用反斜杠转义,并将整个参数包围在双引号内。反斜线和参数周围的一对双引号将被C语言运行时剥离。</target>
        </trans-unit>
        <trans-unit id="a4980f1bbd2b4cd245b8c8043825f0a0babf7335" translate="yes" xml:space="preserve">
          <source>Here are some more examples</source>
          <target state="translated">下面是一些更多的例子</target>
        </trans-unit>
        <trans-unit id="0b595570315b5625b2174cdd7459401aaf7451f5" translate="yes" xml:space="preserve">
          <source>Here are some more examples; be aware that when using an explicit index, the &lt;code&gt;$&lt;/code&gt; may need escaping:</source>
          <target state="translated">这里还有一些例子。请注意，在使用显式索引时， &lt;code&gt;$&lt;/code&gt; 可能需要转义：</target>
        </trans-unit>
        <trans-unit id="c694403eaca658591930c8c7c2bb34296f84a099" translate="yes" xml:space="preserve">
          <source>Here are some notable values:</source>
          <target state="translated">以下是一些值得注意的数值。</target>
        </trans-unit>
        <trans-unit id="cc7e40e86aef57a83594c5dfdd7f8a1c23f71b5f" translate="yes" xml:space="preserve">
          <source>Here are some other examples:</source>
          <target state="translated">下面是其他一些例子。</target>
        </trans-unit>
        <trans-unit id="5552dd4aff82cc5a2b99f42ba7a6d2949d5c6e2e" translate="yes" xml:space="preserve">
          <source>Here are some other functions:</source>
          <target state="translated">下面是其他一些功能。</target>
        </trans-unit>
        <trans-unit id="79024a11d0139db04c2facf9ae0e8d93da4c05aa" translate="yes" xml:space="preserve">
          <source>Here are some other more substantive style issues to think about:</source>
          <target state="translated">这里还有一些其他更实质性的风格问题需要思考。</target>
        </trans-unit>
        <trans-unit id="8de6ff6be7dbb16b2f90d46db02214f1b31982a4" translate="yes" xml:space="preserve">
          <source>Here are some samples of syntactically valid declarations, with annotation as to how they resolve internally into &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; invocations by perl. These examples are primarily useful to see how the &quot;appropriate package&quot; is found for the possible method lookups for package-defined attributes.</source>
          <target state="translated">这是一些语法有效声明的示例，并带有注释，说明它们如何内部解析为perl的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; 调用。这些示例主要用于查看如何找到&amp;ldquo;适当的程序包&amp;rdquo;以进行程序包定义的属性的可能方法查找。</target>
        </trans-unit>
        <trans-unit id="f09c78fd713d777b16d7b0dc7451ff268dfc7da3" translate="yes" xml:space="preserve">
          <source>Here are some samples of syntactically valid declarations, with annotation as to how they resolve internally into &lt;code&gt;use attributes&lt;/code&gt; invocations by perl. These examples are primarily useful to see how the &quot;appropriate package&quot; is found for the possible method lookups for package-defined attributes.</source>
          <target state="translated">这是一些语法上有效的声明示例，并带有注释，说明如何在内部将其解析为perl的 &lt;code&gt;use attributes&lt;/code&gt; 调用。这些示例主要用于查看如何找到&amp;ldquo;合适的程序包&amp;rdquo;以进行程序包定义的属性的可能方法查找。</target>
        </trans-unit>
        <trans-unit id="3ef6c8462426b25783d9f2c73bd41688e54925d5" translate="yes" xml:space="preserve">
          <source>Here are some variants, most of which don't work:</source>
          <target state="translated">这里有一些变体,大部分都不能用。</target>
        </trans-unit>
        <trans-unit id="0361977099d002d67600facecf96ac617d8167ef" translate="yes" xml:space="preserve">
          <source>Here are the current possible types, with short descriptions:</source>
          <target state="translated">以下是目前可能的类型,并有简短的说明。</target>
        </trans-unit>
        <trans-unit id="67895007dd0c6840199574bcaf648ce79505acd6" translate="yes" xml:space="preserve">
          <source>Here are the methods for the DotFiles tied hash.</source>
          <target state="translated">下面是DotFiles绑定哈希的方法。</target>
        </trans-unit>
        <trans-unit id="bdd9e497208f79834038783c1e02aab82a664f8b" translate="yes" xml:space="preserve">
          <source>Here are the methods:</source>
          <target state="translated">下面是方法。</target>
        </trans-unit>
        <trans-unit id="308b3fd3c823fd8f4a8be7a1c05819c0bdbe51b4" translate="yes" xml:space="preserve">
          <source>Here are the places where Perl will assume &lt;code&gt;$_&lt;/code&gt; even if you don't use it:</source>
          <target state="translated">这是即使您不使用Perl也会假设 &lt;code&gt;$_&lt;/code&gt; 的地方：</target>
        </trans-unit>
        <trans-unit id="0a9a64ecb96bf415307190a704ba59f675ea62cc" translate="yes" xml:space="preserve">
          <source>Here are the possible keys for the hash:</source>
          <target state="translated">以下是哈希的可能密钥。</target>
        </trans-unit>
        <trans-unit id="133a7307c88c0ca94d0fd77ce650ab97042a4831" translate="yes" xml:space="preserve">
          <source>Here are the quote-like operators that apply to pattern matching and related activities.</source>
          <target state="translated">下面是适用于模式匹配和相关活动的引号式运算符。</target>
        </trans-unit>
        <trans-unit id="c59988c08aece7bd08debf7ada77c7366bd57099" translate="yes" xml:space="preserve">
          <source>Here are the rules that are used in &lt;code&gt;catdir()&lt;/code&gt; ; note that we try to be as compatible as possible to Unix:</source>
          <target state="translated">以下是 &lt;code&gt;catdir()&lt;/code&gt; 中使用的规则；请注意，我们尝试与Unix尽可能兼容：</target>
        </trans-unit>
        <trans-unit id="3ed36fd5ffaf22cc0a28878706f0e8bf6dac1f65" translate="yes" xml:space="preserve">
          <source>Here are the rules that are used in &lt;code&gt;catdir()&lt;/code&gt;; note that we try to be as compatible as possible to Unix:</source>
          <target state="translated">以下是 &lt;code&gt;catdir()&lt;/code&gt; 中使用的规则；请注意，我们尝试与Unix尽可能兼容：</target>
        </trans-unit>
        <trans-unit id="4aa7fef747fea48e4e4795cd9eaeefa09930bbdb" translate="yes" xml:space="preserve">
          <source>Here are the short and long forms of the values the &lt;code&gt;General Category&lt;/code&gt; property can have:</source>
          <target state="translated">以下是&amp;ldquo; &lt;code&gt;General Category&lt;/code&gt; 属性可以具有的值的长短形式：</target>
        </trans-unit>
        <trans-unit id="420394a2a2618e29901a0ab672922a30d23423d8" translate="yes" xml:space="preserve">
          <source>Here are the statistics for Perl 5.005_62 on my system:</source>
          <target state="translated">以下是我系统中Perl 5.005_62的统计数据。</target>
        </trans-unit>
        <trans-unit id="fd03473c869638bd902e9d6b0f20d91be736706a" translate="yes" xml:space="preserve">
          <source>Here are the suggested ways of modifying your include path, including environment variables, run-time switches, and in-code statements:</source>
          <target state="translated">以下是建议的修改include路径的方法,包括环境变量、运行时开关和代码内语句。</target>
        </trans-unit>
        <trans-unit id="c09b558fc05cb8053f5a3187154e8896a601ad3a" translate="yes" xml:space="preserve">
          <source>Here are the ways that Perl knows that a string should be treated as Unicode:</source>
          <target state="translated">以下是Perl知道一个字符串应该被视为Unicode的方法。</target>
        </trans-unit>
        <trans-unit id="4358e9bb262d19ae65de17de5c9b7a341e07eea3" translate="yes" xml:space="preserve">
          <source>Here are what those parameters to the new() constructor mean:</source>
          <target state="translated">下面是new()构造函数的这些参数的含义。</target>
        </trans-unit>
        <trans-unit id="d3c80c52da3a7596fb4bd95e7f557fcc03ea2102" translate="yes" xml:space="preserve">
          <source>Here documents are found in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;. Check for these three things:</source>
          <target state="translated">这里的文档可以在&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;中找到。检查以下三件事：</target>
        </trans-unit>
        <trans-unit id="484c5007fac2b871f4ec1de41d18168107149ae5" translate="yes" xml:space="preserve">
          <source>Here in our DotFiles example, we'll be careful not to let them try to overwrite the file unless they've called the clobber() method on the original object reference returned by tie().</source>
          <target state="translated">在我们的DotFiles例子中,我们要注意不要让他们试图覆盖文件,除非他们调用了 tie()返回的原始对象引用的 clobber()方法。</target>
        </trans-unit>
        <trans-unit id="47c02f53e38b9b0fb6a0ae2769d47d0a5b5b6556" translate="yes" xml:space="preserve">
          <source>Here is a DBM Filter that does it:</source>
          <target state="translated">这里有一个DBM过滤器可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="f525e8a25cabfe7d14de3785ff13475d1795d58b" translate="yes" xml:space="preserve">
          <source>Here is a Perl subroutine which prints whatever parameters are passed to it.</source>
          <target state="translated">这里是一个Perl子程序,它可以打印传递给它的任何参数。</target>
        </trans-unit>
        <trans-unit id="45cd387e7d7083c724152df763a18216115c4120" translate="yes" xml:space="preserve">
          <source>Here is a Perl subroutine,</source>
          <target state="translated">下面是一个Perl子程序。</target>
        </trans-unit>
        <trans-unit id="badb362bb0ad7ef4caa28ee99b671c9b8a6d2d3a" translate="yes" xml:space="preserve">
          <source>Here is a brief checklist on how to use Maketext to localize applications:</source>
          <target state="translated">下面是一份关于如何使用Maketext进行本地化应用的简要清单。</target>
        </trans-unit>
        <trans-unit id="e180555a648403b54c19cc98b95102cc9c7da450" translate="yes" xml:space="preserve">
          <source>Here is a code snippet to tell what &quot;word&quot; characters are in the current locale, in that locale's order:</source>
          <target state="translated">这里有一段代码,用来告诉你当前locale中的 &quot;word &quot;字符是什么,按照locale的顺序。</target>
        </trans-unit>
        <trans-unit id="1d9d16b43d949b27c929aa01a0989059daef7367" translate="yes" xml:space="preserve">
          <source>Here is a crude diagram of how filehandle, PerlIO, and Encode interact.</source>
          <target state="translated">下面是一个关于filehandle、PerlIO和Encode如何交互的粗略图表。</target>
        </trans-unit>
        <trans-unit id="8cd600b00d9b275c1b848cf418f2f3dc7bc149f6" translate="yes" xml:space="preserve">
          <source>Here is a definition of the interface available:</source>
          <target state="translated">下面是可用接口的定义。</target>
        </trans-unit>
        <trans-unit id="4ffd58769a04701c527d60f25ae6cee8c3577aa1" translate="yes" xml:space="preserve">
          <source>Here is a definition of the interface:</source>
          <target state="translated">下面是接口的定义。</target>
        </trans-unit>
        <trans-unit id="86773bb3e419f5d3ec6cdc84464ead386b08f646" translate="yes" xml:space="preserve">
          <source>Here is a filter which a variation of the &lt;code&gt;Joe2Jim&lt;/code&gt; filter. As well as substituting all occurrences of &lt;code&gt;&quot;Joe&quot;&lt;/code&gt; to &lt;code&gt;&quot;Jim&quot;&lt;/code&gt; it keeps a count of the number of substitutions made in the context object.</source>
          <target state="translated">这是 &lt;code&gt;Joe2Jim&lt;/code&gt; 过滤器的变体。除了将所有出现的 &lt;code&gt;&quot;Joe&quot;&lt;/code&gt; 替换为 &lt;code&gt;&quot;Jim&quot;&lt;/code&gt; 它还会对上下文对象中进行的替换次数进行计数。</target>
        </trans-unit>
        <trans-unit id="4d0499c68821327c798829729804b1a0bcda02ab" translate="yes" xml:space="preserve">
          <source>Here is a formula to ensurrogate a Unicode character \x{10000} and above;</source>
          <target state="translated">以下是一个公式,用于代用Unicode字符\x{10000}及以上。</target>
        </trans-unit>
        <trans-unit id="5e13ad2f9de57b9ee78127b86f1be789cace5f69" translate="yes" xml:space="preserve">
          <source>Here is a less often used example:</source>
          <target state="translated">下面是一个不太常用的例子。</target>
        </trans-unit>
        <trans-unit id="8615e06af1883810bfc6afe31e15071d09d0a5c7" translate="yes" xml:space="preserve">
          <source>Here is a list of additional methods:</source>
          <target state="translated">以下是其他方法的清单。</target>
        </trans-unit>
        <trans-unit id="0815879d63f4c647e36f2a3e53c2a854eb38d7a9" translate="yes" xml:space="preserve">
          <source>Here is a list of facet types by package. The packages are not used internally, but are where the documentation for each type is kept.</source>
          <target state="translated">这里是按包列出的facet类型。这些包不是内部使用的,而是每个类型的文档保存的地方。</target>
        </trans-unit>
        <trans-unit id="b6f9d3fd360afdcd3acc8bec172ad26a0315b6d8" translate="yes" xml:space="preserve">
          <source>Here is a list of the common features of the anonymous sub and the &lt;code&gt;filter()&lt;/code&gt; method.</source>
          <target state="translated">这是匿名子和 &lt;code&gt;filter()&lt;/code&gt; 方法的常见功能列表。</target>
        </trans-unit>
        <trans-unit id="1832b72be8a1d9f95753e5f4c415597ea4ff02d1" translate="yes" xml:space="preserve">
          <source>Here is a list of the valid options:</source>
          <target state="translated">以下是有效选项的列表。</target>
        </trans-unit>
        <trans-unit id="8914294fa8d99540ed79b9d165dee16297f1d6a9" translate="yes" xml:space="preserve">
          <source>Here is a longer example of &lt;code&gt;given&lt;/code&gt; :</source>
          <target state="translated">这是 &lt;code&gt;given&lt;/code&gt; 一个更长的例子：</target>
        </trans-unit>
        <trans-unit id="770b47b87a22658ce1106c32715d366b237fafe0" translate="yes" xml:space="preserve">
          <source>Here is a longer example of &lt;code&gt;given&lt;/code&gt;:</source>
          <target state="translated">这是 &lt;code&gt;given&lt;/code&gt; 一个更长的例子：</target>
        </trans-unit>
        <trans-unit id="b951146917555dc2bff07eaf853fe90ebe90da08" translate="yes" xml:space="preserve">
          <source>Here is a more complete description of how &lt;code&gt;carp&lt;/code&gt; and &lt;code&gt;croak&lt;/code&gt; work. What they do is search the call-stack for a function call stack where they have not been told that there shouldn't be an error. If every call is marked safe, they give up and give a full stack backtrace instead. In other words they presume that the first likely looking potential suspect is guilty. Their rules for telling whether a call shouldn't generate errors work as follows:</source>
          <target state="translated">下面是一个更完整的说明 &lt;code&gt;carp&lt;/code&gt; 和 &lt;code&gt;croak&lt;/code&gt; 工作。他们要做的是在调用堆栈中搜索一个函数调用堆栈，在该调用堆栈中没有被告知不应有错误。如果每个呼叫都被标记为安全，则他们放弃并给出完整的堆栈回溯。换句话说，他们认为第一个可能看似潜在的嫌犯是有罪的。他们用于判断呼叫是否不应产生错误的规则如下：</target>
        </trans-unit>
        <trans-unit id="faf8b9ff2265f8681cbbc8e12a3625240f11fc4d" translate="yes" xml:space="preserve">
          <source>Here is a more complete example that makes use of some of the methods described above. It also makes use of the API interface directly (see &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;&quot;THE API INTERFACE&quot;&lt;/a&gt;).</source>
          <target state="translated">这是一个使用上述某些方法的更完整的示例。它还直接使用API​​接口（请参阅&lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;&amp;ldquo; API接口&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e9d5f1ad420c45c5ca7b8cd720763979928a0e80" translate="yes" xml:space="preserve">
          <source>Here is a more complete example that makes use of some of the methods described above. It also makes use of the API interface directly (see &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt;).</source>
          <target state="translated">这是一个利用上述某些方法的更完整的示例。它还直接使用API​​接口（请参阅&lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;API接口&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="481b0824c1ad273d7763f1ffdf818909caa88617" translate="yes" xml:space="preserve">
          <source>Here is a possible workaround: create a toplevel</source>
          <target state="translated">这里有一个可能的变通方法:创建一个toplevel的</target>
        </trans-unit>
        <trans-unit id="aac02f3544d72b59392576f2e2d1edbb502cf904" translate="yes" xml:space="preserve">
          <source>Here is a real example. Netscape 2.0 keeps a record of the locations you visit along with the time you last visited them in a DB_HASH database. This is usually stored in the file</source>
          <target state="translated">这是一个真实的例子。Netscape 2.0在DB_HASH数据库中保留了您访问的地点以及您最后访问的时间的记录。这通常存储在文件</target>
        </trans-unit>
        <trans-unit id="645c6ed6c5edc9279cd1369bce1c3b76531901ff" translate="yes" xml:space="preserve">
          <source>Here is a sample chunk of code to break up and put back together again some fixed-format input lines, in this case from the output of a normal, Berkeley-style ps:</source>
          <target state="translated">这里是一个示例代码块,用于将一些固定格式的输入行打散并重新组合在一起,在这种情况下,它来自一个普通的、Berkeley式的ps的输出。</target>
        </trans-unit>
        <trans-unit id="38eab965034c311c9ba1e3fb718a8ef1f540a4a4" translate="yes" xml:space="preserve">
          <source>Here is a script that saves, redirects, and restores &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt; using various methods:</source>
          <target state="translated">这是使用各种方法保存，重定向和还原 &lt;code&gt;STDOUT&lt;/code&gt; 和 &lt;code&gt;STDERR&lt;/code&gt; 的脚本：</target>
        </trans-unit>
        <trans-unit id="bf170b2ef98b6313890763a8318d77c620c61ec2" translate="yes" xml:space="preserve">
          <source>Here is a script which uses it:</source>
          <target state="translated">下面是一个使用它的脚本。</target>
        </trans-unit>
        <trans-unit id="d109e8133d36be8ec27bcf8a10b412b1b37621e9" translate="yes" xml:space="preserve">
          <source>Here is a short breakdown of perl's operation:</source>
          <target state="translated">下面简单介绍一下perl的操作。</target>
        </trans-unit>
        <trans-unit id="b641d2582f209503d29beece571a8e6d76517863" translate="yes" xml:space="preserve">
          <source>Here is a short example which shows how &lt;code&gt;IO::Select&lt;/code&gt; could be used to write a server which communicates with several sockets while also listening for more connections on a listen socket</source>
          <target state="translated">这是一个简短的示例，显示了如何使用 &lt;code&gt;IO::Select&lt;/code&gt; 编写服务器，该服务器与多个套接字通信，同时还在侦听套接字上侦听更多连接</target>
        </trans-unit>
        <trans-unit id="f42a88335a66627a85ff6a9bee66b1f0bc358b5d" translate="yes" xml:space="preserve">
          <source>Here is a short, but incomplete summary:</source>
          <target state="translated">下面是一个简短但不完整的总结。</target>
        </trans-unit>
        <trans-unit id="120acde3518e6786e0d2c79e05b71648be345e7b" translate="yes" xml:space="preserve">
          <source>Here is a simple XSUB which illustrates the mechanics of calling both the &lt;code&gt;PrintID&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; methods from C.</source>
          <target state="translated">这是一个简单的XSUB，它说明了从C 调用 &lt;code&gt;PrintID&lt;/code&gt; 和 &lt;code&gt;Display&lt;/code&gt; 方法的机制。</target>
        </trans-unit>
        <trans-unit id="fe479990bde1cedb7827b08a0b51384331185af7" translate="yes" xml:space="preserve">
          <source>Here is a simple constructor:</source>
          <target state="translated">这里有一个简单的构造函数。</target>
        </trans-unit>
        <trans-unit id="8cf9fcb79a6528df89e621ddbe45b24482b8eaf2" translate="yes" xml:space="preserve">
          <source>Here is a simple example of how to add a new target to the generated Makefile:</source>
          <target state="translated">下面是一个简单的例子,说明如何在生成的Makefile中添加一个新的目标。</target>
        </trans-unit>
        <trans-unit id="68aa8a40a88c99ac15d963facbd3494dfdead354" translate="yes" xml:space="preserve">
          <source>Here is a simple example of the technique, using the &lt;a href=&quot;Hash::Util::FieldHash&quot;&gt;Hash::Util::FieldHash&lt;/a&gt; core module. This module was added to the core to support inside-out object implementations.</source>
          <target state="translated">这是使用&lt;a href=&quot;Hash::Util::FieldHash&quot;&gt;Hash :: Util :: FieldHash&lt;/a&gt;核心模块的简单方法示例。该模块已添加到核心以支持由内而外的对象实现。</target>
        </trans-unit>
        <trans-unit id="40cda83fc05639dd468f5eab757cfe3f54097a29" translate="yes" xml:space="preserve">
          <source>Here is a simple example of the technique, using the &lt;a href=&quot;hash/util/fieldhash&quot;&gt;Hash::Util::FieldHash&lt;/a&gt; core module. This module was added to the core to support inside-out object implementations.</source>
          <target state="translated">这是使用&lt;a href=&quot;hash/util/fieldhash&quot;&gt;Hash :: Util :: FieldHash&lt;/a&gt;核心模块的简单方法示例。该模块已添加到核心以支持由内而外的对象实现。</target>
        </trans-unit>
        <trans-unit id="559816aad9ae4c16103f091e70123c0b683add53" translate="yes" xml:space="preserve">
          <source>Here is a simple example that uses RECNO (if you are using a version of Perl earlier than 5.004_57 this example won't work -- see &lt;a href=&quot;#Extra-RECNO-Methods&quot;&gt;&quot;Extra RECNO Methods&quot;&lt;/a&gt; for a workaround).</source>
          <target state="translated">这是一个使用RECNO的简单示例（如果您使用的Perl版本早于5.004_57，则此示例将不起作用-解决&lt;a href=&quot;#Extra-RECNO-Methods&quot;&gt;方法&lt;/a&gt;请参见&amp;ldquo;其他RECNO方法&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="126689dd133c61c2158a4c313ed301c9a4876c96" translate="yes" xml:space="preserve">
          <source>Here is a simple example that uses RECNO (if you are using a version of Perl earlier than 5.004_57 this example won't work -- see &lt;a href=&quot;#Extra-RECNO-Methods&quot;&gt;Extra RECNO Methods&lt;/a&gt; for a workaround).</source>
          <target state="translated">这是一个使用RECNO的简单示例（如果您使用的Perl版本早于5.004_57，则此示例将不起作用- 有关解决&lt;a href=&quot;#Extra-RECNO-Methods&quot;&gt;方法&lt;/a&gt;，请参见Extra RECNO Methods）。</target>
        </trans-unit>
        <trans-unit id="319b9d58a92f86f8037b1f0bce75684db1494b7b" translate="yes" xml:space="preserve">
          <source>Here is a skeleton for the</source>
          <target state="translated">这里是一个骨架,用于</target>
        </trans-unit>
        <trans-unit id="550484c98d2783ef867d760a633e2f2132a4d47b" translate="yes" xml:space="preserve">
          <source>Here is a snippet of XSUB which defines</source>
          <target state="translated">这里是XSUB的一个片段,它定义了</target>
        </trans-unit>
        <trans-unit id="002abcfd840947931c322494ad132e91e82ebd0f" translate="yes" xml:space="preserve">
          <source>Here is a snippet of code that is loosely based on Tom Christiansen's</source>
          <target state="translated">这里是一段代码,它大致基于Tom Christiansen的</target>
        </trans-unit>
        <trans-unit id="45cde31767fc2f9538502554458696cb23085fa9" translate="yes" xml:space="preserve">
          <source>Here is a trivial XSUB which prints the context in which it is currently executing.</source>
          <target state="translated">这里有一个琐碎的XSUB,它可以打印出当前正在执行的上下文。</target>
        </trans-unit>
        <trans-unit id="10eee1483a3720a88b88f2a6e6f0dd7de0f97165" translate="yes" xml:space="preserve">
          <source>Here is a trivial example of using &lt;code&gt;deflate&lt;/code&gt; . It simply reads standard input, deflates it and writes it to standard output.</source>
          <target state="translated">这是使用 &lt;code&gt;deflate&lt;/code&gt; 的简单示例。它只是读取标准输入，将其放气并将其写入标准输出。</target>
        </trans-unit>
        <trans-unit id="c80454242f7e359341fe858a8036d1c91f6e349e" translate="yes" xml:space="preserve">
          <source>Here is a trivial example of using &lt;code&gt;deflate&lt;/code&gt;. It simply reads standard input, deflates it and writes it to standard output.</source>
          <target state="translated">这是使用 &lt;code&gt;deflate&lt;/code&gt; 的简单示例。它只是读取标准输入，将其放气并将其写入标准输出。</target>
        </trans-unit>
        <trans-unit id="41ea711e9831279932d6165629ca443cfabce37a" translate="yes" xml:space="preserve">
          <source>Here is a typical example of context popping, as found in &lt;code&gt;pp_leavesub&lt;/code&gt; (simplified slightly):</source>
          <target state="translated">这是一个典型的上下文弹出示例，如 &lt;code&gt;pp_leavesub&lt;/code&gt; （略有简化）所示：</target>
        </trans-unit>
        <trans-unit id="1868baee762e5828998b63475228ea8991afb128" translate="yes" xml:space="preserve">
          <source>Here is a very brief example of a policy module that expires each cache item after ten seconds.</source>
          <target state="translated">下面是一个非常简单的策略模块的例子,每个缓存项目在十秒后过期。</target>
        </trans-unit>
        <trans-unit id="7f88bfdf5db7c3c03b6f8f2495da889972cfe524" translate="yes" xml:space="preserve">
          <source>Here is a very spartan uudecoder that will work on EBCDIC:</source>
          <target state="translated">这里是一个非常简陋的uudecoder,可以在EBCDIC上工作。</target>
        </trans-unit>
        <trans-unit id="d946c977086b5be12c98dcb6ff1ce5c76b228d28" translate="yes" xml:space="preserve">
          <source>Here is an efficient way to delete all files that haven't been modified for at least a week:</source>
          <target state="translated">这里有一个有效的方法,可以删除所有至少一周内没有修改的文件。</target>
        </trans-unit>
        <trans-unit id="70fccfa6b6af36450513847e29399b60a48adeac" translate="yes" xml:space="preserve">
          <source>Here is an example from big5-eten.</source>
          <target state="translated">下面是big5-eten的一个例子。</target>
        </trans-unit>
        <trans-unit id="e9c9019a4b9d1c2c747c162dad5a190290c7d35f" translate="yes" xml:space="preserve">
          <source>Here is an example of backtracking: Let's say you want to find the word following &quot;foo&quot; in the string &quot;Food is on the foo table.&quot;:</source>
          <target state="translated">下面是一个回溯的例子。假设你想在 &quot;食物在福桌上 &quot;这个字符串中 找到 &quot;福 &quot;后面的单词。</target>
        </trans-unit>
        <trans-unit id="ea40af6afb8d235271ee69af60576e5fd7626d85" translate="yes" xml:space="preserve">
          <source>Here is an example of how to access the option name and value from within a subroutine:</source>
          <target state="translated">下面是一个如何在子程序中访问期权名称和值的例子。</target>
        </trans-unit>
        <trans-unit id="205e5e253d5e8d9713777fb82bdd5445436cb1b6" translate="yes" xml:space="preserve">
          <source>Here is an example of how your own code can go broken:</source>
          <target state="translated">下面是一个例子,说明自己的代码怎么会坏掉。</target>
        </trans-unit>
        <trans-unit id="748768cc7486ba197e2bf8648f0ea7277ae15d72" translate="yes" xml:space="preserve">
          <source>Here is an example of the script which &quot;calculates&quot; the side of circumscribed octagon using the above package:</source>
          <target state="translated">下面是一个使用上述软件包 &quot;计算 &quot;圆周八角形边的脚本示例。</target>
        </trans-unit>
        <trans-unit id="404268aa749a8cb74398fcef4885ddfb5e393936" translate="yes" xml:space="preserve">
          <source>Here is an example of these principles in action:</source>
          <target state="translated">下面是这些原则的一个实例。</target>
        </trans-unit>
        <trans-unit id="d36af1892ac909ba4b83e53e087863bb90d56692" translate="yes" xml:space="preserve">
          <source>Here is an example of using &lt;code&gt;NVtime&lt;/code&gt; from C:</source>
          <target state="translated">这是从C 使用 &lt;code&gt;NVtime&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="7c9994bdad12e2f359f710fa2f6ef403d1effd52" translate="yes" xml:space="preserve">
          <source>Here is an example of using &lt;code&gt;inflate&lt;/code&gt; .</source>
          <target state="translated">这是使用 &lt;code&gt;inflate&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="db70c2ba72c1ebe893c3bd333e0df1b322d0b57a" translate="yes" xml:space="preserve">
          <source>Here is an example of using &lt;code&gt;inflate&lt;/code&gt;.</source>
          <target state="translated">这是使用 &lt;code&gt;inflate&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="a6e2da397e1c17983df2e6041276a4e28620f94d" translate="yes" xml:space="preserve">
          <source>Here is an example of using an optional parameter to override the default buffer size.</source>
          <target state="translated">下面是一个使用可选参数来覆盖默认缓冲区大小的例子。</target>
        </trans-unit>
        <trans-unit id="8f3c57546ccedafc9770a8f0efa81f37adc91294" translate="yes" xml:space="preserve">
          <source>Here is an example of using the &lt;code&gt;Compress::Raw::Zlib::Deflate&lt;/code&gt; optional parameter list to override the default buffer size and compression level. All other options will take their default values.</source>
          <target state="translated">这是一个使用 &lt;code&gt;Compress::Raw::Zlib::Deflate&lt;/code&gt; 可选参数列表来覆盖默认缓冲区大小和压缩级别的示例。所有其他选项将采用其默认值。</target>
        </trans-unit>
        <trans-unit id="87545ecf0b6e7815b60232cfb74673f436cd6fe1" translate="yes" xml:space="preserve">
          <source>Here is an example of using the &lt;code&gt;deflateInit&lt;/code&gt; optional parameter list to override the default buffer size and compression level. All other options will take their default values.</source>
          <target state="translated">这是一个使用 &lt;code&gt;deflateInit&lt;/code&gt; 可选参数列表覆盖默认缓冲区大小和压缩级别的示例。所有其他选项将采用其默认值。</target>
        </trans-unit>
        <trans-unit id="09d05a4a26dea0db21fa2d5b84da51786c319d41" translate="yes" xml:space="preserve">
          <source>Here is an example of using the &lt;code&gt;inflateInit&lt;/code&gt; optional parameter to override the default buffer size.</source>
          <target state="translated">这是一个使用 &lt;code&gt;inflateInit&lt;/code&gt; 可选参数来覆盖默认缓冲区大小的示例。</target>
        </trans-unit>
        <trans-unit id="c7cbd7a5ef78ce531e711de3f32a263a9851ff1b" translate="yes" xml:space="preserve">
          <source>Here is an example of using the filter:</source>
          <target state="translated">下面是一个使用过滤器的例子。</target>
        </trans-unit>
        <trans-unit id="e4ff3e36580b38b61c7a227d4955c81060aeb814" translate="yes" xml:space="preserve">
          <source>Here is an example script that uses &lt;code&gt;Filter::sh&lt;/code&gt; :</source>
          <target state="translated">这是一个使用 &lt;code&gt;Filter::sh&lt;/code&gt; 的示例脚本：</target>
        </trans-unit>
        <trans-unit id="626be57a73915f6479e3b15d4d6386f5b48c7020" translate="yes" xml:space="preserve">
          <source>Here is an example script that uses &lt;code&gt;Filter::sh&lt;/code&gt;:</source>
          <target state="translated">这是一个使用 &lt;code&gt;Filter::sh&lt;/code&gt; 的示例脚本：</target>
        </trans-unit>
        <trans-unit id="012645975f14da1f34bb102f202aaf2953a30bc6" translate="yes" xml:space="preserve">
          <source>Here is an example script which uses the interface. It implements a</source>
          <target state="translated">这里是一个使用该接口的脚本示例。它实现了一个</target>
        </trans-unit>
        <trans-unit id="1cbf7c7be1c22fad45e3015eadd538010d85816f" translate="yes" xml:space="preserve">
          <source>Here is an example that makes use of this tie:</source>
          <target state="translated">下面是一个利用这个领带的例子。</target>
        </trans-unit>
        <trans-unit id="a8ff5767311ec468cc89661ca51ca82e04f18ab9" translate="yes" xml:space="preserve">
          <source>Here is an example that renames all c files to cpp.</source>
          <target state="translated">下面是一个将所有c文件重命名为cpp的例子。</target>
        </trans-unit>
        <trans-unit id="80e0e9e4bb3140e634ddeaa722387560a0149a79" translate="yes" xml:space="preserve">
          <source>Here is an example to illustrate how the bits actually fall in place:</source>
          <target state="translated">这里举个例子来说明位子到底是如何落地的。</target>
        </trans-unit>
        <trans-unit id="d0e29b3fe9551af38ec63a152fe4f4ef139ee92e" translate="yes" xml:space="preserve">
          <source>Here is an example where a string containing blank-separated words, numbers and single dashes is to be split into its components. Using &lt;code&gt;/\s+/&lt;/code&gt; alone won't work, because spaces are not required between dashes, or a word or a dash. Additional places for a split are established by looking ahead and behind:</source>
          <target state="translated">这是一个示例，其中包含以空格分隔的单词，数字和单破折号的字符串将被拆分成多个部分。单独使用 &lt;code&gt;/\s+/&lt;/code&gt; 行不通的，因为在破折号，单词或破折号之间不需要空格。通过向前和向后看，可以建立其他拆分位置：</target>
        </trans-unit>
        <trans-unit id="4b737180e2561bd5a0699f794a8b8783a4667057" translate="yes" xml:space="preserve">
          <source>Here is an example which illustrates the problem from a &lt;b&gt;DB_File&lt;/b&gt; perspective:</source>
          <target state="translated">这是一个从&lt;b&gt;DB_File&lt;/b&gt;角度说明问题的示例：</target>
        </trans-unit>
        <trans-unit id="f644e6370d9a6fe28106ff279c08d32f76b322b7" translate="yes" xml:space="preserve">
          <source>Here is an extreme example. Consider the Fibonacci sequence, defined by the following function:</source>
          <target state="translated">下面是一个极端的例子。考虑斐波那契序列,由以下函数定义。</target>
        </trans-unit>
        <trans-unit id="87cc084321780edd34384cbc3149445fe191a094" translate="yes" xml:space="preserve">
          <source>Here is an interesting idea that doesn't involve the Debug filter. Currently Perl subroutines have fairly limited support for formal parameter lists. You can specify the number of parameters and their type, but you still have to manually take them out of the &lt;code&gt;@_&lt;/code&gt; array yourself. Write a source filter that allows you to have a named parameter list. Such a filter would turn this:</source>
          <target state="translated">这是一个有趣的想法，它不涉及&amp;ldquo;调试&amp;rdquo;过滤器。当前，Perl子例程对形式参数列表的支持相当有限。您可以指定参数的数量及其类型，但是仍然必须手动将它们从 &lt;code&gt;@_&lt;/code&gt; 数组中取出。编写一个源过滤器，使您可以拥有一个命名参数列表。这样的过滤器会变成这样：</target>
        </trans-unit>
        <trans-unit id="cdf048c5ea517c38dde03f3aa3ec4c135c3bd31b" translate="yes" xml:space="preserve">
          <source>Here is another real-life example. By default, whenever Perl writes to a DBM database it always writes the key and value as strings. So when you use this:</source>
          <target state="translated">下面是另一个真实的例子。默认情况下,每当Perl写入DBM数据库时,它总是将键和值写成字符串。所以当你使用这个。</target>
        </trans-unit>
        <trans-unit id="25d95fcca3eab15fb28653dc8409bb9ada80176a" translate="yes" xml:space="preserve">
          <source>Here is how &lt;code&gt;Encode&lt;/code&gt; handles the UTF8 flag.</source>
          <target state="translated">这是 &lt;code&gt;Encode&lt;/code&gt; 处理UTF8标志的方式。</target>
        </trans-unit>
        <trans-unit id="a3b1ac2677b1b9f8b57e877bf8d52ae893a26dd3" translate="yes" xml:space="preserve">
          <source>Here is how the blind poet would modernise the encoding:</source>
          <target state="translated">以下是盲人诗人将如何进行现代化的编码。</target>
        </trans-unit>
        <trans-unit id="89e87986f55aa1d049d1fc43e956c467b865ddf7" translate="yes" xml:space="preserve">
          <source>Here is how to query the database for the &lt;b&gt;de&lt;/b&gt; (Deutsch or German) locale.</source>
          <target state="translated">以下是在数据库中查询&lt;b&gt;de&lt;/b&gt;（德语或德语）语言环境的方法。</target>
        </trans-unit>
        <trans-unit id="b74dc5032afa362c898993b212d8c65907cee21d" translate="yes" xml:space="preserve">
          <source>Here is how to use this module.</source>
          <target state="translated">下面是这个模块的使用方法。</target>
        </trans-unit>
        <trans-unit id="e417973919b13f8ed343cc33d50cf8bf18dd96fb" translate="yes" xml:space="preserve">
          <source>Here is how to write your native data out using UTF-8 (or UTF-EBCDIC) and then read it back in.</source>
          <target state="translated">下面是如何使用UTF-8(或UTF-EBCDIC)将本地数据写出来,然后再读回来。</target>
        </trans-unit>
        <trans-unit id="e23347f9a27415c41076a210002eea6fcec860f7" translate="yes" xml:space="preserve">
          <source>Here is our &lt;code&gt;File&lt;/code&gt; class using &lt;code&gt;Moose&lt;/code&gt; :</source>
          <target state="translated">这是我们使用 &lt;code&gt;Moose&lt;/code&gt; 的 &lt;code&gt;File&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="9495aaee55fb80cc67d19bf52eb6559a4bfcab26" translate="yes" xml:space="preserve">
          <source>Here is our &lt;code&gt;File&lt;/code&gt; class using &lt;code&gt;Moose&lt;/code&gt;:</source>
          <target state="translated">这是我们使用 &lt;code&gt;Moose&lt;/code&gt; 的 &lt;code&gt;File&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="3cd300984a980fc559dc1a1ab348f5e54e30db5c" translate="yes" xml:space="preserve">
          <source>Here is same snippet of code rewritten using &lt;code&gt;globmap&lt;/code&gt;</source>
          <target state="translated">这是使用 &lt;code&gt;globmap&lt;/code&gt; 重写的同一代码段</target>
        </trans-unit>
        <trans-unit id="9d1d9e97293f2045a09f6d838c3b2ec8fb4c6f77" translate="yes" xml:space="preserve">
          <source>Here is some explanation of that format:</source>
          <target state="translated">下面是对这种格式的一些解释。</target>
        </trans-unit>
        <trans-unit id="f6967e582bf81d06472d4e74fa87d3738c79e15a" translate="yes" xml:space="preserve">
          <source>Here is the Perl subroutine</source>
          <target state="translated">下面是Perl的子程序</target>
        </trans-unit>
        <trans-unit id="c14eb5e60796cb8513e72c1a3dc8468ba095c078" translate="yes" xml:space="preserve">
          <source>Here is the answer for the exercise: In the case of str(), we need no explicit recursion since the overloaded &lt;code&gt;.&lt;/code&gt;-operator will fall back to an existing overloaded operator &lt;code&gt;&quot;&quot;&lt;/code&gt; . Overloaded arithmetic operators</source>
          <target state="translated">这是练习的答案：在str（）的情况下，由于重载，我们不需要显式递归 &lt;code&gt;.&lt;/code&gt; -operator将退回到现有的重载运算符 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。重载算术运算符</target>
        </trans-unit>
        <trans-unit id="859c0d277a95c300a54069c3c3fa1998c806c07c" translate="yes" xml:space="preserve">
          <source>Here is the answer for the exercise: In the case of str(), we need no explicit recursion since the overloaded &lt;code&gt;.&lt;/code&gt;-operator will fall back to an existing overloaded operator &lt;code&gt;&quot;&quot;&lt;/code&gt;. Overloaded arithmetic operators</source>
          <target state="translated">这是练习的答案：在str（）的情况下，由于重载，我们不需要显式递归 &lt;code&gt;.&lt;/code&gt; -operator将退回到现有的重载运算符 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。重载算术运算符</target>
        </trans-unit>
        <trans-unit id="0490d051b62ee770784e189641a4237c3b3f3c05" translate="yes" xml:space="preserve">
          <source>Here is the complete Debug filter:</source>
          <target state="translated">这里是完整的Debug过滤器。</target>
        </trans-unit>
        <trans-unit id="1389bf6f29596689df97762593fe5eec3e652d54" translate="yes" xml:space="preserve">
          <source>Here is the complete list of POP macros available, along with the types they return.</source>
          <target state="translated">以下是可用的POP宏的完整列表,以及它们返回的类型。</target>
        </trans-unit>
        <trans-unit id="41758a39c9a7b172d40507117ebc8d6513b795ee" translate="yes" xml:space="preserve">
          <source>Here is the crux of the problem. A side-effect of opening the &lt;b&gt;DB_File&lt;/b&gt; database in step 2 is that an initial block from the database will get read from disk and cached in memory.</source>
          <target state="translated">这是问题的症结所在。在第2步中打开&lt;b&gt;DB_File&lt;/b&gt;数据库的副作用是，数据库的初始块将从磁盘读取并缓存在内存中。</target>
        </trans-unit>
        <trans-unit id="c51e4961cb27feed1f60a5e6765893809aef1e36" translate="yes" xml:space="preserve">
          <source>Here is the hooking interface:</source>
          <target state="translated">这里是挂钩界面。</target>
        </trans-unit>
        <trans-unit id="a16851851d330cec48f9b8e9d6adc8c31c07b46b" translate="yes" xml:space="preserve">
          <source>Here is the list of options. Some options can be in short format (-f) or long (--from) one.</source>
          <target state="translated">下面是选项列表。有些选项可以是短格式(-f)或长格式(-from)。</target>
        </trans-unit>
        <trans-unit id="59a0c7a2e7021b69e05a0894a3173e1357ec31a3" translate="yes" xml:space="preserve">
          <source>Here is the list of things which may be &quot;broken&quot; on EMX (from EMX docs):</source>
          <target state="translated">以下是EMX上可能 &quot;坏掉 &quot;的东西清单(来自EMX文档)。</target>
        </trans-unit>
        <trans-unit id="2ff240e57cd35b4f33c424da68af14cbdadb7f0a" translate="yes" xml:space="preserve">
          <source>Here is the module.</source>
          <target state="translated">这里是模块。</target>
        </trans-unit>
        <trans-unit id="1061d133b7ebfd4153ef09e5ea8f0d70a6682093" translate="yes" xml:space="preserve">
          <source>Here is the output (split into several lines):</source>
          <target state="translated">下面是输出结果(分成几行)。</target>
        </trans-unit>
        <trans-unit id="8d77260497f2dd38213b4c5d12c82639b7bb64d8" translate="yes" xml:space="preserve">
          <source>Here is the output from the code above.</source>
          <target state="translated">下面是上面代码的输出。</target>
        </trans-unit>
        <trans-unit id="afa8a8a3c0bd9e2f5b6e60996a561b236f9c8638" translate="yes" xml:space="preserve">
          <source>Here is the output from the script:</source>
          <target state="translated">下面是脚本的输出。</target>
        </trans-unit>
        <trans-unit id="3165612e15dd81d081ad2ea3bdee303a0e8cef7a" translate="yes" xml:space="preserve">
          <source>Here is the output:</source>
          <target state="translated">这是输出。</target>
        </trans-unit>
        <trans-unit id="bc7f872b555210687127240090558fcc03c8212f" translate="yes" xml:space="preserve">
          <source>Here is the relevant quote from the dbopen man page where it defines the use of the R_CURSOR flag with seq:</source>
          <target state="translated">这里是引用dbopen手册中的相关内容,它定义了使用seq.R_CURSOR标志。</target>
        </trans-unit>
        <trans-unit id="2219210520e554129a1633cb7206210581ad4e0f" translate="yes" xml:space="preserve">
          <source>Here is the sample C file:</source>
          <target state="translated">下面是C文件的示例。</target>
        </trans-unit>
        <trans-unit id="4b7d8db184d6d571b8ca9a214519cc03ef4c5e4a" translate="yes" xml:space="preserve">
          <source>Here is the script above rewritten using the &lt;code&gt;seq&lt;/code&gt; API method.</source>
          <target state="translated">这是上面使用 &lt;code&gt;seq&lt;/code&gt; API方法重写的脚本。</target>
        </trans-unit>
        <trans-unit id="2e67d178bb0da6449165979cec1cd5461e419a26" translate="yes" xml:space="preserve">
          <source>Here is the text of</source>
          <target state="translated">以下是全文</target>
        </trans-unit>
        <trans-unit id="ff1b450e27d60fd1ad40e7bb902cfa0aa22a3e80" translate="yes" xml:space="preserve">
          <source>Here is what C has that Perl doesn't:</source>
          <target state="translated">下面是C语言有的,Perl没有的。</target>
        </trans-unit>
        <trans-unit id="16fc2b68835145e65475f1bb3c3809808bf7eb3b" translate="yes" xml:space="preserve">
          <source>Here is yet another way to print your environment:</source>
          <target state="translated">下面是另一种打印环境的方法。</target>
        </trans-unit>
        <trans-unit id="a9c1621c9657e20cbf24cd9acf9471928604302c" translate="yes" xml:space="preserve">
          <source>Here some simple examples. For the full details of the data structure and the related glob-style pattern matching, see &lt;a href=&quot;TAP::Parser::Scheduler#Rules-data-structure&quot;&gt;&quot;Rules data structure&quot; in TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="translated">这里有一些简单的例子。有关数据结构和相关的glob样式模式匹配的完整详细信息，请参见&lt;a href=&quot;TAP::Parser::Scheduler#Rules-data-structure&quot;&gt;TAP :: Parser :: Scheduler中的&amp;ldquo;规则数据结构&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d8ed8a023e586883874c39ef49b4107598cdc9c" translate="yes" xml:space="preserve">
          <source>Here some simple examples. For the full details of the data structure and the related glob-style pattern matching, see &lt;a href=&quot;parser/scheduler#Rules-data-structure&quot;&gt;Rules data structure in TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="translated">这里有一些简单的例子。有关数据结构和相关的glob样式模式匹配的完整详细信息，请参见&lt;a href=&quot;parser/scheduler#Rules-data-structure&quot;&gt;TAP :: Parser :: Scheduler中的Rules数据结构&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c82546a7315fbf02695dbf5d467040f6b1a876b8" translate="yes" xml:space="preserve">
          <source>Here the actual architecture of the Synology system matters. You have to find out where the gcc libraries have been installed. Look in /opt for a directory similar to arm-none-linux-gnueab or powerpc-linux-gnuspe. In the instructions below I'll use powerpc-linux-gnuspe as an example.</source>
          <target state="translated">这里,Synology 系统的实际架构很重要。你必须找到安装 gcc 库的位置。在 /opt 中寻找类似 arm-none-linux-gnueab 或 powerpc-linux-gnuspe 的目录。在下面的说明中,我将以 powerpc-linux-gnuspe 为例。</target>
        </trans-unit>
        <trans-unit id="8ac9540016a9d087f8c1a19391a980dab40c0a80" translate="yes" xml:space="preserve">
          <source>Here the first call caches the list (1,2,3,4,5,6,7). The second call does not really make sense. &lt;code&gt;Memoize&lt;/code&gt; cannot guess what behavior &lt;code&gt;iota&lt;/code&gt; should have in scalar context without actually calling it in scalar context. Normally &lt;code&gt;Memoize&lt;/code&gt;</source>
          <target state="translated">在这里，第一个调用将缓存列表（1,2,3,4,5,6,7）。第二个电话真的没有意义。 &lt;code&gt;Memoize&lt;/code&gt; 无法猜测什么样的行为 &lt;code&gt;iota&lt;/code&gt; 应该在标量上下文没有在标量上下文实际调用它。通常 &lt;code&gt;Memoize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9449cd01fe2c1ad3593def47ef2650f44e48880d" translate="yes" xml:space="preserve">
          <source>Here the first line will load &lt;code&gt;Carp&lt;/code&gt;</source>
          <target state="translated">第一行将加载 &lt;code&gt;Carp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ec7a9d65cd4bf61cf8b315b7aa4990f3fbae6e4" translate="yes" xml:space="preserve">
          <source>Here the generated XS function returns nothing on success, and will die() with a meaningful error message on error.</source>
          <target state="translated">这里生成的XS函数在成功时不返回任何内容,而在出错时将会die(),并给出有意义的错误信息。</target>
        </trans-unit>
        <trans-unit id="083a79c03137ba3c061edc8bbcb5ea85ceb9fdd1" translate="yes" xml:space="preserve">
          <source>Here the multi-argument form of pipe open() is preferred because the pattern and indeed even the filenames themselves might hold metacharacters.</source>
          <target state="translated">在这里,pipe open()的多参数形式是首选,因为模式甚至文件名本身都可能包含元字符。</target>
        </trans-unit>
        <trans-unit id="84ce6346e023cfe513980b15261a23a5e8073bce" translate="yes" xml:space="preserve">
          <source>Here the number of bytes chopped off (1) is shown next as the OFFSET. The portion of the string between the &quot;real&quot; and the &quot;fake&quot; beginnings is shown in parentheses, and the values of &lt;code&gt;SvCUR&lt;/code&gt; and &lt;code&gt;SvLEN&lt;/code&gt; reflect the fake beginning, not the real one. (The first character of the string buffer happens to have changed to &quot;\1&quot; here, not &quot;1&quot;, because the current implementation stores the offset count in the string buffer. This is subject to change.)</source>
          <target state="translated">在这里，被切掉的字节数（1）接下来显示为OFFSET。括号中显示的是&amp;ldquo;真实&amp;rdquo;和&amp;ldquo;假&amp;rdquo;开头之间的字符串部分， &lt;code&gt;SvCUR&lt;/code&gt; 和 &lt;code&gt;SvLEN&lt;/code&gt; 的值反映的是假开头，而不是真实的开头。 （由于当前实现将偏移量计数存储在字符串缓冲区中，因此字符串缓冲区的第一个字符恰好已更改为&amp;ldquo; \ 1&amp;rdquo;，而不是&amp;ldquo; 1&amp;rdquo;。这可能会发生变化。）</target>
        </trans-unit>
        <trans-unit id="02f2e253f1bb4668aac3cfa34c16cf32f5c7d557" translate="yes" xml:space="preserve">
          <source>Here translator() is a subroutine which takes</source>
          <target state="translated">这里的 translator()是一个子程序,它以</target>
        </trans-unit>
        <trans-unit id="5ec73b17b809ba7add1fdfcfb1b37379d0947f01" translate="yes" xml:space="preserve">
          <source>Here we are assuming &lt;code&gt;My::I18N::en&lt;/code&gt; to own the main lexicon.</source>
          <target state="translated">在这里，我们假设 &lt;code&gt;My::I18N::en&lt;/code&gt; 拥有主词典。</target>
        </trans-unit>
        <trans-unit id="69ad459c54b1acfe7be7330c75e06154ad271928" translate="yes" xml:space="preserve">
          <source>Here we can see a much more complex program, with various optimisations in play. At regnode 10 we see an example where a character class with only one character in it was turned into an &lt;code&gt;EXACT&lt;/code&gt; node. We can also see where an entire alternation was turned into a &lt;code&gt;TRIE-EXACT&lt;/code&gt; node. As a consequence, some of the regnodes have been marked as optimised away. We can see that the &lt;code&gt;$&lt;/code&gt; symbol has been converted into an &lt;code&gt;EOL&lt;/code&gt; regop, a special piece of code that looks for &lt;code&gt;\n&lt;/code&gt; or the end of the string.</source>
          <target state="translated">在这里，我们可以看到一个更加复杂的程序，并且在进行各种优化。在Regnode 10，我们看到一个示例，其中仅包含一个字符的字符类被转换为 &lt;code&gt;EXACT&lt;/code&gt; 节点。我们还可以看到将整个替换项转换为 &lt;code&gt;TRIE-EXACT&lt;/code&gt; 节点的位置。结果，某些regnode已被标记为已优化。我们可以看到 &lt;code&gt;$&lt;/code&gt; 符号已转换为 &lt;code&gt;EOL&lt;/code&gt; 重做，这是一段特殊代码，用于查找 &lt;code&gt;\n&lt;/code&gt; 或字符串的结尾。</target>
        </trans-unit>
        <trans-unit id="9e88298fdbd00bad0c423ba34b385ffbc4d523ec" translate="yes" xml:space="preserve">
          <source>Here we describe the internal form your code is converted to by Perl. Start with a simple example:</source>
          <target state="translated">这里我们描述一下你的代码被Perl转换为的内部形式。从一个简单的例子开始。</target>
        </trans-unit>
        <trans-unit id="c7a54d30dda627090722af6ca7619feef7f811fd" translate="yes" xml:space="preserve">
          <source>Here we discuss how to build Perl under AmigaOS.</source>
          <target state="translated">这里我们讨论如何在AmigaOS下构建Perl。</target>
        </trans-unit>
        <trans-unit id="5a948596d25d15dea7b9635c0bba86ef5734411f" translate="yes" xml:space="preserve">
          <source>Here we discuss how to build Perl under OS/2.</source>
          <target state="translated">这里我们讨论如何在OS/2下构建Perl。</target>
        </trans-unit>
        <trans-unit id="e0ac29b536b198edfced84637724dab1c5327400" translate="yes" xml:space="preserve">
          <source>Here we document the backslash sequences that don't fall in one of the categories above. These are:</source>
          <target state="translated">在这里,我们记录了不属于上述某一类的反斜杠序列。这些序列是:</target>
        </trans-unit>
        <trans-unit id="78599b796151b0cc81f36fe73ffc3c8ea3b46215" translate="yes" xml:space="preserve">
          <source>Here we list environment variables with are either OS/2- and DOS- and Win*-specific, or are more important under OS/2 than under other OSes.</source>
          <target state="translated">这里我们列出了环境变量,这些变量要么是OS/2和DOS以及Win*特有的,要么是在OS/2下比在其他操作系统下更重要。</target>
        </trans-unit>
        <trans-unit id="2d28d2754acd9ac1365a8c90a3604a80ec81bb16" translate="yes" xml:space="preserve">
          <source>Here we list major changes which could make you by surprise.</source>
          <target state="translated">在这里,我们列出了可能让你感到意外的重大变化。</target>
        </trans-unit>
        <trans-unit id="ffa194969d86c572c4f360d304be10a58d841a2b" translate="yes" xml:space="preserve">
          <source>Here we suppose that conversion to &lt;code&gt;MyObject&lt;/code&gt; in the INPUT: section and from MyObject when processing RETVAL will modify a global variable &lt;code&gt;global_state&lt;/code&gt; . After these conversions are performed, we restore the old value of &lt;code&gt;global_state&lt;/code&gt; (to avoid memory leaks, for example).</source>
          <target state="translated">在这里，我们假设在处理RETVAL时，在INPUT：部分中从MyObject 转换为 &lt;code&gt;MyObject&lt;/code&gt; 会修改全局变量 &lt;code&gt;global_state&lt;/code&gt; 。执行完这些转换后，我们恢复了 &lt;code&gt;global_state&lt;/code&gt; 的旧值（例如，避免内存泄漏）。</target>
        </trans-unit>
        <trans-unit id="c12f8daf742cd0e2e4cefb5aa95001afa9ec6004" translate="yes" xml:space="preserve">
          <source>Here we suppose that conversion to &lt;code&gt;MyObject&lt;/code&gt; in the INPUT: section and from MyObject when processing RETVAL will modify a global variable &lt;code&gt;global_state&lt;/code&gt;. After these conversions are performed, we restore the old value of &lt;code&gt;global_state&lt;/code&gt; (to avoid memory leaks, for example).</source>
          <target state="translated">在这里，我们假设在处理RETVAL时，在INPUT：部分中从MyObject到 &lt;code&gt;MyObject&lt;/code&gt; 的转换将修改全局变量 &lt;code&gt;global_state&lt;/code&gt; 。执行完这些转换后，我们恢复了 &lt;code&gt;global_state&lt;/code&gt; 的旧值（例如，避免内存泄漏）。</target>
        </trans-unit>
        <trans-unit id="a8ed5c8e65b6eb8ae2e55830259cac345b514bb1" translate="yes" xml:space="preserve">
          <source>Here we'll create some files that will generate a test library. These will include a C source file and a header file. We'll also create a Makefile.PL in this directory. Then we'll make sure that running make at the Mytest2 level will automatically run this Makefile.PL file and the resulting Makefile.</source>
          <target state="translated">在这里,我们将创建一些文件,生成一个测试库。这些文件将包括一个C源文件和一个头文件。我们还将在这个目录下创建一个Makefile.PL。然后我们将确保在Mytest2级别运行make会自动运行这个Makefile.PL文件和生成的Makefile。</target>
        </trans-unit>
        <trans-unit id="930cec360a8de0d300404f1ae97c04e5862e5b86" translate="yes" xml:space="preserve">
          <source>Here we're using the typeglobs to do symbol table aliasing. It's a tad subtle, though, and also won't work if you're using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables, because only globals (even in disguise as &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;s) are in the symbol table.</source>
          <target state="translated">在这里，我们使用typeglobs进行符号表别名。但是，这有点微妙，如果使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 变量，它也将不起作用，因为符号表中仅包含全局变量（甚至伪装成 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="06be2ecbc25fb96dbb599240b486ce47b84ed17c" translate="yes" xml:space="preserve">
          <source>Here we're using the typeglobs to do symbol table aliasing. It's a tad subtle, though, and also won't work if you're using &lt;code&gt;my&lt;/code&gt; variables, because only globals (even in disguise as &lt;code&gt;local&lt;/code&gt;s) are in the symbol table.</source>
          <target state="translated">在这里，我们使用typeglobs进行符号表别名。但是，这有点微妙，如果您使用 &lt;code&gt;my&lt;/code&gt; 变量，它也将不起作用，因为符号表中仅包含全局变量（甚至伪装成 &lt;code&gt;local&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5ca4ef30e473f35ac20ca9ad8e996a139eaf86fb" translate="yes" xml:space="preserve">
          <source>Here we've created a reference to an anonymous array of three elements whose final element is itself a reference to another anonymous array of three elements. (The multidimensional syntax described later can be used to access this. For example, after the above, &lt;code&gt;$arrayref-&amp;gt;[2][1]&lt;/code&gt; would have the value &quot;b&quot;.)</source>
          <target state="translated">在这里，我们创建了对三个元素的匿名数组的引用，其最终元素本身就是对另一个三个元素的匿名数组的引用。（可以使用稍后描述的多维语法来访问它。例如，在上述之后， &lt;code&gt;$arrayref-&amp;gt;[2][1]&lt;/code&gt; 的值将为&amp;ldquo; b&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="977db011c41d89278867b065d331c7d420016e2c" translate="yes" xml:space="preserve">
          <source>Here you see an example of Perl's system abstraction, which we'll see later: &lt;code&gt;PerlMem_malloc&lt;/code&gt; is either your system's &lt;code&gt;malloc&lt;/code&gt; , or Perl's own &lt;code&gt;malloc&lt;/code&gt; as defined in</source>
          <target state="translated">在这里，您将看到Perl系统抽象的示例，稍后我们将看到： &lt;code&gt;PerlMem_malloc&lt;/code&gt; 是系统的 &lt;code&gt;malloc&lt;/code&gt; ，或者是Perl自己的 &lt;code&gt;malloc&lt;/code&gt; ,如</target>
        </trans-unit>
        <trans-unit id="b64b714460c7f17586b097330025e123e22543a5" translate="yes" xml:space="preserve">
          <source>Here you see an example of Perl's system abstraction, which we'll see later: &lt;code&gt;PerlMem_malloc&lt;/code&gt; is either your system's &lt;code&gt;malloc&lt;/code&gt;, or Perl's own &lt;code&gt;malloc&lt;/code&gt; as defined in</source>
          <target state="translated">在这里，您将看到Perl系统抽象的示例，稍后我们将看到： &lt;code&gt;PerlMem_malloc&lt;/code&gt; 是系统的 &lt;code&gt;malloc&lt;/code&gt; ，或者是Perl自己的 &lt;code&gt;malloc&lt;/code&gt; ,如</target>
        </trans-unit>
        <trans-unit id="afea48b05d5e51f5f1638375ce5b0e27610663a4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a full program showing how to make use of locale-sensitive sorting, Unicode casing, and managing print widths when some of the characters take up zero or two columns, not just one column each time. When run, the following program produces this nicely aligned output:</source>
          <target state="translated">这是一个完整的程序，显示了当某些字符占用零或两列，而不是每次仅包含一列时，如何利用对区域设置敏感的排序，Unicode大小写和管理打印宽度。运行时，以下程序将生成此对齐良好的输出：</target>
        </trans-unit>
        <trans-unit id="6a19b2363612bc52e7e1f472c3c8e257075049a6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how to implicitly manage the translation; all encoding and decoding is done automatically, just as with streams that have a particular encoding attached to them:</source>
          <target state="translated">这是隐式管理翻译的方法；所有编码和解码都是自动完成的，就像附加了特定编码的流一样：</target>
        </trans-unit>
        <trans-unit id="e1c2be9aec08f68310e7254caae4389bbea07c40" translate="yes" xml:space="preserve">
          <source>Here's &lt;code&gt;modrm&lt;/code&gt; , a little utility to cleanly remove an installed module.</source>
          <target state="translated">这是 &lt;code&gt;modrm&lt;/code&gt; ，一个实用工具，可以干净地删除已安装的模块。</target>
        </trans-unit>
        <trans-unit id="07ce2ba300c1f805c13e04282fb9bd9b4aef88e6" translate="yes" xml:space="preserve">
          <source>Here's &lt;code&gt;modrm&lt;/code&gt;, a little utility to cleanly remove an installed module.</source>
          <target state="translated">这是 &lt;code&gt;modrm&lt;/code&gt; ，一个实用工具，可以干净地删除已安装的模块。</target>
        </trans-unit>
        <trans-unit id="acb297651ed81fb994c8862e1324045de85e7420" translate="yes" xml:space="preserve">
          <source>Here's a UDP program similar to the sample Internet TCP client given earlier. However, instead of checking one host at a time, the UDP version will check many of them asynchronously by simulating a multicast and then using select() to do a timed-out wait for I/O. To do something similar with TCP, you'd have to use a different socket handle for each host.</source>
          <target state="translated">这里是一个类似于前面给出的Internet TCP客户端示例的UDP程序。然而,UDP版本不是一次只检查一台主机,而是通过模拟多播来异步检查多台主机,然后使用select()来做一个定时退出的I/O等待。如果要用TCP做类似的事情,你必须为每个主机使用不同的socket句柄。</target>
        </trans-unit>
        <trans-unit id="4f4b45b7c3f776b4fbc38fc3bb7e907362d3ca50" translate="yes" xml:space="preserve">
          <source>Here's a brief lead of how to upgrade the compiler to the latest level. Of course this is subject to changes. You can only upgrade versions from ftp-available updates if the first three digit groups are the same (in where you can skip intermediate unlike the patches in the developer snapshots of Perl), or to one version up where the &quot;base&quot; is available. In other words, the AIX compiler patches are cumulative.</source>
          <target state="translated">这里简单的介绍一下如何将编译器升级到最新级别。当然这是有可能改变的。你只能从ftp-available更新的版本升级,如果前三个数字组是相同的(在其中你可以跳过中间不像Perl的开发者快照中的补丁),或者升级到一个版本向上的 &quot;基础 &quot;是可用的。换句话说,AIX编译器的补丁是累积的。</target>
        </trans-unit>
        <trans-unit id="9083bbfd93bc36a0ba2fe1e425a822a01dff192a" translate="yes" xml:space="preserve">
          <source>Here's a brief recap of the options we covered:</source>
          <target state="translated">下面简单回顾一下我们所涉及的选项。</target>
        </trans-unit>
        <trans-unit id="b70c746e9664f4a89ae78b4bc44345a9debc8745" translate="yes" xml:space="preserve">
          <source>Here's a classic non-closure function-generating function:</source>
          <target state="translated">这是一个经典的非封闭函数生成函数。</target>
        </trans-unit>
        <trans-unit id="737671b9935a9677418172be58d93041b2c042de" translate="yes" xml:space="preserve">
          <source>Here's a client that creates a TCP connection to the &quot;daytime&quot; service at port 13 of the host name &quot;localhost&quot; and prints out everything that the server there cares to provide.</source>
          <target state="translated">这里有一个客户端,它在主机名 &quot;localhost &quot;的13端口创建了一个TCP连接到 &quot;daytime &quot;服务,并打印出那里的服务器关心提供的一切。</target>
        </trans-unit>
        <trans-unit id="a5f63dc35eae9c630d6e8946bcdd1e57d0bacb18" translate="yes" xml:space="preserve">
          <source>Here's a complete example of matching IPV4 internet protocol addresses in any (single) script</source>
          <target state="translated">下面是一个在任何(单个)脚本中匹配IPV4互联网协议地址的完整示例</target>
        </trans-unit>
        <trans-unit id="b9872b20edef13d184c9e33e7e54f0406f2852dd" translate="yes" xml:space="preserve">
          <source>Here's a diversion: copy &quot;runperl.bat&quot; to &quot;runperl&quot;, and type &quot;runperl&quot;. Explain the observed behavior, or lack thereof. :) Hint: .gnidnats llits er'uoy fi ,&quot;lrepnur&quot; eteled :tniH</source>
          <target state="translated">这里有一个转移:将 &quot;runperl.bat &quot;复制到 &quot;runperl &quot;中,然后输入 &quot;runperl&quot;。解释一下观察到的行为,或者没有观察到。:)提示:.gnidnats llits er'uoy fi,&quot;lrepnur&quot; eteled :tniH。</target>
        </trans-unit>
        <trans-unit id="cf12c485957b201d4ea57553686d7cb0039dde88" translate="yes" xml:space="preserve">
          <source>Here's a list of the backslash sequences that are character classes. They are discussed in more detail below. (For the backslash sequences that aren't character classes, see &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt;.)</source>
          <target state="translated">这是字符类的反斜杠序列的列表。它们将在下面更详细地讨论。（有关不是字符类的反斜杠序列，请参见&lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="5ab128180a319c2d07a98a10caf6a07254c0f651" translate="yes" xml:space="preserve">
          <source>Here's a list of the currently unsupported API, and also the version of Perl below which it is unsupported:</source>
          <target state="translated">下面是目前不支持的API的列表,也是不支持的Perl以下版本。</target>
        </trans-unit>
        <trans-unit id="33b154fc2c3c454de669961df32cf81dfe425d93" translate="yes" xml:space="preserve">
          <source>Here's a little program that generates all permutations of all the words on each line of input. The algorithm embodied in the &lt;code&gt;permute()&lt;/code&gt; function is discussed in Volume 4 (still unpublished) of Knuth's</source>
          <target state="translated">这是一个小程序，可生成输入每一行上所有单词的所有排列。 &lt;code&gt;permute()&lt;/code&gt; 函数中包含的算法在Knuth's的第4卷（尚未出版）中进行了讨论。</target>
        </trans-unit>
        <trans-unit id="ac1edab256d838d310d923b4a7442c76a785939d" translate="yes" xml:space="preserve">
          <source>Here's a little program that's somewhat like fmt(1):</source>
          <target state="translated">这是一个有点像fmt(1)的小程序。</target>
        </trans-unit>
        <trans-unit id="fd6a03a6db0cc55634b2b495ac28f42a4ed52934" translate="yes" xml:space="preserve">
          <source>Here's a lovely Perlish solution by Larry Rosler. It exploits properties of bitwise xor on ASCII strings.</source>
          <target state="translated">这是Larry Rosler的一个可爱的Perlish解决方案。它利用了 ASCII 字符串的 bitwise xor 属性。</target>
        </trans-unit>
        <trans-unit id="c5fae574ad1367dcbd0544744e45226bb907e0c9" translate="yes" xml:space="preserve">
          <source>Here's a mailbox appender for BSD systems.</source>
          <target state="translated">这里有一个BSD系统的邮箱应用程序。</target>
        </trans-unit>
        <trans-unit id="39554d786a12cee063a370b311126f557d404cc0" translate="yes" xml:space="preserve">
          <source>Here's a more complicated example: suppose that you wanted &lt;code&gt;struct netconfig&lt;/code&gt; to be blessed into the class &lt;code&gt;Net::Config&lt;/code&gt; . One way to do this is to use underscores (_) to separate package names, as follows:</source>
          <target state="translated">这是一个更复杂的示例：假设您希望将 &lt;code&gt;struct netconfig&lt;/code&gt; 纳入类 &lt;code&gt;Net::Config&lt;/code&gt; 。一种方法是使用下划线（_）分隔软件包名称，如下所示：</target>
        </trans-unit>
        <trans-unit id="40fb940b270cba1c2d6bdc833bd631f4a1ae5a33" translate="yes" xml:space="preserve">
          <source>Here's a more complicated example: suppose that you wanted &lt;code&gt;struct netconfig&lt;/code&gt; to be blessed into the class &lt;code&gt;Net::Config&lt;/code&gt;. One way to do this is to use underscores (_) to separate package names, as follows:</source>
          <target state="translated">这是一个更复杂的示例：假设您希望将 &lt;code&gt;struct netconfig&lt;/code&gt; 祝福到类 &lt;code&gt;Net::Config&lt;/code&gt; 。一种方法是使用下划线（_）分隔程序包名称，如下所示：</target>
        </trans-unit>
        <trans-unit id="ef76926490bf6bc7991a173108bb3e76598bbc43" translate="yes" xml:space="preserve">
          <source>Here's a more extensive illustration using vec():</source>
          <target state="translated">下面是一个使用vec()的更广泛的说明。</target>
        </trans-unit>
        <trans-unit id="9b21353c7b746d6125b0bd9ccdf2d5f6e32ae7e7" translate="yes" xml:space="preserve">
          <source>Here's a more sophisticated example of using %Config:</source>
          <target state="translated">下面是一个更复杂的使用%Config的例子。</target>
        </trans-unit>
        <trans-unit id="79fc5a3fa5bc2df2e735e49c28e40c308b498181" translate="yes" xml:space="preserve">
          <source>Here's a much better web-page hit counter:</source>
          <target state="translated">这里有一个更好的网页点击计数器。</target>
        </trans-unit>
        <trans-unit id="d392ab49a010fb0ac59f9f0078cb125cae17692b" translate="yes" xml:space="preserve">
          <source>Here's a partial table of features the different packages offer:</source>
          <target state="translated">以下是不同套餐提供的部分功能表。</target>
        </trans-unit>
        <trans-unit id="41a14f9ddca1a8bfb40a30abc5c0f1b2c1f62eef" translate="yes" xml:space="preserve">
          <source>Here's a quick mapping for the utilities/modules, and their names for the $BLACKLIST, $METHOD_FAIL and other internal functions.</source>
          <target state="translated">这里是实用程序/模块的快速映射,以及它们在$BLACKLIST、$METHOD_FAIL和其他内部函数中的名称。</target>
        </trans-unit>
        <trans-unit id="65dd6cf38c10a9b90787d2bbbbe67a89618fa22e" translate="yes" xml:space="preserve">
          <source>Here's a real world example, taken from work done to resolve &lt;a href=&quot;https://github.com/Perl/perl5/issues/10118&quot;&gt;perl #10118&lt;/a&gt;. Use of</source>
          <target state="translated">这是一个真实的示例，取自解决&lt;a href=&quot;https://github.com/Perl/perl5/issues/10118&quot;&gt;perl＃10118的工作&lt;/a&gt;。用于</target>
        </trans-unit>
        <trans-unit id="cda00e934fa6376dbf363c4a7973b5685c850503" translate="yes" xml:space="preserve">
          <source>Here's a reservoir-sampling algorithm from the Camel Book:</source>
          <target state="translated">这是《骆驼记》中的一个水库取样算法。</target>
        </trans-unit>
        <trans-unit id="9e206bb004fc82d9ef3fcc3d4b1c49d6f3d42ac3" translate="yes" xml:space="preserve">
          <source>Here's a safe backtick or pipe open for read:</source>
          <target state="translated">这里有一个安全的背板或管道打开阅读。</target>
        </trans-unit>
        <trans-unit id="a7cce3c8a9d58b666d239193afb2494a20bba3a2" translate="yes" xml:space="preserve">
          <source>Here's a sample TCP client using Internet-domain sockets:</source>
          <target state="translated">下面是一个使用Internet域套接字的TCP客户端示例。</target>
        </trans-unit>
        <trans-unit id="9c9e5f5e52c5d8da22662f4567979deb732ae0a9" translate="yes" xml:space="preserve">
          <source>Here's a sample Unix-domain client:</source>
          <target state="translated">这里有一个Unix-domain客户端的例子。</target>
        </trans-unit>
        <trans-unit id="d1aee0a8129cd8627dd813843d4743d6011f0d62" translate="yes" xml:space="preserve">
          <source>Here's a sample plugin, for your reference:</source>
          <target state="translated">下面是一个示例插件,供大家参考。</target>
        </trans-unit>
        <trans-unit id="bee38889229a5c9d4ff45e0c3ab7e676e43a251f" translate="yes" xml:space="preserve">
          <source>Here's a sample program,</source>
          <target state="translated">这是一个样本程序。</target>
        </trans-unit>
        <trans-unit id="705113e6af32ce6049ec614b7bd8ea0f06bc826f" translate="yes" xml:space="preserve">
          <source>Here's a sample showing how to create and use a record whose fields are of many different sorts:</source>
          <target state="translated">下面是一个示例,展示了如何创建和使用一个字段有多种不同类型的记录。</target>
        </trans-unit>
        <trans-unit id="16fbac9b09446fb7fa1607fa6cbcd3cd579323e7" translate="yes" xml:space="preserve">
          <source>Here's a sample:</source>
          <target state="translated">这是一个样本。</target>
        </trans-unit>
        <trans-unit id="d48d2b1ee87d318b2f88933c600ad433cc38ac05" translate="yes" xml:space="preserve">
          <source>Here's a short bibliography courtesy of J&amp;uuml;rgen Christoffel:</source>
          <target state="translated">这是J&amp;uuml;rgenChristoffel提供的简短参考书目：</target>
        </trans-unit>
        <trans-unit id="7b6db8c67bc1492d1475adb966fe40db79852b40" translate="yes" xml:space="preserve">
          <source>Here's a simple client that takes a remote host to fetch a document from, and then a list of files to get from that host. This is a more interesting client than the previous one because it first sends something to the server before fetching the server's response.</source>
          <target state="translated">这是一个简单的客户端,它从远程主机上获取一个文件,然后从该主机上获取一个文件列表。这个客户端比前一个客户端更有意思,因为它先向服务器发送一些东西,然后再获取服务器的响应。</target>
        </trans-unit>
        <trans-unit id="6d6b6f3994774d06d8f1e409ff389cf7bc440169" translate="yes" xml:space="preserve">
          <source>Here's a simple example of a switch based on pattern matching, lined up in a way to make it look more like a switch statement. We'll do a multiway conditional based on the type of reference stored in $whatchamacallit:</source>
          <target state="translated">下面是一个简单的基于模式匹配的开关的例子,排队的方式让它看起来更像一个开关语句。我们将根据$whatchamacallit中存储的引用类型做一个多向条件。</target>
        </trans-unit>
        <trans-unit id="adf661fec1c7ed224422528dd69c23adb6998e67" translate="yes" xml:space="preserve">
          <source>Here's a simple example to illustrate the difference between the two range operators:</source>
          <target state="translated">这里有一个简单的例子来说明这两个范围运算符的区别。</target>
        </trans-unit>
        <trans-unit id="24f0b23833358ef065f35cfbec9242ef09ccac71" translate="yes" xml:space="preserve">
          <source>Here's a simple program which converts between Celsius and Fahrenheit, it too has a problem:</source>
          <target state="translated">这里有一个简单的程序,可以在摄氏度和华氏度之间进行转换,它也有一个问题。</target>
        </trans-unit>
        <trans-unit id="0837b2c8d138afbded4f97677c64e44b344b5f56" translate="yes" xml:space="preserve">
          <source>Here's a simple-minded example program that rewrites its command-line parameters as integers correctly formatted in the current locale:</source>
          <target state="translated">这里有一个头脑简单的示例程序,它将命令行参数改写为在当前语言环境下正确格式化的整数。</target>
        </trans-unit>
        <trans-unit id="f4b1ca0d619e6e130110c613ca994de9ad0679d7" translate="yes" xml:space="preserve">
          <source>Here's a small example showing shared memory usage.</source>
          <target state="translated">下面是一个显示共享内存使用情况的小例子。</target>
        </trans-unit>
        <trans-unit id="ca0b16455dba662fbcb02846342b83e69dabc681" translate="yes" xml:space="preserve">
          <source>Here's a summary of the possible predicates:</source>
          <target state="translated">下面是对可能的谓语的总结。</target>
        </trans-unit>
        <trans-unit id="58dc9ec13109b06fde34d79108b2ec3645eaf897" translate="yes" xml:space="preserve">
          <source>Here's a test to make sure that the data contains nothing but &quot;word&quot; characters (alphabetics, numerics, and underscores), a hyphen, an at sign, or a dot.</source>
          <target state="translated">下面是一个测试,以确保数据只包含 &quot;字 &quot;字符(字母、数字和下划线)、连字符、&quot;at &quot;号或点。</target>
        </trans-unit>
        <trans-unit id="759693dd6cb991ad225a2379fc23020ea66b9451" translate="yes" xml:space="preserve">
          <source>Here's a trick for interpolating a subroutine call into a string:</source>
          <target state="translated">这里有一个将子程序调用内插到字符串中的技巧。</target>
        </trans-unit>
        <trans-unit id="566b3956738219763456c200fc999f82ae79bed2" translate="yes" xml:space="preserve">
          <source>Here's a truly obscure example:</source>
          <target state="translated">这是一个真正晦涩的例子。</target>
        </trans-unit>
        <trans-unit id="673e00298dcf732578c132c6f7ebc33b00f2f5a5" translate="yes" xml:space="preserve">
          <source>Here's a way to do backticks reasonably safely. Notice how the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; is not called with a string that the shell could expand. This is by far the best way to call something that might be subjected to shell escapes: just never call the shell at all.</source>
          <target state="translated">这是一种合理安全地进行反引号的方法。请注意，如何不使用外壳程序可以扩展的字符串来调用 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 。到目前为止，这是调用可能受到外壳转义符攻击的某些东西的最佳方法：根本不要调用外壳。</target>
        </trans-unit>
        <trans-unit id="d9c7cd5d68bc715c0bc2090946109f25a3884bfa" translate="yes" xml:space="preserve">
          <source>Here's a way to do backticks reasonably safely. Notice how the &lt;code&gt;exec&lt;/code&gt; is not called with a string that the shell could expand. This is by far the best way to call something that might be subjected to shell escapes: just never call the shell at all.</source>
          <target state="translated">这是一种合理安全地进行反引号的方法。请注意，如何不使用外壳程序可以扩展的字符串来调用 &lt;code&gt;exec&lt;/code&gt; 。到目前为止，这是调用可能遭受外壳转义的某些东西的最佳方法：根本不要调用外壳。</target>
        </trans-unit>
        <trans-unit id="eaaae86ddf2180ef145c4679eb81721d464c8d5e" translate="yes" xml:space="preserve">
          <source>Here's an even simpler example: I wrote a simple ray tracer; the program would look in a certain direction, figure out what it was looking at, and then convert the `color' value (typically a string like `red') of that object to a red, green, and blue pixel value, like this:</source>
          <target state="translated">这里有一个更简单的例子。我写了一个简单的射线跟踪器;程序会朝某个方向看,找出它正在看的东西,然后将该物体的 &quot;颜色 &quot;值(通常是像 &quot;红色 &quot;这样的字符串)转换为红色、绿色和蓝色的像素值,像这样。</target>
        </trans-unit>
        <trans-unit id="eb7f2b2a1f46da14792dc92fada7de16651b64e3" translate="yes" xml:space="preserve">
          <source>Here's an example of a module as a blessed scalar:</source>
          <target state="translated">下面是一个模块作为祝福标量的例子。</target>
        </trans-unit>
        <trans-unit id="433e4046c8d4a59acb27a1b8715b8d822849f3f4" translate="yes" xml:space="preserve">
          <source>Here's an example of a semaphore:</source>
          <target state="translated">下面是一个信号体的例子。</target>
        </trans-unit>
        <trans-unit id="e5da5564566886484e5f1909e68561f2893fc59f" translate="yes" xml:space="preserve">
          <source>Here's an example of a simple .t file for the fictional Film module.</source>
          <target state="translated">下面是一个简单的.t文件的例子,用于虚构Film模块。</target>
        </trans-unit>
        <trans-unit id="00e3c595287e645175478199893dcfbab0d3f383" translate="yes" xml:space="preserve">
          <source>Here's an example of a somewhat interesting tied hash class: it gives you a hash representing a particular user's dot files. You index into the hash with the name of the file (minus the dot) and you get back that dot file's contents. For example:</source>
          <target state="translated">这是一个有点有趣的绑定哈希类的例子:它给了你一个哈希,代表一个特定用户的点文件。你用文件名(减去点)索引到哈希中,就能得到该点文件的内容。比如说</target>
        </trans-unit>
        <trans-unit id="44172aa24b9ebcb09c3ac7dacdd0f49ad41ffcca" translate="yes" xml:space="preserve">
          <source>Here's an example of how to copy a binary file:</source>
          <target state="translated">下面是一个如何复制二进制文件的例子。</target>
        </trans-unit>
        <trans-unit id="db4ebf9573581d82c8cc95cd18272cd15b08d992" translate="yes" xml:space="preserve">
          <source>Here's an example of how to pass in a string and a regular expression for it to match against. You construct the pattern with the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator:</source>
          <target state="translated">这是一个如何传递字符串和正则表达式以使其匹配的示例。您可以使用 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 运算符构造模式：</target>
        </trans-unit>
        <trans-unit id="99a411d8c049e8f5d02a926ffc1bf596e0d48187" translate="yes" xml:space="preserve">
          <source>Here's an example of how to pass in a string and a regular expression for it to match against. You construct the pattern with the &lt;code&gt;qr//&lt;/code&gt; operator:</source>
          <target state="translated">这是一个如何传递字符串和正则表达式以使其匹配的示例。您可以使用 &lt;code&gt;qr//&lt;/code&gt; 运算符构造模式：</target>
        </trans-unit>
        <trans-unit id="637519bbaa8687d335368b0791bb0e149bbe34ba" translate="yes" xml:space="preserve">
          <source>Here's an example of running that program, which we'll call</source>
          <target state="translated">下面是一个运行该程序的例子,我们称之为</target>
        </trans-unit>
        <trans-unit id="36af409f70db85a39900fd4afda6942fc83aa2ef" translate="yes" xml:space="preserve">
          <source>Here's an example of setting a filehandle named &lt;code&gt;$REMOTE&lt;/code&gt; to be non-blocking at the system level. You'll have to negotiate &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&lt;code&gt;$|&lt;/code&gt;&lt;/a&gt; on your own, though.</source>
          <target state="translated">这是在系统级别将名为 &lt;code&gt;$REMOTE&lt;/code&gt; 的文件句柄设置为非阻塞的示例。您必须协商&lt;a href=&quot;perlvar#%24%7C&quot;&gt; &lt;code&gt;$|&lt;/code&gt; &lt;/a&gt;靠你自己。</target>
        </trans-unit>
        <trans-unit id="f582133574110a3518036c490af80a6f46ec43be" translate="yes" xml:space="preserve">
          <source>Here's an example of setting a filehandle named &lt;code&gt;REMOTE&lt;/code&gt; to be non-blocking at the system level. You'll have to negotiate &lt;code&gt;$|&lt;/code&gt; on your own, though.</source>
          <target state="translated">这是在系统级别将名为 &lt;code&gt;REMOTE&lt;/code&gt; 的文件句柄设置为非阻塞的示例。您必须协商 &lt;code&gt;$|&lt;/code&gt; 靠你自己。</target>
        </trans-unit>
        <trans-unit id="5747af8299e3ce8766cc1e6c9250f3bd0c64b9fc" translate="yes" xml:space="preserve">
          <source>Here's an example of using open2():</source>
          <target state="translated">下面是一个使用open2()的例子。</target>
        </trans-unit>
        <trans-unit id="52ee3997caaa83f241ead3aa88bc5b3a35f1e445" translate="yes" xml:space="preserve">
          <source>Here's an example of using the &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; variable:</source>
          <target state="translated">这是使用 &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; 变量的示例：</target>
        </trans-unit>
        <trans-unit id="244af372fc1dc3d578b9e7b6c1576ec36ffa9ff8" translate="yes" xml:space="preserve">
          <source>Here's an example of what a stack backtrace via &lt;code&gt;T&lt;/code&gt; command might look like:</source>
          <target state="translated">这是一个通过 &lt;code&gt;T&lt;/code&gt; 命令进行堆栈回溯的示例：</target>
        </trans-unit>
        <trans-unit id="e488d97af419d58ca23b439a55505523edbe2e65" translate="yes" xml:space="preserve">
          <source>Here's an example of what you need for a simple module:</source>
          <target state="translated">下面是一个简单模块所需的例子。</target>
        </trans-unit>
        <trans-unit id="daccc2549e31545d57fdedfeee9273ddd1b0ff86" translate="yes" xml:space="preserve">
          <source>Here's an example script file:</source>
          <target state="translated">这里有一个例子脚本文件。</target>
        </trans-unit>
        <trans-unit id="acda0e1d4c96684fdc356f00d807ddf1f623f6ae" translate="yes" xml:space="preserve">
          <source>Here's an example that looks up nonnumeric uids in the passwd file:</source>
          <target state="translated">下面是一个在passwd文件中查找非数字ids的例子。</target>
        </trans-unit>
        <trans-unit id="5c0f7a1e07a375e4333db5cd9cca105a10ea230a" translate="yes" xml:space="preserve">
          <source>Here's an example that makes sure that whoever runs this program knows their password:</source>
          <target state="translated">这里有一个例子,可以确保运行这个程序的人知道自己的密码。</target>
        </trans-unit>
        <trans-unit id="2ba3dad78e5e2c46821c06eb650b17001a0a2ef6" translate="yes" xml:space="preserve">
          <source>Here's an example to test whether Nagle's algorithm is enabled on a socket:</source>
          <target state="translated">下面是一个测试Nagle算法是否在socket上启用的例子。</target>
        </trans-unit>
        <trans-unit id="d274e7c0c009a3ac1b895b776347d105b0d85baa" translate="yes" xml:space="preserve">
          <source>Here's an example using a recursive regular expression. The goal is to capture all of the text within angle brackets, including the text in nested angle brackets. This sample text has two &quot;major&quot; groups: a group with one level of nesting and a group with two levels of nesting. There are five total groups in angle brackets:</source>
          <target state="translated">这是一个使用递归正则表达式的例子。目标是捕获角括号内的所有文本,包括嵌套角括号内的文本。这个示例文本有两个 &quot;主要 &quot;组:一个组有一级嵌套,一个组有两级嵌套。角括号内共有五个组。</target>
        </trans-unit>
        <trans-unit id="61f04271f847d0c8988094c50219a148be404036" translate="yes" xml:space="preserve">
          <source>Here's an example.</source>
          <target state="translated">这里有一个例子。</target>
        </trans-unit>
        <trans-unit id="af1afc0eb692136e51fe1f2de2eb325d93796576" translate="yes" xml:space="preserve">
          <source>Here's an example. It used to be a common paradigm, for decades, in the perl core to use &lt;code&gt;strchr(&quot;list&quot;, c)&lt;/code&gt; to see if the character &lt;code&gt;c&lt;/code&gt; is any of the ones given in &lt;code&gt;&quot;list&quot;&lt;/code&gt;, a double-quote-enclosed string of the set of characters that we are seeing if &lt;code&gt;c&lt;/code&gt; is one of. As long as &lt;code&gt;c&lt;/code&gt; isn't a &lt;code&gt;NUL&lt;/code&gt;, it works. But when &lt;code&gt;c&lt;/code&gt; is a &lt;code&gt;NUL&lt;/code&gt;, &lt;code&gt;strchr&lt;/code&gt; returns a pointer to the terminating &lt;code&gt;NUL&lt;/code&gt; in &lt;code&gt;&quot;list&quot;&lt;/code&gt;. This likely will result in a segfault or a security issue when the caller uses that end pointer as the starting point to read from.</source>
          <target state="translated">这是一个例子。几十年来，在perl内核中使用 &lt;code&gt;strchr(&quot;list&quot;, c)&lt;/code&gt; 来查看字符 &lt;code&gt;c&lt;/code&gt; 是否为 &lt;code&gt;&quot;list&quot;&lt;/code&gt; （用双引号括起来的字符串）中给出的任何字符，这在几十年来一直是一种常见的范例。如果 &lt;code&gt;c&lt;/code&gt; 是其中之一，我们将看到的一组字符。只要 &lt;code&gt;c&lt;/code&gt; 不是 &lt;code&gt;NUL&lt;/code&gt; ，它就可以工作。但是，当 &lt;code&gt;c&lt;/code&gt; 为 &lt;code&gt;NUL&lt;/code&gt; 时， &lt;code&gt;strchr&lt;/code&gt; 在 &lt;code&gt;&quot;list&quot;&lt;/code&gt; 返回一个指向终止 &lt;code&gt;NUL&lt;/code&gt; 的指针。当调用方使用该结束指针作为读取起点时，这可能会导致段错误或安全问题。</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">这里有一个例子。</target>
        </trans-unit>
        <trans-unit id="ea18952ce84912806a08117b90f220eff293cf76" translate="yes" xml:space="preserve">
          <source>Here's another example of using &lt;code&gt;..&lt;/code&gt; :</source>
          <target state="translated">这是使用 &lt;code&gt;..&lt;/code&gt; 的另一个示例：</target>
        </trans-unit>
        <trans-unit id="15ed5c05afc05681027a67404fe0661073a709bb" translate="yes" xml:space="preserve">
          <source>Here's another example of using &lt;code&gt;..&lt;/code&gt;:</source>
          <target state="translated">这是使用 &lt;code&gt;..&lt;/code&gt; 的另一个示例：</target>
        </trans-unit>
        <trans-unit id="43b272b51e8dfc98c92e4358c6ca3238363075ae" translate="yes" xml:space="preserve">
          <source>Here's another example. Let's say you'd like to match a number at the end of a string, and you also want to keep the preceding part of the match. So you write this:</source>
          <target state="translated">这里还有一个例子。比方说,你想在一个字符串的末尾匹配一个数字,同时你也想保留匹配的前面部分。所以你写下这样的内容。</target>
        </trans-unit>
        <trans-unit id="6d394fbb45cdbc9850e3f0051e919676f4c5a2f8" translate="yes" xml:space="preserve">
          <source>Here's another interesting wanted function. It will find all symbolic links that don't resolve:</source>
          <target state="translated">这里还有一个有趣的想要的功能。它可以找到所有不解析的符号链接。</target>
        </trans-unit>
        <trans-unit id="6dabe892652409d7baaf4ea9766517a9552179bd" translate="yes" xml:space="preserve">
          <source>Here's another simplistic example that illustrates the use of thread signalling in conjunction with a semaphore to provide rudimentary</source>
          <target state="translated">下面是另一个简单的例子,它说明了线程信号与信号体的结合使用,以提供基本的</target>
        </trans-unit>
        <trans-unit id="de1305ff8bab2aad6bcd989ab04908e0dc517958" translate="yes" xml:space="preserve">
          <source>Here's another strategy: Open a pipe to yourself, using &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(MYSELF, &quot;|-&quot;)&lt;/code&gt; (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) and always write() to MYSELF instead of STDOUT. Have your child process massage its STDIN to rearrange headers and footers however you like. Not very convenient, but doable.</source>
          <target state="translated">这是另一种策略：使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(MYSELF, &quot;|-&quot;)&lt;/code&gt; （请参见&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;）打开一条通往自己的管道，并始终将（）写入MYSELF而不是STDOUT。让您的孩子按自己的意愿按摩其STDIN以重新排列页眉和页脚。不是很方便，但是可行。</target>
        </trans-unit>
        <trans-unit id="89e8986edeec6b98232eb3810b91a1ddd6bfcc03" translate="yes" xml:space="preserve">
          <source>Here's another strategy: Open a pipe to yourself, using &lt;code&gt;open(MYSELF, &quot;|-&quot;)&lt;/code&gt; (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;) and always write() to MYSELF instead of STDOUT. Have your child process massage its STDIN to rearrange headers and footers however you like. Not very convenient, but doable.</source>
          <target state="translated">这是另一种策略：使用 &lt;code&gt;open(MYSELF, &quot;|-&quot;)&lt;/code&gt; （请参见&lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc中的&amp;ldquo; open&amp;rdquo; &lt;/a&gt;）打开一个通往自己的管道，并始终将（）写入MYSELF而不是STDOUT。让您的孩子按自己的意愿按摩其STDIN，以重新排列页眉和页脚。不是很方便，但是可行。</target>
        </trans-unit>
        <trans-unit id="5ac230c93491a8097772635d05027ee087235965" translate="yes" xml:space="preserve">
          <source>Here's another way to check for sentences in a paragraph:</source>
          <target state="translated">这里还有一种检查段落中句子的方法。</target>
        </trans-unit>
        <trans-unit id="273a17fa15878be17fe206b05c8584be04a69acf" translate="yes" xml:space="preserve">
          <source>Here's another, slightly less painful, way to do it from Benjamin Goldberg, who uses a zero-width negative look-behind assertion.</source>
          <target state="translated">这里还有一种稍微不那么痛苦的方法,来自Benjamin Goldberg,他使用了一个零宽度的负面看后断言。</target>
        </trans-unit>
        <trans-unit id="0cddef9286505d532aaa041e36320e67de4b2c80" translate="yes" xml:space="preserve">
          <source>Here's another; let's compute spherical volumes:</source>
          <target state="translated">这里还有一个,我们来计算球面体积。</target>
        </trans-unit>
        <trans-unit id="15dc729f18ba699bddbeda2935fed34db64f6cdb" translate="yes" xml:space="preserve">
          <source>Here's code that finds everything between START and END in a paragraph:</source>
          <target state="translated">这里的代码可以找到段落中start和end之间的所有内容。</target>
        </trans-unit>
        <trans-unit id="26eff15275e0bc723eda9623b566a21d7d660ee9" translate="yes" xml:space="preserve">
          <source>Here's how a C programmer might code up a particular algorithm in Perl:</source>
          <target state="translated">下面是一个C程序员如何在Perl中编写一个特定算法的代码。</target>
        </trans-unit>
        <trans-unit id="f53c4c5c95494b6983dc9580a97d651bc52209f4" translate="yes" xml:space="preserve">
          <source>Here's how it really works:</source>
          <target state="translated">下面是它的真实工作原理。</target>
        </trans-unit>
        <trans-unit id="5725ea72516798e0e59187e116804b3012dacd34" translate="yes" xml:space="preserve">
          <source>Here's how that might look:</source>
          <target state="translated">这就是可能出现的情况。</target>
        </trans-unit>
        <trans-unit id="c646f07c7dfa6ee86de30d8e7226eba37cb787f8" translate="yes" xml:space="preserve">
          <source>Here's how to do one operation using a loop. We'll assume an @AoA variable as before.</source>
          <target state="translated">下面是如何使用循环进行一个操作。我们和之前一样假设一个@AoA变量。</target>
        </trans-unit>
        <trans-unit id="268a5d49f5ba74b653796a536ebf6253b796189f" translate="yes" xml:space="preserve">
          <source>Here's how to perform each step for each operating system. This is &amp;lt;not&amp;gt; a substitute for reading the README and INSTALL files that might have come with your module!</source>
          <target state="translated">这是为每个操作系统执行每个步骤的方法。这不是替代读取模块随附的README和INSTALL文件的方法！</target>
        </trans-unit>
        <trans-unit id="f61d7cd6d889dcf489e482c04dbdd66a13cc2eb1" translate="yes" xml:space="preserve">
          <source>Here's how to use &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;\G&lt;/code&gt; :</source>
          <target state="translated">这是在 &lt;code&gt;\G&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="26c1023a9e6ac89e64f8047581df9767933e6cd7" translate="yes" xml:space="preserve">
          <source>Here's how to use &lt;code&gt;m//gc&lt;/code&gt; with &lt;code&gt;\G&lt;/code&gt;:</source>
          <target state="translated">这是在 &lt;code&gt;\G&lt;/code&gt; 上使用 &lt;code&gt;m//gc&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="72b07fa8c9ee5cfa969d3c94936ee2dff05c5e76" translate="yes" xml:space="preserve">
          <source>Here's how to use our little example:</source>
          <target state="translated">下面是我们的小例子。</target>
        </trans-unit>
        <trans-unit id="f9a1c6d8d1b1e5ebc9092a952afe3520c4d3df94" translate="yes" xml:space="preserve">
          <source>Here's how we can make the first example safer:</source>
          <target state="translated">下面是我们如何让第一个例子更安全。</target>
        </trans-unit>
        <trans-unit id="1c3c6addf8c05cad39d9f725c53d0c79d67cc1b7" translate="yes" xml:space="preserve">
          <source>Here's how you might write a function that returns a list of keys occurring in all the hashes passed to it:</source>
          <target state="translated">下面是如何编写一个函数,返回所有传递给它的哈希值中出现的键的列表。</target>
        </trans-unit>
        <trans-unit id="4247da91d20e93ce8300b57f7c386a920c116cb0" translate="yes" xml:space="preserve">
          <source>Here's how you'd compile the example in the next section, &lt;a href=&quot;#Adding-a-Perl-interpreter-to-your-C-program&quot;&gt;&quot;Adding a Perl interpreter to your C program&quot;&lt;/a&gt;, on my Linux box:</source>
          <target state="translated">这是在Linux机器上的下一部分&lt;a href=&quot;#Adding-a-Perl-interpreter-to-your-C-program&quot;&gt;&amp;ldquo;向C程序中添加Perl解释器&amp;rdquo;中&lt;/a&gt;编译示例的方式：</target>
        </trans-unit>
        <trans-unit id="ae2023d3bcf8a706017206316be16158eb0a8503" translate="yes" xml:space="preserve">
          <source>Here's how you'd compile the example in the next section, &lt;a href=&quot;#Adding-a-Perl-interpreter-to-your-C-program&quot;&gt;Adding a Perl interpreter to your C program&lt;/a&gt;, on my Linux box:</source>
          <target state="translated">在下一节&amp;ldquo; 在Linux盒子上&lt;a href=&quot;#Adding-a-Perl-interpreter-to-your-C-program&quot;&gt;向C程序中添加Perl解释器&amp;rdquo;中，您将按照&lt;/a&gt;以下方式编译示例：</target>
        </trans-unit>
        <trans-unit id="3c91b848d807e7b04b1ab06ec49ea4392d7ec7d3" translate="yes" xml:space="preserve">
          <source>Here's how, given a vector in &lt;code&gt;$vec&lt;/code&gt; , you can get those bits into your &lt;code&gt;@ints&lt;/code&gt; array:</source>
          <target state="translated">给定 &lt;code&gt;$vec&lt;/code&gt; 的向量，这是如何将这些位放入 &lt;code&gt;@ints&lt;/code&gt; 数组中的方法：</target>
        </trans-unit>
        <trans-unit id="05e823e1939b1a8d4b1e60b3d1cc0a6d9b92d2ab" translate="yes" xml:space="preserve">
          <source>Here's how, given a vector in &lt;code&gt;$vec&lt;/code&gt;, you can get those bits into your &lt;code&gt;@ints&lt;/code&gt; array:</source>
          <target state="translated">在给定 &lt;code&gt;$vec&lt;/code&gt; 的向量的情况下，可以通过以下方法将这些位放入 &lt;code&gt;@ints&lt;/code&gt; 数组中：</target>
        </trans-unit>
        <trans-unit id="22975b2012514ff308ba25754da36c22aeb6ce2b" translate="yes" xml:space="preserve">
          <source>Here's one strategy: If you have a fixed-size footer, you can get footers by checking $FORMAT_LINES_LEFT before each write() and print the footer yourself if necessary.</source>
          <target state="translated">这里有一个策略。如果你有一个固定大小的页脚,你可以在每次写()之前检查$FORMAT_LINES_LEFT来获取页脚,如果需要的话,你可以自己打印页脚。</target>
        </trans-unit>
        <trans-unit id="525e3062fa27a1689f30b9419dfa2b5e57815b15" translate="yes" xml:space="preserve">
          <source>Here's our &lt;code&gt;File&lt;/code&gt; class once more:</source>
          <target state="translated">这再次是我们的 &lt;code&gt;File&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="b1783e928a570b5dc6d74dafaff14364959e7e0f" translate="yes" xml:space="preserve">
          <source>Here's our &lt;code&gt;File&lt;/code&gt; class with &lt;code&gt;Class::Accessor&lt;/code&gt; :</source>
          <target state="translated">这是我们的带有 &lt;code&gt;Class::Accessor&lt;/code&gt; &lt;code&gt;File&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="327f9e2f42a9d97334b0e6c830bc13c66b0647cf" translate="yes" xml:space="preserve">
          <source>Here's our &lt;code&gt;File&lt;/code&gt; class with &lt;code&gt;Class::Accessor&lt;/code&gt;:</source>
          <target state="translated">这是我们的带有 &lt;code&gt;Class::Accessor&lt;/code&gt; &lt;code&gt;File&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="95130bd2aff1326444cc7bcdc6d685db2ff09cc5" translate="yes" xml:space="preserve">
          <source>Here's some advice: supply a creation mode of &lt;code&gt;0666&lt;/code&gt; for regular files (in &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt;) and one of &lt;code&gt;0777&lt;/code&gt; for directories (in &lt;a href=&quot;#mkdir-FILENAME%2CMODE&quot;&gt;&lt;code&gt;mkdir&lt;/code&gt;&lt;/a&gt;) and executable files. This gives users the freedom of choice: if they want protected files, they might choose process umasks of &lt;code&gt;022&lt;/code&gt;, &lt;code&gt;027&lt;/code&gt;, or even the particularly antisocial mask of &lt;code&gt;077&lt;/code&gt;. Programs should rarely if ever make policy decisions better left to the user. The exception to this is when writing files that should be kept private: mail files, web browser cookies,</source>
          <target state="translated">以下是一些建议：为常规文件（在&lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; 中&lt;/a&gt;）提供 &lt;code&gt;0666&lt;/code&gt; 的创建模式，为目录（在&lt;a href=&quot;#mkdir-FILENAME%2CMODE&quot;&gt; &lt;code&gt;mkdir&lt;/code&gt; 中&lt;/a&gt;）和可执行文件提供 &lt;code&gt;0777&lt;/code&gt; 的创建模式。这为用户提供了选择的自由：如果他们想要保护的文件，他们可能会选择的过程中使用umasks &lt;code&gt;022&lt;/code&gt; ， &lt;code&gt;027&lt;/code&gt; ，甚至反社会特别的面具 &lt;code&gt;077&lt;/code&gt; 。程序很少应该做出让用户更好地决策的决定。例外情况是在编写应保密的文件时：邮件文件，网络浏览器Cookie，</target>
        </trans-unit>
        <trans-unit id="57354b9e0e2f7e59368dea0a84947b0e2a0827cd" translate="yes" xml:space="preserve">
          <source>Here's some advice: supply a creation mode of &lt;code&gt;0666&lt;/code&gt; for regular files (in &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;) and one of &lt;code&gt;0777&lt;/code&gt; for directories (in &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt;) and executable files. This gives users the freedom of choice: if they want protected files, they might choose process umasks of &lt;code&gt;022&lt;/code&gt; , &lt;code&gt;027&lt;/code&gt; , or even the particularly antisocial mask of &lt;code&gt;077&lt;/code&gt; . Programs should rarely if ever make policy decisions better left to the user. The exception to this is when writing files that should be kept private: mail files, web browser cookies,</source>
          <target state="translated">这里是一些建议：为常规文件（在 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 中）提供 &lt;code&gt;0666&lt;/code&gt; 的创建模式，为目录（在 &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; 中）和可执行文件提供 &lt;code&gt;0777&lt;/code&gt; 的创建模式。这为用户提供了选择的自由：如果他们想要保护的文件，他们可能会选择的过程中使用umasks &lt;code&gt;022&lt;/code&gt; ， &lt;code&gt;027&lt;/code&gt; ，甚至反社会特别的面具 &lt;code&gt;077&lt;/code&gt; 。程序很少应该做出让用户更好地决策的决定。例外情况是在编写应保密的文件时：邮件文件，网络浏览器Cookie，</target>
        </trans-unit>
        <trans-unit id="e2752daa5f028f44257bc9623ea0f7f9230b9d85" translate="yes" xml:space="preserve">
          <source>Here's some advice: supply a creation mode of &lt;code&gt;0666&lt;/code&gt; for regular files (in &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;) and one of &lt;code&gt;0777&lt;/code&gt; for directories (in &lt;code&gt;&lt;a href=&quot;mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt;) and executable files. This gives users the freedom of choice: if they want protected files, they might choose process umasks of &lt;code&gt;022&lt;/code&gt; , &lt;code&gt;027&lt;/code&gt; , or even the particularly antisocial mask of &lt;code&gt;077&lt;/code&gt; . Programs should rarely if ever make policy decisions better left to the user. The exception to this is when writing files that should be kept private: mail files, web browser cookies,</source>
          <target state="translated">这里是一些建议：为常规文件（在 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 中）提供 &lt;code&gt;0666&lt;/code&gt; 的创建模式，为目录（在 &lt;code&gt;&lt;a href=&quot;mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; 中）和可执行文件提供 &lt;code&gt;0777&lt;/code&gt; 的创建模式。这为用户提供了选择的自由：如果他们想要保护的文件，他们可能会选择的过程中使用umasks &lt;code&gt;022&lt;/code&gt; ， &lt;code&gt;027&lt;/code&gt; ，甚至反社会特别的面具 &lt;code&gt;077&lt;/code&gt; 。程序很少应该做出让用户更好地决策的决定。例外情况是在编写应保密的文件时：邮件文件，网络浏览器Cookie，</target>
        </trans-unit>
        <trans-unit id="4ed39bdc449f7cf4b3c38e3ffdf7cd70fa08f940" translate="yes" xml:space="preserve">
          <source>Here's some code that finds sentences that begin with &quot;From &quot; (which would be mangled by many mailers):</source>
          <target state="translated">这里有一些代码可以找到以 &quot;From &quot;开头的句子(很多邮件会把这些句子弄乱)。</target>
        </trans-unit>
        <trans-unit id="aa42825d4fc178008e13f884fd63afc0d6bcd50d" translate="yes" xml:space="preserve">
          <source>Here's some entries from the output of the property &quot;Nv&quot;, which has format &lt;code&gt;&quot;ar&quot;&lt;/code&gt; .</source>
          <target state="translated">这是属性&amp;ldquo; Nv&amp;rdquo;的输出的一些条目，其格式为 &lt;code&gt;&quot;ar&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79efac09c122b4a103329f6db97a15af7c7c6205" translate="yes" xml:space="preserve">
          <source>Here's some entries from the output of the property &quot;Nv&quot;, which has format &lt;code&gt;&quot;ar&quot;&lt;/code&gt;.</source>
          <target state="translated">这是属性&amp;ldquo; Nv&amp;rdquo;的输出的一些条目，其格式为 &lt;code&gt;&quot;ar&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="983afceb3200f14ad7cf769e6f457a540b745124" translate="yes" xml:space="preserve">
          <source>Here's some more recommendations</source>
          <target state="translated">下面再给大家推荐一下</target>
        </trans-unit>
        <trans-unit id="425356b04c5e4659def26c3afe717def29a81e4c" translate="yes" xml:space="preserve">
          <source>Here's something Larry suggested: if a &lt;code&gt;U&lt;/code&gt; is the first active format during a &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, (for example, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; &quot;U3C8&quot;, @stuff&lt;/code&gt; ) then the resulting string should be treated as UTF-8 encoded.</source>
          <target state="translated">这是Larry建议的：如果 &lt;code&gt;U&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 期间的第一个活动格式（例如 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; &quot;U3C8&quot;, @stuff&lt;/code&gt; ），那么结果字符串应视为UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="4378597a87d2aa3b47f60334936696fad7b403c9" translate="yes" xml:space="preserve">
          <source>Here's something Larry suggested: if a &lt;code&gt;U&lt;/code&gt; is the first active format during a &lt;code&gt;pack&lt;/code&gt;, (for example, &lt;code&gt;pack &quot;U3C8&quot;, @stuff&lt;/code&gt;) then the resulting string should be treated as UTF-8 encoded.</source>
          <target state="translated">这是Larry建议的：如果 &lt;code&gt;U&lt;/code&gt; 是 &lt;code&gt;pack&lt;/code&gt; 期间的第一个活动格式（例如 &lt;code&gt;pack &quot;U3C8&quot;, @stuff&lt;/code&gt; ），则应将所得字符串视为UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="b314a6f828aa6ba79d336b2bc1f9e451bb9826c7" translate="yes" xml:space="preserve">
          <source>Here's that program; tested on v5.14.</source>
          <target state="translated">这就是那个程序;在v5.14上测试。</target>
        </trans-unit>
        <trans-unit id="ce077bf1b8dbc3882bb449e22e472c33bd6126e0" translate="yes" xml:space="preserve">
          <source>Here's the Apache configuration entry you'll need to make use of it. Once set it will result in everything in the /compressed directory will be compressed automagically.</source>
          <target state="translated">这是Apache的配置条目,你需要使用它。一旦设置,它将导致所有在/compressed目录下的东西都会被自动压缩。</target>
        </trans-unit>
        <trans-unit id="7c1fe856f88363dd186e2e7ada6054be89d9b374" translate="yes" xml:space="preserve">
          <source>Here's the answer to the problem I posed earlier, of reformatting a file of city and country names.</source>
          <target state="translated">这是我前面提出的问题的答案,即重新格式化一个城市和国家名称的文件。</target>
        </trans-unit>
        <trans-unit id="ec2064253b0b50a2575cd193f528ea54b5bba134" translate="yes" xml:space="preserve">
          <source>Here's the case of taking a reference to the same memory location again and again:</source>
          <target state="translated">这里的情况是,一次又一次地对同一个内存位置进行引用。</target>
        </trans-unit>
        <trans-unit id="a750afb60c3b3c5f05dc778fe8f81eda212eb4a1" translate="yes" xml:space="preserve">
          <source>Here's the code.</source>
          <target state="translated">这是代码。</target>
        </trans-unit>
        <trans-unit id="687ec9bc2da6b7d16d8a23c230dfb7c1307404b0" translate="yes" xml:space="preserve">
          <source>Here's the code. We'll</source>
          <target state="translated">这是代码。我们将</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">这是代码。</target>
        </trans-unit>
        <trans-unit id="faf00dc9cd5933c3e758b3e429588f852416f9ff" translate="yes" xml:space="preserve">
          <source>Here's the comprehensive list of values you can expect as</source>
          <target state="translated">以下是你可以期待的价值的全面列表,作为</target>
        </trans-unit>
        <trans-unit id="92d590121c2fc19f8a6623b373db411150058833" translate="yes" xml:space="preserve">
          <source>Here's the constructor:</source>
          <target state="translated">这是构造函数。</target>
        </trans-unit>
        <trans-unit id="67de0300ad7e657a8db469b4cb89cf11ed0c9b15" translate="yes" xml:space="preserve">
          <source>Here's the fetch for our DotFiles example.</source>
          <target state="translated">下面是我们的DotFiles例子的获取方法。</target>
        </trans-unit>
        <trans-unit id="ea37c8a435a5d1ae861daa3601c34204e044ad1a" translate="yes" xml:space="preserve">
          <source>Here's the general rule: When you approach a task commonly done using a whole range of platforms, think about writing portable code. That way, you don't sacrifice much by way of the implementation choices you can avail yourself of, and at the same time you can give your users lots of platform choices. On the other hand, when you have to take advantage of some unique feature of a particular platform, as is often the case with systems programming (whether for Unix, Windows, VMS, etc.), consider writing platform-specific code.</source>
          <target state="translated">这是一般规则。当你接近一个使用各种平台完成的任务时,要考虑编写可移植的代码。这样一来,你不会因为可以利用的实现选择而牺牲很多,同时你也可以给你的用户提供很多平台选择。另一方面,当你必须利用某个特定平台的一些独特功能时,就像系统编程中经常出现的情况一样(无论是Unix、Windows、VMS等),考虑编写特定平台的代码。</target>
        </trans-unit>
        <trans-unit id="9c681da90263d542164ba3d2f3ec45d3fa28748f" translate="yes" xml:space="preserve">
          <source>Here's the most basic test program.</source>
          <target state="translated">这是最基本的测试程序。</target>
        </trans-unit>
        <trans-unit id="b5763f4294d53b8fde1e0d145ff3e1ebda9932aa" translate="yes" xml:space="preserve">
          <source>Here's the start of</source>
          <target state="translated">这里是开始</target>
        </trans-unit>
        <trans-unit id="62dfcd0f3177b39de6db7b0fd66738d0abd59908" translate="yes" xml:space="preserve">
          <source>Here's two outputs (or 'renderings'), using the -exec and -basic (i.e. default) formatting conventions on the same code snippet.</source>
          <target state="translated">这是两个输出(或 &quot;渲染&quot;),使用-exec和-basic(即默认)格式约定在同一个代码片段上。</target>
        </trans-unit>
        <trans-unit id="b7e6198c27f03baf5a7cf4c101c7cbf2083f6919" translate="yes" xml:space="preserve">
          <source>Here's what happens: when Perl reads in a string literal, it sticks to 8 bit encoding as long as it can. (But perhaps originally it was internally encoded as UTF-8, when you dumped it.) When it has to give that up because other characters are added to the text string, it silently upgrades the string to UTF-8.</source>
          <target state="translated">事情是这样的:当Perl读入一个字符串文字时,它尽可能地坚持使用8位编码(但也许最初它的内部编码是UTF-8,当你转储它时)。(但也许最初它的内部编码是UTF-8,当你转储它的时候)。当它不得不放弃这一点时,因为其他字符被添加到文本字符串中,它就会默默地将字符串升级为 UTF-8。</target>
        </trans-unit>
        <trans-unit id="3d080817ae211b70ffb8548327b1435f255163a6" translate="yes" xml:space="preserve">
          <source>Here,</source>
          <target state="translated">Here,</target>
        </trans-unit>
        <trans-unit id="664fb069ea88b967ad1512f692644a45d6f7de10" translate="yes" xml:space="preserve">
          <source>Here, &quot;=head1 Foo&quot; and &quot;=cut&quot; are command paragraphs because the first line of each matches &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt;. &quot;</source>
          <target state="translated">这里，&amp;ldquo; = head1 Foo&amp;rdquo;和&amp;ldquo; = cut&amp;rdquo;是命令段落，因为每个的第一行都匹配 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="6e880e78238dbe97c5e8b6a05af56ed349c5a146" translate="yes" xml:space="preserve">
          <source>Here, &quot;=head1 Foo&quot; and &quot;=cut&quot; are command paragraphs because the first line of each matches &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt;. &quot;</source>
          <target state="translated">这里，&amp;ldquo; = head1 Foo&amp;rdquo;和&amp;ldquo; = cut&amp;rdquo;是命令段落，因为每个的第一行都匹配 &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt; 。 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0b2d91e5d5873ea3e50cabcf6bf495277d88e43b" translate="yes" xml:space="preserve">
          <source>Here, $subroutine is the function that the caller called (rather than the function containing the caller). Note that $subroutine may be &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; if the frame is not a subroutine call, but an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. In such a case additional elements $evaltext and &lt;code&gt;$is_require&lt;/code&gt; are set: &lt;code&gt;$is_require&lt;/code&gt; is true if the frame is created by a &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, $evaltext contains the text of the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; statement. In particular, for an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; statement, $subroutine is &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; , but $evaltext is undefined. (Note also that each &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement creates a &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame inside an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; frame.) $subroutine may also be &lt;code&gt;(unknown)&lt;/code&gt; if this particular subroutine happens to have been deleted from the symbol table. &lt;code&gt;$hasargs&lt;/code&gt; is true if a new instance of &lt;code&gt;@_&lt;/code&gt; was set up for the frame. &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; contain pragmatic hints that the caller was compiled with. &lt;code&gt;$hints&lt;/code&gt; corresponds to &lt;code&gt;$^H&lt;/code&gt; , and &lt;code&gt;$bitmask&lt;/code&gt; corresponds to &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; . The &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; values are subject to change between versions of Perl, and are not meant for external use.</source>
          <target state="translated">在这里，$ subroutine是调用者调用的函数（而不是包含调用者的函数）。请注意，如果框架不是子例程调用，而是 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，则$ subroutine可能是 &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; 。在这种情况下，将设置其他元素$ evaltext和 &lt;code&gt;$is_require&lt;/code&gt; ：如果框架是由 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句创建的，则 &lt;code&gt;$is_require&lt;/code&gt; 为true ，$ evaltext包含 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; EXPR语句的文本。特别是，对于 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; BLOCK语句，$ subroutine是 &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;），但是$ evaltext是未定义的。 （请注意，每次 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句在 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; EXPR框架内创建一个 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 框架。 &lt;code&gt;(unknown)&lt;/code&gt; 如果此子例程恰好已从符号表中删除，则$ subroutine也可能是（未知）。如果为框架设置了新的 &lt;code&gt;@_&lt;/code&gt; 实例，则 &lt;code&gt;$hasargs&lt;/code&gt; 为true 。 &lt;code&gt;$hints&lt;/code&gt; 和 &lt;code&gt;$bitmask&lt;/code&gt; 包含调用者编译时的实用提示。 &lt;code&gt;$hints&lt;/code&gt; 对应于 &lt;code&gt;$^H&lt;/code&gt; ， &lt;code&gt;$bitmask&lt;/code&gt; 对应于 &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; 。在 &lt;code&gt;$hints&lt;/code&gt; 和 &lt;code&gt;$bitmask&lt;/code&gt; 值在Perl版本之间可能会发生变化，并不表示供外部使用。</target>
        </trans-unit>
        <trans-unit id="0cf857d30373eeccb44d9f659b21b0118b696cbc" translate="yes" xml:space="preserve">
          <source>Here, $subroutine is the function that the caller called (rather than the function containing the caller). Note that $subroutine may be &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; if the frame is not a subroutine call, but an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. In such a case additional elements $evaltext and &lt;code&gt;$is_require&lt;/code&gt; are set: &lt;code&gt;$is_require&lt;/code&gt; is true if the frame is created by a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, $evaltext contains the text of the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; statement. In particular, for an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; statement, $subroutine is &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; , but $evaltext is undefined. (Note also that each &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement creates a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; frame.) $subroutine may also be &lt;code&gt;(unknown)&lt;/code&gt; if this particular subroutine happens to have been deleted from the symbol table. &lt;code&gt;$hasargs&lt;/code&gt; is true if a new instance of &lt;code&gt;@_&lt;/code&gt; was set up for the frame. &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; contain pragmatic hints that the caller was compiled with. &lt;code&gt;$hints&lt;/code&gt; corresponds to &lt;code&gt;$^H&lt;/code&gt; , and &lt;code&gt;$bitmask&lt;/code&gt; corresponds to &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; . The &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; values are subject to change between versions of Perl, and are not meant for external use.</source>
          <target state="translated">在这里，$ subroutine是调用者调用的函数（而不是包含调用者的函数）。请注意，如果框架不是子例程调用，而是 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，则$ subroutine可能是 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; 。在这种情况下，将设置其他元素$ evaltext和 &lt;code&gt;$is_require&lt;/code&gt; ：如果框架是由 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句创建的，则 &lt;code&gt;$is_require&lt;/code&gt; 为true ，$ evaltext包含 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; EXPR语句的文本。特别是，对于 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; BLOCK语句，$ subroutine是 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;），但是$ evaltext是未定义的。 （请注意，每次 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; EXPR框架内创建一个 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 框架。 &lt;code&gt;(unknown)&lt;/code&gt; 如果此子例程恰好已从符号表中删除，则$ subroutine也可能是（未知）。如果为框架设置了新的 &lt;code&gt;@_&lt;/code&gt; 实例，则 &lt;code&gt;$hasargs&lt;/code&gt; 为true 。 &lt;code&gt;$hints&lt;/code&gt; 和 &lt;code&gt;$bitmask&lt;/code&gt; 包含调用者编译时的实用提示。 &lt;code&gt;$hints&lt;/code&gt; 对应于 &lt;code&gt;$^H&lt;/code&gt; ， &lt;code&gt;$bitmask&lt;/code&gt; 对应于 &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; 。在 &lt;code&gt;$hints&lt;/code&gt; 和 &lt;code&gt;$bitmask&lt;/code&gt; 值在Perl版本之间可能会发生变化，并不表示供外部使用。</target>
        </trans-unit>
        <trans-unit id="f3735e4f7cd84efb99098edde43ca86112a7452e" translate="yes" xml:space="preserve">
          <source>Here, $subroutine is the function that the caller called (rather than the function containing the caller). Note that $subroutine may be &lt;code&gt;(eval)&lt;/code&gt; if the frame is not a subroutine call, but an &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;. In such a case additional elements $evaltext and &lt;code&gt;$is_require&lt;/code&gt; are set: &lt;code&gt;$is_require&lt;/code&gt; is true if the frame is created by a &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; statement, $evaltext contains the text of the &lt;code&gt;eval EXPR&lt;/code&gt; statement. In particular, for an &lt;code&gt;eval BLOCK&lt;/code&gt; statement, $subroutine is &lt;code&gt;(eval)&lt;/code&gt;, but $evaltext is undefined. (Note also that each &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; statement creates a &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; frame inside an &lt;code&gt;eval EXPR&lt;/code&gt; frame.) $subroutine may also be &lt;code&gt;(unknown)&lt;/code&gt; if this particular subroutine happens to have been deleted from the symbol table. &lt;code&gt;$hasargs&lt;/code&gt; is true if a new instance of &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt; was set up for the frame. &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; contain pragmatic hints that the caller was compiled with. &lt;code&gt;$hints&lt;/code&gt; corresponds to &lt;a href=&quot;perlvar#%24%5EH&quot;&gt;&lt;code&gt;$^H&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;$bitmask&lt;/code&gt; corresponds to &lt;a href=&quot;perlvar#%24%7B%5EWARNING_BITS%7D&quot;&gt;&lt;code&gt;${^WARNING_BITS}&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; values are subject to change between versions of Perl, and are not meant for external use.</source>
          <target state="translated">在这里，$ subroutine是调用者调用的函数（而不是包含调用者的函数）。请注意，如果框架不是子例程调用，而是&lt;a href=&quot;#eval-EXPR&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;，则$ subroutine可能是 &lt;code&gt;(eval)&lt;/code&gt; 。在这种情况下，将设置其他元素$ evaltext和 &lt;code&gt;$is_require&lt;/code&gt; ：如果框架是由&lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;语句创建的，则 &lt;code&gt;$is_require&lt;/code&gt; 为true ，$ evaltext包含 &lt;code&gt;eval EXPR&lt;/code&gt; 语句的文本。特别是，对于 &lt;code&gt;eval BLOCK&lt;/code&gt; 语句，$ subroutine是 &lt;code&gt;(eval)&lt;/code&gt; ，但是$ evaltext是未定义的。 （也请注意，每个&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;的语句创建一个&lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;内部的框架 &lt;code&gt;eval EXPR&lt;/code&gt; frame。）如果该子例程恰好已从符号表中删除，则$ subroutine也可能是 &lt;code&gt;(unknown)&lt;/code&gt; 。如果为框架设置了新的&lt;a href=&quot;perlvar#%40_&quot;&gt; &lt;code&gt;@_&lt;/code&gt; &lt;/a&gt;实例，则 &lt;code&gt;$hasargs&lt;/code&gt; 为true 。 &lt;code&gt;$hints&lt;/code&gt; 和 &lt;code&gt;$bitmask&lt;/code&gt; 包含调用者编译时的实用提示。 &lt;code&gt;$hints&lt;/code&gt; 对应于&lt;a href=&quot;perlvar#%24%5EH&quot;&gt; &lt;code&gt;$^H&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;$bitmask&lt;/code&gt; 对应于&lt;a href=&quot;perlvar#%24%7B%5EWARNING_BITS%7D&quot;&gt; &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; &lt;/a&gt;。在 &lt;code&gt;$hints&lt;/code&gt; 和 &lt;code&gt;$bitmask&lt;/code&gt; 值受Perl的版本之间的变化，但并不意味着外用。</target>
        </trans-unit>
        <trans-unit id="caa26f85e260be75edcd0346a364ee2896d298ec" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(?&amp;gt;[^()]+)&lt;/code&gt; breaks the degeneracy of string partitioning by gobbling up as much of the string as possible and keeping it. Then match failures fail much more quickly.</source>
          <target state="translated">在这里， &lt;code&gt;(?&amp;gt;[^()]+)&lt;/code&gt; 通过尽可能多地吞噬并保留字符串来打破字符串分区的退化性。然后，匹配失败会更快地失败。</target>
        </trans-unit>
        <trans-unit id="a1b989b57eb518dccad89ad922a4fe2c3b8290b8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;.?&lt;/code&gt; eats its maximal one character at the earliest possible position in the string, &lt;code&gt;'a'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; , leaving &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; the opportunity to match both &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;'s. Finally,</source>
          <target state="translated">在这里 &lt;code&gt;.?&lt;/code&gt; 在 &lt;code&gt;programming&lt;/code&gt; 的字符串 &lt;code&gt;'a'&lt;/code&gt; 的最早位置处吃了最大的一个字符，从而使 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; 有机会匹配两个 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 。最后，</target>
        </trans-unit>
        <trans-unit id="6940871278768e0d3843403746506dfab5014fac" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;.?&lt;/code&gt; eats its maximal one character at the earliest possible position in the string, &lt;code&gt;'a'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt;, leaving &lt;code&gt;m{1,2}&lt;/code&gt; the opportunity to match both &lt;code&gt;'m'&lt;/code&gt;'s. Finally,</source>
          <target state="translated">在这里 &lt;code&gt;.?&lt;/code&gt; 在 &lt;code&gt;programming&lt;/code&gt; 的字符串 &lt;code&gt;'a'&lt;/code&gt; 的最早位置处吃了最大的一个字符，从而使 &lt;code&gt;m{1,2}&lt;/code&gt; 有机会匹配两个 &lt;code&gt;'m'&lt;/code&gt; 。最后，</target>
        </trans-unit>
        <trans-unit id="a4a0735ee9beb6f441c46c7bd92351e785038614" translate="yes" xml:space="preserve">
          <source>Here, The earliest possible match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; is the first quantifier, so it gets to match a maximal &lt;code&gt;mm&lt;/code&gt; .</source>
          <target state="translated">这里，最早的可能的匹配是在第一 &lt;code&gt;'m'&lt;/code&gt; 中 &lt;code&gt;programming&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; 是第一个量词，因此它可以匹配最大 &lt;code&gt;mm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aadfcc9f4e36a1550c20bdeb59b13a55d871dfc7" translate="yes" xml:space="preserve">
          <source>Here, The earliest possible match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt;. &lt;code&gt;m{1,2}&lt;/code&gt; is the first quantifier, so it gets to match a maximal &lt;code&gt;mm&lt;/code&gt;.</source>
          <target state="translated">这里，最早的可能的匹配是在第一 &lt;code&gt;'m'&lt;/code&gt; 中 &lt;code&gt;programming&lt;/code&gt; 。 &lt;code&gt;m{1,2}&lt;/code&gt; 是第一个量词，因此它可以匹配最大 &lt;code&gt;mm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3716a6d294692219d3cd1801d8d99a5dbba94e08" translate="yes" xml:space="preserve">
          <source>Here, all the alternatives match at the first string position, so the first alternative is the one that matches. If some of the alternatives are truncations of the others, put the longest ones first to give them a chance to match.</source>
          <target state="translated">在这里,所有的备选方案都在第一个字符串位置匹配,所以第一个备选方案就是匹配的方案。如果有些选项是其他选项的截断,则把最长的选项放在前面,使它们有机会匹配。</target>
        </trans-unit>
        <trans-unit id="689480ae64fc1f47a0a934be3391ff1dd20b6f51" translate="yes" xml:space="preserve">
          <source>Here, code is written for all the currently linked extensions along with code for &lt;code&gt;DBI&lt;/code&gt; and &lt;code&gt;DBD::Oracle&lt;/code&gt; .</source>
          <target state="translated">在这里，将为所有当前链接的扩展编写代码，并为 &lt;code&gt;DBI&lt;/code&gt; 和 &lt;code&gt;DBD::Oracle&lt;/code&gt; 编写代码。</target>
        </trans-unit>
        <trans-unit id="7e1da21ea3d3d0f4b406cb9d4b1c545dbb154ce6" translate="yes" xml:space="preserve">
          <source>Here, code is written for all the currently linked extensions along with code for &lt;code&gt;DBI&lt;/code&gt; and &lt;code&gt;DBD::Oracle&lt;/code&gt;.</source>
          <target state="translated">在这里，将为所有当前链接的扩展编写代码，并为 &lt;code&gt;DBI&lt;/code&gt; 和 &lt;code&gt;DBD::Oracle&lt;/code&gt; 编写代码。</target>
        </trans-unit>
        <trans-unit id="6aaaa9a188728345ceda0023a2930141166a0d68" translate="yes" xml:space="preserve">
          <source>Here, the code points 0x964 and 0x965 are both used in Bengali, Devanagari, Gurmukhi, and Oriya, but no other scripts.</source>
          <target state="translated">这里,代码点0x964和0x965都用于孟加拉语、Devanagari、Gurmukhi和Oriya,但没有其他脚本。</target>
        </trans-unit>
        <trans-unit id="c6406af5e03eb4f4938f3da32dd26a4c74c548ed" translate="yes" xml:space="preserve">
          <source>Here, the regexp matches at the start of the string. The first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much as possible, leaving just a single &lt;code&gt;'m'&lt;/code&gt; for the second quantifier &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此处，正则表达式在字符串的开头匹配。第一个量词 &lt;code&gt;.*&lt;/code&gt; 尽可能地抓住，而第二个量词 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; 只留下一个 &lt;code&gt;'m'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bd5106d8c958bc219ebcb6fcaec8723192083e1" translate="yes" xml:space="preserve">
          <source>Here, the regexp matches at the start of the string. The first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much as possible, leaving just a single &lt;code&gt;'m'&lt;/code&gt; for the second quantifier &lt;code&gt;m{1,2}&lt;/code&gt;.</source>
          <target state="translated">此处，正则表达式在字符串的开头匹配。第一个量词 &lt;code&gt;.*&lt;/code&gt; 尽可能地抓住，而第二个量词 &lt;code&gt;m{1,2}&lt;/code&gt; 只留下一个 &lt;code&gt;'m'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c10eb1d2f1c36813ee26854f2e1241cc9e1fd565" translate="yes" xml:space="preserve">
          <source>Here, we use a second &lt;code&gt;open&lt;/code&gt; argument of &lt;code&gt;&quot;|-&quot;&lt;/code&gt;, signifying that the filehandle assigned to &lt;code&gt;$cat_fh&lt;/code&gt; should be a write-pipe. We can then use it just as we would a write-only ordinary filehandle, including the basic function of &lt;code&gt;print&lt;/code&gt;-ing data to it.</source>
          <target state="translated">在这里，我们使用第二个 &lt;code&gt;open&lt;/code&gt; 参数 &lt;code&gt;&quot;|-&quot;&lt;/code&gt; ，表示分配给 &lt;code&gt;$cat_fh&lt;/code&gt; 的文件句柄应该是写管道。然后，我们可以像只写普通文件句柄那样使用它，包括将数据 &lt;code&gt;print&lt;/code&gt; 到该文件句柄的基本功能。</target>
        </trans-unit>
        <trans-unit id="7d40285a9c3c8ccdbd6762112a10bef59352519d" translate="yes" xml:space="preserve">
          <source>Here, when the '$a' in the eval is being compiled, f() is not currently being executed, so its $a is not available for capture.</source>
          <target state="translated">在这里,当eval中的'$a'被编译时,f()当前并没有被执行,所以它的$a无法被捕获。</target>
        </trans-unit>
        <trans-unit id="dd7c1c3b995f345fd62ac66cfeb3e09d91946309" translate="yes" xml:space="preserve">
          <source>Here, when the '\&amp;amp;a' in the eval is being compiled, f() is not currently being executed, so its &amp;amp;a is not available for capture.</source>
          <target state="translated">在这里，当评估eval中的'\＆a'时，当前未执行f（），因此其＆a无法捕获。</target>
        </trans-unit>
        <trans-unit id="ede19d3c74e6b3a68c4bd3de5c03f1c72f2ba22c" translate="yes" xml:space="preserve">
          <source>Hex strings may only represent integers. Strings that would cause integer overflow trigger a warning. Leading whitespace is not stripped, unlike oct(). To present something as hex, look into &lt;a href=&quot;#printf&quot;&gt;printf&lt;/a&gt;, &lt;a href=&quot;#sprintf&quot;&gt;sprintf&lt;/a&gt;, and &lt;a href=&quot;#unpack&quot;&gt;unpack&lt;/a&gt;.</source>
          <target state="translated">十六进制字符串只能代表整数。可能导致整数溢出的字符串会触发警告。与oct（）不同，前导空格不会被剥离。要以十六进制形式显示内容，请查看&lt;a href=&quot;#printf&quot;&gt;printf&lt;/a&gt;，&lt;a href=&quot;#sprintf&quot;&gt;sprintf&lt;/a&gt;和&lt;a href=&quot;#unpack&quot;&gt;unpack&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4ab04b2f53a36bbb2dc5c2deb103b3c069c62c2" translate="yes" xml:space="preserve">
          <source>Hex strings may only represent integers. Strings that would cause integer overflow trigger a warning. Leading whitespace is not stripped, unlike oct(). To present something as hex, look into &lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;, &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;, and &lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;.</source>
          <target state="translated">十六进制字符串只能代表整数。可能导致整数溢出的字符串会触发警告。与oct（）不同，前导空格不会被剥离。要以十六进制形式显示内容，请查看&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;，&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;和&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f63676066d11c05b5d8b9b8be78e1e17f582eed6" translate="yes" xml:space="preserve">
          <source>Hexadecimal (prefixed with &quot;0x&quot;) and binary numbers (prefixed with &quot;0b&quot;) are accepted, too. Please note that octal numbers are not recognized by new(), so the following will print &quot;123&quot;:</source>
          <target state="translated">十六进制数(前缀为 &quot;0x&quot;)和二进制数(前缀为 &quot;0b&quot;)也被接受。请注意,new()不能识别八进制数,所以下面将打印 &quot;123&quot;。</target>
        </trans-unit>
        <trans-unit id="2486d235457d8e2812e9f4481543bdfa3dc85c5e" translate="yes" xml:space="preserve">
          <source>Hexadecimal Notation</source>
          <target state="translated">十六进制符号</target>
        </trans-unit>
        <trans-unit id="d754dce244e30fbc42722c0d0d3408fc0e8b5ff5" translate="yes" xml:space="preserve">
          <source>Hexadecimal escapes</source>
          <target state="translated">十六进制泄漏</target>
        </trans-unit>
        <trans-unit id="ceb4c2b4da9935612f806f0eaf63dea44928d37a" translate="yes" xml:space="preserve">
          <source>Hexadecimal float: exponent overflow</source>
          <target state="translated">十六进制浮点数:指数溢出。</target>
        </trans-unit>
        <trans-unit id="6787bb9bded584a1ccebdd178acfcd973639f3f7" translate="yes" xml:space="preserve">
          <source>Hexadecimal float: exponent underflow</source>
          <target state="translated">十六进制浮点数:指数下溢。</target>
        </trans-unit>
        <trans-unit id="48201f76ddff073fa44d07df4a8baaecc78c6e0e" translate="yes" xml:space="preserve">
          <source>Hexadecimal float: internal error (%s)</source>
          <target state="translated">十六进制浮点数:内部错误(%s)</target>
        </trans-unit>
        <trans-unit id="71fdf425e37a4288160c1066f4c9ea378b81d48e" translate="yes" xml:space="preserve">
          <source>Hexadecimal float: mantissa overflow</source>
          <target state="translated">十六进制浮点数:万字符溢出。</target>
        </trans-unit>
        <trans-unit id="08fee2dcc28bb2107c935539547a0cafdbf2783a" translate="yes" xml:space="preserve">
          <source>Hexadecimal float: precision loss</source>
          <target state="translated">十六进制浮点数:精度损失</target>
        </trans-unit>
        <trans-unit id="4f362cd2180b7cce0594c6133e6481cd125bcf0e" translate="yes" xml:space="preserve">
          <source>Hexadecimal float: unsupported long double format</source>
          <target state="translated">十六进制浮点数:不支持长双格式。</target>
        </trans-unit>
        <trans-unit id="0055aac53ab95723749bf6b5bb8f9b5857c75d3e" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating point can start just like a hexadecimal literal, and it can be followed by an optional fractional hexadecimal part, but it must be followed by &lt;code&gt;p&lt;/code&gt; , an optional sign, and a power of two. The format is useful for accurately presenting floating point values, avoiding conversions to or from decimal floating point, and therefore avoiding possible loss in precision. Notice that while most current platforms use the 64-bit IEEE 754 floating point, not all do. Another potential source of (low-order) differences are the floating point rounding modes, which can differ between CPUs, operating systems, and compilers, and which Perl doesn't control.</source>
          <target state="translated">十六进制浮点可以像十六进制文字一样开始，并且可以跟一个可选的分数十六进制部分，但必须跟一个 &lt;code&gt;p&lt;/code&gt; ，一个可选符号以及2的幂。该格式对于准确显示浮点值，避免转换为十进制浮点数或从十进制浮点数进行转换非常有用，因此可以避免精度损失。请注意，尽管大多数当前平台都使用64位IEEE 754浮点，但并非所有平台都使用。另一个（低阶）差异的潜在来源是浮点舍入模式，该模式在CPU，操作系统和编译器之间可能会有所不同，而Perl无法控制这种模式。</target>
        </trans-unit>
        <trans-unit id="6538253332ea41555b76df01c0a9eb4e30e75f6d" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating point can start just like a hexadecimal literal, and it can be followed by an optional fractional hexadecimal part, but it must be followed by &lt;code&gt;p&lt;/code&gt;, an optional sign, and a power of two. The format is useful for accurately presenting floating point values, avoiding conversions to or from decimal floating point, and therefore avoiding possible loss in precision. Notice that while most current platforms use the 64-bit IEEE 754 floating point, not all do. Another potential source of (low-order) differences are the floating point rounding modes, which can differ between CPUs, operating systems, and compilers, and which Perl doesn't control.</source>
          <target state="translated">十六进制浮点可以像十六进制文字一样开始，并且可以跟一个可选的分数十六进制部分，但是必须跟一个 &lt;code&gt;p&lt;/code&gt; ，一个可选符号以及2的幂。该格式对于准确显示浮点值，避免转换为十进制浮点数或从十进制浮点数转换为有用，因此可以避免精度损失。请注意，尽管当前大多数平台都使用64位IEEE 754浮点，但并非所有平台都使用。另一个（低阶）差异的潜在来源是浮点舍入模式，该模式在CPU，操作系统和编译器之间可能会有所不同，而Perl无法控制这种模式。</target>
        </trans-unit>
        <trans-unit id="8905655ccfc1958b445b80fef0232ecf74e57bc8" translate="yes" xml:space="preserve">
          <source>Hexadecimal number &amp;gt; 0xffffffff non-portable</source>
          <target state="translated">十六进制数&amp;gt; 0xffffffff（不可移植）</target>
        </trans-unit>
        <trans-unit id="c5f839007ffa6c33e78ea32b2edbfe75db988fef" translate="yes" xml:space="preserve">
          <source>Hexadecimal, octal, or binary, representations in string literals (e.g. '0xff') are not automatically converted to their integer representation. The hex() and oct() functions make these conversions for you. See &lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt; and &lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt; for more details.</source>
          <target state="translated">字符串文字中的十六进制，八进制或二进制表示（例如&amp;ldquo; 0xff&amp;rdquo;）不会自动转换为整数表示。hex（）和oct（）函数为您进行了这些转换。有关更多详细信息，请参见&lt;a href=&quot;functions/hex&quot;&gt;十六进制&lt;/a&gt;和&lt;a href=&quot;functions/oct&quot;&gt;十进制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="394f3535ef6619d95b226f10b0fb91749452cd92" translate="yes" xml:space="preserve">
          <source>Hexadecimal, octal, or binary, representations in string literals (e.g. '0xff') are not automatically converted to their integer representation. The hex() and oct() functions make these conversions for you. See &lt;a href=&quot;perlfunc#hex&quot;&gt;&quot;hex&quot; in perlfunc&lt;/a&gt; and &lt;a href=&quot;perlfunc#oct&quot;&gt;&quot;oct&quot; in perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">字符串文字中的十六进制，八进制或二进制表示（例如&amp;ldquo; 0xff&amp;rdquo;）不会自动转换为整数表示。hex（）和oct（）函数为您进行了这些转换。见&lt;a href=&quot;perlfunc#hex&quot;&gt;在perlfunc&amp;ldquo;十六进制&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;perlfunc#oct&quot;&gt;&amp;ldquo;十月&amp;rdquo;在perlfunc&lt;/a&gt;更多细节。</target>
        </trans-unit>
        <trans-unit id="af0d47fb48d369e779ea66f99b77ac3ba09d56e3" translate="yes" xml:space="preserve">
          <source>Hey, isn't Perl supposed to make this sort of thing easy? Well, it does, if you use the right tools. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; are designed to help you out when dealing with fixed-width data like the above. Let's have a look at a solution with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">嘿，不是应该让Perl简化这种事情吗？好的，如果您使用正确的工具，那就可以了。 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 旨在帮助您处理上述固定宽度的数据。让我们看一下 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 的解决方案：</target>
        </trans-unit>
        <trans-unit id="07a002a323d2c31a9141607bc892ee1574aeebbd" translate="yes" xml:space="preserve">
          <source>Hey, isn't Perl supposed to make this sort of thing easy? Well, it does, if you use the right tools. &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; are designed to help you out when dealing with fixed-width data like the above. Let's have a look at a solution with &lt;code&gt;unpack&lt;/code&gt;:</source>
          <target state="translated">嘿，不是应该让Perl简化这种事情吗？好的，如果您使用正确的工具，那就可以了。 &lt;code&gt;pack&lt;/code&gt; 和 &lt;code&gt;unpack&lt;/code&gt; 旨在帮助您处理上述固定宽度的数据。让我们看一下 &lt;code&gt;unpack&lt;/code&gt; 的解决方案：</target>
        </trans-unit>
        <trans-unit id="38419124bd7b06ea4fc82f2ec5707cd4239617e6" translate="yes" xml:space="preserve">
          <source>Hiding Perl_</source>
          <target state="translated">隱藏Perl_</target>
        </trans-unit>
        <trans-unit id="1428b1718a9c369e65d9d918143e0a1d8ca542e9" translate="yes" xml:space="preserve">
          <source>Hiding or invalidating some other definition of the same name. (Not to be confused with &lt;b&gt;overloading&lt;/b&gt;, which adds definitions that must be disambiguated some other way.) To confuse the issue further, we use the word with two overloaded definitions: to describe how you can define your own &lt;b&gt;subroutine&lt;/b&gt; to hide a built-in &lt;b&gt;function&lt;/b&gt; of the same name (see the section &amp;ldquo;Overriding Built-in Functions&amp;rdquo; in Camel chapter 11, &amp;ldquo;Modules&amp;rdquo;), and to describe how you can define a replacement &lt;b&gt;method&lt;/b&gt; in a &lt;b&gt;derived class&lt;/b&gt; to hide a &lt;b&gt;base class&lt;/b&gt;&amp;rsquo;s method of the same name (see Camel chapter 12, &amp;ldquo;Objects&amp;rdquo;).</source>
          <target state="translated">隐藏或使其他相同名称的定义无效。（不要与&lt;b&gt;重载&lt;/b&gt;相混淆，&lt;b&gt;重载&lt;/b&gt;会增加必须以其他方式消除歧义的定义。）为了进一步混淆这个问题，我们使用带有两个重载定义的单词：描述如何定义自己的&lt;b&gt;子例程&lt;/b&gt;来隐藏内置函数。&lt;b&gt;具有&lt;/b&gt;相同名称的&lt;b&gt;函数&lt;/b&gt;（请参见Camel第11章&amp;ldquo;模块&amp;rdquo;中的&amp;ldquo;覆盖内置函数&amp;rdquo;一节），并描述如何在&lt;b&gt;派生类中&lt;/b&gt;定义替换&lt;b&gt;方法&lt;/b&gt;以隐藏&lt;b&gt;基类&lt;/b&gt;的方法。名称相同（请参见骆驼第12章，&amp;ldquo;对象&amp;rdquo;）。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c470287cb379da96c293a62fb8664cf2247d2b55" translate="yes" xml:space="preserve">
          <source>High Level</source>
          <target state="translated">高级别</target>
        </trans-unit>
        <trans-unit id="ad6c175822059b79229ebfc786ac972d1cc9dd61" translate="yes" xml:space="preserve">
          <source>High resolution alarm, sleep, gettimeofday, interval timers</source>
          <target state="translated">高分辨率闹钟、睡眠、gettimeofday、间隔定时器</target>
        </trans-unit>
        <trans-unit id="06ec56d2d4a59020901e32260159cfaa9fcc9ac8" translate="yes" xml:space="preserve">
          <source>High-level commands do such initializations automatically.</source>
          <target state="translated">高层命令会自动进行这种初始化。</target>
        </trans-unit>
        <trans-unit id="e29ea1646e3ae3268842b4efea0250df490ad525" translate="yes" xml:space="preserve">
          <source>Higher-Order Perl</source>
          <target state="translated">高阶Perl</target>
        </trans-unit>
        <trans-unit id="2f40e6c9a09885ca0cf7997c2375c0fe1fb31d9f" translate="yes" xml:space="preserve">
          <source>Hint: The &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; tutorial covers the T_INOUT, T_IN, and T_OUT XS types nicely.</source>
          <target state="translated">提示：&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;教程很好地介绍了T_INOUT，T_IN和T_OUT XS类型。</target>
        </trans-unit>
        <trans-unit id="e3d4d7c7e48bee9d90099bb119b39917c09def77" translate="yes" xml:space="preserve">
          <source>Hint: sometimes appending &lt;code&gt;&quot;, stopped&quot;&lt;/code&gt; to your message will cause it to make better sense when the string &lt;code&gt;&quot;at foo line 123&quot;&lt;/code&gt; is appended. Suppose you are running script &quot;canasta&quot;.</source>
          <target state="translated">提示：有时在消息中附加 &lt;code&gt;&quot;, stopped&quot;&lt;/code&gt; 会在附加字符串 &lt;code&gt;&quot;at foo line 123&quot;&lt;/code&gt; 时更有意义。假设您正在运行脚本&amp;ldquo; canasta&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="eef8e89aeb708a408921fec1b9e87c4d04faaced" translate="yes" xml:space="preserve">
          <source>Hints</source>
          <target state="translated">Hints</target>
        </trans-unit>
        <trans-unit id="4d29825148796b94b3706b9469ee384bc5c32604" translate="yes" xml:space="preserve">
          <source>Hints can be provided for both scalar and list contexts. Note that an autodying subroutine will never see a void context, as &lt;code&gt;autodie&lt;/code&gt; always needs to capture the return value for examination. Autodying subroutines called in void context act as if they're called in a scalar context, but their return value is discarded after it has been checked.</source>
          <target state="translated">可以为标量和列表上下文提供提示。请注意，自动打印子例程永远不会看到void上下文，因为自动 &lt;code&gt;autodie&lt;/code&gt; 始终需要捕获返回值以进行检查。在void上下文中调用的autodying子例程的行为就像在标量上下文中被调用一样，但是它们的返回值在检查后将被丢弃。</target>
        </trans-unit>
        <trans-unit id="2e7ad51592f12093f07f504091e6b4574d36b5ff" translate="yes" xml:space="preserve">
          <source>Hints for Writing Pod</source>
          <target state="translated">撰写播客的提示</target>
        </trans-unit>
        <trans-unit id="b645eb28e32b28c0363e14b822198d8bf042449d" translate="yes" xml:space="preserve">
          <source>Hints may consist of subroutine references, objects overloading smart-match, regular expressions, and depending on Perl version possibly other things. You can specify different hints for how failure should be identified in scalar and list contexts.</source>
          <target state="translated">提示可以由子程序引用、重载smart-match的对象、正则表达式组成,根据Perl版本的不同,可能还有其他的东西。你可以指定不同的提示,说明在标量和列表上下文中如何识别失败。</target>
        </trans-unit>
        <trans-unit id="cd94510567b2e65da4d128c15c97d4b8bf6c814e" translate="yes" xml:space="preserve">
          <source>Hintsfile support</source>
          <target state="translated">支持Hints文件</target>
        </trans-unit>
        <trans-unit id="57ec96f40e52a96bf96bf4e1bcab6928fd860e76" translate="yes" xml:space="preserve">
          <source>Historical note: A few older Pod processors would not see a &quot;&amp;gt;&quot; as closing a &quot;C&amp;lt;&quot; code, if the &quot;&amp;gt;&quot; was immediately preceded by a &quot;-&quot;. This was so that this:</source>
          <target state="translated">历史记录：如果&amp;ldquo;&amp;gt;&amp;rdquo;前面紧跟一个&amp;ldquo;-&amp;rdquo;，则一些较旧的Pod处理器不会在关闭&amp;ldquo; C &amp;lt;&amp;rdquo;代码时看到&amp;ldquo;&amp;gt;&amp;rdquo;。这样做是这样的：</target>
        </trans-unit>
        <trans-unit id="456da061b07638f2efc60c23c53fa3c2c51535e7" translate="yes" xml:space="preserve">
          <source>Historical notes: 'die' used to be the default value of &lt;code&gt;$huge&lt;/code&gt; . Now, 'wrap' is the default value.</source>
          <target state="translated">历史记录：'die'曾经是 &lt;code&gt;$huge&lt;/code&gt; 的默认值。现在，&amp;ldquo; wrap&amp;rdquo;是默认值。</target>
        </trans-unit>
        <trans-unit id="19ea8843c58830508eaf140dfecf76c53f9de3a3" translate="yes" xml:space="preserve">
          <source>Historical notes: 'die' used to be the default value of &lt;code&gt;$huge&lt;/code&gt;. Now, 'wrap' is the default value.</source>
          <target state="translated">历史记录：'die'曾经是 &lt;code&gt;$huge&lt;/code&gt; 的默认值。现在，&amp;ldquo; wrap&amp;rdquo;是默认值。</target>
        </trans-unit>
        <trans-unit id="3e800c8fc87d99008c1563976a3e7822cfaf0d87" translate="yes" xml:space="preserve">
          <source>Historically Perl has been a refcounted language. This means that each variable tracks how many things reference it, and when the variable is no longer referenced it will automatically free itself. In theory Perl code should not have to care about this, and in a future version Perl might change to some other strategy, although in practice this is unlikely.</source>
          <target state="translated">历史上Perl是一种refcounted语言。这意味着每个变量都会跟踪有多少东西引用它,当变量不再被引用时,它将自动释放自己。理论上Perl代码不应该关心这个问题,在未来的版本中,Perl可能会改用其他策略,不过实际上不太可能。</target>
        </trans-unit>
        <trans-unit id="0b09a13158d2d1c843704dc0085426732de965d7" translate="yes" xml:space="preserve">
          <source>Historically Perl has varied in whether sorting is stable by default. If stability matters, it can be controlled explicitly by using the &lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; pragma.</source>
          <target state="translated">从历史上看，Perl在默认情况下排序是否稳定方面有所不同。如果稳定性很重要，则可以使用&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; pragma对其进行显式控制。</target>
        </trans-unit>
        <trans-unit id="a4bea0d3c8dc12ea86900e60a2460f211b081d43" translate="yes" xml:space="preserve">
          <source>Historically, any software that you give away, particularly if you make the source code available as well. Now often called &lt;b&gt;open source software&lt;/b&gt;. Recently there has been a trend to use the term in contradistinction to &lt;b&gt;open source software&lt;/b&gt;, to refer only to free software released under the Free Software Foundation&amp;rsquo;s GPL (General Public License), but this is difficult to justify etymologically.</source>
          <target state="translated">从历史上看，您赠送的任何软件，尤其是在您也提供源代码的情况下。现在经常被称为&lt;b&gt;开源软件&lt;/b&gt;。最近，有一种趋势是使用矛盾的术语来表示&lt;b&gt;开源软件&lt;/b&gt;，仅指在自由软件基金会的GPL（通用公共许可）下发布的自由软件，但这在词源上很难证明。</target>
        </trans-unit>
        <trans-unit id="97391b474b93a4ff5ad2004bc1c3d103a9fb4d4e" translate="yes" xml:space="preserve">
          <source>Historically, only the pumpking cherry-picked changes from bleadperl into maintperl. This has scaling problems. At the same time, maintenance branches of stable versions of Perl need to be treated with great care. To that end, as of Perl 5.12, we have a new process for maint branches.</source>
          <target state="translated">历史上,只有南瓜挑剔的从bleadperl改成maintperl。这存在着扩展问题。同时,Perl稳定版本的维护分支需要非常谨慎地对待。为此,从Perl 5.12开始,我们对maint分支进行了新的处理。</target>
        </trans-unit>
        <trans-unit id="a70077bc9082a3c8ea160dc01f918a3a65a6e212" translate="yes" xml:space="preserve">
          <source>Historically, these would be generated by the &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; tool, part of the standard perl distribution. This program converts &lt;code&gt;cpp(1)&lt;/code&gt; directives in C header files to files containing subroutine definitions, like &lt;code&gt;SYS_getitimer()&lt;/code&gt; , which you can use as arguments to your functions. It doesn't work perfectly, but it usually gets most of the job done. Simple files like</source>
          <target state="translated">从历史上看，这些将由&lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt;工具生成，它是标准perl发行版的一部分。该程序将C头文件中的 &lt;code&gt;cpp(1)&lt;/code&gt; 指令转换为包含子例程定义的文件，例如 &lt;code&gt;SYS_getitimer()&lt;/code&gt; ，您可以将其用作函数的参数。它不能完美运行，但通常可以完成大部分工作。像这样的简单文件</target>
        </trans-unit>
        <trans-unit id="63c14478e9043824d23cc2298dab27f2d02eeb16" translate="yes" xml:space="preserve">
          <source>Historically, these would be generated by the &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; tool, part of the standard perl distribution. This program converts &lt;code&gt;cpp(1)&lt;/code&gt; directives in C header files to files containing subroutine definitions, like &lt;code&gt;SYS_getitimer()&lt;/code&gt;, which you can use as arguments to your functions. It doesn't work perfectly, but it usually gets most of the job done. Simple files like</source>
          <target state="translated">从历史上看，这些将由&lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt;工具生成，它是标准perl发行版的一部分。该程序将C头文件中的 &lt;code&gt;cpp(1)&lt;/code&gt; 指令转换为包含子例程定义的文件，例如 &lt;code&gt;SYS_getitimer()&lt;/code&gt; ，您可以将其用作函数的参数。它不能完美运行，但是通常可以完成大部分工作。像这样的简单文件</target>
        </trans-unit>
        <trans-unit id="723525aec4e05b078bfa1f7212775fddba5a19b2" translate="yes" xml:space="preserve">
          <source>Historically, we've held ourselves to a far higher standard than backward-compatibility -- bugward-compatibility. Any accident of implementation or unintentional side-effect of running some bit of code has been considered to be a feature of the language to be defended with the same zeal as any other feature or functionality. No matter how frustrating these unintentional features may be to us as we continue to improve Perl, these unintentional features often deserve our protection. It is very important that existing software written in Perl continue to work correctly. If end-user developers have adopted a bug as a feature, we need to treat it as such.</source>
          <target state="translated">从历史上看,我们对自己的要求比向后兼容的标准要高得多--向错误兼容。任何实现上的意外或运行某些代码时的无意副作用,都被认为是语言的一个特性,需要像维护其他特性或功能一样热情地维护。无论在我们继续改进Perl的过程中,这些无意的功能可能会让我们感到多么沮丧,这些无意的功能往往值得我们保护。现有的用Perl编写的软件能够继续正确地工作是非常重要的。如果终端用户开发者把一个错误当作一个特性,我们需要把它当作一个特性来对待。</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="2e6d74e94851d72f49d2c6b59183be96d60c8e34" translate="yes" xml:space="preserve">
          <source>History and Background</source>
          <target state="translated">历史和背景</target>
        </trans-unit>
        <trans-unit id="ace535b09698d3ae2888504e132d0829ba6b4d7d" translate="yes" xml:space="preserve">
          <source>History of CPAN Meta Spec changes</source>
          <target state="translated">CPAN元规格变化的历史</target>
        </trans-unit>
        <trans-unit id="3e8e120f18fdbffd8b9be5d8fa532f5e8e03fa02" translate="yes" xml:space="preserve">
          <source>History of Middle Earth</source>
          <target state="translated">中土史</target>
        </trans-unit>
        <trans-unit id="9d34c3581dd43beee5ddd060d0bab25f439fd94b" translate="yes" xml:space="preserve">
          <source>History of WinCE port</source>
          <target state="translated">WinCE端口的历史</target>
        </trans-unit>
        <trans-unit id="e73e3de4102afafe13d5b9177c279b777279e4aa" translate="yes" xml:space="preserve">
          <source>Hmm. What happened here? If you've been following along, you know that the above pattern should be effectively (almost) the same as the last one; enclosing the &lt;code&gt;'d'&lt;/code&gt; in a character class isn't going to change what it matches. So why does the first not print while the second one does?</source>
          <target state="translated">唔。这里发生了什么？如果您一直在遵循，那么您就会知道上述模式实际上（几乎）应该与最后一种模式相同；将 &lt;code&gt;'d'&lt;/code&gt; 括在字符类中不会改变它匹配的内容。那么为什么第一个不打印而第二个不打印呢？</target>
        </trans-unit>
        <trans-unit id="9733ac081a67789bdb91140dbb2aaf4de5c5ec7b" translate="yes" xml:space="preserve">
          <source>Hmm. What happened here? If you've been following along, you know that the above pattern should be effectively (almost) the same as the last one; enclosing the &lt;code&gt;d&lt;/code&gt; in a character class isn't going to change what it matches. So why does the first not print while the second one does?</source>
          <target state="translated">嗯 这里发生了什么？如果您一直在遵循，那么您就会知道上述模式实际上（几乎）应该与最后一种模式相同；将 &lt;code&gt;d&lt;/code&gt; 括在字符类中不会改变其匹配项。那么为什么第一个不打印而第二个不打印呢？</target>
        </trans-unit>
        <trans-unit id="821ac8e428a38ddcf25e2027bc128ec6e743a489" translate="yes" xml:space="preserve">
          <source>Hmm... that's still a bit ugly. How about this:</source>
          <target state="translated">嗯......还是有点难看。那这个呢?</target>
        </trans-unit>
        <trans-unit id="511721548acc73e7ad2a7122ec29970e3c6188d3" translate="yes" xml:space="preserve">
          <source>Holds information on the longest string that must occur at a fixed offset from the start of the pattern, and the longest string that must occur at a floating offset from the start of the pattern. Used to do Fast-Boyer-Moore searches on the string to find out if its worth using the regex engine at all, and if so where in the string to search.</source>
          <target state="translated">保存从模式开始的固定偏移处出现的最长字符串和从模式开始的浮动偏移处出现的最长字符串的信息。用于对字符串进行Fast-Boyer-Moore搜索,以确定是否值得使用regex引擎,如果值得,则在字符串的哪个位置进行搜索。</target>
        </trans-unit>
        <trans-unit id="959988c98232c3eb8b17616f91948b459e04946f" translate="yes" xml:space="preserve">
          <source>Holds some explanation in the case of an error.</source>
          <target state="translated">在错误的情况下,持有一些解释。</target>
        </trans-unit>
        <trans-unit id="01443708f436be923f0aee8880549437dad1a448" translate="yes" xml:space="preserve">
          <source>Holds the last reported error. Kept for historical reasons, but its use is very much discouraged. Use the &lt;code&gt;error()&lt;/code&gt; method instead:</source>
          <target state="translated">保存上一次报告的错误。由于历史原因而保留，但不鼓励使用。请改用 &lt;code&gt;error()&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="c95db6ed76758307edcf864f1a4ab2acb112562d" translate="yes" xml:space="preserve">
          <source>Holds the output of the &lt;code&gt;date&lt;/code&gt; command when the configuration file was produced. This is used to tag both</source>
          <target state="translated">保留配置文件生成时 &lt;code&gt;date&lt;/code&gt; 命令的输出。这用于标记两个</target>
        </trans-unit>
        <trans-unit id="739c29f4f6f84e7a7eaff9a32fa3671bc3d08941" translate="yes" xml:space="preserve">
          <source>Holds the private path used by Configure to find out the libraries. Its value is prepend to libpth. This variable takes care of special machines, like the mips. Usually, it should be empty.</source>
          <target state="translated">保存Configure用来查找库的私有路径。它的值是libpth的前缀。这个变量用于处理特殊的机器,比如mips。通常情况下,它应该是空的。</target>
        </trans-unit>
        <trans-unit id="582b824400c82cf0f40f9f7c604827d48ea750f5" translate="yes" xml:space="preserve">
          <source>Holds the standard error of the executed command (or empty string if there was no STDERR output or if &lt;code&gt;discard_output&lt;/code&gt; was used; it's always defined!)</source>
          <target state="translated">保留已执行命令的标准错误（如果没有STDERR输出或使用 &lt;code&gt;discard_output&lt;/code&gt; ,则为空字符串；始终已定义！）</target>
        </trans-unit>
        <trans-unit id="7c3e4c3ddb7125c1c1e75cedd0d2a9c28f53291d" translate="yes" xml:space="preserve">
          <source>Holds the standard output and error of the executed command merged into one stream (or empty string if there was no output at all or if &lt;code&gt;discard_output&lt;/code&gt; was used; it's always defined!)</source>
          <target state="translated">保留合并到一个流中的标准输出和已执行命令的错误（如果根本没有输出或使用了 &lt;code&gt;discard_output&lt;/code&gt; 空字符串；始终已定义！）</target>
        </trans-unit>
        <trans-unit id="5f9c8ab4b280eb2c610d191400d239df37776272" translate="yes" xml:space="preserve">
          <source>Holds the standard output of the executed command (or empty string if there was no STDOUT output or if &lt;code&gt;discard_output&lt;/code&gt; was used; it's always defined!)</source>
          <target state="translated">保留已执行命令的标准输出（如果没有STDOUT输出或使用了 &lt;code&gt;discard_output&lt;/code&gt; 空字符串；始终已定义！）</target>
        </trans-unit>
        <trans-unit id="1f43fffdbf7b0c05af0b8fc8fcc67b1c8be39947" translate="yes" xml:space="preserve">
          <source>Home page for ISO 15924.</source>
          <target state="translated">ISO 15924的主页。</target>
        </trans-unit>
        <trans-unit id="1ba2fa3de9992cda18c006a91b37960fee16b9e0" translate="yes" xml:space="preserve">
          <source>Hook manipulation</source>
          <target state="translated">钩子操作</target>
        </trans-unit>
        <trans-unit id="5027e8d0e915f65d00ad88208e35669396121f09" translate="yes" xml:space="preserve">
          <source>Hook stack for managing scopes via %^H</source>
          <target state="translated">通过%^H管理作用域的钩子堆栈。</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="4b09a3b7ef7178d5866c8b4122a3b1b80e280cb2" translate="yes" xml:space="preserve">
          <source>Hopefully the contents of each of the filters should be self-explanatory. Both &quot;fetch&quot; filters remove the terminating NULL, and both &quot;store&quot; filters add a terminating NULL.</source>
          <target state="translated">希望每个过滤器的内容应该是不言自明的。两个 &quot;fetch &quot;过滤器都删除了终止的NULL,两个 &quot;store &quot;过滤器都增加了终止的NULL。</target>
        </trans-unit>
        <trans-unit id="1a684169a4210a05fab1617879fe368df08034f1" translate="yes" xml:space="preserve">
          <source>HostName</source>
          <target state="translated">HostName</target>
        </trans-unit>
        <trans-unit id="5a0c43672840e7d1029ec4aa340b54209da75c4a" translate="yes" xml:space="preserve">
          <source>Hostname and service name for the local address to &lt;code&gt;bind()&lt;/code&gt; to.</source>
          <target state="translated">本地地址要 &lt;code&gt;bind()&lt;/code&gt; 主机名和服务名。</target>
        </trans-unit>
        <trans-unit id="3159cb6d83d75fcd994ddd9e9c2b1dcf0d071ae6" translate="yes" xml:space="preserve">
          <source>Hostname and service name for the peer to &lt;code&gt;connect()&lt;/code&gt; to. The service name may be given as a port number, as a decimal string.</source>
          <target state="translated">要 &lt;code&gt;connect()&lt;/code&gt; 到的对等方的主机名和服务名。服务名称可以以端口号或十进制字符串的形式给出。</target>
        </trans-unit>
        <trans-unit id="0c81abc87bdc5538df96766fcae6d44438449d0a" translate="yes" xml:space="preserve">
          <source>How</source>
          <target state="translated">How</target>
        </trans-unit>
        <trans-unit id="b28755c4371822ab05bbd3edfbd84f8ae5c44516" translate="yes" xml:space="preserve">
          <source>How Do I Convert Binary Data Into a Particular Encoding, Or Vice Versa?</source>
          <target state="translated">我如何将二进制数据转换为特定的编码,或者反之亦然?</target>
        </trans-unit>
        <trans-unit id="5ec153ad02980479ddc59f23ab37e27027e62588" translate="yes" xml:space="preserve">
          <source>How Do I Detect Data That's Not Valid In a Particular Encoding?</source>
          <target state="translated">我如何检测在特定编码中无效的数据?</target>
        </trans-unit>
        <trans-unit id="83daa5c8b58e95efd16e89c69000aaf2de146549" translate="yes" xml:space="preserve">
          <source>How Do I Display Unicode? How Do I Input Unicode?</source>
          <target state="translated">我如何显示Unicode?我如何输入Unicode?</target>
        </trans-unit>
        <trans-unit id="eed7b35ef6f59f0cb6c635063802f8b69563cf7e" translate="yes" xml:space="preserve">
          <source>How Do I Find Out What Encoding a File Has?</source>
          <target state="translated">我如何找出一个文件的编码?</target>
        </trans-unit>
        <trans-unit id="87e4752c70fc96666a27cf0847bc95f48c8b5c9c" translate="yes" xml:space="preserve">
          <source>How Do I Know Whether My String Is In Unicode?</source>
          <target state="translated">我如何知道我的字符串是否使用Unicode?</target>
        </trans-unit>
        <trans-unit id="9a4dab32f52f3d5fb8384770ca50058013424c08" translate="yes" xml:space="preserve">
          <source>How Do I Make My Scripts Work With Unicode?</source>
          <target state="translated">我如何使我的脚本与Unicode一起工作?</target>
        </trans-unit>
        <trans-unit id="aa967413382158f18536864c2c5f2d495ed0e167" translate="yes" xml:space="preserve">
          <source>How Does Unicode Work With Traditional Locales?</source>
          <target state="translated">統一碼如何與傳統地區配合?</target>
        </trans-unit>
        <trans-unit id="ed7d6cb8e007f613e72e9f2c9f88a4738718ec79" translate="yes" xml:space="preserve">
          <source>How Lexical Warnings interact with &lt;b&gt;-w&lt;/b&gt;/&lt;code&gt;$^W&lt;/code&gt; :</source>
          <target state="translated">词汇警告如何与&lt;b&gt;-w&lt;/b&gt; / &lt;code&gt;$^W&lt;/code&gt; 交互：</target>
        </trans-unit>
        <trans-unit id="0ba774a79f5bdd71460b672473718c53cdc18568" translate="yes" xml:space="preserve">
          <source>How Lexical Warnings interact with &lt;b&gt;-w&lt;/b&gt;/&lt;code&gt;$^W&lt;/code&gt;:</source>
          <target state="translated">词汇警告如何与&lt;b&gt;-w&lt;/b&gt; / &lt;code&gt;$^W&lt;/code&gt; 交互：</target>
        </trans-unit>
        <trans-unit id="d1d502798bd5bd5bfc80ae2ff245f8510eaa3465" translate="yes" xml:space="preserve">
          <source>How Perl Chooses an Operator Implementation</source>
          <target state="translated">Perl如何选择操作符实现</target>
        </trans-unit>
        <trans-unit id="9d0dbe99bf0e202fd46e73a61d85e7d37d314d99" translate="yes" xml:space="preserve">
          <source>How PerlIO_apply_layera fits in, where its docs, was it made public?</source>
          <target state="translated">PerlIO_apply_layera如何配合,它的docs在哪里,是公开的吗?</target>
        </trans-unit>
        <trans-unit id="c8ce23a97419be4cb95d062b610a07bbe22ce84e" translate="yes" xml:space="preserve">
          <source>How Plugins work?</source>
          <target state="translated">插件如何工作?</target>
        </trans-unit>
        <trans-unit id="d5c739c2b8daeba650fc90008192e941caa8ca99" translate="yes" xml:space="preserve">
          <source>How SUPER is Resolved</source>
          <target state="translated">SUPER是如何解决的</target>
        </trans-unit>
        <trans-unit id="30ea041c36c78a4bf2e3a15655945d87e8d2b703" translate="yes" xml:space="preserve">
          <source>How To Write A Makefile.PL</source>
          <target state="translated">如何编写Makefile.PL</target>
        </trans-unit>
        <trans-unit id="4a252fc6f68b2a5fddacedeb60aa9691abebcc2a" translate="yes" xml:space="preserve">
          <source>How a piece of code actually goes about doing its job. Users of the code should not count on implementation details staying the same unless they are part of the published &lt;b&gt;interface&lt;/b&gt;.</source>
          <target state="translated">一段代码实际上是如何完成其​​工作的。代码的用户不应指望实现细节保持不变，除非它们是已发布&lt;b&gt;接口的&lt;/b&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="e2e38e1473acd589790c55670049e3a998855b25" translate="yes" xml:space="preserve">
          <source>How are you supposed to know what flavour of Make a Makefile has been generated for if you didn't specify a value explicitly? Search the generated Makefile for the definition of the MAKE variable, which is used to recursively invoke the Make utility. That will tell you what Make you're supposed to invoke the Makefile with.</source>
          <target state="translated">如果你没有明确地指定一个值,你怎么知道生成的Makefile是什么类型的?在生成的 Makefile 中搜索 MAKE 变量的定义,它是用来递归调用 Make 工具的。这将告诉你应该用什么Make来调用Makefile。</target>
        </trans-unit>
        <trans-unit id="411ad64f6dc4be13b3049742bd05bd21505c6bc7" translate="yes" xml:space="preserve">
          <source>How big is it?</source>
          <target state="translated">它有多大?</target>
        </trans-unit>
        <trans-unit id="27c74f66aeb35e0636195d822a7e3464616e6fc2" translate="yes" xml:space="preserve">
          <source>How can I access a dynamic variable while a similarly named lexical is in scope?</source>
          <target state="translated">当一个类似名称的词库在作用域内时,我如何访问一个动态变量?</target>
        </trans-unit>
        <trans-unit id="a4335b4f09781554b24ada06ac33e99c54ce3d7c" translate="yes" xml:space="preserve">
          <source>How can I access or change N characters of a string?</source>
          <target state="translated">如何访问或更改一个字符串的N个字符?</target>
        </trans-unit>
        <trans-unit id="5371ca66bd4ba8690a33a1384214275dda640111" translate="yes" xml:space="preserve">
          <source>How can I always keep my hash sorted?</source>
          <target state="translated">如何才能始终保持我的哈希分类?</target>
        </trans-unit>
        <trans-unit id="8584960f36ac9f047e34a3eda935743347b5f7f6" translate="yes" xml:space="preserve">
          <source>How can I call backticks without shell processing?</source>
          <target state="translated">如何在没有壳处理的情况下调用回拨?</target>
        </trans-unit>
        <trans-unit id="cd430257f97dbf507a96e7339aa72325a34a2ee9" translate="yes" xml:space="preserve">
          <source>How can I call my system's unique C functions from Perl?</source>
          <target state="translated">如何从Perl中调用系统特有的C函数?</target>
        </trans-unit>
        <trans-unit id="90f43bbd8d5db22db1ec788113816dce3fba1fdc" translate="yes" xml:space="preserve">
          <source>How can I capture STDERR from an external command?</source>
          <target state="translated">如何从外部命令中捕获STDERR?</target>
        </trans-unit>
        <trans-unit id="84907121b70e047be5c9daea9434199430d20e18" translate="yes" xml:space="preserve">
          <source>How can I catch accesses to undefined variables, functions, or methods?</source>
          <target state="translated">如何捕捉对未定义变量、函数或方法的访问?</target>
        </trans-unit>
        <trans-unit id="c73810cc9a224a5b0753f3ce02b7769672b7dc50" translate="yes" xml:space="preserve">
          <source>How can I change the permissions of a file on a remote server ?</source>
          <target state="translated">如何更改远程服务器上文件的权限?</target>
        </trans-unit>
        <trans-unit id="e13761e1cadfb4e6d275a8cd44df7f322009226b" translate="yes" xml:space="preserve">
          <source>How can I check if a key exists in a multilevel hash?</source>
          <target state="translated">如何检查多级哈希中是否存在密钥?</target>
        </trans-unit>
        <trans-unit id="9501d5027299df90931400bb41c70210a1c7aacf" translate="yes" xml:space="preserve">
          <source>How can I comment out a large block of Perl code?</source>
          <target state="translated">如何注释掉一大段Perl代码?</target>
        </trans-unit>
        <trans-unit id="639138b8959cf833940b74db28e00ac3d078eb9d" translate="yes" xml:space="preserve">
          <source>How can I compare two dates and find the difference?</source>
          <target state="translated">如何比较两个日期并找出差异?</target>
        </trans-unit>
        <trans-unit id="92731d0a16ed8941afe35ab6fae1c71e5ff73d63" translate="yes" xml:space="preserve">
          <source>How can I compile my Perl program into byte code or C?</source>
          <target state="translated">如何将我的Perl程序编译成字节码或C语言?</target>
        </trans-unit>
        <trans-unit id="f297bf1c9610312e098c5eff2eb10783e881e05c" translate="yes" xml:space="preserve">
          <source>How can I convert my shell script to perl?</source>
          <target state="translated">如何将我的shell脚本转换为perl?</target>
        </trans-unit>
        <trans-unit id="fc9934bcfd8649f3922c04fc5693703b33981e29" translate="yes" xml:space="preserve">
          <source>How can I convince others to use Perl?</source>
          <target state="translated">如何说服别人使用Perl?</target>
        </trans-unit>
        <trans-unit id="61781e6bf9642bee00811fb1e34ef7698e18ae20" translate="yes" xml:space="preserve">
          <source>How can I copy a file?</source>
          <target state="translated">如何复制文件?</target>
        </trans-unit>
        <trans-unit id="62ee42141b7c95a311d0f8cb97c8e383832868b4" translate="yes" xml:space="preserve">
          <source>How can I count the number of occurrences of a substring within a string?</source>
          <target state="translated">如何计算一个字符串中子串的出现次数?</target>
        </trans-unit>
        <trans-unit id="e426c21b9ed422b544529af4c9449106fd8175dd" translate="yes" xml:space="preserve">
          <source>How can I debug my scripts that use Net::* modules ?</source>
          <target state="translated">如何调试使用Net::*模块的脚本?</target>
        </trans-unit>
        <trans-unit id="f0aa6516dbefab9dd5eb5222f4701f9c5f218b7c" translate="yes" xml:space="preserve">
          <source>How can I determine if a string is a text string or a binary string?</source>
          <target state="translated">如何判断一个字符串是文本字符串还是二进制字符串?</target>
        </trans-unit>
        <trans-unit id="218779f6e2b4819e8fa691d46344a18cc62cfb76" translate="yes" xml:space="preserve">
          <source>How can I do RPC in Perl?</source>
          <target state="translated">如何在Perl中进行RPC?</target>
        </trans-unit>
        <trans-unit id="67ea1bb995fcd1fc57c8e9b92a095f41d9b7834f" translate="yes" xml:space="preserve">
          <source>How can I do an atexit() or setjmp()/longjmp()? (Exception handling)</source>
          <target state="translated">如何进行texit()或setjmp()/longjmp()?(异常处理)</target>
        </trans-unit>
        <trans-unit id="5af190bbb735548d1facf32f768401f6d294971f" translate="yes" xml:space="preserve">
          <source>How can I do approximate matching?</source>
          <target state="translated">如何进行近似匹配?</target>
        </trans-unit>
        <trans-unit id="570f18a5d24dc2e398fe91082824106830a64146" translate="yes" xml:space="preserve">
          <source>How can I expand variables in text strings?</source>
          <target state="translated">如何在文本字符串中展开变量?</target>
        </trans-unit>
        <trans-unit id="79199189d2f681d40463922bceb5338164a11bf3" translate="yes" xml:space="preserve">
          <source>How can I find out my current or calling package?</source>
          <target state="translated">如何查询我的当前或通话套餐?</target>
        </trans-unit>
        <trans-unit id="2174489b130a993ef91515d9a1c4f01f1df7d31d" translate="yes" xml:space="preserve">
          <source>How can I find the Julian Day?</source>
          <target state="translated">如何找到朱利安日?</target>
        </trans-unit>
        <trans-unit id="b9735d79cbde5c76c3fddd9a7f2ea2d91841d1f1" translate="yes" xml:space="preserve">
          <source>How can I free an array or hash so my program shrinks?</source>
          <target state="translated">如何释放数组或哈希,使我的程序缩小?</target>
        </trans-unit>
        <trans-unit id="a65a81dcfe85675764c8fa953a5501143a7a4d4c" translate="yes" xml:space="preserve">
          <source>How can I get #!perl to work on [MS-DOS,NT,...]?</source>
          <target state="translated">如何让#!perl在[MS-DOS,NT,...]上工作?</target>
        </trans-unit>
        <trans-unit id="bf6b38eb1c743c27901f724e241bc103f6e22f1a" translate="yes" xml:space="preserve">
          <source>How can I get &lt;code&gt;#!perl&lt;/code&gt; to work on [MS-DOS,NT,...]?</source>
          <target state="translated">我如何获得 &lt;code&gt;#!perl&lt;/code&gt; 在[MS-DOS，NT，...]上工作？</target>
        </trans-unit>
        <trans-unit id="402e6fe7ce516fa4af09165ec04abd0ecfff56b0" translate="yes" xml:space="preserve">
          <source>How can I get a binary version of Perl?</source>
          <target state="translated">如何获得 Perl 的二进制版本?</target>
        </trans-unit>
        <trans-unit id="70a068e99378aace39b694de85966e9dee8710b7" translate="yes" xml:space="preserve">
          <source>How can I get the modification time of a file on a remote FTP server ?</source>
          <target state="translated">如何获取远程FTP服务器上文件的修改时间?</target>
        </trans-unit>
        <trans-unit id="2da1a103ebf1acd1fb34a8083f53578de0506ba8" translate="yes" xml:space="preserve">
          <source>How can I get the size of a file on a remote FTP server ?</source>
          <target state="translated">如何获得远程FTP服务器上文件的大小?</target>
        </trans-unit>
        <trans-unit id="f01d20dc05214c47d4b244f669680dc5511e26c5" translate="yes" xml:space="preserve">
          <source>How can I get the unique keys from two hashes?</source>
          <target state="translated">如何从两个哈希值中获取唯一密钥?</target>
        </trans-unit>
        <trans-unit id="c41c416bf1bb0f25b4ae1ae9fd568032d02685fd" translate="yes" xml:space="preserve">
          <source>How can I hide the source for my Perl program?</source>
          <target state="translated">如何隐藏Perl程序的源代码?</target>
        </trans-unit>
        <trans-unit id="6c1e3d2428ca43719e62fc8b4685854b671a4efe" translate="yes" xml:space="preserve">
          <source>How can I hope to use regular expressions without creating illegible and unmaintainable code?</source>
          <target state="translated">我怎么能希望使用正则表达式而不产生难以辨认和不可维护的代码?</target>
        </trans-unit>
        <trans-unit id="b41e3d8caca6f525dc73482358563647f9033bf1" translate="yes" xml:space="preserve">
          <source>How can I know how many entries are in a hash?</source>
          <target state="translated">如何知道一个哈希中有多少个条目?</target>
        </trans-unit>
        <trans-unit id="91090b21439190b378705149c5300b111d7f99b3" translate="yes" xml:space="preserve">
          <source>How can I lock a file?</source>
          <target state="translated">如何锁定文件?</target>
        </trans-unit>
        <trans-unit id="2b525e6fbe8d4f65916593a6d6f3bcc00b55e5ee" translate="yes" xml:space="preserve">
          <source>How can I make &lt;code&gt;\w&lt;/code&gt; match national character sets?</source>
          <target state="translated">如何使 &lt;code&gt;\w&lt;/code&gt; 与国家字符集匹配？</target>
        </trans-unit>
        <trans-unit id="493e8171097525007801a396579dca3fc0ae7646" translate="yes" xml:space="preserve">
          <source>How can I make \w match national character sets?</source>
          <target state="translated">如何使\w符合国家字符集?</target>
        </trans-unit>
        <trans-unit id="8efd8bb825816036c83b0bc4f4bc86a0e0087ba8" translate="yes" xml:space="preserve">
          <source>How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?</source>
          <target state="translated">如何使文件柄成为子程序的本地文件柄?如何在子程序之间传递文件柄?如何制作一个文件柄数组?</target>
        </trans-unit>
        <trans-unit id="225121f6ad8826944237905943573b1a1ad7146a" translate="yes" xml:space="preserve">
          <source>How can I make my CGI script more efficient?</source>
          <target state="translated">如何让我的CGI脚本更有效率?</target>
        </trans-unit>
        <trans-unit id="aa449d7fc61d0c5f65c319dcdaf3c309d5a861d5" translate="yes" xml:space="preserve">
          <source>How can I make my Perl program run faster?</source>
          <target state="translated">如何让我的Perl程序运行得更快?</target>
        </trans-unit>
        <trans-unit id="da8314c9a027c83b1de3d8a02639e8b7fd488456" translate="yes" xml:space="preserve">
          <source>How can I make my Perl program take less memory?</source>
          <target state="translated">如何让我的Perl程序占用更少的内存?</target>
        </trans-unit>
        <trans-unit id="ab79906bd54ede65c9167982f83df39910ca41eb" translate="yes" xml:space="preserve">
          <source>How can I make my hash remember the order I put elements into it?</source>
          <target state="translated">如何让我的哈希记住我放入元素的顺序?</target>
        </trans-unit>
        <trans-unit id="eff3ee7a75a95b7dc6ebbcab6cdc87f62eaed0b6" translate="yes" xml:space="preserve">
          <source>How can I make the Perl equivalent of a C structure/C++ class/hash or array of hashes or arrays?</source>
          <target state="translated">如何使Perl相当于C结构/C++类/哈希或数组的哈希或数组?</target>
        </trans-unit>
        <trans-unit id="313eaa4ceba4000008228fa89da4dfffac4883cb" translate="yes" xml:space="preserve">
          <source>How can I manipulate fixed-record-length files?</source>
          <target state="translated">如何操作固定记录长度的文件?</target>
        </trans-unit>
        <trans-unit id="e9c4cf85e44267039f73e90a4005aa7e0fbde93f" translate="yes" xml:space="preserve">
          <source>How can I match a locale-smart version of /[a-zA-Z]/?</source>
          <target state="translated">如何匹配/[a-zA-Z]/的本地智能版本?</target>
        </trans-unit>
        <trans-unit id="a09d0b29b89d8c572780ffdaa75b2f1b8df250c7" translate="yes" xml:space="preserve">
          <source>How can I match a locale-smart version of &lt;code&gt;/[a-zA-Z]/&lt;/code&gt; ?</source>
          <target state="translated">如何匹配 &lt;code&gt;/[a-zA-Z]/&lt;/code&gt; 的语言环境智能版本？</target>
        </trans-unit>
        <trans-unit id="46f9f4e17442c3dcf3475bc074cd33f2cbbe23ef" translate="yes" xml:space="preserve">
          <source>How can I match a locale-smart version of &lt;code&gt;/[a-zA-Z]/&lt;/code&gt;?</source>
          <target state="translated">如何匹配 &lt;code&gt;/[a-zA-Z]/&lt;/code&gt; 的语言环境智能版本？</target>
        </trans-unit>
        <trans-unit id="acc211b194ec96e0a9f39c2fc3c9760c5684f182" translate="yes" xml:space="preserve">
          <source>How can I match strings with multibyte characters?</source>
          <target state="translated">如何匹配带有多字节字符的字符串?</target>
        </trans-unit>
        <trans-unit id="77dcf6b0c4c91ea96666741c5ba2af5b17f44eab" translate="yes" xml:space="preserve">
          <source>How can I measure time under a second?</source>
          <target state="translated">如何测量一秒以下的时间?</target>
        </trans-unit>
        <trans-unit id="fc57917cedb17fe47cbb1a1fb4694f4b806c4a38" translate="yes" xml:space="preserve">
          <source>How can I open a file named with a leading &quot;&amp;gt;&quot; or trailing blanks?</source>
          <target state="translated">如何打开以&amp;ldquo;&amp;gt;&amp;rdquo;或尾随空白命名的文件？</target>
        </trans-unit>
        <trans-unit id="3db0de0b51e68209069c4bcced248be111e64bf1" translate="yes" xml:space="preserve">
          <source>How can I open a file with a leading &quot;&amp;gt;&quot; or trailing blanks?</source>
          <target state="translated">如何打开带有&amp;ldquo;&amp;gt;&amp;rdquo;或尾随空白的文件？</target>
        </trans-unit>
        <trans-unit id="2e27cd7875437a1d5b58c674aa20e1a1f445ed2f" translate="yes" xml:space="preserve">
          <source>How can I open a filehandle to a string?</source>
          <target state="translated">如何将文件柄打开为字符串?</target>
        </trans-unit>
        <trans-unit id="66bdbd7c5e5fc4cc3882f787c23fdf9783890787" translate="yes" xml:space="preserve">
          <source>How can I open a pipe both to and from a command?</source>
          <target state="translated">如何既能打开管道,又能从命令中打开?</target>
        </trans-unit>
        <trans-unit id="01291b9947177ee6a9867efb46ea11fb8dc4a814" translate="yes" xml:space="preserve">
          <source>How can I organize tests into subdirectories and have them run?</source>
          <target state="translated">如何将测试组织到子目录中并让它们运行?</target>
        </trans-unit>
        <trans-unit id="cc95647ff06623df9f3fe7b151e5174f6d8d433a" translate="yes" xml:space="preserve">
          <source>How can I output Roman numerals?</source>
          <target state="translated">如何输出罗马数字?</target>
        </trans-unit>
        <trans-unit id="e415a2ec1d5bacc294697e39127dad698ce08519" translate="yes" xml:space="preserve">
          <source>How can I output my numbers with commas added?</source>
          <target state="translated">如何输出加了逗号的数字?</target>
        </trans-unit>
        <trans-unit id="71d9df292afc1f28ab8d43537f9b2fc5e1d5e39d" translate="yes" xml:space="preserve">
          <source>How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?</source>
          <target state="translated">如何传递/返回一个{函数、FileHandle、数组、Hash、方法、Regex}?</target>
        </trans-unit>
        <trans-unit id="607da88807131fb0d75ed3b744e20b136c3c6945" translate="yes" xml:space="preserve">
          <source>How can I prevent addition of unwanted keys into a hash?</source>
          <target state="translated">如何防止在哈希中加入不需要的密钥?</target>
        </trans-unit>
        <trans-unit id="132c95be002620b77b84199839203d3bbecd265f" translate="yes" xml:space="preserve">
          <source>How can I print out a word-frequency or line-frequency summary?</source>
          <target state="translated">如何打印出字频或行频摘要?</target>
        </trans-unit>
        <trans-unit id="9b8afbc5c9adfffb10eaf9f9e73e6a5dd9a33727" translate="yes" xml:space="preserve">
          <source>How can I pull out lines between two patterns that are themselves on different lines?</source>
          <target state="translated">如何在两个本身就在不同线上的图案之间拉出线条?</target>
        </trans-unit>
        <trans-unit id="aa09f1e8ecf9751a8e601635407b1b85b484a991" translate="yes" xml:space="preserve">
          <source>How can I quote a variable to use in a regex?</source>
          <target state="translated">如何在regex中引用变量?</target>
        </trans-unit>
        <trans-unit id="5048ee292d54dc738c8b2e4a4e9d40ed88661804" translate="yes" xml:space="preserve">
          <source>How can I read a single character from a file? From the keyboard?</source>
          <target state="translated">如何从文件中读取单个字符?从键盘上读取?</target>
        </trans-unit>
        <trans-unit id="bd4bea532194d27e8f4c0167b3ea139fc3e738e8" translate="yes" xml:space="preserve">
          <source>How can I read in a file by paragraphs?</source>
          <target state="translated">如何在文件中按段落阅读?</target>
        </trans-unit>
        <trans-unit id="d86b23e0a7033694a41285ad01891788240ba487" translate="yes" xml:space="preserve">
          <source>How can I read in an entire file all at once?</source>
          <target state="translated">如何一次性读入整个文件?</target>
        </trans-unit>
        <trans-unit id="be068faf9cf22c97ef84fb173f7722fe689af084" translate="yes" xml:space="preserve">
          <source>How can I recognise a UTF-8 string?</source>
          <target state="translated">如何识别UTF-8字符串?</target>
        </trans-unit>
        <trans-unit id="28052c84845f30a6d5db733cf8047009c5a791db" translate="yes" xml:space="preserve">
          <source>How can I reliably rename a file?</source>
          <target state="translated">如何可靠地重命名一个文件?</target>
        </trans-unit>
        <trans-unit id="8a768c48e2e0b2fc34f88cb4e753c4bb5f8f926e" translate="yes" xml:space="preserve">
          <source>How can I remove duplicate elements from a list or array?</source>
          <target state="translated">如何从列表或数组中删除重复的元素?</target>
        </trans-unit>
        <trans-unit id="daff1cd30b2b776eb20a1e8ba332328966a941c8" translate="yes" xml:space="preserve">
          <source>How can I set up a footer format to be used with write()?</source>
          <target state="translated">如何设置与write()一起使用的页脚格式?</target>
        </trans-unit>
        <trans-unit id="e1d8eb9609efe77a17044341626f5d092fb4352d" translate="yes" xml:space="preserve">
          <source>How can I sleep() or alarm() for under a second?</source>
          <target state="translated">如何能在一秒内睡觉()或闹钟()?</target>
        </trans-unit>
        <trans-unit id="2e588f9010bcd10392f7edf040ae56a945189e99" translate="yes" xml:space="preserve">
          <source>How can I split a [character]-delimited string except when inside [character]?</source>
          <target state="translated">除了在[字符]内,如何分割一个[字符]限定的字符串?</target>
        </trans-unit>
        <trans-unit id="043a45581bbf861e01b6d8df458229f88cd7fe73" translate="yes" xml:space="preserve">
          <source>How can I store a multidimensional array in a DBM file?</source>
          <target state="translated">如何在DBM文件中存储一个多维数组?</target>
        </trans-unit>
        <trans-unit id="3e3f15708830cd90fcc2e8ed11e6fc04c0345d66" translate="yes" xml:space="preserve">
          <source>How can I take a string and turn it into epoch seconds?</source>
          <target state="translated">如何把一个字符串变成纪元秒?</target>
        </trans-unit>
        <trans-unit id="279887cb82cd1ebda6c6c1a0b09fc6f0014cb878" translate="yes" xml:space="preserve">
          <source>How can I tell if a variable is tainted?</source>
          <target state="translated">如何判断一个变量是否有污点?</target>
        </trans-unit>
        <trans-unit id="58516c6da782669b8d9c7cfc7d02262b3e4bb1bb" translate="yes" xml:space="preserve">
          <source>How can I tell whether a certain element is contained in a list or array?</source>
          <target state="translated">如何判断列表或数组中是否包含某个元素?</target>
        </trans-unit>
        <trans-unit id="a5d5b57593f0038532f9a469856b028182200632" translate="yes" xml:space="preserve">
          <source>How can I tell whether my encoding fully supports PerlIO ?</source>
          <target state="translated">如何判断我的编码是否完全支持PerlIO?</target>
        </trans-unit>
        <trans-unit id="81aaf6c4723167313d15ab1c5f7e5b530f8557ce" translate="yes" xml:space="preserve">
          <source>How can I tell whether there's a character waiting on a filehandle?</source>
          <target state="translated">如何判断一个文件柄上是否有字符在等待?</target>
        </trans-unit>
        <trans-unit id="b2fcf8739ca319f39af63e3ce5170d91f44f77f2" translate="yes" xml:space="preserve">
          <source>How can I translate tildes (~) in a filename?</source>
          <target state="translated">如何翻译文件名中的tildes(~)?</target>
        </trans-unit>
        <trans-unit id="881f014c19a83fce123198524d0af95f5abeddf7" translate="yes" xml:space="preserve">
          <source>How can I use Perl interactively?</source>
          <target state="translated">如何交互式地使用Perl?</target>
        </trans-unit>
        <trans-unit id="4822820e0cebd48f928eec2f020bfeb1c6c58fcc" translate="yes" xml:space="preserve">
          <source>How can I use Perl's -i option from within a program?</source>
          <target state="translated">如何在程序中使用 Perl 的 -i 选项?</target>
        </trans-unit>
        <trans-unit id="b59721a4c76a7fca29f80e903b0f2dded9b41579" translate="yes" xml:space="preserve">
          <source>How can I use Perl's &lt;code&gt;-i&lt;/code&gt; option from within a program?</source>
          <target state="translated">如何在程序中使用Perl的 &lt;code&gt;-i&lt;/code&gt; 选项？</target>
        </trans-unit>
        <trans-unit id="a0b830d488369e5b57f08961ae54b6541e391fcb" translate="yes" xml:space="preserve">
          <source>How can I use a filehandle indirectly?</source>
          <target state="translated">如何间接使用filehandle?</target>
        </trans-unit>
        <trans-unit id="2954afefc188233ca0982e40813f35aedafa9c02" translate="yes" xml:space="preserve">
          <source>How can I use a reference as a hash key?</source>
          <target state="translated">如何使用引用作为哈希键?</target>
        </trans-unit>
        <trans-unit id="1cd3f90234d9f2d28d7f7859571cd8142dbcb6f4" translate="yes" xml:space="preserve">
          <source>How can I use a variable as a variable name?</source>
          <target state="translated">如何使用变量作为变量名?</target>
        </trans-unit>
        <trans-unit id="0c905d4e5eee64ffc80c2808116d673741258304" translate="yes" xml:space="preserve">
          <source>How can I use curses with Perl?</source>
          <target state="translated">如何使用Perl中的咒语?</target>
        </trans-unit>
        <trans-unit id="50c6bbc4fb82176bf9d1327a643a764fb7e991f8" translate="yes" xml:space="preserve">
          <source>How can I write a GUI (X, Tk, Gtk, etc.) in Perl?</source>
          <target state="translated">如何用Perl写一个GUI(X、Tk、Gtk等)?</target>
        </trans-unit>
        <trans-unit id="81e8482ca19f1c03f3246a06ec608fbebf4e5f7c" translate="yes" xml:space="preserve">
          <source>How can I write expect in Perl?</source>
          <target state="translated">如何在 Perl 中写出 expect?</target>
        </trans-unit>
        <trans-unit id="1ed0197c720cb0aff97775cc40d6071cc2ec1d85" translate="yes" xml:space="preserve">
          <source>How can I write() into a string?</source>
          <target state="translated">如何将()写入字符串?</target>
        </trans-unit>
        <trans-unit id="ebe948a96ce8ed3fcef25d460b5826d6e46a03f1" translate="yes" xml:space="preserve">
          <source>How can you figure out what to add? Assuming your Perl is post-5.001, execute a &lt;code&gt;perl -V&lt;/code&gt; command and pay special attention to the &quot;cc&quot; and &quot;ccflags&quot; information.</source>
          <target state="translated">您如何找出要添加的内容？假设您的Perl为5.01之后，请执行 &lt;code&gt;perl -V&lt;/code&gt; 命令并特别注意&amp;ldquo; cc&amp;rdquo;和&amp;ldquo; ccflags&amp;rdquo;信息。</target>
        </trans-unit>
        <trans-unit id="7839a80cf8d473225aea7a22d12034d28e88fd87" translate="yes" xml:space="preserve">
          <source>How can you tell the difference between a non-zero status that is the result of a VMS native error status or an encoded Unix status? You can not unless you look at the ${^CHILD_ERROR_NATIVE} value. The ${^CHILD_ERROR_NATIVE} value returns the actual VMS status value and check the severity bits. If the severity bits are equal to 1, then if the numeric value for &lt;code&gt;$?&lt;/code&gt; is between 2 and 255 or 0, then &lt;code&gt;$?&lt;/code&gt; accurately reflects a value passed back from a Unix application. If &lt;code&gt;$?&lt;/code&gt; is 1, and the severity bits indicate a VMS error (2), then &lt;code&gt;$?&lt;/code&gt; is from a Unix application exit value.</source>
          <target state="translated">您如何分辨VMS本机错误状态或编码的Unix状态导致的非零状态之间的区别？除非您查看$ {^ CHILD_ERROR_NATIVE}值，否则您将无法这样做。$ {^ CHILD_ERROR_NATIVE}值返回实际的VMS状态值并检查严重性位。如果严重性位等于1，则 &lt;code&gt;$?&lt;/code&gt; 的数值是否为$？在2到255或0之间，然后 &lt;code&gt;$?&lt;/code&gt; 准确地反映从Unix应用程序传回的值。如果 &lt;code&gt;$?&lt;/code&gt; 为1，严重性位指示VMS错误（2），然后 &lt;code&gt;$?&lt;/code&gt; 来自Unix应用程序退出值。</target>
        </trans-unit>
        <trans-unit id="10e8b70e261dbd1684433d0e38a377a1e6c6f1bf" translate="yes" xml:space="preserve">
          <source>How come exec() doesn't return?</source>
          <target state="translated">为什么exec()不返回?</target>
        </trans-unit>
        <trans-unit id="642d4ca1dadf5e67b2382dbc957dee2d26101ca3" translate="yes" xml:space="preserve">
          <source>How come when I open a file read-write it wipes it out?</source>
          <target state="translated">为什么我打开一个文件读写的时候会把它抹掉?</target>
        </trans-unit>
        <trans-unit id="120ce3c4d0d569cc353775c742050f216df78c10" translate="yes" xml:space="preserve">
          <source>How come? Because once upon a time, the argument to push() had to be a real array, not just a reference to one. That's no longer true. In fact, the line marked &quot;implicit deref&quot; above works just fine--in this instance--to do what the one that says explicit deref did.</source>
          <target state="translated">怎么会这样呢?因为从前,push()的参数必须是一个真正的数组,而不仅仅是一个数组的引用。现在不再是这样了。事实上,上面标有 &quot;implicit deref &quot;的那行就很好用--在这个例子中--做了那个标有显式 deref 的那行。</target>
        </trans-unit>
        <trans-unit id="1a8c1eab260cee26d9dd30d8d1f6ad51a65f4aa2" translate="yes" xml:space="preserve">
          <source>How deeply nested the event is.</source>
          <target state="translated">事件的嵌套有多深。</target>
        </trans-unit>
        <trans-unit id="2e345122aff9e67ed09307eafafa850438366608" translate="yes" xml:space="preserve">
          <source>How deeply nested the hub was.</source>
          <target state="translated">枢纽的嵌套有多深。</target>
        </trans-unit>
        <trans-unit id="c4a52c2fce0f47a3f02d91b4d141841b4a0759aa" translate="yes" xml:space="preserve">
          <source>How do I access .tar.Z files?</source>
          <target state="translated">如何访问.tar.Z文件?</target>
        </trans-unit>
        <trans-unit id="35cd8e41b71c05362e2e05b8fea674b5b9428071" translate="yes" xml:space="preserve">
          <source>How do I add a directory to my include path (@INC) at runtime?</source>
          <target state="translated">如何在运行时在我的include路径(@INC)中添加一个目录?</target>
        </trans-unit>
        <trans-unit id="a8c4b858302cc359dbd26e7a94330185357e2027" translate="yes" xml:space="preserve">
          <source>How do I add the directory my program lives in to the module/library search path?</source>
          <target state="translated">如何将我的程序所在的目录添加到模块/库搜索路径中?</target>
        </trans-unit>
        <trans-unit id="3767a07fd4ca1c10dc3a53f806060f350ef02ac9" translate="yes" xml:space="preserve">
          <source>How do I adopt or take over a module already on CPAN?</source>
          <target state="translated">我如何采用或接管CPAN上已有的模块?</target>
        </trans-unit>
        <trans-unit id="2b820f99468b1968d2885fc455211ce9aab00b68" translate="yes" xml:space="preserve">
          <source>How do I ask the user for a password?</source>
          <target state="translated">如何向用户索要密码?</target>
        </trans-unit>
        <trans-unit id="203a77501794721d243b497cab58f25f10122bf4" translate="yes" xml:space="preserve">
          <source>How do I automate an HTML form submission?</source>
          <target state="translated">如何自动提交HTML表格?</target>
        </trans-unit>
        <trans-unit id="b9487e21fcb84b27b564a1a52da3c445074087f9" translate="yes" xml:space="preserve">
          <source>How do I avoid zombies on a Unix system?</source>
          <target state="translated">如何在Unix系统上避免僵尸?</target>
        </trans-unit>
        <trans-unit id="f3a92921961d16b06b6e90c94b5e844a5163c8ba" translate="yes" xml:space="preserve">
          <source>How do I capitalize all the words on one line?</source>
          <target state="translated">如何将一行字全部大写?</target>
        </trans-unit>
        <trans-unit id="4bb5fa72780a70fbcd38ea05720abb4024270f79" translate="yes" xml:space="preserve">
          <source>How do I change the Nth occurrence of something?</source>
          <target state="translated">如何改变东西的第N次出现?</target>
        </trans-unit>
        <trans-unit id="bbe71d73de3e4f641a5e48b9cabe7daee1df1bb9" translate="yes" xml:space="preserve">
          <source>How do I change, delete, or insert a line in a file, or append to the beginning of a file?</source>
          <target state="translated">如何在文件中更改、删除、插入一行,或追加到文件的开头?</target>
        </trans-unit>
        <trans-unit id="26ebac281176cc167fc28682837fc8035f2df7f9" translate="yes" xml:space="preserve">
          <source>How do I check a valid mail address?</source>
          <target state="translated">如何查询有效的邮件地址?</target>
        </trans-unit>
        <trans-unit id="a6d4bc02f449734d8d38a8c79be0738d1807657b" translate="yes" xml:space="preserve">
          <source>How do I check whether input is ready on the keyboard?</source>
          <target state="translated">如何检查键盘上的输入是否就绪?</target>
        </trans-unit>
        <trans-unit id="e9d5289c1b2381a4bfc799f6d79379a45148a056" translate="yes" xml:space="preserve">
          <source>How do I clear a package?</source>
          <target state="translated">如何清除包裹?</target>
        </trans-unit>
        <trans-unit id="da64d3ab23e8dfda8ada8eca869e3e4304053e10" translate="yes" xml:space="preserve">
          <source>How do I clear the screen?</source>
          <target state="translated">如何清除屏幕?</target>
        </trans-unit>
        <trans-unit id="dc7b6aff1b04d81838ccfc000e127a9b49e09b59" translate="yes" xml:space="preserve">
          <source>How do I close a file descriptor by number?</source>
          <target state="translated">如何按编号关闭文件描述符?</target>
        </trans-unit>
        <trans-unit id="2102c2d58d3c697659db6f147f9c7750ead5e836" translate="yes" xml:space="preserve">
          <source>How do I close a process's filehandle without waiting for it to complete?</source>
          <target state="translated">如何在不等待进程完成的情况下关闭进程的文件柄?</target>
        </trans-unit>
        <trans-unit id="82c4851509fc2188559dfc3bbd26e54406e86a76" translate="yes" xml:space="preserve">
          <source>How do I compare strings?</source>
          <target state="translated">如何比较字符串?</target>
        </trans-unit>
        <trans-unit id="a5014833338499c76ba684cef2ad05a8939c7509" translate="yes" xml:space="preserve">
          <source>How do I compute the difference of two arrays? How do I compute the intersection of two arrays?</source>
          <target state="translated">如何计算两个数组的差?如何计算两个数组的交点?</target>
        </trans-unit>
        <trans-unit id="28baf17ec2f9a6ff5d6d17753e8bf70e57ef541a" translate="yes" xml:space="preserve">
          <source>How do I convert a string to UTF-8?</source>
          <target state="translated">如何将字符串转换为UTF-8?</target>
        </trans-unit>
        <trans-unit id="a1ff2698b449bb489c981be9b3dd682dc2dd11e3" translate="yes" xml:space="preserve">
          <source>How do I convert between numeric representations/bases/radixes?</source>
          <target state="translated">如何在数字表示法/基数/半径之间进行转换?</target>
        </trans-unit>
        <trans-unit id="0506850f7d31bd4782eb7c2ff13183ae7d6e27bb" translate="yes" xml:space="preserve">
          <source>How do I convert from binary to decimal</source>
          <target state="translated">如何将二进制转换为十进制?</target>
        </trans-unit>
        <trans-unit id="6763571be4b24365fdbf47562a891c2c2a4061df" translate="yes" xml:space="preserve">
          <source>How do I convert from decimal to binary</source>
          <target state="translated">如何将十进制转换为二进制?</target>
        </trans-unit>
        <trans-unit id="135991f8dae083c523ec58906bfcb69cccb0578d" translate="yes" xml:space="preserve">
          <source>How do I convert from decimal to hexadecimal</source>
          <target state="translated">如何将十进制转换为十六进制?</target>
        </trans-unit>
        <trans-unit id="36fe51b125b1634217406cabccf1c4ca07f98c99" translate="yes" xml:space="preserve">
          <source>How do I convert from decimal to octal</source>
          <target state="translated">如何将十进制转换为八进制?</target>
        </trans-unit>
        <trans-unit id="0e154b3973b3e38c40dce2887c701eeb759ba7d9" translate="yes" xml:space="preserve">
          <source>How do I convert from encoding FOO to encoding BAR?</source>
          <target state="translated">如何将FOO编码转换为BAR编码?</target>
        </trans-unit>
        <trans-unit id="4b920c4f62d053fb6ad8f68f4bc740e16585148f" translate="yes" xml:space="preserve">
          <source>How do I convert from octal to decimal</source>
          <target state="translated">如何将八进制转换为十进制?</target>
        </trans-unit>
        <trans-unit id="8274dd7834392a793f979a76735c021fd05ed705" translate="yes" xml:space="preserve">
          <source>How do I convert hexadecimal into decimal</source>
          <target state="translated">如何将十六进制转换为十进制?</target>
        </trans-unit>
        <trans-unit id="f9aa83752cb5484c41a1a794b8c3e92b85b90232" translate="yes" xml:space="preserve">
          <source>How do I copy an entire directory?</source>
          <target state="translated">如何复制整个目录?</target>
        </trans-unit>
        <trans-unit id="878e0980aa72aa1b56f3382c08eb0ae977818037" translate="yes" xml:space="preserve">
          <source>How do I count the number of lines in a file?</source>
          <target state="translated">如何计算一个文件的行数?</target>
        </trans-unit>
        <trans-unit id="86a1974c296e30057e2194a7ef2242b7c1cfd98c" translate="yes" xml:space="preserve">
          <source>How do I create a Module::Build based Build.PL derived from an ExtUtils::MakeMaker focused Makefile.PL?</source>
          <target state="translated">如何从ExtUtils::MakeMaker集中的Makefile.PL创建一个基于Module::Build的Build.PL?</target>
        </trans-unit>
        <trans-unit id="aa6bdbe546fadef34a6ec8c386dc99a9b330832e" translate="yes" xml:space="preserve">
          <source>How do I create a class?</source>
          <target state="translated">如何创建一个班级?</target>
        </trans-unit>
        <trans-unit id="4d74113d708c10f061b26ff7fcdab35341dbf82e" translate="yes" xml:space="preserve">
          <source>How do I create a module?</source>
          <target state="translated">如何创建模块?</target>
        </trans-unit>
        <trans-unit id="236c38bf7065e57bd631c8a83a8f5bfc130478e7" translate="yes" xml:space="preserve">
          <source>How do I create a static variable?</source>
          <target state="translated">如何创建一个静态变量?</target>
        </trans-unit>
        <trans-unit id="b74b37fe4636da83763c3e9df557c6184ae8c0f0" translate="yes" xml:space="preserve">
          <source>How do I create a switch or case statement?</source>
          <target state="translated">如何创建一个开关或case语句?</target>
        </trans-unit>
        <trans-unit id="87e0957c61f867da042ce74af89ed18af7f653b6" translate="yes" xml:space="preserve">
          <source>How do I cross-reference my Perl programs?</source>
          <target state="translated">如何交叉引用我的Perl程序?</target>
        </trans-unit>
        <trans-unit id="70f54b8026aba3fe0b07c960855d5b7aab7bb809" translate="yes" xml:space="preserve">
          <source>How do I debug my Perl programs?</source>
          <target state="translated">如何调试我的Perl程序?</target>
        </trans-unit>
        <trans-unit id="97378d9d3fe8991aaac89412355467232d0a4c27" translate="yes" xml:space="preserve">
          <source>How do I declare/create a structure?</source>
          <target state="translated">如何声明/创建一个结构?</target>
        </trans-unit>
        <trans-unit id="2f51e7bb07a2328659ee4f97c52bb6f158f54842" translate="yes" xml:space="preserve">
          <source>How do I decode a MIME/BASE64 string?</source>
          <target state="translated">如何对MIME/BASE64字符串进行解码?</target>
        </trans-unit>
        <trans-unit id="2cd19e271c87d62d106f8fec30b522eacf831c74" translate="yes" xml:space="preserve">
          <source>How do I decode encrypted password files?</source>
          <target state="translated">如何破解加密的密码文件?</target>
        </trans-unit>
        <trans-unit id="23d494744b67cf68faa6ba521e0dbfb0f945c204" translate="yes" xml:space="preserve">
          <source>How do I decode or create those %-encodings on the web?</source>
          <target state="translated">如何在网络上解码或创建这些%编码?</target>
        </trans-unit>
        <trans-unit id="ee2564195c16e10af1a2a54e803a2d5eaa4bba4a" translate="yes" xml:space="preserve">
          <source>How do I define methods for every class/object?</source>
          <target state="translated">如何为每个类/对象定义方法?</target>
        </trans-unit>
        <trans-unit id="65a1e2e0843b152e3e957dda320e2bd68a2d232e" translate="yes" xml:space="preserve">
          <source>How do I delete a directory tree?</source>
          <target state="translated">如何删除目录树?</target>
        </trans-unit>
        <trans-unit id="39ddaeab66eebefd8e49abf20a3ac9b4d117bd4d" translate="yes" xml:space="preserve">
          <source>How do I delete everything not in my</source>
          <target state="translated">我如何删除所有不在我的</target>
        </trans-unit>
        <trans-unit id="c6598461e8184a71f0045d1091c9275b621efb6c" translate="yes" xml:space="preserve">
          <source>How do I delete the last N lines from a file?</source>
          <target state="translated">如何删除文件中的最后N行?</target>
        </trans-unit>
        <trans-unit id="82c2c49b1820b2e4b306f272a2091aeedd8bf680" translate="yes" xml:space="preserve">
          <source>How do I determine whether a scalar is a number/whole/integer/float?</source>
          <target state="translated">如何确定一个标量是数字/整体/整数/浮点数?</target>
        </trans-unit>
        <trans-unit id="f65b76741f09d6f8756a10de0d88399c941d8dbe" translate="yes" xml:space="preserve">
          <source>How do I do (anything)?</source>
          <target state="translated">我怎么做(什么)?</target>
        </trans-unit>
        <trans-unit id="5a3899f947a018efe1a69e369cf5894457670072" translate="yes" xml:space="preserve">
          <source>How do I do a &lt;code&gt;tail -f&lt;/code&gt; in perl?</source>
          <target state="translated">如何在perl中执行 &lt;code&gt;tail -f&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="08d06a078c58ebbf0c5a4ee81c3c6214665f0e66" translate="yes" xml:space="preserve">
          <source>How do I do a tail -f in perl?</source>
          <target state="translated">如何在perl中做尾部-f?</target>
        </trans-unit>
        <trans-unit id="8a1d6beddae75cca1e0c47c227a5ded3e3a37f2c" translate="yes" xml:space="preserve">
          <source>How do I do fancy stuff with the keyboard/screen/mouse?</source>
          <target state="translated">如何用键盘/屏幕/鼠标做一些花哨的东西?</target>
        </trans-unit>
        <trans-unit id="4adc2a7ad5bba352a704cf7278066f75dfdb1320" translate="yes" xml:space="preserve">
          <source>How do I download files from an FTP server ?</source>
          <target state="translated">如何从FTP服务器下载文件?</target>
        </trans-unit>
        <trans-unit id="beaabf13bf44c3d2a6f003d0da1ad9d016f78129" translate="yes" xml:space="preserve">
          <source>How do I dup() a filehandle in Perl?</source>
          <target state="translated">如何在Perl中dup()一个文件柄?</target>
        </trans-unit>
        <trans-unit id="c99c99752028698e07bd697c4f55f10aeb2574b2" translate="yes" xml:space="preserve">
          <source>How do I efficiently match many regular expressions at once?</source>
          <target state="translated">如何高效地同时匹配多个正则表达式?</target>
        </trans-unit>
        <trans-unit id="d8501dfb7a286a0bc3e79d726ff0aa33a83b4611" translate="yes" xml:space="preserve">
          <source>How do I expand function calls in a string?</source>
          <target state="translated">如何在字符串中展开函数调用?</target>
        </trans-unit>
        <trans-unit id="40ad9f6ac9837b05501210a465bcfa76304dce6b" translate="yes" xml:space="preserve">
          <source>How do I expand tabs in a string?</source>
          <target state="translated">如何在字符串中展开制表符?</target>
        </trans-unit>
        <trans-unit id="1794d4b7480b0f45fea6bded5c811dbf977507ba" translate="yes" xml:space="preserve">
          <source>How do I extract URLs?</source>
          <target state="translated">如何提取URL?</target>
        </trans-unit>
        <trans-unit id="e7089a10dfdd460d912e93d4c4488293420a3931" translate="yes" xml:space="preserve">
          <source>How do I extract only files that have property X from an archive?</source>
          <target state="translated">如何从存档中只提取属性为X的文件?</target>
        </trans-unit>
        <trans-unit id="4490e28bfd20b3131d4a6a9a43d5708c9217af3c" translate="yes" xml:space="preserve">
          <source>How do I extract selected columns from a string?</source>
          <target state="translated">如何从字符串中提取选定的列?</target>
        </trans-unit>
        <trans-unit id="5e9ce3143a0232dce445afb94a4cd2cbabc5866a" translate="yes" xml:space="preserve">
          <source>How do I fetch an HTML file?</source>
          <target state="translated">如何获取一个HTML文件?</target>
        </trans-unit>
        <trans-unit id="5874d66493051782bd5b330106175c43ebb7b6dd" translate="yes" xml:space="preserve">
          <source>How do I fetch/put an (S)FTP file?</source>
          <target state="translated">如何获取/投放(S)FTP文件?</target>
        </trans-unit>
        <trans-unit id="930fdbc050be8c4df7c4e53dd8aa59f284368264" translate="yes" xml:space="preserve">
          <source>How do I find matching/nesting anything?</source>
          <target state="translated">如何找到匹配/嵌套的东西?</target>
        </trans-unit>
        <trans-unit id="bc8fb538829e6c584fa0187f483d1bbaba9e7351" translate="yes" xml:space="preserve">
          <source>How do I find out if I'm running interactively or not?</source>
          <target state="translated">如何发现自己是否在交互式运行?</target>
        </trans-unit>
        <trans-unit id="67eefe0342c38d62f056273caef773f2b1d22382" translate="yes" xml:space="preserve">
          <source>How do I find out my hostname, domainname, or IP address?</source>
          <target state="translated">如何找到我的主机名、域名或IP地址?</target>
        </trans-unit>
        <trans-unit id="b35cce5c620df3c5213a5b63c9524655cbb9d4b9" translate="yes" xml:space="preserve">
          <source>How do I find out which operating system I'm running under?</source>
          <target state="translated">如何知道我在哪个操作系统下运行?</target>
        </trans-unit>
        <trans-unit id="01907eb2e6a268c88ab9c2c3bfb59105a7c7e3c4" translate="yes" xml:space="preserve">
          <source>How do I find the current century or millennium?</source>
          <target state="translated">如何找到当前的世纪或千年?</target>
        </trans-unit>
        <trans-unit id="3463510f64a1c5a49fcc37902eead9f9ac95605b" translate="yes" xml:space="preserve">
          <source>How do I find the day or week of the year?</source>
          <target state="translated">如何找到一年中的哪一天或哪一周?</target>
        </trans-unit>
        <trans-unit id="982d40212fc998a0686d78df9c4ba26898354f0e" translate="yes" xml:space="preserve">
          <source>How do I find the first array element for which a condition is true?</source>
          <target state="translated">如何找到第一个条件为真的数组元素?</target>
        </trans-unit>
        <trans-unit id="74e25e9ffe5b922252ebf9163105b704200cdbaf" translate="yes" xml:space="preserve">
          <source>How do I find the soundex value of a string?</source>
          <target state="translated">如何查找字符串的声母值?</target>
        </trans-unit>
        <trans-unit id="d5fb344779130b34177124faae9f510c7450c0be" translate="yes" xml:space="preserve">
          <source>How do I find the user's mail address?</source>
          <target state="translated">如何找到用户的邮件地址?</target>
        </trans-unit>
        <trans-unit id="9b5f48590c3589b927773b9f4489ef3e2df19ab7" translate="yes" xml:space="preserve">
          <source>How do I find which modules are installed on my system?</source>
          <target state="translated">如何查找系统中安装了哪些模块?</target>
        </trans-unit>
        <trans-unit id="db22bcad0e65ee82eb15cee813db7ad1bc862f74" translate="yes" xml:space="preserve">
          <source>How do I find yesterday's date?</source>
          <target state="translated">如何找到昨天的日期?</target>
        </trans-unit>
        <trans-unit id="f14d19d9f33ebecf97e59acd91f7a3e35d168a35" translate="yes" xml:space="preserve">
          <source>How do I flush/unbuffer an output filehandle? Why must I do this?</source>
          <target state="translated">如何刷新/取消缓冲一个输出文件柄?为什么我必须这样做?</target>
        </trans-unit>
        <trans-unit id="50ced00e1da5731e9f081395bef33daf71015cca" translate="yes" xml:space="preserve">
          <source>How do I fork a daemon process?</source>
          <target state="translated">如何fork一个守护进程?</target>
        </trans-unit>
        <trans-unit id="b5197890f13966fd4c7d88cf82096a37fc11915e" translate="yes" xml:space="preserve">
          <source>How do I get MakeMaker and Module::Build to install to the same place?</source>
          <target state="translated">如何让MakeMaker和Module::Build安装到同一个地方?</target>
        </trans-unit>
        <trans-unit id="fb4fad4fa61c86e768baf3c503d80347718f36c7" translate="yes" xml:space="preserve">
          <source>How do I get a directory listing from an FTP server ?</source>
          <target state="translated">如何从FTP服务器获取目录列表?</target>
        </trans-unit>
        <trans-unit id="af1e555b8ad44f5ee09984b301d45f763b3ab693" translate="yes" xml:space="preserve">
          <source>How do I get a file's timestamp in perl?</source>
          <target state="translated">如何在perl中获取文件的时间戳?</target>
        </trans-unit>
        <trans-unit id="f416b305fcb8113d5bc19886df8b83bac5c89fb3" translate="yes" xml:space="preserve">
          <source>How do I get a random number between X and Y?</source>
          <target state="translated">如何获得X和Y之间的随机数?</target>
        </trans-unit>
        <trans-unit id="0f092c3cc9246e7de03f0d8e8c730fbe8df49215" translate="yes" xml:space="preserve">
          <source>How do I get the screen size?</source>
          <target state="translated">如何获得屏幕尺寸?</target>
        </trans-unit>
        <trans-unit id="d2945107e7da57555f0937b6495cd275527b10d0" translate="yes" xml:space="preserve">
          <source>How do I handle Unicode strings?</source>
          <target state="translated">如何处理Unicode字符串?</target>
        </trans-unit>
        <trans-unit id="c3313630d3f982060a390f5f1946717a57153c40" translate="yes" xml:space="preserve">
          <source>How do I handle binary data correctly?</source>
          <target state="translated">如何正确处理二进制数据?</target>
        </trans-unit>
        <trans-unit id="3d9eeab5302abcd051b9c7c58a10262f71b93d0d" translate="yes" xml:space="preserve">
          <source>How do I handle circular lists?</source>
          <target state="translated">如何处理循环列表?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
