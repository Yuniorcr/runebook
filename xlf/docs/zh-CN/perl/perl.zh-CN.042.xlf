<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="a87ba5fd11240d3846b6402630cc4fc5a1bb692a" translate="yes" xml:space="preserve">
          <source>The name of the remote file. For the local file name, the result of $ff-&amp;gt;output_file will be used.</source>
          <target state="translated">远程文件的名称。对于本地文件名，将使用$ ff-&amp;gt; output_file的结果。</target>
        </trans-unit>
        <trans-unit id="54a547e6d045957f910163d7d9750610edbb9f85" translate="yes" xml:space="preserve">
          <source>The name of the test that will be displayed after the &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;not
ok&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;ok&lt;/code&gt; 或 &lt;code&gt;not ok&lt;/code&gt; 之后将显示的测试名称。</target>
        </trans-unit>
        <trans-unit id="fed54953d3ed163e618a466d003f5bcd630ecc77" translate="yes" xml:space="preserve">
          <source>The name of the test. Usually a filename.</source>
          <target state="translated">测试的名称。通常是一个文件名。</target>
        </trans-unit>
        <trans-unit id="bddd22d202ef6bbfb07440852aa85decd3f86741" translate="yes" xml:space="preserve">
          <source>The name of the variable the OP's targ refers to, if any, otherwise the letter t followed by the OP's targ in decimal.</source>
          <target state="translated">OP的targ所指向的变量名称,如果有的话,否则在OP的targ后面加上字母t,用十进制表示。</target>
        </trans-unit>
        <trans-unit id="57d8fd0b0612e473ba409ed332506df9547952e4" translate="yes" xml:space="preserve">
          <source>The name of this target is the name of the tarball generated by tardist. This target does the actual work of turning the distdir into a tarball.</source>
          <target state="translated">这个目标的名字是 tardist 生成的 tar 包的名字。这个目标完成了将 distdir 变成 tar 包的实际工作。</target>
        </trans-unit>
        <trans-unit id="7f384abee623b7aefa3eee77d6cf325a89576f28" translate="yes" xml:space="preserve">
          <source>The name of this target is the name of the zip file generated by zipdist. This target does the actual work of turning the distdir into a zip file.</source>
          <target state="translated">这个目标的名称是 zipdist 生成的 zip 文件的名称。这个目标完成了将distdir转化为zip文件的实际工作。</target>
        </trans-unit>
        <trans-unit id="40fffdd6d8d082596e0b6d7269c4fc2ab2372dd8" translate="yes" xml:space="preserve">
          <source>The name or URL, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the name (also sometimes called the page) is &quot;perlfunc&quot;. In &quot;L&amp;lt;/CAVEATS&amp;gt;&quot;, the name is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">名称或URL，如果没有则为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。（例如，在&amp;ldquo; L &amp;lt;Perl Functions | perlfunc&amp;gt;&amp;rdquo;中，名称（有时也称为页面）为&amp;ldquo; perlfunc&amp;rdquo;。在&amp;ldquo; L &amp;lt;/ CAVEATS&amp;gt;&amp;rdquo;中，名称为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="032b79c8986bca0bbbc3c31a86f48e2e4e0d3085" translate="yes" xml:space="preserve">
          <source>The name returned is the &quot;best&quot; (defined below) official name or alias for the code point, if available; otherwise your custom alias for it, if defined; otherwise &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. This means that your alias will only be returned for code points that don't have an official Unicode name (nor alias) such as private use code points.</source>
          <target state="translated">返回的名称是代码点的&amp;ldquo;最佳&amp;rdquo;（在下面定义）正式名称或别名；否则，您的自定义别名（如果已定义）；否则 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。这意味着您的别名将仅针对没有正式Unicode名称（也不是别名）的代码点（例如专用代码点）返回。</target>
        </trans-unit>
        <trans-unit id="45c859e03c561ae7900b19a5195289cf330fd686" translate="yes" xml:space="preserve">
          <source>The name specification contains the name of the option, optionally followed by a list of alternative names separated by vertical bar characters.</source>
          <target state="translated">名称规格包含了选项的名称,后面是由竖条字符分隔的备选名称列表。</target>
        </trans-unit>
        <trans-unit id="74ea5f2153ac354bb676ac855da5204a1c4f0887" translate="yes" xml:space="preserve">
          <source>The name stored in the pad name struct. This returns NULL for a target slot.</source>
          <target state="translated">存储在pad name结构中的名称。对于目标槽,返回NULL。</target>
        </trans-unit>
        <trans-unit id="7c9c5d421e8490b0fb44df42960273145ec017c2" translate="yes" xml:space="preserve">
          <source>The name that &lt;code&gt;gv_stash*v&lt;/code&gt; wants is the name of the package whose symbol table you want. The default package is called &lt;code&gt;main&lt;/code&gt; . If you have multiply nested packages, pass their names to &lt;code&gt;gv_stash*v&lt;/code&gt; , separated by &lt;code&gt;::&lt;/code&gt; as in the Perl language itself.</source>
          <target state="translated">那名 &lt;code&gt;gv_stash*v&lt;/code&gt; 要的是你想要其符号表中的包的名称。默认软件包称为 &lt;code&gt;main&lt;/code&gt; 。如果您有多个嵌套的软件包， &lt;code&gt;gv_stash*v&lt;/code&gt; 它们的名称传递给gv_stash * v，与Perl语言本身一样，以 &lt;code&gt;::&lt;/code&gt; 分隔。</target>
        </trans-unit>
        <trans-unit id="0ea1c9f71e1742c14f7e274aadd24083453f785c" translate="yes" xml:space="preserve">
          <source>The name used to execute the current copy of Perl, from C's &lt;code&gt;argv[0]&lt;/code&gt; or (where supported)</source>
          <target state="translated">用于执行C的 &lt;code&gt;argv[0]&lt;/code&gt; 或（如果支持）的Perl当前副本的名称</target>
        </trans-unit>
        <trans-unit id="7d5e4108cb484849f5cc23fa9d5c378793d57fcf" translate="yes" xml:space="preserve">
          <source>The names</source>
          <target state="translated">名称</target>
        </trans-unit>
        <trans-unit id="618e9ec6e6fd129b3719b6fed50188e89fd59442" translate="yes" xml:space="preserve">
          <source>The names are in the old-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">名称采用旧样式（请参见&amp;ldquo; &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;旧样式&amp;rdquo;和&amp;ldquo;新样式&amp;rdquo;的块名&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="07ca386df79309f7e041c206d3183ef66c0ddbc4" translate="yes" xml:space="preserve">
          <source>The names associated with pad entries.</source>
          <target state="translated">与焊盘条目相关的名称。</target>
        </trans-unit>
        <trans-unit id="284af84a82eacc68e4acdb3ccfa2e6b8438eb902" translate="yes" xml:space="preserve">
          <source>The names have been chosen by analogy with &lt;a href=&quot;tie/scalar&quot;&gt;Tie::Scalar&lt;/a&gt; methods names with an additional &lt;b&gt;LENGTH&lt;/b&gt; callback for efficiency. However named capture variables are currently not tied internally but implemented via magic.</source>
          <target state="translated">名称的选择与&lt;a href=&quot;tie/scalar&quot;&gt;Tie :: Scalar&lt;/a&gt;方法名称类似，并带有附加的&lt;b&gt;LENGTH&lt;/b&gt;回调以提高效率。但是，命名的捕获变量当前不内部绑定，而是通过魔术实现的。</target>
        </trans-unit>
        <trans-unit id="6f2021e99e612abfa74ac94b1f6cbd3e729a273e" translate="yes" xml:space="preserve">
          <source>The names of any symbols that cannot be exported should be listed in the &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; array.</source>
          <target state="translated">&lt;code&gt;@EXPORT_FAIL&lt;/code&gt; 数组中应列出无法导出的任何符号的名称。</target>
        </trans-unit>
        <trans-unit id="ce28b5edeebefe670a07dac363032a7c7d1c8c78" translate="yes" xml:space="preserve">
          <source>The names of one or more patch files or other text attachments to be included with the report. Multiple files must be separated with commas.</source>
          <target state="translated">要列入报告的一个或多个补丁文件或其他文本附件的名称。多个文件必须用逗号分隔。</target>
        </trans-unit>
        <trans-unit id="8f857c3b3defbce0780a8f039ec3e39d992aed2b" translate="yes" xml:space="preserve">
          <source>The names of the constants are grouped by length. Generate child subroutines for each group with this number or more names in.</source>
          <target state="translated">常量的名称按长度分组。为每组生成子程序,每组有这个数量或更多的名字在。</target>
        </trans-unit>
        <trans-unit id="014e7ffcf388c955244e207841832a805e1b764b" translate="yes" xml:space="preserve">
          <source>The names of the fields can be obtained by calling &lt;code&gt;overview_fmt&lt;/code&gt; .</source>
          <target state="translated">可以通过调用 &lt;code&gt;overview_fmt&lt;/code&gt; 获得字段的名称。</target>
        </trans-unit>
        <trans-unit id="e4fc313d5aefbc7e8f27ebb1be72375df1f65ec2" translate="yes" xml:space="preserve">
          <source>The names of the signals are the ones listed out by &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; on your system, or you can retrieve them using the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Signal&quot;&gt;IPC::Signal&lt;/a&gt;.</source>
          <target state="translated">信号的名称是系统上 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; 列出的名称，或者您可以使用CPAN模块&lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Signal&quot;&gt;IPC :: Signal&lt;/a&gt;检索它们。</target>
        </trans-unit>
        <trans-unit id="9e5a87a1d013fec4fa7021ebe1fad71eb5dada0f" translate="yes" xml:space="preserve">
          <source>The naming of encodings, both by the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; and by the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma allows for flexible names: &lt;code&gt;koi8-r&lt;/code&gt; and &lt;code&gt;KOI8R&lt;/code&gt; will both be understood.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma 都对编码进行命名可以使用灵活的名称： &lt;code&gt;koi8-r&lt;/code&gt; 和 &lt;code&gt;KOI8R&lt;/code&gt; 都可以理解。</target>
        </trans-unit>
        <trans-unit id="eb26ebee327534f7eadec1f76baa31ad090fef00" translate="yes" xml:space="preserve">
          <source>The native status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. On POSIX-like systems this value can be decoded with the WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG and WIFCONTINUED functions provided by the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="translated">最后一个管道关闭，反引号（ &lt;code&gt;``&lt;/code&gt; ）命令，成功调用 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; 或从 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 运算符返回的本机状态。在类似POSIX的系统上，可以使用&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块提供的WIFEXITED，WEXITSTATUS，WIFSIGNALED，WTERMSIG，WIFSTOPPED，WSTOPSIG和WIFCONTINUED函数对该值进行解码。</target>
        </trans-unit>
        <trans-unit id="2f679d50295d2d00d85ba280df81111988684878" translate="yes" xml:space="preserve">
          <source>The natural question: &quot;Why can't Perl compensate for the gaps?&quot; warrants an answer. One good reason is that C compilers might provide (non-ANSI) extensions permitting all sorts of fancy control over the way structures are aligned, even at the level of an individual structure field. And, if this were not enough, there is an insidious thing called &lt;code&gt;union&lt;/code&gt; where the amount of fill bytes cannot be derived from the alignment of the next item alone.</source>
          <target state="translated">自然的问题是：&amp;ldquo;为什么Perl无法弥补这些差距？&amp;rdquo; 有一个答案。一个很好的理由是C编译器可能会提供（非ANSI）扩展名，即使在单个结构字段的级别上，也可以对结构的对齐方式进行各种形式的控制。而且，如果这还不够的话，那么有一个阴险的事情叫做 &lt;code&gt;union&lt;/code&gt; ，其中填充字节的数量不能仅从下一项的对齐中得出。</target>
        </trans-unit>
        <trans-unit id="73304f2bc3720cbdf5bbe3a347ce1a6a6606cb3e" translate="yes" xml:space="preserve">
          <source>The natural way to do this is to have a hash whose keys are country names. Associated with each country name key is a list of the cities in that country. Each time you read a line of input, split it into a country and a city, look up the list of cities already known to be in that country, and append the new city to the list. When you're done reading the input, iterate over the hash as usual, sorting each list of cities before you print it out.</source>
          <target state="translated">自然而然的方法是有一个哈希,其键是国家名称。与每个国家名键相关联的是这个国家的城市列表。每次读取一行输入时,把它分成一个国家和一个城市,查找已经知道的那个国家的城市列表,并把新的城市追加到列表中。当你读完输入时,像往常一样在哈希中迭代,在打印出来之前对每个城市列表进行排序。</target>
        </trans-unit>
        <trans-unit id="9ba13cfae515a220e252c3e1157af722de7da0aa" translate="yes" xml:space="preserve">
          <source>The negation is useful for defining (surprise!) negated classes.</source>
          <target state="translated">否定式对于定义(惊喜!)被否定的类是有用的。</target>
        </trans-unit>
        <trans-unit id="db0ad6bd4816ce652496b94f2f1d7976b92ada0c" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_NN&lt;/code&gt; which elide the NULL pointer check.</source>
          <target state="translated">该宏 &lt;code&gt;OP_TYPE_ISNT&lt;/code&gt; 的取反以及 &lt;code&gt;OP_TYPE_IS_NN&lt;/code&gt; 和 &lt;code&gt;OP_TYPE_ISNT_NN&lt;/code&gt; 都可以使用，它们忽略了NULL指针检查。</target>
        </trans-unit>
        <trans-unit id="691f70fa29f72e49de97eccc12c05c1f840f1b46" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; which elide the NULL pointer check.</source>
          <target state="translated">该宏 &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; 的取反以及 &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; 和 &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; 都可以使用，它们可以忽略 NULL指针检查。</target>
        </trans-unit>
        <trans-unit id="a68f1f4d38ce035e2e238de529bbc7313afe802e" translate="yes" xml:space="preserve">
          <source>The new class is given a constructor method, &lt;code&gt;new&lt;/code&gt; , for creating struct objects.</source>
          <target state="translated">新类具有构造方法 &lt;code&gt;new&lt;/code&gt; ，用于创建struct对象。</target>
        </trans-unit>
        <trans-unit id="133a286ef1fa797920ffbacb6d543c092bbb9c81" translate="yes" xml:space="preserve">
          <source>The new compare function must be specified when you create the database.</source>
          <target state="translated">新的比较函数必须在创建数据库时指定。</target>
        </trans-unit>
        <trans-unit id="6ca5133e85084fb8ccd654bdee5f648c6a7925f9" translate="yes" xml:space="preserve">
          <source>The new interface to the USE_PERLIO implementation. The layers &quot;:crlf&quot; and &quot;:raw&quot; are only ones allowed for other implementations and those are silently ignored. (As of perl5.8 &quot;:raw&quot; is deprecated.) Use PerlIO_binmode() below for the portable case.</source>
          <target state="translated">USE_PERLIO 实现的新接口。&quot;:crlf&quot; 和 &quot;:raw&quot; 这两个层是其他实现所允许的,它们会被默默地忽略。(从 perl5.8 开始,&quot;:raw&quot; 已经过时了。)使用下面的 PerlIO_binmode()来处理可移植的情况。</target>
        </trans-unit>
        <trans-unit id="ef605716ebbaada258955508adf61e07c343c95f" translate="yes" xml:space="preserve">
          <source>The new key is specified by</source>
          <target state="translated">新钥匙由</target>
        </trans-unit>
        <trans-unit id="853b1cad8315c050b3031642990285f3b3f61796" translate="yes" xml:space="preserve">
          <source>The new perlIO layer is used. NI-S' favorite.</source>
          <target state="translated">使用了新的perlIO层。NI-S的最爱。</target>
        </trans-unit>
        <trans-unit id="3f44fc740bd8115fd48ea2f3dccbe8d30383620f" translate="yes" xml:space="preserve">
          <source>The new routine will be called whenever a built-in function is called without a qualifying package:</source>
          <target state="translated">每当调用一个没有限定包的内置函数时,新例程就会被调用。</target>
        </trans-unit>
        <trans-unit id="69fd8169a1c03a87b9cb7323668ea2985b78ca39" translate="yes" xml:space="preserve">
          <source>The new semantics are now only available with &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; . The old semantics are only available through &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; . Users are strongly encouraged to upgrade to at least 2.08 in order to avoid surprises.</source>
          <target state="translated">现在，新语义仅在 &lt;code&gt;make_path&lt;/code&gt; 和 &lt;code&gt;remove_tree&lt;/code&gt; 中可用。旧的语义只能通过 &lt;code&gt;mkpath&lt;/code&gt; 和 &lt;code&gt;rmtree&lt;/code&gt; 使用。强烈建议用户升级到至少2.08，以避免出现意外情况。</target>
        </trans-unit>
        <trans-unit id="dcb00043758d6e48f38e06be5dcd0156fe97d078" translate="yes" xml:space="preserve">
          <source>The new shiny result of either genuine new functionality or your arduous refactoring is now ready and correctly exported. So what could possibly go wrong?</source>
          <target state="translated">无论是真正的新功能还是您艰辛的重构,新的闪亮结果现在已经准备好了,并且正确地导出了。那么有什么可能出错呢?</target>
        </trans-unit>
        <trans-unit id="c231cf25130a94dd10bb860a955a6b6ad30c18f8" translate="yes" xml:space="preserve">
          <source>The new simpler way to call &lt;code&gt;XSLoader::load()&lt;/code&gt; with no arguments at all does not work on Perl 5.8.4 and 5.8.5.</source>
          <target state="translated">根本没有任何参数调用 &lt;code&gt;XSLoader::load()&lt;/code&gt; 的新的更简单的方法在Perl 5.8.4和5.8.5上不起作用。</target>
        </trans-unit>
        <trans-unit id="80d8983154af8008f3d7e48dfd488df835186d04" translate="yes" xml:space="preserve">
          <source>The new thread creation is line 20. We pass on to it a reference to the queue we've created, and the prime number we've found. In lines 21 through 24, we check to make sure that our new thread got created, and if not, we stop checking any remaining numbers in the queue.</source>
          <target state="translated">新的线程创建是第20行。我们将我们创建的队列和找到的质数的引用传递给它。在第21行到第24行,我们检查我们的新线程是否被创建,如果没有,我们停止检查队列中剩余的数字。</target>
        </trans-unit>
        <trans-unit id="9044c695c3da968e5a2ea15d51b8b1e2dbc7cbb0" translate="yes" xml:space="preserve">
          <source>The new() function searches for all the installed .packlists on the system, and stores their contents. The .packlists can be queried with the functions described below. Where it searches by default is determined by the settings found in &lt;code&gt;%Config::Config&lt;/code&gt; , and what the value is of the PERL5LIB environment variable.</source>
          <target state="translated">new（）函数搜索系统上所有已安装的.packlists，并存储其内容。可以使用以下功能查询.packlists。默认情况下，它的搜索位置取决于 &lt;code&gt;%Config::Config&lt;/code&gt; 以及PERL5LIB环境变量的值。</target>
        </trans-unit>
        <trans-unit id="5e76ad120503fe22fb2abd0288095a443b471d16" translate="yes" xml:space="preserve">
          <source>The newer style replaces these with underscores, like this:</source>
          <target state="translated">新的样式用下划线代替了这些,就像这样。</target>
        </trans-unit>
        <trans-unit id="0249c11220739d961eab9d8efdfb827caa468595" translate="yes" xml:space="preserve">
          <source>The newly created subroutine takes ownership of a reference to the passed in SV.</source>
          <target state="translated">新创建的子程序拥有对传入SV的引用的所有权。</target>
        </trans-unit>
        <trans-unit id="c36ff1fb86ca87ccc2385388c9e1be809de8496c" translate="yes" xml:space="preserve">
          <source>The next 8 bits contain the termination status of the program.</source>
          <target state="translated">后面8位包含程序的终止状态。</target>
        </trans-unit>
        <trans-unit id="429ca09b18f928ad50edc605bbb88976cae30220" translate="yes" xml:space="preserve">
          <source>The next example demonstrates how one would place an explicit undef in the return value, should the need arise.</source>
          <target state="translated">下一个例子演示了如何在返回值中放置一个显式的undef,如果需要的话。</target>
        </trans-unit>
        <trans-unit id="abdb50fe44b0e7ab1495a77ca76309d394c16e26" translate="yes" xml:space="preserve">
          <source>The next example show how to use the &lt;code&gt;LimitOutput&lt;/code&gt; option. Notice the use of two nested loops in this case. The outer loop reads the data from the input source - STDIN and the inner loop repeatedly calls &lt;code&gt;inflate&lt;/code&gt; until &lt;code&gt;$input&lt;/code&gt; is exhausted, we get an error, or the end of the stream is reached. One point worth remembering is by using the &lt;code&gt;LimitOutput&lt;/code&gt; option you also get &lt;code&gt;ConsumeInput&lt;/code&gt; set as well - this makes the code below much simpler.</source>
          <target state="translated">下一个示例显示如何使用 &lt;code&gt;LimitOutput&lt;/code&gt; 选项。注意在这种情况下使用两个嵌套循环。外循环从输入源-STDIN读取数据，内循环重复调用 &lt;code&gt;inflate&lt;/code&gt; ,直到 &lt;code&gt;$input&lt;/code&gt; 耗尽，我们得到一个错误，或到达流的末尾。值得记住的一点是，通过使用 &lt;code&gt;LimitOutput&lt;/code&gt; 选项，您还可以设置 &lt;code&gt;ConsumeInput&lt;/code&gt; ，这使下面的代码更加简单。</target>
        </trans-unit>
        <trans-unit id="a73f1f7691d7497b711d0f4bac2e881b3c885873" translate="yes" xml:space="preserve">
          <source>The next example shows each input parameter evaluated late.</source>
          <target state="translated">下一个例子显示了每一个输入参数的后期评估。</target>
        </trans-unit>
        <trans-unit id="def9f1245a38d3c5116ce761f9376e6f2078f597" translate="yes" xml:space="preserve">
          <source>The next examples will use the following C++ class.</source>
          <target state="translated">接下来的例子将使用以下C++类。</target>
        </trans-unit>
        <trans-unit id="6c82e2eba4791c1303c10eb37d70a72bf59badcd" translate="yes" xml:space="preserve">
          <source>The next option deals with the charset (a.k.a. character set) your terminal supports. In general, CPAN is English speaking territory, so the charset does not matter much but some CPAN have names that are outside the ASCII range. If your terminal supports UTF-8, you should say no to the next question. If it expects ISO-8859-1 (also known as LATIN1) then you should say yes. If it supports neither, your answer does not matter because you will not be able to read the names of some authors anyway. If you answer no, names will be output in UTF-8.</source>
          <target state="translated">下一個選項是關於你的終端機所支援的字符集(charset)。一般來說,CPAN 是英文的領域,所以字符集並不重要,但有些 CPAN 的名稱是在 ASCII 範圍之外的,如果你的終端支援 UTF-8,你應該對下一個問題說不。如果您的终端支持UTF-8,您应该对下一个问题说不。如果您的终端支持ISO-8859-1(也称为LATIN1),那么您应该说 &quot;是&quot;。如果两者都不支持,您的回答就不重要了,因为您无论如何都无法读取某些作者的名字。如果您回答 &quot;否&quot;,名字将以UTF-8输出。</target>
        </trans-unit>
        <trans-unit id="128477608ba084f3baead065e12f71790ccb5def" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt; es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="translated">&lt;code&gt;BRANCH&lt;/code&gt; es 的下一个指针很有趣，因为它指向分支失败时应该执行的位置。执行时，如果引擎尝试从分支遍历到不是分支的 &lt;code&gt;regnext&lt;/code&gt; ，则引擎将知道整个分支集都已失败。</target>
        </trans-unit>
        <trans-unit id="8b56244f1caeaf0b5b4e0b479de80d44c501b35d" translate="yes" xml:space="preserve">
          <source>The next step is interpolation in the text obtained, which is now delimiter-independent. There are multiple cases.</source>
          <target state="translated">下一步是在得到的文本中进行插值,现在的文本与分隔符无关。有多种情况。</target>
        </trans-unit>
        <trans-unit id="99d612978700e6928f957643eba3d0d61622b6ed" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system via email.</source>
          <target state="translated">下一步是通过电子邮件向Perl核心票务系统提交你的补丁。</target>
        </trans-unit>
        <trans-unit id="82a6f456a2c90d50e2abfb7f37ee6f9a4299445f" translate="yes" xml:space="preserve">
          <source>The next task is to break the problem down into smaller problems that are easily converted into a regexp.</source>
          <target state="translated">接下来的任务是将问题分解成容易转换为regexp的小问题。</target>
        </trans-unit>
        <trans-unit id="c9e21bae9fb5eef63978dcfa71c7a0d3cb21ec24" translate="yes" xml:space="preserve">
          <source>The next time you wish to make a patch, you need to start from the latest perl in a pristine state. Check you don't have any local changes or added files in your perl check-out which you wish to keep, then run these commands:</source>
          <target state="translated">下一次你想打补丁的时候,你需要从最新的perl原始状态开始。检查你的 perl check-out 中没有任何你希望保留的本地修改或添加的文件,然后运行这些命令。</target>
        </trans-unit>
        <trans-unit id="79f58ceb3f799f52310d0fb9160eed5d3d3eaba7" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is it's like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="translated">todo测试的好处是,相对于简单地注释出一个测试块,它就像拥有一个程序化的todo列表。你知道还有多少工作要做,你知道有哪些错误,而且你会立即知道它们何时被修复。</target>
        </trans-unit>
        <trans-unit id="92737be37077b1e4ee6685cd7da7d12b0a775c27" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C requires that certain things be set up in the console before Visual C will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run the &lt;code&gt;vcvars32.bat&lt;/code&gt; file to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; or &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; . On a typical install of a Microsoft C compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files\Microsoft Visual Studio\VC98\Bin. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="translated">Visual C ++附带的nmake足以满足构建要求。 Visual C要求成功运行Visual C之前，必须在控制台中进行某些设置。要使控制台能够运行C编译器，您需要事先运行 &lt;code&gt;vcvars32.bat&lt;/code&gt; 文件以针对x86-32和x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; 或 &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; 进行编译。在典型安装的Microsoft C编译器产品上，这些批处理文件将已经在 &lt;code&gt;PATH&lt;/code&gt; 中环境变量，因此您可以在控制台中输入它们而无需绝对路径。如果您需要找到批处理文件的绝对路径，通常可以在C：\ Program Files \ Microsoft Visual Studio \ VC98 \ Bin之类的位置找到它。对于某些较新的Micrsoft C产品（〜2004年以后发行），安装程序将在开始菜单中放置一个快捷方式，以启动新的控制台窗口，并已为目标体系结构设置了控制台（x86-32或x86-64或IA64）。 。对于较新的编译器，您可以选择使用较旧的批处理文件。</target>
        </trans-unit>
        <trans-unit id="d92d9609b16a9236c6b0750e878097cebaf141fa" translate="yes" xml:space="preserve">
          <source>The nmake that comes with the Platform SDK will suffice for building Perl. Make sure you are building within one of the &quot;Build Environment&quot; shells available after you install the Platform SDK from the Start Menu.</source>
          <target state="translated">平台SDK自带的nmake就可以满足构建Perl的需要。确保你是在从开始菜单安装Platform SDK后,在 &quot;Build Environment &quot;shell中进行编译。</target>
        </trans-unit>
        <trans-unit id="4cf437af831d898cd280f5f9fa16e3b19f38db9a" translate="yes" xml:space="preserve">
          <source>The node type, either &lt;code&gt;section&lt;/code&gt; or &lt;code&gt;item&lt;/code&gt; . As an unofficial type, there is also &lt;code&gt;hyperlink&lt;/code&gt; , derived from e.g. &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">节点类型，可以是 &lt;code&gt;section&lt;/code&gt; 或 &lt;code&gt;item&lt;/code&gt; 。作为非官方类型，还存在 &lt;code&gt;hyperlink&lt;/code&gt; ，例如从 &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; &lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt; &amp;gt;派生而来。</target>
        </trans-unit>
        <trans-unit id="8827c5b69a11959983a358ee79f064e14c978f0c" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt; ):</source>
          <target state="translated">非破坏性修饰符 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 导致返回替换结果，而不是修改 &lt;code&gt;$_&lt;/code&gt; （或使用 &lt;code&gt;=~&lt;/code&gt; 绑定到替换变量的任何变量）：</target>
        </trans-unit>
        <trans-unit id="d3e24c19053882dd3539c4f0f017c48b302d8630" translate="yes" xml:space="preserve">
          <source>The non-zero numeric</source>
          <target state="translated">非零数字</target>
        </trans-unit>
        <trans-unit id="ed0d308e2d36922ca367c5db784707665a50eda8" translate="yes" xml:space="preserve">
          <source>The normal Makefile.PL that h2xs generates doesn't know about the mylib directory. We need to tell it that there is a subdirectory and that we will be generating a library in it. Let's add the argument MYEXTLIB to the WriteMakefile call so that it looks like this:</source>
          <target state="translated">h2xs生成的普通Makefile.PL不知道mylib目录。我们需要告诉它有一个子目录,并且我们将在其中生成一个库。让我们在WriteMakefile调用中添加参数MYEXTLIB,这样它看起来就像这样。</target>
        </trans-unit>
        <trans-unit id="b1469f4963ec233a67445e77b1dc5adf4ccf9ab7" translate="yes" xml:space="preserve">
          <source>The normal course of action is to call:</source>
          <target state="translated">正常的做法是打电话。</target>
        </trans-unit>
        <trans-unit id="ecf683f52c0f42f564cf7e0ed381f4bb97cc8438" translate="yes" xml:space="preserve">
          <source>The normal use of this class is like so:</source>
          <target state="translated">这个类的正常使用是这样的。</target>
        </trans-unit>
        <trans-unit id="1ac2010e9cf7828bd4211d3176636428b6a9a255" translate="yes" xml:space="preserve">
          <source>The normal way to run a Perl program is by making it directly executable, or else by passing the name of the source file as an argument on the command line. (An interactive Perl environment is also possible--see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; for details on how to do that.) Upon startup, Perl looks for your program in one of the following places:</source>
          <target state="translated">运行Perl程序的通常方法是使其直接可执行，或者通过在命令行上传递源文件的名称作为参数。（也可以使用交互式Perl环境- 有关如何执行此&lt;a href=&quot;perldebug&quot;&gt;操作&lt;/a&gt;的详细信息，请参见perldebug。）启动后，Perl在以下位置之一查找程序：</target>
        </trans-unit>
        <trans-unit id="46672cb58512b6dfcf1bfa852b6fb1012267b6a3" translate="yes" xml:space="preserve">
          <source>The notation still looks a little cumbersome, so there's one more abbreviation:</source>
          <target state="translated">符号还是显得有些繁琐,所以多了一个缩写。</target>
        </trans-unit>
        <trans-unit id="faf2109c5b26dde1813deee78331f15408acfe4a" translate="yes" xml:space="preserve">
          <source>The notion that an empty &lt;b&gt;derived class&lt;/b&gt; should behave exactly like its &lt;b&gt;base class&lt;/b&gt;.</source>
          <target state="translated">空&lt;b&gt;派生类的&lt;/b&gt;行为应与其&lt;b&gt;基类&lt;/b&gt;完全相同的概念。</target>
        </trans-unit>
        <trans-unit id="d26e84b13c8c8748080fe4085da63e6e9ef520f9" translate="yes" xml:space="preserve">
          <source>The notion that you can tell an &lt;b&gt;object&lt;/b&gt; to do something generic, and the object will interpret the command in different ways depending on its type. [&amp;lt; Greek &amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, many forms.]</source>
          <target state="translated">您可以告诉&lt;b&gt;对象&lt;/b&gt;执行通用操作的概念，并且对象将根据其类型以不同的方式解释命令。[&amp;lt;希腊语&amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;-+ &amp;mu;&amp;omicron;&amp;rho;ϕή，有多种形式。]</target>
        </trans-unit>
        <trans-unit id="ad272f88bed19c2e6cec366907b96e0baf112d7c" translate="yes" xml:space="preserve">
          <source>The notion that, with a complete set of simple tools that work well together, you can build almost anything you want. Which is fine if you&amp;rsquo;re assembling a tricycle, but if you&amp;rsquo;re building a defranishizing comboflux regurgalator, you really want your own machine shop in which to build special tools. Perl is sort of a machine shop.</source>
          <target state="translated">有了一套完整的简单工具，它们可以很好地协同工作，您可以构建几乎任何想要的东西。如果您要组装三轮车，那很好，但是如果您要制造脱色的康菲斯回流调节器，那么您真的希望自己的机械车间可以制造特殊的工具。Perl就像是一家机械厂。</target>
        </trans-unit>
        <trans-unit id="d8cd6888cbc4c56537079a3ca6af05881fde2aca" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt; , which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="translated">空文件句柄 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 是特殊的：它可用于模拟&lt;b&gt;sed&lt;/b&gt;和&lt;b&gt;awk&lt;/b&gt;以及其他任何使用文件名列表的Unix过滤器程序的行为，对所有文件名的每一行都执行相同的操作。来自 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 的输入或者来自标准输入，或者来自命令行上列出的每个文件。它是这样工作的：第一次计算 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 时，将检查 &lt;code&gt;@ARGV&lt;/code&gt; 数组，如果它为空，则 &lt;code&gt;$ARGV[0]&lt;/code&gt; 设置为 &lt;code&gt;&quot;-&quot;&lt;/code&gt; ，当打开时会为您提供标准输入。然后，将 &lt;code&gt;@ARGV&lt;/code&gt; 数组作为文件名列表进行处理。循环</target>
        </trans-unit>
        <trans-unit id="6d22af8d2b7cf7cf2c570f3f335ab2a750c99b68" translate="yes" xml:space="preserve">
          <source>The null list is represented by (). Interpolating it in a list has no effect. Thus ((),(),()) is equivalent to (). Similarly, interpolating an array with no elements is the same as if no array had been interpolated at that point.</source>
          <target state="translated">空列表用()表示。在列表中对其进行插值,没有效果。因此((),(),())相当于()。同理,对一个没有元素的数组进行插值,与此时没有数组插值是一样的。</target>
        </trans-unit>
        <trans-unit id="1797c45a73a5a87e1dcbfe3ceafa93cc5c4f9d01" translate="yes" xml:space="preserve">
          <source>The null loop times can be cached, the key being the number of rounds. The caching can be controlled using calls like these:</source>
          <target state="translated">可以缓存空循环时间,关键是轮数。缓存可以使用这样的调用来控制。</target>
        </trans-unit>
        <trans-unit id="c43d1fda274f03a112b4082e8056292b9c40d862" translate="yes" xml:space="preserve">
          <source>The number 0, the strings &lt;code&gt;'0'&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , the empty list &lt;code&gt;()&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; are all false in a boolean context. All other values are true. Negation of a true value by &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; returns a special false value. When evaluated as a string it is treated as &lt;code&gt;&quot;&quot;&lt;/code&gt; , but as a number, it is treated as 0. Most Perl operators that return true or false behave this way.</source>
          <target state="translated">在布尔上下文中，数字0，字符串 &lt;code&gt;'0'&lt;/code&gt; 和 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，空列表 &lt;code&gt;()&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 均为false。所有其他值都是正确的。否定真值 &lt;code&gt;!&lt;/code&gt; 或 &lt;code&gt;not&lt;/code&gt; 返回特殊的false值。以字符串形式求值时，将其视为 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，而将其视为数字，则将其视为0。大多数返回true或false的Perl运算符都将以这种方式运行。</target>
        </trans-unit>
        <trans-unit id="692f2a5740e6be2f2f4c50b1195b7318b218c93b" translate="yes" xml:space="preserve">
          <source>The number after Perl (i.e. the 5 after Perl 5) is the major release of the perl interpreter as well as the version of the language. Each major version has significant differences that earlier versions cannot support.</source>
          <target state="translated">Perl后面的数字(即Perl 5后面的5)是perl解释器的主要版本以及语言的版本。每一个主要版本都有早期版本无法支持的重大差异。</target>
        </trans-unit>
        <trans-unit id="3191b134cb3717b47b8c71b05a1d940752bad987" translate="yes" xml:space="preserve">
          <source>The number for the &quot;generation&quot; of the test run. The first generation is 1 (one) and subsequent generations are 2, 3, etc.</source>
          <target state="translated">测试运行的 &quot;代数&quot;。第一代为1(1),以后的代数为2、3等。</target>
        </trans-unit>
        <trans-unit id="fa99ba7fda4b251af40087fa9ad0d33252bbd195" translate="yes" xml:space="preserve">
          <source>The number of concurrent jobs this formatter will handle.</source>
          <target state="translated">该表格器将处理的并发作业数量。</target>
        </trans-unit>
        <trans-unit id="5d2ba45a48d3868e33de1ec7e956df019e81e42a" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after av_fill() returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt; .</source>
          <target state="translated">av_fill（）返回后，数组中的元素数将为 &lt;code&gt;fill + 1&lt;/code&gt; 。如果数组以前较短，则附加的其他元素将设置为NULL。如果数组较长，则释放多余的元素。 &lt;code&gt;av_fill(av, -1)&lt;/code&gt; 与 &lt;code&gt;av_clear(av)&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b9161f7d8230483ece3123e0d04957cb7a945f72" translate="yes" xml:space="preserve">
          <source>The number of items in a hash can be obtained by doing:</source>
          <target state="translated">可以通过做获得哈希中的项目数。</target>
        </trans-unit>
        <trans-unit id="e4c9a33204f057eb951c01e0df7449caf0e7389f" translate="yes" xml:space="preserve">
          <source>The number of lines left on the page of the currently selected output channel.</source>
          <target state="translated">当前选择的输出通道的页面剩余行数。</target>
        </trans-unit>
        <trans-unit id="8b661ef45c3e83256fc7a63d23f91b2343af29ac" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt; . The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) variable. Many error messages report both values, if available.</source>
          <target state="translated">在此之前读取的行数加1。Perl为打开的每个源文件或输入文件保留一个单独的行号。当前源文件的行号由 &lt;code&gt;__LINE__&lt;/code&gt; 表示。当前输入行号（对于最近通过 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; 读取的文件）用 &lt;code&gt;$.&lt;/code&gt; 表示。（ &lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ）变量。许多错误消息报告两个值（如果有）。</target>
        </trans-unit>
        <trans-unit id="7adfc7b3eafb7c58d678ada0cc8dfa22b0798638" translate="yes" xml:space="preserve">
          <source>The number of seconds the program ran for before being terminated, or 0 if no timeout occurred.</source>
          <target state="translated">终止前程序运行的秒数,如果没有超时,则为0。</target>
        </trans-unit>
        <trans-unit id="701c3dee8ddb529dd17cdf0b20bfe4db85c06698" translate="yes" xml:space="preserve">
          <source>The number of spaces to indent regular text, and the default indentation for &lt;code&gt;=over&lt;/code&gt; blocks. Defaults to 4.</source>
          <target state="translated">要缩进常规文本的空格数，以及 &lt;code&gt;=over&lt;/code&gt; 块的默认缩进。默认为4。</target>
        </trans-unit>
        <trans-unit id="65eb3487d858db8bd02f6c81679897d6d005441b" translate="yes" xml:space="preserve">
          <source>The number of tests in your script. This means all ok() and skip() calls.</source>
          <target state="translated">脚本中的测试次数。这意味着所有的ok()和skip()调用。</target>
        </trans-unit>
        <trans-unit id="c2e318858e274a3b2d56e4e8546a3453a590b339" translate="yes" xml:space="preserve">
          <source>The number of tests with TODO directives.</source>
          <target state="translated">有TODO指令的测试数量。</target>
        </trans-unit>
        <trans-unit id="c43b06bec0238ed7c22fd0d6e38144c2bb8f0d70" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; routine.</source>
          <target state="translated">引用结构的次数。当它降至0时，通过调用pregfree自动释放regexp。在每个引擎的&lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt;例程中应将其设置为1 。</target>
        </trans-unit>
        <trans-unit id="c7aa069edb979af7f298ec7da8f6245a682e62f6" translate="yes" xml:space="preserve">
          <source>The number of times the test has failed.</source>
          <target state="translated">测试失败的次数。</target>
        </trans-unit>
        <trans-unit id="f294a946b3a2f3d15985548e48a89b85b334300e" translate="yes" xml:space="preserve">
          <source>The number of times the test has passed.</source>
          <target state="translated">测试通过的次数。</target>
        </trans-unit>
        <trans-unit id="6ecf3312d862847aadfe59c31f3bcfa85cc3016b" translate="yes" xml:space="preserve">
          <source>The numbering within each branch will be as normal, and any groups following this construct will be numbered as though the construct contained only one branch, that being the one with the most capture groups in it.</source>
          <target state="translated">每个分支内的编号将与正常情况一样,该构造后的任何组将被编号,就好像该构造只包含一个分支,即其中有最多捕获组的那个分支。</target>
        </trans-unit>
        <trans-unit id="d3f5b7856c836d8ae15bae5d2911f695737356ba" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigFloat. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">数字以对象的形式存储,其内部可能随时发生变化,特别是在数学运算之间。这些对象也可能属于不同的类,比如Math::BigInt,或者Math::BigFloat。将它们混合在一起,即使是普通的标量,也不是什么特别的事情,而是正常的,也是意料之中的事情。</target>
        </trans-unit>
        <trans-unit id="0d52076285e4f235f1d8532711b46d3578467720" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigInt::Lite. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">数字以对象的形式存储,其内部可能随时发生变化,特别是在数学运算之间。这些对象也可能属于不同的类,比如Math::BigInt,或者Math::BigInt::Lite。将它们混合在一起,即使是普通的标量,也不是什么特别的事情,而是正常的,也是意料之中的事情。</target>
        </trans-unit>
        <trans-unit id="d62316f7524c3cde4e634f1fd21e7ac49fd46233" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to 0777), to be modified by the current &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="translated">应用于每个已创建目录的数字权限模式（默认为0777），由当前 &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 修改。如果目录已经存在（因此不需要创建），则不会修改权限。</target>
        </trans-unit>
        <trans-unit id="41e019f9571f72909dc6712d8ba72dd87f1a9db6" translate="yes" xml:space="preserve">
          <source>The numeric value of the COP's hint flags, or an empty string if this is not a COP.</source>
          <target state="translated">COP的提示标志的数值,如果不是COP,则为空字符串。</target>
        </trans-unit>
        <trans-unit id="419fea734cd75b36bfd625f906eafadf3594cbdf" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's flags.</source>
          <target state="translated">OP标志的数值。</target>
        </trans-unit>
        <trans-unit id="e13f8ed0a121e4b7f2050aa9d7bd9bd36bdb9772" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's private flags.</source>
          <target state="translated">OP的私有标志的数值。</target>
        </trans-unit>
        <trans-unit id="afdb5b0bce9be5274063464faba90d66849c8cbe" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's targ.</source>
          <target state="translated">上文中的targ的数值。</target>
        </trans-unit>
        <trans-unit id="e4bd78ffa7c276231e5c09572ec79b0007d54b06" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's type, in decimal.</source>
          <target state="translated">OP类型的数值,以十进制表示。</target>
        </trans-unit>
        <trans-unit id="4a6a6fda3b81e72660dadfe40e0c6cbbf8b62d9b" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">该对象被重新赋予 &lt;code&gt;IO::Handle&lt;/code&gt; 的子类，并成为管道读取端的句柄。如果给出了 &lt;code&gt;ARGS&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ，并将 &lt;code&gt;ARGS&lt;/code&gt; 传递给exec。</target>
        </trans-unit>
        <trans-unit id="7b25df29627971e66202a04141c07ea01261d426" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">该对象被重新赋予 &lt;code&gt;IO::Handle&lt;/code&gt; 的子类，并成为管道写入端的句柄。如果给出了 &lt;code&gt;ARGS&lt;/code&gt; ，则调用 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ，并将 &lt;code&gt;ARGS&lt;/code&gt; 传递给exec。</target>
        </trans-unit>
        <trans-unit id="40e63c161da60788dfbf25012eced379198e6461" translate="yes" xml:space="preserve">
          <source>The object or class on which a method is called is passed as one of the method's arguments, not as a separate &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="translated">调用方法的对象或类作为方法的参数之一传递，而不是作为单独的 &lt;code&gt;this&lt;/code&gt; 值传递。</target>
        </trans-unit>
        <trans-unit id="15b98c3fd23a1ef70ae8197a79094d62be1e4c5c" translate="yes" xml:space="preserve">
          <source>The object oriented interface to &lt;code&gt;Digest::MD5&lt;/code&gt; is described in this section. After a &lt;code&gt;Digest::MD5&lt;/code&gt; object has been created, you will add data to it and finally ask for the digest in a suitable format. A single object can be used to calculate multiple digests.</source>
          <target state="translated">本节介绍了 &lt;code&gt;Digest::MD5&lt;/code&gt; 面向对象的接口。一个经过 &lt;code&gt;Digest::MD5&lt;/code&gt; 对象已经创建，您将数据添加到它，最后以合适的格式要求的摘要。单个对象可用于计算多个摘要。</target>
        </trans-unit>
        <trans-unit id="e33be9a872157d87d04d9ab372ad71b851a50cce" translate="yes" xml:space="preserve">
          <source>The object registry is also used to repair a field hash after thread cloning. Here, the entire object registry is processed. For every reference found there, the field hashes it has used are visited and the entry is updated.</source>
          <target state="translated">对象注册表也是用来修复线程克隆后的字段哈希。在这里,整个对象注册表都会被处理。对于在那里发现的每一个引用,都会访问它所使用的字段哈希,并更新条目。</target>
        </trans-unit>
        <trans-unit id="90c880f65630ae33e5e929b9f5badc61ea20d016" translate="yes" xml:space="preserve">
          <source>The object registry keeps track of references that have been used as field hash keys. The keys are generated from the reference address like in a field hash (though the registry isn't a field hash). Each value is a weak copy of the original reference, stored in an &lt;code&gt;SV&lt;/code&gt; that is itself magical (&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; again). The magical structure holds a list (another hash, really) of field hashes that the reference has been used with. When the weakref becomes stale, the magic is activated and uses the list to delete the reference from all field hashes it has been used with. After that, the entry is removed from the object registry itself. Implicitly, that frees the magic structure and the storage it has been using.</source>
          <target state="translated">对象注册表跟踪已用作字段哈希键的引用。键是从参考地址生成的，就像在字段哈希中一样（尽管注册表不是字段哈希）。每个值都是原始参考的弱副本，存储在本身就是魔术的 &lt;code&gt;SV&lt;/code&gt; 中（再次是 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; ）。神奇的结构保存了与引用一起使用的字段哈希的列表（实际上是另一个哈希）。当weakref变得陈旧时，魔术会被激活并使用该列表从与之一起使用的所有字段散列中删除引用。之后，该条目将从对象注册表本身中删除。隐式地，这释放了魔术结构及其一直在使用的存储空间。</target>
        </trans-unit>
        <trans-unit id="d72391ab64988da73b0a894ff996ef426650aa27" translate="yes" xml:space="preserve">
          <source>The object returned by &lt;code&gt;builder()&lt;/code&gt; may change at runtime so you should call &lt;code&gt;builder()&lt;/code&gt; inside each function rather than store it in a global.</source>
          <target state="translated">&lt;code&gt;builder()&lt;/code&gt; 返回的对象可能会在运行时更改，因此您应该在每个函数内调用 &lt;code&gt;builder()&lt;/code&gt; 而不是将其存储在全局函数中。</target>
        </trans-unit>
        <trans-unit id="afec221431749f399e52c9677871688987dfbb46" translate="yes" xml:space="preserve">
          <source>The oct() function is commonly used when a string such as &lt;code&gt;644&lt;/code&gt; needs to be converted into a file mode, for example. Although Perl automatically converts strings into numbers as needed, this automatic conversion assumes base 10.</source>
          <target state="translated">例如，当需要将诸如 &lt;code&gt;644&lt;/code&gt; 之类的字符串转换为文件模式时，通常使用oct（）函数。尽管Perl会根据需要自动将字符串转换为数字，但是此自动转换假定以10为底。</target>
        </trans-unit>
        <trans-unit id="09c9c348da6207c41e75d17f6b539e26d9c4cd1f" translate="yes" xml:space="preserve">
          <source>The official (threaded) builds from HP, as they are shipped on the Application DVD/CD's are available on &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt; for both PA-RISC and IPF (Itanium Processor Family). They are built with the HP ANSI-C compiler. Up till 5.8.8 that was done by ActiveState.</source>
          <target state="translated">对于HP 和PA-RISC ，官方的（线程化的）构建都来自应用DVD / CD上的出厂版本，可从&lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt;获得。和IPF（Itanium处理器系列）。它们是使用HP ANSI-C编译器构建的。直到5.8.8由ActiveState完成。</target>
        </trans-unit>
        <trans-unit id="122c2a7e4876853c52ff4c6bbc23491cac5b2166" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at rt.perl.org. All participants in discussion there are expected to adhere to a standard of conduct.</source>
          <target state="translated">开发perl的官方论坛是上面提到的perl5-porters邮件列表,以及它的bug跟踪器rt.perl.org。所有参与讨论的人都应该遵守行为标准。</target>
        </trans-unit>
        <trans-unit id="318a2a25e89f6df5d0fee0930895c69196eba39a" translate="yes" xml:space="preserve">
          <source>The official name of VMS as of this writing is OpenVMS.</source>
          <target state="translated">截至目前,VMS的正式名称是OpenVMS。</target>
        </trans-unit>
        <trans-unit id="9e04119b1083995ffa8b809847e51388388f1606" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is</source>
          <target state="translated">Berkeley DB的官方网站是</target>
        </trans-unit>
        <trans-unit id="065d987b91e5e5831e84ee6eb6792bbd1900fe0e" translate="yes" xml:space="preserve">
          <source>The old behaviour of immediate croaking can be re-instated by setting &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; to some &lt;code&gt;FALSE&lt;/code&gt; value.</source>
          <target state="translated">立即呱呱叫的旧行为可以通过设置重新设置 &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; 一些 &lt;code&gt;FALSE&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="5b386f850ac3d208fd4890f0e6e16aecfa5e9221" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt; , can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">可以使用 &lt;code&gt;&quot;style&quot;&lt;/code&gt; 参数更改可以具有 &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;polar&quot;&lt;/code&gt; 值的旧显示格式样式。</target>
        </trans-unit>
        <trans-unit id="e3404a80aca7096e4f7cc6df65a56468be124f24" translate="yes" xml:space="preserve">
          <source>The old form of gv_init_pvn(). It does not work with UTF8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the GV_ADDMULTI flag will be passed to gv_init_pvn().</source>
          <target state="translated">gv_init_pvn（）的旧形式。它不具有UTF8字符串，因为它没有flags参数。如果设置了 &lt;code&gt;multi&lt;/code&gt; 参数，则GV_ADDMULTI标志将传递给gv_init_pvn（）。</target>
        </trans-unit>
        <trans-unit id="79188e84f37b880e4a772b5ff3206627de3b874e" translate="yes" xml:space="preserve">
          <source>The old home for the module tests, you shouldn't put anything new in here. There are still some bits and pieces hanging around in here that need to be moved. Perhaps you could move them? Thanks!</source>
          <target state="translated">模块测试的老家,你不应该在这里放任何新东西。还有一些零碎的东西挂在这里,需要移动。也许你可以把它们搬走?谢谢你!</target>
        </trans-unit>
        <trans-unit id="37d530fbe2e5d190496e0bd800701dfa6c514e1c" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; , you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt; ; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt; , which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; .</source>
          <target state="translated">旧的包定界符是单引号，但现在双冒号是首选的定界符，部分原因是它对人类更易读，部分原因是对&lt;b&gt;emacs&lt;/b&gt;宏更易读。这也使C ++程序员感到自己知道发生了什么&amp;mdash;而不是使用单引号作为分隔符，这使Ada程序员感到自己知道发生了什么。因为仍然支持老式语法以实现向后兼容性，所以如果您尝试使用诸如 &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; 类的字符串，则将访问 &lt;code&gt;$owner::s&lt;/code&gt; ;也就是说，包 &lt;code&gt;owner&lt;/code&gt; 的$ s变量可能不是您的意思。使用括号消除歧义，例如 &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6c9fb581904d8c9128af585c935239bf8557de2" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="translated">较旧（且可能已过时）的库&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da753c735f79a0349646d5159490ba674b8d624f" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="translated">较旧的库&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod :: SAX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="995ae7aa276ffe30824f52880be0efab53f1e92d" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;,
$bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; .</source>
          <target state="translated">add_bits（）的一个参数形式采用$ bitstring的&amp;ldquo; 1&amp;rdquo;和&amp;ldquo; 0&amp;rdquo;字符作为参数。这是 &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;, $bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="7fb0ed6067910ab4f7c54b4b88cf43df00178824" translate="yes" xml:space="preserve">
          <source>The one parameter calling convention also still works.</source>
          <target state="translated">一个参数的调用惯例也依然有效。</target>
        </trans-unit>
        <trans-unit id="80912f94b4001d6702c4a5ac8c13128730d9bdf7" translate="yes" xml:space="preserve">
          <source>The one user (apart from the superuser) who has absolute control over a &lt;b&gt;file&lt;/b&gt;. A file may also have a &lt;b&gt;group&lt;/b&gt; of users who may exercise joint ownership if the real owner permits it. See &lt;b&gt;permission bits&lt;/b&gt;.</source>
          <target state="translated">对&lt;b&gt;文件&lt;/b&gt;具有绝对控制权的一个用户（超级用户除外）。文件也可以有一&lt;b&gt;组&lt;/b&gt;用户，如果真实所有者允许，则可以行使共同所有权。请参阅&lt;b&gt;权限位&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="bf794f433c5b5ee5b62cabad4f9e0efe662e76bb" translate="yes" xml:space="preserve">
          <source>The only absolutely mandatory method. Called when the layer is pushed onto the stack. The &lt;code&gt;mode&lt;/code&gt; argument may be NULL if this occurs post-open. The &lt;code&gt;arg&lt;/code&gt; will be non-&lt;code&gt;NULL&lt;/code&gt; if an argument string was passed. In most cases this should call &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; to convert &lt;code&gt;mode&lt;/code&gt; into the appropriate &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; flags in addition to any actions the layer itself takes. If a layer is not expecting an argument it need neither save the one passed to it, nor provide &lt;code&gt;Getarg()&lt;/code&gt; (it could perhaps &lt;code&gt;Perl_warn&lt;/code&gt; that the argument was un-expected).</source>
          <target state="translated">唯一绝对强制的方法。在将层推入堆栈时调用。该 &lt;code&gt;mode&lt;/code&gt; 参数可以为NULL，如果发生这种情况后开放。该 &lt;code&gt;arg&lt;/code&gt; 将非 &lt;code&gt;NULL&lt;/code&gt; 如果参数字符串传递。在大多数情况下，除了层本身执行的任何操作之外，还应该调用 &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; 将 &lt;code&gt;mode&lt;/code&gt; 转换为适当的 &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; 标志。如果某个层不希望有参数，则它既不需要保存传递​​给它的参数，也不需要提供 &lt;code&gt;Getarg()&lt;/code&gt; （它可能会 &lt;code&gt;Perl_warn&lt;/code&gt; 指出该参数是意外的）。</target>
        </trans-unit>
        <trans-unit id="8efd8a42e658c0f7e91c83e2d2d53f100f4033a8" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt; , (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="translated">唯一的区别是由于 &lt;code&gt;string_vianame&lt;/code&gt; 是运行时，而 &lt;code&gt;\N{}&lt;/code&gt; 是编译时。您不能在 &lt;code&gt;\N{}&lt;/code&gt; 内插值（因此 &lt;code&gt;\N{$variable}&lt;/code&gt; 不起作用）；如果输入名称未知，则 &lt;code&gt;string_vianame&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 而不是语法错误。</target>
        </trans-unit>
        <trans-unit id="341b8df1dab5c18fe08d27199395d7d12fe5908e" translate="yes" xml:space="preserve">
          <source>The only flag specified this time was G_SCALAR. That means that the &lt;code&gt;@_&lt;/code&gt; array will be created and that the value returned by</source>
          <target state="translated">这次指定的唯一标志是G_SCALAR。这意味着将创建 &lt;code&gt;@_&lt;/code&gt; 数组，并且由返回的值</target>
        </trans-unit>
        <trans-unit id="1be9c07fcdeba873e922d933912b59d6dffd7f9b" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt; . Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">唯一的插值是从 &lt;code&gt;\\&lt;/code&gt; 对中删除 &lt;code&gt;\&lt;/code&gt; 。因此， &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; 中的 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 实际上被视为连字符，并且没有可用的字符范围。替换 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; 中的 &lt;code&gt;\1&lt;/code&gt; 不能用作 &lt;code&gt;$1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12717cd3a47ff8f730f2ca2276f3a722ee0a85b7" translate="yes" xml:space="preserve">
          <source>The only issue left is to how to bootstrap</source>
          <target state="translated">唯一剩下的问题是如何启动</target>
        </trans-unit>
        <trans-unit id="77cda32153e2808e7ed17b43ef801a42c30a29bd" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; that</source>
          <target state="translated">唯一一种简单的语句是评估其副作用的表达式。每个简单的语句都必须以分号结尾，除非它是一个块中的最终语句，在这种情况下，分号是可选的。但是，如果该块占用多于一行，则无论如何都应使用分号，因为您最终可能会添加另一行。需要注意的是有像运营商 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; ，并 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; 这</target>
        </trans-unit>
        <trans-unit id="3f747c4ca5428591254eb88eeb68548667575b4e" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;Prior to Perl v5.22&lt;/a&gt;).</source>
          <target state="translated">几乎可以肯定，此编译指示的唯一合法使用是每个文件只有一个文件（在顶部，具有文件范围），因为该文件很可能只会以一种编码来编写。在v5.22 &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;之前的&lt;/a&gt; Perls中有更多限制（请参阅Perl v5.22之前的版本）。</target>
        </trans-unit>
        <trans-unit id="34c58516de1f8035b02dd5ba10465691170b3177" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt; . To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt; . Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt; , which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="translated">Perl可能支持的唯一多字节（或宽字符）语言环境是UTF-8。这是由于实施的困难，高质量的UTF-8语言环境现已在世界上的每个地区（&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;）发布的事实所致。可以使用&lt;a href=&quot;encode&quot;&gt;编码&lt;/a&gt;转换为您的语言环境的模块。因此，如果您使用这些语言环境之一（例如Big5或Shift JIS），则必须执行这些操作之一。对于UTF-8语言环境，在没有完全UTF-8语言环境支持的Perls（v5.20之前）中，它们可能工作得相当好（取决于您的C库实现），只是因为它们和Perl都存储了占用字符的字符多个字节以相同的方式。但是，即使不是大多数，某些C库实现也可能无法在 &lt;code&gt;LC_CTYPE&lt;/code&gt; 下正确处理Latin-1范围（128-255）中上半部分的字符。要查看某个字符在语言环境下是否为特定类型，Perl使用了 &lt;code&gt;isalnum()&lt;/code&gt; 之类的函数。您的C库可能不适用于具有这些功能的UTF-8语言环境，而是只能在较新的广泛库函数下工作，例如 &lt;code&gt;iswalnum()&lt;/code&gt; ，Perl不使用。这些多字节语言环境被视为单字节语言环境，并且将具有以下限制。从Perl v5.22开始，当Perl检测到它不完全支持的多字节语言环境时，将引发警告消息。</target>
        </trans-unit>
        <trans-unit id="81ecbc2496d990405244fb5517f23afeb52e9228" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame(name) in charnames&lt;/a&gt;, and &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Perl当前支持的唯一非字符属性是&amp;ldquo;命名序列&amp;rdquo;，其中代码点序列被赋予一个名称，通常被视为单个实体。（Perl通过 &lt;code&gt;\N{...}&lt;/code&gt; 双引号结构，&lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames中的charnames :: string_vianame（name）&lt;/a&gt;和&lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;Unicode :: UCD中的namedseq（）&lt;/a&gt;支持这些功能。</target>
        </trans-unit>
        <trans-unit id="4392ba6f21132243d1d665e363dbf9f2d5cd7f44" translate="yes" xml:space="preserve">
          <source>The only non-single-byte locale Perl supports is (starting in v5.20) UTF-8. This means that code points above 255 are treated as Unicode no matter what locale is in effect (since UTF-8 implies Unicode).</source>
          <target state="translated">Perl 唯一支持的非单字节语言是 UTF-8(从 v5.20 开始)。这意味着,无论使用的是哪种locale,255以上的代码点都会被视为Unicode(因为UTF-8意味着Unicode)。</target>
        </trans-unit>
        <trans-unit id="9a67bc69297226e55a92fe7a2acd416579cf6146" translate="yes" xml:space="preserve">
          <source>The only objective benefit to using &lt;code&gt;DirHandle&lt;/code&gt; is that it avoids namespace pollution by creating globs to hold directory handles.</source>
          <target state="translated">使用 &lt;code&gt;DirHandle&lt;/code&gt; 的唯一客观好处是，它通过创建glob来保存目录句柄来避免名称空间污染。</target>
        </trans-unit>
        <trans-unit id="29b92533d26d29124ecd17a1f17bcca141dd3115" translate="yes" xml:space="preserve">
          <source>The only other constraint is you must pre-declare how many tests you plan to run. This is in case something goes horribly wrong during the test and your test program aborts, or skips a test or whatever. You do this like so:</source>
          <target state="translated">唯一的限制是你必须预先声明你计划运行多少测试。这是为了防止在测试过程中出现可怕的错误,你的测试程序中止,或跳过一个测试或其他什么。你可以这样做。</target>
        </trans-unit>
        <trans-unit id="c629e4aca342ff5d679b1354d5badb624d786fd5" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; . Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="translated">可能不应该发出警告的唯一地方是，如果优化导致甚至完全不尝试整个模式匹配。例如，Perl可能会发现，要使字符串与某个正则表达式模式匹配，该字符串必须包含子字符串 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 。在尝试进行匹配之前，Perl可能会寻找该子字符串，如果找不到该子字符串，则在没有实际尝试的情况下立即使匹配失败。因此即使字符串包含高于Unicode的代码点，也不会生成警告。</target>
        </trans-unit>
        <trans-unit id="c7dc3eb2b3b66b20134df38443b06998c7b78e71" translate="yes" xml:space="preserve">
          <source>The only purpose of this step is to create the needed directories, and let you know the names of these directories. From the output you can see that the directory for the extension is</source>
          <target state="translated">这一步的唯一目的是创建需要的目录,并让你知道这些目录的名称。从输出中你可以看到,扩展的目录是</target>
        </trans-unit>
        <trans-unit id="8b743cce5d7490a9e24b6e3b1af9c9095cbf1cfd" translate="yes" xml:space="preserve">
          <source>The only required part is the first field, the name of a module (e.g. Foo::Bar, i.e.</source>
          <target state="translated">唯一需要的部分是第一个字段,即一个模块的名称(如Foo::Bar,即。</target>
        </trans-unit>
        <trans-unit id="a47d064470efbb85a4c64c4b51a76380fc85cda0" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are GV_SUPER and SVf_UTF8.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 的唯一有效值为GV_SUPER和SVf_UTF8。</target>
        </trans-unit>
        <trans-unit id="27c03514e890f7e1e455be24f92d8de38867990a" translate="yes" xml:space="preserve">
          <source>The only thing to note is that, in both the static and virtual methods, the method name is not passed via the stack--it is used as the first parameter to</source>
          <target state="translated">唯一需要注意的是,在静态和虚拟方法中,方法名不是通过堆栈传递的--它是作为</target>
        </trans-unit>
        <trans-unit id="9a6d4c47eb4eb3548f61bca4b08d9e197f6e1287" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine</source>
          <target state="translated">您唯一需要记住的是 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程</target>
        </trans-unit>
        <trans-unit id="befc7f9200d677e41e635df70642f3120f18f3ee" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. When used as a number, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt; ; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt; ; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="translated">在Perl中需要声明的唯一内容是报表格式和子例程（有时甚至不是子例程）。标量变量将保留未定义的值（ &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），直到为其分配了已定义的值为止，该值不是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。当用作数字时， &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 被视为 &lt;code&gt;0&lt;/code&gt; ；当用作字符串时，将其视为空字符串 &lt;code&gt;&quot;&quot;&lt;/code&gt; ；当用作未分配的参考时，将其视为错误。如果启用警告，则在将 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 视为字符串或数字时，系统会通知您未初始化的值。好吧，通常。布尔上下文，例如：</target>
        </trans-unit>
        <trans-unit id="31db2a79cbb61c12ae686554ebaa8cf24c12eba8" translate="yes" xml:space="preserve">
          <source>The only times that you absolutely</source>
          <target state="translated">只有在你绝对</target>
        </trans-unit>
        <trans-unit id="cdb480d4e9cef712b05b3e3ca053bd2714b2800c" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt; .</source>
          <target state="translated">更改此设置的唯一方法是为 &lt;code&gt;'|'&lt;/code&gt; 提供您自己的子例程 。</target>
        </trans-unit>
        <trans-unit id="c65da34730ca57e068ebb9d99972660fe1a63a25" translate="yes" xml:space="preserve">
          <source>The only way to override a lexical warnings setting is with the &lt;b&gt;-W&lt;/b&gt; or &lt;b&gt;-X&lt;/b&gt; command line flags.</source>
          <target state="translated">覆盖词法警告设置的唯一方法是使用&lt;b&gt;-W&lt;/b&gt;或&lt;b&gt;-X&lt;/b&gt;命令行标志。</target>
        </trans-unit>
        <trans-unit id="cbd9c5131dd8145825db3c00e95fdf65545c95f3" translate="yes" xml:space="preserve">
          <source>The op tree is connected in two ways: you can imagine that there are two &quot;routes&quot; through it, two orders in which you can traverse the tree. First, parse order reflects how the parser understood the code, and secondly, execution order tells perl what order to perform the operations in.</source>
          <target state="translated">op树有两种连接方式:你可以想象有两条 &quot;路线 &quot;穿过它,有两种顺序可以遍历这棵树。首先,解析顺序反映了解析器如何理解代码,其次,执行顺序告诉perl以什么顺序执行操作。</target>
        </trans-unit>
        <trans-unit id="87587f650625db0a4ecb1818a87bdf007aa521f9" translate="yes" xml:space="preserve">
          <source>The op tree representing the code block is returned. This is always a real op, never a null pointer. It will normally be a &lt;code&gt;lineseq&lt;/code&gt; list, including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops. No ops to construct any kind of runtime scope are included by virtue of it being a block.</source>
          <target state="translated">返回表示代码块的操作树。这始终是一个真实的操作，绝不是空指针。它通常是一个 &lt;code&gt;lineseq&lt;/code&gt; 列表，包括 &lt;code&gt;nextstate&lt;/code&gt; 或等效的操作。由于它是一个块，因此不包含任何构造任何类型的运行时范围的操作。</target>
        </trans-unit>
        <trans-unit id="0ada1b492ff1e32feecd23ad2e48d8b585f13df5" translate="yes" xml:space="preserve">
          <source>The op tree representing the expression is returned. If an optional expression is absent, a null pointer is returned, otherwise the pointer will be non-null.</source>
          <target state="translated">返回代表表达式的操作树。如果没有可选的表达式,则返回一个空指针,否则指针将是非空的。</target>
        </trans-unit>
        <trans-unit id="b8ec717bc605b587bc78dee46e74bc74f77b59be" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="translated">返回表示该语句的操作树。如果语句为空，则可能为空指针，例如，如果该语句实际上是子例程定义（具有编译时的副作用）。如果不为null，则将由ops直接实现该语句，适合传递给&lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;。它通常不会包含 &lt;code&gt;nextstate&lt;/code&gt; 或等效操作（除了那些完全包含在语句内的作用域中嵌入的操作）。</target>
        </trans-unit>
        <trans-unit id="55a48ae410aca9d3fe9a16a19fa26233018ca671" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="translated">返回表示该语句的操作树。如果语句为空，则可能为空指针，例如，如果该语句实际上是子例程定义（具有编译时的副作用）。如果不为null，则它将是&lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;调用的结果，通常包括 &lt;code&gt;nextstate&lt;/code&gt; 或等效的op。</target>
        </trans-unit>
        <trans-unit id="80258368ca90132ffffe94b685646de5d3e0a9ff" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement sequence is returned. This may be a null pointer if the statements were all null, for example if there were no statements or if there were only subroutine definitions (which have compile-time side effects). If not null, it will be a &lt;code&gt;lineseq&lt;/code&gt; list, normally including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops.</source>
          <target state="translated">返回表示语句序列的操作树。如果语句全为空，则可能为空指针，例如，如果不存在任何语句，或者仅存在子例程定义（具有编译时副作用）。如果不为null，它将是一个 &lt;code&gt;lineseq&lt;/code&gt; 列表，通常包括 &lt;code&gt;nextstate&lt;/code&gt; 或等效的ops。</target>
        </trans-unit>
        <trans-unit id="ee004e116194c04a5a9d3789b699d566539ba78d" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP flags abbreviations&lt;/a&gt;).</source>
          <target state="translated">op标志（&lt;b&gt;ex'sK / 2'&lt;/b&gt;）在（&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP标志缩写&lt;/a&gt;）中进行了描述。</target>
        </trans-unit>
        <trans-unit id="8eec999d2cf9d026309d4e24a85ebd9a75290847" translate="yes" xml:space="preserve">
          <source>The open source license that Larry Wall created for Perl, maximizing Perl&amp;rsquo;s usefulness, availability, and modifiability. The current version is 2. (&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;).</source>
          <target state="translated">拉里&amp;middot;沃尔（Larry Wall）为Perl创建的开源许可证，使Perl的有用性，可用性和可修改性最大化。当前版本为2。（&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d076872f9624d7a17cf4c11c33523c71a8396f8e" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given $cmd and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="translated">open2()函数运行给定的$cmd,并连接$chld_out进行读取和$chld_in进行写入。这就是你认为应该工作的东西,当你尝试的时候</target>
        </trans-unit>
        <trans-unit id="793bd01a6b2dc5e14b8e95bd14b22d7c8c213b3b" translate="yes" xml:space="preserve">
          <source>The operand of some types of regop is a literal string; for others, it is a regop leading into a sub-program. In particular, the operand of a &lt;code&gt;BRANCH&lt;/code&gt; node is the first regop of the branch.</source>
          <target state="translated">某些类型的regop的操作数是文字字符串；对于其他人来说，这是导致子程序重新使用的方法。特别是， &lt;code&gt;BRANCH&lt;/code&gt; 节点的操作数是分支的第一个重新操作。</target>
        </trans-unit>
        <trans-unit id="cf8df21203ce7e715434391039cee96dd7ffc65d" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt; ) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="translated">操作系统，设备驱动程序，C库和Perl运行时系统都共同使程序员能够将单个字符（ &lt;code&gt;\n&lt;/code&gt; ）视为行终止符，而无需考虑外部表示形式。在许多操作系统上，本机文本文件表示形式与内部表示形式匹配，但是在某些平台上， &lt;code&gt;\n&lt;/code&gt; 的外部表示形式由多个字符组成。</target>
        </trans-unit>
        <trans-unit id="8c6975d92732aba7cc117877a890c8662a217abc" translate="yes" xml:space="preserve">
          <source>The operation of the &lt;code&gt;%ENV&lt;/code&gt; array depends on the translation of the logical name</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; 数组的操作取决于逻辑名的转换</target>
        </trans-unit>
        <trans-unit id="1fcdc1a8281a2698369d4d0c5ac8331125832af5" translate="yes" xml:space="preserve">
          <source>The operation of the bval option warrants some discussion. Here is the definition of bval from the Berkeley DB 1.85 recno manual page:</source>
          <target state="translated">bval选项的操作值得讨论。以下是Berkeley DB 1.85 recno手册中对bval的定义。</target>
        </trans-unit>
        <trans-unit id="f8261c0231b653877a248b54abf80f0b93e9f204" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; , and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">此方法的操作还受 &lt;code&gt;archlibexp&lt;/code&gt; ， &lt;code&gt;cccdlflags&lt;/code&gt; ， &lt;code&gt;ccflags&lt;/code&gt; ， &lt;code&gt;optimize&lt;/code&gt; 和 &lt;code&gt;cc&lt;/code&gt; 条目 &lt;code&gt;Config.pm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ea94336b097e013eb83f32bbba38514d8eaa887" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; , and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">此方法的操作还受 &lt;code&gt;lddlflags&lt;/code&gt; ， &lt;code&gt;shrpenv&lt;/code&gt; 和 &lt;code&gt;ld&lt;/code&gt; 条目 &lt;code&gt;Config.pm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cf8b3d14dd93250118a75dcead35353084d8d3c" translate="yes" xml:space="preserve">
          <source>The operations that are affected by locale are:</source>
          <target state="translated">受地域影响的业务有:</target>
        </trans-unit>
        <trans-unit id="4ea8be07a0890d457a63bbbdc0361b2f2a0630bf" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="translated">运算符 &lt;code&gt;not&lt;/code&gt; 不是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 的有效键。但是，如果运算符 &lt;code&gt;!&lt;/code&gt; 过载则该相同的实现将被用于 &lt;code&gt;not&lt;/code&gt; （因为两个操作符的优先仅不同）。</target>
        </trans-unit>
        <trans-unit id="78cd830e88c435efad5c7c64c9421f0a7b44115d" translate="yes" xml:space="preserve">
          <source>The operator may be assigned to if both the 2nd and 3rd arguments are legal lvalues (meaning that you can assign to them):</source>
          <target state="translated">如果第2个和第3个参数都是合法的l值(意味着你可以对它们进行赋值),则可以对该运算符进行赋值。</target>
        </trans-unit>
        <trans-unit id="5904b513e41f7f0a3948a698bdf838835b48e7f3" translate="yes" xml:space="preserve">
          <source>The opname, as in &lt;b&gt;'add[t1]'&lt;/b&gt;, may be followed by op-specific information in parentheses or brackets (ex &lt;b&gt;'[t1]'&lt;/b&gt;).</source>
          <target state="translated">与&lt;b&gt;&amp;ldquo; add [t1]&amp;rdquo;中的操作名一样&lt;/b&gt;，可以在括号或方括号（例如&lt;b&gt;&amp;ldquo; [t1]&amp;rdquo;&lt;/b&gt;）后跟操作特定的信息。</target>
        </trans-unit>
        <trans-unit id="18a01865affffe01d68458832d996fae1c28b752" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;.</source>
          <target state="translated">的相对&lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8b12f229c6486073ad774a1dc49a9e1e9fe1afd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir()&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#catdir()&quot;&gt;catdir（）&lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="cd5ab607bfc9b28a62d0ee095cfa34da1a0a1edd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;../spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;../spec#catdir&quot;&gt;catdir（）&lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="1ebefb2669972c85d8b9e00b79503067268d1b9d" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt; .</source>
          <target state="translated">与 &lt;code&gt;catdir()&lt;/code&gt; 相反。</target>
        </trans-unit>
        <trans-unit id="9058f904dc63789872dd9542a7b1316b89449f40" translate="yes" xml:space="preserve">
          <source>The opset and opset_to_ops functions can be used to convert from a list of operators to an opset and</source>
          <target state="translated">opset和opset_to_ops函数可以用来将运算符列表转换为OPSET和</target>
        </trans-unit>
        <trans-unit id="e0e7014b5567d7771bd0933f5acd1310aac22e0f" translate="yes" xml:space="preserve">
          <source>The optag name used must not be defined already (define_optag will croak if it is already defined). Optag names are global to the perl process and optag definitions cannot be altered or deleted once defined.</source>
          <target state="translated">所使用的optag名称不能是已经定义好的 (如果已经定义好了,define_optag就会崩溃)。optag名称是全局性的,一旦定义了optag,就不能更改或删除。</target>
        </trans-unit>
        <trans-unit id="16ae99f8eb8c5eb6cf77bcb07b90faddacb6b646" translate="yes" xml:space="preserve">
          <source>The optimizer-specific information is used to avoid entering (a slow) regex engine on strings that will not definitely match. If the &lt;code&gt;isall&lt;/code&gt; flag is set, a call to the regex engine may be avoided even when the optimizer found an appropriate place for the match.</source>
          <target state="translated">优化程序特定的信息用于避免在肯定不会匹配的字符串上输入（缓慢的）正则表达式引擎。如果设置了 &lt;code&gt;isall&lt;/code&gt; 标志，即使优化器找到了合适的匹配位置，也可以避免对正则表达式引擎的调用。</target>
        </trans-unit>
        <trans-unit id="c2bcebf69d65f38d819f2ef47d3870130b4b4a34" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="translated">该选项不带参数，可以通过在其前面加上&amp;ldquo; no&amp;rdquo;或&amp;ldquo; no-&amp;rdquo;来取反。例如 &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; 将允许 &lt;code&gt;--foo&lt;/code&gt; （值1将被分配），以及 &lt;code&gt;--nofoo&lt;/code&gt; 和 &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; （值0将被分配）。如果该选项具有别名，则这也适用于别名。</target>
        </trans-unit>
        <trans-unit id="05bc04ade0e6f0bfb276419b00c5f9d55f933117" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt; , when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="translated">该选项不带参数，并且每次出现在命令行中时都将增加1。例如， &lt;code&gt;&quot;more+&quot;&lt;/code&gt; 与 &lt;code&gt;--more --more --more&lt;/code&gt; 一起使用时，将使该值增加3倍，从而得出3的值（前提是该值是0或首先未定义）。</target>
        </trans-unit>
        <trans-unit id="e6c73626524fd7b39cf23cb6ceb0594624a4560f" translate="yes" xml:space="preserve">
          <source>The option name as specified to the GetOptions() function is called the option</source>
          <target state="translated">在GetOptions()函数中指定的选项名称被称为选项。</target>
        </trans-unit>
        <trans-unit id="28e883d6a03c91177fe93b06a907181312e7662a" translate="yes" xml:space="preserve">
          <source>The option names defined below are case insensitive and can be optionally prefixed by a '-'. So all of the following are valid</source>
          <target state="translated">下面定义的选项名不区分大小写,可以选择在前面加上'-'。所以以下所有选项都是有效的</target>
        </trans-unit>
        <trans-unit id="24d6abd722573e6cae42881df7cf4d56ac582b1b" translate="yes" xml:space="preserve">
          <source>The option requires an argument of the given type. Supported types are:</source>
          <target state="translated">该选项需要一个给定类型的参数。支持的类型有:</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">可选的</target>
        </trans-unit>
        <trans-unit id="3cb07c5a1f900e41d71b7af9007db9793c77a65e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;rules&lt;/code&gt; attribute provides direction on which tests should be run in parallel and which should be run sequentially. If no rule data structure is provided, a default data structure is used which makes every test eligible to be run in parallel:</source>
          <target state="translated">可选的 &lt;code&gt;rules&lt;/code&gt; 属性提供了应该并行运行测试以及应该顺序运行测试的方向。如果没有提供规则数据结构，则使用默认数据结构，该结构使每个测试都可以并行运行：</target>
        </trans-unit>
        <trans-unit id="0a173dcd400a0274b32b98f040a162b1b1782227" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt; , in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="translated">可选参数被视为文字字符串，除非它们以 &lt;code&gt;~&lt;/code&gt; 或 &lt;code&gt;!&lt;/code&gt; 开头。，在这种情况下，它们被解释为正则表达式（可能取反）。</target>
        </trans-unit>
        <trans-unit id="a213bd4ecadb16ed12c21fa427d78bb53fa09a37" translate="yes" xml:space="preserve">
          <source>The options listed above customize parts of the default header, but setting &lt;code&gt;html_header&lt;/code&gt; or &lt;code&gt;html_footer&lt;/code&gt; completely overrides the built-in header or footer. These may be useful if you want to use template tags instead of literal HTML headers and footers or are integrating converted POD pages in a larger website.</source>
          <target state="translated">上面列出的选项可自定义默认标题的各个部分，但是设置 &lt;code&gt;html_header&lt;/code&gt; 或 &lt;code&gt;html_footer&lt;/code&gt; 会完全覆盖内置的标题或页脚。如果您要使用模板标签而不是原义的HTML标头和页脚，或者将转换后的POD页面集成到较大的网站中，则这些选项可能很有用。</target>
        </trans-unit>
        <trans-unit id="73d081dbc5fcc08b3b44f6576034c6838b070bec" translate="yes" xml:space="preserve">
          <source>The options to this argument is a list of either directories that are searched recursively, or files. (Usually you wouldn't specify files, but just dirs.) Or you can just specify an empty-list, as in $name2path; with the &lt;code&gt;inc&lt;/code&gt; option on, as it is by default.</source>
          <target state="translated">该参数的选项是递归搜索目录或文件的列表。（通常，您将不指定文件，而仅指定目录。）或者您可以仅指定一个空列表，如$ name2path中所示；与 &lt;code&gt;inc&lt;/code&gt; 上，因为它是默认选项。</target>
        </trans-unit>
        <trans-unit id="f0865be52cedbd9c729cf95a5b09eba31832648b" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">optree在线程之间共享。这意味着optree有可能会超过创建它的特定线程（因此是解释器实例）的寿命，因此真正的Perl标量不能存储在optree中。而是使用紧凑形式，该形式只能存储整数（有符号和无符号），字符串或 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 的值-引用和浮点值是字符串化的。如果需要存储多个值或复杂的结构，则应序列化它们，例如使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 。记录了从 &lt;code&gt;%^H&lt;/code&gt; 删除哈希键的过程，并且可以 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; undef值的key区别开来。</target>
        </trans-unit>
        <trans-unit id="96c80c62d3615e8dcdce9b967100a640447d19ae" translate="yes" xml:space="preserve">
          <source>The order in which objects are destroyed during the global destruction before the program exits is unpredictable. This means that any objects contained by your object may already have been destroyed. You should check that a contained object is defined before calling a method on it:</source>
          <target state="translated">在程序退出前的全局销毁过程中,对象被销毁的顺序是不可预测的。这意味着你的对象所包含的任何对象可能已经被销毁了。在调用对象的方法之前,你应该先检查是否定义了一个包含的对象。</target>
        </trans-unit>
        <trans-unit id="1362f44821baf70a0c53e26c223d4e933d506d90" translate="yes" xml:space="preserve">
          <source>The order in which this test was run for the given test suite result.</source>
          <target state="translated">对于给定的测试套件结果,该测试的运行顺序。</target>
        </trans-unit>
        <trans-unit id="49bfec1872d74cc3aa3b51bdca30781b5d81ee87" translate="yes" xml:space="preserve">
          <source>The order into which &lt;b&gt;characters&lt;/b&gt; sort. This is used by &lt;b&gt;string&lt;/b&gt; comparison routines to decide, for example, where in this glossary to put &amp;ldquo;collating sequence&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;字符&lt;/b&gt;排序的顺序。这是使用&lt;b&gt;字符串&lt;/b&gt;比较例程来决定，例如，在本词汇表中把&amp;ldquo;排序序列&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="717cecbd54045d9533e4eb5b41c7c271d10ce913" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open2().</source>
          <target state="translated">参数的顺序与open2()不同。</target>
        </trans-unit>
        <trans-unit id="1338c98402171198f17cc3c818e89af7db3bfea3" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open3().</source>
          <target state="translated">参数的顺序与open3()不同。</target>
        </trans-unit>
        <trans-unit id="e57a83be29caa0cba0eac2c66aec01c8ecc059c8" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of EXPR, or the pattern contained by capture group</source>
          <target state="translated">顺序与EXPR的结果的正则表达式或捕获组所包含的模式相同。</target>
        </trans-unit>
        <trans-unit id="0f9c7f78b473deec8b2b7b3c5ae964aaebd4ae76" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ).</source>
          <target state="translated">原始的 &lt;code&gt;MD5&lt;/code&gt; 接口是由尼尔&amp;middot;温顿（ &lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; Winton）（N.Winton@axion.bt.co.uk）编写的。</target>
        </trans-unit>
        <trans-unit id="7eb97de2fdb41a38605a8a09e6520652a52c56e7" translate="yes" xml:space="preserve">
          <source>The original Dylan paper</source>
          <target state="translated">原版迪伦纸</target>
        </trans-unit>
        <trans-unit id="af612d63faee2dc3856c86fd5cc671079598e557" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">原始的Pod :: Text包含通过termcap序列进行格式化的代码，尽管默认情况下未启用它，并且使其完全无法正常工作。此重写甚至都没有尝试这样做，但是它的一个子类可以。寻找&lt;a href=&quot;text/termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07dd5b1a0e82d303f2b0b28746eab063467b6ba7" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; . Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden.</source>
          <target state="translated">原始UTF-8规范最多允许6个字节，以允许对最大 &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; 的数字进行编码。Perl继续允许这样做，并已将其扩展到最多13个字节，以对代码点进行编码，直到可以容纳64位字为止。但是，如果您将其中的任何一项输出为不可移植的，Perl将发出警告。并且在严格的UTF-8输入协议下，它们是禁止的。</target>
        </trans-unit>
        <trans-unit id="a0e54c9386e1df6efdb32bc51b43d382c1fa2bb3" translate="yes" xml:space="preserve">
          <source>The original culture of the pre-populist Internet and the deeply-held beliefs of Perl's author, Larry Wall, gave rise to the free and open distribution policy of Perl. Perl is supported by its users. The core, the standard Perl library, the optional modules, and the documentation you're reading now were all written by volunteers.</source>
          <target state="translated">在互联网流行前的原始文化和Perl作者Larry Wall深深的信念,造就了Perl的免费开放发行政策。Perl得到了用户的支持。核心、标准的Perl库、可选模块以及你现在阅读的文档都是由志愿者编写的。</target>
        </trans-unit>
        <trans-unit id="124cee86525fe9ae3fd7e1b40184ae6b8c5be548" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility.</source>
          <target state="translated">&lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;的原始形式，将其传递给 &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; 标志以实现向后兼容。</target>
        </trans-unit>
        <trans-unit id="03b164c5369f7a3512c3a8ff6e7ba584a97c85cb" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="translated">CPAN Meta文件的原始格式为&lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt;，相应的文件名为</target>
        </trans-unit>
        <trans-unit id="3411d71283c2f07e45c5a35c0fcbe60c51f6b9bb" translate="yes" xml:space="preserve">
          <source>The original purpose of source filters was to let you encrypt your program source to prevent casual piracy. This isn't all they can do, as you'll soon learn. But first, the basics.</source>
          <target state="translated">源码过滤器的最初目的是让你对程序源码进行加密,以防止随意盗版。这并不是它们能做的全部,你很快就会知道。但首先,是基础知识。</target>
        </trans-unit>
        <trans-unit id="a310ea971545c067e472063428469fc1fad9aa30" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;dORIGMARK&lt;/code&gt; .</source>
          <target state="translated">XSUB的原始堆栈标记。参见 &lt;code&gt;dORIGMARK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9fdbd5653ee6341eabe4730cc34935e3db7a992" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt; ), like so:</source>
          <target state="translated">原始样式在块名称中使用空格和连字符（ &lt;code&gt;No_Block&lt;/code&gt; 除外），如下所示：</target>
        </trans-unit>
        <trans-unit id="8dcbc33a95cd67473b45a522488fc8cc805a4f47" translate="yes" xml:space="preserve">
          <source>The original title was</source>
          <target state="translated">原标题为</target>
        </trans-unit>
        <trans-unit id="7ea4b9a6cd75e55515170d81fe9ec6a923c1c00a" translate="yes" xml:space="preserve">
          <source>The original version of B::Terse was written by Malcolm Beattie, &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;. This wrapper was written by Stephen McCamant, &amp;lt;smcc@MIT.EDU&amp;gt;.</source>
          <target state="translated">B :: Terse的原始版本由Malcolm Beattie撰写，&amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;。该包装由Stephen McCamant，&amp;lt;smcc@MIT.EDU&amp;gt;编写。</target>
        </trans-unit>
        <trans-unit id="ba66fcf36669927e93622e0a65ee5e2d5c9bffdb" translate="yes" xml:space="preserve">
          <source>The original version of PA-RISC, HP no longer sells any system with this chip.</source>
          <target state="translated">PA-RISC的原始版本,惠普已经不再销售任何带有该芯片的系统。</target>
        </trans-unit>
        <trans-unit id="0705420ac769cdd445f5fb673329007ec7bccb68" translate="yes" xml:space="preserve">
          <source>The original version of this article originally appeared in The Perl Journal #10, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">本文的原始版本最初出现在 The Perl Journal #10,版权归 The Perl Journal 1998 所有。本文由 Jon Orwant 和 The Perl Journal 提供。本文档可以在与Perl本身相同的条款下发布。</target>
        </trans-unit>
        <trans-unit id="9009e0d18f1d5f332e2819aa4a5b08efaa84ba15" translate="yes" xml:space="preserve">
          <source>The original was written by Andy Dougherty</source>
          <target state="translated">原著作者是Andy Dougherty。</target>
        </trans-unit>
        <trans-unit id="ac8cde9199e82022f2799533159dbf659a64016b" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;OA_*&lt;/code&gt; constants should not be used.</source>
          <target state="translated">不应使用其他 &lt;code&gt;OA_*&lt;/code&gt; 常量。</target>
        </trans-unit>
        <trans-unit id="e99c9d2a05f195a52a6e3dccd804ac6a0edaa601" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">其他 &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; 方法意味着每个 &lt;code&gt;$parser&lt;/code&gt; 对象仅调用一次；但是只要最后一次调用（并且只有最后一次调用）以 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值结尾，就可以根据需要为每个 &lt;code&gt;$parser&lt;/code&gt; 对象多次调用 &lt;code&gt;parse_lines&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0806e4bd09cd5bd6dbaceaf9c0baff74d032490" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt; :</source>
          <target state="translated">如果您知道 &lt;code&gt;STORABLE_freeze&lt;/code&gt; ，其他参数应该看起来很熟悉：</target>
        </trans-unit>
        <trans-unit id="407b63c5d1d6303ca3afdf08c491fa75e0221db1" translate="yes" xml:space="preserve">
          <source>The other big problem with &lt;code&gt;$^W&lt;/code&gt; is the way you can inadvertently change the warning setting in unexpected places in your code. For example, when the code below is run (without the &lt;b&gt;-w&lt;/b&gt; flag), the second call to &lt;code&gt;doit&lt;/code&gt; will trip a &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; warning, whereas the first will not.</source>
          <target state="translated">&lt;code&gt;$^W&lt;/code&gt; 的另一个大问题是您无意中在代码中意外位置更改警告设置的方式。例如，当下面的代码运行（不&lt;b&gt;-w&lt;/b&gt;标志），到第二呼叫 &lt;code&gt;doit&lt;/code&gt; 将跳闸一个 &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; 的警告，而第一不会。</target>
        </trans-unit>
        <trans-unit id="fc649a384c23c44b5ba2efe0b85df4a20e6ec321" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt; , so the executables are named accordingly.</source>
          <target state="translated">其他情况需要更多复杂的过程。下面，我假设Perl的当前版本是 &lt;code&gt;5.8.2&lt;/code&gt; ，因此可执行文件将相应地命名。</target>
        </trans-unit>
        <trans-unit id="c457b75f143400140761950573f5b842848c756c" translate="yes" xml:space="preserve">
          <source>The other counterpart, in the column labelled &quot;Full-range Unicode&quot;, matches any appropriate characters in the full Unicode character set. For example, &lt;code&gt;\p{Alpha}&lt;/code&gt; matches not just the ASCII alphabetic characters, but any character in the entire Unicode character set considered alphabetic. An entry in the column labelled &quot;backslash sequence&quot; is a (short) equivalent.</source>
          <target state="translated">在标记为&amp;ldquo;全范围Unicode&amp;rdquo;的列中，另一个匹配项与完整Unicode字符集中的任何适当字符匹配。例如， &lt;code&gt;\p{Alpha}&lt;/code&gt; 匹配ASCII字母字符，而且匹配整个Unicode字符集中被视为字母的任何字符。标记为&amp;ldquo;反斜杠序列&amp;rdquo;的列中的条目是（短）等效项。</target>
        </trans-unit>
        <trans-unit id="ece66aa413156fc84b73d204d2d9bbbf0fe1c18a" translate="yes" xml:space="preserve">
          <source>The other hack is to restore FP flags after a call to dlopen(). This helps against similar damage done by DLLs _DLLInitTerm() at runtime. Currently no way to switch these hacks off is provided.</source>
          <target state="translated">另一个黑客是在调用dlopen()后恢复FP标志。这有助于防止DLLs _DLLInitTerm()在运行时造成类似的破坏。目前还没有提供关闭这些黑客的方法。</target>
        </trans-unit>
        <trans-unit id="9303fbfd8a21fb685b416cbb44c3a447eed84853" translate="yes" xml:space="preserve">
          <source>The other is to install the module in a temporary location.</source>
          <target state="translated">另一种是将模块安装在一个临时的位置。</target>
        </trans-unit>
        <trans-unit id="7370aa653e76af4b47e0ca0cfb340c944499961e" translate="yes" xml:space="preserve">
          <source>The other modification made is that</source>
          <target state="translated">另一个修改是</target>
        </trans-unit>
        <trans-unit id="52e0e078ed7f59ceb7388f298d1ea1da0c3bdb08" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt; ) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="translated">使用变量来保存另一个变量的名称的另一个不好的主意是，该问题通常是由于对Perl数据结构缺乏理解，尤其是哈希。通过使用符号引用，您只是在使用包的符号表哈希（例如 &lt;code&gt;%main::&lt;/code&gt; 而不是用户定义的哈希。解决方案是使用您自己的哈希或真实引用。</target>
        </trans-unit>
        <trans-unit id="5743b7f731fc10e9d1778f5bba7c58560baf6a5c" translate="yes" xml:space="preserve">
          <source>The other structure is pointed to by the &lt;code&gt;regexp&lt;/code&gt; struct's &lt;code&gt;pprivate&lt;/code&gt; and is in addition to &lt;code&gt;intflags&lt;/code&gt; in the same struct considered to be the property of the regex engine which compiled the regular expression;</source>
          <target state="translated">&lt;code&gt;regexp&lt;/code&gt; 结构的 &lt;code&gt;pprivate&lt;/code&gt; 指向其他结构，除了该结构中的intflags之外， &lt;code&gt;intflags&lt;/code&gt; 被认为是编译正则表达式的regex引擎的属性。</target>
        </trans-unit>
        <trans-unit id="5b612d86c256526a7120d0f540436c62b7f8f79b" translate="yes" xml:space="preserve">
          <source>The other synchronization primitives described below can suffer from similar problems.</source>
          <target state="translated">下面描述的其他同步基元也会出现类似的问题。</target>
        </trans-unit>
        <trans-unit id="a811a8ea9dab8327d772322e2e441ab82ca0e86f" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">打印操作符的输出字段分隔符。如果定义，则在每个print参数之间打印该值。默认值为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e6a9347f20222b252ad3782a91c8dbdeaeb1ab5" translate="yes" xml:space="preserve">
          <source>The output file to print to. If the special names &quot;-&quot; or &quot;&amp;gt;&amp;amp;1&quot; or &quot;&amp;gt;&amp;amp;STDOUT&quot; are used then standard output is used. If &quot;&amp;gt;&amp;amp;2&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot; is used then standard error is used.</source>
          <target state="translated">要输出到的输出文件。如果使用特殊名称&amp;ldquo;-&amp;rdquo;或&amp;ldquo;&amp;gt;＆1&amp;rdquo;或&amp;ldquo;&amp;gt;＆STDOUT&amp;rdquo;，则使用标准输出。如果使用&amp;ldquo;&amp;gt;＆2&amp;rdquo;或&amp;ldquo;&amp;gt;＆STDERR&amp;rdquo;，则使用标准错误。</target>
        </trans-unit>
        <trans-unit id="cf7f158841e06623182985de04b67d3455d986ee" translate="yes" xml:space="preserve">
          <source>The output files are placed in the hierarchy rooted at Perl's architecture dependent library directory. You can specify a different hierarchy with a &lt;b&gt;-d&lt;/b&gt; switch.</source>
          <target state="translated">输出文件放置在根于Perl依赖于体系结构的库目录的层次结构中。您可以使用&lt;b&gt;-d&lt;/b&gt;开关指定其他层次结构。</target>
        </trans-unit>
        <trans-unit id="5d7376e07f79489cad7f31d1cda9c5ba04d798cb" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;Configurable Options&lt;/a&gt;.</source>
          <target state="translated">输出格式由&amp;ldquo;可&lt;a href=&quot;#Configurable-Options&quot;&gt;配置选项&amp;rdquo;&lt;/a&gt;下所述的多个选项控制。</target>
        </trans-unit>
        <trans-unit id="99376109c851932f74197e279ea101a89b6befe6" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; is within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , not whether the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; is.</source>
          <target state="translated">&lt;a href=&quot;functions/write&quot;&gt;写入&lt;/a&gt;的输出格式由更早的格式声明（&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;）确定，因此输出是否受语言环境的影响取决于 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; 是否在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的范围内，而不取决于 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 是。</target>
        </trans-unit>
        <trans-unit id="821335e2d4cef7b064fd271a1052ad49bb811014" translate="yes" xml:space="preserve">
          <source>The output from an XSUB which uses something like the T_PTRREF map, which doesn't bless the object, might look something like this:</source>
          <target state="translated">使用类似T_PTRREF映射的XSUB的输出,不祝福对象,可能是这样的。</target>
        </trans-unit>
        <trans-unit id="0f57dea9a1d29f634f6f112b3d23937584062d88" translate="yes" xml:space="preserve">
          <source>The output from that will be</source>
          <target state="translated">其输出将是</target>
        </trans-unit>
        <trans-unit id="489ef92ce8f286ef5d6d82e8d178af124ae1bd61" translate="yes" xml:space="preserve">
          <source>The output is untainted. If you don't know what tainting is, don't worry about it.</source>
          <target state="translated">输出是没有污染的。如果你不知道什么是污点,就不要担心。</target>
        </trans-unit>
        <trans-unit id="74b4c8cfc7182db2977001aba6ce4cd0c9c3eff4" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">输出行可以用作 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 调用中的模板：</target>
        </trans-unit>
        <trans-unit id="628776c99f7feeea9f3047213f9a74832f55bae9" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;uname -a&lt;/code&gt; if available, otherwise the hostname. The whole thing is then lower-cased and slashes and single quotes are removed.</source>
          <target state="translated">&lt;code&gt;uname -a&lt;/code&gt; 的输出（如果可用），否则为主机名。然后将整个内容小写，并删除斜杠和单引号。</target>
        </trans-unit>
        <trans-unit id="b50cc56cf670c43f6be20602b16c39970c70b1a0" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">打印操作员的输出记录分隔符。如果定义，则在打印的最后一个参数之后打印此值。默认值为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8366e38dbe1255a05a31be8b8ca8cff24bae31ce" translate="yes" xml:space="preserve">
          <source>The output shows all of the groups. The outermost matches show up first and the nested matches show up later:</source>
          <target state="translated">输出显示所有的组。最外层的匹配项先显示,嵌套的匹配项后显示。</target>
        </trans-unit>
        <trans-unit id="61a2ac718a159127bd64e67ec39c4e8e007d9514" translate="yes" xml:space="preserve">
          <source>The output shows that Perl found the two major groups:</source>
          <target state="translated">输出显示,Perl找到了两大组。</target>
        </trans-unit>
        <trans-unit id="eb272330b66e99a860c17d412be21e54b237263f" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt; . Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt; , but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="translated">输出显示，在 &lt;code&gt;OUTER&lt;/code&gt; 块中， &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 的值来自与 &lt;code&gt;$outer&lt;/code&gt; 的匹配。在 &lt;code&gt;INNER&lt;/code&gt; 块内部， &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 的值来自与 &lt;code&gt;$inner&lt;/code&gt; 的匹配，但仅直到块的末尾（即动态范围）为止。后 &lt;code&gt;INNER&lt;/code&gt; 块完成，值 &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 回报为反对这门亲事值 &lt;code&gt;$outer&lt;/code&gt; ，即使我们还没有做出其他比赛：</target>
        </trans-unit>
        <trans-unit id="43b62e463d3539b36d5bc54872fb60071ea829c7" translate="yes" xml:space="preserve">
          <source>The output shows the constant() subroutine we're testing being replaced with the value of the &lt;code&gt;DEBUG&lt;/code&gt; constant: zero. The line to be tested has been completely optimized away, and you can't get much more efficient than that.</source>
          <target state="translated">输出显示我们正在测试的constant（）子例程已被 &lt;code&gt;DEBUG&lt;/code&gt; 常量的值替换为零。要测试的生产线已经完全优化，您将无法获得比这更高的效率。</target>
        </trans-unit>
        <trans-unit id="223632d9e65a77def5c7f3d1e26472458213d8c9" translate="yes" xml:space="preserve">
          <source>The output string will be returned.</source>
          <target state="translated">将返回输出字符串。</target>
        </trans-unit>
        <trans-unit id="5b1aa869d1f21ede1a6455013df56f91d9ec5d9c" translate="yes" xml:space="preserve">
          <source>The output strings for &lt;b&gt;Tputs&lt;/b&gt; are cached for counts of 1 for performance. &lt;b&gt;Tgoto&lt;/b&gt; and &lt;b&gt;Tpad&lt;/b&gt; do not cache. &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; is the raw termcap data and &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; is the cached version.</source>
          <target state="translated">&lt;b&gt;Tputs&lt;/b&gt;的输出字符串缓存为1，以提高性能。&lt;b&gt;Tgoto&lt;/b&gt;和&lt;b&gt;Tpad&lt;/b&gt;不缓存。 &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; 是原始termcap数据， &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; 是缓存的版本。</target>
        </trans-unit>
        <trans-unit id="5e7202107b643ac3d564aacb4d094eef76b947a2" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="translated">输出值及其符号,必须是1,2,...,OBJ2-1范围内的正值,或者是减去OBJ2的相同值。例如,如果输入参数是代表数字7和5的对象,则该方法必须返回一个代表数字3和 &quot;+&quot;号的对象,因为(3*7)% 5=1 % 5,或者返回一个代表数字2和&quot;-&quot;号的对象,因为(-2*7)% 5=1 % 5。</target>
        </trans-unit>
        <trans-unit id="1eef73c78f4ba8f7baa5a469f4fff0d89cabb26a" translate="yes" xml:space="preserve">
          <source>The output you'll get when the script is executed:</source>
          <target state="translated">当脚本被执行时,你将得到的输出。</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">的输出。</target>
        </trans-unit>
        <trans-unit id="0dc65b45e14d95f10af2c76613db8f6869035f53" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 与终止时间之间的总时间或挂钟时间。经过的时间包括用户和系统时间，以及等待系统上其他用户和进程所花费的时间。不可避免地，这是给出的最近似的测量值。</target>
        </trans-unit>
        <trans-unit id="5407cf16873f519751b5a5a5e241e60dd7a6b88b" translate="yes" xml:space="preserve">
          <source>The pTHX_ symbol in the definition is a macro used by Perl under threading to provide an extra argument to the routine holding a pointer back to the interpreter that is executing the regexp. So under threading all routines get an extra argument.</source>
          <target state="translated">定义中的pTHX_符号是Perl在线程化下使用的一个宏,用于为例程提供一个额外的参数,该参数持有一个指向正在执行regexp的解释器的指针。所以在线程下,所有的例程都会得到一个额外的参数。</target>
        </trans-unit>
        <trans-unit id="f3fe23968698971d8ab162ac70a7f7b71df42802" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;A*&lt;/code&gt; gobbles up all remaining bytes, and &lt;code&gt;$prio&lt;/code&gt; remains undefined! Before we let disappointment dampen the morale: Perl's got the trump card to make this trick too, just a little further up the sleeve. Watch this:</source>
          <target state="translated">打包代码 &lt;code&gt;A*&lt;/code&gt; 吞噬了所有剩余字节，而 &lt;code&gt;$prio&lt;/code&gt; 仍未定义！在我们失望之前挫败士气：Perl也获得了王牌来做这个技巧，只是袖手旁观。看这个：</target>
        </trans-unit>
        <trans-unit id="7933b3c7848d20de1a22817261c68e6d7c53c8c0" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="translated">添加了打包代码 &lt;code&gt;w&lt;/code&gt; 以支持一种便携式二进制数据编码方案，该方案远远超出了简单的整数。 （有关详细信息，请访问Scarab项目的&lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;。）BER（二进制编码表示）压缩的无符号整数存储基数128位，最高有效位在前，并且位数越少越好。除最后一个字节外，每个字节均设置位八（高位）。 BER编码没有大小限制，但是Perl不会极端。</target>
        </trans-unit>
        <trans-unit id="1cf9569df81623b7e7940e6c5aeacc511770e43a" translate="yes" xml:space="preserve">
          <source>The pack code for big-endian (high order byte at the lowest address) is &lt;code&gt;n&lt;/code&gt; for 16 bit and &lt;code&gt;N&lt;/code&gt; for 32 bit integers. You use these codes if you know that your data comes from a compliant architecture, but, surprisingly enough, you should also use these pack codes if you exchange binary data, across the network, with some system that you know next to nothing about. The simple reason is that this order has been chosen as the</source>
          <target state="translated">big-endian（最低地址的高位字节）的打包代码对于16位是 &lt;code&gt;n&lt;/code&gt; ，对于32位整数是 &lt;code&gt;N&lt;/code&gt; 。如果您知道数据来自兼容体系结构，则可以使用这些代码，但是，令人惊讶的是，如果您要通过网络与几乎一无所知的系统交换二进制数据，那么也应该使用这些打包代码。原因很简单，该订单已被选择为</target>
        </trans-unit>
        <trans-unit id="57fad0d4b36d335f1fb095e9863848e373754e9c" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 之前的打包代码可以是任何适合表示数字的代码：所有数字二进制打包代码，甚至是文本代码，例如 &lt;code&gt;A4&lt;/code&gt; 或 &lt;code&gt;Z*&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7172e02890f0d23e60cb06f72d229c969bc3f33e" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="translated">包装格式 &lt;code&gt;A&lt;/code&gt; 表示&amp;ldquo;任何字符&amp;rdquo;；如果你是 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ING和你的东西用完了收拾， &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 将填补剩下了空间。</target>
        </trans-unit>
        <trans-unit id="9582d05d51afa98d043db268f238bb511bec0a17" translate="yes" xml:space="preserve">
          <source>The package contains a session manager and a cache manager. The session manager keeps track of what has been fetched, built, and installed in the current session. The cache manager keeps track of the disk space occupied by the make processes and deletes excess space using a simple FIFO mechanism.</source>
          <target state="translated">该包包含一个会话管理器和一个缓存管理器。会话管理器会跟踪当前会话中已经获取、构建和安装的内容,缓存管理器会跟踪make进程占用的磁盘空间,并使用简单的FIFO机制删除多余的空间。缓存管理器跟踪make进程占用的磁盘空间,并使用简单的FIFO机制删除多余的空间。</target>
        </trans-unit>
        <trans-unit id="fdc4d85fb172b2eb58f10fb1bda38f21c477922a" translate="yes" xml:space="preserve">
          <source>The package name argument will typically be the name of the class into which the subroutine was declared, but it may also be the name of a derived class (since handlers are inherited).</source>
          <target state="translated">包名参数通常是子程序被声明成的类的名称,但也可能是派生类的名称(因为处理程序是继承的)。</target>
        </trans-unit>
        <trans-unit id="91efffdbf8c7db0b4f5430206e2d6e6cd3563e8f" translate="yes" xml:space="preserve">
          <source>The package name uses the &lt;code&gt;DBM_Filter::&lt;/code&gt; prefix.</source>
          <target state="translated">程序包名称使用 &lt;code&gt;DBM_Filter::&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="61ad7bd19c49da733338e6250d6950f088f8b981" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt;).</source>
          <target state="translated">表示发行版的软件包。例如， &lt;code&gt;Test::More&lt;/code&gt; 或 &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 。它将用于派生有关分发的信息，例如&lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;，Perl库中的安装位置以及默认情况下将在其中查找XS文件的位置（请参阅&lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4576d414ced67927c5747f7cd9e683dea9105380" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;
qr//&lt;/code&gt; ). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="translated">qr //魔术对象的软件包被祝福（如 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; qr//&lt;/code&gt; ）。建议引擎将其更改为其程序包名称以进行标识，无论它们是否在对象上实现方法。</target>
        </trans-unit>
        <trans-unit id="73079d10e9cd577552c5b87cfb22afa1b7851691" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="translated">此方法返回的包的 &lt;code&gt;@ISA&lt;/code&gt; 中还应该具有内部 &lt;code&gt;Regexp&lt;/code&gt; 包。无论使用什么引擎， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; 都应始终为true。</target>
        </trans-unit>
        <trans-unit id="7b32ac926fcc794f5f7982e502e4686af4c595bf" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt; , on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="translated">当调用者简单地说 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; Net :: Acme时，包变量 &lt;code&gt;@EXPORT&lt;/code&gt; 将确定将导出哪些符号-您几乎不需要在其中放置任何内容。另一方面，@ &lt;code&gt;@EXPORT_OK&lt;/code&gt; 指定您要导出的符号。如果确实要导出一堆符号，请使用 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 并定义一个标准导出集- 有关更多详细信息，请参见&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="650111e5202c538679780ce9ea893a905f97b0fc" translate="yes" xml:space="preserve">
          <source>The packages relating to various DBM-related implementations (</source>
          <target state="translated">与各种DBM相关的实施方案相关的包()。</target>
        </trans-unit>
        <trans-unit id="c94813a5310ff08ec4ccbc37cd40783e0084e83e" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The COP_SEQ_RANGE_LOW and _HIGH fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="translated">PADNAMELIST中的焊盘名称有其PV,持有变量的名称。COP_SEQ_RANGE_LOW和_HIGH字段形成了一个cop_seq数字的范围(low+1...high包括在内),这个名字是有效的。在编译过程中,这些字段可以持有特殊值PERL_PADSEQ_INTRO来表示不同的阶段。</target>
        </trans-unit>
        <trans-unit id="ad69ddb72e9f5b5565c26efc4eeac2130e2ed028" translate="yes" xml:space="preserve">
          <source>The padded $string is returned.</source>
          <target state="translated">返回填充的$string。</target>
        </trans-unit>
        <trans-unit id="d3a360c727f09061a32c58fb443bedffc200fc64" translate="yes" xml:space="preserve">
          <source>The paper &quot;How to Break MD5 and Other Hash Functions&quot; by Xiaoyun Wang and Hongbo Yu.</source>
          <target state="translated">王晓云、于洪波的论文《如何破解MD5等哈希函数》。</target>
        </trans-unit>
        <trans-unit id="6bcc7e86c6ab48d9801f437d7ce277bb0ef436bb" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="translated">您提供给&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt;的段落不应包含嵌入式换行符。&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt;无法对齐行（右对齐）。</target>
        </trans-unit>
        <trans-unit id="0d3c20158693e8f7ad6ce14151f5e71a493b3128" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">参数 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 用于控制压缩数据的目的地。该参数可以采用以下形式之一。</target>
        </trans-unit>
        <trans-unit id="2a2ee58982c19a9868c4499e7bd1b9d1531f2904" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the uncompressed data. This parameter can take one of these forms.</source>
          <target state="translated">参数 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 用于控制未压缩数据的目的地。该参数可以采用以下形式之一。</target>
        </trans-unit>
        <trans-unit id="4380851c25da81befd83447bad55f6f9f369b966" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$text&lt;/code&gt; is a string or block of text to be parsed for interior sequences; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number corresponding to the beginning of &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">参数 &lt;code&gt;$text&lt;/code&gt; 是要为内部序列解析的字符串或文本块；参数 &lt;code&gt;$line_num&lt;/code&gt; 是与 &lt;code&gt;$text&lt;/code&gt; 开头相对应的行号。</target>
        </trans-unit>
        <trans-unit id="175733e4967510eadb5d4ab18e962461101eaed6" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;extra_libs&lt;/code&gt; can be used to specify &lt;b&gt;additional&lt;/b&gt; paths to search for installed modules. For instance</source>
          <target state="translated">参数 &lt;code&gt;extra_libs&lt;/code&gt; 可用于指定&lt;b&gt;其他&lt;/b&gt;路径以搜索已安装的模块。例如</target>
        </trans-unit>
        <trans-unit id="76679b1c7056137b35154fa4603dcc56a2e17eed" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;type&lt;/code&gt; is an enumeration which specifies which of the 3 interface methods (DB_HASH, DB_BTREE or DB_RECNO) is to be used. Depending on which of these is actually chosen, the final parameter,</source>
          <target state="translated">参数 &lt;code&gt;type&lt;/code&gt; 是一个枚举，它指定要使用三种接口方法（DB_HASH，DB_BTREE或DB_RECNO）中的哪一种。根据实际选择的参数，最终参数</target>
        </trans-unit>
        <trans-unit id="6df79d8edafef2b8d47fc8b433ceb1dac071556d" translate="yes" xml:space="preserve">
          <source>The parameter list to my() may be assigned to if desired, which allows you to initialize your variables. (If no initializer is given for a particular variable, it is created with the undefined value.) Commonly this is used to name input parameters to a subroutine. Examples:</source>
          <target state="translated">如果需要的话,可以将参数列表分配给my(),这样可以让你初始化你的变量。(如果没有为某个变量提供初始化器,则会以未定义的值创建。)通常这用来命名子程序的输入参数。例子。</target>
        </trans-unit>
        <trans-unit id="42306ba107d404a6932eda2f03148007a2382a8a" translate="yes" xml:space="preserve">
          <source>The parameter's default value will still be evaluated if the corresponding argument isn't supplied, even though the value won't be stored anywhere. This is in case evaluating it has important side effects. However, it will be evaluated in void context, so if it doesn't have side effects and is not trivial it will generate a warning if the &quot;void&quot; warning category is enabled. If a nameless optional parameter's default value is not important, it may be omitted just as the parameter's name was:</source>
          <target state="translated">如果没有提供相应的参数,参数的默认值仍然会被评估,即使该值不会被存储在任何地方。这是在评估它有重要副作用的情况下。然而,它将在void上下文中被评估,所以如果它没有副作用,而且不是琐碎的,如果启用了 &quot;void &quot;警告类别,它将产生一个警告。如果一个无名可选参数的默认值并不重要,那么它可以像参数的名称一样被省略。</target>
        </trans-unit>
        <trans-unit id="59f23da7798f0b234972a256a92c78bcfb8c2aa3" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the compressed data.</source>
          <target state="translated">参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 用来定义压缩数据的源。</target>
        </trans-unit>
        <trans-unit id="ed835ab2fa9d34eac4fd3a603940891a0a5eef62" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the uncompressed data.</source>
          <target state="translated">参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 用来定义未压缩数据的源。</target>
        </trans-unit>
        <trans-unit id="2e0cab04bcd8cbbda8dd4d2c9ce2cf18535f80ac" translate="yes" xml:space="preserve">
          <source>The parameters it accepts are:</source>
          <target state="translated">它接受的参数有:</target>
        </trans-unit>
        <trans-unit id="a830abc7b9d4b876164e2805f5f239e46c825485" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; 的参数添加到perl搜索路径的开头。说</target>
        </trans-unit>
        <trans-unit id="ea253e51dc3b40387e985b7980c9898cef5a3467" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="translated">关于括号 &lt;code&gt;XSLoader::load()&lt;/code&gt; ，因为我们更换需要的参数 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ，所以编译器不知道的功能 &lt;code&gt;XSLoader::load()&lt;/code&gt; 是存在的。</target>
        </trans-unit>
        <trans-unit id="f992098d3a5a843dac6b8ae9c7b69d4a2fac46e8" translate="yes" xml:space="preserve">
          <source>The parse proceeds pretty much exactly as it does during the construction phase, except that most routines are short-circuited to change the size field &lt;code&gt;RExC_size&lt;/code&gt; and not do anything else.</source>
          <target state="translated">解析的进行过程几乎与构造阶段完全相同，只是大多数例程被短路以更改大小字段 &lt;code&gt;RExC_size&lt;/code&gt; 且不执行其他任何操作。</target>
        </trans-unit>
        <trans-unit id="93ac900e49339cc6ef6dea21ed4478644c93af89" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt; , and that and its associated routines can be found in</source>
          <target state="translated">语法分析器得到了词法分析器的大力支持，该词法分析器将您的输入分块成令牌，并确定每个令牌是什么类型的东西：变量名，运算符，空字，子例程，核心函数，等等。词法分析器的主要入口点是 &lt;code&gt;yylex&lt;/code&gt; ，它及其相关的例程可以在下面找到。</target>
        </trans-unit>
        <trans-unit id="c291c44225b529aa63eb30ed6a4d6cbe06294dcd" translate="yes" xml:space="preserve">
          <source>The parser then sees the following code:</source>
          <target state="translated">然后,解析器会看到以下代码。</target>
        </trans-unit>
        <trans-unit id="09f50fcb4a70f717d3ac7b5f391fbd97a01ce899" translate="yes" xml:space="preserve">
          <source>The part of the address of a TCP or UDP socket that directs packets to the correct process after finding the right machine, something like the phone extension you give when you reach the company operator. Also the result of converting code to run on a different platform than originally intended, or the verb denoting this conversion.</source>
          <target state="translated">TCP或UDP套接字的地址部分,在找到正确的机器后,将数据包引导到正确的进程,就像你联系公司接线员时给出的电话分机一样。也是指将代码转换为在不同的平台上运行的结果,或表示这种转换的动词。</target>
        </trans-unit>
        <trans-unit id="ae986ba9c61f4a263f7b3033ed66b7a9c47ca2ea" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use does not support the specified signal being used in a &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; call.</source>
          <target state="translated">您尝试使用的特定Perl副本不支持在 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 调用中使用的指定信号。</target>
        </trans-unit>
        <trans-unit id="24e4beb9cede37117dbc38642ef9d4cdf73ef0f4" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use was not built using the &lt;code&gt;useithreads&lt;/code&gt; configuration option.</source>
          <target state="translated">您要使用的Perl特定副本不是使用 &lt;code&gt;useithreads&lt;/code&gt; 配置选项构建的。</target>
        </trans-unit>
        <trans-unit id="e133c3129f1a418b83b69fbe9affe042d494a52e" translate="yes" xml:space="preserve">
          <source>The particular macro you must use depends on which &lt;code&gt;sv_set*v&lt;/code&gt; routine you called first. This is because every &lt;code&gt;sv_set*v&lt;/code&gt; routine turns on only the bit for the particular type of data being set, and turns off all the rest.</source>
          <target state="translated">您必须使用的特定宏取决于您首先调用的 &lt;code&gt;sv_set*v&lt;/code&gt; 例程。这是因为每个 &lt;code&gt;sv_set*v&lt;/code&gt; 例程仅打开所设置的特定数据类型的位，而关闭其余所有位。</target>
        </trans-unit>
        <trans-unit id="1c24d584fffb94c2e195393379212bd0e772bba9" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt;.</source>
          <target state="translated">可以将传递的属性指定为&lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases（）&lt;/a&gt;返回的任何同义词。</target>
        </trans-unit>
        <trans-unit id="515ad1971581ebeed29e0dfbff2e2ca6f9f34b5c" translate="yes" xml:space="preserve">
          <source>The patchlevel level of this package. The value of patchlevel comes from the</source>
          <target state="translated">这个软件包的补丁级别。补丁级别的值来自于</target>
        </trans-unit>
        <trans-unit id="6c9c1991e5426882e512831205056ad8d0cb53e5" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt; . By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt; . However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt; .</source>
          <target state="translated">Perl通过 &lt;code&gt;@INC&lt;/code&gt; 的路径。默认情况下，这是双重深度优先搜索，一次查找定义的方法，一次查找 &lt;code&gt;AUTOLOAD&lt;/code&gt; 。但是，Perl允许您使用 &lt;code&gt;mro&lt;/code&gt; 进行配置。</target>
        </trans-unit>
        <trans-unit id="97b7ffc6783961615c324915aaa3803b45441d58" translate="yes" xml:space="preserve">
          <source>The path from the uri, will be at least a single '/'.</source>
          <target state="translated">从uri的路径,将至少是一个'/'。</target>
        </trans-unit>
        <trans-unit id="935a26d686af6b04ea7fea8358669d0caebc7249" translate="yes" xml:space="preserve">
          <source>The path of the file from which the history (assuming a usable Term::ReadLine backend) will be read on the debugger's startup, and to which it will be saved on shutdown (for persistence across sessions). Similar in concept to Bash's &lt;code&gt;.bash_history&lt;/code&gt; file.</source>
          <target state="translated">历史记录（假设可用的Term :: ReadLine后端）将在调试器启动时从中读取，并且在关机时将其保存到该文件的路径（以确保跨会话的持久性）。在概念上与Bash的 &lt;code&gt;.bash_history&lt;/code&gt; 文件类似。</target>
        </trans-unit>
        <trans-unit id="3f73d1d0634237caab821e6e9c8fad9914a18a73" translate="yes" xml:space="preserve">
          <source>The path to the file is automatically converted to a Unix like equivalent for use in the archive, and, if on MacOS, the file's modification time is converted from the MacOS epoch to the Unix epoch. So tar archives created on MacOS with &lt;b&gt;Archive::Tar&lt;/b&gt; can be read both with</source>
          <target state="translated">文件的路径会自动转换为Unix之类的文件，以供存档使用；如果在MacOS上，则文件的修改时间将从MacOS时代转换为Unix时代。因此，在MacOS上使用&lt;b&gt;Archive :: Tar&lt;/b&gt;创建的tar存档可以通过</target>
        </trans-unit>
        <trans-unit id="2ab24d7b050cb5882eec74eec0cbc6ea2a2768dd" translate="yes" xml:space="preserve">
          <source>The pathname of a POD file to syntax-check (defaults to standard input).</source>
          <target state="translated">要进行语法检查的POD文件的路径名(默认为标准输入)。</target>
        </trans-unit>
        <trans-unit id="3091661abc10e8b933048a63287800c8286b8cec" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing pod documentation to be output in usage message format (defaults to standard input).</source>
          <target state="translated">包含要以使用信息格式输出的 pod 文档的文件路径名(默认为标准输入)。</target>
        </trans-unit>
        <trans-unit id="5506a685c5fca482706d4108f11645e50bb17fd9" translate="yes" xml:space="preserve">
          <source>The pathname of a file from which to select sections of pod documentation (defaults to standard input).</source>
          <target state="translated">文件的路径名,用于选择 pod 文档的部分(默认为标准输入)。</target>
        </trans-unit>
        <trans-unit id="64067e36292a9c79bf92f0c4d392216daafe926d" translate="yes" xml:space="preserve">
          <source>The pattern begins with a class matching a subset of letters. Whenever this matches, a statement like &lt;code&gt;$count{'a'}++;&lt;/code&gt; is executed, incrementing the letter's counter. Then &lt;code&gt;(*FAIL)&lt;/code&gt; does what it says, and the regexp engine proceeds according to the book: as long as the end of the string hasn't been reached, the position is advanced before looking for another vowel. Thus, match or no match makes no difference, and the regexp engine proceeds until the entire string has been inspected. (It's remarkable that an alternative solution using something like</source>
          <target state="translated">模式以匹配字母子集的类开头。只要匹配，就使用 &lt;code&gt;$count{'a'}++;&lt;/code&gt; 类的语句；被执行，增加字母的计数器。然后 &lt;code&gt;(*FAIL)&lt;/code&gt; 进行说明，然后正则表达式引擎根据该书继续进行：只要未到达字符串的末尾，在寻找另一个元音之前，该位置将前进。因此，匹配或不匹配没有区别，并且正则表达式引擎继续进行直到检查了整个字符串。 （值得注意的是，替代解决方案使用类似</target>
        </trans-unit>
        <trans-unit id="194b10f85ac928e670426276285fc77367b6bf3e" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">模式匹配成功并且 &lt;code&gt;$1&lt;/code&gt; 被定义，尽管它匹配&amp;ldquo; nothing&amp;rdquo;。它确实没有匹配任何东西。相反，它匹配的东西恰好是零个字符。这一切都是坦率和诚实的。当一个函数返回一个未定义的值时，就表示它不能给您一个诚实的答案。因此，仅在质疑您要执行的操作的完整性时，才应使用 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 。在其他时候，您想要的是与 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;&quot;&quot;&lt;/code&gt; 的简单比较。</target>
        </trans-unit>
        <trans-unit id="6ccde9606e998bb56b83482fdb0ce2d1cd2b87e5" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">模式匹配成功并且 &lt;code&gt;$1&lt;/code&gt; 被定义，尽管它匹配&amp;ldquo; nothing&amp;rdquo;。它确实没有匹配任何东西。相反，它匹配的东西恰好是零个字符。这一切都是坦率和诚实的。当一个函数返回一个未定义的值时，就表示它不能给您一个诚实的答案。因此，仅在质疑您要执行的操作的完整性时，才应使用 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 。在其他时候，您想要的是与 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;&quot;&quot;&lt;/code&gt; 的简单比较。</target>
        </trans-unit>
        <trans-unit id="00e74cbb0f8570bc720cdf9f1dc73c5533c198b5" translate="yes" xml:space="preserve">
          <source>The pattern matching metacharacters &quot;(&quot;, &quot;)&quot;, and &quot;|&quot; do not have backslashes in front.</source>
          <target state="translated">模式匹配的元字符&quot;(&quot;、&quot;)&quot;和&quot;|&quot;前面没有反斜杠。</target>
        </trans-unit>
        <trans-unit id="8647f015f186197cabe9c1508a8d5b1dddf875e9" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="translated">在不使用 &lt;code&gt;=~&lt;/code&gt; 运算符的情况下使用模式匹配操作 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; （aka &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="216352b3a9f025091614aa329a166fdb30a18a8e" translate="yes" xml:space="preserve">
          <source>The pattern modifiers:</source>
          <target state="translated">模式修改器。</target>
        </trans-unit>
        <trans-unit id="a2c1a780666383b49402abd005e8fafffcab62b8" translate="yes" xml:space="preserve">
          <source>The pattern of macro calls is like this:</source>
          <target state="translated">宏调用的模式是这样的。</target>
        </trans-unit>
        <trans-unit id="3569af6a782c9884f9c5e89ba969f12fe42cf2da" translate="yes" xml:space="preserve">
          <source>The pattern really,</source>
          <target state="translated">这个模式真的。</target>
        </trans-unit>
        <trans-unit id="8a46001019582eae5c4e5728c4a3fb31cd3dbf38" translate="yes" xml:space="preserve">
          <source>The patterns used in Perl pattern matching evolved from those supplied in the Version 8 regex routines. (The routines are derived (distantly) from Henry Spencer's freely redistributable reimplementation of the V8 routines.) See &lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;Version 8 Regular Expressions&lt;/a&gt; for details.</source>
          <target state="translated">Perl模式匹配中使用的模式是从版本8 regex例程中提供的模式演变而来的。（这些例程（从（远处）派生自Henry Spencer的V8例程的可自由重新分配的重新实现。）有关详细信息，请参见&lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;版本8正则表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dac0ad9b1d3df00129661ed1e95ffc2c13f0c968" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt; hook.</source>
          <target state="translated">窥孔优化器绝对不能完全更换。而是通过包装现有的优化器向其添加代码。在&lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3：perlguts中的窥孔优化中&lt;/a&gt;可以看到执行此操作的基本方法。如果新代码希望在整个子例程的结构上而不是仅在顶层上对ops进行操作，则包装&lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt;钩子可能会更方便。</target>
        </trans-unit>
        <trans-unit id="db43041726026c591925cfc25e5688f00dc4bbac" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt; hook.</source>
          <target state="translated">窥孔优化器绝对不能完全更换。而是通过包装现有的优化器向其添加代码。在&lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3：perlguts中的窥孔优化中&lt;/a&gt;可以看到执行此操作的基本方法。如果新代码只希望在子例程的顶层操作而不是在整个结构中操作，则包装&lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt;钩子可能会更方便。</target>
        </trans-unit>
        <trans-unit id="ace3f1e6483238aa81eb601036e5dcd7d2b38b3a" translate="yes" xml:space="preserve">
          <source>The per-instance data are held in memory beyond the basic PerlIOl struct, by making a PerlIOl the first member of the layer's struct thus:</source>
          <target state="translated">每个实例的数据被保存在基本的PerlIOl结构之外的内存中,通过使PerlIOl成为层结构的第一个成员,这样。</target>
        </trans-unit>
        <trans-unit id="467fb902a44226db21d27e75dc641b031d86cd72" translate="yes" xml:space="preserve">
          <source>The per-instance data for a particular handle.</source>
          <target state="translated">特定手柄的每个实例数据。</target>
        </trans-unit>
        <trans-unit id="85e58f1f52dd9a0e84852e44b90f48bbed040fce" translate="yes" xml:space="preserve">
          <source>The per-record overhead will limit the maximum number of records you can access per file. Note that</source>
          <target state="translated">每条记录的开销将限制你在每个文件中可以访问的最大记录数。请注意</target>
        </trans-unit>
        <trans-unit id="874d7f7aa12fc5ea3bd61b16d41289fe642a630c" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot;</source>
          <target state="translated">除了&quot;...&quot;之外,句号&quot;...&quot;与任何字符相匹配。</target>
        </trans-unit>
        <trans-unit id="e038fd297e6c1d463ecc98d5fcaacd0e4180bccd" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot; (unless the modifier &lt;code&gt;//s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="translated">时期 '。' 匹配除&amp;ldquo; \ n&amp;rdquo;以外的任何字符（除非修饰符 &lt;code&gt;//s&lt;/code&gt; 有效，如下所述）。</target>
        </trans-unit>
        <trans-unit id="50625043a5bdab5548c251e25233bc0e03a34159" translate="yes" xml:space="preserve">
          <source>The perl code in PerlIO.pm then attempts to locate a layer by doing</source>
          <target state="translated">然后,PerlIO.pm中的perl代码试图通过以下操作来定位一个层</target>
        </trans-unit>
        <trans-unit id="16b7e5af7739f86fd0e9e79d11ca97ac5649e9b1" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt; . The basic rule of perl exceptions is that &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (in the absence of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; , while &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; .</source>
          <target state="translated">perl核心将 &lt;code&gt;setjmp()&lt;/code&gt; 等包装在宏 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 和 &lt;code&gt;JMPENV_JUMP&lt;/code&gt; 中。perl的异常的基本规则是， &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; ，和 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; （在不存在的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ）执行 &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; ，而 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 内 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 做了 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c474186075797ee40452934f04a51f573b827bb" translate="yes" xml:space="preserve">
          <source>The perl executable is obtained by linking</source>
          <target state="translated">perl可执行文件可以通过链接到</target>
        </trans-unit>
        <trans-unit id="06ded168a76972d517d9136275d2690412f2929f" translate="yes" xml:space="preserve">
          <source>The perl message comes out with &quot;Perl&quot; in front. The &lt;code&gt;BEGIN&lt;/code&gt; block works at compile time so all of the compilation errors and warnings get the &quot;Perl:&quot; prefix too.</source>
          <target state="translated">perl消息前面带有&amp;ldquo; Perl&amp;rdquo;。该 &lt;code&gt;BEGIN&lt;/code&gt; 在编译时块的工作，因此所有的编译错误和警告得到&amp;ldquo;的Perl：&amp;rdquo;前缀了。</target>
        </trans-unit>
        <trans-unit id="b63df2b573a7b7008051f6d3411e1d7de7dd31b6" translate="yes" xml:space="preserve">
          <source>The perl source is in a git repository. You can clone the repository with the following command:</source>
          <target state="translated">perl源代码在git仓库中。你可以用下面的命令来克隆仓库。</target>
        </trans-unit>
        <trans-unit id="327d340c9d37adf78ea3fa44d3b1c6e9e8b77c71" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Calling Perl Routines from within C Programs&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">perl tie函数将变量与实现各种GET，SET等方法的对象相关联。若要执行等效于XSUB的perl tie功能，您必须模仿此行为。下面的代码执行必要的步骤-首先创建一个新的哈希，然后创建第二个哈希，并将其加到要实现tie方法的类中。最后，它将两个哈希绑定在一起，并返回对新绑定哈希的引用。请注意，下面的代码不会调用MyTie类中的TIEHASH方法- 有关如何执行此操作的详细信息，请参见&lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;从C程序中调用Perl例程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="123c31a7a632081aa07f5ab58c14ca27dc4643f2" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt; .</source>
          <target state="translated">生成的XS子例程的Perl可见名称，它将返回常量。默认为 &lt;code&gt;constant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87baa838c319b67b0a259076dbfb27270de34c58" translate="yes" xml:space="preserve">
          <source>The perl-mvs@perl.org list is for discussion of porting issues as well as general usage issues for all EBCDIC Perls. Send a message body of &quot;subscribe perl-mvs&quot; to majordomo@perl.org.</source>
          <target state="translated">perl-mvs@perl.org 列表用于讨论所有 EBCDIC Perls 的移植问题以及一般使用问题。发送 &quot;订阅perl-mvs &quot;的消息到majordomo@perl.org。</target>
        </trans-unit>
        <trans-unit id="5ba3dea55a126a532be4f9eaeca0422de96d0827" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="translated">perl5-changes邮件列表会收到每个修补程序的副本，该副本将提交给perl存储库的维护和开发分支。有关订阅和存档信息，请参见&lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c029dc7e52d0d0d6369cc3ff0e62686a113c165" translate="yes" xml:space="preserve">
          <source>The perl5-porters (p5p) mailing list is where the Perl standard distribution is maintained and developed. The people who maintain Perl are also referred to as the &quot;Perl 5 Porters&quot;, &quot;p5p&quot; or just the &quot;porters&quot;.</source>
          <target state="translated">perl5-porters (p5p)邮件列表是维护和开发 Perl 标准发行版的地方。维护Perl的人也被称为 &quot;Perl 5 Porters&quot;、&quot;p5p &quot;或只是 &quot;porters&quot;。</target>
        </trans-unit>
        <trans-unit id="55339a112f571a65cc173aaae9b60118d4926fb7" translate="yes" xml:space="preserve">
          <source>The perlbug program will ask you a few questions about your email address and the patch you're submitting. Once you've answered them it will submit your patch via email.</source>
          <target state="translated">perlbug 程序会问你一些关于你的电子邮件地址和你要提交的补丁的问题。一旦你回答了这些问题,它就会通过电子邮件提交你的补丁。</target>
        </trans-unit>
        <trans-unit id="a319a07f2540ad16252f1fe55565bcf46c56c4bb" translate="yes" xml:space="preserve">
          <source>The perldoc for utime also has an example that has the same effect as touch(1) on files that</source>
          <target state="translated">utime的perldoc中也有一个例子,它与touch(1)对以下文件有同样的效果。</target>
        </trans-unit>
        <trans-unit id="ed575d398752b423e73c91acec2e13e6122dc7e1" translate="yes" xml:space="preserve">
          <source>The perlfaq comprises several documents that answer the most commonly asked questions about Perl and Perl programming. It's divided by topic into nine major sections outlined in this document.</source>
          <target state="translated">perlfaq由几个文档组成,回答了关于Perl和Perl编程最常见的问题。它按主题分为本文档概述的九个主要部分。</target>
        </trans-unit>
        <trans-unit id="bf571460e6819407bba20acb1eb1771f32d393cd" translate="yes" xml:space="preserve">
          <source>The perlfaq is an evolving document. Read the latest version at &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;. It is also included in the standard Perl distribution.</source>
          <target state="translated">perlfaq是一份不断发展的文档。请访问&lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;阅读最新版本。它也包含在标准Perl发行版中。</target>
        </trans-unit>
        <trans-unit id="d8ba3c9bbcf37ca492d8ac656f9c49509454f36e" translate="yes" xml:space="preserve">
          <source>The perlpod spec for a Verbatim paragraph is &quot;It should be reproduced exactly...&quot;, which means that the whitespace you've used to indent your verbatim blocks will be preserved in the output. This can be annoying for outputs such as HTML, where that whitespace will remain in front of every line. It's an unfortunate case where syntax is turned into semantics.</source>
          <target state="translated">perlpod对逐字段的规范是 &quot;它应该被精确地复制......&quot;,这意味着你用来缩进逐字段的空白将被保留在输出中。这对于像HTML这样的输出来说是很烦人的,因为在这些输出中,每行前面都会保留空白。这是一个不幸的例子,语法变成了语义。</target>
        </trans-unit>
        <trans-unit id="d320cdc510ba6fe180a797e4852d051df0ce9e8c" translate="yes" xml:space="preserve">
          <source>The perlstyle manual supplied with Perl has many helpful points.</source>
          <target state="translated">Perl附带的perlstyle手册中有很多有用的地方。</target>
        </trans-unit>
        <trans-unit id="f61630dfa6a2b75f5a9ee952e22583e2bdae4aef" translate="yes" xml:space="preserve">
          <source>The person whom the &lt;b&gt;operating system&lt;/b&gt; will let do almost anything. Typically your system administrator or someone pretending to be your system administrator. On Unix systems, the &lt;b&gt;root&lt;/b&gt; user. On Windows systems, usually the Administrator user.</source>
          <target state="translated">&lt;b&gt;操作系统&lt;/b&gt;会让任何人做的人。通常，您的系统管理员或冒充您的系统管理员的人。在Unix系统上，是&lt;b&gt;root&lt;/b&gt;用户。在Windows系统上，通常是管理员用户。</target>
        </trans-unit>
        <trans-unit id="674e8f557a9263711bdd1bff3bb098f69b9e9b84" translate="yes" xml:space="preserve">
          <source>The pipeline model divides up a task into a series of steps, and passes the results of one step on to the thread processing the next. Each thread does one thing to each piece of data and passes the results to the next thread in line.</source>
          <target state="translated">管道模型将一个任务分为一系列步骤,并将一个步骤的结果传递给下一个处理的线程。每个线程对每一个数据做一件事,并将结果传递给下一个线程。</target>
        </trans-unit>
        <trans-unit id="e5963c8e8de82f4449d7ed9e1e51afdf5f459ee1" translate="yes" xml:space="preserve">
          <source>The pl2pm utility will get you started.</source>
          <target state="translated">pl2pm工具将让你开始使用。</target>
        </trans-unit>
        <trans-unit id="1d36c8a340c756f47102c1832b54cb16f13c0c7c" translate="yes" xml:space="preserve">
          <source>The plan (for example, '1..5'), must only come at the beginning or end of the TAP output.</source>
          <target state="translated">计划(例如'1...5'),只能在TAP输出的开头或结尾出现。</target>
        </trans-unit>
        <trans-unit id="4fc2d017a3ab4b5deac17556464426823c475059" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">该函数的重点是&amp;ldquo;植入&amp;rdquo; &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 函数，以便每次运行程序时 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 都能产生不同的序列。当使用参数调用时， &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 将其用作种子；否则（半）随机选择种子。无论哪种情况，从Perl 5.14开始，它都会返回种子。表示您的代码可以工作</target>
        </trans-unit>
        <trans-unit id="2e1f3e31ba6a1b36a8c681657ab8caf017949b14" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">该函数的重点是&amp;ldquo;植入&amp;rdquo; &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 函数，以便每次运行程序时 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 都能产生不同的序列。当使用参数调用时， &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 将其用作种子；否则（半）随机选择种子。无论哪种情况，从Perl 5.14开始，它都会返回种子。表示您的代码可以工作</target>
        </trans-unit>
        <trans-unit id="d8e49cca1375307d0cbb7648d543980bc0807cf4" translate="yes" xml:space="preserve">
          <source>The pointer is blessed into a class that is derived from the name of type of the pointer but with all '*' in the name replaced with 'Ptr'.</source>
          <target state="translated">指针被祝福成一个类,这个类是由指针的类型名派生出来的,但名字中的'*'都被替换成'Ptr'。</target>
        </trans-unit>
        <trans-unit id="549bcd1d7ae81c0474487c42c591f283db8f5fed" translate="yes" xml:space="preserve">
          <source>The pointer to the PV of the &lt;code&gt;dsv&lt;/code&gt; is returned.</source>
          <target state="translated">返回指向 &lt;code&gt;dsv&lt;/code&gt; PV的指针。</target>
        </trans-unit>
        <trans-unit id="7ab31953e34eba90fc36ab51df0189b64f65aae0" translate="yes" xml:space="preserve">
          <source>The points to note are</source>
          <target state="translated">需要注意的是</target>
        </trans-unit>
        <trans-unit id="c1fdc510fd28f743532d0f8810f2c036e2bf9b84" translate="yes" xml:space="preserve">
          <source>The polar notation (also known as the trigonometric representation) is much more handy for performing multiplications and divisions of complex numbers, whilst the cartesian notation is better suited for additions and subtractions. Real numbers are on the</source>
          <target state="translated">极坐标符号(也称为三角符号)在进行复数的乘法和除法时更为方便,而卡提斯符号则更适合于加减法。实数是在</target>
        </trans-unit>
        <trans-unit id="b5ec1158a1165100647b29065f9f5443b0e8eb69" translate="yes" xml:space="preserve">
          <source>The polar style attempts to emphasize arguments like</source>
          <target state="translated">两极风格试图强调这样的论点,如</target>
        </trans-unit>
        <trans-unit id="9c2c870c4a68cedcedbfdb919f7afe57be993942" translate="yes" xml:space="preserve">
          <source>The port for Win32 was used as a reference.</source>
          <target state="translated">Win32的端口被用作参考。</target>
        </trans-unit>
        <trans-unit id="9181a3290f36ca81b3bb6720fe9893dc45df567f" translate="yes" xml:space="preserve">
          <source>The port of Perl to to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="translated">从Perl 5.12开始,Perl到Mac OS的移植被正式取消,不过MacPerl的最后一个正式生产版本对应的是Perl 5.6。虽然Perl 5.10包含了对Mac OS的移植,但ExtUtils::MakeMaker,作为Perl模块安装基础架构的核心部分,在2004年4月正式取消了对Mac OS的支持。</target>
        </trans-unit>
        <trans-unit id="f4180538d74696f5817f3f6feca9a1c65e2c02f2" translate="yes" xml:space="preserve">
          <source>The porters appreciate the time you spent helping to make Perl better. Thank you!</source>
          <target state="translated">搬运工感谢你花时间帮助Perl变得更好。谢谢你们</target>
        </trans-unit>
        <trans-unit id="54bd391c46a02c41cb9ecadecb266d6444c3a53a" translate="yes" xml:space="preserve">
          <source>The portion of the extension provided by the XS code may be connected to the rest of Perl in either of two ways. In the &lt;b&gt;static&lt;/b&gt; configuration, the object code for the extension is linked directly into</source>
          <target state="translated">XS代码提供的扩展部分可以通过两种方式之一连接到Perl的其余部分。在&lt;b&gt;静态&lt;/b&gt;配置中，扩展的目标代码直接链接到</target>
        </trans-unit>
        <trans-unit id="4c71fa06187e2cb76d45cf6769bdd2d2cbe65fe5" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="translated">FILEHANDLE在文件中的位置保持不变。您可能要在写入文件之前调用&lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;查找&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efdfff91986b015ed9943f5eed1ac7ffd6711ca2" translate="yes" xml:space="preserve">
          <source>The possessive forms (new in Perl 5.10) prevent backtracking: what gets matched by a pattern with a possessive quantifier will not be backtracked into, even if that causes the whole match to fail.</source>
          <target state="translated">占有式(Perl 5.10 中新增的)可以防止回溯:被带有占有式量化符的模式匹配的内容不会被回溯到,即使这会导致整个匹配失败。</target>
        </trans-unit>
        <trans-unit id="5eab19b8b748f65afb0049c25c884441fbae1bc8" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="translated">可能的类别是：： &lt;code&gt;:collate&lt;/code&gt; ， &lt;code&gt;:ctype&lt;/code&gt; ， &lt;code&gt;:messages&lt;/code&gt; ， &lt;code&gt;:monetary&lt;/code&gt; ， &lt;code&gt;:numeric&lt;/code&gt; ， &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 和伪类别 &lt;code&gt;:characters&lt;/code&gt; （如下所述）。</target>
        </trans-unit>
        <trans-unit id="d6655e8efe41a46d2438d144ed4d6129c437e80b" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;code&gt;Fcntl&lt;/code&gt; . See the documentation of your operating system's</source>
          <target state="translated">MODE参数的可能值和标志位取决于系统。可通过标准模块 &lt;code&gt;Fcntl&lt;/code&gt; 使用它们。请参阅您操作系统的文档</target>
        </trans-unit>
        <trans-unit id="f5b739ecc638266d58487c7c88c27f4bcc3311ca" translate="yes" xml:space="preserve">
          <source>The possibly inferred link-text; i.e., if there was no real link text, then this is the text that we'll infer in its place. (E.g., for &quot;L&amp;lt;Getopt::Std&amp;gt;&quot;, the inferred link text is &quot;Getopt::Std&quot;.)</source>
          <target state="translated">可能推断出的链接文本；即，如果没有真正的链接文本，那么这就是我们将在其位置推断的文本。（例如，对于&amp;ldquo; L &amp;lt;Getopt :: Std&amp;gt;&amp;rdquo;，推断的链接文本为&amp;ldquo; Getopt :: Std&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="4e5ec7c69ae0bd18f551874e75cc4c912902b3a0" translate="yes" xml:space="preserve">
          <source>The practice of saying, &amp;ldquo;If I had to do it all over, I&amp;rsquo;d do it differently,&amp;rdquo; and then actually going back and doing it all over differently. Mathematically speaking, it&amp;rsquo;s returning from an unsuccessful recursion on a tree of possibilities. Perl backtracks when it attempts to match patterns with a &lt;b&gt;regular expression&lt;/b&gt;, and its earlier attempts don&amp;rsquo;t pan out. See the section &amp;ldquo;The Little Engine That /Couldn(n&amp;rsquo;t)&amp;rdquo; in Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">这样说：&amp;ldquo;如果我必须一遍又一遍，我会以不同的方式来做&amp;rdquo;，然后实际上回头并以不同的方式来做一遍。从数学上讲，它是从对可能性树的不成功递归中返回的。当Perl尝试使用&lt;b&gt;正则表达式&lt;/b&gt;匹配模式时，它会回溯，并且其较早的尝试不会成功。请参阅骆驼第5章&amp;ldquo;模式匹配&amp;rdquo;中的&amp;ldquo; /无法（启用）的小引擎&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="03599d25f97c0e2d0192955c405d8519204aa81e" translate="yes" xml:space="preserve">
          <source>The practice of shifting an alphabet one or more characters for encipherment dates back thousands of years and was explicitly detailed by Gaius Julius Caesar in his &lt;b&gt;Gallic Wars&lt;/b&gt; text. A single alphabet shift is sometimes referred to as a rotation and the shift amount is given as a number $n after the string 'rot' or &quot;rot$n&quot;. Rot0 and rot26 would designate identity maps on the 26-letter English version of the Latin alphabet. Rot13 has the interesting property that alternate subsequent invocations are identity maps (thus rot13 is its own non-trivial inverse in the group of 26 alphabet rotations). Hence the following is a rot13 encoder and decoder that will work on ASCII and EBCDIC platforms:</source>
          <target state="translated">将字母转换为一个或多个字符进行加密的做法可以追溯到数千年前，盖乌斯&amp;middot;朱利叶斯&amp;middot;凯撒（Gaius Julius Caesar）在他的《&lt;b&gt;高卢战争》（Gallic Wars）&lt;/b&gt;文字中对此进行了详细说明。有时将单个字母移位称为旋转，并将移位量表示为字符串&amp;ldquo; rot&amp;rdquo;或&amp;ldquo; rot $ n&amp;rdquo;之后的数字$ n。 Rot0和rot26将在拉丁字母的26个字母的英语版本上指定身份映射。 Rot13具有有趣的特性，即交替的后续调用是身份映射（因此rot13是其自身在26个字母旋转的组中的非平凡逆）。因此，以下是适用于ASCII和EBCDIC平台的rot13编码器和解码器：</target>
        </trans-unit>
        <trans-unit id="a4931fe0eefec05b185de502969d863746246773" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="translated">在编译 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ，使 &lt;code&gt;$?&lt;/code&gt; 反映实际的VMS退出状态，而不是上述的POSIX状态的默认模拟。设置 &lt;code&gt;$?&lt;/code&gt; 时，该实用程序还会禁止将非零值转换为SS $ _ABORT 。在END块中（但零仍将转换为SS $ _NORMAL）。</target>
        </trans-unit>
        <trans-unit id="36ba59d998f30d35a2800e28be03d01cb711ce6c" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; pragma was supported and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="translated">编译指示是每个脚本而不是每个块的词汇。只有最后 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; 重要，它影响&lt;b&gt;了整个脚本&lt;/b&gt;。但是， &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; 杂乱码受支持，并且 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 可以在给定脚本中出现任意多次（尽管只有最后一个有效）。</target>
        </trans-unit>
        <trans-unit id="f8b4d970b42fbff322fe3d169272f393cc128f89" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="translated">编译指示&lt;a href=&quot;../bignum&quot;&gt;BIGNUM&lt;/a&gt;，&lt;a href=&quot;../bigint&quot;&gt;BIGINT&lt;/a&gt;和&lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt;因为他们解决autoupgrading /降级问题，至少部分也可能会感兴趣。</target>
        </trans-unit>
        <trans-unit id="984c1d7b1bad11977f9a25ba621b51c787c8e6c4" translate="yes" xml:space="preserve">
          <source>The preamble added to each output file is rather verbose, and most of it is only necessary in the presence of non-ASCII characters. It would ideally be nice if all of those definitions were only output if needed, perhaps on the fly as the characters are used.</source>
          <target state="translated">添加到每个输出文件中的序言相当啰嗦,而且大多数序言只有在出现非ASCII字符时才是必要的。如果所有这些定义只在需要的时候才输出,或许在使用字符的过程中即时输出,那就更好了。</target>
        </trans-unit>
        <trans-unit id="45357f49e477501b84ee9e2077b2244c8a2bb54d" translate="yes" xml:space="preserve">
          <source>The preamble code for the class is as follows:</source>
          <target state="translated">该类的前言代码如下。</target>
        </trans-unit>
        <trans-unit id="b4c4542a57f99c1f10f3ac073718f1821e067ea0" translate="yes" xml:space="preserve">
          <source>The preference of the &lt;b&gt;regular expression&lt;/b&gt; engine to match the leftmost occurrence of a &lt;b&gt;pattern&lt;/b&gt;, then given a position at which a match will occur, the preference for the longest match (presuming the use of a &lt;b&gt;greedy&lt;/b&gt; quantifier). See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo; for</source>
          <target state="translated">所述的优先级&lt;b&gt;的正则表达式&lt;/b&gt;引擎匹配的最左边的发生&lt;b&gt;模式&lt;/b&gt;，然后在给定的其中一个匹配会发生位置，为最长匹配偏好（假设使用的&lt;b&gt;贪婪&lt;/b&gt;量词）。有关信息，请参见骆驼第5章&amp;ldquo;模式匹配&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="fb28a274f1049ea39bf5f7992f63f38b064b26ab" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; .</source>
          <target state="translated">首选的方法是在 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; 时声明一个计划。</target>
        </trans-unit>
        <trans-unit id="a070b02ec3ff7789ebf48e13bc147cc73129be84" translate="yes" xml:space="preserve">
          <source>The prefix specified by &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; will be used with a numeric suffix if the name for a value is undefined.</source>
          <target state="translated">如果未定义值的名称，则 &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; 指定的前缀将带有数字后缀。</target>
        </trans-unit>
        <trans-unit id="47b994ba12e424b0e632ed96c89a1498fbc470f8" translate="yes" xml:space="preserve">
          <source>The presence of the word &quot;FATAL&quot; in the category list will escalate warnings in those categories into fatal errors in that lexical scope.</source>
          <target state="translated">在类别列表中出现 &quot;FATAL &quot;一词,将把这些类别中的警告升级为该词法范围内的致命错误。</target>
        </trans-unit>
        <trans-unit id="7069f5b0b1dc1568e108cd084477a400c3f8668e" translate="yes" xml:space="preserve">
          <source>The previous assignments are exactly equivalent to</source>
          <target state="translated">前面的作业完全等同于</target>
        </trans-unit>
        <trans-unit id="8d4bba88bb17e91a3967206974b895243970981e" translate="yes" xml:space="preserve">
          <source>The previous example was not particularly useful. To make it more general purpose we will make use of the context data and allow any arbitrary</source>
          <target state="translated">前面的例子不是特别有用。为了使其更加通用,我们将利用上下文数据,允许任意的</target>
        </trans-unit>
        <trans-unit id="e9b3a0712244fd40d4ef0fb4f6b05e3de06f443f" translate="yes" xml:space="preserve">
          <source>The previous paragraph is applicable verbatim to tied hash access using the &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; functions as well.</source>
          <target state="translated">上一段同样适用于使用 &lt;code&gt;hv_store&lt;/code&gt; 和 &lt;code&gt;hv_store_ent&lt;/code&gt; 函数的绑定哈希访问。</target>
        </trans-unit>
        <trans-unit id="dd2b650563ddd2d2b6e29ef9f64d0b20b2f5e086" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any text. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="translated">上一节（由 &lt;code&gt;=head&lt;/code&gt; 命令引入）不包含任何文本。这通常表示缺少某些东西。注： &lt;code&gt;=head1&lt;/code&gt; ，紧接着 &lt;code&gt;=head2&lt;/code&gt; 不会触发此警告。</target>
        </trans-unit>
        <trans-unit id="186c5466a670230e882670fbcd9b5aa0c0353eb4" translate="yes" xml:space="preserve">
          <source>The previous step created</source>
          <target state="translated">上一步创建了</target>
        </trans-unit>
        <trans-unit id="340b1d36d10dcf0bc3c98148a5a96864b33866c8" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt; above.</source>
          <target state="translated">&amp;ldquo; dlopen：存根拦截失败&amp;rdquo;消息的主要原因是LD_LIBRARY_PATH环境变量包含一个目录，该目录是/ usr / lib（例如/ lib）的符号链接。请参阅上面的&lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b0f3d276de0b395d904df1ee65d02fbb91e800c" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; .</source>
          <target state="translated">该模块的主要目的是提供对zip文件和缓冲区的流写入访问。它不是通用文件存档器。如果这是您想要的，请签出 &lt;code&gt;Archive::Zip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d840d1ff084fc0827d16e21e7b3094c84c9a7a3" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is</source>
          <target state="translated">gzip的主要站点是</target>
        </trans-unit>
        <trans-unit id="76b9d6c85592a8675b44ceb172e5fcc460f2a10f" translate="yes" xml:space="preserve">
          <source>The primary site for the</source>
          <target state="translated">的主要场所。</target>
        </trans-unit>
        <trans-unit id="dff39311adfb064fbb523d321b7e4b3dbea2499f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is</source>
          <target state="translated">bzip2程序的主要站点是</target>
        </trans-unit>
        <trans-unit id="20a7ebabe8aa28f193ee803e7dabf5b8ae97c28d" translate="yes" xml:space="preserve">
          <source>The principal value of the arc tangent of y/x</source>
          <target state="translated">y/x的弧切线的主值</target>
        </trans-unit>
        <trans-unit id="c3a6a975854cac68d0d2fce1f652f0011a15276f" translate="yes" xml:space="preserve">
          <source>The principle is that the number of objects found influences how an item is displayed. If the search finds one item, the result is displayed with the rather verbose method &lt;code&gt;as_string&lt;/code&gt; , but if more than one is found, each object is displayed with the terse method &lt;code&gt;as_glimpse&lt;/code&gt; .</source>
          <target state="translated">原理是找到的对象数量会影响项目的显示方式。如果搜索找到一项，则使用相当冗长的方法 &lt;code&gt;as_string&lt;/code&gt; 显示结果，但是如果找到多个项，则使用简洁的方法 &lt;code&gt;as_glimpse&lt;/code&gt; 显示每个对象。</target>
        </trans-unit>
        <trans-unit id="febd9a2b7b0ebfb667a62ab220755a864d89456a" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; . You can set $OFS and $ORS if you're using the English module.</source>
          <target state="translated">除非您设置 &lt;code&gt;$,&lt;/code&gt; 和 &lt;code&gt;$\&lt;/code&gt; ，否则print（）语句不会添加字段和记录分隔符。如果使用英语模块，则可以设置$ OFS和$ ORS。</target>
        </trans-unit>
        <trans-unit id="39cbd438adc424d857eb231b91cd98738e10a91c" translate="yes" xml:space="preserve">
          <source>The private data cache will take ownership of a reference to private_sv, much the same way that &lt;code&gt;hv_store()&lt;/code&gt; takes ownership of a reference to the value that you pass it.</source>
          <target state="translated">私有数据缓存将拥有对private_sv的引用的所有权，与 &lt;code&gt;hv_store()&lt;/code&gt; 拥有对您传递的值的引用的所有权的方式几乎相同。</target>
        </trans-unit>
        <trans-unit id="7c29fbafe2b5b36ada501a03eca4a2fd699c674d" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; .</source>
          <target state="translated">诸如 &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; 类的私有对象哈希键可能不会更改，但可以添加其他键，如 &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9da35a7db7a9991be43f0a35bab375b2fa2f7661" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; can restore it.</source>
          <target state="translated">private变量用于保存当前的语言环境状态，以便对&lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt;进行必要的匹配调用可以恢复它。</target>
        </trans-unit>
        <trans-unit id="5290ff0dba8c2d4696fae469f418160732641247" translate="yes" xml:space="preserve">
          <source>The problem can be further examined in a roughly equivalent C program:</source>
          <target state="translated">这个问题可以在一个大致相当的C程序中进一步研究。</target>
        </trans-unit>
        <trans-unit id="13328591f6760dcc09259e6c0b9735e71fa4da38" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt; :</source>
          <target state="translated">当您从Perl认为是字符串的东西中获取数字时（例如 &lt;code&gt;@ARGV&lt;/code&gt; 中的命令行参数），就会出现问题：</target>
        </trans-unit>
        <trans-unit id="cd8bb5622c99567256e6a98501e22410a2a7900d" translate="yes" xml:space="preserve">
          <source>The problem comes when you have, for instance, a string that isn't flagged as UTF-8, and contains a byte sequence that could be UTF-8 -- especially when combining non-UTF-8 and UTF-8 strings.</source>
          <target state="translated">例如,当你有一个没有标记为UTF-8的字符串,并且包含一个可能是UTF-8的字节序列时,问题就来了--特别是当你把非UTF-8和UTF-8的字符串结合起来时。</target>
        </trans-unit>
        <trans-unit id="e918e6ad2cf12f5152c6540799f1ea5ccc7d457e" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="translated">存在该问题是因为分配给 &lt;code&gt;*Foo::foo&lt;/code&gt; glob 的匿名子例程将在调用堆栈中显示为被称为 &lt;code&gt;__ANON__&lt;/code&gt; 而不是您期望的 &lt;code&gt;foo&lt;/code&gt; 。由于 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 程序查找被调用的方法的名称，因此在这种情况下将失败。</target>
        </trans-unit>
        <trans-unit id="aea1a84a6e43b26958b1598b1f93e9a632b83a16" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="translated">这里的问题是，Uid_t可能不仅在 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 范围内，而且可能没有符号，在这种情况下，大的uid将被打印为负值。</target>
        </trans-unit>
        <trans-unit id="56bc12834cd035d1009997925f3d7abe998a9788" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">这里的问题是，名为 &lt;code&gt;a&lt;/code&gt; 的组和名为 &lt;code&gt;b&lt;/code&gt; 的组都是属于 &lt;code&gt;$1&lt;/code&gt; 的组的别名。</target>
        </trans-unit>
        <trans-unit id="dda9a4d26fe1b0eb3aeffd7cffb748b622bb8f5f" translate="yes" xml:space="preserve">
          <source>The problem is that Perl has both compile-time and run-time warnings. To disable compile-time warnings you need to rewrite the code like this:</source>
          <target state="translated">问题是Perl有编译时和运行时的警告。要禁用编译时警告,你需要重写这样的代码。</target>
        </trans-unit>
        <trans-unit id="000d776ae8231195ffb025ac77c4f425f1c2ff6f" translate="yes" xml:space="preserve">
          <source>The problem is that both &lt;code&gt;rp&lt;/code&gt; and &lt;code&gt;dp&lt;/code&gt; are pointers to the same location in memory! In C, you'd have to remember to malloc() yourself some new memory. In Perl, you'll want to use the array constructor &lt;code&gt;[]&lt;/code&gt; or the hash constructor &lt;code&gt;{}&lt;/code&gt; instead. Here's the right way to do the preceding broken code fragments:</source>
          <target state="translated">问题在于 &lt;code&gt;rp&lt;/code&gt; 和 &lt;code&gt;dp&lt;/code&gt; 都是指向内存中相同位置的指针！在C语言中，您必须记住自己给malloc（）一些新的内存。在Perl中，您将要使用数组构造函数 &lt;code&gt;[]&lt;/code&gt; 或哈希构造函数 &lt;code&gt;{}&lt;/code&gt; 。这是执行前面的破碎代码片段的正确方法：</target>
        </trans-unit>
        <trans-unit id="44e0ee462b8e8a33d77de1117d49fdbd0c841da5" translate="yes" xml:space="preserve">
          <source>The problem is that grep builds a return list, regardless of the context. This means you're making Perl go to the trouble of building a list that you then just throw away. If the list is large, you waste both time and space. If your intent is to iterate over the list, then use a for loop for this purpose.</source>
          <target state="translated">问题是 grep 会建立一个返回列表,而不管上下文如何。这意味着你让Perl费尽心思建立一个列表,然后你就把它扔掉。如果列表很大,你会浪费时间和空间。如果你的目的是在列表上进行迭代,那么就使用 for 循环来实现这个目的。</target>
        </trans-unit>
        <trans-unit id="6df859dc8cac16c31baff14e80c7d840e1cb3153" translate="yes" xml:space="preserve">
          <source>The problem is that none of these examples are reliable: they depend on the command interpreter. Under Unix, the first two often work. Under DOS, it's entirely possible that neither works. If 4DOS was the command shell, you'd probably have better luck like this:</source>
          <target state="translated">问题是,这些例子都不可靠:它们取决于命令解释器。在Unix下,前两个经常能用。在DOS下,完全有可能两个都不行。如果4DOS是命令外壳,你可能会有更好的运气,像这样。</target>
        </trans-unit>
        <trans-unit id="95485cb814321ef14b952e45ddf9a35301af1a5e" translate="yes" xml:space="preserve">
          <source>The problem is that none of this is reliable: it depends on the command and it is entirely possible neither works. If</source>
          <target state="translated">问题是这些都不靠谱:它取决于命令,完全有可能两个都不管用。如果</target>
        </trans-unit>
        <trans-unit id="88377fbeaf8b4fab35329a7e374ea24a4795a7c5" translate="yes" xml:space="preserve">
          <source>The problem is that this code will always be parsed and executed, even when the debug level set in the logging configuration file is zero. Once the debug() subroutine has been entered, and the internal &lt;code&gt;$debug&lt;/code&gt; variable confirmed to be zero, for example, the message which has been sent in will be discarded and the program will continue. In the example given though, the &lt;code&gt;\%INC&lt;/code&gt; hash will already have been dumped, and the message string constructed, all of which work could be bypassed by a debug variable at the statement level, like this:</source>
          <target state="translated">问题在于，即使在日志配置文件中设置的调试级别为零时，也始终将解析并执行此代码。例如，一旦输入debug（）子例程，并且内部 &lt;code&gt;$debug&lt;/code&gt; 变量确认为零，已发送的消息将被丢弃，程序将继续。在给出的示例中， &lt;code&gt;\%INC&lt;/code&gt; 哈希将已经被转储，并且构造了消息字符串，所有这些工作都可以由语句级别的调试变量绕过，如下所示：</target>
        </trans-unit>
        <trans-unit id="73cae6ed898e3261e96216aa07490bc469dc51e8" translate="yes" xml:space="preserve">
          <source>The problem is that this code would</source>
          <target state="translated">问题是,这段代码将</target>
        </trans-unit>
        <trans-unit id="e6af2011607132108daf874aceb7c74f8abf4357" translate="yes" xml:space="preserve">
          <source>The problem is that those double-quotes force stringification--coercing numbers and references into strings--even when you don't want them to be strings. Think of it this way: double-quote expansion is used to produce new strings. If you already have a string, why do you need more?</source>
          <target state="translated">问题是,这些双引号强迫字符串化--强迫数字和引用成为字符串--即使你不希望它们成为字符串。可以这样想:双引号扩展是用来产生新的字符串的。如果你已经有了一个字符串,为什么还需要更多?</target>
        </trans-unit>
        <trans-unit id="d0f76e9ccc888898fb7c8d297bdf6217c3b3b765" translate="yes" xml:space="preserve">
          <source>The problem is that various structures visible via procfs use off_t, and if you compile with largefile support these change from 32 bits to 64 bits. Thus what you get back from procfs doesn't match up with the structures in perl, resulting in garbage. See proc(4) for further discussion.</source>
          <target state="translated">问题是通过procfs可见的各种结构都使用off_t,如果编译时支持largefile,这些结构就会从32位变为64位。因此,你从 procfs 得到的东西与 perl 中的结构不匹配,导致垃圾。更多讨论请参见 proc(4)。</target>
        </trans-unit>
        <trans-unit id="fc4b1a9098877c5f0dfd053c053f3947a9421580" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; : one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n, etc. In fact there are an exponential number of ways to partition a string as a function of its length. A regexp may get lucky and match early in the process, but if there is no match, Perl will try</source>
          <target state="translated">问题是嵌套的不确定量词。在 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt; 之间划分长度为n的字符串有很多不同的方法：一个重复的 &lt;code&gt;b+&lt;/code&gt; 长度为n，两个重复的第一个 &lt;code&gt;b+&lt;/code&gt; 长度为k，第二个重复的长度为nk，m个重复，其位的总和为n等等。实际上，根据字符串的长度，有成千上万种方式对字符串进行分区。正则表达式可能会很幸运，并且可以在此过程的早期进行匹配，但是如果没有匹配项，Perl会尝试</target>
        </trans-unit>
        <trans-unit id="57ef8306dabb66b8a3dd5849936f56c155cd391f" translate="yes" xml:space="preserve">
          <source>The problem is usually that the command interpreters on those systems have rather different ideas about quoting than the Unix shells under which the one-liners were created. On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">问题通常是这些系统上的命令解释器与创建单引号的Unix shell有相当不同的想法。在某些系统上,你可能不得不将单引号改为双引号,你必须要用</target>
        </trans-unit>
        <trans-unit id="5ee9f00b1299262770f29ccbf33382cfb01278a2" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;Writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="translated">问题在于缓冲确实会破坏您的一天。即使您的 &lt;code&gt;Writer&lt;/code&gt; 文件句柄已自动刷新，以便另一端的进程及时获取数据，您通常也无法采取任何措施强制该进程以类似的快速方式将其数据提供给您。在这种特殊情况下，我们实际上可以这样做，因为</target>
        </trans-unit>
        <trans-unit id="f6f3b81b70ac61e4574d6ebcd3e976b1d72049f0" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt; . It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="translated">垃圾回收和线程安全的问题都可以通过函数 &lt;code&gt;register()&lt;/code&gt; 来解决。它将对象与任何数量的哈希一起注册。注册表意味着当对象死亡时，将删除该对象的引用地址下任何哈希中的条目。这样可以保证在这些哈希中收集垃圾。这也意味着在线程克隆时，已注册哈希中的对象条目将替换为更新的条目，其键为克隆对象的引用地址。因此，对象数据关联变为线程安全的。</target>
        </trans-unit>
        <trans-unit id="95e6fb31b348934a4b1c0d293aa560867eaa2c02" translate="yes" xml:space="preserve">
          <source>The process number of the Perl running this script. Though you</source>
          <target state="translated">运行这个脚本的Perl的进程号。虽然你</target>
        </trans-unit>
        <trans-unit id="b93ffa0ee1718038fedc8009038c2d7f70371455" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">将字符串转换为四个Unicode &lt;b&gt;casemap&lt;/b&gt;之一的&lt;b&gt;过程&lt;/b&gt; ;在Perl中，它是通过 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; 函数实现的。</target>
        </trans-unit>
        <trans-unit id="2cf36cd26c284e1c84d9c66a1a4b1fbb69c4ead2" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt; , its only parent is &lt;code&gt;File&lt;/code&gt; . If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">确定应使用哪种方法的过程称为&lt;b&gt;方法解析&lt;/b&gt;。Perl要做的是首先 &lt;code&gt;File::MP3&lt;/code&gt; 对象的类（在这种情况下为File :: MP3）。如果该类定义了方法，则将调用该类的方法版本。如果不是，Perl依次检查每个父类。对于 &lt;code&gt;File::MP3&lt;/code&gt; ，其唯一的父对象是 &lt;code&gt;File&lt;/code&gt; 。如果 &lt;code&gt;File::MP3&lt;/code&gt; 没有定义方法，但是 &lt;code&gt;File&lt;/code&gt; 定义了，则Perl在 &lt;code&gt;File&lt;/code&gt; 中调用该方法。</target>
        </trans-unit>
        <trans-unit id="080ae8ae51ff51ae8e5ac989879f84eb0a78985b" translate="yes" xml:space="preserve">
          <source>The process of gluing one cat&amp;rsquo;s nose to another cat&amp;rsquo;s tail. Also a similar operation on two &lt;b&gt;strings&lt;/b&gt;.</source>
          <target state="translated">将一只猫的鼻子粘到另一只猫的尾巴上的过程。对两个&lt;b&gt;字符串&lt;/b&gt;也有类似的操作。</target>
        </trans-unit>
        <trans-unit id="908f91e0beaa0a05d55f4dc47581a39df63d9d61" translate="yes" xml:space="preserve">
          <source>The process of producing a &lt;b&gt;string&lt;/b&gt; representation of an abstract object.</source>
          <target state="translated">产生抽象对象的&lt;b&gt;字符串&lt;/b&gt;表示的过程。</target>
        </trans-unit>
        <trans-unit id="3e1e79f73acf8d324572f017b3dffb010974336f" translate="yes" xml:space="preserve">
          <source>The process of trying one alternative, seeing if it matches, and moving on to the next alternative, while going back in the string from where the previous alternative was tried, if it doesn't, is called</source>
          <target state="translated">尝试一个备选方案,看是否匹配,然后转到下一个备选方案,如果不匹配,则从上一个备选方案所在的字符串返回,这个过程称为</target>
        </trans-unit>
        <trans-unit id="74fa9d2e4258275e6ce9c275f9e0e82d2661aeb2" translate="yes" xml:space="preserve">
          <source>The process of turning source code into a machine-usable form. See &lt;b&gt;compile phase&lt;/b&gt;.</source>
          <target state="translated">将源代码转换为机器可用形式的过程。参见&lt;b&gt;编译阶段&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="cc5a52491b0f391cb1ad331e975b3decd008b51b" translate="yes" xml:space="preserve">
          <source>The program can be made to run by &quot;laundering&quot; the tainted value through a regular expression: the second example--which still ignores locale information--runs, creating the file named on its command line if it can.</source>
          <target state="translated">通过正则表达式 &quot;洗白 &quot;污点值,可以使程序运行:第二个例子--仍然忽略locale信息--运行,如果可以的话,在其命令行上创建命名的文件。</target>
        </trans-unit>
        <trans-unit id="71e8e6b13bea2c8688fa8edfd4a4d7df9ffed609" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt; , the log is over.</source>
          <target state="translated">该程序崩溃， &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; S，调用 &lt;code&gt;closelog&lt;/code&gt; ，日志就结束了。</target>
        </trans-unit>
        <trans-unit id="9f6e033c5ffe643ac5235dd0c4de96e8993b109b" translate="yes" xml:space="preserve">
          <source>The program h2xs is the starting point for creating extensions. In later examples we'll see how we can use h2xs to read header files and generate templates to connect to C routines.</source>
          <target state="translated">程序h2xs是创建扩展的起点。在后面的例子中,我们将看到如何使用h2xs读取头文件并生成模板来连接C例程。</target>
        </trans-unit>
        <trans-unit id="6480e775a128a11d00bdb33611f7cc04c69a6a31" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2--7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt; , whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="translated">该程序分为两部分：第2--7行读取输入并建立数据结构，第8-13行分析数据并打印出报告。我们将有一个哈希 &lt;code&gt;%table&lt;/code&gt; ，其键是国家名称，其值是对城市名称数组的引用。数据结构将如下所示：</target>
        </trans-unit>
        <trans-unit id="d46a6e0b6bbf3d5823709dce22271813109f1ce6" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures.</source>
          <target state="translated">该程序由一组 &lt;code&gt;regnode&lt;/code&gt; 结构表示，其中一个或多个代表程序的单个Regop。结构 &lt;code&gt;regnode&lt;/code&gt; 是所需的最小结构，并具有与所有其他较大结构共享的字段结构。</target>
        </trans-unit>
        <trans-unit id="135fe1206adbfe007b6735c772853b1eaf66848e" translate="yes" xml:space="preserve">
          <source>The program must take care to ensure that this takes place</source>
          <target state="translated">该计划必须注意确保这种情况的发生。</target>
        </trans-unit>
        <trans-unit id="c1da64105b623d7426e31c12654e36ae7053e949" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="translated">该程序仅花了17多个时钟运行。注意 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 输出的值不同，重要的是始终使用相同的值，并且不要混淆每个值的含义。</target>
        </trans-unit>
        <trans-unit id="8912a00ba87d6cbf5df35a3207c6a72bfeb3c965" translate="yes" xml:space="preserve">
          <source>The program will halt</source>
          <target state="translated">该程序将停止</target>
        </trans-unit>
        <trans-unit id="267c6b23ea1ed3936b0ecbfc44abd9e2d8aa3502" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;md5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="translated">编程界面易于使用：与CPAN的&lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt;模块中的编程界面相同。因此，如果您的应用程序当前使用&lt;a href=&quot;md5&quot;&gt;Digest :: MD5，&lt;/a&gt;并且您希望SHA的安全性更高，则转换它们很简单。</target>
        </trans-unit>
        <trans-unit id="d0f12348b1996ab0ae0eb3467409b46f3ff517e5" translate="yes" xml:space="preserve">
          <source>The programs and documentation in this dist are distributed in the hope that they will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</source>
          <target state="translated">本远端中的程序和文档是以有用为目的而分发的,但不作任何保证,甚至不对某一特定目的的适销性或适用性作默示保证。</target>
        </trans-unit>
        <trans-unit id="3b63891b0a81b9b51c173bac879417506124032c" translate="yes" xml:space="preserve">
          <source>The prompt of the cpan shell can contain the current command number for easier tracking of the session or be a plain string.</source>
          <target state="translated">cpan shell的提示符可以包含当前的命令号,以便于跟踪会话,也可以是一个普通的字符串。</target>
        </trans-unit>
        <trans-unit id="a9cf8b59c024e83e18267b0f8a6518d4ffcc35fc" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt; ) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="translated">EBCDIC中大写字母之前的小写属性甚至被带到拉丁语1 EBCDIC页面上，例如0037和1047。例如，&amp;ldquo;&amp;Euml;&amp;rdquo;（ &lt;code&gt;E WITH DIAERESIS&lt;/code&gt; ，203）在&amp;ldquo;&amp;euml;&amp;rdquo;之前（ &lt;code&gt;e WITH DIAERESIS&lt;/code&gt; ，235） ）在ASCII平台上，但后者（83）在EBCDIC平台上位于前者（115）之前。（精明的读者会注意到，&amp;ldquo;&amp;szlig;&amp;rdquo; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; 字母SHARP S的大写字母只是&amp;ldquo; SS&amp;rdquo;，而&amp;ldquo;&amp;yuml;&amp;rdquo;（小 &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; 的大写字母）和&amp;ldquo; &amp;micro;&amp;rdquo;（ &lt;code&gt;MICRO SIGN&lt;/code&gt; ）不在大写字母中0..255范围，但使用Unicode（在启用Unicode的Perl中）。</target>
        </trans-unit>
        <trans-unit id="09b7c3443c95713bb7f5c3a34ea900a666d3209c" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</source>
          <target state="translated">协议（例如 &lt;code&gt;IPPROTO_TCP&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="16c98cd2a0bd15be4f172d1ada9a2ed6c4ba31c3" translate="yes" xml:space="preserve">
          <source>The protocol also defines several standard &lt;b&gt;translations&lt;/b&gt; which the file can undergo during transfer. These are ASCII, EBCDIC, binary, and byte. ASCII is the default type, and indicates that the sender of files will translate the ends of lines to a standard representation which the receiver will then translate back into their local representation. EBCDIC indicates the file being transferred is in EBCDIC format. Binary (also known as image) format sends the data as a contiguous bit stream. Byte format transfers the data as bytes, the values of which remain the same regardless of differences in byte size between the two machines (in theory - in practice you should only use this if you really know what you're doing). This class does not support the EBCDIC or byte formats, and will default to binary instead if they are attempted.</source>
          <target state="translated">该协议还定义了几种标准&lt;b&gt;翻译&lt;/b&gt;文件在传输过程中会受到的影响。这些是ASCII，EBCDIC，二进制和字节。 ASCII是默认类型，它表示文件的发送方会将行尾转换为标准表示，然后接收方会将其转换回其本地表示。 EBCDIC表示正在传输的文件为EBCDIC格式。二进制（也称为图像）格式将数据作为连续的位流发送。字节格式将数据传输为字节，无论两台计算机之间的字节大小如何，其值都将保持不变（理论上-实际上，只有在真正知道自己在做什么的情况下，才应使用此格式）。此类不支持EBCDIC或字节格式，并且如果尝试使用它们，则默认为二进制。</target>
        </trans-unit>
        <trans-unit id="3e54303b3641a865f35ca39d2a398386ca07567a" translate="yes" xml:space="preserve">
          <source>The prototype CV for a 'my' sub.</source>
          <target state="translated">我的 &quot;子的原型简历。</target>
        </trans-unit>
        <trans-unit id="11a1d81ab8f0f4c68c1c261efa58242791ed97cf" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, come after the signature.</source>
          <target state="translated">原型属性和其他任何属性都在签名之后。</target>
        </trans-unit>
        <trans-unit id="420268bbe69f10bd1b6ed7fa6d80a149e32d8a64" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt; .</source>
          <target state="translated">属性中的原型将在从子类中获取的原型之后立即分配给子，这意味着如果同时声明了两者，则传统定义的原型将被忽略。换句话说， &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; 与 &lt;code&gt;sub foo(@){}&lt;/code&gt; 是无法区分的。</target>
        </trans-unit>
        <trans-unit id="d6eb998a9749fabedff565e15bacf235434a61b2" translate="yes" xml:space="preserve">
          <source>The provided argument MUST be equal to the string for the validation to pass.</source>
          <target state="translated">提供的参数必须等于要通过验证的字符串。</target>
        </trans-unit>
        <trans-unit id="113c257205a6110f9be3ea8173531d90a26a925b" translate="yes" xml:space="preserve">
          <source>The provided argument MUST equal one of the elements of the array ref for the validation to pass. An array ref can hold all the above values.</source>
          <target state="translated">提供的参数必须等于数组ref中的一个元素,才能通过验证。一个数组 ref 可以容纳上述所有的值。</target>
        </trans-unit>
        <trans-unit id="f0175fe813dc359c6d5d92da9a9b07e142152ec0" translate="yes" xml:space="preserve">
          <source>The provided argument MUST match the regular expression for the validation to pass.</source>
          <target state="translated">提供的参数必须与正则表达式相匹配,才能通过验证。</target>
        </trans-unit>
        <trans-unit id="7028c08ff6edd9122ed07f747d04ab21bb6b6da9" translate="yes" xml:space="preserve">
          <source>The provided subroutine MUST return true in order for the validation to pass and the argument accepted.</source>
          <target state="translated">所提供的子程序必须返回true,以使验证通过并接受参数。</target>
        </trans-unit>
        <trans-unit id="93c41fbabb74d3c7cddc4b5e78899f8faa1b1f17" translate="yes" xml:space="preserve">
          <source>The pseudo-hash feature was an experimental feature introduced in earlier versions of Perl and removed in 5.10.0. A pseudo-hash is an array reference which can be accessed using named keys like a hash. You may run in to some code in the wild which uses it. See the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma for more information.</source>
          <target state="translated">伪哈希功能是在Perl的早期版本中引入的实验性功能，在5.10.0中已删除。伪哈希是一个数组引用，可以使用诸如哈希之类的命名键进行访问。您可能会在野外运行一些使用它的代码。有关更多信息，请参见&lt;a href=&quot;fields&quot;&gt;字段&lt;/a&gt;编译指示。</target>
        </trans-unit>
        <trans-unit id="2c3bf5ebc790603d27cda992131fe6f16a627371" translate="yes" xml:space="preserve">
          <source>The public API must remain consistent, i.e. if a sub-class is overloading addition, the sub-class must use the same name, in this case badd(). The reason for this is that Math::BigInt is optimized to call the object methods directly.</source>
          <target state="translated">公共API必须保持一致,即如果一个子类重载了加法,子类必须使用相同的名称,本例中是badd()。原因是Math::BigInt经过优化,可以直接调用对象方法。</target>
        </trans-unit>
        <trans-unit id="dc2995512c58b9b2e35d09bc546dc5a7fbc84663" translate="yes" xml:space="preserve">
          <source>The purpose of the macro &lt;code&gt;SPAGAIN&lt;/code&gt; is to refresh the local copy of the stack pointer. This is necessary because it is possible that the memory allocated to the Perl stack has been reallocated during the</source>
          <target state="translated">宏 &lt;code&gt;SPAGAIN&lt;/code&gt; 的目的是刷新堆栈指针的本地副本。这是必要的，因为分配给Perl堆栈的内存可能已在重新分配期间重新分配。</target>
        </trans-unit>
        <trans-unit id="b29cd6102fd964c85b9f311d0c28db3fab69123d" translate="yes" xml:space="preserve">
          <source>The purpose of the testing is twofold: one, to help developers fix any problems in their code that crop up because of lack of testing on other platforms; two, to provide users with information about whether a given module works on a given platform.</source>
          <target state="translated">测试的目的有两个:一是帮助开发者修复代码中因缺乏在其他平台上的测试而产生的问题;二是为用户提供某个模块是否在某个平台上工作的信息。</target>
        </trans-unit>
        <trans-unit id="843821edac19011f1a6d1c830e78298f0013f7a5" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to show you how to call Perl subroutines directly from C, i.e., how to write</source>
          <target state="translated">本文档的目的是告诉你如何从C语言中直接调用Perl子程序,即如何编写</target>
        </trans-unit>
        <trans-unit id="414e7fd5b34fea33393baf5db076f7ff8658e79f" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to provide a wide range of testing utilities. Various ways to say &quot;ok&quot; with better diagnostics, facilities to skip tests, test future features and compare complicated data structures. While you can do almost anything with a simple &lt;code&gt;ok()&lt;/code&gt; function, it doesn't provide good diagnostic output.</source>
          <target state="translated">该模块的目的是提供广泛的测试实用程序。具有更好的诊断能力的各种说法都可以，可以跳过测试，测试将来的功能并比较复杂的数据结构。尽管您可以使用简单的 &lt;code&gt;ok()&lt;/code&gt; 函数执行几乎所有操作，但它不能提供良好的诊断输出。</target>
        </trans-unit>
        <trans-unit id="9bfc8ef428f97c3f3e1176a68cf8e1112929bebf" translate="yes" xml:space="preserve">
          <source>The purpose, scope and target applications of your module</source>
          <target state="translated">您的模块的目的、范围和目标应用。</target>
        </trans-unit>
        <trans-unit id="ddc9dd67da090624c445edfafa6830e5bccd4e64" translate="yes" xml:space="preserve">
          <source>The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful, and then document what you wrote so you don&amp;rsquo;t have to answer so many questions about it. Hence, the first great virtue of a programmer. Also hence, this book. See also &lt;b&gt;impatience&lt;/b&gt; and &lt;b&gt;hubris&lt;/b&gt;.</source>
          <target state="translated">使您全力以赴降低总能耗的质量。它使您可以编写其他人会发现有用的省力程序，然后记录您所写的内容，因此您不必回答那么多问题。因此，程序员的第一大美德。因此，这本书也是。另请参见&lt;b&gt;不耐烦&lt;/b&gt;和&lt;b&gt;自大&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="52d7089e85ac35a7092bc58942f32bee7ca90b8d" translate="yes" xml:space="preserve">
          <source>The question of string equivalence turns somewhat complicated in Unicode: what do you mean by &quot;equal&quot;?</source>
          <target state="translated">字符串等价的问题在Unicode中变得有些复杂:什么叫 &quot;等价&quot;?</target>
        </trans-unit>
        <trans-unit id="f2a24b3b2648553142b8c5a0c4598996a73f792a" translate="yes" xml:space="preserve">
          <source>The question remains on when the SVs which are</source>
          <target state="translated">问题仍然是,什么时候才会有特别提款权?</target>
        </trans-unit>
        <trans-unit id="099c0ce39a19f948a86d0ea40fc49e8ea2b14385" translate="yes" xml:space="preserve">
          <source>The question, of course, is why would you do something like this? Why create a semaphore with a starting count that's not one, or why decrement or increment it by more than one? The answer is resource availability. Many resources that you want to manage access for can be safely used by more than one thread at once.</source>
          <target state="translated">当然,问题是,你为什么要做这样的事情?为什么要创建一个起始数不是1的旗语,或者为什么要将其递减或递增超过1?答案是资源可用性。许多你想管理访问的资源可以被多个线程同时安全使用。</target>
        </trans-unit>
        <trans-unit id="551d1aa8a1248eaf53c1cd9d606d72ab7488cd21" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty method only works well when you don't plan to leave the commented code in the source. If a Pod parser comes along, your multiline comment is going to show up in the Pod translation. A better way hides it from Pod parsers as well.</source>
          <target state="translated">这种快刀斩乱麻的方法只有在你不打算在源码中留下注释的时候才好用,如果有Pod解析器出现,你的多行注释就会显示在Pod翻译中。如果Pod解析器出现,你的多行注释就会出现在Pod翻译中。一个更好的方法是把它也隐藏起来,不让Pod解析器发现。</target>
        </trans-unit>
        <trans-unit id="a41d7294035834639b17968992ffda16ae85e9a1" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt; , ending the Pod section:</source>
          <target state="translated">注释掉多行Perl的一种简单方法是用Pod指令包围这些行。您必须将这些指令放在行的开头，以及Perl期望有新语句的位置（因此，不要放在诸如 &lt;code&gt;#&lt;/code&gt; 注释之类的语句中间）。您以 &lt;code&gt;=cut&lt;/code&gt; 结束注释，从而结束Pod部分：</target>
        </trans-unit>
        <trans-unit id="0c2f3594848e5558e5b1bcd7932b24c116883439" translate="yes" xml:space="preserve">
          <source>The quotient is always the greatest integer less than or equal to the real-valued quotient of the two operands, and the remainder (when it is non-zero) always has the same sign as the second operand; so, for example,</source>
          <target state="translated">商数总是小于或等于两个操作数的实值商的最大整数,余数(当它是非零时)总是与第二个操作数具有相同的符号;所以,例如。</target>
        </trans-unit>
        <trans-unit id="04db20aec07e3c7b83de9b23243f0bb2ef9f279e" translate="yes" xml:space="preserve">
          <source>The random characters are provided by File::Temp and ensure that each module's individual build directory is unique. This makes running CPAN.pm in concurrent processes simultaneously safe.</source>
          <target state="translated">随机字符由File::Temp提供,确保每个模块的单独构建目录是唯一的。这使得在并发进程中同时运行CPAN.pm是安全的。</target>
        </trans-unit>
        <trans-unit id="054e3d7058644b114207f253c83eb2c8a141a8e1" translate="yes" xml:space="preserve">
          <source>The range operator (in list context) makes use of the magical auto-increment algorithm if the operands are strings. You can say</source>
          <target state="translated">如果操作数是字符串,那么范围操作符(在列表上下文中)就会使用神奇的自动递增算法。你可以说</target>
        </trans-unit>
        <trans-unit id="4828534433b64aecd95537d37d705a006ad5851e" translate="yes" xml:space="preserve">
          <source>The range operator &lt;code&gt;..&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">范围运算符 &lt;code&gt;..&lt;/code&gt; 不能重载。</target>
        </trans-unit>
        <trans-unit id="bc508fe7a659eeced29e856ebc7b8d62470c6bbb" translate="yes" xml:space="preserve">
          <source>The range operator also works on strings, using the magical auto-increment, see below.</source>
          <target state="translated">范围运算符也适用于字符串,使用神奇的自动增量,见下文。</target>
        </trans-unit>
        <trans-unit id="e7f8ca3eb25d07981f64e697003d81f247478aa9" translate="yes" xml:space="preserve">
          <source>The range operator is &quot;..&quot;, not comma. The comma operator works as in C.</source>
          <target state="translated">范围运算符是&quot;.&quot;,不是逗号。逗号运算符的工作原理和C语言一样。</target>
        </trans-unit>
        <trans-unit id="6b43593ef7e3f96c529ec6f6490c77d15e8ee949" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt; , rather than comma.</source>
          <target state="translated">范围运算符是 &lt;code&gt;...&lt;/code&gt; ，而不是逗号。</target>
        </trans-unit>
        <trans-unit id="272be5d09f375bcf2f8787674ae6b79aa38f8abf" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="translated">要求这样做的理由是不破坏依赖于Unicode出现之前工作方式的较旧程序。这些较旧的程序仅了解ASCII字符集，因此对于其他字符可能无法正常工作。当字符串以UTF-8编码时，Perl假定程序已准备好处理Unicode，但是当字符串不是时，Perl假定只需要ASCII，因此那些不是ASCII字符的字符就不再公认它们在Unicode中将是什么。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 告诉Perl将所有字符都视为Unicode，无论字符串是否使用UTF-8编码，都可以避免此问题。</target>
        </trans-unit>
        <trans-unit id="62a00a9112198d60e9e6e148f4efbf8b5c8bde2f" translate="yes" xml:space="preserve">
          <source>The raw original L&amp;lt;...&amp;gt; content, before text is split on &quot;|&quot;, &quot;/&quot;, etc, and before E&amp;lt;...&amp;gt; codes are expanded.</source>
          <target state="translated">原始原始L &amp;lt;...&amp;gt;内容，在&amp;ldquo; |&amp;rdquo;，&amp;ldquo; /&amp;rdquo;等上分割文本之前，以及在扩展E &amp;lt;...&amp;gt;代码之前。</target>
        </trans-unit>
        <trans-unit id="16f6921cb27bb9d796f9843804daa8d9f88db314" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;), and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="translated">只读魔术变量 &lt;code&gt;${^UNICODE}&lt;/code&gt; 反映此设置的数值。此变量在Perl启动期间设置，此后为只读。如果需要运行时效果，请使用三个参数的open（）（请参见&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;），两个参数的binmode（）（请参见&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;）和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译指示（请参见&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8ac185b6e70958a0bc2daae47b4a77ca571d1fad" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">这个过程的真正向导。如果您使用的计算机同时支持多个组的成员资格，请使用空格将您所在的组列表分开。第一个数字是 &lt;code&gt;getgid()&lt;/code&gt; 返回的数字，随后的是 &lt;code&gt;getgroups()&lt;/code&gt; 返回的数字，其中一个可能是与第一个数字相同。</target>
        </trans-unit>
        <trans-unit id="c41410f8fa129356669d6ff84f5e22cd64e4d0cb" translate="yes" xml:space="preserve">
          <source>The real sequence number of the OP, as a regular number and not adjusted to be relative to the start of the real program. (This will generally be a fairly large number because all of &lt;b&gt;B::Concise&lt;/b&gt; is compiled before your program is).</source>
          <target state="translated">OP的实际序号，作为常规编号，并且未调整为相对于实际程序的开始。（这通常是一个相当大的数字，因为所有&lt;b&gt;B :: Concise&lt;/b&gt;都在程序编写之前进行了编译）。</target>
        </trans-unit>
        <trans-unit id="520aa3cfc6d3d06d2079bcf3cd80538cdc94136b" translate="yes" xml:space="preserve">
          <source>The real time timing is done using time(2) and the granularity is therefore only one second.</source>
          <target state="translated">实时计时是用time(2)来完成的,因此颗粒度只有一秒。</target>
        </trans-unit>
        <trans-unit id="000f9aa1d39e9791c956bd280884dcab10bddcf9" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="translated">此过程的真正uid。您可以使用 &lt;code&gt;POSIX::setuid()&lt;/code&gt; 同时更改实际uid和有效uid 。由于对 &lt;code&gt;$&amp;lt;&lt;/code&gt; 更改需要系统调用，因此请检查 &lt;code&gt;$!&lt;/code&gt; 进行更改后尝试检测任何可能的错误。</target>
        </trans-unit>
        <trans-unit id="226998a781d1d6550060a07be6fe5dd8d2b4b4b4" translate="yes" xml:space="preserve">
          <source>The real work is done in the standard typemap.</source>
          <target state="translated">真正的工作是在标准类型图中完成的。</target>
        </trans-unit>
        <trans-unit id="c08e193bbc2bcd92c562519697a3487f212bcddb" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt; , but consider this situation:</source>
          <target state="translated">存在 &lt;code&gt;encode_language_tag&lt;/code&gt; 的原因是因为不同的语言标签可能表示相同的语言。通常可以使用 &lt;code&gt;same_language_tag&lt;/code&gt; 进行处理，但请考虑以下情况：</target>
        </trans-unit>
        <trans-unit id="ca772eb153fd56cb7e89f09b86319ec24565520e" translate="yes" xml:space="preserve">
          <source>The reason I said &quot;in this instance&quot; is because that</source>
          <target state="translated">我之所以说 &quot;在这种情况下&quot;,是因为这</target>
        </trans-unit>
        <trans-unit id="739ee83789116c83fd6d7b4456cdd5e4f5143663" translate="yes" xml:space="preserve">
          <source>The reason for not checking the return value from print() is because of pipe buffering; physical writes are delayed. That won't blow up until the close, and it will blow up with a SIGPIPE. To catch it, you could use this:</source>
          <target state="translated">不检查print()的返回值是因为管道缓冲,物理写入是有延迟的。那要到关闭的时候才会炸开,而且会炸开一个SIGPIPE。要想抓住它,可以用这个办法。</target>
        </trans-unit>
        <trans-unit id="b3e75d2f4213b8c35d2937b292cccac3d8a1e38d" translate="yes" xml:space="preserve">
          <source>The reason for this is that CPAN does not know the dependencies of all modules when it starts out. To decide about the additional items to install, it just uses data found in the META.yml file or the generated Makefile. An undetected missing piece breaks the process. But it may well be that your Bundle installs some prerequisite later than some depending item and thus your second try is able to resolve everything. Please note, CPAN.pm does not know the dependency tree in advance and cannot sort the queue of things to install in a topologically correct order. It resolves perfectly well &lt;b&gt;if&lt;/b&gt; all modules declare the prerequisites correctly with the PREREQ_PM attribute to MakeMaker or the &lt;code&gt;requires&lt;/code&gt; stanza of Module::Build. For bundles which fail and you need to install often, it is recommended to sort the Bundle definition file manually.</source>
          <target state="translated">原因是CPAN在启动时并不知道所有模块的依赖性。要决定要安装的其他项目，它仅使用在META.yml文件或生成的Makefile中找到的数据。未检测到的丢失片段会中断该过程。但是，很可能是您的捆绑软件在安装某些先决条件之后，再安装某些依赖项，因此您的第二次尝试就能解决所有问题。请注意，CPAN.pm事先不知道依赖关系树，因此无法按拓扑正确的顺序对要安装的事物队列进行排序。它解决得很好&lt;b&gt;，如果&lt;/b&gt;所有模块与PREREQ_PM属性MakeMaker的或正确申报的先决条件的 &lt;code&gt;requires&lt;/code&gt; Module :: Build的节。对于失败的捆绑软件，您需要经常安装，建议手动对捆绑软件定义文件进行排序。</target>
        </trans-unit>
        <trans-unit id="5fa379384b7d494ede930080ac4d01947c2521a8" translate="yes" xml:space="preserve">
          <source>The reason for this unusability is that a fundamental assumption of Perl is that the characters it cares about for parsing and lexical analysis are the same whether or not the text is in UTF-8. For example, Perl expects the character &lt;code&gt;&quot;[&quot;&lt;/code&gt; to have the same representation, no matter if the string containing it (or program text) is UTF-8 encoded or not. To ensure this, Perl adapts UTF-EBCDIC to the particular code page so that all characters it expects to be UTF-8 invariant are in fact UTF-8 invariant. This means that text generated on a computer running one version of Perl's UTF-EBCDIC has to be translated to be intelligible to a computer running another.</source>
          <target state="translated">之所以无法使用，是因为Perl的基本假设是，无论文本是否使用UTF-8，它关心的用于分析和词法分析的字符都是相同的。例如，Perl期望字符 &lt;code&gt;&quot;[&quot;&lt;/code&gt; 具有相同的表示形式，无论包含它的字符串（或程序文本）是否经过UTF-8编码。为了确保这一点，Perl使UTF-EBCDIC适应特定的代码页，以便它期望为UTF-8不变的所有字符实际上都是UTF-8不变的。这意味着在运行一种版本的Perl UTF-EBCDIC的计算机上生成的文本必须经过翻译才能理解为运行另一种版本的计算机。</target>
        </trans-unit>
        <trans-unit id="148e8f8b4033e043ed0349ade3e3972ed042dff2" translate="yes" xml:space="preserve">
          <source>The reason is that Encode::Guess guesses encoding by trial and error. It first splits $data into lines and tries to decode the line for each suspect. It keeps it going until all but one encoding is eliminated out of suspects list. ISO-8859 series is just too successful for most cases (because it fills almost all code points in \x00-\xff).</source>
          <target state="translated">原因是 Encode::Guess 通过试错来猜测编码。它首先将$data分割成一行行,并尝试为每个嫌疑人解码。它一直持续下去,直到除了一个编码之外,所有的编码都被排除在嫌疑人列表之外。ISO-8859系列在大多数情况下都太成功了(因为它几乎填满了所有的编码点\x00-\xff)。</target>
        </trans-unit>
        <trans-unit id="94742df1b378e1ee0c32933e905c9b3866f15f37" translate="yes" xml:space="preserve">
          <source>The reason is that variable interpolation and code expressions together pose a security risk. The combination is dangerous because many programmers who write search engines often take user input and plug it directly into a regexp:</source>
          <target state="translated">原因是变量插值和代码表达式一起构成了安全风险。这种组合是很危险的,因为很多编写搜索引擎的程序员经常把用户的输入直接插入到regexp中。</target>
        </trans-unit>
        <trans-unit id="c8fa70ef72504bbb3f7d6986506b4705b0ceb70a" translate="yes" xml:space="preserve">
          <source>The reason is that vendor encoding is usually a superset of national standard so it becomes too ambiguous for most cases.</source>
          <target state="translated">原因是厂商的编码通常是国家标准的超集,所以对于大多数情况下,它变得过于模糊。</target>
        </trans-unit>
        <trans-unit id="fedf7056008fbc98297422a200d9b784c0b8db45" translate="yes" xml:space="preserve">
          <source>The reason that doesn't do what you want is because assigning a named array like that to a scalar is taking an array in scalar context, which means just counts the number of elements in @tmp.</source>
          <target state="translated">之所以不能如你所愿,是因为把这样一个命名的数组赋给一个标量,就是在标量上下文中取一个数组,也就是只计算@tmp中的元素数。</target>
        </trans-unit>
        <trans-unit id="550ff1bc08b0298c35cdd00d235a478cadb820d7" translate="yes" xml:space="preserve">
          <source>The reason that host $failed_ack_host did not receive a valid ACK. Useful to find out why when ack( $fail_ack_host ) returns a false value.</source>
          <target state="translated">主机$failed_ack_host没有收到有效ACK的原因。当ack($fail_ack_host )返回一个false值时,可以用来找出原因。</target>
        </trans-unit>
        <trans-unit id="251bb3c15e15e0ec21516300833b60efe1125c75" translate="yes" xml:space="preserve">
          <source>The reason this function has &quot;_strictly&quot; in its name is that when you're processing an Accept-Language list according to the RFCs, if you interpret the RFCs quite strictly, then you would use implicate_supers_strictly, but for normal use (i.e., common-sense use, as far as I'm concerned) you'd use implicate_supers.</source>
          <target state="translated">这个函数名称中带有&quot;_strictly &quot;的原因是,当你根据RFCs处理Accept-Language列表时,如果你对RFCs的解释相当严格,那么你会使用 implicate_supers_strictly,但对于正常使用(即常识性使用,就我而言),你会使用 implicate_supers。</target>
        </trans-unit>
        <trans-unit id="e1005d9c83a9fa9fcbc88e4d2084838b8de52293" translate="yes" xml:space="preserve">
          <source>The reason this is necessary is that the area of the Perl stack which held them will very likely have been overwritten by something else by the time control returns from</source>
          <target state="translated">之所以需要这样做,是因为当控制从</target>
        </trans-unit>
        <trans-unit id="7f8610d66bd9a8ef9ccb75cedd8c737641eb770d" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because RFC 1951 content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">之所以不是默认行为,是因为RFC 1951内容只能通过尝试解压来检测。这个过程很容易出错,可能会导致误报。</target>
        </trans-unit>
        <trans-unit id="19bd78bd51bc1c56b13d7881beac1baa5b73fb31" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because lzma_alone content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">这不是默认行为的原因是lzma_alone内容只能通过尝试解压来检测。这个过程很容易出错,可能会导致误报。</target>
        </trans-unit>
        <trans-unit id="28f02f8a8e5a76ee5006992d613d3802d772737a" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt; , it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt; . This is particularly true for these cases:</source>
          <target state="translated">究其原因，这是不对的是，由你来使用指针的时候 &lt;code&gt;rememberSub&lt;/code&gt; 在 &lt;code&gt;CallSavedSub1&lt;/code&gt; ，它可能会或可能不会仍然指的是被记录在Perl子 &lt;code&gt;SaveSub1&lt;/code&gt; 。在以下情况下尤其如此：</target>
        </trans-unit>
        <trans-unit id="1fc61e22be627df80a7651746e52decec2ded90a" translate="yes" xml:space="preserve">
          <source>The reasons for most important skipped tests are:</source>
          <target state="translated">大多数重要的跳过测试的原因是:</target>
        </trans-unit>
        <trans-unit id="cc1622b786a9a5b8c43f01f8734a1a12e356f528" translate="yes" xml:space="preserve">
          <source>The recognized bright background color attributes (colors 8 to 15) are:</source>
          <target state="translated">公认的亮色背景色属性(颜色8至15)为:。</target>
        </trans-unit>
        <trans-unit id="6c5d4a5f4c9a09fda354809420b2cbe2f30c42f0" translate="yes" xml:space="preserve">
          <source>The recognized normal background color attributes (colors 0 to 7) are:</source>
          <target state="translated">认可的正常背景色属性(颜色0至7)为:。</target>
        </trans-unit>
        <trans-unit id="4a93814d53d2a583e73a218be86053c6699847f6" translate="yes" xml:space="preserve">
          <source>The recognized normal foreground color attributes (colors 0 to 7) are:</source>
          <target state="translated">识别的普通前景色属性(颜色0至7)为:。</target>
        </trans-unit>
        <trans-unit id="c8d8fb33b8f8ad299c896b38af940448a2194ca3" translate="yes" xml:space="preserve">
          <source>The recognized options to new() are as follows. All options take a single argument.</source>
          <target state="translated">new()的公认选项如下。所有选项都只取一个参数。</target>
        </trans-unit>
        <trans-unit id="1e562f76f9cdb0ef2aab453d2c38556cc6a6334d" translate="yes" xml:space="preserve">
          <source>The recommended compiler to use in Tru64 is the native C compiler. The native compiler produces much faster code (the speed difference is noticeable: several dozen percentages) and also more correct code: if you are considering using the GNU C compiler you should use at the very least the release of 2.95.3 since all older gcc releases are known to produce broken code when compiling Perl. One manifestation of this brokenness is the lib/sdbm test dumping core; another is many of the op/regexp and op/pat, or ext/Storable tests dumping core (the exact pattern of failures depending on the GCC release and optimization flags).</source>
          <target state="translated">建议在Tru64中使用的编译器是本地C编译器。原生编译器产生的代码要快得多(速度上的差异很明显:几十个百分点),而且代码也更正确:如果您考虑使用 GNU C 编译器,您至少应该使用 2.95.3 版本,因为所有旧的 gcc 版本在编译 Perl 时都会产生破损的代码。这种破绽的一个表现是lib/sdbm测试转储核心;另一个表现是许多op/regexp和op/pat,或者ext/Storable测试转储核心(具体的失败模式取决于gcc版本和优化标志)。</target>
        </trans-unit>
        <trans-unit id="a954751580ed0f6e74f6ae52a458e3decc2b6782" translate="yes" xml:space="preserve">
          <source>The recommended order of sections in Perl module documentation is:</source>
          <target state="translated">在Perl模块文档中,推荐的章节顺序是。</target>
        </trans-unit>
        <trans-unit id="da2bd70489cefb603292ce8b5cfe4c6cae04aaf7" translate="yes" xml:space="preserve">
          <source>The recommended way to build Perl for the OS/400 PASE is to build the Perl 5 source code (release 5.8.1 or later) under AIX.</source>
          <target state="translated">为OS/400 PASE构建Perl的推荐方法是在AIX下构建Perl 5源代码(5.8.1或更高版本)。</target>
        </trans-unit>
        <trans-unit id="e06b04ad5d41fce493c0b00ecf1ca37dfa5afcff" translate="yes" xml:space="preserve">
          <source>The red() and green() functions would be similar. To create these, we'll assign a closure to a typeglob of the name of the function we're trying to build.</source>
          <target state="translated">red()和green()函数也类似。为了创建这两个函数,我们将为我们试图构建的函数名称的类型球分配一个闭包。</target>
        </trans-unit>
        <trans-unit id="1d461f380b420e2f92a59ecbfaa16c7256f214ff" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; would be decremented at the end of</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 的引用计数将在末尾减少</target>
        </trans-unit>
        <trans-unit id="aa0554de1d883a744516c47aa9649afa91c2844b" translate="yes" xml:space="preserve">
          <source>The reference count for each specified &lt;code&gt;SV*&lt;/code&gt; parameter is decremented.</source>
          <target state="translated">每个指定的 &lt;code&gt;SV*&lt;/code&gt; 参数的参考计数都会减少。</target>
        </trans-unit>
        <trans-unit id="2beb795bee8f23385c682524158dfa3883714ef0" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name list.</source>
          <target state="translated">垫名列表的引用次数。</target>
        </trans-unit>
        <trans-unit id="ed87a4c5aaea6eeced4317ed59578fe0847b6b0f" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name.</source>
          <target state="translated">垫名的引用次数。</target>
        </trans-unit>
        <trans-unit id="0f3b4f395e70b832ec180500f62bfe30abfdf04c" translate="yes" xml:space="preserve">
          <source>The reference count of the padlist. Currently this is always 1.</source>
          <target state="translated">垫表的引用次数。目前总是1。</target>
        </trans-unit>
        <trans-unit id="b9e9c4a001467c1b7e5e43bb821f471e292d9d31" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;$foo&lt;/code&gt; 到 &lt;code&gt;$bar&lt;/code&gt; 的引用已被削弱。当 &lt;code&gt;$bar&lt;/code&gt; 变量超出范围时，将被垃圾回收。下次查看 &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; 键的值时，它将为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fc857a94806f2c57cbbf2e2dd2d2b88b08c2fe6" translate="yes" xml:space="preserve">
          <source>The reference is truly dumped and we can finally see what we're dealing with. Our quoting was perfectly valid but wrong for our purposes, with 'and jerry' being treated as 2 separate words rather than a phrase, thus throwing the evenly paired hash structure out of alignment.</source>
          <target state="translated">引用真正被甩掉了,我们终于可以看到我们在处理什么了。我们的引用是完全有效的,但对于我们的目的来说是错误的,'和jerry'被当作2个独立的单词而不是一个短语,从而使偶数配对的哈希结构失准。</target>
        </trans-unit>
        <trans-unit id="4adfd6b1f7abb309b66c9315a05ff37197f3a0fe" translate="yes" xml:space="preserve">
          <source>The references you get from rule 2 are the same kind of references that you get from rule 1:</source>
          <target state="translated">你从规则2中得到的参考资料和从规则1中得到的参考资料是一样的。</target>
        </trans-unit>
        <trans-unit id="168bedf74d17b291ff7d2c437f9134d9006e0ffe" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations, etc., and uses &lt;code&gt;\g1&lt;/code&gt; to look for a repeat. Although &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;\g1&lt;/code&gt; represent the same thing, care should be taken to use matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... only</source>
          <target state="translated">regexp具有单个分组，该分组考虑4个字母的组合，然后考虑3个字母的组合等，并使用 &lt;code&gt;\g1&lt;/code&gt; 查找重复。尽管 &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;\g1&lt;/code&gt; 代表同一件事，但应注意仅使用匹配的变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ，...。</target>
        </trans-unit>
        <trans-unit id="d1eb9cbcdcc85f0afd97e3812b595b9e1f6b3fd8" translate="yes" xml:space="preserve">
          <source>The regexp matches an open parenthesis, one or more copies of an alternation, and a close parenthesis. The alternation is two-way, with the first alternative &lt;code&gt;[^()]+&lt;/code&gt; matching a substring with no parentheses and the second alternative &lt;code&gt;\([^()]*\)&lt;/code&gt; matching a substring delimited by parentheses. The problem with this regexp is that it is pathological: it has nested indeterminate quantifiers of the form &lt;code&gt;(a+|b)+&lt;/code&gt;. We discussed in Part 1 how nested quantifiers like this could take an exponentially long time to execute if there was no match possible. To prevent the exponential blowup, we need to prevent useless backtracking at some point. This can be done by enclosing the inner quantifier as an independent subexpression:</source>
          <target state="translated">正则表达式匹配一个开放的括号，一个或多个交替的副本以及一个封闭的括号。交替是双向的，第一种选择 &lt;code&gt;[^()]+&lt;/code&gt; 匹配没有括号的子字符串，第二种选择 &lt;code&gt;\([^()]*\)&lt;/code&gt; 匹配用括号定界的子字符串。此正则表达式的问题在于它是病理性的：它嵌套了 &lt;code&gt;(a+|b)+&lt;/code&gt; 形式的不确定量词。在第1部分中，我们讨论了如果没有匹配的可能，那么像这样的嵌套量词如何需要花费指数级的时间才能执行。为防止指数爆炸，我们需要在某些时候防止无用的回溯。这可以通过将内部量词括起来作为独立的子表达式来完成：</target>
        </trans-unit>
        <trans-unit id="368bf455728e0cc079751b44e9fea4161849b273" translate="yes" xml:space="preserve">
          <source>The regexp structure contains all the data that perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts such as is the pattern anchored in some way, or what flags were used during the compile, or whether the program contains special constructs that perl needs to be aware of.</source>
          <target state="translated">regexp结构包含了所有perl需要知道的数据,以便正确使用正则表达式。它包含了关于优化的数据,perl可以使用这些数据来确定是否真的应该使用regex引擎,以及在各种情况下正确执行模式所需要的各种其他控制信息,例如模式是否以某种方式被锚定,或者在编译过程中使用了什么标志,或者程序是否包含perl需要注意的特殊结构。</target>
        </trans-unit>
        <trans-unit id="c3c54f92228f6f05bcc0bda8517b5a88720264e3" translate="yes" xml:space="preserve">
          <source>The regexp without the &lt;code&gt;//x&lt;/code&gt; modifier is</source>
          <target state="translated">没有 &lt;code&gt;//x&lt;/code&gt; 修饰符的正则表达式是</target>
        </trans-unit>
        <trans-unit id="cd0504e6dcc01ce1582fd08d19ab6d72b18efd43" translate="yes" xml:space="preserve">
          <source>The regops are defined in</source>
          <target state="translated">regops定义在</target>
        </trans-unit>
        <trans-unit id="398b15f4cf9df5e68a324633c771b534053133cc" translate="yes" xml:space="preserve">
          <source>The regression tests for each operator live in</source>
          <target state="translated">每个运营商的回归测试活在</target>
        </trans-unit>
        <trans-unit id="1185c36b91985e4291f68ed8a08b57d301b0c6f7" translate="yes" xml:space="preserve">
          <source>The regular expression engine can be a weighty tool to wield. On long strings and complex patterns it can end up having to do a lot of work to find a match, and even more to decide that no match is possible. Consider a situation like the following pattern.</source>
          <target state="translated">正则表达式引擎可能是一个重量级的工具。对于长字符串和复杂的模式,它可能最终不得不做很多工作来寻找匹配,甚至更多的工作是决定不可能匹配。考虑一下像下面这种模式的情况。</target>
        </trans-unit>
        <trans-unit id="550e74d9d02bffd01cf3b652c4e172b2d8cb3f39" translate="yes" xml:space="preserve">
          <source>The regular expression to execute.</source>
          <target state="translated">要执行的正则表达式。</target>
        </trans-unit>
        <trans-unit id="8c3b3408d3eb9771532acb10a043be225a8f7a49" translate="yes" xml:space="preserve">
          <source>The regular expression to match the balanced text uses two new (to Perl 5.10) regular expression features. These are covered in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and this example is a modified version of one in that documentation.</source>
          <target state="translated">匹配平衡文本的正则表达式使用两个新的（对Perl 5.10而言）正则表达式功能。这些内容在&lt;a href=&quot;perlre&quot;&gt;perlre中进行了介绍&lt;/a&gt;，本示例是该文档中的内容的修改版本。</target>
        </trans-unit>
        <trans-unit id="7b89c7165c60ab0797d1970f7d1380e29eaa0008" translate="yes" xml:space="preserve">
          <source>The related &lt;code&gt;base&lt;/code&gt; pragma will combine fields from base classes and any fields declared using the &lt;code&gt;fields&lt;/code&gt; pragma. This enables field inheritance to work properly. Inherited fields can be overridden but will generate a warning if warnings are enabled.</source>
          <target state="translated">相关的 &lt;code&gt;base&lt;/code&gt; 杂注将结合基类中的字段和使用 &lt;code&gt;fields&lt;/code&gt; 杂注声明的任何字段。这使字段继承能够正常工作。继承的字段可以被覆盖，但是如果启用了警告，则会生成警告。</target>
        </trans-unit>
        <trans-unit id="31c9eb432cfde9dbb8b6575337f7f66a6d53cbda" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Perl_pp_regcomp&lt;/code&gt; 中的相关代码段：</target>
        </trans-unit>
        <trans-unit id="99cbb925914614f38c9cb5913b1dca990337342e" translate="yes" xml:space="preserve">
          <source>The remainder of the input string (i.e. the characters after the extracted string). On failure, the entire string is returned.</source>
          <target state="translated">输入字符串的剩余部分(即提取字符串后的字符)。如果失败,将返回整个字符串。</target>
        </trans-unit>
        <trans-unit id="efbd63ef88d15920cb0b989c9bf11dcb1d2eacf4" translate="yes" xml:space="preserve">
          <source>The remaining arguments list the files to be included in the tar file. These files must all exist. Any files which don't exist or can't be read are silently ignored.</source>
          <target state="translated">其余参数列出了要包含在 tar 文件中的文件,这些文件必须全部存在。这些文件必须全部存在。任何不存在或无法读取的文件都会被忽略。</target>
        </trans-unit>
        <trans-unit id="1833f6078478dddd497b7e7b088899346fc9339d" translate="yes" xml:space="preserve">
          <source>The remaining list-reduction functions are all specialisations of this generic idea.</source>
          <target state="translated">其余的列表还原函数都是这个通用思想的特殊化。</target>
        </trans-unit>
        <trans-unit id="5790bf8249cfb740e1105f12c204270f7d624a65" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt; . If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="translated">其余语言环境类别当前未由Perl本身使用。但要再次注意，Perl与之交互的事物可能会使用它们，包括标准Perl发行版之外的扩展以及操作系统及其实用程序。请特别注意 &lt;code&gt;$!&lt;/code&gt; 的字符串值！ &lt;code&gt;LC_MESSAGES&lt;/code&gt; 可能会更改外部实用程序给出的错误消息。如果要使用可移植的错误代码，请使用 &lt;code&gt;%!&lt;/code&gt; 。参见&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f593d82b22de04a34fb6b00553893736966b088" translate="yes" xml:space="preserve">
          <source>The remaining three arguments to &lt;code&gt;autosplit&lt;/code&gt; govern other options to the autosplitter.</source>
          <target state="translated">自动 &lt;code&gt;autosplit&lt;/code&gt; 的其余三个参数控制着自动拆分器的其他选项。</target>
        </trans-unit>
        <trans-unit id="359f225886acbac14791dc5bc2f8daf71a950d7f" translate="yes" xml:space="preserve">
          <source>The remaining transformations (e.g. hex -&amp;gt; oct, bin -&amp;gt; hex, etc.) are left as an exercise to the inclined reader.</source>
          <target state="translated">其余的转换（例如，十六进制-&amp;gt; oct，bin-&amp;gt;十六进制等）作为练习留给倾斜的读者。</target>
        </trans-unit>
        <trans-unit id="24d565f51a3155e5d1586b0499680351e5378dc6" translate="yes" xml:space="preserve">
          <source>The repeat count for &lt;code&gt;u&lt;/code&gt; is interpreted as the maximal number of bytes to encode per line of output, with 0, 1 and 2 replaced by 45. The repeat count should not be more than 65.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 的重复计数被解释为每行输出要编码的最大字节数，其中0、1和2替换为45。重复计数不应超过65。</target>
        </trans-unit>
        <trans-unit id="f593cdc0477b84a5d137272da930d89fe6995081" translate="yes" xml:space="preserve">
          <source>The repertoire of characters that Perl can represent is a superset of those defined by the Unicode Consortium. On most platforms the ordinal values of a character as returned by &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; is the</source>
          <target state="translated">Perl可以代表的字符表是Unicode联盟定义的那些字符的超集。在大多数平台如通过返回一个字符的顺序值 &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="2b90d7584bfb12af61e5f1ab0554e525a346ffd6" translate="yes" xml:space="preserve">
          <source>The report generated is in the following format:</source>
          <target state="translated">生成的报告格式如下:</target>
        </trans-unit>
        <trans-unit id="c18cb003bcf6566604f8240405fff42c4ea43f6c" translate="yes" xml:space="preserve">
          <source>The report is then grouped by the &lt;b&gt;Package&lt;/b&gt; of each variable, subroutine or format with the special case &quot;(lexicals)&quot; meaning lexical variables. Each &lt;b&gt;object&lt;/b&gt; name (implicitly qualified by its containing &lt;b&gt;Package&lt;/b&gt;) includes its type character(s) at the beginning where possible. Lexical variables are easier to track and even included dereferencing information where possible.</source>
          <target state="translated">然后，将报告按每个变量，子例程或格式的&lt;b&gt;包&lt;/b&gt;进行分组，并以特殊情况&amp;ldquo;（词法）&amp;rdquo;表示词法变量。每个&lt;b&gt;对象&lt;/b&gt;名称（由其包含的&lt;b&gt;Package&lt;/b&gt;隐式限定）在可能的开头都包括其类型字符。词法变量更容易跟踪，甚至在可能的情况下甚至包括取消引用信息。</target>
        </trans-unit>
        <trans-unit id="a2f4b71d3df1e22731185a4eb5f4e73af9bf14da" translate="yes" xml:space="preserve">
          <source>The report with</source>
          <target state="translated">该报告附有</target>
        </trans-unit>
        <trans-unit id="32baff471ed8eb8f5ceead8f0fa06a41ab81b875" translate="yes" xml:space="preserve">
          <source>The request was judged to be small, so the possibility to trap it depends on the way perl was compiled. By default it is not trappable. However, if compiled for this, Perl may use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency pool after die()ing with this message. In this case the error is trappable</source>
          <target state="translated">该请求被判断为很小，因此捕获该请求的可能性取决于perl的编译方式。默认情况下，它是不可捕获的。但是，如果为此编译，Perl可能会在die（）处理此消息后将 &lt;code&gt;$^M&lt;/code&gt; 的内容用作紧急池。在这种情况下，错误是可捕获的</target>
        </trans-unit>
        <trans-unit id="e06f7be9330cffa7a55aee96bfbe8c1e1072f6a9" translate="yes" xml:space="preserve">
          <source>The requests do not necessarily go always all the way down to the operating system: that's where PerlIO buffering comes into play.</source>
          <target state="translated">请求不一定总是一路传到操作系统:这就是PerlIO缓冲的作用。</target>
        </trans-unit>
        <trans-unit id="d362ada26ee954875bdcbdb4ef3110ff77e350ef" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the &quot;</source>
          <target state="translated">实际上,require函数将寻找&quot;</target>
        </trans-unit>
        <trans-unit id="7925470de731575e163d706573142112baceaaab" translate="yes" xml:space="preserve">
          <source>The require function will look for the &quot;</source>
          <target state="translated">require函数将寻找&quot;</target>
        </trans-unit>
        <trans-unit id="a4dd4536ee0a716833e52164851f465f831c0d1d" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt; ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 期间所需的参数是哈希，程序包以及对 &lt;code&gt;FETCH&lt;/code&gt; ing函数的引用。可选参数是任意标量$ data，对 &lt;code&gt;EXISTS&lt;/code&gt; 函数的引用以及哈希和存在缓存的初始值。</target>
        </trans-unit>
        <trans-unit id="37cc4a6beddbd481d62d1aa4fb0c7078c9745a11" translate="yes" xml:space="preserve">
          <source>The requires and build_requires dependency declarations</source>
          <target state="translated">requires和build_requires的依赖性声明。</target>
        </trans-unit>
        <trans-unit id="68eca29cf3cefa1ee83b5c875c176fa92ac4b217" translate="yes" xml:space="preserve">
          <source>The rest is duplicate code from MM_Unix. Should move the linker code to its own method.</source>
          <target state="translated">其余的都是MM_Unix的重复代码。应该把链接器的代码移到自己的方法中。</target>
        </trans-unit>
        <trans-unit id="5f0ee77d23f152cd1591836db1cbf485219544f6" translate="yes" xml:space="preserve">
          <source>The rest is for internal usage of this package. In particular, if TIEHASH is overwritten, it should call SUPER::TIEHASH.</source>
          <target state="translated">其余的是本包的内部使用。特别是,如果TIEHASH被覆盖,应该调用SUPER::TIEHASH。</target>
        </trans-unit>
        <trans-unit id="bf6a19c74f24c99c3610c0c4323af3d860d85c2f" translate="yes" xml:space="preserve">
          <source>The rest of the .pm file contains sample code for providing documentation for the extension.</source>
          <target state="translated">.pm文件的其余部分包含为扩展名提供文档的示例代码。</target>
        </trans-unit>
        <trans-unit id="6a0a96f4412d084abe1abbbb705cc005b4d7612f" translate="yes" xml:space="preserve">
          <source>The rest of the function description may be indented or left-adjusted. The following example shows a function with its body left-adjusted. Most examples in this document will indent the body for better readability.</source>
          <target state="translated">函数描述的其余部分可以缩进或左调整。下面的例子显示了一个函数,它的正文是向左调整的。本文档中的大多数例子都会对正文进行缩进以提高可读性。</target>
        </trans-unit>
        <trans-unit id="4748c8c8a6af67adc5b974371e823f12ce953a5d" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please email comments to &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;.</source>
          <target state="translated">本节的其余部分可能需要更新，但是我们不知道该说些什么。请通过电子邮件将评论发送至&lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3cb44cf97eef964df25c82472ad386e80122021" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt; .</source>
          <target state="translated">重新启动是使用先前实施 &lt;code&gt;longjmp&lt;/code&gt; 的在 &lt;code&gt;regatom()&lt;/code&gt; 返回一个 &lt;code&gt;setjmp&lt;/code&gt; 的在 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; ，但是这被证明是有问题的，因为后者是含有许多自动变量，大量功能，它们相互作用严重与紧急控制流程 &lt;code&gt;setjmp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e8310b48c79e713f14decd4088c7da40b8f8d5f" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt; . In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="translated">比较操作的限制是，即使例如 &lt;code&gt;cmp&lt;/code&gt; 应该返回一个有福的引用，自动生成的 &lt;code&gt;lt&lt;/code&gt; 函数也将基于 &lt;code&gt;cmp&lt;/code&gt; 结果的数值仅生成标准逻辑值。特别是在这种情况下，需要进行有效的数值转换（可能用其他转换形式表示）。</target>
        </trans-unit>
        <trans-unit id="17095fb32ad5dc43587aca28eee99cc6fee8a6b5" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;$^R&lt;/code&gt; is automatically localized, so that it will behave properly in the presence of backtracking.</source>
          <target state="translated">结果 &lt;code&gt;$^R&lt;/code&gt; 会自动进行本地化，因此在存在回溯的情况下它将正常运行。</target>
        </trans-unit>
        <trans-unit id="917b4b2d464d47448ca46f205a594a1f2094a00d" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">结果 &lt;code&gt;Regexp&lt;/code&gt; 表示该参数是由 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 生成的正则表达式。</target>
        </trans-unit>
        <trans-unit id="1beec82c5ad986daa3005ca6feae967035c22b78" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">结果 &lt;code&gt;Regexp&lt;/code&gt; 表示该参数是由 &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 生成的正则表达式。</target>
        </trans-unit>
        <trans-unit id="413c5704399ec4e320c4b4de62416c60414146e3" translate="yes" xml:space="preserve">
          <source>The result is returned as two arguments. If the modular multiplicative inverse does not exist, both arguments are undefined. Otherwise, the arguments are a number (object) and its sign (&quot;+&quot; or &quot;-&quot;).</source>
          <target state="translated">结果作为两个参数返回。如果模块乘法逆不存在,则两个参数都是未定义的,否则,参数是数字(对象)和它的符号(&quot;+&quot;或&quot;-&quot;)。否则,参数是一个数字(对象)和它的符号(&quot;+&quot;或&quot;-&quot;)。</target>
        </trans-unit>
        <trans-unit id="e2176289afdf7f655c62c369888f79d214a9f024" translate="yes" xml:space="preserve">
          <source>The result is that the contents of line 17 of the file will be replaced with &quot;Cherry pie&quot;; a newline character will separate line 17 from line 18. This means that this code will do nothing:</source>
          <target state="translated">结果是文件第17行的内容将被替换为 &quot;Cherry pie&quot;;一个换行符将第17行和第18行分开。这意味着这段代码什么都不会做。</target>
        </trans-unit>
        <trans-unit id="f863b8e99992f5c2a779d9ed98aecf9cef5b7a84" translate="yes" xml:space="preserve">
          <source>The result is the Unicode character or character sequence given by</source>
          <target state="translated">其结果是Unicode字符或字符序列,给出了</target>
        </trans-unit>
        <trans-unit id="17faf27e0d190c0297fec9a5baff8ccb279e91a8" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由括号之间的十六进制数字指定的字符。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1743ff5152c2110b7544e70901f154f3b6b46b92" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由十六进制数字指定的字符，范围为​​0x00至0xFF。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6bbe820fb63fd799e4d92d37fd1768342fc0ad13" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由括号之间的八进制数字指定的字符。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5d07b8bddc1c5dd823f98677754aff0c68b0c00" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">结果是由三位数的八进制数指定的字符，范围在000到777之间（但最好不要在077以上使用，请参阅下一段）。有关哪个字符的详细信息，请参见下面的&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d2ac189a7b892d497c3a957f821832172806b14" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;code&gt;xhdr&lt;/code&gt; except the is will be restricted to headers where the text of the header matches &lt;code&gt;PATTERN&lt;/code&gt;</source>
          <target state="translated">结果与 &lt;code&gt;xhdr&lt;/code&gt; 相同，除了仅限于标头文本与 &lt;code&gt;PATTERN&lt;/code&gt; 匹配的标头</target>
        </trans-unit>
        <trans-unit id="37186ac3e81998654b9034f359d33c97b138b201" translate="yes" xml:space="preserve">
          <source>The result may be used as a subpattern in a match:</source>
          <target state="translated">其结果可作为匹配中的子模式使用。</target>
        </trans-unit>
        <trans-unit id="30a38c7996159062562ab2957a6c23713b7a1d86" translate="yes" xml:space="preserve">
          <source>The result of evaluation of the last successful &lt;code&gt;(?{ code })&lt;/code&gt; regular expression assertion (see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). May be written to.</source>
          <target state="translated">最后一个成功的 &lt;code&gt;(?{ code })&lt;/code&gt; 正则表达式断言的求值结果（请参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;）。可能被写入。</target>
        </trans-unit>
        <trans-unit id="66611e861a602cfa60591a93b737577becd37f08" translate="yes" xml:space="preserve">
          <source>The result of great_circle_direction is in radians, zero indicating straight north, pi or -pi straight south, pi/2 straight west, and -pi/2 straight east.</source>
          <target state="translated">great_circle_direction的结果以弧度为单位,0表示直北,pi或-pi直南,pi/2直西,-pi/2直东。</target>
        </trans-unit>
        <trans-unit id="f6846ed84b71cca2d8b5fb5477773187fbddddb3" translate="yes" xml:space="preserve">
          <source>The result of md5(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) will be exactly the same as the result of md5(&quot;abc&quot;).</source>
          <target state="translated">md5(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)的结果将与md5(&quot;abc&quot;)的结果完全相同。</target>
        </trans-unit>
        <trans-unit id="641d055cafe1e1ee3cae38ce56b7935f5d3bc2b3" translate="yes" xml:space="preserve">
          <source>The result of overflowing the range of the integers is undefined because it is undefined also in C. In other words, using 32-bit integers, &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; is undefined. Shifting by a negative number of bits is also undefined.</source>
          <target state="translated">整数范围溢出的结果是不确定的，因为在C语言中也未定义。换句话说，使用32位整数， &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; 是不确定的。移位为负数位也是不确定的。</target>
        </trans-unit>
        <trans-unit id="00de3247a1fa0dbaa5340672e75fce7f76fa569f" translate="yes" xml:space="preserve">
          <source>The result of this scenario is at best a database that doesn't contain what you expect. At worst the database will corrupt.</source>
          <target state="translated">这种情况的结果是,最好的情况是数据库中没有你所期望的内容。最坏的情况是数据库会损坏。</target>
        </trans-unit>
        <trans-unit id="f6de57c3d8ec6b1611fc0077d370dda9fed1574d" translate="yes" xml:space="preserve">
          <source>The result returned will be one of the following:</source>
          <target state="translated">返回的结果将是以下之一:</target>
        </trans-unit>
        <trans-unit id="0b8a9a1357d52322f675cb2cb87488ac744f63b6" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="translated">如果包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 形式有效，则包含插值材料的结果字符串将被污染。</target>
        </trans-unit>
        <trans-unit id="51fb17ca190a73d84710650cb1a592da2c670185" translate="yes" xml:space="preserve">
          <source>The result will be an array of 3 elements, each a reference to an array which will hold the handles that are ready for reading, writing and have exceptions respectively. Upon error an empty list is returned.</source>
          <target state="translated">结果将是一个由3个元素组成的数组,每个元素都是一个数组的引用,数组中分别存放着准备好读、写和有异常的句柄。一旦出错,将返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="a68ddca584ffd166b11e615f1b961f7dd364600e" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="translated">结果最多是层数的三倍：第一个元素是名称，第二个元素是参数（未指定的参数是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），第三个元素是标志，第四个元素再次是名称，依此类推向前。</target>
        </trans-unit>
        <trans-unit id="e6e0c7dba94f1684aba5f4cd6501d599a99358de" translate="yes" xml:space="preserve">
          <source>The resulting $subdir_cmd has no leading tab nor trailing newline. This makes it easier to embed in a make string. For example.</source>
          <target state="translated">产生的$subdir_cmd没有前导符,也没有尾部的换行。这使得它更容易嵌入到make字符串中。例如</target>
        </trans-unit>
        <trans-unit id="5f6fcb4f54789b9c880bc0144fb1cf2ebd3b3159" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; values of this string's bytes - the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="translated">生成的字节序列最方便用于检查校验和。不要通过for循环添加此字符串字节的 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 值来减慢程序的速度- &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 代码 &lt;code&gt;%&lt;/code&gt; 是用于计算所有字节的8位总和的东西，该总和必须等于零：</target>
        </trans-unit>
        <trans-unit id="421b5462923e8d16da2f8509620d57a56b898133" translate="yes" xml:space="preserve">
          <source>The resulting path is relative by default, i.e. the resulting path will have a leading colon.</source>
          <target state="translated">默认情况下,生成的路径是相对的,也就是说,生成的路径会有一个前导的冒号。</target>
        </trans-unit>
        <trans-unit id="d4b19b5c805ca56f431cfbcdeba1af9f3a6200a3" translate="yes" xml:space="preserve">
          <source>The resulting program then looks like:</source>
          <target state="translated">然后,产生的程序就像。</target>
        </trans-unit>
        <trans-unit id="bd638c59c5752a7ccfc83a3bf825d1784299cda6" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">可以将结果传递到&lt;a href=&quot;#catpath&quot;&gt;catpath，&lt;/a&gt;以获取与原始路径相同（通常相同）的路径。</target>
        </trans-unit>
        <trans-unit id="fbae74b52e9e1a2f4034868dc967236dfb097109" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath()&quot;&gt;catpath()&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">可以将结果传递到&lt;a href=&quot;#catpath()&quot;&gt;catpath（）&lt;/a&gt;以获取与原始路径等效（通常相同）的路径。</target>
        </trans-unit>
        <trans-unit id="9fd6f04fef4668c0fb9b5436580855adbbe256e9" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;code&gt;catpath()&lt;/code&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">可以将结果传递到 &lt;code&gt;catpath()&lt;/code&gt; 以获取与原始路径等效（通常相同）的路径。</target>
        </trans-unit>
        <trans-unit id="7b48baa73a171c70124bb46d586398a253fc305f" translate="yes" xml:space="preserve">
          <source>The results follow ASCII rules. Only the characters &lt;code&gt;A-Z&lt;/code&gt; change, to &lt;code&gt;a-z&lt;/code&gt; respectively.</source>
          <target state="translated">结果遵循ASCII规则。仅字符 &lt;code&gt;A-Z&lt;/code&gt; 更改为 &lt;code&gt;a-z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6e1386230ca5a3e137558786aef0b9ef4ab7b59" translate="yes" xml:space="preserve">
          <source>The results of creating new symbol table entries directly or modifying any entries that are not already typeglobs are undefined and subject to change between releases of perl.</source>
          <target state="translated">直接创建新的符号表条目或修改任何还没有 typeglobs 的条目的结果都是未定义的,并且在 perl 的不同版本之间会发生变化。</target>
        </trans-unit>
        <trans-unit id="7c1728e8e43393222dde9f78fe3123aaa1846fe7" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt; , use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="translated">从 &lt;code&gt;VERSION&lt;/code&gt; 返回的内容实际上是使用 &lt;code&gt;$VERSION&lt;/code&gt; 标量包的字符串化版本对象，该对象保证是等效的，但可能与 &lt;code&gt;$VERSION&lt;/code&gt; 标量的内容不完全相同。如果您需要 &lt;code&gt;$VERSION&lt;/code&gt; 的实际内容，请改用 &lt;code&gt;$CLASS::VERSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94b2a16af23a66e19e44621474dc0fa990710d75" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="translated">生成的Perl函数的返回列表由该函数的C返回值组成（除非XSUB为 &lt;code&gt;void&lt;/code&gt; 返回类型或 &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; ），然后是所有 &lt;code&gt;OUTLIST&lt;/code&gt; 和 &lt;code&gt;IN_OUTLIST&lt;/code&gt; 参数（按出现的顺序）。从XSUB返回时，将修改 &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; Perl参数，使其具有C函数写入的值。</target>
        </trans-unit>
        <trans-unit id="a21da59cc5c1c0e700b109e9dda17411cbacb1df" translate="yes" xml:space="preserve">
          <source>The return true when the argument satisfies the condition. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; are not integers and are neither odd nor even.</source>
          <target state="translated">当参数满足条件时返回true。 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;+inf&lt;/code&gt; ， &lt;code&gt;-inf&lt;/code&gt; 不是整数，也不是奇数也不是偶数。</target>
        </trans-unit>
        <trans-unit id="b8bfaca788fa3c0ddbe45ea5ad9f0da16e79efb8" translate="yes" xml:space="preserve">
          <source>The return value (if defined) is a Perl object, of class &lt;code&gt;PerlIO::Layer&lt;/code&gt; which is created by the C code in</source>
          <target state="translated">返回值（如果已定义）是 &lt;code&gt;PerlIO::Layer&lt;/code&gt; 类的Perl对象，该对象由C语言中的C创建</target>
        </trans-unit>
        <trans-unit id="45642a1469744a5e7107d7873a8272d52cfce5d2" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">返回值 &lt;code&gt;LVALUE&lt;/code&gt; 表示对不是变量的左值的引用。您可以通过引用函数调用（例如 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; )来实现。如果引用指向&lt;a href=&quot;perldata#Version-Strings&quot;&gt;版本字符串，&lt;/a&gt;则返回 &lt;code&gt;VSTRING&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68a59800451bff6b585d75aa0febce039f889432" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">返回值 &lt;code&gt;LVALUE&lt;/code&gt; 表示对不是变量的左值的引用。您可以通过引用函数调用（例如 &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; )来实现。如果引用指向&lt;a href=&quot;../perldata#Version-Strings&quot;&gt;版本字符串，&lt;/a&gt;则返回 &lt;code&gt;VSTRING&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1b1a3b59d37e5fda7fca51bd6d7cc822e1098fc" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="translated">可以 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 返回值以获取原始引用结构的相同副本。（请务必考虑从不受信任的来源评估代码的安全性！）</target>
        </trans-unit>
        <trans-unit id="5ce36c299811e6d9af00c0cefc9c75e073456ac7" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; 的返回值是实现定义的；有关更多信息，请查阅您的atan2（3）联机帮助页。</target>
        </trans-unit>
        <trans-unit id="769d902022de1a90d1cd24370f703e7b45d5dad4" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; 的返回值是实现定义的；有关更多信息，请查阅您的atan2（3）联机帮助页。</target>
        </trans-unit>
        <trans-unit id="7fa7da95c4b58e8bb23e135f8795df5f9ac97aa0" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">返回值是 &lt;code&gt;true&lt;/code&gt; ，如果这是一个有效的原型， &lt;code&gt;false&lt;/code&gt; 如果不是，不论 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd97a8975a72082d0544ff1e498721e427862ae3" translate="yes" xml:space="preserve">
          <source>The return value is POSIX-like (shifted up by 8 bits), which only allows room for a made-up value derived from the severity bits of the native 32-bit condition code (unless overridden by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ). If the native condition code is one that has a POSIX value encoded, the POSIX value will be decoded to extract the expected exit value. For more details see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt;. (VMS)</source>
          <target state="translated">返回值是POSIX样（移由8位），只允许室用于从本地32位条件代码的严重性位（除非由重写衍生的虚构的值 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ）。如果本地条件代码是已编码POSIX值的代码，则POSIX值将被解码以提取预期的退出值。有关更多详细信息，请参见&lt;a href=&quot;perlvms#%24%3f&quot;&gt;$？在perlvms中&lt;/a&gt;。（VMS）</target>
        </trans-unit>
        <trans-unit id="43901da674d6737b62ebf11f4c04c938005307af" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="translated">返回值始终是标量，可以是字符串或数字。对于具有值同义词的属性，此函数返回的同义词是最长，最具描述性的形式，当在标量上下文中调用时，&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;返回的形式。当然，您可以在结果上调用&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;以获取其他同义词。</target>
        </trans-unit>
        <trans-unit id="01e2753bab1a4f25f52114a02dccb7b840c45d95" translate="yes" xml:space="preserve">
          <source>The return value is the $ctx object itself.</source>
          <target state="translated">返回值是$ctx对象本身。</target>
        </trans-unit>
        <trans-unit id="52ee5d406f163544969cdcc538ef722336dcb763" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">返回值是 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 调用返回的程序的退出状态。要获得实际的退出值，请向右移动八位（请参见下文）。另请参阅&lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;。这是</target>
        </trans-unit>
        <trans-unit id="aadd087b1069c48b3ff2e37ed0925a6bb732b05e" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">返回值是 &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 调用返回的程序的退出状态。要获得实际的退出值，请向右移动八位（请参见下文）。另请参阅&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;。这是</target>
        </trans-unit>
        <trans-unit id="857262cdace40b471947bb6d3b761ee596eafe64" translate="yes" xml:space="preserve">
          <source>The return value is the updated object itself.</source>
          <target state="translated">返回值是更新后的对象本身。</target>
        </trans-unit>
        <trans-unit id="7f93f7b8be78580a6fdb8b5153d679ad923050d6" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回值可以是包含零个或多个arrayref，一个整数或 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="36fd088c56b8f88cc2d2e8985a8fda08a71a63d3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="translated">返回值可以是第1到第4权重的arrayref，如上所示。返回值可以是整数作为主要权重，如下所示。如果返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则将使用默认的派生排序规则元素。</target>
        </trans-unit>
        <trans-unit id="9d5675dc8f958bc8634e0a1b5851a8577fc5c3bc" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; （和 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ）的返回值如下：</target>
        </trans-unit>
        <trans-unit id="03abb254ae6958b0d4d3e3d838f5570ae93832e6" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; （和 &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ）的返回值如下：</target>
        </trans-unit>
        <trans-unit id="16085bf8175ff49a2dcc989db1bc66f5346f4ab0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;INLINED&lt;/code&gt; in this example will always be 54321, regardless of later modifications to $x. You can also put any arbitrary code inside the sub, at it will be executed immediately and its return value captured the same way.</source>
          <target state="translated">在此示例中， &lt;code&gt;INLINED&lt;/code&gt; 的返回值将始终为54321，而不管以后对$ x的修改如何。您还可以将任意代码放入子代码中，然后立即执行该子代码，并以相同的方式捕获其返回值。</target>
        </trans-unit>
        <trans-unit id="f23542316437f18c2dc0de0ad16ae0deb404671a" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;survey&lt;/code&gt; is two hashes:</source>
          <target state="translated">&lt;code&gt;survey&lt;/code&gt; 的返回值是两个散列：</target>
        </trans-unit>
        <trans-unit id="6c7d2d6bce6775764986b9434f93f3fd3d99f22b" translate="yes" xml:space="preserve">
          <source>The return value of Pod::Perldoc::GetOptsOO::getopts is true if no errors, otherwise it's false.</source>
          <target state="translated">如果没有错误,Pod::Perldoc::GetOptsOO::getopts的返回值为true,否则为false。</target>
        </trans-unit>
        <trans-unit id="57cb77ff2698d7727be628530d185f8aa579f00d" translate="yes" xml:space="preserve">
          <source>The return value of tell() for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. tell() on pipes, fifos, and sockets usually returns -1.</source>
          <target state="translated">tell()对标准流(如STDIN)的返回值取决于操作系统:它可能返回-1或其他值。在管道、fifos和套接字上的tell()通常返回-1。</target>
        </trans-unit>
        <trans-unit id="972da9f747345510c81b2dc820fd0994a9799509" translate="yes" xml:space="preserve">
          <source>The return value will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt; . Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">如果操作失败或如果不需要将该值实际存储在散列中（如绑定散列的情况），则返回值将为NULL。否则，可以取消引用以获取原始 &lt;code&gt;SV*&lt;/code&gt; 。注意，调用者负责在调用之前适当地增加 &lt;code&gt;val&lt;/code&gt; 的引用计数，并在函数返回NULL时递减它。实际上，成功的hv_store拥有对 &lt;code&gt;val&lt;/code&gt; 的一个引用的所有权。这通常是您想要的；新创建的SV的引用计数为1，因此，如果您所有的代码都是创建SV，然后将它们存储在哈希中，则hv_store将拥有对新SV的唯一引用，并且您的代码无需执行任何其他操作即可整理。 hv_store未实现为对hv_store_ent的调用，并且不会为密钥创建临时SV，因此，如果您的密钥数据尚未采用SV格式，则优先使用hv_store而不是hv_store_ent。</target>
        </trans-unit>
        <trans-unit id="9bfc61e3c5920efd0c58d16c1ed44649d2d5bb7c" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error condition, followed by the hostname and service name.</source>
          <target state="translated">返回值将是一个列表;第一个值是错误条件,后面是主机名和服务名。</target>
        </trans-unit>
        <trans-unit id="080fb2b25b92c9701522bdcbe08ea5301edb65d9" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error indication, followed by a list of address structures (if no error occurred).</source>
          <target state="translated">返回值将是一个列表;第一个值是一个错误指示,后面是一个地址结构的列表(如果没有发生错误)。</target>
        </trans-unit>
        <trans-unit id="e58ba0106a37355ff008e5789a74611883b7e6cc" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains a reference to an array which contains the overview fields for that message.</source>
          <target state="translated">返回值将是对哈希的引用,其中键是消息编号,每个值包含对数组的引用,数组中包含该消息的概览字段。</target>
        </trans-unit>
        <trans-unit id="c8d88b4235e896d1cdf2637f38fe289f36609de1" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains the text of the requested header for that message.</source>
          <target state="translated">返回值将是对哈希的引用,其中键是消息号码,每个值包含该消息的请求头的文本。</target>
        </trans-unit>
        <trans-unit id="17d18fcb9f371a15bbc60a7727df47264e8d90a5" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="translated">返回值比&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;更&amp;ldquo;煮熟&amp;rdquo; 。例如， &lt;code&gt;&quot;uc&quot;&lt;/code&gt; 属性值是包含输入代码点的完整大写字母映射的实际字符串。当完整映射与简单映射不同时，必须麻烦 &lt;code&gt;charinfo&lt;/code&gt; 才能从其 &lt;code&gt;upper&lt;/code&gt; 哈希元素获取此值。</target>
        </trans-unit>
        <trans-unit id="3df12c311a5affa1878c7637ef497a0992643ca1" translate="yes" xml:space="preserve">
          <source>The returned object will only be valid as long as the underlying OPs and SVs continue to exist. Do not attempt to use the object after the underlying structures are freed.</source>
          <target state="translated">只有在底层OP和SV继续存在的情况下,返回的对象才会有效。在底层结构被释放后,不要试图使用该对象。</target>
        </trans-unit>
        <trans-unit id="afb88fca63fb7d940d0f8f78e07d1c80fa709c01" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">返回的值是哈希中原始键的副本，因此修改它们将不会影响原始哈希。比较&lt;a href=&quot;#values&quot;&gt;值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d53dad6b674af04a6d84ac0aee48048c271fdde" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">返回的值是哈希中原始键的副本，因此修改它们将不会影响原始哈希。比较&lt;a href=&quot;values&quot;&gt;值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21a00c167788624d4ca90d4b617125a344dae47a" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot; in a Perl regular rexpression for these, like &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ,</source>
          <target state="translated">Perl扩展属性（例如 &lt;code&gt;Any&lt;/code&gt; 和 &lt;code&gt;Greek&lt;/code&gt; )的返回值有些误导。值为 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;N&lt;/code&gt; &amp;rdquo;。所有Unicode属性都是两部分的，因此您实际上可以在Perl常规表达式中使用 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;N&lt;/code&gt; &amp;rdquo;，例如 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt; 。但是，并不是以这种方式指定Perl扩展名，仅像 &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="f5eea968d1f523529d28fcd024fbb7e15c83c048" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object.</source>
          <target state="translated">Perl解释器的修订版，版本和子版本，表示为&lt;a href=&quot;version&quot;&gt;版本&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="85e9edc5bb272a0ee91c10e7c6d3172fdb763afd" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a decimal of the form 5.XXXYYY, where XXX is the version / 1e3 and YYY is the subversion / 1e6. For example, Perl v5.10.1 would be &quot;5.010001&quot;.</source>
          <target state="translated">Perl 解释器的修订版、版本和子版本,用小数表示,形式为 5.XXXYYY,其中 XXX 是版本/1e3,YYY 是子版本/1e6。例如,Perl v5.10.1就是 &quot;5.010001&quot;。</target>
        </trans-unit>
        <trans-unit id="66e488be2f8483df95b9f037ffeda3de74384599" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt; . The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="translated">在某些操作上，例如 &lt;code&gt;new()&lt;/code&gt; ， &lt;code&gt;bstr()&lt;/code&gt; 和 &lt;code&gt;numify()&lt;/code&gt; ，此模块的重写版本（vs. v0.01）速度较慢。原因是它现在做更多的工作并处理更多的案件。通常在其他数学运算中会花费在这些运算上的时间，因此平均而言，代码应该（快得多）快得多。如果没有，请与作者联系。</target>
        </trans-unit>
        <trans-unit id="23622f986ab9be80262d33005c6066bc0cc050da" translate="yes" xml:space="preserve">
          <source>The right column will also caution you if a property means something different than what might normally be expected.</source>
          <target state="translated">如果一个属性的含义与通常预期的不同,右栏也会提醒你。</target>
        </trans-unit>
        <trans-unit id="ae21a75ed2b2f6ef4dbb92843a55ab639a296c6c" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt; also in</source>
          <target state="translated">从第5行开始，右侧类似于我们刚刚看到的内容：我们有 &lt;code&gt;add&lt;/code&gt; op（ &lt;code&gt;pp_add&lt;/code&gt; 也位于</target>
        </trans-unit>
        <trans-unit id="88e3fe5f1905fd5d0642f37b1a353b457c2b5b66" translate="yes" xml:space="preserve">
          <source>The right operand is not evaluated while the operator is in the &quot;false&quot; state, and the left operand is not evaluated while the operator is in the &quot;true&quot; state. The precedence is a little lower than || and &amp;amp;&amp;amp;. The value returned is either the empty string for false, or a sequence number (beginning with 1) for true. The sequence number is reset for each range encountered. The final sequence number in a range has the string &lt;code&gt;&quot;E0&quot;&lt;/code&gt; appended to it, which doesn't affect its numeric value, but gives you something to search for if you want to exclude the endpoint. You can exclude the beginning point by waiting for the sequence number to be greater than 1.</source>
          <target state="translated">当运算符处于&amp;ldquo; false&amp;rdquo;状态时，不评估右侧操作数，而当运算符处于&amp;ldquo; true&amp;rdquo;状态时，不评估左侧操作数。优先级略低于|| 和&amp;amp;&amp;amp;。返回的值要么为空字符串（为false），要么为序列号（从1开始）为true。将为遇到的每个范围重置序列号。范围中的最后一个序列号附加了字符串 &lt;code&gt;&quot;E0&quot;&lt;/code&gt; ，这不会影响其数值，但是如果您要排除端点，则会为您提供一些搜索内容。您可以通过等待序列号大于1来排除起点。</target>
        </trans-unit>
        <trans-unit id="712b7dd783ec62d03111b67512c4c71fb70fa066" translate="yes" xml:space="preserve">
          <source>The rightmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;gt;&quot;).</source>
          <target state="translated">最右边的定界符从参数文本开始到内部序列（应为&amp;ldquo;&amp;gt;&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="f1b13ab5c99b5028d035c2e34026b78f830a5ce1" translate="yes" xml:space="preserve">
          <source>The rmtree() function provide the legacy interface of remove_tree() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to remove_tree().</source>
          <target state="translated">rmtree()函数提供了传统的remove_tree()的接口,但对传递的参数有不同的解释。该函数的行为和返回值与 remove_tree()完全相同。</target>
        </trans-unit>
        <trans-unit id="97d9690fe48f5ed9ac8be9b70513653d3ab42339" translate="yes" xml:space="preserve">
          <source>The rot13 example was a trivial example. Here's another demonstration that shows off a few more features.</source>
          <target state="translated">rot13的例子是一个微不足道的例子。下面是另一个演示,展示了一些更多的功能。</target>
        </trans-unit>
        <trans-unit id="4a28f646da84403da9a05e371721d016d1168285" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$idx]&lt;/code&gt; .</source>
          <target state="translated">perl的大致等效项是 &lt;code&gt;$myarray[$idx]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07cb0ce6d373861ed9384fe1d2dba7e82ae7d7eb" translate="yes" xml:space="preserve">
          <source>The routine &lt;code&gt;regtail()&lt;/code&gt; is called by both &lt;code&gt;reg()&lt;/code&gt; and &lt;code&gt;regbranch()&lt;/code&gt; in order to &quot;set the tail pointer&quot; correctly. When executing and we get to the end of a branch, we need to go to the node following the grouping parens. When parsing, however, we don't know where the end will be until we get there, so when we do we must go back and update the offsets as appropriate. &lt;code&gt;regtail&lt;/code&gt; is used to make this easier.</source>
          <target state="translated">&lt;code&gt;reg()&lt;/code&gt; 和 &lt;code&gt;regbranch()&lt;/code&gt; 都调用例程 &lt;code&gt;regtail()&lt;/code&gt; ，以便正确地&amp;ldquo;设置尾部指针&amp;rdquo;。执行时，我们到达分支的末尾，我们需要转到分组parens之后的节点。但是，在解析时，直到到达终点，我们才知道终点在哪里，所以当我们这样做时，我们必须返回并适当地更新偏移量。 &lt;code&gt;regtail&lt;/code&gt; 用于简化此过程。</target>
        </trans-unit>
        <trans-unit id="96fb8a6192d6d2137dae358308fab281f2803684" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; , a loop exit, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt; .</source>
          <target state="translated">当即将引发致命异常时，将调用 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 指示的例程。错误消息将作为第一个参数传递。当 &lt;code&gt;__DIE__&lt;/code&gt; 钩子例程返回时，异常处理将像没有钩子时一样继续进行，除非钩子例程本身通过 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; ，循环出口或 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 退出。该 &lt;code&gt;__DIE__&lt;/code&gt; 处理程序在通话过程中明确禁用，这样就可以从一个死 &lt;code&gt;__DIE__&lt;/code&gt; 处理程序。 &lt;code&gt;__WARN__&lt;/code&gt; 同样。</target>
        </trans-unit>
        <trans-unit id="c23e498d9e0f7b9916602bb81bb457e05dc15d28" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt; . The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="translated">最常用的例程是 &lt;code&gt;call_sv&lt;/code&gt; 。在 &lt;code&gt;SV*&lt;/code&gt; 参数中包含的任何Perl函数的名称叫，或者给子程序的引用。第二个参数由标志组成，这些标志控制在其中调用子例程的上下文，是否正在传递子例程参数，应如何捕获错误以及如何处理返回值。</target>
        </trans-unit>
        <trans-unit id="02aa17c916dde6540e50fc69118a82269239b3fa" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;b&gt;false&lt;/b&gt; otherwise.</source>
          <target state="translated">否则，该例程返回&lt;b&gt;false&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2a6f415596eaaeb6ae6674de29690a406129631d" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; exception.</source>
          <target state="translated">例程针对I / O问题或其他内部错误返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，否则返回true。严重的错误将作为 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 传播。</target>
        </trans-unit>
        <trans-unit id="30cd5a5724b0cdff1db0ded8bf4cad313b5d3163" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;reftype&lt;/code&gt; are exportable.</source>
          <target state="translated">例程 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;reftype&lt;/code&gt; 可导出。</target>
        </trans-unit>
        <trans-unit id="7978092db3768ef7e6d213d57a05b4b46c4c1d11" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; exported by default. You must specify which ones you want to use.</source>
          <target state="translated">该程序 &lt;code&gt;make_path&lt;/code&gt; 和 &lt;code&gt;remove_tree&lt;/code&gt; 都&lt;b&gt;不会&lt;/b&gt;默认被导出。您必须指定要使用的那些。</target>
        </trans-unit>
        <trans-unit id="5f252df425e68241a153a06fc0e9c8513b5f1aa7" translate="yes" xml:space="preserve">
          <source>The routines are called in string comparison order of KEY.</source>
          <target state="translated">例程按KEY的字符串比较顺序调用。</target>
        </trans-unit>
        <trans-unit id="258695837b0d342f488ae3724d49cf11d73778d9" translate="yes" xml:space="preserve">
          <source>The rule by which Digest::SHA handles a Unicode string is easy to state, but potentially confusing to grasp: the string is interpreted as a sequence of byte values, where each byte value is equal to the ordinal value (viz. code point) of its corresponding Unicode character. That way, the Unicode string 'abc' has exactly the same digest value as the ordinary string 'abc'.</source>
          <target state="translated">Digest::SHA处理Unicode字符串的规则很容易说明,但可能会让人感到困惑:字符串被解释为一个字节值序列,其中每个字节值等于其对应Unicode字符的序数值(即码点)。这样一来,Unicode字符串'abc'与普通字符串'abc'具有完全相同的数字值。</target>
        </trans-unit>
        <trans-unit id="6b4e5af62f9d03a0b5c8d39854ce10f47d56d0b1" translate="yes" xml:space="preserve">
          <source>The rule must only have one top level key: either 'par' for &quot;parallel&quot; or 'seq' for &quot;sequence&quot;.</source>
          <target state="translated">规则必须只有一个顶层键:&quot;parallel &quot;的'par'或 &quot;sequence &quot;的'seq'。</target>
        </trans-unit>
        <trans-unit id="2858e68dbb1d52d413ae8f5dae1d589d672ac788" translate="yes" xml:space="preserve">
          <source>The rule of thumb for portable code is: Do it all in portable Perl, or use a module (that may internally implement it with platform-specific code, but exposes a common interface).</source>
          <target state="translated">可移植代码的经验法则是。全部用可移植的Perl来做,或者使用一个模块(可以在内部用特定平台的代码来实现,但要暴露一个通用接口)。</target>
        </trans-unit>
        <trans-unit id="d771186d9f060b8e39d56f4b8de80fe1694de984" translate="yes" xml:space="preserve">
          <source>The rules data structure is documented more in the next section.</source>
          <target state="translated">规则数据结构在下一节会有更多的记载。</target>
        </trans-unit>
        <trans-unit id="b2b47541d9fe53d041ea0cd594a357e270362960" translate="yes" xml:space="preserve">
          <source>The rules determining what it is are quite simple: if the character following the backslash is an ASCII punctuation (non-word) character (that is, anything that is not a letter, digit, or underscore), then the backslash just takes away any special meaning of the character following it.</source>
          <target state="translated">决定它是什么的规则很简单:如果反斜线后面的字符是ASCII标点符号(非单词)字符(即任何不是字母、数字或下划线的字符),那么反斜线只是带走了它后面字符的任何特殊意义。</target>
        </trans-unit>
        <trans-unit id="f747d6278f9a09b6ca106424547e7e55bc600835" translate="yes" xml:space="preserve">
          <source>The rules of conduct that, in the absence of other guidance, determine what should happen first. For example, in the absence of parentheses, you always do multiplication before addition.</source>
          <target state="translated">在没有其他指导意见的情况下,决定应该先做什么的行为规则。例如,在没有括号的情况下,你总是先做乘法再做加法。</target>
        </trans-unit>
        <trans-unit id="4ac2685482eb75c8db66c436a646aa6e3d97f9ed" translate="yes" xml:space="preserve">
          <source>The runtime component should have the name</source>
          <target state="translated">运行时组件的名称应该是</target>
        </trans-unit>
        <trans-unit id="763ace778385d85ae756e3844782d5cfee6e0e05" translate="yes" xml:space="preserve">
          <source>The same approach as a command line:</source>
          <target state="translated">与命令行的方法相同。</target>
        </trans-unit>
        <trans-unit id="9976b6a81a6abb21b7cab5b632b4ad690c05665b" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 相同，但是如果无法自动生成丢失的运算符，则可以在不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 指令的情况下，允许Perl还原为对该运算符执行的操作，而不是发出错误消息。</target>
        </trans-unit>
        <trans-unit id="286499ca118e6aee1159ad012e0d0c293bc05679" translate="yes" xml:space="preserve">
          <source>The same checksum can also be calculated in OO style:</source>
          <target state="translated">同样的校验和也可以用OO式计算。</target>
        </trans-unit>
        <trans-unit id="e7121397996c97368f3bf5006e5d7cf5183183f6" translate="yes" xml:space="preserve">
          <source>The same effect as the example above in a different way. The coderef takes the alias name as an argument and returns a canonical name on success or undef if not. Note the second argument is ignored if provided. Use this with even more caution than the regex version.</source>
          <target state="translated">与上面的例子效果相同,但方式不同。coderef将别名作为参数,并在成功时返回一个规范的名称,如果不成功则返回undef。注意,如果提供了第二个参数,则会被忽略。使用这个方法要比使用 regex 版本更加谨慎。</target>
        </trans-unit>
        <trans-unit id="e43451146d37e633afabe95e907553562bae7cb9" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">对于包含子例程或当前正在执行的评估字符串也是如此。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 字符串的$ filename 看起来像 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a048bf53e27173e747513cb4000a6c6bd711ca9e" translate="yes" xml:space="preserve">
          <source>The same information is displayed at the end of the output from the command</source>
          <target state="translated">同样的信息也会显示在命令</target>
        </trans-unit>
        <trans-unit id="fe72bff5d187e52fa5d199f09887af6af2e32815" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; : these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="translated">对于 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 的实现，情况并非如此：期望它们修改其操作数。的适当实现 &lt;code&gt;--&lt;/code&gt; 可能看起来像</target>
        </trans-unit>
        <trans-unit id="b9889316caadba38254c295ba1f667d08e692e37" translate="yes" xml:space="preserve">
          <source>The same might happen to AIX 5.1 or other OS levels. As a side note, Perl cannot be built without bos.adt.syscalls and bos.adt.libm installed</source>
          <target state="translated">同样的情况也可能发生在AIX 5.1或其他级别的操作系统上。另外,如果没有安装bos.adt.syscalls和bos.adt.libm,Perl是无法构建的。</target>
        </trans-unit>
        <trans-unit id="2d3beec233d4767fecd283497936fe00947a8d1a" translate="yes" xml:space="preserve">
          <source>The same package name can be used more than once, allowing for non-contiguous code. This is useful if you have a stronger ordering principle than package names.</source>
          <target state="translated">同一个包名可以使用一次以上,允许使用不相邻的代码。如果你有比包名更强的排序原则,这很有用。</target>
        </trans-unit>
        <trans-unit id="adf0ce12f9a7b11a4e4d148adc2353bc6022f25b" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="translated">如果在非ISO8859-1和非UTF-8语言环境中启用标准文件句柄，默认 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 层和 &lt;code&gt;@ARGV&lt;/code&gt; 的自动UTF-8化，则会出现相同的问题（通过使用&lt;b&gt;-C&lt;/b&gt;命令行或 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 环境变量；请参见&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;）。事物以UTF-8的形式读入，这通常意味着使用Unicode解释，但是语言环境的存在会导致它们在该语言环境中进行解释。例如，Unicode输入中的0xD7代码点（应表示乘法符号）在希腊语环境下不会被Perl那样解释。这不是问题</target>
        </trans-unit>
        <trans-unit id="8104fdf41371cefa43c656a17bffde6b62386dd0" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from BigInt.</source>
          <target state="translated">如果将它们传递给Math :: BigInt-&amp;gt; binf（）对象，则会发生相同的问题。由于不可能重载这些例程，因此无法通过BigInt进行修复。</target>
        </trans-unit>
        <trans-unit id="70e999fed9c0e326d353539553d4a7555374fd82" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in unpack().</source>
          <target state="translated">同样的模板一般也可以用在unpack()中。</target>
        </trans-unit>
        <trans-unit id="6b6c7f4b6ab698dbba6b63d74e5bcb57fa5d9973" translate="yes" xml:space="preserve">
          <source>The same tests are run both times, but more information is provided when running as &lt;code&gt;./perl harness&lt;/code&gt;.</source>
          <target state="translated">两次都运行相同的测试，但是以 &lt;code&gt;./perl harness&lt;/code&gt; 运行时会提供更多信息。</target>
        </trans-unit>
        <trans-unit id="1f4add58be52aaba625e5f7ff33a20f204714d58" translate="yes" xml:space="preserve">
          <source>The sample program:</source>
          <target state="translated">样板程序。</target>
        </trans-unit>
        <trans-unit id="f745bb5cbca08197cbed6d6403139abf437a8fa9" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt; .</source>
          <target state="translated">标量 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值存储在称为 &lt;code&gt;PL_sv_undef&lt;/code&gt; 的SV实例中。</target>
        </trans-unit>
        <trans-unit id="6e858b562140c68ce32ea23e2b6e666b2e82798f" translate="yes" xml:space="preserve">
          <source>The scalar/list context for the subroutine and for the right-hand side of assignment is determined as if the subroutine call is replaced by a scalar. For example, consider:</source>
          <target state="translated">子程序和赋值右侧的标量/列表上下文的确定,就像子程序调用被标量代替一样。例如,考虑:</target>
        </trans-unit>
        <trans-unit id="8a59c0bcb531b15ec7601a5c46eda41a994dbd08" translate="yes" xml:space="preserve">
          <source>The scheme above allows interpretation of a wide range of dates, particularly if 4-digit years are used.</source>
          <target state="translated">上述方案允许对广泛的日期进行解释,特别是在使用4位数年份时。</target>
        </trans-unit>
        <trans-unit id="3fc0ce48ddfa00a9f249dd98501d09516efb57c0" translate="yes" xml:space="preserve">
          <source>The scheme from the uri (like 'file', 'http', etc)</source>
          <target state="translated">来自uri的方案(如'file'、'http'等)。</target>
        </trans-unit>
        <trans-unit id="49277474cf2c3fa04e4e431396fc13bca0311697" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 的作用域已将 &lt;code&gt;void&lt;/code&gt; warnings类别升级为致命错误，因此程序在遇到警告时会立即终止。</target>
        </trans-unit>
        <trans-unit id="05dbbff48c1e514e522b4520f47f1f9d051aaac1" translate="yes" xml:space="preserve">
          <source>The script first verifies the function of the &lt;code&gt;Name&lt;/code&gt; class.</source>
          <target state="translated">该脚本首先验证 &lt;code&gt;Name&lt;/code&gt; 类的功能。</target>
        </trans-unit>
        <trans-unit id="bab70c074a8060d72a4a917d75cb758f3fdbebe9" translate="yes" xml:space="preserve">
          <source>The script is available from &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt;</source>
          <target state="translated">该脚本可从&lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877获得&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc3001b62b3120b5e625f2291ab08a912ad78b79" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt; ) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="translated">搜索引擎最初会将 &lt;code&gt;\D*&lt;/code&gt; 与&amp;ldquo; ABC&amp;rdquo; 匹配。然后它将尝试将 &lt;code&gt;(?!123)&lt;/code&gt; 与&amp;ldquo; 123&amp;rdquo; 匹配，但失败。但是，由于在正则表达式中使用了一个量词（ &lt;code&gt;\D*&lt;/code&gt; ），因此搜索引擎可以回溯和重试匹配项，从而希望匹配整个正则表达式。</target>
        </trans-unit>
        <trans-unit id="4989338d675235ed7afc62322345e940a111f8d8" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;//p&lt;/code&gt; , which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="translated">第二个优点是嵌入式修饰符（ &lt;code&gt;//p&lt;/code&gt; 除外，它修改了整个正则表达式）仅影响包含修饰符的组中的正则表达式。因此可以使用分组来定位修饰符的效果：</target>
        </trans-unit>
        <trans-unit id="e6b19a99a58715509197b4fd3bb055452f4e6bb8" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt; . The final argument to &lt;code&gt;Newxc&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; , should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="translated">第二个和第三个参数 &lt;code&gt;number&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 指定应分配多少个指定类型的数据结构。参数 &lt;code&gt;type&lt;/code&gt; 传递给 &lt;code&gt;sizeof&lt;/code&gt; 。最后一个参数到 &lt;code&gt;Newxc&lt;/code&gt; ， &lt;code&gt;cast&lt;/code&gt; ，如果使用，应 &lt;code&gt;pointer&lt;/code&gt; 参数是从所述不同 &lt;code&gt;type&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="9372cc26ce11f225b78cb9001dded71987be37ab" translate="yes" xml:space="preserve">
          <source>The second argument ($eol) is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. Every occurrence of &quot;\n&quot; is replaced with this string, and it is also used for additional &quot;soft line breaks&quot; to ensure that no line end up longer than 76 characters. Pass it as &quot;\015\012&quot; to produce data suitable for external consumption. The string &quot;\r\n&quot; produces the same result on many platforms, but not all.</source>
          <target state="translated">第二个参数($eol)是要使用的行尾序列。它是可选的,默认为&quot;\n&quot;。每一次出现&quot;\/n &quot;都会被替换为这个字符串,它也用于额外的 &quot;软换行&quot;,以确保没有一行超过76个字符。将其传递为&quot;\015\012&quot;,以产生适合外部消费的数据。字符串&quot;\r\n &quot;在许多平台上产生相同的结果,但不是所有平台。</target>
        </trans-unit>
        <trans-unit id="691db7e7ba5b2eef57391203c3fd8b3455b42a9c" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">第二个参数可以是带有选项的哈希引用，该选项与传递给 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; 的参数相同。</target>
        </trans-unit>
        <trans-unit id="36e7dec2e6aed1723cd212b39460017f8772c38b" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="translated">第二个参数是一个正则表达式。它可以作为正则表达式参考（即 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ）或（为了更好地与旧的perls兼容）作为看起来像正则表达式的字符串给出（当前不支持替代定界符）：</target>
        </trans-unit>
        <trans-unit id="e9cd8da657568e7bbba17b34028b2178bd5abb57" translate="yes" xml:space="preserve">
          <source>The second argument is considered a regex if it is either a regex object or a string that looks like a regex. Regex objects are constructed with the qr// operator in recent versions of perl. A string is considered to look like a regex if its first and last characters are &quot;/&quot;, or if the first character is &quot;m&quot; and its second and last characters are both the same non-alphanumeric non-whitespace character. These regexp</source>
          <target state="translated">第二个参数如果是一个regex对象或一个看起来像regex的字符串,则被认为是一个regex。在最近的perl版本中,Regex对象是用qr//运算符构造的。如果一个字符串的第一个和最后一个字符是&quot;/&quot;,或者第一个字符是 &quot;m&quot;,第二个和最后一个字符都是相同的非字母数字非空格字符,那么这个字符串就被认为是一个regex对象。这些regexp</target>
        </trans-unit>
        <trans-unit id="ffe3c605f37afcab4c8601d801b588d13a566637" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in the case of a unary operator.</source>
          <target state="translated">第二个参数是另一个操作数，如果是一元运算符，则为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e99835175d57940dd272e3dc71fc2882ef5b0d66" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can either compress using &lt;code&gt;gzip&lt;/code&gt; or &lt;code&gt;bzip2&lt;/code&gt; . If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="translated">第二个参数用于指示压缩。您可以使用 &lt;code&gt;gzip&lt;/code&gt; 或 &lt;code&gt;bzip2&lt;/code&gt; 进行压缩。如果您传递数字，则假定它是 &lt;code&gt;gzip&lt;/code&gt; 压缩级别（介于1和9之间），但最好使用常量：</target>
        </trans-unit>
        <trans-unit id="a0c730e612ef3dd802df3a15f52c50f234217ccd" translate="yes" xml:space="preserve">
          <source>The second argument may be considered optional, but remains for backwards compatibility. Archive::Tar now looks at the file magic to determine what class should be used to open the file and will transparently Do The Right Thing.</source>
          <target state="translated">第二个参数可能被认为是可选的,但为了向后的兼容性而保留。Archive::Tar 现在会根据文件的魔力来决定应该用什么类来打开文件,并且会透明地做正确的事情。</target>
        </trans-unit>
        <trans-unit id="fc50752077e3b12e3cd10f78b06bb8c9b8f956b4" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt; 's. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="translated">第二个参数指向包含 &lt;code&gt;num&lt;/code&gt; &lt;code&gt;SV*&lt;/code&gt; 的数组。创建AV后，可以根据需要销毁SV。</target>
        </trans-unit>
        <trans-unit id="241df4a30fc4febc2cd9ef098abdb1cdbc871750" translate="yes" xml:space="preserve">
          <source>The second call to hex() will warn about a non-portable constant.</source>
          <target state="translated">第二个对hex()的调用将对一个非可移植常量发出警告。</target>
        </trans-unit>
        <trans-unit id="52f5fb6e434df4bf3ba2648b67634f2b93cdc1b5" translate="yes" xml:space="preserve">
          <source>The second call-back is optional if the call back is registered prior to the call to $term-&amp;gt;readline.</source>
          <target state="translated">如果在调用$ term-&amp;gt; readline之前注册了回调，则第二个回调是可选的。</target>
        </trans-unit>
        <trans-unit id="104d457b0581ca75e5a33a6cc382aa3d75495d54" translate="yes" xml:space="preserve">
          <source>The second call-back registered is the call back for registration. The input filehandle (often STDIN, but not necessarily) will be passed in.</source>
          <target state="translated">注册的第二个回调是注册的回调。输入的文件柄(通常是STDIN,但不一定)将被传递进来。</target>
        </trans-unit>
        <trans-unit id="0d9c1d1eb4a7fe50e319b8d6cb4e544cda2638c9" translate="yes" xml:space="preserve">
          <source>The second column is the return type, the third column the name. Columns after that are the arguments. The first column is a set of flags:</source>
          <target state="translated">第二列是返回类型,第三列是名称。之后的列是参数。第一列是一组标志。</target>
        </trans-unit>
        <trans-unit id="833ac465c5bc76260e3533a8f5293c1a6cc4e353" translate="yes" xml:space="preserve">
          <source>The second example in the synopsis does something equivalent to this:</source>
          <target state="translated">概要中的第二个例子做的事情与此相当。</target>
        </trans-unit>
        <trans-unit id="f7f8f6797190b2ee94971db1ba0f6aeb4ac8dc06" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt; , and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt; , or are shorter than 5 chars.</source>
          <target state="translated">第二个示例打印名称为 &lt;code&gt;foo&lt;/code&gt; 的条目，以及名称结尾为 &lt;code&gt;bar&lt;/code&gt; 或少于5个字符的条目。</target>
        </trans-unit>
        <trans-unit id="6b7ec951497cf0073403b17626a675e036c31257" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt; .</source>
          <target state="translated">如果留在输入缓冲区中的所有数据的第二出口点的测试， &lt;code&gt;$input&lt;/code&gt; -记得 &lt;code&gt;ConsumeInput&lt;/code&gt; 选项时，将自动启用 &lt;code&gt;LimitOutput&lt;/code&gt; 使用。输入缓冲区用完后，外部循环可以再次运行并覆盖现在为空的 &lt;code&gt;$input&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dba4d9ed358b9b1b26a10b82c95880d18ef1ec5" translate="yes" xml:space="preserve">
          <source>The second form allows the filter to hold state information using a closure, thus:</source>
          <target state="translated">第二种形式允许过滤器使用闭合来保存状态信息,因此。</target>
        </trans-unit>
        <trans-unit id="204d9fcc358796976a40cb62f3873844790ea690" translate="yes" xml:space="preserve">
          <source>The second form is strongly discouraged, because it breaks the ability of a subclass to reuse the parent's constructor, but you may still run across it in existing code.</source>
          <target state="translated">第二种形式是不被鼓励的,因为它破坏了子类重用父类构造函数的能力,但你仍然可能在现有的代码中遇到它。</target>
        </trans-unit>
        <trans-unit id="0819d819ae212b8e1bcdb9b5bc6d671458a8958e" translate="yes" xml:space="preserve">
          <source>The second form limits or expands the output with shell globbing as in the following examples:</source>
          <target state="translated">第二种形式通过shell globbing限制或扩展输出,如下面的例子。</target>
        </trans-unit>
        <trans-unit id="c407c89499b72c27a5a072472ddedf2b307bb4f0" translate="yes" xml:space="preserve">
          <source>The second form takes an ASCII string of &quot;0&quot; and &quot;1&quot; characters as its argument. It's equivalent to</source>
          <target state="translated">第二种形式以 &quot;0 &quot;和 &quot;1 &quot;字符的ASCII字符串作为参数。它相当于</target>
        </trans-unit>
        <trans-unit id="653b770c920437547bfd253af4e36f98e0dbfce5" translate="yes" xml:space="preserve">
          <source>The second form, for convenience, simply calls the &lt;code&gt;new&lt;/code&gt; method on its arguments before dumping the object immediately.</source>
          <target state="translated">为了方便起见，第二种形式只是在立即转储对象之前对其参数调用 &lt;code&gt;new&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="dc711c3d286876153bcbf61db541b42c9a9350fc" translate="yes" xml:space="preserve">
          <source>The second gives data on how many keys are at each depth in the chain, and gives an idea of how much work a fetch *hit* will take. The performance for an update or delete of an item in the hash is equivalent to this case.</source>
          <target state="translated">第二个给出了链中每个深度有多少个键的数据,并给出了一个取*命中需要多少工作的概念。在哈希中更新或删除一个项目的性能相当于这种情况。</target>
        </trans-unit>
        <trans-unit id="5995436678b8ce31e572994a72a1c15e94c7f93e" translate="yes" xml:space="preserve">
          <source>The second is</source>
          <target state="translated">二是</target>
        </trans-unit>
        <trans-unit id="3d4dc00d964c0b0076b393752a2dfc8106f40760" translate="yes" xml:space="preserve">
          <source>The second is a question mark &lt;code&gt;?&lt;/code&gt; to match any single character. The third specifies a specific set of characters.</source>
          <target state="translated">第二个是问号 &lt;code&gt;?&lt;/code&gt; 匹配任何单个字符。第三个指定一组特定的字符。</target>
        </trans-unit>
        <trans-unit id="86badbc4e990f49a4a0e0309ce3e34af3acb8215" translate="yes" xml:space="preserve">
          <source>The second is, in short, more readable. In particular, it's obvious that the number of parameters you're feeding to that phrase (two) is the number of parameters that it</source>
          <target state="translated">第二种,简而言之,更有可读性。特别是,很明显,你给那个短语输入的参数数(两个)就是它的参数数。</target>
        </trans-unit>
        <trans-unit id="7d7dcadbcc9256c73e53e45ca4167a8f00171936" translate="yes" xml:space="preserve">
          <source>The second method both creates the AV and initially populates it with SVs:</source>
          <target state="translated">第二种方法既创建了AV,又初步填充了SV。</target>
        </trans-unit>
        <trans-unit id="5a04571edd1042cba183eaac5eb081daffd5163c" translate="yes" xml:space="preserve">
          <source>The second method divides up the generated code into</source>
          <target state="translated">第二种方法是将生成的代码划分为</target>
        </trans-unit>
        <trans-unit id="30b5717864fa144252bae28ce0e68e9e2886c509" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; , which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="translated">第二个新的显示参数是 &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; ，可以将其设置为true或false，默认值为true。请参阅上一节了解这意味着什么。</target>
        </trans-unit>
        <trans-unit id="105094491ac9a931737afcae5ec00cc67ecea83f" translate="yes" xml:space="preserve">
          <source>The second option is to explicitly instruct Configure to detect the newer Berkeley DB installation, by supplying the right directories with &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; and &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt;&lt;b&gt;and&lt;/b&gt; before running &quot;make test&quot; setting your LD_LIBRARY_PATH to</source>
          <target state="translated">第二个选项是通过向正确的目录提供 &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; 和 &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt; &lt;b&gt;并&lt;/b&gt;在运行&amp;ldquo; make test&amp;rdquo;之前将LD_LIBRARY_PATH设置为，以明确指示Configure来检测更新的Berkeley DB安装。</target>
        </trans-unit>
        <trans-unit id="b104d0289f2a63192d73ded4515b99bcffef5da9" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt; , is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt; , so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="translated">第二个参数 &lt;code&gt;$mode&lt;/code&gt; 用于指定是打开文件进行读取还是写入，并在写入时选择指定压缩级别和压缩策略。 &lt;code&gt;$mode&lt;/code&gt; 参数的格式类似于'C'函数 &lt;code&gt;fopen&lt;/code&gt; 的mode参数，因此&amp;ldquo; rb&amp;rdquo;用于打开以供读取，&amp;ldquo; wb&amp;rdquo;用于写入，而&amp;ldquo; ab&amp;rdquo;用于附加（在末尾写入）文件）。</target>
        </trans-unit>
        <trans-unit id="9eae2bfeb40a7aaf7114e7fd8256ee81caccdbd3" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;^&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;$&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="translated">第二个正则表达式不匹配，因为 &lt;code&gt;^&lt;/code&gt; 限制了 &lt;code&gt;keeper&lt;/code&gt; 只能在字符串的开头进行匹配，但是 &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; keeper在中间开始。第三个正则表达式确实匹配，因为 &lt;code&gt;$&lt;/code&gt; 约束 &lt;code&gt;keeper&lt;/code&gt; 仅在字符串的末尾匹配。</target>
        </trans-unit>
        <trans-unit id="733da91fc44d8ab5e75ced78a6cc48a582c7d7b0" translate="yes" xml:space="preserve">
          <source>The second returned item and &lt;code&gt;$!&lt;/code&gt; can be used to check for valid input:</source>
          <target state="translated">第二个返回的项目和 &lt;code&gt;$!&lt;/code&gt; 可用于检查有效输入：</target>
        </trans-unit>
        <trans-unit id="2c1496bf9c5a01143ce96b1f9c010fe32e40f772" translate="yes" xml:space="preserve">
          <source>The second sentence is wrong. In actual fact bval will only default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when the openinfo parameter in dbopen is NULL. If a non-NULL openinfo parameter is used at all, the value that happens to be in bval will be used. That means you always have to specify bval when making use of any of the options in the openinfo parameter. This documentation error will be fixed in the next release of Berkeley DB.</source>
          <target state="translated">第二句话是错误的。实际上，只有当dbopen中的openinfo参数为NULL时，bval 才会默认为 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。如果完全使用了非NULL的openinfo参数，则将使用恰好在bval中的值。这意味着在使用openinfo参数中的任何选项时，您始终必须指定bval。此文档错误将在下一版Berkeley DB中修复。</target>
        </trans-unit>
        <trans-unit id="aaad1f57fe700f2a9b2dd58ec708684feaf8128f" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a lexical subroutine that has gone out of scope, for example,</source>
          <target state="translated">第二种情况是由eval访问一个已经超出范围的词汇子程序造成的,例如。</target>
        </trans-unit>
        <trans-unit id="9ade278ee614d31e9547b1781d35dc6ff90a8980" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a variable that has gone out of scope, for example,</source>
          <target state="translated">第二种情况是由eval访问一个已经超出范围的变量引起的,例如。</target>
        </trans-unit>
        <trans-unit id="b47d8c8a23f4e0d763e99999d69c0c5eb0cb3a92" translate="yes" xml:space="preserve">
          <source>The second style of bundling lifts this restriction. It can be enabled with:</source>
          <target state="translated">第二种捆绑方式解除了这一限制。它可以通过以下方式启用:</target>
        </trans-unit>
        <trans-unit id="ab8073e684e0f88cfe3fd5f9716b9c696bbef27e" translate="yes" xml:space="preserve">
          <source>The second value to be substituted in the output string (usually the row in cursor addressing capabilities)</source>
          <target state="translated">在输出字符串中替换的第二个值(通常是游标寻址能力中的行)。</target>
        </trans-unit>
        <trans-unit id="72ec171fc6e9d8dd4e1917d8ba0d47a2f390d23d" translate="yes" xml:space="preserve">
          <source>The second, more efficient way is to use the following template for your Foo.xs:</source>
          <target state="translated">第二种更有效的方法是为你的Foo.xs使用以下模板。</target>
        </trans-unit>
        <trans-unit id="ea8fa202ee5b9df3dfb7272625ecae21681f7d7d" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="translated">该部分（旧版本中又称为&amp;ldquo;项目&amp;rdquo;），如果没有则为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。例如，在&amp;ldquo; L &amp;lt;Getopt :: Std / DESCRIPTION&amp;gt;&amp;rdquo;中，&amp;ldquo; DESCRIPTION&amp;rdquo;是该部分。 （请注意，这与联机帮助页部分不同，如&amp;ldquo; man 5 crontab&amp;rdquo;中的&amp;ldquo; 5&amp;rdquo;。Pod意义上的&amp;ldquo; Section Foo&amp;rdquo;是指标题或项目所引入的文本部分，其文字为&amp;ldquo; Foo&amp;rdquo; &amp;ldquo;。）</target>
        </trans-unit>
        <trans-unit id="8d5faf936bbea0ef6b4af3b53c6607ced9b3cdea" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt; for more information.</source>
          <target state="translated">强调临时文件创建的安全性，以便将文件句柄和文件名一起返回。这有助于确保在检查文件存在与打开之间通过另一个过程创建临时文件的情况下不会发生竞争状况。提供了附加的安全级别，例如，检查是否在世界可写目录上设置了粘性位。有关更多信息，请参见&lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02ef1170c6c4276366f2c9602e48f300db3d9145" translate="yes" xml:space="preserve">
          <source>The seemingly equivalent construct in Perl, &lt;code&gt;$$aref[$i]&lt;/code&gt; first does the deref of $aref, making it take $aref as a reference to an array, and then dereference that, and finally tell you the</source>
          <target state="translated">在Perl中看似等效的构造函数 &lt;code&gt;$$aref[$i]&lt;/code&gt; 首先对$ aref进行解引用，使它以$ aref作为对数组的引用，然后对其进行解引用，最后告诉您</target>
        </trans-unit>
        <trans-unit id="5d3a7adddb69f2204deb61bd662439aeebd384d4" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;code&gt;setitimer()&lt;/code&gt; documentation.</source>
          <target state="translated">多线程程序的间隔计时器的语义是特定于系统的，某些系统可能支持其他间隔计时器。例如，未指定哪个线程获取信号。请参阅您的 &lt;code&gt;setitimer()&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="65ef3e0624e679879b7ce02cec7d6809073f165d" translate="yes" xml:space="preserve">
          <source>The sense of the match can be reversed by using &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">可以使用 &lt;code&gt;!~&lt;/code&gt; 运算符反转匹配的含义：</target>
        </trans-unit>
        <trans-unit id="571f2b8a003669439aca5df927f2bc3b59493e17" translate="yes" xml:space="preserve">
          <source>The sequence &lt;code&gt;\b&lt;/code&gt; is special inside a bracketed character class. While outside the character class, &lt;code&gt;\b&lt;/code&gt; is an assertion indicating a point that does not have either two word characters or two non-word characters on either side, inside a bracketed character class, &lt;code&gt;\b&lt;/code&gt; matches a backspace character.</source>
          <target state="translated">序列 &lt;code&gt;\b&lt;/code&gt; 在带括号的字符类中是特殊的。在字符类之外， &lt;code&gt;\b&lt;/code&gt; 是一个断言，指示在括号字符类内，点的任一侧都没有两个单词字符或两个非单词字符的点， &lt;code&gt;\b&lt;/code&gt; 匹配一个退格字符。</target>
        </trans-unit>
        <trans-unit id="6b263532d25e62f98e230387976bd3e1a8c5cb59" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP's next OP.</source>
          <target state="translated">OP的下一个OP的序列号。</target>
        </trans-unit>
        <trans-unit id="b45bacc53a5ed1f0afceaa4ff3006834edab117c" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP, or a hyphen if it doesn't have one.</source>
          <target state="translated">上位机的序列号,如果没有序列号,则为连字符。</target>
        </trans-unit>
        <trans-unit id="4f0a83d5889e74bacf92e475321b6ad01721beb5" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP. Note that this is a sequence number generated by B::Concise.</source>
          <target state="translated">OP的序列号。注意,这是一个由 B::Concise 生成的序列号。</target>
        </trans-unit>
        <trans-unit id="c10dc949f49eb3d32cdb0534e93e9f1fddb641e8" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="translated">&lt;code&gt;\a&lt;/code&gt; ， &lt;code&gt;\c&lt;/code&gt; ， &lt;code&gt;\e&lt;/code&gt; ， &lt;code&gt;\f&lt;/code&gt; ， &lt;code&gt;\n&lt;/code&gt; ， &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; ， &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; ， &lt;code&gt;\r&lt;/code&gt; ， &lt;code&gt;\t&lt;/code&gt; 和 &lt;code&gt;\x&lt;/code&gt; 序列也很特殊，它们的含义相同在方括号类之外做。</target>
        </trans-unit>
        <trans-unit id="0d53186f69243fe4e7fc81db07bccfc51f977e9e" translate="yes" xml:space="preserve">
          <source>The serializing hook, called on the object during serialization. It can be inherited, or defined in the class itself, like any other method.</source>
          <target state="translated">序列化钩子,在序列化过程中对对象进行调用。它可以被继承,也可以像其他方法一样在类本身中定义。</target>
        </trans-unit>
        <trans-unit id="4e9ebcecc7a860f145ea8f9108514a4fa8316dfb" translate="yes" xml:space="preserve">
          <source>The service name supplied to getaddrinfo() is not available for the socket type given in the $hints.</source>
          <target state="translated">提供给getaddrinfo()的服务名对于$hints中给出的socket类型是不可用的。</target>
        </trans-unit>
        <trans-unit id="ba23ccf9d34101355ab34a3727e24a0a0f7b250a" translate="yes" xml:space="preserve">
          <source>The services a piece of code promises to provide forever, in contrast to its &lt;b&gt;implementation&lt;/b&gt;, which it should feel free to change whenever it likes.</source>
          <target state="translated">与它的&lt;b&gt;实现&lt;/b&gt;相反，一段代码承诺可以永远提供这些服务，并且可以随时随意更改。</target>
        </trans-unit>
        <trans-unit id="32c78a4d560dbf4474d5f3b5cef5e0e631bdf4c5" translate="yes" xml:space="preserve">
          <source>The set is specified as a list of characters, or as a range of characters where the beginning and end of the range are separated by a minus (or dash) character, or as any combination of lists and ranges. The dash can also be included in the set as a character it if is the beginning or end of the set. This set is enclosed in square brackets. The close square bracket &lt;code&gt;]&lt;/code&gt; may be used in a set if it is the first character in the set.</source>
          <target state="translated">该集合被指定为一个字符列表，或一个字符范围，其中范围的开始和结尾用减号（或破折号）分隔，或者指定为列表和范围的任何组合。破折号也可以作为字符包含在集合中，如果它是集合的开始或结尾。这套放在方括号中。紧密括号 &lt;code&gt;]&lt;/code&gt; 可以在一组中使用，如果它是该组中的第一个字符。</target>
        </trans-unit>
        <trans-unit id="271c11282a628a982454242ec29109ed2ea23f1d" translate="yes" xml:space="preserve">
          <source>The set of characters that are deemed whitespace are those that Unicode calls &quot;Pattern White Space&quot;, namely:</source>
          <target state="translated">被认为是空白的一组字符是Unicode称为 &quot;模式白色空间 &quot;的字符,即:</target>
        </trans-unit>
        <trans-unit id="5e7d4549f7a90817f3e92cc9271f629864ca580a" translate="yes" xml:space="preserve">
          <source>The setlocale function</source>
          <target state="translated">setlocale函数</target>
        </trans-unit>
        <trans-unit id="6cd53441a7a72535c4ff8e055f31a3a3fc042379" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="translated">子例程属性的设置在编译时发生。 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明中的变量属性也将在编译时应用。但是， &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 变量会在运行时应用其属性。这意味着您必须</target>
        </trans-unit>
        <trans-unit id="ab1edc3ed4db36281da6290a4a02b6bb1d2f2a9a" translate="yes" xml:space="preserve">
          <source>The seven routines are:</source>
          <target state="translated">这七项常规是:</target>
        </trans-unit>
        <trans-unit id="7db711982141cfb12b9e3602192ccba86ac4d921" translate="yes" xml:space="preserve">
          <source>The sheet</source>
          <target state="translated">该表</target>
        </trans-unit>
        <trans-unit id="67100f7fba2fe91ac3115331e86988966a0f9ad9" translate="yes" xml:space="preserve">
          <source>The shell offers to run in</source>
          <target state="translated">外壳提供运行在</target>
        </trans-unit>
        <trans-unit id="d2a4c575dba49342e824220d900f0c783780f4b9" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="translated">Shell的 &lt;code&gt;test&lt;/code&gt; 使用&amp;ldquo; =&amp;rdquo;，&amp;ldquo;！=&amp;rdquo;，&amp;ldquo; &amp;lt;&amp;rdquo;等进行字符串比较，并使用&amp;ldquo; -eq&amp;rdquo;，&amp;ldquo;-ne&amp;rdquo;，&amp;ldquo;-lt&amp;rdquo;等进行数字比较。这与Perl相反，后者使用 &lt;code&gt;eq&lt;/code&gt; ， &lt;code&gt;ne&lt;/code&gt; ， &lt;code&gt;lt&lt;/code&gt; 进行字符串比较，并使用 &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; 等进行数字比较。</target>
        </trans-unit>
        <trans-unit id="fe36cec28443e99377776c6efc56682531e56f06" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; ) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="translated">简短的答案是，默认情况下，Perl 仅根据字符的代码点比较等效项（ &lt;code&gt;eq&lt;/code&gt; ， &lt;code&gt;ne&lt;/code&gt; ）。在上述情况下，答案为否（因为0x00C1！= 0x0041）。但有时，任何大写字母A都应视为相等，甚至在任何情况下都应视为A。</target>
        </trans-unit>
        <trans-unit id="b57501930c25501b20f82b569d1ea16761a497e6" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; ) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; .</source>
          <target state="translated">简短的答案是，默认情况下，Perl 仅根据字符的代码点比较字符串（ &lt;code&gt;lt&lt;/code&gt; ， &lt;code&gt;le&lt;/code&gt; ， &lt;code&gt;cmp&lt;/code&gt; ， &lt;code&gt;ge&lt;/code&gt; ， &lt;code&gt;gt&lt;/code&gt; ）。在上述情况下，答案是&amp;ldquo;之后&amp;rdquo;，因为 &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ace0e0cec639bb708cb2cf532e982971dd3748da" translate="yes" xml:space="preserve">
          <source>The short name of the general category of</source>
          <target state="translated">的总称。</target>
        </trans-unit>
        <trans-unit id="02c6ec10d109a1b719286e329258adf56d502cef" translate="yes" xml:space="preserve">
          <source>The short story</source>
          <target state="translated">小故事</target>
        </trans-unit>
        <trans-unit id="eb4d2d85d25fb4d71e2225f2e7a3eb6515112128" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="translated">简而言之，您可能应该只在标量或函数上使用定义，而不能在集合（数组和哈希）上使用。有关更多详细信息，请参见Perl 5.004版本或更高版本中的&lt;a href=&quot;functions/defined&quot;&gt;定义&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="be047f864fccecb4801e21c3ca26d33faa969dbf" translate="yes" xml:space="preserve">
          <source>The sign &lt;code&gt;/^[+-]$/&lt;/code&gt; is stored separately. The string 'NaN' is used to represent the result when input arguments are not numbers, as well as the result of dividing by zero.</source>
          <target state="translated">符号 &lt;code&gt;/^[+-]$/&lt;/code&gt; 是分开存储的。字符串'NaN'用于表示输入参数不是数字时的结果以及除以零的结果。</target>
        </trans-unit>
        <trans-unit id="5d535efa9748a7b51984807c3b0e47062fc14e19" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf' and stored separately. You can access it with the sign() method.</source>
          <target state="translated">符号是'+'、'-'、'NaN'、'+inf'或'-inf',并单独存储。你可以用sign()方法访问它。</target>
        </trans-unit>
        <trans-unit id="be8bba598ba0bfbad37b038eb92c99bbb5b687ac" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'.</source>
          <target state="translated">符号是'+'、'-'、'NaN'、'+inf'或'-inf'。</target>
        </trans-unit>
        <trans-unit id="32ee9fc8e75a1189426734a34b70183ae0bf5e08" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'. You can access it with the sign() method.</source>
          <target state="translated">符号是'+'、'-'、'NaN'、'+inf'或'-inf'。你可以通过sign()方法访问它。</target>
        </trans-unit>
        <trans-unit id="d68142e064ec1d6e704c7c13d44f8b02e77345ce" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code. When using a signature, the signature is a parenthesised list that goes immediately after the subroutine name. The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="translated">签名是子程序主体的一部分。通常一个子程序的主体是一个简单的括号内的代码块。当使用签名时,签名是一个紧跟在子程序名称之后的括号列表。签名声明了该代码块范围内的词汇变量。当子程序被调用时,签名会首先控制该子程序。它从传递的参数列表中填充签名变量。如果参数列表不符合签名的要求,那么它将抛出一个异常。当签名处理完成后,控制权就会传递给块。</target>
        </trans-unit>
        <trans-unit id="2444d6c2a6baf7e1580c4abcb9b61735a0532f35" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">每一个字的意义将在本教程的其他部分解释,但现在,只需知道一个元字符可以通过在它前面加上反斜杠来匹配。</target>
        </trans-unit>
        <trans-unit id="d05188639d7fd13d368b039de9eab91f22380450" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt; , matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; . That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="translated">类似命名的属性 &lt;code&gt;\p{Punct}&lt;/code&gt; 匹配ASCII范围内的一个稍有不同的集合，即 &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; 。也就是说，它缺少9个字符 &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; ，这是因为Unicode将POSIX认为是标点的东西分为两类，标点符号和符号。</target>
        </trans-unit>
        <trans-unit id="a851643ae5a58ccc6f3ce68bfdab3a7ef68d1794" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt; , execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="translated">简单的规则是：自动加载非方法时，继承将不起作用。对旧代码的简单修复方法是：在以前依赖于从名为 &lt;code&gt;BaseClass&lt;/code&gt; 的基类继承非方法的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 的任何模块中，在启动过程中执行 &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41d909120b343bfa9af89dc978321448d395292c" translate="yes" xml:space="preserve">
          <source>The simple stdio implementation creates the files</source>
          <target state="translated">简单的stdio实现会创建文件</target>
        </trans-unit>
        <trans-unit id="f2a9e9b7a3c97685eea0b1595b9417bb605f6809" translate="yes" xml:space="preserve">
          <source>The simplest XSUBs consist of 3 parts: a description of the return value, the name of the XSUB routine and the names of its arguments, and a description of types or formats of the arguments.</source>
          <target state="translated">最简单的XSUB包括3个部分:返回值的描述,XSUB例程的名称和参数的名称,以及参数的类型或格式的描述。</target>
        </trans-unit>
        <trans-unit id="5cfe5e43e01ddc5838feef9195e0126bb74ada96" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt; . Thus the integer regexp is</source>
          <target state="translated">最简单的情况是整数。这些由数字序列组成，前面有一个可选的符号。我们可以用 &lt;code&gt;\d+&lt;/code&gt; 表示的数字和符号可以与 &lt;code&gt;[+-]&lt;/code&gt; 匹配。因此，整数regexp为</target>
        </trans-unit>
        <trans-unit id="90f647a57152f0376dead3744742f9e10945d73a" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt; .</source>
          <target state="translated">最简单的方法使用 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 函数。它可以在左侧或右侧填充空格，在左侧填充零，并且不会截断结果。该 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 功能只能用空格右边垫字符串，它会结果截到的最大长度 &lt;code&gt;$pad_len&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc3e208a9819c2ed872df1040ec4eed39730cc50" translate="yes" xml:space="preserve">
          <source>The simplest regex is simply a word, or more generally, a string of characters. A regex consisting of a word matches any string that contains that word:</source>
          <target state="translated">最简单的regex只是一个单词,或者更一般的是一串字符。由一个词组成的regex可以匹配任何包含该词的字符串。</target>
        </trans-unit>
        <trans-unit id="e7349953e0f225a36578668e9ad5be25a2093d5b" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of a word matches any string that contains that word:</source>
          <target state="translated">最简单的regexp就是一个单词,或者更普遍的是一个字符串。由一个词组成的regexp可以匹配任何包含该词的字符串。</target>
        </trans-unit>
        <trans-unit id="f93ecdae42936826d9c1b25b5229a95d439104b0" translate="yes" xml:space="preserve">
          <source>The simplest style of bundling can be enabled with:</source>
          <target state="translated">最简单的捆绑方式可以通过以下方式启用。</target>
        </trans-unit>
        <trans-unit id="7cd479644d912e323fa369ec3403c930944ff04b" translate="yes" xml:space="preserve">
          <source>The simplest two-level data structure to build in Perl is an array of arrays, sometimes casually called a list of lists. It's reasonably easy to understand, and almost everything that applies here will also be applicable later on with the fancier data structures.</source>
          <target state="translated">在Perl中构建的最简单的两级数据结构是一个数组,有时也会被随便称为列表的列表。它相当容易理解,几乎这里适用的所有内容也都适用于后面的更高级的数据结构。</target>
        </trans-unit>
        <trans-unit id="6e9b91e3cec9f10bb3ce35088b75f0be6c8e9b0d" translate="yes" xml:space="preserve">
          <source>The simplest type of op structure is &lt;code&gt;OP&lt;/code&gt; : this has no children. Unary operators, &lt;code&gt;UNOP&lt;/code&gt; s, have one child, and this is pointed to by the &lt;code&gt;op_first&lt;/code&gt; field. Binary operators (&lt;code&gt;BINOP&lt;/code&gt; s) have not only an &lt;code&gt;op_first&lt;/code&gt; field but also an &lt;code&gt;op_last&lt;/code&gt; field. The most complex type of op is a &lt;code&gt;LISTOP&lt;/code&gt; , which has any number of children. In this case, the first child is pointed to by &lt;code&gt;op_first&lt;/code&gt; and the last child by &lt;code&gt;op_last&lt;/code&gt; . The children in between can be found by iteratively following the &lt;code&gt;OpSIBLING&lt;/code&gt; pointer from the first child to the last (but see below).</source>
          <target state="translated">&lt;code&gt;OP&lt;/code&gt; 结构的最简单类型是OP：它没有子代。一元运算符 &lt;code&gt;UNOP&lt;/code&gt; 拥有一个孩子，这由 &lt;code&gt;op_first&lt;/code&gt; 字段指出。二进制运算符（ &lt;code&gt;BINOP&lt;/code&gt; ）不仅具有 &lt;code&gt;op_first&lt;/code&gt; 字段，而且具有 &lt;code&gt;op_last&lt;/code&gt; 字段。 op的最复杂类型是 &lt;code&gt;LISTOP&lt;/code&gt; ，它可以有任意数量的子代。在这种情况下，第一个孩子由 &lt;code&gt;op_first&lt;/code&gt; 指向，最后一个孩子由 &lt;code&gt;op_last&lt;/code&gt; 指向。可以通过从第一个孩子到最后一个孩子反复跟踪 &lt;code&gt;OpSIBLING&lt;/code&gt; 指针来找到中间的孩子（但请参见下文）。</target>
        </trans-unit>
        <trans-unit id="2054b09e7b3505e051c925e118baa9402ac5d4ec" translate="yes" xml:space="preserve">
          <source>The simplest way to do this is:</source>
          <target state="translated">最简单的方法就是。</target>
        </trans-unit>
        <trans-unit id="388dab005124e81f16d269b4ee944aa3b8003908" translate="yes" xml:space="preserve">
          <source>The simplest way to use this library is to import the md5_hex() function (or one of its cousins):</source>
          <target state="translated">使用这个库最简单的方法是导入md5_hex()函数(或它的一个表兄弟)。</target>
        </trans-unit>
        <trans-unit id="5ecd63cfa076538859f9d50a754ce0ea42b734ec" translate="yes" xml:space="preserve">
          <source>The simplest, most straightforward way to create a thread is with &lt;code&gt;create()&lt;/code&gt; :</source>
          <target state="translated">创建线程的最简单，最直接的方法是使用 &lt;code&gt;create()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="142891f6dfc36054413e16ddc5cd0b102274ac48" translate="yes" xml:space="preserve">
          <source>The single parameter &lt;code&gt;cb1&lt;/code&gt; is a pointer to a function, so you must have defined &lt;code&gt;cb1&lt;/code&gt; in your code, say something like this</source>
          <target state="translated">单个参数 &lt;code&gt;cb1&lt;/code&gt; 是指向函数的指针，因此您必须在代码中定义 &lt;code&gt;cb1&lt;/code&gt; ，这样说</target>
        </trans-unit>
        <trans-unit id="c390613e0b451f9ebc65ddd44ea3f2cbf88c23f5" translate="yes" xml:space="preserve">
          <source>The situation in which an &lt;b&gt;expression&lt;/b&gt; is expected by its surroundings (the code calling it) to return a list of values rather than a single value. Functions that want a</source>
          <target state="translated">其中的情形&lt;b&gt;表达&lt;/b&gt;是通过其周围预期（代码调用它）返回值的列表，而不是一个单一的值。需要一个功能</target>
        </trans-unit>
        <trans-unit id="d86701b02acab027c0d49bd429316b14b358d71d" translate="yes" xml:space="preserve">
          <source>The situation in which an &lt;b&gt;expression&lt;/b&gt; is expected by its surroundings (the code calling it) to return a single &lt;b&gt;value&lt;/b&gt; rather than a &lt;b&gt;list&lt;/b&gt; of values. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;list context&lt;/b&gt;. A scalar context sometimes imposes additional constraints on the return value&amp;mdash;see &lt;b&gt;string context&lt;/b&gt; and &lt;b&gt;numeric context&lt;/b&gt;. Sometimes we talk about a &lt;b&gt;Boolean context&lt;/b&gt; inside conditionals, but this imposes no additional constraints, since any scalar value, whether numeric or &lt;b&gt;string&lt;/b&gt;, is already true or false.</source>
          <target state="translated">其中的情形&lt;b&gt;表达&lt;/b&gt;是通过其周围预期（代码调用它）返回单个&lt;b&gt;值&lt;/b&gt;，而不是一个&lt;b&gt;列表&lt;/b&gt;值。另请参阅&lt;b&gt;上下文&lt;/b&gt;和&lt;b&gt;列表上下文&lt;/b&gt;。标量上下文有时会对返回值施加额外的约束-请参见&lt;b&gt;字符串上下文&lt;/b&gt;和&lt;b&gt;数字上下文&lt;/b&gt;。有时我们谈论条件条件中的&lt;b&gt;布尔上下文&lt;/b&gt;，但这没有附加任何约束，因为任何标量值（无论是数字还是&lt;b&gt;字符串&lt;/b&gt;）都已经是true或false。</target>
        </trans-unit>
        <trans-unit id="5bf519df1d56695e3fe7b5f2cac71014a6a10291" translate="yes" xml:space="preserve">
          <source>The situation in which an expression is expected by its surroundings (the code calling it) to return a &lt;b&gt;string&lt;/b&gt;. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;numeric context&lt;/b&gt;.</source>
          <target state="translated">表达式被周围环境（调用它的代码）期望返回&lt;b&gt;字符串的情况&lt;/b&gt;。另请参阅&lt;b&gt;上下文&lt;/b&gt;和&lt;b&gt;数字上下文&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d5278b812a3307d0ee6951ce2678ae1eab81add9" translate="yes" xml:space="preserve">
          <source>The situation in which an expression is expected by its surroundings (the code calling it) to return a number. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;string context&lt;/b&gt;.</source>
          <target state="translated">表达式被其周围环境（调用它的代码）期望返回数字的情况。另请参见&lt;b&gt;context&lt;/b&gt;和&lt;b&gt;string context&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="1778a01cc57bbb1bfba8f72e778c79445c3a36bf" translate="yes" xml:space="preserve">
          <source>The situation is even less clear for tools such as MakeMaker that can be used to install additional modules into non-standard places. For example, if a user intends to install a module into a private directory (perhaps by setting &lt;code&gt;PREFIX&lt;/code&gt; on the</source>
          <target state="translated">对于诸如MakeMaker之类的可用于将其他模块安装到非标准位置的工具而言，情况甚至还不清楚。例如，如果用户打算通过设置安装模块为一体的民营目录（也许 &lt;code&gt;PREFIX&lt;/code&gt; 上</target>
        </trans-unit>
        <trans-unit id="9a9c38132104cf7801e22419b38670f4a24614fb" translate="yes" xml:space="preserve">
          <source>The situation where this is necessary, is presumably quite rare.</source>
          <target state="translated">必须这样做的情况,大概是相当罕见的。</target>
        </trans-unit>
        <trans-unit id="5a9a5af0a6298739507c5ced21852b79711a0a57" translate="yes" xml:space="preserve">
          <source>The situation with matching Unicode properties in regular expressions, the &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs, against these code points is not as clear cut, and how these are handled has changed as we've gained experience.</source>
          <target state="translated">对于这些代码点，在正则表达式 &lt;code&gt;\p{}&lt;/code&gt; 和 &lt;code&gt;\P{}&lt;/code&gt; 构造中具有匹配的Unicode属性的情况并没有那么明确，随着经验的积累，如何处理它们也发生了变化。</target>
        </trans-unit>
        <trans-unit id="88e6088a9ab77ba2f6a1ec54ad364f7fffa87f43" translate="yes" xml:space="preserve">
          <source>The size of the file will be determined, and sent to the server automatically for normal files so that this method need only be called if you are transferring data from a socket, named pipe, or other stream not associated with a normal file.</source>
          <target state="translated">文件的大小将被确定,对于普通文件,将自动发送到服务器,因此,只有当你从一个套接字、命名的管道或其他不与普通文件相关联的流中传输数据时,才需要调用这个方法。</target>
        </trans-unit>
        <trans-unit id="87d9309a72cdac9a52fd9593050f47fe997d18b5" translate="yes" xml:space="preserve">
          <source>The size of the per-instance data structure, e.g.:</source>
          <target state="translated">每个实例数据结构的大小,例如:。</target>
        </trans-unit>
        <trans-unit id="5877446a070972ed92cd79aed206f27b2111d714" translate="yes" xml:space="preserve">
          <source>The size of the pieces you&amp;rsquo;re dealing with, mentally speaking.</source>
          <target state="translated">从心理上讲，您正在处理的作品的大小。</target>
        </trans-unit>
        <trans-unit id="1656b4f2fdda6835a902c9679ea0caaf9c6c13e1" translate="yes" xml:space="preserve">
          <source>The size specifier &lt;code&gt;V&lt;/code&gt; has no effect for Perl code, but is supported for compatibility with XS code. It means &quot;use the standard size for a Perl integer or floating-point number&quot;, which is the default.</source>
          <target state="translated">大小说明符 &lt;code&gt;V&lt;/code&gt; 对Perl代码无效，但受支持以与XS代码兼容。它的意思是&amp;ldquo;对Perl整数或浮点数使用标准大小&amp;rdquo;，这是默认设置。</target>
        </trans-unit>
        <trans-unit id="0b86c8f6fcdbd6b3e5e7fca2359cdc4a25ce8c43" translate="yes" xml:space="preserve">
          <source>The skipped prefix (i.e. the characters before the extracted string). On failure, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">跳过的前缀（即，提取的字符串之前的字符）。失败时，将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cca8448b9d4d7f08ec6d38447f60e1a5ccb09b43" translate="yes" xml:space="preserve">
          <source>The slower but superior fixes are when you may be able to yourself fix the misconfiguration of your own environment variables. The mis(sing)configuration of the whole system's locales usually requires the help of your friendly system administrator.</source>
          <target state="translated">较慢但较好的修复方法是,你可能会自己修复自己的环境变量的错误配置。整个系统的错误配置通常需要你友好的系统管理员的帮助。</target>
        </trans-unit>
        <trans-unit id="0fbe962e06d42462e7c0e18bd04f3db25354c94a" translate="yes" xml:space="preserve">
          <source>The smaller and more localized the change, the better. Similarly, a series of small patches is greatly preferred over a single large patch.</source>
          <target state="translated">变化越小、越局部越好。同样,一系列的小补丁比单一的大补丁要好得多。</target>
        </trans-unit>
        <trans-unit id="f4b9fc3a5444ff6c99460c86f0eae40188849994" translate="yes" xml:space="preserve">
          <source>The smallest individual element of a string. Computers store characters as integers, but Perl lets you operate on them as text. The integer used to represent a particular character is called that character&amp;rsquo;s &lt;b&gt;codepoint&lt;/b&gt;.</source>
          <target state="translated">字符串的最小单个元素。计算机将字符存储为整数，但是Perl允许您将它们作为文本进行操作。用于表示特定字符​​的整数称为该字符的&lt;b&gt;代码点&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="743692cb1b17807cb7e732ecae2c349fdebd6008" translate="yes" xml:space="preserve">
          <source>The smart match stops when it finds a match, so it doesn't have to try every expression.</source>
          <target state="translated">智能匹配在找到匹配项时就会停止,所以它不必尝试每个表达式。</target>
        </trans-unit>
        <trans-unit id="936144db8d649469afd4d348dac4550c6a90cbd0" translate="yes" xml:space="preserve">
          <source>The smartmatch implicitly dereferences any non-blessed hash or array reference, so the &lt;code&gt;&lt;i&gt;HASH&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;&lt;i&gt;ARRAY&lt;/i&gt;&lt;/code&gt; entries apply in those cases. For blessed references, the &lt;code&gt;&lt;i&gt;Object&lt;/i&gt;&lt;/code&gt; entries apply. Smartmatches involving hashes only consider hash keys, never hash values.</source>
          <target state="translated">smartmatch隐式取消引用任何非祝福的哈希或数组引用，因此 &lt;code&gt;&lt;i&gt;HASH&lt;/i&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;i&gt;ARRAY&lt;/i&gt;&lt;/code&gt; 条目在这些情况下适用。对于有祝福的引用，将应用&amp;ldquo; &lt;code&gt;&lt;i&gt;Object&lt;/i&gt;&lt;/code&gt; 条目。涉及哈希的智能匹配仅考虑哈希键，而不考虑哈希值。</target>
        </trans-unit>
        <trans-unit id="d02f6728ba4dcd43d024dc500f10ccfe28692eeb" translate="yes" xml:space="preserve">
          <source>The smartmatch operator is most often used as the implicit operator of a &lt;code&gt;when&lt;/code&gt; clause. See the section on &quot;Switch Statements&quot; in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;.</source>
          <target state="translated">smartmatch运算符最常用作 &lt;code&gt;when&lt;/code&gt; 子句的隐式运算符。请参阅&lt;a href=&quot;perlsyn&quot;&gt;perlsyn中的&lt;/a&gt; &amp;ldquo;切换语句&amp;rdquo; 部分。</target>
        </trans-unit>
        <trans-unit id="538eac64870e76a04cefadec7560ac9099d4a644" translate="yes" xml:space="preserve">
          <source>The socket tests may fail if the network is not configured. You have to make &quot;/hurd/pfinet&quot; the translator for &quot;/servers/socket/2&quot;, giving it the right arguments. Try &quot;/hurd/pfinet --help&quot; for more information.</source>
          <target state="translated">如果网络没有配置好,套接字测试可能会失败,你必须让&quot;/hurd/pfinet &quot;成为&quot;/servers/socket/2 &quot;的翻译器。你必须让&quot;/hurd/pfinet &quot;成为&quot;/servers/socket/2 &quot;的翻译器,给它正确的参数。试试&quot;/hurd/pfinet --help &quot;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="127dbba60bbfba8c121a95d45a5b1267637cec67" translate="yes" xml:space="preserve">
          <source>The socket type (e.g. &lt;code&gt;SOCK_STREAM&lt;/code&gt; )</source>
          <target state="translated">套接字类型（例如 &lt;code&gt;SOCK_STREAM&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="d10c516fba6283faccc420f0f1f0ddca597fd882" translate="yes" xml:space="preserve">
          <source>The sole purpose of this module is to enable colour highlighting from the command line.</source>
          <target state="translated">该模块的唯一目的是在命令行中启用颜色高亮。</target>
        </trans-unit>
        <trans-unit id="165006648b6cdcfa730ff63bd97b9430605a3ca6" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; out of the child directory to a place outside the directory tree to be removed.</source>
          <target state="translated">解决方案是将 &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 从子目录中移到要删除的目录树之外的位置。</target>
        </trans-unit>
        <trans-unit id="8bd1e61d4eb0bbe0f75b3581782eef3e8dfaf4b4" translate="yes" xml:space="preserve">
          <source>The sort of characters we put into words. In Unicode, this is all letters including all ideographs and certain diacritics, letter numbers like Roman numerals, and various combining marks.</source>
          <target state="translated">我们在文字中放入的那种字符。在Unicode中,这是所有的字母,包括所有的表意文字和某些双音字,字母数字如罗马数字,以及各种组合标记。</target>
        </trans-unit>
        <trans-unit id="a1d44ffc9ae032aff54b02af9e8455f31b34d012" translate="yes" xml:space="preserve">
          <source>The sort order will cause differences between results obtained on ASCII platforms versus EBCDIC platforms. What follows are some suggestions on how to deal with these differences.</source>
          <target state="translated">排序顺序会导致在ASCII平台和EBCDIC平台上得到的结果不同。下面是关于如何处理这些差异的一些建议。</target>
        </trans-unit>
        <trans-unit id="89da5c4101906ac148b9121db995bfdaa11ef39f" translate="yes" xml:space="preserve">
          <source>The source buffer can either be a scalar or a scalar reference.</source>
          <target state="translated">源缓冲区可以是一个标量,也可以是一个标量参考。</target>
        </trans-unit>
        <trans-unit id="67687b08f8914b53b7f3846fac38e3b4363d7a5e" translate="yes" xml:space="preserve">
          <source>The source buffer, &lt;code&gt;$source&lt;/code&gt; , can either be a scalar or a scalar reference.</source>
          <target state="translated">源缓冲区 &lt;code&gt;$source&lt;/code&gt; 可以是标量或标量引用。</target>
        </trans-unit>
        <trans-unit id="1b7e9fa2ae5c5f428ffd5cfef77286b08b69792f" translate="yes" xml:space="preserve">
          <source>The source code for an extension usually resides in its own directory. At least three files are generally provided:</source>
          <target state="translated">一个扩展的源代码通常驻扎在自己的目录中。一般至少提供三个文件。</target>
        </trans-unit>
        <trans-unit id="1e4ee98da0c8794c248be818bce3b87507488dbe" translate="yes" xml:space="preserve">
          <source>The source code includes multiple hash algorithms to choose from. While we believe that the default perl hash is robust to attack, we have included the hash function Siphash as a fall-back option. At the time of release of Perl 5.18.0 Siphash is believed to be of cryptographic strength. This is not the default as it is much slower than the default hash.</source>
          <target state="translated">源代码中包含了多种哈希算法可供选择。虽然我们相信默认的perl哈希算法对攻击是稳健的,但我们还是包含了哈希函数Siphash作为后备选项。在Perl 5.18.0发布时,Siphash被认为是具有加密强度的。这不是默认的,因为它比默认的哈希慢得多。</target>
        </trans-unit>
        <trans-unit id="d0caf29be420bbd199849ea512093a83580509aa" translate="yes" xml:space="preserve">
          <source>The source code locations are supported &lt;b&gt;only&lt;/b&gt; if you have the Developer Tools installed. (BFD is &lt;b&gt;not&lt;/b&gt; needed.)</source>
          <target state="translated">&lt;b&gt;仅&lt;/b&gt;当您安装了开发人员工具时，&lt;b&gt;才&lt;/b&gt;支持源代码位置。（BFD是&lt;b&gt;不&lt;/b&gt;需要的。）</target>
        </trans-unit>
        <trans-unit id="edb2a3de91b362ca2b61febe5041a5a32501556d" translate="yes" xml:space="preserve">
          <source>The source code repository for Test::More can be found at</source>
          <target state="translated">Test::More的源代码库可以在以下地址找到</target>
        </trans-unit>
        <trans-unit id="449ffcdb319b9addd8fd6dc6fc9226340b95b72f" translate="yes" xml:space="preserve">
          <source>The source filter distribution includes two modules that simplify this task: &lt;code&gt;Filter::exec&lt;/code&gt; and &lt;code&gt;Filter::sh&lt;/code&gt; . Both allow you to run any external executable. Both use a coprocess to control the flow of data into and out of the external executable. (For details on coprocesses, see Stephens, W.R., &quot;Advanced Programming in the UNIX Environment.&quot; Addison-Wesley, ISBN 0-210-56317-7, pages 441-445.) The difference between them is that &lt;code&gt;Filter::exec&lt;/code&gt; spawns the external command directly, while &lt;code&gt;Filter::sh&lt;/code&gt; spawns a shell to execute the external command. (Unix uses the Bourne shell; NT uses the cmd shell.) Spawning a shell allows you to make use of the shell metacharacters and redirection facilities.</source>
          <target state="translated">源过滤器分发包含两个简化此任务的模块： &lt;code&gt;Filter::exec&lt;/code&gt; 和 &lt;code&gt;Filter::sh&lt;/code&gt; 。两者都允许您运行任何外部可执行文件。两者都使用协同处理来控制数据流入和流出外部可执行文件的过程。 （有关协同处理的详细信息，请参见Stephens，WR，&amp;ldquo; UNIX环境中的高级编程。&amp;rdquo; Addison-Wesley，ISBN 0-210-56317-7，第441-445页。）它们之间的区别在于 &lt;code&gt;Filter::exec&lt;/code&gt; 产生了直接使用外部命令，而 &lt;code&gt;Filter::sh&lt;/code&gt; 生成一个shell来执行外部命令。 （Unix使用Bourne外壳； NT使用cmd外壳。）生成外壳可以使您利用外壳的元字符和重定向功能。</target>
        </trans-unit>
        <trans-unit id="ea0efb50a1d96794619b6be6780ccfe01a3a3f70" translate="yes" xml:space="preserve">
          <source>The source has to be set before you can parse anything. The lowest-level way is to call &lt;code&gt;set_source&lt;/code&gt; :</source>
          <target state="translated">必须先设置源，然后才能解析任何内容。最低级别的方法是调用 &lt;code&gt;set_source&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="30a7a830852a264986b70187999506a317874b7f" translate="yes" xml:space="preserve">
          <source>The source of ISO 3166-1 two-letter codes used by this module.</source>
          <target state="translated">本模块使用的ISO 3166-1双字母代码的来源。</target>
        </trans-unit>
        <trans-unit id="26888526042c45b79818c80cb5da539324a9402b" translate="yes" xml:space="preserve">
          <source>The source of the official ISO 3166-1 three-letter codes and three-digit codes.</source>
          <target state="translated">正式的ISO 3166-1三字母代码和三位数代码的来源。</target>
        </trans-unit>
        <trans-unit id="454a907e32531c807293e3735238b43baf267920" translate="yes" xml:space="preserve">
          <source>The special argument of &lt;code&gt;h h&lt;/code&gt; produces the entire help page, which is quite long.</source>
          <target state="translated">&lt;code&gt;h h&lt;/code&gt; 的特殊参数生成整个帮助页面，该页面很长。</target>
        </trans-unit>
        <trans-unit id="c6f65c11625ca6f6efd4fce69ae54247f9d5fb65" translate="yes" xml:space="preserve">
          <source>The special bookkeeping Perl does to track the flow of external data through your program and disallow their use in system commands.</source>
          <target state="translated">Perl做的特殊记账工作是为了跟踪外部数据在你的程序中的流动,并禁止在系统命令中使用它们。</target>
        </trans-unit>
        <trans-unit id="fbeef28b2f2c3763e9cdd6d44783f63733b4347f" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that a contiguous set of characters can be written as a range. With ranges, the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; . Some examples are</source>
          <target state="translated">特殊字符 &lt;code&gt;'-'&lt;/code&gt; 在字符类中充当范围运算符，因此可以将连续的一组字符写为范围。有了范围，笨拙的 &lt;code&gt;[0123456789]&lt;/code&gt; 和 &lt;code&gt;[abc...xyz]&lt;/code&gt; 成为苗条的 &lt;code&gt;[0-9]&lt;/code&gt; 和 &lt;code&gt;[a-z]&lt;/code&gt; 。一些例子是</target>
        </trans-unit>
        <trans-unit id="3a71b165b4e188832e186d5361505b47059b1afc" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; :</source>
          <target state="translated">特殊字符 &lt;code&gt;'-'&lt;/code&gt; 在字符类中充当范围运算符，因此笨拙的 &lt;code&gt;[0123456789]&lt;/code&gt; 和 &lt;code&gt;[abc...xyz]&lt;/code&gt; 成为苗条的 &lt;code&gt;[0-9]&lt;/code&gt; 和 &lt;code&gt;[a-z]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c1d9d9306fb9aa515c3bd892587a0587d3baf9f6" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;^&lt;/code&gt; in the first position of a character class denotes a</source>
          <target state="translated">字符类第一位置的特殊字符 &lt;code&gt;^&lt;/code&gt; 表示</target>
        </trans-unit>
        <trans-unit id="8afc59f37c7b54c4d8a636841474cf58beb13e84" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;^&lt;/code&gt; in the first position of a character class denotes a &lt;b&gt;negated character class&lt;/b&gt;, which matches any character but those in the brackets. Both &lt;code&gt;[...]&lt;/code&gt; and &lt;code&gt;[^...]&lt;/code&gt; must match a character, or the match fails. Then</source>
          <target state="translated">字符类的第一个位置中的特殊字符 &lt;code&gt;^&lt;/code&gt; 表示&lt;b&gt;否定的字符类&lt;/b&gt;，它与除方括号中的字符以外的任何字符匹配。无论 &lt;code&gt;[...]&lt;/code&gt; 和 &lt;code&gt;[^...]&lt;/code&gt; 必须一个字符匹配，否则匹配失败。然后</target>
        </trans-unit>
        <trans-unit id="94d7fdb99f703e5dc3a7ffcb7bb005616b504881" translate="yes" xml:space="preserve">
          <source>The special filehandle that iterates over command-line filenames in &lt;code&gt;@ARGV&lt;/code&gt; . Usually written as the null filehandle in the angle operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Note that currently &lt;code&gt;ARGV&lt;/code&gt; only has its magical effect within the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator; elsewhere it is just a plain filehandle corresponding to the last file opened by &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . In particular, passing &lt;code&gt;\*ARGV&lt;/code&gt; as a parameter to a function that expects a filehandle may not cause your function to automatically read the contents of all the files in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">遍历 &lt;code&gt;@ARGV&lt;/code&gt; 中的命令行文件名的特殊文件句柄。通常写为角度运算符 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 中的空文件句柄。注意，当前 &lt;code&gt;ARGV&lt;/code&gt; 仅在 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符内具有神奇的作用；在其他地方，它只是一个普通文件句柄，对应于 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 打开的最后一个文件。特别是，将 &lt;code&gt;\*ARGV&lt;/code&gt; 作为参数传递给需要文件句柄的函数，可能不会导致函数自动读取 &lt;code&gt;@ARGV&lt;/code&gt; 中所有文件的内容。</target>
        </trans-unit>
        <trans-unit id="f805e5a7fa6e6a7379f92a69ce80440a9d42a7c7" translate="yes" xml:space="preserve">
          <source>The special filehandle that points to the currently open output file when doing edit-in-place processing with &lt;b&gt;-i&lt;/b&gt;. Useful when you have to do a lot of inserting and don't want to keep modifying &lt;code&gt;$_&lt;/code&gt; . See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the &lt;b&gt;-i&lt;/b&gt; switch.</source>
          <target state="translated">使用&lt;b&gt;-i&lt;/b&gt;进行就地编辑时，指向当前打开的输出文件的特殊文件句柄。当您必须进行大量插入并且不想继续修改 &lt;code&gt;$_&lt;/code&gt; 时很有用。参见&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;对于&lt;b&gt;-i&lt;/b&gt;开关。</target>
        </trans-unit>
        <trans-unit id="25d2e9e8733979d7b1492fbdd9a7cb623d57628f" translate="yes" xml:space="preserve">
          <source>The special literals __FILE__, __LINE__, and __PACKAGE__ represent the current filename, line number, and package name at that point in your program. __SUB__ gives a reference to the current subroutine. They may be used only as separate tokens; they will not be interpolated into strings. If there is no current package (due to an empty &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; directive), __PACKAGE__ is the undefined value. (But the empty &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; is no longer supported, as of version 5.10.) Outside of a subroutine, __SUB__ is the undefined value. __SUB__ is only available in 5.16 or higher, and only with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;current_sub&quot;&lt;/code&gt; declaration.</source>
          <target state="translated">特殊文字__FILE __，__ LINE__和__PACKAGE__表示程序中该点的当前文件名，行号和程序包名称。 __SUB__提供对当前子例程的引用。它们只能用作单独的令牌；它们不会插值到字符串中。如果没有当前包（由于为空 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; 指令），则__PACKAGE__是未定义的值。 （但是从5.10版开始，不再支持空 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; ）在子例程之外，__SUB__是未定义的值。 __SUB__仅在5.16或更高版本中可用，并且仅在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;current_sub&quot;&lt;/code&gt; 声明时可用。</target>
        </trans-unit>
        <trans-unit id="6af0b63b67806c6dfb7b9ddb2d398096248ddab4" translate="yes" xml:space="preserve">
          <source>The special mark that tells the operating system it can run this program. There are actually three execute bits under Unix, and which bit gets used depends on whether you own the file singularly, collectively, or not at all.</source>
          <target state="translated">告诉操作系统可以运行这个程序的特殊标志。在Unix下其实有三个执行位,使用哪个位取决于你是单一拥有、集体拥有还是完全不拥有文件。</target>
        </trans-unit>
        <trans-unit id="6429c59caa249ed4d6719a4eab753f28d6cfd25d" translate="yes" xml:space="preserve">
          <source>The special methods &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::can&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;maybe::next::method&lt;/code&gt; are not available until this &lt;code&gt;mro&lt;/code&gt; module has been loaded via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 加载此 &lt;code&gt;mro&lt;/code&gt; 模块之前， &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::can&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;maybe::next::method&lt;/code&gt; 的特殊方法不可用。</target>
        </trans-unit>
        <trans-unit id="c41f3d15a857df9bc04fff7f6a7434b18442c584" translate="yes" xml:space="preserve">
          <source>The special quoting behavior ignores precedence, and hence may apply to</source>
          <target state="translated">特殊的引用行为忽略了优先性,因此可能适用于</target>
        </trans-unit>
        <trans-unit id="79a2544429fe460799a8292535fcaefc5e4c6c60" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is exempt from &lt;b&gt;-w&lt;/b&gt; complaints about improper numeric conversions.</source>
          <target state="translated">对于特殊的数字转换，&lt;b&gt;-w&lt;/b&gt;投诉可免除特殊字符串 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="026f6dfd3d9c99c5a9bfd6afe8ee0f79daedf36d" translate="yes" xml:space="preserve">
          <source>The special symbol &lt;code&gt;__PACKAGE__&lt;/code&gt; contains the current package, but cannot (easily) be used to construct variable names.</source>
          <target state="translated">特殊符号 &lt;code&gt;__PACKAGE__&lt;/code&gt; 包含当前程序包，但不能（轻松）用于构造变量名。</target>
        </trans-unit>
        <trans-unit id="8f36c55aa844c8a0dac4156e30712cffbcd8a9f0" translate="yes" xml:space="preserve">
          <source>The special two-argument form of Perl's open() function ignores trailing blanks in filenames and infers the mode from certain leading characters (or a trailing &quot;|&quot;). In older versions of Perl this was the only version of open() and so it is prevalent in old code and books.</source>
          <target state="translated">Perl 的 open()函数的特殊的双参数形式忽略了文件名中的尾部空白,并从某些前导字符 (或尾部的 &quot;|&quot;)来推断模式。在旧版本的Perl中,这是open()的唯一版本,因此在旧的代码和书籍中很常见。</target>
        </trans-unit>
        <trans-unit id="161a5a9075bb6b7595615ee16fc183085e48d829" translate="yes" xml:space="preserve">
          <source>The special value 00 will cause Perl to slurp files in paragraph mode. Any value 0400 or above will cause Perl to slurp files whole, but by convention the value 0777 is the one normally used for this purpose.</source>
          <target state="translated">特殊的值 00 将使 Perl 以段落模式吞吐文件。任何 0400 或以上的值都会使 Perl 读取整个文件,但按照惯例,通常用于此目的的值是 0777。</target>
        </trans-unit>
        <trans-unit id="510ff7ba673af9c07da4bdf1546cce9f48d4aa9d" translate="yes" xml:space="preserve">
          <source>The special variable &lt;code&gt;$#array&lt;/code&gt; tells you the index of the last element of an array:</source>
          <target state="translated">特殊变量 &lt;code&gt;$#array&lt;/code&gt; 告诉您数组最后一个元素的索引：</target>
        </trans-unit>
        <trans-unit id="848d9f1e6794b744b742b40d6e30625dbd74dd9d" translate="yes" xml:space="preserve">
          <source>The special variables for formats are a subset of those for filehandles. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for more information about Perl's formats.</source>
          <target state="translated">格式的特殊变量是文件句柄的特殊变量。有关Perl格式的更多信息，请参见&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d50e7fd9df415ed27a91da10839b57126db4d317" translate="yes" xml:space="preserve">
          <source>The special verbosity level 99 requires to also specify the -sections parameter; then these sections are extracted and printed.</source>
          <target state="translated">特殊的verbosity级别99要求同时指定-sections参数,然后提取并打印这些章节。</target>
        </trans-unit>
        <trans-unit id="79d7da7f02ba1ece997a8e1f533d9c05c192eb59" translate="yes" xml:space="preserve">
          <source>The specific task here is to sort the 286,525 lines of this file by Response Code, Query, Browser, Referring Url, and lastly Date. One solution might be to use the following code, which iterates over the files given on the command-line.</source>
          <target state="translated">这里的具体任务是将这个文件的286,525行按响应代码、查询、浏览器、引用Url和最后的日期进行排序。一个解决方案可能是使用下面的代码,它在命令行给出的文件上进行迭代。</target>
        </trans-unit>
        <trans-unit id="61bf1ad08824c740b76048cd4f454fa0d05ebcf4" translate="yes" xml:space="preserve">
          <source>The specification which tar derives from; &lt;code&gt; &lt;a href=&quot;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;&gt;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">tar源自的规范； &lt;code&gt; &lt;a href=&quot;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;&gt;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5249ead0cea582438ce306dee2ff065c9121394e" translate="yes" xml:space="preserve">
          <source>The specified</source>
          <target state="translated">指定的</target>
        </trans-unit>
        <trans-unit id="0bbf6ce071adc9bbc621e13b2eb0c9adb5ed909d" translate="yes" xml:space="preserve">
          <source>The specified filtering subroutine is called every time a &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG&lt;/code&gt; is encountered, and passed all the source code following that call, up to either the next &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; (or whatever terminator you've set) or the end of the source file, whichever occurs first. By default, any &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;
BANG;&lt;/code&gt; call must appear by itself on a separate line, or it is ignored.</source>
          <target state="translated">每次遇到 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG&lt;/code&gt; 时，都会调用指定的过滤子例程，并在该调用之后将所有源代码传递给下一个 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; （或您设置的终止符）或源文件的末尾，以先到者为准。默认情况下，任何 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; 呼叫必须单独出现在单独的行上，否则将被忽略。</target>
        </trans-unit>
        <trans-unit id="c52324d25d30fa15232ecb990b5648a4dcfeb28a" translate="yes" xml:space="preserve">
          <source>The split function</source>
          <target state="translated">拆分功能</target>
        </trans-unit>
        <trans-unit id="ddfcdc05a5251df7fbf9a8a775f1e8025aac3f91" translate="yes" xml:space="preserve">
          <source>The split operator</source>
          <target state="translated">拆分运算符</target>
        </trans-unit>
        <trans-unit id="62b2eb8876cf935a6917a946dbc16da0fe289ddf" translate="yes" xml:space="preserve">
          <source>The square brackets explicitly turn a list value into a scalar value, while parentheses do not. So when a parenthesized list is evaluated in a scalar context, the comma is treated like C's comma operator, which throws away the left argument, which is not what you want. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for more on this.</source>
          <target state="translated">方括号将列表值显式转换为标量值，而括号则不然。因此，当在标量上下文中对带括号的列表求值时，逗号就像C的逗号运算符一样处理，该运算符会丢弃左参数，这不是您想要的。有关更多信息，请参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="daa1d51a4ab5d5dc2b248180c01a452f38c9d08d" translate="yes" xml:space="preserve">
          <source>The square brackets make a reference to a new array with a</source>
          <target state="translated">方括号中是对新数组的引用,方括号中是对新数组的引用。</target>
        </trans-unit>
        <trans-unit id="23fce1430ee4d5e6ff2eda3c170c6c5f5f7f9889" translate="yes" xml:space="preserve">
          <source>The stability of these extensions varies widely. Some have been part of the core language for many years. Others are experimental and may change without warning or be completely removed. Check the documentation on an individual feature to verify its current status.</source>
          <target state="translated">这些扩展的稳定性差异很大。有些已经成为核心语言的一部分多年。其他的则是实验性的,可能会在没有警告的情况下改变或被完全移除。请查看个别功能的文档以确认其当前状态。</target>
        </trans-unit>
        <trans-unit id="1fd7c6e1c540b52e642a959640d5271791317f81" translate="yes" xml:space="preserve">
          <source>The stack arguments are accessible through the &lt;code&gt;ST(n)&lt;/code&gt; macro, which returns the &lt;code&gt;n&lt;/code&gt; 'th stack argument. Argument 0 is the first argument passed in the Perl subroutine call. These arguments are &lt;code&gt;SV*&lt;/code&gt; , and can be used anywhere an &lt;code&gt;SV*&lt;/code&gt; is used.</source>
          <target state="translated">可通过 &lt;code&gt;ST(n)&lt;/code&gt; 宏访问堆栈参数，该宏返回第 &lt;code&gt;n&lt;/code&gt; 个堆栈参数。参数0是Perl子例程调用中传递的第一个参数。这些参数是 &lt;code&gt;SV*&lt;/code&gt; ，可以在使用 &lt;code&gt;SV*&lt;/code&gt; 任何地方使用。</target>
        </trans-unit>
        <trans-unit id="25a0b1ef2ef458b2d3cc833a6246a76631f78cfb" translate="yes" xml:space="preserve">
          <source>The stack size of currently extant threads cannot be changed, therefore, the following results in the above error:</source>
          <target state="translated">不能改变当前已存在线程的堆栈大小,因此,以下导致上述错误。</target>
        </trans-unit>
        <trans-unit id="fc601a28bc12b4ada50e0942554017adba6dc50b" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; modules, along with the &lt;code&gt;bignum&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; , and &lt;code&gt;bigrat&lt;/code&gt; pragmas, provide variable-precision arithmetic and overloaded operators, although they're currently pretty slow. At the cost of some space and considerable speed, they avoid the normal pitfalls associated with limited-precision representations.</source>
          <target state="translated">标准的 &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; 模块，以及 &lt;code&gt;bignum&lt;/code&gt; ， &lt;code&gt;bigint&lt;/code&gt; 和 &lt;code&gt;bigrat&lt;/code&gt; 编译指示，提供了变量精度算术和重载运算符，尽管它们目前非常慢。以一些空间和相当大的速度为代价，它们避免了与有限精度表示相关联的正常陷阱。</target>
        </trans-unit>
        <trans-unit id="ebb34ffe368cd7aab86ce86e94cbaf4a640b2d39" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">标准的 &lt;code&gt;IO::Select&lt;/code&gt; 模块提供了一个用户友好的界面来 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; ，主要是因为它为您完成了所有的位掩码工作。</target>
        </trans-unit>
        <trans-unit id="16315bade45df278e7f616f03ff95a3f0a8f22eb" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">标准的 &lt;code&gt;IO::Select&lt;/code&gt; 模块提供了一个用户友好的界面来 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; ，主要是因为它为您完成了所有的位掩码工作。</target>
        </trans-unit>
        <trans-unit id="7c56d1d9eaa2950435f175be867488228983813f" translate="yes" xml:space="preserve">
          <source>The standard Perl 5 MRO would be (D, B, A, C). The result being that &lt;b&gt;A&lt;/b&gt; appears before &lt;b&gt;C&lt;/b&gt;, even though &lt;b&gt;C&lt;/b&gt; is the subclass of &lt;b&gt;A&lt;/b&gt;. The C3 MRO algorithm however, produces the following order: (D, B, C, A), which does not have this issue.</source>
          <target state="translated">标准的Perl 5 MRO为（D，B，A，C）。结果使得&lt;b&gt;一个&lt;/b&gt;之前出现&lt;b&gt;&amp;Ccedil;&lt;/b&gt;，即使&lt;b&gt;&amp;Ccedil;&lt;/b&gt;是子类&lt;b&gt;甲&lt;/b&gt;。但是，C3 MRO算法产生以下顺序：（D，B，C，A），没有此问题。</target>
        </trans-unit>
        <trans-unit id="65db7a2a2e4a32185cf7e73efd313530e97c3f64" translate="yes" xml:space="preserve">
          <source>The standard Pod::Parser method parse_from_filehandle() takes up to two arguments, the first being the file handle to read POD from and the second being the file handle to write the formatted output to. The first defaults to STDIN if not given, and the second defaults to STDOUT. The method parse_from_file() is almost identical, except that its two arguments are the input and output disk files instead. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for the specific details.</source>
          <target state="translated">标准Pod :: Parser方法parse_from_filehandle（）最多使用两个参数，第一个是从中读取POD的文件句柄，第二个是向其写入格式化输出的文件句柄。如果未指定，则第一个默认为STDIN，第二个默认为STDOUT。方法parse_from_file（）几乎相同，只是方法的两个参数分别是输入和输出磁盘文件。有关详细信息，请参见&lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d459c791ef0819fa116e56f83671629a780f70ae" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_file() takes one argument naming the POD file to read from. By default, the output is sent to &lt;code&gt;STDOUT&lt;/code&gt; , but this can be changed with the output_fh() method.</source>
          <target state="translated">标准Pod :: Simple方法parse_file（）使用一个参数命名要读取的POD文件。默认情况下，输出发送到 &lt;code&gt;STDOUT&lt;/code&gt; ，但是可以使用output_fh（）方法更改它。</target>
        </trans-unit>
        <trans-unit id="b669405b1331755a6517c831be989ebdf0920199" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_from_file() takes up to two arguments, the first being the input file to read POD from and the second being the file to write the formatted output to.</source>
          <target state="translated">标准的Pod::Simple方法parse_from_file()需要两个参数,第一个是要读取POD的输入文件,第二个是要写入格式化输出的文件。</target>
        </trans-unit>
        <trans-unit id="c21871c0e5568494a7fbe46008b5f9b899656bd2" translate="yes" xml:space="preserve">
          <source>The standard Tie::RefHash module provides a convenient workaround to this.</source>
          <target state="translated">标准的Tie::RefHash模块为此提供了一个方便的变通方法。</target>
        </trans-unit>
        <trans-unit id="66cc6332c8e3c57e5b8e7b4ce541f13735f1aa06" translate="yes" xml:space="preserve">
          <source>The standard Unicode properties listed below are documented in &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;; Perl_Decimal_Digit is documented in &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt;. The other Perl extensions are in &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;Other Properties in perlunicode&lt;/a&gt;;</source>
          <target state="translated">下面列出的标准Unicode属性记录在&lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/中&lt;/a&gt;；Perl_Decimal_Digit &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;以Unicode :: UCD&lt;/a&gt;记录在prop_invmap（）中。其他Perl扩展&lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;位于perlunicode&lt;/a&gt;中的Other Properties中；</target>
        </trans-unit>
        <trans-unit id="fdea898e7a6fa5187cc16e508d0249ddcaeda57c" translate="yes" xml:space="preserve">
          <source>The standard release of Perl (the one maintained by the Perl development team) is distributed only in source code form. You can find the latest releases at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;.</source>
          <target state="translated">Perl的标准版本（由Perl开发团队维护的版本）仅以源代码形式分发。您可以在&lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/上&lt;/a&gt;找到最新版本。</target>
        </trans-unit>
        <trans-unit id="026f8e314f5a0595f026a7356cc10536cfc51440" translate="yes" xml:space="preserve">
          <source>The standard sections of a manual page are:</source>
          <target state="translated">手册页的标准部分是:</target>
        </trans-unit>
        <trans-unit id="ebe88b6db5cc5c12b5e1ae182a8ede9bae134d07" translate="yes" xml:space="preserve">
          <source>The standard typemap does not contain PerlIO * before perl 5.7, but it has the three stream variants. Using a PerlIO * directly is not backwards compatible unless you provide your own typemap.</source>
          <target state="translated">perl 5.7之前的标准tyemap不包含PerlIO *,但它有三个流变体。直接使用PerlIO *是不向后兼容的,除非你提供自己的typemap。</target>
        </trans-unit>
        <trans-unit id="a4d40d48d96b939643d17277ad94dfc253906873" translate="yes" xml:space="preserve">
          <source>The standard typemap offers three variants of PerlIO *: &lt;code&gt;InputStream&lt;/code&gt; (T_IN), &lt;code&gt;InOutStream&lt;/code&gt; (T_INOUT) and &lt;code&gt;OutputStream&lt;/code&gt; (T_OUT). A bare &lt;code&gt;PerlIO *&lt;/code&gt; is considered a T_INOUT. If it matters in your code (see below for why it might) #define or typedef one of the specific names and use that as the argument or result type in your XS file.</source>
          <target state="translated">标准的类型映射提供PerlIO *的三种变体： &lt;code&gt;InputStream&lt;/code&gt; （T_IN）， &lt;code&gt;InOutStream&lt;/code&gt; （T_INOUT）和 &lt;code&gt;OutputStream&lt;/code&gt; （T_OUT）。裸露的 &lt;code&gt;PerlIO *&lt;/code&gt; 被视为T_INOUT。如果它在您的代码中很重要（请参阅下文，了解原因）#define或typedef具体名称之一，并将其​​用作XS文件中的参数或结果类型。</target>
        </trans-unit>
        <trans-unit id="3718e2c8d6baf1715fb8924869dc7062354846f5" translate="yes" xml:space="preserve">
          <source>The standard/default list of directories in which dl_findfile() will search for libraries etc. Directories are searched in order: $dl_library_path[0], [1], ... etc</source>
          <target state="translated">标准/默认的目录列表,dl_findfile()将在其中搜索库等。按顺序搜索。$dl_library_path[0],[1],...等。</target>
        </trans-unit>
        <trans-unit id="81b82092af810ac11d0e71f19aeda4997801a33d" translate="yes" xml:space="preserve">
          <source>The stash associated with a typed lexical. This returns the %Foo:: hash for &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; .</source>
          <target state="translated">与键入的词法关联的隐藏。这将为 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; 返回％Foo ::哈希。</target>
        </trans-unit>
        <trans-unit id="cc4f30ab95381b1c15dfe4d97fa8f832c168bf1d" translate="yes" xml:space="preserve">
          <source>The stash in which this &quot;our&quot; variable was declared.</source>
          <target state="translated">声明这个 &quot;我们的 &quot;变量的储藏室。</target>
        </trans-unit>
        <trans-unit id="136e96ab03183ea4c3a7028af3545e7d9d5bc253" translate="yes" xml:space="preserve">
          <source>The stat() mode bits are probably right for most of the files and directories found on your system, because few people want to use the additional features offered by access(). But you may encounter surprises if your program runs on a system that uses ACLs, since the stat() information won't reflect the actual permissions.</source>
          <target state="translated">stat()模式位可能对你系统中的大多数文件和目录都是正确的,因为很少有人想使用access()提供的附加功能。但是如果你的程序运行在一个使用ACLs的系统上,你可能会遇到一些意外,因为 stat()的信息不会反映实际的权限。</target>
        </trans-unit>
        <trans-unit id="e8e71255cf8fb3fde9520415463a7e71c11cd3c9" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; doesn't change the current position, but it does clear the end-of-file condition on the handle, so that the next &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; makes Perl try again to read something.</source>
          <target state="translated">语句 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; 不会更改当前位置，但是它确实清除了句柄上的文件结束条件，因此下一个 &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; 使Perl再次尝试读取某些内容。</target>
        </trans-unit>
        <trans-unit id="707171be35bdd3b79efa241046dd3631507040a6" translate="yes" xml:space="preserve">
          <source>The status 2 indicates that at least one of the specified files does not contain</source>
          <target state="translated">状态2表示指定的文件中至少有一个不含</target>
        </trans-unit>
        <trans-unit id="9251e77389b34b5c344d864eb779d11058b888c5" translate="yes" xml:space="preserve">
          <source>The status code returned from &lt;code&gt;inflate&lt;/code&gt; will only trigger termination of the main processing loop if it isn't &lt;code&gt;Z_OK&lt;/code&gt; . When &lt;code&gt;LimitOutput&lt;/code&gt; has not been used the &lt;code&gt;Z_OK&lt;/code&gt; status means that the end of the compressed data stream has been reached or there has been an error in uncompression.</source>
          <target state="translated">从返回的状态代码 &lt;code&gt;inflate&lt;/code&gt; 只会触发主处理循环的终止，如果它不是 &lt;code&gt;Z_OK&lt;/code&gt; 。当 &lt;code&gt;LimitOutput&lt;/code&gt; 尚未使用的 &lt;code&gt;Z_OK&lt;/code&gt; 状态表示所述压缩数据流的结尾已经到达或有在解压缩了一个错误。</target>
        </trans-unit>
        <trans-unit id="2298239a448f47305c5dbab535dd02c58c7526e3" translate="yes" xml:space="preserve">
          <source>The status of the hushed flag also affects output of VMS error messages from compilation errors. Again, you still get the Perl error message (and the code in $STATUS)</source>
          <target state="translated">hushed标志的状态也会影响编译错误时VMS错误信息的输出。同样,你仍然会得到Perl错误信息(以及$STATUS中的代码)。</target>
        </trans-unit>
        <trans-unit id="4cb40ccf1b5efc1b553ba9f11bd2e4b83ffc7264" translate="yes" xml:space="preserve">
          <source>The status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. This is just the 16-bit status word returned by the traditional Unix &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; system call (or else is made up to look like it). Thus, the exit value of the subprocess is really (&lt;code&gt;$?&amp;gt;&amp;gt;
8&lt;/code&gt; ), and &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; gives which signal, if any, the process died from, and &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; reports whether there was a core dump.</source>
          <target state="translated">通过最后的管道关闭返回的状态，反引号（ &lt;code&gt;``&lt;/code&gt; ）命令，成功调用 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 的或 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; 或从 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 操作。这仅仅是传统的Unix &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 系统调用返回的16位状态字（或者看起来像这样）。因此，子流程的退出值实际上是（ &lt;code&gt;$?&amp;gt;&amp;gt; 8&lt;/code&gt; ），而 &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; 给出该进程终止于哪个信号（如果有），以及 &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; 报告是否存在核心转储。</target>
        </trans-unit>
        <trans-unit id="6450e7782a48b71f2dca0230b4493dd10ff37ce5" translate="yes" xml:space="preserve">
          <source>The status value that is returned by the user's &lt;code&gt;filter&lt;/code&gt; method or anonymous sub and the &lt;code&gt;filter_read&lt;/code&gt; and &lt;code&gt;read_exact&lt;/code&gt; functions take the same set of values, namely:</source>
          <target state="translated">用户的 &lt;code&gt;filter&lt;/code&gt; 方法或匿名子返回的状态值以及 &lt;code&gt;filter_read&lt;/code&gt; 和 &lt;code&gt;read_exact&lt;/code&gt; 函数采用相同的一组值，即：</target>
        </trans-unit>
        <trans-unit id="3b8220a76d45ce112350b70ee4dbd73fc8b8bc74" translate="yes" xml:space="preserve">
          <source>The stdio(3C) manpage notes that for LP32 applications, only 255 files may be opened using fopen(), and only file descriptors 0 through 255 can be used in a stream. Since perl calls open() and then fdopen(3C) with the resulting file descriptor, perl is limited to 255 simultaneous open files, even if sysopen() is used. If this proves to be an insurmountable problem, you can compile perl as a LP64 application, see &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;Building an LP64 perl&lt;/a&gt; for details. Note also that the default resource limit for open file descriptors on Solaris is 255, so you will have to modify your ulimit or rctl (Solaris 9 onwards) appropriately.</source>
          <target state="translated">stdio（3C）联机帮助页指出，对于LP32应用程序，使用fopen（）只能打开255个文件，并且流中只能使用文件描述符0到255。由于perl调用open（）然后使用结果文件描述符调用fdopen（3C），因此即使使用sysopen（），perl也被限制为255个同时打开的文件。如果证明这是一个无法解决的问题，则可以将perl编译为LP64应用程序，有关详细信息，请参阅&lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;构建LP64 perl&lt;/a&gt;。另请注意，在Solaris上，打开文件描述符的默认资源限制为255，因此您将必须适当地修改ulimit或rctl（从Solaris 9开始）。</target>
        </trans-unit>
        <trans-unit id="00bff96ca21371570b04e3ba98b01671b01481ae" translate="yes" xml:space="preserve">
          <source>The store functions will &lt;code&gt;croak&lt;/code&gt; if they run into such references unless you set &lt;code&gt;$Storable::forgive_me&lt;/code&gt; to some &lt;code&gt;TRUE&lt;/code&gt; value. In that case, the fatal message is converted to a warning and some meaningless string is stored instead.</source>
          <target state="translated">这家商店的功能会 &lt;code&gt;croak&lt;/code&gt; ，如果他们碰上这样的引用，除非你设置 &lt;code&gt;$Storable::forgive_me&lt;/code&gt; 一些 &lt;code&gt;TRUE&lt;/code&gt; 值。在这种情况下，致命消息将转换为警告，并存储一些无意义的字符串。</target>
        </trans-unit>
        <trans-unit id="af1c1657bd0ce03b1ba6ae64acc2840b7f31bd40" translate="yes" xml:space="preserve">
          <source>The strend and patend pointers should point to the byte following the last character of each string.</source>
          <target state="translated">strend和patend指针应该指向每个字符串最后一个字符后的字节。</target>
        </trans-unit>
        <trans-unit id="ccae9ac2ba65b56262ababed8ca5ba389eb0ed32" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; . (Ths tells Perl to use the &lt;code&gt;NDBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="translated">字符串 &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; 。（这告诉Perl使用 &lt;code&gt;NDBM_File&lt;/code&gt; 包执行哈希函数。）</target>
        </trans-unit>
        <trans-unit id="c5c77c76e1fc3205395047a2345f8ef41459d3bb" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;$vec&lt;/code&gt; only takes up as many bits as it needs. For instance, if you had 16 entries in &lt;code&gt;@ints&lt;/code&gt; , &lt;code&gt;$vec&lt;/code&gt; only needs two bytes to store them (not counting the scalar variable overhead).</source>
          <target state="translated">字符串 &lt;code&gt;$vec&lt;/code&gt; 仅占用所需的位数。例如，如果 &lt;code&gt;@ints&lt;/code&gt; 中有16个条目，则 &lt;code&gt;$vec&lt;/code&gt; 仅需要两个字节来存储它们（不计算标量变量的开销）。</target>
        </trans-unit>
        <trans-unit id="ace981c506425cb8cbcfe9d653a843e517d5bdac" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; has six graphemes but up to eight codepoints. This counts by grapheme, not by codepoint:</source>
          <target state="translated">字符串 &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; 具有六个音素，但最多八个编码点。这是通过字素而不是代码点计算的：</target>
        </trans-unit>
        <trans-unit id="e842cb2ff66d209b19263b7c79265ed68c6571d7" translate="yes" xml:space="preserve">
          <source>The string following whatever was matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK). Example:</source>
          <target state="translated">上一次成功的模式匹配所匹配的字符串（不包括隐藏在当前BLOCK所包围的BLOCK或 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 中的任何匹配项）。例：</target>
        </trans-unit>
        <trans-unit id="64817d2b5e56c060bf38149d53adb10efe254293" translate="yes" xml:space="preserve">
          <source>The string for Tuesday, December 12, 1995.</source>
          <target state="translated">1995年12月12日星期二的字符串。</target>
        </trans-unit>
        <trans-unit id="f9abb06eb1806839c0e5b7b9bda35c81b35ae824" translate="yes" xml:space="preserve">
          <source>The string index to a &lt;b&gt;hash&lt;/b&gt;, used to look up the &lt;b&gt;value&lt;/b&gt; associated with that key.</source>
          <target state="translated">&lt;b&gt;哈希&lt;/b&gt;的字符串索引，用于查找与该键关联的&lt;b&gt;值&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="cdaff357d54d31b09acea6f6d18fd623eddeb9f1" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">该字符串被分成由TEMPLATE描述的块。每个块分别转换为一个值。通常，字符串是 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 的结果，或者字符串的字符表示某种C结构。</target>
        </trans-unit>
        <trans-unit id="1c49e7731d3dc172a2f14e1ee383fed675a44e84" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">该字符串被分成由TEMPLATE描述的块。每个块分别转换为一个值。通常，字符串是 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 的结果，或者字符串的字符表示某种C结构。</target>
        </trans-unit>
        <trans-unit id="188acb1539bbcc7515d5af86f1bf3d6e3f0bd9c0" translate="yes" xml:space="preserve">
          <source>The string matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK).</source>
          <target state="translated">上一次成功的模式匹配所匹配的字符串（不计算隐藏在当前BLOCK所包围的BLOCK或 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 中的任何匹配项）。</target>
        </trans-unit>
        <trans-unit id="3d206cfe2e19b0f3779f91c6d76bdde7d7e22deb" translate="yes" xml:space="preserve">
          <source>The string output (of floating point numbers) will be padded with zeros:</source>
          <target state="translated">字符串输出(浮点数的)将用0填充。</target>
        </trans-unit>
        <trans-unit id="baf7cbc523832c454565f07354dbdc53faf7a98a" translate="yes" xml:space="preserve">
          <source>The string output will always have leading and trailing zeros stripped and drop a plus sign. &lt;code&gt;bstr()&lt;/code&gt; will give you always the form with a decimal point, while &lt;code&gt;bsstr()&lt;/code&gt; (s for scientific) gives you the scientific notation.</source>
          <target state="translated">字符串输出将始终去除开头和结尾的零，并删除加号。 &lt;code&gt;bstr()&lt;/code&gt; 会始终为您提供带小数点的形式，而 &lt;code&gt;bsstr()&lt;/code&gt; （s表示科学）会为您提供科学计数法。</target>
        </trans-unit>
        <trans-unit id="fe7b97aace0009c030b7f9cefcb2ca042c7263c6" translate="yes" xml:space="preserve">
          <source>The string preceding whatever was matched by the last successful pattern match, not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK.</source>
          <target state="translated">上一次成功的模式匹配所匹配的内容之前的字符串，不计算隐藏在当前块所包围的块或 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 任何匹配。</target>
        </trans-unit>
        <trans-unit id="3d01fff15593695c94b4861cde9efd9b7494ec49" translate="yes" xml:space="preserve">
          <source>The string result of any operation that uses locale information is tainted, as it is possible for a locale to be untrustworthy. See &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;.</source>
          <target state="translated">使用语言环境信息的任何操作的字符串结果都会受到污染，因为语言环境可能是不可信任的。请参阅&amp;ldquo; &lt;a href=&quot;#SECURITY&quot;&gt;安全性&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8fe36e2f9f506bb3c17ca908f63a229076cb522b" translate="yes" xml:space="preserve">
          <source>The string returned is not always in NFD/NFKD. Reordering may be required.</source>
          <target state="translated">返回的字符串并不总是NFD/NFKD。可能需要重新排序。</target>
        </trans-unit>
        <trans-unit id="0906d45502ea0bd7da882f8e89531d4e1f01bc75" translate="yes" xml:space="preserve">
          <source>The string that starts options. If a constant string is not sufficient, see &lt;code&gt;prefix_pattern&lt;/code&gt; .</source>
          <target state="translated">开始选项的字符串。如果常量字符串不足，请参见 &lt;code&gt;prefix_pattern&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcff2e1cc42c11b32cad489cc398585a2adb0338" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by</source>
          <target state="translated">要插入的字符串用</target>
        </trans-unit>
        <trans-unit id="e41abf45c9431728dd7313f8c098905bb3fb1c5d" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by octets starting at</source>
          <target state="translated">要插入的字符串用八位数来表示,开始于</target>
        </trans-unit>
        <trans-unit id="afbb1230317b082fc0f64afe5f1a79c6e5661e9b" translate="yes" xml:space="preserve">
          <source>The string to be inserted is the string value of</source>
          <target state="translated">要插入的字符串是字符串值为</target>
        </trans-unit>
        <trans-unit id="5a627ebdca058ca40f7afebaa0947770e3b19935" translate="yes" xml:space="preserve">
          <source>The string value of &lt;code&gt;$!&lt;/code&gt; is that returned by the CRTL's strerror() function, so it will include the VMS message for VMS-specific errors. The numeric value of &lt;code&gt;$!&lt;/code&gt; is the value of &lt;code&gt;errno&lt;/code&gt; , except if errno is EVMSERR, in which case &lt;code&gt;$!&lt;/code&gt; contains the value of vaxc$errno. Setting &lt;code&gt;$!&lt;/code&gt; always sets errno to the value specified. If this value is EVMSERR, it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the string value of &lt;code&gt;$!&lt;/code&gt; won't reflect the VMS error message from before &lt;code&gt;$!&lt;/code&gt; was set.</source>
          <target state="translated">字符串值 &lt;code&gt;$!&lt;/code&gt; 是由CRTL的strerror（）函数返回的，因此它将包括针对VMS特定错误的VMS消息。 &lt;code&gt;$!&lt;/code&gt; 的数值 是 &lt;code&gt;errno&lt;/code&gt; 的值，除非errno是EVMSERR，在这种情况下 &lt;code&gt;$!&lt;/code&gt; 包含vaxc $ errno的值。设定 &lt;code&gt;$!&lt;/code&gt; 始终将errno设置为指定的值。如果此值为EVMSERR，则还将vaxc $ errno设置为4（NONAME-F-NOMSG），因此字符串值 &lt;code&gt;$!&lt;/code&gt; 不会反映 &lt;code&gt;$!&lt;/code&gt; 之前的VMS错误消息！被设定。</target>
        </trans-unit>
        <trans-unit id="ed1f52a4cdbc897685e0ae4db35f3139cd121ffc" translate="yes" xml:space="preserve">
          <source>The string value of the $data provided as argument is appended to the message we calculate the digest for. The return value is the $ctx object itself.</source>
          <target state="translated">作为参数提供的$data的字符串值被附加到我们计算摘要的消息中。返回值是$ctx对象本身。</target>
        </trans-unit>
        <trans-unit id="8d2353f63db6ded15b27f9ce53f46b40b4850e7c" translate="yes" xml:space="preserve">
          <source>The struct() function</source>
          <target state="translated">结构()函数</target>
        </trans-unit>
        <trans-unit id="2b18f7164a2da5acc0a078abefbfdb45f1b7ed1a" translate="yes" xml:space="preserve">
          <source>The structure of the tied() data is an array reference with elements</source>
          <target state="translated">tied()数据的结构是一个数组引用,元素是</target>
        </trans-unit>
        <trans-unit id="6772fe1a2535c049980c3763958a49b4c1d992f9" translate="yes" xml:space="preserve">
          <source>The stub package included with the perl distribution allows some additional methods:</source>
          <target state="translated">perl发行版中包含的stub包允许一些额外的方法。</target>
        </trans-unit>
        <trans-unit id="6bfcc48f6a94ab4b3e39e57492b7c1d6d2ad759d" translate="yes" xml:space="preserve">
          <source>The submitter address in &lt;code&gt;AUTH&lt;/code&gt; option is expected to be in a format as required by RFC 2554, in an RFC2821-quoted form and xtext-encoded, or &amp;lt;&amp;gt; .</source>
          <target state="translated">&lt;code&gt;AUTH&lt;/code&gt; 选项中的提交者地址应采用RFC 2554要求的格式，采用RFC2821引用的格式，并采用xtext编码或&amp;lt;&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="4fb6dff8391b18be99fd9ebb7eb204cdfa56639a" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'='&lt;/code&gt; does not overload the Perl assignment operator: it is used only to allow mutators to work as described here. (See &lt;a href=&quot;#Assignments&quot;&gt;Assignments&lt;/a&gt; above.)</source>
          <target state="translated">&lt;code&gt;'='&lt;/code&gt; 的子例程不会使Perl赋值运算符重载：它仅用于允许更改器按此处所述工作。（请参阅上面的&lt;a href=&quot;#Assignments&quot;&gt;作业&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="f6d2e2cf74b94dd2aff54191a4db818c472b013b" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'qr'&lt;/code&gt; is used wherever the object is interpolated into or used as a regexp, including when it appears on the RHS of a &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;'qr'&lt;/code&gt; 子例程用于将对象插入或用作正则表达式的任何位置，包括当它出现在 &lt;code&gt;=~&lt;/code&gt; 或 &lt;code&gt;!~&lt;/code&gt; 运算符的RHS中时。</target>
        </trans-unit>
        <trans-unit id="64e556905a1003da7539606b5717985b47db5c9d" translate="yes" xml:space="preserve">
          <source>The subroutine for the assignment variant of an operator is required only to return the result of the operation. It is permitted to change the value of its operand (this is safe because Perl calls the copy constructor first), but this is optional since Perl assigns the returned value to the left-hand operand anyway.</source>
          <target state="translated">运算符的赋值变体的子程序只需要返回操作的结果。它允许改变其操作数的值(这是安全的,因为Perl会先调用复制构造函数),但这是可选的,因为Perl无论如何都会将返回的值分配给左手操作数。</target>
        </trans-unit>
        <trans-unit id="bf76f7497b47b7fb391cbc985e75a2ec906b200f" translate="yes" xml:space="preserve">
          <source>The subroutine interface has the advantage over the constants interface in that only two subroutines are exported into your namespace, versus thirty-eight in the constants interface. On the flip side, the constants interface has the advantage of better compile time error checking, since misspelled names of colors or attributes in calls to color() and colored() won't be caught until runtime whereas misspelled names of constants will be caught at compile time. So, pollute your namespace with almost two dozen subroutines that you may not even use that often, or risk a silly bug by mistyping an attribute. Your choice, TMTOWTDI after all.</source>
          <target state="translated">与常量接口相比,子程序接口的优势在于只有两个子程序被输出到你的命名空间,而常量接口则有38个。反过来说,常量接口的优势在于它有更好的编译时错误检查功能,因为在调用color()和colored()时拼写错误的颜色或属性的名字要到运行时才会被发现,而常量拼写错误的名字会在编译时被发现。所以,是用近二十多个子程序来污染你的命名空间,而这些子程序你可能并不经常使用,还是冒着错误键入一个属性的风险去做一个愚蠢的错误。你的选择,TMTOWTDI毕竟。</target>
        </trans-unit>
        <trans-unit id="914a52e2466ed981c0c31fa5a16b3a84e13235bf" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to five optional arguments:</source>
          <target state="translated">该子程序最多接受五个可选参数。</target>
        </trans-unit>
        <trans-unit id="685ad04169c11394ad7ed60a2bfecf22cb675ffa" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments (the same set as &lt;code&gt;extract_tagged&lt;/code&gt; except for the string to be processed). It returns a reference to a subroutine which in turn takes a single argument (the text to be extracted from).</source>
          <target state="translated">子例程最多包含四个可选参数（除了要处理的字符串之外，其他设置与 &lt;code&gt;extract_tagged&lt;/code&gt; 相同）。它返回对子例程的引用，该子例程又接受一个参数（要从中提取文本）。</target>
        </trans-unit>
        <trans-unit id="8d893978d831c7b5b97d6abcf392307452f2c4dc" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments:</source>
          <target state="translated">该子程序最多接受四个可选参数。</target>
        </trans-unit>
        <trans-unit id="7612ae6125d2980d42108a51846f43870c13a8ab" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to two optional arguments:</source>
          <target state="translated">该子程序最多接受两个可选参数。</target>
        </trans-unit>
        <trans-unit id="3a75faaa2a2f313dd76bd18e70bc1892ae4231d3" translate="yes" xml:space="preserve">
          <source>The subroutines for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , and &lt;code&gt;'bool'&lt;/code&gt; can return any arbitrary Perl value. If the corresponding operation for this value is overloaded too, the operation will be called again with this value.</source>
          <target state="translated">&lt;code&gt;'&quot;&quot;'&lt;/code&gt; ， &lt;code&gt;'0+'&lt;/code&gt; 和 &lt;code&gt;'bool'&lt;/code&gt; 的子例程可以返回任意的Perl值。如果与此值对应的操作也过载，则将使用该值再次调用该操作。</target>
        </trans-unit>
        <trans-unit id="268a5bcbdfddf71f1babd661a5336aa5d10c3ae8" translate="yes" xml:space="preserve">
          <source>The subroutines must return a specially-formatted string, with one or more newline-separated lines. Each line must be one of the following:</source>
          <target state="translated">子程序必须返回一个特殊格式的字符串,其中包含一个或多个以新行分隔的行。每一行必须是以下内容之一:</target>
        </trans-unit>
        <trans-unit id="2ba07955562198fe0f02a6cf2bc902a4d38ec5bc" translate="yes" xml:space="preserve">
          <source>The subscript separator for multidimensional array emulation. If you refer to a hash element as</source>
          <target state="translated">多维数组仿真的下标分隔符。如果您将一个哈希元素称为</target>
        </trans-unit>
        <trans-unit id="b5d318f376ec00a74018e4ca7dc7c929a2558708" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">替代运算符。请参阅&lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop中的Regexp类引用运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cdda388fa507341e8fbaf2711ecce13a77670278" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">替代运算符。请参阅&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop中的Regexp类引用运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43eed4ac710279951c5f21e178623c718cf97122" translate="yes" xml:space="preserve">
          <source>The substring to be extracted must appear at the current &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; location of the string's variable (or at index zero, if no &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; position is defined). In other words, the &lt;code&gt;extract_...&lt;/code&gt; subroutines</source>
          <target state="translated">要提取的子字符串必须出现在字符串变量的当前 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 位置（或者，如果未定义 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 位置，则显示在索引零）。换句话说， &lt;code&gt;extract_...&lt;/code&gt; 子例程</target>
        </trans-unit>
        <trans-unit id="631c84fac439176eea77875d9cd55aac6e34bef4" translate="yes" xml:space="preserve">
          <source>The subtle but sometimes brutal art of attempting to turn your possibly malformed program into a valid &lt;b&gt;syntax tree&lt;/b&gt;.</source>
          <target state="translated">试图将您可能格式错误的程序转换为有效的&lt;b&gt;语法树&lt;/b&gt;的技巧，但有时却是残酷的。</target>
        </trans-unit>
        <trans-unit id="69b5462de54900759de9c61920b693e4e317aaf5" translate="yes" xml:space="preserve">
          <source>The subversion level of this package. The value of subversion comes from the</source>
          <target state="translated">这个包的subversion级别。subversion的值来自于</target>
        </trans-unit>
        <trans-unit id="270d4886cf1a538b0addd0c2b282f59bb7645fa0" translate="yes" xml:space="preserve">
          <source>The superuser (&lt;code&gt;UID&lt;/code&gt; == 0). Also the top-level directory of the filesystem.</source>
          <target state="translated">超级用户（ &lt;code&gt;UID&lt;/code&gt; == 0）。也是文件系统的顶级目录。</target>
        </trans-unit>
        <trans-unit id="bb4d5743fc0dd23109f98c367b228edac660d539" translate="yes" xml:space="preserve">
          <source>The support of Unicode is new starting from Perl version v5.6, and more fully implemented in versions v5.8 and later. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">从Perl版本v5.6开始新增了对Unicode的支持，并且在版本v5.8及更高版本中更全面地实现了Unicode。参见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a84c55afdf9f74f3a1d06dd4132c903afc0559c7" translate="yes" xml:space="preserve">
          <source>The supported platforms are Linux, and OS X (some *BSD might work at least partly, but they have not yet been tested).</source>
          <target state="translated">支持的平台是Linux,和OS X(一些*BSD可能至少部分工作,但它们还没有被测试)。</target>
        </trans-unit>
        <trans-unit id="c6fbcb6100de3c481ef36f607630c6994106ebd8" translate="yes" xml:space="preserve">
          <source>The surprising part is that &lt;code&gt;--a&lt;/code&gt; sets option &lt;code&gt;a&lt;/code&gt; (due to auto completion), not &lt;code&gt;all&lt;/code&gt; .</source>
          <target state="translated">令人惊讶的部分是 &lt;code&gt;--a&lt;/code&gt; 设置了选项 &lt;code&gt;a&lt;/code&gt; （由于自动完成），而不是 &lt;code&gt;all&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="033617fd53c9330532a1c3d67c45fd0449d158c6" translate="yes" xml:space="preserve">
          <source>The surroundings or environment. The context given by the surrounding code determines what kind of data a particular &lt;b&gt;expression&lt;/b&gt; is expected to return. The three primary contexts are &lt;b&gt;list context&lt;/b&gt;, &lt;b&gt;scalar&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. Scalar context is sometimes subdivided into &lt;b&gt;Boolean context&lt;/b&gt;, &lt;b&gt;numeric context&lt;/b&gt;, &lt;b&gt;string context&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. There&amp;rsquo;s also a &amp;ldquo;don&amp;rsquo;t care&amp;rdquo; context (which is dealt with in Camel chapter 2, &amp;ldquo;Bits and Pieces&amp;rdquo;, if you care).</source>
          <target state="translated">环境或环境。周围代码给出的上下文确定特定&lt;b&gt;表达式&lt;/b&gt;期望返回哪种数据。三个主要上下文是&lt;b&gt;列表上下文&lt;/b&gt;，&lt;b&gt;标量&lt;/b&gt;和&lt;b&gt;无效上下文&lt;/b&gt;。标量上下文有时又细分为&lt;b&gt;布尔上下文&lt;/b&gt;，&lt;b&gt;数字上下文&lt;/b&gt;，&lt;b&gt;字符串上下文&lt;/b&gt;和&lt;b&gt;void上下文&lt;/b&gt;。还有一个&amp;ldquo;无关&amp;rdquo;上下文（如果需要的话，请参见骆驼第2章&amp;ldquo;零碎&amp;rdquo;部分）。</target>
        </trans-unit>
        <trans-unit id="ed80b515b4081009a4556929c3f21adbe337dfc8" translate="yes" xml:space="preserve">
          <source>The sv_magic function uses &lt;code&gt;how&lt;/code&gt; to determine which, if any, predefined &quot;Magic Virtual Table&quot; should be assigned to the &lt;code&gt;mg_virtual&lt;/code&gt; field. See the &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; section below. The &lt;code&gt;how&lt;/code&gt; argument is also stored in the &lt;code&gt;mg_type&lt;/code&gt; field. The value of &lt;code&gt;how&lt;/code&gt; should be chosen from the set of macros &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; found in</source>
          <target state="translated">sv_magic函数使用 &lt;code&gt;how&lt;/code&gt; 确定应该将哪些预定义的&amp;ldquo; Magic虚拟表&amp;rdquo;分配给 &lt;code&gt;mg_virtual&lt;/code&gt; 字段。请参阅下面的&amp;ldquo; &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;魔术虚拟表&amp;rdquo;&lt;/a&gt;部分。该 &lt;code&gt;how&lt;/code&gt; 参数也存储在 &lt;code&gt;mg_type&lt;/code&gt; 领域。的价值 &lt;code&gt;how&lt;/code&gt; 应从组宏选择 &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; 中发现的</target>
        </trans-unit>
        <trans-unit id="6d632295f69a2e258303de734a1930d293a5d47a" translate="yes" xml:space="preserve">
          <source>The switch statement is called &lt;code&gt;given/when&lt;/code&gt; and only available in perl 5.10 or newer. See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">switch语句称为 &lt;code&gt;given/when&lt;/code&gt; ，仅在perl 5.10或更高版本中可用。请参阅&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsyn中的Switch语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd4512bd52c00d29ccebf2f597b2a43c4da8833a" translate="yes" xml:space="preserve">
          <source>The symbol between angle brackets indicates the op's type, for example; &amp;lt;2&amp;gt; is a BINOP, &amp;lt;@&amp;gt; a LISTOP, and &amp;lt;#&amp;gt; is a PADOP, which is used in threaded perls. (see &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;OP class abbreviations&lt;/a&gt;).</source>
          <target state="translated">例如，尖括号之间的符号表示op的类型；&amp;lt;2&amp;gt;是BINOP，&amp;lt;@&amp;gt;是LISTOP，&amp;lt;＃&amp;gt;是PADOP，用于线程Perl。（请参阅&lt;a href=&quot;#OP-class-abbreviations&quot;&gt;OP类的缩写&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2fa8c942f2b2a058230427b77fde679fbccbc45f" translate="yes" xml:space="preserve">
          <source>The symbol table for a package happens to be stored in the hash of that name with two colons appended. The main symbol table's name is thus &lt;code&gt;%main::&lt;/code&gt; , or &lt;code&gt;%::&lt;/code&gt; for short. Likewise the symbol table for the nested package mentioned earlier is named &lt;code&gt;%OUTER::INNER::&lt;/code&gt; .</source>
          <target state="translated">软件包的符号表恰好存储在该名称的哈希中，并附加了两个冒号。主符号表的名称因此简称为 &lt;code&gt;%main::&lt;/code&gt; 或 &lt;code&gt;%::&lt;/code&gt; 。同样，前面提到的嵌套包的符号表名为 &lt;code&gt;%OUTER::INNER::&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4d8237c3f2b5d66316d69a0012fa0f4c23704f9" translate="yes" xml:space="preserve">
          <source>The symbol table is filled with names looking like line-noise.</source>
          <target state="translated">符号表里的名字看起来就像线噪。</target>
        </trans-unit>
        <trans-unit id="c5234fa33c4424920b3b6f455994e7727a2634e0" translate="yes" xml:space="preserve">
          <source>The symbols, ZIP_CM_STORE, ZIP_CM_DEFLATE, ZIP_CM_BZIP2 and ZIP_CM_LZMA are used to select the compression method.</source>
          <target state="translated">符号ZIP_CM_STORE、ZIP_CM_DEFLATE、ZIP_CM_BZIP2和ZIP_CM_LZMA用于选择压缩方式。</target>
        </trans-unit>
        <trans-unit id="0e5ab20507b2337eca95f7b51820364382691825" translate="yes" xml:space="preserve">
          <source>The syntactic position falling between a method call and its arguments when using the indirect object invocation syntax. (The slot is distinguished by the absence of a comma between it and the next argument.) &lt;code&gt;STDERR&lt;/code&gt; is in the indirect object slot here:</source>
          <target state="translated">使用间接对象调用语法时，方法调用及其参数之间的句法位置。（该插槽的特点是它与下一个参数之间没有逗号。） &lt;code&gt;STDERR&lt;/code&gt; 在此处的间接对象插槽中：</target>
        </trans-unit>
        <trans-unit id="f8f8b505ce05315e1a17e36787d4eec3e6ea7c76" translate="yes" xml:space="preserve">
          <source>The syntax</source>
          <target state="translated">语法</target>
        </trans-unit>
        <trans-unit id="b260d025f9cb3da5ac539f033e81a2ed933eaba6" translate="yes" xml:space="preserve">
          <source>The syntax and behavior is similar to a &lt;code&gt;SKIP: BLOCK&lt;/code&gt; except the tests will be marked as failing but todo. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret them as passing.</source>
          <target state="translated">语法和行为与&amp;ldquo; &lt;code&gt;SKIP: BLOCK&lt;/code&gt; 相似，不同之处在于测试将被标记为失败但可以执行。&lt;a href=&quot;harness&quot;&gt;测试::线束&lt;/a&gt;会将其解释为通过。</target>
        </trans-unit>
        <trans-unit id="47cc68a8f32c23223d1563cd08d4fd0cd4cd2e20" translate="yes" xml:space="preserve">
          <source>The syntax for &lt;code&gt;skip&lt;/code&gt; is about the only way it can be, but it's still quite confusing. Just start with the above examples and you'll be okay.</source>
          <target state="translated">&lt;code&gt;skip&lt;/code&gt; 的语法大约是唯一的方法，但是仍然很混乱。只要从上面的示例开始，您就可以了。</target>
        </trans-unit>
        <trans-unit id="ad53e9b382fc96ff2b2e55cab8f01b18f6934cd1" translate="yes" xml:space="preserve">
          <source>The syntax for an Input FileGlob is identical to &lt;code&gt;File::Glob&lt;/code&gt; , except for the following</source>
          <target state="translated">输入FileGlob的语法与 &lt;code&gt;File::Glob&lt;/code&gt; 相同，但以下内容除外</target>
        </trans-unit>
        <trans-unit id="d238d90126a97e645c3d07a616c57a948aa56c49" translate="yes" xml:space="preserve">
          <source>The syntax for encoding text strings to binary strings is as simple as decoding:</source>
          <target state="translated">将文本字符串编码为二进制字符串的语法和解码一样简单。</target>
        </trans-unit>
        <trans-unit id="0de2770d6e55eee81f76094997c8b0b61106fb04" translate="yes" xml:space="preserve">
          <source>The syntax:</source>
          <target state="translated">语法:</target>
        </trans-unit>
        <trans-unit id="a6f851731919e85a8b6dbd2464120f7f6baa4b5b" translate="yes" xml:space="preserve">
          <source>The system being designed is large, or is likely to become large.</source>
          <target state="translated">正在设计的系统是大型的,或有可能成为大型的。</target>
        </trans-unit>
        <trans-unit id="a8562e11d0057f4470ed7be8cd68c00d5386166f" translate="yes" xml:space="preserve">
          <source>The system copy routine may also be called directly under VMS and OS/2 as &lt;code&gt;File::Copy::syscopy&lt;/code&gt; (or under VMS as &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; , which is the routine that does the actual work for syscopy).</source>
          <target state="translated">系统复制例程也可以直接在VMS和OS / 2下以 &lt;code&gt;File::Copy::syscopy&lt;/code&gt; （或在VMS下以 &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; ，这是为syscopy进行实际工作的例程）。</target>
        </trans-unit>
        <trans-unit id="3b60dcb15de0e9f8fb8f2aec0c96f53a958b30c3" translate="yes" xml:space="preserve">
          <source>The system design is already object-oriented.</source>
          <target state="translated">系统设计已经是面向对象的。</target>
        </trans-unit>
        <trans-unit id="f2d2b02a34c5f3a2771d92387a8965fe957ed399" translate="yes" xml:space="preserve">
          <source>The system ignores the first line and feeds the program to</source>
          <target state="translated">系统忽略第一行,并将程序送至</target>
        </trans-unit>
        <trans-unit id="f1eb32227e059ade5c92f6015a4dd65ea3a6bc28" translate="yes" xml:space="preserve">
          <source>The system time is the amount of time the kernel itself spent executing routines, or system calls, on behalf of this process user.</source>
          <target state="translated">系统时间是指内核本身代表这个进程用户执行例程或系统调用的时间。</target>
        </trans-unit>
        <trans-unit id="831ee4615baf52dd07f0a014bffa561cd6b8234d" translate="yes" xml:space="preserve">
          <source>The system time of the null loop might be slightly more than the system time of the loop with the actual code and therefore the difference might end up being &amp;lt; 0.</source>
          <target state="translated">空循环的系统时间可能会比带有实际代码的循环的系统时间稍长一些，因此差值可能最终小于0。</target>
        </trans-unit>
        <trans-unit id="5880c4b2f3b12a5f35ec0374b9437ee3cf2ad712" translate="yes" xml:space="preserve">
          <source>The system's notion of time of day and calendar date is controlled in widely different ways. Don't assume the timezone is stored in &lt;code&gt;$ENV{TZ}&lt;/code&gt; , and even if it is, don't assume that you can control the timezone through that variable. Don't assume anything about the three-letter timezone abbreviations (for example that MST would be the Mountain Standard Time, it's been known to stand for Moscow Standard Time). If you need to use timezones, express them in some unambiguous format like the exact number of minutes offset from UTC, or the POSIX timezone format.</source>
          <target state="translated">系统的日期时间和日历日期的概念以多种不同的方式进行控制。不要假设时区存储在 &lt;code&gt;$ENV{TZ}&lt;/code&gt; ，即使是这样，也不要假设您可以通过该变量控制时区。不要对三个字母的时区缩写做任何假设（例如，MST将是&amp;ldquo;山区标准时间&amp;rdquo;，众所周知，它代表&amp;ldquo;莫斯科标准时间&amp;rdquo;）。如果您需要使用时区，请以一些明确的格式表示它们，例如与UTC的确切分钟数偏移或POSIX时区格式。</target>
        </trans-unit>
        <trans-unit id="10bc5e79cfd3d40c28f5293903b887866aeb92ec" translate="yes" xml:space="preserve">
          <source>The table below has two columns. The left column contains the &lt;code&gt;\p{}&lt;/code&gt; constructs to look up, possibly preceded by the flags mentioned above; and the right column contains information about them, like a description, or synonyms. The table shows both the single and compound forms for each property that has them. If the left column is a short name for a property, the right column will give its longer, more descriptive name; and if the left column is the longest name, the right column will show any equivalent shortest name, in both single and compound forms if applicable.</source>
          <target state="translated">下表有两列。左列包含要查找的 &lt;code&gt;\p{}&lt;/code&gt; 构造，可能前面带有上述标志；右列包含有关它们的信息，例如描述或同义词。该表显示了具有它们的每个属性的单一形式和复合形式。如果左列是属性的缩写，则右列将给出其更长的，更具描述性的名称；如果左栏是最长的名称，则右栏将显示任何等效的最短名称，适用时可以是单字形式或复合形式。</target>
        </trans-unit>
        <trans-unit id="1666e90a958abe062ff0c13eedc4273819f1aea6" translate="yes" xml:space="preserve">
          <source>The table file should locate in the</source>
          <target state="translated">表文件应位于</target>
        </trans-unit>
        <trans-unit id="b1154d069cc05928d8b59c50b5730e339b959183" translate="yes" xml:space="preserve">
          <source>The table of methods for all operations is cached in magic for the symbol table hash for the package. The cache is invalidated during processing of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; , new function definitions, and changes in @ISA.</source>
          <target state="translated">所有操作的方法表都以魔术的形式缓存在包的符号表哈希中。在处理 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; ，新函数定义以及@ISA中的更改期间，缓存无效。</target>
        </trans-unit>
        <trans-unit id="b36cd501ad88aba2f3b3a0d1d67027c7a1e869d6" translate="yes" xml:space="preserve">
          <source>The table of smartmatches in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator in perlop&lt;/a&gt; is not identical to that proposed by the Perl 6 specification, mainly due to differences between Perl 6's and Perl 5's data models, but also because the Perl 6 spec has changed since Perl 5 rushed into early adoption.</source>
          <target state="translated">&lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;perlop&lt;/a&gt;中Smartmatch Operator中的smartmatchs表与Perl 6规范中提出的表不完全相同，这主要是由于Perl 6和Perl 5的数据模型之间的差异，也是因为自Perl 5抢先采用以来Perl 6规范已更改。</target>
        </trans-unit>
        <trans-unit id="94ad06074e14c7f30c5f734701604346041b5cbc" translate="yes" xml:space="preserve">
          <source>The tangent</source>
          <target state="translated">切线</target>
        </trans-unit>
        <trans-unit id="9125938896cf0c452742065869d161bf7df834a0" translate="yes" xml:space="preserve">
          <source>The tarball can be created as follows:</source>
          <target state="translated">焦油球的创建方法如下:</target>
        </trans-unit>
        <trans-unit id="b87ef1c14b4fb669d5f4570a38dcf5e22aa3e1b3" translate="yes" xml:space="preserve">
          <source>The target is to make OS/2 one of the best supported platform for using/building/developing Perl and</source>
          <target state="translated">我们的目标是使OS/2成为使用/构建/开发Perl的最佳支持平台之一。</target>
        </trans-unit>
        <trans-unit id="f704785556fc74856ecd269c550a540acda7d08d" translate="yes" xml:space="preserve">
          <source>The target of the OP, or nothing for a nulled OP.</source>
          <target state="translated">靶子的OP,或者什么都没有的无效OP。</target>
        </trans-unit>
        <trans-unit id="d551cba509e623574e29a4be73bb109e3d69062b" translate="yes" xml:space="preserve">
          <source>The template can take a different set of rules per key that is used.</source>
          <target state="translated">模板可以根据每个使用的密钥采取不同的规则集。</target>
        </trans-unit>
        <trans-unit id="56fadcfb4c1428b721edcda3a997763e93a92ef4" translate="yes" xml:space="preserve">
          <source>The template may be any filename with some number of X's appended to it, for example F. The trailing X's are replaced with unique alphanumeric combinations.</source>
          <target state="translated">模板可以是任何附加了一些X的文件名,例如F,后面的X用唯一的字母数字组合代替。</target>
        </trans-unit>
        <trans-unit id="527fc2a5f793bc1d57c90fcfdd90ce2b38cfafb9" translate="yes" xml:space="preserve">
          <source>The term &quot;native&quot; does not mean quite as much when we talk about native integers, as it does when native floating point numbers are involved. The only implication of the term &quot;native&quot; on integers is that the limits for the maximal and the minimal supported true integral quantities are close to powers of 2. However, &quot;native&quot; floats have a most fundamental restriction: they may represent only those numbers which have a relatively &quot;short&quot; representation when converted to a binary fraction. For example, 0.9 cannot be represented by a native float, since the binary fraction for 0.9 is infinite:</source>
          <target state="translated">当我们谈论原生整数时,&quot;原生 &quot;一词的意义并不像涉及原生浮点数时那样大。但是,&quot;原生 &quot;浮点数有一个最基本的限制:它们只能表示那些转换为二进制分数时有相对 &quot;短 &quot;表示的数字。例如,0.9不能用原生浮点数表示,因为0.9的二进制分数是无限的。</target>
        </trans-unit>
        <trans-unit id="60065770d703c59b1d8e19903d480a6c8c3d4ce7" translate="yes" xml:space="preserve">
          <source>The term &quot;railroad normal form&quot; is a bit esoteric, with &quot;syntax diagram/charts&quot;, or &quot;railroad diagram/charts&quot; being more common terms. Nevertheless it provides a useful mental image of a regex program: each node can be thought of as a unit of track, with a single entry and in most cases a single exit point (there are pieces of track that fork, but statistically not many), and the whole forms a layout with a single entry and single exit point. The matching process can be thought of as a car that moves along the track, with the particular route through the system being determined by the character read at each possible connector point. A car can fall off the track at any point but it may only proceed as long as it matches the track.</source>
          <target state="translated">&quot;铁路正常形式 &quot;这个术语有点深奥,&quot;语法图/图 &quot;或 &quot;铁路图/图 &quot;是更常见的术语。尽管如此,它还是提供了一个有用的重构程序的心理形象:每一个节点都可以看作是一个轨道单位,只有一个入口,大多数情况下只有一个出口点(有的轨道会分叉,但据统计并不多),整个形成了一个布局,只有一个入口和一个出口点。匹配过程可以看成是一辆沿着轨道移动的汽车,在系统中的具体路线由每个可能的连接点读取的字符决定。车子可以在任何一个点掉出轨道,但只要与轨道匹配,它就只能继续前进。</target>
        </trans-unit>
        <trans-unit id="cb8cf5974b1ed2433ffc34db8b95199dcc132ecd" translate="yes" xml:space="preserve">
          <source>The term 'mathemagic' describes the overloaded implementation of mathematical operators. Mathemagical operations raise an issue. Consider the code:</source>
          <target state="translated">术语 &quot;数学 &quot;描述了数学运算符的超载实现。数理运算提出了一个问题。请看下面的代码。</target>
        </trans-unit>
        <trans-unit id="eaeae7045f589906beb0ab8c4692ec54095f2a80" translate="yes" xml:space="preserve">
          <source>The term, &quot;Unicode bug&quot; has been applied to an inconsistency with the code points in the &lt;code&gt;Latin-1 Supplement&lt;/code&gt; block, that is, between 128 and 255. Without a locale specified, unlike all other characters or code points, these characters can have very different semantics depending on the rules in effect. (Characters whose code points are above 255 force Unicode rules; whereas the rules for ASCII characters are the same under both ASCII and Unicode rules.)</source>
          <target state="translated">术语&amp;ldquo; Unicode错误&amp;rdquo;已应用于与 &lt;code&gt;Latin-1 Supplement&lt;/code&gt; 块中的代码点不一致的地方，即128到255之间。与所有其他字符或代码点不同，没有指定语言环境，这些字符可以具有取决于有效规则的语义非常不同。（代码点大于255的字符将强制执行Unicode规则；而ASCII和Unicode规则下的ASCII字符规则均相同。）</target>
        </trans-unit>
        <trans-unit id="694ad9d197b3bccc91651d679f02271b6dd9c6f8" translate="yes" xml:space="preserve">
          <source>The terminal output bit rate (often mistakenly called the baud rate) for this terminal - if not set a warning will be generated and it will be defaulted to 9600.</source>
          <target state="translated">该终端的终端输出比特率(通常被误称为波特率)--如果没有设置,将产生警告,默认为9600。</target>
        </trans-unit>
        <trans-unit id="45cdb3e3cad66807c8dfdf23c9cff4fc7bd36017" translate="yes" xml:space="preserve">
          <source>The terminal type whose termcap entry will be used - if not supplied it will default to $ENV{TERM}: if that is not set then &lt;b&gt;Tgetent&lt;/b&gt; will croak.</source>
          <target state="translated">将使用其termcap条目的终端类型-如果未提供，则默认为$ ENV {TERM}：如果未设置，则&lt;b&gt;Tgetent&lt;/b&gt;会&lt;b&gt;崩溃&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="a8d5f39cee7740c7c53d20d14cbf1ad8092c45e0" translate="yes" xml:space="preserve">
          <source>The terminating string may be either an identifier (a word), or some quoted text. An unquoted identifier works like double quotes. There may not be a space between the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and the identifier, unless the identifier is explicitly quoted. (If you put a space it will be treated as a null identifier, which is valid, and matches the first empty line.) The terminating string must appear by itself (unquoted and with no surrounding whitespace) on the terminating line.</source>
          <target state="translated">终止字符串可以是标识符（单词）或某些带引号的文本。未加引号的标识符的作用类似于双引号。除非显式引用标识符，否则 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 和标识符之间可能没有空格。（如果您放置一个空格，它将被视为一个空标识符，该标识符是有效的，并且与第一个空行匹配。）终止字符串必须自己出现在终止行上（未加引号且没有空格）。</target>
        </trans-unit>
        <trans-unit id="693f7bb103883c0a728e204ee6c0e2c1249be088" translate="yes" xml:space="preserve">
          <source>The terminator of runtime &lt;code&gt;(?{...})&lt;/code&gt; is found by temporarily switching control to the perl parser, which should stop at the point where the logically balancing terminating &lt;code&gt;}&lt;/code&gt; is found.</source>
          <target state="translated">通过将控制权暂时切换到perl解析器，可以找到运行时的终止符 &lt;code&gt;(?{...})&lt;/code&gt; ，该终止符应在找到逻辑平衡的终止符 &lt;code&gt;}&lt;/code&gt; 处停止。</target>
        </trans-unit>
        <trans-unit id="45074fa74bab84b7b8642e2f2cccf8a44bd5974b" translate="yes" xml:space="preserve">
          <source>The test</source>
          <target state="translated">测试</target>
        </trans-unit>
        <trans-unit id="404700fb40de228f041c8b476423971728a238e9" translate="yes" xml:space="preserve">
          <source>The test harness leaves much to be desired. Patches welcome.</source>
          <target state="translated">测试线束还有很多需要改进的地方。欢迎使用补丁。</target>
        </trans-unit>
        <trans-unit id="a5f877c1b13f5bd28ecef34f68e2dcb7eb31de7b" translate="yes" xml:space="preserve">
          <source>The test name extensions. Defaults to &lt;code&gt;.t&lt;/code&gt;.</source>
          <target state="translated">测试名称扩展名。默认为 &lt;code&gt;.t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18b17a09a74e93fa5e780df81bc80e5b90469686" translate="yes" xml:space="preserve">
          <source>The test suite is much better, but always needs improvement.</source>
          <target state="translated">测试套件要好得多,但总是需要改进。</target>
        </trans-unit>
        <trans-unit id="710c520b5e701804e8b8991b8c559c8c70f62fc8" translate="yes" xml:space="preserve">
          <source>The test will exit with 255.</source>
          <target state="translated">测试将以255退出。</target>
        </trans-unit>
        <trans-unit id="adc50b89ec0ba50b71ee74cf410505fc2fa0bc3e" translate="yes" xml:space="preserve">
          <source>The testing system is designed to be used by performing a three step process for each test you wish to test. This process starts with using &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; in advance to declare what the testsuite you are testing will output with &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; to stdout and stderr.</source>
          <target state="translated">该测试系统旨在通过对您要测试的每个测试执行三步过程来使用。此过程首先使用 &lt;code&gt;test_out&lt;/code&gt; 和 &lt;code&gt;test_err&lt;/code&gt; 来声明要测试的测试套件将通过&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;输出到stdout和stderr。</target>
        </trans-unit>
        <trans-unit id="e7d3c8b5f530bcb2e21b05b385528e49c2684bd6" translate="yes" xml:space="preserve">
          <source>The tests</source>
          <target state="translated">测试</target>
        </trans-unit>
        <trans-unit id="a22b8fe6a3e6e46d5dd177a5cb8828e7b0955e47" translate="yes" xml:space="preserve">
          <source>The tests &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-B&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; , &lt;code&gt;-e&lt;/code&gt; , &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-S&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; , and &lt;code&gt;-z&lt;/code&gt; work as advertised. The return values for &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; tell you whether you can actually access the file; this may not reflect the UIC-based file protections. Since real and effective UIC don't differ under VMS, &lt;code&gt;-O&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; . Similarly, several other tests, including &lt;code&gt;-A&lt;/code&gt; , &lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; , and &lt;code&gt;-u&lt;/code&gt; , aren't particularly meaningful under VMS, and the values returned by these tests reflect whatever your CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; routine does to the equivalent bits in the st_mode field. Finally, &lt;code&gt;-d&lt;/code&gt; returns true if passed a device specification without an explicit directory (e.g. &lt;code&gt;DUA1:&lt;/code&gt; ), as well as if passed a directory.</source>
          <target state="translated">测试 &lt;code&gt;-b&lt;/code&gt; ， &lt;code&gt;-B&lt;/code&gt; ， &lt;code&gt;-c&lt;/code&gt; ， &lt;code&gt;-C&lt;/code&gt; ， &lt;code&gt;-d&lt;/code&gt; ， &lt;code&gt;-e&lt;/code&gt; ， &lt;code&gt;-f&lt;/code&gt; ， &lt;code&gt;-o&lt;/code&gt; ， &lt;code&gt;-M&lt;/code&gt; ， &lt;code&gt;-s&lt;/code&gt; ， &lt;code&gt;-S&lt;/code&gt; ， &lt;code&gt;-t&lt;/code&gt; ， &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-z&lt;/code&gt; 的工作与广告一样。 &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; 和 &lt;code&gt;-x&lt;/code&gt; 的返回值告诉您是否可以实际访问该文件。这可能无法反映基于UIC的文件保护。由于真实有效的UIC在VMS下没有区别，因此 &lt;code&gt;-O&lt;/code&gt; ， &lt;code&gt;-R&lt;/code&gt; ， &lt;code&gt;-W&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 等效于 &lt;code&gt;-o&lt;/code&gt; ， &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; 和 &lt;code&gt;-x&lt;/code&gt; 。同样，在VMS下，其他几个测试（包括 &lt;code&gt;-A&lt;/code&gt; ， &lt;code&gt;-g&lt;/code&gt; ， &lt;code&gt;-k&lt;/code&gt; ， &lt;code&gt;-l&lt;/code&gt; ， &lt;code&gt;-p&lt;/code&gt; 和 &lt;code&gt;-u&lt;/code&gt; ）也不是特别有意义，这些测试返回的值反映了您的CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 例程所做的一切到st_mode字段中的等效位。最后，如果传递了没有显式目录的设备规范（例如 &lt;code&gt;DUA1:&lt;/code&gt; )以及传递了目录，则 &lt;code&gt;-d&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="4fe750878672d4fb196503a672d7f5b98d0e668b" translate="yes" xml:space="preserve">
          <source>The text &quot;Object Attributes&quot; comprises the heading there. The text in these heading commands can use formatting codes, as seen here:</source>
          <target state="translated">文本 &quot;对象属性 &quot;构成了那里的标题。这些标题命令中的文本可以使用格式代码,如这里所示。</target>
        </trans-unit>
        <trans-unit id="422420f7789cdb6ab09e238f60941fefea41ab12" translate="yes" xml:space="preserve">
          <source>The text matched by the last bracket of the last successful search pattern. This is useful if you don't know which one of a set of alternative patterns matched. For example:</source>
          <target state="translated">最后一个成功搜索模式的最后一个括号所匹配的文本。如果您不知道一组备选模式中哪一个匹配,这很有用。例如</target>
        </trans-unit>
        <trans-unit id="8d5e558c4e38b1badcb4cca2c007e3208f52adfb" translate="yes" xml:space="preserve">
          <source>The text matched by the used group most-recently closed (i.e. the group with the rightmost closing parenthesis) of the last successful search pattern.</source>
          <target state="translated">最后一次成功搜索模式的使用过的组(即最右边括号的组)所匹配的文本。</target>
        </trans-unit>
        <trans-unit id="c1c9727d8e424808f3451a4472d65a7ff102f563" translate="yes" xml:space="preserve">
          <source>The text of a message to print immediately prior to printing the program's usage message.</source>
          <target state="translated">在打印程序的使用信息之前,要立即打印的信息文本。</target>
        </trans-unit>
        <trans-unit id="2808389282f74befb5070bb0b9545514e48a6905" translate="yes" xml:space="preserve">
          <source>The text of the Makefile is run through this method before writing to disk. It allows systems a chance to make portability fixes to the Makefile.</source>
          <target state="translated">Makefile的文本在写入磁盘之前会通过这种方法运行。它让系统有机会对Makefile进行可移植性修正。</target>
        </trans-unit>
        <trans-unit id="4abae05debe0661c57f27b361d90da4ccea7c4db" translate="yes" xml:space="preserve">
          <source>The text/binary issue is covered at length in the Cygwin documentation.</source>
          <target state="translated">文本/二进制的问题在Cygwin文档中已有详细介绍。</target>
        </trans-unit>
        <trans-unit id="3155c02df4aea0a613a1c72b2a9ac5c7a7efff80" translate="yes" xml:space="preserve">
          <source>The thetas, phis, direction, and distance in the above are all in radians.</source>
          <target state="translated">上面的thetas、phis、方向、距离都是以弧度为单位。</target>
        </trans-unit>
        <trans-unit id="b1d631fb3ea4c05afea84d61f3fa4b47ab2ddcf3" translate="yes" xml:space="preserve">
          <source>The thing you&amp;rsquo;re working on. Structures like &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , and &lt;code&gt;given&lt;/code&gt; set the topic for you by assigning to &lt;code&gt;$_&lt;/code&gt; , the default (</source>
          <target state="translated">您正在处理的事情。结构类似 &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;foreach&lt;/code&gt; ，并 &lt;code&gt;given&lt;/code&gt; 通过分配来设置主题为你 &lt;code&gt;$_&lt;/code&gt; ，默认（</target>
        </trans-unit>
        <trans-unit id="d7aa255f6bad43d19c5308997ee1af4d4b4ab78c" translate="yes" xml:space="preserve">
          <source>The third argument ($binmode) will select binary mode if passed as a TRUE value. In binary mode &quot;\n&quot; will be encoded in the same way as any other non-printable character. This ensures that a decoder will end up with exactly the same string whatever line ending sequence it uses. In general it is preferable to use the base64 encoding for binary data; see &lt;a href=&quot;base64&quot;&gt;MIME::Base64&lt;/a&gt;.</source>
          <target state="translated">如果作为TRUE值传​​递，第三个参数（$ binmode）将选择二进制模式。在二进制模式下，&amp;ldquo; \ n&amp;rdquo;的编码方式与其他任何不可打印的字符相同。这确保了解码器无论使用哪种行结束序列，都将以完全相同的字符串结尾。通常，最好对二进制数据使用base64编码。参见&lt;a href=&quot;base64&quot;&gt;MIME :: Base64&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="402137bf9c592f0ce8adeea3685dbc19201507dd" translate="yes" xml:space="preserve">
          <source>The third argument can be a hash reference with options. Note that all options are case-sensitive.</source>
          <target state="translated">第三个参数可以是一个带有选项的哈希引用。注意,所有的选项都是区分大小写的。</target>
        </trans-unit>
        <trans-unit id="d09df4868eb6859f97bcec11bc2fb80a75d17197" translate="yes" xml:space="preserve">
          <source>The third argument is an optional prefix. All files will be tucked away in the directory you specify as prefix. So if you have files 'a' and 'b' in your archive, and you specify 'foo' as prefix, they will be written to the archive as 'foo/a' and 'foo/b'.</source>
          <target state="translated">第三个参数是一个可选的前缀。所有的文件将被藏在您指定的前缀目录中。因此,如果您的存档中有文件'a'和'b',而您指定'foo'作为前缀,它们将以'foo/a'和'foo/b'的形式写入存档。</target>
        </trans-unit>
        <trans-unit id="f4fe54f58bf6b8a68158e2a28b4c6c3ebee0bf58" translate="yes" xml:space="preserve">
          <source>The third argument is set to TRUE if (and only if) the two operands have been swapped. Perl may do this to ensure that the first argument (&lt;code&gt;$self&lt;/code&gt; ) is an object implementing the overloaded operation, in line with general object calling conventions. For example, if &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are &lt;code&gt;Number&lt;/code&gt; s:</source>
          <target state="translated">当（且仅）两个操作数已交换时，第三个参数设置为TRUE。 Perl可以这样做，以确保第一个参数（ &lt;code&gt;$self&lt;/code&gt; ）是实现重载操作的对象，符合常规的对象调用约定。例如，如果 &lt;code&gt;$x&lt;/code&gt; 和 &lt;code&gt;$y&lt;/code&gt; 是 &lt;code&gt;Number&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b6927ece55a1584561056753f900c2e3751385e3" translate="yes" xml:space="preserve">
          <source>The third form of character class you can use in Perl regular expressions is the bracketed character class. In its simplest form, it lists the characters that may be matched, surrounded by square brackets, like this: &lt;code&gt;[aeiou]&lt;/code&gt; . This matches one of &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt; . Like the other character classes, exactly one character is matched.* To match a longer string consisting of characters mentioned in the character class, follow the character class with a &lt;a href=&quot;perlre#Quantifiers&quot;&gt;quantifier&lt;/a&gt;. For instance, &lt;code&gt;[aeiou]+&lt;/code&gt; matches one or more lowercase English vowels.</source>
          <target state="translated">您可以在Perl正则表达式中使用的字符类的第三种形式是方括号中的字符类。它以最简单的形式列出可能匹配的字符，并用方括号括起来，如下所示： &lt;code&gt;[aeiou]&lt;/code&gt; 。这匹配 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;e&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;o&lt;/code&gt; 或 &lt;code&gt;u&lt;/code&gt; 之一。与其他字符类一样，一个字符也将完全匹配。*要匹配由字符类中提到的字符组成的更长字符串，请在字符类后面加上一个&lt;a href=&quot;perlre#Quantifiers&quot;&gt;数量词&lt;/a&gt;。例如， &lt;code&gt;[aeiou]+&lt;/code&gt; 匹配一个或多个小写英语元音。</target>
        </trans-unit>
        <trans-unit id="98c965cda02550e370a5b37b87d94e4f8f16189d" translate="yes" xml:space="preserve">
          <source>The third option is to work around the problem by disabling the DB_File completely when build Perl by specifying -Ui_db to Configure, and then using the BerkeleyDB module from CPAN instead of DB_File. The BerkeleyDB works with Berkeley DB versions 2.* or greater.</source>
          <target state="translated">第三种方案是在构建Perl时,通过指定-Ui_db来配置,然后使用CPAN中的BerkeleyDB模块代替DB_File,完全禁用DB_File来解决这个问题。BerkeleyDB适用于Berkeley DB 2.*或更高版本。</target>
        </trans-unit>
        <trans-unit id="06ac2659f5a86781c045ab0079857269ceabc456" translate="yes" xml:space="preserve">
          <source>The third parameter is an integer flag, which tells &lt;code&gt;rmscopy&lt;/code&gt; how to handle timestamps. If it is &amp;lt; 0, none of the input file's timestamps are propagated to the output file. If it is &amp;gt; 0, then it is interpreted as a bitmask: if bit 0 (the LSB) is set, then timestamps other than the revision date are propagated; if bit 1 is set, the revision date is propagated. If the third parameter to &lt;code&gt;rmscopy&lt;/code&gt; is 0, then it behaves much like the DCL COPY command: if the name or type of the output file was explicitly specified, then no timestamps are propagated, but if they were taken implicitly from the input filespec, then all timestamps other than the revision date are propagated. If this parameter is not supplied, it defaults to 0.</source>
          <target state="translated">第三个参数是整数标志，它告诉 &lt;code&gt;rmscopy&lt;/code&gt; 如何处理时间戳。如果它小于0，则没有输入文件的时间戳传播到输出文件。如果它大于0，则将其解释为位掩码：如果设置了位0（LSB），则将传播除修订日期以外的时间戳；否则，将传播该时间戳。如果设置了位1，则会传播修订日期。如果 &lt;code&gt;rmscopy&lt;/code&gt; 的第三个参数为0，则其行为类似于DCL COPY命令：如果显式指定了输出文件的名称或类型，则不会传播任何时间戳，但是如果它们是从输入filespec中隐式获取的，则除修订日期以外的所有时间戳都会传播。如果未提供此参数，则默认为0。</target>
        </trans-unit>
        <trans-unit id="65eff2bc7c7605d4f858e4809838a551a55b2c9c" translate="yes" xml:space="preserve">
          <source>The third parameter of &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; determines whether AUTOLOAD lookup is performed if the given method is not present: non-zero means yes, look for AUTOLOAD; zero means no, don't look for AUTOLOAD. Calling &lt;code&gt;gv_fetchmethod&lt;/code&gt; is equivalent to calling &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; with a non-zero &lt;code&gt;autoload&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; 的第三个参数确定是否在不存在给定方法的情况下执行AUTOLOAD查找：非零表示是，查找AUTOLOAD；否则返回0。零表示不，不要寻找AUTOLOAD。调用 &lt;code&gt;gv_fetchmethod&lt;/code&gt; 等效于使用非零 &lt;code&gt;autoload&lt;/code&gt; 参数调用 &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04bad251a051beab258a1b64e282a2e8539b9769" translate="yes" xml:space="preserve">
          <source>The third, even more efficient way is to ape how it is done within the Perl guts:</source>
          <target state="translated">第三种更有效的方法是模仿Perl内部的做法。</target>
        </trans-unit>
        <trans-unit id="79c45ac3b3a9de2cee8656fb9dfb3aeb3d0a968d" translate="yes" xml:space="preserve">
          <source>The threaded Perl build works also on AIX 5.1 but the IBM Perl build (Perl v5.6.0) is not threaded on AIX 5.1.</source>
          <target state="translated">线程化的Perl构建在AIX 5.1上也能工作,但IBM的Perl构建(Perl v5.6.0)在AIX 5.1上不是线程化的。</target>
        </trans-unit>
        <trans-unit id="5c1bbb696ed6ae965a0f7d9f707a450102369948" translate="yes" xml:space="preserve">
          <source>The three dotted bitwise assignment operators (&lt;code&gt;&amp;amp;.=&lt;/code&gt;&lt;code&gt;|.=&lt;/code&gt;&lt;code&gt;^.=&lt;/code&gt; ) are new in Perl 5.22 and experimental. See &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.</source>
          <target state="translated">在Perl 5.22中，这三个点状的按位赋值运算符（ &lt;code&gt;&amp;amp;.=&lt;/code&gt; &lt;code&gt;|.=&lt;/code&gt; &lt;code&gt;^.=&lt;/code&gt; ）是新的，并且是实验性的。请参见&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;按位字符串运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="608f375aebf252abe9239c4f7b8a529aa2fe8363" translate="yes" xml:space="preserve">
          <source>The three features of key hashes,</source>
          <target state="translated">关键哈希的三个特点。</target>
        </trans-unit>
        <trans-unit id="062af9abb2e5d348e479446852d7c0c45c4b3f85" translate="yes" xml:space="preserve">
          <source>The three invocations of the subroutine all operate in sync. The semaphore, though, makes sure that only one thread is accessing the global variable at once.</source>
          <target state="translated">子程序的三次调用都是同步运行的。不过旗语可以确保一次只有一个线程访问全局变量。</target>
        </trans-unit>
        <trans-unit id="c211076f27a370be0b7366cd2b652219b05d68b1" translate="yes" xml:space="preserve">
          <source>The three predefined variables $DB_HASH, $DB_BTREE and $DB_RECNO are usually adequate for most applications. If you do need to create extra instances of these objects, constructors are available for each file type.</source>
          <target state="translated">三个预定义的变量$DB_HASH、$DB_BTREE和$DB_RECNO通常足以满足大多数应用程序的需要。如果你确实需要创建这些对象的额外实例,那么每个文件类型都有构造函数。</target>
        </trans-unit>
        <trans-unit id="e9c27515a2acd2e5fb4a7aba2f69ec1143808efd" translate="yes" xml:space="preserve">
          <source>The three principal virtues of a programmer are Laziness, Impatience, and Hubris. See the Camel Book for why.</source>
          <target state="translated">程序员的三大美德是懒惰、急躁和傲慢。原因请看《骆驼记》。</target>
        </trans-unit>
        <trans-unit id="8d0972bf14f371a7ca1ef1bcaa261257cc368602" translate="yes" xml:space="preserve">
          <source>The three variables, api_revision, api_version, and api_subversion, specify the version of the oldest perl binary compatible with the present perl. In a full version string such as</source>
          <target state="translated">api_revision、api_version和api_subversion这三个变量指定了与当前perl兼容的最老的perl二进制的版本。在一个完整的版本字符串中,如</target>
        </trans-unit>
        <trans-unit id="5f7adaa1232b94661eb586ac3b6e3dfed3cf89b3" translate="yes" xml:space="preserve">
          <source>The three warnings functions, &lt;code&gt;warnings::warn&lt;/code&gt; , &lt;code&gt;warnings::warnif&lt;/code&gt; and &lt;code&gt;warnings::enabled&lt;/code&gt; can optionally take an object reference in place of a category name. In this case the functions will use the class name of the object as the warnings category.</source>
          <target state="translated">这三个警告功能 &lt;code&gt;warnings::warn&lt;/code&gt; ， &lt;code&gt;warnings::warnif&lt;/code&gt; ，警告和 &lt;code&gt;warnings::enabled&lt;/code&gt; 可以启用对象引用来代替类别名称。在这种情况下，函数将使用对象的类名称作为警告类别。</target>
        </trans-unit>
        <trans-unit id="330a38aeb545f580c0244d785039ed36ba36d545" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl #121481]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl＃121481]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b68d73ad1b59ae384323f9df247206460ebd3566" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl #116487]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl＃116487]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8045076fdd60e6523f73b7c70511783c44a65e4" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl #119313]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl＃119313]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a16744b674df3a293c07c2c144ffeafe30d93a5" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl #119315]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl＃119315]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed1860908f3e196b681653f0d3c4015121aac114" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl #119317]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl＃119317]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c89e9b1dbbb9968b38d0d3719212d5f4f930d48c" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl #119437]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl＃119437]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a1e967726ae4e6415ad56477887e8f2fd56977f" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl #119451]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl＃119451]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f14154eef095f6d5ad9ed12b7ee560090c8240df" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl #119453]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl＃119453]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1140c9b87fc789061a9c67b7de5921f54ea0a0a7" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl #119455]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl＃119455]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6f307da7b6aa442d7423ca357f21550160d4bb6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl #120085]&lt;/a&gt;.</source>
          <target state="translated">此功能的票证是&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl＃120085]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b73333a2d87bb4bdcdf8360f5d380f719aac7b6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl #122947]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl＃122947]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25b9d0a99bd226d2ae0ff1a2acdc8ae410a969ec" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl #123630]&lt;/a&gt;.</source>
          <target state="translated">此功能的票证是&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl＃123630]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0769a8451d93e389be7960f58724061e03726c33" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl #123707]&lt;/a&gt;.</source>
          <target state="translated">此功能的票证是&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl＃123707]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4152408e418529cff3fa9a89a90fa02a4c71e407" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl #120162]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl＃120162]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="896c7c2fe4064687353e3dfbb412d579a6d56aea" translate="yes" xml:space="preserve">
          <source>The tie() function binds a variable to a class (package) that will provide the implementation for access methods for that variable. Once this magic has been performed, accessing a tied variable automatically triggers method calls in the proper class. The complexity of the class is hidden behind magic methods calls. The method names are in ALL CAPS, which is a convention that Perl uses to indicate that they're called implicitly rather than explicitly--just like the BEGIN() and END() functions.</source>
          <target state="translated">tie()函数将一个变量绑定到一个类(包)上,该类将为该变量的访问方法提供实现。一旦这个魔法被执行,访问绑定的变量就会自动触发适当类中的方法调用。类的复杂性就隐藏在魔法方法调用的背后。方法的名称是用大写的,这是Perl用来表示它们是隐式调用而不是显式调用的惯例--就像BEGIN()和END()函数一样。</target>
        </trans-unit>
        <trans-unit id="2ae79bd4ddb1c94445f10f56348d3008d5501006" translate="yes" xml:space="preserve">
          <source>The time at which the program began running, in seconds since the epoch (beginning of 1970). The values returned by the &lt;b&gt;-M&lt;/b&gt;, &lt;b&gt;-A&lt;/b&gt;, and &lt;b&gt;-C&lt;/b&gt; filetests are based on this value.</source>
          <target state="translated">程序开始运行的时间，自该时间段（1970年开始）以来的秒数。&lt;b&gt;-M&lt;/b&gt;，&lt;b&gt;-A&lt;/b&gt;和&lt;b&gt;-C文件&lt;/b&gt;测试返回的值基于该值。</target>
        </trans-unit>
        <trans-unit id="850e579e5bd369cd341c43e0bd12ab77ec41d87f" translate="yes" xml:space="preserve">
          <source>The time has been cut in half, which is a respectable speed improvement by any standard. Naturally, it is important to check the output is consistent with the first program run, this is where the Unix system &lt;code&gt;cksum&lt;/code&gt; utility comes in.</source>
          <target state="translated">时间缩短了一半，从任何标准来看，这都是相当可观的速度改进。自然地，检查输出是否与第一个程序运行一致很重要，这是Unix系统 &lt;code&gt;cksum&lt;/code&gt; 实用程序出现的地方。</target>
        </trans-unit>
        <trans-unit id="b516aafa3dbd5e537bbd8654d3807aa023edea27" translate="yes" xml:space="preserve">
          <source>The time it takes varies depending on how fast your machine is and how large your encoding is. Unless you are working on something big like euc-tw, it won't take too long.</source>
          <target state="translated">所需的时间取决于你的机器有多快和你的编码有多大。除非你的工作是像euc-tw这样大的东西,否则不会花太多时间。</target>
        </trans-unit>
        <trans-unit id="e4a773ca459be08fb127884cfab114e154432eff" translate="yes" xml:space="preserve">
          <source>The time of the null loop (a loop with the same number of rounds but empty loop body) is subtracted from the time of the real loop.</source>
          <target state="translated">空循环(循环次数相同但循环体为空的循环)的时间减去实循环的时间。</target>
        </trans-unit>
        <trans-unit id="b6a2ce725119cbf8ac82ed9014cf15ca7bd90e68" translate="yes" xml:space="preserve">
          <source>The time returned also includes the process times of the terminated child processes for which wait() has been executed. This value is somewhat like the second value returned by the times() of core Perl, but not necessarily identical. Note that due to backward compatibility limitations the returned value may wrap around at about 2147 seconds or at about 36 minutes.</source>
          <target state="translated">返回的时间还包括被执行了wait()的终止子进程的进程时间。这个值有点像核心Perl的 times()返回的第二个值,但不一定相同。请注意,由于向后兼容性的限制,返回的值可能会在2147秒左右或者36分钟左右绕过。</target>
        </trans-unit>
        <trans-unit id="0d1626bdb98ca3cc408f22b06c2161e7fe233ac0" translate="yes" xml:space="preserve">
          <source>The time when Perl is actually doing what your code says to do, as opposed to the earlier period of time when it was trying to figure out whether what you said made any sense whatsoever, which is &lt;b&gt;compile time&lt;/b&gt;.</source>
          <target state="translated">Perl实际上正在执行您的代码所说的事情的时间，而不是之前它试图弄清楚您所说的内容是否有意义的&lt;b&gt;时间&lt;/b&gt;，这就是&lt;b&gt;编译时间&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="84f0e5475a9de884cf21f0b5087fb4edeef00da2" translate="yes" xml:space="preserve">
          <source>The time when Perl is trying to make sense of your code, as opposed to when it thinks it knows what your code means and is merely trying to do what it thinks your code says to do, which is &lt;b&gt;runtime&lt;/b&gt;.</source>
          <target state="translated">Perl尝试理解您的代码的时间，而不是它认为自己知道代码的含义的时间，而仅仅是尝试执行代码认为要执行的操作，即&lt;b&gt;runtime&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2e4f067abc3cb37a82d1ce3a350c4ed5ac55d47a" translate="yes" xml:space="preserve">
          <source>The timeout in the [PKG] can be specified as zero to effect a &quot;poll&quot;, but you shouldn't do that because a new IO::Select object will be created behind the scenes just to do the single poll. This is horrendously inefficient. Use rather true select() with a zero timeout on the handle, or non-blocking IO.</source>
          <target state="translated">PKG]中的超时时间可以指定为零来实现 &quot;轮询&quot;,但你不应该这样做,因为在幕后会创建一个新的IO::Select对象来进行单次轮询。这是非常低效的。使用相当真实的select(),句柄超时为零,或者使用非阻塞IO。</target>
        </trans-unit>
        <trans-unit id="538790731acb7259f937f6ff4a2bbf78b24054c5" translate="yes" xml:space="preserve">
          <source>The timeout may be a number of seconds relative to the current time (e.g., 5 seconds from when the call is made), or may be an absolute timeout in</source>
          <target state="translated">超时可以是一个相对于当前时间的秒数(例如,从拨打电话时起5秒),也可以是一个绝对的超时,以</target>
        </trans-unit>
        <trans-unit id="fd8fbd616a78a90070ef718270fee035f94b0bad" translate="yes" xml:space="preserve">
          <source>The timing is done using time(3) and times(3).</source>
          <target state="translated">利用时间(3)和次数(3)进行计时。</target>
        </trans-unit>
        <trans-unit id="bfc27e045cf8c436a59465851692c98d92afa4eb" translate="yes" xml:space="preserve">
          <source>The title of this section indicates the second problem you may run into sooner or later when you pack C structures. If the function you intend to call expects a, say, &lt;code&gt;void *&lt;/code&gt; value, you</source>
          <target state="translated">本节的标题指示打包C结构时迟早会遇到的第二个问题。如果您打算调用的函数期望一个 &lt;code&gt;void *&lt;/code&gt; 值，则您</target>
        </trans-unit>
        <trans-unit id="3aeea9af350571abf85e25c4751ee40203e9d46b" translate="yes" xml:space="preserve">
          <source>The top level documentation about Perl regular expressions is found in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;perlre&quot;&gt;perlre中&lt;/a&gt;可以找到有关Perl正则表达式的顶级文档。</target>
        </trans-unit>
        <trans-unit id="3205e679e2f0bb1ae1342389bae87dd20bedcfd5" translate="yes" xml:space="preserve">
          <source>The top node in the tree is &lt;code&gt;[ 'Document', \%attributes,
&lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</source>
          <target state="translated">树的顶部节点是 &lt;code&gt;[ 'Document', \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37995bec6dd9b8643c48818f0b81e11787b543cc" translate="yes" xml:space="preserve">
          <source>The total elapsed times the test took to run, in seconds from the epoch..</source>
          <target state="translated">测试运行所需的总时间,从纪元开始,以秒为单位。</target>
        </trans-unit>
        <trans-unit id="1c62e4162c4c89e197d0fdd84f0911b0a91d8950" translate="yes" xml:space="preserve">
          <source>The total number of comparisons is equal to the sum of the squares of the number of entries in each bucket. For a random hash of &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt; keys into &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt; buckets, the expected value is:</source>
          <target state="translated">比较的总数等于每个存储桶中条目数的平方和。对于 &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt;个存储桶中 &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt;个键的随机散列，期望值为：</target>
        </trans-unit>
        <trans-unit id="d4c2502de58f3e2d86d4adebf37cdce84d5b9f9b" translate="yes" xml:space="preserve">
          <source>The total time it took for the test to run, in seconds. If &lt;code&gt;Time::HiRes&lt;/code&gt; is available, it will have finer granularity.</source>
          <target state="translated">测试运行的总时间（以秒为单位）。如果 &lt;code&gt;Time::HiRes&lt;/code&gt; 可用，它将具有更精细的粒度。</target>
        </trans-unit>
        <trans-unit id="1b3a565887dd69be936761de4d497f57b4dfa910" translate="yes" xml:space="preserve">
          <source>The tradeoff is that one needs to calculate the number of return values in advance (though overextending the stack will not typically hurt anything but memory consumption).</source>
          <target state="translated">权衡的办法是,需要提前计算返回值的数量(虽然过度扩展堆栈通常除了内存消耗外不会有任何伤害)。</target>
        </trans-unit>
        <trans-unit id="02dc2cb0935e5c48d56deb5ed1a283c1991198d6" translate="yes" xml:space="preserve">
          <source>The traditional &quot;0&quot;, &quot;1&quot;, and &quot;2&quot; MODEs are implemented with different numeric values on some systems. The flags exported by &lt;code&gt;Fcntl&lt;/code&gt; (O_RDONLY, O_WRONLY, O_RDWR) should work everywhere though. (Mac OS, OS/390)</source>
          <target state="translated">在某些系统上，传统的&amp;ldquo; 0&amp;rdquo;，&amp;ldquo; 1&amp;rdquo;和&amp;ldquo; 2&amp;rdquo; MODE是用不同的数值实现的。但是，由 &lt;code&gt;Fcntl&lt;/code&gt; 导出的标志（O_RDONLY，O_WRONLY，O_RDWR）应该在任何地方都有效。（Mac OS，OS / 390）</target>
        </trans-unit>
        <trans-unit id="edec44b15608ad1c090140c537934ec3a77ab750" translate="yes" xml:space="preserve">
          <source>The traditional one has it followed by a name enclosed in braces, meaning the character (or sequence of characters) given by that name. Thus &lt;code&gt;\N{ASTERISK}&lt;/code&gt; is another way of writing &lt;code&gt;*&lt;/code&gt; , valid in both double-quoted strings and regular expression patterns. In patterns, it doesn't have the meaning an unescaped &lt;code&gt;*&lt;/code&gt; does.</source>
          <target state="translated">传统的名称后跟一个用大括号括起来的名称，意思是该名称给出的字符（或字符序列）。因此 &lt;code&gt;\N{ASTERISK}&lt;/code&gt; 是另一种写 &lt;code&gt;*&lt;/code&gt; 的方式，在双引号字符串和正则表达式模式中均有效。在模式中，它没有未转义 &lt;code&gt;*&lt;/code&gt; 的含义。</target>
        </trans-unit>
        <trans-unit id="cf50a6157f8b6c5d609d11261410355088e7eb85" translate="yes" xml:space="preserve">
          <source>The transitional compilation environment is obtained with the following compiler and linker flags:</source>
          <target state="translated">过渡性编译环境是通过以下编译器和链接器标志获得的。</target>
        </trans-unit>
        <trans-unit id="7383cd567e6253ea6210a9db604e2fa9e5e4632a" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">音译运算符。与 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 相同。请参阅&lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlop中的类似于引用的运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e96d614d57d8ccc80741217a9adfc3a85457d070" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">音译运算符。与 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 相同。请参阅&lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlop中的类似于引用的运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4178c59a00064af8220ead2c08c98e1676579390" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">音译运算符。与 &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 相同。请参阅&lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;perlop中的类似于引用的运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ea9a92782ae9df97b0632f112e4b5544a1a9028b" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">音译运算符。与 &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 相同。请参阅&lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;perlop中的类似于引用的运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75ab4f7335b924ba00dcfa6684ad7ab9b56afe36" translate="yes" xml:space="preserve">
          <source>The trap and untrap methods are synonyms for deny and permit respectfully.</source>
          <target state="translated">陷阱法和解陷阱法是拒绝和允许的同义词,恭敬地。</target>
        </trans-unit>
        <trans-unit id="79edf12630cd230667f23adf7c1c02295b7aaf31" translate="yes" xml:space="preserve">
          <source>The treatment of more than one physical &lt;b&gt;line&lt;/b&gt; as a single logical line. &lt;b&gt;Makefile&lt;/b&gt; lines are continued by putting a backslash before the &lt;b&gt;newline&lt;/b&gt;. Mail headers, as defined by RFC 822, are continued by putting a space or tab</source>
          <target state="translated">将多条物理&lt;b&gt;线&lt;/b&gt;视为一条逻辑线。通过在&lt;b&gt;换行符&lt;/b&gt;前加反斜杠来继续&lt;b&gt;Makefile &lt;/b&gt;&lt;b&gt;行&lt;/b&gt;。RFC 822定义的邮件标题通过放置空格或制表符来继续</target>
        </trans-unit>
        <trans-unit id="416e0656b5d6eca80f77db061d8df87eef2d675e" translate="yes" xml:space="preserve">
          <source>The tree is created by the compiler while</source>
          <target state="translated">树是由编译器创建的,而</target>
        </trans-unit>
        <trans-unit id="751a409fc8b6dd72130af7dcf107013d6a066c03" translate="yes" xml:space="preserve">
          <source>The trick in this task is to find the directory. Before your script does anything else (such as a &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;), you can get the current working directory with the &lt;code&gt;Cwd&lt;/code&gt; module, which comes with Perl:</source>
          <target state="translated">此任务中的技巧是找到目录。在脚本执行其他任何操作（例如 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; ）之前，您可以使用Perl随附的 &lt;code&gt;Cwd&lt;/code&gt; 模块获取当前的工作目录：</target>
        </trans-unit>
        <trans-unit id="f5f4f31af96f44cb48b6403e792709ecc6d53b8e" translate="yes" xml:space="preserve">
          <source>The trick is that if you read a &lt;code&gt;BOM&lt;/code&gt; , you will know the byte order, since if it was written on a big-endian platform, you will read the bytes &lt;code&gt;0xFE 0xFF&lt;/code&gt;, but if it was written on a little-endian platform, you will read the bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt;. (And if the originating platform was writing in ASCII platform UTF-8, you will read the bytes &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt;.)</source>
          <target state="translated">诀窍在于，如果您阅读 &lt;code&gt;BOM&lt;/code&gt; ，您将知道字节顺序，因为如果它是在big-endian平台上编写的，您将读取字节 &lt;code&gt;0xFE 0xFF&lt;/code&gt; ，但是，如果它是在little-endian平台上编写的，则您可以将读取字节 &lt;code&gt;0xFF 0xFE&lt;/code&gt; 。（如果原始平台使用ASCII平台UTF-8编写，则将读取字节 &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="98f1375fe9d48b636ba837bd6c5d9b3f6fb48c48" translate="yes" xml:space="preserve">
          <source>The trick is to give a special parameter to the Configure shell script when running it on AIX:</source>
          <target state="translated">诀窍是在AIX上运行Configure shell脚本时,给它一个特殊参数。</target>
        </trans-unit>
        <trans-unit id="0a8f7f70cdf2316a2ca5d5174affe77306a16af9" translate="yes" xml:space="preserve">
          <source>The trick to this problem is avoiding accidental autovivification. If you want to check three keys deep, you might na&amp;iuml;vely try this:</source>
          <target state="translated">解决此问题的技巧是避免意外的自动生存。如果您想深入检查三个键，可以天真的尝试一下：</target>
        </trans-unit>
        <trans-unit id="8f023c48c1c4fd330a5e021a4a36ff097b3f2c34" translate="yes" xml:space="preserve">
          <source>The tricky thing to remember is that the first parameter is true if you want to</source>
          <target state="translated">要记住的是,第一个参数为真,如果你想让</target>
        </trans-unit>
        <trans-unit id="0358acd687c89e6aeedb15fd79329af2ac79f19b" translate="yes" xml:space="preserve">
          <source>The trigonometric constant &lt;b&gt;pi&lt;/b&gt; and some of handy multiples of it are also defined.</source>
          <target state="translated">还定义了三角常数&lt;b&gt;pi&lt;/b&gt;及其一些方便的倍数。</target>
        </trans-unit>
        <trans-unit id="46116b5afa30e36e5dfcca4ac124810d45929096" translate="yes" xml:space="preserve">
          <source>The trust in item 2 is transitive. If A trusts B, and B trusts C, then A trusts C. So if you do not override &lt;code&gt;@ISA&lt;/code&gt; with &lt;code&gt;@CARP_NOT&lt;/code&gt; , then this trust relationship is identical to, &quot;inherits from&quot;.</source>
          <target state="translated">对项目2的信任是可传递的。如果A信任B，B信任C，则A信任C。因此，如果您不使用 &lt;code&gt;@CARP_NOT&lt;/code&gt; 覆盖 &lt;code&gt;@ISA&lt;/code&gt; ，则此信任关系与&amp;ldquo;继承自&amp;rdquo;相同。</target>
        </trans-unit>
        <trans-unit id="761c5f5b8a8444418e2d9bdc4d8cca16ccc65180" translate="yes" xml:space="preserve">
          <source>The truth of the matter is that perl's regular expressions these days are much more complex than this kind of structure, but visualising it this way can help when trying to get your bearings, and it matches the current implementation pretty closely.</source>
          <target state="translated">事实上,现在的perl的正则表达式要比这种结构复杂得多,但这样可视化可以帮助你在试图了解自己的方向时,它与当前的实现非常吻合。</target>
        </trans-unit>
        <trans-unit id="df6a9452c74fa01c8c98846cb474f3c173568489" translate="yes" xml:space="preserve">
          <source>The tty driver is put into raw mode and restored using an operating system specific command, in UNIX-like environments &lt;code&gt;stty&lt;/code&gt; .</source>
          <target state="translated">在类似UNIX的环境 &lt;code&gt;stty&lt;/code&gt; 中，将tty驱动程序置于原始模式并使用操作系统特定的命令进行还原。</target>
        </trans-unit>
        <trans-unit id="99fb31ac14610942d5eec87bdc1a87d0b036e971" translate="yes" xml:space="preserve">
          <source>The tutorial started in the Llama continues in the Alpaca, which introduces the intermediate features of references, data structures, object-oriented programming, and modules:</source>
          <target state="translated">在Llama中开始的教程在Alpaca中继续,介绍了引用、数据结构、面向对象编程和模块的中间特性。</target>
        </trans-unit>
        <trans-unit id="6ef070521ff5826ca5eb1f98285ab64a027e2793" translate="yes" xml:space="preserve">
          <source>The two additional lines request from perl to catch various common problems in your code. They check different things so you need both. A potential problem caught by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; will cause your code to stop immediately when it is encountered, while &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; will merely give a warning (like the command-line switch &lt;b&gt;-w&lt;/b&gt;) and let your code run. To read more about them check their respective manual pages at &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">来自perl的另外两行要求捕获代码中的各种常见问题。他们检查不同的事物，因此您同时需要两者。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; 潜在问题； &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; 时，将导致您的代码在遇到时立即停止；只会发出警告（如命令行开关&lt;b&gt;-w&lt;/b&gt;），并让您的代码运行。要了解更多关于他们在检查各自的手册页&lt;a href=&quot;strict&quot;&gt;严格&lt;/a&gt;和&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba2dc4945c85043455423fb1b5a39f8aa3d6b28f" translate="yes" xml:space="preserve">
          <source>The two argument form of add_bits() will add the first $nbits bits from $data. For the last potentially partial byte only the high order &lt;code&gt;$nbits % 8&lt;/code&gt; bits are used. If $nbits is greater than &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; , then this method would do the same as &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; .</source>
          <target state="translated">add_bits（）的两个参数形式将添加$ data中的前$ nbits位。对于最后一个可能的部分字节，仅使用高位 &lt;code&gt;$nbits % 8&lt;/code&gt; 位。如果$ nbits大于 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; ，则此方法将与 &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="edfc68f9b85a8c57ac6b419328c423790a72a43e" translate="yes" xml:space="preserve">
          <source>The two arrays &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT&lt;/code&gt; are very important. The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of other packages in which to search for methods (or subroutines) that do not exist in the current package. This is usually only important for object-oriented extensions (which we will talk about much later), and so usually doesn't need to be modified.</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; 和 &lt;code&gt;@EXPORT&lt;/code&gt; 这两个数组非常重要。的 &lt;code&gt;@ISA&lt;/code&gt; 数组包含在其中搜索用于不在当前包中存在的方法（或子程序）的其它包的列表。这通常仅对面向对象的扩展很重要（我们将在后面讨论），因此通常不需要进行修改。</target>
        </trans-unit>
        <trans-unit id="1bc049a18027fa1202df37bcfed013d26326a12f" translate="yes" xml:space="preserve">
          <source>The two control characters ^D and ^Z, and the tokens __END__ and __DATA__ may be used to indicate the logical end of the script before the actual end of file. Any following text is ignored.</source>
          <target state="translated">两个控制字符^D和^Z,以及标记__END__和__DATA__可以用来表示脚本在文件实际结束之前的逻辑结束。任何下面的文字都会被忽略。</target>
        </trans-unit>
        <trans-unit id="34dcc268df0f1b7f78c17ae23e0cef09454c6cdc" translate="yes" xml:space="preserve">
          <source>The two entry points are &lt;code&gt;re_intuit_start()&lt;/code&gt; and &lt;code&gt;pregexec()&lt;/code&gt; . These routines have a somewhat incestuous relationship with overlap between their functions, and &lt;code&gt;pregexec()&lt;/code&gt; may even call &lt;code&gt;re_intuit_start()&lt;/code&gt; on its own. Nevertheless other parts of the perl source code may call into either, or both.</source>
          <target state="translated">这两个入口点是 &lt;code&gt;re_intuit_start()&lt;/code&gt; 和 &lt;code&gt;pregexec()&lt;/code&gt; 。这些例程之间存在某种乱伦的关系，它们的函数之间存在重叠，并且 &lt;code&gt;pregexec()&lt;/code&gt; 甚至可以自己调用 &lt;code&gt;re_intuit_start()&lt;/code&gt; 。但是，perl源代码的其他部分可能会调用其中之一，也可能两者都调用。</target>
        </trans-unit>
        <trans-unit id="8d4c95b48b6a1668825ba4572ce44483ca77dc51" translate="yes" xml:space="preserve">
          <source>The two filenames can also be given separately in full as &lt;code&gt;$dirfile&lt;/code&gt; and &lt;code&gt;$pagfilename&lt;/code&gt; . This suits for two files without &quot;.dir&quot; and &quot;.pag&quot; extensions, perhaps for example two files from &lt;a href=&quot;file/temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">这两个文件名也可以分别以 &lt;code&gt;$dirfile&lt;/code&gt; 和 &lt;code&gt;$pagfilename&lt;/code&gt; 。这适合两个没有扩展名&amp;ldquo; .dir&amp;rdquo;和&amp;ldquo; .pag&amp;rdquo;的文件，例如，&lt;a href=&quot;file/temp&quot;&gt;File :: Temp中的&lt;/a&gt;两个文件。</target>
        </trans-unit>
        <trans-unit id="2f1774e1f537dc56f588c1be426bca15556e7438" translate="yes" xml:space="preserve">
          <source>The two first forms are simply syntactic sugar which automatically load the right module on first use. The second form allow you to use algorithm names which contains letters which are not legal perl identifiers, e.g. &quot;SHA-1&quot;. If no implementation for the given algorithm can be found, then an exception is raised.</source>
          <target state="translated">前两种形式是简单的语法糖,第一次使用时自动加载正确的模块。第二种形式允许你使用包含字母的算法名,这些字母不是合法的perl标识符,例如 &quot;SHA-1&quot;。如果找不到给定算法的实现,那么就会引发一个异常。</target>
        </trans-unit>
        <trans-unit id="c95a4925ad583d0cdab2da763605ba8a5577a6cd" translate="yes" xml:space="preserve">
          <source>The two main uses for this are to switch back to using the package sub inside an inner scope:</source>
          <target state="translated">这两个主要用途是切换回内部作用域内使用包子。</target>
        </trans-unit>
        <trans-unit id="9fdb893929b74d583f916a04691865e61a0c8195" translate="yes" xml:space="preserve">
          <source>The two most common mistakes made in constructing something like an array of arrays is either accidentally counting the number of elements or else taking a reference to the same memory location repeatedly. Here's the case where you just get the count instead of a nested array:</source>
          <target state="translated">在构造数组这样的东西时,最常犯的两个错误是:要么是不小心数到了元素的数量,要么是重复地获取对同一个内存位置的引用。这里的情况是,你只得到计数而不是嵌套数组。</target>
        </trans-unit>
        <trans-unit id="9ef613531270a3be0f714b7b0c6603ad457c5c67" translate="yes" xml:space="preserve">
          <source>The two primary use cases supported by &lt;a href=&quot;harness&quot;&gt;TAP::Harness&lt;/a&gt; for plugins are</source>
          <target state="translated">&lt;a href=&quot;harness&quot;&gt;TAP :: Harness&lt;/a&gt;插件支持的两个主要用例是</target>
        </trans-unit>
        <trans-unit id="49899df9616cd2a3f123de74937bc969a55089e7" translate="yes" xml:space="preserve">
          <source>The two quickest fixes are either to render Perl silent about any locale inconsistencies or to run Perl under the default locale &quot;C&quot;.</source>
          <target state="translated">最快的两个修复方法是,让Perl对任何locale的不一致保持沉默,或者在默认locale &quot;C &quot;下运行Perl。</target>
        </trans-unit>
        <trans-unit id="1d29057aa8b200a921ab9b4c9f2a8fac7349c60a" translate="yes" xml:space="preserve">
          <source>The two sets of barcharts give stats and a visual indication of performance of the hash.</source>
          <target state="translated">这两组barch图给出了统计数字,并直观地显示了哈希的性能。</target>
        </trans-unit>
        <trans-unit id="ea356fe6678cb16635414403ae22dc70cf7c6eb2" translate="yes" xml:space="preserve">
          <source>The two statements:</source>
          <target state="translated">这两种说法。</target>
        </trans-unit>
        <trans-unit id="2e850f7b70f56596c655ae357f7738793fa85127" translate="yes" xml:space="preserve">
          <source>The type of the constant (</source>
          <target state="translated">常数的类型(</target>
        </trans-unit>
        <trans-unit id="207d3c0594c531831415850568f05351cc4335f1" translate="yes" xml:space="preserve">
          <source>The type of the third parameter is arbitrary as far as the typemap is concerned. It just has to be in line with the declared variable.</source>
          <target state="translated">第三个参数的类型就类型图而言是任意的。它只需与声明的变量一致即可。</target>
        </trans-unit>
        <trans-unit id="3a8fb2c5d9024ab64dd8a1b418b0785f1b45c2d4" translate="yes" xml:space="preserve">
          <source>The type-to-match is whitewashed (except for commas, which have no whitespace before them, and multiple &lt;code&gt;*&lt;/code&gt; which have no whitespace between them).</source>
          <target state="translated">匹配项的类型被粉刷（除了逗号，逗号之前没有空格，而多个 &lt;code&gt;*&lt;/code&gt; 之间没有空格）。</target>
        </trans-unit>
        <trans-unit id="065bb709681867146d38619409b0c4858958cd7d" translate="yes" xml:space="preserve">
          <source>The typemap checks that a scalar reference is passed from perl to XS.</source>
          <target state="translated">类型图检查标量引用是否从perl传递到XS。</target>
        </trans-unit>
        <trans-unit id="1aca61f72e9539e566a25a6f843796b117e0a616" translate="yes" xml:space="preserve">
          <source>The types are:</source>
          <target state="translated">这些类型是:</target>
        </trans-unit>
        <trans-unit id="b8218b5c6abbddadba7d9cdb24a7712b0e31ed41" translate="yes" xml:space="preserve">
          <source>The typical C compiler&amp;rsquo;s first pass, which processes lines beginning with &lt;code&gt;#&lt;/code&gt; for conditional compilation and macro definition, and does various manipulations of the program text based on the current definitions. Also known as</source>
          <target state="translated">典型的C编译器的第一遍，处理以 &lt;code&gt;#&lt;/code&gt; 开头的行以进行条件编译和宏定义，并根据当前定义对程序文本进行各种操作。也称为</target>
        </trans-unit>
        <trans-unit id="c3f6853138e86a46a65a1f12c8ebb77c9ad23c63" translate="yes" xml:space="preserve">
          <source>The typical approach uses the Perl debugger, described in the</source>
          <target state="translated">典型的方法是使用Perl调试器,描述于</target>
        </trans-unit>
        <trans-unit id="8d039cb4fff50dcf102a20e5a834fd5dcb92db29" translate="yes" xml:space="preserve">
          <source>The typical input/output flow of a program is:</source>
          <target state="translated">一个程序的典型输入/输出流程是。</target>
        </trans-unit>
        <trans-unit id="bb341dafe72dfd453b6e963169c19a0e3677ecc8" translate="yes" xml:space="preserve">
          <source>The typical interactions between pieces of data are best represented by operators.</source>
          <target state="translated">典型的数据之间的相互作用最好用运算符来表示。</target>
        </trans-unit>
        <trans-unit id="37bcc82c39e22721104650473d90114a9246bb63" translate="yes" xml:space="preserve">
          <source>The typical usage case is for private modules or working copies of projects from remote repositories on the local disk.</source>
          <target state="translated">典型的使用情况是用于本地磁盘上的私有模块或远程资源库中的项目工作副本。</target>
        </trans-unit>
        <trans-unit id="a4e2f09da65ffeb5dd41665671b5f400f853e79b" translate="yes" xml:space="preserve">
          <source>The typical usage is from within a Makefile generated by &lt;a href=&quot;makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;. So under normal circumstances you won't have to deal with this module directly.</source>
          <target state="translated">典型用法是从&lt;a href=&quot;makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;生成的Makefile中。因此，在正常情况下，您不必直接处理此模块。</target>
        </trans-unit>
        <trans-unit id="b839dd64fd51c7239737d976be2aaf701494cef3" translate="yes" xml:space="preserve">
          <source>The typical way to use an &lt;code&gt;EVERY&lt;/code&gt; call is to wrap it in another base method, that all classes inherit. For example, to ensure that every destructor an object inherits is actually called (as opposed to just the left-most-depth-first-est one):</source>
          <target state="translated">使用 &lt;code&gt;EVERY&lt;/code&gt; 调用的典型方法是将其包装在所有类都继承的另一个基本方法中。例如，要确保实际调用对象所继承的每个析构函数（而不是仅从最左深度第一开始）：</target>
        </trans-unit>
        <trans-unit id="d078360c456578fa6c56aaca3475f63295e459b1" translate="yes" xml:space="preserve">
          <source>The uncolor() function and support for ANSI_COLORS_DISABLED were added in Term::ANSIColor 1.04, included in Perl 5.8.0.</source>
          <target state="translated">uncolor()函数和对ANSI_COLORS_DISABLED的支持是在Term::ANSIColor 1.04中添加的,包含在Perl 5.8.0中。</target>
        </trans-unit>
        <trans-unit id="d2846292c4ece0df1cdbdb746e73838c0174b8ea" translate="yes" xml:space="preserve">
          <source>The underlying behaviour of &lt;code&gt;%+&lt;/code&gt; is provided by the &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; 的基本行为由&lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt;模块提供。</target>
        </trans-unit>
        <trans-unit id="cc10f153a716bc66afaf3456e02a5c9183a04515" translate="yes" xml:space="preserve">
          <source>The underlying parser object. This is useful if you need the full information for the test program.</source>
          <target state="translated">底层解析器对象。如果你需要测试程序的完整信息,这很有用。</target>
        </trans-unit>
        <trans-unit id="b7d8dde972f17bdda4b61ab86196bc96064679a1" translate="yes" xml:space="preserve">
          <source>The undump program was an ancient attempt to speed up Perl program by storing the already-compiled form to disk. This is no longer a viable option, as it only worked on a few architectures, and wasn't a good solution anyway.</source>
          <target state="translated">undump程序是一个古老的尝试,通过将已经编译好的形式存储到磁盘上来加快Perl程序的速度。这已经不是一个可行的方案了,因为它只在少数架构上有效,而且无论如何也不是一个好的解决方案。</target>
        </trans-unit>
        <trans-unit id="be8a46bbcbbd519aa2c58d3aea183c9d8f4c685d" translate="yes" xml:space="preserve">
          <source>The unfortunate similarity of this function's name to that of Perl's &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; operator is strictly coincidental. This function works from the left; &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; works from the right.</source>
          <target state="translated">不幸的是，此函数的名称与Perl的 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 运算符的相似之处完全是巧合。此功能从左开始工作； &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 从右边开始。</target>
        </trans-unit>
        <trans-unit id="ca3db9d0f0db6a082e0aea1f0a6be142ef87df51" translate="yes" xml:space="preserve">
          <source>The untie Gotcha</source>
          <target state="translated">解开绳索,抓住你</target>
        </trans-unit>
        <trans-unit id="12164923a1b041bdc762cdb62bbbc7fb759ea434" translate="yes" xml:space="preserve">
          <source>The untie() Gotcha</source>
          <target state="translated">解开()的疑难杂症</target>
        </trans-unit>
        <trans-unit id="50d65961a427d2a64bc08d49e4d87b52f498e907" translate="yes" xml:space="preserve">
          <source>The uppercase variants (&lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; , and &lt;code&gt;\V&lt;/code&gt; ) are character classes that match, respectively, any character that isn't a word character, digit, whitespace, horizontal whitespace, or vertical whitespace.</source>
          <target state="translated">大写变体（ &lt;code&gt;\W&lt;/code&gt; ， &lt;code&gt;\D&lt;/code&gt; ， &lt;code&gt;\S&lt;/code&gt; ， &lt;code&gt;\H&lt;/code&gt; 和 &lt;code&gt;\V&lt;/code&gt; ）是分别与不是单词字符，数字，空格，水平空格或垂直空格的任何字符匹配的字符类。</target>
        </trans-unit>
        <trans-unit id="6a360f037634db2d1e1b847c01d4ff39f2e82c73" translate="yes" xml:space="preserve">
          <source>The uri you passed to the constructor</source>
          <target state="translated">你传递给构造函数的URLI</target>
        </trans-unit>
        <trans-unit id="7175c322baef80b04d65002673bad08dde1a5590" translate="yes" xml:space="preserve">
          <source>The urllist parameter has CD-ROM support</source>
          <target state="translated">urllist参数支持CD-ROM。</target>
        </trans-unit>
        <trans-unit id="0e71ac825c7f966ddb9142eb457a1ad27b050118" translate="yes" xml:space="preserve">
          <source>The usage is for a canned filter is:</source>
          <target state="translated">罐装过滤器的用法是。</target>
        </trans-unit>
        <trans-unit id="826c70de8255c56bc69c42539c313e47e2f05832" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;//g&lt;/code&gt; is shown in the following example. Suppose we have a string that consists of words separated by spaces. If we know how many words there are in advance, we could extract the words using groupings:</source>
          <target state="translated">下例显示了 &lt;code&gt;//g&lt;/code&gt; 的用法。假设我们有一个由空格分隔的单词组成的字符串。如果我们事先知道有多少个单词，可以使用分组来提取单词：</target>
        </trans-unit>
        <trans-unit id="832a5d88d8f5443e11412058babdb54340f702ac" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; is discouraged, as it can result in exceptions not being thrown if you</source>
          <target state="translated">不鼓励使用 &lt;code&gt;:void&lt;/code&gt; ，因为如果您使用它，可能会导致未引发异常</target>
        </trans-unit>
        <trans-unit id="0ce5a82961769245d2e039e505d826cd3e904ef4" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; with Fatal is discouraged.</source>
          <target state="translated">不建议将 &lt;code&gt;:void&lt;/code&gt; 与Fatal一起使用。</target>
        </trans-unit>
        <trans-unit id="dac4651068bc57e4e25c4b9a7bdd7a073791862a" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;=&amp;gt;&lt;/code&gt; above provides necessary quoting of &lt;code&gt;MODULE&lt;/code&gt; . If you don't use the fat comma (eg you don't have any ARGUMENTS), then you'll need to quote the MODULE.</source>
          <target state="translated">上面 &lt;code&gt;=&amp;gt;&lt;/code&gt; 的使用提供了 &lt;code&gt;MODULE&lt;/code&gt; 的必要引用。如果您不使用粗逗号（例如，您没有任何参数），则需要引用MODULE。</target>
        </trans-unit>
        <trans-unit id="9b512e8508712c1167d958e6e4ad448ccc7e030f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\Q&lt;/code&gt; causes the &amp;lt;.&amp;gt; in the regex to be treated as a regular character, so that &lt;code&gt;P.&lt;/code&gt; matches a &lt;code&gt;P&lt;/code&gt; followed by a dot.</source>
          <target state="translated">使用 &lt;code&gt;\Q&lt;/code&gt; 会将正则表达式中的&amp;lt;。&amp;gt;视为常规字符，因此 &lt;code&gt;P.&lt;/code&gt; 匹配一个 &lt;code&gt;P&lt;/code&gt; ,后跟一个点。</target>
        </trans-unit>
        <trans-unit id="514e40665c7756f02fb508e8f86f86167ddf537d" translate="yes" xml:space="preserve">
          <source>The use of a camel with the topic of Perl is a trademark of O'Reilly and Associates, Inc. Used with permission.</source>
          <target state="translated">骆驼与Perl主题的使用是O'Reilly and Associates,Inc.的商标。经许可使用。</target>
        </trans-unit>
        <trans-unit id="9cb45eca9a7939753b03a1360d763d098c0e7870" translate="yes" xml:space="preserve">
          <source>The use of all caps for constant names is merely a convention, although it is recommended in order to make constants stand out and to help avoid collisions with other barewords, keywords, and subroutine names. Constant names must begin with a letter or underscore. Names beginning with a double underscore are reserved. Some poor choices for names will generate warnings, if warnings are enabled at compile time.</source>
          <target state="translated">在常量名称中使用大写只是一种惯例,但为了使常量更加突出,并有助于避免与其他裸词、关键字和子程序名称发生冲突,建议使用大写。常量名称必须以字母或下划线开头。以双下划线开头的名字是保留的。如果在编译时启用了警告,那么一些错误的名字会产生警告。</target>
        </trans-unit>
        <trans-unit id="58b862df75de13b5dcf2d9b0b606b5454f4112c1" translate="yes" xml:space="preserve">
          <source>The use of hash keys starting with a hyphen (&lt;code&gt;-name&lt;/code&gt; ) or entirely in upper case (&lt;code&gt;NAME&lt;/code&gt; ) is a relic of older versions of Perl in which ordinary lower case strings were not handled correctly by the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator. While some modules retain uppercase or hyphenated argument keys for historical reasons or as a matter of personal style, most new modules should use simple lower case keys. Whatever you choose, be consistent!</source>
          <target state="translated">使用以连字符（ &lt;code&gt;-name&lt;/code&gt; ）开头或完全以大写（ &lt;code&gt;NAME&lt;/code&gt; ）开头的哈希键是Perl较旧版本的遗留物，其中 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符未正确处理普通的小写字符串。虽然某些模块出于历史原因或个人风格保留大写或带连字符的参数键，但大多数新模块应使用简单的小写键。无论您选择什么，都要保持一致！</target>
        </trans-unit>
        <trans-unit id="0181fb947fb2e09fe7658e112ec2fe9418c5503f" translate="yes" xml:space="preserve">
          <source>The use of interpreter-based threads in perl is officially &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">正式&lt;a href=&quot;perlpolicy#discouraged&quot;&gt;禁止&lt;/a&gt;在perl中使用基于解释器的线程。</target>
        </trans-unit>
        <trans-unit id="af3aa24ab804ebe0a65aee4289caba48448e851d" translate="yes" xml:space="preserve">
          <source>The use of parentheses around a &lt;b&gt;subpattern&lt;/b&gt; in a &lt;b&gt;regular expression&lt;/b&gt; to store the matched &lt;b&gt;substring&lt;/b&gt; as a &lt;b&gt;backreference&lt;/b&gt;. (Captured strings are also returned as a list in &lt;b&gt;list context&lt;/b&gt;.) See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">在&lt;b&gt;正则表达式&lt;/b&gt;中围绕&lt;b&gt;子模式&lt;/b&gt;使用括号将匹配的&lt;b&gt;子字符串&lt;/b&gt;存储为后向&lt;b&gt;引用&lt;/b&gt;。（捕获的字符串也将作为&lt;b&gt;列表上下文&lt;/b&gt;中的&lt;b&gt;列表&lt;/b&gt;返回。）请参见Camel第5章&amp;ldquo;模式匹配&amp;rdquo;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ceb3a7a104da1d4a198b733387677a08ee3ca395" translate="yes" xml:space="preserve">
          <source>The use of parenthesis can be used to capture parts of the input filename.</source>
          <target state="translated">使用括号可以用来捕捉输入文件名的部分内容。</target>
        </trans-unit>
        <trans-unit id="379fb1c054bbd3152f276aaca35f049867852f33" translate="yes" xml:space="preserve">
          <source>The use of the following functions is discouraged as they are not actually testing functions and produce no diagnostics to help figure out what went wrong. They were written before &lt;code&gt;is_deeply()&lt;/code&gt; existed because I couldn't figure out how to display a useful diff of two arbitrary data structures.</source>
          <target state="translated">不鼓励使用以下功能，因为它们实际上不是测试功能，并且不会产生诊断信息以帮助找出问题所在。它们是在 &lt;code&gt;is_deeply()&lt;/code&gt; 存在之前编写的，因为我不知道如何显示两个任意数据结构的有用差异。</target>
        </trans-unit>
        <trans-unit id="5b392cf4598b7c92d87fc443e5bf63773c90811b" translate="yes" xml:space="preserve">
          <source>The usenm option</source>
          <target state="translated">usenm选项</target>
        </trans-unit>
        <trans-unit id="977cdd9dc7908139553c49b2609de1c2c08baff9" translate="yes" xml:space="preserve">
          <source>The user id owning the file</source>
          <target state="translated">拥有该文件的用户ID</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
