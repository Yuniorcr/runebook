<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="8ae5f938ab7a5d83a52240928c9fc8f756451386" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit decimal numbers (format &lt;code&gt;i&lt;/code&gt; ) for output.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化输出的64位十进制数字（格式 &lt;code&gt;i&lt;/code&gt; ）的字符串。</target>
        </trans-unit>
        <trans-unit id="67f3f82cc82b4b966bf37a7650e599f3caebbae2" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit decimal numbers (format &lt;code&gt;i&lt;/code&gt;) for output.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化输出的64位十进制数字（格式 &lt;code&gt;i&lt;/code&gt; ）的字符串。</target>
        </trans-unit>
        <trans-unit id="b81a10e07e19ecd9ea940b8094c09118247d9976" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit hExADECimAl numbers (format &lt;code&gt;X&lt;/code&gt; ) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIx64 so that even case-blind systems can see the difference.</source>
          <target state="translated">如果定义了此变量，则该字符串包含stdio用于格式化输出的64位hExADECimAl数字（格式 &lt;code&gt;X&lt;/code&gt; ）的字符串。名称中的 &lt;code&gt;U&lt;/code&gt; 是将其与sPRIx64分开，以便即使大小写不均的系统也可以看到差异。</target>
        </trans-unit>
        <trans-unit id="83b9dfdbe65dffb2c54b38449f43e2b100be9ab9" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit hExADECimAl numbers (format &lt;code&gt;X&lt;/code&gt;) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIx64 so that even case-blind systems can see the difference.</source>
          <target state="translated">如果定义了此变量，则该字符串包含stdio用于格式化输出的64位hExADECimAl数字（格式 &lt;code&gt;X&lt;/code&gt; ）的字符串。名称中的 &lt;code&gt;U&lt;/code&gt; 是将其与sPRIx64分开，以便即使大小写不均的系统也可以看到差异。</target>
        </trans-unit>
        <trans-unit id="9ec40980af277a53203a731f456671009736e566" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit hexadecimal numbers (format &lt;code&gt;x&lt;/code&gt; ) for output.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化输出的64位十六进制数字（格式 &lt;code&gt;x&lt;/code&gt; ）的字符串。</target>
        </trans-unit>
        <trans-unit id="3dc36ab3b201ba898512f271cd471ea7023cc0a8" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit hexadecimal numbers (format &lt;code&gt;x&lt;/code&gt;) for output.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化输出的64位十六进制数字（格式 &lt;code&gt;x&lt;/code&gt; ）的字符串。</target>
        </trans-unit>
        <trans-unit id="31b88a2a561747708142859b385e21cffab2ae43" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit octal numbers (format &lt;code&gt;o&lt;/code&gt; ) for output.</source>
          <target state="translated">如果定义了此变量，则它包含stdio用于格式化输出的64位八进制数字（格式 &lt;code&gt;o&lt;/code&gt; ）的字符串。</target>
        </trans-unit>
        <trans-unit id="cd3924c1c084cb44315833891ddcd4a7eebd0e67" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit octal numbers (format &lt;code&gt;o&lt;/code&gt;) for output.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化输出的64位八进制数字（格式 &lt;code&gt;o&lt;/code&gt; ）的字符串。</target>
        </trans-unit>
        <trans-unit id="8e6ccb1849bdac1320c428c08feac83669cad758" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit unsigned decimal numbers (format &lt;code&gt;u&lt;/code&gt; ) for output.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化输出的64位无符号十进制数字（格式 &lt;code&gt;u&lt;/code&gt; ）的字符串。</target>
        </trans-unit>
        <trans-unit id="36f35afe2c30bd98009a97f65964123423bdd4d4" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit unsigned decimal numbers (format &lt;code&gt;u&lt;/code&gt;) for output.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化输出的64位无符号十进制数字（格式 &lt;code&gt;u&lt;/code&gt; ）的字符串。</target>
        </trans-unit>
        <trans-unit id="222bb5647e9123694b13cf58d9917c77bccc21a6" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;E&lt;/code&gt; ) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIeldbl so that even case-blind systems can see the difference.</source>
          <target state="translated">如果定义了此变量，则包含stdio用来格式化长双精度字符（格式 &lt;code&gt;E&lt;/code&gt; ）以输出的字符串。名称中的 &lt;code&gt;U&lt;/code&gt; 是将其与sPRIeldbl分开，以便即使是大小写不明的系统也可以看到差异。</target>
        </trans-unit>
        <trans-unit id="2050a0f7b3a9a23a52125e530e11a02bf8c893d1" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;E&lt;/code&gt;) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIeldbl so that even case-blind systems can see the difference.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化长双精度字符（格式 &lt;code&gt;E&lt;/code&gt; ）以输出的字符串。名称中的 &lt;code&gt;U&lt;/code&gt; 是将其与sPRIeldbl分开，以便即使大小写不明的系统也可以看到差异。</target>
        </trans-unit>
        <trans-unit id="19eff6d51cf0aa4f54340246c25b4fe22c0a7043" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;F&lt;/code&gt; ) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIfldbl so that even case-blind systems can see the difference.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化输出的long double（格式 &lt;code&gt;F&lt;/code&gt; ）的字符串。名称中的 &lt;code&gt;U&lt;/code&gt; 是将其与sPRIfldbl分开，以便即使是大小写不明的系统也可以看到差异。</target>
        </trans-unit>
        <trans-unit id="efe80f269f9289b061bd7dbb22f37e51a19b5e35" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;F&lt;/code&gt;) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIfldbl so that even case-blind systems can see the difference.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化长双精度字符（格式 &lt;code&gt;F&lt;/code&gt; ）以输出的字符串。名称中的 &lt;code&gt;U&lt;/code&gt; 是将其与sPRIfldbl分开，以便即使大小写不均的系统也可以看到差异。</target>
        </trans-unit>
        <trans-unit id="b6d81738452d04eab1f933bf7232ed90f2df15fa" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;G&lt;/code&gt; ) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIgldbl so that even case-blind systems can see the difference.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化长双精度（格式 &lt;code&gt;G&lt;/code&gt; ）以输出的字符串。名称中的 &lt;code&gt;U&lt;/code&gt; 是将其与sPRIgldbl分开，以便即使大小写不均的系统也可以看到差异。</target>
        </trans-unit>
        <trans-unit id="2a784bda71777bc6e4d31dd43bc4e461c72e418f" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;G&lt;/code&gt;) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIgldbl so that even case-blind systems can see the difference.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化长双精度字符（格式 &lt;code&gt;G&lt;/code&gt; ）以输出的字符串。名称中的 &lt;code&gt;U&lt;/code&gt; 是将其与sPRIgldbl分开，以便即使大小写不均的系统也可以看到差异。</target>
        </trans-unit>
        <trans-unit id="4115d1a6f75fdc4020d61ac608e2060b9c155a10" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;e&lt;/code&gt; ) for output.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化长双精度（格式 &lt;code&gt;e&lt;/code&gt; ）以输出的字符串。</target>
        </trans-unit>
        <trans-unit id="700f8e67e02a598e0e54376271db9e1c0a5b8ecb" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;e&lt;/code&gt;) for output.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化长双精度字符（格式 &lt;code&gt;e&lt;/code&gt; ）以输出的字符串。</target>
        </trans-unit>
        <trans-unit id="01930f22e76b74b59d1c31877d972228ff93ba53" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;f&lt;/code&gt; ) for input.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化输入的long double（格式 &lt;code&gt;f&lt;/code&gt; ）的字符串。</target>
        </trans-unit>
        <trans-unit id="9cb55332554b23f3aa4a22de66b9e7bcac1d0693" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;f&lt;/code&gt; ) for output.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化长双精度（格式 &lt;code&gt;f&lt;/code&gt; ）以输出的字符串。</target>
        </trans-unit>
        <trans-unit id="b26dd7a188b2c3657a7c1ed02e3716865b21c9d7" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;f&lt;/code&gt;) for input.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化输入的long double（格式 &lt;code&gt;f&lt;/code&gt; ）的字符串。</target>
        </trans-unit>
        <trans-unit id="5544508c61f44a54d0e120abd80b36263a180a3a" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;f&lt;/code&gt;) for output.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化长双精度（格式 &lt;code&gt;f&lt;/code&gt; ）以输出的字符串。</target>
        </trans-unit>
        <trans-unit id="89b45d6978a0a0f110d2a827f50454d233b58449" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;g&lt;/code&gt; ) for output.</source>
          <target state="translated">如果定义了此变量，则该字符串包含stdio用于格式化长双精度（格式 &lt;code&gt;g&lt;/code&gt; ）以输出的字符串。</target>
        </trans-unit>
        <trans-unit id="98a82044bd7f333e6bd3f7829751724488d9d452" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;g&lt;/code&gt;) for output.</source>
          <target state="translated">如果定义了此变量，则包含stdio用于格式化长双精度字符（格式 &lt;code&gt;g&lt;/code&gt; ）以输出的字符串。</target>
        </trans-unit>
        <trans-unit id="9c4b2499caf3daffc937f7d1cd2b93bf83f7b0ec" translate="yes" xml:space="preserve">
          <source>This variable, if defined, encodes the type of a double: 1 = &lt;code&gt;IEEE&lt;/code&gt; 754 32-bit big little endian, 2 = &lt;code&gt;IEEE&lt;/code&gt; 754 32-bit big big endian, 3 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit big little endian, 4 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit big big endian, 5 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit big little endian, 6 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit big big endian, 7 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit big mixed endian le-be, 8 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit big mixed endian be-le, -1 = unknown format.</source>
          <target state="translated">如果定义此变量，则将其编码为双精度类型：1 = &lt;code&gt;IEEE&lt;/code&gt; 754 32位大小端字节序，2 = &lt;code&gt;IEEE&lt;/code&gt; 754 32位大小端字节序，3 = &lt;code&gt;IEEE&lt;/code&gt; 754 64位大小端字节，4 = &lt;code&gt;IEEE&lt;/code&gt; 754 64位大字节序，5 = &lt;code&gt;IEEE&lt;/code&gt; 754 128位大字节序，6 = &lt;code&gt;IEEE&lt;/code&gt; 754 128位大字节序，7 = &lt;code&gt;IEEE&lt;/code&gt; 754 64位大字节序，8 = &lt;code&gt;IEEE&lt;/code&gt; 754 64位大混合字节序be-le，-1 =未知格式。</target>
        </trans-unit>
        <trans-unit id="c5d4ec9109bfc7e2c8658277ab4e1e7f6b540afd" translate="yes" xml:space="preserve">
          <source>This variable, if defined, encodes the type of a double: 1 = &lt;code&gt;IEEE&lt;/code&gt; 754 32-bit little endian, 2 = &lt;code&gt;IEEE&lt;/code&gt; 754 32-bit big endian, 3 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit little endian, 4 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit big endian, 5 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit little endian, 6 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit big endian, 7 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit mixed endian le-be, 8 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit mixed endian be-le, 9 = &lt;code&gt;VAX&lt;/code&gt; 32bit little endian F float format 10 = &lt;code&gt;VAX&lt;/code&gt; 64bit little endian D float format 11 = &lt;code&gt;VAX&lt;/code&gt; 64bit little endian G float format 12 = &lt;code&gt;IBM&lt;/code&gt; 32bit format 13 = &lt;code&gt;IBM&lt;/code&gt; 64bit format 14 = Cray 64bit format -1 = unknown format.</source>
          <target state="translated">如果定义此变量，则将其编码为双精度类型：1 = &lt;code&gt;IEEE&lt;/code&gt; 754 32位小端，2 = &lt;code&gt;IEEE&lt;/code&gt; 754 32位大端，3 = &lt;code&gt;IEEE&lt;/code&gt; 754 64位小端，4 = &lt;code&gt;IEEE&lt;/code&gt; 754 64位大字节序，5 = &lt;code&gt;IEEE&lt;/code&gt; 754 128位小字节序，6 = &lt;code&gt;IEEE&lt;/code&gt; 754 128位大字节序，7 = &lt;code&gt;IEEE&lt;/code&gt; 754 64位混合字节序，8 = &lt;code&gt;IEEE&lt;/code&gt; 754 64位混合字节序，9 = &lt;code&gt;VAX&lt;/code&gt; 32位小端F浮点格式10 = &lt;code&gt;VAX&lt;/code&gt; 64位小端D浮点格式11 = &lt;code&gt;VAX&lt;/code&gt; 64位小端G浮点格式12 = &lt;code&gt;IBM&lt;/code&gt; 32位格式13 = &lt;code&gt;IBM&lt;/code&gt; 64位格式14 = Cray 64位格式-1 =未知格式。</target>
        </trans-unit>
        <trans-unit id="6d1304e84a7f4ed50e62aa480c26a3922856d446" translate="yes" xml:space="preserve">
          <source>This variable, if defined, encodes the type of a long double: 0 = double, 1 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit big little endian, 2 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit big big endian, 3 = x86 80-bit little endian, 4 = x86 80-bit big endian, 5 = double-double 128-bit little endian, 6 = double-double 128-bit big endian, -1 = unknown format.</source>
          <target state="translated">如果已定义，则此变量编码长双精度型的类型：0 =双精度，1 = &lt;code&gt;IEEE&lt;/code&gt; 754 128位大小端字节序，2 = &lt;code&gt;IEEE&lt;/code&gt; 754 128位大小端字节序，3 = x86 80位小长端字节，4 = x86 80位大字节序，5 =双128位小字节序，6 =双128位大字节序，-1 =未知格式。</target>
        </trans-unit>
        <trans-unit id="cd6a413ce253159d4a0401b9ac379c35750b0045" translate="yes" xml:space="preserve">
          <source>This variable, if defined, encodes the type of a long double: 0 = double, 1 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit little endian, 2 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit big endian, 3 = x86 80-bit little endian, 4 = x86 80-bit big endian, 5 = double-double 128-bit little endian, 6 = double-double 128-bit big endian, 7 = 128-bit mixed-endian double-double (64-bit LEs in &lt;code&gt;BE&lt;/code&gt;), 8 = 128-bit mixed-endian double-double (64-bit BEs in &lt;code&gt;LE&lt;/code&gt;), 9 = 128-bit &lt;code&gt;PDP&lt;/code&gt;-style mixed-endian long doubles, -1 = unknown format.</source>
          <target state="translated">如果定义了此变量，则它会编码长双精度型的类型：0 =双精度型，1 = &lt;code&gt;IEEE&lt;/code&gt; 754 128位小端序，2 = &lt;code&gt;IEEE&lt;/code&gt; 754 128位大端序，3 = x86 80位小端序，4 = x86 80位大字节序，5 =双-双128位小字节序，6 =双-双128位大字节序，7 = 128位混合-字节序双倍双精度（ &lt;code&gt;BE&lt;/code&gt; 中的64位LE ），8 = 128位混合字节长双精度双精度型（ &lt;code&gt;LE&lt;/code&gt; 中为64位BE ），9 = 128位 &lt;code&gt;PDP&lt;/code&gt; 样式的混合字节长双精度双精度型，-1 =未知格式。</target>
        </trans-unit>
        <trans-unit id="2a280f8227b0adcb74f96bd4a84586fde60a2c87" translate="yes" xml:space="preserve">
          <source>This variable, if defined, encodes the type of a quad: 1 = int, 2 = long, 3 = long long, 4 = int64_t.</source>
          <target state="translated">如果定义了这个变量,则对四边形的类型进行编码。1=int,2=long,3=long long,4=int64_t.</target>
        </trans-unit>
        <trans-unit id="9d4d7d23fb68dfb0e56a5dbb549631b71c22498b" translate="yes" xml:space="preserve">
          <source>This variable, if defined, tells that there's a 64-bit integer type, quadtype.</source>
          <target state="translated">如果定义了这个变量,就会告诉大家有一个64位的整数类型,即quadtype。</target>
        </trans-unit>
        <trans-unit id="2ec4246dee0f43c0b7b758a9ec91d6ccc69de145" translate="yes" xml:space="preserve">
          <source>This variable, indicates that we can use sysctl with &lt;code&gt;KERN_PROC_PATHNAME&lt;/code&gt; to get a full path for the executable, and hence convert $^X to an absolute path.</source>
          <target state="translated">此变量表示我们可以将sysctl与 &lt;code&gt;KERN_PROC_PATHNAME&lt;/code&gt; 一起使用以获取可执行文件的完整路径，从而将$ ^ X转换为绝对路径。</target>
        </trans-unit>
        <trans-unit id="4d1ab2f45c88a294e86812741f36b5040a0f8962" translate="yes" xml:space="preserve">
          <source>This venerable module has been the de-facto standard for Perl code profiling for more than a decade, but has been replaced by a number of other modules which have brought us back to the 21st century. Although you're recommended to evaluate your tool from the several mentioned here and from the CPAN list at the base of this document, (and currently &lt;a href=&quot;Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; seems to be the weapon of choice - see below), we'll take a quick look at the output from &lt;a href=&quot;Devel::DProf&quot;&gt;Devel::DProf&lt;/a&gt; first, to set a baseline for Perl profiling tools. Run the above program under the control of &lt;code&gt;Devel::DProf&lt;/code&gt; by using the &lt;code&gt;-d&lt;/code&gt; switch on the command-line.</source>
          <target state="translated">这个古老的模块已经成为Perl代码概要分析的实际标准，但是已经被许多其他模块所取代，这使我们回到了21世纪。尽管建议您从此处提到的几种工具以及本文档基础上的CPAN列表中评估您的工具（但目前&lt;a href=&quot;Devel::NYTProf&quot;&gt;Devel :: NYTProf&lt;/a&gt;似乎是选择的武器-参见下文），但我们将首先快速查看&lt;a href=&quot;Devel::DProf&quot;&gt;Devel :: DProf&lt;/a&gt;的输出，以设置Perl分析工具的基准。通过在命令行上使用 &lt;code&gt;-d&lt;/code&gt; 开关，在 &lt;code&gt;Devel::DProf&lt;/code&gt; 的控制下运行上述程序。</target>
        </trans-unit>
        <trans-unit id="fa78f147d9884daa116a5882818c1ec5ea0dcb5e" translate="yes" xml:space="preserve">
          <source>This venerable module has been the de-facto standard for Perl code profiling for more than a decade, but has been replaced by a number of other modules which have brought us back to the 21st century. Although you're recommended to evaluate your tool from the several mentioned here and from the CPAN list at the base of this document, (and currently &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; seems to be the weapon of choice - see below), we'll take a quick look at the output from &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::DProf&quot;&gt;Devel::DProf&lt;/a&gt; first, to set a baseline for Perl profiling tools. Run the above program under the control of &lt;code&gt;Devel::DProf&lt;/code&gt; by using the &lt;code&gt;-d&lt;/code&gt; switch on the command-line.</source>
          <target state="translated">这个古老的模块已经成为Perl代码剖析的实际标准，但是已经被许多其他模块所取代，这使我们回到了21世纪。尽管建议您从此处提到的几种工具以及本文档基础上的CPAN列表中评估您的工具，（并且目前&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel :: NYTProf&lt;/a&gt;似乎是选择的武器-参见下文），但我们将首先，快速查看&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::DProf&quot;&gt;Devel :: DProf&lt;/a&gt;的输出，以设置Perl分析工具的基准。通过在命令行上使用 &lt;code&gt;-d&lt;/code&gt; 开关，在 &lt;code&gt;Devel::DProf&lt;/code&gt; 的控制下运行上述程序。</target>
        </trans-unit>
        <trans-unit id="d8b7da5503989109939012afef8ef4e8d0e19732" translate="yes" xml:space="preserve">
          <source>This version of &lt;b&gt;DB_File&lt;/b&gt; will work with either version 1.x, 2.x or 3.x of Berkeley DB, but is limited to the functionality provided by version 1.</source>
          <target state="translated">此版本的&lt;b&gt;DB_File&lt;/b&gt;可与Berkeley DB的1.x，2.x或3.x版本一起使用，但仅限于版本1提供的功能。</target>
        </trans-unit>
        <trans-unit id="b0eb508fb3be052a99ae33f92711f88add33b71f" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;Win32API::File&lt;/code&gt; can be used like an &lt;code&gt;IO::File&lt;/code&gt; object:</source>
          <target state="translated">此版本的 &lt;code&gt;Win32API::File&lt;/code&gt; 可以像 &lt;code&gt;IO::File&lt;/code&gt; 对象一样使用：</target>
        </trans-unit>
        <trans-unit id="2abd4acddb66e31e5e1fcc2efdb9ba17579b4d60" translate="yes" xml:space="preserve">
          <source>This version of B::Terse is really just a wrapper that calls &lt;a href=&quot;B::Concise&quot;&gt;B::Concise&lt;/a&gt; with the &lt;b&gt;-terse&lt;/b&gt; option. It is provided for compatibility with old scripts (and habits) but using B::Concise directly is now recommended instead.</source>
          <target state="translated">这个版本的B :: Terse实际上只是一个使用&lt;b&gt;-terse&lt;/b&gt;选项调用&lt;a href=&quot;B::Concise&quot;&gt;B :: Concise&lt;/a&gt;的包装器。提供它是为了与旧脚本（和习惯）兼容，但现在建议直接使用B :: Concise。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0a150a56d3915850d7ba6874be9e5ac297420d19" translate="yes" xml:space="preserve">
          <source>This version of B::Terse is really just a wrapper that calls &lt;a href=&quot;concise&quot;&gt;B::Concise&lt;/a&gt; with the &lt;b&gt;-terse&lt;/b&gt; option. It is provided for compatibility with old scripts (and habits) but using B::Concise directly is now recommended instead.</source>
          <target state="translated">这个版本的B :: Terse实际上只是一个使用&lt;b&gt;-terse&lt;/b&gt;选项调用&lt;a href=&quot;concise&quot;&gt;B :: Concise&lt;/a&gt;的包装器。提供它是为了与旧脚本（和习惯）兼容，但现在建议直接使用B :: Concise。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f7beea27edd37499cd6d29dd522284d798300531" translate="yes" xml:space="preserve">
          <source>This version of Storable will defer croaking until it encounters a data type in the file that it does not recognize. This means that it will continue to read files generated by newer Storable modules which are careful in what they write out, making it easier to upgrade Storable modules in a mixed environment.</source>
          <target state="translated">这个版本的Storable会推迟呱呱坠地,直到遇到文件中的数据类型它不认识。这意味着它将继续读取较新的Storable模块生成的文件,这些模块在写出文件时很小心,这使得在混合环境中升级Storable模块变得更加容易。</target>
        </trans-unit>
        <trans-unit id="5eaf48998d3dac5c6c583e6c7a41844ecc68cbdc" translate="yes" xml:space="preserve">
          <source>This version of Tie::Handle is neither related to nor compatible with the Tie::Handle (3.0) module available on CPAN. It was due to an accident that two modules with the same name appeared. The namespace clash has been cleared in favor of this module that comes with the perl core in September 2000 and accordingly the version number has been bumped up to 4.0.</source>
          <target state="translated">这个版本的 Tie::Handle 与 CPAN 上的 Tie::Handle (3.0)模块既不相关也不兼容。这是由于一个意外,出现了两个同名的模块。2000年9月,这个命名空间的冲突已经被清除,改用perl核心的这个模块,因此版本号被提升到4.0。</target>
        </trans-unit>
        <trans-unit id="90d5427fd8fb6285ef2a8069dc284898c742f957" translate="yes" xml:space="preserve">
          <source>This version of Tie::RefHash seems to no longer work with 5.004. This has not been throughly investigated. Patches welcome ;-)</source>
          <target state="translated">这个版本的 Tie::RefHash 似乎不再适用于 5.004。这个问题还没有被彻底调查过。欢迎提供补丁;-)</target>
        </trans-unit>
        <trans-unit id="01f1b71892670e34f133ad330dd4b67c49baabc8" translate="yes" xml:space="preserve">
          <source>This version of libnet requires Perl 5.8.1 or higher.</source>
          <target state="translated">这个版本的libnet需要Perl 5.8.1或更高版本。</target>
        </trans-unit>
        <trans-unit id="7ba74e67d43f1dcfdfea27ea433084f1ae0841f7" translate="yes" xml:space="preserve">
          <source>This version promises absolutely nothing about the internals, which may change without notice. A future version of the module will have a well-defined and stable subclassing API.</source>
          <target state="translated">这个版本对内部结构没有任何承诺,可能会在没有通知的情况下改变。该模块的未来版本将有一个定义明确且稳定的子类API。</target>
        </trans-unit>
        <trans-unit id="2c33d1e6335776e46321c7802e91226cd357ca23" translate="yes" xml:space="preserve">
          <source>This very simple command line example demonstrates the streaming capabilities of the module. The code reads data from STDIN, compresses it, and writes the compressed data to STDOUT.</source>
          <target state="translated">这个非常简单的命令行例子展示了模块的流媒体功能。这段代码从STDIN读取数据,压缩数据,并将压缩后的数据写入STDOUT。</target>
        </trans-unit>
        <trans-unit id="0cd942caf754c58fe17da1e32e8323477ac4ba5d" translate="yes" xml:space="preserve">
          <source>This warning category was added in the specified Perl version (a development release). Without the &lt;code&gt;'if'&lt;/code&gt; , trying to use it in an earlier release would generate an unknown warning category error.</source>
          <target state="translated">此警告类别已添加到指定的Perl版本（开发版本）中。如果没有 &lt;code&gt;'if'&lt;/code&gt; ，尝试在较早版本中使用它会生成未知的警告类别错误。</target>
        </trans-unit>
        <trans-unit id="1e633ddd1e5bf36f7ac48a03da45d1264ed96ee5" translate="yes" xml:space="preserve">
          <source>This warning is emitted when you try to store a key or a value that is too long. It means that the change was not recorded in the database. See BUGS AND WARNINGS below.</source>
          <target state="translated">当你试图存储一个过长的键或值时,会发出这个警告。这意味着变化没有被记录在数据库中。参见下面的 &quot;错误和警告&quot;。</target>
        </trans-unit>
        <trans-unit id="e8cff43243ebcf6f3dd6cc489bc961145ec38b74" translate="yes" xml:space="preserve">
          <source>This warning will not be issued for numerical constants equal to 0 or 1 since they are often used in statements like</source>
          <target state="translated">这个警告不会对等于0或1的数字常量发出,因为它们经常被用在类似于</target>
        </trans-unit>
        <trans-unit id="fb25267b9628f5c34293586036ece5f10f559c4e" translate="yes" xml:space="preserve">
          <source>This warning will only be issued if the module was loaded from a core library directory, which allows the &lt;code&gt;use deprecate&lt;/code&gt; line to be included in the CPAN version of the module. Because the pragma remains silent when the module is run from a non-core library directory, the pragma call does not need to be patched into or out of either the core or CPAN version of the module. The exact same code can be shipped for either purpose.</source>
          <target state="translated">仅当从核心库目录加载模块时才发出此警告，这允许在模块的CPAN版本中包括 &lt;code&gt;use deprecate&lt;/code&gt; 行。因为从非核心库目录运行模块时，编译指示保持沉默，所以不需要将编译指示调用打入或打入模块的核心或CPAN版本。可以将完全相同的代码用于这两种目的。</target>
        </trans-unit>
        <trans-unit id="88527b08bd7fd0eb304080fa0991400d2de28f89" translate="yes" xml:space="preserve">
          <source>This was a badly misnamed method. It indicates which TODO tests unexpectedly succeeded. Will now issue a warning and call &lt;code&gt;todo_passed&lt;/code&gt; .</source>
          <target state="translated">这是一个严重错误命名的方法。它指示哪些TODO测试意外成功。现在将发出警告并调用 &lt;code&gt;todo_passed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa4dc1c03b748cd0f54a6e36b58cd790f7b37d93" translate="yes" xml:space="preserve">
          <source>This was a badly misnamed method. It indicates which TODO tests unexpectedly succeeded. Will now issue a warning and call &lt;code&gt;todo_passed&lt;/code&gt;.</source>
          <target state="translated">这是一个严重错误命名的方法。它指示哪些TODO测试意外成功。现在将发出警告并调用 &lt;code&gt;todo_passed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b45cf862902bfae8835d878b4e23a6c4625a4b39" translate="yes" xml:space="preserve">
          <source>This was a long-standing bug that was removed in Perl 5.16, as there was no way to tie the scalar itself when it held a typeglob, and no way to untie a scalar that had had a typeglob assigned to it. If you see this message, you must be using an older version.</source>
          <target state="translated">这是一个长期存在的错误,在Perl 5.16中被删除了,因为当标量持有一个typeglob时,无法绑定标量本身,也无法解除已经分配了typeglob的标量的绑定。如果你看到这条消息,你一定是在使用旧版本。</target>
        </trans-unit>
        <trans-unit id="aa5539ec182325e9d71ebb4572a22404618af670" translate="yes" xml:space="preserve">
          <source>This was added in 5.18.0.</source>
          <target state="translated">这是在5.18.0添加的。</target>
        </trans-unit>
        <trans-unit id="73547d5e4f49176fd82dee316a69c227bee73684" translate="yes" xml:space="preserve">
          <source>This was added in perl 5.10.0 and removed in perl 5.23.4.</source>
          <target state="translated">这是在perl 5.10.0中添加的,在perl 5.23.4中删除。</target>
        </trans-unit>
        <trans-unit id="5d6fa0871ce6ad13e934257fa7ce3533e8952e03" translate="yes" xml:space="preserve">
          <source>This was added in perl 5.10.0, but it should be noted there are significant incompatibilities between 5.10.0 and 5.10.1.</source>
          <target state="translated">这是在perl 5.10.0中添加的,但需要注意的是,5.10.0和5.10.1之间有很大的不兼容性。</target>
        </trans-unit>
        <trans-unit id="86ee83050383416b7e389e9af0ba79674a7563d4" translate="yes" xml:space="preserve">
          <source>This was added in perl 5.10.0.</source>
          <target state="translated">这是在perl 5.10.0中加入的。</target>
        </trans-unit>
        <trans-unit id="a0752bb9783d2b9a1a7e76fb203ea820e0ca870c" translate="yes" xml:space="preserve">
          <source>This was added in perl 5.14.0 and removed in perl 5.23.1.</source>
          <target state="translated">这是在perl 5.14.0中添加的,在perl 5.23.1中删除。</target>
        </trans-unit>
        <trans-unit id="c40fb4feaa26bd467071cbae21a4a30c404f85d3" translate="yes" xml:space="preserve">
          <source>This was added in perl 5.18.0.</source>
          <target state="translated">这是在perl 5.18.0中加入的。</target>
        </trans-unit>
        <trans-unit id="bbe97e5b827f96bf118c9316e0567cd6e381cc7d" translate="yes" xml:space="preserve">
          <source>This was added in perl 5.20.0.</source>
          <target state="translated">这是在perl 5.20.0中加入的。</target>
        </trans-unit>
        <trans-unit id="c80207a7acd3de0a1ba18af490ae7493a04473d7" translate="yes" xml:space="preserve">
          <source>This was added in perl 5.22.0.</source>
          <target state="translated">这是在perl 5.22.0中加入的。</target>
        </trans-unit>
        <trans-unit id="3f87b1ac06bc83c2319790f42b388bd0ccadfcd8" translate="yes" xml:space="preserve">
          <source>This was added on perl 5.22.0.</source>
          <target state="translated">这是在perl 5.22.0上添加的。</target>
        </trans-unit>
        <trans-unit id="a8f651ba658ca750c49bd019c617379c7670ef2f" translate="yes" xml:space="preserve">
          <source>This was admittedly a rather silly example, because you're using string literals whose content is perfectly safe. There is therefore no cause to resort to the harder-to-read, multi-argument form of pipe open(). However, whenever you cannot be assured that the program arguments are free of shell metacharacters, the fancier form of open() should be used. For example:</source>
          <target state="translated">诚然,这是一个相当愚蠢的例子,因为你使用的是字符串,其内容是完全安全的。因此,我们没有理由使用 pipe open()这种更难读、多参数的形式。然而,当你不能保证程序参数中没有shell元字符时,就应该使用open()的更高级的形式。例如</target>
        </trans-unit>
        <trans-unit id="52842d3db3182ba8489c9fe305ea59c070b90b44" translate="yes" xml:space="preserve">
          <source>This was broken by a bugfix to how planning is done. The test was updated after the bugfix.</source>
          <target state="translated">这是由一个规划方式的bug修复所打破的。该测试在修复bug后进行了更新。</target>
        </trans-unit>
        <trans-unit id="6adc8016fae975d63e5781a7a173583fad74e2a2" translate="yes" xml:space="preserve">
          <source>This was deprecated in Perl 5.004, and was made fatal in Perl 5.28.</source>
          <target state="translated">这个功能在 Perl 5.004 中已经被废弃,而在 Perl 5.28 中则是致命的。</target>
        </trans-unit>
        <trans-unit id="4ad1f59b92c11293a099928bce1ad73cdf53620e" translate="yes" xml:space="preserve">
          <source>This was deprecated in Perl 5.12.</source>
          <target state="translated">在Perl 5.12中,这个功能被取消了。</target>
        </trans-unit>
        <trans-unit id="d8277d13b7b088fe35066777a82bd8877dc5ddaf" translate="yes" xml:space="preserve">
          <source>This was deprecated in Perl 5.14, and the bug was fixed in Perl 5.16.</source>
          <target state="translated">这在Perl 5.14中已被废弃,这个错误在Perl 5.16中得到了修正。</target>
        </trans-unit>
        <trans-unit id="b7d7dc7d321351f8bc93d1d89d80efcb1109c89d" translate="yes" xml:space="preserve">
          <source>This was needed to compile &lt;code&gt;Perl/Tk&lt;/code&gt; for XFree86-OS/2 out-of-the-box, and link with DLLs for other useful libraries, which typically are compiled with &lt;code&gt;-Zmt -Zcrtdll&lt;/code&gt; .</source>
          <target state="translated">这是 &lt;code&gt;-Zmt -Zcrtdll&lt;/code&gt; 为XFree86-OS / 2 编译 &lt;code&gt;Perl/Tk&lt;/code&gt; 以及与其他有用库的DLL链接所必需的，这些库通常是用-Zmt -Zcrtdll编译的。</target>
        </trans-unit>
        <trans-unit id="ba0132f62d3c0837a8cbce3b6e8ada9ff6d8da3a" translate="yes" xml:space="preserve">
          <source>This was needed to compile &lt;code&gt;Perl/Tk&lt;/code&gt; for XFree86-OS/2 out-of-the-box, and link with DLLs for other useful libraries, which typically are compiled with &lt;code&gt;-Zmt -Zcrtdll&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;-Zmt -Zcrtdll&lt;/code&gt; 为XFree86-OS / 2编译 &lt;code&gt;Perl/Tk&lt;/code&gt; ，并与其他有用库的DLL链接所必需的，这些库通常是用-Zmt -Zcrtdll编译的。</target>
        </trans-unit>
        <trans-unit id="b90e7352745273d9d5fc329cd7b135def60740ad" translate="yes" xml:space="preserve">
          <source>This was once handled by &lt;a href=&quot;Encode::Bytes&quot;&gt;Encode::Bytes&lt;/a&gt; but because of all those unusual specifications, Encode 2.20 has relocated the support to &lt;a href=&quot;Encode::GSM0338&quot;&gt;Encode::GSM0338&lt;/a&gt;. See &lt;a href=&quot;Encode::GSM0338&quot;&gt;Encode::GSM0338&lt;/a&gt; for details.</source>
          <target state="translated">这曾经由&lt;a href=&quot;Encode::Bytes&quot;&gt;Encode :: Bytes&lt;/a&gt;处理，但是由于所有这些异常规范，Encode 2.20已将支持重新定位到&lt;a href=&quot;Encode::GSM0338&quot;&gt;Encode :: GSM0338&lt;/a&gt;。有关详细信息，请参见&lt;a href=&quot;Encode::GSM0338&quot;&gt;Encode :: GSM0338&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f5cfb3fd6b00c8dfb20e9b633295719ddfb3bcde" translate="yes" xml:space="preserve">
          <source>This was once handled by &lt;a href=&quot;Encode::Bytes&quot;&gt;Encode::Bytes&lt;/a&gt; but because of all those unusual specifications, Encode 2.20 has relocated the support to this module.</source>
          <target state="translated">这曾经由&lt;a href=&quot;Encode::Bytes&quot;&gt;Encode :: Bytes&lt;/a&gt;处理，但是由于所有这些异常规范，Encode 2.20已将支持重新定位到该模块。</target>
        </trans-unit>
        <trans-unit id="833ec61263166849d2a9c2ebdf6cb1d3f6ab0212" translate="yes" xml:space="preserve">
          <source>This was once handled by &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::Bytes&quot;&gt;Encode::Bytes&lt;/a&gt; but because of all those unusual specifications, Encode 2.20 has relocated the support to this module.</source>
          <target state="translated">这曾经由&lt;a href=&quot;http://search.cpan.org/perldoc/Encode::Bytes&quot;&gt;Encode :: Bytes&lt;/a&gt;处理，但是由于所有这些异常规范，Encode 2.20已将支持重新定位到该模块。</target>
        </trans-unit>
        <trans-unit id="673c10b2478f050683d1e4c485023459285fac78" translate="yes" xml:space="preserve">
          <source>This was released in Test::More 0.88 and first shipped with Perl in 5.10.1 as part of Test::More 0.92.</source>
          <target state="translated">这是在 Test::More 0.88 中发布的,并作为 Test::More 0.92 的一部分在 5.10.1 中首次与 Perl 一起发布。</target>
        </trans-unit>
        <trans-unit id="07e05c78f2530dcd101f922dcc9a65641fe08796" translate="yes" xml:space="preserve">
          <source>This was the method that version.pm adopted as well. Some examples may be helpful:</source>
          <target state="translated">version.pm也采用了这种方法。一些例子可能会有帮助。</target>
        </trans-unit>
        <trans-unit id="4a133adb902d85c6cf121910a483b79ef0cf0ad5" translate="yes" xml:space="preserve">
          <source>This way you ensure that your library really works 100% within Math::BigInt.</source>
          <target state="translated">这样你就可以确保你的库真正100%地在Math::BigInt中工作。</target>
        </trans-unit>
        <trans-unit id="ce6198ece9bfb71059f3d726e5c12d16f2b9fa36" translate="yes" xml:space="preserve">
          <source>This way, we avoid namespace pollution by not creating global variables and we've simplified our code as well.</source>
          <target state="translated">这样一来,我们通过不创建全局变量,避免了命名空间污染,也简化了我们的代码。</target>
        </trans-unit>
        <trans-unit id="8dbee524f7a0db93b950c3c6b304adf98088982f" translate="yes" xml:space="preserve">
          <source>This way, you can filter on any attribute of the files in the archive. Consult the &lt;code&gt;Archive::Tar::File&lt;/code&gt; documentation on how to use these objects.</source>
          <target state="translated">这样，您可以过滤存档中文件的任何属性。有关如何使用这些对象的信息，请查阅 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="035be350abab307537bd4a5157d94ede32ad2db2" translate="yes" xml:space="preserve">
          <source>This way, you'll be forced to declare all your variables with my() and also disallow accidental &quot;symbolic dereferencing&quot;. Therefore if you'd done this:</source>
          <target state="translated">这样一来,你将被迫用my()来声明所有的变量,同时也不允许意外的 &quot;符号解引用&quot;。因此,如果你这样做了。</target>
        </trans-unit>
        <trans-unit id="4eea9ab96b86c2e70b488d8aa5e8991a1b8d5b3c" translate="yes" xml:space="preserve">
          <source>This where the firewall machine runs an ftp server. This kind of firewall will only let you access ftp servers outside the firewall. This is usually done by connecting to the firewall with ftp, then entering a username like &quot;user@outside.host.com&quot;.</source>
          <target state="translated">这其中防火墙机器运行的是ftp服务器。这种防火墙只会让你访问防火墙外的ftp服务器。这通常是通过用ftp连接到防火墙,然后输入一个用户名,如 &quot;user@outside.host.com&quot;。</target>
        </trans-unit>
        <trans-unit id="35c834ce9b69362e3fd6f7146051fbf20c1d653c" translate="yes" xml:space="preserve">
          <source>This whole affair is quite dangerous, as you may block forever. It assumes it's going to talk to something like &lt;a href=&quot;http://man.he.net/man1/bc&quot;&gt;bc(1)&lt;/a&gt;, both writing to it and reading from it. This is presumably safe because you &quot;know&quot; that commands like &lt;a href=&quot;http://man.he.net/man1/bc&quot;&gt;bc(1)&lt;/a&gt; will read a line at a time and output a line at a time. Programs like &lt;a href=&quot;http://man.he.net/man1/sort&quot;&gt;sort(1)&lt;/a&gt; that read their entire input stream first, however, are quite apt to cause deadlock.</source>
          <target state="translated">整个事件非常危险，因为您可能会永远受阻。它假定它将要与&lt;a href=&quot;http://man.he.net/man1/bc&quot;&gt;bc（1）之&lt;/a&gt;类的东西交谈，同时对其进行写入和读取。这大概是安全的，因为您&amp;ldquo;知道&amp;rdquo;诸如&lt;a href=&quot;http://man.he.net/man1/bc&quot;&gt;bc（1）之&lt;/a&gt;类的命令将一次读取一行并一次输出一行。但是，像&lt;a href=&quot;http://man.he.net/man1/sort&quot;&gt;sort（1）&lt;/a&gt;这样的程序会首先读取其整个输入流，因此很容易引起死锁。</target>
        </trans-unit>
        <trans-unit id="a1b36c3523eae51f237d9a16581fa97335171ca3" translate="yes" xml:space="preserve">
          <source>This whole affair is quite dangerous, as you may block forever. It assumes it's going to talk to something like &lt;b&gt;bc&lt;/b&gt;, both writing to it and reading from it. This is presumably safe because you &quot;know&quot; that commands like &lt;b&gt;bc&lt;/b&gt; will read a line at a time and output a line at a time. Programs like &lt;b&gt;sort&lt;/b&gt; that read their entire input stream first, however, are quite apt to cause deadlock.</source>
          <target state="translated">整个事件非常危险，因为您可能会永远受阻。它假定它将与&lt;b&gt;bc&lt;/b&gt;之类的对象进行对话，同时对其进行写入和读取。这大概是安全的，因为您&amp;ldquo;知道&amp;rdquo;诸如&lt;b&gt;bc之类的&lt;/b&gt;命令将一次读取一行并一次输出一行。但是，诸如&lt;b&gt;sort之类的&lt;/b&gt;程序会首先读取其整个输入流，因此很容易引起死锁。</target>
        </trans-unit>
        <trans-unit id="0f0b5462a666458a41aebef2f79e13773386a813" translate="yes" xml:space="preserve">
          <source>This will arrange to have &lt;code&gt;my_start_hook&lt;/code&gt; called at the start of compiling every lexical scope. The available hooks are:</source>
          <target state="translated">这将安排在编译每个词法范围开始时调用 &lt;code&gt;my_start_hook&lt;/code&gt; 。可用的挂钩是：</target>
        </trans-unit>
        <trans-unit id="5676c2e017cdc717b4c080a4e42c0c92fc23cd0b" translate="yes" xml:space="preserve">
          <source>This will be adequate if you ever need to have only one callback registered at any time. An example could be an error handler like the code sketched out above. Remember though, repeated calls to &lt;code&gt;register_fatal&lt;/code&gt; will replace the previously registered callback function with the new one.</source>
          <target state="translated">如果您需要随时只注册一个回调，这将足够了。一个示例可能是错误处理程序，例如上面概述的代码。但是请记住，重复调用 &lt;code&gt;register_fatal&lt;/code&gt; 会将先前注册的回调函数替换为新的回调函数。</target>
        </trans-unit>
        <trans-unit id="e49ef6980bc11da9126cc73cebced07915750bd4" translate="yes" xml:space="preserve">
          <source>This will be hopefully fixed soon ;)</source>
          <target state="translated">这将是希望很快修复;)</target>
        </trans-unit>
        <trans-unit id="84c8586018e16cc8bdba71e80abd032027928904" translate="yes" xml:space="preserve">
          <source>This will be true if the amnesty was granted to a parent event and inherited by this event, which is a child, such as an assertion within a subtest that is marked todo.</source>
          <target state="translated">如果赦免被授予一个父事件,并由这个事件继承,这将是真实的,这个事件是一个子事件,比如一个子测试中的断言被标记为todo。</target>
        </trans-unit>
        <trans-unit id="9e10c44561f52b9bb33ad9f3f6e795b031a63516" translate="yes" xml:space="preserve">
          <source>This will be used by Perl to see what flags the regexp was compiled with, this will normally be set to the value of the flags parameter by the &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; callback. See the &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; documentation for valid flags.</source>
          <target state="translated">Perl将使用它来查看使用regexp编译了哪些标志，通常将由&lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt;回调将其设置为flags参数的值。有关有效标志，请参阅&lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="2bc84788b27f3c38d36164bfbf7f627ab2751e51" translate="yes" xml:space="preserve">
          <source>This will build the default setup that installs under SDK:local/newlib/lib/</source>
          <target state="translated">这将构建安装在SDK:local/newlib/lib/的默认设置。</target>
        </trans-unit>
        <trans-unit id="930a43d21f4f78037b3a8cd53a181a8ce40027bf" translate="yes" xml:space="preserve">
          <source>This will call &lt;code&gt;$hub-&amp;gt;cull&lt;/code&gt; on all hubs in the stack.</source>
          <target state="translated">这将在堆栈中的所有集线器上调用 &lt;code&gt;$hub-&amp;gt;cull&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14f01a7800d3c6ae7f1d36562ddb036bcb0f3fef" translate="yes" xml:space="preserve">
          <source>This will call &lt;code&gt;process(&quot;arg1&quot;)&lt;/code&gt; while &lt;code&gt;$width&lt;/code&gt; is &lt;code&gt;80&lt;/code&gt; , &lt;code&gt;process(&quot;arg2&quot;)&lt;/code&gt; while &lt;code&gt;$width&lt;/code&gt; is &lt;code&gt;72&lt;/code&gt; , and &lt;code&gt;process(&quot;arg3&quot;)&lt;/code&gt; while &lt;code&gt;$width&lt;/code&gt; is &lt;code&gt;60&lt;/code&gt; .</source>
          <target state="translated">这将调用 &lt;code&gt;process(&quot;arg1&quot;)&lt;/code&gt; ，而 &lt;code&gt;$width&lt;/code&gt; 是 &lt;code&gt;80&lt;/code&gt; ， &lt;code&gt;process(&quot;arg2&quot;)&lt;/code&gt; ，而 &lt;code&gt;$width&lt;/code&gt; 是 &lt;code&gt;72&lt;/code&gt; ，和 &lt;code&gt;process(&quot;arg3&quot;)&lt;/code&gt; ，而 &lt;code&gt;$width&lt;/code&gt; 是 &lt;code&gt;60&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef8eafab6fdf00c54629025842f72d762c6ae1ee" translate="yes" xml:space="preserve">
          <source>This will call &lt;code&gt;process(&quot;arg1&quot;)&lt;/code&gt; while &lt;code&gt;$width&lt;/code&gt; is &lt;code&gt;80&lt;/code&gt;, &lt;code&gt;process(&quot;arg2&quot;)&lt;/code&gt; while &lt;code&gt;$width&lt;/code&gt; is &lt;code&gt;72&lt;/code&gt;, and &lt;code&gt;process(&quot;arg3&quot;)&lt;/code&gt; while &lt;code&gt;$width&lt;/code&gt; is &lt;code&gt;60&lt;/code&gt;.</source>
          <target state="translated">这将调用 &lt;code&gt;process(&quot;arg1&quot;)&lt;/code&gt; ，而 &lt;code&gt;$width&lt;/code&gt; 是 &lt;code&gt;80&lt;/code&gt; ， &lt;code&gt;process(&quot;arg2&quot;)&lt;/code&gt; ，而 &lt;code&gt;$width&lt;/code&gt; 是 &lt;code&gt;72&lt;/code&gt; ，和 &lt;code&gt;process(&quot;arg3&quot;)&lt;/code&gt; ，而 &lt;code&gt;$width&lt;/code&gt; 是 &lt;code&gt;60&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f9f81bd2d1f19a3ddd018a3abad8eeb66f3f8eb" translate="yes" xml:space="preserve">
          <source>This will call the callback routine for arg1 and arg2, and then terminate GetOptions() leaving &lt;code&gt;&quot;arg3&quot;&lt;/code&gt; in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">这将调用arg1和arg2的回调例程，然后终止GetOptions（）并在 &lt;code&gt;@ARGV&lt;/code&gt; 中保留 &lt;code&gt;&quot;arg3&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4cce8e23b1baa9b13a48148de7b04ff8e11c05a" translate="yes" xml:space="preserve">
          <source>This will call the callback routine for arg1 and arg2, and then terminate GetOptions() leaving &lt;code&gt;&quot;arg3&quot;&lt;/code&gt; in &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="translated">这将调用arg1和arg2的回调例程，然后终止GetOptions（）并在 &lt;code&gt;@ARGV&lt;/code&gt; 中保留 &lt;code&gt;&quot;arg3&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f58ac8fe1aff61494f576cce3683a76df1d61d32" translate="yes" xml:space="preserve">
          <source>This will cause &lt;code&gt;TAP::Parser&lt;/code&gt; to pass custom configuration to two of the built- in source handlers - &lt;a href=&quot;TAP::Parser::SourceHandler::Perl&quot;&gt;TAP::Parser::SourceHandler::Perl&lt;/a&gt;, &lt;a href=&quot;TAP::Parser::SourceHandler::File&quot;&gt;TAP::Parser::SourceHandler::File&lt;/a&gt; - and attempt to load the &lt;code&gt;MyCustom&lt;/code&gt; class. See &lt;a href=&quot;TAP::Parser::IteratorFactory#load_handlers&quot;&gt;&quot;load_handlers&quot; in TAP::Parser::IteratorFactory&lt;/a&gt; for more detail.</source>
          <target state="translated">这将导致 &lt;code&gt;TAP::Parser&lt;/code&gt; 将自定义配置传递给两个内置源处理程序&lt;a href=&quot;TAP::Parser::SourceHandler::Perl&quot;&gt;-TAP :: Parser :: SourceHandler :: Perl&lt;/a&gt;，&lt;a href=&quot;TAP::Parser::SourceHandler::File&quot;&gt;TAP :: Parser :: SourceHandler :: File-&lt;/a&gt;并尝试加载 &lt;code&gt;MyCustom&lt;/code&gt; 类。有关更多详细信息，请参见&lt;a href=&quot;TAP::Parser::IteratorFactory#load_handlers&quot;&gt;TAP :: Parser :: IteratorFactory中的&amp;ldquo; load_handlers&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b1923af4c70dd0486d19861010f7f67dda0840b" translate="yes" xml:space="preserve">
          <source>This will cause &lt;code&gt;TAP::Parser&lt;/code&gt; to pass custom configuration to two of the built- in source handlers - &lt;a href=&quot;parser/sourcehandler/perl&quot;&gt;TAP::Parser::SourceHandler::Perl&lt;/a&gt;, &lt;a href=&quot;parser/sourcehandler/file&quot;&gt;TAP::Parser::SourceHandler::File&lt;/a&gt; - and attempt to load the &lt;code&gt;MyCustom&lt;/code&gt; class. See &lt;a href=&quot;parser/iteratorfactory#load_handlers&quot;&gt;load_handlers in TAP::Parser::IteratorFactory&lt;/a&gt; for more detail.</source>
          <target state="translated">这将导致 &lt;code&gt;TAP::Parser&lt;/code&gt; 将自定义配置传递给两个内置源处理程序&lt;a href=&quot;parser/sourcehandler/perl&quot;&gt;-TAP :: Parser :: SourceHandler :: Perl&lt;/a&gt;，&lt;a href=&quot;parser/sourcehandler/file&quot;&gt;TAP :: Parser :: SourceHandler :: File-&lt;/a&gt;并尝试加载 &lt;code&gt;MyCustom&lt;/code&gt; 类。有关更多详细信息，请参见&lt;a href=&quot;parser/iteratorfactory#load_handlers&quot;&gt;TAP :: Parser :: IteratorFactory中的load_handlers&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b1f393b5aa15620c16e7dffc32aa8ea367c1f0a" translate="yes" xml:space="preserve">
          <source>This will cause Perl with the prebuilt @INC of</source>
          <target state="translated">这将导致Perl中预置的@INC为</target>
        </trans-unit>
        <trans-unit id="76fec5adda9b5970b64c5f42a2c8bf602e1ee608" translate="yes" xml:space="preserve">
          <source>This will cause the data array ref to be removed, allowing normal garbage collection to clean it up. With AnyEvent, that will cause $data-&amp;gt;[0] to be cleaned up, and AnyEvent will automatically cancel the watcher at that time. If another loop requires more than that to clean up a file watcher, that will be up to the caller to handle.</source>
          <target state="translated">这将导致删除数据数组ref，从而允许正常的垃圾收集对其进行清理。使用AnyEvent，这将导致$ data-&amp;gt; [0]被清除，并且AnyEvent将在那时自动取消观察程序。如果另一个循环需要更多来清理文件监视程序，则将由调用程序来处理。</target>
        </trans-unit>
        <trans-unit id="a4504afe5839985c9ade0a7b670cc6581df005e9" translate="yes" xml:space="preserve">
          <source>This will completely remove all hubs from the stack. Normally you do not want to do this, but there are a few valid reasons for it.</source>
          <target state="translated">这将从堆栈中完全移除所有的轮毂。通常情况下,你不希望这样做,但有几个合理的理由。</target>
        </trans-unit>
        <trans-unit id="67ac58793459c7b76692726a54173eedfed44523" translate="yes" xml:space="preserve">
          <source>This will copy the newly compiled perl and libraries into your DJGPP directory structure. Perl.exe and the utilities go into &lt;code&gt;($DJDIR)/bin&lt;/code&gt; , and the library goes under &lt;code&gt;($DJDIR)/lib/perl5&lt;/code&gt; . The pod documentation goes under &lt;code&gt;($DJDIR)/lib/perl5/pod&lt;/code&gt; .</source>
          <target state="translated">这会将新编译的perl和库复制到DJGPP目录结构中。Perl.exe和实用程序进入 &lt;code&gt;($DJDIR)/bin&lt;/code&gt; ，库进入 &lt;code&gt;($DJDIR)/lib/perl5&lt;/code&gt; 。pod文档位于 &lt;code&gt;($DJDIR)/lib/perl5/pod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49d297ec8066b67d0ab35aa053302ca08ef1299d" translate="yes" xml:space="preserve">
          <source>This will copy the newly compiled perl and libraries into your DJGPP directory structure. Perl.exe and the utilities go into &lt;code&gt;($DJDIR)/bin&lt;/code&gt;, and the library goes under &lt;code&gt;($DJDIR)/lib/perl5&lt;/code&gt;. The pod documentation goes under &lt;code&gt;($DJDIR)/lib/perl5/pod&lt;/code&gt;.</source>
          <target state="translated">这会将新编译的perl和库复制到DJGPP目录结构中。Perl.exe和实用程序进入 &lt;code&gt;($DJDIR)/bin&lt;/code&gt; ，库进入 &lt;code&gt;($DJDIR)/lib/perl5&lt;/code&gt; 。pod文档位于 &lt;code&gt;($DJDIR)/lib/perl5/pod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="064ccc6e75634bb34bbc9459a4eee07115444768" translate="yes" xml:space="preserve">
          <source>This will create a new empty stack instance. All arguments are ignored.</source>
          <target state="translated">这将创建一个新的空栈实例。所有参数都被忽略。</target>
        </trans-unit>
        <trans-unit id="0ded09f0f6527aa84cb6b52847b25c42890b11fc" translate="yes" xml:space="preserve">
          <source>This will create a new thread that will begin execution with the specified entry point function, and give it the</source>
          <target state="translated">这将创建一个新的线程,该线程将从指定的入口点函数开始执行,并给它以</target>
        </trans-unit>
        <trans-unit id="5da6c9768fadd258537254d703795cd0330cf3a4" translate="yes" xml:space="preserve">
          <source>This will create an &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2::Event::Ok&lt;/a&gt; object for you. If &lt;code&gt;$bool&lt;/code&gt; is false then an &lt;a href=&quot;Test2::Event::Diag&quot;&gt;Test2::Event::Diag&lt;/a&gt; event will be sent as well with details about the failure. If you do not want automatic diagnostics you should use the &lt;code&gt;send_event()&lt;/code&gt; method directly.</source>
          <target state="translated">这将为您创建一个&lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2 :: Event :: Ok&lt;/a&gt;对象。如果 &lt;code&gt;$bool&lt;/code&gt; 为false，则将发送&lt;a href=&quot;Test2::Event::Diag&quot;&gt;Test2 :: Event :: Diag&lt;/a&gt;事件以及有关失败的详细信息。如果您不希望进行自动诊断，则应直接使用 &lt;code&gt;send_event()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="7feae50769e88d3667c6e843c8c3f60be4ca7ae4" translate="yes" xml:space="preserve">
          <source>This will create objects with numbers stored in two different backend libraries, and &lt;b&gt;VERY BAD THINGS&lt;/b&gt; will happen when you use these together:</source>
          <target state="translated">这将创建带有存储在两个不同后端库中的数字的对象，并且将它们一起使用会发生&lt;b&gt;非常糟糕的&lt;/b&gt;事情：</target>
        </trans-unit>
        <trans-unit id="3b0d8d3754e191837d6089eefe1c10fd8b43be6c" translate="yes" xml:space="preserve">
          <source>This will create the new directory &lt;code&gt;($DJDIR)/Text-CSV-0.01&lt;/code&gt; , filling it with the source for this module.</source>
          <target state="translated">这将创建新目录 &lt;code&gt;($DJDIR)/Text-CSV-0.01&lt;/code&gt; ，并用该模块的源代码填充它。</target>
        </trans-unit>
        <trans-unit id="bbe19c29c1fd71ec20d33df3c3d7fcbef3a7ea1a" translate="yes" xml:space="preserve">
          <source>This will create the new directory &lt;code&gt;($DJDIR)/Text-CSV-0.01&lt;/code&gt;, filling it with the source for this module.</source>
          <target state="translated">这将创建新目录 &lt;code&gt;($DJDIR)/Text-CSV-0.01&lt;/code&gt; ，并用该模块的源代码填充它。</target>
        </trans-unit>
        <trans-unit id="dc361eb19a041a374d3eb78b53745450afadf9b1" translate="yes" xml:space="preserve">
          <source>This will decode the command line arguments to perl (the &lt;code&gt;@ARGV&lt;/code&gt; array) in-place.</source>
          <target state="translated">这将就地将命令行参数解码为perl（ &lt;code&gt;@ARGV&lt;/code&gt; 数组）。</target>
        </trans-unit>
        <trans-unit id="0492d7e2f7ae4ff241ecd4e3581f4b8beed997ff" translate="yes" xml:space="preserve">
          <source>This will display a line like this:</source>
          <target state="translated">这将显示这样一行字。</target>
        </trans-unit>
        <trans-unit id="179f02e4ac0dea4bbf8e34372089742f745f888c" translate="yes" xml:space="preserve">
          <source>This will do some preprocessing then run the Configure script for you. The Configure script is interactive, but in most cases you just need to press ENTER. The &quot;set&quot; command ensures that DJGPP preserves the letter case of file names when reading directories. If you already issued this set command when unpacking the archive, and you are in the same DOS session as when you unpacked the archive, you don't have to issue the set command again. This command is necessary *before* you start to (re)configure or (re)build perl in order to ensure both that perl builds correctly and that building XS-type modules can succeed. See the DJGPP info entry for &quot;_preserve_fncase&quot; for more information:</source>
          <target state="translated">这将进行一些预处理,然后为你运行配置脚本。配置脚本是交互式的,但在大多数情况下,您只需按回车键即可。set &quot;命令确保DJGPP在读取目录时保留文件名的字母大小写。如果您在解压归档时已经发出了这个set命令,并且您与解压归档时处于同一个DOS会话中,您不必再次发出set命令。在*开始(re)配置或(re)构建perl之前,这个命令是必要的,以确保perl正确构建,并确保构建XS型模块能够成功。更多信息请参见DJGPP信息条目&quot;_preserve_fncase&quot;。</target>
        </trans-unit>
        <trans-unit id="675c6b6318fd0296508995ff2fb40f1a73999db5" translate="yes" xml:space="preserve">
          <source>This will do the same as the above example, along with printing additional arguments for linking with the &lt;code&gt;Socket&lt;/code&gt; extension.</source>
          <target state="translated">这将与上面的示例相同，并打印用于与 &lt;code&gt;Socket&lt;/code&gt; 扩展链接的其他参数。</target>
        </trans-unit>
        <trans-unit id="94a2b2e485b64f8289df8501ad4445804a71f181" translate="yes" xml:space="preserve">
          <source>This will export the symbols one level 'above' the current package - ie: to the program or module that used package A.</source>
          <target state="translated">这将导出比当前包高一级的符号--即:导出到使用包A的程序或模块中。</target>
        </trans-unit>
        <trans-unit id="8ac204334b95f4e740c8716e51afe8da1ef03360" translate="yes" xml:space="preserve">
          <source>This will generate a make fragment which runs the @cmds in the given $dir. The rough equivalent to this, except cross platform.</source>
          <target state="translated">这将生成一个make片段,在给定的$dir中运行@cmds。粗略等同于这个,除了跨平台。</target>
        </trans-unit>
        <trans-unit id="c676e0a391005b05f49486f88f52e026b3ba6394" translate="yes" xml:space="preserve">
          <source>This will generate a new hub and push it to the top of the stack. Optionally you can provide arguments that will be passed into the constructor for the &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt; object.</source>
          <target state="translated">这将生成一个新的集线器并将其推到堆栈的顶部。（可选）您可以提供将传递给&lt;a href=&quot;Test2::Hub&quot;&gt;Test2 :: Hub&lt;/a&gt;对象的构造函数的参数。</target>
        </trans-unit>
        <trans-unit id="4a8e38bf0f1124ee8cd2f4c246969afdbdca1fd0" translate="yes" xml:space="preserve">
          <source>This will generate a perl one-liner safe for the particular platform you're on based on the given $perl_code and @switches (a -e is assumed) suitable for using in a make target. It will use the proper shell quoting and escapes.</source>
          <target state="translated">这将根据给定的 $perl_code 和 @switches (假定有 -e)生成一个适合你所在的特定平台的 perl 单行代码,并适合在 make target 中使用。它将使用适当的shell引号和转义符。</target>
        </trans-unit>
        <trans-unit id="2fe60433bffca1c65e9d3e8cf9d5d49faaafa689" translate="yes" xml:space="preserve">
          <source>This will generate code for linking with &lt;code&gt;DynaLoader&lt;/code&gt; and each static extension found in &lt;code&gt;$Config{static_ext}&lt;/code&gt; . The code is written to the default file name</source>
          <target state="translated">这将生成用于与 &lt;code&gt;DynaLoader&lt;/code&gt; 和 &lt;code&gt;$Config{static_ext}&lt;/code&gt; 找到的每个静态扩展进行链接的代码。代码被写入默认文件名</target>
        </trans-unit>
        <trans-unit id="eec7c4e4f5fe3b6790a50a383deab47852630299" translate="yes" xml:space="preserve">
          <source>This will generate code for linking with &lt;code&gt;DynaLoader&lt;/code&gt; and each static extension found in &lt;code&gt;$Config{static_ext}&lt;/code&gt;. The code is written to the default file name</source>
          <target state="translated">这将生成用于与 &lt;code&gt;DynaLoader&lt;/code&gt; 和 &lt;code&gt;$Config{static_ext}&lt;/code&gt; 找到的每个静态扩展进行链接的代码。代码被写入默认文件名</target>
        </trans-unit>
        <trans-unit id="c6f2639aaf13d9987fd657edd9bdf38a6bb02bde" translate="yes" xml:space="preserve">
          <source>This will generate code with an &lt;code&gt;xs_init&lt;/code&gt; function that glues the perl &lt;code&gt;Socket::bootstrap&lt;/code&gt; function to the C &lt;code&gt;boot_Socket&lt;/code&gt; function and writes it to a file named</source>
          <target state="translated">这将使用 &lt;code&gt;xs_init&lt;/code&gt; 函数生成代码，该函数将perl &lt;code&gt;Socket::bootstrap&lt;/code&gt; 函数粘贴到C &lt;code&gt;boot_Socket&lt;/code&gt; 函数，并将其写入名为的文件中。</target>
        </trans-unit>
        <trans-unit id="44086860d79949a66a99005bb2fd2981ff4af4db" translate="yes" xml:space="preserve">
          <source>This will generate the following subs in your namespace:</source>
          <target state="translated">这将在你的命名空间中生成以下子。</target>
        </trans-unit>
        <trans-unit id="c7ad1387b149a78d9ba1b3b7e1d8beb42457553a" translate="yes" xml:space="preserve">
          <source>This will get the value for a specified meta &lt;code&gt;$key&lt;/code&gt;. Normally this will return &lt;code&gt;undef&lt;/code&gt; when there is no value for the &lt;code&gt;$key&lt;/code&gt;, however you can specify a &lt;code&gt;$default&lt;/code&gt; value to set when no value is already set.</source>
          <target state="translated">这将获得指定meta &lt;code&gt;$key&lt;/code&gt; 的值。通常，当 &lt;code&gt;$key&lt;/code&gt; 没有值时，它将返回 &lt;code&gt;undef&lt;/code&gt; ，但是您可以指定一个 &lt;code&gt;$default&lt;/code&gt; 值，以在未设置任何值的情况下进行设置。</target>
        </trans-unit>
        <trans-unit id="7eea9f6a9a0cddb272db87ac62953e746207d48b" translate="yes" xml:space="preserve">
          <source>This will get the value for a specified meta &lt;code&gt;$key&lt;/code&gt;. This does not have the &lt;code&gt;$default&lt;/code&gt; overhead that &lt;code&gt;meta()&lt;/code&gt; does.</source>
          <target state="translated">这将获得指定meta &lt;code&gt;$key&lt;/code&gt; 的值。它没有 &lt;code&gt;meta()&lt;/code&gt; 的 &lt;code&gt;$default&lt;/code&gt; 开销。</target>
        </trans-unit>
        <trans-unit id="f22691f1210ffc5ff46fde23f10fccdf3bbe7104" translate="yes" xml:space="preserve">
          <source>This will get/set the &lt;code&gt;terminate&lt;/code&gt; attribute. This defaults to undef in scalar context, or an empty list in list context. Setting this to undef will clear it completely. This must be set to a positive integer (0 or larger).</source>
          <target state="translated">这将获取/设置 &lt;code&gt;terminate&lt;/code&gt; 属性。在标量上下文中默认为undef，在列表上下文中默认为空列表。将此设置为undef将完全清除它。必须将其设置为正整数（0或更大）。</target>
        </trans-unit>
        <trans-unit id="cdd63235e2a6d84a12c5f4085006a244e21d9d51" translate="yes" xml:space="preserve">
          <source>This will go into the &lt;code&gt;build_requires&lt;/code&gt; field of your</source>
          <target state="translated">这将进入您的 &lt;code&gt;build_requires&lt;/code&gt; 字段</target>
        </trans-unit>
        <trans-unit id="b69aab99f02e831fdaf85f1e3ecb658a4bca7288" translate="yes" xml:space="preserve">
          <source>This will go into the &lt;code&gt;configure_requires&lt;/code&gt; field of your</source>
          <target state="translated">这将进入您的 &lt;code&gt;configure_requires&lt;/code&gt; 字段</target>
        </trans-unit>
        <trans-unit id="044f8f7fc28b6f913f2eb7261e1be2cd16a84799" translate="yes" xml:space="preserve">
          <source>This will go into the &lt;code&gt;requires&lt;/code&gt; field of your</source>
          <target state="translated">这将进入您的 &lt;code&gt;requires&lt;/code&gt; 字段</target>
        </trans-unit>
        <trans-unit id="7b80864e93830ef0ed83edd0adbf1c600a67743b" translate="yes" xml:space="preserve">
          <source>This will hold all the output of a command. It needs to be a reference to a scalar. Note that this will hold both the STDOUT and STDERR messages, and you have no way of telling which is which. If you require this distinction, run the &lt;code&gt;run&lt;/code&gt; command in list context and inspect the individual buffers.</source>
          <target state="translated">这将保留命令的所有输出。它必须是对标量的引用。请注意，这将同时保存STDOUT和STDERR消息，并且您无法分辨哪个是哪个。如果需要这种区别，请在列表上下文中 &lt;code&gt;run&lt;/code&gt; 命令并检查各个缓冲区。</target>
        </trans-unit>
        <trans-unit id="02c623985a1a7dc417e0a406fc6886bed2478d0f" translate="yes" xml:space="preserve">
          <source>This will indeed make the value &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, but if you try to modify the value of &lt;code&gt;key&lt;/code&gt; , you'll get the following error:</source>
          <target state="translated">这确实会使值 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，但如果尝试修改 &lt;code&gt;key&lt;/code&gt; 的值，则会出现以下错误：</target>
        </trans-unit>
        <trans-unit id="32d093230d8afd4dfa30e5b675bc05f84dd94d65" translate="yes" xml:space="preserve">
          <source>This will indeed make the value &lt;code&gt;undef&lt;/code&gt;, but if you try to modify the value of &lt;code&gt;key&lt;/code&gt;, you'll get the following error:</source>
          <target state="translated">这确实会使值 &lt;code&gt;undef&lt;/code&gt; ，但如果尝试修改 &lt;code&gt;key&lt;/code&gt; 的值，则会出现以下错误：</target>
        </trans-unit>
        <trans-unit id="6c59ff5ece51fef3713b13fdc203a334520a2680" translate="yes" xml:space="preserve">
          <source>This will indeed remove all references to destroyed objects, but the remaining references to objects will be strong, causing the remaining objects to never be destroyed because there is now always a strong reference to them in the @object array.</source>
          <target state="translated">这确实会删除所有对被销毁对象的引用,但剩下的对对象的引用将是强引用,导致剩下的对象永远不会被销毁,因为现在在@对象数组中总有一个对它们的强引用。</target>
        </trans-unit>
        <trans-unit id="502a4e7b5c19c4f943e0927f97d4e589d92242b6" translate="yes" xml:space="preserve">
          <source>This will install Perl, including</source>
          <target state="translated">这将安装Perl,包括</target>
        </trans-unit>
        <trans-unit id="5360f0733d6fa5a59167722a15beb5e5d0628299" translate="yes" xml:space="preserve">
          <source>This will install all files in the module under your home directory, with man pages and libraries going into an appropriate place (usually ~/man and ~/lib). How the exact location is determined is complicated and depends on how your Perl was configured. INSTALL_BASE works more like what other build systems call &quot;prefix&quot; than PREFIX and we recommend you use that instead.</source>
          <target state="translated">这将会把模块中的所有文件安装到你的主目录下,而手册和库则会安装到一个适当的位置 (通常是 ~/man 和 ~/lib)。具体位置如何确定是很复杂的,这取决于你的Perl是如何配置的。INSTALL_BASE 的工作原理更像是其他编译系统所说的 &quot;前缀&quot;,而不是 PREFIX,我们建议你用它来代替。</target>
        </trans-unit>
        <trans-unit id="c93de459956112e67c32897f139a786020e9ae92" translate="yes" xml:space="preserve">
          <source>This will install the module's architecture-independent files into ~/lib, the architecture-dependent files into ~/lib/$archname.</source>
          <target state="translated">这将会把模块中与架构无关的文件安装到~/lib中,与架构有关的文件安装到~/lib/$archname中。</target>
        </trans-unit>
        <trans-unit id="037930b84c250a860d75497404c0fa5cd777c91f" translate="yes" xml:space="preserve">
          <source>This will invoke &lt;code&gt;MyExpirePolicy-&amp;gt;TIEHASH(args)&lt;/code&gt; . MyExpirePolicy::TIEHASH should do whatever is appropriate to set up the cache, and it should return the cache object to the caller.</source>
          <target state="translated">这将调用 &lt;code&gt;MyExpirePolicy-&amp;gt;TIEHASH(args)&lt;/code&gt; 。MyExpirePolicy :: TIEHASH应该执行设置缓存的适当操作，并且应将缓存对象返回给调用方。</target>
        </trans-unit>
        <trans-unit id="a5a59c7a890c0f22a657cb40bc1da8408c4952ff" translate="yes" xml:space="preserve">
          <source>This will invoke &lt;code&gt;MyExpirePolicy-&amp;gt;TIEHASH(args)&lt;/code&gt;. MyExpirePolicy::TIEHASH should do whatever is appropriate to set up the cache, and it should return the cache object to the caller.</source>
          <target state="translated">这将调用 &lt;code&gt;MyExpirePolicy-&amp;gt;TIEHASH(args)&lt;/code&gt; 。MyExpirePolicy :: TIEHASH应该执行设置缓存的适当操作，并且应将缓存对象返回给调用方。</target>
        </trans-unit>
        <trans-unit id="8b7f85cc213a9528b5fae8654b1de379039b58cd" translate="yes" xml:space="preserve">
          <source>This will invoke the Perl script</source>
          <target state="translated">这将调用Perl脚本</target>
        </trans-unit>
        <trans-unit id="2d3ad41335ec2699e64793b18bdc830c93f34fd9" translate="yes" xml:space="preserve">
          <source>This will issue a warning from the file and line number of the context.</source>
          <target state="translated">这将从上下文的文件和行号发出警告。</target>
        </trans-unit>
        <trans-unit id="3d7846c6fc3f33f521fafde1ba9db4c27782855d" translate="yes" xml:space="preserve">
          <source>This will likely require many formatters to have tables mapping from treatable Unicode codepoints (such as the &quot;\xE9&quot; for the e-acute character) to the escape sequences or codes necessary for conveying such sequences in the target output format. A converter to *roff would, for example know that &quot;\xE9&quot; (whether conveyed literally, or via a E&amp;lt;...&amp;gt; sequence) is to be conveyed as &quot;e\\*'&quot;. Similarly, a program rendering Pod in a Mac OS application window, would presumably need to know that &quot;\xE9&quot; maps to codepoint 142 in MacRoman encoding that (at time of writing) is native for Mac OS. Such Unicode2whatever mappings are presumably already widely available for common output formats. (Such mappings may be incomplete! Implementers are not expected to bend over backwards in an attempt to render Cherokee syllabics, Etruscan runes, Byzantine musical symbols, or any of the other weird things that Unicode can encode.) And if a Pod document uses a character not found in such a mapping, the formatter should consider it an unrenderable character.</source>
          <target state="translated">这很可能需要许多格式化程序将表映射成可处理的Unicode代码点（例如e-acute字符的&amp;ldquo; \ xE9&amp;rdquo;）到转义序列或以目标输出格式传达此类序列所必需的代码。例如，* roff的转换器将知道&amp;ldquo; \ xE9&amp;rdquo;（无论是字面还是通过E &amp;lt;...&amp;gt;序列进行传输）都将作为&amp;ldquo; e \\ *'&amp;rdquo;进行传输。同样，在Mac OS应用程序窗口中呈现Pod的程序可能需要知道&amp;ldquo; \ xE9&amp;rdquo;映射到MacRoman编码的代码点142（在撰写本文时）是Mac OS固有的。此类Unicode2映射无论如何都可能已经广泛用于常见的输出格式。 （此类映射可能不完整！期望实现者不要弯腰去尝试呈现切诺基音节，伊特鲁里亚符文，拜占庭音乐符号或Unicode可以编码的任何其他奇怪的东西。 ，格式化程序应将其视为不可渲染的字符。</target>
        </trans-unit>
        <trans-unit id="b9af5931254814b66f0bff8fcce1663d48d23196" translate="yes" xml:space="preserve">
          <source>This will load the core of the Getopt::Long module and prepare your program for using it. Most of the actual Getopt::Long code is not loaded until you really call one of its functions.</source>
          <target state="translated">这将加载 Getopt::Long 模块的核心,并为使用它准备程序。大部分实际的 Getopt::Long 代码不会被加载,直到你真正调用它的一个函数。</target>
        </trans-unit>
        <trans-unit id="84613dc13583c880545edeaa7309fbaf7d904405" translate="yes" xml:space="preserve">
          <source>This will load the necessary things (like BigInt) when they are needed, and automatically.</source>
          <target state="translated">这将在需要的时候自动加载必要的东西(如BigInt)。</target>
        </trans-unit>
        <trans-unit id="7a6931f78851cb973cc9d65880d16fc9ed754cce" translate="yes" xml:space="preserve">
          <source>This will make a shallow clone of the facet. You may specify fields to override as arguments.</source>
          <target state="translated">这将使面的浅层克隆。您可以指定要覆盖的字段作为参数。</target>
        </trans-unit>
        <trans-unit id="9d8f3b44f04663247b0f9e8a7dffb832852e0f5e" translate="yes" xml:space="preserve">
          <source>This will match all non-Unicode code points, since every one of them is not in Kana. You can use intersection to exclude these, if desired, as this modified example shows:</source>
          <target state="translated">这将匹配所有非Unicode码点,因为每一个码点都不在Kana中。如果需要的话,您可以使用交集来排除这些码点,就像这个修改后的例子所示。</target>
        </trans-unit>
        <trans-unit id="944f02167d664ef9e70480a5d72868212b398166" translate="yes" xml:space="preserve">
          <source>This will match all the digit characters that are in the Thai script.</source>
          <target state="translated">这将匹配泰文中的所有数字字符。</target>
        </trans-unit>
        <trans-unit id="99b2cac7ea367f44702a2a2abb89101d039ec9d6" translate="yes" xml:space="preserve">
          <source>This will normally hide the current context for the top hub. If you need to hide the context for a different hub you can pass in the optional &lt;code&gt;$hid&lt;/code&gt; parameter.</source>
          <target state="translated">通常，这将隐藏顶部中心的当前上下文。如果您需要隐藏其他集线器的上下文，则可以传入可选的 &lt;code&gt;$hid&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="6273e23b6c541cdfeea4c27da4fef2152f6377e8" translate="yes" xml:space="preserve">
          <source>This will only show up under use strict (another good reason to run under use strict).</source>
          <target state="translated">这只会在使用严格的情况下出现(另一个在使用严格下运行的好理由)。</target>
        </trans-unit>
        <trans-unit id="c65fa159bab1e30bba712c2c1e9c30d9ac5133d7" translate="yes" xml:space="preserve">
          <source>This will optimize down to &lt;code&gt;&quot;foo&quot;&lt;/code&gt; , so &lt;code&gt;&quot;bar&quot;&lt;/code&gt; will never be considered (even though the rules say to use a smartmatch on &lt;code&gt;&quot;foo&quot;&lt;/code&gt; ). For an alternation like this, an array ref will work, because this will instigate smartmatching:</source>
          <target state="translated">这将优化为 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; ，因此将永远不会考虑 &lt;code&gt;&quot;bar&quot;&lt;/code&gt; （即使规则说要在 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 上使用smartmatch ）。对于这样的替换，数组引用将起作用，因为这将引发智能匹配：</target>
        </trans-unit>
        <trans-unit id="33deb2e289bee882cbf3028d1fec9799baf70dd3" translate="yes" xml:space="preserve">
          <source>This will optimize down to &lt;code&gt;&quot;foo&quot;&lt;/code&gt;, so &lt;code&gt;&quot;bar&quot;&lt;/code&gt; will never be considered (even though the rules say to use a smartmatch on &lt;code&gt;&quot;foo&quot;&lt;/code&gt;). For an alternation like this, an array ref will work, because this will instigate smartmatching:</source>
          <target state="translated">这将优化到 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; ，因此将永远不会考虑 &lt;code&gt;&quot;bar&quot;&lt;/code&gt; （即使规则说要在 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 上使用smartmatch ）。对于这样的替换，数组引用将起作用，因为这将引发智能匹配：</target>
        </trans-unit>
        <trans-unit id="4c8134855a16c717eaa6422187d170260e57cb1b" translate="yes" xml:space="preserve">
          <source>This will output only the &lt;code&gt;=head2 Algorithm&lt;/code&gt; heading and content within the &lt;code&gt;=head1 DESCRIPTION&lt;/code&gt; section. The regexp binding is stronger than the section separator, such that e.g.:</source>
          <target state="translated">这将输出仅 &lt;code&gt;=head2 Algorithm&lt;/code&gt; 的标题和内容的内 &lt;code&gt;=head1 DESCRIPTION&lt;/code&gt; 部分。regexp绑定比节分隔符更强，例如：</target>
        </trans-unit>
        <trans-unit id="a53b7fc46cab28aa51967ea901426700557399bc" translate="yes" xml:space="preserve">
          <source>This will pop a hub from the stack, if the hub at the top of the stack does not match the hub you expect (passed in as an argument) it will throw an exception.</source>
          <target state="translated">这将从堆栈中弹出一个轮毂,如果堆栈顶部的轮毂与你期望的轮毂不匹配(作为参数传入),它将抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="d8cbe9fcb0b43d3c677dc5305458ee2e62e4a31f" translate="yes" xml:space="preserve">
          <source>This will predeclare all the subroutine whose names are in the list, allowing you to use them without parentheses even before they're declared.</source>
          <target state="translated">这将预先声明所有名字在列表中的子程序,允许你在声明它们之前就不加括号地使用它们。</target>
        </trans-unit>
        <trans-unit id="d6c5fdfb9dbf5dd576a4fe59626b53e05f4e7d63" translate="yes" xml:space="preserve">
          <source>This will predeclare all the subroutines whose names are in the list, allowing you to use them without parentheses (as list operators) even before they're declared.</source>
          <target state="translated">这将预先声明所有名字在列表中的子程序,允许你在声明它们之前就不加括号地使用它们(作为列表操作符)。</target>
        </trans-unit>
        <trans-unit id="0485931e797f0d3157ea50aac95b26b852bb2c34" translate="yes" xml:space="preserve">
          <source>This will predeclare all the variables whose names are in the list, allowing you to use them under &quot;use strict&quot;, and disabling any typo warnings.</source>
          <target state="translated">这将预先声明所有名字在列表中的变量,允许你在 &quot;严格使用 &quot;下使用它们,并禁用任何排版警告。</target>
        </trans-unit>
        <trans-unit id="2ed7ee1155828d2b2b40b29d755792b670ff1874" translate="yes" xml:space="preserve">
          <source>This will print</source>
          <target state="translated">这将打印</target>
        </trans-unit>
        <trans-unit id="0c513de1733ecd2b8ffce2a2e048c7fdbe91583f" translate="yes" xml:space="preserve">
          <source>This will print -3, not -2 (as it would if you divide -5 by 2 and truncate the result).</source>
          <target state="translated">这将打印-3,而不是-2(就像你把-5除以2并截断结果一样)。</target>
        </trans-unit>
        <trans-unit id="e88a5abf01aa2eb9eaafc62c5178572c3f0dcb93" translate="yes" xml:space="preserve">
          <source>This will print a grouped list of Perl's functions, like the &lt;a href=&quot;../perlfunc#Perl-Functions-by-Category&quot;&gt;Perl Functions by Category in perlfunc&lt;/a&gt; section.</source>
          <target state="translated">这将打印Perl函数的分组列表，例如&lt;a href=&quot;../perlfunc#Perl-Functions-by-Category&quot;&gt;perlfunc&lt;/a&gt;部分中的Perl按类别分类的函数。</target>
        </trans-unit>
        <trans-unit id="e41583327bc9cc32aaa0b02aa5d9186e43155f80" translate="yes" xml:space="preserve">
          <source>This will print a grouped list of Perl's functions, like the &lt;a href=&quot;perlfunc#Perl-Functions-by-Category&quot;&gt;&quot;Perl Functions by Category&quot; in perlfunc&lt;/a&gt; section.</source>
          <target state="translated">这将打印Perl函数的分组列表，例如&lt;a href=&quot;perlfunc#Perl-Functions-by-Category&quot;&gt;perlfunc&lt;/a&gt;部分中的&amp;ldquo;按类别的Perl函数&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="06f3c28ca20ac2a91e7b3a25f9cd8948580e5a8c" translate="yes" xml:space="preserve">
          <source>This will print arguments for linking with &lt;code&gt;libperl&lt;/code&gt; and extensions found in &lt;code&gt;$Config{static_ext}&lt;/code&gt; . This includes libraries found in &lt;code&gt;$Config{libs}&lt;/code&gt; and the first ModuleName.a library for each extension that is found by searching &lt;code&gt;@INC&lt;/code&gt; or the path specified by the &lt;b&gt;-I&lt;/b&gt; option. In addition, when ModuleName.a is found, additional linker arguments are picked up from the</source>
          <target state="translated">这将打印用于链接 &lt;code&gt;libperl&lt;/code&gt; 的参数和 &lt;code&gt;$Config{static_ext}&lt;/code&gt; 扩展名。这包括在 &lt;code&gt;$Config{libs}&lt;/code&gt; 找到的库以及通过搜索 &lt;code&gt;@INC&lt;/code&gt; 或&lt;b&gt;-I&lt;/b&gt;选项指定的路径找到的每个扩展名的第一个ModuleName.a库。此外，找到ModuleName.a时，还会从</target>
        </trans-unit>
        <trans-unit id="e1a6cfe75b96e0fdc730bad6aa31b403693c30dc" translate="yes" xml:space="preserve">
          <source>This will print arguments for linking with &lt;code&gt;libperl&lt;/code&gt; and extensions found in &lt;code&gt;$Config{static_ext}&lt;/code&gt;. This includes libraries found in &lt;code&gt;$Config{libs}&lt;/code&gt; and the first ModuleName.a library for each extension that is found by searching &lt;code&gt;@INC&lt;/code&gt; or the path specified by the &lt;b&gt;-I&lt;/b&gt; option. In addition, when ModuleName.a is found, additional linker arguments are picked up from the</source>
          <target state="translated">这将打印用于链接 &lt;code&gt;libperl&lt;/code&gt; 的参数和 &lt;code&gt;$Config{static_ext}&lt;/code&gt; 扩展名。这包括在 &lt;code&gt;$Config{libs}&lt;/code&gt; 找到的库以及通过搜索 &lt;code&gt;@INC&lt;/code&gt; 或&lt;b&gt;-I&lt;/b&gt;选项指定的路径找到的每个扩展名的第一个ModuleName.a库。此外，找到ModuleName.a时，还会从</target>
        </trans-unit>
        <trans-unit id="4f60443610a43a49d5ead9ee72728dd61dc61c29" translate="yes" xml:space="preserve">
          <source>This will print only the content of &lt;code&gt;=head1 DESCRIPTION&lt;/code&gt; and the &lt;code&gt;=head2 Introduction&lt;/code&gt; sections, but no other &lt;code&gt;=head2&lt;/code&gt;, and no other &lt;code&gt;=head1&lt;/code&gt; either.</source>
          <target state="translated">这将只打印的内容 &lt;code&gt;=head1 DESCRIPTION&lt;/code&gt; 和 &lt;code&gt;=head2 Introduction&lt;/code&gt; 部分，但没有其他 &lt;code&gt;=head2&lt;/code&gt; ，并没有其他 &lt;code&gt;=head1&lt;/code&gt; 两种。</target>
        </trans-unit>
        <trans-unit id="672df04456226246b8abe50d62f0bbee0ad0889a" translate="yes" xml:space="preserve">
          <source>This will print out</source>
          <target state="translated">这将打印出</target>
        </trans-unit>
        <trans-unit id="0a53fd47cfa0cb2aa29facae441d5e18a6061c7b" translate="yes" xml:space="preserve">
          <source>This will print out a warning about overwriting Mytest2, but that's okay. Our files are stored in Mytest2/mylib, and will be untouched.</source>
          <target state="translated">这将打印出一个关于覆盖 Mytest2 的警告,但这没关系。我们的文件存储在 Mytest2/mylib 中,不会被触动。</target>
        </trans-unit>
        <trans-unit id="7bed74d2734f7ca79e0f367ce5a29d3b84e44af2" translate="yes" xml:space="preserve">
          <source>This will print...</source>
          <target state="translated">这将打印...</target>
        </trans-unit>
        <trans-unit id="6e363eb5c9d1e189e7877f05521713cb961f9afe" translate="yes" xml:space="preserve">
          <source>This will print:</source>
          <target state="translated">这将打印。</target>
        </trans-unit>
        <trans-unit id="899924678036d32490097cf13a3010a6c2e916cc" translate="yes" xml:space="preserve">
          <source>This will produce: &quot;&lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; &quot;</source>
          <target state="translated">这将产生：&amp;ldquo; &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="40197f89d9552ed2ed618b0a94d0da9bdd7f768c" translate="yes" xml:space="preserve">
          <source>This will produce: &quot;&lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt;&quot;</source>
          <target state="translated">这将产生：&amp;ldquo; &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="65d8f131a0962cd0151f9af4c7b366b97852fe0c" translate="yes" xml:space="preserve">
          <source>This will push the new hub onto the stack.</source>
          <target state="translated">这将把新的枢纽推到堆栈上。</target>
        </trans-unit>
        <trans-unit id="f9e190e6e848eda316c1f8903ac738aaf6f899b4" translate="yes" xml:space="preserve">
          <source>This will put modules into</source>
          <target state="translated">这将使模块进入</target>
        </trans-unit>
        <trans-unit id="7f52025f3fd591756e387158d1cd6ccc53bfb3a5" translate="yes" xml:space="preserve">
          <source>This will quote $text so it is interpreted literally in the shell.</source>
          <target state="translated">这将引用$text,所以它在shell中是按字面意思解释的。</target>
        </trans-unit>
        <trans-unit id="41f7aa0266df2687cdc027e0895ee05c3a8cf995" translate="yes" xml:space="preserve">
          <source>This will release the context. This runs cleanup tasks, and several important hooks. It will also restore &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$?&lt;/code&gt;, and &lt;code&gt;$@&lt;/code&gt; to what they were when the context was created.</source>
          <target state="translated">这将释放上下文。这将运行清理任务以及一些重要的钩子。它还将恢复 &lt;code&gt;$!&lt;/code&gt; ， &lt;code&gt;$?&lt;/code&gt; ，以及将 &lt;code&gt;$@&lt;/code&gt; 设置为创建上下文时的样子。</target>
        </trans-unit>
        <trans-unit id="cec316130454262fb9a931304c0dde874c470f8c" translate="yes" xml:space="preserve">
          <source>This will remove the value of a specified meta &lt;code&gt;$key&lt;/code&gt;. The old &lt;code&gt;$val&lt;/code&gt; will be returned.</source>
          <target state="translated">这将删除指定的meta &lt;code&gt;$key&lt;/code&gt; 的值。旧的 &lt;code&gt;$val&lt;/code&gt; 将被返回。</target>
        </trans-unit>
        <trans-unit id="07824cc0b4d23c3d3bb1cfda8a48de7d53df4bf2" translate="yes" xml:space="preserve">
          <source>This will reset the state of the incremental parser and will remove the parsed text from the input buffer so far. This is useful after &lt;code&gt;incr_parse&lt;/code&gt; died, in which case the input buffer and incremental parser state is left unchanged, to skip the text parsed so far and to reset the parse state.</source>
          <target state="translated">到目前为止，这将重置增量解析器的状态，并将已解析的文本从输入缓冲区中删除。在 &lt;code&gt;incr_parse&lt;/code&gt; 终止后，此功能很有用，在这种情况下，输入缓冲区和增量解析器状态保持不变，可以跳过到目前为止已解析的文本并重置解析状态。</target>
        </trans-unit>
        <trans-unit id="f1f61ad8e0b3eb41c5891bbe5a0d386a76431ba8" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;undef&lt;/code&gt; if the relationship cannot be checked, which happens if either event has an incomplete or missing trace. This will return &lt;code&gt;0&lt;/code&gt; if the traces are complete, but do not match. &lt;code&gt;1&lt;/code&gt; will be returned if there is a match.</source>
          <target state="translated">如果无法检查关系，则将返回 &lt;code&gt;undef&lt;/code&gt; ，如果任何一个事件的跟踪不完整或丢失，就会发生这种情况。如果跟踪完成但不匹配，则将返回 &lt;code&gt;0&lt;/code&gt; 。如果有匹配项，则返回 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fd2b879f129714bea8a682b5294c7417238be95" translate="yes" xml:space="preserve">
          <source>This will return a hashref of facet data. Each facet hash will be a shallow copy of the original.</source>
          <target state="translated">这将返回一个facet数据的哈希值。每个分面数据的哈希值将是原始数据的浅层拷贝。</target>
        </trans-unit>
        <trans-unit id="f59d5228b102dd5cbad2d2e6da168ec6245e7a05" translate="yes" xml:space="preserve">
          <source>This will return a shallow clone of the context. The shallow clone is safe to store for later.</source>
          <target state="translated">这将返回上下文的一个浅层克隆。这个浅层克隆是安全的,可以存储到以后。</target>
        </trans-unit>
        <trans-unit id="fe211d3e5a7b27ac06f1bfed9d79529a0b4e0811" translate="yes" xml:space="preserve">
          <source>This will return all the hubs in the stack as a list.</source>
          <target state="translated">这将以列表的形式返回堆栈中的所有枢纽。</target>
        </trans-unit>
        <trans-unit id="a3fa038bab0a35a1278c1028a76b1b599ab2f3c7" translate="yes" xml:space="preserve">
          <source>This will return the</source>
          <target state="translated">这将返回</target>
        </trans-unit>
        <trans-unit id="3012b886e66f0d66b1233e77e03322a89d9ca8d0" translate="yes" xml:space="preserve">
          <source>This will return the 'about' facet hashref.</source>
          <target state="translated">这将返回 &quot;关于 &quot;facet的hashref。</target>
        </trans-unit>
        <trans-unit id="9d3892ab0e68676392aba5a3deb55d6e5f3a7a00" translate="yes" xml:space="preserve">
          <source>This will return the 'trace' facet, normally blessed (but this is not enforced when the trace is set using &lt;code&gt;set_trace()&lt;/code&gt;.</source>
          <target state="translated">这将返回通常具有祝福的&amp;ldquo;跟踪&amp;rdquo;构面（但使用 &lt;code&gt;set_trace()&lt;/code&gt; 设置跟踪时不会强制执行此构面。</target>
        </trans-unit>
        <trans-unit id="6c947246a8100b62a64074ea3ea27340d97e5c57" translate="yes" xml:space="preserve">
          <source>This will return the &lt;a href=&quot;Test2::API::Stack&quot;&gt;Test2::API::Stack&lt;/a&gt; instance the context used to find the current hub.</source>
          <target state="translated">这将返回&lt;a href=&quot;Test2::API::Stack&quot;&gt;Test2 :: API :: Stack&lt;/a&gt;实例的上下文，该上下文用于查找当前中心。</target>
        </trans-unit>
        <trans-unit id="071d70de3cfed7ceb62bef529de3f7a12de2cf57" translate="yes" xml:space="preserve">
          <source>This will return the &lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2::EventFacet::Trace&lt;/a&gt; instance used by the context.</source>
          <target state="translated">这将返回上下文使用的&lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2 :: EventFacet :: Trace&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="7c1e2a334411bcce7d3ed6759e85d7774c7db84a" translate="yes" xml:space="preserve">
          <source>This will return the &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt; instance the context recognizes as the current one to which all events should be sent.</source>
          <target state="translated">这将返回&lt;a href=&quot;Test2::Hub&quot;&gt;Test2 :: Hub&lt;/a&gt;实例，上下文将其识别为所有事件都应发送到的当前实例。</target>
        </trans-unit>
        <trans-unit id="2912d0daea2e211af97d7e1a3ea98a0298d18c0b" translate="yes" xml:space="preserve">
          <source>This will return the filename based on the template but will not open this file. Cannot be used in conjunction with UNLINK set to true. Default is to always open the file to protect from possible race conditions. A warning is issued if warnings are turned on. Consider using the tmpnam() and mktemp() functions described elsewhere in this document if opening the file is not required.</source>
          <target state="translated">这将返回基于模板的文件名,但不会打开这个文件。不能与UNLINK设置为true时一起使用。默认值是始终打开文件,以防止可能的竞赛条件。如果开启了警告,则会发出警告。如果不需要打开文件,可以考虑使用本文档其他地方介绍的tmpnam()和mktemp()函数。</target>
        </trans-unit>
        <trans-unit id="5166921abcf19f440f3497ae7dcd12be03f7bc28" translate="yes" xml:space="preserve">
          <source>This will return the global &lt;a href=&quot;Test2::API::Stack&quot;&gt;Test2::API::Stack&lt;/a&gt; instance. If this has not yet been initialized it will be initialized now.</source>
          <target state="translated">这将返回全局&lt;a href=&quot;Test2::API::Stack&quot;&gt;Test2 :: API :: Stack&lt;/a&gt;实例。如果尚未初始化，则将立即初始化。</target>
        </trans-unit>
        <trans-unit id="a995f385670c66d0da520343be6badafb9165a59" translate="yes" xml:space="preserve">
          <source>This will return the global &lt;a href=&quot;Test2::IPC::Driver&quot;&gt;Test2::IPC::Driver&lt;/a&gt; instance. If this has not yet been initialized it will be initialized now.</source>
          <target state="translated">这将返回全局&lt;a href=&quot;Test2::IPC::Driver&quot;&gt;Test2 :: IPC :: Driver&lt;/a&gt;实例。如果尚未初始化，则将立即初始化。</target>
        </trans-unit>
        <trans-unit id="d642486b0fdba840f586862b0632bdfe7b784cf3" translate="yes" xml:space="preserve">
          <source>This will return the global formatter class. This is not an instance. By default the formatter is set to &lt;a href=&quot;Test2::Formatter::TAP&quot;&gt;Test2::Formatter::TAP&lt;/a&gt;.</source>
          <target state="translated">这将返回全局格式化程序类。这不是实例。默认情况下，格式化程序设置为&lt;a href=&quot;Test2::Formatter::TAP&quot;&gt;Test2 :: Formatter :: TAP&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a43701025bcaaa97f4c20a7fae8b7f58307dc924" translate="yes" xml:space="preserve">
          <source>This will return the id of the current thread when threads are enabled, otherwise it returns 0.</source>
          <target state="translated">当线程启用时,将返回当前线程的id,否则返回0。</target>
        </trans-unit>
        <trans-unit id="a95636615c967951a75f0745e419202e8c181663" translate="yes" xml:space="preserve">
          <source>This will return the key for the facet in the facet data hash.</source>
          <target state="translated">这将返回分面数据哈希中分面的密钥。</target>
        </trans-unit>
        <trans-unit id="d82f0a6881fcf3d362a2caae5716b353b8c09bb4" translate="yes" xml:space="preserve">
          <source>This will return the top hub from the stack. If there is no top hub yet this will create it.</source>
          <target state="translated">这将从堆栈中返回顶部枢纽。如果还没有顶部集线器,这将创建它。</target>
        </trans-unit>
        <trans-unit id="c9d0e21b9306afe027cffc8be7eb5a1ef6fdaafd" translate="yes" xml:space="preserve">
          <source>This will return the top hub from the stack. If there is no top hub yet this will return undef.</source>
          <target state="translated">这将返回堆栈中的顶部枢纽。如果还没有顶级枢纽,将返回undef。</target>
        </trans-unit>
        <trans-unit id="626d4c923543f739ced5a5a4133e42da29976f88" translate="yes" xml:space="preserve">
          <source>This will return true if testing is complete and no other events should be sent. This is useful in things like warning handlers where you might want to turn warnings into events, but need them to start acting like normal warnings when testing is done.</source>
          <target state="translated">如果测试已经完成,并且没有其他事件应该被发送,那么这个值将返回true。这对于像警告处理程序这样的东西很有用,你可能想把警告变成事件,但需要在测试完成后让它们像正常的警告一样行动。</target>
        </trans-unit>
        <trans-unit id="dc9e1cf54480f23b5df8c08401a8eff218ed9c89" translate="yes" xml:space="preserve">
          <source>This will return true if the facet should be in a list instead of a single item.</source>
          <target state="translated">如果facet应该在一个列表中而不是在一个单项中,则会返回true。</target>
        </trans-unit>
        <trans-unit id="058b4ba4b9036eb7bc1ad3260ce86f253167e2de" translate="yes" xml:space="preserve">
          <source>This will return true if the stack and IPC instances have already been initialized. It will return false if they have not. Init happens as late as possible. It happens as soon as a tool requests the IPC instance, the formatter, or the stack.</source>
          <target state="translated">如果堆栈和IPC实例已经被初始化,则返回true。如果它们没有被初始化,则返回false。尽可能晚发生初始化。一旦工具请求IPC实例、formatter或堆栈,它就会发生。</target>
        </trans-unit>
        <trans-unit id="afb834590329aede62a7b1a0c021d221b2c6d004" translate="yes" xml:space="preserve">
          <source>This will run Configure and keep a record:</source>
          <target state="translated">这将运行配置并保持记录。</target>
        </trans-unit>
        <trans-unit id="af9c0543615ac7cf90353b4a24138697b5df455b" translate="yes" xml:space="preserve">
          <source>This will run the provided codeblock with the args in &lt;code&gt;@args&lt;/code&gt;. This codeblock will be run as a subtest. A subtest is an isolated test state that is condensed into a single &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2::Event::Subtest&lt;/a&gt; event, which contains all events generated inside the subtest.</source>
          <target state="translated">这将使用 &lt;code&gt;@args&lt;/code&gt; 中的args运行提供的代码块。此代码块将作为子测试运行。子测试是一个隔离的测试状态，被压缩为单个&lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2 :: Event :: Subtest&lt;/a&gt;事件，其中包含子测试内部生成的所有事件。</target>
        </trans-unit>
        <trans-unit id="3ec88525a1d6ccafa3d30457de14d7bad4de11c0" translate="yes" xml:space="preserve">
          <source>This will search for a module named &lt;code&gt;App::Prove::Plugin::MyPlugin&lt;/code&gt; , or failing that, &lt;code&gt;MyPlugin&lt;/code&gt; . If the plugin can't be found, &lt;code&gt;prove&lt;/code&gt; will complain &amp;amp; exit.</source>
          <target state="translated">这将搜索名为 &lt;code&gt;App::Prove::Plugin::MyPlugin&lt;/code&gt; 的模块，否则将搜索 &lt;code&gt;MyPlugin&lt;/code&gt; 。如果找不到该插件，则 &lt;code&gt;prove&lt;/code&gt; 将投诉并退出。</target>
        </trans-unit>
        <trans-unit id="5e687f1f0bf9f59f044484eb486936cdf9e849ac" translate="yes" xml:space="preserve">
          <source>This will search for a module named &lt;code&gt;App::Prove::Plugin::MyPlugin&lt;/code&gt;, or failing that, &lt;code&gt;MyPlugin&lt;/code&gt;. If the plugin can't be found, &lt;code&gt;prove&lt;/code&gt; will complain &amp;amp; exit.</source>
          <target state="translated">这将搜索名为 &lt;code&gt;App::Prove::Plugin::MyPlugin&lt;/code&gt; 的模块，否则将搜索 &lt;code&gt;MyPlugin&lt;/code&gt; 。如果找不到该插件，则 &lt;code&gt;prove&lt;/code&gt; 将投诉并退出。</target>
        </trans-unit>
        <trans-unit id="f30c710e3d8112c1044077c8cf0f284dc043fe97" translate="yes" xml:space="preserve">
          <source>This will send and return an &lt;a href=&quot;Test2::Event::Pass&quot;&gt;Test2::Event::Pass&lt;/a&gt; event. You may optionally provide a &lt;code&gt;$name&lt;/code&gt; for the assertion.</source>
          <target state="translated">这将发送并返回一个&lt;a href=&quot;Test2::Event::Pass&quot;&gt;Test2 :: Event :: Pass&lt;/a&gt;事件。您可以选择为断言提供 &lt;code&gt;$name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6032dd11dd54e4e97302369ddf59357d7575753c" translate="yes" xml:space="preserve">
          <source>This will set &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$?&lt;/code&gt;, and &lt;code&gt;$@&lt;/code&gt; to what they were when the context was created. There is no localization or anything done here, calling this method will actually set these vars.</source>
          <target state="translated">这将设置 &lt;code&gt;$!&lt;/code&gt; ， &lt;code&gt;$?&lt;/code&gt; ，以及将 &lt;code&gt;$@&lt;/code&gt; 设置为创建上下文时的样子。这里没有本地化或完成任何操作，调用此方法实际上将设置这些变量。</target>
        </trans-unit>
        <trans-unit id="53857214badcaa71270373a4350b085fd3be23d6" translate="yes" xml:space="preserve">
          <source>This will set the value, but it will also warn you that the method is deprecated.</source>
          <target state="translated">这将设置该值,但它也会警告你该方法已被废弃。</target>
        </trans-unit>
        <trans-unit id="9f2435be0f1ad6eda0969960399156643c76c7a4" translate="yes" xml:space="preserve">
          <source>This will silence warnings from this module, as shown above.</source>
          <target state="translated">如上图所示,这将使该模块的警告静音。</target>
        </trans-unit>
        <trans-unit id="ca31d9fb831c9a9410b0952a2719e1cdb223f34f" translate="yes" xml:space="preserve">
          <source>This will simply return the boolean value of the loaded flag. If Test2 has finished loading this will be true, otherwise false. Loading is considered complete the first time a tool requests a context.</source>
          <target state="translated">这将简单地返回加载标志的布尔值。如果Test2已经完成加载,这个值将为true,否则为false。当工具第一次请求上下文时,加载就被认为是完成了。</target>
        </trans-unit>
        <trans-unit id="74d8c906bb8ef849bacade7aef9b4a5b44d353f1" translate="yes" xml:space="preserve">
          <source>This will still print 10, not 20. Remember that local() affects package variables, which are all &quot;global&quot; to the package.</source>
          <target state="translated">这仍然会打印10,而不是20。请记住,local()会影响包的变量,而这些变量都是包的全局变量。</target>
        </trans-unit>
        <trans-unit id="2a6fcacb9fbe4a51fd646facf84bbf9e55589d63" translate="yes" xml:space="preserve">
          <source>This will terminate if the file is undeletable for some reason (protected, not there, and so on).</source>
          <target state="translated">如果文件因某种原因无法删除(受保护的,不存在的,等等),这将终止。</target>
        </trans-unit>
        <trans-unit id="feff36db777feae7b7039051928fb49050eaab4e" translate="yes" xml:space="preserve">
          <source>This will terminate if the file is undeleteable for some reason (protected, not there, and so on).</source>
          <target state="translated">如果文件因某种原因无法删除(受保护的,不存在的,等等),这将终止。</target>
        </trans-unit>
        <trans-unit id="7ffb822c298702a56540cec9f5d17292e8f99429" translate="yes" xml:space="preserve">
          <source>This will throw an exception reporting to the file and line number of the context. This will also release the context for you.</source>
          <target state="translated">这将抛出一个异常,报告上下文的文件和行号。这也将为你释放上下文。</target>
        </trans-unit>
        <trans-unit id="d039d7ba20b83e75e45e1330e7ddf21cf6828e15" translate="yes" xml:space="preserve">
          <source>This will try to load a module &lt;code&gt;ExtUtils::Typemaps::Excommunicated&lt;/code&gt; and use it as an &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; subclass. If that fails, it'll try loading &lt;code&gt;Excommunicated&lt;/code&gt; as a module, if that fails, it'll try to read a file called</source>
          <target state="translated">这将尝试加载模块 &lt;code&gt;ExtUtils::Typemaps::Excommunicated&lt;/code&gt; 并将其用作 &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; 子类。如果失败，它将尝试将 &lt;code&gt;Excommunicated&lt;/code&gt; 作为模块加载，如果失败，则将尝试读取名为</target>
        </trans-unit>
        <trans-unit id="1bd914f7804d4417b7bb5813b67988d44deeaf55" translate="yes" xml:space="preserve">
          <source>This will try to read &lt;code&gt;&quot;unicore/pro_alias.pl&quot;&lt;/code&gt; from the &lt;code&gt;@INC&lt;/code&gt; path. This file should return a list in plain perl:</source>
          <target state="translated">这将尝试从 &lt;code&gt;@INC&lt;/code&gt; 路径读取 &lt;code&gt;&quot;unicore/pro_alias.pl&quot;&lt;/code&gt; 。此文件应以纯Perl返回列表：</target>
        </trans-unit>
        <trans-unit id="77f2b91fc53461e4232392b6bf05a6cab13fc62c" translate="yes" xml:space="preserve">
          <source>This will turn off result long-term storage. Calling this method will make &lt;code&gt;details&lt;/code&gt; and &lt;code&gt;summary&lt;/code&gt; useless. You may want to use this if you are running enough tests to fill up all available memory.</source>
          <target state="translated">这将关闭结果长期存储。调用此方法将使 &lt;code&gt;details&lt;/code&gt; 和 &lt;code&gt;summary&lt;/code&gt; 无用。如果您正在运行足够的测试以填充所有可用内存，则可能要使用此功能。</target>
        </trans-unit>
        <trans-unit id="14ef65510ce174baa0db67a974cf806364df6c54" translate="yes" xml:space="preserve">
          <source>This will unblock any thread that is blocked trying to &lt;code&gt;down&lt;/code&gt; the semaphore if the &lt;code&gt;up&lt;/code&gt; raises the semaphore's count above the amount that the &lt;code&gt;down&lt;/code&gt; is trying to decrement it by. For example, if three threads are blocked trying to &lt;code&gt;down&lt;/code&gt; a semaphore by one, and another thread &lt;code&gt;up&lt;/code&gt; s the semaphore by two, then two of the blocked threads (which two is indeterminate) will become unblocked.</source>
          <target state="translated">这将解除被阻止试图任何线程 &lt;code&gt;down&lt;/code&gt; 的信号，如果 &lt;code&gt;up&lt;/code&gt; 提升的量上述信号灯的计数 &lt;code&gt;down&lt;/code&gt; 正试图通过减小数字。例如，如果三个线程被阻塞试图 &lt;code&gt;down&lt;/code&gt; 一个信号量由一个，而另一个线程 &lt;code&gt;up&lt;/code&gt; S按两个信号量，那么两个阻塞的线程的（其中两个是不确定的）将变得畅通。</target>
        </trans-unit>
        <trans-unit id="2291862c9d641fb23bcd9328e8bf9135209ce8c7" translate="yes" xml:space="preserve">
          <source>This will unblock any thread that is blocked trying to &lt;code&gt;down&lt;/code&gt; the semaphore if the &lt;code&gt;up&lt;/code&gt; raises the semaphore's count above the amount that the &lt;code&gt;down&lt;/code&gt; is trying to decrement it by. For example, if three threads are blocked trying to &lt;code&gt;down&lt;/code&gt; a semaphore by one, and another thread &lt;code&gt;up&lt;/code&gt;s the semaphore by two, then two of the blocked threads (which two is indeterminate) will become unblocked.</source>
          <target state="translated">这将解除被阻止试图任何线程 &lt;code&gt;down&lt;/code&gt; 的信号，如果 &lt;code&gt;up&lt;/code&gt; 提升的量上述信号灯的计数 &lt;code&gt;down&lt;/code&gt; 正试图通过减小数字。例如，如果三个线程被阻塞试图 &lt;code&gt;down&lt;/code&gt; 一个信号量由一个，而另一个线程 &lt;code&gt;up&lt;/code&gt; S按两个信号量，那么两个阻塞的线程的（其中两个是不确定的）将变得畅通。</target>
        </trans-unit>
        <trans-unit id="6f351c4b6aca96e53a16da8efca1e61fe6247c18" translate="yes" xml:space="preserve">
          <source>This will use miniperl to complete the rest of the build.</source>
          <target state="translated">这将使用miniperl来完成其余的构建。</target>
        </trans-unit>
        <trans-unit id="c16d64a3c76763b9210f27c1d7475ba78b790318" translate="yes" xml:space="preserve">
          <source>This will wait for the corresponding thread to complete its execution. When the thread finishes, &lt;code&gt;-&amp;gt;join()&lt;/code&gt; will return the return value(s) of the entry point function.</source>
          <target state="translated">这将等待相应的线程完成其执行。线程完成后， &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 将返回入口点函数的返回值。</target>
        </trans-unit>
        <trans-unit id="2af730ddaf4e289f57edfe5d0943ccf22cf812f6" translate="yes" xml:space="preserve">
          <source>This won't expand &lt;code&gt;&quot;\n&quot;&lt;/code&gt; or &lt;code&gt;&quot;\t&quot;&lt;/code&gt; or any other special escapes.</source>
          <target state="translated">这不会扩展 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;\t&quot;&lt;/code&gt; 或任何其他特殊的转义符。</target>
        </trans-unit>
        <trans-unit id="f64d878770a911b3e3aee44ed6986ddc7e345565" translate="yes" xml:space="preserve">
          <source>This work is published from Taiwan.</source>
          <target state="translated">本作品由台湾出版。</target>
        </trans-unit>
        <trans-unit id="d34159428b026fd2a257dac5cc4d16c93aa663f8" translate="yes" xml:space="preserve">
          <source>This workaround is unnecessary since Unicode 6.3.0.</source>
          <target state="translated">从Unicode 6.3.0开始,这个变通方法就没有必要了。</target>
        </trans-unit>
        <trans-unit id="8c1458dfe63303a12ab8e9dcbe389526ca2f043c" translate="yes" xml:space="preserve">
          <source>This works</source>
          <target state="translated">这个工作</target>
        </trans-unit>
        <trans-unit id="881dcb6cd52e1e6c1fe3d0de8f69b6f16afcd3ed" translate="yes" xml:space="preserve">
          <source>This works because field hashes respond to keys that are not references like a normal hash would and use the string offered as the hash key. Thus, if a method is called as a class method, the field hash is presented with the class name instead of an object and blithely uses it as a key. Since the keys of real objects are decimal numbers, there is no conflict and the slot in the field hash can be used like any other. The &lt;code&gt;id()&lt;/code&gt; function behaves correspondingly with respect to non-reference arguments.</source>
          <target state="translated">之所以可行，是因为字段散列会像正常散列一样响应未引用的键，并使用提供的字符串作为散列键。因此，如果将一种方法称为类方法，则将使用类名而不是对象来显示字段哈希，并且会巧妙地将其用作键。由于实际对象的键是十进制数字，所以没有冲突，并且字段哈希中的插槽可以像其他任何字段一样使用。的 &lt;code&gt;id()&lt;/code&gt; 函数相对于非参考参数相应的行为。</target>
        </trans-unit>
        <trans-unit id="37aaa803ee7c99ec4174d78cf82dc91b9204b890" translate="yes" xml:space="preserve">
          <source>This works by doing overriding methods on the singleton, and directly accessing hash values on the singleton. A new version has been released that uses the Test2 API to accomplish the same result in a saner way.</source>
          <target state="translated">这种工作方式是在单体上做覆盖方法,在单体上直接访问哈希值。一个新的版本已经发布,它使用Test2 API以更理智的方式实现同样的结果。</target>
        </trans-unit>
        <trans-unit id="f0fd9a4f981e792862c2c1c34299d3c036119504" translate="yes" xml:space="preserve">
          <source>This works by invoking the &lt;code&gt;FREEZE&lt;/code&gt; method on the object, with the first argument being the object to serialise, and the second argument being the constant string &lt;code&gt;JSON&lt;/code&gt; to distinguish it from other serialisers.</source>
          <target state="translated">通过在对象上调用 &lt;code&gt;FREEZE&lt;/code&gt; 方法来工作，第一个参数是要序列化的对象，第二个参数是常量字符串 &lt;code&gt;JSON&lt;/code&gt; ,以将其与其他序列化程序区分开。</target>
        </trans-unit>
        <trans-unit id="ee37bc8498bec33db688cccd48192a7818024c7e" translate="yes" xml:space="preserve">
          <source>This works even if the package variable has not been used before, as package variables spring into existence when first used.</source>
          <target state="translated">即使包变量以前没有被使用过,这个方法也是有效的,因为包变量在第一次使用的时候就已经存在了。</target>
        </trans-unit>
        <trans-unit id="2dd7e5f2596a2fbf8c9fd904eb776f4f1a29ce3e" translate="yes" xml:space="preserve">
          <source>This works exactly like calling &lt;code&gt;$file-&amp;gt;save()&lt;/code&gt; . This can be very useful for writing dynamic code. For example, it allows you to pass a method name to be called as a parameter to another method.</source>
          <target state="translated">这就像调用 &lt;code&gt;$file-&amp;gt;save()&lt;/code&gt; 。这对于编写动态代码非常有用。例如，它允许您将方法名称作为参数传递给另一个方法。</target>
        </trans-unit>
        <trans-unit id="c16f7da148af11cbf671d895e51f5a7793076850" translate="yes" xml:space="preserve">
          <source>This works exactly like calling &lt;code&gt;$file-&amp;gt;save()&lt;/code&gt;. This can be very useful for writing dynamic code. For example, it allows you to pass a method name to be called as a parameter to another method.</source>
          <target state="translated">这就像调用 &lt;code&gt;$file-&amp;gt;save()&lt;/code&gt; 。这对于编写动态代码可能非常有用。例如，它允许您将方法名称作为参数传递给另一个方法。</target>
        </trans-unit>
        <trans-unit id="5594cfec5e61454de66a12e73e2e1b179cf923ba" translate="yes" xml:space="preserve">
          <source>This works if the dereference produces a string</source>
          <target state="translated">如果dereference产生了一个字符串,这个方法就会起作用。</target>
        </trans-unit>
        <trans-unit id="38266e487c0f4fb0b669611ed55fd5e57c3bf09c" translate="yes" xml:space="preserve">
          <source>This works just like &lt;code&gt;/bin/tar&lt;/code&gt;'s &lt;code&gt;-h&lt;/code&gt; option.</source>
          <target state="translated">就像 &lt;code&gt;/bin/tar&lt;/code&gt; 的 &lt;code&gt;-h&lt;/code&gt; 选项一样。</target>
        </trans-unit>
        <trans-unit id="f4db4f1dcef0abf193caecabc91b1d8ec192b619" translate="yes" xml:space="preserve">
          <source>This works just like &lt;code&gt;new_from_file&lt;/code&gt;, except that a handle can be provided as the first argument.</source>
          <target state="translated">就像 &lt;code&gt;new_from_file&lt;/code&gt; 一样，除了可以提供句柄作为第一个参数之外，它的工作原理相同。</target>
        </trans-unit>
        <trans-unit id="219577552fb5335aa48c2b04bb85269685e4f05b" translate="yes" xml:space="preserve">
          <source>This works just like &lt;code&gt;parse_file&lt;/code&gt; except that it reads the Pod content not from a file, but from a string that you have already in memory.</source>
          <target state="translated">就像 &lt;code&gt;parse_file&lt;/code&gt; 一样，它的工作原理不同，它不是从文件中读取Pod内容，而是从您已经在内存中的字符串中读取Pod内容。</target>
        </trans-unit>
        <trans-unit id="97ee63f99fe6452186fce78a0713bcb1bd8591fa" translate="yes" xml:space="preserve">
          <source>This works just like patching anything else, with one extra consideration.</source>
          <target state="translated">这就像打补丁一样,多了一个考虑因素。</target>
        </trans-unit>
        <trans-unit id="038f2b08f3729bf9e55b6c7536286beb304119b2" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$fh&amp;gt; described in &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt; except that it's more readable and can be safely called in a list context but still returns just one line.</source>
          <target state="translated">类似于&lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;perlop的&amp;ldquo; I / O运算符&amp;rdquo;中&lt;/a&gt;所述的&amp;lt;$ fh&amp;gt; ，但它更具可读性，可以在列表上下文中安全地调用它，但仍只返回一行。</target>
        </trans-unit>
        <trans-unit id="e00aef65607bdbfd4bbca8fcf5fc5917d56249a8" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$fh&amp;gt; described in &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt; except that it's more readable and can be safely called in a list context but still returns just one line.</source>
          <target state="translated">它的工作方式与&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop的I / O运算符中&lt;/a&gt;所述的&amp;lt;$ fh&amp;gt; 相同，不同之处在于它更具可读性，可以在列表上下文中安全地调用它，但仍只返回一行。</target>
        </trans-unit>
        <trans-unit id="dcebba3c0143d6834639907ecbbcce5227295c40" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$fh&amp;gt; when called in a list context to read all the remaining lines in a file, except that it's more readable. It will also croak() if accidentally called in a scalar context.</source>
          <target state="translated">在列表上下文中被调用以读取文件中所有剩余的行时，它的作用类似于&amp;lt;$ fh&amp;gt;，只是它更具可读性。如果在标量上下文中意外调用，它也会croak（）。</target>
        </trans-unit>
        <trans-unit id="7450c62face5ca7b9e02c283184e4738197040fb" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$io&amp;gt; described in &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt; except that it's more readable and can be safely called in a list context but still returns just one line. If used as the conditional +within a &lt;code&gt;while&lt;/code&gt; or C-style &lt;code&gt;for&lt;/code&gt; loop, however, you will need to +emulate the functionality of &amp;lt;$io&amp;gt; with &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;($_ = $io-&amp;gt;getline)&lt;/code&gt; .</source>
          <target state="translated">它的工作方式与&lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;perlop的I / O运算符中&lt;/a&gt;所述的&amp;lt;$ io&amp;gt; 相同，不同之处在于它更具可读性，可以在列表上下文中安全地调用它，但仍只返回一行。如果用作内有条件+ &lt;code&gt;while&lt;/code&gt; 或C风格 &lt;code&gt;for&lt;/code&gt; 环，但是，你将需要仿真+ &amp;lt;$ IO&amp;gt;的与所述功能 &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;($_ = $io-&amp;gt;getline)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3495f3db5c4d1d0c89019c28aef54ca3210b08f0" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$io&amp;gt; described in &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt; except that it's more readable and can be safely called in a list context but still returns just one line. If used as the conditional within a &lt;code&gt;while&lt;/code&gt; or C-style &lt;code&gt;for&lt;/code&gt; loop, however, you will need to emulate the functionality of &amp;lt;$io&amp;gt; with &lt;code&gt;defined($_ = $io-&amp;gt;getline)&lt;/code&gt;.</source>
          <target state="translated">它的工作方式类似于&lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;perlop的&amp;ldquo; I / O操作员&amp;rdquo;中&lt;/a&gt;所述的&amp;lt;$ io&amp;gt; ，但它更具可读性，可以在列表上下文中安全地调用它，但仍只返回一行。但是，如果在 &lt;code&gt;while&lt;/code&gt; 或C风格的 &lt;code&gt;for&lt;/code&gt; 循环中用作条件，则需要使用 &lt;code&gt;defined($_ = $io-&amp;gt;getline)&lt;/code&gt; 模拟&amp;lt;$ io&amp;gt;的功能。</target>
        </trans-unit>
        <trans-unit id="c8787e54def79a3f32ab71769162cbf50a0d2256" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$io&amp;gt; when called in a list context to read all the remaining lines in a file, except that it's more readable. It will also croak() if accidentally called in a scalar context.</source>
          <target state="translated">在列表上下文中被调用以读取文件中所有剩余的行时，它的作用类似于&amp;lt;$ io&amp;gt;，只是它更具可读性。如果在标量上下文中意外调用，它也会croak（）。</target>
        </trans-unit>
        <trans-unit id="2bc655ffdbbb7b5de088685237be5925d7bbe434" translate="yes" xml:space="preserve">
          <source>This works like &lt;code&gt;implicate_supers&lt;/code&gt; except that the implicated forms are added to the end of the return list.</source>
          <target state="translated">这就像 &lt;code&gt;implicate_supers&lt;/code&gt; 除了牵连的形式被添加到返回列表的末尾。</target>
        </trans-unit>
        <trans-unit id="86cdc5ca018e3bf7bd5f95614dd661c8b598198f" translate="yes" xml:space="preserve">
          <source>This works like get_title except that it returns the contents of the &quot;=head1 AUTHOR\n\nParagraph...\n&quot; section, assuming that that section isn't terribly long. To recognize a &quot;=head1 Author\n\nParagraph\n&quot; section, pass the &lt;code&gt;nocase&lt;/code&gt; option:</source>
          <target state="translated">类似于get_title一样，除了它返回&amp;ldquo; = head1 AUTHOR \ n \ nParagraph ... \ n&amp;rdquo;部分的内容外，假定该部分的长度不是很长。要识别&amp;ldquo; = head1作者\ n \ n段落\ n&amp;rdquo;部分，请传递 &lt;code&gt;nocase&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="64a77cc5fc2dfee3e1cafa417d88e53b294176fe" translate="yes" xml:space="preserve">
          <source>This works like get_title except that it returns the contents of the &quot;=head1 DESCRIPTION\n\nParagraph...\n&quot; section, assuming that that section isn't terribly long. To recognize a &quot;=head1 Description\n\nParagraph\n&quot; section, pass the &lt;code&gt;nocase&lt;/code&gt; option:</source>
          <target state="translated">类似于get_title一样，除了它返回&amp;ldquo; = head1DESCRIPTION \ n \ nParagraph ... \ n&amp;rdquo;部分的内容外，假设该部分的长度不是很长。要识别&amp;ldquo; = head1 Description \ n \ nParagraph \ n&amp;rdquo;部分，请传递 &lt;code&gt;nocase&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="26df8521ce0593af395e7709eafe289696c2f1f5" translate="yes" xml:space="preserve">
          <source>This works like get_title except that it returns the contents of the &quot;=head1 VERSION\n\n[BIG BLOCK]\n&quot; block. Note that this does NOT return the module's &lt;code&gt;$VERSION&lt;/code&gt; !! To recognize a &quot;=head1 Version\n\n[BIG BLOCK]\n&quot; section, pass the &lt;code&gt;nocase&lt;/code&gt; option:</source>
          <target state="translated">除了返回&amp;ldquo; = head1 VERSION \ n \ n [BIG BLOCK] \ n&amp;rdquo;块的内容外，这与get_title相似。注意，这不会返回模块的 &lt;code&gt;$VERSION&lt;/code&gt; ！要识别&amp;ldquo; = head1版本\ n \ n [大块] \ n&amp;rdquo;部分，请传递 &lt;code&gt;nocase&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="8a823c0684b5208934f648973411ba95381fb432" translate="yes" xml:space="preserve">
          <source>This works like get_title except that it returns the contents of the &quot;=head1 VERSION\n\n[BIG BLOCK]\n&quot; block. Note that this does NOT return the module's &lt;code&gt;$VERSION&lt;/code&gt;!! To recognize a &quot;=head1 Version\n\n[BIG BLOCK]\n&quot; section, pass the &lt;code&gt;nocase&lt;/code&gt; option:</source>
          <target state="translated">除了返回&amp;ldquo; = head1 VERSION \ n \ n [BIG BLOCK] \ n&amp;rdquo;块的内容外，这与get_title相似。注意，这不会返回模块的 &lt;code&gt;$VERSION&lt;/code&gt; ！要识别&amp;ldquo; = head1版本\ n \ n [大块] \ n&amp;rdquo;部分，请传递 &lt;code&gt;nocase&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="e5587967553798e28442ad51621f624abf3a3ff5" translate="yes" xml:space="preserve">
          <source>This works like the &lt;code&gt;decode&lt;/code&gt; method, but instead of raising an exception when there is trailing garbage after the first JSON object, it will silently stop parsing there and return the number of characters consumed so far.</source>
          <target state="translated">这类似于 &lt;code&gt;decode&lt;/code&gt; 方法，但不会在第一个JSON对象后出现尾随垃圾时引发异常，而是会在该处静默停止解析并返回到目前为止消耗的字符数。</target>
        </trans-unit>
        <trans-unit id="0009c0f22b1f9b3091524f0133e652a04ae0337e" translate="yes" xml:space="preserve">
          <source>This works like the &lt;code&gt;strict_type&lt;/code&gt; option you can pass to &lt;code&gt;check&lt;/code&gt; , which will turn on &lt;code&gt;strict_type&lt;/code&gt; globally for all calls to &lt;code&gt;check&lt;/code&gt; .</source>
          <target state="translated">就像您可以传递给 &lt;code&gt;check&lt;/code&gt; 的 &lt;code&gt;strict_type&lt;/code&gt; 选项一样，它将为所有 &lt;code&gt;check&lt;/code&gt; 调用全局打开 &lt;code&gt;strict_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58a60db99fd5287a02afd89bdfd44fadadefdf30" translate="yes" xml:space="preserve">
          <source>This works like the &lt;code&gt;strict_type&lt;/code&gt; option you can pass to &lt;code&gt;check&lt;/code&gt;, which will turn on &lt;code&gt;strict_type&lt;/code&gt; globally for all calls to &lt;code&gt;check&lt;/code&gt;.</source>
          <target state="translated">这就像您可以传递给 &lt;code&gt;check&lt;/code&gt; 的 &lt;code&gt;strict_type&lt;/code&gt; 选项一样，它将为所有 &lt;code&gt;check&lt;/code&gt; 调用全局打开 &lt;code&gt;strict_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="362f494acfae36c73643784bd959c4c06fb6c5c4" translate="yes" xml:space="preserve">
          <source>This works most like other language's behavior when you specify a prefix. We recommend this method.</source>
          <target state="translated">当你指定一个前缀时,它的工作原理与其他语言的行为最相似。我们推荐这种方法。</target>
        </trans-unit>
        <trans-unit id="915aba858aed251bdf66e2831b7666e6978faed3" translate="yes" xml:space="preserve">
          <source>This works only on 5.10+</source>
          <target state="translated">这只在5.10+上有效</target>
        </trans-unit>
        <trans-unit id="55b95f28c493942c265a9070f59ae310c120e01c" translate="yes" xml:space="preserve">
          <source>This works under Unix and Windows, and the current version doesn't look half as bad under Windows as it used to. Some of the gui elements still don't 'feel' quite right, though. The interface is very natural and 'perlish', making it easy to use in small scripts that just need a simple gui. It hasn't been updated in a while.</source>
          <target state="translated">这在Unix和Windows下都能使用,而且当前的版本在Windows下看起来没有以前那么糟糕。不过,有些gui元素的 &quot;感觉 &quot;还是不太对。界面非常自然和 &quot;perlish&quot;,使得它很容易在小脚本中使用,只需要一个简单的gui。它已经有一段时间没有更新了。</target>
        </trans-unit>
        <trans-unit id="455be4bb715491d8c40b42c1f8dcc680c608eb5f" translate="yes" xml:space="preserve">
          <source>This works well, and means that XS authors can gleefully write:</source>
          <target state="translated">这很好,意味着XS作者可以兴高采烈地写作。</target>
        </trans-unit>
        <trans-unit id="b707b9d283df75f490a344769164044f8e4c5af9" translate="yes" xml:space="preserve">
          <source>This works with leading special strings, dynamically determined:</source>
          <target state="translated">这适用于前导的特殊字符串,动态确定。</target>
        </trans-unit>
        <trans-unit id="ff04426d22726a3d4a81073dac982b940cab46f5" translate="yes" xml:space="preserve">
          <source>This would install the complete distribution file (say BAR/Foo-1.23.tar.gz) with all accompanying material. But if you would like to install version 1.23_90, you need to know where the distribution file resides on CPAN relative to the authors/id/ directory. If the author is BAR, this might be BAR/Foo-1.23_90.tar.gz; so you would have to say</source>
          <target state="translated">这将会安装完整的发行版文件(比如BAR/Foo-1.23.tar.gz)和所有附带的材料。但是如果你想安装1.23_90版本,你需要知道发行版文件在CPAN上相对于作者/id/目录的位置。如果作者是BAR,可能是BAR/Foo-1.23_90.tar.gz;所以你必须说</target>
        </trans-unit>
        <trans-unit id="56ee25d704c11c02d7362a5e6635fcc0e634817b" translate="yes" xml:space="preserve">
          <source>This would make &lt;code&gt;Carp&lt;/code&gt; report the error as coming from a caller not in &lt;code&gt;My::Carping::Package&lt;/code&gt; , nor from &lt;code&gt;My::Friendly::Caller&lt;/code&gt; .</source>
          <target state="translated">这将使 &lt;code&gt;Carp&lt;/code&gt; 将错误报告为不是来自 &lt;code&gt;My::Carping::Package&lt;/code&gt; 的调用者，也不来自 &lt;code&gt;My::Friendly::Caller&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="019ec406a64daebd498d30d29f05ac3a5a5def69" translate="yes" xml:space="preserve">
          <source>This would make &lt;code&gt;Carp&lt;/code&gt; report the error as coming from a caller not in &lt;code&gt;My::Carping::Package&lt;/code&gt;, nor from &lt;code&gt;My::Friendly::Caller&lt;/code&gt;.</source>
          <target state="translated">这将使 &lt;code&gt;Carp&lt;/code&gt; 将错误报告为不是来自 &lt;code&gt;My::Carping::Package&lt;/code&gt; 的调用者，也不是来自 &lt;code&gt;My::Friendly::Caller&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="891cab2fd452efda8a6a8bb2376fc567d9984ca2" translate="yes" xml:space="preserve">
          <source>This would match a line of the form:</source>
          <target state="translated">这将与表格的一行相匹配。</target>
        </trans-unit>
        <trans-unit id="bd1a277e3dce80fb2a8014b20af5fd4775d02c21" translate="yes" xml:space="preserve">
          <source>This would produce.</source>
          <target state="translated">这将产生:</target>
        </trans-unit>
        <trans-unit id="d3b8e94b68c600a8d4a422c5367048147e22fdaf" translate="yes" xml:space="preserve">
          <source>This would signal to the parser that paragraphs in this begin...end region are subject to normal handling as ordinary/verbatim paragraphs (while still tagged as meant only for processors that understand the &quot;biblio&quot; identifier). The same effect could be had with:</source>
          <target state="translated">这将向解析器发出信号,表明在这个开始...结束区域的段落将作为普通/逐字段进行正常处理(同时仍然标记为仅适用于理解 &quot;biblio &quot;标识符的处理器)。同样的效果也可以通过以下方式实现:</target>
        </trans-unit>
        <trans-unit id="15fd697862c8639869e1e78b476a5aeed8efb2ef" translate="yes" xml:space="preserve">
          <source>This would start</source>
          <target state="translated">这将开始</target>
        </trans-unit>
        <trans-unit id="00bebdd1c33f014f6c6f83be97cd8f7afa9c4c0a" translate="yes" xml:space="preserve">
          <source>This wrapping happens always when compiling Perl core source (PERL_CORE is defined) or the Perl core extensions (PERL_EXT is defined). When compiling XS code outside of Perl core the wrapping does not take place. Note, however, that intermixing the _r-forms (as Perl compiled for multithreaded operation will do) and the _r-less forms is neither well-defined (inconsistent results, data corruption, or even crashes become more likely), nor is it very portable.</source>
          <target state="translated">当编译Perl核心源码(定义了PERL_CORE)或Perl核心扩展(定义了PERL_EXT)时,这种封装总是发生。当编译Perl核心以外的XS代码时,包装不会发生。但是,请注意,混合使用 _r 形式(就像为多线程操作而编译的 Perl 所做的那样)和 _r-less 形式既没有很好的定义(结果不一致,数据损坏,甚至崩溃的可能性更大),也不是很可移植。</target>
        </trans-unit>
        <trans-unit id="d0e68ab8f02ae3faa0396a3a11b0f81dcf6b0685" translate="yes" xml:space="preserve">
          <source>This wrapping happens always when compiling Perl core source (PERL_CORE is defined) or the Perl core extensions (PERL_EXT is defined). When compiling XS code outside of the Perl core, the wrapping does not take place before Perl 5.28. Starting in that release you can</source>
          <target state="translated">在编译Perl核心源码(定义了PERL_CORE)或Perl核心扩展(定义了PERL_EXT)时,总是会发生这种封装。当编译Perl核心以外的XS代码时,在Perl 5.28之前不会发生封装。从该版本开始,你可以</target>
        </trans-unit>
        <trans-unit id="14e5fcab8c4178b44f80118d0d0e8c790e5ed2e6" translate="yes" xml:space="preserve">
          <source>This zero-width assertion executes any embedded Perl code. It always succeeds, and its return value is set as &lt;code&gt;$^R&lt;/code&gt; .</source>
          <target state="translated">零宽度断言将执行任何嵌入式Perl代码。它总是成功，其返回值被设置为 &lt;code&gt;$^R&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="037ab5d7d658f9f73dced777295d92918612ab07" translate="yes" xml:space="preserve">
          <source>This zero-width assertion executes any embedded Perl code. It always succeeds, and its return value is set as &lt;code&gt;$^R&lt;/code&gt;.</source>
          <target state="translated">零宽度断言将执行任何嵌入式Perl代码。它总是成功，其返回值被设置为 &lt;code&gt;$^R&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3986864eb1cd79d2d3acbfd270bc8eeed78bdddc" translate="yes" xml:space="preserve">
          <source>This zero-width pattern can be used to mark the point reached in a string when a certain part of the pattern has been successfully matched. This mark may be given a name. A later &lt;code&gt;(*SKIP)&lt;/code&gt; pattern will then skip forward to that point if backtracked into on failure. Any number of &lt;code&gt;(*MARK)&lt;/code&gt; patterns are allowed, and the</source>
          <target state="translated">当模式的特定部分成功匹配时，此零宽度模式可用于标记字符串中到达的点。可以给该商标起一个名字。如果回溯到失败时，则稍后的 &lt;code&gt;(*SKIP)&lt;/code&gt; 模式将向前跳到该点。允许使用任意数量的 &lt;code&gt;(*MARK)&lt;/code&gt; 模式，并且</target>
        </trans-unit>
        <trans-unit id="018c0e68c94f9f979bcddcd227e8ad92dfe5e9c0" translate="yes" xml:space="preserve">
          <source>This zero-width pattern can be used to mark the point reached in a string when a certain part of the pattern has been successfully matched. This mark may be given a name. A later &lt;code&gt;(*SKIP)&lt;/code&gt; pattern will then skip forward to that point if backtracked into on failure. Any number of &lt;code&gt;(*MARK)&lt;/code&gt; patterns are allowed, and the NAME portion may be duplicated.</source>
          <target state="translated">当模式的特定部分已成功匹配时，此零宽度模式可用于标记字符串中到达的点。可以给该商标起一个名字。如果回溯到失败时，则稍后的 &lt;code&gt;(*SKIP)&lt;/code&gt; 模式将跳到该点。允许使用任意数量的 &lt;code&gt;(*MARK)&lt;/code&gt; 模式，并且NAME部分可以重复。</target>
        </trans-unit>
        <trans-unit id="3e845add8e49d7a0ebfe26e6329051032e10440f" translate="yes" xml:space="preserve">
          <source>This zero-width pattern is similar to &lt;code&gt;(*PRUNE)&lt;/code&gt; , except that on failure it also signifies that whatever text that was matched leading up to the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern being executed cannot be part of</source>
          <target state="translated">零宽度模式类似于 &lt;code&gt;(*PRUNE)&lt;/code&gt; ，除了在失败时它还表示，导致执行 &lt;code&gt;(*SKIP)&lt;/code&gt; 模式的任何匹配文本都不能成为其中的一部分</target>
        </trans-unit>
        <trans-unit id="51e4c7fda54787bcde2f76a35e31d235c61d7234" translate="yes" xml:space="preserve">
          <source>This zero-width pattern is similar to &lt;code&gt;(*PRUNE)&lt;/code&gt;, except that on failure it also signifies that whatever text that was matched leading up to the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern being executed cannot be part of</source>
          <target state="translated">零宽度模式类似于 &lt;code&gt;(*PRUNE)&lt;/code&gt; ，除了在失败时它还表示，导致执行 &lt;code&gt;(*SKIP)&lt;/code&gt; 模式的任何匹配文本都不能成为其中的一部分</target>
        </trans-unit>
        <trans-unit id="f14d48589d384cf0a42c2d25bee216599d01f868" translate="yes" xml:space="preserve">
          <source>This zero-width pattern prunes the backtracking tree at the current point when backtracked into on failure. Consider the pattern &lt;code&gt;/&lt;i&gt;A&lt;/i&gt; (*PRUNE) &lt;i&gt;B&lt;/i&gt;/&lt;/code&gt;, where</source>
          <target state="translated">当回溯到失败时，此零宽度模式会在当前点修剪回溯树。考虑模式 &lt;code&gt;/&lt;i&gt;A&lt;/i&gt; (*PRUNE) &lt;i&gt;B&lt;/i&gt;/&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="8c4b9623686b3758cfd382a28c93e0707ac9367e" translate="yes" xml:space="preserve">
          <source>This zero-width pattern prunes the backtracking tree at the current point when backtracked into on failure. Consider the pattern &lt;code&gt;A (*PRUNE) B&lt;/code&gt;, where A and B are complex patterns. Until the &lt;code&gt;(*PRUNE)&lt;/code&gt; verb is reached, A may backtrack as necessary to match. Once it is reached, matching continues in B, which may also backtrack as necessary; however, should B not match, then no further backtracking will take place, and the pattern will fail outright at the current starting position.</source>
          <target state="translated">当出现故障时，此零宽度模式会在当前点修剪回溯树。考虑模式 &lt;code&gt;A (*PRUNE) B&lt;/code&gt; ，其中A和B是复杂模式。在达到 &lt;code&gt;(*PRUNE)&lt;/code&gt; 动词之前，A可能会根据需要进行回溯以进行匹配。一旦达到，匹配就会在B中继续进行，必要时也可以回溯；但是，如果B不匹配，则不会进行进一步的回溯，并且该模式将在当前起始位置完全失败。</target>
        </trans-unit>
        <trans-unit id="6ab6320cf6b57ad1eb41183660b9a012d0721d64" translate="yes" xml:space="preserve">
          <source>Thomas Dorner</source>
          <target state="translated">Thomas Dorner</target>
        </trans-unit>
        <trans-unit id="81e4e8d1869fa873203b699ef2f7c28f0d0f204c" translate="yes" xml:space="preserve">
          <source>Those can be rather inefficient though. If they aren't fast enough for you, you might just read chunks of data and count the number of newlines:</source>
          <target state="translated">不过这些方法的效率可能相当低。如果它们对你来说不够快,你可能只是读取数据块,然后计算新行数。</target>
        </trans-unit>
        <trans-unit id="1fd34bde8d27f4db80e364187fff01e57e24dcf5" translate="yes" xml:space="preserve">
          <source>Those debugging perl with the DDD frontend over gdb may find the following useful:</source>
          <target state="translated">在gdb上使用DDD前端调试perl的人可能会发现以下内容很有用。</target>
        </trans-unit>
        <trans-unit id="d8de155d193899f771792e739cfd779f42445bfd" translate="yes" xml:space="preserve">
          <source>Those discouraged forms are accepted as input to &lt;code&gt;prop_aliases&lt;/code&gt; , but are not returned in the lists. &lt;code&gt;prop_aliases('isL&amp;amp;')&lt;/code&gt; and &lt;code&gt;prop_aliases('isL_')&lt;/code&gt; , which are old synonyms for &lt;code&gt;&quot;Is_LC&quot;&lt;/code&gt; and should not be used in new code, are examples of this. These both return &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt; . Thus this function allows you to take a discouraged form, and find its acceptable alternatives. The same goes with single-form Block property equivalences. Only the forms that begin with &lt;code&gt;&quot;In_&quot;&lt;/code&gt; are not discouraged; if you pass &lt;code&gt;prop_aliases&lt;/code&gt; a discouraged form, you will get back the equivalent ones that begin with &lt;code&gt;&quot;In_&quot;&lt;/code&gt; . It will otherwise look like a new-style block name (see. &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">那些不鼓励使用的形式被接受为 &lt;code&gt;prop_aliases&lt;/code&gt; 的输入，但未在列表中返回。 &lt;code&gt;prop_aliases('isL&amp;amp;')&lt;/code&gt; 和 &lt;code&gt;prop_aliases('isL_')&lt;/code&gt; 是 &lt;code&gt;&quot;Is_LC&quot;&lt;/code&gt; 旧同义词，不应在新代码中使用。这些都返回 &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt; 。因此，此功能使您可以采取不鼓励的形式，并找到可接受的替代方案。单一形式的Block属性等效项也是如此。不鼓励 &lt;code&gt;&quot;In_&quot;&lt;/code&gt; 开头的表格；如果您通过 &lt;code&gt;prop_aliases&lt;/code&gt; 不鼓励的形式，您将获得以 &lt;code&gt;&quot;In_&quot;&lt;/code&gt; 开头的等价形式。否则，它将看起来像新样式的块名称（请参阅。&lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;旧样式与新样式的块名称&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7e7315b6f7527f6cad5c0696c36731171292e6d3" translate="yes" xml:space="preserve">
          <source>Those discouraged forms are accepted as input to &lt;code&gt;prop_aliases&lt;/code&gt;, but are not returned in the lists. &lt;code&gt;prop_aliases('isL&amp;amp;')&lt;/code&gt; and &lt;code&gt;prop_aliases('isL_')&lt;/code&gt;, which are old synonyms for &lt;code&gt;&quot;Is_LC&quot;&lt;/code&gt; and should not be used in new code, are examples of this. These both return &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt;. Thus this function allows you to take a discouraged form, and find its acceptable alternatives. The same goes with single-form Block property equivalences. Only the forms that begin with &lt;code&gt;&quot;In_&quot;&lt;/code&gt; are not discouraged; if you pass &lt;code&gt;prop_aliases&lt;/code&gt; a discouraged form, you will get back the equivalent ones that begin with &lt;code&gt;&quot;In_&quot;&lt;/code&gt;. It will otherwise look like a new-style block name (see. &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style versus new-style block names&quot;&lt;/a&gt;).</source>
          <target state="translated">那些不鼓励使用的形式被接受为 &lt;code&gt;prop_aliases&lt;/code&gt; 的输入，但未在列表中返回。 &lt;code&gt;prop_aliases('isL&amp;amp;')&lt;/code&gt; 和 &lt;code&gt;prop_aliases('isL_')&lt;/code&gt; 是 &lt;code&gt;&quot;Is_LC&quot;&lt;/code&gt; 旧同义词，不应在新代码中使用。这些都返回 &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt; 。因此，此功能使您可以采取不鼓励的形式，并找到可接受的替代方案。单一形式的Block属性等效项也是如此。不鼓励 &lt;code&gt;&quot;In_&quot;&lt;/code&gt; 开头的表格；如果您 &lt;code&gt;prop_aliases&lt;/code&gt; 形式，则将取回以 &lt;code&gt;&quot;In_&quot;&lt;/code&gt; 开头的等效形式。否则，它将看起来像新样式的块名称（请参阅&lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&amp;ldquo;旧样式与新样式的块名称&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3da17d9bf3cc6c170baa5678aa93a096d0f37e23" translate="yes" xml:space="preserve">
          <source>Those examples also illustrate that you should not try to use &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; as a substitute for the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module.</source>
          <target state="translated">这些示例还说明，您不应尝试使用&lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt;代替&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="6da32d7b6dfc1f76299003b85142b3301014ca18" translate="yes" xml:space="preserve">
          <source>Those examples also illustrate that you should not try to use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; as a substitute for the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module.</source>
          <target state="translated">这些示例还说明，您不应尝试使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 代替&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="a75c1c6107c9c80616709d9370ed7d64d72897ff" translate="yes" xml:space="preserve">
          <source>Those examples also illustrate that you should not try to use &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; as a substitute for the &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt; module.</source>
          <target state="translated">这些示例还说明，您不应尝试使用 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 代替&lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="1b7bc94e0db621087dac583856d0104fb7d8c89b" translate="yes" xml:space="preserve">
          <source>Those letters could all be Latin (as in the example just above), or they could be all Cyrillic (except for the dot), or they could be a mixture of the two. In the case of an internet address the &lt;code&gt;.com&lt;/code&gt; would be in Latin, And any Cyrillic ones would cause it to be a mixture, not a script run. Someone clicking on such a link would not be directed to the real Paypal website, but an attacker would craft a look-alike one to attempt to gather sensitive information from the person.</source>
          <target state="translated">这些字母都可以是拉丁字母（如上例所示），也可以全部是西里尔字母（点除外），也可以是两者的混合体。如果是Internet地址，则 &lt;code&gt;.com&lt;/code&gt; 将使用拉丁语，而任何西里尔字母都将导致它是混合文件，而不是脚本运行文件。单击此类链接的人不会被定向到真实的Paypal网站，但攻击者将制作一个外观相似的网站，试图从该人那里收集敏感信息。</target>
        </trans-unit>
        <trans-unit id="09bb82492fe1deca424636c6f8f129828507429d" translate="yes" xml:space="preserve">
          <source>Those methods which override default MM_Unix methods are marked &quot;(override)&quot;, while methods unique to MM_VMS are marked &quot;(specific)&quot;. For overridden methods, documentation is limited to an explanation of why this method overrides the MM_Unix method; see the &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt; documentation for more details.</source>
          <target state="translated">那些覆盖默认MM_Unix方法的方法标记为&amp;ldquo;（覆盖）&amp;rdquo;，而MM_VMS特有的方法标记为&amp;ldquo;（特定）&amp;rdquo;。对于覆盖的方法，文档仅限于解释此方法为何覆盖MM_Unix方法的原因。有关更多详细信息，请参见&lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils :: MM_Unix&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="956b46dcd2869bcc1ce846f30fe79b6d32253a71" translate="yes" xml:space="preserve">
          <source>Those methods which override default MM_Unix methods are marked &quot;(override)&quot;, while methods unique to MM_VMS are marked &quot;(specific)&quot;. For overridden methods, documentation is limited to an explanation of why this method overrides the MM_Unix method; see the ExtUtils::MM_Unix documentation for more details.</source>
          <target state="translated">那些覆盖默认的 MM_Unix 方法的方法被标记为&quot;(覆盖)&quot;,而 MM_VMS 独有的方法被标记为&quot;(特定)&quot;。对于被覆盖的方法,文档仅限于解释为什么这个方法覆盖了MM_Unix方法;更多细节请参见ExtUtils::MM_Unix文档。</target>
        </trans-unit>
        <trans-unit id="89694826230f33ec41f3391ad1e9d0ae75075e89" translate="yes" xml:space="preserve">
          <source>Those not usable within a bracketed character class (like &lt;code&gt;[\da-z]&lt;/code&gt; ) are marked as &lt;code&gt;Not in [].&lt;/code&gt;</source>
          <target state="translated">那些在方括号字符类中不可用的字符（例如 &lt;code&gt;[\da-z]&lt;/code&gt; ） &lt;code&gt;Not in [].&lt;/code&gt; 中标记为Not。</target>
        </trans-unit>
        <trans-unit id="ed08d333f4d7b0ebed9f1e47a113b306b6da0b17" translate="yes" xml:space="preserve">
          <source>Those not usable within a bracketed character class (like &lt;code&gt;[\da-z]&lt;/code&gt;) are marked as &lt;code&gt;Not in [].&lt;/code&gt;</source>
          <target state="translated">那些在方括号字符类中不可用的字符（例如 &lt;code&gt;[\da-z]&lt;/code&gt; ） &lt;code&gt;Not in [].&lt;/code&gt; 中标记为Not。</target>
        </trans-unit>
        <trans-unit id="5c59400870fdcf39cd37f7130db3cbffeeca3151" translate="yes" xml:space="preserve">
          <source>Those options are explained in &lt;a href=&quot;../man&quot;&gt;Pod::Man&lt;/a&gt;.</source>
          <target state="translated">这些选项在&lt;a href=&quot;../man&quot;&gt;Pod :: Man中&lt;/a&gt;进行了说明。</target>
        </trans-unit>
        <trans-unit id="5a7014dea585b921e6969f68f00359599742e4a3" translate="yes" xml:space="preserve">
          <source>Those options are explained in &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt;.</source>
          <target state="translated">这些选项在&lt;a href=&quot;Pod::Man&quot;&gt;Pod :: Man中&lt;/a&gt;进行了说明。</target>
        </trans-unit>
        <trans-unit id="6e2b5b8ade9f04ee810e0602b2c63da979876bd5" translate="yes" xml:space="preserve">
          <source>Though ISO-8859 does have ISO-8859-5, the KOI8 series is far more popular in the Net. &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; comes with the following KOI charsets. For gory details, see &lt;a href=&quot;http://czyborra.com/charsets/cyrillic.html&quot;&gt;http://czyborra.com/charsets/cyrillic.html&lt;/a&gt;</source>
          <target state="translated">尽管ISO-8859确实具有ISO-8859-5，但KOI8系列在网络中更为流行。&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;带有以下KOI字符集。有关详细信息，请参见&lt;a href=&quot;http://czyborra.com/charsets/cyrillic.html&quot;&gt;http://czyborra.com/charsets/cyrillic.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2d164817730248c36fd41c3d7e8fb0afe7ee263" translate="yes" xml:space="preserve">
          <source>Though Jungshik Shin has reported that Mozilla supports this encoding, it was too late before 5.8.0 for us to add it. In the future, it may be available via a separate module. See &lt;a href=&quot;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&lt;/a&gt; and &lt;a href=&quot;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&lt;/a&gt; if you are interested in helping us.</source>
          <target state="translated">尽管Jungshik Shin曾报道Mozilla支持此编码，但在5.8.0之前对于我们添加它为时已晚。将来，它可能会通过单独的模块提供。见&lt;a href=&quot;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&lt;/a&gt;和&lt;a href=&quot;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&lt;/a&gt;如果您有兴趣帮助我们。</target>
        </trans-unit>
        <trans-unit id="58cc14e3886ee7120dc696463085595dfcc5771f" translate="yes" xml:space="preserve">
          <source>Though Jungshik Shin has reported that Mozilla supports this encoding, it was too late before 5.8.0 for us to add it. In the future, it may be available via a separate module. See &lt;a href=&quot;https://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&lt;/a&gt; and &lt;a href=&quot;https://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&lt;/a&gt; if you are interested in helping us.</source>
          <target state="translated">尽管Jungshik Shin曾报道Mozilla支持此编码，但在5.8.0之前对于我们添加它为时已晚。将来，它可能会通过单独的模块提供。见&lt;a href=&quot;https://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&lt;/a&gt;和&lt;a href=&quot;https://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&lt;/a&gt;如果您有兴趣帮助我们。</target>
        </trans-unit>
        <trans-unit id="66d24de1d761cc58def056c26e4fb86b5492f71e" translate="yes" xml:space="preserve">
          <source>Though a much better way is to use the &lt;a href=&quot;Test2::Plugin::UTF8&quot;&gt;Test2::Plugin::UTF8&lt;/a&gt; plugin, which is part of &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;.</source>
          <target state="translated">尽管更好的方法是使用&lt;a href=&quot;Test2::Plugin::UTF8&quot;&gt;Test2 :: Plugin :: UTF8&lt;/a&gt;插件，它是&lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="b8a06e11acd02f600ac3a6ff09284942503ee656" translate="yes" xml:space="preserve">
          <source>Though forcing an argument into a particular form does not change the stored number, Perl remembers the result of such conversions. In particular, though the first such conversion may be time-consuming, repeated operations will not need to redo the conversion.</source>
          <target state="translated">虽然强制将一个参数转换成特定的形式并不会改变存储的数字,但 Perl 会记住这种转换的结果。特别是,尽管第一次这样的转换可能会很耗时,但重复的操作将不需要重做转换。</target>
        </trans-unit>
        <trans-unit id="f3be83a9aceb8b170431d7d56170a63bf06c2048" translate="yes" xml:space="preserve">
          <source>Though much can be written about the inconsistency and coverage problems of gcc warnings (like &lt;code&gt;-Wall&lt;/code&gt; not meaning &quot;all the warnings&quot;, or some common portability problems not being covered by &lt;code&gt;-Wall&lt;/code&gt; , or &lt;code&gt;-ansi&lt;/code&gt; and &lt;code&gt;-pedantic&lt;/code&gt; both being a poorly defined collection of warnings, and so forth), gcc is still a useful tool in keeping our coding nose clean.</source>
          <target state="translated">尽管可以写很多有关gcc警告的不一致和覆盖问题的信息（例如 &lt;code&gt;-Wall&lt;/code&gt; 并不意味着&amp;ldquo;所有警告&amp;rdquo;，或者 &lt;code&gt;-Wall&lt;/code&gt; 不能覆盖某些常见的可移植性问题，或者 &lt;code&gt;-ansi&lt;/code&gt; 和 &lt;code&gt;-pedantic&lt;/code&gt; 都是定义不明确的集合）警告等等），gcc仍然是保持我们的编码鼻子干净的有用工具。</target>
        </trans-unit>
        <trans-unit id="4faaa6fa5354d5373d44ec1d57892b26bbdbc5ff" translate="yes" xml:space="preserve">
          <source>Though much can be written about the inconsistency and coverage problems of gcc warnings (like &lt;code&gt;-Wall&lt;/code&gt; not meaning &quot;all the warnings&quot;, or some common portability problems not being covered by &lt;code&gt;-Wall&lt;/code&gt;, or &lt;code&gt;-ansi&lt;/code&gt; and &lt;code&gt;-pedantic&lt;/code&gt; both being a poorly defined collection of warnings, and so forth), gcc is still a useful tool in keeping our coding nose clean.</source>
          <target state="translated">尽管可以写很多有关gcc警告的不一致和覆盖问题的信息（例如 &lt;code&gt;-Wall&lt;/code&gt; 并不意味着&amp;ldquo;所有警告&amp;rdquo;，或者 &lt;code&gt;-Wall&lt;/code&gt; 或 &lt;code&gt;-ansi&lt;/code&gt; 和 &lt;code&gt;-pedantic&lt;/code&gt; 都没有很好定义的集合，但没有涵盖一些常见的可移植性问题）警告等），gcc仍然是保持代码前端清洁的有用工具。</target>
        </trans-unit>
        <trans-unit id="419ade92c2c3a75f745587c25bed6b20ff3a2dd8" translate="yes" xml:space="preserve">
          <source>Though this module can be used without any &lt;code&gt;table&lt;/code&gt; file, to use this module easily, it is recommended to install a table file in the UCA format, by copying it under the directory &amp;lt;a place in @INC&amp;gt;/Unicode/Collate.</source>
          <target state="translated">尽管可以在没有任何 &lt;code&gt;table&lt;/code&gt; 文件的情况下使用此模块，但为了轻松使用此模块，建议通过将UCA格式的表文件复制到&amp;lt;INC&amp;gt; / Unicode / Collat​​e目录下的目录下来安装该文件。</target>
        </trans-unit>
        <trans-unit id="7863f7503e5377891a3b7452c7d6cc377d443fe7" translate="yes" xml:space="preserve">
          <source>Thread</source>
          <target state="translated">Thread</target>
        </trans-unit>
        <trans-unit id="998ceaaad06364c8b6eb7bb906fdf278086c1d9b" translate="yes" xml:space="preserve">
          <source>Thread # terminated abnormally: ...</source>
          <target state="translated">线程#异常终止:......。</target>
        </trans-unit>
        <trans-unit id="0d8bdcbf638d7eb68b070735be885cf9e96d329d" translate="yes" xml:space="preserve">
          <source>Thread - Manipulate threads in Perl (for old code only)</source>
          <target state="translated">线程-在Perl中操作线程(仅适用于旧代码)</target>
        </trans-unit>
        <trans-unit id="c918ac60574a68bba66c3da27f233195a15f2b9b" translate="yes" xml:space="preserve">
          <source>Thread Basics</source>
          <target state="translated">螺纹基础知识</target>
        </trans-unit>
        <trans-unit id="a78e21be0817d13d864f0b6be8854cdfa543bd85" translate="yes" xml:space="preserve">
          <source>Thread ID of this instance.</source>
          <target state="translated">本实例的线程ID。</target>
        </trans-unit>
        <trans-unit id="ebe1f739c1cdedc327a9eae1c397ab14c9d64437" translate="yes" xml:space="preserve">
          <source>Thread IDs</source>
          <target state="translated">主题ID</target>
        </trans-unit>
        <trans-unit id="898f39e0ee67463e37091c0ab76e5df497814e8b" translate="yes" xml:space="preserve">
          <source>Thread Pitfalls: Races</source>
          <target state="translated">线程陷阱。赛事</target>
        </trans-unit>
        <trans-unit id="b66b6cbe04365929e922b75680e179e46127f3a3" translate="yes" xml:space="preserve">
          <source>Thread Safety</source>
          <target state="translated">螺纹安全</target>
        </trans-unit>
        <trans-unit id="d3dbf16992ead48a52867791a62d8b164c67fd1f" translate="yes" xml:space="preserve">
          <source>Thread creation failed: pthread_attr_setstacksize(</source>
          <target state="translated">线程创建失败:pthread_attr_setstacksize(</target>
        </trans-unit>
        <trans-unit id="bfe544dd150b465313579f9a917937793103ac16" translate="yes" xml:space="preserve">
          <source>Thread creation failed: pthread_create returned #</source>
          <target state="translated">线程创建失败:pthread_create返回#。</target>
        </trans-unit>
        <trans-unit id="c4066c9a805adec4e9141cb77efe0020bace9560" translate="yes" xml:space="preserve">
          <source>Thread objects also have an overloaded &lt;code&gt;==&lt;/code&gt; comparison so that you can do comparison on them as you would with normal objects.</source>
          <target state="translated">线程对象还具有重载的 &lt;code&gt;==&lt;/code&gt; 比较，因此您可以像对普通对象那样对它们进行比较。</target>
        </trans-unit>
        <trans-unit id="d0cef5deb223649da3c92e68bafacf5c8ccd785e" translate="yes" xml:space="preserve">
          <source>Thread safety</source>
          <target state="translated">螺纹安全</target>
        </trans-unit>
        <trans-unit id="549ccddc66fc92574e2a5d76a4615e0548e5e609" translate="yes" xml:space="preserve">
          <source>Thread support is a Perl compile-time option. It's something that's turned on or off when Perl is built at your site, rather than when your programs are compiled. If your Perl wasn't compiled with thread support enabled, then any attempt to use threads will fail.</source>
          <target state="translated">线程支持是Perl编译时的一个选项。它是在你的网站上构建Perl时,而不是在编译程序时开启或关闭的东西。如果你的Perl在编译时没有启用线程支持,那么任何使用线程的尝试都会失败。</target>
        </trans-unit>
        <trans-unit id="46bddf5c24ca2d6a4d9042e8357ff7786b5311d0" translate="yes" xml:space="preserve">
          <source>Thread support is not tested in this version of the djgpp perl.</source>
          <target state="translated">在这个版本的djgpp perl中没有测试线程支持。</target>
        </trans-unit>
        <trans-unit id="c46da741d2999f303803e3f917e3740fdda50340" translate="yes" xml:space="preserve">
          <source>Thread support is not very reliable before 5.10.1, but that's because threads are not very reliable before 5.10.1.</source>
          <target state="translated">线程支持在5.10.1之前不是很可靠,但那是因为线程在5.10.1之前不是很可靠。</target>
        </trans-unit>
        <trans-unit id="11feb4cfa0751bbfde7a5acce22a835701e10a09" translate="yes" xml:space="preserve">
          <source>Thread-&amp;gt;list</source>
          <target state="translated">Thread-&amp;gt;list</target>
        </trans-unit>
        <trans-unit id="c33ecb12695532db82054d26a0b666a4c71b167c" translate="yes" xml:space="preserve">
          <source>Thread-&amp;gt;self</source>
          <target state="translated">Thread-&amp;gt;self</target>
        </trans-unit>
        <trans-unit id="8fed753691ece692a240fff0998afe0f2ace9f0d" translate="yes" xml:space="preserve">
          <source>Thread-Safe Modules</source>
          <target state="translated">线程安全模块</target>
        </trans-unit>
        <trans-unit id="7481655dbaa92f6baf98738070e27520e97d079c" translate="yes" xml:space="preserve">
          <source>Thread-Safety of System Libraries</source>
          <target state="translated">系统库的线程安全</target>
        </trans-unit>
        <trans-unit id="932b17e3a913e7164b20d08cedb16d8eee3d76fc" translate="yes" xml:space="preserve">
          <source>Thread-aware system interfaces</source>
          <target state="translated">线程感知系统接口</target>
        </trans-unit>
        <trans-unit id="3f487c5ede1faaacb7af8d62cbc07904f78f97b1" translate="yes" xml:space="preserve">
          <source>Thread-safe modules</source>
          <target state="translated">线程安全模块</target>
        </trans-unit>
        <trans-unit id="8d5d3327153c08a2630824ad42fbb1c6c94a74e6" translate="yes" xml:space="preserve">
          <source>Thread-safe operations are supported in Windows starting in Visual Studio 2005, and in systems compatible with POSIX 2008. Some platforms claim to support POSIX 2008, but have buggy implementations, so that the hints files for compiling to run on them turn off attempting to use thread-safety. &lt;code&gt;${^SAFE_LOCALES}&lt;/code&gt; will be 0 on them.</source>
          <target state="translated">从Visual Studio 2005开始，在Windows中以及与POSIX 2008兼容的系统中都支持线程安全操作。某些平台声称支持POSIX 2008，但是具有错误的实现，因此用于在其上运行的提示文件将关闭，以尝试执行以下操作：使用线程安全。 &lt;code&gt;${^SAFE_LOCALES}&lt;/code&gt; 将为0。</target>
        </trans-unit>
        <trans-unit id="a04c2c8f868b7f546d5c03554daa6de042ed3f5f" translate="yes" xml:space="preserve">
          <source>Thread-safe queues</source>
          <target state="translated">线程安全队列</target>
        </trans-unit>
        <trans-unit id="6ec24d7d376e4c8018f31c516a824eaf616af734" translate="yes" xml:space="preserve">
          <source>Thread-safe semaphores</source>
          <target state="translated">线程安全的信号词</target>
        </trans-unit>
        <trans-unit id="1a5d305757aae906720c104f8cc9b46cfea47a9a" translate="yes" xml:space="preserve">
          <source>Thread-safety of extensions</source>
          <target state="translated">扩展线程的安全性</target>
        </trans-unit>
        <trans-unit id="396f10461adcaf1d700d25868c55c05cc6b1f668" translate="yes" xml:space="preserve">
          <source>Thread::Queue</source>
          <target state="translated">Thread::Queue</target>
        </trans-unit>
        <trans-unit id="a99444903cfd04a299ea92dd5417034d9b8ba995" translate="yes" xml:space="preserve">
          <source>Thread::Queue - Thread-safe queues</source>
          <target state="translated">线程::队列-线程安全队列</target>
        </trans-unit>
        <trans-unit id="762634ef60addc5dc2601bb4e594eccb63b09b78" translate="yes" xml:space="preserve">
          <source>Thread::Queue Discussion Forum on CPAN: &lt;a href=&quot;http://www.cpanforum.com/dist/Thread-Queue&quot;&gt;http://www.cpanforum.com/dist/Thread-Queue&lt;/a&gt;</source>
          <target state="translated">CPAN上的Thread :: Queue讨论论坛：&lt;a href=&quot;http://www.cpanforum.com/dist/Thread-Queue&quot;&gt;http&lt;/a&gt; : //www.cpanforum.com/dist/Thread-Queue</target>
        </trans-unit>
        <trans-unit id="e095a6673757f69a6701a64b890923c021a33f37" translate="yes" xml:space="preserve">
          <source>Thread::Queue on MetaCPAN: &lt;a href=&quot;https://metacpan.org/release/Thread-Queue&quot;&gt;https://metacpan.org/release/Thread-Queue&lt;/a&gt;</source>
          <target state="translated">MetaCPAN上的Thread :: Queue：&lt;a href=&quot;https://metacpan.org/release/Thread-Queue&quot;&gt;https&lt;/a&gt; ://metacpan.org/release/Thread-Queue</target>
        </trans-unit>
        <trans-unit id="0074185a9ba92a372e711b37e0503d776af40535" translate="yes" xml:space="preserve">
          <source>Thread::Semaphore</source>
          <target state="translated">Thread::Semaphore</target>
        </trans-unit>
        <trans-unit id="5153c71809c73fa56e9f450e40e65e39c3a75a98" translate="yes" xml:space="preserve">
          <source>Thread::Semaphore - Thread-safe semaphores</source>
          <target state="translated">Thread::Semaphore-线程安全的信号灯</target>
        </trans-unit>
        <trans-unit id="b671103ebdb4e0b4d2ecc230ad75192d06191f6c" translate="yes" xml:space="preserve">
          <source>Thread::Semaphore Discussion Forum on CPAN: &lt;a href=&quot;http://www.cpanforum.com/dist/Thread-Semaphore&quot;&gt;http://www.cpanforum.com/dist/Thread-Semaphore&lt;/a&gt;</source>
          <target state="translated">CPAN上的Thread :: Semaphore讨论论坛：&lt;a href=&quot;http://www.cpanforum.com/dist/Thread-Semaphore&quot;&gt;http&lt;/a&gt; : //www.cpanforum.com/dist/Thread-Semaphore</target>
        </trans-unit>
        <trans-unit id="78e4d100100edaa775feea0a8c72907079d2f6c0" translate="yes" xml:space="preserve">
          <source>Thread::Semaphore on MetaCPAN: &lt;a href=&quot;https://metacpan.org/release/Thread-Semaphore&quot;&gt;https://metacpan.org/release/Thread-Semaphore&lt;/a&gt;</source>
          <target state="translated">MetaCPAN上的Thread :: Semaphore：&lt;a href=&quot;https://metacpan.org/release/Thread-Semaphore&quot;&gt;https&lt;/a&gt;：//metacpan.org/release/Thread-Semaphore</target>
        </trans-unit>
        <trans-unit id="a01c8841eeee1a585b966adef58341ccb26f6e3f" translate="yes" xml:space="preserve">
          <source>Threaded Perl</source>
          <target state="translated">有线程的Perl</target>
        </trans-unit>
        <trans-unit id="b3c18742ec345b212b0e3561e0712bc0736d2fd7" translate="yes" xml:space="preserve">
          <source>Threaded Perl &amp;lt; 5L</source>
          <target state="translated">螺纹Perl &amp;lt;5L</target>
        </trans-unit>
        <trans-unit id="896b80373adefd94b0d4d1ca953da0068f3de675" translate="yes" xml:space="preserve">
          <source>Threaded Perl on HP-UX</source>
          <target state="translated">HP-UX上的线程Perl</target>
        </trans-unit>
        <trans-unit id="278ce1d68672d63d7d64a6301d587c6d418cdd49" translate="yes" xml:space="preserve">
          <source>Threaded Perl on Tru64</source>
          <target state="translated">Tru64上的线程Perl</target>
        </trans-unit>
        <trans-unit id="3e5a5f323fc4b225e8b871ec76ea2983f10ebd12" translate="yes" xml:space="preserve">
          <source>Threaded Program Models</source>
          <target state="translated">线程模型</target>
        </trans-unit>
        <trans-unit id="5541d0b76d127f6a3c54bbc247ffcc1b6c2bbc25" translate="yes" xml:space="preserve">
          <source>Threading</source>
          <target state="translated">Threading</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="6596a15b769c831a3f0b4a20d6206e9aaff0ff18" translate="yes" xml:space="preserve">
          <source>Threads And Data</source>
          <target state="translated">线程和数据</target>
        </trans-unit>
        <trans-unit id="ce6a15cf18170dad63898b28647ad599c148d2e2" translate="yes" xml:space="preserve">
          <source>Threads and PERL_NO_GET_CONTEXT</source>
          <target state="translated">线程和PERL_NO_GET_CONTEXT。</target>
        </trans-unit>
        <trans-unit id="f29a9672c8b3e91f034cbb02629e17bf739af74a" translate="yes" xml:space="preserve">
          <source>Threads are executed in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; context. This method will return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the thread terminates</source>
          <target state="translated">线程在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 上下文中执行。如果线程终止，此方法将返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f937508b206813fc7fc617e2e68bc09cd2fe07a" translate="yes" xml:space="preserve">
          <source>Threads are executed in an &lt;code&gt;eval&lt;/code&gt; context. This method will return &lt;code&gt;undef&lt;/code&gt; if the thread terminates</source>
          <target state="translated">线程在 &lt;code&gt;eval&lt;/code&gt; 上下文中执行。如果线程终止，此方法将返回 &lt;code&gt;undef&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b839f3a9a828ffa9cf5380fd081f2abe973e818b" translate="yes" xml:space="preserve">
          <source>Threads created after the stack size is set will then either call &lt;code&gt;pthread_attr_setstacksize()&lt;/code&gt;</source>
          <target state="translated">设置堆栈大小后创建的线程将调用 &lt;code&gt;pthread_attr_setstacksize()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="94467b457a28016ce826b824829b4d6d15c2d05d" translate="yes" xml:space="preserve">
          <source>Threads in perl on Solaris.</source>
          <target state="translated">Solaris上的perl线程。</target>
        </trans-unit>
        <trans-unit id="9bf016cf50be3949ad3553a7f6154f5ec7b5a4bd" translate="yes" xml:space="preserve">
          <source>Threads seem to work OK, though at the moment not all tests pass when threads are used in combination with 64-bit configurations.</source>
          <target state="translated">线程似乎可以正常工作,不过目前当线程与64位配置结合使用时,并非所有的测试都能通过。</target>
        </trans-unit>
        <trans-unit id="4cfcad8da4f4097a771977a006ace86ca57e64ee" translate="yes" xml:space="preserve">
          <source>Three additional functions allow access to this statistic from Perl. First, use &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; to get the information contained in the output of mstat() into %hash. The field of this hash are</source>
          <target state="translated">三个附加功能允许从Perl访问此统计信息。首先，使用 &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; 将mstat（）输出中包含的信息转换为％hash。该哈希的字段是</target>
        </trans-unit>
        <trans-unit id="26e5837be2de4b1aebd256f3b85dedb9966c5789" translate="yes" xml:space="preserve">
          <source>Three arguments are passed to all subroutines specified in the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive (with exceptions - see below, particularly &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;).</source>
          <target state="translated">将三个参数传递给 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 指令中指定的所有子例程（例外-参见下文，尤其是&lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="eda363e39741d5cd78c03eff4a6d63f761929ec3" translate="yes" xml:space="preserve">
          <source>Three arguments are passed to all subroutines specified in the &lt;code&gt;use overload&lt;/code&gt; directive (with exceptions - see below, particularly &lt;a href=&quot;#nomethod&quot;&gt;&quot;nomethod&quot;&lt;/a&gt;).</source>
          <target state="translated">三个参数传递给 &lt;code&gt;use overload&lt;/code&gt; 指令中指定的所有子例程（例外-参见下文，特别是&lt;a href=&quot;#nomethod&quot;&gt;&amp;ldquo; nomethod&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3cd6b1128d59a894465f4f165820b4021adc3e92" translate="yes" xml:space="preserve">
          <source>Three basic types of firewalls</source>
          <target state="translated">三种基本类型的防火墙</target>
        </trans-unit>
        <trans-unit id="0cfd5fb11aff1629d8a4d5d5d19e3a7e21cf359a" translate="yes" xml:space="preserve">
          <source>Three callback methods must be supplied by a class extending &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; to receive the corresponding event:</source>
          <target state="translated">扩展&lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt;的类必须提供三个回调方法，以接收相应的事件：</target>
        </trans-unit>
        <trans-unit id="c4ffe47253803edde038382d85662a60a52eedba" translate="yes" xml:space="preserve">
          <source>Three examples illustrate locale-dependent tainting. The first program, which ignores its locale, won't run: a value taken directly from the command line may not be used to name an output file when taint checks are enabled.</source>
          <target state="translated">三个例子说明了依赖本地的污点。第一个程序,它忽略了它的locale,不会运行:当污点检查被启用时,一个直接从命令行获取的值不能被用来命名一个输出文件。</target>
        </trans-unit>
        <trans-unit id="6141ac98876a4853f17c73073300c31f8ef5f853" translate="yes" xml:space="preserve">
          <source>Three kinds of values are supported: integer numbers, floating point numbers, and strings.</source>
          <target state="translated">支持三种值:整数、浮点数和字符串。</target>
        </trans-unit>
        <trans-unit id="1e762c22c180faab240d71e43cfef464b083afa9" translate="yes" xml:space="preserve">
          <source>Three techniques can make regular expressions maintainable and understandable.</source>
          <target state="translated">三种技术可以使正则表达式变得可维护、可理解。</target>
        </trans-unit>
        <trans-unit id="1e024ca38a0a0e2a4280224604ff002f7a982d0a" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;ignoreChar&lt;/code&gt; , any character matching &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$ignoreChar/&lt;/a&gt;&lt;/code&gt; will be ignored. Through &lt;code&gt;ignoreName&lt;/code&gt; , any character whose name (given in the &lt;code&gt;table&lt;/code&gt; file as a comment) matches &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$ignoreName/&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">通过 &lt;code&gt;ignoreChar&lt;/code&gt; ，任何与 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$ignoreChar/&lt;/a&gt;&lt;/code&gt; 匹配的字符都将被忽略。通过 &lt;code&gt;ignoreName&lt;/code&gt; ，将忽略名称（在 &lt;code&gt;table&lt;/code&gt; 文件中作为注释给出）与 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$ignoreName/&lt;/a&gt;&lt;/code&gt; 匹配的任何字符。</target>
        </trans-unit>
        <trans-unit id="6982b043a594faf7eee60f7d8781076841a7bed8" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;ignoreChar&lt;/code&gt;, any character matching &lt;code&gt;qr/$ignoreChar/&lt;/code&gt; will be ignored. Through &lt;code&gt;ignoreName&lt;/code&gt;, any character whose name (given in the &lt;code&gt;table&lt;/code&gt; file as a comment) matches &lt;code&gt;qr/$ignoreName/&lt;/code&gt; will be ignored.</source>
          <target state="translated">通过 &lt;code&gt;ignoreChar&lt;/code&gt; ，任何与 &lt;code&gt;qr/$ignoreChar/&lt;/code&gt; 匹配的字符都将被忽略。通过 &lt;code&gt;ignoreName&lt;/code&gt; ，将忽略名称（在 &lt;code&gt;table&lt;/code&gt; 文件中作为注释给出）与 &lt;code&gt;qr/$ignoreName/&lt;/code&gt; 匹配的任何字符。</target>
        </trans-unit>
        <trans-unit id="2656f0fc85c8406c01f3e25365ba08b9847d1444" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;overrideCJK&lt;/code&gt; , ordering of CJK unified ideographs (including extensions) can be overridden.</source>
          <target state="translated">通过 &lt;code&gt;overrideCJK&lt;/code&gt; ，可以覆盖CJK统一表意文字的顺序（包括扩展名）。</target>
        </trans-unit>
        <trans-unit id="a4812f3fb25100135533513adb0cedc6268f243c" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;overrideCJK&lt;/code&gt;, ordering of CJK unified ideographs (including extensions) can be overridden.</source>
          <target state="translated">通过 &lt;code&gt;overrideCJK&lt;/code&gt; ，可以覆盖CJK统一表意文字的顺序（包括扩展名）。</target>
        </trans-unit>
        <trans-unit id="d41b6131470dc9be4067c613ceb5bce948ecfe0f" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;undefChar&lt;/code&gt; , any character matching &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$undefChar/&lt;/a&gt;&lt;/code&gt; will be undefined. Through &lt;code&gt;undefName&lt;/code&gt; , any character whose name (given in the &lt;code&gt;table&lt;/code&gt; file as a comment) matches &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$undefName/&lt;/a&gt;&lt;/code&gt; will be undefined.</source>
          <target state="translated">通过 &lt;code&gt;undefChar&lt;/code&gt; ，任何与 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$undefChar/&lt;/a&gt;&lt;/code&gt; 匹配的字符都将是未定义的。通过 &lt;code&gt;undefName&lt;/code&gt; ，可以定义名称（在 &lt;code&gt;table&lt;/code&gt; 文件中作为注释给出）与 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$undefName/&lt;/a&gt;&lt;/code&gt; 匹配的任何字符。</target>
        </trans-unit>
        <trans-unit id="06a20d5faae40c1690e4ca328ce25858d383557b" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;undefChar&lt;/code&gt;, any character matching &lt;code&gt;qr/$undefChar/&lt;/code&gt; will be undefined. Through &lt;code&gt;undefName&lt;/code&gt;, any character whose name (given in the &lt;code&gt;table&lt;/code&gt; file as a comment) matches &lt;code&gt;qr/$undefName/&lt;/code&gt; will be undefined.</source>
          <target state="translated">通过 &lt;code&gt;undefChar&lt;/code&gt; ，任何与 &lt;code&gt;qr/$undefChar/&lt;/code&gt; 匹配的字符都将是未定义的。通过 &lt;code&gt;undefName&lt;/code&gt; ，可以定义名称（在 &lt;code&gt;table&lt;/code&gt; 文件中作为注释给出）与 &lt;code&gt;qr/$undefName/&lt;/code&gt; 匹配的任何字符。</target>
        </trans-unit>
        <trans-unit id="d077a4a651b19b1e4364e9f887336a0ac7a1fd1b" translate="yes" xml:space="preserve">
          <source>Throughout Perl's documentation, you'll find numerous examples intended to help explain the discussed features. Please keep in mind that many of them are code fragments rather than complete programs.</source>
          <target state="translated">在Perl的整个文档中,你会发现许多例子旨在帮助解释所讨论的特性。请记住,其中许多是代码片段而不是完整的程序。</target>
        </trans-unit>
        <trans-unit id="c8b395c4fc736d7a1ffa585c8b907d633728a128" translate="yes" xml:space="preserve">
          <source>Throughout the previous section all the examples have used the syntax:</source>
          <target state="translated">在上一节中,所有的例子都使用了这种语法。</target>
        </trans-unit>
        <trans-unit id="04ea385bf46d02438c73b811e0575313e27e41c8" translate="yes" xml:space="preserve">
          <source>Throughout this document a variety of interfaces to the rpcb_gettime() XSUB will be explored. The XSUBs will take their parameters in different orders or will take different numbers of parameters. In each case the XSUB is an abstraction between Perl and the real C rpcb_gettime() function, and the XSUB must always ensure that the real rpcb_gettime() function is called with the correct parameters. This abstraction will allow the programmer to create a more Perl-like interface to the C function.</source>
          <target state="translated">在这篇文档中,我们将探讨rpcb_gettime()XSUB的各种接口。这些XSUB会以不同的顺序来获取参数,或者获取不同数量的参数。在每一种情况下,XSUB都是Perl和真正的C语言rpcb_gettime()函数之间的抽象,XSUB必须确保真正的rpcb_gettime()函数被正确的参数调用。这种抽象将允许程序员为C函数创建一个更类似Perl的接口。</target>
        </trans-unit>
        <trans-unit id="b15b9c197ac6c931d6850ebe19f2134cab6a760f" translate="yes" xml:space="preserve">
          <source>Throughout this document you'll see references to other parts of the Perl documentation. You can read that documentation using the &lt;code&gt;perldoc&lt;/code&gt; command or whatever method you're using to read this document.</source>
          <target state="translated">在整个文档中，您将看到对Perl文档其他部分的引用。您可以使用 &lt;code&gt;perldoc&lt;/code&gt; 命令或您用来阅读本文档的任何方法来阅读该文档。</target>
        </trans-unit>
        <trans-unit id="d384b2c788b5330a252672c9c0d9ed4dcefe6cd2" translate="yes" xml:space="preserve">
          <source>Throughout this document, &quot;Pod&quot; has been the preferred spelling for the name of the documentation format. One may also use &quot;POD&quot; or &quot;pod&quot;. For the documentation that is (typically) in the Pod format, you may use &quot;pod&quot;, or &quot;Pod&quot;, or &quot;POD&quot;. Understanding these distinctions is useful; but obsessing over how to spell them, usually is not.</source>
          <target state="translated">在本文件中,&quot;Pod &quot;一直是文件格式名称的首选拼写。也可以使用 &quot;POD &quot;或 &quot;Pod&quot;。对于(通常)采用Pod格式的文档,可以使用 &quot;pod&quot;,或 &quot;Pod&quot;,或 &quot;POD&quot;。了解这些区别是有用的;但纠结于如何拼写,通常是没有用的。</target>
        </trans-unit>
        <trans-unit id="6a4f24f440cbc4008a46d5ea71d57cb32fa115ff" translate="yes" xml:space="preserve">
          <source>Throw in some dubious extra macros for Makefile args.</source>
          <target state="translated">为Makefile args加入一些可疑的额外宏。</target>
        </trans-unit>
        <trans-unit id="76751470c1dde2f50d7d809c9a5f8b163f6ce43e" translate="yes" xml:space="preserve">
          <source>Throws an error if any of the signals supplied cannot be added to the set.</source>
          <target state="translated">如果所提供的任何信号不能被添加到集合中,则抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="47b73cafd4faf1fefd5169b12127f2bdff667740" translate="yes" xml:space="preserve">
          <source>Throws an exception telling you the attribute is read-only. This is exported to override any active setters for the attribute in a parent class.</source>
          <target state="translated">抛出一个异常,告诉你这个属性是只读的。这被导出为覆盖父类中属性的任何活动设置器。</target>
        </trans-unit>
        <trans-unit id="d1f7b26cf9b0b9d2fcaec187b02a47e2ac8cf9d0" translate="yes" xml:space="preserve">
          <source>Thus Perl allows such constructs, by</source>
          <target state="translated">因此Perl允许这样的构造,通过</target>
        </trans-unit>
        <trans-unit id="ab203f90d156d52e2f73ed76c1de89f7fea26e7e" translate="yes" xml:space="preserve">
          <source>Thus Perl returns true on success and false on failure, yet you can still easily determine the actual value returned by the operating system:</source>
          <target state="translated">因此Perl在成功时返回true,失败时返回false,但你仍然可以轻松地确定操作系统返回的实际值。</target>
        </trans-unit>
        <trans-unit id="68e6804dcc6b004791c6943dada1f9eeda86eed7" translate="yes" xml:space="preserve">
          <source>Thus means that you need to get some copy of a</source>
          <target state="translated">因此,这意味着你需要得到一些副本的一个</target>
        </trans-unit>
        <trans-unit id="cced270ffb5295be4933e701f4fb59adf650f013" translate="yes" xml:space="preserve">
          <source>Thus the following lines are equivalent:</source>
          <target state="translated">因此,下面的行文是等价的。</target>
        </trans-unit>
        <trans-unit id="2e4d332fae9a917754e083395b2e8d74491bb6fd" translate="yes" xml:space="preserve">
          <source>Thus the pattern &lt;code&gt;/foo(?:\w+|\d+|\s+)bar/&lt;/code&gt; can be thought of as the following chart:</source>
          <target state="translated">因此，可以将模式 &lt;code&gt;/foo(?:\w+|\d+|\s+)bar/&lt;/code&gt; 视为以下图表：</target>
        </trans-unit>
        <trans-unit id="f633037050d154781c387ade59e7e2912691ab20" translate="yes" xml:space="preserve">
          <source>Thus the warning is raised for many fewer cases than in earlier Perls, and only when what the result is could be arguable. It turns out that none of the optimizations made by Perl (or are ever likely to be made) cause the warning to be skipped, so it solves both problems of Perl's earlier approach. The most commonly used property that is affected by this change is &lt;code&gt;\p{Unassigned}&lt;/code&gt; which is a short form for &lt;code&gt;\p{General_Category=Unassigned}&lt;/code&gt; . Starting in v5.20, all non-Unicode code points are considered &lt;code&gt;Unassigned&lt;/code&gt; . In earlier releases the matches failed because the result was considered undefined.</source>
          <target state="translated">因此，与早期的Perls相比，仅在结果可争论的情况下，才在更少的情况下发出警告。事实证明，Perl所做的任何优化（或曾经进行过的优化）均不会导致警告被忽略，因此可以解决Perl较早方法的两个问题。受此更改影响的最常用属性是 &lt;code&gt;\p{Unassigned}&lt;/code&gt; ，它是 &lt;code&gt;\p{General_Category=Unassigned}&lt;/code&gt; 。从v5.20开始，所有非Unicode代码点都被视为 &lt;code&gt;Unassigned&lt;/code&gt; 。在早期版本中，匹配失败，因为结果被认为是未定义的。</target>
        </trans-unit>
        <trans-unit id="61e13a16949757dfa1e1583008faeb5e63993d67" translate="yes" xml:space="preserve">
          <source>Thus the warning is raised for many fewer cases than in earlier Perls, and only when what the result is could be arguable. It turns out that none of the optimizations made by Perl (or are ever likely to be made) cause the warning to be skipped, so it solves both problems of Perl's earlier approach. The most commonly used property that is affected by this change is &lt;code&gt;\p{Unassigned}&lt;/code&gt; which is a short form for &lt;code&gt;\p{General_Category=Unassigned}&lt;/code&gt;. Starting in v5.20, all non-Unicode code points are considered &lt;code&gt;Unassigned&lt;/code&gt;. In earlier releases the matches failed because the result was considered undefined.</source>
          <target state="translated">因此，仅在结果可争论的情况下，才在比以前的Perls少得多的情况下发出警告。事实证明，Perl所做的任何优化（或曾经进行过的优化）都不会导致警告被忽略，因此它解决了Perl较早方法的两个问题。受此更改影响的最常用属性是 &lt;code&gt;\p{Unassigned}&lt;/code&gt; ，它是 &lt;code&gt;\p{General_Category=Unassigned}&lt;/code&gt; 。从v5.20开始，所有非Unicode代码点均被视为 &lt;code&gt;Unassigned&lt;/code&gt; 。在早期版本中，匹配失败，因为结果被认为是未定义的。</target>
        </trans-unit>
        <trans-unit id="198082eebbb223fde4a47c55ef1e44319568487c" translate="yes" xml:space="preserve">
          <source>Thus you can say</source>
          <target state="translated">因此你可以说</target>
        </trans-unit>
        <trans-unit id="61d7278739eb25e7e5958e1c5b254402dd825eb3" translate="yes" xml:space="preserve">
          <source>Thus, after a match against &lt;code&gt;$_&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; coincides with &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; $_, $-[0],
$+[0] - $-[0]&lt;/code&gt; . Similarly, $</source>
          <target state="translated">因此，在与 &lt;code&gt;$_&lt;/code&gt; 匹配之后， &lt;code&gt;$&amp;amp;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; $_, $-[0], $+[0] - $-[0]&lt;/code&gt; 相符。同样，$</target>
        </trans-unit>
        <trans-unit id="41169299ed066a28115e5870cc4da4575fd56075" translate="yes" xml:space="preserve">
          <source>Thus, after a match against &lt;code&gt;$_&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; coincides with &lt;code&gt;substr $_, $-[0], $+[0] - $-[0]&lt;/code&gt;. Similarly, $</source>
          <target state="translated">因此，在与 &lt;code&gt;$_&lt;/code&gt; 匹配之后， &lt;code&gt;$&amp;amp;&lt;/code&gt; 与 &lt;code&gt;substr $_, $-[0], $+[0] - $-[0]&lt;/code&gt; 相符。同样，$</target>
        </trans-unit>
        <trans-unit id="c9649f9466e2d92d8678d66258528b39110e1a08" translate="yes" xml:space="preserve">
          <source>Thus, techniques are of interest that store object data</source>
          <target state="translated">因此,存储对象数据的技术备受关注</target>
        </trans-unit>
        <trans-unit id="69514cb2285daf6fa2a75d85f6f93569b1ec1fbe" translate="yes" xml:space="preserve">
          <source>Thus, the following code:</source>
          <target state="translated">因此,下面的代码。</target>
        </trans-unit>
        <trans-unit id="fdfd242e087e9b16796271aa3a036f7d0bbc20a8" translate="yes" xml:space="preserve">
          <source>Thus, when an SV is determined to be magical and of type &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt; , if a get operation is being performed, the routine &lt;code&gt;magic_get&lt;/code&gt; is called. All the various routines for the various magical types begin with &lt;code&gt;magic_&lt;/code&gt; . NOTE: the magic routines are not considered part of the Perl API, and may not be exported by the Perl library.</source>
          <target state="translated">因此，当确定SV具有魔术性且类型为 &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt; 时，如果执行了get操作，则会调用例程 &lt;code&gt;magic_get&lt;/code&gt; 。各种魔术类型的所有各种例程 &lt;code&gt;magic_&lt;/code&gt; 。注意：魔术例程不被认为是Perl API的一部分，并且可能不会被Perl库导出。</target>
        </trans-unit>
        <trans-unit id="0549c98abe5f2c41103ad967e9de7400fdf53796" translate="yes" xml:space="preserve">
          <source>Thus, when an SV is determined to be magical and of type &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt;, if a get operation is being performed, the routine &lt;code&gt;magic_get&lt;/code&gt; is called. All the various routines for the various magical types begin with &lt;code&gt;magic_&lt;/code&gt;. NOTE: the magic routines are not considered part of the Perl API, and may not be exported by the Perl library.</source>
          <target state="translated">因此，当确定SV具有魔术性并且类型为 &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt; 时，如果正在执行get操作， &lt;code&gt;magic_get&lt;/code&gt; 调用例程magic_get。各种魔术类型的所有各种例程 &lt;code&gt;magic_&lt;/code&gt; 。注意：魔术例程不被认为是Perl API的一部分，并且可能不会被Perl库导出。</target>
        </trans-unit>
        <trans-unit id="792b045fd76c8a8e326c6a926aab95f7dc272599" translate="yes" xml:space="preserve">
          <source>Tidies a pod file. It's a good idea to run this on a pod file you've patched.</source>
          <target state="translated">整理一个 pod 文件。最好在你打过补丁的 pod 文件上运行这个。</target>
        </trans-unit>
        <trans-unit id="b6cf02234ec17d26dce972804e5d1459de07ad2c" translate="yes" xml:space="preserve">
          <source>Tidy up a pad at the end of compilation of the code to which it belongs. Jobs performed here are: remove most stuff from the pads of anonsub prototypes; give it a &lt;code&gt;@_&lt;/code&gt;; mark temporaries as such. &lt;code&gt;type&lt;/code&gt; indicates the kind of subroutine:</source>
          <target state="translated">在其所属的代码编译结束时整理一下。这里执行的工作是：从anonsub原型垫上移走大多数东西；给它一个 &lt;code&gt;@_&lt;/code&gt; ; 临时标记临时人员。 &lt;code&gt;type&lt;/code&gt; 指示子例程的类型：</target>
        </trans-unit>
        <trans-unit id="296860fe60dd454f0fedbc6ccca9835dfde819d9" translate="yes" xml:space="preserve">
          <source>Tidy up a pad at the end of compilation of the code to which it belongs. Jobs performed here are: remove most stuff from the pads of anonsub prototypes; give it a @_; mark temporaries as such.</source>
          <target state="translated">在所属代码编译结束后,对垫子进行整理。这里执行的工作是:从anonsub原型的pads中删除大部分的东西;给它一个@_;将临时性的东西标记成这样。</target>
        </trans-unit>
        <trans-unit id="7d075f169d648523eaa03bb2a98984e48aa65769" translate="yes" xml:space="preserve">
          <source>Tie</source>
          <target state="translated">Tie</target>
        </trans-unit>
        <trans-unit id="5e1d6d92861c9421bba19d24d93aa2e9bfe58ad7" translate="yes" xml:space="preserve">
          <source>Tie large variables to disk</source>
          <target state="translated">将大型变量与磁盘绑定</target>
        </trans-unit>
        <trans-unit id="0bb65db42104858e7d9b646133b08eaaeba3381c" translate="yes" xml:space="preserve">
          <source>Tie::Array</source>
          <target state="translated">Tie::Array</target>
        </trans-unit>
        <trans-unit id="75e3c18c1d17d4f15800c858036a1510e1e1f0e6" translate="yes" xml:space="preserve">
          <source>Tie::Array - base class for tied arrays</source>
          <target state="translated">Tie::Array-绑定数组的基类。</target>
        </trans-unit>
        <trans-unit id="3315a464fcfacdc6f9533f0ecfd375368fedb11d" translate="yes" xml:space="preserve">
          <source>Tie::File</source>
          <target state="translated">Tie::File</target>
        </trans-unit>
        <trans-unit id="a8bb1e5ad4fcbd12edf8be28ae56bee14e6f545c" translate="yes" xml:space="preserve">
          <source>Tie::File - Access the lines of a disk file via a Perl array</source>
          <target state="translated">Tie::File-通过Perl数组访问磁盘文件的行。</target>
        </trans-unit>
        <trans-unit id="dc17380e1c5c0cb9aaf50a1f92e76e8ea993f448" translate="yes" xml:space="preserve">
          <source>Tie::File calls &lt;code&gt;binmode&lt;/code&gt; on filehandles that it opens internally, but not on filehandles passed in by the user. For consistency, especially if using the tied files cross-platform, you may wish to call &lt;code&gt;binmode&lt;/code&gt; on the filehandle prior to tying the file.</source>
          <target state="translated">Tie :: File &lt;code&gt;binmode&lt;/code&gt; 在内部打开的文件句柄上调用binmode，但不会在用户传递的文件句柄上调用binmode。为了保持一致性，尤其是在跨平台使用绑定文件的情况下，您可能希望在绑定文件之前在文件句柄上调用 &lt;code&gt;binmode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6319e96a453cce98221083d4f3fd8db235526699" translate="yes" xml:space="preserve">
          <source>Tie::Handle</source>
          <target state="translated">Tie::Handle</target>
        </trans-unit>
        <trans-unit id="0a548ea9945566563847425cd86bcbb7a0d010cc" translate="yes" xml:space="preserve">
          <source>Tie::Handle - base class definitions for tied handles</source>
          <target state="translated">Tie::Handle-绑定手柄的基类定义。</target>
        </trans-unit>
        <trans-unit id="cd52c37918e2c0b25f36b5f416810f9f4f61d1e1" translate="yes" xml:space="preserve">
          <source>Tie::Hash</source>
          <target state="translated">Tie::Hash</target>
        </trans-unit>
        <trans-unit id="b1f9afc2a333da12fb6b6ad2b6d5e266f06e1fc4" translate="yes" xml:space="preserve">
          <source>Tie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes</source>
          <target state="translated">Tie::Hash,Tie::StdHash,Tie::ExtraHash-绑定哈希的基类定义。</target>
        </trans-unit>
        <trans-unit id="c8d3a75ba1b0a3910318dc42acaa46468a63fedd" translate="yes" xml:space="preserve">
          <source>Tie::Hash::NamedCapture</source>
          <target state="translated">Tie::Hash::NamedCapture</target>
        </trans-unit>
        <trans-unit id="fe35d5fd9c32e90217b32911caa7181fd20d6a89" translate="yes" xml:space="preserve">
          <source>Tie::Hash::NamedCapture - Named regexp capture buffers</source>
          <target state="translated">Tie::Hash::NamedCapture-命名的regexp捕获缓冲区。</target>
        </trans-unit>
        <trans-unit id="703b368dc238bcde88f5095c837de68b527d723e" translate="yes" xml:space="preserve">
          <source>Tie::Memoize</source>
          <target state="translated">Tie::Memoize</target>
        </trans-unit>
        <trans-unit id="7b3289a8b6604631463790d9f588d4dd69111f3a" translate="yes" xml:space="preserve">
          <source>Tie::Memoize - add data to hash when needed</source>
          <target state="translated">Tie::Memoize-在需要时将数据添加到哈希中。</target>
        </trans-unit>
        <trans-unit id="aeeb15286d4bc809144814ad40c79ee05c416c3a" translate="yes" xml:space="preserve">
          <source>Tie::RefHash</source>
          <target state="translated">Tie::RefHash</target>
        </trans-unit>
        <trans-unit id="4bb364c89cbd37ee3daa5c39771c2605b0633761" translate="yes" xml:space="preserve">
          <source>Tie::RefHash - use references as hash keys</source>
          <target state="translated">Tie::RefHash-使用引用作为哈希键。</target>
        </trans-unit>
        <trans-unit id="fb9e6a1ad57553eb30c0b9f049adcbf5c6d8c3ed" translate="yes" xml:space="preserve">
          <source>Tie::Scalar</source>
          <target state="translated">Tie::Scalar</target>
        </trans-unit>
        <trans-unit id="14241eaa440004f0f7b17e76185eebd008e2584c" translate="yes" xml:space="preserve">
          <source>Tie::Scalar vs Tie::StdScalar</source>
          <target state="translated">Tie::Scalar vs Tie::StdScalar</target>
        </trans-unit>
        <trans-unit id="9c8072ce734013166993c6f0143dd7123d88fcc5" translate="yes" xml:space="preserve">
          <source>Tie::Scalar, Tie::StdScalar - base class definitions for tied scalars</source>
          <target state="translated">Tie::Scalar,Tie::StdScalar-绑定标量的基类定义。</target>
        </trans-unit>
        <trans-unit id="24703e371c3e7f945d3b78d21edd36185f76ca6e" translate="yes" xml:space="preserve">
          <source>Tie::StdHandle</source>
          <target state="translated">Tie::StdHandle</target>
        </trans-unit>
        <trans-unit id="a6e6391cf784418a4b559abce054165c18d48250" translate="yes" xml:space="preserve">
          <source>Tie::StdHandle - base class definitions for tied handles</source>
          <target state="translated">Tie::StdHandle-绑定句柄的基类定义。</target>
        </trans-unit>
        <trans-unit id="2f3439068e890141de6922d6924a5c42144d9aab" translate="yes" xml:space="preserve">
          <source>Tie::SubstrHash</source>
          <target state="translated">Tie::SubstrHash</target>
        </trans-unit>
        <trans-unit id="6980b3892c06ab7d2c795b8a0449ed68a3aed6bd" translate="yes" xml:space="preserve">
          <source>Tie::SubstrHash - Fixed-table-size, fixed-key-length hashing</source>
          <target state="translated">Tie::SubstrHash-固定表大小、固定键长度的散列法。</target>
        </trans-unit>
        <trans-unit id="464ee826aae53453c130a0c1497f3c4ca331982d" translate="yes" xml:space="preserve">
          <source>Tied access to ndbm files</source>
          <target state="translated">绑定访问ndbm文件</target>
        </trans-unit>
        <trans-unit id="8a33955c62ec97774e8693644b322775bd7663ae" translate="yes" xml:space="preserve">
          <source>Tied access to odbm files</source>
          <target state="translated">绑定访问odbm文件</target>
        </trans-unit>
        <trans-unit id="1588828c9e5b2bd88f7d08cd7f3e57f7ec8ffbf5" translate="yes" xml:space="preserve">
          <source>Tied access to sdbm files</source>
          <target state="translated">绑定访问sdbm文件</target>
        </trans-unit>
        <trans-unit id="1720e98baff7940aea5456c5ab89cbd8f4faa4be" translate="yes" xml:space="preserve">
          <source>Tied filehandles are still incomplete. sysopen(), truncate(), flock(), fcntl(), stat() and -X can't currently be trapped.</source>
          <target state="translated">sysopen()、truncate()、flock()、fcntl()、stat()和-X目前还不能被捕获。</target>
        </trans-unit>
        <trans-unit id="4b7baf020a5c394ffec94a6c51412ee34b96cd55" translate="yes" xml:space="preserve">
          <source>Tied hash interface</source>
          <target state="translated">绑定的哈希接口</target>
        </trans-unit>
        <trans-unit id="45a90cde1e783db9283275e5312c014bb1cb705f" translate="yes" xml:space="preserve">
          <source>Tied hash/array slices cause multiple FETCH/STORE pairs, there are no tie methods for slice operations.</source>
          <target state="translated">绑定的哈希/数组分片会造成多个FETCH/STORE对,分片操作没有绑定方法。</target>
        </trans-unit>
        <trans-unit id="44a21f1b3d2e469d8d4dbb6af794f7ad93c019a6" translate="yes" xml:space="preserve">
          <source>Tied hashes and arrays are magical beasts of the &lt;code&gt;PERL_MAGIC_tied&lt;/code&gt; magic type.</source>
          <target state="translated">绑散列和数组是 &lt;code&gt;PERL_MAGIC_tied&lt;/code&gt; 魔术类型的魔术野兽。</target>
        </trans-unit>
        <trans-unit id="83884faf685c9098ec150488288e4d48b3ce8cb8" translate="yes" xml:space="preserve">
          <source>Tied hashes may have a different ordering behaviour to perl's hash implementation.</source>
          <target state="translated">绑定的哈希可能与perl的哈希实现有不同的排序行为。</target>
        </trans-unit>
        <trans-unit id="d3d1d3d65efd2c22754237fd41c0e585f040ec15" translate="yes" xml:space="preserve">
          <source>Tied hashes may have their own ordering and algorithmic complexity attacks.</source>
          <target state="translated">绑定哈希可能有自己的排序和算法复杂性攻击。</target>
        </trans-unit>
        <trans-unit id="24b5ed066516a43ed14f22509aac06d08e585ed9" translate="yes" xml:space="preserve">
          <source>Ties are handled by choosing the first handler.</source>
          <target state="translated">通过选择第一个处理者来处理平局。</target>
        </trans-unit>
        <trans-unit id="64d5dd10fdcd493eede6caa7c5fa5f02730895e8" translate="yes" xml:space="preserve">
          <source>Tim Bunce and Charles Bailey. Currently maintained by David Landgren &amp;lt;</source>
          <target state="translated">蒂姆&amp;middot;邦斯和查尔斯&amp;middot;贝利。目前由David Landgren维护&amp;lt;</target>
        </trans-unit>
        <trans-unit id="3ddc0a76c09f699fa94ee0a72995b7039d633486" translate="yes" xml:space="preserve">
          <source>Tim Bunce, 11 August 1994.</source>
          <target state="translated">1994年8月11日,Tim Bunce。</target>
        </trans-unit>
        <trans-unit id="8cf374401e16921c8b9927b27c7d0a5e707f664a" translate="yes" xml:space="preserve">
          <source>Tim Bunce, 2nd June 1995.</source>
          <target state="translated">Tim Bunce,1995年6月2日。</target>
        </trans-unit>
        <trans-unit id="3175b9a598f6f77b48765e43cfb7cd7d7b509655" translate="yes" xml:space="preserve">
          <source>Tim Jenness</source>
          <target state="translated">Tim Jenness</target>
        </trans-unit>
        <trans-unit id="99e549517dd29d09a287dd50b24a5bc08370dba4" translate="yes" xml:space="preserve">
          <source>Tim Jenness &amp;lt;t.jenness@jach.hawaii.edu&amp;gt;</source>
          <target state="translated">蒂姆&amp;middot;詹尼斯&amp;lt;t.jenness@jach.hawaii.edu&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ba097d23c99b23a50efd8f2fea03c845fd6c6c33" translate="yes" xml:space="preserve">
          <source>Tim Jenness &amp;lt;t.jenness@jach.hawaii.edu&amp;gt; provided &lt;code&gt;pod_where&lt;/code&gt; and &lt;code&gt;contains_pod&lt;/code&gt; .</source>
          <target state="translated">Tim Jenness &amp;lt;t.jenness@jach.hawaii.edu&amp;gt;提供了 &lt;code&gt;pod_where&lt;/code&gt; 和 &lt;code&gt;contains_pod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b514fb185ee4318cecaed2812ba7869208c66528" translate="yes" xml:space="preserve">
          <source>Tim Jenness &amp;lt;tjenness@cpan.org&amp;gt;</source>
          <target state="translated">蒂姆&amp;middot;詹尼斯&amp;lt;tjenness@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1869a3cb31c7d1aee298b5966f09e01ff91380af" translate="yes" xml:space="preserve">
          <source>Tim Jenness, &amp;lt;t.jenness@jach.hawaii.edu&amp;gt;, Christian Soeller, &amp;lt;csoelle@mph.auckland.ac.nz&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt.compulink.co.uk&amp;gt;, Andrew Main (Zefram) &amp;lt;zefram@fysh.org&amp;gt;</source>
          <target state="translated">蒂姆&amp;middot;詹尼斯（Tim Jenness）， ）&amp;lt;zefram@fysh.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="93e2988b00d7b32dc16eda9dda1443c70d8e538b" translate="yes" xml:space="preserve">
          <source>Tim.Bunce (at) ig.co.uk</source>
          <target state="translated">Tim.Bunce (at)ig.co.uk</target>
        </trans-unit>
        <trans-unit id="d077aa36842cc868f42990d7049841ea88af7d34" translate="yes" xml:space="preserve">
          <source>Tim.Bunce@ig.co.uk</source>
          <target state="translated">Tim.Bunce@ig.co.uk</target>
        </trans-unit>
        <trans-unit id="e4179a3f25309044bcb58d588fe8e8bd90fd67c9" translate="yes" xml:space="preserve">
          <source>Time COUNT iterations of CODE. CODE may be a string to eval or a code reference; either way the CODE will run in the caller's package. Results will be printed to STDOUT as TITLE followed by the times. TITLE defaults to &quot;timethis COUNT&quot; if none is provided. STYLE determines the format of the output, as described for timestr() below.</source>
          <target state="translated">CODE的时间COUNT迭代。CODE可以是一个字符串,也可以是一个代码引用;无论哪种方式,CODE都将在调用者的包中运行。结果将以TITLE的形式打印到STDOUT,后面是次数。如果没有提供TITLE,默认为 &quot;timethis COUNT&quot;。STYLE决定了输出的格式,如下文对 timestr()的描述。</target>
        </trans-unit>
        <trans-unit id="3b32a6d9639a8d4119ec2ee525234d95d8857ca9" translate="yes" xml:space="preserve">
          <source>Time and Date</source>
          <target state="translated">时间和日期</target>
        </trans-unit>
        <trans-unit id="ba899f435a04612971ed3cd90f1a2814efd01889" translate="yes" xml:space="preserve">
          <source>Time and daytime network client interface</source>
          <target state="translated">时间和白天的网络客户端接口</target>
        </trans-unit>
        <trans-unit id="91258f8a07507a00e4da6f106ca4198c6edce78f" translate="yes" xml:space="preserve">
          <source>Time-related functions</source>
          <target state="translated">与时间有关的职能</target>
        </trans-unit>
        <trans-unit id="ac91bba7fcbd91c8d367a4f56e1aba373023bebd" translate="yes" xml:space="preserve">
          <source>Time::HiRes</source>
          <target state="translated">Time::HiRes</target>
        </trans-unit>
        <trans-unit id="e7a9e6eb81fae6fdb1dc6f6133fdfcde6d6d2e8f" translate="yes" xml:space="preserve">
          <source>Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers</source>
          <target state="translated">Time::HiRes-高分辨率的闹钟,睡眠,gettimeofday,间隔定时器。</target>
        </trans-unit>
        <trans-unit id="94df31ba192f82c8d905bfd5f68e42a860c364a4" translate="yes" xml:space="preserve">
          <source>Time::Local</source>
          <target state="translated">Time::Local</target>
        </trans-unit>
        <trans-unit id="f389186d9b9640e798d2c3270420ee058c982a8f" translate="yes" xml:space="preserve">
          <source>Time::Local - Efficiently compute time from local and GMT time</source>
          <target state="translated">Time::Local-从当地时间和GMT时间有效地计算时间。</target>
        </trans-unit>
        <trans-unit id="068e2f4f422dc17d00b1dbbf4d66d078ee8c1c17" translate="yes" xml:space="preserve">
          <source>Time::Local - efficiently compute time from local and GMT time</source>
          <target state="translated">Time::Local-从本地时间和GMT时间有效地计算时间。</target>
        </trans-unit>
        <trans-unit id="0a2a9a0e5d10ea8cd730c55ab8fbc21a6da6bc46" translate="yes" xml:space="preserve">
          <source>Time::Piece</source>
          <target state="translated">Time::Piece</target>
        </trans-unit>
        <trans-unit id="3b1c89f6e740fb1373ec42ee463919eaf109abbc" translate="yes" xml:space="preserve">
          <source>Time::Piece - Object Oriented time objects</source>
          <target state="translated">Time::Piece-面向对象的时间对象。</target>
        </trans-unit>
        <trans-unit id="ac2e609ce173a3276a7464b9debe21218246f96d" translate="yes" xml:space="preserve">
          <source>Time::Piece has a built-in strptime() function (from FreeBSD), allowing you incredibly flexible date parsing routines. For example:</source>
          <target state="translated">Time::Piece 有一个内置的 strptime()函数 (来自 FreeBSD),允许你使用非常灵活的日期解析例程。例如</target>
        </trans-unit>
        <trans-unit id="6fb89f7a383c83046c2d6e7aeb455a015e9f82bc" translate="yes" xml:space="preserve">
          <source>Time::Piece::strptime by default can only parse American English date names. Meanwhile, Time::Piece-&amp;gt;strftime() will return date names that use the current configured system locale. This means dates returned by strftime might not be able to be parsed by strptime. This is the default behavior and can be overridden by calling Time::Piece-&amp;gt;use_locale(). This builds a list of the current locale's day and month names which strptime will use to parse with. Note this is a global override and will affect all Time::Piece instances.</source>
          <target state="translated">默认情况下，时间:: Piece :: strptime只能解析美国英语日期名称。同时，Time :: Piece-&amp;gt; strftime（）将返回使用当前配置的系统区域设置的日期名称。这意味着strftime返回的日期可能无法由strptime解析。这是默认行为，可以通过调用Time :: Piece-&amp;gt; use_locale（）来覆盖。这将构建strptime将用来解析的当前语言环境的日期和月份名称的列表。请注意，这是一个全局替代，将影响所有Time :: Piece实例。</target>
        </trans-unit>
        <trans-unit id="d40344d994e23d7372c530bbf0bbd03eeb00a6dc" translate="yes" xml:space="preserve">
          <source>Time::Seconds</source>
          <target state="translated">Time::Seconds</target>
        </trans-unit>
        <trans-unit id="39f6129fd39e3df4fcacf60c5d99f5c6192c805d" translate="yes" xml:space="preserve">
          <source>Time::Seconds - a simple API to convert seconds to other date values</source>
          <target state="translated">Time::Seconds-一个简单的API,用于将秒转换为其他日期值。</target>
        </trans-unit>
        <trans-unit id="cbf1ec1195a651fc24927b61f20ae1c2b1743372" translate="yes" xml:space="preserve">
          <source>Time::Seconds also exports the following constants:</source>
          <target state="translated">Time::Seconds 还输出以下常量。</target>
        </trans-unit>
        <trans-unit id="16d75647463ccb98ccc9ac22ce0d58439164ffe1" translate="yes" xml:space="preserve">
          <source>Time::gmtime</source>
          <target state="translated">Time::gmtime</target>
        </trans-unit>
        <trans-unit id="ca443191990262bcf077810f460d0cd5da0a2497" translate="yes" xml:space="preserve">
          <source>Time::gmtime - by-name interface to Perl's built-in gmtime() function</source>
          <target state="translated">Time::gmtime-Perl内建的gmtime()函数的按名接口</target>
        </trans-unit>
        <trans-unit id="1e32398fc4863ae4d240a706fe6661194fea16dc" translate="yes" xml:space="preserve">
          <source>Time::localtime</source>
          <target state="translated">Time::localtime</target>
        </trans-unit>
        <trans-unit id="1c04f7003a511410fc2dc340400d8f81416e8250" translate="yes" xml:space="preserve">
          <source>Time::localtime - by-name interface to Perl's built-in localtime() function</source>
          <target state="translated">Time::localtime-Perl内置的localtime()函数的按名接口</target>
        </trans-unit>
        <trans-unit id="de41baa484e46c7cf981eab70afe99b8805cc8b2" translate="yes" xml:space="preserve">
          <source>Time::tm</source>
          <target state="translated">Time::tm</target>
        </trans-unit>
        <trans-unit id="21f72c1b3c5d75c7e3444254a7622f9392f93a3d" translate="yes" xml:space="preserve">
          <source>Time::tm - internal object used by Time::gmtime and Time::localtime</source>
          <target state="translated">Time::tm-Time::gmtime 和 Time::localtime 使用的内部对象。</target>
        </trans-unit>
        <trans-unit id="e368ab9a5fbb03e74a7f8b310c3fe08ae2271a05" translate="yes" xml:space="preserve">
          <source>TimeOut</source>
          <target state="translated">TimeOut</target>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="bf885321e4853536c53ad9a2c9930e27e148e561" translate="yes" xml:space="preserve">
          <source>Timeout =&amp;gt; NUM</source>
          <target state="translated">超时=&amp;gt; NUM</target>
        </trans-unit>
        <trans-unit id="c46821e5334d7cbbbeb412cbbc4fae07b635b35c" translate="yes" xml:space="preserve">
          <source>Timeout I/O.</source>
          <target state="translated">超时I/O。</target>
        </trans-unit>
        <trans-unit id="ca2b6328d392947cda8eed37cd6fd0fce114f5ab" translate="yes" xml:space="preserve">
          <source>Timeout for inactivity during {Makefile,Build}.PL?</source>
          <target state="translated">在{Makefile,Build}.PL过程中,超时不活动?</target>
        </trans-unit>
        <trans-unit id="6202f67c7c444f6f4c73b3c31ad99a53b9159e1b" translate="yes" xml:space="preserve">
          <source>Timeout for parsing module versions?</source>
          <target state="translated">解析模块版本超时?</target>
        </trans-unit>
        <trans-unit id="7b97ea2213b8941cebfb4eaa8bbbb9bd0bba9f0a" translate="yes" xml:space="preserve">
          <source>Tiny set of tools for unfortunate souls who cannot use</source>
          <target state="translated">为不能使用的不幸的灵魂提供一套小小的工具。</target>
        </trans-unit>
        <trans-unit id="eb3cc8be33f220718da61643e6e0bc1c501663fd" translate="yes" xml:space="preserve">
          <source>Tips and Techniques</source>
          <target state="translated">提示和技术</target>
        </trans-unit>
        <trans-unit id="092da30065f07adb4a08c52dc1aaf646aa06aee4" translate="yes" xml:space="preserve">
          <source>Tips and Tricks</source>
          <target state="translated">提示和技巧</target>
        </trans-unit>
        <trans-unit id="f7fb128ab2b2b606667607db6ec0f87259f7a1e5" translate="yes" xml:space="preserve">
          <source>Titlecase</source>
          <target state="translated">Titlecase</target>
        </trans-unit>
        <trans-unit id="eb5cc0f84fc345c602dd1accf23180e03ce108cd" translate="yes" xml:space="preserve">
          <source>Tk</source>
          <target state="translated">Tk</target>
        </trans-unit>
        <trans-unit id="767ea1b5d1e2d80e5699c6649ded795c6b5cad19" translate="yes" xml:space="preserve">
          <source>To (en|de)code encodings marked by &lt;code&gt;(**)&lt;/code&gt;, you need &lt;code&gt;Encode::HanExtra&lt;/code&gt;, available from CPAN.</source>
          <target state="translated">要（en | de）编码 &lt;code&gt;(**)&lt;/code&gt; 标记的编码，您需要 &lt;code&gt;Encode::HanExtra&lt;/code&gt; （可从CPAN获得）。</target>
        </trans-unit>
        <trans-unit id="75e9f1113dd228531b5734915ff74dd66ea601f0" translate="yes" xml:space="preserve">
          <source>To (re)open &lt;code&gt;STDOUT&lt;/code&gt; or &lt;code&gt;STDERR&lt;/code&gt; as an in-memory file, close it first:</source>
          <target state="translated">要（重新）打开 &lt;code&gt;STDOUT&lt;/code&gt; 或 &lt;code&gt;STDERR&lt;/code&gt; 作为内存文件，请首先将其关闭：</target>
        </trans-unit>
        <trans-unit id="7a790472031c710be009a7b4a42a45592085ee5d" translate="yes" xml:space="preserve">
          <source>To OO or not to OO?</source>
          <target state="translated">要OO还是不要OO?</target>
        </trans-unit>
        <trans-unit id="2e5fb83e42913577879316262366950ec7aec439" translate="yes" xml:space="preserve">
          <source>To access servers outside these type of firewalls with perl, you need Net::FTP.</source>
          <target state="translated">要用perl访问这些类型的防火墙之外的服务器,你需要Net::FTP。</target>
        </trans-unit>
        <trans-unit id="9715ff5bc3ceda6802c5265803ef21d4705c83eb" translate="yes" xml:space="preserve">
          <source>To access servers outside these types of firewalls with perl (even for ftp), you need LWP or HTTP::Tiny.</source>
          <target state="translated">要用perl访问这些类型的防火墙之外的服务器(即使是ftp),你需要LWP或HTTP::Tiny。</target>
        </trans-unit>
        <trans-unit id="75353a5a7f7320bec3542821474a8dbab7c8c12c" translate="yes" xml:space="preserve">
          <source>To access the actual value that an SV points to, you can use the macros:</source>
          <target state="translated">要访问SV指向的实际值,可以使用宏。</target>
        </trans-unit>
        <trans-unit id="18ca46dd427588f094e1ba9ca5a38e797fcd2ac7" translate="yes" xml:space="preserve">
          <source>To access this functionality without the core overrides, pass the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; an empty import list, and then access function functions with their full qualified names. On the other hand, the built-ins are still available via the &lt;code&gt;CORE::&lt;/code&gt; pseudo-package.</source>
          <target state="translated">要在没有核心替代的情况下访问此功能，请传递 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 空的导入列表，然后使用具有完整限定名的功能函数进行访问。另一方面，仍可以通过 &lt;code&gt;CORE::&lt;/code&gt; 伪程序包使用内置程序。</target>
        </trans-unit>
        <trans-unit id="dca3331d12806630976595e1bbb7790e715a99c2" translate="yes" xml:space="preserve">
          <source>To access this functionality without the core overrides, pass the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; an empty import list, and then access function functions with their full qualified names. The built-ins are always still available via the &lt;code&gt;CORE::&lt;/code&gt; pseudo-package.</source>
          <target state="translated">要在没有核心替代的情况下访问此功能，请传递 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 空的导入列表，然后使用具有完整限定名的功能函数进行访问。内置的始终可以通过 &lt;code&gt;CORE::&lt;/code&gt; 伪包获得。</target>
        </trans-unit>
        <trans-unit id="00d7f9df22362a2f3c85b921564fc19258d8388c" translate="yes" xml:space="preserve">
          <source>To access this functionality without the core overrides, pass the &lt;code&gt;use&lt;/code&gt; an empty import list, and then access function functions with their full qualified names. On the other hand, the built-ins are still available via the &lt;code&gt;CORE::&lt;/code&gt; pseudo-package.</source>
          <target state="translated">要在没有核心替代的情况下访问此功能，请传递 &lt;code&gt;use&lt;/code&gt; 空的导入列表，然后使用具有完整限定名的功能函数进行访问。另一方面，仍可以通过 &lt;code&gt;CORE::&lt;/code&gt; 伪软件包使用内置的插件。</target>
        </trans-unit>
        <trans-unit id="8104695610bb754f8e946466b35dfbf1827c0fd9" translate="yes" xml:space="preserve">
          <source>To access this functionality without the core overrides, pass the &lt;code&gt;use&lt;/code&gt; an empty import list, and then access function functions with their full qualified names. The built-ins are always still available via the &lt;code&gt;CORE::&lt;/code&gt; pseudo-package.</source>
          <target state="translated">要在没有核心替代的情况下访问此功能，请传递 &lt;code&gt;use&lt;/code&gt; 空的导入列表，然后使用具有完整限定名的功能函数进行访问。内置的始终可以通过 &lt;code&gt;CORE::&lt;/code&gt; 伪包获得。</target>
        </trans-unit>
        <trans-unit id="ce78b43e2a908e0a4f8a1b6833f38009e23883a3" translate="yes" xml:space="preserve">
          <source>To accomplish this behaviour, simply specify an array reference as the destination for the option:</source>
          <target state="translated">要实现这一行为,只需指定一个数组引用作为选项的目标。</target>
        </trans-unit>
        <trans-unit id="f61067f007c7ba160effec3a91d355b4f290080e" translate="yes" xml:space="preserve">
          <source>To actually alter the visible command line, you can assign to the variable $0 as documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. This won't work on all operating systems, though. Daemon programs like sendmail place their state there, as in:</source>
          <target state="translated">要实际更改可见命令行，可以将变量$ 0赋给&lt;a href=&quot;perlvar&quot;&gt;perlvar中记录的内容&lt;/a&gt;。不过，这并不适用于所有操作系统。诸如sendmail之类的守护程序将其状态放置在此处，如下所示：</target>
        </trans-unit>
        <trans-unit id="e6257d01bcff432617bc3aaafa5362a537c023ed" translate="yes" xml:space="preserve">
          <source>To actually do the magic method call, we have to call a subroutine in Perl space: &lt;code&gt;call_method&lt;/code&gt; takes care of that, and it's described in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;. We call the &lt;code&gt;PUSH&lt;/code&gt; method in scalar context, and we're going to discard its return value. The call_method() function removes the top element of the mark stack, so there is nothing for the caller to clean up.</source>
          <target state="translated">要实际执行魔术方法调用，我们必须在Perl空间中调用一个子例程： &lt;code&gt;call_method&lt;/code&gt; 负责该操作，这在&lt;a href=&quot;perlcall&quot;&gt;perlcall中进行了&lt;/a&gt;描述。我们在标量上下文中调用 &lt;code&gt;PUSH&lt;/code&gt; 方法，我们将舍弃其返回值。call_method（）函数将删除标记堆栈的顶部元素，因此调用者无需清理任何内容。</target>
        </trans-unit>
        <trans-unit id="6122d22a4decb5ce34478a60d87283b09ca23b69" translate="yes" xml:space="preserve">
          <source>To actually run a script set-id, if you don't have the safe version of set-id scripts, you'll need to put a C wrapper around the script. A C wrapper is just a compiled program that does nothing except call your Perl program. Compiled programs are not subject to the kernel bug that plagues set-id scripts. Here's a simple wrapper, written in C:</source>
          <target state="translated">要真正运行一个脚本set-id,如果你没有安全版的set-id脚本,你需要在脚本周围放一个C包装器。C包装器就是一个编译后的程序,除了调用你的Perl程序外,什么都不做。编译后的程序不会受到困扰 set-id 脚本的内核 bug 的影响。这里有一个简单的封装程序,用C语言写的。</target>
        </trans-unit>
        <trans-unit id="2c5d4ebd8ab0875fd7f6df0d61ffd7b676158145" translate="yes" xml:space="preserve">
          <source>To add a new alias to a given encoding, use:</source>
          <target state="translated">要为一个给定的编码添加新的别名,使用:</target>
        </trans-unit>
        <trans-unit id="504c5fdbd3b3208314b10451eb998ac1dfbb6a34" translate="yes" xml:space="preserve">
          <source>To add lines before a certain line, you can add a line (or lines!) before Perl prints &lt;code&gt;$_&lt;/code&gt; :</source>
          <target state="translated">要在某行之前添加行，可以在Perl打印 &lt;code&gt;$_&lt;/code&gt; 之前添加一行（或多行！）：</target>
        </trans-unit>
        <trans-unit id="664ca3b18fd212ce34e3ecc1b835f5946d711935" translate="yes" xml:space="preserve">
          <source>To add lines before a certain line, you can add a line (or lines!) before Perl prints &lt;code&gt;$_&lt;/code&gt;:</source>
          <target state="translated">要在某行之前添加行，可以在Perl打印 &lt;code&gt;$_&lt;/code&gt; 之前添加一行（或多行！）：</target>
        </trans-unit>
        <trans-unit id="41c5424e693984510192a96a5bd33b04a6c7bcb7" translate="yes" xml:space="preserve">
          <source>To add one to something automatically, hence the name of the &lt;code&gt;++&lt;/code&gt; operator. To instead subtract one from something automatically is known as an &amp;ldquo;autodecrement&amp;rdquo;.</source>
          <target state="translated">自动将某物添加到某物，因此是 &lt;code&gt;++&lt;/code&gt; 运算符的名称。取而代之的是自动从某项中减去一个，称为&amp;ldquo;自动递减&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="62767b0d851017800baeabeacc96e05ce69f9c80" translate="yes" xml:space="preserve">
          <source>To add to user-friendliness, our server prompts the user for commands. Most servers don't do this. Because of the prompt without a newline, you'll have to use the &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; variant of the interactive client above.</source>
          <target state="translated">为了增加用户友好性，我们的服务器会提示用户输入命令。大多数服务器不这样做。由于提示中没有换行符，因此您必须使用上面的交互式客户端的 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 变体。</target>
        </trans-unit>
        <trans-unit id="2982163185a13aaba90c2350554d80613d204e6d" translate="yes" xml:space="preserve">
          <source>To add to user-friendliness, our server prompts the user for commands. Most servers don't do this. Because of the prompt without a newline, you'll have to use the &lt;code&gt;sysread&lt;/code&gt; variant of the interactive client above.</source>
          <target state="translated">为了增加用户友好性，我们的服务器提示用户输入命令。大多数服务器不这样做。由于提示中没有换行符，因此您必须使用上面的交互式客户端的 &lt;code&gt;sysread&lt;/code&gt; 变体。</target>
        </trans-unit>
        <trans-unit id="0c2508ff4f655eadc6c615c0836ceada22445901" translate="yes" xml:space="preserve">
          <source>To address these deficiencies, the concept of locales was invented (formally the ISO C, XPG4, POSIX 1.c &quot;locale system&quot;). And applications were and are being written that use the locale mechanism. The process of making such an application take account of its users' preferences in these kinds of matters is called &lt;b&gt;internationalization&lt;/b&gt; (often abbreviated as &lt;b&gt;i18n&lt;/b&gt;); telling such an application about a particular set of preferences is known as &lt;b&gt;localization&lt;/b&gt; (&lt;b&gt;l10n&lt;/b&gt;).</source>
          <target state="translated">为了解决这些缺陷，发明了语言环境的概念（正式称为ISO C，XPG4，POSIX 1.c&amp;ldquo;语言环境系统&amp;rdquo;）。并正在编写使用语言环境机制的应用程序。制作此类应用程序的过程会考虑到用户在此类问题上的偏好，这称为&lt;b&gt;国际化&lt;/b&gt;（通常缩写为&lt;b&gt;i18n&lt;/b&gt;）；告诉此类应用程序特定的一组首选项称为&lt;b&gt;本地化&lt;/b&gt;（&lt;b&gt;l10n&lt;/b&gt;）。</target>
        </trans-unit>
        <trans-unit id="38480288701c4661e4a26dcbd6037e4ac31c3101" translate="yes" xml:space="preserve">
          <source>To aid debugging, the source file</source>
          <target state="translated">为了帮助调试,源文件</target>
        </trans-unit>
        <trans-unit id="b056ef758d989b19b1755b858981a3d1c4ee3ad4" translate="yes" xml:space="preserve">
          <source>To alleviate the second problem (partially) it is advised to write your scripts like this:</source>
          <target state="translated">为了缓解第二个问题(部分),建议你这样写脚本。</target>
        </trans-unit>
        <trans-unit id="033bf41b49c5ad8519d831cfcfc92f95acf893c1" translate="yes" xml:space="preserve">
          <source>To allow programs to process arguments that look like switches, but aren't, both functions will stop processing switches when they see the argument &lt;code&gt;--&lt;/code&gt; . The &lt;code&gt;--&lt;/code&gt; will be removed from @ARGV.</source>
          <target state="translated">为了允许程序处理看起来像开关的参数，而看起来却不是，两个函数在看到参数 &lt;code&gt;--&lt;/code&gt; 时都会停止处理开关。本 &lt;code&gt;--&lt;/code&gt; 从@ARGV被删除。</target>
        </trans-unit>
        <trans-unit id="26d2f668076a8bd4840d99c6ca84eae07eb71067" translate="yes" xml:space="preserve">
          <source>To allow programs to process arguments that look like switches, but aren't, both functions will stop processing switches when they see the argument &lt;code&gt;--&lt;/code&gt;. The &lt;code&gt;--&lt;/code&gt; will be removed from @ARGV.</source>
          <target state="translated">为了使程序能够处理看起来像开关的参数，而看起来却不是，两个函数都将在看到参数 &lt;code&gt;--&lt;/code&gt; 时停止处理开关。本 &lt;code&gt;--&lt;/code&gt; 从@ARGV被删除。</target>
        </trans-unit>
        <trans-unit id="2288a81816c59a1de87c3ad78e6617983dda9fd7" translate="yes" xml:space="preserve">
          <source>To allow the XSUB for rpcb_gettime() to have a default host value the parameters to the XSUB could be rearranged. The XSUB will then call the real rpcb_gettime() function with the parameters in the correct order. This XSUB can be called from Perl with either of the following statements:</source>
          <target state="translated">为了让rpcb_gettime()的XSUB有一个默认的主机值,XSUB的参数可以重新排列。然后XSUB将以正确的顺序调用真正的rpcb_gettime()函数的参数。这个XSUB可以在Perl中用以下任何一个语句来调用。</target>
        </trans-unit>
        <trans-unit id="4bdd80dbd948c58cb0887db4e2666aa7ba8a1b77" translate="yes" xml:space="preserve">
          <source>To ask for the next layer down use PerlIONext(PerlIO *f).</source>
          <target state="translated">要请求下一层向下使用PerlIONext(PerlIO *f)。</target>
        </trans-unit>
        <trans-unit id="5e82b72795636964d66437770c692b7d03ceb23b" translate="yes" xml:space="preserve">
          <source>To assign a specific &lt;b&gt;network address&lt;/b&gt; to a &lt;b&gt;socket&lt;/b&gt;.</source>
          <target state="translated">要指定一个特定的&lt;b&gt;网络地址&lt;/b&gt;的&lt;b&gt;插座&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="c2c2805d5269d7141c86f56aaf1c2c2a76a26622" translate="yes" xml:space="preserve">
          <source>To assist you &lt;code&gt;test_test&lt;/code&gt; can colour the background of the debug information to disambiguate the different types of output. The debug output will have its background coloured green and red. The green part represents the text which is the same between the executed and actual output, the red shows which part differs.</source>
          <target state="translated">为了帮助您， &lt;code&gt;test_test&lt;/code&gt; 可以为调试信息的背景着色，以消除不同类型的输出的歧义。调试输出的背景将变为绿色和红色。绿色部分表示已执行的输出和实际输出之间的文本相同，红色部分表示不同的文本。</target>
        </trans-unit>
        <trans-unit id="e8e1cbea5e7824434cdf9fc699c75f29c54b93f0" translate="yes" xml:space="preserve">
          <source>To auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt; .</source>
          <target state="translated">要自动检测并解压缩RFC 1950或RFC 1952数据流（即gzip），请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da07f070c84b91e83551c266e4da3f67a05bb198" translate="yes" xml:space="preserve">
          <source>To auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt;.</source>
          <target state="translated">要自动检测并解压缩RFC 1950或RFC 1952数据流（即gzip），请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b525fdc47ff53e260dc0931cfbc7865b5eae8d3" translate="yes" xml:space="preserve">
          <source>To avoid ambiguity, when signatures are enabled the special syntax for prototypes is disabled. There is no attempt to guess whether a parenthesised group was intended to be a prototype or a signature. To give a subroutine a prototype under these circumstances, use a &lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype attribute&lt;/a&gt;. For example,</source>
          <target state="translated">为避免歧义，启用签名后，将禁用原型的特殊语法。没有尝试猜测带括号的组是作为原型还是签名。要在这种情况下为子例程提供原型，请使用&lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype属性&lt;/a&gt;。例如，</target>
        </trans-unit>
        <trans-unit id="409b9ee9e716af7051876e4ad525c073a4badea1" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code who are running earlier versions of Perl with mysterious failures, put this sort of thing at the top of your file to signal that your code will work</source>
          <target state="translated">为了避免让那些正在运行早期版本的Perl的潜在用户对你的代码感到困惑,请在文件的顶部写上这样的内容,以表明你的代码可以正常工作。</target>
        </trans-unit>
        <trans-unit id="cdb270b498c0b4af5dad93d34e6e87c778aa6616" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code who are running earlier versions of Perl with mysterious syntax errors, put this sort of thing at the top of your file to signal that your code will work</source>
          <target state="translated">为了避免那些正在运行早期版本的Perl的潜在用户被神秘的语法错误所迷惑,请在文件的顶部写上这样的内容,以表明你的代码可以正常工作</target>
        </trans-unit>
        <trans-unit id="010f767fa3f7758e437e81843e72a2beb1516ec0" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code with mysterious syntax errors, put something like this at the top of your script:</source>
          <target state="translated">为了避免你的代码的潜在用户被神秘的语法错误所迷惑,在你的脚本的顶部写上这样的内容。</target>
        </trans-unit>
        <trans-unit id="92c9a11d8c00dc701cc8cb47a28dac284fb7ca76" translate="yes" xml:space="preserve">
          <source>To avoid creating a new SV every time &lt;code&gt;SaveSub2&lt;/code&gt; is called, the function first checks to see if it has been called before. If not, then space for a new SV is allocated and the reference to the Perl subroutine &lt;code&gt;name&lt;/code&gt; is copied to the variable &lt;code&gt;keepSub&lt;/code&gt; in one operation using &lt;code&gt;newSVsv&lt;/code&gt; . Thereafter, whenever &lt;code&gt;SaveSub2&lt;/code&gt; is called, the existing SV, &lt;code&gt;keepSub&lt;/code&gt; , is overwritten with the new value using &lt;code&gt;SvSetSV&lt;/code&gt; .</source>
          <target state="translated">为了避免每次调用 &lt;code&gt;SaveSub2&lt;/code&gt; 时都创建新的SV ，该函数首先检查是否已调用过它。如果不是，则分配用于新SV的空间，并使用 &lt;code&gt;newSVsv&lt;/code&gt; 在一次操作中将对 Perl子例程 &lt;code&gt;name&lt;/code&gt; 的引用复制到变量 &lt;code&gt;keepSub&lt;/code&gt; 中。此后，每当 &lt;code&gt;SaveSub2&lt;/code&gt; 被调用时，现有SV， &lt;code&gt;keepSub&lt;/code&gt; ，改写为使用新的值 &lt;code&gt;SvSetSV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb5249a309596988b57e0fd6c4b6cf1306fbd076" translate="yes" xml:space="preserve">
          <source>To avoid creating a new SV every time &lt;code&gt;SaveSub2&lt;/code&gt; is called, the function first checks to see if it has been called before. If not, then space for a new SV is allocated and the reference to the Perl subroutine &lt;code&gt;name&lt;/code&gt; is copied to the variable &lt;code&gt;keepSub&lt;/code&gt; in one operation using &lt;code&gt;newSVsv&lt;/code&gt;. Thereafter, whenever &lt;code&gt;SaveSub2&lt;/code&gt; is called, the existing SV, &lt;code&gt;keepSub&lt;/code&gt;, is overwritten with the new value using &lt;code&gt;SvSetSV&lt;/code&gt;.</source>
          <target state="translated">为了避免每次调用 &lt;code&gt;SaveSub2&lt;/code&gt; 时都创建新的SV ，该函数首先检查是否已调用过它。如果没有，那么将为新的SV分配空间，并使用 &lt;code&gt;newSVsv&lt;/code&gt; 在一次操作中将对Perl子例程 &lt;code&gt;name&lt;/code&gt; 的引用复制到变量 &lt;code&gt;keepSub&lt;/code&gt; 中。此后，每当 &lt;code&gt;SaveSub2&lt;/code&gt; 被调用时，现有SV， &lt;code&gt;keepSub&lt;/code&gt; ，改写为使用新的值 &lt;code&gt;SvSetSV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f1c469efc6b2f6bb3fb09ea0c807689f209337a" translate="yes" xml:space="preserve">
          <source>To avoid memory leaks, all trailing duplicate entries in @INC are removed.</source>
          <target state="translated">为了避免内存泄漏,@INC中所有尾部重复的条目都被删除。</target>
        </trans-unit>
        <trans-unit id="fe0f91423917e2fcf830eb3362231efceaad6437" translate="yes" xml:space="preserve">
          <source>To avoid relying on an object's underlying representation, if the smartmatch's right operand is an object that doesn't overload &lt;code&gt;~~&lt;/code&gt; , it raises the exception &quot;&lt;code&gt;Smartmatching a non-overloaded object
breaks encapsulation&lt;/code&gt; &quot;. That's because one has no business digging around to see whether something is &quot;in&quot; an object. These are all illegal on objects without a &lt;code&gt;~~&lt;/code&gt; overload:</source>
          <target state="translated">为了避免依赖对象的基础表示，如果smartmatch的正确操作数是不重载 &lt;code&gt;~~&lt;/code&gt; 的对象，则会引发异常&amp;ldquo; &lt;code&gt;Smartmatching a non-overloaded object breaks encapsulation&lt;/code&gt; &amp;rdquo;。那是因为没有人在四处寻找东西是否在物体中。这些对没有 &lt;code&gt;~~&lt;/code&gt; 重载的对象都是非法的：</target>
        </trans-unit>
        <trans-unit id="c22d05674967c3bc15cf7ec7d92f09d20cda4ca5" translate="yes" xml:space="preserve">
          <source>To avoid relying on an object's underlying representation, if the smartmatch's right operand is an object that doesn't overload &lt;code&gt;~~&lt;/code&gt;, it raises the exception &quot;&lt;code&gt;Smartmatching a non-overloaded object breaks encapsulation&lt;/code&gt;&quot;. That's because one has no business digging around to see whether something is &quot;in&quot; an object. These are all illegal on objects without a &lt;code&gt;~~&lt;/code&gt; overload:</source>
          <target state="translated">为了避免依赖对象的基础表示，如果smartmatch的正确操作数是不重载 &lt;code&gt;~~&lt;/code&gt; 的对象，则会引发异常&amp;ldquo; &lt;code&gt;Smartmatching a non-overloaded object breaks encapsulation&lt;/code&gt; &amp;rdquo;。那是因为没有人在四处寻找事物是否在物体中。这些对没有 &lt;code&gt;~~&lt;/code&gt; 重载的对象都是非法的：</target>
        </trans-unit>
        <trans-unit id="55a1998bc2a5a4986f2bb06eff8015bbc211cdc8" translate="yes" xml:space="preserve">
          <source>To avoid slab fragmentation, freed ops are marked as freed and attached to the slab's freed chain (an idea stolen from DBM::Deep). Those freed ops are reused when possible. Not reusing freed ops would be simpler, but it would result in significantly higher memory usage for programs with large &lt;code&gt;if (DEBUG) {...}&lt;/code&gt; blocks.</source>
          <target state="translated">为了避免平板碎片化，将释放的操作标记为已释放，并附加到平板的释放链上（从DBM :: Deep窃取的主意）。那些释放的操作将在可能的情况下被重用。不重用释放的操作会更简单，但是对于带有 &lt;code&gt;if (DEBUG) {...}&lt;/code&gt; 块的程序，这将导致显着更高的内存使用率。</target>
        </trans-unit>
        <trans-unit id="4c10393ba7ca423ef6dd3c94a2b581675efc33a8" translate="yes" xml:space="preserve">
          <source>To avoid the possibility of miscoordination, Perl now flushes FILEHANDLE before locking or unlocking it.</source>
          <target state="translated">为了避免误操作的可能性,Perl现在在锁定或解锁FILEHANDLE之前会先刷新它。</target>
        </trans-unit>
        <trans-unit id="3c85a34364c95e0f00f8b4537e9fe9720d82fa1b" translate="yes" xml:space="preserve">
          <source>To avoid this blocking behaviour, the caller should pass in the result of such a lookup using the &lt;code&gt;PeerAddrInfo&lt;/code&gt; or &lt;code&gt;LocalAddrInfo&lt;/code&gt; arguments. This can be achieved by using &lt;a href=&quot;Net::LibAsyncNS&quot;&gt;Net::LibAsyncNS&lt;/a&gt;, or the &lt;code&gt;getaddrinfo(3)&lt;/code&gt; function can be called in a child process.</source>
          <target state="translated">为了避免这种阻塞行为，调用者应使用 &lt;code&gt;PeerAddrInfo&lt;/code&gt; 或 &lt;code&gt;LocalAddrInfo&lt;/code&gt; 参数传递这种查找的结果。这可以通过使用&lt;a href=&quot;Net::LibAsyncNS&quot;&gt;Net :: LibAsyncNS&lt;/a&gt;来实现，或者可以在子进程中调用 &lt;code&gt;getaddrinfo(3)&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="5d5d75934a6f7e951fd9357cb74cb7683ab1e280" translate="yes" xml:space="preserve">
          <source>To avoid this problem, either put in extra parentheses or use the super low precedence &lt;code&gt;or&lt;/code&gt; operator:</source>
          <target state="translated">为避免此问题，请添加额外的括号或使用超低优先级 &lt;code&gt;or&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="766d42f164385b7f29a7e92b44d6d78b6d17a595" translate="yes" xml:space="preserve">
          <source>To avoid this problem, when it encounters a here document whilst extracting from a modifiable string, &lt;code&gt;extract_quotelike&lt;/code&gt; silently rearranges the string to an equivalent piece of Perl:</source>
          <target state="translated">为了避免这个问题，当它在从可修改的字符串中提取时遇到一个here文档时， &lt;code&gt;extract_quotelike&lt;/code&gt; 会默默地将该字符串重新排列为等效的Perl：</target>
        </trans-unit>
        <trans-unit id="da9ceee7d2a6a8bd92bf59b8dd4824301848ef6c" translate="yes" xml:space="preserve">
          <source>To avoid this warning and to avoid having different output encodings in a single stream, always specify an encoding explicitly, for example with a PerlIO layer:</source>
          <target state="translated">为了避免这个警告,并避免在一个流中有不同的输出编码,总是显式地指定一个编码,例如用PerlIO层。</target>
        </trans-unit>
        <trans-unit id="35af978891563db2721278dcfd7e8de9b9ef61ce" translate="yes" xml:space="preserve">
          <source>To avoid this, whenever a CV and its associated pad is freed, any &lt;code&gt;&amp;amp;&lt;/code&gt; entries in the pad are explicitly removed from the pad, and if the refcount of the pointed-to anon sub is still positive, then that child's &lt;code&gt;CvOUTSIDE&lt;/code&gt; is set to point to its grandparent. This will only occur in the single specific case of a non-closure anon prototype having one or more active references (such as &lt;code&gt;$a&lt;/code&gt; above).</source>
          <target state="translated">为避免这种情况，每当释放CV及其关联的填充板时，该填充板中的所有 &lt;code&gt;&amp;amp;&lt;/code&gt; 条目都会从填充板中显式删除，并且如果所指向的anon子的引用计数仍为正，则该孩子的 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 设置为指向给祖父母这仅在具有一个或多个活动引用（例如上述 &lt;code&gt;$a&lt;/code&gt; ）的非封闭式匿名原型的单个特定情况下发生。</target>
        </trans-unit>
        <trans-unit id="892f516de74c75c59b1eb990ddf92d3f52eefdaf" translate="yes" xml:space="preserve">
          <source>To avoid this, you can force the Makefile to be rebuilt whenever you change the module containing the version number by adding this to your WriteMakefile() arguments.</source>
          <target state="translated">为了避免这种情况,你可以通过在你的WriteMakefile()参数中添加以下内容来强制Makefile在每次改变包含版本号的模块时被重建。</target>
        </trans-unit>
        <trans-unit id="79bc3cfb105613cbe5f2c89b6ab087189a45bded" translate="yes" xml:space="preserve">
          <source>To avoid wasted work when a restart is needed, the sizing pass is abandoned - &lt;code&gt;regatom()&lt;/code&gt; immediately returns NULL, setting the flag &lt;code&gt;RESTART_UTF8&lt;/code&gt; . (This action is encapsulated using the macro &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; .) This restart request is propagated up the call chain in a similar fashion, until it is &quot;caught&quot; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , which marks the pattern as containing Unicode, and restarts the sizing pass. It is also possible for constructions within run-time code blocks to turn out to need Unicode representation., which is signalled by &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; returning false to &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; .</source>
          <target state="translated">为了避免在需要重新启动时浪费工作，调整大小通道被放弃 &lt;code&gt;regatom()&lt;/code&gt; 立即返回NULL，并设置标志 &lt;code&gt;RESTART_UTF8&lt;/code&gt; 。 （此操作使用宏 &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; 封装。）此重新启动请求以类似的方式在调用链中传播，直到被&amp;ldquo;捕获&amp;rdquo;在 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 中，该标志将模式标记为包含Unicode，然后重新启动调整大小。运行时代码块中的构造也有可能需要Unicode表示。这由 &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; 返回false到 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 来表示。</target>
        </trans-unit>
        <trans-unit id="09e124c75c7cbe80f3e4228168f11f802fe412a9" translate="yes" xml:space="preserve">
          <source>To be able to access the two parameters that were pushed onto the stack after they return from</source>
          <target state="translated">为了能够访问两个参数,这两个参数在它们从</target>
        </trans-unit>
        <trans-unit id="6e3a208559e7fc6775f8912d077235f17cca0135" translate="yes" xml:space="preserve">
          <source>To be announced.</source>
          <target state="translated">有待宣布。</target>
        </trans-unit>
        <trans-unit id="161647c06ada22688c122c82ae94e4258d4b89c7" translate="yes" xml:space="preserve">
          <source>To be announced. Or deleted.</source>
          <target state="translated">待公布。或删除。</target>
        </trans-unit>
        <trans-unit id="1942f94bc444abb1b89482bc04403e0f7a2e9a63" translate="yes" xml:space="preserve">
          <source>To be compatible with .Net regular expressions, &lt;code&gt;\g{name}&lt;/code&gt; may also be written as &lt;code&gt;\k{name}&lt;/code&gt; , &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'name'&lt;/code&gt;.</source>
          <target state="translated">为了与.Net正则表达式兼容， &lt;code&gt;\g{name}&lt;/code&gt; 也可以写为 &lt;code&gt;\k{name}&lt;/code&gt; ， &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; 或 &lt;code&gt;\k'name'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f26c77c319cb6291a616300d3aa5bcb9b742805" translate="yes" xml:space="preserve">
          <source>To be compatible with .Net regular expressions, &lt;code&gt;\g{name}&lt;/code&gt; may also be written as &lt;code&gt;\k{name}&lt;/code&gt;, &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'name'&lt;/code&gt;.</source>
          <target state="translated">为了与.Net正则表达式兼容， &lt;code&gt;\g{name}&lt;/code&gt; 也可以写为 &lt;code&gt;\k{name}&lt;/code&gt; ， &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; 或 &lt;code&gt;\k'name'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cda9b7c28c9197f9e2d7b4ff8ca73ca58bad94f4" translate="yes" xml:space="preserve">
          <source>To be even more flexible, use &lt;code&gt;done_testing&lt;/code&gt;. This means we're just running some tests, don't know how many. [6]</source>
          <target state="translated">为了更加灵活，请使用 &lt;code&gt;done_testing&lt;/code&gt; 。这意味着我们只是在运行一些测试，不知道有多少。[6]</target>
        </trans-unit>
        <trans-unit id="bc3bab69ee4c24015f181f505f714806f55a6a5d" translate="yes" xml:space="preserve">
          <source>To be fully compatible with the Exporter and MakeMaker modules you should store your module's version number in a non-my package variable called $VERSION. This should be a positive floating point number with at least two digits after the decimal (i.e., hundredths, e.g, &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt; ). Don't use a &quot;1.3.2&quot; style version. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for details.</source>
          <target state="translated">为了与Exporter和MakeMaker模块完全兼容，应将模块的版本号存储在名为$ VERSION的非我的程序包变量中。这应该是一个正浮点数，在小数点后至少应有两位数字（例如，百分之一，例如 &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt; ）。不要使用&amp;ldquo; 1.3.2&amp;rdquo;样式的版本。有关详细信息，请参见&lt;a href=&quot;exporter&quot;&gt;导出&lt;/a&gt;器。</target>
        </trans-unit>
        <trans-unit id="aca5a42cae80e068514dd5dee0bc31352df05942" translate="yes" xml:space="preserve">
          <source>To be fully compatible with the Exporter and MakeMaker modules you should store your module's version number in a non-my package variable called $VERSION. This should be a positive floating point number with at least two digits after the decimal (i.e., hundredths, e.g, &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt;). Don't use a &quot;1.3.2&quot; style version. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for details.</source>
          <target state="translated">为了与Exporter和MakeMaker模块完全兼容，应将模块的版本号存储在名为$ VERSION的非我的程序包变量中。这应该是一个正浮点数，在小数点后至少应有两位数字（即百分之一，例如 &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt; ）。不要使用&amp;ldquo; 1.3.2&amp;rdquo;样式的版本。有关详细信息，请参见&lt;a href=&quot;exporter&quot;&gt;导出&lt;/a&gt;器。</target>
        </trans-unit>
        <trans-unit id="781abe7cd10e483cb21c7189d334aa3e4eaca732" translate="yes" xml:space="preserve">
          <source>To be more precise, we will say that a regex program is an encoding of a graph. Each node in the graph corresponds to part of the original regex pattern, such as a literal string or a branch, and has a pointer to the nodes representing the next component to be matched. Since &quot;node&quot; and &quot;opcode&quot; already have other meanings in the perl source, we will call the nodes in a regex program &quot;regops&quot;.</source>
          <target state="translated">更准确地说,我们会说一个regex程序是一个图的编码。图中的每一个节点都对应着原始regex模式的一部分,比如一个文字字符串或一个分支,并且有一个指针指向代表下一个要匹配的组件的节点。由于 &quot;节点 &quot;和 &quot;opcode &quot;在perl源码中已经有了其他含义,所以我们将regex程序中的节点称为 &quot;regops&quot;。</target>
        </trans-unit>
        <trans-unit id="a03a7a550b2afe3393fb820749da17491cf98371" translate="yes" xml:space="preserve">
          <source>To be pedantic, the comparison is actually &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR)&lt;/code&gt; , but that is only an issue if you use a floating point expression; when implicitly using &lt;code&gt;$.&lt;/code&gt; as described in the previous paragraph, the comparison is &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;($.)&lt;/code&gt; which is only an issue when &lt;code&gt;$.&lt;/code&gt; is set to a floating point value and you are not reading from a file. Furthermore, &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; or &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will not do what you want in scalar context because each of the operands are evaluated using their integer representation.</source>
          <target state="translated">要学究，比较实际上是 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR)&lt;/code&gt; ，但这仅是使用浮点表达式的问题；隐式使用 &lt;code&gt;$.&lt;/code&gt; 如上一段所述，比较是 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;($.)&lt;/code&gt; ，这只是在 &lt;code&gt;$.&lt;/code&gt; 时有问题。设置为浮点值，并且您不是从文件中读取。此外， &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; 或 &lt;code&gt;2.18 .. 3.14&lt;/code&gt; 在标量上下文中将无法执行您想要的操作，因为每个操作数均使用其整数表示来求值。</target>
        </trans-unit>
        <trans-unit id="7a2cc51866f8f7fa513bdcb0e655d22cd247b768" translate="yes" xml:space="preserve">
          <source>To be pedantic, the comparison is actually &lt;code&gt;int(EXPR) == int(EXPR)&lt;/code&gt;, but that is only an issue if you use a floating point expression; when implicitly using &lt;code&gt;$.&lt;/code&gt; as described in the previous paragraph, the comparison is &lt;code&gt;int(EXPR) == int($.)&lt;/code&gt; which is only an issue when &lt;code&gt;$.&lt;/code&gt; is set to a floating point value and you are not reading from a file. Furthermore, &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; or &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will not do what you want in scalar context because each of the operands are evaluated using their integer representation.</source>
          <target state="translated">要学究一点，比较实际上是 &lt;code&gt;int(EXPR) == int(EXPR)&lt;/code&gt; ，但这仅在使用浮点表达式时才是问题；隐式使用 &lt;code&gt;$.&lt;/code&gt; 如上一段所述，比较是 &lt;code&gt;int(EXPR) == int($.)&lt;/code&gt; ，这只是在 &lt;code&gt;$.&lt;/code&gt; 时有问题。设置为浮点值，并且您不是从文件中读取。此外，在标量上下文中， &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; 或 &lt;code&gt;2.18 .. 3.14&lt;/code&gt; 不会执行您想要的操作，因为每个操作数都是使用它们的整数表示来求值的。</target>
        </trans-unit>
        <trans-unit id="ed53a49e46f6db6479ffd9a906bbff37f48f8995" translate="yes" xml:space="preserve">
          <source>To be polite to other functions wrapping your own you usually want to increment &lt;code&gt;$Level&lt;/code&gt; rather than set it to a constant.</source>
          <target state="translated">为了礼貌地使用其他包装自己的函数，通常需要增加 &lt;code&gt;$Level&lt;/code&gt; 而不是将其设置为常量。</target>
        </trans-unit>
        <trans-unit id="377966b7899d2c6cc0617addc0bc388cc67a68ae" translate="yes" xml:space="preserve">
          <source>To be portable each component of a module name should be limited to 11 characters. If it might be used on MS-DOS then try to ensure each is unique in the first 8 characters. Nested modules make this easier.</source>
          <target state="translated">为了便于移植,模块名称中的每个组件应限制在11个字符以内。如果它可能在MS-DOS上使用,那么尽量保证每个模块的前8个字符是唯一的。嵌套的模块可以使这一点更容易。</target>
        </trans-unit>
        <trans-unit id="82fd649ae548631dbfdff32da1fa30eb76335c87" translate="yes" xml:space="preserve">
          <source>To be safe, we should have anchored the above example, to prevent matches for something like &lt;code&gt;Hebrew_Braille&lt;/code&gt;, but there aren't any script names like that, so far. A warning is issued if none of the legal values for a property are matched by your pattern. It's likely that a future release will raise a warning if your pattern ends up causing every possible code point to match.</source>
          <target state="translated">为了安全起见，我们应该锚定上面的示例，以防止与 &lt;code&gt;Hebrew_Braille&lt;/code&gt; 之类的内容匹配，但是到目前为止，还没有类似的脚本名称。如果您的模式不匹配任何属性的合法值，则会发出警告。如果您的模式最终导致每个可能的代码点都匹配，则将来的发行版可能会发出警告。</target>
        </trans-unit>
        <trans-unit id="b076f38e81902902b25d1f17b1608ab8be160484" translate="yes" xml:space="preserve">
          <source>To begin your reading, start with:</source>
          <target state="translated">要开始阅读,先从。</target>
        </trans-unit>
        <trans-unit id="a61e1eb5d11062cb9036bb12d10d76fe348be7c1" translate="yes" xml:space="preserve">
          <source>To browse existing Perl bugs and patches, you can use the web interface at &lt;a href=&quot;http://rt.perl.org/&quot;&gt;http://rt.perl.org/&lt;/a&gt;.</source>
          <target state="translated">要浏览现有的Perl错误和补丁，可以使用Web界面，网址为&lt;a href=&quot;http://rt.perl.org/&quot;&gt;http://rt.perl.org/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b19b13b7eebea3b4a95edad33fffc49ec225b2e5" translate="yes" xml:space="preserve">
          <source>To build a non-XS module, you can use the standard module-building instructions distributed with perl modules.</source>
          <target state="translated">要建立一个非XS模块,你可以使用随perl模块分发的标准模块建立指令。</target>
        </trans-unit>
        <trans-unit id="6c2705e01ac97996d808db8effeb88881961867f" translate="yes" xml:space="preserve">
          <source>To build an XS module, you must use the standard module-building instructions distributed with perl modules *PLUS* three extra instructions specific to the DJGPP &quot;static link&quot; build environment.</source>
          <target state="translated">要构建XS模块,必须使用随perl模块分发的标准模块构建指令*PLUS*三个针对DJGPP &quot;静态链接 &quot;构建环境的额外指令。</target>
        </trans-unit>
        <trans-unit id="d5c2765f0199128d509d1897ee86d4417f4dd8a3" translate="yes" xml:space="preserve">
          <source>To build extensions other than standard extensions, NetWare Perl has to be installed on Windows along with Windows Perl. The Perl for Windows can be either downloaded from the CPAN site and built using the sources, or the binaries can be directly downloaded from the ActiveState site. Installation can be done by invoking</source>
          <target state="translated">要建立标准扩展以外的扩展,必须在Windows上安装NetWare Perl和Windows Perl。Windows 的 Perl 可以从 CPAN 站点下载并使用源代码构建,或者直接从 ActiveState 站点下载二进制文件。安装可以通过调用</target>
        </trans-unit>
        <trans-unit id="787c86241856156cd077a05b7bdc7004761044c1" translate="yes" xml:space="preserve">
          <source>To build perl from its source code on the Stratus V Series platform you must have OpenVOS Release 17.1.0 or later, GNU Tools Release 3.5 or later, and the C/POSIX Runtime Libraries.</source>
          <target state="translated">要在Stratus V系列平台上从源代码中构建perl,你必须有OpenVOS 17.1.0或更高版本,GNU Tools 3.5或更高版本,以及C/POSIX Runtime Libraries。</target>
        </trans-unit>
        <trans-unit id="b8374368118e0a9e9250156402520f453adca786" translate="yes" xml:space="preserve">
          <source>To build perl under AmigaOS from the patched sources you will need to have a recent version of the SDK. Version 53.29 is recommended, earlier versions will probably work too.</source>
          <target state="translated">要在AmigaOS下使用打过补丁的源码编译perl,你需要有一个最新版本的SDK。建议使用53.29版本,更早的版本可能也能使用。</target>
        </trans-unit>
        <trans-unit id="29d9cfbafe7af9c12fb5ae5d7307a03b50f8bc3e" translate="yes" xml:space="preserve">
          <source>To build perl with AddressSanitizer, your Configure invocation should look like:</source>
          <target state="translated">要使用AddressSanitizer构建perl,你的Configure调用应该是这样的。</target>
        </trans-unit>
        <trans-unit id="b12975798f70dc1cb8c9fb59b7af2b4445d07d6d" translate="yes" xml:space="preserve">
          <source>To calculate the digest of an n-bit message where</source>
          <target state="translated">要计算一个n位信息的摘要,其中</target>
        </trans-unit>
        <trans-unit id="0df1e5f84b4694c53717b89d6fb8b89ff7d44718" translate="yes" xml:space="preserve">
          <source>To calculate the distance between London (51.3N 0.5W) and Tokyo (35.7N 139.8E) in kilometers:</source>
          <target state="translated">计算伦敦(51.3N 0.5W)和东京(35.7N 139.8E)之间的距离,单位为公里。</target>
        </trans-unit>
        <trans-unit id="4cea3ec7425389162d89934663cf2df355daf6af" translate="yes" xml:space="preserve">
          <source>To call a function on each element in an array, and collect the results, use:</source>
          <target state="translated">要对数组中的每个元素调用一个函数,并收集结果,使用。</target>
        </trans-unit>
        <trans-unit id="dbe4aebe356ab30727111304ed5066c2800f1b44" translate="yes" xml:space="preserve">
          <source>To call a function on each element of an array, but ignore the results:</source>
          <target state="translated">对数组中的每个元素调用一个函数,但忽略结果。</target>
        </trans-unit>
        <trans-unit id="710b700709beaae3a0d7fb3e17148d99cdb1ee11" translate="yes" xml:space="preserve">
          <source>To call a function on each integer in a (small) range, you &lt;b&gt;can&lt;/b&gt; use:</source>
          <target state="translated">要在（较小）范围内的每个整数上调用函数，&lt;b&gt;可以&lt;/b&gt;使用：</target>
        </trans-unit>
        <trans-unit id="b0c03ca703f3d70571e4ed1a5f4b95eb2f4f7eac" translate="yes" xml:space="preserve">
          <source>To call individual Perl subroutines, you can use any of the &lt;b&gt;call_*&lt;/b&gt; functions documented in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;. In this example we'll use &lt;code&gt;call_argv&lt;/code&gt; .</source>
          <target state="translated">要调用单独的Perl子程序，你可以使用任何的&lt;b&gt;call_ *&lt;/b&gt;中介绍的功能&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。在此示例中，我们将使用 &lt;code&gt;call_argv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b0356115da72e97143cd3fb75c87b7ab25d47c5" translate="yes" xml:space="preserve">
          <source>To call individual Perl subroutines, you can use any of the &lt;b&gt;call_*&lt;/b&gt; functions documented in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;. In this example we'll use &lt;code&gt;call_argv&lt;/code&gt;.</source>
          <target state="translated">要调用单独的Perl子程序，你可以使用任何的&lt;b&gt;call_ *&lt;/b&gt;中介绍的功能&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。在此示例中，我们将使用 &lt;code&gt;call_argv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f49f3d19c459317781abadc37d2ae6f14022eac3" translate="yes" xml:space="preserve">
          <source>To call subroutines:</source>
          <target state="translated">要调用子程序。</target>
        </trans-unit>
        <trans-unit id="5abcacc2499f97bcbde0588fdd4401b44cc6c01a" translate="yes" xml:space="preserve">
          <source>To capture a command's STDERR but discard its STDOUT (ordering is important here):</source>
          <target state="translated">捕获一个命令的STDERR,但丢弃它的STDOUT(这里的顺序很重要)。</target>
        </trans-unit>
        <trans-unit id="891b8754dd37bb2c3dc54aab3a1185e0fd372170" translate="yes" xml:space="preserve">
          <source>To capture a command's STDERR but discard its STDOUT:</source>
          <target state="translated">捕获命令的STDERR,但丢弃其STDOUT。</target>
        </trans-unit>
        <trans-unit id="7ddfc050c95c3b76b8561d8851899b023835e01c" translate="yes" xml:space="preserve">
          <source>To capture a command's STDOUT but discard its STDERR:</source>
          <target state="translated">捕获命令的STDOUT,但丢弃其STDERR。</target>
        </trans-unit>
        <trans-unit id="459bfbbfb62f196ec5bdfb8f616f754fb8b81d04" translate="yes" xml:space="preserve">
          <source>To capture a program's STDERR, and let its STDOUT go to our own STDERR:</source>
          <target state="translated">捕捉一个程序的STDERR,让它的STDOUT进入我们自己的STDERR。</target>
        </trans-unit>
        <trans-unit id="5bd52eb04283645c047b422b0b8e0a7d88ad61c6" translate="yes" xml:space="preserve">
          <source>To capture a program's STDERR, but discard its STDOUT:</source>
          <target state="translated">捕获程序的STDERR,但丢弃其STDOUT。</target>
        </trans-unit>
        <trans-unit id="8a448a300769cb48dfafecf642b7105f4ae83d7b" translate="yes" xml:space="preserve">
          <source>To capture a program's STDOUT, but discard its STDERR:</source>
          <target state="translated">捕获程序的STDOUT,但丢弃其STDERR。</target>
        </trans-unit>
        <trans-unit id="48535a0ea84ddf99c0ff0191b2ebc7ac2d2965e6" translate="yes" xml:space="preserve">
          <source>To catch this kind of problem, we can force each variable to be declared before use by pulling in the strict module, by putting 'use strict;' after the first line of the script.</source>
          <target state="translated">为了抓住这种问题,我们可以通过拉入strict模块,在脚本的第一行后面加上'use strict;',强制每个变量在使用前声明。</target>
        </trans-unit>
        <trans-unit id="ee4539dea7c8d87e83fb7b99fbcea7146f28bf41" translate="yes" xml:space="preserve">
          <source>To center a whole line of text, do something like this:</source>
          <target state="translated">要将整行文字居中,可以这样做。</target>
        </trans-unit>
        <trans-unit id="cb50b80c4012bf8864c9070a8feaf64a654c0893" translate="yes" xml:space="preserve">
          <source>To change existing lines, insert the code to modify the lines inside the &lt;code&gt;while&lt;/code&gt; loop. In this case, the code finds all lowercased versions of &quot;perl&quot; and uppercases them. The happens for every line, so be sure that you're supposed to do that on every line!</source>
          <target state="translated">要更改现有行，请插入代码以修改 &lt;code&gt;while&lt;/code&gt; 循环内的行。在这种情况下，代码将查找&amp;ldquo; perl&amp;rdquo;的所有小写版本并将其大写。每行都会发生这种情况，因此请确保您应该在每行上都执行此操作！</target>
        </trans-unit>
        <trans-unit id="3014ba02f0b23a5077d149c5a55186e1b0210812" translate="yes" xml:space="preserve">
          <source>To change one of these elements, just assign to it like this:</source>
          <target state="translated">要改变其中一个元素,只需像这样分配给它。</target>
        </trans-unit>
        <trans-unit id="0bc26e290e338fd9cb7ec178f79c71f3fe32327a" translate="yes" xml:space="preserve">
          <source>To change only a particular line, the input line number, &lt;code&gt;$.&lt;/code&gt; , is useful. First read and print the lines up to the one you want to change. Next, read the single line you want to change, change it, and print it. After that, read the rest of the lines and print those:</source>
          <target state="translated">要仅更改特定行，请输入行号 &lt;code&gt;$.&lt;/code&gt; ，很有用。首先阅读并打印您要更改的行。接下来，阅读要更改的一行，进行更改并打印。之后，阅读其余各行并打印：</target>
        </trans-unit>
        <trans-unit id="8261e5499a7ae4c48592a1983635f3df7192d7cc" translate="yes" xml:space="preserve">
          <source>To change only a particular line, the input line number, &lt;code&gt;$.&lt;/code&gt;, is useful. First read and print the lines up to the one you want to change. Next, read the single line you want to change, change it, and print it. After that, read the rest of the lines and print those:</source>
          <target state="translated">要仅更改特定行，请输入行号 &lt;code&gt;$.&lt;/code&gt; ，很有用。首先阅读并打印直到您要更改的行。接下来，阅读要更改的一行，进行更改并打印。之后，阅读其余各行并打印：</target>
        </trans-unit>
        <trans-unit id="f7b3b581f75dc5b407edfb21187704d85ccc3337" translate="yes" xml:space="preserve">
          <source>To change only the fifth line, you can add a test checking &lt;code&gt;$.&lt;/code&gt; , the input line number, then only perform the operation when the test passes:</source>
          <target state="translated">要仅更改第五行，可以添加一个检查 &lt;code&gt;$.&lt;/code&gt; 的测试。，输入行号，然后仅在测试通过时执行操作：</target>
        </trans-unit>
        <trans-unit id="833e5f56fff3dfac3d9eb1d5cb139919fbf68571" translate="yes" xml:space="preserve">
          <source>To change only the fifth line, you can add a test checking &lt;code&gt;$.&lt;/code&gt;, the input line number, then only perform the operation when the test passes:</source>
          <target state="translated">要仅更改第五行，可以添加一个检查 &lt;code&gt;$.&lt;/code&gt; 的测试。，输入行号，然后仅在测试通过时执行操作：</target>
        </trans-unit>
        <trans-unit id="2ac56000e9557456388facc9434e99b2f25c68f2" translate="yes" xml:space="preserve">
          <source>To change part of a string, you can use the optional fourth argument which is the replacement string.</source>
          <target state="translated">要改变字符串的一部分,可以使用可选的第四个参数,即替换字符串。</target>
        </trans-unit>
        <trans-unit id="159bf1e2399227a81a68240fcbc4a8d0c4d4386e" translate="yes" xml:space="preserve">
          <source>To change the configuration you will need to use either the &lt;code&gt;-c&lt;/code&gt; or the &lt;code&gt;-d&lt;/code&gt; options.</source>
          <target state="translated">要更改配置，您将需要使用 &lt;code&gt;-c&lt;/code&gt; 或 &lt;code&gt;-d&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="82b774af2b2d757667a119fdffcb3a39066bffc5" translate="yes" xml:space="preserve">
          <source>To change the value of an</source>
          <target state="translated">要改变一个</target>
        </trans-unit>
        <trans-unit id="c3243d9e5f9c11b853cdbfbdad7815af406db7ec" translate="yes" xml:space="preserve">
          <source>To check if you've got an object derived from a specific class you have to write:</source>
          <target state="translated">要检查你是否有一个从特定类派生出来的对象,你必须写。</target>
        </trans-unit>
        <trans-unit id="b5f0280c18244571ee821966259aa01905eea140" translate="yes" xml:space="preserve">
          <source>To check that a PerlIO* is valid use PerlIOValid(PerlIO *f). (All this does is really just to check that the pointer is non-NULL and that the pointer behind that is non-NULL.)</source>
          <target state="translated">要检查一个PerlIO*是否有效,使用PerlIOValid(PerlIO *f)。(所有这一切其实只是为了检查指针是否为非NULL,以及后面的指针是否为非NULL。)</target>
        </trans-unit>
        <trans-unit id="6efc33cfc9910a60ea4ef9bf5110b124df74dec6" translate="yes" xml:space="preserve">
          <source>To circumvent this, Perl uses two hacks. They help against</source>
          <target state="translated">为了规避这个问题,Perl使用了两个黑客。它们有助于防止</target>
        </trans-unit>
        <trans-unit id="fc16356cccf83cfc4cbdd42d7b6c6a4bf9f4c7cd" translate="yes" xml:space="preserve">
          <source>To clean up after compilation you can use either of</source>
          <target state="translated">要在编译后进行清理,你可以使用以下任一方法</target>
        </trans-unit>
        <trans-unit id="9b687155f88b0a0c7f0b7a50cd6c0fc2a98e0825" translate="yes" xml:space="preserve">
          <source>To clear the screen, you just have to print the special sequence that tells the terminal to clear the screen. Once you have that sequence, output it when you want to clear the screen.</source>
          <target state="translated">要清除屏幕,你只需要打印出告诉终端清除屏幕的特殊序列。一旦你有了这个序列,当你要清除屏幕时,就输出它。</target>
        </trans-unit>
        <trans-unit id="aeb7d489151127988ed87013a2d0db094b3d4f08" translate="yes" xml:space="preserve">
          <source>To commit to a maintenance version of perl, you need to create a local tracking branch:</source>
          <target state="translated">要提交到 perl 的维护版本,你需要创建一个本地跟踪分支。</target>
        </trans-unit>
        <trans-unit id="c45964cfffa3b2dbc072504434f04f57c4932a60" translate="yes" xml:space="preserve">
          <source>To compare two strings case-insensitively, use &lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;&lt;code&gt;foldEQ_utf8()&lt;/code&gt;&lt;/a&gt; (the strings don't have to have the same UTF-8ness).</source>
          <target state="translated">&lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt; &lt;code&gt;foldEQ_utf8()&lt;/code&gt; &lt;/a&gt;区分大小写地比较两个字符串，请使用foldEQ_utf8（）（这些字符串不必具有相同的UTF-8ness）。</target>
        </trans-unit>
        <trans-unit id="5339fbdb482ebe20149617c58a946c9025ec4bd2" translate="yes" xml:space="preserve">
          <source>To compare two strings case-insensitively, use &lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;foldEQ_utf8() &lt;/a&gt; (the strings don't have to have the same UTF-8ness).</source>
          <target state="translated">&lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;要不&lt;/a&gt;区分大小写地比较两个字符串，请使用foldEQ_utf8（）（这些字符串不必具有相同的UTF-8ness）。</target>
        </trans-unit>
        <trans-unit id="9ef4437f2da5ad50f0107615b5cd7fb7937669db" translate="yes" xml:space="preserve">
          <source>To compile Perl with threads, add -Dusethreads to the arguments of Configure. Verify that the -D_POSIX_C_SOURCE=199506L compiler flag is automatically added to the list of flags. Also make sure that -lpthread is listed before -lc in the list of libraries to link Perl with. The hints provided for HP-UX during Configure will try very hard to get this right for you.</source>
          <target state="translated">要用线程编译Perl,请在Configure的参数中添加-Dusethreads。确认 -D_POSIX_C_SOURCE=199506L 编译器标志会自动添加到标志列表中。同时确保在链接Perl的库列表中,-lpthread被列在-lc之前。在配置过程中为HP-UX提供的提示会很努力的为你做好这个工作。</target>
        </trans-unit>
        <trans-unit id="dca1f2d388460992485bc83958326b4fabbe3a89" translate="yes" xml:space="preserve">
          <source>To compile a 64-bit application on an UltraSparc with a recent Sun Compiler, you need to use the flag &quot;-xarch=v9&quot;. getconf(1) will tell you this, e.g.</source>
          <target state="translated">要在UltraSparc上用最新的Sun编译器编译一个64位的应用程序,需要使用&quot;-xarch=v9 &quot;这个标志,getconf(1)会告诉你这一点,例如</target>
        </trans-unit>
        <trans-unit id="aafe5bf2c4343a0e3d4371c91d0581b8bfb71744" translate="yes" xml:space="preserve">
          <source>To compile the demonstration application PerlApp you need first to install the Perl headers under the SDK.</source>
          <target state="translated">要编译示范应用程序PerlApp,首先需要在SDK下安装Perl头文件。</target>
        </trans-unit>
        <trans-unit id="87a608f7610a06343062c0a4f15a78987866b679" translate="yes" xml:space="preserve">
          <source>To compress all files in the directory &quot;/my/home&quot; that match &quot;*.txt&quot; and store the compressed data in the same directory</source>
          <target state="translated">压缩&quot;/my/home &quot;目录下所有符合 &quot;*.txt &quot;的文件,并将压缩后的数据存储在同一目录下。</target>
        </trans-unit>
        <trans-unit id="e79c6c77e53867aede1a00267dc0d36f666b7950" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number between 8 and 15.</source>
          <target state="translated">要压缩RFC 1950数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为8到15之间的正数。</target>
        </trans-unit>
        <trans-unit id="7421981a167883ab2bc4949efb716b7db4314b6b" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">要压缩RFC 1951数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf7349fcec84071676b172827e1a49b634a1fdb7" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt;.</source>
          <target state="translated">要压缩RFC 1951数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb0992d170df6f988844c94c5a16d02581fe60f0" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt; .</source>
          <target state="translated">要压缩RFC 1952数据流（即gzip），请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;WANT_GZIP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3745f78ab286dd7d4193d09748c3eef61c61724d" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt;.</source>
          <target state="translated">要压缩RFC 1952数据流（即gzip），请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;WANT_GZIP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c0a5b03c1713572aa7618df4ce2ea31c5f8ea2a" translate="yes" xml:space="preserve">
          <source>To concatenate</source>
          <target state="translated">连接</target>
        </trans-unit>
        <trans-unit id="6e6c0c8d29557c5cf786e08230a13bcf9f5a031b" translate="yes" xml:space="preserve">
          <source>To configure the</source>
          <target state="translated">要配置</target>
        </trans-unit>
        <trans-unit id="27b8a31fcae13694057ef8e5270215d578e3caf3" translate="yes" xml:space="preserve">
          <source>To connect one filehandle to several output filehandles, you can use the &lt;a href=&quot;IO::Tee&quot;&gt;IO::Tee&lt;/a&gt; or &lt;a href=&quot;Tie::FileHandle::Multiplex&quot;&gt;Tie::FileHandle::Multiplex&lt;/a&gt; modules.</source>
          <target state="translated">要将一个文件句柄连接到多个输出文件句柄，可以使用&lt;a href=&quot;IO::Tee&quot;&gt;IO :: Tee&lt;/a&gt;或&lt;a href=&quot;Tie::FileHandle::Multiplex&quot;&gt;Tie :: FileHandle :: Multiplex&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="b8324e82632846a0ff4c29dfcce46aaf6bb8f9fb" translate="yes" xml:space="preserve">
          <source>To connect one filehandle to several output filehandles, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Tee&quot;&gt;IO::Tee&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::FileHandle::Multiplex&quot;&gt;Tie::FileHandle::Multiplex&lt;/a&gt; modules.</source>
          <target state="translated">要将一个文件句柄连接到多个输出文件句柄，可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/IO::Tee&quot;&gt;IO :: Tee&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/Tie::FileHandle::Multiplex&quot;&gt;Tie :: FileHandle :: Multiplex&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="8d6cbc660d600cd1c4583162826d97d790f4bf63" translate="yes" xml:space="preserve">
          <source>To conserve memory you should have your compiler modules loaded into the Link Pack Area (LPA/ELPA) rather than in a link list or step lib.</source>
          <target state="translated">为了节省内存,你应该将你的编译器模块加载到链接包区域(LPA/ELPA),而不是链接列表或步骤库中。</target>
        </trans-unit>
        <trans-unit id="968a823fad5813dfb21cd46750147776a5611926" translate="yes" xml:space="preserve">
          <source>To considerably speed up the initial CPAN shell startup, it is possible to use Storable to create a cache of metadata. If Storable is not available, the normal index mechanism will be used.</source>
          <target state="translated">为了大大加快CPAN shell的初始启动速度,可以使用Storable来创建元数据的缓存。如果Storable不可用,将使用普通的索引机制。</target>
        </trans-unit>
        <trans-unit id="20a4b2b8d77aba12d02e264b26db5b4fc2052c4a" translate="yes" xml:space="preserve">
          <source>To contact the author, send email to: &lt;code&gt;mjd-perl-tiefile+@plover.com&lt;/code&gt;</source>
          <target state="translated">要与作者联系，请发送电子邮件至： &lt;code&gt;mjd-perl-tiefile+@plover.com&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4e7d2faeb717445863f554610fdabbf94c812cb" translate="yes" xml:space="preserve">
          <source>To control what text is used for display, you use &quot;&lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt;&quot;, as in:</source>
          <target state="translated">要控制用于显示的文本，请使用&amp;ldquo; &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; &amp;rdquo;，如下所示：</target>
        </trans-unit>
        <trans-unit id="7f787791e1e7cbfd6f94bf52b9685495ede53680" translate="yes" xml:space="preserve">
          <source>To convert &lt;a href=&quot;config#perlpath&quot;&gt;&lt;code&gt;$Config{perlpath}&lt;/code&gt;&lt;/a&gt; to a file pathname, say:</source>
          <target state="translated">要将&lt;a href=&quot;config#perlpath&quot;&gt; &lt;code&gt;$Config{perlpath}&lt;/code&gt; &lt;/a&gt;转换为文件路径名，请说：</target>
        </trans-unit>
        <trans-unit id="c07c15697f1959a79e3e58a6af11dd7e45671417" translate="yes" xml:space="preserve">
          <source>To convert &lt;a href=&quot;perlvar#%24%5EX&quot;&gt;&lt;code&gt;$^X&lt;/code&gt;&lt;/a&gt; to a file pathname, taking account of the requirements of the various operating system possibilities, say:</source>
          <target state="translated">考虑到各种操作系统可能性的要求，将&lt;a href=&quot;perlvar#%24%5EX&quot;&gt; &lt;code&gt;$^X&lt;/code&gt; &lt;/a&gt;转换为文件路径名，例如：</target>
        </trans-unit>
        <trans-unit id="0f2616580d4b758d8bc7475f582ba3ef32958144" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;$Config{perlpath}&lt;/code&gt; to a file pathname, say:</source>
          <target state="translated">要将 &lt;code&gt;$Config{perlpath}&lt;/code&gt; 转换为文件路径名，请说：</target>
        </trans-unit>
        <trans-unit id="445d48b4e3ded0561c8b941a914e856d01c116d2" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;$^X&lt;/code&gt; to a file pathname, taking account of the requirements of the various operating system possibilities, say:</source>
          <target state="translated">考虑到各种操作系统可能性的要求，将 &lt;code&gt;$^X&lt;/code&gt; 转换为文件路径名，例如：</target>
        </trans-unit>
        <trans-unit id="c00d24e73fce2df83990c0f155f2d36a18a08fc4" translate="yes" xml:space="preserve">
          <source>To convert an octal number, use from_oct();</source>
          <target state="translated">要转换八进制数,使用from_oct()。</target>
        </trans-unit>
        <trans-unit id="7d95d35a7d9c8de57b1e556f0a9920a9c8320986" translate="yes" xml:space="preserve">
          <source>To convert from EBCDIC 037 to ASCII just reverse the order of the tr/// arguments like so:</source>
          <target state="translated">要将EBCDIC 037转换为ASCII码,只需将tr///参数的顺序颠倒过来,就像这样。</target>
        </trans-unit>
        <trans-unit id="e95102da8c741e9ba252adcb490152dec1b8623d" translate="yes" xml:space="preserve">
          <source>To convert from new-style to old-style, follow this recipe:</source>
          <target state="translated">要想将新式转换为旧式,请按照这个配方进行。</target>
        </trans-unit>
        <trans-unit id="b7383321848919d955ca5bfae7880346b845b2ba" translate="yes" xml:space="preserve">
          <source>To convert strings that might start with any of &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0x&lt;/code&gt;, or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;#oct-EXPR&quot;&gt;&lt;code&gt;oct&lt;/code&gt;&lt;/a&gt;. To present something as hex, look into &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要转换可能会与任何开头的字符串 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;0x&lt;/code&gt; ，或 &lt;code&gt;0b&lt;/code&gt; ，见&lt;a href=&quot;#oct-EXPR&quot;&gt; &lt;code&gt;oct&lt;/code&gt; &lt;/a&gt;。要以十六进制形式显示内容，请查看&lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;printf&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;sprintf&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9fa39707ee5532360879dd87b7e44a99cff8fee0" translate="yes" xml:space="preserve">
          <source>To copy all your .c file to a backup directory</source>
          <target state="translated">要将所有的.c文件复制到备份目录下</target>
        </trans-unit>
        <trans-unit id="5ab2f997dcaa14c701c81b93174b6bfe66ee6931" translate="yes" xml:space="preserve">
          <source>To copy the array, use</source>
          <target state="translated">要复制数组,使用</target>
        </trans-unit>
        <trans-unit id="49c50a429b3a772bc583381f94d7fd07c2224e83" translate="yes" xml:space="preserve">
          <source>To correctly maintain reference counts, it is essential to keep track of what references the XS code is manipulating. The programmer should always know where a reference has come from and who owns it, and be aware of any creation or destruction of references, and any transfers of ownership. Because ownership isn't represented explicitly in the xV data structures, only the reference count need be actually maintained by the code, and that means that this understanding of ownership is not actually evident in the code. For example, transferring ownership of a reference from one owner to another doesn't change the reference count at all, so may be achieved with no actual code. (The transferring code doesn't touch the referenced object, but does need to ensure that the former owner knows that it no longer owns the reference, and that the new owner knows that it now does.)</source>
          <target state="translated">为了正确维护引用计数,必须跟踪XS代码正在操作哪些引用。程序员应该始终知道一个引用从哪里来,谁拥有它,并知道任何引用的创建或销毁,以及任何所有权的转移。由于所有权在xV数据结构中并没有明确表示,所以代码实际只需要维护引用计数,这意味着这种对所有权的理解实际上在代码中并不明显。例如,将一个引用的所有权从一个所有者转移到另一个所有者,根本不会改变引用计数,所以可能在没有实际代码的情况下实现。(转移的代码不会触及被引用的对象,但需要确保前所有者知道它不再拥有该引用,而新所有者知道它现在拥有该引用。)</target>
        </trans-unit>
        <trans-unit id="86582412ddc1c4958ec10cc1409f68b2a052f72a" translate="yes" xml:space="preserve">
          <source>To cover such cases, you can redispatch methods via:</source>
          <target state="translated">为了覆盖这种情况,你可以通过重新分配方法。</target>
        </trans-unit>
        <trans-unit id="816db1c262f755f697320a74d5b828dbd17231a2" translate="yes" xml:space="preserve">
          <source>To create Unicode characters in literals, use the &lt;code&gt;\N{...}&lt;/code&gt; notation in double-quoted strings:</source>
          <target state="translated">要在文字中创建Unicode字符，请在双引号字符串中使用 &lt;code&gt;\N{...}&lt;/code&gt; 符号：</target>
        </trans-unit>
        <trans-unit id="c36e175a2f7ac1c4707a3b48724437b649be4b2b" translate="yes" xml:space="preserve">
          <source>To create a POD filter for translating POD documentation into some other format, you create a subclass of &lt;b&gt;Pod::Parser&lt;/b&gt; which typically overrides just the base class implementation for the following methods:</source>
          <target state="translated">要创建用于将POD文档转换为其他格式的POD过滤器，请创建&lt;b&gt;Pod :: Parser&lt;/b&gt;的子类，该子类通常仅覆盖以下方法的基类实现：</target>
        </trans-unit>
        <trans-unit id="3376aadc06d935bc6556cf078e6fff6d6ceed1e6" translate="yes" xml:space="preserve">
          <source>To create a Perl module that implements a PerlIO layer in Perl (as opposed to in C using XS as the interface to Perl), you need to supply some of the following subroutines. It is recommended to create these Perl modules in the PerlIO::via:: namespace, so that they can easily be located on CPAN and use the default namespace feature of the PerlIO::via module itself.</source>
          <target state="translated">要在Perl中创建一个实现PerlIO层的Perl模块(而不是在C语言中使用XS作为Perl的接口),你需要提供以下一些子程序。建议在PerlIO::via::命名空间中创建这些Perl模块,这样就可以很容易地在CPAN上找到它们,并使用PerlIO::via模块本身的默认命名空间功能。</target>
        </trans-unit>
        <trans-unit id="cea82dcc2341d67ceae28cb7f8dd640de30d8fab" translate="yes" xml:space="preserve">
          <source>To create a child &lt;b&gt;process&lt;/b&gt; identical to the parent process at its moment of conception, at least until it gets ideas of its own. A thread with protected memory.</source>
          <target state="translated">要在创建子&lt;b&gt;进程时&lt;/b&gt;创建与父&lt;b&gt;进程&lt;/b&gt;相同的子进程，至少要等到得到自己的想法为止。具有受保护的内存的线程。</target>
        </trans-unit>
        <trans-unit id="973c5f5d0d37e9d577d7def77212ab83a77d00d7" translate="yes" xml:space="preserve">
          <source>To create a complex number, use either:</source>
          <target state="translated">要创建一个复杂的数字,请使用以下两种方法。</target>
        </trans-unit>
        <trans-unit id="2ba00f13d11568a68eea0b9363c1c701b94f3530" translate="yes" xml:space="preserve">
          <source>To create a handler, define it as a subroutine with the same name as the desired attribute, and declare the subroutine itself with the attribute &lt;code&gt;:ATTR&lt;/code&gt; . For example:</source>
          <target state="translated">要创建处理程序，请将其定义为与所需属性同名的子例程，然后使用属性 &lt;code&gt;:ATTR&lt;/code&gt; 声明该子例程本身。例如：</target>
        </trans-unit>
        <trans-unit id="7be1f84ddb058aa59042284e3c774355eb9bd0e7" translate="yes" xml:space="preserve">
          <source>To create a handler, define it as a subroutine with the same name as the desired attribute, and declare the subroutine itself with the attribute &lt;code&gt;:ATTR&lt;/code&gt;. For example:</source>
          <target state="translated">要创建处理程序，请将其定义为与所需属性同名的子例程，然后使用 &lt;code&gt;:ATTR&lt;/code&gt; 属性声明该子例程本身。例如：</target>
        </trans-unit>
        <trans-unit id="bf8c75fd66b25e79071f909e18cf1703b677444d" translate="yes" xml:space="preserve">
          <source>To create a mortal reference, use the functions:</source>
          <target state="translated">要创建一个凡人参照物,使用函数。</target>
        </trans-unit>
        <trans-unit id="0f301595bc4c387e143da9231296df032806e83c" translate="yes" xml:space="preserve">
          <source>To create a mortal variable, use the functions:</source>
          <target state="translated">要创建一个凡人变量,请使用函数。</target>
        </trans-unit>
        <trans-unit id="168d2bd52151b2f88de55aa6a46a9bc34a213502" translate="yes" xml:space="preserve">
          <source>To create a named pipe, use the &lt;code&gt;POSIX::mkfifo()&lt;/code&gt; function.</source>
          <target state="translated">要创建命名管道，请使用 &lt;code&gt;POSIX::mkfifo()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="fb4519b518bb57bb6e760a3915cac3cb53c117b7" translate="yes" xml:space="preserve">
          <source>To create a new Perl variable with an undef value which can be accessed from your Perl script, use the following routines, depending on the variable type.</source>
          <target state="translated">要创建一个新的带有 undef 值的 Perl 变量,并可以从你的 Perl 脚本中访问,根据变量的类型,使用以下例程。</target>
        </trans-unit>
        <trans-unit id="c5e6c240b7113609dabfe56dd41076e1c64fdaed" translate="yes" xml:space="preserve">
          <source>To create a new compartment, use</source>
          <target state="translated">要创建一个新的隔间,请使用</target>
        </trans-unit>
        <trans-unit id="5e69f259d43b2f65fc36274b2ebe4426a448a0c1" translate="yes" xml:space="preserve">
          <source>To create a patch file for all your local changes:</source>
          <target state="translated">要为您的所有本地更改创建一个补丁文件。</target>
        </trans-unit>
        <trans-unit id="a2f8f5de503a593a35d422a3d1a1da701a2bb15e" translate="yes" xml:space="preserve">
          <source>To create a reference, use either of the following functions:</source>
          <target state="translated">要创建一个引用,请使用以下任一函数。</target>
        </trans-unit>
        <trans-unit id="3b14234e60346a5da75e272e4ecdc1bcef627a2f" translate="yes" xml:space="preserve">
          <source>To create a reference, we use the &lt;code&gt;newRV&lt;/code&gt; function. Note that you can cast an AV* or an HV* to type SV* in this case (and many others). This allows you to take references to arrays, hashes and scalars with the same function. Conversely, the &lt;code&gt;SvRV&lt;/code&gt; function always returns an SV*, which may need to be cast to the appropriate type if it is something other than a scalar (check with &lt;code&gt;SvTYPE&lt;/code&gt; ).</source>
          <target state="translated">要创建参考，我们使用 &lt;code&gt;newRV&lt;/code&gt; 函数。请注意，在这种情况下（以及许多其他情况），可以将AV *或HV *转换为SV *。这使您可以引用具有相同功能的数组，哈希和标量。相反， &lt;code&gt;SvRV&lt;/code&gt; 函数始终返回SV *，如果它不是标量，则可能需要转换为适当的类型（请使用 &lt;code&gt;SvTYPE&lt;/code&gt; 进行检查）。</target>
        </trans-unit>
        <trans-unit id="76c3711b1f4442657fc38b46f51a53e19c63e499" translate="yes" xml:space="preserve">
          <source>To create a reference, we use the &lt;code&gt;newRV_inc&lt;/code&gt; function. Note that you can cast an AV* or an HV* to type SV* in this case (and many others). This allows you to take references to arrays, hashes and scalars with the same function. Conversely, the &lt;code&gt;SvRV&lt;/code&gt; function always returns an SV*, which may need to be cast to the appropriate type if it is something other than a scalar (check with &lt;code&gt;SvTYPE&lt;/code&gt;).</source>
          <target state="translated">要创建参考，我们使用 &lt;code&gt;newRV_inc&lt;/code&gt; 函数。请注意，在这种情况下（以及许多其他情况），可以将AV *或HV *转换为SV *。这使您可以引用具有相同功能的数组，哈希和标量。相反， &lt;code&gt;SvRV&lt;/code&gt; 函数始终返回SV *，如果它不是标量，则可能需要转换为适当的类型（请使用 &lt;code&gt;SvTYPE&lt;/code&gt; 进行检查）。</target>
        </trans-unit>
        <trans-unit id="f750d278ece92b690ce083757a8b99d17e4a1cc6" translate="yes" xml:space="preserve">
          <source>To create a shared library, the following steps must be performed:</source>
          <target state="translated">要创建一个共享库,必须执行以下步骤。</target>
        </trans-unit>
        <trans-unit id="3c6eb343e88be36bc92d3d97f3219df475d3ded3" translate="yes" xml:space="preserve">
          <source>To create a zip file, &lt;code&gt;output.zip&lt;/code&gt; , that contains the compressed contents of the files &lt;code&gt;alpha.txt&lt;/code&gt; and &lt;code&gt;beta.txt&lt;/code&gt;</source>
          <target state="translated">要创建一个zip文件 &lt;code&gt;output.zip&lt;/code&gt; ，其中包含文件 &lt;code&gt;alpha.txt&lt;/code&gt; 和 &lt;code&gt;beta.txt&lt;/code&gt; 的压缩内容</target>
        </trans-unit>
        <trans-unit id="4b6ff2c8131533c1aec284cd279aab620b4a7896" translate="yes" xml:space="preserve">
          <source>To create a zip file, &lt;code&gt;output.zip&lt;/code&gt;, that contains the compressed contents of the files &lt;code&gt;alpha.txt&lt;/code&gt; and &lt;code&gt;beta.txt&lt;/code&gt;</source>
          <target state="translated">要创建一个zip文件 &lt;code&gt;output.zip&lt;/code&gt; ，其中包含文件 &lt;code&gt;alpha.txt&lt;/code&gt; 和 &lt;code&gt;beta.txt&lt;/code&gt; 的压缩内容</target>
        </trans-unit>
        <trans-unit id="a8a9c4100fca7c9df2f642138fcef0fc96929592" translate="yes" xml:space="preserve">
          <source>To create an HV, you use the following routine:</source>
          <target state="translated">要创建一个HV,您可以使用以下例程。</target>
        </trans-unit>
        <trans-unit id="0094ef6c2580e3be5fb982924088c9990a9a669b" translate="yes" xml:space="preserve">
          <source>To create an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number.</source>
          <target state="translated">要创建RFC 1950数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为正数。</target>
        </trans-unit>
        <trans-unit id="c43fa53c9a4af41c4362a70dd0d3da19011de429" translate="yes" xml:space="preserve">
          <source>To create an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">要创建RFC 1951数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04500f8f7e1689707f89183f5977f70d07b39e1b" translate="yes" xml:space="preserve">
          <source>To create an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt;.</source>
          <target state="translated">要创建RFC 1951数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbb0b362cb67cdcf254362d24dcd3489205dd8b1" translate="yes" xml:space="preserve">
          <source>To create your own result types you have two options:</source>
          <target state="translated">要创建自己的结果类型,你有两个选择。</target>
        </trans-unit>
        <trans-unit id="948e86a50124d6c16a2bb795d3ad5dd4ba16fd66" translate="yes" xml:space="preserve">
          <source>To deallocate the memory of a &lt;b&gt;referent&lt;/b&gt; (first triggering its &lt;code&gt;DESTROY&lt;/code&gt; method, if it has one).</source>
          <target state="translated">取消分配&lt;b&gt;参照对象&lt;/b&gt;的内存（如果有&lt;b&gt;参照对象&lt;/b&gt;，则首先触发其 &lt;code&gt;DESTROY&lt;/code&gt; 方法）。</target>
        </trans-unit>
        <trans-unit id="684b7eba474ceeeee203e03efc4972ceab5f4011" translate="yes" xml:space="preserve">
          <source>To declare a file-private variable, you still use a lexical variable. A file is also a scope, so a lexical variable defined in the file cannot be seen from any other file.</source>
          <target state="translated">要声明一个文件私有变量,还是要使用一个词法变量。文件也是一个作用域,所以在文件中定义的词汇变量不能从其他文件中看到。</target>
        </trans-unit>
        <trans-unit id="26f359ab42151643a554fcca60e916cbc3b8c6c1" translate="yes" xml:space="preserve">
          <source>To declare multiple parents, you simply need to pass multiple class names to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; parent&lt;/code&gt; :</source>
          <target state="translated">要声明多个父对象，您只需要传递多个类名即可 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; parent&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4bb1aac304b6e2bad9b2c8e30ae0f6a69783e20b" translate="yes" xml:space="preserve">
          <source>To declare multiple parents, you simply need to pass multiple class names to &lt;code&gt;use parent&lt;/code&gt;:</source>
          <target state="translated">要声明多个父对象，您只需要传递多个类名即可 &lt;code&gt;use parent&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="195f600c4f130988d6cb960024f570abb452421b" translate="yes" xml:space="preserve">
          <source>To declare subroutines:</source>
          <target state="translated">要声明子程序。</target>
        </trans-unit>
        <trans-unit id="d689355c5c4c25b69703a4f888325a4f315e40d5" translate="yes" xml:space="preserve">
          <source>To decode the string, use the &lt;code&gt;uri_unescape&lt;/code&gt; function:</source>
          <target state="translated">要解码字符串，请使用 &lt;code&gt;uri_unescape&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="c00b1b3082eeba042c1321adab39b3572b77ab5f" translate="yes" xml:space="preserve">
          <source>To define a new encoding, use:</source>
          <target state="translated">要定义一个新的编码,使用。</target>
        </trans-unit>
        <trans-unit id="90539d229e0f3e1882d607e70d036357967dd42b" translate="yes" xml:space="preserve">
          <source>To define an anonymous subroutine at runtime:</source>
          <target state="translated">在运行时定义一个匿名子程序。</target>
        </trans-unit>
        <trans-unit id="c9cdf944c5644c128ca4890eae1d815775404ea8" translate="yes" xml:space="preserve">
          <source>To define your own variables, simply add them to the hash, or change existing values if you need to. The level and format are passed in as references to scalars, but it is unlikely that they will need to be changed or even used.</source>
          <target state="translated">要定义你自己的变量,只需将它们添加到哈希中,或者在需要时改变现有的值。级别和格式是作为对标量的引用传递进来的,但不太可能需要改变甚至使用它们。</target>
        </trans-unit>
        <trans-unit id="663c37fcccd4eb9d16f3753290874adfe0a38adc" translate="yes" xml:space="preserve">
          <source>To delete a filter pass &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to it.</source>
          <target state="translated">要删除过滤器，请将 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 传递给它。</target>
        </trans-unit>
        <trans-unit id="13cdb92e706e9bc2ee9e805b13be6097ddaf3e74" translate="yes" xml:space="preserve">
          <source>To delete a filter pass &lt;code&gt;undef&lt;/code&gt; to it.</source>
          <target state="translated">要删除过滤器，请将 &lt;code&gt;undef&lt;/code&gt; 传递给它。</target>
        </trans-unit>
        <trans-unit id="c6700a8c11e3d4c6c50392505cb5fdaeda8fab3d" translate="yes" xml:space="preserve">
          <source>To delete a partition, zero out all fields except for &lt;code&gt;$bToRewrite&lt;/code&gt; which should be set to &lt;code&gt;1&lt;/code&gt;. To add a partition, increment &lt;code&gt;$cPartitions&lt;/code&gt; and add the information for the new partition into the arrays, making sure that you insert &lt;code&gt;1&lt;/code&gt; into @bToRewrite.</source>
          <target state="translated">要删除分区， &lt;code&gt;$bToRewrite&lt;/code&gt; 以外的所有字段清零（应将其设置为 &lt;code&gt;1&lt;/code&gt; )。要添加分区，请增加 &lt;code&gt;$cPartitions&lt;/code&gt; 并将新分区的信息添加到数组中，并确保在@bToRewrite中插入 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7282a69c7ceaa80a01f9176cf957edc11cea4de" translate="yes" xml:space="preserve">
          <source>To delete lines, only print the ones that you want.</source>
          <target state="translated">要删除行,只打印你想要的行。</target>
        </trans-unit>
        <trans-unit id="c1469f4d29b40fb0b7ab86c2c4e92578f7c6eb9f" translate="yes" xml:space="preserve">
          <source>To determine at runtime if this capability has been compiled in your perl, you can check the value of &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt; .</source>
          <target state="translated">要在运行时确定此功能是否已在perl中进行编译，可以检查 &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e519c90ecace9cdd9ef4f4b53067e00b66728320" translate="yes" xml:space="preserve">
          <source>To determine at runtime if this capability has been compiled in your perl, you can check the value of &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt;.</source>
          <target state="translated">要在运行时确定此功能是否已在perl中进行编译，可以检查 &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="9ac9c1626cb28585a5803d5d3d2ce1edde74347f" translate="yes" xml:space="preserve">
          <source>To determine if a module came with your version of Perl, you can install and use the &lt;a href=&quot;Module::CoreList&quot;&gt;Module::CoreList&lt;/a&gt; module. It has the information about the modules (with their versions) included with each release of Perl.</source>
          <target state="translated">要确定Perl版本是否随附模块，可以安装并使用&lt;a href=&quot;Module::CoreList&quot;&gt;Module :: CoreList&lt;/a&gt;模块。它具有有关每个Perl版本中包含的模块（及其版本）的信息。</target>
        </trans-unit>
        <trans-unit id="5ce033ec9e41969bd8c16961760514dcb521d365" translate="yes" xml:space="preserve">
          <source>To determine if a module came with your version of Perl, you can install and use the &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt; module. It has the information about the modules (with their versions) included with each release of Perl.</source>
          <target state="translated">要确定Perl版本是否随附模块，可以安装并使用&lt;a href=&quot;module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt;模块。它具有有关每个Perl版本中包含的模块（及其版本）的信息。</target>
        </trans-unit>
        <trans-unit id="a3640814314afd9f7ac9d11a68cf889d6f47fec5" translate="yes" xml:space="preserve">
          <source>To determine if a string is in Unicode, use:</source>
          <target state="translated">要确定一个字符串是否为Unicode,使用:</target>
        </trans-unit>
        <trans-unit id="bca0ec2b6522f981d9c11831a03f1f68a8800f50" translate="yes" xml:space="preserve">
          <source>To determine if an SV is a reference, you can use the following macro:</source>
          <target state="translated">要确定一个SV是否是一个引用,可以使用以下宏。</target>
        </trans-unit>
        <trans-unit id="c9936c817f7d3f0a431d8c4cc266d4265437482c" translate="yes" xml:space="preserve">
          <source>To determine if you are running under ASCII or EBCDIC, you can use the return value of &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; to test one or more character values. For example:</source>
          <target state="translated">要确定您是在ASCII还是EBCDIC下运行，可以使用 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 的返回值来测试一个或多个字符值。例如：</target>
        </trans-unit>
        <trans-unit id="c4d19f268a46b2039ad626d07491613ba196e3ba" translate="yes" xml:space="preserve">
          <source>To determine if you are running under ASCII or EBCDIC, you can use the return value of &lt;code&gt;ord()&lt;/code&gt; or &lt;code&gt;chr()&lt;/code&gt; to test one or more character values. For example:</source>
          <target state="translated">要确定您是在ASCII还是EBCDIC下运行，可以使用 &lt;code&gt;ord()&lt;/code&gt; 或 &lt;code&gt;chr()&lt;/code&gt; 的返回值来测试一个或多个字符值。例如：</target>
        </trans-unit>
        <trans-unit id="86e75dff4a5cb692b3db4e186257a30b993c598a" translate="yes" xml:space="preserve">
          <source>To determine whether or not perl was built under an EBCDIC code page you can use the Config module like so:</source>
          <target state="translated">要确定perl是否是在EBCDIC代码页下构建的,你可以使用Config模块,比如这样。</target>
        </trans-unit>
        <trans-unit id="c7ca989a561cc6bb21cb242f3f9a4867fcc2a0a2" translate="yes" xml:space="preserve">
          <source>To determine which category a specific warning has been assigned to see &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;.</source>
          <target state="translated">要确定为哪个类别指定了特定警告，请参阅&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a93e35e1721136bbf3e35a386749266ad37800e0" translate="yes" xml:space="preserve">
          <source>To die with a simple string message, the &lt;a href=&quot;#croak&quot;&gt;&quot;croak&quot;&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">为了用简单的字符串消息消亡，&lt;a href=&quot;#croak&quot;&gt;&amp;ldquo;吱吱作响&amp;rdquo;&lt;/a&gt;功能可能会更方便。</target>
        </trans-unit>
        <trans-unit id="d2650be423c3da22a5978107c38e624c70d0e420" translate="yes" xml:space="preserve">
          <source>To die with a simple string message, the &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">为了用简单的字符串消息消亡，&lt;a href=&quot;#croak&quot;&gt;吱吱作响的&lt;/a&gt;功能可能会更方便。</target>
        </trans-unit>
        <trans-unit id="1dfd486790a39158f4a7ca56ddcfea76a7b570b2" translate="yes" xml:space="preserve">
          <source>To disable blessing objects while thawing/retrieving remove the flag &lt;code&gt;BLESS_OK&lt;/code&gt; = 2 from &lt;code&gt;$Storable::flags&lt;/code&gt; or set the 2nd argument for thaw/retrieve to 0.</source>
          <target state="translated">要在解冻/检索时禁用祝福对象，请从 &lt;code&gt;$Storable::flags&lt;/code&gt; 删除标志 &lt;code&gt;BLESS_OK&lt;/code&gt; = 2或将解冻/检索的第二个参数设置为0。</target>
        </trans-unit>
        <trans-unit id="347758299b3b52a08c513c37128e636634230c65" translate="yes" xml:space="preserve">
          <source>To disable prototypes:</source>
          <target state="translated">要禁用原型。</target>
        </trans-unit>
        <trans-unit id="5d0844b4d1a693267fe5fcf752c200ff27d0a20a" translate="yes" xml:space="preserve">
          <source>To disable scoping:</source>
          <target state="translated">要禁用范围化。</target>
        </trans-unit>
        <trans-unit id="49438a7c7aac56a61be90484df5f68db7923a254" translate="yes" xml:space="preserve">
          <source>To disable the feature and, if applicable, re-enable any warnings, use:</source>
          <target state="translated">要禁用该功能,并在适用情况下重新启用任何警告,请使用。</target>
        </trans-unit>
        <trans-unit id="6a2e4cf0ee9b26b39ec068b4b4c9bcaa2ebda9e0" translate="yes" xml:space="preserve">
          <source>To disable this check, set this variable to &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">要禁用此检查，请将此变量设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ff637f529a61890918adfda94de235cbe32273b" translate="yes" xml:space="preserve">
          <source>To disable this check, set this variable to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">要禁用此检查，请将此变量设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b80cbb6c9445e33c66e64e8bbc664c2dc7cb143d" translate="yes" xml:space="preserve">
          <source>To disable this default safe mode, set these values to something higher than 0. At a level of 1, you get backtraces upon receiving any kind of warning (this is often annoying) or exception (this is often valuable). Unfortunately, the debugger cannot discern fatal exceptions from non-fatal ones. If &lt;code&gt;dieLevel&lt;/code&gt; is even 1, then your non-fatal exceptions are also traced and unceremoniously altered if they came from &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval'ed&lt;/a&gt;&lt;/code&gt; strings or from any kind of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; within modules you're attempting to load. If &lt;code&gt;dieLevel&lt;/code&gt; is 2, the debugger doesn't care where they came from: It usurps your exception handler and prints out a trace, then modifies all exceptions with its own embellishments. This may perhaps be useful for some tracing purposes, but tends to hopelessly destroy any program that takes its exception handling seriously.</source>
          <target state="translated">要禁用此默认安全模式，请将这些值设置为大于0的值。级别为1时，在收到任何类型的警告（这通常很烦人）或异常（这通常很有价值）时会得到回溯。不幸的是，调试器无法区分致命错误和非致命错误。如果 &lt;code&gt;dieLevel&lt;/code&gt; 甚至为1，那么非致命异常也将被跟踪，并且如果它们来自 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval'ed&lt;/a&gt;&lt;/code&gt; 字符串或尝试加载的模块中的任何类型的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，则可以毫不客气地对其进行更改。如果 &lt;code&gt;dieLevel&lt;/code&gt; 为2时，调试器不在乎它们来自何处：它会篡改异常处理程序并打印出跟踪，然后使用自己的修饰来修改所有异常。这可能对于某些跟踪目的很有用，但往往无可救药地破坏认真对待其异常处理的任何程序。</target>
        </trans-unit>
        <trans-unit id="cb4293ab3018dc6b8d0d5076e39654c8c02af5e2" translate="yes" xml:space="preserve">
          <source>To disable this default safe mode, set these values to something higher than 0. At a level of 1, you get backtraces upon receiving any kind of warning (this is often annoying) or exception (this is often valuable). Unfortunately, the debugger cannot discern fatal exceptions from non-fatal ones. If &lt;code&gt;dieLevel&lt;/code&gt; is even 1, then your non-fatal exceptions are also traced and unceremoniously altered if they came from &lt;code&gt;eval'ed&lt;/code&gt; strings or from any kind of &lt;code&gt;eval&lt;/code&gt; within modules you're attempting to load. If &lt;code&gt;dieLevel&lt;/code&gt; is 2, the debugger doesn't care where they came from: It usurps your exception handler and prints out a trace, then modifies all exceptions with its own embellishments. This may perhaps be useful for some tracing purposes, but tends to hopelessly destroy any program that takes its exception handling seriously.</source>
          <target state="translated">要禁用此默认安全模式，请将这些值设置为大于0的值。级别为1时，在收到任何类型的警告（这通常很烦人）或异常（这通常很有价值）时会得到回溯。不幸的是，调试器无法区分致命错误和非致命错误。如果 &lt;code&gt;dieLevel&lt;/code&gt; 甚至为1，则非致命异常也将被跟踪，并且如果它们来自 &lt;code&gt;eval'ed&lt;/code&gt; 字符串或尝试加载的模块中的任何类型的 &lt;code&gt;eval&lt;/code&gt; ，则可以毫不客气地对其进行更改。如果 &lt;code&gt;dieLevel&lt;/code&gt; 为2时，调试器不在乎它们来自何处：它会篡改异常处理程序并打印出跟踪，然后使用自己的修饰来修改所有异常。这可能对于某些跟踪目的很有用，但往往会无可救药地破坏任何认真对待其异常处理的程序。</target>
        </trans-unit>
        <trans-unit id="775ac8e4b166c7efdd67d5a474126369cafcedff" translate="yes" xml:space="preserve">
          <source>To disable tieing data while thawing/retrieving remove the flag &lt;code&gt;TIE_OK&lt;/code&gt; = 4 from &lt;code&gt;$Storable::flags&lt;/code&gt; or set the 2nd argument for thaw/retrieve to 0.</source>
          <target state="translated">要在解冻/检索时禁用绑定数据，请从 &lt;code&gt;$Storable::flags&lt;/code&gt; 删除标志 &lt;code&gt;TIE_OK&lt;/code&gt; = 4或将解冻/检索的第二个参数设置为0。</target>
        </trans-unit>
        <trans-unit id="8d156c08336acd4fd9a2800ec24f479a8112dea4" translate="yes" xml:space="preserve">
          <source>To disable version checking:</source>
          <target state="translated">要禁用版本检查。</target>
        </trans-unit>
        <trans-unit id="738a71c259ac0a8afb90292476b05521cb3a2b41" translate="yes" xml:space="preserve">
          <source>To disallow the use of, for example, &lt;code&gt;LWP&lt;/code&gt; and &lt;code&gt;Net::FTP&lt;/code&gt; , you could set $File::Fetch::BLACKLIST to:</source>
          <target state="translated">要禁止使用例如 &lt;code&gt;LWP&lt;/code&gt; 和 &lt;code&gt;Net::FTP&lt;/code&gt; ，可以将$ File :: Fetch :: BLACKLIST设置为：</target>
        </trans-unit>
        <trans-unit id="8c3ea5cb60afc12efc66dbc5590a051167db7a27" translate="yes" xml:space="preserve">
          <source>To disallow the use of, for example, &lt;code&gt;LWP&lt;/code&gt; and &lt;code&gt;Net::FTP&lt;/code&gt;, you could set $File::Fetch::BLACKLIST to:</source>
          <target state="translated">例如，要禁止使用 &lt;code&gt;LWP&lt;/code&gt; 和 &lt;code&gt;Net::FTP&lt;/code&gt; ，可以将$ File :: Fetch :: BLACKLIST设置为：</target>
        </trans-unit>
        <trans-unit id="80dd5fada40953f3424fd8a183a453e068557bb1" translate="yes" xml:space="preserve">
          <source>To discover what type of value the reference refers to, use the following macro and then check the return value.</source>
          <target state="translated">要发现引用指的是什么类型的值,使用以下宏,然后检查返回值。</target>
        </trans-unit>
        <trans-unit id="8fc94d5f52eb1139b287df828008badfb6c3e089" translate="yes" xml:space="preserve">
          <source>To display and change the libnet configuration run the libnetcfg command.</source>
          <target state="translated">要显示和更改libnet配置,请运行libnetcfg命令。</target>
        </trans-unit>
        <trans-unit id="60ed656a96349b78cdba5a83471f5324d8dd1e87" translate="yes" xml:space="preserve">
          <source>To display the results you use the</source>
          <target state="translated">要显示结果,您可以使用</target>
        </trans-unit>
        <trans-unit id="2ac49a31f43cbe10ed9c501335f1421ecc6af0bb" translate="yes" xml:space="preserve">
          <source>To do it correctly, you can use one of the &lt;code&gt;Date&lt;/code&gt; modules since they work with calendars instead of times. The &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; module makes it simple, and give you the same time of day, only the day before, despite daylight saving time changes:</source>
          <target state="translated">要正确执行此操作，可以使用&amp;ldquo; &lt;code&gt;Date&lt;/code&gt; 模块之一，因为它们使用日历而不是时间。该&lt;a href=&quot;datetime&quot;&gt;日期时间&lt;/a&gt;模块使得它简单，给你一天的同一时间，只有前一天，尽管夏令时更改：</target>
        </trans-unit>
        <trans-unit id="ad781551179d37e74d6f0377992b51ea7bdaace0" translate="yes" xml:space="preserve">
          <source>To do it correctly, you can use one of the &lt;code&gt;Date&lt;/code&gt; modules since they work with calendars instead of times. The &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module makes it simple, and give you the same time of day, only the day before, despite daylight saving time changes:</source>
          <target state="translated">要正确执行此操作，可以使用&amp;ldquo; &lt;code&gt;Date&lt;/code&gt; 模块之一，因为它们使用日历而不是时间。该&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;日期时间&lt;/a&gt;模块使得它简单，给你一天的同一时间，只有前一天，尽管夏令时更改：</target>
        </trans-unit>
        <trans-unit id="9370a32c5a26795ae66ed04fd1bbf4641dcb50f3" translate="yes" xml:space="preserve">
          <source>To do so, PerlIO always calls (de|en)code methods with CHECK set to 1. This ensures that the method stops at the right place when it encounters partial character. The following is what happens when PerlIO and Encode tries to encode (from utf8) more than 1024 bytes and the buffer boundary happens to be in the middle of a character.</source>
          <target state="translated">为此,PerlIO总是在CHECK设置为1的情况下调用(de|en)码方法,这样可以确保方法在遇到部分字符时停在正确的位置。下面是PerlIO和Encode试图对超过1024个字节的字符进行编码(从utf8开始),而缓冲区边界恰好在一个字符的中间时的情况。</target>
        </trans-unit>
        <trans-unit id="e288609d3f494ae8be47d7fabedf138f3b357269" translate="yes" xml:space="preserve">
          <source>To do the equivalent of &lt;code&gt;cp -R&lt;/code&gt; (i.e. copy an entire directory tree recursively) in portable Perl, you'll either need to write something yourself or find a good CPAN module such as &lt;a href=&quot;File::Copy::Recursive&quot;&gt;File::Copy::Recursive&lt;/a&gt;.</source>
          <target state="translated">要在便携式Perl中执行 &lt;code&gt;cp -R&lt;/code&gt; 的等效功能（即以递归方式复制整个目录树），您要么需要自己写点东西，要么需要找到一个不错的CPAN模块，例如&lt;a href=&quot;File::Copy::Recursive&quot;&gt;File :: Copy :: Recursive&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1d6265a7b40372fb699b2b2f27a1df7b8f80a66" translate="yes" xml:space="preserve">
          <source>To do the equivalent of &lt;code&gt;cp -R&lt;/code&gt; (i.e. copy an entire directory tree recursively) in portable Perl, you'll either need to write something yourself or find a good CPAN module such as &lt;a href=&quot;http://search.cpan.org/perldoc/File::Copy::Recursive&quot;&gt;File::Copy::Recursive&lt;/a&gt;.</source>
          <target state="translated">要在便携式Perl中执行 &lt;code&gt;cp -R&lt;/code&gt; 的等效功能（即以递归方式复制整个目录树），您需要自己编写一些内容或找到一个好的CPAN模块，例如&lt;a href=&quot;http://search.cpan.org/perldoc/File::Copy::Recursive&quot;&gt;File :: Copy :: Recursive&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="800198c8e77892b2ea37f8a62c33fb5be9843971" translate="yes" xml:space="preserve">
          <source>To do this we need to produce a program by parsing the text. We then need to execute the program to find the point in the string that matches. And we need to do the whole thing efficiently.</source>
          <target state="translated">要做到这一点,我们需要通过解析文本来制作一个程序。然后我们需要执行程序,在字符串中找到匹配的点。而且我们需要高效地完成整个过程。</target>
        </trans-unit>
        <trans-unit id="b3b368d6bf057c7196323316138f2bb623cf857e" translate="yes" xml:space="preserve">
          <source>To do this you need to store a copy of the object returned from the tie.</source>
          <target state="translated">要做到这一点,你需要存储一个从领带返回的对象的副本。</target>
        </trans-unit>
        <trans-unit id="16944f02408f01608a70adc6c00bddd6a6f21c5d" translate="yes" xml:space="preserve">
          <source>To do this, declare the XSUB as</source>
          <target state="translated">要做到这一点,请将XSUB声明为</target>
        </trans-unit>
        <trans-unit id="9ba25feb906f9144f135e56832aaff07eb5da168" translate="yes" xml:space="preserve">
          <source>To do this, simple invoke the redispatch as:</source>
          <target state="translated">要做到这一点,只需调用重新调度为。</target>
        </trans-unit>
        <trans-unit id="c76098aac2b117e4e74346d50713bf96ac98a839" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;TAP::Formatter&quot;&gt;TAP::Formatter&lt;/a&gt;, or write your own. Writing formatters are a bit more involved than writing a</source>
          <target state="translated">为此，您可以扩展现有的&lt;a href=&quot;TAP::Formatter&quot;&gt;TAP :: Formatter&lt;/a&gt;，也可以编写自己的TAP :: Formatter。编写格式化程序比编写一个格式化程序要复杂得多。</target>
        </trans-unit>
        <trans-unit id="bab21cf4aaf0dd1470c7bbbf3e1fd1618a699e4e" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, or write your own. It's a pretty simple API, and they can be loaded and configured using the &lt;code&gt;sources&lt;/code&gt; parameter to &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt;.</source>
          <target state="translated">为此，您可以扩展现有的&lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;，也可以编写自己的TAP :: Parser :: SourceHandler。这是一个非常简单的API，可以使用 &lt;code&gt;sources&lt;/code&gt; 参数将其加载和配置为&lt;a href=&quot;#new&quot;&gt;&amp;ldquo; new&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b963497fc0bd80a2ad6cd72e920bb19d3acf535" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Formatter&quot;&gt;TAP::Formatter&lt;/a&gt;, or write your own. Writing formatters are a bit more involved than writing a</source>
          <target state="translated">为此，您可以扩展现有的&lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Formatter&quot;&gt;TAP :: Formatter&lt;/a&gt;，也可以编写自己的文件。编写格式化程序比编写一个格式化程序要复杂得多。</target>
        </trans-unit>
        <trans-unit id="4d922248445626035fad600ec3b500e3d07eeccb" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, or write your own. It's a pretty simple API, and they can be loaded and configured using the &lt;code&gt;sources&lt;/code&gt; parameter to &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">为此，您可以扩展现有的&lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;，也可以编写自己的。这是一个非常简单的API，可以使用 &lt;code&gt;sources&lt;/code&gt; 参数将它们加载和配置为&lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9af8e6fc2b2d44ed39a720480b5eca952598206" translate="yes" xml:space="preserve">
          <source>To do this, you have to parse out each word in the input stream. We'll pretend that by word you mean chunk of alphabetics, hyphens, or apostrophes, rather than the non-whitespace chunk idea of a word given in the previous question:</source>
          <target state="translated">要做到这一点,你必须解析出输入流中的每个单词。我们假设你所说的单词是指字母、连字符或省略号的块,而不是上一个问题中给出的非空白块的单词概念。</target>
        </trans-unit>
        <trans-unit id="6deb2232b7d100aa506f8d7a9be0b44c33bb7cba" translate="yes" xml:space="preserve">
          <source>To do this, you need to inform &lt;code&gt;WriteMakeFile()&lt;/code&gt; in your</source>
          <target state="translated">为此，您需要通知您的 &lt;code&gt;WriteMakeFile()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a594dc0644909bfef7173f1f8eb29922809128db" translate="yes" xml:space="preserve">
          <source>To do what you meant properly, you must write:</source>
          <target state="translated">要想做好自己的意思,必须要写。</target>
        </trans-unit>
        <trans-unit id="da74a36079576adc88b6c00e82f57a05912e49d0" translate="yes" xml:space="preserve">
          <source>To do your own error handling, call this function with the &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; flag to suppress any warnings, and then examine the &lt;code&gt;*errors&lt;/code&gt; return.</source>
          <target state="translated">要执行自己的错误处理，请使用 &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; 标志调用此函数以禁止显示任何警告，然后检查 &lt;code&gt;*errors&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="d3e2fbf11b8c81738d92b26c858673a8798bed9d" translate="yes" xml:space="preserve">
          <source>To emphasize that you are operating only on ASCII characters, you can append &lt;code&gt;_A&lt;/code&gt; to each of the macros in the ASCII column: &lt;code&gt;isALPHA_A&lt;/code&gt; , &lt;code&gt;isDIGIT_A&lt;/code&gt; , and so on.</source>
          <target state="translated">为了强调您仅对ASCII字符进行操作，可以将 &lt;code&gt;_A&lt;/code&gt; 附加到ASCII列中的每个宏： &lt;code&gt;isALPHA_A&lt;/code&gt; ， &lt;code&gt;isDIGIT_A&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="a0a83e62e85a9a106da5ff1e3e3b0371178b7026" translate="yes" xml:space="preserve">
          <source>To emphasize that you are operating only on ASCII characters, you can append &lt;code&gt;_A&lt;/code&gt; to each of the macros in the ASCII column: &lt;code&gt;isALPHA_A&lt;/code&gt;, &lt;code&gt;isDIGIT_A&lt;/code&gt;, and so on.</source>
          <target state="translated">为了强调您仅对ASCII字符进行操作，可以将 &lt;code&gt;_A&lt;/code&gt; 附加到ASCII列中的每个宏： &lt;code&gt;isALPHA_A&lt;/code&gt; ， &lt;code&gt;isDIGIT_A&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="7d42b2af4b68e58610fc5bf7b2aa1e720d762bd6" translate="yes" xml:space="preserve">
          <source>To enable colouring from the command line, you can use the &lt;a href=&quot;Text::Builder::Tester::Color&quot;&gt;Text::Builder::Tester::Color&lt;/a&gt; module like so:</source>
          <target state="translated">要从命令行启用着色，可以使用&lt;a href=&quot;Text::Builder::Tester::Color&quot;&gt;Text :: Builder :: Tester :: Color&lt;/a&gt;模块，如下所示：</target>
        </trans-unit>
        <trans-unit id="e2f50143516f5760cd1414be18dcb711d9b307dd" translate="yes" xml:space="preserve">
          <source>To enable colouring from the command line, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Builder::Tester::Color&quot;&gt;Text::Builder::Tester::Color&lt;/a&gt; module like so:</source>
          <target state="translated">要从命令行启用着色，可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Builder::Tester::Color&quot;&gt;Text :: Builder :: Tester :: Color&lt;/a&gt;模块，如下所示：</target>
        </trans-unit>
        <trans-unit id="9c570da316518400b84383905afc3b038138342e" translate="yes" xml:space="preserve">
          <source>To enable multiline matching one should use the &lt;code&gt;/m&lt;/code&gt; regexp modifier (possibly in combination with &lt;code&gt;/s&lt;/code&gt;). This can be set on a per match bases, or can be enabled per lexical scope (including a whole file) with &lt;code&gt;use re '/m'&lt;/code&gt;.</source>
          <target state="translated">要启用多行匹配，应使用 &lt;code&gt;/m&lt;/code&gt; regexp修饰符（可能与 &lt;code&gt;/s&lt;/code&gt; 结合使用）。可以在每个匹配的基础上设置，也可以 &lt;code&gt;use re '/m'&lt;/code&gt; 在每个词法范围（包括整个文件）中启用。</target>
        </trans-unit>
        <trans-unit id="b01967f773567b844b2b023b2a86bde4df70fc34" translate="yes" xml:space="preserve">
          <source>To enable prototypes:</source>
          <target state="translated">要启用原型。</target>
        </trans-unit>
        <trans-unit id="5ccde66aca7ada9c8fed76ada1d4a0446a4f8743" translate="yes" xml:space="preserve">
          <source>To enable scoping:</source>
          <target state="translated">要启用范围界定:</target>
        </trans-unit>
        <trans-unit id="767b2e0f754eeebe201f5f18e618f6b053217aac" translate="yes" xml:space="preserve">
          <source>To enable this seamless support, you should &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; (which is automatically selected if you &lt;code&gt;use 5.012&lt;/code&gt; or higher). See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. (5.14 also fixes a number of bugs and departures from the Unicode standard.)</source>
          <target state="translated">要启用此无缝支持，应 &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; （如果 &lt;code&gt;use 5.012&lt;/code&gt; 或更高版本，则会自动选择该功能）。请参阅&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。（5.14还修复了一些错误以及与Unicode标准的不同之处。）</target>
        </trans-unit>
        <trans-unit id="1484f429016f98a746a3ab26c198f24bb67adaaa" translate="yes" xml:space="preserve">
          <source>To enable version checking:</source>
          <target state="translated">要启用版本检查。</target>
        </trans-unit>
        <trans-unit id="a7615d4326dc246eeb4adafc5aa5d8082bb1cd6e" translate="yes" xml:space="preserve">
          <source>To encode a string yourself, use the &lt;a href=&quot;URI::Escape&quot;&gt;URI::Escape&lt;/a&gt; module. The &lt;code&gt;uri_escape&lt;/code&gt; function returns the escaped string:</source>
          <target state="translated">要自己编码一个字符串，请使用&lt;a href=&quot;URI::Escape&quot;&gt;URI :: Escape&lt;/a&gt;模块。该 &lt;code&gt;uri_escape&lt;/code&gt; 函数返回的转义字符串：</target>
        </trans-unit>
        <trans-unit id="270b403e8cadfb40d1d97c0de3bf7642f9c98fb6" translate="yes" xml:space="preserve">
          <source>To encode a string yourself, use the &lt;a href=&quot;http://search.cpan.org/perldoc/URI::Escape&quot;&gt;URI::Escape&lt;/a&gt; module. The &lt;code&gt;uri_escape&lt;/code&gt; function returns the escaped string:</source>
          <target state="translated">要自己编码字符串，请使用&lt;a href=&quot;http://search.cpan.org/perldoc/URI::Escape&quot;&gt;URI :: Escape&lt;/a&gt;模块。该 &lt;code&gt;uri_escape&lt;/code&gt; 函数返回的转义字符串：</target>
        </trans-unit>
        <trans-unit id="197383dea9cb9c2b7e4139f047ab7802bc1168de" translate="yes" xml:space="preserve">
          <source>To end a Pod block, use a blank line, then a line beginning with &quot;=cut&quot;, and a blank line after it. This lets Perl (and the Pod formatter) know that this is where Perl code is resuming. (The blank line before the &quot;=cut&quot; is not technically necessary, but many older Pod processors require it.)</source>
          <target state="translated">要结束一个Pod块,先用空行,然后用&quot;=cut &quot;开头的行,再在它后面用空行。这可以让Perl(和Pod格式化器)知道这是Perl代码恢复的地方。(&quot;=cut &quot;前的空行在技术上并不是必须的,但许多旧的 Pod 处理器要求这样做。)</target>
        </trans-unit>
        <trans-unit id="0ae4a1a4ec134ed8922ee208a028b2c3245ebe13" translate="yes" xml:space="preserve">
          <source>To enforce scalar context in this particular case, however, you need merely omit the parentheses:</source>
          <target state="translated">然而,要在这种特殊情况下执行标量上下文,你只需要省略括号。</target>
        </trans-unit>
        <trans-unit id="5528aa31607b22ee5ba7b25dc9ad20fd957a80a3" translate="yes" xml:space="preserve">
          <source>To ensure your Perl programs can see these newly installed modules, set your &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable to</source>
          <target state="translated">为确保您的Perl程序可以看到这些新安装的模块，请将您的 &lt;code&gt;PERL5LIB&lt;/code&gt; 环境变量设置为</target>
        </trans-unit>
        <trans-unit id="7aa8a6d9b5359d93562881107c4eb01ac8b79421" translate="yes" xml:space="preserve">
          <source>To escape the special meaning of &lt;code&gt;.&lt;/code&gt;, we use &lt;code&gt;\Q&lt;/code&gt; :</source>
          <target state="translated">逃避...的特殊含义 &lt;code&gt;.&lt;/code&gt; ，我们使用 &lt;code&gt;\Q&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="23c0119f090722ce349ecc5009302976b6a64631" translate="yes" xml:space="preserve">
          <source>To escape the special meaning of &lt;code&gt;.&lt;/code&gt;, we use &lt;code&gt;\Q&lt;/code&gt;:</source>
          <target state="translated">逃避...的特殊含义 &lt;code&gt;.&lt;/code&gt; ，我们使用 &lt;code&gt;\Q&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1f8b13457bc503e2905034bca18967c492e5be31" translate="yes" xml:space="preserve">
          <source>To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come out our old STDERR:</source>
          <target state="translated">要交换一个命令的STDOUT和STDERR,以便捕获STDERR,但留下它的STDOUT,出来我们的旧STDERR。</target>
        </trans-unit>
        <trans-unit id="f19cbea3f43d914ef5dccac2f20ddb20b0a670bb" translate="yes" xml:space="preserve">
          <source>To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come out the old STDERR:</source>
          <target state="translated">要交换一个命令的STDOUT和STDERR,以便捕获STDERR,但留下它的STDOUT,出来的是旧的STDERR。</target>
        </trans-unit>
        <trans-unit id="1e299ba0ecd4337d918ed97321e55b553fe7e0a0" translate="yes" xml:space="preserve">
          <source>To exercise the various implementations the script &lt;a href=&quot;#Example-2&quot;&gt;below&lt;/a&gt; can be used.</source>
          <target state="translated">为了执行各种实现，可以使用&lt;a href=&quot;#Example-2&quot;&gt;以下&lt;/a&gt;脚本。</target>
        </trans-unit>
        <trans-unit id="746a283f2992b56a8070a48ac33ef2cb2b8ab7fb" translate="yes" xml:space="preserve">
          <source>To explain them each in detail:</source>
          <target state="translated">要详细解释它们各自。</target>
        </trans-unit>
        <trans-unit id="337ab3fc6e23ee2083bb48006f6530a512cb7265" translate="yes" xml:space="preserve">
          <source>To explicitly turn off a &quot;FATAL&quot; warning you just disable the warning it is associated with. So, for example, to disable the &quot;void&quot; warning in the example above, either of these will do the trick:</source>
          <target state="translated">要明确关闭一个 &quot;FATAL &quot;警告,你只需禁用与之相关的警告。所以,例如,要禁用上面例子中的 &quot;void &quot;警告,这两种方法都可以。</target>
        </trans-unit>
        <trans-unit id="d8cfaf574ce10955d44800ed1fb485165bb12d03" translate="yes" xml:space="preserve">
          <source>To extract a comma-delimited list of numbers, use</source>
          <target state="translated">要提取一个以逗号分隔的数字列表,使用</target>
        </trans-unit>
        <trans-unit id="d086f02213d0494d6662b67a4783c59065f8a170" translate="yes" xml:space="preserve">
          <source>To extract an ASCII tar archive on BS2000 POSIX you need an ASCII filesystem (we used the mountpoint /usr/local/ascii for this). Now you extract the archive in the ASCII filesystem without I/O-conversion:</source>
          <target state="translated">要在BS2000 POSIX上解压ASCII压缩包,你需要一个ASCII文件系统(我们使用挂载点/usr/local/ascii)。现在你可以在ASCII文件系统中解压压缩包,而不需要进行I/O转换。</target>
        </trans-unit>
        <trans-unit id="25ec0794844bd37f005928c43a00d6da3d3e457e" translate="yes" xml:space="preserve">
          <source>To find how (UCS-2|UTF-(16|32))(LE|BE)? differ from one another, see &lt;a href=&quot;Encode::Unicode&quot;&gt;Encode::Unicode&lt;/a&gt;.</source>
          <target state="translated">查找如何（UCS-2 | UTF-（16 | 32））（LE | BE）？彼此不同，请参见&lt;a href=&quot;Encode::Unicode&quot;&gt;Encode :: Unicode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c062b7c2a495ae2a5b72a1379e8b1a41239ea1d2" translate="yes" xml:space="preserve">
          <source>To find how to use this module in detail, see &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">要详细了解如何使用此模块，请参见&lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ee7c07a6985c2bc43ddeeba4f6a14f8a3da6596" translate="yes" xml:space="preserve">
          <source>To find how to use this module in detail, see &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">要详细了解如何使用此模块，请参见&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3930f92a272e8f2e02166feb6d52740dba8a2a7" translate="yes" xml:space="preserve">
          <source>To find out</source>
          <target state="translated">要了解</target>
        </trans-unit>
        <trans-unit id="8b9ad1d9bf5e88e70343c9bc73bc8f95e823175e" translate="yes" xml:space="preserve">
          <source>To find out how to use this module in detail, see &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">要详细了解如何使用此模块，请参见&lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2adbea2c685a6abde137a3a64635b621e1971a84" translate="yes" xml:space="preserve">
          <source>To find out how to use this module in detail, see &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">要详细了解如何使用此模块，请参见&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f73fb3d1fc5746c2536b396c0845c316c4d80215" translate="yes" xml:space="preserve">
          <source>To find out in detail which encodings are supported by this package, see &lt;a href=&quot;Encode::Supported&quot;&gt;Encode::Supported&lt;/a&gt;.</source>
          <target state="translated">要详细了解此程序包支持哪些编码，请参见&lt;a href=&quot;Encode::Supported&quot;&gt;Encode :: Supported&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8814e60c44afe937889a748a7dc5d647bd329617" translate="yes" xml:space="preserve">
          <source>To find out in detail which encodings are supported by this package, see &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt;.</source>
          <target state="translated">要详细了解此程序包支持哪些编码，请参见&lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7957585a16fb8e9f58abff4512426bfd62b9e660" translate="yes" xml:space="preserve">
          <source>To find out where a module's source code is located, use</source>
          <target state="translated">要知道一个模块的源代码在哪里,使用</target>
        </trans-unit>
        <trans-unit id="714fa5ade47f6c038c4e5047b338fbf758e5ccc9" translate="yes" xml:space="preserve">
          <source>To find out whether a given string is a valid non-zero number, it's sometimes enough to test it against both numeric 0 and also lexical &quot;0&quot; (although this will cause noises if warnings are on). That's because strings that aren't numbers count as 0, just as they do in &lt;b&gt;awk&lt;/b&gt;:</source>
          <target state="translated">要找出给定的字符串是否为有效的非零数字，有时足以将其与数字0以及词法&amp;ldquo; 0&amp;rdquo;进行比较（尽管如果打开警告会引起噪音）。这是因为非数字的字符串像&lt;b&gt;awk&lt;/b&gt;一样被计为0 ：</target>
        </trans-unit>
        <trans-unit id="b365160bfd575c380666252714a7e2191298f003" translate="yes" xml:space="preserve">
          <source>To find out which character encodings your Perl supports, run:</source>
          <target state="translated">要了解你的Perl支持哪些字符编码,请运行。</target>
        </trans-unit>
        <trans-unit id="1e6f34bd3a736ed4112e8f178b09aac2a9e39ab4" translate="yes" xml:space="preserve">
          <source>To find something between two single characters, a pattern like &lt;code&gt;/x([^x]*)x/&lt;/code&gt; will get the intervening bits in $1. For multiple ones, then something more like &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; would be needed. For nested patterns and/or balanced expressions, see the so-called &lt;a href=&quot;perlre#%28%3FPARNO%29-%28%3F-PARNO%29-%28%3F%2BPARNO%29-%28%3FR%29-%28%3F0%29&quot;&gt;(?PARNO)&lt;/a&gt; construct (available since perl 5.10). The CPAN module &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; can help to build such regular expressions (see in particular &lt;a href=&quot;Regexp::Common::balanced&quot;&gt;Regexp::Common::balanced&lt;/a&gt; and &lt;a href=&quot;Regexp::Common::delimited&quot;&gt;Regexp::Common::delimited&lt;/a&gt;).</source>
          <target state="translated">要在两个单个字符之间查找内容，类似 &lt;code&gt;/x([^x]*)x/&lt;/code&gt; 将获得$ 1中的中间位。对于多个，则需要类似 &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; 的东西。有关嵌套模式和/或平衡表达式，请参见所谓的&lt;a href=&quot;perlre#%28%3FPARNO%29-%28%3F-PARNO%29-%28%3F%2BPARNO%29-%28%3FR%29-%28%3F0%29&quot;&gt;（？PARNO）&lt;/a&gt;构造（自perl 5.10起可用）。 CPAN模块&lt;a href=&quot;Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt;可以帮助构建此类正则表达式（尤其请参见&lt;a href=&quot;Regexp::Common::balanced&quot;&gt;Regexp :: Common :: balanced&lt;/a&gt;和&lt;a href=&quot;Regexp::Common::delimited&quot;&gt;Regexp :: Common :: delimited&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8d0d1d4b42258f044bb86db954a57628e8eecd09" translate="yes" xml:space="preserve">
          <source>To find something between two single characters, a pattern like &lt;code&gt;/x([^x]*)x/&lt;/code&gt; will get the intervening bits in $1. For multiple ones, then something more like &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; would be needed. For nested patterns and/or balanced expressions, see the so-called &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt; construct (available since perl 5.10). The CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; can help to build such regular expressions (see in particular &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::balanced&quot;&gt;Regexp::Common::balanced&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::delimited&quot;&gt;Regexp::Common::delimited&lt;/a&gt;).</source>
          <target state="translated">要在两个单个字符之间查找内容，类似 &lt;code&gt;/x([^x]*)x/&lt;/code&gt; 将获得$ 1中的中间位。对于多个，则需要类似 &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; 的东西。有关嵌套模式和/或平衡表达式，请参见所谓的&lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;（？PARNO）&lt;/a&gt;构造（自perl 5.10起可用）。 CPAN模块&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt;可以帮助构建这样的正则表达式（尤其请参见&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::balanced&quot;&gt;Regexp :: Common :: balanced&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::delimited&quot;&gt;Regexp :: Common :: delimited&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="462c225b3ec5f7ec0eb1907b83b31298442e3ef8" translate="yes" xml:space="preserve">
          <source>To find the first array element which satisfies a condition, you can use the &lt;code&gt;first()&lt;/code&gt; function in the &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt; module, which comes with Perl 5.8. This example finds the first element that contains &quot;Perl&quot;.</source>
          <target state="translated">要查找满足条件的第一个数组元素，可以使用Perl 5.8随附的&lt;a href=&quot;List::Util&quot;&gt;List :: Util&lt;/a&gt;模块中的 &lt;code&gt;first()&lt;/code&gt; 函数。本示例查找包含&amp;ldquo; Perl&amp;rdquo;的第一个元素。</target>
        </trans-unit>
        <trans-unit id="c8886406693c43465a74828d32fde569bd987324" translate="yes" xml:space="preserve">
          <source>To find the first array element which satisfies a condition, you can use the &lt;code&gt;first()&lt;/code&gt; function in the &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; module, which comes with Perl 5.8. This example finds the first element that contains &quot;Perl&quot;.</source>
          <target state="translated">要查找满足条件的第一个数组元素，可以使用Perl 5.8附带的&lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt;模块中的 &lt;code&gt;first()&lt;/code&gt; 函数。本示例查找包含&amp;ldquo; Perl&amp;rdquo;的第一个元素。</target>
        </trans-unit>
        <trans-unit id="f1ca27f7c9ffaf0873146b4d5569bf1f7dd85f24" translate="yes" xml:space="preserve">
          <source>To find the package you are currently in, use the special literal &lt;code&gt;__PACKAGE__&lt;/code&gt; , as documented in &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;. You can only use the special literals as separate tokens, so you can't interpolate them into strings like you can with variables:</source>
          <target state="translated">寻找你目前在包装，使用特殊的文本 &lt;code&gt;__PACKAGE__&lt;/code&gt; ，如记录&lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;。您只能将特殊文字用作单独的标记，因此无法像使用变量那样将它们插入到字符串中：</target>
        </trans-unit>
        <trans-unit id="f89e6a14f2ee6c8a6aa9c17296db02bef0f9a5ee" translate="yes" xml:space="preserve">
          <source>To find the package you are currently in, use the special literal &lt;code&gt;__PACKAGE__&lt;/code&gt;, as documented in &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;. You can only use the special literals as separate tokens, so you can't interpolate them into strings like you can with variables:</source>
          <target state="translated">寻找你目前在包装，使用特殊的文本 &lt;code&gt;__PACKAGE__&lt;/code&gt; ，如记录&lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;。您只能将特殊文字用作单独的标记，因此无法像使用变量那样将它们插入到字符串中：</target>
        </trans-unit>
        <trans-unit id="cffcf6d33c52e5caff06e5888e1b1afff8c79cd9" translate="yes" xml:space="preserve">
          <source>To find the synonyms for single-forms, such as &lt;code&gt;\p{Any}&lt;/code&gt; , use &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt; instead.</source>
          <target state="translated">要查找单形式的同义词，例如 &lt;code&gt;\p{Any}&lt;/code&gt; ，请使用&lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases（）&lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="eb89d412def16cc37609c904cc14b810aa0fb5df" translate="yes" xml:space="preserve">
          <source>To find the synonyms for single-forms, such as &lt;code&gt;\p{Any}&lt;/code&gt;, use &lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&quot;prop_aliases()&quot;&lt;/a&gt; instead.</source>
          <target state="translated">要查找单形式的同义词，例如 &lt;code&gt;\p{Any}&lt;/code&gt; ，请改用&lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&amp;ldquo; prop_aliases（）&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b4474f5909a02cbe785465728ea131216f023c4" translate="yes" xml:space="preserve">
          <source>To find your local Perl Mongers (or PM as they're commonly abbreviated) group check the international Perl Mongers directory at &lt;a href=&quot;http://www.pm.org/&quot;&gt;http://www.pm.org/&lt;/a&gt;.</source>
          <target state="translated">要查找本地的Perl Mongers（或通常缩写为PM）组，请&lt;a href=&quot;http://www.pm.org/&quot;&gt;访问&lt;/a&gt;位于http://www.pm.org/的国际Perl Mongers目录。</target>
        </trans-unit>
        <trans-unit id="51fa9c8218dc025937f10203b9150ec3a3d4872c" translate="yes" xml:space="preserve">
          <source>To fire up the debugger, type</source>
          <target state="translated">要启动调试器,键入</target>
        </trans-unit>
        <trans-unit id="5061c6729e5e674eb297e87fb65b6e686195258a" translate="yes" xml:space="preserve">
          <source>To fix by applying one, as it were. In the realm of hackerdom, a listing of the differences between two versions of a program as might be applied by the &lt;b&gt;patch&lt;/b&gt;(1) program when you want to fix a bug or upgrade your old version.</source>
          <target state="translated">通过应用一个来修复。在黑客领域，列出了程序的两个版本之间的差异，当您要修复错误或升级旧版本时，&lt;b&gt;修补程序&lt;/b&gt;（1）可能会应用这两个版本之间的差异。</target>
        </trans-unit>
        <trans-unit id="baa8da9e4b55dce6e5a8c524e072f785277c31e7" translate="yes" xml:space="preserve">
          <source>To fix this, some people formed Unicode, Inc. and produced a new character set containing all the characters you can possibly think of and more. There are several ways of representing these characters, and the one Perl uses is called UTF-8. UTF-8 uses a variable number of bytes to represent a character. You can learn more about Unicode and Perl's Unicode model in &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">为了解决这个问题，一些人成立了Unicode，Inc.并产生了一个新的字符集，其中包含您可能想到的所有字符以及更多其他字符。有几种表示这些字符的方法，Perl使用的一种称为UTF-8。UTF-8使用可变数量的字节来表示字符。您可以在&lt;a href=&quot;perlunicode&quot;&gt;perlunicode中&lt;/a&gt;了解有关Unicode和Perl的Unicode模型的更多信息。</target>
        </trans-unit>
        <trans-unit id="a4f76f5a03185d9e714674242e64dfcf1b7f20c4" translate="yes" xml:space="preserve">
          <source>To forbid ASCII/non-ASCII matches (like &quot;k&quot; with &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; ), specify the &quot;a&quot; twice, for example &lt;code&gt;/aai&lt;/code&gt; or &lt;code&gt;/aia&lt;/code&gt; . (The first occurrence of &quot;a&quot; restricts the &lt;code&gt;\d&lt;/code&gt; , etc., and the second occurrence adds the &lt;code&gt;/i&lt;/code&gt; restrictions.) But, note that code points outside the ASCII range will use Unicode rules for &lt;code&gt;/i&lt;/code&gt; matching, so the modifier doesn't really restrict things to just ASCII; it just forbids the intermixing of ASCII and non-ASCII.</source>
          <target state="translated">要禁止ASCII /非ASCII匹配（如带有 &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; &amp;ldquo; k&amp;rdquo; ），请两次指定&amp;ldquo; a&amp;rdquo;，例如 &lt;code&gt;/aai&lt;/code&gt; 或 &lt;code&gt;/aia&lt;/code&gt; 。 （第一次出现的&amp;ldquo; a&amp;rdquo;会限制 &lt;code&gt;\d&lt;/code&gt; 等，第二次出现的会添加 &lt;code&gt;/i&lt;/code&gt; 限制。）但是，请注意，ASCII范围之外的代码点将使用Unicode规则进行 &lt;code&gt;/i&lt;/code&gt; 匹配，因此修饰符不会并没有真正将事情限制为仅ASCII；它只是禁止将ASCII与非ASCII混合使用。</target>
        </trans-unit>
        <trans-unit id="7747b215397466c348d54e9b8de2e0e6dbbf3fa6" translate="yes" xml:space="preserve">
          <source>To forbid ASCII/non-ASCII matches (like &quot;k&quot; with &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt;), specify the &lt;code&gt;&quot;a&quot;&lt;/code&gt; twice, for example &lt;code&gt;/aai&lt;/code&gt; or &lt;code&gt;/aia&lt;/code&gt;. (The first occurrence of &lt;code&gt;&quot;a&quot;&lt;/code&gt; restricts the &lt;code&gt;\d&lt;/code&gt;,</source>
          <target state="translated">要禁止ASCII /非ASCII匹配（如带有 &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; &amp;ldquo; k&amp;rdquo; ），请两次指定 &lt;code&gt;&quot;a&quot;&lt;/code&gt; ，例如 &lt;code&gt;/aai&lt;/code&gt; 或 &lt;code&gt;/aia&lt;/code&gt; 。（ &lt;code&gt;&quot;a&quot;&lt;/code&gt; 的首次出现会限制 &lt;code&gt;\d&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="ce87ca60a35ae769cbfeb60038a35828e8b052b1" translate="yes" xml:space="preserve">
          <source>To force &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; to uncompress all the bzip2 data streams, include the &lt;code&gt;MultiStream&lt;/code&gt; option, as shown below</source>
          <target state="translated">要强制 &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; 解压缩所有bzip2数据流，请包含 &lt;code&gt;MultiStream&lt;/code&gt; 选项，如下所示</target>
        </trans-unit>
        <trans-unit id="d738795a19cd0b9eeeb60570db56c2f44fad5488" translate="yes" xml:space="preserve">
          <source>To force &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; to uncompress all the gzip data streams, include the &lt;code&gt;MultiStream&lt;/code&gt; option, as shown below</source>
          <target state="translated">要强制 &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; 解压缩所有gzip数据流，请包含 &lt;code&gt;MultiStream&lt;/code&gt; 选项，如下所示</target>
        </trans-unit>
        <trans-unit id="bc2a4c58af25cd402ee36a19ab3abed7cc44071e" translate="yes" xml:space="preserve">
          <source>To force interpretation as a subroutine call, either put an ampersand before the subroutine name, or qualify the name with its package. Alternatively, you can import the subroutine (or pretend that it's imported with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; pragma).</source>
          <target state="translated">要强制将其解释为子例程调用，请在子例程名称前加上&amp;ldquo;＆&amp;rdquo;号，或使用其包对名称进行限定。或者，您可以导入子例程（或假装 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; pragma 导入）。</target>
        </trans-unit>
        <trans-unit id="d2cf84ed24d58ace958b85882dc11163745c65be" translate="yes" xml:space="preserve">
          <source>To force interpretation as a subroutine call, either put an ampersand before the subroutine name, or qualify the name with its package. Alternatively, you can import the subroutine (or pretend that it's imported with the &lt;code&gt;use subs&lt;/code&gt; pragma).</source>
          <target state="translated">要强制将其解释为子例程调用，请在子例程名称前添加&amp;ldquo;＆&amp;rdquo;号，或使用其包对名称进行限定。或者，您可以导入子例程（或假装它是 &lt;code&gt;use subs&lt;/code&gt; pragma导入的）。</target>
        </trans-unit>
        <trans-unit id="457433c503b0c64ab575af65985486ef91bd670a" translate="yes" xml:space="preserve">
          <source>To force multiple data values into an SV, you must do two things: use the &lt;code&gt;sv_set*v&lt;/code&gt; routines to add the additional scalar type, then set a flag so that Perl will believe it contains more than one type of data. The four macros to set the flags are:</source>
          <target state="translated">要将多个数据值强制输入到SV中，您必须做两件事：使用 &lt;code&gt;sv_set*v&lt;/code&gt; 例程添加其他标量类型，然后设置一个标志，以使Perl认为它包含不止一种数据类型。设置标志的四个宏是：</target>
        </trans-unit>
        <trans-unit id="b603c7813804b39f069cc444400779dd5f80774c" translate="yes" xml:space="preserve">
          <source>To force unicode semantics in code portable to perl 5.8 and 5.10, call &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; unconditionally.</source>
          <target state="translated">要在代码可移植性中将unicode语义强制为perl 5.8和5.10，请无条件调用 &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e794c449edc7f65a40ec8153981b15f3f2a9b550" translate="yes" xml:space="preserve">
          <source>To free an SV that you've created, call &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt; . Normally this call is not necessary (see &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Reference Counts and Mortality&lt;/a&gt;).</source>
          <target state="translated">要释放已创建的SV，请调用 &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt; 。通常，此调用不是必需的（请参阅&lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;参考计数和死亡率&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c3e7390df1746c54f2c60ceb3e38eab54ee218d5" translate="yes" xml:space="preserve">
          <source>To free an SV that you've created, call &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt;. Normally this call is not necessary (see &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;&quot;Reference Counts and Mortality&quot;&lt;/a&gt;).</source>
          <target state="translated">要释放已创建的SV，请调用 &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt; 。通常，此调用不是必需的（请参阅&lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;&amp;ldquo;引用计数和死亡率&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2d1737256e6e8a51ce74a94d85a078c8dd0ab640" translate="yes" xml:space="preserve">
          <source>To gain access to symbols that are exported from another module. See &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">获得对从另一个模块导出的符号的访问权限。请参阅 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 骆驼第27章，&amp;ldquo;功能&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ff21df3d4f7e1323bcb14d219834d5b523bb12a8" translate="yes" xml:space="preserve">
          <source>To gain access to symbols that are exported from another module. See &lt;code&gt;use&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">获得对从另一个模块导出的符号的访问权限。请参阅 &lt;code&gt;use&lt;/code&gt; 骆驼第27章，&amp;ldquo;功能&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0f02cb11f0716e30aa4d5cf8185ab8c7897bdf67" translate="yes" xml:space="preserve">
          <source>To generate accessors you list them when using the module:</source>
          <target state="translated">要生成存取器,你可以在使用模块时列出它们。</target>
        </trans-unit>
        <trans-unit id="dcb6076af26c9d87b4c92a15d546b5cbbac01e84" translate="yes" xml:space="preserve">
          <source>To generate just the stubs:</source>
          <target state="translated">要只生成存根。</target>
        </trans-unit>
        <trans-unit id="535754fb5bff8ed1b444cf7b15654e6f3c7d7a5c" translate="yes" xml:space="preserve">
          <source>To get a Math::BigFloat you either need to call the operation manually, make sure the operands are already of the proper type or casted to that type via Math::BigFloat-&amp;gt;new():</source>
          <target state="translated">要获取Math :: BigFloat，您需要手动调用操作，请确保操作数已经是正确的类型，或者通过Math :: BigFloat-&amp;gt; new（）强制转换为该类型：</target>
        </trans-unit>
        <trans-unit id="482a14b92894717900240dda3533f7f04de8b428" translate="yes" xml:space="preserve">
          <source>To get a binary stream an alternate method is to use:</source>
          <target state="translated">为了得到二进制流,可以使用另一种方法。</target>
        </trans-unit>
        <trans-unit id="342926328b3f4e6b863f62ddbfc63ea7184c5807" translate="yes" xml:space="preserve">
          <source>To get a full list of the available sync points:</source>
          <target state="translated">要获得可用同步点的完整列表。</target>
        </trans-unit>
        <trans-unit id="4a7e3e5cefb00444495078948120515244d3f977" translate="yes" xml:space="preserve">
          <source>To get a random number between two values, you can use the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; built-in to get a random number between 0 and 1. From there, you shift that into the range that you want.</source>
          <target state="translated">要获得两个值之间的随机数，可以使用内置的 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 获得0到1之间的随机数。从那里，将其移动到所需的范围内。</target>
        </trans-unit>
        <trans-unit id="07bedc590c0c2707d4838577cb4e73d5ee21573c" translate="yes" xml:space="preserve">
          <source>To get a random number between two values, you can use the &lt;code&gt;rand()&lt;/code&gt; built-in to get a random number between 0 and 1. From there, you shift that into the range that you want.</source>
          <target state="translated">要获得两个值之间的随机数，可以使用内置的 &lt;code&gt;rand()&lt;/code&gt; 获得0到1之间的随机数。从那里，将其移动到所需的范围内。</target>
        </trans-unit>
        <trans-unit id="503a91db6b0ee3a6aaf3799cd04cbf8c2160ee5a" translate="yes" xml:space="preserve">
          <source>To get a real at or caret into the field, do this:</source>
          <target state="translated">要想真正进入这个领域,请这样做。</target>
        </trans-unit>
        <trans-unit id="6546b16387b88ec0ca99336cb1d0e013e452d98c" translate="yes" xml:space="preserve">
          <source>To get all the output from your error log, and not miss any messages via helpful operating system buffering, insert a line like this, at the start of your script:</source>
          <target state="translated">要想从错误日志中获取所有的输出,并通过有用的操作系统缓冲来不错过任何消息,在脚本的开头插入这样一行。</target>
        </trans-unit>
        <trans-unit id="2baf587b399a3c62f41dfcb4f6a76fcf67a09c4b" translate="yes" xml:space="preserve">
          <source>To get an &lt;code&gt;HMQ&lt;/code&gt; , the extension should call &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hmq&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hmq&lt;/code&gt; .</source>
          <target state="translated">为了得到一个 &lt;code&gt;HMQ&lt;/code&gt; ，扩展应调用 &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; 中C.执行该呼叫之后， &lt;code&gt;hmq&lt;/code&gt; 可以作为被访问 &lt;code&gt;Perl_hmq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2eacbf75f11af85a991f44461b926b7c934f62f4" translate="yes" xml:space="preserve">
          <source>To get an &lt;code&gt;HMQ&lt;/code&gt;, the extension should call &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hmq&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hmq&lt;/code&gt;.</source>
          <target state="translated">为了得到一个 &lt;code&gt;HMQ&lt;/code&gt; ，扩展应调用 &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; 中C.执行该呼叫之后， &lt;code&gt;hmq&lt;/code&gt; 可以作为被访问 &lt;code&gt;Perl_hmq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4fbf979e25bdf63e3a72510bfcc0bebacbf8c90" translate="yes" xml:space="preserve">
          <source>To get an unbuffered stream specify an unbuffered layer (e.g. &lt;code&gt;:unix&lt;/code&gt; ) in the open call:</source>
          <target state="translated">要获取未缓冲的流，请在open调用中指定一个未缓冲的层（例如 &lt;code&gt;:unix&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="e43bb9c5d530c176cdc88e98a6d34bb2bcea788a" translate="yes" xml:space="preserve">
          <source>To get an unbuffered stream specify an unbuffered layer (e.g. &lt;code&gt;:unix&lt;/code&gt;) in the open call:</source>
          <target state="translated">要获取未缓冲的流，请在open调用中指定一个未缓冲的层（例如 &lt;code&gt;:unix&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="4f25553ad923c6b2f304e605c8fcb2af6b398a17" translate="yes" xml:space="preserve">
          <source>To get around the error, place the word &lt;code&gt;DB_File&lt;/code&gt; in either single or double quotes, like this:</source>
          <target state="translated">要解决该错误，请将单词 &lt;code&gt;DB_File&lt;/code&gt; 放在单引号或双引号中，如下所示：</target>
        </trans-unit>
        <trans-unit id="e7cc39162825d124202c37827aea79596926f995" translate="yes" xml:space="preserve">
          <source>To get around the security problem, I could also pull the values from a hash instead of evaluating variable names. Using a single &lt;code&gt;/e&lt;/code&gt;, I can check the hash to ensure the value exists, and if it doesn't, I can replace the missing value with a marker, in this case &lt;code&gt;???&lt;/code&gt; to signal that I missed something:</source>
          <target state="translated">为了解决安全问题，我还可以从哈希中提取值，而不是评估变量名。使用单个 &lt;code&gt;/e&lt;/code&gt; ，我可以检查哈希值以确保该值存在，如果不存在，则可以用标记替换丢失的值，在这种情况下 &lt;code&gt;???&lt;/code&gt; 表示我错过了一些东西：</target>
        </trans-unit>
        <trans-unit id="7daccee0149b6b5c023c3105df2756ca16d7041c" translate="yes" xml:space="preserve">
          <source>To get around these problems it is necessary to take a full copy of the SV. The code below shows &lt;code&gt;SaveSub2&lt;/code&gt; modified to do that.</source>
          <target state="translated">要解决这些问题，必须获取SV的完整副本。下面的代码显示 &lt;code&gt;SaveSub2&lt;/code&gt; 已修改为执行此操作。</target>
        </trans-unit>
        <trans-unit id="f3981d8032c1c97862aa0ee6d17a5d52da82d00a" translate="yes" xml:space="preserve">
          <source>To get around this, either upgrade to Perl v5.6.0 or later, do the glob yourself with readdir() and patterns, or use a module like &lt;a href=&quot;File::Glob&quot;&gt;File::Glob&lt;/a&gt;, one that doesn't use the shell to do globbing.</source>
          <target state="translated">要解决此问题，请升级到Perl v5.6.0或更高版本，使用readdir（）和pattern自己完成glob，或者使用&lt;a href=&quot;File::Glob&quot;&gt;File :: Glob之&lt;/a&gt;类的模块，该模块不使用Shell进行globing。</target>
        </trans-unit>
        <trans-unit id="e5e782973aff491dec9c851f1733c85508f6c14a" translate="yes" xml:space="preserve">
          <source>To get around this, either upgrade to Perl v5.6.0 or later, do the glob yourself with readdir() and patterns, or use a module like &lt;a href=&quot;file/glob&quot;&gt;File::Glob&lt;/a&gt;, one that doesn't use the shell to do globbing.</source>
          <target state="translated">要解决此问题，请升级到Perl v5.6.0或更高版本，使用readdir（）和pattern自己完成glob，或者使用&lt;a href=&quot;file/glob&quot;&gt;File :: Glob之&lt;/a&gt;类的模块，该模块不使用Shell进行globing。</target>
        </trans-unit>
        <trans-unit id="f6d7c7ba0c3680f1bdd16d6aa20e16ef63f21df2" translate="yes" xml:space="preserve">
          <source>To get around this, you have to unbuffer the output filehandle, in this case, &lt;code&gt;STDOUT&lt;/code&gt; . You can set the special variable &lt;code&gt;$|&lt;/code&gt; to a true value (mnemonic: making your filehandles &quot;piping hot&quot;):</source>
          <target state="translated">要解决此问题，您必须取消缓冲输出文件句柄（在本例中为 &lt;code&gt;STDOUT&lt;/code&gt; )。您可以设置特殊变量 &lt;code&gt;$|&lt;/code&gt; 到一个真实值（助记符：使文件句柄&amp;ldquo;变热&amp;rdquo;）：</target>
        </trans-unit>
        <trans-unit id="5f530554d003756c8f58481299f2771b8fc63a8d" translate="yes" xml:space="preserve">
          <source>To get around this, you have to unbuffer the output filehandle, in this case, &lt;code&gt;STDOUT&lt;/code&gt;. You can set the special variable &lt;code&gt;$|&lt;/code&gt; to a true value (mnemonic: making your filehandles &quot;piping hot&quot;):</source>
          <target state="translated">要解决此问题，您必须取消缓冲输出文件句柄，在本例中为 &lt;code&gt;STDOUT&lt;/code&gt; 。您可以设置特殊变量 &lt;code&gt;$|&lt;/code&gt; 到一个真实值（助记符：使文件句柄&amp;ldquo;变热&amp;rdquo;）：</target>
        </trans-unit>
        <trans-unit id="a6f34a68c60751e410691b9ae6ddd9f980469ba3" translate="yes" xml:space="preserve">
          <source>To get at hash elements:</source>
          <target state="translated">为了获得哈希元素。</target>
        </trans-unit>
        <trans-unit id="7f878bb059ecb8cc0e6a947e6d0564b810589ae6" translate="yes" xml:space="preserve">
          <source>To get even more recent perl depots for the whole range of HP-UX, visit H.Merijn Brand's site at &lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;http://mirrors.develooper.com/hpux/#Perl&lt;/a&gt;. Carefully read the notes to see if the available versions suit your needs.</source>
          <target state="translated">要获得有关整个HP-UX范围的更多Perl软件仓库，请访问H.Merijn Brand的站点，&lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;网址&lt;/a&gt;为http://mirrors.develooper.com/hpux/#Perl。仔细阅读说明，以查看可用版本是否符合您的需求。</target>
        </trans-unit>
        <trans-unit id="76a1d18d8c0d8e0ec36c61f2ab6bce082fca6308" translate="yes" xml:space="preserve">
          <source>To get finer test reports, call</source>
          <target state="translated">要获得更精细的测试报告,请致电</target>
        </trans-unit>
        <trans-unit id="93d274f25d53139f7087deba04a14a18e5484351" translate="yes" xml:space="preserve">
          <source>To get index entries on &lt;code&gt;STDERR&lt;/code&gt; , turn on the F register, as in:</source>
          <target state="translated">要在 &lt;code&gt;STDERR&lt;/code&gt; 上获取索引条目，请打开F寄存器，如下所示：</target>
        </trans-unit>
        <trans-unit id="4794a765fde524229c427466a3a2da3c2272b297" translate="yes" xml:space="preserve">
          <source>To get index entries on &lt;code&gt;STDERR&lt;/code&gt;, turn on the F register, as in:</source>
          <target state="translated">要在 &lt;code&gt;STDERR&lt;/code&gt; 上获取索引条目，请打开F寄存器，如下所示：</target>
        </trans-unit>
        <trans-unit id="c89e5c359123efe3e2b8df35515e166a3190f60d" translate="yes" xml:space="preserve">
          <source>To get more perl depots for the whole range of HP-UX, visit H.Merijn Brand's site at &lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;http://mirrors.develooper.com/hpux/#Perl&lt;/a&gt;. Carefully read the notes to see if the available versions suit your needs.</source>
          <target state="translated">要获得整个HP-UX范围内更多的perl软件仓库，请访问H.Merijn Brand的站点，&lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;网址&lt;/a&gt;为http://mirrors.develooper.com/hpux/#Perl。仔细阅读说明，以查看可用的版本是否满足您的需求。</target>
        </trans-unit>
        <trans-unit id="8b6b89efcdec932089c6c9c0f91cf90b0d1e52b9" translate="yes" xml:space="preserve">
          <source>To get multiple values from an array:</source>
          <target state="translated">从一个数组中获取多个值。</target>
        </trans-unit>
        <trans-unit id="c67d46d6312179612215d6ef23eb3f6db1321700" translate="yes" xml:space="preserve">
          <source>To get platform independent controls, you can use &lt;code&gt;\N{...}&lt;/code&gt; .</source>
          <target state="translated">要获得独立于平台的控件，可以使用 &lt;code&gt;\N{...}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b8ad9382504b98c42922faf4d1b352db68cbdde" translate="yes" xml:space="preserve">
          <source>To get platform independent controls, you can use &lt;code&gt;\N{...}&lt;/code&gt;.</source>
          <target state="translated">要获得独立于平台的控件，可以使用 &lt;code&gt;\N{...}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a965832b8b2f81c82888b8327d5081a21e8081aa" translate="yes" xml:space="preserve">
          <source>To get some interesting statistics, it is recommended that &lt;code&gt;randomize_urllist&lt;/code&gt; be set; this introduces some amount of randomness into the URL selection.</source>
          <target state="translated">为了获得一些有趣的统计数据，建议设置 &lt;code&gt;randomize_urllist&lt;/code&gt; 。这在URL选择中引入了一定程度的随机性。</target>
        </trans-unit>
        <trans-unit id="42f32ff5f8a54ed95afefa260a5241934e3c3cb8" translate="yes" xml:space="preserve">
          <source>To get somewhat similar but locale-dependent date strings, set up your locale environment variables appropriately (please see &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;) and try for example:</source>
          <target state="translated">要获得类似但与语言环境相关的日期字符串，请适当地设置您的语言环境环境变量（请参阅&lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;），然后尝试例如：</target>
        </trans-unit>
        <trans-unit id="ab2c259ec21b8fdc7591d4aa060782af6913d852" translate="yes" xml:space="preserve">
          <source>To get somewhat similar but locale-dependent date strings, set up your locale environment variables appropriately (please see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;) and try for example:</source>
          <target state="translated">要获得类似但与语言环境相关的日期字符串，请适当地设置您的语言环境环境变量（请参阅&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;），然后尝试例如：</target>
        </trans-unit>
        <trans-unit id="c33d002d66788db30ed6cc7efa61fd7b3021f5f2" translate="yes" xml:space="preserve">
          <source>To get the 25 traditional lowercase Greek letters, including both sigmas, you could use this instead:</source>
          <target state="translated">要得到25个繁体小写希腊字母,包括两个sigmas,你可以用这个代替。</target>
        </trans-unit>
        <trans-unit id="6e85259394ca22644c2c269f73c9d0468d9813a0" translate="yes" xml:space="preserve">
          <source>To get the HAB, the extension should call &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hab&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hab&lt;/code&gt; . There is no need to release the HAB after it is used.</source>
          <target state="translated">为了得到HAB，扩展应调用 &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; 进行该呼叫之后在C.， &lt;code&gt;hab&lt;/code&gt; 可以作为被访问 &lt;code&gt;Perl_hab&lt;/code&gt; 。使用后无需释放HAB。</target>
        </trans-unit>
        <trans-unit id="a4090f094b0b5e7e1c333253056aa1e10c2b3006" translate="yes" xml:space="preserve">
          <source>To get the HAB, the extension should call &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hab&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hab&lt;/code&gt;. There is no need to release the HAB after it is used.</source>
          <target state="translated">为了得到HAB，扩展应调用 &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; 进行该呼叫之后在C.， &lt;code&gt;hab&lt;/code&gt; 可以作为被访问 &lt;code&gt;Perl_hab&lt;/code&gt; 。使用HAB之后，无需释放它。</target>
        </trans-unit>
        <trans-unit id="35604b07a393cc3fdbf315f40abc25e64114d031" translate="yes" xml:space="preserve">
          <source>To get the IP address, you can use the &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname&lt;/a&gt;&lt;/code&gt; built-in function to turn the name into a number. To turn that number into the dotted octet form (a.b.c.d) that most people expect, use the &lt;code&gt;inet_ntoa&lt;/code&gt; function from the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module, which also comes with perl.</source>
          <target state="translated">要获取IP地址，可以使用内置的 &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname&lt;/a&gt;&lt;/code&gt; 函数将名称转换为数字。要将数字转换为大多数人期望的点分八 &lt;code&gt;inet_ntoa&lt;/code&gt; 形式（abcd），请使用&lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt;模块中的inet_ntoa函数，该模块也是perl附带的。</target>
        </trans-unit>
        <trans-unit id="6f5ae18e2f134e19fbd9a1950117e9b15bbc93df" translate="yes" xml:space="preserve">
          <source>To get the IP address, you can use the &lt;code&gt;gethostbyname&lt;/code&gt; built-in function to turn the name into a number. To turn that number into the dotted octet form (a.b.c.d) that most people expect, use the &lt;code&gt;inet_ntoa&lt;/code&gt; function from the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module, which also comes with perl.</source>
          <target state="translated">要获取IP地址，可以使用内置的 &lt;code&gt;gethostbyname&lt;/code&gt; 函数将名称转换为数字。要将数字转换成大多数人期望的点分八 &lt;code&gt;inet_ntoa&lt;/code&gt; 格式（abcd），请使用&lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt;模块中的inet_ntoa函数，该模块也是perl附带的。</target>
        </trans-unit>
        <trans-unit id="3a2fdb082ba52bcf7b3e152cd572fe7df01166a8" translate="yes" xml:space="preserve">
          <source>To get the actual events you need to get them from the parent event directly</source>
          <target state="translated">要获得实际的事件,你需要直接从父事件中获得它们</target>
        </trans-unit>
        <trans-unit id="aa0526e650783189d8454499d3396cf899e8f521" translate="yes" xml:space="preserve">
          <source>To get the day of year for any date, use &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;'s &lt;code&gt;mktime&lt;/code&gt; to get a time in epoch seconds for the argument to &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要获取任何日期的年份，请使用&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;的 &lt;code&gt;mktime&lt;/code&gt; 获取以纪元秒为单位的 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 时间。</target>
        </trans-unit>
        <trans-unit id="75db1fc5bb4504ae3cfd425396fb9b0ab5948972" translate="yes" xml:space="preserve">
          <source>To get the day of year for any date, use &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;'s &lt;code&gt;mktime&lt;/code&gt; to get a time in epoch seconds for the argument to &lt;code&gt;localtime&lt;/code&gt;.</source>
          <target state="translated">要获取任何日期的年份，请使用&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;的 &lt;code&gt;mktime&lt;/code&gt; 获取以纪元秒为单位的 &lt;code&gt;localtime&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="ffadb121be361a5885303dda8c46c6cf80b68bb1" translate="yes" xml:space="preserve">
          <source>To get the last two digits of the year (e.g., &quot;01&quot; in 2001) do:</source>
          <target state="translated">要得到年份的最后两位数字(例如,2001年的 &quot;01&quot;),可以这样做:</target>
        </trans-unit>
        <trans-unit id="65e2eefe742ea63873b699fb966b09a893a8daaa" translate="yes" xml:space="preserve">
          <source>To get the most performance benefit I want to have the test scripts that take the longest to run start first - otherwise I'll be waiting for the one test that takes nearly a minute to complete after all the others are done. I can use the --state switch to run the tests in slowest to fastest order:</source>
          <target state="translated">为了获得最大的性能优势,我想让运行时间最长的测试脚本先开始--否则我将在所有其他测试完成后,等待一个需要近一分钟才能完成的测试。我可以使用--状态开关以最慢到最快的顺序运行测试。</target>
        </trans-unit>
        <trans-unit id="22228c8d3b8e275582e9f34035469fcccc1c47a6" translate="yes" xml:space="preserve">
          <source>To get the script to work properly and silence the warning make sure there are no valid references to the tied object</source>
          <target state="translated">为了使脚本正常工作并使警告静默,请确保没有对绑定对象的有效引用。</target>
        </trans-unit>
        <trans-unit id="3d2c84cce621656fbbd6db23ecc45f9cb65b75f8" translate="yes" xml:space="preserve">
          <source>To get the stash pointer for a particular package, use the function:</source>
          <target state="translated">要获得特定包的储藏指针,使用函数。</target>
        </trans-unit>
        <trans-unit id="2990698bc29bbd13b737294b202675b151d03401" translate="yes" xml:space="preserve">
          <source>To get the version number from a Perl module, consumers should use the &lt;code&gt;MM-&amp;gt;parse_version($file)&lt;/code&gt; method provided by &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; or &lt;a href=&quot;Module::Metadata&quot;&gt;Module::Metadata&lt;/a&gt;. For example, for the module given by &lt;code&gt;$mod&lt;/code&gt;, the version may be retrieved in one of the following ways:</source>
          <target state="translated">要从Perl模块获取版本号，使用者应使用&lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;或&lt;a href=&quot;Module::Metadata&quot;&gt;Module :: Metadata&lt;/a&gt;提供的 &lt;code&gt;MM-&amp;gt;parse_version($file)&lt;/code&gt; 方法。例如，对于 &lt;code&gt;$mod&lt;/code&gt; 给定的模块，可以通过以下方式之一检索版本：</target>
        </trans-unit>
        <trans-unit id="1496f65198c7ac994d7422ae9ced83ce54781e58" translate="yes" xml:space="preserve">
          <source>To get things going, note that GBARR/Scalar-List-Utils-1.18.tar.gz is compatible with ancient perls and that File::Temp is listed as a prerequisite but CPAN has reasonable workarounds if it is missing.</source>
          <target state="translated">要开始工作,请注意GBARR/Scalar-List-Utils-1.18.tar.gz与古老的perls兼容,File::Temp被列为先决条件,但如果缺少它,CPAN有合理的变通办法。</target>
        </trans-unit>
        <trans-unit id="0258f9df35378eac84877d3f62eff75269ae164c" translate="yes" xml:space="preserve">
          <source>To get valgrind and for more information see</source>
          <target state="translated">要获得valgrind和更多信息,请参见</target>
        </trans-unit>
        <trans-unit id="969efaa9efa953c87797414000140cc60d6a47f5" translate="yes" xml:space="preserve">
          <source>To go through all of the keys, use the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; function. This extracts all of the keys of the hash and gives them back to you as a list. You can then get the value through the particular key you're processing:</source>
          <target state="translated">要浏览所有按键，请使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 功能。这将提取哈希的所有键，并将它们作为列表返回给您。然后，您可以通过正在处理的特定键来获取值：</target>
        </trans-unit>
        <trans-unit id="0bb8b0be0f6dbf55ac7483ea415db4f8150fbafd" translate="yes" xml:space="preserve">
          <source>To go through all of the keys, use the &lt;code&gt;keys&lt;/code&gt; function. This extracts all of the keys of the hash and gives them back to you as a list. You can then get the value through the particular key you're processing:</source>
          <target state="translated">要浏览所有按键，请使用 &lt;code&gt;keys&lt;/code&gt; 功能。这将提取哈希的所有键，并将它们作为列表返回给您。然后，您可以通过正在处理的特定键来获取值：</target>
        </trans-unit>
        <trans-unit id="da7117148549139674b757cf18ceb49ea4e3b714" translate="yes" xml:space="preserve">
          <source>To hack on the Perl guts, you'll need to read the following things:</source>
          <target state="translated">要黑掉Perl的内脏,你需要阅读以下内容。</target>
        </trans-unit>
        <trans-unit id="bf182f7a67e6a5ec57b171f14e7d3fa5c6ddc216" translate="yes" xml:space="preserve">
          <source>To handle this situation, Perl uses</source>
          <target state="translated">为了处理这种情况,Perl使用</target>
        </trans-unit>
        <trans-unit id="adcd3970934fc11a2c18b9c7c3e26524958accfd" translate="yes" xml:space="preserve">
          <source>To handle this situation, the PPCODE directive is used and the stack is extended using the macro:</source>
          <target state="translated">为了处理这种情况,使用PPCODE指令,并使用宏扩展栈。</target>
        </trans-unit>
        <trans-unit id="f2c53c3c3d7de6d2315fba06d0366c539cf64b63" translate="yes" xml:space="preserve">
          <source>To have everything installed in your home directory, do the following.</source>
          <target state="translated">要把所有的东西都安装在你的主目录中,请执行以下操作。</target>
        </trans-unit>
        <trans-unit id="ebc28ed79805f971814bf2f23886e1860e904a26" translate="yes" xml:space="preserve">
          <source>To help explain what &lt;code&gt;File::GlobMapper&lt;/code&gt; does, consider what code you would write if you wanted to rename all files in the current directory that ended in &lt;code&gt;.tar.gz&lt;/code&gt; to &lt;code&gt;.tgz&lt;/code&gt;. So say these files are in the current directory</source>
          <target state="translated">为了帮助解释 &lt;code&gt;File::GlobMapper&lt;/code&gt; 功能，请考虑如果要将当前目录中所有以 &lt;code&gt;.tar.gz&lt;/code&gt; 结尾的文件重命名为 &lt;code&gt;.tgz&lt;/code&gt; ，将编写什么代码。所以说这些文件在当前目录中</target>
        </trans-unit>
        <trans-unit id="2009b3db85976237ffec01f5a479f250593bd279" translate="yes" xml:space="preserve">
          <source>To help understand how to write a Perl source filter we need an example to study. Here is a complete source filter that performs rot13 decoding. (Rot13 is a very simple encryption scheme used in Usenet postings to hide the contents of offensive posts. It moves every letter forward thirteen places, so that A becomes N, B becomes O, and Z becomes M.)</source>
          <target state="translated">为了帮助理解如何编写Perl源过滤器,我们需要一个例子来研究。这里是一个完整的源码过滤器,它可以执行rot13解码。(Rot13是一个非常简单的加密方案,用于Usenet帖子中隐藏攻击性帖子的内容。它将每个字母向前移动13位,因此A变成了N,B变成了O,Z变成了M。)</target>
        </trans-unit>
        <trans-unit id="b67c3276fc328ee702718e80d3624e6e736f9072" translate="yes" xml:space="preserve">
          <source>To help understand why this can be a real problem first consider how a callback is set up in an all C environment. Typically a C API will provide a function to register a callback. This will expect a pointer to a function as one of its parameters. Below is a call to a hypothetical function &lt;code&gt;register_fatal&lt;/code&gt; which registers the C function to get called when a fatal error occurs.</source>
          <target state="translated">为了帮助理解为什么这可能是一个真正的问题，请首先考虑如何在全C环境中设置回调。通常，C API将提供注册回调的功能。这将期望指向函数的指针作为其参数之一。下面是对假设函数 &lt;code&gt;register_fatal&lt;/code&gt; 的调用，该函数注册 C函数以在发生致命错误时被调用。</target>
        </trans-unit>
        <trans-unit id="6caa11e5f28551bc8c9f71be4abd8c87215d7f26" translate="yes" xml:space="preserve">
          <source>To help you convert legacy programs to more modern Perl, the &lt;a href=&quot;pl2pm&quot;&gt;pl2pm&lt;/a&gt; utility will help you convert old-style Perl 4 libraries to new-style Perl5 modules.</source>
          <target state="translated">为了帮助您将遗留程序转换为更现代的Perl，&lt;a href=&quot;pl2pm&quot;&gt;pl2pm&lt;/a&gt;实用程序将帮助您将旧式Perl 4库转换为新式Perl5模块。</target>
        </trans-unit>
        <trans-unit id="c501d022d8a0fffa65c230084aad7354f866cab9" translate="yes" xml:space="preserve">
          <source>To help you figure out what was undefined, perl will try to tell you the name of the variable (if any) that was undefined. In some cases it cannot do this, so it also tells you what operation you used the undefined value in. Note, however, that perl optimizes your program and the operation displayed in the warning may not necessarily appear literally in your program. For example, &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; is usually optimized into &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt; , and the warning will refer to the &lt;code&gt;concatenation (.)&lt;/code&gt; operator, even though there is no &lt;code&gt;.&lt;/code&gt; in your program.</source>
          <target state="translated">为了帮助您弄清未定义的内容，perl会尝试告诉您未定义的变量的名称（如果有）。在某些情况下，它不能执行此操作，因此它还会告诉您使用了未定义值的操作。但是，请注意，perl会优化您的程序，警告中显示的操作不一定会在程序中字面上出现。例如，通常将 &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; 优化为 &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt; ，即使没有，警告也会引用 &lt;code&gt;concatenation (.)&lt;/code&gt; 运算符 &lt;code&gt;.&lt;/code&gt; 在您的程序中。</target>
        </trans-unit>
        <trans-unit id="a5f43865bbac7f1f33a9c88f0ac1c82c9566920f" translate="yes" xml:space="preserve">
          <source>To help you figure out what was undefined, perl will try to tell you the name of the variable (if any) that was undefined. In some cases it cannot do this, so it also tells you what operation you used the undefined value in. Note, however, that perl optimizes your program and the operation displayed in the warning may not necessarily appear literally in your program. For example, &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; is usually optimized into &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt;, and the warning will refer to the &lt;code&gt;concatenation (.)&lt;/code&gt; operator, even though there is no &lt;code&gt;.&lt;/code&gt; in your program.</source>
          <target state="translated">为了帮助您弄清未定义的内容，perl会尝试告诉您未定义的变量的名称（如果有）。在某些情况下，它不能执行此操作，因此它还会告诉您使用了未定义值的操作。但是，请注意，perl会优化您的程序，警告中显示的操作不一定会在程序中显示。例如，通常将 &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; 优化为 &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt; ，并且警告将引用 &lt;code&gt;concatenation (.)&lt;/code&gt; 运算符，即使没有 &lt;code&gt;.&lt;/code&gt; 在您的程序中。</target>
        </trans-unit>
        <trans-unit id="77d1efff4e4ad59e580cc05099536ea5f027ae77" translate="yes" xml:space="preserve">
          <source>To hide the rough edges under the hood, provide a tie()d interface to the package &lt;code&gt;symbolic&lt;/code&gt; . Add methods</source>
          <target state="translated">要隐藏引擎盖下的粗糙边缘，请为 &lt;code&gt;symbolic&lt;/code&gt; 包提供tie（）d接口。新增方法</target>
        </trans-unit>
        <trans-unit id="58c28f318aa4f864e9846446b68afedbfe1de577" translate="yes" xml:space="preserve">
          <source>To hide the rough edges under the hood, provide a tie()d interface to the package &lt;code&gt;symbolic&lt;/code&gt;. Add methods</source>
          <target state="translated">要隐藏引擎盖下的粗糙边缘，请为 &lt;code&gt;symbolic&lt;/code&gt; 包提供tie（）d接口。新增方法</target>
        </trans-unit>
        <trans-unit id="4b357009cc7277d51ef692d8123b4f3841c85837" translate="yes" xml:space="preserve">
          <source>To illustrate how to use &lt;code&gt;InputLength&lt;/code&gt; here is a script that walks a zip file and prints out how many lines are in each compressed file (if you intend write code to walking through a zip file for real see &lt;a href=&quot;IO::Uncompress::Unzip#Walking-through-a-zip-file&quot;&gt;&quot;Walking through a zip file&quot; in IO::Uncompress::Unzip&lt;/a&gt; ). Also, although this example uses the zlib-based compression, the technique can be used by the other &lt;code&gt;IO::Uncompress::*&lt;/code&gt; modules.</source>
          <target state="translated">为了说明如何使用 &lt;code&gt;InputLength&lt;/code&gt; ，以下是一个脚本，该脚本可遍历zip文件并打印出每个压缩文件中的行数（如果您打算编写代码以真正遍历zip文件，请参见&lt;a href=&quot;IO::Uncompress::Unzip#Walking-through-a-zip-file&quot;&gt;IO中的&amp;ldquo;遍历zip文件&amp;rdquo; :: Uncompress :: Unzip&lt;/a&gt;）。同样，尽管此示例使用基于zlib的压缩，但是该技术也可以由其他 &lt;code&gt;IO::Uncompress::*&lt;/code&gt; 模块使用。</target>
        </trans-unit>
        <trans-unit id="bb09986ebdb919a3ce53d54257037e7652baac8f" translate="yes" xml:space="preserve">
          <source>To illustrate the differences between these variables, consider the following Perl expression, which uses a single-quoted string. After execution of this statement, perl may have set all four special error variables:</source>
          <target state="translated">为了说明这些变量之间的差异,请考虑以下Perl表达式,它使用的是单引号字符串。在执行这个语句后,perl可能已经设置了所有四个特殊的错误变量。</target>
        </trans-unit>
        <trans-unit id="f0157186b912ecd3453913b9ba18ef7c370be226" translate="yes" xml:space="preserve">
          <source>To illustrate this feature, we'll design a pattern that matches if a string contains a palindrome. (This is a word or a sentence that, while ignoring spaces, interpunctuation and case, reads the same backwards as forwards. We begin by observing that the empty string or a string containing just one word character is a palindrome. Otherwise it must have a word character up front and the same at its end, with another palindrome in between.</source>
          <target state="translated">为了说明这个特性,我们将设计一个模式,如果一个字符串中包含一个词缀,则进行匹配。(这是一个单词或句子,在忽略空格、标点符号和大小写的情况下,读起来和向前一样。我们首先观察到,空字符串或只包含一个单词字符的字符串是一个表音符。否则一定是前面有一个字符,后面也有一个字符,中间还有一个回文。</target>
        </trans-unit>
        <trans-unit id="983dc7293d2e1cce05648cd63638e4f7e22fc331" translate="yes" xml:space="preserve">
          <source>To illustrate unpacking for bit strings, we'll decompose a simple status register (a &quot;-&quot; stands for a &quot;reserved&quot; bit):</source>
          <target state="translated">为了说明对位串的解包,我们将分解一个简单的状态寄存器(&quot;-&quot;代表 &quot;保留 &quot;位)。</target>
        </trans-unit>
        <trans-unit id="0eeac6bf1837c3892fad2067238a40143aea5c3f" translate="yes" xml:space="preserve">
          <source>To illustrate,</source>
          <target state="translated">为了说明:</target>
        </trans-unit>
        <trans-unit id="3f180de5f2359e1c5045cf60151ad16271ecfbd0" translate="yes" xml:space="preserve">
          <source>To implement a copy constructor, add &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; line, and code (this code assumes that mutators change things one level deep only, so recursive copying is not needed):</source>
          <target state="translated">要实现复制构造函数，请添加 &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; 以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 行和代码（此代码假定mutator仅将内容更改为一级，因此不需要递归复制）：</target>
        </trans-unit>
        <trans-unit id="1ef1c60a444763ee513ae1faa2574b43d63f6e12" translate="yes" xml:space="preserve">
          <source>To implement a copy constructor, add &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; to &lt;code&gt;use overload&lt;/code&gt; line, and code (this code assumes that mutators change things one level deep only, so recursive copying is not needed):</source>
          <target state="translated">要实现复制构造函数，请添加 &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; 以 &lt;code&gt;use overload&lt;/code&gt; 行和代码（此代码假定mutator仅将内容更改为一层，因此不需要递归复制）：</target>
        </trans-unit>
        <trans-unit id="8240260917b1a03cdad7c5747565fe071f2719a2" translate="yes" xml:space="preserve">
          <source>To implement most arithmetic operations is easy; one should just use the tables of operations, and change the code which fills %subr to</source>
          <target state="translated">要实现大部分的算术运算很容易,只需利用运算表,将填充%subr的代码改成</target>
        </trans-unit>
        <trans-unit id="81c4d513cec75ad639c29820e8f6fc040826df1f" translate="yes" xml:space="preserve">
          <source>To import subroutines:</source>
          <target state="translated">要导入子程序。</target>
        </trans-unit>
        <trans-unit id="97177a061d7ff62a243885c9bd4e1efe9ede32f2" translate="yes" xml:space="preserve">
          <source>To increase the value of something by 1 (or by some other number, if so specified).</source>
          <target state="translated">将某物的价值增加1(或其他数字,如果指定的话)。</target>
        </trans-unit>
        <trans-unit id="72b80e806b1c83aea2a8c7cd737f1e4bbb0943c8" translate="yes" xml:space="preserve">
          <source>To indicate to rather use commandline tools than modules</source>
          <target state="translated">表示宁愿使用命令行工具而不是模块</target>
        </trans-unit>
        <trans-unit id="75120c587d6fba4a38cc9dc45cf5606751546e6f" translate="yes" xml:space="preserve">
          <source>To insert a line after one already in the file, use the &lt;code&gt;-n&lt;/code&gt; switch. It's just like &lt;code&gt;-p&lt;/code&gt; except that it doesn't print &lt;code&gt;$_&lt;/code&gt; at the end of the loop, so you have to do that yourself. In this case, print &lt;code&gt;$_&lt;/code&gt; first, then print the line that you want to add.</source>
          <target state="translated">要在文件中已有的一行之后插入一行，请使用 &lt;code&gt;-n&lt;/code&gt; 开关。就像 &lt;code&gt;-p&lt;/code&gt; 一样，除了在循环结束时不显示 &lt;code&gt;$_&lt;/code&gt; 之外，因此您必须自己执行此操作。在这种情况下，先打印 &lt;code&gt;$_&lt;/code&gt; ，然后打印要添加的行。</target>
        </trans-unit>
        <trans-unit id="574f86f03c88819ff70bca34830f6be35a8bf5f1" translate="yes" xml:space="preserve">
          <source>To install NetWare Perl onto a NetWare server, first map the Sys volume of a NetWare server to</source>
          <target state="translated">要将 NetWare Perl 安装到 NetWare 服务器上,首先要将 NetWare 服务器的 Sys 卷映射到</target>
        </trans-unit>
        <trans-unit id="ee9638bdc9d8a0c759ba97d86bfdc7724a758ac8" translate="yes" xml:space="preserve">
          <source>To install a callback I pass the name of the callback and a subroutine reference to TAP::Harness or TAP::Parser's callback method:</source>
          <target state="translated">要安装一个回调,我传递回调的名称和一个子程序引用到TAP::Harness或TAP::Parser的回调方法。</target>
        </trans-unit>
        <trans-unit id="e3c3d18a60e95dd185226e349523858601f99df9" translate="yes" xml:space="preserve">
          <source>To install the Perl headers and the class CPerlBase documentation so that you no more need the Perl sources around to compile Perl applications using the SDK:</source>
          <target state="translated">安装Perl头文件和CPerlBase类文档,这样你就不再需要Perl源码来使用SDK编译Perl应用程序了。</target>
        </trans-unit>
        <trans-unit id="a7a520bfb7587900e1cbb96bf573db69af079c5b" translate="yes" xml:space="preserve">
          <source>To iterate over the indices of an array, use &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $i (0 .. $#array)
{}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $v (@array) {}&lt;/code&gt; iterates over the values.</source>
          <target state="translated">要遍历数组的索引，请使用 &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $i (0 .. $#array) {}&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $v (@array) {}&lt;/code&gt; 遍历值。</target>
        </trans-unit>
        <trans-unit id="bb6bf360110a80a4c3eb61df0aff99d211da1c11" translate="yes" xml:space="preserve">
          <source>To iterate over the indices of an array, use &lt;code&gt;foreach my $i (0 .. $#array) {}&lt;/code&gt;. &lt;code&gt;foreach my $v (@array) {}&lt;/code&gt; iterates over the values.</source>
          <target state="translated">要遍历数组的索引，请使用 &lt;code&gt;foreach my $i (0 .. $#array) {}&lt;/code&gt; 。 &lt;code&gt;foreach my $v (@array) {}&lt;/code&gt; 遍历值。</target>
        </trans-unit>
        <trans-unit id="8f0a51f73b6311fa2b970169a1f0134f7c61aef8" translate="yes" xml:space="preserve">
          <source>To join a mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt; , send an empty message to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; . This mailing list is for announcements only and has extremely low traffic---fewer than two messages per year.</source>
          <target state="translated">要加入有关 &lt;code&gt;Memoize&lt;/code&gt; 公告的邮件列表，请将空白消息发送至 &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; 。该邮件列表仅用于公告，并且流量极低-每年少于两封邮件。</target>
        </trans-unit>
        <trans-unit id="45a6289801496005295f094536fc8ecc4c1c8e83" translate="yes" xml:space="preserve">
          <source>To join a mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt;, send an empty message to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt;. This mailing list is for announcements only and has extremely low traffic---fewer than two messages per year.</source>
          <target state="translated">要加入有关 &lt;code&gt;Memoize&lt;/code&gt; 公告的邮件列表，请将空消息发送至 &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; 。该邮件列表仅用于公告，并且流量极低-每年少于两封邮件。</target>
        </trans-unit>
        <trans-unit id="9c7770af2e023d19bb1b24c66498040c02b4d820" translate="yes" xml:space="preserve">
          <source>To join a very low-traffic mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt; , send an empty note to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; .</source>
          <target state="translated">要加入流量非常低的邮件列表以获取有关 &lt;code&gt;Memoize&lt;/code&gt; 的公告，请发送空白邮件至 &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed725c5a7b13b5f14db9ddb8b3bae580a82d496b" translate="yes" xml:space="preserve">
          <source>To join a very low-traffic mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt;, send an empty note to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt;.</source>
          <target state="translated">要加入流量非常低的邮件列表以获取有关 &lt;code&gt;Memoize&lt;/code&gt; 的公告，请发送空白邮件至 &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23905cfc18d99e713280156ef1eb62fd65833ce9" translate="yes" xml:space="preserve">
          <source>To just compare two strings for equality/non-equality, you can just use &lt;a href=&quot;perlapi#memEQ&quot;&gt;&lt;code&gt;memEQ()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlapi#memEQ&quot;&gt;&lt;code&gt;memNE()&lt;/code&gt;&lt;/a&gt; as usual, except the strings must be both UTF-8 or not UTF-8 encoded.</source>
          <target state="translated">只需比较两个字符串是否相等，就可以&lt;a href=&quot;perlapi#memEQ&quot;&gt; &lt;code&gt;memEQ()&lt;/code&gt; &lt;/a&gt;仅使用memEQ（）和&lt;a href=&quot;perlapi#memEQ&quot;&gt; &lt;code&gt;memNE()&lt;/code&gt; &lt;/a&gt;，不同之处在于字符串必须都是UTF-8或非UTF-8编码的。</target>
        </trans-unit>
        <trans-unit id="30da17ba518ee8896f295021c334b446312ba2d0" translate="yes" xml:space="preserve">
          <source>To just compare two strings for equality/non-equality, you can just use &lt;a href=&quot;perlapi#memEQ&quot;&gt;memEQ() &lt;/a&gt; and &lt;a href=&quot;perlapi#memEQ&quot;&gt;memNE() &lt;/a&gt; as usual, except the strings must be both UTF-8 or not UTF-8 encoded.</source>
          <target state="translated">只需比较两个字符串是否相等，就可以&lt;a href=&quot;perlapi#memEQ&quot;&gt;像平常一样&lt;/a&gt;仅使用memEQ（）和&lt;a href=&quot;perlapi#memEQ&quot;&gt;memNE（）&lt;/a&gt;，不同之处在于字符串必须都是UTF-8或非UTF-8编码的。</target>
        </trans-unit>
        <trans-unit id="bfd1d911fc5d8c1a13ece46d4a41278866b326f9" translate="yes" xml:space="preserve">
          <source>To keep our namespace nice and unpolluted, edit the .pm file and change the variable &lt;code&gt;@EXPORT&lt;/code&gt; to &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Finally, in the .xs file, edit the #include line to read:</source>
          <target state="translated">为了使我们的命名空间保持良好且不受污染，请编辑.pm文件，并将变量 &lt;code&gt;@EXPORT&lt;/code&gt; 更改为 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 。最后，在.xs文件中，编辑#include行以读取：</target>
        </trans-unit>
        <trans-unit id="66c523aae45e20a099aa6d752ca36a4c5fad3933" translate="yes" xml:space="preserve">
          <source>To keep our namespace nice and unpolluted, edit the .pm file and change the variable &lt;code&gt;@EXPORT&lt;/code&gt; to &lt;code&gt;@EXPORT_OK&lt;/code&gt;. Finally, in the .xs file, edit the #include line to read:</source>
          <target state="translated">为了使我们的命名空间保持良好且不受污染，请编辑.pm文件，并将变量 &lt;code&gt;@EXPORT&lt;/code&gt; 更改为 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 。最后，在.xs文件中，编辑#include行以读取：</target>
        </trans-unit>
        <trans-unit id="03272788bb4c31073d76ce4d5e5b7d43fa610bff" translate="yes" xml:space="preserve">
          <source>To learn how to install modules you download from CPAN, read &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt;.</source>
          <target state="translated">要了解如何安装从CPAN下载的模块，请阅读&lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a06d2306514b40b8ba1c92a7641c86fc2fa15b9" translate="yes" xml:space="preserve">
          <source>To learn how to use a particular module, use &lt;code&gt;perldoc &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt;. Typically you will want to &lt;code&gt;use &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt;, which will then give you access to exported functions or an OO interface to the module.</source>
          <target state="translated">要了解如何使用特定模块，请使用 &lt;code&gt;perldoc &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt; 。通常，您将需要 &lt;code&gt;use &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt; ，这将使您可以访问导出的函数或该模块的OO接口。</target>
        </trans-unit>
        <trans-unit id="085a503b5041562d55123a7fc6e92076974024bc" translate="yes" xml:space="preserve">
          <source>To learn more, just type a bogus option, like &lt;b&gt;-\?&lt;/b&gt;, and a long usage message will be provided. There are a fair number of possibilities.</source>
          <target state="translated">要了解更多信息，只需输入假选项，例如&lt;b&gt;-\ ?？&lt;/b&gt;，并且将提供长时间使用消息。有很多可能性。</target>
        </trans-unit>
        <trans-unit id="7513ca0f7dee98a8be8a3dca79c36e371b5b2223" translate="yes" xml:space="preserve">
          <source>To limit the allowed bracked notation methods to a specific list, use the whitelist() method:</source>
          <target state="translated">要将允许的括号符号方法限制在一个特定的列表中,请使用 whitelist()方法。</target>
        </trans-unit>
        <trans-unit id="b660f64338ea03a5a1e256309c3e2566abdfdf76" translate="yes" xml:space="preserve">
          <source>To limit the number of decimal places in your numbers, you can use the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. See &lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;Floating-point Arithmetic in perlop&lt;/a&gt; for more details.</source>
          <target state="translated">要限制数字中的小数位数，可以使用 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 函数。有关更多详细信息，请参见&lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;perlop中的浮点算法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0835636a7544b690a78e5a06870d277ecb58681d" translate="yes" xml:space="preserve">
          <source>To limit the number of decimal places in your numbers, you can use the &lt;code&gt;printf&lt;/code&gt; or &lt;code&gt;sprintf&lt;/code&gt; function. See &lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;&quot;Floating-point Arithmetic&quot; in perlop&lt;/a&gt; for more details.</source>
          <target state="translated">要限制数字中的小数位数，可以使用 &lt;code&gt;printf&lt;/code&gt; 或 &lt;code&gt;sprintf&lt;/code&gt; 函数。有关更多详细信息，请参见&lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;perlop中的&amp;ldquo;浮点算法&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a08be93803c5f2a1dab3670911ed75d37f74ad6a" translate="yes" xml:space="preserve">
          <source>To load &lt;code&gt;TAP::Harness&lt;/code&gt; plugins, you'll need to use the &lt;code&gt;tap_harness_args&lt;/code&gt; parameter to &lt;code&gt;new&lt;/code&gt; , typically from your &lt;code&gt;Build.PL&lt;/code&gt; . For example:</source>
          <target state="translated">要加载 &lt;code&gt;TAP::Harness&lt;/code&gt; 插件，通常需要从 &lt;code&gt;Build.PL&lt;/code&gt; 中将 &lt;code&gt;tap_harness_args&lt;/code&gt; 参数用于 &lt;code&gt;new&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="189a273951294ca8e561bbd38119a481f3bcdeb3" translate="yes" xml:space="preserve">
          <source>To load &lt;code&gt;TAP::Harness&lt;/code&gt; plugins, you'll need to use the &lt;code&gt;tap_harness_args&lt;/code&gt; parameter to &lt;code&gt;new&lt;/code&gt;, typically from your &lt;code&gt;Build.PL&lt;/code&gt;. For example:</source>
          <target state="translated">要加载 &lt;code&gt;TAP::Harness&lt;/code&gt; 插件，通常需要从 &lt;code&gt;Build.PL&lt;/code&gt; 中将 &lt;code&gt;tap_harness_args&lt;/code&gt; 参数用于 &lt;code&gt;new&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="1281377e392724ce754ea5fba63ddbdb0e3e3b86" translate="yes" xml:space="preserve">
          <source>To load on demand. (Also called &amp;ldquo;lazy&amp;rdquo; loading.) Specifically, to call an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine on behalf of an undefined subroutine.</source>
          <target state="translated">按需加载。（也称为&amp;ldquo;延迟&amp;rdquo;加载。）具体地说，是代表未定义的子例程调用 &lt;code&gt;AUTOLOAD&lt;/code&gt; 子例程。</target>
        </trans-unit>
        <trans-unit id="793c105080b4d15bf59a358db204c3e7d2658f2d" translate="yes" xml:space="preserve">
          <source>To load packages while adding them to &lt;code&gt;@ISA&lt;/code&gt;, see the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma. The discouraged &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; pragma does this as well, but should not be used except when compatibility with the discouraged &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma is required.</source>
          <target state="translated">要在将软件包添加到 &lt;code&gt;@ISA&lt;/code&gt; 的同时加载软件包，请参阅&lt;a href=&quot;parent&quot;&gt;父级&lt;/a&gt;编译指示。不鼓励使用的&lt;a href=&quot;base&quot;&gt;基本&lt;/a&gt;编译指示也可以执行此操作，但是除非需要与不建议使用的&lt;a href=&quot;fields&quot;&gt;字段进行&lt;/a&gt;编译的兼容性，否则不要使用。</target>
        </trans-unit>
        <trans-unit id="c23756075d8a23d3d03df135a356f7c210c8debd" translate="yes" xml:space="preserve">
          <source>To maintain backward compatibility with version 1.x of this module &lt;code&gt;gzreadline&lt;/code&gt; ignores the &lt;code&gt;$/&lt;/code&gt; variable - it</source>
          <target state="translated">为了保持与该模块1.x版本的向后兼容性， &lt;code&gt;gzreadline&lt;/code&gt; 忽略 &lt;code&gt;$/&lt;/code&gt; 变量-它</target>
        </trans-unit>
        <trans-unit id="abc4743aa98a734da932da278854d69561d0cbfb" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; work, we need to implement actual mutators, either directly, or in &lt;code&gt;nomethod&lt;/code&gt; . We continue to do things inside &lt;code&gt;nomethod&lt;/code&gt; , thus add</source>
          <target state="translated">为了使 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 正常工作，我们需要直接或以 &lt;code&gt;nomethod&lt;/code&gt; 实现实际的变量。我们继续在 &lt;code&gt;nomethod&lt;/code&gt; 内做事，因此添加</target>
        </trans-unit>
        <trans-unit id="6a057782113c7191c271c05bf3e4a07cba925f05" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; work, we need to implement actual mutators, either directly, or in &lt;code&gt;nomethod&lt;/code&gt;. We continue to do things inside &lt;code&gt;nomethod&lt;/code&gt;, thus add</source>
          <target state="translated">为了使 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 正常工作，我们需要直接或以 &lt;code&gt;nomethod&lt;/code&gt; 实现实际的mutator 。我们继续在 &lt;code&gt;nomethod&lt;/code&gt; 内做事，因此添加</target>
        </trans-unit>
        <trans-unit id="91a1c6beb7c38d494fe7c7d801b2befdd4173ffc" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; work, there were two changes to</source>
          <target state="translated">为了使 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 起作用，需要进行两项更改</target>
        </trans-unit>
        <trans-unit id="b87c350e6119d6693a7cb04a8612a5e26f6e647d" translate="yes" xml:space="preserve">
          <source>To make a backup of &lt;code&gt;inFile.txt&lt;/code&gt; , give &lt;code&gt;-i&lt;/code&gt; a file extension to add:</source>
          <target state="translated">要备份 &lt;code&gt;inFile.txt&lt;/code&gt; ，请给 &lt;code&gt;-i&lt;/code&gt; 一个文件扩展名以添加：</target>
        </trans-unit>
        <trans-unit id="6d55112a0a5725689f79da10048f1a7a2263eebb" translate="yes" xml:space="preserve">
          <source>To make a backup of &lt;code&gt;inFile.txt&lt;/code&gt;, give &lt;code&gt;-i&lt;/code&gt; a file extension to add:</source>
          <target state="translated">要备份 &lt;code&gt;inFile.txt&lt;/code&gt; ，请给 &lt;code&gt;-i&lt;/code&gt; 一个文件扩展名以添加：</target>
        </trans-unit>
        <trans-unit id="6e23de5e44e6d05a87a65143f53c7e5d6f21dc61" translate="yes" xml:space="preserve">
          <source>To make a local branch of a remote branch:</source>
          <target state="translated">要使远程分支的本地分支。</target>
        </trans-unit>
        <trans-unit id="8414b77ccfd34c712fab8c626931679fd71f5d22" translate="yes" xml:space="preserve">
          <source>To make a long story short, you can use the special variables &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; , &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; and &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; with AVs and HVs, but you have to make sure you know what you're doing.</source>
          <target state="translated">长话短说，可以将特殊变量 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; ， &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 和 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 与AV和HV一起使用，但必须确保您知道自己在做什么。</target>
        </trans-unit>
        <trans-unit id="da79e317ac8a925a940d2422dac9d23c152e3b6d" translate="yes" xml:space="preserve">
          <source>To make a long story short, you can use the special variables &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt;, &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; and &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; with AVs and HVs, but you have to make sure you know what you're doing.</source>
          <target state="translated">长话短说，可以将特殊变量 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; ， &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 和 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 与AV和HV一起使用，但是必须确保您知道自己在做什么。</target>
        </trans-unit>
        <trans-unit id="5c0463c040e841ec603e099982e8abee57b683e9" translate="yes" xml:space="preserve">
          <source>To make life easier when dealing with duplicate keys, &lt;b&gt;DB_File&lt;/b&gt; comes with a few utility methods.</source>
          <target state="translated">为了&lt;b&gt;简化&lt;/b&gt;重复键的使用，&lt;b&gt;DB_File&lt;/b&gt;提供了一些实用程序方法。</target>
        </trans-unit>
        <trans-unit id="5ae2d3fa0128e67ff0e0a2c8bcd480511ed4d982" translate="yes" xml:space="preserve">
          <source>To make proper use of the</source>
          <target state="translated">要正确使用</target>
        </trans-unit>
        <trans-unit id="c44a199ec9bf1193e7c67a06e66e66c5a73ebf54" translate="yes" xml:space="preserve">
          <source>To make sure we're talking about the same thing when we discuss the removal of features or functionality from the Perl core, we have specific definitions for a few words and phrases.</source>
          <target state="translated">为了确保我们在讨论从 Perl 核心中移除特性或功能时,谈论的是同一件事,我们对一些单词和短语有特定的定义。</target>
        </trans-unit>
        <trans-unit id="5942273fcaa449896c9e37c66cd4e802e9c0964a" translate="yes" xml:space="preserve">
          <source>To make symbols from a &lt;b&gt;module&lt;/b&gt; available for &lt;b&gt;import&lt;/b&gt; by other modules.</source>
          <target state="translated">使&lt;b&gt;模块中的&lt;/b&gt;符号可被其他模块&lt;b&gt;导入&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="dcd61647f554ce66ac28cd2d49ac0cbdb07ed537" translate="yes" xml:space="preserve">
          <source>To make the field hashes kick in, it is easiest to redefine &lt;code&gt;refaddr&lt;/code&gt; as</source>
          <target state="translated">为了使散列值 &lt;code&gt;refaddr&lt;/code&gt; ，将refaddr重新定义为</target>
        </trans-unit>
        <trans-unit id="ffcdcbe9b2ae0d61ba055686a39957aa53dc38e5" translate="yes" xml:space="preserve">
          <source>To make the interface more useful for older versions of Perl, a number of methods are supplied with &lt;b&gt;DB_File&lt;/b&gt; to simulate the missing array operations. All these methods are accessed via the object returned from the tie call.</source>
          <target state="translated">为了使该接口对较早版本的Perl更有用，&lt;b&gt;DB_File&lt;/b&gt;提供了许多方法来模拟缺少的数组操作。所有这些方法都是通过tie调用返回的对象访问的。</target>
        </trans-unit>
        <trans-unit id="1e1af3e6c47d65824073836d9be72328a9d2a810" translate="yes" xml:space="preserve">
          <source>To make these calls fail</source>
          <target state="translated">要使这些呼叫失败</target>
        </trans-unit>
        <trans-unit id="5100ca13c61421986a8b595f7f48745403cf86c2" translate="yes" xml:space="preserve">
          <source>To make things more complicated, the hash may contain references to the actual destinations, for example:</source>
          <target state="translated">为了使事情更复杂,哈希可能包含对实际目的地的引用,例如。</target>
        </trans-unit>
        <trans-unit id="23271da81593c086fb9f97e8eda36eed5fe8ab37" translate="yes" xml:space="preserve">
          <source>To make use of either of the two filter modules above, place the line below in a Perl source file.</source>
          <target state="translated">要使用上述两个过滤模块中的任何一个,请在Perl源文件中加入以下一行。</target>
        </trans-unit>
        <trans-unit id="546b84e64be1bb2630d4087e9c7e0aa2ec07fbeb" translate="yes" xml:space="preserve">
          <source>To make use of threading, however, one usually wants the threads to share at least some data between themselves. This is done with the &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; module and the &lt;code&gt;:shared&lt;/code&gt; attribute:</source>
          <target state="translated">但是，为了利用线程，通常希望线程之间共享至少一些数据。这是通过&lt;a href=&quot;threads/shared&quot;&gt;thread :: shared&lt;/a&gt;模块和 &lt;code&gt;:shared&lt;/code&gt; 属性完成的：</target>
        </trans-unit>
        <trans-unit id="a04c440174950d35de1ff03f07736720e16d8ea1" translate="yes" xml:space="preserve">
          <source>To make use of threading, however, one usually wants the threads to share at least some data between themselves. This is done with the &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; module and the &lt;code&gt;:shared&lt;/code&gt; attribute:</source>
          <target state="translated">但是，为了利用线程，通常希望线程在它们之间共享至少一些数据。这是通过&lt;a href=&quot;threads::shared&quot;&gt;thread :: shared&lt;/a&gt;模块和 &lt;code&gt;:shared&lt;/code&gt; 属性完成的：</target>
        </trans-unit>
        <trans-unit id="482a24cc09ed210b4be1c7fca66ab517d60e1e62" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;../perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="translated">要将FILEHANDLE标记为UTF-8，请使用 &lt;code&gt;:utf8&lt;/code&gt; 或 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 。 &lt;code&gt;:utf8&lt;/code&gt; 只是将数据标记为UTF-8，而无需进一步检查，而 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 则检查数据是否实际上是有效的UTF-8。更多细节可以在&lt;a href=&quot;../perlio/encoding&quot;&gt;PerlIO :: encoding中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="5274ade94ad24fbd8e1e1d8904bba9bc30f6d6c0" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="translated">要将FILEHANDLE标记为UTF-8，请使用 &lt;code&gt;:utf8&lt;/code&gt; 或 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 。 &lt;code&gt;:utf8&lt;/code&gt; 只是将数据标记为UTF-8，而无需进一步检查，而 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 则检查数据是否实际上是有效的UTF-8。更多细节可以在&lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO :: encoding中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="5abdd218835bb6eb6001f3cd74ea29d6653d76a4" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt;. &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;PerlIO::encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="translated">要将FILEHANDLE标记为UTF-8，请使用 &lt;code&gt;:utf8&lt;/code&gt; 或 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 。 &lt;code&gt;:utf8&lt;/code&gt; 只是将数据标记为UTF-8，而无需进一步检查，而 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 则检查数据是否实际上是有效的UTF-8。更多细节可以在&lt;a href=&quot;PerlIO::encoding&quot;&gt;PerlIO :: encoding中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="b4e2df2dd87486f202e752cbd1bc2453ac926173" translate="yes" xml:space="preserve">
          <source>To minimize the number of sbrk(2)s, malloc() asks for more memory. This field gives the size of the yet unused part, which is sbrk(2)ed, but never touched.</source>
          <target state="translated">为了减少sbrk(2)的数量,malloc()要求获得更多的内存。这个字段给出了尚未使用的部分的大小,这部分是sbrk(2)ed,但从未被触及。</target>
        </trans-unit>
        <trans-unit id="c7e29496ccd957aa4492216e45f2282e137e2591" translate="yes" xml:space="preserve">
          <source>To obtain this, a reference to a hash must be passed</source>
          <target state="translated">为了得到这个信息,必须传递一个对哈希的引用。</target>
        </trans-unit>
        <trans-unit id="76c61aa559d88fae477b92a372d192b3b51d4c5b" translate="yes" xml:space="preserve">
          <source>To open a file without blocking, creating if necessary:</source>
          <target state="translated">要在不阻挡的情况下打开文件,必要时创建。</target>
        </trans-unit>
        <trans-unit id="354facfe42bf4e55b171df83905f745324ebd0c9" translate="yes" xml:space="preserve">
          <source>To open file for appending, create if necessary:</source>
          <target state="translated">要打开文件进行追加,必要时创建。</target>
        </trans-unit>
        <trans-unit id="1702818d3f57a9131b4035ed033f063e2b07cebf" translate="yes" xml:space="preserve">
          <source>To open file for appending, file must exist:</source>
          <target state="translated">要打开文件进行追加,文件必须存在。</target>
        </trans-unit>
        <trans-unit id="4967760590c67e61373186454a8e4a1135dcb6d9" translate="yes" xml:space="preserve">
          <source>To open file for reading:</source>
          <target state="translated">要打开文件进行阅读。</target>
        </trans-unit>
        <trans-unit id="cee1bc0ab3a065feee926895157fb947a422ff0d" translate="yes" xml:space="preserve">
          <source>To open file for update, create file if necessary:</source>
          <target state="translated">要打开文件进行更新,必要时创建文件。</target>
        </trans-unit>
        <trans-unit id="7c8a25c4e2b2e915deaf352a915d4e6583e2f962" translate="yes" xml:space="preserve">
          <source>To open file for update, file must exist:</source>
          <target state="translated">要打开文件进行更新,文件必须存在。</target>
        </trans-unit>
        <trans-unit id="b8d1b7a21cb716decbfe05cd44f437ced848a3ac" translate="yes" xml:space="preserve">
          <source>To open file for update, file must not exist:</source>
          <target state="translated">要打开文件进行更新,文件必须不存在。</target>
        </trans-unit>
        <trans-unit id="e09916f7ec3e12864e36849354a4ebf1fbb19361" translate="yes" xml:space="preserve">
          <source>To open file for writing, create new file if needed or else truncate old file:</source>
          <target state="translated">要打开文件进行写作,如果需要的话,可以创建新的文件,或者截断旧的文件。</target>
        </trans-unit>
        <trans-unit id="290398a666a114bce8d99caa62b27b49c84e4b59" translate="yes" xml:space="preserve">
          <source>To open file for writing, create new file, file must not exist:</source>
          <target state="translated">要打开文件进行写入,需要创建新文件,文件必须不存在。</target>
        </trans-unit>
        <trans-unit id="d996476f79882a20a27ba1e93bb75ca52cdeca1e" translate="yes" xml:space="preserve">
          <source>To open the temporary filehandle with O_EXLOCK (open with exclusive file lock) use &lt;code&gt;EXLOCK=&amp;gt;1&lt;/code&gt;. This is supported only by some operating systems (most notably BSD derived systems). By default EXLOCK will be false. Former &lt;code&gt;File::Temp&lt;/code&gt; versions set EXLOCK to true, so to be sure to get an unlocked filehandle also with older versions, explicitly set &lt;code&gt;EXLOCK=&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">要使用O_EXLOCK打开临时文件句柄（使用独占文件锁打开），请使用 &lt;code&gt;EXLOCK=&amp;gt;1&lt;/code&gt; 。仅某些操作系统（最著名的是BSD派生系统）支持此功能。默认情况下，EXLOCK将为false。以前的 &lt;code&gt;File::Temp&lt;/code&gt; 版本将EXLOCK设置为true，因此，为确保也获得较早版本的未锁定文件句柄，请显式设置 &lt;code&gt;EXLOCK=&amp;gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6007d31a54fba5ebc4520f06ed8627e89a0d4a2c" translate="yes" xml:space="preserve">
          <source>To output UTF-8, use the &lt;code&gt;:encoding&lt;/code&gt; or &lt;code&gt;:utf8&lt;/code&gt; output layer. Prepending</source>
          <target state="translated">要输出UTF-8，请使用 &lt;code&gt;:encoding&lt;/code&gt; 或 &lt;code&gt;:utf8&lt;/code&gt; 输出层。前置</target>
        </trans-unit>
        <trans-unit id="3b36e6dcece917ee92e199616190bf7ab5b56187" translate="yes" xml:space="preserve">
          <source>To overcome this limitation, you need to turn on /s matching within the prefix pattern, using the &lt;code&gt;(?s)&lt;/code&gt; directive: '(?s).*?(?=&amp;lt;H1&amp;gt;)'</source>
          <target state="translated">为了克服此限制，您需要使用 &lt;code&gt;(?s)&lt;/code&gt; 指令在前缀模式中打开/ s匹配：'（？s）。*？（？= &amp;lt;H1&amp;gt;）'</target>
        </trans-unit>
        <trans-unit id="062f2ac749842e1dd1762ff59d78e1eb660fe9b7" translate="yes" xml:space="preserve">
          <source>To override a Perl built-in routine with your own version, you need to import it at compile-time. This can be conveniently achieved with the &lt;code&gt;subs&lt;/code&gt; pragma. This will affect only the package in which you've imported the said subroutine:</source>
          <target state="translated">要用您自己的版本覆盖Perl内置例程，您需要在编译时将其导入。可以通过 &lt;code&gt;subs&lt;/code&gt; pragma 方便地实现。这只会影响您在其中导入了上述子例程的软件包：</target>
        </trans-unit>
        <trans-unit id="1aa3f784c17082d78c7fbfe639d471e8c69f8458" translate="yes" xml:space="preserve">
          <source>To override a built-in globally (that is, in all namespaces), you need to import your function into the &lt;code&gt;CORE::GLOBAL&lt;/code&gt; pseudo-namespace at compile time:</source>
          <target state="translated">要全局覆盖一个内置的（即在所有名称空间中），您需要在编译时将函数导入 &lt;code&gt;CORE::GLOBAL&lt;/code&gt; 伪命名空间：</target>
        </trans-unit>
        <trans-unit id="675c69919880e76e4b55ea1a685db1213f2914e2" translate="yes" xml:space="preserve">
          <source>To override the standard utime():</source>
          <target state="translated">要覆盖标准的utime()。</target>
        </trans-unit>
        <trans-unit id="605fcd402b7e1fdc810b4ff2c0f6a15f906ca915" translate="yes" xml:space="preserve">
          <source>To pack dates stored as triplets ( day, month, year ) in an array &lt;code&gt;@dates&lt;/code&gt; into a sequence of byte, byte, short integer we can write</source>
          <target state="translated">要将存储为三元组（日，月，年）的日期包装在 &lt;code&gt;@dates&lt;/code&gt; 数组中，以字节，字节，短整数序列组成，我们可以编写</target>
        </trans-unit>
        <trans-unit id="1d0cde2eb7df8017d255040c9f5af9796899dd92" translate="yes" xml:space="preserve">
          <source>To parse a string &lt;code&gt;$str&lt;/code&gt; as a floating point number use</source>
          <target state="translated">要将字符串 &lt;code&gt;$str&lt;/code&gt; 解析为浮点数，请使用</target>
        </trans-unit>
        <trans-unit id="61571c195afbee84b0b85796b78595db86b7183b" translate="yes" xml:space="preserve">
          <source>To parse a string &lt;code&gt;$str&lt;/code&gt; as a number in some base &lt;code&gt;$base&lt;/code&gt; use</source>
          <target state="translated">解析字符串 &lt;code&gt;$str&lt;/code&gt; 在一些基数的数字 &lt;code&gt;$base&lt;/code&gt; 使用</target>
        </trans-unit>
        <trans-unit id="8c0b000078df0842ed41dd6cf17b93c225c65646" translate="yes" xml:space="preserve">
          <source>To parse this code, Perl uses a heuristic based on what package names it has seen, what subroutines exist in the current package, what barewords it has previously seen, and other input. Needless to say, heuristics can produce very surprising results!</source>
          <target state="translated">为了解析这段代码,Perl使用了一个启发式的方法,基于它见过的包名、当前包中存在的子程序、之前见过的裸词以及其他输入。不用说,启发式方法可以产生非常惊人的结果!</target>
        </trans-unit>
        <trans-unit id="fbca7774c8df9c1e7fff186e61962bc8047a5ac6" translate="yes" xml:space="preserve">
          <source>To pass an object method into a subroutine, you can do this:</source>
          <target state="translated">要将一个对象方法传入一个子程序,可以这样做。</target>
        </trans-unit>
        <trans-unit id="767a526ac8d0e957a93b83324d4f56d1ac303c9b" translate="yes" xml:space="preserve">
          <source>To pass in &lt;code&gt;NULL&lt;/code&gt; as the pointer to an optional buffer, pass in an empty list reference, &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">要传递 &lt;code&gt;NULL&lt;/code&gt; 作为指向可选缓冲区的指针，请传递一个空列表引用 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="249caf0f11ba46a1737a888a2cd12f841c024b93" translate="yes" xml:space="preserve">
          <source>To pass supplemental arguments to a program opened with &lt;code&gt; '|-' &lt;/code&gt; or &lt;code&gt; '-|' &lt;/code&gt; append them to the command string as you would system EXPR.</source>
          <target state="translated">将补充参数传递给以 &lt;code&gt; '|-' &lt;/code&gt; 或 &lt;code&gt; '-|' &lt;/code&gt; 打开的程序 将它们附加到命令字符串，就像系统EXPR一样。</target>
        </trans-unit>
        <trans-unit id="9bb3f23b2e2cd47ffa049a4b5b8e3297a48bd649" translate="yes" xml:space="preserve">
          <source>To prepare distribution you need to do following:</source>
          <target state="translated">要准备分发,您需要做以下工作。</target>
        </trans-unit>
        <trans-unit id="47e04bab26a33f27d49843c62d8c3b7400695e70" translate="yes" xml:space="preserve">
          <source>To prepend lines to the beginning, print those lines before you enter the loop that prints the existing lines.</source>
          <target state="translated">要在行前添加行,请在进入打印现有行的循环之前打印这些行。</target>
        </trans-unit>
        <trans-unit id="453d8a60ef1b8720b3eb21b0a6becefda886f512" translate="yes" xml:space="preserve">
          <source>To prevent &amp;lt;extract_quotelike&amp;gt; from mucking about with the input in this way (this is the only case where a list-context &lt;code&gt;extract_quotelike&lt;/code&gt; does so), you can pass the input variable as an interpolated literal:</source>
          <target state="translated">为防止&amp;lt;extract_quotelike&amp;gt;以此方式与输入混为一谈（这是列表上下文 &lt;code&gt;extract_quotelike&lt;/code&gt; 这样做的唯一情况），可以将输入变量作为内插文字传递：</target>
        </trans-unit>
        <trans-unit id="743105860f25b02f06770315902de6783c423895" translate="yes" xml:space="preserve">
          <source>To prevent &lt;code&gt;memoize&lt;/code&gt; from installing the memoized version anywhere, use &lt;code&gt;INSTALL =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">为了防止 &lt;code&gt;memoize&lt;/code&gt; 的任何地方安装memoized版本，使用 &lt;code&gt;INSTALL =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0ceea23486fb8fa0dd3f37c46296eb6503b2487" translate="yes" xml:space="preserve">
          <source>To prevent &lt;code&gt;memoize&lt;/code&gt; from installing the memoized version anywhere, use &lt;code&gt;INSTALL =&amp;gt; undef&lt;/code&gt;.</source>
          <target state="translated">为了防止 &lt;code&gt;memoize&lt;/code&gt; 的任何地方安装memoized版本，使用 &lt;code&gt;INSTALL =&amp;gt; undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9de321857a95078722502ca43a0201a5f6a4b12" translate="yes" xml:space="preserve">
          <source>To prevent any ambiguity,</source>
          <target state="translated">为了防止任何歧义。</target>
        </trans-unit>
        <trans-unit id="fb87adecfac8f5df4ab3fe938fde55af46ebf1a3" translate="yes" xml:space="preserve">
          <source>To prevent specific methods from being called in bracket notation, use the blacklist() method:</source>
          <target state="translated">为了防止特定的方法被括号符号调用,使用黑名单()方法。</target>
        </trans-unit>
        <trans-unit id="7d04ca12ba631be1e6e856ee05396b933016cf93" translate="yes" xml:space="preserve">
          <source>To prevent the &lt;code&gt;qv()&lt;/code&gt; function from being exported to the caller's namespace, either use version with a null parameter:</source>
          <target state="translated">为了防止将 &lt;code&gt;qv()&lt;/code&gt; 函数导出到调用者的名称空间，请使用带有null参数的version：</target>
        </trans-unit>
        <trans-unit id="ac0fc603c0e20ee050f6b1167e08040f2086e70a" translate="yes" xml:space="preserve">
          <source>To prevent the contents of a queue from being modified by another thread while it is being examined and/or changed, &lt;a href=&quot;../threads/shared#lock-VARIABLE&quot;&gt;lock&lt;/a&gt; the queue inside a local block:</source>
          <target state="translated">为了防止队列的内容在检查和/或更改时被另一个线程修改，请将队列&lt;a href=&quot;../threads/shared#lock-VARIABLE&quot;&gt;锁定&lt;/a&gt;在本地块内：</target>
        </trans-unit>
        <trans-unit id="b8427301b03347200dffe8c8bd3a067e2726323d" translate="yes" xml:space="preserve">
          <source>To prevent the contents of a queue from being modified by another thread while it is being examined and/or changed, &lt;a href=&quot;threads::shared#lock-VARIABLE&quot;&gt;lock&lt;/a&gt; the queue inside a local block:</source>
          <target state="translated">为了防止队列的内容在检查和/或更改时被另一个线程修改，请将队列&lt;a href=&quot;threads::shared#lock-VARIABLE&quot;&gt;锁定&lt;/a&gt;在本地块内：</target>
        </trans-unit>
        <trans-unit id="521d225cb8b8267bdc9221af420cb3102374b4c5" translate="yes" xml:space="preserve">
          <source>To prevent this, supply a &lt;code&gt;NORMALIZER&lt;/code&gt; function that turns the program arguments into a string in a way that equivalent arguments turn into the same string. A &lt;code&gt;NORMALIZER&lt;/code&gt; function for &lt;code&gt;f&lt;/code&gt; above might look like this:</source>
          <target state="translated">为避免这种情况，请提供 &lt;code&gt;NORMALIZER&lt;/code&gt; 函数，该函数将程序参数转换为字符串，而等效参数转换为相同字符串。上面 &lt;code&gt;f&lt;/code&gt; 的 &lt;code&gt;NORMALIZER&lt;/code&gt; 函数可能看起来像这样：</target>
        </trans-unit>
        <trans-unit id="6fa84f786f1f2e361ba53d7582050f707e69605c" translate="yes" xml:space="preserve">
          <source>To produce a perl binary with a different name than &lt;code&gt;perl&lt;/code&gt; , either say</source>
          <target state="translated">要产生一个与 &lt;code&gt;perl&lt;/code&gt; 名称不同的perl二进制文件，可以说</target>
        </trans-unit>
        <trans-unit id="76b5e8be4f2c5ad1ba3d72bdd1d3c182b64412ef" translate="yes" xml:space="preserve">
          <source>To produce a perl binary with a different name than &lt;code&gt;perl&lt;/code&gt;, either say</source>
          <target state="translated">要产生一个与 &lt;code&gt;perl&lt;/code&gt; 名称不同的perl二进制文件，可以说</target>
        </trans-unit>
        <trans-unit id="deeb5ed64d8b8726d03c2a35d8b9a4f9932501dd" translate="yes" xml:space="preserve">
          <source>To prove success on the host machine, run &quot;dumpbin /headers wince-arm-pocket-wce400\perl.exe&quot; from the win32/ folder and look for &quot;machine (ARM)&quot; in the FILE HEADER VALUES and &quot;subsystem (Windows CE GUI)&quot; in the OPTIONAL HEADER VALUES.</source>
          <target state="translated">为了证明在主机上的成功,从win32/文件夹中运行 &quot;dumpbin /headers wince-arm-pocket-wce400/perl.exe&quot;,并在FILE HEADER VALUES中查找 &quot;机器(ARM)&quot;,在OPTIONAL HEADER VALUES中查找 &quot;子系统(Windows CE GUI)&quot;。</target>
        </trans-unit>
        <trans-unit id="e3f95db7629c92dc13df17dee2376ecae6bd28b4" translate="yes" xml:space="preserve">
          <source>To provide a Perl interface to this library we need to be able to map between the &lt;code&gt;fh&lt;/code&gt; parameter and the Perl subroutine we want called. A hash is a convenient mechanism for storing this mapping. The code below shows a possible implementation</source>
          <target state="translated">为了向该库提供Perl接口，我们需要能够在 &lt;code&gt;fh&lt;/code&gt; 参数和我们要调用的Perl子例程之间进行映射。哈希是用于存储此映射的便捷机制。下面的代码显示了可能的实现</target>
        </trans-unit>
        <trans-unit id="56afd5e1c9ab39b7d24b6a35fc7523124fb4a154" translate="yes" xml:space="preserve">
          <source>To provide an example, let's say the popular &lt;code&gt;Foo::Bar::escape_html&lt;/code&gt; function doesn't deal with Unicode data yet. The wrapper function would convert the argument to raw UTF-8 and convert the result back to Perl's internal representation like so:</source>
          <target state="translated">举个例子，假设流行的 &lt;code&gt;Foo::Bar::escape_html&lt;/code&gt; 函数尚未处理Unicode数据。包装函数会将参数转换为原始UTF-8，然后将结果转换回Perl的内部表示形式，如下所示：</target>
        </trans-unit>
        <trans-unit id="67eb0c577eae9b827927188aaf0fb3c3cf029b5e" translate="yes" xml:space="preserve">
          <source>To provide backward compatibility with the previous version of &lt;a href=&quot;Net::Ping&quot;&gt;Net::Ping&lt;/a&gt;, a &lt;code&gt;pingecho()&lt;/code&gt; subroutine is available with the same functionality as before. &lt;code&gt;pingecho()&lt;/code&gt; uses the tcp protocol. The return values and parameters are the same as described for the &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method. This subroutine is obsolete and may be removed in a future version of &lt;a href=&quot;Net::Ping&quot;&gt;Net::Ping&lt;/a&gt;.</source>
          <target state="translated">为了提供与&lt;a href=&quot;Net::Ping&quot;&gt;Net :: Ping&lt;/a&gt;先前版本的向后兼容性，可以使用 &lt;code&gt;pingecho()&lt;/code&gt; 子例程，该例程具有与以前相同的功能。 &lt;code&gt;pingecho()&lt;/code&gt; 使用tcp协议。返回值和参数与&lt;a href=&quot;#ping&quot;&gt;&amp;ldquo; ping&amp;rdquo;&lt;/a&gt;方法中描述的相同。该子例程已过时，可以在以后的&lt;a href=&quot;Net::Ping&quot;&gt;Net :: Ping&lt;/a&gt;版本中删除。</target>
        </trans-unit>
        <trans-unit id="fe539191c8112058d164cdbdc07c4a313e2ceb71" translate="yes" xml:space="preserve">
          <source>To provide backward compatibility with the previous version of Net::Ping, a pingecho() subroutine is available with the same functionality as before. pingecho() uses the tcp protocol. The return values and parameters are the same as described for the ping() method. This subroutine is obsolete and may be removed in a future version of Net::Ping.</source>
          <target state="translated">为了向后兼容以前版本的 Net::Ping,我们提供了一个 pingecho()子程序,它的功能与以前的相同。 pingecho()使用 tcp 协议。返回值和参数与ping()方法的描述相同。这个子例程已经过时了,可能会在 Net::Ping 的未来版本中被删除。</target>
        </trans-unit>
        <trans-unit id="ece610257b3402f7eea4d17dbc76eda55d9cbb02" translate="yes" xml:space="preserve">
          <source>To provide the capability to set/get class-wide settings, it is best instead to provide accessors as subroutines or class methods instead.</source>
          <target state="translated">为了提供设置/获取全类设置的功能,最好是以子程序或类方法的形式提供访问器。</target>
        </trans-unit>
        <trans-unit id="c22d13aed3a39a35ea13dd4bc32c2e899b497afb" translate="yes" xml:space="preserve">
          <source>To purchase this book, visit &lt;a href=&quot;http://oreilly.com/catalog/9780596514471/&quot;&gt;http://oreilly.com/catalog/9780596514471/&lt;/a&gt; or your favourite bookstore.</source>
          <target state="translated">要购买此书，请访问&lt;a href=&quot;http://oreilly.com/catalog/9780596514471/&quot;&gt;http://oreilly.com/catalog/9780596514471/&lt;/a&gt;或您最喜欢的书店。</target>
        </trans-unit>
        <trans-unit id="29ea3ee26188231fd563bb14e2dd6e7f583ebf9d" translate="yes" xml:space="preserve">
          <source>To purchase this book, visit &lt;a href=&quot;https://oreilly.com/catalog/9780596514471/&quot;&gt;http://oreilly.com/catalog/9780596514471/&lt;/a&gt; or your favourite bookstore.</source>
          <target state="translated">要购买此书，请访问&lt;a href=&quot;https://oreilly.com/catalog/9780596514471/&quot;&gt;http://oreilly.com/catalog/9780596514471/&lt;/a&gt;或您最喜欢的书店。</target>
        </trans-unit>
        <trans-unit id="b8ad3c75e2a9658073e3c75677575371b7b2154a" translate="yes" xml:space="preserve">
          <source>To put the output from any parse method into a string instead of a file handle, call the output_string() method instead of output_fh().</source>
          <target state="translated">要把任何解析方法的输出放到一个字符串而不是文件句柄中,调用output_string()方法而不是output_fh()。</target>
        </trans-unit>
        <trans-unit id="8d3d8f79e5bb23da5237f2bc4f067b582af08744" translate="yes" xml:space="preserve">
          <source>To quickly check the type of a &lt;code&gt;Archive::Tar::File&lt;/code&gt; object, you can use the following methods:</source>
          <target state="translated">要快速检查 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 对象的类型，可以使用以下方法：</target>
        </trans-unit>
        <trans-unit id="ffb74a402d25037ed756434b89268f8c6c0f487e" translate="yes" xml:space="preserve">
          <source>To quote the bzip2 documentation</source>
          <target state="translated">引用bzip2的文档</target>
        </trans-unit>
        <trans-unit id="2e030dd198e6e120e9f1df9a82e7575806595a2d" translate="yes" xml:space="preserve">
          <source>To read an entire &lt;b&gt;file&lt;/b&gt; into a &lt;b&gt;string&lt;/b&gt; in one operation.</source>
          <target state="translated">通过一次操作将整个&lt;b&gt;文件&lt;/b&gt;读入&lt;b&gt;字符串&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d6676802f298dda33ea89ee297e7a4c3b7e4e2ac" translate="yes" xml:space="preserve">
          <source>To read both a command's STDOUT and its STDERR separately, it's easiest to redirect them separately to files, and then read from those files when the program is done:</source>
          <target state="translated">如果要分别读取一个命令的STDOUT和它的STDERR,最简单的办法是将它们分别重定向到文件中,等程序完成后再从这些文件中读取。</target>
        </trans-unit>
        <trans-unit id="441b0a3f043e9d675f24f50e1a3845049a78b701" translate="yes" xml:space="preserve">
          <source>To read both a command's STDOUT and its STDERR separately, you can redirect them to temp files, let the command run, then read the temp files:</source>
          <target state="translated">要分别读取一个命令的STDOUT和它的STDERR,可以将它们重定向到临时文件,让命令运行,然后读取临时文件。</target>
        </trans-unit>
        <trans-unit id="5540d6192acd70f39a8ef597e449669bc8ae5ddb" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt; , and write the compressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">要从现有的Perl文件句柄 &lt;code&gt;$input&lt;/code&gt; 读取，并将压缩后的数据写入缓冲区 &lt;code&gt;$buffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c349b729382da049ab850b286913e925d6fe3968" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt; , and write the uncompressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">要从现有的Perl文件句柄 &lt;code&gt;$input&lt;/code&gt; 读取，并将未压缩的数据写入缓冲区 &lt;code&gt;$buffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b6c4a10d71392deb29372c2a92475955d692a6e" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt;, and write the compressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt;.</source>
          <target state="translated">要从现有的Perl文件句柄 &lt;code&gt;$input&lt;/code&gt; 读取，并将压缩后的数据写入缓冲区 &lt;code&gt;$buffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e4ba76e5ff4a01f16e01bd7d5a780beec6519c3" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt;, and write the uncompressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt;.</source>
          <target state="translated">要从现有的Perl文件句柄 &lt;code&gt;$input&lt;/code&gt; 读取，并将未压缩的数据写入缓冲区 &lt;code&gt;$buffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7482ebcf137b958140c12465f2671a82fcf986b9" translate="yes" xml:space="preserve">
          <source>To read the</source>
          <target state="translated">阅读</target>
        </trans-unit>
        <trans-unit id="87df4beb52a8613330401231fb10bf4839a044e4" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1950&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.1950&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcdf55eeb6470c2b3d7fd6cf75243e9a7e9d3240" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1950&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.1950&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="5f3af95cfb979c68a078d4244b348eca50284cce" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1951&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.1951&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="4698f091bc1fdd774cb393f877e7282bc2a1c3c5" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1951&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.1951&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="fe87604cf51141fe67b4d7c05185428541881932" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.Compressed&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.Compressed&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f301dbf129331d08eb2d42bb04443bcca2c06d9c" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.Compressed&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.Compressed&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcd74724ed743479732074df76791b8e4375f0ba" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.bz2&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="263ebe5d94b7d39489ca2895d917dbacbfcc41fc" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.bz2&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0224a4a1040095275155b56f5f7207fca1c2ad1" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.gz&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.gz&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="328756a43a9eee1db660f9353e2936fa148261c1" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.gz&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt.gz&lt;/code&gt; 的内容并将未压缩的数据写入文件 &lt;code&gt;file1.txt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62b61bd1daa8a6cb2d7eb96d3ece7209a79b5aec" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1950&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.1950&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58f6252b156248cb5d164937a716b657f41d643b" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1950&lt;/code&gt;.</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.1950&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e429b7a25235b582c4b383620392f1a750a3bdd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1951&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.1951&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fef40be75516f086b04d71827ac5f116bf2718cd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1951&lt;/code&gt;.</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.1951&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c406d8acaac2a742d676187babe70fbc63a189bd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.bz2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33aeb771cd352fb39ce6d9be074532d17039ae52" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.bz2&lt;/code&gt;.</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.bz2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa350228ff2721777414a685ddb5c4e3af10826c" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.gz&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.gz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a2635502bb2923dab4d82f7333e4b41da9484a4" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.gz&lt;/code&gt;.</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.gz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1253348a31fd66554a6efd5d56c0e22a2ff1b137" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.zip&lt;/code&gt; .</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.zip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae6686db2a7eebd5b91805c9b0d9008be2e94d9e" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.zip&lt;/code&gt;.</source>
          <target state="translated">读取文件 &lt;code&gt;file1.txt&lt;/code&gt; 的内容并将压缩数据写入文件 &lt;code&gt;file1.txt.zip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cb0378e48901dddc588a6225fe4a4196884f056" translate="yes" xml:space="preserve">
          <source>To really poke around with Perl, you'll probably want to build Perl for debugging, like this:</source>
          <target state="translated">如果要真正的摸索Perl,你可能会想要构建Perl来进行调试,就像这样。</target>
        </trans-unit>
        <trans-unit id="224b47d42836cf02b0538bc7324878629aa47a30" translate="yes" xml:space="preserve">
          <source>To receive an announcement whenever a new version of this module is released, send a blank email message to &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt; .</source>
          <target state="translated">要在该模块的新版本发布时收到公告，请将空白电子邮件发送到 &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9c2c718f1481d7a23bdb92c3c65c5d23a83c26f" translate="yes" xml:space="preserve">
          <source>To receive an announcement whenever a new version of this module is released, send a blank email message to &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt;.</source>
          <target state="translated">要在该模块的新版本发布时收到公告，请将空白电子邮件发送到 &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59bd9384e894fc19ae43b0a3a96f9c688fce9ba8" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;a href=&quot;File::Path#make_path%28-%24dir1%2C-%24dir2%2C-....-%29&quot;&gt;&lt;code&gt;make_path&lt;/code&gt;&lt;/a&gt; function of the &lt;a href=&quot;File::Path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">要递归创建目录结构，请查看&lt;a href=&quot;File::Path&quot;&gt;File :: Path&lt;/a&gt;模块的&lt;a href=&quot;File::Path#make_path%28-%24dir1%2C-%24dir2%2C-....-%29&quot;&gt; &lt;code&gt;make_path&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="d3e33fd8f77a0950334d95b2b753813796d2bf20" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;code&gt;make_path&lt;/code&gt; function of the &lt;a href=&quot;../file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">要递归创建目录结构，请查看&lt;a href=&quot;../file/path&quot;&gt;File :: Path&lt;/a&gt;模块的 &lt;code&gt;make_path&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="d93ce0279ba5e733f28599be83e53944021fc924" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;code&gt;make_path&lt;/code&gt; function of the &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">要递归创建目录结构，请查看&lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt;模块的 &lt;code&gt;make_path&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="b5946d1b5adc8bf79e8d8691892a42663cd834d2" translate="yes" xml:space="preserve">
          <source>To reduce the overhead as much as possible, only one possible location is checked to find the extension DLL (this location is where &lt;code&gt;make install&lt;/code&gt; would put the DLL). If not found, the search for the DLL is transparently delegated to &lt;code&gt;DynaLoader&lt;/code&gt; , which looks for the DLL along the &lt;code&gt;@INC&lt;/code&gt; list.</source>
          <target state="translated">为了尽可能减少开销，仅检查一个可能的位置以找到扩展DLL（此位置是 &lt;code&gt;make install&lt;/code&gt; 放置DLL的位置）。如果未找到，则将对DLL的搜索透明地委派给 &lt;code&gt;DynaLoader&lt;/code&gt; ，后者沿 &lt;code&gt;@INC&lt;/code&gt; 列表查找DLL 。</target>
        </trans-unit>
        <trans-unit id="2a76f398b95d1961552e49490d4d377316e986e8" translate="yes" xml:space="preserve">
          <source>To reduce the overhead as much as possible, only one possible location is checked to find the extension DLL (this location is where &lt;code&gt;make install&lt;/code&gt; would put the DLL). If not found, the search for the DLL is transparently delegated to &lt;code&gt;DynaLoader&lt;/code&gt;, which looks for the DLL along the &lt;code&gt;@INC&lt;/code&gt; list.</source>
          <target state="translated">为了尽可能减少开销，仅检查一个可能的位置以找到扩展DLL（此位置是 &lt;code&gt;make install&lt;/code&gt; 放置DLL的位置）。如果未找到，则将对DLL的搜索透明地委派给 &lt;code&gt;DynaLoader&lt;/code&gt; ，后者沿 &lt;code&gt;@INC&lt;/code&gt; 列表查找DLL 。</target>
        </trans-unit>
        <trans-unit id="66c3094c723d121eb0bf078e8289c66d4fdd4a9a" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;a href=&quot;File::Path#rmtree%28-%24dir-%29&quot;&gt;&lt;code&gt;rmtree&lt;/code&gt;&lt;/a&gt; function of the &lt;a href=&quot;File::Path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">要递归删除目录树（在Unix上为 &lt;code&gt;rm -rf&lt;/code&gt; ），请&lt;a href=&quot;File::Path&quot;&gt;查看File :: Path&lt;/a&gt;模块的&lt;a href=&quot;File::Path#rmtree%28-%24dir-%29&quot;&gt; &lt;code&gt;rmtree&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="98bed95392f2bd5c21b8012e731bec1f2530889e" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;code&gt;rmtree&lt;/code&gt; function of the &lt;a href=&quot;../file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">要递归删除目录树（在Unix上为 &lt;code&gt;rm -rf&lt;/code&gt; ），请&lt;a href=&quot;../file/path&quot;&gt;查看File :: Path&lt;/a&gt;模块的 &lt;code&gt;rmtree&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="4e5b819764f7105a80a7d510f2a867ba675bddec" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;code&gt;rmtree&lt;/code&gt; function of the &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">要递归删除目录树（在Unix上为 &lt;code&gt;rm -rf&lt;/code&gt; ），请&lt;a href=&quot;file/path&quot;&gt;查看File :: Path&lt;/a&gt;模块的 &lt;code&gt;rmtree&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="e56141f1ebe96f14282b26d571378c274b2244ed" translate="yes" xml:space="preserve">
          <source>To remove a tied environment variable from the environment, assign it the undefined value</source>
          <target state="translated">要从环境中删除一个绑定的环境变量,请给它分配一个未定义的值。</target>
        </trans-unit>
        <trans-unit id="06b0ac63c637336d9c539fb315b8373179470836" translate="yes" xml:space="preserve">
          <source>To remove creation of the tied hash on each access, one may an extra level of indirection which allows a non-circular structure of references:</source>
          <target state="translated">为了消除在每次访问时创建绑定哈希,可以增加一个额外的间接层次,允许引用的非循环结构。</target>
        </trans-unit>
        <trans-unit id="385dafb73da7d1789642356fd78d8d3446310a3d" translate="yes" xml:space="preserve">
          <source>To remove the magic from an SV, call the function sv_unmagic:</source>
          <target state="translated">要删除SV中的魔法,调用函数sv_unmagic。</target>
        </trans-unit>
        <trans-unit id="1244516061f404f040587b4bb0bc9e4acce762e7" translate="yes" xml:space="preserve">
          <source>To replace any of these components I call one of these harness methods with the name of the replacement class:</source>
          <target state="translated">为了替换这些组件中的任何一个,我用替换类的名称来调用其中的一个驾驭方法。</target>
        </trans-unit>
        <trans-unit id="ee81225f636096e269a365626b3e0c2212110758" translate="yes" xml:space="preserve">
          <source>To report a new bug, visit:</source>
          <target state="translated">要报告一个新的错误,请访问。</target>
        </trans-unit>
        <trans-unit id="e2d5ab4989d41c738d1504f8f7e7186c29958e2b" translate="yes" xml:space="preserve">
          <source>To reset your working directory to a pristine condition you can do:</source>
          <target state="translated">要重置你的工作目录到原始状态,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="935323786b12419a7345fc07129055605bd12b91" translate="yes" xml:space="preserve">
          <source>To retrieve data stored to disk, use &lt;code&gt;retrieve&lt;/code&gt; with a file name. The objects stored into that file are recreated into memory for you, and a</source>
          <target state="translated">要检索存储到磁盘的数据，请使用带有文件名的 &lt;code&gt;retrieve&lt;/code&gt; 。存储在该文件中的对象将为您重新创建到内存中，并且</target>
        </trans-unit>
        <trans-unit id="7f6b972558cf783871ca862e09f183ae72cbdc43" translate="yes" xml:space="preserve">
          <source>To retrieve the &lt;code&gt;REGEXP&lt;/code&gt; object from the scalar in an XS function use the &lt;code&gt;SvRX&lt;/code&gt; macro, see &lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;&quot;REGEXP Functions&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">要使用XS函数从标量中检索 &lt;code&gt;REGEXP&lt;/code&gt; 对象，请使用 &lt;code&gt;SvRX&lt;/code&gt; 宏，请参见perlapi中的&lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;&amp;ldquo; REGEXP函数&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f95fbea27e1a9b8ba09786147eb856c1d1f83f4" translate="yes" xml:space="preserve">
          <source>To retrieve the &lt;code&gt;REGEXP&lt;/code&gt; object from the scalar in an XS function use the &lt;code&gt;SvRX&lt;/code&gt; macro, see &lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;REGEXP Functions in perlapi&lt;/a&gt;.</source>
          <target state="translated">要使用XS函数从标量中检索 &lt;code&gt;REGEXP&lt;/code&gt; 对象，请使用 &lt;code&gt;SvRX&lt;/code&gt; 宏，请参见&lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;perlapi中的REGEXP函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1231633ff6452d875f890a43a2ae8ede0790e949" translate="yes" xml:space="preserve">
          <source>To return an empty list one must use a PPCODE: block and then not push return values on the stack.</source>
          <target state="translated">要返回一个空列表,必须使用PPCODE:块,然后不在栈上推送返回值。</target>
        </trans-unit>
        <trans-unit id="c0fa2ebc492606f9abfba27c95d0995af195e45c" translate="yes" xml:space="preserve">
          <source>To run Perl on DPMI platforms one needs RSX runtime. This is needed under DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT (see &lt;a href=&quot;#Other-OSes&quot;&gt;&quot;Other OSes&quot;&lt;/a&gt;). RSX would not work with VCPI only, as EMX would, it requires DMPI.</source>
          <target state="translated">要在DPMI平台上运行Perl，需要RSX运行时。在DOS-inside-OS / 2，Win0.3 *，Win0.95和WinNT下，这是必需的（请参阅&lt;a href=&quot;#Other-OSes&quot;&gt;&amp;ldquo;其他操作系统&amp;rdquo;&lt;/a&gt;）。RSX不能像EMX那样仅与VCPI一起使用，它需要DMPI。</target>
        </trans-unit>
        <trans-unit id="c52a15c8b572dc0999ddd7a3d452b4f9cfbf130a" translate="yes" xml:space="preserve">
          <source>To run Perl on DPMI platforms one needs RSX runtime. This is needed under DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT (see &lt;a href=&quot;#Other-OSes&quot;&gt;Other OSes&lt;/a&gt;). RSX would not work with VCPI only, as EMX would, it requires DMPI.</source>
          <target state="translated">要在DPMI平台上运行Perl，需要RSX运行时。在DOS-inside-OS / 2，Win0.3 *，Win0.95和WinNT下，这是必需的（请参阅&lt;a href=&quot;#Other-OSes&quot;&gt;其他操作系统&lt;/a&gt;）。RSX不能像EMX一样仅与VCPI一起使用，它需要DMPI。</target>
        </trans-unit>
        <trans-unit id="f4988afc10b11011c01fd1dc8e2d9efa2ca35527" translate="yes" xml:space="preserve">
          <source>To run a &lt;b&gt;program&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt;. (Has nothing to do with the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; built-in, unless you&amp;rsquo;re trying to run a &lt;b&gt;signal handler&lt;/b&gt;.)</source>
          <target state="translated">运行&lt;b&gt;程序&lt;/b&gt;或&lt;b&gt;子程序&lt;/b&gt;。（除非您试图运行&lt;b&gt;信号处理程序&lt;/b&gt;，否则它与内置的 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 无关）。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97a854ddf9aaf9c69e7b95eed2386df587b2d5c0" translate="yes" xml:space="preserve">
          <source>To run a &lt;b&gt;program&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt;. (Has nothing to do with the &lt;code&gt;kill&lt;/code&gt; built-in, unless you&amp;rsquo;re trying to run a &lt;b&gt;signal handler&lt;/b&gt;.)</source>
          <target state="translated">运行&lt;b&gt;程序&lt;/b&gt;或&lt;b&gt;子程序&lt;/b&gt;。（与内置的 &lt;code&gt;kill&lt;/code&gt; 无关，除非您尝试运行&lt;b&gt;信号处理程序&lt;/b&gt;。）</target>
        </trans-unit>
        <trans-unit id="8cf4ac8bbb41685c2ce7804ccdb1791a6e3ce985" translate="yes" xml:space="preserve">
          <source>To run a Perl program from the Unix command line:</source>
          <target state="translated">从Unix命令行运行Perl程序。</target>
        </trans-unit>
        <trans-unit id="69d193d311b7fdb3c43e19bb64a6bebcfed27d39" translate="yes" xml:space="preserve">
          <source>To run this code, &lt;code&gt;perl_run&lt;/code&gt; is called, which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; then enters a runops loop. This loop executes the eval and tie ops on line 1, with the eval pushing a &lt;code&gt;CxEVAL&lt;/code&gt; onto the context stack.</source>
          <target state="translated">要运行此代码，将调用 &lt;code&gt;perl_run&lt;/code&gt; ，它执行 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; ,然后进入runops循环。此循环在第1行执行eval并绑定操作，而eval将 &lt;code&gt;CxEVAL&lt;/code&gt; 推入上下文堆栈。</target>
        </trans-unit>
        <trans-unit id="46ec5458708076d609a6883cd1bd780e161cc64e" translate="yes" xml:space="preserve">
          <source>To say the least, surrogate pairs were the biggest mistake of the Unicode Consortium. But according to the late Douglas Adams in</source>
          <target state="translated">至少可以说,代用对是Unicode联盟最大的错误。但根据已故的道格拉斯-亚当斯(Douglas Adams)在</target>
        </trans-unit>
        <trans-unit id="48af12ca119bf709d476507ec2e3aea7bdcd0d97" translate="yes" xml:space="preserve">
          <source>To search the perlfaq question headings:</source>
          <target state="translated">要搜索perlfaq问题标题。</target>
        </trans-unit>
        <trans-unit id="518862144f077b9ba7e98c4f411c046f6e96affb" translate="yes" xml:space="preserve">
          <source>To see all about your machine, type</source>
          <target state="translated">要查看您的机器的所有信息,请输入</target>
        </trans-unit>
        <trans-unit id="5d0d28f6946dedb31c299d2d78aa9802594a8195" translate="yes" xml:space="preserve">
          <source>To see how (un)packing works, we'll start with a simple template code where the conversion is in low gear: between the contents of a byte sequence and a string of hexadecimal digits. Let's use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, since this is likely to remind you of a dump program, or some desperate last message unfortunate programs are wont to throw at you before they expire into the wild blue yonder. Assuming that the variable &lt;code&gt;$mem&lt;/code&gt; holds a sequence of bytes that we'd like to inspect without assuming anything about its meaning, we can write</source>
          <target state="translated">为了了解打包的工作方式，我们将以一个简单的模板代码开始，该模板的转换速度很慢：在字节序列的内容和一串十六进制数字之间。让我们使用 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ，因为这很可能使您想起一个转储程序，或者一些绝望的最后消息，不幸的程序在它们变成荒野的蓝色边缘之前不会扔给您。假设变量 &lt;code&gt;$mem&lt;/code&gt; 保留了我们要检查的字节序列，而没有对其含义作任何假设，我们可以编写</target>
        </trans-unit>
        <trans-unit id="02e337f8ffa5587c60ddae1e61c27bc0cb20b9a1" translate="yes" xml:space="preserve">
          <source>To see how (un)packing works, we'll start with a simple template code where the conversion is in low gear: between the contents of a byte sequence and a string of hexadecimal digits. Let's use &lt;code&gt;unpack&lt;/code&gt;, since this is likely to remind you of a dump program, or some desperate last message unfortunate programs are wont to throw at you before they expire into the wild blue yonder. Assuming that the variable &lt;code&gt;$mem&lt;/code&gt; holds a sequence of bytes that we'd like to inspect without assuming anything about its meaning, we can write</source>
          <target state="translated">为了了解打包的工作方式，我们将从一个简单的模板代码开始，其中的转换是低速的：在字节序列的内容和十六进制数字字符串之间。让我们使用 &lt;code&gt;unpack&lt;/code&gt; ，因为这很可能使您想起一个转储程序，或者一些绝望的最后消息，不幸的程序在它们变成荒野的蓝色边缘之前不会扔给您。假设变量 &lt;code&gt;$mem&lt;/code&gt; 保留了我们要检查的字节序列，而没有对其含义进行任何假设，我们可以编写</target>
        </trans-unit>
        <trans-unit id="526ccfeab3729429cc060187cce1bbaba5ac3037" translate="yes" xml:space="preserve">
          <source>To see how this affects &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, we'll compare these two C structures:</source>
          <target state="translated">要查看这如何影响 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ，我们将比较这两个C结构：</target>
        </trans-unit>
        <trans-unit id="9053b5511eec27497eeb92618a57db0e9ef4499d" translate="yes" xml:space="preserve">
          <source>To see how this affects &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt;, we'll compare these two C structures:</source>
          <target state="translated">要查看这如何影响 &lt;code&gt;pack&lt;/code&gt; 和 &lt;code&gt;unpack&lt;/code&gt; ，我们将比较这两个C结构：</target>
        </trans-unit>
        <trans-unit id="f4c245de21e3816d09a578f5e1c5f63c7d4c6210" translate="yes" xml:space="preserve">
          <source>To see if a variable contains a reference, use the &lt;a href=&quot;perlfunc#ref-EXPR&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; function. It returns true if its argument is a reference. Actually it's a little better than that: It returns &lt;code&gt;HASH&lt;/code&gt; for hash references and &lt;code&gt;ARRAY&lt;/code&gt; for array references.</source>
          <target state="translated">要查看变量是否包含引用，请使用&lt;a href=&quot;perlfunc#ref-EXPR&quot;&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt;函数。如果其参数是引用，则返回true。实际上，它比这要好一些：它为哈希引用返回 &lt;code&gt;HASH&lt;/code&gt; ，为数组引用返回 &lt;code&gt;ARRAY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99fa402c0f19d397a266c609792e7a721baa908f" translate="yes" xml:space="preserve">
          <source>To see if a variable contains a reference, use the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function. It returns true if its argument is a reference. Actually it's a little better than that: It returns &lt;code&gt;HASH&lt;/code&gt; for hash references and &lt;code&gt;ARRAY&lt;/code&gt; for array references.</source>
          <target state="translated">要查看变量是否包含引用，请使用 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 函数。如果其参数是引用，则返回true。实际上，它比这要好一些：它为哈希引用返回 &lt;code&gt;HASH&lt;/code&gt; ，为数组引用返回 &lt;code&gt;ARRAY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="960bf2c563408fba71fe24086af2e53cbf0767bd" translate="yes" xml:space="preserve">
          <source>To see if your system is affected by this discrepancy check if &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; -q NPTL&lt;/code&gt; returns a false value. NTPL threads preserve the POSIX semantics.</source>
          <target state="translated">要查看您的系统是否受此差异影响，请检查 &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; -q NPTL&lt;/code&gt; 返回一个假值。NTPL线程保留POSIX语义。</target>
        </trans-unit>
        <trans-unit id="6370b1130305216b6c4037876a31e89ca9fbcd86" translate="yes" xml:space="preserve">
          <source>To see if your system is affected by this discrepancy check if &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | grep -q NPTL&lt;/code&gt; returns a false value. NTPL threads preserve the POSIX semantics.</source>
          <target state="translated">要查看您的系统是否受此差异影响，请检查 &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | grep -q NPTL&lt;/code&gt; 返回一个假值。NTPL线程保留POSIX语义。</target>
        </trans-unit>
        <trans-unit id="d211374e5db97da1828e5f0a6f84c0b749ec44e8" translate="yes" xml:space="preserve">
          <source>To see it in action, add a method</source>
          <target state="translated">要想看到它的运作,请添加一个方法</target>
        </trans-unit>
        <trans-unit id="fddb2e3b0651d7cee6f1eddfc0db7c585ec33e9f" translate="yes" xml:space="preserve">
          <source>To see the output of specific failing tests run the harness from the t directory:</source>
          <target state="translated">要查看特定失败测试的输出,请从t目录下运行 harness。</target>
        </trans-unit>
        <trans-unit id="5e8654d4f5f9129c9cab32750ab5566521abf2dc" translate="yes" xml:space="preserve">
          <source>To see what a state description looks like, just run the following:</source>
          <target state="translated">要查看状态描述是什么样子的,只需运行以下命令。</target>
        </trans-unit>
        <trans-unit id="1afd16a9742f3bb00f5d52a4bea0944a04f89bb4" translate="yes" xml:space="preserve">
          <source>To see what is installed on your system:</source>
          <target state="translated">要查看系统中安装了什么。</target>
        </trans-unit>
        <trans-unit id="759c7cca5357567d905de52c1b1b6b667aaa23a6" translate="yes" xml:space="preserve">
          <source>To see what version is included on the DVD (assumed here to be mounted on /cdrom), issue this command:</source>
          <target state="translated">要查看DVD上包含的版本(这里假设是挂载在/cdrom上),发出这个命令。</target>
        </trans-unit>
        <trans-unit id="7ad61eadcf1dbdb7c99f44756b97def548456147" translate="yes" xml:space="preserve">
          <source>To see whether you have non-const data you can use a BSD (or GNU) compatible &lt;code&gt;nm&lt;/code&gt; :</source>
          <target state="translated">要查看是否有非常量数据，可以使用与BSD（或GNU）兼容的 &lt;code&gt;nm&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1349f12e189a41ade68fc4f2a3b99132d4421e66" translate="yes" xml:space="preserve">
          <source>To see whether you have non-const data you can use a BSD (or GNU) compatible &lt;code&gt;nm&lt;/code&gt;:</source>
          <target state="translated">要查看是否有非常量数据，可以使用与BSD（或GNU）兼容的 &lt;code&gt;nm&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ceecb8953e41093c57b8581763c4bd993092c9bf" translate="yes" xml:space="preserve">
          <source>To see why this is a problem, consider what can happen when two processes, say &quot;A&quot; and &quot;B&quot;, both want to update the same &lt;b&gt;DB_File&lt;/b&gt; database using the locking steps outlined above. Assume process &quot;A&quot; has already opened the database and has a write lock, but it hasn't actually updated the database yet (it has finished step 2, but not started step 3 yet). Now process &quot;B&quot; tries to open the same database - step 1 will succeed, but it will block on step 2 until process &quot;A&quot; releases the lock. The important thing to notice here is that at this point in time both processes will have cached identical initial blocks from the database.</source>
          <target state="translated">要了解为什么会出现问题，请考虑当两个进程（例如&amp;ldquo; A&amp;rdquo;和&amp;ldquo; B&amp;rdquo;）都希望使用上述锁定步骤更新同一&lt;b&gt;DB_File&lt;/b&gt;数据库时会发生什么。假定进程&amp;ldquo; A&amp;rdquo;已经打开数据库并具有写锁，但是它实际上尚未更新数据库（它已完成步骤2，但尚未开始步骤3）。现在，进程&amp;ldquo; B&amp;rdquo;尝试打开相同的数据库-步骤1将成功，但是它将在步骤2阻塞，直到进程&amp;ldquo; A&amp;rdquo;释放锁为止。这里要注意的重要一点是，此时两个进程都将从数据库中缓存相同的初始块。</target>
        </trans-unit>
        <trans-unit id="887591ebb547202a2fbb02bece1d9984e9bcdec7" translate="yes" xml:space="preserve">
          <source>To see why, notice how you'll still have an issue on half-way-point alternation:</source>
          <target state="translated">要想知道原因,请注意,你在半程点交替上还是会有问题。</target>
        </trans-unit>
        <trans-unit id="0cddf3be7ebfd9389288691711afdcfed8edf9c1" translate="yes" xml:space="preserve">
          <source>To send a &lt;b&gt;datagram&lt;/b&gt; to multiple destinations simultaneously.</source>
          <target state="translated">同时发送&lt;b&gt;数据报到&lt;/b&gt;多个目的地。</target>
        </trans-unit>
        <trans-unit id="8617ca70598e41eabf7c915af7a92af825a55fcd" translate="yes" xml:space="preserve">
          <source>To send something to its correct destination. Often used metaphorically to indicate a transfer of programmatic control to a destination selected algorithmically, often by lookup in a table of function &lt;b&gt;references&lt;/b&gt; or, in the case of object &lt;b&gt;methods&lt;/b&gt;, by traversing the inheritance tree looking for the most specific definition for the method.</source>
          <target state="translated">将某物发送到正确的目的地。通常通过比喻来表示将程序控制权转移到通过算法选择的目标，通常是通过在函数&lt;b&gt;引用&lt;/b&gt;表中查找，或者在对象&lt;b&gt;方法&lt;/b&gt;的情况下，通过遍历继承树以寻找方法的最特定定义。</target>
        </trans-unit>
        <trans-unit id="67e016f9948cc1473ec98e12bd274f9eaa7682bd" translate="yes" xml:space="preserve">
          <source>To set the state of a pragma:</source>
          <target state="translated">设置一个pragma的状态。</target>
        </trans-unit>
        <trans-unit id="4d0f638abe1cc26ab6bbeb03cebb08b40820c287" translate="yes" xml:space="preserve">
          <source>To set your private value, call &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt; :</source>
          <target state="translated">要设置您的私有值，请调用 &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="16aae45044289a718089765d242152d067d315d5" translate="yes" xml:space="preserve">
          <source>To set your private value, call &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt;:</source>
          <target state="translated">要设置您的私有值，请调用 &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="39b42d6c90a6c04419bddc3aa56e776f03e6d4b1" translate="yes" xml:space="preserve">
          <source>To shut off its generation, pass the &lt;code&gt;NO_META&lt;/code&gt; flag to &lt;code&gt;WriteMakefile()&lt;/code&gt; .</source>
          <target state="translated">要关闭其生成，请将 &lt;code&gt;NO_META&lt;/code&gt; 标志传递给 &lt;code&gt;WriteMakefile()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eacb74b08b83ca5e29c7e01a124f0c6492dc5d47" translate="yes" xml:space="preserve">
          <source>To shut off its generation, pass the &lt;code&gt;NO_META&lt;/code&gt; flag to &lt;code&gt;WriteMakefile()&lt;/code&gt;.</source>
          <target state="translated">要关闭其生成，请将 &lt;code&gt;NO_META&lt;/code&gt; 标志传递给 &lt;code&gt;WriteMakefile()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57cf8244407c213f6cbced635b585a8f402b31ff" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; . See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , and &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">要发出信号量，请将 &lt;code&gt;-1&lt;/code&gt; 替换为 &lt;code&gt;1&lt;/code&gt; 。另请参见&lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;perlipc&lt;/a&gt;， &lt;code&gt;IPC::SysV&lt;/code&gt; 和 &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; 文档中的SysV IPC。</target>
        </trans-unit>
        <trans-unit id="d782cb39a280e66911e6595a3826686b674e633e" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; . See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , and &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">要发出信号量，请将 &lt;code&gt;-1&lt;/code&gt; 替换为 &lt;code&gt;1&lt;/code&gt; 。另请参见&lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;perlipc&lt;/a&gt;， &lt;code&gt;IPC::SysV&lt;/code&gt; 和 &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; 文档中的SysV IPC。</target>
        </trans-unit>
        <trans-unit id="49cc3c1b8c165959fade8c0cdac2c114f0c70649" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt;. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;&quot;SysV IPC&quot; in perlipc&lt;/a&gt; and the documentation for &lt;a href=&quot;IPC::SysV&quot;&gt;&lt;code&gt;IPC::SysV&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;IPC::Semaphore&quot;&gt;&lt;code&gt;IPC::Semaphore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要发出信号量，请将 &lt;code&gt;-1&lt;/code&gt; 替换为 &lt;code&gt;1&lt;/code&gt; 。另请参见&lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;perlipc中的&amp;ldquo; SysV IPC&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;IPC::SysV&quot;&gt; &lt;code&gt;IPC::SysV&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;IPC::Semaphore&quot;&gt; &lt;code&gt;IPC::Semaphore&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="46e199b8e074ec6e1896ea95f9bad604e453a779" translate="yes" xml:space="preserve">
          <source>To signal to Perl that HMQ is not needed any more, call &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt; . Perl process will automatically morph/unmorph itself into/from a PM process if HMQ is needed/not-needed. Perl will automatically enable/disable &lt;code&gt;WM_QUIT&lt;/code&gt; message during shutdown if the message queue is served/not-served.</source>
          <target state="translated">要向Perl发出不再需要HMQ的信号，请调用 &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt; 。如果需要/不需要HMQ，Perl进程将自动将自身变形为PM过程或从PM过程中变形。如果消息队列已服务/未服务，则Perl将在关机期间自动启用/禁用 &lt;code&gt;WM_QUIT&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="76395c3ce12a1fd4356ad20f5dad8a9f32df5165" translate="yes" xml:space="preserve">
          <source>To signal to Perl that HMQ is not needed any more, call &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt;. Perl process will automatically morph/unmorph itself into/from a PM process if HMQ is needed/not-needed. Perl will automatically enable/disable &lt;code&gt;WM_QUIT&lt;/code&gt; message during shutdown if the message queue is served/not-served.</source>
          <target state="translated">要向Perl发出不再需要HMQ的信号，请调用 &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt; 。如果需要/不需要HMQ，Perl进程将自动将自身变形为PM过程或从PM过程中变形。如果消息队列已服务/未服务，则Perl将在关机期间自动启用/禁用 &lt;code&gt;WM_QUIT&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="3868e3b616a54cb1bab8634fd841ed657adc2c50" translate="yes" xml:space="preserve">
          <source>To silently interpret it as the Perl operator, use the &lt;code&gt;CORE::&lt;/code&gt; prefix on the operator (e.g. &lt;code&gt;CORE::log($x)&lt;/code&gt; ) or declare the subroutine to be an object method (see &lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;Subroutine Attributes in perlsub&lt;/a&gt; or &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;).</source>
          <target state="translated">要以静默方式将其解释为Perl运算符，请在运算符上使用 &lt;code&gt;CORE::&lt;/code&gt; 前缀（例如 &lt;code&gt;CORE::log($x)&lt;/code&gt; ）或将子例程声明为对象方法（请参见&lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;perlsub中的Subroutine Attributes&lt;/a&gt;或&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="77f74a1e8ed985d91bce77589cc0e8ad84a337cc" translate="yes" xml:space="preserve">
          <source>To silently interpret it as the Perl operator, use the &lt;code&gt;CORE::&lt;/code&gt; prefix on the operator (e.g. &lt;code&gt;CORE::log($x)&lt;/code&gt;) or declare the subroutine to be an object method (see &lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;&quot;Subroutine Attributes&quot; in perlsub&lt;/a&gt; or &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;).</source>
          <target state="translated">要以静默方式将其解释为Perl运算符，请在运算符上使用 &lt;code&gt;CORE::&lt;/code&gt; 前缀（例如 &lt;code&gt;CORE::log($x)&lt;/code&gt; ）或将子例程声明为对象方法（请参见&lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;perlsub&lt;/a&gt;或&lt;a href=&quot;attributes&quot;&gt;attribute中的&lt;/a&gt;&amp;ldquo;子例程属性&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="ea26257b4903cfdcc4f9b51c3c53cf94dc5f1003" translate="yes" xml:space="preserve">
          <source>To simplify multi-line substitutions, the &quot;.&quot; character never matches a newline unless you use the &lt;code&gt;/s&lt;/code&gt; modifier, which in effect tells Perl to pretend the string is a single line--even if it isn't.</source>
          <target state="translated">为了简化多行替换，请使用&amp;ldquo;。&amp;rdquo;。字符永远不会与换行符匹配，除非您使用 &lt;code&gt;/s&lt;/code&gt; 修饰符，该修饰符实际上告诉Perl假装字符串是单行-即使不是。</target>
        </trans-unit>
        <trans-unit id="8a2c6b3c9e2b9a0960e93d5d6acb36d8aa948a45" translate="yes" xml:space="preserve">
          <source>To simplify multi-line substitutions, the &lt;code&gt;&quot;.&quot;&lt;/code&gt; character never matches a newline unless you use the &lt;a href=&quot;#s&quot;&gt;&lt;code&gt;/s&lt;/code&gt;&lt;/a&gt; modifier, which in effect tells Perl to pretend the string is a single line--even if it isn't.</source>
          <target state="translated">为了简化多行替换，请使用 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 字符永远不会与换行符匹配，除非您使用&lt;a href=&quot;#s&quot;&gt; &lt;code&gt;/s&lt;/code&gt; &lt;/a&gt;修饰符，该修饰符实际上告诉Perl假装字符串是单行-即使不是。</target>
        </trans-unit>
        <trans-unit id="3dcc0c984ac1c1f3aa01cd10ae020a1e23d2e144" translate="yes" xml:space="preserve">
          <source>To skip lines, use the looping controls. The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; in this example skips comment lines, and the &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; stops all processing once it encounters either &lt;code&gt;__END__&lt;/code&gt; or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">要跳过行，请使用循环控件。此示例中的 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 跳过注释行，并且 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 遇到 &lt;code&gt;__END__&lt;/code&gt; 或 &lt;code&gt;__DATA__&lt;/code&gt; 时,它停止所有处理。</target>
        </trans-unit>
        <trans-unit id="fa5fe915c274707436eefaadbe2f71ad0bad5d61" translate="yes" xml:space="preserve">
          <source>To skip lines, use the looping controls. The &lt;code&gt;next&lt;/code&gt; in this example skips comment lines, and the &lt;code&gt;last&lt;/code&gt; stops all processing once it encounters either &lt;code&gt;__END__&lt;/code&gt; or &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="translated">要跳过行，请使用循环控件。本示例中的 &lt;code&gt;next&lt;/code&gt; 跳过注释行，并且上 &lt;code&gt;last&lt;/code&gt; 遇到 &lt;code&gt;__END__&lt;/code&gt; 或 &lt;code&gt;__DATA__&lt;/code&gt; 时，最后一个将停止所有处理。</target>
        </trans-unit>
        <trans-unit id="7cb7cc3fb6917e0db56d0ceef1f6b092afc65ddb" translate="yes" xml:space="preserve">
          <source>To solve this, you must manually use pipe(), fork(), and the form of open() which sets one file descriptor to another, as shown below:</source>
          <target state="translated">为了解决这个问题,你必须手动使用管道()、fork()以及将一个文件描述符设置为另一个文件描述符的open()形式,如下图所示。</target>
        </trans-unit>
        <trans-unit id="4f249829a932dbf9b88abd3f71ccd6d576666559" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="translated">要按值对哈希进行排序，您需要使用&lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;功能。这是哈希值的降序数字排序：</target>
        </trans-unit>
        <trans-unit id="f205d5425879968b7952a3fb61c2ff97a391a194" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="translated">要按值对哈希进行排序，您需要使用 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 功能。这是哈希值的降序数字排序：</target>
        </trans-unit>
        <trans-unit id="e22346e7b0a650eb196d705609c50726a647e816" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="translated">要按值对哈希进行排序，您需要使用 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 功能。这是哈希值的降序数字排序：</target>
        </trans-unit>
        <trans-unit id="035b2f73f3e8b156397dc2189e758b10b01a049f" translate="yes" xml:space="preserve">
          <source>To sort a hash, start with the keys. In this example, we give the list of keys to the sort function which then compares them ASCIIbetically (which might be affected by your locale settings). The output list has the keys in ASCIIbetical order. Once we have the keys, we can go through them to create a report which lists the keys in ASCIIbetical order.</source>
          <target state="translated">要对一个哈希进行排序,先从键值开始。在这个例子中,我们将键值列表交给排序函数,然后以ASCII码方式对它们进行比较(这可能会受到您的本地设置的影响)。输出列表中的键按 ASCII 字符顺序排列。一旦我们得到了键值,我们就可以通过它们来创建一个按ASCII字节顺序排列的报告。</target>
        </trans-unit>
        <trans-unit id="bd567593644cab945269478fa56978a3d2bc8799" translate="yes" xml:space="preserve">
          <source>To specify a character by Unicode code point, use the form &lt;code&gt;\N{U+&lt;i&gt;code
point&lt;/i&gt;}&lt;/code&gt;, where</source>
          <target state="translated">要通过Unicode代码点指定字符，请使用 &lt;code&gt;\N{U+&lt;i&gt;code point&lt;/i&gt;}&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="97bdead994a8b1301604dc655e33bb83cb6a1547" translate="yes" xml:space="preserve">
          <source>To specify a compression level when writing, append a digit between 0 and 9 to the mode string -- 0 means no compression and 9 means maximum compression. If no compression level is specified Z_DEFAULT_COMPRESSION is used.</source>
          <target state="translated">要在写入时指定压缩级别,请在模式字符串中添加0到9之间的数字--0表示不压缩,9表示最大压缩。如果没有指定压缩级别,则使用Z_DEFAULT_COMPRESSION。</target>
        </trans-unit>
        <trans-unit id="679c6d53c6265b7e7972b50aa21c407989720f3b" translate="yes" xml:space="preserve">
          <source>To specify a literal SPACE character, you can escape it with a backslash, like:</source>
          <target state="translated">要指定一个SPACE字符,可以用反斜杠转义,如:。</target>
        </trans-unit>
        <trans-unit id="edce8429b2a3fa7edc3e49d4ca87a0b2294c60e2" translate="yes" xml:space="preserve">
          <source>To specify a particular stack size for any individual thread, call &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">要为任何单个线程指定特定的堆栈大小，请调用 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; 并将哈希引用作为第一个参数：</target>
        </trans-unit>
        <trans-unit id="5a3b28c1d56d62a0c685010a78c8616b6f249aaf" translate="yes" xml:space="preserve">
          <source>To specify a real-time timeout, supply the &lt;code&gt;LIFETIME&lt;/code&gt; option with a numeric value. Cached data will expire after this many seconds, and will be looked up afresh when it expires. When a data item is looked up afresh, its lifetime is reset.</source>
          <target state="translated">要指定实时超时，请为 &lt;code&gt;LIFETIME&lt;/code&gt; 选项提供一个数值。缓存的数据将在这几秒钟后过期，并且将在过期后重新查找。重新查找数据项时，将重置其生存期。</target>
        </trans-unit>
        <trans-unit id="75872cec7b7dae2ec30afbe5f15f62f2ed47906e" translate="yes" xml:space="preserve">
          <source>To specify by name, the name of the character or character sequence goes between the curly braces.</source>
          <target state="translated">如果要用名称来指定,则在大括号之间加上字符或字符序列的名称。</target>
        </trans-unit>
        <trans-unit id="dde9b4df6bfb5d9f21839e498fe1e3acf75a91a1" translate="yes" xml:space="preserve">
          <source>To specify how numbers are formatted when printed, one is advised to use &lt;code&gt;printf&lt;/code&gt; or &lt;code&gt;sprintf&lt;/code&gt; instead.</source>
          <target state="translated">要指定数字在打印时的格式，建议您改用 &lt;code&gt;printf&lt;/code&gt; 或 &lt;code&gt;sprintf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e22be0e52c335b1ce8908cd9371ba0e4b96e3022" translate="yes" xml:space="preserve">
          <source>To specify the compression strategy when writing, append 'f' for filtered data, 'h' for Huffman only compression, or 'R' for run-length encoding. If no strategy is specified Z_DEFAULT_STRATEGY is used.</source>
          <target state="translated">要在写入时指定压缩策略,请添加'f'表示过滤数据,'h'表示只压缩Huffman,或'R'表示长度编码。如果没有指定策略,则使用Z_DEFAULT_STRATEGY。</target>
        </trans-unit>
        <trans-unit id="cb8a391550e8914db81270f773f4523451df8b90" translate="yes" xml:space="preserve">
          <source>To speed things up in complex installation scenarios, CPAN.pm keeps track of what it has already done and refuses to do some things a second time. A &lt;code&gt;get&lt;/code&gt; , a &lt;code&gt;make&lt;/code&gt; , and an &lt;code&gt;install&lt;/code&gt; are not repeated. A &lt;code&gt;test&lt;/code&gt; is repeated only if the previous test was unsuccessful. The diagnostic message when CPAN.pm refuses to do something a second time is one of</source>
          <target state="translated">为了加快复杂安装场景中的处理速度，CPAN.pm会跟踪已完成的操作，并拒绝第二次执行某些操作。一个 &lt;code&gt;get&lt;/code&gt; ，一个 &lt;code&gt;make&lt;/code&gt; 和 &lt;code&gt;install&lt;/code&gt; 不重复。一个 &lt;code&gt;test&lt;/code&gt; 重复只有在以前的测试是不成功的。CPAN.pm再次拒绝执行某操作时的诊断消息是以下一种</target>
        </trans-unit>
        <trans-unit id="ee745e8e1ccd43545cce5d6e1098128c6d2cb42b" translate="yes" xml:space="preserve">
          <source>To split a string automatically, as the</source>
          <target state="translated">要自动拆分一个字符串,就像</target>
        </trans-unit>
        <trans-unit id="1c43b020de2fd47f4f4fe689a93a4f681f980968" translate="yes" xml:space="preserve">
          <source>To start exploring some of the features of Test::Harness I need to switch from</source>
          <target state="translated">要开始探索Test::Harness的一些功能,我需要从以下方面进行切换</target>
        </trans-unit>
        <trans-unit id="76a587334bce3d780e4ef5607b4eb7989a44b338" translate="yes" xml:space="preserve">
          <source>To start external programs with complicated command lines (like with pipes in between, and/or quoting of arguments), Perl uses an external shell. With EMX port such shell should be named</source>
          <target state="translated">为了启动带有复杂命令行的外部程序 (比如中间有管道,和/或引用参数),Perl 使用了一个外部 shell。对于 EMX port,这种 shell 的名字应该是</target>
        </trans-unit>
        <trans-unit id="4496b7043de2731c625ff5d9cbb9bfec5778dc82" translate="yes" xml:space="preserve">
          <source>To start perl by clicking on a perl source file, you have to make the according entries in HKCR (see</source>
          <target state="translated">要通过点击一个perl源文件来启动perl,你必须在HKCR中输入相应的条目(见</target>
        </trans-unit>
        <trans-unit id="ed415ca8982026bad9b823bf326a650e9d0848ae" translate="yes" xml:space="preserve">
          <source>To subtract a value from a variable, as in &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; &amp;rdquo; (meaning to remove 1 from its value) or &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; by 3&amp;rdquo;.</source>
          <target state="translated">从变量中减去一个值，如&amp;ldquo;减 &lt;code&gt;$x&lt;/code&gt; &amp;rdquo;（表示从其值中删除1）或&amp;ldquo;减 &lt;code&gt;$x&lt;/code&gt; 3&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b3834a44244c88392770a12aebccbba7a107bc50" translate="yes" xml:space="preserve">
          <source>To subtract a value from a variable, as in &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt;&amp;rdquo; (meaning to remove 1 from its value) or &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; by 3&amp;rdquo;.</source>
          <target state="translated">从变量中减去一个值，如&amp;ldquo;减 &lt;code&gt;$x&lt;/code&gt; &amp;rdquo;（表示从其值中删除1）或&amp;ldquo;减 &lt;code&gt;$x&lt;/code&gt; 3&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c34bd44153421ecb4ee7a84a5cf2f9e94314d16d" translate="yes" xml:space="preserve">
          <source>To summarise:</source>
          <target state="translated">概括地说:</target>
        </trans-unit>
        <trans-unit id="1ec17769e0302f168a8a4f3337a21d3e87e35b66" translate="yes" xml:space="preserve">
          <source>To summarize,</source>
          <target state="translated">总结一下:</target>
        </trans-unit>
        <trans-unit id="bdefe539f6f30e5536e03e0dcfcbf06113e55e75" translate="yes" xml:space="preserve">
          <source>To summarize, here are a number of possible methods for you to consider for storing the mapping between C and the Perl callback</source>
          <target state="translated">总结一下,以下是一些你可以考虑的存储C和Perl回调之间的映射的方法。</target>
        </trans-unit>
        <trans-unit id="87770a145a86a8f01c504f30ba378126d36ae639" translate="yes" xml:space="preserve">
          <source>To summarize, here's what to expect and how to handle locales in XS code:</source>
          <target state="translated">总结一下,以下是在XS代码中处理locale的期望和方法。</target>
        </trans-unit>
        <trans-unit id="9eda1d19cb3d66414653545444049318272d3717" translate="yes" xml:space="preserve">
          <source>To summarize, the &lt;code&gt;\o{}&lt;/code&gt; form is always safe to use, and the other form is safe to use for code points through \077 when you use exactly three digits to specify them.</source>
          <target state="translated">总而言之， &lt;code&gt;\o{}&lt;/code&gt; 格式始终可以安全使用，而当您恰好使用三个数字来指定它们时，另一种格式可以安全地用于\ 077的代码点。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
