<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="f40c24735c228769cecae3c743dcd1c13b34fed1" translate="yes" xml:space="preserve">
          <source>To summarize, this modifier provides protection for applications that don't wish to be exposed to all of Unicode. Specifying it twice gives added protection.</source>
          <target state="translated">总而言之,这个修饰符为那些不希望暴露在所有Unicode下的应用程序提供保护。两次指定它可以提供额外的保护。</target>
        </trans-unit>
        <trans-unit id="8b52f75bf07c40cc3e2dd50eeec591de76cf40c0" translate="yes" xml:space="preserve">
          <source>To support potentially complex type mappings, if a typemap entry used by an XSUB contains a comment like &lt;code&gt;/*scope*/&lt;/code&gt; then scoping will be automatically enabled for that XSUB.</source>
          <target state="translated">为了支持潜在的复杂类型映射，如果XSUB使用的类型映射条目包含 &lt;code&gt;/*scope*/&lt;/code&gt; 之类的注释，则将自动为该XSUB启用作用域。</target>
        </trans-unit>
        <trans-unit id="91686b6431594592a741d6ffaa933cf36c582cbb" translate="yes" xml:space="preserve">
          <source>To support the &lt;code&gt;IO::Socket::INET&lt;/code&gt; API, the host and port information may be passed in a single string rather than as two separate arguments.</source>
          <target state="translated">为了支持 &lt;code&gt;IO::Socket::INET&lt;/code&gt; API，主机和端口信息可以通过单个字符串而不是作为两个单独的参数传递。</target>
        </trans-unit>
        <trans-unit id="c8462b0ae01f912ec184e35a1a54c294d3db9c0b" translate="yes" xml:space="preserve">
          <source>To support these systems a dl_expandspec() function can be implemented either in the</source>
          <target state="translated">为了支持这些系统,dl_expandspec()函数可以在</target>
        </trans-unit>
        <trans-unit id="28ae7b79101a8be6ce604e7c61e718194e3e904d" translate="yes" xml:space="preserve">
          <source>To swap pairs of characters in a string (with even length) one could use several techniques. First, let's use &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; to skip forward and back:</source>
          <target state="translated">要交换字符串中的字符对（长度相等），可以使用多种技术。首先，让我们使用 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;X&lt;/code&gt; 向前和向后跳过：</target>
        </trans-unit>
        <trans-unit id="1051c83149c4c36730f97e1db8ce4187ba11feed" translate="yes" xml:space="preserve">
          <source>To switch back to blead:</source>
          <target state="translated">要切换回出血。</target>
        </trans-unit>
        <trans-unit id="52ed4dc484d91fd5d94539987c6af1829eb4d58f" translate="yes" xml:space="preserve">
          <source>To switch back to the default behaviour, use</source>
          <target state="translated">要切换回默认行为,使用</target>
        </trans-unit>
        <trans-unit id="58f194a064ccb257aaff951da440487e80ed0887" translate="yes" xml:space="preserve">
          <source>To take a closer look at how the engine does optimizations, see the section &lt;a href=&quot;#Pragmas-and-debugging&quot;&gt;&quot;Pragmas and debugging&quot;&lt;/a&gt; below.</source>
          <target state="translated">要仔细查看引擎如何进行优化，请参见下面的&lt;a href=&quot;#Pragmas-and-debugging&quot;&gt;&amp;ldquo;编译指示和调试&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="9ad4d27e66821295806e39cdf16c87b63c90f1ed" translate="yes" xml:space="preserve">
          <source>To take a closer look at how the engine does optimizations, see the section &lt;a href=&quot;#Pragmas-and-debugging&quot;&gt;Pragmas and debugging&lt;/a&gt; below.</source>
          <target state="translated">要仔细查看引擎如何进行优化，请参见下面的&amp;ldquo; &lt;a href=&quot;#Pragmas-and-debugging&quot;&gt;编译和调试&lt;/a&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="b4f5b8181a41c615c87aa14a36a9140e586c5541" translate="yes" xml:space="preserve">
          <source>To tell PerlIO to use line buffer, implement -&amp;gt;needs_lines method for your encoding object. See &lt;a href=&quot;Encode::Encoding&quot;&gt;Encode::Encoding&lt;/a&gt; for details.</source>
          <target state="translated">要告诉PerlIO使用行缓冲区，请为您的编码对象实现-&amp;gt; needs_lines方法。有关详细信息，请参见&lt;a href=&quot;Encode::Encoding&quot;&gt;Encode :: Encoding&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3651fac40bf38f464aae40f7d0973a874e0f3ea" translate="yes" xml:space="preserve">
          <source>To test that your code is behaving correctly and not modifying COW buffers, on systems that support</source>
          <target state="translated">为了测试你的代码是否正确,是否修改了COW缓冲区,在系统上,支持</target>
        </trans-unit>
        <trans-unit id="9bfb4f72eb168db2a7d20587450847a727ac1bdf" translate="yes" xml:space="preserve">
          <source>To test that your code is behaving correctly and not modifying COW buffers, on systems that support &lt;a href=&quot;http://man.he.net/man2/mmap&quot;&gt;mmap(2)&lt;/a&gt; (i.e., Unix) you can configure perl with &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_COW&lt;/code&gt; and it will turn buffer violations into crashes. You will find it to be marvellously slow, so you may want to skip perl's own tests.</source>
          <target state="translated">要测试您的代码是否正确运行并且不修改COW缓冲区，在支持&lt;a href=&quot;http://man.he.net/man2/mmap&quot;&gt;mmap（2）的系统&lt;/a&gt;（即Unix）上，可以使用 &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_COW&lt;/code&gt; 配置perl，它将把违反缓冲区的行为变成崩溃。您会发现它运行起来非常慢，因此您可能要跳过perl自己的测试。</target>
        </trans-unit>
        <trans-unit id="8ce0bdd874392ab18a8e9a217e048b7e9971ae31" translate="yes" xml:space="preserve">
          <source>To test whether a variable contains tainted data, and whose use would thus trigger an &quot;Insecure dependency&quot; message, you can use the &lt;code&gt;tainted()&lt;/code&gt; function of the Scalar::Util module, available in your nearby CPAN mirror, and included in Perl starting from the release 5.8.0. Or you may be able to use the following &lt;code&gt;is_tainted()&lt;/code&gt; function.</source>
          <target state="translated">要测试变量是否包含污染数据，并使用该变量会触发&amp;ldquo;不安全依赖项&amp;rdquo;消息，可以使用Scalar :: Util模块的 &lt;code&gt;tainted()&lt;/code&gt; 函数，该函数在您附近的CPAN镜像中可用，并且包含在Perl中从5.8.0版开始。或者您可以使用以下 &lt;code&gt;is_tainted()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="521a49c8c35183a9a627a2f63a5d516c8a7cf5ba" translate="yes" xml:space="preserve">
          <source>To the Perl program that called fork(), all this is designed to be transparent. The parent returns from the fork() with a pseudo-process ID that can be subsequently used in any process-manipulation functions; the child returns from the fork() with a value of &lt;code&gt;0&lt;/code&gt; to signify that it is the child pseudo-process.</source>
          <target state="translated">对于调用fork（）的Perl程序，所有这些都设计为透明的。父级从fork（）返回带有伪进程ID的伪ID，该ID可以随后在任何进程操纵函数中使用。子进程从fork（）返回值为 &lt;code&gt;0&lt;/code&gt; ,以表明它是子进程。</target>
        </trans-unit>
        <trans-unit id="c7e05b4fcf627d6e6c4197f19ffda73a879c664a" translate="yes" xml:space="preserve">
          <source>To the best of our ability, we will attempt to fix critical issues in the two most recent stable 5.x release series. Fixes for the current release series take precedence over fixes for the previous release series.</source>
          <target state="translated">我们将尽我们的能力,尝试修复最近两个稳定的 5.x 版本系列中的关键问题。当前版本系列的修复优先于之前版本系列的修复。</target>
        </trans-unit>
        <trans-unit id="51a0f8c69bc4919eb0f20691df0fe50a577785df" translate="yes" xml:space="preserve">
          <source>To the best of our ability, we will provide &quot;critical&quot; security patches / releases for any major version of Perl whose 5.x.0 release was within the past three years. We can only commit to providing these for the most recent .y release in any 5.x.y series.</source>
          <target state="translated">在我们的能力范围内,我们将为过去三年内发布 5.x.0 版本的任何主要 Perl 版本提供 &quot;关键 &quot;安全补丁/版本。我们只能承诺为任何 5.x.y 系列中最新的 .y 版本提供这些补丁。</target>
        </trans-unit>
        <trans-unit id="0150808aeae45323caf819f2a13c1da7ff5a8491" translate="yes" xml:space="preserve">
          <source>To the extent possible under law, 唐鳳 has waived all copyright and related or neighboring rights to &lt;a href=&quot;test-use-ok&quot;&gt;Test-use-ok&lt;/a&gt;.</source>
          <target state="translated">在法律允许的范围内，唐凤放弃了&lt;a href=&quot;test-use-ok&quot;&gt;Test-use-ok的&lt;/a&gt;所有版权以及相关或邻近的权利。</target>
        </trans-unit>
        <trans-unit id="6fa12fa0dac95b52f8a74aca03b7455d8e9dea13" translate="yes" xml:space="preserve">
          <source>To throw away the current &lt;b&gt;process&lt;/b&gt;&amp;rsquo;s program and replace it with another, without exiting the process or relinquishing any resources held (apart from the old memory image).</source>
          <target state="translated">丢弃当前&lt;b&gt;进程&lt;/b&gt;的程序并用另一个程序替换，而无需退出该进程或放弃所持有的任何资源（除了旧的内存映像外）。</target>
        </trans-unit>
        <trans-unit id="f643f5e924090f3cdd5f1a59fb90c2d5e840c683" translate="yes" xml:space="preserve">
          <source>To transfer files without &amp;lt;LF&amp;gt;&amp;lt;CR&amp;gt; translation Net::FTP provides the &lt;code&gt;binary&lt;/code&gt; method</source>
          <target state="translated">无需&amp;lt;LF&amp;gt; &amp;lt;CR&amp;gt;转换即可传输文件Net :: FTP提供了 &lt;code&gt;binary&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="448a61a17f3cda496b5d3ba49da88ff7c85062ed" translate="yes" xml:space="preserve">
          <source>To transform a bit vector into a string or list of 0's and 1's, use these:</source>
          <target state="translated">要将一个位向量转换为一个0和1的字符串或列表,使用这些。</target>
        </trans-unit>
        <trans-unit id="52d3ead3184110f1e5fce1f1092454c6b16a6c41" translate="yes" xml:space="preserve">
          <source>To translate from and to an arbitrary text encoding, use the &lt;code&gt;:encoding&lt;/code&gt; layer. The matching of encoding names in &lt;code&gt;:encoding&lt;/code&gt; is loose: case does not matter, and many encodings have several aliases. See &lt;a href=&quot;Encode::Supported&quot;&gt;Encode::Supported&lt;/a&gt; for details and the list of supported locales.</source>
          <target state="translated">要在任意文本编码之间进行转换，请使用 &lt;code&gt;:encoding&lt;/code&gt; 层。 &lt;code&gt;:encoding&lt;/code&gt; 中编码名称的匹配是松散的：大小写无关紧要，许多编码都有多个别名。有关详细信息和支持的语言环境，请参见&lt;a href=&quot;Encode::Supported&quot;&gt;Encode :: Supported&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="944acb39535fd8c95944433695337f030097b9f4" translate="yes" xml:space="preserve">
          <source>To trim trailing newlines from text lines use &lt;a href=&quot;perlfunc#chomp-VARIABLE&quot;&gt;&lt;code&gt;chomp&lt;/code&gt;&lt;/a&gt;. With default settings that function looks for a trailing &lt;code&gt;\n&lt;/code&gt; character and thus trims in a portable way.</source>
          <target state="translated">要修剪文本行中的尾随换行符，请使用&lt;a href=&quot;perlfunc#chomp-VARIABLE&quot;&gt; &lt;code&gt;chomp&lt;/code&gt; &lt;/a&gt;。使用默认设置时，该功能会查找尾随 &lt;code&gt;\n&lt;/code&gt; 字符，从而以可移植的方式进行修剪。</target>
        </trans-unit>
        <trans-unit id="8d6d675a384b336013b57ff889fd3d31ada57c0a" translate="yes" xml:space="preserve">
          <source>To trim trailing newlines from text lines use &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;. With default settings that function looks for a trailing &lt;code&gt;\n&lt;/code&gt; character and thus trims in a portable way.</source>
          <target state="translated">要修剪文本行中的尾随换行符，请使用 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; 。使用默认设置时，该功能会查找尾随 &lt;code&gt;\n&lt;/code&gt; 字符，从而以可移植的方式进行修剪。</target>
        </trans-unit>
        <trans-unit id="fc544de4b36caa59d370fbe1d58c57b2dd4e85a5" translate="yes" xml:space="preserve">
          <source>To try dmake's parallel mode, type &quot;dmake -P2&quot;, where 2, is the maximum number of parallel jobs you want to run. A number of things in the build process will run in parallel, but there are serialization points where you will see just 1 CPU maxed out. This is normal.</source>
          <target state="translated">要尝试dmake的并行模式,键入 &quot;dmake -P2&quot;,其中2,是你想要运行的并行作业的最大数量。构建过程中的许多事情都会并行运行,但在一些序列化点上,你会看到只有1个CPU最大。这是很正常的。</target>
        </trans-unit>
        <trans-unit id="40f27a2565b48c1f61edc1951aa27946b5ec4637" translate="yes" xml:space="preserve">
          <source>To turn a hostname into a human-readable plain IP address use getaddrinfo() to turn the hostname into a list of socket structures, then getnameinfo() on each one to make it a readable IP address again.</source>
          <target state="translated">要把主机名变成一个人类可读的普通IP地址,使用getaddrinfo()把主机名变成一个套接字结构的列表,然后对每个套接字结构进行getnameinfo(),使其再次成为一个可读的IP地址。</target>
        </trans-unit>
        <trans-unit id="f7838aca863be2066e77c33f9ec760e481423363" translate="yes" xml:space="preserve">
          <source>To turn one string representation into another by mapping each character of the source string to its corresponding character in the result string. Not to be confused with translation: for example, Greek</source>
          <target state="translated">通过将源字符串中的每个字符映射到结果字符串中的相应字符,将一个字符串表示转化为另一个字符串表示。不要与翻译相混淆:例如,希腊语的</target>
        </trans-unit>
        <trans-unit id="2796f222a72ab401559f8c49bff573c8aee5f84f" translate="yes" xml:space="preserve">
          <source>To unambiguously refer to the built-in form, precede the built-in name with the special package qualifier &lt;code&gt;CORE::&lt;/code&gt; . For example, saying &lt;code&gt;CORE::open()&lt;/code&gt; always refers to the built-in &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, even if the current package has imported some other subroutine called &lt;code&gt;&amp;amp;open()&lt;/code&gt; from elsewhere. Even though it looks like a regular function call, it isn't: the CORE:: prefix in that case is part of Perl's syntax, and works for any keyword, regardless of what is in the CORE package. Taking a reference to it, that is, &lt;code&gt;\&amp;amp;CORE::open&lt;/code&gt; , only works for some keywords. See &lt;a href=&quot;core&quot;&gt;CORE&lt;/a&gt;.</source>
          <target state="translated">要明确引用内置表单，请在内置名称之前加上特殊的包限定符 &lt;code&gt;CORE::&lt;/code&gt; 。例如，说 &lt;code&gt;CORE::open()&lt;/code&gt; 始终是指内置的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; ，即使当前程序包已从其他位置导入了称为 &lt;code&gt;&amp;amp;open()&lt;/code&gt; 的其他子例程。即使看起来像常规函数调用，它也不是：在这种情况下，CORE ::前缀是Perl语法的一部分，并且适用于任何关键字，而与CORE包中的内容无关。以它为参考，即 &lt;code&gt;\&amp;amp;CORE::open&lt;/code&gt; ，仅适用于某些关键字。参见&lt;a href=&quot;core&quot;&gt;核心&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="734561318cece230eccec304d2226018e762ebff" translate="yes" xml:space="preserve">
          <source>To unambiguously refer to the built-in form, precede the built-in name with the special package qualifier &lt;code&gt;CORE::&lt;/code&gt;. For example, saying &lt;code&gt;CORE::open()&lt;/code&gt; always refers to the built-in &lt;code&gt;open()&lt;/code&gt;, even if the current package has imported some other subroutine called &lt;code&gt;&amp;amp;open()&lt;/code&gt; from elsewhere. Even though it looks like a regular function call, it isn't: the CORE:: prefix in that case is part of Perl's syntax, and works for any keyword, regardless of what is in the CORE package. Taking a reference to it, that is, &lt;code&gt;\&amp;amp;CORE::open&lt;/code&gt;, only works for some keywords. See &lt;a href=&quot;core&quot;&gt;CORE&lt;/a&gt;.</source>
          <target state="translated">要明确引用内置表单，请在内置名称之前加上特殊的包限定符 &lt;code&gt;CORE::&lt;/code&gt; 。例如，说 &lt;code&gt;CORE::open()&lt;/code&gt; 始终引用内置的 &lt;code&gt;open()&lt;/code&gt; ，即使当前程序包已从其他位置导入了称为 &lt;code&gt;&amp;amp;open()&lt;/code&gt; 的其他子例程。即使看起来像常规函数调用，它也不是：在这种情况下，CORE ::前缀是Perl语法的一部分，并且适用于任何关键字，无论CORE包中包含什么。以它为参考，即 &lt;code&gt;\&amp;amp;CORE::open&lt;/code&gt; ，仅适用于某些关键字。请参阅&amp;ldquo;&lt;a href=&quot;core&quot;&gt;核心&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="248423c43b116b150a001ee976cc646676062436" translate="yes" xml:space="preserve">
          <source>To uncompress</source>
          <target state="translated">解压</target>
        </trans-unit>
        <trans-unit id="218af45982210497e46e853ffef0192283629105" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.1950&quot; and store the compressed data in the same directory</source>
          <target state="translated">解压&quot;/my/home &quot;目录下所有符合 &quot;*.txt.1950 &quot;的文件,并将压缩后的数据存储在同一目录下。</target>
        </trans-unit>
        <trans-unit id="5ddcb357cfd2b7762051e66890c8b84e7d960611" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.1951&quot; and store the compressed data in the same directory</source>
          <target state="translated">解压&quot;/my/home &quot;目录中所有符合 &quot;*.txt.1951 &quot;的文件,并将压缩后的数据存储在同一目录中。</target>
        </trans-unit>
        <trans-unit id="0e932ba5dc24bfd784757a246bd08027f46d4625" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.Compressed&quot; and store the compressed data in the same directory</source>
          <target state="translated">解压&quot;/my/home &quot;目录下所有符合 &quot;*.txt.Compressed &quot;的文件,并将压缩后的数据存储在同一目录下。</target>
        </trans-unit>
        <trans-unit id="29a087f9cfa51d4e0c2f6a475a11f449e63412aa" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.bz2&quot; and store the compressed data in the same directory</source>
          <target state="translated">解压&quot;/my/home &quot;目录下所有符合 &quot;*.txt.bz2 &quot;的文件,并将压缩后的数据存储在同一目录下。</target>
        </trans-unit>
        <trans-unit id="61aa1a4650d4e1d7c6939abfa456f5aeb3345d9a" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.gz&quot; and store the compressed data in the same directory</source>
          <target state="translated">解压&quot;/my/home &quot;目录下所有符合 &quot;*.txt.gz &quot;的文件,并将压缩后的数据存储在同一目录下。</target>
        </trans-unit>
        <trans-unit id="2754edb3f14d19ed8eebfcca373f83ac4a3282e7" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number between 8 and 15.</source>
          <target state="translated">要解压缩RFC 1950数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为8到15之间的正数。</target>
        </trans-unit>
        <trans-unit id="44083e3f2b591fd2c77505655cdb2c8f0aceb349" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number.</source>
          <target state="translated">要解压缩RFC 1950数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为正数。</target>
        </trans-unit>
        <trans-unit id="ceb9d1b68954b1740a461cdcd4976b0e567a28d9" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">要解压缩RFC 1951数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f170e414b119e7ad18faa1ef3905d7483fe9aa7c" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt;.</source>
          <target state="translated">要解压缩RFC 1951数据流，请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42e613bd86be8bd3cb751a2f5e9d0b238c337e5e" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt; .</source>
          <target state="translated">要解压缩RFC 1952数据流（即gzip），请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;WANT_GZIP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f4fb6ffd8b0c13548ef465f1f6d2c2d688e65fd" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt;.</source>
          <target state="translated">要解压缩RFC 1952数据流（即gzip），请将 &lt;code&gt;WindowBits&lt;/code&gt; 设置为 &lt;code&gt;WANT_GZIP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfba75b19db48553fce3ae8bd422d26a25e30031" translate="yes" xml:space="preserve">
          <source>To understand that, here is a description of how we make computers grok our characters.</source>
          <target state="translated">为了理解这一点,下面介绍一下我们是如何让计算机摸清我们的角色的。</target>
        </trans-unit>
        <trans-unit id="be309868d7c608c972ac92d2374d84d68bbcff87" translate="yes" xml:space="preserve">
          <source>To understand what kinds of incompatibilities one may expect, and in the rare case that the version of Perl on your machine is older than this document, see the section on &quot;Troubleshooting these Examples&quot; for more information.</source>
          <target state="translated">要了解可能出现的不兼容情况,以及你的机器上的Perl版本比本文档更老的罕见情况,请参见 &quot;排除这些示例的故障 &quot;一节了解更多信息。</target>
        </trans-unit>
        <trans-unit id="6b79315e2daa0488ef5b85ec7b3ded4c1bf9ff5d" translate="yes" xml:space="preserve">
          <source>To understand what the above</source>
          <target state="translated">要了解上述内容</target>
        </trans-unit>
        <trans-unit id="84e6e80a4aa5a302f6ddaa79d242cdcf126f821b" translate="yes" xml:space="preserve">
          <source>To uppercase or lowercase several characters, one might want to use &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; , which will lowercase/uppercase all characters following them, until either the end of the pattern or the next occurrence of &lt;code&gt;\E&lt;/code&gt; , whichever comes first. They provide functionality similar to what the functions &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; provide.</source>
          <target state="translated">要对几个字符进行大写或小写转换，可能要使用 &lt;code&gt;\L&lt;/code&gt; 或 &lt;code&gt;\U&lt;/code&gt; ，它们将对它们后面的所有字符进行小写/大写，直到模式结尾或下一个出现的 &lt;code&gt;\E&lt;/code&gt; （以先到者为准）。它们提供的功能类似于 &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; 提供的功能。</target>
        </trans-unit>
        <trans-unit id="21a1fe6cbffcae1c27b590bd9990080f83e9d683" translate="yes" xml:space="preserve">
          <source>To uppercase or lowercase several characters, one might want to use &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt;, which will lowercase/uppercase all characters following them, until either the end of the pattern or the next occurrence of &lt;code&gt;\E&lt;/code&gt;, whichever comes first. They provide functionality similar to what the functions &lt;code&gt;lc&lt;/code&gt; and &lt;code&gt;uc&lt;/code&gt; provide.</source>
          <target state="translated">要以大写或小写形式显示几个字符，可能需要使用 &lt;code&gt;\L&lt;/code&gt; 或 &lt;code&gt;\U&lt;/code&gt; ，这将使后面的所有字符都变为小写/大写，直到模式结尾或下一个出现的 &lt;code&gt;\E&lt;/code&gt; （以先到者为准）。它们提供的功能类似于 &lt;code&gt;lc&lt;/code&gt; 和 &lt;code&gt;uc&lt;/code&gt; 提供的功能。</target>
        </trans-unit>
        <trans-unit id="fd3b3ccd26f316b1795adeb89ffff2bedd268ce6" translate="yes" xml:space="preserve">
          <source>To use 'load_remote' or 'autoload_remote', specify at 'use'.</source>
          <target state="translated">要使用'load_remote'或'autoload_remote',请在'use'处指定。</target>
        </trans-unit>
        <trans-unit id="8a5610b8c5bc5858528e5c0711e8cd5aeeeaeb22" translate="yes" xml:space="preserve">
          <source>To use &lt;b&gt;AutoLoader&lt;/b&gt;, the author of a module has to place the definitions of subroutines to be autoloaded after an &lt;code&gt;__END__&lt;/code&gt; token. (See &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;.) The &lt;b&gt;AutoSplit&lt;/b&gt; module can then be run manually to extract the definitions into individual files</source>
          <target state="translated">要使用&lt;b&gt;AutoLoader&lt;/b&gt;，模块的作者必须将要自动加载的子例程的定义 &lt;code&gt;__END__&lt;/code&gt; 标记之后。（请参阅&lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;。）然后可以手动运行&lt;b&gt;AutoSplit&lt;/b&gt;模块，以将定义提取到单个文件中。</target>
        </trans-unit>
        <trans-unit id="09401632ee7edad8ed959974db2a06c3088b608d" translate="yes" xml:space="preserve">
          <source>To use Bzip2 compression, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed.</source>
          <target state="translated">要使用Bzip2压缩，必须安装模块 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d246c1b4a8c6fc55969eb14bc150616f75299064" translate="yes" xml:space="preserve">
          <source>To use Getopt::Long from a Perl program, you must include the following line in your Perl program:</source>
          <target state="translated">要从Perl程序中使用Getopt::Long,你必须在Perl程序中加入以下一行。</target>
        </trans-unit>
        <trans-unit id="ca5f9362859e86ac853b5005fcaab143b5cd4fd8" translate="yes" xml:space="preserve">
          <source>To use LZMA compression, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed.</source>
          <target state="translated">要使用LZMA压缩，必须安装模块 &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9dc12bf802050f20704badfc03f5cc7c4d321fc" translate="yes" xml:space="preserve">
          <source>To use Net::FTP, or any other module in the libnet distribution, through a SOCKS firewall you must create a socks-ified perl executable by compiling perl with the socks library.</source>
          <target state="translated">要通过 SOCKS 防火墙使用 Net::FTP 或 libnet 发行版中的任何其他模块,你必须通过使用 socks 库编译 perl 来创建一个 socks-ified perl 可执行文件。</target>
        </trans-unit>
        <trans-unit id="6a708529644756357339b6bd4e7ce1cb0f6dc3ee" translate="yes" xml:space="preserve">
          <source>To use a here-document to assign an array, one line per element, you might use an approach like this:</source>
          <target state="translated">要使用here-document来分配一个数组,每个元素一行,你可以使用这样的方法。</target>
        </trans-unit>
        <trans-unit id="d339f8f2813eea011c2650e8b1ed1fdac84e3d1c" translate="yes" xml:space="preserve">
          <source>To use a lexical subroutine from inside the subroutine itself, you must predeclare it. The &lt;code&gt;sub foo {...}&lt;/code&gt; subroutine definition syntax respects any previous &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; or &lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; declaration.</source>
          <target state="translated">要从子例程本身内部使用词汇子例程，必须预先声明它。该 &lt;code&gt;sub foo {...}&lt;/code&gt; 子程序定义语法方面的任何以前 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; 或 &lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; 宣言。</target>
        </trans-unit>
        <trans-unit id="46735f54baf859d9a048ed8b3d013ded7487875d" translate="yes" xml:space="preserve">
          <source>To use adb, download the Android SDK from &lt;a href=&quot;https://developer.android.com/sdk/index.html&quot;&gt;https://developer.android.com/sdk/index.html&lt;/a&gt;. The &quot;SDK Tools Only&quot; version should suffice -- if you downloaded the ADT Bundle, you can find the sdk under</source>
          <target state="translated">要使用adb，请从&lt;a href=&quot;https://developer.android.com/sdk/index.html&quot;&gt;https://developer.android.com/sdk/index.html&lt;/a&gt;下载Android SDK 。&amp;ldquo;仅SDK工具&amp;rdquo;版本就足够了-如果您下载了ADT捆绑包，则可以在以下位置找到sdk</target>
        </trans-unit>
        <trans-unit id="0a6c22616496274a8c0483ef0b81201680edefba" translate="yes" xml:space="preserve">
          <source>To use in your program as a pragma, merely invoke</source>
          <target state="translated">要在你的程序中作为一个pragma使用,只需调用一下</target>
        </trans-unit>
        <trans-unit id="c9702d448044d584ba0f08cf12e0416ad038a1b6" translate="yes" xml:space="preserve">
          <source>To use it more practically, you have to give the names of encodings to check (</source>
          <target state="translated">为了更实际地使用它,你必须给出要检查的编码名称(</target>
        </trans-unit>
        <trans-unit id="b4e86d7d6b51808534a6c222afc66338bce81e3d" translate="yes" xml:space="preserve">
          <source>To use ssh, you'll need to install and run a sshd app and set it up properly. There are several paid and free apps that do this rather easily, so you should be able to spot one on the store. Remember that Perl requires a passwordless connection, so set up a public key.</source>
          <target state="translated">要使用ssh,你需要安装和运行一个sshd应用程序,并进行正确的设置。有几个付费和免费的应用程序可以很容易地完成这项工作,所以你应该可以在商店里找到一个。记住,Perl需要无密码连接,所以要设置一个公钥。</target>
        </trans-unit>
        <trans-unit id="22588255917f935bc82a9b5e6907a6c5af5e0773" translate="yes" xml:space="preserve">
          <source>To use the OVERLOAD: keyword, create an XS function which takes three input parameters ( or use the c style '...' definition) like this:</source>
          <target state="translated">要使用OVERLOAD:关键字,创建一个XS函数,它需要三个输入参数(或使用c风格的'...'定义),像这样。</target>
        </trans-unit>
        <trans-unit id="2eb14825f964f456a1059f994fc559fc5aaaa465" translate="yes" xml:space="preserve">
          <source>To use the OVERLOAD: keyword, create an XS function which takes three input parameters (or use the C-style '...' definition) like this:</source>
          <target state="translated">要使用OVERLOAD:关键字,请创建一个XS函数,它需要三个输入参数(或使用C-style的'...'定义),像这样。</target>
        </trans-unit>
        <trans-unit id="3dc634fc1f1bc1b5d00fde6bff6b384f2eeb3f97" translate="yes" xml:space="preserve">
          <source>To use the Perl you just installed you will need to add a new entry to your PATH environment variable: &lt;code&gt;$INST_TOP\bin&lt;/code&gt; , e.g.</source>
          <target state="translated">要使用刚刚安装的Perl，您需要在PATH环境变量中添加一个新条目： &lt;code&gt;$INST_TOP\bin&lt;/code&gt; ，例如</target>
        </trans-unit>
        <trans-unit id="c6290d7b4a4817dd1a944f6b3cabef3b11fd0b36" translate="yes" xml:space="preserve">
          <source>To use the Perl you just installed you will need to add a new entry to your PATH environment variable: &lt;code&gt;$INST_TOP\bin&lt;/code&gt;, e.g.</source>
          <target state="translated">要使用刚刚安装的Perl，您需要在PATH环境变量中添加一个新条目： &lt;code&gt;$INST_TOP\bin&lt;/code&gt; ，例如</target>
        </trans-unit>
        <trans-unit id="7bc829cf0e8a5c97f97a31b7c617e9428478c19b" translate="yes" xml:space="preserve">
          <source>To use the forked debugger, you need to have the default display set to an X-11 Server and some environment variables set that Unix expects.</source>
          <target state="translated">要使用分叉调试器,你需要将默认显示设置为X-11服务器,并设置一些Unix期望的环境变量。</target>
        </trans-unit>
        <trans-unit id="fc207fecfdae515e813f72872e49086f5b78c28e" translate="yes" xml:space="preserve">
          <source>To use the module it is necessary to do the following:</source>
          <target state="translated">要使用该模块,需要做以下工作。</target>
        </trans-unit>
        <trans-unit id="dd4bd0185af39ed243608e8976fc475a01dc61d4" translate="yes" xml:space="preserve">
          <source>To use this expiration policy, the user would say</source>
          <target state="translated">要使用这个过期策略,用户会说</target>
        </trans-unit>
        <trans-unit id="538ca1c3044001d3cfa088cc4be7d0f4954981d6" translate="yes" xml:space="preserve">
          <source>To use this method you must have the Digest::MD5 or the MD5 module installed, otherwise this method will return</source>
          <target state="translated">要使用这个方法,你必须安装了Digest::MD5或MD5模块,否则这个方法将回到</target>
        </trans-unit>
        <trans-unit id="b3ee11508a4f000324b572266622a1fcc5b08715" translate="yes" xml:space="preserve">
          <source>To use this performance boost, set the current directory via</source>
          <target state="translated">要使用这个性能提升,可以通过以下方式设置当前目录</target>
        </trans-unit>
        <trans-unit id="acb718902c4afb0dc31c479abac33d68d277ca9d" translate="yes" xml:space="preserve">
          <source>To warn with a simple string message, the &lt;a href=&quot;#warn&quot;&gt;&quot;warn&quot;&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">要使用简单的字符串消息进行&lt;a href=&quot;#warn&quot;&gt;警告&lt;/a&gt;，&amp;ldquo;警告&amp;rdquo;功能可能更方便。</target>
        </trans-unit>
        <trans-unit id="38c026c273aff885d8062765e295cb0676868f0f" translate="yes" xml:space="preserve">
          <source>To warn with a simple string message, the &lt;a href=&quot;#warn&quot;&gt;warn&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">要使用简单的字符串消息进行&lt;a href=&quot;#warn&quot;&gt;警告&lt;/a&gt;，警告功能可能更方便。</target>
        </trans-unit>
        <trans-unit id="be15e0c4892f05af6b92d2d4a6be1a0a5f9a6dcd" translate="yes" xml:space="preserve">
          <source>To watch the tail of a dynamically growing logfile, (from the command line):</source>
          <target state="translated">要观察一个动态增长的日志文件的尾巴,(从命令行)。</target>
        </trans-unit>
        <trans-unit id="a70297b48e7206cae4fcb0090dd44f6d0f3207a8" translate="yes" xml:space="preserve">
          <source>To work around this bug, surround the code with a second set of braces. This creates an inner block that defeats the &lt;code&gt;MULTICALL&lt;/code&gt; logic, and does get fresh SVs allocated each time:</source>
          <target state="translated">要变通解决此错误，请用另一组花括号将代码括起来。这将创建一个内部块，该内部块会打败 &lt;code&gt;MULTICALL&lt;/code&gt; 逻辑，并且每次都会获得新分配的SV：</target>
        </trans-unit>
        <trans-unit id="df77a0e9f9993c56d24066721ca0f8c51a0345d4" translate="yes" xml:space="preserve">
          <source>To work around this, set environment variables as part of the</source>
          <target state="translated">要解决这个问题,可以将环境变量设置为环境变量的一部分。</target>
        </trans-unit>
        <trans-unit id="67bc56a45c2b844733bf04f643db3f4d6359ddb1" translate="yes" xml:space="preserve">
          <source>To work with only alphanumeric sequences (including underscores), you might consider</source>
          <target state="translated">要只使用字母数字序列(包括下划线),你可以考虑使用</target>
        </trans-unit>
        <trans-unit id="737fcabd51bb1faacb7059e47b96e0c587be8c5f" translate="yes" xml:space="preserve">
          <source>To write a test for your new (and probably not even done) module, create a new file called</source>
          <target state="translated">要为你的新模块(可能还没有完成)写一个测试,创建一个新的文件,叫做</target>
        </trans-unit>
        <trans-unit id="02bfda7919e7b9ec9d9ea9a01639287be236928c" translate="yes" xml:space="preserve">
          <source>To write platform-independent code, you must use &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; instead, like &lt;code&gt;\N{ESCAPE}&lt;/code&gt; or &lt;code&gt;\N{U+001B}&lt;/code&gt; , see &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">要编写与平台无关的代码，必须改为使用 &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; ，例如 &lt;code&gt;\N{ESCAPE}&lt;/code&gt; 或 &lt;code&gt;\N{U+001B}&lt;/code&gt; ，请参见&lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c88d87a2cc45115c74eeb5e575d4bb12e18a967" translate="yes" xml:space="preserve">
          <source>To write platform-independent code, you must use &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; instead, like &lt;code&gt;\N{ESCAPE}&lt;/code&gt; or &lt;code&gt;\N{U+001B}&lt;/code&gt;, see &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">要编写与平台无关的代码，必须改为使用 &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; ，例如 &lt;code&gt;\N{ESCAPE}&lt;/code&gt; 或 &lt;code&gt;\N{U+001B}&lt;/code&gt; ，请参见&lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32379df686c78a3422056dcfb4c9b1da18747d64" translate="yes" xml:space="preserve">
          <source>To yield a usable Perl variable, characters that are not part of the syntax for variables are translated to underscores. For example, &lt;code&gt;--fpp-struct-&lt;a href=&quot;../functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; will set the variable &lt;code&gt;$opt_fpp_struct_return&lt;/code&gt; . Note that this variable resides in the namespace of the calling program, not necessarily &lt;code&gt;main&lt;/code&gt; . For example:</source>
          <target state="translated">为了产生可用的Perl变量，将不属于变量语法的字符转换为下划线。例如，-- &lt;code&gt;--fpp-struct-&lt;a href=&quot;../functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 将设置变量 &lt;code&gt;$opt_fpp_struct_return&lt;/code&gt; 。请注意，此变量位于调用程序的名称空间中，不一定位于 &lt;code&gt;main&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="a049b042bf8f7cb4d234fc89dd589815ab07f9de" translate="yes" xml:space="preserve">
          <source>To yield a usable Perl variable, characters that are not part of the syntax for variables are translated to underscores. For example, &lt;code&gt;--fpp-struct-return&lt;/code&gt; will set the variable &lt;code&gt;$opt_fpp_struct_return&lt;/code&gt;. Note that this variable resides in the namespace of the calling program, not necessarily &lt;code&gt;main&lt;/code&gt;. For example:</source>
          <target state="translated">为了产生可用的Perl变量，将不属于变量语法的字符转换为下划线。例如，-- &lt;code&gt;--fpp-struct-return&lt;/code&gt; 将设置变量 &lt;code&gt;$opt_fpp_struct_return&lt;/code&gt; 。请注意，此变量位于调用程序的名称空间中，不一定位于 &lt;code&gt;main&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="af2824d2ae2117d9a03cba6d58d8adc173a02e61" translate="yes" xml:space="preserve">
          <source>To%s: illegal mapping '%s'</source>
          <target state="translated">To%s:非法映射'%s'</target>
        </trans-unit>
        <trans-unit id="33224443be18843a7174975c46578d74787bc749" translate="yes" xml:space="preserve">
          <source>Tobias Brox, tobiasb@tobiasb.funcom.com</source>
          <target state="translated">Tobias Brox,tobiasb@tobiasb.funcom.com</target>
        </trans-unit>
        <trans-unit id="57a4f395602ffbc6392e66ae2e2c5974770b3c0a" translate="yes" xml:space="preserve">
          <source>Todo tests</source>
          <target state="translated">所有测试</target>
        </trans-unit>
        <trans-unit id="ec7a57e5883d57c428d8e15819e5060eeed56435" translate="yes" xml:space="preserve">
          <source>Together, these categories go a long way towards being able to customize a single program to run in many different locations. But there are deficiencies, so keep reading.</source>
          <target state="translated">这些类别加在一起,对于能够定制一个程序在许多不同的地方运行有很大的帮助。但也有不足之处,请继续阅读。</target>
        </trans-unit>
        <trans-unit id="6f1eb05b47fbf56bdd9586b2ff6beeffab4ce59f" translate="yes" xml:space="preserve">
          <source>Together, these two features are intended to replace the historical &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; function, which has (at least) two bugs in it, that cannot easily be fixed without breaking existing programs:</source>
          <target state="translated">这两个功能共同旨在取代历史性的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 函数，该函数具有（至少）两个bug，在不破坏现有程序的情况下不易修复：</target>
        </trans-unit>
        <trans-unit id="4ce897ee72e1aab169ad26b4888dec08e507c975" translate="yes" xml:space="preserve">
          <source>Together, these two features are intended to replace the legacy string &lt;code&gt;eval&lt;/code&gt; function, which behaves problematically in some instances. They are available starting with Perl 5.16, and are enabled by default by a &lt;code&gt;use 5.16&lt;/code&gt; or higher declaration.</source>
          <target state="translated">这两个功能一起用于替换旧式字符串 &lt;code&gt;eval&lt;/code&gt; 函数，该函数在某些情况下会出现问题。它们从Perl 5.16开始可用，并且默认情况下已通过 &lt;code&gt;use 5.16&lt;/code&gt; 或更高版本的声明启用。</target>
        </trans-unit>
        <trans-unit id="751e44ad1c63d964b7e27098dbfa3f7faca67a2f" translate="yes" xml:space="preserve">
          <source>Toggle buffered status.</source>
          <target state="translated">切换缓冲状态。</target>
        </trans-unit>
        <trans-unit id="5379fd6502d08f80951bb93415834c8443e36cd5" translate="yes" xml:space="preserve">
          <source>Toggle trace mode (see also the &lt;code&gt;AutoTrace&lt;/code&gt; option). Optional argument is the maximum number of levels to trace below the current one; anything deeper than that will be silent.</source>
          <target state="translated">切换跟踪模式（另请参阅&amp;ldquo; &lt;code&gt;AutoTrace&lt;/code&gt; 跟踪&amp;rdquo; 选项）。可选参数是要跟踪的当前级别以下的最大级别数；任何比这更深的东西都将保持沉默。</target>
        </trans-unit>
        <trans-unit id="f422da5828ccca294dcf6d07ee5efb74761f28a1" translate="yes" xml:space="preserve">
          <source>Tokens from Pod::Simple::PullParser</source>
          <target state="translated">来自Pod::Simple::PullParser的代币。</target>
        </trans-unit>
        <trans-unit id="e3f27977b0cf7c5ef1db648369c2aa76bc8a767d" translate="yes" xml:space="preserve">
          <source>Tokens of an RPN expression may be separated by whitespace, but such separation is usually not required. It is required only where unseparated tokens would look like a longer token. For example, &lt;code&gt;12 34 +&lt;/code&gt; can be written as &lt;code&gt;12 34+&lt;/code&gt;, but not as &lt;code&gt;1234 +&lt;/code&gt;.</source>
          <target state="translated">RPN表达式的标记可以用空格分隔，但是通常不需要这样的分隔。仅在未分隔的令牌看起来像更长的令牌的情况下才需要。例如， &lt;code&gt;12 34 +&lt;/code&gt; 可以写为 &lt;code&gt;12 34+&lt;/code&gt; ，但不能写为 &lt;code&gt;1234 +&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="685cbbd2434336a1c0d592cb5e469ec23061ee59" translate="yes" xml:space="preserve">
          <source>Tom Christiansen</source>
          <target state="translated">Tom Christiansen</target>
        </trans-unit>
        <trans-unit id="8be2aa955349ba9da124a5ab00db7e6f88ee861a" translate="yes" xml:space="preserve">
          <source>Tom Christiansen &amp;lt;</source>
          <target state="translated">汤姆&amp;middot;克里斯蒂安森&amp;lt;</target>
        </trans-unit>
        <trans-unit id="5ca9f204e050f14afeeca056eec19f3529541293" translate="yes" xml:space="preserve">
          <source>Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt; wrote this, with occasional kibbitzing from Larry Wall and Jeffrey Friedl in the background.</source>
          <target state="translated">汤姆&amp;middot;克里斯蒂安森（Tom Christiansen）&amp;lt;tchrist@perl.com&amp;gt;写道，偶尔还有拉里&amp;middot;沃尔（Larry Wall）和杰弗里&amp;middot;弗里德尔（Jeffrey Friedl）的嘲讽。</target>
        </trans-unit>
        <trans-unit id="8e134c4a6e79e76b0db622556fcf6a08eb055742" translate="yes" xml:space="preserve">
          <source>Tom Christiansen wrote the original perlfaq then expanded it with the help of Nat Torkington. brian d foy substantially edited and expanded the perlfaq. perlfaq-workers and others have also supplied feedback, patches and corrections over the years.</source>
          <target state="translated">Tom Christiansen撰写了最初的perlfaq,然后在Nat Torkington的帮助下对其进行了扩充。Brian D Foy对perlfaq进行了大量的编辑和扩充。</target>
        </trans-unit>
        <trans-unit id="13f0322dc66b8435d53d03e97ab3bdb9a5e08c67" translate="yes" xml:space="preserve">
          <source>Tom Christiansen wrote the original version of this document. brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; wrote this version. See the individual perlfaq documents for additional copyright information.</source>
          <target state="translated">汤姆&amp;middot;克里斯蒂安森（Tom Christiansen）撰写了本文档的原始版本。brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; 编写了此版本。有关其他版权信息，请参阅各个perlfaq文档。</target>
        </trans-unit>
        <trans-unit id="594631f752605ca51961fa701a3edb58acb263cd" translate="yes" xml:space="preserve">
          <source>Tom Christiansen, &amp;lt;tchrist@perl.com&amp;gt;.</source>
          <target state="translated">汤姆&amp;middot;克里斯蒂安森（Tom Christiansen），&amp;lt;tchrist@perl.com&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="95a03ceecd01437e5e0609dbfa8dc64983a0ce69" translate="yes" xml:space="preserve">
          <source>Tom Christiansen, with occasional vestiges of Larry Wall's original version and suggestions from the Perl Porters.</source>
          <target state="translated">Tom Christiansen,偶尔会有Larry Wall的原始版本的痕迹和Perl Porters的建议。</target>
        </trans-unit>
        <trans-unit id="86f2b4b3ae91b418a1683a4b91e72d3ad71dd15f" translate="yes" xml:space="preserve">
          <source>Tom Hukins &amp;lt;tom@eborcom.com&amp;gt;</source>
          <target state="translated">汤姆&amp;middot;休金斯&amp;lt;tom@eborcom.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e834545bca77fe29ecc8dac8de115465b8dcd679" translate="yes" xml:space="preserve">
          <source>Tom Lutz &amp;lt;</source>
          <target state="translated">汤姆&amp;middot;卢兹&amp;lt;</target>
        </trans-unit>
        <trans-unit id="476ccb2f91007a71136d530d51755067de803643" translate="yes" xml:space="preserve">
          <source>Tom Phoenix, &amp;lt;</source>
          <target state="translated">汤姆&amp;middot;菲尼克斯&amp;lt;</target>
        </trans-unit>
        <trans-unit id="0d331f4232946333d8f1366dd1d47c9f81d210b2" translate="yes" xml:space="preserve">
          <source>Tomas Doran &amp;lt;bobtfish@bobtfish.net&amp;gt;</source>
          <target state="translated">托马斯&amp;middot;多兰（Tomas Doran）&amp;lt;bobtfish@bobtfish.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="28c9ef80202c4539b6ea96fa83f4e8656550b386" translate="yes" xml:space="preserve">
          <source>Tomohiro Hosaka &amp;lt;bokutin@bokut.in&amp;gt;</source>
          <target state="translated">细坂智宏&amp;lt;bokutin@bokut.in&amp;gt;</target>
        </trans-unit>
        <trans-unit id="793b4a701cfe0913d08894024037c7429f46b186" translate="yes" xml:space="preserve">
          <source>Tony Cook &amp;lt;tony@develop-help.com&amp;gt;</source>
          <target state="translated">托尼&amp;middot;库克（Tony Cook）&amp;lt;tony@develop-help.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="60b01674cdd852dec165a416e0496fa965e8b91a" translate="yes" xml:space="preserve">
          <source>Too deeply nested ()-groups</source>
          <target state="translated">嵌套太深的()-组。</target>
        </trans-unit>
        <trans-unit id="1db6f1ae51bb58b9a4860785d43a21467f4cbb8c" translate="yes" xml:space="preserve">
          <source>Too few args to syscall</source>
          <target state="translated">系统调用的参数太少</target>
        </trans-unit>
        <trans-unit id="2364f2f117108b7557a903b349dc899cf3b08e9e" translate="yes" xml:space="preserve">
          <source>Too few arguments for subroutine '%s'</source>
          <target state="translated">子程序'%s'的参数太少。</target>
        </trans-unit>
        <trans-unit id="ba42647932e0b5434947f286f404459ce1a76e83" translate="yes" xml:space="preserve">
          <source>Too few records will be retrieved.</source>
          <target state="translated">太少的记录会被检索出来。</target>
        </trans-unit>
        <trans-unit id="ff02d866660d5b53534c080f1fcb0457f7d00d24" translate="yes" xml:space="preserve">
          <source>Too late for &quot;-%s&quot; option</source>
          <target state="translated">为时已晚的&quot;-%s &quot;选项</target>
        </trans-unit>
        <trans-unit id="769c54b58dcbc8ae188a5471b5a9ac818add3700" translate="yes" xml:space="preserve">
          <source>Too late to run %s block</source>
          <target state="translated">来不及跑了</target>
        </trans-unit>
        <trans-unit id="b3e03f0741d093e7b4fe7029e12428aa7a386bc5" translate="yes" xml:space="preserve">
          <source>Too many ('s</source>
          <target state="translated">太多('s)</target>
        </trans-unit>
        <trans-unit id="db44b7d3a550f69ac66850f32920ad09e8328651" translate="yes" xml:space="preserve">
          <source>Too many )'s</source>
          <target state="translated">太多了</target>
        </trans-unit>
        <trans-unit id="9155bcdc24c3728c4025b090f8ec51766e724176" translate="yes" xml:space="preserve">
          <source>Too many args to syscall</source>
          <target state="translated">系统调用的参数太多</target>
        </trans-unit>
        <trans-unit id="3f95368fd6442a537ee2dd900f3e1bb4d5350d08" translate="yes" xml:space="preserve">
          <source>Too many arguments for %s</source>
          <target state="translated">争论太多,%s</target>
        </trans-unit>
        <trans-unit id="e4091f54a0813795be4fd20124afb6c89bed7942" translate="yes" xml:space="preserve">
          <source>Too many arguments for subroutine '%s'</source>
          <target state="translated">子程序'%s'的参数太多。</target>
        </trans-unit>
        <trans-unit id="ef15ae49ed8dd79937ceab5a3d6972af6ced0871" translate="yes" xml:space="preserve">
          <source>Too many nested open parens in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中嵌套的开放式括号太多；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="0f85c6fbc6b17f4b329c823a126de114fb51f097" translate="yes" xml:space="preserve">
          <source>Too many will be retrieved.</source>
          <target state="translated">太多了会被收回。</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="2f4169d30e0802a9d8a3d39c5549f0963dd393e1" translate="yes" xml:space="preserve">
          <source>Tools &amp;amp; SDK</source>
          <target state="translated">工具和SDK</target>
        </trans-unit>
        <trans-unit id="2d26e7b7bd96209071fc6ad7cab1a93d4b45e8bf" translate="yes" xml:space="preserve">
          <source>Tools to compile Perl modules</source>
          <target state="translated">编译Perl模块的工具</target>
        </trans-unit>
        <trans-unit id="f0ad973010edc9e98f2f60aa9dbfdb7b904996da" translate="yes" xml:space="preserve">
          <source>Tools used by Test2 and friends.</source>
          <target state="translated">Test2和朋友们使用的工具。</target>
        </trans-unit>
        <trans-unit id="a00a8f35172e2849241ce00e52e7b7a9a0047d25" translate="yes" xml:space="preserve">
          <source>Top of Form Processing</source>
          <target state="translated">表格处理的顶部</target>
        </trans-unit>
        <trans-unit id="ee80479b0fa9a2d2efdf0ff5851a9a2f37c4056d" translate="yes" xml:space="preserve">
          <source>Top of form processing is handled automatically: if there is insufficient room on the current page for the formatted record, the page is advanced by writing a form feed and a special top-of-page format is used to format the new page header before the record is written. By default, the top-of-page format is the name of the filehandle with &quot;_TOP&quot; appended, or &quot;top&quot; in the current package if the former does not exist. This would be a problem with autovivified filehandles, but it may be dynamically set to the format of your choice by assigning the name to the &lt;code&gt;$^&lt;/code&gt; variable while that filehandle is selected. The number of lines remaining on the current page is in variable &lt;code&gt;$-&lt;/code&gt; , which can be set to &lt;code&gt;0&lt;/code&gt; to force a new page.</source>
          <target state="translated">表单顶部的处理是自动进行的：如果当前页面上没有足够的空间容纳格式化记录，则通过编写表单提要来推进页面的前进，并使用特殊的页面顶部格式来格式化新页面的页眉。记录被写入。默认情况下，页面顶部格式是附加了&amp;ldquo; _TOP&amp;rdquo;的文件句柄的名称，如果当前包不存在，则为当前包中的&amp;ldquo;顶部&amp;rdquo;。这是自动文件句柄的问题，但可以通过在选择该文件句柄时将名称分配给 &lt;code&gt;$^&lt;/code&gt; 变量来将其动态设置为您选择的格式。当前页面上剩余的行数在变量 &lt;code&gt;$-&lt;/code&gt; 中，可以将其设置为 &lt;code&gt;0&lt;/code&gt; 以强制进入新页面。</target>
        </trans-unit>
        <trans-unit id="f10b9e66ec3cf51c0d1a7e3d006886e22937c14a" translate="yes" xml:space="preserve">
          <source>Top of form processing is handled automatically: if there is insufficient room on the current page for the formatted record, the page is advanced by writing a form feed and a special top-of-page format is used to format the new page header before the record is written. By default, the top-of-page format is the name of the filehandle with &lt;code&gt;_TOP&lt;/code&gt; appended, or &lt;code&gt;top&lt;/code&gt; in the current package if the former does not exist. This would be a problem with autovivified filehandles, but it may be dynamically set to the format of your choice by assigning the name to the &lt;a href=&quot;perlvar#%24%5E&quot;&gt;&lt;code&gt;$^&lt;/code&gt;&lt;/a&gt; variable while that filehandle is selected. The number of lines remaining on the current page is in variable &lt;a href=&quot;perlvar#%24-&quot;&gt;&lt;code&gt;$-&lt;/code&gt;&lt;/a&gt;, which can be set to &lt;code&gt;0&lt;/code&gt; to force a new page.</source>
          <target state="translated">表单顶部的处理是自动进行的：如果当前页面上没有足够的空间容纳格式化的记录，则通过编写表单提要来前进页面，并使用特殊的页面顶部格式来格式化新页面的页眉。记录被写入。默认情况下，页面顶部格式是附加了 &lt;code&gt;_TOP&lt;/code&gt; 的文件句柄的名称，如果不存在前者，则为当前程序包的 &lt;code&gt;top&lt;/code&gt; 。这是自动文件句柄的问题，但是可以通过在选择该文件句柄时将名称分配给&lt;a href=&quot;perlvar#%24%5E&quot;&gt; &lt;code&gt;$^&lt;/code&gt; &lt;/a&gt;变量来将其动态设置为您选择的格式。当前页面上剩余的行数在变量&lt;a href=&quot;perlvar#%24-&quot;&gt; &lt;code&gt;$-&lt;/code&gt; 中&lt;/a&gt;，可以将其设置为 &lt;code&gt;0&lt;/code&gt; 以强制进入新页面。</target>
        </trans-unit>
        <trans-unit id="9d8d0feb3edb0eff1e9ffe23486e4f54336c8d4e" translate="yes" xml:space="preserve">
          <source>Top-of-form processing is by default handled by a format with the same name as the current filehandle with &quot;_TOP&quot; concatenated to it. It's triggered at the top of each page. See &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;.</source>
          <target state="translated">默认情况下，格式顶部处理由与当前文件句柄同名的格式处理，并带有&amp;ldquo; _TOP&amp;rdquo;。它在每个页面的顶部触发。见&lt;a href=&quot;functions/write&quot;&gt;写&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58ef03b2e7b2cce794df0ce3f4e46ce888251a1d" translate="yes" xml:space="preserve">
          <source>Top-of-form processing is by default handled by a format with the same name as the current filehandle with &quot;_TOP&quot; concatenated to it. It's triggered at the top of each page. See &lt;a href=&quot;perlfunc#write&quot;&gt;&quot;write&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">默认情况下，格式顶部处理由与当前文件句柄同名的格式处理，并带有&amp;ldquo; _TOP&amp;rdquo;。它在每个页面的顶部触发。请参阅&lt;a href=&quot;perlfunc#write&quot;&gt;perlfunc中的&amp;ldquo;写入&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb98d71b2e229a477af401f7c4895167097dcb8a" translate="yes" xml:space="preserve">
          <source>TopSystemUID</source>
          <target state="translated">TopSystemUID</target>
        </trans-unit>
        <trans-unit id="f766dbf6de80a1783868b76b0ffdd16e6a94e83e" translate="yes" xml:space="preserve">
          <source>Topic branches and rewriting history</source>
          <target state="translated">主题分支和改写历史</target>
        </trans-unit>
        <trans-unit id="8e2f2b4afe1a913994b69be99455c56a7fc054ab" translate="yes" xml:space="preserve">
          <source>Torsten Schoenfeld</source>
          <target state="translated">Torsten Schoenfeld</target>
        </trans-unit>
        <trans-unit id="855b740deb0e234d1668b8ec10c825eb8a3450f0" translate="yes" xml:space="preserve">
          <source>Total CPU (User + System) of any children processes.</source>
          <target state="translated">任何子进程的CPU总量(用户+系统)。</target>
        </trans-unit>
        <trans-unit id="3481164ed61c4f3a7713de67224c54bcab0e71f6" translate="yes" xml:space="preserve">
          <source>Total CPU (User + System) of the main (parent) process.</source>
          <target state="translated">主(父)进程的CPU总量(用户+系统)。</target>
        </trans-unit>
        <trans-unit id="1e2c196e8d42960075bf83565f85bd785a488f4c" translate="yes" xml:space="preserve">
          <source>Total CPU of parent and any children processes.</source>
          <target state="translated">父进程和任何子进程的CPU总量。</target>
        </trans-unit>
        <trans-unit id="32bbce2a356130ac460d0855ed4bb96cc9c277fe" translate="yes" xml:space="preserve">
          <source>Trace function calls</source>
          <target state="translated">跟踪函数调用</target>
        </trans-unit>
        <trans-unit id="4b32a7b148f732eb014244c4bbbcbbea6216c149" translate="yes" xml:space="preserve">
          <source>Trace mode (similar to &lt;code&gt;t&lt;/code&gt; command, but can be put into &lt;code&gt;PERLDB_OPTS&lt;/code&gt; ).</source>
          <target state="translated">跟踪模式（类似于 &lt;code&gt;t&lt;/code&gt; 命令，但可以放入 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 中）。</target>
        </trans-unit>
        <trans-unit id="75ddac2cad68f5ef90bf266909b1cc9bff0811e0" translate="yes" xml:space="preserve">
          <source>Trace mode (similar to &lt;code&gt;t&lt;/code&gt; command, but can be put into &lt;code&gt;PERLDB_OPTS&lt;/code&gt;).</source>
          <target state="translated">跟踪模式（类似于 &lt;code&gt;t&lt;/code&gt; 命令，但可以放入 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 中）。</target>
        </trans-unit>
        <trans-unit id="4d8c4db1a294c0162454110ac7c8472297017033" translate="yes" xml:space="preserve">
          <source>Trace through execution of &lt;code&gt;expr&lt;/code&gt; . Optional first argument is the maximum number of levels to trace below the current one; anything deeper than that will be silent. See &lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;Frame Listing Output Examples in perldebguts&lt;/a&gt; for examples.</source>
          <target state="translated">通过执行 &lt;code&gt;expr&lt;/code&gt; 进行跟踪。可选的第一个参数是要跟踪的当前级别以下的最大级别数；任何比这更深的东西都将保持沉默。有关&lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;示例，&lt;/a&gt;请参见perldebguts中的框架列表输出示例。</target>
        </trans-unit>
        <trans-unit id="41581b1e8642b813163a8ffec956716ae9f8f88d" translate="yes" xml:space="preserve">
          <source>Trace through execution of &lt;code&gt;expr&lt;/code&gt;. Optional first argument is the maximum number of levels to trace below the current one; anything deeper than that will be silent. See &lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;&quot;Frame Listing Output Examples&quot; in perldebguts&lt;/a&gt; for examples.</source>
          <target state="translated">通过执行 &lt;code&gt;expr&lt;/code&gt; 进行跟踪。可选的第一个参数是要跟踪的当前级别以下的最大级别数；任何比这更深的东西都将保持沉默。有关&lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;示例，&lt;/a&gt;请参见perldebguts中的&amp;ldquo;框架清单输出示例&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="21b60e7167b2cc35295d61cd8ed5b383229ffbac" translate="yes" xml:space="preserve">
          <source>Trace variable used when Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch. This is the C variable which corresponds to Perl's $DB::trace variable. See &lt;code&gt;&lt;a href=&quot;#PL_DBsingle&quot;&gt;&quot;PL_DBsingle&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过&lt;b&gt;-d&lt;/b&gt;开关在调试模式下运行Perl时使用的跟踪变量。这是C变量，它对应于Perl的$ DB :: trace变量。请参阅 &lt;code&gt;&lt;a href=&quot;#PL_DBsingle&quot;&gt;&quot;PL_DBsingle&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24be5dbb481a63442832782f4da3ef4f0dc024ff" translate="yes" xml:space="preserve">
          <source>Trace variable used when Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch. This is the C variable which corresponds to Perl's $DB::trace variable. See &lt;code&gt;PL_DBsingle&lt;/code&gt; .</source>
          <target state="translated">使用&lt;b&gt;-d&lt;/b&gt;开关在Perl以调试模式运行时使用的跟踪变量。这是C变量，它对应于Perl的$ DB :: trace变量。参见 &lt;code&gt;PL_DBsingle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="411aea8f76aef96f5e36c8b291c19e9ceb9466d1" translate="yes" xml:space="preserve">
          <source>Traces changes to Perl's interpreter state. You can internalize this as tracing changes to Perl's &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; variable, especially since the values for &lt;code&gt;NEWPHASE&lt;/code&gt; and &lt;code&gt;OLDPHASE&lt;/code&gt; are the strings that &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; reports.</source>
          <target state="translated">跟踪更改到Perl的解释器状态。您可以将其内部化，以跟踪对Perl的 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 变量的更改，尤其是因为 &lt;code&gt;NEWPHASE&lt;/code&gt; 和 &lt;code&gt;OLDPHASE&lt;/code&gt; 的值是 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 报告的字符串。</target>
        </trans-unit>
        <trans-unit id="0786ec1507cde8f738cd5528e03a2b67d40c8c91" translate="yes" xml:space="preserve">
          <source>Traces the entry of any subroutine. Note that all of the variables refer to the subroutine that is being invoked; there is currently no way to get ahold of any information about the subroutine's</source>
          <target state="translated">追踪任何子程序的进入。请注意,所有的变量都是指正在被调用的子程序;目前还没有办法获得任何关于子程序的信息。</target>
        </trans-unit>
        <trans-unit id="9f47af59eb569759ff1e8a42a52da14fba8b1705" translate="yes" xml:space="preserve">
          <source>Traces the execution of each opcode in the Perl runloop. This probe is fired before the opcode is executed. When the Perl debugger is enabled, the DTrace probe is fired</source>
          <target state="translated">追踪Perl runloop中每个操作码的执行情况。该探针在操作码执行之前被触发。当启用Perl调试器时,DTrace探针会被触发。</target>
        </trans-unit>
        <trans-unit id="bbb01fbe6bfaaec090a44633982fb31ae18d0d39" translate="yes" xml:space="preserve">
          <source>Traces the exit of any subroutine. Note that all of the variables refer to the subroutine that is returning; there is currently no way to get ahold of any information about the subroutine's</source>
          <target state="translated">追踪任何子程序的退出。请注意,所有的变量都是指正在返回的子程序;目前还没有办法获得任何关于子程序的信息。</target>
        </trans-unit>
        <trans-unit id="469260e080c9b35d7ee5b388f5235f91978c75b9" translate="yes" xml:space="preserve">
          <source>Traditional form:</source>
          <target state="translated">传统形式。</target>
        </trans-unit>
        <trans-unit id="0ad67b0aa9abbb10a0d4b2ca67f1c4ff5d61a0ed" translate="yes" xml:space="preserve">
          <source>Traditionally END blocks have been executed at the end of the perl_run. This causes problems for applications that never call perl_run. Since perl 5.7.2 you can specify &lt;code&gt;PL_exit_flags |= PERL_EXIT_DESTRUCT_END&lt;/code&gt; to get the new behaviour. This also enables the running of END blocks if the perl_parse fails and &lt;code&gt;perl_destruct&lt;/code&gt; will return the exit value.</source>
          <target state="translated">传统上，END块是在perl_run的末尾执行的。这会给永不调用perl_run的应用程序带来问题。从perl 5.7.2开始，您可以指定 &lt;code&gt;PL_exit_flags |= PERL_EXIT_DESTRUCT_END&lt;/code&gt; 以获取新的行为。如果perl_parse失败并且 &lt;code&gt;perl_destruct&lt;/code&gt; 将返回退出值，这还将启用END块的运行。</target>
        </trans-unit>
        <trans-unit id="0f62d4679a2de6656186513ec5b0145dfd0852c8" translate="yes" xml:space="preserve">
          <source>Traditionally in Perl, any use of any of the three variables &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; (or their &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; English&lt;/code&gt; equivalents) anywhere in the code, caused all subsequent successful pattern matches to make a copy of the matched string, in case the code might subsequently access one of those variables. This imposed a considerable performance penalty across the whole program, so generally the use of these variables has been discouraged.</source>
          <target state="translated">传统上，在Perl中，对代码中任何位置的三个变量 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 或 &lt;code&gt;$'&lt;/code&gt; 中的任何一个的使用（或它们 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; English&lt;/code&gt; 等效项）都会导致所有后续的成功模式匹配生成匹配字符串的副本，以防代码随后可能会访问这些变量之一。这对整个程序造成了相当大的性能损失，因此通常不鼓励使用这些变量。</target>
        </trans-unit>
        <trans-unit id="b39057d081d4426f280d8e658ad98c69967c3dee" translate="yes" xml:space="preserve">
          <source>Traditionally in Perl, any use of any of the three variables &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; (or their &lt;code&gt;use English&lt;/code&gt; equivalents) anywhere in the code, caused all subsequent successful pattern matches to make a copy of the matched string, in case the code might subsequently access one of those variables. This imposed a considerable performance penalty across the whole program, so generally the use of these variables has been discouraged.</source>
          <target state="translated">传统上，在Perl中，对代码中任何位置的三个变量 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 或 &lt;code&gt;$'&lt;/code&gt; 中的任何一个（或它们 &lt;code&gt;use English&lt;/code&gt; 等效项）的任何使用，都会导致所有后续的成功模式匹配生成匹配字符串的副本，以防万一代码随后可能会访问这些变量之一。这对整个程序造成了相当大的性能损失，因此通常不鼓励使用这些变量。</target>
        </trans-unit>
        <trans-unit id="edc1e4ae8cd5bdd4ef52be4cd619be47a1e80306" translate="yes" xml:space="preserve">
          <source>Traditionally the result is a string of 13 bytes: two first bytes of the salt, followed by 11 bytes from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt;, and only the first eight bytes of PLAINTEXT mattered. But alternative hashing schemes (like MD5), higher level security schemes (like C2), and implementations on non-Unix platforms may produce different strings.</source>
          <target state="translated">传统上，结果是一个13字节的字符串：salt的两个前字节，然后是集合 &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; 中的11个字节，仅PLAINTEXT的前八个字节很重要。但是替代的哈希方案（如MD5），更高级别的安全方案（如C2）以及在非Unix平台上的实现可能会产生不同的字符串。</target>
        </trans-unit>
        <trans-unit id="366ba2d0971221ce62e3e700bb5e4027a597313b" translate="yes" xml:space="preserve">
          <source>Traditionally, Perl has captured the value of the variable at that point and turned the subroutine into a constant eligible for inlining. In those cases where the variable can be modified elsewhere, this breaks the behavior of closures, in which the subroutine captures the variable itself, rather than its value, so future changes to the variable are reflected in the subroutine's return value.</source>
          <target state="translated">传统上,Perl在这一点上捕获了变量的值,并将子程序变成了一个符合内联条件的常量。在那些变量可以在其他地方修改的情况下,这就打破了闭包的行为,在闭包中,子程序捕获的是变量本身,而不是它的值,因此未来对变量的改变会反映在子程序的返回值中。</target>
        </trans-unit>
        <trans-unit id="77c289ba4e5a8332a82b92e0a687ee8832b65763" translate="yes" xml:space="preserve">
          <source>Traditionally, the Perl function &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; rounds to 0 (see &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;), and so for floating-point-like types one should follow the same semantic.</source>
          <target state="translated">传统上，Perl函数将 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 四舍五入为0（请参阅&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;），因此对于类浮点类型，应遵循相同的语义。</target>
        </trans-unit>
        <trans-unit id="adbc09d928775a73e398c4d99047b6c88a5a75f6" translate="yes" xml:space="preserve">
          <source>Traditionally, the Perl function &lt;code&gt;int&lt;/code&gt; rounds to 0 (see &lt;a href=&quot;perlfunc#int&quot;&gt;&quot;int&quot; in perlfunc&lt;/a&gt;), and so for floating-point-like types one should follow the same semantic.</source>
          <target state="translated">传统上，Perl函数将 &lt;code&gt;int&lt;/code&gt; 舍入为0（请参阅&lt;a href=&quot;perlfunc#int&quot;&gt;perlfunc中的&amp;ldquo; int&amp;rdquo;&lt;/a&gt;），因此对于类似浮点的类型，应该遵循相同的语义。</target>
        </trans-unit>
        <trans-unit id="b2c93accaaddf881f0426884fd5fb319c6e78ef4" translate="yes" xml:space="preserve">
          <source>Traditionally, the definition of an inside-out class contains a bare block inside which a number of lexical hashes are declared and the basic accessor methods defined, usually through &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; . Further methods may be defined outside this block. There has to be a DESTROY method and, for thread support, a CLONE method.</source>
          <target state="translated">传统上，由内而外的类的定义包含一个裸露的块，该块中声明了许多词汇哈希，并定义了基本的访问器方法，通常通过 &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; 。可以在此块之外定义其他方法。必须有一个DESTROY方法，并且为了线程支持，必须有一个CLONE方法。</target>
        </trans-unit>
        <trans-unit id="a7bba9f4132fe6d6098df9712bd5f009714f6811" translate="yes" xml:space="preserve">
          <source>Traditionally, the definition of an inside-out class contains a bare block inside which a number of lexical hashes are declared and the basic accessor methods defined, usually through &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt;. Further methods may be defined outside this block. There has to be a DESTROY method and, for thread support, a CLONE method.</source>
          <target state="translated">传统上，由内而外的类的定义包含一个裸露的块，该块中声明了许多词汇哈希，并定义了基本的访问器方法，通常通过 &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; 。可以在此块之外定义其他方法。必须有一个DESTROY方法，并且为了线程支持，必须有一个CLONE方法。</target>
        </trans-unit>
        <trans-unit id="56e30fa719825fef87897a9b73f8c643d6e27859" translate="yes" xml:space="preserve">
          <source>Traditionally, typemaps needed to be written to a separate file, conventionally called &lt;code&gt;typemap&lt;/code&gt; in a CPAN distribution. With ExtUtils::ParseXS (the XS compiler) version 3.12 or better which comes with perl 5.16, typemaps can also be embedded directly into XS code using a HERE-doc like syntax:</source>
          <target state="translated">传统上，类型映射需要写入一个单独的文件，在CPAN分发中通常称为类型 &lt;code&gt;typemap&lt;/code&gt; 。使用Perl 5.16附带的ExtUtils :: ParseXS（XS编译器）3.12或更高版本，也可以使用类似HERE-doc的语法将类型映射直接嵌入XS代码中：</target>
        </trans-unit>
        <trans-unit id="09f8c62448637990777ebfc05ef92616935bd9ae" translate="yes" xml:space="preserve">
          <source>Trailing \ in regex m/%s/</source>
          <target state="translated">在regex m/%s/中的尾数为&quot;/&quot;。</target>
        </trans-unit>
        <trans-unit id="b116d15c8d0f591aea30acc14d32c8151254d15b" translate="yes" xml:space="preserve">
          <source>Transfer file in ASCII. CRLF translation will be done if required</source>
          <target state="translated">以ASCII码传输文件。如有需要,将进行CRLF翻译。</target>
        </trans-unit>
        <trans-unit id="19b93b66a9a164099cf4c3e60d4b5f7a2c5a7780" translate="yes" xml:space="preserve">
          <source>Transfer file in binary mode. No transformation will be done.</source>
          <target state="translated">以二进制模式传输文件。不会进行转换。</target>
        </trans-unit>
        <trans-unit id="71b54b146f4723aa8db4c8d0ffb0816f4aee31ad" translate="yes" xml:space="preserve">
          <source>Transforms the current application into a PM application and back. The argument true means that a real message loop is going to be served. OS2::MorphPM() returns the PM message queue handle as an integer.</source>
          <target state="translated">将当前应用程序转换为PM应用程序并返回。参数true表示将提供一个真正的消息循环。OS2::MorphPM()以整数形式返回 PM 消息队列句柄。</target>
        </trans-unit>
        <trans-unit id="45a38a062b50bb87ecbfadb79c2d11cbaef46742" translate="yes" xml:space="preserve">
          <source>Transition notes when upgrading to Test2</source>
          <target state="translated">升级到Test2时的过渡说明</target>
        </trans-unit>
        <trans-unit id="3ab5267ee01682b79d53eef55a6ec4c6169897d2" translate="yes" xml:space="preserve">
          <source>Translate logical name DCL$PATH as a searchlist, rather than trying to &lt;code&gt;&lt;a href=&quot;../../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; string value of &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; .</source>
          <target state="translated">将逻辑名称DCL $ PATH转换为搜索列表，而不是尝试 &lt;code&gt;&lt;a href=&quot;../../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; 字符串值。</target>
        </trans-unit>
        <trans-unit id="ff6fe6980843b217b9b010e6374cc31ac52dccf0" translate="yes" xml:space="preserve">
          <source>Translate logical name DCL$PATH as a searchlist, rather than trying to &lt;code&gt;split&lt;/code&gt; string value of &lt;code&gt;$ENV{'PATH'}&lt;/code&gt;.</source>
          <target state="translated">将逻辑名称DCL $ PATH转换为搜索列表，而不是尝试 &lt;code&gt;split&lt;/code&gt; &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; 字符串值。</target>
        </trans-unit>
        <trans-unit id="4df3684f8e1af9f3d36ff43ec1a39944ea62d252" translate="yes" xml:space="preserve">
          <source>Translates a Windows path to the corresponding cygwin path respecting the current mount points. With a second non-null argument returns an absolute path. Double-byte characters will not be translated.</source>
          <target state="translated">在尊重当前挂载点的前提下,将Windows路径转换为相应的cygwin路径。如果使用第二个非空参数,则返回一个绝对路径。双字节字符不会被翻译。</target>
        </trans-unit>
        <trans-unit id="43c8972cdf7cbd4964f60ea0553934fab0c0bfe0" translate="yes" xml:space="preserve">
          <source>Translates a Windows pid to the corresponding cygwin pid (if any).</source>
          <target state="translated">将Windows pid翻译成对应的cygwin pid(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="582d5dcb01cd3d8be49a7bc9c562cc61d6d3a8c7" translate="yes" xml:space="preserve">
          <source>Translates a cygwin path to the corresponding cygwin path respecting the current mount points. With a second non-null argument returns an absolute path. Double-byte characters will not be translated.</source>
          <target state="translated">将一个cygwin路径翻译成与当前挂载点相对应的cygwin路径。如果使用第二个非空参数,则返回一个绝对路径。双字节字符不会被翻译。</target>
        </trans-unit>
        <trans-unit id="d0b7e8b1f9fa64e7df02a610ac8f751cbf79794f" translate="yes" xml:space="preserve">
          <source>Translates a cygwin pid to the corresponding Windows pid (which may or may not be the same).</source>
          <target state="translated">将一个cygwin pid翻译成对应的Windows pid(可能是或可能不是相同的)。</target>
        </trans-unit>
        <trans-unit id="3cb9f5d38a91da3cb24f8ddc9ee0b78bc3316e7d" translate="yes" xml:space="preserve">
          <source>Translates the template as before except that a directory name is specified.</source>
          <target state="translated">除了指定目录名外,其他都和之前一样翻译模板。</target>
        </trans-unit>
        <trans-unit id="0e0c59b2d3a94d773b16fba8c10f9e6b9a4c8d83" translate="yes" xml:space="preserve">
          <source>Translators are available for converting Pod to various formats like plain text, HTML, man pages, and more.</source>
          <target state="translated">翻译器可用于将Pod转换为各种格式,如纯文本、HTML、man pages等。</target>
        </trans-unit>
        <trans-unit id="3d02c52d09a4e30f9d862205070306d13e0fd4bf" translate="yes" xml:space="preserve">
          <source>Translators may request clarification of the situation in which a particular phrase is found. For example, in English we are entirely happy saying &quot;</source>
          <target state="translated">译者可以要求对某一短语的情况进行澄清。例如,在英语中,我们完全乐意说&quot;</target>
        </trans-unit>
        <trans-unit id="7cec7716cf837c5d26e64202c8e48b66fd1ee111" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to &amp;amp;#NNN; where NNN is the decimal Unicode code point.</source>
          <target state="translated">编码为＆＃NNN;时缺少音译字符 其中NNN是十进制Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="4a944de5b3bc5a013582ea0515548fdc64b85e91" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to &amp;amp;#xHHHH; where HHHH is the hexadecimal Unicode code point.</source>
          <target state="translated">编码为＆＃xHHHH;时缺少音译字符 其中HHHH是十六进制Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="7531ab4c38b927cd6bd26046089b6f931f4b9669" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to \x{HHHH} where HHHH is the hexadecimal Unicode code point.</source>
          <target state="translated">将编码中缺失的字符转写为 \x{HHHH},其中HHHH是十六进制Unicode码点。</target>
        </trans-unit>
        <trans-unit id="41fb5a616fd328877f09027e33238e8f08b825a7" translate="yes" xml:space="preserve">
          <source>Transliterates all occurrences of the characters found (or not found if the &lt;code&gt;/c&lt;/code&gt; modifier is specified) in the search list with the positionally corresponding character in the replacement list, possibly deleting some, depending on the modifiers specified. It returns the number of characters replaced or deleted. If no string is specified via the &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator, the &lt;code&gt;$_&lt;/code&gt; string is transliterated.</source>
          <target state="translated">转换在搜索列表中找到的所有出现的字符（如果指定了 &lt;code&gt;/c&lt;/code&gt; 修饰符则找不到），并替换列表中位置相对应的字符，可能会删除某些字符，具体取决于指定的修饰符。它返回替换或删除的字符数。如果没有通过 &lt;code&gt;=~&lt;/code&gt; 或 &lt;code&gt;!~&lt;/code&gt; 运算符指定任何字符串，则 &lt;code&gt;$_&lt;/code&gt; 字符串将被音译。</target>
        </trans-unit>
        <trans-unit id="778ddecb6dcc9c5eac19efad6822ed838d8cfd37" translate="yes" xml:space="preserve">
          <source>Transliterates all occurrences of the characters found in the search list with the corresponding character in the replacement list. It returns the number of characters replaced or deleted. If no string is specified via the &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator, the &lt;code&gt;$_&lt;/code&gt; string is transliterated.</source>
          <target state="translated">用替换列表中的相应字符对所有出现在搜索列表中的字符进行音译。它返回替换或删除的字符数。如果没有通过 &lt;code&gt;=~&lt;/code&gt; 或 &lt;code&gt;!~&lt;/code&gt; 运算符指定任何字符串，则 &lt;code&gt;$_&lt;/code&gt; 字符串将被音译。</target>
        </trans-unit>
        <trans-unit id="31352bae87fe97a737e1fbb74f2d29f6b62133a0" translate="yes" xml:space="preserve">
          <source>Transliteration pattern not terminated</source>
          <target state="translated">翻译模式未结束</target>
        </trans-unit>
        <trans-unit id="a70808fd22f433d5ec8e8c5f0aad4eb5242bb686" translate="yes" xml:space="preserve">
          <source>Transliteration replacement not terminated</source>
          <target state="translated">未终止的翻译替换</target>
        </trans-unit>
        <trans-unit id="420a5e0771ab4a0b9e610c4b35eccba70828962b" translate="yes" xml:space="preserve">
          <source>Transparent BigInteger support for Perl</source>
          <target state="translated">为Perl提供透明的BigInteger支持</target>
        </trans-unit>
        <trans-unit id="7267fd5dd0f2d5cad0d4fdfbc6f406231fbc74c7" translate="yes" xml:space="preserve">
          <source>Transparent BigNumber support for Perl</source>
          <target state="translated">为Perl提供透明的BigNumber支持</target>
        </trans-unit>
        <trans-unit id="d53f15081d775673dd122d267a0fda505ffa50fe" translate="yes" xml:space="preserve">
          <source>Transparent BigNumber/BigRational support for Perl</source>
          <target state="translated">为Perl提供透明的BigNumber/BigRational支持。</target>
        </trans-unit>
        <trans-unit id="1320fa0059bd04032c977af604f63823046e2bca" translate="yes" xml:space="preserve">
          <source>Trappable errors may be trapped using the eval operator. See &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;. In almost all cases, warnings may be selectively disabled or promoted to fatal errors using the &lt;code&gt;warnings&lt;/code&gt; pragma. See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">可以使用eval运算符捕获可陷阱错误。参见&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;。在几乎所有情况下，都可以使用 &lt;code&gt;warnings&lt;/code&gt; 实用程序选择性地禁用警告或将警告升级为致命错误。请参阅&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9594e634fc8d3b1ced220c4bc1c7249b17dcfd33" translate="yes" xml:space="preserve">
          <source>Trappable errors may be trapped using the eval operator. See &lt;a href=&quot;perlfunc#eval&quot;&gt;&quot;eval&quot; in perlfunc&lt;/a&gt;. In almost all cases, warnings may be selectively disabled or promoted to fatal errors using the &lt;code&gt;warnings&lt;/code&gt; pragma. See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">可以使用eval运算符捕获可陷阱错误。请参阅&lt;a href=&quot;perlfunc#eval&quot;&gt;perlfunc中的&amp;ldquo; eval&amp;rdquo;&lt;/a&gt;。在几乎所有情况下，都可以使用 &lt;code&gt;warnings&lt;/code&gt; 实用程序选择性地禁用警告或将警告升级为致命错误。请参阅&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a51ac6ee368e2e9218baa833ba69372fe936aae9" translate="yes" xml:space="preserve">
          <source>Trapping $SIG {__DIE__} other than during program exit.</source>
          <target state="translated">除了在程序退出过程中捕获$SIG {__DIE__}。</target>
        </trans-unit>
        <trans-unit id="17b071b49543aa19f12f2274e32fe9c1ba934844" translate="yes" xml:space="preserve">
          <source>Trapping &lt;code&gt;$SIG {__DIE__}&lt;/code&gt; other than during program exit.</source>
          <target state="translated">捕获 &lt;code&gt;$SIG {__DIE__}&lt;/code&gt; 而不是在程序退出期间捕获。</target>
        </trans-unit>
        <trans-unit id="7f10d4d7cb6294c3306a64ba2969b74200be2428" translate="yes" xml:space="preserve">
          <source>Traverse a directory tree.</source>
          <target state="translated">遍历一个目录树。</target>
        </trans-unit>
        <trans-unit id="b2a99160c9547d1ab75aaa55623e70b1b8573818" translate="yes" xml:space="preserve">
          <source>Treat string as multiple lines. That is, change &quot;^&quot; and &quot;$&quot; from matching the start of the string's first line and the end of its last line to matching the start and end of each line within the string.</source>
          <target state="translated">将字符串视为多行。也就是说,将&quot;^&quot;和&quot;$&quot;从匹配字符串第一行的开始和最后一行的结束改为匹配字符串内每一行的开始和结束。</target>
        </trans-unit>
        <trans-unit id="93fa15e2fd4bd3f0707530f7f374f8fd00c44547" translate="yes" xml:space="preserve">
          <source>Treat string as single line. That is, change &quot;.&quot; to match any character whatsoever, even a newline, which normally it would not match.</source>
          <target state="translated">将字符串视为单行。也就是说,将&quot;.&quot;改为匹配任何字符,即使是换行符,通常也不会匹配。</target>
        </trans-unit>
        <trans-unit id="78e54c9da655d8dd5d453436c311823f0a02dca4" translate="yes" xml:space="preserve">
          <source>Treat the string as single line. That is, change &lt;code&gt;&quot;.&quot;&lt;/code&gt; to match any character whatsoever, even a newline, which normally it would not match.</source>
          <target state="translated">将字符串视为单行。即，更改 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 可以匹配任何字符，甚至是换行符（通常不会匹配）。</target>
        </trans-unit>
        <trans-unit id="72ce43ffe9e36e380be02d47d4ca4755e5f762f0" translate="yes" xml:space="preserve">
          <source>Treat the string being matched against as multiple lines. That is, change &lt;code&gt;&quot;^&quot;&lt;/code&gt; and &lt;code&gt;&quot;$&quot;&lt;/code&gt; from matching the start of the string's first line and the end of its last line to matching the start and end of each line within the string.</source>
          <target state="translated">将匹配的字符串视为多行。也就是说，将 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;$&quot;&lt;/code&gt; 从匹配字符串的第一行的开头和最后一行的末尾更改为匹配字符串中每行的开始和结尾。</target>
        </trans-unit>
        <trans-unit id="13d54adba605a60e729039d50fd8ece1d374030c" translate="yes" xml:space="preserve">
          <source>Treating errors reported by OS/2 API</source>
          <target state="translated">处理OS/2 API报告的错误</target>
        </trans-unit>
        <trans-unit id="369a3fe575602256c74f237530b2066156aadc25" translate="yes" xml:space="preserve">
          <source>Treats ARRAY as a stack by appending the values of LIST to the end of ARRAY. The length of ARRAY increases by the length of LIST. Has the same effect as</source>
          <target state="translated">将ARRAY作为堆栈处理,将LIST的值追加到ARRAY的最后。ARRAY的长度按LIST的长度增加。与</target>
        </trans-unit>
        <trans-unit id="4c2b22d2044144acb2e177299ffb0546b35d1302" translate="yes" xml:space="preserve">
          <source>Treats the complete zip file/buffer as a single compressed data stream. When reading in multi-stream mode each member of the zip file/buffer will be uncompressed in turn until the end of the file/buffer is encountered.</source>
          <target state="translated">将完整的zip文件/缓冲区作为一个单一的压缩数据流处理,当以多流模式读取时,zip文件/缓冲区的每个成员将依次被解压,直到文件/缓冲区结束。当以多流模式读取时,ZIP文件/缓冲区的每个成员将依次被解压缩,直到遇到文件/缓冲区的末端。</target>
        </trans-unit>
        <trans-unit id="9170df3df869288dce7be7560494463cb05b5488" translate="yes" xml:space="preserve">
          <source>Treats the return value of the code block as the condition.</source>
          <target state="translated">将代码块的返回值作为条件。</target>
        </trans-unit>
        <trans-unit id="a635e53ae97925c0c25ad3ddaf7be47457bf89eb" translate="yes" xml:space="preserve">
          <source>Treats the return value of the code block as the condition. Full syntax: &lt;code&gt;(?(?{ &lt;i&gt;code&lt;/i&gt; })&lt;i&gt;then&lt;/i&gt;|&lt;i&gt;else&lt;/i&gt;)&lt;/code&gt;</source>
          <target state="translated">将代码块的返回值视为条件。完整语法： &lt;code&gt;(?(?{ &lt;i&gt;code&lt;/i&gt; })&lt;i&gt;then&lt;/i&gt;|&lt;i&gt;else&lt;/i&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="076fbc2c1d84c79c360a6aaf693ed414200277af" translate="yes" xml:space="preserve">
          <source>Treats the string in EXPR as a bit vector made up of elements of width BITS and returns the value of the element specified by OFFSET as an unsigned integer. BITS therefore specifies the number of bits that are reserved for each element in the bit vector. This must be a power of two from 1 to 32 (or 64, if your platform supports that).</source>
          <target state="translated">将EXPR中的字符串视为由宽度为BITS的元素组成的位向量,并将OFFSET指定的元素值作为无符号整数返回。因此,BITS指定了位向量中每个元素的保留位数。这个数字必须是1到32(或者64,如果你的平台支持的话)的2次幂。</target>
        </trans-unit>
        <trans-unit id="74c726e22e1ef4f0ff5d0f342fa4b671a8d7e3e6" translate="yes" xml:space="preserve">
          <source>Tree Contents</source>
          <target state="translated">树木内容</target>
        </trans-unit>
        <trans-unit id="bc924ad99a31c83efb674a21a76798fdb63e8535" translate="yes" xml:space="preserve">
          <source>Tries to &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; the given $module or $file. If it loads successfully, the test will pass. Otherwise it fails and displays the load error.</source>
          <target state="translated">尝试 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 给定的$ module或$ file。如果加载成功，则测试将通过。否则，它将失败并显示加载错误。</target>
        </trans-unit>
        <trans-unit id="9e432f6da17926a8d04f67b7c7b25438f0d2078a" translate="yes" xml:space="preserve">
          <source>Tries to &lt;code&gt;require&lt;/code&gt; the given $module or $file. If it loads successfully, the test will pass. Otherwise it fails and displays the load error.</source>
          <target state="translated">尝试 &lt;code&gt;require&lt;/code&gt; 给定的$ module或$ file。如果加载成功，则测试将通过。否则，它将失败并显示加载错误。</target>
        </trans-unit>
        <trans-unit id="82437a05f154f78a4ae190392aa21b46338d0c97" translate="yes" xml:space="preserve">
          <source>Tries to uses &lt;a href=&quot;../../../ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; &amp;amp; &lt;a href=&quot;../../../io/select&quot;&gt;IO::Select&lt;/a&gt; to communicate with the spawned process if they are available. Falls back onto &lt;code&gt;&lt;a href=&quot;../../../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尝试使用&lt;a href=&quot;../../../ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt;＆&lt;a href=&quot;../../../io/select&quot;&gt;IO :: Select&lt;/a&gt;与产生的进程进行通信（如果可用）。退回到 &lt;code&gt;&lt;a href=&quot;../../../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="576659556d288e025b94f7ce5ace34cc997c7d54" translate="yes" xml:space="preserve">
          <source>Tries to uses &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; &amp;amp; &lt;a href=&quot;IO::Select&quot;&gt;IO::Select&lt;/a&gt; to communicate with the spawned process if they are available. Falls back onto &lt;code&gt;open()&lt;/code&gt;.</source>
          <target state="translated">尝试使用&lt;a href=&quot;IPC::Open3&quot;&gt;IPC :: Open3&lt;/a&gt;＆&lt;a href=&quot;IO::Select&quot;&gt;IO :: Select&lt;/a&gt;与产生的进程进行通信（如果可用）。退回到 &lt;code&gt;open()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0328d99f96d6b6cb2e5370be4979de91fb2ea44" translate="yes" xml:space="preserve">
          <source>Triggered by a delete from %^H, records the key to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; .</source>
          <target state="translated">由％^ H删除触发，将密钥记录到 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b83192144a37d41cc56666387a2897c4231e185" translate="yes" xml:space="preserve">
          <source>Triggered by a delete from &lt;code&gt;%^H&lt;/code&gt;, records the key to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;%^H&lt;/code&gt; 删除触发，将密钥记录到 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce25e5857867e6310e792d455213353087781834" translate="yes" xml:space="preserve">
          <source>Triggered by a store to %^H, records the key/value pair to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; . It is assumed that hints aren't storing anything that would need a deep copy. Maybe we should warn if we find a reference.</source>
          <target state="translated">由商店触发％^ H，将键/值对记录到 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 。假定提示没有存储任何需要深层复制的内容。如果找到参考，也许我们应该警告。</target>
        </trans-unit>
        <trans-unit id="d308cd2f0c07029bd86f512d81284ed366f6c445" translate="yes" xml:space="preserve">
          <source>Triggered by a store to &lt;code&gt;%^H&lt;/code&gt;, records the key/value pair to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt;. It is assumed that hints aren't storing anything that would need a deep copy. Maybe we should warn if we find a reference.</source>
          <target state="translated">由商店触发 &lt;code&gt;%^H&lt;/code&gt; ，将键/值对记录到 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 。假定提示没有存储任何需要深层复制的内容。如果找到参考，也许我们应该警告。</target>
        </trans-unit>
        <trans-unit id="5e62fd5a7239de339d5bd00c0d3006bd6b133b17" translate="yes" xml:space="preserve">
          <source>Triggered by clearing %^H, resets &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; .</source>
          <target state="translated">通过清除％^ H触发，重置 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b8a309606a54a3100175b28554ebbc2c0bf40e9" translate="yes" xml:space="preserve">
          <source>Triggered by clearing &lt;code&gt;%^H&lt;/code&gt;, resets &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt;.</source>
          <target state="translated">通过清除 &lt;code&gt;%^H&lt;/code&gt; 触发，重置 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">三角函数</target>
        </trans-unit>
        <trans-unit id="ce550b5479caa5cd0ed1b0d59ad15c9773c7bcdb" translate="yes" xml:space="preserve">
          <source>Trilogy, &lt;code&gt;In the beginning the
Universe was created. This has made a lot of people very angry and
been widely regarded as a bad move&lt;/code&gt; . Their mistake was not of this magnitude so let's forgive them.</source>
          <target state="translated">三部曲， &lt;code&gt;In the beginning the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move&lt;/code&gt; 。他们的错误不是那么严重，所以让我们原谅他们。</target>
        </trans-unit>
        <trans-unit id="bd5caa14d9ae02b51776bb926be345cdff071829" translate="yes" xml:space="preserve">
          <source>Trilogy, &lt;code&gt;In the beginning the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move&lt;/code&gt;. Their mistake was not of this magnitude so let's forgive them.</source>
          <target state="translated">三部曲， &lt;code&gt;In the beginning the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move&lt;/code&gt; 。他们的错误不是那么严重，所以让我们原谅他们。</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="28e5d7df36d1a6dde25f3c09a31821344957a89c" translate="yes" xml:space="preserve">
          <source>Troubleshooting these Examples</source>
          <target state="translated">解决这些例子的问题</target>
        </trans-unit>
        <trans-unit id="95a9fcae6cc7c433c5ecb181677d9e65f088ed3c" translate="yes" xml:space="preserve">
          <source>Tru64 5.1 documentation on syslog, &lt;a href=&quot;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&quot;&gt;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&lt;/a&gt;</source>
          <target state="translated">Syslog上的Tru64 5.1文档，&lt;a href=&quot;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&quot;&gt;http：//h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="048a8987b7e7ec2f729db8f1f26dbe354039d137" translate="yes" xml:space="preserve">
          <source>Tru64 documentation on syslog, &lt;a href=&quot;http://nixdoc.net/man-pages/Tru64/man3/syslog.3.html&quot;&gt;http://nixdoc.net/man-pages/Tru64/man3/syslog.3.html&lt;/a&gt;</source>
          <target state="translated">syslog上的Tru64文档，&lt;a href=&quot;http://nixdoc.net/man-pages/Tru64/man3/syslog.3.html&quot;&gt;http：//nixdoc.net/man-pages/Tru64/man3/syslog.3.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23888b0b14d45068fea9c016be17513c2fc8f457" translate="yes" xml:space="preserve">
          <source>True color and aliases are not supported by the constant interface.</source>
          <target state="translated">常数接口不支持真彩和别名。</target>
        </trans-unit>
        <trans-unit id="2032ae3fd0b83aa79eef0ab641b287df415a0ffd" translate="yes" xml:space="preserve">
          <source>True if all testing should be halted immediately.</source>
          <target state="translated">如果应立即停止所有测试,则为真。</target>
        </trans-unit>
        <trans-unit id="9109071ad135094f2373ecd2b94d8dc48e87efa6" translate="yes" xml:space="preserve">
          <source>True if an external</source>
          <target state="translated">如果一个外部</target>
        </trans-unit>
        <trans-unit id="3d8c968cafa644831ebe062927600b2f8922bcb7" translate="yes" xml:space="preserve">
          <source>True if and only if the version object was created with a underscore, e.g.</source>
          <target state="translated">如果且仅当版本对象是以下划线创建的,例如,true。</target>
        </trans-unit>
        <trans-unit id="f3a74362a5094d39f2b42a3da4ab4b28a9691928" translate="yes" xml:space="preserve">
          <source>True if on an OS where qx operator (or backticks) can redirect &lt;code&gt;STDERR&lt;/code&gt; onto &lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">如果在qx运算符（或反引号）可以将 &lt;code&gt;STDERR&lt;/code&gt; 重定向到 &lt;code&gt;STDOUT&lt;/code&gt; 的操作系统上，则为true 。</target>
        </trans-unit>
        <trans-unit id="93fe8e82ddc3a4dc6131ed9782aa5f9370ee777e" translate="yes" xml:space="preserve">
          <source>True if on an OS where qx operator (or backticks) can redirect &lt;code&gt;STDERR&lt;/code&gt; onto &lt;code&gt;STDOUT&lt;/code&gt;.</source>
          <target state="translated">如果在qx运算符（或反引号）可以将 &lt;code&gt;STDERR&lt;/code&gt; 重定向到 &lt;code&gt;STDOUT&lt;/code&gt; 的操作系统上，则为true 。</target>
        </trans-unit>
        <trans-unit id="2ac2287aae7e1950a35f3972fa5317afd518e160" translate="yes" xml:space="preserve">
          <source>True if the &lt;code&gt;callback($hub)&lt;/code&gt; method on the event should be called.</source>
          <target state="translated">如果应在事件上 &lt;code&gt;callback($hub)&lt;/code&gt; 方法，则为true 。</target>
        </trans-unit>
        <trans-unit id="69954ea7da329e8cdabdea3ecd3ac1d75fce20fd" translate="yes" xml:space="preserve">
          <source>True if the assertion passed.</source>
          <target state="translated">如果断言通过,则为真。</target>
        </trans-unit>
        <trans-unit id="df801d4537bfb58354fb108cdce7113cab9309ef" translate="yes" xml:space="preserve">
          <source>True if the event contains diagnostics info. This is useful because a non-verbose harness may choose to hide events that are not in this category. Some formatters may choose to send these to STDERR instead of STDOUT to ensure they are seen.</source>
          <target state="translated">如果事件包含诊断信息,则为真。这一点很有用,因为一个非verbose的线束可能会选择隐藏不属于这个类别的事件。有些格式化程序可能会选择将这些事件发送到STDERR而不是STDOUT,以确保它们被看到。</target>
        </trans-unit>
        <trans-unit id="54a8b59f97958ff045f6c01f8b83b5a2e2ebdf5c" translate="yes" xml:space="preserve">
          <source>True if the event is global in nature and should be seen by all hubs.</source>
          <target state="translated">如果该事件是全局性的,并且应该被所有的中心看到,则为真。</target>
        </trans-unit>
        <trans-unit id="edd2a61baedabf880cbaef8af523d638bf533482" translate="yes" xml:space="preserve">
          <source>True if the event should be skipped by formatters.</source>
          <target state="translated">如果该事件应被格式化程序跳过,则为真。</target>
        </trans-unit>
        <trans-unit id="0ea7f713bb50ee451a6daabd00c2427e62cfb9f7" translate="yes" xml:space="preserve">
          <source>True if the event was buffered and not sent to the formatter independent of a parent (This should never be set when nested is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;undef&lt;/code&gt;).</source>
          <target state="translated">如果事件被缓冲且未发送给独立于父级的格式化程序，则为true（当nested为 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;undef&lt;/code&gt; 时，永远不应设置该事件）。</target>
        </trans-unit>
        <trans-unit id="52369ee8420cce3f1adcdcc979064876449bf33b" translate="yes" xml:space="preserve">
          <source>True if the socket is currently positioned at the urgent data mark, false otherwise.</source>
          <target state="translated">如果当前套接字定位在紧急数据标记处,则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="eac6f6323bc5d7181c78c2fb3ebd2b5d82dd47f8" translate="yes" xml:space="preserve">
          <source>True if the socket is currently positioned at the urgent data mark, false otherwise. If your system doesn't yet implement &lt;code&gt;sockatmark&lt;/code&gt; this will throw an exception.</source>
          <target state="translated">如果套接字当前位于紧急数据标记处，则为true，否则为false。如果您的系统尚未实现 &lt;code&gt;sockatmark&lt;/code&gt; 则将引发异常。</target>
        </trans-unit>
        <trans-unit id="263df4a03022b2922b4599d5befe15e4f094944e" translate="yes" xml:space="preserve">
          <source>True if the source has meta data.</source>
          <target state="translated">如果源有元数据,则为真。</target>
        </trans-unit>
        <trans-unit id="1060dac952d58237b926360d8015317b306f2cf6" translate="yes" xml:space="preserve">
          <source>True if the subtest is buffered (meaning the formatter has probably not seen them yet).</source>
          <target state="translated">如果子测试是缓冲的(意味着格式化器可能还没有看到它们),则为真。</target>
        </trans-unit>
        <trans-unit id="ead298b6e06af0e6aa6b218dfc1434b74a59946d" translate="yes" xml:space="preserve">
          <source>True if the subtest is buffered, that is all subevents render at once. If this is false it means all subevents render as they are produced.</source>
          <target state="translated">如果子测试是缓冲的,则为真,即所有的子事件同时呈现。如果为false,则意味着所有的子事件都会在生成时呈现。</target>
        </trans-unit>
        <trans-unit id="f4532ad71a145630727fdc99e9e7077d2ca07a8f" translate="yes" xml:space="preserve">
          <source>True if the system can really fork. This will be false for systems where fork is emulated.</source>
          <target state="translated">如果系统真的可以fork,则为true。对于模拟fork的系统,这个值为false。</target>
        </trans-unit>
        <trans-unit id="a5626c52704625d46d51a67bed3154dc66584552" translate="yes" xml:space="preserve">
          <source>True if the testing has ended. This MAY return the stack frame of the tool that ended the test, but that is not guaranteed.</source>
          <target state="translated">如果测试已经结束,则返回true。这可能会返回结束测试的工具的堆栈框架,但这是不保证的。</target>
        </trans-unit>
        <trans-unit id="001c945275af8c53e929fc8bb52b9331e9fa2beb" translate="yes" xml:space="preserve">
          <source>True if this op will be the return value of an lvalue subroutine</source>
          <target state="translated">如果这个操作是一个lvalue子程序的返回值,则为true。</target>
        </trans-unit>
        <trans-unit id="407715ca6f2feb3c98182b0f933855e8539ff50e" translate="yes" xml:space="preserve">
          <source>True if this system is capable of true or pseudo-fork.</source>
          <target state="translated">如果这个系统能够真假分叉,则为真。</target>
        </trans-unit>
        <trans-unit id="0d5d7ce97ba71eed0cb8d5f95d0b08ebce27950e" translate="yes" xml:space="preserve">
          <source>True if this system is capable of using threads.</source>
          <target state="translated">如果这个系统能够使用线程,则为真。</target>
        </trans-unit>
        <trans-unit id="a225ab817ea7fa5d168aaeda6fa091c3d9bf26a1" translate="yes" xml:space="preserve">
          <source>True is returned if the file name begins with &lt;code&gt;drive_letter:&lt;/code&gt; , and if not, File::Spec::Unix file_name_is_absolute() is called.</source>
          <target state="translated">如果文件名以 &lt;code&gt;drive_letter:&lt;/code&gt; 开头，则返回True ，否则，返回File :: Spec :: Unix file_name_is_absolute（）。</target>
        </trans-unit>
        <trans-unit id="feb89466cc01669fa065abcba450c743f09dda61" translate="yes" xml:space="preserve">
          <source>True is returned if the file name begins with &lt;code&gt;drive_letter:&lt;/code&gt;, and if not, File::Spec::Unix file_name_is_absolute() is called.</source>
          <target state="translated">如果文件名以 &lt;code&gt;drive_letter:&lt;/code&gt; 开头，则返回True ，否则，返回File :: Spec :: Unix file_name_is_absolute（）。</target>
        </trans-unit>
        <trans-unit id="fc30aa25ff3d01d64cda3e60440cb70eb23d7d54" translate="yes" xml:space="preserve">
          <source>True only if the version object is a dotted-decimal version, e.g.</source>
          <target state="translated">只有当版本对象是点-十进制版本时,才会为真,例如。</target>
        </trans-unit>
        <trans-unit id="714a51854b847f734d4ad3e61a135b245522aeae" translate="yes" xml:space="preserve">
          <source>True while the most recent result was a TODO. Becomes true before the TODO result is returned and stays true until just before the next non- TODO test is returned.</source>
          <target state="translated">当最近的结果是TODO时为真。在TODO结果返回之前变为真,并保持真,直到下一个非TODO测试返回之前。</target>
        </trans-unit>
        <trans-unit id="1aceee4ee4f49927d115b3fc82be6c512d7c286c" translate="yes" xml:space="preserve">
          <source>True/false results are never tainted.</source>
          <target state="translated">真/假结果永远不会被污染。</target>
        </trans-unit>
        <trans-unit id="f8dc96e0b59ea3e8174d5b669fb89eb4295305d3" translate="yes" xml:space="preserve">
          <source>Truncate $x to an integer value.</source>
          <target state="translated">将$x截断为一个整数值。</target>
        </trans-unit>
        <trans-unit id="191dfbc6a35e73fdb5087a2421ab0ece27f48615" translate="yes" xml:space="preserve">
          <source>Truncate at end-of-file.</source>
          <target state="translated">在文件末尾截断。</target>
        </trans-unit>
        <trans-unit id="11625b03167a879105d56ac5232340fe7c1e8727" translate="yes" xml:space="preserve">
          <source>Truncate file suggested by open mode.</source>
          <target state="translated">按打开模式建议截断文件。</target>
        </trans-unit>
        <trans-unit id="7b41166934a48e946fe5af0522939c8c4005a23a" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; on error.</source>
          <target state="translated">将在FILEHANDLE上打开的文件或由EXPR命名的文件截断为指定的长度。如果未在系统上实现截断，则引发异常。如果成功，则返回true，如果出错则返回&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69983876ff90a7fef773e08a772b817cd9bc808d" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">将在FILEHANDLE上打开的文件或由EXPR命名的文件截断为指定的长度。如果未在系统上实现截断，则引发异常。如果成功，则返回true，否则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6b7268dfdb3e49fbc8b9714eadb8dee9d853cfb" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">将在FILEHANDLE上打开的文件或由EXPR命名的文件截断为指定的长度。如果未在系统上实现截断，则引发异常。如果成功，则返回true，否则返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59f6a9fc2fffb15b78c0b81473cdfd56174958cf" translate="yes" xml:space="preserve">
          <source>Truncation</source>
          <target state="translated">Truncation</target>
        </trans-unit>
        <trans-unit id="2975c0f92fcae4101065548cc1a5e6bfa7744574" translate="yes" xml:space="preserve">
          <source>Truncation to same-or-shorter lengths only. (VOS)</source>
          <target state="translated">只截断到相同或较短的长度。(VOS)</target>
        </trans-unit>
        <trans-unit id="07fcbd4e35869ee7c3769699235ad97c3caf7ea4" translate="yes" xml:space="preserve">
          <source>Truth and Falsehood</source>
          <target state="translated">真相与假象</target>
        </trans-unit>
        <trans-unit id="0ea36a88c9652f7de32e4b8cdc539660f9c8bb67" translate="yes" xml:space="preserve">
          <source>Truth. (&lt;code&gt;PL_sv_yes&lt;/code&gt; ) The value is not needed (and ignored).</source>
          <target state="translated">真相。（ &lt;code&gt;PL_sv_yes&lt;/code&gt; ）不需要（忽略）该值。</target>
        </trans-unit>
        <trans-unit id="fec0d66775a5a838fdce0113e0fc71a37b212e7d" translate="yes" xml:space="preserve">
          <source>Truth. (&lt;code&gt;PL_sv_yes&lt;/code&gt;) The value is not needed (and ignored).</source>
          <target state="translated">真相。（ &lt;code&gt;PL_sv_yes&lt;/code&gt; ）不需要（忽略）该值。</target>
        </trans-unit>
        <trans-unit id="820aa128934b824418f5ca61678f5828e0a9f3f1" translate="yes" xml:space="preserve">
          <source>Try 'which ld' and 'which ld' (or try 'ar --version' and 'ld --version', which work only for the GNU tools, and will announce themselves to be such), and adjust your PATH so that you are consistently using either the native tools or the GNU tools. After fixing your PATH, you should do 'make distclean' and start all the way from running the Configure since you may have quite a confused situation.</source>
          <target state="translated">试试 &quot;which ld &quot;和 &quot;which ld&quot;(或者试试 &quot;ar --version &quot;和 &quot;ld --version&quot;,它们只对GNU工具有效,而且会自报家门),然后调整你的PATH,使你始终使用本地工具或GNU工具。修正PATH后,你应该执行'make distclean',然后从运行Configure开始,因为你可能会遇到相当混乱的情况。</target>
        </trans-unit>
        <trans-unit id="98c21aef49a5ddf4f1e39c55f7f2477e1906d688" translate="yes" xml:space="preserve">
          <source>Try &lt;code&gt;perldoc Amiga::ARexx&lt;/code&gt; for more info.</source>
          <target state="translated">尝试 &lt;code&gt;perldoc Amiga::ARexx&lt;/code&gt; 了解更多信息。</target>
        </trans-unit>
        <trans-unit id="8e033ddf358a130409c1ab5546e94f94b80bcb2f" translate="yes" xml:space="preserve">
          <source>Try &lt;code&gt;perldoc Amiga::Exec&lt;/code&gt; for more info.</source>
          <target state="translated">有关更多信息，请尝试 &lt;code&gt;perldoc Amiga::Exec&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfec8d0f349c3c42fb9d1815573a589ac82ef522" translate="yes" xml:space="preserve">
          <source>Try and match a closing delimiter bracket. If the bracket was the same species as the last opening bracket, return the substring to that point. If the bracket was mismatched, return an error.</source>
          <target state="translated">试着匹配一个关闭的分隔符括号。如果括号与最后一个打开的括号是同一物种,返回到该点的子串。如果括号不匹配,则返回一个错误。</target>
        </trans-unit>
        <trans-unit id="3534e8ec8243f82da173a0a961f29a6061ccc5a4" translate="yes" xml:space="preserve">
          <source>Try every conceivable way to get hostname</source>
          <target state="translated">尝试所有能想到的方法来获取主机名。</target>
        </trans-unit>
        <trans-unit id="dfea66ec3b5d472c8a85f9f4143d2c2a2932e7a3" translate="yes" xml:space="preserve">
          <source>Try hard not to exceed 79-columns</source>
          <target state="translated">尽量不要超过79列</target>
        </trans-unit>
        <trans-unit id="71156f6966e318bbb69b3350da865612c3413590" translate="yes" xml:space="preserve">
          <source>Try keeping around the seekpointer and go there, like this:</source>
          <target state="translated">试着保持在seekpointer周围,然后去那里,像这样。</target>
        </trans-unit>
        <trans-unit id="5ab49ef558819708ac26895c52750c3610705d02" translate="yes" xml:space="preserve">
          <source>Try not to launch headlong into developing your module without spending some time thinking first. A little forethought may save you a vast amount of effort later on.</source>
          <target state="translated">尽量不要在没有先花一些时间思考的情况下,就一头扎进开发你的模块。一点点的预想可能会让你以后省去大量的精力。</target>
        </trans-unit>
        <trans-unit id="66c86b400f1e32f25dbc921f7ed16eeea4ab2376" translate="yes" xml:space="preserve">
          <source>Try the &lt;a href=&quot;Net::FTP&quot;&gt;Net::FTP&lt;/a&gt;, &lt;a href=&quot;TCP::Client&quot;&gt;TCP::Client&lt;/a&gt;, and &lt;a href=&quot;Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; modules (available from CPAN). &lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt; will also help for emulating the telnet protocol, but &lt;a href=&quot;Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; is quite probably easier to use.</source>
          <target state="translated">尝试使用&lt;a href=&quot;Net::FTP&quot;&gt;Net :: FTP&lt;/a&gt;，&lt;a href=&quot;TCP::Client&quot;&gt;TCP :: Client&lt;/a&gt;和&lt;a href=&quot;Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt;模块（可从CPAN获得）。&lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt;也将有助于模拟telnet协议，但是&lt;a href=&quot;Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt;可能更易于使用。</target>
        </trans-unit>
        <trans-unit id="1a2b567df2700cceb3e59d9f8a3eb3ca3092a77c" translate="yes" xml:space="preserve">
          <source>Try the &lt;a href=&quot;net/ftp&quot;&gt;Net::FTP&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/TCP::Client&quot;&gt;TCP::Client&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; modules (available from CPAN). &lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt; will also help for emulating the telnet protocol, but &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; is quite probably easier to use.</source>
          <target state="translated">尝试使用&lt;a href=&quot;net/ftp&quot;&gt;Net :: FTP&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/TCP::Client&quot;&gt;TCP :: Client&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt;模块（可从CPAN获得）。&lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt;也将有助于模拟telnet协议，但是&lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt;可能更易于使用。</target>
        </trans-unit>
        <trans-unit id="87f2df3af873276d11f18dcdfa6067907516ef82" translate="yes" xml:space="preserve">
          <source>Try the first alternative in the first group 'abd'.</source>
          <target state="translated">试试第一组的第一个备选方案'abd'。</target>
        </trans-unit>
        <trans-unit id="8fdc9fd893f9837a30290ddcdb863de474cd49f7" translate="yes" xml:space="preserve">
          <source>Try the native, UDP socket then UNIX domain socket mechanisms:</source>
          <target state="translated">试试本机、UDP套接字然后UNIX域套接字机制。</target>
        </trans-unit>
        <trans-unit id="6a75e271162bdc3d061e3493d3ce114d627fc256" translate="yes" xml:space="preserve">
          <source>Try the resources in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;.</source>
          <target state="translated">试用&lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2中&lt;/a&gt;的资源。</target>
        </trans-unit>
        <trans-unit id="aacef041b76d57895de9d7f5cee32482707bd3b3" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict qw(...);&lt;/code&gt; ). Remember that you can add &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict qw(...);&lt;/code&gt; to individual blocks of code that need less strictness.</source>
          <target state="translated">尝试 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict qw(...);&lt;/code&gt; ）。请记住，您不能添加 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict qw(...);&lt;/code&gt; 不需要那么严格的单个代码块。</target>
        </trans-unit>
        <trans-unit id="dbe02bedd5bb36eab5b4bbe32b7d4940cf95d2ec" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings qw(...);&lt;/code&gt; ). Remember that you can add &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(...);&lt;/code&gt; to individual blocks of code that need less warnings.</source>
          <target state="translated">尝试 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings qw(...);&lt;/code&gt; ）。请记住，您不能添加 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(...);&lt;/code&gt; 到需要较少警告的单个代码块。</target>
        </trans-unit>
        <trans-unit id="38b826b6e348509b8760d8f24eae463b23ce7bf6" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;use strict;&lt;/code&gt; (or &lt;code&gt;use strict qw(...);&lt;/code&gt;). Remember that you can add &lt;code&gt;no strict qw(...);&lt;/code&gt; to individual blocks of code that need less strictness.</source>
          <target state="translated">尝试 &lt;code&gt;use strict;&lt;/code&gt; （或 &lt;code&gt;use strict qw(...);&lt;/code&gt; ）。请记住，您不能添加 &lt;code&gt;no strict qw(...);&lt;/code&gt; 到需要较少严格性的单个代码块。</target>
        </trans-unit>
        <trans-unit id="2bf7f5a326028f0c812e9c509d8082b45d0e5a3e" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;use warnings;&lt;/code&gt; (or &lt;code&gt;use warnings qw(...);&lt;/code&gt;). Remember that you can add &lt;code&gt;no warnings qw(...);&lt;/code&gt; to individual blocks of code that need less warnings.</source>
          <target state="translated">尝试 &lt;code&gt;use warnings;&lt;/code&gt; （或 &lt;code&gt;use warnings qw(...);&lt;/code&gt; ）。请记住，您不能添加 &lt;code&gt;no warnings qw(...);&lt;/code&gt; 到需要较少警告的单个代码块。</target>
        </trans-unit>
        <trans-unit id="1a50d23e31ca789a858a654feff08b918836c974" translate="yes" xml:space="preserve">
          <source>Try to color output. See &lt;a href=&quot;../tap/formatter/base#new&quot;&gt;new in TAP::Formatter::Base&lt;/a&gt;.</source>
          <target state="translated">尝试彩色输出。参见&lt;a href=&quot;../tap/formatter/base#new&quot;&gt;TAP :: Formatter :: Base中的新增内容&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56802a31d085c41de140ede22328a67086473d5e" translate="yes" xml:space="preserve">
          <source>Try to color output. See &lt;a href=&quot;TAP::Formatter::Base#new&quot;&gt;&quot;new&quot; in TAP::Formatter::Base&lt;/a&gt;.</source>
          <target state="translated">尝试彩色输出。请参阅&lt;a href=&quot;TAP::Formatter::Base#new&quot;&gt;TAP :: Formatter :: Base中的&amp;ldquo;新&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e97a54a5e20ef4c3c124d4963b017c39c1dad7b" translate="yes" xml:space="preserve">
          <source>Try to design the new module to be easy to extend and reuse.</source>
          <target state="translated">尽量将新模块设计成易于扩展和复用。</target>
        </trans-unit>
        <trans-unit id="220ea4d529b6fa37d1fa97bbb19f2fed77ce5e5b" translate="yes" xml:space="preserve">
          <source>Try to determine name of extension being built. We begin with the name of the current directory. Since VMS filenames are case-insensitive, however, we look for a</source>
          <target state="translated">尝试确定正在构建的扩展名。我们从当前目录的名称开始。由于VMS文件名是不区分大小写的,因此,我们寻找一个</target>
        </trans-unit>
        <trans-unit id="909a91fc6d3b48263691b246eef6c09eb4ec3bfc" translate="yes" xml:space="preserve">
          <source>Try to determine the width of the screen and the bold and underline sequences for the terminal from termcap, and use that information in formatting the output. Output will be wrapped at two columns less than the width of your terminal device. Using this option requires that your system have a termcap file somewhere where Term::Cap can find it and requires that your system support termios. With this option, the output of &lt;b&gt;pod2text&lt;/b&gt; will contain terminal control sequences for your current terminal type.</source>
          <target state="translated">尝试从termcap确定屏幕的宽度以及终端的粗体和下划线序列，并在格式化输出时使用该信息。输出将包裹在小于终端设备宽度的两列中。使用此选项要求您的系统在Term :: Cap可以找到的地方有一个termcap文件，并要求您的系统支持termios。使用此选项，&lt;b&gt;pod2text&lt;/b&gt;的输出将包含您当前终端类型的终端控制序列。</target>
        </trans-unit>
        <trans-unit id="08f15a05901602892a511e670ab4aa0307df4226" translate="yes" xml:space="preserve">
          <source>Try to document your code and use Pod formatting in a consistent way. Here are commonly expected conventions:</source>
          <target state="translated">尽量以一致的方式记录你的代码和使用Pod格式。以下是通常预期的约定。</target>
        </trans-unit>
        <trans-unit id="c88c728349f5a2409f402906caa2d933f74c0865" translate="yes" xml:space="preserve">
          <source>Try to match a quote or quotelike operator. If found, call &lt;code&gt;extract_quotelike&lt;/code&gt; to eat it. If &lt;code&gt;extract_quotelike&lt;/code&gt; fails, return the error it returned. Otherwise go back to step 1.</source>
          <target state="translated">尝试匹配一个quote或quotelike运算符。如果找到，请调用 &lt;code&gt;extract_quotelike&lt;/code&gt; 食用。如果 &lt;code&gt;extract_quotelike&lt;/code&gt; 失败，则返回它返回的错误。否则，请返回步骤1。</target>
        </trans-unit>
        <trans-unit id="fed009e07cf40a3bfaccb23b101b1df3951ecefd" translate="yes" xml:space="preserve">
          <source>Try to match an opening delimiter bracket. If found, call &lt;code&gt;extract_codeblock&lt;/code&gt; recursively to eat the embedded block. If the recursive call fails, return an error. Otherwise, go back to step 1.</source>
          <target state="translated">尝试匹配一个分隔符。如果找到，则递归调用 &lt;code&gt;extract_codeblock&lt;/code&gt; 来吃嵌入式块。如果递归调用失败，则返回错误。否则，请返回步骤1。</target>
        </trans-unit>
        <trans-unit id="1bf160ae95bc79040defdb4258d5fad8caa20a29" translate="yes" xml:space="preserve">
          <source>Try to obtain the latest version of the Windows SDK. Sometimes these packages contain a particular Windows OS version in their name, but actually work on other OS versions too. For example, the &quot;Windows Server 2003 R2 Platform SDK&quot; also runs on Windows XP SP2 and Windows 2000.</source>
          <target state="translated">尝试获取最新版本的Windows SDK。有时,这些软件包的名称中包含一个特定的Windows操作系统版本,但实际上也可以在其他操作系统版本上运行。例如,&quot;Windows Server 2003 R2 Platform SDK &quot;也可以在Windows XP SP2和Windows 2000上运行。</target>
        </trans-unit>
        <trans-unit id="962ca701cc2570a663505435d963dc55f234f4d9" translate="yes" xml:space="preserve">
          <source>Trying to create a new child with a previous child still active (i.e., &lt;code&gt;finalize&lt;/code&gt; not called) will &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">尝试创建一个新的孩子并使其先前的孩子仍然处于活动状态（即，未调用 &lt;code&gt;finalize&lt;/code&gt; ）将 &lt;code&gt;croak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0c592184c4820418323672dd4337df40c4098b0" translate="yes" xml:space="preserve">
          <source>Trying to do too much</source>
          <target state="translated">试图做得太多</target>
        </trans-unit>
        <trans-unit id="44d272c0c6193575553012dfbe62f22573eeb82f" translate="yes" xml:space="preserve">
          <source>Trying to run a test when you have an open child will also &lt;code&gt;croak&lt;/code&gt; and cause the test suite to fail.</source>
          <target state="translated">当您有一个开放的孩子时，尝试运行测试也会 &lt;code&gt;croak&lt;/code&gt; 并导致测试套件失败。</target>
        </trans-unit>
        <trans-unit id="e1251ee8a07b3dea6c343e31961e5913e11f0ce3" translate="yes" xml:space="preserve">
          <source>Tune the internal settings for the deflate object &lt;code&gt;$d&lt;/code&gt; . This option is only available if you are running zlib 1.2.2.3 or better.</source>
          <target state="translated">调整deflate对象 &lt;code&gt;$d&lt;/code&gt; 的内部设置。仅当您运行zlib 1.2.2.3或更高版本时，此选项才可用。</target>
        </trans-unit>
        <trans-unit id="3896985029531ee0a442a6eafffd21b16e99bab0" translate="yes" xml:space="preserve">
          <source>Tune the internal settings for the deflate object &lt;code&gt;$d&lt;/code&gt;. This option is only available if you are running zlib 1.2.2.3 or better.</source>
          <target state="translated">调整deflate对象 &lt;code&gt;$d&lt;/code&gt; 的内部设置。仅当您运行zlib 1.2.2.3或更高版本时，此选项才可用。</target>
        </trans-unit>
        <trans-unit id="008eee580921a65a5e935994d388ebe43c6df0cd" translate="yes" xml:space="preserve">
          <source>Tuning the way RESOLVE_SYMLINK will works</source>
          <target state="translated">调整RESOLVE_SYMLINK的工作方式。</target>
        </trans-unit>
        <trans-unit id="8c3f4c8cc5ca57e1d0107a8c0347eb3646189c97" translate="yes" xml:space="preserve">
          <source>Tunnelling &lt;code&gt;https&lt;/code&gt; over an &lt;code&gt;http&lt;/code&gt; proxy using the CONNECT method is supported. If your proxy uses &lt;code&gt;https&lt;/code&gt; itself, you can not tunnel &lt;code&gt;https&lt;/code&gt; over it.</source>
          <target state="translated">支持使用CONNECT方法通过 &lt;code&gt;http&lt;/code&gt; 代理隧道 &lt;code&gt;https&lt;/code&gt; 。如果您的代理服务器本身使用 &lt;code&gt;https&lt;/code&gt; ，则无法在其上通过隧道发送 &lt;code&gt;https&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7153e6702b4ea48c7c0d01affdef0e1b39fd6dc" translate="yes" xml:space="preserve">
          <source>Turkey</source>
          <target state="translated">Turkey</target>
        </trans-unit>
        <trans-unit id="f7db0bf3a9c02aa40e34f07d8431257fcf327327" translate="yes" xml:space="preserve">
          <source>Turn =head1 directives into links pointing to the top of the HTML file.</source>
          <target state="translated">将=head1指令变成指向HTML文件顶部的链接。</target>
        </trans-unit>
        <trans-unit id="00eb812c53d2b2fc577cde21da51d4b0a2dbeaba" translate="yes" xml:space="preserve">
          <source>Turn IPC off</source>
          <target state="translated">关闭IPC</target>
        </trans-unit>
        <trans-unit id="33f87dc87ea378d835e56e5bfd248ea1a352c832" translate="yes" xml:space="preserve">
          <source>Turn Pod into XML</source>
          <target state="translated">将Pod转为XML</target>
        </trans-unit>
        <trans-unit id="8e7cc74dfcc71c13798fc4a8a0bda3cb164ed4c1" translate="yes" xml:space="preserve">
          <source>Turn Pod::Simple events into method calls</source>
          <target state="translated">将Pod::Simple事件转化为方法调用</target>
        </trans-unit>
        <trans-unit id="87a4a4a475f00352f77a10d3ec1fd9eee936c4ee" translate="yes" xml:space="preserve">
          <source>Turn off Apple tar's tendency to copy resource forks as &quot;._foo&quot; files.</source>
          <target state="translated">关闭 Apple tar 将资源叉复制为&quot;._foo &quot;文件的倾向。</target>
        </trans-unit>
        <trans-unit id="002da87886e80eee99a8ca6dc4e3fe4cabdcf032" translate="yes" xml:space="preserve">
          <source>Turn off CPAN.pm's attempts to lock anything. You should be careful with this since you might end up with multiple scripts trying to muck in the same directory. This isn't so much of a concern if you're loading a special config with &lt;code&gt;-j&lt;/code&gt;, and that config sets up its own work directories.</source>
          <target state="translated">关闭CPAN.pm的尝试锁定任何内容。您应该对此小心谨慎，因为您可能最终会遇到多个试图在同一个目录中混入脚本的脚本。如果您要使用 &lt;code&gt;-j&lt;/code&gt; 加载特殊配置，则不必担心，该配置会设置自己的工作目录。</target>
        </trans-unit>
        <trans-unit id="75c822c937f705b4f59deefb9b7306dfc70d6869" translate="yes" xml:space="preserve">
          <source>Turn off IPC polling.</source>
          <target state="translated">关闭IPC投票。</target>
        </trans-unit>
        <trans-unit id="a5f985f0fcda86b1c258609df3d266b43ed8ce4a" translate="yes" xml:space="preserve">
          <source>Turn on IPC for threading or forking support.</source>
          <target state="translated">开启IPC以支持螺纹或分叉。</target>
        </trans-unit>
        <trans-unit id="48d8224908b27731eb611ee5800a332f08bd6efe" translate="yes" xml:space="preserve">
          <source>Turn on colour in Test::Builder::Tester</source>
          <target state="translated">在 Test::Builder::Tester 中打开颜色。</target>
        </trans-unit>
        <trans-unit id="33bdb8453820e783c9ed80ead4da0eab3e622342" translate="yes" xml:space="preserve">
          <source>Turn on cpan warnings. This checks various things, like directory permissions, and tells you about problems you might have.</source>
          <target state="translated">打开cpan警告。这会检查各种东西,比如目录权限,并告诉你可能存在的问题。</target>
        </trans-unit>
        <trans-unit id="3aaaf6cc176020f3991943f2032de33eccbdb645" translate="yes" xml:space="preserve">
          <source>Turn on debugging messages.</source>
          <target state="translated">开启调试信息。</target>
        </trans-unit>
        <trans-unit id="987617e4099bb6d10ab491d6ac24dec67dd616d3" translate="yes" xml:space="preserve">
          <source>Turn on polling. This will cull events from other processes and threads every time a context is created.</source>
          <target state="translated">开启轮询。这将在每次创建上下文时从其他进程和线程中提取事件。</target>
        </trans-unit>
        <trans-unit id="c5afa3624933dbb94708b864157bd75149a4bc45" translate="yes" xml:space="preserve">
          <source>Turn on the UTF-8 status of an SV (the data is not changed, just the flag). Do not use frivolously.</source>
          <target state="translated">开启SV的UTF-8状态(数据不改变,只是标志)。不要轻率使用。</target>
        </trans-unit>
        <trans-unit id="58ffd65543f8495b744e9f3f6c44eb3bd2d31977" translate="yes" xml:space="preserve">
          <source>Turn on the escaping of characters as described in the SPACES AND TABS section.</source>
          <target state="translated">打开字符的转义,如空格和TABS部分所述。</target>
        </trans-unit>
        <trans-unit id="9903e627171cb3011421fef7af4a686d6ebc3e08" translate="yes" xml:space="preserve">
          <source>Turn on/off printing of warnings. Repeating &lt;b&gt;-warnings&lt;/b&gt; increases the warning level, i.e. more warnings are printed. Currently increasing to level two causes flagging of unescaped &quot;&amp;lt;,&amp;gt;&quot; characters.</source>
          <target state="translated">打开/关闭警告打印。重复&lt;b&gt;警告会&lt;/b&gt;提高警告级别，即打印更多警告。当前增加到第二级会导致标记未转义的&amp;ldquo; &amp;lt;，&amp;gt;&amp;rdquo;字符。</target>
        </trans-unit>
        <trans-unit id="d7dd646019946f4186b2c9415767806d113e6794" translate="yes" xml:space="preserve">
          <source>Turn warnings on/off.</source>
          <target state="translated">打开/关闭警告。</target>
        </trans-unit>
        <trans-unit id="4c628137dd54154b5661d62a2c76528177ce2c0e" translate="yes" xml:space="preserve">
          <source>Turning on one of the character set flags with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; takes precedence over the &lt;code&gt;locale&lt;/code&gt; pragma and the 'unicode_strings' &lt;code&gt;feature&lt;/code&gt; , for regular expressions. Turning off one of these flags when it is active reverts to the behaviour specified by whatever other pragmata are in scope. For example:</source>
          <target state="translated">对于正则表达式， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; 打开一个字符集标志的优先级高于 &lt;code&gt;locale&lt;/code&gt; 编译指示和&amp;ldquo; unicode_strings&amp;rdquo; &lt;code&gt;feature&lt;/code&gt; 。当这些标志之一处于活动状态时将其关闭，将恢复为其他范围内的杂物所指定的行为。例如：</target>
        </trans-unit>
        <trans-unit id="bab3f5ad74d31e2186209289e3cd6bd581941efe" translate="yes" xml:space="preserve">
          <source>Turning on one of the character set flags with &lt;code&gt;use re&lt;/code&gt; takes precedence over the &lt;code&gt;locale&lt;/code&gt; pragma and the 'unicode_strings' &lt;code&gt;feature&lt;/code&gt;, for regular expressions. Turning off one of these flags when it is active reverts to the behaviour specified by whatever other pragmata are in scope. For example:</source>
          <target state="translated">对于正则表达式， &lt;code&gt;use re&lt;/code&gt; 打开一个字符集标志的优先级高于 &lt;code&gt;locale&lt;/code&gt; 编译指示和&amp;ldquo; unicode_strings&amp;rdquo; &lt;code&gt;feature&lt;/code&gt; 。当这些标志之一处于活动状态时将其关闭，将恢复为其他杂用函数所作用域所指定的行为。例如：</target>
        </trans-unit>
        <trans-unit id="1dac2f62695f453fd439059f0a117cf373d1f773" translate="yes" xml:space="preserve">
          <source>Turns every &lt;code&gt;head1&lt;/code&gt; heading into a link back to the top of the page. By default, no backlinks are generated.</source>
          <target state="translated">将每个 &lt;code&gt;head1&lt;/code&gt; 标题转换为指向页面顶部的链接。默认情况下，不生成任何反向链接。</target>
        </trans-unit>
        <trans-unit id="488b4a24fda23c677bfd758dfeda4e2b3e28ea5b" translate="yes" xml:space="preserve">
          <source>Turns on all &quot;extra&quot; debugging options.</source>
          <target state="translated">开启所有 &quot;额外 &quot;的调试选项。</target>
        </trans-unit>
        <trans-unit id="8a6abc6af101e3e68b329eb351f149732ea8c3d9" translate="yes" xml:space="preserve">
          <source>Turns on all compile related debug options.</source>
          <target state="translated">开启所有与编译相关的调试选项。</target>
        </trans-unit>
        <trans-unit id="377f42734b94211c01fa848b2645c0c159ecedcd" translate="yes" xml:space="preserve">
          <source>Turns on all execute related debug options.</source>
          <target state="translated">开启所有与执行相关的调试选项。</target>
        </trans-unit>
        <trans-unit id="16cf0e466a4f6fe0b3456839377f934eda051d4e" translate="yes" xml:space="preserve">
          <source>Turns on all non-extra compile related debug options.</source>
          <target state="translated">开启所有与编译无关的调试选项。</target>
        </trans-unit>
        <trans-unit id="bb0c3643227c9fa0f255763a21a1f9559b3e9dd1" translate="yes" xml:space="preserve">
          <source>Turns on all non-extra execute related debug options.</source>
          <target state="translated">打开所有非extra执行相关的调试选项。</target>
        </trans-unit>
        <trans-unit id="cf78d64b4c15f8d89c3f09aea595a015508f3471" translate="yes" xml:space="preserve">
          <source>Turns on autoflush, print ARGS and then restores the autoflush status of the &lt;code&gt;IO::Handle&lt;/code&gt; object. Returns the return value from print.</source>
          <target state="translated">打开自动刷新，打印ARGS，然后恢复 &lt;code&gt;IO::Handle&lt;/code&gt; 对象的自动刷新状态。返回打印的返回值。</target>
        </trans-unit>
        <trans-unit id="2d1676fcc040bdf1deeab307eee1f9a1faa4d87a" translate="yes" xml:space="preserve">
          <source>Turns on debug output related to the process of parsing the pattern.</source>
          <target state="translated">开启与模式解析过程相关的调试输出。</target>
        </trans-unit>
        <trans-unit id="80ae89d796a9f5474c9cf55351133039b045499c" translate="yes" xml:space="preserve">
          <source>Turns on debugging</source>
          <target state="translated">开启调试</target>
        </trans-unit>
        <trans-unit id="0b71618ab3c580ced56e12be5afa8ca78d10b841" translate="yes" xml:space="preserve">
          <source>Turns on debugging of the main matching loop.</source>
          <target state="translated">开启主匹配循环的调试。</target>
        </trans-unit>
        <trans-unit id="821dfaade517bc8af20717058964e6e45387b304" translate="yes" xml:space="preserve">
          <source>Turns on the magical status of an SV. See &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">打开SV的魔幻状态。参见 &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d12b512bcc17c858f7f78847cab2c7f6461efd3" translate="yes" xml:space="preserve">
          <source>Turns on the magical status of an SV. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">打开SV的魔法状态。参见 &lt;code&gt;sv_magic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5ed69f1e400ca234d376650a653b6521d5c1651" translate="yes" xml:space="preserve">
          <source>Turns the @metadata_pairs into YAML.</source>
          <target state="translated">将@metadata_pairs变成YAML。</target>
        </trans-unit>
        <trans-unit id="606c2af8d67a4d7dc7224ecdbb198b95627a3d18" translate="yes" xml:space="preserve">
          <source>Tutorial on making a new module.</source>
          <target state="translated">制作新模块的教程。</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="4106aa6fe38782986e71b6df351f9eed9adc1100" translate="yes" xml:space="preserve">
          <source>Tutorials, end-user documentation, research papers, FAQs etc are not appropriate in a module's main documentation. If you really want to write these, include them as sub-documents such as &lt;code&gt;My::Module::Tutorial&lt;/code&gt; or &lt;code&gt;My::Module::FAQ&lt;/code&gt; and provide a link in the SEE ALSO section of the main documentation.</source>
          <target state="translated">教程，最终用户文档，研究论文，常见问题解答等不适用于该模块的主要文档。如果您确实想编写这些内容，请将它们作为子文档包括在 &lt;code&gt;My::Module::Tutorial&lt;/code&gt; 或 &lt;code&gt;My::Module::FAQ&lt;/code&gt; 并在主文档的&amp;ldquo;另请参阅&amp;rdquo;部分中提供链接。</target>
        </trans-unit>
        <trans-unit id="d4f6fcebc83fe08414440f2690253120c9bf99c3" translate="yes" xml:space="preserve">
          <source>Tweak the style of B::Deparse's output. The letters should follow directly after the 's', with no space or punctuation. The following options are available:</source>
          <target state="translated">调整 B::Deparse 的输出风格。字母应该直接跟在's'后面,没有空格或标点符号。以下是可用的选项。</target>
        </trans-unit>
        <trans-unit id="8b77b783948e5ce8fbd237831d47a3e2aa25c8cf" translate="yes" xml:space="preserve">
          <source>Two additional extensions by Andreas Kaiser, &lt;code&gt;OS2::UPM&lt;/code&gt; , and &lt;code&gt;OS2::FTP&lt;/code&gt; , are included into &lt;code&gt;ILYAZ&lt;/code&gt; directory, mirrored on CPAN. Other OS/2-related extensions are available too.</source>
          <target state="translated">&lt;code&gt;ILYAZ&lt;/code&gt; 目录中包含Andreas Kaiser的另外两个扩展 &lt;code&gt;OS2::UPM&lt;/code&gt; 和 &lt;code&gt;OS2::FTP&lt;/code&gt; ，已在CPAN上进行了镜像。其他与OS / 2相关的扩展也可用。</target>
        </trans-unit>
        <trans-unit id="e1e1c471607b1953c35055b694d94ae2115e7490" translate="yes" xml:space="preserve">
          <source>Two additional extensions by Andreas Kaiser, &lt;code&gt;OS2::UPM&lt;/code&gt;, and &lt;code&gt;OS2::FTP&lt;/code&gt;, are included into &lt;code&gt;ILYAZ&lt;/code&gt; directory, mirrored on CPAN. Other OS/2-related extensions are available too.</source>
          <target state="translated">Andreas Kaiser的另外两个扩展 &lt;code&gt;OS2::UPM&lt;/code&gt; 和 &lt;code&gt;OS2::FTP&lt;/code&gt; 包含在 &lt;code&gt;ILYAZ&lt;/code&gt; 目录中，并在CPAN上进行了镜像。其他与OS / 2相关的扩展也可用。</target>
        </trans-unit>
        <trans-unit id="225de66ed8612f5eaedcbe3517b9b8a030dd1dfb" translate="yes" xml:space="preserve">
          <source>Two additional fields &lt;code&gt;free&lt;/code&gt; , &lt;code&gt;used&lt;/code&gt; contain array references which provide per-bucket count of free and used chunks. Two other fields &lt;code&gt;mem_size&lt;/code&gt; , &lt;code&gt;available_size&lt;/code&gt; contain array references which provide the information about the allocated size and usable size of chunks in each bucket. Again, see &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;Using $ENV{PERL_DEBUG_MSTATS} in perldebguts&lt;/a&gt; for details.</source>
          <target state="translated">两个附加字段 &lt;code&gt;free&lt;/code&gt; ， &lt;code&gt;used&lt;/code&gt; 含有数组引用其提供可用和已用块的每桶计数。另外两个字段 &lt;code&gt;mem_size&lt;/code&gt; ， &lt;code&gt;available_size&lt;/code&gt; 包含数组引用，这些引用提供有关每个存储桶中块的已分配大小和可用大小的信息。再次，请参阅&lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;perldebguts中的使用$ ENV {PERL_DEBUG_MSTATS}以&lt;/a&gt;获取详细信息。</target>
        </trans-unit>
        <trans-unit id="645e14dd280baf021efadb33e4b6285cfb158d60" translate="yes" xml:space="preserve">
          <source>Two additional fields &lt;code&gt;free&lt;/code&gt;, &lt;code&gt;used&lt;/code&gt; contain array references which provide per-bucket count of free and used chunks. Two other fields &lt;code&gt;mem_size&lt;/code&gt;, &lt;code&gt;available_size&lt;/code&gt; contain array references which provide the information about the allocated size and usable size of chunks in each bucket. Again, see &lt;a href=&quot;perldebguts#Using-%24ENV%7BPERL_DEBUG_MSTATS%7D&quot;&gt;&quot;Using $ENV{PERL_DEBUG_MSTATS}&quot; in perldebguts&lt;/a&gt; for details.</source>
          <target state="translated">两个附加字段 &lt;code&gt;free&lt;/code&gt; ， &lt;code&gt;used&lt;/code&gt; 含有数组引用其提供可用和已用块的每桶计数。另外两个字段 &lt;code&gt;mem_size&lt;/code&gt; ， &lt;code&gt;available_size&lt;/code&gt; 包含数组引用，这些引用提供有关每个存储桶中块的已分配大小和可用大小的信息。再次，请参阅&lt;a href=&quot;perldebguts#Using-%24ENV%7BPERL_DEBUG_MSTATS%7D&quot;&gt;perldebguts中的&amp;ldquo;使用$ ENV {PERL_DEBUG_MSTATS}&amp;rdquo;以&lt;/a&gt;获取详细信息。</target>
        </trans-unit>
        <trans-unit id="959e1dbe5c03b6bf54bd2c7c42f5c06de670abcf" translate="yes" xml:space="preserve">
          <source>Two arrays smartmatch if each element in the first array smartmatches (that is, is &quot;in&quot;) the corresponding element in the second array, recursively.</source>
          <target state="translated">如果第一个数组中的每个元素与第二个数组中的相应元素递归地智能匹配(即 &quot;在&quot;),则两个数组就会智能匹配。</target>
        </trans-unit>
        <trans-unit id="ef9d289482c44cedd928e08a539e06da234c1ea2" translate="yes" xml:space="preserve">
          <source>Two directories</source>
          <target state="translated">两个目录</target>
        </trans-unit>
        <trans-unit id="4932b4ce84c4a3c76d97d8ddc1677ad9583f731a" translate="yes" xml:space="preserve">
          <source>Two exceptions are fseek() and ftell(). 32-bit applications should use fseeko(3C) and ftello(3C). These will get automatically mapped to fseeko64() and ftello64().</source>
          <target state="translated">两种例外情况是fseek()和ftell(),32位应用应该使用fseeko(3C)和ftello(3C)。32位应用程序应该使用fseeko(3C)和ftello(3C)。这些会自动映射到fseeko64()和ftello64()。</target>
        </trans-unit>
        <trans-unit id="59e6099a51676c8b357d47058d648615908e9535" translate="yes" xml:space="preserve">
          <source>Two functions are provided by</source>
          <target state="translated">提供了两项功能</target>
        </trans-unit>
        <trans-unit id="362495d14b1f3b1a8e9077a2b6d2d038307cf755" translate="yes" xml:space="preserve">
          <source>Two functions are provided to perform in-memory compression/uncompression of RFC 1950 data streams. They are called &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; .</source>
          <target state="translated">提供了两个功能来执行RFC 1950数据流的内存中压缩/解压缩。它们称为 &lt;code&gt;compress&lt;/code&gt; 和 &lt;code&gt;uncompress&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60a9bef4c585c40271adbc6700cd51119d598e56" translate="yes" xml:space="preserve">
          <source>Two functions are provided to perform in-memory compression/uncompression of RFC 1950 data streams. They are called &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt;.</source>
          <target state="translated">提供了两个功能来执行RFC 1950数据流的内存中压缩/解压缩。它们分别称为 &lt;code&gt;compress&lt;/code&gt; 和 &lt;code&gt;uncompress&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1fae0daa00d9847553b4c2af0e0bfcf15f43ad2" translate="yes" xml:space="preserve">
          <source>Two hexadecimal numbers separated by horizontal whitespace (space or tabular characters) denoting a range of code points to include.</source>
          <target state="translated">两个十六进制数字,用水平空格(空格或表格字符)隔开,表示要包括的码点范围。</target>
        </trans-unit>
        <trans-unit id="7fe7068b60f3e31f3d2f257534aa6f46077e516b" translate="yes" xml:space="preserve">
          <source>Two hexadecimal numbers separated by horizontal whitespace (space or tabular characters) denoting a range of code points to include. The second number must not be smaller than the first.</source>
          <target state="translated">两个十六进制数字,用水平空格(空格或表格字符)隔开,表示要包括的码点范围。第二个数字不得小于第一个数字。</target>
        </trans-unit>
        <trans-unit id="fc8d21d4a74e99aae1a5fc40b83d3fff90123b23" translate="yes" xml:space="preserve">
          <source>Two nested identical markup commands have been found. Generally this does not make sense.</source>
          <target state="translated">发现有两个嵌套的相同标记命令。一般情况下,这是说不通的。</target>
        </trans-unit>
        <trans-unit id="5e76b53030582383f7d551a5e77c668c449dbb3b" translate="yes" xml:space="preserve">
          <source>Two of the codes specified by the standard (XTS which is reserved for testing purposes and XXX which is for transactions where no currency is involved) are omitted.</source>
          <target state="translated">标准规定的两个代码(XTS用于测试目的,XXX用于不涉及货币的交易)被省略。</target>
        </trans-unit>
        <trans-unit id="a1d006aec19b5d26f771c4cb3b1aa7d14cd4a562" translate="yes" xml:space="preserve">
          <source>Two or more suspects remain</source>
          <target state="translated">仍有两名或更多嫌疑人</target>
        </trans-unit>
        <trans-unit id="069f392f8b693bf3f912fa721edb551769786910" translate="yes" xml:space="preserve">
          <source>Two other &quot;encapsulation&quot; macros are the PERL_GLOBAL_STRUCT and PERL_GLOBAL_STRUCT_PRIVATE (the latter turns on the former, and the former turns on MULTIPLICITY.) The PERL_GLOBAL_STRUCT causes all the internal variables of Perl to be wrapped inside a single global struct, struct perl_vars, accessible as (globals) &amp;amp;PL_Vars or PL_VarsPtr or the function Perl_GetVars(). The PERL_GLOBAL_STRUCT_PRIVATE goes one step further, there is still a single struct (allocated in main() either from heap or from stack) but there are no global data symbols pointing to it. In either case the global struct should be initialized as the very first thing in main() using Perl_init_global_struct() and correspondingly tear it down after perl_free() using Perl_free_global_struct(), please see</source>
          <target state="translated">另外两个&amp;ldquo;封装&amp;rdquo;宏是PERL_GLOBAL_STRUCT和PERL_GLOBAL_STRUCT_PRIVATE（后者打开前者，而前者打开MULTIPLICITY。）PERL_GLOBAL_STRUCT使Perl的所有内部变量都包装在单个全局结构（结构perl_vars）中，可作为（全局）＆PL_Vars或PL_VarsPtr或函数Perl_GetVars（）。 PERL_GLOBAL_STRUCT_PRIVATE进一步走了一步，仍然只有一个结构（从堆或堆栈中分配到main（）中），但是没有指向它的全局数据符号。无论哪种情况，都应该使用Perl_init_global_struct（）将全局结构初始化为main（）中的第一件事，并在使用Perl_free_global_struct（）进行perl_free（）之后将其相应地拆除</target>
        </trans-unit>
        <trans-unit id="9e4d897b2c15b7e4e4ca9fbaec8aab25f6b14e93" translate="yes" xml:space="preserve">
          <source>Two possible uses (besides ignoring the property) come to mind. A singleton class could be implemented this using the generic object. If necessary, an &lt;code&gt;init()&lt;/code&gt; method could die or ignore calls with actual objects (references), so only the generic object will ever exist.</source>
          <target state="translated">我想到了两种可能的用途（除了忽略属性）。可以使用泛型对象来实现单例类。如有必要， &lt;code&gt;init()&lt;/code&gt; 方法可能会死掉或忽略对实际对象（引用）的调用，因此只有通用对象会存在。</target>
        </trans-unit>
        <trans-unit id="b02b6a9a4575d62354db7ec75686a98545f9466d" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt; may modify files locked with &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">两种潜在的非显而易见但传统的&lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt; &lt;code&gt;flock&lt;/code&gt; &lt;/a&gt;语义是：它无限期地等待直到授予锁为止，并且它的锁&lt;b&gt;仅仅是建议性的&lt;/b&gt;。这样的自由锁更加灵活，但是提供的保证却更少。这意味着，不也使用的程序&lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt; &lt;code&gt;flock&lt;/code&gt; &lt;/a&gt;可以修改文件锁定与&lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt; &lt;code&gt;flock&lt;/code&gt; &lt;/a&gt;。见&lt;a href=&quot;perlport&quot;&gt;Perlport&lt;/a&gt;，您端口的特定文档以及系统特定的本地联机帮助页以获取详细信息。如果您正在编写可移植程序，则最好采用传统行为。（但是，如果不是那样，您应该总是总是完全自由地编写自己系统的特性（有时称为&amp;ldquo;功能&amp;rdquo;。）对可移植性问题的过分遵守不会妨碍您完成工作。）</target>
        </trans-unit>
        <trans-unit id="70abff015732d480e204353f739476e826fe7dc6" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; may modify files locked with &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">两种潜在的非显而易见但传统的 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 语义是：它无限期地等待直到授予锁为止，并且其锁&lt;b&gt;仅仅是建议性的&lt;/b&gt;。这样的自由锁更加灵活，但是提供的保证却更少。这意味着，不也使用的程序 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 可以修改文件锁定与 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 。见&lt;a href=&quot;../perlport&quot;&gt;Perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</target>
        </trans-unit>
        <trans-unit id="3c9f59ec6423987c8c2fe5d0858f160205e3fc59" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; may modify files locked with &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">两种潜在的非显而易见但传统的 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 语义是：它无限期地等待直到授予锁为止，并且其锁&lt;b&gt;仅仅是建议性的&lt;/b&gt;。这样的自由锁更加灵活，但是提供的保证却更少。这意味着，不也使用的程序 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 可以修改文件锁定与 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 。见&lt;a href=&quot;perlport&quot;&gt;Perlport&lt;/a&gt;，您端口的特定文档以及系统特定的本地联机帮助页以获取详细信息。如果您正在编写可移植程序，则最好采用传统行为。（但是，如果您不是这样，那么您一如既往可以完全自由地编写自己系统的特性（有时称为&amp;ldquo;功能&amp;rdquo;。）对可移植性问题的过度依赖不会妨碍您完成工作。）</target>
        </trans-unit>
        <trans-unit id="53df84b423920613232d12c96d5eb675ef01a9db" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional flock semantics are that it waits indefinitely until the lock is granted, and that its locks are</source>
          <target state="translated">两个潜在的非显而易见但传统的羊群语义是,它无限期地等待,直到锁被授予,并且它的锁是</target>
        </trans-unit>
        <trans-unit id="778a62aee9043b393531476babc83e7e729243c9" translate="yes" xml:space="preserve">
          <source>Two special locales are worth particular mention: &quot;C&quot; and &quot;POSIX&quot;. Currently these are effectively the same locale: the difference is mainly that the first one is defined by the C standard, the second by the POSIX standard. They define the &lt;b&gt;default locale&lt;/b&gt; in which every program starts in the absence of locale information in its environment. (The</source>
          <target state="translated">值得特别提及的两个特殊语言环境：&amp;ldquo; C&amp;rdquo;和&amp;ldquo; POSIX&amp;rdquo;。当前，这些区域实际上是相同的语言环境：区别主要在于第一个由C标准定义，第二个由POSIX标准定义。它们定义了&lt;b&gt;默认语言环境&lt;/b&gt;，每个程序都在其环境中缺少语言环境信息的情况下启动。（</target>
        </trans-unit>
        <trans-unit id="001ed180b265179aa35dbaf576484db20b8f3115" translate="yes" xml:space="preserve">
          <source>Two special marker lines will bracket debugging code, like this:</source>
          <target state="translated">两条特殊的标记线会括住调试代码,像这样。</target>
        </trans-unit>
        <trans-unit id="fc4c89a57e0f51cea54d0e2e158fcc3083bc5fa2" translate="yes" xml:space="preserve">
          <source>Two threads both access &lt;code&gt;$x&lt;/code&gt; . Each thread can potentially be interrupted at any point, or be executed in any order. At the end, &lt;code&gt;$x&lt;/code&gt; could be 3 or 4, and both &lt;code&gt;$y&lt;/code&gt; and &lt;code&gt;$z&lt;/code&gt; could be 2 or 3.</source>
          <target state="translated">两个线程都访问 &lt;code&gt;$x&lt;/code&gt; 。每个线程都可能在任何时候被中断，或以任何顺序执行。最后， &lt;code&gt;$x&lt;/code&gt; 可以是3或4， &lt;code&gt;$y&lt;/code&gt; 和 &lt;code&gt;$z&lt;/code&gt; 都可以是2或3。</target>
        </trans-unit>
        <trans-unit id="ed596ad5315f7ee111b20fc3225326599075e7d0" translate="yes" xml:space="preserve">
          <source>Two threads both access &lt;code&gt;$x&lt;/code&gt;. Each thread can potentially be interrupted at any point, or be executed in any order. At the end, &lt;code&gt;$x&lt;/code&gt; could be 3 or 4, and both &lt;code&gt;$y&lt;/code&gt; and &lt;code&gt;$z&lt;/code&gt; could be 2 or 3.</source>
          <target state="translated">两个线程都访问 &lt;code&gt;$x&lt;/code&gt; 。每个线程都可能在任何时候被中断，或以任何顺序执行。最后， &lt;code&gt;$x&lt;/code&gt; 可以是3或4， &lt;code&gt;$y&lt;/code&gt; 和 &lt;code&gt;$z&lt;/code&gt; 都可以是2或3。</target>
        </trans-unit>
        <trans-unit id="a040608578e9e9c915007f47fc1e5b14ac218a6c" translate="yes" xml:space="preserve">
          <source>Two ways. One is to build the module normally...</source>
          <target state="translated">两种方法。一种是正常搭建模块...</target>
        </trans-unit>
        <trans-unit id="aed361ca9a7b196027b5db9a2f0828216a331df8" translate="yes" xml:space="preserve">
          <source>Two's complement (bitwise not). This is equivalent to</source>
          <target state="translated">二的补充(位上不)。这相当于</target>
        </trans-unit>
        <trans-unit id="1f8bb2682169008d50215675c388c14028479675" translate="yes" xml:space="preserve">
          <source>Two's complement (bitwise not). This is equivalent to, but faster than,</source>
          <target state="translated">二的补充(位上不)。这相当于,但快于。</target>
        </trans-unit>
        <trans-unit id="ec9798b2ceec50b36efb45258055740cd070510f" translate="yes" xml:space="preserve">
          <source>Two-arg &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; is magic and can translate characters like &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, and &lt;code&gt;|&lt;/code&gt; in filenames, which is usually the wrong thing to do. &lt;a href=&quot;perlfunc#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt; and three-arg &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; don't have this problem.</source>
          <target state="translated">两个参数&lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;很神奇，可以翻译 &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;|&lt;/code&gt; 等字符。在文件名中，这通常是错误的做法。&lt;a href=&quot;perlfunc#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; &lt;/a&gt;和三参数&lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;不存在此问题。</target>
        </trans-unit>
        <trans-unit id="639570380139caf69541c926ba46013c3318dc90" translate="yes" xml:space="preserve">
          <source>Two-face References</source>
          <target state="translated">双面参考</target>
        </trans-unit>
        <trans-unit id="ae90b2c9e3f2f4b661468b3ddaef859dd9bff8a2" translate="yes" xml:space="preserve">
          <source>Two-face Scalars</source>
          <target state="translated">双面疤痕</target>
        </trans-unit>
        <trans-unit id="f60980a56996745ba95f06a5f138b8e86a98d3dd" translate="yes" xml:space="preserve">
          <source>Tye McQueen, tye@metronet.com, http://perlmonks.org/?node=tye.</source>
          <target state="translated">Tye McQueen,tye@metronet.com,http://perlmonks.org/?node=tye。</target>
        </trans-unit>
        <trans-unit id="47708aacd7aae4d98506843c2ea25848ad8c524c" translate="yes" xml:space="preserve">
          <source>Tying Arrays</source>
          <target state="translated">捆绑数组</target>
        </trans-unit>
        <trans-unit id="29fe0e127980eab253dd9684cf8924d1439a9c07" translate="yes" xml:space="preserve">
          <source>Tying Arrays by Casey West &amp;lt;</source>
          <target state="translated">凯西&amp;middot;韦斯特（Casey West）的捆绑阵列&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cb864932b4ba6b40040bda147b28500825da685" translate="yes" xml:space="preserve">
          <source>Tying FileHandles</source>
          <target state="translated">绑定FileHandles</target>
        </trans-unit>
        <trans-unit id="c44951e9133e5d8875fa8e60d17eb7ca4e5ec846" translate="yes" xml:space="preserve">
          <source>Tying Hashes</source>
          <target state="translated">捆绑哈希值</target>
        </trans-unit>
        <trans-unit id="c124692dc36c13d6ea9eefe451091514b3053308" translate="yes" xml:space="preserve">
          <source>Tying Scalars</source>
          <target state="translated">绑扎疤痕</target>
        </trans-unit>
        <trans-unit id="dd441f6c670bdd175a4a06606b3ade32864a5013" translate="yes" xml:space="preserve">
          <source>Tying to an already-opened filehandle</source>
          <target state="translated">绑定到一个已经打开的文件柄上</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="b987ff7b7058c91b5723d0647b696ba512fc503e" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake install&quot; (or &quot;gmake install&quot;, &quot;nmake install&quot;). This will put the newly built perl and the libraries under whatever &lt;code&gt;INST_TOP&lt;/code&gt; points to in the Makefile. It will also install the pod documentation under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; and HTML versions of the same under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt;.</source>
          <target state="translated">输入&amp;ldquo; dmake install&amp;rdquo;（或&amp;ldquo; gmake install&amp;rdquo;，&amp;ldquo; nmake install&amp;rdquo;）。这会将新建的perl和库放在 &lt;code&gt;INST_TOP&lt;/code&gt; 指向Makefile中的任何位置下。它还会将pod文档安装在 &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; 并将HTML版本安装在 &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="622fe690390119c9b2836b529615b923c08f64da" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake install&quot; (or &quot;nmake install&quot;). This will put the newly built perl and the libraries under whatever &lt;code&gt;INST_TOP&lt;/code&gt; points to in the Makefile. It will also install the pod documentation under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; and HTML versions of the same under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt; .</source>
          <target state="translated">键入&amp;ldquo; dmake install&amp;rdquo;（或&amp;ldquo; nmake install&amp;rdquo;）。这会将新建的perl和库放在 &lt;code&gt;INST_TOP&lt;/code&gt; 所指向的Makefile中。它还将在 &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; 下安装pod文档，并在 &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt; 下安装相同的HTML版本。</target>
        </trans-unit>
        <trans-unit id="0bc4b446d209674d0e9fea7244b04c4c376a3eb5" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake test&quot; (or &quot;gmake test&quot;, &quot;nmake test&quot;). This will run most of the tests from the testsuite (many tests will be skipped).</source>
          <target state="translated">输入 &quot;dmake test&quot; (或 &quot;gmake test&quot;,&quot;nmake test&quot;)。这将运行testuite中的大部分测试(许多测试将被跳过)。</target>
        </trans-unit>
        <trans-unit id="48996994efbc36adb9197c655f8807f921339671" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake test&quot; (or &quot;nmake test&quot;). This will run most of the tests from the testsuite (many tests will be skipped).</source>
          <target state="translated">输入 &quot;dmake test&quot; (或 &quot;nmake test&quot;)。这将运行testuite中的大部分测试 (许多测试将被跳过)。</target>
        </trans-unit>
        <trans-unit id="ce74e5125b2ce8cfe1e9037bd6ca72c9f8e02d8e" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake&quot; (&quot;gmake&quot; for GNU make, or &quot;nmake&quot; if you are using that make).</source>
          <target state="translated">输入 &quot;dmake&quot;(GNU make的 &quot;gmake&quot;,如果你使用的是make,则输入 &quot;nmake&quot;)。</target>
        </trans-unit>
        <trans-unit id="e707f55e50471f8dc7a11eb61a45491656e65c20" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake&quot; (or &quot;nmake&quot; if you are using that make).</source>
          <target state="translated">输入 &quot;dmake&quot;(或 &quot;nmake&quot;,如果你使用的是make)。</target>
        </trans-unit>
        <trans-unit id="817cc5b4f0c413465ec1e98078f923e58ba436f8" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;perl -v&lt;/code&gt; at the command line to find out.</source>
          <target state="translated">在命令行中键入 &lt;code&gt;perl -v&lt;/code&gt; 进行查找。</target>
        </trans-unit>
        <trans-unit id="9226639af847a9b60c06b437bbd1474fd6ad1ed2" translate="yes" xml:space="preserve">
          <source>Type =&amp;gt; INT</source>
          <target state="translated">类型=&amp;gt; INT</target>
        </trans-unit>
        <trans-unit id="8d4464e66323935602a00348988e0d51aae9ab21" translate="yes" xml:space="preserve">
          <source>Type flag for I/O objects. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">输入I / O对象的标志。请参见&lt;a href=&quot;#svtype&quot;&gt;&amp;ldquo; svtype&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="470a91ba8a41cc959ff1b12a936c2603408f2a81" translate="yes" xml:space="preserve">
          <source>Type flag for I/O objects. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">I / O对象的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0214e8a20ca847239102bda8ea4c8f57bc680a1d" translate="yes" xml:space="preserve">
          <source>Type flag for arrays. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">数组的类型标志。请参见&lt;a href=&quot;#svtype&quot;&gt;&amp;ldquo; svtype&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="115e0f5825d2a5e2437586f43a3052a4bc413be2" translate="yes" xml:space="preserve">
          <source>Type flag for arrays. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">数组的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b619926ff72ff70acdcfb56667bc380fd10917da" translate="yes" xml:space="preserve">
          <source>Type flag for formats. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">输入格式标志。请参见&lt;a href=&quot;#svtype&quot;&gt;&amp;ldquo; svtype&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5424ebb415da653ce11cbaa80efe5caaa204e71c" translate="yes" xml:space="preserve">
          <source>Type flag for formats. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">输入格式标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="862128cc96218003cbfad3b7ee14c34ad3105872" translate="yes" xml:space="preserve">
          <source>Type flag for hashes. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">键入标志的哈希值。请参见&lt;a href=&quot;#svtype&quot;&gt;&amp;ldquo; svtype&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11f3d189f9118d5a6a717d6df4d8bfc5dd5c80fb" translate="yes" xml:space="preserve">
          <source>Type flag for hashes. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">输入哈希标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9baa4a58d00e83fc0bcce1af37a4d54939255e4" translate="yes" xml:space="preserve">
          <source>Type flag for regular expressions. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">正则表达式的类型标志。请参见&lt;a href=&quot;#svtype&quot;&gt;&amp;ldquo; svtype&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7697ce082ff72de4bd1f6e232aec1e708c3e949b" translate="yes" xml:space="preserve">
          <source>Type flag for regular expressions. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">正则表达式的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68fd7e6db2e32b4d1268770600fb508ba841fcb6" translate="yes" xml:space="preserve">
          <source>Type flag for scalars. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">输入标量的标志。请参见&lt;a href=&quot;#svtype&quot;&gt;&amp;ldquo; svtype&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8842ec0ce8ceed5f394b670f4b4d43838af8af85" translate="yes" xml:space="preserve">
          <source>Type flag for scalars. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">输入标量的标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc19461206b9d4e886495f08f330852592ae56f4" translate="yes" xml:space="preserve">
          <source>Type flag for scalars. See &lt;a href=&quot;perlapi#svtype&quot;&gt;&quot;svtype&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">输入标量的标志。请参见&lt;a href=&quot;perlapi#svtype&quot;&gt;perlapi中的&amp;ldquo; svtype&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc3eaa4bcf13a8b0cfd50d989093647d196bc08a" translate="yes" xml:space="preserve">
          <source>Type flag for subroutines. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">子例程的类型标志。请参见&lt;a href=&quot;#svtype&quot;&gt;&amp;ldquo; svtype&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba6e0906867866e6b4c76c1aa73ce8fb1ddab2a4" translate="yes" xml:space="preserve">
          <source>Type flag for subroutines. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">子例程的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b728a87739a1b53338d9a99924f6b87621554866" translate="yes" xml:space="preserve">
          <source>Type flag for typeglobs. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="translated">typeglob的类型标志。请参见&lt;a href=&quot;#svtype&quot;&gt;&amp;ldquo; svtype&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d98af6202cdf505f81d6de89907f306acd604bb" translate="yes" xml:space="preserve">
          <source>Type flag for typeglobs. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">typeglob的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b83265a2400fad6fae10ac8b63f66f6aa5168ddc" translate="yes" xml:space="preserve">
          <source>Type of arg %d to %s must be %s (not %s)</source>
          <target state="translated">arg %d到%s的类型必须是%s(不是%s)</target>
        </trans-unit>
        <trans-unit id="33daa9fc448c1a401c5c6eb564a12a3b5b0309c7" translate="yes" xml:space="preserve">
          <source>Type of arg %d to &amp;amp;CORE::%s must be %s</source>
          <target state="translated">到＆CORE ::％s的arg％d的类型必须为％s</target>
        </trans-unit>
        <trans-unit id="e47d64cc94d0acfc0cdbf0b2c9dd711351e0f339" translate="yes" xml:space="preserve">
          <source>Type of first matching node.</source>
          <target state="translated">第一匹配节点的类型。</target>
        </trans-unit>
        <trans-unit id="82be69629fdb03e428153252cb628a3089333b85" translate="yes" xml:space="preserve">
          <source>Type-casting operator.</source>
          <target state="translated">型铸操作员。</target>
        </trans-unit>
        <trans-unit id="3c6b62766a1a668fd13ee2f54c72526e46bdd675" translate="yes" xml:space="preserve">
          <source>Type-specific attribute handlers</source>
          <target state="translated">特定类型属性处理程序</target>
        </trans-unit>
        <trans-unit id="ee3fb11d05c90c37311491cf33008925b13b487f" translate="yes" xml:space="preserve">
          <source>Type:</source>
          <target state="translated">Type:</target>
        </trans-unit>
        <trans-unit id="dacaa1ce7373acde846ee256ee267058f226c8cb" translate="yes" xml:space="preserve">
          <source>Typed lexicals</source>
          <target state="translated">打字词法</target>
        </trans-unit>
        <trans-unit id="764662b450b71457a1b7dac7680a6d81b8a030c7" translate="yes" xml:space="preserve">
          <source>Typeglob Slots</source>
          <target state="translated">Typeglob老虎机</target>
        </trans-unit>
        <trans-unit id="35c58169317903405f89e446350d7099fc17650c" translate="yes" xml:space="preserve">
          <source>Typeglobs and Filehandles</source>
          <target state="translated">Typeglobs和Filehandles</target>
        </trans-unit>
        <trans-unit id="c93af0f29f506026f9bce190608810109efe41de" translate="yes" xml:space="preserve">
          <source>Typeglobs are also a way to create a local filehandle using the local() operator. These last until their block is exited, but may be passed back. For example:</source>
          <target state="translated">Typeglobs 也是一种使用 local()操作符创建本地文件柄的方法。这些都会持续到它们的块被退出,但可能会被传回。例如</target>
        </trans-unit>
        <trans-unit id="ce5682fe2db39004dc33d1f245a642897d0ccef1" translate="yes" xml:space="preserve">
          <source>Typeless &lt;code&gt;abs&lt;/code&gt; or &lt;code&gt;fabs&lt;/code&gt;,</source>
          <target state="translated">无类型 &lt;code&gt;abs&lt;/code&gt; 或 &lt;code&gt;fabs&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="7c854e2c86ed5ebd580cf024fab8796f99c1a0f9" translate="yes" xml:space="preserve">
          <source>Types of Nodes</source>
          <target state="translated">节点类型</target>
        </trans-unit>
        <trans-unit id="54a79ea7d31cf3e80acf5e2ca6b3eef126289136" translate="yes" xml:space="preserve">
          <source>Typical frequently used settings:</source>
          <target state="translated">典型的常用设置。</target>
        </trans-unit>
        <trans-unit id="19f0351a6e0b3a0f7afdab28ba608c9abfed4106" translate="yes" xml:space="preserve">
          <source>Typical names for the single object key are &lt;code&gt;__class_whatever__&lt;/code&gt;, or &lt;code&gt;$__dollars_are_rarely_used__$&lt;/code&gt; or &lt;code&gt;}ugly_brace_placement&lt;/code&gt;, or even things like &lt;code&gt;__class_md5sum(classname)__&lt;/code&gt;, to reduce the risk of clashing with real hashes.</source>
          <target state="translated">单个对象密钥的典型名称是 &lt;code&gt;__class_whatever__&lt;/code&gt; 或 &lt;code&gt;$__dollars_are_rarely_used__$&lt;/code&gt; &lt;code&gt;}ugly_brace_placement&lt;/code&gt; __ $或} ugly_brace_placement，甚至是 &lt;code&gt;__class_md5sum(classname)__&lt;/code&gt; 之类的东西，以减少与真实哈希冲突的风险。</target>
        </trans-unit>
        <trans-unit id="eeee45f0582f2da790f6df23acb83c5b9ac37e5b" translate="yes" xml:space="preserve">
          <source>Typical usage is just:</source>
          <target state="translated">典型的用法是刚。</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">典型用途:</target>
        </trans-unit>
        <trans-unit id="f0a20c31caa817cfde9a5903c8d1331d2cc5ddae" translate="yes" xml:space="preserve">
          <source>Typical use is to do range checks on &lt;code&gt;uv&lt;/code&gt; before casting:</source>
          <target state="translated">典型用途是在投射前对 &lt;code&gt;uv&lt;/code&gt; 进行范围检查：</target>
        </trans-unit>
        <trans-unit id="0f7c555ca8af58d8be6641bce4c54e1f92594d54" translate="yes" xml:space="preserve">
          <source>Typical use of AutoSplit in the perl MakeMaker utility is via the command-line with:</source>
          <target state="translated">在perl MakeMaker实用程序中,AutoSplit的典型用法是通过命令行使用。</target>
        </trans-unit>
        <trans-unit id="2eb42fd8be2849b836904fd8c0478452015d5021" translate="yes" xml:space="preserve">
          <source>Typically displayed in italics. Example: &quot;&lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt; &quot;</source>
          <target state="translated">通常以斜体显示。示例：&amp;ldquo; &lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="b5d871a9c977277097fa4a829e659b06d6204d49" translate="yes" xml:space="preserve">
          <source>Typically displayed in italics. Example: &quot;&lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt;&quot;</source>
          <target state="translated">通常以斜体显示。示例：&amp;ldquo; &lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="e392be83caed3c91eae784a95dbf70091fef0bbc" translate="yes" xml:space="preserve">
          <source>Typically only necessary for debugging and testing, if you need to dump the internals of an SV, &lt;a href=&quot;Devel::Peek&quot;&gt;Devel::Peek's&lt;/a&gt; Dump() provides more detail in a compact form.</source>
          <target state="translated">如果您需要转储SV的内部结构，通常仅对于调试和测试才需要，&lt;a href=&quot;Devel::Peek&quot;&gt;Devel :: Peek的&lt;/a&gt;Dump（）以紧凑的形式提供了更多详细信息。</target>
        </trans-unit>
        <trans-unit id="2a174345584e66d867781b1452d35dc4522e5c23" translate="yes" xml:space="preserve">
          <source>Typically only necessary for debugging and testing. Don't use this flag as a marker to distinguish character and binary data, that should be decided for each variable when you write your code.</source>
          <target state="translated">通常只有在调试和测试时才需要。不要用这个标志作为区分字符和二进制数据的标志,这应该在你写代码的时候为每个变量决定。</target>
        </trans-unit>
        <trans-unit id="0b14febd4050c6e9e7fff1ec1a1e04a32b2411b9" translate="yes" xml:space="preserve">
          <source>Typically render into NFD on input and NFC on output. Using NFKC or NFKD functions improves recall on searches, assuming you've already done to the same text to be searched. Note that this is about much more than just pre- combined compatibility glyphs; it also reorders marks according to their canonical combining classes and weeds out singletons.</source>
          <target state="translated">通常在输入时渲染成NFD,输出时渲染成NFC。使用NFKC或NFKD函数可以提高搜索时的召回率,假设你已经对要搜索的同一文本进行了搜索。请注意,这不仅仅是关于预组合兼容性字形,它还根据它们的规范组合类重新排序标记,并剔除单体。</target>
        </trans-unit>
        <trans-unit id="4aadd663fd22d97ef1413917c08e1ab3e9fe702e" translate="yes" xml:space="preserve">
          <source>Typically returns the string &lt;code&gt;at &amp;lt;FILE&amp;gt; line &amp;lt;LINE&amp;gt;&lt;/code&gt;. If &lt;code&gt;detail&lt;/code&gt; is set then its value will be returned instead.</source>
          <target state="translated">通常返回 &lt;code&gt;at &amp;lt;FILE&amp;gt; line &amp;lt;LINE&amp;gt;&lt;/code&gt; 的字符串。如果设置了 &lt;code&gt;detail&lt;/code&gt; ,则将返回其值。</target>
        </trans-unit>
        <trans-unit id="b5c564109e8a3afa5be0b031d855d9ae4aa0bbb3" translate="yes" xml:space="preserve">
          <source>Typically this is used to emulate &lt;code&gt;#!&lt;/code&gt; startup on platforms that don't support &lt;code&gt;#!&lt;/code&gt; . It's also convenient when debugging a script that uses &lt;code&gt;#!&lt;/code&gt; , and is thus normally found by the shell's $PATH search mechanism.</source>
          <target state="translated">通常，它用于模拟 &lt;code&gt;#!&lt;/code&gt; 在不支持 &lt;code&gt;#!&lt;/code&gt; 平台上启动！。当调试使用 &lt;code&gt;#!&lt;/code&gt; 的脚本时，这也很方便。，因此通常是由外壳程序的$ PATH搜索机制找到的。</target>
        </trans-unit>
        <trans-unit id="0f7ce98ce055e01dae18470a5f2a3135a14234ad" translate="yes" xml:space="preserve">
          <source>Typically this is used to emulate &lt;code&gt;#!&lt;/code&gt; startup on platforms that don't support &lt;code&gt;#!&lt;/code&gt;. It's also convenient when debugging a script that uses &lt;code&gt;#!&lt;/code&gt;, and is thus normally found by the shell's $PATH search mechanism.</source>
          <target state="translated">通常，它用于模拟 &lt;code&gt;#!&lt;/code&gt; 在不支持 &lt;code&gt;#!&lt;/code&gt; 平台上启动！。在调试使用 &lt;code&gt;#!&lt;/code&gt; 的脚本时，这也很方便。，因此通常是由外壳程序的$ PATH搜索机制找到的。</target>
        </trans-unit>
        <trans-unit id="687058d347f26c3b9dcf0508ed2f5930b5b6fa48" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be returned via &lt;code&gt;$out&lt;/code&gt; . &lt;code&gt;$status&lt;/code&gt; will have a value &lt;code&gt;Z_OK&lt;/code&gt; if successful.</source>
          <target state="translated">通常用于完成放气。任何待处理的输出将通过 &lt;code&gt;$out&lt;/code&gt; 返回。如果成功， &lt;code&gt;$status&lt;/code&gt; 的值 &lt;code&gt;Z_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bb05899bf90c01639baa0fce37a7ffd38acaffb" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be returned via &lt;code&gt;$out&lt;/code&gt;. &lt;code&gt;$status&lt;/code&gt; will have a value &lt;code&gt;Z_OK&lt;/code&gt; if successful.</source>
          <target state="translated">通常用于完成放气。任何未决的输出将通过 &lt;code&gt;$out&lt;/code&gt; 返回。如果成功， &lt;code&gt;$status&lt;/code&gt; 的值 &lt;code&gt;Z_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01a46f6fee05faa753caaabc6b43de594c708bd4" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be written to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">通常用于完成放气。任何未决的输出将被写入 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61eb0abe390afe612ea12baca62c7c474255a6b3" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be written to &lt;code&gt;$output&lt;/code&gt;.</source>
          <target state="translated">通常用于完成放气。任何未决的输出将被写入 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6622b7497b5ad854ceef3d9e6b7f39de4b5a746f" translate="yes" xml:space="preserve">
          <source>Typically will call &lt;code&gt;Fill&lt;/code&gt; and manipulate pointers (possibly via the API). &lt;code&gt;PerlIOBuf_read()&lt;/code&gt; may be suitable for derived classes which provide &quot;fast gets&quot; methods.</source>
          <target state="translated">通常会调用 &lt;code&gt;Fill&lt;/code&gt; 和操作指针（可能通过API）。 &lt;code&gt;PerlIOBuf_read()&lt;/code&gt; 可能适用于提供&amp;ldquo;快速获取&amp;rdquo;方法的派生类。</target>
        </trans-unit>
        <trans-unit id="eb1290094db39111daed12026731de41d874265c" translate="yes" xml:space="preserve">
          <source>Typically you only need to set this if you are using nonstandard prefixes and want some or all of them to have the same semantics as '--' does under normal circumstances.</source>
          <target state="translated">通常情况下,只有当你使用非标准的前缀,并希望其中的一些或所有前缀具有与'--'在正常情况下相同的语义时,你才需要设置这个。</target>
        </trans-unit>
        <trans-unit id="bbb5689bb894bcd45bb2427b7ffbb2ba5d9ac28a" translate="yes" xml:space="preserve">
          <source>Typically you use the &lt;code&gt;\G&lt;/code&gt; anchor with the &lt;code&gt;c&lt;/code&gt; flag when you want to try a different match if one fails, such as in a tokenizer. Jeffrey Friedl offers this example which works in 5.004 or later.</source>
          <target state="translated">通常，如果您想要在匹配失败的情况下尝试其他匹配（例如在分词器中），则可以将 &lt;code&gt;\G&lt;/code&gt; 锚与 &lt;code&gt;c&lt;/code&gt; 标志一起使用。Jeffrey Friedl提供了适用于5.004或更高版本的示例。</target>
        </trans-unit>
        <trans-unit id="e42958c3877ca65db1e97bfa470cdaaff1d1e60d" translate="yes" xml:space="preserve">
          <source>Typically you use the &lt;code&gt;\G&lt;/code&gt; anchor with the &lt;code&gt;c&lt;/code&gt; modifier when you want to try a different match if one fails, such as in a tokenizer. Jeffrey Friedl offers this example which works in 5.004 or later.</source>
          <target state="translated">通常，如果您想在失败的情况下（例如在分词器中）尝试其他匹配，则可以将 &lt;code&gt;\G&lt;/code&gt; 锚与 &lt;code&gt;c&lt;/code&gt; 修饰符一起使用。 Jeffrey Friedl提供了此示例，该示例可在5.004或更高版本中使用。</target>
        </trans-unit>
        <trans-unit id="4d250975c35bc29bcb347189b99facfa0b3287b6" translate="yes" xml:space="preserve">
          <source>Typically you'll want to change how TAP gets</source>
          <target state="translated">通常情况下,你会想改变TAP的获取方式。</target>
        </trans-unit>
        <trans-unit id="291f2d298dd4e6053c773023592956eee5655566" translate="yes" xml:space="preserve">
          <source>Typically, Perl tests are run through this. However, anything which spits out TAP is fine. You can use this argument to specify the name of the program (and optional switches) to run your tests with:</source>
          <target state="translated">通常情况下,Perl测试是通过这个来运行的。然而,任何能吐出TAP的程序都可以。你可以用这个参数来指定程序的名称 (和可选的开关)来运行你的测试。</target>
        </trans-unit>
        <trans-unit id="b62868c79b9e92764b29688b63eb397e1c587dcb" translate="yes" xml:space="preserve">
          <source>Typically, a &lt;code&gt;package&lt;/code&gt; statement is the first declaration in a file included in a program by one of the &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, or &lt;code&gt;use&lt;/code&gt; operators. You can switch into a package in more than one place: &lt;code&gt;package&lt;/code&gt; has no effect beyond specifying which symbol table the compiler will use for dynamic symbols for the rest of that block or until the next &lt;code&gt;package&lt;/code&gt; statement. You can refer to variables and filehandles in other packages by prefixing the identifier with the package name and a double colon: &lt;code&gt;$Package::Variable&lt;/code&gt;. If the package name is null, the &lt;code&gt;main&lt;/code&gt; package is assumed. That is, &lt;code&gt;$::sail&lt;/code&gt; is equivalent to &lt;code&gt;$main::sail&lt;/code&gt;.</source>
          <target state="translated">通常， &lt;code&gt;package&lt;/code&gt; 语句是 &lt;code&gt;do&lt;/code&gt; ， &lt;code&gt;require&lt;/code&gt; 或 &lt;code&gt;use&lt;/code&gt; 运算符之一在程序包含的文件中的第一个声明。您可以在多个位置切换到程序包： &lt;code&gt;package&lt;/code&gt; 除了指定编译器将在该块的其余部分或直到下一个 &lt;code&gt;package&lt;/code&gt; 语句之前将哪个符号表用于动态符号之外，没有其他作用。您可以通过在标识符前面加上软件包名称和双冒号来引用其他软件包中的变量和文件句柄： &lt;code&gt;$Package::Variable&lt;/code&gt; 。如果程序包名称为null，则假定 &lt;code&gt;main&lt;/code&gt; 程序包。也就是说， &lt;code&gt;$::sail&lt;/code&gt; 等效于 &lt;code&gt;$main::sail&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc1a3db1817e4391406ea8e4c10b938d812a2baf" translate="yes" xml:space="preserve">
          <source>Typically, a C compiler allocates 12 bytes to a &lt;code&gt;gappy_t&lt;/code&gt; variable, but requires only 8 bytes for a &lt;code&gt;dense_t&lt;/code&gt; . After investigating this further, we can draw memory maps, showing where the extra 4 bytes are hidden:</source>
          <target state="translated">通常，C编译器将12个字节分配给 &lt;code&gt;gappy_t&lt;/code&gt; 变量，但是对于 &lt;code&gt;dense_t&lt;/code&gt; 只需要8个字节。在进一步研究之后，我们可以绘制内存映射，显示出多余的4个字节在哪里被隐藏：</target>
        </trans-unit>
        <trans-unit id="842e52cd2265b412e8f4aaf0dec34c2c2fc7c9ed" translate="yes" xml:space="preserve">
          <source>Typically, a C compiler allocates 12 bytes to a &lt;code&gt;gappy_t&lt;/code&gt; variable, but requires only 8 bytes for a &lt;code&gt;dense_t&lt;/code&gt;. After investigating this further, we can draw memory maps, showing where the extra 4 bytes are hidden:</source>
          <target state="translated">通常，C编译器将12个字节分配给 &lt;code&gt;gappy_t&lt;/code&gt; 变量，但是对于 &lt;code&gt;dense_t&lt;/code&gt; 只需要8个字节。在进一步研究之后，我们可以绘制内存映射，显示出多余的4个字节在哪里被隐藏：</target>
        </trans-unit>
        <trans-unit id="83c91d2712bb90187ca081aa74ad37d202d5e800" translate="yes" xml:space="preserve">
          <source>Typically, however, things are the other way around: the tieable class expects its arguments as a flattened list, so the attribute looks like:</source>
          <target state="translated">然而,通常情况下,事情是相反的:可绑定类希望它的参数是一个扁平化的列表,所以属性看起来像。</target>
        </trans-unit>
        <trans-unit id="f8985e43d2d106574f328b34641196cf266af572" translate="yes" xml:space="preserve">
          <source>Typically, the</source>
          <target state="translated">通常情况下</target>
        </trans-unit>
        <trans-unit id="a2dcf9e9fce909e6d70f7fd2b928940489e6fad5" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype d off&quot; or &quot;buildtype d&quot; at the command prompt causes the buildtype to be set to Debug type with D1 flag set.</source>
          <target state="translated">在命令提示符下键入 &quot;buildtype d off &quot;或 &quot;buildtype d &quot;会使buildtype被设置为Debug类型,并设置D1标志。</target>
        </trans-unit>
        <trans-unit id="b2c7510e598f94047792f2e34322c55a1d654ee0" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype d on&quot; at the command prompt causes the buildtype to be set to Debug type with D2 flag set.</source>
          <target state="translated">在命令提示符下输入 &quot;buildtype d on &quot;会使buildtype被设置为Debug类型,并设置D2标志。</target>
        </trans-unit>
        <trans-unit id="6127511edf886df0417540a81474ffb3800e60b7" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype r&quot; at the command prompt sets it to Release Build type.</source>
          <target state="translated">在命令提示符下输入 &quot;buildtype r &quot;将其设置为Release Build类型。</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="70ae2f8ea36eac22765cdf44837146969d083d4c" translate="yes" xml:space="preserve">
          <source>U/WIN specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_Unix的U/WIN特定子类。</target>
        </trans-unit>
        <trans-unit id="e87e721b92dfc3ce5a42bdc5529d628275269297" translate="yes" xml:space="preserve">
          <source>UAX #11: East Asian Width</source>
          <target state="translated">UAX#11:东亚宽度</target>
        </trans-unit>
        <trans-unit id="54e111693f7553557203eea396555ad20db941bc" translate="yes" xml:space="preserve">
          <source>UAX #14: Unicode Line Breaking Algorithm</source>
          <target state="translated">UAX #14:Unicode断行算法</target>
        </trans-unit>
        <trans-unit id="f62b71447bb2670ca75d2c60404b5335b86f48a9" translate="yes" xml:space="preserve">
          <source>UAX #15: Unicode Normalization Forms</source>
          <target state="translated">UAX #15:Unicode规范化表格。</target>
        </trans-unit>
        <trans-unit id="57fbcb66826627051473f0031e536eaa29808986" translate="yes" xml:space="preserve">
          <source>UAX #29: Unicode Text Segmentation</source>
          <target state="translated">UAX #29:Unicode文本分割。</target>
        </trans-unit>
        <trans-unit id="04846c59e74a6b4b2e534cd9cb9a90b44ec543b2" translate="yes" xml:space="preserve">
          <source>UAX #44: Unicode Character Database</source>
          <target state="translated">UAX #44:Unicode字符数据库</target>
        </trans-unit>
        <trans-unit id="591e272980f29149d094e061515f3a24c2416346" translate="yes" xml:space="preserve">
          <source>UC</source>
          <target state="translated">UC</target>
        </trans-unit>
        <trans-unit id="3a333ea8bebfa50b73219f11f7bf0ebbb8c9a863" translate="yes" xml:space="preserve">
          <source>UCA recommends that out-of-range values should not be ignored for security reasons. Say, &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; should not be equal to &lt;code&gt;&quot;perl&quot;&lt;/code&gt; . However, &lt;code&gt;U+FFFD&lt;/code&gt; is wrongly mapped to a variable collation element in DUCET for Unicode 6.0.0 to 6.2.0, that means out-of-range values will be ignored when &lt;code&gt;variable&lt;/code&gt; isn't &lt;code&gt;Non-ignorable&lt;/code&gt; .</source>
          <target state="translated">UCA建议出于安全原因，不应忽略超出范围的值。说 &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; 不应等于 &lt;code&gt;&quot;perl&quot;&lt;/code&gt; 。但是，对于Unicode 6.0.0至6.2.0 ， &lt;code&gt;U+FFFD&lt;/code&gt; 错误地映射到DUCET中的变量归类元素，这意味着当 &lt;code&gt;variable&lt;/code&gt; 不是 &lt;code&gt;Non-ignorable&lt;/code&gt; ignorable时，超出范围的值将被忽略。</target>
        </trans-unit>
        <trans-unit id="492c906fc3f312af6ae908d9ffaf994fd07f46cc" translate="yes" xml:space="preserve">
          <source>UCA recommends that out-of-range values should not be ignored for security reasons. Say, &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; should not be equal to &lt;code&gt;&quot;perl&quot;&lt;/code&gt;. However, &lt;code&gt;U+FFFD&lt;/code&gt; is wrongly mapped to a variable collation element in DUCET for Unicode 6.0.0 to 6.2.0, that means out-of-range values will be ignored when &lt;code&gt;variable&lt;/code&gt; isn't &lt;code&gt;Non-ignorable&lt;/code&gt;.</source>
          <target state="translated">UCA建议出于安全原因，不应忽略超出范围的值。说 &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; 不应等于 &lt;code&gt;&quot;perl&quot;&lt;/code&gt; 。但是，对于Unicode 6.0.0至6.2.0 ， &lt;code&gt;U+FFFD&lt;/code&gt; 错误地映射到DUCET中的变量归类元素，这意味着当 &lt;code&gt;variable&lt;/code&gt; 不是 &lt;code&gt;Non-ignorable&lt;/code&gt; ignorable时，超出范围的值将被忽略。</target>
        </trans-unit>
        <trans-unit id="46cc4029c87ef2347d0792acb85d7dbc180043ff" translate="yes" xml:space="preserve">
          <source>UCA_Version</source>
          <target state="translated">UCA_Version</target>
        </trans-unit>
        <trans-unit id="e80de0851d29f92f6e9e34856bbc13a9b674c12b" translate="yes" xml:space="preserve">
          <source>UCS</source>
          <target state="translated">UCS</target>
        </trans-unit>
        <trans-unit id="c3ba710b4e9b506e4750f6e24e9eeec383e609b3" translate="yes" xml:space="preserve">
          <source>UCS-2</source>
          <target state="translated">UCS-2</target>
        </trans-unit>
        <trans-unit id="206177d23e4d5ec0abfb5c6b0df396d679742e7c" translate="yes" xml:space="preserve">
          <source>UCS-2 is a fixed-length encoding with each character taking 16 bits. It &lt;b&gt;does not&lt;/b&gt; support</source>
          <target state="translated">UCS-2是定长编码，每个字符占用16位。它&lt;b&gt;不&lt;/b&gt;支持</target>
        </trans-unit>
        <trans-unit id="daeba9311089266fcf0acd6d54c9e56ca13a992e" translate="yes" xml:space="preserve">
          <source>UCS-2, UCS-4</source>
          <target state="translated">UCS-2、UCS-4</target>
        </trans-unit>
        <trans-unit id="e9a6f622e340090feb219eb5c94b0df756e8e486" translate="yes" xml:space="preserve">
          <source>UDP</source>
          <target state="translated">UDP</target>
        </trans-unit>
        <trans-unit id="a392dc8e430c846ca90f8e40c79fda571eef8daf" translate="yes" xml:space="preserve">
          <source>UDP datagrams are</source>
          <target state="translated">UDP数据报是</target>
        </trans-unit>
        <trans-unit id="0b1ddbe7e9085079ee7967600cb1889fd0b548d1" translate="yes" xml:space="preserve">
          <source>UDP: Message Passing</source>
          <target state="translated">UDP:信息传递</target>
        </trans-unit>
        <trans-unit id="d946adf52a4783929f122d341b29ac0fe188371c" translate="yes" xml:space="preserve">
          <source>UID</source>
          <target state="translated">UID</target>
        </trans-unit>
        <trans-unit id="6baa0c91c35738e244018a78ee06f9f0b5e589ea" translate="yes" xml:space="preserve">
          <source>UNDEF</source>
          <target state="translated">UNDEF</target>
        </trans-unit>
        <trans-unit id="bbb2722df9c1be9f9216f08d7da234a2e705e9d4" translate="yes" xml:space="preserve">
          <source>UNDERBAR</source>
          <target state="translated">UNDERBAR</target>
        </trans-unit>
        <trans-unit id="74ff590c1dac1161eec0fbaa8b7d8b3a98fff4d5" translate="yes" xml:space="preserve">
          <source>UNICODE AND SIDE EFFECTS</source>
          <target state="translated">统一编码和副作用</target>
        </trans-unit>
        <trans-unit id="0f9d971f52bdd7a74ebeb786ec5143de4c2935d5" translate="yes" xml:space="preserve">
          <source>UNICODE IN OLDER PERLS</source>
          <target state="translated">旧版PERLS中的UNICODE</target>
        </trans-unit>
        <trans-unit id="3d51f9ce7ad6a8a131760c17f51427e8bbfb85b1" translate="yes" xml:space="preserve">
          <source>UNICODE_REPLACEMENT</source>
          <target state="translated">UNICODE_REPLACEMENT</target>
        </trans-unit>
        <trans-unit id="94c5e5979031dbec3b6f240558b2bfaa36f46791" translate="yes" xml:space="preserve">
          <source>UNIMPLEMENTED</source>
          <target state="translated">UNIMPLEMENTED</target>
        </trans-unit>
        <trans-unit id="9392ee60535a3aa7bb3335f263044b78e27554ed" translate="yes" xml:space="preserve">
          <source>UNISTD</source>
          <target state="translated">UNISTD</target>
        </trans-unit>
        <trans-unit id="c070755890afd262edf57a1cfae99ffc017d2459" translate="yes" xml:space="preserve">
          <source>UNITCHECK</source>
          <target state="translated">UNITCHECK</target>
        </trans-unit>
        <trans-unit id="bc192a928ab3fe78a1c74cfa4d1027b44d52c868" translate="yes" xml:space="preserve">
          <source>UNIVERSAL</source>
          <target state="translated">UNIVERSAL</target>
        </trans-unit>
        <trans-unit id="1feda7e9d1b1a232e025eeb903dd53659f7b069c" translate="yes" xml:space="preserve">
          <source>UNIVERSAL - base class for ALL classes (blessed references)</source>
          <target state="translated">UNIVERSAL-所有类的基础类(祝福参考)</target>
        </trans-unit>
        <trans-unit id="b23387c60700d885c584c4f2b25855ad58b48b48" translate="yes" xml:space="preserve">
          <source>UNIX and POSIX systems provide an abstract access() operating system call, which should be used to query the read, write, and execute rights. This function hides various distinct approaches in additional operating system specific security features, like Access Control Lists (ACLs)</source>
          <target state="translated">UNIX和POSIX系统提供了一个抽象访问()的操作系统调用,应该用来查询读、写和执行权限。这个函数将各种不同的方法隐藏在额外的操作系统特定的安全功能中,比如访问控制列表(ACLs)。</target>
        </trans-unit>
        <trans-unit id="fa0c8b9587852cbf0dc08f98bcecbaed53f1e1c0" translate="yes" xml:space="preserve">
          <source>UNIX domain sockets added by Sean Robinson &amp;lt;</source>
          <target state="translated">Sean Robinson添加的UNIX域套接字&amp;lt;</target>
        </trans-unit>
        <trans-unit id="85db2499d39f4696e02fb26511b230add2c1b670" translate="yes" xml:space="preserve">
          <source>UNIX file permissions are based on sets of mode bits for {read,write,execute} for each {user,group,other}. By default Cygwin only tracks the Win32 read-only attribute represented as the UNIX file user write bit (files are always readable, files are executable if they have a</source>
          <target state="translated">UNIX文件的权限是基于每个{用户、组、其他}的{读、写、执行}模式位的集合。默认情况下,Cygwin只跟踪以UNIX文件用户写位表示的Win32只读属性(文件总是可读的,如果文件有写位,则可执行)。</target>
        </trans-unit>
        <trans-unit id="1db53023f517a9c3a97970b2e62a29042045d3f0" translate="yes" xml:space="preserve">
          <source>UNI_TO_NATIVE</source>
          <target state="translated">UNI_TO_NATIVE</target>
        </trans-unit>
        <trans-unit id="36361e169f0479184326d85ebb47825bf51a5753" translate="yes" xml:space="preserve">
          <source>UNLIKELY</source>
          <target state="translated">UNLIKELY</target>
        </trans-unit>
        <trans-unit id="5c24b56d363871364a8198c1e16261b34c9bf761" translate="yes" xml:space="preserve">
          <source>UNLINK flag available since 0.10.</source>
          <target state="translated">从0.10开始提供UNLINK标志。</target>
        </trans-unit>
        <trans-unit id="265e8c38a269eb32604a5d0ed5924378784ee057" translate="yes" xml:space="preserve">
          <source>UNSHIFT this, LIST</source>
          <target state="translated">UNSHIFT这个,LIST</target>
        </trans-unit>
        <trans-unit id="5b8f1af6e17a29d4f20f56ec6d442f59acfc755d" translate="yes" xml:space="preserve">
          <source>UNSUPPORTED</source>
          <target state="translated">UNSUPPORTED</target>
        </trans-unit>
        <trans-unit id="40cccdd49a4b2f7980664d02999aa7b9e3022b50" translate="yes" xml:space="preserve">
          <source>UNTIE by Nick Ing-Simmons &amp;lt;</source>
          <target state="translated">Nick Ing-Simmons撰写的UNTIE &amp;lt;</target>
        </trans-unit>
        <trans-unit id="41304503568dff57766f35c33ebaca45f5e827b2" translate="yes" xml:space="preserve">
          <source>UNTIE this</source>
          <target state="translated">UNTIE this</target>
        </trans-unit>
        <trans-unit id="ea518a7caeec27fa571544a1959010e8689298ab" translate="yes" xml:space="preserve">
          <source>UPGRADE SUGGESTED</source>
          <target state="translated">建议升级</target>
        </trans-unit>
        <trans-unit id="e3bb3273c3d27a35e7a79c09d285ae651319171c" translate="yes" xml:space="preserve">
          <source>UPGRADING</source>
          <target state="translated">UPGRADING</target>
        </trans-unit>
        <trans-unit id="a6b6b187a5dabe1711e09378ba034929cf5397f3" translate="yes" xml:space="preserve">
          <source>UPSTREAM indicates where patches should go. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; implies that this hasn't been discussed for the module at hand. &lt;code&gt;blead&lt;/code&gt; indicates that the copy of the module in the blead sources is to be considered canonical, &lt;code&gt;cpan&lt;/code&gt; means that the module on CPAN is to be patched first. &lt;code&gt;first-come&lt;/code&gt; means that blead can be patched freely if it is in sync with the latest release on CPAN.</source>
          <target state="translated">UPSTREAM指示应将修补程序放到哪里。 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 表示尚未对手头的模块进行讨论。 &lt;code&gt;blead&lt;/code&gt; 表示将blead源中的模块副本视为规范副本， &lt;code&gt;cpan&lt;/code&gt; 表示将首先修补CPAN上的模块。 &lt;code&gt;first-come&lt;/code&gt; 是指，如果与最新版CPAN同步，则可以免费修补blead。</target>
        </trans-unit>
        <trans-unit id="1b193f75bbf58b38858154a6e283a021406e55fd" translate="yes" xml:space="preserve">
          <source>UPSTREAM indicates where patches should go. &lt;code&gt;undef&lt;/code&gt; implies that this hasn't been discussed for the module at hand. &lt;code&gt;blead&lt;/code&gt; indicates that the copy of the module in the blead sources is to be considered canonical, &lt;code&gt;cpan&lt;/code&gt; means that the module on CPAN is to be patched first. &lt;code&gt;first-come&lt;/code&gt; means that blead can be patched freely if it is in sync with the latest release on CPAN.</source>
          <target state="translated">UPSTREAM指示应将修补程序放到哪里。 &lt;code&gt;undef&lt;/code&gt; 表示尚未对手头的模块进行讨论。 &lt;code&gt;blead&lt;/code&gt; 表示将blead源中的模块副本视为规范副本， &lt;code&gt;cpan&lt;/code&gt; 表示将首先对CPAN上的模块进行修补。 &lt;code&gt;first-come&lt;/code&gt; 意思是，如果与CPAN的最新版本同步，则可以免费对blead进行修补。</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="ba5e5280eb88749f4ed2bd7802c151c1f77cb3d7" translate="yes" xml:space="preserve">
          <source>URL decoding and encoding</source>
          <target state="translated">URL解码和编码</target>
        </trans-unit>
        <trans-unit id="a2c8158547717be782e140b2ad8b3a2b5e515fe5" translate="yes" xml:space="preserve">
          <source>URL for further information</source>
          <target state="translated">详见网址</target>
        </trans-unit>
        <trans-unit id="61aff325c59f0125c7432101521fe8aef2d620f8" translate="yes" xml:space="preserve">
          <source>URLS</source>
          <target state="translated">URLS</target>
        </trans-unit>
        <trans-unit id="cf3bfa9a159c5a5ddc20da1eccd6bbddbdc037e4" translate="yes" xml:space="preserve">
          <source>USAGE</source>
          <target state="translated">USAGE</target>
        </trans-unit>
        <trans-unit id="11db5afeaceeb6d5fec1a6025012faccc762da50" translate="yes" xml:space="preserve">
          <source>USAGE DETAILS</source>
          <target state="translated">使用细节</target>
        </trans-unit>
        <trans-unit id="3ca88d77aca2d323542d2e8f12b83151e0846c19" translate="yes" xml:space="preserve">
          <source>USE EXAMPLES</source>
          <target state="translated">使用示例</target>
        </trans-unit>
        <trans-unit id="48c336c391ccd32eaf0812999ba74a1243f916d3" translate="yes" xml:space="preserve">
          <source>USE Test2::Suite INSTEAD</source>
          <target state="translated">USE Test2::Suite INSTEAD</target>
        </trans-unit>
        <trans-unit id="ce94de210299952d4167e1951445b8720839ce7f" translate="yes" xml:space="preserve">
          <source>USEFUL</source>
          <target state="translated">USEFUL</target>
        </trans-unit>
        <trans-unit id="6eb0c61201a96afc99cbf180f1c8d93c0a9fd8c8" translate="yes" xml:space="preserve">
          <source>USER</source>
          <target state="translated">USER</target>
        </trans-unit>
        <trans-unit id="045095377d72052bacadc70846f65ba919bc72ee" translate="yes" xml:space="preserve">
          <source>USER METHODS</source>
          <target state="translated">用户方法</target>
        </trans-unit>
        <trans-unit id="eff0e1414e1813c02157d57d3f325f32947a8413" translate="yes" xml:space="preserve">
          <source>USE_MULTI &amp;amp; USE_IMP_SYS defined and USE_ITHREADS not defined</source>
          <target state="translated">已定义USE_MULTI和USE_IMP_SYS，未定义USE_ITHREADS</target>
        </trans-unit>
        <trans-unit id="5e29b7b3b7536de15b46013805cfeb875c7a61d3" translate="yes" xml:space="preserve">
          <source>USE_MULTI, USE_ITHREADS &amp;amp; USE_IMP_SYS defined</source>
          <target state="translated">定义了USE_MULTI，USE_ITHREADS和USE_IMP_SYS</target>
        </trans-unit>
        <trans-unit id="227996d58fdfdee97220bd395f44c03336330289" translate="yes" xml:space="preserve">
          <source>USE_PERL_FLOCK</source>
          <target state="translated">USE_PERL_FLOCK</target>
        </trans-unit>
        <trans-unit id="f8104e09349c8c6000afb7fc05a4ed027d50f4e3" translate="yes" xml:space="preserve">
          <source>USE_THREADS</source>
          <target state="translated">USE_THREADS</target>
        </trans-unit>
        <trans-unit id="eeb0c37772a1b806f230c8036c163dab104d01af" translate="yes" xml:space="preserve">
          <source>USING A CONTEXT</source>
          <target state="translated">使用语境</target>
        </trans-unit>
        <trans-unit id="d403f19c30d9dafcf5b6a7bb8666159dacf7697f" translate="yes" xml:space="preserve">
          <source>USING B::Deparse AS A MODULE</source>
          <target state="translated">使用 B::Deparse 作为一个模块。</target>
        </trans-unit>
        <trans-unit id="2efa10816450d527d9e56d3271b7e34ea8c81a61" translate="yes" xml:space="preserve">
          <source>USING CONTEXT: THE DEBUG FILTER</source>
          <target state="translated">使用上下文:DEBUG过滤器</target>
        </trans-unit>
        <trans-unit id="5dc41a076ce2820059919cbbf35a7c867770cef6" translate="yes" xml:space="preserve">
          <source>USING FILTERS</source>
          <target state="translated">使用过滤器</target>
        </trans-unit>
        <trans-unit id="3d73074a3cddd39278e855bf130287734b3a28e3" translate="yes" xml:space="preserve">
          <source>USING LOCALES</source>
          <target state="translated">使用LOCALS</target>
        </trans-unit>
        <trans-unit id="e914e6326e1588417f534e760a668a311b7406cd" translate="yes" xml:space="preserve">
          <source>USING PERL IN OPENVOS</source>
          <target state="translated">在OPENVOS中使用PERL</target>
        </trans-unit>
        <trans-unit id="99eec133fe1ada053200d233f3eaa4520c2bb5fb" translate="yes" xml:space="preserve">
          <source>USING THE CONSTRUCTOR</source>
          <target state="translated">使用建设者</target>
        </trans-unit>
        <trans-unit id="ac35aec57e40ba482f8f9fa734ce439013d2f6b2" translate="yes" xml:space="preserve">
          <source>USING THE EXTERNAL GZIP</source>
          <target state="translated">使用外部的GZIP文件</target>
        </trans-unit>
        <trans-unit id="ca105f51c68cd465fba8a30858f385516bc30dcf" translate="yes" xml:space="preserve">
          <source>USING UTF8</source>
          <target state="translated">使用UTF8</target>
        </trans-unit>
        <trans-unit id="6af50db97d3b4d2d4a30cc3bc98a5ffb4cb39ec7" translate="yes" xml:space="preserve">
          <source>USourceData.txt</source>
          <target state="translated">USourceData.txt</target>
        </trans-unit>
        <trans-unit id="d96ff9257bc1dd5af725fa01d1ac6c3c64b3d707" translate="yes" xml:space="preserve">
          <source>USourceGlyphs.pdf</source>
          <target state="translated">USourceGlyphs.pdf</target>
        </trans-unit>
        <trans-unit id="618f65101275eae124d9a7c9c7a5431c588e88d8" translate="yes" xml:space="preserve">
          <source>UTF</source>
          <target state="translated">UTF</target>
        </trans-unit>
        <trans-unit id="6b28c2250a1cbb7c8f56dfcf0dd9e06201c35f2f" translate="yes" xml:space="preserve">
          <source>UTF stands for &quot;Unicode Transformation Format&quot;. UTF-8 is an encoding of Unicode into a sequence of 8-bit byte chunks, based on ASCII and Latin-1. The length of a sequence required to represent a Unicode code point depends on the ordinal number of that code point, with larger numbers requiring more bytes. UTF-EBCDIC is like UTF-8, but based on EBCDIC. They are enough alike that often, casual usage will conflate the two terms, and use &quot;UTF-8&quot; to mean both the UTF-8 found on ASCII platforms, and the UTF-EBCDIC found on EBCDIC ones.</source>
          <target state="translated">UTF是 &quot;Unicode转换格式 &quot;的缩写。UTF-8是一种基于ASCII和Latin-1的Unicode编码,将Unicode编码成8位字节块的序列。表示一个Unicode码点所需的序列长度取决于该码点的序数,数字越大需要的字节数越多。UTF-EBCDIC和UTF-8一样,但基于EBCDIC。它们非常相像,所以经常会有一些人把这两个术语混为一谈,用 &quot;UTF-8 &quot;来表示ASCII平台上的UTF-8和EBCDIC平台上的UTF-EBCDIC。</target>
        </trans-unit>
        <trans-unit id="5a9da893be5fd5fae314bea8dcdeeee12beeec4b" translate="yes" xml:space="preserve">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>
        </trans-unit>
        <trans-unit id="c965e907f9d25c517a8e5bd79aea9417a0714217" translate="yes" xml:space="preserve">
          <source>UTF-16 is almost the same as UCS-2 but it supports</source>
          <target state="translated">UTF-16与UCS-2几乎相同,但它支持的是</target>
        </trans-unit>
        <trans-unit id="6368ee0d76a2ca5c3d83c85e127ba1610670e64c" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate U+%X</source>
          <target state="translated">UTF-16的代名词U+%X.</target>
        </trans-unit>
        <trans-unit id="5222e4ab75ba1ce305284f282ec30a73156a366c" translate="yes" xml:space="preserve">
          <source>UTF-16, UTF-16BE, UTF-16LE, Surrogates, and &lt;code&gt;BOM&lt;/code&gt; 's (Byte Order Marks)</source>
          <target state="translated">UTF-16，UTF-16BE，UTF-16LE，代理和 &lt;code&gt;BOM&lt;/code&gt; （字节顺序标记）</target>
        </trans-unit>
        <trans-unit id="ca51c01ddb04a5d5f4843a1045e4eb7fa59f4fe4" translate="yes" xml:space="preserve">
          <source>UTF-16, UTF-16BE, UTF-16LE, Surrogates, and &lt;code&gt;BOM&lt;/code&gt;'s (Byte Order Marks)</source>
          <target state="translated">UTF-16，UTF-16BE，UTF-16LE，代理和 &lt;code&gt;BOM&lt;/code&gt; （字节顺序标记）</target>
        </trans-unit>
        <trans-unit id="47a1ff59a1e826be6636526f502c21d7b7b97ead" translate="yes" xml:space="preserve">
          <source>UTF-32 (UCS-4) is a fixed-length encoding with each character taking 32 bits. Since it is 32-bit, there is no need for</source>
          <target state="translated">UTF-32(UCS-4)是一种固定长度的编码,每个字符占32位。由于它是32位的,所以没有必要使用 &quot;UCS-4&quot;。</target>
        </trans-unit>
        <trans-unit id="dfd8dce020ef601007001e4289b99a7908444d8a" translate="yes" xml:space="preserve">
          <source>UTF-32, UTF-32BE, UTF-32LE</source>
          <target state="translated">UTF-32,UTF-32BE,UTF-32LE。</target>
        </trans-unit>
        <trans-unit id="20e199acc434517cd4a6e5977a48bae6e5af47a4" translate="yes" xml:space="preserve">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>
        </trans-unit>
        <trans-unit id="4d56cb8e2ad2a50613de9fa7d9d9a0d239c1aca9" translate="yes" xml:space="preserve">
          <source>UTF-7 encoding</source>
          <target state="translated">UTF-7编码</target>
        </trans-unit>
        <trans-unit id="c69eadbe302e95901c2e20dc0780e1b33ffbf733" translate="yes" xml:space="preserve">
          <source>UTF-7 is a special encoding which &quot;re-encodes&quot; UTF-16BE into a 7-bit encoding. It is implemented separately by Encode::Unicode::UTF7.</source>
          <target state="translated">UTF-7是一种特殊的编码,它将UTF-16BE重新编码为7位编码。它由Encode::Unicode::UTF7单独实现。</target>
        </trans-unit>
        <trans-unit id="ba8308c0cebaf2cef9e02fb7f26e6c4f56ba6ce0" translate="yes" xml:space="preserve">
          <source>UTF-7 was not supported by Encode until version 1.95 because of that. But Unicode::String, a module by Gisle Aas which adds Unicode supports to non-utf8-savvy perl did support UTF-7, the UTF-7 support was added so Encode can supersede Unicode::String 100%.</source>
          <target state="translated">因为这个原因,Encode在1.95版本之前都不支持UTF-7,但Gisle Aas的Unicode::String模块增加了对UTF-7的支持。但是Gisle Aas的一个模块Unicode::String为不精通utf8的perl增加了Unicode支持,确实支持UTF-7,UTF-7的支持被加入,所以Encode可以100%取代Unicode::String。</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="e2635de14b396bd81c2a4f587434aea9cfbf99fc" translate="yes" xml:space="preserve">
          <source>UTF-8 and UTF-EBCDIC are two different encodings used to represent Unicode code points as sequences of bytes. Macros with the same names (but different definitions) in</source>
          <target state="translated">UTF-8和UTF-EBCDIC是两种不同的编码,用来表示Unicode码点的字节序列。中名称相同(但定义不同)的宏。</target>
        </trans-unit>
        <trans-unit id="8b4fe83acd749a66b827e068556fa7943eee22bb" translate="yes" xml:space="preserve">
          <source>UTF-8 and Unicode FAQ for Unix/Linux</source>
          <target state="translated">UTF-8和Unicode常见问题解答(Unix/Linux)</target>
        </trans-unit>
        <trans-unit id="79cdcb7150e1254a38f057938e6f4012fc46b08a" translate="yes" xml:space="preserve">
          <source>UTF-8 is a variable-length (1 to 4 bytes), byte-order independent encoding. In most of Perl's documentation, including elsewhere in this document, the term &quot;UTF-8&quot; means also &quot;UTF-EBCDIC&quot;. But in this section, &quot;UTF-8&quot; refers only to the encoding used on ASCII platforms. It is a superset of 7-bit US-ASCII, so anything encoded in ASCII has the identical representation when encoded in UTF-8.</source>
          <target state="translated">UTF-8 是一种可变长度(1 到 4 个字节)、独立于字节顺序的编码。在Perl的大部分文档中,包括本文档的其他地方,术语 &quot;UTF-8 &quot;也意味着 &quot;UTF-EBCDIC&quot;。但在本节中,&quot;UTF-8 &quot;仅指ASCII平台上使用的编码。它是7位US-ASCII的超集,所以任何用ASCII编码的东西在用UTF-8编码时都有相同的表示。</target>
        </trans-unit>
        <trans-unit id="2d6c49b0c5ea97423fbd4064bf9d6fbd9eeb0509" translate="yes" xml:space="preserve">
          <source>UTF-8 is very structured, so many combinations of bytes are invalid. In the past, Perl tried to soldier on and make some sense of invalid combinations, but this can lead to security holes, so now, if the Perl core needs to process an invalid combination, it will either raise a fatal error, or will replace those bytes by the sequence that forms the Unicode REPLACEMENT CHARACTER, for which purpose Unicode created it.</source>
          <target state="translated">UTF-8的结构性很强,所以很多字节的组合都是无效的。过去,Perl试图兵来将挡,让无效组合变得有意义,但这可能会导致安全漏洞,所以现在,如果Perl核心需要处理一个无效组合,它要么会引发一个致命的错误,要么会用构成Unicode REPLACEMENT CHARACTER的序列来替换这些字节,Unicode就是为了这个目的而创建的。</target>
        </trans-unit>
        <trans-unit id="64b07e44d3986db9cf7499225144a4d1d394db97" translate="yes" xml:space="preserve">
          <source>UTF-8 treats the first 128 codepoints, 0..127, the same as ASCII. They take only one byte per character. All other characters are encoded as two to four bytes using a complex scheme. Fortunately, Perl handles this for us, so we don't have to worry about this.</source>
          <target state="translated">UTF-8对前128个代码点0...127的处理与ASCII相同。它们每个字符只需要一个字节。所有其他的字符都要用一个复杂的方案编码成两到四个字节。幸运的是,Perl为我们处理了这个问题,所以我们不必担心这个问题。</target>
        </trans-unit>
        <trans-unit id="7443ec4bd05d2044739a43a92206bcfe32f068b2" translate="yes" xml:space="preserve">
          <source>UTF-8 vs. utf8 vs. UTF8</source>
          <target state="translated">UTF-8 vs.utf8 vs.UTF8。</target>
        </trans-unit>
        <trans-unit id="21357a91ac9a6238516304ecf3d0973befa29dc1" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC</source>
          <target state="translated">UTF-EBCDIC</target>
        </trans-unit>
        <trans-unit id="54206a5f5bcbb8b5ddd3ceb665085cec48ec6be8" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is defined by &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr16&quot;&gt;Unicode Technical Report #16&lt;/a&gt;. It is defined based on CCSID 1047, not allowing for the differences for other code pages. This allows for easy interchange of text between computers running different code pages, but makes it unusable, without adaptation, for Perl on those other code pages.</source>
          <target state="translated">UTF-EBCDIC由&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr16&quot;&gt;Unicode技术报告＃16&lt;/a&gt;定义。它是根据CCSID 1047定义的，不允许其他代码页有所不同。这样可以在运行不同代码页的计算机之间轻松交换文本，但是对于其他代码页上的Perl，如果不进行修改，就无法使用。</target>
        </trans-unit>
        <trans-unit id="d1acc50280127d54b308a40ab3c768e112572a85" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is defined by &lt;a href=&quot;https://www.unicode.org/reports/tr16&quot;&gt;Unicode Technical Report #16&lt;/a&gt; (often referred to as just TR16). It is defined based on CCSID 1047, not allowing for the differences for other code pages. This allows for easy interchange of text between computers running different code pages, but makes it unusable, without adaptation, for Perl on those other code pages.</source>
          <target state="translated">UTF-EBCDIC由&lt;a href=&quot;https://www.unicode.org/reports/tr16&quot;&gt;Unicode技术报告＃16&lt;/a&gt;（通常称为TR16）定义。它是根据CCSID 1047定义的，不允许其他代码页有所不同。这样可以在运行不同代码页的计算机之间轻松交换文本，但是对于其他代码页上的Perl，如果不进行修改，就无法使用。</target>
        </trans-unit>
        <trans-unit id="f9b0bbf585cedfbc65f392d0551056f49932bbd3" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is used on EBCDIC platforms. It generally requires more bytes to represent a given code point than UTF-8 does; the largest Unicode code points take 5 bytes to represent (instead of 4 in UTF-8), and, extended for 64-bit words, it uses 14 bytes instead of 13 bytes in UTF-8.</source>
          <target state="translated">UTF-EBCDIC用于EBCDIC平台。它通常比UTF-8需要更多的字节来表示一个给定的码点;最大的Unicode码点需要5个字节来表示(而不是UTF-8的4个字节),而且,扩展到64位单词,它使用14个字节而不是UTF-8的13个字节。</target>
        </trans-unit>
        <trans-unit id="fae1061497efd49ee6054c0a3d6e1ce19e05e6be" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is used on EBCDIC platforms. The largest Unicode code points take 5 bytes to represent (instead of 4 in UTF-8), and Perl extends it to a maximum of 7 bytes to encode pode points up to what can fit in a 32-bit word (instead of 13 bytes and a 64-bit word in UTF-8).</source>
          <target state="translated">在EBCDIC平台上使用UTF-EBCDIC。最大的Unicode码点需要5个字节来表示(而不是UTF-8中的4个字节),Perl将其扩展到最大7个字节,以将码点编码到32位字中(而不是UTF-8中的13个字节和64位字)。</target>
        </trans-unit>
        <trans-unit id="32e4aba336279eb247fca6069de55e692fafce3d" translate="yes" xml:space="preserve">
          <source>UTF-X</source>
          <target state="translated">UTF-X</target>
        </trans-unit>
        <trans-unit id="31c724652517aa38e02f9cc38046b12306389452" translate="yes" xml:space="preserve">
          <source>UTF8SKIP</source>
          <target state="translated">UTF8SKIP</target>
        </trans-unit>
        <trans-unit id="126afec887a4798caa07a768c2ae8b1e709d5df3" translate="yes" xml:space="preserve">
          <source>UTF8_CHK_SKIP</source>
          <target state="translated">UTF8_CHK_SKIP</target>
        </trans-unit>
        <trans-unit id="f98f9b7b4dfefa91df6e8d07ade4cdf88d2b3a4e" translate="yes" xml:space="preserve">
          <source>UTF8_IS_INVARIANT</source>
          <target state="translated">UTF8_IS_INVARIANT</target>
        </trans-unit>
        <trans-unit id="ce7018ef4c544b4117f40b9403d65042195dc6ca" translate="yes" xml:space="preserve">
          <source>UTF8_IS_NONCHAR</source>
          <target state="translated">UTF8_IS_NONCHAR</target>
        </trans-unit>
        <trans-unit id="43a7d7eb6f7a4999dcf643e96fc55bf3ed29e04b" translate="yes" xml:space="preserve">
          <source>UTF8_IS_SUPER</source>
          <target state="translated">UTF8_IS_SUPER</target>
        </trans-unit>
        <trans-unit id="41c64bb8f1a0503efaa4f02874d635fa7fb44ce4" translate="yes" xml:space="preserve">
          <source>UTF8_IS_SURROGATE</source>
          <target state="translated">UTF8_IS_SURROGATE</target>
        </trans-unit>
        <trans-unit id="45d5fa1bf0c167c3f6576cc7457645a65299cae3" translate="yes" xml:space="preserve">
          <source>UTF8_MAXBYTES</source>
          <target state="translated">UTF8_MAXBYTES</target>
        </trans-unit>
        <trans-unit id="0a897c1fa81d6a6686e912ed672c264e86acb2f9" translate="yes" xml:space="preserve">
          <source>UTF8_MAXBYTES_CASE</source>
          <target state="translated">UTF8_MAXBYTES_CASE</target>
        </trans-unit>
        <trans-unit id="8af74f37673e55aee8c36bf5b73bd668baf4075c" translate="yes" xml:space="preserve">
          <source>UTF8_SAFE_SKIP</source>
          <target state="translated">UTF8_SAFE_SKIP</target>
        </trans-unit>
        <trans-unit id="69870d763a319ff2077dd64b9f02bdfd1ad88546" translate="yes" xml:space="preserve">
          <source>UTF8_SKIP</source>
          <target state="translated">UTF8_SKIP</target>
        </trans-unit>
        <trans-unit id="17562b3d061f2f42586076a6b020ba8eb357a3ff" translate="yes" xml:space="preserve">
          <source>UTILITIES</source>
          <target state="translated">UTILITIES</target>
        </trans-unit>
        <trans-unit id="58bc809d31f639453a46636f9c8ab08c8b78bb44" translate="yes" xml:space="preserve">
          <source>UTILITY FUNCTIONS</source>
          <target state="translated">实用功能</target>
        </trans-unit>
        <trans-unit id="0df889160bec1efd3a376bc092db51a6960809d0" translate="yes" xml:space="preserve">
          <source>UTS #10: Unicode Collation Algorithm</source>
          <target state="translated">UTS #10:统一码整理算法</target>
        </trans-unit>
        <trans-unit id="876d25fb5dd30a195bda72a305a7ba4a3acfcb55" translate="yes" xml:space="preserve">
          <source>UTS #18: Unicode Regular Expressions</source>
          <target state="translated">UTS #18:Unicode正则表达式。</target>
        </trans-unit>
        <trans-unit id="edd7d8b48471cc7bdfa22b6a7694cc46d2409bb0" translate="yes" xml:space="preserve">
          <source>UV</source>
          <target state="translated">UV</target>
        </trans-unit>
        <trans-unit id="b25ef34eb3a5137d61daf0def8b67fe626cd3875" translate="yes" xml:space="preserve">
          <source>UVCHR_IS_INVARIANT</source>
          <target state="translated">UVCHR_IS_INVARIANT</target>
        </trans-unit>
        <trans-unit id="626b2f1b7c0d475b14997cb2d1af0b7a04543371" translate="yes" xml:space="preserve">
          <source>UVCHR_SKIP</source>
          <target state="translated">UVCHR_SKIP</target>
        </trans-unit>
        <trans-unit id="9746ff9d4d7b1c241287393e4d9dd0cd6f1bbf03" translate="yes" xml:space="preserve">
          <source>UVX</source>
          <target state="translated">UVX</target>
        </trans-unit>
        <trans-unit id="e92904bce8026b3c1f8828b0ce882e6b081c7fb6" translate="yes" xml:space="preserve">
          <source>Uganda</source>
          <target state="translated">Uganda</target>
        </trans-unit>
        <trans-unit id="c951ec00f123510a00d1e3d9539b11b4631d4096" translate="yes" xml:space="preserve">
          <source>Ukraine</source>
          <target state="translated">Ukraine</target>
        </trans-unit>
        <trans-unit id="994023f4756ccee554f76e83b238ef8441ca987c" translate="yes" xml:space="preserve">
          <source>Ultimate control over what should be done when (actually: each time) an option is encountered on the command line can be achieved by designating a reference to a subroutine (or an anonymous subroutine) as the option destination. When GetOptions() encounters the option, it will call the subroutine with two or three arguments. The first argument is the name of the option. (Actually, it is an object that stringifies to the name of the option.) For a scalar or array destination, the second argument is the value to be stored. For a hash destination, the second argument is the key to the hash, and the third argument the value to be stored. It is up to the subroutine to store the value, or do whatever it thinks is appropriate.</source>
          <target state="translated">通过指定一个对子程序(或一个匿名子程序)的引用作为选项的目标,可以最终控制在命令行上遇到一个选项时(实际上:每次)应该做什么。当GetOptions()遇到选项时,它将用两个或三个参数来调用子程序。第一个参数是期权的名称。(实际上,它是一个字符串化为选项名称的对象。)对于一个标量或数组目标,第二个参数是要存储的值。对于哈希目标,第二个参数是哈希的键,第三个参数是要存储的值。由子程序决定是否存储该值,或者做任何它认为合适的事情。</target>
        </trans-unit>
        <trans-unit id="3ee38d90a0334118e79056b8389ee44abc43742c" translate="yes" xml:space="preserve">
          <source>Unacceptable behavior will result in a public and clearly identified warning. A second instance of unacceptable behavior from the same individual will result in removal from the mailing list and GitHub issue tracker, for a period of one calendar month. The rationale for this is to provide an opportunity for the person to change the way they act.</source>
          <target state="translated">不可接受的行为将导致公开和明确的警告。如果同一人再次出现不可接受的行为,将被从邮件列表和 GitHub 问题跟踪器中删除,为期一个月。这样做的原因是为了给当事人提供一个改变行为方式的机会。</target>
        </trans-unit>
        <trans-unit id="fd11761cf7cb6cb9a563ded422bdfc4417516b2a" translate="yes" xml:space="preserve">
          <source>Unacceptable behavior will result in a public and clearly identified warning. Repeated unacceptable behavior will result in removal from the mailing list and revocation of rights to update rt.perl.org. The first removal is for one month. Subsequent removals will double in length. After six months with no warning, a user's ban length is reset. Removals, like warnings, are public.</source>
          <target state="translated">不可接受的行为将导致公开和明确的警告。重复的不可接受的行为将导致从邮件列表中移除,并取消更新rt.perl.org的权利。第一次移除的期限是一个月。其后的移除时间将加倍。六个月后,在没有警告的情况下,用户的禁言期会被重置。移除和警告一样,都是公开的。</target>
        </trans-unit>
        <trans-unit id="7be1c42f094036e0d5e47ba36abcce7c417f4479" translate="yes" xml:space="preserve">
          <source>Unambiguous name: &lt;code&gt;CP932&lt;/code&gt;. &lt;code&gt;IANA&lt;/code&gt; name (also used by Mozilla, and provided as an alias by Encode): &lt;code&gt;Windows-31J&lt;/code&gt;.</source>
          <target state="translated">明确的名称： &lt;code&gt;CP932&lt;/code&gt; 。 &lt;code&gt;IANA&lt;/code&gt; 名称（也由Mozilla使用，并且由Encode作为别名提供）： &lt;code&gt;Windows-31J&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f645668eee1c03a85fb2473dd516adceaef3f2d" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;!&quot;&lt;/code&gt; performs logical negation, that is, &quot;not&quot;. See also &lt;a href=&quot;#Logical-Not&quot;&gt;&lt;code&gt;not&lt;/code&gt;&lt;/a&gt; for a lower precedence version of this.</source>
          <target state="translated">一元 &lt;code&gt;&quot;!&quot;&lt;/code&gt; 执行逻辑否定，即&amp;ldquo;不&amp;rdquo;。也见&lt;a href=&quot;#Logical-Not&quot;&gt; &lt;code&gt;not&lt;/code&gt; &lt;/a&gt;为这个优先级较低的版本。</target>
        </trans-unit>
        <trans-unit id="1f8a4652f1c5950bdfb9f442db5f7ff059a9e8ff" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;!&quot;&lt;/code&gt; performs logical negation, that is, &quot;not&quot;. See also &lt;code&gt;not&lt;/code&gt; for a lower precedence version of this.</source>
          <target state="translated">一元 &lt;code&gt;&quot;!&quot;&lt;/code&gt; 执行逻辑否定，即&amp;ldquo;不&amp;rdquo;。也见 &lt;code&gt;not&lt;/code&gt; 为这个优先级较低的版本。</target>
        </trans-unit>
        <trans-unit id="9a531b0100d0a01bbebb12554267e4d3655767b7" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;+&quot;&lt;/code&gt; has no effect whatsoever, even on strings. It is useful syntactically for separating a function name from a parenthesized expression that would otherwise be interpreted as the complete list of function arguments. (See examples above under &lt;a href=&quot;#Terms-and-List-Operators-%28Leftward%29&quot;&gt;&quot;Terms and List Operators (Leftward)&quot;&lt;/a&gt;.)</source>
          <target state="translated">一元 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 即使对字符串也不起作用。在语法上将函数名称与带括号的表达式分开是很有用的，否则该表达式会被解释为函数参数的完整列表。 （请参见上面&lt;a href=&quot;#Terms-and-List-Operators-%28Leftward%29&quot;&gt;&amp;ldquo;术语和列表运算符（向左）&amp;rdquo;&lt;/a&gt;下的示例。）</target>
        </trans-unit>
        <trans-unit id="975143052b1e27f57ec5fcc07f42eb1c0eae9dc3" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;+&quot;&lt;/code&gt; has no effect whatsoever, even on strings. It is useful syntactically for separating a function name from a parenthesized expression that would otherwise be interpreted as the complete list of function arguments. (See examples above under &lt;a href=&quot;#Terms-and-List-Operators-(Leftward)&quot;&gt;Terms and List Operators (Leftward)&lt;/a&gt;.)</source>
          <target state="translated">一元 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 即使对字符串也不起作用。在语法上将函数名称与带括号的表达式分隔开很有用，否则该表达式会被解释为函数参数的完整列表。 （请参阅上面&amp;ldquo; &lt;a href=&quot;#Terms-and-List-Operators-(Leftward)&quot;&gt;条款和列表运算符（向左）&amp;rdquo;&lt;/a&gt;下的示例。）</target>
        </trans-unit>
        <trans-unit id="cbc2e014fe3be3f69d01617e0a9853fb77867e55" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;-&quot;&lt;/code&gt; performs arithmetic negation if the operand is numeric, including any string that looks like a number. If the operand is an identifier, a string consisting of a minus sign concatenated with the identifier is returned. Otherwise, if the string starts with a plus or minus, a string starting with the opposite sign is returned. One effect of these rules is that &lt;code&gt;-bareword&lt;/code&gt; is equivalent to the string &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt; . If, however, the string begins with a non-alphabetic character (excluding &lt;code&gt;&quot;+&quot;&lt;/code&gt; or &lt;code&gt;&quot;-&quot;&lt;/code&gt; ), Perl will attempt to convert the string to a numeric, and the arithmetic negation is performed. If the string cannot be cleanly converted to a numeric, Perl will give the warning &lt;b&gt;Argument &quot;the string&quot; isn't numeric in negation (-) at ...&lt;/b&gt;.</source>
          <target state="translated">如果操作数是数字（包括任何看起来像数字的字符串），一元 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 执行算术求反。如果操作数是标识符，则返回一个字符串，该字符串由与标识符连接的减号组成。否则，如果字符串以加号或减号开头，则返回以相反符号开头的字符串。这些规则的作用之一是 &lt;code&gt;-bareword&lt;/code&gt; 等效于字符串 &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt; 。但是，如果字符串以非字母字符（ &lt;code&gt;&quot;+&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 除外）开头，则Perl将尝试将字符串转换为数字，然后执行算术求反。如果字符串不能干净地转换为数字，Perl将给出警告&lt;b&gt;参数&amp;ldquo; string&amp;rdquo;不是...的否定（-）数字&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="7bfdc53979623a8376c9812be313cb442d92714a" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;-&quot;&lt;/code&gt; performs arithmetic negation if the operand is numeric, including any string that looks like a number. If the operand is an identifier, a string consisting of a minus sign concatenated with the identifier is returned. Otherwise, if the string starts with a plus or minus, a string starting with the opposite sign is returned. One effect of these rules is that &lt;code&gt;-bareword&lt;/code&gt; is equivalent to the string &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt;. If, however, the string begins with a non-alphabetic character (excluding &lt;code&gt;&quot;+&quot;&lt;/code&gt; or &lt;code&gt;&quot;-&quot;&lt;/code&gt;), Perl will attempt to convert the string to a numeric, and the arithmetic negation is performed. If the string cannot be cleanly converted to a numeric, Perl will give the warning &lt;b&gt;Argument &quot;the string&quot; isn't numeric in negation (-) at ...&lt;/b&gt;.</source>
          <target state="translated">如果操作数是数字（包括任何看起来像数字的字符串），则一元 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 执行算术求反。如果操作数是标识符，则返回一个字符串，该字符串由与标识符连接的减号组成。否则，如果字符串以加号或减号开头，则返回以相反符号开头的字符串。这些规则的作用之一是 &lt;code&gt;-bareword&lt;/code&gt; 等效于字符串 &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt; 。但是，如果字符串以非字母字符（ &lt;code&gt;&quot;+&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 除外）开头，则Perl将尝试将字符串转换为数字，然后执行算术求反。如果字符串不能干净地转换为数字，Perl将给出警告&lt;b&gt;参数&amp;ldquo; the string&amp;rdquo;不是...的否定（-）数字&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="75765e3d8911e6ac713c74a3a1fc1d709b9ed2ea" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;\&quot;&lt;/code&gt; creates a reference to whatever follows it. See &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Do not confuse this behavior with the behavior of backslash within a string, although both forms do convey the notion of protecting the next thing from interpolation.</source>
          <target state="translated">一元 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 会创建一个对其后面内容的引用。参见&lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;和&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。不要混淆此行为与字符串中的反斜杠行为，尽管这两种形式都传达了保护下一个内容免受插值的影响的概念。</target>
        </trans-unit>
        <trans-unit id="ebbcbdaf6ef9f2a6fa62770e3fce7999d3f8a59a" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;\&quot;&lt;/code&gt; creates references. If its operand is a single sigilled thing, it creates a reference to that object. If its operand is a parenthesised list, then it creates references to the things mentioned in the list. Otherwise it puts its operand in list context, and creates a list of references to the scalars in the list provided by the operand. See &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Do not confuse this behavior with the behavior of backslash within a string, although both forms do convey the notion of protecting the next thing from interpolation.</source>
          <target state="translated">一元 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 创建引用。如果其操作数是单个标错的事物，它将创建对该对象的引用。如果其操作数是带括号的列表，则它将创建对列表中提到的内容的引用。否则，它将其操作数放在列表上下文中，并在操作数提供的列表中创建对标量的引用的列表。参见&lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;和&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。不要将这种行为与字符串中的反斜杠的行为混淆，尽管两种形式的确传达了保护下一个内容免受插值的影响的概念。</target>
        </trans-unit>
        <trans-unit id="a440a050a6ba4df9312abb517ec0cbc1f89e1767" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;not&quot;&lt;/code&gt; returns the logical negation of the expression to its right. It's the equivalent of &lt;code&gt;&quot;!&quot;&lt;/code&gt; except for the very low precedence.</source>
          <target state="translated">一元 &lt;code&gt;&quot;not&quot;&lt;/code&gt; 返回表达式的逻辑取反。相当于 &lt;code&gt;&quot;!&quot;&lt;/code&gt; 除了非常低的优先级。</target>
        </trans-unit>
        <trans-unit id="eafed7c0deddc83d38ef5898a025102a424aea2a" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; performs bitwise negation, that is, 1's complement. For example, &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; is 0640. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt; and &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;.) Note that the width of the result is platform-dependent: &lt;code&gt;~0&lt;/code&gt; is 32 bits wide on a 32-bit platform, but 64 bits wide on a 64-bit platform, so if you are expecting a certain bit width, remember to use the &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; operator to mask off the excess bits.</source>
          <target state="translated">一元 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 执行按位求反，即1的补码。例如， &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; 是0640.（另请参见&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&amp;ldquo;整数算术&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&amp;ldquo;按位字符串运算符&amp;rdquo;&lt;/a&gt;。）注意，结果的宽度是依赖于平台的： &lt;code&gt;~0&lt;/code&gt; 是32个位宽为32位的平台上，但在64位平台上为64位宽，因此，如果您期望某个位宽，请记住使用 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 运算符来掩盖多余的位。</target>
        </trans-unit>
        <trans-unit id="4dae9b42247425fb7e1e868bc6aec93255104f04" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; performs bitwise negation, that is, 1's complement. For example, &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; is 0640. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt; and &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.) Note that the width of the result is platform-dependent: &lt;code&gt;~0&lt;/code&gt; is 32 bits wide on a 32-bit platform, but 64 bits wide on a 64-bit platform, so if you are expecting a certain bit width, remember to use the &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; operator to mask off the excess bits.</source>
          <target state="translated">一元 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 执行按位求反，即1的补码。例如， &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; 是0640.（参见&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数算术&lt;/a&gt;和&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;按位字符串运算符&lt;/a&gt;。）注意，结果的宽度是依赖于平台的： &lt;code&gt;~0&lt;/code&gt; 是32个位宽为32位的平台上，但64个位宽在64位平台上，因此，如果期望某个位宽，请记住使用 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 运算符来掩盖多余的位。</target>
        </trans-unit>
        <trans-unit id="121bb514c3415be69016271f5f8950c0aed3f161" translate="yes" xml:space="preserve">
          <source>Unbackslashed prototype characters have special meanings. Any unbackslashed &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; eats all remaining arguments, and forces list context. An argument represented by &lt;code&gt;$&lt;/code&gt; forces scalar context. An &lt;code&gt;&amp;amp;&lt;/code&gt; requires an anonymous subroutine, which, if passed as the first argument, does not require the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; keyword or a subsequent comma.</source>
          <target state="translated">不加反斜杠的原型字符具有特殊含义。任何不加反斜杠的 &lt;code&gt;@&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; 都会吃掉所有剩余的参数，并强制列出上下文。由 &lt;code&gt;$&lt;/code&gt; 表示的参数强制标量上下文。一个 &lt;code&gt;&amp;amp;&lt;/code&gt; 需要匿名的子程序，其中，如果作为第一个参数传递，不需要 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 关键字或随后的逗号。</target>
        </trans-unit>
        <trans-unit id="0f4206d3ad193e4f502eb8614314c82b73d3aac7" translate="yes" xml:space="preserve">
          <source>Unbackslashed prototype characters have special meanings. Any unbackslashed &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; eats all remaining arguments, and forces list context. An argument represented by &lt;code&gt;$&lt;/code&gt; forces scalar context. An &lt;code&gt;&amp;amp;&lt;/code&gt; requires an anonymous subroutine, which, if passed as the first argument, does not require the &lt;code&gt;sub&lt;/code&gt; keyword or a subsequent comma.</source>
          <target state="translated">不加反斜杠的原型字符具有特殊含义。任何不加反斜杠的 &lt;code&gt;@&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; 都会吃掉所有剩余的参数，并强制列出上下文。由 &lt;code&gt;$&lt;/code&gt; 表示的参数强制标量上下文。一个 &lt;code&gt;&amp;amp;&lt;/code&gt; 需要匿名的子程序，其中，如果作为第一个参数传递，不需要 &lt;code&gt;sub&lt;/code&gt; 关键字或随后的逗号。</target>
        </trans-unit>
        <trans-unit id="3738795de70b96657adef7c7eb0d0399db5d1dfd" translate="yes" xml:space="preserve">
          <source>Unbalanced context: %d more PUSHes than POPs</source>
          <target state="translated">不平衡的背景:PUSHs比POPs多出%d。</target>
        </trans-unit>
        <trans-unit id="fd301ac8b7825aca5986ed906c3a5149ebf3f404" translate="yes" xml:space="preserve">
          <source>Unbalanced saves: %d more saves than restores</source>
          <target state="translated">不平衡保存:保存量比恢复量多%d。</target>
        </trans-unit>
        <trans-unit id="6c20914fff1ee5340b7195287825b168d65cf279" translate="yes" xml:space="preserve">
          <source>Unbalanced scopes: %d more ENTERs than LEAVEs</source>
          <target state="translated">不平衡范围:ENTERs比LEAVEs多%d。</target>
        </trans-unit>
        <trans-unit id="353a68e15d6c873dffbe66b456319369d1b6b50f" translate="yes" xml:space="preserve">
          <source>Unbalanced string table refcount: (%d) for &quot;%s&quot;</source>
          <target state="translated">不平衡字符串表refcount。(%d)为&quot;%s&quot;</target>
        </trans-unit>
        <trans-unit id="d948ff04e713e8c3958319663d10246dfd6ee946" translate="yes" xml:space="preserve">
          <source>Unbalanced tmps: %d more allocs than frees</source>
          <target state="translated">不平衡的临时文件:分配数比空闲数多%d</target>
        </trans-unit>
        <trans-unit id="825c40d18a2a673a59517a26d2876574d355db3e" translate="yes" xml:space="preserve">
          <source>Uncompress gzip, zip, bzip2 or lzop file/buffer</source>
          <target state="translated">解压gzip、zip、bzip2或lzop文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="d920a6c2ef6eab3bfedd330e8191658438c99755" translate="yes" xml:space="preserve">
          <source>Uncompress gzip, zip, bzip2, xz, lzma, lzip, lzf or lzop file/buffer</source>
          <target state="translated">解压gzip、zip、bzip2、xz、lzma、lzip、lzf或lzop文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="aed55ac0a8b1616e77c1e8b5f3fc823c056e7f68" translate="yes" xml:space="preserve">
          <source>Uncompress zlib-based (zip, gzip) file/buffer</source>
          <target state="translated">解压基于zlib(zip,gzip)的文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="5566ebf8e86133343de98e57588751d94f017699" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">解压缩 &lt;code&gt;$input&lt;/code&gt; 并将未压缩的数据写入 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28f5f3ca9546807770e11a4b5cc0101b027504cd" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt;.</source>
          <target state="translated">解压缩 &lt;code&gt;$input&lt;/code&gt; 并将未压缩的数据写入 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3241d8b84b7531f4c85af8e73c024fd4504975c7" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$source&lt;/code&gt; . If successful it returns the uncompressed data. Otherwise it returns</source>
          <target state="translated">解压缩 &lt;code&gt;$source&lt;/code&gt; 。如果成功，它将返回未压缩的数据。否则返回</target>
        </trans-unit>
        <trans-unit id="3e3d7aabce04dc1ae1923e54e8345382bb871093" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$source&lt;/code&gt;. If successful it returns the uncompressed data. Otherwise it returns</source>
          <target state="translated">解压缩 &lt;code&gt;$source&lt;/code&gt; 。如果成功，它将返回未压缩的数据。否则返回</target>
        </trans-unit>
        <trans-unit id="ac8d3226186ea01833996c8b65de3f2a8379790e" translate="yes" xml:space="preserve">
          <source>Uncompression</source>
          <target state="translated">Uncompression</target>
        </trans-unit>
        <trans-unit id="4189d548d277ce627b98749a55c3556ffc35219e" translate="yes" xml:space="preserve">
          <source>Unconditionally match a bareword or any other single character, and then go back to step 1.</source>
          <target state="translated">无条件匹配一个裸字或其他任何一个单字,然后回到步骤1。</target>
        </trans-unit>
        <trans-unit id="577343970a5bf9b7cb8738f42c2797ca4589087a" translate="yes" xml:space="preserve">
          <source>Uncuddled elses and &quot;K&amp;amp;R&quot; style for indenting control constructs</source>
          <target state="translated">缩进的控件和&amp;ldquo; K＆R&amp;rdquo;风格的缩进控件结构</target>
        </trans-unit>
        <trans-unit id="11c11d31d108dd964ce797e5076b1d8839850791" translate="yes" xml:space="preserve">
          <source>Uncuddled elses.</source>
          <target state="translated">未被拥抱的地方。</target>
        </trans-unit>
        <trans-unit id="5cd9e75daaa9152346601595647eb2d9696e6583" translate="yes" xml:space="preserve">
          <source>Undef if an external</source>
          <target state="translated">如果是外部,则为不定义。</target>
        </trans-unit>
        <trans-unit id="a6e635cf2fd6fb596c7dbe39947e67bb7ea6fa49" translate="yes" xml:space="preserve">
          <source>Undefined format</source>
          <target state="translated">未定义格式</target>
        </trans-unit>
        <trans-unit id="bc4f02e6922be60fefc3ec95167f2596c8a6d252" translate="yes" xml:space="preserve">
          <source>Undefined format &quot;%s&quot; called</source>
          <target state="translated">未定义格式&quot;%s&quot;,称为</target>
        </trans-unit>
        <trans-unit id="3c4edf1aebafd67a9b05c592beff7f41d45d0d8d" translate="yes" xml:space="preserve">
          <source>Undefined sort subroutine &quot;%s&quot; called</source>
          <target state="translated">未定义排序子程序&quot;%s&quot;,称为</target>
        </trans-unit>
        <trans-unit id="4df75dc3ed124d993a3860e648584776b9c515c8" translate="yes" xml:space="preserve">
          <source>Undefined subroutine &amp;amp;%s called</source>
          <target state="translated">未定义的子例程＆％s被调用</target>
        </trans-unit>
        <trans-unit id="b410752a7d8baa31a708ac9e0618b37a2bdd788d" translate="yes" xml:space="preserve">
          <source>Undefined subroutine &amp;amp;main::GetOptions called</source>
          <target state="translated">未定义的子程序＆main :: GetOptions被调用</target>
        </trans-unit>
        <trans-unit id="547eab04e6e04e1b4edec483ca694ca7539affef" translate="yes" xml:space="preserve">
          <source>Undefined subroutine called</source>
          <target state="translated">未定义的子程序,称为</target>
        </trans-unit>
        <trans-unit id="264796a21d9347fe1112a79c8f0b60a38d55c6c6" translate="yes" xml:space="preserve">
          <source>Undefined subroutine in sort</source>
          <target state="translated">排序中未定义子程序</target>
        </trans-unit>
        <trans-unit id="6d3680cc6661c9c64f65a5465eb19c791369f48e" translate="yes" xml:space="preserve">
          <source>Undefined top format &quot;%s&quot; called</source>
          <target state="translated">未定义顶部格式&quot;%s&quot;,称为</target>
        </trans-unit>
        <trans-unit id="fc0e7464ad33c8fd897b6e1f38879e9424a6041b" translate="yes" xml:space="preserve">
          <source>Undefined value assigned to typeglob</source>
          <target state="translated">未定义的值分配给 typeglob</target>
        </trans-unit>
        <trans-unit id="4be1ae516287ece8c814ce973af8c8cef754916c" translate="yes" xml:space="preserve">
          <source>Undefines the array. Frees the memory used by the av to store its list of scalars. If any destructors are triggered as a result, the av itself may be freed.</source>
          <target state="translated">解除对数组的定义。释放av用于存储其标量列表的内存。如果因此触发了任何析构函数,则可以释放av本身。</target>
        </trans-unit>
        <trans-unit id="54917ea2121718cf7348ee74d00c8feedc82f150" translate="yes" xml:space="preserve">
          <source>Undefines the array. The XS equivalent of &lt;code&gt;undef(@array)&lt;/code&gt;.</source>
          <target state="translated">未定义数组。XS等效于 &lt;code&gt;undef(@array)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="270b863b48b0c13c0b01735bf826d9b654084021" translate="yes" xml:space="preserve">
          <source>Undefines the collation element as if it were unassigned in the &lt;code&gt;table&lt;/code&gt; . This reduces the size of the table. If an unassigned character appears in the string to be collated, the sort key is made from its codepoint as a single-character collation element, as it is greater than any other assigned collation elements (in the codepoint order among the unassigned characters). But, it'd be better to ignore characters unfamiliar to you and maybe never used.</source>
          <target state="translated">取消定义排序规则元素，就好像在 &lt;code&gt;table&lt;/code&gt; 中未分配该元素一样。这样可以减小表的大小。如果未分配的字符出现在要校对的字符串中，则排序键将从其代码点作为单字符归类元素，因为它大于任何其他已分配的归类元素（按未分配字符中的代码点顺序）。但是，最好忽略不熟悉的字符，也许永远不要使用。</target>
        </trans-unit>
        <trans-unit id="6c572aa720a9e02b4868a08c5ea6700924c6a793" translate="yes" xml:space="preserve">
          <source>Undefines the collation element as if it were unassigned in the &lt;code&gt;table&lt;/code&gt;. This reduces the size of the table. If an unassigned character appears in the string to be collated, the sort key is made from its codepoint as a single-character collation element, as it is greater than any other assigned collation elements (in the codepoint order among the unassigned characters). But, it'd be better to ignore characters unfamiliar to you and maybe never used.</source>
          <target state="translated">取消排序规则元素的定义，就好像在 &lt;code&gt;table&lt;/code&gt; 中未分配该元素一样。这样可以减小表的大小。如果未分配的字符出现在要校对的字符串中，则排序键从其代码点作为单字符归类元素，因为它大于任何其他已分配的归类元素（按未分配字符中的代码点顺序）。但是，最好忽略不熟悉的字符，甚至可能从未使用过的字符。</target>
        </trans-unit>
        <trans-unit id="7b61a323c52c38306eb024952539f4f8c5a7ffe3" translate="yes" xml:space="preserve">
          <source>Undefines the hash. The XS equivalent of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef(%hash)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">未定义哈希。XS等效于 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef(%hash)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e5b088250fea82ab591b0cfc87d6babcdba55fe" translate="yes" xml:space="preserve">
          <source>Undefines the hash. The XS equivalent of &lt;code&gt;undef(%hash)&lt;/code&gt;.</source>
          <target state="translated">未定义哈希。XS等效于 &lt;code&gt;undef(%hash)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21918cc87ca44856538ac74361e547848b42b7b4" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt; ), a hash (using &lt;code&gt;%&lt;/code&gt; ), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt; ), or a typeglob (using &lt;code&gt;*&lt;/code&gt; ). Saying &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;#delete&quot;&gt;delete&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="translated">未定义EXPR的值，该值必须为左值。仅用于标量值，数组（使用 &lt;code&gt;@&lt;/code&gt; ），哈希（使用 &lt;code&gt;%&lt;/code&gt; ），子例程（使用 &lt;code&gt;&amp;amp;&lt;/code&gt; ）或typeglob（使用 &lt;code&gt;*&lt;/code&gt; ）。在大多数预定义变量或DBM列表值上说 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; 可能不会达到您的期望，所以不要那样做。请参阅&lt;a href=&quot;#delete&quot;&gt;删除&lt;/a&gt;。始终返回未定义的值。您可以省略EXPR，在这种情况下，所有内容均未定义，但仍会得到一个未定义的值，例如，可以从子例程返回，分配给变量或作为参数传递。例子：</target>
        </trans-unit>
        <trans-unit id="12772c94a5d6a3598c32da79f4c1c4affc5b608e" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt; ), a hash (using &lt;code&gt;%&lt;/code&gt; ), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt; ), or a typeglob (using &lt;code&gt;*&lt;/code&gt; ). Saying &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="translated">未定义EXPR的值，该值必须为左值。仅用于标量值，数组（使用 &lt;code&gt;@&lt;/code&gt; ），哈希（使用 &lt;code&gt;%&lt;/code&gt; ），子例程（使用 &lt;code&gt;&amp;amp;&lt;/code&gt; ）或typeglob（使用 &lt;code&gt;*&lt;/code&gt; ）。在大多数预定义变量或DBM列表值上说 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; 可能不会达到您的期望，所以不要那样做。请参阅&lt;a href=&quot;delete&quot;&gt;删除&lt;/a&gt;。始终返回未定义的值。您可以省略EXPR，在这种情况下，所有内容均未定义，但仍会得到一个未定义的值，例如，可以从子例程返回，分配给变量或作为参数传递。例子：</target>
        </trans-unit>
        <trans-unit id="638220651f84b9cd00c5941897d28ba69d79dc1a" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt;), a hash (using &lt;code&gt;%&lt;/code&gt;), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt;), or a typeglob (using &lt;code&gt;*&lt;/code&gt;). Saying &lt;code&gt;undef $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;#delete-EXPR&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="translated">未定义EXPR的值，该值必须为左值。仅在标量值，数组（使用 &lt;code&gt;@&lt;/code&gt; ），哈希（使用 &lt;code&gt;%&lt;/code&gt; ），子例程（使用 &lt;code&gt;&amp;amp;&lt;/code&gt; ）或typeglob（使用 &lt;code&gt;*&lt;/code&gt; ）上使用。在大多数预定义变量或DBM列表值上说 &lt;code&gt;undef $hash{$key}&lt;/code&gt; 可能不会达到您的期望，所以不要那样做。请参阅&lt;a href=&quot;#delete-EXPR&quot;&gt; &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt;。始终返回未定义的值。您可以省略EXPR，在这种情况下，什么都没有定义，但是您仍然会得到一个不确定的值，例如，可以从子例程返回，分配给变量或作为参数传递。例子：</target>
        </trans-unit>
        <trans-unit id="8b42ea56822642513e4f112de38357bed9dd6a64" translate="yes" xml:space="preserve">
          <source>Undefining this symbol disables the PerlIO abstraction. PerlIO is now the default; it is not recommended to disable PerlIO.</source>
          <target state="translated">取消定义这个符号可以禁用PerlIO抽象。PerlIO现在是默认的,不建议禁用PerlIO。</target>
        </trans-unit>
        <trans-unit id="14931b1ffe46d4f806d87924392ea8d8ba051a3f" translate="yes" xml:space="preserve">
          <source>Undefining this symbol forces Perl to be compiled statically.</source>
          <target state="translated">不定义这个符号会强制Perl进行静态编译。</target>
        </trans-unit>
        <trans-unit id="55d31ccf7c7a9061158740ae0e4ba2a4be4c51d6" translate="yes" xml:space="preserve">
          <source>Under &quot;Classic&quot; MacOS, a perl program will have the appropriate Creator and Type, so that double-clicking them will invoke the MacPerl application. Under Mac OS X, clickable apps can be made from any &lt;code&gt;#!&lt;/code&gt; script using Wil Sanchez' DropScript utility: &lt;a href=&quot;http://www.wsanchez.net/software/&quot;&gt;http://www.wsanchez.net/software/&lt;/a&gt; .</source>
          <target state="translated">在&amp;ldquo;经典&amp;rdquo; MacOS下，perl程序将具有适当的创建者和类型，因此双击它们将调用MacPerl应用程序。在Mac OS X下，可通过任何 &lt;code&gt;#!&lt;/code&gt; 来创建可点击的应用程序！使用Wil Sanchez的DropScript实用程序编写脚本：&lt;a href=&quot;http://www.wsanchez.net/software/&quot;&gt;http&lt;/a&gt; ://www.wsanchez.net/software/ 。</target>
        </trans-unit>
        <trans-unit id="7de147ca0cf42a020c2b34e4934080e8fbf00bba" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt;, test number 2 would</source>
          <target state="translated">在&lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness下&lt;/a&gt;，测试编号2将</target>
        </trans-unit>
        <trans-unit id="830e70bc7050b5ad58debeaf947b37217d6be21e" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt;, test number 2 would</source>
          <target state="translated">在&lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness下&lt;/a&gt;，测试编号2将</target>
        </trans-unit>
        <trans-unit id="50510298fcc80cb0b2cfe5fcb98eb1382cb9d484" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , detection step of discontiguous contractions will be skipped.</source>
          <target state="translated">在 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; ，不连续收缩的检测步骤将被跳过。</target>
        </trans-unit>
        <trans-unit id="6a769e92dc491fba4fdaa440dbac9751e38e85b4" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt;, detection step of discontiguous contractions will be skipped.</source>
          <target state="translated">在 &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt; ，不连续收缩的检测步骤将被跳过。</target>
        </trans-unit>
        <trans-unit id="da1bc7be7a27894ec56a14e00f77fdf88c07658e" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;array_base&quot;&lt;/code&gt; , &lt;code&gt;$[&lt;/code&gt; no longer has any effect, and always contains 0. Assigning 0 to it is permitted, but any other value will produce an error.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; ，或者 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;array_base&quot;&lt;/code&gt; ， &lt;code&gt;$[&lt;/code&gt; 不再具有任何作用，并且始终包含0。允许为其分配0，但是任何其他值都会产生错误。</target>
        </trans-unit>
        <trans-unit id="bacf555aace53131b41a0f7ef63c9e3e7d03589b" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;unicode_strings&lt;/code&gt; starting in Perl 5.12.0, Unicode rules are generally used. See &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; for details on how this works in combination with various other pragmas.</source>
          <target state="translated">在 &lt;code&gt;unicode_strings&lt;/code&gt; 在Perl 5.12.0开始，统一规则通常使用。有关与其他各种语用结合使用的详细信息，请参见&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f60303853e6438f23bfd0e7253ff8d6666354a3e" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;unicode_strings&lt;/code&gt; starting in Perl 5.12.0, Unicode rules are generally used. See &lt;a href=&quot;perlfunc#lc&quot;&gt;&quot;lc&quot; in perlfunc&lt;/a&gt; for details on how this works in combination with various other pragmas.</source>
          <target state="translated">在 &lt;code&gt;unicode_strings&lt;/code&gt; 在Perl 5.12.0开始，统一规则通常使用。有关如何与各种其他实用程序结合使用的详细信息，请参见&lt;a href=&quot;perlfunc#lc&quot;&gt;perlfunc中的&amp;ldquo; lc&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94fe5caf324bcb104f1845ec70df5cb17cd45071" translate="yes" xml:space="preserve">
          <source>Under Cygwin, $^E is the same as $!. When using &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32 API Functions&lt;/a&gt;, use &lt;code&gt;Win32::GetLastError()&lt;/code&gt; to get the last Windows error.</source>
          <target state="translated">在Cygwin下，$ ^ E与$！相同。使用&lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32 API Functions时&lt;/a&gt;，请使用 &lt;code&gt;Win32::GetLastError()&lt;/code&gt; 获取最后的Windows错误。</target>
        </trans-unit>
        <trans-unit id="bf1bd7b89a19b28d20d4df86f951acf9fc393dd7" translate="yes" xml:space="preserve">
          <source>Under Cygwin, $^E is the same as $!. When using &lt;a href=&quot;win32&quot;&gt;Win32 API Functions&lt;/a&gt;, use &lt;code&gt;Win32::GetLastError()&lt;/code&gt; to get the last Windows error.</source>
          <target state="translated">在Cygwin下，$ ^ E与$！相同。使用&lt;a href=&quot;win32&quot;&gt;Win32 API Functions时&lt;/a&gt;，请使用 &lt;code&gt;Win32::GetLastError()&lt;/code&gt; 获取最后的Windows错误。</target>
        </trans-unit>
        <trans-unit id="08490cc0df2a509f16cddc3cf2a4ae40e649767f" translate="yes" xml:space="preserve">
          <source>Under EBCDIC platforms, &lt;code&gt;e2char($n)&lt;/code&gt; may not always be the same as &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(e2charnum($n))&lt;/a&gt;&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr($Name2character_number{$name})&lt;/a&gt;&lt;/code&gt;, because the strings are returned as native, and the numbers are returned as Unicode. However, for Perls starting with v5.8, &lt;code&gt;e2char($n)&lt;/code&gt; is the same as &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/a&gt;&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在EBCDIC平台上， &lt;code&gt;e2char($n)&lt;/code&gt; 可能并不总是与 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(e2charnum($n))&lt;/a&gt;&lt;/code&gt; ，对于 &lt;code&gt;$Name2character{$name}&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr($Name2character_number{$name})&lt;/a&gt;&lt;/code&gt; ，因为返回了字符串作为本机，并且数字以Unicode返回。但是，对于以v5.8开头的Perls， &lt;code&gt;e2char($n)&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;$Name2character{$name}&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24801e56e20625b1799dc0d5ebdcc72e9b0dcde9" translate="yes" xml:space="preserve">
          <source>Under EBCDIC platforms, &lt;code&gt;e2char($n)&lt;/code&gt; may not always be the same as &lt;code&gt;chr(e2charnum($n))&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;chr($Name2character_number{$name})&lt;/code&gt;, because the strings are returned as native, and the numbers are returned as Unicode. However, for Perls starting with v5.8, &lt;code&gt;e2char($n)&lt;/code&gt; is the same as &lt;code&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/code&gt;.</source>
          <target state="translated">在EBCDIC平台上， &lt;code&gt;e2char($n)&lt;/code&gt; 可能并不总是与 &lt;code&gt;chr(e2charnum($n))&lt;/code&gt; ，对于 &lt;code&gt;$Name2character{$name}&lt;/code&gt; 和 &lt;code&gt;chr($Name2character_number{$name})&lt;/code&gt; ，ditto也可能相同，因为返回了字符串作为本机，并且数字以Unicode返回。但是，对于以v5.8开头的Perls， &lt;code&gt;e2char($n)&lt;/code&gt; 与 &lt;code&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/code&gt; 和 &lt;code&gt;$Name2character{$name}&lt;/code&gt; 和 &lt;code&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fc50122941a9cec999fb031245122855f9d5976" translate="yes" xml:space="preserve">
          <source>Under NFS this will use the time of the NFS server, not the time of the local machine. If there is a time synchronization problem, the NFS server and local machine will have different times. The Unix &lt;a href=&quot;http://man.he.net/man1/touch&quot;&gt;touch(1)&lt;/a&gt; command will in fact normally use this form instead of the one shown in the first example.</source>
          <target state="translated">在NFS下，这将使用NFS服务器的时间，而不是本地计算机的时间。如果存在时间同步问题，则NFS服务器和本地计算机的时间将不同。实际上，Unix &lt;a href=&quot;http://man.he.net/man1/touch&quot;&gt;touch（1）&lt;/a&gt;命令通常将使用这种形式，而不是第一个示例中所示的形式。</target>
        </trans-unit>
        <trans-unit id="18254acc65d18b7ddbf875f7bfc47db0d75ce39a" translate="yes" xml:space="preserve">
          <source>Under NFS this will use the time of the NFS server, not the time of the local machine. If there is a time synchronization problem, the NFS server and local machine will have different times. The Unix touch(1) command will in fact normally use this form instead of the one shown in the first example.</source>
          <target state="translated">在NFS下,这将使用NFS服务器的时间,而不是本地机器的时间。如果存在时间同步问题,NFS 服务器和本地机器的时间将不同。事实上,Unix touch(1)命令通常会使用这种形式,而不是第一个例子中所示的形式。</target>
        </trans-unit>
        <trans-unit id="f3924a4fe96e1e85710f171a0842dfde3423eb52" translate="yes" xml:space="preserve">
          <source>Under OS/2, &lt;code&gt;$^E&lt;/code&gt; is set to the error code of the last call to OS/2 API either via CRT, or directly from perl.</source>
          <target state="translated">在OS / 2下，将 &lt;code&gt;$^E&lt;/code&gt; 设置为通过CRT或直接从perl对OS / 2 API的最后一次调用的错误代码。</target>
        </trans-unit>
        <trans-unit id="19dcdc34494760727e410f497dbed91a176d6c5e" translate="yes" xml:space="preserve">
          <source>Under Perl 5.10 only, using a string eval when &lt;code&gt;autodie&lt;/code&gt; is in effect can cause the autodie behaviour to leak into the surrounding scope. This can be worked around by using a &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; at the end of the scope to explicitly remove autodie's effects, or by avoiding the use of string eval.</source>
          <target state="translated">仅在Perl 5.10下，当自动 &lt;code&gt;autodie&lt;/code&gt; 有效时使用字符串eval 可能会导致autodie行为泄漏到周围的范围中。可以通过在范围末尾使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; 来显式删除autodie的效果，或避免使用字符串eval来解决此问题。</target>
        </trans-unit>
        <trans-unit id="141394caeda9c5ad5a22f24134bab7c210cd57fb" translate="yes" xml:space="preserve">
          <source>Under Perl 5.10 only, using a string eval when &lt;code&gt;autodie&lt;/code&gt; is in effect can cause the autodie behaviour to leak into the surrounding scope. This can be worked around by using a &lt;code&gt;no autodie&lt;/code&gt; at the end of the scope to explicitly remove autodie's effects, or by avoiding the use of string eval.</source>
          <target state="translated">仅在Perl 5.10下，当自动 &lt;code&gt;autodie&lt;/code&gt; 有效时使用字符串eval可能会导致autodie行为泄漏到周围的作用域中。可以通过在范围末尾使用 &lt;code&gt;no autodie&lt;/code&gt; 来显式删除autodie的效果，或者避免使用字符串eval来解决此问题。</target>
        </trans-unit>
        <trans-unit id="1824d549ede70b3449b6bc94fa47857184a96f9f" translate="yes" xml:space="preserve">
          <source>Under Perl 5.18 and later, SvREADONLY only applies to read-only variables, and, under 5.20, copy-on-write scalars can also be read-only, so the above check is incorrect. You just want:</source>
          <target state="translated">在Perl 5.18及以后的版本中,SvREADONLY只适用于只读变量,而在5.20下,写后复制的标量也可以是只读的,所以上面的检查是不正确的。你只是想。</target>
        </trans-unit>
        <trans-unit id="8d107d150b9abd6d04d1d29a993fa6ea829d9209" translate="yes" xml:space="preserve">
          <source>Under Perl 5.8 only, &lt;code&gt;autodie&lt;/code&gt;</source>
          <target state="translated">仅在Perl 5.8下， &lt;code&gt;autodie&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e28f5c058f0915564622ac46660d6f84c05ab318" translate="yes" xml:space="preserve">
          <source>Under Perl 5.8, the &lt;code&gt;given/when&lt;/code&gt; structure is not available, so the following structure may be used:</source>
          <target state="translated">在Perl 5.8中， &lt;code&gt;given/when&lt;/code&gt; 结构不可用，因此可以使用以下结构：</target>
        </trans-unit>
        <trans-unit id="ef993909ab6a97a91baf7e650bc7ce46f77c2516" translate="yes" xml:space="preserve">
          <source>Under QNX 6.2.0 there are still a few tests which fail. See below and hints/qnx.sh for more information.</source>
          <target state="translated">在 QNX 6.2.0 下,仍有一些测试失败。请参见下文和提示/qnx.sh 了解更多信息。</target>
        </trans-unit>
        <trans-unit id="66b5ec5cf7fb5924aee8dffa63eba13ccd60d52e" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, there are a few case-insensitive matches that cross the 255/256 boundary. Except for UTF-8 locales in Perls v5.20 and later, these are disallowed under &lt;code&gt;/l&lt;/code&gt; . For example, 0xFF (on ASCII platforms) does not caselessly match the character at 0x178, &lt;code&gt;LATIN
CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt; , because 0xFF may not be &lt;code&gt;LATIN SMALL
LETTER Y WITH DIAERESIS&lt;/code&gt; in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is.</source>
          <target state="translated">根据Unicode规则，有一些不区分大小写的匹配跨越255/256边界。除了Perls v5.20及更高版本中的UTF-8语言环境外， &lt;code&gt;/l&lt;/code&gt; 下不允许使用这些语言环境。例如，0xFF（在ASCII平台上）不能不区分大小写地匹配0x178的字符， &lt;code&gt;LATIN CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt; ，因为在当前语言环境中0xFF可能不是 &lt;code&gt;LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; ，而Perl无法知道是否字符甚至存在于语言环境中，更不用说代码点了。</target>
        </trans-unit>
        <trans-unit id="a229f317f16db87320c5e41b43cc77785168f869" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, there are a few case-insensitive matches that cross the 255/256 boundary. Except for UTF-8 locales in Perls v5.20 and later, these are disallowed under &lt;code&gt;/l&lt;/code&gt;. For example, 0xFF (on ASCII platforms) does not caselessly match the character at 0x178, &lt;code&gt;LATIN CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt;, because 0xFF may not be &lt;code&gt;LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is.</source>
          <target state="translated">根据Unicode规则，有一些不区分大小写的匹配跨越255/256边界。除了Perls v5.20及更高版本中的UTF-8语言环境外， &lt;code&gt;/l&lt;/code&gt; 下不允许使用这些语言环境。例如，0xFF（在ASCII平台上）不能不区分大小写地匹配0x178的字符， &lt;code&gt;LATIN CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt; ，因为在当前语言环境中0xFF可能不是 &lt;code&gt;LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; ，Perl无法知道是否字符甚至存在于语言环境中，更不用说它是什么代码点了。</target>
        </trans-unit>
        <trans-unit id="666da3b151d79c3526ad94c74b4a7b5272bc4ad7" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, these upper-Latin1 characters are interpreted as Unicode code points, which means they have the same semantics as Latin-1 (ISO-8859-1) and C1 controls.</source>
          <target state="translated">根据Unicode规则,这些上拉丁1字符被解释为Unicode码点,这意味着它们与Latin-1(ISO-8859-1)和C1控制具有相同的语义。</target>
        </trans-unit>
        <trans-unit id="15d191765263aacd2b7fcad31e78fb6cf886a85b" translate="yes" xml:space="preserve">
          <source>Under VMS this reflects the actual VMS exit status; i.e. it is the same as &lt;code&gt;$?&lt;/code&gt; when the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; is in effect.</source>
          <target state="translated">在VMS下，这反映了VMS的实际退出状态；即与 &lt;code&gt;$?&lt;/code&gt; 相同吗？当编译指示 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 时，使用 vmsish'status'。</target>
        </trans-unit>
        <trans-unit id="c6482226ed3d921882dbfe662280c6e28493cbae" translate="yes" xml:space="preserve">
          <source>Under VMS this reflects the actual VMS exit status; i.e. it is the same as &lt;code&gt;$?&lt;/code&gt; when the pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; is in effect.</source>
          <target state="translated">在VMS下，这反映了VMS的实际退出状态；即与 &lt;code&gt;$?&lt;/code&gt; 相同吗？当编译指示 &lt;code&gt;use vmsish 'status'&lt;/code&gt; 时，使用vmsish'status'。</target>
        </trans-unit>
        <trans-unit id="737324e93129014d33d4923a010ebe747aa167f7" translate="yes" xml:space="preserve">
          <source>Under VMS, &lt;code&gt;$^E&lt;/code&gt; provides the VMS status value from the last system error. This is more specific information about the last system error than that provided by &lt;code&gt;$!&lt;/code&gt; . This is particularly important when &lt;code&gt;$!&lt;/code&gt; is set to &lt;b&gt;EVMSERR&lt;/b&gt;.</source>
          <target state="translated">在VMS下， &lt;code&gt;$^E&lt;/code&gt; 提供上一次系统错误后的VMS状态值。与 &lt;code&gt;$!&lt;/code&gt; 提供的信息相比，这是有关上一个系统错误的更具体的信息。。这在 &lt;code&gt;$!&lt;/code&gt; 时尤其重要！设置为&lt;b&gt;EVMSERR&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="76dfcc4ab4ed83661a267ed44726342ca382d02d" translate="yes" xml:space="preserve">
          <source>Under VMS, &lt;code&gt;$^E&lt;/code&gt; provides the VMS status value from the last system error. This is more specific information about the last system error than that provided by &lt;code&gt;$!&lt;/code&gt;. This is particularly important when &lt;code&gt;$!&lt;/code&gt; is set to &lt;b&gt;EVMSERR&lt;/b&gt;.</source>
          <target state="translated">在VMS下， &lt;code&gt;$^E&lt;/code&gt; 提供上一次系统错误后的VMS状态值。与 &lt;code&gt;$!&lt;/code&gt; 提供的信息相比，这是有关上一个系统错误的更具体的信息。。这在 &lt;code&gt;$!&lt;/code&gt; 时尤为重要。设置为&lt;b&gt;EVMSERR&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="50b3f98ca540bd0c81d34840956f838255c71318" translate="yes" xml:space="preserve">
          <source>Under VMS, if there is no directory information in the $path, then the current default device and directory is used.</source>
          <target state="translated">在VMS下,如果$path中没有目录信息,则使用当前默认的设备和目录。</target>
        </trans-unit>
        <trans-unit id="3aaae4cddb5ecef27b2c450c8cc4b4b174c7016f" translate="yes" xml:space="preserve">
          <source>Under VMS, the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status, instead of the default emulation of POSIX status; see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt; for details.</source>
          <target state="translated">在VMS下， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 的编译指示使 &lt;code&gt;$?&lt;/code&gt; 反映实际的VMS退出状态，而不是POSIX状态的默认模拟；看到&lt;a href=&quot;perlvms#%24%3f&quot;&gt;$？在perlvms中&lt;/a&gt;获取详细信息。</target>
        </trans-unit>
        <trans-unit id="9fe540ff184660416cab5f62ce2d7a86b31b31b4" translate="yes" xml:space="preserve">
          <source>Under VMS, the pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status, instead of the default emulation of POSIX status; see &lt;a href=&quot;perlvms#%24%3F&quot;&gt;&quot;$?&quot; in perlvms&lt;/a&gt; for details.</source>
          <target state="translated">在VMS下， &lt;code&gt;use vmsish 'status'&lt;/code&gt; 可以使 &lt;code&gt;$?&lt;/code&gt; 反映实际的VMS退出状态，而不是POSIX状态的默认模拟；看到&lt;a href=&quot;perlvms#%24%3F&quot;&gt;&amp;ldquo; $？&amp;rdquo; 在perlvms中&lt;/a&gt;获取详细信息。</target>
        </trans-unit>
        <trans-unit id="711e7c0754f84b5e7bda634825aa4039a4a70c54" translate="yes" xml:space="preserve">
          <source>Under Win32's &quot;test&quot; target you may use the TEST_SWITCHES and TEST_FILES environment variables to control the behaviour of</source>
          <target state="translated">在Win32的 &quot;test &quot;目标下,你可以使用TEST_SWITCHES和TEST_FILES环境变量来控制下面的行为</target>
        </trans-unit>
        <trans-unit id="53c6d0758bf54648c779157ed9111dd650df9efe" translate="yes" xml:space="preserve">
          <source>Under Win32, &lt;code&gt;$^E&lt;/code&gt; always returns the last error information reported by the Win32 call &lt;code&gt;GetLastError()&lt;/code&gt; which describes the last error from within the Win32 API. Most Win32-specific code will report errors via &lt;code&gt;$^E&lt;/code&gt; . ANSI C and Unix-like calls set &lt;code&gt;errno&lt;/code&gt; and so most portable Perl code will report errors via &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">在Win32下， &lt;code&gt;$^E&lt;/code&gt; 总是返回Win32调用 &lt;code&gt;GetLastError()&lt;/code&gt; 报告的最后错误信息，该信息描述了Win32 API中的最后一个错误。大多数特定于Win32的代码将通过 &lt;code&gt;$^E&lt;/code&gt; 报告错误。ANSI C和类Unix调用设置 &lt;code&gt;errno&lt;/code&gt; ，因此大多数可移植的Perl代码将通过 &lt;code&gt;$!&lt;/code&gt; 报告错误！。</target>
        </trans-unit>
        <trans-unit id="9e14095c735f4241ba86445b598120697973ed27" translate="yes" xml:space="preserve">
          <source>Under Win32, &lt;code&gt;$^E&lt;/code&gt; always returns the last error information reported by the Win32 call &lt;code&gt;GetLastError()&lt;/code&gt; which describes the last error from within the Win32 API. Most Win32-specific code will report errors via &lt;code&gt;$^E&lt;/code&gt;. ANSI C and Unix-like calls set &lt;code&gt;errno&lt;/code&gt; and so most portable Perl code will report errors via &lt;code&gt;$!&lt;/code&gt;.</source>
          <target state="translated">在Win32下， &lt;code&gt;$^E&lt;/code&gt; 总是返回Win32调用 &lt;code&gt;GetLastError()&lt;/code&gt; 报告的最后错误信息，该信息描述了Win32 API中的最后一个错误。大多数特定于Win32的代码将通过 &lt;code&gt;$^E&lt;/code&gt; 报告错误。ANSI C和类Unix调用设置 &lt;code&gt;errno&lt;/code&gt; ，因此大多数可移植的Perl代码将通过 &lt;code&gt;$!&lt;/code&gt; 报告错误！。</target>
        </trans-unit>
        <trans-unit id="9f5b168779b6e4455afcf5fa22f2ddb16d807c4c" translate="yes" xml:space="preserve">
          <source>Under Windows NT, &lt;code&gt;$sPath&lt;/code&gt; can start with &lt;code&gt;&quot;//?/&quot;&lt;/code&gt; to allow the use of paths longer than &lt;code&gt;MAX_PATH&lt;/code&gt; [for UNC paths, replace the leading &lt;code&gt;&quot;//&quot;&lt;/code&gt; with &lt;code&gt;&quot;//?/UNC/&quot;&lt;/code&gt;, as in &lt;code&gt;&quot;//?/UNC/Server/Share/Dir/File.Ext&quot;&lt;/code&gt;].</source>
          <target state="translated">在Windows NT &lt;code&gt;$sPath&lt;/code&gt; 可以启动 &lt;code&gt;&quot;//?/&quot;&lt;/code&gt; 允许使用的路径长于 &lt;code&gt;MAX_PATH&lt;/code&gt; [对于UNC路径，更换领导 &lt;code&gt;&quot;//&quot;&lt;/code&gt; 与 &lt;code&gt;&quot;//?/UNC/&quot;&lt;/code&gt; ，如 &lt;code&gt;&quot;//?/UNC/Server/Share/Dir/File.Ext&quot;&lt;/code&gt; ]。</target>
        </trans-unit>
        <trans-unit id="445377f279bee790252626a9efe4c710c5fb31ec" translate="yes" xml:space="preserve">
          <source>Under Windows and VMS the option file is named</source>
          <target state="translated">在Windows和VMS下,选项文件名为</target>
        </trans-unit>
        <trans-unit id="991af3b0df6455b17cae9de8484aa49771ee9333" translate="yes" xml:space="preserve">
          <source>Under a few operating systems, &lt;code&gt;$^E&lt;/code&gt; may contain a more verbose error indicator, such as in this case, &quot;CDROM tray not closed.&quot; Systems that do not support extended error messages leave &lt;code&gt;$^E&lt;/code&gt; the same as &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">在某些操作系统下， &lt;code&gt;$^E&lt;/code&gt; 可能包含更详细的错误指示符，例如在这种情况下，&amp;ldquo; CDROM托盘未关闭&amp;rdquo;。不支持扩展错误消息的系统将 &lt;code&gt;$^E&lt;/code&gt; 与 &lt;code&gt;$!&lt;/code&gt; 相同。。</target>
        </trans-unit>
        <trans-unit id="9cba04bbbcd7e6b0b58cb405fffa7701c6b86b43" translate="yes" xml:space="preserve">
          <source>Under a few operating systems, &lt;code&gt;$^E&lt;/code&gt; may contain a more verbose error indicator, such as in this case, &quot;CDROM tray not closed.&quot; Systems that do not support extended error messages leave &lt;code&gt;$^E&lt;/code&gt; the same as &lt;code&gt;$!&lt;/code&gt;.</source>
          <target state="translated">在某些操作系统下， &lt;code&gt;$^E&lt;/code&gt; 可能包含更详细的错误指示符，例如在这种情况下，&amp;ldquo; CDROM托盘未关闭&amp;rdquo;。不支持扩展错误消息的系统将 &lt;code&gt;$^E&lt;/code&gt; 与 &lt;code&gt;$!&lt;/code&gt; 保留相同！。</target>
        </trans-unit>
        <trans-unit id="b8188d9bfb2c028e78df0c34f466ab12923ca95e" translate="yes" xml:space="preserve">
          <source>Under bignum (or bigint or bigrat), Perl will &quot;upgrade&quot; the numbers appropriately. This means that:</source>
          <target state="translated">在bignum(或bigint或bigrat)下,Perl会适当地 &quot;升级 &quot;数字。这意味着</target>
        </trans-unit>
        <trans-unit id="936167913e1d36052a60fe747af5e2acfb71f327" translate="yes" xml:space="preserve">
          <source>Under case-sensitive matching, these both match the same code points as &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; (&lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; ). The difference is that under &lt;code&gt;/i&lt;/code&gt; caseless matching, these match the same as &lt;code&gt;\p{Cased}&lt;/code&gt; , whereas &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; matches &lt;code&gt;\p{Cased_Letter&lt;/code&gt; ).</source>
          <target state="translated">在区分大小写的匹配下，它们都与 &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; （ &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; ）相同的代码点匹配。区别在于，在 &lt;code&gt;/i&lt;/code&gt; 不区分大小写的匹配下，这些匹配与 &lt;code&gt;\p{Cased}&lt;/code&gt; ，而 &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; 匹配 &lt;code&gt;\p{Cased_Letter&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="16d7375a7fe76f99800381f8b36c3f7a2c76e668" translate="yes" xml:space="preserve">
          <source>Under case-sensitive matching, these both match the same code points as &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; (&lt;code&gt;\p{gc=lt}&lt;/code&gt;). The difference is that under &lt;code&gt;/i&lt;/code&gt; caseless matching, these match the same as &lt;code&gt;\p{Cased}&lt;/code&gt;, whereas &lt;code&gt;\p{gc=lt}&lt;/code&gt; matches &lt;code&gt;\p{Cased_Letter&lt;/code&gt;).</source>
          <target state="translated">在区分大小写的匹配下，它们都与 &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; （ &lt;code&gt;\p{gc=lt}&lt;/code&gt; ）匹配相同的代码点。区别在于，在 &lt;code&gt;/i&lt;/code&gt; 不区分大小写的匹配下，这些匹配与 &lt;code&gt;\p{Cased}&lt;/code&gt; ，而 &lt;code&gt;\p{gc=lt}&lt;/code&gt; 匹配 &lt;code&gt;\p{Cased_Letter&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="58098e551f5eebaa46d0d3a19d00f14ced3f4d46" translate="yes" xml:space="preserve">
          <source>Under ithreads the optree is read only. If you want to enforce this, to check for write accesses from buggy code, compile with &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; to enable code that allocates op memory via &lt;code&gt;mmap&lt;/code&gt; , and sets it read-only when it is attached to a subroutine. Any write access to an op results in a &lt;code&gt;SIGBUS&lt;/code&gt; and abort.</source>
          <target state="translated">在ithreads下，optree是只读的。如果要强制执行此操作，要检查来自错误代码的写访问，请使用 &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; 进行编译，以启用通过 &lt;code&gt;mmap&lt;/code&gt; 分配操作内存的代码，并在将其附加到子例程时将其设置为只读。对op的任何写访问都会导致 &lt;code&gt;SIGBUS&lt;/code&gt; 并中止。</target>
        </trans-unit>
        <trans-unit id="21eb1ae9bcc07ffd150bd4cea8dca0ae9a233a36" translate="yes" xml:space="preserve">
          <source>Under ithreads the optree is read only. If you want to enforce this, to check for write accesses from buggy code, compile with &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; to enable code that allocates op memory via &lt;code&gt;mmap&lt;/code&gt;, and sets it read-only when it is attached to a subroutine. Any write access to an op results in a &lt;code&gt;SIGBUS&lt;/code&gt; and abort.</source>
          <target state="translated">在ithreads下，optree是只读的。如果要强制执行此操作，要检查来自错误代码的写访问，请使用 &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; 进行编译，以启用通过 &lt;code&gt;mmap&lt;/code&gt; 分配操作内存的代码，并在将其附加到子例程时将其设置为只读。对op的任何写访问都会导致 &lt;code&gt;SIGBUS&lt;/code&gt; 并中止。</target>
        </trans-unit>
        <trans-unit id="9d556cba6d79170127d0f04c67e73cd273a0ab83" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the CV forgets about its slab (decrementing the reference count) when the root is attached. So the slab reference counting that happens when ops are freed takes care of freeing the slab. In some cases, the CV is told to forget about the slab (&lt;code&gt;cv_forget_slab&lt;/code&gt;) precisely so that the ops can survive after the CV is done away with.</source>
          <target state="translated">在正常情况下，附加根后，CV会忘记其平板（减少参考计数）。因此，释放操作时发生的参考引用计数将确保释放参考。在某些情况下，CV被告知要完全忘记平板（ &lt;code&gt;cv_forget_slab&lt;/code&gt; ），以便在取消CV之后可以继续使用操作。</target>
        </trans-unit>
        <trans-unit id="41c5c0dce73b6a45e16e6c80203f13488d40f1dd" translate="yes" xml:space="preserve">
          <source>Under the &quot;switch&quot; feature, Perl gains the experimental keywords &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt; . Starting from Perl 5.16, one can prefix the switch keywords with &lt;code&gt;CORE::&lt;/code&gt; to access the feature without a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; statement. The keywords &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; are analogous to &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; in other languages, so the code in the previous section could be rewritten as</source>
          <target state="translated">在&amp;ldquo;开关&amp;rdquo;功能，Perl中获得了实验用的关键字 &lt;code&gt;given&lt;/code&gt; ， &lt;code&gt;when&lt;/code&gt; ， &lt;code&gt;default&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;break&lt;/code&gt; 。从Perl 5.16开始，可以在switch关键字前添加 &lt;code&gt;CORE::&lt;/code&gt; 前缀，以在不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; 语句的情况下访问该功能。 &lt;code&gt;given&lt;/code&gt; 的关键字和 &lt;code&gt;when&lt;/code&gt; 类似于其他语言中的 &lt;code&gt;switch&lt;/code&gt; 和 &lt;code&gt;case&lt;/code&gt; ，因此上一节中的代码可以重写为</target>
        </trans-unit>
        <trans-unit id="429aec7265e307e4dfd4174d6cfde74d06bbb3ef" translate="yes" xml:space="preserve">
          <source>Under the &quot;switch&quot; feature, Perl gains the experimental keywords &lt;code&gt;given&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt;. Starting from Perl 5.16, one can prefix the switch keywords with &lt;code&gt;CORE::&lt;/code&gt; to access the feature without a &lt;code&gt;use feature&lt;/code&gt; statement. The keywords &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; are analogous to &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; in other languages -- though &lt;code&gt;continue&lt;/code&gt; is not -- so the code in the previous section could be rewritten as</source>
          <target state="translated">在&amp;ldquo;开关&amp;rdquo;功能，Perl中获得了实验用的关键字 &lt;code&gt;given&lt;/code&gt; ， &lt;code&gt;when&lt;/code&gt; ， &lt;code&gt;default&lt;/code&gt; ， &lt;code&gt;continue&lt;/code&gt; 和 &lt;code&gt;break&lt;/code&gt; 。从Perl 5.16开始，可以在switch关键字前添加 &lt;code&gt;CORE::&lt;/code&gt; 前缀，以在不 &lt;code&gt;use feature&lt;/code&gt; 语句的情况下访问该功能。 &lt;code&gt;given&lt;/code&gt; 的关键字和 &lt;code&gt;when&lt;/code&gt; 类似于其他语言中的 &lt;code&gt;switch&lt;/code&gt; 和 &lt;code&gt;case&lt;/code&gt; ，尽管 &lt;code&gt;continue&lt;/code&gt; 不是，所以上一节中的代码可以重写为</target>
        </trans-unit>
        <trans-unit id="f764edcb644a2a893a6fefa3a757e31fb881f9a7" translate="yes" xml:space="preserve">
          <source>Under the &lt;a href=&quot;feature#The-%27unicode_eval%27-and-%27evalbytes%27-features&quot;&gt;&lt;code&gt;&quot;unicode_eval&quot;&lt;/code&gt; feature&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;feature#The-%27unicode_eval%27-and-%27evalbytes%27-features&quot;&gt; &lt;code&gt;&quot;unicode_eval&quot;&lt;/code&gt; 功能下&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3dcedc6c33e9a6ba46a7f82a03dd4b7c259f61b3" translate="yes" xml:space="preserve">
          <source>Under the &lt;code&gt;unicode_eval&lt;/code&gt; feature, Perl's &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; function, when passed a string, will evaluate it as a string of characters, ignoring any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declarations. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; exists to declare the encoding of the script, which only makes sense for a stream of bytes, not a string of characters. Source filters are forbidden, as they also really only make sense on strings of bytes. Any attempt to activate a source filter will result in an error.</source>
          <target state="translated">在 &lt;code&gt;unicode_eval&lt;/code&gt; 功能下，Perl的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 函数在传递字符串时会将其评估为字符串，而不会 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 声明。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 可以声明脚本的编码，该脚本仅对字节流有意义，而对字符串不起作用。禁止使用源过滤器，因为它们实际上仅对字节字符串有意义。任何尝试激活源过滤器的操作都会导致错误。</target>
        </trans-unit>
        <trans-unit id="3ed7e8de69faa9a39e5b719579b31e326e5e1ba3" translate="yes" xml:space="preserve">
          <source>Under the Mac, it depends which environment you are using. The MacPerl shell, or MPW, is much like Unix shells in its support for several quoting variants, except that it makes free use of the Mac's non-ASCII characters as control characters.</source>
          <target state="translated">在Mac下,要看你使用的是什么环境。MacPerl shell,也就是MPW,和Unix shell很像,它支持几种引号变体,只是它可以自由使用Mac的非ASCII字符作为控制字符。</target>
        </trans-unit>
        <trans-unit id="57a69bed4d30aeb2c23df15a4942d2f1bc4e9a99" translate="yes" xml:space="preserve">
          <source>Under the current implementation, the &lt;code&gt;foreach&lt;/code&gt; loop can be anywhere within the &lt;code&gt;when&lt;/code&gt; modifier's dynamic scope, but must be within the &lt;code&gt;given&lt;/code&gt; block's lexical scope. This restricted may be relaxed in a future release. See &lt;a href=&quot;#Switch-Statements&quot;&gt;Switch Statements&lt;/a&gt; below.</source>
          <target state="translated">在当前实现下， &lt;code&gt;foreach&lt;/code&gt; 循环可以在 &lt;code&gt;when&lt;/code&gt; 修饰符的动态范围内的任何位置，但必须在 &lt;code&gt;given&lt;/code&gt; 块的词法范围内。在将来的版本中，可以放宽此限制。请参阅下面的&lt;a href=&quot;#Switch-Statements&quot;&gt;切换语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2c16149ecdeeb74ed5502e1f6dbfb7232f42a07" translate="yes" xml:space="preserve">
          <source>Under the current implementation, the &lt;code&gt;foreach&lt;/code&gt; loop can be anywhere within the &lt;code&gt;when&lt;/code&gt; modifier's dynamic scope, but must be within the &lt;code&gt;given&lt;/code&gt; block's lexical scope. This restriction may be relaxed in a future release. See &lt;a href=&quot;#Switch-Statements&quot;&gt;&quot;Switch Statements&quot;&lt;/a&gt; below.</source>
          <target state="translated">在当前实现下， &lt;code&gt;foreach&lt;/code&gt; 循环可以位于 &lt;code&gt;when&lt;/code&gt; 修饰符的动态范围内的任何位置，但必须位于 &lt;code&gt;given&lt;/code&gt; 块的词法范围内。在将来的版本中，可能会放宽此限制。请参阅下面的&lt;a href=&quot;#Switch-Statements&quot;&gt;&amp;ldquo;切换语句&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e08f959b6899ef90dffb2ee9e0e0a8572c0a7c28" translate="yes" xml:space="preserve">
          <source>Under the hood, Perl filehandles are instances of the &lt;code&gt;IO::Handle&lt;/code&gt; or &lt;code&gt;IO::File&lt;/code&gt; class. Once you have an open filehandle, you can call methods on it. Additionally, you can call methods on the &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , and &lt;code&gt;STDERR&lt;/code&gt; filehandles.</source>
          <target state="translated">在幕后，Perl文件句柄是 &lt;code&gt;IO::Handle&lt;/code&gt; 或 &lt;code&gt;IO::File&lt;/code&gt; 类的实例。拥有打开的文件句柄后，可以在其上调用方法。此外，您可以在 &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; 和 &lt;code&gt;STDERR&lt;/code&gt; 文件句柄上调用方法。</target>
        </trans-unit>
        <trans-unit id="39f4d0de021895e742d4650602144370ddd79e3a" translate="yes" xml:space="preserve">
          <source>Under the hood, Perl filehandles are instances of the &lt;code&gt;IO::Handle&lt;/code&gt; or &lt;code&gt;IO::File&lt;/code&gt; class. Once you have an open filehandle, you can call methods on it. Additionally, you can call methods on the &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt;, and &lt;code&gt;STDERR&lt;/code&gt; filehandles.</source>
          <target state="translated">在底层，Perl文件句柄是 &lt;code&gt;IO::Handle&lt;/code&gt; 或 &lt;code&gt;IO::File&lt;/code&gt; 类的实例。拥有打开的文件句柄后，可以在其上调用方法。此外，您可以在 &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; 和 &lt;code&gt;STDERR&lt;/code&gt; 文件句柄上调用方法。</target>
        </trans-unit>
        <trans-unit id="16abd29e91ee37c03769fcf588081b10ade9062f" translate="yes" xml:space="preserve">
          <source>Under the same license as Perl itself</source>
          <target state="translated">与Perl本身使用相同的许可证</target>
        </trans-unit>
        <trans-unit id="27e7e970c4cb85f5a1a451cbbaa7bb6fdbefed11" translate="yes" xml:space="preserve">
          <source>Underlying implementation for the &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; Perl function. Note that the perl-level function is vaguely deprecated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; Perl功能的基础实现。请注意，不建议使用perl级功能。</target>
        </trans-unit>
        <trans-unit id="7f6fc2f81f4959a48ec9de583348cb6833131799" translate="yes" xml:space="preserve">
          <source>Underlying implementation for the &lt;code&gt;reset&lt;/code&gt; Perl function. Note that the perl-level function is vaguely deprecated.</source>
          <target state="translated">&lt;code&gt;reset&lt;/code&gt; Perl功能的基础实现。请注意，不建议使用perl级功能。</target>
        </trans-unit>
        <trans-unit id="3d53a031b5fe95ac3434bee7e57607b8155a1a48" translate="yes" xml:space="preserve">
          <source>Understand References Today</source>
          <target state="translated">了解今天的参考资料</target>
        </trans-unit>
        <trans-unit id="d2b515bbbe667df83c6f17f27b425a07b052435e" translate="yes" xml:space="preserve">
          <source>Understand that this removes the case-insensitivity feature of this module.</source>
          <target state="translated">理解这将删除该模块的大小写不敏感功能。</target>
        </trans-unit>
        <trans-unit id="5dff374e163235318e5ce8f7742ec1049ed8b995" translate="yes" xml:space="preserve">
          <source>Understanding the Magic of Tied Hashes and Arrays</source>
          <target state="translated">理解绑定哈希值和数组的神奇之处</target>
        </trans-unit>
        <trans-unit id="4fad51d89f7e0dadc266115be3afc11b52bc9806" translate="yes" xml:space="preserve">
          <source>Undertake to build a new set of Perl images using VMS commands. Since VMS does dynamic loading, it's not necessary to statically link each extension into the Perl image, so this isn't the normal build path. Consequently, it hasn't really been tested, and may well be incomplete.</source>
          <target state="translated">承担使用VMS命令构建一套新的Perl镜像。由于 VMS 是动态加载的,所以没有必要将每个扩展都静态地链接到 Perl 映像中,所以这不是正常的构建路径。因此,它还没有经过真正的测试,很可能是不完整的。</target>
        </trans-unit>
        <trans-unit id="6b54be85a5a464cb36e53bbd5948681e9238101f" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV, where fakery means &quot;more than&quot; a string: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an &lt;code&gt;xpvmg&lt;/code&gt;; if we're a copy-on-write scalar, this is the on-write time when we do the copy, and is also used locally; if this is a vstring, drop the vstring magic. If &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; is set then a copy-on-write scalar drops its PV buffer (if any) and becomes &lt;code&gt;SvPOK_off&lt;/code&gt; rather than making a copy. (Used where this scalar is about to be set to some other value.) In addition, the &lt;code&gt;flags&lt;/code&gt; parameter gets passed to &lt;code&gt;sv_unref_flags()&lt;/code&gt; when unreffing. &lt;code&gt;sv_force_normal&lt;/code&gt; calls this function with flags set to 0.</source>
          <target state="translated">在SV上撤消各种类型的伪造，其中伪造意味着&amp;ldquo;多于&amp;rdquo;一个字符串：如果PV是共享字符串，则进行私人复制；如果我们是裁判，请停止引用；如果我们是全球人士， &lt;code&gt;xpvmg&lt;/code&gt; 降级为xpvmg；如果我们是写时复制标量，则这是我们执行复制时的写时时间，并且也在本地使用；如果这是一个vstring，请放下vstring的魔法。如果设置了 &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; ,则写时复制标量会丢弃其PV缓冲区（如果有）并变为 &lt;code&gt;SvPOK_off&lt;/code&gt; ,而不是进行复制。 （在将标量设置为其他值的情况下使用。）此外，取消设置时， &lt;code&gt;flags&lt;/code&gt; 参数将传递给 &lt;code&gt;sv_unref_flags()&lt;/code&gt; 。 &lt;code&gt;sv_force_normal&lt;/code&gt; 将标志设置为0调用此函数。</target>
        </trans-unit>
        <trans-unit id="58380a9a71bcafd994016d7b4cb1383592a7215e" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV, where fakery means &quot;more than&quot; a string: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an xpvmg; if we're a copy-on-write scalar, this is the on-write time when we do the copy, and is also used locally; if this is a vstring, drop the vstring magic. If &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; is set then a copy-on-write scalar drops its PV buffer (if any) and becomes SvPOK_off rather than making a copy. (Used where this scalar is about to be set to some other value.) In addition, the &lt;code&gt;flags&lt;/code&gt; parameter gets passed to &lt;code&gt;sv_unref_flags()&lt;/code&gt; when unreffing. &lt;code&gt;sv_force_normal&lt;/code&gt; calls this function with flags set to 0.</source>
          <target state="translated">在SV上撤消各种类型的伪造，其中伪造意味着&amp;ldquo;多于&amp;rdquo;一个字符串：如果PV是共享字符串，则进行私人复制；如果我们是裁判，请停止引用；如果我们是全球人士，则降级为xpvmg；如果我们是写时复制标量，则这是我们执行复制时的写时时间，并且也在本地使用；如果这是vstring，请放下vstring魔术。如果设置了 &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; ,则写时复制标量会丢弃其PV缓冲区（如果有）并变为SvPOK_off，而不是进行复制。 （用于将标量设置为其他值的地方。）此外，取消设置时， &lt;code&gt;flags&lt;/code&gt; 参数将传递给 &lt;code&gt;sv_unref_flags()&lt;/code&gt; 。 &lt;code&gt;sv_force_normal&lt;/code&gt; 将标志设置为0调用此函数。</target>
        </trans-unit>
        <trans-unit id="6f1a942ff8c67eb2d1fc5bf7179e4670a0cecd7d" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an &lt;code&gt;xpvmg&lt;/code&gt;. See also &lt;code&gt;&lt;a href=&quot;#sv_force_normal_flags&quot;&gt;&quot;sv_force_normal_flags&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">撤消SV上的各种伪造：如果PV是共享字符串，则进行私人复制；如果PV是共享字符串，则进行私人复制。如果我们是裁判，请停止引用；如果我们是全球人士， &lt;code&gt;xpvmg&lt;/code&gt; 降级为xpvmg。另请参见 &lt;code&gt;&lt;a href=&quot;#sv_force_normal_flags&quot;&gt;&quot;sv_force_normal_flags&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c0043167da52b5a8f43ef5ef3ae847c1d205a64" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an xpvmg. See also &lt;code&gt;sv_force_normal_flags&lt;/code&gt; .</source>
          <target state="translated">撤消SV上的各种伪造：如果PV是共享字符串，则进行私人复制；如果我们是裁判，请停止引用；如果我们是全球人士，请降级为xpvmg。另请参见 &lt;code&gt;sv_force_normal_flags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9b219af612756cb93e821fb5ae6c25750a8208b" translate="yes" xml:space="preserve">
          <source>Undocumented functions</source>
          <target state="translated">未记录的功能</target>
        </trans-unit>
        <trans-unit id="e41716465542db7b5229d785ccf7cc674a9a2021" translate="yes" xml:space="preserve">
          <source>Unescaped left brace in regex is illegal here in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中未转义的左大括号在正则表达式中是非法的；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="6360e841155690a571fd019b59b2e90901cd664e" translate="yes" xml:space="preserve">
          <source>Unescaped left brace in regex is passed through in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中未转义的左括号在正则表达式中传递；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="ebd43bbecc54b5a0f3d5534ed1867230c22e3ca4" translate="yes" xml:space="preserve">
          <source>Unescaped left braces in regular expressions</source>
          <target state="translated">正则表达式中未括号的左括号。</target>
        </trans-unit>
        <trans-unit id="9cb80f3878ea015392dd87b05584ccec54611d89" translate="yes" xml:space="preserve">
          <source>Unescaped left braces in regular expressions (for 5.30)</source>
          <target state="translated">正则表达式中未括号的左方括号(5.30的)。</target>
        </trans-unit>
        <trans-unit id="9669238bade25c40c06b3f549ae09d7384574818" translate="yes" xml:space="preserve">
          <source>Unescaped literal '%c' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中未转义的文字'％c'；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="22086bbd02aed990980d36b0db035a998bc6e3e0" translate="yes" xml:space="preserve">
          <source>Unexpected '(' with no preceding operator in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">意外的'（'，正则表达式中没有前面的运算符；在m /％s /中以&amp;lt;-HERE标记</target>
        </trans-unit>
        <trans-unit id="e8ad8043f2dbcf1dd017dcdb5209cbf492290eda" translate="yes" xml:space="preserve">
          <source>Unexpected ')' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中出现意外的'）'；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="d3baa204dcc0f34d9c04dd0cdbe5cd8bc491de0f" translate="yes" xml:space="preserve">
          <source>Unexpected ']' with no following ')' in (?[... in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">（？[...在正则表达式中）后面没有'''意外的']'；在m /％s /中以&amp;lt;-HERE标记</target>
        </trans-unit>
        <trans-unit id="3ceff2d23f8886ee7189841ccdf57932b12e7de9" translate="yes" xml:space="preserve">
          <source>Unexpected binary operator '%c' with no preceding operand in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">意外的二进制运算符'％c'在正则表达式中没有前置操作数；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="a6fd6877eeb4ca65b2ae370712af39b9caed0a2a" translate="yes" xml:space="preserve">
          <source>Unexpected character in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中的意外字符；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="93bb4877e7bb13d05b3e08f4eae8e3dad1e4b888" translate="yes" xml:space="preserve">
          <source>Unexpected constant lvalue entersub entry via type/targ %d:%d</source>
          <target state="translated">意外的常量lvalue通过type/targ %d:%d进入ub条目。</target>
        </trans-unit>
        <trans-unit id="f3d819fa6d0f62b6341c9587511dec4703500307" translate="yes" xml:space="preserve">
          <source>Unexpected exit %u</source>
          <target state="translated">意外退出%u</target>
        </trans-unit>
        <trans-unit id="8dbae700354867d121187e2a50e0cc20e0e1e77b" translate="yes" xml:space="preserve">
          <source>Unexpected exit failure %d</source>
          <target state="translated">意外的退出失败%d</target>
        </trans-unit>
        <trans-unit id="eed18284023acb946f22279a557b952faac276d4" translate="yes" xml:space="preserve">
          <source>Unfinished Tales</source>
          <target state="translated">未完成的故事</target>
        </trans-unit>
        <trans-unit id="4df58040d6486eaa853729500be20c8509618322" translate="yes" xml:space="preserve">
          <source>Unfortunately it is not that difficult somehow manage to break one's Mac OS X Perl rather severely. If all else fails and you want to really, &lt;b&gt;REALLY&lt;/b&gt;, start from scratch and remove even your Apple Perl installation (which has become corrupted somehow), the following instructions should do it. &lt;b&gt;Please think twice before following these instructions: they are much like conducting brain surgery to yourself. Without anesthesia.&lt;/b&gt; We will &lt;b&gt;not&lt;/b&gt; come to fix your system if you do this.</source>
          <target state="translated">不幸的是，设法严重破坏Mac OS X Perl并不困难。如果一切都失败了，你要真的，&lt;b&gt;真的&lt;/b&gt;，从头开始，并清除即使您的Apple Perl安装（其中已损坏以某种方式），按以下说明应该这样做。&lt;b&gt;在遵循这些说明之前，请三思：它们非常像对自己进行脑部手术。无需麻醉。&lt;/b&gt;如果您这样做，我们将&lt;b&gt;不会&lt;/b&gt;修复您的系统。</target>
        </trans-unit>
        <trans-unit id="378b677974afb6ec2935fe271f0a9219fbb154a8" translate="yes" xml:space="preserve">
          <source>Unfortunately this field is basically meaningless, since many distributions are hybrids of several kinds of things, or some new thing, or subjectively different in focus depending on who's using them. Tools like Module::Build and MakeMaker will likely stop generating this field.</source>
          <target state="translated">遗憾的是这个字段基本没有意义,因为很多发行版都是几种东西的混合体,或者一些新的东西,或者根据使用的人不同,主观上侧重点不同。像Module::Build和MakeMaker这样的工具很可能会停止生成这个字段。</target>
        </trans-unit>
        <trans-unit id="59f5b94a3a1a43fcb76168bb8fa3d4bd048c2c1e" translate="yes" xml:space="preserve">
          <source>Unfortunately this is sometimes not enough, neither colour nor quotes will help you with problems involving tabs, other non-printing characters and certain kinds of problems inherent in Unicode. To deal with this, you can switch Test::Tester into a mode whereby all &quot;tricky&quot; characters are shown as \{xx}. Tricky characters are those with ASCII code less than 33 or higher than 126. This makes the output more difficult to read but much easier to find subtle differences between strings. To turn on this mode either call &lt;code&gt;show_space()&lt;/code&gt; in your test script or set the &lt;code&gt;TESTTESTERSPACE&lt;/code&gt; environment variable to be a true value. The example above would then look like</source>
          <target state="translated">不幸的是，有时这还不够，无论是颜色还是引号都不会帮助您解决包括制表符，其他非打印字符以及Unicode固有的某些类型的问题。为了解决这个问题，您可以将Test :: Tester切换到一种模式，其中所有&amp;ldquo;特技&amp;rdquo;字符都显示为\ {xx}。棘手的字符是那些ASCII码小于33或大于126的字符。这使输出更难以阅读，但更容易发现字符串之间的细微差别。要打开此模式，请在测试脚本中调用 &lt;code&gt;show_space()&lt;/code&gt; 或将 &lt;code&gt;TESTTESTERSPACE&lt;/code&gt; 环境变量设置为真值。上面的示例将如下所示</target>
        </trans-unit>
        <trans-unit id="29de2b4590451aa9259989dd73cca2f011560c79" translate="yes" xml:space="preserve">
          <source>Unfortunately, I can't differentiate any further.</source>
          <target state="translated">可惜的是,我无法再区分了。</target>
        </trans-unit>
        <trans-unit id="6e14820d498a0bc4a9f36bbc1285250e475a8eba" translate="yes" xml:space="preserve">
          <source>Unfortunately, a note cannot be used with the single argument style of &lt;code&gt;ok()&lt;/code&gt; . That is, if you try &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt;, then &lt;code&gt;Test&lt;/code&gt; will interpret this as &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt;, and probably end up testing &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; -- and that's not what you want!</source>
          <target state="translated">不幸的是，注释不能与 &lt;code&gt;ok()&lt;/code&gt; 的单个参数样式一起使用。也就是说，如果您尝试 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt; ，那么 &lt;code&gt;Test&lt;/code&gt; 会将其解释为 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; ，并且最终可能会测试 &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; －那不是您想要的！</target>
        </trans-unit>
        <trans-unit id="ef3c1b19c392ac342a5e6bd955e45b0b563788d1" translate="yes" xml:space="preserve">
          <source>Unfortunately, a note cannot be used with the single argument style of &lt;code&gt;ok()&lt;/code&gt;. That is, if you try &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt;, then &lt;code&gt;Test&lt;/code&gt; will interpret this as &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt;, and probably end up testing &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; -- and that's not what you want!</source>
          <target state="translated">不幸的是，注释不能与 &lt;code&gt;ok()&lt;/code&gt; 的单个参数样式一起使用。也就是说，如果您尝试 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt; ，那么 &lt;code&gt;Test&lt;/code&gt; 会将其解释为 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; ，并且最终可能会测试 &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; ，这不是您想要的！</target>
        </trans-unit>
        <trans-unit id="4ed74c92d4298d9e7fcce728b69ed6f5c8ab08c5" translate="yes" xml:space="preserve">
          <source>Unfortunately, for backwards compatibility reasons, an empty &lt;code&gt;\x&lt;/code&gt; is legal outside &lt;code&gt;use re 'strict'&lt;/code&gt; and expands to a NUL character.</source>
          <target state="translated">不幸的是，出于向后兼容的原因，空 &lt;code&gt;\x&lt;/code&gt; 在外部可以 &lt;code&gt;use re 'strict'&lt;/code&gt; 合法，并扩展为NUL字符。</target>
        </trans-unit>
        <trans-unit id="7f4f5938609da571758adb22fa6ce02f230693d9" translate="yes" xml:space="preserve">
          <source>Unfortunately, interpretation of colors 0 through 7 often depends on whether the emulator supports eight colors or sixteen colors. Emulators that only support eight colors (such as the Linux console) will display colors 0 through 7 with normal brightness and ignore colors 8 through 15, treating them the same as white. Emulators that support 16 colors, such as gnome-terminal, normally display colors 0 through 7 as dim or darker versions and colors 8 through 15 as normal brightness. On such emulators, the &quot;normal&quot; white (color 7) usually is shown as pale grey, requiring bright white (15) to be used to get a real white color. Bright black usually is a dark grey color, although some terminals display it as pure black. Some sixteen-color terminal emulators also treat normal yellow (color 3) as orange or brown, and bright yellow (color 11) as yellow.</source>
          <target state="translated">不幸的是,0到7的颜色的解释通常取决于仿真器是支持8种颜色还是16种颜色。只支持8种颜色的模拟器(如Linux控制台)会以正常的亮度显示0到7号颜色,而忽略8到15号颜色,把它们当作白色对待。支持16种颜色的模拟器,如gnome-terminal,通常会将颜色0到7显示为暗色或较暗的版本,将颜色8到15显示为正常亮度。在这样的仿真器上,&quot;正常 &quot;的白色(颜色7)通常显示为淡灰色,需要使用亮白色(15)才能得到真正的白色。亮黑色通常是一种深灰色,尽管有些终端显示为纯黑色。一些十六色终端仿真器还将正常的黄色(颜色3)处理为橙色或棕色,将亮黄色(颜色11)处理为黄色。</target>
        </trans-unit>
        <trans-unit id="d3f96232328f4faede427c8ce3041998253135ab" translate="yes" xml:space="preserve">
          <source>Unfortunately, it may be that encodings are not &lt;code&gt;PerlIO&lt;/code&gt; -savvy. You can check to see whether your encoding is supported by &lt;code&gt;PerlIO&lt;/code&gt; by invoking the &lt;code&gt;perlio_ok&lt;/code&gt; method on it:</source>
          <target state="translated">不幸的是，可能是编码不 &lt;code&gt;PerlIO&lt;/code&gt; PerlIO。您可以通过在其上调用 &lt;code&gt;perlio_ok&lt;/code&gt; 方法来检查 &lt;code&gt;PerlIO&lt;/code&gt; 是否支持您的编码：</target>
        </trans-unit>
        <trans-unit id="7a881f618a75cd78f718468efd31960bdadb828c" translate="yes" xml:space="preserve">
          <source>Unfortunately, it may be that encodings are not &lt;code&gt;PerlIO&lt;/code&gt;-savvy. You can check to see whether your encoding is supported by &lt;code&gt;PerlIO&lt;/code&gt; by invoking the &lt;code&gt;perlio_ok&lt;/code&gt; method on it:</source>
          <target state="translated">不幸的是，可能是编码不 &lt;code&gt;PerlIO&lt;/code&gt; PerlIO。您可以通过在其上调用 &lt;code&gt;perlio_ok&lt;/code&gt; 方法来检查 &lt;code&gt;PerlIO&lt;/code&gt; 是否支持您的编码：</target>
        </trans-unit>
        <trans-unit id="fa870b38ba970158ffd4da6159a903c51d8f85af" translate="yes" xml:space="preserve">
          <source>Unfortunately, the original specification of UTF-8 leaves some room for interpretation of how many bytes of encoded output one should generate from one input Unicode character. Strictly speaking, the shortest possible sequence of UTF-8 bytes should be generated, because otherwise there is potential for an input buffer overflow at the receiving end of a UTF-8 connection. Perl always generates the shortest length UTF-8, and with warnings on, Perl will warn about non-shortest length UTF-8 along with other malformations, such as the surrogates, which are not Unicode code points valid for interchange.</source>
          <target state="translated">遗憾的是,UTF-8的原始规范为从一个输入的Unicode字符中产生多少字节的编码输出留下了一些解释的空间。严格地说,应该生成尽可能短的UTF-8字节序列,因为否则在UTF-8连接的接收端有可能出现输入缓冲区溢出。Perl总是生成最短长度的UTF-8,在开启警告的情况下,Perl会对非最短长度的UTF-8以及其他畸形情况发出警告,比如代用码,这些代用码不是Unicode码点有效的互换。</target>
        </trans-unit>
        <trans-unit id="a23a8e59abb3029d4c1dd279e145008516f63183" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are quite a few deficiencies with the design (and often, the implementations) of locales. Unicode was invented (see &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for an introduction to that) in part to address these design deficiencies, and nowadays, there is a series of &quot;UTF-8 locales&quot;, based on Unicode. These are locales whose character set is Unicode, encoded in UTF-8. Starting in v5.20, Perl fully supports UTF-8 locales, except for sorting and string comparisons like &lt;code&gt;lt&lt;/code&gt; and &lt;code&gt;ge&lt;/code&gt;. Starting in v5.26, Perl can handle these reasonably as well, depending on the platform's implementation. However, for earlier releases or for better control, use &lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode::Collate&lt;/a&gt;. There are actually two slightly different types of UTF-8 locales: one for Turkic languages and one for everything else.</source>
          <target state="translated">不幸的是，语言环境的设计（通常是实现）存在很多缺陷。发明Unicode是为了解决这些设计缺陷（部分介绍请参见&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;），如今，有一系列基于Unicode的&amp;ldquo; UTF-8语言环境&amp;rdquo;。这些是字符集为Unicode且以UTF-8编码的语言环境。从v5.20开始，Perl完全支持UTF-8语言环境，除了 &lt;code&gt;lt&lt;/code&gt; 和 &lt;code&gt;ge&lt;/code&gt; 之类的排序和字符串比较。从v5.26开始，Perl也可以根据平台的实现合理地处理这些问题。但是，对于早期版本或更好的控制，请使用&lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;。实际上，存在两种略有不同的UTF-8语言环境：一种用于突厥语，另一种用于其他所有语言。</target>
        </trans-unit>
        <trans-unit id="1170c59a72df3e22ea0a090adf0e9824ff8c0b09" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are quite a few deficiencies with the design (and often, the implementations) of locales. Unicode was invented (see &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for an introduction to that) in part to address these design deficiencies, and nowadays, there is a series of &quot;UTF-8 locales&quot;, based on Unicode. These are locales whose character set is Unicode, encoded in UTF-8. Starting in v5.20, Perl fully supports UTF-8 locales, except for sorting and string comparisons. (Use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; for these.) Perl continues to support the old non UTF-8 locales as well. There are currently no UTF-8 locales for EBCDIC platforms.</source>
          <target state="translated">不幸的是，语言环境的设计（通常是实现）存在很多缺陷。发明Unicode是为了解决这些设计缺陷（部分介绍请参见&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;），如今，有一系列基于Unicode的&amp;ldquo; UTF-8语言环境&amp;rdquo;。这些是字符集为Unicode且以UTF-8编码的语言环境。从v5.20开始，Perl完全支持UTF-8语言环境，除了排序和字符串比较。 （为此，请使用&lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;。）Perl也继续支持旧的非UTF-8语言环境。 EBCDIC平台当前没有UTF-8语言环境。</target>
        </trans-unit>
        <trans-unit id="c8d518114a049f78aefe7090de8efc32eccefc83" translate="yes" xml:space="preserve">
          <source>Unfortunately, this isn't true. In perl 5.18 and earlier, AVs use &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a marker for indicating that an array element has not yet been initialized. Thus, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $av[0]&lt;/code&gt; would be true for the above Perl code, but false for the array generated by the XS code. In perl 5.20, storing &amp;amp;PL_sv_undef will create a read-only element, because the scalar &amp;amp;PL_sv_undef itself is stored, not a copy.</source>
          <target state="translated">不幸的是，事实并非如此。在perl 5.18及更早版本中，AV使用 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 作为标记来指示尚未初始化数组元素。因此， &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $av[0]&lt;/code&gt; 对于上面的Perl代码为true，但对于XS代码生成的数组为false。在perl 5.20中，存储＆PL_sv_undef将创建一个只读元素，因为标量＆PL_sv_undef本身是存储的，而不是副本。</target>
        </trans-unit>
        <trans-unit id="6aaca93722126b600c61100d9e3813a48d2917af" translate="yes" xml:space="preserve">
          <source>Unfortunately, this isn't true. In perl 5.18 and earlier, AVs use &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a marker for indicating that an array element has not yet been initialized. Thus, &lt;code&gt;exists $av[0]&lt;/code&gt; would be true for the above Perl code, but false for the array generated by the XS code. In perl 5.20, storing &amp;amp;PL_sv_undef will create a read-only element, because the scalar &amp;amp;PL_sv_undef itself is stored, not a copy.</source>
          <target state="translated">不幸的是，事实并非如此。在perl 5.18及更早版本中，AV使用 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 作为标记，用于指示尚未初始化数组元素。因此， &lt;code&gt;exists $av[0]&lt;/code&gt; 对于上面的Perl代码为true，但对于XS代码生成的数组为false。在perl 5.20中，存储＆PL_sv_undef将创建一个只读元素，因为标量＆PL_sv_undef本身是存储的，而不是副本。</target>
        </trans-unit>
        <trans-unit id="4484d276f38b1e070d2bbc67b4f47022917572dc" translate="yes" xml:space="preserve">
          <source>Unfortunately, this scheme does not work well with escape-based encodings such as ISO-2022-JP.</source>
          <target state="translated">不幸的是,这种方案不能很好地与基于转义的编码(如ISO-2022-JP)配合使用。</target>
        </trans-unit>
        <trans-unit id="5a9b09da1b70d953819b14bad175ad6e8c81c049" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this &lt;code&gt;style&lt;/code&gt; variable is used to set defaults for all three directory hierarchies (core, vendor, and site), there is no guarantee that the same style is actually appropriate for all those directories. For example, $prefix might be</source>
          <target state="translated">不幸的是，尽管此 &lt;code&gt;style&lt;/code&gt; 变量用于为所有三个目录层次结构（核心，供应商和站点）设置默认值，但不能保证实际上相同的样式适用于所有这些目录。例如，$ prefix可能是</target>
        </trans-unit>
        <trans-unit id="87c5d4faa14910842f5557a05819e468661f127e" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this is true, it's still broken. All the references in @AoA refer to the</source>
          <target state="translated">不幸的是,虽然这是事实,但还是破绽百出。在@AoA中的所有引用都指的是</target>
        </trans-unit>
        <trans-unit id="b3033d12e8c5e48f79875dd4cf162f90c243f353" translate="yes" xml:space="preserve">
          <source>Unfortunately, you may encounter Perl modules that are not</source>
          <target state="translated">遗憾的是,你可能会遇到一些不属于</target>
        </trans-unit>
        <trans-unit id="76435dad798e21eb71def4f2d3a46ed9708e4adf" translate="yes" xml:space="preserve">
          <source>Unget a line of text from the server.</source>
          <target state="translated">从服务器上获取一行文字。</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="eb802e96fd38e5e550d19f898a4fa941c45d6b21" translate="yes" xml:space="preserve">
          <source>Unicode 7.0 changed the wording so that they are &quot;&lt;b&gt;not recommended&lt;/b&gt; for use in open interchange of Unicode text data&quot;. The 7.0 Standard goes on to say:</source>
          <target state="translated">Unicode 7.0更改了措辞，因此&amp;ldquo; &lt;b&gt;不建议&lt;/b&gt;在开放式Unicode文本数据交换中使用它们&amp;rdquo;。 7.0标准继续说：</target>
        </trans-unit>
        <trans-unit id="8306b01ff9c220d1ce9274f85cf12d457904d299" translate="yes" xml:space="preserve">
          <source>Unicode Character Properties</source>
          <target state="translated">统一码字符属性</target>
        </trans-unit>
        <trans-unit id="2a76af7c10ae9a7945dc677634ff7f287d2f0d66" translate="yes" xml:space="preserve">
          <source>Unicode Collation Algorithm</source>
          <target state="translated">统一码整理算法</target>
        </trans-unit>
        <trans-unit id="c80690d5b1494bcf7f26319a35f4cf6977eedc42" translate="yes" xml:space="preserve">
          <source>Unicode Collation Algorithm - UTS #10</source>
          <target state="translated">統一碼整理算法-UTS #10</target>
        </trans-unit>
        <trans-unit id="8a8a7bf1ba1b9e4c2b07e9ad90fbd26463e5d980" translate="yes" xml:space="preserve">
          <source>Unicode Consortium</source>
          <target state="translated">统一码联盟</target>
        </trans-unit>
        <trans-unit id="0eb610a39db0d61541e877f8f7d93f1d2cd4e414" translate="yes" xml:space="preserve">
          <source>Unicode Consortium &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt;</source>
          <target state="translated">Unicode联盟&lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3570b2b05ae0a63f4914d2244d9f883b9ba33c3c" translate="yes" xml:space="preserve">
          <source>Unicode Consortium &lt;a href=&quot;https://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt;</source>
          <target state="translated">Unicode联盟&lt;a href=&quot;https://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b56cce9c1325a6619b09abb29a03b2934dad13be" translate="yes" xml:space="preserve">
          <source>Unicode Encodings</source>
          <target state="translated">統一碼編碼</target>
        </trans-unit>
        <trans-unit id="20d826b4f354ace01634ff9215d461c1d2de2da2" translate="yes" xml:space="preserve">
          <source>Unicode FAQ</source>
          <target state="translated">统一码常见问题</target>
        </trans-unit>
        <trans-unit id="be2c3b070e201b30c780f442801bee53720d3f02" translate="yes" xml:space="preserve">
          <source>Unicode Glossary</source>
          <target state="translated">统一码词汇表</target>
        </trans-unit>
        <trans-unit id="c37be50216d5f3d38f1ea9b4becfe8758aaff3f3" translate="yes" xml:space="preserve">
          <source>Unicode I/O</source>
          <target state="translated">统一码I/O</target>
        </trans-unit>
        <trans-unit id="0b15b2a3ee7f250e6d79317da505977b8ac153a4" translate="yes" xml:space="preserve">
          <source>Unicode Locale Data Markup Language (LDML) - UTS #35</source>
          <target state="translated">統一碼地域數據標記語言(LDML)-UTS #35</target>
        </trans-unit>
        <trans-unit id="4f977034e8571e3a210188dcc1d8385457a8e9f6" translate="yes" xml:space="preserve">
          <source>Unicode Normalization Forms</source>
          <target state="translated">统一码规范化形式</target>
        </trans-unit>
        <trans-unit id="775e22294d31686679c1488c3a4e009b588fb93a" translate="yes" xml:space="preserve">
          <source>Unicode Normalization Forms - UAX #15</source>
          <target state="translated">统一码规范化表格-UAX #15</target>
        </trans-unit>
        <trans-unit id="41086ae1277eac703b49ed9c64da7c4e1e028776" translate="yes" xml:space="preserve">
          <source>Unicode Properties</source>
          <target state="translated">统一码属性</target>
        </trans-unit>
        <trans-unit id="ecfb52e522a545f9d54db78a273755a7cf69910d" translate="yes" xml:space="preserve">
          <source>Unicode Recommended Reading List</source>
          <target state="translated">统一码推荐阅读列表</target>
        </trans-unit>
        <trans-unit id="3dc43797a086d2e60b97e26ddbcd0e763ba2be44" translate="yes" xml:space="preserve">
          <source>Unicode Regular Expression Support Level</source>
          <target state="translated">统一码正则表达式支持级别</target>
        </trans-unit>
        <trans-unit id="47be4025952fbf3894ef86d325a9d331d9d77d10" translate="yes" xml:space="preserve">
          <source>Unicode Support</source>
          <target state="translated">支持Unicode</target>
        </trans-unit>
        <trans-unit id="5477f70b1eea785630b35cd84e386522cded5715" translate="yes" xml:space="preserve">
          <source>Unicode Transformation Format</source>
          <target state="translated">统一码转换格式</target>
        </trans-unit>
        <trans-unit id="3b3c1f4d1dbf76960cd965f0a9ee21a6e35c74bd" translate="yes" xml:space="preserve">
          <source>Unicode Useful Resources</source>
          <target state="translated">统一码实用资源</target>
        </trans-unit>
        <trans-unit id="0bd38e8f5dc5fab318029c6a0f6bf740c02237f9" translate="yes" xml:space="preserve">
          <source>Unicode aims to &lt;b&gt;UNI&lt;/b&gt;-fy the en-&lt;b&gt;CODE&lt;/b&gt;-ings of all the world's character sets into a single Standard. For quite a few of the various coding standards that existed when Unicode was first created, converting from each to Unicode essentially meant adding a constant to each code point in the original standard, and converting back meant just subtracting that same constant. For ASCII and ISO-8859-1, the constant is 0. For ISO-8859-5, (Cyrillic) the constant is 864; for Hebrew (ISO-8859-8), it's 1488; Thai (ISO-8859-11), 3424; and so forth. This made it easy to do the conversions, and facilitated the adoption of Unicode.</source>
          <target state="translated">Unicode的旨在&lt;b&gt;UNI&lt;/b&gt; -Fy的恩&lt;b&gt;CODE&lt;/b&gt;的世界上所有的字符集-ings成一个单一的标准。对于最初创建Unicode时存在的各种编码标准中的很多，从每种编码标准转换为Unicode本质上意味着在原始标准的每个代码点上添加一个常数，而转换回该常数则意味着减去该常数。对于ASCII和ISO-8859-1，常数为0。对于ISO-8859-5，（西里尔字母），常数为864；对于（Cyrillic）常数。希伯来语（ISO-8859-8）为1488；泰语（ISO-8859-11），3424；等等。这使得转换变得容易，并促进了Unicode的采用。</target>
        </trans-unit>
        <trans-unit id="292b5cfbcdb907b6b9b2852bab43a1e41959e1df" translate="yes" xml:space="preserve">
          <source>Unicode also defines various</source>
          <target state="translated">统一码还定义了各种</target>
        </trans-unit>
        <trans-unit id="bfb017bed191925e52b6029168924ebfe8c5d26c" translate="yes" xml:space="preserve">
          <source>Unicode and EBCDIC</source>
          <target state="translated">统一码和EBCDIC</target>
        </trans-unit>
        <trans-unit id="e27520c25eb75e7d79e8f990eeb1be4ae1df41df" translate="yes" xml:space="preserve">
          <source>Unicode and ISO/IEC 10646 are coordinated standards that unify almost all other modern character set standards, covering more than 80 writing systems and hundreds of languages, including all commercially-important modern languages. All characters in the largest Chinese, Japanese, and Korean dictionaries are also encoded. The standards will eventually cover almost all characters in more than 250 writing systems and thousands of languages. Unicode 1.0 was released in October 1991, and 6.0 in October 2010.</source>
          <target state="translated">統一碼和ISO/IEC 10646是協調的標準,統一了幾乎所有其他的現代字符集標準,涵蓋80多種文字系統和數百種語言,包括所有商業上重要的現代語言。最大的中文、日文和韩文字典中的所有字符也都被编码。该标准最终将覆盖250多种书写系统和数千种语言中的几乎所有字符。统一码1.0于1991年10月发布,6.0于2010年10月发布。</target>
        </trans-unit>
        <trans-unit id="35759c0ae04781f6ce2a8261ef308a0d62267332" translate="yes" xml:space="preserve">
          <source>Unicode and Localisation Support</source>
          <target state="translated">统一码和本地化支持</target>
        </trans-unit>
        <trans-unit id="c79347889e0d28fc8f7e3b48dc5c985da6b9c2b3" translate="yes" xml:space="preserve">
          <source>Unicode and Multilingual Support in HTML, Fonts, Web Browsers and Other Applications</source>
          <target state="translated">在HTML、字体、网络浏览器和其他应用程序中支持统一码和多语言。</target>
        </trans-unit>
        <trans-unit id="aa0a00bb85a8ade7272b8fa2d081ab3abd746b2c" translate="yes" xml:space="preserve">
          <source>Unicode and UTF</source>
          <target state="translated">Unicode和UTF</target>
        </trans-unit>
        <trans-unit id="8e9632880dc5b73eee711bbb8acae51558160af7" translate="yes" xml:space="preserve">
          <source>Unicode and UTF-8</source>
          <target state="translated">统一码和UTF-8</target>
        </trans-unit>
        <trans-unit id="814213da4f2b17caa9167081f902458536e3ac5c" translate="yes" xml:space="preserve">
          <source>Unicode casing is very different from ASCII casing.</source>
          <target state="translated">Unicode编码与ASCII编码有很大不同。</target>
        </trans-unit>
        <trans-unit id="3db087027c1f3fb2dafc91bf1aec8e28ed66555f" translate="yes" xml:space="preserve">
          <source>Unicode character database</source>
          <target state="translated">统一码字符数据库</target>
        </trans-unit>
        <trans-unit id="90ce74ac0f978040e744ea5f9ee3a9fc0fdd5b56" translate="yes" xml:space="preserve">
          <source>Unicode character properties that are NOT accepted by Perl</source>
          <target state="translated">不被Perl接受的Unicode字符属性</target>
        </trans-unit>
        <trans-unit id="131ad96e9210c062a5a91bbff68adb3c52f574b9" translate="yes" xml:space="preserve">
          <source>Unicode characters are assigned to</source>
          <target state="translated">Unicode字符被分配到</target>
        </trans-unit>
        <trans-unit id="9cd8bdcde375ab8cc6d64998c61f22e2b1db366b" translate="yes" xml:space="preserve">
          <source>Unicode characters have a Unicode name and numeric code point (ordinal) value. Use the &lt;code&gt;\N{}&lt;/code&gt; construct to specify a character by either of these values. Certain sequences of characters also have names.</source>
          <target state="translated">Unicode字符具有Unicode名称和数字代码点（常规）值。使用 &lt;code&gt;\N{}&lt;/code&gt; 构造通过这两个值之一指定字符。某些字符序列也具有名称。</target>
        </trans-unit>
        <trans-unit id="210080ef48f936087dda80492d9856fe5ec4b9bc" translate="yes" xml:space="preserve">
          <source>Unicode classes</source>
          <target state="translated">统一码类</target>
        </trans-unit>
        <trans-unit id="0f01459324a40b9e6a3a0e387cbfebfba5b6c62c" translate="yes" xml:space="preserve">
          <source>Unicode code points versus EBCDIC code points</source>
          <target state="translated">统一码码点与EBCDIC码点的比较</target>
        </trans-unit>
        <trans-unit id="7625e9ef1dd87171eb4d5354c03dd9be33744a1d" translate="yes" xml:space="preserve">
          <source>Unicode codepoint</source>
          <target state="translated">统一编码码点</target>
        </trans-unit>
        <trans-unit id="329b02599470f15ed9e34472928160323f9fb081" translate="yes" xml:space="preserve">
          <source>Unicode coding schemes other than native utf8 are supported by Encode::Unicode, which will be autoloaded on demand.</source>
          <target state="translated">Encode::Unicode支持除原生utf8以外的其他Unicode编码方案,将根据需求自动加载。</target>
        </trans-unit>
        <trans-unit id="106885fd8f00b6d1d3909f50579c6a1e81f50c34" translate="yes" xml:space="preserve">
          <source>Unicode concept which most often is equal to uppercase, but for certain characters like the German &quot;sharp s&quot; there is a difference.</source>
          <target state="translated">Unicode的概念,大多数情况下等于大写,但对于某些字符,如德语的 &quot;sharp s &quot;是有区别的。</target>
        </trans-unit>
        <trans-unit id="be2f011fe43db39f9182b02fbc6580c3cfe62024" translate="yes" xml:space="preserve">
          <source>Unicode considers many code points to be illegal, or to be avoided. Perl generally accepts them, once they have passed through any input filters that may try to exclude them. These have been discussed above (see &quot;Surrogates&quot; under UTF-16 in &lt;a href=&quot;#Unicode-Encodings&quot;&gt;&quot;Unicode Encodings&quot;&lt;/a&gt;, &lt;a href=&quot;#Noncharacter-code-points&quot;&gt;&quot;Noncharacter code points&quot;&lt;/a&gt;, and &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;&quot;Beyond Unicode code points&quot;&lt;/a&gt;).</source>
          <target state="translated">Unicode认为许多代码点是非法的或应避免的。一旦它们通过可能试图排除它们的任何输入过滤器，Perl通常就会接受它们。上面已经讨论了这些内容（请参见&amp;ldquo; &lt;a href=&quot;#Unicode-Encodings&quot;&gt;Unicode编码&amp;rdquo;&lt;/a&gt;，&lt;a href=&quot;#Noncharacter-code-points&quot;&gt;&amp;ldquo;非字符代码点&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;&amp;ldquo;超越Unicode代码点&amp;rdquo;中&lt;/a&gt;UTF-16下的&amp;ldquo;代理&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="d49075f8dbc705f2f67ea7272b64074e286787f2" translate="yes" xml:space="preserve">
          <source>Unicode defines a fourth boundary type, accessible through the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt; module.</source>
          <target state="translated">Unicode定义了第四个边界类型，可通过&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::LineBreak&quot;&gt;Unicode :: LineBreak&lt;/a&gt;模块访问。</target>
        </trans-unit>
        <trans-unit id="07aa50c4f0010de0db76a15f32c4e153b24a7275" translate="yes" xml:space="preserve">
          <source>Unicode defines all its properties in the compound form, so all single-form properties are Perl extensions. Most of these are just synonyms for the Unicode ones, but some are genuine extensions, including several that are in the compound form. And quite a few of these are actually recommended by Unicode (in &lt;a href=&quot;http://www.unicode.org/reports/tr18&quot;&gt;http://www.unicode.org/reports/tr18&lt;/a&gt;).</source>
          <target state="translated">Unicode以复合形式定义其所有属性，因此所有单形式属性都是Perl扩展。其中大多数只是Unicode的同义词，但有些是真正的扩展，包括一些复合形式。Unicode实际上推荐了其中的很多（在&lt;a href=&quot;http://www.unicode.org/reports/tr18&quot;&gt;http://www.unicode.org/reports/tr18中&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="83740583eabf50f236d63ef1d8d25274281fb0cf" translate="yes" xml:space="preserve">
          <source>Unicode defines all its properties in the compound form, so all single-form properties are Perl extensions. Most of these are just synonyms for the Unicode ones, but some are genuine extensions, including several that are in the compound form. And quite a few of these are actually recommended by Unicode (in &lt;a href=&quot;https://www.unicode.org/reports/tr18&quot;&gt;https://www.unicode.org/reports/tr18&lt;/a&gt;).</source>
          <target state="translated">Unicode以复合形式定义其所有属性，因此所有单形式属性都是Perl扩展。其中大多数只是Unicode的同义词，但有些是真正的扩展，包括一些复合形式的扩展。Unicode实际上推荐了其中的很多（在&lt;a href=&quot;https://www.unicode.org/reports/tr18&quot;&gt;https://www.unicode.org/reports/tr18中&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8557c4367cf0c9f30d95a470ee521928d669fb7c" translate="yes" xml:space="preserve">
          <source>Unicode defines characters like &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; or &lt;code&gt;GREEK
SMALL LETTER ALPHA&lt;/code&gt; and unique numbers for the characters, in this case 0x0041 and 0x03B1, respectively. These unique numbers are called</source>
          <target state="translated">Unicode定义类似的字符 &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; 或 &lt;code&gt;GREEK SMALL LETTER ALPHA&lt;/code&gt; 分别和唯一号码中的字符，在这种情况下0x0041和0x03B1。这些唯一的号码称为</target>
        </trans-unit>
        <trans-unit id="acaff2c7ef0e4ff533eb55c7b82bb8cb537cf6b5" translate="yes" xml:space="preserve">
          <source>Unicode does define several other decimal--and numeric--characters besides the familiar 0 to 9, such as the Arabic and Indic digits. Perl does not support string-to-number conversion for digits other than ASCII &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt; (and ASCII &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt; for hexadecimal). To get safe conversions from any Unicode string, use &lt;a href=&quot;Unicode::UCD#num%28%29&quot;&gt;&quot;num()&quot; in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Unicode确实定义了除熟悉的0到9外的其他十进制和数字字符，例如阿拉伯和印度数字。 Perl不支持ASCII &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;9&lt;/code&gt; （十六进制为ASCII &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;f&lt;/code&gt; ）以外的数字到字符串到数字的转换。要从任何Unicode字符串获得安全的转换，请&lt;a href=&quot;Unicode::UCD#num%28%29&quot;&gt;在Unicode :: UCD中&lt;/a&gt;使用&amp;ldquo; num（）&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="66287c5bc6e75d359bae32c20cfc35103e105bf3" translate="yes" xml:space="preserve">
          <source>Unicode does define several other decimal--and numeric--characters besides the familiar 0 to 9, such as the Arabic and Indic digits. Perl does not support string-to-number conversion for digits other than ASCII &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt; (and ASCII &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt; for hexadecimal). To get safe conversions from any Unicode string, use &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Unicode确实定义了除了熟悉的0到9之外的其他十进制和数字字符，例如阿拉伯数字和印度数字。Perl不支持ASCII &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;9&lt;/code&gt; （十六进制的ASCII &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;f&lt;/code&gt; ）以外的数字到字符串到数字的转换。要从任何Unicode字符串获得安全的转换，请&lt;a href=&quot;unicode/ucd#num()&quot;&gt;在Unicode :: UCD中&lt;/a&gt;使用num（）。</target>
        </trans-unit>
        <trans-unit id="e0b4309884526bd11fe1ab30cc9fc6ed43648809" translate="yes" xml:space="preserve">
          <source>Unicode form that is useful when comparing strings regardless of case, as certain characters have complex one-to-many case mappings. Primarily a variant of lowercase.</source>
          <target state="translated">Unicode形式,在比较字符串的大小写时非常有用,因为某些字符具有复杂的一对多大小写映射。主要是小写字母的变体。</target>
        </trans-unit>
        <trans-unit id="71079ed61722f43474765527d68998144c7665d4" translate="yes" xml:space="preserve">
          <source>Unicode furnishes the &lt;code&gt;Age&lt;/code&gt; property from which this is derived. The problem with Age is that a strict interpretation of it (which Perl takes) has it matching the precise release a code point's meaning is introduced in. Thus &lt;code&gt;U+0041&lt;/code&gt; would match only 1.1; and &lt;code&gt;U+1EFF&lt;/code&gt; only 5.1. This is not usually what you want.</source>
          <target state="translated">Unicode提供了 &lt;code&gt;Age&lt;/code&gt; 属性（从中派生该属性）。 Age的问题在于对它（Perl采取的一种严格的解释）使其与引入了代码点含义的精确版本相匹配。因此， &lt;code&gt;U+0041&lt;/code&gt; 仅匹配1.1；因此，A + 0041仅匹配1.1。和 &lt;code&gt;U+1EFF&lt;/code&gt; 仅5.1。这通常不是您想要的。</target>
        </trans-unit>
        <trans-unit id="fd3ab6b6f70f7431b1416e0f9107c1af48c38649" translate="yes" xml:space="preserve">
          <source>Unicode has some property-value pairs that currently don't match anything. This happens generally either because they are obsolete, or they exist for symmetry with other forms, but no language has yet been encoded that uses them. In this version of Unicode, the following match zero code points:</source>
          <target state="translated">Unicode有一些属性值对目前没有任何匹配。出现这种情况一般是因为它们已经过时了,或者它们的存在是为了与其他形式对称,但还没有任何语言使用它们的编码。在这个版本的Unicode中,以下是匹配零码点的。</target>
        </trans-unit>
        <trans-unit id="598e8ae9c96e08e40d6e1a738b55c351268bc51b" translate="yes" xml:space="preserve">
          <source>Unicode has three pseudo scripts that are handled specially.</source>
          <target state="translated">Unicode有三种伪脚本被特殊处理。</target>
        </trans-unit>
        <trans-unit id="73c49c9d36b230f185c7169c7475e8856ddbd520" translate="yes" xml:space="preserve">
          <source>Unicode in Perl on EBCDIC</source>
          <target state="translated">在Perl中使用EBCDIC的Unicode</target>
        </trans-unit>
        <trans-unit id="5a2ff10d38459692f18fa8f0d5e12e0027770ead" translate="yes" xml:space="preserve">
          <source>Unicode is a character set standard which plans to codify all of the writing systems of the world, plus many other symbols.</source>
          <target state="translated">Unicode是一个字符集标准,它计划将世界上所有的书写系统,加上许多其他符号进行编码。</target>
        </trans-unit>
        <trans-unit id="3bb1c5615f2383d427b4613073ef1ec435b5138c" translate="yes" xml:space="preserve">
          <source>Unicode is a character set that can represent most characters in most of the world's languages, providing room for over one million different characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin characters are assigned to the numbers 0 - 127. The Latin-1 Supplement with characters that are used in several European languages is in the next range, up to 255. After some more Latin extensions we find the character sets from languages using non-Roman alphabets, interspersed with a variety of symbol sets such as currency symbols, Zapf Dingbats or Braille. (You might want to visit &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for a look at some of them - my personal favourites are Telugu and Kannada.)</source>
          <target state="translated">Unicode是一个字符集，可以代表世界上大多数语言的大多数字符，为超过一百万个不同的字符提供了空间。 Unicode 3.1指定94,140个字符：基本拉丁字符分配给数字0-127。具有多种欧洲语言使用的字符的Latin-1补码在下一个范围内，最多为255。在发现更多拉丁扩展之后，我们发现使用非罗马字母的语言中的字符集，并点缀各种符号集，例如货币符号，Zapf Dingbats或盲文。 （您可能想访问&lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt;来查看其中的一些-我个人的最爱是泰卢固语和卡纳达语。）</target>
        </trans-unit>
        <trans-unit id="918d612f1c2574dce41b14dc2be8c0387758201b" translate="yes" xml:space="preserve">
          <source>Unicode is a character set that can represent most characters in most of the world's languages, providing room for over one million different characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin characters are assigned to the numbers 0 - 127. The Latin-1 Supplement with characters that are used in several European languages is in the next range, up to 255. After some more Latin extensions we find the character sets from languages using non-Roman alphabets, interspersed with a variety of symbol sets such as currency symbols, Zapf Dingbats or Braille. (You might want to visit &lt;a href=&quot;https://www.unicode.org/&quot;&gt;https://www.unicode.org/&lt;/a&gt; for a look at some of them - my personal favourites are Telugu and Kannada.)</source>
          <target state="translated">Unicode是一个字符集，可以表示世界上大多数语言中的大多数字符，为超过一百万个不同的字符提供了空间。 Unicode 3.1指定94,140个字符：基本拉丁字符分配给数字0-127。具有多种欧洲语言使用的字符的Latin-1补码在下一个范围内，最多为255。在发现更多拉丁扩展之后，我们发现使用非罗马字母的语言中的字符集，并点缀各种符号集，例如货币符号，Zapf Dingbats或盲文。 （您可能想访问&lt;a href=&quot;https://www.unicode.org/&quot;&gt;https://www.unicode.org/&lt;/a&gt;来查看其中的一些-我个人的最爱是泰卢固语和卡纳达语。）</target>
        </trans-unit>
        <trans-unit id="bb4b52a0e0d40f8cd4680e731fa8661db40b7bfb" translate="yes" xml:space="preserve">
          <source>Unicode is a comprehensive standard. It specifies many things outside the scope of Perl, such as how to display sequences of characters. For a full discussion of all aspects of Unicode, see &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;.</source>
          <target state="translated">Unicode是一个全面的标准。它指定了Perl范围之外的许多内容，例如如何显示字符序列。有关Unicode所有方面的完整讨论，请参见&lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0004a5b6be77b386fdac7a26a14cd8154c46e916" translate="yes" xml:space="preserve">
          <source>Unicode is a comprehensive standard. It specifies many things outside the scope of Perl, such as how to display sequences of characters. For a full discussion of all aspects of Unicode, see &lt;a href=&quot;https://www.unicode.org&quot;&gt;https://www.unicode.org&lt;/a&gt;.</source>
          <target state="translated">Unicode是一个全面的标准。它指定了Perl范围之外的许多内容，例如如何显示字符序列。有关Unicode所有方面的完整讨论，请参见&lt;a href=&quot;https://www.unicode.org&quot;&gt;https://www.unicode.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b43e74b6aa7b2acf2d7d34cb97f083e42a3eb18" translate="yes" xml:space="preserve">
          <source>Unicode is a new and complex technology and one may easily overlook certain security pitfalls. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; for an overview and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details, and &lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;&quot;Security Implications of Unicode&quot; in perlunicode&lt;/a&gt; for security implications in particular.</source>
          <target state="translated">Unicode是一种新的复杂技术，可以轻易忽略某些安全隐患。见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;的概述和&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;的详细信息，并&lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;在perlunicode&amp;ldquo;的Unicode的安全隐患&amp;rdquo;&lt;/a&gt;的特别安全的影响。</target>
        </trans-unit>
        <trans-unit id="38d8bac67762b71e3e301bd389dd5bf647e3a7f7" translate="yes" xml:space="preserve">
          <source>Unicode is a new and complex technology and one may easily overlook certain security pitfalls. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; for an overview and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details, and &lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;Security Implications of Unicode in perlunicode&lt;/a&gt; for security implications in particular.</source>
          <target state="translated">Unicode是一种新的复杂技术，可以轻易忽略某些安全隐患。见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;的概述和&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;的细节，并&lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;在perlunicode统一的安全隐患&lt;/a&gt;特别是对于安全隐患。</target>
        </trans-unit>
        <trans-unit id="2819bd58737a8580070f8ba307d9387529fe1cef" translate="yes" xml:space="preserve">
          <source>Unicode is encoded using several competing encodings, of which UTF-8 is the most used. In a Unicode encoding, multiple subsequent bytes can be used to store a single code point, or simply: character.</source>
          <target state="translated">Unicode使用几种相互竞争的编码,其中UTF-8是使用最多的编码。在Unicode编码中,可以用多个后续字节来存储一个码点,或者干脆说:字符。</target>
        </trans-unit>
        <trans-unit id="eebcf5b59ea874094c8b9d89a4f67a602ded5273" translate="yes" xml:space="preserve">
          <source>Unicode is stored in &lt;code&gt;$oswBuffer&lt;/code&gt;. &lt;code&gt;$lwBufSize&lt;/code&gt; and &lt;code&gt;$olwOutLength&lt;/code&gt; are measured as number of &lt;code&gt;WCHAR&lt;/code&gt;s.</source>
          <target state="translated">Unicode存储在 &lt;code&gt;$oswBuffer&lt;/code&gt; 。 &lt;code&gt;$lwBufSize&lt;/code&gt; 和 &lt;code&gt;$olwOutLength&lt;/code&gt; 以 &lt;code&gt;WCHAR&lt;/code&gt; 的数量进行度量。</target>
        </trans-unit>
        <trans-unit id="5a66fde7942a6271294a3a5979cbe3017c3d5acd" translate="yes" xml:space="preserve">
          <source>Unicode is supported on EBCDIC platforms. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;.</source>
          <target state="translated">EBCDIC平台支持Unicode。参见&lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9649076a02c41263127b2e79657012b62bed018f" translate="yes" xml:space="preserve">
          <source>Unicode non-character U+%X is not recommended for open interchange</source>
          <target state="translated">不建议在开放交换中使用U+%X非字符。</target>
        </trans-unit>
        <trans-unit id="4276af257ec826541933ef5d517bc7bb403fdca7" translate="yes" xml:space="preserve">
          <source>Unicode only allows code points up to 0x10FFFF, but Perl allows much larger ones. Up till Perl 5.28, it was allowed to use code points exceeding the maximum value of an integer (&lt;code&gt;IV_MAX&lt;/code&gt;). However, that did break the perl interpreter in some constructs, including causing it to hang in a few cases. The known problem areas were in &lt;code&gt;tr///&lt;/code&gt;, regular expression pattern matching using quantifiers, as quote delimiters in &lt;code&gt;q&lt;i&gt;X&lt;/i&gt;...&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; (where</source>
          <target state="translated">Unicode只允许最大0x10FFFF的代码点，但是Perl允许更大的代码点。直到Perl 5.28，才允许使用超过整数最大值（ &lt;code&gt;IV_MAX&lt;/code&gt; ）的代码点。但是，这确实在某些构造中破坏了perl解释器，包括在某些情况下导致其挂起。已知问题区域在 &lt;code&gt;tr///&lt;/code&gt; ，使用量词的正则表达式模式匹配，作为 &lt;code&gt;q&lt;i&gt;X&lt;/i&gt;...&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 引号定界符（其中</target>
        </trans-unit>
        <trans-unit id="989d0062ad097f9dec3fa95782856724eb6165aa" translate="yes" xml:space="preserve">
          <source>Unicode promises that the set of code points that have these two properties will never change, so something that is not quoted in v5.16 will never need to be quoted in any future Perl release. (Not all the code points that match Pattern_Syntax have actually had characters assigned to them; so there is room to grow, but they are quoted whether assigned or not. Perl, of course, would never use an unassigned code point as an actual metacharacter.)</source>
          <target state="translated">Unicode 承诺,具有这两个属性的代码点集永远不会改变,所以在 v5.16 中没有被引用的东西在未来的任何 Perl 版本中都不需要被引用。(并不是所有与 Pattern_Syntax 匹配的代码点实际上都已经被分配了字符;所以还有增长的空间,但无论是否被分配,它们都会被引用。当然,Perl永远不会将一个未分配的代码点作为一个实际的元字符使用)。)</target>
        </trans-unit>
        <trans-unit id="fb2ca4e28ea7e22cfa06c89ba6c3b93dca994a19" translate="yes" xml:space="preserve">
          <source>Unicode properties are defined (surprise!) only on Unicode code points. Starting in v5.20, when matching against &lt;code&gt;\p&lt;/code&gt; and &lt;code&gt;\P&lt;/code&gt; , Perl treats non-Unicode code points (those above the legal Unicode maximum of 0x10FFFF) as if they were typical unassigned Unicode code points.</source>
          <target state="translated">Unicode属性仅在Unicode代码点上定义（惊奇！）。从v5.20开始，当与 &lt;code&gt;\p&lt;/code&gt; 和 &lt;code&gt;\P&lt;/code&gt; 匹配时，Perl会将非Unicode代码点（高于合法Unicode最大值0x10FFFF的代码点）视为典型的未分配Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="a1b191780dd618f1a1adb03d6a73e2206a215bac" translate="yes" xml:space="preserve">
          <source>Unicode properties are defined (surprise!) only on Unicode code points. Starting in v5.20, when matching against &lt;code&gt;\p&lt;/code&gt; and &lt;code&gt;\P&lt;/code&gt;, Perl treats non-Unicode code points (those above the legal Unicode maximum of 0x10FFFF) as if they were typical unassigned Unicode code points.</source>
          <target state="translated">Unicode属性仅在Unicode代码点上定义（惊奇！）。从v5.20开始，当与 &lt;code&gt;\p&lt;/code&gt; 和 &lt;code&gt;\P&lt;/code&gt; 匹配时，Perl会将非Unicode代码点（高于合法Unicode最大值0x10FFFF的代码点）视为典型的未分配Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="4421ab9f1aa61dc9cbda1e9f59175c1a3635d1e0" translate="yes" xml:space="preserve">
          <source>Unicode property wildcard not terminated</source>
          <target state="translated">未终止的Unicode属性通配符</target>
        </trans-unit>
        <trans-unit id="139a9bb1fddefbaa23b5411336f2d45c5af1add3" translate="yes" xml:space="preserve">
          <source>Unicode publishes the names of blocks in two different styles, though the two are equivalent under Unicode's loose matching rules.</source>
          <target state="translated">Unicode以两种不同的风格发布区块的名称,不过在Unicode宽松的匹配规则下,两者是等价的。</target>
        </trans-unit>
        <trans-unit id="38ecc57a7a45e8fa0530ba908225186656979efa" translate="yes" xml:space="preserve">
          <source>Unicode rules are used for the case change.</source>
          <target state="translated">箱体变化采用Unicode规则。</target>
        </trans-unit>
        <trans-unit id="1b41da839119c4860ed2bab536f19149822ad0f7" translate="yes" xml:space="preserve">
          <source>Unicode string</source>
          <target state="translated">统一码字符串</target>
        </trans-unit>
        <trans-unit id="f63eb0aa495029030f8880e8159d4eda857dd8ed" translate="yes" xml:space="preserve">
          <source>Unicode string properties are not implemented in (?[...]) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">Unicode字符串属性未在正则表达式（？[...]）中实现；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="7088ba3066aa65d6bcc96771fbb92a42fd96dcd6" translate="yes" xml:space="preserve">
          <source>Unicode support is an extensive requirement. While Perl does not implement the Unicode standard or the accompanying technical reports from cover to cover, Perl does support many Unicode features.</source>
          <target state="translated">支持Unicode是一项广泛的要求。虽然Perl没有从头到尾实施Unicode标准或附带的技术报告,但Perl确实支持许多Unicode功能。</target>
        </trans-unit>
        <trans-unit id="92c5fb67050f7cc6a07c62ea0f43698241d0a5b2" translate="yes" xml:space="preserve">
          <source>Unicode surrogate U+%X is illegal in UTF-8</source>
          <target state="translated">在UTF-8中,U+%X是非法的。</target>
        </trans-unit>
        <trans-unit id="b8b243e5f3e426dd36737b42e29d2ec9970a7c1a" translate="yes" xml:space="preserve">
          <source>Unicode, of course, assigns each of those code points a particular meaning (along with ones above 255). To preserve backward compatibility, Perl only uses the Unicode meanings when there is some indication that Unicode is what is intended; otherwise the non-ASCII code points remain treated as if they are unassigned.</source>
          <target state="translated">当然,Unicode 会给这些代码点分配一个特定的含义(以及 255 以上的代码点)。为了保持向后的兼容性,Perl只在有某种迹象表明Unicode是其目的时才使用Unicode的含义;否则,非ASCII码点仍被当作未分配的码点处理。</target>
        </trans-unit>
        <trans-unit id="21276899f4cb4b0159879360c7526c4fe6c28316" translate="yes" xml:space="preserve">
          <source>Unicode/Collate</source>
          <target state="translated">Unicode/Collate</target>
        </trans-unit>
        <trans-unit id="37148638183749a1c0b03d85014634d4e43c64c4" translate="yes" xml:space="preserve">
          <source>Unicode/Collate/Foo.txt</source>
          <target state="translated">Unicode/Collate/Foo.txt</target>
        </trans-unit>
        <trans-unit id="f77e952a14d870cb3ae7b18f391e8c5f3d325575" translate="yes" xml:space="preserve">
          <source>Unicode::Collate</source>
          <target state="translated">Unicode::Collate</target>
        </trans-unit>
        <trans-unit id="3ff519c896603d01c9e76e4f19191f11d112327a" translate="yes" xml:space="preserve">
          <source>Unicode::Collate - Unicode Collation Algorithm</source>
          <target state="translated">Unicode::Collate-统一码整理算法</target>
        </trans-unit>
        <trans-unit id="fdf0d75274a879104b0f1f8bc64ee18ff02c5b30" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Big5</source>
          <target state="translated">Unicode::Collate::CJK::Big5</target>
        </trans-unit>
        <trans-unit id="1d6f6aa49ee6fad5eca6f35948b7e1bb0ab65190" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Big5 - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="translated">Unicode::Collate::CJK::Big5-为Unicode::Collate的中日韩统一表意文字加权。</target>
        </trans-unit>
        <trans-unit id="5df783cdcff877161e1582e96c9fee058c8ac391" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::GB2312</source>
          <target state="translated">Unicode::Collate::CJK::GB2312</target>
        </trans-unit>
        <trans-unit id="69f6a1af4b9d7847bba5939a34148141b098e758" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::GB2312 - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="translated">Unicode::Collate::CJK::GB2312-为Unicode::Collate加权中日韩统一表意文字。</target>
        </trans-unit>
        <trans-unit id="6a120ddf4b189ce790913ac61694171437406f3d" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::JISX0208</source>
          <target state="translated">Unicode::Collate::CJK::JISX0208</target>
        </trans-unit>
        <trans-unit id="52137c04544cacc73939ff1aee0c874c9d8fee08" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::JISX0208 - weighting JIS KANJI for Unicode::Collate</source>
          <target state="translated">Unicode::Collate::CJK::JISX0208-Unicode::Collate的JIS KANJI加权。</target>
        </trans-unit>
        <trans-unit id="522cc80239808b956014178ec75f366b2cd491f0" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Korean</source>
          <target state="translated">Unicode::Collate::CJK::Korean</target>
        </trans-unit>
        <trans-unit id="0ac8b48e92e15bda76c4fcc728f48f96352b283f" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Korean - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="translated">Unicode::Collate::CJK::Korean-Unicode::Collate的中日韩统一表意文字的加权。</target>
        </trans-unit>
        <trans-unit id="19c59af510fe79c64655e756d8461e5d375c2fd6" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Pinyin</source>
          <target state="translated">Unicode::Collate::CJK::Pinyin</target>
        </trans-unit>
        <trans-unit id="42747836215aeadf69f9c614290fca82880640f7" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Pinyin - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="translated">Unicode::Collate::CJK::拼音-为Unicode::Collate加权中日韩统一表意文字。</target>
        </trans-unit>
        <trans-unit id="119a4f4d104376889a668529add1217787695cd3" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Stroke</source>
          <target state="translated">Unicode::Collate::CJK::Stroke</target>
        </trans-unit>
        <trans-unit id="f4760535296459fcd8959501743735349df70437" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Stroke - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="translated">Unicode::Collate::CJK::Stroke-Unicode::Collate的中日韩统一表意文字的加权。</target>
        </trans-unit>
        <trans-unit id="935469afe79a7967133cbd5dc7a19cf8e8b7b28e" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Zhuyin</source>
          <target state="translated">Unicode::Collate::CJK::Zhuyin</target>
        </trans-unit>
        <trans-unit id="6bf20cf45b8ff713b3a40392be9d33f596934776" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Zhuyin - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="translated">Unicode::Collate::CJK::Zhuyin-为Unicode::Collate加权中日韩统一表意文字。</target>
        </trans-unit>
        <trans-unit id="1a163e245e5c3cf99dc2f5ab882390d17947426d" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::Locale</source>
          <target state="translated">Unicode::Collate::Locale</target>
        </trans-unit>
        <trans-unit id="001480054455d7b56706418239469b08b55ae695" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::Locale - Linguistic tailoring for DUCET via Unicode::Collate</source>
          <target state="translated">Unicode::Collate::Locale-通过Unicode::Collate为DUCET量身定做语言。</target>
        </trans-unit>
        <trans-unit id="72b47eca97eb095d02921b6571fab1a6dfdb0bc0" translate="yes" xml:space="preserve">
          <source>Unicode::Normalize</source>
          <target state="translated">Unicode::Normalize</target>
        </trans-unit>
        <trans-unit id="2e61bd2963848230702b059b3f915c279424ceeb" translate="yes" xml:space="preserve">
          <source>Unicode::Normalize - Unicode Normalization Forms</source>
          <target state="translated">Unicode::normalize-Unicode规范化表格</target>
        </trans-unit>
        <trans-unit id="58e1ebb138145877210bc1aaddb6a695f639333f" translate="yes" xml:space="preserve">
          <source>Unicode::UCD</source>
          <target state="translated">Unicode::UCD</target>
        </trans-unit>
        <trans-unit id="878eb3fe5907f3dbbef3993a9d210c838c3bd0a6" translate="yes" xml:space="preserve">
          <source>Unicode::UCD - Unicode character database</source>
          <target state="translated">Unicode::UCD-Unicode字符数据库</target>
        </trans-unit>
        <trans-unit id="b0e10771734c32d2d9e8385457afb6c4bd746163" translate="yes" xml:space="preserve">
          <source>Unicode::UCD::UnicodeVersion</source>
          <target state="translated">Unicode::UCD::UnicodeVersion</target>
        </trans-unit>
        <trans-unit id="1147d047b52e119e77fa52566535f97fa00f2d54" translate="yes" xml:space="preserve">
          <source>Unified method to both set and get options in the &lt;code&gt;SOL_SOCKET&lt;/code&gt; level. If called with one argument then &lt;a href=&quot;IO::Socket#getsockopt&quot;&gt;&quot;getsockopt&quot; in IO::Socket&lt;/a&gt; is called, otherwise &lt;a href=&quot;IO::Socket#setsockopt&quot;&gt;&quot;setsockopt&quot; in IO::Socket&lt;/a&gt; is called.</source>
          <target state="translated">设置和获取 &lt;code&gt;SOL_SOCKET&lt;/code&gt; 级别选项的统一方法。如果使用一个参数调用，则调用&lt;a href=&quot;IO::Socket#getsockopt&quot;&gt;IO :: Socket中的&amp;ldquo; getsockopt&amp;rdquo;&lt;/a&gt;，否则调用IO :: Socket中的&lt;a href=&quot;IO::Socket#setsockopt&quot;&gt;&amp;ldquo; setsockopt&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c884d01b9429a9f7304a835d13687b8ca5872d3c" translate="yes" xml:space="preserve">
          <source>Unified method to both set and get options in the SOL_SOCKET level. If called with one argument then getsockopt is called, otherwise setsockopt is called.</source>
          <target state="translated">在SOL_SOCKET层中设置和获取选项的统一方法,如果调用一个参数,则调用getockopt,否则调用setockopt。如果用一个参数调用,则调用getockopt,否则调用setockopt。</target>
        </trans-unit>
        <trans-unit id="238642af65f3add9fa062158d9a8954a0d8cc5fc" translate="yes" xml:space="preserve">
          <source>Unimplemented, but you can use &lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; and the &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module to achieve similar things.</source>
          <target state="translated">未实现，但是您可以使用&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;和&lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt;模块来实现类似的功能。</target>
        </trans-unit>
        <trans-unit id="e6507a9fbb8009ec64673ec8cd6b7aa40be844fe" translate="yes" xml:space="preserve">
          <source>Unimplemented, but you can use &lt;a href=&quot;perlfunc#die&quot;&gt;&quot;die&quot; in perlfunc&lt;/a&gt; and the &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module to achieve similar things.</source>
          <target state="translated">未实现，但是您可以&lt;a href=&quot;perlfunc#die&quot;&gt;在perlfunc&lt;/a&gt;和&lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt;模块中使用&amp;ldquo; die&amp;rdquo;来实现类似的功能。</target>
        </trans-unit>
        <trans-unit id="afec59d2cbb0d42662480e51b0e7e50584f1e2e5" translate="yes" xml:space="preserve">
          <source>Unimplemented, except on Windows, due to the vagaries of vendor locale names, returning &lt;code&gt;&quot;&quot;&lt;/code&gt; on non-Windows.</source>
          <target state="translated">由于供应商语言环境名称不固定，因此未实现（Windows除外），在非Windows上返回 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e456a7d2242bb697d1c62ca28710a65f1b354e3" translate="yes" xml:space="preserve">
          <source>Unimplemented, so returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">未实现，因此返回 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9769121f10f77079b27eb08e9ffa488cbcc37ed0" translate="yes" xml:space="preserve">
          <source>United Kingdom</source>
          <target state="translated">联合王国</target>
        </trans-unit>
        <trans-unit id="768685ca582abd0af2fbb57ca37752aa98c9372b" translate="yes" xml:space="preserve">
          <source>United States</source>
          <target state="translated">美国</target>
        </trans-unit>
        <trans-unit id="c6635fe323dcba6e8b8b2d5cdbb340361ce906ed" translate="yes" xml:space="preserve">
          <source>Universal Binary support</source>
          <target state="translated">支持通用二进制</target>
        </trans-unit>
        <trans-unit id="a1a652fb80ef2238fc4c5e10930af87b4f3aac30" translate="yes" xml:space="preserve">
          <source>Universal Character Set</source>
          <target state="translated">通用字符集</target>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="2fb49d2b5adcca8ced12a532099ac9adce5647b1" translate="yes" xml:space="preserve">
          <source>Unix Network Programming, 2nd Edition, Volume 1</source>
          <target state="translated">Unix网络编程第2版第1卷</target>
        </trans-unit>
        <trans-unit id="b4c5506923f63fcc0ec2a3603b475130b23382af" translate="yes" xml:space="preserve">
          <source>Unix Review</source>
          <target state="translated">Unix评论</target>
        </trans-unit>
        <trans-unit id="4b39a128140df62988dc25aafca006880dd71ad2" translate="yes" xml:space="preserve">
          <source>Unix has no need of special linker flags.</source>
          <target state="translated">Unix不需要特殊的链接器标志。</target>
        </trans-unit>
        <trans-unit id="4547b2fe2a8711e2250c90726e47d0a32f9e7c0b" translate="yes" xml:space="preserve">
          <source>Unix style shell macros like &lt;code&gt;$(abcd)&lt;/code&gt; are passed through instead of being converted to &lt;code&gt;$^(abcd^)&lt;/code&gt; independent of the &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; feature setting. Unix style shell macros should not use characters that are not in the ASCII character set, as the resulting specification may or may not be still in UTF8 format.</source>
          <target state="translated">像 &lt;code&gt;$(abcd)&lt;/code&gt; 这样的Unix风格的shell宏将通过传递，而不是独立于 &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; 功能设置而转换为 &lt;code&gt;$^(abcd^)&lt;/code&gt; 。Unix样式的外壳宏不应使用不在ASCII字符集中的字符，因为生成的规范可能仍然是UTF8格式，也可能不是。</target>
        </trans-unit>
        <trans-unit id="faa3f11d873bf24fcae352a27226c0c2e88d087f" translate="yes" xml:space="preserve">
          <source>Unix's &lt;code&gt;#!&lt;/code&gt; technique can be simulated on other systems:</source>
          <target state="translated">Unix的 &lt;code&gt;#!&lt;/code&gt; 可以在其他系统上模拟该技术：</target>
        </trans-unit>
        <trans-unit id="7f87c004392cd89a556aff5f86328de12b9ca773" translate="yes" xml:space="preserve">
          <source>Unix-Domain TCP Clients and Servers</source>
          <target state="translated">Unix-Domain TCP客户端和服务器</target>
        </trans-unit>
        <trans-unit id="4acfa258fe45e38658aa00a5dfda8b8abeddb8cc" translate="yes" xml:space="preserve">
          <source>Unix-domain sockets on OS/2 live in a pseudo-file-system &lt;code&gt;/sockets/...&lt;/code&gt; . To avoid a failure to create a socket with a name of a different form, &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; is prepended to the socket name (unless it starts with this already).</source>
          <target state="translated">OS / 2上的Unix域套接字位于伪文件系统 &lt;code&gt;/sockets/...&lt;/code&gt; 中。为避免创建具有不同格式名称的套接字失败，请在套接字名称之前加上 &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; （除非它已经以此开头）。</target>
        </trans-unit>
        <trans-unit id="35779ed7c2718c03c2a679cc689368ba373e9248" translate="yes" xml:space="preserve">
          <source>Unix-domain sockets on OS/2 live in a pseudo-file-system &lt;code&gt;/sockets/...&lt;/code&gt;. To avoid a failure to create a socket with a name of a different form, &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; is prepended to the socket name (unless it starts with this already).</source>
          <target state="translated">OS / 2上的Unix域套接字位于伪文件系统 &lt;code&gt;/sockets/...&lt;/code&gt; 中。为避免创建具有不同格式名称的套接字失败，请在套接字名称之前加上 &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; （除非它已经以此开头）。</target>
        </trans-unit>
        <trans-unit id="4f3c45c8b86738464ace2f8005c8fbdecfe76366" translate="yes" xml:space="preserve">
          <source>Unix.U</source>
          <target state="translated">Unix.U</target>
        </trans-unit>
        <trans-unit id="bc7819b34ff87570745fbe461e36a16f80e562ce" translate="yes" xml:space="preserve">
          <source>Unknown</source>
          <target state="translated">Unknown</target>
        </trans-unit>
        <trans-unit id="a8b5e7a7d509a7c62d93ee2bad1c35496336638f" translate="yes" xml:space="preserve">
          <source>Unknown &quot;re&quot; subpragma '%s' (known ones are: %s)</source>
          <target state="translated">未知的 &quot;re &quot;子项'%s'(已知的有:%s)。</target>
        </trans-unit>
        <trans-unit id="ae6c175629d52f8caa8d90709840d842ec6a24a8" translate="yes" xml:space="preserve">
          <source>Unknown &amp;lt;unknown@example.com&amp;gt;</source>
          <target state="translated">未知&amp;lt;unknown@example.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4260834064ed4da863200d4ab98727ee77cc0db4" translate="yes" xml:space="preserve">
          <source>Unknown '(*...)' construct '%s' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中未知的（（* ...））构造'％s'; 以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="516d733c8bf9db439f1f86408315d55784a8e43c" translate="yes" xml:space="preserve">
          <source>Unknown '=xxxx' commands, unknown 'X&amp;lt;...&amp;gt;' interior-sequences, and unterminated interior sequences.</source>
          <target state="translated">未知的'= xxxx'命令，未知的'X &amp;lt;...&amp;gt;'内部序列和未终止的内部序列。</target>
        </trans-unit>
        <trans-unit id="0c7f616921e8aa6ce31483dac2c125041fa7ff10" translate="yes" xml:space="preserve">
          <source>Unknown E content in E&amp;lt;</source>
          <target state="translated">E &amp;lt;中的未知E含量</target>
        </trans-unit>
        <trans-unit id="b452be528de2ca72fbdca17c8a6b9000bd72960e" translate="yes" xml:space="preserve">
          <source>Unknown PerlIO layer &quot;%s&quot;</source>
          <target state="translated">未知PerlIO层&quot;%s&quot;</target>
        </trans-unit>
        <trans-unit id="bcc9d502ba9bb87ff9a938ae6d50ef1785f93443" translate="yes" xml:space="preserve">
          <source>Unknown Unicode option letter '%c'</source>
          <target state="translated">未知Unicode选项字母'%c'。</target>
        </trans-unit>
        <trans-unit id="b383a6c76e59091add963d05eca879c2155929c3" translate="yes" xml:space="preserve">
          <source>Unknown Unicode option value %d</source>
          <target state="translated">未知Unicode选项值%d</target>
        </trans-unit>
        <trans-unit id="63b64d99361c84dd2b785abb8dd250103d6a822f" translate="yes" xml:space="preserve">
          <source>Unknown charname '%s'</source>
          <target state="translated">未知字符名'%s'</target>
        </trans-unit>
        <trans-unit id="4f8c284e5307746cdeea5551e2520dce4836d73d" translate="yes" xml:space="preserve">
          <source>Unknown directive:</source>
          <target state="translated">指令不明。</target>
        </trans-unit>
        <trans-unit id="e5fd9aa24c9417e7332e6f25936ae2a6ec8f1524" translate="yes" xml:space="preserve">
          <source>Unknown error</source>
          <target state="translated">不明错误</target>
        </trans-unit>
        <trans-unit id="2ebda19c79ae8fdc09d9f934173a9e0b1dda8ac2" translate="yes" xml:space="preserve">
          <source>Unknown locale category %d; can't set it to %s</source>
          <target state="translated">未知区域类别%d;无法设置为%s。</target>
        </trans-unit>
        <trans-unit id="17e9349b86ed14bdbc36e717e0e54a45178a5709" translate="yes" xml:space="preserve">
          <source>Unknown open() mode '%s'</source>
          <target state="translated">未知open()模式'%s'</target>
        </trans-unit>
        <trans-unit id="7a9ce623a0a054e7c503d1bead726383200a08d0" translate="yes" xml:space="preserve">
          <source>Unknown option: %s</source>
          <target state="translated">未知选项:%s</target>
        </trans-unit>
        <trans-unit id="94063b188637c4358408514f0dec4be5138069da" translate="yes" xml:space="preserve">
          <source>Unknown process %x sent message to prime_env_iter: %s</source>
          <target state="translated">未知进程%x向prime_env_iter发送消息:%s。</target>
        </trans-unit>
        <trans-unit id="5a27728149a20fa874d8e5d6ec5784571e435f85" translate="yes" xml:space="preserve">
          <source>Unknown regexp modifier &quot;/%s&quot;</source>
          <target state="translated">未知的regexp修改器&quot;/%s&quot;</target>
        </trans-unit>
        <trans-unit id="48c5c163aa1fa71615dee0d3c90ca77bf54723d6" translate="yes" xml:space="preserve">
          <source>Unknown result token.</source>
          <target state="translated">未知的结果令牌。</target>
        </trans-unit>
        <trans-unit id="5362b9dbff55eae528c95c41a9cdfba23a42b91e" translate="yes" xml:space="preserve">
          <source>Unknown switch condition (?(...)) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中未知的开关条件（？（...））; 以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="cc278b1f69a68c5fa1706993032fe0bce8d046fa" translate="yes" xml:space="preserve">
          <source>Unknown verb pattern '%s' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中未知的动词模式'％s'；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="faa3d10b86eac319b820b63f583e0a0a896d21a3" translate="yes" xml:space="preserve">
          <source>Unknown warnings category '%s'</source>
          <target state="translated">未知警告类别&quot;%s</target>
        </trans-unit>
        <trans-unit id="4013e411624fa8892f8200feafb69475d2458d0b" translate="yes" xml:space="preserve">
          <source>Unknowns are &lt;code&gt;&quot;-&quot;&lt;/code&gt; . Unknowns can happen unfortunately quite easily: if the platform doesn't support retrieving the information; if the binary is missing the debug information; if the optimizer has transformed the code by for example inlining.</source>
          <target state="translated">未知的是 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 。不幸的是，未知事件很容易发生：如果平台不支持检索信息；如果二进制文件缺少调试信息；如果优化程序通过内联等方式转换了代码。</target>
        </trans-unit>
        <trans-unit id="e246db88408875913f8b8fd552f45cc3814a8897" translate="yes" xml:space="preserve">
          <source>Unknowns are &lt;code&gt;&quot;-&quot;&lt;/code&gt;. Unknowns can happen unfortunately quite easily: if the platform doesn't support retrieving the information; if the binary is missing the debug information; if the optimizer has transformed the code by for example inlining.</source>
          <target state="translated">未知的是 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 。不幸的是，未知事件很容易发生：如果平台不支持检索信息；如果二进制文件缺少调试信息；如果优化程序已通过内联等方式对代码进行了转换。</target>
        </trans-unit>
        <trans-unit id="ce906b20ea9a7a0bf0bcbae85c1c9421e3de60b2" translate="yes" xml:space="preserve">
          <source>Unless %hash has already been locked the key/value could be deleted regardless of this setting.</source>
          <target state="translated">除非%hash已经被锁定,否则不管这个设置如何,钥匙/值都可以被删除。</target>
        </trans-unit>
        <trans-unit id="5c6af5673dc4ae00136df64bec88a6550bf388e5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, the PerlIO layers of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; are set to &quot;&lt;code&gt;:encoding(&lt;i&gt;ENCNAME&lt;/i&gt;)&lt;/code&gt;&quot;. Therefore,</source>
          <target state="translated">除非 &lt;code&gt;${^UNICODE}&lt;/code&gt; （从v5.8.2开始可用）存在并且不为零，否则将 &lt;code&gt;STDIN&lt;/code&gt; 和 &lt;code&gt;STDOUT&lt;/code&gt; 的PerlIO层设置为&amp;ldquo; &lt;code&gt;:encoding(&lt;i&gt;ENCNAME&lt;/i&gt;)&lt;/code&gt; &amp;rdquo;。因此，</target>
        </trans-unit>
        <trans-unit id="d2c8c659e558ac6c6718a8a57a68dcfe5600f320" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; (&lt;code&gt;-Accflags=-DPERL_MEM_LOG_NOIMPL&lt;/code&gt;) is also compiled, the logging functions read $ENV{PERL_MEM_LOG} to determine whether to log the event, and if so how:</source>
          <target state="translated">除非还编译了 &lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; （ &lt;code&gt;-Accflags=-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; ），否则日志记录功能将读取$ ENV {PERL_MEM_LOG}以确定是否记录该事件，以及如何记录该事件：</target>
        </trans-unit>
        <trans-unit id="c4a238cf9ea26a0e7ddfda497c5bf0d771bd8656" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; is also compiled, the logging functions read $ENV{PERL_MEM_LOG} to determine whether to log the event, and if so how:</source>
          <target state="translated">除非还编译了 &lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; ，否则日志记录功能将读取$ ENV {PERL_MEM_LOG}以确定是否记录该事件，以及如何记录该事件：</target>
        </trans-unit>
        <trans-unit id="7183c27cf3fecde6bcc64c00a3a891d43f73c77b" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; is set to &lt;code&gt;T&lt;/code&gt; (and the kernel is after 2000/09/01), such DLLs are considered to be global. When loading a global DLL it is first looked in the table of already-loaded global DLLs. Because of this the fact that one executable loaded a DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; and &lt;code&gt;ENDLIBPATH&lt;/code&gt; , or</source>
          <target state="translated">除非 &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; 设置为 &lt;code&gt;T&lt;/code&gt; （并且内核在2000/09/01之后），否则此类DLL被视为全局的。加载全局DLL时，首先在已加载的全局DLL表中查找。因此，一个可执行文件从 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 和 &lt;code&gt;ENDLIBPATH&lt;/code&gt; 加载了一个DLL ，或者</target>
        </trans-unit>
        <trans-unit id="a9d2404af2307482983ff6743f035f7118e9d8f6" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; is set to &lt;code&gt;T&lt;/code&gt; (and the kernel is after 2000/09/01), such DLLs are considered to be global. When loading a global DLL it is first looked in the table of already-loaded global DLLs. Because of this the fact that one executable loaded a DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; and &lt;code&gt;ENDLIBPATH&lt;/code&gt;, or</source>
          <target state="translated">除非 &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; 设置为 &lt;code&gt;T&lt;/code&gt; （并且内核在2000/09/01之后），否则此类DLL被认为是全局的。加载全局DLL时，首先在已加载的全局DLL表中查找。因此，一个可执行文件从 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 和 &lt;code&gt;ENDLIBPATH&lt;/code&gt; 加载了一个DLL ，或者</target>
        </trans-unit>
        <trans-unit id="4244b98dff2bf774775c08e4df5afb2e645e4b77" translate="yes" xml:space="preserve">
          <source>Unless ASCII vs. EBCDIC issues are specifically being discussed, references to UTF-8 encoding in this document and elsewhere should be read as meaning UTF-EBCDIC on EBCDIC platforms. See &lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;&quot;Unicode and UTF&quot; in perlebcdic&lt;/a&gt;.</source>
          <target state="translated">除非特别讨论了ASCII与EBCDIC的问题，否则本文档和其他地方对UTF-8编码的引用应理解为EBCDIC平台上的UTF-EBCDIC。请参阅&lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;perlebcdic中的&amp;ldquo; Unicode和UTF&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="025ed2d87cd53899da043f16934d54b56cb767cf" translate="yes" xml:space="preserve">
          <source>Unless ASCII vs. EBCDIC issues are specifically being discussed, references to UTF-8 encoding in this document and elsewhere should be read as meaning UTF-EBCDIC on EBCDIC platforms. See &lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;Unicode and UTF in perlebcdic&lt;/a&gt;.</source>
          <target state="translated">除非特别讨论了ASCII与EBCDIC的问题，否则本文档和其他地方对UTF-8编码的引用应理解为EBCDIC平台上的UTF-EBCDIC。请参阅&lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;perlebcdic中的Unicode和UTF&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="763e516abf0169c17797549989072db7b3b436d9" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, functions return 0 on success, or a negative value (usually &lt;code&gt;EOF&lt;/code&gt; which is usually -1) and set &lt;code&gt;errno&lt;/code&gt; on error.</source>
          <target state="translated">除非另有说明，否则函数在成功时返回0，或者返回负值（通常 &lt;code&gt;EOF&lt;/code&gt; 通常为-1），并在错误时设置 &lt;code&gt;errno&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="843ebacc41e4317d9c7bf3f947fad475a9e1f11b" translate="yes" xml:space="preserve">
          <source>Unless otherwise notes, all examples below require this standard preamble to work correctly, with the &lt;code&gt;#!&lt;/code&gt; adjusted to work on your system:</source>
          <target state="translated">除非另有说明，否则以下所有示例均要求此标准序言才能正确使用 &lt;code&gt;#!&lt;/code&gt; 。调整以在您的系统上工作：</target>
        </trans-unit>
        <trans-unit id="a1410ee8e42e843fa403d9edd63361088b53c82a" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, version numbers &lt;b&gt;must&lt;/b&gt; appear in one of two formats:</source>
          <target state="translated">除非另有说明，否则版本号&lt;b&gt;必须&lt;/b&gt;以以下两种格式之一显示：</target>
        </trans-unit>
        <trans-unit id="519ecd12b4838877006c606ab377c9933076da06" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated all methods return either a</source>
          <target state="translated">除非另有说明,否则所有方法都返回一个</target>
        </trans-unit>
        <trans-unit id="58c869a304e00ffd24d619f7d44db8d57f44a80c" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated it works just like ExtUtils::MM_Unix</source>
          <target state="translated">除非另有说明,否则它的工作原理和ExtUtils::MM_Unix一样。</target>
        </trans-unit>
        <trans-unit id="ae0b84fa2af86714bff9b9ce409d73281e7852b8" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated it works just like ExtUtils::MM_Unix.</source>
          <target state="translated">除非另有说明,否则它的工作原理和ExtUtils::MM_Unix一样。</target>
        </trans-unit>
        <trans-unit id="caa9da45012bfbe0b5378d58f4fff0a9abfa58b5" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, it works just like ExtUtils::MM_Unix</source>
          <target state="translated">除非另有说明,否则它的工作原理和ExtUtils::MM_Unix一样。</target>
        </trans-unit>
        <trans-unit id="495362fe83affb77b166fe352e049869ffdf5946" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, it works just like ExtUtils::MM_Unix.</source>
          <target state="translated">除非另有说明,否则它的工作原理和ExtUtils::MM_Unix一样。</target>
        </trans-unit>
        <trans-unit id="42e400a7ab19dec964d9377da14546fab4feb3ec" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;anyinflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;anyinflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="47a707f463b0bb3f1b25444c520600dbd6696505" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;anyuncompress&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;anyuncompress&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="d669d839575081392547a5a9cafaedbd09bec28c" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;bunzip2&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;bunzip2&lt;/code&gt; 命令， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="5cd0d3bee7135d518d8ccc595535d8b3eccde37f" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;bzip2&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;bzip2&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="2d2f8a94031befaa66720968f47bd4dde9da6fcf" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;deflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;deflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="f180e51799fa543d0272bd825b3d860097f806c2" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;gunzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;gunzip&lt;/code&gt; 解， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="43b54de84f56f9f511018d58087cdd33377321ec" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;gzip&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="d8c0791fbf600370c86e6ae040e4b2abd896e9ba" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;inflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;inflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="e65e4b1379d48c357409defc2e3a088bfcc64051" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;rawdeflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数为 &lt;code&gt;rawdeflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="f9aa434ca385a7cef6abc358c51e5f3189796565" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;rawinflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数为 &lt;code&gt;rawinflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="e2285dec1544503fb1e6e19eb0aec81e1f5a9726" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;unzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;unzip&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="f45874d912d180929ebed6cffec516fc7cf2fb97" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;zip&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="871cfac0f7d812719fa8ee355ce0991623ac4e0b" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise all method can be called as class methods, or as object methods. If called as class methods then the &quot;default&quot; object will be used, and if necessary created using the current processes %Config and @INC. See the 'default' option to new() for details.</source>
          <target state="translated">除非另有规定,否则所有的方法都可以作为类方法或对象方法来调用,如果作为类方法来调用,那么将使用 &quot;默认 &quot;对象,必要时使用当前进程%Config和@INC来创建。如果作为类方法调用,那么将使用 &quot;默认 &quot;对象,如果需要的话,将使用当前进程%Config和@INC创建。详见new()的 &quot;默认 &quot;选项。</target>
        </trans-unit>
        <trans-unit id="360b129724fa7c1c8235f3513edf30406e818a7b" translate="yes" xml:space="preserve">
          <source>Unless the &lt;code&gt;/r&lt;/code&gt; option is used, the string specified with &lt;code&gt;=~&lt;/code&gt; must be a scalar variable, an array element, a hash element, or an assignment to one of those; in other words, an lvalue.</source>
          <target state="translated">除非使用 &lt;code&gt;/r&lt;/code&gt; 选项，否则用 &lt;code&gt;=~&lt;/code&gt; 指定的字符串必须是标量变量，数组元素，哈希元素或对其中之一的赋值；换句话说，一个左值。</target>
        </trans-unit>
        <trans-unit id="9ef73743f2ca77d91834c677a3b2a131dd0854b0" translate="yes" xml:space="preserve">
          <source>Unless the above additional feature is enabled, nothing about the backtrace functionality is visible, except for the Perl/XS level.</source>
          <target state="translated">除非启用上述附加功能,否则除了Perl/XS级别外,关于回溯功能的任何内容都不可见。</target>
        </trans-unit>
        <trans-unit id="c2c4cb992d99b0b97748811097f97eea4d2ce81b" translate="yes" xml:space="preserve">
          <source>Unless the operator is an assignment (&lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , etc.), repeat step (1) in respect of the second operand.</source>
          <target state="translated">除非运算符是赋值（ &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; 等），否则请对第二个操作数重复步骤（1）。</target>
        </trans-unit>
        <trans-unit id="05d7e76af21f11f9c892472417201fd8ed4cf910" translate="yes" xml:space="preserve">
          <source>Unless the operator is an assignment (&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, etc.), repeat step (1) in respect of the second operand.</source>
          <target state="translated">除非运算符是赋值（ &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; 等），否则请针对第二个操作数重复步骤（1）。</target>
        </trans-unit>
        <trans-unit id="2c6634c0ddc3b2fcdacf253fa92fd7c8403abaf0" translate="yes" xml:space="preserve">
          <source>Unless the pattern or string are encoded in UTF-8, only ASCII characters can match positively.</source>
          <target state="translated">除非模式或字符串用UTF-8编码,否则只有ASCII字符可以正面匹配。</target>
        </trans-unit>
        <trans-unit id="93f6520e33056598a5ce68e86d15794aa942a8a6" translate="yes" xml:space="preserve">
          <source>Unless they are explicitly specified, the default values for the exit status, verbose level, and output stream to use are determined as follows:</source>
          <target state="translated">除非明确指定它们,否则要使用的退出状态、verbose级别和输出流的默认值如下。</target>
        </trans-unit>
        <trans-unit id="28631a8600ab2d0e4799cb9a021cc0306169b6f9" translate="yes" xml:space="preserve">
          <source>Unless you are accessing the CPAN on your filesystem via a file: URL, CPAN.pm needs to keep the source files it downloads somewhere. Please supply a directory where the downloaded files are to be kept.</source>
          <target state="translated">除非你是通过一个文件来访问你的文件系统中的CPAN:URL,CPAN.pm需要在某个地方保存它下载的源文件。请提供一个保存下载文件的目录。</target>
        </trans-unit>
        <trans-unit id="6b861eac07037b268358d427fce8707b48f9500e" translate="yes" xml:space="preserve">
          <source>Unless you are using the &lt;code&gt;fields&lt;/code&gt; pragma, consider this module discouraged in favor of the lighter-weight &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">除非您使用 &lt;code&gt;fields&lt;/code&gt; pragma，否则建议不要使用此模块，而应使用轻量级的 &lt;code&gt;parent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd40baebc35d8dd113beed64e1b32df4e1666e49" translate="yes" xml:space="preserve">
          <source>Unless you are using the &lt;code&gt;fields&lt;/code&gt; pragma, consider this module discouraged in favor of the lighter-weight &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="translated">除非您使用 &lt;code&gt;fields&lt;/code&gt; pragma，否则建议不要使用此模块，而应使用轻量级的 &lt;code&gt;parent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84f0f4d743460958895c1346a2bcc4ae32486815" translate="yes" xml:space="preserve">
          <source>Unless you don't like the possibility of there being part of your Perl scripts embedded in a database file, this is nothing to worry about.</source>
          <target state="translated">除非你不喜欢你的Perl脚本的一部分被嵌入到数据库文件中,否则这没什么好担心的。</target>
        </trans-unit>
        <trans-unit id="078c8b3d64fda031c2ca3a111adc19b05790c7fb" translate="yes" xml:space="preserve">
          <source>Unless you have a particular reason to use the two-argument form you should use the three-argument form of open() which does not treat any characters in the filename as special.</source>
          <target state="translated">除非你有特别的理由使用两个参数形式,否则你应该使用open()的三个参数形式,它不会将文件名中的任何字符视为特殊字符。</target>
        </trans-unit>
        <trans-unit id="bcd145902080112cd3bd3565e1aa0b2eb6698439" translate="yes" xml:space="preserve">
          <source>Unless you have good reasons for using some other format (for example, a format used within your company), the convention is to name your changelog file &lt;code&gt;Changes&lt;/code&gt; , and to follow the simple format described in &lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Changes::Spec&quot;&gt;CPAN::Changes::Spec&lt;/a&gt;.</source>
          <target state="translated">除非您有充分的理由使用其他格式（例如，公司内部使用的格式），否则约定是将更改日志文件命名为 &lt;code&gt;Changes&lt;/code&gt; ，并遵循&lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Changes::Spec&quot;&gt;CPAN :: Changes :: Spec中&lt;/a&gt;描述的简单格式。</target>
        </trans-unit>
        <trans-unit id="87db3fba7e4f130f44369a6d247e1f97fe2c94e1" translate="yes" xml:space="preserve">
          <source>Unless you have good reasons for using some other format (for example, a format used within your company), the convention is to name your changelog file &lt;code&gt;Changes&lt;/code&gt;, and to follow the simple format described in &lt;a href=&quot;CPAN::Changes::Spec&quot;&gt;CPAN::Changes::Spec&lt;/a&gt;.</source>
          <target state="translated">除非您有充分的理由使用其他格式（例如，公司内部使用的格式），否则约定是将更改日志文件命名为 &lt;code&gt;Changes&lt;/code&gt; ，并遵循&lt;a href=&quot;CPAN::Changes::Spec&quot;&gt;CPAN :: Changes :: Spec中&lt;/a&gt;描述的简单格式。</target>
        </trans-unit>
        <trans-unit id="ba7a1f205e8e2686b0c4b6d39cce725cef83741e" translate="yes" xml:space="preserve">
          <source>Unless you know better, serializing hook should always say:</source>
          <target state="translated">除非你更了解,否则序列化钩子应该总是说。</target>
        </trans-unit>
        <trans-unit id="4f5f76f31b82833340ef52081bb4d0e79eab2cc2" translate="yes" xml:space="preserve">
          <source>Unless you know with 100% certainty that quux() is only ever available for the &quot;Foonix&quot; operating system &lt;b&gt;and&lt;/b&gt; that is available &lt;b&gt;and&lt;/b&gt; correctly working for &lt;b&gt;all&lt;/b&gt; past, present, &lt;b&gt;and&lt;/b&gt; future versions of &quot;Foonix&quot;, the above is very wrong. This is more correct (though still not perfect, because the below is a compile-time check):</source>
          <target state="translated">除非您有100％的确定性知道quux（）仅可用于&amp;ldquo; Foonix&amp;rdquo;操作系统，&lt;b&gt;并且&lt;/b&gt;该版本对于&amp;ldquo; Foonix&amp;rdquo;的&lt;b&gt;所有&lt;/b&gt;过去，现在&lt;b&gt;和&lt;/b&gt;将来的版本均可用&lt;b&gt;且&lt;/b&gt;正确运行，否则上述说法是错误的。这是更正确的（尽管仍然不完美，因为以下是编​​译时检查）：&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="93ff79231a3d36c0c3d8ce3114e701a1baebbf25" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a false value, Pod::Search will recurse into subdirectories of the search directories.</source>
          <target state="translated">除非你把这个属性设置为假值,否则Pod::Search将递归到搜索目录的子目录。</target>
        </trans-unit>
        <trans-unit id="17c62f898b45d3be500e6c39bec8d493a60a2715" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Search will apply Perl-specific heuristics to find the correct module PODs quickly. This attribute's default value is false. You won't normally need to set this to true.</source>
          <target state="translated">除非你把这个属性设置为真,否则Pod::Search将应用Perl特有的启发式方法来快速找到正确的模块POD。这个属性的默认值是false。一般情况下,你不需要将此属性设置为true。</target>
        </trans-unit>
        <trans-unit id="9f9a16887abf4c916f1550cac344cc208f6c0b6b" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Simple::Search will consider only the first file of a given modulename as it looks thru the specified directories; that is, with this option off, if Pod::Simple::Search has seen a &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; already in this search, then it won't bother looking at a &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; later on in that search, because that file is merely a &quot;shadow&quot;. But if you turn on &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt; , then these &quot;shadow&quot; files are inspected too, and are noted in the pathname2podname return hash.</source>
          <target state="translated">除非将此属性设置为真值，否则Pod :: Simple :: Search将仅考虑给定模块名的第一个文件，因为它通过指定目录进行查找；也就是说，关闭此选项后，如果Pod :: Simple :: Search 在此搜索中已经看到了 &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; ，那么以后就不会再 &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; 了。该搜索，因为该文件仅仅是&amp;ldquo;影子&amp;rdquo;。但是，如果打开 &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt; ，那么也会检查这些&amp;ldquo; shadow&amp;rdquo;文件，并在pathname2podname返回哈希中将其记录下来。</target>
        </trans-unit>
        <trans-unit id="4fc995dcd124519ccc18ad86cc265d6cd653065c" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Simple::Search will consider only the first file of a given modulename as it looks thru the specified directories; that is, with this option off, if Pod::Simple::Search has seen a &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; already in this search, then it won't bother looking at a &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; later on in that search, because that file is merely a &quot;shadow&quot;. But if you turn on &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt;, then these &quot;shadow&quot; files are inspected too, and are noted in the pathname2podname return hash.</source>
          <target state="translated">除非您将此属性设置为真值，否则Pod :: Simple :: Search将仅考虑给定模块名的第一个文件，因为它看起来通过指定目录；也就是说，关闭此选项后，如果Pod :: Simple :: Search在此搜索中已经看到了 &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; ，那么以后就不会再 &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; 了。该搜索，因为该文件仅是一个&amp;ldquo;影子&amp;rdquo;。但是，如果打开 &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt; ，那么也会检查这些&amp;ldquo; shadow&amp;rdquo;文件，并在pathname2podname返回哈希中将其记录下来。</target>
        </trans-unit>
        <trans-unit id="fa89971032de2d3d226811c31dc2014b63de305b" translate="yes" xml:space="preserve">
          <source>Unless you want to override the defaults, prefer META_MERGE so as to get the advantage of any future defaults.</source>
          <target state="translated">除非你想覆盖默认值,否则最好选择META_MERGE,这样才能获得未来默认值的优势。</target>
        </trans-unit>
        <trans-unit id="eb83985aa16dab9a13560a8e8f1159fe638efa8b" translate="yes" xml:space="preserve">
          <source>Unless you want to use its advanced features, this is probably all you need to know to use Exporter.</source>
          <target state="translated">除非你想使用它的高级功能,否则这可能是你使用Exporter所需要了解的全部内容。</target>
        </trans-unit>
        <trans-unit id="04c205c66e7bc90d55cfb8afb031ef118a5c83da" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;ve used &lt;code&gt;/a&lt;/code&gt; or &lt;code&gt;/aa&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; matches more than ASCII digits only, but Perl&amp;rsquo;s implicit string-to-number conversion does not current recognize these. Here&amp;rsquo;s how to convert such strings manually.</source>
          <target state="translated">除非您使用 &lt;code&gt;/a&lt;/code&gt; 或 &lt;code&gt;/aa&lt;/code&gt; ，否则 &lt;code&gt;\d&lt;/code&gt; 只能匹配多个ASCII数字，但是Perl的隐式字符串到数字的转换当前无法识别这些数字。这是手动转换此类字符串的方法。</target>
        </trans-unit>
        <trans-unit id="37d04e5bf67a8174972d88089473b77064f2c69b" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;ve used &lt;code&gt;/a&lt;/code&gt; or &lt;code&gt;/aa&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt; matches more than ASCII digits only, but Perl&amp;rsquo;s implicit string-to-number conversion does not current recognize these. Here&amp;rsquo;s how to convert such strings manually.</source>
          <target state="translated">除非您使用 &lt;code&gt;/a&lt;/code&gt; 或 &lt;code&gt;/aa&lt;/code&gt; ，否则 &lt;code&gt;\d&lt;/code&gt; 只能匹配多个ASCII数字，但是Perl的隐式字符串到数字的转换当前无法识别这些数字。这是手动转换此类字符串的方法。</target>
        </trans-unit>
        <trans-unit id="8a9444f4badd85c5a13fe02c22e0706b7a37804d" translate="yes" xml:space="preserve">
          <source>Unless you're writing a new &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, a plugin or subclassing &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="translated">除非您正在编写新的&lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;，插件或&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser的&lt;/a&gt;子类，否则您可能不需要直接使用此模块。</target>
        </trans-unit>
        <trans-unit id="b006759734f26ef71ac954f172bdb96074166b64" translate="yes" xml:space="preserve">
          <source>Unless you're writing a new &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, a plugin, or subclassing &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="translated">除非您正在编写新的&lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;，插件或&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser的&lt;/a&gt;子类，否则您可能不需要直接使用此模块。</target>
        </trans-unit>
        <trans-unit id="5d5045afa1f26fa3558f3707783d1ac5db1ca1f3" translate="yes" xml:space="preserve">
          <source>Unless you're writing a new &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, a plugin or subclassing &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="translated">除非您正在编写新的&lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;，插件或&lt;a href=&quot;../parser&quot;&gt;TAP :: Parser的&lt;/a&gt;子类，否则您可能不需要直接使用此模块。</target>
        </trans-unit>
        <trans-unit id="83a68b50b49a806ff511080c423ef60589d29433" translate="yes" xml:space="preserve">
          <source>Unless you're writing a plugin or subclassing &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="translated">除非您正在编写插件或&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser的&lt;/a&gt;子类，否则您可能不需要直接使用此模块。</target>
        </trans-unit>
        <trans-unit id="d54802d84b1114c8dea2af70188cfd6c295957d7" translate="yes" xml:space="preserve">
          <source>Unless your parameters specify &lt;code&gt;'formatter'&lt;/code&gt; or &lt;code&gt;'ipc'&lt;/code&gt; arguments, the formatter and IPC instance will be inherited from the current top hub. You can set the parameters to &lt;code&gt;undef&lt;/code&gt; to avoid having a formatter or IPC instance.</source>
          <target state="translated">除非您的参数指定 &lt;code&gt;'formatter'&lt;/code&gt; 或 &lt;code&gt;'ipc'&lt;/code&gt; 参数，否则formatter和IPC实例将从当前的顶级集线器继承。您可以将参数设置为 &lt;code&gt;undef&lt;/code&gt; ,以避免出现格式化程序或IPC实例。</target>
        </trans-unit>
        <trans-unit id="e4fc409268936e0da48b9a4cfb9650b21029f3c0" translate="yes" xml:space="preserve">
          <source>Unlike</source>
          <target state="translated">Unlike</target>
        </trans-unit>
        <trans-unit id="0b93fd78908f06ac9f5039bb243a42a6b44ce01c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#Decimal-Versions&quot;&gt;&quot;Decimal Versions&quot;&lt;/a&gt;, Dotted-Decimal Versions have more than a single decimal point, e.g.:</source>
          <target state="translated">与&lt;a href=&quot;#Decimal-Versions&quot;&gt;&amp;ldquo;十进制版本&amp;rdquo;&lt;/a&gt;不同，点分十进制版本具有多个单个小数点，例如：</target>
        </trans-unit>
        <trans-unit id="cb0a5bc8021cd6778eed9a88f7e5cfd7b53090d1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt;, this does not include the decomposition type. Use the &lt;code&gt;Decomposition_Type&lt;/code&gt; property to get that.</source>
          <target state="translated">与&lt;a href=&quot;#charinfo%28%29&quot;&gt;&amp;ldquo; charinfo（）&amp;rdquo;不同&lt;/a&gt;，它不包括分解类型。使用 &lt;code&gt;Decomposition_Type&lt;/code&gt; 属性来获取该属性。</target>
        </trans-unit>
        <trans-unit id="26769d51e7e8546d072ce687409eedaf6bbd7d27" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;, this does not include the decomposition type. Use the &lt;code&gt;Decomposition_Type&lt;/code&gt; property to get that.</source>
          <target state="translated">与&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;不同，它不包括分解类型。使用 &lt;code&gt;Decomposition_Type&lt;/code&gt; 属性可以实现这一点。</target>
        </trans-unit>
        <trans-unit id="9a41788c4603779b500b4b22e894cfcf25b5f9a6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#dbmopen-HASH%2CDBNAME%2CMASK&quot;&gt;&lt;code&gt;dbmopen&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;&lt;code&gt;tie&lt;/code&gt;&lt;/a&gt; function will not &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; or the &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; module for interesting &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;&lt;code&gt;tie&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">与&lt;a href=&quot;#dbmopen-HASH%2CDBNAME%2CMASK&quot;&gt; &lt;code&gt;dbmopen&lt;/code&gt; &lt;/a&gt;不同，&lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt; &lt;code&gt;tie&lt;/code&gt; &lt;/a&gt;函数将不会为您&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;一个模块。您需要自己明确地执行此操作。有关有趣的&lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt; &lt;code&gt;tie&lt;/code&gt; &lt;/a&gt;实现，请参见&lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt;或&lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="6a6202c7008c5edbd97e21466da5df4a59ec41a0" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="translated">与&lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;printf&lt;/code&gt; &lt;/a&gt;不同，当将数组作为第一个参数传递给&lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;sprintf&lt;/code&gt; 时&lt;/a&gt;，sprintf可能不执行您的意思。该数组具有标量上下文，并且Perl不会使用数组的第0个元素作为格式，而是使用数组中的元素计数作为格式，这几乎是没有用的。</target>
        </trans-unit>
        <trans-unit id="a68f9ca2a4829500bd2437e49a38f1fec56cc959" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#utf8_to_bytes&quot;&gt;&quot;utf8_to_bytes&quot;&lt;/a&gt; but like &lt;a href=&quot;#bytes_to_utf8&quot;&gt;&quot;bytes_to_utf8&quot;&lt;/a&gt;, this is non-destructive of the input string.</source>
          <target state="translated">与&lt;a href=&quot;#utf8_to_bytes&quot;&gt;&amp;ldquo; utf8_to_bytes&amp;rdquo;&lt;/a&gt;不同，但与&lt;a href=&quot;#bytes_to_utf8&quot;&gt;&amp;ldquo; bytes_to_utf8&amp;rdquo;&lt;/a&gt;类似，这对输入字符串没有破坏性。</target>
        </trans-unit>
        <trans-unit id="0f7823a1b5c73e2c047f503abcdbc0ee1982c031" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;integer&quot;&gt;integer&lt;/a&gt;, this pragma creates integer constants that are only limited in their size by the available memory and CPU time.</source>
          <target state="translated">与&lt;a href=&quot;integer&quot;&gt;integer&lt;/a&gt;不同，此pragma创建的整数常量的大小仅受可用内存和CPU时间的限制。</target>
        </trans-unit>
        <trans-unit id="ed386882eb03009cdfed1d7cc619e0742b192d68" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function will not &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt; or the</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数不会为您 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 一个模块。您需要自己明确地执行此操作。请参阅&lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt;或</target>
        </trans-unit>
        <trans-unit id="e6074edfe48b345d15827a75a36946caff143c7a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function will not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; or the</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数不会为您 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 一个模块。您需要自己明确地执行此操作。请参阅&lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt;或</target>
        </trans-unit>
        <trans-unit id="7f221507f852d26a177998f0fca0127e91483ffd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for...in&lt;/a&gt;&lt;/code&gt;, Perl's &lt;code&gt;for&lt;/code&gt; (also spelled &lt;code&gt;foreach&lt;/code&gt; ) does not allow the left-hand side to be an arbitrary expression. It must be a variable:</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for...in&lt;/a&gt;&lt;/code&gt; 不同，Perl的 &lt;code&gt;for&lt;/code&gt; （也拼写为 &lt;code&gt;foreach&lt;/code&gt; ）不允许左侧为任意表达式。它必须是一个变量：</target>
        </trans-unit>
        <trans-unit id="2d1c847135806754dca42b817cb04eaf19cedf87" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 不同，当将数组作为第一个参数传递给 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 时，sprintf可能不执行您的意思。该数组具有标量上下文，并且Perl不会使用数组的第0个元素作为格式，而是使用数组中的元素计数作为格式，这几乎是没有用的。</target>
        </trans-unit>
        <trans-unit id="89ae4f74127125a7e7d48317841dc79dfceae6a6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 不同，当将数组作为第一个参数传递给 &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 时，sprintf可能不执行您的意思。该数组具有标量上下文，并且Perl不会使用数组的第0个元素作为格式，而是使用数组中的元素计数作为格式，这几乎是没有用的。</target>
        </trans-unit>
        <trans-unit id="3b964f91b8b4881dd0085a0962dbd9390808f7e2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;[[:digit:]]&lt;/code&gt; which matches digits in many writing systems, such as Thai and Devanagari, there are currently only two sets of hexadecimal digits, and it is unlikely that more will be added. This is because you not only need the ten digits, but also the six &lt;code&gt;[A-F]&lt;/code&gt; (and &lt;code&gt;[a-f]&lt;/code&gt;) to correspond. That means only the Latin script is suitable for these, and Unicode has only two sets of these, the familiar ASCII set, and the fullwidth forms starting at U+FF10 (FULLWIDTH DIGIT ZERO).</source>
          <target state="translated">与 &lt;code&gt;[[:digit:]]&lt;/code&gt; 在许多书写系统（例如Thai和Devanagari ）中匹配数字不同，当前仅存在两组十六进制数字，并且不太可能添加更多十六进制数字。这是因为您不仅需要十个数字，而且还需要六个 &lt;code&gt;[A-F]&lt;/code&gt; （和 &lt;code&gt;[a-f]&lt;/code&gt; ）对应。这意味着仅拉丁脚本适用于这些脚本，而Unicode仅具有这两组脚本，即熟悉的ASCII集和以U + FF10（全宽数字零）开头的全角格式。</target>
        </trans-unit>
        <trans-unit id="b58c8c453430fd542b53059b23563075518c8ca7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;for...in&lt;/code&gt;, Perl's &lt;code&gt;for&lt;/code&gt; (also spelled &lt;code&gt;foreach&lt;/code&gt;) does not allow the left-hand side to be an arbitrary expression. It must be a variable:</source>
          <target state="translated">与 &lt;code&gt;for...in&lt;/code&gt; 不同，Perl的 &lt;code&gt;for&lt;/code&gt; （也拼写为 &lt;code&gt;foreach&lt;/code&gt; ）不允许左侧为任意表达式。它必须是一个变量：</target>
        </trans-unit>
        <trans-unit id="08ee12c11bcd84febb2422b0c97e2cecef90b3a9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;use feature &quot;:5.12&quot;&lt;/code&gt;, saying &lt;code&gt;use v5.12&lt;/code&gt; (or any higher version) also does the equivalent of &lt;code&gt;use strict&lt;/code&gt;; see &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt; for details.</source>
          <target state="translated">与 &lt;code&gt;use feature &quot;:5.12&quot;&lt;/code&gt; ，说 &lt;code&gt;use v5.12&lt;/code&gt; （或任何更高版本）也等同于 &lt;code&gt;use strict&lt;/code&gt; ；有关详细信息，请参见&lt;a href=&quot;perlfunc#use&quot;&gt;perlfunc中的&amp;ldquo;使用&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9885543c31cf8cf0906d34d4b26f89726d373169" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;which&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; , this function is platform independent and will also work on, for example, Win32.</source>
          <target state="translated">与 &lt;code&gt;which&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 不同，此函数与平台无关，并且也可以在Win32等环境下使用。</target>
        </trans-unit>
        <trans-unit id="4fd10722655bcf3a1480d15b870f6c966069d54d" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;which&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, this function is platform independent and will also work on, for example, Win32.</source>
          <target state="translated">与 &lt;code&gt;which&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 不同，此功能是平台无关的，并且也可以在Win32上运行。</target>
        </trans-unit>
        <trans-unit id="8c1319ac66a745a073ad45b032e405d0c0606e8b" translate="yes" xml:space="preserve">
          <source>Unlike Perl 4, in which all the variables were dynamic and shared one global name space, causing maintainability problems, Perl 5 provides two mechanisms for protecting code from having its variables stomped on by other code: lexically scoped variables created with &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;state&lt;/code&gt; and namespaced global variables, which are exposed via the &lt;code&gt;vars&lt;/code&gt; pragma, or the &lt;code&gt;our&lt;/code&gt; keyword. Any global variable is considered to be part of a namespace and can be accessed via a &quot;fully qualified form&quot;. Conversely, any lexically scoped variable is considered to be part of that lexical-scope, and does not have a &quot;fully qualified form&quot;.</source>
          <target state="translated">与Perl 4中的所有变量都是动态的并且共享一个全局名称空间，从而引起可维护性问题的Perl 5不同，Perl 5提供了两种保护代码使其变量不受其他代码踩踏的机制：用 &lt;code&gt;my&lt;/code&gt; 或 &lt;code&gt;state&lt;/code&gt; 创建的词法范围变量和命名空间全局变量，这些变量通过 &lt;code&gt;vars&lt;/code&gt; pragma或 &lt;code&gt;our&lt;/code&gt; 关键字公开。任何全局变量都被视为名称空间的一部分，并且可以通过&amp;ldquo;完全限定的形式&amp;rdquo;进行访问。相反，任何词法范围变量都被视为该词法范围的一部分，并且不具有&amp;ldquo;完全限定形式&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a35eb11bdbc8f6461d7ed511f9bd108d79a6ba74" translate="yes" xml:space="preserve">
          <source>Unlike Perl's built-in hashes, it is not safe to &lt;code&gt;delete&lt;/code&gt; the current item from a GDBM_File tied hash while iterating over it with &lt;code&gt;each&lt;/code&gt;. This is a limitation of the gdbm library.</source>
          <target state="translated">与Perl的内置哈希值不同，在对 &lt;code&gt;each&lt;/code&gt; 项目进行迭代时，从GDBM_File绑定的哈希表中 &lt;code&gt;delete&lt;/code&gt; 当前项目是不安全的。这是gdbm库的限制。</target>
        </trans-unit>
        <trans-unit id="a93ac07922c6fc8a77d40224ee6574380d8e4055" translate="yes" xml:space="preserve">
          <source>Unlike Win32 build, miniperl will not have</source>
          <target state="translated">与Win32构建不同的是,miniperl将不会有</target>
        </trans-unit>
        <trans-unit id="a7c35c87e2cd92f458c69ed20a29518c1fc60ceb" translate="yes" xml:space="preserve">
          <source>Unlike constants in some languages, these cannot be overridden on the command line or via environment variables.</source>
          <target state="translated">与某些语言中的常量不同,这些常量不能在命令行或通过环境变量被覆盖。</target>
        </trans-unit>
        <trans-unit id="2e9d61b3ed80ed71e7bbbb9d575bf23b5d77fb98" translate="yes" xml:space="preserve">
          <source>Unlike dbmopen(), the tie() function will not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you--you need to do that explicitly yourself.</source>
          <target state="translated">与dbmopen（）不同，tie（）函数不会为您 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 一个模块-您需要自己明确地执行此操作。</target>
        </trans-unit>
        <trans-unit id="ac457fcb4cff6e9b40b4fc09afe6c228026b2c13" translate="yes" xml:space="preserve">
          <source>Unlike dbmopen(), the tie() function will not &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; a module for you--you need to do that explicitly yourself.</source>
          <target state="translated">与dbmopen（）不同，tie（）函数不会为您 &lt;code&gt;use&lt;/code&gt; 或 &lt;code&gt;require&lt;/code&gt; 一个模块-您需要自己明确地执行此操作。</target>
        </trans-unit>
        <trans-unit id="ae7d99bfc8b3205da369ad185c97fc4f2004cc75" translate="yes" xml:space="preserve">
          <source>Unlike dynamic variables created by the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; operator, lexical variables declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; are totally hidden from the outside world, including any called subroutines. This is true if it's the same subroutine called from itself or elsewhere--every call gets its own copy.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 运算符创建的动态变量不同，使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明的词法变量对外界完全隐藏，包括任何被调用的子例程。如果它是从其本身或在其他地方调用的相同子例程，则这是正确的-每次调用都有自己的副本。</target>
        </trans-unit>
        <trans-unit id="ef30321397c8a6c2a145849a1e7eb34fc5044060" translate="yes" xml:space="preserve">
          <source>Unlike dynamic variables created by the &lt;code&gt;local&lt;/code&gt; operator, lexical variables declared with &lt;code&gt;my&lt;/code&gt; are totally hidden from the outside world, including any called subroutines. This is true if it's the same subroutine called from itself or elsewhere--every call gets its own copy.</source>
          <target state="translated">与 &lt;code&gt;local&lt;/code&gt; 运算符创建的动态变量不同，用 &lt;code&gt;my&lt;/code&gt; 声明的词法变量对外界完全隐藏，包括任何被调用的子例程。如果它是从其本身或在其他地方调用的相同子例程，则这是正确的-每个调用都具有自己的副本。</target>
        </trans-unit>
        <trans-unit id="f1d613b9dfee0f458298b76229e47572b9ad09a4" translate="yes" xml:space="preserve">
          <source>Unlike in C and Pascal, in Perl these are all defined in terms of BLOCKs, not statements. This means that the curly brackets are</source>
          <target state="translated">与C语言和Pascal语言不同的是,在Perl中,这些都是以BLOCK的形式定义的,而不是以语句的形式定义的。这意味着,大括号是</target>
        </trans-unit>
        <trans-unit id="f21336a91710bef15208089eafb11092016626b2" translate="yes" xml:space="preserve">
          <source>Unlike in C, the scalar assignment operator produces a valid lvalue. Modifying an assignment is equivalent to doing the assignment and then modifying the variable that was assigned to. This is useful for modifying a copy of something, like this:</source>
          <target state="translated">与C语言不同的是,标量赋值运算符会产生一个有效的l值。修改赋值相当于先做赋值,然后修改被赋值的变量。这对于修改某个东西的副本很有用,就像这样。</target>
        </trans-unit>
        <trans-unit id="5f827eec6110de095ec9210c18c9cbffc634099b" translate="yes" xml:space="preserve">
          <source>Unlike in earlier versions of Perl, &lt;code&gt;:raw&lt;/code&gt; is</source>
          <target state="translated">与早期版本的Perl不同， &lt;code&gt;:raw&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="33bdaa80be75964fba31840d455d3822e7d396b4" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;&quot;&quot;&lt;/code&gt; ) can be returned. Since &lt;code&gt;catdir()&lt;/code&gt; on Mac OS always appends a trailing colon to distinguish a directory path from a file path, a single trailing colon will be ignored, i.e. there's no empty directory name after it.</source>
          <target state="translated">与仅在分隔符上拆分目录不同，可以返回空目录名称（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）。由于Mac OS上的 &lt;code&gt;catdir()&lt;/code&gt; 总是附加尾随冒号来区分目录路径和文件路径，因此单个尾随冒号将被忽略，即其后没有空目录名。</target>
        </trans-unit>
        <trans-unit id="7e91e9b08f85424586bbe7fa7e02138bcae68a32" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;&quot;&quot;&lt;/code&gt;) can be returned. Since &lt;code&gt;catdir()&lt;/code&gt; on Mac OS always appends a trailing colon to distinguish a directory path from a file path, a single trailing colon will be ignored, i.e. there's no empty directory name after it.</source>
          <target state="translated">与仅在分隔符上拆分目录不同，可以返回空目录名称（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）。由于Mac OS上的 &lt;code&gt;catdir()&lt;/code&gt; 总是附加尾随冒号来区分目录路径和文件路径，因此单个尾随冒号将被忽略，即其后没有空目录名。</target>
        </trans-unit>
        <trans-unit id="54463777f2a5a26bb28578fbecd0a237664559d0" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt; ) can be returned, because these are significant on some OSes.</source>
          <target state="translated">与仅在分隔符上拆分目录不同，可以返回空目录名称（ &lt;code&gt;''&lt;/code&gt; ），因为这些名称在某些操作系统上很重要。</target>
        </trans-unit>
        <trans-unit id="86f74613bf49290364595249fc093a5b0e46c0b1" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt; ) can be returned, because these are significant on some OSs.</source>
          <target state="translated">与仅在分隔符上拆分目录不同，可以返回空目录名称（ &lt;code&gt;''&lt;/code&gt; ），因为这些名称在某些操作系统上很重要。</target>
        </trans-unit>
        <trans-unit id="a1dab7e402fccbdcf23288af9af78be14a2bd58c" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt;) can be returned, because these are significant on some OSes.</source>
          <target state="translated">与仅在分隔符上拆分目录不同，可以返回空目录名称（ &lt;code&gt;''&lt;/code&gt; ），因为这些名称在某些OS上很重要。</target>
        </trans-unit>
        <trans-unit id="6113c750f78736baa4aa9cd996719b663fd9d18d" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt;) can be returned, because these are significant on some OSs.</source>
          <target state="translated">与仅在分隔符上拆分目录不同，可以返回空目录名称（ &lt;code&gt;''&lt;/code&gt; ），因为这些名称在某些OS上很重要。</target>
        </trans-unit>
        <trans-unit id="f0601a2027041706b4a215c5ba97b0f2d038f55f" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, leading empty and trailing directory entries can be returned, because these are significant on some OSs. So,</source>
          <target state="translated">与仅仅在分隔符上分割目录不同,可以返回前导空和后导目录条目,因为这些条目在某些操作系统上很重要。所以。</target>
        </trans-unit>
        <trans-unit id="7934f43f05e561c630f325debe8a290638569198" translate="yes" xml:space="preserve">
          <source>Unlike local variables in C or C++, Perl's lexical variables don't necessarily get recycled just because their scope has exited. If something more permanent is still aware of the lexical, it will stick around. So long as something else references a lexical, that lexical won't be freed--which is as it should be. You wouldn't want memory being free until you were done using it, or kept around once you were done. Automatic garbage collection takes care of this for you.</source>
          <target state="translated">与 C 或 C++中的局部变量不同,Perl 的词法变量不一定会因为其作用域退出而被回收。如果有更永久性的东西仍然知道这个词库,它就会一直存在。只要有其他东西引用一个词法,这个词法就不会被释放--这也是应该的。你不会希望内存在你使用完之前是空闲的,或者一旦你使用完了,它就会被保留下来。自动垃圾收集会帮你解决这个问题。</target>
        </trans-unit>
        <trans-unit id="61c2bf5d9fb9c4e4b449918bf685b7cd4c575760" translate="yes" xml:space="preserve">
          <source>Unlike many other languages which support object orientation, Perl does not provide any special syntax for constructing an object. Objects are merely Perl data structures (hashes, arrays, scalars, filehandles, etc.) that have been explicitly associated with a particular class.</source>
          <target state="translated">与其他许多支持对象导向的语言不同,Perl并没有提供任何特殊的语法来构造对象。对象只是Perl的数据结构(哈希、数组、标量、文件柄等),它们已经明确地与一个特定的类相关联。</target>
        </trans-unit>
        <trans-unit id="96a17407e83fd96732a811a270065f8bf99b9560" translate="yes" xml:space="preserve">
          <source>Unlike most encodings which accept various ways to handle errors, Unicode encodings simply croaks.</source>
          <target state="translated">与大多数编码接受各种处理错误的方式不同,Unicode编码只是呱呱叫。</target>
        </trans-unit>
        <trans-unit id="49b673e0d13d9cc508ff95ef6bf45edac94a0386" translate="yes" xml:space="preserve">
          <source>Unlike most locales, which are specific to a language and country pair, Unicode classifies all the characters that are letters</source>
          <target state="translated">不像大多数地方码是针对语言和国家对的,Unicode将所有属于字母的字符进行分类。</target>
        </trans-unit>
        <trans-unit id="de28345f4c14a0c66a5513ec93329ba001d9ced5" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="c0d9558dea8e06eb18c291c6122258af13477176" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="9b35f8dffb5619dd71375e3734d385be7cc68976" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="642dec0f5e46307ce9e97ef7e93a9392f0b1f7ab" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="8e8af66683db3fc2cddaa8cdf32b4f53ebab4445" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; ，因此重做（&amp;ldquo; foo&amp;rdquo;）。&amp;ldquo; bar&amp;rdquo;将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="5bec2254ea41ddda3ef06eefb12b88f8ff1170ba" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="46f28e7c4c55184f01ee0fc59018a927acd8437c" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="fe0bcbfb6300fcbe2507c49b4631d20697de525c" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; ，因此重做（&amp;ldquo; foo&amp;rdquo;）。&amp;ldquo; bar&amp;rdquo;将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="34c00fe043d78656afd77828c738549c64c1fe0d" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;dump (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;a href=&quot;#dump-LABEL&quot;&gt;&lt;code&gt;dump&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;dump (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为&lt;a href=&quot;#dump-LABEL&quot;&gt; &lt;code&gt;dump&lt;/code&gt; &lt;/a&gt;参数的一部分。</target>
        </trans-unit>
        <trans-unit id="a22585aa0bd13d608250b8dcea334b07dd252021" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;last (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;last (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为&lt;a href=&quot;#last-LABEL&quot;&gt; &lt;code&gt;last&lt;/code&gt; &lt;/a&gt;参数的一部分。</target>
        </trans-unit>
        <trans-unit id="bec12e43efad3d3a645f2714eff3a43a7be31992" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;next (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;next (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为&lt;a href=&quot;#next-LABEL&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;参数的一部分。</target>
        </trans-unit>
        <trans-unit id="03dc19f120a0108be730d05ae2cc974e390f447d" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;redo (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;a href=&quot;#redo-LABEL&quot;&gt;&lt;code&gt;redo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的 &lt;code&gt;redo (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; ，因此重做（&amp;ldquo; foo&amp;rdquo;）。&amp;ldquo; bar&amp;rdquo;将使&amp;ldquo; bar&amp;rdquo;成为&lt;a href=&quot;#redo-LABEL&quot;&gt; &lt;code&gt;redo&lt;/code&gt; &lt;/a&gt;参数的一部分。</target>
        </trans-unit>
        <trans-unit id="3ee3973cea98d2564d41622c65ad1eadc9b20495" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="fd9949db65a27c0400a1254746b3e91b925c452b" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="c7a5022b5ad46573ca70c92672e20e032530725b" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;return (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &lt;code&gt;&quot;bar&quot;&lt;/code&gt; to be part of the argument to &lt;a href=&quot;#return-EXPR&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它也不受函数函数规则的约束，因此 &lt;code&gt;return (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使 &lt;code&gt;&quot;bar&quot;&lt;/code&gt; 成为&lt;a href=&quot;#return-EXPR&quot;&gt; &lt;code&gt;return&lt;/code&gt; &lt;/a&gt;参数的一部分。</target>
        </trans-unit>
        <trans-unit id="728a32d1ef745efc09c9a2c8f8520f5d6f4c4b95" translate="yes" xml:space="preserve">
          <source>Unlike most of the other functions that have &lt;code&gt;utf8&lt;/code&gt; in their name, the input to this function is NOT a UTF-8-encoded string. The function name is slightly</source>
          <target state="translated">与大多数其他名称中带有 &lt;code&gt;utf8&lt;/code&gt; 的其他函数不同，此函数的输入不是UTF-8编码的字符串。函数名称略</target>
        </trans-unit>
        <trans-unit id="d21a9fd801c4b5ff299a1a5bef8631136555ebd2" translate="yes" xml:space="preserve">
          <source>Unlike most operators, the smartmatch operator knows to treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; specially:</source>
          <target state="translated">与大多数运算符不同，smartmatch运算符知道如何特别处理 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a099365433c865a39830b29bcea8462ee44a1ac6" translate="yes" xml:space="preserve">
          <source>Unlike most operators, the smartmatch operator knows to treat &lt;code&gt;undef&lt;/code&gt; specially:</source>
          <target state="translated">与大多数运算符不同，smartmatch运算符知道如何特别处理 &lt;code&gt;undef&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c52ae364f54ddc8596b506c3503500a0182fc785" translate="yes" xml:space="preserve">
          <source>Unlike most other encodings, the following always croaks on error for any $chk that evaluates to true.</source>
          <target state="translated">与大多数其他编码不同的是,对于任何值为真的$chk,下面的代码总是错误的。</target>
        </trans-unit>
        <trans-unit id="3d20af86f51aab9cb74465f15c6036108807e949" translate="yes" xml:space="preserve">
          <source>Unlike non-user-defined &lt;code&gt;\p{}&lt;/code&gt; property matches, no warning is ever generated if these properties are matched against a non-Unicode code point (see &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;&quot;Beyond Unicode code points&quot;&lt;/a&gt; below).</source>
          <target state="translated">与非用户定义的 &lt;code&gt;\p{}&lt;/code&gt; 属性匹配不同，如果将这些属性与非Unicode代码点匹配，则不会生成任何警告（请参见下面的&lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;&amp;ldquo;超出Unicode代码点&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a0be45e558750e70d5ad5d40843ef88fbc85d85e" translate="yes" xml:space="preserve">
          <source>Unlike non-user-defined &lt;code&gt;\p{}&lt;/code&gt; property matches, no warning is ever generated if these properties are matched against a non-Unicode code point (see &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;Beyond Unicode code points&lt;/a&gt; below).</source>
          <target state="translated">与非用户定义的 &lt;code&gt;\p{}&lt;/code&gt; 属性匹配不同，如果将这些属性与非Unicode代码点匹配，则不会生成任何警告（请参见下面的&lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;Unicode代码点之外&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="54d85676113e32968ab38ead192e565266d17ce6" translate="yes" xml:space="preserve">
          <source>Unlike other DJGPP packages, which are normal &quot;zip&quot; files, most CPAN module packages are &quot;gzipped tarballs&quot;. Recent versions of WinZip will safely unpack and expand them, *UNLESS* they have zero-length files. It is a known WinZip bug (as of v7.0) that it will not extract zero-length files.</source>
          <target state="translated">与其他DJGPP包是普通的 &quot;zip &quot;文件不同,大多数CPAN模块包是 &quot;gzipped tarballs&quot;。最新版本的WinZip可以安全地解压和扩展它们,除非它们有零长度的文件。这是一个已知的WinZip错误(从7.0版本开始),它不能解压零长度的文件。</target>
        </trans-unit>
        <trans-unit id="7d1d9ddacb9cc957a1381975755b447def4208e7" translate="yes" xml:space="preserve">
          <source>Unlike other boolean options, this opotion is enabled by default beginning with version &lt;code&gt;4.0&lt;/code&gt;.</source>
          <target state="translated">与其他布尔选项不同，此选项默认从版本 &lt;code&gt;4.0&lt;/code&gt; 开始启用。</target>
        </trans-unit>
        <trans-unit id="83864ffb2b433053a7d93f1893b27cbe33018e20" translate="yes" xml:space="preserve">
          <source>Unlike other encodings where mappings are not one-to-one against Unicode, UTFs are supposed to map 100% against one another. So Encode is more strict on UTFs.</source>
          <target state="translated">与其他编码不同,其他编码与Unicode的映射不是一对一的,UTF应该是100%的相互映射。所以Encode对UTFs的要求比较严格。</target>
        </trans-unit>
        <trans-unit id="9944da74f109a50432581cc20ef1a61578ffdb1c" translate="yes" xml:space="preserve">
          <source>Unlike other types of quote-like literals, a here document is rarely a contiguous substring. For example, a typical piece of code using here document might look like this:</source>
          <target state="translated">与其他类型的类似引号的文字不同,here文档很少是一个连续的子串。例如,一段使用 here 文档的典型代码可能是这样的。</target>
        </trans-unit>
        <trans-unit id="82bfb2284168959f095690d2be25e5ae6b5a6d2d" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; declarations are not BLOCK-scoped. They are thus effective for the entire file in which they appear. You may not rescind such declarations with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</source>
          <target state="translated">与影响 &lt;code&gt;$^H&lt;/code&gt; 提示变量的编译指示不同， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; 声明不是BLOCK范围的。因此，它们对于显示它们的整个文件都是有效的。你可能不撤销这些声明与 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="946dc8e2b9e4dbb1e056eab35da113b4edec1e74" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; declarations are not BLOCK-scoped. They are thus effective for the entire package in which they appear. You may not rescind such declarations with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</source>
          <target state="translated">与影响 &lt;code&gt;$^H&lt;/code&gt; 提示变量的编译指示不同， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; 声明不是BLOCK范围的。因此，它们对于其中出现的整个包装都是有效的。你可能不撤销这些声明与 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee09d59fb829cfd66034aa9b684c476eb3f881a3" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;use vars&lt;/code&gt; and &lt;code&gt;use subs&lt;/code&gt; declarations are not lexically scoped to the block they appear in: they affect the entire package in which they appear. It is not possible to rescind these declarations with &lt;code&gt;no vars&lt;/code&gt; or &lt;code&gt;no subs&lt;/code&gt;.</source>
          <target state="translated">与影响 &lt;code&gt;$^H&lt;/code&gt; 提示变量的编译指示不同， &lt;code&gt;use vars&lt;/code&gt; 和 &lt;code&gt;use subs&lt;/code&gt; 声明在词法上并不局限于它们所出现的块：它们会影响它们所出现的整个包。 &lt;code&gt;no vars&lt;/code&gt; 或 &lt;code&gt;no subs&lt;/code&gt; 废除这些声明是不可能的。</target>
        </trans-unit>
        <trans-unit id="a62fc8b32926f79e07e4cd739d192b4db682422d" translate="yes" xml:space="preserve">
          <source>Unlike previous examples, we've now run h2xs on a real include file. This has caused some extra goodies to appear in both the .pm and .xs files.</source>
          <target state="translated">与之前的例子不同,我们现在已经在一个真正的include文件上运行h2xs。这使得一些额外的好东西出现在.pm和.xs文件中。</target>
        </trans-unit>
        <trans-unit id="1ef80340079fb27e8a35fae5de34324e0ae68abb" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; implementations, the directory used for the temporary file is not specified in a system include file (&lt;code&gt;P_tmpdir&lt;/code&gt;) but simply depends on the choice of tmpdir() returned by &lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt;. On some implementations this location can be set using the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, which may not be secure. If this is a problem, simply use mkstemp() and specify a template.</source>
          <target state="translated">与&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;实现不同，用于临时文件的目录不是在系统包含文件（ &lt;code&gt;P_tmpdir&lt;/code&gt; ）中指定的，而仅取决于&lt;a href=&quot;File::Spec&quot;&gt;File :: Spec&lt;/a&gt;返回的tmpdir（）的选择。在某些实现中，可以使用 &lt;code&gt;TMPDIR&lt;/code&gt; 环境变量来设置此位置，这可能并不安全。如果这是一个问题，只需使用mkstemp（）并指定一个模板。</target>
        </trans-unit>
        <trans-unit id="82613342b350d8ac2d5e700389b419d73a2e8511" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;Newx&lt;/code&gt; and &lt;code&gt;Newxc&lt;/code&gt; macros, the &lt;code&gt;Newxz&lt;/code&gt; macro calls &lt;code&gt;memzero&lt;/code&gt; to zero out all the newly allocated memory.</source>
          <target state="translated">与 &lt;code&gt;Newx&lt;/code&gt; 和 &lt;code&gt;Newxc&lt;/code&gt; 宏不同， &lt;code&gt;Newxz&lt;/code&gt; 宏调用 &lt;code&gt;memzero&lt;/code&gt; 将所有新分配的内存清零。</target>
        </trans-unit>
        <trans-unit id="3459d8de61947e832dd8d6cc93a45a157f32fe5d" translate="yes" xml:space="preserve">
          <source>Unlike the GNU programs,</source>
          <target state="translated">与GNU程序不同。</target>
        </trans-unit>
        <trans-unit id="675122bbd6fe9d02ab821cef4f122f1e2fdb7554" translate="yes" xml:space="preserve">
          <source>Unlike the L</source>
          <target state="translated">不像L</target>
        </trans-unit>
        <trans-unit id="00946f20f0f39de3fde945a1c4762c9a2eb54a4d" translate="yes" xml:space="preserve">
          <source>Unlike the old Unix fmt(1) utility, this module correctly accounts for any Unicode combining characters (such as diacriticals) that may occur in each line for both expansion and unexpansion. These are overstrike characters that do not increment the logical position. Make sure you have the appropriate Unicode settings enabled.</source>
          <target state="translated">与旧的Unix fmt(1)实用程序不同,这个模块正确地计算了每行中可能出现的Unicode组合字符(如双标号)的扩展和未扩展。这些字符是不增加逻辑位置的叠加字符。确保您已经启用了适当的Unicode设置。</target>
        </trans-unit>
        <trans-unit id="0625a7948b2143bf8fa5b94abdec3d975bedca11" translate="yes" xml:space="preserve">
          <source>Unlike the old unix utilities, this module correctly accounts for any Unicode combining characters (such as diacriticals) that may occur in each line for both expansion and unexpansion. These are overstrike characters that do not increment the logical position. Make sure you have the appropriate Unicode settings enabled.</source>
          <target state="translated">与旧的unix实用程序不同,该模块正确地计算了每行中可能出现的Unicode组合字符(如双音符),包括扩展和未扩展。这些字符是不增加逻辑位置的叠加字符。确保您已经启用了适当的Unicode设置。</target>
        </trans-unit>
        <trans-unit id="bbee11f3129dceedbb755c4927925d533e72e81f" translate="yes" xml:space="preserve">
          <source>Unlike the original coding of this example, the returned values are not accessed in reverse order. So &lt;code&gt;ST(0)&lt;/code&gt; refers to the first value returned by the Perl subroutine and &lt;code&gt;ST(count-1)&lt;/code&gt; refers to the last.</source>
          <target state="translated">与本示例的原始编码不同，返回的值不是按相反的顺序访问的。因此， &lt;code&gt;ST(0)&lt;/code&gt; 指的是Perl子例程返回的第一个值， &lt;code&gt;ST(count-1)&lt;/code&gt; 指的是最后一个值。</target>
        </trans-unit>
        <trans-unit id="038e468b7871a7585436a41ba81caefab5eb3568" translate="yes" xml:space="preserve">
          <source>Unlike the stringification operator, there is never any need to append trailing zeros to preserve the correct version value.</source>
          <target state="translated">与字符串化运算符不同的是,永远不需要添加尾部的零来保存正确的版本值。</target>
        </trans-unit>
        <trans-unit id="daa5c6301a77bc0d8757cfca2a7141b60979b735" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#croak&quot;&gt;&quot;croak&quot;&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">与&lt;a href=&quot;#croak&quot;&gt;&amp;ldquo; croak&amp;rdquo;&lt;/a&gt;不同， &lt;code&gt;pat&lt;/code&gt; 不允许为null。</target>
        </trans-unit>
        <trans-unit id="54921bfadbbc4d5488355e38753c36b606db5127" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">与&lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;不同， &lt;code&gt;pat&lt;/code&gt; 不允许为null。</target>
        </trans-unit>
        <trans-unit id="ae0137e5db1f710b710a9bc0edfaf77e15650ab6" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#vcroak&quot;&gt;&quot;vcroak&quot;&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">与&lt;a href=&quot;#vcroak&quot;&gt;&amp;ldquo; vcroak&amp;rdquo;&lt;/a&gt;不同， &lt;code&gt;pat&lt;/code&gt; 不允许为null。</target>
        </trans-unit>
        <trans-unit id="8a7070baa0bba9b5c3411b37157873dd12da55ea" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#vcroak&quot;&gt;vcroak&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">与&lt;a href=&quot;#vcroak&quot;&gt;vcroak&lt;/a&gt;不同， &lt;code&gt;pat&lt;/code&gt; 不允许为null。</target>
        </trans-unit>
        <trans-unit id="28eadad196509c659a3994d74f2858a30a637ebf" translate="yes" xml:space="preserve">
          <source>Unlink a file, this wraps &lt;code&gt;unlink()&lt;/code&gt; in a way that makes it more reliable cross-platform when trying to unlink files you recently altered.</source>
          <target state="translated">取消 &lt;code&gt;unlink()&lt;/code&gt; 文件，这种包装方式将unlink（）包装起来，使其在尝试取消链接最近更改的文件时更加可靠地跨平台使用。</target>
        </trans-unit>
        <trans-unit id="e5cefcdd918640639ca1153770063f61e285104d" translate="yes" xml:space="preserve">
          <source>Unlink any temporary files you create.</source>
          <target state="translated">解除您创建的任何临时文件的链接。</target>
        </trans-unit>
        <trans-unit id="3e77881bda9dd47b3e5c55a65b50384eb4b9609f" translate="yes" xml:space="preserve">
          <source>Unloads a previously loaded dynamic-link library. The HANDLE is no longer valid after this call. See &lt;a&gt;LoadLibrary&lt;/a&gt; for information on dynamically loading a library.</source>
          <target state="translated">卸载以前加载的动态链接库。在此调用之后，HANDLE不再有效。有关动态加载库的信息，请参见&lt;a&gt;LoadLibrary&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f2c338fa9bfcccaac25268ab0ef12e64490b19e" translate="yes" xml:space="preserve">
          <source>Unlock and close the database.</source>
          <target state="translated">解锁并关闭数据库。</target>
        </trans-unit>
        <trans-unit id="425b4daaa8be44cc037fb6c4f8a9c4ee47b576db" translate="yes" xml:space="preserve">
          <source>Unmatched ( in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">不匹配（以正则表达式表示；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="a6fca5f2f3ab74092e2301bc93cfd673ca1d5fb7" translate="yes" xml:space="preserve">
          <source>Unmatched ) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中不匹配的）; 以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="87bab1d81d4066140528cdd5b267a8458e21ea97" translate="yes" xml:space="preserve">
          <source>Unmatched [ in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中无与伦比的[ 以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="5582b12b8fb1f3004178fe6e1d310ea58d890611" translate="yes" xml:space="preserve">
          <source>Unmatched right %s bracket</source>
          <target state="translated">不匹配的右%括号</target>
        </trans-unit>
        <trans-unit id="bc2c3a3141852414ad16ff6056e8a91c4d6648f7" translate="yes" xml:space="preserve">
          <source>Unpack the main archive to a temporary location (RAM: is fine).</source>
          <target state="translated">将主存档解压到一个临时位置(RAM:即可)。</target>
        </trans-unit>
        <trans-unit id="3a1b8bde43d6985240bfa75345e6d99d943394fd" translate="yes" xml:space="preserve">
          <source>Unpack the result with</source>
          <target state="translated">将结果用</target>
        </trans-unit>
        <trans-unit id="add77c91d022a17024fa5eba373c6e719da883a1" translate="yes" xml:space="preserve">
          <source>Unpack the result with &lt;code&gt;tar -xof yourmodule.tar&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;tar -xof yourmodule.tar&lt;/code&gt; 解压缩结果</target>
        </trans-unit>
        <trans-unit id="ae62392d2b4bc10cbedb53bdaea138dd0c54922e" translate="yes" xml:space="preserve">
          <source>Unpack the source package</source>
          <target state="translated">解压源码包</target>
        </trans-unit>
        <trans-unit id="3ba56861ba0d7e4bf096f38cb19b9bd9d11ad9ab" translate="yes" xml:space="preserve">
          <source>Unpacking CPAN Modules on DOS</source>
          <target state="translated">在DOS上解压CPAN模块</target>
        </trans-unit>
        <trans-unit id="a3e58138dfa89b35eb5a0a67e0ceb78fe71fb3cd" translate="yes" xml:space="preserve">
          <source>Unpacking Perl Distribution on BS2000</source>
          <target state="translated">在BS2000上解压Perl发行版</target>
        </trans-unit>
        <trans-unit id="1906a11a734d044847362b51bdd5c4ffec722822" translate="yes" xml:space="preserve">
          <source>Unpacking Perl distribution on OS/390</source>
          <target state="translated">在OS/390上解压Perl发行版</target>
        </trans-unit>
        <trans-unit id="1bfe6e7e13df7f1f795bc2c142ba9f8933ba83d0" translate="yes" xml:space="preserve">
          <source>Unpacking a Stack Frame</source>
          <target state="translated">拆开堆叠框架的包装</target>
        </trans-unit>
        <trans-unit id="13585670fad4d52485b4ecff204569086b8b8bc7" translate="yes" xml:space="preserve">
          <source>Unpacking this message can be done with the same template:</source>
          <target state="translated">解开这个消息可以用同一个模板。</target>
        </trans-unit>
        <trans-unit id="65ab97485c132c2a06d23b7d99106c078eeca52f" translate="yes" xml:space="preserve">
          <source>Unpacking using the &lt;code&gt;U&lt;/code&gt; template code also works on UTF-8 encoded byte strings.</source>
          <target state="translated">使用 &lt;code&gt;U&lt;/code&gt; 模板代码解压缩也适用于UTF-8编码的字节字符串。</target>
        </trans-unit>
        <trans-unit id="72bbb6196a2774c03510ad2f9119cf1acefc342b" translate="yes" xml:space="preserve">
          <source>Unqualified &lt;code&gt;dump()&lt;/code&gt;</source>
          <target state="translated">不合格的 &lt;code&gt;dump()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e326cb1d4e10ed2c54308ac7f68f78f28b408a5" translate="yes" xml:space="preserve">
          <source>Unqualified dump()</source>
          <target state="translated">无条件的dump()</target>
        </trans-unit>
        <trans-unit id="b99dd6692af960885bd57e60a35c0eb60eb31d7b" translate="yes" xml:space="preserve">
          <source>Unquoted string &quot;%s&quot; may clash with future reserved word</source>
          <target state="translated">未加引号的字符串&quot;%s &quot;可能会与未来的保留字发生冲突。</target>
        </trans-unit>
        <trans-unit id="07b032b56f7aa399f0c5a6580292f3e83d7b1fad" translate="yes" xml:space="preserve">
          <source>Unread</source>
          <target state="translated">Unread</target>
        </trans-unit>
        <trans-unit id="630c8dcab3eab70bdc2071c988078d95676c03b2" translate="yes" xml:space="preserve">
          <source>Unrecognized character %s; marked by &amp;lt;-- HERE after %s near column %d</source>
          <target state="translated">无法识别的字符％s；％s在％d列附近后以&amp;lt;-HERE标记</target>
        </trans-unit>
        <trans-unit id="35c8af17f83153420d0d873b2861766a589d6251" translate="yes" xml:space="preserve">
          <source>Unrecognized escape \%c in character class in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式字符类中无法识别的转义\％c；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="435719049eae3b64ca346100529a4145c47781d5" translate="yes" xml:space="preserve">
          <source>Unrecognized escape \%c in character class passed through in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">在正则表达式中传递的字符类中无法识别的转义\％c；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="43f0a236cfaeb24a6d268ae857e2d6c9ca2477d8" translate="yes" xml:space="preserve">
          <source>Unrecognized escape \%c passed through</source>
          <target state="translated">未确认的逃逸c通过</target>
        </trans-unit>
        <trans-unit id="6680e7a052c1c186addf84b706b28b2f52bdc84d" translate="yes" xml:space="preserve">
          <source>Unrecognized escape \%s passed through in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中传递了无法识别的转义\％s；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="14f5901f9cf23090de8d1e00ed8502304a6736d2" translate="yes" xml:space="preserve">
          <source>Unrecognized signal name &quot;%s&quot;</source>
          <target state="translated">未识别的信号名称&quot;%s&quot;</target>
        </trans-unit>
        <trans-unit id="3d60ad24f51432cfcd0acc6a239e8d374b5bdb9a" translate="yes" xml:space="preserve">
          <source>Unrecognized signal name: ...</source>
          <target state="translated">未识别的信号名称:...。</target>
        </trans-unit>
        <trans-unit id="e72ab0d0741f2af5e4f61b7913215c68a19c3881" translate="yes" xml:space="preserve">
          <source>Unrecognized switch: -%s (-h will show valid options)</source>
          <target state="translated">未识别的开关:-%s (-h将显示有效选项)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
