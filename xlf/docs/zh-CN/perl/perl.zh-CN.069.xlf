<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="9d8d0feb3edb0eff1e9ffe23486e4f54336c8d4e" translate="yes" xml:space="preserve">
          <source>Top-of-form processing is by default handled by a format with the same name as the current filehandle with &quot;_TOP&quot; concatenated to it. It's triggered at the top of each page. See &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;.</source>
          <target state="translated">默认情况下，格式顶部处理由与当前文件句柄同名的格式处理，并带有&amp;ldquo; _TOP&amp;rdquo;。它在每个页面的顶部触发。见&lt;a href=&quot;functions/write&quot;&gt;写&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58ef03b2e7b2cce794df0ce3f4e46ce888251a1d" translate="yes" xml:space="preserve">
          <source>Top-of-form processing is by default handled by a format with the same name as the current filehandle with &quot;_TOP&quot; concatenated to it. It's triggered at the top of each page. See &lt;a href=&quot;perlfunc#write&quot;&gt;&quot;write&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb98d71b2e229a477af401f7c4895167097dcb8a" translate="yes" xml:space="preserve">
          <source>TopSystemUID</source>
          <target state="translated">TopSystemUID</target>
        </trans-unit>
        <trans-unit id="f766dbf6de80a1783868b76b0ffdd16e6a94e83e" translate="yes" xml:space="preserve">
          <source>Topic branches and rewriting history</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2f2b4afe1a913994b69be99455c56a7fc054ab" translate="yes" xml:space="preserve">
          <source>Torsten Schoenfeld</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855b740deb0e234d1668b8ec10c825eb8a3450f0" translate="yes" xml:space="preserve">
          <source>Total CPU (User + System) of any children processes.</source>
          <target state="translated">任何子进程的CPU总量(用户+系统)。</target>
        </trans-unit>
        <trans-unit id="3481164ed61c4f3a7713de67224c54bcab0e71f6" translate="yes" xml:space="preserve">
          <source>Total CPU (User + System) of the main (parent) process.</source>
          <target state="translated">主(父)进程的CPU总量(用户+系统)。</target>
        </trans-unit>
        <trans-unit id="1e2c196e8d42960075bf83565f85bd785a488f4c" translate="yes" xml:space="preserve">
          <source>Total CPU of parent and any children processes.</source>
          <target state="translated">父进程和任何子进程的CPU总量。</target>
        </trans-unit>
        <trans-unit id="32bbce2a356130ac460d0855ed4bb96cc9c277fe" translate="yes" xml:space="preserve">
          <source>Trace function calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b32a7b148f732eb014244c4bbbcbbea6216c149" translate="yes" xml:space="preserve">
          <source>Trace mode (similar to &lt;code&gt;t&lt;/code&gt; command, but can be put into &lt;code&gt;PERLDB_OPTS&lt;/code&gt; ).</source>
          <target state="translated">跟踪模式（类似于 &lt;code&gt;t&lt;/code&gt; 命令，但可以放入 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 中）。</target>
        </trans-unit>
        <trans-unit id="75ddac2cad68f5ef90bf266909b1cc9bff0811e0" translate="yes" xml:space="preserve">
          <source>Trace mode (similar to &lt;code&gt;t&lt;/code&gt; command, but can be put into &lt;code&gt;PERLDB_OPTS&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8c4db1a294c0162454110ac7c8472297017033" translate="yes" xml:space="preserve">
          <source>Trace through execution of &lt;code&gt;expr&lt;/code&gt; . Optional first argument is the maximum number of levels to trace below the current one; anything deeper than that will be silent. See &lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;Frame Listing Output Examples in perldebguts&lt;/a&gt; for examples.</source>
          <target state="translated">通过执行 &lt;code&gt;expr&lt;/code&gt; 进行跟踪。可选的第一个参数是要跟踪的当前级别以下的最大级别数；任何比这更深的东西都将保持沉默。有关&lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;示例，&lt;/a&gt;请参见perldebguts中的框架列表输出示例。</target>
        </trans-unit>
        <trans-unit id="41581b1e8642b813163a8ffec956716ae9f8f88d" translate="yes" xml:space="preserve">
          <source>Trace through execution of &lt;code&gt;expr&lt;/code&gt;. Optional first argument is the maximum number of levels to trace below the current one; anything deeper than that will be silent. See &lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;&quot;Frame Listing Output Examples&quot; in perldebguts&lt;/a&gt; for examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b60e7167b2cc35295d61cd8ed5b383229ffbac" translate="yes" xml:space="preserve">
          <source>Trace variable used when Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch. This is the C variable which corresponds to Perl's $DB::trace variable. See &lt;code&gt;&lt;a href=&quot;#PL_DBsingle&quot;&gt;&quot;PL_DBsingle&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24be5dbb481a63442832782f4da3ef4f0dc024ff" translate="yes" xml:space="preserve">
          <source>Trace variable used when Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch. This is the C variable which corresponds to Perl's $DB::trace variable. See &lt;code&gt;PL_DBsingle&lt;/code&gt; .</source>
          <target state="translated">使用&lt;b&gt;-d&lt;/b&gt;开关在Perl以调试模式运行时使用的跟踪变量。这是C变量，它对应于Perl的$ DB :: trace变量。参见 &lt;code&gt;PL_DBsingle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="411aea8f76aef96f5e36c8b291c19e9ceb9466d1" translate="yes" xml:space="preserve">
          <source>Traces changes to Perl's interpreter state. You can internalize this as tracing changes to Perl's &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; variable, especially since the values for &lt;code&gt;NEWPHASE&lt;/code&gt; and &lt;code&gt;OLDPHASE&lt;/code&gt; are the strings that &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; reports.</source>
          <target state="translated">跟踪更改到Perl的解释器状态。您可以将其内部化，以跟踪对Perl的 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 变量的更改，尤其是因为 &lt;code&gt;NEWPHASE&lt;/code&gt; 和 &lt;code&gt;OLDPHASE&lt;/code&gt; 的值是 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 报告的字符串。</target>
        </trans-unit>
        <trans-unit id="0786ec1507cde8f738cd5528e03a2b67d40c8c91" translate="yes" xml:space="preserve">
          <source>Traces the entry of any subroutine. Note that all of the variables refer to the subroutine that is being invoked; there is currently no way to get ahold of any information about the subroutine's</source>
          <target state="translated">追踪任何子程序的进入。请注意,所有的变量都是指正在被调用的子程序;目前还没有办法获得任何关于子程序的信息。</target>
        </trans-unit>
        <trans-unit id="9f47af59eb569759ff1e8a42a52da14fba8b1705" translate="yes" xml:space="preserve">
          <source>Traces the execution of each opcode in the Perl runloop. This probe is fired before the opcode is executed. When the Perl debugger is enabled, the DTrace probe is fired</source>
          <target state="translated">追踪Perl runloop中每个操作码的执行情况。该探针在操作码执行之前被触发。当启用Perl调试器时,DTrace探针会被触发。</target>
        </trans-unit>
        <trans-unit id="bbb01fbe6bfaaec090a44633982fb31ae18d0d39" translate="yes" xml:space="preserve">
          <source>Traces the exit of any subroutine. Note that all of the variables refer to the subroutine that is returning; there is currently no way to get ahold of any information about the subroutine's</source>
          <target state="translated">追踪任何子程序的退出。请注意,所有的变量都是指正在返回的子程序;目前还没有办法获得任何关于子程序的信息。</target>
        </trans-unit>
        <trans-unit id="469260e080c9b35d7ee5b388f5235f91978c75b9" translate="yes" xml:space="preserve">
          <source>Traditional form:</source>
          <target state="translated">传统形式。</target>
        </trans-unit>
        <trans-unit id="0ad67b0aa9abbb10a0d4b2ca67f1c4ff5d61a0ed" translate="yes" xml:space="preserve">
          <source>Traditionally END blocks have been executed at the end of the perl_run. This causes problems for applications that never call perl_run. Since perl 5.7.2 you can specify &lt;code&gt;PL_exit_flags |= PERL_EXIT_DESTRUCT_END&lt;/code&gt; to get the new behaviour. This also enables the running of END blocks if the perl_parse fails and &lt;code&gt;perl_destruct&lt;/code&gt; will return the exit value.</source>
          <target state="translated">传统上，END块是在perl_run的末尾执行的。这会给永不调用perl_run的应用程序带来问题。从perl 5.7.2开始，您可以指定 &lt;code&gt;PL_exit_flags |= PERL_EXIT_DESTRUCT_END&lt;/code&gt; 以获取新的行为。如果perl_parse失败并且 &lt;code&gt;perl_destruct&lt;/code&gt; 将返回退出值，这还将启用END块的运行。</target>
        </trans-unit>
        <trans-unit id="0f62d4679a2de6656186513ec5b0145dfd0852c8" translate="yes" xml:space="preserve">
          <source>Traditionally in Perl, any use of any of the three variables &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; (or their &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; English&lt;/code&gt; equivalents) anywhere in the code, caused all subsequent successful pattern matches to make a copy of the matched string, in case the code might subsequently access one of those variables. This imposed a considerable performance penalty across the whole program, so generally the use of these variables has been discouraged.</source>
          <target state="translated">传统上，在Perl中，对代码中任何位置的三个变量 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 或 &lt;code&gt;$'&lt;/code&gt; 中的任何一个的使用（或它们 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; English&lt;/code&gt; 等效项）都会导致所有后续的成功模式匹配生成匹配字符串的副本，以防代码随后可能会访问这些变量之一。这对整个程序造成了相当大的性能损失，因此通常不鼓励使用这些变量。</target>
        </trans-unit>
        <trans-unit id="b39057d081d4426f280d8e658ad98c69967c3dee" translate="yes" xml:space="preserve">
          <source>Traditionally in Perl, any use of any of the three variables &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; (or their &lt;code&gt;use English&lt;/code&gt; equivalents) anywhere in the code, caused all subsequent successful pattern matches to make a copy of the matched string, in case the code might subsequently access one of those variables. This imposed a considerable performance penalty across the whole program, so generally the use of these variables has been discouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc1e4ae8cd5bdd4ef52be4cd619be47a1e80306" translate="yes" xml:space="preserve">
          <source>Traditionally the result is a string of 13 bytes: two first bytes of the salt, followed by 11 bytes from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt;, and only the first eight bytes of PLAINTEXT mattered. But alternative hashing schemes (like MD5), higher level security schemes (like C2), and implementations on non-Unix platforms may produce different strings.</source>
          <target state="translated">传统上，结果是一个13字节的字符串：salt的两个前字节，然后是集合 &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; 中的11个字节，仅PLAINTEXT的前八个字节很重要。但是替代的哈希方案（如MD5），更高级别的安全方案（如C2）以及在非Unix平台上的实现可能会产生不同的字符串。</target>
        </trans-unit>
        <trans-unit id="366ba2d0971221ce62e3e700bb5e4027a597313b" translate="yes" xml:space="preserve">
          <source>Traditionally, Perl has captured the value of the variable at that point and turned the subroutine into a constant eligible for inlining. In those cases where the variable can be modified elsewhere, this breaks the behavior of closures, in which the subroutine captures the variable itself, rather than its value, so future changes to the variable are reflected in the subroutine's return value.</source>
          <target state="translated">传统上,Perl在这一点上捕获了变量的值,并将子程序变成了一个符合内联条件的常量。在那些变量可以在其他地方修改的情况下,这就打破了闭包的行为,在闭包中,子程序捕获的是变量本身,而不是它的值,因此未来对变量的改变会反映在子程序的返回值中。</target>
        </trans-unit>
        <trans-unit id="77c289ba4e5a8332a82b92e0a687ee8832b65763" translate="yes" xml:space="preserve">
          <source>Traditionally, the Perl function &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; rounds to 0 (see &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;), and so for floating-point-like types one should follow the same semantic.</source>
          <target state="translated">传统上，Perl函数将 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 四舍五入为0（请参阅&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;），因此对于类浮点类型，应遵循相同的语义。</target>
        </trans-unit>
        <trans-unit id="adbc09d928775a73e398c4d99047b6c88a5a75f6" translate="yes" xml:space="preserve">
          <source>Traditionally, the Perl function &lt;code&gt;int&lt;/code&gt; rounds to 0 (see &lt;a href=&quot;perlfunc#int&quot;&gt;&quot;int&quot; in perlfunc&lt;/a&gt;), and so for floating-point-like types one should follow the same semantic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c93accaaddf881f0426884fd5fb319c6e78ef4" translate="yes" xml:space="preserve">
          <source>Traditionally, the definition of an inside-out class contains a bare block inside which a number of lexical hashes are declared and the basic accessor methods defined, usually through &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; . Further methods may be defined outside this block. There has to be a DESTROY method and, for thread support, a CLONE method.</source>
          <target state="translated">传统上，由内而外的类的定义包含一个裸露的块，该块中声明了许多词汇哈希，并定义了基本的访问器方法，通常通过 &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; 。可以在此块之外定义其他方法。必须有一个DESTROY方法，并且为了线程支持，必须有一个CLONE方法。</target>
        </trans-unit>
        <trans-unit id="a7bba9f4132fe6d6098df9712bd5f009714f6811" translate="yes" xml:space="preserve">
          <source>Traditionally, the definition of an inside-out class contains a bare block inside which a number of lexical hashes are declared and the basic accessor methods defined, usually through &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt;. Further methods may be defined outside this block. There has to be a DESTROY method and, for thread support, a CLONE method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e30fa719825fef87897a9b73f8c643d6e27859" translate="yes" xml:space="preserve">
          <source>Traditionally, typemaps needed to be written to a separate file, conventionally called &lt;code&gt;typemap&lt;/code&gt; in a CPAN distribution. With ExtUtils::ParseXS (the XS compiler) version 3.12 or better which comes with perl 5.16, typemaps can also be embedded directly into XS code using a HERE-doc like syntax:</source>
          <target state="translated">传统上，类型映射需要写入一个单独的文件，在CPAN分发中通常称为类型 &lt;code&gt;typemap&lt;/code&gt; 。使用Perl 5.16附带的ExtUtils :: ParseXS（XS编译器）3.12或更高版本，也可以使用类似HERE-doc的语法将类型映射直接嵌入XS代码中：</target>
        </trans-unit>
        <trans-unit id="09f8c62448637990777ebfc05ef92616935bd9ae" translate="yes" xml:space="preserve">
          <source>Trailing \ in regex m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b116d15c8d0f591aea30acc14d32c8151254d15b" translate="yes" xml:space="preserve">
          <source>Transfer file in ASCII. CRLF translation will be done if required</source>
          <target state="translated">以ASCII码传输文件。如有需要,将进行CRLF翻译。</target>
        </trans-unit>
        <trans-unit id="19b93b66a9a164099cf4c3e60d4b5f7a2c5a7780" translate="yes" xml:space="preserve">
          <source>Transfer file in binary mode. No transformation will be done.</source>
          <target state="translated">以二进制模式传输文件。不会进行转换。</target>
        </trans-unit>
        <trans-unit id="71b54b146f4723aa8db4c8d0ffb0816f4aee31ad" translate="yes" xml:space="preserve">
          <source>Transforms the current application into a PM application and back. The argument true means that a real message loop is going to be served. OS2::MorphPM() returns the PM message queue handle as an integer.</source>
          <target state="translated">将当前应用程序转换为PM应用程序并返回。参数true表示将提供一个真正的消息循环。OS2::MorphPM()以整数形式返回 PM 消息队列句柄。</target>
        </trans-unit>
        <trans-unit id="45a38a062b50bb87ecbfadb79c2d11cbaef46742" translate="yes" xml:space="preserve">
          <source>Transition notes when upgrading to Test2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab5267ee01682b79d53eef55a6ec4c6169897d2" translate="yes" xml:space="preserve">
          <source>Translate logical name DCL$PATH as a searchlist, rather than trying to &lt;code&gt;&lt;a href=&quot;../../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; string value of &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; .</source>
          <target state="translated">将逻辑名称DCL $ PATH转换为搜索列表，而不是尝试 &lt;code&gt;&lt;a href=&quot;../../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; 字符串值。</target>
        </trans-unit>
        <trans-unit id="ff6fe6980843b217b9b010e6374cc31ac52dccf0" translate="yes" xml:space="preserve">
          <source>Translate logical name DCL$PATH as a searchlist, rather than trying to &lt;code&gt;split&lt;/code&gt; string value of &lt;code&gt;$ENV{'PATH'}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df3684f8e1af9f3d36ff43ec1a39944ea62d252" translate="yes" xml:space="preserve">
          <source>Translates a Windows path to the corresponding cygwin path respecting the current mount points. With a second non-null argument returns an absolute path. Double-byte characters will not be translated.</source>
          <target state="translated">在尊重当前挂载点的前提下,将Windows路径转换为相应的cygwin路径。如果使用第二个非空参数,则返回一个绝对路径。双字节字符不会被翻译。</target>
        </trans-unit>
        <trans-unit id="43c8972cdf7cbd4964f60ea0553934fab0c0bfe0" translate="yes" xml:space="preserve">
          <source>Translates a Windows pid to the corresponding cygwin pid (if any).</source>
          <target state="translated">将Windows pid翻译成对应的cygwin pid(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="582d5dcb01cd3d8be49a7bc9c562cc61d6d3a8c7" translate="yes" xml:space="preserve">
          <source>Translates a cygwin path to the corresponding cygwin path respecting the current mount points. With a second non-null argument returns an absolute path. Double-byte characters will not be translated.</source>
          <target state="translated">将一个cygwin路径翻译成与当前挂载点相对应的cygwin路径。如果使用第二个非空参数,则返回一个绝对路径。双字节字符不会被翻译。</target>
        </trans-unit>
        <trans-unit id="d0b7e8b1f9fa64e7df02a610ac8f751cbf79794f" translate="yes" xml:space="preserve">
          <source>Translates a cygwin pid to the corresponding Windows pid (which may or may not be the same).</source>
          <target state="translated">将一个cygwin pid翻译成对应的Windows pid(可能是或可能不是相同的)。</target>
        </trans-unit>
        <trans-unit id="3cb9f5d38a91da3cb24f8ddc9ee0b78bc3316e7d" translate="yes" xml:space="preserve">
          <source>Translates the template as before except that a directory name is specified.</source>
          <target state="translated">除了指定目录名外,其他都和之前一样翻译模板。</target>
        </trans-unit>
        <trans-unit id="0e0c59b2d3a94d773b16fba8c10f9e6b9a4c8d83" translate="yes" xml:space="preserve">
          <source>Translators are available for converting Pod to various formats like plain text, HTML, man pages, and more.</source>
          <target state="translated">翻译器可用于将Pod转换为各种格式,如纯文本、HTML、man pages等。</target>
        </trans-unit>
        <trans-unit id="3d02c52d09a4e30f9d862205070306d13e0fd4bf" translate="yes" xml:space="preserve">
          <source>Translators may request clarification of the situation in which a particular phrase is found. For example, in English we are entirely happy saying &quot;</source>
          <target state="translated">译者可以要求对某一短语的情况进行澄清。例如,在英语中,我们完全乐意说&quot;</target>
        </trans-unit>
        <trans-unit id="7cec7716cf837c5d26e64202c8e48b66fd1ee111" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to &amp;amp;#NNN; where NNN is the decimal Unicode code point.</source>
          <target state="translated">编码为＆＃NNN;时缺少音译字符 其中NNN是十进制Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="4a944de5b3bc5a013582ea0515548fdc64b85e91" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to &amp;amp;#xHHHH; where HHHH is the hexadecimal Unicode code point.</source>
          <target state="translated">编码为＆＃xHHHH;时缺少音译字符 其中HHHH是十六进制Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="7531ab4c38b927cd6bd26046089b6f931f4b9669" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to \x{HHHH} where HHHH is the hexadecimal Unicode code point.</source>
          <target state="translated">将编码中缺失的字符转写为 \x{HHHH},其中HHHH是十六进制Unicode码点。</target>
        </trans-unit>
        <trans-unit id="41fb5a616fd328877f09027e33238e8f08b825a7" translate="yes" xml:space="preserve">
          <source>Transliterates all occurrences of the characters found (or not found if the &lt;code&gt;/c&lt;/code&gt; modifier is specified) in the search list with the positionally corresponding character in the replacement list, possibly deleting some, depending on the modifiers specified. It returns the number of characters replaced or deleted. If no string is specified via the &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator, the &lt;code&gt;$_&lt;/code&gt; string is transliterated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778ddecb6dcc9c5eac19efad6822ed838d8cfd37" translate="yes" xml:space="preserve">
          <source>Transliterates all occurrences of the characters found in the search list with the corresponding character in the replacement list. It returns the number of characters replaced or deleted. If no string is specified via the &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator, the &lt;code&gt;$_&lt;/code&gt; string is transliterated.</source>
          <target state="translated">用替换列表中的相应字符对所有出现在搜索列表中的字符进行音译。它返回替换或删除的字符数。如果没有通过 &lt;code&gt;=~&lt;/code&gt; 或 &lt;code&gt;!~&lt;/code&gt; 运算符指定任何字符串，则 &lt;code&gt;$_&lt;/code&gt; 字符串将被音译。</target>
        </trans-unit>
        <trans-unit id="31352bae87fe97a737e1fbb74f2d29f6b62133a0" translate="yes" xml:space="preserve">
          <source>Transliteration pattern not terminated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70808fd22f433d5ec8e8c5f0aad4eb5242bb686" translate="yes" xml:space="preserve">
          <source>Transliteration replacement not terminated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420a5e0771ab4a0b9e610c4b35eccba70828962b" translate="yes" xml:space="preserve">
          <source>Transparent BigInteger support for Perl</source>
          <target state="translated">为Perl提供透明的BigInteger支持</target>
        </trans-unit>
        <trans-unit id="7267fd5dd0f2d5cad0d4fdfbc6f406231fbc74c7" translate="yes" xml:space="preserve">
          <source>Transparent BigNumber support for Perl</source>
          <target state="translated">为Perl提供透明的BigNumber支持</target>
        </trans-unit>
        <trans-unit id="d53f15081d775673dd122d267a0fda505ffa50fe" translate="yes" xml:space="preserve">
          <source>Transparent BigNumber/BigRational support for Perl</source>
          <target state="translated">为Perl提供透明的BigNumber/BigRational支持。</target>
        </trans-unit>
        <trans-unit id="1320fa0059bd04032c977af604f63823046e2bca" translate="yes" xml:space="preserve">
          <source>Trappable errors may be trapped using the eval operator. See &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;. In almost all cases, warnings may be selectively disabled or promoted to fatal errors using the &lt;code&gt;warnings&lt;/code&gt; pragma. See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">可以使用eval运算符捕获可陷阱错误。参见&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;。在几乎所有情况下，都可以使用 &lt;code&gt;warnings&lt;/code&gt; 实用程序选择性地禁用警告或将警告升级为致命错误。请参阅&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9594e634fc8d3b1ced220c4bc1c7249b17dcfd33" translate="yes" xml:space="preserve">
          <source>Trappable errors may be trapped using the eval operator. See &lt;a href=&quot;perlfunc#eval&quot;&gt;&quot;eval&quot; in perlfunc&lt;/a&gt;. In almost all cases, warnings may be selectively disabled or promoted to fatal errors using the &lt;code&gt;warnings&lt;/code&gt; pragma. See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51ac6ee368e2e9218baa833ba69372fe936aae9" translate="yes" xml:space="preserve">
          <source>Trapping $SIG {__DIE__} other than during program exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17b071b49543aa19f12f2274e32fe9c1ba934844" translate="yes" xml:space="preserve">
          <source>Trapping &lt;code&gt;$SIG {__DIE__}&lt;/code&gt; other than during program exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f10d4d7cb6294c3306a64ba2969b74200be2428" translate="yes" xml:space="preserve">
          <source>Traverse a directory tree.</source>
          <target state="translated">遍历一个目录树。</target>
        </trans-unit>
        <trans-unit id="b2a99160c9547d1ab75aaa55623e70b1b8573818" translate="yes" xml:space="preserve">
          <source>Treat string as multiple lines. That is, change &quot;^&quot; and &quot;$&quot; from matching the start of the string's first line and the end of its last line to matching the start and end of each line within the string.</source>
          <target state="translated">将字符串视为多行。也就是说,将&quot;^&quot;和&quot;$&quot;从匹配字符串第一行的开始和最后一行的结束改为匹配字符串内每一行的开始和结束。</target>
        </trans-unit>
        <trans-unit id="93fa15e2fd4bd3f0707530f7f374f8fd00c44547" translate="yes" xml:space="preserve">
          <source>Treat string as single line. That is, change &quot;.&quot; to match any character whatsoever, even a newline, which normally it would not match.</source>
          <target state="translated">将字符串视为单行。也就是说,将&quot;.&quot;改为匹配任何字符,即使是换行符,通常也不会匹配。</target>
        </trans-unit>
        <trans-unit id="78e54c9da655d8dd5d453436c311823f0a02dca4" translate="yes" xml:space="preserve">
          <source>Treat the string as single line. That is, change &lt;code&gt;&quot;.&quot;&lt;/code&gt; to match any character whatsoever, even a newline, which normally it would not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ce43ffe9e36e380be02d47d4ca4755e5f762f0" translate="yes" xml:space="preserve">
          <source>Treat the string being matched against as multiple lines. That is, change &lt;code&gt;&quot;^&quot;&lt;/code&gt; and &lt;code&gt;&quot;$&quot;&lt;/code&gt; from matching the start of the string's first line and the end of its last line to matching the start and end of each line within the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d54adba605a60e729039d50fd8ece1d374030c" translate="yes" xml:space="preserve">
          <source>Treating errors reported by OS/2 API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369a3fe575602256c74f237530b2066156aadc25" translate="yes" xml:space="preserve">
          <source>Treats ARRAY as a stack by appending the values of LIST to the end of ARRAY. The length of ARRAY increases by the length of LIST. Has the same effect as</source>
          <target state="translated">将ARRAY作为堆栈处理,将LIST的值追加到ARRAY的最后。ARRAY的长度按LIST的长度增加。与</target>
        </trans-unit>
        <trans-unit id="4c2b22d2044144acb2e177299ffb0546b35d1302" translate="yes" xml:space="preserve">
          <source>Treats the complete zip file/buffer as a single compressed data stream. When reading in multi-stream mode each member of the zip file/buffer will be uncompressed in turn until the end of the file/buffer is encountered.</source>
          <target state="translated">将完整的zip文件/缓冲区作为一个单一的压缩数据流处理,当以多流模式读取时,zip文件/缓冲区的每个成员将依次被解压,直到文件/缓冲区结束。当以多流模式读取时,ZIP文件/缓冲区的每个成员将依次被解压缩,直到遇到文件/缓冲区的末端。</target>
        </trans-unit>
        <trans-unit id="9170df3df869288dce7be7560494463cb05b5488" translate="yes" xml:space="preserve">
          <source>Treats the return value of the code block as the condition.</source>
          <target state="translated">将代码块的返回值作为条件。</target>
        </trans-unit>
        <trans-unit id="a635e53ae97925c0c25ad3ddaf7be47457bf89eb" translate="yes" xml:space="preserve">
          <source>Treats the return value of the code block as the condition. Full syntax: &lt;code&gt;(?(?{ &lt;i&gt;code&lt;/i&gt; })&lt;i&gt;then&lt;/i&gt;|&lt;i&gt;else&lt;/i&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076fbc2c1d84c79c360a6aaf693ed414200277af" translate="yes" xml:space="preserve">
          <source>Treats the string in EXPR as a bit vector made up of elements of width BITS and returns the value of the element specified by OFFSET as an unsigned integer. BITS therefore specifies the number of bits that are reserved for each element in the bit vector. This must be a power of two from 1 to 32 (or 64, if your platform supports that).</source>
          <target state="translated">将EXPR中的字符串视为由宽度为BITS的元素组成的位向量,并将OFFSET指定的元素值作为无符号整数返回。因此,BITS指定了位向量中每个元素的保留位数。这个数字必须是1到32(或者64,如果你的平台支持的话)的2次幂。</target>
        </trans-unit>
        <trans-unit id="74c726e22e1ef4f0ff5d0f342fa4b671a8d7e3e6" translate="yes" xml:space="preserve">
          <source>Tree Contents</source>
          <target state="translated">树木内容</target>
        </trans-unit>
        <trans-unit id="bc924ad99a31c83efb674a21a76798fdb63e8535" translate="yes" xml:space="preserve">
          <source>Tries to &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; the given $module or $file. If it loads successfully, the test will pass. Otherwise it fails and displays the load error.</source>
          <target state="translated">尝试 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 给定的$ module或$ file。如果加载成功，则测试将通过。否则，它将失败并显示加载错误。</target>
        </trans-unit>
        <trans-unit id="9e432f6da17926a8d04f67b7c7b25438f0d2078a" translate="yes" xml:space="preserve">
          <source>Tries to &lt;code&gt;require&lt;/code&gt; the given $module or $file. If it loads successfully, the test will pass. Otherwise it fails and displays the load error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82437a05f154f78a4ae190392aa21b46338d0c97" translate="yes" xml:space="preserve">
          <source>Tries to uses &lt;a href=&quot;../../../ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; &amp;amp; &lt;a href=&quot;../../../io/select&quot;&gt;IO::Select&lt;/a&gt; to communicate with the spawned process if they are available. Falls back onto &lt;code&gt;&lt;a href=&quot;../../../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尝试使用&lt;a href=&quot;../../../ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt;＆&lt;a href=&quot;../../../io/select&quot;&gt;IO :: Select&lt;/a&gt;与产生的进程进行通信（如果可用）。退回到 &lt;code&gt;&lt;a href=&quot;../../../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="576659556d288e025b94f7ce5ace34cc997c7d54" translate="yes" xml:space="preserve">
          <source>Tries to uses &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; &amp;amp; &lt;a href=&quot;IO::Select&quot;&gt;IO::Select&lt;/a&gt; to communicate with the spawned process if they are available. Falls back onto &lt;code&gt;open()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0328d99f96d6b6cb2e5370be4979de91fb2ea44" translate="yes" xml:space="preserve">
          <source>Triggered by a delete from %^H, records the key to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; .</source>
          <target state="translated">由％^ H删除触发，将密钥记录到 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b83192144a37d41cc56666387a2897c4231e185" translate="yes" xml:space="preserve">
          <source>Triggered by a delete from &lt;code&gt;%^H&lt;/code&gt;, records the key to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce25e5857867e6310e792d455213353087781834" translate="yes" xml:space="preserve">
          <source>Triggered by a store to %^H, records the key/value pair to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; . It is assumed that hints aren't storing anything that would need a deep copy. Maybe we should warn if we find a reference.</source>
          <target state="translated">由商店触发％^ H，将键/值对记录到 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 。假定提示没有存储任何需要深层复制的内容。如果找到参考，也许我们应该警告。</target>
        </trans-unit>
        <trans-unit id="d308cd2f0c07029bd86f512d81284ed366f6c445" translate="yes" xml:space="preserve">
          <source>Triggered by a store to &lt;code&gt;%^H&lt;/code&gt;, records the key/value pair to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt;. It is assumed that hints aren't storing anything that would need a deep copy. Maybe we should warn if we find a reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e62fd5a7239de339d5bd00c0d3006bd6b133b17" translate="yes" xml:space="preserve">
          <source>Triggered by clearing %^H, resets &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; .</source>
          <target state="translated">通过清除％^ H触发，重置 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b8a309606a54a3100175b28554ebbc2c0bf40e9" translate="yes" xml:space="preserve">
          <source>Triggered by clearing &lt;code&gt;%^H&lt;/code&gt;, resets &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">三角函数</target>
        </trans-unit>
        <trans-unit id="ce550b5479caa5cd0ed1b0d59ad15c9773c7bcdb" translate="yes" xml:space="preserve">
          <source>Trilogy, &lt;code&gt;In the beginning the
Universe was created. This has made a lot of people very angry and
been widely regarded as a bad move&lt;/code&gt; . Their mistake was not of this magnitude so let's forgive them.</source>
          <target state="translated">三部曲， &lt;code&gt;In the beginning the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move&lt;/code&gt; 。他们的错误不是那么严重，所以让我们原谅他们。</target>
        </trans-unit>
        <trans-unit id="bd5caa14d9ae02b51776bb926be345cdff071829" translate="yes" xml:space="preserve">
          <source>Trilogy, &lt;code&gt;In the beginning the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move&lt;/code&gt;. Their mistake was not of this magnitude so let's forgive them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="28e5d7df36d1a6dde25f3c09a31821344957a89c" translate="yes" xml:space="preserve">
          <source>Troubleshooting these Examples</source>
          <target state="translated">解决这些例子的问题</target>
        </trans-unit>
        <trans-unit id="95a9fcae6cc7c433c5ecb181677d9e65f088ed3c" translate="yes" xml:space="preserve">
          <source>Tru64 5.1 documentation on syslog, &lt;a href=&quot;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&quot;&gt;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&lt;/a&gt;</source>
          <target state="translated">Syslog上的Tru64 5.1文档，&lt;a href=&quot;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&quot;&gt;http：//h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="048a8987b7e7ec2f729db8f1f26dbe354039d137" translate="yes" xml:space="preserve">
          <source>Tru64 documentation on syslog, &lt;a href=&quot;http://nixdoc.net/man-pages/Tru64/man3/syslog.3.html&quot;&gt;http://nixdoc.net/man-pages/Tru64/man3/syslog.3.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23888b0b14d45068fea9c016be17513c2fc8f457" translate="yes" xml:space="preserve">
          <source>True color and aliases are not supported by the constant interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2032ae3fd0b83aa79eef0ab641b287df415a0ffd" translate="yes" xml:space="preserve">
          <source>True if all testing should be halted immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9109071ad135094f2373ecd2b94d8dc48e87efa6" translate="yes" xml:space="preserve">
          <source>True if an external</source>
          <target state="translated">如果一个外部</target>
        </trans-unit>
        <trans-unit id="3d8c968cafa644831ebe062927600b2f8922bcb7" translate="yes" xml:space="preserve">
          <source>True if and only if the version object was created with a underscore, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a74362a5094d39f2b42a3da4ab4b28a9691928" translate="yes" xml:space="preserve">
          <source>True if on an OS where qx operator (or backticks) can redirect &lt;code&gt;STDERR&lt;/code&gt; onto &lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">如果在qx运算符（或反引号）可以将 &lt;code&gt;STDERR&lt;/code&gt; 重定向到 &lt;code&gt;STDOUT&lt;/code&gt; 的操作系统上，则为true 。</target>
        </trans-unit>
        <trans-unit id="93fe8e82ddc3a4dc6131ed9782aa5f9370ee777e" translate="yes" xml:space="preserve">
          <source>True if on an OS where qx operator (or backticks) can redirect &lt;code&gt;STDERR&lt;/code&gt; onto &lt;code&gt;STDOUT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ac2287aae7e1950a35f3972fa5317afd518e160" translate="yes" xml:space="preserve">
          <source>True if the &lt;code&gt;callback($hub)&lt;/code&gt; method on the event should be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69954ea7da329e8cdabdea3ecd3ac1d75fce20fd" translate="yes" xml:space="preserve">
          <source>True if the assertion passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df801d4537bfb58354fb108cdce7113cab9309ef" translate="yes" xml:space="preserve">
          <source>True if the event contains diagnostics info. This is useful because a non-verbose harness may choose to hide events that are not in this category. Some formatters may choose to send these to STDERR instead of STDOUT to ensure they are seen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a8b59f97958ff045f6c01f8b83b5a2e2ebdf5c" translate="yes" xml:space="preserve">
          <source>True if the event is global in nature and should be seen by all hubs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd2a61baedabf880cbaef8af523d638bf533482" translate="yes" xml:space="preserve">
          <source>True if the event should be skipped by formatters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ea7f713bb50ee451a6daabd00c2427e62cfb9f7" translate="yes" xml:space="preserve">
          <source>True if the event was buffered and not sent to the formatter independent of a parent (This should never be set when nested is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;undef&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52369ee8420cce3f1adcdcc979064876449bf33b" translate="yes" xml:space="preserve">
          <source>True if the socket is currently positioned at the urgent data mark, false otherwise.</source>
          <target state="translated">如果当前套接字定位在紧急数据标记处,则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="eac6f6323bc5d7181c78c2fb3ebd2b5d82dd47f8" translate="yes" xml:space="preserve">
          <source>True if the socket is currently positioned at the urgent data mark, false otherwise. If your system doesn't yet implement &lt;code&gt;sockatmark&lt;/code&gt; this will throw an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263df4a03022b2922b4599d5befe15e4f094944e" translate="yes" xml:space="preserve">
          <source>True if the source has meta data.</source>
          <target state="translated">如果源有元数据,则为真。</target>
        </trans-unit>
        <trans-unit id="1060dac952d58237b926360d8015317b306f2cf6" translate="yes" xml:space="preserve">
          <source>True if the subtest is buffered (meaning the formatter has probably not seen them yet).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead298b6e06af0e6aa6b218dfc1434b74a59946d" translate="yes" xml:space="preserve">
          <source>True if the subtest is buffered, that is all subevents render at once. If this is false it means all subevents render as they are produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4532ad71a145630727fdc99e9e7077d2ca07a8f" translate="yes" xml:space="preserve">
          <source>True if the system can really fork. This will be false for systems where fork is emulated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5626c52704625d46d51a67bed3154dc66584552" translate="yes" xml:space="preserve">
          <source>True if the testing has ended. This MAY return the stack frame of the tool that ended the test, but that is not guaranteed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="001c945275af8c53e929fc8bb52b9331e9fa2beb" translate="yes" xml:space="preserve">
          <source>True if this op will be the return value of an lvalue subroutine</source>
          <target state="translated">如果这个操作是一个lvalue子程序的返回值,则为true。</target>
        </trans-unit>
        <trans-unit id="407715ca6f2feb3c98182b0f933855e8539ff50e" translate="yes" xml:space="preserve">
          <source>True if this system is capable of true or pseudo-fork.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5d7ce97ba71eed0cb8d5f95d0b08ebce27950e" translate="yes" xml:space="preserve">
          <source>True if this system is capable of using threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a225ab817ea7fa5d168aaeda6fa091c3d9bf26a1" translate="yes" xml:space="preserve">
          <source>True is returned if the file name begins with &lt;code&gt;drive_letter:&lt;/code&gt; , and if not, File::Spec::Unix file_name_is_absolute() is called.</source>
          <target state="translated">如果文件名以 &lt;code&gt;drive_letter:&lt;/code&gt; 开头，则返回True ，否则，返回File :: Spec :: Unix file_name_is_absolute（）。</target>
        </trans-unit>
        <trans-unit id="feb89466cc01669fa065abcba450c743f09dda61" translate="yes" xml:space="preserve">
          <source>True is returned if the file name begins with &lt;code&gt;drive_letter:&lt;/code&gt;, and if not, File::Spec::Unix file_name_is_absolute() is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc30aa25ff3d01d64cda3e60440cb70eb23d7d54" translate="yes" xml:space="preserve">
          <source>True only if the version object is a dotted-decimal version, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714a51854b847f734d4ad3e61a135b245522aeae" translate="yes" xml:space="preserve">
          <source>True while the most recent result was a TODO. Becomes true before the TODO result is returned and stays true until just before the next non- TODO test is returned.</source>
          <target state="translated">当最近的结果是TODO时为真。在TODO结果返回之前变为真,并保持真,直到下一个非TODO测试返回之前。</target>
        </trans-unit>
        <trans-unit id="1aceee4ee4f49927d115b3fc82be6c512d7c286c" translate="yes" xml:space="preserve">
          <source>True/false results are never tainted.</source>
          <target state="translated">真/假结果永远不会被污染。</target>
        </trans-unit>
        <trans-unit id="f8dc96e0b59ea3e8174d5b669fb89eb4295305d3" translate="yes" xml:space="preserve">
          <source>Truncate $x to an integer value.</source>
          <target state="translated">将$x截断为一个整数值。</target>
        </trans-unit>
        <trans-unit id="191dfbc6a35e73fdb5087a2421ab0ece27f48615" translate="yes" xml:space="preserve">
          <source>Truncate at end-of-file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11625b03167a879105d56ac5232340fe7c1e8727" translate="yes" xml:space="preserve">
          <source>Truncate file suggested by open mode.</source>
          <target state="translated">按打开模式建议截断文件。</target>
        </trans-unit>
        <trans-unit id="7b41166934a48e946fe5af0522939c8c4005a23a" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69983876ff90a7fef773e08a772b817cd9bc808d" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">将在FILEHANDLE上打开的文件或由EXPR命名的文件截断为指定的长度。如果未在系统上实现截断，则引发异常。如果成功，则返回true，否则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6b7268dfdb3e49fbc8b9714eadb8dee9d853cfb" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">将在FILEHANDLE上打开的文件或由EXPR命名的文件截断为指定的长度。如果未在系统上实现截断，则引发异常。如果成功，则返回true，否则返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59f6a9fc2fffb15b78c0b81473cdfd56174958cf" translate="yes" xml:space="preserve">
          <source>Truncation</source>
          <target state="translated">Truncation</target>
        </trans-unit>
        <trans-unit id="2975c0f92fcae4101065548cc1a5e6bfa7744574" translate="yes" xml:space="preserve">
          <source>Truncation to same-or-shorter lengths only. (VOS)</source>
          <target state="translated">只截断到相同或较短的长度。(VOS)</target>
        </trans-unit>
        <trans-unit id="07fcbd4e35869ee7c3769699235ad97c3caf7ea4" translate="yes" xml:space="preserve">
          <source>Truth and Falsehood</source>
          <target state="translated">真相与假象</target>
        </trans-unit>
        <trans-unit id="0ea36a88c9652f7de32e4b8cdc539660f9c8bb67" translate="yes" xml:space="preserve">
          <source>Truth. (&lt;code&gt;PL_sv_yes&lt;/code&gt; ) The value is not needed (and ignored).</source>
          <target state="translated">真相。（ &lt;code&gt;PL_sv_yes&lt;/code&gt; ）不需要（忽略）该值。</target>
        </trans-unit>
        <trans-unit id="fec0d66775a5a838fdce0113e0fc71a37b212e7d" translate="yes" xml:space="preserve">
          <source>Truth. (&lt;code&gt;PL_sv_yes&lt;/code&gt;) The value is not needed (and ignored).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820aa128934b824418f5ca61678f5828e0a9f3f1" translate="yes" xml:space="preserve">
          <source>Try 'which ld' and 'which ld' (or try 'ar --version' and 'ld --version', which work only for the GNU tools, and will announce themselves to be such), and adjust your PATH so that you are consistently using either the native tools or the GNU tools. After fixing your PATH, you should do 'make distclean' and start all the way from running the Configure since you may have quite a confused situation.</source>
          <target state="translated">试试 &quot;which ld &quot;和 &quot;which ld&quot;(或者试试 &quot;ar --version &quot;和 &quot;ld --version&quot;,它们只对GNU工具有效,而且会自报家门),然后调整你的PATH,使你始终使用本地工具或GNU工具。修正PATH后,你应该执行'make distclean',然后从运行Configure开始,因为你可能会遇到相当混乱的情况。</target>
        </trans-unit>
        <trans-unit id="98c21aef49a5ddf4f1e39c55f7f2477e1906d688" translate="yes" xml:space="preserve">
          <source>Try &lt;code&gt;perldoc Amiga::ARexx&lt;/code&gt; for more info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e033ddf358a130409c1ab5546e94f94b80bcb2f" translate="yes" xml:space="preserve">
          <source>Try &lt;code&gt;perldoc Amiga::Exec&lt;/code&gt; for more info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfec8d0f349c3c42fb9d1815573a589ac82ef522" translate="yes" xml:space="preserve">
          <source>Try and match a closing delimiter bracket. If the bracket was the same species as the last opening bracket, return the substring to that point. If the bracket was mismatched, return an error.</source>
          <target state="translated">试着匹配一个关闭的分隔符括号。如果括号与最后一个打开的括号是同一物种,返回到该点的子串。如果括号不匹配,则返回一个错误。</target>
        </trans-unit>
        <trans-unit id="3534e8ec8243f82da173a0a961f29a6061ccc5a4" translate="yes" xml:space="preserve">
          <source>Try every conceivable way to get hostname</source>
          <target state="translated">尝试所有能想到的方法来获取主机名。</target>
        </trans-unit>
        <trans-unit id="dfea66ec3b5d472c8a85f9f4143d2c2a2932e7a3" translate="yes" xml:space="preserve">
          <source>Try hard not to exceed 79-columns</source>
          <target state="translated">尽量不要超过79列</target>
        </trans-unit>
        <trans-unit id="71156f6966e318bbb69b3350da865612c3413590" translate="yes" xml:space="preserve">
          <source>Try keeping around the seekpointer and go there, like this:</source>
          <target state="translated">试着保持在seekpointer周围,然后去那里,像这样。</target>
        </trans-unit>
        <trans-unit id="5ab49ef558819708ac26895c52750c3610705d02" translate="yes" xml:space="preserve">
          <source>Try not to launch headlong into developing your module without spending some time thinking first. A little forethought may save you a vast amount of effort later on.</source>
          <target state="translated">尽量不要在没有先花一些时间思考的情况下,就一头扎进开发你的模块。一点点的预想可能会让你以后省去大量的精力。</target>
        </trans-unit>
        <trans-unit id="66c86b400f1e32f25dbc921f7ed16eeea4ab2376" translate="yes" xml:space="preserve">
          <source>Try the &lt;a href=&quot;Net::FTP&quot;&gt;Net::FTP&lt;/a&gt;, &lt;a href=&quot;TCP::Client&quot;&gt;TCP::Client&lt;/a&gt;, and &lt;a href=&quot;Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; modules (available from CPAN). &lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt; will also help for emulating the telnet protocol, but &lt;a href=&quot;Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; is quite probably easier to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2b567df2700cceb3e59d9f8a3eb3ca3092a77c" translate="yes" xml:space="preserve">
          <source>Try the &lt;a href=&quot;net/ftp&quot;&gt;Net::FTP&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/TCP::Client&quot;&gt;TCP::Client&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; modules (available from CPAN). &lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt; will also help for emulating the telnet protocol, but &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; is quite probably easier to use.</source>
          <target state="translated">尝试使用&lt;a href=&quot;net/ftp&quot;&gt;Net :: FTP&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/TCP::Client&quot;&gt;TCP :: Client&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt;模块（可从CPAN获得）。&lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt;也将有助于模拟telnet协议，但是&lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt;可能更易于使用。</target>
        </trans-unit>
        <trans-unit id="87f2df3af873276d11f18dcdfa6067907516ef82" translate="yes" xml:space="preserve">
          <source>Try the first alternative in the first group 'abd'.</source>
          <target state="translated">试试第一组的第一个备选方案'abd'。</target>
        </trans-unit>
        <trans-unit id="8fdc9fd893f9837a30290ddcdb863de474cd49f7" translate="yes" xml:space="preserve">
          <source>Try the native, UDP socket then UNIX domain socket mechanisms:</source>
          <target state="translated">试试本机、UDP套接字然后UNIX域套接字机制。</target>
        </trans-unit>
        <trans-unit id="6a75e271162bdc3d061e3493d3ce114d627fc256" translate="yes" xml:space="preserve">
          <source>Try the resources in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;.</source>
          <target state="translated">试用&lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2中&lt;/a&gt;的资源。</target>
        </trans-unit>
        <trans-unit id="aacef041b76d57895de9d7f5cee32482707bd3b3" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict qw(...);&lt;/code&gt; ). Remember that you can add &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict qw(...);&lt;/code&gt; to individual blocks of code that need less strictness.</source>
          <target state="translated">尝试 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict qw(...);&lt;/code&gt; ）。请记住，您不能添加 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict qw(...);&lt;/code&gt; 不需要那么严格的单个代码块。</target>
        </trans-unit>
        <trans-unit id="dbe02bedd5bb36eab5b4bbe32b7d4940cf95d2ec" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings qw(...);&lt;/code&gt; ). Remember that you can add &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(...);&lt;/code&gt; to individual blocks of code that need less warnings.</source>
          <target state="translated">尝试 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings qw(...);&lt;/code&gt; ）。请记住，您不能添加 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(...);&lt;/code&gt; 到需要较少警告的单个代码块。</target>
        </trans-unit>
        <trans-unit id="38b826b6e348509b8760d8f24eae463b23ce7bf6" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;use strict;&lt;/code&gt; (or &lt;code&gt;use strict qw(...);&lt;/code&gt;). Remember that you can add &lt;code&gt;no strict qw(...);&lt;/code&gt; to individual blocks of code that need less strictness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf7f5a326028f0c812e9c509d8082b45d0e5a3e" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;use warnings;&lt;/code&gt; (or &lt;code&gt;use warnings qw(...);&lt;/code&gt;). Remember that you can add &lt;code&gt;no warnings qw(...);&lt;/code&gt; to individual blocks of code that need less warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a50d23e31ca789a858a654feff08b918836c974" translate="yes" xml:space="preserve">
          <source>Try to color output. See &lt;a href=&quot;../tap/formatter/base#new&quot;&gt;new in TAP::Formatter::Base&lt;/a&gt;.</source>
          <target state="translated">尝试彩色输出。参见&lt;a href=&quot;../tap/formatter/base#new&quot;&gt;TAP :: Formatter :: Base中的新增内容&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56802a31d085c41de140ede22328a67086473d5e" translate="yes" xml:space="preserve">
          <source>Try to color output. See &lt;a href=&quot;TAP::Formatter::Base#new&quot;&gt;&quot;new&quot; in TAP::Formatter::Base&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e97a54a5e20ef4c3c124d4963b017c39c1dad7b" translate="yes" xml:space="preserve">
          <source>Try to design the new module to be easy to extend and reuse.</source>
          <target state="translated">尽量将新模块设计成易于扩展和复用。</target>
        </trans-unit>
        <trans-unit id="220ea4d529b6fa37d1fa97bbb19f2fed77ce5e5b" translate="yes" xml:space="preserve">
          <source>Try to determine name of extension being built. We begin with the name of the current directory. Since VMS filenames are case-insensitive, however, we look for a</source>
          <target state="translated">尝试确定正在构建的扩展名。我们从当前目录的名称开始。由于VMS文件名是不区分大小写的,因此,我们寻找一个</target>
        </trans-unit>
        <trans-unit id="909a91fc6d3b48263691b246eef6c09eb4ec3bfc" translate="yes" xml:space="preserve">
          <source>Try to determine the width of the screen and the bold and underline sequences for the terminal from termcap, and use that information in formatting the output. Output will be wrapped at two columns less than the width of your terminal device. Using this option requires that your system have a termcap file somewhere where Term::Cap can find it and requires that your system support termios. With this option, the output of &lt;b&gt;pod2text&lt;/b&gt; will contain terminal control sequences for your current terminal type.</source>
          <target state="translated">尝试从termcap确定屏幕的宽度以及终端的粗体和下划线序列，并在格式化输出时使用该信息。输出将包裹在小于终端设备宽度的两列中。使用此选项要求您的系统在Term :: Cap可以找到的地方有一个termcap文件，并要求您的系统支持termios。使用此选项，&lt;b&gt;pod2text&lt;/b&gt;的输出将包含您当前终端类型的终端控制序列。</target>
        </trans-unit>
        <trans-unit id="08f15a05901602892a511e670ab4aa0307df4226" translate="yes" xml:space="preserve">
          <source>Try to document your code and use Pod formatting in a consistent way. Here are commonly expected conventions:</source>
          <target state="translated">尽量以一致的方式记录你的代码和使用Pod格式。以下是通常预期的约定。</target>
        </trans-unit>
        <trans-unit id="c88c728349f5a2409f402906caa2d933f74c0865" translate="yes" xml:space="preserve">
          <source>Try to match a quote or quotelike operator. If found, call &lt;code&gt;extract_quotelike&lt;/code&gt; to eat it. If &lt;code&gt;extract_quotelike&lt;/code&gt; fails, return the error it returned. Otherwise go back to step 1.</source>
          <target state="translated">尝试匹配一个quote或quotelike运算符。如果找到，请调用 &lt;code&gt;extract_quotelike&lt;/code&gt; 食用。如果 &lt;code&gt;extract_quotelike&lt;/code&gt; 失败，则返回它返回的错误。否则，请返回步骤1。</target>
        </trans-unit>
        <trans-unit id="fed009e07cf40a3bfaccb23b101b1df3951ecefd" translate="yes" xml:space="preserve">
          <source>Try to match an opening delimiter bracket. If found, call &lt;code&gt;extract_codeblock&lt;/code&gt; recursively to eat the embedded block. If the recursive call fails, return an error. Otherwise, go back to step 1.</source>
          <target state="translated">尝试匹配一个分隔符。如果找到，则递归调用 &lt;code&gt;extract_codeblock&lt;/code&gt; 来吃嵌入式块。如果递归调用失败，则返回错误。否则，请返回步骤1。</target>
        </trans-unit>
        <trans-unit id="1bf160ae95bc79040defdb4258d5fad8caa20a29" translate="yes" xml:space="preserve">
          <source>Try to obtain the latest version of the Windows SDK. Sometimes these packages contain a particular Windows OS version in their name, but actually work on other OS versions too. For example, the &quot;Windows Server 2003 R2 Platform SDK&quot; also runs on Windows XP SP2 and Windows 2000.</source>
          <target state="translated">尝试获取最新版本的Windows SDK。有时,这些软件包的名称中包含一个特定的Windows操作系统版本,但实际上也可以在其他操作系统版本上运行。例如,&quot;Windows Server 2003 R2 Platform SDK &quot;也可以在Windows XP SP2和Windows 2000上运行。</target>
        </trans-unit>
        <trans-unit id="962ca701cc2570a663505435d963dc55f234f4d9" translate="yes" xml:space="preserve">
          <source>Trying to create a new child with a previous child still active (i.e., &lt;code&gt;finalize&lt;/code&gt; not called) will &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">尝试创建一个新的孩子并使其先前的孩子仍然处于活动状态（即，未调用 &lt;code&gt;finalize&lt;/code&gt; ）将 &lt;code&gt;croak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0c592184c4820418323672dd4337df40c4098b0" translate="yes" xml:space="preserve">
          <source>Trying to do too much</source>
          <target state="translated">试图做得太多</target>
        </trans-unit>
        <trans-unit id="44d272c0c6193575553012dfbe62f22573eeb82f" translate="yes" xml:space="preserve">
          <source>Trying to run a test when you have an open child will also &lt;code&gt;croak&lt;/code&gt; and cause the test suite to fail.</source>
          <target state="translated">当您有一个开放的孩子时，尝试运行测试也会 &lt;code&gt;croak&lt;/code&gt; 并导致测试套件失败。</target>
        </trans-unit>
        <trans-unit id="e1251ee8a07b3dea6c343e31961e5913e11f0ce3" translate="yes" xml:space="preserve">
          <source>Tune the internal settings for the deflate object &lt;code&gt;$d&lt;/code&gt; . This option is only available if you are running zlib 1.2.2.3 or better.</source>
          <target state="translated">调整deflate对象 &lt;code&gt;$d&lt;/code&gt; 的内部设置。仅当您运行zlib 1.2.2.3或更高版本时，此选项才可用。</target>
        </trans-unit>
        <trans-unit id="3896985029531ee0a442a6eafffd21b16e99bab0" translate="yes" xml:space="preserve">
          <source>Tune the internal settings for the deflate object &lt;code&gt;$d&lt;/code&gt;. This option is only available if you are running zlib 1.2.2.3 or better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008eee580921a65a5e935994d388ebe43c6df0cd" translate="yes" xml:space="preserve">
          <source>Tuning the way RESOLVE_SYMLINK will works</source>
          <target state="translated">调整RESOLVE_SYMLINK的工作方式。</target>
        </trans-unit>
        <trans-unit id="8c3f4c8cc5ca57e1d0107a8c0347eb3646189c97" translate="yes" xml:space="preserve">
          <source>Tunnelling &lt;code&gt;https&lt;/code&gt; over an &lt;code&gt;http&lt;/code&gt; proxy using the CONNECT method is supported. If your proxy uses &lt;code&gt;https&lt;/code&gt; itself, you can not tunnel &lt;code&gt;https&lt;/code&gt; over it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7153e6702b4ea48c7c0d01affdef0e1b39fd6dc" translate="yes" xml:space="preserve">
          <source>Turkey</source>
          <target state="translated">Turkey</target>
        </trans-unit>
        <trans-unit id="f7db0bf3a9c02aa40e34f07d8431257fcf327327" translate="yes" xml:space="preserve">
          <source>Turn =head1 directives into links pointing to the top of the HTML file.</source>
          <target state="translated">将=head1指令变成指向HTML文件顶部的链接。</target>
        </trans-unit>
        <trans-unit id="00eb812c53d2b2fc577cde21da51d4b0a2dbeaba" translate="yes" xml:space="preserve">
          <source>Turn IPC off</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f87dc87ea378d835e56e5bfd248ea1a352c832" translate="yes" xml:space="preserve">
          <source>Turn Pod into XML</source>
          <target state="translated">将Pod转为XML</target>
        </trans-unit>
        <trans-unit id="8e7cc74dfcc71c13798fc4a8a0bda3cb164ed4c1" translate="yes" xml:space="preserve">
          <source>Turn Pod::Simple events into method calls</source>
          <target state="translated">将Pod::Simple事件转化为方法调用</target>
        </trans-unit>
        <trans-unit id="87a4a4a475f00352f77a10d3ec1fd9eee936c4ee" translate="yes" xml:space="preserve">
          <source>Turn off Apple tar's tendency to copy resource forks as &quot;._foo&quot; files.</source>
          <target state="translated">关闭 Apple tar 将资源叉复制为&quot;._foo &quot;文件的倾向。</target>
        </trans-unit>
        <trans-unit id="002da87886e80eee99a8ca6dc4e3fe4cabdcf032" translate="yes" xml:space="preserve">
          <source>Turn off CPAN.pm's attempts to lock anything. You should be careful with this since you might end up with multiple scripts trying to muck in the same directory. This isn't so much of a concern if you're loading a special config with &lt;code&gt;-j&lt;/code&gt;, and that config sets up its own work directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75c822c937f705b4f59deefb9b7306dfc70d6869" translate="yes" xml:space="preserve">
          <source>Turn off IPC polling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f985f0fcda86b1c258609df3d266b43ed8ce4a" translate="yes" xml:space="preserve">
          <source>Turn on IPC for threading or forking support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d8224908b27731eb611ee5800a332f08bd6efe" translate="yes" xml:space="preserve">
          <source>Turn on colour in Test::Builder::Tester</source>
          <target state="translated">在 Test::Builder::Tester 中打开颜色。</target>
        </trans-unit>
        <trans-unit id="33bdb8453820e783c9ed80ead4da0eab3e622342" translate="yes" xml:space="preserve">
          <source>Turn on cpan warnings. This checks various things, like directory permissions, and tells you about problems you might have.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aaaf6cc176020f3991943f2032de33eccbdb645" translate="yes" xml:space="preserve">
          <source>Turn on debugging messages.</source>
          <target state="translated">开启调试信息。</target>
        </trans-unit>
        <trans-unit id="987617e4099bb6d10ab491d6ac24dec67dd616d3" translate="yes" xml:space="preserve">
          <source>Turn on polling. This will cull events from other processes and threads every time a context is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5afa3624933dbb94708b864157bd75149a4bc45" translate="yes" xml:space="preserve">
          <source>Turn on the UTF-8 status of an SV (the data is not changed, just the flag). Do not use frivolously.</source>
          <target state="translated">开启SV的UTF-8状态(数据不改变,只是标志)。不要轻率使用。</target>
        </trans-unit>
        <trans-unit id="58ffd65543f8495b744e9f3f6c44eb3bd2d31977" translate="yes" xml:space="preserve">
          <source>Turn on the escaping of characters as described in the SPACES AND TABS section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9903e627171cb3011421fef7af4a686d6ebc3e08" translate="yes" xml:space="preserve">
          <source>Turn on/off printing of warnings. Repeating &lt;b&gt;-warnings&lt;/b&gt; increases the warning level, i.e. more warnings are printed. Currently increasing to level two causes flagging of unescaped &quot;&amp;lt;,&amp;gt;&quot; characters.</source>
          <target state="translated">打开/关闭警告打印。重复&lt;b&gt;警告会&lt;/b&gt;提高警告级别，即打印更多警告。当前增加到第二级会导致标记未转义的&amp;ldquo; &amp;lt;，&amp;gt;&amp;rdquo;字符。</target>
        </trans-unit>
        <trans-unit id="d7dd646019946f4186b2c9415767806d113e6794" translate="yes" xml:space="preserve">
          <source>Turn warnings on/off.</source>
          <target state="translated">打开/关闭警告。</target>
        </trans-unit>
        <trans-unit id="4c628137dd54154b5661d62a2c76528177ce2c0e" translate="yes" xml:space="preserve">
          <source>Turning on one of the character set flags with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; takes precedence over the &lt;code&gt;locale&lt;/code&gt; pragma and the 'unicode_strings' &lt;code&gt;feature&lt;/code&gt; , for regular expressions. Turning off one of these flags when it is active reverts to the behaviour specified by whatever other pragmata are in scope. For example:</source>
          <target state="translated">对于正则表达式， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; 打开一个字符集标志的优先级高于 &lt;code&gt;locale&lt;/code&gt; 编译指示和&amp;ldquo; unicode_strings&amp;rdquo; &lt;code&gt;feature&lt;/code&gt; 。当这些标志之一处于活动状态时将其关闭，将恢复为其他范围内的杂物所指定的行为。例如：</target>
        </trans-unit>
        <trans-unit id="bab3f5ad74d31e2186209289e3cd6bd581941efe" translate="yes" xml:space="preserve">
          <source>Turning on one of the character set flags with &lt;code&gt;use re&lt;/code&gt; takes precedence over the &lt;code&gt;locale&lt;/code&gt; pragma and the 'unicode_strings' &lt;code&gt;feature&lt;/code&gt;, for regular expressions. Turning off one of these flags when it is active reverts to the behaviour specified by whatever other pragmata are in scope. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dac2f62695f453fd439059f0a117cf373d1f773" translate="yes" xml:space="preserve">
          <source>Turns every &lt;code&gt;head1&lt;/code&gt; heading into a link back to the top of the page. By default, no backlinks are generated.</source>
          <target state="translated">将每个 &lt;code&gt;head1&lt;/code&gt; 标题转换为指向页面顶部的链接。默认情况下，不生成任何反向链接。</target>
        </trans-unit>
        <trans-unit id="488b4a24fda23c677bfd758dfeda4e2b3e28ea5b" translate="yes" xml:space="preserve">
          <source>Turns on all &quot;extra&quot; debugging options.</source>
          <target state="translated">开启所有 &quot;额外 &quot;的调试选项。</target>
        </trans-unit>
        <trans-unit id="8a6abc6af101e3e68b329eb351f149732ea8c3d9" translate="yes" xml:space="preserve">
          <source>Turns on all compile related debug options.</source>
          <target state="translated">开启所有与编译相关的调试选项。</target>
        </trans-unit>
        <trans-unit id="377f42734b94211c01fa848b2645c0c159ecedcd" translate="yes" xml:space="preserve">
          <source>Turns on all execute related debug options.</source>
          <target state="translated">开启所有与执行相关的调试选项。</target>
        </trans-unit>
        <trans-unit id="16cf0e466a4f6fe0b3456839377f934eda051d4e" translate="yes" xml:space="preserve">
          <source>Turns on all non-extra compile related debug options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0c3643227c9fa0f255763a21a1f9559b3e9dd1" translate="yes" xml:space="preserve">
          <source>Turns on all non-extra execute related debug options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf78d64b4c15f8d89c3f09aea595a015508f3471" translate="yes" xml:space="preserve">
          <source>Turns on autoflush, print ARGS and then restores the autoflush status of the &lt;code&gt;IO::Handle&lt;/code&gt; object. Returns the return value from print.</source>
          <target state="translated">打开自动刷新，打印ARGS，然后恢复 &lt;code&gt;IO::Handle&lt;/code&gt; 对象的自动刷新状态。返回打印的返回值。</target>
        </trans-unit>
        <trans-unit id="2d1676fcc040bdf1deeab307eee1f9a1faa4d87a" translate="yes" xml:space="preserve">
          <source>Turns on debug output related to the process of parsing the pattern.</source>
          <target state="translated">开启与模式解析过程相关的调试输出。</target>
        </trans-unit>
        <trans-unit id="80ae89d796a9f5474c9cf55351133039b045499c" translate="yes" xml:space="preserve">
          <source>Turns on debugging</source>
          <target state="translated">开启调试</target>
        </trans-unit>
        <trans-unit id="0b71618ab3c580ced56e12be5afa8ca78d10b841" translate="yes" xml:space="preserve">
          <source>Turns on debugging of the main matching loop.</source>
          <target state="translated">开启主匹配循环的调试。</target>
        </trans-unit>
        <trans-unit id="821dfaade517bc8af20717058964e6e45387b304" translate="yes" xml:space="preserve">
          <source>Turns on the magical status of an SV. See &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d12b512bcc17c858f7f78847cab2c7f6461efd3" translate="yes" xml:space="preserve">
          <source>Turns on the magical status of an SV. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">打开SV的魔法状态。参见 &lt;code&gt;sv_magic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5ed69f1e400ca234d376650a653b6521d5c1651" translate="yes" xml:space="preserve">
          <source>Turns the @metadata_pairs into YAML.</source>
          <target state="translated">将@metadata_pairs变成YAML。</target>
        </trans-unit>
        <trans-unit id="606c2af8d67a4d7dc7224ecdbb198b95627a3d18" translate="yes" xml:space="preserve">
          <source>Tutorial on making a new module.</source>
          <target state="translated">制作新模块的教程。</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="4106aa6fe38782986e71b6df351f9eed9adc1100" translate="yes" xml:space="preserve">
          <source>Tutorials, end-user documentation, research papers, FAQs etc are not appropriate in a module's main documentation. If you really want to write these, include them as sub-documents such as &lt;code&gt;My::Module::Tutorial&lt;/code&gt; or &lt;code&gt;My::Module::FAQ&lt;/code&gt; and provide a link in the SEE ALSO section of the main documentation.</source>
          <target state="translated">教程，最终用户文档，研究论文，常见问题解答等不适用于该模块的主要文档。如果您确实想编写这些内容，请将它们作为子文档包括在 &lt;code&gt;My::Module::Tutorial&lt;/code&gt; 或 &lt;code&gt;My::Module::FAQ&lt;/code&gt; 并在主文档的&amp;ldquo;另请参阅&amp;rdquo;部分中提供链接。</target>
        </trans-unit>
        <trans-unit id="d4f6fcebc83fe08414440f2690253120c9bf99c3" translate="yes" xml:space="preserve">
          <source>Tweak the style of B::Deparse's output. The letters should follow directly after the 's', with no space or punctuation. The following options are available:</source>
          <target state="translated">调整 B::Deparse 的输出风格。字母应该直接跟在's'后面,没有空格或标点符号。以下是可用的选项。</target>
        </trans-unit>
        <trans-unit id="8b77b783948e5ce8fbd237831d47a3e2aa25c8cf" translate="yes" xml:space="preserve">
          <source>Two additional extensions by Andreas Kaiser, &lt;code&gt;OS2::UPM&lt;/code&gt; , and &lt;code&gt;OS2::FTP&lt;/code&gt; , are included into &lt;code&gt;ILYAZ&lt;/code&gt; directory, mirrored on CPAN. Other OS/2-related extensions are available too.</source>
          <target state="translated">&lt;code&gt;ILYAZ&lt;/code&gt; 目录中包含Andreas Kaiser的另外两个扩展 &lt;code&gt;OS2::UPM&lt;/code&gt; 和 &lt;code&gt;OS2::FTP&lt;/code&gt; ，已在CPAN上进行了镜像。其他与OS / 2相关的扩展也可用。</target>
        </trans-unit>
        <trans-unit id="e1e1c471607b1953c35055b694d94ae2115e7490" translate="yes" xml:space="preserve">
          <source>Two additional extensions by Andreas Kaiser, &lt;code&gt;OS2::UPM&lt;/code&gt;, and &lt;code&gt;OS2::FTP&lt;/code&gt;, are included into &lt;code&gt;ILYAZ&lt;/code&gt; directory, mirrored on CPAN. Other OS/2-related extensions are available too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="225de66ed8612f5eaedcbe3517b9b8a030dd1dfb" translate="yes" xml:space="preserve">
          <source>Two additional fields &lt;code&gt;free&lt;/code&gt; , &lt;code&gt;used&lt;/code&gt; contain array references which provide per-bucket count of free and used chunks. Two other fields &lt;code&gt;mem_size&lt;/code&gt; , &lt;code&gt;available_size&lt;/code&gt; contain array references which provide the information about the allocated size and usable size of chunks in each bucket. Again, see &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;Using $ENV{PERL_DEBUG_MSTATS} in perldebguts&lt;/a&gt; for details.</source>
          <target state="translated">两个附加字段 &lt;code&gt;free&lt;/code&gt; ， &lt;code&gt;used&lt;/code&gt; 含有数组引用其提供可用和已用块的每桶计数。另外两个字段 &lt;code&gt;mem_size&lt;/code&gt; ， &lt;code&gt;available_size&lt;/code&gt; 包含数组引用，这些引用提供有关每个存储桶中块的已分配大小和可用大小的信息。再次，请参阅&lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;perldebguts中的使用$ ENV {PERL_DEBUG_MSTATS}以&lt;/a&gt;获取详细信息。</target>
        </trans-unit>
        <trans-unit id="645e14dd280baf021efadb33e4b6285cfb158d60" translate="yes" xml:space="preserve">
          <source>Two additional fields &lt;code&gt;free&lt;/code&gt;, &lt;code&gt;used&lt;/code&gt; contain array references which provide per-bucket count of free and used chunks. Two other fields &lt;code&gt;mem_size&lt;/code&gt;, &lt;code&gt;available_size&lt;/code&gt; contain array references which provide the information about the allocated size and usable size of chunks in each bucket. Again, see &lt;a href=&quot;perldebguts#Using-%24ENV%7BPERL_DEBUG_MSTATS%7D&quot;&gt;&quot;Using $ENV{PERL_DEBUG_MSTATS}&quot; in perldebguts&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="959e1dbe5c03b6bf54bd2c7c42f5c06de670abcf" translate="yes" xml:space="preserve">
          <source>Two arrays smartmatch if each element in the first array smartmatches (that is, is &quot;in&quot;) the corresponding element in the second array, recursively.</source>
          <target state="translated">如果第一个数组中的每个元素与第二个数组中的相应元素递归地智能匹配(即 &quot;在&quot;),则两个数组就会智能匹配。</target>
        </trans-unit>
        <trans-unit id="ef9d289482c44cedd928e08a539e06da234c1ea2" translate="yes" xml:space="preserve">
          <source>Two directories</source>
          <target state="translated">两个目录</target>
        </trans-unit>
        <trans-unit id="4932b4ce84c4a3c76d97d8ddc1677ad9583f731a" translate="yes" xml:space="preserve">
          <source>Two exceptions are fseek() and ftell(). 32-bit applications should use fseeko(3C) and ftello(3C). These will get automatically mapped to fseeko64() and ftello64().</source>
          <target state="translated">两种例外情况是fseek()和ftell(),32位应用应该使用fseeko(3C)和ftello(3C)。32位应用程序应该使用fseeko(3C)和ftello(3C)。这些会自动映射到fseeko64()和ftello64()。</target>
        </trans-unit>
        <trans-unit id="59e6099a51676c8b357d47058d648615908e9535" translate="yes" xml:space="preserve">
          <source>Two functions are provided by</source>
          <target state="translated">提供了两项功能</target>
        </trans-unit>
        <trans-unit id="362495d14b1f3b1a8e9077a2b6d2d038307cf755" translate="yes" xml:space="preserve">
          <source>Two functions are provided to perform in-memory compression/uncompression of RFC 1950 data streams. They are called &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; .</source>
          <target state="translated">提供了两个功能来执行RFC 1950数据流的内存中压缩/解压缩。它们称为 &lt;code&gt;compress&lt;/code&gt; 和 &lt;code&gt;uncompress&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60a9bef4c585c40271adbc6700cd51119d598e56" translate="yes" xml:space="preserve">
          <source>Two functions are provided to perform in-memory compression/uncompression of RFC 1950 data streams. They are called &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fae0daa00d9847553b4c2af0e0bfcf15f43ad2" translate="yes" xml:space="preserve">
          <source>Two hexadecimal numbers separated by horizontal whitespace (space or tabular characters) denoting a range of code points to include.</source>
          <target state="translated">两个十六进制数字,用水平空格(空格或表格字符)隔开,表示要包括的码点范围。</target>
        </trans-unit>
        <trans-unit id="7fe7068b60f3e31f3d2f257534aa6f46077e516b" translate="yes" xml:space="preserve">
          <source>Two hexadecimal numbers separated by horizontal whitespace (space or tabular characters) denoting a range of code points to include. The second number must not be smaller than the first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8d21d4a74e99aae1a5fc40b83d3fff90123b23" translate="yes" xml:space="preserve">
          <source>Two nested identical markup commands have been found. Generally this does not make sense.</source>
          <target state="translated">发现有两个嵌套的相同标记命令。一般情况下,这是说不通的。</target>
        </trans-unit>
        <trans-unit id="5e76b53030582383f7d551a5e77c668c449dbb3b" translate="yes" xml:space="preserve">
          <source>Two of the codes specified by the standard (XTS which is reserved for testing purposes and XXX which is for transactions where no currency is involved) are omitted.</source>
          <target state="translated">标准规定的两个代码(XTS用于测试目的,XXX用于不涉及货币的交易)被省略。</target>
        </trans-unit>
        <trans-unit id="a1d006aec19b5d26f771c4cb3b1aa7d14cd4a562" translate="yes" xml:space="preserve">
          <source>Two or more suspects remain</source>
          <target state="translated">仍有两名或更多嫌疑人</target>
        </trans-unit>
        <trans-unit id="069f392f8b693bf3f912fa721edb551769786910" translate="yes" xml:space="preserve">
          <source>Two other &quot;encapsulation&quot; macros are the PERL_GLOBAL_STRUCT and PERL_GLOBAL_STRUCT_PRIVATE (the latter turns on the former, and the former turns on MULTIPLICITY.) The PERL_GLOBAL_STRUCT causes all the internal variables of Perl to be wrapped inside a single global struct, struct perl_vars, accessible as (globals) &amp;amp;PL_Vars or PL_VarsPtr or the function Perl_GetVars(). The PERL_GLOBAL_STRUCT_PRIVATE goes one step further, there is still a single struct (allocated in main() either from heap or from stack) but there are no global data symbols pointing to it. In either case the global struct should be initialized as the very first thing in main() using Perl_init_global_struct() and correspondingly tear it down after perl_free() using Perl_free_global_struct(), please see</source>
          <target state="translated">另外两个&amp;ldquo;封装&amp;rdquo;宏是PERL_GLOBAL_STRUCT和PERL_GLOBAL_STRUCT_PRIVATE（后者打开前者，而前者打开MULTIPLICITY。）PERL_GLOBAL_STRUCT使Perl的所有内部变量都包装在单个全局结构（结构perl_vars）中，可作为（全局）＆PL_Vars或PL_VarsPtr或函数Perl_GetVars（）。 PERL_GLOBAL_STRUCT_PRIVATE进一步走了一步，仍然只有一个结构（从堆或堆栈中分配到main（）中），但是没有指向它的全局数据符号。无论哪种情况，都应该使用Perl_init_global_struct（）将全局结构初始化为main（）中的第一件事，并在使用Perl_free_global_struct（）进行perl_free（）之后将其相应地拆除</target>
        </trans-unit>
        <trans-unit id="9e4d897b2c15b7e4e4ca9fbaec8aab25f6b14e93" translate="yes" xml:space="preserve">
          <source>Two possible uses (besides ignoring the property) come to mind. A singleton class could be implemented this using the generic object. If necessary, an &lt;code&gt;init()&lt;/code&gt; method could die or ignore calls with actual objects (references), so only the generic object will ever exist.</source>
          <target state="translated">我想到了两种可能的用途（除了忽略属性）。可以使用泛型对象来实现单例类。如有必要， &lt;code&gt;init()&lt;/code&gt; 方法可能会死掉或忽略对实际对象（引用）的调用，因此只有通用对象会存在。</target>
        </trans-unit>
        <trans-unit id="b02b6a9a4575d62354db7ec75686a98545f9466d" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt; may modify files locked with &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70abff015732d480e204353f739476e826fe7dc6" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; may modify files locked with &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">两种潜在的非显而易见但传统的 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 语义是：它无限期地等待直到授予锁为止，并且其锁&lt;b&gt;仅仅是建议性的&lt;/b&gt;。这样的自由锁更加灵活，但是提供的保证却更少。这意味着，不也使用的程序 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 可以修改文件锁定与 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 。见&lt;a href=&quot;../perlport&quot;&gt;Perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</target>
        </trans-unit>
        <trans-unit id="3c9f59ec6423987c8c2fe5d0858f160205e3fc59" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; may modify files locked with &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">两种潜在的非显而易见但传统的 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 语义是：它无限期地等待直到授予锁为止，并且其锁&lt;b&gt;仅仅是建议性的&lt;/b&gt;。这样的自由锁更加灵活，但是提供的保证却更少。这意味着，不也使用的程序 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 可以修改文件锁定与 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 。见&lt;a href=&quot;perlport&quot;&gt;Perlport&lt;/a&gt;，您端口的特定文档以及系统特定的本地联机帮助页以获取详细信息。如果您正在编写可移植程序，则最好采用传统行为。（但是，如果您不是这样，那么您一如既往可以完全自由地编写自己系统的特性（有时称为&amp;ldquo;功能&amp;rdquo;。）对可移植性问题的过度依赖不会妨碍您完成工作。）</target>
        </trans-unit>
        <trans-unit id="53df84b423920613232d12c96d5eb675ef01a9db" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional flock semantics are that it waits indefinitely until the lock is granted, and that its locks are</source>
          <target state="translated">两个潜在的非显而易见但传统的羊群语义是,它无限期地等待,直到锁被授予,并且它的锁是</target>
        </trans-unit>
        <trans-unit id="778a62aee9043b393531476babc83e7e729243c9" translate="yes" xml:space="preserve">
          <source>Two special locales are worth particular mention: &quot;C&quot; and &quot;POSIX&quot;. Currently these are effectively the same locale: the difference is mainly that the first one is defined by the C standard, the second by the POSIX standard. They define the &lt;b&gt;default locale&lt;/b&gt; in which every program starts in the absence of locale information in its environment. (The</source>
          <target state="translated">值得特别提及的两个特殊语言环境：&amp;ldquo; C&amp;rdquo;和&amp;ldquo; POSIX&amp;rdquo;。当前，这些区域实际上是相同的语言环境：区别主要在于第一个由C标准定义，第二个由POSIX标准定义。它们定义了&lt;b&gt;默认语言环境&lt;/b&gt;，每个程序都在其环境中缺少语言环境信息的情况下启动。（</target>
        </trans-unit>
        <trans-unit id="001ed180b265179aa35dbaf576484db20b8f3115" translate="yes" xml:space="preserve">
          <source>Two special marker lines will bracket debugging code, like this:</source>
          <target state="translated">两条特殊的标记线会括住调试代码,像这样。</target>
        </trans-unit>
        <trans-unit id="fc4c89a57e0f51cea54d0e2e158fcc3083bc5fa2" translate="yes" xml:space="preserve">
          <source>Two threads both access &lt;code&gt;$x&lt;/code&gt; . Each thread can potentially be interrupted at any point, or be executed in any order. At the end, &lt;code&gt;$x&lt;/code&gt; could be 3 or 4, and both &lt;code&gt;$y&lt;/code&gt; and &lt;code&gt;$z&lt;/code&gt; could be 2 or 3.</source>
          <target state="translated">两个线程都访问 &lt;code&gt;$x&lt;/code&gt; 。每个线程都可能在任何时候被中断，或以任何顺序执行。最后， &lt;code&gt;$x&lt;/code&gt; 可以是3或4， &lt;code&gt;$y&lt;/code&gt; 和 &lt;code&gt;$z&lt;/code&gt; 都可以是2或3。</target>
        </trans-unit>
        <trans-unit id="ed596ad5315f7ee111b20fc3225326599075e7d0" translate="yes" xml:space="preserve">
          <source>Two threads both access &lt;code&gt;$x&lt;/code&gt;. Each thread can potentially be interrupted at any point, or be executed in any order. At the end, &lt;code&gt;$x&lt;/code&gt; could be 3 or 4, and both &lt;code&gt;$y&lt;/code&gt; and &lt;code&gt;$z&lt;/code&gt; could be 2 or 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a040608578e9e9c915007f47fc1e5b14ac218a6c" translate="yes" xml:space="preserve">
          <source>Two ways. One is to build the module normally...</source>
          <target state="translated">两种方法。一种是正常搭建模块...</target>
        </trans-unit>
        <trans-unit id="aed361ca9a7b196027b5db9a2f0828216a331df8" translate="yes" xml:space="preserve">
          <source>Two's complement (bitwise not). This is equivalent to</source>
          <target state="translated">二的补充(位上不)。这相当于</target>
        </trans-unit>
        <trans-unit id="1f8bb2682169008d50215675c388c14028479675" translate="yes" xml:space="preserve">
          <source>Two's complement (bitwise not). This is equivalent to, but faster than,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec9798b2ceec50b36efb45258055740cd070510f" translate="yes" xml:space="preserve">
          <source>Two-arg &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; is magic and can translate characters like &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, and &lt;code&gt;|&lt;/code&gt; in filenames, which is usually the wrong thing to do. &lt;a href=&quot;perlfunc#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt; and three-arg &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; don't have this problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639570380139caf69541c926ba46013c3318dc90" translate="yes" xml:space="preserve">
          <source>Two-face References</source>
          <target state="translated">双面参考</target>
        </trans-unit>
        <trans-unit id="ae90b2c9e3f2f4b661468b3ddaef859dd9bff8a2" translate="yes" xml:space="preserve">
          <source>Two-face Scalars</source>
          <target state="translated">双面疤痕</target>
        </trans-unit>
        <trans-unit id="f60980a56996745ba95f06a5f138b8e86a98d3dd" translate="yes" xml:space="preserve">
          <source>Tye McQueen, tye@metronet.com, http://perlmonks.org/?node=tye.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47708aacd7aae4d98506843c2ea25848ad8c524c" translate="yes" xml:space="preserve">
          <source>Tying Arrays</source>
          <target state="translated">捆绑数组</target>
        </trans-unit>
        <trans-unit id="29fe0e127980eab253dd9684cf8924d1439a9c07" translate="yes" xml:space="preserve">
          <source>Tying Arrays by Casey West &amp;lt;</source>
          <target state="translated">凯西&amp;middot;韦斯特（Casey West）的捆绑阵列&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cb864932b4ba6b40040bda147b28500825da685" translate="yes" xml:space="preserve">
          <source>Tying FileHandles</source>
          <target state="translated">绑定FileHandles</target>
        </trans-unit>
        <trans-unit id="c44951e9133e5d8875fa8e60d17eb7ca4e5ec846" translate="yes" xml:space="preserve">
          <source>Tying Hashes</source>
          <target state="translated">捆绑哈希值</target>
        </trans-unit>
        <trans-unit id="c124692dc36c13d6ea9eefe451091514b3053308" translate="yes" xml:space="preserve">
          <source>Tying Scalars</source>
          <target state="translated">绑扎疤痕</target>
        </trans-unit>
        <trans-unit id="dd441f6c670bdd175a4a06606b3ade32864a5013" translate="yes" xml:space="preserve">
          <source>Tying to an already-opened filehandle</source>
          <target state="translated">绑定到一个已经打开的文件柄上</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="b987ff7b7058c91b5723d0647b696ba512fc503e" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake install&quot; (or &quot;gmake install&quot;, &quot;nmake install&quot;). This will put the newly built perl and the libraries under whatever &lt;code&gt;INST_TOP&lt;/code&gt; points to in the Makefile. It will also install the pod documentation under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; and HTML versions of the same under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622fe690390119c9b2836b529615b923c08f64da" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake install&quot; (or &quot;nmake install&quot;). This will put the newly built perl and the libraries under whatever &lt;code&gt;INST_TOP&lt;/code&gt; points to in the Makefile. It will also install the pod documentation under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; and HTML versions of the same under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt; .</source>
          <target state="translated">键入&amp;ldquo; dmake install&amp;rdquo;（或&amp;ldquo; nmake install&amp;rdquo;）。这会将新建的perl和库放在 &lt;code&gt;INST_TOP&lt;/code&gt; 所指向的Makefile中。它还将在 &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; 下安装pod文档，并在 &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt; 下安装相同的HTML版本。</target>
        </trans-unit>
        <trans-unit id="0bc4b446d209674d0e9fea7244b04c4c376a3eb5" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake test&quot; (or &quot;gmake test&quot;, &quot;nmake test&quot;). This will run most of the tests from the testsuite (many tests will be skipped).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48996994efbc36adb9197c655f8807f921339671" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake test&quot; (or &quot;nmake test&quot;). This will run most of the tests from the testsuite (many tests will be skipped).</source>
          <target state="translated">输入 &quot;dmake test&quot; (或 &quot;nmake test&quot;)。这将运行testuite中的大部分测试 (许多测试将被跳过)。</target>
        </trans-unit>
        <trans-unit id="ce74e5125b2ce8cfe1e9037bd6ca72c9f8e02d8e" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake&quot; (&quot;gmake&quot; for GNU make, or &quot;nmake&quot; if you are using that make).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e707f55e50471f8dc7a11eb61a45491656e65c20" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake&quot; (or &quot;nmake&quot; if you are using that make).</source>
          <target state="translated">输入 &quot;dmake&quot;(或 &quot;nmake&quot;,如果你使用的是make)。</target>
        </trans-unit>
        <trans-unit id="817cc5b4f0c413465ec1e98078f923e58ba436f8" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;perl -v&lt;/code&gt; at the command line to find out.</source>
          <target state="translated">在命令行中键入 &lt;code&gt;perl -v&lt;/code&gt; 进行查找。</target>
        </trans-unit>
        <trans-unit id="9226639af847a9b60c06b437bbd1474fd6ad1ed2" translate="yes" xml:space="preserve">
          <source>Type =&amp;gt; INT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4464e66323935602a00348988e0d51aae9ab21" translate="yes" xml:space="preserve">
          <source>Type flag for I/O objects. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="470a91ba8a41cc959ff1b12a936c2603408f2a81" translate="yes" xml:space="preserve">
          <source>Type flag for I/O objects. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">I / O对象的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0214e8a20ca847239102bda8ea4c8f57bc680a1d" translate="yes" xml:space="preserve">
          <source>Type flag for arrays. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115e0f5825d2a5e2437586f43a3052a4bc413be2" translate="yes" xml:space="preserve">
          <source>Type flag for arrays. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">数组的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b619926ff72ff70acdcfb56667bc380fd10917da" translate="yes" xml:space="preserve">
          <source>Type flag for formats. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5424ebb415da653ce11cbaa80efe5caaa204e71c" translate="yes" xml:space="preserve">
          <source>Type flag for formats. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">输入格式标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="862128cc96218003cbfad3b7ee14c34ad3105872" translate="yes" xml:space="preserve">
          <source>Type flag for hashes. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f3d189f9118d5a6a717d6df4d8bfc5dd5c80fb" translate="yes" xml:space="preserve">
          <source>Type flag for hashes. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">输入哈希标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9baa4a58d00e83fc0bcce1af37a4d54939255e4" translate="yes" xml:space="preserve">
          <source>Type flag for regular expressions. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7697ce082ff72de4bd1f6e232aec1e708c3e949b" translate="yes" xml:space="preserve">
          <source>Type flag for regular expressions. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">正则表达式的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68fd7e6db2e32b4d1268770600fb508ba841fcb6" translate="yes" xml:space="preserve">
          <source>Type flag for scalars. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8842ec0ce8ceed5f394b670f4b4d43838af8af85" translate="yes" xml:space="preserve">
          <source>Type flag for scalars. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">输入标量的标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc19461206b9d4e886495f08f330852592ae56f4" translate="yes" xml:space="preserve">
          <source>Type flag for scalars. See &lt;a href=&quot;perlapi#svtype&quot;&gt;&quot;svtype&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc3eaa4bcf13a8b0cfd50d989093647d196bc08a" translate="yes" xml:space="preserve">
          <source>Type flag for subroutines. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba6e0906867866e6b4c76c1aa73ce8fb1ddab2a4" translate="yes" xml:space="preserve">
          <source>Type flag for subroutines. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">子例程的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b728a87739a1b53338d9a99924f6b87621554866" translate="yes" xml:space="preserve">
          <source>Type flag for typeglobs. See &lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d98af6202cdf505f81d6de89907f306acd604bb" translate="yes" xml:space="preserve">
          <source>Type flag for typeglobs. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">typeglob的类型标志。参见&lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b83265a2400fad6fae10ac8b63f66f6aa5168ddc" translate="yes" xml:space="preserve">
          <source>Type of arg %d to %s must be %s (not %s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33daa9fc448c1a401c5c6eb564a12a3b5b0309c7" translate="yes" xml:space="preserve">
          <source>Type of arg %d to &amp;amp;CORE::%s must be %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47d64cc94d0acfc0cdbf0b2c9dd711351e0f339" translate="yes" xml:space="preserve">
          <source>Type of first matching node.</source>
          <target state="translated">第一匹配节点的类型。</target>
        </trans-unit>
        <trans-unit id="82be69629fdb03e428153252cb628a3089333b85" translate="yes" xml:space="preserve">
          <source>Type-casting operator.</source>
          <target state="translated">型铸操作员。</target>
        </trans-unit>
        <trans-unit id="3c6b62766a1a668fd13ee2f54c72526e46bdd675" translate="yes" xml:space="preserve">
          <source>Type-specific attribute handlers</source>
          <target state="translated">特定类型属性处理程序</target>
        </trans-unit>
        <trans-unit id="ee3fb11d05c90c37311491cf33008925b13b487f" translate="yes" xml:space="preserve">
          <source>Type:</source>
          <target state="translated">Type:</target>
        </trans-unit>
        <trans-unit id="dacaa1ce7373acde846ee256ee267058f226c8cb" translate="yes" xml:space="preserve">
          <source>Typed lexicals</source>
          <target state="translated">打字词法</target>
        </trans-unit>
        <trans-unit id="764662b450b71457a1b7dac7680a6d81b8a030c7" translate="yes" xml:space="preserve">
          <source>Typeglob Slots</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c58169317903405f89e446350d7099fc17650c" translate="yes" xml:space="preserve">
          <source>Typeglobs and Filehandles</source>
          <target state="translated">Typeglobs和Filehandles</target>
        </trans-unit>
        <trans-unit id="c93af0f29f506026f9bce190608810109efe41de" translate="yes" xml:space="preserve">
          <source>Typeglobs are also a way to create a local filehandle using the local() operator. These last until their block is exited, but may be passed back. For example:</source>
          <target state="translated">Typeglobs 也是一种使用 local()操作符创建本地文件柄的方法。这些都会持续到它们的块被退出,但可能会被传回。例如</target>
        </trans-unit>
        <trans-unit id="ce5682fe2db39004dc33d1f245a642897d0ccef1" translate="yes" xml:space="preserve">
          <source>Typeless &lt;code&gt;abs&lt;/code&gt; or &lt;code&gt;fabs&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c854e2c86ed5ebd580cf024fab8796f99c1a0f9" translate="yes" xml:space="preserve">
          <source>Types of Nodes</source>
          <target state="translated">节点类型</target>
        </trans-unit>
        <trans-unit id="54a79ea7d31cf3e80acf5e2ca6b3eef126289136" translate="yes" xml:space="preserve">
          <source>Typical frequently used settings:</source>
          <target state="translated">典型的常用设置。</target>
        </trans-unit>
        <trans-unit id="19f0351a6e0b3a0f7afdab28ba608c9abfed4106" translate="yes" xml:space="preserve">
          <source>Typical names for the single object key are &lt;code&gt;__class_whatever__&lt;/code&gt;, or &lt;code&gt;$__dollars_are_rarely_used__$&lt;/code&gt; or &lt;code&gt;}ugly_brace_placement&lt;/code&gt;, or even things like &lt;code&gt;__class_md5sum(classname)__&lt;/code&gt;, to reduce the risk of clashing with real hashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeee45f0582f2da790f6df23acb83c5b9ac37e5b" translate="yes" xml:space="preserve">
          <source>Typical usage is just:</source>
          <target state="translated">典型的用法是刚。</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">典型用途:</target>
        </trans-unit>
        <trans-unit id="f0a20c31caa817cfde9a5903c8d1331d2cc5ddae" translate="yes" xml:space="preserve">
          <source>Typical use is to do range checks on &lt;code&gt;uv&lt;/code&gt; before casting:</source>
          <target state="translated">典型用途是在投射前对 &lt;code&gt;uv&lt;/code&gt; 进行范围检查：</target>
        </trans-unit>
        <trans-unit id="0f7c555ca8af58d8be6641bce4c54e1f92594d54" translate="yes" xml:space="preserve">
          <source>Typical use of AutoSplit in the perl MakeMaker utility is via the command-line with:</source>
          <target state="translated">在perl MakeMaker实用程序中,AutoSplit的典型用法是通过命令行使用。</target>
        </trans-unit>
        <trans-unit id="2eb42fd8be2849b836904fd8c0478452015d5021" translate="yes" xml:space="preserve">
          <source>Typically displayed in italics. Example: &quot;&lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt; &quot;</source>
          <target state="translated">通常以斜体显示。示例：&amp;ldquo; &lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="b5d871a9c977277097fa4a829e659b06d6204d49" translate="yes" xml:space="preserve">
          <source>Typically displayed in italics. Example: &quot;&lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt;&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e392be83caed3c91eae784a95dbf70091fef0bbc" translate="yes" xml:space="preserve">
          <source>Typically only necessary for debugging and testing, if you need to dump the internals of an SV, &lt;a href=&quot;Devel::Peek&quot;&gt;Devel::Peek's&lt;/a&gt; Dump() provides more detail in a compact form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a174345584e66d867781b1452d35dc4522e5c23" translate="yes" xml:space="preserve">
          <source>Typically only necessary for debugging and testing. Don't use this flag as a marker to distinguish character and binary data, that should be decided for each variable when you write your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b14febd4050c6e9e7fff1ec1a1e04a32b2411b9" translate="yes" xml:space="preserve">
          <source>Typically render into NFD on input and NFC on output. Using NFKC or NFKD functions improves recall on searches, assuming you've already done to the same text to be searched. Note that this is about much more than just pre- combined compatibility glyphs; it also reorders marks according to their canonical combining classes and weeds out singletons.</source>
          <target state="translated">通常在输入时渲染成NFD,输出时渲染成NFC。使用NFKC或NFKD函数可以提高搜索时的召回率,假设你已经对要搜索的同一文本进行了搜索。请注意,这不仅仅是关于预组合兼容性字形,它还根据它们的规范组合类重新排序标记,并剔除单体。</target>
        </trans-unit>
        <trans-unit id="4aadd663fd22d97ef1413917c08e1ab3e9fe702e" translate="yes" xml:space="preserve">
          <source>Typically returns the string &lt;code&gt;at &amp;lt;FILE&amp;gt; line &amp;lt;LINE&amp;gt;&lt;/code&gt;. If &lt;code&gt;detail&lt;/code&gt; is set then its value will be returned instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c564109e8a3afa5be0b031d855d9ae4aa0bbb3" translate="yes" xml:space="preserve">
          <source>Typically this is used to emulate &lt;code&gt;#!&lt;/code&gt; startup on platforms that don't support &lt;code&gt;#!&lt;/code&gt; . It's also convenient when debugging a script that uses &lt;code&gt;#!&lt;/code&gt; , and is thus normally found by the shell's $PATH search mechanism.</source>
          <target state="translated">通常，它用于模拟 &lt;code&gt;#!&lt;/code&gt; 在不支持 &lt;code&gt;#!&lt;/code&gt; 平台上启动！。当调试使用 &lt;code&gt;#!&lt;/code&gt; 的脚本时，这也很方便。，因此通常是由外壳程序的$ PATH搜索机制找到的。</target>
        </trans-unit>
        <trans-unit id="0f7ce98ce055e01dae18470a5f2a3135a14234ad" translate="yes" xml:space="preserve">
          <source>Typically this is used to emulate &lt;code&gt;#!&lt;/code&gt; startup on platforms that don't support &lt;code&gt;#!&lt;/code&gt;. It's also convenient when debugging a script that uses &lt;code&gt;#!&lt;/code&gt;, and is thus normally found by the shell's $PATH search mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687058d347f26c3b9dcf0508ed2f5930b5b6fa48" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be returned via &lt;code&gt;$out&lt;/code&gt; . &lt;code&gt;$status&lt;/code&gt; will have a value &lt;code&gt;Z_OK&lt;/code&gt; if successful.</source>
          <target state="translated">通常用于完成放气。任何待处理的输出将通过 &lt;code&gt;$out&lt;/code&gt; 返回。如果成功， &lt;code&gt;$status&lt;/code&gt; 的值 &lt;code&gt;Z_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bb05899bf90c01639baa0fce37a7ffd38acaffb" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be returned via &lt;code&gt;$out&lt;/code&gt;. &lt;code&gt;$status&lt;/code&gt; will have a value &lt;code&gt;Z_OK&lt;/code&gt; if successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a46f6fee05faa753caaabc6b43de594c708bd4" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be written to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">通常用于完成放气。任何未决的输出将被写入 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61eb0abe390afe612ea12baca62c7c474255a6b3" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be written to &lt;code&gt;$output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6622b7497b5ad854ceef3d9e6b7f39de4b5a746f" translate="yes" xml:space="preserve">
          <source>Typically will call &lt;code&gt;Fill&lt;/code&gt; and manipulate pointers (possibly via the API). &lt;code&gt;PerlIOBuf_read()&lt;/code&gt; may be suitable for derived classes which provide &quot;fast gets&quot; methods.</source>
          <target state="translated">通常会调用 &lt;code&gt;Fill&lt;/code&gt; 和操作指针（可能通过API）。 &lt;code&gt;PerlIOBuf_read()&lt;/code&gt; 可能适用于提供&amp;ldquo;快速获取&amp;rdquo;方法的派生类。</target>
        </trans-unit>
        <trans-unit id="eb1290094db39111daed12026731de41d874265c" translate="yes" xml:space="preserve">
          <source>Typically you only need to set this if you are using nonstandard prefixes and want some or all of them to have the same semantics as '--' does under normal circumstances.</source>
          <target state="translated">通常情况下,只有当你使用非标准的前缀,并希望其中的一些或所有前缀具有与'--'在正常情况下相同的语义时,你才需要设置这个。</target>
        </trans-unit>
        <trans-unit id="bbb5689bb894bcd45bb2427b7ffbb2ba5d9ac28a" translate="yes" xml:space="preserve">
          <source>Typically you use the &lt;code&gt;\G&lt;/code&gt; anchor with the &lt;code&gt;c&lt;/code&gt; flag when you want to try a different match if one fails, such as in a tokenizer. Jeffrey Friedl offers this example which works in 5.004 or later.</source>
          <target state="translated">通常，如果您想要在匹配失败的情况下尝试其他匹配（例如在分词器中），则可以将 &lt;code&gt;\G&lt;/code&gt; 锚与 &lt;code&gt;c&lt;/code&gt; 标志一起使用。Jeffrey Friedl提供了适用于5.004或更高版本的示例。</target>
        </trans-unit>
        <trans-unit id="e42958c3877ca65db1e97bfa470cdaaff1d1e60d" translate="yes" xml:space="preserve">
          <source>Typically you use the &lt;code&gt;\G&lt;/code&gt; anchor with the &lt;code&gt;c&lt;/code&gt; modifier when you want to try a different match if one fails, such as in a tokenizer. Jeffrey Friedl offers this example which works in 5.004 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d250975c35bc29bcb347189b99facfa0b3287b6" translate="yes" xml:space="preserve">
          <source>Typically you'll want to change how TAP gets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291f2d298dd4e6053c773023592956eee5655566" translate="yes" xml:space="preserve">
          <source>Typically, Perl tests are run through this. However, anything which spits out TAP is fine. You can use this argument to specify the name of the program (and optional switches) to run your tests with:</source>
          <target state="translated">通常情况下,Perl测试是通过这个来运行的。然而,任何能吐出TAP的程序都可以。你可以用这个参数来指定程序的名称 (和可选的开关)来运行你的测试。</target>
        </trans-unit>
        <trans-unit id="b62868c79b9e92764b29688b63eb397e1c587dcb" translate="yes" xml:space="preserve">
          <source>Typically, a &lt;code&gt;package&lt;/code&gt; statement is the first declaration in a file included in a program by one of the &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, or &lt;code&gt;use&lt;/code&gt; operators. You can switch into a package in more than one place: &lt;code&gt;package&lt;/code&gt; has no effect beyond specifying which symbol table the compiler will use for dynamic symbols for the rest of that block or until the next &lt;code&gt;package&lt;/code&gt; statement. You can refer to variables and filehandles in other packages by prefixing the identifier with the package name and a double colon: &lt;code&gt;$Package::Variable&lt;/code&gt;. If the package name is null, the &lt;code&gt;main&lt;/code&gt; package is assumed. That is, &lt;code&gt;$::sail&lt;/code&gt; is equivalent to &lt;code&gt;$main::sail&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1a3db1817e4391406ea8e4c10b938d812a2baf" translate="yes" xml:space="preserve">
          <source>Typically, a C compiler allocates 12 bytes to a &lt;code&gt;gappy_t&lt;/code&gt; variable, but requires only 8 bytes for a &lt;code&gt;dense_t&lt;/code&gt; . After investigating this further, we can draw memory maps, showing where the extra 4 bytes are hidden:</source>
          <target state="translated">通常，C编译器将12个字节分配给 &lt;code&gt;gappy_t&lt;/code&gt; 变量，但是对于 &lt;code&gt;dense_t&lt;/code&gt; 只需要8个字节。在进一步研究之后，我们可以绘制内存映射，显示出多余的4个字节在哪里被隐藏：</target>
        </trans-unit>
        <trans-unit id="842e52cd2265b412e8f4aaf0dec34c2c2fc7c9ed" translate="yes" xml:space="preserve">
          <source>Typically, a C compiler allocates 12 bytes to a &lt;code&gt;gappy_t&lt;/code&gt; variable, but requires only 8 bytes for a &lt;code&gt;dense_t&lt;/code&gt;. After investigating this further, we can draw memory maps, showing where the extra 4 bytes are hidden:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c91d2712bb90187ca081aa74ad37d202d5e800" translate="yes" xml:space="preserve">
          <source>Typically, however, things are the other way around: the tieable class expects its arguments as a flattened list, so the attribute looks like:</source>
          <target state="translated">然而,通常情况下,事情是相反的:可绑定类希望它的参数是一个扁平化的列表,所以属性看起来像。</target>
        </trans-unit>
        <trans-unit id="f8985e43d2d106574f328b34641196cf266af572" translate="yes" xml:space="preserve">
          <source>Typically, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2dcf9e9fce909e6d70f7fd2b928940489e6fad5" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype d off&quot; or &quot;buildtype d&quot; at the command prompt causes the buildtype to be set to Debug type with D1 flag set.</source>
          <target state="translated">在命令提示符下键入 &quot;buildtype d off &quot;或 &quot;buildtype d &quot;会使buildtype被设置为Debug类型,并设置D1标志。</target>
        </trans-unit>
        <trans-unit id="b2c7510e598f94047792f2e34322c55a1d654ee0" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype d on&quot; at the command prompt causes the buildtype to be set to Debug type with D2 flag set.</source>
          <target state="translated">在命令提示符下输入 &quot;buildtype d on &quot;会使buildtype被设置为Debug类型,并设置D2标志。</target>
        </trans-unit>
        <trans-unit id="6127511edf886df0417540a81474ffb3800e60b7" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype r&quot; at the command prompt sets it to Release Build type.</source>
          <target state="translated">在命令提示符下输入 &quot;buildtype r &quot;将其设置为Release Build类型。</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="70ae2f8ea36eac22765cdf44837146969d083d4c" translate="yes" xml:space="preserve">
          <source>U/WIN specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_Unix的U/WIN特定子类。</target>
        </trans-unit>
        <trans-unit id="e87e721b92dfc3ce5a42bdc5529d628275269297" translate="yes" xml:space="preserve">
          <source>UAX #11: East Asian Width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e111693f7553557203eea396555ad20db941bc" translate="yes" xml:space="preserve">
          <source>UAX #14: Unicode Line Breaking Algorithm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62b71447bb2670ca75d2c60404b5335b86f48a9" translate="yes" xml:space="preserve">
          <source>UAX #15: Unicode Normalization Forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57fbcb66826627051473f0031e536eaa29808986" translate="yes" xml:space="preserve">
          <source>UAX #29: Unicode Text Segmentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04846c59e74a6b4b2e534cd9cb9a90b44ec543b2" translate="yes" xml:space="preserve">
          <source>UAX #44: Unicode Character Database</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591e272980f29149d094e061515f3a24c2416346" translate="yes" xml:space="preserve">
          <source>UC</source>
          <target state="translated">UC</target>
        </trans-unit>
        <trans-unit id="3a333ea8bebfa50b73219f11f7bf0ebbb8c9a863" translate="yes" xml:space="preserve">
          <source>UCA recommends that out-of-range values should not be ignored for security reasons. Say, &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; should not be equal to &lt;code&gt;&quot;perl&quot;&lt;/code&gt; . However, &lt;code&gt;U+FFFD&lt;/code&gt; is wrongly mapped to a variable collation element in DUCET for Unicode 6.0.0 to 6.2.0, that means out-of-range values will be ignored when &lt;code&gt;variable&lt;/code&gt; isn't &lt;code&gt;Non-ignorable&lt;/code&gt; .</source>
          <target state="translated">UCA建议出于安全原因，不应忽略超出范围的值。说 &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; 不应等于 &lt;code&gt;&quot;perl&quot;&lt;/code&gt; 。但是，对于Unicode 6.0.0至6.2.0 ， &lt;code&gt;U+FFFD&lt;/code&gt; 错误地映射到DUCET中的变量归类元素，这意味着当 &lt;code&gt;variable&lt;/code&gt; 不是 &lt;code&gt;Non-ignorable&lt;/code&gt; ignorable时，超出范围的值将被忽略。</target>
        </trans-unit>
        <trans-unit id="492c906fc3f312af6ae908d9ffaf994fd07f46cc" translate="yes" xml:space="preserve">
          <source>UCA recommends that out-of-range values should not be ignored for security reasons. Say, &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; should not be equal to &lt;code&gt;&quot;perl&quot;&lt;/code&gt;. However, &lt;code&gt;U+FFFD&lt;/code&gt; is wrongly mapped to a variable collation element in DUCET for Unicode 6.0.0 to 6.2.0, that means out-of-range values will be ignored when &lt;code&gt;variable&lt;/code&gt; isn't &lt;code&gt;Non-ignorable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46cc4029c87ef2347d0792acb85d7dbc180043ff" translate="yes" xml:space="preserve">
          <source>UCA_Version</source>
          <target state="translated">UCA_Version</target>
        </trans-unit>
        <trans-unit id="e80de0851d29f92f6e9e34856bbc13a9b674c12b" translate="yes" xml:space="preserve">
          <source>UCS</source>
          <target state="translated">UCS</target>
        </trans-unit>
        <trans-unit id="c3ba710b4e9b506e4750f6e24e9eeec383e609b3" translate="yes" xml:space="preserve">
          <source>UCS-2</source>
          <target state="translated">UCS-2</target>
        </trans-unit>
        <trans-unit id="206177d23e4d5ec0abfb5c6b0df396d679742e7c" translate="yes" xml:space="preserve">
          <source>UCS-2 is a fixed-length encoding with each character taking 16 bits. It &lt;b&gt;does not&lt;/b&gt; support</source>
          <target state="translated">UCS-2是定长编码，每个字符占用16位。它&lt;b&gt;不&lt;/b&gt;支持</target>
        </trans-unit>
        <trans-unit id="daeba9311089266fcf0acd6d54c9e56ca13a992e" translate="yes" xml:space="preserve">
          <source>UCS-2, UCS-4</source>
          <target state="translated">UCS-2、UCS-4</target>
        </trans-unit>
        <trans-unit id="e9a6f622e340090feb219eb5c94b0df756e8e486" translate="yes" xml:space="preserve">
          <source>UDP</source>
          <target state="translated">UDP</target>
        </trans-unit>
        <trans-unit id="a392dc8e430c846ca90f8e40c79fda571eef8daf" translate="yes" xml:space="preserve">
          <source>UDP datagrams are</source>
          <target state="translated">UDP数据报是</target>
        </trans-unit>
        <trans-unit id="0b1ddbe7e9085079ee7967600cb1889fd0b548d1" translate="yes" xml:space="preserve">
          <source>UDP: Message Passing</source>
          <target state="translated">UDP:信息传递</target>
        </trans-unit>
        <trans-unit id="d946adf52a4783929f122d341b29ac0fe188371c" translate="yes" xml:space="preserve">
          <source>UID</source>
          <target state="translated">UID</target>
        </trans-unit>
        <trans-unit id="6baa0c91c35738e244018a78ee06f9f0b5e589ea" translate="yes" xml:space="preserve">
          <source>UNDEF</source>
          <target state="translated">UNDEF</target>
        </trans-unit>
        <trans-unit id="bbb2722df9c1be9f9216f08d7da234a2e705e9d4" translate="yes" xml:space="preserve">
          <source>UNDERBAR</source>
          <target state="translated">UNDERBAR</target>
        </trans-unit>
        <trans-unit id="74ff590c1dac1161eec0fbaa8b7d8b3a98fff4d5" translate="yes" xml:space="preserve">
          <source>UNICODE AND SIDE EFFECTS</source>
          <target state="translated">统一编码和副作用</target>
        </trans-unit>
        <trans-unit id="0f9d971f52bdd7a74ebeb786ec5143de4c2935d5" translate="yes" xml:space="preserve">
          <source>UNICODE IN OLDER PERLS</source>
          <target state="translated">旧版PERLS中的UNICODE</target>
        </trans-unit>
        <trans-unit id="3d51f9ce7ad6a8a131760c17f51427e8bbfb85b1" translate="yes" xml:space="preserve">
          <source>UNICODE_REPLACEMENT</source>
          <target state="translated">UNICODE_REPLACEMENT</target>
        </trans-unit>
        <trans-unit id="94c5e5979031dbec3b6f240558b2bfaa36f46791" translate="yes" xml:space="preserve">
          <source>UNIMPLEMENTED</source>
          <target state="translated">UNIMPLEMENTED</target>
        </trans-unit>
        <trans-unit id="9392ee60535a3aa7bb3335f263044b78e27554ed" translate="yes" xml:space="preserve">
          <source>UNISTD</source>
          <target state="translated">UNISTD</target>
        </trans-unit>
        <trans-unit id="c070755890afd262edf57a1cfae99ffc017d2459" translate="yes" xml:space="preserve">
          <source>UNITCHECK</source>
          <target state="translated">UNITCHECK</target>
        </trans-unit>
        <trans-unit id="bc192a928ab3fe78a1c74cfa4d1027b44d52c868" translate="yes" xml:space="preserve">
          <source>UNIVERSAL</source>
          <target state="translated">UNIVERSAL</target>
        </trans-unit>
        <trans-unit id="1feda7e9d1b1a232e025eeb903dd53659f7b069c" translate="yes" xml:space="preserve">
          <source>UNIVERSAL - base class for ALL classes (blessed references)</source>
          <target state="translated">UNIVERSAL-所有类的基础类(祝福参考)</target>
        </trans-unit>
        <trans-unit id="b23387c60700d885c584c4f2b25855ad58b48b48" translate="yes" xml:space="preserve">
          <source>UNIX and POSIX systems provide an abstract access() operating system call, which should be used to query the read, write, and execute rights. This function hides various distinct approaches in additional operating system specific security features, like Access Control Lists (ACLs)</source>
          <target state="translated">UNIX和POSIX系统提供了一个抽象访问()的操作系统调用,应该用来查询读、写和执行权限。这个函数将各种不同的方法隐藏在额外的操作系统特定的安全功能中,比如访问控制列表(ACLs)。</target>
        </trans-unit>
        <trans-unit id="fa0c8b9587852cbf0dc08f98bcecbaed53f1e1c0" translate="yes" xml:space="preserve">
          <source>UNIX domain sockets added by Sean Robinson &amp;lt;</source>
          <target state="translated">Sean Robinson添加的UNIX域套接字&amp;lt;</target>
        </trans-unit>
        <trans-unit id="85db2499d39f4696e02fb26511b230add2c1b670" translate="yes" xml:space="preserve">
          <source>UNIX file permissions are based on sets of mode bits for {read,write,execute} for each {user,group,other}. By default Cygwin only tracks the Win32 read-only attribute represented as the UNIX file user write bit (files are always readable, files are executable if they have a</source>
          <target state="translated">UNIX文件的权限是基于每个{用户、组、其他}的{读、写、执行}模式位的集合。默认情况下,Cygwin只跟踪以UNIX文件用户写位表示的Win32只读属性(文件总是可读的,如果文件有写位,则可执行)。</target>
        </trans-unit>
        <trans-unit id="1db53023f517a9c3a97970b2e62a29042045d3f0" translate="yes" xml:space="preserve">
          <source>UNI_TO_NATIVE</source>
          <target state="translated">UNI_TO_NATIVE</target>
        </trans-unit>
        <trans-unit id="36361e169f0479184326d85ebb47825bf51a5753" translate="yes" xml:space="preserve">
          <source>UNLIKELY</source>
          <target state="translated">UNLIKELY</target>
        </trans-unit>
        <trans-unit id="5c24b56d363871364a8198c1e16261b34c9bf761" translate="yes" xml:space="preserve">
          <source>UNLINK flag available since 0.10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="265e8c38a269eb32604a5d0ed5924378784ee057" translate="yes" xml:space="preserve">
          <source>UNSHIFT this, LIST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b8f1af6e17a29d4f20f56ec6d442f59acfc755d" translate="yes" xml:space="preserve">
          <source>UNSUPPORTED</source>
          <target state="translated">UNSUPPORTED</target>
        </trans-unit>
        <trans-unit id="40cccdd49a4b2f7980664d02999aa7b9e3022b50" translate="yes" xml:space="preserve">
          <source>UNTIE by Nick Ing-Simmons &amp;lt;</source>
          <target state="translated">Nick Ing-Simmons撰写的UNTIE &amp;lt;</target>
        </trans-unit>
        <trans-unit id="41304503568dff57766f35c33ebaca45f5e827b2" translate="yes" xml:space="preserve">
          <source>UNTIE this</source>
          <target state="translated">UNTIE this</target>
        </trans-unit>
        <trans-unit id="ea518a7caeec27fa571544a1959010e8689298ab" translate="yes" xml:space="preserve">
          <source>UPGRADE SUGGESTED</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3bb3273c3d27a35e7a79c09d285ae651319171c" translate="yes" xml:space="preserve">
          <source>UPGRADING</source>
          <target state="translated">UPGRADING</target>
        </trans-unit>
        <trans-unit id="a6b6b187a5dabe1711e09378ba034929cf5397f3" translate="yes" xml:space="preserve">
          <source>UPSTREAM indicates where patches should go. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; implies that this hasn't been discussed for the module at hand. &lt;code&gt;blead&lt;/code&gt; indicates that the copy of the module in the blead sources is to be considered canonical, &lt;code&gt;cpan&lt;/code&gt; means that the module on CPAN is to be patched first. &lt;code&gt;first-come&lt;/code&gt; means that blead can be patched freely if it is in sync with the latest release on CPAN.</source>
          <target state="translated">UPSTREAM指示应将修补程序放到哪里。 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 表示尚未对手头的模块进行讨论。 &lt;code&gt;blead&lt;/code&gt; 表示将blead源中的模块副本视为规范副本， &lt;code&gt;cpan&lt;/code&gt; 表示将首先修补CPAN上的模块。 &lt;code&gt;first-come&lt;/code&gt; 是指，如果与最新版CPAN同步，则可以免费修补blead。</target>
        </trans-unit>
        <trans-unit id="1b193f75bbf58b38858154a6e283a021406e55fd" translate="yes" xml:space="preserve">
          <source>UPSTREAM indicates where patches should go. &lt;code&gt;undef&lt;/code&gt; implies that this hasn't been discussed for the module at hand. &lt;code&gt;blead&lt;/code&gt; indicates that the copy of the module in the blead sources is to be considered canonical, &lt;code&gt;cpan&lt;/code&gt; means that the module on CPAN is to be patched first. &lt;code&gt;first-come&lt;/code&gt; means that blead can be patched freely if it is in sync with the latest release on CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="ba5e5280eb88749f4ed2bd7802c151c1f77cb3d7" translate="yes" xml:space="preserve">
          <source>URL decoding and encoding</source>
          <target state="translated">URL解码和编码</target>
        </trans-unit>
        <trans-unit id="a2c8158547717be782e140b2ad8b3a2b5e515fe5" translate="yes" xml:space="preserve">
          <source>URL for further information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61aff325c59f0125c7432101521fe8aef2d620f8" translate="yes" xml:space="preserve">
          <source>URLS</source>
          <target state="translated">URLS</target>
        </trans-unit>
        <trans-unit id="cf3bfa9a159c5a5ddc20da1eccd6bbddbdc037e4" translate="yes" xml:space="preserve">
          <source>USAGE</source>
          <target state="translated">USAGE</target>
        </trans-unit>
        <trans-unit id="11db5afeaceeb6d5fec1a6025012faccc762da50" translate="yes" xml:space="preserve">
          <source>USAGE DETAILS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca88d77aca2d323542d2e8f12b83151e0846c19" translate="yes" xml:space="preserve">
          <source>USE EXAMPLES</source>
          <target state="translated">使用示例</target>
        </trans-unit>
        <trans-unit id="48c336c391ccd32eaf0812999ba74a1243f916d3" translate="yes" xml:space="preserve">
          <source>USE Test2::Suite INSTEAD</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce94de210299952d4167e1951445b8720839ce7f" translate="yes" xml:space="preserve">
          <source>USEFUL</source>
          <target state="translated">USEFUL</target>
        </trans-unit>
        <trans-unit id="6eb0c61201a96afc99cbf180f1c8d93c0a9fd8c8" translate="yes" xml:space="preserve">
          <source>USER</source>
          <target state="translated">USER</target>
        </trans-unit>
        <trans-unit id="045095377d72052bacadc70846f65ba919bc72ee" translate="yes" xml:space="preserve">
          <source>USER METHODS</source>
          <target state="translated">用户方法</target>
        </trans-unit>
        <trans-unit id="eff0e1414e1813c02157d57d3f325f32947a8413" translate="yes" xml:space="preserve">
          <source>USE_MULTI &amp;amp; USE_IMP_SYS defined and USE_ITHREADS not defined</source>
          <target state="translated">已定义USE_MULTI和USE_IMP_SYS，未定义USE_ITHREADS</target>
        </trans-unit>
        <trans-unit id="5e29b7b3b7536de15b46013805cfeb875c7a61d3" translate="yes" xml:space="preserve">
          <source>USE_MULTI, USE_ITHREADS &amp;amp; USE_IMP_SYS defined</source>
          <target state="translated">定义了USE_MULTI，USE_ITHREADS和USE_IMP_SYS</target>
        </trans-unit>
        <trans-unit id="227996d58fdfdee97220bd395f44c03336330289" translate="yes" xml:space="preserve">
          <source>USE_PERL_FLOCK</source>
          <target state="translated">USE_PERL_FLOCK</target>
        </trans-unit>
        <trans-unit id="f8104e09349c8c6000afb7fc05a4ed027d50f4e3" translate="yes" xml:space="preserve">
          <source>USE_THREADS</source>
          <target state="translated">USE_THREADS</target>
        </trans-unit>
        <trans-unit id="eeb0c37772a1b806f230c8036c163dab104d01af" translate="yes" xml:space="preserve">
          <source>USING A CONTEXT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d403f19c30d9dafcf5b6a7bb8666159dacf7697f" translate="yes" xml:space="preserve">
          <source>USING B::Deparse AS A MODULE</source>
          <target state="translated">使用 B::Deparse 作为一个模块。</target>
        </trans-unit>
        <trans-unit id="2efa10816450d527d9e56d3271b7e34ea8c81a61" translate="yes" xml:space="preserve">
          <source>USING CONTEXT: THE DEBUG FILTER</source>
          <target state="translated">使用上下文:DEBUG过滤器</target>
        </trans-unit>
        <trans-unit id="5dc41a076ce2820059919cbbf35a7c867770cef6" translate="yes" xml:space="preserve">
          <source>USING FILTERS</source>
          <target state="translated">使用过滤器</target>
        </trans-unit>
        <trans-unit id="3d73074a3cddd39278e855bf130287734b3a28e3" translate="yes" xml:space="preserve">
          <source>USING LOCALES</source>
          <target state="translated">使用LOCALS</target>
        </trans-unit>
        <trans-unit id="e914e6326e1588417f534e760a668a311b7406cd" translate="yes" xml:space="preserve">
          <source>USING PERL IN OPENVOS</source>
          <target state="translated">在OPENVOS中使用PERL</target>
        </trans-unit>
        <trans-unit id="99eec133fe1ada053200d233f3eaa4520c2bb5fb" translate="yes" xml:space="preserve">
          <source>USING THE CONSTRUCTOR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac35aec57e40ba482f8f9fa734ce439013d2f6b2" translate="yes" xml:space="preserve">
          <source>USING THE EXTERNAL GZIP</source>
          <target state="translated">使用外部的GZIP文件</target>
        </trans-unit>
        <trans-unit id="ca105f51c68cd465fba8a30858f385516bc30dcf" translate="yes" xml:space="preserve">
          <source>USING UTF8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af50db97d3b4d2d4a30cc3bc98a5ffb4cb39ec7" translate="yes" xml:space="preserve">
          <source>USourceData.txt</source>
          <target state="translated">USourceData.txt</target>
        </trans-unit>
        <trans-unit id="d96ff9257bc1dd5af725fa01d1ac6c3c64b3d707" translate="yes" xml:space="preserve">
          <source>USourceGlyphs.pdf</source>
          <target state="translated">USourceGlyphs.pdf</target>
        </trans-unit>
        <trans-unit id="618f65101275eae124d9a7c9c7a5431c588e88d8" translate="yes" xml:space="preserve">
          <source>UTF</source>
          <target state="translated">UTF</target>
        </trans-unit>
        <trans-unit id="6b28c2250a1cbb7c8f56dfcf0dd9e06201c35f2f" translate="yes" xml:space="preserve">
          <source>UTF stands for &quot;Unicode Transformation Format&quot;. UTF-8 is an encoding of Unicode into a sequence of 8-bit byte chunks, based on ASCII and Latin-1. The length of a sequence required to represent a Unicode code point depends on the ordinal number of that code point, with larger numbers requiring more bytes. UTF-EBCDIC is like UTF-8, but based on EBCDIC. They are enough alike that often, casual usage will conflate the two terms, and use &quot;UTF-8&quot; to mean both the UTF-8 found on ASCII platforms, and the UTF-EBCDIC found on EBCDIC ones.</source>
          <target state="translated">UTF是 &quot;Unicode转换格式 &quot;的缩写。UTF-8是一种基于ASCII和Latin-1的Unicode编码,将Unicode编码成8位字节块的序列。表示一个Unicode码点所需的序列长度取决于该码点的序数,数字越大需要的字节数越多。UTF-EBCDIC和UTF-8一样,但基于EBCDIC。它们非常相像,所以经常会有一些人把这两个术语混为一谈,用 &quot;UTF-8 &quot;来表示ASCII平台上的UTF-8和EBCDIC平台上的UTF-EBCDIC。</target>
        </trans-unit>
        <trans-unit id="5a9da893be5fd5fae314bea8dcdeeee12beeec4b" translate="yes" xml:space="preserve">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>
        </trans-unit>
        <trans-unit id="c965e907f9d25c517a8e5bd79aea9417a0714217" translate="yes" xml:space="preserve">
          <source>UTF-16 is almost the same as UCS-2 but it supports</source>
          <target state="translated">UTF-16与UCS-2几乎相同,但它支持的是</target>
        </trans-unit>
        <trans-unit id="6368ee0d76a2ca5c3d83c85e127ba1610670e64c" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate U+%X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5222e4ab75ba1ce305284f282ec30a73156a366c" translate="yes" xml:space="preserve">
          <source>UTF-16, UTF-16BE, UTF-16LE, Surrogates, and &lt;code&gt;BOM&lt;/code&gt; 's (Byte Order Marks)</source>
          <target state="translated">UTF-16，UTF-16BE，UTF-16LE，代理和 &lt;code&gt;BOM&lt;/code&gt; （字节顺序标记）</target>
        </trans-unit>
        <trans-unit id="ca51c01ddb04a5d5f4843a1045e4eb7fa59f4fe4" translate="yes" xml:space="preserve">
          <source>UTF-16, UTF-16BE, UTF-16LE, Surrogates, and &lt;code&gt;BOM&lt;/code&gt;'s (Byte Order Marks)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a1ff59a1e826be6636526f502c21d7b7b97ead" translate="yes" xml:space="preserve">
          <source>UTF-32 (UCS-4) is a fixed-length encoding with each character taking 32 bits. Since it is 32-bit, there is no need for</source>
          <target state="translated">UTF-32(UCS-4)是一种固定长度的编码,每个字符占32位。由于它是32位的,所以没有必要使用 &quot;UCS-4&quot;。</target>
        </trans-unit>
        <trans-unit id="dfd8dce020ef601007001e4289b99a7908444d8a" translate="yes" xml:space="preserve">
          <source>UTF-32, UTF-32BE, UTF-32LE</source>
          <target state="translated">UTF-32,UTF-32BE,UTF-32LE。</target>
        </trans-unit>
        <trans-unit id="20e199acc434517cd4a6e5977a48bae6e5af47a4" translate="yes" xml:space="preserve">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>
        </trans-unit>
        <trans-unit id="4d56cb8e2ad2a50613de9fa7d9d9a0d239c1aca9" translate="yes" xml:space="preserve">
          <source>UTF-7 encoding</source>
          <target state="translated">UTF-7编码</target>
        </trans-unit>
        <trans-unit id="c69eadbe302e95901c2e20dc0780e1b33ffbf733" translate="yes" xml:space="preserve">
          <source>UTF-7 is a special encoding which &quot;re-encodes&quot; UTF-16BE into a 7-bit encoding. It is implemented separately by Encode::Unicode::UTF7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8308c0cebaf2cef9e02fb7f26e6c4f56ba6ce0" translate="yes" xml:space="preserve">
          <source>UTF-7 was not supported by Encode until version 1.95 because of that. But Unicode::String, a module by Gisle Aas which adds Unicode supports to non-utf8-savvy perl did support UTF-7, the UTF-7 support was added so Encode can supersede Unicode::String 100%.</source>
          <target state="translated">因为这个原因,Encode在1.95版本之前都不支持UTF-7,但Gisle Aas的Unicode::String模块增加了对UTF-7的支持。但是Gisle Aas的一个模块Unicode::String为不精通utf8的perl增加了Unicode支持,确实支持UTF-7,UTF-7的支持被加入,所以Encode可以100%取代Unicode::String。</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="e2635de14b396bd81c2a4f587434aea9cfbf99fc" translate="yes" xml:space="preserve">
          <source>UTF-8 and UTF-EBCDIC are two different encodings used to represent Unicode code points as sequences of bytes. Macros with the same names (but different definitions) in</source>
          <target state="translated">UTF-8和UTF-EBCDIC是两种不同的编码,用来表示Unicode码点的字节序列。中名称相同(但定义不同)的宏。</target>
        </trans-unit>
        <trans-unit id="8b4fe83acd749a66b827e068556fa7943eee22bb" translate="yes" xml:space="preserve">
          <source>UTF-8 and Unicode FAQ for Unix/Linux</source>
          <target state="translated">UTF-8和Unicode常见问题解答(Unix/Linux)</target>
        </trans-unit>
        <trans-unit id="79cdcb7150e1254a38f057938e6f4012fc46b08a" translate="yes" xml:space="preserve">
          <source>UTF-8 is a variable-length (1 to 4 bytes), byte-order independent encoding. In most of Perl's documentation, including elsewhere in this document, the term &quot;UTF-8&quot; means also &quot;UTF-EBCDIC&quot;. But in this section, &quot;UTF-8&quot; refers only to the encoding used on ASCII platforms. It is a superset of 7-bit US-ASCII, so anything encoded in ASCII has the identical representation when encoded in UTF-8.</source>
          <target state="translated">UTF-8 是一种可变长度(1 到 4 个字节)、独立于字节顺序的编码。在Perl的大部分文档中,包括本文档的其他地方,术语 &quot;UTF-8 &quot;也意味着 &quot;UTF-EBCDIC&quot;。但在本节中,&quot;UTF-8 &quot;仅指ASCII平台上使用的编码。它是7位US-ASCII的超集,所以任何用ASCII编码的东西在用UTF-8编码时都有相同的表示。</target>
        </trans-unit>
        <trans-unit id="2d6c49b0c5ea97423fbd4064bf9d6fbd9eeb0509" translate="yes" xml:space="preserve">
          <source>UTF-8 is very structured, so many combinations of bytes are invalid. In the past, Perl tried to soldier on and make some sense of invalid combinations, but this can lead to security holes, so now, if the Perl core needs to process an invalid combination, it will either raise a fatal error, or will replace those bytes by the sequence that forms the Unicode REPLACEMENT CHARACTER, for which purpose Unicode created it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b07e44d3986db9cf7499225144a4d1d394db97" translate="yes" xml:space="preserve">
          <source>UTF-8 treats the first 128 codepoints, 0..127, the same as ASCII. They take only one byte per character. All other characters are encoded as two to four bytes using a complex scheme. Fortunately, Perl handles this for us, so we don't have to worry about this.</source>
          <target state="translated">UTF-8对前128个代码点0...127的处理与ASCII相同。它们每个字符只需要一个字节。所有其他的字符都要用一个复杂的方案编码成两到四个字节。幸运的是,Perl为我们处理了这个问题,所以我们不必担心这个问题。</target>
        </trans-unit>
        <trans-unit id="7443ec4bd05d2044739a43a92206bcfe32f068b2" translate="yes" xml:space="preserve">
          <source>UTF-8 vs. utf8 vs. UTF8</source>
          <target state="translated">UTF-8 vs.utf8 vs.UTF8。</target>
        </trans-unit>
        <trans-unit id="21357a91ac9a6238516304ecf3d0973befa29dc1" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC</source>
          <target state="translated">UTF-EBCDIC</target>
        </trans-unit>
        <trans-unit id="54206a5f5bcbb8b5ddd3ceb665085cec48ec6be8" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is defined by &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr16&quot;&gt;Unicode Technical Report #16&lt;/a&gt;. It is defined based on CCSID 1047, not allowing for the differences for other code pages. This allows for easy interchange of text between computers running different code pages, but makes it unusable, without adaptation, for Perl on those other code pages.</source>
          <target state="translated">UTF-EBCDIC由&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr16&quot;&gt;Unicode技术报告＃16&lt;/a&gt;定义。它是根据CCSID 1047定义的，不允许其他代码页有所不同。这样可以在运行不同代码页的计算机之间轻松交换文本，但是对于其他代码页上的Perl，如果不进行修改，就无法使用。</target>
        </trans-unit>
        <trans-unit id="d1acc50280127d54b308a40ab3c768e112572a85" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is defined by &lt;a href=&quot;https://www.unicode.org/reports/tr16&quot;&gt;Unicode Technical Report #16&lt;/a&gt; (often referred to as just TR16). It is defined based on CCSID 1047, not allowing for the differences for other code pages. This allows for easy interchange of text between computers running different code pages, but makes it unusable, without adaptation, for Perl on those other code pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b0bbf585cedfbc65f392d0551056f49932bbd3" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is used on EBCDIC platforms. It generally requires more bytes to represent a given code point than UTF-8 does; the largest Unicode code points take 5 bytes to represent (instead of 4 in UTF-8), and, extended for 64-bit words, it uses 14 bytes instead of 13 bytes in UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae1061497efd49ee6054c0a3d6e1ce19e05e6be" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is used on EBCDIC platforms. The largest Unicode code points take 5 bytes to represent (instead of 4 in UTF-8), and Perl extends it to a maximum of 7 bytes to encode pode points up to what can fit in a 32-bit word (instead of 13 bytes and a 64-bit word in UTF-8).</source>
          <target state="translated">在EBCDIC平台上使用UTF-EBCDIC。最大的Unicode码点需要5个字节来表示(而不是UTF-8中的4个字节),Perl将其扩展到最大7个字节,以将码点编码到32位字中(而不是UTF-8中的13个字节和64位字)。</target>
        </trans-unit>
        <trans-unit id="32e4aba336279eb247fca6069de55e692fafce3d" translate="yes" xml:space="preserve">
          <source>UTF-X</source>
          <target state="translated">UTF-X</target>
        </trans-unit>
        <trans-unit id="31c724652517aa38e02f9cc38046b12306389452" translate="yes" xml:space="preserve">
          <source>UTF8SKIP</source>
          <target state="translated">UTF8SKIP</target>
        </trans-unit>
        <trans-unit id="126afec887a4798caa07a768c2ae8b1e709d5df3" translate="yes" xml:space="preserve">
          <source>UTF8_CHK_SKIP</source>
          <target state="translated">UTF8_CHK_SKIP</target>
        </trans-unit>
        <trans-unit id="f98f9b7b4dfefa91df6e8d07ade4cdf88d2b3a4e" translate="yes" xml:space="preserve">
          <source>UTF8_IS_INVARIANT</source>
          <target state="translated">UTF8_IS_INVARIANT</target>
        </trans-unit>
        <trans-unit id="ce7018ef4c544b4117f40b9403d65042195dc6ca" translate="yes" xml:space="preserve">
          <source>UTF8_IS_NONCHAR</source>
          <target state="translated">UTF8_IS_NONCHAR</target>
        </trans-unit>
        <trans-unit id="43a7d7eb6f7a4999dcf643e96fc55bf3ed29e04b" translate="yes" xml:space="preserve">
          <source>UTF8_IS_SUPER</source>
          <target state="translated">UTF8_IS_SUPER</target>
        </trans-unit>
        <trans-unit id="41c64bb8f1a0503efaa4f02874d635fa7fb44ce4" translate="yes" xml:space="preserve">
          <source>UTF8_IS_SURROGATE</source>
          <target state="translated">UTF8_IS_SURROGATE</target>
        </trans-unit>
        <trans-unit id="45d5fa1bf0c167c3f6576cc7457645a65299cae3" translate="yes" xml:space="preserve">
          <source>UTF8_MAXBYTES</source>
          <target state="translated">UTF8_MAXBYTES</target>
        </trans-unit>
        <trans-unit id="0a897c1fa81d6a6686e912ed672c264e86acb2f9" translate="yes" xml:space="preserve">
          <source>UTF8_MAXBYTES_CASE</source>
          <target state="translated">UTF8_MAXBYTES_CASE</target>
        </trans-unit>
        <trans-unit id="8af74f37673e55aee8c36bf5b73bd668baf4075c" translate="yes" xml:space="preserve">
          <source>UTF8_SAFE_SKIP</source>
          <target state="translated">UTF8_SAFE_SKIP</target>
        </trans-unit>
        <trans-unit id="69870d763a319ff2077dd64b9f02bdfd1ad88546" translate="yes" xml:space="preserve">
          <source>UTF8_SKIP</source>
          <target state="translated">UTF8_SKIP</target>
        </trans-unit>
        <trans-unit id="17562b3d061f2f42586076a6b020ba8eb357a3ff" translate="yes" xml:space="preserve">
          <source>UTILITIES</source>
          <target state="translated">UTILITIES</target>
        </trans-unit>
        <trans-unit id="58bc809d31f639453a46636f9c8ab08c8b78bb44" translate="yes" xml:space="preserve">
          <source>UTILITY FUNCTIONS</source>
          <target state="translated">实用功能</target>
        </trans-unit>
        <trans-unit id="0df889160bec1efd3a376bc092db51a6960809d0" translate="yes" xml:space="preserve">
          <source>UTS #10: Unicode Collation Algorithm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876d25fb5dd30a195bda72a305a7ba4a3acfcb55" translate="yes" xml:space="preserve">
          <source>UTS #18: Unicode Regular Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd7d8b48471cc7bdfa22b6a7694cc46d2409bb0" translate="yes" xml:space="preserve">
          <source>UV</source>
          <target state="translated">UV</target>
        </trans-unit>
        <trans-unit id="b25ef34eb3a5137d61daf0def8b67fe626cd3875" translate="yes" xml:space="preserve">
          <source>UVCHR_IS_INVARIANT</source>
          <target state="translated">UVCHR_IS_INVARIANT</target>
        </trans-unit>
        <trans-unit id="626b2f1b7c0d475b14997cb2d1af0b7a04543371" translate="yes" xml:space="preserve">
          <source>UVCHR_SKIP</source>
          <target state="translated">UVCHR_SKIP</target>
        </trans-unit>
        <trans-unit id="9746ff9d4d7b1c241287393e4d9dd0cd6f1bbf03" translate="yes" xml:space="preserve">
          <source>UVX</source>
          <target state="translated">UVX</target>
        </trans-unit>
        <trans-unit id="e92904bce8026b3c1f8828b0ce882e6b081c7fb6" translate="yes" xml:space="preserve">
          <source>Uganda</source>
          <target state="translated">Uganda</target>
        </trans-unit>
        <trans-unit id="c951ec00f123510a00d1e3d9539b11b4631d4096" translate="yes" xml:space="preserve">
          <source>Ukraine</source>
          <target state="translated">Ukraine</target>
        </trans-unit>
        <trans-unit id="994023f4756ccee554f76e83b238ef8441ca987c" translate="yes" xml:space="preserve">
          <source>Ultimate control over what should be done when (actually: each time) an option is encountered on the command line can be achieved by designating a reference to a subroutine (or an anonymous subroutine) as the option destination. When GetOptions() encounters the option, it will call the subroutine with two or three arguments. The first argument is the name of the option. (Actually, it is an object that stringifies to the name of the option.) For a scalar or array destination, the second argument is the value to be stored. For a hash destination, the second argument is the key to the hash, and the third argument the value to be stored. It is up to the subroutine to store the value, or do whatever it thinks is appropriate.</source>
          <target state="translated">通过指定一个对子程序(或一个匿名子程序)的引用作为选项的目标,可以最终控制在命令行上遇到一个选项时(实际上:每次)应该做什么。当GetOptions()遇到选项时,它将用两个或三个参数来调用子程序。第一个参数是期权的名称。(实际上,它是一个字符串化为选项名称的对象。)对于一个标量或数组目标,第二个参数是要存储的值。对于哈希目标,第二个参数是哈希的键,第三个参数是要存储的值。由子程序决定是否存储该值,或者做任何它认为合适的事情。</target>
        </trans-unit>
        <trans-unit id="3ee38d90a0334118e79056b8389ee44abc43742c" translate="yes" xml:space="preserve">
          <source>Unacceptable behavior will result in a public and clearly identified warning. A second instance of unacceptable behavior from the same individual will result in removal from the mailing list and GitHub issue tracker, for a period of one calendar month. The rationale for this is to provide an opportunity for the person to change the way they act.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd11761cf7cb6cb9a563ded422bdfc4417516b2a" translate="yes" xml:space="preserve">
          <source>Unacceptable behavior will result in a public and clearly identified warning. Repeated unacceptable behavior will result in removal from the mailing list and revocation of rights to update rt.perl.org. The first removal is for one month. Subsequent removals will double in length. After six months with no warning, a user's ban length is reset. Removals, like warnings, are public.</source>
          <target state="translated">不可接受的行为将导致公开和明确的警告。重复的不可接受的行为将导致从邮件列表中移除,并取消更新rt.perl.org的权利。第一次移除的期限是一个月。其后的移除时间将加倍。六个月后,在没有警告的情况下,用户的禁言期会被重置。移除和警告一样,都是公开的。</target>
        </trans-unit>
        <trans-unit id="7be1c42f094036e0d5e47ba36abcce7c417f4479" translate="yes" xml:space="preserve">
          <source>Unambiguous name: &lt;code&gt;CP932&lt;/code&gt;. &lt;code&gt;IANA&lt;/code&gt; name (also used by Mozilla, and provided as an alias by Encode): &lt;code&gt;Windows-31J&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f645668eee1c03a85fb2473dd516adceaef3f2d" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;!&quot;&lt;/code&gt; performs logical negation, that is, &quot;not&quot;. See also &lt;a href=&quot;#Logical-Not&quot;&gt;&lt;code&gt;not&lt;/code&gt;&lt;/a&gt; for a lower precedence version of this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f8a4652f1c5950bdfb9f442db5f7ff059a9e8ff" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;!&quot;&lt;/code&gt; performs logical negation, that is, &quot;not&quot;. See also &lt;code&gt;not&lt;/code&gt; for a lower precedence version of this.</source>
          <target state="translated">一元 &lt;code&gt;&quot;!&quot;&lt;/code&gt; 执行逻辑否定，即&amp;ldquo;不&amp;rdquo;。也见 &lt;code&gt;not&lt;/code&gt; 为这个优先级较低的版本。</target>
        </trans-unit>
        <trans-unit id="9a531b0100d0a01bbebb12554267e4d3655767b7" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;+&quot;&lt;/code&gt; has no effect whatsoever, even on strings. It is useful syntactically for separating a function name from a parenthesized expression that would otherwise be interpreted as the complete list of function arguments. (See examples above under &lt;a href=&quot;#Terms-and-List-Operators-%28Leftward%29&quot;&gt;&quot;Terms and List Operators (Leftward)&quot;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975143052b1e27f57ec5fcc07f42eb1c0eae9dc3" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;+&quot;&lt;/code&gt; has no effect whatsoever, even on strings. It is useful syntactically for separating a function name from a parenthesized expression that would otherwise be interpreted as the complete list of function arguments. (See examples above under &lt;a href=&quot;#Terms-and-List-Operators-(Leftward)&quot;&gt;Terms and List Operators (Leftward)&lt;/a&gt;.)</source>
          <target state="translated">一元 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 即使对字符串也不起作用。在语法上将函数名称与带括号的表达式分隔开很有用，否则该表达式会被解释为函数参数的完整列表。 （请参阅上面&amp;ldquo; &lt;a href=&quot;#Terms-and-List-Operators-(Leftward)&quot;&gt;条款和列表运算符（向左）&amp;rdquo;&lt;/a&gt;下的示例。）</target>
        </trans-unit>
        <trans-unit id="cbc2e014fe3be3f69d01617e0a9853fb77867e55" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;-&quot;&lt;/code&gt; performs arithmetic negation if the operand is numeric, including any string that looks like a number. If the operand is an identifier, a string consisting of a minus sign concatenated with the identifier is returned. Otherwise, if the string starts with a plus or minus, a string starting with the opposite sign is returned. One effect of these rules is that &lt;code&gt;-bareword&lt;/code&gt; is equivalent to the string &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt; . If, however, the string begins with a non-alphabetic character (excluding &lt;code&gt;&quot;+&quot;&lt;/code&gt; or &lt;code&gt;&quot;-&quot;&lt;/code&gt; ), Perl will attempt to convert the string to a numeric, and the arithmetic negation is performed. If the string cannot be cleanly converted to a numeric, Perl will give the warning &lt;b&gt;Argument &quot;the string&quot; isn't numeric in negation (-) at ...&lt;/b&gt;.</source>
          <target state="translated">如果操作数是数字（包括任何看起来像数字的字符串），一元 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 执行算术求反。如果操作数是标识符，则返回一个字符串，该字符串由与标识符连接的减号组成。否则，如果字符串以加号或减号开头，则返回以相反符号开头的字符串。这些规则的作用之一是 &lt;code&gt;-bareword&lt;/code&gt; 等效于字符串 &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt; 。但是，如果字符串以非字母字符（ &lt;code&gt;&quot;+&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 除外）开头，则Perl将尝试将字符串转换为数字，然后执行算术求反。如果字符串不能干净地转换为数字，Perl将给出警告&lt;b&gt;参数&amp;ldquo; string&amp;rdquo;不是...的否定（-）数字&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="7bfdc53979623a8376c9812be313cb442d92714a" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;-&quot;&lt;/code&gt; performs arithmetic negation if the operand is numeric, including any string that looks like a number. If the operand is an identifier, a string consisting of a minus sign concatenated with the identifier is returned. Otherwise, if the string starts with a plus or minus, a string starting with the opposite sign is returned. One effect of these rules is that &lt;code&gt;-bareword&lt;/code&gt; is equivalent to the string &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt;. If, however, the string begins with a non-alphabetic character (excluding &lt;code&gt;&quot;+&quot;&lt;/code&gt; or &lt;code&gt;&quot;-&quot;&lt;/code&gt;), Perl will attempt to convert the string to a numeric, and the arithmetic negation is performed. If the string cannot be cleanly converted to a numeric, Perl will give the warning &lt;b&gt;Argument &quot;the string&quot; isn't numeric in negation (-) at ...&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75765e3d8911e6ac713c74a3a1fc1d709b9ed2ea" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;\&quot;&lt;/code&gt; creates a reference to whatever follows it. See &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Do not confuse this behavior with the behavior of backslash within a string, although both forms do convey the notion of protecting the next thing from interpolation.</source>
          <target state="translated">一元 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 会创建一个对其后面内容的引用。参见&lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;和&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。不要混淆此行为与字符串中的反斜杠行为，尽管这两种形式都传达了保护下一个内容免受插值的影响的概念。</target>
        </trans-unit>
        <trans-unit id="ebbcbdaf6ef9f2a6fa62770e3fce7999d3f8a59a" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;\&quot;&lt;/code&gt; creates references. If its operand is a single sigilled thing, it creates a reference to that object. If its operand is a parenthesised list, then it creates references to the things mentioned in the list. Otherwise it puts its operand in list context, and creates a list of references to the scalars in the list provided by the operand. See &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Do not confuse this behavior with the behavior of backslash within a string, although both forms do convey the notion of protecting the next thing from interpolation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a440a050a6ba4df9312abb517ec0cbc1f89e1767" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;not&quot;&lt;/code&gt; returns the logical negation of the expression to its right. It's the equivalent of &lt;code&gt;&quot;!&quot;&lt;/code&gt; except for the very low precedence.</source>
          <target state="translated">一元 &lt;code&gt;&quot;not&quot;&lt;/code&gt; 返回表达式的逻辑取反。相当于 &lt;code&gt;&quot;!&quot;&lt;/code&gt; 除了非常低的优先级。</target>
        </trans-unit>
        <trans-unit id="eafed7c0deddc83d38ef5898a025102a424aea2a" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; performs bitwise negation, that is, 1's complement. For example, &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; is 0640. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt; and &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;.) Note that the width of the result is platform-dependent: &lt;code&gt;~0&lt;/code&gt; is 32 bits wide on a 32-bit platform, but 64 bits wide on a 64-bit platform, so if you are expecting a certain bit width, remember to use the &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; operator to mask off the excess bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dae9b42247425fb7e1e868bc6aec93255104f04" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; performs bitwise negation, that is, 1's complement. For example, &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; is 0640. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt; and &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.) Note that the width of the result is platform-dependent: &lt;code&gt;~0&lt;/code&gt; is 32 bits wide on a 32-bit platform, but 64 bits wide on a 64-bit platform, so if you are expecting a certain bit width, remember to use the &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; operator to mask off the excess bits.</source>
          <target state="translated">一元 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 执行按位求反，即1的补码。例如， &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; 是0640.（参见&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数算术&lt;/a&gt;和&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;按位字符串运算符&lt;/a&gt;。）注意，结果的宽度是依赖于平台的： &lt;code&gt;~0&lt;/code&gt; 是32个位宽为32位的平台上，但64个位宽在64位平台上，因此，如果期望某个位宽，请记住使用 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 运算符来掩盖多余的位。</target>
        </trans-unit>
        <trans-unit id="121bb514c3415be69016271f5f8950c0aed3f161" translate="yes" xml:space="preserve">
          <source>Unbackslashed prototype characters have special meanings. Any unbackslashed &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; eats all remaining arguments, and forces list context. An argument represented by &lt;code&gt;$&lt;/code&gt; forces scalar context. An &lt;code&gt;&amp;amp;&lt;/code&gt; requires an anonymous subroutine, which, if passed as the first argument, does not require the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; keyword or a subsequent comma.</source>
          <target state="translated">不加反斜杠的原型字符具有特殊含义。任何不加反斜杠的 &lt;code&gt;@&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; 都会吃掉所有剩余的参数，并强制列出上下文。由 &lt;code&gt;$&lt;/code&gt; 表示的参数强制标量上下文。一个 &lt;code&gt;&amp;amp;&lt;/code&gt; 需要匿名的子程序，其中，如果作为第一个参数传递，不需要 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 关键字或随后的逗号。</target>
        </trans-unit>
        <trans-unit id="0f4206d3ad193e4f502eb8614314c82b73d3aac7" translate="yes" xml:space="preserve">
          <source>Unbackslashed prototype characters have special meanings. Any unbackslashed &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; eats all remaining arguments, and forces list context. An argument represented by &lt;code&gt;$&lt;/code&gt; forces scalar context. An &lt;code&gt;&amp;amp;&lt;/code&gt; requires an anonymous subroutine, which, if passed as the first argument, does not require the &lt;code&gt;sub&lt;/code&gt; keyword or a subsequent comma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3738795de70b96657adef7c7eb0d0399db5d1dfd" translate="yes" xml:space="preserve">
          <source>Unbalanced context: %d more PUSHes than POPs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd301ac8b7825aca5986ed906c3a5149ebf3f404" translate="yes" xml:space="preserve">
          <source>Unbalanced saves: %d more saves than restores</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c20914fff1ee5340b7195287825b168d65cf279" translate="yes" xml:space="preserve">
          <source>Unbalanced scopes: %d more ENTERs than LEAVEs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="353a68e15d6c873dffbe66b456319369d1b6b50f" translate="yes" xml:space="preserve">
          <source>Unbalanced string table refcount: (%d) for &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d948ff04e713e8c3958319663d10246dfd6ee946" translate="yes" xml:space="preserve">
          <source>Unbalanced tmps: %d more allocs than frees</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825c40d18a2a673a59517a26d2876574d355db3e" translate="yes" xml:space="preserve">
          <source>Uncompress gzip, zip, bzip2 or lzop file/buffer</source>
          <target state="translated">解压gzip、zip、bzip2或lzop文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="d920a6c2ef6eab3bfedd330e8191658438c99755" translate="yes" xml:space="preserve">
          <source>Uncompress gzip, zip, bzip2, xz, lzma, lzip, lzf or lzop file/buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed55ac0a8b1616e77c1e8b5f3fc823c056e7f68" translate="yes" xml:space="preserve">
          <source>Uncompress zlib-based (zip, gzip) file/buffer</source>
          <target state="translated">解压基于zlib(zip,gzip)的文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="5566ebf8e86133343de98e57588751d94f017699" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">解压缩 &lt;code&gt;$input&lt;/code&gt; 并将未压缩的数据写入 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28f5f3ca9546807770e11a4b5cc0101b027504cd" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3241d8b84b7531f4c85af8e73c024fd4504975c7" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$source&lt;/code&gt; . If successful it returns the uncompressed data. Otherwise it returns</source>
          <target state="translated">解压缩 &lt;code&gt;$source&lt;/code&gt; 。如果成功，它将返回未压缩的数据。否则返回</target>
        </trans-unit>
        <trans-unit id="3e3d7aabce04dc1ae1923e54e8345382bb871093" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$source&lt;/code&gt;. If successful it returns the uncompressed data. Otherwise it returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8d3226186ea01833996c8b65de3f2a8379790e" translate="yes" xml:space="preserve">
          <source>Uncompression</source>
          <target state="translated">Uncompression</target>
        </trans-unit>
        <trans-unit id="4189d548d277ce627b98749a55c3556ffc35219e" translate="yes" xml:space="preserve">
          <source>Unconditionally match a bareword or any other single character, and then go back to step 1.</source>
          <target state="translated">无条件匹配一个裸字或其他任何一个单字,然后回到步骤1。</target>
        </trans-unit>
        <trans-unit id="577343970a5bf9b7cb8738f42c2797ca4589087a" translate="yes" xml:space="preserve">
          <source>Uncuddled elses and &quot;K&amp;amp;R&quot; style for indenting control constructs</source>
          <target state="translated">缩进的控件和&amp;ldquo; K＆R&amp;rdquo;风格的缩进控件结构</target>
        </trans-unit>
        <trans-unit id="11c11d31d108dd964ce797e5076b1d8839850791" translate="yes" xml:space="preserve">
          <source>Uncuddled elses.</source>
          <target state="translated">未被拥抱的地方。</target>
        </trans-unit>
        <trans-unit id="5cd9e75daaa9152346601595647eb2d9696e6583" translate="yes" xml:space="preserve">
          <source>Undef if an external</source>
          <target state="translated">如果是外部,则为不定义。</target>
        </trans-unit>
        <trans-unit id="a6e635cf2fd6fb596c7dbe39947e67bb7ea6fa49" translate="yes" xml:space="preserve">
          <source>Undefined format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4f02e6922be60fefc3ec95167f2596c8a6d252" translate="yes" xml:space="preserve">
          <source>Undefined format &quot;%s&quot; called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4edf1aebafd67a9b05c592beff7f41d45d0d8d" translate="yes" xml:space="preserve">
          <source>Undefined sort subroutine &quot;%s&quot; called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df75dc3ed124d993a3860e648584776b9c515c8" translate="yes" xml:space="preserve">
          <source>Undefined subroutine &amp;amp;%s called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b410752a7d8baa31a708ac9e0618b37a2bdd788d" translate="yes" xml:space="preserve">
          <source>Undefined subroutine &amp;amp;main::GetOptions called</source>
          <target state="translated">未定义的子程序＆main :: GetOptions被调用</target>
        </trans-unit>
        <trans-unit id="547eab04e6e04e1b4edec483ca694ca7539affef" translate="yes" xml:space="preserve">
          <source>Undefined subroutine called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264796a21d9347fe1112a79c8f0b60a38d55c6c6" translate="yes" xml:space="preserve">
          <source>Undefined subroutine in sort</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3680cc6661c9c64f65a5465eb19c791369f48e" translate="yes" xml:space="preserve">
          <source>Undefined top format &quot;%s&quot; called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc0e7464ad33c8fd897b6e1f38879e9424a6041b" translate="yes" xml:space="preserve">
          <source>Undefined value assigned to typeglob</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be1ae516287ece8c814ce973af8c8cef754916c" translate="yes" xml:space="preserve">
          <source>Undefines the array. Frees the memory used by the av to store its list of scalars. If any destructors are triggered as a result, the av itself may be freed.</source>
          <target state="translated">解除对数组的定义。释放av用于存储其标量列表的内存。如果因此触发了任何析构函数,则可以释放av本身。</target>
        </trans-unit>
        <trans-unit id="54917ea2121718cf7348ee74d00c8feedc82f150" translate="yes" xml:space="preserve">
          <source>Undefines the array. The XS equivalent of &lt;code&gt;undef(@array)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="270b863b48b0c13c0b01735bf826d9b654084021" translate="yes" xml:space="preserve">
          <source>Undefines the collation element as if it were unassigned in the &lt;code&gt;table&lt;/code&gt; . This reduces the size of the table. If an unassigned character appears in the string to be collated, the sort key is made from its codepoint as a single-character collation element, as it is greater than any other assigned collation elements (in the codepoint order among the unassigned characters). But, it'd be better to ignore characters unfamiliar to you and maybe never used.</source>
          <target state="translated">取消定义排序规则元素，就好像在 &lt;code&gt;table&lt;/code&gt; 中未分配该元素一样。这样可以减小表的大小。如果未分配的字符出现在要校对的字符串中，则排序键将从其代码点作为单字符归类元素，因为它大于任何其他已分配的归类元素（按未分配字符中的代码点顺序）。但是，最好忽略不熟悉的字符，也许永远不要使用。</target>
        </trans-unit>
        <trans-unit id="6c572aa720a9e02b4868a08c5ea6700924c6a793" translate="yes" xml:space="preserve">
          <source>Undefines the collation element as if it were unassigned in the &lt;code&gt;table&lt;/code&gt;. This reduces the size of the table. If an unassigned character appears in the string to be collated, the sort key is made from its codepoint as a single-character collation element, as it is greater than any other assigned collation elements (in the codepoint order among the unassigned characters). But, it'd be better to ignore characters unfamiliar to you and maybe never used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b61a323c52c38306eb024952539f4f8c5a7ffe3" translate="yes" xml:space="preserve">
          <source>Undefines the hash. The XS equivalent of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef(%hash)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">未定义哈希。XS等效于 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef(%hash)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e5b088250fea82ab591b0cfc87d6babcdba55fe" translate="yes" xml:space="preserve">
          <source>Undefines the hash. The XS equivalent of &lt;code&gt;undef(%hash)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21918cc87ca44856538ac74361e547848b42b7b4" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt; ), a hash (using &lt;code&gt;%&lt;/code&gt; ), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt; ), or a typeglob (using &lt;code&gt;*&lt;/code&gt; ). Saying &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;#delete&quot;&gt;delete&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="translated">未定义EXPR的值，该值必须为左值。仅用于标量值，数组（使用 &lt;code&gt;@&lt;/code&gt; ），哈希（使用 &lt;code&gt;%&lt;/code&gt; ），子例程（使用 &lt;code&gt;&amp;amp;&lt;/code&gt; ）或typeglob（使用 &lt;code&gt;*&lt;/code&gt; ）。在大多数预定义变量或DBM列表值上说 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; 可能不会达到您的期望，所以不要那样做。请参阅&lt;a href=&quot;#delete&quot;&gt;删除&lt;/a&gt;。始终返回未定义的值。您可以省略EXPR，在这种情况下，所有内容均未定义，但仍会得到一个未定义的值，例如，可以从子例程返回，分配给变量或作为参数传递。例子：</target>
        </trans-unit>
        <trans-unit id="12772c94a5d6a3598c32da79f4c1c4affc5b608e" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt; ), a hash (using &lt;code&gt;%&lt;/code&gt; ), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt; ), or a typeglob (using &lt;code&gt;*&lt;/code&gt; ). Saying &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="translated">未定义EXPR的值，该值必须为左值。仅用于标量值，数组（使用 &lt;code&gt;@&lt;/code&gt; ），哈希（使用 &lt;code&gt;%&lt;/code&gt; ），子例程（使用 &lt;code&gt;&amp;amp;&lt;/code&gt; ）或typeglob（使用 &lt;code&gt;*&lt;/code&gt; ）。在大多数预定义变量或DBM列表值上说 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; 可能不会达到您的期望，所以不要那样做。请参阅&lt;a href=&quot;delete&quot;&gt;删除&lt;/a&gt;。始终返回未定义的值。您可以省略EXPR，在这种情况下，所有内容均未定义，但仍会得到一个未定义的值，例如，可以从子例程返回，分配给变量或作为参数传递。例子：</target>
        </trans-unit>
        <trans-unit id="638220651f84b9cd00c5941897d28ba69d79dc1a" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt;), a hash (using &lt;code&gt;%&lt;/code&gt;), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt;), or a typeglob (using &lt;code&gt;*&lt;/code&gt;). Saying &lt;code&gt;undef $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;#delete-EXPR&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b42ea56822642513e4f112de38357bed9dd6a64" translate="yes" xml:space="preserve">
          <source>Undefining this symbol disables the PerlIO abstraction. PerlIO is now the default; it is not recommended to disable PerlIO.</source>
          <target state="translated">取消定义这个符号可以禁用PerlIO抽象。PerlIO现在是默认的,不建议禁用PerlIO。</target>
        </trans-unit>
        <trans-unit id="14931b1ffe46d4f806d87924392ea8d8ba051a3f" translate="yes" xml:space="preserve">
          <source>Undefining this symbol forces Perl to be compiled statically.</source>
          <target state="translated">不定义这个符号会强制Perl进行静态编译。</target>
        </trans-unit>
        <trans-unit id="55d31ccf7c7a9061158740ae0e4ba2a4be4c51d6" translate="yes" xml:space="preserve">
          <source>Under &quot;Classic&quot; MacOS, a perl program will have the appropriate Creator and Type, so that double-clicking them will invoke the MacPerl application. Under Mac OS X, clickable apps can be made from any &lt;code&gt;#!&lt;/code&gt; script using Wil Sanchez' DropScript utility: &lt;a href=&quot;http://www.wsanchez.net/software/&quot;&gt;http://www.wsanchez.net/software/&lt;/a&gt; .</source>
          <target state="translated">在&amp;ldquo;经典&amp;rdquo; MacOS下，perl程序将具有适当的创建者和类型，因此双击它们将调用MacPerl应用程序。在Mac OS X下，可通过任何 &lt;code&gt;#!&lt;/code&gt; 来创建可点击的应用程序！使用Wil Sanchez的DropScript实用程序编写脚本：&lt;a href=&quot;http://www.wsanchez.net/software/&quot;&gt;http&lt;/a&gt; ://www.wsanchez.net/software/ 。</target>
        </trans-unit>
        <trans-unit id="7de147ca0cf42a020c2b34e4934080e8fbf00bba" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt;, test number 2 would</source>
          <target state="translated">在&lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness下&lt;/a&gt;，测试编号2将</target>
        </trans-unit>
        <trans-unit id="830e70bc7050b5ad58debeaf947b37217d6be21e" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt;, test number 2 would</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50510298fcc80cb0b2cfe5fcb98eb1382cb9d484" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , detection step of discontiguous contractions will be skipped.</source>
          <target state="translated">在 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; ，不连续收缩的检测步骤将被跳过。</target>
        </trans-unit>
        <trans-unit id="6a769e92dc491fba4fdaa440dbac9751e38e85b4" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt;, detection step of discontiguous contractions will be skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1bc7be7a27894ec56a14e00f77fdf88c07658e" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;array_base&quot;&lt;/code&gt; , &lt;code&gt;$[&lt;/code&gt; no longer has any effect, and always contains 0. Assigning 0 to it is permitted, but any other value will produce an error.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; ，或者 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;array_base&quot;&lt;/code&gt; ， &lt;code&gt;$[&lt;/code&gt; 不再具有任何作用，并且始终包含0。允许为其分配0，但是任何其他值都会产生错误。</target>
        </trans-unit>
        <trans-unit id="bacf555aace53131b41a0f7ef63c9e3e7d03589b" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;unicode_strings&lt;/code&gt; starting in Perl 5.12.0, Unicode rules are generally used. See &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; for details on how this works in combination with various other pragmas.</source>
          <target state="translated">在 &lt;code&gt;unicode_strings&lt;/code&gt; 在Perl 5.12.0开始，统一规则通常使用。有关与其他各种语用结合使用的详细信息，请参见&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f60303853e6438f23bfd0e7253ff8d6666354a3e" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;unicode_strings&lt;/code&gt; starting in Perl 5.12.0, Unicode rules are generally used. See &lt;a href=&quot;perlfunc#lc&quot;&gt;&quot;lc&quot; in perlfunc&lt;/a&gt; for details on how this works in combination with various other pragmas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fe5caf324bcb104f1845ec70df5cb17cd45071" translate="yes" xml:space="preserve">
          <source>Under Cygwin, $^E is the same as $!. When using &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32 API Functions&lt;/a&gt;, use &lt;code&gt;Win32::GetLastError()&lt;/code&gt; to get the last Windows error.</source>
          <target state="translated">在Cygwin下，$ ^ E与$！相同。使用&lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32 API Functions时&lt;/a&gt;，请使用 &lt;code&gt;Win32::GetLastError()&lt;/code&gt; 获取最后的Windows错误。</target>
        </trans-unit>
        <trans-unit id="bf1bd7b89a19b28d20d4df86f951acf9fc393dd7" translate="yes" xml:space="preserve">
          <source>Under Cygwin, $^E is the same as $!. When using &lt;a href=&quot;win32&quot;&gt;Win32 API Functions&lt;/a&gt;, use &lt;code&gt;Win32::GetLastError()&lt;/code&gt; to get the last Windows error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08490cc0df2a509f16cddc3cf2a4ae40e649767f" translate="yes" xml:space="preserve">
          <source>Under EBCDIC platforms, &lt;code&gt;e2char($n)&lt;/code&gt; may not always be the same as &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(e2charnum($n))&lt;/a&gt;&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr($Name2character_number{$name})&lt;/a&gt;&lt;/code&gt;, because the strings are returned as native, and the numbers are returned as Unicode. However, for Perls starting with v5.8, &lt;code&gt;e2char($n)&lt;/code&gt; is the same as &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/a&gt;&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在EBCDIC平台上， &lt;code&gt;e2char($n)&lt;/code&gt; 可能并不总是与 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(e2charnum($n))&lt;/a&gt;&lt;/code&gt; ，对于 &lt;code&gt;$Name2character{$name}&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr($Name2character_number{$name})&lt;/a&gt;&lt;/code&gt; ，因为返回了字符串作为本机，并且数字以Unicode返回。但是，对于以v5.8开头的Perls， &lt;code&gt;e2char($n)&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;$Name2character{$name}&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24801e56e20625b1799dc0d5ebdcc72e9b0dcde9" translate="yes" xml:space="preserve">
          <source>Under EBCDIC platforms, &lt;code&gt;e2char($n)&lt;/code&gt; may not always be the same as &lt;code&gt;chr(e2charnum($n))&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;chr($Name2character_number{$name})&lt;/code&gt;, because the strings are returned as native, and the numbers are returned as Unicode. However, for Perls starting with v5.8, &lt;code&gt;e2char($n)&lt;/code&gt; is the same as &lt;code&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc50122941a9cec999fb031245122855f9d5976" translate="yes" xml:space="preserve">
          <source>Under NFS this will use the time of the NFS server, not the time of the local machine. If there is a time synchronization problem, the NFS server and local machine will have different times. The Unix &lt;a href=&quot;http://man.he.net/man1/touch&quot;&gt;touch(1)&lt;/a&gt; command will in fact normally use this form instead of the one shown in the first example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18254acc65d18b7ddbf875f7bfc47db0d75ce39a" translate="yes" xml:space="preserve">
          <source>Under NFS this will use the time of the NFS server, not the time of the local machine. If there is a time synchronization problem, the NFS server and local machine will have different times. The Unix touch(1) command will in fact normally use this form instead of the one shown in the first example.</source>
          <target state="translated">在NFS下,这将使用NFS服务器的时间,而不是本地机器的时间。如果存在时间同步问题,NFS 服务器和本地机器的时间将不同。事实上,Unix touch(1)命令通常会使用这种形式,而不是第一个例子中所示的形式。</target>
        </trans-unit>
        <trans-unit id="f3924a4fe96e1e85710f171a0842dfde3423eb52" translate="yes" xml:space="preserve">
          <source>Under OS/2, &lt;code&gt;$^E&lt;/code&gt; is set to the error code of the last call to OS/2 API either via CRT, or directly from perl.</source>
          <target state="translated">在OS / 2下，将 &lt;code&gt;$^E&lt;/code&gt; 设置为通过CRT或直接从perl对OS / 2 API的最后一次调用的错误代码。</target>
        </trans-unit>
        <trans-unit id="19dcdc34494760727e410f497dbed91a176d6c5e" translate="yes" xml:space="preserve">
          <source>Under Perl 5.10 only, using a string eval when &lt;code&gt;autodie&lt;/code&gt; is in effect can cause the autodie behaviour to leak into the surrounding scope. This can be worked around by using a &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; at the end of the scope to explicitly remove autodie's effects, or by avoiding the use of string eval.</source>
          <target state="translated">仅在Perl 5.10下，当自动 &lt;code&gt;autodie&lt;/code&gt; 有效时使用字符串eval 可能会导致autodie行为泄漏到周围的范围中。可以通过在范围末尾使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; 来显式删除autodie的效果，或避免使用字符串eval来解决此问题。</target>
        </trans-unit>
        <trans-unit id="141394caeda9c5ad5a22f24134bab7c210cd57fb" translate="yes" xml:space="preserve">
          <source>Under Perl 5.10 only, using a string eval when &lt;code&gt;autodie&lt;/code&gt; is in effect can cause the autodie behaviour to leak into the surrounding scope. This can be worked around by using a &lt;code&gt;no autodie&lt;/code&gt; at the end of the scope to explicitly remove autodie's effects, or by avoiding the use of string eval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1824d549ede70b3449b6bc94fa47857184a96f9f" translate="yes" xml:space="preserve">
          <source>Under Perl 5.18 and later, SvREADONLY only applies to read-only variables, and, under 5.20, copy-on-write scalars can also be read-only, so the above check is incorrect. You just want:</source>
          <target state="translated">在Perl 5.18及以后的版本中,SvREADONLY只适用于只读变量,而在5.20下,写后复制的标量也可以是只读的,所以上面的检查是不正确的。你只是想。</target>
        </trans-unit>
        <trans-unit id="8d107d150b9abd6d04d1d29a993fa6ea829d9209" translate="yes" xml:space="preserve">
          <source>Under Perl 5.8 only, &lt;code&gt;autodie&lt;/code&gt;</source>
          <target state="translated">仅在Perl 5.8下， &lt;code&gt;autodie&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e28f5c058f0915564622ac46660d6f84c05ab318" translate="yes" xml:space="preserve">
          <source>Under Perl 5.8, the &lt;code&gt;given/when&lt;/code&gt; structure is not available, so the following structure may be used:</source>
          <target state="translated">在Perl 5.8中， &lt;code&gt;given/when&lt;/code&gt; 结构不可用，因此可以使用以下结构：</target>
        </trans-unit>
        <trans-unit id="ef993909ab6a97a91baf7e650bc7ce46f77c2516" translate="yes" xml:space="preserve">
          <source>Under QNX 6.2.0 there are still a few tests which fail. See below and hints/qnx.sh for more information.</source>
          <target state="translated">在 QNX 6.2.0 下,仍有一些测试失败。请参见下文和提示/qnx.sh 了解更多信息。</target>
        </trans-unit>
        <trans-unit id="66b5ec5cf7fb5924aee8dffa63eba13ccd60d52e" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, there are a few case-insensitive matches that cross the 255/256 boundary. Except for UTF-8 locales in Perls v5.20 and later, these are disallowed under &lt;code&gt;/l&lt;/code&gt; . For example, 0xFF (on ASCII platforms) does not caselessly match the character at 0x178, &lt;code&gt;LATIN
CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt; , because 0xFF may not be &lt;code&gt;LATIN SMALL
LETTER Y WITH DIAERESIS&lt;/code&gt; in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is.</source>
          <target state="translated">根据Unicode规则，有一些不区分大小写的匹配跨越255/256边界。除了Perls v5.20及更高版本中的UTF-8语言环境外， &lt;code&gt;/l&lt;/code&gt; 下不允许使用这些语言环境。例如，0xFF（在ASCII平台上）不能不区分大小写地匹配0x178的字符， &lt;code&gt;LATIN CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt; ，因为在当前语言环境中0xFF可能不是 &lt;code&gt;LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; ，而Perl无法知道是否字符甚至存在于语言环境中，更不用说代码点了。</target>
        </trans-unit>
        <trans-unit id="a229f317f16db87320c5e41b43cc77785168f869" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, there are a few case-insensitive matches that cross the 255/256 boundary. Except for UTF-8 locales in Perls v5.20 and later, these are disallowed under &lt;code&gt;/l&lt;/code&gt;. For example, 0xFF (on ASCII platforms) does not caselessly match the character at 0x178, &lt;code&gt;LATIN CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt;, because 0xFF may not be &lt;code&gt;LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666da3b151d79c3526ad94c74b4a7b5272bc4ad7" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, these upper-Latin1 characters are interpreted as Unicode code points, which means they have the same semantics as Latin-1 (ISO-8859-1) and C1 controls.</source>
          <target state="translated">根据Unicode规则,这些上拉丁1字符被解释为Unicode码点,这意味着它们与Latin-1(ISO-8859-1)和C1控制具有相同的语义。</target>
        </trans-unit>
        <trans-unit id="15d191765263aacd2b7fcad31e78fb6cf886a85b" translate="yes" xml:space="preserve">
          <source>Under VMS this reflects the actual VMS exit status; i.e. it is the same as &lt;code&gt;$?&lt;/code&gt; when the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; is in effect.</source>
          <target state="translated">在VMS下，这反映了VMS的实际退出状态；即与 &lt;code&gt;$?&lt;/code&gt; 相同吗？当编译指示 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 时，使用 vmsish'status'。</target>
        </trans-unit>
        <trans-unit id="c6482226ed3d921882dbfe662280c6e28493cbae" translate="yes" xml:space="preserve">
          <source>Under VMS this reflects the actual VMS exit status; i.e. it is the same as &lt;code&gt;$?&lt;/code&gt; when the pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737324e93129014d33d4923a010ebe747aa167f7" translate="yes" xml:space="preserve">
          <source>Under VMS, &lt;code&gt;$^E&lt;/code&gt; provides the VMS status value from the last system error. This is more specific information about the last system error than that provided by &lt;code&gt;$!&lt;/code&gt; . This is particularly important when &lt;code&gt;$!&lt;/code&gt; is set to &lt;b&gt;EVMSERR&lt;/b&gt;.</source>
          <target state="translated">在VMS下， &lt;code&gt;$^E&lt;/code&gt; 提供上一次系统错误后的VMS状态值。与 &lt;code&gt;$!&lt;/code&gt; 提供的信息相比，这是有关上一个系统错误的更具体的信息。。这在 &lt;code&gt;$!&lt;/code&gt; 时尤其重要！设置为&lt;b&gt;EVMSERR&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="76dfcc4ab4ed83661a267ed44726342ca382d02d" translate="yes" xml:space="preserve">
          <source>Under VMS, &lt;code&gt;$^E&lt;/code&gt; provides the VMS status value from the last system error. This is more specific information about the last system error than that provided by &lt;code&gt;$!&lt;/code&gt;. This is particularly important when &lt;code&gt;$!&lt;/code&gt; is set to &lt;b&gt;EVMSERR&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b3f98ca540bd0c81d34840956f838255c71318" translate="yes" xml:space="preserve">
          <source>Under VMS, if there is no directory information in the $path, then the current default device and directory is used.</source>
          <target state="translated">在VMS下,如果$path中没有目录信息,则使用当前默认的设备和目录。</target>
        </trans-unit>
        <trans-unit id="3aaae4cddb5ecef27b2c450c8cc4b4b174c7016f" translate="yes" xml:space="preserve">
          <source>Under VMS, the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status, instead of the default emulation of POSIX status; see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt; for details.</source>
          <target state="translated">在VMS下， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 的编译指示使 &lt;code&gt;$?&lt;/code&gt; 反映实际的VMS退出状态，而不是POSIX状态的默认模拟；看到&lt;a href=&quot;perlvms#%24%3f&quot;&gt;$？在perlvms中&lt;/a&gt;获取详细信息。</target>
        </trans-unit>
        <trans-unit id="9fe540ff184660416cab5f62ce2d7a86b31b31b4" translate="yes" xml:space="preserve">
          <source>Under VMS, the pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status, instead of the default emulation of POSIX status; see &lt;a href=&quot;perlvms#%24%3F&quot;&gt;&quot;$?&quot; in perlvms&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711e7c0754f84b5e7bda634825aa4039a4a70c54" translate="yes" xml:space="preserve">
          <source>Under Win32's &quot;test&quot; target you may use the TEST_SWITCHES and TEST_FILES environment variables to control the behaviour of</source>
          <target state="translated">在Win32的 &quot;test &quot;目标下,你可以使用TEST_SWITCHES和TEST_FILES环境变量来控制下面的行为</target>
        </trans-unit>
        <trans-unit id="53c6d0758bf54648c779157ed9111dd650df9efe" translate="yes" xml:space="preserve">
          <source>Under Win32, &lt;code&gt;$^E&lt;/code&gt; always returns the last error information reported by the Win32 call &lt;code&gt;GetLastError()&lt;/code&gt; which describes the last error from within the Win32 API. Most Win32-specific code will report errors via &lt;code&gt;$^E&lt;/code&gt; . ANSI C and Unix-like calls set &lt;code&gt;errno&lt;/code&gt; and so most portable Perl code will report errors via &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">在Win32下， &lt;code&gt;$^E&lt;/code&gt; 总是返回Win32调用 &lt;code&gt;GetLastError()&lt;/code&gt; 报告的最后错误信息，该信息描述了Win32 API中的最后一个错误。大多数特定于Win32的代码将通过 &lt;code&gt;$^E&lt;/code&gt; 报告错误。ANSI C和类Unix调用设置 &lt;code&gt;errno&lt;/code&gt; ，因此大多数可移植的Perl代码将通过 &lt;code&gt;$!&lt;/code&gt; 报告错误！。</target>
        </trans-unit>
        <trans-unit id="9e14095c735f4241ba86445b598120697973ed27" translate="yes" xml:space="preserve">
          <source>Under Win32, &lt;code&gt;$^E&lt;/code&gt; always returns the last error information reported by the Win32 call &lt;code&gt;GetLastError()&lt;/code&gt; which describes the last error from within the Win32 API. Most Win32-specific code will report errors via &lt;code&gt;$^E&lt;/code&gt;. ANSI C and Unix-like calls set &lt;code&gt;errno&lt;/code&gt; and so most portable Perl code will report errors via &lt;code&gt;$!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5b168779b6e4455afcf5fa22f2ddb16d807c4c" translate="yes" xml:space="preserve">
          <source>Under Windows NT, &lt;code&gt;$sPath&lt;/code&gt; can start with &lt;code&gt;&quot;//?/&quot;&lt;/code&gt; to allow the use of paths longer than &lt;code&gt;MAX_PATH&lt;/code&gt; [for UNC paths, replace the leading &lt;code&gt;&quot;//&quot;&lt;/code&gt; with &lt;code&gt;&quot;//?/UNC/&quot;&lt;/code&gt;, as in &lt;code&gt;&quot;//?/UNC/Server/Share/Dir/File.Ext&quot;&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445377f279bee790252626a9efe4c710c5fb31ec" translate="yes" xml:space="preserve">
          <source>Under Windows and VMS the option file is named</source>
          <target state="translated">在Windows和VMS下,选项文件名为</target>
        </trans-unit>
        <trans-unit id="991af3b0df6455b17cae9de8484aa49771ee9333" translate="yes" xml:space="preserve">
          <source>Under a few operating systems, &lt;code&gt;$^E&lt;/code&gt; may contain a more verbose error indicator, such as in this case, &quot;CDROM tray not closed.&quot; Systems that do not support extended error messages leave &lt;code&gt;$^E&lt;/code&gt; the same as &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">在某些操作系统下， &lt;code&gt;$^E&lt;/code&gt; 可能包含更详细的错误指示符，例如在这种情况下，&amp;ldquo; CDROM托盘未关闭&amp;rdquo;。不支持扩展错误消息的系统将 &lt;code&gt;$^E&lt;/code&gt; 与 &lt;code&gt;$!&lt;/code&gt; 相同。。</target>
        </trans-unit>
        <trans-unit id="9cba04bbbcd7e6b0b58cb405fffa7701c6b86b43" translate="yes" xml:space="preserve">
          <source>Under a few operating systems, &lt;code&gt;$^E&lt;/code&gt; may contain a more verbose error indicator, such as in this case, &quot;CDROM tray not closed.&quot; Systems that do not support extended error messages leave &lt;code&gt;$^E&lt;/code&gt; the same as &lt;code&gt;$!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8188d9bfb2c028e78df0c34f466ab12923ca95e" translate="yes" xml:space="preserve">
          <source>Under bignum (or bigint or bigrat), Perl will &quot;upgrade&quot; the numbers appropriately. This means that:</source>
          <target state="translated">在bignum(或bigint或bigrat)下,Perl会适当地 &quot;升级 &quot;数字。这意味着</target>
        </trans-unit>
        <trans-unit id="936167913e1d36052a60fe747af5e2acfb71f327" translate="yes" xml:space="preserve">
          <source>Under case-sensitive matching, these both match the same code points as &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; (&lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; ). The difference is that under &lt;code&gt;/i&lt;/code&gt; caseless matching, these match the same as &lt;code&gt;\p{Cased}&lt;/code&gt; , whereas &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; matches &lt;code&gt;\p{Cased_Letter&lt;/code&gt; ).</source>
          <target state="translated">在区分大小写的匹配下，它们都与 &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; （ &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; ）相同的代码点匹配。区别在于，在 &lt;code&gt;/i&lt;/code&gt; 不区分大小写的匹配下，这些匹配与 &lt;code&gt;\p{Cased}&lt;/code&gt; ，而 &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; 匹配 &lt;code&gt;\p{Cased_Letter&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="16d7375a7fe76f99800381f8b36c3f7a2c76e668" translate="yes" xml:space="preserve">
          <source>Under case-sensitive matching, these both match the same code points as &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; (&lt;code&gt;\p{gc=lt}&lt;/code&gt;). The difference is that under &lt;code&gt;/i&lt;/code&gt; caseless matching, these match the same as &lt;code&gt;\p{Cased}&lt;/code&gt;, whereas &lt;code&gt;\p{gc=lt}&lt;/code&gt; matches &lt;code&gt;\p{Cased_Letter&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58098e551f5eebaa46d0d3a19d00f14ced3f4d46" translate="yes" xml:space="preserve">
          <source>Under ithreads the optree is read only. If you want to enforce this, to check for write accesses from buggy code, compile with &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; to enable code that allocates op memory via &lt;code&gt;mmap&lt;/code&gt; , and sets it read-only when it is attached to a subroutine. Any write access to an op results in a &lt;code&gt;SIGBUS&lt;/code&gt; and abort.</source>
          <target state="translated">在ithreads下，optree是只读的。如果要强制执行此操作，要检查来自错误代码的写访问，请使用 &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; 进行编译，以启用通过 &lt;code&gt;mmap&lt;/code&gt; 分配操作内存的代码，并在将其附加到子例程时将其设置为只读。对op的任何写访问都会导致 &lt;code&gt;SIGBUS&lt;/code&gt; 并中止。</target>
        </trans-unit>
        <trans-unit id="21eb1ae9bcc07ffd150bd4cea8dca0ae9a233a36" translate="yes" xml:space="preserve">
          <source>Under ithreads the optree is read only. If you want to enforce this, to check for write accesses from buggy code, compile with &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; to enable code that allocates op memory via &lt;code&gt;mmap&lt;/code&gt;, and sets it read-only when it is attached to a subroutine. Any write access to an op results in a &lt;code&gt;SIGBUS&lt;/code&gt; and abort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d556cba6d79170127d0f04c67e73cd273a0ab83" translate="yes" xml:space="preserve">
          <source>Under normal circumstances, the CV forgets about its slab (decrementing the reference count) when the root is attached. So the slab reference counting that happens when ops are freed takes care of freeing the slab. In some cases, the CV is told to forget about the slab (&lt;code&gt;cv_forget_slab&lt;/code&gt;) precisely so that the ops can survive after the CV is done away with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c5c0dce73b6a45e16e6c80203f13488d40f1dd" translate="yes" xml:space="preserve">
          <source>Under the &quot;switch&quot; feature, Perl gains the experimental keywords &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt; . Starting from Perl 5.16, one can prefix the switch keywords with &lt;code&gt;CORE::&lt;/code&gt; to access the feature without a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; statement. The keywords &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; are analogous to &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; in other languages, so the code in the previous section could be rewritten as</source>
          <target state="translated">在&amp;ldquo;开关&amp;rdquo;功能，Perl中获得了实验用的关键字 &lt;code&gt;given&lt;/code&gt; ， &lt;code&gt;when&lt;/code&gt; ， &lt;code&gt;default&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;break&lt;/code&gt; 。从Perl 5.16开始，可以在switch关键字前添加 &lt;code&gt;CORE::&lt;/code&gt; 前缀，以在不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; 语句的情况下访问该功能。 &lt;code&gt;given&lt;/code&gt; 的关键字和 &lt;code&gt;when&lt;/code&gt; 类似于其他语言中的 &lt;code&gt;switch&lt;/code&gt; 和 &lt;code&gt;case&lt;/code&gt; ，因此上一节中的代码可以重写为</target>
        </trans-unit>
        <trans-unit id="429aec7265e307e4dfd4174d6cfde74d06bbb3ef" translate="yes" xml:space="preserve">
          <source>Under the &quot;switch&quot; feature, Perl gains the experimental keywords &lt;code&gt;given&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt;. Starting from Perl 5.16, one can prefix the switch keywords with &lt;code&gt;CORE::&lt;/code&gt; to access the feature without a &lt;code&gt;use feature&lt;/code&gt; statement. The keywords &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; are analogous to &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; in other languages -- though &lt;code&gt;continue&lt;/code&gt; is not -- so the code in the previous section could be rewritten as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f764edcb644a2a893a6fefa3a757e31fb881f9a7" translate="yes" xml:space="preserve">
          <source>Under the &lt;a href=&quot;feature#The-%27unicode_eval%27-and-%27evalbytes%27-features&quot;&gt;&lt;code&gt;&quot;unicode_eval&quot;&lt;/code&gt; feature&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcedc6c33e9a6ba46a7f82a03dd4b7c259f61b3" translate="yes" xml:space="preserve">
          <source>Under the &lt;code&gt;unicode_eval&lt;/code&gt; feature, Perl's &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; function, when passed a string, will evaluate it as a string of characters, ignoring any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declarations. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; exists to declare the encoding of the script, which only makes sense for a stream of bytes, not a string of characters. Source filters are forbidden, as they also really only make sense on strings of bytes. Any attempt to activate a source filter will result in an error.</source>
          <target state="translated">在 &lt;code&gt;unicode_eval&lt;/code&gt; 功能下，Perl的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 函数在传递字符串时会将其评估为字符串，而不会 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 声明。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 可以声明脚本的编码，该脚本仅对字节流有意义，而对字符串不起作用。禁止使用源过滤器，因为它们实际上仅对字节字符串有意义。任何尝试激活源过滤器的操作都会导致错误。</target>
        </trans-unit>
        <trans-unit id="3ed7e8de69faa9a39e5b719579b31e326e5e1ba3" translate="yes" xml:space="preserve">
          <source>Under the Mac, it depends which environment you are using. The MacPerl shell, or MPW, is much like Unix shells in its support for several quoting variants, except that it makes free use of the Mac's non-ASCII characters as control characters.</source>
          <target state="translated">在Mac下,要看你使用的是什么环境。MacPerl shell,也就是MPW,和Unix shell很像,它支持几种引号变体,只是它可以自由使用Mac的非ASCII字符作为控制字符。</target>
        </trans-unit>
        <trans-unit id="57a69bed4d30aeb2c23df15a4942d2f1bc4e9a99" translate="yes" xml:space="preserve">
          <source>Under the current implementation, the &lt;code&gt;foreach&lt;/code&gt; loop can be anywhere within the &lt;code&gt;when&lt;/code&gt; modifier's dynamic scope, but must be within the &lt;code&gt;given&lt;/code&gt; block's lexical scope. This restricted may be relaxed in a future release. See &lt;a href=&quot;#Switch-Statements&quot;&gt;Switch Statements&lt;/a&gt; below.</source>
          <target state="translated">在当前实现下， &lt;code&gt;foreach&lt;/code&gt; 循环可以在 &lt;code&gt;when&lt;/code&gt; 修饰符的动态范围内的任何位置，但必须在 &lt;code&gt;given&lt;/code&gt; 块的词法范围内。在将来的版本中，可以放宽此限制。请参阅下面的&lt;a href=&quot;#Switch-Statements&quot;&gt;切换语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2c16149ecdeeb74ed5502e1f6dbfb7232f42a07" translate="yes" xml:space="preserve">
          <source>Under the current implementation, the &lt;code&gt;foreach&lt;/code&gt; loop can be anywhere within the &lt;code&gt;when&lt;/code&gt; modifier's dynamic scope, but must be within the &lt;code&gt;given&lt;/code&gt; block's lexical scope. This restriction may be relaxed in a future release. See &lt;a href=&quot;#Switch-Statements&quot;&gt;&quot;Switch Statements&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08f959b6899ef90dffb2ee9e0e0a8572c0a7c28" translate="yes" xml:space="preserve">
          <source>Under the hood, Perl filehandles are instances of the &lt;code&gt;IO::Handle&lt;/code&gt; or &lt;code&gt;IO::File&lt;/code&gt; class. Once you have an open filehandle, you can call methods on it. Additionally, you can call methods on the &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , and &lt;code&gt;STDERR&lt;/code&gt; filehandles.</source>
          <target state="translated">在幕后，Perl文件句柄是 &lt;code&gt;IO::Handle&lt;/code&gt; 或 &lt;code&gt;IO::File&lt;/code&gt; 类的实例。拥有打开的文件句柄后，可以在其上调用方法。此外，您可以在 &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; 和 &lt;code&gt;STDERR&lt;/code&gt; 文件句柄上调用方法。</target>
        </trans-unit>
        <trans-unit id="39f4d0de021895e742d4650602144370ddd79e3a" translate="yes" xml:space="preserve">
          <source>Under the hood, Perl filehandles are instances of the &lt;code&gt;IO::Handle&lt;/code&gt; or &lt;code&gt;IO::File&lt;/code&gt; class. Once you have an open filehandle, you can call methods on it. Additionally, you can call methods on the &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt;, and &lt;code&gt;STDERR&lt;/code&gt; filehandles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16abd29e91ee37c03769fcf588081b10ade9062f" translate="yes" xml:space="preserve">
          <source>Under the same license as Perl itself</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e7e970c4cb85f5a1a451cbbaa7bb6fdbefed11" translate="yes" xml:space="preserve">
          <source>Underlying implementation for the &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; Perl function. Note that the perl-level function is vaguely deprecated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; Perl功能的基础实现。请注意，不建议使用perl级功能。</target>
        </trans-unit>
        <trans-unit id="7f6fc2f81f4959a48ec9de583348cb6833131799" translate="yes" xml:space="preserve">
          <source>Underlying implementation for the &lt;code&gt;reset&lt;/code&gt; Perl function. Note that the perl-level function is vaguely deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d53a031b5fe95ac3434bee7e57607b8155a1a48" translate="yes" xml:space="preserve">
          <source>Understand References Today</source>
          <target state="translated">了解今天的参考资料</target>
        </trans-unit>
        <trans-unit id="d2b515bbbe667df83c6f17f27b425a07b052435e" translate="yes" xml:space="preserve">
          <source>Understand that this removes the case-insensitivity feature of this module.</source>
          <target state="translated">理解这将删除该模块的大小写不敏感功能。</target>
        </trans-unit>
        <trans-unit id="5dff374e163235318e5ce8f7742ec1049ed8b995" translate="yes" xml:space="preserve">
          <source>Understanding the Magic of Tied Hashes and Arrays</source>
          <target state="translated">理解绑定哈希值和数组的神奇之处</target>
        </trans-unit>
        <trans-unit id="4fad51d89f7e0dadc266115be3afc11b52bc9806" translate="yes" xml:space="preserve">
          <source>Undertake to build a new set of Perl images using VMS commands. Since VMS does dynamic loading, it's not necessary to statically link each extension into the Perl image, so this isn't the normal build path. Consequently, it hasn't really been tested, and may well be incomplete.</source>
          <target state="translated">承担使用VMS命令构建一套新的Perl镜像。由于 VMS 是动态加载的,所以没有必要将每个扩展都静态地链接到 Perl 映像中,所以这不是正常的构建路径。因此,它还没有经过真正的测试,很可能是不完整的。</target>
        </trans-unit>
        <trans-unit id="6b54be85a5a464cb36e53bbd5948681e9238101f" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV, where fakery means &quot;more than&quot; a string: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an &lt;code&gt;xpvmg&lt;/code&gt;; if we're a copy-on-write scalar, this is the on-write time when we do the copy, and is also used locally; if this is a vstring, drop the vstring magic. If &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; is set then a copy-on-write scalar drops its PV buffer (if any) and becomes &lt;code&gt;SvPOK_off&lt;/code&gt; rather than making a copy. (Used where this scalar is about to be set to some other value.) In addition, the &lt;code&gt;flags&lt;/code&gt; parameter gets passed to &lt;code&gt;sv_unref_flags()&lt;/code&gt; when unreffing. &lt;code&gt;sv_force_normal&lt;/code&gt; calls this function with flags set to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58380a9a71bcafd994016d7b4cb1383592a7215e" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV, where fakery means &quot;more than&quot; a string: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an xpvmg; if we're a copy-on-write scalar, this is the on-write time when we do the copy, and is also used locally; if this is a vstring, drop the vstring magic. If &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; is set then a copy-on-write scalar drops its PV buffer (if any) and becomes SvPOK_off rather than making a copy. (Used where this scalar is about to be set to some other value.) In addition, the &lt;code&gt;flags&lt;/code&gt; parameter gets passed to &lt;code&gt;sv_unref_flags()&lt;/code&gt; when unreffing. &lt;code&gt;sv_force_normal&lt;/code&gt; calls this function with flags set to 0.</source>
          <target state="translated">在SV上撤消各种类型的伪造，其中伪造意味着&amp;ldquo;多于&amp;rdquo;一个字符串：如果PV是共享字符串，则进行私人复制；如果我们是裁判，请停止引用；如果我们是全球人士，则降级为xpvmg；如果我们是写时复制标量，则这是我们执行复制时的写时时间，并且也在本地使用；如果这是vstring，请放下vstring魔术。如果设置了 &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; ,则写时复制标量会丢弃其PV缓冲区（如果有）并变为SvPOK_off，而不是进行复制。 （用于将标量设置为其他值的地方。）此外，取消设置时， &lt;code&gt;flags&lt;/code&gt; 参数将传递给 &lt;code&gt;sv_unref_flags()&lt;/code&gt; 。 &lt;code&gt;sv_force_normal&lt;/code&gt; 将标志设置为0调用此函数。</target>
        </trans-unit>
        <trans-unit id="6f1a942ff8c67eb2d1fc5bf7179e4670a0cecd7d" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an &lt;code&gt;xpvmg&lt;/code&gt;. See also &lt;code&gt;&lt;a href=&quot;#sv_force_normal_flags&quot;&gt;&quot;sv_force_normal_flags&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0043167da52b5a8f43ef5ef3ae847c1d205a64" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an xpvmg. See also &lt;code&gt;sv_force_normal_flags&lt;/code&gt; .</source>
          <target state="translated">撤消SV上的各种伪造：如果PV是共享字符串，则进行私人复制；如果我们是裁判，请停止引用；如果我们是全球人士，请降级为xpvmg。另请参见 &lt;code&gt;sv_force_normal_flags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9b219af612756cb93e821fb5ae6c25750a8208b" translate="yes" xml:space="preserve">
          <source>Undocumented functions</source>
          <target state="translated">未记录的功能</target>
        </trans-unit>
        <trans-unit id="e41716465542db7b5229d785ccf7cc674a9a2021" translate="yes" xml:space="preserve">
          <source>Unescaped left brace in regex is illegal here in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6360e841155690a571fd019b59b2e90901cd664e" translate="yes" xml:space="preserve">
          <source>Unescaped left brace in regex is passed through in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd43bbecc54b5a0f3d5534ed1867230c22e3ca4" translate="yes" xml:space="preserve">
          <source>Unescaped left braces in regular expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb80f3878ea015392dd87b05584ccec54611d89" translate="yes" xml:space="preserve">
          <source>Unescaped left braces in regular expressions (for 5.30)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9669238bade25c40c06b3f549ae09d7384574818" translate="yes" xml:space="preserve">
          <source>Unescaped literal '%c' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22086bbd02aed990980d36b0db035a998bc6e3e0" translate="yes" xml:space="preserve">
          <source>Unexpected '(' with no preceding operator in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8ad8043f2dbcf1dd017dcdb5209cbf492290eda" translate="yes" xml:space="preserve">
          <source>Unexpected ')' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3baa204dcc0f34d9c04dd0cdbe5cd8bc491de0f" translate="yes" xml:space="preserve">
          <source>Unexpected ']' with no following ')' in (?[... in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ceff2d23f8886ee7189841ccdf57932b12e7de9" translate="yes" xml:space="preserve">
          <source>Unexpected binary operator '%c' with no preceding operand in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6fd6877eeb4ca65b2ae370712af39b9caed0a2a" translate="yes" xml:space="preserve">
          <source>Unexpected character in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93bb4877e7bb13d05b3e08f4eae8e3dad1e4b888" translate="yes" xml:space="preserve">
          <source>Unexpected constant lvalue entersub entry via type/targ %d:%d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d819fa6d0f62b6341c9587511dec4703500307" translate="yes" xml:space="preserve">
          <source>Unexpected exit %u</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dbae700354867d121187e2a50e0cc20e0e1e77b" translate="yes" xml:space="preserve">
          <source>Unexpected exit failure %d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed18284023acb946f22279a557b952faac276d4" translate="yes" xml:space="preserve">
          <source>Unfinished Tales</source>
          <target state="translated">未完成的故事</target>
        </trans-unit>
        <trans-unit id="4df58040d6486eaa853729500be20c8509618322" translate="yes" xml:space="preserve">
          <source>Unfortunately it is not that difficult somehow manage to break one's Mac OS X Perl rather severely. If all else fails and you want to really, &lt;b&gt;REALLY&lt;/b&gt;, start from scratch and remove even your Apple Perl installation (which has become corrupted somehow), the following instructions should do it. &lt;b&gt;Please think twice before following these instructions: they are much like conducting brain surgery to yourself. Without anesthesia.&lt;/b&gt; We will &lt;b&gt;not&lt;/b&gt; come to fix your system if you do this.</source>
          <target state="translated">不幸的是，设法严重破坏Mac OS X Perl并不困难。如果一切都失败了，你要真的，&lt;b&gt;真的&lt;/b&gt;，从头开始，并清除即使您的Apple Perl安装（其中已损坏以某种方式），按以下说明应该这样做。&lt;b&gt;在遵循这些说明之前，请三思：它们非常像对自己进行脑部手术。无需麻醉。&lt;/b&gt;如果您这样做，我们将&lt;b&gt;不会&lt;/b&gt;修复您的系统。</target>
        </trans-unit>
        <trans-unit id="378b677974afb6ec2935fe271f0a9219fbb154a8" translate="yes" xml:space="preserve">
          <source>Unfortunately this field is basically meaningless, since many distributions are hybrids of several kinds of things, or some new thing, or subjectively different in focus depending on who's using them. Tools like Module::Build and MakeMaker will likely stop generating this field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f5b94a3a1a43fcb76168bb8fa3d4bd048c2c1e" translate="yes" xml:space="preserve">
          <source>Unfortunately this is sometimes not enough, neither colour nor quotes will help you with problems involving tabs, other non-printing characters and certain kinds of problems inherent in Unicode. To deal with this, you can switch Test::Tester into a mode whereby all &quot;tricky&quot; characters are shown as \{xx}. Tricky characters are those with ASCII code less than 33 or higher than 126. This makes the output more difficult to read but much easier to find subtle differences between strings. To turn on this mode either call &lt;code&gt;show_space()&lt;/code&gt; in your test script or set the &lt;code&gt;TESTTESTERSPACE&lt;/code&gt; environment variable to be a true value. The example above would then look like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29de2b4590451aa9259989dd73cca2f011560c79" translate="yes" xml:space="preserve">
          <source>Unfortunately, I can't differentiate any further.</source>
          <target state="translated">可惜的是,我无法再区分了。</target>
        </trans-unit>
        <trans-unit id="6e14820d498a0bc4a9f36bbc1285250e475a8eba" translate="yes" xml:space="preserve">
          <source>Unfortunately, a note cannot be used with the single argument style of &lt;code&gt;ok()&lt;/code&gt; . That is, if you try &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt;, then &lt;code&gt;Test&lt;/code&gt; will interpret this as &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt;, and probably end up testing &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; -- and that's not what you want!</source>
          <target state="translated">不幸的是，注释不能与 &lt;code&gt;ok()&lt;/code&gt; 的单个参数样式一起使用。也就是说，如果您尝试 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt; ，那么 &lt;code&gt;Test&lt;/code&gt; 会将其解释为 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; ，并且最终可能会测试 &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; －那不是您想要的！</target>
        </trans-unit>
        <trans-unit id="ef3c1b19c392ac342a5e6bd955e45b0b563788d1" translate="yes" xml:space="preserve">
          <source>Unfortunately, a note cannot be used with the single argument style of &lt;code&gt;ok()&lt;/code&gt;. That is, if you try &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt;, then &lt;code&gt;Test&lt;/code&gt; will interpret this as &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt;, and probably end up testing &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; -- and that's not what you want!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed74c92d4298d9e7fcce728b69ed6f5c8ab08c5" translate="yes" xml:space="preserve">
          <source>Unfortunately, for backwards compatibility reasons, an empty &lt;code&gt;\x&lt;/code&gt; is legal outside &lt;code&gt;use re 'strict'&lt;/code&gt; and expands to a NUL character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f4f5938609da571758adb22fa6ce02f230693d9" translate="yes" xml:space="preserve">
          <source>Unfortunately, interpretation of colors 0 through 7 often depends on whether the emulator supports eight colors or sixteen colors. Emulators that only support eight colors (such as the Linux console) will display colors 0 through 7 with normal brightness and ignore colors 8 through 15, treating them the same as white. Emulators that support 16 colors, such as gnome-terminal, normally display colors 0 through 7 as dim or darker versions and colors 8 through 15 as normal brightness. On such emulators, the &quot;normal&quot; white (color 7) usually is shown as pale grey, requiring bright white (15) to be used to get a real white color. Bright black usually is a dark grey color, although some terminals display it as pure black. Some sixteen-color terminal emulators also treat normal yellow (color 3) as orange or brown, and bright yellow (color 11) as yellow.</source>
          <target state="translated">不幸的是,0到7的颜色的解释通常取决于仿真器是支持8种颜色还是16种颜色。只支持8种颜色的模拟器(如Linux控制台)会以正常的亮度显示0到7号颜色,而忽略8到15号颜色,把它们当作白色对待。支持16种颜色的模拟器,如gnome-terminal,通常会将颜色0到7显示为暗色或较暗的版本,将颜色8到15显示为正常亮度。在这样的仿真器上,&quot;正常 &quot;的白色(颜色7)通常显示为淡灰色,需要使用亮白色(15)才能得到真正的白色。亮黑色通常是一种深灰色,尽管有些终端显示为纯黑色。一些十六色终端仿真器还将正常的黄色(颜色3)处理为橙色或棕色,将亮黄色(颜色11)处理为黄色。</target>
        </trans-unit>
        <trans-unit id="d3f96232328f4faede427c8ce3041998253135ab" translate="yes" xml:space="preserve">
          <source>Unfortunately, it may be that encodings are not &lt;code&gt;PerlIO&lt;/code&gt; -savvy. You can check to see whether your encoding is supported by &lt;code&gt;PerlIO&lt;/code&gt; by invoking the &lt;code&gt;perlio_ok&lt;/code&gt; method on it:</source>
          <target state="translated">不幸的是，可能是编码不 &lt;code&gt;PerlIO&lt;/code&gt; PerlIO。您可以通过在其上调用 &lt;code&gt;perlio_ok&lt;/code&gt; 方法来检查 &lt;code&gt;PerlIO&lt;/code&gt; 是否支持您的编码：</target>
        </trans-unit>
        <trans-unit id="7a881f618a75cd78f718468efd31960bdadb828c" translate="yes" xml:space="preserve">
          <source>Unfortunately, it may be that encodings are not &lt;code&gt;PerlIO&lt;/code&gt;-savvy. You can check to see whether your encoding is supported by &lt;code&gt;PerlIO&lt;/code&gt; by invoking the &lt;code&gt;perlio_ok&lt;/code&gt; method on it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa870b38ba970158ffd4da6159a903c51d8f85af" translate="yes" xml:space="preserve">
          <source>Unfortunately, the original specification of UTF-8 leaves some room for interpretation of how many bytes of encoded output one should generate from one input Unicode character. Strictly speaking, the shortest possible sequence of UTF-8 bytes should be generated, because otherwise there is potential for an input buffer overflow at the receiving end of a UTF-8 connection. Perl always generates the shortest length UTF-8, and with warnings on, Perl will warn about non-shortest length UTF-8 along with other malformations, such as the surrogates, which are not Unicode code points valid for interchange.</source>
          <target state="translated">遗憾的是,UTF-8的原始规范为从一个输入的Unicode字符中产生多少字节的编码输出留下了一些解释的空间。严格地说,应该生成尽可能短的UTF-8字节序列,因为否则在UTF-8连接的接收端有可能出现输入缓冲区溢出。Perl总是生成最短长度的UTF-8,在开启警告的情况下,Perl会对非最短长度的UTF-8以及其他畸形情况发出警告,比如代用码,这些代用码不是Unicode码点有效的互换。</target>
        </trans-unit>
        <trans-unit id="a23a8e59abb3029d4c1dd279e145008516f63183" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are quite a few deficiencies with the design (and often, the implementations) of locales. Unicode was invented (see &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for an introduction to that) in part to address these design deficiencies, and nowadays, there is a series of &quot;UTF-8 locales&quot;, based on Unicode. These are locales whose character set is Unicode, encoded in UTF-8. Starting in v5.20, Perl fully supports UTF-8 locales, except for sorting and string comparisons like &lt;code&gt;lt&lt;/code&gt; and &lt;code&gt;ge&lt;/code&gt;. Starting in v5.26, Perl can handle these reasonably as well, depending on the platform's implementation. However, for earlier releases or for better control, use &lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode::Collate&lt;/a&gt;. There are actually two slightly different types of UTF-8 locales: one for Turkic languages and one for everything else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1170c59a72df3e22ea0a090adf0e9824ff8c0b09" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are quite a few deficiencies with the design (and often, the implementations) of locales. Unicode was invented (see &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for an introduction to that) in part to address these design deficiencies, and nowadays, there is a series of &quot;UTF-8 locales&quot;, based on Unicode. These are locales whose character set is Unicode, encoded in UTF-8. Starting in v5.20, Perl fully supports UTF-8 locales, except for sorting and string comparisons. (Use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; for these.) Perl continues to support the old non UTF-8 locales as well. There are currently no UTF-8 locales for EBCDIC platforms.</source>
          <target state="translated">不幸的是，语言环境的设计（通常是实现）存在很多缺陷。发明Unicode是为了解决这些设计缺陷（部分介绍请参见&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;），如今，有一系列基于Unicode的&amp;ldquo; UTF-8语言环境&amp;rdquo;。这些是字符集为Unicode且以UTF-8编码的语言环境。从v5.20开始，Perl完全支持UTF-8语言环境，除了排序和字符串比较。 （为此，请使用&lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;。）Perl也继续支持旧的非UTF-8语言环境。 EBCDIC平台当前没有UTF-8语言环境。</target>
        </trans-unit>
        <trans-unit id="c8d518114a049f78aefe7090de8efc32eccefc83" translate="yes" xml:space="preserve">
          <source>Unfortunately, this isn't true. In perl 5.18 and earlier, AVs use &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a marker for indicating that an array element has not yet been initialized. Thus, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $av[0]&lt;/code&gt; would be true for the above Perl code, but false for the array generated by the XS code. In perl 5.20, storing &amp;amp;PL_sv_undef will create a read-only element, because the scalar &amp;amp;PL_sv_undef itself is stored, not a copy.</source>
          <target state="translated">不幸的是，事实并非如此。在perl 5.18及更早版本中，AV使用 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 作为标记来指示尚未初始化数组元素。因此， &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $av[0]&lt;/code&gt; 对于上面的Perl代码为true，但对于XS代码生成的数组为false。在perl 5.20中，存储＆PL_sv_undef将创建一个只读元素，因为标量＆PL_sv_undef本身是存储的，而不是副本。</target>
        </trans-unit>
        <trans-unit id="6aaca93722126b600c61100d9e3813a48d2917af" translate="yes" xml:space="preserve">
          <source>Unfortunately, this isn't true. In perl 5.18 and earlier, AVs use &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a marker for indicating that an array element has not yet been initialized. Thus, &lt;code&gt;exists $av[0]&lt;/code&gt; would be true for the above Perl code, but false for the array generated by the XS code. In perl 5.20, storing &amp;amp;PL_sv_undef will create a read-only element, because the scalar &amp;amp;PL_sv_undef itself is stored, not a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4484d276f38b1e070d2bbc67b4f47022917572dc" translate="yes" xml:space="preserve">
          <source>Unfortunately, this scheme does not work well with escape-based encodings such as ISO-2022-JP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9b09da1b70d953819b14bad175ad6e8c81c049" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this &lt;code&gt;style&lt;/code&gt; variable is used to set defaults for all three directory hierarchies (core, vendor, and site), there is no guarantee that the same style is actually appropriate for all those directories. For example, $prefix might be</source>
          <target state="translated">不幸的是，尽管此 &lt;code&gt;style&lt;/code&gt; 变量用于为所有三个目录层次结构（核心，供应商和站点）设置默认值，但不能保证实际上相同的样式适用于所有这些目录。例如，$ prefix可能是</target>
        </trans-unit>
        <trans-unit id="87c5d4faa14910842f5557a05819e468661f127e" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this is true, it's still broken. All the references in @AoA refer to the</source>
          <target state="translated">不幸的是,虽然这是事实,但还是破绽百出。在@AoA中的所有引用都指的是</target>
        </trans-unit>
        <trans-unit id="b3033d12e8c5e48f79875dd4cf162f90c243f353" translate="yes" xml:space="preserve">
          <source>Unfortunately, you may encounter Perl modules that are not</source>
          <target state="translated">遗憾的是,你可能会遇到一些不属于</target>
        </trans-unit>
        <trans-unit id="76435dad798e21eb71def4f2d3a46ed9708e4adf" translate="yes" xml:space="preserve">
          <source>Unget a line of text from the server.</source>
          <target state="translated">从服务器上获取一行文字。</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="eb802e96fd38e5e550d19f898a4fa941c45d6b21" translate="yes" xml:space="preserve">
          <source>Unicode 7.0 changed the wording so that they are &quot;&lt;b&gt;not recommended&lt;/b&gt; for use in open interchange of Unicode text data&quot;. The 7.0 Standard goes on to say:</source>
          <target state="translated">Unicode 7.0更改了措辞，因此&amp;ldquo; &lt;b&gt;不建议&lt;/b&gt;在开放式Unicode文本数据交换中使用它们&amp;rdquo;。 7.0标准继续说：</target>
        </trans-unit>
        <trans-unit id="8306b01ff9c220d1ce9274f85cf12d457904d299" translate="yes" xml:space="preserve">
          <source>Unicode Character Properties</source>
          <target state="translated">统一码字符属性</target>
        </trans-unit>
        <trans-unit id="2a76af7c10ae9a7945dc677634ff7f287d2f0d66" translate="yes" xml:space="preserve">
          <source>Unicode Collation Algorithm</source>
          <target state="translated">统一码整理算法</target>
        </trans-unit>
        <trans-unit id="c80690d5b1494bcf7f26319a35f4cf6977eedc42" translate="yes" xml:space="preserve">
          <source>Unicode Collation Algorithm - UTS #10</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8a7bf1ba1b9e4c2b07e9ad90fbd26463e5d980" translate="yes" xml:space="preserve">
          <source>Unicode Consortium</source>
          <target state="translated">统一码联盟</target>
        </trans-unit>
        <trans-unit id="0eb610a39db0d61541e877f8f7d93f1d2cd4e414" translate="yes" xml:space="preserve">
          <source>Unicode Consortium &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56cce9c1325a6619b09abb29a03b2934dad13be" translate="yes" xml:space="preserve">
          <source>Unicode Encodings</source>
          <target state="translated">統一碼編碼</target>
        </trans-unit>
        <trans-unit id="20d826b4f354ace01634ff9215d461c1d2de2da2" translate="yes" xml:space="preserve">
          <source>Unicode FAQ</source>
          <target state="translated">统一码常见问题</target>
        </trans-unit>
        <trans-unit id="be2c3b070e201b30c780f442801bee53720d3f02" translate="yes" xml:space="preserve">
          <source>Unicode Glossary</source>
          <target state="translated">统一码词汇表</target>
        </trans-unit>
        <trans-unit id="c37be50216d5f3d38f1ea9b4becfe8758aaff3f3" translate="yes" xml:space="preserve">
          <source>Unicode I/O</source>
          <target state="translated">统一码I/O</target>
        </trans-unit>
        <trans-unit id="0b15b2a3ee7f250e6d79317da505977b8ac153a4" translate="yes" xml:space="preserve">
          <source>Unicode Locale Data Markup Language (LDML) - UTS #35</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f977034e8571e3a210188dcc1d8385457a8e9f6" translate="yes" xml:space="preserve">
          <source>Unicode Normalization Forms</source>
          <target state="translated">统一码规范化形式</target>
        </trans-unit>
        <trans-unit id="775e22294d31686679c1488c3a4e009b588fb93a" translate="yes" xml:space="preserve">
          <source>Unicode Normalization Forms - UAX #15</source>
          <target state="translated">统一码规范化表格-UAX #15</target>
        </trans-unit>
        <trans-unit id="41086ae1277eac703b49ed9c64da7c4e1e028776" translate="yes" xml:space="preserve">
          <source>Unicode Properties</source>
          <target state="translated">统一码属性</target>
        </trans-unit>
        <trans-unit id="ecfb52e522a545f9d54db78a273755a7cf69910d" translate="yes" xml:space="preserve">
          <source>Unicode Recommended Reading List</source>
          <target state="translated">统一码推荐阅读列表</target>
        </trans-unit>
        <trans-unit id="3dc43797a086d2e60b97e26ddbcd0e763ba2be44" translate="yes" xml:space="preserve">
          <source>Unicode Regular Expression Support Level</source>
          <target state="translated">统一码正则表达式支持级别</target>
        </trans-unit>
        <trans-unit id="47be4025952fbf3894ef86d325a9d331d9d77d10" translate="yes" xml:space="preserve">
          <source>Unicode Support</source>
          <target state="translated">支持Unicode</target>
        </trans-unit>
        <trans-unit id="5477f70b1eea785630b35cd84e386522cded5715" translate="yes" xml:space="preserve">
          <source>Unicode Transformation Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b3c1f4d1dbf76960cd965f0a9ee21a6e35c74bd" translate="yes" xml:space="preserve">
          <source>Unicode Useful Resources</source>
          <target state="translated">统一码实用资源</target>
        </trans-unit>
        <trans-unit id="0bd38e8f5dc5fab318029c6a0f6bf740c02237f9" translate="yes" xml:space="preserve">
          <source>Unicode aims to &lt;b&gt;UNI&lt;/b&gt;-fy the en-&lt;b&gt;CODE&lt;/b&gt;-ings of all the world's character sets into a single Standard. For quite a few of the various coding standards that existed when Unicode was first created, converting from each to Unicode essentially meant adding a constant to each code point in the original standard, and converting back meant just subtracting that same constant. For ASCII and ISO-8859-1, the constant is 0. For ISO-8859-5, (Cyrillic) the constant is 864; for Hebrew (ISO-8859-8), it's 1488; Thai (ISO-8859-11), 3424; and so forth. This made it easy to do the conversions, and facilitated the adoption of Unicode.</source>
          <target state="translated">Unicode的旨在&lt;b&gt;UNI&lt;/b&gt; -Fy的恩&lt;b&gt;CODE&lt;/b&gt;的世界上所有的字符集-ings成一个单一的标准。对于最初创建Unicode时存在的各种编码标准中的很多，从每种编码标准转换为Unicode本质上意味着在原始标准的每个代码点上添加一个常数，而转换回该常数则意味着减去该常数。对于ASCII和ISO-8859-1，常数为0。对于ISO-8859-5，（西里尔字母），常数为864；对于（Cyrillic）常数。希伯来语（ISO-8859-8）为1488；泰语（ISO-8859-11），3424；等等。这使得转换变得容易，并促进了Unicode的采用。</target>
        </trans-unit>
        <trans-unit id="292b5cfbcdb907b6b9b2852bab43a1e41959e1df" translate="yes" xml:space="preserve">
          <source>Unicode also defines various</source>
          <target state="translated">统一码还定义了各种</target>
        </trans-unit>
        <trans-unit id="bfb017bed191925e52b6029168924ebfe8c5d26c" translate="yes" xml:space="preserve">
          <source>Unicode and EBCDIC</source>
          <target state="translated">统一码和EBCDIC</target>
        </trans-unit>
        <trans-unit id="e27520c25eb75e7d79e8f990eeb1be4ae1df41df" translate="yes" xml:space="preserve">
          <source>Unicode and ISO/IEC 10646 are coordinated standards that unify almost all other modern character set standards, covering more than 80 writing systems and hundreds of languages, including all commercially-important modern languages. All characters in the largest Chinese, Japanese, and Korean dictionaries are also encoded. The standards will eventually cover almost all characters in more than 250 writing systems and thousands of languages. Unicode 1.0 was released in October 1991, and 6.0 in October 2010.</source>
          <target state="translated">統一碼和ISO/IEC 10646是協調的標準,統一了幾乎所有其他的現代字符集標準,涵蓋80多種文字系統和數百種語言,包括所有商業上重要的現代語言。最大的中文、日文和韩文字典中的所有字符也都被编码。该标准最终将覆盖250多种书写系统和数千种语言中的几乎所有字符。统一码1.0于1991年10月发布,6.0于2010年10月发布。</target>
        </trans-unit>
        <trans-unit id="35759c0ae04781f6ce2a8261ef308a0d62267332" translate="yes" xml:space="preserve">
          <source>Unicode and Localisation Support</source>
          <target state="translated">统一码和本地化支持</target>
        </trans-unit>
        <trans-unit id="c79347889e0d28fc8f7e3b48dc5c985da6b9c2b3" translate="yes" xml:space="preserve">
          <source>Unicode and Multilingual Support in HTML, Fonts, Web Browsers and Other Applications</source>
          <target state="translated">在HTML、字体、网络浏览器和其他应用程序中支持统一码和多语言。</target>
        </trans-unit>
        <trans-unit id="aa0a00bb85a8ade7272b8fa2d081ab3abd746b2c" translate="yes" xml:space="preserve">
          <source>Unicode and UTF</source>
          <target state="translated">Unicode和UTF</target>
        </trans-unit>
        <trans-unit id="8e9632880dc5b73eee711bbb8acae51558160af7" translate="yes" xml:space="preserve">
          <source>Unicode and UTF-8</source>
          <target state="translated">统一码和UTF-8</target>
        </trans-unit>
        <trans-unit id="814213da4f2b17caa9167081f902458536e3ac5c" translate="yes" xml:space="preserve">
          <source>Unicode casing is very different from ASCII casing.</source>
          <target state="translated">Unicode编码与ASCII编码有很大不同。</target>
        </trans-unit>
        <trans-unit id="3db087027c1f3fb2dafc91bf1aec8e28ed66555f" translate="yes" xml:space="preserve">
          <source>Unicode character database</source>
          <target state="translated">统一码字符数据库</target>
        </trans-unit>
        <trans-unit id="90ce74ac0f978040e744ea5f9ee3a9fc0fdd5b56" translate="yes" xml:space="preserve">
          <source>Unicode character properties that are NOT accepted by Perl</source>
          <target state="translated">不被Perl接受的Unicode字符属性</target>
        </trans-unit>
        <trans-unit id="131ad96e9210c062a5a91bbff68adb3c52f574b9" translate="yes" xml:space="preserve">
          <source>Unicode characters are assigned to</source>
          <target state="translated">Unicode字符被分配到</target>
        </trans-unit>
        <trans-unit id="9cd8bdcde375ab8cc6d64998c61f22e2b1db366b" translate="yes" xml:space="preserve">
          <source>Unicode characters have a Unicode name and numeric code point (ordinal) value. Use the &lt;code&gt;\N{}&lt;/code&gt; construct to specify a character by either of these values. Certain sequences of characters also have names.</source>
          <target state="translated">Unicode字符具有Unicode名称和数字代码点（常规）值。使用 &lt;code&gt;\N{}&lt;/code&gt; 构造通过这两个值之一指定字符。某些字符序列也具有名称。</target>
        </trans-unit>
        <trans-unit id="210080ef48f936087dda80492d9856fe5ec4b9bc" translate="yes" xml:space="preserve">
          <source>Unicode classes</source>
          <target state="translated">统一码类</target>
        </trans-unit>
        <trans-unit id="0f01459324a40b9e6a3a0e387cbfebfba5b6c62c" translate="yes" xml:space="preserve">
          <source>Unicode code points versus EBCDIC code points</source>
          <target state="translated">统一码码点与EBCDIC码点的比较</target>
        </trans-unit>
        <trans-unit id="7625e9ef1dd87171eb4d5354c03dd9be33744a1d" translate="yes" xml:space="preserve">
          <source>Unicode codepoint</source>
          <target state="translated">统一编码码点</target>
        </trans-unit>
        <trans-unit id="329b02599470f15ed9e34472928160323f9fb081" translate="yes" xml:space="preserve">
          <source>Unicode coding schemes other than native utf8 are supported by Encode::Unicode, which will be autoloaded on demand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="106885fd8f00b6d1d3909f50579c6a1e81f50c34" translate="yes" xml:space="preserve">
          <source>Unicode concept which most often is equal to uppercase, but for certain characters like the German &quot;sharp s&quot; there is a difference.</source>
          <target state="translated">Unicode的概念,大多数情况下等于大写,但对于某些字符,如德语的 &quot;sharp s &quot;是有区别的。</target>
        </trans-unit>
        <trans-unit id="be2f011fe43db39f9182b02fbc6580c3cfe62024" translate="yes" xml:space="preserve">
          <source>Unicode considers many code points to be illegal, or to be avoided. Perl generally accepts them, once they have passed through any input filters that may try to exclude them. These have been discussed above (see &quot;Surrogates&quot; under UTF-16 in &lt;a href=&quot;#Unicode-Encodings&quot;&gt;&quot;Unicode Encodings&quot;&lt;/a&gt;, &lt;a href=&quot;#Noncharacter-code-points&quot;&gt;&quot;Noncharacter code points&quot;&lt;/a&gt;, and &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;&quot;Beyond Unicode code points&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49075f8dbc705f2f67ea7272b64074e286787f2" translate="yes" xml:space="preserve">
          <source>Unicode defines a fourth boundary type, accessible through the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt; module.</source>
          <target state="translated">Unicode定义了第四个边界类型，可通过&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::LineBreak&quot;&gt;Unicode :: LineBreak&lt;/a&gt;模块访问。</target>
        </trans-unit>
        <trans-unit id="07aa50c4f0010de0db76a15f32c4e153b24a7275" translate="yes" xml:space="preserve">
          <source>Unicode defines all its properties in the compound form, so all single-form properties are Perl extensions. Most of these are just synonyms for the Unicode ones, but some are genuine extensions, including several that are in the compound form. And quite a few of these are actually recommended by Unicode (in &lt;a href=&quot;http://www.unicode.org/reports/tr18&quot;&gt;http://www.unicode.org/reports/tr18&lt;/a&gt;).</source>
          <target state="translated">Unicode以复合形式定义其所有属性，因此所有单形式属性都是Perl扩展。其中大多数只是Unicode的同义词，但有些是真正的扩展，包括一些复合形式。Unicode实际上推荐了其中的很多（在&lt;a href=&quot;http://www.unicode.org/reports/tr18&quot;&gt;http://www.unicode.org/reports/tr18中&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="83740583eabf50f236d63ef1d8d25274281fb0cf" translate="yes" xml:space="preserve">
          <source>Unicode defines all its properties in the compound form, so all single-form properties are Perl extensions. Most of these are just synonyms for the Unicode ones, but some are genuine extensions, including several that are in the compound form. And quite a few of these are actually recommended by Unicode (in &lt;a href=&quot;https://www.unicode.org/reports/tr18&quot;&gt;https://www.unicode.org/reports/tr18&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8557c4367cf0c9f30d95a470ee521928d669fb7c" translate="yes" xml:space="preserve">
          <source>Unicode defines characters like &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; or &lt;code&gt;GREEK
SMALL LETTER ALPHA&lt;/code&gt; and unique numbers for the characters, in this case 0x0041 and 0x03B1, respectively. These unique numbers are called</source>
          <target state="translated">Unicode定义类似的字符 &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; 或 &lt;code&gt;GREEK SMALL LETTER ALPHA&lt;/code&gt; 分别和唯一号码中的字符，在这种情况下0x0041和0x03B1。这些唯一的号码称为</target>
        </trans-unit>
        <trans-unit id="acaff2c7ef0e4ff533eb55c7b82bb8cb537cf6b5" translate="yes" xml:space="preserve">
          <source>Unicode does define several other decimal--and numeric--characters besides the familiar 0 to 9, such as the Arabic and Indic digits. Perl does not support string-to-number conversion for digits other than ASCII &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt; (and ASCII &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt; for hexadecimal). To get safe conversions from any Unicode string, use &lt;a href=&quot;Unicode::UCD#num%28%29&quot;&gt;&quot;num()&quot; in Unicode::UCD&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66287c5bc6e75d359bae32c20cfc35103e105bf3" translate="yes" xml:space="preserve">
          <source>Unicode does define several other decimal--and numeric--characters besides the familiar 0 to 9, such as the Arabic and Indic digits. Perl does not support string-to-number conversion for digits other than ASCII &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt; (and ASCII &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt; for hexadecimal). To get safe conversions from any Unicode string, use &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Unicode确实定义了除了熟悉的0到9之外的其他十进制和数字字符，例如阿拉伯数字和印度数字。Perl不支持ASCII &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;9&lt;/code&gt; （十六进制的ASCII &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;f&lt;/code&gt; ）以外的数字到字符串到数字的转换。要从任何Unicode字符串获得安全的转换，请&lt;a href=&quot;unicode/ucd#num()&quot;&gt;在Unicode :: UCD中&lt;/a&gt;使用num（）。</target>
        </trans-unit>
        <trans-unit id="e0b4309884526bd11fe1ab30cc9fc6ed43648809" translate="yes" xml:space="preserve">
          <source>Unicode form that is useful when comparing strings regardless of case, as certain characters have complex one-to-many case mappings. Primarily a variant of lowercase.</source>
          <target state="translated">Unicode形式,在比较字符串的大小写时非常有用,因为某些字符具有复杂的一对多大小写映射。主要是小写字母的变体。</target>
        </trans-unit>
        <trans-unit id="71079ed61722f43474765527d68998144c7665d4" translate="yes" xml:space="preserve">
          <source>Unicode furnishes the &lt;code&gt;Age&lt;/code&gt; property from which this is derived. The problem with Age is that a strict interpretation of it (which Perl takes) has it matching the precise release a code point's meaning is introduced in. Thus &lt;code&gt;U+0041&lt;/code&gt; would match only 1.1; and &lt;code&gt;U+1EFF&lt;/code&gt; only 5.1. This is not usually what you want.</source>
          <target state="translated">Unicode提供了 &lt;code&gt;Age&lt;/code&gt; 属性（从中派生该属性）。 Age的问题在于对它（Perl采取的一种严格的解释）使其与引入了代码点含义的精确版本相匹配。因此， &lt;code&gt;U+0041&lt;/code&gt; 仅匹配1.1；因此，A + 0041仅匹配1.1。和 &lt;code&gt;U+1EFF&lt;/code&gt; 仅5.1。这通常不是您想要的。</target>
        </trans-unit>
        <trans-unit id="fd3ab6b6f70f7431b1416e0f9107c1af48c38649" translate="yes" xml:space="preserve">
          <source>Unicode has some property-value pairs that currently don't match anything. This happens generally either because they are obsolete, or they exist for symmetry with other forms, but no language has yet been encoded that uses them. In this version of Unicode, the following match zero code points:</source>
          <target state="translated">Unicode有一些属性值对目前没有任何匹配。出现这种情况一般是因为它们已经过时了,或者它们的存在是为了与其他形式对称,但还没有任何语言使用它们的编码。在这个版本的Unicode中,以下是匹配零码点的。</target>
        </trans-unit>
        <trans-unit id="598e8ae9c96e08e40d6e1a738b55c351268bc51b" translate="yes" xml:space="preserve">
          <source>Unicode has three pseudo scripts that are handled specially.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c49c9d36b230f185c7169c7475e8856ddbd520" translate="yes" xml:space="preserve">
          <source>Unicode in Perl on EBCDIC</source>
          <target state="translated">在Perl中使用EBCDIC的Unicode</target>
        </trans-unit>
        <trans-unit id="5a2ff10d38459692f18fa8f0d5e12e0027770ead" translate="yes" xml:space="preserve">
          <source>Unicode is a character set standard which plans to codify all of the writing systems of the world, plus many other symbols.</source>
          <target state="translated">Unicode是一个字符集标准,它计划将世界上所有的书写系统,加上许多其他符号进行编码。</target>
        </trans-unit>
        <trans-unit id="3bb1c5615f2383d427b4613073ef1ec435b5138c" translate="yes" xml:space="preserve">
          <source>Unicode is a character set that can represent most characters in most of the world's languages, providing room for over one million different characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin characters are assigned to the numbers 0 - 127. The Latin-1 Supplement with characters that are used in several European languages is in the next range, up to 255. After some more Latin extensions we find the character sets from languages using non-Roman alphabets, interspersed with a variety of symbol sets such as currency symbols, Zapf Dingbats or Braille. (You might want to visit &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for a look at some of them - my personal favourites are Telugu and Kannada.)</source>
          <target state="translated">Unicode是一个字符集，可以代表世界上大多数语言的大多数字符，为超过一百万个不同的字符提供了空间。 Unicode 3.1指定94,140个字符：基本拉丁字符分配给数字0-127。具有多种欧洲语言使用的字符的Latin-1补码在下一个范围内，最多为255。在发现更多拉丁扩展之后，我们发现使用非罗马字母的语言中的字符集，并点缀各种符号集，例如货币符号，Zapf Dingbats或盲文。 （您可能想访问&lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt;来查看其中的一些-我个人的最爱是泰卢固语和卡纳达语。）</target>
        </trans-unit>
        <trans-unit id="918d612f1c2574dce41b14dc2be8c0387758201b" translate="yes" xml:space="preserve">
          <source>Unicode is a character set that can represent most characters in most of the world's languages, providing room for over one million different characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin characters are assigned to the numbers 0 - 127. The Latin-1 Supplement with characters that are used in several European languages is in the next range, up to 255. After some more Latin extensions we find the character sets from languages using non-Roman alphabets, interspersed with a variety of symbol sets such as currency symbols, Zapf Dingbats or Braille. (You might want to visit &lt;a href=&quot;https://www.unicode.org/&quot;&gt;https://www.unicode.org/&lt;/a&gt; for a look at some of them - my personal favourites are Telugu and Kannada.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4b52a0e0d40f8cd4680e731fa8661db40b7bfb" translate="yes" xml:space="preserve">
          <source>Unicode is a comprehensive standard. It specifies many things outside the scope of Perl, such as how to display sequences of characters. For a full discussion of all aspects of Unicode, see &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;.</source>
          <target state="translated">Unicode是一个全面的标准。它指定了Perl范围之外的许多内容，例如如何显示字符序列。有关Unicode所有方面的完整讨论，请参见&lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0004a5b6be77b386fdac7a26a14cd8154c46e916" translate="yes" xml:space="preserve">
          <source>Unicode is a comprehensive standard. It specifies many things outside the scope of Perl, such as how to display sequences of characters. For a full discussion of all aspects of Unicode, see &lt;a href=&quot;https://www.unicode.org&quot;&gt;https://www.unicode.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b43e74b6aa7b2acf2d7d34cb97f083e42a3eb18" translate="yes" xml:space="preserve">
          <source>Unicode is a new and complex technology and one may easily overlook certain security pitfalls. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; for an overview and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details, and &lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;&quot;Security Implications of Unicode&quot; in perlunicode&lt;/a&gt; for security implications in particular.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d8bac67762b71e3e301bd389dd5bf647e3a7f7" translate="yes" xml:space="preserve">
          <source>Unicode is a new and complex technology and one may easily overlook certain security pitfalls. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; for an overview and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details, and &lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;Security Implications of Unicode in perlunicode&lt;/a&gt; for security implications in particular.</source>
          <target state="translated">Unicode是一种新的复杂技术，可以轻易忽略某些安全隐患。见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;的概述和&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;的细节，并&lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;在perlunicode统一的安全隐患&lt;/a&gt;特别是对于安全隐患。</target>
        </trans-unit>
        <trans-unit id="2819bd58737a8580070f8ba307d9387529fe1cef" translate="yes" xml:space="preserve">
          <source>Unicode is encoded using several competing encodings, of which UTF-8 is the most used. In a Unicode encoding, multiple subsequent bytes can be used to store a single code point, or simply: character.</source>
          <target state="translated">Unicode使用几种相互竞争的编码,其中UTF-8是使用最多的编码。在Unicode编码中,可以用多个后续字节来存储一个码点,或者干脆说:字符。</target>
        </trans-unit>
        <trans-unit id="eebcf5b59ea874094c8b9d89a4f67a602ded5273" translate="yes" xml:space="preserve">
          <source>Unicode is stored in &lt;code&gt;$oswBuffer&lt;/code&gt;. &lt;code&gt;$lwBufSize&lt;/code&gt; and &lt;code&gt;$olwOutLength&lt;/code&gt; are measured as number of &lt;code&gt;WCHAR&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a66fde7942a6271294a3a5979cbe3017c3d5acd" translate="yes" xml:space="preserve">
          <source>Unicode is supported on EBCDIC platforms. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;.</source>
          <target state="translated">EBCDIC平台支持Unicode。参见&lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9649076a02c41263127b2e79657012b62bed018f" translate="yes" xml:space="preserve">
          <source>Unicode non-character U+%X is not recommended for open interchange</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4276af257ec826541933ef5d517bc7bb403fdca7" translate="yes" xml:space="preserve">
          <source>Unicode only allows code points up to 0x10FFFF, but Perl allows much larger ones. Up till Perl 5.28, it was allowed to use code points exceeding the maximum value of an integer (&lt;code&gt;IV_MAX&lt;/code&gt;). However, that did break the perl interpreter in some constructs, including causing it to hang in a few cases. The known problem areas were in &lt;code&gt;tr///&lt;/code&gt;, regular expression pattern matching using quantifiers, as quote delimiters in &lt;code&gt;q&lt;i&gt;X&lt;/i&gt;...&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; (where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="989d0062ad097f9dec3fa95782856724eb6165aa" translate="yes" xml:space="preserve">
          <source>Unicode promises that the set of code points that have these two properties will never change, so something that is not quoted in v5.16 will never need to be quoted in any future Perl release. (Not all the code points that match Pattern_Syntax have actually had characters assigned to them; so there is room to grow, but they are quoted whether assigned or not. Perl, of course, would never use an unassigned code point as an actual metacharacter.)</source>
          <target state="translated">Unicode 承诺,具有这两个属性的代码点集永远不会改变,所以在 v5.16 中没有被引用的东西在未来的任何 Perl 版本中都不需要被引用。(并不是所有与 Pattern_Syntax 匹配的代码点实际上都已经被分配了字符;所以还有增长的空间,但无论是否被分配,它们都会被引用。当然,Perl永远不会将一个未分配的代码点作为一个实际的元字符使用)。)</target>
        </trans-unit>
        <trans-unit id="fb2ca4e28ea7e22cfa06c89ba6c3b93dca994a19" translate="yes" xml:space="preserve">
          <source>Unicode properties are defined (surprise!) only on Unicode code points. Starting in v5.20, when matching against &lt;code&gt;\p&lt;/code&gt; and &lt;code&gt;\P&lt;/code&gt; , Perl treats non-Unicode code points (those above the legal Unicode maximum of 0x10FFFF) as if they were typical unassigned Unicode code points.</source>
          <target state="translated">Unicode属性仅在Unicode代码点上定义（惊奇！）。从v5.20开始，当与 &lt;code&gt;\p&lt;/code&gt; 和 &lt;code&gt;\P&lt;/code&gt; 匹配时，Perl会将非Unicode代码点（高于合法Unicode最大值0x10FFFF的代码点）视为典型的未分配Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="a1b191780dd618f1a1adb03d6a73e2206a215bac" translate="yes" xml:space="preserve">
          <source>Unicode properties are defined (surprise!) only on Unicode code points. Starting in v5.20, when matching against &lt;code&gt;\p&lt;/code&gt; and &lt;code&gt;\P&lt;/code&gt;, Perl treats non-Unicode code points (those above the legal Unicode maximum of 0x10FFFF) as if they were typical unassigned Unicode code points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4421ab9f1aa61dc9cbda1e9f59175c1a3635d1e0" translate="yes" xml:space="preserve">
          <source>Unicode property wildcard not terminated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="139a9bb1fddefbaa23b5411336f2d45c5af1add3" translate="yes" xml:space="preserve">
          <source>Unicode publishes the names of blocks in two different styles, though the two are equivalent under Unicode's loose matching rules.</source>
          <target state="translated">Unicode以两种不同的风格发布区块的名称,不过在Unicode宽松的匹配规则下,两者是等价的。</target>
        </trans-unit>
        <trans-unit id="38ecc57a7a45e8fa0530ba908225186656979efa" translate="yes" xml:space="preserve">
          <source>Unicode rules are used for the case change.</source>
          <target state="translated">箱体变化采用Unicode规则。</target>
        </trans-unit>
        <trans-unit id="1b41da839119c4860ed2bab536f19149822ad0f7" translate="yes" xml:space="preserve">
          <source>Unicode string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f63eb0aa495029030f8880e8159d4eda857dd8ed" translate="yes" xml:space="preserve">
          <source>Unicode string properties are not implemented in (?[...]) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7088ba3066aa65d6bcc96771fbb92a42fd96dcd6" translate="yes" xml:space="preserve">
          <source>Unicode support is an extensive requirement. While Perl does not implement the Unicode standard or the accompanying technical reports from cover to cover, Perl does support many Unicode features.</source>
          <target state="translated">支持Unicode是一项广泛的要求。虽然Perl没有从头到尾实施Unicode标准或附带的技术报告,但Perl确实支持许多Unicode功能。</target>
        </trans-unit>
        <trans-unit id="92c5fb67050f7cc6a07c62ea0f43698241d0a5b2" translate="yes" xml:space="preserve">
          <source>Unicode surrogate U+%X is illegal in UTF-8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8b243e5f3e426dd36737b42e29d2ec9970a7c1a" translate="yes" xml:space="preserve">
          <source>Unicode, of course, assigns each of those code points a particular meaning (along with ones above 255). To preserve backward compatibility, Perl only uses the Unicode meanings when there is some indication that Unicode is what is intended; otherwise the non-ASCII code points remain treated as if they are unassigned.</source>
          <target state="translated">当然,Unicode 会给这些代码点分配一个特定的含义(以及 255 以上的代码点)。为了保持向后的兼容性,Perl只在有某种迹象表明Unicode是其目的时才使用Unicode的含义;否则,非ASCII码点仍被当作未分配的码点处理。</target>
        </trans-unit>
        <trans-unit id="21276899f4cb4b0159879360c7526c4fe6c28316" translate="yes" xml:space="preserve">
          <source>Unicode/Collate</source>
          <target state="translated">Unicode/Collate</target>
        </trans-unit>
        <trans-unit id="37148638183749a1c0b03d85014634d4e43c64c4" translate="yes" xml:space="preserve">
          <source>Unicode/Collate/Foo.txt</source>
          <target state="translated">Unicode/Collate/Foo.txt</target>
        </trans-unit>
        <trans-unit id="f77e952a14d870cb3ae7b18f391e8c5f3d325575" translate="yes" xml:space="preserve">
          <source>Unicode::Collate</source>
          <target state="translated">Unicode::Collate</target>
        </trans-unit>
        <trans-unit id="3ff519c896603d01c9e76e4f19191f11d112327a" translate="yes" xml:space="preserve">
          <source>Unicode::Collate - Unicode Collation Algorithm</source>
          <target state="translated">Unicode::Collate-统一码整理算法</target>
        </trans-unit>
        <trans-unit id="fdf0d75274a879104b0f1f8bc64ee18ff02c5b30" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Big5</source>
          <target state="translated">Unicode::Collate::CJK::Big5</target>
        </trans-unit>
        <trans-unit id="1d6f6aa49ee6fad5eca6f35948b7e1bb0ab65190" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Big5 - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df783cdcff877161e1582e96c9fee058c8ac391" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::GB2312</source>
          <target state="translated">Unicode::Collate::CJK::GB2312</target>
        </trans-unit>
        <trans-unit id="69f6a1af4b9d7847bba5939a34148141b098e758" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::GB2312 - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a120ddf4b189ce790913ac61694171437406f3d" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::JISX0208</source>
          <target state="translated">Unicode::Collate::CJK::JISX0208</target>
        </trans-unit>
        <trans-unit id="52137c04544cacc73939ff1aee0c874c9d8fee08" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::JISX0208 - weighting JIS KANJI for Unicode::Collate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522cc80239808b956014178ec75f366b2cd491f0" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Korean</source>
          <target state="translated">Unicode::Collate::CJK::Korean</target>
        </trans-unit>
        <trans-unit id="0ac8b48e92e15bda76c4fcc728f48f96352b283f" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Korean - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c59af510fe79c64655e756d8461e5d375c2fd6" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Pinyin</source>
          <target state="translated">Unicode::Collate::CJK::Pinyin</target>
        </trans-unit>
        <trans-unit id="42747836215aeadf69f9c614290fca82880640f7" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Pinyin - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="119a4f4d104376889a668529add1217787695cd3" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Stroke</source>
          <target state="translated">Unicode::Collate::CJK::Stroke</target>
        </trans-unit>
        <trans-unit id="f4760535296459fcd8959501743735349df70437" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Stroke - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="935469afe79a7967133cbd5dc7a19cf8e8b7b28e" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Zhuyin</source>
          <target state="translated">Unicode::Collate::CJK::Zhuyin</target>
        </trans-unit>
        <trans-unit id="6bf20cf45b8ff713b3a40392be9d33f596934776" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::CJK::Zhuyin - weighting CJK Unified Ideographs for Unicode::Collate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a163e245e5c3cf99dc2f5ab882390d17947426d" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::Locale</source>
          <target state="translated">Unicode::Collate::Locale</target>
        </trans-unit>
        <trans-unit id="001480054455d7b56706418239469b08b55ae695" translate="yes" xml:space="preserve">
          <source>Unicode::Collate::Locale - Linguistic tailoring for DUCET via Unicode::Collate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b47eca97eb095d02921b6571fab1a6dfdb0bc0" translate="yes" xml:space="preserve">
          <source>Unicode::Normalize</source>
          <target state="translated">Unicode::Normalize</target>
        </trans-unit>
        <trans-unit id="2e61bd2963848230702b059b3f915c279424ceeb" translate="yes" xml:space="preserve">
          <source>Unicode::Normalize - Unicode Normalization Forms</source>
          <target state="translated">Unicode::normalize-Unicode规范化表格</target>
        </trans-unit>
        <trans-unit id="58e1ebb138145877210bc1aaddb6a695f639333f" translate="yes" xml:space="preserve">
          <source>Unicode::UCD</source>
          <target state="translated">Unicode::UCD</target>
        </trans-unit>
        <trans-unit id="878eb3fe5907f3dbbef3993a9d210c838c3bd0a6" translate="yes" xml:space="preserve">
          <source>Unicode::UCD - Unicode character database</source>
          <target state="translated">Unicode::UCD-Unicode字符数据库</target>
        </trans-unit>
        <trans-unit id="b0e10771734c32d2d9e8385457afb6c4bd746163" translate="yes" xml:space="preserve">
          <source>Unicode::UCD::UnicodeVersion</source>
          <target state="translated">Unicode::UCD::UnicodeVersion</target>
        </trans-unit>
        <trans-unit id="1147d047b52e119e77fa52566535f97fa00f2d54" translate="yes" xml:space="preserve">
          <source>Unified method to both set and get options in the &lt;code&gt;SOL_SOCKET&lt;/code&gt; level. If called with one argument then &lt;a href=&quot;IO::Socket#getsockopt&quot;&gt;&quot;getsockopt&quot; in IO::Socket&lt;/a&gt; is called, otherwise &lt;a href=&quot;IO::Socket#setsockopt&quot;&gt;&quot;setsockopt&quot; in IO::Socket&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c884d01b9429a9f7304a835d13687b8ca5872d3c" translate="yes" xml:space="preserve">
          <source>Unified method to both set and get options in the SOL_SOCKET level. If called with one argument then getsockopt is called, otherwise setsockopt is called.</source>
          <target state="translated">在SOL_SOCKET层中设置和获取选项的统一方法,如果调用一个参数,则调用getockopt,否则调用setockopt。如果用一个参数调用,则调用getockopt,否则调用setockopt。</target>
        </trans-unit>
        <trans-unit id="238642af65f3add9fa062158d9a8954a0d8cc5fc" translate="yes" xml:space="preserve">
          <source>Unimplemented, but you can use &lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; and the &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module to achieve similar things.</source>
          <target state="translated">未实现，但是您可以使用&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;和&lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt;模块来实现类似的功能。</target>
        </trans-unit>
        <trans-unit id="e6507a9fbb8009ec64673ec8cd6b7aa40be844fe" translate="yes" xml:space="preserve">
          <source>Unimplemented, but you can use &lt;a href=&quot;perlfunc#die&quot;&gt;&quot;die&quot; in perlfunc&lt;/a&gt; and the &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module to achieve similar things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afec59d2cbb0d42662480e51b0e7e50584f1e2e5" translate="yes" xml:space="preserve">
          <source>Unimplemented, except on Windows, due to the vagaries of vendor locale names, returning &lt;code&gt;&quot;&quot;&lt;/code&gt; on non-Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e456a7d2242bb697d1c62ca28710a65f1b354e3" translate="yes" xml:space="preserve">
          <source>Unimplemented, so returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9769121f10f77079b27eb08e9ffa488cbcc37ed0" translate="yes" xml:space="preserve">
          <source>United Kingdom</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768685ca582abd0af2fbb57ca37752aa98c9372b" translate="yes" xml:space="preserve">
          <source>United States</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6635fe323dcba6e8b8b2d5cdbb340361ce906ed" translate="yes" xml:space="preserve">
          <source>Universal Binary support</source>
          <target state="translated">支持通用二进制</target>
        </trans-unit>
        <trans-unit id="a1a652fb80ef2238fc4c5e10930af87b4f3aac30" translate="yes" xml:space="preserve">
          <source>Universal Character Set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="2fb49d2b5adcca8ced12a532099ac9adce5647b1" translate="yes" xml:space="preserve">
          <source>Unix Network Programming, 2nd Edition, Volume 1</source>
          <target state="translated">Unix网络编程第2版第1卷</target>
        </trans-unit>
        <trans-unit id="b4c5506923f63fcc0ec2a3603b475130b23382af" translate="yes" xml:space="preserve">
          <source>Unix Review</source>
          <target state="translated">Unix评论</target>
        </trans-unit>
        <trans-unit id="4b39a128140df62988dc25aafca006880dd71ad2" translate="yes" xml:space="preserve">
          <source>Unix has no need of special linker flags.</source>
          <target state="translated">Unix不需要特殊的链接器标志。</target>
        </trans-unit>
        <trans-unit id="4547b2fe2a8711e2250c90726e47d0a32f9e7c0b" translate="yes" xml:space="preserve">
          <source>Unix style shell macros like &lt;code&gt;$(abcd)&lt;/code&gt; are passed through instead of being converted to &lt;code&gt;$^(abcd^)&lt;/code&gt; independent of the &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; feature setting. Unix style shell macros should not use characters that are not in the ASCII character set, as the resulting specification may or may not be still in UTF8 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa3f11d873bf24fcae352a27226c0c2e88d087f" translate="yes" xml:space="preserve">
          <source>Unix's &lt;code&gt;#!&lt;/code&gt; technique can be simulated on other systems:</source>
          <target state="translated">Unix的 &lt;code&gt;#!&lt;/code&gt; 可以在其他系统上模拟该技术：</target>
        </trans-unit>
        <trans-unit id="7f87c004392cd89a556aff5f86328de12b9ca773" translate="yes" xml:space="preserve">
          <source>Unix-Domain TCP Clients and Servers</source>
          <target state="translated">Unix-Domain TCP客户端和服务器</target>
        </trans-unit>
        <trans-unit id="4acfa258fe45e38658aa00a5dfda8b8abeddb8cc" translate="yes" xml:space="preserve">
          <source>Unix-domain sockets on OS/2 live in a pseudo-file-system &lt;code&gt;/sockets/...&lt;/code&gt; . To avoid a failure to create a socket with a name of a different form, &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; is prepended to the socket name (unless it starts with this already).</source>
          <target state="translated">OS / 2上的Unix域套接字位于伪文件系统 &lt;code&gt;/sockets/...&lt;/code&gt; 中。为避免创建具有不同格式名称的套接字失败，请在套接字名称之前加上 &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; （除非它已经以此开头）。</target>
        </trans-unit>
        <trans-unit id="35779ed7c2718c03c2a679cc689368ba373e9248" translate="yes" xml:space="preserve">
          <source>Unix-domain sockets on OS/2 live in a pseudo-file-system &lt;code&gt;/sockets/...&lt;/code&gt;. To avoid a failure to create a socket with a name of a different form, &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; is prepended to the socket name (unless it starts with this already).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f3c45c8b86738464ace2f8005c8fbdecfe76366" translate="yes" xml:space="preserve">
          <source>Unix.U</source>
          <target state="translated">Unix.U</target>
        </trans-unit>
        <trans-unit id="bc7819b34ff87570745fbe461e36a16f80e562ce" translate="yes" xml:space="preserve">
          <source>Unknown</source>
          <target state="translated">Unknown</target>
        </trans-unit>
        <trans-unit id="a8b5e7a7d509a7c62d93ee2bad1c35496336638f" translate="yes" xml:space="preserve">
          <source>Unknown &quot;re&quot; subpragma '%s' (known ones are: %s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae6c175629d52f8caa8d90709840d842ec6a24a8" translate="yes" xml:space="preserve">
          <source>Unknown &amp;lt;unknown@example.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4260834064ed4da863200d4ab98727ee77cc0db4" translate="yes" xml:space="preserve">
          <source>Unknown '(*...)' construct '%s' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516d733c8bf9db439f1f86408315d55784a8e43c" translate="yes" xml:space="preserve">
          <source>Unknown '=xxxx' commands, unknown 'X&amp;lt;...&amp;gt;' interior-sequences, and unterminated interior sequences.</source>
          <target state="translated">未知的'= xxxx'命令，未知的'X &amp;lt;...&amp;gt;'内部序列和未终止的内部序列。</target>
        </trans-unit>
        <trans-unit id="0c7f616921e8aa6ce31483dac2c125041fa7ff10" translate="yes" xml:space="preserve">
          <source>Unknown E content in E&amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b452be528de2ca72fbdca17c8a6b9000bd72960e" translate="yes" xml:space="preserve">
          <source>Unknown PerlIO layer &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc9d502ba9bb87ff9a938ae6d50ef1785f93443" translate="yes" xml:space="preserve">
          <source>Unknown Unicode option letter '%c'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b383a6c76e59091add963d05eca879c2155929c3" translate="yes" xml:space="preserve">
          <source>Unknown Unicode option value %d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b64d99361c84dd2b785abb8dd250103d6a822f" translate="yes" xml:space="preserve">
          <source>Unknown charname '%s'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8c284e5307746cdeea5551e2520dce4836d73d" translate="yes" xml:space="preserve">
          <source>Unknown directive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5fd9aa24c9417e7332e6f25936ae2a6ec8f1524" translate="yes" xml:space="preserve">
          <source>Unknown error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebda19c79ae8fdc09d9f934173a9e0b1dda8ac2" translate="yes" xml:space="preserve">
          <source>Unknown locale category %d; can't set it to %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e9349b86ed14bdbc36e717e0e54a45178a5709" translate="yes" xml:space="preserve">
          <source>Unknown open() mode '%s'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9ce623a0a054e7c503d1bead726383200a08d0" translate="yes" xml:space="preserve">
          <source>Unknown option: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94063b188637c4358408514f0dec4be5138069da" translate="yes" xml:space="preserve">
          <source>Unknown process %x sent message to prime_env_iter: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a27728149a20fa874d8e5d6ec5784571e435f85" translate="yes" xml:space="preserve">
          <source>Unknown regexp modifier &quot;/%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c5c163aa1fa71615dee0d3c90ca77bf54723d6" translate="yes" xml:space="preserve">
          <source>Unknown result token.</source>
          <target state="translated">未知的结果令牌。</target>
        </trans-unit>
        <trans-unit id="5362b9dbff55eae528c95c41a9cdfba23a42b91e" translate="yes" xml:space="preserve">
          <source>Unknown switch condition (?(...)) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc278b1f69a68c5fa1706993032fe0bce8d046fa" translate="yes" xml:space="preserve">
          <source>Unknown verb pattern '%s' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa3d10b86eac319b820b63f583e0a0a896d21a3" translate="yes" xml:space="preserve">
          <source>Unknown warnings category '%s'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4013e411624fa8892f8200feafb69475d2458d0b" translate="yes" xml:space="preserve">
          <source>Unknowns are &lt;code&gt;&quot;-&quot;&lt;/code&gt; . Unknowns can happen unfortunately quite easily: if the platform doesn't support retrieving the information; if the binary is missing the debug information; if the optimizer has transformed the code by for example inlining.</source>
          <target state="translated">未知的是 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 。不幸的是，未知事件很容易发生：如果平台不支持检索信息；如果二进制文件缺少调试信息；如果优化程序通过内联等方式转换了代码。</target>
        </trans-unit>
        <trans-unit id="e246db88408875913f8b8fd552f45cc3814a8897" translate="yes" xml:space="preserve">
          <source>Unknowns are &lt;code&gt;&quot;-&quot;&lt;/code&gt;. Unknowns can happen unfortunately quite easily: if the platform doesn't support retrieving the information; if the binary is missing the debug information; if the optimizer has transformed the code by for example inlining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce906b20ea9a7a0bf0bcbae85c1c9421e3de60b2" translate="yes" xml:space="preserve">
          <source>Unless %hash has already been locked the key/value could be deleted regardless of this setting.</source>
          <target state="translated">除非%hash已经被锁定,否则不管这个设置如何,钥匙/值都可以被删除。</target>
        </trans-unit>
        <trans-unit id="5c6af5673dc4ae00136df64bec88a6550bf388e5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, the PerlIO layers of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; are set to &quot;&lt;code&gt;:encoding(&lt;i&gt;ENCNAME&lt;/i&gt;)&lt;/code&gt;&quot;. Therefore,</source>
          <target state="translated">除非 &lt;code&gt;${^UNICODE}&lt;/code&gt; （从v5.8.2开始可用）存在并且不为零，否则将 &lt;code&gt;STDIN&lt;/code&gt; 和 &lt;code&gt;STDOUT&lt;/code&gt; 的PerlIO层设置为&amp;ldquo; &lt;code&gt;:encoding(&lt;i&gt;ENCNAME&lt;/i&gt;)&lt;/code&gt; &amp;rdquo;。因此，</target>
        </trans-unit>
        <trans-unit id="d2c8c659e558ac6c6718a8a57a68dcfe5600f320" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; (&lt;code&gt;-Accflags=-DPERL_MEM_LOG_NOIMPL&lt;/code&gt;) is also compiled, the logging functions read $ENV{PERL_MEM_LOG} to determine whether to log the event, and if so how:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a238cf9ea26a0e7ddfda497c5bf0d771bd8656" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; is also compiled, the logging functions read $ENV{PERL_MEM_LOG} to determine whether to log the event, and if so how:</source>
          <target state="translated">除非还编译了 &lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; ，否则日志记录功能将读取$ ENV {PERL_MEM_LOG}以确定是否记录该事件，以及如何记录该事件：</target>
        </trans-unit>
        <trans-unit id="7183c27cf3fecde6bcc64c00a3a891d43f73c77b" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; is set to &lt;code&gt;T&lt;/code&gt; (and the kernel is after 2000/09/01), such DLLs are considered to be global. When loading a global DLL it is first looked in the table of already-loaded global DLLs. Because of this the fact that one executable loaded a DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; and &lt;code&gt;ENDLIBPATH&lt;/code&gt; , or</source>
          <target state="translated">除非 &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; 设置为 &lt;code&gt;T&lt;/code&gt; （并且内核在2000/09/01之后），否则此类DLL被视为全局的。加载全局DLL时，首先在已加载的全局DLL表中查找。因此，一个可执行文件从 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 和 &lt;code&gt;ENDLIBPATH&lt;/code&gt; 加载了一个DLL ，或者</target>
        </trans-unit>
        <trans-unit id="a9d2404af2307482983ff6743f035f7118e9d8f6" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; is set to &lt;code&gt;T&lt;/code&gt; (and the kernel is after 2000/09/01), such DLLs are considered to be global. When loading a global DLL it is first looked in the table of already-loaded global DLLs. Because of this the fact that one executable loaded a DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; and &lt;code&gt;ENDLIBPATH&lt;/code&gt;, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4244b98dff2bf774775c08e4df5afb2e645e4b77" translate="yes" xml:space="preserve">
          <source>Unless ASCII vs. EBCDIC issues are specifically being discussed, references to UTF-8 encoding in this document and elsewhere should be read as meaning UTF-EBCDIC on EBCDIC platforms. See &lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;&quot;Unicode and UTF&quot; in perlebcdic&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025ed2d87cd53899da043f16934d54b56cb767cf" translate="yes" xml:space="preserve">
          <source>Unless ASCII vs. EBCDIC issues are specifically being discussed, references to UTF-8 encoding in this document and elsewhere should be read as meaning UTF-EBCDIC on EBCDIC platforms. See &lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;Unicode and UTF in perlebcdic&lt;/a&gt;.</source>
          <target state="translated">除非特别讨论了ASCII与EBCDIC的问题，否则本文档和其他地方对UTF-8编码的引用应理解为EBCDIC平台上的UTF-EBCDIC。请参阅&lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;perlebcdic中的Unicode和UTF&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="763e516abf0169c17797549989072db7b3b436d9" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, functions return 0 on success, or a negative value (usually &lt;code&gt;EOF&lt;/code&gt; which is usually -1) and set &lt;code&gt;errno&lt;/code&gt; on error.</source>
          <target state="translated">除非另有说明，否则函数在成功时返回0，或者返回负值（通常 &lt;code&gt;EOF&lt;/code&gt; 通常为-1），并在错误时设置 &lt;code&gt;errno&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="843ebacc41e4317d9c7bf3f947fad475a9e1f11b" translate="yes" xml:space="preserve">
          <source>Unless otherwise notes, all examples below require this standard preamble to work correctly, with the &lt;code&gt;#!&lt;/code&gt; adjusted to work on your system:</source>
          <target state="translated">除非另有说明，否则以下所有示例均要求此标准序言才能正确使用 &lt;code&gt;#!&lt;/code&gt; 。调整以在您的系统上工作：</target>
        </trans-unit>
        <trans-unit id="a1410ee8e42e843fa403d9edd63361088b53c82a" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, version numbers &lt;b&gt;must&lt;/b&gt; appear in one of two formats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519ecd12b4838877006c606ab377c9933076da06" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated all methods return either a</source>
          <target state="translated">除非另有说明,否则所有方法都返回一个</target>
        </trans-unit>
        <trans-unit id="58c869a304e00ffd24d619f7d44db8d57f44a80c" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated it works just like ExtUtils::MM_Unix</source>
          <target state="translated">除非另有说明,否则它的工作原理和ExtUtils::MM_Unix一样。</target>
        </trans-unit>
        <trans-unit id="ae0b84fa2af86714bff9b9ce409d73281e7852b8" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated it works just like ExtUtils::MM_Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa9da45012bfbe0b5378d58f4fff0a9abfa58b5" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, it works just like ExtUtils::MM_Unix</source>
          <target state="translated">除非另有说明,否则它的工作原理和ExtUtils::MM_Unix一样。</target>
        </trans-unit>
        <trans-unit id="495362fe83affb77b166fe352e049869ffdf5946" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, it works just like ExtUtils::MM_Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e400a7ab19dec964d9377da14546fab4feb3ec" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;anyinflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;anyinflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="47a707f463b0bb3f1b25444c520600dbd6696505" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;anyuncompress&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;anyuncompress&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="d669d839575081392547a5a9cafaedbd09bec28c" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;bunzip2&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;bunzip2&lt;/code&gt; 命令， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="5cd0d3bee7135d518d8ccc595535d8b3eccde37f" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;bzip2&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;bzip2&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="2d2f8a94031befaa66720968f47bd4dde9da6fcf" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;deflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;deflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="f180e51799fa543d0272bd825b3d860097f806c2" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;gunzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;gunzip&lt;/code&gt; 解， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="43b54de84f56f9f511018d58087cdd33377321ec" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;gzip&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="d8c0791fbf600370c86e6ae040e4b2abd896e9ba" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;inflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;inflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="e65e4b1379d48c357409defc2e3a088bfcc64051" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;rawdeflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数为 &lt;code&gt;rawdeflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="f9aa434ca385a7cef6abc358c51e5f3189796565" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;rawinflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数为 &lt;code&gt;rawinflate&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="e2285dec1544503fb1e6e19eb0aec81e1f5a9726" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;unzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;unzip&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="f45874d912d180929ebed6cffec516fc7cf2fb97" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">除非下文指定，可选参数 &lt;code&gt;zip&lt;/code&gt; ， &lt;code&gt;OPTS&lt;/code&gt; ，是相同的那些在定义的OO接口用于&lt;a href=&quot;#Constructor-Options&quot;&gt;构造选项&lt;/a&gt;下面部分。</target>
        </trans-unit>
        <trans-unit id="871cfac0f7d812719fa8ee355ce0991623ac4e0b" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise all method can be called as class methods, or as object methods. If called as class methods then the &quot;default&quot; object will be used, and if necessary created using the current processes %Config and @INC. See the 'default' option to new() for details.</source>
          <target state="translated">除非另有规定,否则所有的方法都可以作为类方法或对象方法来调用,如果作为类方法来调用,那么将使用 &quot;默认 &quot;对象,必要时使用当前进程%Config和@INC来创建。如果作为类方法调用,那么将使用 &quot;默认 &quot;对象,如果需要的话,将使用当前进程%Config和@INC创建。详见new()的 &quot;默认 &quot;选项。</target>
        </trans-unit>
        <trans-unit id="360b129724fa7c1c8235f3513edf30406e818a7b" translate="yes" xml:space="preserve">
          <source>Unless the &lt;code&gt;/r&lt;/code&gt; option is used, the string specified with &lt;code&gt;=~&lt;/code&gt; must be a scalar variable, an array element, a hash element, or an assignment to one of those; in other words, an lvalue.</source>
          <target state="translated">除非使用 &lt;code&gt;/r&lt;/code&gt; 选项，否则用 &lt;code&gt;=~&lt;/code&gt; 指定的字符串必须是标量变量，数组元素，哈希元素或对其中之一的赋值；换句话说，一个左值。</target>
        </trans-unit>
        <trans-unit id="9ef73743f2ca77d91834c677a3b2a131dd0854b0" translate="yes" xml:space="preserve">
          <source>Unless the above additional feature is enabled, nothing about the backtrace functionality is visible, except for the Perl/XS level.</source>
          <target state="translated">除非启用上述附加功能,否则除了Perl/XS级别外,关于回溯功能的任何内容都不可见。</target>
        </trans-unit>
        <trans-unit id="c2c4cb992d99b0b97748811097f97eea4d2ce81b" translate="yes" xml:space="preserve">
          <source>Unless the operator is an assignment (&lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , etc.), repeat step (1) in respect of the second operand.</source>
          <target state="translated">除非运算符是赋值（ &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; 等），否则请对第二个操作数重复步骤（1）。</target>
        </trans-unit>
        <trans-unit id="05d7e76af21f11f9c892472417201fd8ed4cf910" translate="yes" xml:space="preserve">
          <source>Unless the operator is an assignment (&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, etc.), repeat step (1) in respect of the second operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6634c0ddc3b2fcdacf253fa92fd7c8403abaf0" translate="yes" xml:space="preserve">
          <source>Unless the pattern or string are encoded in UTF-8, only ASCII characters can match positively.</source>
          <target state="translated">除非模式或字符串用UTF-8编码,否则只有ASCII字符可以正面匹配。</target>
        </trans-unit>
        <trans-unit id="93f6520e33056598a5ce68e86d15794aa942a8a6" translate="yes" xml:space="preserve">
          <source>Unless they are explicitly specified, the default values for the exit status, verbose level, and output stream to use are determined as follows:</source>
          <target state="translated">除非明确指定它们,否则要使用的退出状态、verbose级别和输出流的默认值如下。</target>
        </trans-unit>
        <trans-unit id="28631a8600ab2d0e4799cb9a021cc0306169b6f9" translate="yes" xml:space="preserve">
          <source>Unless you are accessing the CPAN on your filesystem via a file: URL, CPAN.pm needs to keep the source files it downloads somewhere. Please supply a directory where the downloaded files are to be kept.</source>
          <target state="translated">除非你是通过一个文件来访问你的文件系统中的CPAN:URL,CPAN.pm需要在某个地方保存它下载的源文件。请提供一个保存下载文件的目录。</target>
        </trans-unit>
        <trans-unit id="6b861eac07037b268358d427fce8707b48f9500e" translate="yes" xml:space="preserve">
          <source>Unless you are using the &lt;code&gt;fields&lt;/code&gt; pragma, consider this module discouraged in favor of the lighter-weight &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">除非您使用 &lt;code&gt;fields&lt;/code&gt; pragma，否则建议不要使用此模块，而应使用轻量级的 &lt;code&gt;parent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd40baebc35d8dd113beed64e1b32df4e1666e49" translate="yes" xml:space="preserve">
          <source>Unless you are using the &lt;code&gt;fields&lt;/code&gt; pragma, consider this module discouraged in favor of the lighter-weight &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84f0f4d743460958895c1346a2bcc4ae32486815" translate="yes" xml:space="preserve">
          <source>Unless you don't like the possibility of there being part of your Perl scripts embedded in a database file, this is nothing to worry about.</source>
          <target state="translated">除非你不喜欢你的Perl脚本的一部分被嵌入到数据库文件中,否则这没什么好担心的。</target>
        </trans-unit>
        <trans-unit id="078c8b3d64fda031c2ca3a111adc19b05790c7fb" translate="yes" xml:space="preserve">
          <source>Unless you have a particular reason to use the two-argument form you should use the three-argument form of open() which does not treat any characters in the filename as special.</source>
          <target state="translated">除非你有特别的理由使用两个参数形式,否则你应该使用open()的三个参数形式,它不会将文件名中的任何字符视为特殊字符。</target>
        </trans-unit>
        <trans-unit id="bcd145902080112cd3bd3565e1aa0b2eb6698439" translate="yes" xml:space="preserve">
          <source>Unless you have good reasons for using some other format (for example, a format used within your company), the convention is to name your changelog file &lt;code&gt;Changes&lt;/code&gt; , and to follow the simple format described in &lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Changes::Spec&quot;&gt;CPAN::Changes::Spec&lt;/a&gt;.</source>
          <target state="translated">除非您有充分的理由使用其他格式（例如，公司内部使用的格式），否则约定是将更改日志文件命名为 &lt;code&gt;Changes&lt;/code&gt; ，并遵循&lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Changes::Spec&quot;&gt;CPAN :: Changes :: Spec中&lt;/a&gt;描述的简单格式。</target>
        </trans-unit>
        <trans-unit id="87db3fba7e4f130f44369a6d247e1f97fe2c94e1" translate="yes" xml:space="preserve">
          <source>Unless you have good reasons for using some other format (for example, a format used within your company), the convention is to name your changelog file &lt;code&gt;Changes&lt;/code&gt;, and to follow the simple format described in &lt;a href=&quot;CPAN::Changes::Spec&quot;&gt;CPAN::Changes::Spec&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba7a1f205e8e2686b0c4b6d39cce725cef83741e" translate="yes" xml:space="preserve">
          <source>Unless you know better, serializing hook should always say:</source>
          <target state="translated">除非你更了解,否则序列化钩子应该总是说。</target>
        </trans-unit>
        <trans-unit id="4f5f76f31b82833340ef52081bb4d0e79eab2cc2" translate="yes" xml:space="preserve">
          <source>Unless you know with 100% certainty that quux() is only ever available for the &quot;Foonix&quot; operating system &lt;b&gt;and&lt;/b&gt; that is available &lt;b&gt;and&lt;/b&gt; correctly working for &lt;b&gt;all&lt;/b&gt; past, present, &lt;b&gt;and&lt;/b&gt; future versions of &quot;Foonix&quot;, the above is very wrong. This is more correct (though still not perfect, because the below is a compile-time check):</source>
          <target state="translated">除非您有100％的确定性知道quux（）仅可用于&amp;ldquo; Foonix&amp;rdquo;操作系统，&lt;b&gt;并且&lt;/b&gt;该版本对于&amp;ldquo; Foonix&amp;rdquo;的&lt;b&gt;所有&lt;/b&gt;过去，现在&lt;b&gt;和&lt;/b&gt;将来的版本均可用&lt;b&gt;且&lt;/b&gt;正确运行，否则上述说法是错误的。这是更正确的（尽管仍然不完美，因为以下是编​​译时检查）：&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="93ff79231a3d36c0c3d8ce3114e701a1baebbf25" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a false value, Pod::Search will recurse into subdirectories of the search directories.</source>
          <target state="translated">除非你把这个属性设置为假值,否则Pod::Search将递归到搜索目录的子目录。</target>
        </trans-unit>
        <trans-unit id="17c62f898b45d3be500e6c39bec8d493a60a2715" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Search will apply Perl-specific heuristics to find the correct module PODs quickly. This attribute's default value is false. You won't normally need to set this to true.</source>
          <target state="translated">除非你把这个属性设置为真,否则Pod::Search将应用Perl特有的启发式方法来快速找到正确的模块POD。这个属性的默认值是false。一般情况下,你不需要将此属性设置为true。</target>
        </trans-unit>
        <trans-unit id="9f9a16887abf4c916f1550cac344cc208f6c0b6b" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Simple::Search will consider only the first file of a given modulename as it looks thru the specified directories; that is, with this option off, if Pod::Simple::Search has seen a &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; already in this search, then it won't bother looking at a &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; later on in that search, because that file is merely a &quot;shadow&quot;. But if you turn on &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt; , then these &quot;shadow&quot; files are inspected too, and are noted in the pathname2podname return hash.</source>
          <target state="translated">除非将此属性设置为真值，否则Pod :: Simple :: Search将仅考虑给定模块名的第一个文件，因为它通过指定目录进行查找；也就是说，关闭此选项后，如果Pod :: Simple :: Search 在此搜索中已经看到了 &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; ，那么以后就不会再 &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; 了。该搜索，因为该文件仅仅是&amp;ldquo;影子&amp;rdquo;。但是，如果打开 &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt; ，那么也会检查这些&amp;ldquo; shadow&amp;rdquo;文件，并在pathname2podname返回哈希中将其记录下来。</target>
        </trans-unit>
        <trans-unit id="4fc995dcd124519ccc18ad86cc265d6cd653065c" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Simple::Search will consider only the first file of a given modulename as it looks thru the specified directories; that is, with this option off, if Pod::Simple::Search has seen a &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; already in this search, then it won't bother looking at a &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; later on in that search, because that file is merely a &quot;shadow&quot;. But if you turn on &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt;, then these &quot;shadow&quot; files are inspected too, and are noted in the pathname2podname return hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa89971032de2d3d226811c31dc2014b63de305b" translate="yes" xml:space="preserve">
          <source>Unless you want to override the defaults, prefer META_MERGE so as to get the advantage of any future defaults.</source>
          <target state="translated">除非你想覆盖默认值,否则最好选择META_MERGE,这样才能获得未来默认值的优势。</target>
        </trans-unit>
        <trans-unit id="eb83985aa16dab9a13560a8e8f1159fe638efa8b" translate="yes" xml:space="preserve">
          <source>Unless you want to use its advanced features, this is probably all you need to know to use Exporter.</source>
          <target state="translated">除非你想使用它的高级功能,否则这可能是你使用Exporter所需要了解的全部内容。</target>
        </trans-unit>
        <trans-unit id="04c205c66e7bc90d55cfb8afb031ef118a5c83da" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;ve used &lt;code&gt;/a&lt;/code&gt; or &lt;code&gt;/aa&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; matches more than ASCII digits only, but Perl&amp;rsquo;s implicit string-to-number conversion does not current recognize these. Here&amp;rsquo;s how to convert such strings manually.</source>
          <target state="translated">除非您使用 &lt;code&gt;/a&lt;/code&gt; 或 &lt;code&gt;/aa&lt;/code&gt; ，否则 &lt;code&gt;\d&lt;/code&gt; 只能匹配多个ASCII数字，但是Perl的隐式字符串到数字的转换当前无法识别这些数字。这是手动转换此类字符串的方法。</target>
        </trans-unit>
        <trans-unit id="37d04e5bf67a8174972d88089473b77064f2c69b" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;ve used &lt;code&gt;/a&lt;/code&gt; or &lt;code&gt;/aa&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt; matches more than ASCII digits only, but Perl&amp;rsquo;s implicit string-to-number conversion does not current recognize these. Here&amp;rsquo;s how to convert such strings manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9444f4badd85c5a13fe02c22e0706b7a37804d" translate="yes" xml:space="preserve">
          <source>Unless you're writing a new &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, a plugin or subclassing &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b006759734f26ef71ac954f172bdb96074166b64" translate="yes" xml:space="preserve">
          <source>Unless you're writing a new &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, a plugin, or subclassing &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d5045afa1f26fa3558f3707783d1ac5db1ca1f3" translate="yes" xml:space="preserve">
          <source>Unless you're writing a new &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, a plugin or subclassing &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="translated">除非您正在编写新的&lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;，插件或&lt;a href=&quot;../parser&quot;&gt;TAP :: Parser的&lt;/a&gt;子类，否则您可能不需要直接使用此模块。</target>
        </trans-unit>
        <trans-unit id="83a68b50b49a806ff511080c423ef60589d29433" translate="yes" xml:space="preserve">
          <source>Unless you're writing a plugin or subclassing &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54802d84b1114c8dea2af70188cfd6c295957d7" translate="yes" xml:space="preserve">
          <source>Unless your parameters specify &lt;code&gt;'formatter'&lt;/code&gt; or &lt;code&gt;'ipc'&lt;/code&gt; arguments, the formatter and IPC instance will be inherited from the current top hub. You can set the parameters to &lt;code&gt;undef&lt;/code&gt; to avoid having a formatter or IPC instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4fc409268936e0da48b9a4cfb9650b21029f3c0" translate="yes" xml:space="preserve">
          <source>Unlike</source>
          <target state="translated">Unlike</target>
        </trans-unit>
        <trans-unit id="0b93fd78908f06ac9f5039bb243a42a6b44ce01c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#Decimal-Versions&quot;&gt;&quot;Decimal Versions&quot;&lt;/a&gt;, Dotted-Decimal Versions have more than a single decimal point, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0a5bc8021cd6778eed9a88f7e5cfd7b53090d1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt;, this does not include the decomposition type. Use the &lt;code&gt;Decomposition_Type&lt;/code&gt; property to get that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26769d51e7e8546d072ce687409eedaf6bbd7d27" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;, this does not include the decomposition type. Use the &lt;code&gt;Decomposition_Type&lt;/code&gt; property to get that.</source>
          <target state="translated">与&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;不同，它不包括分解类型。使用 &lt;code&gt;Decomposition_Type&lt;/code&gt; 属性可以实现这一点。</target>
        </trans-unit>
        <trans-unit id="9a41788c4603779b500b4b22e894cfcf25b5f9a6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#dbmopen-HASH%2CDBNAME%2CMASK&quot;&gt;&lt;code&gt;dbmopen&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;&lt;code&gt;tie&lt;/code&gt;&lt;/a&gt; function will not &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; or the &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; module for interesting &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;&lt;code&gt;tie&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6202c7008c5edbd97e21466da5df4a59ec41a0" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68f9ca2a4829500bd2437e49a38f1fec56cc959" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#utf8_to_bytes&quot;&gt;&quot;utf8_to_bytes&quot;&lt;/a&gt; but like &lt;a href=&quot;#bytes_to_utf8&quot;&gt;&quot;bytes_to_utf8&quot;&lt;/a&gt;, this is non-destructive of the input string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f7823a1b5c73e2c047f503abcdbc0ee1982c031" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;integer&quot;&gt;integer&lt;/a&gt;, this pragma creates integer constants that are only limited in their size by the available memory and CPU time.</source>
          <target state="translated">与&lt;a href=&quot;integer&quot;&gt;integer&lt;/a&gt;不同，此pragma创建的整数常量的大小仅受可用内存和CPU时间的限制。</target>
        </trans-unit>
        <trans-unit id="ed386882eb03009cdfed1d7cc619e0742b192d68" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function will not &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt; or the</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数不会为您 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 一个模块。您需要自己明确地执行此操作。请参阅&lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt;或</target>
        </trans-unit>
        <trans-unit id="e6074edfe48b345d15827a75a36946caff143c7a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function will not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; or the</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数不会为您 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 一个模块。您需要自己明确地执行此操作。请参阅&lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt;或</target>
        </trans-unit>
        <trans-unit id="7f221507f852d26a177998f0fca0127e91483ffd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for...in&lt;/a&gt;&lt;/code&gt;, Perl's &lt;code&gt;for&lt;/code&gt; (also spelled &lt;code&gt;foreach&lt;/code&gt; ) does not allow the left-hand side to be an arbitrary expression. It must be a variable:</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for...in&lt;/a&gt;&lt;/code&gt; 不同，Perl的 &lt;code&gt;for&lt;/code&gt; （也拼写为 &lt;code&gt;foreach&lt;/code&gt; ）不允许左侧为任意表达式。它必须是一个变量：</target>
        </trans-unit>
        <trans-unit id="2d1c847135806754dca42b817cb04eaf19cedf87" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 不同，当将数组作为第一个参数传递给 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 时，sprintf可能不执行您的意思。该数组具有标量上下文，并且Perl不会使用数组的第0个元素作为格式，而是使用数组中的元素计数作为格式，这几乎是没有用的。</target>
        </trans-unit>
        <trans-unit id="89ae4f74127125a7e7d48317841dc79dfceae6a6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 不同，当将数组作为第一个参数传递给 &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 时，sprintf可能不执行您的意思。该数组具有标量上下文，并且Perl不会使用数组的第0个元素作为格式，而是使用数组中的元素计数作为格式，这几乎是没有用的。</target>
        </trans-unit>
        <trans-unit id="3b964f91b8b4881dd0085a0962dbd9390808f7e2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;[[:digit:]]&lt;/code&gt; which matches digits in many writing systems, such as Thai and Devanagari, there are currently only two sets of hexadecimal digits, and it is unlikely that more will be added. This is because you not only need the ten digits, but also the six &lt;code&gt;[A-F]&lt;/code&gt; (and &lt;code&gt;[a-f]&lt;/code&gt;) to correspond. That means only the Latin script is suitable for these, and Unicode has only two sets of these, the familiar ASCII set, and the fullwidth forms starting at U+FF10 (FULLWIDTH DIGIT ZERO).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58c8c453430fd542b53059b23563075518c8ca7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;for...in&lt;/code&gt;, Perl's &lt;code&gt;for&lt;/code&gt; (also spelled &lt;code&gt;foreach&lt;/code&gt;) does not allow the left-hand side to be an arbitrary expression. It must be a variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ee12c11bcd84febb2422b0c97e2cecef90b3a9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;use feature &quot;:5.12&quot;&lt;/code&gt;, saying &lt;code&gt;use v5.12&lt;/code&gt; (or any higher version) also does the equivalent of &lt;code&gt;use strict&lt;/code&gt;; see &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9885543c31cf8cf0906d34d4b26f89726d373169" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;which&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; , this function is platform independent and will also work on, for example, Win32.</source>
          <target state="translated">与 &lt;code&gt;which&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 不同，此函数与平台无关，并且也可以在Win32等环境下使用。</target>
        </trans-unit>
        <trans-unit id="4fd10722655bcf3a1480d15b870f6c966069d54d" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;which&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;, this function is platform independent and will also work on, for example, Win32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1319ac66a745a073ad45b032e405d0c0606e8b" translate="yes" xml:space="preserve">
          <source>Unlike Perl 4, in which all the variables were dynamic and shared one global name space, causing maintainability problems, Perl 5 provides two mechanisms for protecting code from having its variables stomped on by other code: lexically scoped variables created with &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;state&lt;/code&gt; and namespaced global variables, which are exposed via the &lt;code&gt;vars&lt;/code&gt; pragma, or the &lt;code&gt;our&lt;/code&gt; keyword. Any global variable is considered to be part of a namespace and can be accessed via a &quot;fully qualified form&quot;. Conversely, any lexically scoped variable is considered to be part of that lexical-scope, and does not have a &quot;fully qualified form&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35eb11bdbc8f6461d7ed511f9bd108d79a6ba74" translate="yes" xml:space="preserve">
          <source>Unlike Perl's built-in hashes, it is not safe to &lt;code&gt;delete&lt;/code&gt; the current item from a GDBM_File tied hash while iterating over it with &lt;code&gt;each&lt;/code&gt;. This is a limitation of the gdbm library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93ac07922c6fc8a77d40224ee6574380d8e4055" translate="yes" xml:space="preserve">
          <source>Unlike Win32 build, miniperl will not have</source>
          <target state="translated">与Win32构建不同的是,miniperl将不会有</target>
        </trans-unit>
        <trans-unit id="a7c35c87e2cd92f458c69ed20a29518c1fc60ceb" translate="yes" xml:space="preserve">
          <source>Unlike constants in some languages, these cannot be overridden on the command line or via environment variables.</source>
          <target state="translated">与某些语言中的常量不同,这些常量不能在命令行或通过环境变量被覆盖。</target>
        </trans-unit>
        <trans-unit id="2e9d61b3ed80ed71e7bbbb9d575bf23b5d77fb98" translate="yes" xml:space="preserve">
          <source>Unlike dbmopen(), the tie() function will not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you--you need to do that explicitly yourself.</source>
          <target state="translated">与dbmopen（）不同，tie（）函数不会为您 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 一个模块-您需要自己明确地执行此操作。</target>
        </trans-unit>
        <trans-unit id="ac457fcb4cff6e9b40b4fc09afe6c228026b2c13" translate="yes" xml:space="preserve">
          <source>Unlike dbmopen(), the tie() function will not &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; a module for you--you need to do that explicitly yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7d99bfc8b3205da369ad185c97fc4f2004cc75" translate="yes" xml:space="preserve">
          <source>Unlike dynamic variables created by the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; operator, lexical variables declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; are totally hidden from the outside world, including any called subroutines. This is true if it's the same subroutine called from itself or elsewhere--every call gets its own copy.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 运算符创建的动态变量不同，使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明的词法变量对外界完全隐藏，包括任何被调用的子例程。如果它是从其本身或在其他地方调用的相同子例程，则这是正确的-每次调用都有自己的副本。</target>
        </trans-unit>
        <trans-unit id="ef30321397c8a6c2a145849a1e7eb34fc5044060" translate="yes" xml:space="preserve">
          <source>Unlike dynamic variables created by the &lt;code&gt;local&lt;/code&gt; operator, lexical variables declared with &lt;code&gt;my&lt;/code&gt; are totally hidden from the outside world, including any called subroutines. This is true if it's the same subroutine called from itself or elsewhere--every call gets its own copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d613b9dfee0f458298b76229e47572b9ad09a4" translate="yes" xml:space="preserve">
          <source>Unlike in C and Pascal, in Perl these are all defined in terms of BLOCKs, not statements. This means that the curly brackets are</source>
          <target state="translated">与C语言和Pascal语言不同的是,在Perl中,这些都是以BLOCK的形式定义的,而不是以语句的形式定义的。这意味着,大括号是</target>
        </trans-unit>
        <trans-unit id="f21336a91710bef15208089eafb11092016626b2" translate="yes" xml:space="preserve">
          <source>Unlike in C, the scalar assignment operator produces a valid lvalue. Modifying an assignment is equivalent to doing the assignment and then modifying the variable that was assigned to. This is useful for modifying a copy of something, like this:</source>
          <target state="translated">与C语言不同的是,标量赋值运算符会产生一个有效的l值。修改赋值相当于先做赋值,然后修改被赋值的变量。这对于修改某个东西的副本很有用,就像这样。</target>
        </trans-unit>
        <trans-unit id="5f827eec6110de095ec9210c18c9cbffc634099b" translate="yes" xml:space="preserve">
          <source>Unlike in earlier versions of Perl, &lt;code&gt;:raw&lt;/code&gt; is</source>
          <target state="translated">与早期版本的Perl不同， &lt;code&gt;:raw&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="33bdaa80be75964fba31840d455d3822e7d396b4" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;&quot;&quot;&lt;/code&gt; ) can be returned. Since &lt;code&gt;catdir()&lt;/code&gt; on Mac OS always appends a trailing colon to distinguish a directory path from a file path, a single trailing colon will be ignored, i.e. there's no empty directory name after it.</source>
          <target state="translated">与仅在分隔符上拆分目录不同，可以返回空目录名称（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）。由于Mac OS上的 &lt;code&gt;catdir()&lt;/code&gt; 总是附加尾随冒号来区分目录路径和文件路径，因此单个尾随冒号将被忽略，即其后没有空目录名。</target>
        </trans-unit>
        <trans-unit id="7e91e9b08f85424586bbe7fa7e02138bcae68a32" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;&quot;&quot;&lt;/code&gt;) can be returned. Since &lt;code&gt;catdir()&lt;/code&gt; on Mac OS always appends a trailing colon to distinguish a directory path from a file path, a single trailing colon will be ignored, i.e. there's no empty directory name after it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54463777f2a5a26bb28578fbecd0a237664559d0" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt; ) can be returned, because these are significant on some OSes.</source>
          <target state="translated">与仅在分隔符上拆分目录不同，可以返回空目录名称（ &lt;code&gt;''&lt;/code&gt; ），因为这些名称在某些操作系统上很重要。</target>
        </trans-unit>
        <trans-unit id="86f74613bf49290364595249fc093a5b0e46c0b1" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt; ) can be returned, because these are significant on some OSs.</source>
          <target state="translated">与仅在分隔符上拆分目录不同，可以返回空目录名称（ &lt;code&gt;''&lt;/code&gt; ），因为这些名称在某些操作系统上很重要。</target>
        </trans-unit>
        <trans-unit id="a1dab7e402fccbdcf23288af9af78be14a2bd58c" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt;) can be returned, because these are significant on some OSes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6113c750f78736baa4aa9cd996719b663fd9d18d" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt;) can be returned, because these are significant on some OSs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0601a2027041706b4a215c5ba97b0f2d038f55f" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, leading empty and trailing directory entries can be returned, because these are significant on some OSs. So,</source>
          <target state="translated">与仅仅在分隔符上分割目录不同,可以返回前导空和后导目录条目,因为这些条目在某些操作系统上很重要。所以。</target>
        </trans-unit>
        <trans-unit id="7934f43f05e561c630f325debe8a290638569198" translate="yes" xml:space="preserve">
          <source>Unlike local variables in C or C++, Perl's lexical variables don't necessarily get recycled just because their scope has exited. If something more permanent is still aware of the lexical, it will stick around. So long as something else references a lexical, that lexical won't be freed--which is as it should be. You wouldn't want memory being free until you were done using it, or kept around once you were done. Automatic garbage collection takes care of this for you.</source>
          <target state="translated">与 C 或 C++中的局部变量不同,Perl 的词法变量不一定会因为其作用域退出而被回收。如果有更永久性的东西仍然知道这个词库,它就会一直存在。只要有其他东西引用一个词法,这个词法就不会被释放--这也是应该的。你不会希望内存在你使用完之前是空闲的,或者一旦你使用完了,它就会被保留下来。自动垃圾收集会帮你解决这个问题。</target>
        </trans-unit>
        <trans-unit id="61c2bf5d9fb9c4e4b449918bf685b7cd4c575760" translate="yes" xml:space="preserve">
          <source>Unlike many other languages which support object orientation, Perl does not provide any special syntax for constructing an object. Objects are merely Perl data structures (hashes, arrays, scalars, filehandles, etc.) that have been explicitly associated with a particular class.</source>
          <target state="translated">与其他许多支持对象导向的语言不同,Perl并没有提供任何特殊的语法来构造对象。对象只是Perl的数据结构(哈希、数组、标量、文件柄等),它们已经明确地与一个特定的类相关联。</target>
        </trans-unit>
        <trans-unit id="96a17407e83fd96732a811a270065f8bf99b9560" translate="yes" xml:space="preserve">
          <source>Unlike most encodings which accept various ways to handle errors, Unicode encodings simply croaks.</source>
          <target state="translated">与大多数编码接受各种处理错误的方式不同,Unicode编码只是呱呱叫。</target>
        </trans-unit>
        <trans-unit id="49b673e0d13d9cc508ff95ef6bf45edac94a0386" translate="yes" xml:space="preserve">
          <source>Unlike most locales, which are specific to a language and country pair, Unicode classifies all the characters that are letters</source>
          <target state="translated">不像大多数地方码是针对语言和国家对的,Unicode将所有属于字母的字符进行分类。</target>
        </trans-unit>
        <trans-unit id="de28345f4c14a0c66a5513ec93329ba001d9ced5" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="c0d9558dea8e06eb18c291c6122258af13477176" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="9b35f8dffb5619dd71375e3734d385be7cc68976" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="642dec0f5e46307ce9e97ef7e93a9392f0b1f7ab" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="8e8af66683db3fc2cddaa8cdf32b4f53ebab4445" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; ，因此重做（&amp;ldquo; foo&amp;rdquo;）。&amp;ldquo; bar&amp;rdquo;将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="5bec2254ea41ddda3ef06eefb12b88f8ff1170ba" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="46f28e7c4c55184f01ee0fc59018a927acd8437c" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="fe0bcbfb6300fcbe2507c49b4631d20697de525c" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它的优先级与赋值相同。它也不受函数函数规则的 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; ，因此重做（&amp;ldquo; foo&amp;rdquo;）。&amp;ldquo; bar&amp;rdquo;将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="34c00fe043d78656afd77828c738549c64c1fe0d" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;dump (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;a href=&quot;#dump-LABEL&quot;&gt;&lt;code&gt;dump&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22585aa0bd13d608250b8dcea334b07dd252021" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;last (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec12e43efad3d3a645f2714eff3a43a7be31992" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;next (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03dc19f120a0108be730d05ae2cc974e390f447d" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;redo (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;a href=&quot;#redo-LABEL&quot;&gt;&lt;code&gt;redo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee3973cea98d2564d41622c65ad1eadc9b20495" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="fd9949db65a27c0400a1254746b3e91b925c452b" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与大多数命名运算符不同，它也不受函数函数规则的约束，因此 &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 将使&amp;ldquo; bar&amp;rdquo;成为 &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 参数的一部分。</target>
        </trans-unit>
        <trans-unit id="c7a5022b5ad46573ca70c92672e20e032530725b" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;return (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &lt;code&gt;&quot;bar&quot;&lt;/code&gt; to be part of the argument to &lt;a href=&quot;#return-EXPR&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728a32d1ef745efc09c9a2c8f8520f5d6f4c4b95" translate="yes" xml:space="preserve">
          <source>Unlike most of the other functions that have &lt;code&gt;utf8&lt;/code&gt; in their name, the input to this function is NOT a UTF-8-encoded string. The function name is slightly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d21a9fd801c4b5ff299a1a5bef8631136555ebd2" translate="yes" xml:space="preserve">
          <source>Unlike most operators, the smartmatch operator knows to treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; specially:</source>
          <target state="translated">与大多数运算符不同，smartmatch运算符知道如何特别处理 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a099365433c865a39830b29bcea8462ee44a1ac6" translate="yes" xml:space="preserve">
          <source>Unlike most operators, the smartmatch operator knows to treat &lt;code&gt;undef&lt;/code&gt; specially:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52ae364f54ddc8596b506c3503500a0182fc785" translate="yes" xml:space="preserve">
          <source>Unlike most other encodings, the following always croaks on error for any $chk that evaluates to true.</source>
          <target state="translated">与大多数其他编码不同的是,对于任何值为真的$chk,下面的代码总是错误的。</target>
        </trans-unit>
        <trans-unit id="3d20af86f51aab9cb74465f15c6036108807e949" translate="yes" xml:space="preserve">
          <source>Unlike non-user-defined &lt;code&gt;\p{}&lt;/code&gt; property matches, no warning is ever generated if these properties are matched against a non-Unicode code point (see &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;&quot;Beyond Unicode code points&quot;&lt;/a&gt; below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0be45e558750e70d5ad5d40843ef88fbc85d85e" translate="yes" xml:space="preserve">
          <source>Unlike non-user-defined &lt;code&gt;\p{}&lt;/code&gt; property matches, no warning is ever generated if these properties are matched against a non-Unicode code point (see &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;Beyond Unicode code points&lt;/a&gt; below).</source>
          <target state="translated">与非用户定义的 &lt;code&gt;\p{}&lt;/code&gt; 属性匹配不同，如果将这些属性与非Unicode代码点匹配，则不会生成任何警告（请参见下面的&lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;Unicode代码点之外&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="54d85676113e32968ab38ead192e565266d17ce6" translate="yes" xml:space="preserve">
          <source>Unlike other DJGPP packages, which are normal &quot;zip&quot; files, most CPAN module packages are &quot;gzipped tarballs&quot;. Recent versions of WinZip will safely unpack and expand them, *UNLESS* they have zero-length files. It is a known WinZip bug (as of v7.0) that it will not extract zero-length files.</source>
          <target state="translated">与其他DJGPP包是普通的 &quot;zip &quot;文件不同,大多数CPAN模块包是 &quot;gzipped tarballs&quot;。最新版本的WinZip可以安全地解压和扩展它们,除非它们有零长度的文件。这是一个已知的WinZip错误(从7.0版本开始),它不能解压零长度的文件。</target>
        </trans-unit>
        <trans-unit id="7d1d9ddacb9cc957a1381975755b447def4208e7" translate="yes" xml:space="preserve">
          <source>Unlike other boolean options, this opotion is enabled by default beginning with version &lt;code&gt;4.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83864ffb2b433053a7d93f1893b27cbe33018e20" translate="yes" xml:space="preserve">
          <source>Unlike other encodings where mappings are not one-to-one against Unicode, UTFs are supposed to map 100% against one another. So Encode is more strict on UTFs.</source>
          <target state="translated">与其他编码不同,其他编码与Unicode的映射不是一对一的,UTF应该是100%的相互映射。所以Encode对UTFs的要求比较严格。</target>
        </trans-unit>
        <trans-unit id="9944da74f109a50432581cc20ef1a61578ffdb1c" translate="yes" xml:space="preserve">
          <source>Unlike other types of quote-like literals, a here document is rarely a contiguous substring. For example, a typical piece of code using here document might look like this:</source>
          <target state="translated">与其他类型的类似引号的文字不同,here文档很少是一个连续的子串。例如,一段使用 here 文档的典型代码可能是这样的。</target>
        </trans-unit>
        <trans-unit id="82bfb2284168959f095690d2be25e5ae6b5a6d2d" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; declarations are not BLOCK-scoped. They are thus effective for the entire file in which they appear. You may not rescind such declarations with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</source>
          <target state="translated">与影响 &lt;code&gt;$^H&lt;/code&gt; 提示变量的编译指示不同， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; 声明不是BLOCK范围的。因此，它们对于显示它们的整个文件都是有效的。你可能不撤销这些声明与 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="946dc8e2b9e4dbb1e056eab35da113b4edec1e74" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; declarations are not BLOCK-scoped. They are thus effective for the entire package in which they appear. You may not rescind such declarations with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</source>
          <target state="translated">与影响 &lt;code&gt;$^H&lt;/code&gt; 提示变量的编译指示不同， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; 声明不是BLOCK范围的。因此，它们对于其中出现的整个包装都是有效的。你可能不撤销这些声明与 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee09d59fb829cfd66034aa9b684c476eb3f881a3" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;use vars&lt;/code&gt; and &lt;code&gt;use subs&lt;/code&gt; declarations are not lexically scoped to the block they appear in: they affect the entire package in which they appear. It is not possible to rescind these declarations with &lt;code&gt;no vars&lt;/code&gt; or &lt;code&gt;no subs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a62fc8b32926f79e07e4cd739d192b4db682422d" translate="yes" xml:space="preserve">
          <source>Unlike previous examples, we've now run h2xs on a real include file. This has caused some extra goodies to appear in both the .pm and .xs files.</source>
          <target state="translated">与之前的例子不同,我们现在已经在一个真正的include文件上运行h2xs。这使得一些额外的好东西出现在.pm和.xs文件中。</target>
        </trans-unit>
        <trans-unit id="1ef80340079fb27e8a35fae5de34324e0ae68abb" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; implementations, the directory used for the temporary file is not specified in a system include file (&lt;code&gt;P_tmpdir&lt;/code&gt;) but simply depends on the choice of tmpdir() returned by &lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt;. On some implementations this location can be set using the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, which may not be secure. If this is a problem, simply use mkstemp() and specify a template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82613342b350d8ac2d5e700389b419d73a2e8511" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;Newx&lt;/code&gt; and &lt;code&gt;Newxc&lt;/code&gt; macros, the &lt;code&gt;Newxz&lt;/code&gt; macro calls &lt;code&gt;memzero&lt;/code&gt; to zero out all the newly allocated memory.</source>
          <target state="translated">与 &lt;code&gt;Newx&lt;/code&gt; 和 &lt;code&gt;Newxc&lt;/code&gt; 宏不同， &lt;code&gt;Newxz&lt;/code&gt; 宏调用 &lt;code&gt;memzero&lt;/code&gt; 将所有新分配的内存清零。</target>
        </trans-unit>
        <trans-unit id="3459d8de61947e832dd8d6cc93a45a157f32fe5d" translate="yes" xml:space="preserve">
          <source>Unlike the GNU programs,</source>
          <target state="translated">与GNU程序不同。</target>
        </trans-unit>
        <trans-unit id="675122bbd6fe9d02ab821cef4f122f1e2fdb7554" translate="yes" xml:space="preserve">
          <source>Unlike the L</source>
          <target state="translated">不像L</target>
        </trans-unit>
        <trans-unit id="00946f20f0f39de3fde945a1c4762c9a2eb54a4d" translate="yes" xml:space="preserve">
          <source>Unlike the old Unix fmt(1) utility, this module correctly accounts for any Unicode combining characters (such as diacriticals) that may occur in each line for both expansion and unexpansion. These are overstrike characters that do not increment the logical position. Make sure you have the appropriate Unicode settings enabled.</source>
          <target state="translated">与旧的Unix fmt(1)实用程序不同,这个模块正确地计算了每行中可能出现的Unicode组合字符(如双标号)的扩展和未扩展。这些字符是不增加逻辑位置的叠加字符。确保您已经启用了适当的Unicode设置。</target>
        </trans-unit>
        <trans-unit id="0625a7948b2143bf8fa5b94abdec3d975bedca11" translate="yes" xml:space="preserve">
          <source>Unlike the old unix utilities, this module correctly accounts for any Unicode combining characters (such as diacriticals) that may occur in each line for both expansion and unexpansion. These are overstrike characters that do not increment the logical position. Make sure you have the appropriate Unicode settings enabled.</source>
          <target state="translated">与旧的unix实用程序不同,该模块正确地计算了每行中可能出现的Unicode组合字符(如双音符),包括扩展和未扩展。这些字符是不增加逻辑位置的叠加字符。确保您已经启用了适当的Unicode设置。</target>
        </trans-unit>
        <trans-unit id="bbee11f3129dceedbb755c4927925d533e72e81f" translate="yes" xml:space="preserve">
          <source>Unlike the original coding of this example, the returned values are not accessed in reverse order. So &lt;code&gt;ST(0)&lt;/code&gt; refers to the first value returned by the Perl subroutine and &lt;code&gt;ST(count-1)&lt;/code&gt; refers to the last.</source>
          <target state="translated">与本示例的原始编码不同，返回的值不是按相反的顺序访问的。因此， &lt;code&gt;ST(0)&lt;/code&gt; 指的是Perl子例程返回的第一个值， &lt;code&gt;ST(count-1)&lt;/code&gt; 指的是最后一个值。</target>
        </trans-unit>
        <trans-unit id="038e468b7871a7585436a41ba81caefab5eb3568" translate="yes" xml:space="preserve">
          <source>Unlike the stringification operator, there is never any need to append trailing zeros to preserve the correct version value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa5c6301a77bc0d8757cfca2a7141b60979b735" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#croak&quot;&gt;&quot;croak&quot;&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54921bfadbbc4d5488355e38753c36b606db5127" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">与&lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;不同， &lt;code&gt;pat&lt;/code&gt; 不允许为null。</target>
        </trans-unit>
        <trans-unit id="ae0137e5db1f710b710a9bc0edfaf77e15650ab6" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#vcroak&quot;&gt;&quot;vcroak&quot;&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7070baa0bba9b5c3411b37157873dd12da55ea" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#vcroak&quot;&gt;vcroak&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">与&lt;a href=&quot;#vcroak&quot;&gt;vcroak&lt;/a&gt;不同， &lt;code&gt;pat&lt;/code&gt; 不允许为null。</target>
        </trans-unit>
        <trans-unit id="28eadad196509c659a3994d74f2858a30a637ebf" translate="yes" xml:space="preserve">
          <source>Unlink a file, this wraps &lt;code&gt;unlink()&lt;/code&gt; in a way that makes it more reliable cross-platform when trying to unlink files you recently altered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5cefcdd918640639ca1153770063f61e285104d" translate="yes" xml:space="preserve">
          <source>Unlink any temporary files you create.</source>
          <target state="translated">解除您创建的任何临时文件的链接。</target>
        </trans-unit>
        <trans-unit id="3e77881bda9dd47b3e5c55a65b50384eb4b9609f" translate="yes" xml:space="preserve">
          <source>Unloads a previously loaded dynamic-link library. The HANDLE is no longer valid after this call. See &lt;a&gt;LoadLibrary&lt;/a&gt; for information on dynamically loading a library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2c338fa9bfcccaac25268ab0ef12e64490b19e" translate="yes" xml:space="preserve">
          <source>Unlock and close the database.</source>
          <target state="translated">解锁并关闭数据库。</target>
        </trans-unit>
        <trans-unit id="425b4daaa8be44cc037fb6c4f8a9c4ee47b576db" translate="yes" xml:space="preserve">
          <source>Unmatched ( in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6fca5f2f3ab74092e2301bc93cfd673ca1d5fb7" translate="yes" xml:space="preserve">
          <source>Unmatched ) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87bab1d81d4066140528cdd5b267a8458e21ea97" translate="yes" xml:space="preserve">
          <source>Unmatched [ in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5582b12b8fb1f3004178fe6e1d310ea58d890611" translate="yes" xml:space="preserve">
          <source>Unmatched right %s bracket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2c3a3141852414ad16ff6056e8a91c4d6648f7" translate="yes" xml:space="preserve">
          <source>Unpack the main archive to a temporary location (RAM: is fine).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1b8bde43d6985240bfa75345e6d99d943394fd" translate="yes" xml:space="preserve">
          <source>Unpack the result with</source>
          <target state="translated">将结果用</target>
        </trans-unit>
        <trans-unit id="add77c91d022a17024fa5eba373c6e719da883a1" translate="yes" xml:space="preserve">
          <source>Unpack the result with &lt;code&gt;tar -xof yourmodule.tar&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;tar -xof yourmodule.tar&lt;/code&gt; 解压缩结果</target>
        </trans-unit>
        <trans-unit id="ae62392d2b4bc10cbedb53bdaea138dd0c54922e" translate="yes" xml:space="preserve">
          <source>Unpack the source package</source>
          <target state="translated">解压源码包</target>
        </trans-unit>
        <trans-unit id="3ba56861ba0d7e4bf096f38cb19b9bd9d11ad9ab" translate="yes" xml:space="preserve">
          <source>Unpacking CPAN Modules on DOS</source>
          <target state="translated">在DOS上解压CPAN模块</target>
        </trans-unit>
        <trans-unit id="a3e58138dfa89b35eb5a0a67e0ceb78fe71fb3cd" translate="yes" xml:space="preserve">
          <source>Unpacking Perl Distribution on BS2000</source>
          <target state="translated">在BS2000上解压Perl发行版</target>
        </trans-unit>
        <trans-unit id="1906a11a734d044847362b51bdd5c4ffec722822" translate="yes" xml:space="preserve">
          <source>Unpacking Perl distribution on OS/390</source>
          <target state="translated">在OS/390上解压Perl发行版</target>
        </trans-unit>
        <trans-unit id="1bfe6e7e13df7f1f795bc2c142ba9f8933ba83d0" translate="yes" xml:space="preserve">
          <source>Unpacking a Stack Frame</source>
          <target state="translated">拆开堆叠框架的包装</target>
        </trans-unit>
        <trans-unit id="13585670fad4d52485b4ecff204569086b8b8bc7" translate="yes" xml:space="preserve">
          <source>Unpacking this message can be done with the same template:</source>
          <target state="translated">解开这个消息可以用同一个模板。</target>
        </trans-unit>
        <trans-unit id="65ab97485c132c2a06d23b7d99106c078eeca52f" translate="yes" xml:space="preserve">
          <source>Unpacking using the &lt;code&gt;U&lt;/code&gt; template code also works on UTF-8 encoded byte strings.</source>
          <target state="translated">使用 &lt;code&gt;U&lt;/code&gt; 模板代码解压缩也适用于UTF-8编码的字节字符串。</target>
        </trans-unit>
        <trans-unit id="72bbb6196a2774c03510ad2f9119cf1acefc342b" translate="yes" xml:space="preserve">
          <source>Unqualified &lt;code&gt;dump()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e326cb1d4e10ed2c54308ac7f68f78f28b408a5" translate="yes" xml:space="preserve">
          <source>Unqualified dump()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99dd6692af960885bd57e60a35c0eb60eb31d7b" translate="yes" xml:space="preserve">
          <source>Unquoted string &quot;%s&quot; may clash with future reserved word</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b032b56f7aa399f0c5a6580292f3e83d7b1fad" translate="yes" xml:space="preserve">
          <source>Unread</source>
          <target state="translated">Unread</target>
        </trans-unit>
        <trans-unit id="630c8dcab3eab70bdc2071c988078d95676c03b2" translate="yes" xml:space="preserve">
          <source>Unrecognized character %s; marked by &amp;lt;-- HERE after %s near column %d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c8af17f83153420d0d873b2861766a589d6251" translate="yes" xml:space="preserve">
          <source>Unrecognized escape \%c in character class in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435719049eae3b64ca346100529a4145c47781d5" translate="yes" xml:space="preserve">
          <source>Unrecognized escape \%c in character class passed through in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f0a236cfaeb24a6d268ae857e2d6c9ca2477d8" translate="yes" xml:space="preserve">
          <source>Unrecognized escape \%c passed through</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6680e7a052c1c186addf84b706b28b2f52bdc84d" translate="yes" xml:space="preserve">
          <source>Unrecognized escape \%s passed through in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f5901f9cf23090de8d1e00ed8502304a6736d2" translate="yes" xml:space="preserve">
          <source>Unrecognized signal name &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d60ad24f51432cfcd0acc6a239e8d374b5bdb9a" translate="yes" xml:space="preserve">
          <source>Unrecognized signal name: ...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e72ab0d0741f2af5e4f61b7913215c68a19c3881" translate="yes" xml:space="preserve">
          <source>Unrecognized switch: -%s (-h will show valid options)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a7351144db986600fc42c362487972431c1fb70" translate="yes" xml:space="preserve">
          <source>Unsafe signals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c52c7fb5fb7350d05f5400b468c41971c6a2ea" translate="yes" xml:space="preserve">
          <source>Unsets the IV status of an SV.</source>
          <target state="translated">解除SV的IV状态。</target>
        </trans-unit>
        <trans-unit id="4b35d98112909417a16d4e204369414a7012a63c" translate="yes" xml:space="preserve">
          <source>Unsets the NV status of an SV.</source>
          <target state="translated">解除SV的NV状态。</target>
        </trans-unit>
        <trans-unit id="8c346401fde7bad98f35f3a033aefb050144d4e1" translate="yes" xml:space="preserve">
          <source>Unsets the NV/IV status of an SV.</source>
          <target state="translated">解除SV的NV/IV状态。</target>
        </trans-unit>
        <trans-unit id="b2fe5f61df3d20003f435b822e60a53db4a67fca" translate="yes" xml:space="preserve">
          <source>Unsets the PV status of an SV.</source>
          <target state="translated">取消设置SV的PV状态。</target>
        </trans-unit>
        <trans-unit id="2b428943db3814d458253435d21b77a7039ff870" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of an SV.</source>
          <target state="translated">解除SV的RV状态。</target>
        </trans-unit>
        <trans-unit id="167340ebdf7672f2c96a0ab5594ee87b55416719" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt; . The &lt;code&gt;cflags&lt;/code&gt; argument can contain &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; to force the reference count to be decremented (otherwise the decrementing is conditional on the reference count being different from one or the reference being a readonly SV). See &lt;code&gt;SvROK_off&lt;/code&gt; .</source>
          <target state="translated">取消设置SV的RV状态，并减少RV所引用内容的引用计数。几乎可以认为这是 &lt;code&gt;newSVrv&lt;/code&gt; 的逆转。所述 &lt;code&gt;cflags&lt;/code&gt; 参数可以包含 &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; 迫使引用计数被递减（否则递减是上的引用计数从一个是不同的或参考是一个只读SV有条件的）。参见 &lt;code&gt;SvROK_off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2213e6f5fdeb83ff58d3c894e858b5a7ff9788f0" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt; . This is &lt;code&gt;sv_unref_flags&lt;/code&gt; with the &lt;code&gt;flag&lt;/code&gt; being zero. See &lt;code&gt;SvROK_off&lt;/code&gt; .</source>
          <target state="translated">取消设置SV的RV状态，并减少RV所引用内容的引用计数。几乎可以认为这是 &lt;code&gt;newSVrv&lt;/code&gt; 的逆转。这是 &lt;code&gt;sv_unref_flags&lt;/code&gt; ， &lt;code&gt;flag&lt;/code&gt; 为零。参见 &lt;code&gt;SvROK_off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4cffc0b1a0c243323d58c0b5fa0e4671c5ada28" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt;. The &lt;code&gt;cflags&lt;/code&gt; argument can contain &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; to force the reference count to be decremented (otherwise the decrementing is conditional on the reference count being different from one or the reference being a readonly SV). See &lt;code&gt;&lt;a href=&quot;#SvROK_off&quot;&gt;&quot;SvROK_off&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f24f3b0f1eacb57c8cbf5e1328666ef8fc81abb" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt;. This is &lt;code&gt;sv_unref_flags&lt;/code&gt; with the &lt;code&gt;flag&lt;/code&gt; being zero. See &lt;code&gt;&lt;a href=&quot;#SvROK_off&quot;&gt;&quot;SvROK_off&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcfacd26d54ec31883bc064dd4f33047f4f7aa58" translate="yes" xml:space="preserve">
          <source>Unsets the UTF-8 status of an SV (the data is not changed, just the flag). Do not use frivolously.</source>
          <target state="translated">取消SV的UTF-8状态(数据没有改变,只是标志)。不要随便使用。</target>
        </trans-unit>
        <trans-unit id="d458cc7af0595ce52fa475113c58f925209c55f3" translate="yes" xml:space="preserve">
          <source>Unsets the script encoding. The layers of &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; are reset to &quot;&lt;code&gt;:raw&lt;/code&gt; &quot; (the default unprocessed raw stream of bytes).</source>
          <target state="translated">取消脚本编码。 &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; 的层重设为&amp;ldquo; &lt;code&gt;:raw&lt;/code&gt; &amp;rdquo;（默认的未处理原始字节流）。</target>
        </trans-unit>
        <trans-unit id="8ffc0139d7a33cda1bb74b572fbce39422237d1e" translate="yes" xml:space="preserve">
          <source>Unsets the script encoding. The layers of &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt; are reset to &quot;&lt;code&gt;:raw&lt;/code&gt;&quot; (the default unprocessed raw stream of bytes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f886677b52de9f164b2193f280f9e0b4fa4087" translate="yes" xml:space="preserve">
          <source>Unshift the given number of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values onto the beginning of the array. The array will grow automatically to accommodate the addition. You must then use &lt;code&gt;av_store&lt;/code&gt; to assign values to these new elements.</source>
          <target state="translated">将给定数量的 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值平移到数组的开头。阵列将自动增长以适应添加。然后，您必须使用 &lt;code&gt;av_store&lt;/code&gt; 为这些新元素分配值。</target>
        </trans-unit>
        <trans-unit id="75a9c3204a7376541e1fbe9d2c8b5f9cdca1e7c3" translate="yes" xml:space="preserve">
          <source>Unshift the given number of &lt;code&gt;undef&lt;/code&gt; values onto the beginning of the array. The array will grow automatically to accommodate the addition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c8806e91e8b07e1c8c5b623b330c5fc17f1e53" translate="yes" xml:space="preserve">
          <source>Unshifts an SV onto the beginning of the array, creating the array if necessary. A small internal helper function to remove a commonly duplicated idiom.</source>
          <target state="translated">将一个SV移到数组的开头,必要时创建数组。一个小的内部辅助函数,用于删除一个常见的重复成语。</target>
        </trans-unit>
        <trans-unit id="ee9dd9a34e19860a5fcf0a7ebd745fb02d06f995" translate="yes" xml:space="preserve">
          <source>Unsigned long integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned long&lt;/code&gt; . The default typemap for &lt;code&gt;unsigned long&lt;/code&gt; is T_UV.</source>
          <target state="translated">无符号长整数。这等效于T_UV，但显式将返回值强制转换为 &lt;code&gt;unsigned long&lt;/code&gt; 类型。 &lt;code&gt;unsigned long&lt;/code&gt; 的默认类型映射是T_UV。</target>
        </trans-unit>
        <trans-unit id="ced873325d4a96e8ef45785591aba3dcab16744b" translate="yes" xml:space="preserve">
          <source>Unsigned long integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned long&lt;/code&gt;. The default typemap for &lt;code&gt;unsigned long&lt;/code&gt; is T_UV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef145f774c9c40a970f92057ceb7090d079d49a8" translate="yes" xml:space="preserve">
          <source>Unsigned short integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned short&lt;/code&gt; . The default typemap for &lt;code&gt;unsigned short&lt;/code&gt; is T_UV.</source>
          <target state="translated">无符号的短整数。这等效于T_UV，但显式将返回类型强制转换为 &lt;code&gt;unsigned short&lt;/code&gt; 类型。 &lt;code&gt;unsigned short&lt;/code&gt; 的默认类型映射是T_UV。</target>
        </trans-unit>
        <trans-unit id="df6c108aea89772b8a63a9edc5f87c844d4af0f5" translate="yes" xml:space="preserve">
          <source>Unsigned short integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned short&lt;/code&gt;. The default typemap for &lt;code&gt;unsigned short&lt;/code&gt; is T_UV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e913109aa138d1120ee92917139364ad0e62c982" translate="yes" xml:space="preserve">
          <source>Unstable CPAN modules</source>
          <target state="translated">不稳定的CPAN模块</target>
        </trans-unit>
        <trans-unit id="9831cf1a4b45f856ff1bfb0d3f2cad82357c9d2d" translate="yes" xml:space="preserve">
          <source>Unsuccessful %s on filename containing newline</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea66a9b99cf0a2a1cdbce38ec66bd1c5b4a6472f" translate="yes" xml:space="preserve">
          <source>Unsupported directory function &quot;%s&quot; called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f166b32e4b60fa7b2dcb9461bba55e0fc0824b" translate="yes" xml:space="preserve">
          <source>Unsupported encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eef5d64732b0acc7a8ccefeec52120ece754125" translate="yes" xml:space="preserve">
          <source>Unsupported function %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d9503b567ed143ca61aa16b0f7d9ae956dd496" translate="yes" xml:space="preserve">
          <source>Unsupported function fork</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c5497b1a7cb7063234cce74ee916eac2bf6146" translate="yes" xml:space="preserve">
          <source>Unsupported script encoding %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7eb67c38ebe84ebbe543f338c00dda69167f50e" translate="yes" xml:space="preserve">
          <source>Unsupported socket function &quot;%s&quot; called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36af1ae54977c39ffd1ead9641e29d3a83f91f42" translate="yes" xml:space="preserve">
          <source>Untaint an SV. Use &lt;code&gt;SvTAINTED_off&lt;/code&gt; instead.</source>
          <target state="translated">取消SV。请改用 &lt;code&gt;SvTAINTED_off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf2cbcc095493f902db2ae40c30ea409c9c066e5" translate="yes" xml:space="preserve">
          <source>Untaints an SV. Be</source>
          <target state="translated">污染了一个SV。是</target>
        </trans-unit>
        <trans-unit id="c7caa469295aafcb97e51d949546f29d23659089" translate="yes" xml:space="preserve">
          <source>Unterminated</source>
          <target state="translated">Unterminated</target>
        </trans-unit>
        <trans-unit id="61f3c80e76746c97d6708a314163f8c2fd9b4bef" translate="yes" xml:space="preserve">
          <source>Unterminated &amp;lt;&amp;gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e068ea0edf1c7b4de3ae2e55c67d1e8b974e77" translate="yes" xml:space="preserve">
          <source>Unterminated '(*...' argument in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624e8334756d23d133eedf0a6bc6607c292afcbb" translate="yes" xml:space="preserve">
          <source>Unterminated '(*...' construct in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59551fb5498e7f4ecec0f9a669fcc525e52d708" translate="yes" xml:space="preserve">
          <source>Unterminated \g... pattern in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eed8703593e02aeec17f79e274dece7c2582459" translate="yes" xml:space="preserve">
          <source>Unterminated \g{...} pattern in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2cc0e43ab8f9502433f110394b1a21ca55af23" translate="yes" xml:space="preserve">
          <source>Unterminated attribute list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0888b49dc0060324f0f2e9fa27010b029af92a" translate="yes" xml:space="preserve">
          <source>Unterminated attribute parameter in attribute list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b13c5c91a9b07a5b57b3a0636a5913145b68098" translate="yes" xml:space="preserve">
          <source>Unterminated compressed integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2743d41a5029219fd527d8b196fe97e1ab034e0d" translate="yes" xml:space="preserve">
          <source>Unterminated delimiter for here document</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d319b07743736c50cebc71660dfd18cd71390d3" translate="yes" xml:space="preserve">
          <source>Unterminated verb pattern argument in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31df085fb521f1474fc83e47e984ad35a507e50f" translate="yes" xml:space="preserve">
          <source>Unterminated verb pattern in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1c8a6c3311799ae1ea8e9badc636ca33ce5f06" translate="yes" xml:space="preserve">
          <source>Until May 1997, this document was maintained by Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;. It is now maintained as part of Perl itself by the Perl 5 Porters &amp;lt;perl5-porters@perl.org&amp;gt;.</source>
          <target state="translated">直到1997年5月，该文档由Jeff Okamoto维护&amp;lt;okamoto@corp.hp.com&amp;gt;。现在，Perl 5 Porters &amp;lt;perl5-porters@perl.org&amp;gt;将其作为Perl本身的一部分进行维护。</target>
        </trans-unit>
        <trans-unit id="1831403e65413acb20ccb5893a29f9432e4a4a0c" translate="yes" xml:space="preserve">
          <source>Until May 1997, this document was maintained by Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;. It is now maintained as part of Perl itself.</source>
          <target state="translated">直到1997年5月，该文档由Jeff Okamoto维护&amp;lt;okamoto@corp.hp.com&amp;gt;。现在，它已作为Perl本身的一部分进行维护。</target>
        </trans-unit>
        <trans-unit id="c233457d919be5e7a3077c4ecc8aac8f0f4cca07" translate="yes" xml:space="preserve">
          <source>Until Unicode 3.1, it was legal for programs to accept this malformation, but it was discovered that this created security issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9377bbae85c5f3f0ba947e70ca82611c37d8697f" translate="yes" xml:space="preserve">
          <source>Until Unicode 6.1, the 4 control characters U+0080, U+0081, U+0084, and U+0099 did not have names nor aliases. To preserve backwards compatibility, any alias you define for these code points will be returned by this function, in preference to the official name.</source>
          <target state="translated">在Unicode 6.1之前,4个控制字符U+0080、U+0081、U+0084和U+0099没有名称或别名。为了保持向后的兼容性,任何你为这些码点定义的别名都会被这个函数返回,而不是官方名称。</target>
        </trans-unit>
        <trans-unit id="1eb5a9bdac4b575070ceef54e56442cbab9b46a4" translate="yes" xml:space="preserve">
          <source>Until Unicode 7.0, the noncharacters were &quot;&lt;b&gt;forbidden&lt;/b&gt; for use in open interchange of Unicode text data&quot;, so that code that processed those streams could use these code points as sentinels that could be mixed in with character data, and would always be distinguishable from that data. (Emphasis above and in the next paragraph are added in this document.)</source>
          <target state="translated">在Unicode 7.0之前，&amp;ldquo;非字符&lt;b&gt;禁止&lt;/b&gt;在Unicode文本数据的开放式交换中使用&amp;rdquo;，以便处理这些流的代码可以将这些代码点用作可与字符数据混合的标记，并且始终可以与之区别开来。数据。（在本文档的上方和下一个段落中添加了重点。）</target>
        </trans-unit>
        <trans-unit id="cf0c5cc9e7d8c8770f1e88663df8d645526d47b8" translate="yes" xml:space="preserve">
          <source>Until the lexical &lt;code&gt;$_&lt;/code&gt; feature was removed, this function would find the position of the lexical &lt;code&gt;$_&lt;/code&gt; in the pad of the currently-executing function and return the offset in the current pad, or &lt;code&gt;NOT_IN_PAD&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ab20108515e8dd588162df69f6581bf8cbeba9" translate="yes" xml:space="preserve">
          <source>Until then, users are alerted &lt;b&gt;NOT&lt;/b&gt; to rely on the value of &lt;code&gt;$_&lt;/code&gt; remaining unmodified between the outside and the inside of the control block. In particular, the following example is &lt;b&gt;UNSAFE&lt;/b&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e4b4459c9bb0a70e21b5f9e46e887914c2d11b" translate="yes" xml:space="preserve">
          <source>Until version 1.72 of this module, the recommended technique for locking &lt;b&gt;DB_File&lt;/b&gt; databases was to flock the filehandle returned from the &quot;fd&quot; function. Unfortunately this technique has been shown to be fundamentally flawed (Kudos to David Harris for tracking this down). Use it at your own peril!</source>
          <target state="translated">在此模块的1.72版之前，推荐的用于锁定&lt;b&gt;DB_File&lt;/b&gt;数据库的技术是使从&amp;ldquo; fd&amp;rdquo;函数返回的文件句柄聚集。不幸的是，该技术已被证明具有根本的缺陷（David Harris对此表示敬意）。使用它的后果自负！</target>
        </trans-unit>
        <trans-unit id="086839a55d5b993fe1e0e2c06b1920a0c4bb718d" translate="yes" xml:space="preserve">
          <source>Until version 1.88 CPAN.pm never trusted the contents of the build_dir directory between sessions. Since 1.88_58 CPAN.pm has a YAML-based mechanism that makes it possible to share the contents of the build_dir/ directory between different sessions with the same version of perl. People who prefer to test things several days before installing will like this feature because it saves a lot of time.</source>
          <target state="translated">在1.88版本之前,CPAN.pm从来没有信任过不同会话之间的build_dir/目录的内容。从1.88_58版开始,CPAN.pm有了一个基于YAML的机制,使得在使用相同版本perl的不同会话之间可以共享build_dir/目录的内容。那些喜欢在安装前几天测试的人将会喜欢这个功能,因为它节省了很多时间。</target>
        </trans-unit>
        <trans-unit id="3e8ce03700f57426d42c01b15a7e4b29915f11c3" translate="yes" xml:space="preserve">
          <source>Unused. Left in for compatibility with Perl 5.10.0.</source>
          <target state="translated">未使用。为与Perl 5.10.0兼容而保留。</target>
        </trans-unit>
        <trans-unit id="06342bce5c18e1ce2d5790dec4f3e08db46e5f75" translate="yes" xml:space="preserve">
          <source>Unusually, the overloaded implementation of the smart match operator does not get full control of the smart match behaviour. In particular, in the following code:</source>
          <target state="translated">不寻常的是,智能匹配操作符的重载实现并没有得到智能匹配行为的完全控制。特别是,在下面的代码中。</target>
        </trans-unit>
        <trans-unit id="29dacba7bdce44332111c01c6b875e4536599d85" translate="yes" xml:space="preserve">
          <source>Unweaken a reference: Clear the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; remove the backreference to this RV from the array of backreferences associated with the target SV, increment the refcount of the target. Silently ignores &lt;code&gt;undef&lt;/code&gt; and warns on non-weak references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6b69fad267beac964f8da92bb1c2cb8cf51e03" translate="yes" xml:space="preserve">
          <source>Unzipping a complete zip file to disk</source>
          <target state="translated">将一个完整的压缩文件解压缩到磁盘上</target>
        </trans-unit>
        <trans-unit id="3706919ae59d2c2aad143453aa2569b724a8dcba" translate="yes" xml:space="preserve">
          <source>Up to 3.14_05, the switch &lt;b&gt;-v&lt;/b&gt; was used to produce verbose messages of &lt;b&gt;perldoc&lt;/b&gt; operation, which is now enabled by &lt;b&gt;-D&lt;/b&gt;.</source>
          <target state="translated">直到3.14_05，开关&lt;b&gt;-v&lt;/b&gt;用来产生&lt;b&gt;perldoc&lt;/b&gt;操作的详细消息，该消息现在由&lt;b&gt;-D&lt;/b&gt;启用。</target>
        </trans-unit>
        <trans-unit id="ccaf842ca15dd152998644a5cc6be29af2ba5d3b" translate="yes" xml:space="preserve">
          <source>Up to Perl 5.5, opendir() could not autovivify a directory handle from &lt;code&gt;undef&lt;/code&gt;, so using a lexical handle required using a function from &lt;a href=&quot;symbol&quot;&gt;Symbol&lt;/a&gt; to create an anonymous glob, which took a separate step. &lt;code&gt;DirHandle&lt;/code&gt; encapsulates this, which allowed cleaner code than opendir(). Since Perl 5.6, opendir() alone has been all you need for lexical handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37c83dafbe144687e4e64f7705c9303ba945d98" translate="yes" xml:space="preserve">
          <source>Up until Perl 5.18, the actual rules of what a valid identifier was were a bit fuzzy. However, in general, anything defined here should work on previous versions of Perl, while the opposite -- edge cases that work in previous versions, but aren't defined here -- probably won't work on newer versions. As an important side note, please note that the following only applies to bareword identifiers as found in Perl source code, not identifiers introduced through symbolic references, which have much fewer restrictions. If working under the effect of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; pragma, the following rules apply:</source>
          <target state="translated">直到Perl 5.18，有效标识符的实际规则还是有点模糊。但是，一般而言，此处定义的任何内容都应在Perl的早期版本上起作用，而相反的情况（在先前版本中可用但在此未定义的边缘情况）可能不适用于较新版本。作为重要的补充说明，请注意，以下内容仅适用于Perl源代码中的裸字标识符，不适用于通过符号引用引入的标识符，而符号引用的限制要少得多。如果在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; 的作用下工作；编译指示，以下规则适用：</target>
        </trans-unit>
        <trans-unit id="6fc88db01ba5e7a05c82ebb02e9f5bce416f55ca" translate="yes" xml:space="preserve">
          <source>Up until Perl 5.18, the actual rules of what a valid identifier was were a bit fuzzy. However, in general, anything defined here should work on previous versions of Perl, while the opposite -- edge cases that work in previous versions, but aren't defined here -- probably won't work on newer versions. As an important side note, please note that the following only applies to bareword identifiers as found in Perl source code, not identifiers introduced through symbolic references, which have much fewer restrictions. If working under the effect of the &lt;code&gt;use utf8;&lt;/code&gt; pragma, the following rules apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="700db59a01b3167d63908b9389905b718c997451" translate="yes" xml:space="preserve">
          <source>Update the pad compilation state variables on entry to a new block.</source>
          <target state="translated">在进入一个新的块时更新垫子编译状态变量。</target>
        </trans-unit>
        <trans-unit id="8d41ca4ae9515e795255242cbd01a15b9d2f782f" translate="yes" xml:space="preserve">
          <source>Update the running test count during testing.</source>
          <target state="translated">在测试过程中更新运行测试次数。</target>
        </trans-unit>
        <trans-unit id="38f04a1ce254f18542607a5049eadaa5aadd3a16" translate="yes" xml:space="preserve">
          <source>Updated 03 October 2019 for perl-5.32.0+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4df1b22166fed22f195ec39ac5348e1ad4b8f4" translate="yes" xml:space="preserve">
          <source>Updated 12 March 2001 to mention //'SYS1.TCPPARMS(TCPDATA)'.</source>
          <target state="translated">2001年3月12日更新,提到//'SYS1.TCPPARMS(TCPDATA)'。</target>
        </trans-unit>
        <trans-unit id="6a623978ea73cf3eae49fa257cd2b3aa518dc7a5" translate="yes" xml:space="preserve">
          <source>Updated 12 November 2000 for the 5.7.1 release of Perl.</source>
          <target state="translated">2000年11月12日更新为Perl的5.7.1版本。</target>
        </trans-unit>
        <trans-unit id="dd3c1a655a151c3e2de2f2bcc426466b5deb0bf5" translate="yes" xml:space="preserve">
          <source>Updated 15 January 2001 for the 5.7.1 release of Perl.</source>
          <target state="translated">2001年1月15日更新为Perl的5.7.1版本。</target>
        </trans-unit>
        <trans-unit id="5b24aab6b7b4ffb7848dd5c01694221d0200543c" translate="yes" xml:space="preserve">
          <source>Updated 24 January 2001 to mention dynamic loading.</source>
          <target state="translated">2001年1月24日更新,提到动态加载。</target>
        </trans-unit>
        <trans-unit id="555d5c68c249342b429101141b4e668ed9316de1" translate="yes" xml:space="preserve">
          <source>Updated 28 November 2001 for broken URLs.</source>
          <target state="translated">2001年11月28日更新了破损的网址。</target>
        </trans-unit>
        <trans-unit id="e62d7626efdd54a1045fbdd7ab753ad6e883c01e" translate="yes" xml:space="preserve">
          <source>Updated by Kirrily &quot;Skud&quot; Robert, &lt;code&gt;skud@cpan.org&lt;/code&gt;</source>
          <target state="translated">由Kirrily&amp;ldquo; Skud&amp;rdquo; Robert更新，skud @ &lt;code&gt;skud@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d4259d34b695e49901c9de958534f87265a7f80" translate="yes" xml:space="preserve">
          <source>Updated to be autogenerated from comments in the source by Benjamin Stuhl.</source>
          <target state="translated">更新为根据Benjamin Stuhl的评论自动生成。</target>
        </trans-unit>
        <trans-unit id="76fadb0208f83533ce563882faa439aa56b4df27" translate="yes" xml:space="preserve">
          <source>Updates for 5.8.0 by Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;</source>
          <target state="translated">Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt; 5.8.0的更新。</target>
        </trans-unit>
        <trans-unit id="1339cf8af116acbabf9923f4b5f205bd8b4522d5" translate="yes" xml:space="preserve">
          <source>Updates the current digest state by appending bits to it. The return value is the updated object itself.</source>
          <target state="translated">通过添加位来更新当前的摘要状态。返回值是更新后的对象本身。</target>
        </trans-unit>
        <trans-unit id="0f2ec1c28ed80b9544a67d730b3a5ce7a7abddfc" translate="yes" xml:space="preserve">
          <source>Updates to dual-life modules should consist of minimal patches to fix crashing bugs or security issues (as above). Any changes made to dual-life modules for which CPAN is canonical should be coordinated with the upstream author.</source>
          <target state="translated">双生模块的更新应包括最小的补丁,以修复崩溃的错误或安全问题(如上所述)。对CPAN是标准的双寿命模块的任何更改都应与上游作者协调。</target>
        </trans-unit>
        <trans-unit id="6308607dfbe53993e815ce31d09f4ea8e48145b7" translate="yes" xml:space="preserve">
          <source>Updating Apple's Perl</source>
          <target state="translated">更新苹果的Perl</target>
        </trans-unit>
        <trans-unit id="e1215f678a578a0f9348858eb8435faef2c2b2a9" translate="yes" xml:space="preserve">
          <source>Updating perldelta</source>
          <target state="translated">更新perldelta</target>
        </trans-unit>
        <trans-unit id="a93c4eda9c6091f3f69d33443d08d2297a61d678" translate="yes" xml:space="preserve">
          <source>Upgrade all installed modules. Blindly doing this can really break things, so keep a backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9b320c5f351db0fa6eccf0f443242caa105988" translate="yes" xml:space="preserve">
          <source>Upgrade an SV to a more complex form. Generally adds a new body type to the SV, then copies across as much information as possible from the old body. It croaks if the SV is already in a more complex form than requested. You generally want to use the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro wrapper, which checks the type before calling &lt;code&gt;sv_upgrade&lt;/code&gt; , and hence does not croak. See also &lt;code&gt;svtype&lt;/code&gt; .</source>
          <target state="translated">将SV升级为更复杂的形式。通常，向SV添加新的主体类型，然后从旧主体中复制尽可能多的信息。如果SV已经比要求的形式复杂，它就会发出嘶哑的声音。通常，您需要使用 &lt;code&gt;SvUPGRADE&lt;/code&gt; 宏包装程序，该宏包装程序在调用 &lt;code&gt;sv_upgrade&lt;/code&gt; 之前检查类型，因此不会崩溃。另请参见 &lt;code&gt;svtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d51dcaafe87398cb11a10ca76493ca177deff1c" translate="yes" xml:space="preserve">
          <source>Upgrade an SV to a more complex form. Generally adds a new body type to the SV, then copies across as much information as possible from the old body. It croaks if the SV is already in a more complex form than requested. You generally want to use the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro wrapper, which checks the type before calling &lt;code&gt;sv_upgrade&lt;/code&gt;, and hence does not croak. See also &lt;code&gt;&lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add6ead95077aa4159bcce425fd97688bfe672e4" translate="yes" xml:space="preserve">
          <source>Upgrade both sides to unicode-strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9f028e2ed4c8dda78241c1ef169c062efd613f" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. Any arguments necessary for SSL must be given in &lt;code&gt;new&lt;/code&gt; already.</source>
          <target state="translated">将现有的普通连接升级到SSL。SSL必需的所有参数都必须已经在 &lt;code&gt;new&lt;/code&gt; 中给出。</target>
        </trans-unit>
        <trans-unit id="2e297ad00204348f72b48d82b1764d98805e45e0" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. The SSL arguments have to be given in &lt;code&gt;new&lt;/code&gt; already because they are needed for data connections too.</source>
          <target state="translated">将现有的普通连接升级到SSL。SSL参数必须已经在 &lt;code&gt;new&lt;/code&gt; 中给出，因为数据连接也需要它们。</target>
        </trans-unit>
        <trans-unit id="6f973497f8e7a213aaea7ca02f49b6eca9fd3bfc" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. You can use SSL arguments as documented in &lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt;, but it will usually use the right arguments already.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fee598dc67371af303baa6134f7476c80299023" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. You can use SSL arguments as documented in &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt;, but it will usually use the right arguments already.</source>
          <target state="translated">将现有的普通连接升级到SSL。您可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/IO::Socket::SSL&quot;&gt;IO :: Socket :: SSL中&lt;/a&gt;记录的SSL参数，但是通常已经使用了正确的参数。</target>
        </trans-unit>
        <trans-unit id="bd48bfd47491f661502b2059f5ddd29245e2ae65" translate="yes" xml:space="preserve">
          <source>Upgrade the input stream to handle UTF8.</source>
          <target state="translated">升级输入流以处理UTF8。</target>
        </trans-unit>
        <trans-unit id="512167fc556180d756801a5133a4af3eea376b8d" translate="yes" xml:space="preserve">
          <source>Upload the tarball</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd0f1b9998e13b00b78484f1fadbc538035dbb0" translate="yes" xml:space="preserve">
          <source>Upon a successful match, if &lt;code&gt;pe1&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt;, it will be set to point to the beginning of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc1ecb08d6b6e94555b0616aae01977c29165a2" translate="yes" xml:space="preserve">
          <source>Upon a successful match, if &lt;code&gt;pe1&lt;/code&gt; is non-NULL, it will be set to point to the beginning of the</source>
          <target state="translated">匹配成功后，如果 &lt;code&gt;pe1&lt;/code&gt; 为非NULL，它将被设置为指向</target>
        </trans-unit>
        <trans-unit id="d6227a3769b7b8bef00a65fa576f89761ee6446f" translate="yes" xml:space="preserve">
          <source>Upon failure, returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfebf0d8d353544ce7a20fd6b2aa49b84d774da5" translate="yes" xml:space="preserve">
          <source>Upon return from the code that needs to use the global locale, &lt;a href=&quot;perlapi#sync_locale&quot;&gt;&lt;code&gt;sync_locale()&lt;/code&gt;&lt;/a&gt; should be called to restore the safe multi-thread operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9bbd1f38e3f10a7609320917c264db329d774df" translate="yes" xml:space="preserve">
          <source>Upon success, returns an &lt;a href=&quot;ExtUtils::Typemaps&quot;&gt;ExtUtils::Typemaps&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d3d32521b4b97a3ea7146d67bef7d8345970f3" translate="yes" xml:space="preserve">
          <source>Upon success, returns the same string passed as argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a843d4dab6f725af56da9a31e9ee6fb792722a4" translate="yes" xml:space="preserve">
          <source>Upon successful return, the number of variants in the string can be computed by having saved the value of &lt;code&gt;*lenp&lt;/code&gt; before the call, and subtracting it from the after-call value of &lt;code&gt;*lenp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169eb65969db88df1163a98feb823fd7dda92b8b" translate="yes" xml:space="preserve">
          <source>Upon successful return, the number of variants in the string can be computed by having saved the value of &lt;code&gt;*lenp&lt;/code&gt; before the call, and subtracting the after-call value of &lt;code&gt;*lenp&lt;/code&gt; from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7931625de6bea30c3520a42f1b48c8c7ccb1cf73" translate="yes" xml:space="preserve">
          <source>Upon the call, the &lt;code&gt;mg_obj&lt;/code&gt; field will hold the hash key to be accessed. Upon return, the &lt;code&gt;SV*&lt;/code&gt; value in &lt;code&gt;mg_obj&lt;/code&gt; will be used in place of the original key in the hash access. The integer index value in the first parameter will be the &lt;code&gt;action&lt;/code&gt; value from &lt;code&gt;hv_fetch_common&lt;/code&gt; , or -1 if the call is from &lt;code&gt;hv_delete_common&lt;/code&gt; .</source>
          <target state="translated">调用后， &lt;code&gt;mg_obj&lt;/code&gt; 字段将保留要访问的哈希键。返回时，将使用 &lt;code&gt;mg_obj&lt;/code&gt; 中的 &lt;code&gt;SV*&lt;/code&gt; 值代替哈希访问中的原始键。第一个参数中的整数索引值将是来自 &lt;code&gt;hv_fetch_common&lt;/code&gt; 的 &lt;code&gt;action&lt;/code&gt; 值，如果调用来自 &lt;code&gt;hv_delete_common&lt;/code&gt; 则为 -1 。</target>
        </trans-unit>
        <trans-unit id="5908c7f7cc15c0eccf74a3929a4b447274d6a72c" translate="yes" xml:space="preserve">
          <source>Upon the call, the &lt;code&gt;mg_obj&lt;/code&gt; field will hold the hash key to be accessed. Upon return, the &lt;code&gt;SV*&lt;/code&gt; value in &lt;code&gt;mg_obj&lt;/code&gt; will be used in place of the original key in the hash access. The integer index value in the first parameter will be the &lt;code&gt;action&lt;/code&gt; value from &lt;code&gt;hv_fetch_common&lt;/code&gt;, or -1 if the call is from &lt;code&gt;hv_delete_common&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa70849156e04d235d49fdb3686f0245d179ad8d" translate="yes" xml:space="preserve">
          <source>Upon tying a new hash to this package, the developer must specify the size of the keys that will be used, the size of the value fields that the keys will index, and the size of the overall table (in terms of key-value pairs, not size in hard memory).</source>
          <target state="translated">在将一个新的哈希绑定到这个包后,开发者必须指定将使用的键的大小,键将索引的值字段的大小,以及整个表的大小(以键值对为单位,而不是硬内存的大小)。</target>
        </trans-unit>
        <trans-unit id="187b6d106a78abc992df989626da341b4759f5bf" translate="yes" xml:space="preserve">
          <source>Upper/lower case differences in property names and values are irrelevant; thus &lt;code&gt;\p{Upper}&lt;/code&gt; means the same thing as &lt;code&gt;\p{upper}&lt;/code&gt; or even &lt;code&gt;\p{UpPeR}&lt;/code&gt; . Similarly, you can add or subtract underscores anywhere in the middle of a word, so that these are also equivalent to &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt; . And white space is irrelevant adjacent to non-word characters, such as the braces and the equals or colon separators, so &lt;code&gt;\p{ Upper }&lt;/code&gt; and &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; are equivalent to these as well. In fact, white space and even hyphens can usually be added or deleted anywhere. So even &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; is equivalent. All this is called &quot;loose-matching&quot; by Unicode. The few places where stricter matching is used is in the middle of numbers, and in the Perl extension properties that begin or end with an underscore. Stricter matching cares about white space (except adjacent to non-word characters), hyphens, and non-interior underscores.</source>
          <target state="translated">属性名称和值的大小写差异无关紧要；因此 &lt;code&gt;\p{Upper}&lt;/code&gt; 与 &lt;code&gt;\p{upper}&lt;/code&gt; 甚至 &lt;code&gt;\p{UpPeR}&lt;/code&gt; 。同样，您可以在单词中间的任意位置添加或减去下划线，以便它们也等效于 &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt; 。而且与非单词字符（例如大括号和等号或冒号分隔符）相邻的空格无关紧要，因此 &lt;code&gt;\p{ Upper }&lt;/code&gt; 和 &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; 也等同于这些字符。实际上，通常可以在任何地方添加或删除空格甚至连字符。因此，即使 &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; 是等效的。所有这些都被Unicode称为&amp;ldquo;松散匹配&amp;rdquo;。使用更严格匹配的几个地方是数字的中间，以及以下划线开头或结尾的Perl扩展属性。更严格的匹配会关注空格（除了与非单词字符相邻的空格），连字符和非内部下划线。</target>
        </trans-unit>
        <trans-unit id="4660b05f7ff6fc21af46a89123d4d2cc76b34ecd" translate="yes" xml:space="preserve">
          <source>Upper/lower case differences in property names and values are irrelevant; thus &lt;code&gt;\p{Upper}&lt;/code&gt; means the same thing as &lt;code&gt;\p{upper}&lt;/code&gt; or even &lt;code&gt;\p{UpPeR}&lt;/code&gt;. Similarly, you can add or subtract underscores anywhere in the middle of a word, so that these are also equivalent to &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt;. And white space is generally irrelevant adjacent to non-word characters, such as the braces and the equals or colon separators, so &lt;code&gt;\p{ Upper }&lt;/code&gt; and &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; are equivalent to these as well. In fact, white space and even hyphens can usually be added or deleted anywhere. So even &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; is equivalent. All this is called &quot;loose-matching&quot; by Unicode. The &quot;name&quot; property has some restrictions on this due to a few outlier names. Full details are given in &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&quot;&gt;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46cec56f3412b99de640a0bca5cebcfbc4f533b0" translate="yes" xml:space="preserve">
          <source>Urgh. No wonder. There's a big difference between &quot;a null byte&quot;, character zero, and &quot;a space&quot;, character 32. Perl's put something between the date and the description - but unfortunately, we can't see it!</source>
          <target state="translated">呃...难怪。&quot;一个空字节&quot;(字符0)和 &quot;一个空格&quot;(字符32)之间有很大的区别。Perl在日期和描述之间放了一些东西--但不幸的是,我们看不到它!</target>
        </trans-unit>
        <trans-unit id="da969c82ff05cdc8d49e5dc3d47bc17f0b801a39" translate="yes" xml:space="preserve">
          <source>Urgh. Well, it's a bit better, but - well, would you want to maintain that?</source>
          <target state="translated">呃...好吧,这是一个有点好,但-好吧,你想保持这一点?</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="82706ecdf8b404a3d7af76c38e97c34669646ccc" translate="yes" xml:space="preserve">
          <source>Usage Hints for Perl on OS/390</source>
          <target state="translated">OS/390上Perl的使用提示</target>
        </trans-unit>
        <trans-unit id="96115201cdc9d452c0fc7c1a0ccadddf5148529a" translate="yes" xml:space="preserve">
          <source>Usage Hints for Perl on Windows</source>
          <target state="translated">Perl在Windows上的使用提示</target>
        </trans-unit>
        <trans-unit id="73e902d9c6da4a824d1ebe10f64b85e576698ee7" translate="yes" xml:space="preserve">
          <source>Usage is</source>
          <target state="translated">用途是</target>
        </trans-unit>
        <trans-unit id="b4adcf0ec968acb4f04ec349a0b19258b19ca830" translate="yes" xml:space="preserve">
          <source>Usage messages issued as a result of bad command-line syntax should go to &lt;code&gt;STDERR&lt;/code&gt; . However, usage messages issued due to an explicit request to print usage (like specifying &lt;b&gt;-help&lt;/b&gt; on the command line) should go to &lt;code&gt;STDOUT&lt;/code&gt; , just in case the user wants to pipe the output to a pager (such as &lt;b&gt;more(1)&lt;/b&gt;).</source>
          <target state="translated">由于命令行语法错误而发出的用法消息应发送到 &lt;code&gt;STDERR&lt;/code&gt; 。但是，由于显式请求打印用法而发出的用法消息（例如，在命令行上指定&lt;b&gt;-help&lt;/b&gt;）应发送到 &lt;code&gt;STDOUT&lt;/code&gt; ，以防万一用户希望将输出通过管道发送到寻呼机（例如&lt;b&gt;more（1）&lt;/b&gt;）。</target>
        </trans-unit>
        <trans-unit id="41d5df819d19562e6554eaedc6a7c783f798be7b" translate="yes" xml:space="preserve">
          <source>Usage messages issued as a result of bad command-line syntax should go to &lt;code&gt;STDERR&lt;/code&gt;. However, usage messages issued due to an explicit request to print usage (like specifying &lt;b&gt;-help&lt;/b&gt; on the command line) should go to &lt;code&gt;STDOUT&lt;/code&gt;, just in case the user wants to pipe the output to a pager (such as &lt;b&gt;more(1)&lt;/b&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="261136bd75aafd5cdd3130fb700c6549b50d82b1" translate="yes" xml:space="preserve">
          <source>Usage might be something like:</source>
          <target state="translated">用法可能是这样的。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="7e4b7de93d932c1efcbac56adf57dfdace4c1516" translate="yes" xml:space="preserve">
          <source>Usage: POSIX::%s(%s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125a9a7f74a7b0dd6f1033bba99a6fa5c5199974" translate="yes" xml:space="preserve">
          <source>Usage: Win32::%s(%s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d4d43cc6f3a833e0340a0d1794b6d7b9958657e" translate="yes" xml:space="preserve">
          <source>Use</source>
          <target state="translated">Use</target>
        </trans-unit>
        <trans-unit id="4f798ffcb78d5a7f233440bdd6c6128bfc8e6fe0" translate="yes" xml:space="preserve">
          <source>Use &quot;%s&quot; instead of &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82df0013720cd7586b2bc95bd024b2fab925070f" translate="yes" xml:space="preserve">
          <source>Use &quot;opaque&quot; data type for the C types matched by the regular expression, even if these types are &lt;code&gt;typedef&lt;/code&gt; -equivalent to types from typemaps. Should not be used without &lt;b&gt;-x&lt;/b&gt;.</source>
          <target state="translated">对于正则表达式匹配的C类型，请使用&amp;ldquo;不透明&amp;rdquo;数据类型，即使这些类型与typemap 中的 &lt;code&gt;typedef&lt;/code&gt; 是等效的也是如此。不带&lt;b&gt;-x&lt;/b&gt;不应使用。</target>
        </trans-unit>
        <trans-unit id="f821e8c5dcdcc4f25432b67bcb287f73b2058efb" translate="yes" xml:space="preserve">
          <source>Use &quot;opaque&quot; data type for the C types matched by the regular expression, even if these types are &lt;code&gt;typedef&lt;/code&gt;-equivalent to types from typemaps. Should not be used without &lt;b&gt;-x&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c21be167d639b35ddaa57a08912b97d5e9dff41" translate="yes" xml:space="preserve">
          <source>Use &quot;tie&quot; to open the database.</source>
          <target state="translated">使用 &quot;领带 &quot;打开数据库。</target>
        </trans-unit>
        <trans-unit id="446b95fda0c14dcd166b6b7bb8452cd305935a5c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#is_utf8_string_flags&quot;&gt;&quot;is_utf8_string_flags&quot;&lt;/a&gt;, &lt;a href=&quot;#is_utf8_string_loc_flags&quot;&gt;&quot;is_utf8_string_loc_flags&quot;&lt;/a&gt;, and &lt;a href=&quot;#is_utf8_string_loclen_flags&quot;&gt;&quot;is_utf8_string_loclen_flags&quot;&lt;/a&gt; to check entire strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="083bcfc1424d9243fc6a63bfbd611d517b2983c2" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;HTML::Strip&quot;&gt;HTML::Strip&lt;/a&gt;, or &lt;a href=&quot;HTML::FormatText&quot;&gt;HTML::FormatText&lt;/a&gt; which not only removes HTML but also attempts to do a little simple formatting of the resulting plain text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="138b7329a1d9ab9236d2f4b1f41480a59ad859da" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt; if at all possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a1c34e684465d646570e575678d89d88fa6eded" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; (part of the standard Perl distribution):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2859b671be05bd5de57f7f8967124d35c1657098" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="328b2dd567925d497d9e667189af9a036b40b4b4" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; - wisely!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6d07e8046e85c144f5081da5bd8baf9030e3a5" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Strip&quot;&gt;HTML::Strip&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::FormatText&quot;&gt;HTML::FormatText&lt;/a&gt; which not only removes HTML but also attempts to do a little simple formatting of the resulting plain text.</source>
          <target state="translated">使用&lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Strip&quot;&gt;HTML :: Strip&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/HTML::FormatText&quot;&gt;HTML :: FormatText&lt;/a&gt;不仅可以删除HTML，还可以尝试对生成的纯文本进行一些简单的格式化。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
