<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d8b84d36cdfd8993b5da988b0d1072e922c4f772" translate="yes" xml:space="preserve">
          <source>The distribution metadata for a CPAN dist</source>
          <target state="translated">CPAN dist的分发元数据。</target>
        </trans-unit>
        <trans-unit id="36683b868091d21c8930b291476202549c6dcddb" translate="yes" xml:space="preserve">
          <source>The distribution of a bundle should follow the same convention as other distributions.</source>
          <target state="translated">捆绑的分布应遵循与其他分布相同的惯例。</target>
        </trans-unit>
        <trans-unit id="51432e8130a916aea0132035b34ce241b04f9cf8" translate="yes" xml:space="preserve">
          <source>The distroprefs system of &lt;code&gt;CPAN.pm&lt;/code&gt; addresses this problem by allowing the user to specify extra informations and recipes in YAML files to either</source>
          <target state="translated">&lt;code&gt;CPAN.pm&lt;/code&gt; 的distroprefs系统通过允许用户在YAML文件中指定额外的信息和配方来解决此问题，</target>
        </trans-unit>
        <trans-unit id="593a274a7d2141476dcb8b11db34f2f4536141e3" translate="yes" xml:space="preserve">
          <source>The division (/) and the following functions</source>
          <target state="translated">除法(/)和以下功能</target>
        </trans-unit>
        <trans-unit id="863f717363dbe8d220d352a111c6c709f1a560be" translate="yes" xml:space="preserve">
          <source>The djgpp environment for DOS, &lt;a href=&quot;http://www.delorie.com/djgpp/&quot;&gt;http://www.delorie.com/djgpp/&lt;/a&gt; and &lt;a href=&quot;perldos&quot;&gt;perldos&lt;/a&gt;.</source>
          <target state="translated">DOS的djgpp环境，&lt;a href=&quot;http://www.delorie.com/djgpp/&quot;&gt;http://www.delorie.com/djgpp/&lt;/a&gt;和&lt;a href=&quot;perldos&quot;&gt;perldos&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02d01132aeec36ca260315fce03b39bb29168535" translate="yes" xml:space="preserve">
          <source>The do-or-die equivalents are set up simply by calling Fatal's &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; routine, passing it the names of the functions to be replaced. You may wrap both user-defined functions and overridable CORE operators (except &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, or any other built-in that cannot be expressed via prototypes) in this way.</source>
          <target state="translated">只需通过调用Fatal的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 例程，并为其传递要替换的函数的名称，即可设置do-die的等效项。您可以通过这种方式包装用户定义的函数和可重写的CORE运算符（ &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 或任何其他无法通过原型表示的内置函数除外）。</target>
        </trans-unit>
        <trans-unit id="467707c3656000f994482e7ea5cafe87685ee6c8" translate="yes" xml:space="preserve">
          <source>The documentation for the Perl API explains what some of the internal functions do, as well as the many macros used in the source.</source>
          <target state="translated">Perl API 的文档解释了一些内部函数的作用,以及源代码中使用的许多宏。</target>
        </trans-unit>
        <trans-unit id="fae102196b6b483518d27e0d97d3595cd35f7b66" translate="yes" xml:space="preserve">
          <source>The dot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f38f6b4980cd9d2e94100bc5fdda9f827f655ac" translate="yes" xml:space="preserve">
          <source>The dot (or period), &lt;code&gt;.&lt;/code&gt; is probably the most used, and certainly the most well-known character class. By default, a dot matches any character, except for the newline. That default can be changed to add matching the newline by using the</source>
          <target state="translated">点（或点） &lt;code&gt;.&lt;/code&gt; 是最常用的字符类，当然也是最著名的字符类。默认情况下，点与任何字符匹配，除了换行符。可以更改默认值，以使用来添加匹配的换行符</target>
        </trans-unit>
        <trans-unit id="a8d050074e0d8db225e0ced36924986b2d59e591" translate="yes" xml:space="preserve">
          <source>The dynamic nature of the regular expression variables means that their value is limited to the block that they are in, as demonstrated by this bit of code:</source>
          <target state="translated">正则表达式变量的动态性质意味着它们的值被限制在它们所在的块中,正如这段代码所示。</target>
        </trans-unit>
        <trans-unit id="4214b1d60eaaef0d8bb7337abe8a20ad57121d02" translate="yes" xml:space="preserve">
          <source>The earliest development of &lt;code&gt;newgetopt.pl&lt;/code&gt; started in 1990, with Perl version 4. As a result, its development, and the development of Getopt::Long, has gone through several stages. Since backward compatibility has always been extremely important, the current version of Getopt::Long still supports a lot of constructs that nowadays are no longer necessary or otherwise unwanted. This section describes briefly some of these 'features'.</source>
          <target state="translated">&lt;code&gt;newgetopt.pl&lt;/code&gt; 的最早开发始于1990年，当时是Perl版本4。因此，它的开发以及Getopt :: Long的开发经历了多个阶段。由于向后兼容性一直非常重要，因此，当前版本的Getopt :: Long仍然支持许多如今不再需要或不需要的构造。本节简要介绍其中一些&amp;ldquo;功能&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a629fbdcc51d0664a749c16709dba8d145f34d93" translate="yes" xml:space="preserve">
          <source>The easier it is to reproduce your bug, the more likely it will be fixed -- if nobody can duplicate your problem, it probably won't be addressed.</source>
          <target state="translated">越容易重现你的bug,它就越有可能被修复--如果没有人能够复制你的问题,它可能不会被解决。</target>
        </trans-unit>
        <trans-unit id="a0f603eb4b75174f5f5f8c92980d04d40846be1f" translate="yes" xml:space="preserve">
          <source>The easier it is to understand a reproducible bug, the more likely it will be fixed. Any insight you can provide into the problem will help a great deal. In other words, try to analyze the problem (to the extent you can) and report your discoveries.</source>
          <target state="translated">越容易理解一个可重现的bug,它就越有可能被修复。你能提供的任何关于问题的见解都会有很大的帮助。换句话说,尝试分析问题(在你能做到的范围内)并报告你的发现。</target>
        </trans-unit>
        <trans-unit id="affd4579291392539b898984b2d64fdfbc46e13c" translate="yes" xml:space="preserve">
          <source>The easiest and most portable option available for creating your own source filter is to write it completely in Perl. To distinguish this from the previous two techniques, I'll call it a Perl source filter.</source>
          <target state="translated">要创建自己的源码过滤器,最简单、最便携的选择是完全用Perl编写。为了区别于前面两种技术,我将其称为Perl源码过滤器。</target>
        </trans-unit>
        <trans-unit id="74aa13205a264868ad41eb543a1a088589f0736a" translate="yes" xml:space="preserve">
          <source>The easiest conceptual solution is to count the lines in the file then start at the beginning and print the number of lines (minus the last N) to a new file.</source>
          <target state="translated">最简单的概念性解决方案是计算文件中的行数,然后从头开始,将行数(减去最后的N行)打印到一个新文件中。</target>
        </trans-unit>
        <trans-unit id="06308af6d2242e4fa49dd6cd28115c9993df529e" translate="yes" xml:space="preserve">
          <source>The easiest way is to have a module also named CPAN do it for you by using the &lt;code&gt;cpan&lt;/code&gt; command that comes with Perl. You can give it a list of modules to install:</source>
          <target state="translated">最简单的方法是使用Perl随附的 &lt;code&gt;cpan&lt;/code&gt; 命令让一个也名为CPAN的模块为您完成此操作。您可以为其提供要安装的模块列表：</target>
        </trans-unit>
        <trans-unit id="50ecd0af899536563eb76ce8a93b28def2b41789" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to read a key in nonblocking mode with the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, passing it an argument of -1 to indicate not to block:</source>
          <target state="translated">最简单的方法是使用CPAN 的&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt;模块以非阻塞模式读取密钥，并向其传递参数-1表示不阻塞：</target>
        </trans-unit>
        <trans-unit id="8ab82d3c686ea0162144c8d6cfd2e56593a5e530" translate="yes" xml:space="preserve">
          <source>The easiest way to examine the op tree is to stop Perl after it has finished parsing, and get it to dump out the tree. This is exactly what the compiler backends &lt;a href=&quot;b/terse&quot;&gt;B::Terse&lt;/a&gt;, &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt; and &lt;a href=&quot;b/debug&quot;&gt;B::Debug&lt;/a&gt; do.</source>
          <target state="translated">检查op树的最简单方法是在完成解析后停止Perl，然后将其转储到树中。这正是编译器后端&lt;a href=&quot;b/terse&quot;&gt;B :: Terse&lt;/a&gt;，&lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt;和&lt;a href=&quot;b/debug&quot;&gt;B :: Debug&lt;/a&gt;所做的工作。</target>
        </trans-unit>
        <trans-unit id="e420b4167196d87c0672e2ec36244ffaaeacf17d" translate="yes" xml:space="preserve">
          <source>The easiest way to get a template set of macros to use is by specifying the &lt;code&gt;-g&lt;/code&gt; (&lt;code&gt;--global&lt;/code&gt; ) option with h2xs (see &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;).</source>
          <target state="translated">获取要使用的宏的模板集的最简单方法是通过在h2xs中指定 &lt;code&gt;-g&lt;/code&gt; （-- &lt;code&gt;--global&lt;/code&gt; ）选项（请参阅&lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="40c9c21dcd497445970db52d8583cffea3bdb68e" translate="yes" xml:space="preserve">
          <source>The easiest way to specify an individual typable character is to enclose it in brackets:</source>
          <target state="translated">指定单个可输入字符的最简单方法是用括号将其括起来。</target>
        </trans-unit>
        <trans-unit id="61b4571e42b1eb8646fcc517dc4040a5571233f2" translate="yes" xml:space="preserve">
          <source>The easiest way to tell if a subroutine was inlined is by using &lt;a href=&quot;b/deparse&quot;&gt;B::Deparse&lt;/a&gt;. Consider this example of two subroutines returning &lt;code&gt;1&lt;/code&gt; , one with a &lt;code&gt;()&lt;/code&gt; prototype causing it to be inlined, and one without (with deparse output truncated for clarity):</source>
          <target state="translated">判断是否已内联子例程的最简单方法是使用&lt;a href=&quot;b/deparse&quot;&gt;B :: Deparse&lt;/a&gt;。考虑下面的示例，其中有两个子例程返回 &lt;code&gt;1&lt;/code&gt; ，一个子例程带有 &lt;code&gt;()&lt;/code&gt; 原型使其内联，而另一个子例程没有返回（为清楚起见，删节输出被截断）：</target>
        </trans-unit>
        <trans-unit id="1861cd9be51843a146c51b85f741a8d483f14173" translate="yes" xml:space="preserve">
          <source>The easy answer is &quot;Don't do that!&quot;</source>
          <target state="translated">简单的答案是 &quot;不要这样做!&quot;</target>
        </trans-unit>
        <trans-unit id="0597cca28cb7230a0e356c17782e46be9384f5c8" translate="yes" xml:space="preserve">
          <source>The effect of using &quot;failure_auto_handler&quot; is like an AUTO lexicon, except that it 1) compiles $key even if it starts with &quot;_&quot;, and 2) you have a record in the new hashref $lh-&amp;gt;{'failure_lex'} of all the keys that have failed for this object. This should avoid your program dying -- as long as your keys aren't actually invalid as bracket code, and as long as they don't try calling methods that don't exist.</source>
          <target state="translated">使用&amp;ldquo; failure_auto_handler&amp;rdquo;的效果就像一个AUTO词典，除了它1）即使以&amp;ldquo; _&amp;rdquo;开头也编译$ key，并且2）您在新的hashref $ lh-&amp;gt; {'failure_lex'}中有一条记录。该对象失败的所有键中的一个。这应该避免您的程序死亡-只要您的键实际上不作为方括号代码无效，并且只要它们不尝试调用不存在的方法即可。</target>
        </trans-unit>
        <trans-unit id="e111bef16ba68c39a0b6040a000b635141c8f1f2" translate="yes" xml:space="preserve">
          <source>The effective gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getegid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">这个过程的有效指导。如果您使用的机器同时支持多个组的成员资格，请提供一个空格，分隔您所在的组的列表。第一个数字是 &lt;code&gt;getegid()&lt;/code&gt; 返回的数字，随后的是 &lt;code&gt;getgroups()&lt;/code&gt; 返回的数字，其中一个可能是与第一个数字相同。</target>
        </trans-unit>
        <trans-unit id="391c814eb86428160d8ecfb1e5d99a0a23856f18" translate="yes" xml:space="preserve">
          <source>The effective uid of this process. For example:</source>
          <target state="translated">这个过程的有效uid。例如:</target>
        </trans-unit>
        <trans-unit id="78e522cbb08752f888e4a4c422be723520118862" translate="yes" xml:space="preserve">
          <source>The element &lt;code&gt;$ENV{DEFAULT}&lt;/code&gt; is special: when read, it returns Perl's current default device and directory, and when set, it resets them, regardless of the definition of</source>
          <target state="translated">元素 &lt;code&gt;$ENV{DEFAULT}&lt;/code&gt; 是特殊的：读取时，它将返回Perl的当前默认设备和目录，并且在设置时，它将重置它们，而不管其定义如何。</target>
        </trans-unit>
        <trans-unit id="1927e85810982ff4bedcbd8fe6ac46c4f4acfd36" translate="yes" xml:space="preserve">
          <source>The element is a hash, initialized by default to &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">该元素是一个哈希，默认情况下初始化为 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="010155a37e502b613f4bf666146b070b50ac9cf2" translate="yes" xml:space="preserve">
          <source>The element is a scalar, and by default is initialized to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (but see &lt;a href=&quot;#Initializing-with-new&quot;&gt;Initializing with new&lt;/a&gt;).</source>
          <target state="translated">元素是一个标量，默认情况下被初始化为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （但请参见&lt;a href=&quot;#Initializing-with-new&quot;&gt;使用new初始化&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7c7fe592a2def98474e3260c74013058ff355fc6" translate="yes" xml:space="preserve">
          <source>The element is an array, initialized by default to &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">元素是一个数组，默认情况下初始化为 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="942bdb865668cc5d25526303c780ec9824d73845" translate="yes" xml:space="preserve">
          <source>The element's value must be a reference blessed to the named class or to one of its subclasses. The element is not initialized by default.</source>
          <target state="translated">元素的值必须是对指定类或其子类的引用。该元素默认不初始化。</target>
        </trans-unit>
        <trans-unit id="cfb20ee6aa799cc8c00cade7ca9b921cb0624824" translate="yes" xml:space="preserve">
          <source>The elements we're getting from the array start with a &lt;code&gt;$&lt;/code&gt; because we're getting just a single value out of the array; you ask for a scalar, you get a scalar.</source>
          <target state="translated">我们从数组中获取的元素以 &lt;code&gt;$&lt;/code&gt; 开头，因为我们从数组中获取的只是一个值；你要求一个标量，你得到一个标量。</target>
        </trans-unit>
        <trans-unit id="c2d2a5272ddb492896f4b1aa2fdc89f7d8b57cf1" translate="yes" xml:space="preserve">
          <source>The elliptical statement cannot stand in for an expression that is part of a larger statement, since the &lt;code&gt;...&lt;/code&gt; is also the three-dot version of the flip-flop operator (see &lt;a href=&quot;perlop#Range-Operators&quot;&gt;Range Operators in perlop&lt;/a&gt;).</source>
          <target state="translated">椭圆语句不能代表较大语句的一部分，因为 &lt;code&gt;...&lt;/code&gt; 也是触发器运算&lt;a href=&quot;perlop#Range-Operators&quot;&gt;符的三点形式&lt;/a&gt;（请参见perlop中的Range运算符）。</target>
        </trans-unit>
        <trans-unit id="545891d79255fc3bc69760f930c3f25bc8ae8965" translate="yes" xml:space="preserve">
          <source>The email you got when you received your CPAN ID will tell you how to log in to PAUSE, the Perl Authors Upload SErver. From the menus there, you can upload your module to CPAN.</source>
          <target state="translated">当您收到 CPAN ID 时,您收到的邮件会告诉您如何登录 PAUSE,即 Perl Authors Upload SErver。从那里的菜单中,你可以将你的模块上传到 CPAN。</target>
        </trans-unit>
        <trans-unit id="588a9b522600848c7a034e730acfdc94a0b61885" translate="yes" xml:space="preserve">
          <source>The encoding is assumed to be an Encode object, on entry the PV of the sv is assumed to be octets in that encoding, and the sv will be converted into Unicode (and UTF-8).</source>
          <target state="translated">编码被假定为Encode对象,输入时sv的PV被假定为该编码的八位数,sv将被转换为Unicode(和UTF-8)。</target>
        </trans-unit>
        <trans-unit id="2aac7e4350e18d454240d654ed5501855f5c3e7e" translate="yes" xml:space="preserve">
          <source>The encoding is assumed to be an Encode object, the PV of the ssv is assumed to be octets in that encoding and decoding the input starts from the position which (PV + *offset) pointed to. The dsv will be concatenated the decoded UTF-8 string from ssv. Decoding will terminate when the string tstr appears in decoding output or the input ends on the PV of the ssv. The value which the offset points will be modified to the last input position on the ssv.</source>
          <target state="translated">编码被假定为Encode对象,ssv的PV被假定为该编码的八位数,并从(PV+*offset)指向的位置开始解码输入。dsv将从ssv解码后的UTF-8字符串连接起来。当解码输出中出现字符串tstr或输入在ssv的PV上结束时,解码将终止。偏移量所指向的值将被修改为ssv的最后输入位置。</target>
        </trans-unit>
        <trans-unit id="d3062423073ff3110a760ac5983fd2a737512781" translate="yes" xml:space="preserve">
          <source>The encoding pragma is not supported on EBCDIC platforms.</source>
          <target state="translated">EBCDIC平台不支持编码原则。</target>
        </trans-unit>
        <trans-unit id="04abf26a5ca58977d603141fc0ef79876490369d" translate="yes" xml:space="preserve">
          <source>The encoding requested is not supported by the Encode module.</source>
          <target state="translated">Encode模块不支持要求的编码。</target>
        </trans-unit>
        <trans-unit id="39b0be99c7e0fde92c59a2dde4b75bd2c5e6a66a" translate="yes" xml:space="preserve">
          <source>The encodings of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; are individually settable by parameters to the pragma:</source>
          <target state="translated">&lt;code&gt;STDIN&lt;/code&gt; 和 &lt;code&gt;STDOUT&lt;/code&gt; 的编码可分别通过编译指示参数设置：</target>
        </trans-unit>
        <trans-unit id="0d58ea5991c657606e31a1ebddfdcbdfe42b5a94" translate="yes" xml:space="preserve">
          <source>The end result of all this is a list of pairs of filenames. By default that is what is returned by &lt;code&gt;globmap&lt;/code&gt; . In this example the data structure returned will look like this</source>
          <target state="translated">所有这些的最终结果是文件名对列表。默认情况下，就是 &lt;code&gt;globmap&lt;/code&gt; 返回的内容。在此示例中，返回的数据结构将如下所示</target>
        </trans-unit>
        <trans-unit id="733a0f46f2e4433da326d8b3d8649ddcec9e6f67" translate="yes" xml:space="preserve">
          <source>The engine implementing pack() Perl function.</source>
          <target state="translated">实现pack()Perl函数的引擎。</target>
        </trans-unit>
        <trans-unit id="3347858c5b43f539e0e1c803ce10b0c1e284b3a5" translate="yes" xml:space="preserve">
          <source>The engine implementing pack() Perl function. Note: parameters next_in_list and flags are not used. This call should not be used; use packlist instead.</source>
          <target state="translated">实现pack()Perl函数的引擎。注意:没有使用参数 next_in_list 和 flags。这个调用不应该被使用,而应该使用packlist。</target>
        </trans-unit>
        <trans-unit id="5023a760442586ad60fa18e526984ee22ee1b465" translate="yes" xml:space="preserve">
          <source>The engine implementing the unpack() Perl function.</source>
          <target state="translated">实现unpack()Perl函数的引擎。</target>
        </trans-unit>
        <trans-unit id="23836ad0aab663b81186836eab5aaaa304905073" translate="yes" xml:space="preserve">
          <source>The engine implementing unpack() Perl function. Note: parameters strbeg, new_s and ocnt are not used. This call should not be used, use unpackstring instead.</source>
          <target state="translated">实现unpack()Perl函数的引擎。注意:没有使用参数 strbeg、new_s 和 ocnt。这个调用不应该被使用,而应该使用unpackstring。</target>
        </trans-unit>
        <trans-unit id="d9382e3775d5db72bf3f9d8d46eb30460f658e51" translate="yes" xml:space="preserve">
          <source>The engine's private copy of the flags the pattern was compiled with. Usually this is the same as &lt;code&gt;extflags&lt;/code&gt; unless the engine chose to modify one of them.</source>
          <target state="translated">编译模式的标志的引擎的专用副本。通常，这与 &lt;code&gt;extflags&lt;/code&gt; 相同，除非引擎选择修改其中之一。</target>
        </trans-unit>
        <trans-unit id="7e628a3e380b1bb720e0473c9d50225fb2d2a7bf" translate="yes" xml:space="preserve">
          <source>The entire getaddrinfo() subsystem can be exported using the tag &lt;code&gt;:addrinfo&lt;/code&gt; ; this exports the getaddrinfo() and getnameinfo() functions, and all the &lt;code&gt;AI_*&lt;/code&gt; , &lt;code&gt;NI_*&lt;/code&gt; , &lt;code&gt;NIx_*&lt;/code&gt; and &lt;code&gt;EAI_*&lt;/code&gt; constants.</source>
          <target state="translated">可以使用标签 &lt;code&gt;:addrinfo&lt;/code&gt; 导出整个getaddrinfo（）子系统；这将导出getaddrinfo（）和getnameinfo（）函数，以及所有 &lt;code&gt;AI_*&lt;/code&gt; ， &lt;code&gt;NI_*&lt;/code&gt; ， &lt;code&gt;NIx_*&lt;/code&gt; 和 &lt;code&gt;EAI_*&lt;/code&gt; 常量。</target>
        </trans-unit>
        <trans-unit id="425561102978b28bf5fcfefe3513eb2739c2c06d" translate="yes" xml:space="preserve">
          <source>The entire hardware and software context in which a program runs. A program written in a platform-dependent language might break if you change any of the following: machine, operating system, libraries, compiler, or system configuration. The</source>
          <target state="translated">程序运行的整个硬件和软件环境。如果你改变了以下任何一项:机器、操作系统、库、编译器或系统配置,一个用平台依赖性语言编写的程序可能会崩溃。在这里,我想说的是,如果你改变了以下任何一个因素,那么用平台依赖型语言编写的程序可能会崩溃:机器、操作系统、库、编译器或系统配置。</target>
        </trans-unit>
        <trans-unit id="062ee9dd6945c627c0db8805ff34b8bebe56650f" translate="yes" xml:space="preserve">
          <source>The entire upgrading/downgrading is still experimental and might not work as you expect or may even have bugs. You might get errors like this:</source>
          <target state="translated">整个升级/降级仍是实验性的,可能无法按照你的预期工作,甚至可能有bug。你可能会得到这样的错误。</target>
        </trans-unit>
        <trans-unit id="5e462b82c7819411d2795ec13fd404d6485cf8ac" translate="yes" xml:space="preserve">
          <source>The environment is not automatically made available as separate scalar variables.</source>
          <target state="translated">环境不会自动作为单独的标量变量提供。</target>
        </trans-unit>
        <trans-unit id="4a714b26cc76c6e720a2c1944b7c3273669f5c69" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PERL_RL&lt;/code&gt; governs which ReadLine clone is loaded. If the value is false, a dummy interface is used. If the value is true, it should be tail of the name of the package to use, such as &lt;code&gt;Perl&lt;/code&gt; or &lt;code&gt;Gnu&lt;/code&gt; .</source>
          <target state="translated">环境变量 &lt;code&gt;PERL_RL&lt;/code&gt; 控制着加载哪个ReadLine克隆。如果该值为false，则使用虚拟接口。如果值为true，则应为要使用的软件包名称的 &lt;code&gt;Gnu&lt;/code&gt; ，例如 &lt;code&gt;Perl&lt;/code&gt; 或Gnu。</target>
        </trans-unit>
        <trans-unit id="17c8987c252d8945d5eef3157bdde1da3d4677a3" translate="yes" xml:space="preserve">
          <source>The error function [C99].</source>
          <target state="translated">误差函数[C99]。</target>
        </trans-unit>
        <trans-unit id="c03bfb5951202558a79d3146a129bcd7599c5997" translate="yes" xml:space="preserve">
          <source>The error level, should be 'WARNING' or 'ERROR'.</source>
          <target state="translated">错误级别,应该是 &quot;WARNING &quot;或 &quot;ERROR&quot;。</target>
        </trans-unit>
        <trans-unit id="489643f4ea640ba730461cfbd32bed09509bae25" translate="yes" xml:space="preserve">
          <source>The error message or object will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak_sv&lt;/code&gt; function never returns normally.</source>
          <target state="translated">错误消息或对象将用作异常，默认情况下将控制权返回到最近的封闭 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，但可能会被 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 处理程序进行修改。无论如何， &lt;code&gt;croak_sv&lt;/code&gt; 函数永远不会正常返回。</target>
        </trans-unit>
        <trans-unit id="664a7836db566d6a3f4c07aec582c78faf8e8984" translate="yes" xml:space="preserve">
          <source>The error message or object will by default be written to standard error, but this is subject to modification by a &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handler.</source>
          <target state="translated">默认情况下，错误消息或对象将被写入标准错误，但这可以通过 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 处理程序进行修改。</target>
        </trans-unit>
        <trans-unit id="b67bc4e2f3fe19fc43d4ef72e9869cbd0c9674e2" translate="yes" xml:space="preserve">
          <source>The error message will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak&lt;/code&gt; function never returns normally.</source>
          <target state="translated">错误消息将用作异常，默认情况下会将控制权返回到最近的封闭 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，但可能会被 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 处理程序进行修改。无论如何， &lt;code&gt;croak&lt;/code&gt; 函数永远不会正常返回。</target>
        </trans-unit>
        <trans-unit id="900d77a6d61d64e8af52decba69cafd8be937ac1" translate="yes" xml:space="preserve">
          <source>The error number returned by a &lt;b&gt;syscall&lt;/b&gt; when it fails. Perl refers to the error by the name &lt;code&gt;$!&lt;/code&gt; (or &lt;code&gt;$OS_ERROR&lt;/code&gt; if you use the English module).</source>
          <target state="translated">失败时由&lt;b&gt;系统调用&lt;/b&gt;返回的错误号。Perl用 &lt;code&gt;$!&lt;/code&gt; 来指代错误。（如果使用英文模块， &lt;code&gt;$OS_ERROR&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="953076d4b6c381c0ffffe4399cd4fbc39f8ceb23" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. If no error occurred it will be zero numerically and an empty string.</source>
          <target state="translated">错误值将为对偶变量；可与 &lt;code&gt;EI_*&lt;/code&gt; 错误常量相比较，或可打印为人类可读的错误消息字符串。如果未发生错误，则数字将为零，并且为空字符串。</target>
        </trans-unit>
        <trans-unit id="4f48137cede1f63ecf865be7641415458ec370ab" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. The host and service names will be plain strings.</source>
          <target state="translated">错误值将为对偶变量；可与 &lt;code&gt;EI_*&lt;/code&gt; 错误常量相比较，或可打印为人类可读的错误消息字符串。主机名和服务名将为纯字符串。</target>
        </trans-unit>
        <trans-unit id="7d1c1519bb36749c3cad434bbe27ce9cca770380" translate="yes" xml:space="preserve">
          <source>The evaluation modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; wraps an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{...}&lt;/a&gt;&lt;/code&gt; around the replacement string and the evaluated result is substituted for the matched substring. Some examples:</source>
          <target state="translated">评估修饰符 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{...}&lt;/a&gt;&lt;/code&gt; 包裹在替换字符串周围，并将评估结果替换为匹配的子字符串。一些例子：</target>
        </trans-unit>
        <trans-unit id="b4c657becf62f17dba34f2c0a7892b03eec9664a" translate="yes" xml:space="preserve">
          <source>The exact implementation of this macro varies by architecture and version of perl, and the return value may change per invocation, so the value is only valid for the duration of a single perl process.</source>
          <target state="translated">这个宏的具体实现因perl的架构和版本不同而不同,而且每次调用的返回值可能会改变,所以这个值只对单个perl进程的持续时间有效。</target>
        </trans-unit>
        <trans-unit id="77f569ab2ca56d55a753f65526e499d75cae3e5d" translate="yes" xml:space="preserve">
          <source>The exact line number may vary, but if the warning (W) comes from a line line this</source>
          <target state="translated">确切的行号可能会有所不同,但如果警告(W)来自于一行行的行号,这个</target>
        </trans-unit>
        <trans-unit id="995bdcd8d207fa374f9f43b6e279df6bd565026b" translate="yes" xml:space="preserve">
          <source>The exact line numbers may vary between Perl releases. The warnings are benign and can be ignored: in later C compiler releases the warnings should be gone.</source>
          <target state="translated">确切的行数在不同的Perl版本中可能会有所不同。这些警告是良性的,可以忽略:在以后的 C 编译版本中,这些警告应该会消失。</target>
        </trans-unit>
        <trans-unit id="44fc79e864b1257675cf101f1f7fd3a57bf639a9" translate="yes" xml:space="preserve">
          <source>The exact manner in which the address is returned in $symref is not currently defined. The only initial requirement is that $symref can be passed to, and understood by, dl_install_xsub().</source>
          <target state="translated">$symref中返回地址的具体方式目前还没有定义。唯一的初始要求是$symref可以传递给dl_install_xsub()并被其理解。</target>
        </trans-unit>
        <trans-unit id="e70c2ef4d5d588ebbe05350bafa35fc8f80a6a1c" translate="yes" xml:space="preserve">
          <source>The exact meaning of the $gcos field varies but it usually contains the real name of the user (as opposed to the login name) and other information pertaining to the user. Beware, however, that in many system users are able to change this information and therefore it cannot be trusted and therefore the $gcos is tainted (see &lt;a href=&quot;../perlsec&quot;&gt;perlsec&lt;/a&gt;). The $passwd and $shell, user's encrypted password and login shell, are also tainted, for the same reason.</source>
          <target state="translated">$ gcos字段的确切含义有所不同，但是它通常包含用户的真实姓名（与登录名相对）以及与该用户有关的其他信息。但是请注意，在许多系统中，用户都可以更改此信息，因此该信息不能被信任，因此$ gcos受到污染（请参阅&lt;a href=&quot;../perlsec&quot;&gt;perlsec&lt;/a&gt;）。由于相同的原因，用户的加密密码和登录外壳$ passwd和$ shell也被污染。</target>
        </trans-unit>
        <trans-unit id="d7d6887be4411b65036ddda7abbe1d73b16c3d9f" translate="yes" xml:space="preserve">
          <source>The exact meaning of the $gcos field varies but it usually contains the real name of the user (as opposed to the login name) and other information pertaining to the user. Beware, however, that in many system users are able to change this information and therefore it cannot be trusted and therefore the $gcos is tainted (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). The $passwd and $shell, user's encrypted password and login shell, are also tainted, for the same reason.</source>
          <target state="translated">$ gcos字段的确切含义有所不同，但是它通常包含用户的真实姓名（与登录名相对）以及与该用户有关的其他信息。但是请注意，在许多系统中，用户都可以更改此信息，因此该信息不能被信任，因此$ gcos受到污染（请参阅&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;）。由于相同的原因，用户的加密密码和登录外壳$ passwd和$ shell也被污染。</target>
        </trans-unit>
        <trans-unit id="6462c6eed55545498a4b1274ffec108a59806854" translate="yes" xml:space="preserve">
          <source>The exact rules for how often (??{}) and (?{}) are executed in a pattern are unspecified. In the case of a successful match you can assume that they DWIM and will be executed in left to right order the appropriate number of times in the accepting path of the pattern as would any other meta-pattern. How non-accepting pathways and match failures affect the number of times a pattern is executed is specifically unspecified and may vary depending on what optimizations can be applied to the pattern and is likely to change from version to version.</source>
          <target state="translated">模式中(??{})和(?{})被执行的频率的确切规则是没有规定的。在匹配成功的情况下,你可以假设它们DWIM,并将在模式的接受路径中按照从左到右的顺序执行适当的次数,就像任何其他元模式一样。非接受路径和匹配失败如何影响模式的执行次数是具体未说明的,可能会根据模式可以应用的优化而变化,并且很可能在不同版本之间发生变化。</target>
        </trans-unit>
        <trans-unit id="b7beaad311b9cd2e0a10bf6f8d5a018e83ebb91c" translate="yes" xml:space="preserve">
          <source>The exact same effect could, incidentally, be achieved with a single &quot;=for&quot; paragraph:</source>
          <target state="translated">顺便说一句,用一个&quot;=for &quot;段也可以达到完全相同的效果。</target>
        </trans-unit>
        <trans-unit id="61acc8b78f6506711798cda20b87d0c0557e6d78" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;../fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE和ATTRS的确切语义和接口仍在不断发展。 TYPE当前绑定到 &lt;code&gt;fields&lt;/code&gt; pragma 的使用，并且使用 &lt;code&gt;attributes&lt;/code&gt; pragma 来处理属性，或者从Perl 5.8.0开始，也可以通过 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 模块来处理属性。有关详细信息以及&lt;a href=&quot;../fields&quot;&gt;字段&lt;/a&gt;，&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;和&lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute :: Handlers的&lt;/a&gt;信息，请参见&lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;perlsub中的my（）的私有变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90e321854a7d357a33050984753578010a7cc972" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE和ATTRS的确切语义和接口仍在不断发展。 TYPE当前绑定到 &lt;code&gt;fields&lt;/code&gt; pragma 的使用，并且使用 &lt;code&gt;attributes&lt;/code&gt; pragma 来处理属性，或者从Perl 5.8.0开始，也可以通过 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 模块来处理属性。有关详细信息以及&lt;a href=&quot;fields&quot;&gt;字段&lt;/a&gt;，&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;和&lt;a href=&quot;attribute/handlers&quot;&gt;Attribute :: Handlers的&lt;/a&gt;信息，请参见&lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;perlsub中的my（）的私有变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a2c046e7769f3ecfcaed8dd98a806a8be83eb888" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , or &lt;code&gt;__PACKAGE__&lt;/code&gt; . It is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or starting from Perl 5.8.0 also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE和ATTRS的确切语义和接口仍在不断发展。 TYPE可以是一个空词， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; 声明的常量或 &lt;code&gt;__PACKAGE__&lt;/code&gt; 。当前它绑定到 &lt;code&gt;fields&lt;/code&gt; pragma 的使用，并且使用 &lt;code&gt;attributes&lt;/code&gt; pragma 处理属性，或者也可以通过 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 模块从Perl 5.8.0开始处理属性。有关详细信息以及&lt;a href=&quot;fields&quot;&gt;字段&lt;/a&gt;，&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;和&lt;a href=&quot;attribute/handlers&quot;&gt;Attribute :: Handlers的&lt;/a&gt;信息，请参见&lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;perlsub中的my（）的私有变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8bfadb028cf247124d08e25f901567b324753c6" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;__package__&quot;&gt;__PACKAGE__&lt;/a&gt;&lt;/code&gt;. It is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or starting from Perl 5.8.0 also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;../fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE和ATTRS的确切语义和接口仍在不断发展。 TYPE可以是一个空词， &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; 声明的常量或 &lt;code&gt;&lt;a href=&quot;__package__&quot;&gt;__PACKAGE__&lt;/a&gt;&lt;/code&gt; 。当前它绑定到 &lt;code&gt;fields&lt;/code&gt; pragma 的使用，并且使用 &lt;code&gt;attributes&lt;/code&gt; pragma 来处理属性，或者也可以通过 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 模块从Perl 5.8.0开始。有关详细信息以及&lt;a href=&quot;../fields&quot;&gt;字段&lt;/a&gt;，&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;和&lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute :: Handlers的&lt;/a&gt;信息，请参见&lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;perlsub中的my（）的私有变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8d599de382831818fdc3314909d743d15fa4f85" translate="yes" xml:space="preserve">
          <source>The exact set of characters matched by &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; varies depending on various pragma and regular expression modifiers. It is possible to restrict the match to the ASCII range by using the &lt;code&gt;/a&lt;/code&gt; regular expression modifier. See &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; 和 &lt;code&gt;\w&lt;/code&gt; 匹配的确切字符集取决于各种编译指示和正则表达式修饰符。使用 &lt;code&gt;/a&lt;/code&gt; 正则表达式修饰符可以将匹配限制在ASCII范围内。参见&lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04c6e96fbcd4407d552a2d3c6f391d06e2768883" translate="yes" xml:space="preserve">
          <source>The example below illustrates this feature using the pattern for floating point numbers that was presented earlier on. The three subpatterns that are used more than once are the optional sign, the digit sequence for an integer and the decimal fraction. The DEFINE group at the end of the pattern contains their definition. Notice that the decimal fraction pattern is the first place where we can reuse the integer pattern.</source>
          <target state="translated">下面的例子用前面介绍的浮点数的模式来说明这个功能。三个被多次使用的子模式是可选符号、整数的数字序列和小数分数。模式末尾的DEFINE组包含了它们的定义。注意,小数分数模式是我们可以重复使用整数模式的第一个地方。</target>
        </trans-unit>
        <trans-unit id="b95b2fc7c1cff73cb10b6820506fd203858d5dd0" translate="yes" xml:space="preserve">
          <source>The example does not untaint &lt;code&gt;$data&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, because the characters matched by &lt;code&gt;\w&lt;/code&gt; are determined by the locale. Perl considers that locale definitions are untrustworthy because they contain data from outside the program. If you are writing a locale-aware program, and want to launder data with a regular expression containing &lt;code&gt;\w&lt;/code&gt; , put &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; ahead of the expression in the same block. See &lt;a href=&quot;perllocale#SECURITY&quot;&gt;SECURITY in perllocale&lt;/a&gt; for further discussion and examples.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境有效，该示例不会取消 &lt;code&gt;$data&lt;/code&gt; 污染，因为 &lt;code&gt;\w&lt;/code&gt; 匹配的字符由语言环境决定。 Perl认为语言环境定义是不可信的，因为它们包含程序外部的数据。如果您正在编写一个可识别语言环境的程序，并希望使用包含 &lt;code&gt;\w&lt;/code&gt; 的正则表达式清洗数据，则在同一块中的表达式前 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; 放置任何语言环境。有关更多讨论和示例，请参见&lt;a href=&quot;perllocale#SECURITY&quot;&gt;perllocale中的SECURITY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd1c21f507054a9e5bf00808f679503b139b9cd1" translate="yes" xml:space="preserve">
          <source>The examples above use a relative path to the perl interpreter, getting whatever version is first in the user's path. If you want a specific version of Perl, say, perl5.14.1, you should place that directly in the &lt;code&gt;#!&lt;/code&gt; line's path.</source>
          <target state="translated">上面的示例使用到perl解释器的相对路径，获取用户路径中第一个版本的文件。如果要使用Perl的特定版本，例如perl5.14.1，则应将其直接放在 &lt;code&gt;#!&lt;/code&gt; 中。线的路径。</target>
        </trans-unit>
        <trans-unit id="ba7768ce3ab49f321e6775f2de42c2a895f7304f" translate="yes" xml:space="preserve">
          <source>The examples given at the start of the document (an error handler and an event driven program) are typical of the two main sorts of flow control that you are likely to encounter with callbacks. There is a very important distinction between them, so pay attention.</source>
          <target state="translated">本文开头给出的例子(一个错误处理程序和一个事件驱动程序)是典型的两种主要的流控制类型,你可能会遇到回调。它们之间有一个非常重要的区别,所以要注意。</target>
        </trans-unit>
        <trans-unit id="d5744c543ee5f3d510361cac5aaaa06664739511" translate="yes" xml:space="preserve">
          <source>The examples illustrate several aspects: the first three queries target modules, authors, or distros directly and yield exactly one result. The last two use regular expressions and yield several results. The last one targets all of bundles, modules, authors, and distros simultaneously. When more than one result is available, they are printed in one-line format.</source>
          <target state="translated">这些例子说明了几个方面:前三个查询直接以模块、作者或发行版为目标,只产生一个结果。后面两个使用正则表达式,产生了多个结果。最后一个是同时针对所有的bundles、模块、作者和发行版。当有一个以上的结果时,它们会以单行格式打印。</target>
        </trans-unit>
        <trans-unit id="ddf2315db7343aee83255d9099df21a0faac3030" translate="yes" xml:space="preserve">
          <source>The examples in the previous section display an annoying weakness. We were only matching 3-letter words, or chunks of words of 4 letters or less. We'd like to be able to match words or, more generally, strings of any length, without writing out tedious alternatives like &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt; .</source>
          <target state="translated">上一节中的示例显示了一个令人讨厌的弱点。我们只匹配3个字母的单词或4个字母以下的单词块。我们希望能够匹配单词，或更广泛地说，匹配任何长度的字符串，而无需写出诸如 &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt; 类的乏味选择。</target>
        </trans-unit>
        <trans-unit id="6a56adef05fecf63fd9cba639dd925bcaf1cb87b" translate="yes" xml:space="preserve">
          <source>The examples show a very simple class that implements a</source>
          <target state="translated">这些例子展示了一个非常简单的类,它实现了一个非常简单的</target>
        </trans-unit>
        <trans-unit id="45802eeee4d1f7759548f95073ecb55a63eb7a92" translate="yes" xml:space="preserve">
          <source>The examples show this class implemented with different levels of support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; . All supported combinations are shown. The difference between implementations is often quite small. The implementations are:</source>
          <target state="translated">这些示例显示了 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 通过不同级别的支持实现的此类。显示所有受支持的组合。实现之间的差异通常很小。实现是：</target>
        </trans-unit>
        <trans-unit id="f51ffd2e5bcc1a6d7d14bd6f95a324550850104d" translate="yes" xml:space="preserve">
          <source>The excellent Calendar FAQ at &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;</source>
          <target state="translated">出色的日历常见问题解答，&lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;网址&lt;/a&gt;为http://www.tondering.dk/claus/calendar.html</target>
        </trans-unit>
        <trans-unit id="b98aabfe9b6ba71ecfd39be082dced0eadaf1cc4" translate="yes" xml:space="preserve">
          <source>The excellent Filter::Util::Call module (by Paul Marquess) provides a usable Perl interface to source filtering, but it is often too powerful and not nearly as simple as it could be.</source>
          <target state="translated">优秀的Filter::Util::Call模块(由Paul Marquess编写)为源码过滤提供了一个可用的Perl接口,但它往往太强大了,而且也没有那么简单。</target>
        </trans-unit>
        <trans-unit id="52ea595fb3e7d2ce456e743df519b555912d5e12" translate="yes" xml:space="preserve">
          <source>The exception is for organization-specific email (e.g. foo@yourcompany.com) where policy can be codified in your program. In that case, you could look at $ENV{USER}, $ENV{LOGNAME}, and getpwuid($&amp;lt;) in scalar context, like so:</source>
          <target state="translated">特定于组织的电子邮件（例如foo@yourcompany.com）例外，可以在您的程序中编写策略。在这种情况下，您可以在标量上下文中查看$ ENV {USER}，$ ENV {LOGNAME}和getpwuid（$ &amp;lt;），如下所示：</target>
        </trans-unit>
        <trans-unit id="ffc87b76bc5dac6308b19a21f2fb89ffe909a88b" translate="yes" xml:space="preserve">
          <source>The exception to the principle of &quot;one tainted value taints the whole expression&quot; is with the ternary conditional operator &lt;code&gt;?:&lt;/code&gt;. Since code with a ternary conditional</source>
          <target state="translated">三元条件运算符 &lt;code&gt;?:&lt;/code&gt; 是&amp;ldquo;一个值污染整个表达式&amp;rdquo;原理的例外。由于代码具有三元条件</target>
        </trans-unit>
        <trans-unit id="5c4020c3e362c07677c68b98797130c8e33e53fa" translate="yes" xml:space="preserve">
          <source>The exception to this rule are</source>
          <target state="translated">这一规则的例外是</target>
        </trans-unit>
        <trans-unit id="06cb57f51318b2c753120a0083873c4679095e1b" translate="yes" xml:space="preserve">
          <source>The exception to this rule is if you are calling a Perl subroutine directly from an XSUB function. In this case it is not necessary to use the &lt;code&gt;dSP&lt;/code&gt; macro explicitly--it will be declared for you automatically.</source>
          <target state="translated">此规则的例外是，如果您直接从XSUB函数调用Perl子例程。在这种情况下，无需显式使用 &lt;code&gt;dSP&lt;/code&gt; 宏-它将自动为您声明。</target>
        </trans-unit>
        <trans-unit id="0d894dabcea23f9b036a1c82348cf80da10ab49b" translate="yes" xml:space="preserve">
          <source>The exceptions are:</source>
          <target state="translated">例外情况是:</target>
        </trans-unit>
        <trans-unit id="3e26c68194190c41dfdad74105f0e492dc235a18" translate="yes" xml:space="preserve">
          <source>The execution order is indicated by &lt;code&gt;===&amp;gt;&lt;/code&gt; marks, thus it is &lt;code&gt;3
4 5 6&lt;/code&gt; (node &lt;code&gt;6&lt;/code&gt; is not included into above listing), i.e., &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt; .</source>
          <target state="translated">执行顺序由 &lt;code&gt;===&amp;gt;&lt;/code&gt; 标记指示，因此它是 &lt;code&gt;3 4 5 6&lt;/code&gt; （上面的列表中未包括节点 &lt;code&gt;6&lt;/code&gt; ），即 &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68a81e1fe7a2f079c1b9f8b207b9fe9d777e92c5" translate="yes" xml:space="preserve">
          <source>The executive summary: learn how your filesystem works. The permissions on a file say what can happen to the data in that file. The permissions on a directory say what can happen to the list of files in that directory. If you delete a file, you're removing its name from the directory (so the operation depends on the permissions of the directory, not of the file). If you try to write to the file, the permissions of the file govern whether you're allowed to.</source>
          <target state="translated">内容提要:了解你的文件系统如何工作。一个文件上的权限说的是该文件中的数据可以发生什么。一个目录上的权限说的是该目录中的文件列表可以发生什么。如果你删除一个文件,你就会从目录中删除它的名字(所以这个操作取决于目录的权限,而不是文件的权限)。如果你试图向文件写入,文件的权限支配你是否被允许。</target>
        </trans-unit>
        <trans-unit id="29fc393062d8546f20ed1b167ba8df5f73019ce5" translate="yes" xml:space="preserve">
          <source>The exit code of the executed program.</source>
          <target state="translated">执行程序的退出代码。</target>
        </trans-unit>
        <trans-unit id="137ed18115f3228ba7f07a48e55913ee96e30593" translate="yes" xml:space="preserve">
          <source>The exit status value to return.</source>
          <target state="translated">要返回的退出状态值。</target>
        </trans-unit>
        <trans-unit id="0c5c8d24f00e7eedd0cb8f1fea1a1b90fbdc8c11" translate="yes" xml:space="preserve">
          <source>The exit() function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;code&gt;$?&lt;/code&gt; . If this is a problem, you can call &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; to avoid END and destructor processing. See &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="translated">exit（）函数并不总是立即退出。它首先调用任何已定义的 &lt;code&gt;END&lt;/code&gt; 例程，但是这些 &lt;code&gt;END&lt;/code&gt; 例程本身可能不会中止退出。同样，任何需要调用的对象析构函数都在实际出口之前被调用。 &lt;code&gt;END&lt;/code&gt; 例程和析构函数可以通过修改 &lt;code&gt;$?&lt;/code&gt; 来更改退出状态。。如果这是一个问题，则可以调用 &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; 以避免END和析构函数的处理。有关详细信息，请参见&lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="680c902ef0b900a40fad1c488731545af94f9d10" translate="yes" xml:space="preserve">
          <source>The exit() function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;code&gt;$?&lt;/code&gt; . If this is a problem, you can call &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; to avoid END and destructor processing. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="translated">exit（）函数并不总是立即退出。它首先调用任何已定义的 &lt;code&gt;END&lt;/code&gt; 例程，但是这些 &lt;code&gt;END&lt;/code&gt; 例程本身可能不会中止退出。同样，任何需要调用的对象析构函数都在实际出口之前被调用。 &lt;code&gt;END&lt;/code&gt; 例程和析构函数可以通过修改 &lt;code&gt;$?&lt;/code&gt; 来更改退出状态。。如果这是一个问题，则可以调用 &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; 以避免END和析构函数的处理。有关详细信息，请参见&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="878ff23487a7f8c43fec8d4483cc1765c4df9eb4" translate="yes" xml:space="preserve">
          <source>The experimental &lt;code&gt;given&lt;/code&gt; statement is</source>
          <target state="translated">实验 &lt;code&gt;given&lt;/code&gt; 语句是</target>
        </trans-unit>
        <trans-unit id="19bd303111f858742510d8d90c5638313c02c5ce" translate="yes" xml:space="preserve">
          <source>The experimental &lt;code&gt;legacy&lt;/code&gt; pragma was swallowed by the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;code&gt;feature&lt;/code&gt; 杂语淹没了实验性的 &lt;code&gt;legacy&lt;/code&gt; 杂语。</target>
        </trans-unit>
        <trans-unit id="f321e42a52fdc6b5d89f69bf0fc91962da84c32f" translate="yes" xml:space="preserve">
          <source>The exponent is an &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt; , followed by an integer. So the exponent regexp is</source>
          <target state="translated">指数是 &lt;code&gt;e&lt;/code&gt; 或 &lt;code&gt;E&lt;/code&gt; ，后跟一个整数。所以指数正则表达式是</target>
        </trans-unit>
        <trans-unit id="dc560dadf22f2caa4887dcda366e49e8868f1d51" translate="yes" xml:space="preserve">
          <source>The exponentiation operator is &quot;**&quot;, not &quot;^&quot;. &quot;^&quot; is the XOR operator, as in C. (You know, one could get the feeling that &lt;b&gt;awk&lt;/b&gt; is basically incompatible with C.)</source>
          <target state="translated">取幂运算符是&amp;ldquo; **&amp;rdquo;，而不是&amp;ldquo; ^&amp;rdquo;。像C中一样，&amp;ldquo; ^&amp;rdquo;是XOR运算符（您可能会感觉到&lt;b&gt;awk&lt;/b&gt;与C基本不兼容。）</target>
        </trans-unit>
        <trans-unit id="009dcc9526e9f6902be1b067b6a2b9829ed8f757" translate="yes" xml:space="preserve">
          <source>The expression is evaluated in scalar context. So the following will work:</source>
          <target state="translated">表达式是在标量上下文中评估的。因此,下面的方法就可以了。</target>
        </trans-unit>
        <trans-unit id="09c23065a9eeac610af39d5a880a04c9ff912e79" translate="yes" xml:space="preserve">
          <source>The ext/ODBM_File/odbm is known to fail with static builds (Configure -Uusedl) due to a known bug in Tru64's static libdbm library. The good news is that you very probably don't need to ever use the ODBM_File extension since more advanced NDBM_File works fine, not to mention the even more advanced DB_File.</source>
          <target state="translated">已知 ext/ODBM_File/odbm 在静态构建时可能会失败 (Configure -Uusedl),这是因为 Tru64 的静态 libdbm 库存在一个已知的 bug。好消息是,你很可能不需要使用 ODBM_File 扩展,因为更高级的 NDBM_File 可以正常工作,更不用说更高级的 DB_File 了。</target>
        </trans-unit>
        <trans-unit id="31ec63f172c0fdca1326836d5d87e5fe035f0607" translate="yes" xml:space="preserve">
          <source>The extended filetest functionality is used by Perl only when the argument of the operators is a filename, not when it is a filehandle.</source>
          <target state="translated">扩展的filetest功能只有在运算符的参数是文件名时才会被Perl使用,而不是当它是一个文件手时。</target>
        </trans-unit>
        <trans-unit id="b669bdb080a6675f7c6ed5d24b2ef14539648c80" translate="yes" xml:space="preserve">
          <source>The extension is dynamically linked</source>
          <target state="translated">该扩展是动态链接的</target>
        </trans-unit>
        <trans-unit id="f990232badfb418cbf7dd0574833889e9f679aa9" translate="yes" xml:space="preserve">
          <source>The extension is pure perl, so doesn't need linking to the perl executable</source>
          <target state="translated">该扩展是纯perl的,所以不需要链接到perl可执行文件。</target>
        </trans-unit>
        <trans-unit id="13f70d182dd718c2ffdf92971d2248139cbe171e" translate="yes" xml:space="preserve">
          <source>The extension is statically linked to the perl binary</source>
          <target state="translated">扩展是静态地链接到perl二进制文件的</target>
        </trans-unit>
        <trans-unit id="b1beda77ee5a84052f068e6757ef13cea3f36f8f" translate="yes" xml:space="preserve">
          <source>The extracted string, including the specified delimiters. If the extraction fails &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">提取的字符串，包括指定的定界符。如果提取失败，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3130a57897b10b0bc008c6b4f6ef79e3b3444412" translate="yes" xml:space="preserve">
          <source>The extracted termcap entry is available in the object as &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt; .</source>
          <target state="translated">提取的termcap条目在对象中可用为 &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c328df413a33fa608e46c6826495b03f8d0ee0f6" translate="yes" xml:space="preserve">
          <source>The extraction process works by applying each extractor in sequence to the text string.</source>
          <target state="translated">提取过程的工作原理是将每个提取器依次应用到文本字符串上。</target>
        </trans-unit>
        <trans-unit id="7ad2005947669b79c8509770fad3b2b296acf5fd" translate="yes" xml:space="preserve">
          <source>The fact that such a FILE * has been 'exported' is recorded, (normally by pushing a new :stdio &quot;layer&quot; onto the PerlIO *), which may affect future PerlIO operations on the original PerlIO *. You should not call &lt;code&gt;fclose()&lt;/code&gt; on the file unless you call &lt;code&gt;PerlIO_releaseFILE()&lt;/code&gt; to disassociate it from the PerlIO *. (Do not use PerlIO_importFILE() for doing the disassociation.)</source>
          <target state="translated">记录了这样一个FILE *已经被&amp;ldquo;导出&amp;rdquo;的事实（通常通过将新的：stdio&amp;ldquo;层&amp;rdquo;推入PerlIO *）来进行记录，这可能会影响将来在原始PerlIO *上进行的PerlIO操作。除非调用 &lt;code&gt;PerlIO_releaseFILE()&lt;/code&gt; 使其与PerlIO *解除关联，否则不应在文件上调用 &lt;code&gt;fclose()&lt;/code&gt; 。 （请勿使用PerlIO_importFILE（）进行取消关联。）</target>
        </trans-unit>
        <trans-unit id="357aafdac768e27bb52a043649452bd876a53d4d" translate="yes" xml:space="preserve">
          <source>The factory itself is never instantiated (this</source>
          <target state="translated">工厂本身从未被实例化(这个</target>
        </trans-unit>
        <trans-unit id="ee17924499933b661b8e0c34b82c36eff25eeaf5" translate="yes" xml:space="preserve">
          <source>The fastgetcwd() function is provided as a synonym for cwd().</source>
          <target state="translated">fastgetcwd()函数是作为cwd()的同义词提供的。</target>
        </trans-unit>
        <trans-unit id="533f832808f430e9fde8557e2b27391f20356a2e" translate="yes" xml:space="preserve">
          <source>The feature logical name DECC$FILENAME_UNIX_REPORT modifies traditional Perl behavior in the conversion of file specifications from Unix to VMS format in order to follow the extended character handling rules now expected by the CRTL. Specifically, when this feature is in effect, the &lt;code&gt;./.../&lt;/code&gt; in a Unix path is now translated to &lt;code&gt;[.^.^.^.]&lt;/code&gt; instead of the traditional VMS &lt;code&gt;[...]&lt;/code&gt; . To be compatible with what MakeMaker expects, if a VMS path cannot be translated to a Unix path, it is passed through unchanged, so &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; will return &lt;code&gt;[...]&lt;/code&gt; .</source>
          <target state="translated">功能逻辑名称DECC $ FILENAME_UNIX_REPORT修改了将文件规范从Unix转换为VMS格式时的传统Perl行为，以便遵循CRTL现在期望的扩展字符处理规则。具体来说，当此功能生效时，Unix路径中的 &lt;code&gt;./.../&lt;/code&gt; 现在可以转换为 &lt;code&gt;[.^.^.^.]&lt;/code&gt; 而不是传统的VMS &lt;code&gt;[...]&lt;/code&gt; 。为了与MakeMaker期望的兼容，如果无法将VMS路径转换为Unix路径，则将其 &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; 传递，因此unixify（&amp;ldquo; [...]&amp;rdquo;）将返回 &lt;code&gt;[...]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98ee4cd3c900fba7f346eaf4d73c2e59283171b2" translate="yes" xml:space="preserve">
          <source>The feature needs to be enabled with &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt; .</source>
          <target state="translated">该功能需要通过 &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt; 启用。</target>
        </trans-unit>
        <trans-unit id="e9967e9df7e264da6bcdb44f5aee030bc917d02a" translate="yes" xml:space="preserve">
          <source>The features you got from your mother and father, mixed together unpredictably. (See also &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;single inheritance&lt;/b&gt;.) In computer languages (including Perl), it is the notion that a given class may have multiple direct ancestors or &lt;b&gt;base classes&lt;/b&gt;.</source>
          <target state="translated">您从母亲和父亲那里获得的功能是无法预测地融合在一起的。（另请参见&lt;b&gt;继承&lt;/b&gt;和&lt;b&gt;单继承&lt;/b&gt;。）在计算机语言（包括Perl）中，这是给定类可以具有多个直接祖先或&lt;b&gt;基类&lt;/b&gt;的观念。</target>
        </trans-unit>
        <trans-unit id="ddb61ef14874404dd766423660c7d397637ace24" translate="yes" xml:space="preserve">
          <source>The features you got from your mother, if she told you that you don&amp;rsquo;t have a father. (See also &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;multiple inheritance&lt;/b&gt;.) In computer languages, the idea that &lt;b&gt;classes&lt;/b&gt; reproduce asexually so that a given class can only have one direct ancestor or &lt;b&gt;base class&lt;/b&gt;. Perl supplies no such restriction, though you may certainly program Perl that way if you like.</source>
          <target state="translated">如果母亲告诉您您没有父亲，那么您从母亲那里获得的功能。（另请参见&lt;b&gt;继承&lt;/b&gt;和&lt;b&gt;多重继承&lt;/b&gt;。）在计算机语言中，&lt;b&gt;类&lt;/b&gt;的观念是无性繁殖的，因此给定的类只能具有一个直接祖先或&lt;b&gt;基类&lt;/b&gt;。Perl没有提供这样的限制，但是如果您愿意的话，您当然可以用这种方式编程Perl。</target>
        </trans-unit>
        <trans-unit id="3a3635eb281607d1f863de82b6a5a308964a4737" translate="yes" xml:space="preserve">
          <source>The field &quot;@*&quot; can be used for printing multi-line, nontruncated values; it should (but need not) appear by itself on a line. A final line feed is chomped off, but all other characters are emitted verbatim.</source>
          <target state="translated">字段&quot;@*&quot;可用于打印多行、非截断的值;它应该(但不需要)单独出现在一行上。最后的换行会被截断,但所有其他字符都会被逐字输出。</target>
        </trans-unit>
        <trans-unit id="38f6e6f64de0d391d989196e8ebb7ddb708ac60a" translate="yes" xml:space="preserve">
          <source>The fields are discussed in more detail below:</source>
          <target state="translated">下面将详细讨论这些领域。</target>
        </trans-unit>
        <trans-unit id="d21955b9d1337383a18b406fff73dac35d4d6488" translate="yes" xml:space="preserve">
          <source>The fields are tab-separated. The first column is the depth (zero being the innermost non-skipped frame). In the hex:offset, the hex is where the program counter was in S_parse_body, and the :offset (might be missing) tells how much inside the S_parse_body the program counter was.</source>
          <target state="translated">字段是以标签分隔的。第一列是深度(0是最里面的非跳转帧)。在hex:offset中,hex是程序计数器在S_parse_body中的位置,而:offset(可能会缺失)则是告诉程序计数器在S_parse_body里面的位置。</target>
        </trans-unit>
        <trans-unit id="3aabcb5c5289f7ad819b54aa9417f88080d7fec5" translate="yes" xml:space="preserve">
          <source>The fields of interest which may appear in this line are</source>
          <target state="translated">这一行可能出现的相关领域是:</target>
        </trans-unit>
        <trans-unit id="04fbc7508d5d457aedc840547581d13fb785d13c" translate="yes" xml:space="preserve">
          <source>The file</source>
          <target state="translated">该文件</target>
        </trans-unit>
        <trans-unit id="99944ba23fa1671290cc70fdf7f917ecb5343db9" translate="yes" xml:space="preserve">
          <source>The file (name) the error occurred in.</source>
          <target state="translated">发生错误的文件(名称)。</target>
        </trans-unit>
        <trans-unit id="74280467b06cd39e1ebe6f256e50f06eca04fcbe" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;perlio.c&lt;/code&gt; provides the following layers:</source>
          <target state="translated">&lt;code&gt;perlio.c&lt;/code&gt; 文件提供以下层：</target>
        </trans-unit>
        <trans-unit id="b4bb1e7661bc100161f83c2b2d4bc9930cd6bed6" translate="yes" xml:space="preserve">
          <source>The file MANIFEST.SKIP may contain regular expressions of files that should be ignored by mkmanifest() and filecheck(). The regular expressions should appear one on each line. Blank lines and lines which start with &lt;code&gt;#&lt;/code&gt; are skipped. Use &lt;code&gt;\#&lt;/code&gt; if you need a regular expression to start with a &lt;code&gt;#&lt;/code&gt; .</source>
          <target state="translated">文件MANIFEST.SKIP可能包含mkmanifest（）和filecheck（）应该忽略的文件的正则表达式。正则表达式应在每一行上显示一个。空行和以 &lt;code&gt;#&lt;/code&gt; 开头的行将被跳过。如果您需要以 &lt;code&gt;#&lt;/code&gt; 开头的正则表达式，请使用 &lt;code&gt;\#&lt;/code&gt; ＃。</target>
        </trans-unit>
        <trans-unit id="2791b558da2cb7ec65180cdaeb2459b7a1726fa1" translate="yes" xml:space="preserve">
          <source>The file Makefile.PL should look something like this:</source>
          <target state="translated">文件Makefile.PL应该是这样的。</target>
        </trans-unit>
        <trans-unit id="76e388baaf2a00fb72a8272cf31814ec70994241" translate="yes" xml:space="preserve">
          <source>The file Mytest.pm should start with something like this:</source>
          <target state="translated">Mytest.pm文件的开头应该是这样的。</target>
        </trans-unit>
        <trans-unit id="a37078c2a2fb3ae7f022a61feee12e4a85c77a67" translate="yes" xml:space="preserve">
          <source>The file Unicode/Collate/allkeys.txt was copied verbatim from &lt;a href=&quot;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&lt;/a&gt;. For this file, Copyright (c) 2001-2012 Unicode, Inc. Distributed under the Terms of Use in &lt;a href=&quot;http://www.unicode.org/copyright.html&quot;&gt;http://www.unicode.org/copyright.html&lt;/a&gt;.</source>
          <target state="translated">文件Unicode / Collat​​e / allkeys.txt是从&lt;a href=&quot;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&lt;/a&gt;逐字复制的。对于此文件，版权所有（c）2001-2012 Unicode，Inc.。根据使用条款在&lt;a href=&quot;http://www.unicode.org/copyright.html&quot;&gt;http://www.unicode.org/copyright.html中&lt;/a&gt;分发。</target>
        </trans-unit>
        <trans-unit id="1744236e794a4c53bf20da07fd1df8dc62fc8e81" translate="yes" xml:space="preserve">
          <source>The file is</source>
          <target state="translated">该文件是</target>
        </trans-unit>
        <trans-unit id="79a42520a58ddeeb12292112f2a308b0310a0a00" translate="yes" xml:space="preserve">
          <source>The file is removed when the filehandle is closed or when the program exits. No access to the filename is provided.</source>
          <target state="translated">当文件柄关闭或程序退出时,该文件将被删除。不提供对文件名的访问。</target>
        </trans-unit>
        <trans-unit id="5b68113e94418bbe01dba1e8408762baaba90492" translate="yes" xml:space="preserve">
          <source>The file must return true as the last statement to indicate successful execution of any initialization code, so it's customary to end such a file with &lt;code&gt;1;&lt;/code&gt; unless you're sure it'll return true otherwise. But it's better just to put the &lt;code&gt;1;&lt;/code&gt; , in case you add more statements.</source>
          <target state="translated">该文件必须作为最后一条语句返回true，以指示任何初始化代码的成功执行，因此习惯上以1结尾这样的文件 &lt;code&gt;1;&lt;/code&gt; 除非您确定否则它将返回true。但是最好只放 &lt;code&gt;1;&lt;/code&gt; ，以防添加更多语句。</target>
        </trans-unit>
        <trans-unit id="cda785c206d1d83026d51c7970996f0a544bbd22" translate="yes" xml:space="preserve">
          <source>The file named in VERSION_FROM is not added as a dependency to Makefile. This is not really correct, but it would be a major pain during development to have to rewrite the Makefile for any smallish change in that file. If you want to make sure that the Makefile contains the correct VERSION macro after any change of the file, you would have to do something like</source>
          <target state="translated">在 VERSION_FROM 中命名的文件没有被添加到 Makefile 中作为依赖关系。这其实并不正确,但在开发过程中,如果要为该文件的任何细微变化而重写Makefile,那将是一件非常痛苦的事情。如果你想确保在对文件进行任何修改后,Makefile 中包含正确的 VERSION 宏,你就必须做一些类似这样的事情</target>
        </trans-unit>
        <trans-unit id="bdaf2cba4d9764ecdf7f47c7aa146b4c33b7bbf0" translate="yes" xml:space="preserve">
          <source>The file redirection characters &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, and &quot;|&quot; can be quoted by double quotes (although there are suggestions that this may not always be true). Single quotes are not treated as quotes by the shell or the C runtime, they don't get stripped by the shell (just to make this type of quoting completely useless). The caret &quot;^&quot; has also been observed to behave as a quoting character, but this appears to be a shell feature, and the caret is not stripped from the command line, so Perl still sees it (and the C runtime phase does not treat the caret as a quote character).</source>
          <target state="translated">文件重定向字符&amp;ldquo; &amp;lt;&amp;rdquo;，&amp;ldquo;&amp;ldquo;&amp;gt;&amp;rdquo;和&amp;ldquo; |&amp;rdquo;可以用双引号引起来（尽管有些建议可能并不总是如此）。 shell或C运行时不会将单引号视为引号，它们不会被shell剥夺（只是使这种类型的引号完全无用）。还可以观察到插入符&amp;ldquo; ^&amp;rdquo;表现为引号字符，但这似乎是shell功能，并且没有从命令行中删除插入符，因此Perl仍然可以看到它（并且C运行时阶段不处理插入符号作为引号）。</target>
        </trans-unit>
        <trans-unit id="52fb6cb3aabc05d2c0113ff975b6b538671a53b3" translate="yes" xml:space="preserve">
          <source>The file returned by File::Temp will have been opened in binary mode if such a mode is available. If that is not correct, use the C</source>
          <target state="translated">File::Temp 返回的文件将以二进制模式打开,如果这种模式可用的话。如果不正确,请使用C</target>
        </trans-unit>
        <trans-unit id="00c1f1869978b35696fb14c540a8ba10948b7605" translate="yes" xml:space="preserve">
          <source>The file type, or extension, is always present in a VMS-format file specification even if it's zero-length. This means that, by default, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; will return a trailing dot on a file with no extension, so where you would see &lt;code&gt;&quot;a&quot;&lt;/code&gt; on Unix you'll see &lt;code&gt;&quot;a.&quot;&lt;/code&gt; on VMS. However, the trailing dot may be suppressed by enabling the &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; feature in the environment (see the CRTL documentation on feature logical names).</source>
          <target state="translated">文件类型或扩展名始终存在于VMS格式的文件规范中，即使其长度为零。这意味着，默认情况下， &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 将在不带扩展名的文件上返回尾随点，因此在Unix上看到 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 地方将看到&amp;ldquo; a&amp;rdquo; &lt;code&gt;&quot;a.&quot;&lt;/code&gt; 在VMS上。但是，可以通过在环境中启用 &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; 功能来抑制尾随点（请参阅CRTL文档中的功能逻辑名）。</target>
        </trans-unit>
        <trans-unit id="4023271c9fc7425e571468846ea1d383c9d49eba" translate="yes" xml:space="preserve">
          <source>The file types are:</source>
          <target state="translated">文件类型有:</target>
        </trans-unit>
        <trans-unit id="43719b35ec87acc604024ce99c0c8fb60624b26e" translate="yes" xml:space="preserve">
          <source>The file's mode</source>
          <target state="translated">文件的模式</target>
        </trans-unit>
        <trans-unit id="a95c16ea1ecea8120f9e1164c67484d409f61395" translate="yes" xml:space="preserve">
          <source>The file's name</source>
          <target state="translated">文件的名称</target>
        </trans-unit>
        <trans-unit id="4b9a5685b1075bc4b20ae964579e2b1d813d620d" translate="yes" xml:space="preserve">
          <source>The filehandle behaves normally for the parent, but I/O to that filehandle is piped from/to the STDOUT/STDIN of the child process. In the child process, the filehandle isn't opened--I/O happens from/to the new STDOUT/STDIN. Typically this is used like the normal piped open when you want to exercise more control over just how the pipe command gets executed, such as when running setuid and you don't want to have to scan shell commands for metacharacters.</source>
          <target state="translated">filehandle对父进程来说是正常的,但对该filehandle的I/O是从/到子进程的STDOUT/STDIN的管道。在子进程中,文件柄并没有被打开--I/O是从/到新的STDOUT/STDIN的。通常,当你想对管道命令的执行方式进行更多的控制时,比如在运行setuid时,你不想扫描shell命令中的元字符时,就会像普通的管道打开一样使用这个方法。</target>
        </trans-unit>
        <trans-unit id="82d3d5cbabb04fbe3144e08782ff5dbb8eaf643d" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="translated">当其引用计数达到零时，文件句柄将关闭。如果它是用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明的词法范围变量，则通常意味着封闭范围的结尾。但是，此自动关闭不会检查错误，因此最好显式关闭文件句柄，尤其是用于写入的文件句柄：</target>
        </trans-unit>
        <trans-unit id="c6da7495029a8eadd3a9c0429778422e3ffb1d61" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="translated">当其引用计数达到零时，文件句柄将关闭。如果它是用 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明的词法范围变量，则通常意味着封闭范围的结尾。但是，此自动关闭不会检查错误，因此最好显式关闭文件句柄，尤其是用于写入的文件句柄：</target>
        </trans-unit>
        <trans-unit id="f157c14e0e96a0cb19a8e1a0df5c9ee87ca4b5e2" translate="yes" xml:space="preserve">
          <source>The filehandles STDIN, STDOUT, and STDERR are predefined. (The filehandles &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , and &lt;code&gt;stderr&lt;/code&gt; will also work except in packages, where they would be interpreted as local identifiers rather than global.) Additional filehandles may be created with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function, amongst others. See &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; and &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for details on this.</source>
          <target state="translated">文件句柄STDIN，STDOUT和STDERR是预定义的。（除了包中的文件句柄 &lt;code&gt;stdin&lt;/code&gt; ， &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 还将起作用，在软件包中，它们将被解释为本地标识符而不是全局标识符。）可以使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 函数创建其他文件句柄。参见&lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;并&lt;a href=&quot;functions/open&quot;&gt;打开&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="586bcd238ccd4b9fecd344d54e37e9531bdb9cd2" translate="yes" xml:space="preserve">
          <source>The filehandles may also be integers, in which case they are understood as file descriptors.</source>
          <target state="translated">文件柄也可以是整数,在这种情况下,它们被理解为文件描述符。</target>
        </trans-unit>
        <trans-unit id="66a7978092f9f45d843d817f4a627ae3fdb00a8b" translate="yes" xml:space="preserve">
          <source>The filename of the data store holding the data that App::Prove::State reads.</source>
          <target state="translated">持有App::Prove::State读取的数据的数据存储的文件名。</target>
        </trans-unit>
        <trans-unit id="6d594502076d5702a51ff03f260fd4c765a898ae" translate="yes" xml:space="preserve">
          <source>The filename of the perllibrary that will be used together with this extension. Defaults to libperl.a.</source>
          <target state="translated">与此扩展名一起使用的 perllibrary 的文件名。默认为libperl.a。</target>
        </trans-unit>
        <trans-unit id="d9b0656face1bd799f2d3aeeb4a33e8ccdb99fbf" translate="yes" xml:space="preserve">
          <source>The filename passed to the one- and two-argument forms of open() will have leading and trailing whitespace deleted and normal redirection characters honored. This property, known as &quot;magic open&quot;, can often be used to good effect. A user could specify a filename of</source>
          <target state="translated">传递给open()的单参数和双参数形式的文件名将删除前导空格和后导空格,并保留正常的重定向字符。这个属性,被称为 &quot;神奇的打开&quot;,经常被用来达到良好的效果。用户可以指定一个文件名为</target>
        </trans-unit>
        <trans-unit id="6d720ff4e8b207a8fa86d2d1f6ed053fe36cb247" translate="yes" xml:space="preserve">
          <source>The files</source>
          <target state="translated">文件</target>
        </trans-unit>
        <trans-unit id="5e8ac4ea16fdec255bb3d994323e38344f15cd1a" translate="yes" xml:space="preserve">
          <source>The files in the &quot;qnx&quot; directory are:</source>
          <target state="translated">&quot;qnx &quot;目录下的文件有:</target>
        </trans-unit>
        <trans-unit id="ccf1a34f9c5304eccd7056360fe19cfcc880dfc0" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither access timestamp nor change timestamp (meaning that about the only portable timestamp is the modification timestamp), or one second granularity of any timestamps (e.g. the FAT filesystem limits the time granularity to two seconds).</source>
          <target state="translated">文件系统可能既不支持访问时间戳,也不支持更改时间戳(也就是说,大约只有修改时间戳才是可移植的时间戳),或者支持一秒粒度的任何时间戳(例如FAT文件系统将时间粒度限制为两秒)。</target>
        </trans-unit>
        <trans-unit id="4acc2f4b822151bd730e57f84d225c79d062f507" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither hard links (&lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt;) nor symbolic links (&lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">文件系统可能既不支持硬链接（ &lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; ），也不支持符号链接（ &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="15629c3f6edb637003db8544e5aa317bc95e5e82" translate="yes" xml:space="preserve">
          <source>The filesystem of Symbian devices uses DOSish syntax, &quot;drives&quot; separated from paths by a colon, and backslashes for the path. The exact assignment of the drives probably varies between platforms, but for example in Series 60 you might see C: as the (flash) main memory, D: as the RAM drive, E: as the memory card (MMC), Z: as the ROM. In Series 80 D: is the memory card. As far the devices go the NUL: is the bit bucket, the COMx: are the serial lines, IRCOMx: are the IR ports, TMP: might be C:\System\Temp. Remember to double those backslashes in doublequoted strings.</source>
          <target state="translated">Symbian设备的文件系统使用DOS式语法,&quot;驱动器 &quot;与路径之间用冒号隔开,路径用反斜杠表示。驱动器的具体分配可能在不同的平台上有所不同,但例如在60系列中,你可能会看到C:作为(闪存)主存储器,D:作为RAM驱动器,E:作为存储卡(MMC),Z:作为ROM。在80系列中,D:是存储卡。至于设备中的NUL:是位桶,COMx:是串行线,IRCOMx:是红外端口,TMP:可能是C:\SystemTemp。记得在双引号的字符串中,这些反斜杠要双倍。</target>
        </trans-unit>
        <trans-unit id="60abfd860ab77072c0ffed33f686231d933f221b" translate="yes" xml:space="preserve">
          <source>The filetest operators &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are not implemented, as they require more information than just a stat buffer.</source>
          <target state="translated">未执行文件测试运算符 &lt;code&gt;-t&lt;/code&gt; ， &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; ，因为它们需要更多信息，而不仅仅是stat缓冲区。</target>
        </trans-unit>
        <trans-unit id="a32f19af093b1f7fb24c634263035e297b5a2ba3" translate="yes" xml:space="preserve">
          <source>The filter ensures that Perl parses the code between the &amp;lt;DEBUG_BEGIN&amp;gt; and &lt;code&gt;DEBUG_END&lt;/code&gt; markers only when the &lt;code&gt;DEBUG&lt;/code&gt; environment variable exists. That means that when &lt;code&gt;DEBUG&lt;/code&gt; does exist, the code above should be passed through the filter unchanged. The marker lines can also be passed through as-is, because the Perl parser will see them as comment lines. When &lt;code&gt;DEBUG&lt;/code&gt; isn't set, we need a way to disable the debug code. A simple way to achieve that is to convert the lines between the two markers into comments:</source>
          <target state="translated">过滤器确保仅当存在 &lt;code&gt;DEBUG&lt;/code&gt; 环境变量时，Perl才能解析&amp;lt;DEBUG_BEGIN&amp;gt;和 &lt;code&gt;DEBUG_END&lt;/code&gt; 标记之间的代码。这意味着当确实存在 &lt;code&gt;DEBUG&lt;/code&gt; 时，上面的代码应不更改地通过过滤器。标记行也可以按原样传递，因为Perl解析器会将其视为注释行。当未设置 &lt;code&gt;DEBUG&lt;/code&gt; 时，我们需要一种禁用调试代码的方法。一种简单的实现方法是将两个标记之间的线转换为注释：</target>
        </trans-unit>
        <trans-unit id="3cfa6a6fd2754ac19a694b001066c8361c789aec" translate="yes" xml:space="preserve">
          <source>The filter included are:</source>
          <target state="translated">包括的过滤器有:</target>
        </trans-unit>
        <trans-unit id="06dac022e678c85372a6fa4a8e6e10c155086a90" translate="yes" xml:space="preserve">
          <source>The filter is applied to</source>
          <target state="translated">该过滤器适用于</target>
        </trans-unit>
        <trans-unit id="6311b9692024a04fd6e913eb59f189ec85a241cf" translate="yes" xml:space="preserve">
          <source>The filter is applied to the key</source>
          <target state="translated">滤波器被应用到键</target>
        </trans-unit>
        <trans-unit id="edd6196707ee8763311d3aafd47d83821af190dd" translate="yes" xml:space="preserve">
          <source>The filter is applied to the value</source>
          <target state="translated">滤波器被应用于</target>
        </trans-unit>
        <trans-unit id="6693f0e2b9229e67ead2ac6746c8771a8ed55fa9" translate="yes" xml:space="preserve">
          <source>The final &lt;code&gt;PUTBACK&lt;/code&gt; is used to leave the Perl stack in a consistent state before exiting the function. This is necessary because when we popped the return value from the stack with &lt;code&gt;POPi&lt;/code&gt; it updated only our local copy of the stack pointer. Remember, &lt;code&gt;PUTBACK&lt;/code&gt; sets the global stack pointer to be the same as our local copy.</source>
          <target state="translated">最终的 &lt;code&gt;PUTBACK&lt;/code&gt; 用于在退出函数之前使Perl堆栈保持一致状态。这是必要的，因为当我们使用 &lt;code&gt;POPi&lt;/code&gt; 从堆栈中弹出返回值时，它仅更新了堆栈指针的本地副本。请记住， &lt;code&gt;PUTBACK&lt;/code&gt; 将全局堆栈指针设置为与本地副本相同。</target>
        </trans-unit>
        <trans-unit id="6d574089f345d41e6ac1476fc2b80885aa410f07" translate="yes" xml:space="preserve">
          <source>The final character can't be a hyphen, colon, or period. URLs ending with these characters, while allowed by XHTML, can be awkward to extract from plain text.</source>
          <target state="translated">最后一个字符不能是连字符、冒号或句号。以这些字符结尾的URL,虽然XHTML允许,但从纯文本中提取会很麻烦。</target>
        </trans-unit>
        <trans-unit id="0a99e11f3a928dd6413c811829c3b9af3764501f" translate="yes" xml:space="preserve">
          <source>The final difference between regular bracketed character classes and these, is that it is not possible to get these to match a multi-character fold. Thus,</source>
          <target state="translated">常规括号内的字符类与这些的最后区别,就是无法让这些字符与多字符折合。因此。</target>
        </trans-unit>
        <trans-unit id="cde87782285bb08650f77bdd2e4ce0e06adc25ff" translate="yes" xml:space="preserve">
          <source>The final element of a list assignment may be an array or a hash:</source>
          <target state="translated">列表赋值的最后一个元素可以是一个数组或哈希。</target>
        </trans-unit>
        <trans-unit id="b74663d384e88ec12c85ff6a9f4b23592b8a3858" translate="yes" xml:space="preserve">
          <source>The final line (with Index [242]) means that the value for all code points above the legal Unicode maximum code point have the value &quot;No_Block&quot;, which is the term Unicode uses for a non-existing block.</source>
          <target state="translated">最后一行(带索引[242])的意思是,所有超过Unicode法定最大码点的码点的值都有 &quot;No_Block&quot;,这是Unicode用来表示不存在的块的术语。</target>
        </trans-unit>
        <trans-unit id="e6811c076957053b2764757de731f2de38b4111a" translate="yes" xml:space="preserve">
          <source>The final operation uses the backslash character to invalidate the special meaning of an open square bracket &lt;code&gt;[&lt;/code&gt;, the asterisk, backslash or the question mark. Two backslashes in sequence will result in the evaluation of the backslash as a character with no special meaning.</source>
          <target state="translated">最后的操作使用反斜杠字符使方括号 &lt;code&gt;[&lt;/code&gt; ，星号，反斜杠或问号] 的特殊含义无效。顺序两个反斜杠将导致反斜杠作为没有特殊含义的字符进行评估。</target>
        </trans-unit>
        <trans-unit id="be0c78c80ebce8da51fa36633d30ae64f567f49f" translate="yes" xml:space="preserve">
          <source>The final semicolon in a block is optional, as is the final comma in a list. Good style (see &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;) says to put them in except for one-liners:</source>
          <target state="translated">块中的最后一个分号是可选的，列表中的最后一个逗号也是可选的。好的样式（请参阅&lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;）表示将它们放入，但单线除外：</target>
        </trans-unit>
        <trans-unit id="16f205f9e57e8503952af3471732d873e8a9fc93" translate="yes" xml:space="preserve">
          <source>The final semicolon, if any, may be omitted from the value of EXPR or within the BLOCK.</source>
          <target state="translated">如果有分号,最后的分号可以从EXPR的值中省略,也可以在BLOCK中省略。</target>
        </trans-unit>
        <trans-unit id="3ee4566a0600358ccd1fe8d6c5a93a6cd48a9d99" translate="yes" xml:space="preserve">
          <source>The final stage is to call &lt;code&gt;test_test&lt;/code&gt; that will simply compare what you predeclared to what &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; actually outputted, and report the results back with a &quot;ok&quot; or &quot;not ok&quot; (with debugging) to the normal output.</source>
          <target state="translated">最后 &lt;code&gt;test_test&lt;/code&gt; 是调用test_test，它将简单地将您预先声明的内容与&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;实际输出的内容进行比较，然后将结果以&amp;ldquo; ok&amp;rdquo;或&amp;ldquo; not ok&amp;rdquo;（通过调试）报告给正常输出。</target>
        </trans-unit>
        <trans-unit id="31473d1a074747714a49e0fc3e7edd46729c2ea4" translate="yes" xml:space="preserve">
          <source>The final step involves passing each filename matched by the &lt;code&gt;*.tar.gz&lt;/code&gt; file glob through the derived Perl regular expression in turn and expanding the output fileglob using it.</source>
          <target state="translated">最后一步包括依次将每个与 &lt;code&gt;*.tar.gz&lt;/code&gt; 文件glob 匹配的文件名传递给派生的Perl正则表达式，并使用它扩展输出fileglob。</target>
        </trans-unit>
        <trans-unit id="d96d9b1e4edc6c2a13a6362b88a7c6a709b1d43c" translate="yes" xml:space="preserve">
          <source>The final two modifiers we will discuss here, &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;//c&lt;/code&gt; , concern multiple matches. The modifier &lt;code&gt;//g&lt;/code&gt; stands for global matching and allows the matching operator to match within a string as many times as possible. In scalar context, successive invocations against a string will have &lt;code&gt;//g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">我们将在这里讨论的最后两个修饰符 &lt;code&gt;//g&lt;/code&gt; 和 &lt;code&gt;//c&lt;/code&gt; 涉及多个匹配项。修饰符 &lt;code&gt;//g&lt;/code&gt; 表示全局匹配，它允许匹配运算符在一个字符串内尽可能多地匹配。在标量上下文中，对字符串的连续调用将在匹配之间跳转 &lt;code&gt;//g&lt;/code&gt; ，从而跟踪字符串在字符串中的位置。您可以使用 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 函数获取或设置位置。</target>
        </trans-unit>
        <trans-unit id="69b0c89da94c5764d6322358005c665b7a6ec505" translate="yes" xml:space="preserve">
          <source>The final, fourth element (index [3], assigned to &lt;code&gt;$default&lt;/code&gt; in the &quot;block&quot; example) in the four element list returned by this function is used with the &lt;code&gt;&quot;a&quot;&lt;/code&gt; format types; it may also be useful for applications that wish to convert the returned inversion map data structure into some other, such as a hash. It gives the mapping that most code points map to under the property. If you establish the convention that any code point not explicitly listed in your data structure maps to this value, you can potentially make your data structure much smaller. As you construct your data structure from the one returned by this function, simply ignore those ranges that map to this value. For example, to convert to the data structure searchable by &lt;a href=&quot;#charinrange()&quot;&gt;charinrange()&lt;/a&gt;, you can follow this recipe for properties that don't require adjustments:</source>
          <target state="translated">此函数返回的四元素列表中的最后一个第四元素（在[ block]示例中分配给 &lt;code&gt;$default&lt;/code&gt; 索引[3] ）与 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 格式类型一起使用；对于希望将返回的反转映射数据结构转换为其他值（例如哈希）的应用程序，它可能也很有用。它在属性下提供了大多数代码点映射到的映射。如果您建立了约定，即未在数据结构中明确列出的任何代码点都映射到该值，则有可能使数据结构更小。从此函数返回的数据结构构造数据结构时，只需忽略那些映射到该值的范围。例如，转换为&lt;a href=&quot;#charinrange()&quot;&gt;charinrange（）&lt;/a&gt;可搜索的数据结构，对于不需要调整的属性，可以遵循以下食谱：</target>
        </trans-unit>
        <trans-unit id="20c1b5c18477e5291b6b00c55abb0e8a3b781429" translate="yes" xml:space="preserve">
          <source>The find_dup() Method</source>
          <target state="translated">find_dup()方法</target>
        </trans-unit>
        <trans-unit id="a4105f4f4646c65f036c1e5edea46eddb3a8418a" translate="yes" xml:space="preserve">
          <source>The first (and now failed) goal of Unicode was to map all character repertoires into a fixed-length integer so that programmers are happy. Since each character is either a</source>
          <target state="translated">Unicode的第一个(现在已经失败了)目标是将所有字符集映射成一个固定长度的整数,这样程序员就会很高兴。由于每个字符要么是一个</target>
        </trans-unit>
        <trans-unit id="172226a1c7ce5a6d06797585142c70179c0ec58b" translate="yes" xml:space="preserve">
          <source>The first &lt;b&gt;PAUSE&lt;/b&gt; author to upload a &lt;b&gt;namespace&lt;/b&gt; automatically becomes the &lt;b&gt;primary maintainer&lt;/b&gt; for that namespace. The &amp;ldquo;first come&amp;rdquo; permissions distinguish a &lt;b&gt;primary maintainer&lt;/b&gt; who was assigned that role from one who received it automatically.</source>
          <target state="translated">第一个上载&lt;b&gt;名称空间的&lt;/b&gt;&lt;b&gt;PAUSE&lt;/b&gt;作者自动成为该&lt;b&gt;名称空间&lt;/b&gt;的&lt;b&gt;主要维护者&lt;/b&gt;。&amp;ldquo;先来者&amp;rdquo;权限将分配了该角色的&lt;b&gt;主要维护者&lt;/b&gt;与自动接收该角色的&lt;b&gt;主要维护者&lt;/b&gt;区分开。</target>
        </trans-unit>
        <trans-unit id="97526a10437e54c9f14361d8f57177e27604beab" translate="yes" xml:space="preserve">
          <source>The first Perl argument to this function would be treated as a char and assigned to the variable a, and its address would be passed into the function foo. The second Perl argument would be treated as a string pointer and assigned to the variable b. The</source>
          <target state="translated">这个函数的第一个Perl参数将被视为一个char,并分配给变量a,它的地址将被传递给函数foo。第二个Perl参数将被视为字符串指针并分配给变量b。</target>
        </trans-unit>
        <trans-unit id="e5e4f6464deede9ad4eff50e6de5039522d07e08" translate="yes" xml:space="preserve">
          <source>The first and second arguments may be strings, typeglobs, typeglob references, or objects inheriting from IO::Handle; they are used in all cases to obtain the</source>
          <target state="translated">第一个和第二个参数可以是字符串、tyeglobs、tyeglob引用或继承自IO::Handle的对象;在所有情况下,它们都被用来获取</target>
        </trans-unit>
        <trans-unit id="f11ee434e9fca49f11d7860f46bcba7e793d3dea" translate="yes" xml:space="preserve">
          <source>The first and second forms explicitly identify the name of the class being created. The third form assumes the current package name as the class name.</source>
          <target state="translated">第一和第二种形式明确标识了正在创建的类的名称。第三种形式将当前的包名作为类名。</target>
        </trans-unit>
        <trans-unit id="1490a2bc188cd4f0f1d7d40df76c523f30ba9b64" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;pointer&lt;/code&gt; should be the name of a variable that will point to the newly allocated memory.</source>
          <target state="translated">第一个参数 &lt;code&gt;pointer&lt;/code&gt; 应该是将指向新分配的内存的变量的名称。</target>
        </trans-unit>
        <trans-unit id="4f43aa625d664f2ba3718ef0a1149ca5df8580dd" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;setlocale()&lt;/code&gt; gives the &lt;b&gt;category&lt;/b&gt;, the second the &lt;b&gt;locale&lt;/b&gt;. The category tells in what aspect of data processing you want to apply locale-specific rules. Category names are discussed in &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/a&gt; and &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;. The locale is the name of a collection of customization information corresponding to a particular combination of language, country or territory, and codeset. Read on for hints on the naming of locales: not all systems name locales as in the example.</source>
          <target state="translated">&lt;code&gt;setlocale()&lt;/code&gt; 的第一个参数给出&lt;b&gt;类别&lt;/b&gt;，第二个参数给出&lt;b&gt;locale&lt;/b&gt;。类别告诉您要在数据处理的哪个方面应用特定于语言环境的规则。类别名称在&amp;ldquo; &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;本地类别&lt;/a&gt;和&lt;a href=&quot;#ENVIRONMENT&quot;&gt;环境&amp;rdquo;中&lt;/a&gt;进行了讨论。语言环境是与语言，国家或地区和代码集的特定组合相对应的定制信息集合的名称。请继续阅读以获取有关语言环境命名的提示：并非所有系统都像示例中那样命名语言环境。</target>
        </trans-unit>
        <trans-unit id="7d7b3a91ac2b665d00253c60dfd683fd8e3981ca" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;find()&lt;/code&gt; is either a code reference to your &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function, or a hash reference describing the operations to be performed for each file. The code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;The wanted function&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;find()&lt;/code&gt; 的第一个参数要么是对 &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 函数的代码引用，要么是描述每个文件要执行的操作的哈希引用。下面的&lt;a href=&quot;#The-wanted-function&quot;&gt;&amp;ldquo;所需功能&amp;rdquo;&lt;/a&gt;中介绍了代码参考。</target>
        </trans-unit>
        <trans-unit id="4cbf5c859ede86efd02d67b5ed562cbefaa9fa86" translate="yes" xml:space="preserve">
          <source>The first call creates a mortal SV (with no value), the second converts an existing SV to a mortal SV (and thus defers a call to &lt;code&gt;SvREFCNT_dec&lt;/code&gt; ), and the third creates a mortal copy of an existing SV. Because &lt;code&gt;sv_newmortal&lt;/code&gt; gives the new SV no value, it must normally be given one via &lt;code&gt;sv_setpv&lt;/code&gt; , &lt;code&gt;sv_setiv&lt;/code&gt; , etc. :</source>
          <target state="translated">第一个调用创建一个普通SV（无值），第二个调用将现有SV转换为普通SV（从而推迟对 &lt;code&gt;SvREFCNT_dec&lt;/code&gt; 的调用），第三个调用创建现有SV的普通副本。因为 &lt;code&gt;sv_newmortal&lt;/code&gt; 没有给新的SV值，所以通常必须通过 &lt;code&gt;sv_setpv&lt;/code&gt; ， &lt;code&gt;sv_setiv&lt;/code&gt; 等给它一个值：</target>
        </trans-unit>
        <trans-unit id="4477498f36568777dd7d39a288f8eb78c180c0b5" translate="yes" xml:space="preserve">
          <source>The first call will cache the result, say 37, in the scalar cache; the second will cach the list &lt;code&gt;(37)&lt;/code&gt; in the list cache. The third call doesn't call the real &lt;code&gt;complicated&lt;/code&gt; function; it gets the value 37 from the scalar cache.</source>
          <target state="translated">第一次调用会将结果（例如37）缓存在标量缓存中；第二个将缓存列表缓存中的列表 &lt;code&gt;(37)&lt;/code&gt; 。第三次调用不调用真正的 &lt;code&gt;complicated&lt;/code&gt; 函数；它从标量缓存中获取值37。</target>
        </trans-unit>
        <trans-unit id="cb2fb10ae2990b48a149ecb6c3ef672018aecbe1" translate="yes" xml:space="preserve">
          <source>The first call-back registered is the call back for waiting. It is expected that the callback will call the current event loop until there is something waiting to get on the input filehandle. The parameter passed in is the return value of the second call back.</source>
          <target state="translated">注册的第一个回调是等待的回调。预计该回调将调用当前的事件循环,直到在输入的文件handle上有等待得到的东西。传入的参数是第二个回调的返回值。</target>
        </trans-unit>
        <trans-unit id="98e0061b9a6b011cebcff05349c5ac1b63fa9755" translate="yes" xml:space="preserve">
          <source>The first code point of the foldcased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">折叠版本的第一个代码点被返回(但请注意,正如上面所解释的,可能有更多的代码点)。</target>
        </trans-unit>
        <trans-unit id="bff810cbc1a30c3df94411ded7219d0513e8678c" translate="yes" xml:space="preserve">
          <source>The first code point of the lowercased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">返回小写版本的第一个代码点(但请注意,如上所述,可能有更多的代码点)。</target>
        </trans-unit>
        <trans-unit id="caeb3f58f789aa5ac3e09cf711fff7133bd0293e" translate="yes" xml:space="preserve">
          <source>The first code point of the titlecased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">返回titlecased版本的第一个代码点(但请注意,如上所述,可能会有更多。</target>
        </trans-unit>
        <trans-unit id="150061371074e1d388cb756c8513ea3bae095580" translate="yes" xml:space="preserve">
          <source>The first code point of the uppercased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">返回大写版本的第一个代码点(但请注意,如上所述,可能会有更多的代码点)。</target>
        </trans-unit>
        <trans-unit id="b31a69e396cbea336ac162c9e038d50204a60559" translate="yes" xml:space="preserve">
          <source>The first column gives the Unicode code point of the character (in hex format), the second column gives the (Unicode) name. The third column indicates by which class(es) the character is matched (assuming no locale is in effect that changes the &lt;code&gt;\s&lt;/code&gt; matching).</source>
          <target state="translated">第一列给出了字符的Unicode代码点（以十六进制格式），第二列给出了（Unicode）名称。第三列表示匹配字符的类别（假定没有有效的语言环境会更改 &lt;code&gt;\s&lt;/code&gt; 匹配）。</target>
        </trans-unit>
        <trans-unit id="8beadb10ab71cda6dd02fa1a65287381a215cc85" translate="yes" xml:space="preserve">
          <source>The first column in the table is a name for the property; the second column is an alternative name, if any, plus possibly some annotations. The alternative name is the property's full name, unless that would simply repeat the first column, in which case the second column indicates the property's short name (if different). The annotations are given only in the entry for the full name. If a property is obsolete, etc, the entry will be flagged with the same characters used in the table in the &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;section above&lt;/a&gt;, like &lt;b&gt;D&lt;/b&gt; or &lt;b&gt;S&lt;/b&gt;.</source>
          <target state="translated">表中的第一列是属性的名称；第二列是备用名称（如果有的话）以及可能的一些注释。替代名称是属性的全名，除非那会简单地重复第一列，在这种情况下，第二列表示属性的简称（如果不同）。注释仅在全名条目中给出。如果属性是过时的，等等，该条目将与在表中使用的相同的字符进行标记&lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;上面的部分&lt;/a&gt;，象&lt;b&gt;d&lt;/b&gt;或&lt;b&gt;小号&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="6b11168c63a090c6a2f9c94f928cd13ec49996f7" translate="yes" xml:space="preserve">
          <source>The first command sends both standard out and standard error to the temporary file. The second command sends only the old standard output there, and the old standard error shows up on the old standard out.</source>
          <target state="translated">第一条命令将标准输出和标准错误都发送到临时文件中。第二条命令只将旧的标准输出发送到那里,而旧的标准错误则显示在旧的标准输出上。</target>
        </trans-unit>
        <trans-unit id="05c623db7c7d3a79e0f86ce6c1022ffde1e91677" translate="yes" xml:space="preserve">
          <source>The first element of @os_flavor is the major family (ie. Unix, Windows, VMS, OS/2, etc...) and the rest are sub families.</source>
          <target state="translated">@os_flavor的第一个元素是主要家族(即Unix、Windows、VMS、OS/2等),其余为子家族。</target>
        </trans-unit>
        <trans-unit id="4b34621cb98b9f5d1895e9bf56ac10c10fa486de" translate="yes" xml:space="preserve">
          <source>The first example will be driven by an object of the class CPAN::Module, the second by an object of class CPAN::Distribution.</source>
          <target state="translated">第一个例子将由CPAN::Module类的对象驱动,第二个例子由CPAN::Distribution类的对象驱动。</target>
        </trans-unit>
        <trans-unit id="0a27c7509a2d370dd780c83c9db9ebfcd9028447" translate="yes" xml:space="preserve">
          <source>The first extension is an embedded comment &lt;code&gt;(?#text)&lt;/code&gt;. This embeds a comment into the regular expression without affecting its meaning. The comment should not have any closing parentheses in the text. An example is</source>
          <target state="translated">第一个扩展是嵌入式注释 &lt;code&gt;(?#text)&lt;/code&gt; 。这会将注释嵌入到正则表达式中，而不会影响其含义。注释的文本中不应包含任何右括号。一个例子是</target>
        </trans-unit>
        <trans-unit id="222cb4b3d3e8dffe112445249bb168e941db04b2" translate="yes" xml:space="preserve">
          <source>The first extra instruction sets DJGPP's FNCASE environment variable so that the new perl binary which you must build for an XS-type module will build correctly. The second extra instruction re-builds the perl binary in your module directory before you run &quot;make test&quot;, so that you are testing with the new module code you built with &quot;make&quot;. The third extra instruction installs the perl binary from your module directory into the standard DJGPP binary directory, &lt;code&gt;($DJDIR)/bin&lt;/code&gt; , replacing your previous perl binary.</source>
          <target state="translated">第一条额外指令设置了DJGPP的FNCASE环境变量，以便您必须为XS类型的模块构建的新的perl二进制文件将正确构建。第二条额外的指令在运行&amp;ldquo; make test&amp;rdquo;之前在模块目录中重新构建perl二进制文件，以便使用由&amp;ldquo; make&amp;rdquo;构建的新模块代码进行测试。第三条额外的指令将perl二进制文件从模块目录安装到标准DJGPP二进制目录 &lt;code&gt;($DJDIR)/bin&lt;/code&gt; ，替换先前的perl二进制文件。</target>
        </trans-unit>
        <trans-unit id="34b17d18688be07602898309d70943af3ccee567" translate="yes" xml:space="preserve">
          <source>The first few members of the struct give a function table size for compatibility check &quot;name&quot; for the layer, the size to &lt;code&gt;malloc&lt;/code&gt; for the per-instance data, and some flags which are attributes of the class as whole (such as whether it is a buffering layer), then follow the functions which fall into four basic groups:</source>
          <target state="translated">结构的前几个成员为层提供兼容性检查的功能表大小&amp;ldquo;名称&amp;rdquo;，针对每个实例数据的 &lt;code&gt;malloc&lt;/code&gt; 大小以及作为类整体属性的一些标志（例如是否为缓冲层），然后遵循分为四个基本组的功能：</target>
        </trans-unit>
        <trans-unit id="5570358324850dc9a5c098d989e656b82d59427c" translate="yes" xml:space="preserve">
          <source>The first five of these are like the escape sequences &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\F&lt;/code&gt; . For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;; For Foldcase, see &lt;a href=&quot;#Foldcase&quot;&gt;Foldcase&lt;/a&gt;.</source>
          <target state="translated">这些前五个就像是转义序列 &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\U&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; ，和 &lt;code&gt;\F&lt;/code&gt; 。有关Titlecase的信息，请参见&lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;。对于Foldcase，请参见&lt;a href=&quot;#Foldcase&quot;&gt;Foldcase&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="056eb59b4cd627258e760e1417c53352badda0af" translate="yes" xml:space="preserve">
          <source>The first form causes the most-significant</source>
          <target state="translated">第一种形式造成最显著的。</target>
        </trans-unit>
        <trans-unit id="655fd20aca46eac1f13d92b5af802dc31b11d56c" translate="yes" xml:space="preserve">
          <source>The first form is used to request a</source>
          <target state="translated">第一张表格是用来申请</target>
        </trans-unit>
        <trans-unit id="37eddcbe0416a7dc5593d702e9505efc3b548dce" translate="yes" xml:space="preserve">
          <source>The first form lists all distribution files in and below an author's CPAN directory as stored in the CHECKSUMS files distributed on CPAN. The listing recurses into subdirectories.</source>
          <target state="translated">第一种形式列出了作者CPAN目录下的所有发行文件,这些文件存储在CPAN上发行的CHECKSUMS文件中。该列表循环到子目录中。</target>
        </trans-unit>
        <trans-unit id="46eae92ecd4f74796835635e06aeea1b041739b2" translate="yes" xml:space="preserve">
          <source>The first function calculates the length of the string to be appended by using &lt;code&gt;strlen&lt;/code&gt; . In the second, you specify the length of the string yourself. The third function processes its arguments like &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; and appends the formatted output. The fourth function works like &lt;code&gt;vsprintf&lt;/code&gt; . You can specify the address and length of an array of SVs instead of the va_list argument. The fifth function extends the string stored in the first SV with the string stored in the second SV. It also forces the second SV to be interpreted as a string.</source>
          <target state="translated">第一个函数使用 &lt;code&gt;strlen&lt;/code&gt; 计算要附加的字符串的长度。在第二个中，您自己指定字符串的长度。第三个函数处理其参数，如 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; ,并附加格式化的输出。第四个功能类似于 &lt;code&gt;vsprintf&lt;/code&gt; 。您可以指定SV数组的地址和长度，而不是va_list参数。第五功能用存储在第二SV中的字符串扩展存储在第一SV中的字符串。它还会强制将第二个SV解释为字符串。</target>
        </trans-unit>
        <trans-unit id="50f464748e3494ffffc2bddda9e0371a39740923" translate="yes" xml:space="preserve">
          <source>The first function takes a literal string, the second uses the string stored in the SV. Remember that a stash is just a hash table, so you get back an &lt;code&gt;HV*&lt;/code&gt; . The &lt;code&gt;flags&lt;/code&gt; flag will create a new package if it is set to GV_ADD.</source>
          <target state="translated">第一个函数使用文字字符串，第二个函数使用存储在SV中的字符串。请记住，存储只是一个哈希表，因此您将获得 &lt;code&gt;HV*&lt;/code&gt; 。如果将 &lt;code&gt;flags&lt;/code&gt; 标志设置为GV_ADD，它将创建一个新程序包。</target>
        </trans-unit>
        <trans-unit id="835ff098919bab433ee120cffa3fe9f71b92c1c9" translate="yes" xml:space="preserve">
          <source>The first gives data on bucket chain lengths and provides insight on how much work a fetch *miss* will take. In this case we have to inspect every item in a bucket before we can be sure the item is not in the list. The performance for an insert is equivalent to this case, as is a delete where the item is not in the hash.</source>
          <target state="translated">第一个给出了关于桶链长度的数据,并提供了关于取*漏的工作量的见解。在这种情况下,我们必须检查桶中的每一个项目,然后才能确定项目不在列表中。插入的性能等同于这种情况,项目不在哈希中的删除也是如此。</target>
        </trans-unit>
        <trans-unit id="44b1707c0aa3d824f6a27ecfef8a4304420287cd" translate="yes" xml:space="preserve">
          <source>The first interface is an object approach. &lt;code&gt;IO::Dir&lt;/code&gt; provides an object constructor and methods, which are just wrappers around perl's built in directory reading routines.</source>
          <target state="translated">第一个接口是一种对象方法。 &lt;code&gt;IO::Dir&lt;/code&gt; 提供了一个对象构造函数和方法，它们只是perl内置的目录读取例程的包装。</target>
        </trans-unit>
        <trans-unit id="f4941dd26bc8de71bda8bbde95f00b715fc9713b" translate="yes" xml:space="preserve">
          <source>The first is an asterisk &lt;code&gt;*&lt;/code&gt; to match any sequence of zero or more characters.</source>
          <target state="translated">第一个是星号 &lt;code&gt;*&lt;/code&gt; ,用于匹配零个或多个字符的任何序列。</target>
        </trans-unit>
        <trans-unit id="e06aed8ca3d744d52c854ac09d0dcc88676f13d3" translate="yes" xml:space="preserve">
          <source>The first is the '*' metacharacter. This will be replaced by the complete filename matched by the input file glob. So</source>
          <target state="translated">第一个是'*'元字符。这将被输入文件 glob 所匹配的完整文件名所取代。所以</target>
        </trans-unit>
        <trans-unit id="53f5cd295a83b9a3745b8897953b75db40666387" translate="yes" xml:space="preserve">
          <source>The first is the 'default' format, which is used in both basic and exec modes to print all opcodes. The 2nd, goto-format, is used in exec mode when branches are encountered. They're not real opcodes, and are inserted to look like a closing curly brace. The tree-format is tree specific.</source>
          <target state="translated">第一种是 &quot;默认 &quot;格式,在基本模式和执行模式下都用于打印所有操作码。第2种是goto-format,在执行模式中遇到分支时使用。它们并不是真正的操作码,而是被插入的,看起来像一个收尾的大括号。树格式是针对树的。</target>
        </trans-unit>
        <trans-unit id="40fe0d63874f53e08f9d51c255d101fe5f08a938" translate="yes" xml:space="preserve">
          <source>The first line (with Index [0]) means that the value for code point 0 is &quot;Basic Latin&quot;. The entry &quot;0x0080&quot; in the @blocks_ranges column in the second line means that the value from the first line, &quot;Basic Latin&quot;, extends to all code points in the range from 0 up to but not including 0x0080, that is, through 127. In other words, the code points from 0 to 127 are all in the &quot;Basic Latin&quot; block. Similarly, all code points in the range from 0x0080 up to (but not including) 0x0100 are in the block named &quot;Latin-1 Supplement&quot;, etc. (Notice that the return is the old-style block names; see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">第一行（索引为[0]）表示代码点0的值为&amp;ldquo;基本拉丁语&amp;rdquo;。第二行的@blocks_ranges列中的条目&amp;ldquo; 0x0080&amp;rdquo;表示第一行的值&amp;ldquo;基本拉丁语&amp;rdquo;扩展到从0到但不包括0x0080（即到127）的所有代码点换句话说，从0到127的代码点都在&amp;ldquo;基本拉丁语&amp;rdquo;块中。同样，从0x0080到（但不包括）0x0100范围内的所有代码点都在名为&amp;ldquo; Latin-1 Supplement&amp;rdquo;的块中，依此类推。（注意，返回的是旧样式的块名称；请参见&lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;旧样式与新样式的块名称&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0686c2b572c16f799b84765daa2d3e48250c69f7" translate="yes" xml:space="preserve">
          <source>The first line above defines &lt;code&gt;TIMESTAMP&lt;/code&gt; as a 9-element list, as returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; in list context. To set it to the string returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; in scalar context, an explicit &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; keyword is required.</source>
          <target state="translated">上面的第一行将 &lt;code&gt;TIMESTAMP&lt;/code&gt; 定义为由9个元素组成的列表，由 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 返回。要将其设置为标量上下文中 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 返回的字符串，需要一个显式的 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="9d82ab0cc733d5c69ba599aa083f54d41b0cd704" translate="yes" xml:space="preserve">
          <source>The first line ensures that the errors in your argument specification are found early. When you ship your application you should comment out the first line, since it makes the second one useless.</source>
          <target state="translated">第一行确保你的参数规范中的错误被尽早发现。当你发布你的应用程序时,你应该注释掉第一行,因为它使第二行毫无用处。</target>
        </trans-unit>
        <trans-unit id="1d816990178774f44d4b8769d3c845c853e30a87" translate="yes" xml:space="preserve">
          <source>The first line here indicates that the offset/length table contains 45 entries. Each entry is a pair of integers, denoted by &lt;code&gt;offset[&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;]&lt;/code&gt; . Entries are numbered starting with 1, so entry #1 here is &lt;code&gt;1[4]&lt;/code&gt; and entry #12 is &lt;code&gt;5[1]&lt;/code&gt; . &lt;code&gt;1[4]&lt;/code&gt; indicates that the node labeled &lt;code&gt;1:&lt;/code&gt; (the &lt;code&gt;1: ANYOF[bc]&lt;/code&gt;) begins at character position 1 in the pre-compiled form of the regex, and has a length of 4 characters. &lt;code&gt;5[1]&lt;/code&gt; in position 12 indicates that the node labeled &lt;code&gt;12:&lt;/code&gt; (the &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt;) begins at character position 5 in the pre-compiled form of the regex, and has a length of 1 character. &lt;code&gt;12[1]&lt;/code&gt; in position 14 indicates that the node labeled &lt;code&gt;14:&lt;/code&gt; (the &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt;) begins at character position 12 in the pre-compiled form of the regex, and has a length of 1 character---that is, it corresponds to the &lt;code&gt;+&lt;/code&gt; symbol in the precompiled regex.</source>
          <target state="translated">第一行表示偏移量/长度表包含45个条目。每个条目都是一对整数，由 &lt;code&gt;offset[&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;]&lt;/code&gt; 。条目从1开始编号，因此此处的条目＃1为 &lt;code&gt;1[4]&lt;/code&gt; ，条目＃12为 &lt;code&gt;5[1]&lt;/code&gt; 。 &lt;code&gt;1[4]&lt;/code&gt; 表示标记为 &lt;code&gt;1:&lt;/code&gt; 的节点（即 &lt;code&gt;1: ANYOF[bc]&lt;/code&gt; ）以正则表达式的预编译形式在字符位置1处开始，并且长度为4个字符。 &lt;code&gt;5[1]&lt;/code&gt; 中位置12表示该节点标记 &lt;code&gt;12:&lt;/code&gt; （在 &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt; ）在正则表达式的所述预编译的形式的字符位置5开始，并且具有1个字符的长度。 &lt;code&gt;12[1]&lt;/code&gt; 中位置14表示该节点标记 &lt;code&gt;14:&lt;/code&gt; （在 &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt; ）开始于该正则表达式的所述预编译的形式的字符位置12，且具有1个字符的长度---也就是说，它对应于预编译的正则表达式中的 &lt;code&gt;+&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="3daa98ec524432df6c19e25f5089a0ae5fbe0898" translate="yes" xml:space="preserve">
          <source>The first line is an abbreviation for the following two lines, except that it doesn't create the superfluous array variable &lt;code&gt;@array&lt;/code&gt; .</source>
          <target state="translated">第一行是以下两行的缩写，不同之处在于它不会创建多余的数组变量 &lt;code&gt;@array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f07b113f7912ed4a47b2646ff4b1fee0ebfd1d07" translate="yes" xml:space="preserve">
          <source>The first line of the commit message should be a short description without a period. It should be no longer than the subject line of an email, 50 characters being a good rule of thumb.</source>
          <target state="translated">提交信息的第一行应该是一个简短的描述,不要有句号。它不应该比电子邮件的主题行长,50个字符是一个好的经验法则。</target>
        </trans-unit>
        <trans-unit id="ae7ce29a18436b04a3b95f17b59a8ba620a5dab2" translate="yes" xml:space="preserve">
          <source>The first line shows the pre-compiled form of the regex. The second shows the size of the compiled form (in arbitrary units, usually 4-byte words) and the total number of bytes allocated for the offset/length table, usually 4+&lt;code&gt;size&lt;/code&gt; *8. The next line shows the label</source>
          <target state="translated">第一行显示了正则表达式的预编译形式。第二个显示了已编译表格的大小（以任意单位，通常为4个字节字），以及为偏移量/长度表分配的字节总数，通常为4+ &lt;code&gt;size&lt;/code&gt; * 8。下一行显示标签</target>
        </trans-unit>
        <trans-unit id="c7723c265ae779d21866a1c9e48b6be3d9e2e441" translate="yes" xml:space="preserve">
          <source>The first method takes periodically samples of the CPU program counter, and since the program counter can be correlated with the code generated for functions, we get a statistical view of in which functions the program is spending its time. The caveats are that very small/fast functions have lower probability of showing up in the profile, and that periodically interrupting the program (this is usually done rather frequently, in the scale of milliseconds) imposes an additional overhead that may skew the results. The first problem can be alleviated by running the code for longer (in general this is a good idea for profiling), the second problem is usually kept in guard by the profiling tools themselves.</source>
          <target state="translated">第一种方法周期性地抽取CPU程序计数器的样本,由于程序计数器可以与函数生成的代码相关联,我们可以统计出程序在哪些函数中花费了时间。需要注意的是,非常小/快的函数在配置文件中出现的概率较低,而且周期性地中断程序(这通常是相当频繁的,以毫秒为单位)会带来额外的开销,可能会扭曲结果。第一个问题可以通过延长代码运行时间来缓解(一般来说,这对剖析来说是个好主意),第二个问题通常由剖析工具本身来把关。</target>
        </trans-unit>
        <trans-unit id="108fd116edbd3a8efddc6a912d5c851d634fe27e" translate="yes" xml:space="preserve">
          <source>The first name is called the</source>
          <target state="translated">第一个名字叫做</target>
        </trans-unit>
        <trans-unit id="3c95867addff6e3f2248f91516c23a2994856b3e" translate="yes" xml:space="preserve">
          <source>The first of the three available techniques is to write the filter completely in C. The external module you create interfaces directly with the source filter hooks provided by Perl.</source>
          <target state="translated">三种可用技术中的第一种是完全用C语言编写过滤器,你创建的外部模块直接与Perl提供的源过滤器钩子接口。</target>
        </trans-unit>
        <trans-unit id="2cf31ee7914fd21827d64f65da992c78e2dd2481" translate="yes" xml:space="preserve">
          <source>The first of these is the operand providing the overloaded operator implementation - in this case, the object whose &lt;code&gt;minus()&lt;/code&gt; method is being called.</source>
          <target state="translated">其中第一个是提供重载运算符实现的操作数-在这种情况下，将调用其 &lt;code&gt;minus()&lt;/code&gt; 方法的对象。</target>
        </trans-unit>
        <trans-unit id="32df19252ad74319d4ce1046b1c9ffb0a16536ba" translate="yes" xml:space="preserve">
          <source>The first of these two functions checks if a hash table entry exists, and the second deletes it.</source>
          <target state="translated">这两个函数中的第一个函数检查一个哈希表条目是否存在,第二个函数删除它。</target>
        </trans-unit>
        <trans-unit id="2baee74dbd5d9705ba409f49c41818c111db8f9c" translate="yes" xml:space="preserve">
          <source>The first one explicitly passes in the context, which is needed for e.g. threaded builds. The second one does that implicitly; do not get them mixed. If you are not passing in a aTHX_, you will need to do a dTHX (or a dVAR) as the first thing in the function.</source>
          <target state="translated">第一种是显式传递上下文,这对于线程构建等来说是需要的,第二种是隐式传递,不要把它们混为一谈。第二种是隐式的,不要把它们混为一谈。如果你没有传入 aTHX_,你需要在函数中首先做一个 dTHX (或 dVAR)。</target>
        </trans-unit>
        <trans-unit id="b5d9b746eaf9594387396efaab0691495a0a8b7a" translate="yes" xml:space="preserve">
          <source>The first one is &lt;code&gt;&quot;format&quot;&lt;/code&gt; , which is a sprintf()-style format string to be used for both numeric parts of the complex number(s). The is somewhat system-dependent but most often it corresponds to &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt; . You can revert to the default by setting the &lt;code&gt;&lt;a href=&quot;../functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">第一个是 &lt;code&gt;&quot;format&quot;&lt;/code&gt; ，它是sprintf（）样式的格式字符串，用于复数的两个数字部分。它在某种程度上取决于系统，但通常与 &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt; 相对应。您可以通过将 &lt;code&gt;&lt;a href=&quot;../functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 设置为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 来还原为默认值。</target>
        </trans-unit>
        <trans-unit id="64110520d33c3683502b6895ec7f686e2b691a83" translate="yes" xml:space="preserve">
          <source>The first one is a B::PADNAMELIST under Perl 5.22, and a B::AV under earlier versions. The rest are currently B::AV objects, but that could change in future versions.</source>
          <target state="translated">第一个是Perl 5.22下的B::PADNAMELIST,以及早期版本下的B::AV。其余的目前是B::AV对象,但在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="53ea0aa1b4ed42878caaa6bf56a3d5e35dfb1b12" translate="yes" xml:space="preserve">
          <source>The first parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;*.tar.gz&lt;/code&gt;, is an</source>
          <target state="translated">第一个参数 &lt;code&gt;globmap&lt;/code&gt; ， &lt;code&gt;*.tar.gz&lt;/code&gt; ，是</target>
        </trans-unit>
        <trans-unit id="2f7f0d7f3250dff196379a82ef1042cf92584eab" translate="yes" xml:space="preserve">
          <source>The first part of each item is the language tag, between {...}. It is followed by an English name for the language or language-group. Language tags that I judge to be not for general use, are bracketed.</source>
          <target state="translated">每个项目的第一部分是语言标签,位于{...}之间。后面是该语言或语言组的英文名称。我认为不适合一般使用的语言标签被放在括号里。</target>
        </trans-unit>
        <trans-unit id="2850ab20f1390861bb35445270293546335b53f4" translate="yes" xml:space="preserve">
          <source>The first part of the report already shows the critical information regarding which subroutines are using the most time. The next gives some statistics about the source files profiled.</source>
          <target state="translated">报告的第一部分已经显示了关于哪些子程序使用时间最多的关键信息。接下来给出了一些关于源文件的统计资料。</target>
        </trans-unit>
        <trans-unit id="397f188600044026c7930c78c4ec45f2d657488a" translate="yes" xml:space="preserve">
          <source>The first pass is finding the end of the quoted construct. This results in saving to a safe location a copy of the text (between the starting and ending delimiters), normalized as necessary to avoid needing to know what the original delimiters were.</source>
          <target state="translated">第一道是找到引用结构的结尾。这样做的结果是将文本的副本保存到一个安全的位置(在开始和结束定界符之间),必要时进行规范化处理,以避免需要知道原始定界符是什么。</target>
        </trans-unit>
        <trans-unit id="90fe7088bb4f27d081fbb7bc1dcf8f8999b582b8" translate="yes" xml:space="preserve">
          <source>The first quantifier '.*' starts out by matching the whole string 'the cat in the hat'.</source>
          <target state="translated">第一个量化符'.*'开始匹配整个字符串'the cat in the hat'。</target>
        </trans-unit>
        <trans-unit id="9c1c8c14ec1e3a07903d82f126aec6635328f772" translate="yes" xml:space="preserve">
          <source>The first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much of the string as possible while still having the regex match. The second quantifier &lt;code&gt;.*&lt;/code&gt; has no string left to it, so it matches 0 times.</source>
          <target state="translated">第一个量词 &lt;code&gt;.*&lt;/code&gt; 在保持正则表达式匹配的同时，尽可能多地捕获字符串。第二个量词 &lt;code&gt;.*&lt;/code&gt; 没有剩余的字符串，因此它匹配0次。</target>
        </trans-unit>
        <trans-unit id="6e528105bd9590f0533aed7b713042470a33b8f6" translate="yes" xml:space="preserve">
          <source>The first reason is that this technique</source>
          <target state="translated">第一个原因是,这种技术</target>
        </trans-unit>
        <trans-unit id="b01253c2ebd001b8b295bfdd61014e6f7807bcd2" translate="yes" xml:space="preserve">
          <source>The first regexp &lt;code&gt;world&lt;/code&gt; doesn't match because regexps are case-sensitive. The second regexp matches because the substring &lt;code&gt;'o W'&lt;/code&gt; occurs in the string &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; . The space character ' ' is treated like any other character in a regexp and is needed to match in this case. The lack of a space character is the reason the third regexp &lt;code&gt;'oW'&lt;/code&gt; doesn't match. The fourth regexp &lt;code&gt;'World '&lt;/code&gt; doesn't match because there is a space at the end of the regexp, but not at the end of the string. The lesson here is that regexps must match a part of the string</source>
          <target state="translated">第一个regexp &lt;code&gt;world&lt;/code&gt; 不匹配，因为regexp 区分大小写。第二个正则表达式匹配，因为子字符串 &lt;code&gt;'o W'&lt;/code&gt; 出现在字符串 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 。空格字符''就像正则表达式中的其他任何字符一样，在这种情况下需要匹配。缺少空格字符是第三个正则表达式 &lt;code&gt;'oW'&lt;/code&gt; 不匹配的原因。第四个regexp'World &lt;code&gt;'World '&lt;/code&gt; 不匹配，因为在regexp的末尾有一个空格，但在字符串的末尾没有空格。这里的教训是正则表达式必须与字符串的一部分匹配</target>
        </trans-unit>
        <trans-unit id="ddca4d833894463530776d04e09076c4eab205cd" translate="yes" xml:space="preserve">
          <source>The first regexp doesn't match because the string has more to it than &lt;code&gt;keep&lt;/code&gt; . Since the second regexp is exactly the string, it matches. Using both &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; in a regexp forces the complete string to match, so it gives you complete control over which strings match and which don't. Suppose you are looking for a fellow named bert, off in a string by himself:</source>
          <target state="translated">第一个regexp不匹配，因为该字符串比 &lt;code&gt;keep&lt;/code&gt; 具有更多的功能。由于第二个正则表达式恰好是字符串，因此它匹配。在正则表达式中同时使用 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 会强制匹配完整的字符串，因此可以完全控制哪些字符串匹配以及哪些字符串不匹配。假设您正在寻找一个名叫bert的家伙，他自己是一个字符串：</target>
        </trans-unit>
        <trans-unit id="187948592e3895c96d921caa597048a315b504cd" translate="yes" xml:space="preserve">
          <source>The first reports that both those the hashes contain the same data, while the second reports that they do not. Which you prefer is left as an exercise to the reader.</source>
          <target state="translated">第一个报告说这两个哈希值包含相同的数据,而第二个报告说它们不包含相同的数据。你更喜欢哪种说法,留给读者去研究。</target>
        </trans-unit>
        <trans-unit id="8860a773058066d93bd3eee9e9232f1b245f86d6" translate="yes" xml:space="preserve">
          <source>The first section describes POSIX functions from the 1003.1 specification. The second section describes some classes for signal objects, TTY objects, and other miscellaneous objects. The remaining sections list various constants and macros in an organization which roughly follows IEEE Std 1003.1b-1993.</source>
          <target state="translated">第一节介绍了1003.1规范中的POSIX函数。第二节介绍了信号对象、TTY对象和其他杂项对象的一些类。其余部分列出了各种常量和宏,其组织结构大致遵循IEEE Std 1003.1b-1993。</target>
        </trans-unit>
        <trans-unit id="9a3305f1afd295681118d876dec01ed7a5b8a456" translate="yes" xml:space="preserve">
          <source>The first section maps various C data types to a name, which corresponds somewhat with the various Perl types. The second section contains C code which &lt;b&gt;xsubpp&lt;/b&gt; uses to handle input parameters. The third section contains C code which &lt;b&gt;xsubpp&lt;/b&gt; uses to handle output parameters.</source>
          <target state="translated">第一部分将各种C数据类型映射为一个名称，该名称在某种程度上与各种Perl类型相对应。第二部分包含&lt;b&gt;xsubpp&lt;/b&gt;用于处理输入参数的C代码。第三部分包含&lt;b&gt;xsubpp&lt;/b&gt;用于处理输出参数的C代码。</target>
        </trans-unit>
        <trans-unit id="5dec21809b3e94bb56bbf06b1ab08c273929b8df" translate="yes" xml:space="preserve">
          <source>The first section of this document provides an itemized checklist; subsequent sections provide a more detailed discussion of the items on the list. The final section, &quot;Common Pitfalls&quot;, describes some of the most popular mistakes made by CPAN authors.</source>
          <target state="translated">本文件的第一节提供了一个逐项核对清单;随后的章节对清单上的项目进行了更详细的讨论。最后一节 &quot;常见错误 &quot;描述了CPAN作者最常犯的一些错误。</target>
        </trans-unit>
        <trans-unit id="873fa0119aa76096529ccc05f5ae97f00f810fd3" translate="yes" xml:space="preserve">
          <source>The first set of stats gives some summary statistical information, including the quality score translated into &quot;Good&quot;, &quot;Poor&quot; and &quot;Bad&quot;, (score&amp;lt;=1.05, score&amp;lt;=1.2, score&amp;gt;1.2). See the documentation in bucket_stats() for more details.</source>
          <target state="translated">第一组统计信息提供了一些摘要统计信息，包括转换为&amp;ldquo;好&amp;rdquo;，&amp;ldquo;差&amp;rdquo;和&amp;ldquo;差&amp;rdquo;的质量得分（得分&amp;lt;= 1.05，得分&amp;lt;= 1.2，得分&amp;gt; 1.2）。有关更多详细信息，请参见bucket_stats（）中的文档。</target>
        </trans-unit>
        <trans-unit id="da5f31247c2eb407c67afefcfd779d23549ec3df" translate="yes" xml:space="preserve">
          <source>The first situation being much more frequent, it makes sense to rewrite the boilerplate as</source>
          <target state="translated">第一种情况比较多,所以将模板改写成这样是有道理的。</target>
        </trans-unit>
        <trans-unit id="ad55dcbd2815a02cf9af8564c1fdb6a55d76bf9e" translate="yes" xml:space="preserve">
          <source>The first state may happen in &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; and &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handlers.</source>
          <target state="translated">第一种状态可能发生在 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 和 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 处理程序中。</target>
        </trans-unit>
        <trans-unit id="470d1d04836c0a5dd42cc354e122ff4ddc8f36a3" translate="yes" xml:space="preserve">
          <source>The first step is to add this line:</source>
          <target state="translated">第一步是增加这一行。</target>
        </trans-unit>
        <trans-unit id="1d92a911344060c6031358fbe99f5d7b26fb10e8" translate="yes" xml:space="preserve">
          <source>The first step of processing such a line is the conversion, to binary, of the hexadecimal data, to obtain the four fields, while checking the checksum. No surprise here: we'll start with a simple &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; call to convert everything to binary:</source>
          <target state="translated">处理此类行的第一步是在检查校验和的同时，将十六进制数据转换为二进制，以获得四个字段。毫不奇怪：我们将从一个简单的 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 调用开始，将所有内容转换为二进制：</target>
        </trans-unit>
        <trans-unit id="a2237935485a4e0e57cc8ab0badea71ce05f470d" translate="yes" xml:space="preserve">
          <source>The first string position that this regexp can match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; . At this position, the minimal &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}?&lt;/a&gt;&lt;/code&gt; matches just one &lt;code&gt;'m'&lt;/code&gt; . Although the second quantifier &lt;code&gt;.*?&lt;/code&gt; would prefer to match no characters, it is constrained by the end-of-string anchor &lt;code&gt;$&lt;/code&gt; to match the rest of the string.</source>
          <target state="translated">第一串中的位置，该正则表达式匹配可以是在第一 &lt;code&gt;'m'&lt;/code&gt; 中 &lt;code&gt;programming&lt;/code&gt; 。在这个位置，最小 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}?&lt;/a&gt;&lt;/code&gt; 仅匹配一个 &lt;code&gt;'m'&lt;/code&gt; 。虽然第二个量词 &lt;code&gt;.*?&lt;/code&gt; 宁愿不匹配任何字符，它受字符串结尾锚 &lt;code&gt;$&lt;/code&gt; 的约束，以匹配其余字符串。</target>
        </trans-unit>
        <trans-unit id="fea599d468c324040fff443da5016a605f7268fd" translate="yes" xml:space="preserve">
          <source>The first task in building a regexp is to decide what we want to match and what we want to exclude. In our case, we want to match both integers and floating point numbers and we want to reject any string that isn't a number.</source>
          <target state="translated">构建一个regexp的首要任务是决定我们要匹配的内容和要排除的内容。在我们的例子中,我们希望同时匹配整数和浮点数,并拒绝任何非数字的字符串。</target>
        </trans-unit>
        <trans-unit id="a253a2302f0dd4214c0fa19a3c7600e1aeb7c19f" translate="yes" xml:space="preserve">
          <source>The first thing after the &quot;=over&quot; command should be an &quot;=item&quot;, unless there aren't going to be any items at all in this &quot;=over&quot; ... &quot;=back&quot; region.</source>
          <target state="translated">在&quot;=over &quot;命令之后的第一件事应该是&quot;=item&quot;,除非在这个&quot;=over&quot;...&quot;=back &quot;区域中根本不会有任何物品。&quot;=back &quot;区域。</target>
        </trans-unit>
        <trans-unit id="b4182d2194d7b0a192c4908dabaf70426956c4b1" translate="yes" xml:space="preserve">
          <source>The first thread will grab a lock on &lt;code&gt;$x&lt;/code&gt; , then, after a pause during which the second thread has probably had time to do some work, try to grab a lock on &lt;code&gt;$y&lt;/code&gt; . Meanwhile, the second thread grabs a lock on &lt;code&gt;$y&lt;/code&gt; , then later tries to grab a lock on &lt;code&gt;$x&lt;/code&gt; . The second lock attempt for both threads will block, each waiting for the other to release its lock.</source>
          <target state="translated">第一个线程将在 &lt;code&gt;$x&lt;/code&gt; 上锁定一个锁，然后，在第二个线程可能有时间做一些工作的暂停之后，尝试在 &lt;code&gt;$y&lt;/code&gt; 上锁定一个锁。同时，第二个线程抓住 &lt;code&gt;$y&lt;/code&gt; 的锁，然后稍后尝试抓住 &lt;code&gt;$x&lt;/code&gt; 的锁。两个线程的第二次锁定尝试都将阻塞，每个线程都在等待对方释放其锁定。</target>
        </trans-unit>
        <trans-unit id="97805142bc0d01ba991305a8f5bc28f8f3fcba12" translate="yes" xml:space="preserve">
          <source>The first time through the loop, you will rewrite the entire file, from line 0 through the end. The second time through the loop, you will rewrite the entire file from line 1 through the end. The third time through the loop, you will rewrite the entire file from line 2 to the end. And so on.</source>
          <target state="translated">第一次通过循环,你将重写整个文件,从第0行到最后。第二次通过循环,你将重写整个文件,从第1行到最后。第三次通过循环,你将重写整个文件,从第2行到最后。以此类推。</target>
        </trans-unit>
        <trans-unit id="579873cee61866ba7eb29c6c1922769d306aac89" translate="yes" xml:space="preserve">
          <source>The first two fields give the total amount of memory perl sbrk(2)ed (ess-broken? :-) and number of sbrk(2)s used. The third number is what perl thinks about continuity of returned chunks. So long as this number is positive, malloc() will assume that it is probable that sbrk(2) will provide continuous memory.</source>
          <target state="translated">前两个字段给出了perl sbrk(2)ed的内存总量(ess-broken?:-)和使用的sbrk(2)的数量。第三个数字是perl认为返回的块的连续性。只要这个数字是正数,malloc()就会认为sbrk(2)很可能提供连续的内存。</target>
        </trans-unit>
        <trans-unit id="4becb05f0bd7170201aca65de03c239266000dbc" translate="yes" xml:space="preserve">
          <source>The first two forms return &lt;b&gt;true&lt;/b&gt; if the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; should not be produced by composition normalization. For the final two forms to return &lt;b&gt;true&lt;/b&gt;, it is additionally required that this fact not otherwise be determinable from the Unicode data base.</source>
          <target state="translated">如果不应通过合成规范化产生&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数，&lt;/a&gt;则前两种形式返回&lt;b&gt;true&lt;/b&gt;。为了使最后两种形式返回&lt;b&gt;true&lt;/b&gt;，还要求不能通过Unicode数据库确定此事实。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7edeb46a7cf77b29322b042169fd6545cca7858e" translate="yes" xml:space="preserve">
          <source>The first value to be substituted in the output string ( usually the column in a cursor addressing capability )</source>
          <target state="translated">在输出字符串中要替换的第一个值(通常是游标寻址能力中的列)。</target>
        </trans-unit>
        <trans-unit id="6c0a32c5664fb58c1965f29a470eb892918927d8" translate="yes" xml:space="preserve">
          <source>The first version of TAP to include an explicit version number is 13.</source>
          <target state="translated">TAP的第一个包含明确版本号的版本是13。</target>
        </trans-unit>
        <trans-unit id="ba908120df7bb5731ed530b89b4f89b55fe9cb39" translate="yes" xml:space="preserve">
          <source>The first version of this document appeared on Perl Monks, where several people had useful suggestions. Thank you, Perl Monks.</source>
          <target state="translated">本文档的第一版出现在 Perl Monks 上,有几个人提出了有用的建议。谢谢你,Perl Monks。</target>
        </trans-unit>
        <trans-unit id="af8e62f88abda0ab386f2cc101dff094b50fe117" translate="yes" xml:space="preserve">
          <source>The first version, the one without the indirect object, ran the</source>
          <target state="translated">第一个版本,没有间接对象的版本,运行的是</target>
        </trans-unit>
        <trans-unit id="8e5db8a38d2c3f00c90a5e9484dd046d60b873cc" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt; . Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">用于逐字记录文本和代码的固定宽度字体。默认为 &lt;code&gt;CW&lt;/code&gt; 。某些系统可能需要 &lt;code&gt;CR&lt;/code&gt; 。仅对&lt;b&gt;troff&lt;/b&gt;输出有效。</target>
        </trans-unit>
        <trans-unit id="4411138b75b6f4d0eb399c58a09f8dac2bce859c" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt; . Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for troff(1) output.</source>
          <target state="translated">用于逐字记录文本和代码的固定宽度字体。默认为 &lt;code&gt;CW&lt;/code&gt; 。某些系统可能需要 &lt;code&gt;CR&lt;/code&gt; 。仅对troff（1）输出有效。</target>
        </trans-unit>
        <trans-unit id="a5f7fca8c3cfcccf779409e2e759e639d09b18b3" translate="yes" xml:space="preserve">
          <source>The flag SVs_PADSTALE is cleared on lexicals each time the my() is executed, and set on scope exit. This allows the 'Variable $x is not available' warning to be generated in evals, such as</source>
          <target state="translated">每次执行my()时,标志SVs_PADSTALE在词法上被清除,并在作用域退出时设置。这允许在evals中生成 &quot;变量$x不可用 &quot;的警告,例如</target>
        </trans-unit>
        <trans-unit id="b78429f471bd064af1845edc82bca0aa6e6778ce" translate="yes" xml:space="preserve">
          <source>The flags UTF8_WARN_ILLEGAL_INTERCHANGE, UTF8_WARN_SURROGATE, UTF8_WARN_NONCHAR, and UTF8_WARN_SUPER will cause warning messages to be raised for their respective categories, but otherwise the code points are considered valid (not malformations). To get a category to both be treated as a malformation and raise a warning, specify both the WARN and DISALLOW flags. (But note that warnings are not raised if lexically disabled nor if UTF8_CHECK_ONLY is also specified.)</source>
          <target state="translated">标志UTF8_WARN_ILLEGAL_INTERCHANGE、UTF8_WARN_SURROGATE、UTF8_WARN_NONCHAR和UTF8_WARN_SUPER将导致各自类别的警告信息被引发,但除此之外,代码点被认为是有效的(不是畸形)。要想让一个类别既被视为畸形又引发警告,请同时指定WARN和DISALLOW标志。(但请注意,如果词法禁用或同时指定UTF8_CHECK_ONLY,则不会发出警告。)</target>
        </trans-unit>
        <trans-unit id="5e9a6e0acd0b69b277831006219122b07719e738" translate="yes" xml:space="preserve">
          <source>The flags default to zero, if you want something different you can either use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt; , or you can derive from POSIX::SigRt and define your own &lt;code&gt;new()&lt;/code&gt; (the tied hash STORE method of the &lt;code&gt;%SIGRT&lt;/code&gt; calls &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt; , where the &lt;code&gt;$rtsig&lt;/code&gt; ranges from zero to &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt; .</source>
          <target state="translated">这些标志默认为零，如果您想要不同的东西，可以在 &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt; 上使用 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ，也可以从POSIX :: SigRt派生并定义自己的 &lt;code&gt;new()&lt;/code&gt; （ &lt;code&gt;%SIGRT&lt;/code&gt; 调用 &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt; ，其中 &lt;code&gt;$rtsig&lt;/code&gt; 范围从零到 &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d13aa1a177f443868b50bc938e7eaafe94399ebc" translate="yes" xml:space="preserve">
          <source>The flags parameter is mandatory. The valid flag values are R_CURSOR, R_FIRST, R_LAST, R_NEXT and R_PREV.</source>
          <target state="translated">flags参数是必须设置的,有效的flag值是R_CURSOR,R_FIRST,R_LAST,R_NEXT和R_PREV。有效的flag值是R_CURSOR,R_FIRST,R_LAST,R_NEXT和R_PREV。</target>
        </trans-unit>
        <trans-unit id="3f1710e98626f16d762b28b22c17439d043e302f" translate="yes" xml:space="preserve">
          <source>The flags specify dictionary order and case folding:</source>
          <target state="translated">标志指定字典顺序和大小写折叠。</target>
        </trans-unit>
        <trans-unit id="10543ef8424f431d7ff14981f10f88f0c585ac15" translate="yes" xml:space="preserve">
          <source>The flavor</source>
          <target state="translated">味道</target>
        </trans-unit>
        <trans-unit id="0aa322e2f3acfe06e30a26fc0d60aa65599ac7cd" translate="yes" xml:space="preserve">
          <source>The floating point infinity can be exported as a subroutine Inf():</source>
          <target state="translated">浮点无穷大可以导出为一个子程序Inf()。</target>
        </trans-unit>
        <trans-unit id="2e5e2b0312afcc71cd5da99161e1d75eaff20f77" translate="yes" xml:space="preserve">
          <source>The focus is on elements of style which are visible to the users of a module, rather than those parts which are only seen by the module's developers. However, many of the guidelines presented in this document can be extrapolated and applied successfully to a module's internals.</source>
          <target state="translated">本文档的重点是模块的用户可以看到的风格元素,而不是那些只有模块的开发者才能看到的部分。但是,本文中介绍的许多准则都可以外推并成功地应用于模块的内部。</target>
        </trans-unit>
        <trans-unit id="9981cb315250daca0797ec1ef39fd43f6c6f6a86" translate="yes" xml:space="preserve">
          <source>The following &quot;public&quot; global names can be read by clients of this API. Beware that these should be considered &quot;readonly&quot;.</source>
          <target state="translated">以下的 &quot;公共 &quot;全局名称可以被这个API的客户端读取。请注意,这些名称应被视为 &quot;只读&quot;。</target>
        </trans-unit>
        <trans-unit id="20617679e0f828efd3412a47a9694c121128bc85" translate="yes" xml:space="preserve">
          <source>The following &quot;virtual&quot; methods can be defined by the client. They will be called by the API at appropriate points. Note that unless specified otherwise, the debug API only defines empty, non-functional default versions of these methods.</source>
          <target state="translated">以下 &quot;虚拟 &quot;方法可以由客户端定义。它们将在适当的时候被API调用。请注意,除非另有规定,否则调试API只定义这些方法的空的、无功能的默认版本。</target>
        </trans-unit>
        <trans-unit id="74f1711fbc30180876f2a4788abe7e66574474a6" translate="yes" xml:space="preserve">
          <source>The following (inefficiently) deletes all the values of %HASH and @ARRAY:</source>
          <target state="translated">下面(低效地)删除%HASH和@ARRAY的所有值。</target>
        </trans-unit>
        <trans-unit id="d00c5dd059bf93f0972cfd4b44a56b57fd0caf81" translate="yes" xml:space="preserve">
          <source>The following API list contains functions, thus one needs to provide pointers to the modifiable data explicitly (either C pointers, or Perlish &lt;code&gt;GV *&lt;/code&gt; s). Where the above macros take &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;, a similar function takes &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; .</source>
          <target state="translated">以下API列表包含函数，因此需要明确提供指向可修改数据的指针（C指针或Perlish &lt;code&gt;GV *&lt;/code&gt; s）。上述宏采用 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 的地方，类似的函数采用 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; 的地方。</target>
        </trans-unit>
        <trans-unit id="b1909e3498aef1b158b54d7174bc50b2ee9e5d97" translate="yes" xml:space="preserve">
          <source>The following API uses parts of Perl's internals in the current implementation. As such, they are efficient but may change in a future release.</source>
          <target state="translated">下面的API使用了当前实现中Perl的部分内部结构。因此,它们是有效的,但在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="36cab3979d794d7afb5425a45a32e9d6f7ad6a57" translate="yes" xml:space="preserve">
          <source>The following NNTP command are unsupported by the package, and there are no plans to do so.</source>
          <target state="translated">下面的NNTP命令是软件包不支持的,目前也没有计划支持。</target>
        </trans-unit>
        <trans-unit id="2d9e72c95e25f90c1fd2f371c21c4c0499d49748" translate="yes" xml:space="preserve">
          <source>The following RFC959 commands have not been implemented:</source>
          <target state="translated">以下RFC959命令尚未实施。</target>
        </trans-unit>
        <trans-unit id="237479489ace35ae45dfd88db2279ca4abed31a5" translate="yes" xml:space="preserve">
          <source>The following VMS-specific information applies to the indicated &quot;special&quot; Perl variables, in addition to the general information in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. Where there is a conflict, this information takes precedence.</source>
          <target state="translated">除了&lt;a href=&quot;perlvar&quot;&gt;perlvar中&lt;/a&gt;的常规信息之外，以下特定于VMS的信息还适用于指示的&amp;ldquo;特殊&amp;rdquo; Perl变量。发生冲突时，此信息优先。</target>
        </trans-unit>
        <trans-unit id="a7dd0dcb80676e8669cc8ad178e5203d579a6cf3" translate="yes" xml:space="preserve">
          <source>The following Win32-Methods are built-in:</source>
          <target state="translated">以下是内置的Win32方法。</target>
        </trans-unit>
        <trans-unit id="1c76188e19e8645c61f6a21008485b728f914f68" translate="yes" xml:space="preserve">
          <source>The following XS code shows the getnetconfigent() function which is used with ONC+ TIRPC. The getnetconfigent() function will return a pointer to a C structure and has the C prototype shown below. The example will demonstrate how the C pointer will become a Perl reference. Perl will consider this reference to be a pointer to a blessed object and will attempt to call a destructor for the object. A destructor will be provided in the XS source to free the memory used by getnetconfigent(). Destructors in XS can be created by specifying an XSUB function whose name ends with the word &lt;b&gt;DESTROY&lt;/b&gt;. XS destructors can be used to free memory which may have been malloc'd by another XSUB.</source>
          <target state="translated">以下XS代码显示了与ONC + TIRPC一起使用的getnetconfigent（）函数。 getnetconfigent（）函数将返回一个指向C结构的指针，并具有如下所示的C原型。该示例将演示C指针将如何成为Perl引用。 Perl将认为此引用是指向受祝福对象的指针，并将尝试为该对象调用析构函数。 XS源中将提供一个析构函数，以释放getnetconfigent（）使用的内存。在XS析构函数可以通过指定XSUB函数，其名称端以单词来创建&lt;b&gt;DESTROY&lt;/b&gt;。 XS析构函数可用于释放可能已由另一个XSUB分配的内存。</target>
        </trans-unit>
        <trans-unit id="63aaf3d4311946370f948fe1a874ef3b8b5e106b" translate="yes" xml:space="preserve">
          <source>The following XS file shows an XS subroutine, or XSUB, which demonstrates one possible interface to the rpcb_gettime() function. This XSUB represents a direct translation between C and Perl and so preserves the interface even from Perl. This XSUB will be invoked from Perl with the usage shown above. Note that the first three #include statements, for &lt;code&gt;EXTERN.h&lt;/code&gt; , &lt;code&gt;perl.h&lt;/code&gt; , and &lt;code&gt;XSUB.h&lt;/code&gt; , will always be present at the beginning of an XS file. This approach and others will be expanded later in this document. A #define for &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; should be present to fetch the interpreter context more efficiently, see &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt; for details.</source>
          <target state="translated">以下XS文件显示了XS子例程或XSUB，该子例程演示了rpcb_gettime（）函数的一个可能接口。该XSUB表示C和Perl之间的直接转换，因此即使从Perl保留接口也是如此。将使用上面显示的用法从Perl调用此XSUB。请注意，对于 &lt;code&gt;EXTERN.h&lt;/code&gt; ， &lt;code&gt;perl.h&lt;/code&gt; 和 &lt;code&gt;XSUB.h&lt;/code&gt; ，前三个#include语句将始终出现在XS文件的开头。此方法和其他方法将在本文档的后面部分进行扩展。应该提供一个针对 &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; 的#define，以更有效地获取解释器上下文，有关详细信息，请参见&lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a47250eb8cd4ed87f2a860c613d9258f03e5ab61" translate="yes" xml:space="preserve">
          <source>The following XSUB allows a Perl program to access a C library function called sin(). The XSUB will imitate the C function which takes a single argument and returns a single value.</source>
          <target state="translated">下面的XSUB允许Perl程序访问C库的函数sin()。这个XSUB将模仿C函数,接受一个参数并返回一个值。</target>
        </trans-unit>
        <trans-unit id="71f3a3c3ea9ed7f75901c1ba18beceaf1cdd2fef" translate="yes" xml:space="preserve">
          <source>The following XSUB is for a C function which requires special handling of its parameters. The Perl usage is given first.</source>
          <target state="translated">下面的XSUB是一个C函数,需要对其参数进行特殊处理。先给出Perl的用法。</target>
        </trans-unit>
        <trans-unit id="4f90e96487752832ff267e1d1e37b8167fdf3f66" translate="yes" xml:space="preserve">
          <source>The following XSUB uses the &lt;code&gt;SV *&lt;/code&gt; return type as a mnemonic only, and uses a CODE: block to indicate to the compiler that the programmer has supplied all the necessary code. The sv_newmortal() call will initialize the return value to undef, making that the default return value.</source>
          <target state="translated">以下XSUB仅将 &lt;code&gt;SV *&lt;/code&gt; 返回类型用作助记符，并使用CODE：块向编译器指示程序员已提供了所有必需的代码。sv_newmortal（）调用会将返回值初始化为undef，使其成为默认返回值。</target>
        </trans-unit>
        <trans-unit id="a1bc7555b268b447bf525bbb361d23e74ba70916" translate="yes" xml:space="preserve">
          <source>The following XSUB will call the C rpcb_gettime() function and will return its two output values, timep and status, to Perl as a single list.</source>
          <target state="translated">下面的XSUB将调用C语言中的rpcb_gettime()函数,并将其两个输出值timep和status以一个列表的形式返回给Perl。</target>
        </trans-unit>
        <trans-unit id="a13ba96373d895202485d58b843fc94572bbb6f9" translate="yes" xml:space="preserve">
          <source>The following XSUB will generate incorrect C code. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; with parameters &lt;code&gt;(char
*host, time_t timep)&lt;/code&gt; , but the real &lt;code&gt;rpcb_gettime()&lt;/code&gt; wants the &lt;code&gt;timep&lt;/code&gt; parameter to be of type &lt;code&gt;time_t*&lt;/code&gt; rather than &lt;code&gt;time_t&lt;/code&gt; .</source>
          <target state="translated">下面的XSUB将生成不正确的C代码。该&lt;b&gt;xsubpp&lt;/b&gt;编译器将它变成它调用代码 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 与参数 &lt;code&gt;(char *host, time_t timep)&lt;/code&gt; ，但真正 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 希望 &lt;code&gt;timep&lt;/code&gt; 参数为类型 &lt;code&gt;time_t*&lt;/code&gt; ，而不是 &lt;code&gt;time_t&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="72e3e7ea3cadf3d440df4d4dd029f14c329e3532" translate="yes" xml:space="preserve">
          <source>The following are Win32 multilanguage editor/IDEs that support Perl:</source>
          <target state="translated">以下是支持Perl的Win32多语言编辑器/IDE。</target>
        </trans-unit>
        <trans-unit id="878ebe02234cd6605f8faf412927071c9b53a803" translate="yes" xml:space="preserve">
          <source>The following are additions that have been requested, but I have been reluctant to add due to them being very simple to implement in perl</source>
          <target state="translated">以下是一些被要求添加的内容,但我一直不愿意添加,因为它们在perl中很容易实现。</target>
        </trans-unit>
        <trans-unit id="f30d9daa89e8ddd37f1202a1d64d4bf0b2c5e1f9" translate="yes" xml:space="preserve">
          <source>The following are all accessor methods -- that is, they don't do anything on their own, but just alter the contents of the conversion object, which comprises the options for this particular batch conversion.</source>
          <target state="translated">以下都是访问器方法--也就是说,它们本身并不做任何事情,只是改变转换对象的内容,其中包括这个特定批次转换的选项。</target>
        </trans-unit>
        <trans-unit id="cd4d07e071310dab311d4b0da4565a6a9fb7c1f6" translate="yes" xml:space="preserve">
          <source>The following are also defined by POSIX/SUSv3, but unfortunately not very widely implemented:</source>
          <target state="translated">以下也是POSIX/SUSv3定义的,但遗憾的是没有得到很广泛的实现。</target>
        </trans-unit>
        <trans-unit id="5b36027844e4806a69f430d629440d5e7ecab300" translate="yes" xml:space="preserve">
          <source>The following are common causes of compilation and/or execution failures, not common to Perl as such. The C FAQ is good bedtime reading. Please test your changes with as many C compilers and platforms as possible; we will, anyway, and it's nice to save oneself from public embarrassment.</source>
          <target state="translated">以下是编译和/或执行失败的常见原因,并非Perl常见的原因。C FAQ是很好的睡前读物。请用尽可能多的 C 编译器和平台来测试你的修改;无论如何,我们都会这样做的,而且这样做也很好,可以免去自己在公众面前的尴尬。</target>
        </trans-unit>
        <trans-unit id="e2853c6c7f110e3e4c7ed324a99e91a718ca2300" translate="yes" xml:space="preserve">
          <source>The following are exported:</source>
          <target state="translated">以下是输出的内容:</target>
        </trans-unit>
        <trans-unit id="7791b6ab4309dfc3ea821f7f1d4091cb49b39854" translate="yes" xml:space="preserve">
          <source>The following are fast conversions from ISO 8859-1 (Latin-1) bytes to UTF-8 bytes and back, the code works even with older Perl 5 versions.</source>
          <target state="translated">以下是ISO 8859-1 (Latin-1)字节到UTF-8字节的快速转换,即使在旧的Perl 5版本中也能使用。</target>
        </trans-unit>
        <trans-unit id="c852e811877cc6e9c98b0f2d5fb593ccfc901a95" translate="yes" xml:space="preserve">
          <source>The following are methods in the DB base class. A client must access these methods by inheritance (*not* by calling them directly), since the API keeps track of clients through the inheritance mechanism.</source>
          <target state="translated">以下是DB基类中的方法。客户端必须通过继承来访问这些方法(*不是直接调用它们),因为API通过继承机制来跟踪客户端。</target>
        </trans-unit>
        <trans-unit id="2b3c274cc89ec17e7b845a436f38d1540dbbe5c4" translate="yes" xml:space="preserve">
          <source>The following are such interfaces. Also, see &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;. For all of these interfaces Perl currently (as of v5.16.0) simply assumes byte strings both as arguments and results, or UTF-8 strings if the (deprecated) &lt;code&gt;encoding&lt;/code&gt; pragma has been used.</source>
          <target state="translated">以下是此类接口。另请参见&lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;Unicode错误&lt;/a&gt;。对于所有这些接口，Perl当前（自v5.16.0起）仅假设字节字符串作为参数和结果，如果使用（不推荐使用的） &lt;code&gt;encoding&lt;/code&gt; 编译指示，则假定UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="5bd9bb59d1e1fb0197ed7d9b93043408c8c9a510" translate="yes" xml:space="preserve">
          <source>The following are the built-in attributes for subroutines:</source>
          <target state="translated">以下是子程序的内置属性。</target>
        </trans-unit>
        <trans-unit id="e8e3f6674cdb74d0958b2c8c99d763306f790276" translate="yes" xml:space="preserve">
          <source>The following are the built-in attributes for variables:</source>
          <target state="translated">以下是变量的内置属性。</target>
        </trans-unit>
        <trans-unit id="9d2f2e3af66effdb52e3d7832a18951cdcafd9d0" translate="yes" xml:space="preserve">
          <source>The following are valid ($t1 and $t2 are Time::Piece objects):</source>
          <target state="translated">以下是有效的($t1和$t2是Time::Piece对象)。</target>
        </trans-unit>
        <trans-unit id="f353aa81f91d6dfefc37a9410a376bf8429ba4d4" translate="yes" xml:space="preserve">
          <source>The following attributes may be specified as arguments to WriteMakefile() or as NAME=VALUE pairs on the command line. Attributes that became available with later versions of MakeMaker are indicated.</source>
          <target state="translated">以下属性可以作为WriteMakefile()的参数或在命令行中作为NAME=VALUE对来指定。在MakeMaker的后期版本中,会显示出可用的属性。</target>
        </trans-unit>
        <trans-unit id="b84f68ccf7654a835d7d4e99c76422bf128a4813" translate="yes" xml:space="preserve">
          <source>The following blocks are more or less equivalent:</source>
          <target state="translated">以下各块内容或多或少是相当的。</target>
        </trans-unit>
        <trans-unit id="8676339e37a5a253bdb0cffb28423c7698d023a0" translate="yes" xml:space="preserve">
          <source>The following boolean methods are useful in determining the</source>
          <target state="translated">以下布尔方法可用于确定</target>
        </trans-unit>
        <trans-unit id="b20d8378cbbcad7ea8e16d1f3872a95fae060afe" translate="yes" xml:space="preserve">
          <source>The following bzip2 constants are exported by this module</source>
          <target state="translated">本模块导出了以下bzip2常量</target>
        </trans-unit>
        <trans-unit id="f401e4eb4fd748677014cc2aaf006246c60d726e" translate="yes" xml:space="preserve">
          <source>The following checks are currently performed:</source>
          <target state="translated">目前正在进行以下检查:</target>
        </trans-unit>
        <trans-unit id="a62f3d4985ed23dc7ef4b06d5778fb97c9f68862" translate="yes" xml:space="preserve">
          <source>The following code demonstrates how to supply initialization code for function parameters. The initialization code is eval'ed within double quotes by the compiler before it is added to the output so anything which should be interpreted literally [mainly &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , or &lt;code&gt;\\&lt;/code&gt; ] must be protected with backslashes. The variables &lt;code&gt;$var&lt;/code&gt; , &lt;code&gt;$arg&lt;/code&gt; , and &lt;code&gt;$type&lt;/code&gt; can be used as in typemaps.</source>
          <target state="translated">以下代码演示了如何为函数参数提供初始化代码。初始化代码被编译器双引号内eval'ed之前，它被添加到输出，所以，只要应字面解释[主要 &lt;code&gt;$&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; ，或 &lt;code&gt;\\&lt;/code&gt; ]必须用反斜杠保护。变量 &lt;code&gt;$var&lt;/code&gt; ， &lt;code&gt;$arg&lt;/code&gt; 和 &lt;code&gt;$type&lt;/code&gt; 可以在类型映射中使用。</target>
        </trans-unit>
        <trans-unit id="994718a63d0e6e92c9d2b82a651bf83693f2d577" translate="yes" xml:space="preserve">
          <source>The following code opens up an output handle that will convert any output to a hexadecimal dump of the output bytes: for example &quot;A&quot; will be converted to &quot;41&quot; (on ASCII-based machines, on EBCDIC platforms the &quot;A&quot; will become &quot;c1&quot;)</source>
          <target state="translated">下面的代码打开了一个输出句柄,它将把任何输出转换为输出字节的十六进制转储:例如 &quot;A &quot;将被转换为 &quot;41&quot;(在基于ASCII的机器上,在EBCDIC平台上,&quot;A &quot;将变成 &quot;c1&quot;)。</target>
        </trans-unit>
        <trans-unit id="b646612d9dad6d0db0d9ef47258da28b3b64f1c7" translate="yes" xml:space="preserve">
          <source>The following code will build up an ASCII string saying &lt;code&gt;'PerlPerlPerl'&lt;/code&gt; . The comments show the string after each step. Note that this code works in the same way on big-endian or little-endian machines.</source>
          <target state="translated">以下代码将构建一个 &lt;code&gt;'PerlPerlPerl'&lt;/code&gt; 的ASCII字符串。注释显示每个步骤之后的字符串。请注意，此代码在big-endian或little-endian机器上以相同的方式工作。</target>
        </trans-unit>
        <trans-unit id="b67a84b8d82f9d95c5a2c0536fda7094ec319c8b" translate="yes" xml:space="preserve">
          <source>The following code works for single-level arrays. It uses a stringwise comparison, and does not distinguish defined versus undefined empty strings. Modify if you have other needs.</source>
          <target state="translated">以下代码适用于单层数组。它使用的是字符串比较,并且不区分定义的和未定义的空字符串。如果你有其他需要,请修改。</target>
        </trans-unit>
        <trans-unit id="b42ca297dfa48bfb8bd9e9eb19ab8d4d7764f6d5" translate="yes" xml:space="preserve">
          <source>The following collations all make sense and you may meet any of them if you &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; .</source>
          <target state="translated">下列排序规则都很有意义，如果您 &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; 则可能会遇到其中的任何一种。</target>
        </trans-unit>
        <trans-unit id="c5819e2e60b0b7a2348ddc793c274025d6f7880f" translate="yes" xml:space="preserve">
          <source>The following command characters are defined:</source>
          <target state="translated">定义了以下命令字符。</target>
        </trans-unit>
        <trans-unit id="94b38038de165a0daa7082711aa19c3a2036cf7d" translate="yes" xml:space="preserve">
          <source>The following command line switches behave differently under VMS than described in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. Note also that in order to pass uppercase switches to Perl, you need to enclose them in double-quotes on the command line, since the CRTL downcases all unquoted strings.</source>
          <target state="translated">以下命令行开关在VMS下的行为不同于&lt;a href=&quot;perlrun&quot;&gt;perlrun中&lt;/a&gt;描述的行为。还要注意，为了将大写的开关传递给Perl，您需要在命令行上将它们用双引号引起来，因为CRTL会将所有未用引号引起来的字符串都转换为小写。</target>
        </trans-unit>
        <trans-unit id="52448ab44f7b84ff23c0bb42cd9a8e27687108c1" translate="yes" xml:space="preserve">
          <source>The following command shows how to compute digests for typical inputs such as the NIST test vector &quot;abc&quot;:</source>
          <target state="translated">下面的命令显示了如何计算典型输入的摘要,如NIST测试向量 &quot;abc&quot;。</target>
        </trans-unit>
        <trans-unit id="ab2ed20fd1e01c9d474d41404b2754af8ec50648" translate="yes" xml:space="preserve">
          <source>The following compilation warnings may happen in HP-UX releases earlier than 11.31 but are harmless:</source>
          <target state="translated">在11.31之前的HP-UX版本中可能会发生以下编译警告,但无害。</target>
        </trans-unit>
        <trans-unit id="3f82c625cf5e705c9b15fb1534c5c11410cab28f" translate="yes" xml:space="preserve">
          <source>The following compiler versions are currently supported by IBM:</source>
          <target state="translated">目前IBM支持以下编译器版本。</target>
        </trans-unit>
        <trans-unit id="f0ad64f79a84fc4d8e60a250b5c99592e7f5b9c7" translate="yes" xml:space="preserve">
          <source>The following compound statements may be used to control flow:</source>
          <target state="translated">以下复合语句可用于控制流量。</target>
        </trans-unit>
        <trans-unit id="cd012592d06772e0ce9bcaaa2cfc233e60576f7d" translate="yes" xml:space="preserve">
          <source>The following constants may be returned by getaddrinfo() or getnameinfo(). Others may be provided by the OS.</source>
          <target state="translated">以下常量可以由getaddrinfo()或getnameinfo()返回。其他常量可能由操作系统提供。</target>
        </trans-unit>
        <trans-unit id="b842779c0173418719ebe5c2a7970e42d7d014a5" translate="yes" xml:space="preserve">
          <source>The following constants may be supplied as $xflags.</source>
          <target state="translated">以下常量可以作为$xflags提供。</target>
        </trans-unit>
        <trans-unit id="1be3497b66f11b1f18ed534aa513910c71b80ff0" translate="yes" xml:space="preserve">
          <source>The following debugger is actually useful:</source>
          <target state="translated">下面的调试器其实很有用。</target>
        </trans-unit>
        <trans-unit id="c779f6e32c9824a654c3d3bb9768a1c5fd1243ca" translate="yes" xml:space="preserve">
          <source>The following description of methods is still under development. Please refer to the code for not suitably documented sections and complain loudly to the makemaker@perl.org mailing list. Better yet, provide a patch.</source>
          <target state="translated">以下方法的描述仍在开发中。请参考代码中不合适的文档部分,并向 makemaker@perl.org 邮件列表大声抱怨。最好是提供一个补丁。</target>
        </trans-unit>
        <trans-unit id="b3965f0e7b97198aca0dad023bdfa649bc3d7a07" translate="yes" xml:space="preserve">
          <source>The following documentation describes how to use FATAL warnings but the perl5 porters strongly recommend that you understand the risks before doing so, especially for library code intended for use by others, as there is no way for downstream users to change the choice of fatal categories.</source>
          <target state="translated">下面的文档介绍了如何使用 fatal 警告,但 perl5 移植者强烈建议您在这样做之前先了解风险,尤其是对于打算给他人使用的库代码,因为下游用户没有办法更改 fatal 类别的选择。</target>
        </trans-unit>
        <trans-unit id="a7395fbf98116a6fe303ce2ccf2e783d73f2e981" translate="yes" xml:space="preserve">
          <source>The following efficiently counts the number of set bits in a bit vector:</source>
          <target state="translated">下面有效地计算一个位向量中的设置位数。</target>
        </trans-unit>
        <trans-unit id="2679279cde508d70a24c6c066ec89faf688d0162" translate="yes" xml:space="preserve">
          <source>The following entries are used during installation &amp;amp; testing on the libnet package</source>
          <target state="translated">在libnet软件包的安装和测试过程中使用以下条目</target>
        </trans-unit>
        <trans-unit id="f9b777d6ecffc2871fa8ad1bd878e3ae6a3e84c6" translate="yes" xml:space="preserve">
          <source>The following environment variables are not specific to Perl: They are part of the standardized (ISO C, XPG4, POSIX 1.c) &lt;code&gt;setlocale()&lt;/code&gt; method for controlling an application's opinion on data. Windows is non-POSIX, but Perl arranges for the following to work as described anyway. If the locale given by an environment variable is not valid, Perl tries the next lower one in priority. If none are valid, on Windows, the system default locale is then tried. If all else fails, the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale is used. If even that doesn't work, something is badly broken, but Perl tries to forge ahead with whatever the locale settings might be.</source>
          <target state="translated">以下环境变量不是Perl特有的：它们是用于控制应用程序对数据的意见的标准化（ISO C，XPG4，POSIX 1.c） &lt;code&gt;setlocale()&lt;/code&gt; 方法的一部分。Windows不是POSIX，但是Perl仍然按照以下说明安排以下工作。如果环境变量给定的语言环境无效，则Perl优先尝试下一个较低的语言环境。如果没有一个有效，则在Windows上尝试系统默认语言环境。如果所有其他方法均失败，则使用 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 语言环境。即使不起作用，也会严重破坏某些内容，但是Perl会尝试使用任何区域设置进行尝试。</target>
        </trans-unit>
        <trans-unit id="ec33aa555d27541d5a7185de1c1d5ba6a82fafba" translate="yes" xml:space="preserve">
          <source>The following equivalences hold (assuming &lt;code&gt;$#a &amp;gt;= $i&lt;/code&gt; )</source>
          <target state="translated">保持以下等价关系（假设 &lt;code&gt;$#a &amp;gt;= $i&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="85ca43521cd7775d8d33759b4074f5573158c1e6" translate="yes" xml:space="preserve">
          <source>The following error handling mechanism is considered experimental and is subject to change pending feedback from users.</source>
          <target state="translated">以下错误处理机制被认为是试验性的,可能会根据用户的反馈进行修改。</target>
        </trans-unit>
        <trans-unit id="cd63c469244aad9fa5f13ff0ec636281c8ddaf6b" translate="yes" xml:space="preserve">
          <source>The following error occurs because of the Cygwin &lt;code&gt;#define&lt;/code&gt; of &lt;code&gt;_LONG_DOUBLE&lt;/code&gt; :</source>
          <target state="translated">由于 &lt;code&gt;_LONG_DOUBLE&lt;/code&gt; 的Cygwin &lt;code&gt;#define&lt;/code&gt; 而发生以下错误：</target>
        </trans-unit>
        <trans-unit id="e111335c40da2391bb6d2b1d90ed4f7cf911e6e5" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, and in transliterations:</source>
          <target state="translated">下列转义序列可用于内插的构造和转写中。</target>
        </trans-unit>
        <trans-unit id="82159e16248ad6f2c09cd225ffdcbbf320f234ef" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, but not in transliterations.</source>
          <target state="translated">以下转义序列在内插的结构中可用,但在转写中不可用。</target>
        </trans-unit>
        <trans-unit id="62d1bc8a7a340748e143b5a954b697a1e9a92d04" translate="yes" xml:space="preserve">
          <source>The following example contains all supported keywords and structures with the exception of &lt;code&gt;eexpect&lt;/code&gt; which can be used instead of &lt;code&gt;expect&lt;/code&gt; .</source>
          <target state="translated">下面的示例包含所有支持的关键字和结构的除外 &lt;code&gt;eexpect&lt;/code&gt; 可以用来代替 &lt;code&gt;expect&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8665fd8b339dfb9b20108d0f4ac2879711d7bca" translate="yes" xml:space="preserve">
          <source>The following example counts all the possible matching strings in a pattern (without actually matching any of them).</source>
          <target state="translated">下面的例子计算了一个模式中所有可能匹配的字符串(而不是实际匹配其中的任何一个)。</target>
        </trans-unit>
        <trans-unit id="b54547ad1ef83c76b354b1c5c3bcd26f7c112217" translate="yes" xml:space="preserve">
          <source>The following example implements a simple daemon, which restarts itself every time the &lt;code&gt;SIGHUP&lt;/code&gt; signal is received. The actual code is located in the subroutine &lt;code&gt;code()&lt;/code&gt; , which just prints some debugging info to show that it works; it should be replaced with the real code.</source>
          <target state="translated">以下示例实现了一个简单的守护程序，该守护程序在每次收到 &lt;code&gt;SIGHUP&lt;/code&gt; 信号时都会重新启动。实际的代码位于子例程 &lt;code&gt;code()&lt;/code&gt; 中，该子例程仅打印一些调试信息以表明其有效。应将其替换为真实代码。</target>
        </trans-unit>
        <trans-unit id="4db59d80ee391c290c8e0098f7b4cb5a921d343a" translate="yes" xml:space="preserve">
          <source>The following example shows a variation of the rpcb_gettime() function. This function uses the timep variable only as an output variable and does not care about its initial contents.</source>
          <target state="translated">下面的例子显示了rpcb_gettime()函数的一个变体。这个函数只使用timep变量作为输出变量,并不关心它的初始内容。</target>
        </trans-unit>
        <trans-unit id="6e5930c0e8a4086018f7b728e0496b7b5959e325" translate="yes" xml:space="preserve">
          <source>The following example shows how the input parameter &lt;code&gt;timep&lt;/code&gt; can be evaluated late, after a PREINIT.</source>
          <target state="translated">下面的示例示出了如何输入参数 &lt;code&gt;timep&lt;/code&gt; 可以后期进行评价，一个PREINIT之后。</target>
        </trans-unit>
        <trans-unit id="f2d336b88b655db564d2a7de7cc37f5570d6138e" translate="yes" xml:space="preserve">
          <source>The following example will create aliases &lt;code&gt;FOO::gettime()&lt;/code&gt; and &lt;code&gt;BAR::getit()&lt;/code&gt; for this function.</source>
          <target state="translated">下面的示例将为此函数创建别名 &lt;code&gt;FOO::gettime()&lt;/code&gt; 和 &lt;code&gt;BAR::getit()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97da872b2dd68324aaeb980a55e38dbf65cc1f09" translate="yes" xml:space="preserve">
          <source>The following example will import the &lt;code&gt;langinfo()&lt;/code&gt; function itself and three constants to be used as arguments to &lt;code&gt;langinfo()&lt;/code&gt; : a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="translated">下面的示例将导入 &lt;code&gt;langinfo()&lt;/code&gt; 函数本身和三个常量，这些变量将用作 &lt;code&gt;langinfo()&lt;/code&gt; 的参数：一个缩写为一周中第一天的常量（从星期日= 1开始编号），另一个为常量为常数和在当前语言环境中对是/否问题的否定答案。</target>
        </trans-unit>
        <trans-unit id="68fe38084e5e619d96b5a9797595ec407ba06c97" translate="yes" xml:space="preserve">
          <source>The following example will import the langinfo() function itself and three constants to be used as arguments to langinfo(): a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="translated">下面的例子将导入langinfo()函数本身和三个常量作为langinfo()的参数:一个常量用于表示一周中的第一天的缩写(编号从周日开始=1),另外两个常量用于表示当前语言环境下是/否问题的肯定和否定答案。</target>
        </trans-unit>
        <trans-unit id="1d1e35923d66b27df87bbd4951c7d28f5e911d07" translate="yes" xml:space="preserve">
          <source>The following example will start the XS code and will place all functions in a package named RPC.</source>
          <target state="translated">下面的例子将启动XS代码,并将所有函数放在一个名为RPC的包中。</target>
        </trans-unit>
        <trans-unit id="dcb1a8c644e732663ae2a1c5ba3b577a1beb1ffa" translate="yes" xml:space="preserve">
          <source>The following examples all demonstrate how &lt;code&gt;reduce&lt;/code&gt; could be used to implement the other list-reduction functions in this module. (They are not in fact implemented like this, but instead in a more efficient manner in individual C functions).</source>
          <target state="translated">以下示例均演示了如何使用 &lt;code&gt;reduce&lt;/code&gt; 来实现此模块中的其他列表缩减功能。（实际上并不是这样实现的，而是在各个C函数中以更有效的方式实现）。</target>
        </trans-unit>
        <trans-unit id="887954cfa884d676e908a97b64a1555b23e32dbf" translate="yes" xml:space="preserve">
          <source>The following examples are equivalent, but if the code is using complex typemaps then the first example is safer.</source>
          <target state="translated">下面的例子是等价的,但是如果代码使用的是复杂的类型图,那么第一个例子是比较安全的。</target>
        </trans-unit>
        <trans-unit id="49473e8ccd96036c2dcbbff4100727b567ca00bb" translate="yes" xml:space="preserve">
          <source>The following examples assume</source>
          <target state="translated">下面的例子假设</target>
        </trans-unit>
        <trans-unit id="c8963d9d7205dc5eeae0e9a51c29c23916de6bfc" translate="yes" xml:space="preserve">
          <source>The following examples don't attempt to show everything as that would be a monumental task, and, frankly, we don't want this manpage to be an internals document for Perl. The examples do demonstrate some basics of the raw Perl datatypes, and should suffice to get most determined people on their way. There are no guidewires or safety nets, nor blazed trails, so be prepared to travel alone from this point and on and, if at all possible, don't fall into the quicksand (it's bad for business).</source>
          <target state="translated">下面的例子并不试图展示所有的内容,因为那将是一项艰巨的任务,而且,坦率地说,我们不希望这个手册成为 Perl 的内部文档。这些例子确实展示了一些原始 Perl 数据类型的基础知识,应该足以让大多数有决心的人上路。这里没有导引线或安全网,也没有明文规定的小径,所以请准备好从这里开始独自旅行,如果可能的话,请不要掉进流沙中(这对生意不利)。</target>
        </trans-unit>
        <trans-unit id="f93e6ebc989a84ca950fac6b12d34738b1701d5f" translate="yes" xml:space="preserve">
          <source>The following extension layers are bundled with perl:</source>
          <target state="translated">以下扩展层与perl捆绑在一起。</target>
        </trans-unit>
        <trans-unit id="7106b07b78b7a3440b3c0ad4f4323e11abe72903" translate="yes" xml:space="preserve">
          <source>The following extra operations are supported on both real and complex numbers:</source>
          <target state="translated">实数和复数都支持以下额外的操作。</target>
        </trans-unit>
        <trans-unit id="44559e75149012ee5d0aabd7169096ab8b9b70c9" translate="yes" xml:space="preserve">
          <source>The following feature bundles are available:</source>
          <target state="translated">可提供以下功能捆绑:</target>
        </trans-unit>
        <trans-unit id="bfb5fd7e91227c5f530d75f35f7920db7fa46141" translate="yes" xml:space="preserve">
          <source>The following file is certain to trigger a few errors at both runtime and compiletime:</source>
          <target state="translated">下面的文件肯定会在运行时和编译时引发一些错误。</target>
        </trans-unit>
        <trans-unit id="21aca79b002af6c026c59989c512a774a1e9d423" translate="yes" xml:space="preserve">
          <source>The following files were created.</source>
          <target state="translated">创建了以下文件:</target>
        </trans-unit>
        <trans-unit id="c2d8b9dded738fa01824e3880baab2ed9227058b" translate="yes" xml:space="preserve">
          <source>The following flag constants are recognised as $flags. Other flag constants may exist as provided by the OS.</source>
          <target state="translated">下列标志常量被认为是$flags。其他标志常量可能由操作系统提供。</target>
        </trans-unit>
        <trans-unit id="650acaa8d024a737244b8df389c437c35b54545d" translate="yes" xml:space="preserve">
          <source>The following flag constants are recognised in the $hints hash. Other flag constants may exist as provided by the OS.</source>
          <target state="translated">在$hints哈希中,以下标志常量被认可。其他标志常量可能由操作系统提供。</target>
        </trans-unit>
        <trans-unit id="8b04fa6f897518e44671c43d372c1d8cbb29d5b0" translate="yes" xml:space="preserve">
          <source>The following flag has been added in the Perl implementation for csh compatibility:</source>
          <target state="translated">为了与csh兼容,在Perl实现中加入了以下标志。</target>
        </trans-unit>
        <trans-unit id="1cd8e3861113caf88d2e286d8b55139fd349b7d0" translate="yes" xml:space="preserve">
          <source>The following flags would be nice to have but they would first need their own Augean stablemaster:</source>
          <target state="translated">以下旗帜是不错的选择,但它们首先需要自己的奥格马夫。</target>
        </trans-unit>
        <trans-unit id="9100eb4e02b3634a97be9d3c35013fdbb0474e55" translate="yes" xml:space="preserve">
          <source>The following four files sum up all the details discussed so far.</source>
          <target state="translated">以下四个文件总结了迄今为止讨论的所有细节。</target>
        </trans-unit>
        <trans-unit id="c34a482a0a61764634c9a647354d1ae932661df4" translate="yes" xml:space="preserve">
          <source>The following function copies a string into an SV whose reference is &lt;code&gt;rv&lt;/code&gt; . Set length to 0 to let Perl calculate the string length. SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">以下函数将字符串复制到引用为 &lt;code&gt;rv&lt;/code&gt; 的SV中。将length设置为0可让Perl计算字符串长度。如果 &lt;code&gt;classname&lt;/code&gt; 不为null，则SV被祝福。</target>
        </trans-unit>
        <trans-unit id="3c0cf226e396fa1b152052f0820e83e7d855fd95" translate="yes" xml:space="preserve">
          <source>The following function copies the pointer value (</source>
          <target state="translated">以下函数复制指针值(</target>
        </trans-unit>
        <trans-unit id="2e073fa19276cae1009d363a0e5463744a8cdb65" translate="yes" xml:space="preserve">
          <source>The following function is available on Perls built on 64 bit OpenVMS v8.2 with hard links enabled on an ODS-5 formatted build disk. CRTL support is in principle available as of OpenVMS v7.3-1, and better configuration support could detect this.</source>
          <target state="translated">以下功能在64位OpenVMS v8.2上构建的Perls上是可用的,并且在ODS-5格式化的构建盘上启用了硬链接。CRTL支持原则上在OpenVMS v7.3-1时就可以使用,更好的配置支持可以检测到这一点。</target>
        </trans-unit>
        <trans-unit id="1d791c23038d9fe8780d570ab1f25e41c2c30bfa" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is a reference to a blessed object.</source>
          <target state="translated">下面的函数测试SV是否是对受祝福对象的引用。</target>
        </trans-unit>
        <trans-unit id="e97d512753d6d3628f54f7cc67945848127ebcd9" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is blessed into the specified class. It does not check inheritance relationships.</source>
          <target state="translated">以下函数测试SV是否被祝福到指定的类中。它不检查继承关系。</target>
        </trans-unit>
        <trans-unit id="df3aa6043ddcb399a0be1d9f05fb30512b44c0e8" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is derived from the specified class. SV can be either a reference to a blessed object or a string containing a class name. This is the function implementing the &lt;code&gt;UNIVERSAL::isa&lt;/code&gt; functionality.</source>
          <target state="translated">以下函数测试SV是否从指定的类派生。SV可以是对祝福对象的引用，也可以是包含类名的字符串。这是实现 &lt;code&gt;UNIVERSAL::isa&lt;/code&gt; 功能的函数。</target>
        </trans-unit>
        <trans-unit id="f2556ab0e8df33f1383226a4c6f98cdd750d952a" translate="yes" xml:space="preserve">
          <source>The following function upgrades rv to reference if not already one. Creates a new SV for rv to point to. If &lt;code&gt;classname&lt;/code&gt; is non-null, the SV is blessed into the specified class. SV is returned.</source>
          <target state="translated">以下功能将rv升级为参考（如果尚未添加）。为rv指向创建一个新的SV。如果 &lt;code&gt;classname&lt;/code&gt; 为非null，则SV被祝福进入指定的类。SV返回。</target>
        </trans-unit>
        <trans-unit id="29dc5cc89743cc721a2ee3907403e1585ed5aaa4" translate="yes" xml:space="preserve">
          <source>The following functions</source>
          <target state="translated">职能如下</target>
        </trans-unit>
        <trans-unit id="d058fd87c96266d5fdc51527ace77cd0d78cdd43" translate="yes" xml:space="preserve">
          <source>The following functions all perform some useful activity on reference values.</source>
          <target state="translated">以下函数都对参考值进行了一些有用的操作。</target>
        </trans-unit>
        <trans-unit id="2911d89162772ba03d36f6973e469a4101bb2cc6" translate="yes" xml:space="preserve">
          <source>The following functions are Perl implementations of the mktemp() family of temp file generation system calls.</source>
          <target state="translated">下面的函数是Perl中mktemp()系列临时文件生成系统调用的实现。</target>
        </trans-unit>
        <trans-unit id="e0a3d6bc866a23a74bfc5cb99a24046225a27424" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on 64 bit OpenVMS v8.2 and later.</source>
          <target state="translated">以下功能在64位OpenVMS v8.2及以后版本的Perls中可用。</target>
        </trans-unit>
        <trans-unit id="c3192aa510cfad4d7ff0a5d49cbe59b87b3bf2ce" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on 64 bit OpenVMS v8.2 and later. CRTL support is in principle available as of OpenVMS v7.3-2, and better configuration support could detect this.</source>
          <target state="translated">以下功能在64位OpenVMS v8.2及以后版本的Perls上可用。CRTL支持原则上从OpenVMS v7.3-2开始就可以使用,更好的配置支持可以检测到这一点。</target>
        </trans-unit>
        <trans-unit id="9298194e3e006b8fbe7257f536dde080822b8c50" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on VMS 7.2 or greater:</source>
          <target state="translated">以下功能在VMS 7.2或更高版本的Perls上可用。</target>
        </trans-unit>
        <trans-unit id="5c953c5f1b476c550370e7b30065e8a151627682" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls compiled with Dec C 5.2 or greater and running VMS 7.0 or greater:</source>
          <target state="translated">以下函数在用Dec C 5.2或更高版本编译并运行VMS 7.0或更高版本的Perls中可用。</target>
        </trans-unit>
        <trans-unit id="1e205f409e70ccbdada46ad7374f5371cb998862" translate="yes" xml:space="preserve">
          <source>The following functions are available.</source>
          <target state="translated">有以下功能:</target>
        </trans-unit>
        <trans-unit id="5950979e93d5397c31fbc2a28b94b256eeabee34" translate="yes" xml:space="preserve">
          <source>The following functions are currently undocumented. If you use one of them, you may wish to consider creating and submitting documentation for it.</source>
          <target state="translated">以下功能目前还未被记录。如果您使用其中一个函数,您可能会考虑为其创建并提交文档。</target>
        </trans-unit>
        <trans-unit id="886ab3bb8b191680b7816c0256fd741faf8bc7ec" translate="yes" xml:space="preserve">
          <source>The following functions are defined in the &lt;code&gt;utf8::&lt;/code&gt; package by the Perl core. You do not need to say &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; to use these and in fact you should not say that unless you really want to have UTF-8 source code.</source>
          <target state="translated">Perl核心在 &lt;code&gt;utf8::&lt;/code&gt; 包中定义了以下功能。您不需要说 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 来使用它们，实际上，除非您真的想拥有UTF-8源代码，否则您不应该这样说。</target>
        </trans-unit>
        <trans-unit id="d924d0242f33a4bd7b878adc5df25af14f3fc818" translate="yes" xml:space="preserve">
          <source>The following functions are exported by &lt;code&gt;Filter::Util::Call&lt;/code&gt; :</source>
          <target state="translated">以下函数由 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 导出：</target>
        </trans-unit>
        <trans-unit id="aab0faf40d4a413b76ab20e1f7c9c1ce5f8e0b08" translate="yes" xml:space="preserve">
          <source>The following functions are exported by default.</source>
          <target state="translated">以下是默认导出的函数。</target>
        </trans-unit>
        <trans-unit id="f74d5f0be47eadceddfa059884e47684f407a94a" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module. Please note that these are functions (not methods) and therefore &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; not&lt;/code&gt; take an implicit first argument.</source>
          <target state="translated">以下功能由该模块导出。请注意，这些功能（而不是方法），因此 &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; not&lt;/code&gt; 采取隐式的第一个参数。</target>
        </trans-unit>
        <trans-unit id="ecbe41a265e73d2f25c7e96c76a4a747b067fbd6" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module: &lt;code&gt;share&lt;/code&gt; , &lt;code&gt;shared_clone&lt;/code&gt; , &lt;code&gt;is_shared&lt;/code&gt; , &lt;code&gt;cond_wait&lt;/code&gt; , &lt;code&gt;cond_timedwait&lt;/code&gt; , &lt;code&gt;cond_signal&lt;/code&gt; and &lt;code&gt;cond_broadcast&lt;/code&gt;</source>
          <target state="translated">下面的函数由该模块导出： &lt;code&gt;share&lt;/code&gt; ， &lt;code&gt;shared_clone&lt;/code&gt; ， &lt;code&gt;is_shared&lt;/code&gt; ， &lt;code&gt;cond_wait&lt;/code&gt; ， &lt;code&gt;cond_timedwait&lt;/code&gt; ， &lt;code&gt;cond_signal&lt;/code&gt; 和 &lt;code&gt;cond_broadcast&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="359dedf5643622ca4347a5ad1835485c0f626223" translate="yes" xml:space="preserve">
          <source>The following functions are exported only by request.</source>
          <target state="translated">以下函数仅应要求输出。</target>
        </trans-unit>
        <trans-unit id="bdb1dbec7cc374a481e866646b73ca4b04e611a0" translate="yes" xml:space="preserve">
          <source>The following functions are now implemented in FastCalc.xs:</source>
          <target state="translated">以下函数现在在FastCalc.xs中实现。</target>
        </trans-unit>
        <trans-unit id="685959529a3484efa19ac7a3baaeafce45e37b9a" translate="yes" xml:space="preserve">
          <source>The following functions are provided by the &lt;code&gt;Digest::MD5&lt;/code&gt; module. None of these functions are exported by default.</source>
          <target state="translated">&lt;code&gt;Digest::MD5&lt;/code&gt; 模块提供以下功能。默认情况下，这些功能均不会导出。</target>
        </trans-unit>
        <trans-unit id="b8a73287c5b8efe7a8f104d252583b6712796202" translate="yes" xml:space="preserve">
          <source>The following functions are provided:</source>
          <target state="translated">提供了以下功能:</target>
        </trans-unit>
        <trans-unit id="cb80d66061f0196a6ca192d5341a430ee1b0eb26" translate="yes" xml:space="preserve">
          <source>The following functions are supported:</source>
          <target state="translated">支持以下功能:</target>
        </trans-unit>
        <trans-unit id="89bf61ba64cc618bf2874d4293a3aae6452f1aba" translate="yes" xml:space="preserve">
          <source>The following functions can be imported from this module. No functions are exported by default.</source>
          <target state="translated">以下函数可以从本模块导入。缺省情况下,没有函数被导出。</target>
        </trans-unit>
        <trans-unit id="76627ad7f894d0c3e9a81281fe41fe4c1c985047" translate="yes" xml:space="preserve">
          <source>The following functions check whether the string is in that normalization form.</source>
          <target state="translated">以下函数检查字符串是否为该规范化形式。</target>
        </trans-unit>
        <trans-unit id="a27da5eeba1599f572e14a8c9329aa08b0e2cd4f" translate="yes" xml:space="preserve">
          <source>The following functions convert between lists of Perl values and packed binary strings representing structures.</source>
          <target state="translated">以下函数在Perl值列表和代表结构的打包二进制字符串之间进行转换。</target>
        </trans-unit>
        <trans-unit id="2ccfd58b6052a416773b606e17f327b9dd3cd108" translate="yes" xml:space="preserve">
          <source>The following functions have been flagged as part of the public API, but are currently undocumented. Use them at your own risk, as the interfaces are subject to change. Functions that are not listed in this document are not intended for public use, and should NOT be used under any circumstances.</source>
          <target state="translated">以下函数已被标记为公共API的一部分,但目前还未被记录。由于接口可能会发生变化,因此使用这些函数时要自担风险。本文档中没有列出的函数不打算用于公共用途,在任何情况下都不应该使用。</target>
        </trans-unit>
        <trans-unit id="8f79fe7f0a766eea8a6363560d09b1b418f37a54" translate="yes" xml:space="preserve">
          <source>The following functions may or may not be implemented, depending on what type of socket support you've built into your copy of Perl:</source>
          <target state="translated">下面的函数可能会被实现,也可能不会被实现,这取决于你的Perl副本中内置了什么类型的socket支持。</target>
        </trans-unit>
        <trans-unit id="2d8b2c9f184b69863b362bc365b152ff7d6a2cc5" translate="yes" xml:space="preserve">
          <source>The following functions use &lt;code&gt;$_&lt;/code&gt; as a default argument:</source>
          <target state="translated">以下函数使用 &lt;code&gt;$_&lt;/code&gt; 作为默认参数：</target>
        </trans-unit>
        <trans-unit id="0dd434c67978a923f9ec0ee28d2a5538ba5682f6" translate="yes" xml:space="preserve">
          <source>The following functions were not implemented in the VMS port, and calling them produces a fatal error (usually) or undefined behavior (rarely, we hope):</source>
          <target state="translated">以下函数没有在 VMS port 中实现,而且调用它们会产生一个致命的错误 (通常)或未定义的行为 (我们希望很少)。</target>
        </trans-unit>
        <trans-unit id="cdfa439e416672c343b7c0368293d837f0c0576b" translate="yes" xml:space="preserve">
          <source>The following functions would all be inlined:</source>
          <target state="translated">以下功能将全部内联:</target>
        </trans-unit>
        <trans-unit id="f04cb90467492e19af66e5b899cfc303ddef4110" translate="yes" xml:space="preserve">
          <source>The following global variables are associated with arenas:</source>
          <target state="translated">以下全局变量与场馆有关:</target>
        </trans-unit>
        <trans-unit id="0d3412aee89bad6343f641caa3a5d4996443527e" translate="yes" xml:space="preserve">
          <source>The following illustrates use of the Benchmark object:</source>
          <target state="translated">下面说明Benchmark对象的使用。</target>
        </trans-unit>
        <trans-unit id="21c5c52868e5d5448c65efac8d8979602bb9419b" translate="yes" xml:space="preserve">
          <source>The following information applies to gcc version 2. Volunteers to update it as appropriately for gcc version 3 would be appreciated.</source>
          <target state="translated">以下信息适用于gcc版本2。如果有志愿者能根据gcc版本3适当地更新这些信息,将不胜感激。</target>
        </trans-unit>
        <trans-unit id="62ec6b5e797715143c688dee03c54b63962fd46a" translate="yes" xml:space="preserve">
          <source>The following interfaces are provided for compatibility with existing APIs. They should not be used in new code.</source>
          <target state="translated">提供以下接口是为了与现有API兼容。不应在新代码中使用。</target>
        </trans-unit>
        <trans-unit id="0bdb13054ff9ef26849b463627b5915db32807ca" translate="yes" xml:space="preserve">
          <source>The following is a long section of miscellaneous requirements and suggestions to do with Pod processing.</source>
          <target state="translated">下面长篇累牍地介绍与花苞加工有关的杂项要求和建议。</target>
        </trans-unit>
        <trans-unit id="9eebaea88bec8281bdda401db84ecb8529c5edbd" translate="yes" xml:space="preserve">
          <source>The following is an example of a typemap that could be used for this C++ example.</source>
          <target state="translated">下面是一个可以用于这个C++例子的类型映射的例子。</target>
        </trans-unit>
        <trans-unit id="a14c2ddd24e4bc7ed4b474606997260d2d723a26" translate="yes" xml:space="preserve">
          <source>The following is the old c2ph.doc documentation by Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt; Date: 25 Jul 91 08:10:21 GMT</source>
          <target state="translated">以下是Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;的旧c2ph.doc文档。日期：91 Jul 25 08:10:21 GMT</target>
        </trans-unit>
        <trans-unit id="838c8cc6acec4e734454e6016dba1f13113970de" translate="yes" xml:space="preserve">
          <source>The following is used to &lt;a href=&quot;deprecate&quot;&gt;deprecate&lt;/a&gt; core modules beyond a certain version of Perl:</source>
          <target state="translated">以下用于&lt;a href=&quot;deprecate&quot;&gt;淘汰&lt;/a&gt;某些版本的Perl之后的核心模块：</target>
        </trans-unit>
        <trans-unit id="0c3fbe199ab2c0c87ca2506f58ce4cc1ff1336a3" translate="yes" xml:space="preserve">
          <source>The following keys allowed for callbacks. These keys are case-sensitive.</source>
          <target state="translated">以下是允许回调的键。这些键是区分大小写的。</target>
        </trans-unit>
        <trans-unit id="ace2dc9ae3a6b314c56205001ea3e99826b29341" translate="yes" xml:space="preserve">
          <source>The following keys are optional.</source>
          <target state="translated">以下是可选的键:</target>
        </trans-unit>
        <trans-unit id="87593abf1938664ef0461a9fc202ad24f5f827db" translate="yes" xml:space="preserve">
          <source>The following keys are recognised in the option hash:</source>
          <target state="translated">在选项哈希中可以识别以下键。</target>
        </trans-unit>
        <trans-unit id="2e29171b7f3395c93aba1c43b176e6a5f79f9da1" translate="yes" xml:space="preserve">
          <source>The following keys in the hash reference $CPAN::Config are currently defined:</source>
          <target state="translated">当前在哈希引用$CPAN::Config中定义了以下键。</target>
        </trans-unit>
        <trans-unit id="8faa1306b5e277a45ec730d9a598e8adafe08efc" translate="yes" xml:space="preserve">
          <source>The following layers are currently defined:</source>
          <target state="translated">目前定义的层级如下:</target>
        </trans-unit>
        <trans-unit id="8819c5fc895570a060c0cc0274e5435ca8214190" translate="yes" xml:space="preserve">
          <source>The following line is taken from the testsuite for &lt;a href=&quot;http://search.cpan.org/perldoc/File::Map&quot;&gt;File::Map&lt;/a&gt;:</source>
          <target state="translated">以下行来自&lt;a href=&quot;http://search.cpan.org/perldoc/File::Map&quot;&gt;File :: Map&lt;/a&gt;的测试套件：</target>
        </trans-unit>
        <trans-unit id="b26a944c006c4ed66106c7db11bb76fd456329ff" translate="yes" xml:space="preserve">
          <source>The following lines are equivalent:</source>
          <target state="translated">以下行文相当于:</target>
        </trans-unit>
        <trans-unit id="a27fa1a573ac1c2bd0bdaed0b154f8a047e4a778" translate="yes" xml:space="preserve">
          <source>The following list of Unicode supported features for regular expressions describes all features currently directly supported by core Perl. The references to &quot;Level N&quot; and the section numbers refer to the Unicode Technical Standard #18, &quot;Unicode Regular Expressions&quot;, version 13, from August 2008.</source>
          <target state="translated">下面的Unicode支持的正则表达式特性列表描述了目前核心Perl直接支持的所有特性。其中提到的 &quot;N级 &quot;和章节号指的是2008年8月的Unicode技术标准#18,&quot;Unicode正则表达式 &quot;第13版。</target>
        </trans-unit>
        <trans-unit id="04d2ac78ac8de1d9653897258388c5a4d402853b" translate="yes" xml:space="preserve">
          <source>The following macros must always be used to access the contents of hash entries. Note that the arguments to these macros must be simple variables, since they may get evaluated more than once. See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for detailed descriptions of these macros.</source>
          <target state="translated">必须始终使用以下宏来访问哈希条目的内容。请注意，这些宏的参数必须是简单变量，因为它们可能会被多次评估。有关这些宏的详细说明，请参见&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54cabd1569f977ca3a4b00bfe48c1954ef75d0d2" translate="yes" xml:space="preserve">
          <source>The following methods all return a boolean value and are to be overridden in the appropriate subclass.</source>
          <target state="translated">以下方法都返回一个布尔值,并在相应的子类中被重写。</target>
        </trans-unit>
        <trans-unit id="2e28c1a68a0ac1abaa1b238b7c5b433afa448fce" translate="yes" xml:space="preserve">
          <source>The following methods are available for all &lt;code&gt;Digest::&lt;/code&gt; modules:</source>
          <target state="translated">以下方法可用于所有 &lt;code&gt;Digest::&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="5d1a84015cfed0b396f9aadd71cc3704958e67dc" translate="yes" xml:space="preserve">
          <source>The following methods are available:</source>
          <target state="translated">可采用以下方法:</target>
        </trans-unit>
        <trans-unit id="7b6f41c232d0f405651a2979e1a726ffd3fbd1cf" translate="yes" xml:space="preserve">
          <source>The following methods are not supported on a per-filehandle basis.</source>
          <target state="translated">以下方法不支持每个filehandle。</target>
        </trans-unit>
        <trans-unit id="e3dd1f8a67cafbd7d4b11fa3ef01a32bc5c44916" translate="yes" xml:space="preserve">
          <source>The following methods are ones you may wish to override if you want to subclass &lt;code&gt;TAP::Harness&lt;/code&gt; .</source>
          <target state="translated">如果要继承 &lt;code&gt;TAP::Harness&lt;/code&gt; 则可能希望覆盖以下方法。</target>
        </trans-unit>
        <trans-unit id="679901c8aebeb73a7fa904b450ae5e241ed9cb03" translate="yes" xml:space="preserve">
          <source>The following methods are optional, and can be defined if the underlying lib has a fast way to do them. If undefined, Math::BigInt will use pure Perl (hence slow) fallback routines to emulate these:</source>
          <target state="translated">下面的方法是可选的,如果底层库有快速的方法,可以定义这些方法。如果未定义,Math::BigInt 将使用纯 Perl(因此速度很慢)的回退例程来模拟这些方法。</target>
        </trans-unit>
        <trans-unit id="d8157ae492dfb9da4aae902df688ee7d5be628f8" translate="yes" xml:space="preserve">
          <source>The following methods are provided in this module. Each one takes a reference to the object itself as an implicit first parameter.</source>
          <target state="translated">本模块提供了以下方法。每个方法都以对象本身的引用作为隐含的第一个参数。</target>
        </trans-unit>
        <trans-unit id="bde2e5da8041f121dd086d0f1594d72494846e0b" translate="yes" xml:space="preserve">
          <source>The following methods are provided:</source>
          <target state="translated">提供了以下方法:</target>
        </trans-unit>
        <trans-unit id="61fea790abe3137c314afb22029bb574c87067fd" translate="yes" xml:space="preserve">
          <source>The following methods are required for an API version of 2 or greater.</source>
          <target state="translated">以下方法是API版本2或更高版本所需要的。</target>
        </trans-unit>
        <trans-unit id="ec06d96f64f88685f2a77a047bae0d4b9b41fde8" translate="yes" xml:space="preserve">
          <source>The following methods are wrappers for the directory related functions built into perl (the trailing 'dir' has been removed from the names). See &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details of these functions.</source>
          <target state="translated">以下方法是perl内置的目录相关功能的包装器（名称中的尾部&amp;ldquo; dir&amp;rdquo;已删除）。有关这些功能的详细信息，请参见&lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="570150b9609694e95e958423d380ac3c5369cdc3" translate="yes" xml:space="preserve">
          <source>The following methods can be used to manipulate items anywhere in a queue.</source>
          <target state="translated">以下方法可以用来操作队列中任何地方的项目。</target>
        </trans-unit>
        <trans-unit id="1cff87e9e5dce6950df4739edc1576de748d33e5" translate="yes" xml:space="preserve">
          <source>The following methods can be used to transfer files between two remote servers, providing that these two servers can connect directly to each other.</source>
          <target state="translated">以下方法可用于在两台远程服务器之间传输文件,前提是这两台服务器可以直接相互连接。</target>
        </trans-unit>
        <trans-unit id="d8f54c9acd776fdfe4ac513355a1096a098e49e7" translate="yes" xml:space="preserve">
          <source>The following methods can return different results depending on how they are called. If the user explicitly calls either of the &lt;code&gt;pasv&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; methods then these methods will return a</source>
          <target state="translated">以下方法可以根据调用方式返回不同的结果。如果用户显式调用 &lt;code&gt;pasv&lt;/code&gt; 或 &lt;code&gt;port&lt;/code&gt; 方法，则这些方法将返回一个</target>
        </trans-unit>
        <trans-unit id="48671c770c71c327c8f21494ae7c58eef76a7413" translate="yes" xml:space="preserve">
          <source>The following methods can then be used on the compartment object returned by the above constructor. The object argument is implicit in each case.</source>
          <target state="translated">然后,可以对上述构造函数返回的隔间对象使用以下方法。在每种情况下,对象参数都是隐式的。</target>
        </trans-unit>
        <trans-unit id="a9334f5feea4574b7400347c313e7ae3bde9f0a9" translate="yes" xml:space="preserve">
          <source>The following methods deal with queues on a FIFO basis.</source>
          <target state="translated">以下方法是在FIFO的基础上处理队列。</target>
        </trans-unit>
        <trans-unit id="ee7cc6ee31a4cea12821df3d9ff6b6e073be7714" translate="yes" xml:space="preserve">
          <source>The following methods must be defined in order to support the use by Math::BigInt v1.70 or later.</source>
          <target state="translated">为了支持 Math::BigInt v1.70 或更高版本的使用,必须定义以下方法。</target>
        </trans-unit>
        <trans-unit id="1f23966e0bc23b8a5a278ce7e5e420b3556e28b8" translate="yes" xml:space="preserve">
          <source>The following methods upgrade themselves unconditionally; that is if upgrade is in effect, they will always hand up their work:</source>
          <target state="translated">以下方法是无条件升级自己的,也就是说如果升级生效,他们会一直交出自己的作品。</target>
        </trans-unit>
        <trans-unit id="314022e0b634f0a33992a5bea72595f23a273937" translate="yes" xml:space="preserve">
          <source>The following modules are currently used by bigint:</source>
          <target state="translated">目前bigint使用的模块如下。</target>
        </trans-unit>
        <trans-unit id="086b35f723ebe590f75a1aea7b6b1150783292e6" translate="yes" xml:space="preserve">
          <source>The following modules are currently used by bignum:</source>
          <target state="translated">bignum目前使用的模块如下。</target>
        </trans-unit>
        <trans-unit id="d93609e5247b12617e4dd3f00cb7708916287a29" translate="yes" xml:space="preserve">
          <source>The following names have special meaning to Perl. Most punctuation names have reasonable mnemonics, or analogs in the shells. Nevertheless, if you wish to use long variable names, you need only say:</source>
          <target state="translated">以下名称对Perl有特殊意义。大多数标点符号名称都有合理的记忆符号,或者在shell中的类似符号。不过,如果你想使用长的变量名,你只需要说。</target>
        </trans-unit>
        <trans-unit id="8937b6a268204b01bd09b0791adaf0dc939c65b5" translate="yes" xml:space="preserve">
          <source>The following options affect what happens with &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;x&lt;/code&gt; commands:</source>
          <target state="translated">以下选项影响 &lt;code&gt;V&lt;/code&gt; ， &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 命令的操作：</target>
        </trans-unit>
        <trans-unit id="87ad7915cdbf5aabf9ec8f4e6f650717a3e51ad5" translate="yes" xml:space="preserve">
          <source>The following options are available:</source>
          <target state="translated">有以下选项:</target>
        </trans-unit>
        <trans-unit id="5530497eb21d4e6a6dcc738d7ea1b33bd3ad244e" translate="yes" xml:space="preserve">
          <source>The following options are pairwise exclusive.</source>
          <target state="translated">以下选项是成对的。</target>
        </trans-unit>
        <trans-unit id="82fa31556e7811972756a886a4cfa29a126dcd22" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the underlying text formatter. See the manual pages of these modules for more information.</source>
          <target state="translated">以下选项会传递给底层文本格式化器。更多信息请参见这些模块的手册页面。</target>
        </trans-unit>
        <trans-unit id="407cb3c611809d0d6a4a0229085dace99fab8aca" translate="yes" xml:space="preserve">
          <source>The following options are supported: center, date, fixed, fixedbold, fixeditalic, fixedbolditalic, quotes, release, section</source>
          <target state="translated">支持以下选项:居中、日期、固定、固定黑体、固定黑体、固定黑体、引号、发布、部分。</target>
        </trans-unit>
        <trans-unit id="f9719c919f328c184200e9a901169faf3fe1692f" translate="yes" xml:space="preserve">
          <source>The following pattern matches a function foo() which may contain balanced parentheses as the argument.</source>
          <target state="translated">下面的模式与函数foo()匹配,该函数可能包含平衡括号作为参数。</target>
        </trans-unit>
        <trans-unit id="88eac117835fd0d5e8fe0a92e17ee881d0f51bb6" translate="yes" xml:space="preserve">
          <source>The following pattern matches a parenthesized group:</source>
          <target state="translated">下面的模式与一个小括号组相匹配。</target>
        </trans-unit>
        <trans-unit id="9261bf4cae54928a9960941cd2e6c763bb03b07b" translate="yes" xml:space="preserve">
          <source>The following platforms are known to build Perl 5.12 (as of April 2010, its release date) from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src&quot;&gt;http://www.cpan.org/src&lt;/a&gt;</source>
          <target state="translated">已知以下平台可从&lt;a href=&quot;http://www.cpan.org/src&quot;&gt;http://www.cpan.org/src上&lt;/a&gt;提供的标准源代码发行版中构建Perl 5.12（截至2010年4月，其发布日期）。</target>
        </trans-unit>
        <trans-unit id="3340ff1c2b446edebeb559ea5dd147cf80639131" translate="yes" xml:space="preserve">
          <source>The following platforms have been known to build Perl from source in the past (5.005_03 and earlier), but we haven't been able to verify their status for the current release, either because the hardware/software platforms are rare or because we don't have an active champion on these platforms--or both. They used to work, though, so go ahead and try compiling them, and let perlbug@perl.org of any trouble.</source>
          <target state="translated">以下平台在过去(5.005_03及更早的版本)曾被认为可以从源码中构建Perl,但我们还无法验证它们在当前版本中的状态,这可能是因为这些硬件/软件平台很少,也可能是因为我们在这些平台上没有一个活跃的冠军--或者两者都有。不过,它们曾经是可以工作的,所以请继续尝试编译它们,如果有任何问题,请告诉perlbug@perl.org。</target>
        </trans-unit>
        <trans-unit id="8c95fcd90364c113c8743d95c16878f685bbdec9" translate="yes" xml:space="preserve">
          <source>The following platforms have only binaries available via &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; :</source>
          <target state="translated">以下平台只有通过&lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt;提供的二进制文件：</target>
        </trans-unit>
        <trans-unit id="17f6cd1b99f9d8c8f96a2484ba6123182c8c7ea5" translate="yes" xml:space="preserve">
          <source>The following platforms have their own source code distributions and binaries available via &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt;</source>
          <target state="translated">以下平台具有自己的源代码发行版和二进制文件，可通过&lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt;获得。</target>
        </trans-unit>
        <trans-unit id="ba4505bcfd3048861117fe3f1683581b473bc260" translate="yes" xml:space="preserve">
          <source>The following platforms were supported by a previous version of Perl but have been officially removed from Perl's source code as of 5.12:</source>
          <target state="translated">以前的Perl版本支持以下平台,但从5.12开始已经正式从Perl的源代码中删除。</target>
        </trans-unit>
        <trans-unit id="231bce91c0774cb9ac67f2e9bf6e077f99a9edec" translate="yes" xml:space="preserve">
          <source>The following platforms were supported by a previous version of Perl but have been officially removed from Perl's source code as of 5.20:</source>
          <target state="translated">以下平台在以前的Perl版本中是支持的,但从5.20开始已经正式从Perl的源代码中删除。</target>
        </trans-unit>
        <trans-unit id="ce7175eecbb5cf889a2f2cc3f026e2da7a9136e7" translate="yes" xml:space="preserve">
          <source>The following platforms were supported up to 5.10. They may still have worked in 5.12, but supporting code has been removed for 5.14:</source>
          <target state="translated">以下平台在5.10之前一直被支持。它们在5.12中可能还能使用,但5.14中的支持代码已被删除。</target>
        </trans-unit>
        <trans-unit id="446fc2176911919a5044a357259301549c936213" translate="yes" xml:space="preserve">
          <source>The following platforms worked with the previous releases (5.6 and 5.7), but we did not manage either to fix or to test these in time for the 5.8.0 release. There is a very good chance that many of these will work fine with the 5.8.0.</source>
          <target state="translated">以下平台在之前的版本(5.6和5.7)中可以使用,但我们没有及时修复或测试这些平台,以便在5.8.0版本中使用。这些平台中的许多平台很有可能在5.8.0版本中正常工作。</target>
        </trans-unit>
        <trans-unit id="637d6920710e051f990eceb2af393917b297b61a" translate="yes" xml:space="preserve">
          <source>The following pragmas are defined (and have their own documentation).</source>
          <target state="translated">定义了以下实用程序(并有自己的文档)。</target>
        </trans-unit>
        <trans-unit id="3e891a8176dfddab918a655b139307ab8b66b513" translate="yes" xml:space="preserve">
          <source>The following primary functions are provided:</source>
          <target state="translated">提供了以下主要功能:</target>
        </trans-unit>
        <trans-unit id="bbf69375b2075818b8dae7a187b7c74a5295e91b" translate="yes" xml:space="preserve">
          <source>The following problems are encountered with Haiku revision 28311:</source>
          <target state="translated">俳优修订版28311遇到以下问题。</target>
        </trans-unit>
        <trans-unit id="d89ada30f3c9b0885c9f6f1b4c7448cd518fcaa4" translate="yes" xml:space="preserve">
          <source>The following returns the &lt;b&gt;names&lt;/b&gt; of the PerlIO layers on a filehandle.</source>
          <target state="translated">以下内容返回文件句柄上PerlIO层的&lt;b&gt;名称&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="1bc9e3e129e691ac04ecb6526cec5a595482fff6" translate="yes" xml:space="preserve">
          <source>The following revisions are supported. The default is 30.</source>
          <target state="translated">支持以下版本。默认值为30。</target>
        </trans-unit>
        <trans-unit id="c446e9a76c2a849f3d9283f94a02c3c2d25e461d" translate="yes" xml:space="preserve">
          <source>The following routines will be exported into your namespace if you specifically ask that they be imported:</source>
          <target state="translated">如果您特别要求导入以下例程,它们将被导出到您的命名空间。</target>
        </trans-unit>
        <trans-unit id="019be2c4bd05e066f928aafadb59663b3afde865" translate="yes" xml:space="preserve">
          <source>The following routines will be exported into your namespace if you use the Benchmark module:</source>
          <target state="translated">如果你使用Benchmark模块,以下例程将被导出到你的命名空间。</target>
        </trans-unit>
        <trans-unit id="de855448328b5e9f80cc8ce9168a701f985757d7" translate="yes" xml:space="preserve">
          <source>The following rules apply:</source>
          <target state="translated">适用以下规则:</target>
        </trans-unit>
        <trans-unit id="c3f236092c86ae50065ffb55ca5283dcb8508783" translate="yes" xml:space="preserve">
          <source>The following rules are available:</source>
          <target state="translated">有以下规则:</target>
        </trans-unit>
        <trans-unit id="a8f5fc7c9bec47fa12d0874b935f8fd0b4ed0730" translate="yes" xml:space="preserve">
          <source>The following sample implementation of &lt;code&gt;minus()&lt;/code&gt; (which assumes that &lt;code&gt;Number&lt;/code&gt; objects are simply blessed references to scalars) illustrates the calling conventions:</source>
          <target state="translated">以下 &lt;code&gt;minus()&lt;/code&gt; 的示例实现（假设 &lt;code&gt;Number&lt;/code&gt; 对象只是对标量的简单引用）说明了调用约定：</target>
        </trans-unit>
        <trans-unit id="67999be44740f8addea9fce4caf76726233a8acf" translate="yes" xml:space="preserve">
          <source>The following sequences (except &lt;code&gt;\N&lt;/code&gt; ) work within or without a character class. The first six are locale aware, all are Unicode aware. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details.</source>
          <target state="translated">以下序列（ &lt;code&gt;\N&lt;/code&gt; 除外）可在字符类之内或之外使用。前六个是区域设置感知的，所有都是Unicode感知的。有关详细信息，请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;和&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6520d28097d378d9470274294d01c67b34c1c70f" translate="yes" xml:space="preserve">
          <source>The following set of functions all reduce a list down to a single value.</source>
          <target state="translated">以下一组函数都是将一个列表缩减为一个值。</target>
        </trans-unit>
        <trans-unit id="31f700e59048089f2fca9626afc48c135af0fec0" translate="yes" xml:space="preserve">
          <source>The following set of functions, all inspired by &lt;a href=&quot;http://search.cpan.org/perldoc/List::Pairwise&quot;&gt;List::Pairwise&lt;/a&gt;, consume an even-sized list of pairs. The pairs may be key/value associations from a hash, or just a list of values. The functions will all preserve the original ordering of the pairs, and will not be confused by multiple pairs having the same &quot;key&quot; value - nor even do they require that the first of each pair be a plain string.</source>
          <target state="translated">以下所有受&lt;a href=&quot;http://search.cpan.org/perldoc/List::Pairwise&quot;&gt;List :: Pairwise&lt;/a&gt;启发的函数集消耗了偶数大小的对列表。这些对可以是哈希中的键/值关联，也可以只是值列表。这些函数将全部保留对的原始顺序，并且不会被具有相同&amp;ldquo;键&amp;rdquo;值的多个对所混淆-甚至它们都不需要每对中的第一对都是纯字符串。</target>
        </trans-unit>
        <trans-unit id="bf58c9289e75f1b85afc527d37ec88624aafe8e0" translate="yes" xml:space="preserve">
          <source>The following setting are currently preserved: history, breakpoints, actions, debugger options, and the Perl command-line options &lt;b&gt;-w&lt;/b&gt;, &lt;b&gt;-I&lt;/b&gt;, and &lt;b&gt;-e&lt;/b&gt;.</source>
          <target state="translated">当前保留以下设置：历史记录，断点，操作，调试器选项以及Perl命令行选项&lt;b&gt;-w&lt;/b&gt;，&lt;b&gt;-I&lt;/b&gt;和&lt;b&gt;-e&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2f9e7f8b992aecf2d6263a37f2844fd220110139" translate="yes" xml:space="preserve">
          <source>The following shows how using negative indexing can make it easier to embed recursive patterns inside of a &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; construct for later use:</source>
          <target state="translated">下面显示了使用负索引如何使将递归模式嵌入 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 构造内部以供以后使用变得更加容易：</target>
        </trans-unit>
        <trans-unit id="1462e7325e21b0e3087981f44f0af9a643d8599d" translate="yes" xml:space="preserve">
          <source>The following shows the raw form of a reference to a hash.</source>
          <target state="translated">下面显示了引用哈希的原始形式。</target>
        </trans-unit>
        <trans-unit id="967f133103c60d10e71b0c793260fc3ac77b40c4" translate="yes" xml:space="preserve">
          <source>The following single statement:</source>
          <target state="translated">以下单项声明:</target>
        </trans-unit>
        <trans-unit id="2e884b22f85adb1ade979bfac548d842a78ee34c" translate="yes" xml:space="preserve">
          <source>The following standard quantifiers are recognized:</source>
          <target state="translated">以下是公认的标准定量器:</target>
        </trans-unit>
        <trans-unit id="f4477e5386cec5d30c1ffdf2df262ef158032a46" translate="yes" xml:space="preserve">
          <source>The following structure is used as the &lt;code&gt;pprivate&lt;/code&gt; struct by perl's regex engine. Since it is specific to perl it is only of curiosity value to other engine implementations.</source>
          <target state="translated">以下结构被perl的regex引擎用作 &lt;code&gt;pprivate&lt;/code&gt; 结构。由于它特定于perl，因此仅对其他引擎实现具有好奇心。</target>
        </trans-unit>
        <trans-unit id="89e9367ea2c2e9bf561ef1309852d2cf7361c03c" translate="yes" xml:space="preserve">
          <source>The following subroutines are available for general use once this module has been loaded:</source>
          <target state="translated">本模块加载后,以下子程序可供一般使用。</target>
        </trans-unit>
        <trans-unit id="ba25a356d8138d41be0a86a5f5fb1d08b7adedd8" translate="yes" xml:space="preserve">
          <source>The following subsections describe basic locale categories. Beyond these, some combination categories allow manipulation of more than one basic category at a time. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; for a discussion of these.</source>
          <target state="translated">以下小节介绍了基本的语言环境类别。除此之外，一些组合类别还允许一次操纵多个基本类别。有关这些的讨论，请参见&lt;a href=&quot;#ENVIRONMENT&quot;&gt;环境&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00832acd024c7ea26f0714974719f6fe15f3259e" translate="yes" xml:space="preserve">
          <source>The following systems contain with PA-RISC 1.1 chips:</source>
          <target state="translated">以下系统含有PA-RISC 1.1芯片。</target>
        </trans-unit>
        <trans-unit id="6b127f4160144d76492f304d4812a08c409c1ee2" translate="yes" xml:space="preserve">
          <source>The following systems contained PA-RISC 1.0 chips:</source>
          <target state="translated">以下系统包含PA-RISC 1.0芯片:</target>
        </trans-unit>
        <trans-unit id="c10d1b335971cff8856d57f7108722f96d961255" translate="yes" xml:space="preserve">
          <source>The following table is a complete listing of characters matched by &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; as of Unicode 6.3.</source>
          <target state="translated">下表是从Unicode 6.3开始由 &lt;code&gt;\s&lt;/code&gt; ， &lt;code&gt;\h&lt;/code&gt; 和 &lt;code&gt;\v&lt;/code&gt; 匹配的字符的完整列表。</target>
        </trans-unit>
        <trans-unit id="b30fe71571a9a6420e717590392f76849f4888c3" translate="yes" xml:space="preserve">
          <source>The following table is from Unicode 3.2.</source>
          <target state="translated">下表来自Unicode 3.2。</target>
        </trans-unit>
        <trans-unit id="08ac1fd17048e5aaff438c3920650ea36fe28bd5" translate="yes" xml:space="preserve">
          <source>The following table shows the result of the division and the remainder, so that the equation above holds true. Some &quot;ordinary&quot; cases are strewn in to show more clearly the reasoning:</source>
          <target state="translated">下表显示了除法和余数的结果,所以上面的公式成立。为了更清楚地显示出其中的道理,还散布了一些 &quot;普通 &quot;的情况。</target>
        </trans-unit>
        <trans-unit id="3985fef65ba4e91f6d3780d0b3e49df58907d0ee" translate="yes" xml:space="preserve">
          <source>The following table summarizes the default layers on UNIX-like and DOS-like platforms and depending on the setting of &lt;code&gt;$ENV{PERLIO}&lt;/code&gt; :</source>
          <target state="translated">下表总结了类似UNIX和类似DOS的平台上的默认层，具体取决于 &lt;code&gt;$ENV{PERLIO}&lt;/code&gt; 的设置：</target>
        </trans-unit>
        <trans-unit id="72667df1c110c1893cb08480bc1c250b48c0cb32" translate="yes" xml:space="preserve">
          <source>The following tables list the ASCII and Latin 1 ordered sets including the subsets: C0 controls (0..31), ASCII graphics (32..7e), delete (7f), C1 controls (80..9f), and Latin-1 (a.k.a. ISO 8859-1) (a0..ff). In the table names of the Latin 1 extensions to ASCII have been labelled with character names roughly corresponding to</source>
          <target state="translated">下表列出了包括子集在内的ASCII和拉丁文1的有序集,其中包括C0控制(0...31)、ASCII图形(32...7e)、删除(7f)、C1控制(80...9f)和拉丁文1(又称ISO 885)。C0控制(0...31)、ASCII图形(32...7e)、删除(7f)、C1控制(80...9f)和拉丁文1(又名ISO 8859-1)(a0...ff)。在表格中,对ASCII的拉丁文1扩展的名称已经用大致对应于以下的字符名称进行了标注</target>
        </trans-unit>
        <trans-unit id="a992ed291bf59a4f8c8642c8859ba903d7ab1f6d" translate="yes" xml:space="preserve">
          <source>The following tests are still failing for Perl 5.8.1 under QNX 6.2.0:</source>
          <target state="translated">在 QNX 6.2.0 下,Perl 5.8.1 的以下测试仍然失败。</target>
        </trans-unit>
        <trans-unit id="679b51afc9785d4ea117543e0a14a59d2cf8f5c2" translate="yes" xml:space="preserve">
          <source>The following tests may report errors under QNX4:</source>
          <target state="translated">下列测试可能会在 QNX4 下报告错误。</target>
        </trans-unit>
        <trans-unit id="3fcf934fd04c9d50192b3311166eff55a4dd9606" translate="yes" xml:space="preserve">
          <source>The following three functions copy integer, unsigned integer or double into an SV whose reference is &lt;code&gt;rv&lt;/code&gt; . SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">以下三个函数将整数，无符号整数或双精度型复制到引用为 &lt;code&gt;rv&lt;/code&gt; 的SV中。如果 &lt;code&gt;classname&lt;/code&gt; 不为null，则SV被祝福。</target>
        </trans-unit>
        <trans-unit id="ab708869e7683ae4c6749cf27fcceca80c5c3008" translate="yes" xml:space="preserve">
          <source>The following three macros are used to initially allocate memory :</source>
          <target state="translated">以下三个宏用于初始分配内存。</target>
        </trans-unit>
        <trans-unit id="2d49873237bd9d666bf47ecb1ff27e7adc795d90" translate="yes" xml:space="preserve">
          <source>The following two calls behave identically:</source>
          <target state="translated">以下两个调用的行为是相同的。</target>
        </trans-unit>
        <trans-unit id="2886be86660a6181dbf2332b9a39bde42d1bded2" translate="yes" xml:space="preserve">
          <source>The following types of change are NOT acceptable:</source>
          <target state="translated">以下类型的变更是不可接受的:</target>
        </trans-unit>
        <trans-unit id="000a0a677c5358a2d9618715cbd6c3b2ea88fed1" translate="yes" xml:space="preserve">
          <source>The following types of change may be considered acceptable, as long as they do not also fall into any of the &quot;unacceptable&quot; categories set out below:</source>
          <target state="translated">以下类型的变更可以被认为是可以接受的,只要它们不属于以下任何 &quot;不可接受 &quot;的类别:</target>
        </trans-unit>
        <trans-unit id="502bd00665528041c42b284ac29aaf12f2929946" translate="yes" xml:space="preserve">
          <source>The following values can be set by passing &lt;code&gt;config()&lt;/code&gt; a reference to a hash:</source>
          <target state="translated">可以通过向 &lt;code&gt;config()&lt;/code&gt; 传递对哈希的引用来设置以下值：</target>
        </trans-unit>
        <trans-unit id="93c42f22f8e09b7cd455ba48443cb114b75d6049" translate="yes" xml:space="preserve">
          <source>The following variables are 'defined' by B::Concise; when they are used in a style, their respective values are plugged into the rendering of each opcode.</source>
          <target state="translated">以下变量由B::Concise &quot;定义&quot;;当它们被用于一个样式时,它们各自的值被插入到每个操作码的渲染中。</target>
        </trans-unit>
        <trans-unit id="706034b4d6cc89451a1849a613921860ab0e5afc" translate="yes" xml:space="preserve">
          <source>The following variables need to be set &lt;b&gt;before&lt;/b&gt; the call to the -&amp;gt;new constructor.</source>
          <target state="translated">在调用-&amp;gt; new构造函数&lt;b&gt;之前&lt;/b&gt;，需要设置以下变量。</target>
        </trans-unit>
        <trans-unit id="182dfc2e543ebf62f55632eff4a16082cef70bfe" translate="yes" xml:space="preserve">
          <source>The following variables work differently:</source>
          <target state="translated">以下变量的工作方式不同:</target>
        </trans-unit>
        <trans-unit id="076a97e0e26cc34846172ca450710de9a3595069" translate="yes" xml:space="preserve">
          <source>The following were implemented with</source>
          <target state="translated">实施了以下措施</target>
        </trans-unit>
        <trans-unit id="79ed55c53c285526808c76c6e4fadf315b9d9ae9" translate="yes" xml:space="preserve">
          <source>The following will determine the maximum length of the longest allowable pathname on the filesystem which holds</source>
          <target state="translated">下面将确定在文件系统中,允许的最长路径名的最大长度,该路径名为</target>
        </trans-unit>
        <trans-unit id="d57dd39f43cd00fc9fcf08a3e6ef2330c6e56ff0" translate="yes" xml:space="preserve">
          <source>The following will determine the maximum length of the longest allowable pathname on the filesystem which holds &lt;code&gt;/var&lt;/code&gt;.</source>
          <target state="translated">下面将确定保存 &lt;code&gt;/var&lt;/code&gt; 的文件系统上允许的最长路径名的最大长度。</target>
        </trans-unit>
        <trans-unit id="5cbb13ad67db7840db7c7d12b58ddc55ef0ed900" translate="yes" xml:space="preserve">
          <source>The following will get the machine's clock speed.</source>
          <target state="translated">下面将得到机器的时钟速度。</target>
        </trans-unit>
        <trans-unit id="577c472e2dc0fc4d87aa88d05e48ae7e476e2971" translate="yes" xml:space="preserve">
          <source>The following will probably not do what you expect:</source>
          <target state="translated">下面的内容可能不会如你所愿。</target>
        </trans-unit>
        <trans-unit id="5c8bd82fe901dea332f23983ad9e29577c0fed4c" translate="yes" xml:space="preserve">
          <source>The following will probably not print what you expect:</source>
          <target state="translated">下面的内容可能不会像你期望的那样打印。</target>
        </trans-unit>
        <trans-unit id="119de64c9692dd9e013f0596370be8f29169b856" translate="yes" xml:space="preserve">
          <source>The following will query the current &lt;code&gt;LC_CTYPE&lt;/code&gt; category. (No second argument means 'query'.)</source>
          <target state="translated">下面将查询当前的 &lt;code&gt;LC_CTYPE&lt;/code&gt; 类别。（没有第二个参数表示&amp;ldquo;查询&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="5966453b4cde6268559966748dc7d8bf8fdd0ec2" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_COLLATE&lt;/code&gt; behaviour to Argentinian Spanish. &lt;b&gt;NOTE&lt;/b&gt;: The naming and availability of locales depends on your operating system. Please consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for how to find out which locales are available in your system.</source>
          <target state="translated">下面将把 &lt;code&gt;LC_COLLATE&lt;/code&gt; 行为设置为阿根廷西班牙语。&lt;b&gt;注意&lt;/b&gt;：语言环境的命名和可用性取决于您的操作系统。请咨询&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;以了解如何找出系统中可用的语言环境。</target>
        </trans-unit>
        <trans-unit id="5abcdbfe7d0b6ac6ed18a19f7b6cc537b1839b5d" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_CTYPE&lt;/code&gt; behaviour according to the locale environment variables (the second argument &lt;code&gt;&quot;&quot;&lt;/code&gt; ). Please see your system's &lt;code&gt;setlocale(3)&lt;/code&gt; documentation for the locale environment variables' meaning or consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">下面将根据语言环境环境变量（第二个参数 &lt;code&gt;&quot;&quot;&lt;/code&gt; ）设置 &lt;code&gt;LC_CTYPE&lt;/code&gt; 行为。请参阅系统的 &lt;code&gt;setlocale(3)&lt;/code&gt; 文档以了解语言环境环境变量的含义，或查阅&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecbd57a3195c4519fb09fab198f3facf1b32479f" translate="yes" xml:space="preserve">
          <source>The following will set the traditional UNIX system locale behavior (the second argument &lt;code&gt;&quot;C&quot;&lt;/code&gt; ).</source>
          <target state="translated">下面将设置传统的UNIX系统语言环境行为（第二个参数 &lt;code&gt;&quot;C&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d394598bfc021311cf0f2bb824273bc318b5797a" translate="yes" xml:space="preserve">
          <source>The following would first try to find Math::BigInt::Foo, then Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:</source>
          <target state="translated">下面会先尝试寻找Math::BigInt::Foo,然后再寻找Math::BigInt::Bar,当这也失败时,再回复到Math::BigInt::Calc。</target>
        </trans-unit>
        <trans-unit id="9ce20518f56534bcc1118c0bf986d78eef528c90" translate="yes" xml:space="preserve">
          <source>The following:</source>
          <target state="translated">以下是:</target>
        </trans-unit>
        <trans-unit id="678f5358c7187caa2da5eff48aaaa0b704fbae9c" translate="yes" xml:space="preserve">
          <source>The followings items are mostly for reference and general Unicode knowledge, Perl doesn't use these constructs internally.</source>
          <target state="translated">下面的内容主要是供参考和一般的Unicode知识,Perl内部并没有使用这些结构。</target>
        </trans-unit>
        <trans-unit id="0e4f79728d04ec0471d6bf96e407b112aa0cabf3" translate="yes" xml:space="preserve">
          <source>The foregoing mechanism for overriding built-in is restricted, quite deliberately, to the package that requests the import. There is a second method that is sometimes applicable when you wish to override a built-in everywhere, without regard to namespace boundaries. This is achieved by importing a sub into the special namespace &lt;code&gt;CORE::GLOBAL::&lt;/code&gt; . Here is an example that quite brazenly replaces the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator with something that understands regular expressions.</source>
          <target state="translated">覆盖内置的上述机制非常有意地限于请求导入的包。当您希望在任何地方覆盖内置而不考虑名称空间边界时，还有第二种方法有时适用。这是通过将子项导入特殊名称空间 &lt;code&gt;CORE::GLOBAL::&lt;/code&gt; 。这是一个用理解正则表达式的东西大胆地替换 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 运算符的示例。</target>
        </trans-unit>
        <trans-unit id="b85c90a6a43ec9e5bf7a5a11ec769ca8bd55e119" translate="yes" xml:space="preserve">
          <source>The fork() emulation is implemented at the level of the Perl interpreter. What this means in general is that running fork() will actually clone the running interpreter and all its state, and run the cloned interpreter in a separate thread, beginning execution in the new thread just after the point where the fork() was called in the parent. We will refer to the thread that implements this child &quot;process&quot; as the pseudo-process.</source>
          <target state="translated">fork()的仿真是在Perl解释器的层面上实现的。一般来说,这意味着运行fork()实际上会克隆正在运行的解释器和它的所有状态,并在一个单独的线程中运行克隆的解释器,在父线程中调用fork()的点之后开始在新线程中执行。我们将把实现这个子 &quot;进程 &quot;的线程称为伪进程。</target>
        </trans-unit>
        <trans-unit id="e04f09879ad602b86af95f9f6d5d371e6757eda4" translate="yes" xml:space="preserve">
          <source>The fork() emulation may not behave as expected when it is executed in an application which embeds a Perl interpreter and calls Perl APIs that can evaluate bits of Perl code. This stems from the fact that the emulation only has knowledge about the Perl interpreter's own data structures and knows nothing about the containing application's state. For example, any state carried on the application's own call stack is out of reach.</source>
          <target state="translated">fork()仿真在嵌入Perl解释器并调用Perl API的应用程序中执行时,可能不会像预期那样表现。这源于这样一个事实,即仿真只了解Perl解释器自身的数据结构,而对包含应用程序的状态一无所知。例如,应用程序自己的调用堆栈上携带的任何状态都是无法获取的。</target>
        </trans-unit>
        <trans-unit id="0708717756f902c5ff59069bd45289469d28d91c" translate="yes" xml:space="preserve">
          <source>The fork() emulation will not work entirely correctly when called from within a BEGIN block. The forked copy will run the contents of the BEGIN block, but will not continue parsing the source stream after the BEGIN block. For example, consider the following code:</source>
          <target state="translated">当从BEGIN块中调用fork()仿真时,它将不能完全正确地工作。fork()的副本将运行BEGIN块的内容,但不会在BEGIN块之后继续解析源流。例如,考虑以下代码。</target>
        </trans-unit>
        <trans-unit id="15be1c6ce9042f03bee94913baeb82a3ff565ee8" translate="yes" xml:space="preserve">
          <source>The fork() has to come before the setsid() to ensure you aren't a process group leader; the setsid() will fail if you are. If your system doesn't have the setsid() function, open</source>
          <target state="translated">fork()必须在setsid()之前出现,以确保你不是进程组组长;如果你是,setsid()就会失败。如果你的系统没有setsid()函数,打开</target>
        </trans-unit>
        <trans-unit id="9d31d094967d18a344cd7885a66ada91947ca8a3" translate="yes" xml:space="preserve">
          <source>The forked debugger requires the environment variable &lt;code&gt;TERM&lt;/code&gt; to be &lt;code&gt;xterm&lt;/code&gt; , and the environment variable &lt;code&gt;DISPLAY&lt;/code&gt; to exist. &lt;code&gt;xterm&lt;/code&gt; must be in lower case.</source>
          <target state="translated">分叉的调试器要求环境变量 &lt;code&gt;TERM&lt;/code&gt; 为 &lt;code&gt;xterm&lt;/code&gt; ，并且环境变量 &lt;code&gt;DISPLAY&lt;/code&gt; 存在。 &lt;code&gt;xterm&lt;/code&gt; 必须小写。</target>
        </trans-unit>
        <trans-unit id="90a1b936aa7515813dbe100195592b08e94ebcb1" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;$x **= $y&lt;/code&gt; is faster than &lt;code&gt;$x = $x ** $y;&lt;/code&gt; , though.</source>
          <target state="translated">&lt;code&gt;$x **= $y&lt;/code&gt; 的形式比 &lt;code&gt;$x = $x ** $y;&lt;/code&gt; 的形式快；不过。</target>
        </trans-unit>
        <trans-unit id="ea29df8f31e738f8731934d29265ffb8df1b05f7" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt;, available in Perl 4, is no longer available. Replace any occurrence of &lt;code&gt;if BLOCK&lt;/code&gt; by &lt;code&gt;if (&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK)&lt;/code&gt; .</source>
          <target state="translated">Perl 4中可用的 &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt; 表格不再可用。更换出现的任何 &lt;code&gt;if BLOCK&lt;/code&gt; 的 &lt;code&gt;if (&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0d89d2ce75f6dd9a5b033644a202a3e0573863e" translate="yes" xml:space="preserve">
          <source>The formal syntax of a section specification is:</source>
          <target state="translated">剖面规范的形式语法是。</target>
        </trans-unit>
        <trans-unit id="feafac52c2f0bb1c62c34d80f1ccae00a8b7bff5" translate="yes" xml:space="preserve">
          <source>The format is roughly the same as a header section except for the fallback flag: | followed by 0..3. The meaning of the possible values is as follows:</source>
          <target state="translated">除了回退标志外,格式与头部分大致相同。| 后面是0...3。可能的值的含义如下。</target>
        </trans-unit>
        <trans-unit id="7de51818a43a9eeabc5f149d791bcd953969e5ec" translate="yes" xml:space="preserve">
          <source>The format is the same as PREREQ_PM.</source>
          <target state="translated">格式与PREREQ_PM相同。</target>
        </trans-unit>
        <trans-unit id="4a91025674068746c104cf678dff09a87e09a62d" translate="yes" xml:space="preserve">
          <source>The format is:</source>
          <target state="translated">其格式为:</target>
        </trans-unit>
        <trans-unit id="cab7930ea8f9bb0b5e8551406e705f9d6d55872a" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 的构造函数的格式如下所示</target>
        </trans-unit>
        <trans-unit id="2b7f4c6f10c021d585a52efc7c38f1f01339227d" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 的构造函数格式如下所示</target>
        </trans-unit>
        <trans-unit id="e03dc6c86b8958f9b62ec7a6a483ad0e4753decb" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 的构造函数格式如下所示</target>
        </trans-unit>
        <trans-unit id="2cd916282c4e6b36ecc3a6af27b028bb638d27b9" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 的构造函数的格式如下所示</target>
        </trans-unit>
        <trans-unit id="96cf103266184d2ab7c512526262f24222f5b3fa" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Zip&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Zip&lt;/code&gt; 的构造函数格式如下所示</target>
        </trans-unit>
        <trans-unit id="7cddd4e7224584228dd40d8278ce06df26d30be6" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::AnyInflate is shown below</source>
          <target state="translated">IO::Uncompress::AnyInflate的构造函数的格式如下所示。</target>
        </trans-unit>
        <trans-unit id="f335334476f7fdad7a158077eda96d1e77d620ba" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::AnyUncompress is shown below</source>
          <target state="translated">IO::Uncompress::AnyUncompress的构造函数的格式如下所示。</target>
        </trans-unit>
        <trans-unit id="d8f9f10c69da3c0a902ce3d0bf3a43a4fe3d0d99" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Bunzip2 is shown below</source>
          <target state="translated">IO::Uncompress::Bunzip2的构造函数的格式如下所示。</target>
        </trans-unit>
        <trans-unit id="1aee64e705754fe9513f8b1c5a275541fbf25126" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Gunzip is shown below</source>
          <target state="translated">IO::Uncompress::Gunzip的构造函数的格式如下所示。</target>
        </trans-unit>
        <trans-unit id="e0479ea0c00c6dbc0391fab896f56792a7f58abf" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Inflate is shown below</source>
          <target state="translated">IO::Uncompress::Inflate的构造函数的格式如下所示。</target>
        </trans-unit>
        <trans-unit id="abbcd988c20a7a7af1b1b62b62f212c0f098a642" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::RawInflate is shown below</source>
          <target state="translated">IO::Uncompress::RawInflate的构造函数的格式如下所示。</target>
        </trans-unit>
        <trans-unit id="266217c42524ecb82328e7bc0e8f8cf67f30e119" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Unzip is shown below</source>
          <target state="translated">IO::Uncompress::Unzip的构造函数的格式如下所示。</target>
        </trans-unit>
        <trans-unit id="6ce17f5dc7d5e6006e0ab81d86bb016be0d29f0f" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;#gmtime&quot;&gt;gmtime&lt;/a&gt; builtin. See also the &lt;code&gt;Time::Local&lt;/code&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by time()), and the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's strftime(3) and mktime(3) functions.</source>
          <target state="translated">该标量值的格式与语言环境&lt;b&gt;无关，&lt;/b&gt;而是内置于Perl中。对于GMT而非本地时间，请使用内置的&lt;a href=&quot;#gmtime&quot;&gt;gmtime&lt;/a&gt;。另请参见 &lt;code&gt;Time::Local&lt;/code&gt; 模块（用于将秒，分钟，小时等转换回time（）返回的整数值），以及&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块的strftime（3）和mktime（3）函数。</target>
        </trans-unit>
        <trans-unit id="e2da41af1cf680b6887d63dd253c6e01471391c6" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;gmtime&quot;&gt;gmtime&lt;/a&gt; builtin. See also the &lt;code&gt;Time::Local&lt;/code&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by time()), and the &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; module's strftime(3) and mktime(3) functions.</source>
          <target state="translated">该标量值的格式与语言环境&lt;b&gt;无关，&lt;/b&gt;而是内置于Perl中。对于GMT而非本地时间，请使用内置的&lt;a href=&quot;gmtime&quot;&gt;gmtime&lt;/a&gt;。另请参见 &lt;code&gt;Time::Local&lt;/code&gt; 模块（用于将秒，分钟，小时等转换回time（）返回的整数值），以及&lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;模块的strftime（3）和mktime（3）函数。</target>
        </trans-unit>
        <trans-unit id="7fb9dcbdf87a920318a01eb480379e8f7c7c3de2" translate="yes" xml:space="preserve">
          <source>The format specifier detection is not complete printf-syntax detection, but it should catch most common cases.</source>
          <target state="translated">格式指定符检测并不是完整的printf-syntax检测,但它应该能抓住大多数常见的情况。</target>
        </trans-unit>
        <trans-unit id="256ecd9d04a27fc1ec23dd2c77863e67bcf5ad16" translate="yes" xml:space="preserve">
          <source>The formats supported are</source>
          <target state="translated">支持的格式有</target>
        </trans-unit>
        <trans-unit id="0577a9efbbb4297e7d5cf847fb8e2a9cc4cdfef4" translate="yes" xml:space="preserve">
          <source>The formats supported are:</source>
          <target state="translated">支持的格式有:</target>
        </trans-unit>
        <trans-unit id="f7762b6266ff516b0fab73ac7af6d025adc1f538" translate="yes" xml:space="preserve">
          <source>The formats that can convert characters to numbers and vice versa will be different from their ASCII counterparts when executed on an EBCDIC platform. Examples include:</source>
          <target state="translated">当在EBCDIC平台上执行时,可以将字符转换为数字,反之亦然的格式将与ASCII对应的格式不同。例子包括:</target>
        </trans-unit>
        <trans-unit id="5f27c48c4d04704c74b0b5d7d716d5ed43b40c07" translate="yes" xml:space="preserve">
          <source>The former default in which Perl would always use a loose interpretation of UTF-8 has now been overruled:</source>
          <target state="translated">以前的默认情况下,Perl 总是使用对 UTF-8 的宽松解释,现在已经被推翻了。</target>
        </trans-unit>
        <trans-unit id="bacc21ee4934a43e7cffae5409abb3139d8d7444" translate="yes" xml:space="preserve">
          <source>The former is defined to imply Unicode handling; and the latter indicates a Unicode locale, hence a Unicode interpretation of all strings within it.</source>
          <target state="translated">前者被定义为意味着Unicode处理;而后者则表示Unicode区域,因此对其中的所有字符串进行Unicode解释。</target>
        </trans-unit>
        <trans-unit id="abc8578e218b1958e7644bd43d9d008d1386b618" translate="yes" xml:space="preserve">
          <source>The formerly undocumented STRICT argument sets strictness: if true 'use strict;' is used, otherwise it uses 'no strict;'. &lt;b&gt;Note&lt;/b&gt;: if STRICT is omitted 'no strict;' is the default.</source>
          <target state="translated">以前未记录的STRICT参数设置了严格性：如果为真，则&amp;ldquo;使用严格&amp;rdquo;；使用，否则使用&amp;ldquo;不严格&amp;rdquo;。&lt;b&gt;注意&lt;/b&gt;：如果忽略STRICT，则表示&amp;ldquo;不严格&amp;rdquo;；是默认值。</target>
        </trans-unit>
        <trans-unit id="e8c48d78ca541fb734f8a681b44e6478f12be1be" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;(?'NAME'pattern)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt; are equivalent.</source>
          <target state="translated">形式 &lt;code&gt;(?'NAME'pattern)&lt;/code&gt; 和 &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt; 形式是等效的。</target>
        </trans-unit>
        <trans-unit id="3165776bcfd76f28e0c24205090accd64be6f1e3" translate="yes" xml:space="preserve">
          <source>The formula is from the Red Dragon book (reformulated to use the data available) and is documented at &lt;a href=&quot;http://www.strchr.com/hash_functions&quot;&gt;http://www.strchr.com/hash_functions&lt;/a&gt;</source>
          <target state="translated">该公式来自《红龙》（Red Dragon）书（使用现有数据进行了调整），并记录在&lt;a href=&quot;http://www.strchr.com/hash_functions&quot;&gt;http://www.strchr.com/hash_functions中&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea332d524efecd12f52e313e0715e604daa7345f" translate="yes" xml:space="preserve">
          <source>The four &lt;code&gt;CPAN::*&lt;/code&gt; Classes: Author, Bundle, Module, Distribution</source>
          <target state="translated">四个 &lt;code&gt;CPAN::*&lt;/code&gt; 类：作者，捆绑包，模块，分发</target>
        </trans-unit>
        <trans-unit id="4ebe0eef114ce361363114266a5b30d9fc215c2f" translate="yes" xml:space="preserve">
          <source>The four &lt;code&gt;filter_*&lt;/code&gt; methods shown above are available in all the DBM modules that ship with Perl, namely DB_File, GDBM_File, NDBM_File, ODBM_File and SDBM_File.</source>
          <target state="translated">Perl附带的所有DBM模块中都提供了上面显示的四个 &lt;code&gt;filter_*&lt;/code&gt; 方法，即DB_File，GDBM_File，NDBM_File，ODBM_File和SDBM_File。</target>
        </trans-unit>
        <trans-unit id="a87cd62b5e4a547576560e5204e87547d60f9cfe" translate="yes" xml:space="preserve">
          <source>The four CPAN::* Classes: Author, Bundle, Module, Distribution</source>
          <target state="translated">四个CPAN::*类。作者、捆绑包、模块、分发</target>
        </trans-unit>
        <trans-unit id="fe1fb546f60704c6d1d156b3f6fadf776528094a" translate="yes" xml:space="preserve">
          <source>The four element types -- scalar, array, hash, and class -- are represented by strings -- &lt;code&gt;'$'&lt;/code&gt; , &lt;code&gt;'@'&lt;/code&gt; , &lt;code&gt;'%'&lt;/code&gt; , and a class name -- optionally preceded by a &lt;code&gt;'*'&lt;/code&gt; .</source>
          <target state="translated">四个元素类型-标量，数组，哈希和类-用字符串表示- &lt;code&gt;'$'&lt;/code&gt; ， &lt;code&gt;'@'&lt;/code&gt; ， &lt;code&gt;'%'&lt;/code&gt; 和类名称-可选地以 &lt;code&gt;'*'&lt;/code&gt; 开头。</target>
        </trans-unit>
        <trans-unit id="010d48814dc6637936a58a714f4a5b8ac2c0e5b8" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is 0.</source>
          <target state="translated">为此格式返回的列表中的第四个（索引[3]）元素（ &lt;code&gt;$default&lt;/code&gt; ）为0。</target>
        </trans-unit>
        <trans-unit id="2e817fac52edc4c5e0caee985a6afb86c7862868" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; .</source>
          <target state="translated">为此格式返回的列表中的第四个（索引[3]）元素（ &lt;code&gt;$default&lt;/code&gt; ）是 &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d015fffd23c241225267b70dd79dfdb0ced38265" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is the empty string.</source>
          <target state="translated">为此格式返回的列表中的第四个元素（索引[3]）（ &lt;code&gt;$default&lt;/code&gt; ）是空字符串。</target>
        </trans-unit>
        <trans-unit id="3ee5dc54dca610abdb335a6016c33fad310b745e" translate="yes" xml:space="preserve">
          <source>The fourth argument,</source>
          <target state="translated">第四种说法。</target>
        </trans-unit>
        <trans-unit id="d46f45156438266dbc454cfdd5c8500aa9cf2dd2" translate="yes" xml:space="preserve">
          <source>The fourth operation is the same as the logical not of the third operation and is specified the same way as the third with the addition of a caret character &lt;code&gt;^&lt;/code&gt; at the beginning of the test string just inside the open square bracket.</source>
          <target state="translated">第四项操作与第三项操作的逻辑非相同，并以与第三项操作相同的方式指定，只是在方括号内的测试字符串开头添加了插入符号 &lt;code&gt;^&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c67d6a9240f3ec0e157e3e0a648b8e35a0a7ab23" translate="yes" xml:space="preserve">
          <source>The friends locked into &lt;code&gt;M$&lt;/code&gt; world would appreciate the fact that this executable runs under DOS, Win0.3*, Win0.95 and WinNT with an appropriate extender. See &lt;a href=&quot;#Other-OSes&quot;&gt;Other OSes&lt;/a&gt;.</source>
          <target state="translated">锁定在 &lt;code&gt;M$&lt;/code&gt; 世界中的朋友可能会喜欢这个可执行文件在DOS，Win0.3 *，Win0.95和WinNT以及适当的扩展程序下运行的事实。请参阅&lt;a href=&quot;#Other-OSes&quot;&gt;其他操作系统&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="043867751e64107d60b95a69e8badcc29251fb84" translate="yes" xml:space="preserve">
          <source>The full circle is 2</source>
          <target state="translated">全圆是2</target>
        </trans-unit>
        <trans-unit id="e66fe9d715897deb9cd4770d030e58e58ff7af5a" translate="yes" xml:space="preserve">
          <source>The full list of alternatives is:</source>
          <target state="translated">替代品的完整清单是:</target>
        </trans-unit>
        <trans-unit id="80a153a5f23194fa493b49953e70a37ba58abfd1" translate="yes" xml:space="preserve">
          <source>The full text of the license can be found in the LICENSE file included with this module.</source>
          <target state="translated">许可证的全文可以在本模块包含的LICENSE文件中找到。</target>
        </trans-unit>
        <trans-unit id="c54557502ca6f64ebd0cff3c9dbc11ca01487c1f" translate="yes" xml:space="preserve">
          <source>The full version number of this package, such as 5.6.1 (or 5_6_1). This combines revision, patchlevel, and subversion to get the full version number, including any possible subversions. This is suitable for use as a directory name, and hence is filesystem dependent.</source>
          <target state="translated">这个软件包的完整版本号,比如 5.6.1 (或 5_6_1)。这结合了修订版、补丁级别和subversion来获得完整的版本号,包括任何可能的subversion。这适合作为目录名使用,因此是依赖于文件系统的。</target>
        </trans-unit>
        <trans-unit id="5bc944c87864f3d28f9f02ec1b783a4a9aacca33" translate="yes" xml:space="preserve">
          <source>The fully qualified method name that was called is available in the &lt;code&gt;$AUTOLOAD&lt;/code&gt; package global for your class. Since this is a global, if you want to refer to do it without a package name prefix under &lt;code&gt;strict
'vars'&lt;/code&gt; , you need to declare it.</source>
          <target state="translated">在类的全局 &lt;code&gt;$AUTOLOAD&lt;/code&gt; 包中提供了被调用的标准方法名称。由于这是全局的，因此如果要在 &lt;code&gt;strict 'vars'&lt;/code&gt; 下引用而没有包名前缀的方法，则需要声明它。</target>
        </trans-unit>
        <trans-unit id="c7c7ff8a6b152356b1c3b87a4fa36cf4002b4367" translate="yes" xml:space="preserve">
          <source>The function</source>
          <target state="translated">职能</target>
        </trans-unit>
        <trans-unit id="b1263ec90688607ca3bc3ec7bfb0fe38e6efd4c6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::utf8_upgrade() &lt;/a&gt; can be explicitly used to permanently (unless a subsequent &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; is called) cause a string to be treated as Unicode.</source>
          <target state="translated">函数&lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: utf8_upgrade（）&lt;/a&gt;可以显式地永久使用（除非随后的 &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; 被调用）导致将字符串视为Unicode。</target>
        </trans-unit>
        <trans-unit id="0110ffd54f081ff34d7394303d2f5fa900a42f45" translate="yes" xml:space="preserve">
          <source>The function &lt;b&gt;pod_find&lt;/b&gt; searches for POD documents in a given set of files and/or directories. It returns a hash with the file names as keys and the POD name as value. The POD name is derived from the file name and its position in the directory tree.</source>
          <target state="translated">函数&lt;b&gt;pod_find&lt;/b&gt;在给定的文件和/或目录&lt;b&gt;集中&lt;/b&gt;搜索POD文档。它返回一个哈希，文件名作为键，POD名称作为值。POD名称是从文件名及其在目录树中的位置得出的。</target>
        </trans-unit>
        <trans-unit id="48cfcd3ef7cb24df407c69f7ab8cfb221b006395" translate="yes" xml:space="preserve">
          <source>The function &lt;b&gt;simplify_name&lt;/b&gt; is equivalent to &lt;b&gt;basename&lt;/b&gt;, but also strips Perl-like extensions (.pm, .pl, .pod) and extensions like</source>
          <target state="translated">功能&lt;b&gt;simplify_name&lt;/b&gt;相当于&lt;b&gt;基名&lt;/b&gt;，而且剥离的Perl状延伸（.pm后缀，特等，.POD）和扩展等</target>
        </trans-unit>
        <trans-unit id="977e84004739e29fbaa341106fb1e524db41e10d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; has been deprecated, so code has been included to display a warning message whenever the calling module has (at least) the &quot;deprecated&quot; warnings category enabled. Something like this, say.</source>
          <target state="translated">该函数 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 已被弃用，因此只要调用模块启用（至少）启用了&amp;ldquo; deprecated&amp;rdquo;警告类别，便已包含用于显示警告消息的代码。像这样的事情。</target>
        </trans-unit>
        <trans-unit id="509f0d861d7a99d6a484f51f2a9188a5713a5b35" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;filter_read&lt;/code&gt; takes two forms:</source>
          <target state="translated">函数 &lt;code&gt;filter_read&lt;/code&gt; 采取两种形式：</target>
        </trans-unit>
        <trans-unit id="ecd4d38aee306d70f6097ade577ca383b52839ef" translate="yes" xml:space="preserve">
          <source>The function I18N::LangTags::List::name(...) is not exported.</source>
          <target state="translated">I18N::LangTags::List::name(...)函数没有导出。</target>
        </trans-unit>
        <trans-unit id="5583893e9ddd698662f18f40b85c6a69394dd032" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be created. Its behaviour may be tuned by an optional hashref appearing as the last parameter on the call.</source>
          <target state="translated">该函数接受一个要创建的目录列表。它的行为可以通过调用时最后一个参数中出现的可选的hashref来调整。</target>
        </trans-unit>
        <trans-unit id="4c25ffe36bf18f7f44be765fa3c82188ddbc3925" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be removed. Its behaviour may be tuned by an optional hashref appearing as the last parameter on the call.</source>
          <target state="translated">该函数接受一个要删除的目录列表。它的行为可以通过调用时最后一个参数中出现的可选的hashref来调整。</target>
        </trans-unit>
        <trans-unit id="3ef41ec1c0dbf85f3bcd0cef90f173dc6b18dec6" translate="yes" xml:space="preserve">
          <source>The function call &lt;code&gt;shell&lt;/code&gt; takes two optional arguments: one the prompt, the second the default initial command line (the latter only works if a real ReadLine interface module is installed).</source>
          <target state="translated">函数调用 &lt;code&gt;shell&lt;/code&gt; 程序带有两个可选参数：一个是提示，第二个是默认的初始命令行（仅当安装了真正的ReadLine接口模块时，后者才起作用）。</target>
        </trans-unit>
        <trans-unit id="f64674aceb9b0908fa74a739ca7fbade2ac2ee6e" translate="yes" xml:space="preserve">
          <source>The function declaration must be visible at compile time. The prototype affects only interpretation of new-style calls to the function, where new-style is defined as not using the &lt;code&gt;&amp;amp;&lt;/code&gt; character. In other words, if you call it like a built-in function, then it behaves like a built-in function. If you call it like an old-fashioned subroutine, then it behaves like an old-fashioned subroutine. It naturally falls out from this rule that prototypes have no influence on subroutine references like &lt;code&gt;\&amp;amp;foo&lt;/code&gt; or on indirect subroutine calls like &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; or &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt; .</source>
          <target state="translated">函数声明必须在编译时可见。该原型仅影响对该函数的新样式调用的解释，其中新样式定义为不使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 字符。换句话说，如果您像内置函数一样调用它，那么它的行为就像内置函数一样。如果您将其称为老式子例程，则其行为类似于老式子例程。从这个规则自然得出结论，原型对子程序引用（如 &lt;code&gt;\&amp;amp;foo&lt;/code&gt; )或间接子程序调用（如 &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; 或 &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46a4f089237c0dd0b61fdd70575a337b465e2308" translate="yes" xml:space="preserve">
          <source>The function extracts the entry of the specified terminal type</source>
          <target state="translated">该函数提取指定终端类型的条目。</target>
        </trans-unit>
        <trans-unit id="dbacf36c4d8a578101fa6d12242c4841f7204b60" translate="yes" xml:space="preserve">
          <source>The function interface uses attribute strings to describe the colors and text attributes to assign to text. The recognized non-color attributes are clear, reset, bold, dark, faint, italic, underline, underscore, blink, reverse, and concealed. Clear and reset (reset to default attributes), dark and faint (dim and saturated), and underline and underscore are equivalent, so use whichever is the most intuitive to you.</source>
          <target state="translated">功能界面使用属性字符串来描述要分配给文本的颜色和文本属性。识别的非颜色属性有清晰、复位、粗体、暗淡、斜体、下划线、下划线、闪烁、反向和隐藏。清晰和重置(重置为默认属性)、深色和淡色(昏暗和饱和)、下划线和下划线是等价的,所以使用对你来说最直观的那一种。</target>
        </trans-unit>
        <trans-unit id="55694c97e9ceb329d9698a51681bd4944db4ba6e" translate="yes" xml:space="preserve">
          <source>The function is called from the tokeniser, whenever a possible keyword is seen. &lt;code&gt;keyword_ptr&lt;/code&gt; points at the word in the parser's input buffer, and &lt;code&gt;keyword_len&lt;/code&gt; gives its length; it is not null-terminated. The function is expected to examine the word, and possibly other state such as &lt;a href=&quot;perlvar#%25%5eH&quot;&gt;%^H&lt;/a&gt;, to decide whether it wants to handle it as an extended keyword. If it does not, the function should return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; , and the normal parser process will continue.</source>
          <target state="translated">只要看到可能的关键字，就会从令牌处理程序中调用该函数。 &lt;code&gt;keyword_ptr&lt;/code&gt; 指向解析器输入缓冲区中的单词，而 &lt;code&gt;keyword_len&lt;/code&gt; 给出其长度；它不是以Null结尾的。该函数应检查该单词以及可能的其他状态，例如&lt;a href=&quot;perlvar#%25%5eH&quot;&gt;％^ H&lt;/a&gt;，以决定是否要将该单词作为扩展关键字来处理。如果没有，函数应返回 &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; ，正常的解析器过程将继续。</target>
        </trans-unit>
        <trans-unit id="9306c5da74b3095d5bd155bcdf129a71eee56339" translate="yes" xml:space="preserve">
          <source>The function looks in the symbol table of &lt;code&gt;$package&lt;/code&gt; for the typeglob for &lt;code&gt;$referent&lt;/code&gt; , which is a reference to a variable or subroutine (SCALAR, ARRAY, HASH, or CODE). If it finds the typeglob, it returns it. Otherwise, it returns undef. Note that &lt;code&gt;findsym&lt;/code&gt; memoizes the typeglobs it has previously successfully found, so subsequent calls with the same arguments should be much faster.</source>
          <target state="translated">该函数在 &lt;code&gt;$package&lt;/code&gt; 的符号表中查找 &lt;code&gt;$referent&lt;/code&gt; 的typeglob ，这是对变量或子例程（SCALAR，ARRAY，HASH或CODE）的引用。如果找到typeglob，则将其返回。否则，它返回undef。请注意， &lt;code&gt;findsym&lt;/code&gt; 会记住它先前已成功找到的typeglob，因此，使用相同参数的后续调用应快得多。</target>
        </trans-unit>
        <trans-unit id="228b62ac93f3c97adf4846ab7a229490257f21f2" translate="yes" xml:space="preserve">
          <source>The function name and the return type must be placed on separate lines and should be flush left-adjusted.</source>
          <target state="translated">函数名和返回类型必须放在不同的行中,并应左调齐。</target>
        </trans-unit>
        <trans-unit id="497e4c985232c356046790edf3b0a4494724ab06" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;-Name =&amp;gt; value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">该函数可以选择使用多个指定为 &lt;code&gt;-Name =&amp;gt; value&lt;/code&gt; 对的命名选项。这允许定制各个选项，而不必在参数列表中全部指定它们。</target>
        </trans-unit>
        <trans-unit id="c334e8eba917e7f07e2743dd2e109fa8bab331b7" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;-Name=&amp;gt;value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">该函数可以选择采用多个指定为 &lt;code&gt;-Name=&amp;gt;value&lt;/code&gt; 对的命名选项。这允许定制各个选项，而不必在参数列表中全部指定它们。</target>
        </trans-unit>
        <trans-unit id="24c3d21a118e57cb0a792d18dd4aca22a45547ff" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;Name =&amp;gt; value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">该函数可以选择采用多个指定为 &lt;code&gt;Name =&amp;gt; value&lt;/code&gt; 对的命名选项。这允许定制各个选项，而不必在参数列表中全部指定它们。</target>
        </trans-unit>
        <trans-unit id="efd7c1c2cc7bcbc10e2084326d92993267a12ffd" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;TRUE&lt;/code&gt; if the input string is empty, or if the corresponding C function returns &lt;code&gt;TRUE&lt;/code&gt; for every byte in the string.</source>
          <target state="translated">该函数返回 &lt;code&gt;TRUE&lt;/code&gt; ，如果输入的字符串是空的，或者如果对应的C函数返回 &lt;code&gt;TRUE&lt;/code&gt; 的字符串中的每一个字节。</target>
        </trans-unit>
        <trans-unit id="18bb210a9d041841ab7e7d3f647d6ee1d366da33" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, with the reason for the error placed in &lt;code&gt;$!&lt;/code&gt; . Just what is in the packed string depends on LEVEL and OPTNAME; consult getsockopt(2) for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt; ) format.</source>
          <target state="translated">该函数返回一个表示请求的套接字选项的打包字符串，或者对错误的 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，错误原因放在 &lt;code&gt;$!&lt;/code&gt; 中!。打包字符串中的内容取决于LEVEL和OPTNAME；有关详细信息，请咨询getsockopt（2）。一个常见的情况是该选项是一个整数，在这种情况下，结果是一个打包的整数，您可以使用具有 &lt;code&gt;i&lt;/code&gt; （或 &lt;code&gt;I&lt;/code&gt; ）格式的 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 对其进行解码。</target>
        </trans-unit>
        <trans-unit id="f3bdd5d171fe014406932479dff47095d4169b23" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, with the reason for the error placed in &lt;code&gt;$!&lt;/code&gt; . Just what is in the packed string depends on LEVEL and OPTNAME; consult getsockopt(2) for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt; ) format.</source>
          <target state="translated">该函数返回一个表示请求的套接字选项的打包字符串，或者对错误的 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，错误原因放在 &lt;code&gt;$!&lt;/code&gt; 中!。打包字符串中的内容取决于LEVEL和OPTNAME；有关详细信息，请咨询getsockopt（2）。一个常见的情况是该选项是一个整数，在这种情况下，结果是一个打包的整数，您可以使用具有 &lt;code&gt;i&lt;/code&gt; （或 &lt;code&gt;I&lt;/code&gt; ）格式的 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 对其进行解码。</target>
        </trans-unit>
        <trans-unit id="2c416a15314ff142b876195908cf3e0998cacb0b" translate="yes" xml:space="preserve">
          <source>The function returns a true value if the file was written successfully. Otherwise it returns a false value.</source>
          <target state="translated">如果文件写入成功,该函数返回一个真值,否则返回一个假值。否则返回一个false值。</target>
        </trans-unit>
        <trans-unit id="96868ec2f844938f055b367738ce668b3149cb6e" translate="yes" xml:space="preserve">
          <source>The function returns the list of directories actually created during the call; in scalar context the number of directories created.</source>
          <target state="translated">该函数返回调用过程中实际创建的目录列表;在标量上下文中,返回创建的目录数量。</target>
        </trans-unit>
        <trans-unit id="6b560ee48a1c4113ae4a064c91e40e3ebfc92205" translate="yes" xml:space="preserve">
          <source>The function should be defined like this:</source>
          <target state="translated">该函数应该这样定义。</target>
        </trans-unit>
        <trans-unit id="af1dfdcedd7b6d95c274f658ea41922443e248ed" translate="yes" xml:space="preserve">
          <source>The function should return a reference to an array containing the parent classes in order. The names of the classes should be the result of calling &lt;code&gt;HvENAME()&lt;/code&gt; on the stash. In those cases where &lt;code&gt;HvENAME()&lt;/code&gt; returns null, &lt;code&gt;HvNAME()&lt;/code&gt; should be used instead.</source>
          <target state="translated">该函数应按顺序返回对包含父类的数组的引用。类的名称应该是在存储区上调用 &lt;code&gt;HvENAME()&lt;/code&gt; 的结果。在 &lt;code&gt;HvENAME()&lt;/code&gt; 返回null的情况下，应 &lt;code&gt;HvNAME()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df40ff756f018edab3521eb313090bdefa039e32" translate="yes" xml:space="preserve">
          <source>The function takes as first argument a key to test against, and as second argument any form of criteria that are also allowed by the &lt;code&gt;allow&lt;/code&gt; key in the template.</source>
          <target state="translated">该函数将要测试的键用作第一个参数，而模板中的 &lt;code&gt;allow&lt;/code&gt; 键也允许使用任何形式的条件作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="f1378c8817cc1e710b51660b130f3baf8dd96ee6" translate="yes" xml:space="preserve">
          <source>The function takes one optional parameter, a reference to a hash. The contents of the hash allow the deflation interface to be tailored.</source>
          <target state="translated">该函数需要一个可选的参数,即一个哈希的引用。哈希值的内容允许对放气接口进行调整。</target>
        </trans-unit>
        <trans-unit id="deea19e69043d11a7254610da5a869b1f9452180" translate="yes" xml:space="preserve">
          <source>The function that handles the &lt;code&gt;allow&lt;/code&gt; key in the template is also available for independent use.</source>
          <target state="translated">处理模板中的 &lt;code&gt;allow&lt;/code&gt; 键的功能也可以独立使用。</target>
        </trans-unit>
        <trans-unit id="efcf392cc09771ca25c0652559e59fca2e7a7c50" translate="yes" xml:space="preserve">
          <source>The function visit() scans the SV arenas list, and calls a specified function for each SV it finds which is still live - ie which has an SvTYPE other than all 1's, and a non-zero SvREFCNT. visit() is used by the following functions (specified as [function that calls visit()] / [function called by visit() for each SV]):</source>
          <target state="translated">函数visit()扫描SV竞技场列表,并为它找到的每个SV调用一个指定的函数,这些SV仍然是实时的--即它的SvTYPE不是全部的1,并且SvREFCNT不为零。visit()被以下函数使用(指定为[调用visit()的函数]/[每个SV被visit()调用的函数])。</target>
        </trans-unit>
        <trans-unit id="19570f411b75d35372886127cc2a69449d9a4b6b" translate="yes" xml:space="preserve">
          <source>The function will croak with &quot;Wide character in subroutine entry&quot; if $bytes contains characters with code above 255. The base64 encoding is only defined for single-byte characters. Use the Encode module to select the byte encoding you want.</source>
          <target state="translated">如果$bytes包含编码大于255的字符,该函数将以 &quot;Wide character in subroutine entry&quot;(子程序输入中的宽字符)的形式出现。base64 编码只针对单字节字符。使用Encode模块来选择你想要的字节编码。</target>
        </trans-unit>
        <trans-unit id="b2a6bb6e55b46f9d735e2cbaab0b636efd193e6e" translate="yes" xml:space="preserve">
          <source>The function,</source>
          <target state="translated">该职能:</target>
        </trans-unit>
        <trans-unit id="56c2336779d3eb8fad6f134e1b3afd4055cf95fc" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_add&lt;/code&gt; , actually installs the filter. It takes one parameter which should be a reference. The kind of reference used will dictate which of the two filter types will be used.</source>
          <target state="translated">函数 &lt;code&gt;filter_add&lt;/code&gt; 实际上安装了过滤器。它采用一个应该作为参考的参数。使用的参考类型将决定要使用两种过滤器类型中的哪一种。</target>
        </trans-unit>
        <trans-unit id="bd8317ff780b8620fb08e8151dfdbf3a52d2d611" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_del&lt;/code&gt; , is used to disable the current filter. It does not affect the running of the filter. All it does is tell Perl not to call filter any more.</source>
          <target state="translated">函数 &lt;code&gt;filter_del&lt;/code&gt; 用于禁用当前过滤器。它不会影响过滤器的运行。它所做的只是告诉Perl不要再调用filter了。</target>
        </trans-unit>
        <trans-unit id="e85467ff647b7ea9bd91bc8fa0103d9ae4aadb9f" translate="yes" xml:space="preserve">
          <source>The functional interface is simply importable functions with the same name as the algorithm. The functions take the message as argument and return the digest. Example:</source>
          <target state="translated">功能接口是简单的可导入的与算法同名的函数。这些函数将消息作为参数并返回摘要。例如</target>
        </trans-unit>
        <trans-unit id="bf5b597fcbc2815c78fabe6a0ba67f38e49a2b3d" translate="yes" xml:space="preserve">
          <source>The functional interface needs Perl5.005 or better.</source>
          <target state="translated">功能界面需要Perl5.005或更高。</target>
        </trans-unit>
        <trans-unit id="4bdd9d3e5903e6dd1f8e73f664d773008086b093" translate="yes" xml:space="preserve">
          <source>The functions</source>
          <target state="translated">职能</target>
        </trans-unit>
        <trans-unit id="68ff03911b440c28f50688f4c9ab7665ef4a1c34" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;cond_wait()&lt;/code&gt; and &lt;code&gt;cond_signal()&lt;/code&gt; can be used in conjunction with locks to notify co-operating threads that a resource has become available. They are very similar in use to the functions found in &lt;code&gt;pthreads&lt;/code&gt; . However for most purposes, queues are simpler to use and more intuitive. See &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; for more details.</source>
          <target state="translated">函数 &lt;code&gt;cond_wait()&lt;/code&gt; 和 &lt;code&gt;cond_signal()&lt;/code&gt; 可以与锁结合使用，以通知合作线程资源已变得可用。它们的用法与 &lt;code&gt;pthreads&lt;/code&gt; 中的函数非常相似。但是，对于大多数目的而言，队列使用起来更简单，更直观。有关更多详细信息，请参见&lt;a href=&quot;threads/shared&quot;&gt;thread :: shared&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29b4904f96b85af2bf6cf4659323a42dfc8558db" translate="yes" xml:space="preserve">
          <source>The functions and attributes are accessed via the &quot;tab&quot; (for table) member of &lt;code&gt;PerlIOl&lt;/code&gt; . The functions (methods of the layer &quot;class&quot;) are fixed, and are defined by the &lt;code&gt;PerlIO_funcs&lt;/code&gt; type. They are broadly the same as the public &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; functions:</source>
          <target state="translated">通过 &lt;code&gt;PerlIOl&lt;/code&gt; 的&amp;ldquo; tab&amp;rdquo;（用于表）成员可以访问功能和属性。功能（层&amp;ldquo;类&amp;rdquo;的方法）是固定的，并由 &lt;code&gt;PerlIO_funcs&lt;/code&gt; 类型定义。它们与公共 &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; 函数大致相同：</target>
        </trans-unit>
        <trans-unit id="641685ab6429ec4eade93850f03823bb632c2710" translate="yes" xml:space="preserve">
          <source>The functions and attributes of the &quot;layer class&quot;.</source>
          <target state="translated">层类 &quot;的功能和属性。</target>
        </trans-unit>
        <trans-unit id="04a02ab73237464478de303a6921e51a12145bbd" translate="yes" xml:space="preserve">
          <source>The functions are modeled on those in</source>
          <target state="translated">这些功能都是以</target>
        </trans-unit>
        <trans-unit id="de8f908f8a6f8cbbe7a5d22657a37b7e7e24b80c" translate="yes" xml:space="preserve">
          <source>The functions in this section can serve as terms in an expression. They fall into two major categories: list operators and named unary operators. These differ in their precedence relationship with a following comma. (See the precedence table in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.) List operators take more than one argument, while unary operators can never take more than one argument. Thus, a comma terminates the argument of a unary operator, but merely separates the arguments of a list operator. A unary operator generally provides scalar context to its argument, while a list operator may provide either scalar or list contexts for its arguments. If it does both, scalar arguments come first and list argument follow, and there can only ever be one such list argument. For instance, splice() has three scalar arguments followed by a list, whereas gethostbyname() has four scalar arguments.</source>
          <target state="translated">本节中的函数可以用作表达式中的术语。它们分为两大类：列表运算符和命名一元运算符。它们的优先级关系与后跟逗号不同。（请参阅&lt;a href=&quot;perlop&quot;&gt;perlop中&lt;/a&gt;的优先级表。）列表运算符采用一个以上的参数，而一元运算符绝不能采用一个以上的参数。因此，逗号终止一元运算符的参数，但仅分隔列表运算符的参数。一元运算符通常为其参数提供标量上下文，而列表运算符可以为其参数提供标量或列表上下文。如果两者都执行，则标量参数排在最前面，列表参数排在后面，并且永远只能有一个这样的列表参数。例如，splice（）具有三个标量参数，后跟一个列表，而gethostbyname（）具有四个标量参数。</target>
        </trans-unit>
        <trans-unit id="db44e2533a11b8e3bb17098404db4eb4f6f38bb9" translate="yes" xml:space="preserve">
          <source>The functions not currently implemented include:</source>
          <target state="translated">目前未执行的职能包括:</target>
        </trans-unit>
        <trans-unit id="c91d15f478afdf6edcd21180f278e6de93659c87" translate="yes" xml:space="preserve">
          <source>The functions returns the number of files successfully deleted.</source>
          <target state="translated">该函数返回成功删除的文件数量。</target>
        </trans-unit>
        <trans-unit id="c8f00447c143aee7d5d5fe37917ea4e13f05bb95" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wdeclaration-after-statements&lt;/code&gt; scans for such problems (by default on starting from Perl 5.9.4).</source>
          <target state="translated">gcc选项 &lt;code&gt;-Wdeclaration-after-statements&lt;/code&gt; 扫描此类问题（默认情况下从Perl 5.9.4开始）。</target>
        </trans-unit>
        <trans-unit id="5ee3a23159a200898de862e7d5879870227625eb" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wendif-labels&lt;/code&gt; warns about the bad variant (by default on starting from Perl 5.9.4).</source>
          <target state="translated">gcc选项 &lt;code&gt;-Wendif-labels&lt;/code&gt; 警告有关错误的变体（默认情况下从Perl 5.9.4开始）。</target>
        </trans-unit>
        <trans-unit id="4d2d0d644a6adc7963542dd47a318273c10c274d" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wformat&lt;/code&gt; scans for such problems.</source>
          <target state="translated">gcc选项 &lt;code&gt;-Wformat&lt;/code&gt; 扫描此类问题。</target>
        </trans-unit>
        <trans-unit id="db3325d45be5f27fbb2d4ff677421100e7fd8bb0" translate="yes" xml:space="preserve">
          <source>The generated C++ code will call &lt;code&gt;new&lt;/code&gt; .</source>
          <target state="translated">生成的C ++代码将调用 &lt;code&gt;new&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d40f7df8e8a0ceca1fdf5c8cc98299f799cdbb11" translate="yes" xml:space="preserve">
          <source>The generated Makefile enables the user of the extension to invoke</source>
          <target state="translated">生成的Makefile可以让扩展的用户调用</target>
        </trans-unit>
        <trans-unit id="ddf93e71778e5593e96208d788b15d2297c9188f" translate="yes" xml:space="preserve">
          <source>The generated singletons are kept around from instantiation until the end of the shell session. &amp;lt;plugin_list&amp;gt; can be reconfigured at any time at run time. While the cpan shell is running, it checks all activated plugins at each of the 8 reference points listed above and runs the respective method if it is implemented for that object. The method is called with the active CPAN::Distribution object passed in as an argument.</source>
          <target state="translated">生成的单例一直保持实例化状态，直到Shell会话结束。&amp;lt;plugin_list&amp;gt;可以在运行时随时重新配置。当cpan shell运行时，它将在上面列出的8个参考点中的每一个处检查所有已激活的插件，并运行针对该对象实现的相应方法。使用作为参数传入的活动CPAN :: Distribution对象调用该方法。</target>
        </trans-unit>
        <trans-unit id="04c9e6d408a35a88cbae891becfacfd45984120c" translate="yes" xml:space="preserve">
          <source>The generated trailer for a CODE: section ensures that the number of return values Perl will see is either 0 or 1 (depending on the &lt;code&gt;void&lt;/code&gt; ness of the return value of the C function, and heuristics mentioned in &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt;). The trailer generated for a PPCODE: section is based on the number of return values and on the number of times &lt;code&gt;SP&lt;/code&gt; was updated by &lt;code&gt;[X]PUSH*()&lt;/code&gt; macros.</source>
          <target state="translated">为CODE：部分生成的预告片确保Perl将看到的返回值数量为0或1（取决于C函数的返回值的 &lt;code&gt;void&lt;/code&gt; 性以及&lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;RETVAL变量中&lt;/a&gt;提到的启发式方法）。为PPCODE：部分生成的预告片基于返回值的数目以及 &lt;code&gt;[X]PUSH*()&lt;/code&gt; 宏更新 &lt;code&gt;SP&lt;/code&gt; 的次数。</target>
        </trans-unit>
        <trans-unit id="147459e5132af1acc303407a971ff312e870e58e" translate="yes" xml:space="preserve">
          <source>The generation number of the name at offset &lt;code&gt;po&lt;/code&gt; in the current compiling pad (lvalue). Note that &lt;code&gt;SvUVX&lt;/code&gt; is hijacked for this purpose.</source>
          <target state="translated">当前编译区中偏移 &lt;code&gt;po&lt;/code&gt; 处的名称的生成编号（左值）。请注意，为此目的劫持了 &lt;code&gt;SvUVX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65beebb121c6a44259be26715db186e4a704f7cf" translate="yes" xml:space="preserve">
          <source>The generic flag bits are a hybrid of &lt;code&gt;O_XXXXX&lt;/code&gt; style flags deduced from the mode string passed to &lt;code&gt;PerlIO_open()&lt;/code&gt; , and state bits for typical buffer layers.</source>
          <target state="translated">通用标志位是从传递给 &lt;code&gt;PerlIO_open()&lt;/code&gt; 的模式字符串推导出的 &lt;code&gt;O_XXXXX&lt;/code&gt; 样式标志和典型缓冲区层的状态位的混合体。</target>
        </trans-unit>
        <trans-unit id="9373f74aec3f2b814c36a72b32de7c1df8cce7e8" translate="yes" xml:space="preserve">
          <source>The generic names by which a &lt;b&gt;subroutine&lt;/b&gt; knows its &lt;b&gt;arguments&lt;/b&gt;. In many languages, formal arguments are always given individual names; in Perl, the formal arguments are just the elements of an array. The formal arguments to a Perl program are &lt;code&gt;$ARGV[0]&lt;/code&gt; , &lt;code&gt;$ARGV[1]&lt;/code&gt; , and so on. Similarly, the formal arguments to a Perl subroutine are &lt;code&gt;$_[0]&lt;/code&gt; , &lt;code&gt;$_[1]&lt;/code&gt; , and so on. You may give the arguments individual names by assigning the values to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; list. See also &lt;b&gt;actual arguments&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;子例程&lt;/b&gt;知道其自&lt;b&gt;变量&lt;/b&gt;的通用名称。在许多语言中，形式参数总是被赋予单独的名称。在Perl中，形式参数只是数组的元素。 Perl程序的正式参数是 &lt;code&gt;$ARGV[0]&lt;/code&gt; ， &lt;code&gt;$ARGV[1]&lt;/code&gt; 等。类似地，Perl子例程的形式参数为 &lt;code&gt;$_[0]&lt;/code&gt; ， &lt;code&gt;$_[1]&lt;/code&gt; 等。您可以通过将值分配给 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 列表来为参数指定单独的名称。另请参阅&lt;b&gt;实际参数&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="e34968429c314c796b06ef13d6256c2eed375227" translate="yes" xml:space="preserve">
          <source>The get_dup() Method</source>
          <target state="translated">get_dup()方法</target>
        </trans-unit>
        <trans-unit id="777933c68edb9f2b520827371d959a89885f825a" translate="yes" xml:space="preserve">
          <source>The getaddrinfo() function converts a hostname and a service name into a list of structures, each containing a potential way to connect() to the named service on the named host.</source>
          <target state="translated">getaddrinfo()函数将主机名和服务名转换为一个结构列表,每个结构都包含了连接()到命名主机上命名服务的潜在方式。</target>
        </trans-unit>
        <trans-unit id="b2567e2f657f48e5ffd91f457d438d649766ac8c" translate="yes" xml:space="preserve">
          <source>The getdcwd() function is also provided on Win32 to get the current working directory on the specified drive, since Windows maintains a separate current working directory for each drive. If no drive is specified then the current drive is assumed.</source>
          <target state="translated">在Win32上也提供了getdcwd()函数来获取指定驱动器上的当前工作目录,因为Windows为每个驱动器维护了一个单独的当前工作目录。如果没有指定驱动器,则假设当前驱动器。</target>
        </trans-unit>
        <trans-unit id="60ed783ab1755c8923c2106affd806182a9b2682" translate="yes" xml:space="preserve">
          <source>The gethost() function is a simple front-end that forwards a numeric argument to gethostbyaddr() by way of Socket::inet_aton, and the rest to gethostbyname().</source>
          <target state="translated">gethost()函数是一个简单的前端,它通过Socket::inet_aton将一个数字参数转发给gethostbyaddr(),其余的转发给gethostbyname()。</target>
        </trans-unit>
        <trans-unit id="91be5f2becab7f44b4c2d8e8646f84ed2e15605f" translate="yes" xml:space="preserve">
          <source>The gethost() functions do this in the Perl core:</source>
          <target state="translated">在Perl核心中,gethost()函数可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="3d809f6317a210fb06b8763a59c516ccb0250c8f" translate="yes" xml:space="preserve">
          <source>The getnameinfo() function converts a socket address, such as returned by getsockname() or getpeername(), into a pair of human-readable strings representing the address and service name.</source>
          <target state="translated">getnameinfo()函数将一个套接字地址(如由 getsockname()或 getpeername()返回的地址)转换为一对人可读的字符串,代表地址和服务名称。</target>
        </trans-unit>
        <trans-unit id="c7341d184608dfa3d666b4de167cfb9267a092b7" translate="yes" xml:space="preserve">
          <source>The getnet() function is a simple front-end that forwards a numeric argument to getnetbyaddr(), and the rest to getnetbyname().</source>
          <target state="translated">getnet()函数是一个简单的前端,它将一个数字参数转发给getnetbyaddr(),其余的转发给getnetbyname()。</target>
        </trans-unit>
        <trans-unit id="a2bc6ce1fe12be1b0104870e6335dfcba678d52a" translate="yes" xml:space="preserve">
          <source>The getnet() functions do this in the Perl core:</source>
          <target state="translated">在Perl核心中,getnet()函数可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="723d74402111c283b1693c27eac4e9e45b8e6ed9" translate="yes" xml:space="preserve">
          <source>The getproto() function is a simple front-end that forwards a numeric argument to getprotobyport(), and the rest to getprotobyname().</source>
          <target state="translated">getproto()函数是一个简单的前端,它将一个数字参数转发给getprotobyport(),其余的转发给getprotobyname()。</target>
        </trans-unit>
        <trans-unit id="7135ce934ee6874d87ad890231c34f496a98c1a0" translate="yes" xml:space="preserve">
          <source>The getpw() function is a simple front-end that forwards a numeric argument to getpwuid() and the rest to getpwnam().</source>
          <target state="translated">getpw()函数是一个简单的前端,它将一个数字参数转发给getpwuid(),其余的转发给getpwnam()。</target>
        </trans-unit>
        <trans-unit id="0d0b8e4657c6706a0314a90d140b3591ebd5a9bb" translate="yes" xml:space="preserve">
          <source>The getserv() function is a simple front-end that forwards a numeric argument to getservbyport(), and the rest to getservbyname().</source>
          <target state="translated">geterv()函数是一个简单的前端,它将一个数字参数转发给getervbyport(),其余的转发给getervbyname()。</target>
        </trans-unit>
        <trans-unit id="7b3093ca7aacbd788d18481992e739fec224cedd" translate="yes" xml:space="preserve">
          <source>The given arguments are made consistent as though by calling &lt;code&gt;mktime()&lt;/code&gt; before calling your system's &lt;code&gt;strftime()&lt;/code&gt; function, except that the &lt;code&gt;isdst&lt;/code&gt; value is not affected.</source>
          <target state="translated">就像在调用系统的 &lt;code&gt;strftime()&lt;/code&gt; 函数之前调用 &lt;code&gt;mktime()&lt;/code&gt; 一样，使给定的参数一致，不同之处在于 &lt;code&gt;isdst&lt;/code&gt; 值不受影响。</target>
        </trans-unit>
        <trans-unit id="a46f0a3dc0d7705f81eb9d2736f8d38ab0c36cf3" translate="yes" xml:space="preserve">
          <source>The given link to</source>
          <target state="translated">给定的链接</target>
        </trans-unit>
        <trans-unit id="1b7e0113518a74a9ca8cd3adb44721180fc0bb94" translate="yes" xml:space="preserve">
          <source>The glob angle-bracket operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is a pathname generator that implements the rules for file name pattern matching used by Unix-like shells such as the Bourne shell or C shell.</source>
          <target state="translated">glob angle-bracket运算符 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 是路径名生成器，用于实现类Unix外壳（例如Bourne外壳或C外壳）使用的文件名模式匹配规则。</target>
        </trans-unit>
        <trans-unit id="5e215c589947f616aa94dd5242e9494420cfca28" translate="yes" xml:space="preserve">
          <source>The glob containing the output field separator - &lt;code&gt;*,&lt;/code&gt; in Perl space.</source>
          <target state="translated">在Perl空间中包含输出字段分隔符- &lt;code&gt;*,&lt;/code&gt; 的glob 。</target>
        </trans-unit>
        <trans-unit id="72ac12b62c28c3baeece5702a243d181ecdda5a0" translate="yes" xml:space="preserve">
          <source>The glob was stopped because an error was encountered.</source>
          <target state="translated">由于遇到了错误,地球仪被停止。</target>
        </trans-unit>
        <trans-unit id="f628027fc4ac19b3e64d6b57171d06712a0f4de2" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;debug&lt;/code&gt; and &lt;code&gt;debugcolor&lt;/code&gt; pragmas allow one to get detailed debugging info about regexp compilation and execution. &lt;code&gt;debugcolor&lt;/code&gt; is the same as debug, except the debugging information is displayed in color on terminals that can display termcap color sequences. Here is example output:</source>
          <target state="translated">全局 &lt;code&gt;debug&lt;/code&gt; 和 &lt;code&gt;debugcolor&lt;/code&gt; 编译指示允许您获取有关regexp编译和执行的详细调试信息。 &lt;code&gt;debugcolor&lt;/code&gt; 与debug相同，除了debug信息以彩色显示在可以显示termcap颜色序列的终端上。这是示例输出：</target>
        </trans-unit>
        <trans-unit id="2364252b351b212be51c3b8e4ec104f73d0c11a2" translate="yes" xml:space="preserve">
          <source>The global variable $Devel::Peek::pv_limit can be set to limit the number of character printed in various string values. Setting it to 0 means no limit.</source>
          <target state="translated">全局变量$Devel::Peek::pv_limit可以被设置为限制各种字符串值的打印字符数。设置为0表示没有限制。</target>
        </trans-unit>
        <trans-unit id="8c46d35ee4a0a86a8c41ca71ad737aa7e8fc9118" translate="yes" xml:space="preserve">
          <source>The global variables, like &lt;code&gt;@ARGV&lt;/code&gt; or the punctuation variables, must be &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt;. This block reads in</source>
          <target state="translated">全局变量，如 &lt;code&gt;@ARGV&lt;/code&gt; 或标点符号变量，必须在 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 有美化版 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 。该块读入</target>
        </trans-unit>
        <trans-unit id="968cbdca6785865baa2b963e00c7cf59fd1ce4f6" translate="yes" xml:space="preserve">
          <source>The glue code pulls the arguments from the Perl stack, converts these Perl values to the formats expected by a C function, call this C function, transfers the return values of the C function back to Perl. Return values here may be a conventional C return value or any C function arguments that may serve as output parameters. These return values may be passed back to Perl either by putting them on the Perl stack, or by modifying the arguments supplied from the Perl side.</source>
          <target state="translated">胶水代码从Perl堆栈中提取参数,将这些Perl值转换为C函数所期望的格式,调用这个C函数,将C函数的返回值转回Perl。这里的返回值可以是传统的C函数返回值,也可以是任何可以作为输出参数的C函数参数。这些返回值可以通过把它们放在Perl堆栈中,或者通过修改Perl方面提供的参数来传回Perl。</target>
        </trans-unit>
        <trans-unit id="cfb79bdb1e9bdcf50c5258db72c30cb6aeb1e3e1" translate="yes" xml:space="preserve">
          <source>The gmctime() function provides a way of getting at the scalar sense of the original CORE::gmtime() function.</source>
          <target state="translated">gmctime()函数提供了一种获取原始CORE::gmtime()函数的标量意义的方法。</target>
        </trans-unit>
        <trans-unit id="15e78ea46607c2d827f12212191bcd40dffea850" translate="yes" xml:space="preserve">
          <source>The goal here is to have a testing utility that's simple to learn, quick to use and difficult to trip yourself up with while still providing more flexibility than the existing Test.pm. As such, the names of the most common routines are kept tiny, special cases and magic side-effects are kept to a minimum. WYSIWYG.</source>
          <target state="translated">我们的目标是拥有一个简单易学、快速使用、难以让自己陷入困境的测试工具,同时还能提供比现有Test.pm更多的灵活性。因此,最常见的例程的名称都被保留得很小,特殊情况和神奇的副作用都被保留到最小。WYSIWYG.</target>
        </trans-unit>
        <trans-unit id="a352895328c4895bdf1e088252c7cfc98a73fd07" translate="yes" xml:space="preserve">
          <source>The goal of the CPAN Testers project (&lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt;) is to test as many CPAN packages as possible on as many platforms as possible. This provides valuable feedback to module authors and potential users to identify bugs or platform compatibility issues and improves the overall quality and value of CPAN.</source>
          <target state="translated">CPAN Testers项目（&lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt;）的目标是在尽可能多的平台上测试尽可能多的CPAN软件包。这为模块作者和潜在用户提供了宝贵的反馈，以识别错误或平台兼容性问题，并提高了CPAN的整体质量和价值。</target>
        </trans-unit>
        <trans-unit id="7c4f9c804c591c85f4c73346c685fe6b75566956" translate="yes" xml:space="preserve">
          <source>The good news is that at least some DBM module should be available, and &lt;code&gt;AnyDBM_File&lt;/code&gt; will use whichever module it can find. Of course, then the code needs to be fairly strict, dropping to the greatest common factor (e.g., not exceeding 1K for each record), so that it will work with any DBM module. See &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; for more details.</source>
          <target state="translated">好消息是至少应该有一些DBM模块可用，并且 &lt;code&gt;AnyDBM_File&lt;/code&gt; 将使用它可以找到的任何模块。当然，那么代码需要相当严格，降至最大的公因数（例如，每个记录不超过1K），以便它可以与任何DBM模块一起使用。有关更多详细信息，请参见&lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b5a1d8ce58ba1e38f16f3a0f1eb5ac058c6d368" translate="yes" xml:space="preserve">
          <source>The good old C code quality inspector, &lt;code&gt;lint&lt;/code&gt; , is available in several platforms, but please be aware that there are several different implementations of it by different vendors, which means that the flags are not identical across different platforms.</source>
          <target state="translated">良好的旧C代码质量检查器 &lt;code&gt;lint&lt;/code&gt; 可以在多个平台上使用，但是请注意，不同供应商有多种不同的实现方式，这意味着标记在不同平台上并不相同。</target>
        </trans-unit>
        <trans-unit id="64a4aa574c2f36a349fb65698d1079a80c8716e6" translate="yes" xml:space="preserve">
          <source>The grammar gives you the following rule: you can make the thing on the left of the colon if you see all the things on the right in sequence. This is called a &quot;reduction&quot;, and the aim of parsing is to completely reduce the input. There are several different ways you can perform a reduction, separated by vertical bars: so, &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;=&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; makes a &lt;code&gt;term&lt;/code&gt; , and &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;+&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; can also make a &lt;code&gt;term&lt;/code&gt; .</source>
          <target state="translated">语法为您提供以下规则：如果按顺序看到右侧的所有内容，则可以将其制作在冒号的左侧。这称为&amp;ldquo;减少&amp;rdquo;，而解析的目的是完全减少输入。有几种不同的方法可以进行还原，用竖线分隔：那么， &lt;code&gt;term&lt;/code&gt; 其次 &lt;code&gt;=&lt;/code&gt; 后跟 &lt;code&gt;term&lt;/code&gt; 使得 &lt;code&gt;term&lt;/code&gt; 和 &lt;code&gt;term&lt;/code&gt; 随后 &lt;code&gt;+&lt;/code&gt; 其次是 &lt;code&gt;term&lt;/code&gt; 也可以让一个 &lt;code&gt;term&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f689a3c521cea873db9ec7a159a154a44941fb63" translate="yes" xml:space="preserve">
          <source>The grammar, lines one and three of the snippet above, tells you how to build up more complex forms. These complex forms, &quot;non-terminal symbols&quot; are generally placed in lower case. &lt;code&gt;term&lt;/code&gt; here is a non-terminal symbol, representing a single expression.</source>
          <target state="translated">上面这段代码的第一行和第三行的语法告诉您如何构建更复杂的形式。这些复杂的形式，&amp;ldquo;非终结符&amp;rdquo;通常放在小写形式。这里的 &lt;code&gt;term&lt;/code&gt; 是一个非终结符，代表一个表达式。</target>
        </trans-unit>
        <trans-unit id="d748b942ca422b33db3c9c207b20fcf5e35fbf06" translate="yes" xml:space="preserve">
          <source>The great_circle_midpoint() is just a special case of</source>
          <target state="translated">great_circle_midpoint()只是一个特殊的例子。</target>
        </trans-unit>
        <trans-unit id="65a277526deeb0c81c0a5dcd559529318f7f89a5" translate="yes" xml:space="preserve">
          <source>The group as a whole is interpreted as follows:</source>
          <target state="translated">该组整体解释如下:</target>
        </trans-unit>
        <trans-unit id="fc9b7c0745af45eb8fd74cee86dd53c561106e37" translate="yes" xml:space="preserve">
          <source>The group id owning the file</source>
          <target state="translated">拥有该文件的组ID</target>
        </trans-unit>
        <trans-unit id="163b6e7222a22b065c1007b2d5c671945f219faa" translate="yes" xml:space="preserve">
          <source>The group name that owns the file</source>
          <target state="translated">拥有该文件的组名</target>
        </trans-unit>
        <trans-unit id="5464b947891c7dfe478004d22eea99e392c2554b" translate="yes" xml:space="preserve">
          <source>The grouping assigns a value to \g1, so that the same 3-letter sequence is used for both parts.</source>
          <target state="translated">分组给/g1赋值,使两部分使用相同的3个字母序列。</target>
        </trans-unit>
        <trans-unit id="a808380dda4fa48a019446ad652d6dc63c38be3d" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also allow the extraction of the parts of a string that matched. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. They can be used just as ordinary variables:</source>
          <target state="translated">分组元字符 &lt;code&gt;()&lt;/code&gt; 也允许提取匹配的字符串部分。对于每个分组，内部匹配的部分都进入特殊变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等。它们可以像普通变量一样使用：</target>
        </trans-unit>
        <trans-unit id="7778e0ad49a7501b63144277c49609f424265cc5" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also serve another completely different function: they allow the extraction of the parts of a string that matched. This is very useful to find out what matched and for text processing in general. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. They can be used just as ordinary variables:</source>
          <target state="translated">分组元字符 &lt;code&gt;()&lt;/code&gt; 还具有另一个完全不同的功能：它们允许提取匹配的字符串部分。通常，这对于查找匹配项以及进行文本处理非常有用。对于每个分组，内部匹配的部分都进入特殊变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等。它们可以像普通变量一样使用：</target>
        </trans-unit>
        <trans-unit id="1eece9645dd47cfb0899002c6d7925c002a7646e" translate="yes" xml:space="preserve">
          <source>The guts of &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; utility.</source>
          <target state="translated">&lt;a href=&quot;../perldoc&quot;&gt;Perldoc&lt;/a&gt;实用程序的勇气。</target>
        </trans-unit>
        <trans-unit id="31680a03b79cf90dad61ef90684e16f85b576d96" translate="yes" xml:space="preserve">
          <source>The handler names are based on the underlying type of the variable being declared or of the reference passed. Because these attributes are associated with subroutine or variable declarations, this deliberately ignores any possibility of being blessed into some package. Thus, a subroutine declaration uses &quot;CODE&quot; as its</source>
          <target state="translated">处理程序的名称是基于被声明的变量或传递的引用的基本类型。因为这些属性是与子程序或变量声明相关联的,这就刻意忽略了任何被祝福到某个包中的可能性。因此,一个子程序声明使用 &quot;CODE &quot;作为其</target>
        </trans-unit>
        <trans-unit id="a4c1e3467d4145540134804fd2549f602b627fdd" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals calls &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (actually &lt;code&gt;croak&lt;/code&gt; ) with a message indicating which signal was caught.</source>
          <target state="translated">用于随后安装的信号的处理程序调用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; （实际上是 &lt;code&gt;croak&lt;/code&gt; ），并显示一条消息，指示捕获了哪个信号。</target>
        </trans-unit>
        <trans-unit id="6f12af1084926ed2ac194950a97f332b400e2448" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals outputs a Perl stack trace to STDERR and then tries to dump core. This is the default signal handler.</source>
          <target state="translated">用于后续安装信号的处理程序,向STDERR输出Perl堆栈跟踪,然后尝试转储核心。这是默认的信号处理程序。</target>
        </trans-unit>
        <trans-unit id="d5126c9fee7d8a5338a4248383236dc9ecb51986" translate="yes" xml:space="preserve">
          <source>The handling of A &amp;amp; P in MBI/MBF (the old core code shipped with Perl versions &amp;lt;= 5.7.2) is like this:</source>
          <target state="translated">MBI / MBF（Perl版本&amp;lt;= 5.7.2附带的旧核心代码）中的A＆P的处理如下：</target>
        </trans-unit>
        <trans-unit id="fc9357967428b2793ab9d519118dce3147a43e76" translate="yes" xml:space="preserve">
          <source>The handling of errors by the layer is not specified. e.g. when $! should be set explicitly, when the error handling should be just delegated to the top layer.</source>
          <target state="translated">层对错误的处理没有明确规定,比如什么时候应该显式设置$!,什么时候应该只是将错误处理委托给上层。</target>
        </trans-unit>
        <trans-unit id="3b8d0bb90f4b079a36f72ce61ffbf0db337af8a2" translate="yes" xml:space="preserve">
          <source>The handling of hyphens and em dashes is somewhat fragile, and one may get the wrong one under some circumstances. This should only matter for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">连字符和破折号的处理有些脆弱，在某些情况下可能会弄错一个。这仅对&lt;b&gt;troff&lt;/b&gt;输出重要。</target>
        </trans-unit>
        <trans-unit id="de0cf92f651484ad4efbe5f702009188bf5e94e3" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%ENV&lt;/code&gt; contains your current environment. Setting a value in &lt;code&gt;ENV&lt;/code&gt; changes the environment for any child processes you subsequently &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; off.</source>
          <target state="translated">哈希 &lt;code&gt;%ENV&lt;/code&gt; 包含您当前的环境。在 &lt;code&gt;ENV&lt;/code&gt; 中设置一个值会更改您随后 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 关闭的任何子进程的环境。</target>
        </trans-unit>
        <trans-unit id="3342ea08441abded27300d3bc9cbf7a4f36851e5" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%INC&lt;/code&gt; contains entries for each filename included via the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; operators. The key is the filename you specified (with module names converted to pathnames), and the value is the location of the file found. The &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operator uses this hash to determine whether a particular file has already been included.</source>
          <target state="translated">哈希 &lt;code&gt;%INC&lt;/code&gt; 包含通过 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 运算符包含的每个文件名的条目。密钥是您指定的文件名（模块名称已转换为路径名），值是找到的文件的位置。该 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 运营商使用该哈希来确定特定文件是否已经被包含在内。</target>
        </trans-unit>
        <trans-unit id="ae0c946c442c59fafdf0cc03f5925a7d6a67576e" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%SIG&lt;/code&gt; contains signal handlers for signals. For example:</source>
          <target state="translated">哈希 &lt;code&gt;%SIG&lt;/code&gt; 包含信号的信号处理程序。例如：</target>
        </trans-unit>
        <trans-unit id="2b378e4f482e4b01f36a8f2a09efa90c92e18352" translate="yes" xml:space="preserve">
          <source>The hash algorithm is defined in the &lt;code&gt;PERL_HASH&lt;/code&gt; macro:</source>
          <target state="translated">哈希算法在 &lt;code&gt;PERL_HASH&lt;/code&gt; 宏中定义：</target>
        </trans-unit>
        <trans-unit id="eea3de2cc53cbdd71b8b1d8903e357859f8beec1" translate="yes" xml:space="preserve">
          <source>The hash described above is returned for locale-independent casing, where at least one of the mappings has length longer than one. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the code point may have mappings, but if so, all are length one, and are returned by &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;. Note that when this function does return a value, it will be for the complete set of mappings for a code point, even those whose length is one.</source>
          <target state="translated">对于与语言环境无关的大小写，返回上述哈希值，其中至少一个映射的长度大于一个。如果返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则代码点可能具有映射，但如果是，则所有映射都是长度为1，并由&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;返回。请注意，当此函数确实返回值时，它将用于代码点的完整映射集，即使长度为1的映射也是如此。</target>
        </trans-unit>
        <trans-unit id="0c18c1acf75672457070b2eb9996c5075b3edce2" translate="yes" xml:space="preserve">
          <source>The hash does not support exists().</source>
          <target state="translated">哈希不支持exist()。</target>
        </trans-unit>
        <trans-unit id="8ead17751b61a27f00737722511d4f0a6b122f2d" translate="yes" xml:space="preserve">
          <source>The hash has the same structure as the one returned by Storable::file_magic(). The &lt;code&gt;file&lt;/code&gt; element is true if the image is a file image.</source>
          <target state="translated">哈希与Storable :: file_magic（）返回的哈希具有相同的结构。该 &lt;code&gt;file&lt;/code&gt; 如果图像是文件图像元素是真实的。</target>
        </trans-unit>
        <trans-unit id="5130b4f9ca4de414c6b75c63b4b5de1f1cac05d9" translate="yes" xml:space="preserve">
          <source>The hash reference returned by the new() function can be used to examine and modify the contents of the .packlist. Items may be added/deleted from the .packlist by modifying the hash. If the value associated with a hash key is a scalar, the entry written to the .packlist by any subsequent write() will be a simple filename. If the value is a hash, the entry written will be the filename followed by the key=value pairs from the hash. Reading back the .packlist will recreate the original entries.</source>
          <target state="translated">new()函数返回的哈希引用可以用来检查和修改 .packlist 的内容。可以通过修改哈希值从.packlist中添加/删除项目。如果与哈希键相关联的值是一个标量,那么任何后续的write()写入.packlist的条目将是一个简单的文件名。如果值是一个哈希,写入的条目将是文件名,然后是哈希中的key=value对。读回.packlist将重新创建原始条目。</target>
        </trans-unit>
        <trans-unit id="7516ee71ac16390106261a6b0bbe1da56c817eef" translate="yes" xml:space="preserve">
          <source>The hash returned has the following elements:</source>
          <target state="translated">返回的哈希值有以下元素。</target>
        </trans-unit>
        <trans-unit id="43a906eb4ff4eda3db678faefd07c14f14845797" translate="yes" xml:space="preserve">
          <source>The hash variable you want to tie.</source>
          <target state="translated">你要绑定的哈希变量。</target>
        </trans-unit>
        <trans-unit id="0ab4ffe148d6038400649049035912b11305e989" translate="yes" xml:space="preserve">
          <source>The head of the chain of deleted ops is returned, or NULL if no ops were deleted.</source>
          <target state="translated">返回已删除操作链的头部,如果没有删除操作,则返回NULL。</target>
        </trans-unit>
        <trans-unit id="6c336f0d4ef1d936490e8c7b4819c090f6400cf2" translate="yes" xml:space="preserve">
          <source>The header file written by this module, typically</source>
          <target state="translated">由该模块编写的头文件,一般为</target>
        </trans-unit>
        <trans-unit id="4c85c6655d7d1206831fdc527a34ff595586e985" translate="yes" xml:space="preserve">
          <source>The header section continues until a line containing the word CHARMAP. This section has a form of</source>
          <target state="translated">标题部分一直持续到包含CHARMAP字样的一行。这一部分的形式是</target>
        </trans-unit>
        <trans-unit id="a528e0d6eaf7b88f88a4f152246f56b029cd4490" translate="yes" xml:space="preserve">
          <source>The heart of Storable is written in C for decent speed. Extra low-level optimizations have been made when manipulating perl internals, to sacrifice encapsulation for the benefit of greater speed.</source>
          <target state="translated">Storable的核心是用C语言编写的,速度不错。在操作perl内部的时候,我们做了额外的低级优化,以牺牲封装来换取更快的速度。</target>
        </trans-unit>
        <trans-unit id="a6afbf6cabde867bd59953ce46fc882087b1bd27" translate="yes" xml:space="preserve">
          <source>The hex number may optionally be prefixed with &quot;0x&quot; or &quot;x&quot; unless &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; is set in</source>
          <target state="translated">十六进制数字可以选择以&amp;ldquo; 0x&amp;rdquo;或&amp;ldquo; x&amp;rdquo;为前缀，除非在 &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; 位置设置了PERL_SCAN_DISALLOW_PREFIX：</target>
        </trans-unit>
        <trans-unit id="e478860a296847f9fc713c230a9fb9343e5f150e" translate="yes" xml:space="preserve">
          <source>The higher-level loops preserve an additional state between iterations: whether the last match was zero-length. To break the loop, the following match after a zero-length match is prohibited to have a length of zero. This prohibition interacts with backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;), and so the</source>
          <target state="translated">较高级别的循环在迭代之间保留一个附加状态：最后一个匹配是否为零长度。为了打破循环，在零长度匹配之后的以下匹配禁止为零。此禁止与回溯（请参见&lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;）相互作用，因此</target>
        </trans-unit>
        <trans-unit id="9a2214ecae9d593eb49cab164240c89849da3aae" translate="yes" xml:space="preserve">
          <source>The hintsfile is eval()ed immediately after the arguments given to WriteMakefile are stuffed into a hash reference $self but before this reference becomes blessed. So if you want to do the equivalent to override or create an attribute you would say something like</source>
          <target state="translated">hintsfile在给WriteMakefile的参数被塞进一个哈希引用$self之后,但在这个引用成为祝福之前,立即被eval()ed。所以,如果你想做等价的覆盖或创建一个属性,你会说像这样的话</target>
        </trans-unit>
        <trans-unit id="c6b34cade6e81d89b062f256b78cf0c9f72eec68" translate="yes" xml:space="preserve">
          <source>The hook used by perl's &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; operator. &lt;b&gt;ptype&lt;/b&gt; is perl's character for the kind of IO:</source>
          <target state="translated">Perl的 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 运算符使用的钩子。&lt;b&gt;ptype&lt;/b&gt;是perl的IO类型的特征：</target>
        </trans-unit>
        <trans-unit id="f349975f67add93f8850a9eaf9c6c17fd6d7655e" translate="yes" xml:space="preserve">
          <source>The host name supplied to getaddrinfo() did not provide any usable address data.</source>
          <target state="translated">提供给getaddrinfo()的主机名没有提供任何可用的地址数据。</target>
        </trans-unit>
        <trans-unit id="26f0f0653cc389e36c588050d688c99bccaa9d07" translate="yes" xml:space="preserve">
          <source>The host name supplied to getaddrinfo() does not exist, or the address supplied to getnameinfo() is not associated with a host name and the &lt;code&gt;NI_NAMEREQD&lt;/code&gt; flag was supplied.</source>
          <target state="translated">提供给getaddrinfo（）的主机名不存在，或者提供给getnameinfo（）的地址未与主机名关联，并且提供了 &lt;code&gt;NI_NAMEREQD&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="a5eeccb55ae3d60bff3752f2dd5a946e36daa986" translate="yes" xml:space="preserve">
          <source>The hostname in the uri. Will be empty if host was originally 'localhost' for a 'file://' url.</source>
          <target state="translated">uri中的主机名。如果host是'file://'url的'localhost',则为空。</target>
        </trans-unit>
        <trans-unit id="2bcd00b585852692b974ea751e079b51540b5b54" translate="yes" xml:space="preserve">
          <source>The hyperbolic sine, cosine, and tangent</source>
          <target state="translated">双曲正弦、余弦和正切。</target>
        </trans-unit>
        <trans-unit id="a67744a35db2bbac17aada3b55cebfdff3c8d58f" translate="yes" xml:space="preserve">
          <source>The icmp protocol requires that the program be run as root or that it be setuid to root. The other protocols do not require special privileges, but not all network devices implement tcp or udp echo.</source>
          <target state="translated">icmp协议要求程序必须以root身份运行,或者设置uid为root。其他协议不需要特殊的权限,但并非所有的网络设备都实现了tcp或udp echo。</target>
        </trans-unit>
        <trans-unit id="0eb904ac9079537474ee2cc5638a1c5ecde2814c" translate="yes" xml:space="preserve">
          <source>The id must start with a letter (a-z or A-Z)</source>
          <target state="translated">ID必须以字母(a-z或A-Z)开头。</target>
        </trans-unit>
        <trans-unit id="28df5f4390b3a084c824acbbd266525edf8be51a" translate="yes" xml:space="preserve">
          <source>The ideal (but a bit ugly) way to never have to think about that is to use &lt;code&gt;BEGIN&lt;/code&gt; blocks. So the first part of the &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; code could be rewritten as:</source>
          <target state="translated">无需考虑的理想（但有点难看）的方法是使用 &lt;code&gt;BEGIN&lt;/code&gt; 块。因此，&lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt;代码的第一部分可以重写为：</target>
        </trans-unit>
        <trans-unit id="c4b5bd1f2c1aa12d8d86dc87b94e48313e6fd68a" translate="yes" xml:space="preserve">
          <source>The immediate, previous releases (i.e. perl5.14.x ) are usually maintained for a while, although not at the same level as the current releases.</source>
          <target state="translated">前期的版本(例如 perl5.14.x )通常会被维护一段时间,尽管与当前的版本不在同一水平。</target>
        </trans-unit>
        <trans-unit id="805f5e34bdac09e91b618eb56a2ba5ac7b88cd61" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;:raw&lt;/code&gt; is as a pseudo-layer which when &quot;pushed&quot; pops itself and then any layers which do not declare themselves as suitable for binary data. (Undoing :utf8 and :crlf are implemented by clearing flags rather than popping layers but that is an implementation detail.)</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; 的实现是一个伪层，当&amp;ldquo;按下&amp;rdquo;时会弹出自身，然后弹出任何不声明自己适合于二进制数据的层。（撤消：utf8和：crlf是通过清除标志而不是弹出层来实现的，但这是实现的细节。）</target>
        </trans-unit>
        <trans-unit id="1868b2d1d8d2925ab9482699d09a63b0f1af9f3c" translate="yes" xml:space="preserve">
          <source>The implementation of individual components of the system is likely to change over time.</source>
          <target state="translated">该系统各个组成部分的执行情况可能会随着时间的推移而改变。</target>
        </trans-unit>
        <trans-unit id="6075b5ee16206eda7e75f744a66591ab7ff6ad34" translate="yes" xml:space="preserve">
          <source>The implementation of the C3 MRO and switchable MROs within the perl core was written by Brandon L Black. Nicholas Clark created the pluggable interface, refactored Brandon's implementation to work with it, and wrote this document.</source>
          <target state="translated">在perl核心中实现C3 MRO和可切换MRO是由Brandon L Black编写的。Nicholas Clark创建了可插拔的接口,对Brandon的实现进行了重构以与之配合,并编写了这个文档。</target>
        </trans-unit>
        <trans-unit id="f92ca5378313f5f6ef2629dcf71bf80c645c279f" translate="yes" xml:space="preserve">
          <source>The implication of the above description is that a pattern containing nested parentheses will result in a call graph which cycles through &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt; , &lt;code&gt;regpiece()&lt;/code&gt; , &lt;code&gt;regatom()&lt;/code&gt; , &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt;</source>
          <target state="translated">上面描述的含义是，包含嵌套括号的模式将导致调用图循环通过 &lt;code&gt;reg()&lt;/code&gt; ， &lt;code&gt;regbranch()&lt;/code&gt; ， &lt;code&gt;regpiece()&lt;/code&gt; ， &lt;code&gt;regatom()&lt;/code&gt; ， &lt;code&gt;reg()&lt;/code&gt; ， &lt;code&gt;regbranch()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61ca45a7499fa655d95fb3a1c14575987ee3c0c2" translate="yes" xml:space="preserve">
          <source>The implicit iterator variable in the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; 函数中的隐式迭代器变量。</target>
        </trans-unit>
        <trans-unit id="49df36702f6a3c6192de102a29688dbe9fd4061b" translate="yes" xml:space="preserve">
          <source>The implicit variable of &lt;code&gt;given()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;given()&lt;/code&gt; 的隐式变量。</target>
        </trans-unit>
        <trans-unit id="04c82ff9343f818ba122f89e2a74fb9d1d0fecda" translate="yes" xml:space="preserve">
          <source>The importance of these tests is proportional to the alleged stability of a module. A module which purports to be stable or which hopes to achieve wide use should adhere to as strict a testing regime as possible.</source>
          <target state="translated">这些测试的重要性与一个模块的所谓稳定性成正比。一个自称稳定或希望得到广泛使用的模块应尽可能严格地遵守测试制度。</target>
        </trans-unit>
        <trans-unit id="09af00710c80d3dd70ebd96fd4367e42313c5d25" translate="yes" xml:space="preserve">
          <source>The importance of writing good test scripts cannot be over-emphasized. You should closely follow the &quot;ok/not ok&quot; style that Perl itself uses, so that it is very easy and unambiguous to determine the outcome of each test case. When you find and fix a bug, make sure you add a test case for it.</source>
          <target state="translated">写好测试脚本的重要性怎么强调都不过分。你应该严格遵循Perl本身所使用的 &quot;ok/not ok &quot;风格,这样就可以非常容易和明确地确定每个测试用例的结果。当你发现并修复一个bug时,一定要为它添加一个测试用例。</target>
        </trans-unit>
        <trans-unit id="a4561daf93366d570e71e9394fec54f9d31846e6" translate="yes" xml:space="preserve">
          <source>The important and distinguishing feature of run_forked is execution timeout which at first seems to be quite a simple task but if you think that the program which you're spawning might spawn some children itself (which in their turn could do the same and so on) it turns out to be not a simple issue.</source>
          <target state="translated">run_forked的重要和显著的特征是执行超时,这乍一看似乎是一个相当简单的任务,但如果你想到你正在产生的程序可能会产生一些子程序(它们反过来也可以做同样的事情,等等),就会发现这不是一个简单的问题。</target>
        </trans-unit>
        <trans-unit id="4973662d6822686f7aa087396e5cfac037bf9b09" translate="yes" xml:space="preserve">
          <source>The important parts of that are the second argument (the increment) to HEAP, and allowing the stack to be &quot;Above the (16M) line&quot;. If the heap increment is too small then when perl (for example loading unicode/Name.pl) tries to create a &quot;big&quot; (400K+) string it cannot fit in a single segment and you get &quot;Out of Memory!&quot; - even if there is still plenty of memory available.</source>
          <target state="translated">其中重要的部分是HEAP的第二个参数(增量),以及允许堆栈在&quot;(16M)行以上&quot;。如果堆增量太小,那么当perl(例如加载unicode/Name.pl)试图创建一个 &quot;大&quot;(400K以上)的字符串时,它无法容纳在一个段中,你会得到 &quot;Out of Memory!&quot;。-即使还有很多可用的内存,也会得到 &quot;Out of Memory!&quot;。</target>
        </trans-unit>
        <trans-unit id="3f69c866bd6b570c0ad67a5d6dcc4f47abb90206" translate="yes" xml:space="preserve">
          <source>The included contents will be inserted into the MANIFEST.SKIP file in between</source>
          <target state="translated">所包含的内容将被插入到MANIFEST.SKIP文件中的中间位置。</target>
        </trans-unit>
        <trans-unit id="02e5563a36b89e14fcbd689f1595a21037cddaee" translate="yes" xml:space="preserve">
          <source>The independent subexpression &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; doesn't care about the rest of the regexp, so it sees an &lt;code&gt;a&lt;/code&gt; and grabs it. Then the rest of the regexp &lt;code&gt;ab&lt;/code&gt; cannot match. Because &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; is independent, there is no backtracking and the independent subexpression does not give up its &lt;code&gt;a&lt;/code&gt; . Thus the match of the regexp as a whole fails. A similar behavior occurs with completely independent regexps:</source>
          <target state="translated">独立子表达式 &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; 不在乎正则表达式的其余部分，因此它看到 &lt;code&gt;a&lt;/code&gt; 并抓住了它。然后其余的regexp &lt;code&gt;ab&lt;/code&gt; 无法匹配。因为 &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; 是独立的，所以没有回溯，并且独立的子表达式不会放弃其 &lt;code&gt;a&lt;/code&gt; 。因此，整个regexp的匹配失败。完全独立的正则表达式也会发生类似的现象：</target>
        </trans-unit>
        <trans-unit id="d8911df7ecc3a80cd7cb7748b8608afa2215b297" translate="yes" xml:space="preserve">
          <source>The index entry specified contains nothing but whitespace.</source>
          <target state="translated">指定的索引条目只包含空格。</target>
        </trans-unit>
        <trans-unit id="ed2b9d5332f95abb7e28bc54e5124d59c88ac74f" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; returns -1.</source>
          <target state="translated">索引函数在另一个字符串中搜索一个字符串，但是没有完整的正则表达式模式匹配的类似通配符的行为。它返回POSITION或之后STR中第一次出现SUBSTR的位置。如果省略POSITION，则从字符串的开头开始搜索。字符串开头之前或结尾之后的POSITION分别视为字符串的开头或结尾。POSITION和返回值基于零。如果未找到子字符串，则 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 返回-1。</target>
        </trans-unit>
        <trans-unit id="052a5a20374b32a9d318c8e657a3fc6d2c067a62" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;code&gt;&lt;a href=&quot;index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; returns -1.</source>
          <target state="translated">索引函数在另一个字符串中搜索一个字符串，但是没有完整的正则表达式模式匹配的类似通配符的行为。它返回POSITION或之后STR中第一次出现SUBSTR的位置。如果省略POSITION，则从字符串的开头开始搜索。字符串开头之前或结尾之后的POSITION分别视为字符串的开头或结尾。POSITION和返回值基于零。如果未找到子字符串，则 &lt;code&gt;&lt;a href=&quot;index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 返回-1。</target>
        </trans-unit>
        <trans-unit id="f9d12f86f44aac2e21ecbe7b61cc95b95675209f" translate="yes" xml:space="preserve">
          <source>The index of the last allocated space in the padlist. Note that the last pad may be in an earlier slot. Any entries following it will be NULL in that case.</source>
          <target state="translated">垫表中最后一个分配的空间的索引。请注意,最后一个pad可能在一个较早的槽中。在这种情况下,它后面的任何条目将是NULL。</target>
        </trans-unit>
        <trans-unit id="e58a7f8912fdbd8eaa97b22ef4d5d356a40471d5" translate="yes" xml:space="preserve">
          <source>The index of the last pad entry.</source>
          <target state="translated">最后一个垫子的索引。</target>
        </trans-unit>
        <trans-unit id="9c1326f686e664ef67aae2567ac4696fd6d57b00" translate="yes" xml:space="preserve">
          <source>The index of the last pad name.</source>
          <target state="translated">最后一个垫名的索引。</target>
        </trans-unit>
        <trans-unit id="cda2671ac9e05ad8e30450bd5f169c0ab42ddce2" translate="yes" xml:space="preserve">
          <source>The indexing merely outputs messages via &lt;code&gt;.tm&lt;/code&gt; for each major page, section, subsection, item, and any &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; directives. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for more details.</source>
          <target state="translated">索引仅通过 &lt;code&gt;.tm&lt;/code&gt; 为每个主要页面，节，小节，项目和任何 &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 指令输出消息。有关更多详细信息，请参见&lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c99d2cd33e1325afbec2e3f58c4236d44c82d895" translate="yes" xml:space="preserve">
          <source>The inferred anchor text is implemented per &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;:</source>
          <target state="translated">推断的锚文本是根据&lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;实现的：</target>
        </trans-unit>
        <trans-unit id="9dfbacdda04f65b21a64f3fbe8dd597fa30ae2f5" translate="yes" xml:space="preserve">
          <source>The infinity and not-a-number have their own special arithmetic rules. The general rule is that they are &quot;contagious&quot;: &lt;code&gt;Inf&lt;/code&gt; plus one is &lt;code&gt;Inf&lt;/code&gt; , and &lt;code&gt;NaN&lt;/code&gt; plus one is &lt;code&gt;NaN&lt;/code&gt; . Where things get interesting is when you combine infinities and not-a-numbers: &lt;code&gt;Inf&lt;/code&gt; minus &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; divided by &lt;code&gt;INf&lt;/code&gt; are &lt;code&gt;NaN&lt;/code&gt; (while &lt;code&gt;Inf&lt;/code&gt; plus &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; times &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; ). &lt;code&gt;NaN&lt;/code&gt; is also curious in that it does not equal any number,</source>
          <target state="translated">无穷大和非数字都有自己的特殊算术规则。一般规则是它们具有&amp;ldquo;传染性&amp;rdquo;： &lt;code&gt;Inf&lt;/code&gt; 加1为 &lt;code&gt;Inf&lt;/code&gt; ， &lt;code&gt;NaN&lt;/code&gt; 加1为 &lt;code&gt;NaN&lt;/code&gt; 。事情变得有趣的是，当你把无穷大，而不是一个号码： &lt;code&gt;Inf&lt;/code&gt; 减去 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;Inf&lt;/code&gt; 除以 &lt;code&gt;INf&lt;/code&gt; 是 &lt;code&gt;NaN&lt;/code&gt; （而 &lt;code&gt;Inf&lt;/code&gt; 加 &lt;code&gt;Inf&lt;/code&gt; 是 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;Inf&lt;/code&gt; 倍 &lt;code&gt;Inf&lt;/code&gt; 是 &lt;code&gt;Inf&lt;/code&gt; ）。 &lt;code&gt;NaN&lt;/code&gt; 也很好奇，因为它不等于任何数字，</target>
        </trans-unit>
        <trans-unit id="47e5e47a18eb5768545b57a7c2da190e8c801676" translate="yes" xml:space="preserve">
          <source>The infinity is the result of certain math operations that overflow the floating point range, like 9**9**9. The not-a-number is the result when the result is undefined or unrepresentable. Though note that you cannot get &lt;code&gt;NaN&lt;/code&gt; from some common &quot;undefined&quot; or &quot;out-of-range&quot; operations like dividing by zero, or square root of a negative number, since Perl generates fatal errors for those.</source>
          <target state="translated">无限是某些数学运算导致浮点数范围溢出的结果，例如9 ** 9 ** 9。当结果不确定或无法表示时，结果为非数字。但是请注意，您无法从某些常见的&amp;ldquo;未定义&amp;rdquo;或&amp;ldquo;超出范围&amp;rdquo;操作（例如除以零或负数的平方根）获得 &lt;code&gt;NaN&lt;/code&gt; ，因为Perl会为这些操作产生致命错误。</target>
        </trans-unit>
        <trans-unit id="00c49c340cf01a0ad0057e1d1a4eb69e30e225ff" translate="yes" xml:space="preserve">
          <source>The information in</source>
          <target state="translated">中的信息</target>
        </trans-unit>
        <trans-unit id="477d4eda55a2d3f9993a8441da0761392c6f4bde" translate="yes" xml:space="preserve">
          <source>The init routine asks a few questions and writes a CPAN/Config.pm or CPAN/MyConfig.pm file (depending on what it is currently using).</source>
          <target state="translated">init例程会询问一些问题,并写入一个CPAN/Config.pm或CPAN/MyConfig.pm文件(取决于它当前使用的是什么)。</target>
        </trans-unit>
        <trans-unit id="46a6f162dfe4fd1932efaab095f3ad6c7065353c" translate="yes" xml:space="preserve">
          <source>The initial Haiku port was done by Ingo Weinhold &amp;lt;ingo_weinhold@gmx.de&amp;gt;.</source>
          <target state="translated">最初的Haiku端口由Ingo Weinhold &amp;lt;ingo_weinhold@gmx.de&amp;gt;完成。</target>
        </trans-unit>
        <trans-unit id="30baee764016e0fd1d74fa20302dc7f15e17366e" translate="yes" xml:space="preserve">
          <source>The initial comment shows a contrived, even dangerous example. By overriding &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; globally, you would be forcing the new (and subversive) behavior for the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator for</source>
          <target state="translated">最初的评论显示了一个人为的甚至危险的例子。通过全局覆盖 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; ，您将强制 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 运算符的新（且具有颠覆性）行为</target>
        </trans-unit>
        <trans-unit id="9bd35ba0a15f59402bf69541a0c2a672b5245bb7" translate="yes" xml:space="preserve">
          <source>The initializer for a class element is an object of the corresponding class, or of one of it's subclasses, or a reference to a hash containing named arguments to be passed to the element's constructor.</source>
          <target state="translated">类元素的初始化器是相应类的对象,或者是它的一个子类的对象,或者是对包含命名参数的哈希的引用,这些参数将传递给元素的构造函数。</target>
        </trans-unit>
        <trans-unit id="7270a1d75b517033df50fe18fd9734207c302454" translate="yes" xml:space="preserve">
          <source>The input character at &lt;code&gt;p&lt;/code&gt; is assumed to be well-formed.</source>
          <target state="translated">假定 &lt;code&gt;p&lt;/code&gt; 处的输入字符格式正确。</target>
        </trans-unit>
        <trans-unit id="5b4da48b1525c95aa66984d855f728baeff9dd23" translate="yes" xml:space="preserve">
          <source>The input data will be read from each file in turn.</source>
          <target state="translated">输入数据将依次从每个文件中读取。</target>
        </trans-unit>
        <trans-unit id="6a300bdc55cb2694c445f5d77189a272f405a2c8" translate="yes" xml:space="preserve">
          <source>The input number must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">输入数字必须是非负整数，或以 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 开头的字符串，其余部分视为十六进制整数。文字数字常量必须是无符号的；如果前导零或包含非十进制十六进制数字，则将其解释为十六进制；否则将被解释为十进制。如果以 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 开头，则将其解释为Unicode代码点；否则，将其解释为Unicode代码点。否则，它将被解释为本地的。 （只有256以下的代码点在Unicode和本机之间可以有所不同。）因此， &lt;code&gt;U+41&lt;/code&gt; 始终是拉丁字母&amp;ldquo; A&amp;rdquo;。但是 &lt;code&gt;0x41&lt;/code&gt; 在EBCDIC平台上可以是&amp;ldquo; NO-BREAK SPACE&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="74af33c799ba9469f42a06ffc1422c08fe76ab11" translate="yes" xml:space="preserve">
          <source>The input parameter name is loosely matched, which means that white space, hyphens, and underscores are ignored (except for the trailing underscore in the old_form grandfathered-in &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; , and both of which mean &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; ).</source>
          <target state="translated">输入参数名称是松散匹配的，这意味着空格，连字符和下划线将被忽略（除了old_form祖父输入的 &lt;code&gt;&quot;L_&quot;&lt;/code&gt; 的尾随下划线，最好将其写为 &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ，并且两者都意味着 &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6e74e0d2d8b749838155344b24b616732216f51a" translate="yes" xml:space="preserve">
          <source>The input record separator - &lt;code&gt;$/&lt;/code&gt; in Perl space.</source>
          <target state="translated">输入记录分隔符-Perl空间中的 &lt;code&gt;$/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fa23e4762b9d73d4eaf4fe4ff40a6345a28b068" translate="yes" xml:space="preserve">
          <source>The input record separator, newline by default. This influences Perl's idea of what a &quot;line&quot; is. Works like &lt;b&gt;awk&lt;/b&gt;'s RS variable, including treating empty lines as a terminator if set to the null string (an empty line cannot contain any spaces or tabs). You may set it to a multi-character string to match a multi-character terminator, or to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to read through the end of file. Setting it to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; means something slightly different than setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; , if the file contains consecutive empty lines. Setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; will treat two or more consecutive empty lines as a single empty line. Setting to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; will blindly assume that the next input character belongs to the next paragraph, even if it's a newline.</source>
          <target state="translated">输入记录分隔符，默认为换行符。这影响了Perl关于&amp;ldquo;线&amp;rdquo;的概念。就像&lt;b&gt;awk&lt;/b&gt;的RS变量一样工作，包括如果将空行设置为null字符串（空行不能包含任何空格或制表符），则将空行视为终止符。您可以将其设置为多字符字符串以匹配多字符终止符，或者将其设置为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 以通读文件末尾。如果文件包含连续的空行，则将其设置为 &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 意味着与设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 稍有不同。设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt; 会将两个或多个连续的空行视为一个空行。设置为 &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 会盲目地假设下一个输入字符属于下一段，即使它是换行符也是如此。</target>
        </trans-unit>
        <trans-unit id="32e2a05c675d83b32cdc798d03f4bd19670bf464" translate="yes" xml:space="preserve">
          <source>The insertion of a scalar or list value somewhere in the middle of another value, such that it appears to have been there all along. In Perl, variable interpolation happens in double-quoted strings and patterns, and list interpolation occurs when constructing the list of values to pass to a list operator or other such construct that takes a</source>
          <target state="translated">将一个标量值或列表值插入到另一个值的中间某处,使其看起来好像一直都在那里。在Perl中,变量插值发生在双引号字符串和模式中,而列表插值则发生在构建要传递给列表运算符的值列表或其他类似的构造中,这些构造取一个</target>
        </trans-unit>
        <trans-unit id="4d21a2b8d717cbebbeaee5c37e1b249a9b6f4299" translate="yes" xml:space="preserve">
          <source>The inspiration for the stop codon DNA example came from the ZIP code example in chapter 7 of</source>
          <target state="translated">终止密码子DNA例子的灵感来自于在《中国科学》第7章中的ZIP码例子。</target>
        </trans-unit>
        <trans-unit id="4a97f9d9b06cf863773b30ca4503b6a95be51b13" translate="yes" xml:space="preserve">
          <source>The installation paths that you set during the build get compiled into perl, so you don't have to do anything additional to start using that perl (except add its location to your PATH variable).</source>
          <target state="translated">你在构建过程中设置的安装路径会被编译成perl,所以你不需要做任何额外的事情就可以开始使用该perl(除了将它的位置添加到你的PATH变量)。</target>
        </trans-unit>
        <trans-unit id="ed7ec50305347f54da6bfda8296e9515a40cfdd4" translate="yes" xml:space="preserve">
          <source>The installer is ancient and has a few bugs on the paths it uses. You will have to fix them later. Basically, some things go into &quot;C:/Program Files/Windows CE Tools&quot;, others go into &quot;C:/Windows CE Tools&quot; regardless of the path you gave to the installer (the default will be &quot;C:/Windows CE Tools&quot;). Reboots will be required for the installer to proceed. Also .c and .h associations with Visual Studio might get overridden when installing EVC4. You have been warned.</source>
          <target state="translated">安装程序是古老的,它使用的路径上有一些错误。你将不得不稍后修复它们。基本上,有些东西会进入 &quot;C:/Program Files/Windows CE Tools&quot;,有些则会进入 &quot;C:/Windows CE Tools&quot;,不管你给安装程序的路径如何(默认是 &quot;C:/Windows CE Tools&quot;)。安装程序需要重新启动才能进行。另外,在安装EVC4时,Visual Studio的.c和.h关联可能会被覆盖。您已被警告。</target>
        </trans-unit>
        <trans-unit id="5b7ef7bcb453733f9ef12df7a7d461832dbe120b" translate="yes" xml:space="preserve">
          <source>The installman script will try to run on OS/390. There will be fewer errors if you have a roff utility installed. You can obtain GNU groff from the Redbook SG24-5944-00 ftp site.</source>
          <target state="translated">安装脚本将尝试在OS/390上运行。如果你安装了roff实用程序,错误就会减少。你可以从 Redbook SG24-5944-00 ftp 站点获得 GNU groff。</target>
        </trans-unit>
        <trans-unit id="85593ec8ae8efa2e0dca43eb532734290d86abb5" translate="yes" xml:space="preserve">
          <source>The integer a computer uses to represent a given character. ASCII codepoints are in the range 0 to 127; Unicode codepoints are in the range 0 to 0x1F_FFFF; and Perl codepoints are in the range 0 to 2&amp;sup3;&amp;sup2;&amp;minus;1 or 0 to 2⁶⁴&amp;minus;1, depending on your native integer size. In Perl Culture, sometimes called &lt;b&gt;ordinals&lt;/b&gt;.</source>
          <target state="translated">计算机用来表示给定字符的整数。ASCII码点的范围是0到127；Unicode代码点的范围是0到0x1F_FFFF；和Perl代码点的范围是0到2&amp;sup3;&amp;sup2;&amp;minus;1或0到2 ^ -1，这取决于您的本机整数大小。在Perl文化中，有时也称为普通&lt;b&gt;俗语&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="fffacf90cdbd65b0d80477a60f2e9ed117d5e990" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; , and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="translated">整数格式 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;I&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;J&lt;/code&gt; 本质上不可在处理器和操作系统之间移植，因为它们遵循本机字节序和字节序。例如，一个4字节的整数0x12345678（十进制305419896）将被本机排序（安排并由CPU寄存器处理）为字节，如下所示：</target>
        </trans-unit>
        <trans-unit id="c85dc9716f98ce9d26e0b8a1181441b82dd671db" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; , and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="translated">整数格式 &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;I&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;J&lt;/code&gt; 本质上不可在处理器和操作系统之间移植，因为它们遵循本机字节序和字节序。例如，一个4字节的整数0x12345678（十进制305419896）将被本机排序（安排并由CPU寄存器处理）为字节，如下所示：</target>
        </trans-unit>
        <trans-unit id="1696e5627c4e618d6b57f471d56db53f3261ebc8" translate="yes" xml:space="preserve">
          <source>The integer four, not to be confused with six, Tom&amp;rsquo;s favorite editor. IV also means an internal Integer Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold, not to be confused with an &lt;b&gt;NV&lt;/b&gt;.</source>
          <target state="translated">整数四，不要与汤姆最喜欢的编辑器六混淆。IV还表示&lt;b&gt;标量&lt;/b&gt;可以容纳的内部整数值，不要与&lt;b&gt;NV&lt;/b&gt;混淆。</target>
        </trans-unit>
        <trans-unit id="38f7f88bfbbfc7fbb6565adc2a9af0982c4ebbc9" translate="yes" xml:space="preserve">
          <source>The integer or name form of the &lt;code&gt;condition&lt;/code&gt; allows us to choose, with more flexibility, what to match based on what matched earlier in the regexp. This searches for words of the form &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; or &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt; :</source>
          <target state="translated">的的整数或名称的形式 &lt;code&gt;condition&lt;/code&gt; 允许我们选择，更大的灵活性，并基于前面的正则表达式匹配什么匹配什么。此搜索形式为 &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt; 单词：</target>
        </trans-unit>
        <trans-unit id="e05de89837820906430d66857198677bee870304" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="translated">整数类型 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;L&lt;/code&gt; 后面可以跟有 &lt;code&gt;!&lt;/code&gt; 修饰符以指定本机短裤或多头。如该示例中所示的上方，一个裸 &lt;code&gt;l&lt;/code&gt; 手段恰好32位，虽然天然 &lt;code&gt;long&lt;/code&gt; 由本地C编译器看到的可能较大。这主要是在64位平台上的问题。您可以查看是否使用 &lt;code&gt;!&lt;/code&gt; 这种方式有什么不同：</target>
        </trans-unit>
        <trans-unit id="e28530f74a983b5b7c88ba8ea81f426cbf7efd7c" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="translated">整数类型 &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;L&lt;/code&gt; 后面可以跟有 &lt;code&gt;!&lt;/code&gt; 修饰符以指定本机短裤或多头。如该示例中所示的上方，一个裸 &lt;code&gt;l&lt;/code&gt; 手段恰好32位，虽然天然 &lt;code&gt;long&lt;/code&gt; 由本地C编译器看到的可能较大。这主要是在64位平台上的问题。您可以查看是否使用 &lt;code&gt;!&lt;/code&gt; 这种方式有什么不同：</target>
        </trans-unit>
        <trans-unit id="ec5708b037f56278734976c0deaf7b452666b9a4" translate="yes" xml:space="preserve">
          <source>The intended purpose of this routine is to concatenate</source>
          <target state="translated">这个例程的目的是连接</target>
        </trans-unit>
        <trans-unit id="35499217c3dc076a80a3d7b854f65596514d0493" translate="yes" xml:space="preserve">
          <source>The intent is simplicity of use, not power of expression. Paragraphs look like paragraphs (block format), so that they stand out visually, and so that I could run them through &lt;code&gt;fmt&lt;/code&gt; easily to reformat them (that's F7 in my version of &lt;b&gt;vi&lt;/b&gt;, or Esc Q in my version of &lt;b&gt;emacs&lt;/b&gt;). I wanted the translator to always leave the &lt;code&gt;'&lt;/code&gt; and &lt;code&gt;`&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; quotes alone, in verbatim mode, so I could slurp in a working program, shift it over four spaces, and have it print out, er, verbatim. And presumably in a monospace font.</source>
          <target state="translated">目的是使用简单，而不是表达能力。段落看起来像段落（块格式），以便它们在视觉上脱颖而出，以便我可以轻松地通过 &lt;code&gt;fmt&lt;/code&gt; 运行它们以重新格式化它们（在我的&lt;b&gt;vi&lt;/b&gt;版本中为F7，在我的&lt;b&gt;emacs&lt;/b&gt;版本中为Esc Q ）。我想翻译永远离开 &lt;code&gt;'&lt;/code&gt; 和 &lt;code&gt;`&lt;/code&gt; 和 &lt;code&gt;&quot;&lt;/code&gt; 报价独自一人，在逐字模式，这样我就可以在一个工作程序等宽发出声音，在四个空格转向它，并把它打印出来，呃，一字不差。想必字体。</target>
        </trans-unit>
        <trans-unit id="e5ab1ae02bd72d53207c68855ddd39b0273ee3a8" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;code&gt;$!&lt;/code&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt; , which can be set by any system call, this means that the value of the exit code used by &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="translated">目的是将有关可能原因的尽可能多的信息压缩到系统出口代码的有限空间中。但是，作为 &lt;code&gt;$!&lt;/code&gt; 是C的 &lt;code&gt;errno&lt;/code&gt; 的值，可以通过任何系统调用来设置，这意味着 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 所使用的退出代码的值可能是不可预测的，因此除了不可为零以外，不应依赖于此。</target>
        </trans-unit>
        <trans-unit id="0547c3f088cded7d6e36027ba3384ed9126a4a35" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;code&gt;$!&lt;/code&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt; , which can be set by any system call, this means that the value of the exit code used by &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="translated">目的是将有关可能原因的尽可能多的信息压缩到系统出口代码的有限空间中。但是，作为 &lt;code&gt;$!&lt;/code&gt; 是C的 &lt;code&gt;errno&lt;/code&gt; 的值，可以通过任何系统调用来设置，这意味着 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 所使用的退出代码的值可能是不可预测的，因此除了不可为零以外，不应依赖于此。</target>
        </trans-unit>
        <trans-unit id="2e91002a8407b92abe1904ddf5c320e2e26254c0" translate="yes" xml:space="preserve">
          <source>The interaction with the Perl compilation happens inside package &lt;code&gt;myint&lt;/code&gt; :</source>
          <target state="translated">与Perl编译的交互发生在包 &lt;code&gt;myint&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="aa4116edd722cc9f90eb68f17a977fcbd1367d5c" translate="yes" xml:space="preserve">
          <source>The interactive debugger understands the following commands:</source>
          <target state="translated">交互式调试器能理解以下命令。</target>
        </trans-unit>
        <trans-unit id="e70d776f0381bce09991021b76dd2d122db7ce29" translate="yes" xml:space="preserve">
          <source>The interesting thing about &lt;code&gt;&amp;amp;&lt;/code&gt; is that you can generate new syntax with it, provided it's in the initial position:</source>
          <target state="translated">关于 &lt;code&gt;&amp;amp;&lt;/code&gt; 的有趣之处在于，只要它处于初始位置，就可以使用它生成新的语法：</target>
        </trans-unit>
        <trans-unit id="2354b426f3be078a3ef57dbce0f8523b4f89323f" translate="yes" xml:space="preserve">
          <source>The interface defined by this module is missing some of the later additions to perl's debugging functionality. As such, this interface should be considered highly experimental and subject to change.</source>
          <target state="translated">这个模块所定义的接口缺少一些后来添加到perl的调试功能。因此,这个接口应该被认为是高度实验性的,并且可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="6bc76db195856b77ae9c9e32f58ddf5271ff9965" translate="yes" xml:space="preserve">
          <source>The interface exposed by this module is very close to the current implementation of restricted hashes. Over time it is expected that this behavior will be extended and the interface abstracted further.</source>
          <target state="translated">这个模块所暴露的接口非常接近当前限制性哈希的实现。随着时间的推移,预计这种行为将得到扩展,接口将进一步抽象化。</target>
        </trans-unit>
        <trans-unit id="25ed6271fa2a1e00048e3f70c7ae05b81e869ba4" translate="yes" xml:space="preserve">
          <source>The interface is a bit odd because this is the result of a quick refactoring. Don't rely on it.</source>
          <target state="translated">界面有点奇怪,因为这是快速重构的结果。不要依赖它。</target>
        </trans-unit>
        <trans-unit id="86fb605133e4937943b1ba063015c9eb55c6a1c4" translate="yes" xml:space="preserve">
          <source>The interface provided by version 2 of this module should be 100% backward compatible with version 1. If you find a difference in the expected behaviour please contact the author (See &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt;). See &lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;GZIP INTERFACE&lt;/a&gt;</source>
          <target state="translated">此模块的版本2提供的接口应与版本1 100％向后兼容。如果发现预期的行为有所不同，请与作者联系（请参阅&lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt;）。参见&lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;GZIP接口&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="869b0eb21cd8ea8a7cd6e0d3a06abffd6a4f3e9a" translate="yes" xml:space="preserve">
          <source>The interface provides two ways to calculate digests: all-at-once, or in stages. To illustrate, the following short program computes the SHA-256 digest of &quot;hello world&quot; using each approach:</source>
          <target state="translated">该接口提供了两种计算摘要的方法:一次全部计算,或者分阶段计算。为了说明这一点,下面的小程序使用两种方法计算 &quot;hello world &quot;的SHA-256摘要。</target>
        </trans-unit>
        <trans-unit id="8dedf705c01e5c3576fd3717e147541ecb372f63" translate="yes" xml:space="preserve">
          <source>The internal advisory locking is implemented using Perl's flock() routine. If your system does not support any form of flock(), or if you share your files across NFS, you might wish to use other forms of locking by using modules such as LockFile::Simple which lock a file using a filesystem entry, instead of locking the file descriptor.</source>
          <target state="translated">内部咨询锁定是通过Perl的flock()例程实现的。如果你的系统不支持任何形式的flock(),或者你在NFS上共享你的文件,你可能希望使用其他形式的锁定,使用诸如LockFile::Simple这样的模块来锁定文件,而不是锁定文件描述符。</target>
        </trans-unit>
        <trans-unit id="798a90f8fceb3237e533c15e8087d7887afcfeb7" translate="yes" xml:space="preserve">
          <source>The internal variable for debugging support. The meanings of the various bits are subject to change, but currently indicate:</source>
          <target state="translated">内部变量,用于支持调试。各位的含义可能会改变,但目前表示:</target>
        </trans-unit>
        <trans-unit id="85c386c4c074fc2a85f669eb89082305e3dd4f12" translate="yes" xml:space="preserve">
          <source>The internals automatically clone any name with characters 128-255 but none 256+ (ie one that could be either in bytes or utf8) into a second entry which is utf8 encoded.</source>
          <target state="translated">内部程序会自动克隆任何有128-255字符但没有256+字符的名字(即可以是字节或utf8的名字)到第二条utf8编码的条目中。</target>
        </trans-unit>
        <trans-unit id="68038f581434d0080618601485190514733606bb" translate="yes" xml:space="preserve">
          <source>The interpretation of operations and values in Perl sometimes depends on the requirements of the context around the operation or value. There are two major contexts: list and scalar. Certain operations return list values in contexts wanting a list, and scalar values otherwise. If this is true of an operation it will be mentioned in the documentation for that operation. In other words, Perl overloads certain operations based on whether the expected return value is singular or plural. Some words in English work this way, like &quot;fish&quot; and &quot;sheep&quot;.</source>
          <target state="translated">在Perl中,对操作和值的解释有时取决于操作或值周围的上下文的要求。有两种主要的上下文:list 和 scalar。某些操作在需要列表的上下文中返回列表值,否则返回标量值。如果一个操作是如此,它将在该操作的文档中提到。换句话说,Perl会根据预期返回值是单数还是复数来重载某些操作。英语中的一些单词就是这样工作的,比如 &quot;fish &quot;和 &quot;sheep&quot;。</target>
        </trans-unit>
        <trans-unit id="061664239d0f872c4965463ddd59f598a09d06f0" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="translated">默认情况下，仅基于文件的模式以及用户的uid和gid来解释文件权限运算符 &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-R&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; ， &lt;code&gt;-W&lt;/code&gt; ， &lt;code&gt;-x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 。可能还有其他原因导致您无法实际读取，写入或执行文件：例如，网络文件系统访问控制，ACL（访问控制列表），只读文件系统和无法识别的可执行格式。请注意，使用这六个特定的运算符来验证是否可以进行某些操作通常是一个错误，因为它可能会出现竞争状况。</target>
        </trans-unit>
        <trans-unit id="de2595dbfaf95d22e9019632865663f297c76092" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="translated">默认情况下，仅基于文件的模式以及用户的uid和gid来解释文件权限运算符 &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-R&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; ， &lt;code&gt;-W&lt;/code&gt; ， &lt;code&gt;-x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 。可能还有其他原因导致您无法实际读取，写入或执行文件：例如，网络文件系统访问控制，ACL（访问控制列表），只读文件系统和无法识别的可执行格式。请注意，使用这六个特定的运算符来验证是否可以进行某些操作通常是一个错误，因为它可能会出现竞争状况。</target>
        </trans-unit>
        <trans-unit id="c54a39a0dd2a9db45fcc8606c6b9dc540f8d071d" translate="yes" xml:space="preserve">
          <source>The inverse operation - packing byte contents from a string of hexadecimal digits - is just as easily written. For instance:</source>
          <target state="translated">反向操作--从一串十六进制数字中打包字节内容--也很容易写出来。例如</target>
        </trans-unit>
        <trans-unit id="8aacdda2a613fe684f7ff0ec49be15c7f7bad342" translate="yes" xml:space="preserve">
          <source>The is the number of bytes that the Storable header occupies.</source>
          <target state="translated">是指Storable头占用的字节数。</target>
        </trans-unit>
        <trans-unit id="e08f7fe6dcc4a4ede748bb6d3fcab7c9e89b331c" translate="yes" xml:space="preserve">
          <source>The issue of whether to pass the arguments in a hash or a hashref is largely a matter of personal style.</source>
          <target state="translated">在哈希中传递参数还是哈希夫中传递参数的问题,主要是个人风格的问题。</target>
        </trans-unit>
        <trans-unit id="1270f1d87441c40c65f184813fb9549f6a05140e" translate="yes" xml:space="preserve">
          <source>The item you want to look up. Nested modules (such as &lt;code&gt;File::Basename&lt;/code&gt; ) are specified either as &lt;code&gt;File::Basename&lt;/code&gt; or &lt;code&gt;File/Basename&lt;/code&gt; . You may also give a descriptive name of a page, such as &lt;code&gt;perlfunc&lt;/code&gt; . For URLs, HTTP and HTTPS are the only kind currently supported.</source>
          <target state="translated">您要查找的项目。嵌套模块（例如 &lt;code&gt;File::Basename&lt;/code&gt; ）被指定为 &lt;code&gt;File::Basename&lt;/code&gt; 或 &lt;code&gt;File/Basename&lt;/code&gt; 。您还可以提供页面的描述性名称，例如 &lt;code&gt;perlfunc&lt;/code&gt; 。对于URL，HTTP和HTTPS是当前唯一支持的类型。</target>
        </trans-unit>
        <trans-unit id="b950b023ee8eee0b58c44c704206373f4189c22c" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;&quot;~~&quot;&lt;/code&gt; allows you to override the smart matching logic used by the &lt;code&gt;~~&lt;/code&gt; operator and the switch construct (&lt;code&gt;given&lt;/code&gt; /&lt;code&gt;when&lt;/code&gt; ). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; and &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">键 &lt;code&gt;&quot;~~&quot;&lt;/code&gt; 使您可以覆盖 &lt;code&gt;~~&lt;/code&gt; 运算符和switch构造（ &lt;code&gt;given&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; ）使用的智能匹配逻辑。请参见&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsyn&lt;/a&gt;和&lt;a href=&quot;feature&quot;&gt;feature中的&lt;/a&gt;Switch语句。</target>
        </trans-unit>
        <trans-unit id="c40c6befa9e830eefbf95715d61be0cceba411db" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;'-X'&lt;/code&gt; is used to specify a subroutine to handle all the filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on: see &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt; for the full list); it is not possible to overload any filetest operator individually. To distinguish them, the letter following the '-' is passed as the second argument (that is, in the slot that for binary operators is used to pass the second operand).</source>
          <target state="translated">键 &lt;code&gt;'-X'&lt;/code&gt; 用于指定一个子例程来处理所有文件测试运算符（ &lt;code&gt;-f&lt;/code&gt; ， &lt;code&gt;-x&lt;/code&gt; 等：完整列表请参见&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;）；不可能单独重载任何filetest运算符。为了区别它们，将&amp;ldquo;-&amp;rdquo;后的字母作为第二个参数传递（即在用于二进制运算符的插槽中传递第二个操作数）。</target>
        </trans-unit>
        <trans-unit id="8e57e8aa67b22950a3905dc0aca0c46d976bdaa4" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;key&lt;/code&gt; of &lt;code&gt;hv&lt;/code&gt; is deleted at the end of</source>
          <target state="translated">关键的 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;hv&lt;/code&gt; 在结束时被删除</target>
        </trans-unit>
        <trans-unit id="39231120b3a0f9f7321946d1dcf4e67b7cbb06d0" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;neg&lt;/code&gt; is used for unary minus to disambiguate it from binary &lt;code&gt;-&lt;/code&gt; .</source>
          <target state="translated">关键字 &lt;code&gt;neg&lt;/code&gt; 用于一元减号，以使其与二进制 &lt;code&gt;-&lt;/code&gt; 消除歧义。</target>
        </trans-unit>
        <trans-unit id="9af0ef3d95080a656a5a0ae273ae380c9667ee38" translate="yes" xml:space="preserve">
          <source>The key function is</source>
          <target state="translated">关键功能是</target>
        </trans-unit>
        <trans-unit id="890e53c79df507f41db3dd4d31cb915a4367afdd" translate="yes" xml:space="preserve">
          <source>The key here is the &lt;code&gt;nss_delete&lt;/code&gt; call. One workaround for this bug seems to be to create add to the file</source>
          <target state="translated">此处的关键是 &lt;code&gt;nss_delete&lt;/code&gt; 调用。解决该错误的一种方法是在文件中创建添加</target>
        </trans-unit>
        <trans-unit id="f07d5f582b98b9cdfa2323f91d8c44e6ee01e73a" translate="yes" xml:space="preserve">
          <source>The key is specified by</source>
          <target state="translated">钥匙由</target>
        </trans-unit>
        <trans-unit id="7a4574cc32e125230b635f70eb51279af8024135" translate="yes" xml:space="preserve">
          <source>The keys allowed in each of these pre-defined references is limited to the names used in the equivalent C structure. So, for example, the $DB_HASH reference will only allow keys called &lt;code&gt;bsize&lt;/code&gt; , &lt;code&gt;cachesize&lt;/code&gt; , &lt;code&gt;ffactor&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;lorder&lt;/code&gt; and &lt;code&gt;nelem&lt;/code&gt; .</source>
          <target state="translated">这些预定义引用中的每个允许的键都限于等效C结构中使用的名称。因此，例如，在$ DB_HASH参考将只允许钥匙叫 &lt;code&gt;bsize&lt;/code&gt; ， &lt;code&gt;cachesize&lt;/code&gt; ， &lt;code&gt;ffactor&lt;/code&gt; ， &lt;code&gt;hash&lt;/code&gt; ， &lt;code&gt;lorder&lt;/code&gt; 和 &lt;code&gt;nelem&lt;/code&gt; 个。</target>
        </trans-unit>
        <trans-unit id="d6ed2e67811ac5de5639075023acf0cc2ec381bf" translate="yes" xml:space="preserve">
          <source>The keys in the bottom layer hash with the meanings of their values are:</source>
          <target state="translated">底层哈希中的键及其值的含义是。</target>
        </trans-unit>
        <trans-unit id="7d244bc64e243794d6821e1a0dcab4a24a9f05ad" translate="yes" xml:space="preserve">
          <source>The keys in the hash with the meanings of their values are:</source>
          <target state="translated">哈希中的键及其值的含义是:</target>
        </trans-unit>
        <trans-unit id="b936421bf8217d2a23b78502c20a19e381f28f92" translate="yes" xml:space="preserve">
          <source>The keys of &lt;code&gt;%-&lt;/code&gt; -like hashes correspond to all buffer names found in the regular expression; the keys of &lt;code&gt;%+&lt;/code&gt; -like hashes list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="translated">类似 &lt;code&gt;%-&lt;/code&gt; 的哈希键对应于在正则表达式中找到的所有缓冲区名称。类似于 &lt;code&gt;%+&lt;/code&gt; 的哈希键仅列出已捕获（并因此与定义的值相关联）的缓冲区的名称。</target>
        </trans-unit>
        <trans-unit id="108fc2066c755818e3590f4d9c35e36d3cb855db" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;%+&lt;/code&gt; hash list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; 哈希的键仅列出已捕获（并因此与定义的值相关联）的缓冲区的名称。</target>
        </trans-unit>
        <trans-unit id="c4094ef8d037d1a4f33eb2e2deddaec00fa1265e" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;%-&lt;/code&gt; hash correspond to all buffer names found in the regular expression.</source>
          <target state="translated">&lt;code&gt;%-&lt;/code&gt; -hash 的键对应于在正则表达式中找到的所有缓冲区名称。</target>
        </trans-unit>
        <trans-unit id="cfdae1829d96426970bd25497a8e45b42e9a79f4" translate="yes" xml:space="preserve">
          <source>The keys of the hash will be the names of the entries in the directory. Reading a value from the hash will be the result of calling &lt;code&gt;File::stat::lstat&lt;/code&gt; . Deleting an element from the hash will delete the corresponding file or subdirectory, provided that &lt;code&gt;DIR_UNLINK&lt;/code&gt; is included in the &lt;code&gt;OPTIONS&lt;/code&gt; .</source>
          <target state="translated">哈希键将是目录中条目的名称。从哈希读取值将是调用 &lt;code&gt;File::stat::lstat&lt;/code&gt; 。如果在 &lt;code&gt;OPTIONS&lt;/code&gt; 中包含 &lt;code&gt;DIR_UNLINK&lt;/code&gt; ，则从哈希中删除元素将删除相应的文件或子目录。</target>
        </trans-unit>
        <trans-unit id="055987f11411d4374756daa33a787f39e5c8e2e5" translate="yes" xml:space="preserve">
          <source>The keys of this hash are the names of all the known subroutines. Each value is an encoded string that has the sprintf(3) format &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt; .</source>
          <target state="translated">该哈希的关键字是所有已知子例程的名称。每个值都是具有sprintf（3）格式的编码字符串 &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3904530800da7eda131d2f33bddbe47a09140ae0" translate="yes" xml:space="preserve">
          <source>The kind of computer you&amp;rsquo;re working on, where one &amp;ldquo;kind of computer&amp;rdquo; means all those computers sharing a compatible machine language. Since Perl programs are (typically) simple text files, not executable images, a Perl program is much less sensitive to the architecture it&amp;rsquo;s running on than programs in other languages, such as C, that are &lt;b&gt;compiled&lt;/b&gt; into machine code. See also &lt;b&gt;platform&lt;/b&gt; and &lt;b&gt;operating system&lt;/b&gt;.</source>
          <target state="translated">您正在使用的计算机类型，其中&amp;ldquo;一种计算机&amp;rdquo;表示所有共享相同机器语言的计算机。由于Perl程序（通​​常）是简单的文本文件，而不是可执行图像，因此，Perl程序对其运行的体系结构的敏感性要比其他语言（如C）&lt;b&gt;编译&lt;/b&gt;为机器代码的程序低。另请参阅&lt;b&gt;平台&lt;/b&gt;和&lt;b&gt;操作系统&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="af5d08a24c9445659f44e97ac90d397b8dd843c2" translate="yes" xml:space="preserve">
          <source>The known import symbols are the &lt;code&gt;:gzip_external&lt;/code&gt; , &lt;code&gt;:gzip_read_open&lt;/code&gt; , and &lt;code&gt;:gzip_write_open&lt;/code&gt; . Anything else is not recognized.</source>
          <target state="translated">已知的导入符号是 &lt;code&gt;:gzip_external&lt;/code&gt; ， &lt;code&gt;:gzip_read_open&lt;/code&gt; 和 &lt;code&gt;:gzip_write_open&lt;/code&gt; 。其他没有被识别。</target>
        </trans-unit>
        <trans-unit id="9ad665994ad3405e05efc579c556de49d4423595" translate="yes" xml:space="preserve">
          <source>The label of the statement or block the OP is the start of, if any.</source>
          <target state="translated">如果有的话,上位机是声明或块的标签。</target>
        </trans-unit>
        <trans-unit id="147bc8ea909cecad4fb730859bb2907f9623910d" translate="yes" xml:space="preserve">
          <source>The lack of processing of &lt;code&gt;\\&lt;/code&gt; creates specific restrictions on the post-processed text. If the delimiter is &lt;code&gt;/&lt;/code&gt;, one cannot get the combination &lt;code&gt;\/&lt;/code&gt; into the result of this step. &lt;code&gt;/&lt;/code&gt; will finish the regular expression, &lt;code&gt;\/&lt;/code&gt; will be stripped to &lt;code&gt;/&lt;/code&gt; on the previous step, and &lt;code&gt;\\/&lt;/code&gt; will be left as is. Because &lt;code&gt;/&lt;/code&gt; is equivalent to &lt;code&gt;\/&lt;/code&gt; inside a regular expression, this does not matter unless the delimiter happens to be character special to the RE engine, such as in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s*foo*bar*&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m[foo]&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;?foo?&lt;/code&gt; ; or an alphanumeric char, as in:</source>
          <target state="translated">缺少对 &lt;code&gt;\\&lt;/code&gt; 的处理会对后处理的文本产生特定的限制。如果定界符为 &lt;code&gt;/&lt;/code&gt; ，则无法将组合 &lt;code&gt;\/&lt;/code&gt; 放入此步骤的结果中。 &lt;code&gt;/&lt;/code&gt; 将完成正则表达式， &lt;code&gt;\/&lt;/code&gt; 将在上一步中剥离到 &lt;code&gt;/&lt;/code&gt; ，而 &lt;code&gt;\\/&lt;/code&gt; 将保持不变。因为 &lt;code&gt;/&lt;/code&gt; 等价于正则表达式内的 &lt;code&gt;\/&lt;/code&gt; ，所以这无关紧要，除非分隔符恰好是RE引擎专用的字符，例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s*foo*bar*&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m[foo]&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;?foo?&lt;/code&gt; 。 ;或字母数字字符，例如：</target>
        </trans-unit>
        <trans-unit id="329bfa336d3d2c69ff7cf1363d051c82b14482d1" translate="yes" xml:space="preserve">
          <source>The langinfo() function queries various locale information that can be used to localize output and user interfaces. The langinfo() requires one numeric argument that identifies the locale constant to query: if no argument is supplied, &lt;code&gt;$_&lt;/code&gt; is used. The numeric constants appropriate to be used as arguments are exportable from I18N::Langinfo.</source>
          <target state="translated">langinfo（）函数查询各种可用于本地化输出和用户界面的语言环境信息。 langinfo（）需要一个数字参数来标识要查询的语言环境常量：如果未提供任何参数，则使用 &lt;code&gt;$_&lt;/code&gt; 。可从I18N :: Langinfo导出适合用作参数的数字常量。</target>
        </trans-unit>
        <trans-unit id="4ed86afb0e8b9f19c52713fc505ca8e2e35f2532" translate="yes" xml:space="preserve">
          <source>The langinfo() is just a wrapper for the C nl_langinfo() interface.</source>
          <target state="translated">langinfo()只是C语言nl_langinfo()接口的一个包装器。</target>
        </trans-unit>
        <trans-unit id="5d6f822e607c368c541adb8e9be9fa017016c7dd" translate="yes" xml:space="preserve">
          <source>The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal). It combines (in the author's opinion, anyway) some of the best features of &lt;b&gt;sed&lt;/b&gt;, &lt;b&gt;awk&lt;/b&gt;, and &lt;b&gt;sh&lt;/b&gt;, making it familiar and easy to use for Unix users to whip up quick solutions to annoying problems. Its general-purpose programming facilities support procedural, functional, and object-oriented programming paradigms, making Perl a comfortable language for the long haul on major projects, whatever your bent.</source>
          <target state="translated">该语言旨在实用（易于使用，高效，完整），而不是美观（小巧，优雅，简约）。它结合了（无论如何，以作者的观点）&lt;b&gt;sed&lt;/b&gt;，&lt;b&gt;awk&lt;/b&gt;和&lt;b&gt;sh的&lt;/b&gt;一些最佳功能，从而使Unix用户熟悉并易于使用，以快速解决烦人的问题。它的通用编程工具支持过程，函数和面向对象的编程范例，这使Perl成为长期从事大型项目的舒适语言，无论您喜欢什么。</target>
        </trans-unit>
        <trans-unit id="80a9351ce80597f624479310f1723e625f630d11" translate="yes" xml:space="preserve">
          <source>The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal). Its major features are that it's easy to use, supports both procedural and object-oriented (OO) programming, has powerful built-in support for text processing, and has one of the world's most impressive collections of third-party modules.</source>
          <target state="translated">该语言的目的是实用(易用、高效、完整)而不是美观(微小、优雅、简约)。它的主要特点是使用方便,支持程序化和面向对象(OO)编程,对文本处理有强大的内置支持,并拥有世界上最令人印象深刻的第三方模块集合之一。</target>
        </trans-unit>
        <trans-unit id="80efcc67009b4f458fbcd0e166207fe80337c34a" translate="yes" xml:space="preserve">
          <source>The language used is chosen from the loc_lang call. If a lookup is not possible, the i-default language will be used. If the lookup is not in the i-default language, then the key will be returned.</source>
          <target state="translated">所使用的语言是从 loc_lang 调用中选择的。如果无法进行查找,则使用i-default语言。如果查询的语言不是i-default语言,那么将返回密钥。</target>
        </trans-unit>
        <trans-unit id="fba6e11da7ba55d0215680ecc246683e4db3e510" translate="yes" xml:space="preserve">
          <source>The large file compilation environment is obtained with</source>
          <target state="translated">大文件编译环境是通过</target>
        </trans-unit>
        <trans-unit id="7c14ad6f7057f3647ab0ef224e2d72569a519808" translate="yes" xml:space="preserve">
          <source>The largest code point that is representable in UTF-EBCDIC is U+7FFF_FFFF. If you do &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; on a larger value, a runtime error (similar to division by 0) will happen.</source>
          <target state="translated">UTF-EBCDIC中可表示的最大代码点是U + 7FFF_FFFF。如果对较大的值执行 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; ，则会发生运行时错误（类似于除以0）。</target>
        </trans-unit>
        <trans-unit id="81c48ef57866e1c8154c2bdc64ad152dcbc81938" translate="yes" xml:space="preserve">
          <source>The largest code point that is representable in UTF-EBCDIC is U+7FFF_FFFF. If you try to pack a larger value into a character, a runtime error (similar to division by 0) will happen.</source>
          <target state="translated">UTF-EBCDIC中最大的代码点是U+7FFF_FFFF。如果你试图在一个字符中加入一个更大的值,就会发生一个运行时错误(类似于除以0)。</target>
        </trans-unit>
        <trans-unit id="e2cfb7719205bc05d873fbbc8977b16754d06f9e" translate="yes" xml:space="preserve">
          <source>The last &lt;b&gt;filehandle&lt;/b&gt; that was designated with &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select(FILEHANDLE)&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;STDOUT&lt;/code&gt; , if no filehandle has been selected.</source>
          <target state="translated">用 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select(FILEHANDLE)&lt;/a&gt;&lt;/code&gt; 指定的最后一个&lt;b&gt;文件句柄&lt;/b&gt;； &lt;code&gt;STDOUT&lt;/code&gt; ，如果尚未选择文件句柄。</target>
        </trans-unit>
        <trans-unit id="544feb1340389177d3430ba94574fe7a8a59484b" translate="yes" xml:space="preserve">
          <source>The last argument is always considered to be the file portion. Since &lt;code&gt;catfile()&lt;/code&gt; uses &lt;code&gt;catdir()&lt;/code&gt; (see above) for the concatenation of the directory portions (if any), the following with regard to relative and absolute paths is true:</source>
          <target state="translated">最后一个参数始终被认为是文件部分。由于 &lt;code&gt;catfile()&lt;/code&gt; 使用 &lt;code&gt;catdir()&lt;/code&gt; （请参见上文）来串联目录部分（如果有），因此以下有关相对路径和绝对路径的设置为true：</target>
        </trans-unit>
        <trans-unit id="3d5ec4d10744144f22c4f4ea812b28436c8dedd9" translate="yes" xml:space="preserve">
          <source>The last example illustrates another feature of threads. You can spawn off several threads using the same subroutine. Each thread executes the same subroutine, but in a separate thread with a separate environment and potentially separate arguments.</source>
          <target state="translated">最后一个例子说明了线程的另一个特性。你可以使用同一个子程序衍生出多个线程。每个线程都执行同一个子程序,但在一个单独的线程中,有单独的环境和可能的单独参数。</target>
        </trans-unit>
        <trans-unit id="3a9ec3805e1d8d03ada9f35c7b038f53ba566eb8" translate="yes" xml:space="preserve">
          <source>The last example is very slow and outputs extra progress indicators that break the alignment of the result.</source>
          <target state="translated">最后一个例子非常慢,而且输出额外的进度指标,打破了结果的排列。</target>
        </trans-unit>
        <trans-unit id="d7140144abdabb3a340f6e7a9626f45a3f6e90a9" translate="yes" xml:space="preserve">
          <source>The last example points out that character classes are like alternations of characters. At a given character position, the first alternative that allows the regexp match to succeed will be the one that matches.</source>
          <target state="translated">最后一个例子指出,字符类就像字符的交替。在一个给定的字符位置,第一个让regexp匹配成功的备选方案将是匹配的。</target>
        </trans-unit>
        <trans-unit id="8ff092050a74224fa6cfcc69192829226bfd39ef" translate="yes" xml:space="preserve">
          <source>The last example should print:</source>
          <target state="translated">最后一个例子应该是打印的。</target>
        </trans-unit>
        <trans-unit id="d1b1f35817845b0ebf71ac4a0203b5b76bf2839d" translate="yes" xml:space="preserve">
          <source>The last example shows a match with an &lt;code&gt;'i'&lt;/code&gt;&lt;b&gt;modifier&lt;/b&gt;, which makes the match case-insensitive.</source>
          <target state="translated">最后一个示例显示了带有 &lt;code&gt;'i'&lt;/code&gt; &lt;b&gt;修饰符&lt;/b&gt;的匹配项，该匹配项不区分大小写。</target>
        </trans-unit>
        <trans-unit id="e71d02e5faff1a1d5185411ef0df70f32d8f6d20" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regex and replacement are treated as single-quoted strings.</source>
          <target state="translated">最后一个示例显示 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 可以使用其他定界符，例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; ，甚至 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; 。如果使用单引号 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; ，则将正则表达式和替换项视为单引号字符串。</target>
        </trans-unit>
        <trans-unit id="38175234fbd8da1fcb9cc33577b554c9cf1a8cdf" translate="yes" xml:space="preserve">
          <source>The last four modifiers listed above, added in Perl 5.14, control the character set rules, but &lt;code&gt;/a&lt;/code&gt; is the only one you are likely to want to specify explicitly; the other three are selected automatically by various pragmas.</source>
          <target state="translated">上面列出的最后四个修饰符是在Perl 5.14中添加的，它们控制字符集规则，但是 &lt;code&gt;/a&lt;/code&gt; 是您可能希望明确指定的唯一修饰符；其他三个则由各种实用程序自动选择。</target>
        </trans-unit>
        <trans-unit id="5b14495e6536f39321b81d2ad45a9b35a4c183b7" translate="yes" xml:space="preserve">
          <source>The last is particularly useful because it knows about machine-dependent architectures. The &lt;code&gt;lib.pm&lt;/code&gt; pragmatic module was first included with the 5.002 release of Perl.</source>
          <target state="translated">最后一个特别有用，因为它了解与机器有关的体系结构。该 &lt;code&gt;lib.pm&lt;/code&gt; 务实模块首次被列入与5.002版本的Perl。</target>
        </trans-unit>
        <trans-unit id="dee33a8bbee7fed8c390da45a40b2881511f80ec" translate="yes" xml:space="preserve">
          <source>The last item listed (SUNWhea in this example) is the package you need.</source>
          <target state="translated">最后一项(本例中的SUNWhea)是你需要的包。</target>
        </trans-unit>
        <trans-unit id="01f01afddbe80c4c268f0bac95652fd735743f86" translate="yes" xml:space="preserve">
          <source>The last rites performed by a parent &lt;b&gt;process&lt;/b&gt; on behalf of a deceased child process so that it doesn&amp;rsquo;t remain a &lt;b&gt;zombie&lt;/b&gt;. See the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; function calls.</source>
          <target state="translated">父&lt;b&gt;进程&lt;/b&gt;代表死者的子进程进行的最后一次仪式，这样它不会成为&lt;b&gt;僵尸&lt;/b&gt;。请参见 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 函数调用。</target>
        </trans-unit>
        <trans-unit id="6fc5a9dc56cbe77d2375a5e43361dd33676d7edc" translate="yes" xml:space="preserve">
          <source>The last three slots are a recent addition, and for source code compatibility they are only checked for if one of the three flags MGf_COPY, MGf_DUP or MGf_LOCAL is set in mg_flags. This means that most code can continue declaring a vtable as a 5-element value. These three are currently used exclusively by the threading code, and are highly subject to change.</source>
          <target state="translated">最后三个槽是最近增加的,为了保证源代码的兼容性,只有在mg_flags中设置了MGf、MGf_DUP或MGf_LOCAL三个标志之一时,才会对它们进行检查。这意味着大多数代码可以继续将一个vtable声明为一个5元素值。这三个标志目前只由线程代码使用,极有可能发生变化。</target>
        </trans-unit>
        <trans-unit id="0f2130944a7df2b125d5d6b5739b2f67242c3907" translate="yes" xml:space="preserve">
          <source>The last time the test program passed, in seconds from the epoch.</source>
          <target state="translated">测试程序最后一次通过的时间,从时间点算起,以秒为单位。</target>
        </trans-unit>
        <trans-unit id="21878c9b3f2934bab56f2ab1ab4a5f355bfffef3" translate="yes" xml:space="preserve">
          <source>The last time the test suite failed, in seconds from the epoch.</source>
          <target state="translated">测试套件最后一次失败的时间,从时间点算起,以秒为单位。</target>
        </trans-unit>
        <trans-unit id="c8d2323b355b183370e8260c625d724458199602" translate="yes" xml:space="preserve">
          <source>The last topic of Part 1 briefly covers how regexps are used in Perl programs. Where do they fit into Perl syntax?</source>
          <target state="translated">第1部分的最后一个主题简要介绍了如何在Perl程序中使用regexps。它们在Perl语法中的地位如何?</target>
        </trans-unit>
        <trans-unit id="b9c1bf499a546862f7d3dd462a65d36e8e01021a" translate="yes" xml:space="preserve">
          <source>The last two are a little tricky. In &lt;code&gt;[\$x]&lt;/code&gt; , the backslash protects the dollar sign, so the character class has two members &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; . In &lt;code&gt;[\\$x]&lt;/code&gt; , the backslash is protected, so &lt;code&gt;$x&lt;/code&gt; is treated as a variable and substituted in double quote fashion.</source>
          <target state="translated">最后两个有点棘手。在 &lt;code&gt;[\$x]&lt;/code&gt; ，反斜杠保护美元符号，因此字符类具有两个成员 &lt;code&gt;$&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 。在 &lt;code&gt;[\\$x]&lt;/code&gt; ，反斜杠受保护，因此 &lt;code&gt;$x&lt;/code&gt; 被视为变量并以双引号形式替换。</target>
        </trans-unit>
        <trans-unit id="8a00c9f7ecacbf4d6fa87dfc5eecfd61397b17fd" translate="yes" xml:space="preserve">
          <source>The last two constructs may appear unintuitive to most people. The first repeatedly grows a string, whereas the second allocates a large chunk of memory in one go. On some systems, the second is more efficient than the first.</source>
          <target state="translated">最后两个结构对大多数人来说可能显得不直观。第一个结构是重复增长一个字符串,而第二个结构是一次性分配一大块内存。在某些系统上,第二种比第一种更有效率。</target>
        </trans-unit>
        <trans-unit id="7a3180c758450e8b48f9775fac7e74a8e6da633b" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="translated">每个块中的最后两个示例将管道显示为&amp;ldquo;列表形式&amp;rdquo;，并非所有平台都支持该形式。一个好的经验法则是，如果您的平台上有一个真正的 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; （换句话说，如果您的平台是Unix，包括Linux和MacOS X），则可以使用列表形式。您可能希望使用管道的列表形式，以便您可以将文字参数传递给命令，而无需外壳解释其中的任何外壳元字符的风险。但是，这也使您无法从打开管道到故意包含外壳元字符的命令，例如：</target>
        </trans-unit>
        <trans-unit id="224277da0631dd2948d98eac0e58b508ae236071" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="translated">每个块中的最后两个示例将管道显示为&amp;ldquo;列表形式&amp;rdquo;，并非所有平台都支持该形式。一个好的经验法则是，如果您的平台上有一个真正的 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; （换句话说，如果您的平台是Unix，包括Linux和MacOS X），则可以使用列表形式。您可能希望使用管道的列表形式，以便您可以将文字参数传递给命令，而无需外壳解释其中的任何外壳元字符的风险。但是，这也使您无法从打开管道到故意包含外壳元字符的命令，例如：</target>
        </trans-unit>
        <trans-unit id="bb538ba5316dfdb33cebda21455c3214d556eb70" translate="yes" xml:space="preserve">
          <source>The last two were added in Perl 5.22.</source>
          <target state="translated">最后两个是在Perl 5.22中加入的。</target>
        </trans-unit>
        <trans-unit id="ea40dd6a00c5982372bccbdaaeeb63948e0cf1b4" translate="yes" xml:space="preserve">
          <source>The later gives you some idea of what failed. It also makes it easier to find the test in your script, simply search for &quot;simple exponential&quot;.</source>
          <target state="translated">后面的内容让你知道什么地方失败了。这也使你更容易在脚本中找到测试,只需搜索 &quot;简单指数&quot;。</target>
        </trans-unit>
        <trans-unit id="263e6dbf8c2da6cc4831ea57d73cd01c49808e34" translate="yes" xml:space="preserve">
          <source>The latest</source>
          <target state="translated">最新的</target>
        </trans-unit>
        <trans-unit id="d3a60275112428b3ca0987c2c55a45bca5bde073" translate="yes" xml:space="preserve">
          <source>The latest Net::Ping release can be found at CPAN:</source>
          <target state="translated">最新的Net::Ping版本可以在CPAN找到。</target>
        </trans-unit>
        <trans-unit id="874b36774125604150e5f59fd5253e7e8be8da9e" translate="yes" xml:space="preserve">
          <source>The latest Perl release (5.22.0 as of this writing) builds without changes under all versions of Mac OS X from 10.3 &quot;Panther&quot; onwards.</source>
          <target state="translated">最新的Perl版本(截至本文撰写时为5.22.0)在10.3 &quot;Panther &quot;以后的所有版本的Mac OS X上都能正常运行。</target>
        </trans-unit>
        <trans-unit id="abc4f25838809cd7645317e2cc9e7753babbc628" translate="yes" xml:space="preserve">
          <source>The latest source tree is available via cvs:</source>
          <target state="translated">最新的源码树可以通过cvs.com获取。</target>
        </trans-unit>
        <trans-unit id="bf89850a166f6a4ee0978de00ea5e89c74558d84" translate="yes" xml:space="preserve">
          <source>The latest versions are probably the least deployed and widely tested, so you may want to wait a few months after their release and see what problems others have if you are risk averse.</source>
          <target state="translated">最新的版本可能是部署最少、测试最广泛的版本,所以如果你想规避风险,不妨在其发布几个月后再看看别人有什么问题。</target>
        </trans-unit>
        <trans-unit id="283b07d7f4b68277645e0b52df897e2c505c20d3" translate="yes" xml:space="preserve">
          <source>The latest versions of perl have more bug fixes.</source>
          <target state="translated">最新版本的perl有更多的bug修复。</target>
        </trans-unit>
        <trans-unit id="d373e425dea350cf42b44329f2372765cae74bb5" translate="yes" xml:space="preserve">
          <source>The latter pattern would be a character class consisting of a colon, and the letters &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt; .</source>
          <target state="translated">后一种模式是由冒号和字母 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; ， &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;h&lt;/code&gt; 组成的字符类。</target>
        </trans-unit>
        <trans-unit id="6a94f6519fd2ea2b5da884bb4c80f8058226b090" translate="yes" xml:space="preserve">
          <source>The layer is acceptable to have in a binmode(FH) stack - i.e. it does not (or will configure itself not to) transform bytes passing through it.</source>
          <target state="translated">该层在binmode(FH)堆栈中是可以接受的--即它不会(或将自己配置为不会)转换通过它的字节。</target>
        </trans-unit>
        <trans-unit id="1281105f1d2923419cef70eff9c7bbaca9c31ca4" translate="yes" xml:space="preserve">
          <source>The layer is buffered.</source>
          <target state="translated">层的缓冲。</target>
        </trans-unit>
        <trans-unit id="d2977795d28c25d6eee9e0faa6c0a67b12612914" translate="yes" xml:space="preserve">
          <source>The layers are returned in the order an open() or binmode() call would use them. Note that the &quot;default stack&quot; depends on the operating system and on the Perl version, and both the compile-time and runtime configurations of Perl.</source>
          <target state="translated">这些层会按照open()或binmode()调用使用它们的顺序返回。请注意,&quot;默认堆栈 &quot;取决于操作系统和Perl版本,以及Perl的编译时和运行时配置。</target>
        </trans-unit>
        <trans-unit id="b3e7d5b78b27ea298f2a1cae1408ae86359ba800" translate="yes" xml:space="preserve">
          <source>The lddlflags addition is the only abnormal bit.</source>
          <target state="translated">lddlflags的添加是唯一的异常位。</target>
        </trans-unit>
        <trans-unit id="eff5a5e9eacb7b6806eb625ddd8923ff29d2efc5" translate="yes" xml:space="preserve">
          <source>The leading &lt;code&gt;+{&lt;/code&gt; and &lt;code&gt;{;&lt;/code&gt; always serve to disambiguate the expression to mean either the HASH reference, or the BLOCK.</source>
          <target state="translated">前导 &lt;code&gt;+{&lt;/code&gt; 和 &lt;code&gt;{;&lt;/code&gt; 始终用于消除表示HASH引用或BLOCK的歧义。</target>
        </trans-unit>
        <trans-unit id="d4369969cfc835357a0f9f590f26252ba7f58c0e" translate="yes" xml:space="preserve">
          <source>The left hand side of the method invocation (or arrow) operator is the object (or class name), and the right hand side is the method name.</source>
          <target state="translated">方法调用(或箭头)运算符的左边是对象(或类名),右边是方法名。</target>
        </trans-unit>
        <trans-unit id="2a9cac37843dad5a4ff70fbd9f8ea25d75266dcb" translate="yes" xml:space="preserve">
          <source>The left side of the arrow can be any expression returning a reference, including a previous dereference. Note that &lt;code&gt;$array[$x]&lt;/code&gt; is</source>
          <target state="translated">箭头的左侧可以是任何返回引用的表达式，包括先前的取消引用。注意， &lt;code&gt;$array[$x]&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="eb221cc92a9038eecac3c016886c94b3bdd80217" translate="yes" xml:space="preserve">
          <source>The left-hand character up there indicates the context in which the function was called, with &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; meaning scalar or list contexts respectively, and &lt;code&gt;.&lt;/code&gt; meaning void context (which is actually a sort of scalar context). The display above says that you were in the function &lt;code&gt;main::infested&lt;/code&gt; when you ran the stack dump, and that it was called in scalar context from line 10 of the file</source>
          <target state="translated">左边的字符表示调用该函数的上下文， &lt;code&gt;$&lt;/code&gt; 和 &lt;code&gt;@&lt;/code&gt; 分别表示标量或列表上下文，以及 &lt;code&gt;.&lt;/code&gt; 表示无效上下文（实际上是一种标量上下文）。上面的显示显示，当您运行堆栈转储时，您处于函数 &lt;code&gt;main::infested&lt;/code&gt; ，并且在文件第10行的标量上下文中对其进行了调用</target>
        </trans-unit>
        <trans-unit id="d8cc674eda9906f58ae8371f8d5de07f046d9b51" translate="yes" xml:space="preserve">
          <source>The leftmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;lt;&quot;).</source>
          <target state="translated">最左定界符从参数文本开始到内部序列（应为&amp;ldquo; &amp;lt;&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="b2f9e2e6c56a351b6a88108f75341c9d329b9f6c" translate="yes" xml:space="preserve">
          <source>The length at which the argument list is truncated is governed by the next option:</source>
          <target state="translated">参数列表被截断的长度由下一个选项决定。</target>
        </trans-unit>
        <trans-unit id="0c237bc1e8c7da08e4bc9cf58175d51b2735fd6c" translate="yes" xml:space="preserve">
          <source>The length of an array is a scalar value. You may find the length of array @days by evaluating &lt;code&gt;$#days&lt;/code&gt; , as in &lt;b&gt;csh&lt;/b&gt;. However, this isn't the length of the array; it's the subscript of the last element, which is a different value since there is ordinarily a 0th element. Assigning to &lt;code&gt;$#days&lt;/code&gt; actually changes the length of the array. Shortening an array this way destroys intervening values. Lengthening an array that was previously shortened does not recover values that were in those elements.</source>
          <target state="translated">数组的长度是标量值。您可以通过评估 &lt;code&gt;$#days&lt;/code&gt; 来找到@days数组的长度，如&lt;b&gt;csh所示&lt;/b&gt;。但是，这不是数组的长度。它是最后一个元素的下标，这是一个不同的值，因为通常有第0个元素。分配给 &lt;code&gt;$#days&lt;/code&gt; 实际上会更改数组的长度。用这种方法缩短数组会破坏中间值。延长以前缩短的数组不会恢复这些元素中的值。</target>
        </trans-unit>
        <trans-unit id="b1ef5c234e3b75bc352e3b032ce59b9fa1929612" translate="yes" xml:space="preserve">
          <source>The length of the field is supplied by padding out the field with multiple &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, or &quot;|&quot; characters to specify a non-numeric field with, respectively, left justification, right justification, or centering. For a regular field, the value (up to the first newline) is taken and printed according to the selected justification, truncating excess characters. If you terminate a text field with &quot;...&quot;, three dots will be shown if the value is truncated. A special text field may be used to do rudimentary multi-line text block filling; see &lt;a href=&quot;#Using-Fill-Mode&quot;&gt;Using Fill Mode&lt;/a&gt; for details.</source>
          <target state="translated">通过用多个&amp;ldquo; &amp;lt;&amp;rdquo;，&amp;ldquo;&amp;ldquo;&amp;gt;&amp;rdquo;或&amp;ldquo; |&amp;rdquo;填充字段来提供字段的长度字符以分别指定具有左对齐，右对齐或居中的非数字字段。对于常规字段，将根据选定的对齐方式获取并打印该值（直到第一个换行符），并截断多余的字符。如果用&amp;ldquo; ...&amp;rdquo;终止文本字段，则值被截断时将显示三个点。特殊的文本字段可用于进行基本的多行文本块填充；有关详细信息，请参见&lt;a href=&quot;#Using-Fill-Mode&quot;&gt;使用填充模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01b66a1a14f6dce4bff1a210ef4e586716a5899b" translate="yes" xml:space="preserve">
          <source>The length of the name.</source>
          <target state="translated">名的长度。</target>
        </trans-unit>
        <trans-unit id="696a9e70beeee9b566eace1cd87208a1d5c5089e" translate="yes" xml:space="preserve">
          <source>The length(NAME) Keyword</source>
          <target state="translated">长度(NAME)关键字</target>
        </trans-unit>
        <trans-unit id="b958bd03a02b517c3d184dfcfbefe403cc86c37f" translate="yes" xml:space="preserve">
          <source>The level can be changed as follows:</source>
          <target state="translated">可以按以下方式改变等级。</target>
        </trans-unit>
        <trans-unit id="64e6e89b4814ce7405192ddfc665d5e521c03538" translate="yes" xml:space="preserve">
          <source>The level constants are not exported by the module.</source>
          <target state="translated">级别常数不由模块导出。</target>
        </trans-unit>
        <trans-unit id="b4c1d901146534759d309f43fe1b8efda46ffa76" translate="yes" xml:space="preserve">
          <source>The level of detail in Perl module documentation generally goes from less detailed to more detailed. Your SYNOPSIS section should contain a minimal example of use (perhaps as little as one line of code; skip the unusual use cases or anything not needed by most users); the DESCRIPTION should describe your module in broad terms, generally in just a few paragraphs; more detail of the module's routines or methods, lengthy code examples, or other in-depth material should be given in subsequent sections.</source>
          <target state="translated">Perl 模块文档的详细程度一般是由少到多。你的 SYNOPSIS 部分应该包含一个最小的使用实例(可能只有一行代码,跳过不寻常的用例或任何大多数用户不需要的东西);DESCRIPTION 应该概括性地描述你的模块,一般只有几段;模块的例程或方法的更多细节、冗长的代码实例或其他深入的材料应该在后面的部分给出。</target>
        </trans-unit>
        <trans-unit id="0ce002d9483143d05cc2ba45ea1b81cd48bfc336" translate="yes" xml:space="preserve">
          <source>The lexer can be bypassed as well by creating the pattern from smaller components:</source>
          <target state="translated">通过从较小的组件创建模式,也可以绕过词典。</target>
        </trans-unit>
        <trans-unit id="23265d5a0661d902031b21a8d3925278347efe2b" translate="yes" xml:space="preserve">
          <source>The lexer maintains various &lt;code&gt;char*&lt;/code&gt; pointers to things in the &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; buffer. If &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; is ever reallocated, all of these pointers must be updated. Don't attempt to do this manually, but rather use &lt;a href=&quot;#lex_grow_linestr&quot;&gt;lex_grow_linestr&lt;/a&gt; if you need to reallocate the buffer.</source>
          <target state="translated">词法分析器在 &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; 缓冲区中维护指向各种对象的 &lt;code&gt;char*&lt;/code&gt; 指针。如果曾经重新分配 &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; ,则必须更新所有这些指针。不要尝试手动执行此操作，如果需要重新分配缓冲区，请使用&lt;a href=&quot;#lex_grow_linestr&quot;&gt;lex_grow_linestr&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ed189d83743aeda186a080785030258aac3dd09" translate="yes" xml:space="preserve">
          <source>The libnetcfg utility can be used to configure the libnet. Starting from perl 5.8 libnet is part of the standard Perl distribution, but the libnetcfg can be used for any libnet installation.</source>
          <target state="translated">libnetcfg 工具可以用来配置 libnet。从 perl 5.8 开始,libnet 是标准 Perl 发行版的一部分,但 libnetcfg 可以用于任何 libnet 安装。</target>
        </trans-unit>
        <trans-unit id="b7cb7266f690af0bb383573e50d303e552d377e1" translate="yes" xml:space="preserve">
          <source>The libraries specified may be a mixture of static libraries and import libraries (to link with DLLs). Since both kinds are used pretty transparently on the Win32 platform, we do not attempt to distinguish between them.</source>
          <target state="translated">指定的库可能是静态库和导入库的混合体(与DLLs链接)。由于这两种库在Win32平台上的使用非常透明,我们不打算区分它们。</target>
        </trans-unit>
        <trans-unit id="c99e76c717b720c6c49420484756d2dfcd410c40" translate="yes" xml:space="preserve">
          <source>The library that is loaded last will be used. Note that this can be overwritten at any time by loading a different library, and numbers constructed with different libraries cannot be used in math operations together.</source>
          <target state="translated">最后加载的库将被使用。需要注意的是,可以随时通过加载不同的库来覆盖这个库,而且用不同库构造的数不能一起用于数学运算。</target>
        </trans-unit>
        <trans-unit id="7be37c25dc5d34ce7bba6cfdf56923967183a419" translate="yes" xml:space="preserve">
          <source>The licensing terms of your distribution. Generally it's &quot;perl_5&quot; for the same license as Perl itself.</source>
          <target state="translated">你的发行版的许可条款。一般来说,它是 &quot;perl_5&quot;,与Perl本身的许可证相同。</target>
        </trans-unit>
        <trans-unit id="ee54e36e284ff26a979d2076f6ca4023c3d73825" translate="yes" xml:space="preserve">
          <source>The line above describes the limits of buckets currently in use. Each bucket has two sizes: memory footprint and the maximal size of user data that can fit into this bucket. Suppose in the above example that the smallest bucket were size 4. The biggest bucket would have usable size 8188, and the memory footprint would be 8192.</source>
          <target state="translated">上面一行描述了目前使用的桶的限制。每个bucket都有两个大小:内存占用和可以装入这个bucket的用户数据的最大大小。假设在上面的例子中,最小的bucket的大小是4。最大的bucket的可用大小为8188,内存占用为8192。</target>
        </trans-unit>
        <trans-unit id="ac97bcd51055b69e1b4470987fa154b899ce651a" translate="yes" xml:space="preserve">
          <source>The line number the error occurred in.</source>
          <target state="translated">发生错误的行号。</target>
        </trans-unit>
        <trans-unit id="cc23ac8e14569b4b19694084670492ce2aa4a0c6" translate="yes" xml:space="preserve">
          <source>The line shown is the one that is about to be executed &lt;b&gt;next&lt;/b&gt;, it hasn't happened yet. So while we can print a variable with the letter '&lt;b&gt;p&lt;/b&gt;', at this point all we'd get is an empty (undefined) value back. What we need to do is to step through the next executable statement with an '&lt;b&gt;s&lt;/b&gt;':</source>
          <target state="translated">所示的行是&lt;b&gt;下一步&lt;/b&gt;将要执行的行，尚未发生。因此，尽管我们可以打印带有字母&amp;ldquo; &lt;b&gt;p&lt;/b&gt; &amp;rdquo; 的变量，但此时我们得到的只是一个空（未定义）值。我们需要做的是通过下一个带有' &lt;b&gt;s&lt;/b&gt;的可执行语句：</target>
        </trans-unit>
        <trans-unit id="e54713c2cd710c76f4d69536879402921ef82d04" translate="yes" xml:space="preserve">
          <source>The linearized MRO of a class is an ordered array of all of the classes one would search when resolving a method on that class, starting with the class itself.</source>
          <target state="translated">一个类的线性化MRO是一个有序的数组,它包含了所有在该类上解析方法时要搜索的类,从该类本身开始。</target>
        </trans-unit>
        <trans-unit id="f96ce0004635ab8058e21a997ff0fdcac4680ebd" translate="yes" xml:space="preserve">
          <source>The link found cannot be parsed because it does not conform to the syntax described in &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">无法解析找到的链接，因为它不符合&lt;a href=&quot;../perlpod&quot;&gt;perlpod中&lt;/a&gt;描述的语法。</target>
        </trans-unit>
        <trans-unit id="365c0989adb3aa2936b9a9b37c715ae0175f622e" translate="yes" xml:space="preserve">
          <source>The link-text. If there is none, this must be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the link-text is &quot;Perl Functions&quot;. In &quot;L&amp;lt;Time::HiRes&amp;gt;&quot; and even &quot;L&amp;lt;|Time::HiRes&amp;gt;&quot;, there is no link text. Note that link text may contain formatting.)</source>
          <target state="translated">链接文本。如果没有，则必须为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。（例如，在&amp;ldquo; L &amp;lt;Perl函数| perlfunc&amp;gt;&amp;rdquo;中，链接文本为&amp;ldquo; Perl函数&amp;rdquo;。在&amp;ldquo; L &amp;lt;Time :: HiRes&amp;gt;&amp;rdquo;甚至&amp;ldquo; L &amp;lt;| Time :: HiRes&amp;gt;&amp;rdquo;中都没有链接文本。请注意，链接文本可能包含格式。）</target>
        </trans-unit>
        <trans-unit id="d43c6585f184d3f50d1ee9b3f3e7c9226f529c8c" translate="yes" xml:space="preserve">
          <source>The list becomes the default for</source>
          <target state="translated">列表成为默认的</target>
        </trans-unit>
        <trans-unit id="3deb5bdbb77dae94d3dcc1cd91998f32e0e38f14" translate="yes" xml:space="preserve">
          <source>The list in the second argument means:</source>
          <target state="translated">第二个参数中的列表是指:</target>
        </trans-unit>
        <trans-unit id="e1406e4b9186eac7ca74cdee5b539fc3d6f09c6c" translate="yes" xml:space="preserve">
          <source>The list may well be incomplete, or even wrong in some places. When in doubt, consult the platform-specific README files in the Perl source distribution, and any other documentation resources accompanying a given port.</source>
          <target state="translated">这个列表很可能是不完整的,甚至在某些地方是错误的。如果有疑问,请查阅 Perl 源代码发行版中的特定平台的 README 文件,以及其它任何与特定 port 相关的文档资源。</target>
        </trans-unit>
        <trans-unit id="47c47cf18ff1538b7e1e7d5d97838485842b3427" translate="yes" xml:space="preserve">
          <source>The list of &lt;b&gt;directories&lt;/b&gt; the system searches to find a program you want to &lt;b&gt;execute&lt;/b&gt;. The list is stored as one of your &lt;b&gt;environment variables&lt;/b&gt;, accessible in Perl as &lt;code&gt;$ENV{PATH}&lt;/code&gt; .</source>
          <target state="translated">系统搜索以查找要&lt;b&gt;执行&lt;/b&gt;的程序的&lt;b&gt;目录&lt;/b&gt;列表。该列表存储为您的&lt;b&gt;环境变量之一&lt;/b&gt;，可以在Perl中作为 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="880294bb5af5ca3525238395f901655f64c2020a" translate="yes" xml:space="preserve">
          <source>The list of functions supported by this module.</source>
          <target state="translated">本模块支持的功能列表。</target>
        </trans-unit>
        <trans-unit id="77160ea4e8b3bcdfb5681dd2b39ffff26dc948b8" translate="yes" xml:space="preserve">
          <source>The list of functions that will need to recompiled is: creat, fgetpos, fopen, freopen, fsetpos, fstat, fstatvfs, fstatvfsdev, ftruncate, ftw, lockf, lseek, lstat, mmap, nftw, open, prealloc, stat, statvfs, statvfsdev, tmpfile, truncate, getrlimit, setrlimit</source>
          <target state="translated">需要重新编译的函数列表是:create,fgetpos,fopen,freopen,fsetpos,fstat,fstatvfs,fstatvfsdev,ftruncate,ftw,lockf,lseek,lstat,mmap,nftw,open,prealloc,stat,statvfs,statvfsdev,tmpfile,truncate,getrlimit,setrlimit。</target>
        </trans-unit>
        <trans-unit id="0ece79552d7d2f7d04e0b952118b609964429027" translate="yes" xml:space="preserve">
          <source>The list of libraries needed by Perl only (any libraries needed by extensions only will by dropped, if using dynamic loading).</source>
          <target state="translated">只有Perl需要的库列表(如果使用动态加载,只有扩展需要的库将被删除)。</target>
        </trans-unit>
        <trans-unit id="e64ca6ece649f2cd25525c8ae9c0d312fa7bfc44" translate="yes" xml:space="preserve">
          <source>The list of moderators will be public knowledge. At present, it is: Aaron Crane, Andy Dougherty, Ricardo Signes, Steffen M&amp;uuml;ller.</source>
          <target state="translated">主持人名单将是公众知识。目前是：亚伦&amp;middot;克兰（Aaron Crane），安迪&amp;middot;多尔蒂（Andy Dougherty），里卡多&amp;middot;西涅斯（Ricardo Signes），斯特芬&amp;middot;穆勒（SteffenM&amp;uuml;ller）。</target>
        </trans-unit>
        <trans-unit id="1addfaddfdb521f7b3277e8c72cb79cc08f13e02" translate="yes" xml:space="preserve">
          <source>The list of output parameters occurs at the very end of the function, just after the OUTPUT: directive. The use of RETVAL tells Perl that you wish to send this value back as the return value of the XSUB function. In Example 3, we wanted the &quot;return value&quot; placed in the original variable which we passed in, so we listed it (and not RETVAL) in the OUTPUT: section.</source>
          <target state="translated">输出参数列表出现在函数的最后,就在OUTPUT:指令之后。使用RETVAL告诉Perl,你希望把这个值作为XSUB函数的返回值送回来。在例3中,我们希望把 &quot;返回值 &quot;放在我们传入的原始变量中,所以我们把它(而不是RETVAL)列在OUTPUT:部分。</target>
        </trans-unit>
        <trans-unit id="2539fe270e83e959d35fc853744365007ae544d9" translate="yes" xml:space="preserve">
          <source>The list of subfields can be supplied in any of the following formats</source>
          <target state="translated">子字段列表可以以下列任何一种格式提供。</target>
        </trans-unit>
        <trans-unit id="cbcba41fba02d24fea6ac236d8112cd5b98ebb87" translate="yes" xml:space="preserve">
          <source>The list of the registered CPAN sites follows. Please note that the sorting order is alphabetical on fields:</source>
          <target state="translated">已注册的CPAN网站列表如下。请注意,排序顺序是按字母顺序排列的。</target>
        </trans-unit>
        <trans-unit id="e411ef2006039baaa3efb0aa87f085a254587fe2" translate="yes" xml:space="preserve">
          <source>The list of the valid options is shown below. Options not specified will remain unchanged.</source>
          <target state="translated">有效选项列表如下所示。未指定的选项将保持不变。</target>
        </trans-unit>
        <trans-unit id="cca90ac8d52c301adc0df9b517c693dc0133a8b6" translate="yes" xml:space="preserve">
          <source>The list opened with &lt;code&gt;=over&lt;/code&gt; does not contain any items.</source>
          <target state="translated">用 &lt;code&gt;=over&lt;/code&gt; 打开的列表不包含任何项目。</target>
        </trans-unit>
        <trans-unit id="37870cad335f71a8db1ccbfc9f539b9f8492c3a2" translate="yes" xml:space="preserve">
          <source>The list reference contains one or more strings specifying patterns that are</source>
          <target state="translated">列表引用包含一个或多个字符串,指定的模式是</target>
        </trans-unit>
        <trans-unit id="7ecd93d98b44cbb94ca7891c2599a20dc8e75287" translate="yes" xml:space="preserve">
          <source>The list reference contains one or more strings specifying patterns that must</source>
          <target state="translated">列表引用包含一个或多个字符串,指定了必须使用的模式。</target>
        </trans-unit>
        <trans-unit id="0da38439f7a00ec9abb7cd8b98624a8251f6fb80" translate="yes" xml:space="preserve">
          <source>The listing below is alphabetical, case insensitive.</source>
          <target state="translated">以下列表按字母顺序排列,不区分大小写。</target>
        </trans-unit>
        <trans-unit id="768abd184089ae969a2334570319327e5afad505" translate="yes" xml:space="preserve">
          <source>The listing looks something like this:</source>
          <target state="translated">列表看起来像这样。</target>
        </trans-unit>
        <trans-unit id="a6fd74766ba848460935d167a256b131af8e02ea" translate="yes" xml:space="preserve">
          <source>The lists are ordered (roughly) so the most preferred names come before less preferred ones.</source>
          <target state="translated">名单是按顺序排列的(大致),所以最喜欢的名字在不太喜欢的名字之前。</target>
        </trans-unit>
        <trans-unit id="c3448e4c57076d015f65b6c72251baf22ba5950b" translate="yes" xml:space="preserve">
          <source>The literal string in the regex can be replaced by a variable:</source>
          <target state="translated">在regex中的文字字符串可以用一个变量来代替。</target>
        </trans-unit>
        <trans-unit id="9605e010408c59883a845d8cc68911d04aa028cd" translate="yes" xml:space="preserve">
          <source>The literal string in the regexp can be replaced by a variable:</source>
          <target state="translated">regexp中的字面字符串可以用一个变量代替。</target>
        </trans-unit>
        <trans-unit id="cc87d2f061afcaaa2771f59160c4bc3540da65d9" translate="yes" xml:space="preserve">
          <source>The literal string to be output. If it starts with a number and an optional '*' then the padding will be increased by an amount relative to this number, if the '*' is present then this amount will be multiplied by $cnt. This part of $string is removed before output/</source>
          <target state="translated">要输出的字面字符串。如果它以数字和可选的'*'开头,那么padding将增加一个相对于这个数字的数量,如果有'*',那么这个数量将乘以$cnt。$string的这部分内容会在输出前被删除。</target>
        </trans-unit>
        <trans-unit id="67b8f203dc692021f65103823771254ae8d76d5b" translate="yes" xml:space="preserve">
          <source>The literals that are converted are &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt; , and starting in v5.8.1, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. Operations that do conversions include &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;utf8::upgrade&lt;/code&gt; (but not &lt;code&gt;utf8::downgrade&lt;/code&gt; ), and &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">转换后的文字是 &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt; ，并且从v5.8.1开始， &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 。进行转换的操作包括 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;utf8::upgrade&lt;/code&gt; （但不包括 &lt;code&gt;utf8::downgrade&lt;/code&gt; ）和 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dba36a88aebe7e92337b13757f05491149d1212d" translate="yes" xml:space="preserve">
          <source>The little number the &lt;b&gt;operating system&lt;/b&gt; uses to keep track of which opened &lt;b&gt;file&lt;/b&gt; you&amp;rsquo;re talking about. Perl hides the file descriptor inside a &lt;b&gt;standard I/O&lt;/b&gt; stream and then attaches the stream to a &lt;b&gt;filehandle&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;操作系统&lt;/b&gt;用来跟踪您正在谈论的哪个打开&lt;b&gt;文件&lt;/b&gt;的少量数字。Perl在&lt;b&gt;标准I / O&lt;/b&gt;流中隐藏文件描述符，然后将流附加到&lt;b&gt;filehandle&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="c45e18376e8b086f8c631b86953dc61fd730ab6e" translate="yes" xml:space="preserve">
          <source>The load function that dl_load_file() calls may require an absolute pathname. The dl_findfile() function and @dl_library_path can be used to search for and return the absolute pathname for the library/object that you wish to load.</source>
          <target state="translated">dl_load_file()调用的加载函数可能需要一个绝对路径名,dl_findfile()函数和@dl_library_path可以用来搜索并返回你想加载的库/对象的绝对路径名。dl_findfile()函数和@dl_library_path可以用来搜索并返回你想要加载的库/对象的绝对路径名。</target>
        </trans-unit>
        <trans-unit id="8c46c2259b1d6fa0f7f68fad81b43f4cfbd94e4d" translate="yes" xml:space="preserve">
          <source>The loaded modules are IO::Handle, IO::Seekable, IO::File, IO::Pipe, IO::Socket, IO::Dir. You should instead explicitly import the IO modules you want.</source>
          <target state="translated">加载的模块有IO::Handle、IO::Seekable、IO::File、IO::Pipe、IO::Socket、IO::Dir。你应该明确导入你想要的IO模块。</target>
        </trans-unit>
        <trans-unit id="0917a1903587e2d522edafea1a2d6e66a9118a13" translate="yes" xml:space="preserve">
          <source>The local() generated a compile-time error because you just touched a global name without fully qualifying it.</source>
          <target state="translated">local()产生了一个编译时错误,因为你只是碰了一个全局名,而没有完全限定它。</target>
        </trans-unit>
        <trans-unit id="0cf7efcc5129f771b3d1f0dd51149aa0de4647fc" translate="yes" xml:space="preserve">
          <source>The localeconv function</source>
          <target state="translated">当地的econv函数</target>
        </trans-unit>
        <trans-unit id="ba0cd5497a3f02564f53cc5f3cb0a7c74904a185" translate="yes" xml:space="preserve">
          <source>The locking technique went like this.</source>
          <target state="translated">锁定技术是这样的。</target>
        </trans-unit>
        <trans-unit id="fb02723b6a87664f1d9c172d5d68ee624445a8a4" translate="yes" xml:space="preserve">
          <source>The logarithm of the Gamma function [C99].</source>
          <target state="translated">Gamma函数的对数[C99]。</target>
        </trans-unit>
        <trans-unit id="12f81008559a10138f818056ec245c593a6400e5" translate="yes" xml:space="preserve">
          <source>The logic of &lt;code&gt;:locale&lt;/code&gt; is described in full in &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt;, but in short it is first trying nl_langinfo(CODESET) and then guessing from the LC_ALL and LANG locale environment variables.</source>
          <target state="translated">&lt;code&gt;:locale&lt;/code&gt; 的逻辑在&lt;a href=&quot;encoding&quot;&gt;编码&lt;/a&gt;中进行了完整描述，但简而言之，它首先尝试使用nl_langinfo（CODESET），然后从LC_ALL和LANG语言环境环境变量中进行猜测。</target>
        </trans-unit>
        <trans-unit id="cf878ca097d48d543ea19885a2629244c15e1017" translate="yes" xml:space="preserve">
          <source>The logic of finding which locale &lt;code&gt;:locale&lt;/code&gt; uses is as follows:</source>
          <target state="translated">查找哪个语言环境 &lt;code&gt;:locale&lt;/code&gt; 使用的逻辑如下：</target>
        </trans-unit>
        <trans-unit id="49964803a05917808abe031a83a5e6119fc9d862" translate="yes" xml:space="preserve">
          <source>The lone dot that ends a format can also prematurely end a mail message passing through a misconfigured Internet mailer (and based on experience, such misconfiguration is the rule, not the exception). So when sending format code through mail, you should indent it so that the format-ending dot is not on the left margin; this will prevent SMTP cutoff.</source>
          <target state="translated">结束格式的孤点也会使通过配置错误的Internet邮件器的邮件信息过早结束(根据经验,这种配置错误是常规,而不是例外)。因此,当通过邮件发送格式代码时,应将其缩进,使格式结尾点不在左侧空白处;这样可以防止SMTP切断。</target>
        </trans-unit>
        <trans-unit id="23ac1b0fabb60338fc7595b94617767f0048e6fc" translate="yes" xml:space="preserve">
          <source>The lonesome dash</source>
          <target state="translated">孤独的奔跑</target>
        </trans-unit>
        <trans-unit id="8acab1ed969d76981aca60d63a3ad2f6189741fb" translate="yes" xml:space="preserve">
          <source>The long answer is that &quot;it depends&quot;, and a good answer cannot be given without knowing (at the very least) the language context. See &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt;, and</source>
          <target state="translated">长的答案是&amp;ldquo;取决于&amp;rdquo;，如果不（至少）不了解语言上下文，就不能给出一个好的答案。参见&lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;和</target>
        </trans-unit>
        <trans-unit id="2b351929b2c368a051a670eae8fde3b6788ce75f" translate="yes" xml:space="preserve">
          <source>The long answer is that you need to consider character normalization and casing issues: see &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;, Unicode Technical Report #15, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2funicode%2freports%2ftr15&quot;&gt;Unicode Normalization Forms&lt;/a&gt; and sections on case mapping in the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">长答案是，您需要考虑字符规范化和大小写问题：请参见&lt;a href=&quot;unicode/normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;，Unicode技术报告＃15，&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2funicode%2freports%2ftr15&quot;&gt;Unicode规范化形式&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org&quot;&gt;Unicode标准&lt;/a&gt;中的大小写映射部分。</target>
        </trans-unit>
        <trans-unit id="b13e585010c555d0e300d8fe834b6f46a4ae81c6" translate="yes" xml:space="preserve">
          <source>The long answer is the rest of the manpage :-)</source>
          <target state="translated">长答案是manpage的其余部分:-)</target>
        </trans-unit>
        <trans-unit id="31adae3a57b090c57ee3c7e6d1bf3e97b3bf17d2" translate="yes" xml:space="preserve">
          <source>The long name is returned in a form nicely capitalized, suitable for printing.</source>
          <target state="translated">长名以大写的形式返回,适合打印。</target>
        </trans-unit>
        <trans-unit id="3088cd686b7b7b0dbd27c6c1543c10f8e12363eb" translate="yes" xml:space="preserve">
          <source>The lookahead and lookbehind assertions are generalizations of the anchor concept. Lookahead and lookbehind are zero-width assertions that let us specify which characters we want to test for. The lookahead assertion is denoted by &lt;code&gt;(?=regexp)&lt;/code&gt; and the lookbehind assertion is denoted by &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt;. Some examples are</source>
          <target state="translated">前瞻性声明和后向声明是锚概念的概括。前行和后行是零宽度的断言，可让我们指定要测试的字符。先行断言由 &lt;code&gt;(?=regexp)&lt;/code&gt; 表示，后向断言由 &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; 表示。一些例子是</target>
        </trans-unit>
        <trans-unit id="d6f75c5b0c19aae838064eb95c9b0bb2969329be" translate="yes" xml:space="preserve">
          <source>The lookbehind &lt;code&gt;condition&lt;/code&gt; allows, along with backreferences, an earlier part of the match to influence a later part of the match. For instance,</source>
          <target state="translated">后向 &lt;code&gt;condition&lt;/code&gt; 与反向引用一起允许匹配的较早部分影响匹配的较后部分。例如，</target>
        </trans-unit>
        <trans-unit id="81e7a5f6a959e62bd2ce3d55576db8abdefeae7e" translate="yes" xml:space="preserve">
          <source>The loop will do the right thing for a while, but it will unexpectedly fail.</source>
          <target state="translated">循环会做对一段时间,但会意外失败。</target>
        </trans-unit>
        <trans-unit id="45575ec17d57b6c0181a285166eef0dbc45075e3" translate="yes" xml:space="preserve">
          <source>The loop will never terminate.</source>
          <target state="translated">循环永远不会终止。</target>
        </trans-unit>
        <trans-unit id="ef06996a2f846d6797b75f13080961cc1d5fe17b" translate="yes" xml:space="preserve">
          <source>The low levels of the stack work with the low-level operating system calls (file descriptors in C) getting bytes in and out, the higher layers of the stack buffer, filter, and otherwise manipulate the I/O, and return characters (or bytes) to Perl. Terms</source>
          <target state="translated">栈的低层与低层操作系统调用(C语言中的文件描述符)一起工作,获取字节进出,栈的高层缓冲、过滤和以其他方式操作I/O,并向Perl返回字符(或字节)。术语</target>
        </trans-unit>
        <trans-unit id="e618b44ecefc43c73cbcbb761a0be8756b4a11d0" translate="yes" xml:space="preserve">
          <source>The lower-level loops are</source>
          <target state="translated">低级循环是</target>
        </trans-unit>
        <trans-unit id="d49e301cfdcfd0dc30c1292d8446531a39bb2c8d" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;$ref&lt;/code&gt; will be turned into a weak reference. This means that it will not hold a reference count on the object it references. Also when the reference count on that object reaches zero, the reference will be set to undef. This function mutates the lvalue passed as its argument and returns no value.</source>
          <target state="translated">左值 &lt;code&gt;$ref&lt;/code&gt; 将变为弱引用。这意味着它将不保留对其引用的对象的引用计数。同样，当该对象的引用计数达到零时，该引用将设置为undef。此函数使作为参数传递的左值发生突变，并且不返回任何值。</target>
        </trans-unit>
        <trans-unit id="6b3f15897ac19338676b9cf56d55755a66f779f6" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;REF&lt;/code&gt; will be turned from a weak reference back into a normal (strong) reference again. This function mutates the lvalue passed as its argument and returns no value. This undoes the action performed by &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt;.</source>
          <target state="translated">左值 &lt;code&gt;REF&lt;/code&gt; 将再次从弱参考变为正常（强）参考。此函数使作为参数传递的左值发生突变，并且不返回任何值。这取消了&lt;a href=&quot;#weaken&quot;&gt;弱化所&lt;/a&gt;执行的动作。</target>
        </trans-unit>
        <trans-unit id="8b79adf8cca5ef25d3cb23e673042840fb0ff857" translate="yes" xml:space="preserve">
          <source>The macro to put this target on stack is &lt;code&gt;PUSHTARG&lt;/code&gt; , and it is directly used in some opcodes, as well as indirectly in zillions of others, which use it via &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;.</source>
          <target state="translated">将这个目标放在堆栈上的宏是 &lt;code&gt;PUSHTARG&lt;/code&gt; ，它直接用在某些操作码中，也间接用在不计其数的其他操作码中，它们通过 &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; 使用它。</target>
        </trans-unit>
        <trans-unit id="bde4ff87d6048995f18afa79c7d92547dd919bf7" translate="yes" xml:space="preserve">
          <source>The macros PERL_SYS_INIT3() and PERL_SYS_TERM() provide system-specific tune up of the C runtime environment necessary to run Perl interpreters; they should only be called once regardless of how many interpreters you create or destroy. Call PERL_SYS_INIT3() before you create your first interpreter, and PERL_SYS_TERM() after you free your last interpreter.</source>
          <target state="translated">宏PERL_SYS_INIT3()和PERL_SYS_TERM()提供了运行Perl解释器所需的C语言运行环境的系统特定调整;无论你创建或销毁了多少个解释器,它们都应该只被调用一次。在创建第一个解释器之前调用PERL_SYS_INIT3(),在释放最后一个解释器之后调用PERL_SYS_TERM()。</target>
        </trans-unit>
        <trans-unit id="d1139ce181f4f4cad2c7f324461583f5984431bd" translate="yes" xml:space="preserve">
          <source>The macros to simplify this type of error propagation are</source>
          <target state="translated">简化这种类型的错误传播的宏是</target>
        </trans-unit>
        <trans-unit id="c70f4757860a22dec9e7cd7195f5c976eb6e087f" translate="yes" xml:space="preserve">
          <source>The mailbox (MBX) that perl can create to communicate with a pipe defaults to a buffer size of 8192 on 64-bit systems, 512 on VAX. The default buffer size is adjustable via the logical name PERL_MBX_SIZE provided that the value falls between 128 and the SYSGEN parameter MAXBUF inclusive. For example, to set the mailbox size to 32767 use &lt;code&gt;$ENV{'PERL_MBX_SIZE'} = 32767;&lt;/code&gt; and then open and use pipe constructs. An alternative would be to issue the command:</source>
          <target state="translated">perl可以创建以与管道进行通信的邮箱（MBX）在64位系统上默认为8192，在VAX上为512。缺省缓冲区大小可通过逻辑名PERL_MBX_SIZE进行调整，条件是该值介于128和SYSGEN参数MAXBUF（含）之间。例如，要将邮箱大小设置为32767，请使用 &lt;code&gt;$ENV{'PERL_MBX_SIZE'} = 32767;&lt;/code&gt; 然后打开并使用管道结构。一种替代方法是发出命令：</target>
        </trans-unit>
        <trans-unit id="0c5ef5a84eaac465306135c82a819527f916862a" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$]&lt;/code&gt; over &lt;code&gt;$^V&lt;/code&gt; is that it works the same on any version of Perl. The disadvantages are that it can't easily be compared to versions in other formats (e.g. literal v-strings, &quot;v1.2.3&quot; or version objects) and numeric comparisons can occasionally fail; it's good for string literal version checks and bad for comparing to a variable that hasn't been sanity-checked.</source>
          <target state="translated">&lt;code&gt;$]&lt;/code&gt; 优于 &lt;code&gt;$^V&lt;/code&gt; 的主要优点是，它在任何版本的Perl上都可以工作。缺点是无法轻易将其与其他格式的版本（例如文字v字符串，&amp;ldquo; v1.2.3&amp;rdquo;或版本对象）进行比较，并且数值比较有时会失败；这对于字符串文字版本检查很有用，而对于与未经完整性检查的变量进行比较则不利。</target>
        </trans-unit>
        <trans-unit id="fb52b8877c2d456ae00a93e532373fbd1c4c24a5" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$^V&lt;/code&gt; over &lt;code&gt;$]&lt;/code&gt; is that, for Perl v5.10.0 or later, it overloads operators, allowing easy comparison against other version representations (e.g. decimal, literal v-string, &quot;v1.2.3&quot;, or objects). The disadvantage is that prior to v5.10.0, it was only a literal v-string, which can't be easily printed or compared.</source>
          <target state="translated">&lt;code&gt;$^V&lt;/code&gt; 优于 &lt;code&gt;$]&lt;/code&gt; 的主要优点是，对于Perl v5.10.0或更高版本，它会重载运算符，从而可以轻松地与其他版本表示形式进行比较（例如，十进制，文字v字符串，&amp;ldquo; v1.2.3&amp;rdquo;或对象） 。缺点是在v5.10.0之前，它只是一个文字v字符串，无法轻松打印或比较。</target>
        </trans-unit>
        <trans-unit id="101d1c6f485f1984d68802df9d96ca30aed70d37" translate="yes" xml:space="preserve">
          <source>The main change in &lt;code&gt;Compress::Zlib&lt;/code&gt; version 2.x is that it does not now interface directly to the zlib library. Instead it uses the &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; modules for reading/writing gzip files, and the &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; module for some low-level zlib access.</source>
          <target state="translated">&lt;code&gt;Compress::Zlib&lt;/code&gt; 版本2.x 的主要变化是，它现在不直接与zlib库交互。相反，它使用 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 和 &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; 模块读取/写入gzip文件，并使用 &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; 模块进行一些低级zlib访问。</target>
        </trans-unit>
        <trans-unit id="372171de4da878145ca85489d35a3856b5f753b3" translate="yes" xml:space="preserve">
          <source>The main difference between this form of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method and the previous one, is that this one will attempt to return</source>
          <target state="translated">这种形式的 &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 方法与上一种形式的主要区别在于，该形式将尝试返回</target>
        </trans-unit>
        <trans-unit id="506249c3cb5dbdd1518162463cf96d2d3b772f7e" translate="yes" xml:space="preserve">
          <source>The main difference in your code when using &lt;code&gt;LimitOutput&lt;/code&gt; is having to deal with cases where the &lt;code&gt;$input&lt;/code&gt; parameter still contains some uncompressed data that &lt;code&gt;inflate&lt;/code&gt; hasn't processed yet. The status code returned from &lt;code&gt;inflate&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; if uncompression took place and &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; if the output buffer is full.</source>
          <target state="translated">在你的代码的主要区别在使用 &lt;code&gt;LimitOutput&lt;/code&gt; 是必须处理的情况下 &lt;code&gt;$input&lt;/code&gt; 参数仍然包含一些非压缩数据 &lt;code&gt;inflate&lt;/code&gt; 尚未处理。从返回的状态代码 &lt;code&gt;inflate&lt;/code&gt; 将 &lt;code&gt;Z_OK&lt;/code&gt; 如果解压缩发生和 &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; 如果输出缓冲区已满。</target>
        </trans-unit>
        <trans-unit id="05152f518d0f3656c0688ee9cee29d35fcced80c" translate="yes" xml:space="preserve">
          <source>The main enhancements over the standard DBM Filter hooks are:</source>
          <target state="translated">与标准的DBM Filter钩子相比,主要增强了以下几点。</target>
        </trans-unit>
        <trans-unit id="e1f5b26355b7b70560c834756cb61711542dab38" translate="yes" xml:space="preserve">
          <source>The main interface to Perl's documentation is &lt;code&gt;perldoc&lt;/code&gt; , although if you're reading this, it's more than likely that you've already found it.</source>
          <target state="translated">Perl文档的主要界面是 &lt;code&gt;perldoc&lt;/code&gt; ，尽管如果您正在阅读本文，那么很有可能已经找到了它。</target>
        </trans-unit>
        <trans-unit id="9d35e12fdba0e51aa394bd8618a43431bb51d2f3" translate="yes" xml:space="preserve">
          <source>The main processing loop in the code handles reading of compressed data from STDIN.</source>
          <target state="translated">代码中的主处理循环处理从STDIN读取压缩数据。</target>
        </trans-unit>
        <trans-unit id="46fda3610207ec49730bec59c6f9f9a606bd23ef" translate="yes" xml:space="preserve">
          <source>The main restriction is that everything is a metacharacter. Thus, you cannot refer to single characters by doing something like this:</source>
          <target state="translated">主要的限制是,所有的东西都是元字符。因此,你不能通过这样的方式来引用单个字符。</target>
        </trans-unit>
        <trans-unit id="5f01e11115c777ec013558e25689beffe8389e6e" translate="yes" xml:space="preserve">
          <source>The main run-time, i.e. the execution of &lt;code&gt;PL_main_root&lt;/code&gt; .</source>
          <target state="translated">主要运行时，即 &lt;code&gt;PL_main_root&lt;/code&gt; 的执行。</target>
        </trans-unit>
        <trans-unit id="37fc4f091ec88a6495b33730022421e8180365bf" translate="yes" xml:space="preserve">
          <source>The main thing to bear in mind when comparing Perl's</source>
          <target state="translated">在比较Perl的</target>
        </trans-unit>
        <trans-unit id="c06e6958bf7f6e1def3af629026b1de09d93eea1" translate="yes" xml:space="preserve">
          <source>The main two standard installer modules are the old and well established ExtUtils::MakeMaker (for short: EUMM) which uses the Makefile.PL. And the next generation installer Module::Build (MB) which works with the Build.PL (and often comes with a Makefile.PL too). If a module comes only with one of the two we will use that one but if both are supplied then a decision must be made between EUMM and MB. See also &lt;a href=&quot;http://rt.cpan.org/Ticket/Display.html?id=29235&quot;&gt;http://rt.cpan.org/Ticket/Display.html?id=29235&lt;/a&gt; for a discussion about the right default.</source>
          <target state="translated">两个主要的标准安装程序模块是使用Makefile.PL的古老且完善的ExtUtils :: MakeMaker（简称：EUMM）。以及与Build.PL一起使用的下一代安装程序Module :: Build（MB）（通常也附带Makefile.PL）。如果模块仅带有两个模块中的一个，我们将使用该模块，但是如果同时提供了两个模块，则必须在EUMM和MB之间做出决定。另请参见&lt;a href=&quot;http://rt.cpan.org/Ticket/Display.html?id=29235&quot;&gt;http://rt.cpan.org/Ticket/Display.html?id=29235&lt;/a&gt;，以获取有关正确默认值的讨论。</target>
        </trans-unit>
        <trans-unit id="b2f8fe511450837b8803ee63b84fd8df2352eb1f" translate="yes" xml:space="preserve">
          <source>The main use of the &lt;code&gt;@_&lt;/code&gt; pass-through feature is to write subroutines whose main job it is to call other subroutines for you. For further details, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@_&lt;/code&gt; 传递功能的主要用途是编写子例程，其主要工作是为您调用其他子例程。有关更多详细信息，请参见&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53e4e2133c40d29e72103e441a447d5a4a38fc75" translate="yes" xml:space="preserve">
          <source>The main use of typeglobs in modern Perl is create symbol table aliases. This assignment:</source>
          <target state="translated">在现代Perl中,typeglobs的主要用途是创建符号表别名。这个赋值。</target>
        </trans-unit>
        <trans-unit id="69b1898f468b9694e16716e650f4f44f6641ba6b" translate="yes" xml:space="preserve">
          <source>The main way they do this is by abstracting the solution into a Perl module. If you don't know what one of these is, the rest of this document isn't going to be much use to you. You're also missing out on an awful lot of useful code; consider having a look at &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; and &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt; before coming back here.</source>
          <target state="translated">他们这样做的主要方法是将解决方案抽象到Perl模块中。如果您不知道其中的一个是什么，那么本文档的其余部分对您将无用。您还错过了很多有用的代码。在回到这里之前，请考虑看看&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;，&lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt;和&lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f1c38b1c10cfb3cbb67b1b10b401ccad6c0863c" translate="yes" xml:space="preserve">
          <source>The main workhorse. This is a chimera executable: it is compiled as an &lt;code&gt;a.out&lt;/code&gt; -style executable, but is linked with &lt;code&gt;omf&lt;/code&gt; -style dynamic library</source>
          <target state="translated">主要力量。这是一个嵌合体可执行文件：它被编译为 &lt;code&gt;a.out&lt;/code&gt; -style可执行文件，但与 &lt;code&gt;omf&lt;/code&gt; -style动态库链接</target>
        </trans-unit>
        <trans-unit id="3956c803121907ff5d6974bf9c432a88f1cf833c" translate="yes" xml:space="preserve">
          <source>The major headers should be set out using a &lt;code&gt;=head1&lt;/code&gt; directive, and are historically written in the rather startling ALL UPPER CASE format; this is not mandatory, but it's strongly recommended so that sections have consistent naming across different software packages. Minor headers may be included using &lt;code&gt;=head2&lt;/code&gt; , and are typically in mixed case.</source>
          <target state="translated">主要标头应使用 &lt;code&gt;=head1&lt;/code&gt; 指令设置，并在过去以令人震惊的ALL UPPER CASE格式编写；这不是强制性的，但强烈建议这样做，以使各部分在不同的软件包之间具有一致的命名。可以使用 &lt;code&gt;=head2&lt;/code&gt; 包含次要标头，并且通常在混合情况下使用。</target>
        </trans-unit>
        <trans-unit id="01d78be692306962b0b26bf44b44f51f19191990" translate="yes" xml:space="preserve">
          <source>The major reference book on Perl, written by the creator of Perl, is</source>
          <target state="translated">关于Perl的主要参考书是由Perl的创造者所写的。</target>
        </trans-unit>
        <trans-unit id="13680a9d6e9227284375bc26da8c5530041e38fc" translate="yes" xml:space="preserve">
          <source>The majority of messages from the first three classifications above (W, D &amp;amp; S) can be controlled using the &lt;code&gt;warnings&lt;/code&gt; pragma.</source>
          <target state="translated">可以使用 &lt;code&gt;warnings&lt;/code&gt; 编译指示来控制上述前三个类别（W，D和S）中的大多数消息。</target>
        </trans-unit>
        <trans-unit id="cd369e1f787ef0292f11539410c5f0156585f6b5" translate="yes" xml:space="preserve">
          <source>The make process also creates the Perl extensions as</source>
          <target state="translated">make过程还将Perl扩展创建为</target>
        </trans-unit>
        <trans-unit id="6834c3d08e7b64ac9a3d75579db624c6bb6535ce" translate="yes" xml:space="preserve">
          <source>The make process runs only under WinNT shell. The NetWare makefile is located under the NetWare folder. This makes use of miniperl.exe to run some of the Perl scripts. To create miniperl.exe, first set the required paths for Visual c++ compiler (specify vcvars32 location) at the command prompt. Then run nmake from win32 folder through WinNT command prompt. The build process can be stopped after miniperl.exe is created. Then run nmake from NetWare folder through WinNT command prompt.</source>
          <target state="translated">make进程只在WinNT shell下运行。NetWare的makefile位于NetWare文件夹下,它使用miniperl.exe来运行一些Perl脚本。这就利用miniperl.exe来运行一些Perl脚本。要创建miniperl.exe,首先在命令提示符下设置Visual c++编译器所需的路径(指定vcvars32位置)。然后通过WinNT命令提示符从win32文件夹运行nmake。创建miniperl.exe后,可以停止构建过程。然后通过WinNT命令提示符从NetWare文件夹运行nmake。</target>
        </trans-unit>
        <trans-unit id="050ece2e16daad9919f83779717a0433d9f5277b" translate="yes" xml:space="preserve">
          <source>The make under /usr/ccs/bin works fine for building perl. If you have the Sun C compilers, you will also have a parallel version of make (dmake). This works fine to build perl, but can sometimes cause problems when running 'make test' due to underspecified dependencies between the different test harness files. The same problem can also affect the building of some add-on modules, so in those cases either specify '-m serial' on the dmake command line, or use /usr/ccs/bin/make instead. If you wish to use GNU make, be sure that the set-group-id bit is not set. If it is, then arrange your PATH so that /usr/ccs/bin/make is before GNU make or else have the system administrator disable the set-group-id bit on GNU make.</source>
          <target state="translated">在/usr/ccs/bin下的make可以很好地用于构建perl。如果你有Sun C编译器,你也会有一个并行版本的make(dmake)。这在构建perl时工作得很好,但在运行 &quot;make test &quot;时,有时会因为不同的test harness文件之间的依赖关系不够明确而导致问题。同样的问题也会影响一些附加模块的构建,所以在这种情况下,可以在dmake命令行中指定'-m serial',或者使用/usr/ccs/bin/make。如果你想使用 GNU make,请确保 set-group-id 位没有被设置。如果是,则应安排 PATH,使 /usr/ccs/bin/make 位于 GNU make 之前,否则请系统管理员禁用 GNU make 的 set-group-id 位。</target>
        </trans-unit>
        <trans-unit id="093c5a0fa4f10414f0bded11d9711f892cf8d016" translate="yes" xml:space="preserve">
          <source>The makefile for Win32 is used as a reference to create the makefile for NetWare. Also, the make process for NetWare port uses miniperl.exe to run scripts during the make and installation process.</source>
          <target state="translated">Win32的makefile被用作创建NetWare的makefile的参考。此外,NetWare端口的make过程使用miniperl.exe在make和安装过程中运行脚本。</target>
        </trans-unit>
        <trans-unit id="27e98181ad3a79924d7fd39b526549233ec76d6a" translate="yes" xml:space="preserve">
          <source>The man page documenting the an macro set may be</source>
          <target state="translated">记载宏集的手册页可以是</target>
        </trans-unit>
        <trans-unit id="d1b2bfc99455c361765a64ae36b53dd690daec7f" translate="yes" xml:space="preserve">
          <source>The man page documenting the man macro set may be</source>
          <target state="translated">记录man宏集的man页面可以是</target>
        </trans-unit>
        <trans-unit id="284a6c5b883e0ac48b839ca370726900339633bc" translate="yes" xml:space="preserve">
          <source>The mandatory parameter &lt;code&gt;$input&lt;/code&gt; is used to determine the source of the compressed data. This parameter can take one of three forms.</source>
          <target state="translated">强制参数 &lt;code&gt;$input&lt;/code&gt; 用于确定压缩数据的来源。该参数可以采用以下三种形式之一。</target>
        </trans-unit>
        <trans-unit id="c485ab3d22837e3f8be3f1796e0e79d8c8f06f1f" translate="yes" xml:space="preserve">
          <source>The mandatory parameter &lt;code&gt;$output&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">强制参数 &lt;code&gt;$output&lt;/code&gt; 用于控制压缩数据的目的地。该参数可以采用以下形式之一。</target>
        </trans-unit>
        <trans-unit id="de616d536d8ef10cc9a3f654a8c90f376abf8093" translate="yes" xml:space="preserve">
          <source>The manual for GNU &lt;code&gt;gettext&lt;/code&gt; . The gettext dist is available in &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; -- get a recent gettext tarball and look in its &quot;doc/&quot; directory, there's an easily browsable HTML version in there. The gettext documentation asks lots of questions worth thinking about, even if some of their answers are sometimes wonky, particularly where they start talking about pluralization.</source>
          <target state="translated">GNU &lt;code&gt;gettext&lt;/code&gt; 手册。gettext dist可在 &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; 中获得-获取最新的gettext压缩文件，并在其&amp;ldquo; doc /&amp;rdquo;目录中查找，那里有一个易于浏览的HTML版本。gettext文档提出了许多值得考虑的问题，即使他们的某些回答有时有些古怪，尤其是在他们开始谈论多元性的地方。</target>
        </trans-unit>
        <trans-unit id="154ce4660707f31f1810dc0e3b48188806eef41c" translate="yes" xml:space="preserve">
          <source>The many &lt;code&gt;SO_*&lt;/code&gt; and other constants provide the socket option names for getsockopt() and setsockopt().</source>
          <target state="translated">许多 &lt;code&gt;SO_*&lt;/code&gt; 和其他常量为getsockopt（）和setsockopt（）提供套接字选项名称。</target>
        </trans-unit>
        <trans-unit id="55aaa52fca491aa374cc9b313f0827cacbb95ed1" translate="yes" xml:space="preserve">
          <source>The map of tags-to-names that it uses is accessible as %I18N::LangTags::List::Name, and it's the same as the list that follows in this documentation, which should be useful to you even if you don't use this module.</source>
          <target state="translated">它所使用的标签到名称的映射可以访问%I18N::LangTags::List::Name,它和本文档中后面的列表是一样的,即使你不使用这个模块,也应该对你有用。</target>
        </trans-unit>
        <trans-unit id="4ec748c6f374bea6dd407e2a2206dd66cc0ef16e" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and Perl is stored in the global hash &lt;code&gt;Mapping&lt;/code&gt; this time. Using a hash has the distinct advantage that it allows an unlimited number of callbacks to be registered.</source>
          <target state="translated">这次，C回调和Perl之间的映射存储在全局哈希 &lt;code&gt;Mapping&lt;/code&gt; 。使用哈希具有明显的优势，即它允许注册无限数量的回调。</target>
        </trans-unit>
        <trans-unit id="3b99545de853bbada80b111bce027d144c0231ba" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and the Perl equivalent is stored in the global variable &lt;code&gt;callback&lt;/code&gt; .</source>
          <target state="translated">C回调和Perl等效项之间的映射存储在全局变量 &lt;code&gt;callback&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="6a662bfcb14335a42ef03f81101790bf366195df" translate="yes" xml:space="preserve">
          <source>The mapping of &lt;code&gt;U+FFFD&lt;/code&gt; is corrected in Unicode 6.3.0. see &lt;a href=&quot;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&quot;&gt;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&lt;/a&gt; (7.1.4 Trailing Weights). Such a correction is reproduced by this.</source>
          <target state="translated">&lt;code&gt;U+FFFD&lt;/code&gt; 的映射在Unicode 6.3.0中已得到纠正。请参阅&lt;a href=&quot;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&quot;&gt;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights（7.1.4&lt;/a&gt;尾随权重）。由此再现这种校正。</target>
        </trans-unit>
        <trans-unit id="c1b1175bc8b4e9784f2300c93388884be8f7673f" translate="yes" xml:space="preserve">
          <source>The maps for almost all properties are simple scalars that should be interpreted as-is. These values are those given in the Unicode-supplied data files, which may be inconsistent as to capitalization and as to which synonym for a property-value is given. The results may be normalized by using the &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function.</source>
          <target state="translated">几乎所有属性的映射都是应按原样解释的简单标量。这些值是在Unicode提供的数据文件中给出的值，这些值在大小写以及给出属性值的同义词方面可能不一致。可以使用&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;函数将结果标准化。</target>
        </trans-unit>
        <trans-unit id="3e4bf89cabbc9315682f2b81d303b6aa4fa34849" translate="yes" xml:space="preserve">
          <source>The markup used to embed documentation into your Perl code. Pod stands for &amp;ldquo;Plain old documentation&amp;rdquo;. See Camel chapter 23, &amp;ldquo;Plain Old Documentation&amp;rdquo;.</source>
          <target state="translated">用于将文档嵌入到您的Perl代码中的标记。Pod代表&amp;ldquo;普通的旧文档&amp;rdquo;。请参见骆驼第23章，&amp;ldquo;普通旧文档&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="34cc83ddfdc06a0bade5acdcde84b75e2705b198" translate="yes" xml:space="preserve">
          <source>The master web site for CPAN is &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;, &lt;a href=&quot;http://www.cpan.org/SITES.html&quot;&gt;http://www.cpan.org/SITES.html&lt;/a&gt; lists all mirrors.</source>
          <target state="translated">主网站的CPAN是&lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;，&lt;a href=&quot;http://www.cpan.org/SITES.html&quot;&gt;http://www.cpan.org/SITES.html&lt;/a&gt;列出了所有的镜子。</target>
        </trans-unit>
        <trans-unit id="3c45f7edc42ff58b499f5e637a319d744b7420b9" translate="yes" xml:space="preserve">
          <source>The match is greedy and non-backtracking, so that the cluster is never broken up into smaller components.</source>
          <target state="translated">匹配是贪婪的和非回溯的,因此集群永远不会被分解成更小的组件。</target>
        </trans-unit>
        <trans-unit id="c68736af7f30812a5478f14010c89b4ae65386b0" translate="yes" xml:space="preserve">
          <source>The match operator is &quot;=~&quot;, not &quot;~&quot;. (&quot;~&quot; is the one's complement operator, as in C.)</source>
          <target state="translated">匹配运算符是&quot;=~&quot;,不是&quot;~&quot;。(&quot;~&quot;是一的补码运算符,如C语言。)</target>
        </trans-unit>
        <trans-unit id="5795a85f98b64dffbf8aba9e904fb2bc93749e98" translate="yes" xml:space="preserve">
          <source>The match operator is a double quote context, so you can interpolate your variable just like a double quoted string. In this case, you read the regular expression as user input and store it in &lt;code&gt;$regex&lt;/code&gt; . Once you have the pattern in &lt;code&gt;$regex&lt;/code&gt; , you use that variable in the match operator.</source>
          <target state="translated">match运算符是双引号上下文，因此您可以像双引号字符串一样对变量进行插值。在这种情况下，您将正则表达式作为用户输入读取，并将其存储在 &lt;code&gt;$regex&lt;/code&gt; 。一旦在 &lt;code&gt;$regex&lt;/code&gt; 有了模式，就可以在match运算符中使用该变量。</target>
        </trans-unit>
        <trans-unit id="8ab1da87cbb5d0fd800bfa0309cbbc3c397f76b8" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">匹配运算符。请参阅&lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop中的Regexp类似引用运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23da9f3c77f641f40df01068ee8c7ee0a479ea6c" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">匹配运算符。请参阅&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop中的Regexp类似引用运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f542541549a1bc6970c3286cf46be7af8b4f2d05" translate="yes" xml:space="preserve">
          <source>The match-once behavior is controlled by the match delimiter being &lt;code&gt;?&lt;/code&gt;; with any other delimiter this is the normal &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">一次匹配行为由匹配定界符控制为 &lt;code&gt;?&lt;/code&gt; ; 与其他定界符一起使用时，这是常规的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="eeba81f62bbef449f5b856ee7d56cb86c716867d" translate="yes" xml:space="preserve">
          <source>The matched-pattern variables, &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; (pre-match), &lt;code&gt;$'&lt;/code&gt; (post-match), and &lt;code&gt;$+&lt;/code&gt; (last match) also are tainted.</source>
          <target state="translated">匹配模式变量 &lt;code&gt;$&amp;amp;&lt;/code&gt; ， &lt;code&gt;$`&lt;/code&gt; （赛前）， &lt;code&gt;$'&lt;/code&gt; （赛后）和 &lt;code&gt;$+&lt;/code&gt; （最后赛）也被污染。</target>
        </trans-unit>
        <trans-unit id="eef4278a734cc2ba9814c78fdf30442bf1892ae1" translate="yes" xml:space="preserve">
          <source>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. Note that the &lt;code&gt;:utf8&lt;/code&gt; layer must always be specified exactly like that; it is</source>
          <target state="translated">编码名称的匹配很松散：大小写无关紧要，许多编码都有几个别名。注意 &lt;code&gt;:utf8&lt;/code&gt; 层必须始终完全一样指定。它是</target>
        </trans-unit>
        <trans-unit id="906f4ce57c5894760cba731d333a52399d7a0c38" translate="yes" xml:space="preserve">
          <source>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. See &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt; for details and the list of supported locales.</source>
          <target state="translated">编码名称的匹配很松散：大小写无关紧要，许多编码都有几个别名。有关详细信息和支持的语言环境，请参见&lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5401e94f4440b62a9a27d03fcc9d30b1169f66e8" translate="yes" xml:space="preserve">
          <source>The material below is separated into three main sections: main issues of portability (&lt;a href=&quot;#ISSUES&quot;&gt;ISSUES&lt;/a&gt;), platform-specific issues (&lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS&lt;/a&gt;), and built-in Perl functions that behave differently on various ports (&lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;FUNCTION IMPLEMENTATIONS&lt;/a&gt;).</source>
          <target state="translated">下面的材料分为三个主要部分：可移植性的主要问题（&lt;a href=&quot;#ISSUES&quot;&gt;ISSUES&lt;/a&gt;），特定于平台的问题（&lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS&lt;/a&gt;）和在各个端口上表现不同的内置Perl函数（&lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;FUNCTION IMPLEMENTATIONS&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="42a757bded9f533a67a5134eccc21794fdd0b6bd" translate="yes" xml:space="preserve">
          <source>The maximum Unicode code point is &lt;code&gt;U+10FFFF&lt;/code&gt; , and Unicode only defines operations on code points up through that. But Perl works on code points up to the maximum permissible unsigned number available on the platform. However, Perl will not accept these from input streams unless lax rules are being used, and will warn (using the warning category &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if any are output.</source>
          <target state="translated">最大Unicode代码点为 &lt;code&gt;U+10FFFF&lt;/code&gt; ，而Unicode仅定义在此之后的代码点上的操作。但是Perl可以处理的代码点数最多可以达到平台上可用的最大允许无符号数。但是，除非使用松散规则，否则Perl将不接受输入流中的这些内容，并且将输出警告（使用警告类别 &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; ，它是 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 的子类别）。</target>
        </trans-unit>
        <trans-unit id="6cc1808d3e3fb6de5739d08162d085e4fb2b2c51" translate="yes" xml:space="preserve">
          <source>The maximum number of parallel tests to run at any time. Which tests can be run in parallel is controlled by &lt;code&gt;rules&lt;/code&gt; . The default is to run only one test at a time.</source>
          <target state="translated">随时可以运行的最大并行测试数。哪些测试可以并行运行由 &lt;code&gt;rules&lt;/code&gt; 控制。默认设置是一次仅运行一个测试。</target>
        </trans-unit>
        <trans-unit id="0ec24717c6af4893fa65de730b8ddea405e13134" translate="yes" xml:space="preserve">
          <source>The maximum number this construct can express is &lt;code&gt;\777&lt;/code&gt; . If you need a larger one, you need to use &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\o{}&lt;/a&gt; instead. If you meant two separate things, you need to separate them:</source>
          <target state="translated">此构造可以表示的最大数量为 &lt;code&gt;\777&lt;/code&gt; 。如果您需要更大的文件夹，则需要改用&lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\ o {}&lt;/a&gt;。如果您要分开两件事，则需要将它们分开：</target>
        </trans-unit>
        <trans-unit id="823e727fb7ce51ed0c50f11b0b5dce6f9f8c6422" translate="yes" xml:space="preserve">
          <source>The maximum size of a Storable header is currently 21 bytes. If the provided $buffer is only the first part of a Storable image it should at least be this long to ensure that read_magic() will recognize it as such.</source>
          <target state="translated">Storable头的最大大小目前是21字节。如果所提供的$buffer只是Storable映像的第一部分,那么至少应该有这么长,以确保read_magic()能够识别它。</target>
        </trans-unit>
        <trans-unit id="54655c72af2839e9f037d863fc7638dac7966cf0" translate="yes" xml:space="preserve">
          <source>The maximum size of an extra field 65535 bytes.</source>
          <target state="translated">额外字段的最大大小为65535字节。</target>
        </trans-unit>
        <trans-unit id="60da8f51a4ded24731bf101a405dc42107509236" translate="yes" xml:space="preserve">
          <source>The maximum size of the Extra Field 65535 bytes.</source>
          <target state="translated">额外字段的最大大小为65535字节。</target>
        </trans-unit>
        <trans-unit id="51d29e4ee16b1b5f77f1b62a7cfc84201aec0810" translate="yes" xml:space="preserve">
          <source>The maximum system file descriptor, ordinarily 2. System file descriptors are passed to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;ed processes, while higher file descriptors are not. Also, during an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, system file descriptors are preserved even if the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; fails (ordinary file descriptors are closed before the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; is attempted). The close-on-exec status of a file descriptor will be decided according to the value of &lt;code&gt;$^F&lt;/code&gt; when the corresponding file, pipe, or socket was opened, not the time of the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最大系统文件描述符，通常为2。系统文件描述符传递给 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 进程，而更高的文件描述符则不传递。另外，在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 期间，即使 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 失败（通常文件描述符在尝试 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 之前关闭），系统文件描述符也会保留。当打开相应的文件，管道或套接字时，文件描述符的执行关闭状态将根据 &lt;code&gt;$^F&lt;/code&gt; 的值确定，而不是根据 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 的时间确定。</target>
        </trans-unit>
        <trans-unit id="db9125f66ae949d81694c6e6210bfeb871e3d64e" translate="yes" xml:space="preserve">
          <source>The mechanism of translation of &lt;code&gt;\N{...}&lt;/code&gt; escapes is general and not hardwired into</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; 转义的翻译机制是一般性的，并非硬性地</target>
        </trans-unit>
        <trans-unit id="15610051fc12501695115ef5aed4c6968c7a9267" translate="yes" xml:space="preserve">
          <source>The members whose names begin with &lt;code&gt;int_p_&lt;/code&gt; and &lt;code&gt;int_n_&lt;/code&gt; were added by POSIX.1-2008 and are only available on systems that support them.</source>
          <target state="translated">名称以 &lt;code&gt;int_p_&lt;/code&gt; 和 &lt;code&gt;int_n_&lt;/code&gt; 开头的成员是POSIX.1-2008添加的，并且仅在支持它们的系统上可用。</target>
        </trans-unit>
        <trans-unit id="36545165ac282d6d6bbbc3b54b056ad82f2d5183" translate="yes" xml:space="preserve">
          <source>The message, either sent via &lt;code&gt;datasend&lt;/code&gt; or as the &lt;code&gt;MESSAGE&lt;/code&gt; parameter, must be in the format as described by RFC822 and must contain From:, Newsgroups: and Subject: headers.</source>
          <target state="translated">通过 &lt;code&gt;datasend&lt;/code&gt; 发送或作为 &lt;code&gt;MESSAGE&lt;/code&gt; 参数发送的消息，必须采用RFC822描述的格式，并且必须包含From：，Newsgroups和Subject：标头。</target>
        </trans-unit>
        <trans-unit id="ee89b7499807e434bb5f68dbb5e73957271240a3" translate="yes" xml:space="preserve">
          <source>The messages are in alphabetical order, without regard to upper or lower-case. Some of these messages are generic. Spots that vary are denoted with a %s or other printf-style escape. These escapes are ignored by the alphabetical order, as are all characters other than letters. To look up your message, just ignore anything that is not a letter.</source>
          <target state="translated">这些信息按字母顺序排列,不分大写或小写。其中一些信息是通用的。不同的地方用%s或其他printf式转义符表示。这些转义符会被字母顺序所忽略,除了字母以外的所有字符也是如此。要查找你的信息,只需忽略任何不是字母的字符。</target>
        </trans-unit>
        <trans-unit id="e3b332cdd50b0075e2980a517442567c35047868" translate="yes" xml:space="preserve">
          <source>The messages from error exits from inside the Perl core are generally more serious, and are not suppressed.</source>
          <target state="translated">从Perl核心内部错误退出的信息一般比较严重,不会被压制。</target>
        </trans-unit>
        <trans-unit id="1808948aa8eaa300120a3b2e59e72e75d61ea383" translate="yes" xml:space="preserve">
          <source>The metaconfig system has its own git repository. Please see its README file in &lt;a href=&quot;http://perl5.git.perl.org/metaconfig.git/&quot;&gt;http://perl5.git.perl.org/metaconfig.git/&lt;/a&gt; for more details.</source>
          <target state="translated">metaconfig系统具有自己的git存储库。有关更多详细信息，请参见&lt;a href=&quot;http://perl5.git.perl.org/metaconfig.git/&quot;&gt;http://perl5.git.perl.org/metaconfig.git/中的&lt;/a&gt;自述文件。</target>
        </trans-unit>
        <trans-unit id="57044926f6935330105dc7655b75810e4319d78e" translate="yes" xml:space="preserve">
          <source>The metanotation &lt;code&gt;a{b,c,d}e&lt;/code&gt; is a shorthand for &lt;code&gt;abe ace ade&lt;/code&gt; . Left to right order is preserved, with results of matches being sorted separately at a low level to preserve this order. As a special case &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt; are passed undisturbed.</source>
          <target state="translated">元符号 &lt;code&gt;a{b,c,d}e&lt;/code&gt; 是 &lt;code&gt;abe ace ade&lt;/code&gt; 的简写。保留了从左到右的顺序，匹配结果在较低的级别上被单独排序以保留此顺序。作为一种特殊情况， &lt;code&gt;{&lt;/code&gt; ， &lt;code&gt;}&lt;/code&gt; 和 &lt;code&gt;{}&lt;/code&gt; 不受干扰地传递。</target>
        </trans-unit>
        <trans-unit id="3047e3773833dff832f2198e8a9edf5e427dcdc4" translate="yes" xml:space="preserve">
          <source>The method &lt;b&gt;simplify_name&lt;/b&gt; is equivalent to &lt;b&gt;basename&lt;/b&gt;, but also strips Perl-like extensions (.pm, .pl, .pod) and extensions like</source>
          <target state="translated">该方法&lt;b&gt;simplify_name&lt;/b&gt;相当于&lt;b&gt;基名&lt;/b&gt;，而且剥离的Perl状延伸（.pm后缀，特等，.POD）和扩展等</target>
        </trans-unit>
        <trans-unit id="81b66f93d3069f9e60e8cef6e91ea8cf83a141d7" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;pretty&lt;/code&gt; is doing object-to-string conversion, so it is natural to overload the operator &lt;code&gt;&quot;&quot;&lt;/code&gt; using this method. However, inside such a method it is not necessary to pretty-print the</source>
          <target state="translated">&lt;code&gt;pretty&lt;/code&gt; 方法正在执行对象到字符串的转换，因此使用此方法来重载运算符 &lt;code&gt;&quot;&quot;&lt;/code&gt; 是很自然的。但是，在这种方法中，不必对打印的内容进行漂亮的打印。</target>
        </trans-unit>
        <trans-unit id="a6763bc5ce44c1cfaff83e339121fc03fa4b9167" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;survey&lt;/code&gt; searches for POD documents in a given set of files and/or directories. This runs the search according to the various options set by the accessors above. (For example, if the &lt;code&gt;inc&lt;/code&gt; attribute is on, as it is by default, then the perl @INC directories are implicitly added to the list of directories (if any) that you specify.)</source>
          <target state="translated">方法 &lt;code&gt;survey&lt;/code&gt; 在给定的文件和/或目录集中搜索POD文档。这将根据上面的访问者设置的各种选项运行搜索。（例如，如果默认启用 &lt;code&gt;inc&lt;/code&gt; 属性，则将perl @INC目录隐式添加到您指定的目录列表（如果有）。）</target>
        </trans-unit>
        <trans-unit id="c2594fdbf7af0dec9dd0b0469d5ba6b9ac83d4b7" translate="yes" xml:space="preserve">
          <source>The method forms return the object itself when called with arguments, so that they can be chained together nicely.</source>
          <target state="translated">方法形式在调用有参数的对象时,会返回对象本身,这样可以很好地连锁在一起。</target>
        </trans-unit>
        <trans-unit id="2dce83e2cc72bad00d236d5c3647c5845395811f" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; $scalar, classname&lt;/code&gt; . Associates a new scalar instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">由命令 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; $scalar, classname&lt;/code&gt; 调用的方法。将新的标量实例与指定的类关联。 &lt;code&gt;LIST&lt;/code&gt; 将代表完成关联所需的其他参数（沿着&lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;和同胞）。</target>
        </trans-unit>
        <trans-unit id="1329855cb3bc4e49bb5ad4447529605d17972380" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; %hash, classname&lt;/code&gt; . Associates a new hash instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">命令 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; %hash, classname&lt;/code&gt; 调用的方法。将新的哈希实例与指定的类关联。 &lt;code&gt;LIST&lt;/code&gt; 将代表完成关联所需的其他参数（沿着&lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;和同胞）。</target>
        </trans-unit>
        <trans-unit id="f4e115efd5b349da6e5daf0e7907f6b8a0251fea" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; *glob, classname&lt;/code&gt; . Associates a new glob instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">由命令 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; *glob, classname&lt;/code&gt; 调用的方法。将新的glob实例与指定的类相关联。 &lt;code&gt;LIST&lt;/code&gt; 将代表完成关联所需的其他参数（沿着&lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;和同胞）。</target>
        </trans-unit>
        <trans-unit id="bf5b5c7ccd1b01e888481ba1e2326ba23ba62558" translate="yes" xml:space="preserve">
          <source>The method may be called as a function (this is the legacy interface) and will then use a singleton as invocant.</source>
          <target state="translated">该方法可以作为一个函数调用(这是传统的接口),然后将使用一个单子作为调用者。</target>
        </trans-unit>
        <trans-unit id="4e8494bae7398a8984704473fee4ce9cba1c67c3" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; are not defined in &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. Tied hashes do not require presence of these methods, but if defined, the methods will be called in proper time, see &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;.</source>
          <target state="translated">未在&lt;b&gt;Tie :: Hash&lt;/b&gt;，&lt;b&gt;Tie :: StdHash&lt;/b&gt;或&lt;b&gt;Tie :: ExtraHash中&lt;/b&gt;定义 &lt;code&gt;UNTIE&lt;/code&gt; 和 &lt;code&gt;DESTROY&lt;/code&gt; 方法。绑定的哈希不需要这些方法的存在，但是如果定义了这些方法，则将在适当的时间调用这些方法，请参见&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="eb0efdfb2d42a690264f248f711dbbf09fd69f9a" translate="yes" xml:space="preserve">
          <source>The methods POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE, and EXISTS are required if the perl operator with the corresponding (but lowercase) name is to operate on the tied array. The &lt;b&gt;Tie::Array&lt;/b&gt; class can be used as a base class to implement the first five of these in terms of the basic methods above. The default implementations of DELETE and EXISTS in &lt;b&gt;Tie::Array&lt;/b&gt; simply &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">如果具有相应（但小写）名称的perl运算符要在绑定数组上进行操作，则需要POP，PUSH，SHIFT，UNSHIFT，SPLICE，DELETE和EXISTS方法。根据上面的基本方法，&lt;b&gt;Tie :: Array&lt;/b&gt;类可以用作基础类来实现其中的前五个。&lt;b&gt;Tie :: Array&lt;/b&gt;中DELETE和EXISTS的默认实现只是 &lt;code&gt;croak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ca020c3e2bd3840f09ecda9c60cedd92ab50da2" translate="yes" xml:space="preserve">
          <source>The methods associated with a file might include &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与文件关联的方法可能包括 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5263ae238fdcff040734aa4eb38a1f937d29acc1" translate="yes" xml:space="preserve">
          <source>The methods make the assumption that there are 24 hours in a day, 7 days in a week, 365.24225 days in a year and 12 months in a year. (from The Calendar FAQ at &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;)</source>
          <target state="translated">这些方法假设一天中有24小时，一周中有7天，一年365.24225天以及一年12个月。（摘自&lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html上&lt;/a&gt;的Calendar FAQ ）</target>
        </trans-unit>
        <trans-unit id="04b489e4d842d7bd01e6f982c6cbb73f631b2bc2" translate="yes" xml:space="preserve">
          <source>The methods provided by this package are designed to be used in conjunction with ExtUtils::MakeMaker. When MakeMaker writes a Makefile, it creates one or more objects that inherit their methods from a package &lt;code&gt;MM&lt;/code&gt; . MM itself doesn't provide any methods, but it ISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating specific packages take the responsibility for all the methods provided by MM_Unix. We are trying to reduce the number of the necessary overrides by defining rather primitive operations within ExtUtils::MM_Unix.</source>
          <target state="translated">该软件包提供的方法旨在与ExtUtils :: MakeMaker结合使用。当MakeMaker编写Makefile时，它将创建一个或多个对象，这些对象从 &lt;code&gt;MM&lt;/code&gt; 包继承其方法。MM本身不提供任何方法，但是它提供了ISA ExtUtils :: MM_Unix类。MM的继承树允许操作特定的软件包负责MM_Unix提供的所有方法。我们正在尝试通过在ExtUtils :: MM_Unix中定义相当原始的操作来减少必要覆盖的次数。</target>
        </trans-unit>
        <trans-unit id="8c66ae4f45a17e24ec4e91baabbe3addbe06fe69" translate="yes" xml:space="preserve">
          <source>The methods return a status value. All return 0 on success. All return -1 to signify an error and set &lt;code&gt;$!&lt;/code&gt; to the exact error code. The return code 1 generally (but not always) means that the key specified did not exist in the database.</source>
          <target state="translated">这些方法返回状态值。成功均返回0。全部返回-1表示错误并设置 &lt;code&gt;$!&lt;/code&gt; 到确切的错误代码。返回代码1通常（但不总是）表示指定的密钥在数据库中不存在。</target>
        </trans-unit>
        <trans-unit id="fbd4260de22fedf44d365a30940fb70d70e7661e" translate="yes" xml:space="preserve">
          <source>The methods return true if the argument is positive or negative, respectively. &lt;code&gt;NaN&lt;/code&gt; is neither positive nor negative, while &lt;code&gt;+inf&lt;/code&gt; counts as positive, and &lt;code&gt;-inf&lt;/code&gt; is negative. A &lt;code&gt;zero&lt;/code&gt; is neither positive nor negative.</source>
          <target state="translated">如果参数分别为正数或负数，则这些方法分别返回true。 &lt;code&gt;NaN&lt;/code&gt; 既不为正也不为负，而 &lt;code&gt;+inf&lt;/code&gt; &lt;code&gt;-inf&lt;/code&gt; 正，-inf为负。甲 &lt;code&gt;zero&lt;/code&gt; 既不积极也不消极的。</target>
        </trans-unit>
        <trans-unit id="6c2ef40bc1a0b74efb3bfbccd9cee9239eba6f64" translate="yes" xml:space="preserve">
          <source>The midpoint between London and Tokyo being</source>
          <target state="translated">伦敦和东京之间的中间点是</target>
        </trans-unit>
        <trans-unit id="bbcb1c9041fb73d5b33a27311e97c3d17c5b0e33" translate="yes" xml:space="preserve">
          <source>The minimal implementation of the package &lt;code&gt;MyMaths&lt;/code&gt; would be something like this:</source>
          <target state="translated">&lt;code&gt;MyMaths&lt;/code&gt; 软件包的最小实现是这样的：</target>
        </trans-unit>
        <trans-unit id="3d4726f2195d659bbd07fd552c77e45ca0215cb6" translate="yes" xml:space="preserve">
          <source>The minimal length of the match.</source>
          <target state="translated">比赛的最小长度。</target>
        </trans-unit>
        <trans-unit id="7a86715e4677adbc552d12f74a0aff8aa19f9b9f" translate="yes" xml:space="preserve">
          <source>The minimal string that will allow both the start of the string &lt;code&gt;^&lt;/code&gt; and the alternation to match is &lt;code&gt;Th&lt;/code&gt; , with the alternation &lt;code&gt;e|r&lt;/code&gt; matching &lt;code&gt;e&lt;/code&gt; . The second quantifier &lt;code&gt;.*&lt;/code&gt; is free to gobble up the rest of the string.</source>
          <target state="translated">允许字符串 &lt;code&gt;^&lt;/code&gt; 的开头和交替都匹配的最小字符串是 &lt;code&gt;Th&lt;/code&gt; ，交替 &lt;code&gt;e|r&lt;/code&gt; 匹配 &lt;code&gt;e&lt;/code&gt; 。第二个量词 &lt;code&gt;.*&lt;/code&gt; 可以自由吞噬字符串的其余部分。</target>
        </trans-unit>
        <trans-unit id="e954716b49cb8b56dd5f1434ce35c364bc034cbd" translate="yes" xml:space="preserve">
          <source>The minimum required version of Perl for this distribution.</source>
          <target state="translated">本发行版对Perl的最低要求版本。</target>
        </trans-unit>
        <trans-unit id="8f285323eacf0d3787ce2842089aae064f612899" translate="yes" xml:space="preserve">
          <source>The minimum severity level set by &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode may be changed to be ERROR or higher in the future depending on the results of testing and further review.</source>
          <target state="translated">由最小严重性级别组 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 模式可被改变为根据测试和进一步审查的结果在未来ERROR或更高。</target>
        </trans-unit>
        <trans-unit id="a0eb7e9cbc117a074d8972fb43eb29ea9f494777" translate="yes" xml:space="preserve">
          <source>The minimum string length (in characters) required for the pattern to match. This is used to prune the search space by not bothering to match any closer to the end of a string than would allow a match. For instance there is no point in even starting the regex engine if the minlen is 10 but the string is only 5 characters long. There is no way that the pattern can match.</source>
          <target state="translated">匹配模式所需的最小字符串长度(以字符为单位)。这个参数用来修剪搜索空间,如果字符串的长度接近尾部,就不会再去匹配。例如,如果最小长度是10,但字符串只有5个字符,那么启动regex引擎就没有意义。模式是不可能匹配的。</target>
        </trans-unit>
        <trans-unit id="210162554d25993f24361ef0d0eb6d7705ae9f1e" translate="yes" xml:space="preserve">
          <source>The mkpath() function provide the legacy interface of make_path() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to make_path().</source>
          <target state="translated">mkpath()函数提供了make_path()的传统接口,但对传递的参数有不同的解释。该函数的行为和返回值与make_path()相同。</target>
        </trans-unit>
        <trans-unit id="06ad56158c8fa5ced75a1aebddb172710774c3d6" translate="yes" xml:space="preserve">
          <source>The mode argument should be a string as would be passed to fopen/PerlIO_open. If it is NULL then - for legacy support - the code will (depending upon the platform and the implementation) either attempt to empirically determine the mode in which</source>
          <target state="translated">mode参数应该是一个字符串,就像传递给fopen/PerlIO_open一样。如果它是NULL,那么--对于传统的支持--代码将(取决于平台和实现)尝试根据经验确定模式,其中</target>
        </trans-unit>
        <trans-unit id="a3c9e181407a3d8dbcbede503e296bb6515c64a6" translate="yes" xml:space="preserve">
          <source>The modern convention for OO modules is to always use &lt;code&gt;new&lt;/code&gt; as the name for the constructor, but there is no requirement to do so. Any subroutine that blesses a data structure into a class is a valid constructor in Perl.</source>
          <target state="translated">OO模块的现代约定是始终使用 &lt;code&gt;new&lt;/code&gt; 作为构造函数的名称，但是没有必要这样做。将数据结构加到类中的任何子例程在Perl中都是有效的构造函数。</target>
        </trans-unit>
        <trans-unit id="3a53357f11465725d38d814ff941d393401ed024" translate="yes" xml:space="preserve">
          <source>The module</source>
          <target state="translated">该模块</target>
        </trans-unit>
        <trans-unit id="39e5705c3d4c65fd8c41a20a40b57ad45ad89ac2" translate="yes" xml:space="preserve">
          <source>The module actually implements most of an interface described by Larry Wall on the perl5-porters mailing list here: &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&lt;/a&gt;</source>
          <target state="translated">该模块实际上实现了Larry Wall在perl5-porters邮件列表上描述的大多数接口：&lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&quot;&gt;http&lt;/a&gt; ://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html</target>
        </trans-unit>
        <trans-unit id="4eac150fbe415255f3cdb34d1744497bc9492853" translate="yes" xml:space="preserve">
          <source>The module also lets you save intermediate SHA states to a string. The</source>
          <target state="translated">该模块还可以让你把中间的SHA状态保存到一个字符串中。该</target>
        </trans-unit>
        <trans-unit id="ee711fa1cc9e23459ad1dea67a4bc2640b9361b2" translate="yes" xml:space="preserve">
          <source>The module and its user have a contract, part of which is common law, and part of which is &quot;written&quot;. Part of the common law contract is that a module doesn't pollute any namespace it wasn't asked to. The written contract for the module (A.K.A. documentation) may make other provisions. But then you know when you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; RedefineTheWorld&lt;/code&gt; that you're redefining the world and willing to take the consequences.</source>
          <target state="translated">该模块及其用户具有合同，其中一部分是普通法，一部分是&amp;ldquo;书面&amp;rdquo;的。普通法合同的一部分是，模块不会污染任何未被要求的名称空间。模块的书面合同（AKA文档）可能另有规定。但是随后您知道，当您 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; RedefineTheWorld&lt;/code&gt; ，您正在重新定义世界并愿意承担后果。</target>
        </trans-unit>
        <trans-unit id="b0f631dbc58be0710de0b64e0128de801aadc778" translate="yes" xml:space="preserve">
          <source>The module appropriate for the current OS is automatically loaded by File::Spec. Since some modules (like VMS) make use of facilities available only under that OS, it may not be possible to load all modules under all operating systems.</source>
          <target state="translated">File::Spec 会自动加载适合当前操作系统的模块。由于有些模块(如VMS)只使用该操作系统下的设施,可能无法加载所有操作系统下的所有模块。</target>
        </trans-unit>
        <trans-unit id="f14f53ac2830f28434b0714747d843bf7a9d032c" translate="yes" xml:space="preserve">
          <source>The module author loves to hear how &lt;code&gt;autodie&lt;/code&gt; has made your life better (or worse). Feedback can be sent to &amp;lt;pjf@perltraining.com.au&amp;gt;.</source>
          <target state="translated">模块作者喜欢听听 &lt;code&gt;autodie&lt;/code&gt; 如何使您的生活变得更好（或更糟）。反馈可以发送到&amp;lt;pjf@perltraining.com.au&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="64e716d94d3201717e95856fa71dba02b691c1e4" translate="yes" xml:space="preserve">
          <source>The module functionality relies on symbolic references, so things will break under 'use strict' unless 'no strict &quot;refs&quot;' is also specified.</source>
          <target state="translated">该模块的功能依赖于符号引用,所以在 &quot;使用严格 &quot;的情况下,除非同时指定 &quot;没有严格的 &quot;refs&quot;&quot;,否则会出现问题。</target>
        </trans-unit>
        <trans-unit id="34dfe6e94b964deab3088dd9f024d26797644959" translate="yes" xml:space="preserve">
          <source>The module is used to replace common UNIX commands. In all cases the functions work from @ARGV rather than taking arguments. This makes them easier to deal with in Makefiles. Call them like this:</source>
          <target state="translated">该模块用于替换常见的UNIX命令。在所有的情况下,函数都是通过@ARGV工作,而不是接受参数。这使得它们在Makefile中更容易处理。像这样调用它们。</target>
        </trans-unit>
        <trans-unit id="c671baea2f821aba32cfc72c5c947bba8fda15dc" translate="yes" xml:space="preserve">
          <source>The module might issue the following warnings:</source>
          <target state="translated">该模块可能会发出以下警告:</target>
        </trans-unit>
        <trans-unit id="06580747828c7d751b4066d4d4c51e0e99e3ed97" translate="yes" xml:space="preserve">
          <source>The module that implements the canned filter can take one of two forms. Here is a template for the first</source>
          <target state="translated">实现罐装过滤器的模块可以采取两种形式之一。这里是第一种形式的模板</target>
        </trans-unit>
        <trans-unit id="aa3f15cb2c51087f06437c33aa4d5adadaa3850c" translate="yes" xml:space="preserve">
          <source>The module will auto-detect which, if any, of the supported compression formats is being used.</source>
          <target state="translated">该模块将自动检测正在使用的压缩格式(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="f166adc5fd8c563e508f523c65a82ae50be2d86f" translate="yes" xml:space="preserve">
          <source>The month (&lt;code&gt;mon&lt;/code&gt; ), weekday (&lt;code&gt;wday&lt;/code&gt; ), and yearday (&lt;code&gt;yday&lt;/code&gt; ) begin at zero,</source>
          <target state="translated">月份（ &lt;code&gt;mon&lt;/code&gt; ），周日（ &lt;code&gt;wday&lt;/code&gt; ）和yearday（ &lt;code&gt;yday&lt;/code&gt; ）开始于零，</target>
        </trans-unit>
        <trans-unit id="7976bab032857556f1afeeb5486bc37536242264" translate="yes" xml:space="preserve">
          <source>The months and years can be negative for subtractions. Note that there is some &quot;strange&quot; behaviour when adding and subtracting months at the ends of months. Generally when the resulting month is shorter than the starting month then the number of overlap days is added. For example subtracting a month from 2008-03-31 will not result in 2008-02-31 as this is an impossible date. Instead you will get 2008-03-02. This appears to be consistent with other date manipulation tools.</source>
          <target state="translated">月和年可以是负数做减法。需要注意的是,在月末加减月份的时候,会有一些 &quot;奇怪 &quot;的行为。一般来说,当得出的月份比起始月份短时,就会加上重叠的天数。例如,从2008-03-31中减去一个月,结果不会是2008-02-31,因为这是个不可能的日期。相反,你会得到2008-03-02。这似乎与其他日期操作工具一致。</target>
        </trans-unit>
        <trans-unit id="6b9450d19149fb47c1c53f97698b4be633a15d56" translate="yes" xml:space="preserve">
          <source>The more you think about interfacing between two languages, the more you'll realize that the majority of programmer effort has to go into converting between the data structures that are native to either of the languages involved. This trumps other matter such as differing calling conventions because the problem space is so much greater. There are simply more ways to shove data into memory than there are ways to implement a function call.</source>
          <target state="translated">你对两种语言之间的接口考虑得越多,你就越会意识到,大部分程序员的努力都是为了在其中一种语言的本地数据结构之间进行转换。这胜过其他事项,比如不同的调用约定,因为问题空间要大得多。把数据塞进内存的方法比实现函数调用的方法多得多。</target>
        </trans-unit>
        <trans-unit id="8176a4ffeb356c4a7a23ddcef37f49bf2bb9d8e2" translate="yes" xml:space="preserve">
          <source>The mortal routines are not just for SVs; AVs and HVs can be made mortal by passing their address (type-casted to &lt;code&gt;SV*&lt;/code&gt; ) to the &lt;code&gt;sv_2mortal&lt;/code&gt; or &lt;code&gt;sv_mortalcopy&lt;/code&gt; routines.</source>
          <target state="translated">凡人的例程不仅适用于SV。通过将其地址（类型 &lt;code&gt;sv_2mortal&lt;/code&gt; 为 &lt;code&gt;SV*&lt;/code&gt; ）传递给sv_2mortal或 &lt;code&gt;sv_mortalcopy&lt;/code&gt; 例程，可以使AV和HV成为凡人。</target>
        </trans-unit>
        <trans-unit id="9a1cfa37e915685db47ff38f6021965013b98c8b" translate="yes" xml:space="preserve">
          <source>The most common CPAN version numbering scheme looks like this:</source>
          <target state="translated">最常见的CPAN版本编号方案是这样的。</target>
        </trans-unit>
        <trans-unit id="2c4361ab99106fa73a1bb41dd2c636e6a27fcbec" translate="yes" xml:space="preserve">
          <source>The most common example of this is changing the current working directory using &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;. One thread calls &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, and the working directory of all the threads changes.</source>
          <target state="translated">最常见的示例是使用 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 更改当前工作目录。一个线程调用 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; ，所有线程的工作目录都会更改。</target>
        </trans-unit>
        <trans-unit id="9f63cc6de2a2448196e1a86a35300d77fbd9cdf9" translate="yes" xml:space="preserve">
          <source>The most common uses of the interactive modes are</source>
          <target state="translated">互动模式最常见的用途是</target>
        </trans-unit>
        <trans-unit id="3870e4765effd8ab5e5da52360ab236ece22162c" translate="yes" xml:space="preserve">
          <source>The most commonly used of these functions is &lt;code&gt;Perl_sv_dump&lt;/code&gt; ; it's used for dumping SVs, AVs, HVs, and CVs. The &lt;code&gt;Devel::Peek&lt;/code&gt; module calls &lt;code&gt;sv_dump&lt;/code&gt; to produce debugging output from Perl-space, so users of that module should already be familiar with its format.</source>
          <target state="translated">这些函数中最常用的是 &lt;code&gt;Perl_sv_dump&lt;/code&gt; ；它用于转储SV，AV，HV和CV。该 &lt;code&gt;Devel::Peek&lt;/code&gt; 模块调用 &lt;code&gt;sv_dump&lt;/code&gt; 以从Perl的空间调试输出，使模块的用户应该已经熟悉了它的格式。</target>
        </trans-unit>
        <trans-unit id="b3104b20dd3af96ae7f833de8c6d7e1e79108b35" translate="yes" xml:space="preserve">
          <source>The most convenient way of installing a binary distribution of perl is via perl installer</source>
          <target state="translated">最方便的安装perl二进制发行版的方法是通过perl安装程序。</target>
        </trans-unit>
        <trans-unit id="8449f9a2d2191f3c7392f9226647d2910704473a" translate="yes" xml:space="preserve">
          <source>The most efficient way is using &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; and &lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;. This is faster than using &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; when taking many, many strings. It is slower for just a few.</source>
          <target state="translated">最有效的方法是使用&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;和&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;。这比使用许多字符串时使用&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;更快。它慢了几个。</target>
        </trans-unit>
        <trans-unit id="22c40808afd7fc4cc79463965386f4682ff94dfa" translate="yes" xml:space="preserve">
          <source>The most hairy case</source>
          <target state="translated">最毛躁的情况</target>
        </trans-unit>
        <trans-unit id="51dfbd93c1252c67b5797f63c0a32f35baffd72d" translate="yes" xml:space="preserve">
          <source>The most important Perl parsing rule is the first one discussed below: when processing a quoted construct, Perl first finds the end of that construct, then interprets its contents. If you understand this rule, you may skip the rest of this section on the first reading. The other rules are likely to contradict the user's expectations much less frequently than this first one.</source>
          <target state="translated">最重要的Perl解析规则是下面讨论的第一条:在处理一个引用的构造体时,Perl首先要找到该构造体的结尾,然后对其内容进行解释。如果你理解了这一规则,你可以在第一遍阅读时跳过本节的其他内容。其他规则与用户期望的矛盾可能比这第一条规则少得多。</target>
        </trans-unit>
        <trans-unit id="aef7d8dbf9d828ab96b855e0061e1f04b9541021" translate="yes" xml:space="preserve">
          <source>The most important attribute of a socket, like your telephone&amp;rsquo;s telephone number. Typically an IP address. See also &lt;b&gt;port&lt;/b&gt;.</source>
          <target state="translated">套接字的最重要属性，例如电话的电话号码。通常是IP地址。另请参阅&lt;b&gt;port&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="8a25c59d901462fca0083edfc964d9c8bf518a04" translate="yes" xml:space="preserve">
          <source>The most important of which are probably GV_ADD and SVf_UTF8.</source>
          <target state="translated">其中最重要的可能是GV_ADD和SVf_UTF8。</target>
        </trans-unit>
        <trans-unit id="1aae52fef16fc25bcc3b6593dc3391e48196f1ad" translate="yes" xml:space="preserve">
          <source>The most important thing is to run your programs under the &lt;b&gt;-w&lt;/b&gt; flag at all times. You may turn it off explicitly for particular portions of code via the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;code&gt;$^W&lt;/code&gt; variable if you must. You should also always run under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; or know the reason why not. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; sigtrap&lt;/code&gt; and even &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; diagnostics&lt;/code&gt; pragmas may also prove useful.</source>
          <target state="translated">最重要的是始终在&lt;b&gt;-w&lt;/b&gt;标志下运行程序。您可以通过 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; 杂注或 &lt;code&gt;$^W&lt;/code&gt; 变量来显式关闭代码的特定部分（如果需要）。您还应该始终在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;下运行，或者知道为什么不这样做。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; sigtrap&lt;/code&gt; 甚至 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; diagnostics&lt;/code&gt; 的pragma也可以证明是有用的。</target>
        </trans-unit>
        <trans-unit id="c6be7df730b69bf2abfbfef25c9c73eef66cdf79" translate="yes" xml:space="preserve">
          <source>The most important thing to understand about all data structures in Perl--including multidimensional arrays--is that even though they might appear otherwise, Perl &lt;code&gt;@ARRAY&lt;/code&gt; s and &lt;code&gt;%HASH&lt;/code&gt; es are all internally one-dimensional. They can hold only scalar values (meaning a string, number, or a reference). They cannot directly contain other arrays or hashes, but instead contain</source>
          <target state="translated">要了解Perl中的所有数据结构（包括多维数组），最重要的事情是，即使它们可能以其他方式出现，Perl &lt;code&gt;@ARRAY&lt;/code&gt; 和 &lt;code&gt;%HASH&lt;/code&gt; 也是内部一维的。它们只能保存标量值（表示字符串，数字或引用）。它们不能直接包含其他数组或哈希，而是包含</target>
        </trans-unit>
        <trans-unit id="ae5f029eca08711d302dd8f17b7e7f9e635b1ec8" translate="yes" xml:space="preserve">
          <source>The most popular books</source>
          <target state="translated">最受欢迎的书籍</target>
        </trans-unit>
        <trans-unit id="c77ae4b23596713f5e5db719e4b12df8a45dd104" translate="yes" xml:space="preserve">
          <source>The most practical use is likely to specify that some tests are not &quot;parallel-ready&quot;. Since mentioning a file with --rules doesn't cause it to be selected to run as a test, you can &quot;set and forget&quot; some rules preferences in your .proverc file. Then you'll be able to take maximum advantage of the performance benefits of parallel testing, while some exceptions are still run in parallel.</source>
          <target state="translated">最实际的用途可能是指定一些测试不是 &quot;并行就绪 &quot;的。由于用--rules提到一个文件并不会导致它被选为测试运行,所以你可以在你的.proverc文件中 &quot;设置并忘记 &quot;一些规则偏好。然后你就可以最大限度地利用并行测试的性能优势,而一些异常情况仍然会以并行方式运行。</target>
        </trans-unit>
        <trans-unit id="6f276b3b1a0cf0e0ed49a901109064669a604004" translate="yes" xml:space="preserve">
          <source>The most preferable one is &quot;The Default Unicode Collation Element Table&quot; (aka DUCET), available from the Unicode Consortium's website:</source>
          <target state="translated">最可取的是 &quot;默认Unicode整理元素表&quot;(又名DUCET),可从Unicode联盟的网站上获得。</target>
        </trans-unit>
        <trans-unit id="1a2b184063d0bc0a35feb7fb346e45c3d6648eb5" translate="yes" xml:space="preserve">
          <source>The most recent development releases of Perl have been experimenting with removing Perl's dependency on the &quot;normal&quot; standard I/O suite and allowing other stdio implementations to be used. This involves creating a new abstraction layer that then calls whichever implementation of stdio Perl was compiled with. All XSUBs should now use the functions in the PerlIO abstraction layer and not make any assumptions about what kind of stdio is being used.</source>
          <target state="translated">最近的Perl开发版本一直在尝试取消Perl对 &quot;普通 &quot;标准I/O套件的依赖,允许使用其他stdio实现。这涉及到创建一个新的抽象层,然后调用Perl编译时使用的任何stdio实现。现在,所有的XSUB都应该使用PerlIO抽象层中的函数,而不是对使用的stdio做任何假设。</target>
        </trans-unit>
        <trans-unit id="d790d27d68eef3be56d3d5afa1a5d1f30d794f18" translate="yes" xml:space="preserve">
          <source>The most recent upgrade to the PA-RISC design, it added support for 64-bit integer data.</source>
          <target state="translated">PA-RISC设计的最新升级,它增加了对64位整数数据的支持。</target>
        </trans-unit>
        <trans-unit id="0603f466834b0d6d823bdd46c3606b7ca755f71a" translate="yes" xml:space="preserve">
          <source>The most recent version of this module, including documentation and any news of importance, will be available at</source>
          <target state="translated">本模块的最新版本,包括文件和任何重要新闻,将在以下网站提供</target>
        </trans-unit>
        <trans-unit id="f4a085ad231e217eed37777279430f48e1cf87a2" translate="yes" xml:space="preserve">
          <source>The most significant information in the output is about the particular</source>
          <target state="translated">输出中最重要的信息是关于特定的</target>
        </trans-unit>
        <trans-unit id="9de43c038dc457f71dc272efc26e8a4eb0e6b17e" translate="yes" xml:space="preserve">
          <source>The most simple options are the ones that take no values. Their mere presence on the command line enables the option. Popular examples are:</source>
          <target state="translated">最简单的选项是那些不取值的选项。仅仅是在命令行中出现的选项就可以启用。常见的例子有:</target>
        </trans-unit>
        <trans-unit id="fe61ded48d4439fb9787ec0d115995f08935a048" translate="yes" xml:space="preserve">
          <source>The most useful option the cross referencer has is to save the report to a separate file. For instance, to save the report on</source>
          <target state="translated">交叉引用器最有用的选项是将报告保存到一个单独的文件中。例如,要将报告保存在</target>
        </trans-unit>
        <trans-unit id="762e20af8acff77775848b01e093c2cac3013ec4" translate="yes" xml:space="preserve">
          <source>The most useful types that will be returned are:</source>
          <target state="translated">将返回的最有用的类型是:</target>
        </trans-unit>
        <trans-unit id="a4f13e9fd0d66b114f604fe2129d7ad6d576d1c5" translate="yes" xml:space="preserve">
          <source>The movement of bits left or right in a computer word, which has the effect of multiplying or dividing by a power of 2.</source>
          <target state="translated">计算机字中位数的左右移动,其效果是乘以或除以2的幂。</target>
        </trans-unit>
        <trans-unit id="811ee2e71fefd4dbb8ec994c3d2df771d4653871" translate="yes" xml:space="preserve">
          <source>The multiple-bracket form does not affect the interpretation of the contents of the formatting code, only how it must end. That means that the examples above are also exactly the same as this:</source>
          <target state="translated">多括号的形式并不影响对格式码内容的解释,只影响其必须如何结束。也就是说,上面的例子也和这个完全一样。</target>
        </trans-unit>
        <trans-unit id="e2632e91c7e1b901a77d044556dbd4ff9d5c87be" translate="yes" xml:space="preserve">
          <source>The name</source>
          <target state="translated">名称</target>
        </trans-unit>
        <trans-unit id="f32c3c3ac333fcf1879195759e18947b403def2d" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;new&lt;/code&gt; isn't special. We could name our constructor something else:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 名称并不特殊。我们可以将构造函数命名为其他名称：</target>
        </trans-unit>
        <trans-unit id="316e7deb3997f109974511d20499a1d93aa6493c" translate="yes" xml:space="preserve">
          <source>The name is returned as a mortal SV.</source>
          <target state="translated">名为凡人SV返回。</target>
        </trans-unit>
        <trans-unit id="e84fcc4ee47e1e1b5639888428e055c00959431a" translate="yes" xml:space="preserve">
          <source>The name may contain embedded E&amp;lt;&amp;gt; and Z&amp;lt;&amp;gt; formatting codes, and the section, anchor text, and inferred anchor text may contain any formatting codes. Any double quotes around the section are removed as part of the parsing, as is any leading or trailing whitespace.</source>
          <target state="translated">该名称可以包含嵌入的E &amp;lt;&amp;gt;和Z &amp;lt;&amp;gt;格式代码，并且节，锚文本和推断的锚文本可以包含任何格式代码。该部分周围的所有双引号都会被作为分析的一部分删除，所有前导或尾随空格也将被删除。</target>
        </trans-unit>
        <trans-unit id="9f683b00c5db230ebae95056480292ae0fa37d30" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;(*SKIP:NAME)&lt;/code&gt; pattern has special significance. If a &lt;code&gt;(*MARK:NAME)&lt;/code&gt; was encountered while matching, then it is that position which is used as the &quot;skip point&quot;. If no &lt;code&gt;(*MARK)&lt;/code&gt; of that name was encountered, then the &lt;code&gt;(*SKIP)&lt;/code&gt; operator has no effect. When used without a name the &quot;skip point&quot; is where the match point was when executing the (*SKIP) pattern.</source>
          <target state="translated">该名称 &lt;code&gt;(*SKIP:NAME)&lt;/code&gt; 模式具有特殊的意义。如果在匹配时遇到 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; ，则该位置将用作&amp;ldquo;跳过点&amp;rdquo;。如果未遇到该名称的 &lt;code&gt;(*MARK)&lt;/code&gt; ，则 &lt;code&gt;(*SKIP)&lt;/code&gt; 运算符无效。不带名称使用时，&amp;ldquo;跳过点&amp;rdquo;是执行（* SKIP）模式时匹配点的位置。</target>
        </trans-unit>
        <trans-unit id="4ffbfa835ecb6cb544ad106cd35f35360cfc377b" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;result_class&lt;/code&gt; . Defaults to &lt;code&gt;App::Prove::State::Result&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;result_class&lt;/code&gt; 的名称。默认为 &lt;code&gt;App::Prove::State::Result&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="689345a6c608b08f0da8c40d1de1f0d6ad537fb4" translate="yes" xml:space="preserve">
          <source>The name of the C subroutine generated which will return the constants. The default is</source>
          <target state="translated">生成的C子程序的名称,它将返回常量。默认值是</target>
        </trans-unit>
        <trans-unit id="24928164de71defca77ef40b5800aabbee56b274" translate="yes" xml:space="preserve">
          <source>The name of the Makefile to be produced. This is used for the second Makefile that will be produced for the MAP_TARGET.</source>
          <target state="translated">要生成的 Makefile 的名称。用于为MAP_TARGET制作的第二个Makefile。</target>
        </trans-unit>
        <trans-unit id="586bd0a2b6cddbba1d51a20c05e33d4e435a88ba" translate="yes" xml:space="preserve">
          <source>The name of the OP, or 'ex-foo' if the OP is a null that used to be a foo.</source>
          <target state="translated">上位机的名称,如果上位机是一个曾经是foo的null,则为 &quot;ex-foo&quot;。</target>
        </trans-unit>
        <trans-unit id="5c8f940ac3ab77f3cca6bf5d7c2332906bee0772" translate="yes" xml:space="preserve">
          <source>The name of the array containing the &lt;b&gt;argument&lt;/b&gt;&lt;b&gt;vector&lt;/b&gt; from the command line. If you use the empty &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator, &lt;code&gt;ARGV&lt;/code&gt; is the name of both the &lt;b&gt;filehandle&lt;/b&gt; used to traverse the arguments and the &lt;b&gt;scalar&lt;/b&gt; containing the name of the current input file.</source>
          <target state="translated">包含命令行中的&lt;b&gt;参数&lt;/b&gt;&lt;b&gt;向量&lt;/b&gt;的数组的名称。如果使用空的 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符，则 &lt;code&gt;ARGV&lt;/code&gt; 既是用于遍历参数的&lt;b&gt;文件句柄&lt;/b&gt;的名称，又是包含当前输入文件的名称的&lt;b&gt;标量&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="c0ef9637fb40c44d741c359416d9acc461c4754b" translate="yes" xml:space="preserve">
          <source>The name of the capability to be output.</source>
          <target state="translated">要输出的能力名称。</target>
        </trans-unit>
        <trans-unit id="65cd22adf72a74a4b456151c3e1d9f81b33d09a6" translate="yes" xml:space="preserve">
          <source>The name of the class to use to aggregate test results. The default is &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;.</source>
          <target state="translated">用于汇总测试结果的类的名称。默认值为&lt;a href=&quot;parser/aggregator&quot;&gt;TAP :: Parser :: Aggregator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eaad217bdc2e240c2b5911f874d90cf603ae7ab9" translate="yes" xml:space="preserve">
          <source>The name of the class to use to format output. The default is &lt;a href=&quot;formatter/console&quot;&gt;TAP::Formatter::Console&lt;/a&gt;, or &lt;a href=&quot;formatter/file&quot;&gt;TAP::Formatter::File&lt;/a&gt; if the output isn't a TTY.</source>
          <target state="translated">用于格式化输出的类的名称。如果输出不是TTY ，则默认值为&lt;a href=&quot;formatter/console&quot;&gt;TAP :: Formatter :: Console&lt;/a&gt;或&lt;a href=&quot;formatter/file&quot;&gt;TAP :: Formatter :: File&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72da2c41641715361491c5ff4abc5e20b2230add" translate="yes" xml:space="preserve">
          <source>The name of the class to use to multiplex tests during parallel testing. The default is &lt;a href=&quot;parser/multiplexer&quot;&gt;TAP::Parser::Multiplexer&lt;/a&gt;.</source>
          <target state="translated">在并行测试期间用于复用测试的类的名称。默认值为&lt;a href=&quot;parser/multiplexer&quot;&gt;TAP :: Parser :: Multiplexer&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf5c1530a58c08454895ba69cebd216b2fda858b" translate="yes" xml:space="preserve">
          <source>The name of the class to use to parse TAP. The default is &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="translated">用于解析TAP的类的名称。默认值为&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c363903c8b428e2f92b68d74a94f7359ac65693" translate="yes" xml:space="preserve">
          <source>The name of the class to use to schedule test execution. The default is &lt;a href=&quot;parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="translated">用于计划测试执行的类的名称。默认值为&lt;a href=&quot;parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="be46c0fe1db34418e8697bff77cb46ef2046a9fa" translate="yes" xml:space="preserve">
          <source>The name of the constant, as seen by the perl code.</source>
          <target state="translated">常量的名称,如perl代码所示。</target>
        </trans-unit>
        <trans-unit id="4720e470b7493414aa6c88cde788462359384401" translate="yes" xml:space="preserve">
          <source>The name of the current report format for the currently selected output channel. The default format name is the same as the filehandle name. For example, the default format name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is just &lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">当前所选输出通道的当前报告格式的名称。默认格式名称与文件句柄名称相同。例如， &lt;code&gt;STDOUT&lt;/code&gt; 文件句柄的默认格式名称仅为 &lt;code&gt;STDOUT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6e5170077c0838d812432a43efc57d6e9e83c1c" translate="yes" xml:space="preserve">
          <source>The name of the current top-of-page format for the currently selected output channel. The default is the name of the filehandle with &lt;code&gt;_TOP&lt;/code&gt; appended. For example, the default format top name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is &lt;code&gt;STDOUT_TOP&lt;/code&gt; .</source>
          <target state="translated">当前所选输出通道的当前页面顶部格式的名称。默认值是附加了 &lt;code&gt;_TOP&lt;/code&gt; 的文件句柄的名称。例如， &lt;code&gt;STDOUT&lt;/code&gt; 文件句柄的默认格式名称为 &lt;code&gt;STDOUT_TOP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6379fb4c9e525f705c12afeef2d60c9f65c93af3" translate="yes" xml:space="preserve">
          <source>The name of the default local file, that $ff-&amp;gt;output_file falls back to if it would otherwise return no filename. For example when fetching a URI like &lt;a href=&quot;http://www.abc.net.au/&quot;&gt;http://www.abc.net.au/&lt;/a&gt; the contents retrieved may be from a remote file called 'index.html'. The default value of this attribute is literally 'file_default'.</source>
          <target state="translated">默认本地文件的名称，$ ff-&amp;gt; output_file会回退到该名称，否则它将不返回任何文件名。例如，当获取诸如&lt;a href=&quot;http://www.abc.net.au/&quot;&gt;http://www.abc.net.au/&lt;/a&gt;的URI时，检索到的内容可能来自名为&amp;ldquo; index.html&amp;rdquo;的远程文件。该属性的默认值为&amp;ldquo; file_default&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1ec9b1148eb41355676951fe5003b4832073d292" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the C code. The default is &lt;code&gt;const-c.inc&lt;/code&gt; . The &lt;code&gt;-&lt;/code&gt; in the name ensures that the file can't be mistaken for anything related to a legitimate perl package name, and not naming the file &lt;code&gt;.c&lt;/code&gt; avoids having to override Makefile.PL's &lt;code&gt;.xs&lt;/code&gt; to &lt;code&gt;.c&lt;/code&gt; rules.</source>
          <target state="translated">包含C代码的要写入文件的名称。默认值为 &lt;code&gt;const-c.inc&lt;/code&gt; 。名称中的 &lt;code&gt;-&lt;/code&gt; 确保文件不会被误认为与合法的perl软件包名称相关的任何内容，并且不命名文件 &lt;code&gt;.c&lt;/code&gt; 避免了将Makefile.PL的 &lt;code&gt;.xs&lt;/code&gt; 覆盖为 &lt;code&gt;.c&lt;/code&gt; 规则。</target>
        </trans-unit>
        <trans-unit id="2bed22db2d9895f574b197dc49845a9793eb5ff4" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the XS code. The default is &lt;code&gt;const-xs.inc&lt;/code&gt; .</source>
          <target state="translated">包含XS代码的要写入文件的名称。默认值为 &lt;code&gt;const-xs.inc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6d500a8c6262466b93b5ca84e3fdd9132c3d42c" translate="yes" xml:space="preserve">
          <source>The name of the file you want to tie to the hash.</source>
          <target state="translated">你想绑定到哈希值的文件名。</target>
        </trans-unit>
        <trans-unit id="264313247d929c3123a9e7fe3982f9c4d6734ea2" translate="yes" xml:space="preserve">
          <source>The name of the file.</source>
          <target state="translated">文件的名称。</target>
        </trans-unit>
        <trans-unit id="2fed9b5e3d1ecfa444bc4bf0c0867e79f9d251bc" translate="yes" xml:space="preserve">
          <source>The name of the interior sequence command.</source>
          <target state="translated">内部序列命令的名称。</target>
        </trans-unit>
        <trans-unit id="850e998443ed95a332bbac695731c9e48b93fd64" translate="yes" xml:space="preserve">
          <source>The name of the label is returned in the form of a fresh scalar. If an optional label is absent, a null pointer is returned.</source>
          <target state="translated">标签的名称以新标量的形式返回。如果没有可选的标签,则返回一个空指针。</target>
        </trans-unit>
        <trans-unit id="73fad9a569b3c6f7964969b809a10335f9888518" translate="yes" xml:space="preserve">
          <source>The name of the layer whose open() method Perl should invoke on open(). For example if the layer is called APR, you will call:</source>
          <target state="translated">在open()时,Perl应该调用其open()方法的层的名称。例如,如果这个图层被称为APR,你将调用。</target>
        </trans-unit>
        <trans-unit id="72863e084ba8d90c496ae5c6484f120959926659" translate="yes" xml:space="preserve">
          <source>The name of the method</source>
          <target state="translated">方法的名称</target>
        </trans-unit>
        <trans-unit id="e4c23f5fa4cbd2a24c92f584213f4e01a597f939" translate="yes" xml:space="preserve">
          <source>The name of the module you wish to verify -- this is a required key</source>
          <target state="translated">您要验证的模块名称--这是一个必要的关键。</target>
        </trans-unit>
        <trans-unit id="917bce2995f64faec20b4096ae916c3c8efb0bec" translate="yes" xml:space="preserve">
          <source>The name of the operating system under which this copy of Perl was built, as determined during the configuration process. For examples see &lt;a href=&quot;perlport#PLATFORMS&quot;&gt;PLATFORMS in perlport&lt;/a&gt;.</source>
          <target state="translated">在配置过程中确定的构建Perl副本的操作系统的名称。有关示例，请参见&lt;a href=&quot;perlport#PLATFORMS&quot;&gt;perlport中的PLATFORMS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2040df0b9281e990b52b6ffee0618e248f91a919" translate="yes" xml:space="preserve">
          <source>The name of the output file. This is the same as $ff-&amp;gt;file, but any query parameters are stripped off. For example:</source>
          <target state="translated">输出文件的名称。这与$ ff-&amp;gt; file相同，但是会删除所有查询参数。例如：</target>
        </trans-unit>
        <trans-unit id="cbe18d7ad69e81d6c826df352db92d6f22fccd8c" translate="yes" xml:space="preserve">
          <source>The name of the program being documented is conventionally written in bold (using B&amp;lt;&amp;gt;) wherever it occurs, as are all program options. Arguments should be written in italics (I&amp;lt;&amp;gt;). Function names are traditionally written in italics; if you write a function as function(), Pod::Man will take care of this for you. Literal code or commands should be in C&amp;lt;&amp;gt;. References to other man pages should be in the form &lt;code&gt;manpage(section)&lt;/code&gt; or &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt; , and Pod::Man will automatically format those appropriately. The second form, with L&amp;lt;&amp;gt;, is used to request that a POD formatter make a link to the man page if possible. As an exception, one normally omits the section when referring to module documentation since it's not clear what section module documentation will be in; use &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; for module references instead.</source>
          <target state="translated">记录的程序的名称通常会以粗体显示（使用B &amp;lt;&amp;gt;），所有程序选项也是如此。参数应以斜体（I &amp;lt;&amp;gt;）书写。函数名称传统上用斜体写；如果您将函数编写为function（），则Pod :: Man将为您解决此问题。文字代码或命令应位于C &amp;lt;&amp;gt;中。对其他手册页的引用应采用 &lt;code&gt;manpage(section)&lt;/code&gt; 或 &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt; ，并且Pod :: Man将自动将其格式正确。第二种形式，带有L &amp;lt;&amp;gt;，用于请求POD格式化程序在可能的情况下建立指向手册页的链接。作为例外，通常在引用模块文档时会省略该部分，因为尚不清楚模块文档将位于哪个部分。用 &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; 代替模块引用。</target>
        </trans-unit>
        <trans-unit id="7d1dece7f57632e56f321f082b4b7487de40077a" translate="yes" xml:space="preserve">
          <source>The name of the program currently executing, as typed on the command line. In C, the &lt;b&gt;command&lt;/b&gt; name is passed to the program as the first command-line argument. In Perl, it comes in separately as &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="translated">在命令行上键入的当前正在执行的程序的名称。在C语言中，&lt;b&gt;命令&lt;/b&gt;名称作为第一个命令行参数传递给程序。在Perl中，它作为 &lt;code&gt;$0&lt;/code&gt; 单独出现。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
