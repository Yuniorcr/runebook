<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d7a3ea6043299cfce500bdda50fb23f6cbea5c5c" translate="yes" xml:space="preserve">
          <source>Initialize MAKE from either a MAKE environment variable or $Config{make}.</source>
          <target state="translated">通过MAKE环境变量或$Config{make}来初始化MAKE。</target>
        </trans-unit>
        <trans-unit id="8a7c7a1b384ad47d60773edd82ad26376d621207" translate="yes" xml:space="preserve">
          <source>Initialize any macros which are for platform specific use only.</source>
          <target state="translated">初始化任何仅用于平台特定用途的宏。</target>
        </trans-unit>
        <trans-unit id="4476040d6adc770412cdb2150cb39c32735c92d5" translate="yes" xml:space="preserve">
          <source>Initialize macros representing versions of MakeMaker and other tools</source>
          <target state="translated">初始化代表MakeMaker和其他工具版本的宏。</target>
        </trans-unit>
        <trans-unit id="fa2a269c8bcaa8f7394ce2454e1f32bd30c51822" translate="yes" xml:space="preserve">
          <source>Initialize macros which have to do with linking.</source>
          <target state="translated">初始化与链接有关的宏。</target>
        </trans-unit>
        <trans-unit id="cf8b76ad5759b00cf83505f7cf706fcbd53a36ab" translate="yes" xml:space="preserve">
          <source>Initialize the SigSet object to be empty.</source>
          <target state="translated">初始化SigSet对象为空。</target>
        </trans-unit>
        <trans-unit id="553a04fdd695ae3cee805a386f6c72d5ee7c6e5d" translate="yes" xml:space="preserve">
          <source>Initialize the SigSet object to include all signals.</source>
          <target state="translated">初始化SigSet对象以包含所有信号。</target>
        </trans-unit>
        <trans-unit id="7ff28902a2edd7a86041272b550eea681cfd2a0b" translate="yes" xml:space="preserve">
          <source>Initializes AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE, EXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_*, INSTALL*, INSTALLDIRS, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME, OBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB, PERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION, VERSION_SYM, XS_VERSION.</source>
          <target state="translated">初始化AR,AR_STATIC_ARGS,BASEEXT,CONFIG,DISTNAME,DLBASE,EXE_EXT,FULLEXT,FULLPERL,FULLPERLRUN,FULLPERLRUNINST,INST_*,INSTALL*,INSTALLDIRS,LIB_EXT。LIBPERL_A,MAP_TARGET,NAME,OBJ_EXT,PARENT_NAME,PERL,PERL_ARCHLIB,PERL_INC,PERL_LIB,PERL_SRC,PERLRUN,PERLRUNINST,PREFIX,VERSION,VERSION_SYM,XS_VERSION。</target>
        </trans-unit>
        <trans-unit id="9b0af4794c1652a453537aa4d31bc51217044cfb" translate="yes" xml:space="preserve">
          <source>Initializes MAN1PODS from the list of EXE_FILES.</source>
          <target state="translated">从EXE_FILES列表中初始化MAN1PODS。</target>
        </trans-unit>
        <trans-unit id="9908a02e0ec97a9887147642e25f6d00ba2bba87" translate="yes" xml:space="preserve">
          <source>Initializes MAN3PODS from the list of PM files.</source>
          <target state="translated">从PM文件列表中初始化MAN3PODS。</target>
        </trans-unit>
        <trans-unit id="78aa0c8b31d0aa9e4f082b472e25049793a28d4c" translate="yes" xml:space="preserve">
          <source>Initializes PMLIBDIRS and PM from PMLIBDIRS.</source>
          <target state="translated">从PMLIBDIRS初始化PMLIBDIRS和PM。</target>
        </trans-unit>
        <trans-unit id="f52193e05865340eb9150e274aa92320b071b3c6" translate="yes" xml:space="preserve">
          <source>Initializes a new Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">初始化新的Perl解释器。见&lt;a href=&quot;perlembed&quot;&gt;临危&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d157e4855cf1cd1f0584d861b76b87bbd1430bbd" translate="yes" xml:space="preserve">
          <source>Initializes a new object. This method is a stub by default, you should override it as appropriate.</source>
          <target state="translated">初始化一个新对象。这个方法默认是个存根,你应该适当地覆盖它。</target>
        </trans-unit>
        <trans-unit id="9cf6c0c33242d2abf005967a6623b3ae8501f304" translate="yes" xml:space="preserve">
          <source>Initializes the DIRFILESEP macro which is the separator between the directory and filename in a filepath. ie. / on Unix, \ on Win32 and nothing on VMS.</source>
          <target state="translated">初始化DIRFILESEP宏,它是文件路径中目录和文件名之间的分隔符,即在Unix上是/,在Win32上是\,在VMS上是无。</target>
        </trans-unit>
        <trans-unit id="1f6be944d9e52d97024d9034508b4cacc682c441" translate="yes" xml:space="preserve">
          <source>Initializes the macro definitions having to do with compiling and linking used by tools_other() and places them in the $MM object.</source>
          <target state="translated">初始化与 tools_other()使用的编译和链接有关的宏定义,并将它们放在 $MM 对象中。</target>
        </trans-unit>
        <trans-unit id="e775d4b4b0bd3712f9f514299a1d05c1a00cf523" translate="yes" xml:space="preserve">
          <source>Initializes the simple macro definitions used by tools_other() and places them in the $MM object. These use conservative cross platform versions and should be overridden with platform specific versions for performance.</source>
          <target state="translated">初始化 tools_other()所使用的简单宏定义,并将其放置在 $MM 对象中。这些定义使用了保守的跨平台版本,为了保证性能,应该用特定平台的版本来覆盖。</target>
        </trans-unit>
        <trans-unit id="282f9af1f24130bc9182b79671b3debcbe420b2a" translate="yes" xml:space="preserve">
          <source>Initializes tools to use their common (and faster) Unix commands.</source>
          <target state="translated">初始化工具以使用其常用(和更快)的Unix命令。</target>
        </trans-unit>
        <trans-unit id="7a196e34c731e5f3af1e31be4705513bd9e1800a" translate="yes" xml:space="preserve">
          <source>Initializing Function Parameters</source>
          <target state="translated">初始化函数参数</target>
        </trans-unit>
        <trans-unit id="f762e2df9b5c50638aa3c3cbbaf63d08b1a096ce" translate="yes" xml:space="preserve">
          <source>Initializing with &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">用 &lt;code&gt;new&lt;/code&gt; 初始化</target>
        </trans-unit>
        <trans-unit id="5374c9bb7d82a306aff38df30638934a3bedb34d" translate="yes" xml:space="preserve">
          <source>Initializing with new</source>
          <target state="translated">初始化与新</target>
        </trans-unit>
        <trans-unit id="16e4c7e9d2fa46d1492e494337cfb9b14642fd7d" translate="yes" xml:space="preserve">
          <source>Initiate the sending of the data from the current message.</source>
          <target state="translated">启动当前消息的数据发送。</target>
        </trans-unit>
        <trans-unit id="b6b3360634a6df83161df89335cce0e40b6cc3dd" translate="yes" xml:space="preserve">
          <source>Initiates a TCP connection, for a tcp ping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe9280fcef1f95066c459792b601f0a568c68ff3" translate="yes" xml:space="preserve">
          <source>Inplace editing &lt;code&gt;perl -i&lt;/code&gt; of files doesn't work without doing a backup of the file being edited &lt;code&gt;perl -i.bak&lt;/code&gt; because of windowish restrictions, therefore Perl adds the suffix &lt;code&gt;.bak&lt;/code&gt; automatically if you use &lt;code&gt;perl -i&lt;/code&gt; without specifying a backup extension.</source>
          <target state="translated">由于 &lt;code&gt;perl -i.bak&lt;/code&gt; 限制，如果不对正在编辑的文件perl -i.bak进行备份，就不能进行文件就地编辑 &lt;code&gt;perl -i&lt;/code&gt; ，因此，如果您使用 &lt;code&gt;perl -i&lt;/code&gt; 而未指定备份扩展名，则Perl会自动添加后缀 &lt;code&gt;.bak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="f2166976e1182028cf4a602c00df0206990e4b61" translate="yes" xml:space="preserve">
          <source>Input File Glob</source>
          <target state="translated">输入文件全球</target>
        </trans-unit>
        <trans-unit id="b6852c995fba635b92f942abb161a06e4a4f682b" translate="yes" xml:space="preserve">
          <source>Input and Output Layers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc35a576a410b10bc60ae6d2130c68130a12559" translate="yes" xml:space="preserve">
          <source>Input and Output Parameters</source>
          <target state="translated">输入和输出参数</target>
        </trans-unit>
        <trans-unit id="c77783bb0c7d4d2f9b2b8bd6478b069981c0866f" translate="yes" xml:space="preserve">
          <source>Input and output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d4856593d1efd1c0cd8430882cae3851f3f706" translate="yes" xml:space="preserve">
          <source>Input and output functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca6ebb3af2e2ddf731c9ba341152d5ee6d08083" translate="yes" xml:space="preserve">
          <source>Input and output pipes to Perl filehandles are supported; the &quot;file name&quot; is passed to lib$spawn() for asynchronous execution. You should be careful to close any pipes you have opened in a Perl script, lest you leave any &quot;orphaned&quot; subprocesses around when Perl exits.</source>
          <target state="translated">支持指向 Perl 文件柄的输入和输出管道;&quot;文件名 &quot;会被传递给 lib$spawn()用于异步执行。你应该小心关闭在 Perl 脚本中打开的任何管道,以免在 Perl 退出时留下任何 &quot;孤儿 &quot;子进程。</target>
        </trans-unit>
        <trans-unit id="25e7b83bd15298faf6fd8f002de9128fb08ea38f" translate="yes" xml:space="preserve">
          <source>Input from, or output to, a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;device&lt;/b&gt;.</source>
          <target state="translated">来自&lt;b&gt;文件&lt;/b&gt;或&lt;b&gt;设备的&lt;/b&gt;输入或输出。</target>
        </trans-unit>
        <trans-unit id="78a923bcd93c4171316cc3a1bc09d0aa6f07ef83" translate="yes" xml:space="preserve">
          <source>Input given as scalar numbers might lose precision. Quote your input to ensure that no digits are lost:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6047072eebf842c882d2d1ca55ea7667206a889" translate="yes" xml:space="preserve">
          <source>Input library and path specifications are accepted with or without the &lt;code&gt;-l&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; prefixes used by Unix linkers.</source>
          <target state="translated">接受或不包含Unix链接程序使用的 &lt;code&gt;-l&lt;/code&gt; 和 &lt;code&gt;-L&lt;/code&gt; 前缀的输入库和路径规范。</target>
        </trans-unit>
        <trans-unit id="db35c0f2c45290c19fd136029a213ad284b80e55" translate="yes" xml:space="preserve">
          <source>Input library and path specifications are accepted with or without the &lt;code&gt;-l&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; prefixes used by Unix linkers. If neither prefix is present, a token is considered a directory to search if it is in fact a directory, and a library to search for otherwise. Authors who wish their extensions to be portable to Unix or OS/2 should use the Unix prefixes, since the Unix-OS/2 version of ext() requires them.</source>
          <target state="translated">接受或不包含Unix链接程序使用的 &lt;code&gt;-l&lt;/code&gt; 和 &lt;code&gt;-L&lt;/code&gt; 前缀的输入库和路径规范。如果两个前缀都不存在，则将令牌视为要搜索的目录，如果它实际上是目录，则将其视为要搜索的库。希望其扩展可移植到Unix或OS / 2的作者应使用Unix前缀，因为ext（）的Unix-OS / 2版本需要它们。</target>
        </trans-unit>
        <trans-unit id="a1f8b7d0598aac2b8e4ba4b9244e4a933dc9e6b4" translate="yes" xml:space="preserve">
          <source>Input strings are decode()d then encode()d. A straight two-step implementation.</source>
          <target state="translated">输入的字符串是解码()d然后再编码()d。直接两步实现。</target>
        </trans-unit>
        <trans-unit id="ff3057c52ba4da6e1ddf88eb538e9f34e59f7ee9" translate="yes" xml:space="preserve">
          <source>Input to these routines are either BigFloat objects, or strings of the following four forms:</source>
          <target state="translated">这些例程的输入可以是BigFloat对象,也可以是以下四种形式的字符串。</target>
        </trans-unit>
        <trans-unit id="84961be9b7c2809d89e0848f01fd0ffc9df02327" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any scalar number or string that looks like a number and represents a floating point number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2156929b7310422c8528b3fc6dfc3918a5f73f99" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any scalar number or string that looks like a number and represents an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0281be753361164d1d0fc4c9f4d612cf39dd2d" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any string, that looks like a number and results in an integer, including hexadecimal and binary numbers.</source>
          <target state="translated">这些例程的输入值可以是任何字符串,看起来像一个数字,结果是一个整数,包括十六进制和二进制数字。</target>
        </trans-unit>
        <trans-unit id="ff508ce692e1254966736e47898113545150b2ac" translate="yes" xml:space="preserve">
          <source>Insecure $ENV{%s} while running %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f2e8a9a0eb4ece5b87faf1da95aff5e83b5fa4" translate="yes" xml:space="preserve">
          <source>Insecure dependency in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931ce1c7f1f13e481922a26677a26bb4773219c6" translate="yes" xml:space="preserve">
          <source>Insecure directory in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb11eae387cd5cce06293624d01344e1072d48a" translate="yes" xml:space="preserve">
          <source>Insecure user-defined property %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ede375a150e967e64e7e2d887a232d51f368fa" translate="yes" xml:space="preserve">
          <source>Insert LIST elements at the beginning of the array, moving existing elements up to make room.</source>
          <target state="translated">在数组的开头插入LIST元素,将现有元素向上移动以腾出空间。</target>
        </trans-unit>
        <trans-unit id="8b5af2a8ac2266ac1fdb8694203bf8a7b5999fb5" translate="yes" xml:space="preserve">
          <source>Insert LIST elements at the beginning of the array, moving existing elements up to make room. For example:</source>
          <target state="translated">在数组的开头插入LIST元素,将现有元素向上移动以腾出空间。例如:</target>
        </trans-unit>
        <trans-unit id="065f57756426a11d3de09e3d897a1322f51a5123" translate="yes" xml:space="preserve">
          <source>Insert characters into the lexer buffer (&lt;a href=&quot;#PL_parser-%3Elinestr&quot;&gt;&quot;PL_parser-&amp;gt;linestr&quot;&lt;/a&gt;), immediately after the current lexing point (&lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt;bufptr&quot;&lt;/a&gt;), reallocating the buffer if necessary. This means that lexing code that runs later will see the characters as if they had appeared in the input. It is not recommended to do this as part of normal parsing, and most uses of this facility run the risk of the inserted characters being interpreted in an unintended manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8d991df77bf00e29c21cb93175839fa481ea2b" translate="yes" xml:space="preserve">
          <source>Insert characters into the lexer buffer (&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;), immediately after the current lexing point (&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt;), reallocating the buffer if necessary. This means that lexing code that runs later will see the characters as if they had appeared in the input. It is not recommended to do this as part of normal parsing, and most uses of this facility run the risk of the inserted characters being interpreted in an unintended manner.</source>
          <target state="translated">将字符插入到词法分析器缓冲区（&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt;）中，紧接在当前词法分析点（&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt;）之后，如有必要，请重新分配缓冲区。这意味着稍后运行的词法分析代码将看到字符，就好像它们已出现在输入中一样。不建议将其作为常规解析的一部分进行，并且此功能的大多数使用都存在插入字符被意外解释的风险。</target>
        </trans-unit>
        <trans-unit id="d46d273f43c1298f3a09e3049502d6b87af98707" translate="yes" xml:space="preserve">
          <source>Inserting POD, Comments and C Preprocessor Directives</source>
          <target state="translated">插入POD、注释和C预处理器指令</target>
        </trans-unit>
        <trans-unit id="3ddc278de0a82017be1546343c053adba747b534" translate="yes" xml:space="preserve">
          <source>Inserting records that</source>
          <target state="translated">插入以下记录</target>
        </trans-unit>
        <trans-unit id="762d7f10b7a5cbbfbd3a51bba1f8d6e37c660a81" translate="yes" xml:space="preserve">
          <source>Inserts a string at the specified offset/length within the SV. Similar to the Perl substr() function. Handles get magic.</source>
          <target state="translated">在SV中以指定的偏移量/长度插入一个字符串。类似于Perl中的substr()函数。处理get魔术。</target>
        </trans-unit>
        <trans-unit id="0ae14887402eb591db68a2439f3f3fdfb3b0176f" translate="yes" xml:space="preserve">
          <source>Inserts and/or replaces a string at the specified offset/length within the SV. Similar to the Perl &lt;code&gt;substr()&lt;/code&gt; function, with &lt;code&gt;littlelen&lt;/code&gt; bytes starting at &lt;code&gt;little&lt;/code&gt; replacing &lt;code&gt;len&lt;/code&gt; bytes of the string in &lt;code&gt;bigstr&lt;/code&gt; starting at &lt;code&gt;offset&lt;/code&gt;. Handles get magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3e05759f66cf1dafff1c764cc8c3b6a42a2c61" translate="yes" xml:space="preserve">
          <source>Inserts the sharpbang or equivalent magic number to a set of @files.</source>
          <target state="translated">将锐邦或等效的魔数插入到一组@文件中。</target>
        </trans-unit>
        <trans-unit id="bfb7a36a7ca33fb28f326fe5eacde6cacf000521" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;(?{...})&lt;/code&gt; block, &lt;code&gt;$_&lt;/code&gt; refers to the string the regular expression is matching against. You can also use &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; to know what is the current position of matching within this string.</source>
          <target state="translated">在 &lt;code&gt;(?{...})&lt;/code&gt; 块中， &lt;code&gt;$_&lt;/code&gt; 表示正则表达式要匹配的字符串。您还可以使用 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 来了解此字符串中匹配项的当前位置。</target>
        </trans-unit>
        <trans-unit id="9e74660978326d8205b1966918b272dc20370085" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;(?{...})&lt;/code&gt; block, &lt;code&gt;$_&lt;/code&gt; refers to the string the regular expression is matching against. You can also use &lt;code&gt;pos()&lt;/code&gt; to know what is the current position of matching within this string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56e96c79858e86c827cc4e174ee077ce93a7306" translate="yes" xml:space="preserve">
          <source>Inside a Perl program, you can use the &lt;a href=&quot;ExtUtils::Installed&quot;&gt;ExtUtils::Installed&lt;/a&gt; module to show all installed distributions, although it can take awhile to do its magic. The standard library which comes with Perl just shows up as &quot;Perl&quot; (although you can get those with &lt;a href=&quot;Module::CoreList&quot;&gt;Module::CoreList&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f1ba3b99ef99e8ed328c9a98bf927d5f0a5518" translate="yes" xml:space="preserve">
          <source>Inside a Perl program, you can use the &lt;a href=&quot;extutils/installed&quot;&gt;ExtUtils::Installed&lt;/a&gt; module to show all installed distributions, although it can take awhile to do its magic. The standard library which comes with Perl just shows up as &quot;Perl&quot; (although you can get those with &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt;).</source>
          <target state="translated">在Perl程序中，您可以使用&lt;a href=&quot;extutils/installed&quot;&gt;ExtUtils :: Installed&lt;/a&gt;模块来显示所有已安装的发行版，尽管这可能需要一些时间才能完成。Perl附带的标准库只是显示为&amp;ldquo; Perl&amp;rdquo;（尽管您可以使用&lt;a href=&quot;module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt;获得它们）。</target>
        </trans-unit>
        <trans-unit id="2ac6e4915bcad5900cd6401a5966f997e137a0c9" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; code block, &lt;code&gt;$?&lt;/code&gt; contains the value that the program is going to pass to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; to change the exit value of the program. Beware of changing &lt;code&gt;$?&lt;/code&gt; by accident (e.g. by running something via &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">在 &lt;code&gt;END&lt;/code&gt; 代码块中， &lt;code&gt;$?&lt;/code&gt; 包含程序要传递给 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 的值。您可以修改 &lt;code&gt;$?&lt;/code&gt; 更改程序的退出值。当心改变 &lt;code&gt;$?&lt;/code&gt; 偶然（例如通过 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 运行某些东西）。</target>
        </trans-unit>
        <trans-unit id="bf5fff32ec45447a013d87f1e68934fda177610e" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; code block, &lt;code&gt;$?&lt;/code&gt; contains the value that the program is going to pass to &lt;code&gt;exit()&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; to change the exit value of the program. Beware of changing &lt;code&gt;$?&lt;/code&gt; by accident (e.g. by running something via &lt;code&gt;system&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3aa49ae51d12807c062f5debba3be515ca72cb" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; subroutine &lt;code&gt;$?&lt;/code&gt; contains the value that is going to be given to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; in an &lt;code&gt;END&lt;/code&gt; subroutine to change the exit status of your program. For example:</source>
          <target state="translated">在 &lt;code&gt;END&lt;/code&gt; 子程序 &lt;code&gt;$?&lt;/code&gt; 包含将要提供给 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 的值。您可以修改 &lt;code&gt;$?&lt;/code&gt; 在 &lt;code&gt;END&lt;/code&gt; 子程序中更改程序的退出状态。例如：</target>
        </trans-unit>
        <trans-unit id="ad96dc469c005e6c9269282065dbe2d978332531" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; subroutine &lt;code&gt;$?&lt;/code&gt; contains the value that is going to be given to &lt;code&gt;exit()&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; in an &lt;code&gt;END&lt;/code&gt; subroutine to change the exit status of your program. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3aafbb284a68739c4fb1ae1f60eb5141dcdda7" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;CHECK&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; .</source>
          <target state="translated">里面的 &lt;code&gt;CHECK&lt;/code&gt; 块，价值 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 将 &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67ca3322bfb1e33afbca0ac9de2636f604c7b47b" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;CHECK&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77fd9286042f60d2513d71db2f202e6d15711855" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;END&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;END&quot;&lt;/code&gt; .</source>
          <target state="translated">里面的 &lt;code&gt;END&lt;/code&gt; 块，价值 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 将 &lt;code&gt;&quot;END&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40747b8f72c39fcb02dd5eb53c21ee80332129f2" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;END&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;END&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a193b063515ab15da965bd3478de34c4b7d0830" translate="yes" xml:space="preserve">
          <source>Inside of an &lt;code&gt;INIT&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; .</source>
          <target state="translated">一个内部 &lt;code&gt;INIT&lt;/code&gt; 块，价值 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 将 &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dee2a938cbad68208b1a78048519d4dcb40a2614" translate="yes" xml:space="preserve">
          <source>Inside of an &lt;code&gt;INIT&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;INIT&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24121a7266e78f12986b250ed98974d9cfcc24b" translate="yes" xml:space="preserve">
          <source>Inside such a</source>
          <target state="translated">在这样一个</target>
        </trans-unit>
        <trans-unit id="f7a01b93c52f9dee6e4b496cdb9ca5fafa7aa5b5" translate="yes" xml:space="preserve">
          <source>Inside the Perl core (&lt;code&gt;PERL_CORE&lt;/code&gt; defined), you can get at the functions either with or without the &lt;code&gt;Perl_&lt;/code&gt; prefix, thanks to a bunch of defines that live in</source>
          <target state="translated">在Perl内核中（定义了 &lt;code&gt;PERL_CORE&lt;/code&gt; ），可以使用带有或不 &lt;code&gt;Perl_&lt;/code&gt; 前缀的函数，这要感谢存在于其中的许多定义。</target>
        </trans-unit>
        <trans-unit id="0daafc0685af0d01e22cebc44846559b24d94dc9" translate="yes" xml:space="preserve">
          <source>Inside your block, you can use a &lt;code&gt;;&lt;/code&gt; before the ellipsis to denote that the &lt;code&gt;{ ... }&lt;/code&gt; is a block and not a hash reference constructor. Now the ellipsis works:</source>
          <target state="translated">在您的区块中，您可以使用 &lt;code&gt;;&lt;/code&gt; 在省略号之前表示 &lt;code&gt;{ ... }&lt;/code&gt; 是一个块，而不是哈希引用构造函数。现在省略号起作用了：</target>
        </trans-unit>
        <trans-unit id="c37269c429f2ad22959db0e60ac4d8827e7e42ce" translate="yes" xml:space="preserve">
          <source>Inside-Out objects</source>
          <target state="translated">由内而外的对象</target>
        </trans-unit>
        <trans-unit id="7a4af927ec1e221d9c738e75cdfca5e119205956" translate="yes" xml:space="preserve">
          <source>Inside-out classes give us freedom of inheritance, but as usual there is a price.</source>
          <target state="translated">内外班给了我们继承的自由,但照旧有代价的。</target>
        </trans-unit>
        <trans-unit id="ec3c84ba848d8b0d780dabe6d5db65999ccfe2b2" translate="yes" xml:space="preserve">
          <source>Inside-out implementation based on the &lt;code&gt;id()&lt;/code&gt; function with explicit object registry. No destructor is needed and objects are thread safe.</source>
          <target state="translated">基于 &lt;code&gt;id()&lt;/code&gt; 函数的内外实现与显式对象注册表。不需要析构函数，并且对象是线程安全的。</target>
        </trans-unit>
        <trans-unit id="093639ed82951fb2c05d82fa61065038c4a3f59b" translate="yes" xml:space="preserve">
          <source>Inside-out implementation based on the &lt;code&gt;id()&lt;/code&gt; function. It needs a &lt;code&gt;DESTROY&lt;/code&gt; method. For thread support a &lt;code&gt;CLONE&lt;/code&gt; method (not shown) would also be needed. Instead of &lt;code&gt;Hash::Util::FieldHash::id()&lt;/code&gt; the function &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; could be used with very little functional difference. This is the basic pattern of an inside-out class.</source>
          <target state="translated">基于 &lt;code&gt;id()&lt;/code&gt; 函数的由内而外的实现。它需要一个 &lt;code&gt;DESTROY&lt;/code&gt; 方法。对于线程支持，也将需要 &lt;code&gt;CLONE&lt;/code&gt; 方法（未显示）。代替 &lt;code&gt;Hash::Util::FieldHash::id()&lt;/code&gt; ，可以使用功能 &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; ，而功能差异很小。这是由内而外的类的基本模式。</target>
        </trans-unit>
        <trans-unit id="1c8b1c8f4d7d36ee82d3ac919c5d208501a0c13b" translate="yes" xml:space="preserve">
          <source>Insisting on hints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516f54aa115effcfaabedad668e70675fab3e3bf" translate="yes" xml:space="preserve">
          <source>Insisting on hints is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f7dff6871418123fc5bf54019b9bfae13765ed" translate="yes" xml:space="preserve">
          <source>Inspecting &lt;code&gt;$UTF8{Euro}&lt;/code&gt; shows that it contains 3 bytes: &quot;\xe2\x82\xac&quot;. However, it contains only 1 character, number 0x20AC. The round trip can be completed with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">检查 &lt;code&gt;$UTF8{Euro}&lt;/code&gt; 显示它包含3个字节：&amp;ldquo; \ xe2 \ x82 \ xac&amp;rdquo;。但是，它仅包含1个字符，编号为0x20AC。往返旅行可以通过 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 完成：</target>
        </trans-unit>
        <trans-unit id="2b88041bde7425827d8e1b77e408079f51dbc6c2" translate="yes" xml:space="preserve">
          <source>Inspecting &lt;code&gt;$UTF8{Euro}&lt;/code&gt; shows that it contains 3 bytes: &quot;\xe2\x82\xac&quot;. However, it contains only 1 character, number 0x20AC. The round trip can be completed with &lt;code&gt;unpack&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59207d175da65683910680d9c040a0c388fa1f23" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2005 first, then the Platform SDK. Setup your environment as follows (assuming default installation locations were chosen):</source>
          <target state="translated">首先安装Visual C++2005,然后安装Platform SDK。设置环境如下(假设选择了默认的安装位置)。</target>
        </trans-unit>
        <trans-unit id="33cbab1690c07ca74d0ff29dfe5b56b37a842899" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2008-2013 Express, then setup your environment using, e.g.</source>
          <target state="translated">安装Visual C++2008-2013 Express,然后使用,例如,设置你的环境。</target>
        </trans-unit>
        <trans-unit id="64c681793c05d20d47748a1c4848dd27ecc92478" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2008-2019 Express/Community, then setup your environment using, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f196edb7ca2b342cfc8b1c8d1c16c051256d43c" translate="yes" xml:space="preserve">
          <source>Install a callback for a named event.</source>
          <target state="translated">为一个命名的事件安装一个回调。</target>
        </trans-unit>
        <trans-unit id="098146decab9cf9682dd20a4b2bc8c4001fb20aa" translate="yes" xml:space="preserve">
          <source>Install a signal mask and suspend process until signal arrives. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;signal_mask&lt;/code&gt; argument. Consult your system's &lt;code&gt;sigsuspend&lt;/code&gt; manpage for details.</source>
          <target state="translated">安装信号罩并暂停过程，直到信号到达。这使用 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 对象作为 &lt;code&gt;signal_mask&lt;/code&gt; 参数。有关详细信息，请查阅系统的 &lt;code&gt;sigsuspend&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="5064d1cdb752ce928134eb0a4e8326765bed0d5e" translate="yes" xml:space="preserve">
          <source>Install all distributions that have been tested successfully but have not yet been installed. See also &lt;code&gt;is_tested&lt;/code&gt; .</source>
          <target state="translated">安装已成功测试但尚未安装的所有发行版。另请参见 &lt;code&gt;is_tested&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30bb41e456f55898b9a816d97d83d13570e789d0" translate="yes" xml:space="preserve">
          <source>Install files from here to there</source>
          <target state="translated">从这里到那里安装文件</target>
        </trans-unit>
        <trans-unit id="be838642bc4439dddc0a654f23d9ebf8387685d2" translate="yes" xml:space="preserve">
          <source>Install my_handler() as the handler for the &lt;b&gt;normal-signals&lt;/b&gt;:</source>
          <target state="translated">安装my_handler（）作为&lt;b&gt;常规信号&lt;/b&gt;的处理程序：</target>
        </trans-unit>
        <trans-unit id="f8eeec02705f1ef8eb9bf0619d6a4de1e15c32de" translate="yes" xml:space="preserve">
          <source>Install my_handler() as the handler for the normal-signals, provide a Perl stack trace on receipt of one of the error-signals:</source>
          <target state="translated">安装my_handler()作为正常信号的处理程序,在收到一个错误信号时提供一个Perl堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="e64dce2583dfe013eb849f3d2d103a519b4f693d" translate="yes" xml:space="preserve">
          <source>Install the Toolkit first, then the Platform SDK, then the .NET Framework SDK. Setup your environment as follows (assuming default installation locations were chosen):</source>
          <target state="translated">首先安装工具包,然后安装Platform SDK,再安装.NET Framework SDK。按以下方式设置您的环境(假设选择了默认的安装位置)。</target>
        </trans-unit>
        <trans-unit id="cd990d98fdc32595b067d42fc715d5ce94d57be2" translate="yes" xml:space="preserve">
          <source>Install the bundle &lt;code&gt;Bundle::OS2_default&lt;/code&gt;</source>
          <target state="translated">安装包 &lt;code&gt;Bundle::OS2_default&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b20b73b1de67223c2bd9207fae1a1e9b72c2233d" translate="yes" xml:space="preserve">
          <source>Install the bundle file you produced in the first step with something like</source>
          <target state="translated">安装你在第一步制作的bundle文件,使用类似于</target>
        </trans-unit>
        <trans-unit id="b2a00c681671c3322d47892ed0695f73370a27ed" translate="yes" xml:space="preserve">
          <source>Install the specified modules. With no other switches, this switch is implied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a972b5a9d813b2528044bfdb606fb493e85bedb6" translate="yes" xml:space="preserve">
          <source>Install will copy the files into the Windows machine where NetWare Perl is installed and these files may have to be copied to the NetWare server manually. Alternatively, pass</source>
          <target state="translated">安装将把文件复制到安装 NetWare Perl 的 Windows 机器中,这些文件可能需要手动复制到 NetWare 服务器中。另外,也可以通过</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="5170591ca8711f15e1b20c47f412774e19b0fe70" translate="yes" xml:space="preserve">
          <source>Installation Anomalies with Perl on OS/390</source>
          <target state="translated">在OS/390上使用Perl的安装异常现象</target>
        </trans-unit>
        <trans-unit id="8744a89757a103643f2c85c220b914d085ffdf88" translate="yes" xml:space="preserve">
          <source>Installation Prefix</source>
          <target state="translated">安装前缀</target>
        </trans-unit>
        <trans-unit id="a45aaea883d55053b401f0d2cdd7b7f6799182e8" translate="yes" xml:space="preserve">
          <source>Installation of &lt;code&gt;Unicode::Collate::Locale&lt;/code&gt; requires</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180cc178e07c1743ecf9dbe37bab2bf2dabe5bb5" translate="yes" xml:space="preserve">
          <source>Installation of Perl on DOS</source>
          <target state="translated">在DOS上安装Perl</target>
        </trans-unit>
        <trans-unit id="cfb2e768feadc8837cc7fc759954e96ac60a95b5" translate="yes" xml:space="preserve">
          <source>Installation of Perl on Windows</source>
          <target state="translated">在Windows上安装Perl</target>
        </trans-unit>
        <trans-unit id="4ca02b48dd8aa7c8862ef964b8ef23527a77760c" translate="yes" xml:space="preserve">
          <source>Installing Perl Documentation on Plan 9</source>
          <target state="translated">在Plan 9上安装Perl文档</target>
        </trans-unit>
        <trans-unit id="2ae981a52ea5c2d2aafd4355287d2406dc0ef314" translate="yes" xml:space="preserve">
          <source>Installing Perl in OS/400 PASE</source>
          <target state="translated">在OS/400 PASE中安装Perl</target>
        </trans-unit>
        <trans-unit id="b61a365b42d75d8e047fa9fe92ff65b4f60e9701" translate="yes" xml:space="preserve">
          <source>Installing Perl on BS2000</source>
          <target state="translated">在BS2000上安装Perl</target>
        </trans-unit>
        <trans-unit id="0417ed1ca822a227853883f689e9fa61b7253133" translate="yes" xml:space="preserve">
          <source>Installing dynamic extensions</source>
          <target state="translated">安装动态扩展</target>
        </trans-unit>
        <trans-unit id="d551e6ba21a76c8b829c9fd66b0f82cb57a2e6c1" translate="yes" xml:space="preserve">
          <source>Installing handlers into UNIVERSAL, makes them...err..universal. For example:</source>
          <target state="translated">将处理程序安装到UNIVERSAL中,使得它们......呃......通用。例如:</target>
        </trans-unit>
        <trans-unit id="0cfc88ee57d518bf7af556a12ced2b10a8287ca8" translate="yes" xml:space="preserve">
          <source>Installing static extensions</source>
          <target state="translated">安装静态扩展</target>
        </trans-unit>
        <trans-unit id="257dd2466c69ad9b24149fb3bc3f1813543ba72a" translate="yes" xml:space="preserve">
          <source>Installing the built Perl on AmigaOS</source>
          <target state="translated">在AmigaOS上安装建立的Perl</target>
        </trans-unit>
        <trans-unit id="db29ef231e31119424ca9f0f93b9223b833e4152" translate="yes" xml:space="preserve">
          <source>Installing the built perl</source>
          <target state="translated">安装内置的perl</target>
        </trans-unit>
        <trans-unit id="d904df04db30e9f6033f6ecb3f32eb4c2b0e5b70" translate="yes" xml:space="preserve">
          <source>Installing your Extension</source>
          <target state="translated">安装您的分机</target>
        </trans-unit>
        <trans-unit id="0f18cd63862f3975ca1e7ab7bda9fc335b20e2f1" translate="yes" xml:space="preserve">
          <source>Installs a source filter that substitutes &quot;e&quot; for &quot;o&quot; (witheut regard fer what it might be medifying).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4a61ab3dc44ab9b5a205303724a68f74a735a7" translate="yes" xml:space="preserve">
          <source>Instance Methods</source>
          <target state="translated">实例方法</target>
        </trans-unit>
        <trans-unit id="8d64e2312c9072080b4302e3445829998f7c6a99" translate="yes" xml:space="preserve">
          <source>Instance method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e18280b32ffbeebedfcc0fc6dbe9b749315b6ea6" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; , we can write &lt;code&gt;$a[1][2]&lt;/code&gt; ; it means the same thing. Instead of &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; , we can write &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ; it means the same thing.</source>
          <target state="translated">代替 &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; ，我们可以写 &lt;code&gt;$a[1][2]&lt;/code&gt; ；这意味着同一件事。代替 &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; ，我们可以写 &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ; 这意味着同一件事。</target>
        </trans-unit>
        <trans-unit id="593a1adb7d7043c40428f2f6f11f755e1eb8603d" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt;, we can write &lt;code&gt;$a[1][2]&lt;/code&gt;; it means the same thing. Instead of &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt;, we can write &lt;code&gt;$a[0][1] = 23&lt;/code&gt;; it means the same thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba491ba1ec8ef4be8f85786b6a781edf6fccddb7" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; , you can simply use &lt;code&gt;:utf8&lt;/code&gt; , which skips the encoding step if the data was already represented as UTF8 internally. This is widely accepted as good behavior when you're writing, but it can be dangerous when reading, because it causes internal inconsistency when you have invalid byte sequences. Using &lt;code&gt;:utf8&lt;/code&gt; for input can sometimes result in security breaches, so please use &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; instead.</source>
          <target state="translated">代替 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; ，您可以简单地使用 &lt;code&gt;:utf8&lt;/code&gt; ，如果数据已经在内部表示为UTF8，则跳过编码步骤。在编写时，这被普遍认为是一种良好的行为，但在读取时可能会很危险，因为当字节序列无效时，这会导致内部不一致。使用 &lt;code&gt;:utf8&lt;/code&gt; 进行输入有时可能会导致安全漏洞，因此请改用 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bfad6bde5b470a60206db3866234b6dfd103110" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;:encoding(UTF-8)&lt;/code&gt;, you can simply use &lt;code&gt;:utf8&lt;/code&gt;, which skips the encoding step if the data was already represented as UTF8 internally. This is widely accepted as good behavior when you're writing, but it can be dangerous when reading, because it causes internal inconsistency when you have invalid byte sequences. Using &lt;code&gt;:utf8&lt;/code&gt; for input can sometimes result in security breaches, so please use &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ad0b5725694a222d6ac24da3bbb122aa3a958a" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;encode&lt;/code&gt; , you could use &lt;code&gt;_utf8_on&lt;/code&gt; and &lt;code&gt;_utf8_off&lt;/code&gt; , but this is considered bad style. Especially &lt;code&gt;_utf8_on&lt;/code&gt; can be dangerous, for the same reason that &lt;code&gt;:utf8&lt;/code&gt; can.</source>
          <target state="translated">可以使用 &lt;code&gt;_utf8_on&lt;/code&gt; 和 &lt;code&gt;_utf8_off&lt;/code&gt; 代替 &lt;code&gt;decode&lt;/code&gt; 和 &lt;code&gt;encode&lt;/code&gt; ，但这被认为是不好的样式。尤其是 &lt;code&gt;_utf8_on&lt;/code&gt; 可能很危险，原因与 &lt;code&gt;:utf8&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="bdb3493ce203f52a331d6d2854f96ffed217a38c" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;encode&lt;/code&gt;, you could use &lt;code&gt;_utf8_on&lt;/code&gt; and &lt;code&gt;_utf8_off&lt;/code&gt;, but this is considered bad style. Especially &lt;code&gt;_utf8_on&lt;/code&gt; can be dangerous, for the same reason that &lt;code&gt;:utf8&lt;/code&gt; can.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f30761f7bbd31f759ef384a9ad19f6187329e7a" translate="yes" xml:space="preserve">
          <source>Instead of a filename, you can also pass it an existing &lt;code&gt;Archive::Tar::File&lt;/code&gt; object from, for example, another archive. The object will be clone, and effectively be a copy of the original, not an alias.</source>
          <target state="translated">除了文件名，您还可以向它传递来自另一个归档 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 的现有Archive :: Tar :: File对象。该对象将被克隆，并且实际上是原始副本的副本，而不是别名。</target>
        </trans-unit>
        <trans-unit id="124160cac15a4b540f3a3a995eeb45e15636d682" translate="yes" xml:space="preserve">
          <source>Instead of a filename, you may specify an external command (plus an optional argument list) or a scalar reference, in order to open filehandles on commands or in-memory scalars, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d7794c8d2e8209f9cf8a080564bc83932d1de0d" translate="yes" xml:space="preserve">
          <source>Instead of a number, you can use &lt;code&gt;*&lt;/code&gt; to mean &quot;consume everything else left&quot;.</source>
          <target state="translated">可以用 &lt;code&gt;*&lt;/code&gt; 代替数字，以表示&amp;ldquo;消耗掉剩下的所有东西&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2d5ef8b3223bf8e72260629cb76365a1c7d119c3" translate="yes" xml:space="preserve">
          <source>Instead of an actual C function that has to fetch the thread context using &lt;code&gt;dTHX&lt;/code&gt; , you can define macros of the same name and avoid the overhead. Also, keep in mind to possibly free the memory allocated by &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; .</source>
          <target state="translated">不必使用 &lt;code&gt;dTHX&lt;/code&gt; 使用dTHX获取线程上下文的实际C函数，您可以定义相同名称的宏并避免开销。另外，请记住可能释放 &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; 分配的内存。</target>
        </trans-unit>
        <trans-unit id="a07eba34499fa5596b47d75d14fe92d0d0178dc4" translate="yes" xml:space="preserve">
          <source>Instead of an actual C function that has to fetch the thread context using &lt;code&gt;dTHX&lt;/code&gt;, you can define macros of the same name and avoid the overhead. Also, keep in mind to possibly free the memory allocated by &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efec145a63aada8917ea862470d1c559b417d5a8" translate="yes" xml:space="preserve">
          <source>Instead of it, do like this:</source>
          <target state="translated">与其这样,不如这样做。</target>
        </trans-unit>
        <trans-unit id="18bf50916f725e20e492e415ffe30f1d8deec329" translate="yes" xml:space="preserve">
          <source>Instead of loading feature bundles by name, it is easier to let Perl do implicit loading of a feature bundle for you.</source>
          <target state="translated">与其按名称加载功能包,不如让Perl为你隐式加载功能包。</target>
        </trans-unit>
        <trans-unit id="19636d7e449d8e4352801adbe196c0e695eced0d" translate="yes" xml:space="preserve">
          <source>Instead of reading the Unicode Database directly from files, as you were able to do for a long time, you are encouraged to use the supplied functions. So, instead of reading &lt;code&gt;Name.pl&lt;/code&gt; directly, which changed formats in 5.32, and may do so again without notice in the future or even disappear, you ought to use &lt;a href=&quot;#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot;&lt;/a&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4549985addea58856a2589a95661e1f3d1246c4e" translate="yes" xml:space="preserve">
          <source>Instead of setting &lt;code&gt;$SIG{ALRM}&lt;/code&gt; :</source>
          <target state="translated">而不是设置 &lt;code&gt;$SIG{ALRM}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="109c505d57edc356474583bd538981b34aae6661" translate="yes" xml:space="preserve">
          <source>Instead of setting &lt;code&gt;$SIG{ALRM}&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4cf4072b6ecd93f69baec56cef0a223f95f5666" translate="yes" xml:space="preserve">
          <source>Instead of specifying the VERSION in the Makefile.PL you can let MakeMaker parse a file to determine the version number. The parsing routine requires that the file named by VERSION_FROM contains one single line to compute the version number. The first line in the file that contains something like a $VERSION assignment or &lt;code&gt;package Name
VERSION&lt;/code&gt; will be used. The following lines will be parsed o.k.:</source>
          <target state="translated">您可以让MakeMaker解析文件以确定版本号，而不是在Makefile.PL中指定版本。解析例程要求VERSION_FROM命名的文件包含一行以计算版本号。文件中的第一行将包含$ VERSION赋值或 &lt;code&gt;package Name VERSION&lt;/code&gt; 内容。可以解析以下行：</target>
        </trans-unit>
        <trans-unit id="c9d067c5eb0ad6111602fcfc2b4a14a7fd5906ed" translate="yes" xml:space="preserve">
          <source>Instead of the</source>
          <target state="translated">取而代之的是</target>
        </trans-unit>
        <trans-unit id="52ef12851a02520ecdc1bb50b94ab80ca32cf34d" translate="yes" xml:space="preserve">
          <source>Instead of the above process, with Filter::Simple the task of setting up a source code filter is reduced to:</source>
          <target state="translated">有了Filter::Simple,设置源代码过滤器的任务就不再是上述过程,而是简化为。</target>
        </trans-unit>
        <trans-unit id="08d78413d66ea6fc10e343adae82dd66dad36d77" translate="yes" xml:space="preserve">
          <source>Instead of the shell's &lt;code&gt;expand&lt;/code&gt; command, use:</source>
          <target state="translated">代替shell的 &lt;code&gt;expand&lt;/code&gt; 命令，使用：</target>
        </trans-unit>
        <trans-unit id="c97f35f08c784710202f7afd89947e84d996ff4b" translate="yes" xml:space="preserve">
          <source>Instead of the shell's &lt;code&gt;unexpand -a&lt;/code&gt; command, use:</source>
          <target state="translated">代替shell的 &lt;code&gt;unexpand -a&lt;/code&gt; 命令，使用：</target>
        </trans-unit>
        <trans-unit id="6ba67eec9e92df05acdf46af85244d2e3cb47ac2" translate="yes" xml:space="preserve">
          <source>Instead of this:</source>
          <target state="translated">而不是这样。</target>
        </trans-unit>
        <trans-unit id="f550302de10f6528309a1269c83c4106b886739f" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$*&lt;/code&gt; you should use the &lt;code&gt;/m&lt;/code&gt; (and maybe &lt;code&gt;/s&lt;/code&gt;) regexp modifiers. You can enable &lt;code&gt;/m&lt;/code&gt; for a lexical scope (even a whole file) with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/m'&lt;/code&gt; . (In older versions: when &lt;code&gt;$*&lt;/code&gt; was set to a true value then all regular expressions behaved as if they were written using &lt;code&gt;/m&lt;/code&gt;.)</source>
          <target state="translated">而不是使用 &lt;code&gt;$*&lt;/code&gt; 您应该使用 &lt;code&gt;/m&lt;/code&gt; （也许是 &lt;code&gt;/s&lt;/code&gt; ）正则表达式修饰符。您可以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/m'&lt;/code&gt; re'/ m'为词法作用域（甚至整个文件）启用 &lt;code&gt;/m&lt;/code&gt; 。（在较早的版本中：当 &lt;code&gt;$*&lt;/code&gt; 设置为true值时，所有正则表达式的行为就像使用 &lt;code&gt;/m&lt;/code&gt; 编写的一样。）</target>
        </trans-unit>
        <trans-unit id="d1566aff196e46eef40b411b3e40f33b2eca1868" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$*&lt;/code&gt; you should use the &lt;code&gt;/m&lt;/code&gt; (and maybe &lt;code&gt;/s&lt;/code&gt;) regexp modifiers. You can enable &lt;code&gt;/m&lt;/code&gt; for a lexical scope (even a whole file) with &lt;code&gt;use re '/m'&lt;/code&gt;. (In older versions: when &lt;code&gt;$*&lt;/code&gt; was set to a true value then all regular expressions behaved as if they were written using &lt;code&gt;/m&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1168108b163850f03f0e7b84e90e2a3b75e09dc" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$Level&lt;/code&gt; to perform a backtrace, Test2 uses a context object. In this sample you create a context object and store it. This locks the context (errors report 1 level up from here) for all wrapped tools to find. You do not need to use the context object, but you do need to store it in a variable. Once the sub ends the &lt;code&gt;$ctx&lt;/code&gt; variable is destroyed which lets future tools find their own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1ae30c884ab234189c910ec5202733bc2390ed" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;given()&lt;/code&gt; , you can use a &lt;code&gt;foreach()&lt;/code&gt; loop. For example, here's one way to count how many times a particular string occurs in an array:</source>
          <target state="translated">而不是使用 &lt;code&gt;given()&lt;/code&gt; ，您可以使用 &lt;code&gt;foreach()&lt;/code&gt; 循环。例如，这是一种计算特定字符串在数组中出现多少次的方法：</target>
        </trans-unit>
        <trans-unit id="825297ab548b22ab92e503372aa9e1350b6ae1f8" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;given()&lt;/code&gt;, you can use a &lt;code&gt;foreach()&lt;/code&gt; loop. For example, here's one way to count how many times a particular string occurs in an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaff3d1d72214bb8cea47592fb5e3c306e475c28" translate="yes" xml:space="preserve">
          <source>Instead of writing an overloaded interface using pure Perl, you can also use the OVERLOAD keyword to define additional Perl names for your functions (like the ALIAS: keyword above). However, the overloaded functions must be defined in such a way as to accept the number of parameters supplied by perl's overload system. For most overload methods, it will be three parameters; for the &lt;code&gt;nomethod&lt;/code&gt; function it will be four. However, the bitwise operators &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; may be called with three</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf329df99c7b872b2b1eb49834514d53120f89e" translate="yes" xml:space="preserve">
          <source>Instead of writing an overloaded interface using pure Perl, you can also use the OVERLOAD keyword to define additional Perl names for your functions (like the ALIAS: keyword above). However, the overloaded functions must be defined with three parameters (except for the nomethod() function which needs four parameters). If any function has the OVERLOAD: keyword, several additional lines will be defined in the c file generated by xsubpp in order to register with the overload magic.</source>
          <target state="translated">与使用纯Perl编写重载接口不同,你也可以使用OVERLOAD关键字为你的函数定义额外的Perl名称(就像上面的ALIAS:关键字)。但是,重载函数必须用三个参数来定义(除了nomethod()函数需要四个参数)。如果任何函数有OVERLOAD:关键字,那么在xsubpp生成的c文件中会有几行额外的定义,以便注册重载魔法。</target>
        </trans-unit>
        <trans-unit id="638fcabfcb5cd72cef4275780294bf41068d5ea4" translate="yes" xml:space="preserve">
          <source>Instead of writing multiple &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; statements, you may define multiple constants in a single statement by giving, instead of the constant name, a reference to a hash where the keys are the names of the constants to be defined. Obviously, all constants defined using this method must have a single value.</source>
          <target state="translated">除了编写多个 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; 语句外，还可以在单​​个语句中定义多个常量，方法是给散列（而不是常量名）提供对哈希的引用，其中键是要定义的常量的名称。显然，使用此方法定义的所有常量都必须具有单个值。</target>
        </trans-unit>
        <trans-unit id="df4a7dbc731cad321f60bc3be4e6304404421661" translate="yes" xml:space="preserve">
          <source>Instead of writing multiple &lt;code&gt;use constant&lt;/code&gt; statements, you may define multiple constants in a single statement by giving, instead of the constant name, a reference to a hash where the keys are the names of the constants to be defined. Obviously, all constants defined using this method must have a single value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6782b252ab0c32bd42d86fbd7b3f79af4ff565e5" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toFOLD_utf8&quot;&gt;toFOLD_utf8&lt;/a&gt;.</source>
          <target state="translated">而是使用&lt;a href=&quot;#toFOLD_utf8&quot;&gt;toFOLD_utf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d1f6743fcc3e6286f6e367f0b73ab61c02242a50" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toLOWER_utf8&quot;&gt;toLOWER_utf8&lt;/a&gt;.</source>
          <target state="translated">而是使用&lt;a href=&quot;#toLOWER_utf8&quot;&gt;toLOWER_utf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef6bd3b06361be7e68d9b7223a3d403afc7f30fb" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toTITLE_utf8&quot;&gt;toTITLE_utf8&lt;/a&gt;.</source>
          <target state="translated">而是使用&lt;a href=&quot;#toTITLE_utf8&quot;&gt;toTITLE_utf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f68321016539906487e3d1b25d1d9b7700cb63a1" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toUPPER_utf8&quot;&gt;toUPPER_utf8&lt;/a&gt;.</source>
          <target state="translated">而是使用&lt;a href=&quot;#toUPPER_utf8&quot;&gt;toUPPER_utf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8ee82e6fa25bfd2bc478049adfc2e72d633951e" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;, or rarely, &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt;.</source>
          <target state="translated">而是使用&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;，或者很少使用&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5da1022fb23560c08ccb2175ba3ed7594365a4b" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;perlapi#utf8_to_uvchr_buf&quot;&gt;&quot;utf8_to_uvchr_buf&quot; in perlapi&lt;/a&gt;, or rarely, &lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1e3be314ffd2bc3abc3de781de1fea85191bb5" translate="yes" xml:space="preserve">
          <source>Instead you almost certainly want to use &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; or &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;.</source>
          <target state="translated">相反，您几乎可以肯定要使用&lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt;或&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c1ab72749459dc4de544fac6868597b605f1005" translate="yes" xml:space="preserve">
          <source>Instead you almost certainly want to use &lt;a href=&quot;perlapi#uvchr_to_utf8&quot;&gt;&quot;uvchr_to_utf8&quot; in perlapi&lt;/a&gt; or &lt;a href=&quot;perlapi#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c61a7798941b565eb0ca8902a985ea083443b8b" translate="yes" xml:space="preserve">
          <source>Instead, &lt;code&gt;bytes_to_utf8&lt;/code&gt; will give you a UTF-8-encoded &lt;b&gt;copy&lt;/b&gt; of its string argument. This is useful for having the data available for comparisons and so on, without harming the original SV. There's also &lt;code&gt;utf8_to_bytes&lt;/code&gt; to go the other way, but naturally, this will fail if the string contains any characters above 255 that can't be represented in a single byte.</source>
          <target state="translated">相反， &lt;code&gt;bytes_to_utf8&lt;/code&gt; 将为您提供其字符串参数的UTF-8编码&lt;b&gt;副本&lt;/b&gt;。这对于使数据可用于比较等很有用，而又不会损害原始SV。另外还有 &lt;code&gt;utf8_to_bytes&lt;/code&gt; ，但是很自然，如果字符串中包含任何不能用单个字节表示的255以上的字符，则失败。</target>
        </trans-unit>
        <trans-unit id="1d682bf7489c4d815717f3faba809d2c01f4ea4b" translate="yes" xml:space="preserve">
          <source>Instead, all available methods to execute plain text files on Windows rely on the file &quot;extension&quot;. There are three methods to use this to execute perl scripts:</source>
          <target state="translated">相反,在Windows上执行纯文本文件的所有可用方法都依赖于文件的 &quot;扩展名&quot;。有三种方法可以用来执行perl脚本。</target>
        </trans-unit>
        <trans-unit id="1b6f6bc21ad6a818717c640ad98e7196014d29c9" translate="yes" xml:space="preserve">
          <source>Instead, have it like this:</source>
          <target state="translated">而是要这样。</target>
        </trans-unit>
        <trans-unit id="c21043f535759255fae7da396e1a74414adc0df4" translate="yes" xml:space="preserve">
          <source>Instead, it's recommended one uses &lt;code&gt;state&lt;/code&gt; variables to achieve the same effect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0ab28444eeb1a3b5d5448f3e8b2d9f9844879d" translate="yes" xml:space="preserve">
          <source>Instead, switch from &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; to &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;. &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; does everything &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; does, and more! In fact, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; does things</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767f1cd6299c67c930c8d9fe765261f308e05da4" translate="yes" xml:space="preserve">
          <source>Instead, the following solution works rather well. The nice things about it are 1) you can start using it right away; 2) it is more powerful, because it will do the right thing with a pattern like */*/*.c; 3) you can decide whether you do/don't want to use it; and 4) you can extend the method to add any customizations (or even entirely different kinds of wildcard expansion).</source>
          <target state="translated">相反,下面的解决方案相当好用。它的好处是:1)你可以马上开始使用它;2)它的功能更强大,因为它会用*/*/*.c这样的模式做正确的事情;3)你可以决定是否使用/不使用它;4)你可以扩展该方法以添加任何自定义(甚至是完全不同种类的通配符扩展)。</target>
        </trans-unit>
        <trans-unit id="029f2d96c54611243fd4f7123ebf76a0e7725aa0" translate="yes" xml:space="preserve">
          <source>Instead, the stack stores information in a variable-length encoding of &lt;code&gt;ANY&lt;/code&gt; structures. The final value pushed is stored in the &lt;code&gt;UV&lt;/code&gt; field which encodes the kind of item held by the preceeding items; the count and types of which will depend on what kind of item is being stored. The kind field is pushed last because that will be the first field to be popped when unwinding items from the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3e6ac1b90019684415c1dbba6b4a76bfa88d1e" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;blessed&lt;/code&gt; (in the &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module) for boolean checks, &lt;code&gt;isa&lt;/code&gt; for specific class checks and &lt;code&gt;reftype&lt;/code&gt; (also from &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;) for type checks. (See &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; for details and a &lt;code&gt;blessed/isa&lt;/code&gt; example.)</source>
          <target state="translated">取而代之的是，将 &lt;code&gt;blessed&lt;/code&gt; （在&lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;模块中）用于布尔检查，将 &lt;code&gt;isa&lt;/code&gt; 用于特定的类检查，将 &lt;code&gt;reftype&lt;/code&gt; （也来自&lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;）用于类型检查。（有关详细信息和 &lt;code&gt;blessed/isa&lt;/code&gt; 示例，请参见&lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="ff6123faf0e0d43395bbeea664d72b0be06f73ad" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;blessed&lt;/code&gt; (in the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module) for boolean checks, &lt;code&gt;isa&lt;/code&gt; for specific class checks and &lt;code&gt;reftype&lt;/code&gt; (also from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;) for type checks. (See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for details and a &lt;code&gt;blessed/isa&lt;/code&gt; example.)</source>
          <target state="translated">取而代之的是，将 &lt;code&gt;blessed&lt;/code&gt; （在&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;模块中）用于布尔检查，将 &lt;code&gt;isa&lt;/code&gt; 用于特定的类检查，将 &lt;code&gt;reftype&lt;/code&gt; （也来自&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;）用于类型检查。（有关详细信息和 &lt;code&gt;blessed/isa&lt;/code&gt; 示例，请参见&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="88561bf4f68d300fba6b47877d2e1d88be295371" translate="yes" xml:space="preserve">
          <source>Instead, use a temporary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b239d64a76a8342f4a5e3f91a8ae44b81bce472" translate="yes" xml:space="preserve">
          <source>Instead, use double-quotes with a single backslash:</source>
          <target state="translated">取而代之的是使用双引号与单反斜杠。</target>
        </trans-unit>
        <trans-unit id="d6975d2303b579219cd1ad4ae114ac6792c64260" translate="yes" xml:space="preserve">
          <source>Instead, use the definitions IV, UV, IVSIZE, I32SIZE, and so forth. Avoid things like I32 because they are &lt;b&gt;not&lt;/b&gt; guaranteed to be</source>
          <target state="translated">而是使用定义IV，UV，IVSIZE，I32SIZE等。避免使用I32之类的东西，因为&lt;b&gt;不能&lt;/b&gt;保证</target>
        </trans-unit>
        <trans-unit id="f29af992c4a56bb38b3dfd00c903703bc13b8ea4" translate="yes" xml:space="preserve">
          <source>Instead, write this using a lexical variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08114352d8e01718b9f4310cee2e4e9e17e09b27" translate="yes" xml:space="preserve">
          <source>Instructions on how to install your module along with any dependencies. Suggested information to include here:</source>
          <target state="translated">说明如何安装你的模块以及所有的依赖关系。建议在这里包含的信息。</target>
        </trans-unit>
        <trans-unit id="ecdea140cf34e5fdf5440492ab0f9ef1743393d2" translate="yes" xml:space="preserve">
          <source>Insure that colons marking targets are preceded by space, in order to distinguish the target delimiter from a colon appearing as part of a filespec.</source>
          <target state="translated">确保标示目标的冒号前面有空格,以便将目标定界符与作为 filespec 的一部分出现的冒号区分开来。</target>
        </trans-unit>
        <trans-unit id="683987ee4aeb538cfdf37663a8c0ab7ac90a2019" translate="yes" xml:space="preserve">
          <source>Integer Arithmetic</source>
          <target state="translated">整数算术</target>
        </trans-unit>
        <trans-unit id="efbf94ff9c1725858eeaef5462e64f2f9beabf82" translate="yes" xml:space="preserve">
          <source>Integer binary logarithm [C99]</source>
          <target state="translated">整数二进制对数[C99]</target>
        </trans-unit>
        <trans-unit id="0bbddfa82bfc58cb4fa39eff708183ee398ca07e" translate="yes" xml:space="preserve">
          <source>Integer binary logarithm [C99].</source>
          <target state="translated">整数二进制对数[C99]。</target>
        </trans-unit>
        <trans-unit id="e9aa0af9187fd5006e57aa5fe9340c513694f8b0" translate="yes" xml:space="preserve">
          <source>Integer overflow in %s number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6b479cc505431a4dd13a180ea73dec5d1ae03c" translate="yes" xml:space="preserve">
          <source>Integer overflow in format string for %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411c0a34661530dce26957f99bd67035b369dd12" translate="yes" xml:space="preserve">
          <source>Integer overflow in srand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e060e7583c7facbbad20094c9d4fc91b279e279" translate="yes" xml:space="preserve">
          <source>Integer overflow in version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0952c0d0ac1f6d4efaf83d1bb17a2ea9130956b" translate="yes" xml:space="preserve">
          <source>Integer overflow in version %d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e40742eb38c2f7d8587ad34912b36536447d35" translate="yes" xml:space="preserve">
          <source>Integer. An optional leading plus or minus sign, followed by a sequence of digits.</source>
          <target state="translated">整数。一个可选的前导加号或后导减号,后面是一个数字序列。</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="4b35a75e337792a14859048b5fe4c1f4a2d46a86" translate="yes" xml:space="preserve">
          <source>Integrating local directories</source>
          <target state="translated">整合本地目录</target>
        </trans-unit>
        <trans-unit id="1c339f566d96dc4be124c8a012dc09ff7ba394ec" translate="yes" xml:space="preserve">
          <source>Intel C++ Compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a43fe57e64c611c07e7f0722fcf5e81fd02d7e" translate="yes" xml:space="preserve">
          <source>Intel HEX</source>
          <target state="translated">英特尔HEX</target>
        </trans-unit>
        <trans-unit id="283a7688f976826bc81b0d15b139b8fb7bc39125" translate="yes" xml:space="preserve">
          <source>Intel HEX is a file format for representing binary data, mostly for programming various chips, as a text file. (See &lt;a href=&quot;http://en.wikipedia.org/wiki/.hex&quot;&gt;http://en.wikipedia.org/wiki/.hex&lt;/a&gt; for a detailed description, and &lt;a href=&quot;http://en.wikipedia.org/wiki/SREC_&quot;&gt;http://en.wikipedia.org/wiki/SREC_&lt;/a&gt;(file_format) for the Motorola S-record format, which can be unravelled using the same technique.) Each line begins with a colon (':') and is followed by a sequence of hexadecimal characters, specifying a byte count</source>
          <target state="translated">Intel HEX是一种文件格式，用于表示二进制数据（主要用于对各种芯片进行编程）作为文本文件。（参见&lt;a href=&quot;http://en.wikipedia.org/wiki/.hex&quot;&gt;http://en.wikipedia.org/wiki/.hex&lt;/a&gt;要详细描述，以及&lt;a href=&quot;http://en.wikipedia.org/wiki/SREC_&quot;&gt;http://en.wikipedia.org/wiki/SREC_&lt;/a&gt;（file_format）为摩托罗拉S-记录格式，其可以被解开（使用相同的技术。）每行以冒号（'：'）开头，后跟一系列十六进制字符，并指定字节数</target>
        </trans-unit>
        <trans-unit id="a856ee1a019faac6da0b8db428273065b2de2b57" translate="yes" xml:space="preserve">
          <source>Intel HEX is a file format for representing binary data, mostly for programming various chips, as a text file. (See &lt;a href=&quot;https://en.wikipedia.org/wiki/.hex&quot;&gt;https://en.wikipedia.org/wiki/.hex&lt;/a&gt; for a detailed description, and &lt;a href=&quot;https://en.wikipedia.org/wiki/SREC_(file_format)&quot;&gt;https://en.wikipedia.org/wiki/SREC_(file_format)&lt;/a&gt; for the Motorola S-record format, which can be unravelled using the same technique.) Each line begins with a colon (':') and is followed by a sequence of hexadecimal characters, specifying a byte count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da544d1418799d25bfd09546e06754d3e5b1aeb3" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380d7ac3123e0e68ffb5963fc34784cfb9731163" translate="yes" xml:space="preserve">
          <source>Intended for use on command line with &lt;b&gt;-M&lt;/b&gt; option as a way of testing arbitrary scripts against an uninstalled version of a package.</source>
          <target state="translated">旨在与&lt;b&gt;-M&lt;/b&gt;选项一起在命令行上使用，以针对卸载的软件包版本测试任意脚本。</target>
        </trans-unit>
        <trans-unit id="d75d6528effe0d95b951e2f70179256a5a75c5b0" translate="yes" xml:space="preserve">
          <source>Interacting with Perl from the Digital Command Language (DCL) shell often requires a different set of quotation marks than Unix shells do. For example:</source>
          <target state="translated">从数字命令语言(DCL)shell中与Perl进行交互时,通常需要一组不同于Unix shell的引号。例如:</target>
        </trans-unit>
        <trans-unit id="39c574bcdb6de6c0029ded259821021591e578be" translate="yes" xml:space="preserve">
          <source>Interaction with Extensions</source>
          <target state="translated">与扩展部分的互动</target>
        </trans-unit>
        <trans-unit id="36743263147e4579bf65378679da63cd8385f8a2" translate="yes" xml:space="preserve">
          <source>Interactive Client with IO::Socket</source>
          <target state="translated">使用IO::Socket的交互式客户端</target>
        </trans-unit>
        <trans-unit id="a16954cde7a599ddba4d577acd1b685762317ea3" translate="yes" xml:space="preserve">
          <source>Interactive mode:</source>
          <target state="translated">互动模式。</target>
        </trans-unit>
        <trans-unit id="bdcd0f2bf481dc531fd0fd8a96b470b347913b64" translate="yes" xml:space="preserve">
          <source>Interactive sessions maintain a lockfile, by default &lt;code&gt;~/.cpan/.&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; . Batch jobs can run without a lockfile and not disturb each other.</source>
          <target state="translated">交互式会话维护一个 &lt;code&gt;~/.cpan/.&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 文件，默认情况下为〜/ .cpan /。锁。批处理作业可以在没有锁定文件的情况下运行，并且不会互相干扰。</target>
        </trans-unit>
        <trans-unit id="4049be05b318660a87d35f9664cb17d1ca51f690" translate="yes" xml:space="preserve">
          <source>Interactively supply an arbitrary &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;-e&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;-e&lt;/code&gt; 交互式提供任意 &lt;code&gt;expression&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9612d7e5106a7533f6eeeb596274a84b741fb5b" translate="yes" xml:space="preserve">
          <source>Interactively supply an arbitrary &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;-e&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216f7ef95315bf7807890aa65847604f1201542d" translate="yes" xml:space="preserve">
          <source>Interal Utilities for autodie and Fatal! This module is not a part of autodie's public API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f4333051573407ec799c7bafee1c6ca09470f1b" translate="yes" xml:space="preserve">
          <source>Interestingly we get slightly different results, which is mostly because the algorithm which generates the report is different, even though the output file format was allegedly identical. The elapsed, user and system times are clearly showing the time it took for &lt;code&gt;Devel::Profiler&lt;/code&gt; to execute its own run, but the column listings feel more accurate somehow than the ones we had earlier from &lt;code&gt;Devel::DProf&lt;/code&gt; . The 102% figure has disappeared, for example. This is where we have to use the tools at our disposal, and recognise their pros and cons, before using them. Interestingly, the numbers of calls for each subroutine are identical in the two reports, it's the percentages which differ. As the author of &lt;code&gt;Devel::Proviler&lt;/code&gt; writes:</source>
          <target state="translated">有趣的是，我们得到的结果略有不同，这主要是因为尽管据称输出文件格式相同，但生成报告的算法却有所不同。经过的时间，用户和系统时间清楚地显示了 &lt;code&gt;Devel::Profiler&lt;/code&gt; 执行其自己的运行所花费的时间，但是与我们之前从 &lt;code&gt;Devel::DProf&lt;/code&gt; 获得的列表相比，该列列表在某种程度上感觉更准确。例如，102％的数字消失了。在这里，我们必须使用可用的工具，并在使用它们之前认识它们的优缺点。有趣的是，在两个报告中，每个子例程的调用次数是相同的，只是百分比不同。正如 &lt;code&gt;Devel::Proviler&lt;/code&gt; 的作者写道：</target>
        </trans-unit>
        <trans-unit id="80ae20ece05d487021ccd9de0a68139efa803e3c" translate="yes" xml:space="preserve">
          <source>Interestingly we get slightly different results, which is mostly because the algorithm which generates the report is different, even though the output file format was allegedly identical. The elapsed, user and system times are clearly showing the time it took for &lt;code&gt;Devel::Profiler&lt;/code&gt; to execute its own run, but the column listings feel more accurate somehow than the ones we had earlier from &lt;code&gt;Devel::DProf&lt;/code&gt;. The 102% figure has disappeared, for example. This is where we have to use the tools at our disposal, and recognise their pros and cons, before using them. Interestingly, the numbers of calls for each subroutine are identical in the two reports, it's the percentages which differ. As the author of &lt;code&gt;Devel::Proviler&lt;/code&gt; writes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe9cc8d59c908d2dfc528838b1b4b5192a00c09" translate="yes" xml:space="preserve">
          <source>Interface Strategy</source>
          <target state="translated">界面策略</target>
        </trans-unit>
        <trans-unit id="e9bdbdb9fc26f525c1a8ecbeb7cc8ceb768f4d54" translate="yes" xml:space="preserve">
          <source>Interface between CPAN.pm and Kwalify.pm</source>
          <target state="translated">CPAN.pm和Kwalify.pm之间的接口。</target>
        </trans-unit>
        <trans-unit id="7481e39dedf2d2f4c332b82f6502c28043c6929e" translate="yes" xml:space="preserve">
          <source>Interface to Berkeley DB</source>
          <target state="translated">与Berkeley DB的接口</target>
        </trans-unit>
        <trans-unit id="8e2ccff2c57048b71f1d307b6edb8f11b2c43b05" translate="yes" xml:space="preserve">
          <source>Interface to cwd from EMX. Used by &lt;code&gt;Cwd::cwd&lt;/code&gt; .</source>
          <target state="translated">从EMX到cwd的接口。由 &lt;code&gt;Cwd::cwd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5554dd630fd9035ebceb918f102c567832d75cf6" translate="yes" xml:space="preserve">
          <source>Interface to cwd from EMX. Used by &lt;code&gt;Cwd::cwd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6adf7d5cbdb0f3010f3086f3f294d7023f460422" translate="yes" xml:space="preserve">
          <source>Interface to get/set environment variables. Returns the current value as a Unicode string. The $uni_key and $uni_value arguments are expected to be Unicode strings as well. Passing &lt;code&gt;undef&lt;/code&gt; as $uni_value deletes the environment variable named $uni_key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae2466aff78641921461ec62c4d4ef5f0f5b074" translate="yes" xml:space="preserve">
          <source>Interface to zlib compression library</source>
          <target state="translated">zlib压缩库的接口</target>
        </trans-unit>
        <trans-unit id="e346886e4b9cdfd6ef396ff466a7b37cd952cc6d" translate="yes" xml:space="preserve">
          <source>Interfaces to / Emulations of Other Programming Languages</source>
          <target state="translated">与其他编程语言的接口/模拟。</target>
        </trans-unit>
        <trans-unit id="2188689d5ae5f33a21007d13b3dcb52813873257" translate="yes" xml:space="preserve">
          <source>Interfaces to some Win32 API Functions</source>
          <target state="translated">一些Win32 API函数的接口</target>
        </trans-unit>
        <trans-unit id="79cc6bbe2327c1551d1e5d40f07d9b83bc80ae14" translate="yes" xml:space="preserve">
          <source>Interleaving STDOUT/STDERR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033764585e80fa1ca47c0451c08faf861b72f44d" translate="yes" xml:space="preserve">
          <source>Intermediary representation of a table for use in specialized &lt;a href=&quot;Test::API::Context&quot;&gt;Test::API::Context&lt;/a&gt; methods which generate &lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2::EventFacet::Info&lt;/a&gt; facets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3fe500d640cf31fd9a657a78f2b102d9181133" translate="yes" xml:space="preserve">
          <source>Intermediary representation of a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20643cb83b71e3458cd8974c42d3daa3e1288a1" translate="yes" xml:space="preserve">
          <source>Internal Format</source>
          <target state="translated">内部格式</target>
        </trans-unit>
        <trans-unit id="61d67a4869b5e28886ef542cee4befaab340cf82" translate="yes" xml:space="preserve">
          <source>Internal Functions</source>
          <target state="translated">内部功能</target>
        </trans-unit>
        <trans-unit id="0cef48f59f7e2f51840fc46f9024c24cc33d8ed0" translate="yes" xml:space="preserve">
          <source>Internal Utility subroutines for autodie and Fatal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af8acca69afbd9c6d39218e0bb28d32d199f366" translate="yes" xml:space="preserve">
          <source>Internal configuration handling for CPAN.pm</source>
          <target state="translated">CPAN.pm的内部配置处理</target>
        </trans-unit>
        <trans-unit id="0806883110f04db9f91191aca94f31996b0d72ea" translate="yes" xml:space="preserve">
          <source>Internal debugging for CPAN.pm</source>
          <target state="translated">CPAN.pm的内部调试</target>
        </trans-unit>
        <trans-unit id="4c898c3410ed0ae8d99f5b87b9783ee59e1feeaf" translate="yes" xml:space="preserve">
          <source>Internal debugging messages are enabled when $dl_debug is set true. Currently setting $dl_debug only affects the Perl side of the DynaLoader. These messages should help an application developer to resolve any DynaLoader usage problems.</source>
          <target state="translated">当$dl_debug被设置为true时,内部调试信息将被启用。目前设置$dl_debug只影响DynaLoader的Perl端。这些信息应该可以帮助应用开发者解决任何DynaLoader使用问题。</target>
        </trans-unit>
        <trans-unit id="c2682bb60ef046fd0af9a65133fafcb74ba078ce" translate="yes" xml:space="preserve">
          <source>Internal disaster in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49405ebb7fde7f417d0e5c600dc6fa4e232257c1" translate="yes" xml:space="preserve">
          <source>Internal error: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d873f4a2f97ab05d24f6fa0f06cef45d8aeae3b7" translate="yes" xml:space="preserve">
          <source>Internal format</source>
          <target state="translated">内部格式</target>
        </trans-unit>
        <trans-unit id="a7b06547359f2b157e33961f9b748082a4eb9b46" translate="yes" xml:space="preserve">
          <source>Internal function Hash::Util::FieldHash::_fieldhash</source>
          <target state="translated">内部函数 Hash::Util::FieldHash::_fieldhash。</target>
        </trans-unit>
        <trans-unit id="5f0c27e8b0c0bee621d0e3ce9073f2744d23dd75" translate="yes" xml:space="preserve">
          <source>Internal function which adds the filter, based on the &lt;a href=&quot;filter_add&quot;&gt;filter_add&lt;/a&gt; argument type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b9dd26770184bcb91b7be8acd8ff5db510c8df" translate="yes" xml:space="preserve">
          <source>Internal function which adds the filter, based on the &lt;a href=&quot;http://search.cpan.org/perldoc/filter_add&quot;&gt;filter_add&lt;/a&gt; argument type.</source>
          <target state="translated">基于&lt;a href=&quot;http://search.cpan.org/perldoc/filter_add&quot;&gt;filter_add&lt;/a&gt;参数类型添加过滤器的内部函数。</target>
        </trans-unit>
        <trans-unit id="5fee2b9c80ad50aec00177a91487a9d17942074f" translate="yes" xml:space="preserve">
          <source>Internal handling of tar archives for CPAN.pm</source>
          <target state="translated">CPAN.pm的焦油存档的内部处理。</target>
        </trans-unit>
        <trans-unit id="8e0c690a448500e398abe5fb8a070cf47a50330b" translate="yes" xml:space="preserve">
          <source>Internal inconsistency in tracking vforks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7017225658a0f9fba19af865f848f427597c31a" translate="yes" xml:space="preserve">
          <source>Internal method for printing errors and warnings. If no options are given, simply prints &quot;@_&quot;. The following options are recognized and used to form the output:</source>
          <target state="translated">打印错误和警告的内部方法。如果没有给定选项,只打印&quot;@_&quot;。以下选项被识别并用于形成输出。</target>
        </trans-unit>
        <trans-unit id="d524d9cfc678704c162c4cb4460355871a08ade5" translate="yes" xml:space="preserve">
          <source>Internal object used by Time::gmtime and Time::localtime</source>
          <target state="translated">Time::gmtime 和 Time::localtime 使用的内部对象。</target>
        </trans-unit>
        <trans-unit id="dec6a2c45a2bdd64a3ec8fcc2511727cc99b5b26" translate="yes" xml:space="preserve">
          <source>Internal queue support for CPAN.pm</source>
          <target state="translated">CPAN.pm的内部队列支持</target>
        </trans-unit>
        <trans-unit id="237da84ead8405b42fa85a7e388ec997365ff6da" translate="yes" xml:space="preserve">
          <source>Internal urp in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e13d391ba568ec11cf915e5927275eb2d03a56" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; are implemented with a real tied interface via &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt;. The methods in that package will call back into these functions. However the usage of &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; for this purpose might change in future releases. For instance this might be implemented by magic instead (would need an extension to mgvtbl).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de0eedbd92548d18bf918a068ea4b60732f9cf3" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; are implemented with a real tied interface via &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt;. The methods in that package will call back into these functions. However the usage of &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; for this purpose might change in future releases. For instance this might be implemented by magic instead (would need an extension to mgvtbl).</source>
          <target state="translated">内部 &lt;code&gt;%+&lt;/code&gt; 和 &lt;code&gt;%-&lt;/code&gt; 通过&lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt;通过真正的绑定接口实现。该软件包中的方法将回调这些函数。但是，在将来的发行版中，为此使用&lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt;可能会发生变化。例如，这可以通过魔术来实现（将需要扩展到mgvtbl）。</target>
        </trans-unit>
        <trans-unit id="1b09ff7b696f900f84f4dabc94d78d0ec9f89714" translate="yes" xml:space="preserve">
          <source>Internally CPAN.pm uses the UTF-8 charset. If your terminal is expecting ISO-8859-1 charset, a converter can be activated by setting term_is_latin to a true value in your config file. One way of doing so would be</source>
          <target state="translated">CPAN.pm内部使用的是UTF-8字符集,如果你的终端希望使用ISO-8859-1字符集,可以通过在配置文件中设置term_is_latin为true来激活转换器。如果你的终端希望使用ISO-8859-1字符集,可以通过在配置文件中设置term_is_latin为true来激活一个转换器。一种方法是</target>
        </trans-unit>
        <trans-unit id="80378d1e7d2da0cf424eca7e07458848627808d4" translate="yes" xml:space="preserve">
          <source>Internally Encoding -&amp;gt; Unicode and Unicode -&amp;gt; Encoding Map looks like this;</source>
          <target state="translated">内部编码-&amp;gt; Unicode和Unicode-&amp;gt;编码映射如下所示；</target>
        </trans-unit>
        <trans-unit id="0270a1a0f07e6453af1ad3d10386c0ad1d3a4e99" translate="yes" xml:space="preserve">
          <source>Internally the Benchmark object holds timing values, described in &lt;a href=&quot;#NOTES&quot;&gt;&quot;NOTES&quot;&lt;/a&gt; below. The following methods can be used to access them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac21d3e9553672475ffa22a2c6fb0c3420e3cc6" translate="yes" xml:space="preserve">
          <source>Internally the Benchmark object holds timing values, described in &lt;a href=&quot;#NOTES&quot;&gt;NOTES&lt;/a&gt; below. The following methods can be used to access them:</source>
          <target state="translated">基准对象在内部保存时序值，如以下&lt;a href=&quot;#NOTES&quot;&gt;注释中&lt;/a&gt;所述。可以使用以下方法访问它们：</target>
        </trans-unit>
        <trans-unit id="a523262f74789d99cb822f252d727c1f77360575" translate="yes" xml:space="preserve">
          <source>Internally this is set to &lt;code&gt;NULL&lt;/code&gt; unless a custom engine is specified in &lt;code&gt;$^H{regcomp}&lt;/code&gt; , Perl's own set of callbacks can be accessed in the struct pointed to by &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; .</source>
          <target state="translated">在内部，除非在 &lt;code&gt;$^H{regcomp}&lt;/code&gt; 指定了自定义引擎，否则将其设置为 &lt;code&gt;NULL&lt;/code&gt; ，可以在 &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; 指向的结构中访问Perl自己的回调集。</target>
        </trans-unit>
        <trans-unit id="c3120174b4db905355a8c95bdaa9494f155c0435" translate="yes" xml:space="preserve">
          <source>Internally this is set to &lt;code&gt;NULL&lt;/code&gt; unless a custom engine is specified in &lt;code&gt;$^H{regcomp}&lt;/code&gt;, Perl's own set of callbacks can be accessed in the struct pointed to by &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d5951d905f459e1665d8721f731d5fdbea427b7" translate="yes" xml:space="preserve">
          <source>Internally used by Encode</source>
          <target state="translated">Encode内部使用</target>
        </trans-unit>
        <trans-unit id="e76ceb49e27718344d5ee1ece08b4b732be4cccc" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::??::ISO_2022_*</source>
          <target state="translated">内部用于Encode::?:ISO_2022_*。</target>
        </trans-unit>
        <trans-unit id="2bebc443d25f2caf9161712ece027e6af3e9145b" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::CN</source>
          <target state="translated">Encode::CN内部使用</target>
        </trans-unit>
        <trans-unit id="449dbdf27f0aebf5b3ec15f606b3cbc5adf19193" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::JP</source>
          <target state="translated">Encode::JP内部使用</target>
        </trans-unit>
        <trans-unit id="c43fcf4d81bc5dc37c2f1693cf4046ad46e8bf06" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::JP::2022_JP*</source>
          <target state="translated">Encode::JP::2022_JP*内部使用。</target>
        </trans-unit>
        <trans-unit id="b7211781b63a5b485cff3f483aa4493e62335113" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::KR</source>
          <target state="translated">Encode::KR内部使用</target>
        </trans-unit>
        <trans-unit id="87865024ef8da5f651d4b8f2dfd42f62371e839c" translate="yes" xml:space="preserve">
          <source>Internally, Perl currently uses either whatever the native eight-bit character set of the platform (for example Latin-1) is, defaulting to UTF-8, to encode Unicode strings. Specifically, if all code points in the string are &lt;code&gt;0xFF&lt;/code&gt; or less, Perl uses the native eight-bit character set. Otherwise, it uses UTF-8.</source>
          <target state="translated">在内部，Perl当前使用平台的本机八位字符集（例如Latin-1）（默认为UTF-8）来编码Unicode字符串。具体来说，如果字符串中的所有代码点都为 &lt;code&gt;0xFF&lt;/code&gt; 或更小，则Perl将使用本机八位字符集。否则，它将使用UTF-8。</target>
        </trans-unit>
        <trans-unit id="5c9c0562b20651bd210573c4a3cd205f4716cb6a" translate="yes" xml:space="preserve">
          <source>Internally, native integer arithmetic (as provided by your C compiler) is used. This means that Perl's own semantics for arithmetic operations may not be preserved. One common source of trouble is the modulus of negative numbers, which Perl does one way, but your hardware may do another.</source>
          <target state="translated">在内部,我们使用的是本机整数算术(由你的 C 编译器提供)。这意味着 Perl 自己的算术运算语义可能不会被保留。一个常见的麻烦来源是负数的模数,Perl用一种方式来处理,但你的硬件可能用另一种方式来处理。</target>
        </trans-unit>
        <trans-unit id="b7fbfab5bd07346d2a0d188d0642fad2cf67e914" translate="yes" xml:space="preserve">
          <source>Internally, we often set this to an object of class Pod::Simple::Progress. That class is probably undocumented, but you may wish to look at its source.</source>
          <target state="translated">在内部,我们经常将其设置为类Pod::Simple::Progress的对象。这个类可能没有被记录下来,但你可以看看它的源代码。</target>
        </trans-unit>
        <trans-unit id="4e1f47a6ca884b2242a2daaec979f4c9e4628f25" translate="yes" xml:space="preserve">
          <source>Internally, your computer represents floating-point numbers in binary. Digital (as in powers of two) computers cannot store all numbers exactly. Some real numbers lose precision in the process. This is a problem with how computers store numbers and affects all computer languages, not just Perl.</source>
          <target state="translated">在内部,你的计算机用二进制表示浮点数字。数字(如二的幂)计算机不可能精确地存储所有数字。一些实数在这个过程中会失去精度。这是计算机存储数字的一个问题,影响了所有的计算机语言,而不仅仅是Perl。</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="5b92377b87e725e0dd0672bfd114d434b8fa7df8" translate="yes" xml:space="preserve">
          <source>Internals - Reserved special namespace for internals related functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3272f534c54bc991446f61c8eb13e09347dc7ac" translate="yes" xml:space="preserve">
          <source>Internals and C Language Interface</source>
          <target state="translated">内部和C语言接口</target>
        </trans-unit>
        <trans-unit id="221f3b6d81d4077e193de47fb71efa7ac821cbb0" translate="yes" xml:space="preserve">
          <source>International Organization for Standardization &lt;a href=&quot;http://www.iso.ch/&quot;&gt;http://www.iso.ch/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e7980ec1f234461f5c5cc8a7f141d36197c7ac" translate="yes" xml:space="preserve">
          <source>Internationalisation</source>
          <target state="translated">Internationalisation</target>
        </trans-unit>
        <trans-unit id="8f2a515a6b360e659af1aa0a2bbe7a1464bcd610" translate="yes" xml:space="preserve">
          <source>Internationalization (I18N) and localization (L10N) are supported at least in principle even on EBCDIC platforms. The details are system-dependent and discussed under the &lt;a href=&quot;#OS-ISSUES&quot;&gt;&quot;OS ISSUES&quot;&lt;/a&gt; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31cadca51461dbf1ea6607e7802c11fbe6ff93d3" translate="yes" xml:space="preserve">
          <source>Internationalization (I18N) and localization (L10N) are supported at least in principle even on EBCDIC platforms. The details are system-dependent and discussed under the &lt;a href=&quot;#OS-ISSUES&quot;&gt;OS ISSUES&lt;/a&gt; section below.</source>
          <target state="translated">即使在EBCDIC平台上，至少在原则上也支持国际化（I18N）和本地化（L10N）。详细信息取决于系统，并在下面的&amp;ldquo; &lt;a href=&quot;#OS-ISSUES&quot;&gt;操作系统问题&amp;rdquo;&lt;/a&gt;部分中进行了讨论。</target>
        </trans-unit>
        <trans-unit id="06442c59ec9f24811c5d9eb359e2f21b42d4c792" translate="yes" xml:space="preserve">
          <source>Internationalization and Locale</source>
          <target state="translated">国际化和本地化</target>
        </trans-unit>
        <trans-unit id="46c7578271b4ab36db28528f49822a53c8afcb81" translate="yes" xml:space="preserve">
          <source>Internationalization, as defined in the C and POSIX standards, can be criticized as incomplete and ungainly. They also have a tendency, like standards groups, to divide the world into nations, when we all know that the world can equally well be divided into bankers, bikers, gamers, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7421cfdcae4df82cd94a16e9b01d52930cf4a8c" translate="yes" xml:space="preserve">
          <source>Internationalization, as defined in the C and POSIX standards, can be criticized as incomplete, ungainly, and having too large a granularity. (Locales apply to a whole process, when it would arguably be more useful to have them apply to a single thread, window group, or whatever.) They also have a tendency, like standards groups, to divide the world into nations, when we all know that the world can equally well be divided into bankers, bikers, gamers, and so on.</source>
          <target state="translated">在C和POSIX标准中定义的国际化,可以被批评为不完整、不美观和粒度太大。(Locales适用于整个进程,而让它们适用于单个线程、窗口组或其他什么东西可能会更有用。)它们也有一种倾向,就像标准组一样,把世界划分为国家,而我们都知道,世界同样可以划分为银行家、自行车手、游戏玩家等等。</target>
        </trans-unit>
        <trans-unit id="c150f55df149b9e7642e03589abcd3eb462548e7" translate="yes" xml:space="preserve">
          <source>Internet Assigned Numbers Authority &lt;a href=&quot;http://www.iana.org/&quot;&gt;http://www.iana.org/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e18cc52391003fa5303fbdac90ff76add1db9f3" translate="yes" xml:space="preserve">
          <source>Internet Line Terminators</source>
          <target state="translated">互联网线路终端机</target>
        </trans-unit>
        <trans-unit id="1ace89f6b9c54bf536f959a6a92a52a0f9188777" translate="yes" xml:space="preserve">
          <source>Internet Protocol, or Intellectual Property.</source>
          <target state="translated">互联网协议,或知识产权。</target>
        </trans-unit>
        <trans-unit id="6aafd8134caf0f288faa302a3a8189c60711fc0c" translate="yes" xml:space="preserve">
          <source>Internet TCP Clients and Servers</source>
          <target state="translated">互联网TCP客户端和服务器</target>
        </trans-unit>
        <trans-unit id="f4a9147272ff83f2cf2d940d5441a60e554132ae" translate="yes" xml:space="preserve">
          <source>Internet language tags, as defined in RFC 3066, are a formalism for denoting human languages. The two-letter ISO 639-1 language codes are well known (as &quot;en&quot; for English), as are their forms when qualified by a country code (&quot;en-US&quot;). Less well-known are the arbitrary-length non-ISO codes (like &quot;i-mingo&quot;), and the recently (in 2001) introduced three-letter ISO-639-2 codes.</source>
          <target state="translated">RFC 3066中定义的因特网语言标记是表示人类语言的一种形式。双字母的ISO 639-1语言代码是众所周知的(如英语的 &quot;en&quot;),当它们被国家代码限定时,其形式也是如此(&quot;en-US&quot;)。较不知名的是任意长度的非ISO代码(如 &quot;i-mingo&quot;),以及最近(2001年)推出的三字母ISO-639-2代码。</target>
        </trans-unit>
        <trans-unit id="d1f27df0b0f458a0b4241c741d83baaaba6cee55" translate="yes" xml:space="preserve">
          <source>Interoperating with Pbzip2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645bb0cb3effc0c464d1fa2ee02c7473d9c16ab6" translate="yes" xml:space="preserve">
          <source>Interpolated scalars and arrays are converted internally to the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;.&quot;&lt;/code&gt; catenation operations. Thus, &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; becomes:</source>
          <target state="translated">内插标量和数组在内部转换为 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 分类操作。因此， &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; 变为：</target>
        </trans-unit>
        <trans-unit id="7b7796550c9a05d4af98c0f9b17a2e334cf3e552" translate="yes" xml:space="preserve">
          <source>Interpolated scalars and arrays are converted internally to the &lt;code&gt;join&lt;/code&gt; and &lt;code&gt;&quot;.&quot;&lt;/code&gt; catenation operations. Thus, &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc8312ce8a1d5c2a7ed5ed38a0c5c565ab477c8" translate="yes" xml:space="preserve">
          <source>Interpolating an array or slice interpolates the elements in order, separated by the value of &lt;code&gt;$&quot;&lt;/code&gt; , so is equivalent to interpolating &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; $&quot;, @array&lt;/code&gt; . &quot;Punctuation&quot; arrays such as &lt;code&gt;@*&lt;/code&gt; are usually interpolated only if the name is enclosed in braces &lt;code&gt;@{*}&lt;/code&gt;, but the arrays &lt;code&gt;@_&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; , and &lt;code&gt;@-&lt;/code&gt; are interpolated even without braces.</source>
          <target state="translated">插值数组或切片按顺序插值元素，以 &lt;code&gt;$&quot;&lt;/code&gt; 的值分隔，因此等效于插值 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; $&quot;, @array&lt;/code&gt; 。 &amp;ldquo;标点符号&amp;rdquo;阵列如 &lt;code&gt;@*&lt;/code&gt; 如果名称被包围在括号通常只内插 &lt;code&gt;@{*}&lt;/code&gt; ，但阵列 &lt;code&gt;@_&lt;/code&gt; ， &lt;code&gt;@+&lt;/code&gt; ，和 &lt;code&gt;@-&lt;/code&gt; 甚至没有括号内插。</target>
        </trans-unit>
        <trans-unit id="c89b1d270440efce1fe96c18e4bb21c6ce7e1f28" translate="yes" xml:space="preserve">
          <source>Interpolating an array or slice interpolates the elements in order, separated by the value of &lt;code&gt;$&quot;&lt;/code&gt;, so is equivalent to interpolating &lt;code&gt;join $&quot;, @array&lt;/code&gt;. &quot;Punctuation&quot; arrays such as &lt;code&gt;@*&lt;/code&gt; are usually interpolated only if the name is enclosed in braces &lt;code&gt;@{*}&lt;/code&gt;, but the arrays &lt;code&gt;@_&lt;/code&gt;, &lt;code&gt;@+&lt;/code&gt;, and &lt;code&gt;@-&lt;/code&gt; are interpolated even without braces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="938c8acd8c9d50a2d8734d4eebce781a661d4c88" translate="yes" xml:space="preserve">
          <source>Interpolation in patterns has several quirks: &lt;code&gt;$|&lt;/code&gt; , &lt;code&gt;$(&lt;/code&gt; , &lt;code&gt;$)&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; and &lt;code&gt;@-&lt;/code&gt; are not interpolated, and constructs &lt;code&gt;$var[SOMETHING]&lt;/code&gt; are voted (by several different estimators) to be either an array element or &lt;code&gt;$var&lt;/code&gt; followed by an RE alternative. This is where the notation &lt;code&gt;${arr[$bar]}&lt;/code&gt; comes handy: &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; is interpreted as array element &lt;code&gt;-9&lt;/code&gt; , not as a regular expression from the variable &lt;code&gt;$arr&lt;/code&gt; followed by a digit, which would be the interpretation of &lt;code&gt;/$arr[0-9]/&lt;/code&gt; . Since voting among different estimators may occur, the result is not predictable.</source>
          <target state="translated">插值模式有几个怪癖： &lt;code&gt;$|&lt;/code&gt; ， &lt;code&gt;$(&lt;/code&gt; ， &lt;code&gt;$)&lt;/code&gt; ， &lt;code&gt;@+&lt;/code&gt; 和 &lt;code&gt;@-&lt;/code&gt; 不进行插值，并且构造 &lt;code&gt;$var[SOMETHING]&lt;/code&gt; 被投票（由几个不同的估计量）为数组元素或 &lt;code&gt;$var&lt;/code&gt; 后跟RE替代项。这是符号 &lt;code&gt;${arr[$bar]}&lt;/code&gt; 派上用场的地方： &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; 被解释为数组元素 &lt;code&gt;-9&lt;/code&gt; ，而不是变量 &lt;code&gt;$arr&lt;/code&gt; 的正则表达式，后跟数字，这就是对 &lt;code&gt;/$arr[0-9]/&lt;/code&gt; 。由于可能会发生不同估算器之间的投票，因此结果是不可预测的。</target>
        </trans-unit>
        <trans-unit id="39ed28583e84f6b41afb2ccf6f513cf965009d02" translate="yes" xml:space="preserve">
          <source>Interpolation in patterns has several quirks: &lt;code&gt;$|&lt;/code&gt;, &lt;code&gt;$(&lt;/code&gt;, &lt;code&gt;$)&lt;/code&gt;, &lt;code&gt;@+&lt;/code&gt; and &lt;code&gt;@-&lt;/code&gt; are not interpolated, and constructs &lt;code&gt;$var[SOMETHING]&lt;/code&gt; are voted (by several different estimators) to be either an array element or &lt;code&gt;$var&lt;/code&gt; followed by an RE alternative. This is where the notation &lt;code&gt;${arr[$bar]}&lt;/code&gt; comes handy: &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; is interpreted as array element &lt;code&gt;-9&lt;/code&gt;, not as a regular expression from the variable &lt;code&gt;$arr&lt;/code&gt; followed by a digit, which would be the interpretation of &lt;code&gt;/$arr[0-9]/&lt;/code&gt;. Since voting among different estimators may occur, the result is not predictable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b1ed4106cc19f9516b8700eff6b51f8a50bc7e" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string. A &quot;0x&quot; or &quot;x&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">将输入内容解释为十六进制字符串。前缀 &quot;0x &quot;或 &quot;x &quot;是可选的。如果存在前缀,一个下划线字符可以放在前缀之后,或者放在任何两个数字之间。如果输入无效,将返回一个NaN。</target>
        </trans-unit>
        <trans-unit id="e3c6ad2b94e17e8ed6ad8c9f4b49132292140f2b" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string. A prefix (&quot;0b&quot; or &quot;b&quot;, ignoring case) is optional. A single underscore character (&quot;_&quot;) may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ae7a8b8abddae828432695e232afb3455b5e34" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string.A prefix (&quot;0x&quot;, &quot;x&quot;, ignoring case) is optional. A single underscore character (&quot;_&quot;) may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72044a388d08d12a68e1993790c0be63bb048467" translate="yes" xml:space="preserve">
          <source>Interpret input as an octal string. A single underscore character (&quot;_&quot;) may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a91bb371c7a5d73707f3bf850be5ff775864c2" translate="yes" xml:space="preserve">
          <source>Interpret results strictly.</source>
          <target state="translated">严格解释结果。</target>
        </trans-unit>
        <trans-unit id="7bc19d89b05f97e1ecec77b1cd80333965f8eac8" translate="yes" xml:space="preserve">
          <source>Interpret the input as a binary string. A &quot;0b&quot; or &quot;b&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">将输入内容解释为二进制字符串。前缀 &quot;0b &quot;或 &quot;b &quot;是可选的。一个下划线字符可以放在前缀之后,如果存在的话,或者放在任何两个数字之间。如果输入无效,将返回一个NaN。</target>
        </trans-unit>
        <trans-unit id="d76880ffa69808c7f715164c615fdf27a78c1785" translate="yes" xml:space="preserve">
          <source>Interpret the input as a byte string, assuming big endian byte order. The output is always a non-negative, finite integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="453c8b8b13743efe964db57b55ed8957df8eedf7" translate="yes" xml:space="preserve">
          <source>Interpret the input as a value encoded as described in IEEE754-2008. The input can be given as a byte string, hex string or binary string. The input is assumed to be in big-endian byte-order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb708839bb76c97a78f59fb0d153db3bcac65ad" translate="yes" xml:space="preserve">
          <source>Interpret the input as an octal string and return the corresponding value. A &quot;0&quot; (zero) prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">将输入的内容解释为八进制字符串,并返回相应的值。前缀 &quot;0&quot;(零)是可选的。一个下划线字符可以放在前缀之后(如果存在的话),或者放在任何两个数字之间。如果输入无效,将返回一个NaN。</target>
        </trans-unit>
        <trans-unit id="b29af10220daeb6f80d20ec4774b2643643e00f8" translate="yes" xml:space="preserve">
          <source>Interpretation of the &lt;code&gt;gecos&lt;/code&gt; field varies between systems, but traditionally holds 4 comma-separated fields containing the user's full name, office location, work phone number, and home phone number. An &lt;code&gt;&amp;amp;&lt;/code&gt; in the gecos field should be replaced by the user's properly capitalized login &lt;code&gt;name&lt;/code&gt; . The &lt;code&gt;shell&lt;/code&gt; field, if blank, must be assumed to be</source>
          <target state="translated">&lt;code&gt;gecos&lt;/code&gt; 字段的解释在系统之间有所不同，但传统上会保留4个以逗号分隔的字段，其中包含用户的全名，办公室位置，工作电话号码和家庭电话号码。gecos字段中的 &lt;code&gt;&amp;amp;&lt;/code&gt; 应当替换为用户正确大写的登录 &lt;code&gt;name&lt;/code&gt; 。该 &lt;code&gt;shell&lt;/code&gt; 字段，如果空白，必须假定</target>
        </trans-unit>
        <trans-unit id="0976c6eb851bd29a7c13436a47fce586e64022a2" translate="yes" xml:space="preserve">
          <source>Interpretation of the &lt;code&gt;gecos&lt;/code&gt; field varies between systems, but traditionally holds 4 comma-separated fields containing the user's full name, office location, work phone number, and home phone number. An &lt;code&gt;&amp;amp;&lt;/code&gt; in the gecos field should be replaced by the user's properly capitalized login &lt;code&gt;name&lt;/code&gt;. The &lt;code&gt;shell&lt;/code&gt; field, if blank, must be assumed to be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="920aa278d5fde4bc26b94a177b294481884c28c0" translate="yes" xml:space="preserve">
          <source>Interpretation of the buffer's octets can be abstracted out by using the slightly higher-level functions &lt;a href=&quot;#lex_peek_unichar&quot;&gt;&quot;lex_peek_unichar&quot;&lt;/a&gt; and &lt;a href=&quot;#lex_read_unichar&quot;&gt;&quot;lex_read_unichar&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cfbb6233c7812b488cce8d6bd3af2af9ab5bc6" translate="yes" xml:space="preserve">
          <source>Interpretation of the buffer's octets can be abstracted out by using the slightly higher-level functions &lt;a href=&quot;#lex_peek_unichar&quot;&gt;lex_peek_unichar&lt;/a&gt; and &lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;.</source>
          <target state="translated">可以通过使用稍微更高级别的函数&lt;a href=&quot;#lex_peek_unichar&quot;&gt;lex_peek_unichar&lt;/a&gt;和&lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;来抽象出缓冲区八位位组的解释。</target>
        </trans-unit>
        <trans-unit id="92d3f8b03230be860eb13ba99ed5e322ec25a6b0" translate="yes" xml:space="preserve">
          <source>Interpreter</source>
          <target state="translated">Interpreter</target>
        </trans-unit>
        <trans-unit id="b588c5a0249a1b98f3880c0e5147ba7d315538dd" translate="yes" xml:space="preserve">
          <source>Interpreter embedded in larger application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e94340be7381aa50cefb2bdc5e7587b72758de" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding numeric value. If EXPR is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c7c558d92a61d6a4e1c001e4a147b288928483" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding value. (To convert strings that might start with either &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; , or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt;.) If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">将EXPR解释为十六进制字符串，并返回相应的值。（要转换可能与任一开头的字符串 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;0x&lt;/code&gt; ，或 &lt;code&gt;0b&lt;/code&gt; ，见&lt;a href=&quot;#oct&quot;&gt;年10月&lt;/a&gt;）。如果省略EXPR，使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80995a80c008a9c2a1eb866370afb34599cdd244" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding value. (To convert strings that might start with either &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; , or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;.) If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">将EXPR解释为十六进制字符串，并返回相应的值。（要转换可能与任一开头的字符串 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;0x&lt;/code&gt; ，或 &lt;code&gt;0b&lt;/code&gt; ，见&lt;a href=&quot;oct&quot;&gt;年10月&lt;/a&gt;）。如果省略EXPR，使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58710e925b06b5bcd617d0a02276a6d507de1826" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as an octal string and returns the corresponding value. (If EXPR happens to start off with &lt;code&gt;0x&lt;/code&gt; , interprets it as a hex string. If EXPR starts off with &lt;code&gt;0b&lt;/code&gt;, it is interpreted as a binary string. Leading whitespace is ignored in all three cases.) The following will handle decimal, binary, octal, and hex in standard Perl notation:</source>
          <target state="translated">将EXPR解释为八进制字符串，并返回相应的值。（如果EXPR恰好以 &lt;code&gt;0x&lt;/code&gt; 开头，则将其解释为十六进制字符串。如果EXPR是以 &lt;code&gt;0b&lt;/code&gt; 开头，则将其解释为二进制字符串。在所有三种情况下都将忽略前导空格。）以下将处理十进制，二进制，八进制，标准Perl表示法为十六进制：</target>
        </trans-unit>
        <trans-unit id="ae1424465a8d50534920bcc14b8cbe5ef86892ac" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as an octal string and returns the corresponding value. (If EXPR happens to start off with &lt;code&gt;0x&lt;/code&gt;, interprets it as a hex string. If EXPR starts off with &lt;code&gt;0b&lt;/code&gt;, it is interpreted as a binary string. Leading whitespace is ignored in all three cases.) The following will handle decimal, binary, octal, and hex in standard Perl notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d683f7db5d587ede8e14b4d88e6c417a5847d7" translate="yes" xml:space="preserve">
          <source>Interprocess Communication (IPC)</source>
          <target state="translated">进程间通信(IPC)</target>
        </trans-unit>
        <trans-unit id="1e11457cea032ab0c21c71c69e4211f081e8849e" translate="yes" xml:space="preserve">
          <source>Interprocess Communication.</source>
          <target state="translated">进程间通信。</target>
        </trans-unit>
        <trans-unit id="a5a495c9d0578a0494f49fc6ace5fd6e9fed4e9a" translate="yes" xml:space="preserve">
          <source>Interrupting IO</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58447a233c711f903a2587b91bb291042f4b45da" translate="yes" xml:space="preserve">
          <source>Intersection is used generally for getting the common characters matched by two (or more) classes. It's important to remember not to use &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; for the first set; that would be intersecting with nothing, resulting in an empty set.</source>
          <target state="translated">交集通常用于获取由两个（或更多）类匹配的公共字符。重要的是要记住不要在第一组中使用 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 。那将没有任何东西相交，从而导致一个空集。</target>
        </trans-unit>
        <trans-unit id="d34174297460fdd67bf61d2f8749421841769688" translate="yes" xml:space="preserve">
          <source>Intersection is used generally for getting the common characters matched by two (or more) classes. It's important to remember not to use &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; for the first set; that would be intersecting with nothing, resulting in an empty set. (Similarly using &lt;code&gt;&quot;-&quot;&lt;/code&gt; for the first set does nothing).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4724a76d8bc17dfefb1daee3b6d5be588f4c613" translate="yes" xml:space="preserve">
          <source>Introduce the</source>
          <target state="translated">介绍一下</target>
        </trans-unit>
        <trans-unit id="dde62d185b627cf5b7ce046a41566f84e22267ed" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.005</source>
          <target state="translated">在Perl 5.005中引入</target>
        </trans-unit>
        <trans-unit id="25641bc26420a80c8ddbcf38615ca35ce5d7cb63" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.10.0</source>
          <target state="translated">在Perl 5.10.0中引入</target>
        </trans-unit>
        <trans-unit id="b91aad730399f200ac6a5b6dba6fed9c61c025f5" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.12</source>
          <target state="translated">在Perl 5.12中引入</target>
        </trans-unit>
        <trans-unit id="be57168adcd5cd07b75f1c9b6124df0daf76c3bd" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.14.0</source>
          <target state="translated">在Perl 5.14.0中引入</target>
        </trans-unit>
        <trans-unit id="b294ac0a4f8c5992774c8112441dc302d5816a1f" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.20.0</source>
          <target state="translated">在Perl 5.20.0中引入</target>
        </trans-unit>
        <trans-unit id="0c3a6017cbcf96eeafb4387eedc602152339297c" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.22.0</source>
          <target state="translated">在Perl 5.22.0中引入</target>
        </trans-unit>
        <trans-unit id="7993785cfbc9e7981dcd229895be4a20fdb9620c" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.6.0</source>
          <target state="translated">在Perl 5.6.0中引入</target>
        </trans-unit>
        <trans-unit id="31cd408fa26c1acb52eade6304b9c5ef7d3abe35" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.6.1</source>
          <target state="translated">在Perl 5.6.1中引入</target>
        </trans-unit>
        <trans-unit id="51378bbd1f0bc4027eee05ffb1e7f6b0f83420b0" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.8.0</source>
          <target state="translated">在Perl 5.8.0中引入</target>
        </trans-unit>
        <trans-unit id="79667c9718432940922f2e42f6facd3cdd4d3deb" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.9.0</source>
          <target state="translated">在Perl 5.9.0中引入</target>
        </trans-unit>
        <trans-unit id="bb8c7b3973c6116a9525785ab93801f9d4d4fd02" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.9.2</source>
          <target state="translated">在Perl 5.9.2中引入</target>
        </trans-unit>
        <trans-unit id="091f1001c9d6a40187930fa44574a4f653880f2a" translate="yes" xml:space="preserve">
          <source>Introduced in perl 5.25.12.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef8951301d241cbc829612e64580020e610d91f" translate="yes" xml:space="preserve">
          <source>Introduced in: 5.11.2</source>
          <target state="translated">引入:5.11.2</target>
        </trans-unit>
        <trans-unit id="a01d17d00de94eaa77554eca767e361f42130168" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.10</source>
          <target state="translated">引入。Perl 5.10</target>
        </trans-unit>
        <trans-unit id="1e5c7e1205af583a405c6c00903c26fad40a5e6a" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.11.2</source>
          <target state="translated">引入。Perl 5.11.2</target>
        </trans-unit>
        <trans-unit id="d272e647109f1769e2b49a3e24be3094dd708435" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.18</source>
          <target state="translated">引入。Perl 5.18</target>
        </trans-unit>
        <trans-unit id="a5210098032cc4bc65f6c8263851cc2d7666b61d" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.22.0</source>
          <target state="translated">引入。Perl 5.22.0</target>
        </trans-unit>
        <trans-unit id="5a3a1683287083d64acee02ab986003bcf802274" translate="yes" xml:space="preserve">
          <source>Introduced just after perl5.7.0, this is a re-implementation of the above abstraction which allows perl more control over how IO is done as it decouples IO from the way the operating system and C library choose to do things. For USE_PERLIO PerlIO * has an extra layer of indirection - it is a pointer-to-a-pointer. This allows the PerlIO * to remain with a known value while swapping the implementation around underneath</source>
          <target state="translated">这是在 perl5.7.0 之后引入的,是对上述抽象的重新实现,它允许 perl 对 IO 的处理方式有更多的控制,因为它将 IO 与操作系统和 C 库选择的处理方式解耦。对于 USE_PERLIO,PerlIO*多了一层间接性--它是一个指针到指针。这使得 PerlIO*可以保持一个已知的值,同时在下面的实现中进行交换。</target>
        </trans-unit>
        <trans-unit id="bc2d2fa71d8eaea749023a72cddaf418fe1cb149" translate="yes" xml:space="preserve">
          <source>Introduces a catch block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;&quot;Exception Handling&quot; in perlguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df90fec901ab6b3e3c92b7090f061ccf2d6c4aa2" translate="yes" xml:space="preserve">
          <source>Introduces a catch block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">引入了一个捕获块。请参阅&lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlguts中的异常处理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0c2f1d96cf5d9698341444cc5bc1eb344088014" translate="yes" xml:space="preserve">
          <source>Introducing (non-read-only) globals</source>
          <target state="translated">介绍(非只读)globals</target>
        </trans-unit>
        <trans-unit id="154cc0bb0700575719a65b65f0bfb0fc9a438358" translate="yes" xml:space="preserve">
          <source>Introducing read-only (const) globals is okay, as long as you verify with e.g. &lt;code&gt;nm libperl.a|egrep -v ' [TURtr] '&lt;/code&gt; (if your &lt;code&gt;nm&lt;/code&gt; has BSD-style output) that the data you added really is read-only. (If it is, it shouldn't show up in the output of that command.)</source>
          <target state="translated">只要您使用 &lt;code&gt;nm libperl.a|egrep -v ' [TURtr] '&lt;/code&gt; （如果您的 &lt;code&gt;nm&lt;/code&gt; 具有BSD风格的输出）进行验证，就可以真正引入只读的（常量）全局变量，只要。（如果是，则不应在该命令的输出中显示它。）</target>
        </trans-unit>
        <trans-unit id="dcba11e20d56606a737ad2a86071e282fcf184cf" translate="yes" xml:space="preserve">
          <source>Introducing variables inside for()</source>
          <target state="translated">在for()中引入变量</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="c3cbe25b5093a9e955ec87889df443c3c88a6700" translate="yes" xml:space="preserve">
          <source>Introduction to the context stack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad0875833b290c88f0275f52c45f410d897ca9f" translate="yes" xml:space="preserve">
          <source>Introductory Texts</source>
          <target state="translated">介绍性文本</target>
        </trans-unit>
        <trans-unit id="35b4535865312e74cc4ee5fddabecf0f89eff7b1" translate="yes" xml:space="preserve">
          <source>Invalid %s attribute: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16e49525bf4e99622a920415ffb99daaab7bb8c" translate="yes" xml:space="preserve">
          <source>Invalid %s attributes: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f278621344da2113b386e7cf493f5b7effda7cb6" translate="yes" xml:space="preserve">
          <source>Invalid =encoding syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ccfdff90507fec490f3681db3843b0d6286ad3" translate="yes" xml:space="preserve">
          <source>Invalid [] range &quot;%s&quot; in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ca1b8b000c05ddca3141e99f4a127d6bf62783" translate="yes" xml:space="preserve">
          <source>Invalid \0 character in %s for %s: %s\0%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5167b1a82e18cf454d4bc0f759f3a654b3597c1" translate="yes" xml:space="preserve">
          <source>Invalid alias name %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2a343ef8d4bd75601d86b329b7a01d8c329447" translate="yes" xml:space="preserve">
          <source>Invalid alias name %s in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ab829daff8a5e5f6392ceed1cb4afa7bad1191" translate="yes" xml:space="preserve">
          <source>Invalid attribute name %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de5bc9920e09cfc5aa332c66ec4d5cfec265952" translate="yes" xml:space="preserve">
          <source>Invalid attribute name %s in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05e151899283ad3fa0d3b17b289c6f5652fe00d4" translate="yes" xml:space="preserve">
          <source>Invalid character in \N{...}; marked by &amp;lt;-- HERE in \N{%s}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2863c47889763b20775fa1947348a4c08ab6c002" translate="yes" xml:space="preserve">
          <source>Invalid character in charnames alias definition; marked by &amp;lt;-- HERE in '%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71b8ff5c88697d1a550d6673237e1107c606759" translate="yes" xml:space="preserve">
          <source>Invalid conversion in %s: &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da241ea775f4ffbb146ef9175cab747e1e17f61" translate="yes" xml:space="preserve">
          <source>Invalid errors setting &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88ec4ba5b78e52ef0ab2ed660f408ead1951cbe" translate="yes" xml:space="preserve">
          <source>Invalid escape in the specified encoding in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519c9635790d830978d5164b3ad7937b453ade67" translate="yes" xml:space="preserve">
          <source>Invalid hexadecimal number in \N{U+...}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4e943158cfd55f7caa089383100312254493ec" translate="yes" xml:space="preserve">
          <source>Invalid hexadecimal number in \N{U+...} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87131ca7be09c630d75c4fef49d87656455519cb" translate="yes" xml:space="preserve">
          <source>Invalid module name %s with -%c option: contains single ':'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafc147d5721e32ab438b2e1facd6104c69c8cdb" translate="yes" xml:space="preserve">
          <source>Invalid mro name: '%s'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="997bb1def2a65589fb34cef75e7877e3c194aa47" translate="yes" xml:space="preserve">
          <source>Invalid negative number (%s) in chr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ebf8d124c561f25f30e95ab6d9cc2965fe72ff" translate="yes" xml:space="preserve">
          <source>Invalid number '%s' for -C option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b24f046499eeb08ade4a703bdfb2ca0850444e" translate="yes" xml:space="preserve">
          <source>Invalid quantifier in {,} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c55ed435afff8d41b70ade097c0698032d0c012" translate="yes" xml:space="preserve">
          <source>Invalid quote specification &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5c174cc04f03d39141a30a0cfc0c41bc31bb3f" translate="yes" xml:space="preserve">
          <source>Invalid range &quot;%s&quot; in transliteration operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7bf96d82c63323749d7987b1d0a19d37b194c78" translate="yes" xml:space="preserve">
          <source>Invalid reference to group in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b451f3135fd8389070687455f7342fb7a8b6308" translate="yes" xml:space="preserve">
          <source>Invalid separator character %s in PerlIO layer specification %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97ba0ffc9967cd5abf07936f7edcde4477f44be" translate="yes" xml:space="preserve">
          <source>Invalid separator character %s in attribute list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="132cab989b11d24a0daa70576a5563553614029c" translate="yes" xml:space="preserve">
          <source>Invalid strict version format (%s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac063110370f25128c7648841d4d47e40ca1a6f" translate="yes" xml:space="preserve">
          <source>Invalid type '%s' in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40fac60217e12bb0c9148c5e13124cc1ea622f52" translate="yes" xml:space="preserve">
          <source>Invalid version format (%s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a2b722bc1d83834529dc472a04775d93256603" translate="yes" xml:space="preserve">
          <source>Invalid version object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7111e9430dac55fd4a6c0b16ea2e92ba2187d8a" translate="yes" xml:space="preserve">
          <source>Invalidates method caching on any child classes of the given stash, so that they might notice the changes in this one.</source>
          <target state="translated">使给定储藏的任何子类的方法缓存无效,这样他们可能会注意到这个储藏的变化。</target>
        </trans-unit>
        <trans-unit id="6254374b19c61ff561460206a4f9194f4bcd1a52" translate="yes" xml:space="preserve">
          <source>Invalidates the method cache of any classes dependent on the given class. This is not normally necessary. The only known case where pure perl code can confuse the method cache is when you manually install a new constant subroutine by using a readonly scalar value, like the internals of &lt;a href=&quot;constant&quot;&gt;constant&lt;/a&gt; do. If you find another case, please report it so we can either fix it or document the exception here.</source>
          <target state="translated">使依赖于给定类的任何类的方法缓存无效。通常这不是必需的。纯perl代码可能会使方法缓存混乱的唯一已知情况是，当您使用只读标量值手动安装新的常量子例程时，就像&lt;a href=&quot;constant&quot;&gt;constant&lt;/a&gt;内部一样。如果您发现其他情况，请报告，以便我们进行修复或在此处记录例外情况。</target>
        </trans-unit>
        <trans-unit id="c0df4881ff3f493d5106f68dbab35c513534aed4" translate="yes" xml:space="preserve">
          <source>Inventory management of installed modules</source>
          <target state="translated">已安装模块的库存管理</target>
        </trans-unit>
        <trans-unit id="14c5c3735ce54ff56e113f2608fb558c2d638a18" translate="yes" xml:space="preserve">
          <source>Inversion lists are a compact way of specifying Unicode property-value definitions. The 0th item in the list is the lowest code point that has the property-value. The next item (item [1]) is the lowest code point beyond that one that does NOT have the property-value. And the next item beyond that ([2]) is the lowest code point beyond that one that does have the property-value, and so on. Put another way, each element in the list gives the beginning of a range that has the property-value (for even numbered elements), or doesn't have the property-value (for odd numbered elements). The name for this data structure stems from the fact that each element in the list toggles (or inverts) whether the corresponding range is or isn't on the list.</source>
          <target state="translated">反转列表是指定Unicode属性值定义的一种紧凑方式。列表中的第0项是拥有属性值的最低码点。下一个项目(项目[1])是该项目之外不具有属性值的最低码点。下一个项目([2])是有属性值的那个项目之外的最低码点,以此类推。换句话说,列表中的每个元素都给出了一个范围的开始,这个范围有属性值(对于偶数元素),或者没有属性值(对于奇数元素)。这个数据结构的名称源于列表中的每个元素都会切换(或反转)相应的范围是否在列表中。</target>
        </trans-unit>
        <trans-unit id="65b853d505ac70a8422f3186ac06caa076307275" translate="yes" xml:space="preserve">
          <source>Inverting a character class which contains a multi-character sequence is illegal in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31204d44a5939448655207a55e393849306b131a" translate="yes" xml:space="preserve">
          <source>Investigate whether &lt;code&gt;POSIX::dup2&lt;/code&gt; upsets BSD's &lt;code&gt;kqueue&lt;/code&gt; watchers, and if so, consider what possible workarounds might be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e6379916ac816d709ea169dcdb0ea2c85538b2" translate="yes" xml:space="preserve">
          <source>Invocation requires the command to be executed or a coderef and optionally a hashref of options:</source>
          <target state="translated">调用需要执行的命令或coderef和可选的选项hashref。</target>
        </trans-unit>
        <trans-unit id="9866e55ebd73eaa4dfd6d462e055f3a88a4fa2b2" translate="yes" xml:space="preserve">
          <source>Invoke a magic method (like FETCH).</source>
          <target state="translated">援用一种神奇的方法(如FETCH)。</target>
        </trans-unit>
        <trans-unit id="729e0ead914d111524b46b874fed43976337fb94" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_comment&lt;/code&gt; returns true.</source>
          <target state="translated">如果 &lt;code&gt;$result-&amp;gt;is_comment&lt;/code&gt; 返回true，则调用。</target>
        </trans-unit>
        <trans-unit id="b6d3760550f46e7b28bbf7a09042b6769acf3c7e" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_plan&lt;/code&gt; returns true.</source>
          <target state="translated">如果 &lt;code&gt;$result-&amp;gt;is_plan&lt;/code&gt; 返回true，则调用。</target>
        </trans-unit>
        <trans-unit id="4d5c6b94ee048c918e4535240e958632aecb1a6d" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; returns true.</source>
          <target state="translated">如果 &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; 返回true，则调用。</target>
        </trans-unit>
        <trans-unit id="136fe5e37a3fd848b78d877c253e754a822cac52" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_unknown&lt;/code&gt; returns true.</source>
          <target state="translated">如果 &lt;code&gt;$result-&amp;gt;is_unknown&lt;/code&gt; 返回true，则调用此方法。</target>
        </trans-unit>
        <trans-unit id="632983081cf348fad68b5fcc938bef7d785aa8ce" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_version&lt;/code&gt; returns true.</source>
          <target state="translated">如果 &lt;code&gt;$result-&amp;gt;is_version&lt;/code&gt; 返回true，则调用。</target>
        </trans-unit>
        <trans-unit id="dab118fbd97b5abfc5d3df38d7cc4bb27d7a5389" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_yaml&lt;/code&gt; returns true.</source>
          <target state="translated">如果 &lt;code&gt;$result-&amp;gt;is_yaml&lt;/code&gt; 返回true，则调用此方法。</target>
        </trans-unit>
        <trans-unit id="ad610951e9b392fd2e2ceadbb198a63f8613f82d" translate="yes" xml:space="preserve">
          <source>Invoked when there are no more lines to be parsed. Since there is no accompanying &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object the &lt;code&gt;TAP::Parser&lt;/code&gt; object is passed instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4fc12fcbbbf739e9ecf3604f9dbc469d9a9587a" translate="yes" xml:space="preserve">
          <source>Invoked when there are no more lines to be parsed. Since there is no accompanying &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object the &lt;code&gt;TAP::Parser&lt;/code&gt; object is passed instead.</source>
          <target state="translated">当没有更多行需要解析时调用。由于没有随附的&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;对象，因此将传递 &lt;code&gt;TAP::Parser&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="430786511bff9aaafff5936e905ad653f2aebe92" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_get&lt;/code&gt; on an SV if it has 'get' magic. For example, this will call &lt;code&gt;FETCH&lt;/code&gt; on a tied variable. This macro evaluates its argument more than once.</source>
          <target state="translated">如果SV具有&amp;ldquo;魔力&amp;rdquo;，则在SV 上调用 &lt;code&gt;mg_get&lt;/code&gt; 。例如，这将在绑定变量上调用 &lt;code&gt;FETCH&lt;/code&gt; 。该宏多次评估其自变量。</target>
        </trans-unit>
        <trans-unit id="63770cbaa11ab2ed8431af406f1283f32bff5b08" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_set&lt;/code&gt; on an SV if it has 'set' magic. This is necessary after modifying a scalar, in case it is a magical variable like &lt;code&gt;$|&lt;/code&gt; or a tied variable (it calls &lt;code&gt;STORE&lt;/code&gt; ). This macro evaluates its argument more than once.</source>
          <target state="translated">如果SV具有&amp;ldquo;设置&amp;rdquo;魔法，则在SV 上调用 &lt;code&gt;mg_set&lt;/code&gt; 。修改标量后，如果它是 &lt;code&gt;$|&lt;/code&gt; 类的神奇变量，这是必需的。或绑定变量（它调用 &lt;code&gt;STORE&lt;/code&gt; ）。该宏多次评估其自变量。</target>
        </trans-unit>
        <trans-unit id="d8df026416b8e868f3c4d19bec4e4735f833a540" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_set&lt;/code&gt; on an SV if it has 'set' magic. This is necessary after modifying a scalar, in case it is a magical variable like &lt;code&gt;$|&lt;/code&gt; or a tied variable (it calls &lt;code&gt;STORE&lt;/code&gt;). This macro evaluates its argument more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6065fa2fda8beaeb12ea495b85a947dc1c32d666" translate="yes" xml:space="preserve">
          <source>Invokes VMS debugger. (VMS)</source>
          <target state="translated">调用VMS调试器。(VMS)</target>
        </trans-unit>
        <trans-unit id="4a48ee301f0abac2cf4e91d0e45258fd858ca888" translate="yes" xml:space="preserve">
          <source>Invokes debugging mode. Primarily for Encode hackers.</source>
          <target state="translated">调用调试模式。主要针对Encode黑客。</target>
        </trans-unit>
        <trans-unit id="24bad1e8c0ab13d7138af070e6f8fd5104a0af38" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce a library file from object files. In scalar context, the name of the library file is returned. In list context, the library file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The following parameters are optional:</source>
          <target state="translated">调用链接器以从目标文件生成库文件。在标量上下文中，将返回库文件的名称。在列表上下文中，将返回库文件和创建的任何临时文件。必需的 &lt;code&gt;objects&lt;/code&gt; 参数以字符串（对于一个目标文件）或列表引用（对于一个或多个文件）的形式包含要处理的目标文件的名称。以下参数是可选的：</target>
        </trans-unit>
        <trans-unit id="d6dc74aaf36821077c0007a98c7212fc4b3fa1fa" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce an executable file from object files. In scalar context, the name of the executable file is returned. In list context, the executable file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The optional parameters are the same as &lt;code&gt;&lt;a href=&quot;../functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; with exception for</source>
          <target state="translated">调用链接器以从目标文件生成可执行文件。在标量上下文中，将返回可执行文件的名称。在列表上下文中，将返回可执行文件和创建的任何临时文件。必需的 &lt;code&gt;objects&lt;/code&gt; 参数以字符串（对于一个目标文件）或列表引用（对于一个或多个文件）的形式包含要处理的目标文件的名称。可选参数与 &lt;code&gt;&lt;a href=&quot;../functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; 相同，但有例外</target>
        </trans-unit>
        <trans-unit id="79f933cf2af8919cd4f873f791c92f88082706ff" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce an executable file from object files. In scalar context, the name of the executable file is returned. In list context, the executable file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The optional parameters are the same as &lt;code&gt;link&lt;/code&gt; with exception for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b673c6a72896107ce4c1c1720830db2d7090b84b" translate="yes" xml:space="preserve">
          <source>Invoking</source>
          <target state="translated">Invoking</target>
        </trans-unit>
        <trans-unit id="96cd3dba8626073590cef0284f10ba68d27dc29f" translate="yes" xml:space="preserve">
          <source>Invoking C-style &lt;code&gt;open&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7d6999362a94f744230122565df0fb30cec02f" translate="yes" xml:space="preserve">
          <source>Invoking Class Methods</source>
          <target state="translated">调用类方法</target>
        </trans-unit>
        <trans-unit id="36b849bf1b11efdfda1ba9f83f6937c3f5f3d9b5" translate="yes" xml:space="preserve">
          <source>Invoking Perl</source>
          <target state="translated">调用Perl</target>
        </trans-unit>
        <trans-unit id="d893e9caa1e5c938c432bca17fd828ff27fd449c" translate="yes" xml:space="preserve">
          <source>Invoking all versions of a method with a single call</source>
          <target state="translated">只需一次调用就可以调用一个方法的所有版本。</target>
        </trans-unit>
        <trans-unit id="24170ec2bba17eb099637b415016216327bba9b2" translate="yes" xml:space="preserve">
          <source>Invoking the test script via &quot;&lt;code&gt;make test&lt;/code&gt; &quot; did something very important. It invoked perl with all those &lt;code&gt;-I&lt;/code&gt; arguments so that it could find the various files that are part of the extension. It is</source>
          <target state="translated">通过&amp;ldquo; &lt;code&gt;make test&lt;/code&gt; &amp;rdquo; 调用测试脚本做了非常重要的事情。它使用所有这些 &lt;code&gt;-I&lt;/code&gt; 参数调用了perl，以便它可以找到扩展名中的各种文件。它是</target>
        </trans-unit>
        <trans-unit id="2ecba9a37fd38e5bf42e93fcbe6104f64a6dc5ac" translate="yes" xml:space="preserve">
          <source>Invoking the test script via &quot;&lt;code&gt;make test&lt;/code&gt;&quot; did something very important. It invoked perl with all those &lt;code&gt;-I&lt;/code&gt; arguments so that it could find the various files that are part of the extension. It is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5657593a133551a2130d25fd548705e5a0d18d8" translate="yes" xml:space="preserve">
          <source>IoFLAGS</source>
          <target state="translated">IoFLAGS</target>
        </trans-unit>
        <trans-unit id="3bb882aae446ce0088800e6387a83d4c1329eedf" translate="yes" xml:space="preserve">
          <source>IoTYPE</source>
          <target state="translated">IoTYPE</target>
        </trans-unit>
        <trans-unit id="889224e3fca24a6ab17d01fe47a45bc82244e938" translate="yes" xml:space="preserve">
          <source>Iran</source>
          <target state="translated">Iran</target>
        </trans-unit>
        <trans-unit id="eb2131ece0efe78ee8bb1ae98af6099114a8df09" translate="yes" xml:space="preserve">
          <source>Ireland</source>
          <target state="translated">Ireland</target>
        </trans-unit>
        <trans-unit id="5a017d9fae08fe8b742594c766cac2cd8dcf3595" translate="yes" xml:space="preserve">
          <source>Irish for the whole McGillicuddy. In Perl culture, a portmanteau of &amp;ldquo;sharp&amp;rdquo; and &amp;ldquo;bang&amp;rdquo;, meaning the &lt;code&gt;#!&lt;/code&gt; sequence that tells the system where to find the interpreter.</source>
          <target state="translated">整个McGillicuddy爱尔兰人。在Perl文化中，&amp;ldquo;尖锐&amp;rdquo;和&amp;ldquo;爆炸&amp;rdquo;的组合，代表 &lt;code&gt;#!&lt;/code&gt; 告诉系统在哪里可以找到解释器的序列。</target>
        </trans-unit>
        <trans-unit id="15b9752e24986e0f7c7c5303acc5a2830fc9afd6" translate="yes" xml:space="preserve">
          <source>Irix (6.5. What else?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb88b49be9395cb953eb1205ce4b4ea6acad6f1e" translate="yes" xml:space="preserve">
          <source>Irix 5.3</source>
          <target state="translated">Irix 5.3</target>
        </trans-unit>
        <trans-unit id="280a8973708779722e3c6e60a42a133ed8d4613c" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples here are in the public domain. You are permitted and encouraged to use this code and any derivatives thereof in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit to the FAQ would be courteous but is not required.</source>
          <target state="translated">不管它的分布情况如何,这里的所有代码例子都是在公共领域。我们允许并鼓励您在您自己的程序中使用这段代码和任何衍生的代码,并在您认为合适的情况下用于娱乐或盈利。在代码中简单地注释一下,并将功劳归功于FAQ将是礼貌的,但不是必须的。</target>
        </trans-unit>
        <trans-unit id="e6e987fe64dde20e286f30fd90c6b90ffeedb494" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples in these files are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</source>
          <target state="translated">不管它的分布情况如何,这些文件中的所有代码示例都在此被置于公共领域。我们允许并鼓励您在您自己的程序中使用这些代码,以获得您认为合适的乐趣或利润。在代码中作简单的注释以示感谢将是礼貌的,但不是必需的。</target>
        </trans-unit>
        <trans-unit id="16778fd5503d73f3e7cd989fda95007a4e44c18a" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples in this file are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</source>
          <target state="translated">不管它的发行情况如何,本文件中的所有代码示例都在此被置于公共领域。我们允许并鼓励您在您自己的程序中使用这些代码,以获得您认为合适的乐趣或利润。在代码中写上简单的注释以示感谢是礼貌的,但不是必须的。</target>
        </trans-unit>
        <trans-unit id="3b1335a849872557c30733349f1e4699d629a12c" translate="yes" xml:space="preserve">
          <source>Is Perl difficult to learn?</source>
          <target state="translated">Perl难学吗?</target>
        </trans-unit>
        <trans-unit id="ac0736b6a42e76cbb8b7ea3d82d9347dd47ba779" translate="yes" xml:space="preserve">
          <source>Is better written:</source>
          <target state="translated">是比较好写的。</target>
        </trans-unit>
        <trans-unit id="9f9ed743f2c1371f19760689c4a59cf333c563af" translate="yes" xml:space="preserve">
          <source>Is it possible to change the file permissions of a file on an FTP server ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32906667b7957f587634c3ad2cf7b982992ddda0" translate="yes" xml:space="preserve">
          <source>Is it safe to return a reference to local or lexical data?</source>
          <target state="translated">返回对本地或词法数据的引用是否安全?</target>
        </trans-unit>
        <trans-unit id="a15088679e31d0c4822e89f1a281a86a46e94dee" translate="yes" xml:space="preserve">
          <source>Is it the same? Well, maybe so--and maybe not. The subtle difference is that when you assign something in square brackets, you know for sure it's always a brand new reference with a new</source>
          <target state="translated">是一样的吗?嗯,也许是,也许不是。微妙的区别在于,当你把某物赋值在方括号中时,你可以确定它总是一个全新的引用,有一个新的</target>
        </trans-unit>
        <trans-unit id="c842dccd002c594c47398d7b81a3f350518d446b" translate="yes" xml:space="preserve">
          <source>Is not supported for process identification number of 0 or negative numbers. (VMS)</source>
          <target state="translated">不支持工艺识别号为0或负数。(VMS)</target>
        </trans-unit>
        <trans-unit id="85e623ea793b61351aedc1f6283751b7266d3791" translate="yes" xml:space="preserve">
          <source>Is supposed to be superseded by &lt;code&gt;IOCTL_STORAGE_GET_MEDIA_TYPES&lt;/code&gt; but is still useful for determining the types of floppy diskette formats that can be produced by a given floppy drive. See</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed13e4ee416049073be2fb55253aff4db8cf0204" translate="yes" xml:space="preserve">
          <source>Is the disk signature, a unique number assigned by Disk Administrator [</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892d60f6405f23f25c6b3ae4379071e72ec47d11" translate="yes" xml:space="preserve">
          <source>Is the feature generic enough?</source>
          <target state="translated">该功能是否足够通用?</target>
        </trans-unit>
        <trans-unit id="21550a0f41b5f7c0792d01f174b9eb78bb2eb4ca" translate="yes" xml:space="preserve">
          <source>Is the implementation generic enough to be portable?</source>
          <target state="translated">执行是否足够通用,可以移植?</target>
        </trans-unit>
        <trans-unit id="ef5914893715ffaab39210a601dc4f727d6ff4af" translate="yes" xml:space="preserve">
          <source>Is the implementation robust?</source>
          <target state="translated">执行是否有力?</target>
        </trans-unit>
        <trans-unit id="78090775b623989661f8da8dfe386a79dbfa661d" translate="yes" xml:space="preserve">
          <source>Is the implementation tested?</source>
          <target state="translated">执行情况是否经过测试?</target>
        </trans-unit>
        <trans-unit id="7ff173c83692442c34b8acc41b270ff651c2392a" translate="yes" xml:space="preserve">
          <source>Is the scalar handle opened on something?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f6ff8d209700b0f72a5230b6fb85c97fcff80b" translate="yes" xml:space="preserve">
          <source>Is there a pretty-printer (formatter) for Perl?</source>
          <target state="translated">有没有针对Perl的pretty-printer(formatter)?</target>
        </trans-unit>
        <trans-unit id="4de697ef2e229f75e5104bfc892c512110a431a3" translate="yes" xml:space="preserve">
          <source>Is there a way to automatically decode or encode?</source>
          <target state="translated">有没有一种方法可以自动解码或编码?</target>
        </trans-unit>
        <trans-unit id="39ca1c79bbe21712b9201250f2255ac5dedb029e" translate="yes" xml:space="preserve">
          <source>Is there a way to hide perl's command line from programs such as &quot;ps&quot;?</source>
          <target state="translated">有没有办法隐藏perl的命令行,不让 &quot;ps &quot;等程序看到?</target>
        </trans-unit>
        <trans-unit id="3501dfd2cd1d66a0e5956cd00d200fac2bcfba23" translate="yes" xml:space="preserve">
          <source>Is there an IDE or Windows Perl Editor?</source>
          <target state="translated">是否有IDE或Windows Perl编辑器?</target>
        </trans-unit>
        <trans-unit id="d38604e1470c164361620c8174e47b26e8405b57" translate="yes" xml:space="preserve">
          <source>Is there another way to do it?</source>
          <target state="translated">还有其他方法吗?</target>
        </trans-unit>
        <trans-unit id="14fcbaecb1fe49a8bbbcabb376a8c49b63c6d0ee" translate="yes" xml:space="preserve">
          <source>Is there anything else I need to know?</source>
          <target state="translated">还有什么我需要知道的吗?</target>
        </trans-unit>
        <trans-unit id="3079a95c08daf3fbe9a6f4a2b3424c5019e5caa9" translate="yes" xml:space="preserve">
          <source>Is there enough documentation?</source>
          <target state="translated">是否有足够的文件?</target>
        </trans-unit>
        <trans-unit id="a850886339587a195217b1d8cceb0d4cff588e20" translate="yes" xml:space="preserve">
          <source>Is this something that only the submitter wants added to the language, or is it broadly useful? Sometimes, instead of adding a feature with a tight focus, the porters might decide to wait until someone implements the more generalized feature.</source>
          <target state="translated">这是只有提交者希望添加到语言中的东西,还是广泛有用的东西?有时,移植者可能会决定等到有人实现了更广泛的功能之后,再添加一个重点突出的功能。</target>
        </trans-unit>
        <trans-unit id="c6c3f322bd4a89ec99cd36027dacc62c0c50b0bf" translate="yes" xml:space="preserve">
          <source>Is this the document you were after?</source>
          <target state="translated">这是你要找的文件吗?</target>
        </trans-unit>
        <trans-unit id="c801f4251dba57aee2f236238406c19df06e8971" translate="yes" xml:space="preserve">
          <source>Is this you? Is writing tests right up there with writing documentation and having your fingernails pulled out? Did you open up a test and read</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243aed46fb67b26a47f5f82cb478ce344d097065" translate="yes" xml:space="preserve">
          <source>Is your program EMX-compiled with &lt;code&gt;-Zmt -Zcrtdll&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af501c530066fe2526868f8de57f9ed976517fd9" translate="yes" xml:space="preserve">
          <source>IsContainerPartition</source>
          <target state="translated">IsContainerPartition</target>
        </trans-unit>
        <trans-unit id="c6193261c02de21aac043fe2d15ff95fc2e34dca" translate="yes" xml:space="preserve">
          <source>IsRecognizedPartition</source>
          <target state="translated">IsRecognizedPartition</target>
        </trans-unit>
        <trans-unit id="d95874ba2baf2aa8c816605d15eea330b17427d2" translate="yes" xml:space="preserve">
          <source>IsSTD</source>
          <target state="translated">IsSTD</target>
        </trans-unit>
        <trans-unit id="9f55afe53a666115430d24161c215ea18ed5b9a0" translate="yes" xml:space="preserve">
          <source>Isn't Archive::Tar heavier on memory than /bin/tar?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a285d7f91e6104f157a9d3d5748d7dac064dcf" translate="yes" xml:space="preserve">
          <source>Isn't Archive::Tar slow?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c197dfd67f1ed79d11a8b0218cc368bfcce6ccb" translate="yes" xml:space="preserve">
          <source>Israel</source>
          <target state="translated">Israel</target>
        </trans-unit>
        <trans-unit id="71a13751965545486650d22819d11cd32442498c" translate="yes" xml:space="preserve">
          <source>Issue a command as follows;</source>
          <target state="translated">发出命令如下:</target>
        </trans-unit>
        <trans-unit id="634b2e574e8681fa4bd024f62981fab9bb1e46c1" translate="yes" xml:space="preserve">
          <source>Issue a diagnostics message to STDERR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03592f61d67d4b9df2c210af49940f16e407a6d4" translate="yes" xml:space="preserve">
          <source>Issue a diagnostics message to STDOUT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e65cf3242e05b4d2c344ded5e0824a537ad64ec2" translate="yes" xml:space="preserve">
          <source>Issues a &lt;code&gt;ualarm&lt;/code&gt; call; the &lt;code&gt;$interval_useconds&lt;/code&gt; is optional and will be zero if unspecified, resulting in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;-like behaviour.</source>
          <target state="translated">发出 &lt;code&gt;ualarm&lt;/code&gt; 呼叫；在 &lt;code&gt;$interval_useconds&lt;/code&gt; 是可选的，将是零，如果未指定，导致 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 般的行为。</target>
        </trans-unit>
        <trans-unit id="451bb20dde9f17b91d4ea56d923babf92e6ab559" translate="yes" xml:space="preserve">
          <source>Issues a &lt;code&gt;ualarm&lt;/code&gt; call; the &lt;code&gt;$interval_useconds&lt;/code&gt; is optional and will be zero if unspecified, resulting in &lt;code&gt;alarm&lt;/code&gt;-like behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f58a9877a43ede1a54c6d1cffca7950a04cb0e9" translate="yes" xml:space="preserve">
          <source>Issues the warning:</source>
          <target state="translated">发出警告。</target>
        </trans-unit>
        <trans-unit id="d7acc4a63bfa4b603392fb8adfd2d4ca89c11f46" translate="yes" xml:space="preserve">
          <source>It</source>
          <target state="translated">It</target>
        </trans-unit>
        <trans-unit id="38eb0bc8056860c92fb5c583bff73f1456dae838" translate="yes" xml:space="preserve">
          <source>It allows you to fetch any file pointed to by a &lt;code&gt;ftp&lt;/code&gt; , &lt;code&gt;http&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;rsync&lt;/code&gt; uri by a number of different means.</source>
          <target state="translated">它允许您通过多种不同方式来获取 &lt;code&gt;ftp&lt;/code&gt; ， &lt;code&gt;http&lt;/code&gt; ， &lt;code&gt;file&lt;/code&gt; ， &lt;code&gt;git&lt;/code&gt; 或 &lt;code&gt;rsync&lt;/code&gt; uri 指向的任何文件。</target>
        </trans-unit>
        <trans-unit id="5f7f3deaf6b10a7e4949b31b699d2af4c0c5c2a4" translate="yes" xml:space="preserve">
          <source>It allows you to fetch any file pointed to by a &lt;code&gt;ftp&lt;/code&gt;, &lt;code&gt;http&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;rsync&lt;/code&gt; uri by a number of different means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b28d021dc9b9966369f90f11dc74db9e607087c" translate="yes" xml:space="preserve">
          <source>It allows you to validate input via a template. The only requirement is that the arguments must be named.</source>
          <target state="translated">它允许你通过一个模板来验证输入。唯一的要求是参数必须命名。</target>
        </trans-unit>
        <trans-unit id="b9dcbab629dab7b7bb8a9a5c305c5b7edec8fe86" translate="yes" xml:space="preserve">
          <source>It also causes &lt;code&gt;decode&lt;/code&gt; to parse such tagged JSON values and deserialise them via a call to the &lt;code&gt;THAW&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e1f97bb7137990bbbfbdc73b45154ab6a87edc2" translate="yes" xml:space="preserve">
          <source>It also flags things that need to behave specially in an lvalue context, such as &lt;code&gt;$$x = 5&lt;/code&gt; which might have to vivify a reference in &lt;code&gt;$x&lt;/code&gt; .</source>
          <target state="translated">它还标记需要在左值上下文中特殊行为的事物，例如 &lt;code&gt;$$x = 5&lt;/code&gt; ，这可能必须使 &lt;code&gt;$x&lt;/code&gt; 的引用生效。</target>
        </trans-unit>
        <trans-unit id="f46a706382c3e7f690244335b6067ef888c4bc96" translate="yes" xml:space="preserve">
          <source>It also flags things that need to behave specially in an lvalue context, such as &lt;code&gt;$$x = 5&lt;/code&gt; which might have to vivify a reference in &lt;code&gt;$x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908ce366021e2b55b694a1cc88f5df405de36e15" translate="yes" xml:space="preserve">
          <source>It also has embedded documentation, so you can use</source>
          <target state="translated">它还嵌入了文档,所以你可以使用</target>
        </trans-unit>
        <trans-unit id="2ac24af0ec1c7cfa5374898a3526976fbf4e475c" translate="yes" xml:space="preserve">
          <source>It also made it impossible to pass a perl filehandle that wasn't associated with a real filesystem file, like, say, an &lt;code&gt;IO::String&lt;/code&gt; .</source>
          <target state="translated">这也使得无法传递与真实文件系统文件无关的perl文件句柄，例如 &lt;code&gt;IO::String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="affbbcabd9e89330cd688705cb152f75ac31dcc5" translate="yes" xml:space="preserve">
          <source>It also made it impossible to pass a perl filehandle that wasn't associated with a real filesystem file, like, say, an &lt;code&gt;IO::String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50072e7f3665a297dafc9a98026d2ece625b9337" translate="yes" xml:space="preserve">
          <source>It also provides a convenient alias via the MM class (I didn't want MakeMaker modules outside of ExtUtils/).</source>
          <target state="translated">它还通过MM类提供了一个方便的别名(我不希望MakeMaker模块在ExtUtils/之外)。</target>
        </trans-unit>
        <trans-unit id="915bbb1cff409394c98921945b825ccfd726cf97" translate="yes" xml:space="preserve">
          <source>It also provides a convenient alias via the MY class.</source>
          <target state="translated">它还通过MY类提供了一个方便的别名。</target>
        </trans-unit>
        <trans-unit id="f7728ec4984f8aa9520af281a21430a4fa58511c" translate="yes" xml:space="preserve">
          <source>It also sets the effective names (&lt;code&gt;HvENAME&lt;/code&gt; ) on all the stashes as appropriate.</source>
          <target state="translated">它还会在所有存储中适当地设置有效名称（ &lt;code&gt;HvENAME&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fdd0b99c263719f6c7ac54250b06d02a9d280c92" translate="yes" xml:space="preserve">
          <source>It also sets the effective names (&lt;code&gt;HvENAME&lt;/code&gt;) on all the stashes as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b119a076af514e51ac37bcaf3aa61a59bc6514" translate="yes" xml:space="preserve">
          <source>It also supports tying via a win32 handle (for example, from &lt;code&gt;createFile()&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cefa68e3cb791475c8c4a04f377e9985e23ade2" translate="yes" xml:space="preserve">
          <source>It also turns out that EBCDIC has nearly precise equivalents for the ASCII/Latin1 C0 controls and the DELETE control. (The C0 controls are those whose ASCII code points are 0..0x1F; things like TAB, ACK, BEL, etc.) A mapping is set up between these ASCII/EBCDIC controls. There isn't such a precise mapping between the C1 controls on ASCII platforms and the remaining EBCDIC controls. What has been done is to map these controls, mostly arbitrarily, to some otherwise unmatched character in the other character set. Most of these are very very rarely used nowadays in EBCDIC anyway, and their names have been dropped, without much complaint. For example the EO (Eight Ones) EBCDIC control (consisting of eight one bits = 0xFF) is mapped to the C1 APC control (0x9F), and you can't use the name &quot;EO&quot;.</source>
          <target state="translated">事实证明,EBCDIC对于ASCII/Latin1的C0控件和DELETE控件有几乎精确的等价物,(C0控件是那些ASCII码点为0...0x1F的控件,如TAB、ACK、BEL等)。(C0控件是那些ASCII码点为0...0x1F的控件,比如TAB、ACK、BEL等)这些ASCII/EBCDIC控件之间建立了一个映射。在ASCII平台上的C1控件和其余EBCDIC控件之间并没有如此精确的映射。所做的是将这些控件,大部分是任意地映射到其他字符集中一些其他不匹配的字符上。反正这些控件现在在EBCDIC中已经很少使用了,它们的名字也被删掉了,没有多少人抱怨。比如EO(八个一)EBCDIC控件(由八个一位=0xFF组成)被映射到C1 APC控件(0x9F)上,就不能用 &quot;EO &quot;这个名字了。</target>
        </trans-unit>
        <trans-unit id="6e72af9b0783d77ee6316a243e984feea8033ad2" translate="yes" xml:space="preserve">
          <source>It assumes that pat has the same utf8-ness as sv. It's the caller's responsibility to ensure that this is so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff9e21d973b85a09332d5d3faae1a519ffea9ab5" translate="yes" xml:space="preserve">
          <source>It attempts to meet all &quot;MUST&quot; requirements of the specification, but does not implement all &quot;SHOULD&quot; requirements. (Note: it was developed against the earlier RFC 2616 specification and may not yet meet the revised RFC 7230-7235 spec.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd158a359289156ad701983e580703419c574eb4" translate="yes" xml:space="preserve">
          <source>It becomes more important for perl to know about all the possible locale categories on the platform, even if they aren't apparently used in your program. Perl knows all of the Linux ones. If your platform has others, you can submit an issue at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; for inclusion of it in the next release. In the meantime, it is possible to edit the Perl source to teach it about the category, and then recompile. Search for instances of, say, &lt;code&gt;LC_PAPER&lt;/code&gt; in the source, and use that as a template to add the omitted one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6076aff0ee21a62fd6a390261efc5e5f0afb16" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;croak&lt;/code&gt; on failure.</source>
          <target state="translated">它在失败时发出 &lt;code&gt;croak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04dc7e22ec9e3426f178763cb4c63c8305c033ad" translate="yes" xml:space="preserve">
          <source>It calls several other routines, such as &lt;code&gt;fbm_instr()&lt;/code&gt; which does Fast Boyer Moore matching and &lt;code&gt;find_byclass()&lt;/code&gt; which is responsible for finding the start using the first mandatory regop in the program.</source>
          <target state="translated">它调用其他几个例程，如 &lt;code&gt;fbm_instr()&lt;/code&gt; 这确实快博耶&amp;middot;摩尔匹配和 &lt;code&gt;find_byclass()&lt;/code&gt; 负责使用查找程序中的第一个强制性regop开始。</target>
        </trans-unit>
        <trans-unit id="497f49c37ce971a4a73fa1723da212a9045a166f" translate="yes" xml:space="preserve">
          <source>It can also be extended to be an application from &lt;b&gt;C&lt;/b&gt; to &lt;b&gt;C&lt;/b&gt;, whilst its restriction to &lt;b&gt;R&lt;/b&gt; behaves as defined above by using the following definition:</source>
          <target state="translated">也可以将其扩展为从&lt;b&gt;C&lt;/b&gt;到&lt;b&gt;C&lt;/b&gt;的应用程序，同时其对&lt;b&gt;R的&lt;/b&gt;限制的行为如上所定义，使用以下定义：</target>
        </trans-unit>
        <trans-unit id="037c189042a08e857fa9c25c861179516385e907" translate="yes" xml:space="preserve">
          <source>It can also be that long doubles and doubles are the same thing:</source>
          <target state="translated">也可以是长双打和双打是一回事。</target>
        </trans-unit>
        <trans-unit id="5a15f67a53851e31c8be84ee1922d871c9c74ea2" translate="yes" xml:space="preserve">
          <source>It can also store the resource directly in a file:</source>
          <target state="translated">它也可以直接将资源存储在文件中。</target>
        </trans-unit>
        <trans-unit id="2eb713583608cebc3ea2998759255bff9599a6ef" translate="yes" xml:space="preserve">
          <source>It can be called on an object or a class, of course.</source>
          <target state="translated">当然,它可以在一个对象或一个类上调用。</target>
        </trans-unit>
        <trans-unit id="e5c905f1665a696bdc789794d07c2a84423a378d" translate="yes" xml:space="preserve">
          <source>It can be used in the regular procedural way by calling &lt;code&gt;store&lt;/code&gt; with a reference to the object to be stored, along with the file name where the image should be written.</source>
          <target state="translated">通过调用 &lt;code&gt;store&lt;/code&gt; 并引用要存储的对象以及应在其中写入图像的文件名，可以按常规过程使用它。</target>
        </trans-unit>
        <trans-unit id="1b6d3eb9169140a9a6274f80ff5e86670958b748" translate="yes" xml:space="preserve">
          <source>It can easily be defined like this:</source>
          <target state="translated">它可以很容易地被这样定义。</target>
        </trans-unit>
        <trans-unit id="86ba6d37f32935701376ea8939425dea235ee2d1" translate="yes" xml:space="preserve">
          <source>It can load perl dynamic extensions, and it can fork().</source>
          <target state="translated">它可以加载perl动态扩展,也可以fork()。</target>
        </trans-unit>
        <trans-unit id="5a3c2d30ca072f4084789964fe3766438b6284d3" translate="yes" xml:space="preserve">
          <source>It can lose track of whether something should be encoded as UTF-8 or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f9135ce7da4c20ac152391823b647cbbeb33a6" translate="yes" xml:space="preserve">
          <source>It can take one of the following forms:</source>
          <target state="translated">它可以采取以下形式之一:</target>
        </trans-unit>
        <trans-unit id="2f904ea9d1b7cc3495a54fb96cf0850f9e5fd878" translate="yes" xml:space="preserve">
          <source>It can, however, be used as a superclass for other classes. To facilitate this, the generated constructor method uses a two-argument blessing. Furthermore, if the class is hash-based, the key of each element is prefixed with the class name (see</source>
          <target state="translated">但是,它可以作为其他类的超类使用。为了方便这一点,生成的构造函数方法使用了两个参数的祝福。此外,如果这个类是基于哈希的,那么每个元素的键都会在类名前加上前缀(见</target>
        </trans-unit>
        <trans-unit id="09d8ef54917c31dc7c7e7dced0a11cfba194a124" translate="yes" xml:space="preserve">
          <source>It combines the features of the</source>
          <target state="translated">它结合了以下特点</target>
        </trans-unit>
        <trans-unit id="6de2e6681db9e2aba6bd7eace100b8a569aebcfe" translate="yes" xml:space="preserve">
          <source>It constructs and returns a $treewalker coderef, which when invoked, traverses, or walks, and renders the optrees of the given arguments to STDOUT. You can reuse this, and can change the rendering style used each time; thereafter the coderef renders in the new style.</source>
          <target state="translated">它构造并返回一个$treewalker coderef,当调用时,它将遍历或行走,并将给定参数的optrees渲染到STDOUT。你可以重复使用这个函数,并且可以改变每次使用的渲染样式;此后coderef将以新的样式进行渲染。</target>
        </trans-unit>
        <trans-unit id="8ee601f689d3bf17ef24ff756daa44f51b167191" translate="yes" xml:space="preserve">
          <source>It creates a database of the profile information that you can turn into reports. The &lt;code&gt;nytprofhtml&lt;/code&gt; command turns the data into an HTML report similar to the &lt;a href=&quot;Devel::Cover&quot;&gt;Devel::Cover&lt;/a&gt; report:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b00062db32c6f6da9356b09e0e38ccf6b4650d6" translate="yes" xml:space="preserve">
          <source>It creates a database of the profile information that you can turn into reports. The &lt;code&gt;nytprofhtml&lt;/code&gt; command turns the data into an HTML report similar to the &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::Cover&quot;&gt;Devel::Cover&lt;/a&gt; report:</source>
          <target state="translated">它创建一个配置文件信息数据库，您可以将其转换为报告。该 &lt;code&gt;nytprofhtml&lt;/code&gt; 命令将数据放入类似HTML报告&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::Cover&quot;&gt;杰韦利::封面&lt;/a&gt;报道：</target>
        </trans-unit>
        <trans-unit id="ea6e392f63285a19a0d452d50c54df585744488e" translate="yes" xml:space="preserve">
          <source>It currently does</source>
          <target state="translated">目前是</target>
        </trans-unit>
        <trans-unit id="e547a28181c8513c90dab654ebd4bf8ae08d6f97" translate="yes" xml:space="preserve">
          <source>It delivers the correct results for the &lt;code&gt;RADIXCHAR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt; items, without you having to write extra code. The reason for the extra code would be because these are from the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale category, which is normally kept set by Perl so that the radix is a dot, and the separator is the empty string, no matter what the underlying locale is supposed to be, and so to get the expected results, you have to temporarily toggle into the underlying locale, and later toggle back. (You could use plain &lt;code&gt;nl_langinfo&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&lt;/a&gt;&lt;/code&gt; for this but then you wouldn't get the other advantages of &lt;code&gt;Perl_langinfo()&lt;/code&gt;; not keeping &lt;code&gt;LC_NUMERIC&lt;/code&gt; in the C (or equivalent) locale would break a lot of CPAN, which is expecting the radix (decimal point) character to be a dot.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dad9241afc4fe54f1d9bdea5f00177fb19d962a" translate="yes" xml:space="preserve">
          <source>It depends just what you mean by &quot;escape&quot;. URL escapes are dealt with in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;. Shell escapes with the backslash (&lt;code&gt;\&lt;/code&gt; ) character are removed with</source>
          <target state="translated">这取决于您所说的&amp;ldquo;转义&amp;rdquo;。URL转义在&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;中处理。带有反斜杠（ &lt;code&gt;\&lt;/code&gt; ）字符的外壳转义符用</target>
        </trans-unit>
        <trans-unit id="cdac17a54a39be9556592ce5c191473c9ecfd72c" translate="yes" xml:space="preserve">
          <source>It depends just what you mean by &quot;escape&quot;. URL escapes are dealt with in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;. Shell escapes with the backslash (&lt;code&gt;\&lt;/code&gt;) character are removed with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c581007e3ef08adcb3306414f7f2463e871ac22e" translate="yes" xml:space="preserve">
          <source>It does have the drawback of putting the wrong thing in $-[0] and $+[0], but this usually can be worked around.</source>
          <target state="translated">它的缺点是把错误的东西放在$-[0]和$+[0]中,但这通常可以解决。</target>
        </trans-unit>
        <trans-unit id="79d1a39f53aab3a73596d5fd9d9372e7a56d671b" translate="yes" xml:space="preserve">
          <source>It does implement the full UTS#18 grouping, intersection, union, and removal (subtraction) syntax.</source>
          <target state="translated">它确实实现了完整的UTS#18分组、交集、联合和删除(减法)语法。</target>
        </trans-unit>
        <trans-unit id="3283ccec35b62f9d69fc01d0b0127572cdbbfb86" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">它确实像 &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; 。请注意， &lt;code&gt;$unprocessed&lt;/code&gt; 将被修改为副作用。</target>
        </trans-unit>
        <trans-unit id="25a28128ab3b4005d07e5b53db8c8141489e82c0" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781b506fec7893fd5e327ee69d14b0d379ec072d" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">它确实像 &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; 。请注意， &lt;code&gt;$unprocessed&lt;/code&gt; 将被修改为副作用。</target>
        </trans-unit>
        <trans-unit id="053e3e1bd8bbb865867e84abe6ea50be636b0060" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98073979e598afdba9b1edfe5653068ff476e437" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">它确实像 &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; 。请注意， &lt;code&gt;$unprocessed&lt;/code&gt; 将被修改为副作用。</target>
        </trans-unit>
        <trans-unit id="4bd843b35cf6f524d8898789fded24bf5b532aee" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a16bde88f189f6ad288e03cf560598f2698ec6" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">它确实像 &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; 。请注意， &lt;code&gt;$unprocessed&lt;/code&gt; 将被修改为副作用。</target>
        </trans-unit>
        <trans-unit id="5cfa9126aa95883d132daa2d80bb8c833bb459ad" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23674d2d232acdb766b500c08327a83816f04c97" translate="yes" xml:space="preserve">
          <source>It does not protect &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; , so that variables can still be substituted.</source>
          <target state="translated">它不保护 &lt;code&gt;$&lt;/code&gt; 或 &lt;code&gt;@&lt;/code&gt; ，因此仍可以替换变量。</target>
        </trans-unit>
        <trans-unit id="6c7a5ea655e7023099d39c28a9e780a041767575" translate="yes" xml:space="preserve">
          <source>It does not protect &lt;code&gt;'$'&lt;/code&gt; or &lt;code&gt;'@'&lt;/code&gt;, so that variables can still be substituted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b096762458cc1c67705fc722b1b5c19a799e9a" translate="yes" xml:space="preserve">
          <source>It doesn't handle all C constructs, but it does attempt to isolate definitions inside evals so that you can get at the definitions that it can translate.</source>
          <target state="translated">它并不能处理所有的C结构,但它确实试图在evals中隔离定义,这样你就可以得到它能翻译的定义。</target>
        </trans-unit>
        <trans-unit id="661f04839377963b6531cde75241eb25f024872a" translate="yes" xml:space="preserve">
          <source>It doesn't matter whether those elements are already there or not: it'll gladly create them for you, setting intervening elements to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as need be.</source>
          <target state="translated">这些元素是否已经存在都没有关系：它将很高兴为您创建它们，并根据需要将中间元素设置为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fae5276d8d54bb235b88eecab0650a76f813b6ff" translate="yes" xml:space="preserve">
          <source>It doesn't matter whether those elements are already there or not: it'll gladly create them for you, setting intervening elements to &lt;code&gt;undef&lt;/code&gt; as need be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d56e0602580738fb050f4b637c11809b2b2552" translate="yes" xml:space="preserve">
          <source>It ensures that all items returned from the subroutine will be accessible when control returns from the</source>
          <target state="translated">它确保了当控制权从</target>
        </trans-unit>
        <trans-unit id="257a0d1f1aa9bffe5b6fec0d0193d78bda64cf97" translate="yes" xml:space="preserve">
          <source>It ensures that nothing is actually returned from the subroutine.</source>
          <target state="translated">它确保了没有任何东西从子程序中实际返回。</target>
        </trans-unit>
        <trans-unit id="9073e4e615d570b658e9c1dc5b31fb9fbc2e51c4" translate="yes" xml:space="preserve">
          <source>It ensures that only a scalar is actually returned from the subroutine. The subroutine can, of course, ignore the</source>
          <target state="translated">它确保子程序实际只返回一个标量。当然,子程序可以忽略</target>
        </trans-unit>
        <trans-unit id="c5a8cac5521955b5cf81a85b7f0157a0da48a8fd" translate="yes" xml:space="preserve">
          <source>It evaluates to TRUE if, besides those 4 words, any of the sequences &quot;feed&quot;, &quot;field&quot;, &quot;Defoe&quot;, &quot;fume&quot;, and many others are in &lt;code&gt;$foo&lt;/code&gt;. By judicious use of &lt;code&gt;\b&lt;/code&gt; (or better (because it is designed to handle natural language) &lt;code&gt;\b{wb}&lt;/code&gt;), we can make sure that only the Giant's words are matched:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce1e8c1dec22e7fcef7a08df4a73a6d708c188c" translate="yes" xml:space="preserve">
          <source>It exports the following variables:</source>
          <target state="translated">它输出的变量如下:</target>
        </trans-unit>
        <trans-unit id="c5eede2c3ff2d6a126d9a37fe7b6a2f7c7fef7c9" translate="yes" xml:space="preserve">
          <source>It goes without saying that bundling can be quite confusing.</source>
          <target state="translated">毋庸置疑,捆绑是相当混乱的。</target>
        </trans-unit>
        <trans-unit id="3dd9057379828dbfc73545c27db82f9785af3f5b" translate="yes" xml:space="preserve">
          <source>It has not been extensively tested yet and buffered I/O is not yet implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f1fa29899dc9be4d2a29da0c1ebb962d996294" translate="yes" xml:space="preserve">
          <source>It implements just a very simple class to manage an array. Apart from the constructor, &lt;code&gt;new&lt;/code&gt; , it declares methods, one static and one virtual. The static method, &lt;code&gt;PrintID&lt;/code&gt; , prints out simply the class name and a version number. The virtual method, &lt;code&gt;Display&lt;/code&gt; , prints out a single element of the array. Here is an all-Perl example of using it.</source>
          <target state="translated">它仅实现了一个非常简单的类来管理数组。除了构造函数 &lt;code&gt;new&lt;/code&gt; 之外，它还声明方法，一种是静态的，另一种是虚拟的。静态方法 &lt;code&gt;PrintID&lt;/code&gt; 仅打印出类名和版本号。虚拟方法 &lt;code&gt;Display&lt;/code&gt; 可以打印出数组的单个元素。这是使用它的全Perl示例。</target>
        </trans-unit>
        <trans-unit id="194ff250d804880fa7aa6c2644ae6036e2023968" translate="yes" xml:space="preserve">
          <source>It implements just a very simple class to manage an array. Apart from the constructor, &lt;code&gt;new&lt;/code&gt;, it declares methods, one static and one virtual. The static method, &lt;code&gt;PrintID&lt;/code&gt;, prints out simply the class name and a version number. The virtual method, &lt;code&gt;Display&lt;/code&gt;, prints out a single element of the array. Here is an all-Perl example of using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4643eacc5a23fd6cfe7dbaa4ae9405cefd594ff8" translate="yes" xml:space="preserve">
          <source>It includes the TAP::Parser Cookbook:</source>
          <target state="translated">它包括TAP::Parser Cookbook。</target>
        </trans-unit>
        <trans-unit id="0b24215ad07cf4400cc22f004d70379859a91675" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a list context (if it executes</source>
          <target state="translated">它向被调用的子程序表明,它是在列表上下文中执行的(如果它执行了</target>
        </trans-unit>
        <trans-unit id="fd952552f08ee5c64a4b5cd1472fcbc55f52ff32" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a scalar context (if it executes</source>
          <target state="translated">它向被调用的子程序表明它是在标量上下文中执行的(如果它执行了</target>
        </trans-unit>
        <trans-unit id="d334572d38ec1bf7625437e6802d9ceede41a62a" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a void context (if it executes</source>
          <target state="translated">它向被调用的子程序表明,它是在void上下文中执行的(如果它执行了</target>
        </trans-unit>
        <trans-unit id="3dd5d5b49f19e1af8608ede7c4aa585a51f279cb" translate="yes" xml:space="preserve">
          <source>It is</source>
          <target state="translated">它是</target>
        </trans-unit>
        <trans-unit id="4593c265ea2a96fff8349127e24d6f8f64bc8930" translate="yes" xml:space="preserve">
          <source>It is a VIO application.</source>
          <target state="translated">它是一个VIO应用。</target>
        </trans-unit>
        <trans-unit id="15edb9eea808da9feee1a21d84ef34931e249422" translate="yes" xml:space="preserve">
          <source>It is a common feature of applications (whether run directly, or via the Web) for them to be &quot;localized&quot; -- i.e., for them to a present an English interface to an English-speaker, a German interface to a German-speaker, and so on for all languages it's programmed with. Locale::Maketext is a framework for software localization; it provides you with the tools for organizing and accessing the bits of text and text-processing code that you need for producing localized applications.</source>
          <target state="translated">应用程序(无论是直接运行,还是通过网络)的一个共同特点是 &quot;本地化&quot;--也就是说,它们向英语使用者提供一个英语界面,向德语使用者提供一个德语界面,以此类推,对所有语言进行编程。Locale::Maketext是一个软件本地化的框架;它为你提供了组织和访问文本位和文本处理代码的工具,你需要这些代码来制作本地化的应用程序。</target>
        </trans-unit>
        <trans-unit id="dd0c9650fee6ca5253a38ac00e6dc732d4f0e459" translate="yes" xml:space="preserve">
          <source>It is a common problem to want to detect what language(s) the user would prefer output in.</source>
          <target state="translated">想要检测用户希望用什么语言输出是一个常见的问题。</target>
        </trans-unit>
        <trans-unit id="84d9ffe2b782da4eace968e860a68bb94a1236cb" translate="yes" xml:space="preserve">
          <source>It is a fatal error if an operand contains a character whose ordinal value is above 0xFF, and hence not expressible except in UTF-8. The operation is performed on a non-UTF-8 copy for other operands encoded in UTF-8. See &lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;&quot;Byte and Character Semantics&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c07216f6ed146b3d5f5f41f5151571003ed974c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1950 data stream.</source>
          <target state="translated">当 &lt;code&gt;$output&lt;/code&gt; 不是RFC 1950数据流时，尝试使用此选项是一个致命错误。</target>
        </trans-unit>
        <trans-unit id="f26fad9b2ea8dad78ce0ae0159c499c446261e46" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1951 data stream.</source>
          <target state="translated">当 &lt;code&gt;$output&lt;/code&gt; 不是RFC 1951数据流时，尝试使用此选项是一个致命错误。</target>
        </trans-unit>
        <trans-unit id="f52e23ce1b9c7d458b13fea7c76a357d80aa0ef3" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1952 data stream.</source>
          <target state="translated">当 &lt;code&gt;$output&lt;/code&gt; 不是RFC 1952数据流时，尝试使用此选项是一个致命错误。</target>
        </trans-unit>
        <trans-unit id="951fc5c4a5b5cf258c0f54c435f4794f721e0f6c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to call this function except in list context.</source>
          <target state="translated">除了在列表上下文中调用这个函数是一个致命的错误。</target>
        </trans-unit>
        <trans-unit id="84e04c4e01865ff456f52f410d5f957caeadfc3c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to register a non-reference $obj. Any non-hashrefs among the following arguments are silently ignored.</source>
          <target state="translated">注册一个非引用的$obj是一个致命的错误。以下参数中的任何非散列值都将被忽略。</target>
        </trans-unit>
        <trans-unit id="62c55db6ed1bb1f62b509a530f9b2d3c904a4f20" translate="yes" xml:space="preserve">
          <source>It is a hash of hashes that is keyed on perl version. Each keyed hash will have the following keys:</source>
          <target state="translated">它是一个在perl版本上进行键控的哈希。每个键的哈希都有以下键。</target>
        </trans-unit>
        <trans-unit id="25ddadae24c0653c00410eac3e43d9a6483af1b0" translate="yes" xml:space="preserve">
          <source>It is a little bit easier to do so while</source>
          <target state="translated">这样做的时候会比较容易一些。</target>
        </trans-unit>
        <trans-unit id="41ddae9f4920a415092a3be5fefb0262a7109fa2" translate="yes" xml:space="preserve">
          <source>It is a simple matter to expand out an inversion list to a full list of all code points that have the property-value:</source>
          <target state="translated">很简单,将一个反转列表扩展出一个具有属性值的所有代码点的完整列表。</target>
        </trans-unit>
        <trans-unit id="fa408a04e809363f2b269a35a2338df430b18e1f" translate="yes" xml:space="preserve">
          <source>It is a syntax error to use &lt;code&gt;\N{NAME}&lt;/code&gt; where &lt;code&gt;NAME&lt;/code&gt; is unknown.</source>
          <target state="translated">它是一个语法错误，以使用 &lt;code&gt;\N{NAME}&lt;/code&gt; 其中 &lt;code&gt;NAME&lt;/code&gt; 是未知的。</target>
        </trans-unit>
        <trans-unit id="3189cdee5a11207a5d4b78afa8dc9c2b8ecc076f" translate="yes" xml:space="preserve">
          <source>It is able to load multiple modules at once or none at all if one of them was not able to load. It also takes care of any error checking and so forth.</source>
          <target state="translated">它能够同时加载多个模块,如果其中一个模块无法加载,则完全不加载。它还负责任何错误检查等。</target>
        </trans-unit>
        <trans-unit id="5224d6c644e7d334b02295922c6a21bf88351e6e" translate="yes" xml:space="preserve">
          <source>It is advised that formatnames match the regexp &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/a&gt;&lt;/code&gt;. Everything following whitespace after the formatname is a parameter that may be used by the formatter when dealing with this region. This parameter must not be repeated in the &quot;=end&quot; paragraph. Implementors should anticipate future expansion in the semantics and syntax of the first parameter to &quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</source>
          <target state="translated">建议格式名称与regexp &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/a&gt;&lt;/code&gt; 相匹配。格式名后面的空格后面的所有内容都是格式化程序在处理此区域时可以使用的参数。在&amp;ldquo; = end&amp;rdquo;段落中不得重复此参数。实现者应预料将来第一个参数的语义和语法将扩展到&amp;ldquo; = begin&amp;rdquo; /&amp;ldquo; = end&amp;rdquo; /&amp;ldquo; = for&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e650500b6f0231025bf8e8986cda639228e156b4" translate="yes" xml:space="preserve">
          <source>It is advised that formatnames match the regexp &lt;code&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/code&gt;. Everything following whitespace after the formatname is a parameter that may be used by the formatter when dealing with this region. This parameter must not be repeated in the &quot;=end&quot; paragraph. Implementors should anticipate future expansion in the semantics and syntax of the first parameter to &quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bdc4a6dded231914c04e13e61b945f48f5268b4" translate="yes" xml:space="preserve">
          <source>It is also highly desirable that encoding classes inherit from &lt;code&gt;Encode::Encoding&lt;/code&gt; as a base class. This allows that class to define additional behaviour for all encoding objects.</source>
          <target state="translated">还非常需要编码类从 &lt;code&gt;Encode::Encoding&lt;/code&gt; 作为基类继承。这允许该类为所有编码对象定义其他行为。</target>
        </trans-unit>
        <trans-unit id="04e94392102301dd0cfd3e0e0b7cc900aa1df8a8" translate="yes" xml:space="preserve">
          <source>It is also hoped that the interface will cover the needs of OS/2, NT etc and also allow pseudo-dynamic linking (using &lt;code&gt;ld -A&lt;/code&gt; at runtime).</source>
          <target state="translated">还希望该接口将满足OS / 2，NT等的需求，并且还允许伪动态链接（在运行时使用 &lt;code&gt;ld -A&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c5a799ae9f844383ae213d6362def23a82f89603" translate="yes" xml:space="preserve">
          <source>It is also important to realize that these are default boundary definitions, and that implementations may wish to tailor the results for particular purposes and locales.</source>
          <target state="translated">同样重要的是要认识到,这些是默认的边界定义,实现者可能希望为特定的目的和地区定制结果。</target>
        </trans-unit>
        <trans-unit id="71ce07ae3818cf03055cfa783a2edee6c6d417e8" translate="yes" xml:space="preserve">
          <source>It is also important to realize that these are default boundary definitions, and that implementations may wish to tailor the results for particular purposes and locales. For example, some languages, such as Japanese and Thai, require dictionary lookup to accurately determine word boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04f0bafdb5580f449ee2f59e8c42ace66bb7312" translate="yes" xml:space="preserve">
          <source>It is also possible for the reverse to happen: &lt;code&gt;prop_aliases('isc')&lt;/code&gt; returns the list &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; ; whereas &lt;code&gt;prop_aliases('c')&lt;/code&gt; returns &lt;code&gt;(C, Other)&lt;/code&gt; (the latter being a Perl extension meaning &lt;code&gt;General_Category=Other&lt;/code&gt; . &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;Properties accessible through Unicode::UCD in perluniprops&lt;/a&gt; lists the available forms, including which ones are discouraged from use.</source>
          <target state="translated">相反的情况也有可能发生： &lt;code&gt;prop_aliases('isc')&lt;/code&gt; 返回列表 &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; ; 而 &lt;code&gt;prop_aliases('c')&lt;/code&gt; 返回 &lt;code&gt;(C, Other)&lt;/code&gt; （后者是Perl扩展，表示 &lt;code&gt;General_Category=Other&lt;/code&gt; 。）&lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;在perluniprops&lt;/a&gt;中可通过Unicode :: UCD访问的属性列出了可用的形式，包括不鼓励使用的形式。</target>
        </trans-unit>
        <trans-unit id="46b4ec4d35947f03a43a47b65cb8093dc3e99125" translate="yes" xml:space="preserve">
          <source>It is also possible for the reverse to happen: &lt;code&gt;prop_aliases('isc')&lt;/code&gt; returns the list &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt;; whereas &lt;code&gt;prop_aliases('c')&lt;/code&gt; returns &lt;code&gt;(C, Other)&lt;/code&gt; (the latter being a Perl extension meaning &lt;code&gt;General_Category=Other&lt;/code&gt;. &lt;a href=&quot;perluniprops#Properties-accessible-through-Unicode%3A%3AUCD&quot;&gt;&quot;Properties accessible through Unicode::UCD&quot; in perluniprops&lt;/a&gt; lists the available forms, including which ones are discouraged from use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8c00abb531749489f64809eab7af330894c553" translate="yes" xml:space="preserve">
          <source>It is also possible to generate Symbian executables for &quot;miniperl&quot; and &quot;perl&quot;, but since there is no standard command line interface for Symbian (nor full keyboards in the devices), these are useful mainly as demonstrations.</source>
          <target state="translated">也可以为 &quot;miniperl &quot;和 &quot;perl &quot;生成Symbian可执行文件,但由于Symbian没有标准的命令行界面(设备中也没有完整的键盘),所以这些文件主要是作为演示用的。</target>
        </trans-unit>
        <trans-unit id="fba88eaeb368c964f0dd8f74cbc321efcbbc3751" translate="yes" xml:space="preserve">
          <source>It is also possible to have a complex number as either argument of the &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; : the appropriate component of the argument will be used.</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; ， &lt;code&gt;emake&lt;/code&gt; ， &lt;code&gt;cplx&lt;/code&gt; 和 &lt;code&gt;cplxe&lt;/code&gt; 的任何一个参数也可能具有复数：将使用该参数的适当组成部分。</target>
        </trans-unit>
        <trans-unit id="5f695912980907c9e4ce8ee64fb36b966f74913d" translate="yes" xml:space="preserve">
          <source>It is also possible to have a complex number as either argument of the &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;emake&lt;/code&gt;, &lt;code&gt;cplx&lt;/code&gt;, and &lt;code&gt;cplxe&lt;/code&gt;: the appropriate component of the argument will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1daabab3a866899ef9c74e4b9b632751383e7e2" translate="yes" xml:space="preserve">
          <source>It is also possible to instead list the characters you do not want to match. You can do so by using a caret (&lt;code&gt;^&lt;/code&gt;) as the first character in the character class. For instance, &lt;code&gt;[^a-z]&lt;/code&gt; matches any character that is not a lowercase ASCII letter, which therefore includes more than a million Unicode code points. The class is said to be &quot;negated&quot; or &quot;inverted&quot;.</source>
          <target state="translated">也可以列出您不想匹配的字符。您可以通过使用尖号（ &lt;code&gt;^&lt;/code&gt; ）作为字符类中的第一个字符来实现。例如， &lt;code&gt;[^a-z]&lt;/code&gt; 匹配不是小写ASCII字母的任何字符，因此包含超过一百万个Unicode代码点。该类被称为&amp;ldquo;取反&amp;rdquo;或&amp;ldquo;取反&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d1b81a5a48e226bc85d367f9c052e3692ba4d679" translate="yes" xml:space="preserve">
          <source>It is also possible to just require Math::BigFloat:</source>
          <target state="translated">也可以只要求Math::BigFloat。</target>
        </trans-unit>
        <trans-unit id="3fa6ca91de346d776bfa7cb7677e64152ae10a28" translate="yes" xml:space="preserve">
          <source>It is also possible to keep &lt;code&gt;origin&lt;/code&gt; as a git remote, and add a new remote for ssh access:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f73d924849030d9c9bafff98a0dd19b4f629df" translate="yes" xml:space="preserve">
          <source>It is also possible to omit the filename parameter as well, so the call:</source>
          <target state="translated">也可以省略文件名参数,所以调用。</target>
        </trans-unit>
        <trans-unit id="c92bd63c5290ef43a80924b5bd4775d90c01eb70" translate="yes" xml:space="preserve">
          <source>It is also possible to return values directly via the parameter list--whether it is actually desirable to do it is another matter entirely.</source>
          <target state="translated">也可以通过参数列表直接返回值--是否真的需要这样做是另一回事。</target>
        </trans-unit>
        <trans-unit id="50a5455e17306f508cbf1a77905bc1e3511b26df" translate="yes" xml:space="preserve">
          <source>It is also possible to specify the minimal and maximal number of arguments an option takes. &lt;code&gt;foo=s{2,4}&lt;/code&gt; indicates an option that takes at least two and at most 4 arguments. &lt;code&gt;foo=s{1,}&lt;/code&gt; indicates one or more values; &lt;code&gt;foo:s{,}&lt;/code&gt; indicates zero or more option values.</source>
          <target state="translated">也可以指定选项采用的最小和最大数量的参数。 &lt;code&gt;foo=s{2,4}&lt;/code&gt; 表示一个选项，该选项至少接受两个，最多四个参数。 &lt;code&gt;foo=s{1,}&lt;/code&gt; 表示一个或多个值； &lt;code&gt;foo:s{,}&lt;/code&gt; 表示零个或多个选项值。</target>
        </trans-unit>
        <trans-unit id="b77bfd84df66369a6b31eeda1a74a3114d66c160" translate="yes" xml:space="preserve">
          <source>It is also possible to test whether the pre-defined warnings categories are set in the calling module with the &lt;code&gt;warnings::enabled&lt;/code&gt; function. Consider this snippet of code:</source>
          <target state="translated">也可以使用 &lt;code&gt;warnings::enabled&lt;/code&gt; 功能测试在调用模块中是否设置了预定义的警告类别。考虑以下代码片段：</target>
        </trans-unit>
        <trans-unit id="3db1f66552fc819722dedb12482e309bce26efa4" translate="yes" xml:space="preserve">
          <source>It is also unique in that all other Perl operators impose a context (usually string or numeric context) on their operands, autoconverting those operands to those imposed contexts. In contrast, smartmatch</source>
          <target state="translated">它的独特之处在于,所有其他的Perl运算符都会在它们的操作数上施加一个上下文(通常是字符串或数字上下文),将这些操作数自动转换为这些施加的上下文。相比之下,smartmatch</target>
        </trans-unit>
        <trans-unit id="fac8d72d737b1435638a2eef2e2bc6f98342f178" translate="yes" xml:space="preserve">
          <source>It is also worth noting that &lt;code&gt;nextStream&lt;/code&gt; can be called at any time -- you don't have to wait until you have exhausted a compressed data stream before skipping to the next one.</source>
          <target state="translated">还值得注意的是，可以随时调用 &lt;code&gt;nextStream&lt;/code&gt; －您不必等到耗尽压缩数据流之后再跳到下一个。</target>
        </trans-unit>
        <trans-unit id="fe6480e97532361598fcacd4a646c8dd90b848cc" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name not defined by a &lt;code&gt;(?&amp;lt;&lt;i&gt;NAME&lt;/i&gt;&amp;gt;)&lt;/code&gt; earlier in the pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc49eaced7d721523b5bd759190363e32250fa1" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name not defined by a &lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt; earlier in the pattern.</source>
          <target state="translated">引用未由模式中的 &lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt; 定义的名称是错误的。</target>
        </trans-unit>
        <trans-unit id="13ee6665661c6d90800f41308ee104afc7c23af8" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name that is not declared somewhere in the pattern.</source>
          <target state="translated">引用一个没有在模式中声明的名称是错误的。</target>
        </trans-unit>
        <trans-unit id="65cfdd54d892c74c51301f814a65bd9d932d410a" translate="yes" xml:space="preserve">
          <source>It is an error to try to</source>
          <target state="translated">试图进行以下操作是错误的</target>
        </trans-unit>
        <trans-unit id="2f0a90fe17f957e846e3b518ba860308d4237cf1" translate="yes" xml:space="preserve">
          <source>It is assumed that if a module name is supplied, that that name matches the file name. Pods are not opened to check for the 'NAME' entry.</source>
          <target state="translated">如果提供了一个模块名,则假定该名称与文件名一致。Pods不会被打开来检查 &quot;NAME &quot;条目。</target>
        </trans-unit>
        <trans-unit id="c5af0c152794fef2b12ee8e78572d2cb96b0bb53" translate="yes" xml:space="preserve">
          <source>It is at this stage that &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; silently optimizes &lt;code&gt;/^/&lt;/code&gt; to mean &lt;code&gt;/^/m&lt;/code&gt; .</source>
          <target state="translated">正是在这个阶段， &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; 默默地将 &lt;code&gt;/^/&lt;/code&gt; 优化为 &lt;code&gt;/^/m&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f53779f0c0d37544de988c790844edfe4fdb773" translate="yes" xml:space="preserve">
          <source>It is at this stage that &lt;code&gt;split()&lt;/code&gt; silently optimizes &lt;code&gt;/^/&lt;/code&gt; to mean &lt;code&gt;/^/m&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c668d4a29eb47ae15a72aa4d1dd8cfb718abf5" translate="yes" xml:space="preserve">
          <source>It is at this step that &lt;code&gt;\1&lt;/code&gt; is begrudgingly converted to &lt;code&gt;$1&lt;/code&gt; in the replacement text of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, in order to correct the incorrigible</source>
          <target state="translated">正是在此步骤中，将 &lt;code&gt;\1&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 的替换文本中转换为 &lt;code&gt;$1&lt;/code&gt; ，以纠正不可修正的错误</target>
        </trans-unit>
        <trans-unit id="5668f9f099405dc43b82952ae4d9de3551af43ad" translate="yes" xml:space="preserve">
          <source>It is at this step that &lt;code&gt;\1&lt;/code&gt; is begrudgingly converted to &lt;code&gt;$1&lt;/code&gt; in the replacement text of &lt;code&gt;s///&lt;/code&gt;, in order to correct the incorrigible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4466ca0969a2662c5b072bf7cd93ebda9f966a8c" translate="yes" xml:space="preserve">
          <source>It is basically equivalent to:</source>
          <target state="translated">基本等同于。</target>
        </trans-unit>
        <trans-unit id="d3008b3fc272ebfbc9d46dd564fe851829fe13a2" translate="yes" xml:space="preserve">
          <source>It is better to restructure your code so the end pointer is passed down so that you know what it actually is at the point of this call, but if that isn't possible, &lt;a href=&quot;#UTF8_CHK_SKIP&quot;&gt;&quot;&lt;code&gt;UTF8_CHK_SKIP&lt;/code&gt;&quot;&lt;/a&gt; can minimize the chance of accessing beyond the end of the input buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77b015f95e7c8d0f9144f6b141dfe36a63eb292" translate="yes" xml:space="preserve">
          <source>It is clear that inline code is going to be faster than subroutine or method calls, because there is less overhead, but this approach has the disadvantage of being less maintainable and comes at the cost of greater memory usage - there is no such thing as a free lunch. If you are searching for an element in a list, it can be more efficient to store the data in a hash structure, and then simply look to see whether the key is defined, rather than to loop through the entire array using grep() for instance. substr() may be (a lot) faster than grep() but not as flexible, so you have another trade-off to access. Your code may contain a line which takes 0.01 of a second to execute which if you call it 1,000 times, quite likely in a program parsing even medium sized files for instance, you already have a 10 second delay, in just one single code location, and if you call that line 100,000 times, your entire program will slow down to an unbearable crawl.</source>
          <target state="translated">很明显,内联代码要比子程序或方法调用更快,因为开销更少,但这种方法的缺点是可维护性较差,而且要以更大的内存使用量为代价,天下没有免费的午餐。如果你要在一个列表中搜索一个元素,那么将数据存储在一个哈希结构中,然后简单地查看是否定义了键,而不是使用grep()等方法循环浏览整个数组,可能会更有效率。substr()可能比grep()快(很多),但没有那么灵活,所以你要进行另一种权衡来访问。你的代码可能包含了一行需要0.01秒的执行时间,如果你调用它1000次,很有可能在一个程序中,比如说解析中等大小的文件,你已经有了10秒的延迟,只是在一个单一的代码位置,如果你调用这一行100,000次,你的整个程序会慢到无法忍受的地步。</target>
        </trans-unit>
        <trans-unit id="f6122f662407715d120a73ec05bd2bbbf07e1b28" translate="yes" xml:space="preserve">
          <source>It is common to simply say &lt;code&gt;$filename = Pod::Simple::Search-&amp;gt; new
-&amp;gt;find(&quot;perlvar&quot;)&lt;/code&gt; so that just the @INC (well, and scriptdir) directories are searched. (This happens because the &lt;code&gt;inc&lt;/code&gt; attribute is true by default.)</source>
          <target state="translated">通常，简单地说 &lt;code&gt;$filename = Pod::Simple::Search-&amp;gt; new -&amp;gt;find(&quot;perlvar&quot;)&lt;/code&gt; 以便只搜索@INC目录（以及脚本目录）。（这是因为 &lt;code&gt;inc&lt;/code&gt; 属性默认为true。）</target>
        </trans-unit>
        <trans-unit id="94fd6736ac13c38aadc8d6ee40bf099cf30a2334" translate="yes" xml:space="preserve">
          <source>It is commonly thought that if a system does not have the capability to dynamically load a library, you cannot build XSUBs. This is incorrect. You</source>
          <target state="translated">人们通常认为,如果一个系统不具备动态加载库的能力,就不能构建XSUB。这是不正确的。您可以</target>
        </trans-unit>
        <trans-unit id="7b3776ce40b36ce2eb6604faa164797c0a666707" translate="yes" xml:space="preserve">
          <source>It is convenient to think that the indirection operator &lt;code&gt;*&lt;/code&gt; should be considered as a part of the type and the address operator &lt;code&gt;&amp;amp;&lt;/code&gt; should be considered part of the variable. See &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; for more info about handling qualifiers and unary operators in C types.</source>
          <target state="translated">方便地认为，应该将间接运算符 &lt;code&gt;*&lt;/code&gt; 视为类型的一部分，并将地址运算符 &lt;code&gt;&amp;amp;&lt;/code&gt; 视为变量的一部分。有关在C类型中处理限定符和一元运算符的更多信息，请参见&lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e49556be27809812b1f952c88dbd0fb8ac73080a" translate="yes" xml:space="preserve">
          <source>It is conventional to start layer names with a colon (for example, &lt;code&gt;:perlio&lt;/code&gt; ) to emphasize their similarity to variable &quot;attributes&quot;. But the code that parses layer specification strings, which is also used to decode the PERLIO environment variable, treats the colon as a separator.</source>
          <target state="translated">通常以冒号（例如 &lt;code&gt;:perlio&lt;/code&gt; ）开头图层名称，以强调其与变量&amp;ldquo;属性&amp;rdquo;的相似性。但是，用于解析层规范字符串的代码（也用于解码PERLIO环境变量）将冒号视为分隔符。</target>
        </trans-unit>
        <trans-unit id="0a6add6b8448b0bfc8e6cd8b6eca23cb56fc1aa2" translate="yes" xml:space="preserve">
          <source>It is conventional to start layer names with a colon (for example, &lt;code&gt;:perlio&lt;/code&gt;) to emphasize their similarity to variable &quot;attributes&quot;. But the code that parses layer specification strings, which is also used to decode the PERLIO environment variable, treats the colon as a separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddbcb8555d7ffc2811c34458dc5e23aebe16a93" translate="yes" xml:space="preserve">
          <source>It is eagerly hoped that in the future, increasing numbers of formats (and formatters) will support Unicode characters directly (as (X)HTML does with &lt;code&gt;&amp;amp;infin;&lt;/code&gt; , &lt;code&gt;&amp;amp;#8734;&lt;/code&gt;, or &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt;), reducing the need for idiosyncratic mappings of Unicode-to-</source>
          <target state="translated">热切希望将来，越来越多的格式（和格式化程序）将直接支持Unicode字符（如（X）HTML使用 &lt;code&gt;&amp;amp;infin;&lt;/code&gt; ， &lt;code&gt;&amp;amp;#8734;&lt;/code&gt; 或 &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt; ），从而减少了对特殊字符的需求Unicode到</target>
        </trans-unit>
        <trans-unit id="11bfea9ea83d9dc8ba6d1c8b2251fc92f5e63836" translate="yes" xml:space="preserve">
          <source>It is eagerly hoped that in the future, increasing numbers of formats (and formatters) will support Unicode characters directly (as (X)HTML does with &lt;code&gt;&amp;amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;amp;#8734;&lt;/code&gt;, or &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt;), reducing the need for idiosyncratic mappings of Unicode-to-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1feb840e61338fb8d69eab115197ceb6e4d8f195" translate="yes" xml:space="preserve">
          <source>It is easier to see with comments:</source>
          <target state="translated">有评论就更容易看到。</target>
        </trans-unit>
        <trans-unit id="deebd2bf2cb329548cf17163d065366c59ebd497" translate="yes" xml:space="preserve">
          <source>It is entirely possible for a subroutine to have both a prototype and a signature. They do different jobs: the prototype affects compilation of calls to the subroutine, and the signature puts argument values into lexical variables at runtime. You can therefore write</source>
          <target state="translated">一个子程序完全有可能同时拥有原型和签名。它们做着不同的工作:原型会影响对子程序的调用的编译,而签名会在运行时将参数值放入词法变量中。因此你可以写</target>
        </trans-unit>
        <trans-unit id="63ae6e7127f1e6349a2992ac6b857022220dd1af" translate="yes" xml:space="preserve">
          <source>It is even possible to give your own names to characters and character sequences by using the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; module. These custom names are lexically scoped, and so a given code point may have different names in different scopes. The name used is what is in effect at the time the &lt;code&gt;\N{}&lt;/code&gt; is expanded. For patterns in double-quotish context, that means at the time the pattern is parsed. But for patterns that are delimitted by single quotes, the expansion is deferred until pattern compilation time, which may very well have a different &lt;code&gt;charnames&lt;/code&gt; translator in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8705c44d271d802e23ff6717b34393b3365f69d" translate="yes" xml:space="preserve">
          <source>It is even possible to give your own names to characters and character sequences. For details, see &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">甚至可以给您自己的名字命名字符和字符序列。有关详细信息，请参见&lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c3622fe65f713ae38110b205b49d3188003c82c" translate="yes" xml:space="preserve">
          <source>It is expected that arguments to methods that are not explicitly supposed to be changed are constant (but this is not enforced).</source>
          <target state="translated">人们希望那些没有明确表示应该改变的方法的参数是不变的(但这并没有被强制执行)。</target>
        </trans-unit>
        <trans-unit id="776c3073c10966ce7532e508c1ba6620f8fcb74a" translate="yes" xml:space="preserve">
          <source>It is expected that what exactly &lt;code&gt;'strict'&lt;/code&gt; does will evolve over time as we gain experience with it. This means that programs that compile under it in today's Perl may not compile, or may have more or fewer warnings, in future Perls. There is no backwards compatibility promises with regards to it. Also there are already proposals for an alternate syntax for enabling it. For these reasons, using it will raise a &lt;code&gt;experimental::re_strict&lt;/code&gt; class warning, unless that category is turned off.</source>
          <target state="translated">可以预料，随着我们积累经验，确切的 &lt;code&gt;'strict'&lt;/code&gt; 行为会随着时间而发展。这意味着在今天的Perl中使用它进行编译的程序在将来的Perls中可能不会编译，或者可能有更多或更少的警告。没有向后兼容性的保证。也已经有人提出了启用它的替代语法的建议。由于这些原因，除非关闭了该类别，否则使用它会产生 &lt;code&gt;experimental::re_strict&lt;/code&gt; 类警告。</target>
        </trans-unit>
        <trans-unit id="743ffcd338b65d877bd2bc22191ffd5f5bc78800" translate="yes" xml:space="preserve">
          <source>It is exported upon request.</source>
          <target state="translated">它是根据要求出口的。</target>
        </trans-unit>
        <trans-unit id="fc922ccc86e1ddfa603184a6c1df119e90d551a2" translate="yes" xml:space="preserve">
          <source>It is generally a bad idea to mix non-UTF-8 locales and Unicode, and this issue is one of the reasons why. This warning is raised when Unicode rules would normally cause the result of this operation to contain a character that is in the range specified by the locale, 0..255, and hence is subject to the locale's rules, not Unicode's.</source>
          <target state="translated">一般来说,将非UTF-8的locale和Unicode混合使用是个坏主意,这个问题是其中一个原因。当Unicode规则通常会导致该操作的结果包含一个在locale指定的范围内的字符,0...255,因此受locale规则而不是Unicode规则的约束时,就会发出这个警告。</target>
        </trans-unit>
        <trans-unit id="4425fdf4018e2e8fba242ccf31d9fb769e12dacd" translate="yes" xml:space="preserve">
          <source>It is guaranteed that</source>
          <target state="translated">保证</target>
        </trans-unit>
        <trans-unit id="a6f4741397b5a8e1cbfacb47c2230423a05f8010" translate="yes" xml:space="preserve">
          <source>It is guaranteed that an</source>
          <target state="translated">它保证了</target>
        </trans-unit>
        <trans-unit id="13b4603391d295cad7c663188ece67a47ecf1dc6" translate="yes" xml:space="preserve">
          <source>It is hard to understand without digging what exactly matches ranges other than subsets of &lt;code&gt;[A-Z]&lt;/code&gt; , &lt;code&gt;[a-z]&lt;/code&gt; , and &lt;code&gt;[0-9]&lt;/code&gt; . A sound principle is to use only ranges that begin from and end at either alphabetics of equal case ([a-e], [A-E]), or digits ([0-9]). Anything else is unsafe or unclear. If in doubt, spell out the range in full.</source>
          <target state="translated">如果不挖掘 &lt;code&gt;[A-Z]&lt;/code&gt; ， &lt;code&gt;[a-z]&lt;/code&gt; 和 &lt;code&gt;[0-9]&lt;/code&gt; 的子集以外的范围，则很难理解。合理的原则是仅使用以大小写相同的字母（[ae]，[AE]）或数字（[0-9]）开头和结尾的范围。还有其他不安全或不清楚的地方。如有疑问，请完整说明范围。</target>
        </trans-unit>
        <trans-unit id="32102cc598d5c6f1883220e9be88e26b0126c4bb" translate="yes" xml:space="preserve">
          <source>It is highly recommended to use the new interface.</source>
          <target state="translated">强烈建议使用新界面。</target>
        </trans-unit>
        <trans-unit id="ca5fa5ba1e81b193ad6d8416f6d80a9e68a2d380" translate="yes" xml:space="preserve">
          <source>It is however guaranteed that backslash or escape sequences never have a punctuation character following the backslash, not now, and not in a future version of Perl 5. So it is safe to put a backslash in front of a non-word character.</source>
          <target state="translated">然而,我们可以保证反斜杠或转义序列的后面永远不会有标点符号,现在不会,将来的 Perl 5 版本也不会,所以在非单词字符前面加上反斜杠是安全的。</target>
        </trans-unit>
        <trans-unit id="77f0274e9c470893b80643add674cf709738754d" translate="yes" xml:space="preserve">
          <source>It is implemented using the standard perl TIEHASH interface. Please see the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; entry in perlfunc(1) and perltie(1) for more information.</source>
          <target state="translated">它使用标准的perl TIEHASH接口实现。有关更多信息，请参见perlfunc（1）和perltie（1）中的 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="af6e31eac027382e54503e05f6d0085165cacf75" translate="yes" xml:space="preserve">
          <source>It is implemented using the standard perl TIEHASH interface. Please see the &lt;code&gt;tie&lt;/code&gt; entry in perlfunc(1) and perltie(1) for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ed786f282bde3aa8de3b1b643efa3bb560a2fd" translate="yes" xml:space="preserve">
          <source>It is important that you read the &lt;a href=&quot;opcode&quot;&gt;Opcode&lt;/a&gt; module documentation for more information, especially for detailed definitions of opnames, optags and opsets.</source>
          <target state="translated">请阅读&lt;a href=&quot;opcode&quot;&gt;Opcode&lt;/a&gt;模块文档以获取更多信息，尤其是关于操作名，操作标签和操作集的详细定义，这一点很重要。</target>
        </trans-unit>
        <trans-unit id="2977106e878eb3427358dec08f1824351409ba37" translate="yes" xml:space="preserve">
          <source>It is important that you use a supported 'make' program, and ensure Config.pm knows about it. If you don't have nmake, you can either get dmake from the location mentioned earlier or get an old version of nmake reportedly available from:</source>
          <target state="translated">重要的是,你必须使用一个支持的 &quot;make &quot;程序,并确保Config.pm知道它。如果你没有 nmake,你可以从前面提到的地方获取 dmake,或者从以下地方获取旧版本的 nmake。</target>
        </trans-unit>
        <trans-unit id="ff64ea14bb1b01f98f924406ee57c3ed5e8b95d4" translate="yes" xml:space="preserve">
          <source>It is important to do &lt;code&gt;make dist&lt;/code&gt; as early as possible. This way you can easily merge(1) your changes to autogenerated files if you decide to edit your &lt;code&gt;.h&lt;/code&gt; files and rerun h2xs.</source>
          <target state="translated">尽早 &lt;code&gt;make dist&lt;/code&gt; 是很重要的。这样，如果您决定编辑 &lt;code&gt;.h&lt;/code&gt; 文件并重新运行h2xs，则可以轻松地合并（1）对自动生成的文件的更改。</target>
        </trans-unit>
        <trans-unit id="a9a567c14d6791400f926d0994fcc8f3b056f648" translate="yes" xml:space="preserve">
          <source>It is important to know that these CLIs may behave different when the command line contains special characters, in particular quotes or backslashes. For example, with Unix shells you can use single quotes (&lt;code&gt;'&lt;/code&gt;) and double quotes (&lt;code&gt;&quot;&lt;/code&gt;) to group words together. The following alternatives are equivalent on Unix:</source>
          <target state="translated">重要的是要知道，当命令行包含特殊字符（特别是引号或反斜杠）时，这些CLI的行为可能会有所不同。例如，在Unix shell中，您可以使用单引号（ &lt;code&gt;'&lt;/code&gt; ）和双引号（ &lt;code&gt;&quot;&lt;/code&gt; ）将单词组合在一起。以下替代方法在Unix上是等效的：</target>
        </trans-unit>
        <trans-unit id="dcb1aa33844e3457c736e676b2e42e15c5425cfa" translate="yes" xml:space="preserve">
          <source>It is important to note that the variable can be notified even if no thread &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; on the variable. It is therefore important to check the value of the variable and go back to waiting if the requirement is not fulfilled. For example, to pause until a shared counter drops to zero:</source>
          <target state="translated">重要的是要注意，即使在变量上没有线程 &lt;code&gt;cond_signal&lt;/code&gt; 或 &lt;code&gt;cond_broadcast&lt;/code&gt; ，也可以通知该变量。因此，重要的是检查变量的值并在未满足要求时返回等待状态。例如，要暂停直到共享计数器降为零：</target>
        </trans-unit>
        <trans-unit id="38610253c48ac1bf013b9d6e4c9a87cd05da4c30" translate="yes" xml:space="preserve">
          <source>It is important to note that when called with an item that is recovered by using &lt;code&gt;localeconv&lt;/code&gt;, the buffer from any previous explicit call to &lt;code&gt;localeconv&lt;/code&gt; will be overwritten. This means you must save that buffer's contents if you need to access them after a call to this function. (But note that you might not want to be using &lt;code&gt;localeconv()&lt;/code&gt; directly anyway, because of issues like the ones listed in the second item of this list (above) for &lt;code&gt;RADIXCHAR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt;. You can use the methods given in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; to call &lt;a href=&quot;posix#localeconv&quot;&gt;&quot;localeconv&quot; in POSIX&lt;/a&gt; and avoid all the issues, but then you have a hash to unpack).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07be512ccc5c73682b884e92456cd275f3ff5ced" translate="yes" xml:space="preserve">
          <source>It is important to realize when you use these Unicode boundaries, that you are taking a risk that a future version of Perl which contains a later version of the Unicode Standard will not work precisely the same way as it did when your code was written. These rules are not considered stable and have been somewhat more subject to change than the rest of the Standard. Unicode reserves the right to change them at will, and Perl reserves the right to update its implementation to Unicode's new rules. In the past, some changes have been because new characters have been added to the Standard which have different characteristics than all previous characters, so new rules are formulated for handling them. These should not cause any backward compatibility issues. But some changes have changed the treatment of existing characters because the Unicode Technical Committee has decided that the change is warranted for whatever reason. This could be to fix a bug, or because they think better results are obtained with the new rule.</source>
          <target state="translated">当你使用这些Unicode边界时,你必须意识到你正在承担一个风险,即未来的Perl版本如果包含了Unicode标准的较新版本,那么它的工作方式将与你的代码编写时不完全相同。这些规则不被认为是稳定的,而且比标准的其他部分更容易改变。Unicode 保留了随意更改它们的权利,Perl 也保留了根据 Unicode 的新规则更新其实现的权利。在过去,有些变化是因为标准中加入了新的字符,这些字符与以前所有的字符有不同的特性,所以制定了新的规则来处理它们。这些应该不会引起任何后向兼容性问题。但有些变化是由于Unicode技术委员会决定出于某种原因而改变了对现有字符的处理。这可能是为了修复一个错误,或者因为他们认为新规则可以获得更好的结果。</target>
        </trans-unit>
        <trans-unit id="6b377275b56d69ca0e60d3e0cbc10a16f405fe04" translate="yes" xml:space="preserve">
          <source>It is important to remember that &lt;code&gt;yield()&lt;/code&gt; is only a hint to give up the CPU, it depends on your hardware, OS and threading libraries what actually happens. &lt;b&gt;On many operating systems, yield() is a no-op.&lt;/b&gt; Therefore it is important to note that one should not build the scheduling of the threads around &lt;code&gt;yield()&lt;/code&gt; calls. It might work on your platform but it won't work on another platform.</source>
          <target state="translated">重要的是要记住， &lt;code&gt;yield()&lt;/code&gt; 仅是放弃CPU的提示，它取决于您的硬件，操作系统和线程库实际发生的情况。&lt;b&gt;在许多操作系统上，yield（）是禁止操作的。&lt;/b&gt;因此，重要的是要注意，不应围绕 &lt;code&gt;yield()&lt;/code&gt; 调用构建线程的调度。它可能会在您的平台上运行，但不会在另一个平台上运行。</target>
        </trans-unit>
        <trans-unit id="229373f44a4516dbdfee3cc1ec19491aa465bff2" translate="yes" xml:space="preserve">
          <source>It is intended mainly for use in assignments to references (see &lt;a href=&quot;#Assigning-to-References&quot;&gt;&quot;Assigning to References&quot;&lt;/a&gt;, above). It also allows the backslash to be used on just some items in a list of declared variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb902098169f8bf10c78af87761104595e279d51" translate="yes" xml:space="preserve">
          <source>It is intended to be called in this manner:</source>
          <target state="translated">拟以这种方式称呼。</target>
        </trans-unit>
        <trans-unit id="c0729952a79f213dacf0ff4ae76e571d0559ed54" translate="yes" xml:space="preserve">
          <source>It is just like &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt; but it takes an extra parameter placed after all the others, &lt;code&gt;msgs&lt;/code&gt;. If this parameter is 0, this function behaves identically to &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise, &lt;code&gt;msgs&lt;/code&gt; should be a pointer to an &lt;code&gt;AV *&lt;/code&gt; variable, in which this function creates a new AV to contain any appropriate messages. The elements of the array are ordered so that the first message that would have been displayed is in the 0th element, and so on. Each element is a hash with three key-value pairs, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b304ade153185375df945a6e52ec74226ffc08" translate="yes" xml:space="preserve">
          <source>It is just like &lt;code&gt;&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;&lt;/code&gt; but it takes an extra parameter placed after all the others, &lt;code&gt;msgs&lt;/code&gt;. If this parameter is 0, this function behaves identically to &lt;code&gt;&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise, &lt;code&gt;msgs&lt;/code&gt; should be a pointer to an &lt;code&gt;HV *&lt;/code&gt; variable, in which this function creates a new HV to contain any appropriate messages. The hash has three key-value pairs, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c67b173e9f7ca15b0d9849fa732dc6b9c27b1b9" translate="yes" xml:space="preserve">
          <source>It is legal to intermix calls to &lt;code&gt;gzread&lt;/code&gt; and &lt;code&gt;gzreadline&lt;/code&gt; .</source>
          <target state="translated">将调用 &lt;code&gt;gzread&lt;/code&gt; 和 &lt;code&gt;gzreadline&lt;/code&gt; 混合在一起是合法的。</target>
        </trans-unit>
        <trans-unit id="310546f36d0b89e4ca2512f6a8bbbc58b3213ebb" translate="yes" xml:space="preserve">
          <source>It is legal to intermix calls to &lt;code&gt;gzread&lt;/code&gt; and &lt;code&gt;gzreadline&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b081e40b0dd1e97c28fc968fc88db21c07110075" translate="yes" xml:space="preserve">
          <source>It is less confusing to either calculate the result fully, and afterwards round it explicitly, or use the additional parameters to the math functions like so:</source>
          <target state="translated">要么充分计算结果,事后明确四舍五入,要么像这样使用数学函数的附加参数,这样就不那么混乱了。</target>
        </trans-unit>
        <trans-unit id="1a0e27e331f66d429f8d776eb7eea1b1dc292c9e" translate="yes" xml:space="preserve">
          <source>It is like &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt; but it takes an extra parameter placed after all the others, &lt;code&gt;errors&lt;/code&gt;. If this parameter is 0, this function behaves identically to &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise, &lt;code&gt;errors&lt;/code&gt; should be a pointer to a &lt;code&gt;U32&lt;/code&gt; variable, which this function sets to indicate any errors found. Upon return, if &lt;code&gt;*errors&lt;/code&gt; is 0, there were no errors found. Otherwise, &lt;code&gt;*errors&lt;/code&gt; is the bit-wise &lt;code&gt;OR&lt;/code&gt; of the bits described in the list below. Some of these bits will be set if a malformation is found, even if the input &lt;code&gt;flags&lt;/code&gt; parameter indicates that the given malformation is allowed; those exceptions are noted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac2033e4ba80b8d679681b08231b45a9481613f" translate="yes" xml:space="preserve">
          <source>It is more correct and more complete than &lt;a href=&quot;HTTP::Lite&quot;&gt;HTTP::Lite&lt;/a&gt;. It supports proxies and redirection. It also correctly resumes after EINTR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f913862bf185692af7e2eaaf2148c65356aec6" translate="yes" xml:space="preserve">
          <source>It is most convenient to use in a &lt;code&gt;foreach&lt;/code&gt; loop, for example:</source>
          <target state="translated">在 &lt;code&gt;foreach&lt;/code&gt; 循环中使用最方便，例如：</target>
        </trans-unit>
        <trans-unit id="69bffc928e3fa117d0fd3dd3376d4295ace44212" translate="yes" xml:space="preserve">
          <source>It is no longer possible to compile PA-RISC 1.0 executables on either the PA-RISC 1.1 or 2.0 platforms. The command-line flags are accepted, but the resulting executable will not run when transferred to a PA-RISC 1.0 system.</source>
          <target state="translated">在PA-RISC 1.1或2.0平台上编译PA-RISC 1.0可执行文件已不再可能。命令行标志被接受,但当转移到PA-RISC 1.0系统时,产生的可执行文件将无法运行。</target>
        </trans-unit>
        <trans-unit id="09c5f6dc5c28104c8b1496a7745505dfd0c3755b" translate="yes" xml:space="preserve">
          <source>It is no longer possible to link PA-RISC 1.0 shared libraries (even though the command-line flags are still present).</source>
          <target state="translated">现在已经不可能链接PA-RISC 1.0共享库了(即使命令行标志仍然存在)。</target>
        </trans-unit>
        <trans-unit id="5e391513315c3abeec46220661da8fc25e5f09fd" translate="yes" xml:space="preserve">
          <source>It is not considered an error for &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to return false if it fails due to an &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (or equivalent) condition. This means one can still use the common convention of testing the return value of &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; when called with the &lt;code&gt;LOCK_NB&lt;/code&gt; option:</source>
          <target state="translated">如果由于 &lt;code&gt;EWOULDBLOCK&lt;/code&gt; （或等效条件）而失败，则 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 返回false 不会被认为是错误。这意味着当使用 &lt;code&gt;LOCK_NB&lt;/code&gt; 选项调用时，仍然可以使用测试 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 返回值的通用约定：</target>
        </trans-unit>
        <trans-unit id="5203d22c8328a2d0b2cff53631202830f7dc2011" translate="yes" xml:space="preserve">
          <source>It is not considered an error for &lt;code&gt;flock&lt;/code&gt; to return false if it fails due to an &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (or equivalent) condition. This means one can still use the common convention of testing the return value of &lt;code&gt;flock&lt;/code&gt; when called with the &lt;code&gt;LOCK_NB&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb49901ab613cbcc1013bad05870bde6b73a1f49" translate="yes" xml:space="preserve">
          <source>It is not desirable to import the functions &lt;code&gt;fieldhash&lt;/code&gt; and/or &lt;code&gt;fieldhashes&lt;/code&gt; into every class that is going to use them. They are only used once to set up the class. When the class is up and running, these functions serve no more purpose.</source>
          <target state="translated">不希望将函数 &lt;code&gt;fieldhash&lt;/code&gt; 和/或 &lt;code&gt;fieldhashes&lt;/code&gt; 导入要使用它们的每个类中。它们仅用于设置课程一次。当类启动并运行时，这些功能不再起作用。</target>
        </trans-unit>
        <trans-unit id="c5fbc8d597bc2a95fe72ba36ecdd3925f81ca3bb" translate="yes" xml:space="preserve">
          <source>It is not necessary for voting to be held on cherry-picking perldelta entries associated with changes that have already been cherry-picked, nor for the maint-pumpking to obtain votes on changes required by the</source>
          <target state="translated">对与已经采摘的变更相关的采摘perldelta条目不需要进行投票,也不需要主推对所需变更进行投票。</target>
        </trans-unit>
        <trans-unit id="27e3bb472e9cdfda94e8831e0977881e11fb42e5" translate="yes" xml:space="preserve">
          <source>It is not necessary to include every change meeting these criteria, and in general the focus should be on addressing security issues, crashing bugs, regressions and serious installation issues. The temptation to include a plethora of minor changes that don't affect the installation or execution of perl (e.g. spelling corrections in documentation) should be resisted in order to reduce the overall risk of overlooking something. The intention is to create maintenance releases which are both worthwhile and which users can have full confidence in the stability of. (A secondary concern is to avoid burning out the maint-pumpking or overwhelming other committers voting on changes to be included (see &lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;&quot;Getting changes into a maint branch&quot;&lt;/a&gt; below).)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee4bc3261e1d5762f4a782cbbcca1c13a9e84eb" translate="yes" xml:space="preserve">
          <source>It is not necessary to include every change meeting these criteria, and in general the focus should be on addressing security issues, crashing bugs, regressions and serious installation issues. The temptation to include a plethora of minor changes that don't affect the installation or execution of perl (e.g. spelling corrections in documentation) should be resisted in order to reduce the overall risk of overlooking something. The intention is to create maintenance releases which are both worthwhile and which users can have full confidence in the stability of. (A secondary concern is to avoid burning out the maint-pumpking or overwhelming other committers voting on changes to be included (see &lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;Getting changes into a maint branch&lt;/a&gt; below).)</source>
          <target state="translated">不必包括所有符合这些条件的变更，通常，重点应放在解决安全性问题，崩溃的bug，回归和严重的安装问题上。为了减少总体上忽略某些内容的风险，应该抵制诱惑，包括不影响perl的安装或执行的大量次要更改（例如，文档中的拼写更正）。目的是创建既值得而且用户可以对其稳定性完全放心的维护版本。 （第二个注意事项是避免耗尽主干泵或压倒其他提交者对要包含的更改进行投票（请参阅下面的将&lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;更改放入主干分支&lt;/a&gt;）。）</target>
        </trans-unit>
        <trans-unit id="90bcb58fb92d14a7b685940a550af6acd8800f2a" translate="yes" xml:space="preserve">
          <source>It is not necessary to mention DynaLoader or the current extension when filling in INCLUDE_EXT. If the INCLUDE_EXT is mentioned but is empty then only DynaLoader and the current extension will be included in the build.</source>
          <target state="translated">在填写INCLUDE_EXT时,不需要提及DynaLoader或当前的扩展。如果INCLUDE_EXT被提及但为空,那么只有DynaLoader和当前扩展会被包含在构建中。</target>
        </trans-unit>
        <trans-unit id="6c22235436c0d9c88ea34e3651dd185b541bd55a" translate="yes" xml:space="preserve">
          <source>It is not possible to have a subroutine or a keyword with the same name as a constant in the same package. This is probably a Good Thing.</source>
          <target state="translated">在同一个包中,不可能有一个子程序或一个与常量同名的关键字。这可能是一件好事。</target>
        </trans-unit>
        <trans-unit id="f4712dd85edea86a32c5bfd8ffd1fe49536a91d9" translate="yes" xml:space="preserve">
          <source>It is not possible to pack or unpack bit fields - just integral bytes. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; always starts at the next byte boundary and &quot;rounds up&quot; to the next multiple of 8 by adding zero bits as required. (If you do want bit fields, there is &lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;. Or you could implement bit field handling at the character string level, using split, substr, and concatenation on unpacked bit strings.)</source>
          <target state="translated">不能打包或解包位字段-只能是整数字节。 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 总是从下一个字节边界开始，并通过按要求添加零位来&amp;ldquo;舍入&amp;rdquo;为8的下一个倍数。（如果确实需要位字段，则可以使用&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;。也可以在字符串级别使用未打包的位字符串上的split，substr和concatenation来实现位字段处理。）</target>
        </trans-unit>
        <trans-unit id="39a07790029fea0888a82dfcdbb3f4369b9da3f5" translate="yes" xml:space="preserve">
          <source>It is not possible to pack or unpack bit fields - just integral bytes. &lt;code&gt;pack&lt;/code&gt; always starts at the next byte boundary and &quot;rounds up&quot; to the next multiple of 8 by adding zero bits as required. (If you do want bit fields, there is &lt;a href=&quot;perlfunc#vec&quot;&gt;&quot;vec&quot; in perlfunc&lt;/a&gt;. Or you could implement bit field handling at the character string level, using split, substr, and concatenation on unpacked bit strings.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efe75bc9ad9fbe460b3b9a87287e6aa69baa4d8" translate="yes" xml:space="preserve">
          <source>It is not safe to use the value of &lt;code&gt;$^X&lt;/code&gt; as a path name of a file, as some operating systems that have a mandatory suffix on executable files do not require use of the suffix when invoking a command. To convert the value of &lt;code&gt;$^X&lt;/code&gt; to a path name, use the following statements:</source>
          <target state="translated">将 &lt;code&gt;$^X&lt;/code&gt; 的值用作文件的路径名是不安全的，因为某些在可执行文件上带有强制后缀的操作系统在调用命令时不需要使用后缀。要将 &lt;code&gt;$^X&lt;/code&gt; 的值转换为路径名，请使用以下语句：</target>
        </trans-unit>
        <trans-unit id="17f49b3471db481f432117951bcb8866bb533894" translate="yes" xml:space="preserve">
          <source>It is not uncommon to want to match a range of characters. Luckily, instead of listing all characters in the range, one may use the hyphen (&lt;code&gt;-&lt;/code&gt; ). If inside a bracketed character class you have two characters separated by a hyphen, it's treated as if all characters between the two were in the class. For instance, &lt;code&gt;[0-9]&lt;/code&gt; matches any ASCII digit, and &lt;code&gt;[a-m]&lt;/code&gt; matches any lowercase letter from the first half of the ASCII alphabet.</source>
          <target state="translated">想要匹配一定范围的字符并不少见。幸运的是，与其列出该范围内的所有字符，不如使用连字符（ &lt;code&gt;-&lt;/code&gt; ）。如果在带括号的字符类中，您有两个字符用连字符分隔，则将这两个字符之间的所有字符都视为类中的字符。例如， &lt;code&gt;[0-9]&lt;/code&gt; 匹配任何ASCII数字， &lt;code&gt;[a-m]&lt;/code&gt; 匹配ASCII字母表前半部分的任何小写字母。</target>
        </trans-unit>
        <trans-unit id="7607528bdce01b011f213f8ac77cd85f02fbbdd6" translate="yes" xml:space="preserve">
          <source>It is not uncommon to want to match a range of characters. Luckily, instead of listing all characters in the range, one may use the hyphen (&lt;code&gt;-&lt;/code&gt;). If inside a bracketed character class you have two characters separated by a hyphen, it's treated as if all characters between the two were in the class. For instance, &lt;code&gt;[0-9]&lt;/code&gt; matches any ASCII digit, and &lt;code&gt;[a-m]&lt;/code&gt; matches any lowercase letter from the first half of the ASCII alphabet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea195389d2ab8304dae6a2be37001201928a81bd" translate="yes" xml:space="preserve">
          <source>It is now being maintained separately from the Perl core by Dave Rolsky, &amp;lt;autarch@urth.org&amp;gt;.</source>
          <target state="translated">现在，Dave Rolsky（&amp;lt;autarch@urth.org&amp;gt;）与Perl核心分开进行维护。</target>
        </trans-unit>
        <trans-unit id="0a2d81d68cd0e192d7fee2715fc04989d662c22e" translate="yes" xml:space="preserve">
          <source>It is often more readable to use the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator between key/value pairs. The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is mostly just a more visually distinctive synonym for a comma, but it also arranges for its left-hand operand to be interpreted as a string if it's a bareword that would be a legal simple identifier. &lt;code&gt;=&amp;gt;&lt;/code&gt; doesn't quote compound identifiers, that contain double colons. This makes it nice for initializing hashes:</source>
          <target state="translated">在键/值对之间使用 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符通常更易读。该 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运营商大多只是视觉上更加鲜明的逗号代名词，但它也安排了左边的操作数，如果它是这将是一个合法的简单标识的裸词被解释为一个字符串。 &lt;code&gt;=&amp;gt;&lt;/code&gt; 不引用包含双冒号的复合标识符。这非常适合初始化哈希：</target>
        </trans-unit>
        <trans-unit id="c425383e0dcd08da6401882b3bf5fc73ffa2b23f" translate="yes" xml:space="preserve">
          <source>It is often not wise to share an object unless the class itself has been written to support sharing. For example, a shared object's destructor may get called multiple times, once for each thread's scope exit, or may not get called at all if it is embedded inside another shared object. Another issue is that the contents of hash-based objects will be lost due to the above mentioned limitation. See</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5507a15a15ea470ddab20bdff08a946fb003e3" translate="yes" xml:space="preserve">
          <source>It is often not wise to share an object unless the class itself has been written to support sharing. For example, an object's destructor may get called multiple times, once for each thread's scope exit. Another danger is that the contents of hash-based objects will be lost due to the above mentioned limitation. See</source>
          <target state="translated">通常情况下,共享一个对象是不明智的,除非类本身已经被编写成支持共享。例如,一个对象的destructor可能会被多次调用,每个线程的作用域退出都会被调用一次。另一个危险是,基于哈希的对象的内容会因为上述限制而丢失。请看</target>
        </trans-unit>
        <trans-unit id="c69ba08cbdace146eeaa3088aa2fbd7151747d45" translate="yes" xml:space="preserve">
          <source>It is okay for the lines starting at the &quot;CODE:&quot; line to not be indented. However, for readability purposes, it is suggested that you indent CODE: one level and the lines following one more level.</source>
          <target state="translated">从 &quot;CODE:&quot;开始的行可以不缩进。但是,为了便于阅读,建议将CODE:缩进一级,后面的行再缩进一级。</target>
        </trans-unit>
        <trans-unit id="65df07e3fa6135b82df3a9d6866989ee7ae4d5d2" translate="yes" xml:space="preserve">
          <source>It is only used on OS/2 and Win32.</source>
          <target state="translated">它只在OS/2和Win32上使用。</target>
        </trans-unit>
        <trans-unit id="3ea8b006ce3e53db87407f2dbaa5815e87ff2f78" translate="yes" xml:space="preserve">
          <source>It is particularly important to have this graft line if any bisecting is done in the area of the &quot;merge&quot; in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6661787e0f495e149a6ee0b4ddf2a5d46d4df496" translate="yes" xml:space="preserve">
          <source>It is particularly important to note that neither the shell nor the C runtime do any wildcard expansions of command-line arguments (so wildcards need not be quoted). Also, the quoting behaviours of the shell and the C runtime are rudimentary at best (and may, if you are using a non-standard shell, be inconsistent). The only (useful) quote character is the double quote (&quot;). It can be used to protect spaces and other special characters in arguments.</source>
          <target state="translated">特别需要注意的是,shell和C运行时都不对命令行参数进行通配符扩展(所以通配符不需要引用)。另外,shell和C运行时的引号行为充其量只是初级的(如果你使用的是非标准的shell,可能会有不一致的地方)。唯一(有用的)引号字符是双引号(&quot;)。它可以用来保护参数中的空格和其他特殊字符。</target>
        </trans-unit>
        <trans-unit id="b08f708cd4767406ca484e1891baf6f457b1498f" translate="yes" xml:space="preserve">
          <source>It is possible for the Perl subroutine you are calling to terminate abnormally, e.g., by calling</source>
          <target state="translated">你所调用的Perl子程序有可能会异常终止,例如,通过调用</target>
        </trans-unit>
        <trans-unit id="68748e768505aa715cf11b4ae34ec36bb19593be" translate="yes" xml:space="preserve">
          <source>It is possible that, upon completion, not all arguments in the string have been processed. &lt;code&gt;GetOptionsFromString&lt;/code&gt; will, when called in list context, return both the return status and an array reference to any remaining arguments:</source>
          <target state="translated">完成后，可能未处理完字符串中的所有参数。在列表上下文中调用时， &lt;code&gt;GetOptionsFromString&lt;/code&gt; 将返回返回状态和对任何剩余参数的数组引用：</target>
        </trans-unit>
        <trans-unit id="67c5b12c61d00e32b42a8983e07a796133ebb6eb" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;a href=&quot;perlmod#BEGIN%2C-UNITCHECK%2C-CHECK%2C-INIT-and-END&quot;&gt;END blocks&lt;/a&gt; to threads by using &lt;a href=&quot;perlfunc#require-VERSION&quot;&gt;require&lt;/a&gt; or &lt;a href=&quot;perlfunc#eval-EXPR&quot;&gt;eval&lt;/a&gt; with the appropriate code. These &lt;code&gt;END&lt;/code&gt; blocks will then be executed when the thread's interpreter is destroyed (i.e., either during a &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call, or at program termination).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1fb645dee4eb2dcf81d78a3bbd52439eec6574" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;END blocks&lt;/a&gt; to threads by using &lt;a href=&quot;functions/require&quot;&gt;require VERSION&lt;/a&gt; or &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; with the appropriate code. These &lt;code&gt;END&lt;/code&gt; blocks will then be executed when the thread's interpreter is destroyed (i.e., either during a &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call, or at program termination).</source>
          <target state="translated">通过使用带有适当代码的&lt;a href=&quot;functions/require&quot;&gt;require VERSION&lt;/a&gt;或&lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt;，可以向线程添加&lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;END块&lt;/a&gt;。然后，当线程的解释器被销毁时（即，在 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 调用期间或程序终止时），将执行这些 &lt;code&gt;END&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="103a4ec3966b9d4c47f8bb4d45cb27898db88b92" translate="yes" xml:space="preserve">
          <source>It is possible to ask for a different method resolution order with the &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma.</source>
          <target state="translated">可以使用&lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma 要求不同的方法解析顺序。</target>
        </trans-unit>
        <trans-unit id="214e8fa8e052ffd8fef627a3a69587c1d8000f20" translate="yes" xml:space="preserve">
          <source>It is possible to ask for such a statistic at arbitrary points in your execution using the mstat() function out of the standard Devel::Peek module.</source>
          <target state="translated">可以使用标准的Devel::Peek模块中的mstat()函数在执行过程中的任意点要求这样一个统计。</target>
        </trans-unit>
        <trans-unit id="b3c2ec1b334ee0d70dae2975648b13f78c06cb41" translate="yes" xml:space="preserve">
          <source>It is possible to build a threaded version of perl on Solaris. The entire perl thread implementation is still experimental, however, so beware.</source>
          <target state="translated">在Solaris上可以构建一个线程版的perl。然而,整个perl线程的实现仍然是实验性的,所以要注意。</target>
        </trans-unit>
        <trans-unit id="5dcdcf19c7450b4c54b9304c481faacc66e7c2fc" translate="yes" xml:space="preserve">
          <source>It is possible to compile a version of threaded Perl on any version of HP-UX before 10.30, but it is strongly suggested that you be running on HP-UX 11.00 at least.</source>
          <target state="translated">可以在10.30之前的任何HP-UX版本上编译一个线程Perl的版本,但强烈建议你至少在HP-UX 11.00上运行。</target>
        </trans-unit>
        <trans-unit id="fda7319a695e60b7430ed01765a1f487df41c0cc" translate="yes" xml:space="preserve">
          <source>It is possible to control which characters terminate words by modifying &lt;code&gt;$Text::Wrap::break&lt;/code&gt; . Set this to a string such as &lt;code&gt;'[\s:]'&lt;/code&gt; (to break before spaces or colons) or a pre-compiled regexp such as &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/[\s']/&lt;/a&gt;&lt;/code&gt; (to break before spaces or apostrophes). The default is simply &lt;code&gt;'\s'&lt;/code&gt; ; that is, words are terminated by spaces. (This means, among other things, that trailing punctuation such as full stops or commas stay with the word they are &quot;attached&quot; to.) Setting &lt;code&gt;$Text::Wrap::break&lt;/code&gt; to a regular expression that doesn't eat any characters (perhaps just a forward look-ahead assertion) will cause warnings.</source>
          <target state="translated">通过修改 &lt;code&gt;$Text::Wrap::break&lt;/code&gt; 可以控制哪些字符终止单词。将其设置为字符串，例如 &lt;code&gt;'[\s:]'&lt;/code&gt; （在空格或冒号之前中断）或预编译的正则表达式（例如 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/[\s']/&lt;/a&gt;&lt;/code&gt; （在空格或撇号之前中断）。默认是简单的 &lt;code&gt;'\s'&lt;/code&gt; ;也就是说，单词以空格结尾。 （这意味着，除其他事项外，诸如句号或逗号之类的标点符号都与它们&amp;ldquo;附加&amp;rdquo;在一起。）将 &lt;code&gt;$Text::Wrap::break&lt;/code&gt; 设置为不吃任何字符的正则表达式（也许只是一个前瞻性的断言）会引起警告。</target>
        </trans-unit>
        <trans-unit id="4b27989d9b82508c46a4fe952eadfb7a10b89ae6" translate="yes" xml:space="preserve">
          <source>It is possible to control which characters terminate words by modifying &lt;code&gt;$Text::Wrap::break&lt;/code&gt;. Set this to a string such as &lt;code&gt;'[\s:]'&lt;/code&gt; (to break before spaces or colons) or a pre-compiled regexp such as &lt;code&gt;qr/[\s']/&lt;/code&gt; (to break before spaces or apostrophes). The default is simply &lt;code&gt;'\s'&lt;/code&gt;; that is, words are terminated by spaces. (This means, among other things, that trailing punctuation such as full stops or commas stay with the word they are &quot;attached&quot; to.) Setting &lt;code&gt;$Text::Wrap::break&lt;/code&gt; to a regular expression that doesn't eat any characters (perhaps just a forward look-ahead assertion) will cause warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe767cd6ad41a1bf2749df0593b7a56afc9ca68" translate="yes" xml:space="preserve">
          <source>It is possible to create a &quot;circular reference&quot; in Perl, which can lead to memory leaks. A circular reference occurs when two references contain a reference to each other, like this:</source>
          <target state="translated">在Perl中可以创建一个 &quot;循环引用&quot;,这可能会导致内存泄漏。当两个引用包含一个相互引用时,就会出现循环引用,就像这样。</target>
        </trans-unit>
        <trans-unit id="194e4ce07b732bc978b1694be34e6655ffc1b7f6" translate="yes" xml:space="preserve">
          <source>It is possible to determine which character set you are operating under. But first you need to be really really sure you need to do this. Your code will be simpler and probably just as portable if you don't have to test the character set and do different things, depending. There are actually only very few circumstances where it's not easy to write straight-line code portable to all character sets. See &lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;&quot;Unicode and EBCDIC&quot; in perluniintro&lt;/a&gt; for how to portably specify characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c791c22192baa95a06c328176e1b85eddd8c69ea" translate="yes" xml:space="preserve">
          <source>It is possible to determine which character set you are operating under. But first you need to be really really sure you need to do this. Your code will be simpler and probably just as portable if you don't have to test the character set and do different things, depending. There are actually only very few circumstances where it's not easy to write straight-line code portable to all character sets. See &lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;Unicode and EBCDIC in perluniintro&lt;/a&gt; for how to portably specify characters.</source>
          <target state="translated">可以确定要使用的字符集。但是首先，您必须非常确定要执行此操作。如果您不必测试字符集并执行其他操作（取决于具体情况），您的代码将更加简单，并且可能具有可移植性。实际上，在极少数情况下，编写可移植到所有字符集的直线代码并不容易。有关如何可移植地指定字符，请参见&lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;perluniintro中的Unicode和EBCDIC&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0813f66fef4fb95209b9bd5234a37222cb817c4" translate="yes" xml:space="preserve">
          <source>It is possible to explicitly call a parent method from a child:</source>
          <target state="translated">可以从子方法中显式调用父方法。</target>
        </trans-unit>
        <trans-unit id="c0da326565896926df8bd9bb48dde0df4c98d8f9" translate="yes" xml:space="preserve">
          <source>It is possible to forbid or warn on non-Unicode code points, or those that may be problematic by using &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19734113aaf232e977540f9be066f896f4d50e8" translate="yes" xml:space="preserve">
          <source>It is possible to get special treatment for a lone dash. This can be achieved by adding an option specification with an empty name, for example:</source>
          <target state="translated">可以对孤零零的破折号进行特殊处理。这可以通过添加一个空名的选项规范来实现,例如。</target>
        </trans-unit>
        <trans-unit id="0e645006456f020c2cb729a6c316a213de718eec" translate="yes" xml:space="preserve">
          <source>It is possible to import autodie into a different namespace by using &lt;a href=&quot;Import::Into&quot;&gt;Import::Into&lt;/a&gt;. However, you have to pass a &quot;caller depth&quot; (rather than a package name) for this to work correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484490759459d1a463406a9ec978f4abc6c5898b" translate="yes" xml:space="preserve">
          <source>It is possible to inspect both the string given to RE engine and the resulting finite automaton. See the arguments &lt;code&gt;debug&lt;/code&gt; /&lt;code&gt;debugcolor&lt;/code&gt; in the &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; pragma, as well as Perl's &lt;b&gt;-Dr&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;.</source>
          <target state="translated">既可以检查提供给RE引擎的字符串，也可以检查生成的有限自动机。参见参数 &lt;code&gt;debug&lt;/code&gt; / &lt;code&gt;debugcolor&lt;/code&gt; 在 &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; 编译，以及Perl的&lt;b&gt;-Dr&lt;/b&gt;中记录的命令行开关&lt;a href=&quot;perlrun#Command-Switches&quot;&gt;命令开关在perlrun&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2de0a7af99e757a8e8485b1376bbc31dd1cac31e" translate="yes" xml:space="preserve">
          <source>It is possible to inspect both the string given to RE engine and the resulting finite automaton. See the arguments &lt;code&gt;debug&lt;/code&gt;/&lt;code&gt;debugcolor&lt;/code&gt; in the &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; pragma, as well as Perl's &lt;b&gt;-Dr&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;&quot;Command Switches&quot; in perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4987e0746709787de44b276c954d3dc160982cc" translate="yes" xml:space="preserve">
          <source>It is possible to intermix print()s with write()s on the same output channel, but you'll have to handle &lt;code&gt;$-&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; ) yourself.</source>
          <target state="translated">可以在同一输出通道上将print（）与write（）混合在一起，但是您必须自己处理 &lt;code&gt;$-&lt;/code&gt; （ &lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="17a6fb8a364afc4c2bb94e7dfbe0964a25366786" translate="yes" xml:space="preserve">
          <source>It is possible to intermix print()s with write()s on the same output channel, but you'll have to handle &lt;code&gt;$-&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt;) yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe4bd11a84db5fbf18822129f597065dac28979" translate="yes" xml:space="preserve">
          <source>It is possible to make &lt;code&gt;NEXT&lt;/code&gt; redispatch more demandingly (i.e. like &lt;code&gt;SUPER&lt;/code&gt; does), so that the redispatch throws an exception if it cannot find a &quot;next&quot; method to call.</source>
          <target state="translated">可以使 &lt;code&gt;NEXT&lt;/code&gt; 重新分配的要求更高（例如，像 &lt;code&gt;SUPER&lt;/code&gt; 一样），以便重新分配无法找到要调用的&amp;ldquo;下一个&amp;rdquo;方法时引发异常。</target>
        </trans-unit>
        <trans-unit id="41c5e618b60091d8c922ad7e0e5ebbcfaa2cb4df" translate="yes" xml:space="preserve">
          <source>It is possible to manually set &lt;code&gt;@ISA&lt;/code&gt; , and you may see this in older Perl code. Much older code also uses the &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; pragma. For new code, we recommend that you use the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma to declare your parents. This pragma will take care of setting &lt;code&gt;@ISA&lt;/code&gt; . It will also load the parent classes and make sure that the package doesn't inherit from itself.</source>
          <target state="translated">可以手动设置 &lt;code&gt;@ISA&lt;/code&gt; ，并且您可能会在较早的Perl代码中看到它。许多较旧的代码也使用&lt;a href=&quot;base&quot;&gt;基本的&lt;/a&gt;编译指示。对于新代码，我们建议您使用&lt;a href=&quot;parent&quot;&gt;父级&lt;/a&gt;编译指示来声明您的父级。此实用程序将负责设置 &lt;code&gt;@ISA&lt;/code&gt; 。它还将加载父类，并确保该包不会从其自身继承。</target>
        </trans-unit>
        <trans-unit id="0bf520fb97ddb7d66d056d630c6c0c7c679c7af2" translate="yes" xml:space="preserve">
          <source>It is possible to omit some or all of the final 4 parameters in the call to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; and let them take default values. As DB_HASH is the most common file format used, the call:</source>
          <target state="translated">可以在 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用中省略最后4个参数中的部分或全部，并让它们采用默认值。由于DB_HASH是最常用的文件格式，因此调用：</target>
        </trans-unit>
        <trans-unit id="d77ffc116f1345ae65bcfab7b549b42a9b2529d7" translate="yes" xml:space="preserve">
          <source>It is possible to omit some or all of the final 4 parameters in the call to &lt;code&gt;tie&lt;/code&gt; and let them take default values. As DB_HASH is the most common file format used, the call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4afc212139685087c461e85b80958ff6af0a50" translate="yes" xml:space="preserve">
          <source>It is possible to pass either a subroutine reference (recommended) or a fully qualified subroutine name as the first argument. This means you can set hints on modules that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7b6e646490b1b0de97fffd24d0c15d8fcfff05" translate="yes" xml:space="preserve">
          <source>It is possible to predeclare a lexical subroutine. The &lt;code&gt;sub foo {...}&lt;/code&gt; subroutine definition syntax respects any previous &lt;code&gt;my sub;&lt;/code&gt; or &lt;code&gt;state sub;&lt;/code&gt; declaration. Using this to define recursive subroutines is a bad idea, however:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c72d0292032af6dedc904ed64f2438fc661321" translate="yes" xml:space="preserve">
          <source>It is possible to provide aliases that will be displayed in place of the test name by supplying the test as a reference to an array containing &lt;code&gt;[ $test, $alias ]&lt;/code&gt; :</source>
          <target state="translated">通过提供测试作为对包含 &lt;code&gt;[ $test, $alias ]&lt;/code&gt; 的数组的引用，可以提供将代替测试名称显示的别名：</target>
        </trans-unit>
        <trans-unit id="47d1a50872b03930e2d6b45fee9f2467c56c1224" translate="yes" xml:space="preserve">
          <source>It is possible to provide aliases that will be displayed in place of the test name by supplying the test as a reference to an array containing &lt;code&gt;[ $test, $alias ]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25625bc71a3769321141057e7fb45e78f8f3581c" translate="yes" xml:space="preserve">
          <source>It is possible to replace such an alphanumeric name with an expression that returns a reference to the appropriate type. For a description of this, see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">可以使用返回对适当类型的引用的表达式替换此类字母数字名称。有关此内容的描述，请参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f8a33f0d5f0df1acec3703c5fa0463900e9dcf6" translate="yes" xml:space="preserve">
          <source>It is possible to return a modifiable value from a subroutine. To do this, you have to declare the subroutine to return an lvalue.</source>
          <target state="translated">可以从一个子程序中返回一个可修改的值。要做到这一点,你必须声明子程序要返回一个l值。</target>
        </trans-unit>
        <trans-unit id="deb2736fd66852d74a632f14d09ceb41fcda537d" translate="yes" xml:space="preserve">
          <source>It is possible to stack multiple here-docs in a row:</source>
          <target state="translated">可以连续堆叠多个here-doc。</target>
        </trans-unit>
        <trans-unit id="3f9957642dc32b5a7c0c0eefbd7b6c39d5efef50" translate="yes" xml:space="preserve">
          <source>It is possible to strip the EXEs and DLLs created by the build process. The resulting binaries will be significantly smaller. If you want the binaries to be stripped, you can either add a &lt;b&gt;-s&lt;/b&gt; option when Configure prompts you,</source>
          <target state="translated">可以剥离由构建过程创建的EXE和DLL。生成的二进制文件将大大减小。如果您要删除二进制文件，则可以在配置提示您时添加&lt;b&gt;-s&lt;/b&gt;选项，</target>
        </trans-unit>
        <trans-unit id="0ddc0840c422187183750aec88a33c70a57206b1" translate="yes" xml:space="preserve">
          <source>It is possible to supply arguments to tests. To do so separate them from prove's own arguments with the arisdottle, '::'. For example</source>
          <target state="translated">可以为测试提供参数。要做到这一点,可以用 arisdottle,'::'将它们与 prove 自己的参数分开。例如</target>
        </trans-unit>
        <trans-unit id="843780a126a92b7260b78a50d262eb7d19529c37" translate="yes" xml:space="preserve">
          <source>It is possible to write custom layers in addition to the above builtin ones, both in C/XS and Perl, as a module named &lt;code&gt;PerlIO::&amp;lt;layer name&amp;gt;&lt;/code&gt;. Some custom layers come with the Perl distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6e659dc24039769282bd1c1079f9c11cd8c6ba" translate="yes" xml:space="preserve">
          <source>It is possible to write custom layers in addition to the above builtin ones, both in C/XS and Perl. Two such layers (and one example written in Perl using the latter) come with the Perl distribution.</source>
          <target state="translated">除了上述内置的层之外,还可以用C/XS和Perl编写自定义层。在Perl发行版中,有两个这样的图层(还有一个用Perl编写的例子)。</target>
        </trans-unit>
        <trans-unit id="af11e539efd7b5740f9d5c0eba044f8aebf92a4a" translate="yes" xml:space="preserve">
          <source>It is possible to write:</source>
          <target state="translated">可以写。</target>
        </trans-unit>
        <trans-unit id="3043edf54589d4a75af8ab5a83729379d66bb57a" translate="yes" xml:space="preserve">
          <source>It is possible, though hard to do, to call &lt;code&gt;POSIX::setlocale&lt;/code&gt; with a locale that it doesn't recognize as syntactically legal, but actually is legal on that system. This should happen only with embedded perls, or if you hand-craft a locale name yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d15f29d6da4dd3ad23f2444184a1dcb4a66f4b0" translate="yes" xml:space="preserve">
          <source>It is probably best to chose either the Decimal notation or the string notation and stick with it, to reduce confusion. Perl6 version objects &lt;b&gt;may&lt;/b&gt; only support Decimal comparisons. See also &lt;a href=&quot;#Quoting-Rules&quot;&gt;&quot;Quoting Rules&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b89c8d09aeaea53d5ae118db445020ec34e8b36" translate="yes" xml:space="preserve">
          <source>It is probably useful only when combined with &lt;code&gt;(?{})&lt;/code&gt; or &lt;code&gt;(??{})&lt;/code&gt; .</source>
          <target state="translated">仅当与 &lt;code&gt;(?{})&lt;/code&gt; 或 &lt;code&gt;(??{})&lt;/code&gt; 结合使用时，它才有用。</target>
        </trans-unit>
        <trans-unit id="afaea2dff924e16be833d549ac45ba57d1ea538b" translate="yes" xml:space="preserve">
          <source>It is probably useful only when combined with &lt;code&gt;(?{})&lt;/code&gt; or &lt;code&gt;(??{})&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf00d26aa745eb3ee05b04278f9eed1956a14d27" translate="yes" xml:space="preserve">
          <source>It is proposed to change this behavior in a future release of Perl so that whether or not Unicode rules are in effect would not change the behavior: Outside of locale, the POSIX classes would behave like their ASCII-range counterparts. If you wish to comment on this proposal, send email to &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; .</source>
          <target state="translated">建议在Perl的将来版本中更改此行为，以使Unicode规则是否有效都不会更改该行为：在区域设置之外，POSIX类的行为类似于其ASCII范围的对应对象。如果您想对此建议发表评论，请发送电子邮件至 &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6c7a14017f055e8f9bd10d510eabf5bf071a9ca" translate="yes" xml:space="preserve">
          <source>It is recommended that for this usage you put the DEFINE block at the end of the pattern, and that you name any subpatterns defined within it.</source>
          <target state="translated">建议在这种情况下,将DEFINE块放在模式的结尾,并命名其中定义的任何子模式。</target>
        </trans-unit>
        <trans-unit id="b57d669e4107366ea65426a960e0887b522f0627" translate="yes" xml:space="preserve">
          <source>It is recommended that you enable this option unless you really need to create a non-standard Zip file.</source>
          <target state="translated">建议你启用这个选项,除非你真的需要创建一个非标准的Zip文件。</target>
        </trans-unit>
        <trans-unit id="b5a6bde3e661db2000d4d1c6b83211f16182f9b2" translate="yes" xml:space="preserve">
          <source>It is recommended to &lt;code&gt;use Win32;&lt;/code&gt; before any of these functions; however, for backwards compatibility, those marked as [CORE] will automatically do this for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe9f6b9b410e95d779e30fb9ae34ddfb1f7f1185" translate="yes" xml:space="preserve">
          <source>It is reported that the following archives contain enough utils to build perl:</source>
          <target state="translated">据悉,以下档案包含了足够的实用程序来构建perl。</target>
        </trans-unit>
        <trans-unit id="eb8af118e1b3c0f503fae4e488d7355647e3de10" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that applications using Opcode should use a leading capital letter on their tag names since lowercase names are reserved for use by the Opcode module. If using Opcode within a module you should prefix your tags names with the name of your module to ensure uniqueness and thus avoid clashes with other modules.</source>
          <target state="translated">强烈建议使用Opcode的应用程序应该在他们的标签名上使用大写字母,因为小写字母的名字是保留给Opcode模块使用的。如果在一个模块中使用Opcode,您应该在您的标签名称前加上您的模块名称,以确保唯一性,从而避免与其他模块发生冲突。</target>
        </trans-unit>
        <trans-unit id="2739f66ac90ce9cc53c7717d098a81a175c0dbe7" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you enable threads via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; as early as possible in your script.</source>
          <target state="translated">强烈建议您在脚本中尽早通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 来启用线程。</target>
        </trans-unit>
        <trans-unit id="607d6dc00476120329bf70c7f37db42c62c363f4" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you enable threads via &lt;code&gt;use threads&lt;/code&gt; as early as possible in your script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23330295b88e2dfe22f823906399d30b69678a8c" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you use this flag when you run Configure. If you do not do this, but later answer the question about large files when Configure asks you, you may get a configuration that cannot be compiled, or that does not function as expected.</source>
          <target state="translated">强烈建议您在运行Configure时使用该标志。如果您不这样做,但后来在Configure询问您有关大文件的问题时回答了这个问题,您可能会得到一个无法编译的配置,或者无法按照预期的方式运行。</target>
        </trans-unit>
        <trans-unit id="d4398ad9975e0145dd25fc7bc9a7058eb6696304" translate="yes" xml:space="preserve">
          <source>It is suggested that you enable the version of malloc that is distributed with Perl. It keeps pools of various sizes of unallocated memory in order to satisfy allocation requests more quickly. However, on some platforms, it may cause spurious malloc or free errors.</source>
          <target state="translated">建议你启用随 Perl 发行的 malloc 版本。它保留了不同大小的未分配内存池,以便更快地满足分配请求。然而,在某些平台上,它可能会导致虚假的malloc或free错误。</target>
        </trans-unit>
        <trans-unit id="09d04d7278d56b78f672ffa08fd362fe3b4bb9cb" translate="yes" xml:space="preserve">
          <source>It is the appropriate method to use if you need to get the name of a lexical variable from a padname array. Lexical variable names are always stored with a null terminator, and the length field (CUR) is overloaded for other purposes and can't be relied on here.</source>
          <target state="translated">如果你需要从padname数组中获取一个词法变量的名称,那么这是一个合适的方法。词法变量的名称总是以null结束符存储,长度字段(CUR)因为其他目的而被重载,在这里不能依靠它。</target>
        </trans-unit>
        <trans-unit id="6f04d78fbcc86fbb7196577b1692934e2955d725" translate="yes" xml:space="preserve">
          <source>It is therefore strongly recommended that these macros be used by all XS modules that make use of static data.</source>
          <target state="translated">因此,强烈建议所有使用静态数据的XS模块都使用这些宏。</target>
        </trans-unit>
        <trans-unit id="6ddce18b6b5d6c4ef9a5cf7c34f05793b72112fd" translate="yes" xml:space="preserve">
          <source>It is typically used to add extra directories to perl's search path so that later &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statements will find modules which are not located on perl's default search path.</source>
          <target state="translated">它通常用于在perl的搜索路径中添加额外的目录，以便以后 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 语句将查找不在perl的默认搜索路径中的模块。</target>
        </trans-unit>
        <trans-unit id="231d3b33b22966aa08593496a49a29478f187fe4" translate="yes" xml:space="preserve">
          <source>It is typically used to add extra directories to perl's search path so that later &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statements will find modules which are not located on perl's default search path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fbfb42d30ce39230261b344f6acdd15e39f445" translate="yes" xml:space="preserve">
          <source>It is up to individual Pod formatter to display good judgement when confronted with an unrenderable character (which is distinct from an unknown E&amp;lt;thing&amp;gt; sequence that the parser couldn't resolve to anything, renderable or not). It is good practice to map Latin letters with diacritics (like &quot;E&amp;lt;eacute&amp;gt;&quot;/&quot;E&amp;lt;233&amp;gt;&quot;) to the corresponding unaccented US-ASCII letters (like a simple character 101, &quot;e&quot;), but clearly this is often not feasible, and an unrenderable character may be represented as &quot;?&quot;, or the like. In attempting a sane fallback (as from E&amp;lt;233&amp;gt; to &quot;e&quot;), Pod formatters may use the %Latin1Code_to_fallback table in &lt;a href=&quot;Pod::Escapes&quot;&gt;Pod::Escapes&lt;/a&gt;, or &lt;a href=&quot;Text::Unidecode&quot;&gt;Text::Unidecode&lt;/a&gt;, if available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7559da192e0561816f87fb94aa112a7e9ecc6d" translate="yes" xml:space="preserve">
          <source>It is up to individual Pod formatter to display good judgement when confronted with an unrenderable character (which is distinct from an unknown E&amp;lt;thing&amp;gt; sequence that the parser couldn't resolve to anything, renderable or not). It is good practice to map Latin letters with diacritics (like &quot;E&amp;lt;eacute&amp;gt;&quot;/&quot;E&amp;lt;233&amp;gt;&quot;) to the corresponding unaccented US-ASCII letters (like a simple character 101, &quot;e&quot;), but clearly this is often not feasible, and an unrenderable character may be represented as &quot;?&quot;, or the like. In attempting a sane fallback (as from E&amp;lt;233&amp;gt; to &quot;e&quot;), Pod formatters may use the %Latin1Code_to_fallback table in &lt;a href=&quot;pod/escapes&quot;&gt;Pod::Escapes&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Unidecode&quot;&gt;Text::Unidecode&lt;/a&gt;, if available.</source>
          <target state="translated">遇到无法渲染的字符（与解析器无法解析为任何东西（无论是否可渲染）的未知E &amp;lt;thing&amp;gt;序列不同）时，由个人Pod格式化程序显示良好的判断。将带有变音符号的拉丁字母（例如&amp;ldquo; E &amp;lt;eacute&amp;gt;&amp;rdquo; /&amp;ldquo; E &amp;lt;233&amp;gt;&amp;rdquo;）映射到相应的未重音US-ASCII字母（例如简单字符101，&amp;ldquo; e&amp;rdquo;）是一种很好的做法，但这显然是通常无法实现，并且不可呈现的字符可以表示为&amp;ldquo;？&amp;rdquo;等。在尝试进行合理的回退时（从E &amp;lt;233&amp;gt;到&amp;ldquo; e&amp;rdquo;），Pod格式化程序可以使用&lt;a href=&quot;pod/escapes&quot;&gt;Pod :: Escapes&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Unidecode&quot;&gt;Text :: Unidecode中&lt;/a&gt;的％Latin1Code_to_fallback表（如果有）。</target>
        </trans-unit>
        <trans-unit id="d3fe171c1e178608bc5f92e9c9efc16598ce4a39" translate="yes" xml:space="preserve">
          <source>It is up to you to use this information to populate</source>
          <target state="translated">您可以使用这些信息来填报</target>
        </trans-unit>
        <trans-unit id="ce530e54cb38df50f2b9795b42ad1b0802239f94" translate="yes" xml:space="preserve">
          <source>It is usual to pass parameters using global variables (typically $_ for one parameter, or $a and $b for two parameters) rather than via @_. (It is possible to use the @_ mechanism if you know what you're doing, though there is as yet no supported API for it. It's also inherently slower.)</source>
          <target state="translated">通常使用全局变量传递参数(通常$_代表一个参数,或者$a和$b代表两个参数),而不是通过@_。(如果你知道自己在做什么,也可以使用@_机制,尽管目前还没有支持的API。它本身也比较慢)。)</target>
        </trans-unit>
        <trans-unit id="91da970cd331ff859f8e77df6915a3ed4846b274" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;a href=&quot;#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#sleep-EXPR&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt; calls, because &lt;a href=&quot;#sleep-EXPR&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt; may be internally implemented on your system with &lt;a href=&quot;#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c5d14186ab57b1e0629e917b8215f824fb1b8c" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; may be internally implemented on your system with &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">混入 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 呼叫通常是一个错误，因为 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 可能是在系统内部使用 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 实施的。</target>
        </trans-unit>
        <trans-unit id="18d1691040dfd4fd0aeb2ca9801dad0c1249aa8e" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; may be internally implemented on your system with &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">混入 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 呼叫通常是一个错误，因为 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 可能是在系统内部使用 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 实施的。</target>
        </trans-unit>
        <trans-unit id="f94317c7d8a68b955ef8fad7379f1f684a3e243d" translate="yes" xml:space="preserve">
          <source>It is usually impossible to add new syntax to Perl without breaking some existing programs. This pragma provides a way to minimize that risk. New syntactic constructs, or new semantic meanings to older constructs, can be enabled by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'foo'&lt;/code&gt; , and will be parsed only when the appropriate feature pragma is in scope. (Nevertheless, the &lt;code&gt;CORE::&lt;/code&gt; prefix provides access to all Perl keywords, regardless of this pragma.)</source>
          <target state="translated">在不破坏某些现有程序的情况下，通常不可能向Perl添加新语法。这种实用性提供了一种将风险最小化的方法。可以通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'foo'&lt;/code&gt; 启用新的句法构造或旧构造的新语义，并且仅当适当的功能用法在范围内时才进行解析。（尽管如此，使用 &lt;code&gt;CORE::&lt;/code&gt; 前缀可以访问所有Perl关键字，而不管该编译指示如何。）</target>
        </trans-unit>
        <trans-unit id="0f612a30494cb1971874c3ee4fc77442da7514cc" translate="yes" xml:space="preserve">
          <source>It is usually impossible to add new syntax to Perl without breaking some existing programs. This pragma provides a way to minimize that risk. New syntactic constructs, or new semantic meanings to older constructs, can be enabled by &lt;code&gt;use feature 'foo'&lt;/code&gt;, and will be parsed only when the appropriate feature pragma is in scope. (Nevertheless, the &lt;code&gt;CORE::&lt;/code&gt; prefix provides access to all Perl keywords, regardless of this pragma.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8825373ed061df5a7897772f25e6f03f473b0a3c" translate="yes" xml:space="preserve">
          <source>It is very common to want to do encoding transformations when reading or writing files, network connections, pipes etc. If Perl is configured to use the new 'perlio' IO system then &lt;code&gt;Encode&lt;/code&gt; provides a &quot;layer&quot; (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;) which can transform data as it is read or written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60c64d5138091e34ac4e66a3176bc2904d419a6d" translate="yes" xml:space="preserve">
          <source>It is very common when filtering source to only want to apply the filter to the non-character-string parts of the code, or alternatively to</source>
          <target state="translated">在过滤源码时,通常只想将过滤器应用于代码中的非字符串部分,或者将其应用于</target>
        </trans-unit>
        <trans-unit id="7507ed7a14e59c863596321d293c86dd2f1471ac" translate="yes" xml:space="preserve">
          <source>It is very easy to dead-lock a process using this form of open(), or indeed with any use of pipe() with multiple subprocesses. The example above is &quot;safe&quot; because it is simple and calls exec(). See &lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;&quot;Avoiding Pipe Deadlocks&quot;&lt;/a&gt; for general safety principles, but there are extra gotchas with Safe Pipe Opens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df1696685d7983c694bb3c5409a0395bf0e003f" translate="yes" xml:space="preserve">
          <source>It is very easy to dead-lock a process using this form of open(), or indeed with any use of pipe() with multiple subprocesses. The example above is &quot;safe&quot; because it is simple and calls exec(). See &lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;Avoiding Pipe Deadlocks&lt;/a&gt; for general safety principles, but there are extra gotchas with Safe Pipe Opens.</source>
          <target state="translated">使用这种形式的open（）或完全不使用带有多个子进程的pipe（）来死锁一个进程非常容易。上面的示例很&amp;ldquo;安全&amp;rdquo;，因为它很简单，并调用exec（）。有关一般安全原则，请参阅&lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;避免管道死锁&lt;/a&gt;，但是安全管道打开还有其他陷阱。</target>
        </trans-unit>
        <trans-unit id="1f2733d85a83af59b86ea7ca3eeb7a8a21d68e5a" translate="yes" xml:space="preserve">
          <source>It is very easy to get tripped up using a mixture of other programs, external utilities, and Perl scripts that are in varying states of being able to handle case preservation. For example, a file created by an older version of an archive utility or a build utility such as MMK or MMS may generate a filename in all upper case even on an ODS-5 volume. If this filename is later retrieved by a Perl script or module in a case preserving environment, that upper case name may not match the mixed-case or lower-case expectations of the Perl code. Your best bet is to follow an all-or-nothing approach to case preservation: either don't use it at all, or make sure your entire toolchain and application environment support and use it.</source>
          <target state="translated">在使用其他程序、外部工具和Perl脚本时很容易被绊倒,因为这些程序在处理大小写方面的状态各不相同。例如,一个由旧版本的归档工具或诸如MMK或MMS等构建工具创建的文件,即使在ODS-5卷上也可能生成一个全大写的文件名。如果这个文件名后来被Perl脚本或模块在保全大小写的环境中检索到,那么这个大写的文件名可能不符合Perl代码的混合大写或小写的要求。你最好的选择是遵循一种全有或全无的方法来处理大小写保留:要么完全不使用它,要么确保你的整个工具链和应用环境都支持并使用它。</target>
        </trans-unit>
        <trans-unit id="1057ac1e814cd9a3566a8fed96cf94293953ec7a" translate="yes" xml:space="preserve">
          <source>It is very easy to recover the source of Perl programs. You simply feed the program to the perl interpreter and use the modules in the B:: hierarchy. The B::Deparse module should be able to defeat most attempts to hide source. Again, this is not unique to Perl.</source>
          <target state="translated">恢复Perl程序的源码非常容易。你只需将程序送入 perl 解释器并使用 B::层次结构中的模块。B::Deparse 模块应该能够击败大多数隐藏源代码的尝试。同样,这也不是Perl所独有的。</target>
        </trans-unit>
        <trans-unit id="d5b6f5cbb4ab2d2416457262d0018311cb6ac8d2" translate="yes" xml:space="preserve">
          <source>It is very possible that this document will fall far short of being useful to the casual reader. The reader is expected to understand the material in the first few sections of &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">该文档很有可能远远不够对临时读者有用。希望读者了解&lt;a href=&quot;../perlguts&quot;&gt;Perlguts&lt;/a&gt;的前几节中的内容。</target>
        </trans-unit>
        <trans-unit id="8bf9b3e35a922a415eaeb6feb2defbf0bc762198" translate="yes" xml:space="preserve">
          <source>It is very possible that this document will fall far short of being useful to the casual reader. The reader is expected to understand the material in the first few sections of &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055458523774899083238688c776d433516198d1" translate="yes" xml:space="preserve">
          <source>It is worth drawing particular attention to the expected ranges for the values provided. The value for the day of the month is the actual day (i.e. 1..31), while the month is the number of months since January (0..11). This is consistent with the values returned from &lt;code&gt;localtime()&lt;/code&gt; and &lt;code&gt;gmtime()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5424072f53b20136acc827f23a7b8403963d2596" translate="yes" xml:space="preserve">
          <source>It is worth drawing particular attention to the expected ranges for the values provided. The value for the day of the month is the actual day (ie 1..31), while the month is the number of months since January (0..11). This is consistent with the values returned from &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">值得特别注意所提供值的预期范围。月中某天的值是实际日期（即1..31），而月中该值是自一月以来的月数（0..11）。这与从 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 返回的值一致。</target>
        </trans-unit>
        <trans-unit id="c12cfe0a130e1abce3e789227eb445dc3d70c311" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , etc, match single characters, not complete numbers or words. To match a number (that consists of digits), use &lt;code&gt;\d+&lt;/code&gt; ; to match a word, use &lt;code&gt;\w+&lt;/code&gt; . But be aware of the security considerations in doing so, as mentioned above.</source>
          <target state="translated">值得强调的是 &lt;code&gt;\d&lt;/code&gt; ， &lt;code&gt;\w&lt;/code&gt; 等匹配单个字符，而不是完整的数字或单词。要匹配数字（由数字组成），请使用 &lt;code&gt;\d+&lt;/code&gt; ；要匹配单词，请使用 &lt;code&gt;\w+&lt;/code&gt; 。但是，如上所述，请注意这样做的安全性注意事项。</target>
        </trans-unit>
        <trans-unit id="113a0e58d547793b729e9fa965a701228f317998" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, etc, match single characters, not complete numbers or words. To match a number (that consists of digits), use &lt;code&gt;\d+&lt;/code&gt;; to match a word, use &lt;code&gt;\w+&lt;/code&gt;. But be aware of the security considerations in doing so, as mentioned above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ab6d3ec3a28b829b407073297587d950173f49" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;code&gt;\G&lt;/code&gt; improperly used can result in an infinite loop. Take care when using patterns that include &lt;code&gt;\G&lt;/code&gt; in an alternation.</source>
          <target state="translated">值得注意的是 &lt;code&gt;\G&lt;/code&gt; 使用不当会导致无限循环。使用交替包含 &lt;code&gt;\G&lt;/code&gt; 模式时要小心。</target>
        </trans-unit>
        <trans-unit id="db9514e6a01f9d85b4ef7b0e350a06b34e756aba" translate="yes" xml:space="preserve">
          <source>It is worth stressing that there are several different sets of digits in Unicode that are equivalent to 0-9 and are matchable by &lt;code&gt;\d&lt;/code&gt; in a regular expression. If they are used in a single language only, they are in that language's &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extension&lt;/code&gt; . If they are used in more than one script, they will be in &lt;code&gt;sc=Common&lt;/code&gt; , but only if they are used in many scripts should they be in &lt;code&gt;scx=Common&lt;/code&gt; .</source>
          <target state="translated">值得强调的是，Unicode中有几个不同的数字集，它们等效于0-9，并且可以在正则表达式中与 &lt;code&gt;\d&lt;/code&gt; 匹配。如果仅使用一种语言，则使用该语言的 &lt;code&gt;Script&lt;/code&gt; 和 &lt;code&gt;Script_Extension&lt;/code&gt; 。如果在多个脚本中使用它们，则它们将在 &lt;code&gt;sc=Common&lt;/code&gt; 中使用，但只有在许多脚本中使用它们时，才应在 &lt;code&gt;scx=Common&lt;/code&gt; 中使用它们。</target>
        </trans-unit>
        <trans-unit id="c0195b5ac1ee6ed9e15cca2ca1c3622950d2b3cb" translate="yes" xml:space="preserve">
          <source>It is worth stressing that there are several different sets of digits in Unicode that are equivalent to 0-9 and are matchable by &lt;code&gt;\d&lt;/code&gt; in a regular expression. If they are used in a single language only, they are in that language's &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extensions&lt;/code&gt;. If they are used in more than one script, they will be in &lt;code&gt;sc=Common&lt;/code&gt;, but only if they are used in many scripts should they be in &lt;code&gt;scx=Common&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb73a60f536c984fec748fd56250217ac857070f" translate="yes" xml:space="preserve">
          <source>It is, after all, just a guess. You should alway be explicit when it comes to encodings. But there are some, especially Japanese, environment that guess-coding is a must. Use this module with care.</source>
          <target state="translated">毕竟,这只是一个猜测。在编码的时候,你总是应该明确。但在某些环境下,尤其是日语,猜测编码是必须的。请谨慎使用这个模块。</target>
        </trans-unit>
        <trans-unit id="b1fd4c29544df6031e0c7f381c345fa955c2ddef" translate="yes" xml:space="preserve">
          <source>It is, however, very simple, pure Perl, and it has no non-core dependencies. It also provides a &quot;Moose-like&quot; API on demand for the features it supports.</source>
          <target state="translated">不过,它非常简单,是纯粹的Perl,而且它没有非核心的依赖。它还为它支持的功能提供了一个 &quot;类似于Moose &quot;的按需API。</target>
        </trans-unit>
        <trans-unit id="358ba9c90802ce677d93df629a1697c0599e5843" translate="yes" xml:space="preserve">
          <source>It isn't possible to create a true reference to an IO handle (filehandle or dirhandle) using the backslash operator. The most you can get is a reference to a typeglob, which is actually a complete symbol table entry. But see the explanation of the &lt;code&gt;*foo{THING}&lt;/code&gt; syntax below. However, you can still use type globs and globrefs as though they were IO handles.</source>
          <target state="translated">使用反斜杠运算符无法创建对IO句柄（文件句柄或dirhandle）的真实引用。您所能获得的最多是对typeglob的引用，它实际上是完整的符号表条目。但是请参阅下面的 &lt;code&gt;*foo{THING}&lt;/code&gt; 语法说明。但是，您仍然可以像使用IO句柄一样使用类型的globs和globrefs。</target>
        </trans-unit>
        <trans-unit id="be4ec9fbbf231e40204d7019d3f997c286ceaaf0" translate="yes" xml:space="preserve">
          <source>It lets by &lt;code&gt;$(...)&lt;/code&gt;.</source>
          <target state="translated">它可以让用 &lt;code&gt;$(...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1272cce995365257b29707c07e056e98c158a0d6" translate="yes" xml:space="preserve">
          <source>It may also be useful to create a batch file called lib.bat in C:\Program Files\Microsoft Visual C++ Toolkit 2003\bin containing:</source>
          <target state="translated">在C://Program Files/Microsoft Visual C++Toolkit 2003/bin中创建一个名为lib.bat的批处理文件也可能是有用的,其中包含。</target>
        </trans-unit>
        <trans-unit id="c3ee59300b49b89fa621ccf66f9ee189105bf2cd" translate="yes" xml:space="preserve">
          <source>It may also indicate a misspelled constant that has been interpreted as a bareword:</source>
          <target state="translated">它也可能表示一个拼写错误的常量,被解释为一个裸词。</target>
        </trans-unit>
        <trans-unit id="fb79d7ce93f65d8007a6c3362149cd125568d552" translate="yes" xml:space="preserve">
          <source>It may be common (for example at your main lexicon) that the hash keys and values coincide. Like that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d71937f4e01c4691f8ad6115319d1b1a1cc17dc" translate="yes" xml:space="preserve">
          <source>It may be handy to add a function or method to retrieve the number. Use the number in announcements and archive file names when releasing the module (ModuleName-1.02.tar.Z). See perldoc ExtUtils::MakeMaker.pm for details.</source>
          <target state="translated">添加一个函数或方法来检索这个数字可能会很方便。当发布模块时,在公告和归档文件名中使用这个编号(ModuleName-1.02.tar.Z)。详情请参见 perldoc ExtUtils::MakeMaker.pm。</target>
        </trans-unit>
        <trans-unit id="4aba7fcd954a7d79c58b4c5db5fcca156f49cb64" translate="yes" xml:space="preserve">
          <source>It may be helpful to always use the forked debugger so that script I/O is separated from debugger I/O. You can force the debugger to be forked by assigning a value to the logical name &amp;lt;PERLDB_PIDS&amp;gt; that is not a process identification number.</source>
          <target state="translated">始终使用叉式调试器可能会有所帮助，以便将脚本I / O与调试器I / O分开。您可以通过为逻辑名称&amp;lt;PERLDB_PIDS&amp;gt;分配一个值而不是进程标识号来强制调试器派生。</target>
        </trans-unit>
        <trans-unit id="c878552ffbfe93e8fcd546e6ba5f54b617695a5d" translate="yes" xml:space="preserve">
          <source>It may be more portable to use the &lt;a href=&quot;File::Copy&quot;&gt;File::Copy&lt;/a&gt; module instead. You just copy to the new file to the new name (checking return values), then delete the old one. This isn't really the same semantically as a &lt;code&gt;rename()&lt;/code&gt;, which preserves meta-information like permissions, timestamps, inode info, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf5a525be6e13a9a7b1dd1dbd184cb474cd50ab" translate="yes" xml:space="preserve">
          <source>It may be more portable to use the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module instead. You just copy to the new file to the new name (checking return values), then delete the old one. This isn't really the same semantically as a &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt;, which preserves meta-information like permissions, timestamps, inode info, etc.</source>
          <target state="translated">改为使用&lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt;模块更可移植。您只需将新文件复制到新名称（检查返回值），然后删除旧文件即可。从语义 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; ，这与rename（）并不完全相同，rename（）保留诸如权限，时间戳，inode信息等元信息。</target>
        </trans-unit>
        <trans-unit id="db6d5d1cd198cf53911efce9b9d95d5989e30fc0" translate="yes" xml:space="preserve">
          <source>It may be possible to code a simple workaround which would</source>
          <target state="translated">也许可以编写一个简单的变通方法,这样就可以做到</target>
        </trans-unit>
        <trans-unit id="2d1547ff72328148f73028b4bf53e65cca15e95b" translate="yes" xml:space="preserve">
          <source>It may be possible to use the Entropy Gathering Daemon (written in Perl!), available from &lt;a href=&quot;http://www.lothar.com/tech/crypto/&quot;&gt;http://www.lothar.com/tech/crypto/&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;http://www.lothar.com/tech/crypto/&quot;&gt;http://www.lothar.com/tech/crypto/上&lt;/a&gt;的Entropy Gathering Daemon（用Perl！编写）。</target>
        </trans-unit>
        <trans-unit id="ea7e33e821e865ae246a0ffae0bdba930182de6b" translate="yes" xml:space="preserve">
          <source>It may seem obvious to say, but Perl is useful only when users can easily find it. When possible, it's good for both</source>
          <target state="translated">说起来似乎很明显,但Perl只有在用户能很容易找到它的时候才有用。在可能的情况下,它对以下两方面都有好处</target>
        </trans-unit>
        <trans-unit id="fd3430c5befbd819886aa0fff01863d985392126" translate="yes" xml:space="preserve">
          <source>It might conceivably chdir() you out of a directory that it can't chdir() you back into. If fastcwd encounters a problem it will return undef but will probably leave you in a different directory. For a measure of extra security, if everything appears to have worked, the fastcwd() function will check that it leaves you in the same directory that it started in. If it has changed it will &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with the message &quot;Unstable directory path, current directory changed unexpectedly&quot;. That should never happen.</source>
          <target state="translated">可以想象，它会将您chdir（）移出无法chdir（）的目录。如果fastcwd遇到问题，它将返回undef，但可能会将您留在其他目录中。为了提高安全性，如果一切正常，fastcwd（）函数将检查是否将您留在了开始时所在的目录中。如果更改，它将 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 消息&amp;ldquo;不稳定的目录路径，当前目录意外更改&amp;rdquo;。那永远不会发生。</target>
        </trans-unit>
        <trans-unit id="6269f7c0874b90d11b774dcb29c6ab77d94be05c" translate="yes" xml:space="preserve">
          <source>It might conceivably chdir() you out of a directory that it can't chdir() you back into. If fastcwd encounters a problem it will return undef but will probably leave you in a different directory. For a measure of extra security, if everything appears to have worked, the fastcwd() function will check that it leaves you in the same directory that it started in. If it has changed it will &lt;code&gt;die&lt;/code&gt; with the message &quot;Unstable directory path, current directory changed unexpectedly&quot;. That should never happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a597e04d91d3290c6b9fa9abe20a400d22f03ff" translate="yes" xml:space="preserve">
          <source>It might seem possible eliminate slab reference counts altogether, by having all ops implicitly attached to &lt;code&gt;PL_compcv&lt;/code&gt; when allocated and freed when the CV is freed. That would also allow &lt;code&gt;op_free&lt;/code&gt; to skip &lt;code&gt;FreeOp&lt;/code&gt; altogether, and thus free ops faster. But that doesn't work in those cases where ops need to survive beyond their CVs, such as re-evals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642edf6b6e0c22a6bf4368f6631f6fe45a077e55" translate="yes" xml:space="preserve">
          <source>It monkeypatches Test::Builder, and calls it &quot;black magic&quot; in the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="106694ead18b1135cc07d2ae597d50b20a4d8af6" translate="yes" xml:space="preserve">
          <source>It must be stressed that the DynaLoader, by itself, is practically useless for accessing non-Perl libraries because it provides almost no Perl-to-C 'glue'. There is, for example, no mechanism for calling a C library function or supplying arguments. A C::DynaLib module is available from CPAN sites which performs that function for some common system types. And since the year 2000, there's also Inline::C, a module that allows you to write Perl subroutines in C. Also available from your local CPAN site.</source>
          <target state="translated">必须强调的是,DynaLoader本身在访问非Perl库时实际上是无用的,因为它几乎没有提供Perl到C库的 &quot;胶合&quot;。例如,没有调用C库函数或提供参数的机制。在CPAN网站上有一个C::DynaLib模块,它可以为一些常见的系统类型执行该功能。自 2000 年以来,还有 Inline::C,一个允许你用 C 写 Perl 子程序的模块,也可以从本地 CPAN 站点获得。</target>
        </trans-unit>
        <trans-unit id="8bc1cb6024aa942bd48b262d31d7cf7f97b8a25f" translate="yes" xml:space="preserve">
          <source>It occurs to you that this is not the prettiest code you've ever written, but this seems the way to go. You mail off to the translators asking for translations for these four cases. The Chinese guy replies with the one phrase that these all translate to in Chinese, and that phrase has two &quot;%g&quot;s in it, as it should -- but there's a problem. He translates it word-for-word back: &quot;In %g directories contains %g files match your query.&quot; The %g slots are in an order reverse to what they are in English. You wonder how you'll get gettext to handle that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04aa081b59ff3888239972218e3f56b3b6581f1f" translate="yes" xml:space="preserve">
          <source>It particular, it's important to &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize $_ in any routine that assigns to it. Look out for implicit assignments in &lt;code&gt;while&lt;/code&gt; conditionals.</source>
          <target state="translated">尤其重要的是，在分配给它的任何例程中 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; $ _。在 &lt;code&gt;while&lt;/code&gt; 条件中查找隐式赋值。</target>
        </trans-unit>
        <trans-unit id="e9fad7940bb559b8eb57657aa029f3c734e1bf6b" translate="yes" xml:space="preserve">
          <source>It particular, it's important to &lt;code&gt;local&lt;/code&gt;ize $_ in any routine that assigns to it. Look out for implicit assignments in &lt;code&gt;while&lt;/code&gt; conditionals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd14db27f979e38e1e8d4c1576f9b693597877fa" translate="yes" xml:space="preserve">
          <source>It performs the following actions:</source>
          <target state="translated">它执行以下行动:</target>
        </trans-unit>
        <trans-unit id="3a77cf9922a9fef0374667dd7650f3414798d318" translate="yes" xml:space="preserve">
          <source>It prints (without so many line breaks)</source>
          <target state="translated">它可以打印(没有那么多换行符)。</target>
        </trans-unit>
        <trans-unit id="f4bd0cc34b746267dc944192fe3c01787ec4e363" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder since print calls &lt;code&gt;bdiv()&lt;/code&gt; in list context. Also, &lt;code&gt;bdiv()&lt;/code&gt; will modify $c, so be careful. You probably want to use</source>
          <target state="translated">因为print 在列表上下文中调用 &lt;code&gt;bdiv()&lt;/code&gt; ，所以它同时打印商和余数。另外， &lt;code&gt;bdiv()&lt;/code&gt; 会修改$ c，因此要小心。您可能要使用</target>
        </trans-unit>
        <trans-unit id="eeeedb6aa3743486c6e5b956ff78abba71960946" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder since print works in list context. Also, bdiv() will modify $c, so be careful. You probably want to use</source>
          <target state="translated">它同时打印商和余数,因为print在列表上下文中工作。另外,bdiv()会修改 $c,所以要小心。你可能想使用</target>
        </trans-unit>
        <trans-unit id="f734db0d61221ca40b0fe2bebce3caa4e0b18089" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder, since print calls &lt;code&gt;brsft()&lt;/code&gt; in list context. Also, &lt;code&gt;$c-&amp;gt;brsft()&lt;/code&gt; will modify $c, so be careful. You probably want to use</source>
          <target state="translated">因为print 在列表上下文中调用 &lt;code&gt;brsft()&lt;/code&gt; ，所以它同时打印商和余数。另外， &lt;code&gt;$c-&amp;gt;brsft()&lt;/code&gt; 会修改$ c，因此要小心。您可能要使用</target>
        </trans-unit>
        <trans-unit id="ce7853179bda4d7415dfcdbc4fb24a48d915ca39" translate="yes" xml:space="preserve">
          <source>It prints both the number of digits in the number and in the fraction part since print calls &lt;code&gt;&lt;a href=&quot;../functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; in list context. Use something like:</source>
          <target state="translated">因为print 在列表上下文中调用 &lt;code&gt;&lt;a href=&quot;../functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; ，所以它同时打印数字和小数部分中的数字。使用类似：</target>
        </trans-unit>
        <trans-unit id="ae3e52e7991a13cb3327228cb99597bd25c0f239" translate="yes" xml:space="preserve">
          <source>It prints both the number of digits in the number and in the fraction part since print calls &lt;code&gt;length()&lt;/code&gt; in list context. Use something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29cdbd5e538c2f505e08e3d1eef02e06fd63d99d" translate="yes" xml:space="preserve">
          <source>It prints the sequence number of each subroutine call and the name of the called subroutine. Note that &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is being compiled into the package &lt;code&gt;DB&lt;/code&gt; through the use of the &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">它打印每个子例程调用的序列号和被调用子例程的名称。请注意，正在通过使用 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 指令将 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 编译到Package &lt;code&gt;DB&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="9851cbd8d563f766b9710d226d03fcd351760c96" translate="yes" xml:space="preserve">
          <source>It prints the sequence number of each subroutine call and the name of the called subroutine. Note that &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is being compiled into the package &lt;code&gt;DB&lt;/code&gt; through the use of the &lt;code&gt;package&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc0745e2373dd8461369aabf029a5713236cbd6" translate="yes" xml:space="preserve">
          <source>It properly handles the locale radix character, meaning it expects a dot except when called from within the scope of &lt;code&gt;use locale&lt;/code&gt;, in which case the radix character should be that specified by the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb15b033b8c4d79b1e008f6b581eebb8e9cf4d5" translate="yes" xml:space="preserve">
          <source>It provides a number of mechanisms for querying this information.</source>
          <target state="translated">它提供了一些查询这些信息的机制。</target>
        </trans-unit>
        <trans-unit id="b8c1724bc25d41f7c44c94651a6709f709b79e5f" translate="yes" xml:space="preserve">
          <source>It provides default implementations for the methods</source>
          <target state="translated">它提供了以下方法的默认实现</target>
        </trans-unit>
        <trans-unit id="991237cf5d3fbec5f0d4f7d308f07d6c33c5c843" translate="yes" xml:space="preserve">
          <source>It rarely happens, but sometimes a harness might encounter 'missing tests:</source>
          <target state="translated">这种情况很少发生,但有时线束可能会遇到 &quot;漏测&quot;。</target>
        </trans-unit>
        <trans-unit id="58b94065e144f3ae0a0ee1916ab6d2ce54ccb558" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property Comp_Ex (Full_Composition_Exclusion). This property is generated from Composition Exclusions + Singletons + Non-Starter Decompositions.</source>
          <target state="translated">它返回派生属性Comp_Ex (Full_Composition_Exclusion)的布尔值。这个属性是由组成排除+单子+非启动分解生成的。</target>
        </trans-unit>
        <trans-unit id="2104ee6f115c01f93c99709b67d509e11442417d" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFC_MAYBE (NFC_Quick_Check=Maybe).</source>
          <target state="translated">它返回派生属性NFC_MAYBE(NFC_Quick_Check=Maybe)的布尔值。</target>
        </trans-unit>
        <trans-unit id="8eddd31c0562defd83827f48a88a17884adf60ac" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFC_NO (NFC_Quick_Check=No).</source>
          <target state="translated">它返回派生属性NFC_NO (NFC_Quick_Check=No)的布尔值。</target>
        </trans-unit>
        <trans-unit id="5a5415660523b78bb56fd5e9c17b5e348185ce86" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFD_NO (NFD_Quick_Check=No).</source>
          <target state="translated">它返回派生属性NFD_NO (NFD_Quick_Check=No)的布尔值。</target>
        </trans-unit>
        <trans-unit id="670fe547c9b7a29b855ab5f7d41534d43d1e9f4c" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKC_MAYBE (NFKC_Quick_Check=Maybe).</source>
          <target state="translated">它返回派生属性NFKC_MAYBE (NFKC_Quick_Check=Maybe)的布尔值。</target>
        </trans-unit>
        <trans-unit id="904cbf02d71113df93de970071185a11138630e4" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKC_NO (NFKC_Quick_Check=No).</source>
          <target state="translated">它返回派生属性NFKC_NO (NFKC_Quick_Check=No)的布尔值。</target>
        </trans-unit>
        <trans-unit id="829ea5ef8a5200c844ee7c02042a32bc63c04771" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKD_NO (NFKD_Quick_Check=No).</source>
          <target state="translated">它返回派生属性NFKD_NO(NFKD_Quick_Check=No)的布尔值。</target>
        </trans-unit>
        <trans-unit id="8784205d909df0b9a984780fc90733905a3103a1" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the character of the specified codepoint may be composed with the previous one in a certain composition (including Hangul Compositions, but excluding Composition Exclusions and Non-Starter Decompositions).</source>
          <target state="translated">它返回一个布尔值,表示在某种构图(包括汉字构图,但不包括构图排除和非起始分解)中,指定码点的字符是否可以与前一个码点进行构图。</target>
        </trans-unit>
        <trans-unit id="32fdbc7eddb18b1a419ce2d35092783f07d4af22" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point has Non-Starter Decomposition.</source>
          <target state="translated">它返回代码点是否具有非启动分解的布尔值。</target>
        </trans-unit>
        <trans-unit id="05cafc23e99e3bc76eb241d5b7b7627390e2da71" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point is a composition exclusion.</source>
          <target state="translated">它返回一个布尔值,是否该代码点是一个组成排除。</target>
        </trans-unit>
        <trans-unit id="53705043824b274a980c94b9c5b624aa7db18ac7" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point is a singleton</source>
          <target state="translated">它返回一个布尔值,即该代码点是否是一个单体。</target>
        </trans-unit>
        <trans-unit id="3bdd6ab415e1d7803474768a9f82c375da3c7e8f" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$Bzip2Error&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功返回 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 对象，失败返回undef。变量 &lt;code&gt;$Bzip2Error&lt;/code&gt; 将包含有关失败的错误消息。</target>
        </trans-unit>
        <trans-unit id="7b202b09f5eedc56f3eae8328563e18bb8bb267b" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$DeflateError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功时返回 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 对象，失败时返回undef。变量 &lt;code&gt;$DeflateError&lt;/code&gt; 将包含有关失败的错误消息。</target>
        </trans-unit>
        <trans-unit id="0d7bf22968af56755cc48cf3e5eb1866df93fb4a" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$GzipError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功返回 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 对象，失败返回undef。变量 &lt;code&gt;$GzipError&lt;/code&gt; 将包含有关失败的错误消息。</target>
        </trans-unit>
        <trans-unit id="e02c10ad441b5cb12d98ff7ac04d2bec29b76002" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$RawDeflateError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功时返回 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 对象，失败时返回undef。变量 &lt;code&gt;$RawDeflateError&lt;/code&gt; 将包含有关失败的错误消息。</target>
        </trans-unit>
        <trans-unit id="733e2aec8845350fd889ee56ce6b2b1905e8c50e" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Zip&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$ZipError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功返回 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 对象，失败返回undef。变量 &lt;code&gt;$ZipError&lt;/code&gt; 将包含有关失败的错误消息。</target>
        </trans-unit>
        <trans-unit id="55f5b32339878811a57c6c9adb8fddab3c155d6c" translate="yes" xml:space="preserve">
          <source>It returns an array of four or five scalar values: EXTRALIBS, BSLOADLIBS, LDLOADLIBS, LD_RUN_PATH, and, optionally, a reference to the array of the filenames of actual libraries. Some of these don't mean anything unless on Unix. See the details about those platform specifics below. The list of the filenames is returned only if $need_names argument is true.</source>
          <target state="translated">它返回一个由四个或五个标量值组成的数组。EXTRALIBS,BSLOADLIBS,LDLOADLIBS,LD_RUN_PATH,以及一个对实际库的文件名数组的引用。其中一些除非在Unix上,否则没有任何意义。请看下面关于这些平台的细节。只有当$need_names参数为true时,才会返回文件名列表。</target>
        </trans-unit>
        <trans-unit id="1b60723356123e31c4f819b7b57959bd345247e2" translate="yes" xml:space="preserve">
          <source>It returns falls if &lt;code&gt;PACKAGE&lt;/code&gt; has not been loaded yet and the location from where it is said to be loaded on success.</source>
          <target state="translated">如果尚未装入 &lt;code&gt;PACKAGE&lt;/code&gt; ，则返回跌落；如果成功装入PACKAGE，则返回该位置。</target>
        </trans-unit>
        <trans-unit id="ab042aac65d23a49c795444acd76a148a334187c" translate="yes" xml:space="preserve">
          <source>It returns the FCC form (&quot;Fast C Contiguous&quot;; cf. UTN #5).</source>
          <target state="translated">它返回FCC表格(&quot;Fast C Contiguous&quot;;参见UTN #5)。</target>
        </trans-unit>
        <trans-unit id="a80e6baf3c3b2c9535a05b4bf410d7b9c5dde971" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form C (formed by canonical decomposition followed by canonical composition).</source>
          <target state="translated">它返回归一化形式C(由规范分解后再由规范组成)。</target>
        </trans-unit>
        <trans-unit id="a2c5e52810047ee1962e46371ac68fc8dc9054e8" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form D (formed by canonical decomposition).</source>
          <target state="translated">它返回归一化形式D(由规范分解形成)。</target>
        </trans-unit>
        <trans-unit id="1383c6449aad07f7997fc3ec42b0ae3c98ca4a0b" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form KC (formed by compatibility decomposition followed by &lt;b&gt;canonical&lt;/b&gt; composition).</source>
          <target state="translated">它返回规范化形式KC（由兼容性分解和&lt;b&gt;规范&lt;/b&gt;组成组成）。</target>
        </trans-unit>
        <trans-unit id="1d675fdcf5ef1f2056866497e81d752934809791" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form KD (formed by compatibility decomposition).</source>
          <target state="translated">它返回归一化形式KD(由兼容性分解形成)。</target>
        </trans-unit>
        <trans-unit id="4b300118aa94b87649f21e9834526f64818158d8" translate="yes" xml:space="preserve">
          <source>It returns the combining class (as an integer) of the character.</source>
          <target state="translated">它返回字符的组合类(为整数)。</target>
        </trans-unit>
        <trans-unit id="eb22d3dace2d05fa601426312363eea62fa0226b" translate="yes" xml:space="preserve">
          <source>It returns the concatenation of the decomposition of each character in the string.</source>
          <target state="translated">它返回字符串中每个字符的分解连接。</target>
        </trans-unit>
        <trans-unit id="8a852534b28496d947f4c8e100a132748793361d" translate="yes" xml:space="preserve">
          <source>It returns the normalization form of &lt;code&gt;$form_name&lt;/code&gt; .</source>
          <target state="translated">它返回 &lt;code&gt;$form_name&lt;/code&gt; 的规范化形式。</target>
        </trans-unit>
        <trans-unit id="bf3cd095961560034a7b6b2b8569541880d86696" translate="yes" xml:space="preserve">
          <source>It returns the normalization form of &lt;code&gt;$form_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b49fbb316b9278a17d532265fe4cd4e754492934" translate="yes" xml:space="preserve">
          <source>It returns the remainder &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; , where &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; . The &lt;code&gt;$r&lt;/code&gt; has the same sign as &lt;code&gt;$x&lt;/code&gt; and magnitude (absolute value) less than the magnitude of &lt;code&gt;$y&lt;/code&gt; .</source>
          <target state="translated">它返回其余的 &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; ，其中 &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; 。该 &lt;code&gt;$r&lt;/code&gt; 具有相同的符号为 &lt;code&gt;$x&lt;/code&gt; 和大小（绝对值）小于幅度 &lt;code&gt;$y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b96df5a323ccde59c4604283479ada0f880ece8b" translate="yes" xml:space="preserve">
          <source>It returns the remainder &lt;code&gt;$r = $x - $n*$y&lt;/code&gt;, where &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt;. The &lt;code&gt;$r&lt;/code&gt; has the same sign as &lt;code&gt;$x&lt;/code&gt; and magnitude (absolute value) less than the magnitude of &lt;code&gt;$y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837e320b920fba38b4782fb970e5ba4d1738747b" translate="yes" xml:space="preserve">
          <source>It returns the result of canonical composition without applying any decomposition.</source>
          <target state="translated">它在不应用任何分解的情况下返回规范合成的结果。</target>
        </trans-unit>
        <trans-unit id="97c8ed595d7942de577ac5b60184bc3e70b57d00" translate="yes" xml:space="preserve">
          <source>It returns the result of reordering the combining characters according to Canonical Ordering Behavior.</source>
          <target state="translated">它返回根据 Canonical Ordering Behavior 对合并字符重新排序的结果。</target>
        </trans-unit>
        <trans-unit id="0c7818f52644428114d7169367d50f2b1f7b0307" translate="yes" xml:space="preserve">
          <source>It returns the same values as run_tests, so you can further examine the test results if you need to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e13862ba07278e0519e9e4b0230517dc0328cb" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt; ) if &lt;code&gt;YES&lt;/code&gt; ; false (&lt;code&gt;empty string&lt;/code&gt; ) if &lt;code&gt;NO&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;YES&lt;/code&gt; ，则返回true（ &lt;code&gt;1&lt;/code&gt; ）; 如果为 &lt;code&gt;NO&lt;/code&gt; ,则返回false（ &lt;code&gt;empty string&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b1aae34c500721c408b0788928293058d1fef3fa" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt; ) if &lt;code&gt;YES&lt;/code&gt; ; false (&lt;code&gt;empty string&lt;/code&gt; ) if &lt;code&gt;NO&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;MAYBE&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;YES&lt;/code&gt; ，则返回true（ &lt;code&gt;1&lt;/code&gt; ）; 如果为 &lt;code&gt;NO&lt;/code&gt; ，则返回false（ &lt;code&gt;empty string&lt;/code&gt; ）。如果 &lt;code&gt;MAYBE&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e07cc039b9bc283952fe2e0a04d4a341d590f3e7" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt;) if &lt;code&gt;YES&lt;/code&gt;; false (&lt;code&gt;empty string&lt;/code&gt;) if &lt;code&gt;NO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00917cf3a6843e18b27b643db79b6a4b69a6e3c" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt;) if &lt;code&gt;YES&lt;/code&gt;; false (&lt;code&gt;empty string&lt;/code&gt;) if &lt;code&gt;NO&lt;/code&gt;; &lt;code&gt;undef&lt;/code&gt; if &lt;code&gt;MAYBE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a729a5529269a29252f3c2bf2eddc2d7ae807d5" translate="yes" xml:space="preserve">
          <source>It returns true if everything was ok. Otherwise it will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; with one of the messages in the DIAGNOSTICS section.</source>
          <target state="translated">如果一切正常，则返回true。否则，它将与DIAGNOSTICS部分中的消息之一一起 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7671ee7cfbfe57f504b6685d32d40a2c22391d50" translate="yes" xml:space="preserve">
          <source>It returns true if everything was ok. Otherwise it will &lt;code&gt;die()&lt;/code&gt; with one of the messages in the DIAGNOSTICS section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714b64110a6e486db425b221e1f3c962f9afdc59" translate="yes" xml:space="preserve">
          <source>It returns true if the key matched the criteria, or false otherwise.</source>
          <target state="translated">如果键符合标准,则返回true,否则返回false。</target>
        </trans-unit>
        <trans-unit id="cdfcc78500cdaa84a66edd629ca6a9d6469e030b" translate="yes" xml:space="preserve">
          <source>It returns two strings: the first one, &lt;code&gt;$processed&lt;/code&gt; , is a part before the last starter, and the second one, &lt;code&gt;$unprocessed&lt;/code&gt; is another part after the first part. A starter is a character having a combining class of zero (see UAX #15).</source>
          <target state="translated">它返回两个字符串：第一个字符串 &lt;code&gt;$processed&lt;/code&gt; 是最后一个启动器之前的一部分，第二个字符串 &lt;code&gt;$unprocessed&lt;/code&gt; 是第一个部分之后的另一部分。起动器是一个组合类别为零的字符（请参阅UAX＃15）。</target>
        </trans-unit>
        <trans-unit id="bcda37fdc9f0662d168c30c5cdca4733a8dcb549" translate="yes" xml:space="preserve">
          <source>It returns two strings: the first one, &lt;code&gt;$processed&lt;/code&gt;, is a part before the last starter, and the second one, &lt;code&gt;$unprocessed&lt;/code&gt; is another part after the first part. A starter is a character having a combining class of zero (see UAX #15).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d95a08ad814a7f6c58669c1b1316d305c90d5a" translate="yes" xml:space="preserve">
          <source>It sets up a class &lt;code&gt;Name&lt;/code&gt; that is a mirror of one of the implementation classes &lt;code&gt;Name_hash&lt;/code&gt; , &lt;code&gt;Name_id&lt;/code&gt; , ..., &lt;code&gt;Name_fieldhash&lt;/code&gt; . That determines which implementation is run.</source>
          <target state="translated">它设置了一个 &lt;code&gt;Name&lt;/code&gt; 类，它是实现类 &lt;code&gt;Name_hash&lt;/code&gt; ， &lt;code&gt;Name_id&lt;/code&gt; ，...， &lt;code&gt;Name_fieldhash&lt;/code&gt; 之一的镜像。那确定运行哪个实现。</target>
        </trans-unit>
        <trans-unit id="9e5fad0504d022f42c88d249188952052fecb50c" translate="yes" xml:space="preserve">
          <source>It sets up a class &lt;code&gt;Name&lt;/code&gt; that is a mirror of one of the implementation classes &lt;code&gt;Name_hash&lt;/code&gt;, &lt;code&gt;Name_id&lt;/code&gt;, ..., &lt;code&gt;Name_fieldhash&lt;/code&gt;. That determines which implementation is run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3f907f4536c2412455577e73bc09c598212b95" translate="yes" xml:space="preserve">
          <source>It should be noted that because of the double indirection in a &lt;code&gt;PerlIO *&lt;/code&gt; , a &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &quot;is&quot; a &lt;code&gt;PerlIO *&lt;/code&gt; , and so to some degree at least one layer can use the &quot;standard&quot; API on the next layer down.</source>
          <target state="translated">应该注意的是，由于 &lt;code&gt;PerlIO *&lt;/code&gt; 中的双重间接访问， &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &amp;ldquo;是&amp;rdquo; &lt;code&gt;PerlIO *&lt;/code&gt; ，因此在某种程度上至少一层可以在下一层使用&amp;ldquo;标准&amp;rdquo; API下。</target>
        </trans-unit>
        <trans-unit id="c7a2a8bb586f925da0807a643800b85b4622cd20" translate="yes" xml:space="preserve">
          <source>It should be noted that because of the double indirection in a &lt;code&gt;PerlIO *&lt;/code&gt;, a &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &quot;is&quot; a &lt;code&gt;PerlIO *&lt;/code&gt;, and so to some degree at least one layer can use the &quot;standard&quot; API on the next layer down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14a8d613d8259f6f9199d94a881c7c7dcdcf9aa" translate="yes" xml:space="preserve">
          <source>It should be noted that the</source>
          <target state="translated">应该指出的是</target>
        </trans-unit>
        <trans-unit id="a59ebc15941a0d3262901c5719fbfc123fcebf0b" translate="yes" xml:space="preserve">
          <source>It splits the task of generating the Makefile into several subroutines that can be individually overridden. Each subroutine returns the text it wishes to have written to the Makefile.</source>
          <target state="translated">它将生成 Makefile 的任务分割成几个可以单独重写的子程序。每个子程序都返回它希望写入 Makefile 的文本。</target>
        </trans-unit>
        <trans-unit id="82c9f4b13f690f80567f90ba2a27e3429f909ad9" translate="yes" xml:space="preserve">
          <source>It starts like a perl module with a package declaration and a $VERSION variable. After that the pod section looks like any other pod with the only difference being that</source>
          <target state="translated">它的开始就像一个perl模块,有一个包声明和一个$VERSION变量。之后,pod部分看起来就像其他pod一样,唯一的区别就是</target>
        </trans-unit>
        <trans-unit id="20eae6f6b825ab7ac7ea22eebe86fa7977d3df1a" translate="yes" xml:space="preserve">
          <source>It supports the following options, which are explained in &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt;: alt, indent, loose, quotes, sentence, width</source>
          <target state="translated">它支持以下选项，在&lt;a href=&quot;../text&quot;&gt;Pod :: Text中&lt;/a&gt;进行了说明：alt，缩进，松散，引号，句子，宽度</target>
        </trans-unit>
        <trans-unit id="510b7b9b3f742ecce372251df0c084238337e534" translate="yes" xml:space="preserve">
          <source>It supports the following options, which are explained in &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt;: alt, indent, loose, quotes, sentence, width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41aba7727d2b065747551c63f609a3ed9ed9ee45" translate="yes" xml:space="preserve">
          <source>It suppresses duplicates in the column &lt;code&gt;in CPAN file&lt;/code&gt; such that distributions with many upgradeable modules are listed only once.</source>
          <target state="translated">它抑制 &lt;code&gt;in CPAN file&lt;/code&gt; 列中的重复项，因此具有许多可升级模块的发行版仅列出一次。</target>
        </trans-unit>
        <trans-unit id="408685ef311dbc3599ddc558bce5925c12aacf23" translate="yes" xml:space="preserve">
          <source>It takes a Win32 native file handle and returns the size in bytes. Since the size can be a 64 bit value, on non 64 bit integer Perls the value returned will be an object of type &lt;code&gt;Math::BigInt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a26945a658df9dae641582923dd3754dc6d274" translate="yes" xml:space="preserve">
          <source>It takes a hash reference as an argument with two optional keys:</source>
          <target state="translated">它以一个哈希引用作为参数,并带有两个可选的键。</target>
        </trans-unit>
        <trans-unit id="b5a427be1727dabad24c941b3ce2ddc132315b17" translate="yes" xml:space="preserve">
          <source>It takes an optional hashref of options. Valid options include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0a17fd215b480661caff5f818c6d1a010f9c4c" translate="yes" xml:space="preserve">
          <source>It takes the same options as &lt;code&gt;new()&lt;/code&gt; but &lt;code&gt;lazy_validation&lt;/code&gt; defaults to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e1dcd4bfabeba9ef57034858eb07de6c007a236" translate="yes" xml:space="preserve">
          <source>It takes three arguments:</source>
          <target state="translated">它需要三个论点。</target>
        </trans-unit>
        <trans-unit id="a46a1b8abd0b80e91377ad517ddde11f2ad6f67d" translate="yes" xml:space="preserve">
          <source>It tells where the old configuration file was found (if found).</source>
          <target state="translated">它告诉我们旧配置文件的位置(如果找到的话)。</target>
        </trans-unit>
        <trans-unit id="316a78b3112e7d60b8f4b8e53c96f0951d499e19" translate="yes" xml:space="preserve">
          <source>It turns out that you can actually do this also:</source>
          <target state="translated">原来,你其实也可以这样做。</target>
        </trans-unit>
        <trans-unit id="674b7a92bd3974a32a6e0bc4ddce519662bb5c8a" translate="yes" xml:space="preserve">
          <source>It used to be legal to use &lt;code&gt;open()&lt;/code&gt; to associate both a filehandle and a dirhandle to the same symbol (glob or scalar). This idiom is likely to be confusing, and it was deprecated in Perl 5.10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c73ad695b4941117c2fa5c1a0fa146666ac448c3" translate="yes" xml:space="preserve">
          <source>It used to be possible to use &lt;code&gt;tie&lt;/code&gt;, &lt;code&gt;tied&lt;/code&gt; or &lt;code&gt;untie&lt;/code&gt; on a scalar while the scalar holds a typeglob. This caused its filehandle to be tied. It left no way to tie the scalar itself when it held a typeglob, and no way to untie a scalar that had had a typeglob assigned to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dce3c39f57e7aba5158e57e9f8e31a1b80c94a8" translate="yes" xml:space="preserve">
          <source>It used to hold the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59c80ea628e681a66374b04e2b703dd5af8c0f4" translate="yes" xml:space="preserve">
          <source>It uses the &lt;code&gt;getaddrinfo(3)&lt;/code&gt; function to convert hostnames and service names or port numbers into sets of possible addresses to connect to or listen on. This allows it to work for IPv6 where the system supports it, while still falling back to IPv4-only on systems which don't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="143c187acc40c6e4dc672359c95beead999d8959" translate="yes" xml:space="preserve">
          <source>It uses these values to set the extended timestamp field (ID is &quot;UT&quot;) in the local zip header using the three values, $atime, $mtime, $ctime. In addition it sets the extended timestamp field in the central zip header using &lt;code&gt;$mtime&lt;/code&gt; .</source>
          <target state="translated">它使用这些值使用$ atime，$ mtime，$ ctime这三个值在本地zip标头中设置扩展时间戳字段（ID为&amp;ldquo; UT&amp;rdquo;）。此外，它使用 &lt;code&gt;$mtime&lt;/code&gt; 在中央zip标头中设置扩展时间戳字段。</target>
        </trans-unit>
        <trans-unit id="79a1b16fce6a4d25801f9ce9e038622522aac3da" translate="yes" xml:space="preserve">
          <source>It uses these values to set the extended timestamp field (ID is &quot;UT&quot;) in the local zip header using the three values, $atime, $mtime, $ctime. In addition it sets the extended timestamp field in the central zip header using &lt;code&gt;$mtime&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f46edc5cb632e7fccbb0705e4feec5f3263394" translate="yes" xml:space="preserve">
          <source>It was allowed to use a list of variables in a format, without separating them with commas. This usage has been deprecated for a long time, and as of Perl 5.28, this throws a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d084cee81998d6ff3982adc3ae633d6de17437" translate="yes" xml:space="preserve">
          <source>It was easy to write by having it call the Unix cat(1) command, but it would probably be more portable to open the file manually (and somewhat more efficient). Of course, because dot files are a Unixy concept, we're not that concerned.</source>
          <target state="translated">让它调用Unix的cat(1)命令,写起来很容易,但如果手动打开文件,可能会更方便(效率更高一些)。当然,因为点阵文件是Unixy的概念,所以我们并不是很在意。</target>
        </trans-unit>
        <trans-unit id="c142dca333e2894efe138704aae3906df8914b33" translate="yes" xml:space="preserve">
          <source>It was extracted to dual-life on CPAN at version 1.95 by Paul Evans &amp;lt;leonerd@leonerd.org.uk&amp;gt;</source>
          <target state="translated">Paul Evans &amp;lt;leonerd@leonerd.org.uk&amp;gt;在1.95版的CPAN上将其提取为具有双重生命的文件。</target>
        </trans-unit>
        <trans-unit id="166bbe1785a329a167c16e63945354e47d32b2c0" translate="yes" xml:space="preserve">
          <source>It was introduced to avoid the potential problems with the other form, available in all Perls. That form consists of a backslash followed by three octal digits. One problem with this form is that it can look exactly like an old-style backreference (see &lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;&quot;Disambiguation rules between old-style octal escapes and backreferences&quot;&lt;/a&gt; below.) You can avoid this by making the first of the three digits always a zero, but that makes \077 the largest code point specifiable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62846658b7b31f9fc5efa8815011f4172e2d224" translate="yes" xml:space="preserve">
          <source>It was introduced to avoid the potential problems with the other form, available in all Perls. That form consists of a backslash followed by three octal digits. One problem with this form is that it can look exactly like an old-style backreference (see &lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;Disambiguation rules between old-style octal escapes and backreferences&lt;/a&gt; below.) You can avoid this by making the first of the three digits always a zero, but that makes \077 the largest code point specifiable.</source>
          <target state="translated">引入它是为了避免所有Perls中都提供的另一种形式的潜在问题。该形式由反斜杠和三个八进制数字组成。这种形式的一个问题是，它看起来就像是老式的反向引用（请参见下面的&lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;老式八进制转义和反向引用之间的消歧规则&lt;/a&gt;。）可以通过使三个数字中的第一个始终为零来避免这种情况，但是使\ 077成为最大可指定的代码点。</target>
        </trans-unit>
        <trans-unit id="d3ee2a6714e3e6adf556faba68422a058c942c27" translate="yes" xml:space="preserve">
          <source>It will also use a default typemap installed as &lt;code&gt;ExtUtils::typemap&lt;/code&gt; .</source>
          <target state="translated">它还将使用安装为 &lt;code&gt;ExtUtils::typemap&lt;/code&gt; 的默认类型图。</target>
        </trans-unit>
        <trans-unit id="0759e45d98bb4647a58253ee97ba7b77b47a644c" translate="yes" xml:space="preserve">
          <source>It will also use a default typemap installed as &lt;code&gt;ExtUtils::typemap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39ceb1fd2f53bed50ffdadfd8219def2a0114b8" translate="yes" xml:space="preserve">
          <source>It will also use the &lt;a href=&quot;Win32::Locale&quot;&gt;Win32::Locale&lt;/a&gt; module, if it's installed and IGNORE_WIN32_LOCALE is not set to a true value in the environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ab6ec702b4749c563dad7126fbebc3ad5a9050" translate="yes" xml:space="preserve">
          <source>It will also use the &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Locale&quot;&gt;Win32::Locale&lt;/a&gt; module, if it's installed.</source>
          <target state="translated">如果已安装，它将也使用&lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Locale&quot;&gt;Win32 :: Locale&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="eebcb44cc4b0d0bb319df0e9deccc15987032c7b" translate="yes" xml:space="preserve">
          <source>It will always have at least one parameter automatically passed by Perl - this corresponds to the name of the package. In the example above it will be &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt; .</source>
          <target state="translated">它将始终具有至少一个由Perl自动传递的参数-这与包的名称相对应。在上面的示例中，它将是 &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5ac1faf8f9d59ddb0b6351807f16102144c68a8" translate="yes" xml:space="preserve">
          <source>It will always have at least one parameter automatically passed by Perl - this corresponds to the name of the package. In the example above it will be &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b05bb9d8d6cf0031940a72fb71a5bc98935f18a" translate="yes" xml:space="preserve">
          <source>It will default to the global setting of &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt; , which by default is 0.</source>
          <target state="translated">它将默认为 &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt; 的全局设置，默认为0。</target>
        </trans-unit>
        <trans-unit id="f9ce735c72f68600f9b73a9ad2fbc8f2efff3f41" translate="yes" xml:space="preserve">
          <source>It will default to the global setting of &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt;, which by default is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5106e7131ba864011023c16e2d910c408243d8" translate="yes" xml:space="preserve">
          <source>It will exit with 255.</source>
          <target state="translated">它将以255退出。</target>
        </trans-unit>
        <trans-unit id="cd3560715bcdcdb5a5493a3c2aa8a0baf196fb75" translate="yes" xml:space="preserve">
          <source>It will look in the environment for a</source>
          <target state="translated">它将在环境中寻找一个</target>
        </trans-unit>
        <trans-unit id="271dd95369c9033872c86c2ed2d28ba5b5a90105" translate="yes" xml:space="preserve">
          <source>It will not attempt to read beyond &lt;code&gt;e - 1&lt;/code&gt;, provided that the constraint &lt;code&gt;s &amp;lt; e&lt;/code&gt; is true (this is asserted for in &lt;code&gt;-DDEBUGGING&lt;/code&gt; builds). If the UTF-8 for the input character is malformed in some way, the program may croak, or the function may return the REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to change in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ba08d3329959d8ccf0a41d4bc0caadee83aee8" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x (except overloaded operators) will modify $y, and vice versa. Or in other words, &lt;code&gt;=&lt;/code&gt; is only safe if you modify your BigInts only via overloaded math. As soon as you use a method call it breaks:</source>
          <target state="translated">它不会按照您的想法进行操作，例如复制$ x。相反，它只是再次引用&lt;b&gt;同一&lt;/b&gt;对象并将其存储在$ y中。因此，修改$ x的任何内容（重载运算符除外）都将修改$ y，反之亦然。换句话说， &lt;code&gt;=&lt;/code&gt; 仅在您仅通过重载数学修改BigInts时才安全。一旦使用方法调用，它就会中断：</target>
        </trans-unit>
        <trans-unit id="3da306523999d7f8b6c9832cd1c2497b109726eb" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x will modify $y (except overloaded math operators), and vice versa. See &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; for details and how to avoid that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef09ffb235f52f01cd3d25c0c384cab0806a14c" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x will modify $y (except overloaded math operators), and vice versa. See &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for details and how to avoid that.</source>
          <target state="translated">它不会按照您的想法进行操作，例如复制$ x。相反，它只是再次引用&lt;b&gt;同一&lt;/b&gt;对象并将其存储在$ y中。因此，任何修改$ x的东西都会修改$ y（重载的数学运算符除外），反之亦然。有关详细信息以及如何避免这种情况，请参见&lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd48a6ec2ae8cb512d05f750d53684c09ff6166d" translate="yes" xml:space="preserve">
          <source>It will print 'A' and then terminate, as it considers the match to be zero-width, and thus will not match at the same position twice in a row.</source>
          <target state="translated">它将打印'A',然后终止,因为它认为匹配是零宽度的,因此不会在同一位置连续匹配两次。</target>
        </trans-unit>
        <trans-unit id="478635e0153852c95d172e95b14a9c73a7376ef9" translate="yes" xml:space="preserve">
          <source>It will produce output like this:</source>
          <target state="translated">它将产生这样的输出。</target>
        </trans-unit>
        <trans-unit id="033bdc255180f8b012ecc3dd8743f6cfc3998050" translate="yes" xml:space="preserve">
          <source>It will return undef if it was not able to find where the module was installed, or a hash reference with the following keys if it was able to find the file:</source>
          <target state="translated">如果找不到模块的安装位置,它将返回 undef,如果能够找到文件,则返回一个包含以下键的哈希引用。</target>
        </trans-unit>
        <trans-unit id="8fd1f4b13738ec21f8b65433f2c797f00d69b112" translate="yes" xml:space="preserve">
          <source>It won't work across a sequence of &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;retrieve&lt;/code&gt; operations, however, because the addresses in the retrieved objects, which are part of the stringified references, will probably differ from the original addresses. The topology of your structure is preserved, but not hidden semantics like those.</source>
          <target state="translated">但是，它不能在一系列 &lt;code&gt;store&lt;/code&gt; 和 &lt;code&gt;retrieve&lt;/code&gt; 操作中使用，因为检索到的对象中的地址（是字符串化引用的一部分）可能与原始地址不同。您的结构的拓扑将保留，但不会保留诸如此类的隐藏语义。</target>
        </trans-unit>
        <trans-unit id="d829aa608b7d822354368e8bc717a7f78948e864" translate="yes" xml:space="preserve">
          <source>It works on references, too:</source>
          <target state="translated">它对参考文献也有效。</target>
        </trans-unit>
        <trans-unit id="063657847573da8f9a48b2f56cfac7e5ef0c0bcc" translate="yes" xml:space="preserve">
          <source>It works this way as of Perl 5.18. Historically, it was inconsistent, and you would have to write</source>
          <target state="translated">从Perl 5.18开始,它是这样工作的。过去,这种方式是不一致的,你必须写出</target>
        </trans-unit>
        <trans-unit id="4c5e6eff5a06238d171586dbb35b0a88b0b974e6" translate="yes" xml:space="preserve">
          <source>It would be even more readable to write that this way:</source>
          <target state="translated">这样写就更有看头了。</target>
        </trans-unit>
        <trans-unit id="bb356348d0e8eb250c8d665196d735d29e867b02" translate="yes" xml:space="preserve">
          <source>It would be much better if you could ignore the NULL terminations issue in the main application code and have a mechanism that automatically added the terminating NULL to all keys and values whenever you write to the database and have them removed when you read from the database. As I'm sure you have already guessed, this is a problem that DBM Filters can fix very easily.</source>
          <target state="translated">如果你能在主应用程序代码中忽略NULL终止的问题,并有一个机制,每当你向数据库写入时,自动将终止的NULL添加到所有键和值中,并在从数据库中读取时让它们被删除,那就会好得多。相信你已经猜到了,这个问题DBM Filters可以很容易的解决。</target>
        </trans-unit>
        <trans-unit id="664879d0a9a8a0187a85ff4778c8dc4aba203972" translate="yes" xml:space="preserve">
          <source>It would be much safer if the &lt;code&gt;upcase_in()&lt;/code&gt; function were written to return a copy of its parameters instead of changing them in place:</source>
          <target state="translated">如果编写了 &lt;code&gt;upcase_in()&lt;/code&gt; 函数以返回其参数的副本而不是就地更改它们，则将更加安全：</target>
        </trans-unit>
        <trans-unit id="e4a501eefab1e263f175f9fb282fe6f38bf8d7a7" translate="yes" xml:space="preserve">
          <source>It would be nice if one could leave off the commas around the constants entirely and just say:</source>
          <target state="translated">如果能把常量周围的逗号完全去掉,而只说。</target>
        </trans-unit>
        <trans-unit id="7a5b5ee29fb341a3488cf2301ee04c0c66aa8f82" translate="yes" xml:space="preserve">
          <source>It would be nice if we could do this in one fell swoop: unpack a short, back up a little, and then unpack 2 bytes. Since Perl</source>
          <target state="translated">如果我们能一气呵成地完成这个任务,那就更好了:解包一个短的,后退一点,再解包两个字节。由于 Perl</target>
        </trans-unit>
        <trans-unit id="aaa6174f1be6c791e8b304262469e518ba0d9df6" translate="yes" xml:space="preserve">
          <source>It would be nice to just write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcfbbfc45bc8f20d112951dc582ad08e297b4815" translate="yes" xml:space="preserve">
          <source>It would be nice to support encoding to non-UTF8, such as =?ISO-2022-JP? and =?ISO-8859-1?= but that makes the implementation too complicated. These days major mail agents all support =?UTF-8? so I think it is just good enough.</source>
          <target state="translated">如果能支持编码为非UTF8就更好了,比如=?ISO-2022-JP?和=?ISO-8859-1?=,但这样一来实现起来就太复杂了。现在主要的邮件代理都支持=?UTF-8?,所以我认为这就足够了。</target>
        </trans-unit>
        <trans-unit id="33c0be04ddea1d5a74e0dccb69b13ad0c437b131" translate="yes" xml:space="preserve">
          <source>It would put the generated files into needed locations. Manually put</source>
          <target state="translated">它会把生成的文件放到需要的位置。手动将</target>
        </trans-unit>
        <trans-unit id="79d53b44344312c7f974c895e0fb0eb2bd88118d" translate="yes" xml:space="preserve">
          <source>It's a Perl 4 style file defining values for system networking constants. Sometimes it is built using &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; when Perl is installed, but other times it is not. Modern programs should use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket;&lt;/code&gt; instead.</source>
          <target state="translated">这是一个Perl 4样式文件，用于定义系统网络常量的值。有时在安装Perl时是使用&lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt;构建的，而其他时候则不是。现代程序应 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket;&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="2788c8ed5f3ec3bf8bed1e36ab8dd36690fbf752" translate="yes" xml:space="preserve">
          <source>It's a Perl 4 style file defining values for system networking constants. Sometimes it is built using &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; when Perl is installed, but other times it is not. Modern programs should use &lt;code&gt;use Socket;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4113134dec0bea10f51321538387f13a1da8743a" translate="yes" xml:space="preserve">
          <source>It's a cardinal sin to break existing Perl programs. New warnings can be contentious--some say that a program that emits warnings is not broken, while others say it is. Adding keywords has the potential to break programs, changing the meaning of existing token sequences or functions might break programs.</source>
          <target state="translated">破坏现有的Perl程序是一种大罪。新的警告可能会引起争议--有些人说,发出警告的程序并没有被破坏,而另一些人则说它是被破坏的。添加关键字有可能破坏程序,改变现有标记序列或函数的含义也可能破坏程序。</target>
        </trans-unit>
        <trans-unit id="3443bb54ef3fac59b8ef057b86f52fe4980fafa5" translate="yes" xml:space="preserve">
          <source>It's a little tricker with c2ph because you have to get the includes right. I can't know this for your system, but it's not usually too terribly difficult.</source>
          <target state="translated">对于c2ph来说,这是一个比较棘手的问题,因为你必须得到正确的包括。我不知道你的系统是怎样的,但通常不会太难。</target>
        </trans-unit>
        <trans-unit id="110a6a21060fbfe67381c1323cb9f71073b9732c" translate="yes" xml:space="preserve">
          <source>It's also possible to get into trouble with other operations that don't care whether they use tainted values. Make judicious use of the file tests in dealing with any user-supplied filenames. When possible, do opens and such &lt;b&gt;after&lt;/b&gt; properly dropping any special user (or group!) privileges. Perl doesn't prevent you from opening tainted filenames for reading, so be careful what you print out. The tainting mechanism is intended to prevent stupid mistakes, not to remove the need for thought.</source>
          <target state="translated">对于其他不在乎是否使用污染值的操作，也可能会遇到麻烦。在处理用户提供的任何文件名时，明智地使用文件测试。如果可能，请&lt;b&gt;在&lt;/b&gt;正确删除任何特殊用户（或组！）特权&lt;b&gt;后&lt;/b&gt;执行打开等操作。Perl不会阻止您打开受污染的文件名进行读取，因此请小心打印输出。污染机制旨在防止愚蠢的错误，而不是消除思考的需要。</target>
        </trans-unit>
        <trans-unit id="66317ba5ef9718c34fadba6cc4766d4c890f748d" translate="yes" xml:space="preserve">
          <source>It's also the source of a useful idiom for executing a function or performing an operation in list context and then counting the number of return values, by assigning to an empty list and then using that assignment in scalar context. For example, this code:</source>
          <target state="translated">这也是一个有用的成语的来源,在列表上下文中执行一个函数或执行一个操作,然后计算返回值的数量,通过赋值给一个空列表,然后在标量上下文中使用该赋值。例如,这段代码。</target>
        </trans-unit>
        <trans-unit id="fb0964e5585557a9c666044136d7fe7eaf45d2a2" translate="yes" xml:space="preserve">
          <source>It's also too slow (despite caching).</source>
          <target state="translated">它也太慢了(尽管有缓存)。</target>
        </trans-unit>
        <trans-unit id="bfb78b8d261485bbdd288bb61ac4516df58d28f5" translate="yes" xml:space="preserve">
          <source>It's also useful in those cases where you are comparing numbers and &lt;code&gt;is()&lt;/code&gt; 's use of &lt;code&gt;eq&lt;/code&gt; will interfere:</source>
          <target state="translated">在比较数字并且 &lt;code&gt;is()&lt;/code&gt; 的 &lt;code&gt;eq&lt;/code&gt; 使用会干扰以下情况下，它也很有用：</target>
        </trans-unit>
        <trans-unit id="f80232728d1a0e850ad2f6c5b3fdccf6e503f004" translate="yes" xml:space="preserve">
          <source>It's also useful in those cases where you are comparing numbers and &lt;code&gt;is()&lt;/code&gt;'s use of &lt;code&gt;eq&lt;/code&gt; will interfere:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8752339d213c2f85078fabecb615c362db1828df" translate="yes" xml:space="preserve">
          <source>It's also worth taking a moment to explain what happens when you &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize a member of a composite type (i.e. an array or hash element). In this case, the element is &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized</source>
          <target state="translated">还值得花一些时间来解释一下，当您 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 复合类型的成员（即数组或哈希元素）时会发生什么。在这种情况下，元素是 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 化的</target>
        </trans-unit>
        <trans-unit id="c2abe8691d5cb64abc6ccb815e6052901189c534" translate="yes" xml:space="preserve">
          <source>It's also worth taking a moment to explain what happens when you &lt;code&gt;local&lt;/code&gt;ize a member of a composite type (i.e. an array or hash element). In this case, the element is &lt;code&gt;local&lt;/code&gt;ized</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd541e8b6a88392365f934744a878ca9f6a497b7" translate="yes" xml:space="preserve">
          <source>It's better to have numerous simple routines than a few monolithic ones. If your routine changes its behaviour significantly based on its arguments, it's a sign that you should have two (or more) separate routines.</source>
          <target state="translated">拥有许多简单的例程比几个单体例程要好。如果你的例程根据它的参数显著地改变了它的行为,那就说明你应该有两个(或更多)独立的例程。</target>
        </trans-unit>
        <trans-unit id="f3b2de78648bbd7090bfe684b2c6827590ea2a26" translate="yes" xml:space="preserve">
          <source>It's designed to be used as a handy command line utility:</source>
          <target state="translated">它被设计为一个方便的命令行工具。</target>
        </trans-unit>
        <trans-unit id="96439b3081e445faf2fae88934bbc314011a0c32" translate="yes" xml:space="preserve">
          <source>It's easy to notice the problem in such a short example, but in more complicated code you are looking for trouble if you don't localize changes to the special variables.</source>
          <target state="translated">在这样一个简短的例子中很容易发现问题,但在更复杂的代码中,如果你不对特殊变量进行局部修改,你就会找麻烦。</target>
        </trans-unit>
        <trans-unit id="dde0b49167dc00c194116739ebbe7f23d5e20372" translate="yes" xml:space="preserve">
          <source>It's egg-eating all over again: Some think that as a bit string this should be written &quot;10001100&quot; i.e. beginning with the most significant bit, others insist on &quot;00110001&quot;. Well, Perl isn't biased, so that's why we have two bit string codes:</source>
          <target state="translated">这又是一个吃鸡蛋的过程。有人认为,作为一个位串,应该写成 &quot;10001100&quot; 即从最重要的位开始写,而其他人则坚持写成 &quot;00110001&quot;。好吧,Perl不偏不倚,所以我们才有两个位串代码。</target>
        </trans-unit>
        <trans-unit id="f24807b6184833a23a70254e8f0aebceeb147f40" translate="yes" xml:space="preserve">
          <source>It's especially useful when comparing greater-than or smaller-than relation between values:</source>
          <target state="translated">当比较数值之间的大于或小于关系时,它特别有用。</target>
        </trans-unit>
        <trans-unit id="1e3a1b4314f9d6c52bc40629c2fb29defff528f6" translate="yes" xml:space="preserve">
          <source>It's essential to run any timing measurements a sufficient number of times so the numbers settle on a numerical average, otherwise each run will naturally fluctuate due to variations in the environment, to reduce the effect of contention for &lt;code&gt;CPU&lt;/code&gt; resources and network bandwidth for instance. Running the above code for one million iterations, we can take a look at the report output by the &lt;code&gt;Benchmark&lt;/code&gt; module, to see which approach is the most effective.</source>
          <target state="translated">必须对任何时序测量进行足够的次数，这样才能使这些数值稳定在数值平均值上，否则每次运行都会由于环境变化而自然波动，以减少例如争用 &lt;code&gt;CPU&lt;/code&gt; 资源和网络带宽的影响。运行上面的代码一百万次迭代，我们可以看一下 &lt;code&gt;Benchmark&lt;/code&gt; 模块输出的报告，看看哪种方法是最有效的。</target>
        </trans-unit>
        <trans-unit id="7514b40c5333fb03e3aac77ea8c92f752cf5dd0e" translate="yes" xml:space="preserve">
          <source>It's for</source>
          <target state="translated">是给你的</target>
        </trans-unit>
        <trans-unit id="b4b810adc86730679601de6a1493c2a23c259247" translate="yes" xml:space="preserve">
          <source>It's good idea to post an announcement of the availability of your module (or the module itself if small) to the comp.lang.perl.announce Usenet newsgroup. This will at least ensure very wide once-off distribution.</source>
          <target state="translated">最好的办法是在 comp.lang.perl.announce Usenet 新闻组中发布一个关于你的模块 (如果是小模块的话,则是模块本身)的公告。这至少可以保证一次性的广泛传播。</target>
        </trans-unit>
        <trans-unit id="90af562410b60653a0aa18fd2da97246062921f5" translate="yes" xml:space="preserve">
          <source>It's good that you lost track, because you shouldn't depend on the internal format being any specific encoding. But since you asked: by default, the internal format is either ISO-8859-1 (latin-1), or utf8, depending on the history of the string. On EBCDIC platforms, this may be different even.</source>
          <target state="translated">很高兴你失去了方向,因为你不应该依赖内部格式是任何特定的编码。但既然你问了:默认情况下,内部格式是ISO-8859-1 (latin-1),或者utf8,这取决于字符串的历史。在EBCDIC平台上,这甚至可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="d9d2e12c0d08cbda4c9a91e7d799364ca6410b91" translate="yes" xml:space="preserve">
          <source>It's important that $how_many accurately reflects the number of tests in the SKIP block so the # of tests run will match up with your plan. If your plan is &lt;code&gt;no_plan&lt;/code&gt; $how_many is optional and will default to 1.</source>
          <target state="translated">$ how_many准确反映SKIP块中的测试数量非常重要，因此运行的测试数量应与您的计划相匹配。如果您的计划是 &lt;code&gt;no_plan&lt;/code&gt; ,则 $ how_many是可选的，默认为1。</target>
        </trans-unit>
        <trans-unit id="1e8b6f334f8979bc29ccd072552302ba947b27dc" translate="yes" xml:space="preserve">
          <source>It's important to know what custom operators won't do for you. They won't let you add new syntax to Perl, directly. They won't even let you add new keywords, directly. In fact, they won't change the way Perl compiles a program at all. You have to do those changes yourself, after Perl has compiled the program. You do this either by manipulating the op tree using a &lt;code&gt;CHECK&lt;/code&gt; block and the &lt;code&gt;B::Generate&lt;/code&gt; module, or by adding a custom peephole optimizer with the &lt;code&gt;optimize&lt;/code&gt; module.</source>
          <target state="translated">重要的是要知道自定义运算符对您没有帮助。他们不允许您直接向Perl添加新语法。他们甚至不允许您直接添加新关键字。实际上，它们根本不会改变Perl编译程序的方式。在Perl编译程序之后，您必须自己进行更改。您可以通过使用 &lt;code&gt;CHECK&lt;/code&gt; 块和 &lt;code&gt;B::Generate&lt;/code&gt; 模块来操作op树，也可以通过添加带有 &lt;code&gt;optimize&lt;/code&gt; 模块的自定义窥孔优化器来实现。</target>
        </trans-unit>
        <trans-unit id="885ff1b611d651161375b8dbd778f67a1c287d62" translate="yes" xml:space="preserve">
          <source>It's important to note that locks don't prevent access to the variable in question, only lock attempts. This is in keeping with Perl's longstanding tradition of courteous programming, and the advisory file locking that &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; gives you.</source>
          <target state="translated">重要的是要注意，锁并不会阻止对有问题的变量的访问，而只会阻止锁的尝试。这与Perl的长期礼貌编程传统以及 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; 为您提供的咨询文件锁定保持一致。</target>
        </trans-unit>
        <trans-unit id="c7c0c2bd9c27ab14c34335de35804fff201f2533" translate="yes" xml:space="preserve">
          <source>It's important to note that locks don't prevent access to the variable in question, only lock attempts. This is in keeping with Perl's longstanding tradition of courteous programming, and the advisory file locking that &lt;code&gt;flock()&lt;/code&gt; gives you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b860229e93d14d8905681b2058fe74c37532fe8" translate="yes" xml:space="preserve">
          <source>It's important to note that specifying this parameter as non-null will cause any warnings this function would otherwise generate to be suppressed, and instead be placed in &lt;code&gt;*msgs&lt;/code&gt;. The caller can check the lexical warnings state (or not) when choosing what to do with the returned messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2459276db9d22fb9b53f0419f11fb94dbdc78be" translate="yes" xml:space="preserve">
          <source>It's important to note that the resulting string does &lt;b&gt;not&lt;/b&gt; contain the padding characters typical of Base64 encodings. This omission is deliberate, and is done to maintain compatibility with the family of CPAN Digest modules. See &lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;&quot;PADDING OF BASE64 DIGESTS&quot;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ddbbe7b1b79fc3086fea949fd8823cad9c01f9" translate="yes" xml:space="preserve">
          <source>It's important to note that the resulting string does &lt;b&gt;not&lt;/b&gt; contain the padding characters typical of Base64 encodings. This omission is deliberate, and is done to maintain compatibility with the family of CPAN Digest modules. See &lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;PADDING OF BASE64 DIGESTS&lt;/a&gt; for details.</source>
          <target state="translated">值得注意的是，得到的字符串也很重要&lt;b&gt;不&lt;/b&gt;包含典型的Base64编码的填充字符。此遗漏是有意的，并且是为了保持与CPAN Digest模块系列的兼容性而进行的。有关详细信息&lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;，&lt;/a&gt;请参见填充BASE64数字。</target>
        </trans-unit>
        <trans-unit id="9b1efa7406cffc0cec49027fa169f45a3bd427b6" translate="yes" xml:space="preserve">
          <source>It's important to point out that if you want your subclass to be automatically used by &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; you'll have to and make sure it gets loaded somehow. If you're using &lt;a href=&quot;prove&quot;&gt;prove&lt;/a&gt; you can write an &lt;a href=&quot;App::Prove&quot;&gt;App::Prove&lt;/a&gt; plugin. If you're using &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; or &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; directly (e.g. through a custom script, &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;, or &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt;) you can use the &lt;code&gt;config&lt;/code&gt; option which will cause &lt;a href=&quot;TAP::Parser::IteratorFactory#load_sources&quot;&gt;&quot;load_sources&quot; in TAP::Parser::IteratorFactory&lt;/a&gt; to load your subclass).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc53949ff6cd0c67b2204f9d9fce4d627aed693" translate="yes" xml:space="preserve">
          <source>It's important to realize that there are no bytes in a text string. Of course, Perl has its internal encoding to store the string in memory, but ignore that. If you have to do anything with the number of bytes, it's probably best to move that part to step 3, just after you've encoded the string. Then you know exactly how many bytes it will be in the destination string.</source>
          <target state="translated">要知道,文本字符串中没有字节,这一点很重要。当然,Perl有其内部编码来将字符串存储在内存中,但请忽略这一点。如果你必须对字节数做任何处理,最好把这部分移到步骤 3,就在你对字符串进行编码之后。这样你就可以准确地知道它在目标字符串中会有多少字节。</target>
        </trans-unit>
        <trans-unit id="968be3dc629433b16258b1052384042ab95062a2" translate="yes" xml:space="preserve">
          <source>It's important to set a few things straight first. This is the most important part of this tutorial. This view may conflict with other information that you may have found on the web, but that's mostly because many sources are wrong.</source>
          <target state="translated">首先要把一些事情说清楚。这是本教程最重要的部分。这个观点可能会与你在网上找到的其他信息相冲突,但这主要是因为很多来源是错误的。</target>
        </trans-unit>
        <trans-unit id="6903f2d3d35327d3bebb7683e89ad822d6bff850" translate="yes" xml:space="preserve">
          <source>It's important to understand that we are specifically</source>
          <target state="translated">重要的是,我们要明白,我们是专门的</target>
        </trans-unit>
        <trans-unit id="f9b3935d15d2be2d5136d58cf490c65310c19874" translate="yes" xml:space="preserve">
          <source>It's important you make sure to use the &lt;code&gt;[ ]&lt;/code&gt; array reference constructor. That's because this wouldn't work:</source>
          <target state="translated">确保使用 &lt;code&gt;[ ]&lt;/code&gt; 数组引用构造函数很重要。那是因为这行不通：</target>
        </trans-unit>
        <trans-unit id="9fbefe7e70d26e99bc2294921c0de37542709163" translate="yes" xml:space="preserve">
          <source>It's just a first step, but it's usually a good first step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="134dc1d9bd724d0238c1c1d4c4831e9e7f0b91b6" translate="yes" xml:space="preserve">
          <source>It's likely you'll have to add new data types later.</source>
          <target state="translated">很可能你以后还要添加新的数据类型。</target>
        </trans-unit>
        <trans-unit id="4696eb464dfb95137de621144fb7f593ad6ebd66" translate="yes" xml:space="preserve">
          <source>It's not (not!) the boundary between whitespace and non-whitespace, and it's not the stuff between words we use to create sentences.</source>
          <target state="translated">它不是(不是!)whitespace和非whitespace之间的界限,也不是我们用来造句的单词之间的东西。</target>
        </trans-unit>
        <trans-unit id="6bef3566d208cec3b519ea92214ab4883f383173" translate="yes" xml:space="preserve">
          <source>It's not a good idea to split a construct in the middle like this, and it doesn't work here. Instead use the solution above.</source>
          <target state="translated">像这样在中间拆分一个构造并不是一个好主意,在这里是行不通的。而是使用上面的解决方案。</target>
        </trans-unit>
        <trans-unit id="ec66dac5bae6d199b4bd16298b91f74283fac7f8" translate="yes" xml:space="preserve">
          <source>It's not as easy a problem as it looks. How many words do you think are in there? Wait for it... wait for it.... If you answered 5 you're right. Perl words are groups of &lt;code&gt;\w+&lt;/code&gt; , but that's not what you want to capitalize. How is Perl supposed to know not to capitalize that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; after the apostrophe? You could try a regular expression:</source>
          <target state="translated">这看起来并不容易。您认为其中有几句话？等待...等待....如果您回答5，那么您是对的。Perl单词是 &lt;code&gt;\w+&lt;/code&gt; 组，但这不是您要大写的字母。Perl是如何应该知道不能够利用该 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 撇号后？您可以尝试使用正则表达式：</target>
        </trans-unit>
        <trans-unit id="4a8bd2e0723c73ceda4c03acccc160b0debe5557" translate="yes" xml:space="preserve">
          <source>It's not as easy a problem as it looks. How many words do you think are in there? Wait for it... wait for it.... If you answered 5 you're right. Perl words are groups of &lt;code&gt;\w+&lt;/code&gt;, but that's not what you want to capitalize. How is Perl supposed to know not to capitalize that &lt;code&gt;s&lt;/code&gt; after the apostrophe? You could try a regular expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3fa5386c065511869ec9dc4289bdbe2b8248c4" translate="yes" xml:space="preserve">
          <source>It's not enough to say: &quot;that will make it run faster&quot;, you have to check it. Rerun the code under control of the benchmarking or profiling modules, from the first step above, and check that the new code executed the &lt;b&gt;same task&lt;/b&gt; in</source>
          <target state="translated">仅仅说&amp;ldquo;这将使其运行得更快&amp;rdquo;还不够，您必须进行检查。重新运行下的基准或仿形模块的控制的代码，来自上述第一步骤中，并检查新的代码所执行的&lt;b&gt;相同的任务&lt;/b&gt;中</target>
        </trans-unit>
        <trans-unit id="ac2ff02b85c831d3f4a6ab13ec2cd187eee43782" translate="yes" xml:space="preserve">
          <source>It's not possible to individually showcase all the performance related code for Perl here, naturally, but here's a short list of modules from the CPAN which deserve further attention.</source>
          <target state="translated">在这里自然不可能单独展示所有Perl的性能相关代码,但这里有一个简短的CPAN模块列表,值得进一步关注。</target>
        </trans-unit>
        <trans-unit id="dd227a742cbf3f4b2811cdbf8769ec886d4ea747" translate="yes" xml:space="preserve">
          <source>It's not possible to use this module to embed formatting and color attributes using Perl formats. They replace the escape character with a space (as documented in</source>
          <target state="translated">使用这个模块不可能使用Perl格式来嵌入格式和颜色属性。它们用空格代替转义字符(如在</target>
        </trans-unit>
        <trans-unit id="535d143f61fad023b3aec2dac42bd177c0d8265b" translate="yes" xml:space="preserve">
          <source>It's not possible to use this module to embed formatting and color attributes using Perl formats. They replace the escape character with a space (as documented in &lt;a href=&quot;http://man.he.net/man1/perlform&quot;&gt;perlform(1)&lt;/a&gt;), resulting in garbled output from the unrecognized attribute. Even if there were a way around that problem, the format doesn't know that the non-printing escape sequence is zero-length and would incorrectly format the output. For formatted output using color or other attributes, either use sprintf() instead or use formline() and then add the color or other attributes after formatting and before output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf7485885d18503520503d1c1deed4967629127" translate="yes" xml:space="preserve">
          <source>It's not really a barrel of laughs, is it? In fact, it's worse than it may seem; the eagle-eyed may notice that the first field should only be 10 characters wide, and the error has propagated right through the other numbers - which we've had to count by hand. So it's error-prone as well as horribly unfriendly.</source>
          <target state="translated">这不是真的笑料百出吧?事实上,它比看起来更糟糕,眼尖的人可能会注意到,第一个字段应该只有10个字符宽,而这个错误已经直接传播到了其他数字中--我们不得不用手来计算。所以,这既容易出错,又可怕的不友好。</target>
        </trans-unit>
        <trans-unit id="e0ac4f099ce1bc3e2ec1419213f4e20eba107331" translate="yes" xml:space="preserve">
          <source>It's not scary. Come, hold my hand. We're going to give an example of testing a module. For our example, we'll be testing a date library, &lt;a href=&quot;Date::ICal&quot;&gt;Date::ICal&lt;/a&gt;. It's on CPAN, so download a copy and follow along. [2]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d4e78b20b4ec5c47ad5e65cf852abb8251388b" translate="yes" xml:space="preserve">
          <source>It's ok for your test to change where STDOUT and STDERR point to, Test::Builder's default output settings will not be affected.</source>
          <target state="translated">你的测试可以改变 STDOUT 和 STDERR 的指向,Test::Builder 的默认输出设置不会受到影响。</target>
        </trans-unit>
        <trans-unit id="fa762fbbddcd8f0e9e5679cef69f64552f7bd006" translate="yes" xml:space="preserve">
          <source>It's ok. That's all gone now. We've done all the black magic for you. And here are the tricks...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c4906faf9dc43631913b5936b5f4e02175738c" translate="yes" xml:space="preserve">
          <source>It's only intended as a rough tool. You may need to dicker with the files produced.</source>
          <target state="translated">它只是作为一个粗略的工具。你可能需要对产生的文件进行纠错。</target>
        </trans-unit>
        <trans-unit id="4ad5389b057242e5f2754208243d1e536ed13fdf" translate="yes" xml:space="preserve">
          <source>It's only written as a helper module for both CPAN.pm and CPANPLUS.pm.</source>
          <target state="translated">它只作为CPAN.pm和CPANPLUS.pm的辅助模块来编写。</target>
        </trans-unit>
        <trans-unit id="ce38cb5abf7b4d320a0e699a61e26594815c5fdf" translate="yes" xml:space="preserve">
          <source>It's perfectly safe to nest SKIP blocks. Each SKIP block must have the label &lt;code&gt;SKIP&lt;/code&gt; , or Test::More can't work its magic.</source>
          <target state="translated">嵌套跳过块非常安全。每个SKIP块都必须带有标签 &lt;code&gt;SKIP&lt;/code&gt; 或Test :: More不能发挥其魔力。</target>
        </trans-unit>
        <trans-unit id="391da5d64075501c64aecf0b13f021943f8e3a31" translate="yes" xml:space="preserve">
          <source>It's perfectly safe to nest SKIP blocks. Each SKIP block must have the label &lt;code&gt;SKIP&lt;/code&gt;, or Test::More can't work its magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23089c9252263a75014f4ca3ca447b38592d18ae" translate="yes" xml:space="preserve">
          <source>It's possible that not all modules listed below are installed on your system. For example, the GDBM_File module will not be installed if you don't have the gdbm library.</source>
          <target state="translated">有可能在你的系统中并没有安装下面列出的所有模块。例如,如果你没有gdbm库,GDBM_File模块将不会被安装。</target>
        </trans-unit>
        <trans-unit id="9d7827a4cab49cd207c98c793d3174f1c8aaeda1" translate="yes" xml:space="preserve">
          <source>It's possible to change the MRO of a given class either by using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
mro&lt;/code&gt; as shown in the synopsis, or by using the &lt;a href=&quot;#mro%3a%3aset_mro&quot;&gt;mro::set_mro&lt;/a&gt; function below.</source>
          <target state="translated">这是可能或者通过使用来改变给定类的MRO &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; mro&lt;/code&gt; 在概要中显示，或通过使用&lt;a href=&quot;#mro%3a%3aset_mro&quot;&gt;MRO :: set_mro&lt;/a&gt;以下功能。</target>
        </trans-unit>
        <trans-unit id="bef95c6240b3ebd6ee3881a4772ff7b1a355b2ea" translate="yes" xml:space="preserve">
          <source>It's possible to change the MRO of a given class either by using &lt;code&gt;use mro&lt;/code&gt; as shown in the synopsis, or by using the &lt;a href=&quot;#mro%3A%3Aset_mro&quot;&gt;&quot;mro::set_mro&quot;&lt;/a&gt; function below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8141ee35a9c20672528ff17c177b18bb4b35dc61" translate="yes" xml:space="preserve">
          <source>It's possible to have a class that does not expose any publicly settable attributes. Not every class has attributes and methods.</source>
          <target state="translated">可以有一个不暴露任何可公开设置的属性的类。不是每个类都有属性和方法。</target>
        </trans-unit>
        <trans-unit id="fdf6b6ef2b9e4a59b56ec7ba91fcecae99b94163" translate="yes" xml:space="preserve">
          <source>It's possible to load multiple features together, using a</source>
          <target state="translated">可以将多个功能一起加载,使用一个</target>
        </trans-unit>
        <trans-unit id="66c778a3281518c9b26558498194320e4725fef9" translate="yes" xml:space="preserve">
          <source>It's possible to take the previous idea a little further, by using a compile time &lt;code&gt;DEBUG&lt;/code&gt; constant.</source>
          <target state="translated">通过使用编译时 &lt;code&gt;DEBUG&lt;/code&gt; 常量，可以使先前的想法更进一步。</target>
        </trans-unit>
        <trans-unit id="30a0b506f4d59de09c1852a82f659060edd73925" translate="yes" xml:space="preserve">
          <source>It's possible to use simple addition and subtraction of objects:</source>
          <target state="translated">可以使用简单的物体加减法。</target>
        </trans-unit>
        <trans-unit id="7c04330ddf6941f6fc338e6607920a6ccb70bb26" translate="yes" xml:space="preserve">
          <source>It's preferable to patch against the latest blead version, since this is where new development occurs for all changes other than critical bug fixes. Critical bug fix patches should be made against the relevant maint branches, or should be submitted with a note indicating all the branches where the fix should be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2798edf93af2bc08dca21c6c73367266b229901" translate="yes" xml:space="preserve">
          <source>It's probably best to copy one of the existing runops functions and change it to suit your needs. Then, in the BOOT section of your XS file, add the line:</source>
          <target state="translated">最好是复制一个现有的runops函数,并根据你的需要进行修改。然后,在XS文件的BOOT部分,添加以下一行。</target>
        </trans-unit>
        <trans-unit id="b340d427890b7b2748a883b3fba121b10e7d2921" translate="yes" xml:space="preserve">
          <source>It's probably best to prototype new functions, not retrofit prototyping into older ones. That's because you must be especially careful about silent impositions of differing list versus scalar contexts. For example, if you decide that a function should take just one parameter, like this:</source>
          <target state="translated">最好的办法可能是对新功能进行原型设计,而不是将原型设计改造成旧功能。这是因为你必须特别小心不同列表与标量上下文的沉默强加。例如,如果你决定一个函数应该只取一个参数,就像这样。</target>
        </trans-unit>
        <trans-unit id="91ff9edf126b862a4aaa943668bacea81314c045" translate="yes" xml:space="preserve">
          <source>It's probably better to always use commas after constant names in order to force the next error.</source>
          <target state="translated">可能最好总是在常量名称后使用逗号,以强制下一个错误。</target>
        </trans-unit>
        <trans-unit id="16dbf025d239b7a2bc2c7033417d6a18d06e2afb" translate="yes" xml:space="preserve">
          <source>It's probably worth mentioning that if you're going to filetest the return values out of a readdir, you'd better prepend the directory in question. Otherwise, because we didn't chdir() there, it would have been testing the wrong file.</source>
          <target state="translated">可能值得一提的是,如果你要从一个readdir中测试返回值,你最好把有关的目录放在前面。否则,因为我们没有在那里使用chdir(),就会测试出错误的文件。</target>
        </trans-unit>
        <trans-unit id="e6c512535456a00f2d66365aceea1ac2fa50945d" translate="yes" xml:space="preserve">
          <source>It's quite possible that the target system doesn't have a readily available /tmp, so it's generall safer to do something like this:</source>
          <target state="translated">很有可能目标系统没有现成的/tmp,所以一般来说,这样做比较安全。</target>
        </trans-unit>
        <trans-unit id="8748833136242804cdf06e42df13a982b1789766" translate="yes" xml:space="preserve">
          <source>It's recommended that you run &lt;code&gt;use_ok()&lt;/code&gt; inside a BEGIN block so its functions are exported at compile-time and prototypes are properly honored.</source>
          <target state="translated">建议您在BEGIN块中运行 &lt;code&gt;use_ok()&lt;/code&gt; ,以便在编译时导出其功能，并适当使用原型。</target>
        </trans-unit>
        <trans-unit id="fbc60c6d884b88a267926002dcaceb4adc822c67" translate="yes" xml:space="preserve">
          <source>It's safe, however, to P- or p-pack a string literal, because Perl simply allocates an anonymous variable.</source>
          <target state="translated">然而,对字符串文字进行 P-或 p-pack 是安全的,因为 Perl 只是分配了一个匿名变量。</target>
        </trans-unit>
        <trans-unit id="18b132707c62c569a28f6b436602a7bfbd864dfd" translate="yes" xml:space="preserve">
          <source>It's still not quite so clear as prose, but it is very useful for describing the meaning of each part of the pattern.</source>
          <target state="translated">虽然还是没有散文那么清晰,但对于描述图案中每个部分的含义非常有用。</target>
        </trans-unit>
        <trans-unit id="08057143a2d44a0a378f9cd365b42fe324a68a97" translate="yes" xml:space="preserve">
          <source>It's still up to you to seek out the actual changes, and there might not actually be any. Perhaps all of the changes since you last checked cancelled each other out and left the package in the state it was in before.</source>
          <target state="translated">这还是要靠你自己去寻找实际的变化,实际上可能没有任何变化。也许自你上次检查后的所有变化都互相抵消了,使包裹处于之前的状态。</target>
        </trans-unit>
        <trans-unit id="6aa1b5e370d6ab122fa013735d3b648f88f35f20" translate="yes" xml:space="preserve">
          <source>It's the double quotes, not the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, doing this. Whenever you interpolate an array in a double quote context, Perl joins the elements with spaces (or whatever is in &lt;code&gt;$&quot;&lt;/code&gt; , which is a space by default):</source>
          <target state="translated">这样做是双引号而不是 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 。每当您在双引号上下文中插入数组时，Perl就会用空格（或 &lt;code&gt;$&quot;&lt;/code&gt; 任何内容，默认情况下是空格）将元素连接起来：</target>
        </trans-unit>
        <trans-unit id="7e186193135a9027584138d266cd6dc740e3d523" translate="yes" xml:space="preserve">
          <source>It's the double quotes, not the &lt;code&gt;print&lt;/code&gt;, doing this. Whenever you interpolate an array in a double quote context, Perl joins the elements with spaces (or whatever is in &lt;code&gt;$&quot;&lt;/code&gt;, which is a space by default):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faab5a6ebe5c2e1ecdb8d0e0f9a387f835a3623a" translate="yes" xml:space="preserve">
          <source>It's useful if you want to print out the name of a variable. If you restrict yourself to globs which exist at compile-time then the result ought to be unambiguous, because code like &lt;code&gt;${&quot;^G&quot;} = 1&lt;/code&gt; is compiled as two ops - a constant string and a dereference (rv2gv) - so that the glob is created at runtime.</source>
          <target state="translated">如果要打印出变量名，这很有用。如果将自己限制为在编译时存在的全局变量，那么结果应该是明确的，因为像 &lt;code&gt;${&quot;^G&quot;} = 1&lt;/code&gt; 被编译为两个操作-常量字符串和解引用（rv2gv）-这样全局变量是在运行时创建的。</target>
        </trans-unit>
        <trans-unit id="6fb10a58faaab36e9d6bfc07705548b7e33879f9" translate="yes" xml:space="preserve">
          <source>It's very simple to have your tests run under taint mode. Just throw a &lt;code&gt;-T&lt;/code&gt; into the &lt;code&gt;#!&lt;/code&gt; line. &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will read the switches in &lt;code&gt;#!&lt;/code&gt; and use them to run your tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57045aa0891a8e6164538ff7cbd090571f866c1f" translate="yes" xml:space="preserve">
          <source>It's well known that software developers usually fully document the software they write. If, however, the world is in urgent need of your software and there is not enough time to write the full documentation please at least provide a README file containing:</source>
          <target state="translated">众所周知,软件开发者通常会对自己编写的软件进行完整的文档编写。但是,如果世界急需你的软件,而又没有足够的时间来编写完整的文档,请至少提供一个包含README文件。</target>
        </trans-unit>
        <trans-unit id="485b57adcc80650a0f376fe516e0ea35fef68007" translate="yes" xml:space="preserve">
          <source>Italian</source>
          <target state="translated">Italian</target>
        </trans-unit>
        <trans-unit id="4198106b088c5bcb9774e212538d8c15169f58dc" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">固定宽度字体的斜体版本（实际上有点用词不当，因为大多数固定宽度字体仅具有斜体版本，而不是斜体版本）。默认为 &lt;code&gt;CI&lt;/code&gt; 。仅对&lt;b&gt;troff&lt;/b&gt;输出有效。</target>
        </trans-unit>
        <trans-unit id="583cdcdfd2a75305b35fba58a53f31af16e8fada" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">固定宽度字体的斜体版本（实际上有点用词不当，因为大多数固定宽度字体仅具有斜体版本，而不是斜体版本）。默认为 &lt;code&gt;CI&lt;/code&gt; 。仅对troff（1）输出有效。</target>
        </trans-unit>
        <trans-unit id="a71960565a249a16493cbd47c7e62585cc7cdbc3" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt;. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d619f9e66322d8e23851c7238a0c1bf5b94557" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt;. Only matters for troff(1) output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad79ef0f076d3a686ab9738925f4dd2c7e69d7d1" translate="yes" xml:space="preserve">
          <source>Italy</source>
          <target state="translated">Italy</target>
        </trans-unit>
        <trans-unit id="b15ebe35e9c7b71db4b6f242bc6c861b7b404110" translate="yes" xml:space="preserve">
          <source>Itanium Processor Family (IPF) and HP-UX</source>
          <target state="translated">Itanium处理器系列(IPF)和HP-UX。</target>
        </trans-unit>
        <trans-unit id="e54d4abd34db02334ef2ceaf6dadfd1a53f1ce9b" translate="yes" xml:space="preserve">
          <source>Itanium, Itanium 2 &amp;amp; Madison 6</source>
          <target state="translated">安腾，安腾2和麦迪逊6</target>
        </trans-unit>
        <trans-unit id="2644b5ac3389091857c1fa06a99019df89bdf067" translate="yes" xml:space="preserve">
          <source>Item called without tag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e359180eb8ab875848335db708d277f8c6f86293" translate="yes" xml:space="preserve">
          <source>Item, over, and back require a little more explanation: &quot;=over&quot; starts a region specifically for the generation of a list using &quot;=item&quot; commands, or for indenting (groups of) normal paragraphs. At the end of your list, use &quot;=back&quot; to end it. The</source>
          <target state="translated">item、over和back需要多一点解释。&quot;=over &quot;开始一个区域,专门用于使用&quot;=item &quot;命令生成一个列表,或者用于缩进(一组)普通段落。在你的列表的最后,使用&quot;=back &quot;来结束它。列表结束时,使用&quot;=回 &quot;来结束。</target>
        </trans-unit>
        <trans-unit id="839a5a9f576aa03eb6484f3e36f4922e7b29ec1b" translate="yes" xml:space="preserve">
          <source>Items are popped from the stack by the &lt;code&gt;POPMARK&lt;/code&gt; macro. There is also a macro &lt;code&gt;TOPMARK&lt;/code&gt; that inspects the topmost item without removing it. These macros return I32 index values directly. There is also the &lt;code&gt;dMARK&lt;/code&gt; macro which declares a new SV double-pointer variable, called &lt;code&gt;mark&lt;/code&gt;, which points at the marked stack slot; this is the usual macro that C code will use when operating on lists given on the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042e4f40b0307417307709cb5473dc322f497e53" translate="yes" xml:space="preserve">
          <source>Items are popped from the stack by using the &lt;code&gt;POPs&lt;/code&gt; macro or its typed versions, There is also a macro &lt;code&gt;TOPs&lt;/code&gt; that inspects the topmost item without removing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2734858b1f6df00795c8577aa06b54f6e0816d" translate="yes" xml:space="preserve">
          <source>Items are pushed to the save stack by using the various &lt;code&gt;SAVE...()&lt;/code&gt; macros. Many of these macros take a variable and store both its address and current value on the save stack, ensuring that value gets restored on scope exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0e07dde86207db19bb7bb39fcc8f34c4917c7f" translate="yes" xml:space="preserve">
          <source>Items are pushed to the stack by using the &lt;code&gt;PUSHMARK()&lt;/code&gt; macro. Even though the stack itself stores (value) stack indices as integers, the &lt;code&gt;PUSHMARK&lt;/code&gt; macro should be given a stack pointer directly; it will calculate the index offset by comparing to the &lt;code&gt;PL_stack_sp&lt;/code&gt; variable. Thus almost always the code to perform this is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b956fed2d730024f43d841fa09eee15223cb553e" translate="yes" xml:space="preserve">
          <source>Items are pushed to the stack by using the &lt;code&gt;PUSHs()&lt;/code&gt; macro or its variants described above; &lt;code&gt;XPUSHs()&lt;/code&gt;, &lt;code&gt;mPUSHs()&lt;/code&gt;, &lt;code&gt;mXPUSHs()&lt;/code&gt; and the typed versions. Note carefully that the non-&lt;code&gt;X&lt;/code&gt; versions of these macros do not check the size of the stack and assume it to be big enough. These must be paired with a suitable check of the stack's size, such as the &lt;code&gt;EXTEND&lt;/code&gt; macro to ensure it is large enough. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca788485b73309b9f1f94d8376ab88aa565b95b" translate="yes" xml:space="preserve">
          <source>Iterate raw input without applying any fixes for quirky input syntax.</source>
          <target state="translated">迭代原始输入,而不需要对古怪的输入语法进行任何修正。</target>
        </trans-unit>
        <trans-unit id="880d0fdfaa731611203ad90b727f9ad0e4c9d1d5" translate="yes" xml:space="preserve">
          <source>Iterate through it, of course.</source>
          <target state="translated">当然,迭代通过它。</target>
        </trans-unit>
        <trans-unit id="0c168efad25dad6474931abc9c9d01ef4bb67924" translate="yes" xml:space="preserve">
          <source>Iterate through the process output, of course.</source>
          <target state="translated">当然,经由过程输出迭代。</target>
        </trans-unit>
        <trans-unit id="427ce88c1ea69b3f405aa4f0fa73689dcbd052f7" translate="yes" xml:space="preserve">
          <source>Iterates over necessary shared objects, calling &lt;code&gt;xs_make_dlsyms&lt;/code&gt; method for each with appropriate arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269b5437f5a208443de379288c68fd64af0840d2" translate="yes" xml:space="preserve">
          <source>Iterating over the PADNAMELIST iterates over all possible pad items. Pad slots for targets (&lt;code&gt;SVs_PADTMP&lt;/code&gt;) and GVs end up having &amp;amp;PL_padname_undef &quot;names&quot;, while slots for constants have &lt;code&gt;&amp;amp;PL_padname_const&lt;/code&gt; &quot;names&quot; (see &lt;code&gt;&lt;a href=&quot;#pad_alloc&quot;&gt;&quot;pad_alloc&quot;&lt;/a&gt;&lt;/code&gt;). That &lt;code&gt;&amp;amp;PL_padname_undef&lt;/code&gt; and &lt;code&gt;&amp;amp;PL_padname_const&lt;/code&gt; are used is an implementation detail subject to change. To test for them, use &lt;code&gt;!PadnamePV(name)&lt;/code&gt; and &lt;code&gt;PadnamePV(name) &amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92d8ec2d181e1d01333d9fb58638b2b85aed8c4" translate="yes" xml:space="preserve">
          <source>Iterating over the PADNAMELIST iterates over all possible pad items. Pad slots for targets (SVs_PADTMP) and GVs end up having &amp;amp;PL_padname_undef &quot;names&quot;, while slots for constants have &amp;amp;PL_padname_const &quot;names&quot; (see pad_alloc()). That &amp;amp;PL_padname_undef and &amp;amp;PL_padname_const are used is an implementation detail subject to change. To test for them, use &lt;code&gt;!PadnamePV(name)&lt;/code&gt; and &lt;code&gt;PadnamePV(name)
&amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt; , respectively.</source>
          <target state="translated">遍历PADNAMELIST遍历所有可能的填充项目。目标（SVs_PADTMP）和GV的填充插槽最终以＆PL_padname_undef&amp;ldquo;名称&amp;rdquo;命名，而常量的插槽具有＆PL_padname_const&amp;ldquo;名称&amp;rdquo;（请参见pad_alloc（））。使用＆PL_padname_undef和＆PL_padname_const是可能更改的实现细节。要测试它们，请分别使用 &lt;code&gt;!PadnamePV(name)&lt;/code&gt; 和 &lt;code&gt;PadnamePV(name) &amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="ca668574626a9549ef81113edbe0269d243a6e70" translate="yes" xml:space="preserve">
          <source>Iterator for array-based TAP sources</source>
          <target state="translated">阵列式TAP源的迭代器</target>
        </trans-unit>
        <trans-unit id="e365acec52938bb4821137a9d3698525ef64c0e6" translate="yes" xml:space="preserve">
          <source>Iterator for filehandle-based TAP sources</source>
          <target state="translated">基于文件柄的TAP源的迭代器。</target>
        </trans-unit>
        <trans-unit id="608949e6615edc46b7788d7e5f71e396c783a95e" translate="yes" xml:space="preserve">
          <source>Iterator for process-based TAP sources</source>
          <target state="translated">基于过程的TAP源的迭代器</target>
        </trans-unit>
        <trans-unit id="1fdccc2b2140fc0f61c8fa7efaf9cf9309d438ee" translate="yes" xml:space="preserve">
          <source>IteratorFactory</source>
          <target state="translated">IteratorFactory</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="e11cc17e61cacb91ddb22ab15b88e065056ee12e" translate="yes" xml:space="preserve">
          <source>Ithreads work by cloning the data tree so that no data is shared between different threads. These threads can be used by using the &lt;code&gt;threads&lt;/code&gt; module or by doing fork() on win32 (fake fork() support). When a thread is cloned all Perl data is cloned, however non-Perl data cannot be cloned automatically. Perl after 5.8.0 has support for the &lt;code&gt;CLONE&lt;/code&gt; special subroutine. In &lt;code&gt;CLONE&lt;/code&gt; you can do whatever you need to do, like for example handle the cloning of non-Perl data, if necessary. &lt;code&gt;CLONE&lt;/code&gt; will be called once as a class method for every package that has it defined (or inherits it). It will be called in the context of the new thread, so all modifications are made in the new area. Currently CLONE is called with no parameters other than the invocant package name, but code should not assume that this will remain unchanged, as it is likely that in future extra parameters will be passed in to give more information about the state of cloning.</source>
          <target state="translated">Ithread通过克隆数据树来工作，因此不同线程之间不会共享数据。可以通过使用 &lt;code&gt;threads&lt;/code&gt; 模块或在win32上执行fork（）（使用伪造的fork（））来使用这些线程。克隆线程时，将克隆所有Perl数据，但是不能自动克隆非Perl数据。 5.8.0之后的Perl支持 &lt;code&gt;CLONE&lt;/code&gt; 特殊子例程。在 &lt;code&gt;CLONE&lt;/code&gt; 中,您可以执行所需的任何操作，例如，如有必要，处理非Perl数据的克隆。 &lt;code&gt;CLONE&lt;/code&gt; 将被定义为（或继承）每个包的类方法一次调用。将在新线程的上下文中调用它，因此所有修改都在新区​​域中进行。当前调用CLONE时除了发出主叫的程序包名称外没有其他参数，但是代码不应假定它会保持不变，因为将来可能会传入其他参数以提供有关克隆状态的更多信息。</target>
        </trans-unit>
        <trans-unit id="1fc560e7e4efb5d974d128bd00c3dd33446589b6" translate="yes" xml:space="preserve">
          <source>Its &lt;code&gt;pprivate&lt;/code&gt; and &lt;code&gt;intflags&lt;/code&gt; fields contain data specific to each engine.</source>
          <target state="translated">其 &lt;code&gt;pprivate&lt;/code&gt; 和 &lt;code&gt;intflags&lt;/code&gt; 字段包含特定于每个引擎的数据。</target>
        </trans-unit>
        <trans-unit id="16c6982b7d6141952759d09a7076ec5f4dab57ab" translate="yes" xml:space="preserve">
          <source>Its address can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed. Make sure that you don't try to compare a random sv with &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; . For example when interfacing Perl code, it'll work correctly for:</source>
          <target state="translated">只要需要 &lt;code&gt;SV*&lt;/code&gt; 就可以使用其地址。确保您不要尝试将随机sv与 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 进行比较。例如，当连接Perl代码时，它将在以下方面正常工作：</target>
        </trans-unit>
        <trans-unit id="09d223f73a742d40d37e0069338730ea57d94138" translate="yes" xml:space="preserve">
          <source>Its address can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed. Make sure that you don't try to compare a random sv with &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt;. For example when interfacing Perl code, it'll work correctly for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0881b1abd4c8c0f2683196629616b2be066ab1e5" translate="yes" xml:space="preserve">
          <source>Its advantage over &lt;code&gt;ok()&lt;/code&gt; is when the test fails you'll know what $got and $expected were:</source>
          <target state="translated">与 &lt;code&gt;ok()&lt;/code&gt; 相比，它的优点是测试失败时，您将知道$ got和$ expected是什么：</target>
        </trans-unit>
        <trans-unit id="004b859afb711a2b891500dcf0aac6a8c2d2a9a8" translate="yes" xml:space="preserve">
          <source>Its advantages over &lt;code&gt;ok()&lt;/code&gt; are similar to that of &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; . Better diagnostics on failure.</source>
          <target state="translated">它比 &lt;code&gt;ok()&lt;/code&gt; 的优势类似于 &lt;code&gt;is()&lt;/code&gt; 和 &lt;code&gt;isnt()&lt;/code&gt; 的优势。更好的故障诊断。</target>
        </trans-unit>
        <trans-unit id="0c8e5bbdfc16ed39f18dc0db649a1798bde0ff44" translate="yes" xml:space="preserve">
          <source>Its advantages over &lt;code&gt;ok()&lt;/code&gt; are similar to that of &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt;. Better diagnostics on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47f30ae9fc0af2d5174d1161686c5cb48a52d13" translate="yes" xml:space="preserve">
          <source>Its behaviour is identical to using an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; type in XS with T_IV.</source>
          <target state="translated">它的行为与在XS中使用T_IV 使用 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 类型相同。</target>
        </trans-unit>
        <trans-unit id="78ff78bdd00c6e2cf21af3315183fda1a7d0aefd" translate="yes" xml:space="preserve">
          <source>Its behaviour is identical to using an &lt;code&gt;int&lt;/code&gt; type in XS with T_IV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae697da5b215cc5fb762242f2f9d970cf1a4185" translate="yes" xml:space="preserve">
          <source>Its currently very simple and may be expanded sometime in the figure to include more flexible code and switches.</source>
          <target state="translated">其目前非常简单,可能会在图中的某个时候进行扩展,加入更多灵活的代码和开关。</target>
        </trans-unit>
        <trans-unit id="270729f2364ce03a3daacf9b717d32c8a85378b7" translate="yes" xml:space="preserve">
          <source>Its format is not guaranteed not to change over time.</source>
          <target state="translated">其格式不能保证不随时间而改变。</target>
        </trans-unit>
        <trans-unit id="ab2643af88a544c3d8cf389888d3e8add44c6b63" translate="yes" xml:space="preserve">
          <source>Its name comes from the observation that this operation combined with the alternation operator (&lt;code&gt;&quot;|&quot;&lt;/code&gt;) can be used to create what is essentially a pattern-based if/then/else block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41db9b49c066a3eed741a13ffe63dcafc0bc1631" translate="yes" xml:space="preserve">
          <source>Its name comes from the observation that this operation combined with the alternation operator (&lt;code&gt;|&lt;/code&gt;) can be used to create what is essentially a pattern-based if/then/else block:</source>
          <target state="translated">它的名字来自于观察到该操作与交替运算符（ &lt;code&gt;|&lt;/code&gt; ）结合使用时可以用来创建本质上基于模式的if / then / else块的方法：</target>
        </trans-unit>
        <trans-unit id="857df5ce623d367dca94803887ed2679c126a932" translate="yes" xml:space="preserve">
          <source>Its purpose was to allow your non-ASCII Perl scripts not to have to be written in UTF-8; this was useful before editors that worked on UTF-8 encoded text were common, but that was long ago. It caused problems, such as affecting the operation of other modules that weren't expecting it, causing general mayhem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f8c93b7e3928b82285ec3cb4baed8ba27c22ab" translate="yes" xml:space="preserve">
          <source>Its return buffer is per-thread, so it also is never overwritten by a call to this function from another thread; unlike the function it replaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a5e19377208f27c49b06cb17d4ed4cd4b998dc" translate="yes" xml:space="preserve">
          <source>Its use of \x1b (escape) is also very questionable.</source>
          <target state="translated">其使用x1b(逃逸)也很值得商榷。</target>
        </trans-unit>
        <trans-unit id="439b82c22fda8042c3800152aa28934c765e39cf" translate="yes" xml:space="preserve">
          <source>Its value grows rapidly, even for small inputs. For example, A(4, 2) is an integer of 19729 decimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1782b37a47b28cba886190c0e7c9425d4b8409e" translate="yes" xml:space="preserve">
          <source>Its wrapping is done by &lt;a href=&quot;../../text/wrap&quot;&gt;Text::Wrap&lt;/a&gt;, so you can change &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; as you like.</source>
          <target state="translated">它的包装是通过&lt;a href=&quot;../../text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt;完成的，因此您可以根据需要更改 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8279d860cdcd8af715030eac4d6150f64676e6fe" translate="yes" xml:space="preserve">
          <source>Its wrapping is done by &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt;, so you can change &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; as you like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="d4ca6fbb7f638a8b6b39592979f862bfb9bd67d1" translate="yes" xml:space="preserve">
          <source>J. Nick Koston &amp;lt;nick@cpanel.net&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0769e7614be3e4e1822db4f1f3c8b1ae2f3201ca" translate="yes" xml:space="preserve">
          <source>JAPH</source>
          <target state="translated">JAPH</target>
        </trans-unit>
        <trans-unit id="d7060e173c0374cb8eae482e18306d094b4a274a" translate="yes" xml:space="preserve">
          <source>JAPH stands for &quot;Just another Perl hacker,&quot;, which Randal Schwartz used to sign email and usenet messages starting in the late 1980s. He previously used the phrase with many subjects (&quot;Just another x hacker,&quot;), so to distinguish his JAPH, he started to write them as Perl programs:</source>
          <target state="translated">JAPH是 &quot;Just another Perl hacker &quot;的缩写,Randal Schwartz从20世纪80年代末开始用它来签署电子邮件和usenet消息。他之前用这句话的主题很多(&quot;Just another x hacker&quot;),所以为了区别他的JAPH,他开始把它们写成Perl程序。</target>
        </trans-unit>
        <trans-unit id="7f3a84b51622bff154d5971f3af29fa8785e389f" translate="yes" xml:space="preserve">
          <source>JIS has not endorsed the full Microsoft standard however. The official &lt;code&gt;Shift_JIS&lt;/code&gt; includes only JIS X 0201 and JIS X 0208 character sets, while Microsoft has always used &lt;code&gt;Shift_JIS&lt;/code&gt; to encode a wider character repertoire. See &lt;code&gt;IANA&lt;/code&gt; registration for &lt;code&gt;Windows-31J&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="ab81c25e1d8756ce41a1d0bd153f8a1a9cd26516" translate="yes" xml:space="preserve">
          <source>JSON -&amp;gt; PERL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085bf9967f7db3a1e36f211bc12e97fc9c8726e2" translate="yes" xml:space="preserve">
          <source>JSON object. If that is successful, it will return this object, otherwise it will return &lt;code&gt;undef&lt;/code&gt;. If there is a parse error, this method will croak just as &lt;code&gt;decode&lt;/code&gt; would do (one can then use &lt;code&gt;incr_skip&lt;/code&gt; to skip the erroneous part). This is the most common way of using the method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca97a1ee6b474fcf8884b628a790828e390c7d4" translate="yes" xml:space="preserve">
          <source>JSON, &lt;a href=&quot;http://json.org/&quot;&gt;http://json.org/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c9214a804f5e0bb364aa23a074ce1bb72d3b90" translate="yes" xml:space="preserve">
          <source>JSON::PP</source>
          <target state="translated">JSON::PP</target>
        </trans-unit>
        <trans-unit id="bc2d16fc45f4fb15b4bd4ac1aaf8b68aeeba40dd" translate="yes" xml:space="preserve">
          <source>JSON::PP (and JSON::XS) trusts what you pass to &lt;code&gt;encode&lt;/code&gt; method (or &lt;code&gt;encode_json&lt;/code&gt; function) is a clean, validated data structure with values that can be represented as valid JSON values only, because it's not from an external data source (as opposed to JSON texts you pass to &lt;code&gt;decode&lt;/code&gt; or &lt;code&gt;decode_json&lt;/code&gt;, which JSON::PP considers tainted and doesn't trust). As JSON::PP doesn't know exactly what you and consumers of your JSON texts want the unexpected values to be (you may want to convert them into null, or to stringify them with or without normalisation (string representation of infinities/NaN may vary depending on platforms), or to croak without conversion), you're advised to do what you and your consumers need before you encode, and also not to numify values that may start with values that look like a number (including infinities/NaN), without validating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67000e5008a49c5764c9853d27cf57eee1416888" translate="yes" xml:space="preserve">
          <source>JSON::PP - JSON::XS compatible pure-Perl module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6a29e642ee039fc28b8f131cabd5029d088849" translate="yes" xml:space="preserve">
          <source>JSON::PP has been in the Perl core since Perl 5.14, mainly for CPAN toolchain modules to parse META.json.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aaa45ea1b22edf7987707428a94f3b9ee14d933" translate="yes" xml:space="preserve">
          <source>JSON::PP is a pure perl JSON decoder/encoder, and (almost) compatible to much faster &lt;a href=&quot;JSON::XS&quot;&gt;JSON::XS&lt;/a&gt; written by Marc Lehmann in C. JSON::PP works as a fallback module when you use &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; module without having installed JSON::XS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1d3eff2890dd7bf9ac851e6d34ec3c432fa2a0" translate="yes" xml:space="preserve">
          <source>JSON::PP will only attempt to parse the JSON text once it is sure it has enough text to get a decisive result, using a very simple but truly incremental parser. This means that it sometimes won't stop as early as the full parser, for example, it doesn't detect mismatched parentheses. The only thing it guarantees is that it starts decoding as soon as a syntactically valid JSON text has been seen. This means you need to set resource limits (e.g. &lt;code&gt;max_size&lt;/code&gt;) to ensure the parser will stop parsing in the presence if syntax errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4762c702bf2677205442e48ee83f7fae4356feaa" translate="yes" xml:space="preserve">
          <source>JSON::PP::Boolean</source>
          <target state="translated">JSON::PP::Boolean</target>
        </trans-unit>
        <trans-unit id="65c4433f9da239d7a8e60b68a81d180683b869c9" translate="yes" xml:space="preserve">
          <source>JSON::PP::Boolean - dummy module providing JSON::PP::Boolean</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a48e124df6419ac5c2d9d111fda43bf7f4a2ad" translate="yes" xml:space="preserve">
          <source>JSON::PP::is_bool</source>
          <target state="translated">JSON::PP::is_bool</target>
        </trans-unit>
        <trans-unit id="3dbefab7107beb14a9168d002d27c476d9979a2f" translate="yes" xml:space="preserve">
          <source>JSON::PP::null</source>
          <target state="translated">JSON::PP::null</target>
        </trans-unit>
        <trans-unit id="d245a16cb70b0da2f6ce2e1cc1b15f6f0108705d" translate="yes" xml:space="preserve">
          <source>JSON::PP::true, JSON::PP::false</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dced2aceecfe6edc6c5082affb4adef03ec116d9" translate="yes" xml:space="preserve">
          <source>JSON::XS compatible pure-Perl module.</source>
          <target state="translated">JSON::XS兼容的纯Perl模块。</target>
        </trans-unit>
        <trans-unit id="67cff807001c7900c13019d99056e3c2c5564617" translate="yes" xml:space="preserve">
          <source>JSON::XS indents with three spaces when you &lt;code&gt;encode&lt;/code&gt; (if requested by &lt;code&gt;indent&lt;/code&gt; or &lt;code&gt;pretty&lt;/code&gt;), and the number cannot be changed. JSON::PP allows you to change/get the number of indent spaces with these mutator/accessor. The default number of spaces is three (the same as JSON::XS), and the acceptable range is from &lt;code&gt;0&lt;/code&gt; (no indentation; it'd be better to disable indentation by &lt;code&gt;indent(0)&lt;/code&gt;) to &lt;code&gt;15&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0eeebe1b8d9c88c3dd6a874baff7c46254de947" translate="yes" xml:space="preserve">
          <source>Jacinta Richardson for translating much of my ideas into this documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ed50c6d4c26a90edb32bb01d8d5b13b356d708" translate="yes" xml:space="preserve">
          <source>James E Keenan &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc167be5863c0fa54ff8e14b6cf90200815632fb" translate="yes" xml:space="preserve">
          <source>James E. Keenan</source>
          <target state="translated">James E.Keenan</target>
        </trans-unit>
        <trans-unit id="fad8357eef2bb53d17336573edc650a4cf157cf3" translate="yes" xml:space="preserve">
          <source>James E. Keenan &amp;lt;jkeen@verizon.net&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cf1bbb2770fa0d885d542ddaca96bfea96011e" translate="yes" xml:space="preserve">
          <source>James Keenan, &amp;lt;jkeenan@cpan.org&amp;gt;</source>
          <target state="translated">詹姆斯&amp;middot;基南（James Keenan），&amp;lt;jkeenan@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2c916c2a6f4627fbe67be340b96ec2857597184a" translate="yes" xml:space="preserve">
          <source>James Raspass &amp;lt;jraspass@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e4cd2d086a80816fd0c59891fecee24ad1a4c4" translate="yes" xml:space="preserve">
          <source>Jamo_Short_Name</source>
          <target state="translated">Jamo_Short_Name</target>
        </trans-unit>
        <trans-unit id="dc05d77338b63072590a6f49b15e48ec83a7bd95" translate="yes" xml:space="preserve">
          <source>Jan Dubois &amp;lt;jand@activestate.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf29f6cad3232704b33e962ef5194fad3b6817b" translate="yes" xml:space="preserve">
          <source>Japan</source>
          <target state="translated">Japan</target>
        </trans-unit>
        <trans-unit id="6ce48d285e726d9be92e6bf68e171d9553e0896e" translate="yes" xml:space="preserve">
          <source>Japanese Encodings</source>
          <target state="translated">日本编码</target>
        </trans-unit>
        <trans-unit id="f0fae5d9347791c2b844b690a046bfe7552e453c" translate="yes" xml:space="preserve">
          <source>Japheth Cleaver added the bits to allow a forced install (-f).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6422bf1002562f4885ccb3e7c11949b9fc2f34" translate="yes" xml:space="preserve">
          <source>Japheth Cleaver added the bits to allow a forced install (&lt;code&gt;-f&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7b561acfebbb2aad1864ab89f7d4e5285c6e22" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi</source>
          <target state="translated">Jarkko Hietaniemi</target>
        </trans-unit>
        <trans-unit id="a9a4e186a4a793bc3fef06e8162fa8ae0f705095" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">Jarkko Hietaniemi &amp;lt;</target>
        </trans-unit>
        <trans-unit id="13ce73395e162a5533c6ace927e40c80d2cab8fd" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;</source>
          <target state="translated">Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7adef0fede1e52584837e3b9fe09cbb854d77894" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt; Bryan Logan &amp;lt;bryanlog@us.ibm.com&amp;gt; David Larson &amp;lt;larson1@us.ibm.com&amp;gt;</source>
          <target state="translated">Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;布莱恩&amp;middot;洛根&amp;lt;bryanlog@us.ibm.com&amp;gt;大卫&amp;middot;拉森&amp;lt;larson1@us.ibm.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="276f92ff10492dd51e70f45871039bf3b88b6a4b" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi's original</source>
          <target state="translated">亚尔科-希塔涅米的原作</target>
        </trans-unit>
        <trans-unit id="04cfea13773f0ae1b7ac40ccd517f43dc7dcdad4" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, &amp;lt;jhi@hut.fi&amp;gt;</source>
          <target state="translated">Jarkko Hietaniemi，&amp;lt;jhi@hut.fi&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c6f1f3b8aba1c1fb078ca69f70f0d3a32db2b05e" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, &amp;lt;jhi@hut.fi&amp;gt;. Now maintained by Perl 5 porters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc2a5e3ff31736b8a57665e048886c573a122f3" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, conversion into libnetcfg for inclusion into Perl 5.8.</source>
          <target state="translated">Jarkko Hietaniemi,将其转换为libnetcfg,纳入Perl 5.8。</target>
        </trans-unit>
        <trans-unit id="692b885ac0ff146816113cee07c7dfe2ef0ba0a4" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi. Now maintained by perl5 porters.</source>
          <target state="translated">Jarkko Hietaniemi。现在由 perl5 移植者维护。</target>
        </trans-unit>
        <trans-unit id="f0bc884e41c8e0399ef072f3aad2d67eaa7fd5aa" translate="yes" xml:space="preserve">
          <source>JavaScript Traps</source>
          <target state="translated">JavaScript陷阱</target>
        </trans-unit>
        <trans-unit id="f2ef0f46c9cd103d2be6f2673d4379b347904df1" translate="yes" xml:space="preserve">
          <source>Jean Delvare provided the following table of different common terminal emulators and their support for the various attributes and others have helped me flesh it out:</source>
          <target state="translated">Jean Delvare提供了下表不同的常用终端仿真器及其对各种属性的支持,其他人也帮我把它具体化了。</target>
        </trans-unit>
        <trans-unit id="27f5b59f8afefe05a200ff5c9949b24e5ca9ea36" translate="yes" xml:space="preserve">
          <source>Jed</source>
          <target state="translated">Jed</target>
        </trans-unit>
        <trans-unit id="b63c65e75871d5c7820e4ea10cfd70f390f74d22" translate="yes" xml:space="preserve">
          <source>Jeff Okamoto &amp;lt;</source>
          <target state="translated">杰夫&amp;middot;冈本&amp;lt;</target>
        </trans-unit>
        <trans-unit id="7ec7c5d4610b8dd06ad086eed7d40f5d2aaef1a6" translate="yes" xml:space="preserve">
          <source>Jeff Okamoto, Tim Bunce, Nick Gianniotis, Steve Kelem, Gurusamy Sarathy and Larry Wall.</source>
          <target state="translated">Jeff Okamoto、Tim Bunce、Nick Gianniotis、Steve Kelem、Gurusamy Sarathy和Larry Wall。</target>
        </trans-unit>
        <trans-unit id="2425ad3a84d8960ab9c2915a943fd7e28d7c0291" translate="yes" xml:space="preserve">
          <source>Jeremy Mates &amp;lt;jmates@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52232653f25fa8c0538602bfc7945ebf9d9b79a7" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden &amp;lt;jdhedden@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a656e0d05c4ded5764e8eee0b16063f85446f7" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden and Reini Urban provided greatly appreciated help to debug and polish &lt;code&gt;Sys::Syslog&lt;/code&gt; under Cygwin.</source>
          <target state="translated">Jerry D. Hedden和Reini Urban为在Cygwin下调试和完善 &lt;code&gt;Sys::Syslog&lt;/code&gt; 提供了极大的帮助。</target>
        </trans-unit>
        <trans-unit id="1a3cecc43a5465fa758b4f88b43cd646e6623b8f" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden, &amp;lt;jdhedden AT cpan DOT org&amp;gt;</source>
          <target state="translated">杰里&amp;middot;赫登（Jerry D.Hedden），&amp;lt;jpandden at cpan DOT org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e5109d5f0b8672892d9cf43511b2568ff7ce2637" translate="yes" xml:space="preserve">
          <source>Jerry Gay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7ad312b85f19c8a09454b49798a0382227aa86" translate="yes" xml:space="preserve">
          <source>Jess Robinson &amp;lt;castaway@desert-island.me.uk&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f1b3fc35d7e705b8692294a866fb025bdc15b4" translate="yes" xml:space="preserve">
          <source>Jim Brandt suggest and provided the initial implementation for the up-to-date and Changes features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549b2243ef15345835dfd4eb22ac64d2df0ea3a8" translate="yes" xml:space="preserve">
          <source>Jim Keenan fixed up various issues with _download</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef645dbc725c293373ed9661992798b416e9b9b4" translate="yes" xml:space="preserve">
          <source>Joe Smith &amp;lt;Joe.Smith@inwap.com&amp;gt;, using the framework created by Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</source>
          <target state="translated">Joe Smith &amp;lt;Joe.Smith@inwap.com&amp;gt;，使用Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;创建的框架。</target>
        </trans-unit>
        <trans-unit id="c865a479b23a538482933eec4ec96a06755b572a" translate="yes" xml:space="preserve">
          <source>Johan Vromans &amp;lt;jvromans@squirrel.nl&amp;gt;</source>
          <target state="translated">Johan Vromans &amp;lt;jvromans@squirrel.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="183447aad929b68cdb9a4bc6a0988222e172d912" translate="yes" xml:space="preserve">
          <source>Johan Vromans &amp;lt;jvromans@squirrel.nl&amp;gt; H. Merijn Brand &amp;lt;h.m.brand@xs4all.nl&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d401e67bf973d127449e78a2dab7a6e33bf82ed1" translate="yes" xml:space="preserve">
          <source>John Lightsey &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93554073e2a9ef40605d8eff344dac817dfa1a9" translate="yes" xml:space="preserve">
          <source>John Peacock &amp;lt;jpeacock@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdfcbe7345fa5c91aff66147710f3cfd01971e09" translate="yes" xml:space="preserve">
          <source>Joins the separate strings of LIST into a single string with fields separated by the value of EXPR, and returns that new string. Example:</source>
          <target state="translated">将LIST的独立字符串连接成一个单一的字符串,字段用EXPR值分隔,并返回新的字符串。例子:将LIST中独立的字符串连接成一个单独的字符串,并以EXPR值分隔字段,然后返回新的字符串。</target>
        </trans-unit>
        <trans-unit id="8701a18a17d809f2f5e1d9461286d81392c749a1" translate="yes" xml:space="preserve">
          <source>Jon Orwant</source>
          <target state="translated">Jon Orwant</target>
        </trans-unit>
        <trans-unit id="9535723b8f84ea59122230a47649084f0880997b" translate="yes" xml:space="preserve">
          <source>Jon Orwant &amp;lt;</source>
          <target state="translated">乔恩&amp;middot;奥万特&amp;lt;</target>
        </trans-unit>
        <trans-unit id="e683318ce5a68c3c49c2481778c7d3eb5187cf39" translate="yes" xml:space="preserve">
          <source>Jonas B. Nielsen &amp;lt;jonasbn@hoarfrost.local&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b947fc83a952d44b7572b1e1134cb1af54db24" translate="yes" xml:space="preserve">
          <source>Josh Jore &amp;lt;jjore@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc19f76e720fe5e2b005501ad08de9eb7175b61" translate="yes" xml:space="preserve">
          <source>Joshua Chamas's Tie::Cache module may be useful as an expiration manager. (If you try this, let me know how it works out.)</source>
          <target state="translated">Joshua Chamas的Tie::Cache模块可能是有用的到期管理器。(如果你试过,让我知道效果如何。)</target>
        </trans-unit>
        <trans-unit id="272f944afb073e466e447521f217853887659759" translate="yes" xml:space="preserve">
          <source>Joshua ben Jore &amp;lt;jjore@cpan.org&amp;gt;</source>
          <target state="translated">约书亚&amp;middot;本&amp;middot;乔尔&amp;lt;jjore@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f8f06875505d336c6444e4ca735af60cc7f95b69" translate="yes" xml:space="preserve">
          <source>Judicious JavaScript programmers should take note of the following:</source>
          <target state="translated">聪明的JavaScript程序员应该注意以下几点。</target>
        </trans-unit>
        <trans-unit id="829558e61eb4ee30d56d5ca3997b5726751317c0" translate="yes" xml:space="preserve">
          <source>Juerd Waalboer &amp;lt;#####@juerd.nl&amp;gt;</source>
          <target state="translated">Juerd Waalboer &amp;lt;##### @ juerd.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d89d24d0ba5d206a7a244711764b4287f3aa5c8f" translate="yes" xml:space="preserve">
          <source>Juerd Waalboer &amp;lt;#####@juerd.nl&amp;gt;, with the help of many Perl Monks.</source>
          <target state="translated">在许多Perl僧侣的帮助下，Juerd Waalboer &amp;lt;##### @ juerd.nl&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="bd209361669e6039e2d46925b98964270ec9db84" translate="yes" xml:space="preserve">
          <source>July 26, 2005</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b31aa739648b445f7448224142630d141a4270e" translate="yes" xml:space="preserve">
          <source>June 12, 2007</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a23786af78acf626cd4573fa13a06ed0180b91" translate="yes" xml:space="preserve">
          <source>June 2008</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d4e067e5679c035c82b3463849e985c82217de" translate="yes" xml:space="preserve">
          <source>June 2017, for Synology DSM 5.1.5022 and DSM 6.1-15101-4.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
