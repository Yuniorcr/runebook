<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="a345738f3732f2f0cdf6981643487de1b3db946b" translate="yes" xml:space="preserve">
          <source>Perl has a number of C functions that allow you to call Perl subroutines. They are</source>
          <target state="translated">Perl有一些C函数,允许你调用Perl子程序。它们是</target>
        </trans-unit>
        <trans-unit id="1bddeb2bc37a6de64d61b4ee95d33bffdb149de8" translate="yes" xml:space="preserve">
          <source>Perl has a very handy construction</source>
          <target state="translated">Perl有一个非常方便的结构</target>
        </trans-unit>
        <trans-unit id="0fe803dd8b2d3f30a3a54343a2a1b136039b1f5f" translate="yes" xml:space="preserve">
          <source>Perl has an &lt;b&gt;internal format&lt;/b&gt;, an encoding that it uses to encode text strings so it can store them in memory. All text strings are in this internal format. In fact, text strings are never in any other format!</source>
          <target state="translated">Perl具有&lt;b&gt;内部格式&lt;/b&gt;，该&lt;b&gt;格式&lt;/b&gt;用于对文本字符串进行编码，以便将其存储在内存中。所有文本字符串均采用此内部格式。实际上，文本字符串绝不会采用任何其他格式！</target>
        </trans-unit>
        <trans-unit id="8e77f37e525e239856b2f6dca9aacaa6be1709a8" translate="yes" xml:space="preserve">
          <source>Perl has an abstracted interface for all supported character encodings, so this is actually a generic &lt;code&gt;Encode&lt;/code&gt; tutorial and &lt;code&gt;Encode&lt;/code&gt; FAQ. But many people think that Unicode is special and magical, and I didn't want to disappoint them, so I decided to call the document a Unicode tutorial.</source>
          <target state="translated">Perl具有适用于所有受支持的字符编码的抽象接口，因此它实际上是通用的 &lt;code&gt;Encode&lt;/code&gt; 教程和 &lt;code&gt;Encode&lt;/code&gt; 常见问题解答。但是许多人认为Unicode是特殊且神奇的，我不想让他们失望，因此我决定将文档称为Unicode教程。</target>
        </trans-unit>
        <trans-unit id="ba0cf0d83a33c18a21a219f52e56234294b46fae" translate="yes" xml:space="preserve">
          <source>Perl has an experimental facility to allow a subroutine's formal parameters to be introduced by special syntax, separate from the procedural code of the subroutine body. The formal parameter list is known as a</source>
          <target state="translated">Perl有一个实验性的设施,允许子程序的形式化参数通过特殊的语法引入,与子程序体的程序代码分开。形式参数列表被称为</target>
        </trans-unit>
        <trans-unit id="a1de858c46ad7947531577a6915520f75857a413" translate="yes" xml:space="preserve">
          <source>Perl has been extended to support the locale system. This is controlled per application by using one pragma, one function call, and several environment variables.</source>
          <target state="translated">Perl已经扩展到支持locale系统。通过使用一个pragma、一个函数调用和几个环境变量来控制每个应用程序。</target>
        </trans-unit>
        <trans-unit id="9724b09cfb0bd9657e1b0740263fad624a62d13c" translate="yes" xml:space="preserve">
          <source>Perl has been ported to many platforms that do not fit into any of the categories listed above. Some, such as AmigaOS, QNX, Plan 9, and VOS, have been well-integrated into the standard Perl source code kit. You may need to see the</source>
          <target state="translated">Perl已被移植到许多平台上,但这些平台并不属于上述任何类别。有些平台,如 AmigaOS、QNX、Plan 9 和 VOS,已经被很好地集成到标准的 Perl 源代码包中。您可能需要查看</target>
        </trans-unit>
        <trans-unit id="59525826d5ce7fdcf57cd21fd12177031ab869c3" translate="yes" xml:space="preserve">
          <source>Perl has its own special way of easily writing test scripts, but for this example only, we'll create our own test script. Create a file called hello that looks like this:</source>
          <target state="translated">Perl有自己特殊的方式来轻松编写测试脚本,但仅在本例中,我们将创建自己的测试脚本。创建一个名为hello的文件,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="998bc2b1651869833ea0ac38395b9fb4d5ed44f8" translate="yes" xml:space="preserve">
          <source>Perl has long been ported to Intel-style microcomputers running under systems like PC-DOS, MS-DOS, OS/2, and most Windows platforms you can bring yourself to mention (except for Windows CE, if you count that). Users familiar with</source>
          <target state="translated">Perl早已被移植到英特尔风格的微机上,运行在PC-DOS、MS-DOS、OS/2等系统下,以及大多数你能提得起的Windows平台上(Windows CE除外,如果你算的话)。熟悉的用户</target>
        </trans-unit>
        <trans-unit id="fe67796dc02d7b52e1f554749c03ec30b57d6bfa" translate="yes" xml:space="preserve">
          <source>Perl has most of the usual conditional and looping constructs. As of Perl 5.10, it even has a case/switch statement (spelled &lt;code&gt;given&lt;/code&gt; /&lt;code&gt;when&lt;/code&gt; ). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more details.</source>
          <target state="translated">Perl具有大多数通常的条件和循环构造。像Perl 5.10的，它甚至有一个情况/ switch语句（拼写 &lt;code&gt;given&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; ）。有关更多详细信息，请参见&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsyn中的Switch语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db019a5ac1f171d008187e1d1c55e0f5d5a9b3a4" translate="yes" xml:space="preserve">
          <source>Perl has never accepted code points above 255 without them being Unicode, so their use implies Unicode for the whole string.</source>
          <target state="translated">Perl从来没有接受过255以上的码点而不接受Unicode,所以它们的使用意味着整个字符串的Unicode。</target>
        </trans-unit>
        <trans-unit id="3dbc4a73529270e867678196c4fd9545abf0346b" translate="yes" xml:space="preserve">
          <source>Perl has no special syntax for attributes. Under the hood, attributes are often stored as keys in the object's underlying hash, but don't worry about this.</source>
          <target state="translated">Perl对属性没有特殊的语法。在外壳下,属性通常被存储为对象底层哈希中的键,但不用担心这个问题。</target>
        </trans-unit>
        <trans-unit id="a2deb2a0ce121e98962483bd16f83d982606bfc5" translate="yes" xml:space="preserve">
          <source>Perl has several abbreviations for common character classes. (These definitions are those that Perl uses in ASCII-safe mode with the &lt;code&gt;/a&lt;/code&gt; modifier. Otherwise they could match many more non-ASCII Unicode characters as well. See &lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;Backslash sequences in perlrecharclass&lt;/a&gt; for details.)</source>
          <target state="translated">Perl有几种常见字符类的缩写。（这些定义是Perl在带 &lt;code&gt;/a&lt;/code&gt; 修饰符的ASCII安全模式下使用的定义。否则，它们也可以与更多非ASCII Unicode字符匹配。有关详细信息，请参见&lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;perlrecharclass中的反斜杠序列&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="6e2448e5aa8e9e98f0e99e7fca74328732318a16" translate="yes" xml:space="preserve">
          <source>Perl has special debugging hooks at compile-time and run-time used to create debugging environments. These hooks are not to be confused with the</source>
          <target state="translated">Perl在编译时和运行时都有特殊的调试钩子,用于创建调试环境。这些钩子不能与下面的</target>
        </trans-unit>
        <trans-unit id="0380b6f875ab18989e39e87ecb537accdd5cfd4c" translate="yes" xml:space="preserve">
          <source>Perl has three built-in data types: scalars, arrays of scalars, and associative arrays of scalars, known as &quot;hashes&quot;. A scalar is a single string (of any size, limited only by the available memory), number, or a reference to something (which will be discussed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;). Normal arrays are ordered lists of scalars indexed by number, starting with 0. Hashes are unordered collections of scalar values indexed by their associated string key.</source>
          <target state="translated">Perl具有三种内置的数据类型：标量，标量数组和标量的关联数组，称为&amp;ldquo;哈希&amp;rdquo;。标量是单个字符串（任意大小，仅受可用内存限制），数字或对某物的引用（将在&lt;a href=&quot;perlref&quot;&gt;perlref中&lt;/a&gt;进行讨论）。普通数组是按数字索引的标量的有序列表，从0开始。哈希值是按标量值的无序集合，标量值由其关联的字符串键索引。</target>
        </trans-unit>
        <trans-unit id="fe80e5af445506b27b416f76f8599a7353684bc2" translate="yes" xml:space="preserve">
          <source>Perl has three main variable types: scalars, arrays, and hashes.</source>
          <target state="translated">Perl有三种主要的变量类型:标量、数组和哈希。</target>
        </trans-unit>
        <trans-unit id="5581a893a6439e102c22a8a8e459a544618d9458" translate="yes" xml:space="preserve">
          <source>Perl has three typedefs that handle Perl's three main data types:</source>
          <target state="translated">Perl有三个类型定义来处理Perl的三种主要数据类型。</target>
        </trans-unit>
        <trans-unit id="4982bfdcb9933aa8ea045e6714352b02205f1767" translate="yes" xml:space="preserve">
          <source>Perl has two major annual conventions: The Perl Conference (now part of OSCON), put on by O'Reilly, and Yet Another Perl Conference or YAPC (pronounced yap-see), which is localized into several regional YAPCs (North America, Europe, Asia) in a stunning grassroots display by the Perl community. For more information about either conference, check out their respective web pages: OSCON &lt;a href=&quot;http://conferences.oreillynet.com/&quot;&gt;http://conferences.oreillynet.com/&lt;/a&gt;; YAPC &lt;a href=&quot;http://www.yapc.org&quot;&gt;http://www.yapc.org&lt;/a&gt;.</source>
          <target state="translated">Perl有两个主要的年度大会：由O'Reilly主持的Perl会议（现在是OSCON的一部分），还有另一个Perl会议或YAPC（发音为yap-see），该会议已本地化为几个区域YAPC（北美，欧洲） （亚洲）在Perl社区的令人惊叹的草根展示中。有关任一会议的更多信息，请查看各自的网页：OSCON &lt;a href=&quot;http://conferences.oreillynet.com/&quot;&gt;http://conferences.oreillynet.com/&lt;/a&gt; ; YAPC &lt;a href=&quot;http://www.yapc.org&quot;&gt;http://www.yapc.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b6b908f8c33f304fe3c47ffea7a9a025bc30e32" translate="yes" xml:space="preserve">
          <source>Perl identifiers that begin with digits, control characters, or punctuation characters are exempt from the effects of the &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; declaration and are always forced to be in package &lt;code&gt;main&lt;/code&gt; ; they are also exempt from &lt;code&gt;strict 'vars'&lt;/code&gt; errors. A few other names are also exempt in these ways:</source>
          <target state="translated">以数字，控制字符或标点符号开头的Perl标识符不受 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 声明的影响，并且始终被强制包含在包 &lt;code&gt;main&lt;/code&gt; 中；他们也免于 &lt;code&gt;strict 'vars'&lt;/code&gt; 错误。其他一些名称也可以通过以下方式豁免：</target>
        </trans-unit>
        <trans-unit id="c8fd67f8a70f5e14b6e3a19738244712c763a3d5" translate="yes" xml:space="preserve">
          <source>Perl implements a class using a package, but the presence of a package doesn't imply the presence of a class. A package is just a namespace. A class is a package that provides subroutines that can be used as methods. A method is just a subroutine that expects, as its first argument, either the name of a package (for &quot;static&quot; methods), or a reference to something (for &quot;virtual&quot; methods).</source>
          <target state="translated">Perl用一个包来实现一个类,但包的存在并不意味着一个类的存在。一个包只是一个命名空间。一个类是一个提供子程序的包,这些子程序可以作为方法使用。一个方法只是一个子程序,它的第一个参数是一个包的名称(对于 &quot;静态 &quot;方法),或者是一个对某物的引用(对于 &quot;虚拟 &quot;方法)。</target>
        </trans-unit>
        <trans-unit id="58db3a9b91cfa56f68561f9fa6e162ac6046ad34" translate="yes" xml:space="preserve">
          <source>Perl implements a copy-on-write (COW) mechanism for scalars, in which string copies are not immediately made when requested, but are deferred until made necessary by one or the other scalar changing. This is mostly transparent, but one must take care not to modify string buffers that are shared by multiple SVs.</source>
          <target state="translated">Perl为标量实现了一种写后复制(copy-on-write,COW)机制,即当请求时,不会立即进行字符串复制,而是推迟到一个或另一个标量发生变化而变得必要时才进行。这在很大程度上是透明的,但必须注意不要修改由多个SV共享的字符串缓冲区。</target>
        </trans-unit>
        <trans-unit id="9f2e73e561af14b355b2cc7b94da012ba43ebaff" translate="yes" xml:space="preserve">
          <source>Perl in PASE may be used in the same manner as you would use Perl on AIX.</source>
          <target state="translated">PASE中的Perl可以像在AIX上使用Perl一样使用。</target>
        </trans-unit>
        <trans-unit id="f2a8c9dfcc6b27fc2b2bc1c4e09ed07f063fafcb" translate="yes" xml:space="preserve">
          <source>Perl inserts the contents of &lt;code&gt;$ENV{PERL5DB}&lt;/code&gt; (or &lt;code&gt;BEGIN {&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;
'perl5db.pl'}&lt;/code&gt; if not present) before the first line of your program.</source>
          <target state="translated">Perl中插入的内容 &lt;code&gt;$ENV{PERL5DB}&lt;/code&gt; （或 &lt;code&gt;BEGIN {&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'perl5db.pl'}&lt;/code&gt; 如果不存在）程序的第一行之前。</target>
        </trans-unit>
        <trans-unit id="2a9b4ba7a506b9d41ffb5e3879cb8f3519952178" translate="yes" xml:space="preserve">
          <source>Perl interface to IEEE Std 1003.1</source>
          <target state="translated">IEEE Std 1003.1的Perl接口。</target>
        </trans-unit>
        <trans-unit id="98db74e4a9950c02875b0447d97adf3fab69be22" translate="yes" xml:space="preserve">
          <source>Perl interface to the MD5 Algorithm</source>
          <target state="translated">MD5算法的Perl接口</target>
        </trans-unit>
        <trans-unit id="25640a112f893abdc0c31467980b237692e55c11" translate="yes" xml:space="preserve">
          <source>Perl interface to the UNIX syslog(3) calls</source>
          <target state="translated">的Perl接口,调用UNIX syslog(3)。</target>
        </trans-unit>
        <trans-unit id="eb268cafbb2bc2d6a265535e507a93da4ace82e9" translate="yes" xml:space="preserve">
          <source>Perl interface to various &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; packages.</source>
          <target state="translated">Perl与各种 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 软件包的接口。</target>
        </trans-unit>
        <trans-unit id="532fa58abfc3c5192e3d89ee9b20cda6099a638d" translate="yes" xml:space="preserve">
          <source>Perl interpreter-based threads</source>
          <target state="translated">基于Perl解释器的线程</target>
        </trans-unit>
        <trans-unit id="7813b6fd0cf6ff0fcbbed68e090fa174337973c7" translate="yes" xml:space="preserve">
          <source>Perl is a &lt;b&gt;free-form&lt;/b&gt; language: you can format and indent it however you like. Whitespace serves mostly to separate tokens, unlike languages like Python where it is an important part of the syntax, or Fortran where it is immaterial.</source>
          <target state="translated">Perl是一种&lt;b&gt;自由格式的&lt;/b&gt;语言：您可以按自己的喜好格式化和缩进它。空格主要用于分隔令牌，这与Python等语言（而不是语法的重要组成部分）或Fortran语言（而不是语法）很重要。</target>
        </trans-unit>
        <trans-unit id="78b17861828e1fc00762c322f49cbad21d37d4a9" translate="yes" xml:space="preserve">
          <source>Perl is a general-purpose programming language originally developed for text manipulation and now used for a wide range of tasks including system administration, web development, network programming, GUI development, and more.</source>
          <target state="translated">Perl是一种通用的编程语言,最初是为文本操作而开发的,现在被广泛用于系统管理、网络开发、网络编程、GUI开发等任务。</target>
        </trans-unit>
        <trans-unit id="df24bdffd3ed3137e259ab273c3698d7eedca921" translate="yes" xml:space="preserve">
          <source>Perl is a high-level programming language with an eclectic heritage written by Larry Wall and a cast of thousands.</source>
          <target state="translated">Perl是一种高级编程语言,由Larry Wall和数千名演员编写,具有折中的传统。</target>
        </trans-unit>
        <trans-unit id="8e4a5a9567dfe12d565a7fe3569da1af894be351" translate="yes" xml:space="preserve">
          <source>Perl is a profligate wastrel when it comes to memory use. There is a saying that to estimate memory usage of Perl, assume a reasonable algorithm for memory allocation, multiply that estimate by 10, and while you still may miss the mark, at least you won't be quite so astonished. This is not absolutely true, but may provide a good grasp of what happens.</source>
          <target state="translated">在内存使用方面,Perl是个挥霍无度的废柴。有一种说法是,要估计Perl的内存使用量,假设一个合理的内存分配算法,将这个估计值乘以10,虽然你仍然可能会失误,但至少你不会那么惊讶。这并不是绝对正确的,但可以提供一个很好的把握。</target>
        </trans-unit>
        <trans-unit id="5676662b05d1f0dfe8bee99aada0c212a7cfdcd0" translate="yes" xml:space="preserve">
          <source>Perl is at the mercy of your machine's definitions of various operations such as type casting, atof(), and floating-point output with sprintf().</source>
          <target state="translated">Perl是由你的机器对各种操作的定义所决定的,比如类型转换,atof(),以及用sprintf()进行浮点输出。</target>
        </trans-unit>
        <trans-unit id="1d9807bc15de484f6b43cc02362e93cc66150c42" translate="yes" xml:space="preserve">
          <source>Perl is available for most operating systems, including virtually all Unix-like platforms. See &lt;a href=&quot;perlport#Supported-Platforms&quot;&gt;Supported Platforms in perlport&lt;/a&gt; for a listing.</source>
          <target state="translated">Perl可用于大多数操作系统，包括几乎所有类似Unix的平台。有关列表，请参见&lt;a href=&quot;perlport#Supported-Platforms&quot;&gt;perlport&lt;/a&gt;中的支持的平台。</target>
        </trans-unit>
        <trans-unit id="464c9f17acbbf3521c9fe1d4bfb03f4c8f71635b" translate="yes" xml:space="preserve">
          <source>Perl is binary-clean, so it can handle binary data just fine. On Windows or DOS, however, you have to use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; for binary files to avoid conversions for line endings. In general, you should use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; any time you want to work with binary data.</source>
          <target state="translated">Perl是二进制干净的，因此它可以很好地处理二进制数据。但是，在Windows或DOS上，必须对二进制文件使用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 以避免转换行尾。通常，任何时候要使用二进制数据时，都应使用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="432dc52a3d4248eb12d8ce12a42a4bd4668bcd6d" translate="yes" xml:space="preserve">
          <source>Perl is built using PerlIO by default; Unless you've changed this (such as building Perl with &lt;code&gt;Configure -Uuseperlio&lt;/code&gt; ), you can open filehandles directly to Perl scalars via:</source>
          <target state="translated">默认情况下，Perl是使用PerlIO构建的。除非您进行了更改（例如，使用 &lt;code&gt;Configure -Uuseperlio&lt;/code&gt; 构建Perl ），否则可以通过以下方式直接将文件句柄打开到Perl标量：</target>
        </trans-unit>
        <trans-unit id="7c5ecc6508ddab8f3c4d91e33bbc7e0f0b10c001" translate="yes" xml:space="preserve">
          <source>Perl is built with a &lt;code&gt;$^O&lt;/code&gt; variable that indicates the operating system it was built on. This was implemented to help speed up code that would otherwise have to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; and use the value of &lt;code&gt;$Config{osname}&lt;/code&gt; . Of course, to get more detailed information about the system, looking into &lt;code&gt;%Config&lt;/code&gt; is certainly recommended.</source>
          <target state="translated">Perl是用 &lt;code&gt;$^O&lt;/code&gt; 变量构建的，该变量指示构建它的操作系统。这样做是为了帮助加快代码，而这些代码本来必须 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; 并使用 &lt;code&gt;$Config{osname}&lt;/code&gt; 的值。当然，要获取有关系统的更多详细信息，当然建议查看 &lt;code&gt;%Config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0b403c257bdd4aeec1cd64ac49b8e8696c81aad" translate="yes" xml:space="preserve">
          <source>Perl is designed to make it easy to program securely even when running with extra privileges, like setuid or setgid programs. Unlike most command line shells, which are based on multiple substitution passes on each line of the script, Perl uses a more conventional evaluation scheme with fewer hidden snags. Additionally, because the language has more builtin functionality, it can rely less upon external (and possibly untrustworthy) programs to accomplish its purposes.</source>
          <target state="translated">Perl 的设计目的是为了使它能够轻松安全地进行编程,即使是以额外的权限运行,比如 setuid 或 setgid 程序。与大多数命令行 shell 不同的是,Perl 使用的是更为传统的评估方案,其隐患更少。此外,由于该语言有更多的内置功能,它可以较少地依赖外部(可能是不值得信任的)程序来实现其目的。</target>
        </trans-unit>
        <trans-unit id="95e020b4e0da8b6212d413773e1d9a2f7cfa598b" translate="yes" xml:space="preserve">
          <source>Perl is flexible and extensible enough for you to use on virtually any task, from one-line file-processing tasks to large, elaborate systems.</source>
          <target state="translated">Perl的灵活性和可扩展性足以让你在任何任务中使用,从单行文件处理任务到大型复杂的系统。</target>
        </trans-unit>
        <trans-unit id="6ca32777c65e9c1e819db2ba028d7f7c9855e9eb" translate="yes" xml:space="preserve">
          <source>Perl is generally used in the situation when all the floating-point exceptions are ignored, as is the default under EMX. If they are not ignored, some benign Perl programs would get a &lt;code&gt;SIGFPE&lt;/code&gt; and would die a horrible death.</source>
          <target state="translated">Perl通常用于忽略所有浮点异常的情况，这是EMX中的默认设置。如果不忽略它们，某些良性的Perl程序将获得 &lt;code&gt;SIGFPE&lt;/code&gt; ,并且将死于可怕的死亡。</target>
        </trans-unit>
        <trans-unit id="3df1fe819c8ca8623cc85794dcd13ce337949f92" translate="yes" xml:space="preserve">
          <source>Perl is invoked from the command line as described in &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt;. Most perl scripts, however, do have a first line such as &quot;#!/usr/local/bin/perl&quot;. This is known as a shebang (shell-bang) statement and tells the OS shell where to find the perl interpreter. In Plan 9 Perl this statement should be &quot;#!/bin/perl&quot; if you wish to be able to directly invoke the script by its name. Alternatively, you may invoke perl with the command &quot;Perl&quot; instead of &quot;perl&quot;. This will produce Acme-friendly error messages of the form &quot;filename:18&quot;.</source>
          <target state="translated">如&lt;a href=&quot;perl&quot;&gt;perl中&lt;/a&gt;所述，从命令行调用Perl。但是，大多数perl脚本确实有第一行，例如&amp;ldquo;＃！/ usr / local / bin / perl&amp;rdquo;。这称为shebang（shell-bang）语句，它告诉OS Shell在哪里可以找到perl解释器。在Plan 9 Perl中，如果您希望能够通过脚本名称直接调用该脚本，则该语句应为&amp;ldquo;＃！/ bin / perl&amp;rdquo;。或者，您可以使用命令&amp;ldquo; Perl&amp;rdquo;而不是&amp;ldquo; perl&amp;rdquo;来调用perl。这将产生格式为&amp;ldquo; filename：18&amp;rdquo;的Acme友好错误消息。</target>
        </trans-unit>
        <trans-unit id="e108d57bca9b7851cac34cf12c398ccee3cee194" translate="yes" xml:space="preserve">
          <source>Perl is one of the most ported pieces of software ever. It works on operating systems I've never even heard of (see perlport for details). It needs a build tool that can work on all those platforms and with any wacky C compilers and linkers they might have.</source>
          <target state="translated">Perl 是有史以来移植最多的软件之一。它可以在我从未听说过的操作系统上运行 (详见 perlport)。它需要一个能够在所有这些平台上工作的编译器和链接器的构建工具。</target>
        </trans-unit>
        <trans-unit id="69310d8ba2e9aaba734a13daced6bd681b7dd539" translate="yes" xml:space="preserve">
          <source>Perl is widely renowned for excellence in text processing, and regular expressions are one of the big factors behind this fame. Perl regular expressions display an efficiency and flexibility unknown in most other computer languages. Mastering even the basics of regular expressions will allow you to manipulate text with surprising ease.</source>
          <target state="translated">Perl以其在文本处理方面的卓越表现而广为人知,而正则表达式则是这种名声背后的重要因素之一。Perl正则表达式表现出的效率和灵活性是其他大多数计算机语言所无法比拟的。即使是掌握正则表达式的基础知识,也能让你出人意料地轻松处理文本。</target>
        </trans-unit>
        <trans-unit id="9136a62ad4b5fb86c3834a4ff695ef28ba74673c" translate="yes" xml:space="preserve">
          <source>Perl isn't sure if you meant this</source>
          <target state="translated">Perl不知道你是不是指这个</target>
        </trans-unit>
        <trans-unit id="29e85b3cc84aac2162dbddc5c0e070c097c573e4" translate="yes" xml:space="preserve">
          <source>Perl itself (outside the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module) will not use locales unless specifically requested to (but again note that Perl may interact with code that does use them). Even if there is such a request, &lt;b&gt;all&lt;/b&gt; of the following must be true for it to work properly:</source>
          <target state="translated">除非明确要求，否则Perl本身（在&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块外部）将不使用语言环境（但再次请注意，Perl可能会与使用它们的代码进行交互）。即使有这样的请求，也必须满足以下&lt;b&gt;所有&lt;/b&gt;条件才能使其正常工作：</target>
        </trans-unit>
        <trans-unit id="b448d0fc5ff15548da831acf37af4494d6504c93" translate="yes" xml:space="preserve">
          <source>Perl itself never had a Y2K problem, although that never stopped people from creating Y2K problems on their own. See the documentation for &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; for its proper use.</source>
          <target state="translated">Perl本身从未遇到过Y2K问题，尽管这并没有阻止人们自己创造Y2K问题。请参阅 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 时间文档以正确使用。</target>
        </trans-unit>
        <trans-unit id="44b05ec97c9cd0cd0a392295c641d71beeda8b2c" translate="yes" xml:space="preserve">
          <source>Perl keeps the actual data in a linked list of structures with a typedef of HE. These contain the actual key and value pointers (plus extra administrative overhead). The key is a string pointer; the value is an &lt;code&gt;SV*&lt;/code&gt; . However, once you have an &lt;code&gt;HE*&lt;/code&gt; , to get the actual key and value, use the routines specified below.</source>
          <target state="translated">Perl将实际数据保存在类型为HE的结构的链接列表中。这些包含实际的键和值指针（加上额外的管理开销）。键是一个字符串指针；该值为 &lt;code&gt;SV*&lt;/code&gt; 。但是，一旦有了 &lt;code&gt;HE*&lt;/code&gt; ，要获取实际的键和值，请使用下面指定的例程。</target>
        </trans-unit>
        <trans-unit id="b5143bb91f08dc1c6dfd63a718e07f8c7c54d1b4" translate="yes" xml:space="preserve">
          <source>Perl knows how it stored the string internally, and will use that knowledge when you &lt;code&gt;encode&lt;/code&gt; . In other words: don't try to find out what the internal encoding for a certain string is, but instead just encode it into the encoding that you want.</source>
          <target state="translated">Perl知道它如何在内部存储字符串，并且在 &lt;code&gt;encode&lt;/code&gt; 时会使用该知识。换句话说：不要试图找出某个字符串的内部编码是什么，而只是将其编码为所需的编码。</target>
        </trans-unit>
        <trans-unit id="28c0b3b1efe64d6536aefbbd7df5f013304f845e" translate="yes" xml:space="preserve">
          <source>Perl knows what package the method is in by looking at the left side of the arrow. If the left hand side is a package name, it looks for the method in that package. If the left hand side is an object, then Perl looks for the method in the package that the object has been blessed into.</source>
          <target state="translated">Perl通过看箭头左边的箭头就知道这个方法在哪个包里。如果左手边是包名,那么它就会寻找该包中的方法。如果左手边是一个对象,那么 Perl 会在这个对象被祝福的包中寻找方法。</target>
        </trans-unit>
        <trans-unit id="5816a72e8edbf2978259af959564532c0158a768" translate="yes" xml:space="preserve">
          <source>Perl lets us have complex data structures. You can write something like this and all of a sudden, you'd have an array with three dimensions!</source>
          <target state="translated">Perl让我们拥有复杂的数据结构。你可以写这样的东西,突然间,你就有了一个三维的数组。</target>
        </trans-unit>
        <trans-unit id="c792eeb72bf7222c26382dcf2643ff8d2431a9b2" translate="yes" xml:space="preserve">
          <source>Perl lets you use a scalar variable containing a string as a method name:</source>
          <target state="translated">Perl允许你使用一个包含字符串的标量变量作为方法名。</target>
        </trans-unit>
        <trans-unit id="cbe2b90e37525ab41be0459f402495dfeae82682" translate="yes" xml:space="preserve">
          <source>Perl maintains environment variables in a special hash named &lt;code&gt;%ENV&lt;/code&gt; . For when this access method is inconvenient, the Perl module &lt;code&gt;Env&lt;/code&gt; allows environment variables to be treated as scalar or array variables.</source>
          <target state="translated">Perl在名为 &lt;code&gt;%ENV&lt;/code&gt; 的特殊哈希中维护环境变量。对于这种访问方法不方便的情况，Perl模块 &lt;code&gt;Env&lt;/code&gt; 允许将环境变量视为标量或数组变量。</target>
        </trans-unit>
        <trans-unit id="adff6cd758f5a3032ba367b5b7627b9df7afebcc" translate="yes" xml:space="preserve">
          <source>Perl makes all environment variables available to the program being executed, and passes these along to any child processes it starts. However, programs running setuid would do well to execute the following lines before doing anything else, just to keep people honest:</source>
          <target state="translated">Perl 将所有的环境变量提供给正在执行的程序,并将这些变量传递给它启动的任何子进程。然而,运行 setuid 的程序最好在做其他事情之前先执行以下几行,以保证人们的诚实。</target>
        </trans-unit>
        <trans-unit id="dbb37d4ff4d4f8d3c98e670fbe144d6ded8ac9e4" translate="yes" xml:space="preserve">
          <source>Perl may also use &lt;code&gt;minus()&lt;/code&gt; to implement other operators which have not been specified in the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive, according to the rules for &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;Magic Autogeneration&lt;/a&gt; described later. For example, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; above declared no subroutine for any of the operators &lt;code&gt;--&lt;/code&gt; , &lt;code&gt;neg&lt;/code&gt; (the overload key for unary minus), or &lt;code&gt;-=&lt;/code&gt; . Thus</source>
          <target state="translated">根据&lt;a href=&quot;#Magic-Autogeneration&quot;&gt;稍后&lt;/a&gt;描述的Magic Autogeneration的规则，Perl还可以使用 &lt;code&gt;minus()&lt;/code&gt; 来实现 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 指令中未指定的其他运算符。例如，上述 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 重载对于任何运算符 &lt;code&gt;--&lt;/code&gt; ， &lt;code&gt;neg&lt;/code&gt; （一元减号的重载键）或 &lt;code&gt;-=&lt;/code&gt; 都不声明任何子例程。从而</target>
        </trans-unit>
        <trans-unit id="d02d1a8d8ad8ebaf66f5ae1fae9a8be6973bfe68" translate="yes" xml:space="preserve">
          <source>Perl modifies some standard C library calls in the following ways:</source>
          <target state="translated">Perl用以下方式修改了一些标准的C库调用。</target>
        </trans-unit>
        <trans-unit id="ae2b30d9e1d501c616a9183c5e463ad869566bb9" translate="yes" xml:space="preserve">
          <source>Perl module that imports environment variables as scalars or arrays</source>
          <target state="translated">将环境变量作为标量或数组导入的Perl模块。</target>
        </trans-unit>
        <trans-unit id="5bf20acb7bc71507889f12ba0d9ef4ff255fd169" translate="yes" xml:space="preserve">
          <source>Perl modules &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Resource&quot;&gt;BSD::Resource&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Time::TAI64&quot;&gt;Time::TAI64&lt;/a&gt;.</source>
          <target state="translated">Perl模块&lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Resource&quot;&gt;BSD :: Resource&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Time::TAI64&quot;&gt;Time :: TAI64&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9426f05ffd49561244dd50c76b095078d755129d" translate="yes" xml:space="preserve">
          <source>Perl modules always have a</source>
          <target state="translated">Perl模块总是有一个</target>
        </trans-unit>
        <trans-unit id="51c59ce0ac574ea7f8b9de507be10bf4487a787f" translate="yes" xml:space="preserve">
          <source>Perl modules are included into your program by saying</source>
          <target state="translated">将Perl模块包含在你的程序中,说</target>
        </trans-unit>
        <trans-unit id="aefb322d2fca2dbb6f88aa84174a1e5c7a427c0e" translate="yes" xml:space="preserve">
          <source>Perl modules are not the only tools a performance analyst has at their disposal, system tools like &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; should not be overlooked as the next example shows, where we take a quick look at sorting. Many books, theses and articles, have been written about efficient sorting algorithms, and this is not the place to repeat such work, there's several good sorting modules which deserve taking a look at too: &lt;code&gt;Sort::Maker&lt;/code&gt; , &lt;code&gt;Sort::Key&lt;/code&gt; spring to mind. However, it's still possible to make some observations on certain Perl specific interpretations on issues relating to sorting data sets and give an example or two with regard to how sorting large data volumes can effect performance. Firstly, an often overlooked point when sorting large amounts of data, one can attempt to reduce the data set to be dealt with and in many cases &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; can be quite useful as a simple filter:</source>
          <target state="translated">Perl模块并不是性能分析人员可以使用的唯一工具，下一个示例显示了我们不应该忽略诸如 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 类的系统工具，在此我们快速地进行了排序。已经写了许多关于有效排序算法的书籍，论文和文章，而这里并不是重复此类工作的地方，这里有几个不错的排序模块也值得一看： &lt;code&gt;Sort::Maker&lt;/code&gt; ， &lt;code&gt;Sort::Key&lt;/code&gt; 浮现在脑海。但是，仍然有可能对某些Perl特定的解释进行观察，以解释与排序数据集有关的问题，并给出一两个示例，说明对大数据量进行排序如何影响性能。首先，排序大量数据时经常被忽视的一点是，人们可以尝试减少要处理的数据集，并且在许多情况下， &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; 作为简单的过滤器非常有用：</target>
        </trans-unit>
        <trans-unit id="c8ed366b21e1c4b28e58fe8a9ca47a44e9e81f0c" translate="yes" xml:space="preserve">
          <source>Perl modules included on CPAN have a naming hierarchy you should try to fit in with. See &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for more details on how this works, and browse around CPAN and the modules list to get a feel of it. At the very least, remember this: modules should be title capitalised, (This::Thing) fit in with a category, and explain their purpose succinctly.</source>
          <target state="translated">CPAN包含的Perl模块具有您应尝试使用的命名层次结构。有关如何工作的更多详细信息，请参见&lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt;，并浏览CPAN和模块列表以了解它。至少要记住这一点：模块的标题应大写，（This :: Thing）符合类别，并简要说明其用途。</target>
        </trans-unit>
        <trans-unit id="16a1215b63adeb8dd991dd695ae42ffb9a1eb457" translate="yes" xml:space="preserve">
          <source>Perl modules provide a range of features to help you avoid reinventing the wheel, and can be downloaded from CPAN ( &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; ). A number of popular modules are included with the Perl distribution itself.</source>
          <target state="translated">Perl模块提供了一系列功能来帮助您避免重新发明轮子，并且可以从CPAN（&lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;）下载。Perl发行版本身包含许多流行的模块。</target>
        </trans-unit>
        <trans-unit id="d1cd3ab508bb28b102f16c9bbb53b67e972c7a2d" translate="yes" xml:space="preserve">
          <source>Perl must be compiled with the &lt;code&gt;-Dusedtrace&lt;/code&gt; option in order to make use of the provided probes. While DTrace aims to have no overhead when its instrumentation is not active, Perl's support itself cannot uphold that guarantee, so it is built without DTrace probes under most systems. One notable exception is that Mac OS X ships a</source>
          <target state="translated">为了使用提供的探针，必须使用 &lt;code&gt;-Dusedtrace&lt;/code&gt; 选项编译Perl 。虽然DTrace的目标是在不使用其仪器时不产生任何开销，但Perl的支持本身无法维持这一保证，因此在大多数系统下，它都是在没有DTrace探针的情况下构建的。一个值得注意的例外是Mac OS X附带了</target>
        </trans-unit>
        <trans-unit id="7959a78b422ac56c4b5d4bc26bed7e5e49a45d2d" translate="yes" xml:space="preserve">
          <source>Perl normally assumes character semantics in the presence of character data (i.e. data that has come from a source that has been marked as being of a particular character encoding). When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect, the encoding is temporarily ignored, and each string is treated as a series of bytes.</source>
          <target state="translated">Perl通常在存在字符数据（即来自已被标记为具有特定字符编码的源的数据）的情况下假定字符语义。当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 有效时，将暂时忽略编码，并将每个字符串视为一系列字节。</target>
        </trans-unit>
        <trans-unit id="1b90be8b391bd63ee34d9c789dadd260ffcc448a" translate="yes" xml:space="preserve">
          <source>Perl normally buffers output so it doesn't make a system call for every bit of output. By saving up output, it makes fewer expensive system calls. For instance, in this little bit of code, you want to print a dot to the screen for every line you process to watch the progress of your program. Instead of seeing a dot for every line, Perl buffers the output and you have a long wait before you see a row of 50 dots all at once:</source>
          <target state="translated">Perl通常会对输出进行缓冲,所以它不会为每一点输出进行系统调用。通过保存输出,它可以减少昂贵的系统调用。例如,在这段小代码中,你想为每处理一行打印一个点到屏幕上,以观察程序的进度。Perl会缓冲输出,而不是每行都看到一个点,你要等很久才能一下子看到一排50个点。</target>
        </trans-unit>
        <trans-unit id="431e8ad9293b07f5bdc791f87a08a93d077e2bfe" translate="yes" xml:space="preserve">
          <source>Perl now builds with FreeMiNT/Atari. It fails a few tests, that needs some investigation.</source>
          <target state="translated">Perl现在用FreeMiNT/Atari构建。有几个测试失败了,这需要调查一下。</target>
        </trans-unit>
        <trans-unit id="a3e768752fac3a285306cd9e651f17f9a775de00" translate="yes" xml:space="preserve">
          <source>Perl officially stands for Practical Extraction and Report Language, except when it doesn't.</source>
          <target state="translated">Perl官方代表的是实用提取和报告语言,除了当它不是。</target>
        </trans-unit>
        <trans-unit id="b0646278b43c189bd46c39a69a1dddf12d2a1a29" translate="yes" xml:space="preserve">
          <source>Perl on ILE</source>
          <target state="translated">Perl on ILE</target>
        </trans-unit>
        <trans-unit id="880fc5c1aef63a3507fd91075a126effdad077b7" translate="yes" xml:space="preserve">
          <source>Perl on VMS can accept either VMS- or Unix-style file specifications as in either of the following:</source>
          <target state="translated">VMS上的Perl可以接受VMS或Unix风格的文件规范,如以下任何一种。</target>
        </trans-unit>
        <trans-unit id="4e6cb5edd48ea8ec698a9fa2e92cd3f38a3692ce" translate="yes" xml:space="preserve">
          <source>Perl on VMS is discussed in &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; in the Perl distribution.</source>
          <target state="translated">Perl 发行版中的&lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt;中讨论了VMS上的Perl。</target>
        </trans-unit>
        <trans-unit id="d5aebe7d6ab79a49ac64f2ccd625e787536b0d61" translate="yes" xml:space="preserve">
          <source>Perl on VMS supports an emulation of the forked debugger when Perl is run on a VMS system that has X11 support installed.</source>
          <target state="translated">当Perl在安装了X11支持的VMS系统上运行时,VMS上的Perl支持对forked调试器的模拟。</target>
        </trans-unit>
        <trans-unit id="e4268b27ba1ef13a83b583c860e24d2f36fbf4ec" translate="yes" xml:space="preserve">
          <source>Perl on VOS (also known as OpenVOS) is discussed in</source>
          <target state="translated">VOS上的Perl(也称为OpenVOS)将在下面讨论</target>
        </trans-unit>
        <trans-unit id="30b19fafc5c58735f6b1d4a22aac29cb87b533e0" translate="yes" xml:space="preserve">
          <source>Perl only implements the full form of casefolding, but you can access the simple folds using &lt;a href=&quot;../unicode/ucd#casefold()&quot;&gt;casefold() in Unicode::UCD&lt;/a&gt; and &lt;a href=&quot;../unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt;. For further information on casefolding, refer to the Unicode Standard, specifically sections 3.13 &lt;code&gt;Default Case Operations&lt;/code&gt; , 4.2 &lt;code&gt;Case-Normative&lt;/code&gt; , and 5.18 &lt;code&gt;Case Mappings&lt;/code&gt; , available at &lt;a href=&quot;http://www.unicode.org/versions/latest/&quot;&gt;http://www.unicode.org/versions/latest/&lt;/a&gt;, as well as the Case Charts available at &lt;a href=&quot;http://www.unicode.org/charts/case/&quot;&gt;http://www.unicode.org/charts/case/&lt;/a&gt;.</source>
          <target state="translated">Perl仅实现完整的折叠形式，但是您可以使用&lt;a href=&quot;../unicode/ucd#casefold()&quot;&gt;Unicode :: UCD中的&lt;/a&gt;&lt;a href=&quot;../unicode/ucd#prop_invmap()&quot;&gt;casefold（）&lt;/a&gt;和Unicode :: UCD中的prop_invmap（）来访问简单折叠。有关案例折叠的更多信息，请参见Unicode标准，特别是第3.13节&amp;ldquo; &lt;code&gt;Default Case Operations&lt;/code&gt; ，&amp;ldquo; 4.2 &lt;code&gt;Case-Normative&lt;/code&gt; &amp;rdquo;和&amp;ldquo; 5.18 &lt;code&gt;Case Mappings&lt;/code&gt; ，可从&lt;a href=&quot;http://www.unicode.org/versions/latest/&quot;&gt;http://www.unicode.org/versions/latest/获得&lt;/a&gt;，以及案例表可从&lt;a href=&quot;http://www.unicode.org/charts/case/&quot;&gt;http://www.unicode.org/charts/case/获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03ce9ffc7efddb5ffb70fe53243d42ea4fbb733a" translate="yes" xml:space="preserve">
          <source>Perl only implements the full form of casefolding, but you can access the simple folds using &lt;a href=&quot;unicode/ucd#casefold()&quot;&gt;casefold() in Unicode::UCD&lt;/a&gt; and &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt;. For further information on casefolding, refer to the Unicode Standard, specifically sections 3.13 &lt;code&gt;Default Case Operations&lt;/code&gt; , 4.2 &lt;code&gt;Case-Normative&lt;/code&gt; , and 5.18 &lt;code&gt;Case Mappings&lt;/code&gt; , available at &lt;a href=&quot;http://www.unicode.org/versions/latest/&quot;&gt;http://www.unicode.org/versions/latest/&lt;/a&gt;, as well as the Case Charts available at &lt;a href=&quot;http://www.unicode.org/charts/case/&quot;&gt;http://www.unicode.org/charts/case/&lt;/a&gt;.</source>
          <target state="translated">Perl仅实现完整的折叠形式，但是您可以使用&lt;a href=&quot;unicode/ucd#casefold()&quot;&gt;Unicode :: UCD中的&lt;/a&gt;&lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;casefold（）&lt;/a&gt;和Unicode :: UCD中的prop_invmap（）来访问简单折叠。有关案例折叠的更多信息，请参见Unicode标准，特别是第3.13节&amp;ldquo; &lt;code&gt;Default Case Operations&lt;/code&gt; ，&amp;ldquo; 4.2 &lt;code&gt;Case-Normative&lt;/code&gt; &amp;rdquo;和&amp;ldquo; 5.18 &lt;code&gt;Case Mappings&lt;/code&gt; ，可从&lt;a href=&quot;http://www.unicode.org/versions/latest/&quot;&gt;http://www.unicode.org/versions/latest/获得&lt;/a&gt;，以及案例表可从&lt;a href=&quot;http://www.unicode.org/charts/case/&quot;&gt;http://www.unicode.org/charts/case/获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afa3b7b0cef4f08dacda3735ba0561143481e189" translate="yes" xml:space="preserve">
          <source>Perl operations which take a numeric argument treat that argument in one of four different ways: they may force it to one of the integer/floating/ string formats, or they may behave differently depending on the format of the operand. Forcing a numeric value to a particular format does not change the number stored in the value.</source>
          <target state="translated">Perl 中对数字参数的操作有四种不同的处理方式:它们可能会将参数强制为整数/浮点数/字符串格式中的一种,也可能会根据操作数的格式而采取不同的行为。将一个数值强制为特定的格式并不会改变该数值中存储的数字。</target>
        </trans-unit>
        <trans-unit id="2e266081b45b4d898d18421d1048baf2bfd24b32" translate="yes" xml:space="preserve">
          <source>Perl operators are documented in full in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, but here are a few of the most common ones:</source>
          <target state="translated">Perl的运营商都记录在充满&lt;a href=&quot;perlop&quot;&gt;perlop中&lt;/a&gt;，但这里有一些最常见的：</target>
        </trans-unit>
        <trans-unit id="f67a6a1b456cb0e8982256ff29539f81c3619324" translate="yes" xml:space="preserve">
          <source>Perl operators have the following associativity and precedence, listed from highest precedence to lowest. Operators borrowed from C keep the same precedence relationship with each other, even where C's precedence is slightly screwy. (This makes learning Perl easier for C folks.) With very few exceptions, these all operate on scalar values only, not array values.</source>
          <target state="translated">Perl运算符的关联性和优先性如下,从最高的优先性到最低的优先性排列。从 C 语言借来的操作符之间保持相同的优先级关系,即使是在 C 语言的优先级稍有不顺的地方。(这使得C语言的人学习Perl更容易。)除了极少数例外,这些运算符都只对标量值进行操作,而不是数组值。</target>
        </trans-unit>
        <trans-unit id="979c77e2112ac6d101931348fcf8adccee72ed6b" translate="yes" xml:space="preserve">
          <source>Perl operators that return true or false generally return values that can be safely used as numbers. For example, the relational operators in this section and the equality operators in the next one return &lt;code&gt;1&lt;/code&gt; for true and a special version of the defined empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt; , which counts as a zero but is exempt from warnings about improper numeric conversions, just as &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is.</source>
          <target state="translated">返回true或false的Perl运算符通常返回可以安全地用作数字的值。例如，本节中的关系运算符和下一个运算符中的相等运算符返回 &lt;code&gt;1&lt;/code&gt; 表示true，并且返回已定义的空字符串 &lt;code&gt;&quot;&quot;&lt;/code&gt; 的特殊版本，该字符串算作零，但可以免除有关不正确数字转换的警告，如 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93117613e1464552c05f74263a894f716b02c8a7" translate="yes" xml:space="preserve">
          <source>Perl packages may be nested inside other package names, so we can have package names containing &lt;code&gt;::&lt;/code&gt; . But if we used that package name directly as a filename it would make for unwieldy or impossible filenames on some systems. Therefore, if a module's name is, say, &lt;code&gt;Text::Soundex&lt;/code&gt; , then its definition is actually found in the library file</source>
          <target state="translated">Perl软件包可能嵌套在其他软件包名称中，因此我们可以使用包含 &lt;code&gt;::&lt;/code&gt; 的软件包名称。但是，如果我们直接将该软件包名称用作文件名，则在某些系统上会使文件名变得笨拙或不可能。因此，如果模块的名称为 &lt;code&gt;Text::Soundex&lt;/code&gt; ，则实际上在库文件中可以找到其定义。</target>
        </trans-unit>
        <trans-unit id="07d7fb295d5657e201671476cb88a17b37a54746" translate="yes" xml:space="preserve">
          <source>Perl pragma for deprecating the core version of a module</source>
          <target state="translated">用于废弃模块核心版本的Perl pragma。</target>
        </trans-unit>
        <trans-unit id="4ff2d9baf63466a443978236f7b7cb1cc8bd8db5" translate="yes" xml:space="preserve">
          <source>Perl prefers to &lt;code&gt;dup&lt;/code&gt; the new low-level descriptor to the descriptor used by the existing PerlIO. This may become the behaviour of this function in the future.</source>
          <target state="translated">Perl的喜欢 &lt;code&gt;dup&lt;/code&gt; 新的低级别的描述符由现有的PerlIO的使用的描述符。将来这可能成为此功能的行为。</target>
        </trans-unit>
        <trans-unit id="c2ad17b9a58ab83af39d92dc2a0f734f0896297e" translate="yes" xml:space="preserve">
          <source>Perl programs are just plain text, so any editor will do.</source>
          <target state="translated">Perl程序只是纯文本,所以任何编辑器都可以。</target>
        </trans-unit>
        <trans-unit id="14cf61d2a257794aa1f24ba3ebb61b26c9fd6acc" translate="yes" xml:space="preserve">
          <source>Perl promises, that if we ever add regular expression pattern metacharacters to the dozen already defined (&lt;code&gt;\ | ( ) [ { ^ $ * + ? .&lt;/code&gt; ), that we will only use ones that have the Pattern_Syntax property. Perl also promises, that if we ever add characters that are considered to be white space in regular expressions (currently mostly affected by &lt;code&gt;/x&lt;/code&gt;), they will all have the Pattern_White_Space property.</source>
          <target state="translated">Perl承诺，如果我们将正则表达式模式元字符添加到已经定义的十二个（ &lt;code&gt;\ | ( ) [ { ^ $ * + ? .&lt;/code&gt; ）中，我们将仅使用具有Pattern_Syntax属性的字符。 Perl还承诺，如果我们在正则表达式中添加被视为空白的字符（当前主要受 &lt;code&gt;/x&lt;/code&gt; 影响），它们都将具有Pattern_White_Space属性。</target>
        </trans-unit>
        <trans-unit id="67b6495ec04782f446ea386cb264b80a6975aeb6" translate="yes" xml:space="preserve">
          <source>Perl provides a centralized management of these resources:</source>
          <target state="translated">Perl对这些资源进行了集中管理。</target>
        </trans-unit>
        <trans-unit id="d5560f27b86924c423060a2b1fc2c1981aafcb97" translate="yes" xml:space="preserve">
          <source>Perl provides a fork() keyword that corresponds to the Unix system call of the same name. On most Unix-like platforms where the fork() system call is available, Perl's fork() simply calls it.</source>
          <target state="translated">Perl提供了一个fork()关键字,对应于同名的Unix系统调用。在大多数类似Unix的平台上,只要有fork()系统调用,Perl的fork()就会简单地调用它。</target>
        </trans-unit>
        <trans-unit id="de3af496d08feb146e6538a70938f9e1c88a9d41" translate="yes" xml:space="preserve">
          <source>Perl provides a mechanism for alternative namespaces to protect packages from stomping on each other's variables. In fact, there's really no such thing as a global variable in Perl. The package statement declares the compilation unit as being in the given namespace. The scope of the package declaration is from the declaration itself through the end of the enclosing block, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or file, whichever comes first (the same scope as the my() and local() operators). Unqualified dynamic identifiers will be in this namespace, except for those few identifiers that if unqualified, default to the main package instead of the current one as described below. A package statement affects only dynamic variables--including those you've used local() on--but</source>
          <target state="translated">Perl为替代名称空间提供了一种机制，以保护程序包避免踩踏彼此的变量。实际上，Perl中确实没有全局变量之类的东西。 package语句将编译单元声明为位于给定的名称空间中。程序包声明的范围是从声明本身到封闭的块， &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 或文件的末尾，以先到者为准（与my（）和local（）运算符相同）。不合格的动态标识符将在此命名空间中，除了少数不合格的标识符之外，这些标识符默认为主包而不是当前的主包，如下所述。 package语句仅影响动态变量-包括您使用过local（）的那些变量-但</target>
        </trans-unit>
        <trans-unit id="73112f265f6b41c74dc1c4f6ba58a9aa61493def" translate="yes" xml:space="preserve">
          <source>Perl provides a number of mechanisms to coordinate the interactions between themselves and their data, to avoid race conditions and the like. Some of these are designed to resemble the common techniques used in thread libraries such as &lt;code&gt;pthreads&lt;/code&gt; ; others are Perl-specific. Often, the standard techniques are clumsy and difficult to get right (such as condition waits). Where possible, it is usually easier to use Perlish techniques such as queues, which remove some of the hard work involved.</source>
          <target state="translated">Perl提供了许多机制来协调自身与其数据之间的交互，从而避免出现竞争情况等。其中一些设计类似于线程库中使用的通用技术，如 &lt;code&gt;pthreads&lt;/code&gt; ;其他是Perl特定的。通常，标准技术笨拙且难以正确处理（例如条件等待）。在可能的情况下，通常更容易使用Perlish技术（例如队列），从而消除了一些艰苦的工作。</target>
        </trans-unit>
        <trans-unit id="36e7e1ce7a021b749d35bdf6f3b510a2bf8dd56c" translate="yes" xml:space="preserve">
          <source>Perl provides a reasonably safe way to open a file or pipe from a setuid or setgid program: just create a child process with reduced privilege who does the dirty work for you. First, fork a child using the special &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; syntax that connects the parent and child by a pipe. Now the child resets its ID set and any other per-process attributes, like environment variables, umasks, current working directories, back to the originals or known safe values. Then the child process, which no longer has any special permissions, does the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or other system call. Finally, the child passes the data it managed to access back to the parent. Because the file or pipe was opened in the child while running under less privilege than the parent, it's not apt to be tricked into doing something it shouldn't.</source>
          <target state="translated">Perl提供了一种从setuid或setgid程序中打开文件或管道的相当安全的方法：只需以降低的特权创建一个子进程即可为您执行肮脏的工作。首先，使用特殊的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 语法（通过管道连接父级和子级）派生一个子级。现在，孩子将其ID集和所有其他按进程属性（如环境变量，umask，当前工作目录）重置为原始值或已知的安全值。然后，不再具有任何特殊权限的子进程将执行 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 或其他系统调用。最后，孩子将它设法访问的数据传回给父母。由于文件或管道是在子级中打开的，而其运行权限却比父级低，因此不容易被欺骗去做它不应该做的事情。</target>
        </trans-unit>
        <trans-unit id="01b6956704a1caccc5f1a829b2f6df16370a9f29" translate="yes" xml:space="preserve">
          <source>Perl provides many macros to assist in accessing the Perl stack. Wherever possible, these macros should always be used when interfacing to Perl internals. We hope this should make the code less vulnerable to any changes made to Perl in the future.</source>
          <target state="translated">Perl 提供了许多宏来协助访问 Perl 堆栈。在与Perl内部接口时,应尽可能地使用这些宏。我们希望这样做可以使代码在将来Perl的任何改动中不那么脆弱。</target>
        </trans-unit>
        <trans-unit id="8d83d3e4ff54e649960458ab09222a8186178865" translate="yes" xml:space="preserve">
          <source>Perl provides the function &lt;code&gt;sv_chop&lt;/code&gt; to efficiently remove characters from the beginning of a string; you give it an SV and a pointer to somewhere inside the PV, and it discards everything before the pointer. The efficiency comes by means of a little hack: instead of actually removing the characters, &lt;code&gt;sv_chop&lt;/code&gt; sets the flag &lt;code&gt;OOK&lt;/code&gt; (offset OK) to signal to other functions that the offset hack is in effect, and it moves the PV pointer (called &lt;code&gt;SvPVX&lt;/code&gt; ) forward by the number of bytes chopped off, and adjusts &lt;code&gt;SvCUR&lt;/code&gt; and &lt;code&gt;SvLEN&lt;/code&gt; accordingly. (A portion of the space between the old and new PV pointers is used to store the count of chopped bytes.)</source>
          <target state="translated">Perl提供了 &lt;code&gt;sv_chop&lt;/code&gt; 函数来有效地删除字符串开头的字符。您给它提供了SV和指向PV内部某个位置的指针，并且它丢弃了指针之前的所有内容。效率是通过一点技巧来实现的： &lt;code&gt;sv_chop&lt;/code&gt; 不会实际删除字符，而是设置标志 &lt;code&gt;OOK&lt;/code&gt; （偏移OK）以向其他函数发信号表示偏移技巧已生效，并且向前移动PV指针（称为 &lt;code&gt;SvPVX&lt;/code&gt; ）通过切掉的字节数，并相应地调整 &lt;code&gt;SvCUR&lt;/code&gt; 和 &lt;code&gt;SvLEN&lt;/code&gt; 。 （新旧PV指针之间的一部分空间用于存储切碎字节的计数。）</target>
        </trans-unit>
        <trans-unit id="9513d1ec6023b878e1b94840b432efff780b52df" translate="yes" xml:space="preserve">
          <source>Perl provides two API functions to evaluate pieces of Perl code. These are &lt;a href=&quot;perlapi#eval_sv&quot;&gt;eval_sv in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#eval_pv&quot;&gt;eval_pv in perlapi&lt;/a&gt;.</source>
          <target state="translated">Perl提供了两个API函数来评估Perl代码。这些是&lt;a href=&quot;perlapi#eval_sv&quot;&gt;perlapi中的eval_sv&lt;/a&gt;和&lt;a href=&quot;perlapi#eval_pv&quot;&gt;perlapi中的eval_pv&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ffb39ca049ef57e14f57d4751c1d1ac0f78a02d5" translate="yes" xml:space="preserve">
          <source>Perl recognizes the POSIX character classes &lt;code&gt;[=class=]&lt;/code&gt; and &lt;code&gt;[.class.]&lt;/code&gt;, but does not (yet?) support them. Any attempt to use either construct raises an exception.</source>
          <target state="translated">Perl可以识别POSIX字符类 &lt;code&gt;[=class=]&lt;/code&gt; 和 &lt;code&gt;[.class.]&lt;/code&gt; ，但还不支持（但？）。任何使用这两种构造的尝试都会引发异常。</target>
        </trans-unit>
        <trans-unit id="07f5219960a6f7bb8d18294a65d8b9d67281a7a2" translate="yes" xml:space="preserve">
          <source>Perl recognizes the following POSIX character classes:</source>
          <target state="translated">Perl可以识别以下POSIX字符类。</target>
        </trans-unit>
        <trans-unit id="d60612137eda4aa3ff39ca1a5e535cbfedf6b435" translate="yes" xml:space="preserve">
          <source>Perl regexps also support backreferences, lookaheads, and all kinds of other complex details. Read all about them in &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;, &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;, and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">Perl正则表达式还支持反向引用，超前查找和所有其他复杂的细节。在&lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;，&lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;和&lt;a href=&quot;perlre&quot;&gt;perlre中&lt;/a&gt;阅读有关它们的所有信息。</target>
        </trans-unit>
        <trans-unit id="aa3e77c17de568fb7fabddc21617e1e18fce47ab" translate="yes" xml:space="preserve">
          <source>Perl regexps can handle more than just the standard ASCII character set. Perl supports</source>
          <target state="translated">Perl的regexps可以处理的不仅仅是标准的ASCII字符集。Perl支持</target>
        </trans-unit>
        <trans-unit id="d440475b129d32904159fb94e727dbef0d4e25d9" translate="yes" xml:space="preserve">
          <source>Perl regular expressions have a large range of character classes. Some of the character classes are written as a backslash sequence. We will briefly discuss those here; full details of character classes can be found in &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">Perl正则表达式具有多种字符类。一些字符类被写为反斜杠序列。我们将在这里简要讨论这些内容；字符类的完整详细信息可以在&lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="8ae626456b6ab696d8a1f8c512b2605f948687bc" translate="yes" xml:space="preserve">
          <source>Perl relies on the underlying system for the implementation of &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt;; on some systems, the generated numbers are not random enough (especially on Windows : see &lt;a href=&quot;http://www.perlmonks.org/?node_id=803632&quot;&gt;http://www.perlmonks.org/?node_id=803632&lt;/a&gt;). Several CPAN modules in the &lt;code&gt;Math&lt;/code&gt; namespace implement better pseudorandom generators; see for example &lt;a href=&quot;http://search.cpan.org/perldoc/Math::Random::MT&quot;&gt;Math::Random::MT&lt;/a&gt; (&quot;Mersenne Twister&quot;, fast), or &lt;a href=&quot;http://search.cpan.org/perldoc/Math::TrulyRandom&quot;&gt;Math::TrulyRandom&lt;/a&gt; (uses the imperfections in the system's timer to generate random numbers, which is rather slow). More algorithms for random numbers are described in &quot;Numerical Recipes in C&quot; at &lt;a href=&quot;http://www.nr.com/&quot;&gt;http://www.nr.com/&lt;/a&gt;</source>
          <target state="translated">Perl依靠底层系统来实现 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; ；在某些系统上，生成的数字不够随机（尤其是在Windows上：请参见&lt;a href=&quot;http://www.perlmonks.org/?node_id=803632&quot;&gt;http://www.perlmonks.org/?node_id=803632&lt;/a&gt;）。 &lt;code&gt;Math&lt;/code&gt; 名称空间中的几个CPAN模块实现了更好的伪随机数生成器。参见例如&lt;a href=&quot;http://search.cpan.org/perldoc/Math::Random::MT&quot;&gt;Math :: Random :: MT&lt;/a&gt;（&amp;ldquo; Merenne Twister&amp;rdquo;，快速）或&lt;a href=&quot;http://search.cpan.org/perldoc/Math::TrulyRandom&quot;&gt;Math :: TrulyRandom&lt;/a&gt;（使用系统计时器中的缺陷生成随机数，这相当慢）。有关随机数的更多算法，&lt;a href=&quot;http://www.nr.com/&quot;&gt;请参见http://www.nr.com/上的&lt;/a&gt; &amp;ldquo; C的数字食谱&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="5e8b101afd4e3699b22d8dd044a2afe59a2e5739" translate="yes" xml:space="preserve">
          <source>Perl requires braces following &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , etc.</source>
          <target state="translated">Perl要求在 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; ， &lt;code&gt;foreach&lt;/code&gt; 等后面跟随大括号。</target>
        </trans-unit>
        <trans-unit id="baeb92759bd60617241bdfef388270964c6488e2" translate="yes" xml:space="preserve">
          <source>Perl requires semicolons to separate statements.</source>
          <target state="translated">Perl需要分号来分隔语句。</target>
        </trans-unit>
        <trans-unit id="e643a23b551f0082edc8c39f350e57fa7da27bfb" translate="yes" xml:space="preserve">
          <source>Perl resolves this dilemma by transparently calling a copy constructor before calling a method defined to implement a mutator (&lt;code&gt;--&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; , and so on.). In the above example, when Perl reaches the decrement statement, it makes a copy of the object data in &lt;code&gt;$a&lt;/code&gt; and assigns to &lt;code&gt;$a&lt;/code&gt; a reference to the copied data. Only then does it call &lt;code&gt;decr()&lt;/code&gt; , which alters the copied data, leaving &lt;code&gt;$b&lt;/code&gt; unchanged. Thus the object metaphor is preserved as far as possible, while mathemagical operations still work according to the arithmetic metaphor.</source>
          <target state="translated">Perl通过在调用定义为实现mutator的方法（ &lt;code&gt;--&lt;/code&gt; ， &lt;code&gt;+=&lt;/code&gt; 等）之前透明地调用复制构造函数来解决此难题。在上面的示例中，当Perl到达减量语句时，它将在 &lt;code&gt;$a&lt;/code&gt; 复制对象数据，并向 &lt;code&gt;$a&lt;/code&gt; 分配对复制数据的引用。只有这样，它才会调用 &lt;code&gt;decr()&lt;/code&gt; ，这会更改复制的数据，而保持 &lt;code&gt;$b&lt;/code&gt; 不变。因此，尽可能地保留了对象隐喻，而数学运算仍根据算术隐喻起作用。</target>
        </trans-unit>
        <trans-unit id="e718ff2371b8bf00697a05f6ee1339b450bff042" translate="yes" xml:space="preserve">
          <source>Perl runs &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement at run-time. Once Perl loads, compiles, and runs the file, it doesn't do anything else. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is the same as a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; run at compile-time, but Perl also calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the loaded package. These two are the same:</source>
          <target state="translated">Perl 在运行时运行 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 语句。一旦Perl加载，编译并运行文件，它就不会做任何其他事情。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 的语句是一样的一个 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 在编译时运行，但Perl中也称 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 的加载封装的方法。这两个是相同的：</target>
        </trans-unit>
        <trans-unit id="49c228222cbce8f7e3a32ff65352e2b7ebaf362f" translate="yes" xml:space="preserve">
          <source>Perl runs on e-mail; there is no doubt about it. The Camel book was originally written mostly over e-mail and today Perl's development is co-ordinated through mailing lists. The largest repository of Perl mailing lists is located at &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt;.</source>
          <target state="translated">Perl通过电子邮件运行；这个毋庸置疑。骆驼书最初主要是通过电子邮件撰写的，而如今，Perl的开发是通过邮件列表来协调的。Perl邮件列表的最大存储库位于&lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61dbd8b3aa941e2fad4e470525c952ecca2fe9ad" translate="yes" xml:space="preserve">
          <source>Perl runs on numerous operating systems. While most of them share much in common, they also have their own unique features.</source>
          <target state="translated">Perl可以运行在众多的操作系统上。虽然它们中的大多数有很多共同点,但它们也有自己独特的特点。</target>
        </trans-unit>
        <trans-unit id="421935f6afff0e32fa7e44f720a70058704e68f6" translate="yes" xml:space="preserve">
          <source>Perl runs under Unix Systems Services or USS.</source>
          <target state="translated">Perl在Unix系统服务或USS下运行。</target>
        </trans-unit>
        <trans-unit id="e81d373d15ca40f4e59a6d6a3f7cafb56ab9ed4a" translate="yes" xml:space="preserve">
          <source>Perl scripts on UNIX use the &quot;#!&quot; (a.k.a &quot;shebang&quot;) line to indicate to the OS that it should execute the file using perl. Windows has no comparable means to indicate arbitrary files are executables.</source>
          <target state="translated">UNIX上的Perl脚本使用 &quot;#!&quot;(也就是 &quot;shebang&quot;)行来指示操作系统应该使用perl执行文件。(又名 &quot;shebang&quot;)行来向操作系统表明它应该使用perl执行文件。Windows没有类似的方法来表明任意文件是可执行文件。</target>
        </trans-unit>
        <trans-unit id="c4939ec259a60d684db202bce3bcf1de4f358448" translate="yes" xml:space="preserve">
          <source>Perl seems to allow out-of-range values (greater than 0x10FFFF). By default, out-of-range values are replaced with &lt;code&gt;U+FFFD&lt;/code&gt; (REPLACEMENT CHARACTER) when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt;= 22, or ignored when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;lt;= 20.</source>
          <target state="translated">Perl似乎允许超出范围的值（大于0x10FFFF）。默认情况下，当 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; = 22 时，超出范围的值将替换为 &lt;code&gt;U+FFFD&lt;/code&gt; （REPLACEMENT CHARACTER），而当 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;lt;= 20 时，则将其忽略。</target>
        </trans-unit>
        <trans-unit id="f744319952a7a0f61ea238f46c893e99d13a8174" translate="yes" xml:space="preserve">
          <source>Perl should now build using the win32/Makefile. You will need to edit that file to set</source>
          <target state="translated">Perl 现在应该使用 win32/Makefile 来构建。你需要编辑该文件,将</target>
        </trans-unit>
        <trans-unit id="cb621d78e2af41af5785030c0b682152fd53b938" translate="yes" xml:space="preserve">
          <source>Perl should now build using the win32/Makefile. You will need to edit that file to set CCTYPE to one of MSVC90FREE-MSVC120FREE first.</source>
          <target state="translated">现在Perl应该使用win32/Makefile来构建。你需要先编辑该文件,将 CCTYPE 设置为 MSVC90FREE-MSVC120FREE 中的一个。</target>
        </trans-unit>
        <trans-unit id="0ddc1cc89c294f8f7ab11f0687f3217bbc182d09" translate="yes" xml:space="preserve">
          <source>Perl should remain one language, rather than forking into a byte-oriented Perl and a character-oriented Perl.</source>
          <target state="translated">Perl应该保持一种语言,而不是分叉成面向字节的Perl和面向字符的Perl。</target>
        </trans-unit>
        <trans-unit id="c5c49b8b94391dce923175d25bc4e1e360818232" translate="yes" xml:space="preserve">
          <source>Perl source plays by ANSI C89 rules: no C99 (or C++) extensions. In some cases we have to take pre-ANSI requirements into consideration. You don't care about some particular platform having broken Perl? I hear there is still a strong demand for J2EE programmers.</source>
          <target state="translated">Perl源代码遵循ANSI C89规则:没有C99(或C++)扩展。在某些情况下,我们必须考虑到ANSI之前的要求。你不关心某些特定平台已经破坏了Perl?听说J2EE程序员的需求量还是很大的。</target>
        </trans-unit>
        <trans-unit id="912bb016153409bf0daae81d17c059280f97296b" translate="yes" xml:space="preserve">
          <source>Perl stack pointer), and in the handling of data on the stack when returning from an XSUB. In CODE: sections SP preserves the value which was on entry to the XSUB: SP is on the function pointer (which follows the last parameter). In PPCODE: sections SP is moved backward to the beginning of the parameter list, which allows &lt;code&gt;PUSH*()&lt;/code&gt; macros to place output values in the place Perl expects them to be when the XSUB returns back to Perl.</source>
          <target state="translated">Perl堆栈指针），以及在处理从XSUB返回的堆栈上的数据时。在CODE中：SP保留了XSUB条目上输入的值：SP在函数指针上（位于最后一个参数之后）。在PPCODE中：SP部分向后移到参数列表的开头，这允许 &lt;code&gt;PUSH*()&lt;/code&gt; 宏将输出值放置在XSUB返回Perl时Perl期望它们的位置。</target>
        </trans-unit>
        <trans-unit id="c5c35727bb235feb64e08f5a4e4d865a3344d69d" translate="yes" xml:space="preserve">
          <source>Perl starts scripts which begin with cookies &lt;code&gt;extproc&lt;/code&gt; or &lt;code&gt;#!&lt;/code&gt; directly, without an intervention of shell. Perl uses the same algorithm to find the executable as</source>
          <target state="translated">Perl启动以cookie &lt;code&gt;extproc&lt;/code&gt; 或 &lt;code&gt;#!&lt;/code&gt; 开头的脚本。直接进行，无需shell干预。Perl使用相同的算法查找可执行文件，如下所示：</target>
        </trans-unit>
        <trans-unit id="311066088c9b05b3123661ea7b3305044bcd0edf" translate="yes" xml:space="preserve">
          <source>Perl statements end in a semi-colon:</source>
          <target state="translated">Perl语句以分号结束。</target>
        </trans-unit>
        <trans-unit id="a3110ac0fdedcb6602950b25f9e6691154e84e0e" translate="yes" xml:space="preserve">
          <source>Perl supports Unicode strings as of version 5.6. Such strings may contain wide characters, namely, characters whose ordinal values are greater than 255. This can cause problems for digest algorithms such as SHA that are specified to operate on sequences of bytes.</source>
          <target state="translated">Perl从5.6版本开始支持Unicode字符串。这种字符串可能包含宽字符,即序数值大于255的字符。这可能会给诸如SHA等指定对字节序列进行操作的摘要算法带来问题。</target>
        </trans-unit>
        <trans-unit id="a81cbe4ac67faced842394ca9c16af6e77feb312" translate="yes" xml:space="preserve">
          <source>Perl supports a type of threads called interpreter threads (ithreads). These threads can be used explicitly and implicitly.</source>
          <target state="translated">Perl支持一种叫做解释器线程(ithreads)的线程。这些线程可以显式和隐式使用。</target>
        </trans-unit>
        <trans-unit id="b3ddd3f5c1d03839d509e6149edea808fc6cb5cb" translate="yes" xml:space="preserve">
          <source>Perl supports a very limited kind of compile-time argument checking using function prototyping. This can be declared in either the PROTO section or with a &lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype attribute&lt;/a&gt;. If you declare either of</source>
          <target state="translated">Perl使用函数原型支持非常有限的一种编译时参数检查。可以在PROTO部分或用&lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype属性声明&lt;/a&gt;。如果您声明</target>
        </trans-unit>
        <trans-unit id="4e581f21aad5ef67a96d247b183e3193eac70dc7" translate="yes" xml:space="preserve">
          <source>Perl supports another method invocation syntax called &quot;indirect object&quot; notation. This syntax is called &quot;indirect&quot; because the method comes before the object it is being invoked on.</source>
          <target state="translated">Perl 支持另一种方法调用语法,叫做 &quot;间接对象 &quot;符号。这种语法之所以被称为 &quot;间接&quot;,是因为方法在它被调用的对象之前。</target>
        </trans-unit>
        <trans-unit id="265dfd10b5f2d39d276f9f524b9c6e80cdea3f6c" translate="yes" xml:space="preserve">
          <source>Perl supports both pre-5.6 strings of eight-bit native bytes, and strings of Unicode characters. The general principle is that Perl tries to keep its data as eight-bit bytes for as long as possible, but as soon as Unicodeness cannot be avoided, the data is transparently upgraded to Unicode. Prior to Perl v5.14.0, the upgrade was not completely transparent (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;), and for backwards compatibility, full transparency is not gained unless &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'unicode_strings'&lt;/code&gt; (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;) or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; (or higher) is selected.</source>
          <target state="translated">Perl支持5.6之前的8位本机字节字符串和Unicode字符字符串。一般原则是Perl尝试将其数据尽可能长时间地保持为八位字节，但是一旦无法避免Unicodeness，则将数据透明地升级为Unicode。在Perl v5.14.0之前，升级不是完全透明的（请参见&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode中的Unicode错误&lt;/a&gt;），并且为了向后兼容，除非 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; （请参见&lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;）或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; （或更高版本），否则无法获得完全透明的功能。已选择。</target>
        </trans-unit>
        <trans-unit id="e2d84ca8811712997a8e9f3ad7161c9e75151f4e" translate="yes" xml:space="preserve">
          <source>Perl supports cross-compiling to QNX NTO through the Native Development Kit (NDK) for the Blackberry 10. This means that you can cross-compile for both ARM and x86 versions of the platform.</source>
          <target state="translated">Perl 支持通过黑莓 10 的本地开发工具包(NDK)向 QNX NTO 交叉编译。这意味着您可以对 ARM 和 x86 版本的平台进行交叉编译。</target>
        </trans-unit>
        <trans-unit id="61c6178993abcdebf49b240f9190abe5238c4bb9" translate="yes" xml:space="preserve">
          <source>Perl supports several other ways to call methods besides the &lt;code&gt;$object-&amp;gt;method()&lt;/code&gt; usage we've seen so far.</source>
          <target state="translated">除了到目前为止我们已经看到的 &lt;code&gt;$object-&amp;gt;method()&lt;/code&gt; 用法之外，Perl还支持其他几种方法来调用方法。</target>
        </trans-unit>
        <trans-unit id="39eb141cb70a235796d1c9a3b86085a1c03895dd" translate="yes" xml:space="preserve">
          <source>Perl termcap interface</source>
          <target state="translated">Perl术语帽接口</target>
        </trans-unit>
        <trans-unit id="29dca9ab8b1d3b8377101aae3e9cbe3e4fbc8b16" translate="yes" xml:space="preserve">
          <source>Perl threading is going to work only in Tru64 4.0 and newer releases, older operating releases like 3.2 aren't probably going to work properly with threads.</source>
          <target state="translated">Perl线程只在Tru64 4.0和更新的版本中工作,旧的操作版本如3.2可能无法正常使用线程。</target>
        </trans-unit>
        <trans-unit id="711f6c74d0066ee853703c933b2128a03d5d8197" translate="yes" xml:space="preserve">
          <source>Perl threads mailing list: &lt;a href=&quot;http://lists.perl.org/list/ithreads.html&quot;&gt;http://lists.perl.org/list/ithreads.html&lt;/a&gt;</source>
          <target state="translated">Perl线程邮件列表：&lt;a href=&quot;http://lists.perl.org/list/ithreads.html&quot;&gt;http&lt;/a&gt; : //lists.perl.org/list/ithreads.html</target>
        </trans-unit>
        <trans-unit id="d2559db124cb4f86fc6327b39cc58f5d846e3791" translate="yes" xml:space="preserve">
          <source>Perl tips, autodie</source>
          <target state="translated">Perl 技巧,autodie</target>
        </trans-unit>
        <trans-unit id="417a3338dad2fe5b9c31529d81335ca36b2c6619" translate="yes" xml:space="preserve">
          <source>Perl under AmigaOS lacks some features of perl under UNIX because of deficiencies in the UNIX-emulation, most notably:</source>
          <target state="translated">AmigaOS下的Perl由于UNIX-emulation的缺陷,缺乏UNIX下perl的一些功能,最主要的是。</target>
        </trans-unit>
        <trans-unit id="6de1733b62296869d712e2db6939eb5aa3e92225" translate="yes" xml:space="preserve">
          <source>Perl under DOS lacks some features of perl under UNIX because of deficiencies in the UNIX-emulation, most notably:</source>
          <target state="translated">DOS下的Perl由于UNIX-emulation的缺陷,缺乏UNIX下的perl的一些功能,最主要的是。</target>
        </trans-unit>
        <trans-unit id="fed7e4c0f6346d8e97d2349cf02d579f8a312bef" translate="yes" xml:space="preserve">
          <source>Perl under Mac OS Classic has not been supported since before Perl 5.10 (April 2004).</source>
          <target state="translated">自Perl 5.10(2004年4月)之前,Mac OS Classic下的Perl已经不受支持。</target>
        </trans-unit>
        <trans-unit id="0c71cd98e9f081d421a495772db91702ad362132" translate="yes" xml:space="preserve">
          <source>Perl uses &lt;code&gt;\n&lt;/code&gt; to represent the &quot;logical&quot; newline, where what is logical may depend on the platform in use. In MacPerl, &lt;code&gt;\n&lt;/code&gt; always means &lt;code&gt;\015&lt;/code&gt; . On EBCDIC platforms, &lt;code&gt;\n&lt;/code&gt; could be &lt;code&gt;\025&lt;/code&gt; or &lt;code&gt;\045&lt;/code&gt; . In DOSish perls, &lt;code&gt;\n&lt;/code&gt; usually means &lt;code&gt;\012&lt;/code&gt; , but when accessing a file in &quot;text&quot; mode, perl uses the &lt;code&gt;:crlf&lt;/code&gt; layer that translates it to (or from) &lt;code&gt;\015\012&lt;/code&gt; , depending on whether you're reading or writing. Unix does the same thing on ttys in canonical mode. &lt;code&gt;\015\012&lt;/code&gt; is commonly referred to as CRLF.</source>
          <target state="translated">Perl使用 &lt;code&gt;\n&lt;/code&gt; 表示&amp;ldquo;逻辑&amp;rdquo;换行符，其中逻辑内容可能取决于所使用的平台。在MacPerl中， &lt;code&gt;\n&lt;/code&gt; 始终表示 &lt;code&gt;\015&lt;/code&gt; 。在EBCDIC平台上， &lt;code&gt;\n&lt;/code&gt; 可以是 &lt;code&gt;\025&lt;/code&gt; 或 &lt;code&gt;\045&lt;/code&gt; 。在DOSish perls中， &lt;code&gt;\n&lt;/code&gt; 通常表示 &lt;code&gt;\012&lt;/code&gt; ，但是在以&amp;ldquo;文本&amp;rdquo;模式访问文件时，perl使用 &lt;code&gt;:crlf&lt;/code&gt; 层将其转换为 &lt;code&gt;\015\012&lt;/code&gt; （或从中转换），具体取决于您是在读取还是写入。 Unix在规范模式下对ttys执行相同的操作。 &lt;code&gt;\015\012&lt;/code&gt; 通常称为CRLF。</target>
        </trans-unit>
        <trans-unit id="ef2489d6cf6b9a1519765ae5403d21cedb84ac6c" translate="yes" xml:space="preserve">
          <source>Perl uses UTF-8, internally, for most Unicode strings.</source>
          <target state="translated">Perl内部使用UTF-8来处理大多数Unicode字符串。</target>
        </trans-unit>
        <trans-unit id="a32f78ca0221220c37e8fdc6e6abb5de92126da7" translate="yes" xml:space="preserve">
          <source>Perl uses a reference count-driven garbage collection mechanism. SVs, AVs, or HVs (xV for short in the following) start their life with a reference count of 1. If the reference count of an xV ever drops to 0, then it will be destroyed and its memory made available for reuse.</source>
          <target state="translated">Perl使用了一个引用计数驱动的垃圾收集机制。SV、AV或HV(以下简称xV)以参考计数1开始它们的生命。 如果一个xV的参考计数降到0,那么它将被销毁,其内存将被重新使用。</target>
        </trans-unit>
        <trans-unit id="ffa78748c6c02aeaa5f6c0aa0037a286831d36b3" translate="yes" xml:space="preserve">
          <source>Perl uses a simple signal handling model: the %SIG hash contains names or references of user-installed signal handlers. These handlers will be called with an argument which is the name of the signal that triggered it. A signal may be generated intentionally from a particular keyboard sequence like control-C or control-Z, sent to you from another process, or triggered automatically by the kernel when special events transpire, like a child process exiting, your own process running out of stack space, or hitting a process file-size limit.</source>
          <target state="translated">Perl 使用了一个简单的信号处理模型:%SIG 哈希包含用户安装的信号处理程序的名称或引用。这些处理程序将被调用,其参数是触发它的信号的名称。信号可能是由特定的键盘序列(如control-C或control-Z)有意产生的,也可能是由另一个进程发送给你的,或者是由内核在特殊事件发生时自动触发的,比如一个子进程退出,你自己的进程用完了堆栈空间,或者达到了进程文件大小的限制。</target>
        </trans-unit>
        <trans-unit id="697496faa8f310204a7d494fa53a2d354c2af264" translate="yes" xml:space="preserve">
          <source>Perl uses a special typedef IV which is a simple signed integer type that is guaranteed to be large enough to hold a pointer (as well as an integer). Additionally, there is the UV, which is simply an unsigned IV.</source>
          <target state="translated">Perl 使用了一个特殊的 typedef IV,它是一个简单的有符号的整数类型,保证足够大,可以容纳一个指针(以及一个整数)。此外,还有UV,它是一个简单的无符号IV。</target>
        </trans-unit>
        <trans-unit id="77447e8f55a3fbc6e220b03acaf3a045c7382163" translate="yes" xml:space="preserve">
          <source>Perl uses an internal type called a</source>
          <target state="translated">Perl使用一个内部类型,叫做</target>
        </trans-unit>
        <trans-unit id="dcd23c3b2c97cdf3da72f0a14a98128b56138f99" translate="yes" xml:space="preserve">
          <source>Perl uses its own malloc() under OS/2 - interpreters are usually malloc-bound for speed, but perl is not, since its malloc is lightning-fast. Perl-memory-usage-tuned benchmarks show that Perl's malloc is 5 times quicker than EMX one. I do not have convincing data about memory footprint, but a (pretty random) benchmark showed that Perl's one is 5% better.</source>
          <target state="translated">Perl在OS/2下使用了自己的malloc()--解释器通常是为了速度而被malloc绑定的,但perl不是,因为它的malloc是闪电般的快。Perl-内存使用调整基准显示,Perl的malloc比EMX的快5倍。我没有关于内存占用的令人信服的数据,但是一个(相当随机的)基准测试显示Perl的比EMX的快5%。</target>
        </trans-unit>
        <trans-unit id="aaeb3f63a0dee2460eba26dc00ff361a3a2b8977" translate="yes" xml:space="preserve">
          <source>Perl uses the hardwired-or-customized shell (see &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Perl使用硬连线或自定义的外壳程序（请参阅 &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f56985ba618cbe018e4fc2adbd42f3a731d5d38f" translate="yes" xml:space="preserve">
          <source>Perl uses the same mechanism to produce &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc, so you also pay a price for each pattern that contains capturing parentheses. (To avoid this cost while retaining the grouping behaviour, use the extended regular expression &lt;code&gt;(?: ... )&lt;/code&gt; instead.) But if you never use &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; , then patterns</source>
          <target state="translated">Perl使用相同的机制产生 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等，因此您还为包含捕获括号的每个模式付出了代价。（为了避免在保留分组行为的同时产生此费用，请改用扩展的正则表达式 &lt;code&gt;(?: ... )&lt;/code&gt; 。）但是，如果您从不使用 &lt;code&gt;$&amp;amp;&lt;/code&gt; ， &lt;code&gt;$`&lt;/code&gt; 或 &lt;code&gt;$'&lt;/code&gt; ，则使用模式</target>
        </trans-unit>
        <trans-unit id="729ae7be2e299ed898ba24317c3f470da4a89862" translate="yes" xml:space="preserve">
          <source>Perl v5.6.0 introduced lexical control over the handling of warnings by category. The &lt;code&gt;warnings&lt;/code&gt; pragma generally replaces the command line flag &lt;b&gt;-w&lt;/b&gt;. Documentation on the use of lexical warnings, once partly found in this document, is now found in the &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; documentation.</source>
          <target state="translated">Perl v5.6.0引入了按类别对警告处理的词法控制。该 &lt;code&gt;warnings&lt;/code&gt; 编译通常替换命令行标志&lt;b&gt;-w&lt;/b&gt;。一旦在本文档中找到了有关词汇警告的使用文档，即可在&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;文档中找到。</target>
        </trans-unit>
        <trans-unit id="ed16c3492238f59d6acc4b17eee61789dc827788" translate="yes" xml:space="preserve">
          <source>Perl v5.8 and better allow extended Unicode characters in strings. Such strings cannot be encoded directly, as the base64 encoding is only defined for single-byte characters. The solution is to use the Encode module to select the byte encoding you want. For example:</source>
          <target state="translated">Perl v5.8 和更高版本允许在字符串中使用扩展的 Unicode 字符。这种字符串不能直接编码,因为base64编码只定义了单字节字符。解决办法是使用 Encode 模块来选择你想要的字节编码。例如</target>
        </trans-unit>
        <trans-unit id="fac662f37a6502961fed43d288ed81deaf631ca7" translate="yes" xml:space="preserve">
          <source>Perl v5.8 and better allow extended Unicode characters in strings. Such strings cannot be encoded directly, as the quoted-printable encoding is only defined for single-byte characters. The solution is to use the Encode module to select the byte encoding you want. For example:</source>
          <target state="translated">Perl v5.8 和更高版本允许在字符串中使用扩展的 Unicode 字符。这样的字符串不能直接进行编码,因为引号可打印编码只定义了单字节字符。解决办法是使用Encode模块来选择你想要的字节编码。比如说</target>
        </trans-unit>
        <trans-unit id="ca07f22517f53e73e435cde9502974d6bc1e648d" translate="yes" xml:space="preserve">
          <source>Perl variable names may also be a sequence of digits or a single punctuation or control character (with the literal control character form deprecated). These names are all reserved for special uses by Perl; for example, the all-digits names are used to hold data captured by backreferences after a regular expression match. Perl has a special syntax for the single-control-character names: It understands &lt;code&gt;^X&lt;/code&gt; (caret &lt;code&gt;X&lt;/code&gt; ) to mean the control-&lt;code&gt;X&lt;/code&gt; character. For example, the notation &lt;code&gt;$^W&lt;/code&gt; (dollar-sign caret &lt;code&gt;W&lt;/code&gt; ) is the scalar variable whose name is the single character control-&lt;code&gt;W&lt;/code&gt; . This is better than typing a literal control-&lt;code&gt;W&lt;/code&gt; into your program.</source>
          <target state="translated">Perl变量名称也可以是数字序列或单个标点符号或控制字符（不建议使用文字控制字符形式）。这些名称都保留供Perl特殊使用；例如，全数字名称用于保存正则表达式匹配后由反向引用捕获的数据。 Perl对单控件字符名称有一种特殊的语法：它理解 &lt;code&gt;^X&lt;/code&gt; （插入符号 &lt;code&gt;X&lt;/code&gt; ）表示控件 &lt;code&gt;X&lt;/code&gt; 字符。例如，符号 &lt;code&gt;$^W&lt;/code&gt; （美元符号插入符号 &lt;code&gt;W&lt;/code&gt; ）是标量，其名称是单个字符控制- &lt;code&gt;W&lt;/code&gt; 。这比在程序中键入文字控件 &lt;code&gt;W&lt;/code&gt; 更好。</target>
        </trans-unit>
        <trans-unit id="ed35d8a6334fde91537a85bc31a0ea827797100e" translate="yes" xml:space="preserve">
          <source>Perl variable types</source>
          <target state="translated">Perl变量类型</target>
        </trans-unit>
        <trans-unit id="4045947434895b417a6c84aaed4fd5f8d36c865a" translate="yes" xml:space="preserve">
          <source>Perl variables</source>
          <target state="translated">Perl变量</target>
        </trans-unit>
        <trans-unit id="c155457483cd87781fd4429cf68e8cc70eecc55b" translate="yes" xml:space="preserve">
          <source>Perl versions before 5.8 had in its C source code signal handlers which would catch the signal and possibly run a Perl function that you had set in &lt;code&gt;%SIG&lt;/code&gt; . This violated the rules of signal handling at that level causing perl to dump core. Since version 5.8.0, perl looks at &lt;code&gt;%SIG&lt;/code&gt;&lt;b&gt;after&lt;/b&gt; the signal has been caught, rather than while it is being caught. Previous versions of this answer were incorrect.</source>
          <target state="translated">5.8之前的Perl版本在其C源代码信号处理程序中将捕获信号并可能运行您在 &lt;code&gt;%SIG&lt;/code&gt; 中设置的Perl函数。这违反了该级别的信号处理规则，导致perl转储内核。从5.8.0版开始，perl在捕获信号&lt;b&gt;之后&lt;/b&gt;而不是捕获信号时将查看 &lt;code&gt;%SIG&lt;/code&gt; 。此答案的先前版本不正确。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8eacc0652f9a68bdddb6fbf37bd76bc666b4e50b" translate="yes" xml:space="preserve">
          <source>Perl waits for the subprocess to complete before continuing execution in the current process. As described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, the return value of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is a fake &quot;status&quot; which follows POSIX semantics unless the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; is in effect; see the description of &lt;code&gt;$?&lt;/code&gt; in this document for more detail.</source>
          <target state="translated">Perl在继续在当前进程中执行之前，等待子进程完成。如&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;中所述， &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的返回值是伪造的&amp;ldquo; status&amp;rdquo;，它遵循POSIX语义，除非编译指示 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 有效。看到 &lt;code&gt;$?&lt;/code&gt; 的描述？有关详细信息，请参见本文档。</target>
        </trans-unit>
        <trans-unit id="77bc7bc2d999572b3218f851bcc9845dccf95ea0" translate="yes" xml:space="preserve">
          <source>Perl was born in Unix and can therefore access all common Unix system calls. In non-Unix environments, the functionality of some Unix system calls may not be available or details of the available functionality may differ slightly. The Perl functions affected by this are:</source>
          <target state="translated">Perl诞生于Unix,因此可以访问所有常见的Unix系统调用。在非Unix环境下,一些Unix系统调用的功能可能无法使用,或者可用功能的细节可能略有不同。受此影响的Perl函数有:</target>
        </trans-unit>
        <trans-unit id="749163e214f8798aa3cc386d45ba1c2b25237249" translate="yes" xml:space="preserve">
          <source>Perl was originally a language optimized for scanning arbitrary text files, extracting information from those text files, and printing reports based on that information. It quickly became a good language for many system management tasks. Over the years, Perl has grown into a general-purpose programming language. It's widely used for everything from quick &quot;one-liners&quot; to full-scale application development.</source>
          <target state="translated">Perl最初是一种优化的语言,用于扫描任意文本文件,从这些文本文件中提取信息,并根据这些信息打印报告。它很快就成为了许多系统管理任务的好语言。经过多年的发展,Perl已经成长为一种通用的编程语言。它被广泛用于从快速的 &quot;单行本 &quot;到全面的应用程序开发。</target>
        </trans-unit>
        <trans-unit id="97d7a9a879c5c36fd28bdf27f2f4d6a7f1d3b405" translate="yes" xml:space="preserve">
          <source>Perl was originally written to handle US-ASCII only (that is characters whose ordinal numbers are in the range 0 - 127). And documentation and comments may still use the term ASCII, when sometimes in fact the entire range from 0 - 255 is meant.</source>
          <target state="translated">Perl最初是为了处理US-ASCII码(即序数在0-127范围内的字符)而编写的。文档和注释可能仍然使用ASCII码这个术语,但实际上有时是指0-255的整个范围。</target>
        </trans-unit>
        <trans-unit id="bb45aa3bdb1623dc3032bd795cae4fbe7d4a4df0" translate="yes" xml:space="preserve">
          <source>Perl was ported to Mac OS by Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;. Chris Nandor &amp;lt;pudge@pobox.com&amp;gt; continued development and maintenance for the duration of the port's life.</source>
          <target state="translated">Perth由Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;移植到Mac OS。克里斯&amp;middot;南多（Chris Nandor）&amp;lt;pudge@pobox.com&amp;gt;在该港口的整个使用寿命期间继续进行开发和维护。</target>
        </trans-unit>
        <trans-unit id="5ead554bbd070f695e13f79404f4e374bc4948d2" translate="yes" xml:space="preserve">
          <source>Perl websites come in a variety of forms, but they fit into two large categories: forums and news websites. There are many Perl-related websites, so only a few of the community's largest are mentioned here.</source>
          <target state="translated">Perl网站的形式多种多样,但它们适合分为两大类:论坛和新闻网站。与Perl相关的网站有很多,这里只提到社区中最大的几个网站。</target>
        </trans-unit>
        <trans-unit id="96b1e3be8ed57ad80c83e18b4ef34638cdbe949f" translate="yes" xml:space="preserve">
          <source>Perl will always interpret this as a method call.</source>
          <target state="translated">Perl总是会将其解释为方法调用。</target>
        </trans-unit>
        <trans-unit id="108590eaf1947f78469e9a64442a6238023bfc97" translate="yes" xml:space="preserve">
          <source>Perl will always match at the earliest possible point in the string:</source>
          <target state="translated">Perl总是会在字符串中最早的点进行匹配。</target>
        </trans-unit>
        <trans-unit id="dab60b10c40a3d1c155299bacd4f38f02082cabc" translate="yes" xml:space="preserve">
          <source>Perl will attempt to flush all files opened for output before any operation that may do a fork, but this may not be supported on some platforms (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles.</source>
          <target state="translated">Perl将在执行任何可能进行派生的操作之前尝试刷新所有打开的文件以进行输出，但是在某些平台上可能不支持此操作（请参阅&lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;）。为了安全起见，您可能需要设置 &lt;code&gt;$|&lt;/code&gt; （英语中的$ AUTOFLUSH）或在任何打开的句柄上调用 &lt;code&gt;IO::Handle&lt;/code&gt; 的 &lt;code&gt;autoflush()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="43b0e0c3bc56ba7ca3959a0f5e022566b0153f54" translate="yes" xml:space="preserve">
          <source>Perl will attempt to flush all files opened for output before any operation that may do a fork, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles.</source>
          <target state="translated">Perl将在执行任何可能进行派生的操作之前尝试刷新所有打开的文件以进行输出，但是在某些平台上可能不支持此操作（请参阅&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;）。为了安全起见，您可能需要设置 &lt;code&gt;$|&lt;/code&gt; （英语中的$ AUTOFLUSH）或在任何打开的句柄上调用 &lt;code&gt;IO::Handle&lt;/code&gt; 的 &lt;code&gt;autoflush()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="6bea16b3be61058b5cb516538e14480b80e24dcc" translate="yes" xml:space="preserve">
          <source>Perl will attempt to flush all files opened for output before starting the child process, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;&lt;/code&gt;) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;&lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;&lt;/code&gt; on any open handles.</source>
          <target state="translated">Perl将在启动子进程之前尝试刷新所有打开的文件以进行输出，但是在某些平台上可能不支持此操作（请参阅&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;）。为了安全起见，您可能需要设置 &lt;code&gt;$|&lt;/code&gt; （ &lt;code&gt;$AUTOFLUSH&lt;/code&gt; 中 &lt;code&gt;&lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;&lt;/code&gt; ）或拨打 &lt;code&gt;autoflush()&lt;/code&gt; 的方法 &lt;code&gt;&lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;&lt;/code&gt; 上的任何打开的句柄。</target>
        </trans-unit>
        <trans-unit id="69e6c1ab664ef4d480c4cc1af41e9e1fb158cde3" translate="yes" xml:space="preserve">
          <source>Perl will completely read from all open directory handles until they reach the end of the stream. It will then seekdir() back to the original location and all future readdir() requests will be fulfilled from the cache buffer. That means that neither the directory handle held by the parent process nor the one held by the child process will see any changes made to the directory after the fork() call.</source>
          <target state="translated">Perl 将完全读取所有打开的目录句柄,直到它们到达流的末端。然后它将把seekdir()返回到原来的位置,所有未来的readdir()请求都将从缓存缓冲区中完成。这意味着无论是父进程持有的目录句柄还是子进程持有的目录句柄,都不会在fork()调用后看到对目录的任何更改。</target>
        </trans-unit>
        <trans-unit id="ae724785888abcc4558016f3ec47b4f4e63fe38a" translate="yes" xml:space="preserve">
          <source>Perl will generate an error for a few character properties in Unicode when used in a regular expression. The non-Unihan ones are listed below, with the reasons they are not accepted, perhaps with work-arounds. The short names for the properties are listed enclosed in (parentheses). As described after the list, an installation can change the defaults and choose to accept any of these. The list is machine generated based on the choices made for the installation that generated this document.</source>
          <target state="translated">Perl在正则表达式中使用Unicode中的一些字符属性时,会产生错误。下面列出了非Unihan的属性,以及它们不被接受的原因,也许还有变通的办法。这些属性的简称用(括号)括起来。如列表后所述,安装者可以更改默认值并选择接受其中任何一个。这个列表是根据生成本文档的安装所做的选择而由机器生成的。</target>
        </trans-unit>
        <trans-unit id="8b82b63566b58bfbfd5f88517a9ea3598fc70e2d" translate="yes" xml:space="preserve">
          <source>Perl will not guarantee what the result of the above statements is.</source>
          <target state="translated">Perl不会保证上述语句的结果是什么。</target>
        </trans-unit>
        <trans-unit id="ad11d6c2aaa2cf9eed67c4c4a37abbefb094f00c" translate="yes" xml:space="preserve">
          <source>Perl will print</source>
          <target state="translated">Perl会打印</target>
        </trans-unit>
        <trans-unit id="bf866573cd4df8609484c1bf4b87543aa847fff1" translate="yes" xml:space="preserve">
          <source>Perl will print &lt;code&gt;ONCE UPON A TIME THERE WAS&lt;/code&gt; , assuming, of course, that</source>
          <target state="translated">Perl会一次打印 &lt;code&gt;ONCE UPON A TIME THERE WAS&lt;/code&gt; ，当然，前提是</target>
        </trans-unit>
        <trans-unit id="ef9a0a9d3a3fd7fe149a4004c226420f095952a0" translate="yes" xml:space="preserve">
          <source>Perl will start PM programs from VIO (=text-mode) Perl process in a separate PM session; the opposite is not true: when you start a non-PM program from a PM Perl process, Perl would not run it in a separate session. If a separate session is desired, either ensure that shell will be used, as in &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'cmd /c myprog'&lt;/code&gt; , or start it using optional arguments to system() documented in &lt;code&gt;OS2::Process&lt;/code&gt; module. This is considered to be a feature.</source>
          <target state="translated">Perl将在单独的PM会话中从VIO（=文本模式）Perl进程启动PM程序；反之则不成立：从PM Perl进程启动非PM程序时，Perl不会在单独的会话中运行它。如果需要单独的会话，请确保将使用shell，如 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'cmd /c myprog'&lt;/code&gt; ，或使用 &lt;code&gt;OS2::Process&lt;/code&gt; 模块中记录的system（）的可选参数启动它。这被认为是一个功能。</target>
        </trans-unit>
        <trans-unit id="79467cc317c9e9a63f21c7fa1de773705edf809c" translate="yes" xml:space="preserve">
          <source>Perl word completion module</source>
          <target state="translated">Perl单词完成模块</target>
        </trans-unit>
        <trans-unit id="5a1baab191c5a4cbb8bc8a1bc0cd6292ba8ea600" translate="yes" xml:space="preserve">
          <source>Perl works on a bewildering variety of Unix and Unix-like platforms (see e.g. most of the files in the</source>
          <target state="translated">Perl可以在各种Unix和类似Unix的平台上工作(例如,请看在</target>
        </trans-unit>
        <trans-unit id="5f937e1c9658905a769f6858da3294349601c8d9" translate="yes" xml:space="preserve">
          <source>Perl works with UTF-EBCDIC, a multi-byte encoding. In Perls earlier than v5.22, there may be various bugs in this regard.</source>
          <target state="translated">Perl使用UTF-EBCDIC,这是一种多字节编码。在早于v5.22的Perls中,可能会出现这方面的各种错误。</target>
        </trans-unit>
        <trans-unit id="42414ebda9bd8b337ff75ba9b25023988eae655b" translate="yes" xml:space="preserve">
          <source>Perl workshops are, as the name might suggest, workshops where Perl is taught in a variety of ways. At the workshops, subjects range from a beginner's introduction (such as the Pittsburgh Perl Workshop's &quot;Zero To Perl&quot;) to much more advanced subjects.</source>
          <target state="translated">顾名思义,Perl 工作室是以各种方式教授 Perl 的工作室。讲习班的主题从初级入门(如匹兹堡Perl讲习班的 &quot;零到Perl&quot;)到更高级的主题。</target>
        </trans-unit>
        <trans-unit id="7e6b25cba02b7a0948e7b911d7360593ba8a4f62" translate="yes" xml:space="preserve">
          <source>Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; think all codepoints take up 1 print column, but many take 0 or 2. Here to show that normalization makes no difference, we print out both forms:</source>
          <target state="translated">Perl的 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 认为所有代码点占用1个打印列，但许多代码点占用0或2。这里为了表明规范化没有区别，我们打印了两种形式：</target>
        </trans-unit>
        <trans-unit id="609b12c8bffe220b74d5c614b906ddd9f420fc60" translate="yes" xml:space="preserve">
          <source>Perl's</source>
          <target state="translated">Perl's</target>
        </trans-unit>
        <trans-unit id="c4304adeb0f8bf2fdb8cb6a0ee28ba6a82fef1c9" translate="yes" xml:space="preserve">
          <source>Perl's 'use integer;' changes the behaviour of % and / for scalars, but will not change BigInt's way to do things. This is because under 'use integer' Perl will do what the underlying C thinks is right and this is different for each system. If you need BigInt's behaving exactly like Perl's 'use integer', bug the author to implement it ;)</source>
          <target state="translated">Perl 的 'use integer;' 改变了 % 和/的行为,但不会改变 BigInt 的做事方式。这是因为在'use integer'下,Perl会做底层C认为正确的事情,而这对每个系统都是不同的。如果你需要BigInt的行为与Perl的 &quot;使用整数 &quot;完全一样,请向作者提出要求,让他实现它;)</target>
        </trans-unit>
        <trans-unit id="78408db0ece90050f47f78be2d21f98042f5d6be" translate="yes" xml:space="preserve">
          <source>Perl's &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; permits the following universally-known conversions:</source>
          <target state="translated">Perl的 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 允许进行以下众所周知的转换：</target>
        </trans-unit>
        <trans-unit id="679bce65e9c564373f478362e333d0a68acc42d5" translate="yes" xml:space="preserve">
          <source>Perl's &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; permits the following universally-known conversions:</source>
          <target state="translated">Perl的 &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 允许进行以下众所周知的转换：</target>
        </trans-unit>
        <trans-unit id="53cad962b7a83e25af2f6bf67e501730e16fa363" translate="yes" xml:space="preserve">
          <source>Perl's &lt;code&gt;pprivate&lt;/code&gt; structure</source>
          <target state="translated">Perl的 &lt;code&gt;pprivate&lt;/code&gt; 结构</target>
        </trans-unit>
        <trans-unit id="50b7e56f45ec7b1f922cb2ef554212efaf347a1d" translate="yes" xml:space="preserve">
          <source>Perl's API has changed over time, gaining new features, new functions, increasing its flexibility, and reducing the impact on the C namespace environment (reduced pollution). The header file written by this module, typically</source>
          <target state="translated">Perl的API随着时间的推移发生了变化,获得了新的特性,新的功能,增加了它的灵活性,减少了对C命名空间环境的影响(减少污染)。该模块所写的头文件,通常为</target>
        </trans-unit>
        <trans-unit id="e05aa87f748ad78da85fa4d39c89ae07ccce030e" translate="yes" xml:space="preserve">
          <source>Perl's C-style &lt;code&gt;for&lt;/code&gt; loop works like the corresponding &lt;code&gt;while&lt;/code&gt; loop; that means that this:</source>
          <target state="translated">Perl的C风格的 &lt;code&gt;for&lt;/code&gt; 循环类似于相应的 &lt;code&gt;while&lt;/code&gt; 循环；这意味着：</target>
        </trans-unit>
        <trans-unit id="5db9c37ab5f7f0381d150d83940e69ede28d72bd" translate="yes" xml:space="preserve">
          <source>Perl's IO. Consequently only built-in layers can appear in this list, as external layers (such as &lt;code&gt;:encoding()&lt;/code&gt; ) need IO in order to load them! See &lt;a href=&quot;open&quot;&gt;open pragma&lt;/a&gt; for how to add external encodings as defaults.</source>
          <target state="translated">Perl的IO。因此，只有内置层可以出现在此列表中，因为外部层（例如 &lt;code&gt;:encoding()&lt;/code&gt; ）需要IO才能加载它们！有关如何添加外部编码作为默认值，请参见&lt;a href=&quot;open&quot;&gt;open pragma&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a012002430e5ec63e7214212c95e7a6c13798d5" translate="yes" xml:space="preserve">
          <source>Perl's OO system is class-based. Class-based OO is fairly common. It's used by Java, C++, C#, Python, Ruby, and many other languages. There are other object orientation paradigms as well. JavaScript is the most popular language to use another paradigm. JavaScript's OO system is prototype-based.</source>
          <target state="translated">Perl的OO系统是基于类的。基于类的OO相当普遍。它被Java、C++、C#、Python、Ruby和许多其他语言所使用。还有其他的对象导向范式。JavaScript是使用另一种范式的最流行的语言。JavaScript的OO系统是基于原型的。</target>
        </trans-unit>
        <trans-unit id="f14833bc12320cc5b22e2f7f5922dcba8b20a6ea" translate="yes" xml:space="preserve">
          <source>Perl's Unicode Model</source>
          <target state="translated">Perl的Unicode模型</target>
        </trans-unit>
        <trans-unit id="78c1f3e5a87cf4bde2cfaf198cd9b736e054adc6" translate="yes" xml:space="preserve">
          <source>Perl's Unicode Support</source>
          <target state="translated">Perl的Unicode支持</target>
        </trans-unit>
        <trans-unit id="2f4e8610ccf72680ce428d05cdb3a44400f56202" translate="yes" xml:space="preserve">
          <source>Perl's arrays do not have a fixed size, so you don't need linked lists if you just want to add or remove items. You can use array operations such as &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; to do that.</source>
          <target state="translated">Perl的数组没有固定的大小，因此，如果您只想添加或删除项目，则不需要链接列表。您可以使用 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 等数组操作来执行此操作。</target>
        </trans-unit>
        <trans-unit id="f0829cd34f91158f6d50d3501d1729557f626943" translate="yes" xml:space="preserve">
          <source>Perl's basic open() statement can also be used for unidirectional interprocess communication by either appending or prepending a pipe symbol to the second argument to open(). Here's how to start something up in a child process you intend to write to:</source>
          <target state="translated">Perl的基本open()语句也可以通过在open()的第二个参数上追加或预置一个管道符号来进行单向的进程间通信。下面是如何在你打算写入的子进程中启动一些东西。</target>
        </trans-unit>
        <trans-unit id="f7f15224970f30bbd8cc0d913eabc8b8733adcd9" translate="yes" xml:space="preserve">
          <source>Perl's built-in introspection features are fairly minimal. &lt;code&gt;Moose&lt;/code&gt; builds on top of them and creates a full introspection layer for your classes. This lets you ask questions like &quot;what methods does the File class implement?&quot; It also lets you modify your classes programmatically.</source>
          <target state="translated">Perl的内置自省功能非常少。 &lt;code&gt;Moose&lt;/code&gt; 建立在它们之上，并为您的课程创建了完整的自省层。这使您可以提出诸如&amp;ldquo; File类实现什么方法？&amp;rdquo;之类的问题。它还允许您以编程方式修改类。</target>
        </trans-unit>
        <trans-unit id="45287a14757d133ee14640bcf6c328a91774bc92" translate="yes" xml:space="preserve">
          <source>Perl's builtin flock() function (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details) will call flock(2) if that exists, fcntl(2) if it doesn't (on perl version 5.004 and later), and lockf(3) if neither of the two previous system calls exists. On some systems, it may even use a different form of native locking. Here are some gotchas with Perl's flock():</source>
          <target state="translated">Perl的内置flock（）函数（有关详细信息，请参见&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;）将调用flock（2）（如果存在的话），fcntl（2）（如果不存在）（在perl版本5.004及更高版本上）以及lockf（3）（如果两者都不存在）存在先前的系统调用。在某些系统上，它甚至可以使用其他形式的本机锁定。这是Perl的flock（）的一些陷阱：</target>
        </trans-unit>
        <trans-unit id="f507c173df4e9952b98c777db1766156932095e8" translate="yes" xml:space="preserve">
          <source>Perl's documentation is an important resource for our users. It's incredibly important for Perl's documentation to be reasonably coherent and to accurately reflect the current implementation.</source>
          <target state="translated">Perl 的文档是我们用户的重要资源。让Perl的文档保持合理的连贯性并准确地反映当前的实现是非常重要的。</target>
        </trans-unit>
        <trans-unit id="8e7bbfdbc61f02638ca2efad632597e1e0cf6bad" translate="yes" xml:space="preserve">
          <source>Perl's engine sets this flag if the pattern is &lt;code&gt;\s+&lt;/code&gt;.</source>
          <target state="translated">如果模式为 &lt;code&gt;\s+&lt;/code&gt; 则Perl的引擎会设置此标志。</target>
        </trans-unit>
        <trans-unit id="c7dfeaf28529f5593bf2febfb63757ff3cbe501b" translate="yes" xml:space="preserve">
          <source>Perl's engine sets this flag on empty patterns, this optimization makes &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; //&lt;/code&gt; much faster than it would otherwise be. It's even faster than &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Perl的引擎将此标志设置为空模式，此优化使 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; //&lt;/code&gt; 的速度比原本要快得多。它甚至比 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 快。</target>
        </trans-unit>
        <trans-unit id="ae0e4b0c5f9f6cc7920bb5bbdeff06433a976d20" translate="yes" xml:space="preserve">
          <source>Perl's engine sets this if the pattern is &lt;code&gt;/^/&lt;/code&gt; (&lt;code&gt;plen == 1 &amp;amp;&amp;amp; *exp
== '^'&lt;/code&gt; ), even under &lt;code&gt;/^/s&lt;/code&gt; ; see &lt;a href=&quot;perlfunc&quot;&gt;split&lt;/a&gt;. Of course a different regex engine might want to use the same optimizations with a different syntax.</source>
          <target state="translated">如果模式为 &lt;code&gt;/^/&lt;/code&gt; （ &lt;code&gt;plen == 1 &amp;amp;&amp;amp; *exp == '^'&lt;/code&gt; ），即使在 &lt;code&gt;/^/s&lt;/code&gt; 以下，Perl的引擎也会设置此值；见&lt;a href=&quot;perlfunc&quot;&gt;分裂&lt;/a&gt;。当然，不同的正则表达式引擎可能希望使用具有不同语法的相同优化。</target>
        </trans-unit>
        <trans-unit id="7f1c7280d32070c89f6f598972838907640e2c7c" translate="yes" xml:space="preserve">
          <source>Perl's exception handing (i.e. &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; etc.) is built on top of the low-level &lt;code&gt;setjmp()&lt;/code&gt; /&lt;code&gt;longjmp()&lt;/code&gt; C-library functions. These basically provide a way to capture the current PC and SP registers and later restore them; i.e. a &lt;code&gt;longjmp()&lt;/code&gt; continues at the point in code where a previous &lt;code&gt;setjmp()&lt;/code&gt; was done, with anything further up on the C stack being lost. This is why code should always save values using &lt;code&gt;SAVE_FOO&lt;/code&gt; rather than in auto variables.</source>
          <target state="translated">Perl的异常处理（例如 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 等）建立在底层 &lt;code&gt;setjmp()&lt;/code&gt; / &lt;code&gt;longjmp()&lt;/code&gt; C库函数的顶部。这些基本上提供了一种捕获当前PC和SP寄存器并随后还原它们的方法。也就是说， &lt;code&gt;longjmp()&lt;/code&gt; 在代码中先前执行 &lt;code&gt;setjmp()&lt;/code&gt; 的位置继续，而C堆栈上的所有内容都将丢失。这就是为什么代码应始终使用 &lt;code&gt;SAVE_FOO&lt;/code&gt; 而非自动变量来保存值的原因。</target>
        </trans-unit>
        <trans-unit id="e91c40c4e8331eb78a3c6f0cd54f4782d65eb5ae" translate="yes" xml:space="preserve">
          <source>Perl's exception-handling mechanism is its &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; operator. You can use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;longjmp&lt;/code&gt; . For details of this, see the section on signals, especially the time-out handler for a blocking &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; or the section on &quot;Signals&quot; in</source>
          <target state="translated">Perl的异常处理机制是其 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 运算符。您可以将 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 用作 &lt;code&gt;setjmp&lt;/code&gt; ，将 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 用作 &lt;code&gt;longjmp&lt;/code&gt; 。有关此信息的详细信息，请参见有关信号的部分，尤其是&lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc&lt;/a&gt;中的Signals中的阻塞 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; 的超时处理程序，或有关perSign中的&amp;ldquo; Signals&amp;rdquo;部分</target>
        </trans-unit>
        <trans-unit id="7495373aa18cedc70045dae42e442c9fd6b35bbc" translate="yes" xml:space="preserve">
          <source>Perl's initial DTrace support was added, providing &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; probes.</source>
          <target state="translated">添加了Perl的初始DTrace支持，提供了 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; 探针。</target>
        </trans-unit>
        <trans-unit id="de9d9a267eecc4785713b5ac86a07e677cc17c7d" translate="yes" xml:space="preserve">
          <source>Perl's internal UTF8 flag is called &quot;UTF8&quot;, without a hyphen. It indicates whether a string is internally encoded as &quot;utf8&quot;, also without a hyphen.</source>
          <target state="translated">Perl内部的UTF8标志叫做 &quot;UTF8&quot;,没有连字符。它表示一个字符串是否被内部编码为 &quot;utf8&quot;,也没有连字符。</target>
        </trans-unit>
        <trans-unit id="0c96604288539e03d84ef021ff0e6c92aef63b6c" translate="yes" xml:space="preserve">
          <source>Perl's malloc() uses bucketed allocations. Every request is rounded up to the closest bucket size available, and a bucket is taken from the pool of buckets of that size.</source>
          <target state="translated">Perl的malloc()使用桶式分配。每一个请求都会被四舍五入到最接近的可用桶的大小,然后从该大小的桶池中抽取一个桶。</target>
        </trans-unit>
        <trans-unit id="b579bfa5793ff016b56c6d7d86928d92232797da" translate="yes" xml:space="preserve">
          <source>Perl's moaning about locale problems can be silenced by setting the environment variable &lt;code&gt;PERL_BADLANG&lt;/code&gt; to &quot;0&quot; or &quot;&quot;. This method really just sweeps the problem under the carpet: you tell Perl to shut up even when Perl sees that something is wrong. Do not be surprised if later something locale-dependent misbehaves.</source>
          <target state="translated">通过将环境变量 &lt;code&gt;PERL_BADLANG&lt;/code&gt; 设置为&amp;ldquo; 0&amp;rdquo;或&amp;ldquo;&amp;rdquo;，可以消除 Perl对语言环境问题的抱怨。这种方法确实可以解决所有问题：即使Perl认为出问题了，您也要告诉Perl关闭。如果以后出现某些与语言环境有关的错误行为，请不要感到惊讶。</target>
        </trans-unit>
        <trans-unit id="1f69de9b9e78267eea8d1d7d32a8294de0865cf8" translate="yes" xml:space="preserve">
          <source>Perl's operator overloading facility is completely ignored here. Operator overloading allows user-defined behaviors for numbers, such as operations over arbitrarily large integers, floating points numbers with arbitrary precision, operations over &quot;exotic&quot; numbers such as modular arithmetic or p-adic arithmetic, and so on. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details.</source>
          <target state="translated">这里完全忽略了Perl的运算符重载功能。运算符重载允许用户定义数字的行为，例如，对任意大整数的运算，具有任意精度的浮点数，对&amp;ldquo;异&amp;rdquo;数的运算（例如，模算术或p-adic算术），等等。有关详细信息，请参见&lt;a href=&quot;overload&quot;&gt;重载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="669d7e9913d51876345768dad50e148946b6d1f0" translate="yes" xml:space="preserve">
          <source>Perl's own engine will croak on any attempt to modify the capture variables, to do this in another engine use the following callback (copied from &lt;code&gt;Perl_reg_numbered_buff_store&lt;/code&gt; ):</source>
          <target state="translated">Perl自己的引擎将对尝试修改捕获变量的尝试之以 &lt;code&gt;Perl_reg_numbered_buff_store&lt;/code&gt; ，要在另一个引擎中执行此操作，请使用以下回调（从Perl_reg_numbered_buff_store复制）：</target>
        </trans-unit>
        <trans-unit id="6c9f49d7c7e821b89479c1f1cbb325917aa3145b" translate="yes" xml:space="preserve">
          <source>Perl's packages, namespaces, and some info on classes.</source>
          <target state="translated">Perl的包、命名空间和一些关于类的信息。</target>
        </trans-unit>
        <trans-unit id="4588c5311e33f989f4525ce1f0cd16204a00ea04" translate="yes" xml:space="preserve">
          <source>Perl's process, file, and text manipulation facilities make it particularly well-suited for tasks involving quick prototyping, system utilities, software tools, system management tasks, database access, graphical programming, networking, and web programming.</source>
          <target state="translated">Perl的进程、文件和文本处理功能使它特别适合于涉及快速原型设计、系统实用程序、软件工具、系统管理任务、数据库访问、图形编程、网络和网络编程的任务。</target>
        </trans-unit>
        <trans-unit id="93c38b6a66fe842db97ccbef348de209e8c19b5f" translate="yes" xml:space="preserve">
          <source>Perl's regular expression support is both broad and deep, and is the subject of lengthy documentation in &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;, &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;, and elsewhere. However, in short:</source>
          <target state="translated">Perl的正则表达式支持广泛而深入，并且是&lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;，&lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;和其他地方冗长文档的主题。简而言之：</target>
        </trans-unit>
        <trans-unit id="ff94ebb325d8b09e3a30e14e5986ca64a175f3eb" translate="yes" xml:space="preserve">
          <source>Perl's roots in text processing haven't been forgotten over the years. It still boasts some of the most powerful regular expressions to be found anywhere, and its support for Unicode text is world-class. It handles all kinds of structured text, too, through an extensive collection of extensions. Those libraries, collected in the CPAN, provide ready-made solutions to an astounding array of problems. When they haven't set the standard themselves, they steal from the best -- just like Perl itself.</source>
          <target state="translated">多年来,Perl 在文本处理方面的根基并没有被遗忘。它仍然拥有一些最强大的正则表达式,而且它对 Unicode 文本的支持是世界级的。它还可以通过广泛的扩展库处理各种结构化文本。这些库收集在 CPAN 中,为一系列令人震惊的问题提供了现成的解决方案。当它们自己没有制定标准时,它们就从最好的库中偷取,就像Perl本身一样。</target>
        </trans-unit>
        <trans-unit id="e5126fad405ea6c1a0317bc1b96e0b7052710e86" translate="yes" xml:space="preserve">
          <source>Perl's source code is stored in a Git repository.</source>
          <target state="translated">Perl的源代码存储在Git仓库中。</target>
        </trans-unit>
        <trans-unit id="770b04c9b25881d8dba46acccf2294a181b06ea5" translate="yes" xml:space="preserve">
          <source>Perl's source code, and extensions that want maximum portability, should use the above functions instead of those defined in ANSI C's</source>
          <target state="translated">Perl的源代码,以及希望最大限度地提高可移植性的扩展,应该使用上述函数,而不是ANSI C的</target>
        </trans-unit>
        <trans-unit id="c91e012015b18438a085bd4240921bd7bbe55b97" translate="yes" xml:space="preserve">
          <source>Perl's threading package provides the &lt;code&gt;yield()&lt;/code&gt; function that does this. &lt;code&gt;yield()&lt;/code&gt; is pretty straightforward, and works like this:</source>
          <target state="translated">Perl的线程包提供了 &lt;code&gt;yield()&lt;/code&gt; 函数。 &lt;code&gt;yield()&lt;/code&gt; 非常简单，其工作方式如下：</target>
        </trans-unit>
        <trans-unit id="0d178a4e92aee7a478bcdc3786f5d6c00e61333c" translate="yes" xml:space="preserve">
          <source>Perl's version of &lt;code&gt;strdup()&lt;/code&gt; . Returns a pointer to a newly allocated string which is a duplicate of &lt;code&gt;pv&lt;/code&gt; . The size of the string is determined by &lt;code&gt;strlen()&lt;/code&gt; , which means it may not contain embedded &lt;code&gt;NUL&lt;/code&gt; characters and must have a trailing &lt;code&gt;NUL&lt;/code&gt; . The memory allocated for the new string can be freed with the &lt;code&gt;Safefree()&lt;/code&gt; function.</source>
          <target state="translated">Perl的 &lt;code&gt;strdup()&lt;/code&gt; 版本。返回指向新分配的字符串的指针，该字符串与 &lt;code&gt;pv&lt;/code&gt; 重复。字符串的大小由 &lt;code&gt;strlen()&lt;/code&gt; 确定，这意味着它可能不包含嵌入的 &lt;code&gt;NUL&lt;/code&gt; 字符，并且必须具有尾随 &lt;code&gt;NUL&lt;/code&gt; 。可以使用 &lt;code&gt;Safefree()&lt;/code&gt; 函数释放为新字符串分配的内存。</target>
        </trans-unit>
        <trans-unit id="25b683a4b535a4d7cfe41ce26d997bfe703e18cc" translate="yes" xml:space="preserve">
          <source>Perl's version of what &lt;code&gt;strndup()&lt;/code&gt; would be if it existed. Returns a pointer to a newly allocated string which is a duplicate of the first &lt;code&gt;len&lt;/code&gt; bytes from &lt;code&gt;pv&lt;/code&gt; , plus a trailing &lt;code&gt;NUL&lt;/code&gt; byte. The memory allocated for the new string can be freed with the &lt;code&gt;Safefree()&lt;/code&gt; function.</source>
          <target state="translated">如果存在，则为 &lt;code&gt;strndup()&lt;/code&gt; Perl版本。返回一个指向新分配的字符串的指针，该字符串与 &lt;code&gt;pv&lt;/code&gt; 的前 &lt;code&gt;len&lt;/code&gt; 个字节以及 &lt;code&gt;NUL&lt;/code&gt; 字节重复。可以使用 &lt;code&gt;Safefree()&lt;/code&gt; 函数释放为新字符串分配的内存。</target>
        </trans-unit>
        <trans-unit id="7a524db45cae5747e45efc8dd0850e8e606106b1" translate="yes" xml:space="preserve">
          <source>Perl, for example, is supplied with two types of licence: The GNU GPL and The Artistic Licence (see the files README, Copying, and Artistic, or &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;). Larry has good reasons for NOT just using the GNU GPL.</source>
          <target state="translated">例如，Perl提供了两种类型的许可证：GNU GPL和艺术许可（请参阅文件README，Copying和Artistic或&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt;和&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;）。Larry有充分的理由不只是使用GNU GPL。</target>
        </trans-unit>
        <trans-unit id="7fb2ce1409b2c38c39e7006d8b4053a16eb3cd6a" translate="yes" xml:space="preserve">
          <source>Perl, in most cases, will raise a warning when matching an above-Unicode code point against a Unicode property when the result is &lt;code&gt;TRUE&lt;/code&gt; for &lt;code&gt;\p{}&lt;/code&gt; , and &lt;code&gt;FALSE&lt;/code&gt; for &lt;code&gt;\P{}&lt;/code&gt; . For example:</source>
          <target state="translated">Perl中，在大多数情况下，将针对匹配一个Unicode性的上述的Unicode代码点时当结果是提高警告 &lt;code&gt;TRUE&lt;/code&gt; 为 &lt;code&gt;\p{}&lt;/code&gt; ，和 &lt;code&gt;FALSE&lt;/code&gt; 为 &lt;code&gt;\P{}&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="ca608dbd89f51d5e2692a9f1c25c1e965290836e" translate="yes" xml:space="preserve">
          <source>Perl-Zeitung</source>
          <target state="translated">Perl-Zeitung</target>
        </trans-unit>
        <trans-unit id="ad6b525b8d5c1fb1d32da22f33d9e131f0326e0b" translate="yes" xml:space="preserve">
          <source>Perl.Exe</source>
          <target state="translated">Perl.Exe</target>
        </trans-unit>
        <trans-unit id="9a9aafaa9f4d06797b1c23d69746010b54bd3e53" translate="yes" xml:space="preserve">
          <source>Perl.com has two interesting articles on profiling: &quot;Profiling Perl&quot;, by Simon Cozens, &lt;a href=&quot;http://www.perl.com/lpt/a/850&quot;&gt;http://www.perl.com/lpt/a/850&lt;/a&gt; and &quot;Debugging and Profiling mod_perl Applications&quot;, by Frank Wiles, &lt;a href=&quot;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&quot;&gt;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&lt;/a&gt; .</source>
          <target state="translated">Perl.com上有两篇有关概要分析的有趣文章：Simon Cozens的&amp;ldquo;概要分析Perl&amp;rdquo;，&lt;a href=&quot;http://www.perl.com/lpt/a/850&quot;&gt;http&lt;/a&gt;：//www.perl.com/lpt/a/850 和Frank韦尔斯的&amp;ldquo;调试和概要分析mod_perl应用程序&amp;rdquo;，&lt;a href=&quot;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&quot;&gt;http：/ /www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="59ecc62b49475d2cb5cb7295258de980e7bb9d53" translate="yes" xml:space="preserve">
          <source>Perl.pkg</source>
          <target state="translated">Perl.pkg</target>
        </trans-unit>
        <trans-unit id="047f2fc576481bb11cc4caee3ec1941467bc112a" translate="yes" xml:space="preserve">
          <source>Perl/Pollution/Portability</source>
          <target state="translated">Perl/Pollution/Portability</target>
        </trans-unit>
        <trans-unit id="0fabd9b0cbed286f085c386669bbb624b6ae0be5" translate="yes" xml:space="preserve">
          <source>Perl2Exe ( &lt;a href=&quot;http://www.indigostar.com/perl2exe.htm&quot;&gt;http://www.indigostar.com/perl2exe.htm&lt;/a&gt; ) is a command line program for converting perl scripts to executable files. It targets both Windows and Unix platforms.</source>
          <target state="translated">Perl2Exe（&lt;a href=&quot;http://www.indigostar.com/perl2exe.htm&quot;&gt;http://www.indigostar.com/perl2exe.htm&lt;/a&gt;）是用于将perl脚本转换为可执行文件的命令行程序。它针对Windows和Unix平台。</target>
        </trans-unit>
        <trans-unit id="a58d113e289a5dca1b713eadc28920196d35302a" translate="yes" xml:space="preserve">
          <source>Perl5 Functions not currently supported in Plan 9 Perl</source>
          <target state="translated">Perl5 Plan 9目前不支持的函数 Perl</target>
        </trans-unit>
        <trans-unit id="7cf03298e4568d40fe4a8c254cdea9aeaf4618e7" translate="yes" xml:space="preserve">
          <source>Perl5 access to Berkeley DB version 1.x</source>
          <target state="translated">Perl5访问Berkeley DB 1.x版本。</target>
        </trans-unit>
        <trans-unit id="a6b97c33f7f10f0b285f97ea17573e6970b9aabb" translate="yes" xml:space="preserve">
          <source>Perl5 access to the gdbm library.</source>
          <target state="translated">Perl5对gdbm库的访问。</target>
        </trans-unit>
        <trans-unit id="0f928d45134ea1b82a2f4001e977a9ca5021266a" translate="yes" xml:space="preserve">
          <source>PerlApp</source>
          <target state="translated">PerlApp</target>
        </trans-unit>
        <trans-unit id="1fdc87c61ab4b84ad3bb7770857151e78dcb1fd1" translate="yes" xml:space="preserve">
          <source>PerlBuilder is an integrated development environment for Windows that supports Perl development.</source>
          <target state="translated">PerlBuilder是一个支持Perl开发的Windows集成开发环境。</target>
        </trans-unit>
        <trans-unit id="6649c958c30583d092dd8452f695dfb9e308dc26" translate="yes" xml:space="preserve">
          <source>PerlCE is currently linked with a simple console window, so it also works on non-hpc devices.</source>
          <target state="translated">PerlCE目前与一个简单的控制台窗口相连,所以它也可以在非hpc设备上工作。</target>
        </trans-unit>
        <trans-unit id="7aa73f69917f5eded1a42950facbce7317ea38d8" translate="yes" xml:space="preserve">
          <source>PerlIDE is handy to deal with perlce.</source>
          <target state="translated">PerlIDE是方便处理perlce的。</target>
        </trans-unit>
        <trans-unit id="579ddb2e63a9c9da8567b958430ce3a45a513b30" translate="yes" xml:space="preserve">
          <source>PerlIO</source>
          <target state="translated">PerlIO</target>
        </trans-unit>
        <trans-unit id="2bc2886f7622b1210de6b2d1553751fdf04796f5" translate="yes" xml:space="preserve">
          <source>PerlIO * is a FILE *. This has been the default implementation since the abstraction was introduced in perl5.003_02.</source>
          <target state="translated">PerlIO *是一个FILE *。自从perl5.003_02中引入抽象概念以来,这一直是默认的实现。</target>
        </trans-unit>
        <trans-unit id="71eb144823195b4440065066f28d18b5ab87828c" translate="yes" xml:space="preserve">
          <source>PerlIO - On demand loader for PerlIO layers and root of PerlIO::* name space</source>
          <target state="translated">PerlIO-PerlIO层和PerlIO::*名称空间根的按需加载器。</target>
        </trans-unit>
        <trans-unit id="d16207b42b045b160714ba5de2f5ff0e6ff0943e" translate="yes" xml:space="preserve">
          <source>PerlIO ALWAYS calls this method to make sure it has its own private encoding object.</source>
          <target state="translated">PerlIO 总是调用这个方法来确保它有自己的私有编码对象。</target>
        </trans-unit>
        <trans-unit id="197c942bd2c3920a8495cda350b62bc73882bf34" translate="yes" xml:space="preserve">
          <source>PerlIO is a stack of layers.</source>
          <target state="translated">PerlIO是一个层的堆栈。</target>
        </trans-unit>
        <trans-unit id="439a0e2b9ec37cb15accbd0aa170c3040534253a" translate="yes" xml:space="preserve">
          <source>PerlIO layer for quoted-printable strings</source>
          <target state="translated">可引用打印字符串的PerlIO层。</target>
        </trans-unit>
        <trans-unit id="6870089453c5b7ff02d4f86fa5b13e128f37bf93" translate="yes" xml:space="preserve">
          <source>PerlIO material contributed by Lupe Christoph, with some clarification by Nick Ing-Simmons.</source>
          <target state="translated">PerlIO材料由Lupe Christoph贡献,Nick Ing-Simmons做了一些澄清。</target>
        </trans-unit>
        <trans-unit id="820323203cd8f8b2a76e01512d15f3f0590e6729" translate="yes" xml:space="preserve">
          <source>PerlIO overrides the default Cygwin Text/Binary behaviour. A file will always be treated as binary, regardless of the mode of the mount it lives on, just like it is in UNIX. So CR/LF translation needs to be requested in either the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; call like this:</source>
          <target state="translated">PerlIO会覆盖默认的Cygwin文本/二进制行为。就像文件在UNIX中一样，无论文件位于哪种装载模式，它都将始终被视为二进制文件。因此，需要在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 调用中请求CR / LF转换，如下所示：</target>
        </trans-unit>
        <trans-unit id="d4261eaed3053779b6ac602dc0094ca271817116" translate="yes" xml:space="preserve">
          <source>PerlIO.pm</source>
          <target state="translated">PerlIO.pm</target>
        </trans-unit>
        <trans-unit id="1154ad98b215ecf5df7b1e7ad79cee31862d0eaf" translate="yes" xml:space="preserve">
          <source>PerlIO::encoding</source>
          <target state="translated">PerlIO::encoding</target>
        </trans-unit>
        <trans-unit id="0bd3d0c97f8a1994a38840e4b2078cd8c7618564" translate="yes" xml:space="preserve">
          <source>PerlIO::encoding - encoding layer</source>
          <target state="translated">PerlIO::encoding-编码层</target>
        </trans-unit>
        <trans-unit id="1ed740d1e5082e67b34e9a633e9e92164f2f7b46" translate="yes" xml:space="preserve">
          <source>PerlIO::encoding, PerlIO::scalar, PerlIO::via in the Perl core.</source>
          <target state="translated">PerlIO::编码、PerlIO::标量、PerlIO::via在Perl核心。</target>
        </trans-unit>
        <trans-unit id="c62625c5db5d75cf0d983910b623b95f9bd27b6e" translate="yes" xml:space="preserve">
          <source>PerlIO::gzip and APR::PerlIO (mod_perl 2.0) on CPAN.</source>
          <target state="translated">PerlIO::gzip 和 APR::PerlIO (mod_perl 2.0)在 CPAN 上。</target>
        </trans-unit>
        <trans-unit id="b76466d411ce33a97489bbc61bc858849f23c2d6" translate="yes" xml:space="preserve">
          <source>PerlIO::scalar</source>
          <target state="translated">PerlIO::scalar</target>
        </trans-unit>
        <trans-unit id="68b32bd3bc2551440298bb2d6347e307a14d02ff" translate="yes" xml:space="preserve">
          <source>PerlIO::scalar - in-memory IO, scalar IO</source>
          <target state="translated">PerlIO::scalar-内存中的IO,标量IO</target>
        </trans-unit>
        <trans-unit id="6f4147b27883b678d3b28400a2747841090cc49c" translate="yes" xml:space="preserve">
          <source>PerlIO::via</source>
          <target state="translated">PerlIO::via</target>
        </trans-unit>
        <trans-unit id="d69e5b0660da6ada8428bd96b3dfa15197a8ec90" translate="yes" xml:space="preserve">
          <source>PerlIO::via - Helper class for PerlIO layers implemented in perl</source>
          <target state="translated">PerlIO::via-在perl中实现的PerlIO层的辅助类。</target>
        </trans-unit>
        <trans-unit id="c1ddecb6a7a6597042738bddffe28139074d4d7b" translate="yes" xml:space="preserve">
          <source>PerlIO::via::QuotedPrint</source>
          <target state="translated">PerlIO::via::QuotedPrint</target>
        </trans-unit>
        <trans-unit id="82ccb99b92622bcc0fc58d955a6b7496cc1351ac" translate="yes" xml:space="preserve">
          <source>PerlIO::via::QuotedPrint - PerlIO layer for quoted-printable strings</source>
          <target state="translated">PerlIO::via::QuotedPrint-用于引用打印字符串的PerlIO层。</target>
        </trans-unit>
        <trans-unit id="60e19b81fad8ebbf88c9ee26060f85ab35b8d0b9" translate="yes" xml:space="preserve">
          <source>PerlIO::via::QuotedPrint in the Perl core and PerlIO::via::* on CPAN.</source>
          <target state="translated">PerlIO::via::QuotedPrint在Perl核心和PerlIO::via::*在CPAN上。</target>
        </trans-unit>
        <trans-unit id="031a53d77ac71ec3ef46da5f59553f918d566426" translate="yes" xml:space="preserve">
          <source>PerlIOBase(PerlIO *f) returns the &quot;Base&quot; pointer, or in other words, the &lt;code&gt;PerlIOl*&lt;/code&gt; pointer.</source>
          <target state="translated">PerlIOBase（PerlIO * f）返回&amp;ldquo; Base&amp;rdquo;指针，或者换句话说， &lt;code&gt;PerlIOl*&lt;/code&gt; 指针。</target>
        </trans-unit>
        <trans-unit id="b34114bdf01a0e654170651a1a2e3dc55613845c" translate="yes" xml:space="preserve">
          <source>PerlIOSelf(PerlIO* f, type) return the PerlIOBase cast to a type.</source>
          <target state="translated">PerlIOSelf(PerlIO*f,type)返回PerlIOBase的类型。</target>
        </trans-unit>
        <trans-unit id="0255e27b57dfc3265eea6731c6b0c7839e9ab42d" translate="yes" xml:space="preserve">
          <source>PerlIO_debug is a printf()-like function which can be used for debugging. No return value. Its main use is inside PerlIO where using real printf, warn() etc. would recursively call PerlIO and be a problem.</source>
          <target state="translated">PerlIO_debug 是一个类似 printf()的函数,可以用来调试。没有返回值。它的主要用途是在PerlIO内部,如果使用真正的printf、warning()等函数,会递归调用PerlIO,会有问题。</target>
        </trans-unit>
        <trans-unit id="8a0fff3fc1334ecf07d826a061819bfc08e3aaea" translate="yes" xml:space="preserve">
          <source>PerlIO_debug writes to the file named by $ENV{'PERLIO_DEBUG'} typical use might be</source>
          <target state="translated">PerlIO_debug会写入以$ENV{'PERLIO_DEBUG'}命名的文件,典型的用法是</target>
        </trans-unit>
        <trans-unit id="3557c0fab3f26cfdec99b940ea71520d75ea2ee0" translate="yes" xml:space="preserve">
          <source>PerlInterpreter</source>
          <target state="translated">PerlInterpreter</target>
        </trans-unit>
        <trans-unit id="6feba0dc339a322bf408c0ef0a0d56e7e1816aa9" translate="yes" xml:space="preserve">
          <source>PerlMonks is one of the largest Perl forums, and describes itself as &quot;A place for individuals to polish, improve, and showcase their Perl skills.&quot; and &quot;A community which allows everyone to grow and learn from each other.&quot;</source>
          <target state="translated">PerlMonks是最大的Perl论坛之一,它自称是 &quot;个人打磨、提高和展示Perl技能的地方。&quot;、&quot;一个让大家互相成长和学习的社区。&quot;</target>
        </trans-unit>
        <trans-unit id="96118a64fd38dbd81e3cb0e3744963bd1d54ba7a" translate="yes" xml:space="preserve">
          <source>PerlPower()</source>
          <target state="translated">PerlPower()</target>
        </trans-unit>
        <trans-unit id="db63ab2940f098200e4ac58afc78b248f4d2fcb2" translate="yes" xml:space="preserve">
          <source>PerlShr.Exe</source>
          <target state="translated">PerlShr.Exe</target>
        </trans-unit>
        <trans-unit id="07121cdb0e428e6add9cbaefd2f84414e43aa38b" translate="yes" xml:space="preserve">
          <source>Perl_PerlIO_or_Base(PerlIO* f, callback, base, failure, args) either calls the</source>
          <target state="translated">Perl_PerlIO_or_Base(PerlIO*f,callback,base,failure,args)要么调用了</target>
        </trans-unit>
        <trans-unit id="2f0f41f617e9b822c0919fb0f159f1a51c8bb029" translate="yes" xml:space="preserve">
          <source>Perl_PerlIO_or_Base_void(PerlIO* f, callback, base, args) either calls the</source>
          <target state="translated">Perl_PerlIO_or_Base_void(PerlIO*f,callback,base,args)可以调用</target>
        </trans-unit>
        <trans-unit id="81a3f26af0ca1bd5eb03eba445b883c96fd6bebb" translate="yes" xml:space="preserve">
          <source>Perl_PerlIO_or_fail(PerlIO* f, callback, failure, args) either calls the</source>
          <target state="translated">Perl_PerlIO_or_fail(PerlIO*f,callback,failure,args)可以调用</target>
        </trans-unit>
        <trans-unit id="e4851451f4653d2e45acca412261ea7befab27cf" translate="yes" xml:space="preserve">
          <source>Perl_PerlIO_or_fail_void(PerlIO* f, callback, args) either calls the</source>
          <target state="translated">Perl_PerlIO_or_fail_void(PerlIO*f,callback,args)可以调用</target>
        </trans-unit>
        <trans-unit id="2bd7ba33bc197c1cac645c3fa7496edd8205233d" translate="yes" xml:space="preserve">
          <source>Perl_isinfnan() is utility function that returns true if the NV argument is either an infinity or a NaN, false otherwise. To test in more detail, use Perl_isinf() and Perl_isnan().</source>
          <target state="translated">Perl_isinfnan()是一个实用函数,如果 NV 参数是无穷大或 NaN,则返回 true,否则返回 false。要进行更详细的测试,请使用 Perl_isinf()和 Perl_isnan()。</target>
        </trans-unit>
        <trans-unit id="435a6fd71f06655224907356e4d56d72c377a1bd" translate="yes" xml:space="preserve">
          <source>Perls starting in 5.8 have a different Unicode model from 5.6. In 5.6 the programmer was required to use the &lt;code&gt;utf8&lt;/code&gt; pragma to declare that a given scope expected to deal with Unicode data and had to make sure that only Unicode data were reaching that scope. If you have code that is working with 5.6, you will need some of the following adjustments to your code. The examples are written such that the code will continue to work under 5.6, so you should be safe to try them out.</source>
          <target state="translated">从5.8开始的Perls具有与5.6不同的Unicode模型。在5.6中，要求程序员使用 &lt;code&gt;utf8&lt;/code&gt; 编译指示声明给定范围希望处理Unicode数据，并且必须确保只有Unicode数据才能到达该范围。如果您有使用5.6的代码，则需要对代码进行以下一些调整。编写示例以使代码在5.6下可以继续工作，因此您应该安全地尝试它们。</target>
        </trans-unit>
        <trans-unit id="b95bc9c4bdba73fd23a6e99cb0cb35ee28a07aa3" translate="yes" xml:space="preserve">
          <source>Permanently attach to the shared memory segment. When a &lt;code&gt;IPC::SharedMem&lt;/code&gt; object is attached, it will use &lt;a href=&quot;http://search.cpan.org/perldoc/memread&quot;&gt;memread&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/memwrite&quot;&gt;memwrite&lt;/a&gt; instead of &lt;a href=&quot;../functions/shmread&quot;&gt;shmread&lt;/a&gt; and &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt; for accessing the shared memory segment. Returns true if successful, or false on error. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;.</source>
          <target state="translated">永久附加到共享内存段。当一个 &lt;code&gt;IPC::SharedMem&lt;/code&gt; 物体附着，它将使用&lt;a href=&quot;http://search.cpan.org/perldoc/memread&quot;&gt;memread&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/memwrite&quot;&gt;memwrite&lt;/a&gt;代替&lt;a href=&quot;../functions/shmread&quot;&gt;shmread&lt;/a&gt;和&lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;用于访问共享存储器段。如果成功，则返回true；如果错误，则返回false。参见&lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17c52fa4da091dd586a97843497807bc0e23a069" translate="yes" xml:space="preserve">
          <source>Permanently fixing locale problems</source>
          <target state="translated">永久性地解决地域问题</target>
        </trans-unit>
        <trans-unit id="2cf2947e5f569b9ea7e16800990428360247021e" translate="yes" xml:space="preserve">
          <source>Permanently fixing your system's locale configuration</source>
          <target state="translated">永久修复您的系统的locale配置。</target>
        </trans-unit>
        <trans-unit id="9ab7f14d670c62039e207778bc0fed042486426a" translate="yes" xml:space="preserve">
          <source>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</source>
          <target state="translated">兹免费允许任何获得本软件和相关文档文件(&quot;软件&quot;)的人不受限制地使用本软件,包括但不限于使用、复制、修改、合并、出版、分发、再许可和/或出售本软件的权利,并允许接受本软件的人在以下条件下这样做:</target>
        </trans-unit>
        <trans-unit id="78d9cc4b4fc45291ef4d268d18882d87b86fac76" translate="yes" xml:space="preserve">
          <source>Permit</source>
          <target state="translated">Permit</target>
        </trans-unit>
        <trans-unit id="0f8250826e3e169df1c1ab3f1a4991fb276b498f" translate="yes" xml:space="preserve">
          <source>Permit the listed operators to be used when compiling code in the compartment (in</source>
          <target state="translated">允许在车厢内编译代码时使用列出的操作符(在</target>
        </trans-unit>
        <trans-unit id="b7871f509f5f98e4d602975abaec93401e8fa9c5" translate="yes" xml:space="preserve">
          <source>Persistence for Perl data structures</source>
          <target state="translated">Perl数据结构的持久性</target>
        </trans-unit>
        <trans-unit id="f887bea11bbedab00d763b35a7c513eee8986177" translate="yes" xml:space="preserve">
          <source>Persistent Private Variables</source>
          <target state="translated">永久性私有变量</target>
        </trans-unit>
        <trans-unit id="37fcb2b67d89818ceecfdb67f2459b636da00b36" translate="yes" xml:space="preserve">
          <source>Persistent variables via state()</source>
          <target state="translated">通过state()的持久性变量</target>
        </trans-unit>
        <trans-unit id="2e14d0f6039c4bed4f250852e11a5960cec217cc" translate="yes" xml:space="preserve">
          <source>Persistent variables with closures</source>
          <target state="translated">带闭合的持久性变量</target>
        </trans-unit>
        <trans-unit id="297062bf4f638f4e5a1559e426d9dca1019c35bc" translate="yes" xml:space="preserve">
          <source>Peter J. Farley III</source>
          <target state="translated">Peter J.Farley III</target>
        </trans-unit>
        <trans-unit id="2443526b197b82e6711ce47499d4a744b2d3caac" translate="yes" xml:space="preserve">
          <source>Peter John Acklam</source>
          <target state="translated">Peter John Acklam</target>
        </trans-unit>
        <trans-unit id="a32278777d03ff2e6b6ad59e9b3657ba9315fcef" translate="yes" xml:space="preserve">
          <source>Peter Prymmer</source>
          <target state="translated">Peter Prymmer</target>
        </trans-unit>
        <trans-unit id="c3032976541bf9515b50f93b039ec87133fcbe77" translate="yes" xml:space="preserve">
          <source>Peter Prymmer pvhp@best.com wrote this in 1999 and 2000 with CCSID 0819 and 0037 help from Chris Leach and Andr&amp;eacute; Pirard A.Pirard@ulg.ac.be as well as POSIX-BC help from Thomas Dorner Thomas.Dorner@start.de. Thanks also to Vickie Cooper, Philip Newton, William Raffloer, and Joe Smith. Trademarks, registered trademarks, service marks and registered service marks used in this document are the property of their respective owners.</source>
          <target state="translated">Peter Prymmer pvhp@best.com在1999和2000年用Chris Leach和Andr&amp;eacute;Pirard A.Pirard@ulg.ac.be的CCSID 0819和0037帮助以及Thomas Dorner Thomas.Dorner@start的POSIX-BC帮助编写了此文件。德 同时还要感谢Vickie Cooper，Philip Newton，William Raffloer和Joe Smith。本文档中使用的商标，注册商标，服务商标和注册服务商标均为其各自所有者的财产。</target>
        </trans-unit>
        <trans-unit id="b678d41f58da447298d919f29043393443d0cb8b" translate="yes" xml:space="preserve">
          <source>Peter Rabbitson</source>
          <target state="translated">Peter Rabbitson</target>
        </trans-unit>
        <trans-unit id="9a6caa883001f8951928abc18a49fa0996873b1e" translate="yes" xml:space="preserve">
          <source>Peter Scott &amp;lt;Peter@PSDT.com&amp;gt;</source>
          <target state="translated">彼得&amp;middot;斯科特&amp;lt;Peter@PSDT.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9bab0d91a1e342ed2899a60bb0fd7fbb5d908345" translate="yes" xml:space="preserve">
          <source>Phase-specific attribute handlers</source>
          <target state="translated">特定阶段的属性处理程序</target>
        </trans-unit>
        <trans-unit id="11224e45779f711f0ecc038e4dc550b38b44febf" translate="yes" xml:space="preserve">
          <source>Philippe Bruhat &amp;lt;book@cpan.org&amp;gt;</source>
          <target state="translated">菲利普&amp;middot;布鲁哈（Philippe Bruhat）&amp;lt;book@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b7b6129ef396633c6d7fbf8b5ba6a676cf84b685" translate="yes" xml:space="preserve">
          <source>Philosophy and History</source>
          <target state="translated">哲学和历史</target>
        </trans-unit>
        <trans-unit id="a7ca65a16231d5ab21bb882a874c4184071b79df" translate="yes" xml:space="preserve">
          <source>Pick one style or another of &quot;TODO&quot; to be on the safe side.</source>
          <target state="translated">为了安全起见,选择一种或多种风格的 &quot;TODO&quot;。</target>
        </trans-unit>
        <trans-unit id="d9e68904cd8d62a6bd9853c94a5ff5af64e98135" translate="yes" xml:space="preserve">
          <source>Picture lines contain output field definitions, intermingled with literal text. These lines do not undergo any kind of variable interpolation. Field definitions are made up from a set of characters, for starting and extending a field to its desired width. This is the complete set of characters for field definitions:</source>
          <target state="translated">图片行包含输出字段定义,与文字混合在一起。这些行没有经过任何形式的变量插值。字段定义由一组字符组成,用于开始和扩展一个字段到它所需的宽度。这是字段定义的完整字符集。</target>
        </trans-unit>
        <trans-unit id="2ce99d2159f85cc771804ecbd9dda841764e190d" translate="yes" xml:space="preserve">
          <source>Pictures help... Here's the &lt;code&gt;%hash&lt;/code&gt; table:</source>
          <target state="translated">图片帮助...这是 &lt;code&gt;%hash&lt;/code&gt; 表：</target>
        </trans-unit>
        <trans-unit id="c65c8c71a5372d959508dd740dbc1277950d7e03" translate="yes" xml:space="preserve">
          <source>Pictures of the characters in</source>
          <target state="translated">角色的图片</target>
        </trans-unit>
        <trans-unit id="f0a9c866fde7f49d0c8287047fc7266c3fcf3448" translate="yes" xml:space="preserve">
          <source>Ping the remote host and wait for a response. $host can be either the hostname or the IP number of the remote host. The optional timeout must be greater than 0 seconds and defaults to whatever was specified when the ping object was created. Returns a success flag. If the hostname cannot be found or there is a problem with the IP number, the success flag returned will be undef. Otherwise, the success flag will be 1 if the host is reachable and 0 if it is not. For most practical purposes, undef and 0 and can be treated as the same case. In array context, the elapsed time as well as the string form of the ip the host resolved to are also returned. The elapsed time value will be a float, as returned by the Time::HiRes::time() function, if hires() has been previously called, otherwise it is returned as an integer.</source>
          <target state="translated">Ping远程主机并等待响应。$host可以是远程主机的主机名或IP号。可选的超时时间必须大于0秒,默认为创建ping对象时指定的时间。返回一个成功标志。如果找不到主机名或者IP号有问题,返回的成功标志将是undef。否则,如果主机是可到达的,则返回1,如果不是,则返回0。对于大多数实际目的,undef和0和可以作为相同的情况。在数组上下文中,还将返回经过的时间以及主机解析到的ip的字符串形式。如果之前调用了hires(),那么经过的时间值将是一个float,由Time::HiRes::time()函数返回,否则将作为一个整数返回。</target>
        </trans-unit>
        <trans-unit id="bbc0c839f8f40b7cdba9f85501b6142c7594b73f" translate="yes" xml:space="preserve">
          <source>Pipe-open (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">使用包含重定向或shell元字符的命令以管道方式打开（请参见&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="32b1d5a78493496dd5152fd2d504f7e21009e3f2" translate="yes" xml:space="preserve">
          <source>Pipeline</source>
          <target state="translated">Pipeline</target>
        </trans-unit>
        <trans-unit id="785af2a4ad3c4ee912623c6e0b6d4299ea305bf6" translate="yes" xml:space="preserve">
          <source>Pipes</source>
          <target state="translated">Pipes</target>
        </trans-unit>
        <trans-unit id="86638d4dd1bfeebd306bf371ebd586c8fe132936" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack.</source>
          <target state="translated">将 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 放置在堆栈上的指定位置 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="dfd0139035f77f7f1b17632082240cf0b36e9af1" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack.</source>
          <target state="translated">将 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 放置在堆栈上的指定位置 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="916f413ffd5622b866aac763ff8940f66e4a31b9" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack.</source>
          <target state="translated">将 &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 放入堆栈中的指定位置 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b6d516f55eff9b2bccabbdde7685a4b4a9da03f" translate="yes" xml:space="preserve">
          <source>Place a copy of a string into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="translated">将字符串的副本放入堆栈中的指定位置 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 。该值存储在新的凡人SV中。</target>
        </trans-unit>
        <trans-unit id="4e9ab6d8d695d32843b4420d43d220a9cd88325d" translate="yes" xml:space="preserve">
          <source>Place a double into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="translated">将双 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 放入堆栈中的指定位置pos。该值存储在新的凡人SV中。</target>
        </trans-unit>
        <trans-unit id="cfd0007151ad5655c9cbf9340c82d4632eb28b7a" translate="yes" xml:space="preserve">
          <source>Place a message on the queue with the data from &lt;code&gt;MSG&lt;/code&gt; and with type &lt;code&gt;TYPE&lt;/code&gt; . See &lt;a href=&quot;../functions/msgsnd&quot;&gt;msgsnd&lt;/a&gt;.</source>
          <target state="translated">将消息与来自 &lt;code&gt;MSG&lt;/code&gt; 的数据和类型 &lt;code&gt;TYPE&lt;/code&gt; 放入队列中。参见&lt;a href=&quot;../functions/msgsnd&quot;&gt;msgsnd&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25d30c30326aad079b79429ee5676ce31987795b" translate="yes" xml:space="preserve">
          <source>Place an integer into the specified position &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; on the stack. The value is stored in a new mortal SV.</source>
          <target state="translated">将整数放入堆栈中的指定位置 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 。该值存储在新的凡人SV中。</target>
        </trans-unit>
        <trans-unit id="7ab3cd1c8c731f94b45abaa6c37498e8157e7f50" translate="yes" xml:space="preserve">
          <source>Placeholder for a, w, t, T</source>
          <target state="translated">a,w,t,T的占位符。</target>
        </trans-unit>
        <trans-unit id="054293d76d1e13ea0985d27d43a20139eff0cdfe" translate="yes" xml:space="preserve">
          <source>Plain Old Comments (Not!)</source>
          <target state="translated">平凡的评论(不是!)。</target>
        </trans-unit>
        <trans-unit id="9580fcbce0c31ceaa47eb583e5f7ce637fdc8a0a" translate="yes" xml:space="preserve">
          <source>Plain text</source>
          <target state="translated">纯文本</target>
        </trans-unit>
        <trans-unit id="253c3601a5c1772632a58221b654c54c8e50d5ad" translate="yes" xml:space="preserve">
          <source>Plan 9,</source>
          <target state="translated">计划9:</target>
        </trans-unit>
        <trans-unit id="4b2cf4211ed36a7b6ec3c0f885611d65d2982aae" translate="yes" xml:space="preserve">
          <source>Plan result token.</source>
          <target state="translated">计划结果令牌。</target>
        </trans-unit>
        <trans-unit id="89a27c59b357dc17fcf14a17fcc79f90df885094" translate="yes" xml:space="preserve">
          <source>Plane 0</source>
          <target state="translated">平面0</target>
        </trans-unit>
        <trans-unit id="8be58825425054cbd0b59342becdd853b8548be0" translate="yes" xml:space="preserve">
          <source>Platform Specific</source>
          <target state="translated">特定平台</target>
        </trans-unit>
        <trans-unit id="eb666bc9b27013cda41fa8a2da0d844236374b6f" translate="yes" xml:space="preserve">
          <source>Platform-Specific</source>
          <target state="translated">Platform-Specific</target>
        </trans-unit>
        <trans-unit id="eef47a635b38ce4bb5160d8fbf43c327f07918d8" translate="yes" xml:space="preserve">
          <source>Platform-agnostic MM methods</source>
          <target state="translated">不受平台影响的MM方法</target>
        </trans-unit>
        <trans-unit id="efc0c78db0c6b708dec802259186b13ee8606a83" translate="yes" xml:space="preserve">
          <source>Platform-specific pieces of the build system also live in platform-specific directories like</source>
          <target state="translated">构建系统中特定平台的部分也存在于特定平台的目录中,如</target>
        </trans-unit>
        <trans-unit id="2151168060825531d644ad2c9ef307ad23d45dd1" translate="yes" xml:space="preserve">
          <source>Platforms that do not have rdev, blksize, or blocks will return these as '', so numeric comparison or manipulation of these fields may cause 'not numeric' warnings.</source>
          <target state="translated">没有rdev、blksize或block的平台将以''返回,所以数字比较或操作这些字段可能会导致'非数字'警告。</target>
        </trans-unit>
        <trans-unit id="cb78dc6caa9da43d8d82895592406c2fb238b4d0" translate="yes" xml:space="preserve">
          <source>Playing Safe</source>
          <target state="translated">玩安全</target>
        </trans-unit>
        <trans-unit id="f5f50c6b28a2dbf428734248274d14fcc946d37a" translate="yes" xml:space="preserve">
          <source>Please add examples to what follows!</source>
          <target state="translated">请对以下内容进行补充说明!</target>
        </trans-unit>
        <trans-unit id="90db41980a6ddf9879d54f849f2452dacbc9ddd8" translate="yes" xml:space="preserve">
          <source>Please be aware that code in debugger listings may not look the same as your original source code. Line directives and external source filters can alter the code before Perl sees it, causing code to move from its original positions or take on entirely different forms.</source>
          <target state="translated">请注意,调试器列表中的代码可能与您的原始源代码看起来不一样。行指令和外部源码过滤器可能会在Perl看到之前改变代码,导致代码从原来的位置移动,或者采取完全不同的形式。</target>
        </trans-unit>
        <trans-unit id="6e35b70405206d942352bd9cec349bc8a7f2d0ac" translate="yes" xml:space="preserve">
          <source>Please check individual plugin documentation for more details.</source>
          <target state="translated">更多细节请查看各个插件文档。</target>
        </trans-unit>
        <trans-unit id="46a88c30ac9775bf9675292bcf8883102c284165" translate="yes" xml:space="preserve">
          <source>Please check the archive of the perl5-porters list (see below) and/or the bug tracking system before submitting a bug report. Often, you'll find that the bug has been reported already.</source>
          <target state="translated">在提交错误报告之前,请检查 perl5-porters 列表的存档(见下文)和/或错误跟踪系统。通常,你会发现这个错误已经被报告了。</target>
        </trans-unit>
        <trans-unit id="30d084e470b1305e613cce5c8a8f760ce12b4e60" translate="yes" xml:space="preserve">
          <source>Please e-mail us with problems, bug fixes, comments and complaints, although if you have compliments you should send them to Raphael. Please don't e-mail Raphael with problems, as he no longer works on Storable, and your message will be delayed while he forwards it to us.</source>
          <target state="translated">请把问题、错误修复、评论和抱怨用电子邮件发给我们,如果你有赞美之词,你应该把它们发给Raphael。请不要给Raphael发问题邮件,因为他已经不在Storable工作了,你的信息会被他转发给我们而被延迟。</target>
        </trans-unit>
        <trans-unit id="30c152b00259545a7771c21e247f5c5553ad4a6f" translate="yes" xml:space="preserve">
          <source>Please inform the module author if this is necessary to successfully install a module under 5.6 or later.</source>
          <target state="translated">如果要成功安装5.6或更高版本的模块,请告知模块作者。</target>
        </trans-unit>
        <trans-unit id="8b79f33567ebd39e312df677117f1f02c643059b" translate="yes" xml:space="preserve">
          <source>Please keep this list up-to-date by informing me about other items.</source>
          <target state="translated">如果有其他项目,请通知我,以保持这个清单的更新。</target>
        </trans-unit>
        <trans-unit id="d8e4357df6c51adf400f25dbaa777916223b07af" translate="yes" xml:space="preserve">
          <source>Please make sure the SDK version (i.e. the numbers right before '.sdk') matches your system's (in this case, Mac OS X 10.8 &quot;Mountain Lion&quot;), as it is possible to have more than one SDK installed. Also make sure the path exists in your system, and if it doesn't please make sure the SDK is properly installed, as it should come with the 'Command Line Tools' bundle mentioned above. Finally, if you have an older Mac OS X (10.6 &quot;Snow Leopard&quot; and below) running Xcode 4.2 or lower, the SDK path might be something like &lt;code&gt;'/Developer/SDKs/MacOSX10.3.9.sdk'&lt;/code&gt; .</source>
          <target state="translated">请确保SDK版本（即&amp;ldquo; .sdk&amp;rdquo;前的数字）与您的系统版本（在本例中为Mac OS X 10.8&amp;ldquo; Mountain Lion&amp;rdquo;）匹配，因为可能会安装多个SDK。另外，请确保该路径存在于您的系统中，如果没有，请确保正确安装了SDK，因为该SDK应该随上述&amp;ldquo;命令行工具&amp;rdquo;软件包一起提供。最后，如果您有运行Xcode 4.2或更低版本的较旧的Mac OS X（10.6&amp;ldquo; Snow Leopard&amp;rdquo;及以下版本），则SDK路径可能类似于 &lt;code&gt;'/Developer/SDKs/MacOSX10.3.9.sdk'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93b9716fcd4491544e9d39d5e1bcaaba2e6587ef" translate="yes" xml:space="preserve">
          <source>Please make sure you add the perldelta entry to the right section within</source>
          <target state="translated">请确保您将perldelta条目添加到正确的部分中。</target>
        </trans-unit>
        <trans-unit id="23a323093ed3237613762e5f23d911eb5beeb543" translate="yes" xml:space="preserve">
          <source>Please note a significant difference in the behavior of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode is that it does not force a VMS SEVERE_ERROR status on exit. The Unix exit values of 2 through 255 will be encoded in VMS status values with severity levels of SUCCESS. The Unix exit value of 1 will be encoded in a VMS status value with a severity level of ERROR. This is to be compatible with how the VMS C library encodes these values.</source>
          <target state="translated">请注意，在 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 模式下， &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 行为上的显着差异是，它不会在退出时强制VMS SEVERE_ERROR状态。Unix出口值2到255将以VMS状态值进行编码，严重性级别为SUCCESS。Unix出口值1将被编码为VMS状态值，其严重性级别为ERROR。这将与VMS C库如何编码这些值兼容。</target>
        </trans-unit>
        <trans-unit id="acb93428fa7988b6bd9d3d5b914c777174b9e347" translate="yes" xml:space="preserve">
          <source>Please note that ':constant' does not affect integer constants, nor binary nor hexadecimal constants. Use &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; or &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; to get this to work.</source>
          <target state="translated">请注意，'：constant'不影响整数常量，也不影响二进制或十六进制常量。使用&lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;或&lt;a href=&quot;bigint&quot;&gt;Math :: BigInt使它&lt;/a&gt;起作用。</target>
        </trans-unit>
        <trans-unit id="2d144a30f04447f4891231cca52898c1f409adce" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local($tabstop)&lt;/a&gt;&lt;/code&gt; doesn't do the right thing and if you want to use &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; to override &lt;code&gt;$tabstop&lt;/code&gt; , you need to use &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local($Text::Tabs::tabstop)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local($tabstop)&lt;/a&gt;&lt;/code&gt; 做不正确的事情，如果要使用 &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 覆盖 &lt;code&gt;$tabstop&lt;/code&gt; ，则需要使用 &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local($Text::Tabs::tabstop)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="633a4db7a1c782ae1b6e824e0fc9e69a016269b6" translate="yes" xml:space="preserve">
          <source>Please note that Math::BigFloat does &lt;b&gt;not&lt;/b&gt; use the denoted library itself, but it merely passes the lib argument to Math::BigInt. So, instead of the need to do:</source>
          <target state="translated">请注意，Math :: BigFloat本身&lt;b&gt;并不&lt;/b&gt;使用指定的库，而只是将lib参数传递给Math :: BigInt。因此，无需执行以下操作：</target>
        </trans-unit>
        <trans-unit id="a54801dfc85b8f9fc3dbd94457ccfddcfab12f10" translate="yes" xml:space="preserve">
          <source>Please note that POD has the notion of &quot;paragraphs&quot;: this is something starting</source>
          <target state="translated">请注意,POD有一个 &quot;段落 &quot;的概念:这是一个始于</target>
        </trans-unit>
        <trans-unit id="72307c57d87a56e5608808a2107363696283fed6" translate="yes" xml:space="preserve">
          <source>Please note that if multiple files are parsed for a single POD document (perhaps the result of some kind of &lt;code&gt;=include&lt;/code&gt; directive) this method is invoked for every file that is parsed. If you wish to perform certain cleanup actions once per document, then you should use &lt;b&gt;end_pod()&lt;/b&gt;.</source>
          <target state="translated">请注意，如果为单个POD文档解析了多个文件（也许是某种 &lt;code&gt;=include&lt;/code&gt; 指令的结果），则为每个解析的文件调用此方法。如果您希望每个文档执行一次特定的清理操作，则应使用&lt;b&gt;end_pod（）&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="10f71534786c6e41d011fbc9deff5549daf1fe0b" translate="yes" xml:space="preserve">
          <source>Please note that if the layer is created in the PerlIO::via:: namespace, it does &lt;b&gt;not&lt;/b&gt; have to be fully qualified. The PerlIO::via module will prefix the PerlIO::via:: namespace if the specified modulename does not exist as a fully qualified module name.</source>
          <target state="translated">请注意，如果该层中创建的PerlIO的::通过::命名空间，但这&lt;b&gt;并不&lt;/b&gt;必须是完全合格的。如果指定的模块名称不作为标准模块名称存在，则PerlIO :: via模块将在PerlIO :: via ::名称空间前添加前缀。</target>
        </trans-unit>
        <trans-unit id="713c4ec8dda734601e7b059dd41a997e18f77cd8" translate="yes" xml:space="preserve">
          <source>Please note that on Windows platforms colorized output also requires the Win32::Console::ANSI module.</source>
          <target state="translated">请注意,在Windows平台上,彩色化输出还需要Win32::Console::ANSI模块。</target>
        </trans-unit>
        <trans-unit id="b414f05f7085ad8d048ca6abb13a1f7ce979a37b" translate="yes" xml:space="preserve">
          <source>Please note that some of the trigonometric functions can break out from the &lt;b&gt;real axis&lt;/b&gt; into the &lt;b&gt;complex plane&lt;/b&gt;. For example &lt;code&gt;asin(2)&lt;/code&gt; has no definition for plain real numbers but it has definition for complex numbers.</source>
          <target state="translated">请注意，某些三角函数可能会从&lt;b&gt;实轴&lt;/b&gt;分解为&lt;b&gt;复平面&lt;/b&gt;。例如， &lt;code&gt;asin(2)&lt;/code&gt; 没有为普通实数定义，但为复数定义。</target>
        </trans-unit>
        <trans-unit id="2b7c92535c70d75e42791f8ddb48d4ce9ec51fc0" translate="yes" xml:space="preserve">
          <source>Please note that strings and floating point constants are not affected, so that</source>
          <target state="translated">请注意,字符串和浮点常量不受影响,所以</target>
        </trans-unit>
        <trans-unit id="c7e396ad592125eb642ceacdd629f60983df2bdf" translate="yes" xml:space="preserve">
          <source>Please note that the &lt;b&gt;preprocess_line()&lt;/b&gt; method is invoked</source>
          <target state="translated">请注意，调用了&lt;b&gt;preprocess_line（）&lt;/b&gt;方法</target>
        </trans-unit>
        <trans-unit id="865709c0c581d8169eede3efc9f220dad69fc01d" translate="yes" xml:space="preserve">
          <source>Please note that this is an area of recent development in Perl and that the interface described here is therefore still subject to change (and hopefully will have better documentation and more examples).</source>
          <target state="translated">请注意,这是Perl最近发展的一个领域,因此这里描述的界面仍然会有变化(希望会有更好的文档和更多的例子)。</target>
        </trans-unit>
        <trans-unit id="9d1dda7d4ff18b02aa0b290b258576653be091e9" translate="yes" xml:space="preserve">
          <source>Please note that this layer is implied when calling open() thus:</source>
          <target state="translated">请注意,当调用open()时,这一层是隐含的,因此。</target>
        </trans-unit>
        <trans-unit id="14bd27e9d494565b2545ea76d64ba9560ebda982" translate="yes" xml:space="preserve">
          <source>Please note that while this module works on Perl 5.6, it is no longer being routinely tested on 5.6 - the earliest Perl version being routinely tested, and expressly supported, is 5.8.1. However, patches to repair any breakage on 5.6 are still being accepted.</source>
          <target state="translated">请注意,虽然这个模块可以在 Perl 5.6 上运行,但它不再在 5.6 上进行例行测试--最早被例行测试并明确支持的 Perl 版本是 5.8.1。不过,我们仍然接受修复 5.6 版本上的任何故障的补丁。</target>
        </trans-unit>
        <trans-unit id="538443df0be8abcb2c7740f09bb5b4b6d88ac69f" translate="yes" xml:space="preserve">
          <source>Please note the following does not work as expected (prints nothing), since overloading of '..' is not yet possible in Perl (as of v5.8.0):</source>
          <target state="translated">请注意,下面的内容没有达到预期的效果(什么也不打印),因为在Perl中,'...'的重载是不可能的(从v5.8.0开始)。</target>
        </trans-unit>
        <trans-unit id="a240f0a420b088c6642d6eafb7c3deb2f9e741be" translate="yes" xml:space="preserve">
          <source>Please note: in the general case, you're better off using Encode::decode_utf8 to decode a UTF-8 encoded byte string to a Perl Unicode string, and Encode::encode_utf8 to encode a Perl Unicode string to UTF-8 bytes. These functions provide means of handling invalid byte sequences and generally have a friendlier interface.</source>
          <target state="translated">请注意:在一般情况下,你最好使用Encode::decode_utf8将UTF-8编码的字节字符串解码为Perl Unicode字符串,而Encode::encode_utf8将Perl Unicode字符串编码为UTF-8字节。这些函数提供了处理无效字节序列的方法,并且通常具有更友好的接口。</target>
        </trans-unit>
        <trans-unit id="a968cbb027497bb1dd61f62478bee1c4fb7295eb" translate="yes" xml:space="preserve">
          <source>Please note: the two functions defined above are</source>
          <target state="translated">请注意:上面定义的两个函数是</target>
        </trans-unit>
        <trans-unit id="e14b19aff89c4aad18c1b1f461b6bc9f9f18afb0" translate="yes" xml:space="preserve">
          <source>Please read &lt;a href=&quot;#COPYRIGHT&quot;&gt;COPYRIGHT&lt;/a&gt; before using version 2.x or greater of Berkeley DB with DB_File.</source>
          <target state="translated">在将2.x或更高版本的Berkeley DB与DB_File一起使用之前，请阅读&lt;a href=&quot;#COPYRIGHT&quot;&gt;COPYRIGHT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a49d7388a9b16b3144a078e3b5020dee8701b8c5" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;code&gt;Archive::Tar::File&lt;/code&gt; documentation on how to handle these objects.</source>
          <target state="translated">请参考 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 文档，了解如何处理这些对象。</target>
        </trans-unit>
        <trans-unit id="9ba05ea79d06558fc847ddce39fd58ed9e3603b4" translate="yes" xml:space="preserve">
          <source>Please refer to your native fcntl(2), open(2), fseek(3), lseek(2) (equal to Perl's seek() and sysseek(), respectively), and chmod(2) documentation to see what constants are implemented in your system.</source>
          <target state="translated">请参考你的本机fcntl(2)、open(2)、fseek(3)、lseek(2)(分别等于Perl的seek()和sysseek())和chmod(2)文档,看看你的系统中实现了哪些常量。</target>
        </trans-unit>
        <trans-unit id="c84d853900a8b1e8461d42ec22c7bb0bc4e4555b" translate="yes" xml:space="preserve">
          <source>Please remember to send me an updated entry for the Module list!</source>
          <target state="translated">请记得给我发送模块列表的更新条目!</target>
        </trans-unit>
        <trans-unit id="fc5ac378228cc627e576428f688749bb3cf44169" translate="yes" xml:space="preserve">
          <source>Please report all bugs on the RT queue:</source>
          <target state="translated">请在RT队列中报告所有BUG。</target>
        </trans-unit>
        <trans-unit id="cd1826396d92eaf26d7671cebd0646515ababb89" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests through the issue tracker at &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta&lt;/a&gt;. You will be notified automatically of any progress on your issue.</source>
          <target state="translated">请通过问题跟踪器报告所有错误或功能请求，网址为&lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta&lt;/a&gt;。系统会自动将您的问题进展情况通知您。</target>
        </trans-unit>
        <trans-unit id="54e910ef38da12f1e82d477c66613f898afde850" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests through the issue tracker at L</source>
          <target state="translated">请通过问题跟踪器报告任何错误或功能请求,在L</target>
        </trans-unit>
        <trans-unit id="bb7ffcd32fde8fcb70ebf33b96ca410b8c21fd4d" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-math-bigint at rt.cpan.org&lt;/code&gt; , or through the web interface at &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&lt;/a&gt; (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">请将任何错误或功能请求报告给 &lt;code&gt;bug-math-bigint at rt.cpan.org&lt;/code&gt; 上的bug-math-bigint，或者通过&lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt上&lt;/a&gt;的网络界面（需要登录） ）。我们会收到通知，然后在我进行更改时会自动通知您有关错误的进展。</target>
        </trans-unit>
        <trans-unit id="fedca4eaf22650d4f30ff44ea5ea07caadc39831" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-math-bigrat at rt.cpan.org&lt;/code&gt; , or through the web interface at &lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&lt;/a&gt; (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">请将任何错误或功能请求报告给 &lt;code&gt;bug-math-bigrat at rt.cpan.org&lt;/code&gt; ，或通过&lt;a href=&quot;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&quot;&gt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat上&lt;/a&gt;的网络界面（需要登录） ）。我们会收到通知，然后在我进行更改时会自动通知您有关错误的进展。</target>
        </trans-unit>
        <trans-unit id="9e63d77d099b0075753f056790cc8a0a16061cd4" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-sys-syslog (at) rt.cpan.org&lt;/code&gt;, or through the web interface at &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=Sys-Syslog&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=Sys-Syslog&lt;/a&gt;. I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">请将任何错误或功能请求报告给 &lt;code&gt;bug-sys-syslog (at) rt.cpan.org&lt;/code&gt; 上的bug-sys-syslog或通过&lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=Sys-Syslog&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=Sys- Syslog&lt;/a&gt;。我们会收到通知，然后在我进行更改时会自动通知您Bug的进展。</target>
        </trans-unit>
        <trans-unit id="ae680a8d27e7e30eaabedd56fcc07aec11c11d49" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-test-harness at rt.cpan.org&lt;/code&gt; , or through the web interface at &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&lt;/a&gt;. I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</source>
          <target state="translated">请将任何错误或功能请求报告给 &lt;code&gt;bug-test-harness at rt.cpan.org&lt;/code&gt; 上的bug-test-harness，或者通过&lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness上&lt;/a&gt;的网络界面进行报告。我们会收到通知，然后在我进行更改时会自动通知您Bug的进展。</target>
        </trans-unit>
        <trans-unit id="667d7074054f4f754df9eeb8e155a22d30cbaad3" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;code&gt;bug-test-harness@rt.cpan.org&lt;/code&gt; , or through the web interface at &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&lt;/a&gt;. We will be notified, and then you'll automatically be notified of progress on your bug as we make changes.</source>
          <target state="translated">请将任何错误或功能请求报告给 &lt;code&gt;bug-test-harness@rt.cpan.org&lt;/code&gt; 或通过Web界面&lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness进行报告&lt;/a&gt;。我们会收到通知，然后在我们进行更改时会自动通知您有关错误的进展。</target>
        </trans-unit>
        <trans-unit id="9c61f91a0c5559a90a0233170a166239a41b69c9" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests via the perlbug(1) utility.</source>
          <target state="translated">请通过 perlbug(1)工具报告任何错误或功能请求。</target>
        </trans-unit>
        <trans-unit id="538631f2230a63e6ce1111d15fa806e9dbfb590c" translate="yes" xml:space="preserve">
          <source>Please report any errors, updates, or suggestions to</source>
          <target state="translated">如果有任何错误、更新或建议,请报告给我们。</target>
        </trans-unit>
        <trans-unit id="535c1e5f2236649cfc5cd24875aa7a7f5d8bb2dc" translate="yes" xml:space="preserve">
          <source>Please report any other failures as described under &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;BUGS AND CAVEATS&lt;/a&gt;.</source>
          <target state="translated">请按照&lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;BUGGS和CAVEATS中的说明&lt;/a&gt;报告任何其他失败。</target>
        </trans-unit>
        <trans-unit id="76aa5507d30b205fb08850d3924328ca2edc4fec" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-file-fetch@rt.cpan.org&amp;lt;gt&amp;gt;.</source>
          <target state="translated">请向&amp;lt;bug-file-fetch@rt.cpan.org &amp;lt;gt&amp;gt;报告错误或其他问题。</target>
        </trans-unit>
        <trans-unit id="5af156ec0cb2830a387a464db78f0177138c46c7" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-ipc-cmd@rt.cpan.org&amp;gt;.</source>
          <target state="translated">请向&amp;lt;bug-ipc-cmd@rt.cpan.org&amp;gt;报告错误或其他问题。</target>
        </trans-unit>
        <trans-unit id="89fa61346f2ac4a97f3b1820d45a05f5cf6df3b4" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-module-load-conditional@rt.cpan.org&amp;gt;.</source>
          <target state="translated">请将错误或其他问题报告给&amp;lt;bug-module-load-conditional@rt.cpan.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="74e57493a005451600337c2cd20b19335784389b" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-module-load@rt.cpan.org&amp;lt;gt&amp;gt;.</source>
          <target state="translated">请向&amp;lt;bug-module-load@rt.cpan.org &amp;lt;gt&amp;gt;报告错误或其他问题。</target>
        </trans-unit>
        <trans-unit id="aa48dcb88c79a4bb30f628a4e59b5790599238be" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-module-loaded@rt.cpan.org&amp;lt;gt&amp;gt;.</source>
          <target state="translated">请向&amp;lt;bug-module-loaded@rt.cpan.org &amp;lt;gt&amp;gt;报告错误或其他问题。</target>
        </trans-unit>
        <trans-unit id="ea6595769a4f7e77e760cd27c4315806767a46e6" translate="yes" xml:space="preserve">
          <source>Please report bugs or other issues to &amp;lt;bug-params-check@rt.cpan.org&amp;gt;.</source>
          <target state="translated">请将错误或其他问题报告给&amp;lt;bug-params-check@rt.cpan.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="e2b012cfb62b0833f158983eb6a125eb9f62cad3" translate="yes" xml:space="preserve">
          <source>Please report bugs using &lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;.</source>
          <target state="translated">请使用&lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;报告错误。</target>
        </trans-unit>
        <trans-unit id="9b0a18ec15ee7f8f9cfa33de7bf50e0926919e26" translate="yes" xml:space="preserve">
          <source>Please report bugs via &lt;a href=&quot;http://rt.cpan.org/&quot;&gt;http://rt.cpan.org/&lt;/a&gt;</source>
          <target state="translated">请通过&lt;a href=&quot;http://rt.cpan.org/&quot;&gt;http://rt.cpan.org/&lt;/a&gt;报告错误</target>
        </trans-unit>
        <trans-unit id="e4417cf7026fd3b1d558ce74b166a72450fc9e3b" translate="yes" xml:space="preserve">
          <source>Please report bugs via the GitHub Issue Tracker at &lt;a href=&quot;https://github.com/pjf/autodie/issues&quot;&gt;https://github.com/pjf/autodie/issues&lt;/a&gt; or via the CPAN Request Tracker at &lt;a href=&quot;https://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie&quot;&gt;https://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie&lt;/a&gt;.</source>
          <target state="translated">请报告通过GitHub的问题跟踪错误&lt;a href=&quot;https://github.com/pjf/autodie/issues&quot;&gt;https://github.com/pjf/autodie/issues&lt;/a&gt;或通过CPAN请求跟踪器在&lt;a href=&quot;https://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie&quot;&gt;https://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d79a854cdb114b54082c119689356c304d2fefdd" translate="yes" xml:space="preserve">
          <source>Please reports bugs to &amp;lt;bug-archive-tar@rt.cpan.org&amp;gt;.</source>
          <target state="translated">请将错误报告给&amp;lt;bug-archive-tar@rt.cpan.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="d4341b4d3e627a1778c8a45b586f98e9adc4ce3b" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;#parseopts()&quot;&gt;parseopts()&lt;/a&gt; for a complete description of the interface for the setting and unsetting of parse-options.</source>
          <target state="translated">请参阅&lt;a href=&quot;#parseopts()&quot;&gt;parseopts（）&lt;/a&gt;获取有关设置和取消设置parse-options接口的完整说明。</target>
        </trans-unit>
        <trans-unit id="e7f51c19c32ff7fa52bd5ea5cccc3312c8f093f3" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;../parser#SUBCLASSING&quot;&gt;SUBCLASSING in TAP::Parser&lt;/a&gt; for a subclassing overview.</source>
          <target state="translated">有关子类概述，请参见&lt;a href=&quot;../parser#SUBCLASSING&quot;&gt;TAP :: Parser&lt;/a&gt;中的&amp;ldquo;子类&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d2e0a1481bb7e7875074f0faee7691f33bd29319" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;app/prove#PLUGINS&quot;&gt;PLUGINS in App::Prove&lt;/a&gt;.</source>
          <target state="translated">请&lt;a href=&quot;app/prove#PLUGINS&quot;&gt;在App :: Prove中&lt;/a&gt;查看PLUGINS。</target>
        </trans-unit>
        <trans-unit id="989a39f3d25282b53431795da6fd8624c0e76184" translate="yes" xml:space="preserve">
          <source>Please see respective module documentation for further details.</source>
          <target state="translated">更多细节请参见各模块文档。</target>
        </trans-unit>
        <trans-unit id="a30c68c43e99e52ddbaa4a59fdceb1dd51800da4" translate="yes" xml:space="preserve">
          <source>Please see the &quot;See Also&quot; references for a thorough explanation of how to correctly use language tags.</source>
          <target state="translated">关于如何正确使用语言标签,请参见 &quot;另见 &quot;参考资料。</target>
        </trans-unit>
        <trans-unit id="81fd05bcd06561fbf4acc7c17c9823d8c0d4b322" translate="yes" xml:space="preserve">
          <source>Please see the &lt;a href=&quot;mksymlists&quot;&gt;ExtUtils::Mksymlists&lt;/a&gt; documentation for more information about the DL_FUNCS, DL_VARS and FUNCLIST attributes.</source>
          <target state="translated">请参阅&lt;a href=&quot;mksymlists&quot;&gt;ExtUtils :: Mksymlists&lt;/a&gt;文档以获取有关DL_FUNCS，DL_VARS和FUNCLIST属性的更多信息。</target>
        </trans-unit>
        <trans-unit id="2c2e515c2102fd49c64f216a02d32d621813ef11" translate="yes" xml:space="preserve">
          <source>Please see the README file in distribution.</source>
          <target state="translated">请参阅发行版中的 README 文件。</target>
        </trans-unit>
        <trans-unit id="628ecfdf942d40232f5db37e81fc0010f48d3a4b" translate="yes" xml:space="preserve">
          <source>Please see the documentation for &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; for the details of what these parameters do.</source>
          <target state="translated">有关这些参数的详细信息，请参见 &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="5a5dc2d5751ee8cce246c66908a7b4ec4c62daf7" translate="yes" xml:space="preserve">
          <source>Please see the documentation in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for further details.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;bigint&quot;&gt;Math :: BigInt中&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="05004fbce196a7e0bf2a95059afe8e5ce82a91f3" translate="yes" xml:space="preserve">
          <source>Please see the documentation in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;bigint&quot;&gt;Math :: BigInt中&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="e0151ca432ab861ca7ca145a28b62d6ba2feb6f2" translate="yes" xml:space="preserve">
          <source>Please see the git repository for revision history.</source>
          <target state="translated">请查看git仓库的修订历史。</target>
        </trans-unit>
        <trans-unit id="3073b87722e3ef7fb20a17229c346b64eb30ea5d" translate="yes" xml:space="preserve">
          <source>Please see the section about &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;ACCURACY and PRECISION&lt;/a&gt; for further details.</source>
          <target state="translated">有关更多详细信息，请参见&amp;ldquo; &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;精度和精度&lt;/a&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="221b6d6c2e3933bcc937bf432e64ccb1ebb6a488" translate="yes" xml:space="preserve">
          <source>Please send detailed descriptions of any problems and solutions that you may find to &amp;lt;</source>
          <target state="translated">请将您可能发现的任何问题和解决方案的详细说明发送给&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ef68d6f3b0d5f9f183ddfa8c1c49597c47fc04d3" translate="yes" xml:space="preserve">
          <source>Please set your policy to one of the three values.</source>
          <target state="translated">请将您的政策设置为三个值之一。</target>
        </trans-unit>
        <trans-unit id="e5456a0ea6c8660091c6463eca153f6f42857178" translate="yes" xml:space="preserve">
          <source>Please submit bug reports and patches to perlbug@perl.org.</source>
          <target state="translated">请将错误报告和补丁提交到 perlbug@perl.org。</target>
        </trans-unit>
        <trans-unit id="1670aa48b29f76eeff5e31510ce8161f83f94922" translate="yes" xml:space="preserve">
          <source>Please submit bugs to the CPAN RT system at &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Time-Local&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Time-Local&lt;/a&gt; or via email at bug-time-local@rt.cpan.org.</source>
          <target state="translated">请将错误提交到CPAN RT系统，网址为&lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Time-Local&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Time-Local&lt;/a&gt;或通过电子邮件发送至bug-time-local@rt.cpan.org。</target>
        </trans-unit>
        <trans-unit id="027daf21662ca08eda2a7bd48d5158b216706744" translate="yes" xml:space="preserve">
          <source>Please try and supply some documentation if you add functions to the Perl core.</source>
          <target state="translated">如果你在Perl核心中添加函数,请尝试提供一些文档。</target>
        </trans-unit>
        <trans-unit id="f714e6d31a681125e28768dfea867640b126ff8d" translate="yes" xml:space="preserve">
          <source>Please, unless you're hacking the internals, or debugging weirdness, don't think about the UTF8 flag at all. That means that you very probably shouldn't use &lt;code&gt;is_utf8&lt;/code&gt; , &lt;code&gt;_utf8_on&lt;/code&gt; or &lt;code&gt;_utf8_off&lt;/code&gt; at all.</source>
          <target state="translated">拜托，除非您要破解内部程序或调试怪异现象，否则请不要考虑UTF8标志。这意味着您很可能根本不应该使用 &lt;code&gt;is_utf8&lt;/code&gt; ， &lt;code&gt;_utf8_on&lt;/code&gt; 或 &lt;code&gt;_utf8_off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34f29d232cd4bc7b00f36ebc0732290db154e722" translate="yes" xml:space="preserve">
          <source>Plug-in module for automatic expiration of memoized values</source>
          <target state="translated">备忘值自动失效的插件模块。</target>
        </trans-unit>
        <trans-unit id="9edf1040d2bfeaaf802cb8b27a5c7e4a201ff06a" translate="yes" xml:space="preserve">
          <source>Pluggable runops</source>
          <target state="translated">可插拔式运行</target>
        </trans-unit>
        <trans-unit id="5697803d10d7bf281aadc37a72c18ea36adecd64" translate="yes" xml:space="preserve">
          <source>Plugin support ***EXPERIMENTAL***</source>
          <target state="translated">插件支持 ***经验****</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="76ccce846df3b4c3ab1a6f65fc358f4fc11db43e" translate="yes" xml:space="preserve">
          <source>Plugins are objects that implement any of currently eight methods:</source>
          <target state="translated">插件是实现当前八种方法中任何一种方法的对象。</target>
        </trans-unit>
        <trans-unit id="1de58880797e013d954730b62488aa821afcb4c8" translate="yes" xml:space="preserve">
          <source>Plugins can be loaded using the &lt;code&gt;-P&lt;i&gt;plugin&lt;/i&gt;&lt;/code&gt; syntax, eg:</source>
          <target state="translated">插件可以使用所述被加载 &lt;code&gt;-P&lt;i&gt;plugin&lt;/i&gt;&lt;/code&gt; 的语法，例如：</target>
        </trans-unit>
        <trans-unit id="71494d8d1e8a55e1a56d948d21ff0111c0e58ab0" translate="yes" xml:space="preserve">
          <source>Pod Commands</source>
          <target state="translated">花苞命令</target>
        </trans-unit>
        <trans-unit id="3d5386faff713ed9d1073c9258ceccd049f3d049" translate="yes" xml:space="preserve">
          <source>Pod Definitions</source>
          <target state="translated">花苞定义</target>
        </trans-unit>
        <trans-unit id="4ae454b70ee2c5e321bfbc301f9d36222768b986" translate="yes" xml:space="preserve">
          <source>Pod Formatting Codes</source>
          <target state="translated">Pod格式化代码</target>
        </trans-unit>
        <trans-unit id="47918185382f833db1e30bfcfbc001132c7cba90" translate="yes" xml:space="preserve">
          <source>Pod content is contained in &lt;b&gt;Pod blocks&lt;/b&gt;. A Pod block starts with a line that matches &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt;, and continues up to the next line that matches &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=cut/&lt;/a&gt;&lt;/code&gt; or up to the end of the file if there is no &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=cut/&lt;/a&gt;&lt;/code&gt; line.</source>
          <target state="translated">Pod内容包含在&lt;b&gt;Pod块中&lt;/b&gt;。 Pod块从与 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 匹配的行开始，一直到与 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=cut/&lt;/a&gt;&lt;/code&gt; 匹配的下一行，或者直到有文件末尾为止没有 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=cut/&lt;/a&gt;&lt;/code&gt; 行。</target>
        </trans-unit>
        <trans-unit id="d6ddb3d03f7f589056100b138c86215515b2e453" translate="yes" xml:space="preserve">
          <source>Pod formatters</source>
          <target state="translated">Pod格式化器</target>
        </trans-unit>
        <trans-unit id="d66a0d27d4c73edcb27d25e097424b0951626f0c" translate="yes" xml:space="preserve">
          <source>Pod formatters can use Pod::Simple to parse Pod documents and render them into plain text, HTML, or any number of other formats. Typically, such formatters will be subclasses of Pod::Simple, and so they will inherit its methods, like &lt;code&gt;parse_file&lt;/code&gt; .</source>
          <target state="translated">Pod格式化程序可以使用Pod :: Simple解析Pod文档并将其呈现为纯文本，HTML或任何其他多种格式。通常，此类格式化程序将是Pod :: Simple的子类，因此它们将继承其方法，例如 &lt;code&gt;parse_file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44803dfacbed653092718af27817d667ae913774" translate="yes" xml:space="preserve">
          <source>Pod formatters should make reasonable efforts to keep words of Perl code from being broken across lines. For example, &quot;Foo::Bar&quot; in some formatting systems is seen as eligible for being broken across lines as &quot;Foo::&quot; newline &quot;Bar&quot; or even &quot;Foo::-&quot; newline &quot;Bar&quot;. This should be avoided where possible, either by disabling all line-breaking in mid-word, or by wrapping particular words with internal punctuation in &quot;don't break this across lines&quot; codes (which in some formats may not be a single code, but might be a matter of inserting non-breaking zero-width spaces between every pair of characters in a word.)</source>
          <target state="translated">花苞格式化人员应合理地努力使Perl代码中的单词不被跨行打断。例如,在某些格式化系统中,&quot;Foo::Bar &quot;被认为可以作为 &quot;Foo::&quot;换行 &quot;Bar&quot;,甚至是 &quot;Foo::-&quot;换行 &quot;Bar &quot;来断行。在可能的情况下,应该避免这种情况的发生,要么在单词中禁用所有的断行,要么将带有内部标点符号的特定单词包装成 &quot;不要跨行断行 &quot;代码(在某些格式中,这可能不是一个单一的代码,而可能是在单词中的每一对字符之间插入不断行的零宽度空格)。</target>
        </trans-unit>
        <trans-unit id="d30f3aa798097994ab967bc039b02fb5704336d9" translate="yes" xml:space="preserve">
          <source>Pod formatters should tolerate lines in verbatim blocks that are of any length, even if that means having to break them (possibly several times, for very long lines) to avoid text running off the side of the page. Pod formatters may warn of such line-breaking. Such warnings are particularly appropriate for lines are over 100 characters long, which are usually not intentional.</source>
          <target state="translated">花苞格式化人员应该容忍任何长度的逐字块中的行,即使这意味着必须打断它们(对于非常长的行,可能要打断好几次),以避免文本跑出页面的一侧。花苞格式化器可能会对这种断行提出警告。这种警告特别适用于长度超过100个字符的行,这通常不是故意的。</target>
        </trans-unit>
        <trans-unit id="9e45409759a4a45d8ec12bca70ef02e438fd2271" translate="yes" xml:space="preserve">
          <source>Pod formatters, where feasible, are advised to avoid splitting short verbatim paragraphs (under twelve lines, say) across pages.</source>
          <target state="translated">建议花苞格式化人员在可行的情况下,避免将短小的逐字段落(比如说,12行以下)跨页分割。</target>
        </trans-unit>
        <trans-unit id="6b57013c8fdcb737d69c938a9f663099a631cacb" translate="yes" xml:space="preserve">
          <source>Pod is a simple-to-use markup language used for writing documentation for Perl, Perl programs, and Perl modules.</source>
          <target state="translated">Pod是一种简单易用的标记语言,用于编写Perl、Perl程序和Perl模块的文档。</target>
        </trans-unit>
        <trans-unit id="0f6434053591d377adc29bce6462c4e2195b1c17" translate="yes" xml:space="preserve">
          <source>Pod is embedded in files, typically Perl source files, although you can write a file that's nothing but Pod.</source>
          <target state="translated">Pod被嵌入到文件中,通常是Perl的源文件,尽管你可以写一个除了Pod之外什么都没有的文件。</target>
        </trans-unit>
        <trans-unit id="a317c10bc80719752bdbc59669224f21caf94cb6" translate="yes" xml:space="preserve">
          <source>Pod markup consists of three basic kinds of paragraphs: &lt;a href=&quot;#Ordinary-Paragraph&quot;&gt;ordinary&lt;/a&gt;, &lt;a href=&quot;#Verbatim-Paragraph&quot;&gt;verbatim&lt;/a&gt;, and &lt;a href=&quot;#Command-Paragraph&quot;&gt;command&lt;/a&gt;.</source>
          <target state="translated">Pod标记包含三种基本的段落：&lt;a href=&quot;#Ordinary-Paragraph&quot;&gt;普通&lt;/a&gt;，&lt;a href=&quot;#Verbatim-Paragraph&quot;&gt;逐字&lt;/a&gt;和&lt;a href=&quot;#Command-Paragraph&quot;&gt;命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4100fa00f1a6ff1bc2589ecc13660c9f209d6e8" translate="yes" xml:space="preserve">
          <source>Pod parsers</source>
          <target state="translated">Pod解析器</target>
        </trans-unit>
        <trans-unit id="826ed58998f5bc33125341c4f36a3a43574102c1" translate="yes" xml:space="preserve">
          <source>Pod parsers may also note additional attributes including:</source>
          <target state="translated">花苞解析器还可以注意到其他属性,包括:</target>
        </trans-unit>
        <trans-unit id="78ce92125382b9b17f3f27b241298cd0d948dfa7" translate="yes" xml:space="preserve">
          <source>Pod parsers must also support the XHTML codes &quot;E&amp;lt;quot&amp;gt;&quot; for character 34 (doublequote, &quot;), &quot;E&amp;lt;amp&amp;gt;&quot; for character 38 (ampersand, &amp;amp;), and &quot;E&amp;lt;apos&amp;gt;&quot; for character 39 (apostrophe, ').</source>
          <target state="translated">Pod解析器还必须支持XHTML代码&amp;ldquo; E &amp;lt;&amp;rdquo;&amp;gt;表示字符34（双引号，&amp;ldquo;）&amp;rdquo;，&amp;ldquo; E &amp;lt;amp&amp;gt;&amp;rdquo;表示字符38（&amp;ldquo;＆&amp;rdquo;号，和），以及&amp;ldquo; E &amp;lt;&amp;rdquo;表示字符39（撇号）。 ，'）。</target>
        </trans-unit>
        <trans-unit id="d16107ce92c757a467355de94f2c9937bd3ef851" translate="yes" xml:space="preserve">
          <source>Pod parsers must recognize</source>
          <target state="translated">花苞解析器必须识别</target>
        </trans-unit>
        <trans-unit id="6e60f4cd73d8a373a60400a3a94686dfb7543ae7" translate="yes" xml:space="preserve">
          <source>Pod parsers must treat a line with only spaces and/or tabs on it as a &quot;blank line&quot; such as separates paragraphs. (Some older parsers recognized only two adjacent newlines as a &quot;blank line&quot; but would not recognize a newline, a space, and a newline, as a blank line. This is noncompliant behavior.)</source>
          <target state="translated">花苞解析器必须将仅有空格和/或制表符的行视为 &quot;空行&quot;,如分隔段落。(一些旧的解析器只将两个相邻的新行识别为 &quot;空行&quot;,但不会将一个新行、一个空格和一个新行识别为空行。这是不合规的行为。)</target>
        </trans-unit>
        <trans-unit id="0c42bd4ec3460b4dc34871ff713c3f41e0e29ace" translate="yes" xml:space="preserve">
          <source>Pod parsers should accept input lines that are of any length.</source>
          <target state="translated">Pod解析器应该接受任何长度的输入行。</target>
        </trans-unit>
        <trans-unit id="1bf89edbc56bd1aa97ad7cab04b88498a0a483ec" translate="yes" xml:space="preserve">
          <source>Pod parsers should not, by default, try to coerce apostrophe (') and quote (&quot;) into smart quotes (little 9's, 66's, 99's, etc), nor try to turn backtick (`) into anything else but a single backtick character (distinct from an open quote character!), nor &quot;--&quot; into anything but two minus signs. They</source>
          <target state="translated">默认情况下,花苞解析器不应该试图将撇号(')和引号(&quot;)变成智能引号(小9、66、99等),也不应该试图将回车键(`)变成除了单个回车键字符(有别于开放的引号字符!)以外的任何东西,也不应该将&quot;--&quot;变成除了两个减号以外的任何东西。他们</target>
        </trans-unit>
        <trans-unit id="6e79c8f8c8738ed0d3f21bff581d4bef63a3b7d3" translate="yes" xml:space="preserve">
          <source>Pod parsers should understand all &quot;E&amp;lt;html&amp;gt;&quot; codes as defined in the entity declarations in the most recent XHTML specification at &lt;code&gt;www.W3.org&lt;/code&gt; . Pod parsers must understand at least the entities that define characters in the range 160-255 (Latin-1). Pod parsers, when faced with some unknown &quot;E&amp;lt;</source>
          <target state="translated">Pod解析器应了解 &lt;code&gt;www.W3.org&lt;/code&gt; 上最新XHTML规范中的实体声明中定义的所有&amp;ldquo; E &amp;lt;html&amp;gt;&amp;rdquo;代码。 Pod解析器必须至少了解在160-255（Latin-1）范围内定义字符的实体。当遇到某些未知的&amp;ldquo; E &amp;lt;</target>
        </trans-unit>
        <trans-unit id="435533c0da449df0b3756321a9e1ae46d36e29f8" translate="yes" xml:space="preserve">
          <source>Pod parsers should, by default, expand tabs in verbatim paragraphs as they are processed, before passing them to the formatter or other processor. Parsers may also allow an option for overriding this.</source>
          <target state="translated">默认情况下,Pod解析器应该在处理逐字段中展开标签,然后再将其传递给格式化或其他处理器。解析器也可以允许一个选项来覆盖这一点。</target>
        </trans-unit>
        <trans-unit id="3ca8470501fde76fe0175878b3907601deeb185a" translate="yes" xml:space="preserve">
          <source>Pod parsers should, by default, remove newlines from the end of ordinary and verbatim paragraphs before passing them to the formatter. For example, while the paragraph you're reading now could be considered, in Pod source, to end with (and contain) the newline(s) that end it, it should be processed as ending with (and containing) the period character that ends this sentence.</source>
          <target state="translated">默认情况下,Pod解析器应该在将普通段落和逐字段落的结尾处删除换行符,然后再将其传递给格式化器。例如,虽然你现在阅读的段落在Pod源中可以被认为是以(并包含)结束它的换行符结束,但它应该被处理为以(并包含)结束这句话的句号字符结束。</target>
        </trans-unit>
        <trans-unit id="ed20dd657439280794de2dd1f166cc37caab82bd" translate="yes" xml:space="preserve">
          <source>Pod parsers, when processing a series of data paragraphs one after another (within a single region), should consider them to be one large data paragraph that happens to contain blank lines. So the content of the above &quot;=begin html&quot;...&quot;=end html&quot;</source>
          <target state="translated">Pod解析器在处理一系列数据段时,一个接一个(在一个区域内),应该把它们看作是一个大的数据段,而这个数据段恰好包含空行。所以上面&quot;=begin html&quot;...&quot;=end html &quot;的内容为</target>
        </trans-unit>
        <trans-unit id="f0083162b22d1c665e8c416af71fd03dff278ffc" translate="yes" xml:space="preserve">
          <source>Pod parsers, when processing a series of verbatim paragraphs one after another, should consider them to be one large verbatim paragraph that happens to contain blank lines. I.e., these two lines, which have a blank line between them:</source>
          <target state="translated">花苞解析器在接连处理一系列逐字段时,应把它们看作是一个大的逐字段,而这个大的逐字段恰好包含空行。即这两行字,它们之间有一条空行。</target>
        </trans-unit>
        <trans-unit id="b5f64a484d29376d6815265a1e55624e33ac0e03" translate="yes" xml:space="preserve">
          <source>Pod parsers, when reporting errors, should make some effort to report an approximate line number (&quot;Nested E&amp;lt;&amp;gt;'s in Paragraph #52, near line 633 of Thing/Foo.pm!&quot;), instead of merely noting the paragraph number (&quot;Nested E&amp;lt;&amp;gt;'s in Paragraph #52 of Thing/Foo.pm!&quot;). Where this is problematic, the paragraph number should at least be accompanied by an excerpt from the paragraph (&quot;Nested E&amp;lt;&amp;gt;'s in Paragraph #52 of Thing/Foo.pm, which begins 'Read/write accessor for the C&amp;lt;interest rate&amp;gt; attribute...'&quot;).</source>
          <target state="translated">Pod解析器在报告错误时，应做出一些努力来报告大约的行号（&amp;ldquo;第52段中的嵌套E &amp;lt;&amp;gt;，位于Thing / Foo.pm的第633行附近！&amp;rdquo;），而不是仅注意该段号。 （&amp;ldquo;在Thing / Foo.pm的第52段中嵌套的E &amp;lt;&amp;gt;！&amp;rdquo;）。如果这有问题，则该段号至少应附有该段的节选（Thing / Foo.pm的第52段中的&amp;ldquo;嵌套E &amp;lt;&amp;gt;&amp;rdquo;，该段的开头是&amp;ldquo;对C &amp;lt;interest率&amp;gt;属性...'&amp;ldquo;）。</target>
        </trans-unit>
        <trans-unit id="668dc3898e0866dd2110d298d9f0248ce827b86d" translate="yes" xml:space="preserve">
          <source>Pod processors must now treat &quot;text|&quot;-less links as follows:</source>
          <target state="translated">花苞处理器现在必须按以下方式处理 &quot;文本|&quot;-无链接。</target>
        </trans-unit>
        <trans-unit id="594a4383ca99a25d0a62e673cd217ea7d9ae8dcd" translate="yes" xml:space="preserve">
          <source>Pod processors must treat a &quot;=for [label] [content...]&quot; paragraph as meaning the same thing as a &quot;=begin [label]&quot; paragraph, content, and an &quot;=end [label]&quot; paragraph. (The parser may conflate these two constructs, or may leave them distinct, in the expectation that the formatter will nevertheless treat them the same.)</source>
          <target state="translated">花苞处理器必须将&quot;=for [label][content...]&quot;段与&quot;=begin [label]&quot;段、内容和&quot;=end [label]&quot;段的含义相同。(解析器可以将这两个结构混为一谈,也可以将它们分开,期望格式化器将它们视为一样的东西。)</target>
        </trans-unit>
        <trans-unit id="6de2f56b65b8b60daa7959cb94ce9eb7617c07e8" translate="yes" xml:space="preserve">
          <source>Pod processors seeing such a contentless &quot;=over&quot; ... &quot;=back&quot; region, may ignore it, or may report it as an error.</source>
          <target state="translated">花苞处理器看到这样一个无内容的&quot;=over&quot;......区域,可能会忽略它,或者报错。&quot;=back &quot;区域,可能会忽略它,或者报告为错误。</target>
        </trans-unit>
        <trans-unit id="3a61b4f9c5145d423bbf4e3510d246b1bb3674c7" translate="yes" xml:space="preserve">
          <source>Pod processors should tolerate &quot;=item *&quot; / &quot;=item</source>
          <target state="translated">花苞处理器应容忍&quot;=项目*&quot;/&quot;=item</target>
        </trans-unit>
        <trans-unit id="9adfdecd54c38e1ba53caaf5b50318f5e88b69d6" translate="yes" xml:space="preserve">
          <source>Pod processors should tolerate empty &quot;=begin</source>
          <target state="translated">花苞处理器应该容忍空的&quot;=begin&quot;。</target>
        </trans-unit>
        <trans-unit id="6ba827650f169b32c9dafe5b41a25b33124521f2" translate="yes" xml:space="preserve">
          <source>Pod text (i.e., possibly containing formatting codes) that's just not for normal formatting (e.g., may not be a normal-use paragraph, but might be for formatting as a footnote).</source>
          <target state="translated">只是不用于正常格式化的花苞文本(即可能包含格式化代码)(例如,可能不是一个正常使用的段落,但可能是用于格式化的脚注)。</target>
        </trans-unit>
        <trans-unit id="2783a719cd65c4f57c6fddc4f5f579afb17e9719" translate="yes" xml:space="preserve">
          <source>Pod-Parser is free software; you can redistribute it and/or modify it under the terms of the Artistic License distributed with Perl version 5.000 or (at your option) any later version. Please refer to the Artistic License that came with your Perl distribution for more details. If your version of Perl was not distributed under the terms of the Artistic License, than you may distribute PodParser under the same terms as Perl itself.</source>
          <target state="translated">Pod-Parser 是一个自由软件;你可以根据随 Perl 5.000 版或(由你选择)任何更新版本发布的 Artistic License 条款重新发布它和/或修改它。请参考你的Perl发行版所附带的Artistic License来了解更多细节。如果你的Perl版本不是按照Artistic License的条款发布的,你可以按照Perl本身的条款发布PodParser。</target>
        </trans-unit>
        <trans-unit id="1e0d75b84c30c843c8bfda065ca1ea8379066bee" translate="yes" xml:space="preserve">
          <source>Pod::Cache</source>
          <target state="translated">Pod::Cache</target>
        </trans-unit>
        <trans-unit id="b1da253840554c380163f270f69e5e71950e910f" translate="yes" xml:space="preserve">
          <source>Pod::Cache::Item</source>
          <target state="translated">Pod::Cache::Item</target>
        </trans-unit>
        <trans-unit id="4309bafc5148041a8cbecb4efa7c1ba20ab29cfb" translate="yes" xml:space="preserve">
          <source>Pod::Checker</source>
          <target state="translated">Pod::Checker</target>
        </trans-unit>
        <trans-unit id="a5093f45c4b5aaed940c739c6d883bfba267a005" translate="yes" xml:space="preserve">
          <source>Pod::Checker, podchecker() - check pod documents for syntax errors</source>
          <target state="translated">Pod::Checker,podchecker()-检查pod文档的语法错误。</target>
        </trans-unit>
        <trans-unit id="b66220cfac7078b071d64dbaadef5e2df1a1682d" translate="yes" xml:space="preserve">
          <source>Pod::Escapes</source>
          <target state="translated">Pod::Escapes</target>
        </trans-unit>
        <trans-unit id="70a96b22865c78bae1b86e98f32189c8aaa2bb49" translate="yes" xml:space="preserve">
          <source>Pod::Escapes - for resolving Pod E&amp;lt;...&amp;gt; sequences</source>
          <target state="translated">Pod :: Escapes-用于解析Pod E &amp;lt;...&amp;gt;序列</target>
        </trans-unit>
        <trans-unit id="6defdf29847160bf19d64c9df0b01a83e7104754" translate="yes" xml:space="preserve">
          <source>Pod::Find</source>
          <target state="translated">Pod::Find</target>
        </trans-unit>
        <trans-unit id="808564a4fa3f783ef4d67e5d6df9a8f115d31c52" translate="yes" xml:space="preserve">
          <source>Pod::Find - find POD documents in directory trees</source>
          <target state="translated">Pod::Find-在目录树中查找POD文档。</target>
        </trans-unit>
        <trans-unit id="dad87a793e174e3498e4bb970a27f08fc37c4ec4" translate="yes" xml:space="preserve">
          <source>Pod::Functions</source>
          <target state="translated">Pod::Functions</target>
        </trans-unit>
        <trans-unit id="5ae2aa0e6801f18d083fa71458d5eb312ff91cd1" translate="yes" xml:space="preserve">
          <source>Pod::Functions - Group Perl's functions a la perlfunc.pod</source>
          <target state="translated">Pod::Functions-用perlfunc.pod对Perl的功能进行分组。</target>
        </trans-unit>
        <trans-unit id="155d59dfdac80d383af24b34deb797773121193e" translate="yes" xml:space="preserve">
          <source>Pod::Html</source>
          <target state="translated">Pod::Html</target>
        </trans-unit>
        <trans-unit id="6ce65cf1b1b1d8e5982cc14bc857d4e459129be4" translate="yes" xml:space="preserve">
          <source>Pod::Html - module to convert pod files to HTML</source>
          <target state="translated">Pod::Html-将 pod 文件转换为 HTML 的模块。</target>
        </trans-unit>
        <trans-unit id="5ed5257c3f06b8fdcae25020648334294f4275b0" translate="yes" xml:space="preserve">
          <source>Pod::Hyperlink</source>
          <target state="translated">Pod::Hyperlink</target>
        </trans-unit>
        <trans-unit id="dd2479ef40c118023069cffd4b8d4af17078456b" translate="yes" xml:space="preserve">
          <source>Pod::InputObjects</source>
          <target state="translated">Pod::InputObjects</target>
        </trans-unit>
        <trans-unit id="bfd22e221bc5d9239254ba01ea54c7e2a5450505" translate="yes" xml:space="preserve">
          <source>Pod::InputObjects - objects representing POD input paragraphs, commands, etc.</source>
          <target state="translated">Pod::InputObjects-代表POD输入段落、命令等的对象。</target>
        </trans-unit>
        <trans-unit id="1fd87a3ff91f7bce73657a26c6061dd462442c15" translate="yes" xml:space="preserve">
          <source>Pod::InteriorSequence-&amp;gt;*new()*</source>
          <target state="translated">Pod::InteriorSequence-&amp;gt;*new()*</target>
        </trans-unit>
        <trans-unit id="aa9152899b6499f1f28c2040e96614e6bafb5e59" translate="yes" xml:space="preserve">
          <source>Pod::InteriorSequence-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</source>
          <target state="translated">Pod::InteriorSequence-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="910131799392bc52cef82e99a388fd9c65b4ae23" translate="yes" xml:space="preserve">
          <source>Pod::InteriorSequence::*DESTROY()*</source>
          <target state="translated">Pod::InteriorSequence::*DESTROY()*</target>
        </trans-unit>
        <trans-unit id="1f1f3b74ed98a3dd9e45e5bf6a582d0ed682382c" translate="yes" xml:space="preserve">
          <source>Pod::InteriorSequence::&lt;b&gt;DESTROY()&lt;/b&gt;</source>
          <target state="translated">Pod::InteriorSequence::&lt;b&gt;DESTROY()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7583826bf22698054ad129c59e6b413946e80949" translate="yes" xml:space="preserve">
          <source>Pod::List</source>
          <target state="translated">Pod::List</target>
        </trans-unit>
        <trans-unit id="399a822bdd33d5589ccd5adac65bb8bcadff8e2b" translate="yes" xml:space="preserve">
          <source>Pod::Man</source>
          <target state="translated">Pod::Man</target>
        </trans-unit>
        <trans-unit id="5e62c421e1876f6d3d9c493879772552cb121e98" translate="yes" xml:space="preserve">
          <source>Pod::Man - Convert POD data to formatted *roff input</source>
          <target state="translated">Pod::Man-将POD数据转换为格式化的*roff输入。</target>
        </trans-unit>
        <trans-unit id="b90fbc49b7a05d49287613663bd77efed96454b2" translate="yes" xml:space="preserve">
          <source>Pod::Man assumes that your *roff formatters have a fixed-width font named &lt;code&gt;CW&lt;/code&gt; . If yours is called something else (like &lt;code&gt;CR&lt;/code&gt; ), use the &lt;code&gt;fixed&lt;/code&gt; option to specify it. This generally only matters for troff output for printing. Similarly, you can set the fonts used for bold, italic, and bold italic fixed-width output.</source>
          <target state="translated">Pod :: Man假定您的* roff格式化程序使用的定宽字体为 &lt;code&gt;CW&lt;/code&gt; 。如果您的名称被称为其他名称（例如 &lt;code&gt;CR&lt;/code&gt; ），请使用 &lt;code&gt;fixed&lt;/code&gt; 选项进行指定。这通常仅对打印输出的troff重要。同样，您可以设置用于粗体，斜体和粗斜体固定宽度输出的字体。</target>
        </trans-unit>
        <trans-unit id="87a26f0879ac57b4dc74e16802d7a975443066e4" translate="yes" xml:space="preserve">
          <source>Pod::Man doesn't handle font names longer than two characters. Neither do most &lt;b&gt;troff&lt;/b&gt; implementations, but GNU troff does as an extension. It would be nice to support as an option for those who want to use it.</source>
          <target state="translated">Pod :: Man处理的字体名称不能超过两个字符。大多数&lt;b&gt;troff的&lt;/b&gt;实现都没有，但是GNU troff作为扩展。对于那些想使用它的人来说，将其作为一种选择是很好的。</target>
        </trans-unit>
        <trans-unit id="ac7f587bee7ab6accabf7dabad0c45ac456a4a26" translate="yes" xml:space="preserve">
          <source>Pod::Man is a module to convert documentation in the POD format (the preferred language for documenting Perl) into *roff input using the man macro set. The resulting *roff code is suitable for display on a terminal using</source>
          <target state="translated">Pod::Man 是一个模块,它可以使用 man 宏集将 POD 格式(Perl 的首选文档语言)的文档转换为 *roff 输入。由此产生的*roff代码适合在终端上显示,可以使用</target>
        </trans-unit>
        <trans-unit id="ad3445f4f79ce9259a8628ec68bc720cda5d5e62" translate="yes" xml:space="preserve">
          <source>Pod::Man is excessively slow.</source>
          <target state="translated">花苞::人是过分的慢。</target>
        </trans-unit>
        <trans-unit id="51823c2a78f4399e5665a442ee35e9c5bca035b6" translate="yes" xml:space="preserve">
          <source>Pod::Paragraph-&amp;gt;*new()*</source>
          <target state="translated">Pod::Paragraph-&amp;gt;*new()*</target>
        </trans-unit>
        <trans-unit id="7d19eb9c0ae5cf759f818151ef1964f55c63cf45" translate="yes" xml:space="preserve">
          <source>Pod::Paragraph-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</source>
          <target state="translated">Pod::Paragraph-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="74702680baaf5527f7457048b890cf998a0bb577" translate="yes" xml:space="preserve">
          <source>Pod::ParseLink</source>
          <target state="translated">Pod::ParseLink</target>
        </trans-unit>
        <trans-unit id="cb542aa99fa734c9712efd42aa4abd5626202cf7" translate="yes" xml:space="preserve">
          <source>Pod::ParseLink - Parse an L&amp;lt;&amp;gt; formatting code in POD text</source>
          <target state="translated">Pod :: ParseLink-解析POD文本中的L &amp;lt;&amp;gt;格式代码</target>
        </trans-unit>
        <trans-unit id="40d45d7153ea7fd47a061f54ddf8f05276e6b0a8" translate="yes" xml:space="preserve">
          <source>Pod::ParseTree-&amp;gt;*new()*</source>
          <target state="translated">Pod::ParseTree-&amp;gt;*new()*</target>
        </trans-unit>
        <trans-unit id="c5b3a2fe463766f0c50d1925513a960e96c11a70" translate="yes" xml:space="preserve">
          <source>Pod::ParseTree-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</source>
          <target state="translated">Pod::ParseTree-&amp;gt;&lt;b&gt;new()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="58e28f5f7a4d5a5122148dd16c2d1e71ce7bc46b" translate="yes" xml:space="preserve">
          <source>Pod::ParseTree::*DESTROY()*</source>
          <target state="translated">Pod::ParseTree::*DESTROY()*</target>
        </trans-unit>
        <trans-unit id="81662ddf3d094b6a72fa9f04c80b756682be36f9" translate="yes" xml:space="preserve">
          <source>Pod::ParseTree::&lt;b&gt;DESTROY()&lt;/b&gt;</source>
          <target state="translated">Pod::ParseTree::&lt;b&gt;DESTROY()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ee80a8df78f91720393a41e76f1774b357695e04" translate="yes" xml:space="preserve">
          <source>Pod::ParseUtils</source>
          <target state="translated">Pod::ParseUtils</target>
        </trans-unit>
        <trans-unit id="bbc14d0ac8be47a43775571a03e2b17ca30027af" translate="yes" xml:space="preserve">
          <source>Pod::ParseUtils - helpers for POD parsing and conversion</source>
          <target state="translated">Pod::ParseUtils-用于POD解析和转换的帮助程序。</target>
        </trans-unit>
        <trans-unit id="0f85b7c22f11f515805110a0d85c8bbe81e1d272" translate="yes" xml:space="preserve">
          <source>Pod::Parser</source>
          <target state="translated">Pod::Parser</target>
        </trans-unit>
        <trans-unit id="e349932a04d5644a45ac3d6d00713d29777c5bd0" translate="yes" xml:space="preserve">
          <source>Pod::Parser - base class for creating POD filters and translators</source>
          <target state="translated">Pod::Parser-创建POD过滤器和翻译器的基础类。</target>
        </trans-unit>
        <trans-unit id="87e59733686c14028fb5b5ae16afd20f13d498de" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc</source>
          <target state="translated">Pod::Perldoc</target>
        </trans-unit>
        <trans-unit id="9d3a2f1ea446fa05938de94bfd8b37f662112ca1" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc - Look up Perl documentation in Pod format.</source>
          <target state="translated">Pod::Perldoc-以Pod格式查找Perl文档。</target>
        </trans-unit>
        <trans-unit id="952ca16414e36da5649f023d81973c25e340d6f9" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::BaseTo</source>
          <target state="translated">Pod::Perldoc::BaseTo</target>
        </trans-unit>
        <trans-unit id="35bfe0dc1cd61b9db99276bb0f43f2c0c5ad18a2" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::BaseTo - Base for Pod::Perldoc formatters</source>
          <target state="translated">Pod::Perldoc::BaseTo-Pod::Perldoc格式化的基础。</target>
        </trans-unit>
        <trans-unit id="b4063f396bd36a75310fe477b3233942b1f8e567" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::GetOptsOO</source>
          <target state="translated">Pod::Perldoc::GetOptsOO</target>
        </trans-unit>
        <trans-unit id="a32860ca9b02758a905681124e46d01c0cb1afa0" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::GetOptsOO - Customized option parser for Pod::Perldoc</source>
          <target state="translated">Pod::Perldoc::GetOptsOO-为Pod::Perldoc定制的选项解析器。</target>
        </trans-unit>
        <trans-unit id="4db2d3912d225b5fb9794a822706dc8ac6dd251e" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToChecker</source>
          <target state="translated">Pod::Perldoc::ToChecker</target>
        </trans-unit>
        <trans-unit id="fb1bc67a07a358017c46696594ab3bb46f1cb4a2" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToChecker - let Perldoc check Pod for errors</source>
          <target state="translated">Pod::Perldoc::ToChecker-让Perldoc检查Pod的错误。</target>
        </trans-unit>
        <trans-unit id="a1574ea07e4ca7da944a178adab1f198c77bb9c4" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToMan</source>
          <target state="translated">Pod::Perldoc::ToMan</target>
        </trans-unit>
        <trans-unit id="30ccb6b13c861e844f65ca3477dee08e5031e04b" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToMan - let Perldoc render Pod as man pages</source>
          <target state="translated">Pod::Perldoc::ToMan-让Perldoc将Pod渲染成man页。</target>
        </trans-unit>
        <trans-unit id="e4528b7a26cc2f22afcb70063b8c90bfcec139cb" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToNroff</source>
          <target state="translated">Pod::Perldoc::ToNroff</target>
        </trans-unit>
        <trans-unit id="aad347f7e727638ba9cf62fde0284182ed3e5499" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToNroff - let Perldoc convert Pod to nroff</source>
          <target state="translated">Pod::Perldoc::ToNroff-让Perldoc将Pod转换为nroff。</target>
        </trans-unit>
        <trans-unit id="c74cfee58278b9d7e2d985e281b40bac7cf67fe1" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToPod</source>
          <target state="translated">Pod::Perldoc::ToPod</target>
        </trans-unit>
        <trans-unit id="d74169b37abf471a8016b67eb6b64f1d9c9504cb" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToPod - let Perldoc render Pod as ... Pod!</source>
          <target state="translated">Under::Perldoc::ToPod-让Perldoc将Under渲染成...下!</target>
        </trans-unit>
        <trans-unit id="f92919a3efdae5160bab598ae79998a12eaeb9d9" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToRtf</source>
          <target state="translated">Pod::Perldoc::ToRtf</target>
        </trans-unit>
        <trans-unit id="0397b052f308b568ed8ea3c3f278e9880b59064b" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToRtf - let Perldoc render Pod as RTF</source>
          <target state="translated">Pod::Perldoc::ToRtf-让Perldoc将Pod渲染成RTF格式。</target>
        </trans-unit>
        <trans-unit id="c1c7e677057bffb1949a495159f761c28d093073" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToText</source>
          <target state="translated">Pod::Perldoc::ToText</target>
        </trans-unit>
        <trans-unit id="1b76ad0504a574b95327f3837e47de7fc1023f81" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToText - let Perldoc render Pod as plaintext</source>
          <target state="translated">Pod::Perldoc::ToText-让Perldoc将Pod渲染成纯文本。</target>
        </trans-unit>
        <trans-unit id="44a2311f8a968a637bebf75641a7ba7c7bea0e77" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToTk</source>
          <target state="translated">Pod::Perldoc::ToTk</target>
        </trans-unit>
        <trans-unit id="ce6206e971d4052af6b94fba7e16c592c58263c8" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToTk - let Perldoc use Tk::Pod to render Pod</source>
          <target state="translated">Pod::Perldoc::ToTk-让Perldoc使用Tk::Pod来渲染Pod。</target>
        </trans-unit>
        <trans-unit id="cd1e43a8f3efd6bddd767fd169879bd7e8783197" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToXml</source>
          <target state="translated">Pod::Perldoc::ToXml</target>
        </trans-unit>
        <trans-unit id="eb2c349f8bc3477a2154a9f78f20889a0cd5e99e" translate="yes" xml:space="preserve">
          <source>Pod::Perldoc::ToXml - let Perldoc render Pod as XML</source>
          <target state="translated">Pod::Perldoc::ToXml-让Perldoc将Pod渲染成XML格式。</target>
        </trans-unit>
        <trans-unit id="944eb1a064749ff64ccfc3ec1500e3e6fc76949a" translate="yes" xml:space="preserve">
          <source>Pod::PlainText</source>
          <target state="translated">Pod::PlainText</target>
        </trans-unit>
        <trans-unit id="5cc69f416528304166ca8b06a7aa0165df6da3fc" translate="yes" xml:space="preserve">
          <source>Pod::PlainText - Convert POD data to formatted ASCII text</source>
          <target state="translated">Pod::PlainText-将POD数据转换为格式化的ASCII文本。</target>
        </trans-unit>
        <trans-unit id="946a0512ab5f99c773ae3db3dc5b34c4ce07ed9b" translate="yes" xml:space="preserve">
          <source>Pod::PlainText is a module that can convert documentation in the POD format (the preferred language for documenting Perl) into formatted ASCII. It uses no special formatting controls or codes whatsoever, and its output is therefore suitable for nearly any device.</source>
          <target state="translated">Pod::PlainText 是一个模块,它可以将 POD 格式(Perl 文档的首选语言)的文档转换成格式化的 ASCII。它没有使用任何特殊的格式化控件或代码,因此它的输出几乎适用于任何设备。</target>
        </trans-unit>
        <trans-unit id="8ed6eb484633051ee80e6a561ff9dcdff2c845ec" translate="yes" xml:space="preserve">
          <source>Pod::Select</source>
          <target state="translated">Pod::Select</target>
        </trans-unit>
        <trans-unit id="14904b6c97faa949c076532da064781f2d55c6b6" translate="yes" xml:space="preserve">
          <source>Pod::Select, podselect() - extract selected sections of POD from input</source>
          <target state="translated">Pod::Select,podselect()-从输入中提取POD的选定部分。</target>
        </trans-unit>
        <trans-unit id="661be2b89917f8caa0e44c582550ee749e115412" translate="yes" xml:space="preserve">
          <source>Pod::Simpele::XHTML was created by Allison Randal &amp;lt;allison@perl.org&amp;gt;.</source>
          <target state="translated">Pod :: Simpele :: XHTML由Allison Randal &amp;lt;allison@perl.org&amp;gt;创建。</target>
        </trans-unit>
        <trans-unit id="d6a12e7ef9128476299731ac0108ac1f784f3a4d" translate="yes" xml:space="preserve">
          <source>Pod::Simple</source>
          <target state="translated">Pod::Simple</target>
        </trans-unit>
        <trans-unit id="6d11b0239af7ff1a19852fc395f1f5f5a3a35c0c" translate="yes" xml:space="preserve">
          <source>Pod::Simple is a Perl library for parsing text in the Pod (&quot;plain old documentation&quot;) markup language that is typically used for writing documentation for Perl and for Perl modules. The Pod format is explained &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;; the most common formatter is called &lt;code&gt;perldoc&lt;/code&gt; .</source>
          <target state="translated">Pod :: Simple是一个Perl库，用于解析Pod（&amp;ldquo;普通旧文档&amp;rdquo;）标记语言中的文本，该语言通常用于编写Perl和Perl模块的文档。Pod格式解释&lt;a href=&quot;../perlpod&quot;&gt;了&lt;/a&gt; ; 最常见的格式化程序称为 &lt;code&gt;perldoc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="540c209eeff967303f473e2a9f8cc439bebb7a9a" translate="yes" xml:space="preserve">
          <source>Pod::Simple is maintained by:</source>
          <target state="translated">Pod::Simple的维护者是。</target>
        </trans-unit>
        <trans-unit id="1804f7888eed7ad55ddcaa1547cb97407e48d6c0" translate="yes" xml:space="preserve">
          <source>Pod::Simple uses this class for representing the value of the &quot;section&quot; attribute of &quot;L&quot; start-element events. Most applications can just use the normal stringification of objects of this class; they stringify to just the text content of the section, such as &quot;foo&quot; for &lt;code&gt;L&amp;lt;Stuff/foo&amp;gt;&lt;/code&gt; , and &quot;bar&quot; for &lt;code&gt;L&amp;lt;Stuff/bI&amp;lt;ar&amp;gt;&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">Pod :: Simple使用此类表示&amp;ldquo; L&amp;rdquo;个起始元素事件的&amp;ldquo; section&amp;rdquo;属性的值。大多数应用程序只能使用此类的普通字符串化对象。它们只字符串化为该部分的文本内容，例如 &lt;code&gt;L&amp;lt;Stuff/foo&amp;gt;&lt;/code&gt; &amp;ldquo; foo &amp;rdquo;， &lt;code&gt;L&amp;lt;Stuff/bI&amp;lt;ar&amp;gt;&amp;gt;&lt;/code&gt; &amp;ldquo; bar&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="dc75eedd949380ed057546f8903efcf7ffa0476d" translate="yes" xml:space="preserve">
          <source>Pod::Simple was created by Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt; with code borrowed from Marek Rouchal's &lt;a href=&quot;../find&quot;&gt;Pod::Find&lt;/a&gt;, which in turn heavily borrowed code from Nick Ing-Simmons' &lt;code&gt;PodToHtml&lt;/code&gt; .</source>
          <target state="translated">Pod :: Simple是由Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt;创建的，代码是从Marek Rouchal的&lt;a href=&quot;../find&quot;&gt;Pod :: Find&lt;/a&gt;借来的，而后者又从Nick Ing-Simmons的 &lt;code&gt;PodToHtml&lt;/code&gt; 借来了代码。</target>
        </trans-unit>
        <trans-unit id="8185c68a0339f127d3dbf1b4ad4adf9a512efe5f" translate="yes" xml:space="preserve">
          <source>Pod::Simple was created by Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt;. But don't bother him, he's retired.</source>
          <target state="translated">Pod :: Simple是由Sean M. Burke &amp;lt;sburke@cpan.org&amp;gt;创建的。但是不要打扰他，他已经退休了。</target>
        </trans-unit>
        <trans-unit id="d80b5e8d9939c2b2cdcf8caadd6b9ea76e6a4a21" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Checker</source>
          <target state="translated">Pod::Simple::Checker</target>
        </trans-unit>
        <trans-unit id="55590025c27353d8a373860de047b5dce37dba23" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Checker -- check the Pod syntax of a document</source>
          <target state="translated">Pod::Simple::Checker --检查文档的Pod语法。</target>
        </trans-unit>
        <trans-unit id="b74f1729aad6ae1a22d920544a38e42cdf81b6d7" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Debug</source>
          <target state="translated">Pod::Simple::Debug</target>
        </trans-unit>
        <trans-unit id="fa67e2158a0a94760ae209d78cc2c60c328cfd2a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Debug -- put Pod::Simple into trace/debug mode</source>
          <target state="translated">Pod::Simple::Debug --进入跟踪/调试模式。</target>
        </trans-unit>
        <trans-unit id="c186101b5cf38096df66f1dfcd5544f7e2c30c6c" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsText</source>
          <target state="translated">Pod::Simple::DumpAsText</target>
        </trans-unit>
        <trans-unit id="c3c292397a980ed71b52c2ff0898634dee25e619" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsText -- dump Pod-parsing events as text</source>
          <target state="translated">Pod::Simple::DumpAsText --将Pod-parsing事件转储为文本。</target>
        </trans-unit>
        <trans-unit id="cc35fcc6b860e53e9fba03174336a15b24d3e20e" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML</source>
          <target state="translated">Pod::Simple::DumpAsXML</target>
        </trans-unit>
        <trans-unit id="373b728991f6282ba763bd2a10793d147d39c8ce" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML -- turn Pod into XML</source>
          <target state="translated">Pod::Simple::DumpAsXML --将Pod转换成XML。</target>
        </trans-unit>
        <trans-unit id="9f6b85c1362b8bcf343570ad01e881211977b269" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML inherits methods from &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt;.</source>
          <target state="translated">Pod :: Simple :: DumpAsXML继承&lt;a href=&quot;../simple&quot;&gt;Pod :: Simple的&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="a26787ab4cbd9b5d37d67ecda1faa021db04bcda" translate="yes" xml:space="preserve">
          <source>Pod::Simple::DumpAsXML is a subclass of &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt; that parses Pod and turns it into indented and wrapped XML. This class is of interest to people writing Pod formatters based on Pod::Simple.</source>
          <target state="translated">波德::简单:: DumpAsXML是的子类&lt;a href=&quot;../simple&quot;&gt;波德::简单&lt;/a&gt;，它解析POD和把它变成缩进和包裹XML。此类是基于Pod :: Simple编写Pod格式器的人们所感兴趣的。</target>
        </trans-unit>
        <trans-unit id="18e3cad548b1d58d72a35d1b97df012592abca6a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::HTML</source>
          <target state="translated">Pod::Simple::HTML</target>
        </trans-unit>
        <trans-unit id="9ba84d76002e656d6a841be7c0fa1ddaf7a15278" translate="yes" xml:space="preserve">
          <source>Pod::Simple::HTML - convert Pod to HTML</source>
          <target state="translated">Pod::Simple::HTML-将Pod转换为HTML。</target>
        </trans-unit>
        <trans-unit id="4f616c51b55e2caed067f512efd6be765988729c" translate="yes" xml:space="preserve">
          <source>Pod::Simple::HTMLBatch</source>
          <target state="translated">Pod::Simple::HTMLBatch</target>
        </trans-unit>
        <trans-unit id="b714f30d97375e99cc3dc025fe21efb3928ffb30" translate="yes" xml:space="preserve">
          <source>Pod::Simple::HTMLBatch - convert several Pod files to several HTML files</source>
          <target state="translated">Pod::Simple::HTMLBatch-将多个Pod文件转换为多个HTML文件。</target>
        </trans-unit>
        <trans-unit id="c7d427af968fe5b5f7cabfdd1b7609d966dc62cc" translate="yes" xml:space="preserve">
          <source>Pod::Simple::LinkSection</source>
          <target state="translated">Pod::Simple::LinkSection</target>
        </trans-unit>
        <trans-unit id="565e4c6e11a593b50f5257b1a4aee37099620372" translate="yes" xml:space="preserve">
          <source>Pod::Simple::LinkSection -- represent &quot;section&quot; attributes of L codes</source>
          <target state="translated">Pod::Simple::LinkSection --代表L代码的 &quot;部分 &quot;属性。</target>
        </trans-unit>
        <trans-unit id="04192c711189c3d3745e9766bf472b32950a1f73" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Methody</source>
          <target state="translated">Pod::Simple::Methody</target>
        </trans-unit>
        <trans-unit id="0ca575b26347f441076a6fd1a824c79b25cf2619" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Methody -- turn Pod::Simple events into method calls</source>
          <target state="translated">Pod::Simple::Methody --将Pod::Simple事件转化为方法调用。</target>
        </trans-unit>
        <trans-unit id="7aa02a3f7b5768f2a6ec877904dc7ab387a3061a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParser</source>
          <target state="translated">Pod::Simple::PullParser</target>
        </trans-unit>
        <trans-unit id="ea0c112c9214628c826e97034dffc164b33f6a82" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParser -- a pull-parser interface to parsing Pod</source>
          <target state="translated">Pod::Simple::PullParser --一个用于解析Pod的pull-parser接口。</target>
        </trans-unit>
        <trans-unit id="070ea3cf235fa0c5ea455a6107c6b1c28503ff41" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserEndToken</source>
          <target state="translated">Pod::Simple::PullParserEndToken</target>
        </trans-unit>
        <trans-unit id="0e20ea7a70dab49b1f0f66e63f1a06a2f448b097" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserEndToken -- end-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod::Simple::PullParserEndToken --来自Pod::Simple::PullParser的结束标记。</target>
        </trans-unit>
        <trans-unit id="11aea837de023672a7a9d2518ea0e8e11a95f00a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserStartToken</source>
          <target state="translated">Pod::Simple::PullParserStartToken</target>
        </trans-unit>
        <trans-unit id="d6244e584441e2b0f907fb0ffecde2defcc17cae" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserStartToken -- start-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod::Simple::PullParserStartToken --来自 Pod::Simple::PullParser 的启动令牌。</target>
        </trans-unit>
        <trans-unit id="41b32f7393c26878ea6e6764691f6ab8d4cfed16" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserTextToken</source>
          <target state="translated">Pod::Simple::PullParserTextToken</target>
        </trans-unit>
        <trans-unit id="85a00c2aa32007d196ff05d09a358b591b60a9d7" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserTextToken -- text-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod::Simple::PullParserTextToken --来自Pod::Simple::PullParser的文本标记。</target>
        </trans-unit>
        <trans-unit id="af99c7c32db60fbc39ffa01aa36158222378886f" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserToken</source>
          <target state="translated">Pod::Simple::PullParserToken</target>
        </trans-unit>
        <trans-unit id="83ed709c868d2cc4eff657e59deb01ec607246dd" translate="yes" xml:space="preserve">
          <source>Pod::Simple::PullParserToken -- tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod::Simple::PullParserToken --来自Pod::Simple::PullParser的标记。</target>
        </trans-unit>
        <trans-unit id="cd8b2814ae13bcab0bbe442896010091755dc3df" translate="yes" xml:space="preserve">
          <source>Pod::Simple::RTF</source>
          <target state="translated">Pod::Simple::RTF</target>
        </trans-unit>
        <trans-unit id="b3241001e4eb1949e4d0740b263d2fb59490fadf" translate="yes" xml:space="preserve">
          <source>Pod::Simple::RTF -- format Pod as RTF</source>
          <target state="translated">Pod::Simple::RTF --将Pod格式化为RTF。</target>
        </trans-unit>
        <trans-unit id="7cec88f41732497c431990231ff60d0d97239c5a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Search</source>
          <target state="translated">Pod::Simple::Search</target>
        </trans-unit>
        <trans-unit id="e1ea8fdb67de63159764e718db4fbefbb27c467f" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Search - find POD documents in directory trees</source>
          <target state="translated">Pod::Simple::Search-在目录树中查找POD文档。</target>
        </trans-unit>
        <trans-unit id="4bec063b1fe4a8b7088da5083ba7437146419ca6" translate="yes" xml:space="preserve">
          <source>Pod::Simple::SimpleTree</source>
          <target state="translated">Pod::Simple::SimpleTree</target>
        </trans-unit>
        <trans-unit id="eea909e0d762cb819c8aa8330fdb9ba6a9be4d16" translate="yes" xml:space="preserve">
          <source>Pod::Simple::SimpleTree -- parse Pod into a simple parse tree</source>
          <target state="translated">Pod::Simple::SimpleTree --将Pod解析成一棵简单的解析树。</target>
        </trans-unit>
        <trans-unit id="5da91d8d6431a8c01e6c864a85dab3bf9cec1f3e" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Subclassing</source>
          <target state="translated">Pod::Simple::Subclassing</target>
        </trans-unit>
        <trans-unit id="b18ba6877611e38d5ebeca357ca45de50b3d8f5a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Text</source>
          <target state="translated">Pod::Simple::Text</target>
        </trans-unit>
        <trans-unit id="753e56ce7ac1a58ad889fddf470a50b96539c6da" translate="yes" xml:space="preserve">
          <source>Pod::Simple::Text -- format Pod as plaintext</source>
          <target state="translated">Pod::Simple::Text --将Pod格式化为纯文本。</target>
        </trans-unit>
        <trans-unit id="8d8c6d10cf65bae9e13056ddeb8c6d2c2a890ff6" translate="yes" xml:space="preserve">
          <source>Pod::Simple::TextContent</source>
          <target state="translated">Pod::Simple::TextContent</target>
        </trans-unit>
        <trans-unit id="7e136e15cf39e6850f0880e93ca8c30b3d62e90f" translate="yes" xml:space="preserve">
          <source>Pod::Simple::TextContent -- get the text content of Pod</source>
          <target state="translated">Pod::Simple::TextContent --获取Pod的文本内容。</target>
        </trans-unit>
        <trans-unit id="c87067a51be41176018a7a02a831c44466936f6a" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XHTML</source>
          <target state="translated">Pod::Simple::XHTML</target>
        </trans-unit>
        <trans-unit id="259f074470a9013b0eea26649d0b91cffcd63426" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XHTML -- format Pod as validating XHTML</source>
          <target state="translated">Pod::Simple::XHTML --将Pod格式化为验证XHTML。</target>
        </trans-unit>
        <trans-unit id="fcd3e6ec8f3899adef753786dbd1ab596eb81dbe" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XHTML offers a number of methods that modify the format of the HTML output. Call these after creating the parser object, but before the call to &lt;code&gt;parse_file&lt;/code&gt; :</source>
          <target state="translated">Pod :: Simple :: XHTML提供了许多修改HTML输出格式的方法。在创建解析器对象之后，但在调用 &lt;code&gt;parse_file&lt;/code&gt; 之前调用它们：</target>
        </trans-unit>
        <trans-unit id="951593ce225e4b7953c95143c2dd0fc68256192b" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream</source>
          <target state="translated">Pod::Simple::XMLOutStream</target>
        </trans-unit>
        <trans-unit id="2c8ebe8007a83f6db16cd28e4028774e22050e1e" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream -- turn Pod into XML</source>
          <target state="translated">Pod::Simple::XMLOutStream --将Pod转为XML。</target>
        </trans-unit>
        <trans-unit id="5a6dda8cf65a6f2f753c09f42fcc82ca0f054678" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream inherits methods from &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt;.</source>
          <target state="translated">Pod :: Simple :: XMLOutStream继承&lt;a href=&quot;../simple&quot;&gt;Pod :: Simple的&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="b5393b17d53eb5cd3e02f552010cdbdc23dd6294" translate="yes" xml:space="preserve">
          <source>Pod::Simple::XMLOutStream is a subclass of &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt; that parses Pod and turns it into XML.</source>
          <target state="translated">波德::简单:: XMLOutStream是的子类&lt;a href=&quot;../simple&quot;&gt;波德::简单&lt;/a&gt;，它分析波德并将其转化为XML。</target>
        </trans-unit>
        <trans-unit id="4c7f94950bba4ec35927384f3ba52a47b2d388e7" translate="yes" xml:space="preserve">
          <source>Pod::Text</source>
          <target state="translated">Pod::Text</target>
        </trans-unit>
        <trans-unit id="e6e584d20fd5725d4428861f69402acfdd834bf0" translate="yes" xml:space="preserve">
          <source>Pod::Text - Convert POD data to formatted ASCII text</source>
          <target state="translated">Pod::Text-将POD数据转换为格式化的ASCII文本。</target>
        </trans-unit>
        <trans-unit id="519614764ccb1ff38de936b78f067c16eca0fe48" translate="yes" xml:space="preserve">
          <source>Pod::Text is a module that can convert documentation in the POD format (the preferred language for documenting Perl) into formatted ASCII. It uses no special formatting controls or codes whatsoever, and its output is therefore suitable for nearly any device.</source>
          <target state="translated">Pod::Text 是一个模块,它可以将 POD 格式(Perl 文档的首选语言)的文档转换为格式化的 ASCII 文件。它没有使用任何特殊的格式化控件或代码,因此它的输出几乎适用于任何设备。</target>
        </trans-unit>
        <trans-unit id="3b000e1532343476a2f005325a7e1d5a7cc21c94" translate="yes" xml:space="preserve">
          <source>Pod::Text::Color</source>
          <target state="translated">Pod::Text::Color</target>
        </trans-unit>
        <trans-unit id="481fceb7f0a093b935ebdf609b3ea4b2ecf12680" translate="yes" xml:space="preserve">
          <source>Pod::Text::Color - Convert POD data to formatted color ASCII text</source>
          <target state="translated">Pod::Text::Color-将POD数据转换为格式化的彩色ASCII文本。</target>
        </trans-unit>
        <trans-unit id="77f334b564bfb0176f5034dad3905349c4003fa8" translate="yes" xml:space="preserve">
          <source>Pod::Text::Color is a simple subclass of Pod::Text that highlights output text using ANSI color escape sequences. Apart from the color, it in all ways functions like Pod::Text. See &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">Pod :: Text :: Color是Pod :: Text的简单子类，它使用ANSI颜色转义序列突出显示输出文本。除颜色外，它在所有方面都类似于Pod :: Text。有关详细信息和可用选项，请参见&lt;a href=&quot;../text&quot;&gt;Pod :: Text&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1bbee340278a2ff3fc6d6d87793be1b3326a3164" translate="yes" xml:space="preserve">
          <source>Pod::Text::Overstrike</source>
          <target state="translated">Pod::Text::Overstrike</target>
        </trans-unit>
        <trans-unit id="6f979e30783784683adf1aac75e360359ed243cf" translate="yes" xml:space="preserve">
          <source>Pod::Text::Overstrike - Convert POD data to formatted overstrike text</source>
          <target state="translated">Pod::Text::Overstrike-将POD数据转换为格式化的Overstrike文本。</target>
        </trans-unit>
        <trans-unit id="29be1312d16601e968f895f7174874218cfa222e" translate="yes" xml:space="preserve">
          <source>Pod::Text::Overstrike is a simple subclass of Pod::Text that highlights output text using overstrike sequences, in a manner similar to nroff. Characters in bold text are overstruck (character, backspace, character) and characters in underlined text are converted to overstruck underscores (underscore, backspace, character). This format was originally designed for hard-copy terminals and/or line printers, yet is readable on soft-copy (CRT) terminals.</source>
          <target state="translated">Pod::Text::Overstrike是Pod::Text的一个简单的子类,它以类似于nroff的方式,使用overstrike序列来突出输出文本。粗体文本中的字符会被覆盖(字符、退格、字符),而下划线文本中的字符会被转换为覆盖的下划线(下划线、退格、字符)。这种格式最初是为硬拷贝终端和/或行式打印机设计的,但在软拷贝(CRT)终端上也可以阅读。</target>
        </trans-unit>
        <trans-unit id="7195453df8fc7b6eab0965ce075c75610190c6a6" translate="yes" xml:space="preserve">
          <source>Pod::Text::Termcap</source>
          <target state="translated">Pod::Text::Termcap</target>
        </trans-unit>
        <trans-unit id="22f155581256a8a1fab5e33d67ab86301d7bc4cd" translate="yes" xml:space="preserve">
          <source>Pod::Text::Termcap - Convert POD data to ASCII text with format escapes</source>
          <target state="translated">Pod::Text::Termcap-通过格式转义将POD数据转换为ASCII文本。</target>
        </trans-unit>
        <trans-unit id="4aec2a63ef082d360b91e6eb0afca126e8b2efc0" translate="yes" xml:space="preserve">
          <source>Pod::Text::Termcap is a simple subclass of Pod::Text that highlights output text using the correct termcap escape sequences for the current terminal. Apart from the format codes, it in all ways functions like Pod::Text. See &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">Pod :: Text :: Termcap是Pod :: Text的简单子类，它使用当前终端的正确termcap转义序列突出显示输出文本。除了格式代码，它在所有方面都类似于Pod :: Text。有关详细信息和可用选项，请参见&lt;a href=&quot;../text&quot;&gt;Pod :: Text&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01ead75c44533a688798cad50ab41fa8f303554d" translate="yes" xml:space="preserve">
          <source>Pod::Usage</source>
          <target state="translated">Pod::Usage</target>
        </trans-unit>
        <trans-unit id="b4dc8d5361b7e455072cf29ee34ca11a59abca9a" translate="yes" xml:space="preserve">
          <source>Pod::Usage - print a usage message from embedded pod documentation</source>
          <target state="translated">Pod::Usage-从嵌入式 pod 文档中打印使用信息</target>
        </trans-unit>
        <trans-unit id="7ad7eae188bc449da645418942520b12991444b2" translate="yes" xml:space="preserve">
          <source>Pointer to a structure encapsulating the state of the parsing operation currently in progress. The pointer can be locally changed to perform a nested parse without interfering with the state of an outer parse. Individual members of &lt;code&gt;PL_parser&lt;/code&gt; have their own documentation.</source>
          <target state="translated">指向封装当前正在进行的解析操作状态的结构的指针。可以在本地更改指针以执行嵌套解析，而不会干扰外部解析的状态。 &lt;code&gt;PL_parser&lt;/code&gt; 的各个成员都有自己的文档。</target>
        </trans-unit>
        <trans-unit id="569cfd3e6d40d0f45b19803b2cef265e9a1d1cb3" translate="yes" xml:space="preserve">
          <source>Pointer to the character following the physical end of the string (i.e. the &lt;code&gt;\0&lt;/code&gt; , if any).</source>
          <target state="translated">指向字符串物理结尾之后的字符的指针（即 &lt;code&gt;\0&lt;/code&gt; ，如果有的话）。</target>
        </trans-unit>
        <trans-unit id="c7efb8f2f5c41fc448cd25b9357a4b637d7c3c35" translate="yes" xml:space="preserve">
          <source>Pointer to the linearisation function, described below.</source>
          <target state="translated">指向线性化函数的指针,如下所述。</target>
        </trans-unit>
        <trans-unit id="93e37c8eb5980406ef58242eae9fe75acd07201b" translate="yes" xml:space="preserve">
          <source>Pointer to the per-subroutine peephole optimiser. This is a function that gets called at the end of compilation of a Perl subroutine (or equivalently independent piece of Perl code) to perform fixups of some ops and to perform small-scale optimisations. The function is called once for each subroutine that is compiled, and is passed, as sole parameter, a pointer to the op that is the entry point to the subroutine. It modifies the op tree in place.</source>
          <target state="translated">指向每个子程序的窥视孔优化器的指针。这个函数在Perl子程序(或等价的独立Perl代码)编译结束时被调用,用于对一些操作进行修复和小规模的优化。这个函数对每一个被编译的子程序都会被调用一次,作为唯一的参数,它被传递给一个指向子程序入口的 op 的指针。它在原地修改 op 树。</target>
        </trans-unit>
        <trans-unit id="d2e62507cb5b989fbd3aba1b8f6ac801e56c7fb1" translate="yes" xml:space="preserve">
          <source>Pointer to the physical start of the string.</source>
          <target state="translated">指向字符串的物理起始点的指针。</target>
        </trans-unit>
        <trans-unit id="24a8aad8d082073a41e895d4c5a7e7f9947568de" translate="yes" xml:space="preserve">
          <source>Pointer to the position in the string where matching should start; it might not be equal to &lt;code&gt;strbeg&lt;/code&gt; (for example in a later iteration of &lt;code&gt;/.../g&lt;/code&gt; ).</source>
          <target state="translated">指向字符串中应该开始匹配的位置的指针；它可能不等于 &lt;code&gt;strbeg&lt;/code&gt; （例如，在以后的 &lt;code&gt;/.../g&lt;/code&gt; 迭代中）。</target>
        </trans-unit>
        <trans-unit id="5f83ff7c09e64b6014d200a49cf4d57b3fe2a3b7" translate="yes" xml:space="preserve">
          <source>Pointer to the recursive peephole optimiser. This is a function that gets called at the end of compilation of a Perl subroutine (or equivalently independent piece of Perl code) to perform fixups of some ops and to perform small-scale optimisations. The function is called once for each chain of ops linked through their &lt;code&gt;op_next&lt;/code&gt; fields; it is recursively called to handle each side chain. It is passed, as sole parameter, a pointer to the op that is at the head of the chain. It modifies the op tree in place.</source>
          <target state="translated">指向递归窥孔优化器的指针。这个函数在Perl子例程（或等效地独立的Perl代码）的编译结束时被调用，以执行某些操作的修正并进行小规模优化。通过 &lt;code&gt;op_next&lt;/code&gt; 字段链接的每个op链都会调用一次该函数；它被递归调用以处理每个侧链。作为唯一参数，将其传递给指向链顶部的op的指针。它会修改操作树。</target>
        </trans-unit>
        <trans-unit id="1b15de7f05dc81e7a10d8422ae41b092aa35ff88" translate="yes" xml:space="preserve">
          <source>Pointer-To-Integer and Integer-To-Pointer</source>
          <target state="translated">指针到整数和整数到指针。</target>
        </trans-unit>
        <trans-unit id="8db4543231fbc881b475cb920918beb06e6957b1" translate="yes" xml:space="preserve">
          <source>Pointers for How to Use Them</source>
          <target state="translated">如何使用它们的要点</target>
        </trans-unit>
        <trans-unit id="9d0e53b7caa90905a98f7bada48b61cffae6dfc0" translate="yes" xml:space="preserve">
          <source>Points directly to the body of the &lt;a href=&quot;#PL_comppad&quot;&gt;PL_comppad&lt;/a&gt; array. (I.e., this is &lt;code&gt;PAD_ARRAY(PL_comppad)&lt;/code&gt; .)</source>
          <target state="translated">直接指向&lt;a href=&quot;#PL_comppad&quot;&gt;PL_comppad&lt;/a&gt;数组的主体。（即，这是 &lt;code&gt;PAD_ARRAY(PL_comppad)&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="cd50ccbc12c1ecc8379096a1e5a3ea405480427c" translate="yes" xml:space="preserve">
          <source>Points to note this time are</source>
          <target state="translated">这次要注意的几点是</target>
        </trans-unit>
        <trans-unit id="a1ba2b16bcbd7c4705abb0e0545c7340c416117e" translate="yes" xml:space="preserve">
          <source>Points to note this time:</source>
          <target state="translated">这次要注意的几点。</target>
        </trans-unit>
        <trans-unit id="7f6158e808f6832883a61fff6f7473e7ffa8d937" translate="yes" xml:space="preserve">
          <source>Points to note:</source>
          <target state="translated">需要注意的是:</target>
        </trans-unit>
        <trans-unit id="cd6843c94f87c938da300ec96118788e1ddfc762" translate="yes" xml:space="preserve">
          <source>Points to the current position of lexing inside the lexer buffer. Characters around this point may be freely examined, within the range delimited by &lt;code&gt;SvPVX(&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;)&lt;/code&gt; and &lt;a href=&quot;#PL_parser-%3ebufend&quot;&gt;PL_parser-&amp;gt;bufend&lt;/a&gt;. The octets of the buffer may be intended to be interpreted as either UTF-8 or Latin-1, as indicated by &lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt;.</source>
          <target state="translated">指向词法分析器缓冲区内词法化的当前位置。在由 &lt;code&gt;SvPVX(&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;)&lt;/code&gt; 和&lt;a href=&quot;#PL_parser-%3ebufend&quot;&gt;PL_parser-&amp;gt; bufend&lt;/a&gt;分隔的范围内，可以自由检查此点附近的字符。如&lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt;所示，缓冲区的八位位组可以解释为UTF-8或Latin-1 。</target>
        </trans-unit>
        <trans-unit id="466e9eed69ae31dedb4b4028316ec9e7f9681d76" translate="yes" xml:space="preserve">
          <source>Points to the start of the current line inside the lexer buffer. This is useful for indicating at which column an error occurred, and not much else. This must be updated by any lexing code that consumes a newline; the function &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt; handles this detail.</source>
          <target state="translated">指向词法分析器缓冲区内当前行的开头。这对于指示错误发生在哪一列以及不多的错误很有用。这必须由使用换行符的所有词法分析代码进行更新；函数&lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt;处理此细节。</target>
        </trans-unit>
        <trans-unit id="6de0b0c656444c55bac48c2e467aa0f841083cdc" translate="yes" xml:space="preserve">
          <source>Poison</source>
          <target state="translated">Poison</target>
        </trans-unit>
        <trans-unit id="7cba271b13a59766b27ccda79d87f5f8e1106365" translate="yes" xml:space="preserve">
          <source>PoisonWith(0xAB) for catching access to allocated but uninitialized memory.</source>
          <target state="translated">PoisonWith(0xAB)用于捕获对已分配但未初始化的内存的访问。</target>
        </trans-unit>
        <trans-unit id="a5b29691b9f8fe361aff7b2c944f86e8960b1c90" translate="yes" xml:space="preserve">
          <source>PoisonWith(0xEF) for catching access to freed memory.</source>
          <target state="translated">PoisonWith(0xEF)用于捕获对释放内存的访问。</target>
        </trans-unit>
        <trans-unit id="a5f252f9719bb4092eedbac8a2fb53fbb1039f3c" translate="yes" xml:space="preserve">
          <source>Poking at Perl</source>
          <target state="translated">戳穿Perl</target>
        </trans-unit>
        <trans-unit id="1ebd3f7855634092b44032651f78d5bfb891f918" translate="yes" xml:space="preserve">
          <source>Policy on building prerequisites (follow, ask or ignore)?</source>
          <target state="translated">建设先决条件的政策(遵循、询问还是忽略)?</target>
        </trans-unit>
        <trans-unit id="7f660ccc3d4a7cddf101f6e1c123d42735446293" translate="yes" xml:space="preserve">
          <source>Policy on installing 'build_requires' modules (yes, no, ask/yes, ask/no)?</source>
          <target state="translated">安装'build_requires'模块的政策(是,否,问/是,问/否)?</target>
        </trans-unit>
        <trans-unit id="d27d963e0d2061e0a6349a591740d5932e76c404" translate="yes" xml:space="preserve">
          <source>Pollutes global name space for development only task.</source>
          <target state="translated">污染全局名称空间,仅用于开发任务。</target>
        </trans-unit>
        <trans-unit id="989fc91d044783d05d714e433d3e90dca9bdf4da" translate="yes" xml:space="preserve">
          <source>Polymorphism</source>
          <target state="translated">Polymorphism</target>
        </trans-unit>
        <trans-unit id="948fb69e483149176df26ee3b58ea284be041444" translate="yes" xml:space="preserve">
          <source>Polymorphism is one of the key concepts of object-oriented design.</source>
          <target state="translated">多态性是面向对象设计的重要概念之一。</target>
        </trans-unit>
        <trans-unit id="d60d997de9e6fe93b76346e1fd7960a534079d99" translate="yes" xml:space="preserve">
          <source>Pops a double off the stack.</source>
          <target state="translated">在堆栈里打出双倍的牌。</target>
        </trans-unit>
        <trans-unit id="22a0e05c4b5984d222d58a3bf9aebf24e0c8d1a8" translate="yes" xml:space="preserve">
          <source>Pops a long off the stack.</source>
          <target state="translated">从堆栈中弹出一个长。</target>
        </trans-unit>
        <trans-unit id="832e72784da0b9e3a4bd68c7f793defaefe32db9" translate="yes" xml:space="preserve">
          <source>Pops a string off the stack which must consist of bytes i.e. characters &amp;lt; 256.</source>
          <target state="translated">从堆栈中弹出一个字符串，该字符串必须由字节组成，即字符&amp;lt;256。</target>
        </trans-unit>
        <trans-unit id="ec17353cdd71390a8e418b8c83b4061cd7788eaf" translate="yes" xml:space="preserve">
          <source>Pops a string off the stack.</source>
          <target state="translated">从堆栈中弹出一个字符串。</target>
        </trans-unit>
        <trans-unit id="cc089051dba8a74af21264418e130c57e2a1f868" translate="yes" xml:space="preserve">
          <source>Pops a string off the stack. Identical to POPp. There are two names for historical reasons.</source>
          <target state="translated">从栈中弹出一个字符串。与POPp相同。由于历史原因,有两个名字。</target>
        </trans-unit>
        <trans-unit id="7bc58c6d11b5634fdac1fab6062117497b69ac1a" translate="yes" xml:space="preserve">
          <source>Pops an SV off the stack.</source>
          <target state="translated">从堆栈中弹出一个SV。</target>
        </trans-unit>
        <trans-unit id="ef2c625805cf71b84685943309767e2a59dbd613" translate="yes" xml:space="preserve">
          <source>Pops an integer off the stack.</source>
          <target state="translated">从堆栈中弹出一个整数。</target>
        </trans-unit>
        <trans-unit id="b55131b918b111fc0b929f5b1aeacc6459ed4da9" translate="yes" xml:space="preserve">
          <source>Pops and returns the last value of the array, shortening the array by one element.</source>
          <target state="translated">弹出并返回数组的最后一个值,将数组缩短一个元素。</target>
        </trans-unit>
        <trans-unit id="72124d219ef96cd5acab8db5a13304309882b7c2" translate="yes" xml:space="preserve">
          <source>Populates the arrays @keys with the all the keys that would pass an &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; tests, and populates @hidden with the remaining legal keys that have not been utilized.</source>
          <target state="translated">使用将通过 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 测试的所有键填充@keys数组，并使用尚未使用的其余合法键填充@hidden。</target>
        </trans-unit>
        <trans-unit id="cee02632a33989e168b12ec741e01b5327a83cb2" translate="yes" xml:space="preserve">
          <source>Populating a freshly installed perl with one's favorite modules is pretty easy if you maintain a private bundle definition file. To get a useful blueprint of a bundle definition file, the command autobundle can be used on the CPAN shell command line. This command writes a bundle definition file for all modules installed for the current perl interpreter. It's recommended to run this command once only, and from then on maintain the file manually under a private name, say Bundle/my_bundle.pm. With a clever bundle file you can then simply say</source>
          <target state="translated">如果你维护了一个私有的 bundle 定义文件,那么在刚安装的 perl 中填充一个自己喜欢的模块是非常容易的。为了得到一个有用的bundle定义文件的蓝图,可以在CPAN shell命令行中使用autobundle命令。这个命令为当前perl解释器安装的所有模块写一个bundle定义文件。建议只运行一次这个命令,从那时起,用一个私人名字手动维护这个文件,比如说Bundle/my_bundle.pm。有了一个聪明的bundle文件,你可以简单的说</target>
        </trans-unit>
        <trans-unit id="b307b88c84327b1804aee227595be53342245965" translate="yes" xml:space="preserve">
          <source>Portability</source>
          <target state="translated">Portability</target>
        </trans-unit>
        <trans-unit id="429fea4a8a23d35cb2866b8a8e54eff4f9f7d19a" translate="yes" xml:space="preserve">
          <source>Portability Between PA-RISC Versions</source>
          <target state="translated">PA-RISC版本之间的可移植性</target>
        </trans-unit>
        <trans-unit id="0b34819d0cef9dd29634d338c59e4d3820c728c9" translate="yes" xml:space="preserve">
          <source>Portability fixes, such as changes to Configure and the files in the hints/ folder.</source>
          <target state="translated">可移植性修复,如对Configure和hints/文件夹中的文件进行修改。</target>
        </trans-unit>
        <trans-unit id="1f251a1b72b795d210c37cc8808dfb91c5841c32" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#-X&quot;&gt;-X in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#-X&quot;&gt;perlport中的-X&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84a89b40cc0009e8b885def1fe631517f13c8804" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#alarm&quot;&gt;alarm in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#alarm&quot;&gt;在perlport中&lt;/a&gt;发出警报。</target>
        </trans-unit>
        <trans-unit id="f58a7cb3f3e811c1eac599d9c7bf48061833c027" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#atan2&quot;&gt;atan2 in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#atan2&quot;&gt;perlport中的atan2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ed8beab57923abb2517704ee81711f38cf21b94" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#binmode&quot;&gt;binmode in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#binmode&quot;&gt;perlport中的binmode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="171e986303317134be33b061b9ce46ef505fd940" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#chmod&quot;&gt;chmod in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#chmod&quot;&gt;perlport中的chmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="931cc82efd9b523c1ff1857e1014607381be1f1a" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#chown&quot;&gt;chown in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#chown&quot;&gt;perlport中的chown&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34e114d642008c4fff0621ad0f7fefa204d02d90" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#chroot&quot;&gt;chroot in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#chroot&quot;&gt;perlport中的chroot&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f1c48eaf2397ca415e41a6fa9517451281c277c" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#crypt&quot;&gt;crypt in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#crypt&quot;&gt;perlport中的crypt&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c45bac113f4c308e82936e60df6df6c1931dbb8b" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#dbmclose&quot;&gt;dbmclose in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#dbmclose&quot;&gt;perlport中的dbmclose&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fbf347423e5b87d1b332ca9b3d6108fdc3a88e2" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#dbmopen&quot;&gt;dbmopen in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#dbmopen&quot;&gt;perlport中的dbmopen&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8eb5ec3466f6cdf4226f3ab0929d83f32b278695" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#dump&quot;&gt;dump in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#dump&quot;&gt;在perlport中转储&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f8d3bbf0b7025b86f5673b95a17a0ef3c1c1212" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#exec&quot;&gt;exec in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#exec&quot;&gt;perlport中的exec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="311229258591d86e072ab3c10225ef0a5e3642a4" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#exit&quot;&gt;exit in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#exit&quot;&gt;在perlport中退出&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ce6eaa96048196db85fe31b8746c5d58fd9e8d1" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#fcntl&quot;&gt;fcntl in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#fcntl&quot;&gt;perlport中的fcntl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="079a6396bf954e8003a8a937147cde117ff06852" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#flock&quot;&gt;flock in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#flock&quot;&gt;蜂拥而至&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4062b066ff4e5e57c22dcd6e5f3812306be6cb55" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#fork&quot;&gt;fork in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#fork&quot;&gt;在perlport中派生&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="374cc0f9e27f1d2543a6f2e6f55c2b2ecf24a0ca" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#getlogin&quot;&gt;getlogin in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#getlogin&quot;&gt;perlport中的getlogin&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9937a6aa9eb14db23986faebc9c754557a9cb63e" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#getpgrp&quot;&gt;getpgrp in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#getpgrp&quot;&gt;perlport中的getpgrp&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a3c9c808efbd9e2a03c0ba22780dc63fa80b976" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#getppid&quot;&gt;getppid in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#getppid&quot;&gt;perlport中的getppid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c8bf9cafbfe5a3727f717e18fe5637a9657d1e3" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#getpriority&quot;&gt;getpriority in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#getpriority&quot;&gt;perlport中的getpriority&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c9a92d771d324eae7e1f6085b85450eaa5f4c33" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#getpwnam&quot;&gt;getpwnam in perlport&lt;/a&gt; to &lt;a href=&quot;../perlport#endservent&quot;&gt;endservent in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#getpwnam&quot;&gt;perlport中的getpwnam&lt;/a&gt;到&lt;a href=&quot;../perlport#endservent&quot;&gt;perlport中的endersvent&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95a33925a0db79a48d3c1dacd96866c72e816ad1" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#getsockopt&quot;&gt;getsockopt in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#getsockopt&quot;&gt;perlport中的getsockopt&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="451fd1ca3fe7d172aad55237b40c25c3720eefee" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#glob&quot;&gt;glob in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#glob&quot;&gt;perlport中的&lt;/a&gt;问题。</target>
        </trans-unit>
        <trans-unit id="e375af9f12d1c6f2bc03839a36e2ac89a755e4ad" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#gmtime&quot;&gt;gmtime in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#gmtime&quot;&gt;perlport中的gmtime&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb0916bfbaab25389dda35cbe69c6f9a0cabd92b" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#ioctl&quot;&gt;ioctl in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#ioctl&quot;&gt;perlport中的ioctl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2de3944e42155996eeb50944ed2976186dfbbfa5" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#kill&quot;&gt;kill in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#kill&quot;&gt;在perlport中杀死&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7eaa68d564eddd4045a9dd57d744941b1da03a13" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#link&quot;&gt;link in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#link&quot;&gt;perlport中的链接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c477c22606ba7a529797dfc38e60dae51d00171" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#localtime&quot;&gt;localtime in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#localtime&quot;&gt;perlport中的本地时间&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e2c5cb8f92dc1d3aaef9234fc3211969082289f" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#lstat&quot;&gt;lstat in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#lstat&quot;&gt;perlport中的lstat&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac214a3223717227344f149c9e9400019a1ac97d" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#msgctl&quot;&gt;msgctl in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#msgctl&quot;&gt;perlport中的msgctl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2aacc2a0a20793e8dc06ed28334f96f1109414e4" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#msgget&quot;&gt;msgget in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#msgget&quot;&gt;perlport中的msgget&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58c6893a0d57344354cb89274be70b30e58e8319" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#msgrcv&quot;&gt;msgrcv in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#msgrcv&quot;&gt;perlport中的msgrcv&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ece2f63ba6ea017230ff113a7682ad9cb61a1b9" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#msgsnd&quot;&gt;msgsnd in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#msgsnd&quot;&gt;perlport中的msgsnd&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fd2c0061cf9f7d59627ee7926b142b43c0bb5d8" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#open&quot;&gt;open in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#open&quot;&gt;在perlport中公开&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8d9dcc4183e959a0a8c406e297f639b821d7e6a" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#readlink&quot;&gt;readlink in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#readlink&quot;&gt;perlport中的readlink&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d80623fff5a5452ded7eca5cafeaad9a220479f" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#rename&quot;&gt;rename in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#rename&quot;&gt;在perlport中重命名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60cb95b01d7cac1160a8fcd9aa6319e2b256dd8b" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#rewinddir&quot;&gt;rewinddir in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#rewinddir&quot;&gt;perlport中的rewinddir&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e8ee271a393b3ab35832a0399a9716bd4545be8" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#select&quot;&gt;select in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#select&quot;&gt;在perlport中选择&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a916a792a19d0914f5e538e1b61507950ed248bc" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#semctl&quot;&gt;semctl in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#semctl&quot;&gt;perlport中的semctl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6e22134dc6f984ff19dd4e0daa2f57b8baf5986" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#semget&quot;&gt;semget in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#semget&quot;&gt;perlport中的semget&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="474c50d150da4761b9c780c7974d717b1c6b2c9e" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#semop&quot;&gt;semop in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#semop&quot;&gt;perlport中的semop&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dac5afa34df9b930f8c89c10ca69e5570193c2e6" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#setpgrp&quot;&gt;setpgrp in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#setpgrp&quot;&gt;perlport中的setpgrp&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e23f276f0f8950ad13f46fae5b1b8fd4509591d7" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#setpriority&quot;&gt;setpriority in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#setpriority&quot;&gt;perlport中的setpriority&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7061e1739edc69bb246b83a096fa0981e1f5251c" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#setsockopt&quot;&gt;setsockopt in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#setsockopt&quot;&gt;perlport中的setsockopt&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6b4ae9b5ad1b08da481f8567bbfc1cb8b669699" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#shmctl&quot;&gt;shmctl in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#shmctl&quot;&gt;perlport中的shmctl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ceb7cceede55255f2c03923419ba00d17dd1373" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#shmget&quot;&gt;shmget in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#shmget&quot;&gt;perlport中的shmget&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0bc47a3fc4fc4a38ef3e0d7b17a166a775e764ce" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#shmread&quot;&gt;shmread in perlport&lt;/a&gt; and &lt;a href=&quot;../perlport#shmwrite&quot;&gt;shmwrite in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#shmread&quot;&gt;perlport中的shmread&lt;/a&gt;和&lt;a href=&quot;../perlport#shmwrite&quot;&gt;perlport中的shmwrite&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0dce41756b232765d1c032ecd3d3a0d9a8e33895" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#socketpair&quot;&gt;socketpair in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#socketpair&quot;&gt;perlport中的套接字对&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55476d750e005ffead8b73a10218424aba53ef83" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#stat&quot;&gt;stat in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#stat&quot;&gt;perlport中的stat&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71363d0b541b18ba37818287ceda27e5bde57d90" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#symlink&quot;&gt;symlink in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#symlink&quot;&gt;perlport中的symlink&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd26addde8a2d4d9d8c7b6e687d64da690b8666a" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#syscall&quot;&gt;syscall in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#syscall&quot;&gt;perlport中的syscall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3c5f3f484e4201b1f67796ad89ef59b123e7c6c" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#sysopen&quot;&gt;sysopen in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#sysopen&quot;&gt;perlport中的sysopen&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5106a8c40515e6624c616e5ac9aebbbd80552a7c" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#system&quot;&gt;system in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#system&quot;&gt;perlport中的系统&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61d1d487f826b2d057df6e670b5e42fbeac37cd3" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#times&quot;&gt;times in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#times&quot;&gt;perlport中的时间&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccbec3396a164294596f5e1e4e0bdba951cdb81e" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#truncate&quot;&gt;truncate in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#truncate&quot;&gt;在perlport中截断&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ba7b92e20617a2d8b7c263846d7133fd9ec43fc" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#umask&quot;&gt;umask in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#umask&quot;&gt;perlport中的umask&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40c14ab69251d27767b250c1548e4d933cd1a724" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#utime&quot;&gt;utime in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#utime&quot;&gt;perlport中的utime&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4675b398cb210e70ff86790451786bc0364ba2b8" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#wait&quot;&gt;wait in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#wait&quot;&gt;在perlport中等待&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3e89038c4dec1cc988024cd99589fc6629b23cf" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;../perlport#waitpid&quot;&gt;waitpid in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;../perlport#waitpid&quot;&gt;perlport中的waitpid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b70981300ecccd7b8f330cb81f6103c289bec058" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#-X&quot;&gt;-X in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#-X&quot;&gt;perlport中的-X&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4c41aff1aadd6d30ae436b6ad22a7635b760f8f" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#alarm&quot;&gt;alarm in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#alarm&quot;&gt;在perlport中&lt;/a&gt;发出警报。</target>
        </trans-unit>
        <trans-unit id="286b7051a1db4c371e7295081bf3da49c3cacee0" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#atan2&quot;&gt;atan2 in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#atan2&quot;&gt;perlport中的atan2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f60be3a8366f3adaf8b704d8496c1429fcdedb9" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#binmode&quot;&gt;binmode in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#binmode&quot;&gt;perlport中的binmode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42f721f1585fe7bf02000f11e03f8ca6dc0c3e62" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#chmod&quot;&gt;chmod in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#chmod&quot;&gt;perlport中的chmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34105bc16f3abc62a7ebdccb17b84f89ff247b43" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#chown&quot;&gt;chown in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#chown&quot;&gt;perlport中的chown&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3161ed910ec8abac73c4bb8e4ebdf2e5f427689" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#chroot&quot;&gt;chroot in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#chroot&quot;&gt;perlport中的chroot&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9a5244c82530287a1680f7e4630690500bf2c1a" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#crypt&quot;&gt;crypt in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#crypt&quot;&gt;perlport中的crypt&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8153edd1c560afaec1e5e4b29ef61cb3a5fea317" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#dbmclose&quot;&gt;dbmclose in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#dbmclose&quot;&gt;perlport中的dbmclose&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccd35e85192d4a9e665b440ebd8d98e63a21fcd8" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#dbmopen&quot;&gt;dbmopen in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#dbmopen&quot;&gt;perlport中的dbmopen&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3849ea6d3a1e8647089ee23f1c064c70b2aac7e" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#dump&quot;&gt;dump in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#dump&quot;&gt;在perlport中转储&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="159b224453525ea26178c93d815bf8c37156bca7" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#exec&quot;&gt;exec in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#exec&quot;&gt;perlport中的exec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6ef7e2af32d312e2de7c23d3ed0f7b1002c71ef" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#exit&quot;&gt;exit in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#exit&quot;&gt;在perlport中退出&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b51d3531f7ff15ab95b54d19923365629fc28679" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#fcntl&quot;&gt;fcntl in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#fcntl&quot;&gt;perlport中的fcntl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd51dc31bf44af902d7a83aa3d284782505dab81" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#flock&quot;&gt;flock in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#flock&quot;&gt;蜂拥而至&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f294df838a1631d1ff6473a2a0bb188766e13bc5" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#fork&quot;&gt;fork in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#fork&quot;&gt;在perlport中派生&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da0c8aa6744002f6e9535d51ad97f29417869561" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#getlogin&quot;&gt;getlogin in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#getlogin&quot;&gt;perlport中的getlogin&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="272ed60ca449929d819ded198fe36e06b83a39e2" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#getpgrp&quot;&gt;getpgrp in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#getpgrp&quot;&gt;perlport中的getpgrp&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf5f512293ae84473998a24961e0f9cb5d697346" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#getppid&quot;&gt;getppid in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#getppid&quot;&gt;perlport中的getppid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4a68a2a22e44665ce9dd7fd91574dcfc5d0f2cf" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#getpriority&quot;&gt;getpriority in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#getpriority&quot;&gt;perlport中的getpriority&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54c70469975f72b40e614a4aa6531b33418f0a99" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#getpwnam&quot;&gt;getpwnam in perlport&lt;/a&gt; to &lt;a href=&quot;perlport#endservent&quot;&gt;endservent in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#getpwnam&quot;&gt;perlport中的getpwnam&lt;/a&gt;到&lt;a href=&quot;perlport#endservent&quot;&gt;perlport中的endersvent&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5307cc8853752ec02882de2f2c667c8f8f4d5ea3" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#getsockopt&quot;&gt;getsockopt in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#getsockopt&quot;&gt;perlport中的getsockopt&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="242a3ea39a57b93258a257f47655ec88b832f654" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#glob&quot;&gt;glob in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#glob&quot;&gt;perlport中的&lt;/a&gt;问题。</target>
        </trans-unit>
        <trans-unit id="f8bee5ea11b2676b24bd55443d8f59d7856df650" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#gmtime&quot;&gt;gmtime in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#gmtime&quot;&gt;perlport中的gmtime&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7faa7ea82fa854bb3d8e5a2bae082d5c0b965256" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#ioctl&quot;&gt;ioctl in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#ioctl&quot;&gt;perlport中的ioctl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebcacd62a0c2062e21f33d6736a1f62fe2b0936c" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#kill&quot;&gt;kill in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#kill&quot;&gt;在perlport中杀死&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68f116e27b264194581024a236f5075dd0e4db7d" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#link&quot;&gt;link in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#link&quot;&gt;perlport中的链接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03d0db5d10e9974833b1b1c3f3599761c693ed13" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#localtime&quot;&gt;localtime in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#localtime&quot;&gt;perlport中的本地时间&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9384107c161672d710d80e232503dadb7e6b08ff" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#lstat&quot;&gt;lstat in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#lstat&quot;&gt;perlport中的lstat&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ce5d19be1cb2c6b900377e53381f0a75039f0f4" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#msgctl&quot;&gt;msgctl in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#msgctl&quot;&gt;perlport中的msgctl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="273853a12fff8d8c2877c94a799c6d11eb91e146" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#msgget&quot;&gt;msgget in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#msgget&quot;&gt;perlport中的msgget&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ce6fcc59a40ee3a712a22a117201cbb49c059ed" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#msgrcv&quot;&gt;msgrcv in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#msgrcv&quot;&gt;perlport中的msgrcv&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d8c5e98254d5ca7970f0f4f6c4659693975f475" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#msgsnd&quot;&gt;msgsnd in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#msgsnd&quot;&gt;perlport中的msgsnd&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d2b94d8d9164c5d73d2b50e195ed17ceb35e4cf" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#open&quot;&gt;open in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#open&quot;&gt;在perlport中公开&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5597b25507870cc7a3c0d873abddf08fadfbb6a5" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#readlink&quot;&gt;readlink in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#readlink&quot;&gt;perlport中的readlink&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="716e4f3a9669daacc40fd61530bd695bbd7759b6" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#rename&quot;&gt;rename in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#rename&quot;&gt;在perlport中重命名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3b295d2fa1936a3c97fdd610c884273d66474dc" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#rewinddir&quot;&gt;rewinddir in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#rewinddir&quot;&gt;perlport中的rewinddir&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e21863bd7fa9feb756c17b1f01cf46f56ecb93a" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#select&quot;&gt;select in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#select&quot;&gt;在perlport中选择&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1bb1a914f076b276ff0dc1aa94d5000b5c955de4" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#semctl&quot;&gt;semctl in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#semctl&quot;&gt;perlport中的semctl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="853d00ec5dbc8506124b23971b0b01b7963e25d5" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#semget&quot;&gt;semget in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#semget&quot;&gt;perlport中的semget&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="868cb9c221ed7185e8f4796a8e730a0f1ebda26a" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#semop&quot;&gt;semop in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#semop&quot;&gt;perlport中的semop&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25c026caff364ddc036abeccafbebdfc0f3f8775" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#setpgrp&quot;&gt;setpgrp in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#setpgrp&quot;&gt;perlport中的setpgrp&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="872bde48f35ea9e9c9a2245b619f39f1e6b3b03f" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#setpriority&quot;&gt;setpriority in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#setpriority&quot;&gt;perlport中的setpriority&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="691ffbc804de1ecccbf805bd753779ccbe3381c3" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#setsockopt&quot;&gt;setsockopt in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#setsockopt&quot;&gt;perlport中的setsockopt&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="858a2c0f7b0ded8f531191109d3429562043e02f" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#shmctl&quot;&gt;shmctl in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#shmctl&quot;&gt;perlport中的shmctl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="19231dcfd55698d417f14d1a3b6116215782cdab" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#shmget&quot;&gt;shmget in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#shmget&quot;&gt;perlport中的shmget&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="627d60e4612520cea56174ad0b16fbb3e38e20ff" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#shmread&quot;&gt;shmread in perlport&lt;/a&gt; and &lt;a href=&quot;perlport#shmwrite&quot;&gt;shmwrite in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#shmread&quot;&gt;perlport中的shmread&lt;/a&gt;和&lt;a href=&quot;perlport#shmwrite&quot;&gt;perlport中的shmwrite&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="780263b8d6206d15169032a2f7d8df22cef5bf28" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#socketpair&quot;&gt;socketpair in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#socketpair&quot;&gt;perlport中的套接字对&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b4ad715c17b55bb481c2f4b6c3a7d8ca14fd215" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#stat&quot;&gt;stat in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#stat&quot;&gt;perlport中的stat&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eabef1a008d47d2a9d7c9c7aada0ec5ae625016b" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#symlink&quot;&gt;symlink in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#symlink&quot;&gt;perlport中的symlink&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0970859fdcdbefab02ec40fb1a30eba7aa521aca" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#syscall&quot;&gt;syscall in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#syscall&quot;&gt;perlport中的syscall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0ba78b649c5ef4da0ce9e5399e7e3c970338bcb" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#sysopen&quot;&gt;sysopen in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#sysopen&quot;&gt;perlport中的sysopen&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00b0ff2d6c84acc74f68ec16df6d840bfa2a9d20" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#system&quot;&gt;system in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#system&quot;&gt;perlport中的系统&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f47ec6842d670c2b5f240b1a99a343f0be0064a8" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#times&quot;&gt;times in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#times&quot;&gt;perlport中的时间&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c05d575ea825b9eb7d154ec58cf2b3a35023f17" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#truncate&quot;&gt;truncate in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#truncate&quot;&gt;在perlport中截断&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a0723e861033da690aecdb7a0d25465db8b2fd9" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#umask&quot;&gt;umask in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#umask&quot;&gt;perlport中的umask&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9c20941f15437f18d1b942e125adae8f9f85d4c" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#utime&quot;&gt;utime in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#utime&quot;&gt;perlport中的utime&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="884a47ffafccacec9cec489bf984d5bca96a986a" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#wait&quot;&gt;wait in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#wait&quot;&gt;在perlport中等待&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b032428386020b84fe78cbe14f2bb689e3e1c1b1" translate="yes" xml:space="preserve">
          <source>Portability issues: &lt;a href=&quot;perlport#waitpid&quot;&gt;waitpid in perlport&lt;/a&gt;.</source>
          <target state="translated">可移植性问题：&lt;a href=&quot;perlport#waitpid&quot;&gt;perlport中的waitpid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db93898741dd39c4fe99b1c63e52e52213f6f2a7" translate="yes" xml:space="preserve">
          <source>Portability problems</source>
          <target state="translated">便携性问题</target>
        </trans-unit>
        <trans-unit id="079513fb0cbc5cac6b6c82c2309f1cf45564d331" translate="yes" xml:space="preserve">
          <source>Portability-wise the best option is probably to keep to the IEEE 754 64-bit doubles, and of agreed-upon endianness. Another possibility is the &lt;code&gt;&quot;%a&quot;&lt;/code&gt; ) format of &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在可移植性方面，最好的选择可能是保持IEEE 754 64位双精度和一致的字节序。另一种可能性是 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&quot;%a&quot;&lt;/code&gt; ）格式。</target>
        </trans-unit>
        <trans-unit id="3e07e11e6ce830489a0e3d7415eaa2eb4ba1b70c" translate="yes" xml:space="preserve">
          <source>Portability-wise the best option is probably to keep to the IEEE 754 64-bit doubles, and of agreed-upon endianness. Another possibility is the &lt;code&gt;&quot;%a&quot;&lt;/code&gt; ) format of &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在可移植性方面，最好的选择可能是保持IEEE 754 64位双精度和一致的字节序。另一种可能性是 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&quot;%a&quot;&lt;/code&gt; ）格式。</target>
        </trans-unit>
        <trans-unit id="6942aa2b4104144ab813bb2df92d7d21b77ab61f" translate="yes" xml:space="preserve">
          <source>Portable cases are:</source>
          <target state="translated">手提箱是:</target>
        </trans-unit>
        <trans-unit id="81d57ea512cd2b00da23b0b4e909db41c6d5f619" translate="yes" xml:space="preserve">
          <source>Portably perform operations on file names</source>
          <target state="translated">方便地对文件名进行操作</target>
        </trans-unit>
        <trans-unit id="ca3a4fa5e8330446e0c75ad92cfc7751e39dce5a" translate="yes" xml:space="preserve">
          <source>Porting</source>
          <target state="translated">Porting</target>
        </trans-unit>
        <trans-unit id="16cc9b9ed43ca5d3cf0a48ee505d3443f796b9af" translate="yes" xml:space="preserve">
          <source>Porting code from perl-5.6.X</source>
          <target state="translated">从perl-5.6.X移植代码。</target>
        </trans-unit>
        <trans-unit id="e6aa7d597be18a7e75e0ff04e1bdc44069467c90" translate="yes" xml:space="preserve">
          <source>Porting/</source>
          <target state="translated">Porting/</target>
        </trans-unit>
        <trans-unit id="ea9b53e814debd6affceeb25330fbf44281cc84b" translate="yes" xml:space="preserve">
          <source>Porting/bench.pl</source>
          <target state="translated">Porting/bench.pl</target>
        </trans-unit>
        <trans-unit id="7253564338b477221d544e36f39c603f64cc6d02" translate="yes" xml:space="preserve">
          <source>Porting/how_to_write_a_perldelta.pod</source>
          <target state="translated">Porting/how_to_write_a_perldelta.pod</target>
        </trans-unit>
        <trans-unit id="6ddfafb40f17f6ecbc175b82b5894f9f8fe5bba5" translate="yes" xml:space="preserve">
          <source>Porting/pumpkin.pod</source>
          <target state="translated">Porting/pumpkin.pod</target>
        </trans-unit>
        <trans-unit id="e1d84bb832bff9b7ba90c66df47cd4933437114a" translate="yes" xml:space="preserve">
          <source>Porting/release_managers_guide.pod</source>
          <target state="translated">Porting/release_managers_guide.pod</target>
        </trans-unit>
        <trans-unit id="641afa9afdaad52f39b2d32f8a1cd6628b42fd06" translate="yes" xml:space="preserve">
          <source>Portions copyright 2006-2008 Adam Kennedy.</source>
          <target state="translated">2006-2008年亚当-肯尼迪的部分版权。</target>
        </trans-unit>
        <trans-unit id="48a526a81927a98d8cc7484c34ddf42f9e637788" translate="yes" xml:space="preserve">
          <source>Portions of the C code in this library are copyright (c) 1994 by the Regents of the University of California. All rights reserved. The license on this code is compatible with the licensing of the rest of the distribution - please see the source code in</source>
          <target state="translated">本库中的部分C代码的版权(c)1994年由加利福尼亚大学的摄政者所拥有。保留所有权利。这段代码的许可证与其他发行版的许可证是兼容的--请看源代码中的</target>
        </trans-unit>
        <trans-unit id="1b44bd9f2e8afdb3d9a6b86ffdafa46f6fb7dc71" translate="yes" xml:space="preserve">
          <source>Portions of the data tables in this module are derived from the entity declarations in the W3C XHTML specification.</source>
          <target state="translated">本模块中的部分数据表来自于W3C XHTML规范中的实体声明。</target>
        </trans-unit>
        <trans-unit id="e21d9d1f135238fda93004ae5db1ba481150e581" translate="yes" xml:space="preserve">
          <source>Portions of this document that are still incomplete are marked with XXX.</source>
          <target state="translated">本文件中尚不完整的部分用XXX标记。</target>
        </trans-unit>
        <trans-unit id="4aa88ae214cc20e8cb9e2cfedd50aa166fe2ef36" translate="yes" xml:space="preserve">
          <source>Ports of Perl to a new platform, architecture or OS release that involve changes to the implementation.</source>
          <target state="translated">将Perl移植到新的平台、架构或操作系统版本中,涉及到对实现的改变。</target>
        </trans-unit>
        <trans-unit id="6ca22cededa3b3cbf9e73ceb1a2efd6072b76d37" translate="yes" xml:space="preserve">
          <source>Position 18 is good, but position 23 is bogus. What happened?</source>
          <target state="translated">18号位置是好的,但23号位置是假的。发生了什么事?</target>
        </trans-unit>
        <trans-unit id="f8075bf0afcc9cf807fb8c4f9c812962d64e55d5" translate="yes" xml:space="preserve">
          <source>Position information</source>
          <target state="translated">职位信息</target>
        </trans-unit>
        <trans-unit id="c044cacc39f4d91c9b8cc9ba42458a92475e6684" translate="yes" xml:space="preserve">
          <source>Position the file pointer. Should normally call its own &lt;code&gt;Flush&lt;/code&gt; method and then the &lt;code&gt;Seek&lt;/code&gt; method of next layer down.</source>
          <target state="translated">放置文件指针。通常应先调用其自己的 &lt;code&gt;Flush&lt;/code&gt; 方法，然后再调用下一层的 &lt;code&gt;Seek&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="a6c526dcc12f43618f2ecd784fb24aede6eaace5" translate="yes" xml:space="preserve">
          <source>Position the file.</source>
          <target state="translated">定位文件。</target>
        </trans-unit>
        <trans-unit id="d0563a74c40a028ff0eabefa0c47db1f013fe7e3" translate="yes" xml:space="preserve">
          <source>Positional parameters are handled by simply naming scalar variables in the signature. For example,</source>
          <target state="translated">位置参数通过简单地在签名中命名标量变量来处理。例如:</target>
        </trans-unit>
        <trans-unit id="0e30507599bac7d9da05192ebf7bafb46204a7a4" translate="yes" xml:space="preserve">
          <source>Possessing a complete name. The symbol &lt;code&gt;$Ent::moot&lt;/code&gt; is qualified; &lt;code&gt;$moot&lt;/code&gt; is unqualified. A fully qualified filename is specified from the top-level directory.</source>
          <target state="translated">拥有全名。符号 &lt;code&gt;$Ent::moot&lt;/code&gt; 是合格的； &lt;code&gt;$moot&lt;/code&gt; 不合格。在顶级目录中指定了标准文件名。</target>
        </trans-unit>
        <trans-unit id="b0a25e4c6df0cbb8129a405e968846abe861b888" translate="yes" xml:space="preserve">
          <source>Possessive quantifiers</source>
          <target state="translated">占有式量词</target>
        </trans-unit>
        <trans-unit id="710ec6bd221d1eb7ee7cac2afd79245dfe1dd377" translate="yes" xml:space="preserve">
          <source>Possessive quantifiers are equivalent to putting the item they are applied to inside of one of these constructs. The following equivalences apply:</source>
          <target state="translated">占有式定语相当于把它们所应用的项目放在这些结构之一的内部。以下等价物适用于:</target>
        </trans-unit>
        <trans-unit id="8d65618737c8f165c76518763bb53e022b80347d" translate="yes" xml:space="preserve">
          <source>Possible locations to get the files:</source>
          <target state="translated">获取文件的可能地点。</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">可能的数值是:</target>
        </trans-unit>
        <trans-unit id="d472359347147115fc3c19663e89b625bb02902c" translate="yes" xml:space="preserve">
          <source>Post Office Protocol 3 Client class (RFC1939)</source>
          <target state="translated">邮局协议3客户端类(RFC1939)</target>
        </trans-unit>
        <trans-unit id="0a29797f79372fde99a5ef6badeb4b11cfdd110a" translate="yes" xml:space="preserve">
          <source>Post a new article to the news server using a tied filehandle. If posting is allowed, this method will return a tied filehandle that you can print() the contents of the article to be posted. You must explicitly close() the filehandle when you are finished posting the article, and the return value from the close() call will indicate whether the message was successfully posted.</source>
          <target state="translated">使用绑定的文件柄将一篇新文章发布到新闻服务器上。如果允许发布,这个方法将返回一个绑定的文件柄,你可以打印()要发布的文章内容。当你完成发布文章时,你必须显式关闭()这个文件柄,关闭()调用的返回值将指示消息是否成功发布。</target>
        </trans-unit>
        <trans-unit id="c0c64b012716c7ba679076f89a6776bcbf37ad82" translate="yes" xml:space="preserve">
          <source>Post a new article to the news server. If &lt;code&gt;MESSAGE&lt;/code&gt; is specified and posting is allowed then the message will be sent.</source>
          <target state="translated">将新文章发布到新闻服务器。如果指定了 &lt;code&gt;MESSAGE&lt;/code&gt; 并且允许发布，则将发送该消息。</target>
        </trans-unit>
        <trans-unit id="b93dd2631ce48b2c54303e56c98d829a533f5625" translate="yes" xml:space="preserve">
          <source>Post a public message in a heavily trafficked site announcing your intention to take over the module.</source>
          <target state="translated">在人流量大的网站上发布公开信息,宣布你打算接管该模块。</target>
        </trans-unit>
        <trans-unit id="937a6feb504555c9c17e4a5c6895ae9906b154df" translate="yes" xml:space="preserve">
          <source>Postfix Dereference Syntax</source>
          <target state="translated">Postfix Dereference语法</target>
        </trans-unit>
        <trans-unit id="670df18cfdfd04e8862a6c47f0addc1747a2af07" translate="yes" xml:space="preserve">
          <source>Postfix Reference Slicing</source>
          <target state="translated">Postfix引用切片</target>
        </trans-unit>
        <trans-unit id="9b88dd7b4adbe5e941b4c60fc54a020147730776" translate="yes" xml:space="preserve">
          <source>Postfix array and scalar dereferencing</source>
          <target state="translated">后缀数组和标量的取消引用。</target>
        </trans-unit>
        <trans-unit id="c71c2847613385562445ff81717d9bb4d1a33f70" translate="yes" xml:space="preserve">
          <source>Postfix dereference should work in all circumstances where block (circumfix) dereference worked, and should be entirely equivalent. This syntax allows dereferencing to be written and read entirely left-to-right. The following equivalencies are defined:</source>
          <target state="translated">后缀注解应该在所有块(circuitfix)注解起作用的情况下都能起作用,而且应该完全等同。这种语法允许完全从左到右地写和读dereferencing。定义了以下等价性。</target>
        </trans-unit>
        <trans-unit id="f3ec2bb2a047a99ed59d3be9cc0c559fda55d10c" translate="yes" xml:space="preserve">
          <source>Postfix key/value pair slicing, added in 5.20.0 and documented in &lt;a href=&quot;perldata#Key%2fValue-Hash-Slices&quot;&gt;the Key/Value Hash Slices section of perldata&lt;/a&gt;, also behaves as expected:</source>
          <target state="translated">Postfix键/值对切片，在5.20.0中添加，并在&lt;a href=&quot;perldata#Key%2fValue-Hash-Slices&quot;&gt;perldata的&amp;ldquo;键/值散列片&amp;rdquo;部分中进行了记录&lt;/a&gt;，其行为也与预期的一样：</target>
        </trans-unit>
        <trans-unit id="04ec3882b5f81dfbca3ecaeafba246a10ffa796f" translate="yes" xml:space="preserve">
          <source>Postpone load of modules until a function is used</source>
          <target state="translated">推迟模块的加载,直到使用一个函数。</target>
        </trans-unit>
        <trans-unit id="d2a4543d0ad08e45f28a205ad22f1e3caeac2d64" translate="yes" xml:space="preserve">
          <source>Potentially one of the trickiest problems to overcome when designing a callback interface can be figuring out how to store the mapping between the C callback function and the Perl equivalent.</source>
          <target state="translated">在设计回调接口时,最棘手的问题之一可能是如何存储C回调函数和Perl等价函数之间的映射。</target>
        </trans-unit>
        <trans-unit id="0649dcff6091a76865807331d6bfa798c788d3e2" translate="yes" xml:space="preserve">
          <source>Practical hint: you almost never need to use &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; in Perl, because the input operators typically return &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when they run out of data or encounter an error.</source>
          <target state="translated">实用提示：您几乎不需要在Perl中使用 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; ，因为输入运算符通常会在数据用完或遇到错误时返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c79f9de3f9791d9e3640774f31e39c172d803ae" translate="yes" xml:space="preserve">
          <source>Practical hint: you almost never need to use &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; in Perl, because the input operators typically return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when they run out of data or encounter an error.</source>
          <target state="translated">实用提示：您几乎不需要在Perl中使用 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; ，因为输入运算符通常会在数据用完或遇到错误时返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4270fcef9cd955376d2d433cbe3ad453cb9910a5" translate="yes" xml:space="preserve">
          <source>Practicing Perl Programmers should take note of the following:</source>
          <target state="translated">练习Perl程序员应该注意以下几点。</target>
        </trans-unit>
        <trans-unit id="4f32a07197212fd4ee8ad1142954d88e709f37a2" translate="yes" xml:space="preserve">
          <source>Pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; is used to gain access to the names of the Unicode characters and named character sequences, and to allow you to define your own character and character sequence names.</source>
          <target state="translated">Pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; 用于获得对Unicode字符和命名字符序列的名称的访问，并允许您定义自己的字符和字符序列的名称。</target>
        </trans-unit>
        <trans-unit id="d857c4a3cba6bb11f909b140e46311890f7f21c4" translate="yes" xml:space="preserve">
          <source>Pragmas</source>
          <target state="translated">Pragmas</target>
        </trans-unit>
        <trans-unit id="3c5e2f66507f9aa3bf61c02fdd0fa70e115987d9" translate="yes" xml:space="preserve">
          <source>Pragmas and debugging</source>
          <target state="translated">实例和调试</target>
        </trans-unit>
        <trans-unit id="3e8b13bf6bd7207dc21ad82f8de792e97bdb1e50" translate="yes" xml:space="preserve">
          <source>Pragmas are only supported from TAP version 13 onwards.</source>
          <target state="translated">从TAP13版开始,只支持Pragmas。</target>
        </trans-unit>
        <trans-unit id="971af7eca951f1fbb9960d4ee2d3aea5a1235f54" translate="yes" xml:space="preserve">
          <source>Pragmatic Modules</source>
          <target state="translated">实用模块</target>
        </trans-unit>
        <trans-unit id="ea00a7d451d39ea4021279960b408e9e237e5fc0" translate="yes" xml:space="preserve">
          <source>Praise of the module, flowers, and presents still go to the author, Damian Conway &amp;lt;damian@conway.org&amp;gt;.</source>
          <target state="translated">对该模块，鲜花和礼物的称赞仍归作者Damian Conway &amp;lt;damian@conway.org&amp;gt;所致。</target>
        </trans-unit>
        <trans-unit id="1b29958a379894f384c104d607dfd507e7d7dd32" translate="yes" xml:space="preserve">
          <source>Pre-ANSI semantics for that was equivalent to</source>
          <target state="translated">前ANSI的语义等同于</target>
        </trans-unit>
        <trans-unit id="2fbcc9e8ca617de5c029f92c1928b430d8bd8736" translate="yes" xml:space="preserve">
          <source>Pre-compiled regexps are useful for creating dynamic matches that don't need to be recompiled each time they are encountered. Using pre-compiled regexps, we write a &lt;code&gt;grep_step&lt;/code&gt; program which greps for a sequence of patterns, advancing to the next pattern as soon as one has been satisfied.</source>
          <target state="translated">预编译的正则表达式对于创建动态匹配非常有用，这种动态匹配每次遇到都无需重新编译。使用预编译的正则 &lt;code&gt;grep_step&lt;/code&gt; ，我们编写了一个grep_step程序，该程序会抓取一系列模式，并在满足条件后立即进入下一个模式。</target>
        </trans-unit>
        <trans-unit id="d5f48644a7129c9d5da2320101de47f3b885b660" translate="yes" xml:space="preserve">
          <source>Pre-extend an array. The &lt;code&gt;key&lt;/code&gt; is the index to which the array should be extended.</source>
          <target state="translated">预扩展数组。的 &lt;code&gt;key&lt;/code&gt; 在于其中阵列应该扩展的索引。</target>
        </trans-unit>
        <trans-unit id="b10fcb8ea3f8003cc2a68eb477298ced48c3e1ce" translate="yes" xml:space="preserve">
          <source>Pre-process the string to expand &lt;code&gt;{pat,pat,...}&lt;/code&gt; strings like csh(1). The pattern '{}' is left unexpanded for historical reasons (and csh(1) does the same thing to ease typing of find(1) patterns).</source>
          <target state="translated">预处理字符串以扩展 &lt;code&gt;{pat,pat,...}&lt;/code&gt; 字符串，例如csh（1）。由于历史原因，模式'{}'保留为未展开状态（和csh（1）所做的相同的事情可简化对find（1）模式的键入）。</target>
        </trans-unit>
        <trans-unit id="2cfc6ae03601619aa86eab49f8cdcba160ca42e1" translate="yes" xml:space="preserve">
          <source>Pre-requisites</source>
          <target state="translated">Pre-requisites</target>
        </trans-unit>
        <trans-unit id="9c60435756471d4710932d1c59839109eaf4896d" translate="yes" xml:space="preserve">
          <source>Prebuilt methods:</source>
          <target state="translated">预制方法。</target>
        </trans-unit>
        <trans-unit id="28b96a948b2f4129281e76a6bf72cbe04069ac57" translate="yes" xml:space="preserve">
          <source>Prebuilt variables:</source>
          <target state="translated">预设变量。</target>
        </trans-unit>
        <trans-unit id="2b07cb5bc64f911d6e1d4e8b016d735ad5687328" translate="yes" xml:space="preserve">
          <source>Precision P</source>
          <target state="translated">精密P</target>
        </trans-unit>
        <trans-unit id="f875922b09d6dc1883e2e7cdd44c0e3a3e94a8bc" translate="yes" xml:space="preserve">
          <source>Precompilation of the pattern into an internal representation at the moment of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; avoids the need to recompile the pattern every time a match &lt;code&gt;/$pat/&lt;/code&gt; is attempted. (Perl has many other internal optimizations, but none would be triggered in the above example if we did not use &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; operator.)</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; 时刻将模式预编译为内部表示，避免了每次尝试匹配 &lt;code&gt;/$pat/&lt;/code&gt; 都需要重新编译模式。（Perl还有许多其他内部优化，但是如果我们不使用 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; 运算符，则在上面的示例中不会触发任何优化。）</target>
        </trans-unit>
        <trans-unit id="be7aad2f2ead853044925ed4e22070f406951f6c" translate="yes" xml:space="preserve">
          <source>Precompiled binaries, links to many sites, and much, much more are available at &lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt; and &lt;a href=&quot;http://www.blastwave.org/&quot;&gt;http://www.blastwave.org/&lt;/a&gt;.</source>
          <target state="translated">预编译的二进制文件，指向许多站点的链接以及更多内容，请访问&lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt;和&lt;a href=&quot;http://www.blastwave.org/&quot;&gt;http://www.blastwave.org/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9becba2ecce5e815e75f3b05d6a72e8e463e4358" translate="yes" xml:space="preserve">
          <source>Predeclare global variable names</source>
          <target state="translated">预先声明全局变量名称</target>
        </trans-unit>
        <trans-unit id="80c74001ab374f9d6385a023afc607a8a9ee7ede" translate="yes" xml:space="preserve">
          <source>Predeclare sub names</source>
          <target state="translated">预先声明子名称</target>
        </trans-unit>
        <trans-unit id="fcdc57a9dfc65d3e8247e2abc3f2dbee6434d71f" translate="yes" xml:space="preserve">
          <source>Predefined As:</source>
          <target state="translated">预定为:</target>
        </trans-unit>
        <trans-unit id="79e73f11af1b28edb5e6c2f50de7a40c3138546f" translate="yes" xml:space="preserve">
          <source>Predefined Methods</source>
          <target state="translated">预定义方法</target>
        </trans-unit>
        <trans-unit id="ba26022b30a5919c6e22dc87472766a340d507c9" translate="yes" xml:space="preserve">
          <source>Predefined Opcode Tags</source>
          <target state="translated">预定义的操作码标签</target>
        </trans-unit>
        <trans-unit id="74ff649a3a1be6633677b33ec66e3623a45738d8" translate="yes" xml:space="preserve">
          <source>Predicates</source>
          <target state="translated">Predicates</target>
        </trans-unit>
        <trans-unit id="b667e8c1107543d66d7cab24522776a0879c9d96" translate="yes" xml:space="preserve">
          <source>Predicates are not exportable. They must be called by explicitly prefixing them with the Storable package name.</source>
          <target state="translated">谓词是不能导出的。它们必须通过显式地以Storable包名为前缀来调用。</target>
        </trans-unit>
        <trans-unit id="486c0b3ebd2042a6ce2f4cb9151258c31c8a708a" translate="yes" xml:space="preserve">
          <source>Preemptive multitasking systems interrupt threads at regular intervals while the system decides which thread should run next. In a preemptive multitasking system, one thread usually won't monopolize the CPU.</source>
          <target state="translated">先发制人的多任务系统在系统决定下一个线程运行时,会定期中断线程。在先发制人的多任务系统中,一个线程通常不会垄断CPU。</target>
        </trans-unit>
        <trans-unit id="910177df20d444aedde7cd08b1849b3cca54c380" translate="yes" xml:space="preserve">
          <source>Preferred method for determining the current working directory?</source>
          <target state="translated">确定当前工作目录的首选方法?</target>
        </trans-unit>
        <trans-unit id="2aca457be49d63d7eff6210a8d246e858c52f84a" translate="yes" xml:space="preserve">
          <source>Prefix patterns are matched without any trailing modifiers (&lt;code&gt;/gimsox&lt;/code&gt; etc.) This can bite you if you're expecting a prefix specification like '.*?(?=&amp;lt;H1&amp;gt;)' to skip everything up to the first &amp;lt;H1&amp;gt; tag. Such a prefix pattern will only succeed if the &amp;lt;H1&amp;gt; tag is on the current line, since . normally doesn't match newlines.</source>
          <target state="translated">前缀模式是匹配的，没有任何尾随修饰符（ &lt;code&gt;/gimsox&lt;/code&gt; 等）。如果您希望像'。*？（？= &amp;lt;H1&amp;gt;） 。因为&amp;lt;H1&amp;gt;标签在当前行上，所以这样的前缀模式将成功。通常不匹配换行符。</target>
        </trans-unit>
        <trans-unit id="a02d52e7a8f126c57caa627d5a51525bbcd6a947" translate="yes" xml:space="preserve">
          <source>Prefixing a method call with &lt;code&gt;EVERY::&lt;/code&gt; causes every method in the object's hierarchy with that name to be invoked. As the above example illustrates, they are not called in Perl's usual &quot;left-most-depth-first&quot; order. Instead, they are called &quot;breadth-first-dependency-wise&quot;.</source>
          <target state="translated">给方法调用加上 &lt;code&gt;EVERY::&lt;/code&gt; 前缀会导致调用对象层次结构中具有该名称的每个方法。如上面的示例所示，它们不是按照Perl通常的&amp;ldquo;最左深度优先&amp;rdquo;顺序来调用的。相反，它们被称为&amp;ldquo;宽度优先依赖方式&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ca327af27efee895ecb8288cd68d4b6f0ee7b660" translate="yes" xml:space="preserve">
          <source>Prepares a starting point to traverse a hash table. Returns the number of keys in the hash (i.e. the same as &lt;code&gt;HvUSEDKEYS(hv)&lt;/code&gt; ). The return value is currently only meaningful for hashes without tie magic.</source>
          <target state="translated">准备遍历哈希表的起点。返回哈希中的键数（即与 &lt;code&gt;HvUSEDKEYS(hv)&lt;/code&gt; 相同）。当前的返回值仅对没有领带魔术的哈希有意义。</target>
        </trans-unit>
        <trans-unit id="3ba6224af2c92974d736ffced198acbd4096ace3" translate="yes" xml:space="preserve">
          <source>Preparing the target system</source>
          <target state="translated">准备目标系统</target>
        </trans-unit>
        <trans-unit id="ffc03d7ec4535764ca9f3772e318d6f043e9e016" translate="yes" xml:space="preserve">
          <source>Prepend an item to the list of ops contained directly within a list-type op, returning the lengthened list.</source>
          <target state="translated">在列表型操作中直接包含的操作列表中加入一个项目,返回加长后的列表。</target>
        </trans-unit>
        <trans-unit id="a4ef952f6146acb08f845dd15ba77a7f17429906" translate="yes" xml:space="preserve">
          <source>Prepend the supplied directory name to the template. The template should not include parent directory specifications itself. Any parent directory specifications are removed from the template before prepending the supplied directory.</source>
          <target state="translated">将所提供的目录名称前置到模板中。模板本身不应包含父目录规格。任何父目录规格都会从模板中删除,然后再将所提供的目录预置。</target>
        </trans-unit>
        <trans-unit id="0e5ab6fc929309798c3bd158ad1bbf3fa9c0916d" translate="yes" xml:space="preserve">
          <source>Prepends the above directory to &lt;code&gt;BEGINLIBPATH&lt;/code&gt; ;</source>
          <target state="translated">将以上目录添加到 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="9bbcda665d927bc3df5f365451b970ea9d631664" translate="yes" xml:space="preserve">
          <source>Prepends the given string or parse-tree or sequence object to the parse-tree of this interior sequence.</source>
          <target state="translated">将给定的字符串或解析树或序列对象预加入到这个内部序列的解析树中。</target>
        </trans-unit>
        <trans-unit id="eed036e414a34a0c245858652e6d88f14c3faefb" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">Prerequisites</target>
        </trans-unit>
        <trans-unit id="bd4880bf9be46b68a1d78624b0c0e7ee32ab3b0d" translate="yes" xml:space="preserve">
          <source>Prerequisites - what else you may need to have.</source>
          <target state="translated">先决条件--你可能还需要具备哪些条件。</target>
        </trans-unit>
        <trans-unit id="a09ee8803a3e08b44cee3828e8eaea97f4a78f52" translate="yes" xml:space="preserve">
          <source>Prerequisites for Compiling Perl on AmigaOS</source>
          <target state="translated">在AmigaOS上编译Perl的前提条件。</target>
        </trans-unit>
        <trans-unit id="2bf93198f4dd6a32fb330b849b5c10097740f617" translate="yes" xml:space="preserve">
          <source>Prerequisites for Compiling Perl on DOS</source>
          <target state="translated">在DOS上编译Perl的前提条件</target>
        </trans-unit>
        <trans-unit id="95fa8ceddba3a09f73177d0b71d8fe3bcb1a4541" translate="yes" xml:space="preserve">
          <source>Presented with little comment (these will get their own manpages someday) here are short code examples illustrating access of various types of data structures.</source>
          <target state="translated">这里介绍的是很少的评论(这些有朝一日会有自己的manpages),这里有一些简短的代码例子,说明对各种类型的数据结构的访问。</target>
        </trans-unit>
        <trans-unit id="3437b8bc516389bda3cce8e402bfc852a1712fef" translate="yes" xml:space="preserve">
          <source>Preserve more data for future interactive inspections.</source>
          <target state="translated">保留更多的数据,以备将来的互动检查。</target>
        </trans-unit>
        <trans-unit id="e640fa1e20282fa93fdaf4d6fd684e648c672de7" translate="yes" xml:space="preserve">
          <source>Preserve the string matched such that ${^PREMATCH}, ${^MATCH}, and ${^POSTMATCH} are available for use after matching.</source>
          <target state="translated">保留已匹配的字符串,使${^PREMATCH}、${^MATCH}和${^POSTMATCH}在匹配后可以使用。</target>
        </trans-unit>
        <trans-unit id="b33cf22068f58ddac89fea290aa9a5162e4a365b" translate="yes" xml:space="preserve">
          <source>Preserves accuracy to $scale digits from the left (aka significant digits) and pads the rest with zeros. If the number is between 1 and -1, the significant digits count from the first non-zero after the '.'</source>
          <target state="translated">将精度保留到$scale从左边开始的数字(也就是重要的数字),并将其余的数字用0填充。如果数字在1和-1之间,则从'.'后面的第一个非零开始计算。</target>
        </trans-unit>
        <trans-unit id="a5d86d611e35ff6e1b78c3b62444d98363343289" translate="yes" xml:space="preserve">
          <source>Presumably the Philippine language Waray-Waray (Samare&amp;ntilde;o), not the smaller Philippine language Waray Sorsogon, nor the extinct Australian language Waray.</source>
          <target state="translated">大概是菲律宾语的Waray-Waray（Samare&amp;ntilde;o），而不是较小的菲律宾语的Waray Sorsogon，也没有灭绝的澳大利亚语Waray。</target>
        </trans-unit>
        <trans-unit id="0a2cb25a662f585b417f0c2f8f17aaa0a5065d2d" translate="yes" xml:space="preserve">
          <source>Pretty ugly, eh? It's a common idiom though, so don't be too surprised when you see it. You can at least use a temporary variable to hold the previous filehandle: (this is a much better approach in general, because not only does legibility improve, you now have an intermediary stage in the expression to single-step the debugger through):</source>
          <target state="translated">很丑吧?不过这是一个常见的习惯用语,所以当你看到它时不要太惊讶。你至少可以使用一个临时变量来保存之前的文件柄:(一般来说,这是一个更好的方法,因为不仅提高了可读性,而且你现在在表达式中还有一个中间阶段可以让调试器单步通过)。</target>
        </trans-unit>
        <trans-unit id="963f0c082b0ef847cc7f94277b8f965a8541ae8a" translate="yes" xml:space="preserve">
          <source>Prevent the grouping metacharacters &lt;code&gt;()&lt;/code&gt; from capturing. This modifier, new in 5.22, will stop &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc... from being filled in.</source>
          <target state="translated">防止捕获分组元字符 &lt;code&gt;()&lt;/code&gt; 。此修饰符是5.22中的新功能，将阻止 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等填充。</target>
        </trans-unit>
        <trans-unit id="457fa0dd9ef7c1de466cb472004b83bed4a2a8ee" translate="yes" xml:space="preserve">
          <source>Prevents the inclusion of '#line' directives in the output.</source>
          <target state="translated">防止在输出中包含'#行'指令。</target>
        </trans-unit>
        <trans-unit id="4e76bb1e6f14e0746558e405fd753c5acff93017" translate="yes" xml:space="preserve">
          <source>Previous maintainer was Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;.</source>
          <target state="translated">以前的维护者是Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="9af80fa78e3d389344e53119f3893641766863b8" translate="yes" xml:space="preserve">
          <source>Previous maintainer: Hal Pomeranz &amp;lt;pomeranz@netcom.com&amp;gt;, 1994-1997 (Original author unknown). Much of the code for &amp;amp;parse_line() (including the primary regexp) from Joerk Behrends &amp;lt;jbehrends@multimediaproduzenten.de&amp;gt;.</source>
          <target state="translated">先前的维护者：Hal Pomeranz &amp;lt;pomeranz@netcom.com&amp;gt;，1994-1997年（原作者不详）。Joerk Behrends &amp;lt;jbehrends@multimediaproduzenten.de&amp;gt;的＆parse_line（）的许多代码（包括主正则表达式）。</target>
        </trans-unit>
        <trans-unit id="c2ffcc08fe71b18c33582287221ff6c8ae26702c" translate="yes" xml:space="preserve">
          <source>Previous steps were performed during the compilation of Perl code, but this one happens at run time, although it may be optimized to be calculated at compile time if appropriate. After preprocessing described above, and possibly after evaluation if concatenation, joining, casing translation, or metaquoting are involved, the resulting</source>
          <target state="translated">前面的步骤是在编译Perl代码的过程中进行的,但这一步骤是在运行时进行的,不过如果合适的话,可以在编译时进行优化计算。经过上面描述的预处理,如果涉及到连词、连接、套管翻译或元引用,还可能经过评估,得到的</target>
        </trans-unit>
        <trans-unit id="712a386d33ec2d569cadb97eef8f2374df4edce1" translate="yes" xml:space="preserve">
          <source>Previous versions of Getopt::Long used variables for the purpose of configuring. Although manipulating these variables still work, it is strongly encouraged to use the &lt;code&gt;Configure&lt;/code&gt; routine that was introduced in version 2.17. Besides, it is much easier.</source>
          <target state="translated">以前版本的Getopt :: Long使用变量进行配置。尽管处理这些变量仍然有效，但强烈建议您使用2.17版中引入的 &lt;code&gt;Configure&lt;/code&gt; 例程。此外，它要容易得多。</target>
        </trans-unit>
        <trans-unit id="dccc4f2981422e8e0be18ebbbc807021c6e418aa" translate="yes" xml:space="preserve">
          <source>Previous versions of perlpod allowed for a &lt;code&gt;L&amp;lt;section&amp;gt;&lt;/code&gt; syntax (as in &lt;code&gt;L&amp;lt;Object Attributes&amp;gt;&lt;/code&gt; ), which was not easily distinguishable from &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; syntax and for &lt;code&gt;L&amp;lt;&quot;section&quot;&amp;gt;&lt;/code&gt; which was only slightly less ambiguous. This syntax is no longer in the specification, and has been replaced by the &lt;code&gt;L&amp;lt;/section&amp;gt;&lt;/code&gt; syntax (where the slash was formerly optional). Pod parsers should tolerate the &lt;code&gt;L&amp;lt;&quot;section&quot;&amp;gt;&lt;/code&gt; syntax, for a while at least. The suggested heuristic for distinguishing &lt;code&gt;L&amp;lt;section&amp;gt;&lt;/code&gt; from &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; is that if it contains any whitespace, it's a</source>
          <target state="translated">perlpod的早期版本允许使用 &lt;code&gt;L&amp;lt;section&amp;gt;&lt;/code&gt; 语法（如 &lt;code&gt;L&amp;lt;Object Attributes&amp;gt;&lt;/code&gt; ），该语法很难与 &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; 语法区分开，而 &lt;code&gt;L&amp;lt;&quot;section&quot;&amp;gt;&lt;/code&gt; 则仅含糊不清。该语法不再在规范中，并已由 &lt;code&gt;L&amp;lt;/section&amp;gt;&lt;/code&gt; 语法取代（L斜杠以前是可选的）。 Pod解析器至少应忍受 &lt;code&gt;L&amp;lt;&quot;section&quot;&amp;gt;&lt;/code&gt; 语法。建议将 &lt;code&gt;L&amp;lt;section&amp;gt;&lt;/code&gt; 与 &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; 区别开来的试探法是，如果它包含任何空格，则为</target>
        </trans-unit>
        <trans-unit id="5d5080e57965c5e0136dec24846dd5ebda3d2afc" translate="yes" xml:space="preserve">
          <source>Previous versions of perlpod distinguished &lt;code&gt;L&amp;lt;name/&quot;section&quot;&amp;gt;&lt;/code&gt; links from &lt;code&gt;L&amp;lt;name/item&amp;gt;&lt;/code&gt; links (and their targets). These have been merged syntactically and semantically in the current specification, and</source>
          <target state="translated">从 &lt;code&gt;L&amp;lt;name/item&amp;gt;&lt;/code&gt; 链接（及其目标）开始的Perlpod专有 &lt;code&gt;L&amp;lt;name/&quot;section&quot;&amp;gt;&lt;/code&gt; 链接的早期版本。在当前规范中，这些已在语法和语义上合并，并且</target>
        </trans-unit>
        <trans-unit id="14f8fc760485caa4685e61dad45be68f1f9ddaa9" translate="yes" xml:space="preserve">
          <source>Previous versions of this documentation suggested using &lt;code&gt;isa&lt;/code&gt; as a function to determine the type of a reference:</source>
          <target state="translated">本文档的先前版本建议使用 &lt;code&gt;isa&lt;/code&gt; 作为确定引用类型的函数：</target>
        </trans-unit>
        <trans-unit id="16e35723da6a1f4e0f4f26765e6766759d4e06d1" translate="yes" xml:space="preserve">
          <source>Previous versions of this documentation suggested using &lt;code&gt;memory
=&amp;gt; 0&lt;/code&gt; for safe concurrent access. This was mistaken. Tie::File will not support safe concurrent access before version 0.96.</source>
          <target state="translated">本文档的早期版本建议使用 &lt;code&gt;memory =&amp;gt; 0&lt;/code&gt; 进行安全的并发访问。这是错误的。Tie :: File在0.96版之前将不支持安全的并发访问。</target>
        </trans-unit>
        <trans-unit id="4ea86d31b7a890fc1159e9e5757a43b75c64847e" translate="yes" xml:space="preserve">
          <source>Previously Local::Maketext::GutsLoader performed some magic to load Locale::Maketext when utf8 was unavailable. The subs this module provided were merged back into Locale::Maketext</source>
          <target state="translated">之前Local::Maketext::GutsLoader在utf8不可用的情况下执行了一些魔法来加载Locale::Maketext。这个模块提供的子模块被合并到Locale::Maketext中。</target>
        </trans-unit>
        <trans-unit id="7e5fb7a6ba75baae80c7e10052589b5b646d8c66" translate="yes" xml:space="preserve">
          <source>Previously Locale::Maketext::Guts performed some magic to load Locale::Maketext when utf8 was unavailable. The subs this module provided were merged back into Locale::Maketext.</source>
          <target state="translated">以前,当utf8不可用时,Locale::Maketext::Guts执行了一些魔法来加载Locale::Maketext。这个模块提供的子模块被合并回Locale::Maketext中。</target>
        </trans-unit>
        <trans-unit id="5ff7ceb2711be19546099c1783a191fceba3a049" translate="yes" xml:space="preserve">
          <source>Previously this value was always stored in the HV structure, which created an overhead on every hash (and pretty much every object) for something that was rarely used. Now we calculate it on demand the first time that it is needed, and cache it if that calculation is going to be costly to repeat. The cached value is updated by insertions and deletions, but (currently) discarded if the hash is split.</source>
          <target state="translated">以前,这个值总是存储在HV结构中,这就给每一个哈希(以及几乎每一个对象)造成了很少使用的东西的开销。现在,我们在第一次需要它的时候按需计算,如果重复计算的成本很高,我们就把它缓存起来。缓存的值会被插入和删除更新,但(目前)如果哈希被拆分,则会被丢弃。</target>
        </trans-unit>
        <trans-unit id="c940ec50096c5081483cc1c8a4a85997bf9bf27c" translate="yes" xml:space="preserve">
          <source>Previously, only child processes received stringified values:</source>
          <target state="translated">以前,只有子进程才会收到字符串化的值。</target>
        </trans-unit>
        <trans-unit id="32c4d5cec9a9d67d9096ad8b31f2e98c9de6c3c5" translate="yes" xml:space="preserve">
          <source>Principle 0: Taken as a whole, any regexp will be matched at the earliest possible position in the string.</source>
          <target state="translated">原则0:从整体上看,任何regexp都将在字符串的最早位置进行匹配。</target>
        </trans-unit>
        <trans-unit id="6a4f105bbda5244560916b603ce8af958b7f039e" translate="yes" xml:space="preserve">
          <source>Principle 1: In an alternation &lt;code&gt;a|b|c...&lt;/code&gt; , the leftmost alternative that allows a match for the whole regexp will be the one used.</source>
          <target state="translated">原则1：在交替 &lt;code&gt;a|b|c...&lt;/code&gt; ，最左边的替代项是整个正则表达式都可以匹配。</target>
        </trans-unit>
        <trans-unit id="029a1dbf083882cef4054ed7972875e41bc5642b" translate="yes" xml:space="preserve">
          <source>Principle 2: The maximal matching quantifiers &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;{n,m}&lt;/code&gt; will in general match as much of the string as possible while still allowing the whole regexp to match.</source>
          <target state="translated">原理2：最大匹配量词 &lt;code&gt;?&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;{n,m}&lt;/code&gt; 通常将尽可能匹配字符串，同时仍然允许整个正则表达式匹配。</target>
        </trans-unit>
        <trans-unit id="23b72c3ca0299774d68e314619c9048069fa0bef" translate="yes" xml:space="preserve">
          <source>Principle 3: If there are two or more elements in a regexp, the leftmost greedy (non-greedy) quantifier, if any, will match as much (little) of the string as possible while still allowing the whole regexp to match. The next leftmost greedy (non-greedy) quantifier, if any, will try to match as much (little) of the string remaining available to it as possible, while still allowing the whole regexp to match. And so on, until all the regexp elements are satisfied.</source>
          <target state="translated">原则3:如果一个regexp中有两个或两个以上的元素,最左边的贪婪(非贪婪)量化器(如果有的话)将尽可能多(少)地匹配字符串,同时仍然允许整个regexp匹配。下一个最左边的贪婪(非贪婪)量化器(如果有的话)将尽可能多(少)地匹配字符串,同时仍然允许整个regexp匹配。以此类推,直到所有的regexp元素都被满足。</target>
        </trans-unit>
        <trans-unit id="7924ae789f920a103b9e8212ac47e4dc00917a8b" translate="yes" xml:space="preserve">
          <source>Principle 3: If there are two or more elements in a regexp, the leftmost greedy quantifier, if any, will match as much of the string as possible while still allowing the whole regexp to match. The next leftmost greedy quantifier, if any, will try to match as much of the string remaining available to it as possible, while still allowing the whole regexp to match. And so on, until all the regexp elements are satisfied.</source>
          <target state="translated">原则3:如果一个regexp中有两个或更多的元素,那么最左边的贪婪量化器(如果有的话)将尽可能多地匹配字符串,同时仍然允许整个regexp匹配。下一个最左边的贪婪量化器(如果有的话)将尽可能多地匹配剩余的字符串,同时仍然允许整个regexp进行匹配。以此类推,直到满足所有的regexp元素。</target>
        </trans-unit>
        <trans-unit id="5b221e9c2a451799d8f37e2b9874409d5e03ab05" translate="yes" xml:space="preserve">
          <source>Print</source>
          <target state="translated">Print</target>
        </trans-unit>
        <trans-unit id="62c9112958c68fcfcec0378f346995acb5fb475e" translate="yes" xml:space="preserve">
          <source>Print &lt;code&gt;$message&lt;/code&gt; to STDERR.</source>
          <target state="translated">打印 &lt;code&gt;$message&lt;/code&gt; 到STDERR。</target>
        </trans-unit>
        <trans-unit id="28796f1a81c3dcd34643979c6b7feb02d0c7e828" translate="yes" xml:space="preserve">
          <source>Print ARGS to the file.</source>
          <target state="translated">将ARGS打印到文件中。</target>
        </trans-unit>
        <trans-unit id="aeb5f490c0fe5dda6fa8c9b0136063c67f1eba8a" translate="yes" xml:space="preserve">
          <source>Print OP sequence numbers in base</source>
          <target state="translated">以基数打印OP序列号</target>
        </trans-unit>
        <trans-unit id="c95f895c7d7dbde542e1c491d05c9defe9ec89fe" translate="yes" xml:space="preserve">
          <source>Print OPs in a text approximation of a tree, with the root of the tree at the left and 'left-to-right' order of children transformed into 'top-to-bottom'. Because this mode grows both to the right and down, it isn't suitable for large programs (unless you have a very wide terminal).</source>
          <target state="translated">将OP打印成一棵近似于树的文本,树根在左边,子代的'从左到右'顺序转化为'从上到下'。因为这种模式既可以向右生长,也可以向下生长,所以不适合大型程序(除非你有一个很宽的终端)。</target>
        </trans-unit>
        <trans-unit id="64c201f8801eb2b8f4a6b4829f0bb1418f54aea2" translate="yes" xml:space="preserve">
          <source>Print OPs in the order they appear in the OP tree (a preorder traversal, starting at the root). The indentation of each OP shows its level in the tree, and the '-&amp;gt;' at the end of the line indicates the next opcode in execution order. This mode is the default, so the flag is included simply for completeness.</source>
          <target state="translated">按照在OP树中出现的顺序打印OP（从根开始进行遍历）。每个OP的缩进在树中显示其级别，该行末尾的&amp;ldquo;-&amp;gt;&amp;rdquo;表示执行顺序中的下一个操作码。此模式是默认模式，因此仅出于完整性考虑而包含该标志。</target>
        </trans-unit>
        <trans-unit id="8ab076ddbb8deab03d45c660c94d823cf8595ce2" translate="yes" xml:space="preserve">
          <source>Print OPs in the order they would normally execute (for the majority of constructs this is a postorder traversal of the tree, ending at the root). In most cases the OP that usually follows a given OP will appear directly below it; alternate paths are shown by indentation. In cases like loops when control jumps out of a linear path, a 'goto' line is generated.</source>
          <target state="translated">按照OP的正常执行顺序打印OP(对于大多数结构体来说,这是对树的后序遍历,以根为终点)。在大多数情况下,通常跟在给定 OP 后面的 OP 会直接出现在它的下面;备用路径会以缩进方式显示。在像循环这样的情况下,当控制跳出线性路径时,会产生一个'goto'行。</target>
        </trans-unit>
        <trans-unit id="6c982704bf497f0a66edb9c2534a7d373da38b12" translate="yes" xml:space="preserve">
          <source>Print a blank line after a &lt;code&gt;=head1&lt;/code&gt; heading. Normally, no blank line is printed after &lt;code&gt;=head1&lt;/code&gt; , although one is still printed after &lt;code&gt;=head2&lt;/code&gt; , because this is the expected formatting for manual pages; if you're formatting arbitrary text documents, using this option is recommended.</source>
          <target state="translated">在 &lt;code&gt;=head1&lt;/code&gt; 标题之后打印空白行。正常情况下，没有空行之后打印 &lt;code&gt;=head1&lt;/code&gt; ，虽然其中一个后仍印刷 &lt;code&gt;=head2&lt;/code&gt; ，因为这是预期的格式设置为手动页; 如果您要格式化任意文本文档，建议使用此选项。</target>
        </trans-unit>
        <trans-unit id="867127fd347fb038713aa7bf1fa3161513e339cb" translate="yes" xml:space="preserve">
          <source>Print a brief help message and exit.</source>
          <target state="translated">打印简短的帮助信息并退出。</target>
        </trans-unit>
        <trans-unit id="33a3171c128f8353be548144a646976a2ba0eae4" translate="yes" xml:space="preserve">
          <source>Print a usage message from embedded pod documentation</source>
          <target state="translated">从嵌入式 pod 文档中打印使用信息</target>
        </trans-unit>
        <trans-unit id="6515d632fc4240022bb106a3dc691b05ec42ef49" translate="yes" xml:space="preserve">
          <source>Print appropriate &quot;Use of uninitialized variable&quot; warning.</source>
          <target state="translated">打印适当的 &quot;使用未初始化的变量 &quot;警告。</target>
        </trans-unit>
        <trans-unit id="97cfeb23d207e65189895e1fffe73287ac2f12a1" translate="yes" xml:space="preserve">
          <source>Print debugging information. &lt;code&gt;DIR&lt;/code&gt; denotes the direction</source>
          <target state="translated">打印调试信息。 &lt;code&gt;DIR&lt;/code&gt; 表示方向</target>
        </trans-unit>
        <trans-unit id="588c5c4b63a239dce597eee039700f84b90eb2e5" translate="yes" xml:space="preserve">
          <source>Print extra parentheses. Without this option, B::Deparse includes parentheses in its output only when they are needed, based on the structure of your program. With &lt;b&gt;-p&lt;/b&gt;, it uses parentheses (almost) whenever they would be legal. This can be useful if you are used to LISP, or if you want to see how perl parses your input. If you say</source>
          <target state="translated">打印多余的括号。如果没有此选项，则B :: Deparse仅在需要时才根据程序的结构在其输出中包含括号。使用&lt;b&gt;-p时&lt;/b&gt;，只要合法就使用括号（几乎）。如果您习惯了LISP，或者想了解perl如何解析输入，这将很有用。如果你说</target>
        </trans-unit>
        <trans-unit id="41aff8bfc8732953f6c1d650b5976c07600e2c8d" translate="yes" xml:space="preserve">
          <source>Print only first N elements ('' for all).</source>
          <target state="translated">只打印前N个元素(''代表全部)。</target>
        </trans-unit>
        <trans-unit id="e81e6e379c35f5ba519788d4e4a35fbede771adb" translate="yes" xml:space="preserve">
          <source>Print only first N elements of arrays and hashes. If false, prints all the elements.</source>
          <target state="translated">只打印数组和哈希的前N个元素。如果为false,则打印所有元素。</target>
        </trans-unit>
        <trans-unit id="bcc4ef2e2a794b82340048b562c03635739b2793" translate="yes" xml:space="preserve">
          <source>Print out the name of each output file as it is being generated.</source>
          <target state="translated">在生成时打印出每个输出文件的名称。</target>
        </trans-unit>
        <trans-unit id="41c304cd9ca96336004e4476cfb242341b0d8cde" translate="yes" xml:space="preserve">
          <source>Print out the value of one or more options.</source>
          <target state="translated">打印出一个或多个选项的值。</target>
        </trans-unit>
        <trans-unit id="257476f3c32fde0f5eb65f8b31e1baf775927d37" translate="yes" xml:space="preserve">
          <source>Print out usage information and exit.</source>
          <target state="translated">打印出使用信息并退出。</target>
        </trans-unit>
        <trans-unit id="bc9a53e87cca6954b36dc36c0f11d367ea1e424e" translate="yes" xml:space="preserve">
          <source>Print out usage information.</source>
          <target state="translated">打印出使用信息。</target>
        </trans-unit>
        <trans-unit id="0177eff9f7a2fbe1e71adee0b082a252a703abf6" translate="yes" xml:space="preserve">
          <source>Print output intended for testing the internals of the compile process</source>
          <target state="translated">打印用于测试编译过程内部的输出。</target>
        </trans-unit>
        <trans-unit id="a27774755c3595f027c8eb3223fdb5c93fd4fbff" translate="yes" xml:space="preserve">
          <source>Print progress information while scanning.</source>
          <target state="translated">扫描时打印进度信息。</target>
        </trans-unit>
        <trans-unit id="4d7b123cfe3d2a9315789f430a1f12df5dd6cda9" translate="yes" xml:space="preserve">
          <source>Print return value after &lt;code&gt;r&lt;/code&gt; command if set (default).</source>
          <target state="translated">如果设置了 &lt;code&gt;r&lt;/code&gt; 命令，则打印返回值（默认）。</target>
        </trans-unit>
        <trans-unit id="7d041699462235ca2a4d570a60c03f171c2124de" translate="yes" xml:space="preserve">
          <source>Print sequence numbers with the least significant digit first. This is obviously mutually exclusive with bigendian.</source>
          <target state="translated">打印序列号时,先打印最不重要的数字。这显然是与大数互斥的。</target>
        </trans-unit>
        <trans-unit id="42046a99717c8fc1f7b5308618430cf23e775de1" translate="yes" xml:space="preserve">
          <source>Print sequence numbers with the most significant digit first. This is the usual convention for Arabic numerals, and the default.</source>
          <target state="translated">打印序列号时,先打印最重要的数字。这是阿拉伯数字的惯例,也是默认值。</target>
        </trans-unit>
        <trans-unit id="c3ded95dcda74015cef369414ceaf1353a3c08bf" translate="yes" xml:space="preserve">
          <source>Print the manual page and exit.</source>
          <target state="translated">打印手册页并退出。</target>
        </trans-unit>
        <trans-unit id="dafca06fe55ca5e809a5fcfdbf9c2ee2334e2463" translate="yes" xml:space="preserve">
          <source>Print the usage, help and version for this h2xs and exit.</source>
          <target state="translated">打印这个h2xs的用法、帮助和版本,然后退出。</target>
        </trans-unit>
        <trans-unit id="48353b6a506515740ab2f4902262078e0065726e" translate="yes" xml:space="preserve">
          <source>Print the values in</source>
          <target state="translated">将数值打印在</target>
        </trans-unit>
        <trans-unit id="cf456c50fd7554fe013a6e25ab9a344d6d5f2f5b" translate="yes" xml:space="preserve">
          <source>Print this command's manual page and exit.</source>
          <target state="translated">打印该命令的手册页并退出。</target>
        </trans-unit>
        <trans-unit id="b5abd8dca5d79ec848ccb7806e5cedef648f49fd" translate="yes" xml:space="preserve">
          <source>PrintList</source>
          <target state="translated">PrintList</target>
        </trans-unit>
        <trans-unit id="c161e4f9d513f9dc8591fcb0a239c86a9d1fc520" translate="yes" xml:space="preserve">
          <source>PrintUID</source>
          <target state="translated">PrintUID</target>
        </trans-unit>
        <trans-unit id="ca00d8181f32941120efd18913e9feb042cbbf6c" translate="yes" xml:space="preserve">
          <source>Printing individual test results to STDOUT.</source>
          <target state="translated">将单个测试结果打印到STDOUT。</target>
        </trans-unit>
        <trans-unit id="ed2d714a6f330a5a2c0d2c285311e85e596cb81a" translate="yes" xml:space="preserve">
          <source>Printing to a closed pipe or socket will generate a SIGPIPE signal. See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for more on signal handling.</source>
          <target state="translated">打印到封闭的管道或插座上将生成SIGPIPE信号。有关信号处理的更多信息，请参见&lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7ce5ec55f788bd07557410056fe40271d8ea629" translate="yes" xml:space="preserve">
          <source>Printing to a closed pipe or socket will generate a SIGPIPE signal. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more on signal handling.</source>
          <target state="translated">打印到封闭的管道或插座上将生成SIGPIPE信号。有关信号处理的更多信息，请参见&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f0265cab2f9ae79cde71a71556d0e278394eaeb" translate="yes" xml:space="preserve">
          <source>Prints a brief summary of the options.</source>
          <target state="translated">打印选项的摘要。</target>
        </trans-unit>
        <trans-unit id="5120452ca6dc631595efb8d29461dd946809a41a" translate="yes" xml:space="preserve">
          <source>Prints a diagnostic message which is guaranteed not to interfere with test output. Like &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; @diagnostic_message is simply concatenated together.</source>
          <target state="translated">打印保证不会干扰测试输出的诊断消息。就像 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; @diagnostic_message只是简单地串联在一起。</target>
        </trans-unit>
        <trans-unit id="8c49c244084f74c7a4ade71b1d350fb5c73651b5" translate="yes" xml:space="preserve">
          <source>Prints a dump to the currently selected filehandle.</source>
          <target state="translated">打印转储到当前选定的文件柄。</target>
        </trans-unit>
        <trans-unit id="33ae188d27fe9ec243158d1e261dc04f6d576630" translate="yes" xml:space="preserve">
          <source>Prints a fragment of POD suitable for appending to perllocal.pod. Arguments are read from @ARGV.</source>
          <target state="translated">打印适合附加到 perllocal.pod 的 POD 片段。参数从@ARGV中读取。</target>
        </trans-unit>
        <trans-unit id="d418169bc3a4b28200c4744d9dae5cd8e744b200" translate="yes" xml:space="preserve">
          <source>Prints a string or a list of strings. Returns true if successful. FILEHANDLE may be a scalar variable containing the name of or a reference to the filehandle, thus introducing one level of indirection. (NOTE: If FILEHANDLE is a variable and the next token is a term, it may be misinterpreted as an operator unless you interpose a &lt;code&gt;+&lt;/code&gt; or put parentheses around the arguments.) If FILEHANDLE is omitted, prints to the last selected (see &lt;a href=&quot;#select&quot;&gt;select&lt;/a&gt;) output handle. If LIST is omitted, prints &lt;code&gt;$_&lt;/code&gt; to the currently selected output handle. To use FILEHANDLE alone to print the content of &lt;code&gt;$_&lt;/code&gt; to it, you must use a real filehandle like &lt;code&gt;FH&lt;/code&gt; , not an indirect one like &lt;code&gt;$fh&lt;/code&gt; . To set the default output handle to something other than STDOUT, use the select operation.</source>
          <target state="translated">打印一个字符串或字符串列表。如果成功，则返回true。 FILEHANDLE可以是一个标量变量，包含文件句柄的名称或对文件句柄的引用，从而引入了一个间接级别。 （注意：如果FILEHANDLE是变量，而下一个标记是术语，则除非您在参数之间插入 &lt;code&gt;+&lt;/code&gt; 或在参数中加上括号，否则它可能会被误认为是运算符。）如果省略FILEHANDLE，则打印到最后选择的位置（请参阅&lt;a href=&quot;#select&quot;&gt;select&lt;/a&gt;）输出句柄。如果省略LIST，则将 &lt;code&gt;$_&lt;/code&gt; 打印到当前选定的输出句柄。要单独使用FILEHANDLE向其中打印 &lt;code&gt;$_&lt;/code&gt; 的内容，必须使用像 &lt;code&gt;FH&lt;/code&gt; 这样的真实文件句柄，而不是像 &lt;code&gt;$fh&lt;/code&gt; 这样的间接文件句柄。。要将默认输出句柄设置为STDOUT以外的其他值，请使用select操作。</target>
        </trans-unit>
        <trans-unit id="20e173b143e047744531b3fd15b76f4ad914ea5c" translate="yes" xml:space="preserve">
          <source>Prints a string or a list of strings. Returns true if successful. FILEHANDLE may be a scalar variable containing the name of or a reference to the filehandle, thus introducing one level of indirection. (NOTE: If FILEHANDLE is a variable and the next token is a term, it may be misinterpreted as an operator unless you interpose a &lt;code&gt;+&lt;/code&gt; or put parentheses around the arguments.) If FILEHANDLE is omitted, prints to the last selected (see &lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;) output handle. If LIST is omitted, prints &lt;code&gt;$_&lt;/code&gt; to the currently selected output handle. To use FILEHANDLE alone to print the content of &lt;code&gt;$_&lt;/code&gt; to it, you must use a real filehandle like &lt;code&gt;FH&lt;/code&gt; , not an indirect one like &lt;code&gt;$fh&lt;/code&gt; . To set the default output handle to something other than STDOUT, use the select operation.</source>
          <target state="translated">打印一个字符串或字符串列表。如果成功，则返回true。 FILEHANDLE可以是一个标量变量，包含文件句柄的名称或对文件句柄的引用，从而引入了一个间接级别。 （注意：如果FILEHANDLE是变量，而下一个标记是术语，则除非您在参数之间插入 &lt;code&gt;+&lt;/code&gt; 或在参数中加上括号，否则它可能会被误认为是运算符。）如果省略FILEHANDLE，则打印到最后选择的位置（请参阅&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;）输出句柄。如果省略LIST，则将 &lt;code&gt;$_&lt;/code&gt; 打印到当前选定的输出句柄。要单独使用FILEHANDLE向其中打印 &lt;code&gt;$_&lt;/code&gt; 的内容，必须使用像 &lt;code&gt;FH&lt;/code&gt; 这样的真实文件句柄，而不是像 &lt;code&gt;$fh&lt;/code&gt; 这样的间接文件句柄。。要将默认输出句柄设置为STDOUT以外的其他值，请使用select操作。</target>
        </trans-unit>
        <trans-unit id="673f7ed1fcf144a6eba94659c1b8bb4cb6a329f3" translate="yes" xml:space="preserve">
          <source>Prints a string representation of the token. This might not be the exact output, however. Tests will have test numbers added if not present, TODO and SKIP directives will be capitalized and, in general, things will be cleaned up. If you need the original text for the token, see the &lt;code&gt;raw&lt;/code&gt; method.</source>
          <target state="translated">打印令牌的字符串表示形式。但是，这可能不是确切的输出。如果不存在测试，则会添加测试编号，TODO和SKIP指令将大写，并且通常会清除所有内容。如果您需要令牌的原始文本，请参见 &lt;code&gt;raw&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="a5419b1162d34c785eeb369d86d716b9bd02ac8d" translate="yes" xml:space="preserve">
          <source>Prints completion list. Defined by</source>
          <target state="translated">打印完成列表。定义为</target>
        </trans-unit>
        <trans-unit id="934dc976c1f3a281267304f789f524cd21fb3e61" translate="yes" xml:space="preserve">
          <source>Prints out a brief &lt;b&gt;h&lt;/b&gt;elp message.</source>
          <target state="translated">打印出一个简短的&lt;b&gt;^ h&lt;/b&gt; ELP消息。</target>
        </trans-unit>
        <trans-unit id="8c3217961ab68f1c8d44e975715650bfda91f224" translate="yes" xml:space="preserve">
          <source>Prints out a brief help message.</source>
          <target state="translated">打印出简短的帮助信息。</target>
        </trans-unit>
        <trans-unit id="63d68ec3ff2a5f8e8482209bf682a1142f623388" translate="yes" xml:space="preserve">
          <source>Prints out a help message for the given debugger command.</source>
          <target state="translated">打印指定调试器命令的帮助信息。</target>
        </trans-unit>
        <trans-unit id="4570ddcfa99412c204793cd712ce6565f233cdcb" translate="yes" xml:space="preserve">
          <source>Prints out a summary help message</source>
          <target state="translated">打印出摘要帮助信息</target>
        </trans-unit>
        <trans-unit id="62c00c799d0422f6ccb3e9e43272184c0326a6ce" translate="yes" xml:space="preserve">
          <source>Prints out macros for lots of constants.</source>
          <target state="translated">打印出大量常量的宏。</target>
        </trans-unit>
        <trans-unit id="35708a04576938ac03483a4b724360182a7d23a6" translate="yes" xml:space="preserve">
          <source>Prints out the given &lt;code&gt;@msgs&lt;/code&gt; . Like &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, arguments are simply appended together.</source>
          <target state="translated">打印出给定的 &lt;code&gt;@msgs&lt;/code&gt; 。像 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 一样，参数只是简单地附加在一起。</target>
        </trans-unit>
        <trans-unit id="8697e6653e8aef8900cf9e82eba2ff6e2e2ce4de" translate="yes" xml:space="preserve">
          <source>Prints the</source>
          <target state="translated">打印</target>
        </trans-unit>
        <trans-unit id="aa5bdc16d8c54057921ac95e8b1fdf7e996f4f26" translate="yes" xml:space="preserve">
          <source>Prints the C definition of the argument given.</source>
          <target state="translated">打印给定参数的C定义。</target>
        </trans-unit>
        <trans-unit id="a403f4f42c33b1f9084f9bd0a79f13a0277056b6" translate="yes" xml:space="preserve">
          <source>Prints the value of LIST to STDERR. If the last element of LIST does not end in a newline, it appends the same file/line number text as &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; does.</source>
          <target state="translated">将LIST的值打印到STDERR。如果LIST的最后一个元素未以换行符结尾，则它会与 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 一样附加相同的文件/行号文本。</target>
        </trans-unit>
        <trans-unit id="4c5e1509c949e03f2e16a45151c3707f6e64336d" translate="yes" xml:space="preserve">
          <source>Prints the value of LIST to STDERR. If the last element of LIST does not end in a newline, it appends the same file/line number text as &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; does.</source>
          <target state="translated">将LIST的值打印到STDERR。如果LIST的最后一个元素未以换行符结尾，则它会与 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 一样附加相同的文件/行号文本。</target>
        </trans-unit>
        <trans-unit id="bcbea290fe72663ef6d97c309d0691a702a71daa" translate="yes" xml:space="preserve">
          <source>Prints to STDOUT the value of the named configuration variable(s), with multiples when your &lt;code&gt;&lt;i&gt;configvar&lt;/i&gt;&lt;/code&gt; argument looks like a regex (has non-letters). For example:</source>
          <target state="translated">当您的 &lt;code&gt;&lt;i&gt;configvar&lt;/i&gt;&lt;/code&gt; 参数看起来像正则表达式（具有非字母）时，将指定配置变量的值打印到STDOUT，并以倍数显示。例如：</target>
        </trans-unit>
        <trans-unit id="d654c6a51dac4e65071d9448226908e23e864aba" translate="yes" xml:space="preserve">
          <source>Prints to STDOUT the values of the named configuration variable. Each is printed on a separate line in the form:</source>
          <target state="translated">将指定配置变量的值打印到STDOUT。每个变量的值都以表格形式单独一行打印出来。</target>
        </trans-unit>
        <trans-unit id="006ef841b2dbe9474f20b394f899a01b44e0808f" translate="yes" xml:space="preserve">
          <source>Prior to 5.14, there were no explicit modifiers, but &lt;code&gt;/l&lt;/code&gt; was implied for regexes compiled within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , and &lt;code&gt;/d&lt;/code&gt; was implied otherwise. However, interpolating a regex into a larger regex would ignore the original compilation in favor of whatever was in effect at the time of the second compilation. There were a number of inconsistencies (bugs) with the &lt;code&gt;/d&lt;/code&gt; modifier, where Unicode rules would be used when inappropriate, and vice versa. &lt;code&gt;\p{}&lt;/code&gt; did not imply Unicode rules, and neither did all occurrences of &lt;code&gt;\N{}&lt;/code&gt; , until 5.12.</source>
          <target state="translated">此前5.14，没有明确的改性剂，但 &lt;code&gt;/l&lt;/code&gt; 是隐含的范围内编译的正则表达式 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ，和 &lt;code&gt;/d&lt;/code&gt; 是另有暗示。但是，将正则表达式插入较大的正则表达式将忽略原始编译，而有利于第二次编译时生效的内容。 &lt;code&gt;/d&lt;/code&gt; 修饰符存在许多不一致（错误），如果不合适，将使用Unicode规则，反之亦然。 &lt;code&gt;\p{}&lt;/code&gt; 并不隐含Unicode规则，所有出现的 &lt;code&gt;\N{}&lt;/code&gt; 都不隐含Unicode ，直到5.12。</target>
        </trans-unit>
        <trans-unit id="fe8a0830714e6cb8a879a800eebdc6d82f423871" translate="yes" xml:space="preserve">
          <source>Prior to Encode 1.86 this fails because of &quot;local $_&quot;.</source>
          <target state="translated">在Encode 1.86之前,由于 &quot;local $_&quot;的原因,这个失败了。</target>
        </trans-unit>
        <trans-unit id="237bfe322fa2d5537b0e7ae9cfd030692f2d5ae8" translate="yes" xml:space="preserve">
          <source>Prior to Encode version 1.87</source>
          <target state="translated">在Encode 1.87版之前</target>
        </trans-unit>
        <trans-unit id="d393399b163454a92ab92f702710947f99b00d32" translate="yes" xml:space="preserve">
          <source>Prior to Perl 5.14, this wouldn't even compile:</source>
          <target state="translated">在Perl 5.14之前,这甚至无法编译。</target>
        </trans-unit>
        <trans-unit id="de989d99cd26a240641d2cdc8e03612a0efe21ac" translate="yes" xml:space="preserve">
          <source>Prior to Perl 5.17.6 this function returned a UV, it now returns a string, which may be of nearly any size as determined by the hash function your Perl has been built with. Possible sizes may be but are not limited to 4 bytes (for most hash algorithms) and 16 bytes (for siphash).</source>
          <target state="translated">在 Perl 5.17.6 之前,这个函数返回的是一个 UV,现在它返回的是一个字符串,其大小几乎可以由你的 Perl 所使用的哈希函数决定。可能的大小可以是但不限于 4 字节(对于大多数哈希算法)和 16 字节(对于 siphash)。</target>
        </trans-unit>
        <trans-unit id="7c29fb6a57f19dc07c4af7b9c93f10ac571d8e1d" translate="yes" xml:space="preserve">
          <source>Prior to Perl 5.22, lexical &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; subroutines were not deparsed properly. They were emitted as pure declarations, sometimes in the wrong place. Lexical &lt;code&gt;&lt;a href=&quot;../functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; subroutines were not deparsed at all.</source>
          <target state="translated">在Perl 5.22之前，词汇 &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 子例程未得到正确的解析。它们被作为纯声明发出，有时放在错误的位置。词汇 &lt;code&gt;&lt;a href=&quot;../functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 子例程根本没有被贬低。</target>
        </trans-unit>
        <trans-unit id="7ac15b68acc965c4200628245ecd910b03ae005b" translate="yes" xml:space="preserve">
          <source>Prior to Perl 5.8, repetitions of templates had to be made by &lt;code&gt;x&lt;/code&gt; -multiplication of template strings. Now there is a better way as we may use the pack codes &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; combined with a repeat count. The &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; template from the Stack Frame example can simply be written like this:</source>
          <target state="translated">在Perl 5.8之前，必须通过模板字符串的 &lt;code&gt;x&lt;/code&gt; 乘法来重复模板。现在有了更好的方法，因为我们可以将打包代码 &lt;code&gt;(&lt;/code&gt; 和 &lt;code&gt;)&lt;/code&gt; 与重复计数结合使用。堆栈框架示例中的 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 模板可以这样简单地编写：</target>
        </trans-unit>
        <trans-unit id="7c459e52ad4361ad572014fb809fc32c7c7355a6" translate="yes" xml:space="preserve">
          <source>Prior to Perl 5.8.0 it was necessary to do as little as you possibly could in your handler; notice how all we do is set a global variable and then raise an exception. That's because on most systems, libraries are not re-entrant; particularly, memory allocation and I/O routines are not. That meant that doing nearly</source>
          <target state="translated">在Perl 5.8.0之前,有必要在你的处理程序中尽可能地少做一些事情;注意我们所做的只是设置一个全局变量,然后引发一个异常。这是因为在大多数系统中,库是不重入的;尤其是内存分配和 I/O 例程。这就意味着,做几乎</target>
        </trans-unit>
        <trans-unit id="edf719ad4c45a8a39497a026af447085a953aba6" translate="yes" xml:space="preserve">
          <source>Prior to Perl v5.10.0, assignment to &lt;code&gt;$[&lt;/code&gt; could be seen from outer lexical scopes in the same file, unlike other compile-time directives (such as &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt;). Using local() on it would bind its value strictly to a lexical block. Now it is always lexically scoped.</source>
          <target state="translated">在Perl v5.10.0之前，可以从同一文件中的外部词法范围看到对 &lt;code&gt;$[&lt;/code&gt; 赋值，这与其他编译时指令（例如&lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt;）不同。在其上使用local（）会将其值严格绑定到词汇块。现在，它始终在词法范围内。</target>
        </trans-unit>
        <trans-unit id="1eccc3df24f7326b35822731bb67524c647ac965" translate="yes" xml:space="preserve">
          <source>Prior to Perl v5.18, &lt;code&gt;\s&lt;/code&gt; did not match the vertical tab. &lt;code&gt;[^\S\cK]&lt;/code&gt; (obscurely) matches what &lt;code&gt;\s&lt;/code&gt; traditionally did.</source>
          <target state="translated">在Perl v5.18之前， &lt;code&gt;\s&lt;/code&gt; 与垂直标签不匹配。 &lt;code&gt;[^\S\cK]&lt;/code&gt; （模糊地）匹配传统上的 &lt;code&gt;\s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81458241fb89dacc9cdc0cd507759e6ca279c04d" translate="yes" xml:space="preserve">
          <source>Prior to Perl v5.22</source>
          <target state="translated">在Perl v5.22之前</target>
        </trans-unit>
        <trans-unit id="e6e12acf75f0fd6f1c215305ad4143a7eff7a8c7" translate="yes" xml:space="preserve">
          <source>Prior to Perl v5.8.1</source>
          <target state="translated">在Perl v5.8.1之前</target>
        </trans-unit>
        <trans-unit id="ccdb08dd9c53a9d56313f4f2db92f69844b78387" translate="yes" xml:space="preserve">
          <source>Prior to Perl version 5.10, the result of using an lvalue multiple times was unspecified. Prior to 5.16, the result with negative offsets was unspecified.</source>
          <target state="translated">在Perl 5.10版本之前,多次使用l值的结果是不明确的。在5.16之前,没有说明使用负偏移量的结果。</target>
        </trans-unit>
        <trans-unit id="0030b6d60b1028edd6febca0979cdab635fcf553" translate="yes" xml:space="preserve">
          <source>Prior to Storable 2.01, no distinction was made between signed and unsigned integers on storing. By default Storable prefers to store a scalars string representation (if it has one) so this would only cause problems when storing large unsigned integers that had never been converted to string or floating point. In other words values that had been generated by integer operations such as logic ops and then not used in any string or arithmetic context before storing.</source>
          <target state="translated">在Storable 2.01之前,存储时没有区分有符号和无符号整数。默认情况下,Storable更倾向于存储标量字符串表示法(如果有的话),所以这只会在存储大的无符号整数时引起问题,因为这些整数从未被转换为字符串或浮点数。换句话说,这些值是由整数运算产生的,比如逻辑运算,然后在存储前没有在任何字符串或算术上下文中使用。</target>
        </trans-unit>
        <trans-unit id="02a1fc8bf1a7ff0b71b0109895cbd28a2a3ed487" translate="yes" xml:space="preserve">
          <source>Prior to perl 5.6 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; returned copies of the values, so older perl code often contains constructions such as &lt;code&gt;@orbits{&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %orbits}&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; %orbits&lt;/code&gt; where the hash is to be modified.</source>
          <target state="translated">在perl 5.6之前， &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 返回值的副本，因此，较早的perl代码通常包含 &lt;code&gt;@orbits{&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %orbits}&lt;/code&gt; 构造，而不是要修改哈希 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; %orbits&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f11fd4a98a09048dbed1e6ac8b8ef1689e8b33e4" translate="yes" xml:space="preserve">
          <source>Prior to release 5.0 of Perl, a programmer could use dbmopen() to connect an on-disk database in the standard Unix dbm(3x) format magically to a %HASH in their program. However, their Perl was either built with one particular dbm library or another, but not both, and you couldn't extend this mechanism to other packages or types of variables.</source>
          <target state="translated">在Perl 5.0版本之前,程序员可以使用dbmopen()将一个标准Unix dbm(3x)格式的磁盘数据库神奇地连接到他们程序中的%HASH。然而,他们的Perl要么是用一个特定的dbm库构建的,要么是用另一个库构建的,但不是两者都有,而且你不能将这种机制扩展到其他包或变量类型。</target>
        </trans-unit>
        <trans-unit id="70e3fb3fd17c9435bb1df82e7b954798d46dd101" translate="yes" xml:space="preserve">
          <source>Prior to this point, anyone programming in perl who wanted to interact with C programs, like the kernel, was forced to guess the layouts of the C structures, and then hardwire these into his program. Of course, when you took your wonderfully crafted program to a system where the sgtty structure was laid out differently, your program broke. Which is a shame.</source>
          <target state="translated">在这之前,任何用perl编程的人如果想和C程序交互,比如内核,就不得不猜测C结构的布局,然后把这些硬连接到他的程序中。当然,当你把你的精彩程序带到一个sgtty结构布局不同的系统中时,你的程序就会崩溃。这是一个遗憾。</target>
        </trans-unit>
        <trans-unit id="af7e1150dbf03ec2621e5c3e750556f5d9b511aa" translate="yes" xml:space="preserve">
          <source>Prior to v5.14, there were some bugs in &lt;code&gt;\N{...}&lt;/code&gt; with a character name (as opposed to a &lt;code&gt;U+...&lt;/code&gt; code point).</source>
          <target state="translated">在v5.14之前， &lt;code&gt;\N{...}&lt;/code&gt; 存在一个字符名称错误（与 &lt;code&gt;U+...&lt;/code&gt; 代码点相对）。</target>
        </trans-unit>
        <trans-unit id="d4f4150bc1f255b33ac823d8094c75e885836366" translate="yes" xml:space="preserve">
          <source>Prior to v5.16, using &lt;code&gt;\N{...}&lt;/code&gt; with a character name (as opposed to a &lt;code&gt;U+...&lt;/code&gt; code point) required a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames :full&lt;/code&gt; .</source>
          <target state="translated">在v5.16之前，使用 &lt;code&gt;\N{...}&lt;/code&gt; 和字符名称（而不是 &lt;code&gt;U+...&lt;/code&gt; 代码点）需要 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames :full&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2e863acc878c8a62def318f458b49c2252c835f" translate="yes" xml:space="preserve">
          <source>Prior to v5.20, Perl raised a warning and made all matches fail on non-Unicode code points. This could be somewhat surprising:</source>
          <target state="translated">在 v5.20 之前,Perl 会发出警告,并使所有非 Unicode 代码点的匹配失败。这可能有些令人惊讶。</target>
        </trans-unit>
        <trans-unit id="63188205d9031db86825c40d25da5b1f4ef4afef" translate="yes" xml:space="preserve">
          <source>Prior to v5.22 only one form of the pragma with arguments is available:</source>
          <target state="translated">在v5.22之前,带参数的pragma只有一种形式。</target>
        </trans-unit>
        <trans-unit id="2bb17f127c6d06738170e861c52ecb4dd3c7bab1" translate="yes" xml:space="preserve">
          <source>Prior to v5.22, you couldn't specify any ranges portably, except (starting in Perl v5.5.3) all subsets of the &lt;code&gt;[A-Z]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; ranges are specially coded to not pick up gap characters. For example, characters such as &quot;&amp;ocirc;&quot; (&lt;code&gt;o WITH CIRCUMFLEX&lt;/code&gt; ) that lie between &quot;I&quot; and &quot;J&quot; would not be matched by the regular expression range &lt;code&gt;/[H-K]/&lt;/code&gt; . But if either of the range end points is explicitly numeric (and neither is specified by &lt;code&gt;\N{U+...}&lt;/code&gt; ), the gap characters are matched:</source>
          <target state="translated">在v5.22之前，您无法便携式地指定任何范围，除非（从Perl v5.5.3开始） &lt;code&gt;[A-Z]&lt;/code&gt; 和 &lt;code&gt;[a-z]&lt;/code&gt; 范围的所有子集都经过特殊编码，以不拾取空格字符。例如，位于&amp;ldquo; I&amp;rdquo;和&amp;ldquo; J&amp;rdquo;之间的诸如&amp;ldquo;&amp;ocirc;&amp;rdquo;（ &lt;code&gt;o WITH CIRCUMFLEX&lt;/code&gt; ）之类的字符将不与正则表达式范围 &lt;code&gt;/[H-K]/&lt;/code&gt; 匹配。但是，如果两个范围端点中的任何一个都是显式数字的（并且都不由 &lt;code&gt;\N{U+...}&lt;/code&gt; ），则间隔字符将匹配：</target>
        </trans-unit>
        <trans-unit id="8c6a67b224e69bc355ee61cdb60ffe1494025492" translate="yes" xml:space="preserve">
          <source>Prior to version 1.2.0, zlib assumed that there was at least one trailing byte immediately after the compressed data stream when it was carrying out decompression. This normally isn't a problem because the majority of zlib applications guarantee that there will be data directly after the compressed data stream. For example, both gzip (RFC 1950) and zip both define trailing data that follows the compressed data stream.</source>
          <target state="translated">在1.2.0版本之前,zlib在进行解压时,假设在压缩数据流之后至少有一个尾部字节。这通常不是一个问题,因为大多数zlib应用程序保证在压缩数据流之后会直接有数据。例如,gzip(RFC 1950)和zip都定义了压缩数据流之后的尾部数据。</target>
        </trans-unit>
        <trans-unit id="8c0ad90bec3127568428d4c04d5d1ea52f6ba12f" translate="yes" xml:space="preserve">
          <source>Priorities</source>
          <target state="translated">Priorities</target>
        </trans-unit>
        <trans-unit id="92e6b3fba0bbad8db67c2af3c57c98bc96a811e3" translate="yes" xml:space="preserve">
          <source>Private Variables via my()</source>
          <target state="translated">通过my()的私有变量</target>
        </trans-unit>
        <trans-unit id="05130e33abddf0e65c0e7c60a0ddfd3cb42e8f19" translate="yes" xml:space="preserve">
          <source>Private data fields are stored in the hash-object whose reference is returned by the &lt;b&gt;new()&lt;/b&gt; constructor for this class. The names of all private methods and data-fields used by &lt;b&gt;Pod::Parser&lt;/b&gt; begin with a prefix of &quot;_&quot; and match the regular expression &lt;code&gt;/^_\w+$/&lt;/code&gt; .</source>
          <target state="translated">私有数据字段存储在哈希对象中，该哈希对象的引用由此类的&lt;b&gt;new（）&lt;/b&gt;构造函数返回。&lt;b&gt;Pod :: Parser&lt;/b&gt;使用的所有私有方法和数据字段的名称均以前缀&amp;ldquo; _&amp;rdquo;开头，并与正则表达式 &lt;code&gt;/^_\w+$/&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="65f6f08ed32d7f3e7ae8b96d47bc7edf0dd64925" translate="yes" xml:space="preserve">
          <source>Private data fields are stored in the hash-object whose reference is returned by the &lt;b&gt;new()&lt;/b&gt; constructor for this class. The names of all private methods and data-fields used by &lt;b&gt;Pod::Select&lt;/b&gt; begin with a prefix of &quot;_&quot; and match the regular expression &lt;code&gt;/^_\w+$/&lt;/code&gt; .</source>
          <target state="translated">私有数据字段存储在哈希对象中，该哈希对象的引用由此类的&lt;b&gt;new（）&lt;/b&gt;构造函数返回。&lt;b&gt;Pod :: Select&lt;/b&gt;使用的所有私有方法和数据字段的名称均以前缀&amp;ldquo; _&amp;rdquo;开头，并匹配正则表达式 &lt;code&gt;/^_\w+$/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20d7d0dbde2c55d3d35a4245cf685ae7921d0a46" translate="yes" xml:space="preserve">
          <source>Private flags, if any are set for an opcode, are displayed after a '/'</source>
          <target state="translated">如果为一个操作码设置了私人标志,则会在'/'之后显示。</target>
        </trans-unit>
        <trans-unit id="ba4d99009403ef1e9fa58895f77afbe80e15c049" translate="yes" xml:space="preserve">
          <source>Probably give some hints on using SETERRNO() or pointers to where they can be found.</source>
          <target state="translated">可能会给出一些关于使用SETERRNO()的提示,或者指向可以找到它们的地方。</target>
        </trans-unit>
        <trans-unit id="12ee136d3488f2b13710aaf22abd3d36be8ba625" translate="yes" xml:space="preserve">
          <source>Probably more than X kb, since it will all be read into memory. If this is a problem, and you don't need to do in memory manipulation of the archive, consider using the &lt;code&gt;iter&lt;/code&gt; class method, or &lt;code&gt;/bin/tar&lt;/code&gt; instead.</source>
          <target state="translated">可能超过X kb，因为它们都将被读入内存。如果这是一个问题，并且您不需要对档案进行内存操作，请考虑使用 &lt;code&gt;iter&lt;/code&gt; 类方法或 &lt;code&gt;/bin/tar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30d6e13bbb18e72ebcf84bb4444a8e743d2c653b" translate="yes" xml:space="preserve">
          <source>Probably others.</source>
          <target state="translated">可能还有其他人。</target>
        </trans-unit>
        <trans-unit id="6ba279b033596c1de1e96bda59ebc9b45740b37e" translate="yes" xml:space="preserve">
          <source>Probably you &lt;b&gt;do&lt;/b&gt; have the old version installed. This can happen if a module installs itself into a different directory in the @INC path than it was previously installed. This is not really a CPAN.pm problem, you would have the same problem when installing the module manually. The easiest way to prevent this behaviour is to add the argument &lt;code&gt;UNINST=1&lt;/code&gt; to the &lt;code&gt;make install&lt;/code&gt; call, and that is why many people add this argument permanently by configuring</source>
          <target state="translated">可能您&lt;b&gt;确实&lt;/b&gt;安装了旧版本。如果模块将其自身安装到@INC路径中与以前安装的目录不同的目录中，则会发生这种情况。这实际上不是CPAN.pm问题，手动安装模块时也会遇到同样的问题。防止此行为的最简单方法是将参数 &lt;code&gt;UNINST=1&lt;/code&gt; 添加到 &lt;code&gt;make install&lt;/code&gt; 调用中，这就是为什么许多人通过配置永久添加此参数的原因</target>
        </trans-unit>
        <trans-unit id="5a71c3bb0c835b3979085e9217ce9dcff4431ef5" translate="yes" xml:space="preserve">
          <source>Problematic System Interfaces</source>
          <target state="translated">有问题的系统接口</target>
        </trans-unit>
        <trans-unit id="348967ab4ee9f7f83af2fd9006e6f3cb3052fe52" translate="yes" xml:space="preserve">
          <source>Problems can arise if the string expands a scalar containing a floating point number. That scalar can expand to letters, such as &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; or &lt;code&gt;&quot;Infinity&quot;&lt;/code&gt; ; or, within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , the decimal point character may be something other than a dot (such as a comma). None of these are likely to parse as you are likely expecting.</source>
          <target state="translated">如果字符串扩展包含浮点数的标量，则可能会出现问题。标量可以扩展为字母，例如 &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;Infinity&quot;&lt;/code&gt; ；或者，在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的范围内，小数点字符可以是点以外的其他字符（例如逗号）。这些都不可能像您期望的那样进行解析。</target>
        </trans-unit>
        <trans-unit id="4ec141ca9a30659dea063b68fb5a517f3e3d534b" translate="yes" xml:space="preserve">
          <source>Problems can arise if the string expands a scalar containing a floating point number. That scalar can expand to letters, such as &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; or &lt;code&gt;&quot;Infinity&quot;&lt;/code&gt; ; or, within the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , the decimal point character may be something other than a dot (such as a comma). None of these are likely to parse as you are likely expecting.</source>
          <target state="translated">如果字符串扩展包含浮点数的标量，则可能会出现问题。标量可以扩展为字母，例如 &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;Infinity&quot;&lt;/code&gt; ；或者，在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的范围内，小数点字符可以是点以外的其他字符（例如逗号）。这些都不可能像您期望的那样进行解析。</target>
        </trans-unit>
        <trans-unit id="c1a04b0f8db3bbf9a433e4161d3acc8ec9cc5945" translate="yes" xml:space="preserve">
          <source>Problems of Inside-out</source>
          <target state="translated">由内向外的问题</target>
        </trans-unit>
        <trans-unit id="1ee1742b87ae33a1c6f39cdefb753ee45be9c395" translate="yes" xml:space="preserve">
          <source>Problems with tr or sed</source>
          <target state="translated">Tr或sed的问题</target>
        </trans-unit>
        <trans-unit id="41c48fd3a204be2beab6bd0e24fdbda408c2ba06" translate="yes" xml:space="preserve">
          <source>Proc::ProcessTable does not compile on Solaris with perl5.6.0 and higher if you have LARGEFILES defined. Since largefile support is the default in 5.6.0 and later, you have to take special steps to use this module.</source>
          <target state="translated">如果你定义了LARGEFILES,那么Proc::ProcessTable在perl5.6.0及更高版本的Solaris上不能编译。由于5.6.0及以后的版本默认支持largefile,所以你必须采取特殊的步骤来使用这个模块。</target>
        </trans-unit>
        <trans-unit id="ac93e65b57a2151f0a952944a98261a5685458fa" translate="yes" xml:space="preserve">
          <source>Proc::ProcessTable on Solaris</source>
          <target state="translated">Proc::ProcessTable在Solaris上的应用</target>
        </trans-unit>
        <trans-unit id="63b4e90314d2c42ea7a19c98e41b4f05994ebf0f" translate="yes" xml:space="preserve">
          <source>Procedures for predeclaring the output that your test suite is expected to produce until &lt;code&gt;test_test&lt;/code&gt; is called. These procedures automatically assume that each line terminates with &quot;\n&quot;. So</source>
          <target state="translated">在调用 &lt;code&gt;test_test&lt;/code&gt; 之前预先声明测试套件将产生的输出的过程。这些过程自动假定每行以&amp;ldquo; \ n&amp;rdquo;结尾。所以</target>
        </trans-unit>
        <trans-unit id="84b64dd0d66309028df716ba28b5d47e80552535" translate="yes" xml:space="preserve">
          <source>Proceed as above, but make</source>
          <target state="translated">如上所述,但要</target>
        </trans-unit>
        <trans-unit id="f73b8984cc638c7a7b07ebde54216495fdea38ec" translate="yes" xml:space="preserve">
          <source>Process Overview</source>
          <target state="translated">流程概述</target>
        </trans-unit>
        <trans-unit id="47792f7246b1ace09a77268265b8c2e729e950de" translate="yes" xml:space="preserve">
          <source>Process and Thread Termination</source>
          <target state="translated">进程和线程终止</target>
        </trans-unit>
        <trans-unit id="90d477e2d9ac85e239d0759d291d0532a8b57032" translate="yes" xml:space="preserve">
          <source>Process single-character switches with switch clustering</source>
          <target state="translated">用开关簇处理单字符开关。</target>
        </trans-unit>
        <trans-unit id="34ae1c3ba08c93d4aa84d88b30e7ce92a5bf6618" translate="yes" xml:space="preserve">
          <source>Process the contents of $_ to change the source code in the desired manner.</source>
          <target state="translated">对$_的内容进行处理,按照需要的方式修改源代码。</target>
        </trans-unit>
        <trans-unit id="a71e516dfb64d613336cd8c83af6bfd904864ee0" translate="yes" xml:space="preserve">
          <source>Process-scope Changes</source>
          <target state="translated">流程范围变化</target>
        </trans-unit>
        <trans-unit id="4a52ce9e460a5f71bed1414f20a7fe6e02ca3cb9" translate="yes" xml:space="preserve">
          <source>ProcessRead</source>
          <target state="translated">ProcessRead</target>
        </trans-unit>
        <trans-unit id="240d22a1e0317130f09d247d6dde37168740bd36" translate="yes" xml:space="preserve">
          <source>Processes its arguments like &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; and appends the formatted output to an SV. If the appended data contains &quot;wide&quot; characters (including, but not limited to, SVs with a UTF-8 PV formatted with %s, and characters &amp;gt;255 formatted with %c), the original SV might get upgraded to UTF-8. Handles 'get' magic, but not 'set' magic. See &lt;code&gt;sv_catpvf_mg&lt;/code&gt; . If the original SV was UTF-8, the pattern should be valid UTF-8; if the original SV was bytes, the pattern should be too.</source>
          <target state="translated">处理其像 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 这样的参数，并将格式化后的输出附加到SV。如果附加数据包含&amp;ldquo;宽&amp;rdquo;字符（包括但不限于以％s格式化为UTF-8 PV的字符，以及以％c格式化为字符&amp;gt; 255的字符），则原始SV可能会升级为UTF-8。处理&amp;ldquo;获取&amp;rdquo;魔法，但不处理&amp;ldquo;设定&amp;rdquo;魔法。参见 &lt;code&gt;sv_catpvf_mg&lt;/code&gt; 。如果原始SV为UTF-8，则该模式应为有效的UTF-8；否则，此格式应为有效。如果原始SV是字节，则模式也应该是。</target>
        </trans-unit>
        <trans-unit id="d3aea4467da0c26ebde0ed6297ea1903606fe244" translate="yes" xml:space="preserve">
          <source>Processes its arguments like &lt;code&gt;vsprintf&lt;/code&gt; and appends the formatted output to an SV. Does not handle 'set' magic. See &lt;code&gt;sv_vcatpvf_mg&lt;/code&gt; .</source>
          <target state="translated">处理其参数，例如 &lt;code&gt;vsprintf&lt;/code&gt; ，并将格式化的输出附加到SV。不处理&amp;ldquo;定型&amp;rdquo;魔法。参见 &lt;code&gt;sv_vcatpvf_mg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b934966b79098add3be2cc4a61803362f68203fb" translate="yes" xml:space="preserve">
          <source>Processes its arguments like &lt;code&gt;vsprintf&lt;/code&gt; and appends the formatted output to an SV. Uses an array of SVs if the C style variable argument list is missing (NULL). When running with taint checks enabled, indicates via &lt;code&gt;maybe_tainted&lt;/code&gt; if results are untrustworthy (often due to the use of locales).</source>
          <target state="translated">处理其参数，例如 &lt;code&gt;vsprintf&lt;/code&gt; ，并将格式化的输出附加到SV。如果缺少C样式变量参数列表（NULL），则使用SV数组。在启用污点检查的情况下运行时，如果结果不可信（通常是由于使用语言环境），则通过 &lt;code&gt;maybe_tainted&lt;/code&gt; 指示结果。</target>
        </trans-unit>
        <trans-unit id="bb363ec474bd3cedd7705c77914ee3e53e091efe" translate="yes" xml:space="preserve">
          <source>Processes the command-line arguments. Attributes will be set appropriately. Any filenames may be found in the &lt;code&gt;argv&lt;/code&gt; attribute.</source>
          <target state="translated">处理命令行参数。属性将被适当地设置。可以在 &lt;code&gt;argv&lt;/code&gt; 属性中找到任何文件名。</target>
        </trans-unit>
        <trans-unit id="9d23d0424e350de40557cd93a40bb9447e7fcf75" translate="yes" xml:space="preserve">
          <source>Processing Instructions</source>
          <target state="translated">处理说明</target>
        </trans-unit>
        <trans-unit id="a484cb249da1c2816261c338e54ea2ce100a8ffc" translate="yes" xml:space="preserve">
          <source>Processing happens as you knew before. The only difference is that you're now using characters instead of bytes. That's very useful if you use things like &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如您所知，处理过程会发生。唯一的区别是您现在使用的是字符而不是字节。如果您使用诸如 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 之类的东西，那将非常有用。</target>
        </trans-unit>
        <trans-unit id="e35fdd40c3c7fa05c06908e4bbcefbbe3e8decea" translate="yes" xml:space="preserve">
          <source>Processing instructions for the &lt;code&gt;make install&lt;/code&gt; or &lt;code&gt;./Build install&lt;/code&gt; phase of the CPAN mantra. See below under</source>
          <target state="translated">有关CPAN &lt;code&gt;./Build install&lt;/code&gt; 的 &lt;code&gt;make install&lt;/code&gt; 或./Build install阶段的处理说明。见下面</target>
        </trans-unit>
        <trans-unit id="d84fcba7e4f4817ac9bf39f97fede8c0cf9aa1e1" translate="yes" xml:space="preserve">
          <source>Processing instructions for the &lt;code&gt;make test&lt;/code&gt; or &lt;code&gt;./Build test&lt;/code&gt; phase of the CPAN mantra. See below under</source>
          <target state="translated">CPAN口头禅的 &lt;code&gt;make test&lt;/code&gt; 或 &lt;code&gt;./Build test&lt;/code&gt; 阶段的处理说明。见下面</target>
        </trans-unit>
        <trans-unit id="3f32cc81d0fe50f4c815d67016fd04f778345399" translate="yes" xml:space="preserve">
          <source>Processing instructions for the &lt;code&gt;make&lt;/code&gt; or &lt;code&gt;./Build&lt;/code&gt; phase of the CPAN mantra. See below under</source>
          <target state="translated">处理CPAN咒语的 &lt;code&gt;make&lt;/code&gt; 或 &lt;code&gt;./Build&lt;/code&gt; 阶段的指令。见下面</target>
        </trans-unit>
        <trans-unit id="7e35c32fdad63551c269470f250e4811969ec218" translate="yes" xml:space="preserve">
          <source>Processing instructions for the &lt;code&gt;perl Makefile.PL&lt;/code&gt; or &lt;code&gt;perl
Build.PL&lt;/code&gt; phase of the CPAN mantra. See below under</source>
          <target state="translated">CPAN口头禅的 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 或 &lt;code&gt;perl Build.PL&lt;/code&gt; 阶段的处理指令。见下面</target>
        </trans-unit>
        <trans-unit id="982ed577a21afe646e18a3d92db26aa87fed151a" translate="yes" xml:space="preserve">
          <source>Processing of &lt;code&gt;\N{...}&lt;/code&gt; is also done here, and compiled into an intermediate form for the regex compiler. (This is because, as mentioned below, the regex compilation may be done at execution time, and &lt;code&gt;\N{...}&lt;/code&gt; is a compile-time construct.)</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; 处理也在这里完成，并被编译为regex编译器的中间形式。（这是因为，如下所述，正则表达式编译可能在执行时完成，并且 &lt;code&gt;\N{...}&lt;/code&gt; 是编译时构造。）</target>
        </trans-unit>
        <trans-unit id="9701fd573d77167447621582e9abdf1f86b28f3a" translate="yes" xml:space="preserve">
          <source>Processing of &lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; , &lt;code&gt;\E&lt;/code&gt; , and interpolation happens (almost) as with &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; constructs.</source>
          <target state="translated">处理的 &lt;code&gt;\Q&lt;/code&gt; ， &lt;code&gt;\U&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\F&lt;/code&gt; ， &lt;code&gt;\E&lt;/code&gt; ，和内插发生（几乎）与 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; 构建体。</target>
        </trans-unit>
        <trans-unit id="f3b65d43b20d5c0bdaa8f1c4df2161e776bf0d1d" translate="yes" xml:space="preserve">
          <source>Processing of &lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; and interpolation happens as with &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; constructs.</source>
          <target state="translated">处理的 &lt;code&gt;\Q&lt;/code&gt; ， &lt;code&gt;\U&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\F&lt;/code&gt; 和内插发生与 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; 构建体。</target>
        </trans-unit>
        <trans-unit id="249779be2efde8096efc39f80bde3efa59185ef3" translate="yes" xml:space="preserve">
          <source>Processing the results requires an additional if statement to determine whether &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; or &lt;code&gt;$3&lt;/code&gt; and &lt;code&gt;$4&lt;/code&gt; contain the goodies. It would be easier if we could use group numbers 1 and 2 in second alternative as well, and this is exactly what the parenthesized construct &lt;code&gt;(?|...)&lt;/code&gt;, set around an alternative achieves. Here is an extended version of the previous pattern:</source>
          <target state="translated">处理结果需要附加的if语句，以确定 &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 或 &lt;code&gt;$3&lt;/code&gt; 和 &lt;code&gt;$4&lt;/code&gt; 包含物品。如果我们也可以在第二个替代方案中使用组号1和2会更容易，而这正是围绕替代方案设置的带括号构造 &lt;code&gt;(?|...)&lt;/code&gt; 。这是先前模式的扩展版本：</target>
        </trans-unit>
        <trans-unit id="f731f0c07372a44a4d37163f47e58a415c7cf5aa" translate="yes" xml:space="preserve">
          <source>Processors must tolerate an &quot;=over&quot; list that goes off the end of the document (i.e., which has no matching &quot;=back&quot;), but they may warn about such a list.</source>
          <target state="translated">处理器必须容忍一个偏离文档末尾的&quot;=over &quot;列表(即没有匹配的&quot;=back&quot;),但它们可以对这样的列表发出警告。</target>
        </trans-unit>
        <trans-unit id="c9b30fe5cb91e5eed87e9d843db39321e5abdf6e" translate="yes" xml:space="preserve">
          <source>Produce a stack backtrace. See below for details on its output.</source>
          <target state="translated">产生一个堆栈回溯。关于它的输出,请看下文。</target>
        </trans-unit>
        <trans-unit id="1fcd96a29aa9d63a86baddb590cd1dbc2c17f264" translate="yes" xml:space="preserve">
          <source>Produce verbose warning diagnostics</source>
          <target state="translated">产生详细的警告诊断信息</target>
        </trans-unit>
        <trans-unit id="a0d69f82309415639ffb57c2ec15ca60dd4c64a0" translate="yes" xml:space="preserve">
          <source>Produces a fatal error if none of the three system calls (or their close equivalent) exists.</source>
          <target state="translated">如果三个系统调用(或它们的近似物)都不存在,会产生一个致命错误。</target>
        </trans-unit>
        <trans-unit id="960e8fddc698625d55770887235e931f448d8d54" translate="yes" xml:space="preserve">
          <source>Produces:</source>
          <target state="translated">Produces:</target>
        </trans-unit>
        <trans-unit id="d2c5a65aa3f7da56d70c850969cccfb97654f7df" translate="yes" xml:space="preserve">
          <source>Production release currently maintained by demerphq &lt;code&gt;yves at cpan.org&lt;/code&gt; , extensive changes by Michael G. Schwern.</source>
          <target state="translated">demerphq &lt;code&gt;yves at cpan.org&lt;/code&gt; 目前在cpan.org上维护生产版本，Michael G. Schwern进行了大量更改。</target>
        </trans-unit>
        <trans-unit id="1cefe3ad2f8771b28878e24ac772a9d128c62146" translate="yes" xml:space="preserve">
          <source>Production releases, which incorporate bug fixes and new functionality, are widely tested before release. Since the 5.000 release, we have averaged about one production release per year.</source>
          <target state="translated">生产版本包含错误修复和新功能,在发布前进行广泛的测试。自5.000版本以来,我们平均每年发布一个生产版本。</target>
        </trans-unit>
        <trans-unit id="9d68007b0763cb230f9034ec96f52b39d03ad630" translate="yes" xml:space="preserve">
          <source>Program</source>
          <target state="translated">Program</target>
        </trans-unit>
        <trans-unit id="65ccba4e4ffe9da4f39f93b79f123aa04ad91a10" translate="yes" xml:space="preserve">
          <source>Program execution</source>
          <target state="translated">程序执行</target>
        </trans-unit>
        <trans-unit id="79c8be0b38e38e993898785621a849587d1fc42e" translate="yes" xml:space="preserve">
          <source>Program to be used to link libraries for dynamic loading.</source>
          <target state="translated">用于动态加载链接库的程序。</target>
        </trans-unit>
        <trans-unit id="233673261953f1117d42d3b993fa5631e1d0f562" translate="yes" xml:space="preserve">
          <source>Program to use for output of pager-piped commands (those beginning with a &lt;code&gt;|&lt;/code&gt; character.) By default, &lt;code&gt;$ENV{PAGER}&lt;/code&gt; will be used. Because the debugger uses your current terminal characteristics for bold and underlining, if the chosen pager does not pass escape sequences through unchanged, the output of some debugger commands will not be readable when sent through the pager.</source>
          <target state="translated">用于输出寻呼程序命令（以 &lt;code&gt;|&lt;/code&gt; 字符开头的命令）的程序。默认情况下，将使用 &lt;code&gt;$ENV{PAGER}&lt;/code&gt; 。因为调试器将当前的终端特性用于粗体和下划线，所以如果所选的寻呼机没有通过原样传递转义序列，则某些调试器命令的输出在通过寻呼机发送时将无法读取。</target>
        </trans-unit>
        <trans-unit id="40b1cd2c8806121a043ddcb019b6399f2dbb4760" translate="yes" xml:space="preserve">
          <source>Programmatic interface to the Perl debugging API</source>
          <target state="translated">Perl调试API的编程接口</target>
        </trans-unit>
        <trans-unit id="c46a33d512eba5fc7b09e8bb4cc095b44ccd9143" translate="yes" xml:space="preserve">
          <source>Programmer-visible &amp;ldquo;characters&amp;rdquo; are codepoints matched by &lt;code&gt;/./s&lt;/code&gt; , but user-visible &amp;ldquo;characters&amp;rdquo; are graphemes matched by &lt;code&gt;/\X/&lt;/code&gt; .</source>
          <target state="translated">程序员可见的&amp;ldquo;字符&amp;rdquo;是与 &lt;code&gt;/./s&lt;/code&gt; 匹配的代码点，而用户可见的&amp;ldquo;字符&amp;rdquo;是与 &lt;code&gt;/\X/&lt;/code&gt; 匹配的字素。</target>
        </trans-unit>
        <trans-unit id="628a516a46522c1225b06e7fba43671a6cfca7d6" translate="yes" xml:space="preserve">
          <source>Programmers may also query the contained hash structures to find relevant information.</source>
          <target state="translated">程序员也可以查询所包含的哈希结构来查找相关信息。</target>
        </trans-unit>
        <trans-unit id="0532c68f18f669ed265f17fe1e4391db0103bc4d" translate="yes" xml:space="preserve">
          <source>Programming Pearls</source>
          <target state="translated">编程珍珠</target>
        </trans-unit>
        <trans-unit id="6697d919aaf0bdf3780f2bf11d8a61971ea23fa6" translate="yes" xml:space="preserve">
          <source>Programming Perl</source>
          <target state="translated">编写Perl程序</target>
        </trans-unit>
        <trans-unit id="b48776dde59ef3c5ba05ff183db655823f962577" translate="yes" xml:space="preserve">
          <source>Programming Perl, 3rd ed.</source>
          <target state="translated">Programming Perl,3rd ed.</target>
        </trans-unit>
        <trans-unit id="801c545dc4e30e8510acc915d178507c634db27c" translate="yes" xml:space="preserve">
          <source>Programming in which the orderly sequence of events can be determined; that is, when things happen one after the other, not at the same time.</source>
          <target state="translated">在编程中,事件的顺序是可以确定的;也就是说,当事情一个接一个地发生,而不是同时发生。</target>
        </trans-unit>
        <trans-unit id="8d94859a90b2088ddd0d1df7f7d0758ae05c5484" translate="yes" xml:space="preserve">
          <source>Programs derived from other sources sometimes have this. Some people keep a modification log here, but that usually gets long and is normally better maintained in a separate file.</source>
          <target state="translated">从其他来源衍生出来的程序有时也会有这种情况。有些人在这里保存修改日志,但通常会变得很长,通常最好放在一个单独的文件中。</target>
        </trans-unit>
        <trans-unit id="fbc0ca6dae853933487934114343b0d18ee81d17" translate="yes" xml:space="preserve">
          <source>Programs for which the source code is freely available and freely redistributable, with no commercial strings attached. For a more detailed definition, see &lt;a href=&quot;http://www.opensource.org/osd.html&quot;&gt;http://www.opensource.org/osd.html&lt;/a&gt;.</source>
          <target state="translated">源代码可免费获得和自由重新发行的程序，不附带任何商业字符串。有关更详细的定义，请参见&lt;a href=&quot;http://www.opensource.org/osd.html&quot;&gt;http://www.opensource.org/osd.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b00476f569a02ca3539accf5ba044f0d65bcb5e" translate="yes" xml:space="preserve">
          <source>Programs should run just as fast in the new character-oriented mode as in the old byte-oriented mode.</source>
          <target state="translated">在面向字符的新模式下,程序的运行速度应该和面向字节的旧模式一样快。</target>
        </trans-unit>
        <trans-unit id="da96c741b8794039905d8a82d4f548d58f61e17f" translate="yes" xml:space="preserve">
          <source>Programs that can't cope with the fold mapping being multiple code points can use the folding contained in the</source>
          <target state="translated">程序如果不能应对折叠映射为多个代码点的情况,可以使用在</target>
        </trans-unit>
        <trans-unit id="dd0698680d62bac171c8889a2d9e61a094127933" translate="yes" xml:space="preserve">
          <source>Programs that want complete generality and the best folding results should use the folding contained in the</source>
          <target state="translated">程序如果想获得完整的通用性和最佳的折叠效果,应该使用包含在</target>
        </trans-unit>
        <trans-unit id="5c889d397b8b1b4b4fd2bed80c486daeff12e71c" translate="yes" xml:space="preserve">
          <source>Prohibiting substitution</source>
          <target state="translated">禁止替代</target>
        </trans-unit>
        <trans-unit id="9f70a1d8b10f136a2ff15bfca7928b6558a541ba" translate="yes" xml:space="preserve">
          <source>Promote unforeseen warnings to errors with $SIG{__WARN__}.</source>
          <target state="translated">用$SIG{__WARN__}将不可预见的警告提升为错误。</target>
        </trans-unit>
        <trans-unit id="22769fd93d279795e91086b30dc0c80348555910" translate="yes" xml:space="preserve">
          <source>Proof of concept implementation of a trivial CPAN::Plugin</source>
          <target state="translated">一个简单的CPAN::Plugin的概念验证实现。</target>
        </trans-unit>
        <trans-unit id="8cb8e44abb50fda0602cd3141a45b2fa125c05ee" translate="yes" xml:space="preserve">
          <source>PropList.txt</source>
          <target state="translated">PropList.txt</target>
        </trans-unit>
        <trans-unit id="9466ea43fc116acce1e58dfef32cd7abb6fbe461" translate="yes" xml:space="preserve">
          <source>Propagate lvalue (&quot;modifiable&quot;) context to an op and its children.</source>
          <target state="translated">将lvalue(&quot;可修改&quot;)上下文传播给一个op和它的子代。</target>
        </trans-unit>
        <trans-unit id="08aad061d33d2aed46e1bd912c462ebf19ab48de" translate="yes" xml:space="preserve">
          <source>Properties accessible through &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt;</source>
          <target state="translated">可通过 &lt;code&gt;\p{}&lt;/code&gt; 和 &lt;code&gt;\P{}&lt;/code&gt; 访问的属性</target>
        </trans-unit>
        <trans-unit id="30b22d8a6ea2e80a4ede94368e20c898c3306bb2" translate="yes" xml:space="preserve">
          <source>Properties accessible through Unicode::UCD</source>
          <target state="translated">通过Unicode::UCD访问的属性</target>
        </trans-unit>
        <trans-unit id="563bc53aecfd3c93fb7267899dec8bb951315010" translate="yes" xml:space="preserve">
          <source>Properties accessible through \p{} and \P{}</source>
          <target state="translated">可通过 \p{}和 \P{}访问的属性。</target>
        </trans-unit>
        <trans-unit id="504cce65493df0bcf454e1c9d203113ab26835b0" translate="yes" xml:space="preserve">
          <source>Properties accessible through other means</source>
          <target state="translated">通过其他途径进入的财产</target>
        </trans-unit>
        <trans-unit id="5f948ed1aecd13ef6eaaaa7fa03df905621fcdbd" translate="yes" xml:space="preserve">
          <source>Protecting Your Programs</source>
          <target state="translated">保护您的程序</target>
        </trans-unit>
        <trans-unit id="498d5e38147a2aaaadf50f2d1a7ed5f3a11c7285" translate="yes" xml:space="preserve">
          <source>Protocol family constants to use as the first argument to socket() or the value of the &lt;code&gt;SO_DOMAIN&lt;/code&gt; or &lt;code&gt;SO_FAMILY&lt;/code&gt; socket option.</source>
          <target state="translated">协议系列常量，用作socket（）的第一个参数或 &lt;code&gt;SO_DOMAIN&lt;/code&gt; 或 &lt;code&gt;SO_FAMILY&lt;/code&gt; 套接字选项的值。</target>
        </trans-unit>
        <trans-unit id="7c9552582b5fb5655d3fa8a96940f4486707876d" translate="yes" xml:space="preserve">
          <source>Prototype updates by Ilya Zakharevich &amp;lt;ilya@math.ohio-state.edu&amp;gt;.</source>
          <target state="translated">Ilya Zakharevich &amp;lt;ilya@math.ohio-state.edu&amp;gt;更新了原型。</target>
        </trans-unit>
        <trans-unit id="4ae98c95107bca76c978fecb95d46d8d9a2c1e0e" translate="yes" xml:space="preserve">
          <source>Prototypes</source>
          <target state="translated">Prototypes</target>
        </trans-unit>
        <trans-unit id="a5bca78fd1280b75129da9e0607ac0978e22ae46" translate="yes" xml:space="preserve">
          <source>Provide VMS-specific forms of various utility commands.</source>
          <target state="translated">提供各种实用命令的VMS特定形式。</target>
        </trans-unit>
        <trans-unit id="11ddfc9be641270abb6bed328d1f4892d055fe05" translate="yes" xml:space="preserve">
          <source>Provide a README file and perhaps also release notes, changelog, etc</source>
          <target state="translated">提供一个README文件,也许还包括发布说明、变更日志等。</target>
        </trans-unit>
        <trans-unit id="13c79833b637d90171ed134068b1d775c66a45f7" translate="yes" xml:space="preserve">
          <source>Provide a pseudo-class NEXT (et al) that allows method redispatch</source>
          <target state="translated">提供一个允许方法重发的伪类NEXT(等)。</target>
        </trans-unit>
        <trans-unit id="b23333f8402781ffb6c1eec41f9f5179914c01f2" translate="yes" xml:space="preserve">
          <source>Provide a stack trace for the old-interface-signals:</source>
          <target state="translated">提供旧接口信号的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="e4373551d0b44c2890c46fb33fa6da88678677ab" translate="yes" xml:space="preserve">
          <source>Provide a stack trace on the 4 listed signals only:</source>
          <target state="translated">只提供4个所列信号的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="357951aef843b1c6ebb4a03fcd5f58952a57901c" translate="yes" xml:space="preserve">
          <source>Provide additional options to the harness. Currently supported options are:</source>
          <target state="translated">为线束提供额外的选项。目前支持的选项有:</target>
        </trans-unit>
        <trans-unit id="dff17765e8d771354eb6000dda040cf39e225e0f" translate="yes" xml:space="preserve">
          <source>Provide framework for multiple DBMs</source>
          <target state="translated">为多个发展管理制提供框架</target>
        </trans-unit>
        <trans-unit id="f8c6e601144e3f379c359886764519b0dd7488d6" translate="yes" xml:space="preserve">
          <source>Provide hints about user subroutines to autodie</source>
          <target state="translated">提供有关用户子程序的提示,以便自动生成。</target>
        </trans-unit>
        <trans-unit id="8f110f401a8df37e9a6b17075fa908b1c5b601a1" translate="yes" xml:space="preserve">
          <source>Provide informative &quot;file&quot; names for evals based on the place they were compiled.</source>
          <target state="translated">根据评价报告的编制地点,为评价报告提供翔实的 &quot;文件 &quot;名称。</target>
        </trans-unit>
        <trans-unit id="dbcb5bf8bde0c5a5e1b5a3735270b6e1558501e0" translate="yes" xml:space="preserve">
          <source>Provide informative names to anonymous subroutines based on the place they were compiled.</source>
          <target state="translated">根据匿名子程序被编译的地方,为其提供翔实的名称。</target>
        </trans-unit>
        <trans-unit id="eeebb27b46f7caa000dd180f46a3476997c63605" translate="yes" xml:space="preserve">
          <source>Provide links to further information (URL, email)</source>
          <target state="translated">提供更多信息的链接(URL、电子邮件)</target>
        </trans-unit>
        <trans-unit id="6422adf396aa4c7b377814327c5fa3233c9af0ae" translate="yes" xml:space="preserve">
          <source>Provide sensible defaults for parameters which have them. Don't make your users specify parameters which will almost always be the same.</source>
          <target state="translated">为有参数的地方提供合理的默认值。不要让你的用户指定几乎总是相同的参数。</target>
        </trans-unit>
        <trans-unit id="b8f300abee44af01ef8396951c514b4d2e5dbfe3" translate="yes" xml:space="preserve">
          <source>Provided Perl compatibility API</source>
          <target state="translated">提供Perl兼容性API</target>
        </trans-unit>
        <trans-unit id="80413ae92acc6cd45fee5d6371ac186487848ced" translate="yes" xml:space="preserve">
          <source>Provided largely for legacy compatibility; it is better to use pack_sockaddr_in() or unpack_sockaddr_in() explicitly.</source>
          <target state="translated">主要是为了兼容性而提供的;最好使用pack_sockaddr_in()或者显式的unpack_sockaddr_in()。</target>
        </trans-unit>
        <trans-unit id="28474537dd9ef095e20f7aba4d9cb81d5a75457e" translate="yes" xml:space="preserve">
          <source>Provided largely for legacy compatibility; it is better to use pack_sockaddr_in6() or unpack_sockaddr_in6() explicitly.</source>
          <target state="translated">主要是为了兼容性而提供的;最好使用pack_sockaddr_in6()或显式的unpack_sockaddr_in6()。</target>
        </trans-unit>
        <trans-unit id="a36d81826ac81063ca4463eca25402a6693e2b57" translate="yes" xml:space="preserve">
          <source>Provided largely for legacy compatibility; it is better to use pack_sockaddr_un() or unpack_sockaddr_un() explicitly.</source>
          <target state="translated">主要是为了兼容性而提供的;最好使用pack_sockaddr_un()或unpack_sockaddr_un()显式。</target>
        </trans-unit>
        <trans-unit id="fa78e658e64b448bedadd11512ada22bdc0e284b" translate="yes" xml:space="preserve">
          <source>Provided to allow layers to be implemented as Perl code. For instance:</source>
          <target state="translated">提供的目的是为了让层可以作为Perl代码来实现。例如:</target>
        </trans-unit>
        <trans-unit id="15bdc25568e36d006e240cf708f9dce3924f6040" translate="yes" xml:space="preserve">
          <source>Provided your C compiler supports a 64-bit type (e.g. the</source>
          <target state="translated">如果你的C编译器支持64位类型(如</target>
        </trans-unit>
        <trans-unit id="2b11a762a21c8fca08fe84cc3ba7706515215ff7" translate="yes" xml:space="preserve">
          <source>Provided your perl binary was properly configured and installed the &lt;b&gt;ExtUtils::Embed&lt;/b&gt; module will determine all of this information for you:</source>
          <target state="translated">只要正确配置并安装了perl二进制文件，&lt;b&gt;ExtUtils :: Embed&lt;/b&gt;模块将为您确定所有这些信息：</target>
        </trans-unit>
        <trans-unit id="6aee749769ccf0e73f6beb56206ed3f3745da69e" translate="yes" xml:space="preserve">
          <source>Provides a simple framework for writing test scripts</source>
          <target state="translated">为编写测试脚本提供了一个简单的框架</target>
        </trans-unit>
        <trans-unit id="88cd665ef61e5f37b953f8e99c4f4c7c9c545e56" translate="yes" xml:space="preserve">
          <source>Provides a sub-set of the &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; functionality, with the restriction that it is only legal to seek forward in the input file/buffer. It is a fatal error to attempt to seek backward.</source>
          <target state="translated">提供 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 功能的子集，但限制是只能合法地在输入文件/缓冲区中向前搜索。试图向后寻找是致命的错误。</target>
        </trans-unit>
        <trans-unit id="4380abd5e4f9b57c3d1c735d510c8da067ef3b73" translate="yes" xml:space="preserve">
          <source>Provides a sub-set of the &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; functionality, with the restriction that it is only legal to seek forward in the output file/buffer. It is a fatal error to attempt to seek backward.</source>
          <target state="translated">提供 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 功能的子集，但限制是仅在输出文件/缓冲区中向前搜索是合法的。试图向后寻找是致命的错误。</target>
        </trans-unit>
        <trans-unit id="043ad5ef72622e45c304f2c63f38a03738205bb4" translate="yes" xml:space="preserve">
          <source>Provides a sub-set of the &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; functionality, with the restriction that it is only legal to seek forward in the compressed file. It is a fatal error to attempt to seek backward.</source>
          <target state="translated">提供 &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 功能的子集，但限制是仅在压缩文件中向前搜索是合法的。试图向后寻找是致命的错误。</target>
        </trans-unit>
        <trans-unit id="7dd4c64d07073a45696ea9342f023290999ed811" translate="yes" xml:space="preserve">
          <source>Provides a visual display of the standard variant sequences derived from</source>
          <target state="translated">提供了一个可视化的标准变异序列显示,这些变异序列来自于</target>
        </trans-unit>
        <trans-unit id="c52a45815f69df31bfe7c57d00e96b5e68e005cc" translate="yes" xml:space="preserve">
          <source>Provides screen dump of Perl data.</source>
          <target state="translated">提供Perl数据的屏幕转储。</target>
        </trans-unit>
        <trans-unit id="a3777f0013122f0c4a4655ba003bcc967ea9bd1b" translate="yes" xml:space="preserve">
          <source>Provides support for big integer calculations. Not intended to be used by other modules. Other modules which sport the same functions can also be used to support Math::BigInt, like &lt;a href=&quot;http://search.cpan.org/perldoc/Math::BigInt::GMP&quot;&gt;Math::BigInt::GMP&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Math::BigInt::Pari&quot;&gt;Math::BigInt::Pari&lt;/a&gt;.</source>
          <target state="translated">提供对大整数计算的支持。不打算由其他模块使用。具有相同功能的其他模块也可以用于支持Math :: BigInt，例如&lt;a href=&quot;http://search.cpan.org/perldoc/Math::BigInt::GMP&quot;&gt;Math :: BigInt :: GMP&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/perldoc/Math::BigInt::Pari&quot;&gt;Math :: BigInt :: Pari&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="10d70d52199eba6651636a68b4318d214564b47d" translate="yes" xml:space="preserve">
          <source>Provides support for reading data from and writing data to a scalar.</source>
          <target state="translated">提供从标量读取数据和向标量写入数据的支持。</target>
        </trans-unit>
        <trans-unit id="35d3d844e1643f59d23a9592a79adf75a0687a37" translate="yes" xml:space="preserve">
          <source>Provides system-specific clean up of the C runtime environment after running Perl interpreters. This should be called only once, after freeing any remaining Perl interpreters.</source>
          <target state="translated">在运行Perl解释器后,提供系统特有的C运行时环境清理。在释放所有剩余的Perl解释器后,只需调用一次。</target>
        </trans-unit>
        <trans-unit id="5c08e94d1f190f7ace300b8f19617a3c5d31718f" translate="yes" xml:space="preserve">
          <source>Provides system-specific tune up of the C runtime environment necessary to run Perl interpreters. This should be called only once, before creating any Perl interpreters.</source>
          <target state="translated">提供运行 Perl 解释器所需的 C 运行时环境的系统特定调整。在创建任何Perl解释器之前,应只调用一次。</target>
        </trans-unit>
        <trans-unit id="621a00134095fc7f69dd6022503e0657d531ae39" translate="yes" xml:space="preserve">
          <source>Providing the appearance of something without the reality, as in: virtual memory is not real memory. (See also &lt;b&gt;memory&lt;/b&gt;.) The opposite of &amp;ldquo;virtual&amp;rdquo; is &amp;ldquo;transparent&amp;rdquo;, which means providing the reality of something without the appearance, as in: Perl handles the variable-length UTF‑8 character encoding transparently.</source>
          <target state="translated">提供某种没有真实感的外观，例如：虚拟内存不是真实内存。（另请参见&lt;b&gt;内存&lt;/b&gt;。）&amp;ldquo;虚拟&amp;rdquo;的相反之处是&amp;ldquo;透明&amp;rdquo;，这意味着提供某种外观而没有外观的真实性，例如：Perl透明地处理可变长度UTF-8字符编码。</target>
        </trans-unit>
        <trans-unit id="e29e8eedc748840bd27ace9f3607818fa75df015" translate="yes" xml:space="preserve">
          <source>Provisional</source>
          <target state="translated">Provisional</target>
        </trans-unit>
        <trans-unit id="bc57f5706c94c8332625d86e374b5ec8162923ac" translate="yes" xml:space="preserve">
          <source>Provisional; for the analysis and processing of Indic scripts</source>
          <target state="translated">暂定;用于分析和处理印地语文字。</target>
        </trans-unit>
        <trans-unit id="e08767fd1764632990c98ee793a2eb53548be64a" translate="yes" xml:space="preserve">
          <source>Pseudo-hashes</source>
          <target state="translated">Pseudo-hashes</target>
        </trans-unit>
        <trans-unit id="5b10b4e8c62202591bb27bc4c07957f535a6a8c5" translate="yes" xml:space="preserve">
          <source>Pseudo-hashes have been removed from Perl. The 'fields' pragma remains available.</source>
          <target state="translated">伪哈希值已经从 Perl 中删除。字段 &quot;pragma 仍然可以使用。</target>
        </trans-unit>
        <trans-unit id="3044e0ef5b4b41d6c53eefa4f2f2b746e10e10f9" translate="yes" xml:space="preserve">
          <source>Pseudo-hashes: Using an array as a hash</source>
          <target state="translated">伪哈希值。将数组用作散列</target>
        </trans-unit>
        <trans-unit id="bc550b2f7a34ff5e6976a425dc29a862aa93c5f1" translate="yes" xml:space="preserve">
          <source>Pstruct takes any .c or .h files, or preferably .s ones, since that's the format it is going to massage them into anyway, and spits out listings like this:</source>
          <target state="translated">Pstruct接收任何.c或.h文件,或者最好是.s文件,因为无论如何,它都要把它们按摩成这种格式,然后吐出这样的列表。</target>
        </trans-unit>
        <trans-unit id="297bc9763378ddef289f2b0d755586fb4440c94e" translate="yes" xml:space="preserve">
          <source>Pstruct was not a pretty program. Neither was it particularly robust. The problem, you see, was that the C compiler was much better at parsing C than I could ever hope to be.</source>
          <target state="translated">Pstruct不是一个漂亮的程序。它也不是特别健壮。问题是,你看,C编译器在解析C语言方面比我想象的要好得多。</target>
        </trans-unit>
        <trans-unit id="c53eebf11a10d6cf8de1f1717ec349118f7310f1" translate="yes" xml:space="preserve">
          <source>Pthread internal error: message: __libc_reinit() failed, file: ../pthreads/pthread.c, line: 1096 Return Pointer is 0xc082bf33 sh: 5345 Quit(coredump)</source>
          <target state="translated">Pthread内部错误:消息。__libc_reinit()失败,文件:./pthreads/pthread.c,行:1096 返回指针为0xc082bf33 sh:5345 Quit(coredump)</target>
        </trans-unit>
        <trans-unit id="83fd9d90135feee7f6a996aca0791b4d44033ddd" translate="yes" xml:space="preserve">
          <source>Public Functions</source>
          <target state="translated">公共职能</target>
        </trans-unit>
        <trans-unit id="400be4997716cf3bb5a0c05bf961e2a62c95f6c8" translate="yes" xml:space="preserve">
          <source>Public Methods</source>
          <target state="translated">公共方法</target>
        </trans-unit>
        <trans-unit id="6c3aa2b9e37ccd79b46e58ea5b46718457c77761" translate="yes" xml:space="preserve">
          <source>Public Review Issue #29: Normalization Issue</source>
          <target state="translated">公众点评第29期:规范化问题</target>
        </trans-unit>
        <trans-unit id="8d618bb63d8316f9a89333b5c763467803474bba" translate="yes" xml:space="preserve">
          <source>Pugs</source>
          <target state="translated">Pugs</target>
        </trans-unit>
        <trans-unit id="e95b650ab6696c2fae8a07318611a14e120c748e" translate="yes" xml:space="preserve">
          <source>Pure Perl module to support Math::BigInt</source>
          <target state="translated">支持 Math::BigInt 的纯 Perl 模块。</target>
        </trans-unit>
        <trans-unit id="6bedf193383dd829c1a7e1f3c25ac475a95dbc9b" translate="yes" xml:space="preserve">
          <source>Pure Perl version of &lt;code&gt;Data::Dumper&lt;/code&gt; escapes UTF-8 strings correctly only in Perl 5.8.0 and later.</source>
          <target state="translated">纯Perl版本的 &lt;code&gt;Data::Dumper&lt;/code&gt; 仅在Perl 5.8.0和更高版本中正确转义UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="fb4b5bba5c487f415ed0f1e943d54e4cec7304aa" translate="yes" xml:space="preserve">
          <source>Pure pure (that is non xs) modules may be installed via the usual:</source>
          <target state="translated">纯纯的(即非xs)模块可以通过通常的安装。</target>
        </trans-unit>
        <trans-unit id="de3bd83a8b87c6fcf37efea53d47a13ade370276" translate="yes" xml:space="preserve">
          <source>Purify</source>
          <target state="translated">Purify</target>
        </trans-unit>
        <trans-unit id="1adbca3a8c94f365ba3311017ca9fb85bf4ec06c" translate="yes" xml:space="preserve">
          <source>Push a double onto the stack, extending the stack if necessary. Does not use &lt;code&gt;TARG&lt;/code&gt; . See also &lt;code&gt;XPUSHn&lt;/code&gt; , &lt;code&gt;mPUSHn&lt;/code&gt; and &lt;code&gt;PUSHn&lt;/code&gt; .</source>
          <target state="translated">将双按推入堆栈，如有必要，将其扩展。不使用 &lt;code&gt;TARG&lt;/code&gt; 。另请参见 &lt;code&gt;XPUSHn&lt;/code&gt; ， &lt;code&gt;mPUSHn&lt;/code&gt; 和 &lt;code&gt;PUSHn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c66f0f44c90e343c00fbe4997ddc560482746d7f" translate="yes" xml:space="preserve">
          <source>Push a double onto the stack, extending the stack if necessary. Handles 'set' magic. Uses &lt;code&gt;TARG&lt;/code&gt; , so &lt;code&gt;dTARGET&lt;/code&gt; or &lt;code&gt;dXSTARG&lt;/code&gt; should be called to declare it. Do not call multiple &lt;code&gt;TARG&lt;/code&gt; -oriented macros to return lists from XSUB's - see &lt;code&gt;mXPUSHn&lt;/code&gt; instead. See also &lt;code&gt;PUSHn&lt;/code&gt; and &lt;code&gt;mPUSHn&lt;/code&gt; .</source>
          <target state="translated">将双按推入堆栈，如有必要，将其扩展。处理&amp;ldquo;设置&amp;rdquo;魔术。使用 &lt;code&gt;TARG&lt;/code&gt; ，因此应调用 &lt;code&gt;dTARGET&lt;/code&gt; 或 &lt;code&gt;dXSTARG&lt;/code&gt; 进行声明。不要调用多个 &lt;code&gt;TARG&lt;/code&gt; 的宏以从XSUB的列表中返回列表-请参见 &lt;code&gt;mXPUSHn&lt;/code&gt; 。另请参见 &lt;code&gt;PUSHn&lt;/code&gt; 和 &lt;code&gt;mPUSHn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70310d23516f418652dd8578becd2ec048a6f62f" translate="yes" xml:space="preserve">
          <source>Push a double onto the stack. The stack must have room for this element. Does not use &lt;code&gt;TARG&lt;/code&gt; . See also &lt;code&gt;PUSHn&lt;/code&gt; , &lt;code&gt;mXPUSHn&lt;/code&gt; and &lt;code&gt;XPUSHn&lt;/code&gt; .</source>
          <target state="translated">将双倍数推入堆栈。堆栈必须为该元素留出空间。不使用 &lt;code&gt;TARG&lt;/code&gt; 。另请参见 &lt;code&gt;PUSHn&lt;/code&gt; ， &lt;code&gt;mXPUSHn&lt;/code&gt; 和 &lt;code&gt;XPUSHn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a09819d533d2a6cde93684c673c40239b2327313" translate="yes" xml:space="preserve">
          <source>Push a double onto the stack. The stack must have room for this element. Handles 'set' magic. Uses &lt;code&gt;TARG&lt;/code&gt; , so &lt;code&gt;dTARGET&lt;/code&gt; or &lt;code&gt;dXSTARG&lt;/code&gt; should be called to declare it. Do not call multiple &lt;code&gt;TARG&lt;/code&gt; -oriented macros to return lists from XSUB's - see &lt;code&gt;mPUSHn&lt;/code&gt; instead. See also &lt;code&gt;XPUSHn&lt;/code&gt; and &lt;code&gt;mXPUSHn&lt;/code&gt; .</source>
          <target state="translated">将双倍数推入堆栈。堆栈必须为该元素留出空间。处理&amp;ldquo;设置&amp;rdquo;魔术。使用 &lt;code&gt;TARG&lt;/code&gt; ，因此应调用 &lt;code&gt;dTARGET&lt;/code&gt; 或 &lt;code&gt;dXSTARG&lt;/code&gt; 进行声明。不要调用多个 &lt;code&gt;TARG&lt;/code&gt; 的宏以从XSUB的列表中返回列表-请参见 &lt;code&gt;mPUSHn&lt;/code&gt; 。另请参见 &lt;code&gt;XPUSHn&lt;/code&gt; 和 &lt;code&gt;mXPUSHn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37fbc41e170c8928cc728474cf6c2366e3a91513" translate="yes" xml:space="preserve">
          <source>Push a new mortal SV onto the stack, extending the stack if necessary. Does not use &lt;code&gt;TARG&lt;/code&gt; . See also &lt;code&gt;XPUSHs&lt;/code&gt; , &lt;code&gt;PUSHmortal&lt;/code&gt; and &lt;code&gt;PUSHs&lt;/code&gt; .</source>
          <target state="translated">将新的凡人SV推入堆栈，并在必要时扩展堆栈。不使用 &lt;code&gt;TARG&lt;/code&gt; 。另请参阅 &lt;code&gt;XPUSHs&lt;/code&gt; ， &lt;code&gt;PUSHmortal&lt;/code&gt; 和 &lt;code&gt;PUSHs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="050fa706767d321890b953c04c19df5b05aa9b43" translate="yes" xml:space="preserve">
          <source>Push a new mortal SV onto the stack. The stack must have room for this element. Does not use &lt;code&gt;TARG&lt;/code&gt; . See also &lt;code&gt;PUSHs&lt;/code&gt; , &lt;code&gt;XPUSHmortal&lt;/code&gt; and &lt;code&gt;XPUSHs&lt;/code&gt; .</source>
          <target state="translated">将新的凡人SV推入堆栈。堆栈必须为该元素留出空间。不使用 &lt;code&gt;TARG&lt;/code&gt; 。另请参见 &lt;code&gt;PUSHs&lt;/code&gt; ， &lt;code&gt;XPUSHmortal&lt;/code&gt; 和 &lt;code&gt;XPUSHs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffd0047000871af3772812f84a32456a428054a8" translate="yes" xml:space="preserve">
          <source>Push a new pad frame onto the padlist, unless there's already a pad at this depth, in which case don't bother creating a new one. Then give the new pad an @_ in slot zero.</source>
          <target state="translated">将一个新的垫框推到垫表上,除非在这个深度已经有一个垫子了,在这种情况下,不用再去创建一个新的垫子。然后在槽位0给新的垫子一个@_。</target>
        </trans-unit>
        <trans-unit id="ba2a34165de5563eaeb2cd603b049d4c74e59fde" translate="yes" xml:space="preserve">
          <source>Push a string onto the stack, extending the stack if necessary. The &lt;code&gt;len&lt;/code&gt; indicates the length of the string. Does not use &lt;code&gt;TARG&lt;/code&gt; . See also &lt;code&gt;XPUSHp&lt;/code&gt; , &lt;code&gt;mPUSHp&lt;/code&gt; and &lt;code&gt;PUSHp&lt;/code&gt; .</source>
          <target state="translated">将字符串推到堆栈上，如有必要，扩展堆栈。该 &lt;code&gt;len&lt;/code&gt; 指示字符串的长度。不使用 &lt;code&gt;TARG&lt;/code&gt; 。另请参阅 &lt;code&gt;XPUSHp&lt;/code&gt; ， &lt;code&gt;mPUSHp&lt;/code&gt; 和 &lt;code&gt;PUSHp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b05cc48550c5f11f3753078b47d3c48fd30b5aa4" translate="yes" xml:space="preserve">
          <source>Push a string onto the stack, extending the stack if necessary. The &lt;code&gt;len&lt;/code&gt; indicates the length of the string. Handles 'set' magic. Uses &lt;code&gt;TARG&lt;/code&gt; , so &lt;code&gt;dTARGET&lt;/code&gt; or &lt;code&gt;dXSTARG&lt;/code&gt; should be called to declare it. Do not call multiple &lt;code&gt;TARG&lt;/code&gt; -oriented macros to return lists from XSUB's - see &lt;code&gt;mXPUSHp&lt;/code&gt; instead. See also &lt;code&gt;PUSHp&lt;/code&gt; and &lt;code&gt;mPUSHp&lt;/code&gt; .</source>
          <target state="translated">将字符串推到堆栈上，如有必要，扩展堆栈。该 &lt;code&gt;len&lt;/code&gt; 指示字符串的长度。处理&amp;ldquo;设置&amp;rdquo;魔术。使用 &lt;code&gt;TARG&lt;/code&gt; ，因此应调用 &lt;code&gt;dTARGET&lt;/code&gt; 或 &lt;code&gt;dXSTARG&lt;/code&gt; 进行声明。不要调用多个 &lt;code&gt;TARG&lt;/code&gt; 的宏以从XSUB的列表中返回列表-请参阅 &lt;code&gt;mXPUSHp&lt;/code&gt; 。另请参见 &lt;code&gt;PUSHp&lt;/code&gt; 和 &lt;code&gt;mPUSHp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69992c35cddb150767687fecee3a99bf322b8aa1" translate="yes" xml:space="preserve">
          <source>Push a string onto the stack. The stack must have room for this element. The &lt;code&gt;len&lt;/code&gt; indicates the length of the string. Does not use &lt;code&gt;TARG&lt;/code&gt; . See also &lt;code&gt;PUSHp&lt;/code&gt; , &lt;code&gt;mXPUSHp&lt;/code&gt; and &lt;code&gt;XPUSHp&lt;/code&gt; .</source>
          <target state="translated">将字符串推入堆栈。堆栈必须为该元素留出空间。该 &lt;code&gt;len&lt;/code&gt; 指示字符串的长度。不使用 &lt;code&gt;TARG&lt;/code&gt; 。另请参见 &lt;code&gt;PUSHp&lt;/code&gt; ， &lt;code&gt;mXPUSHp&lt;/code&gt; 和 &lt;code&gt;XPUSHp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9a911ea70d9342831bb5853b21493e821263e9f" translate="yes" xml:space="preserve">
          <source>Push a string onto the stack. The stack must have room for this element. The &lt;code&gt;len&lt;/code&gt; indicates the length of the string. Handles 'set' magic. Uses &lt;code&gt;TARG&lt;/code&gt; , so &lt;code&gt;dTARGET&lt;/code&gt; or &lt;code&gt;dXSTARG&lt;/code&gt; should be called to declare it. Do not call multiple &lt;code&gt;TARG&lt;/code&gt; -oriented macros to return lists from XSUB's - see &lt;code&gt;mPUSHp&lt;/code&gt; instead. See also &lt;code&gt;XPUSHp&lt;/code&gt; and &lt;code&gt;mXPUSHp&lt;/code&gt; .</source>
          <target state="translated">将字符串推入堆栈。堆栈必须为该元素留出空间。该 &lt;code&gt;len&lt;/code&gt; 指示字符串的长度。处理&amp;ldquo;设置&amp;rdquo;魔术。使用 &lt;code&gt;TARG&lt;/code&gt; ，因此应调用 &lt;code&gt;dTARGET&lt;/code&gt; 或 &lt;code&gt;dXSTARG&lt;/code&gt; 进行声明。不要调用多个 &lt;code&gt;TARG&lt;/code&gt; 的宏以从XSUB的列表中返回列表-请参见 &lt;code&gt;mPUSHp&lt;/code&gt; 。另请参阅 &lt;code&gt;XPUSHp&lt;/code&gt; 和 &lt;code&gt;mXPUSHp&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
