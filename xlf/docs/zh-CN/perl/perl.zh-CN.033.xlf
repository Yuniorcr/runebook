<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="ade1d38216915151ba7db0ce62f3199d7bf8e743" translate="yes" xml:space="preserve">
          <source>F:/bin</source>
          <target state="translated">F:/bin</target>
        </trans-unit>
        <trans-unit id="16a6231368962f338e8f37dfc91ca30753938154" translate="yes" xml:space="preserve">
          <source>FACET FIELDS</source>
          <target state="translated">面膜领域</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="3f8b9d0d8f1563ce34d8f76abc9faf53ac55bb32" translate="yes" xml:space="preserve">
          <source>FAQs, tricks and tips for &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker的&lt;/a&gt;常见问题，技巧和窍门。</target>
        </trans-unit>
        <trans-unit id="65569c995a4785c8ee0ddac72f9a5d5496ad6056" translate="yes" xml:space="preserve">
          <source>FAQs, tricks and tips for &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 常见问题，技巧和提示。</target>
        </trans-unit>
        <trans-unit id="dec5a3344b6b1da0ebe322bd0a2dfc8eb4528955" translate="yes" xml:space="preserve">
          <source>FATAL errors will cause the program to halt (&lt;code&gt;croak&lt;/code&gt; ), since the problem is so severe that it would be dangerous to continue. (This can always be trapped with &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but it's not a good idea. Under the circumstances, dying is the best thing to do).</source>
          <target state="translated">致命错误将导致程序停止运行（ &lt;code&gt;croak&lt;/code&gt; ），因为问题非常严重，以至于继续存在危险。（这总是被 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 所困，但这不是一个好主意。在这种情况下，最好死去）。</target>
        </trans-unit>
        <trans-unit id="6b6f2d1eafcc9e88114df946d6ac19bc0f376a0c" translate="yes" xml:space="preserve">
          <source>FATAL errors will cause the program to halt (&lt;code&gt;croak&lt;/code&gt;), since the problem is so severe that it would be dangerous to continue. (This can always be trapped with &lt;code&gt;eval&lt;/code&gt;, but it's not a good idea. Under the circumstances, dying is the best thing to do).</source>
          <target state="translated">致命错误将导致程序停止运行（ &lt;code&gt;croak&lt;/code&gt; ），因为问题非常严重，以至于继续存在危险。（这总是被 &lt;code&gt;eval&lt;/code&gt; 所困，但这不是一个好主意。在这种情况下，最好死去）。</target>
        </trans-unit>
        <trans-unit id="69754788a4c6beb4ec0ff140aa5c158dca3bfa2a" translate="yes" xml:space="preserve">
          <source>FB_CROAK</source>
          <target state="translated">FB_CROAK</target>
        </trans-unit>
        <trans-unit id="b626cf33b4a041c5ce4d521b41bf3a7b58bd485d" translate="yes" xml:space="preserve">
          <source>FB_DEFAULT</source>
          <target state="translated">FB_DEFAULT</target>
        </trans-unit>
        <trans-unit id="757934dd26eb29cb3152a5f387ec3d2edb168405" translate="yes" xml:space="preserve">
          <source>FB_PERLQQ FB_HTMLCREF FB_XMLCREF</source>
          <target state="translated">FB_PERLQQ FB_HTMLCREF FB_XMLCREF</target>
        </trans-unit>
        <trans-unit id="0a74cbd8c5cb0982de1a9bcfa6850e000455346d" translate="yes" xml:space="preserve">
          <source>FB_QUIET</source>
          <target state="translated">FB_QUIET</target>
        </trans-unit>
        <trans-unit id="0dd7f31fe0e5f67c669f4440fb273121e4c806e4" translate="yes" xml:space="preserve">
          <source>FB_WARN</source>
          <target state="translated">FB_WARN</target>
        </trans-unit>
        <trans-unit id="8e8b3f3bb48e9f1566f046dd9abec5d58654f4a5" translate="yes" xml:space="preserve">
          <source>FCNTL</source>
          <target state="translated">FCNTL</target>
        </trans-unit>
        <trans-unit id="47dadeeeb2bc9f5421eaa6bbbe50810a393d4c66" translate="yes" xml:space="preserve">
          <source>FEATURE BUNDLES</source>
          <target state="translated">功能包</target>
        </trans-unit>
        <trans-unit id="ec8e87c2f7d4da8aaca114d6270ea98cb522428f" translate="yes" xml:space="preserve">
          <source>FEATURES = less-&amp;gt;of()</source>
          <target state="translated">特征= less-&amp;gt; of（）</target>
        </trans-unit>
        <trans-unit id="489edc9160737f1f5321c8439e0d90f85d95108c" translate="yes" xml:space="preserve">
          <source>FEEDBACK</source>
          <target state="translated">FEEDBACK</target>
        </trans-unit>
        <trans-unit id="a721f50a7a690a4a15e9a37c997197a6892fe7c1" translate="yes" xml:space="preserve">
          <source>FETCH</source>
          <target state="translated">FETCH</target>
        </trans-unit>
        <trans-unit id="a36834b47beb7b8fa9cc177881caffbc9273b059" translate="yes" xml:space="preserve">
          <source>FETCH this</source>
          <target state="translated">FETCH this</target>
        </trans-unit>
        <trans-unit id="c2b96ae35c4cdaf0d5015e044df05ffbf062155e" translate="yes" xml:space="preserve">
          <source>FETCH this, index</source>
          <target state="translated">FETCH this,index</target>
        </trans-unit>
        <trans-unit id="0f0417b5bc981c089adeff175d8d240c193a1c5f" translate="yes" xml:space="preserve">
          <source>FETCH this, key</source>
          <target state="translated">FETCH this,key</target>
        </trans-unit>
        <trans-unit id="c895bf1dc50f257bb516434bac2edbda6ee48875" translate="yes" xml:space="preserve">
          <source>FETCHSIZE and STORESIZE are used to provide &lt;code&gt;$#array&lt;/code&gt; and equivalent &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; access.</source>
          <target state="translated">FETCHSIZE和STORESIZE用于提供 &lt;code&gt;$#array&lt;/code&gt; 和等效的 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; 访问。</target>
        </trans-unit>
        <trans-unit id="9a55d444e2f42ff3332a7b20892e03b42c0dde45" translate="yes" xml:space="preserve">
          <source>FETCHSIZE and STORESIZE are used to provide &lt;code&gt;$#array&lt;/code&gt; and equivalent &lt;code&gt;scalar(@array)&lt;/code&gt; access.</source>
          <target state="translated">FETCHSIZE和STORESIZE用于提供 &lt;code&gt;$#array&lt;/code&gt; 和等效的 &lt;code&gt;scalar(@array)&lt;/code&gt; 访问。</target>
        </trans-unit>
        <trans-unit id="655cf3f775d1131bb1cd13d50dcc9384058c7e74" translate="yes" xml:space="preserve">
          <source>FETCHSIZE returned a negative value</source>
          <target state="translated">FETCHSIZE返回负值</target>
        </trans-unit>
        <trans-unit id="ffdae04b785f3e9a65f525eb253a77d31047f28b" translate="yes" xml:space="preserve">
          <source>FETCHSIZE this</source>
          <target state="translated">FETCHSIZE this</target>
        </trans-unit>
        <trans-unit id="845bc45b1b1e5326c244df2ee7648f3ddd776170" translate="yes" xml:space="preserve">
          <source>FETCH_</source>
          <target state="translated">FETCH_</target>
        </trans-unit>
        <trans-unit id="05cf9a52ee9997400d322323b2f4f5f087799c04" translate="yes" xml:space="preserve">
          <source>FIELDS</source>
          <target state="translated">FIELDS</target>
        </trans-unit>
        <trans-unit id="07c257b16606b468b4287bbfd069963fcb6c04a5" translate="yes" xml:space="preserve">
          <source>FIFO</source>
          <target state="translated">FIFO</target>
        </trans-unit>
        <trans-unit id="3f799155fde6a8df0e53471e8ebc22e51aee5205" translate="yes" xml:space="preserve">
          <source>FIFO (named pipe).</source>
          <target state="translated">FIFO(命名管)。</target>
        </trans-unit>
        <trans-unit id="b4915d3a7ef82abdf96f2b5042452a69b2ea344c" translate="yes" xml:space="preserve">
          <source>FILE</source>
          <target state="translated">FILE</target>
        </trans-unit>
        <trans-unit id="188699dbc4f938b6c1d493b9b4e73beaae160b4d" translate="yes" xml:space="preserve">
          <source>FILE may contain Unicode characters outside the system codepage. Once the file has been created you can use Win32::GetANSIPathName() to get a name that can be passed to system calls and external programs.</source>
          <target state="translated">FILE可能包含系统代码页之外的Unicode字符。一旦文件被创建,你就可以使用Win32::GetANSIPathName()来获得一个可以传递给系统调用和外部程序的名称。</target>
        </trans-unit>
        <trans-unit id="1037b28078b931a2bcf7381d1504e913f7749ea4" translate="yes" xml:space="preserve">
          <source>FILEGV</source>
          <target state="translated">FILEGV</target>
        </trans-unit>
        <trans-unit id="65f4de99dee3e085c7a32fb60bb9eaf5617a70cd" translate="yes" xml:space="preserve">
          <source>FILEHANDLE may be an expression whose value can be used as an indirect filehandle, usually the real filehandle name or an autovivified handle.</source>
          <target state="translated">FILEHANDLE可以是一个表达式,它的值可以作为一个间接的filehandle,通常是真实的filehandle名称或一个自动转换的句柄。</target>
        </trans-unit>
        <trans-unit id="eb6788548cba81bf001baaa9f81e8e517a13289b" translate="yes" xml:space="preserve">
          <source>FILEHANDLE may be an expression whose value gives the name of the actual filehandle. Thus:</source>
          <target state="translated">FILEHANDLE可以是一个表达式,其值给出了实际的文件柄的名称。因此:</target>
        </trans-unit>
        <trans-unit id="9fb4f1d17ef878fbfbe96076658397ad86bd5264" translate="yes" xml:space="preserve">
          <source>FILES</source>
          <target state="translated">FILES</target>
        </trans-unit>
        <trans-unit id="57b2849536a1efa1f62fdf190cadb1a10c11e6b6" translate="yes" xml:space="preserve">
          <source>FILL</source>
          <target state="translated">FILL</target>
        </trans-unit>
        <trans-unit id="9632a4abb88bdcc736407e7934b81d79fbb78781" translate="yes" xml:space="preserve">
          <source>FINDING YOUR WAY AROUND</source>
          <target state="translated">找到自己的方向</target>
        </trans-unit>
        <trans-unit id="059c8321d5ceafe9f97e631f972d839dbaf5b1d5" translate="yes" xml:space="preserve">
          <source>FIONREAD requires a filehandle connected to a stream, meaning that sockets, pipes, and tty devices work, but</source>
          <target state="translated">FIONREAD需要一个连接到流的文件柄,这意味着套接字、管道和ty设备都可以工作,但</target>
        </trans-unit>
        <trans-unit id="f1c14024d456e253b8073d3a89752d6ea8200326" translate="yes" xml:space="preserve">
          <source>FIRSTKEY and NEXTKEY methods go through the keys which were already read, not all the possible keys of the hash.</source>
          <target state="translated">FIRSTKEY和NEXTKEY方法通过已经读取的键,而不是哈希的所有可能的键。</target>
        </trans-unit>
        <trans-unit id="473f2fe7fb87993b779c2cc268a4bc8822c0f618" translate="yes" xml:space="preserve">
          <source>FIRSTKEY is always called in scalar context and it should just return the first key. values(), and each() in list context, will call FETCH for the returned keys.</source>
          <target state="translated">values(),以及list上下文中的every(),会对返回的键调用FETCH。</target>
        </trans-unit>
        <trans-unit id="60763b7739ea9775822fa821fd5c68448c0e057f" translate="yes" xml:space="preserve">
          <source>FIRSTKEY this</source>
          <target state="translated">FIRSTKEY this</target>
        </trans-unit>
        <trans-unit id="e93a0a6500fe82ad7af1d937eb87befdc270cb77" translate="yes" xml:space="preserve">
          <source>FIRST_MAKEFILE</source>
          <target state="translated">FIRST_MAKEFILE</target>
        </trans-unit>
        <trans-unit id="df2badbb417734bff12c2cd1ce6852a857e8b49b" translate="yes" xml:space="preserve">
          <source>FLAG VALUES</source>
          <target state="translated">旗帜值</target>
        </trans-unit>
        <trans-unit id="ae5c9fb3c111122e22c6f658c74f989e6c74e9ee" translate="yes" xml:space="preserve">
          <source>FLAGS</source>
          <target state="translated">FLAGS</target>
        </trans-unit>
        <trans-unit id="fc54423d9b2090ad55b78aa71f44bd7d687a3b90" translate="yes" xml:space="preserve">
          <source>FLAGS FOR JSON::PP ONLY</source>
          <target state="translated">仅针对JSON::PP的标志。</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="73449ef74937cb8a715e6e9b0bcd4bb4e19f070f" translate="yes" xml:space="preserve">
          <source>FLOATING-POINT ENVIRONMENT</source>
          <target state="translated">浮动点环境</target>
        </trans-unit>
        <trans-unit id="f41751eb3ffc92663591f0374ca80b48bbc39b5b" translate="yes" xml:space="preserve">
          <source>FMTEYEWTK</source>
          <target state="translated">FMTEYEWTK</target>
        </trans-unit>
        <trans-unit id="831a66be6f43bd545fdc4414e1f4b885b9c05bb7" translate="yes" xml:space="preserve">
          <source>FMT_GV</source>
          <target state="translated">FMT_GV</target>
        </trans-unit>
        <trans-unit id="15135a59c6851b66ea7afd388b7d51c193aa382b" translate="yes" xml:space="preserve">
          <source>FMT_NAME</source>
          <target state="translated">FMT_NAME</target>
        </trans-unit>
        <trans-unit id="5ebe3bdc53012abb0f99fe6d21ef451db1b6f344" translate="yes" xml:space="preserve">
          <source>FOO()</source>
          <target state="translated">FOO()</target>
        </trans-unit>
        <trans-unit id="29f93d09c4164c56d0a4360f7af9f4da5d683665" translate="yes" xml:space="preserve">
          <source>FOOTNOTES</source>
          <target state="translated">FOOTNOTES</target>
        </trans-unit>
        <trans-unit id="a27448e44064a3e71d47db864ec6590331ae24db" translate="yes" xml:space="preserve">
          <source>FOR MODULE AUTHORS</source>
          <target state="translated">针对模块作者</target>
        </trans-unit>
        <trans-unit id="49b71cfc6dbaeaf2d7271b35e698bcb55b689647" translate="yes" xml:space="preserve">
          <source>FORM</source>
          <target state="translated">FORM</target>
        </trans-unit>
        <trans-unit id="3f6103eba0b588dc2c4ca41ac7c6811788d10af9" translate="yes" xml:space="preserve">
          <source>FORMAT</source>
          <target state="translated">FORMAT</target>
        </trans-unit>
        <trans-unit id="197bc57f95ecd67e69c42b441c686af9b56b66a3" translate="yes" xml:space="preserve">
          <source>FORMAT CONTROL ATTRIBUTES</source>
          <target state="translated">格式控制属性</target>
        </trans-unit>
        <trans-unit id="8c6077236f8ea6885b307ca6cfaf9346871ddc06" translate="yes" xml:space="preserve">
          <source>FORMAT is the</source>
          <target state="translated">FORMAT是指</target>
        </trans-unit>
        <trans-unit id="9ca6f46e23cb251edb9f7e2a3f8e64a09e982c8e" translate="yes" xml:space="preserve">
          <source>FORMAT is the &lt;a href=&quot;http://man.he.net/man3/printf&quot;&gt;printf(3)&lt;/a&gt;-style format specifier (without the leading '%') to use to print the times. It defaults to '5.2f'.</source>
          <target state="translated">FORMAT是用于打印时间的&lt;a href=&quot;http://man.he.net/man3/printf&quot;&gt;printf（3）&lt;/a&gt;风格的格式说明符（不带前导'％'）。默认为&amp;ldquo; 5.2f&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ec5814e0479ce0db049db2be1669d632fac6aa3f" translate="yes" xml:space="preserve">
          <source>FORMATTERS</source>
          <target state="translated">FORMATTERS</target>
        </trans-unit>
        <trans-unit id="d660f8cca36ec17fdb320607d854df06b0b01126" translate="yes" xml:space="preserve">
          <source>FORMATTING SPECIFICATIONS</source>
          <target state="translated">格式规格</target>
        </trans-unit>
        <trans-unit id="4b1e81e861fd516f97ae14bf47f22c76798cec81" translate="yes" xml:space="preserve">
          <source>FORTRAN print control.</source>
          <target state="translated">FORTRAN打印控制。</target>
        </trans-unit>
        <trans-unit id="d8b9930b588cfbff9ca8c2607a532bbe28f9a623" translate="yes" xml:space="preserve">
          <source>FORWARD COMPATIBILITY</source>
          <target state="translated">前向兼容性</target>
        </trans-unit>
        <trans-unit id="cca2a0e16b252e41df41d698b7943121b4ce66e8" translate="yes" xml:space="preserve">
          <source>FREETMPS</source>
          <target state="translated">FREETMPS</target>
        </trans-unit>
        <trans-unit id="ac03725b51e3b18352fbcf923063a48e12b26314" translate="yes" xml:space="preserve">
          <source>FREQUENTLY ASKED QUESTIONS</source>
          <target state="translated">常见问题解答</target>
        </trans-unit>
        <trans-unit id="6496f6c84e390b28e94f50597c1286993f14328b" translate="yes" xml:space="preserve">
          <source>FROM THE COMMAND LINE</source>
          <target state="translated">来自命令行</target>
        </trans-unit>
        <trans-unit id="8872dc813208d15328cb72820a6753a9ddec0776" translate="yes" xml:space="preserve">
          <source>FTP Archives for Perl Modules:</source>
          <target state="translated">Perl模块的FTP档案。</target>
        </trans-unit>
        <trans-unit id="13add5d8be99c7156e522d0830855d1224598c3d" translate="yes" xml:space="preserve">
          <source>FTP Client class</source>
          <target state="translated">FTP客户端类</target>
        </trans-unit>
        <trans-unit id="99c6dd16cd765c469c507fe9b03fc9fa2810bf50" translate="yes" xml:space="preserve">
          <source>FTP Client data connection class</source>
          <target state="translated">FTP客户端数据连接类</target>
        </trans-unit>
        <trans-unit id="d6fc2619f665877d169e9fca0155476e2dbf2fb4" translate="yes" xml:space="preserve">
          <source>FTP servers can work in passive or active mode. Active mode is when you want to transfer data you have to tell the server the address and port to connect to. Passive mode is when the server provide the address and port and you establish the connection.</source>
          <target state="translated">FTP服务器可以在被动或主动模式下工作。主动模式是当你想传输数据时,你必须告诉服务器连接的地址和端口。被动模式是指服务器提供地址和端口,你再建立连接。</target>
        </trans-unit>
        <trans-unit id="36c1fe86d5964c4e743e91fc8cc4caa0733fb438" translate="yes" xml:space="preserve">
          <source>FTP servers usually listen on the same port number, port 21, as any other FTP server. But there is no reason why this has to be the case.</source>
          <target state="translated">FTP服务器通常和其他FTP服务器一样,使用相同的端口号,即21号端口进行监听。但没有理由一定要这样。</target>
        </trans-unit>
        <trans-unit id="d4fa87de490d6c1ca8c48ecbbdf1e0921be54835" translate="yes" xml:space="preserve">
          <source>FTP stands for File Transfer Protocol. It is a way of transferring files between networked machines. The protocol defines a client (whose commands are provided by this module) and a server (not implemented in this module). Communication is always initiated by the client, and the server responds with a message and a status code (and sometimes with data).</source>
          <target state="translated">FTP是文件传输协议的缩写。它是网络机器之间传输文件的一种方式。该协议定义了一个客户端(其命令由本模块提供)和一个服务器(本模块没有实现)。通信总是由客户机发起的,服务器以消息和状态码(有时是数据)来响应。</target>
        </trans-unit>
        <trans-unit id="22cfaa805c4996e790b0842ae141ee601b2ec3b2" translate="yes" xml:space="preserve">
          <source>FULLPERL</source>
          <target state="translated">FULLPERL</target>
        </trans-unit>
        <trans-unit id="96bdd2a0e835c50d5a37670cae3294bb4a92551d" translate="yes" xml:space="preserve">
          <source>FULLPERLRUN</source>
          <target state="translated">FULLPERLRUN</target>
        </trans-unit>
        <trans-unit id="4175d73a603036c7ec596dfc807dbe11477db143" translate="yes" xml:space="preserve">
          <source>FULLPERLRUNINST</source>
          <target state="translated">FULLPERLRUNINST</target>
        </trans-unit>
        <trans-unit id="64aa9da551140f123645f6df265bdb9a6b198111" translate="yes" xml:space="preserve">
          <source>FUNCLIST</source>
          <target state="translated">FUNCLIST</target>
        </trans-unit>
        <trans-unit id="63425456f14a800f08b688a005e2e85f84241751" translate="yes" xml:space="preserve">
          <source>FUNCTION</source>
          <target state="translated">FUNCTION</target>
        </trans-unit>
        <trans-unit id="f8bdd6d62e62677a02e5dc952820aa27e8b6384e" translate="yes" xml:space="preserve">
          <source>FUNCTION DIFFERENCES</source>
          <target state="translated">功能差异</target>
        </trans-unit>
        <trans-unit id="9633f16041f6cad3a579e87f0baed24ec359c5c9" translate="yes" xml:space="preserve">
          <source>FUNCTION IMPLEMENTATIONS</source>
          <target state="translated">功能实施</target>
        </trans-unit>
        <trans-unit id="a54261bf699a2c75d951095758dc3d3d9845baef" translate="yes" xml:space="preserve">
          <source>FUNCTION SPECIFIC NOTES</source>
          <target state="translated">功能规格说明</target>
        </trans-unit>
        <trans-unit id="7524394489df18e23f74e891bd713b273f05b69b" translate="yes" xml:space="preserve">
          <source>FUNCTIONAL INTERFACE</source>
          <target state="translated">功能性接口</target>
        </trans-unit>
        <trans-unit id="e0639bb5342fee4e8d445f26b3a0278cc2fe4679" translate="yes" xml:space="preserve">
          <source>FUNCTIONS</source>
          <target state="translated">FUNCTIONS</target>
        </trans-unit>
        <trans-unit id="256018c65b4eb744f4377a13a19d91631c659dd4" translate="yes" xml:space="preserve">
          <source>FUNCTIONS API</source>
          <target state="translated">功能API</target>
        </trans-unit>
        <trans-unit id="a8b599c6c2d22b5945b690bad2739bb459f033f6" translate="yes" xml:space="preserve">
          <source>FUNCTIONS FOR REFERENCES</source>
          <target state="translated">参考文献的功能</target>
        </trans-unit>
        <trans-unit id="546e2c9a8685e17aa5c5cf752632f067b0b1ac92" translate="yes" xml:space="preserve">
          <source>FURTHER READING</source>
          <target state="translated">进一步的阅读</target>
        </trans-unit>
        <trans-unit id="78d5c48c1c95da4e4d7cfa29209f1e02bb56ed08" translate="yes" xml:space="preserve">
          <source>Facet for assertion amnesty.</source>
          <target state="translated">断言特赦的面。</target>
        </trans-unit>
        <trans-unit id="b2a8373446df3ec05bd53275eaae62cc9a0b479e" translate="yes" xml:space="preserve">
          <source>Facet for errors that need to be shown.</source>
          <target state="translated">需要显示错误的面。</target>
        </trans-unit>
        <trans-unit id="1c1d180871daee0cdbe4502f47ae51bbd4bb7509" translate="yes" xml:space="preserve">
          <source>Facet for events contains other events</source>
          <target state="translated">事件的Facet包含其他事件</target>
        </trans-unit>
        <trans-unit id="70ea596fd77110f489e26ed692733bea3f136f34" translate="yes" xml:space="preserve">
          <source>Facet for hub actions and behaviors.</source>
          <target state="translated">枢纽行动和行为的面。</target>
        </trans-unit>
        <trans-unit id="8324754e4bbbb6888e22aff420189d7b50e4e121" translate="yes" xml:space="preserve">
          <source>Facet for information a developer might care about.</source>
          <target state="translated">开发者可能关心的信息面。</target>
        </trans-unit>
        <trans-unit id="83bfc95bb8ef012dee5214e2e8cc7a7e2fbd4d47" translate="yes" xml:space="preserve">
          <source>Facet for meta-data</source>
          <target state="translated">元数据面</target>
        </trans-unit>
        <trans-unit id="d8f415e842705d2158785c07b8927d1f8a027365" translate="yes" xml:space="preserve">
          <source>Facet for setting the plan</source>
          <target state="translated">制定计划的方面</target>
        </trans-unit>
        <trans-unit id="58384918ecc4e085ca881ebf031c51a056d62901" translate="yes" xml:space="preserve">
          <source>Facet for the hubs an event passes through.</source>
          <target state="translated">一个事件所经过的枢纽的面。</target>
        </trans-unit>
        <trans-unit id="378b6d9594f99674003363daa56d4fa9a71b1ed2" translate="yes" xml:space="preserve">
          <source>Facet representing an assertion.</source>
          <target state="translated">代表一个论断的面。</target>
        </trans-unit>
        <trans-unit id="fda3a9c60d8ab31ff000b4864eefdcc4c00171ff" translate="yes" xml:space="preserve">
          <source>Facet that dictates how to render an event.</source>
          <target state="translated">决定如何渲染事件的面。</target>
        </trans-unit>
        <trans-unit id="a7b0db876f6c994e9f1b7e9e8a9af8dc92aba61e" translate="yes" xml:space="preserve">
          <source>Facet with event details.</source>
          <target state="translated">面与活动细节。</target>
        </trans-unit>
        <trans-unit id="e1548e5421220de5c1180140cf1e5a982f5e3c0c" translate="yes" xml:space="preserve">
          <source>Facets are how events convey their purpose to the Test2 internals and formatters. An event without facets will have no intentional effect on the overall test state, and will not be displayed at all by most formatters, except perhaps to say that an event of an unknown type was seen.</source>
          <target state="translated">Facets是事件如何向Test2内部和formatters传达它们的目的。一个没有面的事件不会对整个测试状态产生任何有意的影响,而且大多数格式化程序根本不会显示,除了可能说看到了一个未知类型的事件。</target>
        </trans-unit>
        <trans-unit id="fe9935e956d4ac9064df2633764e8fb19e4ae925" translate="yes" xml:space="preserve">
          <source>Facets are produced by the &lt;code&gt;facet_data()&lt;/code&gt; subroutine, which you should nearly-always override. &lt;code&gt;facet_data()&lt;/code&gt; is expected to return a hashref where each key is the facet type, and the value is either a hashref with the data for that facet, or an array of hashrefs. Some facets must be defined as single hashrefs, some must be defined as an array of hashrefs, No facets allow both.</source>
          <target state="translated">&lt;code&gt;facet_data()&lt;/code&gt; 面是由facet_data（）子例程生成的，您应该始终对其进行重写。 &lt;code&gt;facet_data()&lt;/code&gt; 应该返回一个hashref，其中每个键都是facet类型，并且值可以是具有该facet数据的hashref或hashref数组。必须将某些构面定义为单个hashref，将某些构面定义为hashref数组，任何构面都不允许。</target>
        </trans-unit>
        <trans-unit id="8aab1b0862ad45abd6672f0567f6c68cf09c136e" translate="yes" xml:space="preserve">
          <source>Facilitate processing an opened filehandle of a compressed archive</source>
          <target state="translated">便于处理已打开的压缩档案的文件柄。</target>
        </trans-unit>
        <trans-unit id="9d0a833e883c67f6559509334a96f848be9e54ed" translate="yes" xml:space="preserve">
          <source>Facilities</source>
          <target state="translated">Facilities</target>
        </trans-unit>
        <trans-unit id="0b8af03a8ba1e4c01fa3396b94568da207e2f7a3" translate="yes" xml:space="preserve">
          <source>Factory for creating TAP::Parser output objects</source>
          <target state="translated">用于创建TAP::Parser输出对象的工厂。</target>
        </trans-unit>
        <trans-unit id="579d7f5c997d76bab3032c2c355897f70853da24" translate="yes" xml:space="preserve">
          <source>Failed tests</source>
          <target state="translated">测试失败</target>
        </trans-unit>
        <trans-unit id="efe0353ca36e091772af60ca71316fe70ddeac9e" translate="yes" xml:space="preserve">
          <source>Failed to close in-place work file %s: %s</source>
          <target state="translated">关闭原地工作文件%s失败:%s。</target>
        </trans-unit>
        <trans-unit id="194bab90ff2f1dcc5e2c4e85ff7e0a9857bb0252" translate="yes" xml:space="preserve">
          <source>Failing tests</source>
          <target state="translated">测试不合格</target>
        </trans-unit>
        <trans-unit id="607919027b2a9b94755ff24dee0db004455fddf6" translate="yes" xml:space="preserve">
          <source>Failover to different communication modes by Nick Williams &amp;lt;</source>
          <target state="translated">故障转移到尼克&amp;middot;威廉姆斯（Nick Williams）的不同通信模式&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c563018d20418391a3a741571c4b388d5e704fb2" translate="yes" xml:space="preserve">
          <source>Fails if the Perl DLL found via &lt;code&gt;BEGINLIBPATH&lt;/code&gt; is different from what was loaded on step 1; e.g., another process could have loaded it from &lt;code&gt;LIBPATH&lt;/code&gt; or from a different value of &lt;code&gt;BEGINLIBPATH&lt;/code&gt; . In these cases one needs to modify the setting of the system so that this other process either does not run, or loads the DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; with &lt;code&gt;LIBPATHSTRICT=T&lt;/code&gt; (available with kernels after September 2000).</source>
          <target state="translated">如果通过 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 找到的Perl DLL 与在步骤1上加载的不同，则失败。例如，另一个进程可能已经从 &lt;code&gt;LIBPATH&lt;/code&gt; 或从 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 的另一个值加载了它。在这种情况下一个需要修改系统的设置，使得这一过程中的其他不运行或者，或负载从DLL &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 与 &lt;code&gt;LIBPATHSTRICT=T&lt;/code&gt; （可仁2000年9月后）。</target>
        </trans-unit>
        <trans-unit id="b6865060f0c3e431fc8e58dc7dfb075d96c65977" translate="yes" xml:space="preserve">
          <source>Fails if the Perl DLL found via &lt;code&gt;BEGINLIBPATH&lt;/code&gt; is different from what was loaded on step 1; e.g., another process could have loaded it from &lt;code&gt;LIBPATH&lt;/code&gt; or from a different value of &lt;code&gt;BEGINLIBPATH&lt;/code&gt;. In these cases one needs to modify the setting of the system so that this other process either does not run, or loads the DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; with &lt;code&gt;LIBPATHSTRICT=T&lt;/code&gt; (available with kernels after September 2000).</source>
          <target state="translated">如果通过 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 找到的Perl DLL与在步骤1上加载的不同，则失败。例如，另一个进程可能已经从 &lt;code&gt;LIBPATH&lt;/code&gt; 或从 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 的另一个值加载了它。在这种情况下一个需要修改系统的设置，使得这一过程中的其他不运行或者，或负载从DLL &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 与 &lt;code&gt;LIBPATHSTRICT=T&lt;/code&gt; （可仁2000年9月后）。</target>
        </trans-unit>
        <trans-unit id="6c5f423c103a5bffe6de7613de2373184d36088d" translate="yes" xml:space="preserve">
          <source>Fails if the original</source>
          <target state="translated">失败,如果原来的</target>
        </trans-unit>
        <trans-unit id="17027fe6c01c307085e08da87bcd8a7cbddca555" translate="yes" xml:space="preserve">
          <source>Fails if the original UTF-8 sequence cannot be represented in the native 8 bit encoding. On failure dies or, if the value of</source>
          <target state="translated">如果原始的UTF-8序列不能用原生8位编码表示,则失败。失败时死亡,或者,如果</target>
        </trans-unit>
        <trans-unit id="5e10cdcfe2f19c749e60e277e1c9015c94fdd67f" translate="yes" xml:space="preserve">
          <source>Failure of user callbacks dispatched using the &lt;code&gt;G_KEEPERR&lt;/code&gt; flag could also result in this warning. See &lt;a href=&quot;perlcall#G_KEEPERR&quot;&gt;&quot;G_KEEPERR&quot; in perlcall&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;G_KEEPERR&lt;/code&gt; 标志调度的用户回调失败也可能导致此警告。请参见&lt;a href=&quot;perlcall#G_KEEPERR&quot;&gt;perlcall中的&amp;ldquo; G_KEEPERR&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd78511c1283702ad2bb60da575ac2d0ff18ab16" translate="yes" xml:space="preserve">
          <source>Failure of user callbacks dispatched using the &lt;code&gt;G_KEEPERR&lt;/code&gt; flag could also result in this warning. See &lt;a href=&quot;perlcall#G_KEEPERR&quot;&gt;G_KEEPERR in perlcall&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;G_KEEPERR&lt;/code&gt; 标志调度的用户回调失败也可能导致此警告。请参阅&lt;a href=&quot;perlcall#G_KEEPERR&quot;&gt;perlcall中的G_KEEPERR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e175cd49340e07a19035148ceef428c5e5467b03" translate="yes" xml:space="preserve">
          <source>Failure to find a next method will result in an exception being thrown (see below for alternatives).</source>
          <target state="translated">如果找不到下一个方法,将导致一个异常被抛出(参见下面的替代方法)。</target>
        </trans-unit>
        <trans-unit id="331a7d40c82f32a89c55031f2f7712cfb5b3bd07" translate="yes" xml:space="preserve">
          <source>Fairly young with a focus on HTML5 and real-time web technologies such as WebSockets.</source>
          <target state="translated">相当年轻,专注于HTML5和WebSockets等实时网络技术。</target>
        </trans-unit>
        <trans-unit id="b3505bf50d858a8755043974e251138d06ee1ab4" translate="yes" xml:space="preserve">
          <source>Fake on-demand retrieval of outstanding PM messages. If &lt;code&gt;force&lt;/code&gt; is false, will not dispatch messages if a real message loop is known to be present. Returns number of messages retrieved.</source>
          <target state="translated">虚假按需检索未完成的PM消息。如果 &lt;code&gt;force&lt;/code&gt; 为false，则在已知存在真实消息循环的情况下将不会调度消息。返回检索到的消息数。</target>
        </trans-unit>
        <trans-unit id="6b7d9017d82f8622025ae6965855a1db0b5bb68b" translate="yes" xml:space="preserve">
          <source>Fall-through</source>
          <target state="translated">Fall-through</target>
        </trans-unit>
        <trans-unit id="fab000fc839ca496f91ba067964c48702895aed4" translate="yes" xml:space="preserve">
          <source>Fallback Data::Dumper and Storable</source>
          <target state="translated">回溯数据::跳线和可存储的数据</target>
        </trans-unit>
        <trans-unit id="2a4cf3efe7afe1d41140981a0335c8d83aa5d220" translate="yes" xml:space="preserve">
          <source>Fallback F</source>
          <target state="translated">回调F</target>
        </trans-unit>
        <trans-unit id="73f8b4fb3083d20a1f8a2c30b19bc54cad14826c" translate="yes" xml:space="preserve">
          <source>Fallback for &lt;code&gt;decode&lt;/code&gt; must return decoded string (sequence of characters) and takes a list of ordinal values as its arguments. So for example if you wish to decode octets as UTF-8, and use ISO-8859-15 as a fallback for bytes that are not valid UTF-8, you could write</source>
          <target state="translated">&lt;code&gt;decode&lt;/code&gt; 后备必须返回解码后的字符串（字符序列），并以序数值列表作为其参数。因此，例如，如果您希望将八位字节解码为UTF-8，并使用ISO-8859-15作为无效UTF-8字节的后备，则可以编写</target>
        </trans-unit>
        <trans-unit id="a969fb863f8d9f84c7595f93fb9e0917427160e1" translate="yes" xml:space="preserve">
          <source>Fallback for encoding -&amp;gt; unicode. When seen, enc2xs adds this character for the decode map only.</source>
          <target state="translated">备用编码-&amp;gt; unicode。看到时，enc2xs仅将此字符添加到解码映射中。</target>
        </trans-unit>
        <trans-unit id="c7fc9099ef21900d77c14fd9245e820c2f3bcb05" translate="yes" xml:space="preserve">
          <source>Fallback for unicode -&amp;gt; encoding. When seen, enc2xs adds this character for the encode map only.</source>
          <target state="translated">Unicode的后备-&amp;gt;编码。看到时，enc2xs仅将此字符添加到编码映射中。</target>
        </trans-unit>
        <trans-unit id="9c5b502e30e454f9201574751906e3d638bd47ad" translate="yes" xml:space="preserve">
          <source>False [] range &quot;%s&quot; in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正则表达式中错误的[]范围&amp;ldquo;％s&amp;rdquo;；以&amp;lt;-HERE标记，以m /％s /</target>
        </trans-unit>
        <trans-unit id="2d4bc2a882c589e2e3abf29bf34c6abd040f95e8" translate="yes" xml:space="preserve">
          <source>False by default. This will return true on events that should not be displayed by formatters.</source>
          <target state="translated">默认为False。对于不应该由格式化程序显示的事件,该值将返回true。</target>
        </trans-unit>
        <trans-unit id="96cc126519ccb2cce10803355bc133ed10a33eb9" translate="yes" xml:space="preserve">
          <source>Family =&amp;gt; INT</source>
          <target state="translated">家庭=&amp;gt; INT</target>
        </trans-unit>
        <trans-unit id="cc390dbd71040b4339ecd1673e22c52149414722" translate="yes" xml:space="preserve">
          <source>Family-neutral IP socket supporting both IPv4 and IPv6</source>
          <target state="translated">家庭中立的IP插座,同时支持IPv4和IPv6。</target>
        </trans-unit>
        <trans-unit id="b4fab41a1c219c7c774d4d5b99f19bfff38b0e96" translate="yes" xml:space="preserve">
          <source>Fancy term for &lt;b&gt;tokenizing&lt;/b&gt;.</source>
          <target state="translated">花式长期&lt;b&gt;令牌化&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="94700cb17db6026703f0124336c1c74248aa0c67" translate="yes" xml:space="preserve">
          <source>Fancy term for a &lt;b&gt;token&lt;/b&gt;.</source>
          <target state="translated">代&lt;b&gt;币的&lt;/b&gt;花哨期限。</target>
        </trans-unit>
        <trans-unit id="ae38f29ac6b64f59f2ed532d4ca0474fdf64d92e" translate="yes" xml:space="preserve">
          <source>Fancy term for a &lt;b&gt;tokener&lt;/b&gt;.</source>
          <target state="translated">对于看中短期&lt;b&gt;tokener&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="f5c2b89d95eac3e9d7a030078747e18b17f8f9e8" translate="yes" xml:space="preserve">
          <source>Far More Than Everything You Ever Wanted To Know. An exhaustive treatise on one narrow topic, something of a super-&lt;b&gt;FAQ&lt;/b&gt;. See Tom for far more.</source>
          <target state="translated">远远超过您想知道的一切。关于一个狭窄主题的详尽论述，这是一个超级&lt;b&gt;FAQ&lt;/b&gt;。见汤姆更多。</target>
        </trans-unit>
        <trans-unit id="97102c70808de7b8e3d760ebf0b36147b801055a" translate="yes" xml:space="preserve">
          <source>FastCalc works exactly like Calc, in stores the numbers in decimal form, chopped into parts.</source>
          <target state="translated">FastCalc的工作原理与Calc完全相同,它将数字以十进制形式存储,并将其切成若干部分。</target>
        </trans-unit>
        <trans-unit id="915120b00045631c4e8983c0043b1f79dd8a3042" translate="yes" xml:space="preserve">
          <source>Fatal</source>
          <target state="translated">Fatal</target>
        </trans-unit>
        <trans-unit id="b4aa64ef3bff004eb3090e0a608393aba194c2eb" translate="yes" xml:space="preserve">
          <source>Fatal - Replace functions with equivalents which succeed or die</source>
          <target state="translated">Fatal-用成功或死亡的等价物代替函数。</target>
        </trans-unit>
        <trans-unit id="7b51ba1a17fb15f440e9b23d89ba8c4efe01b4e8" translate="yes" xml:space="preserve">
          <source>Fatal VMS error (status=%d) at %s, line %d</source>
          <target state="translated">在%s,行%d处出现致命的VMS错误(status=%d)。</target>
        </trans-unit>
        <trans-unit id="c4d463e2edaea59c2a65ec5996b3a03a5976f772" translate="yes" xml:space="preserve">
          <source>Fatal Warnings</source>
          <target state="translated">致命警告</target>
        </trans-unit>
        <trans-unit id="a4a739fca7ca0c79dbb282ff772c97aebe6957a9" translate="yes" xml:space="preserve">
          <source>Fcntl</source>
          <target state="translated">Fcntl</target>
        </trans-unit>
        <trans-unit id="e79e4cb9771eccd5b0301896c4fb88d90381fa77" translate="yes" xml:space="preserve">
          <source>Fcntl - load the C Fcntl.h defines</source>
          <target state="translated">Fcntl-加载C Fcntl.h的定义。</target>
        </trans-unit>
        <trans-unit id="5ba5c3a5081f69770fe71f342b75f8e639b7ddd9" translate="yes" xml:space="preserve">
          <source>FdGetOsFHandle</source>
          <target state="translated">FdGetOsFHandle</target>
        </trans-unit>
        <trans-unit id="01ed00607d92181e571c2670c20709d97c5c44ac" translate="yes" xml:space="preserve">
          <source>Features a comprehensive coverage of CJKV character sets and encodings along with many other issues faced by anyone trying to better support CJKV languages/scripts in all the areas of information processing.</source>
          <target state="translated">全面涵盖了CJKV字符集和编码,以及任何试图在所有信息处理领域更好地支持CJKV语言/脚本的人所面临的许多其他问题。</target>
        </trans-unit>
        <trans-unit id="229c2035f4aec78ea8439cfaab9ef160e590f22f" translate="yes" xml:space="preserve">
          <source>Features can also be turned off by using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;foo&quot;&lt;/code&gt; . This too has lexical effect.</source>
          <target state="translated">功能也可以通过关闭 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;foo&quot;&lt;/code&gt; 。这也具有词汇作用。</target>
        </trans-unit>
        <trans-unit id="0e379ae6e30b736192025420af358547c6ada5ad" translate="yes" xml:space="preserve">
          <source>Features can also be turned off by using &lt;code&gt;no feature &quot;foo&quot;&lt;/code&gt;. This too has lexical effect.</source>
          <target state="translated">也可以不使用 &lt;code&gt;no feature &quot;foo&quot;&lt;/code&gt; 来关闭功能。这也具有词汇作用。</target>
        </trans-unit>
        <trans-unit id="d03d65a3c6febccc90e9f30f5a749117a92b9dcc" translate="yes" xml:space="preserve">
          <source>February 28, 2013</source>
          <target state="translated">2013年2月28日</target>
        </trans-unit>
        <trans-unit id="23cf501c0a2b5c8f4c1ddd40cb4a07d73b755042" translate="yes" xml:space="preserve">
          <source>February, 2004; by Chia-liang Kao: make cmpthese and timestr use time statistics for children instead of parent when the style is 'nop'.</source>
          <target state="translated">2004年2月;作者:高佳良:当样式为'nop'时,让cmpthese和timestr对子代使用时间统计而不是parent。</target>
        </trans-unit>
        <trans-unit id="1d3095f775b3bd756ca42dc28dbbcb522fa556f5" translate="yes" xml:space="preserve">
          <source>Feel free to add any member data fields you need to keep track of things like current font, indentation, horizontal or vertical position, or whatever else you like. Be sure to read &lt;a href=&quot;#PRIVATE-METHODS-AND-DATA&quot;&gt;PRIVATE METHODS AND DATA&lt;/a&gt; to avoid name collisions.</source>
          <target state="translated">随意添加所需的任何成员数据字段，以跟踪诸如当前字体，缩进，水平或垂直位置或其他所需内容。请务必阅读&amp;ldquo; &lt;a href=&quot;#PRIVATE-METHODS-AND-DATA&quot;&gt;私有方法和数据&amp;rdquo;，&lt;/a&gt;以避免名称冲突。</target>
        </trans-unit>
        <trans-unit id="70cbb102105e81fb1b4636c361737ff2e64d0599" translate="yes" xml:space="preserve">
          <source>Feel free to update the ticket about your bug on &lt;a href=&quot;http://rt.perl.org&quot;&gt;http://rt.perl.org&lt;/a&gt; if a new version of Perl is released and your bug is still present.</source>
          <target state="translated">如果发布了新版本的Perl并且您的错误仍然存​​在，请随时在&lt;a href=&quot;http://rt.perl.org&quot;&gt;http://rt.perl.org&lt;/a&gt;上更新有关您的错误的故障单。</target>
        </trans-unit>
        <trans-unit id="818e0f82dbbed731afa80bbab7b35df92f5cc034" translate="yes" xml:space="preserve">
          <source>Feel free to update the ticket about your bug on &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; if a new version of Perl is released and your bug is still present.</source>
          <target state="translated">如果发布了新版本的Perl并且您的错误仍然存​​在，请随时在&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;上更新有关您的错误的票证。</target>
        </trans-unit>
        <trans-unit id="36b9072d4d9d0784cf29d859c2595c262d17ce85" translate="yes" xml:space="preserve">
          <source>Felipe Gasper &amp;lt;felipe@felipegasper.com&amp;gt;</source>
          <target state="translated">费利佩&amp;middot;加斯珀&amp;lt;felipe@felipegasper.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="fd7064e4dbef9d61b58b480cbcce388f810d38f0" translate="yes" xml:space="preserve">
          <source>Fetch a specified numbered capture. &lt;code&gt;sv&lt;/code&gt; should be set to the scalar to return, the scalar is passed as an argument rather than being returned from the function because when it's called Perl already has a scalar to store the value, creating another one would be redundant. The scalar can be set with &lt;code&gt;sv_setsv&lt;/code&gt; , &lt;code&gt;sv_setpvn&lt;/code&gt; and friends, see &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">获取指定编号的捕获。 &lt;code&gt;sv&lt;/code&gt; 应该设置为要返回的标量，将标量作为参数传递而不是从函数返回，因为调用Perl时已经有一个标量来存储值，因此创建另一个标量将是多余的。可以使用 &lt;code&gt;sv_setsv&lt;/code&gt; ， &lt;code&gt;sv_setpvn&lt;/code&gt; 和好友设置标量，请参见&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48fd141ea5546433e7ee18f3519e592b58062912" translate="yes" xml:space="preserve">
          <source>Fetch a specified numbered capture. &lt;code&gt;sv&lt;/code&gt; should be set to the scalar to return, the scalar is passed as an argument rather than being returned from the function because when it's called Perl already has a scalar to store the value, creating another one would be redundant. The scalar can be set with &lt;code&gt;sv_setsv&lt;/code&gt;, &lt;code&gt;sv_setpvn&lt;/code&gt; and friends, see &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">获取指定编号的捕获。 &lt;code&gt;sv&lt;/code&gt; 应该设置为要返回的标量，将标量作为参数传递而不是从函数中返回，因为调用Perl时已经有一个标量来存储值，因此创建另一个标量将是多余的。可以使用 &lt;code&gt;sv_setsv&lt;/code&gt; ， &lt;code&gt;sv_setpvn&lt;/code&gt; 和好友设置标量，请参见&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fbb89725e8e52167503480d3ef11a278907f1601" translate="yes" xml:space="preserve">
          <source>Fetch an ARexx message from the host port. Returns an objrct of class Amiga::ARexx::Msg</source>
          <target state="translated">从主机端口获取ARexx消息。返回Amiga::ARexx::Msg类的objrct。</target>
        </trans-unit>
        <trans-unit id="361d18ac190751239212937c28a02d801b3fdb96" translate="yes" xml:space="preserve">
          <source>Fetch and install dmake somewhere on your path.</source>
          <target state="translated">在你的路径上获取并安装dmake。</target>
        </trans-unit>
        <trans-unit id="2ef1611403db02cc8268d0f9fa27bf2626bfc429" translate="yes" xml:space="preserve">
          <source>Fetch the value of a constant. Returns &lt;code&gt;undef&lt;/code&gt; if &lt;code&gt;$sConstantName&lt;/code&gt; is not the name of a constant supported by this module. Never sets &lt;code&gt;$!&lt;/code&gt; nor &lt;code&gt;$^E&lt;/code&gt;.</source>
          <target state="translated">获取常量的值。如果 &lt;code&gt;$sConstantName&lt;/code&gt; 不是此模块支持的常量的名称，则返回 &lt;code&gt;undef&lt;/code&gt; 。永远不要设置 &lt;code&gt;$!&lt;/code&gt; 也不 &lt;code&gt;$^E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06725480fea615d084c694cfa90098fe4e3f491f" translate="yes" xml:space="preserve">
          <source>Fetches an entry of the INPUT section of the typemap.</source>
          <target state="translated">获取类型地图INPUT部分的条目。</target>
        </trans-unit>
        <trans-unit id="d4a9ae8436e8d3cd5ef250d912f1bdeb9859c506" translate="yes" xml:space="preserve">
          <source>Fetches an entry of the OUTPUT section of the typemap.</source>
          <target state="translated">获取类型映射的OUTPUT部分的条目。</target>
        </trans-unit>
        <trans-unit id="c736b0f8cda63c68f4e793293e1f7b1c4a83bcc7" translate="yes" xml:space="preserve">
          <source>Fetches an entry of the TYPEMAP section of the typemap.</source>
          <target state="translated">获取类型地图TYPEMAP部分的条目。</target>
        </trans-unit>
        <trans-unit id="804d920af683a75f739608bbcb40c81ec9c0980c" translate="yes" xml:space="preserve">
          <source>Fetches the file you requested and returns the full path to the file.</source>
          <target state="translated">获取你要求的文件,并返回文件的完整路径。</target>
        </trans-unit>
        <trans-unit id="827c97bde84978a3bb98e5034a1b606013a63c45" translate="yes" xml:space="preserve">
          <source>Fetches the pad name from the given index.</source>
          <target state="translated">从给定的索引中获取pad名称。</target>
        </trans-unit>
        <trans-unit id="71f58f8d922f796a2889048895e8dc9ffd8f6c42" translate="yes" xml:space="preserve">
          <source>Fetching network info</source>
          <target state="translated">获取网络信息</target>
        </trans-unit>
        <trans-unit id="96d83d9a37e933efbb23620fd66a3863f0d6f889" translate="yes" xml:space="preserve">
          <source>Fetching user and group info</source>
          <target state="translated">获取用户和组信息</target>
        </trans-unit>
        <trans-unit id="70b0630621dc693a0b82b1ac72066204ea3cb1ff" translate="yes" xml:space="preserve">
          <source>Fiddling with the Perl stack from your C program</source>
          <target state="translated">从你的C程序中摸索Perl堆栈</target>
        </trans-unit>
        <trans-unit id="9ae894619db092857c73b584dce0433ed00f6245" translate="yes" xml:space="preserve">
          <source>Field too wide in 'u' format in pack</source>
          <target state="translated">包中'u'格式的字段太宽。</target>
        </trans-unit>
        <trans-unit id="5264e2b4a8e426bffe920139d4498e83c17f919e" translate="yes" xml:space="preserve">
          <source>FieldHash-based inside-out implementation. Object registry happens automatically. No destructor is needed and objects are thread safe.</source>
          <target state="translated">基于FieldHash的由内而外的实现。对象注册表自动发生。不需要destructor,对象是线程安全的。</target>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="07d174584450454292329995c0541462f26066d7" translate="yes" xml:space="preserve">
          <source>Fields are as follows:</source>
          <target state="translated">领域如下:</target>
        </trans-unit>
        <trans-unit id="5d74e30558c4268af35bc2d593f402b9621c70e4" translate="yes" xml:space="preserve">
          <source>Fields in the &lt;a href=&quot;#STRUCTURE&quot;&gt;&quot;STRUCTURE&quot;&lt;/a&gt; section describe data elements, each of which has an associated data type as described herein. There are four primitive types: Boolean, String, List and Map. Other types are subtypes of primitives and define compound data structures or define constraints on the values of a data element.</source>
          <target state="translated">&lt;a href=&quot;#STRUCTURE&quot;&gt;&amp;ldquo;结构&amp;rdquo;&lt;/a&gt;部分中的字段描述数据元素，每个数据元素都具有此处所述的关联数据类型。有四种原始类型：布尔值，字符串，列表和映射。其他类型是图元的子类型，并定义复合数据结构或定义对数据元素值的约束。</target>
        </trans-unit>
        <trans-unit id="6d320afb6b0630e1ccda485797b8576696531e08" translate="yes" xml:space="preserve">
          <source>Fields that aren't applicable to the particular code point argument exist in the returned hash, and are empty.</source>
          <target state="translated">对特定代码点参数不适用的字段存在于返回的哈希中,为空。</target>
        </trans-unit>
        <trans-unit id="69b39efda9ad6870df874aed2f0bbeddee020a37" translate="yes" xml:space="preserve">
          <source>Fifth:</source>
          <target state="translated">Fifth:</target>
        </trans-unit>
        <trans-unit id="f4f4e020ef73cd3f9c800d7b4c395570858c0611" translate="yes" xml:space="preserve">
          <source>Figures out the current line number in the XS file.</source>
          <target state="translated">计算出XS文件中的当前行号。</target>
        </trans-unit>
        <trans-unit id="659f180bfdb0412ca17466a6655bb668ede0196b" translate="yes" xml:space="preserve">
          <source>Figures out which SourceHandler objects to use for a given Source</source>
          <target state="translated">计算出对给定的Source使用哪个SourceHandler对象。</target>
        </trans-unit>
        <trans-unit id="4b9b547e63da9c5d210106fd0343b71348efc18f" translate="yes" xml:space="preserve">
          <source>Figuring out the hexadecimal sequence of a Unicode character you want or deciphering someone else's hexadecimal Unicode regexp is about as much fun as programming in machine code. So another way to specify Unicode characters is to use the</source>
          <target state="translated">计算出你想要的Unicode字符的十六进制序列,或者破译别人的十六进制Unicode regexp,就像用机器代码编程一样有趣。所以另一种指定Unicode字符的方法是使用</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="00acd6f7be2c3aca96cab1792dd9c533c4fb99b0" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;RPC.pm&lt;/code&gt; : Perl module for the RPC extension.</source>
          <target state="translated">文件 &lt;code&gt;RPC.pm&lt;/code&gt; :RPC扩展的Perl模块。</target>
        </trans-unit>
        <trans-unit id="a012c4fa9de1752d421e1a0c810e66e54c1bc04d" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;RPC.pm&lt;/code&gt;: Perl module for the RPC extension.</source>
          <target state="translated">文件 &lt;code&gt;RPC.pm&lt;/code&gt; :RPC扩展的Perl模块。</target>
        </trans-unit>
        <trans-unit id="2572733e62323918ecd19b3a5f28f1fad3d4a4e6" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;RPC.xs&lt;/code&gt; : Interface to some ONC+ RPC bind library functions.</source>
          <target state="translated">文件 &lt;code&gt;RPC.xs&lt;/code&gt; ：与某些ONC + RPC绑定库函数的接口。</target>
        </trans-unit>
        <trans-unit id="d21d0a1f8e28ac4439c9ff42ce00b69859e99056" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;RPC.xs&lt;/code&gt;: Interface to some ONC+ RPC bind library functions.</source>
          <target state="translated">文件 &lt;code&gt;RPC.xs&lt;/code&gt; ：一些ONC + RPC绑定库函数的接口。</target>
        </trans-unit>
        <trans-unit id="0858ff16b7316b0da87cf27e491f57eeba0e7c11" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;rpctest.pl&lt;/code&gt; : Perl test program for the RPC extension.</source>
          <target state="translated">文件 &lt;code&gt;rpctest.pl&lt;/code&gt; :RPC扩展的Perl测试程序。</target>
        </trans-unit>
        <trans-unit id="b9b9f794d632ec2a1eb3d647f9b9b9ab58436d10" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;rpctest.pl&lt;/code&gt;: Perl test program for the RPC extension.</source>
          <target state="translated">文件 &lt;code&gt;rpctest.pl&lt;/code&gt; :RPC扩展的Perl测试程序。</target>
        </trans-unit>
        <trans-unit id="89663ab01d6a733daa8d8f050b0e4c86205af531" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;typemap&lt;/code&gt; : Custom typemap for RPC.xs. (cf. &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;)</source>
          <target state="translated">文件类型 &lt;code&gt;typemap&lt;/code&gt; ：RPC.xs的自定义类型映射。（请参阅&lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="08279cd069867bec755240f0d6eb568b4f16393a" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;typemap&lt;/code&gt;: Custom typemap for RPC.xs. (cf. &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;)</source>
          <target state="translated">文件类型 &lt;code&gt;typemap&lt;/code&gt; ：RPC.xs的自定义类型映射。（请参阅&lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0d73d8626a39dd86d3fe7032f41a3ecc0c3dd715" translate="yes" xml:space="preserve">
          <source>File Extraction Problems on Solaris.</source>
          <target state="translated">Solaris上的文件提取问题。</target>
        </trans-unit>
        <trans-unit id="ab608d2ad8085ce03268de7bd1b1cc78fcd297d4" translate="yes" xml:space="preserve">
          <source>File Globbing</source>
          <target state="translated">文件大小</target>
        </trans-unit>
        <trans-unit id="94f0aef527a940964fa9d548817f94f5c7e0d938" translate="yes" xml:space="preserve">
          <source>File Handle and Input/Output Stream Utilities</source>
          <target state="translated">文件处理和输入/输出流实用程序</target>
        </trans-unit>
        <trans-unit id="2c21dac263de829a5861211698806d60572e8b18" translate="yes" xml:space="preserve">
          <source>File Input and Output</source>
          <target state="translated">文件输入和输出</target>
        </trans-unit>
        <trans-unit id="ed7b317f92a6f66879f8f8669d4497dbe06ba062" translate="yes" xml:space="preserve">
          <source>File Names, File Systems and File Locking (see also File Handles)</source>
          <target state="translated">文件名、文件系统和文件锁定(另见文件句柄)。</target>
        </trans-unit>
        <trans-unit id="5c1cc1d41d3f3f53b541537cbb16ed14651ac798" translate="yes" xml:space="preserve">
          <source>File Naming Options</source>
          <target state="translated">文件命名选项</target>
        </trans-unit>
        <trans-unit id="a726cab0d7c518573e2f7003375fc21599153b1b" translate="yes" xml:space="preserve">
          <source>File Operations</source>
          <target state="translated">文件操作</target>
        </trans-unit>
        <trans-unit id="7572853d675e9450d66b583e3f295602cd6e9a54" translate="yes" xml:space="preserve">
          <source>File Permissions on Cygwin</source>
          <target state="translated">Cygwin上的文件权限</target>
        </trans-unit>
        <trans-unit id="0f4d62f2c22e44d7f4ed81d343bbd5948187b552" translate="yes" xml:space="preserve">
          <source>File Positioning</source>
          <target state="translated">文件定位</target>
        </trans-unit>
        <trans-unit id="caf0d3d658336bf20ddebae36071045171882da3" translate="yes" xml:space="preserve">
          <source>File attribute constants. Returned by &lt;code&gt;attrLetsToBits&lt;/code&gt; and used in the &lt;code&gt;$uFlags&lt;/code&gt; argument to &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="translated">文件属性常量。由 &lt;code&gt;attrLetsToBits&lt;/code&gt; 返回，并在 &lt;code&gt;CreateFile&lt;/code&gt; 的 &lt;code&gt;$uFlags&lt;/code&gt; 参数中使用。</target>
        </trans-unit>
        <trans-unit id="96516abc6bebff8831916b6857ba16f8d6fdd597" translate="yes" xml:space="preserve">
          <source>File blocksize</source>
          <target state="translated">文件块大小</target>
        </trans-unit>
        <trans-unit id="9e1d825c16be42dcd9eac27ad46d89bd0981bbff" translate="yes" xml:space="preserve">
          <source>File can only be processed in a sequential manner.</source>
          <target state="translated">文件只能按顺序处理。</target>
        </trans-unit>
        <trans-unit id="e2776d2d7b4fdf0cd1f81238e59693ef37962888" translate="yes" xml:space="preserve">
          <source>File characteristic options:</source>
          <target state="translated">文件特性选项。</target>
        </trans-unit>
        <trans-unit id="2a98d820804906c7cbc4a39c07f594d33f47d588" translate="yes" xml:space="preserve">
          <source>File containing the body of the report. Use this to quickly send a prepared message.</source>
          <target state="translated">包含报告正文的文件。用它来快速发送准备好的信息。</target>
        </trans-unit>
        <trans-unit id="5f1051fa7a3f3c8d871c9acc4c30e002dc5cc847" translate="yes" xml:space="preserve">
          <source>File containing the body of the report. Use this to quickly send a prepared report.</source>
          <target state="translated">包含报告正文的文件。用它来快速发送准备好的报告。</target>
        </trans-unit>
        <trans-unit id="1653ca6d1bd7cd87184004c951688277cfc7e58a" translate="yes" xml:space="preserve">
          <source>File has been &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt;ed, or should be deleted on &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文件已被 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt; 编辑，或应在 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 上删除。</target>
        </trans-unit>
        <trans-unit id="e7d76d456ba6834e47b16e8b42081256fccbf9d8" translate="yes" xml:space="preserve">
          <source>File has been &lt;code&gt;unlink()&lt;/code&gt;ed, or should be deleted on &lt;code&gt;close()&lt;/code&gt;.</source>
          <target state="translated">文件已被 &lt;code&gt;unlink()&lt;/code&gt; 编辑，或应在 &lt;code&gt;close()&lt;/code&gt; 上删除。</target>
        </trans-unit>
        <trans-unit id="f5f5f1c8650cee1864991294b341c02bd2c5622a" translate="yes" xml:space="preserve">
          <source>File locking using the &lt;code&gt;F_GETLK&lt;/code&gt; command to &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; is a stub that returns &lt;code&gt;ENOSYS&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;F_GETLK&lt;/code&gt; 命令锁定 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; 的文件是返回 &lt;code&gt;ENOSYS&lt;/code&gt; 的存根。</target>
        </trans-unit>
        <trans-unit id="bf0b815315c825f3269c03242b3b198ccea50919" translate="yes" xml:space="preserve">
          <source>File locking using the &lt;code&gt;F_GETLK&lt;/code&gt; command to &lt;code&gt;fcntl()&lt;/code&gt; is a stub that returns &lt;code&gt;ENOSYS&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;F_GETLK&lt;/code&gt; 命令锁定 &lt;code&gt;fcntl()&lt;/code&gt; 的文件是返回 &lt;code&gt;ENOSYS&lt;/code&gt; 的存根。</target>
        </trans-unit>
        <trans-unit id="dfa00f1ae5815d6eaab80150e5fdb0f9d6b07ccd" translate="yes" xml:space="preserve">
          <source>File names are case insensitive, but case preserving. A pathname that contains a backslash or drive letter is a Win32 pathname, and not subject to the translations applied to POSIX style pathnames, but cygwin will warn you, so better convert them to POSIX.</source>
          <target state="translated">文件名不区分大小写,但保留大小写。包含反斜杠或驱动器字母的路径名是Win32路径名,不需要翻译成POSIX风格的路径名,但cygwin会警告你,所以最好将它们转换为POSIX。</target>
        </trans-unit>
        <trans-unit id="9b9dd24c17d5e17210a1ec27701054547639bdec" translate="yes" xml:space="preserve">
          <source>File names on Mac OS X will at the OS-level be converted to NFD-form. A file created by passing a NFC-filename will come in NFD-form from readdir(). See &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; for details of NFD/NFC.</source>
          <target state="translated">Mac OS X上的文件名将在操作系统级别转换为NFD格式。通过传递NFC文件名创建的文件将从readdir（）以NFD格式出现。有关NFD / NFC的详细信息，请参见&lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d54cd453577fef9dfe80492dac9d8160d18c32b6" translate="yes" xml:space="preserve">
          <source>File option flag constants. Used in the &lt;code&gt;$uFlags&lt;/code&gt; argument to &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="translated">文件选项标志常量。在 &lt;code&gt;CreateFile&lt;/code&gt; 的 &lt;code&gt;$uFlags&lt;/code&gt; 参数中使用。</target>
        </trans-unit>
        <trans-unit id="c5919b0472cf28437e422bab84192d0873dd39a7" translate="yes" xml:space="preserve">
          <source>File or pipe to print line number info to. If it is a pipe (say, &lt;code&gt;|visual_perl_db&lt;/code&gt;), then a short message is used. This is the mechanism used to interact with a slave editor or visual debugger, such as the special &lt;code&gt;vi&lt;/code&gt; or &lt;code&gt;emacs&lt;/code&gt; hooks, or the &lt;code&gt;ddd&lt;/code&gt; graphical debugger.</source>
          <target state="translated">用于打印行号信息的文件或管道。如果它是管道（例如 &lt;code&gt;|visual_perl_db&lt;/code&gt; ），那么将使用一条短消息。这是用于与从属编辑器或可视调试器（例如特殊的 &lt;code&gt;vi&lt;/code&gt; 或 &lt;code&gt;emacs&lt;/code&gt; 挂钩）或 &lt;code&gt;ddd&lt;/code&gt; 图形调试器进行交互的机制。</target>
        </trans-unit>
        <trans-unit id="f440d36d60fd2a51c020f6cb4de72889008d2bd8" translate="yes" xml:space="preserve">
          <source>File paths in a MANIFEST always use Unix conventions (ie. /) even if you're not on Unix.</source>
          <target state="translated">MANIFEST中的文件路径总是使用Unix惯例(即/),即使你不是在Unix上。</target>
        </trans-unit>
        <trans-unit id="7dc956feddc3d2623d44caf49dd0d8e0007cbbed" translate="yes" xml:space="preserve">
          <source>File processing option. Takes one or more of the following (in a comma-separated list if there's more than one)</source>
          <target state="translated">文件处理选项。取以下一个或多个(如果有多个,则用逗号分隔的列表)。</target>
        </trans-unit>
        <trans-unit id="d55fcbf3081365ea2dbdf9c282d44d6f2691df69" translate="yes" xml:space="preserve">
          <source>File record attributes. Takes one of the following:</source>
          <target state="translated">文件记录属性。取以下之一:</target>
        </trans-unit>
        <trans-unit id="8f41398b31aa302780598177a116cea6dc3fa88e" translate="yes" xml:space="preserve">
          <source>File record format. Takes one of the following:</source>
          <target state="translated">文件记录格式。采取下列之一:</target>
        </trans-unit>
        <trans-unit id="10f7a88505dbe3f5824d9ceaa62700ff84c27915" translate="yes" xml:space="preserve">
          <source>File sharing constants. Used in the &lt;code&gt;$uShare&lt;/code&gt; argument to &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="translated">文件共享常量。在 &lt;code&gt;CreateFile&lt;/code&gt; 的 &lt;code&gt;$uShare&lt;/code&gt; 参数中使用。</target>
        </trans-unit>
        <trans-unit id="7f11680d8841bb7f976e1fe18696bfa60b7ed127" translate="yes" xml:space="preserve">
          <source>File sharing options. Choose one of the following:</source>
          <target state="translated">文件共享选项。请选择以下选项之一:</target>
        </trans-unit>
        <trans-unit id="d684db983e8b5220e9565d325f0ae9bbe13b32e7" translate="yes" xml:space="preserve">
          <source>File size in bytes</source>
          <target state="translated">文件大小(单位:字节</target>
        </trans-unit>
        <trans-unit id="c37e8261b4c2e82f199fe5efaafed18a68582d21" translate="yes" xml:space="preserve">
          <source>File specifications</source>
          <target state="translated">文件规格</target>
        </trans-unit>
        <trans-unit id="4007cbed1dac0ce1704758796b77f5a74a2f4ba7" translate="yes" xml:space="preserve">
          <source>File specifications containing wildcards are allowed both on the command line and within Perl globs (e.g. &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; ). If the wildcard filespec uses VMS syntax, the resultant filespecs will follow VMS syntax; if a Unix-style filespec is passed in, Unix-style filespecs will be returned. Similar to the behavior of wildcard globbing for a Unix shell, one can escape command line wildcards with double quotation marks &lt;code&gt;&quot;&lt;/code&gt; around a perl program command line argument. However, owing to the stripping of &lt;code&gt;&quot;&lt;/code&gt; characters carried out by the C handling of argv you will need to escape a construct such as this one (in a directory containing the files</source>
          <target state="translated">在命令行和Perl glob中都允许包含通配符的文件规范（例如 &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; ）。如果通配符文件规范使用VMS语法，则生成的文件规范将遵循VMS语法；否则，文件规范将遵循VMS语法。如果传入Unix样式的文件规范，则将返回Unix样式的文件规范。与Unix shell的通配符通配行为类似，可以在perl程序命令行参数周围使用双引号 &lt;code&gt;&quot;&lt;/code&gt; 转义命令行通配符。但是，由于剥离了由argv的C处理执行的 &lt;code&gt;&quot;&lt;/code&gt; 字符，您将需要转义这种结构（在包含文件的目录中）</target>
        </trans-unit>
        <trans-unit id="b9816c97101d5dbae273f4de135cc76301a683d5" translate="yes" xml:space="preserve">
          <source>File specifications containing wildcards are allowed both on the command line and within Perl globs (e.g. &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt;). If the wildcard filespec uses VMS syntax, the resultant filespecs will follow VMS syntax; if a Unix-style filespec is passed in, Unix-style filespecs will be returned. Similar to the behavior of wildcard globbing for a Unix shell, one can escape command line wildcards with double quotation marks &lt;code&gt;&quot;&lt;/code&gt; around a perl program command line argument. However, owing to the stripping of &lt;code&gt;&quot;&lt;/code&gt; characters carried out by the C handling of argv you will need to escape a construct such as this one (in a directory containing the files</source>
          <target state="translated">在命令行和Perl glob中都允许包含通配符的文件规范（例如 &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; ）。如果通配符filespec使用VMS语法，则生成的文件规范将遵循VMS语法；否则，将遵循VMS语法。如果传入Unix样式的文件规范，则将返回Unix样式的文件规范。与Unix shell的通配符通配行为类似，可以在perl程序命令行参数周围转义带有双引号 &lt;code&gt;&quot;&lt;/code&gt; 命令行通配符。但是，由于剥离了由argv的C处理执行的 &lt;code&gt;&quot;&lt;/code&gt; 字符，您将需要转义这种结构（在包含文件的目录中）</target>
        </trans-unit>
        <trans-unit id="a1068e78c1a68e0282abb193b14dbb089a1a5b4e" translate="yes" xml:space="preserve">
          <source>File system characteristics constants. Placed in the &lt;code&gt;$ouFsFlags&lt;/code&gt; argument to &lt;code&gt;GetVolumeInformation&lt;/code&gt;.</source>
          <target state="translated">文件系统特征常数。放置在 &lt;code&gt;GetVolumeInformation&lt;/code&gt; 的 &lt;code&gt;$ouFsFlags&lt;/code&gt; 参数中。</target>
        </trans-unit>
        <trans-unit id="2125f6818b6fbbdb018675e8c02915ed59c3e1f9" translate="yes" xml:space="preserve">
          <source>File system control operations. Used in the &lt;code&gt;$uIoControlCode&lt;/code&gt; argument to &lt;code&gt;DeviceIoControl&lt;/code&gt;.</source>
          <target state="translated">文件系统控制操作。在 &lt;code&gt;DeviceIoControl&lt;/code&gt; 的 &lt;code&gt;$uIoControlCode&lt;/code&gt; 参数中使用。</target>
        </trans-unit>
        <trans-unit id="f27043a55dfbf95c6c91cec59ce3a34dd5e54519" translate="yes" xml:space="preserve">
          <source>File systems might vary in what encoding is to be used for filenames. Since this module has no way to actually figure out what the is correct it goes with the best guess which is to assume filenames are encoding according to the current locale. Users are advised to always specify UTF-8 as the locale charset.</source>
          <target state="translated">文件系统在文件名的编码上可能会有所不同。因为这个模块没有办法真正找出什么是正确的,所以它采用了最好的猜测,即假设文件名是根据当前的locale编码的。建议用户总是指定UTF-8作为locale charset。</target>
        </trans-unit>
        <trans-unit id="aa8c7530b6eaca2532adfa79d220d7c301f8b86e" translate="yes" xml:space="preserve">
          <source>File tests</source>
          <target state="translated">文件测试</target>
        </trans-unit>
        <trans-unit id="2e67adde1ffcac9182fdc414ea1c59b8537d99ba" translate="yes" xml:space="preserve">
          <source>File to output the results to instead of sending as an email. Useful particularly when running perlbug on a machine with no direct internet connection.</source>
          <target state="translated">将结果输出到文件,而不是以电子邮件的形式发送。特别是在没有直接互联网连接的机器上运行perlbug时,非常有用。</target>
        </trans-unit>
        <trans-unit id="5c4f076ba5b3985d1e9a4302dcb8d52cb294c95e" translate="yes" xml:space="preserve">
          <source>File to output the results to. Defaults to &lt;b&gt;perlbug.rep&lt;/b&gt;.</source>
          <target state="translated">将结果输出到的文件。默认为&lt;b&gt;perlbug.rep&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="8524b9f3585575ad7dfc6698bc36a14994079bf5" translate="yes" xml:space="preserve">
          <source>File to save your history?</source>
          <target state="translated">文件来保存你的历史?</target>
        </trans-unit>
        <trans-unit id="1e509862932466ee82e463191172e37b3cea6512" translate="yes" xml:space="preserve">
          <source>File type -- numeric, but comparable to exported constants -- see Archive::Tar's documentation</source>
          <target state="translated">文件类型 --数值型,但与导出的常量相当 --参见 Archive::Tar 的文档。</target>
        </trans-unit>
        <trans-unit id="0bb575a41b8c42befee7e0cd23f0879559755be1" translate="yes" xml:space="preserve">
          <source>File type constants. Returned by &lt;code&gt;GetFileType&lt;/code&gt;.</source>
          <target state="translated">文件类型常量。由 &lt;code&gt;GetFileType&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="568294b0f0962c9dce2ed86a0644f0e488d0d8e1" translate="yes" xml:space="preserve">
          <source>File/Spec.pm</source>
          <target state="translated">File/Spec.pm</target>
        </trans-unit>
        <trans-unit id="0197048641dc3512ca3dbea2bb733e20d4882d0f" translate="yes" xml:space="preserve">
          <source>File::Basename</source>
          <target state="translated">File::Basename</target>
        </trans-unit>
        <trans-unit id="7643855ad41fd167cd1d19d2fc94a1d9a81f520d" translate="yes" xml:space="preserve">
          <source>File::Basename - Parse file paths into directory, filename and suffix.</source>
          <target state="translated">File::Basename-将文件路径解析为目录、文件名和后缀。</target>
        </trans-unit>
        <trans-unit id="a8d61a1262a25e3e4a3b5f743fafe0ce5ae8780f" translate="yes" xml:space="preserve">
          <source>File::Compare</source>
          <target state="translated">File::Compare</target>
        </trans-unit>
        <trans-unit id="d243fbac9648f0d6978bc733f70a7d07c623feba" translate="yes" xml:space="preserve">
          <source>File::Compare - Compare files or filehandles</source>
          <target state="translated">File::Compare-比较文件或文件柄。</target>
        </trans-unit>
        <trans-unit id="fb8db5002f44755b6149a0ab982916a8075daf8b" translate="yes" xml:space="preserve">
          <source>File::Compare was written by Nick Ing-Simmons. Its original documentation was written by Chip Salzenberg.</source>
          <target state="translated">File::比较是由Nick Ing-Simmons编写的。它的原始文档是由Chip Salzenberg编写的。</target>
        </trans-unit>
        <trans-unit id="e84e49c86f519c366047d4a68a91823d7167c285" translate="yes" xml:space="preserve">
          <source>File::Compare::cmp is a synonym for File::Compare::compare. It is exported from File::Compare only by request.</source>
          <target state="translated">File::Compare::cmp 是 File::Compare::compare 的同义词。它只能通过请求从File::Compare导出。</target>
        </trans-unit>
        <trans-unit id="cced95c8b6209ce495a6cd5c577674c5e6e53b3a" translate="yes" xml:space="preserve">
          <source>File::Compare::compare and its sibling functions return 0 if the files are equal, 1 if the files are unequal, or -1 if an error was encountered.</source>
          <target state="translated">File::Compare::compare和它的同级函数如果文件相等则返回0,如果文件不相等则返回1,如果遇到错误则返回-1。</target>
        </trans-unit>
        <trans-unit id="def94ece5481d3beb5558118d685c1a96647aecc" translate="yes" xml:space="preserve">
          <source>File::Compare::compare_text does a line by line comparison of the two files. It stops as soon as a difference is detected. compare_text() accepts an optional third argument: This must be a CODE reference to a line comparison function, which returns 0 when both lines are considered equal. For example:</source>
          <target state="translated">File::Compare::compare_text 对两个文件进行逐行比较。compare_text()接受一个可选的第三个参数。这个参数必须是一个行比较函数的CODE引用,当两行都被认为是相等的时候,它就返回0。例如</target>
        </trans-unit>
        <trans-unit id="bc3cb79c7383464148f9e6e9b35dc66828ee89ef" translate="yes" xml:space="preserve">
          <source>File::Copy</source>
          <target state="translated">File::Copy</target>
        </trans-unit>
        <trans-unit id="054808322e1fad4b177e7be1b21dbd651d7b51df" translate="yes" xml:space="preserve">
          <source>File::Copy - Copy files or filehandles</source>
          <target state="translated">File::Copy-复制文件或文件句柄</target>
        </trans-unit>
        <trans-unit id="f2e6bb244559c9a61df5a32393bbd55e499cf28c" translate="yes" xml:space="preserve">
          <source>File::Copy also provides the &lt;code&gt;syscopy&lt;/code&gt; routine, which copies the file specified in the first parameter to the file specified in the second parameter, preserving OS-specific attributes and file structure. For Unix systems, this is equivalent to the simple &lt;code&gt;copy&lt;/code&gt; routine, which doesn't preserve OS-specific attributes. For VMS systems, this calls the &lt;code&gt;rmscopy&lt;/code&gt; routine (see below). For OS/2 systems, this calls the &lt;code&gt;syscopy&lt;/code&gt; XSUB directly. For Win32 systems, this calls &lt;code&gt;Win32::CopyFile&lt;/code&gt; .</source>
          <target state="translated">File :: Copy还提供 &lt;code&gt;syscopy&lt;/code&gt; 例程，该例程将第一个参数中指定的文件复制到第二个参数中指定的文件，从而保留特定于操作系统的属性和文件结构。对于Unix系统，这等效于简单的 &lt;code&gt;copy&lt;/code&gt; 例程，该例程不保留特定于OS的属性。对于VMS系统，这将调用 &lt;code&gt;rmscopy&lt;/code&gt; 例程（请参见下文）。对于OS / 2系统，这将直接调用 &lt;code&gt;syscopy&lt;/code&gt; XSUB。对于Win32系统，这将调用 &lt;code&gt;Win32::CopyFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54b31fb1c73438315d9d76e490580acedf76b91a" translate="yes" xml:space="preserve">
          <source>File::Copy also provides the &lt;code&gt;syscopy&lt;/code&gt; routine, which copies the file specified in the first parameter to the file specified in the second parameter, preserving OS-specific attributes and file structure. For Unix systems, this is equivalent to the simple &lt;code&gt;copy&lt;/code&gt; routine, which doesn't preserve OS-specific attributes. For VMS systems, this calls the &lt;code&gt;rmscopy&lt;/code&gt; routine (see below). For OS/2 systems, this calls the &lt;code&gt;syscopy&lt;/code&gt; XSUB directly. For Win32 systems, this calls &lt;code&gt;Win32::CopyFile&lt;/code&gt;.</source>
          <target state="translated">File :: Copy还提供 &lt;code&gt;syscopy&lt;/code&gt; 例程，该例程将第一个参数中指定的文件复制到第二个参数中指定的文件，从而保留特定于操作系统的属性和文件结构。对于Unix系统，这等效于简单的 &lt;code&gt;copy&lt;/code&gt; 例程，该例程不保留特定于OS的属性。对于VMS系统，这将调用 &lt;code&gt;rmscopy&lt;/code&gt; 例程（请参见下文）。对于OS / 2系统，这将直接调用 &lt;code&gt;syscopy&lt;/code&gt; XSUB。对于Win32系统，这将调用 &lt;code&gt;Win32::CopyFile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67f88864b88bba7acff99452234fd97bf0f47f99" translate="yes" xml:space="preserve">
          <source>File::Copy was written by Aaron Sherman</source>
          <target state="translated">File::Copy由Aaron Sherman撰写。</target>
        </trans-unit>
        <trans-unit id="f01a5358f4ca69063ca392607e003dc733b2597f" translate="yes" xml:space="preserve">
          <source>File::DosGlob</source>
          <target state="translated">File::DosGlob</target>
        </trans-unit>
        <trans-unit id="5c17116d51c1f03e40c8b694ba6c585eabe2a321" translate="yes" xml:space="preserve">
          <source>File::DosGlob - DOS like globbing and then some</source>
          <target state="translated">File::DosGlob-类似于DOS的globing,然后是一些。</target>
        </trans-unit>
        <trans-unit id="bfa471141e1f7096bf78ca1f82e51c1164281798" translate="yes" xml:space="preserve">
          <source>File::Fetch</source>
          <target state="translated">File::Fetch</target>
        </trans-unit>
        <trans-unit id="dcff4894464604256beca2d13f60a2e0200dbabf" translate="yes" xml:space="preserve">
          <source>File::Fetch - A generic file fetching mechanism</source>
          <target state="translated">File::Fetch-一个通用的文件获取机制。</target>
        </trans-unit>
        <trans-unit id="c8dc9651ac05b80071b1feb534cf5a5de8f9de03" translate="yes" xml:space="preserve">
          <source>File::Fetch is a generic file fetching mechanism.</source>
          <target state="translated">File::Fetch是一个通用的文件获取机制。</target>
        </trans-unit>
        <trans-unit id="2cb1276427ae5064c5b11d564d8f990a7923f8fb" translate="yes" xml:space="preserve">
          <source>File::Fetch is able to fetch a variety of uris, by using several external programs and modules.</source>
          <target state="translated">File::Fetch能够通过使用一些外部程序和模块来获取各种uris。</target>
        </trans-unit>
        <trans-unit id="652b8a474fd7bf89a6c10654387f68b029ba4afc" translate="yes" xml:space="preserve">
          <source>File::Find</source>
          <target state="translated">File::Find</target>
        </trans-unit>
        <trans-unit id="dabbc689655c180a270054bdf94079c67c56996d" translate="yes" xml:space="preserve">
          <source>File::Find - Traverse a directory tree.</source>
          <target state="translated">File::Find-遍历一个目录树。</target>
        </trans-unit>
        <trans-unit id="602f452d2b6cab137b630932705ec11b4fbc5825" translate="yes" xml:space="preserve">
          <source>File::Find used to produce incorrect results if called recursively. During the development of perl 5.8 this bug was fixed. The first fixed version of File::Find was 1.01.</source>
          <target state="translated">File::Find 在递归调用时产生了不正确的结果。在perl 5.8的开发过程中,这个错误得到了修正。File::Find的第一个修复版本是1.01。</target>
        </trans-unit>
        <trans-unit id="cf7493e2714621d4472c83b7fb17367a3f07e0e0" translate="yes" xml:space="preserve">
          <source>File::Find::Rule</source>
          <target state="translated">File::Find::Rule</target>
        </trans-unit>
        <trans-unit id="fdabb48d19b73dd4070bb82d3a9c90ab1b81880a" translate="yes" xml:space="preserve">
          <source>File::Glob</source>
          <target state="translated">File::Glob</target>
        </trans-unit>
        <trans-unit id="8d9f792f087977bcc4f2c40334cf6983814a1f4b" translate="yes" xml:space="preserve">
          <source>File::Glob - Perl extension for BSD glob routine</source>
          <target state="translated">File::Glob-BSD glob 例程的 Perl 扩展。</target>
        </trans-unit>
        <trans-unit id="5c88309ce18d22b575a2e92f21ed146adc833a5f" translate="yes" xml:space="preserve">
          <source>File::Glob::bsd_glob() implements the FreeBSD glob(3) routine, which is a superset of the POSIX glob() (described in IEEE Std 1003.2 &quot;POSIX.2&quot;). bsd_glob() takes a mandatory &lt;code&gt;pattern&lt;/code&gt; argument, and an optional &lt;code&gt;flags&lt;/code&gt; argument, and returns a list of filenames matching the pattern, with interpretation of the pattern modified by the &lt;code&gt;flags&lt;/code&gt; variable.</source>
          <target state="translated">File :: Glob :: bsd_glob（）实现FreeBSD glob（3）例程，该例程是POSIX glob（）的超集（在IEEE Std 1003.2&amp;ldquo; POSIX.2&amp;rdquo;中进行了描述）。bsd_glob（）接受强制性 &lt;code&gt;pattern&lt;/code&gt; 参数和可选的 &lt;code&gt;flags&lt;/code&gt; 参数，并返回与模式匹配的文件名列表，并解释由 &lt;code&gt;flags&lt;/code&gt; 变量修改的模式。</target>
        </trans-unit>
        <trans-unit id="f87067e2d659155bfc6a9854ce51bc4675107538" translate="yes" xml:space="preserve">
          <source>File::Glob::glob() was removed</source>
          <target state="translated">File::Glob::glob()被移除。</target>
        </trans-unit>
        <trans-unit id="1d1ec8d2c1b6a1f048a3125e50262ab2025f6341" translate="yes" xml:space="preserve">
          <source>File::Glob::glob() will disappear</source>
          <target state="translated">File::Glob::glob()将消失</target>
        </trans-unit>
        <trans-unit id="53041d7596d97d11a152927840695227b7f906a6" translate="yes" xml:space="preserve">
          <source>File::Glob::glob() will disappear in perl 5.30. Use File::Glob::bsd_glob() instead.</source>
          <target state="translated">File::Glob::glob()将在 perl 5.30 中消失。使用 File::Glob::bsd_glob()来代替。</target>
        </trans-unit>
        <trans-unit id="ca454d7c1a5b19f064af8b037120ba60d6c7a525" translate="yes" xml:space="preserve">
          <source>File::GlobMapper</source>
          <target state="translated">File::GlobMapper</target>
        </trans-unit>
        <trans-unit id="7f7d175bf488aed0eb444cb11c08455ad8599ba6" translate="yes" xml:space="preserve">
          <source>File::GlobMapper - Extend File Glob to Allow Input and Output Files</source>
          <target state="translated">File::GlobMapper-扩展文件Glob以允许输入和输出文件。</target>
        </trans-unit>
        <trans-unit id="1ee8431a726a8a5ed8c4e143748ae9ecf3b924c2" translate="yes" xml:space="preserve">
          <source>File::Path</source>
          <target state="translated">File::Path</target>
        </trans-unit>
        <trans-unit id="1686306ed7a2e3c93f30ae5144bea665fa4f6ad8" translate="yes" xml:space="preserve">
          <source>File::Path - Create or remove directory trees</source>
          <target state="translated">File::Path-创建或删除目录树。</target>
        </trans-unit>
        <trans-unit id="e96111b9d00440bfa3194f5f2b0d6ee8ef1d305a" translate="yes" xml:space="preserve">
          <source>File::Path::Tiny</source>
          <target state="translated">File::Path::Tiny</target>
        </trans-unit>
        <trans-unit id="a4ef679a008a6f84865a9e072a31d15ade694f3b" translate="yes" xml:space="preserve">
          <source>File::Remove</source>
          <target state="translated">File::Remove</target>
        </trans-unit>
        <trans-unit id="315013b7403b971bbccc00acbcaa29af9f35ca59" translate="yes" xml:space="preserve">
          <source>File::Spec</source>
          <target state="translated">File::Spec</target>
        </trans-unit>
        <trans-unit id="e03ff856a0868930dbc9cd6d64ff461d1bdaaabc" translate="yes" xml:space="preserve">
          <source>File::Spec &amp;lt;= 0.83 has a bug where the file part of catfile is not canonicalized. This override fixes that bug.</source>
          <target state="translated">File :: Spec &amp;lt;= 0.83有一个错误，其中catfile的文件部分未规范化。此替代解决了该错误。</target>
        </trans-unit>
        <trans-unit id="5c2545f01462091353041ce999852a980063ef93" translate="yes" xml:space="preserve">
          <source>File::Spec - portably perform operations on file names</source>
          <target state="translated">File::Spec-可移植地对文件名进行操作。</target>
        </trans-unit>
        <trans-unit id="9959b013bbb548a84f49a147644db4f6f8b5d759" translate="yes" xml:space="preserve">
          <source>File::Spec for AmigaOS</source>
          <target state="translated">File::Spec for AmigaOS</target>
        </trans-unit>
        <trans-unit id="377c35de2ed196f9c5385b1edfdc4eb6ca2a2256" translate="yes" xml:space="preserve">
          <source>File::Spec for Mac OS (Classic)</source>
          <target state="translated">File::Spec for Mac OS (Classic)</target>
        </trans-unit>
        <trans-unit id="e9dc37ac681ea880968c6d2c9418018b55ac8a4a" translate="yes" xml:space="preserve">
          <source>File::Spec for Unix, base for other File::Spec modules</source>
          <target state="translated">File::Spec for Unix,其他File::Spec模块的基础。</target>
        </trans-unit>
        <trans-unit id="2230f7295f7621836cbf459a68fa7d245b56ed9e" translate="yes" xml:space="preserve">
          <source>File::Spec should now recognise an Amiga style absolute path as well as an Unix style one. Relative paths must always be Unix style.</source>
          <target state="translated">File::Spec 现在应该能识别 Amiga 风格的绝对路径和 Unix 风格的路径。相对路径必须始终是 Unix 风格。</target>
        </trans-unit>
        <trans-unit id="5d3e2d6a2a684c855af3654d42b2d52642b0b206" translate="yes" xml:space="preserve">
          <source>File::Spec wrappers</source>
          <target state="translated">文件::规格包装纸</target>
        </trans-unit>
        <trans-unit id="57d505f90f23c581eff3d8fd504c98b55b80e3f3" translate="yes" xml:space="preserve">
          <source>File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2, File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker</source>
          <target state="translated">File::Spec,File::Spec::Unix,File::Spec::Mac,File::Spec::OS2,File::Spec::Win32,File::Spec::VMS,ExtUtils::MakeMaker。</target>
        </trans-unit>
        <trans-unit id="6d1ab27caf0a586b7f11d8ddbe66da5da11dfe66" translate="yes" xml:space="preserve">
          <source>File::Spec::AmigaOS</source>
          <target state="translated">File::Spec::AmigaOS</target>
        </trans-unit>
        <trans-unit id="f6e69f2aec454b070b65436d8f6402978ebd5c22" translate="yes" xml:space="preserve">
          <source>File::Spec::AmigaOS - File::Spec for AmigaOS</source>
          <target state="translated">File::Spec::AmigaOS-File::Spec for AmigaOS</target>
        </trans-unit>
        <trans-unit id="641add72b7fdbf25abb0c07f6fb8252f0c914b3a" translate="yes" xml:space="preserve">
          <source>File::Spec::Cygwin</source>
          <target state="translated">File::Spec::Cygwin</target>
        </trans-unit>
        <trans-unit id="cdfed1a8102059cb23af35a0f86b67871164f579" translate="yes" xml:space="preserve">
          <source>File::Spec::Cygwin - methods for Cygwin file specs</source>
          <target state="translated">File::Spec::Cygwin-用于Cygwin文件规范的方法。</target>
        </trans-unit>
        <trans-unit id="e72fdb6ea5dc0105bf8962f6650693bd46fc1242" translate="yes" xml:space="preserve">
          <source>File::Spec::Epoc</source>
          <target state="translated">File::Spec::Epoc</target>
        </trans-unit>
        <trans-unit id="eb8693815ec649d283b89619fb500489b50c284c" translate="yes" xml:space="preserve">
          <source>File::Spec::Epoc - methods for Epoc file specs</source>
          <target state="translated">File::Spec::Epoc-用于Epoc文件规范的方法。</target>
        </trans-unit>
        <trans-unit id="58ab258073f8844f58a13c0e540afd7c70528044" translate="yes" xml:space="preserve">
          <source>File::Spec::Functions</source>
          <target state="translated">File::Spec::Functions</target>
        </trans-unit>
        <trans-unit id="5200acce0e1b5700ec3f6c1ce8b085a9594ec913" translate="yes" xml:space="preserve">
          <source>File::Spec::Functions - portably perform operations on file names</source>
          <target state="translated">File::Spec::Functions-可移植地执行文件名的操作。</target>
        </trans-unit>
        <trans-unit id="fc6db1e1b5de7797ac516f96a446cab61cfc0d6a" translate="yes" xml:space="preserve">
          <source>File::Spec::Mac</source>
          <target state="translated">File::Spec::Mac</target>
        </trans-unit>
        <trans-unit id="d79a8c64b96c6d94516d88b113e5eac3b9da4ad8" translate="yes" xml:space="preserve">
          <source>File::Spec::Mac - File::Spec for Mac OS (Classic)</source>
          <target state="translated">File::Spec::Mac-File::Spec for Mac OS (Classic)</target>
        </trans-unit>
        <trans-unit id="dd2e7ffeaaea8af26591abffe1ee1b6f540db20c" translate="yes" xml:space="preserve">
          <source>File::Spec::OS2</source>
          <target state="translated">File::Spec::OS2</target>
        </trans-unit>
        <trans-unit id="40e2993be3fcfb49e9dff0bf954a4b4fc18277d7" translate="yes" xml:space="preserve">
          <source>File::Spec::OS2 - methods for OS/2 file specs</source>
          <target state="translated">File::Spec::OS2-用于OS/2文件规范的方法。</target>
        </trans-unit>
        <trans-unit id="f7a8d4f1ec9c1ccc3e150ac09fa9f67a10dfcb83" translate="yes" xml:space="preserve">
          <source>File::Spec::Unix</source>
          <target state="translated">File::Spec::Unix</target>
        </trans-unit>
        <trans-unit id="0d7acdcbd611107237cca4df6cbd4c594405934d" translate="yes" xml:space="preserve">
          <source>File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules</source>
          <target state="translated">File::Spec::Unix-适用于Unix的File::Spec,其他File::Spec模块的基础。</target>
        </trans-unit>
        <trans-unit id="bf21f77214d880322c14e8ee35bc09087fde112d" translate="yes" xml:space="preserve">
          <source>File::Spec::VMS</source>
          <target state="translated">File::Spec::VMS</target>
        </trans-unit>
        <trans-unit id="c14aa057f43f4a505144d4210ab15e571114fe16" translate="yes" xml:space="preserve">
          <source>File::Spec::VMS - methods for VMS file specs</source>
          <target state="translated">File::Spec::VMS-用于VMS文件规范的方法。</target>
        </trans-unit>
        <trans-unit id="2822248f9e471c31171c089c3fdd48b3debb74f9" translate="yes" xml:space="preserve">
          <source>File::Spec::Win32</source>
          <target state="translated">File::Spec::Win32</target>
        </trans-unit>
        <trans-unit id="080364c33593182b7f7f657492fb3b2d46eb857c" translate="yes" xml:space="preserve">
          <source>File::Spec::Win32 - methods for Win32 file specs</source>
          <target state="translated">File::Spec::Win32-用于Win32文件规范的方法。</target>
        </trans-unit>
        <trans-unit id="e0fd4afcd716107e17e677aa59b46d6470fb899a" translate="yes" xml:space="preserve">
          <source>File::Temp</source>
          <target state="translated">File::Temp</target>
        </trans-unit>
        <trans-unit id="3fe450162cf54232d01afd15746195856bbdbb84" translate="yes" xml:space="preserve">
          <source>File::Temp - return name and handle of a temporary file safely</source>
          <target state="translated">File::Temp-安全地返回一个临时文件的名称和句柄。</target>
        </trans-unit>
        <trans-unit id="d91ecfa6abec25b99ed11c8b2d5f3accbd385c89" translate="yes" xml:space="preserve">
          <source>File::chdir</source>
          <target state="translated">File::chdir</target>
        </trans-unit>
        <trans-unit id="e83a936a3382a41b1f3f93e3d07a775dcb299d22" translate="yes" xml:space="preserve">
          <source>File::stat</source>
          <target state="translated">File::stat</target>
        </trans-unit>
        <trans-unit id="9639e61c73c9c60e6cfa27fbe83124dab13c12b1" translate="yes" xml:space="preserve">
          <source>File::stat - by-name interface to Perl's built-in stat() functions</source>
          <target state="translated">File::stat-Perl内置的stat()函数的按名接口</target>
        </trans-unit>
        <trans-unit id="3aaa59844e5f806feadbfe38925fb866e1cd3f21" translate="yes" xml:space="preserve">
          <source>File::stat ignores VMS ACLs</source>
          <target state="translated">File::stat 忽略 VMS ACLs。</target>
        </trans-unit>
        <trans-unit id="99fb53931e742958a9e4d829323954f481f89cc9" translate="yes" xml:space="preserve">
          <source>File::stat ignores use filetest 'access'</source>
          <target state="translated">File::stat 忽略使用 filetest 'access'。</target>
        </trans-unit>
        <trans-unit id="ef5f659600c421b89a34289668dcda4b8fde8960" translate="yes" xml:space="preserve">
          <source>FileCache</source>
          <target state="translated">FileCache</target>
        </trans-unit>
        <trans-unit id="dd4dfad3675618140d4d83ded99b3dd8deb7df16" translate="yes" xml:space="preserve">
          <source>FileCache - keep more files open than the system permits</source>
          <target state="translated">FileCache-保持打开的文件数量超过系统允许的数量。</target>
        </trans-unit>
        <trans-unit id="a5cc97ff5fda266750b3dee9900ddf98823854aa" translate="yes" xml:space="preserve">
          <source>FileCache does not store the current file offset if it finds it necessary to close a file. When the file is reopened, the offset will be as specified by the original &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; file mode. This could be construed to be a bug.</source>
          <target state="translated">FileCache如果发现有必要关闭文件，则不存储当前文件偏移量。重新打开文件时，偏移量将由原始 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 文件模式指定。这可以解释为一个错误。</target>
        </trans-unit>
        <trans-unit id="e560be1c46271875fcf2c02c89a0fafd349042ff" translate="yes" xml:space="preserve">
          <source>FileCache does not store the current file offset if it finds it necessary to close a file. When the file is reopened, the offset will be as specified by the original &lt;code&gt;open&lt;/code&gt; file mode. This could be construed to be a bug.</source>
          <target state="translated">如果发现需要关闭文件，FileCache不会存储当前文件偏移量。重新打开文件时，偏移量将由原始 &lt;code&gt;open&lt;/code&gt; 文件模式指定。这可以解释为一个错误。</target>
        </trans-unit>
        <trans-unit id="89f533c3cd15e297fdf4aabaf6ece0f9c1be27a5" translate="yes" xml:space="preserve">
          <source>FileHandle</source>
          <target state="translated">FileHandle</target>
        </trans-unit>
        <trans-unit id="794819fbb3c9526c54cbc3cce598cbc494f7c4eb" translate="yes" xml:space="preserve">
          <source>FileHandle - supply object methods for filehandles</source>
          <target state="translated">FileHandle-为filehandle提供对象方法。</target>
        </trans-unit>
        <trans-unit id="caccd2fd17d3701ac8d56515a20a8537c819133d" translate="yes" xml:space="preserve">
          <source>Filehandle %s opened only for input</source>
          <target state="translated">只为输入而打开的文件句柄%s</target>
        </trans-unit>
        <trans-unit id="452cce9d01c3fa809d5699a1472cfe4e819be842" translate="yes" xml:space="preserve">
          <source>Filehandle %s opened only for output</source>
          <target state="translated">只为输出而打开的文件句柄%s</target>
        </trans-unit>
        <trans-unit id="843eb3eeb3ed68dd4ce2373716c6a0c575f1c73d" translate="yes" xml:space="preserve">
          <source>Filehandle %s reopened as %s only for input</source>
          <target state="translated">文件柄%s重开为%s,仅用于输入。</target>
        </trans-unit>
        <trans-unit id="fc7038d4dbae8378dfacc2e299daf12024b15451" translate="yes" xml:space="preserve">
          <source>Filehandle STDIN reopened as %s only for output</source>
          <target state="translated">文件handle STDIN重开为%s,仅用于输出。</target>
        </trans-unit>
        <trans-unit id="3e986485fa2d06cffe03b4cb5d722b8847e7c236" translate="yes" xml:space="preserve">
          <source>Filehandles</source>
          <target state="translated">Filehandles</target>
        </trans-unit>
        <trans-unit id="d3712e0344c29c9b6fcd8cd69a7b601cf8888c11" translate="yes" xml:space="preserve">
          <source>Filehandles into commands are also known as</source>
          <target state="translated">将文件柄转化为命令也就是所谓的</target>
        </trans-unit>
        <trans-unit id="745059e953a17e849a5f1d5cc58b8c65a4690f8b" translate="yes" xml:space="preserve">
          <source>Filehandles returned by these functions support the seekable methods.</source>
          <target state="translated">这些函数返回的文件柄支持可寻方法。</target>
        </trans-unit>
        <trans-unit id="d917728ca0ac0c4b9a39ce3d45425ec35d9ebdc0" translate="yes" xml:space="preserve">
          <source>Filename Case</source>
          <target state="translated">文件名案例</target>
        </trans-unit>
        <trans-unit id="fb7a4b255171595818c7e230dab6fcf171fbaa94" translate="yes" xml:space="preserve">
          <source>Filenames</source>
          <target state="translated">Filenames</target>
        </trans-unit>
        <trans-unit id="9fd1eebd086da1a91988827a7bacbfddddd4cb35" translate="yes" xml:space="preserve">
          <source>Filenames can be picked arbitrarily; &lt;code&gt;CPAN.pm&lt;/code&gt; always reads all files (in alphabetical order) and takes the key &lt;code&gt;match&lt;/code&gt; (see below in</source>
          <target state="translated">可以任意选择文件名； &lt;code&gt;CPAN.pm&lt;/code&gt; 始终读取所有文件（按字母顺序）并进行密钥 &lt;code&gt;match&lt;/code&gt; （请参见下文</target>
        </trans-unit>
        <trans-unit id="c9784173a96e4b1510622cabd6602208c753b868" translate="yes" xml:space="preserve">
          <source>Filenames with * and ? will be glob expanded.</source>
          <target state="translated">带*和? 的文件名将被 glob 扩展。</target>
        </trans-unit>
        <trans-unit id="6d5cddfd74101a38239a8348d8bb2b2793e6fb31" translate="yes" xml:space="preserve">
          <source>Fileno</source>
          <target state="translated">Fileno</target>
        </trans-unit>
        <trans-unit id="048ca477f6d313575e8e768358930dd94a0805a0" translate="yes" xml:space="preserve">
          <source>Files I'm trying to fetch have reserved characters or non-ASCII characters in them. What do I do?</source>
          <target state="translated">我试图获取的文件中有保留字符或非ASCII字符。我该怎么做?</target>
        </trans-unit>
        <trans-unit id="119c6ebf5f034a0bdf47e2ccf4a4a00d52bae121" translate="yes" xml:space="preserve">
          <source>Files and Filesystems</source>
          <target state="translated">文件和文件系统</target>
        </trans-unit>
        <trans-unit id="1b66cfb0249a670160094a9d9a1226caf17ef912" translate="yes" xml:space="preserve">
          <source>Files and I/O</source>
          <target state="translated">文件和I/O</target>
        </trans-unit>
        <trans-unit id="dc090aa9a69fc8ac0e7b03719c86dccf85d1fb26" translate="yes" xml:space="preserve">
          <source>Files can be &quot;renamed&quot; between file systems and the file contents and some attributes will be moved. Directories can only be renamed within one file system. If there is already a file or directory named &lt;code&gt;$sNewName&lt;/code&gt;, then &lt;code&gt;MoveFile&lt;/code&gt; will fail.</source>
          <target state="translated">可以在文件系统和文件内容之间&amp;ldquo;重命名&amp;rdquo;文件，并且某些属性将被移动。目录只能在一个文件系统中重命名。如果已经有一个名为 &lt;code&gt;$sNewName&lt;/code&gt; 的文件或目录，则 &lt;code&gt;MoveFile&lt;/code&gt; 将失败。</target>
        </trans-unit>
        <trans-unit id="5bcfdef82017aca1b62d322f75f45269c52cebb0" translate="yes" xml:space="preserve">
          <source>Files older than v2.0 will have the one of the version numbers &quot;-1&quot;, &quot;0&quot; or &quot;1&quot;. No minor number was used at that time.</source>
          <target state="translated">比v2.0更早的文件会有&quot;-1&quot;、&quot;0 &quot;或 &quot;1 &quot;中的一个版本号。当时没有使用小号。</target>
        </trans-unit>
        <trans-unit id="ce0b65cbec28e6a52a00f89d26a974e92b387838" translate="yes" xml:space="preserve">
          <source>Files opened without an encoding argument will be in UTF-8:</source>
          <target state="translated">没有编码参数的文件将以UTF-8格式打开。</target>
        </trans-unit>
        <trans-unit id="646de437489432c391060b841f63b51dd2e343a9" translate="yes" xml:space="preserve">
          <source>Files which are not &lt;code&gt;mmap()&lt;/code&gt; -able revert to behaving like the &lt;code&gt;:perlio&lt;/code&gt; layer. Writes also behave like the &lt;code&gt;:perlio&lt;/code&gt; layer, as &lt;code&gt;mmap()&lt;/code&gt; for write needs extra house-keeping (to extend the file) which negates any advantage.</source>
          <target state="translated">不能使用 &lt;code&gt;mmap()&lt;/code&gt; 的文件将恢复为 &lt;code&gt;:perlio&lt;/code&gt; 层的行为。写操作也像 &lt;code&gt;:perlio&lt;/code&gt; 层一样，因为写操作的 &lt;code&gt;mmap()&lt;/code&gt; 需要额外的内务处理（以扩展文件），这抵消了任何优势。</target>
        </trans-unit>
        <trans-unit id="24cde58079ede41bb0ed81d8b77089f0773128f0" translate="yes" xml:space="preserve">
          <source>Files which are not &lt;code&gt;mmap()&lt;/code&gt;-able revert to behaving like the &lt;code&gt;:perlio&lt;/code&gt; layer. Writes also behave like the &lt;code&gt;:perlio&lt;/code&gt; layer, as &lt;code&gt;mmap()&lt;/code&gt; for write needs extra house-keeping (to extend the file) which negates any advantage.</source>
          <target state="translated">不能使用 &lt;code&gt;mmap()&lt;/code&gt; 的文件将恢复为 &lt;code&gt;:perlio&lt;/code&gt; 层的行为。写操作也像 &lt;code&gt;:perlio&lt;/code&gt; 层一样，因为写操作的 &lt;code&gt;mmap()&lt;/code&gt; 需要额外的内务处理（以扩展文件），这抵消了任何优势。</target>
        </trans-unit>
        <trans-unit id="7adb6736cf2c9ae017b128f98738ffbae0e58655" translate="yes" xml:space="preserve">
          <source>Fill</source>
          <target state="translated">Fill</target>
        </trans-unit>
        <trans-unit id="a4b96b98ba0acc4a2c64164e14e7284859d739a2" translate="yes" xml:space="preserve">
          <source>Fill &lt;code&gt;sv&lt;/code&gt; with current working directory</source>
          <target state="translated">用当前工作目录填充 &lt;code&gt;sv&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a624b168584689d4ad50d72852da812cefd7de42" translate="yes" xml:space="preserve">
          <source>Fill the sv with current working directory</source>
          <target state="translated">用当前的工作目录填充sv</target>
        </trans-unit>
        <trans-unit id="7c991b879751864162456f044ae4b061287a9ddd" translate="yes" xml:space="preserve">
          <source>Fill up memory with a byte pattern (a byte repeated over and over again) that hopefully catches attempts to access uninitialized memory.</source>
          <target state="translated">用一个字节模式(一个字节不断重复)来填充内存,希望能捕捉到访问未初始化内存的尝试。</target>
        </trans-unit>
        <trans-unit id="1caa98b8fe4b092dfaf90807d48e36c7313a1fe3" translate="yes" xml:space="preserve">
          <source>Filter DBM keys/values</source>
          <target state="translated">筛选DBM键/值</target>
        </trans-unit>
        <trans-unit id="49db338137c69e197263cbd2a2a02d160fa11306" translate="yes" xml:space="preserve">
          <source>Filter for DBM_Filter</source>
          <target state="translated">DBM_Filter的过滤器</target>
        </trans-unit>
        <trans-unit id="155bc63929438bf5891026e88a669c019cfee1eb" translate="yes" xml:space="preserve">
          <source>Filter the file list so that all the test files run match /(LIST|OF|PATTERNS)/. Note that with this form the patterns are joined by '|' and you cannot supply a list of files, instead the test files are obtained from the MANIFEST.</source>
          <target state="translated">过滤文件列表,使所有运行的测试文件都符合/(LIST|OF|PATTERNS)/。需要注意的是,这种形式的模式是由'|'连接的,你不能提供一个文件列表,而是从MANIFEST中获取测试文件。</target>
        </trans-unit>
        <trans-unit id="d5a596c0ce5a2b7a7aba6646e13f8fdc098b26bf" translate="yes" xml:space="preserve">
          <source>Filter the file list so that all the test files run match PATTERN. Note that this form is distinct from the &lt;b&gt;-re LIST OF PATTERNS&lt;/b&gt; form below in that it allows the file list to be provided as well.</source>
          <target state="translated">过滤文件列表，以便所有测试文件运行都匹配PATTERN。请注意，此格式与下面的&lt;b&gt;-re LIST OF PATTERNS&lt;/b&gt;格式不同，因为它还允许提供文件列表。</target>
        </trans-unit>
        <trans-unit id="42d3a31d1c9ff4adea6e61106fd398bfebcdb7bc" translate="yes" xml:space="preserve">
          <source>Filter::Simple</source>
          <target state="translated">Filter::Simple</target>
        </trans-unit>
        <trans-unit id="8902388c9d4dcc551448da4cca3d317ed63a6414" translate="yes" xml:space="preserve">
          <source>Filter::Simple - Simplified source filtering</source>
          <target state="translated">Filter::Simple-简化源过滤</target>
        </trans-unit>
        <trans-unit id="4d594a2e8094dc15ca9e42ca0d84c3e0a33987d2" translate="yes" xml:space="preserve">
          <source>Filter::Simple generates a special &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine for your module (see &lt;a href=&quot;#How-it-works&quot;&gt;How it works&lt;/a&gt;) which would normally replace any &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine you might have explicitly declared.</source>
          <target state="translated">Filter :: Simple 为您的模块生成一个特殊的 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程（请参见&lt;a href=&quot;#How-it-works&quot;&gt;工作原理&lt;/a&gt;），该子例程通常会替换您可能已明确声明的任何 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程。</target>
        </trans-unit>
        <trans-unit id="55a67bc6b5c9e931b9cfc1d00997088616960c2d" translate="yes" xml:space="preserve">
          <source>Filter::Simple generates a special &lt;code&gt;import&lt;/code&gt; subroutine for your module (see &lt;a href=&quot;#How-it-works&quot;&gt;&quot;How it works&quot;&lt;/a&gt;) which would normally replace any &lt;code&gt;import&lt;/code&gt; subroutine you might have explicitly declared.</source>
          <target state="translated">Filter :: Simple为您的模块生成一个特殊的 &lt;code&gt;import&lt;/code&gt; 子例程（请参见&lt;a href=&quot;#How-it-works&quot;&gt;&amp;ldquo;如何工作&amp;rdquo;&lt;/a&gt;），该子例程通常会替换您可能已明确声明的任何 &lt;code&gt;import&lt;/code&gt; 子例程。</target>
        </trans-unit>
        <trans-unit id="5b045aab2dc3c12f8983dd3d86529beb5ee5d291" translate="yes" xml:space="preserve">
          <source>Filter::Simple is now maintained by the Perl5-Porters. Please submit bug via the &lt;code&gt;perlbug&lt;/code&gt; tool that comes with your perl. For usage instructions, read &lt;code&gt;perldoc perlbug&lt;/code&gt; or possibly &lt;code&gt;man perlbug&lt;/code&gt; . For mostly anything else, please contact &amp;lt;perl5-porters@perl.org&amp;gt;.</source>
          <target state="translated">Filter :: Simple现在由Perl5-Porters维护。请通过perl随附的 &lt;code&gt;perlbug&lt;/code&gt; 工具提交错误。有关使用说明，请阅读 &lt;code&gt;perldoc perlbug&lt;/code&gt; 或 &lt;code&gt;man perlbug&lt;/code&gt; 。有关大多数其他信息，请联系&amp;lt;perl5-porters@perl.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="5efffe4d78970f8e0d9b73652dcdf366fc15a91e" translate="yes" xml:space="preserve">
          <source>Filter::Simple is now maintained by the Perl5-Porters. Please submit bug via the &lt;code&gt;perlbug&lt;/code&gt; tool that comes with your perl. For usage instructions, read &lt;code&gt;perldoc perlbug&lt;/code&gt; or possibly &lt;code&gt;man perlbug&lt;/code&gt;. For mostly anything else, please contact &amp;lt;perl5-porters@perl.org&amp;gt;.</source>
          <target state="translated">Filter :: Simple现在由Perl5-Porters维护。请通过perl随附的 &lt;code&gt;perlbug&lt;/code&gt; 工具提交错误。有关使用说明，请阅读 &lt;code&gt;perldoc perlbug&lt;/code&gt; 或 &lt;code&gt;man perlbug&lt;/code&gt; 。有关大多数其他信息，请联系&amp;lt;perl5-porters@perl.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="19879ac495533ad1077ba2c41a6a1388fc0daf98" translate="yes" xml:space="preserve">
          <source>Filter::Simple supports this type of filtering by automatically exporting the &lt;code&gt;FILTER_ONLY&lt;/code&gt; subroutine.</source>
          <target state="translated">Filter :: Simple通过自动导出 &lt;code&gt;FILTER_ONLY&lt;/code&gt; 子例程来支持这种类型的过滤。</target>
        </trans-unit>
        <trans-unit id="7738927e99aa19b5661cca71074c5a3666ddd066" translate="yes" xml:space="preserve">
          <source>Filter::Util::Call</source>
          <target state="translated">Filter::Util::Call</target>
        </trans-unit>
        <trans-unit id="7dc52ff0d48741e56609be222232752914b7f609" translate="yes" xml:space="preserve">
          <source>Filter::Util::Call - Perl Source Filter Utility Module</source>
          <target state="translated">Filter::Util::Call--Perl源码过滤工具模块。</target>
        </trans-unit>
        <trans-unit id="04afd517e71c6ed7b121bd0e3b2068ee5c553269" translate="yes" xml:space="preserve">
          <source>Filter_Key_Push</source>
          <target state="translated">Filter_Key_Push</target>
        </trans-unit>
        <trans-unit id="2601ba4f6f8e8afb00fbd46ca3a26e97043b25fc" translate="yes" xml:space="preserve">
          <source>Filter_Push</source>
          <target state="translated">Filter_Push</target>
        </trans-unit>
        <trans-unit id="0a1a4c0dfa7b456e4ecab8567d85b94d3dafc1a1" translate="yes" xml:space="preserve">
          <source>Filter_Value_Push</source>
          <target state="translated">Filter_Value_Push</target>
        </trans-unit>
        <trans-unit id="0cabe77e4a0f9142f83082a357c9dd9516395a45" translate="yes" xml:space="preserve">
          <source>Filtering only specific components of source code</source>
          <target state="translated">只过滤源代码的特定组件</target>
        </trans-unit>
        <trans-unit id="0d724af3cdfe968bbaf60122abf6756e0bff8902" translate="yes" xml:space="preserve">
          <source>Filtering only the code parts of source code</source>
          <target state="translated">只过滤源代码中的代码部分</target>
        </trans-unit>
        <trans-unit id="064b3406638df42c905600b3e499487ada8eb46b" translate="yes" xml:space="preserve">
          <source>Filters Included</source>
          <target state="translated">过滤器包括</target>
        </trans-unit>
        <trans-unit id="c7c6a6ca2fc222f307864374baefcbe6fd304196" translate="yes" xml:space="preserve">
          <source>Filters a list of values to remove subsequent duplicates, as judged by a DWIM-ish string equality or &lt;code&gt;undef&lt;/code&gt; test. Preserves the order of unique elements, and retains the first value of any duplicate set.</source>
          <target state="translated">过滤值列表以删除后续重复项，这由DWIM式的字符串相等性或 &lt;code&gt;undef&lt;/code&gt; 测试判断。保留唯一元素的顺序，并保留任何重复集的第一个值。</target>
        </trans-unit>
        <trans-unit id="6f26bfb39da45fe446ab2ace33aa6a4dfb8d959e" translate="yes" xml:space="preserve">
          <source>Filters a list of values to remove subsequent duplicates, as judged by a numerical equality test. Preserves the order of unique elements, and retains the first value of any duplicate set.</source>
          <target state="translated">过滤一个值的列表,以去除随后的重复值,如通过一个数字平等测试来判断。保留唯一元素的顺序,并保留任何重复集的第一个值。</target>
        </trans-unit>
        <trans-unit id="e2e1b8102595dc1b879e1156836436fadd592ceb" translate="yes" xml:space="preserve">
          <source>Filters a list of values to remove subsequent duplicates, as judged by a string equality test. Preserves the order of unique elements, and retains the first value of any duplicate set.</source>
          <target state="translated">过滤一个值的列表,以去除后续的重复值,通过字符串平等测试来判断。保留唯一元素的顺序,并保留任何重复集的第一个值。</target>
        </trans-unit>
        <trans-unit id="700795207cadfd27a83211dfeea9a61a315dd6d9" translate="yes" xml:space="preserve">
          <source>Filters a list of values to remove subsequent duplicates, as judged by an integer numerical equality test. Preserves the order of unique elements, and retains the first value of any duplicate set. Values in the returned list will be coerced into integers.</source>
          <target state="translated">过滤一个值的列表,以去除后续的重复值,通过一个整数的数字平等测试来判断。保留唯一元素的顺序,并保留任何重复集的第一个值。返回列表中的值将被强制转化为整数。</target>
        </trans-unit>
        <trans-unit id="5a48634134a41cfb47919ca0620c4a4eb370a44f" translate="yes" xml:space="preserve">
          <source>Filters can be created in two main ways</source>
          <target state="translated">过滤器主要有两种创建方式</target>
        </trans-unit>
        <trans-unit id="f3f0a8fb43e79067faffa3f02bee42380f1453b8" translate="yes" xml:space="preserve">
          <source>Filters everything. Identical in effect to &lt;code&gt;FILTER&lt;/code&gt; .</source>
          <target state="translated">过滤所有内容。与 &lt;code&gt;FILTER&lt;/code&gt; 效果相同。</target>
        </trans-unit>
        <trans-unit id="2bbcb71b4ba53e50f605e87980abfc0509da65aa" translate="yes" xml:space="preserve">
          <source>Filters everything. Identical in effect to &lt;code&gt;FILTER&lt;/code&gt;.</source>
          <target state="translated">过滤所有内容。与 &lt;code&gt;FILTER&lt;/code&gt; 效果相同。</target>
        </trans-unit>
        <trans-unit id="dff7559e7e19f13b99b80c4310a808291f2993fd" translate="yes" xml:space="preserve">
          <source>Filters only Perl quotelikes (as interpreted by &lt;code&gt;&amp;amp;Text::Balanced::extract_quotelike&lt;/code&gt; ).</source>
          <target state="translated">仅过滤Perl quotelikes（由 &lt;code&gt;&amp;amp;Text::Balanced::extract_quotelike&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="afc20f79a9a572c35fd24561f6a83d84c1928e1a" translate="yes" xml:space="preserve">
          <source>Filters only Perl quotelikes (as interpreted by &lt;code&gt;&amp;amp;Text::Balanced::extract_quotelike&lt;/code&gt;).</source>
          <target state="translated">仅过滤Perl quotelikes（由 &lt;code&gt;&amp;amp;Text::Balanced::extract_quotelike&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d46715be5a6c7c637a101bd3fb514ca34a022fd4" translate="yes" xml:space="preserve">
          <source>Filters only the pattern literal parts of a Perl quotelike (i.e. the contents of a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, the first half of an &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">仅过滤Perl quotelike的模式文字部分（即 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 的内容，即 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 的前半部分）。</target>
        </trans-unit>
        <trans-unit id="d870e55b5ec07b87a5f7e4519042304d42ec2f31" translate="yes" xml:space="preserve">
          <source>Filters only the pattern literal parts of a Perl quotelike (i.e. the contents of a &lt;code&gt;qr//&lt;/code&gt; or an &lt;code&gt;m//&lt;/code&gt;, the first half of an &lt;code&gt;s///&lt;/code&gt;).</source>
          <target state="translated">仅过滤Perl quotelike的模式文字部分（即 &lt;code&gt;qr//&lt;/code&gt; 或 &lt;code&gt;m//&lt;/code&gt; 的内容，即 &lt;code&gt;s///&lt;/code&gt; 的前半部分）。</target>
        </trans-unit>
        <trans-unit id="9d6c7da3a59381ce364937477b0de797b35ca66f" translate="yes" xml:space="preserve">
          <source>Filters only the string literal parts of a Perl quotelike (i.e. the contents of a string literal, either half of a &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;, the second half of an &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">仅过滤Perl quotelike的字符串文字部分（即，字符串文字的内容， &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 的一半， &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 一半）。</target>
        </trans-unit>
        <trans-unit id="20f3795aaefe54c90ea0bd4135d4048324d2a28b" translate="yes" xml:space="preserve">
          <source>Filters only the string literal parts of a Perl quotelike (i.e. the contents of a string literal, either half of a &lt;code&gt;tr///&lt;/code&gt;, the second half of an &lt;code&gt;s///&lt;/code&gt;).</source>
          <target state="translated">仅过滤Perl quotelike的字符串文字部分（即，字符串文字的内容，即 &lt;code&gt;tr///&lt;/code&gt; 的一半，或 &lt;code&gt;s///&lt;/code&gt; 一半）。</target>
        </trans-unit>
        <trans-unit id="21c3fceb1f21a8d2c7a7604d5f15909ba3c4e6bc" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not POD or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">仅过滤源代码中不是POD或 &lt;code&gt;__DATA__&lt;/code&gt; 的那些部分。</target>
        </trans-unit>
        <trans-unit id="2dd5107f13a5a36c0e20ccaa94005d515585510f" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not POD or &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="translated">仅过滤源代码中不是POD或 &lt;code&gt;__DATA__&lt;/code&gt; 的那些部分。</target>
        </trans-unit>
        <trans-unit id="8d0e4690844c0e997ddfae93ebb04be08becd5b9" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not POD, comments, or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">仅过滤源代码中不是POD，注释或 &lt;code&gt;__DATA__&lt;/code&gt; 的那些部分。</target>
        </trans-unit>
        <trans-unit id="63d1267df0fbacd4b2081c851758f74bcc49c06b" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not POD, comments, or &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="translated">仅过滤源代码中不是POD，注释或 &lt;code&gt;__DATA__&lt;/code&gt; 的那些部分。</target>
        </trans-unit>
        <trans-unit id="73c4703434d54b35a96afa23550eee383050c8e7" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not quotelikes, POD, comments, or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">仅过滤源代码中不是quotelikes，POD，注释或 &lt;code&gt;__DATA__&lt;/code&gt; 的那些部分。</target>
        </trans-unit>
        <trans-unit id="67191f1183b6941ed0c22be475d8782510da690a" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not quotelikes, POD, comments, or &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="translated">仅过滤源代码中不是quotelikes，POD，注释或 &lt;code&gt;__DATA__&lt;/code&gt; 的那些部分。</target>
        </trans-unit>
        <trans-unit id="6768e7cdb67b7548d17f5b47c853204a354ef8a8" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">仅过滤源代码中不是quotelikes，POD或 &lt;code&gt;__DATA__&lt;/code&gt; 的那些部分。</target>
        </trans-unit>
        <trans-unit id="58ed29de26d37c777bddc03a8e289c5c5c06ef78" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="translated">仅过滤源代码中不是quotelikes，POD或 &lt;code&gt;__DATA__&lt;/code&gt; 的那些部分。</target>
        </trans-unit>
        <trans-unit id="a835e84e6476a3627bf2cb0ac10839ce913c16ff" translate="yes" xml:space="preserve">
          <source>Final $ should be \$ or $name</source>
          <target state="translated">最后的$应该是$或者$name。</target>
        </trans-unit>
        <trans-unit id="0c5efd60aef7150698692bd9522cefaa126df2ec" translate="yes" xml:space="preserve">
          <source>Finally there is the 'default', and the related 'default_get' and 'default_set' options. These options control the &quot;default&quot; object which is provided by the class interface to the methods. Setting &lt;code&gt;default_get&lt;/code&gt; to true tells the constructor to return the default object if it is defined. Setting &lt;code&gt;default_set&lt;/code&gt; to true tells the constructor to make the default object the constructed object. Setting the &lt;code&gt;default&lt;/code&gt; option is like setting both to true. This is used primarily internally and probably isn't interesting to any real user.</source>
          <target state="translated">最后是'default'以及相关的'default_get'和'default_set'选项。这些选项控制由类接口提供给方法的&amp;ldquo;默认&amp;rdquo;对象。将 &lt;code&gt;default_get&lt;/code&gt; 设置为true可以告诉构造函数返回默认对象（如果已定义）。将 &lt;code&gt;default_set&lt;/code&gt; 设置为true可以告诉构造函数将默认对象构造为构造对象。设置 &lt;code&gt;default&lt;/code&gt; 选项就像将两者都设置为true一样。这主要是在内部使用的，对于任何实际用户而言可能都不感兴趣。</target>
        </trans-unit>
        <trans-unit id="b793b4c7037146e44c6ebbd985a0e8b5eea1bc2d" translate="yes" xml:space="preserve">
          <source>Finally,</source>
          <target state="translated">Finally,</target>
        </trans-unit>
        <trans-unit id="c007289d889b2ac012d30249ede8e24355c7610c" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; is a Perl module and toolkit that contains PSGI middleware, helpers and adapters to web servers, allowing you to easily deploy scripts which can continue running, and provides flexibility with regards to which web server you use. It can allow existing CGI scripts to enjoy this flexibility and performance with minimal changes, or can be used along with modern Perl web frameworks to make writing and deploying web services with Perl a breeze.</source>
          <target state="translated">最后，&lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt;是一个Perl模块和工具包，其中包含PSGI中间件，Web服务器的帮助程序和适配器，使您可以轻松地部署可以继续运行的脚本，并可以灵活地使用所使用的Web服务器。它可以允许现有的CGI脚本以最小的更改享受这种灵活性和性能，或者可以与现代的Perl Web框架一起使用，从而使使用Perl编写和部署Web服务变得轻而易举。</target>
        </trans-unit>
        <trans-unit id="458f93c6634aea5d4fadc6ced58e859af016d537" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;plack&quot;&gt;Plack&lt;/a&gt; is a Perl module and toolkit that contains PSGI middleware, helpers and adapters to web servers, allowing you to easily deploy scripts which can continue running, and provides flexibility with regards to which web server you use. It can allow existing CGI scripts to enjoy this flexibility and performance with minimal changes, or can be used along with modern Perl web frameworks to make writing and deploying web services with Perl a breeze.</source>
          <target state="translated">最后，&lt;a href=&quot;plack&quot;&gt;Plack&lt;/a&gt;是一个Perl模块和工具包，其中包含PSGI中间件，Web服务器的帮助程序和适配器，使您可以轻松地部署可以继续运行的脚本，并提供有关所使用的Web服务器的灵活性。它可以允许现有的CGI脚本以最小的更改享受这种灵活性和性能，或者可以与现代的Perl Web框架一起使用，从而使使用Perl编写和部署Web服务变得轻而易举。</target>
        </trans-unit>
        <trans-unit id="44941dad1d15df314302a9115d5bc5d8a2ec4415" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;$?&lt;/code&gt; may be set to a non-0 value if the external program</source>
          <target state="translated">最后， &lt;code&gt;$?&lt;/code&gt; 如果外部程序可以设置为非零值</target>
        </trans-unit>
        <trans-unit id="1ec318bbb4a97f05c20b43c3d365fb178815d120" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;$?&lt;/code&gt; may be set to non-0 value if the external program</source>
          <target state="translated">最后， &lt;code&gt;$?&lt;/code&gt; 如果外部程序可以设置为非零值</target>
        </trans-unit>
        <trans-unit id="92dd49b4407ac7414e31cf79437fb39879d44f34" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; will traverse up references exactly</source>
          <target state="translated">最后， &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 将精确遍历引用</target>
        </trans-unit>
        <trans-unit id="66c1abb8f12ea81297c1b86ceb245b7ba4213937" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; also has an additional affect on the bitwise operators. Normally, the operands and results are treated as &lt;b&gt;unsigned&lt;/b&gt; integers, but with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; the operands and results are &lt;b&gt;signed&lt;/b&gt;. This means, among other things, that ~0 is -1, and -2 &amp;amp; -5 is -6.</source>
          <target state="translated">最后， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 对按位运算符也有附加影响。通常，操作数和结果被视为&lt;b&gt;无符号&lt;/b&gt;整数，但 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 操作数和结果已&lt;b&gt;签名&lt;/b&gt;。除其他外，这意味着〜0为-1，而-2＆-5为-6。</target>
        </trans-unit>
        <trans-unit id="4298e2e9c529f41f2c9de7ef565329b328f06ed5" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;LC_CTYPE&lt;/code&gt; affects the (deprecated) POSIX character-class test functions--&lt;code&gt;POSIX::isalpha()&lt;/code&gt; , &lt;code&gt;POSIX::islower()&lt;/code&gt; , and so on. For example, if you move from the &quot;C&quot; locale to a 7-bit ISO 646 one, you may find--possibly to your surprise--that &lt;code&gt;&quot;|&quot;&lt;/code&gt; moves from the &lt;code&gt;POSIX::ispunct()&lt;/code&gt; class to &lt;code&gt;POSIX::isalpha()&lt;/code&gt; . Unfortunately, this creates big problems for regular expressions. &quot;|&quot; still means alternation even though it matches &lt;code&gt;\w&lt;/code&gt; . Starting in v5.22, a warning will be raised when such a locale is switched into. More details are given several paragraphs further down.</source>
          <target state="translated">最后， &lt;code&gt;LC_CTYPE&lt;/code&gt; 影响（不建议使用的）POSIX字符类测试功能 &lt;code&gt;POSIX::isalpha()&lt;/code&gt; ， &lt;code&gt;POSIX::islower()&lt;/code&gt; 等。例如，如果您从&amp;ldquo; C&amp;rdquo;语言环境转换为7位ISO 646语言环境，可能会发现 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 可能使您感到惊讶- 从 &lt;code&gt;POSIX::ispunct()&lt;/code&gt; 类移动到 &lt;code&gt;POSIX::isalpha()&lt;/code&gt; 。不幸的是，这给正则表达式带来了很大的问题。 &amp;ldquo; |&amp;rdquo;即使匹配 &lt;code&gt;\w&lt;/code&gt; 仍然意味着交替。从v5.22开始，切换到这种语言环境时将发出警告。更详细的内容将在后面的几段中给出。</target>
        </trans-unit>
        <trans-unit id="d41a6a4619356e1937fb9383734f7392b639a1de" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;Perl_setlocale&lt;/code&gt; works under all circumstances, whereas plain &lt;code&gt;setlocale&lt;/code&gt; can be completely ineffective on some platforms under some configurations.</source>
          <target state="translated">最后， &lt;code&gt;Perl_setlocale&lt;/code&gt; 在所有情况下均可工作，而普通的 &lt;code&gt;setlocale&lt;/code&gt; 在某些配置下的某些平台上可能完全无效。</target>
        </trans-unit>
        <trans-unit id="3a072e67c07cec137145f02eb0728c6abe18c863" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;lock&lt;/code&gt; will traverse up references exactly</source>
          <target state="translated">最后， &lt;code&gt;lock&lt;/code&gt; 将精确遍历引用</target>
        </trans-unit>
        <trans-unit id="1e32346666d60836d8d3015ff2538a7278da0426" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;use integer;&lt;/code&gt; also has an additional affect on the bitwise operators. Normally, the operands and results are treated as &lt;b&gt;unsigned&lt;/b&gt; integers, but with &lt;code&gt;use integer;&lt;/code&gt; the operands and results are &lt;b&gt;signed&lt;/b&gt;. This means, among other things, that ~0 is -1, and -2 &amp;amp; -5 is -6.</source>
          <target state="translated">最后， &lt;code&gt;use integer;&lt;/code&gt; 对按位运算符也有附加影响。通常，操作数和结果被视为&lt;b&gt;无符号&lt;/b&gt;整数，但 &lt;code&gt;use integer;&lt;/code&gt; 操作数和结果均已&lt;b&gt;签名&lt;/b&gt;。除其他外，这意味着〜0为-1，而-2＆-5为-6。</target>
        </trans-unit>
        <trans-unit id="863cc6df01692aa36bb18136100716eadd4c9578" translate="yes" xml:space="preserve">
          <source>Finally, any other list of arguments is taken as a new list value for the KEY variable discarding the previous value.</source>
          <target state="translated">最后,任何其他的参数列表都会作为KEY变量的新列表值,丢弃之前的值。</target>
        </trans-unit>
        <trans-unit id="5736dff3a318282c51e7671e4d8cd7e83294c7ec" translate="yes" xml:space="preserve">
          <source>Finally, as a general note, try not to use an excessive amount of markup. As documented here and in &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt;, you can safely leave Perl variables, function names, man page references, and the like unadorned by markup and the POD translators will figure it out for you. This makes it much easier to later edit the documentation. Note that many existing translators will do the wrong thing with e-mail addresses when wrapped in L&amp;lt;&amp;gt;, so don't do that.</source>
          <target state="translated">最后，作为一般说明，请尽量不要使用过多的标记。如此处和&lt;a href=&quot;Pod::Man&quot;&gt;Pod :: Man中所述&lt;/a&gt;，您可以放心地保留Perl变量，函数名称，手册页引用等，而无需标记，POD转换器将为您解决。这使得以后编辑文档变得更加容易。请注意，许多现有的翻译器将它们包裹在L &amp;lt;&amp;gt;中时，会对电子邮件地址执行错误的操作，因此请不要这样做。</target>
        </trans-unit>
        <trans-unit id="2782a08306f78a46a43ca3f4245df407dada422a" translate="yes" xml:space="preserve">
          <source>Finally, as a general note, try not to use an excessive amount of markup. As documented here and in &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt;, you can safely leave Perl variables, function names, man page references, and the like unadorned by markup and the POD translators will figure it out for you. This makes it much easier to later edit the documentation. Note that many existing translators will do the wrong thing with e-mail addresses when wrapped in L&amp;lt;&amp;gt;, so don't do that.</source>
          <target state="translated">最后，作为一般说明，请尽量不要使用过多的标记。如此处和&lt;a href=&quot;pod/man&quot;&gt;Pod :: Man中所述&lt;/a&gt;，您可以放心地保留Perl变量，函数名称，手册页引用等，而无需标记，并且POD转换器将为您解决。这使得以后编辑文档变得更加容易。请注意，许多现有的翻译器将它们包裹在L &amp;lt;&amp;gt;中时，会对电子邮件地址执行错误的操作，因此请不要这样做。</target>
        </trans-unit>
        <trans-unit id="09dd5948c51d9dbe80c668a49680794506b31bfd" translate="yes" xml:space="preserve">
          <source>Finally, because Perl is frequently (but not always, and certainly not by definition) an interpreted language, you can write your programs and test them without an intermediate compilation step, allowing you to experiment and test/debug quickly and easily. This ease of experimentation flattens the learning curve even more.</source>
          <target state="translated">最后,由于Perl经常(但并不总是,当然也不是定义中的)是一种解释语言,你可以在没有中间编译步骤的情况下编写和测试你的程序,使你能够快速和轻松地进行实验和测试/调试。这种实验的方便性更使学习曲线变得平坦。</target>
        </trans-unit>
        <trans-unit id="cc57fb18e220062e45c185e13f725e4b2cd6843f" translate="yes" xml:space="preserve">
          <source>Finally, create a Pull Request on GitHub from your branch to blead as described in the GitHub documentation at &lt;a href=&quot;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork&quot;&gt;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork&lt;/a&gt;.</source>
          <target state="translated">最后，按照GitHub文档中&lt;a href=&quot;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork&quot;&gt;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork的&lt;/a&gt;说明，在您的分支机构的GitHub上创建一个请求请求进行引导。</target>
        </trans-unit>
        <trans-unit id="4a510065fc482271aa62171fe6b3a6de41010a11" translate="yes" xml:space="preserve">
          <source>Finally, documentation intended for core Perl developers lives in the</source>
          <target state="translated">最后,为Perl核心开发人员准备的文档存放在</target>
        </trans-unit>
        <trans-unit id="ef0d2a6fbc127dfe3fabf24f53dec0be787cb458" translate="yes" xml:space="preserve">
          <source>Finally, for backward (and we do mean &quot;backward&quot;) compatibility, Perl permits these unnecessary but widely-supported conversions:</source>
          <target state="translated">最后,为了向后(我们指的是 &quot;向后&quot;)兼容,Perl 允许这些不必要的但被广泛支持的转换。</target>
        </trans-unit>
        <trans-unit id="b81575352f8aab412fd4cb07d0470076b14f1f18" translate="yes" xml:space="preserve">
          <source>Finally, here is yet another way to do comma-separated value parsing:</source>
          <target state="translated">最后,这里还有一种方法可以进行逗号分隔的值解析。</target>
        </trans-unit>
        <trans-unit id="834a9815bc42b39ddd5279d8456b87a013959fa0" translate="yes" xml:space="preserve">
          <source>Finally, here's an example of the full typemap file for mapping C strings of the &lt;code&gt;char *&lt;/code&gt; type to Perl scalars/strings:</source>
          <target state="translated">最后，这是用于将 &lt;code&gt;char *&lt;/code&gt; 类型的C字符串映射到Perl标量/字符串的完整typemap文件的示例：</target>
        </trans-unit>
        <trans-unit id="bba57917092f0217e7811ec4321a57605d773dd9" translate="yes" xml:space="preserve">
          <source>Finally, if the command line ends with '&amp;amp;', the entire command is run in the background as an asynchronous subprocess.</source>
          <target state="translated">最后，如果命令行以&amp;ldquo;＆&amp;rdquo;结尾，则整个命令将作为异步子进程在后台运行。</target>
        </trans-unit>
        <trans-unit id="1e49365bee26ebdbc8e5446418348a20a97dc14c" translate="yes" xml:space="preserve">
          <source>Finally, if you feel like a real challenge, have a go at writing a full-blown Perl macro preprocessor as a source filter. Borrow the useful features from the C preprocessor and any other macro processors you know. The tricky bit will be choosing how much knowledge of Perl's syntax you want your filter to have.</source>
          <target state="translated">最后,如果你觉得自己是一个真正的挑战,可以试着写一个完整的Perl宏预处理器作为源过滤器。从 C 预处理器和其他你知道的宏处理器中借用有用的功能。棘手的是如何选择你希望你的过滤器拥有多少Perl语法知识。</target>
        </trans-unit>
        <trans-unit id="88728c279fead59f6cd8637f346aa4a89bc4ca1d" translate="yes" xml:space="preserve">
          <source>Finally, it searches down the C3 MRO list until it reaches the contextually enclosing class, then searches further down the MRO list for the next method with the same name as the contextually enclosing method.</source>
          <target state="translated">最后,它在C3 MRO列表中向下搜索,直到到达上下文包围类,然后再在MRO列表中向下搜索下一个与上下文包围方法同名的方法。</target>
        </trans-unit>
        <trans-unit id="d8f4b0ff247923b3eb8f0e0514234b9fa893f6fd" translate="yes" xml:space="preserve">
          <source>Finally, it's possible to override localtime and gmtime everywhere, by including the ':override' tag in the import list:</source>
          <target state="translated">最后,通过在导入列表中加入':override'标签,可以在所有地方覆盖localtime和gmtime。</target>
        </trans-unit>
        <trans-unit id="f5aad188b46d292eb5dea6e10dfb430bbcea6367" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that Perl might not be the right tool for every job. You're a much better advocate if your claims are reasonable and grounded in reality. Dogmatically advocating anything tends to make people discount your message. Be honest about possible disadvantages to your choice of Perl since any choice has trade-offs.</source>
          <target state="translated">最后,请记住,Perl可能并不是每个工作都适合的工具。如果你的主张是合理的,并且是基于现实的,那么你就是一个更好的倡导者。教条地鼓吹任何东西,往往会让人们对你的信息打折扣。对你选择Perl可能存在的缺点要诚实,因为任何选择都要有所取舍。</target>
        </trans-unit>
        <trans-unit id="12d654760faef187bf9fcd2c080146c42b559499" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that subpatterns created inside a DEFINE block count towards the absolute and relative number of captures, so this:</source>
          <target state="translated">最后,请记住,在DEFINE块内创建的子模式会计入捕获的绝对数和相对数,所以这。</target>
        </trans-unit>
        <trans-unit id="e50add68bf383c512c89d12d1f1fbdacf62aaedc" translate="yes" xml:space="preserve">
          <source>Finally, let's get those four fields. By now, you shouldn't have any problems with the first three fields - but how can we use the byte count of the data in the first field as a length for the data field? Here the codes &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; come to the rescue, as they permit jumping back and forth in the string to unpack.</source>
          <target state="translated">最后，让我们获得这四个字段。到目前为止，前三个字段应该没有任何问题-但是我们如何使用第一个字段中数据的字节数作为数据字段的长度？这里的代码 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;X&lt;/code&gt; 可以解救，因为它们允许在字符串中来回跳跃以解压。</target>
        </trans-unit>
        <trans-unit id="4c63136357795194b6348dcbe928896e7138655b" translate="yes" xml:space="preserve">
          <source>Finally, most properties related to decomposition are accessible via &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;.</source>
          <target state="translated">最后，大多数与分解相关的属性都可以通过&lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;访问。</target>
        </trans-unit>
        <trans-unit id="0bb929b935f9baf3ae2ecaa9eade20a81808b33d" translate="yes" xml:space="preserve">
          <source>Finally, most properties related to decomposition are accessible via &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;.</source>
          <target state="translated">最后，大多数与分解相关的属性都可以通过&lt;a href=&quot;unicode/normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;访问。</target>
        </trans-unit>
        <trans-unit id="de4b908f9ba516df7dd4589f61d68201fc354294" translate="yes" xml:space="preserve">
          <source>Finally, on NFS file systems the link count of the file handle does not always go to zero immediately after unlinking. Currently, this command is expected to fail on NFS disks.</source>
          <target state="translated">最后,在NFS文件系统上,文件句柄的链接计数并不总是在解除链接后立即归零。目前,这个命令在NFS磁盘上预计会失败。</target>
        </trans-unit>
        <trans-unit id="c0056d49190cd844d22da94e2f6a73f54ba22274" translate="yes" xml:space="preserve">
          <source>Finally, once the loop terminates (because we got a 0 or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in the queue, which serves as a note to terminate), we pass on the notice to our child, and wait for it to exit if we've created a child (lines 27 and 30).</source>
          <target state="translated">最后，一旦循环终止（因为队列中有0或 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，这是终止的记号），我们将通知传递给子级，并在创建子级后等待其退出（第27和30行）。</target>
        </trans-unit>
        <trans-unit id="32fe94e035cd45ddddcda4070bc6753cb09716c1" translate="yes" xml:space="preserve">
          <source>Finally, once the loop terminates (because we got a 0 or &lt;code&gt;undef&lt;/code&gt; in the queue, which serves as a note to terminate), we pass on the notice to our child, and wait for it to exit if we've created a child (lines 27 and 30).</source>
          <target state="translated">最后，一旦循环终止（因为队列中有0或 &lt;code&gt;undef&lt;/code&gt; ，这是终止的记号），我们将通知传递给子级，如果创建了子级，则等待其退出（第27和30行）。</target>
        </trans-unit>
        <trans-unit id="d4b58a368a203e349112a813fb51574ad5df46e1" translate="yes" xml:space="preserve">
          <source>Finally, quoted strings cannot span multiple lines. The general rule is that the identifier must be a string literal. Stick with that, and you should be safe.</source>
          <target state="translated">最后,引用的字符串不能跨越多行。一般的规则是,标识符必须是一个字符串文字。坚持这一点,你应该是安全的。</target>
        </trans-unit>
        <trans-unit id="826093a59348aea220454d887a381ab8cec4085f" translate="yes" xml:space="preserve">
          <source>Finally, see the published Unicode Standard (page numbers are from version 6.0.0), including these specific annexes and technical reports:</source>
          <target state="translated">最后,请看已发布的Unicode标准(页码是从6.0.0版本开始的),包括这些具体的附件和技术报告。</target>
        </trans-unit>
        <trans-unit id="8e4fc718922fd33861fef8abc551f702371be5ab" translate="yes" xml:space="preserve">
          <source>Finally, some built-ins (e.g. &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;) can't be overridden.</source>
          <target state="translated">最后，某些内置函数（例如 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; ）不能被覆盖。</target>
        </trans-unit>
        <trans-unit id="c0028dee23b87898288cc766ae53749c2f4ecb87" translate="yes" xml:space="preserve">
          <source>Finally, some built-ins (e.g. &lt;code&gt;exists&lt;/code&gt; or &lt;code&gt;grep&lt;/code&gt;) can't be overridden.</source>
          <target state="translated">最后，某些内置函数（例如 &lt;code&gt;exists&lt;/code&gt; 或 &lt;code&gt;grep&lt;/code&gt; ）不能被覆盖。</target>
        </trans-unit>
        <trans-unit id="fbb0bc03e6c567aa9d048447baa9b177ddc77752" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;b&gt;-i&lt;/b&gt; switch does not impede execution when no files are given on the command line. In this case, no backup is made (the original file cannot, of course, be determined) and processing proceeds from STDIN to STDOUT as might be expected.</source>
          <target state="translated">最后，当命令行上未提供任何文件时，&lt;b&gt;-i&lt;/b&gt;开关不会阻止执行。在这种情况下，不进行备份（当然不能确定原始文件），并且处理可能从STDIN进行到STDOUT。</target>
        </trans-unit>
        <trans-unit id="6e903744590309f2cbd34fe629a8e6cdbf621b80" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;//&lt;/code&gt; default delimiters for a match can be changed to arbitrary delimiters by putting an &lt;code&gt;'m'&lt;/code&gt; out front:</source>
          <target state="translated">最后， &lt;code&gt;//&lt;/code&gt; 匹配的默认定界符可以通过在前面加上 &lt;code&gt;'m'&lt;/code&gt; 来更改为任意定界符：</target>
        </trans-unit>
        <trans-unit id="042bc8fcc5c7d7efd6780c2133d47ab6beba3218" translate="yes" xml:space="preserve">
          <source>Finally, the Mytest.xs file should look something like this:</source>
          <target state="translated">最后,Mytest.xs文件应该是这样的。</target>
        </trans-unit>
        <trans-unit id="c759b85c1874191b3c67e6077ecccb7f1cac3596" translate="yes" xml:space="preserve">
          <source>Finally, the Perl community as a whole recognizes that respect for ownership of code, respect for artistic control, proper credit, and active effort to prevent unintentional code skew or communication gaps is vital to the health of the community and Perl itself. Members of a community should not normally have to resort to rules and laws to deal with each other, and this document, although it contains rules so as to be clear, is about an attitude and general approach. The first step in any dispute should be open communication, respect for opposing views, and an attempt at a compromise. In nearly every circumstance nothing more will be necessary, and certainly no more drastic measure should be used until every avenue of communication and discussion has failed.</source>
          <target state="translated">最后,整个Perl社区认识到,尊重代码的所有权,尊重艺术控制,适当的信用,以及积极努力防止无意的代码歪曲或交流差距,对社区和Perl本身的健康发展至关重要。一个社区的成员通常不应该求助于规则和法律来处理彼此之间的关系,本文档虽然包含了一些规则,以便明确,但它涉及的是一种态度和一般方法。任何争议的第一步应该是公开沟通,尊重反对意见,并尝试妥协。几乎在每一种情况下,都没有必要采取更多的措施,当然,在所有沟通和讨论的渠道都失败之前,不应采取更激烈的措施。</target>
        </trans-unit>
        <trans-unit id="64c2b89b8066b657581a5a8b0c2006c676558b10" translate="yes" xml:space="preserve">
          <source>Finally, the context stack pointer is actually decremented by &lt;code&gt;CX_POP(cx)&lt;/code&gt;. After this point, it's possible that that the current context frame could be overwritten by other contexts being pushed. Although things like ties and &lt;code&gt;DESTROY&lt;/code&gt; are supposed to work within a new context stack, it's best not to assume this. Indeed on debugging builds, &lt;code&gt;CX_POP(cx)&lt;/code&gt; deliberately sets &lt;code&gt;cx&lt;/code&gt; to null to detect code that is still relying on the field values in that context frame. Note in the &lt;code&gt;pp_leavesub()&lt;/code&gt; example above, we grab &lt;code&gt;blk_sub.retop&lt;/code&gt;</source>
          <target state="translated">最后，上下文堆栈指针实际上会减少 &lt;code&gt;CX_POP(cx)&lt;/code&gt; 。此后，当前上下文框架可能会被推送的其他上下文覆盖。尽管诸如tie和 &lt;code&gt;DESTROY&lt;/code&gt; 之类的东西应该在新的上下文堆栈中工作，但是最好不要假设这一点。实际上，在调试版本中， &lt;code&gt;CX_POP(cx)&lt;/code&gt; 故意将 &lt;code&gt;cx&lt;/code&gt; 设置为null来检测仍依赖于该上下文框架中字段值的代码。注意，在上面的 &lt;code&gt;pp_leavesub()&lt;/code&gt; 示例中，我们获取 &lt;code&gt;blk_sub.retop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73b5ad0b05d4d0374aa60aaf0eda94d058db5ae7" translate="yes" xml:space="preserve">
          <source>Finally, the documentation. The job is never done until the paperwork is over, so let's describe the change we've just made. The relevant place is</source>
          <target state="translated">最后是文档。文案工作没有结束之前,工作永远不会结束,所以我们来描述一下我们刚才的变化。相关的地方是</target>
        </trans-unit>
        <trans-unit id="80876825b2c59d50931c0454f32d3120b5201e0a" translate="yes" xml:space="preserve">
          <source>Finally, the following set of approaches was offered by Jeffrey Friedl, whose article in issue #5 of The Perl Journal talks about this very matter.</source>
          <target state="translated">最后,Jeffrey Friedl提供了以下一套方法,他在《The Perl Journal》第5期的文章就谈到了这个问题。</target>
        </trans-unit>
        <trans-unit id="3dff018de1b9478268177e77483e9300bee06c55" translate="yes" xml:space="preserve">
          <source>Finally, the message also can happen under the &lt;code&gt;/x&lt;/code&gt; regex modifier when the &lt;code&gt;\N&lt;/code&gt; is separated by spaces from the &lt;code&gt;{&lt;/code&gt;, in which case, remove the spaces.</source>
          <target state="translated">最后，当 &lt;code&gt;\N&lt;/code&gt; 与 &lt;code&gt;{&lt;/code&gt; 之间用空格分隔时，该消息也可能在 &lt;code&gt;/x&lt;/code&gt; regex修饰符下发生，在这种情况下，请删除空格。</target>
        </trans-unit>
        <trans-unit id="0a5ec48900bcd82fa327a360a4d32095f98f60a4" translate="yes" xml:space="preserve">
          <source>Finally, the modifier may be used with all of the forms mentioned above:</source>
          <target state="translated">最后,该修饰语可与上述所有形式一起使用。</target>
        </trans-unit>
        <trans-unit id="778ba92f0eda34f1617f29aaf6a42ae17012b6e9" translate="yes" xml:space="preserve">
          <source>Finally, the multiple-angle-bracket form does</source>
          <target state="translated">最后,多角括号的形式做了</target>
        </trans-unit>
        <trans-unit id="69cd41be402812aa1fc1573ee80c91588133088e" translate="yes" xml:space="preserve">
          <source>Finally, there is &lt;code&gt;cx_topblock(cx)&lt;/code&gt;, which acts like a super-&lt;code&gt;nextstate&lt;/code&gt; as regards to resetting various vars to their base values. It is used in places like &lt;code&gt;pp_next&lt;/code&gt;, &lt;code&gt;pp_redo&lt;/code&gt; and &lt;code&gt;pp_goto&lt;/code&gt; where rather than exiting a scope, we want to re-initialise the scope. As well as resetting &lt;code&gt;PL_stack_sp&lt;/code&gt; like &lt;code&gt;nextstate&lt;/code&gt;, it also resets &lt;code&gt;PL_markstack_ptr&lt;/code&gt;, &lt;code&gt;PL_scopestack_ix&lt;/code&gt; and &lt;code&gt;PL_curpm&lt;/code&gt;. Note that it doesn't do a &lt;code&gt;FREETMPS&lt;/code&gt;.</source>
          <target state="translated">最后，还有 &lt;code&gt;cx_topblock(cx)&lt;/code&gt; ，它在将各种变量重置为其基值方面起着超 &lt;code&gt;nextstate&lt;/code&gt; 作用。它用于 &lt;code&gt;pp_next&lt;/code&gt; ， &lt;code&gt;pp_redo&lt;/code&gt; 和 &lt;code&gt;pp_goto&lt;/code&gt; 之类的地方，而不是退出作用域，而是要重新初始化作用域。除了像 &lt;code&gt;nextstate&lt;/code&gt; 一样重置 &lt;code&gt;PL_stack_sp&lt;/code&gt; 之外，它还重置 &lt;code&gt;PL_markstack_ptr&lt;/code&gt; ， &lt;code&gt;PL_scopestack_ix&lt;/code&gt; 和 &lt;code&gt;PL_curpm&lt;/code&gt; 。请注意，它不会执行 &lt;code&gt;FREETMPS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63f8e8ad12d75d623f33e44387f1b276ef571892" translate="yes" xml:space="preserve">
          <source>Finally, there is a &lt;code&gt;LOGOP&lt;/code&gt; , or logic op. Like a &lt;code&gt;LISTOP&lt;/code&gt; , this has one or more children, but it doesn't have an &lt;code&gt;op_last&lt;/code&gt; field: so you have to follow &lt;code&gt;op_first&lt;/code&gt; and then the &lt;code&gt;OpSIBLING&lt;/code&gt; chain itself to find the last child. Instead it has an &lt;code&gt;op_other&lt;/code&gt; field, which is comparable to the &lt;code&gt;op_next&lt;/code&gt; field described below, and represents an alternate execution path. Operators like &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; are &lt;code&gt;LOGOP&lt;/code&gt; s. Note that in general, &lt;code&gt;op_other&lt;/code&gt; may not point to any of the direct children of the &lt;code&gt;LOGOP&lt;/code&gt; .</source>
          <target state="translated">最后，有一个 &lt;code&gt;LOGOP&lt;/code&gt; 或逻辑运算符。像 &lt;code&gt;LISTOP&lt;/code&gt; 一样，它具有一个或多个子代，但是它没有 &lt;code&gt;op_last&lt;/code&gt; 字段：因此，您必须先遵循 &lt;code&gt;op_first&lt;/code&gt; ，然后遵循 &lt;code&gt;OpSIBLING&lt;/code&gt; 链本身才能找到最后一个子代。相反，它具有一个 &lt;code&gt;op_other&lt;/code&gt; 字段，该字段与下面描述的 &lt;code&gt;op_next&lt;/code&gt; 字段相当，并且表示备用执行路径。运营商如 &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; 和 &lt;code&gt;?&lt;/code&gt; 是 &lt;code&gt;LOGOP&lt;/code&gt; 。请注意，通常， &lt;code&gt;op_other&lt;/code&gt; 不能指向LOGOP的任何直接 &lt;code&gt;LOGOP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b751f83017cbd5bbf78b027bd8e55f818cb0e53" translate="yes" xml:space="preserve">
          <source>Finally, there is a &lt;code&gt;LOGOP&lt;/code&gt;, or logic op. Like a &lt;code&gt;LISTOP&lt;/code&gt;, this has one or more children, but it doesn't have an &lt;code&gt;op_last&lt;/code&gt; field: so you have to follow &lt;code&gt;op_first&lt;/code&gt; and then the &lt;code&gt;OpSIBLING&lt;/code&gt; chain itself to find the last child. Instead it has an &lt;code&gt;op_other&lt;/code&gt; field, which is comparable to the &lt;code&gt;op_next&lt;/code&gt; field described below, and represents an alternate execution path. Operators like &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; are &lt;code&gt;LOGOP&lt;/code&gt;s. Note that in general, &lt;code&gt;op_other&lt;/code&gt; may not point to any of the direct children of the &lt;code&gt;LOGOP&lt;/code&gt;.</source>
          <target state="translated">最后，有一个 &lt;code&gt;LOGOP&lt;/code&gt; 或逻辑运算符。像 &lt;code&gt;LISTOP&lt;/code&gt; 一样，它具有一个或多个子代，但是它没有 &lt;code&gt;op_last&lt;/code&gt; 字段：因此，您必须先遵循 &lt;code&gt;op_first&lt;/code&gt; ，然后遵循 &lt;code&gt;OpSIBLING&lt;/code&gt; 链本身才能找到最后一个子代。相反，它具有一个 &lt;code&gt;op_other&lt;/code&gt; 字段，该字段与下面描述的 &lt;code&gt;op_next&lt;/code&gt; 字段相当，并且表示备用执行路径。运营商如 &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; 和 &lt;code&gt;?&lt;/code&gt; 是 &lt;code&gt;LOGOP&lt;/code&gt; 。请注意，通常， &lt;code&gt;op_other&lt;/code&gt; 不能指向LOGOP的任何直接 &lt;code&gt;LOGOP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a7cdec53bb27d155c030f9892a0eeb03fd88eb1" translate="yes" xml:space="preserve">
          <source>Finally, there is also an entirely different approach by unpacking big endian shorts and packing them in the reverse byte order:</source>
          <target state="translated">最后,还有一种完全不同的方法,将大恩迪安短裤拆开,按照相反的字节顺序打包。</target>
        </trans-unit>
        <trans-unit id="453b0692eb90c0dfa9ea5982b6a592f258b890f5" translate="yes" xml:space="preserve">
          <source>Finally, there is the code that actually does the filtering. For this type of Perl source filter, all the filtering is done in a method called &lt;code&gt;filter()&lt;/code&gt; . (It is also possible to write a Perl source filter using a closure. See the &lt;code&gt;Filter::Util::Call&lt;/code&gt; manual page for more details.) It's called every time the Perl parser needs another line of source to process. The &lt;code&gt;filter()&lt;/code&gt; method, in turn, reads lines from the source stream using the &lt;code&gt;filter_read()&lt;/code&gt; function.</source>
          <target state="translated">最后，还有实际执行过滤的代码。对于这种类型的Perl源过滤器，所有过滤都是通过称为 &lt;code&gt;filter()&lt;/code&gt; 的方法完成的。（也可以使用闭包编写Perl源过滤器。有关更多详细信息，请参见 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 手册页。）每次Perl解析器需要另一行源代码进行处理时都会调用该方法。所述 &lt;code&gt;filter()&lt;/code&gt; 方法，反过来，从读出用源极流线路 &lt;code&gt;filter_read()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="f63b79d41e03c44ce7102b1bce3292ba0ca343a6" translate="yes" xml:space="preserve">
          <source>Finally, there is the code that actually does the filtering. For this type of Perl source filter, all the filtering is done in a method called &lt;code&gt;filter()&lt;/code&gt;. (It is also possible to write a Perl source filter using a closure. See the &lt;code&gt;Filter::Util::Call&lt;/code&gt; manual page for more details.) It's called every time the Perl parser needs another line of source to process. The &lt;code&gt;filter()&lt;/code&gt; method, in turn, reads lines from the source stream using the &lt;code&gt;filter_read()&lt;/code&gt; function.</source>
          <target state="translated">最后，还有实际执行过滤的代码。对于这种类型的Perl源过滤器，所有过滤都是通过称为 &lt;code&gt;filter()&lt;/code&gt; 的方法完成的。（也可以使用闭包编写Perl源过滤器。有关更多详细信息，请参见 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 手册页。）每次Perl解析器需要另一行源代码进行处理时都会调用该方法。然后， &lt;code&gt;filter()&lt;/code&gt; 方法使用 &lt;code&gt;filter_read()&lt;/code&gt; 函数从源流中读取行。</target>
        </trans-unit>
        <trans-unit id="b70b6b76ef8b9f1c2f4e8ed6e19c93e5bed492e5" translate="yes" xml:space="preserve">
          <source>Finally, this technique can be used to implement a sort on a keyvalue pair list; e.g.:</source>
          <target state="translated">最后,这种技术可以用来实现对键值对列表的排序,例如:。</target>
        </trans-unit>
        <trans-unit id="dff384a2e72772724b586203a02673aa837c967d" translate="yes" xml:space="preserve">
          <source>Finally, using accessors makes inheritance much simpler. Subclasses can use the accessors rather than having to know how a parent class is implemented internally.</source>
          <target state="translated">最后,使用访问器使继承变得更加简单。子类可以使用访问器,而不必知道父类内部是如何实现的。</target>
        </trans-unit>
        <trans-unit id="0de55aa6b3e2509718d66dd5a0030529d86bf08c" translate="yes" xml:space="preserve">
          <source>Finally, we have &lt;a href=&quot;Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt;. This module truly lives up to its name. It has an incredibly minimal API and absolutely no dependencies on any recent Perl. Still, we think it's a lot easier to use than writing your own OO code from scratch.</source>
          <target state="translated">最后，我们有了&lt;a href=&quot;Class::Tiny&quot;&gt;Class :: Tiny&lt;/a&gt;。该模块确实符合其名称。它具有令人难以置信的最小的API，并且绝对不依赖于任何最新的Perl。尽管如此，我们认为使用它比从头开始编写自己的OO代码要容易得多。</target>
        </trans-unit>
        <trans-unit id="a0ee269426b10540758eda6f3baa910232cd84eb" translate="yes" xml:space="preserve">
          <source>Finally, we have &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt;. This module truly lives up to its name. It has an incredibly minimal API and absolutely no dependencies on any recent Perl. Still, we think it's a lot easier to use than writing your own OO code from scratch.</source>
          <target state="translated">最后，我们有了&lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class :: Tiny&lt;/a&gt;。该模块确实符合其名称。它具有令人难以置信的最小的API，并且绝对不依赖任何最新的Perl。尽管如此，我们认为使用它比从头开始编写自己的OO代码要容易得多。</target>
        </trans-unit>
        <trans-unit id="80f162582be94b96acbf3901ff2dad6e5237d61d" translate="yes" xml:space="preserve">
          <source>Finally, when &lt;code&gt;filter&lt;/code&gt; or the anonymous sub are finished processing, they are expected to return the filtered source using &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">最后，当 &lt;code&gt;filter&lt;/code&gt; 或匿名子程序完成处理后，它们将使用 &lt;code&gt;$_&lt;/code&gt; 返回过滤后的源。</target>
        </trans-unit>
        <trans-unit id="879473db2990543f072d8e3f8060a5f6514793f3" translate="yes" xml:space="preserve">
          <source>Finally, when &lt;code&gt;filter&lt;/code&gt; or the anonymous sub are finished processing, they are expected to return the filtered source using &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="translated">最后，当 &lt;code&gt;filter&lt;/code&gt; 或匿名子程序完成处理后，它们将使用 &lt;code&gt;$_&lt;/code&gt; 返回过滤后的源。</target>
        </trans-unit>
        <trans-unit id="237e2517518e5a7e38bf850e59773fff293d743f" translate="yes" xml:space="preserve">
          <source>Finally, you can append an optional third argument, in &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;,&lt;i&gt;arg2&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt;, where</source>
          <target state="translated">最后，您可以在 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;,&lt;i&gt;arg2&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt; 附加一个可选的第三个参数，其中</target>
        </trans-unit>
        <trans-unit id="e97f51f439c9ae965cec0b2dc4c4355eaa28a624" translate="yes" xml:space="preserve">
          <source>Finally, you should then delete the remote smoke-me branch:</source>
          <target state="translated">最后,你应该再删除远程烟我分支。</target>
        </trans-unit>
        <trans-unit id="694939534870b0a1edb23c3bf281899ee38f8c47" translate="yes" xml:space="preserve">
          <source>Finally, you'll need to copy the extension's Perl library module to the</source>
          <target state="translated">最后,你需要将扩展的Perl库模块复制到</target>
        </trans-unit>
        <trans-unit id="860f05ae24e478a14a3acf15fc650e6557c5de7d" translate="yes" xml:space="preserve">
          <source>Find POD documents in directory trees</source>
          <target state="translated">在目录树中查找POD文件</target>
        </trans-unit>
        <trans-unit id="e1857def4ee2d2eb29e93e010b1a0b29040a49b1" translate="yes" xml:space="preserve">
          <source>Find a named lexical anywhere in a chain of nested pads. Add fake entries in the inner pads if it's found in an outer one.</source>
          <target state="translated">在嵌套焊盘链的任何地方找到一个命名词条。如果在外侧的焊盘中找到,则在内侧的焊盘中添加假条目。</target>
        </trans-unit>
        <trans-unit id="4564f34f47e157e7d1dad65f67463f62f1be357a" translate="yes" xml:space="preserve">
          <source>Find an area of Perl that seems interesting to you, and see if you can work out how it works. Scan through the source, and step over it in the debugger. Play, poke, investigate, fiddle! You'll probably get to understand not just your chosen area but a much wider range of</source>
          <target state="translated">找出一个你感兴趣的Perl领域,看看你是否能找出它的工作原理。扫描源码,然后在调试器中踩过它。玩、戳、研究、摆弄! 你可能会了解到的不仅仅是你所选择的领域,而是更广泛的</target>
        </trans-unit>
        <trans-unit id="b0f962c203daff2b574f4bbd4661b46cb058cc00" translate="yes" xml:space="preserve">
          <source>Find and return the variable that is named &lt;code&gt;$_&lt;/code&gt; in the lexical scope of the currently-executing function. This may be a lexical &lt;code&gt;$_&lt;/code&gt; , or will otherwise be the global one.</source>
          <target state="translated">在当前执行的函数的词法范围内查找并返回名为 &lt;code&gt;$_&lt;/code&gt; 的变量。这可能是词汇 &lt;code&gt;$_&lt;/code&gt; ，否则将是全局的。</target>
        </trans-unit>
        <trans-unit id="f3987e57a4047735115abd7670e17ea834246318" translate="yes" xml:space="preserve">
          <source>Find close matches to the named modules that you think you might have mistyped. This requires the optional installation of Text::Levenshtein or Text::Levenshtein::Damerau.</source>
          <target state="translated">找出与你认为可能打错字的命名模块非常匹配的模块。这需要安装 Text::Levenshtein 或 Text::Levenshtein::Damerau。</target>
        </trans-unit>
        <trans-unit id="418498cca51e97a1b0d2b4c89d2b05e75464656f" translate="yes" xml:space="preserve">
          <source>Find out whether a plan has been defined. &lt;code&gt;$plan&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (no plan has been set), &lt;code&gt;no_plan&lt;/code&gt; (indeterminate # of tests) or an integer (the number of expected tests).</source>
          <target state="translated">查明是否已定义计划。 &lt;code&gt;$plan&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （未设置计划）， &lt;code&gt;no_plan&lt;/code&gt; （不确定测试数）或整数（预期测试数）。</target>
        </trans-unit>
        <trans-unit id="b7a3095b5282b9401d12f20b31b6ecddeb954040" translate="yes" xml:space="preserve">
          <source>Find out whether a plan has been defined. &lt;code&gt;$plan&lt;/code&gt; is either &lt;code&gt;undef&lt;/code&gt; (no plan has been set), &lt;code&gt;no_plan&lt;/code&gt; (indeterminate # of tests) or an integer (the number of expected tests).</source>
          <target state="translated">查明是否已定义计划。 &lt;code&gt;$plan&lt;/code&gt; 是 &lt;code&gt;undef&lt;/code&gt; （未设置计划）， &lt;code&gt;no_plan&lt;/code&gt; （不确定测试数）或整数（预期测试数）。</target>
        </trans-unit>
        <trans-unit id="7ca0c65ce5ae45823f61afddf86cef29c2b9896f" translate="yes" xml:space="preserve">
          <source>Find the best mirrors you could be using and use them for the current session.</source>
          <target state="translated">找到你可以使用的最好的镜子,并将其用于当前的环节。</target>
        </trans-unit>
        <trans-unit id="299f4826369de8d05aca882ad20a8c23e29f25dd" translate="yes" xml:space="preserve">
          <source>Find the directory name</source>
          <target state="translated">查找目录名</target>
        </trans-unit>
        <trans-unit id="6ff33fe789ed52358ad4a6f6237332d2d9560dc4" translate="yes" xml:space="preserve">
          <source>Find the first (leftmost) occurrence of a sequence of bytes within another sequence. This is the Perl version of &lt;code&gt;strstr()&lt;/code&gt;, extended to handle arbitrary sequences, potentially containing embedded &lt;code&gt;NUL&lt;/code&gt; characters (&lt;code&gt;NUL&lt;/code&gt; is what the initial &lt;code&gt;n&lt;/code&gt; in the function name stands for; some systems have an equivalent, &lt;code&gt;memmem()&lt;/code&gt;, but with a somewhat different API).</source>
          <target state="translated">查找另一个序列中字节序列的第一个（最左）出现。这是 &lt;code&gt;strstr()&lt;/code&gt; 的Perl版本，扩展为处理任意序列，可能包含嵌入的 &lt;code&gt;NUL&lt;/code&gt; 字符（ &lt;code&gt;NUL&lt;/code&gt; 是函数名称中的首字母 &lt;code&gt;n&lt;/code&gt; 代表的含义；某些系统具有等效的 &lt;code&gt;memmem()&lt;/code&gt; ，但有所不同API）。</target>
        </trans-unit>
        <trans-unit id="4ac57f2d73d65d94cbdbe0755aabac6325af065d" translate="yes" xml:space="preserve">
          <source>Find the general category of a numeric codepoint.</source>
          <target state="translated">找到一个数字码点的一般类别。</target>
        </trans-unit>
        <trans-unit id="c8f2ac7f85f4a8cad43d51157f3d77d5c06e4db0" translate="yes" xml:space="preserve">
          <source>Find the name of the undefined variable (if any) that caused the operator to issue a &quot;Use of uninitialized value&quot; warning. If match is true, only return a name if its value matches &lt;code&gt;uninit_sv&lt;/code&gt;. So roughly speaking, if a unary operator (such as &lt;code&gt;OP_COS&lt;/code&gt;) generates a warning, then following the direct child of the op may yield an &lt;code&gt;OP_PADSV&lt;/code&gt; or &lt;code&gt;OP_GV&lt;/code&gt; that gives the name of the undefined variable. On the other hand, with &lt;code&gt;OP_ADD&lt;/code&gt; there are two branches to follow, so we only print the variable name if we get an exact match. &lt;code&gt;desc_p&lt;/code&gt; points to a string pointer holding the description of the op. This may be updated if needed.</source>
          <target state="translated">查找导致操作员发出&amp;ldquo;使用未初始化的值&amp;rdquo;警告的未定义变量（如果有）的名称。如果match为true，则仅当名称的值与 &lt;code&gt;uninit_sv&lt;/code&gt; 匹配时才返回名称。粗略地说，如果一元运算符（例如 &lt;code&gt;OP_COS&lt;/code&gt; ）生成警告，则跟随op的直接子级可能会产生给出未定义变量名称的 &lt;code&gt;OP_PADSV&lt;/code&gt; 或 &lt;code&gt;OP_GV&lt;/code&gt; 。另一方面，对于 &lt;code&gt;OP_ADD&lt;/code&gt; ，要遵循两个分支，因此，只有在获得完全匹配的情况下，我们才打印变量名称。 &lt;code&gt;desc_p&lt;/code&gt; 指向保存操作说明的字符串指针。如果需要，可以进行更新。</target>
        </trans-unit>
        <trans-unit id="a49c3913d7af3c4d57a065a7a52f55890db2015f" translate="yes" xml:space="preserve">
          <source>Find the name of the undefined variable (if any) that caused the operator to issue a &quot;Use of uninitialized value&quot; warning. If match is true, only return a name if its value matches uninit_sv. So roughly speaking, if a unary operator (such as OP_COS) generates a warning, then following the direct child of the op may yield an OP_PADSV or OP_GV that gives the name of the undefined variable. On the other hand, with OP_ADD there are two branches to follow, so we only print the variable name if we get an exact match. desc_p points to a string pointer holding the description of the op. This may be updated if needed.</source>
          <target state="translated">找到导致操作者发出 &quot;使用未初始化值 &quot;警告的未定义变量的名称(如果有的话)。如果match为真,只有当它的值与uninit_sv匹配时,才返回一个名字。所以粗略地讲,如果一个单利运算符(比如OP_COS)产生了一个警告,那么跟随运算符的直接子代可能会产生一个OP_PADSV或OP_GV,给出未定义变量的名称。另一方面,对于OP_ADD来说,有两个分支可以跟随,所以我们只有在得到一个完全匹配的变量时才会打印出变量名。desc_p指向一个字符串指针,其中保存着op的描述。如果需要的话,可以对其进行更新。</target>
        </trans-unit>
        <trans-unit id="6ac43fb4e0d5bd1c0782abaa41490e339609fd8c" translate="yes" xml:space="preserve">
          <source>Find the position of the lexical &lt;code&gt;$_&lt;/code&gt; in the pad of the currently-executing function. Returns the offset in the current pad, or &lt;code&gt;NOT_IN_PAD&lt;/code&gt; if there is no lexical &lt;code&gt;$_&lt;/code&gt; in scope (in which case the global one should be used instead). &lt;a href=&quot;#find_rundefsv&quot;&gt;find_rundefsv&lt;/a&gt; is likely to be more convenient.</source>
          <target state="translated">在当前执行函数的填充中找到词法 &lt;code&gt;$_&lt;/code&gt; 的位置。返回当前填充中的偏移量；如果范围中没有词法 &lt;code&gt;$_&lt;/code&gt; ，则返回 &lt;code&gt;NOT_IN_PAD&lt;/code&gt; （在这种情况下，应使用全局值$ _代替）。&lt;a href=&quot;#find_rundefsv&quot;&gt;find_rundefsv&lt;/a&gt;可能更方便。</target>
        </trans-unit>
        <trans-unit id="449a6849d1b11914b85fc078a256f3db73a2b32b" translate="yes" xml:space="preserve">
          <source>Find the start position where a regex match should be attempted, or possibly if the regex engine should not be run because the pattern can't match. This is called, as appropriate, by the core, depending on the values of the &lt;code&gt;extflags&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure.</source>
          <target state="translated">找到应尝试进行正则表达式匹配的起始位置，或者找到可能由于模式不匹配而不运行正则表达式引擎的位置。这取决于内核，取决于 &lt;code&gt;regexp&lt;/code&gt; 结构的 &lt;code&gt;extflags&lt;/code&gt; 成员的值。</target>
        </trans-unit>
        <trans-unit id="6483e76c333ac42379066b4aedb6e408fdbe129b" translate="yes" xml:space="preserve">
          <source>FindBin</source>
          <target state="translated">FindBin</target>
        </trans-unit>
        <trans-unit id="24c31d2b2286d66b429b3c123e559310944ed2de" translate="yes" xml:space="preserve">
          <source>FindBin - Locate directory of original perl script</source>
          <target state="translated">FindBin-查找原始perl脚本的目录。</target>
        </trans-unit>
        <trans-unit id="4369a8a5c4e42e43d5e7bb66ccfd1c78f33f275a" translate="yes" xml:space="preserve">
          <source>FindBin - optional module which deals with paths relative to the source file.</source>
          <target state="translated">FindBin-可选模块,处理相对于源文件的路径。</target>
        </trans-unit>
        <trans-unit id="f086fc99759a8e3bb0203cfe84782842d1a193aa" translate="yes" xml:space="preserve">
          <source>FindBin is supported as part of the core perl distribution. Please send bug reports to &amp;lt;</source>
          <target state="translated">作为核心perl发行版的一部分，支持FindBin。请将错误报告发送给&amp;lt;</target>
        </trans-unit>
        <trans-unit id="9448bfafc842c027dacc4896519d4bae55c41c99" translate="yes" xml:space="preserve">
          <source>Finding IANA Character Set Registry names</source>
          <target state="translated">寻找IANA字符集注册表名称</target>
        </trans-unit>
        <trans-unit id="eef2fdb8cb6b261375ae8d62a702d5b95f90b35a" translate="yes" xml:space="preserve">
          <source>Finding Magic</source>
          <target state="translated">寻找魔法</target>
        </trans-unit>
        <trans-unit id="e4f6c5e89298ef6e35e80792cf1b54756849aae5" translate="yes" xml:space="preserve">
          <source>Finding and running system commands made easy</source>
          <target state="translated">查找和运行系统命令变得简单</target>
        </trans-unit>
        <trans-unit id="96480ceeb561d8e5864564872e9b2a46637a4002" translate="yes" xml:space="preserve">
          <source>Finding locales</source>
          <target state="translated">寻找地点</target>
        </trans-unit>
        <trans-unit id="3153f313a1b462b04bbeda7ea0617a540d2d82e4" translate="yes" xml:space="preserve">
          <source>Finding out your status</source>
          <target state="translated">了解您的状态</target>
        </trans-unit>
        <trans-unit id="87d12ac1eef851da5ad3ec16ab4427086784516f" translate="yes" xml:space="preserve">
          <source>Finding packages and VERSION</source>
          <target state="translated">寻找软件包和版本</target>
        </trans-unit>
        <trans-unit id="192a400dd7758944da905f5786b9b1af628198e2" translate="yes" xml:space="preserve">
          <source>Finding the end</source>
          <target state="translated">找到终点</target>
        </trans-unit>
        <trans-unit id="6d70dab88d530f69df03bc2322d08f1cd465a479" translate="yes" xml:space="preserve">
          <source>Finds the executables PERL and FULLPERL</source>
          <target state="translated">查找可执行文件PERL和FULLPERL。</target>
        </trans-unit>
        <trans-unit id="cb3d12363ae65c418567d25fa6af068fa57bcd89" translate="yes" xml:space="preserve">
          <source>Finds the magic pointer for &lt;code&gt;type&lt;/code&gt; matching the SV. See &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">查找与SV &lt;code&gt;type&lt;/code&gt; 匹配的魔术指针。参见 &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22bcd7072415a74f9601a9db40691f4be186016b" translate="yes" xml:space="preserve">
          <source>Finds the magic pointer for type matching the SV. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">查找与SV类型匹配的魔术指针。参见 &lt;code&gt;sv_magic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25d979215bfecc25b84803c1f222b66fe8c9e2ae" translate="yes" xml:space="preserve">
          <source>Finds the magic pointer of &lt;code&gt;type&lt;/code&gt; with the given &lt;code&gt;vtbl&lt;/code&gt; for the &lt;code&gt;SV&lt;/code&gt; . See &lt;code&gt;sv_magicext&lt;/code&gt; .</source>
          <target state="translated">查找的魔力指针 &lt;code&gt;type&lt;/code&gt; 与给定 &lt;code&gt;vtbl&lt;/code&gt; 为 &lt;code&gt;SV&lt;/code&gt; 。参见 &lt;code&gt;sv_magicext&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1508cd21f25aec8c8ff0233e3ab9fa73bbb76820" translate="yes" xml:space="preserve">
          <source>Finds the magic pointer of &lt;code&gt;type&lt;/code&gt; with the given &lt;code&gt;vtbl&lt;/code&gt; for the &lt;code&gt;SV&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#sv_magicext&quot;&gt;&quot;sv_magicext&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">查找的魔力指针 &lt;code&gt;type&lt;/code&gt; 与给定 &lt;code&gt;vtbl&lt;/code&gt; 为 &lt;code&gt;SV&lt;/code&gt; 。参见 &lt;code&gt;&lt;a href=&quot;#sv_magicext&quot;&gt;&quot;sv_magicext&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c909b138eba89ecfbd86df4c9d170ac78d4a3820" translate="yes" xml:space="preserve">
          <source>Finland</source>
          <target state="translated">Finland</target>
        </trans-unit>
        <trans-unit id="267b05432936f6d23e350d21b3fe892d9d8dbea3" translate="yes" xml:space="preserve">
          <source>Fire the debugger up again on your script and we'll look at the help menu. There's a couple of ways of calling help: a simple '&lt;b&gt;h&lt;/b&gt;' will get the summary help list, '&lt;b&gt;|h&lt;/b&gt;' (pipe-h) will pipe the help through your pager (which is (probably 'more' or 'less'), and finally, '&lt;b&gt;h h&lt;/b&gt;' (h-space-h) will give you the entire help screen. Here is the summary page:</source>
          <target state="translated">在脚本上再次启动调试器，我们将查看帮助菜单。有两种调用帮助的方法：简单的&amp;ldquo; &lt;b&gt;h&lt;/b&gt; &amp;rdquo;将获得摘要帮助列表，&amp;ldquo; &lt;b&gt;| h&lt;/b&gt; &amp;rdquo;（pipe-h）将通过您的寻呼机传递帮助（（可能是&amp;ldquo;更多&amp;rdquo;或&amp;ldquo;更少&amp;rdquo;）） ，最后，' &lt;b&gt;hh&lt;/b&gt; '（h-space-h）将为您提供整个帮助屏幕，以下是摘要页面：</target>
        </trans-unit>
        <trans-unit id="cef42e83f0eb4f1a99e0bddde90be004038a21df" translate="yes" xml:space="preserve">
          <source>Fires when Perl has successfully loaded an individual file, whether from &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;. This probe fires after the file is read from disk and its contents evaluated. The filename argument is converted to local filesystem paths instead of providing &lt;code&gt;Module::Name&lt;/code&gt; -style names.</source>
          <target state="translated">当Perl成功加载单个文件（无论是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 还是 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; )时触发。从磁盘读取文件并评估其内容后，将触发此探针。filename参数将转换为本地文件系统路径，而不是提供 &lt;code&gt;Module::Name&lt;/code&gt; 样式名称。</target>
        </trans-unit>
        <trans-unit id="757a897afd699db960721899607f96100462820d" translate="yes" xml:space="preserve">
          <source>Fires when Perl has successfully loaded an individual file, whether from &lt;code&gt;use&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, or &lt;code&gt;do&lt;/code&gt;. This probe fires after the file is read from disk and its contents evaluated. The filename argument is converted to local filesystem paths instead of providing &lt;code&gt;Module::Name&lt;/code&gt;-style names.</source>
          <target state="translated">当Perl成功加载单个文件（无论是 &lt;code&gt;use&lt;/code&gt; ， &lt;code&gt;require&lt;/code&gt; 还是 &lt;code&gt;do&lt;/code&gt; )时触发。从磁盘读取文件并评估其内容后，将触发此探针。filename参数将转换为本地文件系统路径，而不是提供 &lt;code&gt;Module::Name&lt;/code&gt; 样式名称。</target>
        </trans-unit>
        <trans-unit id="7704de478a9404e667918d6d09d2c1e3a1cb6a87" translate="yes" xml:space="preserve">
          <source>Fires when Perl is about to load an individual file, whether from &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;. This probe fires before the file is read from disk. The filename argument is converted to local filesystem paths instead of providing &lt;code&gt;Module::Name&lt;/code&gt; -style names.</source>
          <target state="translated">当Perl即将加载单个文件（无论是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 还是 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; )时触发。从磁盘读取文件之前将触发此探针。filename参数将转换为本地文件系统路径，而不是提供 &lt;code&gt;Module::Name&lt;/code&gt; 样式名称。</target>
        </trans-unit>
        <trans-unit id="b9f10e7adabcd669986aa11e5c555213012ea407" translate="yes" xml:space="preserve">
          <source>Fires when Perl is about to load an individual file, whether from &lt;code&gt;use&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, or &lt;code&gt;do&lt;/code&gt;. This probe fires before the file is read from disk. The filename argument is converted to local filesystem paths instead of providing &lt;code&gt;Module::Name&lt;/code&gt;-style names.</source>
          <target state="translated">当Perl即将加载单个文件（无论是 &lt;code&gt;use&lt;/code&gt; ， &lt;code&gt;require&lt;/code&gt; 还是 &lt;code&gt;do&lt;/code&gt; )时触发。从磁盘读取文件之前将触发此探针。filename参数将转换为本地文件系统路径，而不是提供 &lt;code&gt;Module::Name&lt;/code&gt; 样式名称。</target>
        </trans-unit>
        <trans-unit id="49d7fed0e266f24545d9104466ab74b18bdd8f35" translate="yes" xml:space="preserve">
          <source>Firewalls can be categorized into three basic types.</source>
          <target state="translated">防火墙可分为三种基本类型。</target>
        </trans-unit>
        <trans-unit id="a00bc27da396d3a81b2819430816be98253f7657" translate="yes" xml:space="preserve">
          <source>First In, First Out. See also &lt;b&gt;LIFO&lt;/b&gt;. Also a nickname for a &lt;b&gt;named pipe&lt;/b&gt;.</source>
          <target state="translated">先进先出。另请参阅&lt;b&gt;LIFO&lt;/b&gt;。也是&lt;b&gt;命名管道&lt;/b&gt;的昵称。</target>
        </trans-unit>
        <trans-unit id="8fe7145d9c6c14d380f19ecbb52aad0be3d15872" translate="yes" xml:space="preserve">
          <source>First available in Perl 5.10.1 (the 5.10.0 version behaved differently), binary &lt;code&gt;~~&lt;/code&gt; does a &quot;smartmatch&quot; between its arguments. This is mostly used implicitly in the &lt;code&gt;when&lt;/code&gt; construct described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;, although not all &lt;code&gt;when&lt;/code&gt; clauses call the smartmatch operator. Unique among all of Perl's operators, the smartmatch operator can recurse. The smartmatch operator is &lt;a href=&quot;perlpolicy#experimental&quot;&gt;experimental&lt;/a&gt; and its behavior is subject to change.</source>
          <target state="translated">二进制 &lt;code&gt;~~&lt;/code&gt; 最早在Perl 5.10.1（5.10.0版本的行为有所不同）中提供，它的参数之间进行&amp;ldquo; 智能匹配&amp;rdquo;。尽管不是所有的 &lt;code&gt;when&lt;/code&gt; 子句都调用smartmatch运算符，但&lt;a href=&quot;perlsyn&quot;&gt;通常&lt;/a&gt;在perlsyn中描述的 &lt;code&gt;when&lt;/code&gt; 构造中隐式使用它。在所有Perl运算符中唯一的，smartmatch运算符可以递归。 smartmatch运算符是&lt;a href=&quot;perlpolicy#experimental&quot;&gt;实验性的&lt;/a&gt;，其行为可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="63af0ded76d246a89c78d019ed5af7004abaf7ca" translate="yes" xml:space="preserve">
          <source>First does a distdir. Then a command $(PREOP) which defaults to a null command, followed by $(TO_UNIX), which defaults to a null command under UNIX, and will convert files in distribution directory to UNIX format otherwise. Next it runs &lt;code&gt;tar&lt;/code&gt; on that directory into a tarfile and deletes the directory. Finishes with a command $(POSTOP) which defaults to a null command.</source>
          <target state="translated">首先执行distdir。然后是默认情况下为空命令的命令$（PREOP），然后是UNIX下默认为空命令的$（TO_UNIX），并将分发目录中的文件转换为UNIX格式。接下来，它将在该目录上运行 &lt;code&gt;tar&lt;/code&gt; 到tarfile中并删除该目录。以命令$（POSTOP）结尾，该命令默认为空命令。</target>
        </trans-unit>
        <trans-unit id="2af22b932d239ecb2692524f84027e701417e610" translate="yes" xml:space="preserve">
          <source>First does a distdir. Then a command $(PREOP) which defaults to a null command. Next it runs &lt;code&gt;shar&lt;/code&gt; on that directory into a sharfile and deletes the intermediate directory again. Finishes with a command $(POSTOP) which defaults to a null command. Note: For shdist to work properly a &lt;code&gt;shar&lt;/code&gt; program that can handle directories is mandatory.</source>
          <target state="translated">首先执行distdir。然后是一个默认为空命令的命令$（PREOP）。接下来，它将在该目录上运行 &lt;code&gt;shar&lt;/code&gt; 到sharfile中，然后再次删除中间目录。以命令$（POSTOP）结尾，该命令默认为空命令。注意：为了使shdist正常工作，必须具有可以处理目录的 &lt;code&gt;shar&lt;/code&gt; 程序。</target>
        </trans-unit>
        <trans-unit id="32b6865bf0f3ae68c2cf337647431ed6a911b654" translate="yes" xml:space="preserve">
          <source>First does a distdir. Then a command $(PREOP) which defaults to a null command. Runs &lt;code&gt;$(ZIP) $(ZIPFLAGS)&lt;/code&gt; on that directory into a zipfile. Then deletes that directory. Finishes with a command $(POSTOP) which defaults to a null command.</source>
          <target state="translated">首先执行distdir。然后是一个默认为空命令的命令$（PREOP）。在该目录 &lt;code&gt;$(ZIP) $(ZIPFLAGS)&lt;/code&gt; 运行到一个zip文件中。然后删除该目录。以命令$（POSTOP）结尾，该命令默认为空命令。</target>
        </trans-unit>
        <trans-unit id="94aa237f5671c72c12a3009e96b0d0c3b639055e" translate="yes" xml:space="preserve">
          <source>First example to &lt;code&gt;use deprecate;&lt;/code&gt; was &lt;a href=&quot;switch&quot;&gt;Switch&lt;/a&gt;.</source>
          <target state="translated">第一个 &lt;code&gt;use deprecate;&lt;/code&gt; 示例；是&lt;a href=&quot;switch&quot;&gt;Switch&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87237cd69962d954afc8149676070ba7e99a30f3" translate="yes" xml:space="preserve">
          <source>First is the &quot;transitional compilation environment&quot;, described in lfcompile64(5). According to the man page,</source>
          <target state="translated">首先是 &quot;过渡性编译环境&quot;,在lfcompile64(5)中描述。根据man页面的介绍。</target>
        </trans-unit>
        <trans-unit id="39f2e43e592aba75880c16ffdbd2296c6893e732" translate="yes" xml:space="preserve">
          <source>First of all &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; gets the type of the third parameter ('CODE' in this case). &lt;code&gt;attributes.pm&lt;/code&gt; checks if there is a subroutine called &lt;code&gt;MODIFY_&amp;lt;reftype&amp;gt;_ATTRIBUTES&lt;/code&gt; in the caller's namespace (here: 'main'). In this case a subroutine &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; is required. Then this method is called to check if you have used a &quot;bad attribute&quot;. The subroutine call in this example would look like</source>
          <target state="translated">首先 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 获取第三个参数的类型（在这种情况下为&amp;ldquo; CODE&amp;rdquo;）。 &lt;code&gt;attributes.pm&lt;/code&gt; 检查调用者的名称空间（此处为&amp;ldquo; main&amp;rdquo;）中是否存在一个名为 &lt;code&gt;MODIFY_&amp;lt;reftype&amp;gt;_ATTRIBUTES&lt;/code&gt; 的子例程。在这种情况下，需要一个子程序 &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; 。然后调用此方法以检查您是否使用了&amp;ldquo;不良属性&amp;rdquo;。这个例子中的子程序调用看起来像</target>
        </trans-unit>
        <trans-unit id="b7822424c868e3dc633b16628199202fe7a79904" translate="yes" xml:space="preserve">
          <source>First of all &lt;code&gt;import&lt;/code&gt; gets the type of the third parameter ('CODE' in this case). &lt;code&gt;attributes.pm&lt;/code&gt; checks if there is a subroutine called &lt;code&gt;MODIFY_&amp;lt;reftype&amp;gt;_ATTRIBUTES&lt;/code&gt; in the caller's namespace (here: 'main'). In this case a subroutine &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; is required. Then this method is called to check if you have used a &quot;bad attribute&quot;. The subroutine call in this example would look like</source>
          <target state="translated">首先 &lt;code&gt;import&lt;/code&gt; 获取第三个参数的类型（在这种情况下为&amp;ldquo; CODE&amp;rdquo;）。 &lt;code&gt;attributes.pm&lt;/code&gt; 检查在调用者的名称空间（此处为&amp;ldquo; main&amp;rdquo;）中是否存在一个名为 &lt;code&gt;MODIFY_&amp;lt;reftype&amp;gt;_ATTRIBUTES&lt;/code&gt; 的子例程。在这种情况下，需要一个子程序 &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; 。然后调用此方法以检查您是否使用了&amp;ldquo;不良属性&amp;rdquo;。本例中的子例程调用看起来像</target>
        </trans-unit>
        <trans-unit id="a5edeb3fa4c30eb9326cfd6ee3072f89d302a7fb" translate="yes" xml:space="preserve">
          <source>First of all note that if you're doing this for security reasons (to avoid people seeing passwords, for example) then you should rewrite your program so that critical information is never given as an argument. Hiding the arguments won't make your program completely secure.</source>
          <target state="translated">首先要注意,如果你是出于安全的考虑(例如,为了避免人们看到密码),那么你应该重写你的程序,使关键信息永远不作为参数给出。隐藏参数不会让你的程序完全安全。</target>
        </trans-unit>
        <trans-unit id="02342cfce74aa40ebbe7459fd67794792aa8eda6" translate="yes" xml:space="preserve">
          <source>First of all note that you have full access to the Symbian device when using Perl: you can do a lot of damage to your device (like removing system files) unless you are careful. Please do take backups before doing anything.</source>
          <target state="translated">首先要注意,使用Perl时,你可以完全访问Symbian设备:除非你小心翼翼,否则你可能会对你的设备造成很大的损害(比如删除系统文件)。请在做任何事情之前进行备份。</target>
        </trans-unit>
        <trans-unit id="82d1faba2416c529064d9e355ea5a87b152dcd77" translate="yes" xml:space="preserve">
          <source>First of all, have you tried using &lt;a href=&quot;strict&quot;&gt;&lt;code&gt;use strict;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;&lt;code&gt;use warnings;&lt;/code&gt;&lt;/a&gt;?</source>
          <target state="translated">首先，您是否尝试过使用&lt;a href=&quot;strict&quot;&gt; &lt;code&gt;use strict;&lt;/code&gt; &lt;/a&gt;并&lt;a href=&quot;warnings&quot;&gt; &lt;code&gt;use warnings;&lt;/code&gt; &lt;/a&gt;？</target>
        </trans-unit>
        <trans-unit id="1463803ecb1c9b404836c68a0992ffedefb430c0" translate="yes" xml:space="preserve">
          <source>First of all, have you tried using the &lt;b&gt;-w&lt;/b&gt; switch?</source>
          <target state="translated">首先，您是否尝试过使用&lt;b&gt;-w&lt;/b&gt;开关？</target>
        </trans-unit>
        <trans-unit id="a4f52d54cf15399bdc6e2cfb2dc28b7c88455e40" translate="yes" xml:space="preserve">
          <source>First of all, however, you</source>
          <target state="translated">然而,首先,你</target>
        </trans-unit>
        <trans-unit id="83147c6de1b08740dd2da15332f4959df7841375" translate="yes" xml:space="preserve">
          <source>First of all, there's a few things you can do to make your life a lot more straightforward when it comes to debugging perl programs, without using the debugger at all. To demonstrate, here's a simple script, named &quot;hello&quot;, with a problem:</source>
          <target state="translated">首先,在调试perl程序的时候,有一些事情可以让你的生活变得更加简单,完全不用调试器。为了演示,这里有一个简单的脚本,名为 &quot;hello&quot;,有一个问题。</target>
        </trans-unit>
        <trans-unit id="04c84bafcaec13f658619ad91db4027ae060911a" translate="yes" xml:space="preserve">
          <source>First of all, when doing a match, one may get no run-time output even if debugging is enabled. This means that the regex engine was never entered and that all of the job was therefore done by the optimizer.</source>
          <target state="translated">首先,在进行匹配时,即使启用了调试,也可能得不到运行时的输出。这意味着从未输入过regex引擎,因此所有的工作都由优化器完成。</target>
        </trans-unit>
        <trans-unit id="960494596b28f0ed04786d5db795d0496594f162" translate="yes" xml:space="preserve">
          <source>First off, you must have zlib 1.0.5 or better.</source>
          <target state="translated">首先,你必须有zlib 1.0.5或更高版本。</target>
        </trans-unit>
        <trans-unit id="69ce5e02622d1bff00c96b8c962f42da114efb4f" translate="yes" xml:space="preserve">
          <source>First problem: deciding which functions will be public API functions and which will be private. All functions whose names begin &lt;code&gt;S_&lt;/code&gt; are private (think &quot;S&quot; for &quot;secret&quot; or &quot;static&quot;). All other functions begin with &quot;Perl_&quot;, but just because a function begins with &quot;Perl_&quot; does not mean it is part of the API. (See &lt;a href=&quot;#Internal-Functions&quot;&gt;&quot;Internal Functions&quot;&lt;/a&gt;.) The easiest way to be &lt;b&gt;sure&lt;/b&gt; a function is part of the API is to find its entry in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;. If it exists in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;, it's part of the API. If it doesn't, and you think it should be (i.e., you need it for your extension), submit an issue at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; explaining why you think it should be.</source>
          <target state="translated">第一个问题：确定哪些函数将是公共API函数，哪些将是私有的。名称以 &lt;code&gt;S_&lt;/code&gt; 开头的所有函数都是私有的（将&amp;ldquo; S&amp;rdquo;表示为&amp;ldquo;秘密&amp;rdquo;或&amp;ldquo;静态&amp;rdquo;）。所有其他函数均以&amp;ldquo; Perl_&amp;rdquo;开头，但是仅因为函数以&amp;ldquo; Perl_&amp;rdquo;开头并不意味着它是API的一部分。 （请参阅&lt;a href=&quot;#Internal-Functions&quot;&gt;&amp;ldquo;内部函数&amp;rdquo;&lt;/a&gt;。）&lt;b&gt;确保&lt;/b&gt;函数是API一部分的最简单方法是在&lt;a href=&quot;perlapi&quot;&gt;perlapi中&lt;/a&gt;找到其条目。如果它存在于&lt;a href=&quot;perlapi&quot;&gt;perlapi中&lt;/a&gt;，则它是API的一部分。如果不是这样，并且您认为应该这样做（即，您的扩展程序需要它），请在&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues上&lt;/a&gt;提交问题，以解释您认为应该这样做的原因。</target>
        </trans-unit>
        <trans-unit id="5548dc2d3eeb7fa10ed6d62335952f1161d1be5c" translate="yes" xml:space="preserve">
          <source>First problem: deciding which functions will be public API functions and which will be private. All functions whose names begin &lt;code&gt;S_&lt;/code&gt; are private (think &quot;S&quot; for &quot;secret&quot; or &quot;static&quot;). All other functions begin with &quot;Perl_&quot;, but just because a function begins with &quot;Perl_&quot; does not mean it is part of the API. (See &lt;a href=&quot;#Internal-Functions&quot;&gt;Internal Functions&lt;/a&gt;.) The easiest way to be &lt;b&gt;sure&lt;/b&gt; a function is part of the API is to find its entry in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;. If it exists in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;, it's part of the API. If it doesn't, and you think it should be (i.e., you need it for your extension), send mail via &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; explaining why you think it should be.</source>
          <target state="translated">第一个问题：确定哪些函数将是公共API函数，哪些将是私有API。名称以 &lt;code&gt;S_&lt;/code&gt; 开头的所有功能都是私有的（将&amp;ldquo; S&amp;rdquo;表示为&amp;ldquo;秘密&amp;rdquo;或&amp;ldquo;静态&amp;rdquo;）。所有其他函数均以&amp;ldquo; Perl_&amp;rdquo;开头，但是仅因为函数以&amp;ldquo; Perl_&amp;rdquo;开头并不意味着它是API的一部分。 （请参阅&lt;a href=&quot;#Internal-Functions&quot;&gt;内部函数&lt;/a&gt;。）&lt;b&gt;确保&lt;/b&gt;函数是API一部分的最简单方法是在&lt;a href=&quot;perlapi&quot;&gt;perlapi中&lt;/a&gt;找到其条目。如果它存在于&lt;a href=&quot;perlapi&quot;&gt;perlapi中&lt;/a&gt;，则它是API的一部分。如果不是，并且您认为应该是这样（即，您的扩展程序需要它），则通过&lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt;发送邮件，说明您认为应该这样做的原因。</target>
        </trans-unit>
        <trans-unit id="6d90388b269f11ed13790611d5c39ef23068273b" translate="yes" xml:space="preserve">
          <source>First release of port to 5.16.3.</source>
          <target state="translated">首次发布到5.16.3的版本。</target>
        </trans-unit>
        <trans-unit id="6c6d177453ba632a0301eb097966ff6e4ecd7e13" translate="yes" xml:space="preserve">
          <source>First runs the &lt;code&gt;get&lt;/code&gt; method to make sure the distribution is downloaded and unpacked. Changes to the directory where the distribution has been unpacked and runs the external commands &lt;code&gt;perl
Makefile.PL&lt;/code&gt; or &lt;code&gt;perl Build.PL&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; there.</source>
          <target state="translated">首先运行 &lt;code&gt;get&lt;/code&gt; 方法，以确保分发已下载并解压缩。更改到已解压缩发行版的目录，并运行外部命令 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 或 &lt;code&gt;perl Build.PL&lt;/code&gt; 并 &lt;code&gt;make&lt;/code&gt; 此处进行。</target>
        </trans-unit>
        <trans-unit id="8990c7669972aeb5dbf3f8f7c6f26f615b1eba3b" translate="yes" xml:space="preserve">
          <source>First try</source>
          <target state="translated">第一次尝试</target>
        </trans-unit>
        <trans-unit id="8c24340fb0abf478cd12d4c9a81be46a9b570102" translate="yes" xml:space="preserve">
          <source>First version July 22, 1998; last revised November 21, 2001.</source>
          <target state="translated">1998年7月22日第一版;2001年11月21日最后一次修订。</target>
        </trans-unit>
        <trans-unit id="31fb5f76604a7e6f413356e0c06e90b3583d1c3f" translate="yes" xml:space="preserve">
          <source>First we need to create a temporary new branch for these changes and switch into it:</source>
          <target state="translated">首先我们需要为这些变化创建一个临时的新分支,并切换到它。</target>
        </trans-unit>
        <trans-unit id="ed5b85580c1cc1af9d07f10dd52a32a103df1c0f" translate="yes" xml:space="preserve">
          <source>First we start with which characters to include. We call this collection of characters</source>
          <target state="translated">首先,我们要从包含哪些字符开始。我们称这个字符集合为</target>
        </trans-unit>
        <trans-unit id="f0bcb6253b995340d8661abf6d3eb20fd1447df3" translate="yes" xml:space="preserve">
          <source>First you extract the keys from the hashes into lists, then solve the &quot;removing duplicates&quot; problem described above. For example:</source>
          <target state="translated">首先你要把哈希中的键提取成列表,然后解决上面所说的 &quot;去除重复 &quot;的问题。比如说</target>
        </trans-unit>
        <trans-unit id="2044f5e8e1c516409eb219e4d2d2da652d96754d" translate="yes" xml:space="preserve">
          <source>First you get the BS2000 commandline prompt ('*'). Here you may enter your parameters, e.g. &lt;code&gt;-e 'print &quot;Hello World!\\n&quot;;'&lt;/code&gt; (note the double backslash!) or &lt;code&gt;-w&lt;/code&gt; and the name of your Perl script. Filenames starting with &lt;code&gt;/&lt;/code&gt; are searched in the Posix filesystem, others are searched in the BS2000 filesystem. You may even use wildcards if you put a &lt;code&gt;%&lt;/code&gt; in front of your filename (e.g. &lt;code&gt;-w
checkfiles.pl %*.c&lt;/code&gt; ). Read your C/C++ manual for additional possibilities of the commandline prompt (look for PARAMETER-PROMPTING).</source>
          <target state="translated">首先，您会看到BS2000命令行提示符（'*'）。在这里您可以输入参数，例如 &lt;code&gt;-e 'print &quot;Hello World!\\n&quot;;'&lt;/code&gt; （请注意双反斜杠！）或 &lt;code&gt;-w&lt;/code&gt; 以及Perl脚本的名称。在Posix文件系统中搜索以 &lt;code&gt;/&lt;/code&gt; 开头的文件名，在BS2000文件系统中搜索其他文件名。如果在文件名前加上 &lt;code&gt;%&lt;/code&gt; ，甚至可以使用通配符（例如 &lt;code&gt;-w checkfiles.pl %*.c&lt;/code&gt; ）。阅读您的C / C ++手册，以获取命令行提示符的其他可能性（查找PARAMETER-PROMPTING）。</target>
        </trans-unit>
        <trans-unit id="0e1074481eb31b2beb0a93b170e055ca8fbaf015" translate="yes" xml:space="preserve">
          <source>First you get the BS2000 commandline prompt ('*'). Here you may enter your parameters, e.g. &lt;code&gt;-e 'print &quot;Hello World!\\n&quot;;'&lt;/code&gt; (note the double backslash!) or &lt;code&gt;-w&lt;/code&gt; and the name of your Perl script. Filenames starting with &lt;code&gt;/&lt;/code&gt; are searched in the Posix filesystem, others are searched in the BS2000 filesystem. You may even use wildcards if you put a &lt;code&gt;%&lt;/code&gt; in front of your filename (e.g. &lt;code&gt;-w checkfiles.pl %*.c&lt;/code&gt;). Read your C/C++ manual for additional possibilities of the commandline prompt (look for PARAMETER-PROMPTING).</source>
          <target state="translated">首先，您会看到BS2000命令行提示符（&amp;ldquo; *&amp;rdquo;）。在这里您可以输入参数，例如 &lt;code&gt;-e 'print &quot;Hello World!\\n&quot;;'&lt;/code&gt; （请注意双反斜杠！）或 &lt;code&gt;-w&lt;/code&gt; 以及您的Perl脚本的名称。在Posix文件系统中搜索以 &lt;code&gt;/&lt;/code&gt; 开头的文件名，在BS2000文件系统中搜索其他文件名。如果在文件名前加上 &lt;code&gt;%&lt;/code&gt; ，甚至可以使用通配符（例如 &lt;code&gt;-w checkfiles.pl %*.c&lt;/code&gt; ）。阅读您的C / C ++手册，以了解命令行提示符的其他可能性（请查看PARAMETER-PROMPTING）。</target>
        </trans-unit>
        <trans-unit id="69813602a455899e097cd99c025cf3e1ca0fd741" translate="yes" xml:space="preserve">
          <source>First you'll need to know how to convert between C types and Perl types, with newSViv() and sv_setnv() and newAV() and all their friends. They're described in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">首先，您需要了解如何使用newSViv（）和sv_setnv（）和newAV（）及其所有朋友在C类型和Perl类型之间进行转换。在&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;和&lt;a href=&quot;perlapi&quot;&gt;perlapi中对&lt;/a&gt;它们进行了描述。</target>
        </trans-unit>
        <trans-unit id="d47635cc5b345a29da6fbd6f1b60ef579fbee7af" translate="yes" xml:space="preserve">
          <source>First,</source>
          <target state="translated">First,</target>
        </trans-unit>
        <trans-unit id="d7c19c1fc6c3dbafd3921057c37d39372855cf85" translate="yes" xml:space="preserve">
          <source>First, adding the new possessive &lt;code&gt;+&lt;/code&gt; to any quantifier finds the longest match and does not backtrack. That's important since you want to handle any angle brackets through the recursion, not backtracking. The group &lt;code&gt;[^&amp;lt;&amp;gt;]++&lt;/code&gt; finds one or more non-angle brackets without backtracking.</source>
          <target state="translated">首先，将新的所有格 &lt;code&gt;+&lt;/code&gt; 添加到任何量词中会找到最长的匹配项，并且不会回溯。这很重要，因为您希望通过递归而不是回溯来处理任何尖括号。组 &lt;code&gt;[^&amp;lt;&amp;gt;]++&lt;/code&gt; 查找一个或多个无尖括号而没有回溯。</target>
        </trans-unit>
        <trans-unit id="50b1a9b57fc0e96ef3cb9ee0ed192e6dd3187f0f" translate="yes" xml:space="preserve">
          <source>First, an easy one. Rather than having debugging code that is all-or-nothing, it would be much more useful to be able to control which specific blocks of debugging code get included. Try extending the syntax for debug blocks to allow each to be identified. The contents of the &lt;code&gt;DEBUG&lt;/code&gt; environment variable can then be used to control which blocks get included.</source>
          <target state="translated">首先，一个简单的。而不是拥有全部或全部的调试代码，能够控制包含哪些特定的调试代码块将更加有用。尝试扩展调试块的语法以允许识别每个块。然后可以使用 &lt;code&gt;DEBUG&lt;/code&gt; 环境变量的内容来控制包含哪些块。</target>
        </trans-unit>
        <trans-unit id="3f1e59ee032bf3e9e20cd69af8996ee89b862626" translate="yes" xml:space="preserve">
          <source>First, are you sure that the module isn't already on your system? Try &lt;code&gt;perl -MFoo -e 1&lt;/code&gt; . (Replace &quot;Foo&quot; with the name of the module; for instance, &lt;code&gt;perl -MCGI::Carp -e 1&lt;/code&gt; .)</source>
          <target state="translated">首先，您确定该模块尚未在系统上吗？尝试使用 &lt;code&gt;perl -MFoo -e 1&lt;/code&gt; 。（用模块名称替换&amp;ldquo; Foo&amp;rdquo;；例如， &lt;code&gt;perl -MCGI::Carp -e 1&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="7b89c936bc5ff3bf6eeb7c0528bfdef316cf1b24" translate="yes" xml:space="preserve">
          <source>First, are you sure that the module isn't already on your system? Try &lt;code&gt;perl -MFoo -e 1&lt;/code&gt;. (Replace &quot;Foo&quot; with the name of the module; for instance, &lt;code&gt;perl -MCGI::Carp -e 1&lt;/code&gt;.)</source>
          <target state="translated">首先，您确定该模块尚未在您的系统上吗？尝试使用 &lt;code&gt;perl -MFoo -e 1&lt;/code&gt; 。 （用模块名称替换&amp;ldquo; Foo&amp;rdquo;；例如， &lt;code&gt;perl -MCGI::Carp -e 1&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="5ebaf97085b1af9a8aca032d5654d4392116d444" translate="yes" xml:space="preserve">
          <source>First, download the module package from CPAN (e.g., the &quot;Comma Separated Value&quot; text package, Text-CSV-0.01.tar.gz). Then expand the contents of the package into some location on your disk. Most CPAN modules are built with an internal directory structure, so it is usually safe to expand it in the root of your DJGPP installation. Some people prefer to locate source trees under /usr/src (i.e., &lt;code&gt;($DJDIR)/usr/src&lt;/code&gt; ), but you may put it wherever seems most logical to you, *EXCEPT* under the same directory as your perl source code. There are special rules that apply to modules which live in the perl source tree that do not apply to most of the modules in CPAN.</source>
          <target state="translated">首先，从CPAN下载模块包（例如，&amp;ldquo;逗号分隔值&amp;rdquo;文本包Text-CSV-0.01.tar.gz）。然后，将软件包的内容扩展到磁盘上的某些位置。大多数CPAN模块都使用内部目录结构构建，因此通常可以在DJGPP安装的根目录中对其进行扩展。有些人更喜欢将源树定位在/ usr / src下（即 &lt;code&gt;($DJDIR)/usr/src&lt;/code&gt; ），但是您可以将它放在最适合您的地方，* EXCEPT *与perl源代码位于同一目录下。有一些适用于perl源代码树中的模块的特殊规则，不适用于CPAN中的大多数模块。</target>
        </trans-unit>
        <trans-unit id="a4cf2a47c74d08c7608aab2490244eccf86d59a1" translate="yes" xml:space="preserve">
          <source>First, download the module package from CPAN (e.g., the &quot;Comma Separated Value&quot; text package, Text-CSV-0.01.tar.gz). Then expand the contents of the package into some location on your disk. Most CPAN modules are built with an internal directory structure, so it is usually safe to expand it in the root of your DJGPP installation. Some people prefer to locate source trees under /usr/src (i.e., &lt;code&gt;($DJDIR)/usr/src&lt;/code&gt;), but you may put it wherever seems most logical to you, *EXCEPT* under the same directory as your perl source code. There are special rules that apply to modules which live in the perl source tree that do not apply to most of the modules in CPAN.</source>
          <target state="translated">首先，从CPAN下载模块包（例如，&amp;ldquo;逗号分隔值&amp;rdquo;文本包Text-CSV-0.01.tar.gz）。然后，将软件包的内容扩展到磁盘上的某个位置。大多数CPAN模块都是使用内部目录结构构建的，因此通常可以在DJGPP安装目录的根目录中对其进行扩展。有些人更喜欢将源树定位在/ usr / src下（即 &lt;code&gt;($DJDIR)/usr/src&lt;/code&gt; ），但是您可以将它放在最适合您的地方，* EXCEPT *与perl源代码位于同一目录下。有一些适用于perl源代码树中的模块的特殊规则，不适用于CPAN中的大多数模块。</target>
        </trans-unit>
        <trans-unit id="6bd8c84d305c51b13e814aea0158d4e7f9348781" translate="yes" xml:space="preserve">
          <source>First, ensure that you've found an actual bug. Second, ensure you've found an actual bug.</source>
          <target state="translated">首先,确保你已经发现了一个实际的错误。第二,确保你已经发现了一个实际的bug。</target>
        </trans-unit>
        <trans-unit id="ae1f5078345edb7a706a89221e3d6b7ce9cef2cd" translate="yes" xml:space="preserve">
          <source>First, export the path to the SDK into the build environment:</source>
          <target state="translated">首先,将SDK的路径导出到构建环境中。</target>
        </trans-unit>
        <trans-unit id="f736b2c3892c2f343a0b6266829dd11c79e488a9" translate="yes" xml:space="preserve">
          <source>First, get rid of the libperl.dylib:</source>
          <target state="translated">首先,去掉libperl.dylib。</target>
        </trans-unit>
        <trans-unit id="152625e23957ee1b161f4b03465822ac30d6d72d" translate="yes" xml:space="preserve">
          <source>First, it can be confusing to read. In the above example, it's not clear if &lt;code&gt;save&lt;/code&gt; is a method provided by the &lt;code&gt;File&lt;/code&gt; class or simply a subroutine that expects a file object as its first argument.</source>
          <target state="translated">首先，它可能使阅读混乱。在上面的示例中，不清楚 &lt;code&gt;save&lt;/code&gt; 是 &lt;code&gt;File&lt;/code&gt; 类提供的方法还是仅将文件对象作为第一个参数的子例程。</target>
        </trans-unit>
        <trans-unit id="9d7b42a2c11d81d6afadf3ea1e473b60b0c267e3" translate="yes" xml:space="preserve">
          <source>First, it determines the linearized C3 MRO of the object or class it is being called on.</source>
          <target state="translated">首先,它确定被调用的对象或类的线性化C3 MRO。</target>
        </trans-unit>
        <trans-unit id="fb4ac5a946a8d4958fc6dfdd3a7c2b8f9b12b58f" translate="yes" xml:space="preserve">
          <source>First, let's look at reading it in from a file. This is something like adding a row at a time. We'll assume that there's a flat file in which each line is a row and each word an element. If you're trying to develop an @AoA array containing all these, here's the right way to do that:</source>
          <target state="translated">首先,我们来看看从文件中读进去。这就像一次添加一行一样。我们假设有一个平面文件,其中每行是一行,每个字是一个元素。如果你想开发一个包含所有这些内容的@AoA数组,这里有一个正确的方法。</target>
        </trans-unit>
        <trans-unit id="78e2d97b2606f5e4646f167be6edb794b2d59b32" translate="yes" xml:space="preserve">
          <source>First, make a local branch and switch to it:</source>
          <target state="translated">首先,做一个本地分支,然后切换到它。</target>
        </trans-unit>
        <trans-unit id="7e9e25e60917815bcdbb3181b9454d4fd283b6a1" translate="yes" xml:space="preserve">
          <source>First, make sure you have the latest &lt;b&gt;cpan-mac&lt;/b&gt; distribution ( &lt;a href=&quot;http://www.cpan.org/authors/id/CNANDOR/&quot;&gt;http://www.cpan.org/authors/id/CNANDOR/&lt;/a&gt; ), which has utilities for doing all of the steps. Read the cpan-mac directions carefully and install it. If you choose not to use cpan-mac for some reason, there are alternatives listed here.</source>
          <target state="translated">首先，请确保您拥有最新的&lt;b&gt;cpan-mac&lt;/b&gt;发行版（&lt;a href=&quot;http://www.cpan.org/authors/id/CNANDOR/&quot;&gt;http://www.cpan.org/authors/id/CNANDOR/&lt;/a&gt;），该发行版具有执行所有步骤的实用程序。仔细阅读cpan-mac的说明并安装。如果出于某种原因选择不使用cpan-mac，则此处列出了替代方法。</target>
        </trans-unit>
        <trans-unit id="9ff45e7f3f7ac11b2b708c0549868f02253d3144" translate="yes" xml:space="preserve">
          <source>First, please read &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; for details on hacking the Perl core. That document covers many details on how to create a good patch.</source>
          <target state="translated">首先，请阅读&lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt;以获取有关破解Perl内核的详细信息。该文档涵盖了有关如何创建一个好的补丁的许多细节。</target>
        </trans-unit>
        <trans-unit id="5e4209086a0693a3c62d398c3fd3a79469cf0aa1" translate="yes" xml:space="preserve">
          <source>First, read &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode Security Considerations&lt;/a&gt;.</source>
          <target state="translated">首先，阅读&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode安全注意事项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f75f2ff97115a58ce045c83a79898c0c702db3b" translate="yes" xml:space="preserve">
          <source>First, read &lt;a href=&quot;https://www.unicode.org/reports/tr36&quot;&gt;Unicode Security Considerations&lt;/a&gt;.</source>
          <target state="translated">首先，阅读&lt;a href=&quot;https://www.unicode.org/reports/tr36&quot;&gt;Unicode安全注意事项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1be4fd7c33f5ba283ee1991244bc33bbae5e14ad" translate="yes" xml:space="preserve">
          <source>First, remember that &lt;code&gt;[1, 2, 3]&lt;/code&gt; makes an anonymous array containing &lt;code&gt;(1, 2, 3)&lt;/code&gt; , and gives you a reference to that array.</source>
          <target state="translated">首先，请记住 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 会创建一个包含 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 的匿名数组，并为您提供对该数组的引用。</target>
        </trans-unit>
        <trans-unit id="2c9778c828ac452ecd15f39d014e052e50b62a3b" translate="yes" xml:space="preserve">
          <source>First, remember that &lt;code&gt;[1, 2, 3]&lt;/code&gt; makes an anonymous array containing &lt;code&gt;(1, 2, 3)&lt;/code&gt;, and gives you a reference to that array.</source>
          <target state="translated">首先，请记住 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 会创建一个包含 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 的匿名数组，并为您提供对该数组的引用。</target>
        </trans-unit>
        <trans-unit id="1aab1dc764048d005c10306d35fb8721fb57f5b8" translate="yes" xml:space="preserve">
          <source>First, see earlier in this document about &lt;a href=&quot;#Finding-locales&quot;&gt;&quot;Finding locales&quot;&lt;/a&gt;. That tells how to find which locales are really supported--and more importantly, installed--on your system. In our example error message, environment variables affecting the locale are listed in the order of decreasing importance (and unset variables do not matter). Therefore, having LC_ALL set to &quot;En_US&quot; must have been the bad choice, as shown by the error message. First try fixing locale settings listed first.</source>
          <target state="translated">首先，请参见本文档前面的&lt;a href=&quot;#Finding-locales&quot;&gt;&amp;ldquo;查找语言环境&amp;rdquo;&lt;/a&gt;。这说明了如何找到系统上真正支持（更重要的是已安装）的语言环境。在我们的示例错误消息中，影响区域设置的环境变量按重要性递减的顺序列出（未设置的变量无关紧要）。因此，将LC_ALL设置为&amp;ldquo; En_US&amp;rdquo;一定是错误的选择，如错误消息所示。首先尝试修复首先列出的语言环境设置。</target>
        </trans-unit>
        <trans-unit id="ab31ac192075d493669c9807b4d74587336e2089" translate="yes" xml:space="preserve">
          <source>First, see earlier in this document about &lt;a href=&quot;#Finding-locales&quot;&gt;Finding locales&lt;/a&gt;. That tells how to find which locales are really supported--and more importantly, installed--on your system. In our example error message, environment variables affecting the locale are listed in the order of decreasing importance (and unset variables do not matter). Therefore, having LC_ALL set to &quot;En_US&quot; must have been the bad choice, as shown by the error message. First try fixing locale settings listed first.</source>
          <target state="translated">首先，请参阅本文档前面有关&lt;a href=&quot;#Finding-locales&quot;&gt;查找语言环境的内容&lt;/a&gt;。这说明了如何查找系统上确实支持（更重要的是已安装）的语言环境。在我们的示例错误消息中，影响区域设置的环境变量按重要性递减的顺序列出（未设置的变量无关紧要）。因此，将LC_ALL设置为&amp;ldquo; En_US&amp;rdquo;一定是错误的选择，如错误消息所示。首先尝试修复首先列出的区域设置。</target>
        </trans-unit>
        <trans-unit id="c27578c07f284f149f1e59f8dc0cd46db350e08e" translate="yes" xml:space="preserve">
          <source>First, see the answer to &quot;Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?&quot;.</source>
          <target state="translated">首先,请看 &quot;为什么我得到的是长小数(例如,19.9499999999999),而不是我应该得到的数字(例如,19.95)?&quot;的答案。</target>
        </trans-unit>
        <trans-unit id="c7929df02929344c4da8c51ff70c78d4168b4050" translate="yes" xml:space="preserve">
          <source>First, type &lt;code&gt;ppm&lt;/code&gt; from a shell and see whether ActiveState's PPM repository has your module. If so, you can install it with &lt;code&gt;ppm&lt;/code&gt; and you won't have to bother with any of the other steps here. You might be able to use the CPAN instructions from the &quot;Unix or Linux&quot; section above as well; give it a try. Otherwise, you'll have to follow the steps below.</source>
          <target state="translated">首先，从外壳程序中键入 &lt;code&gt;ppm&lt;/code&gt; ，然后查看ActiveState的PPM存储库是否包含您的模块。如果是这样，您可以在 &lt;code&gt;ppm&lt;/code&gt; 上安装它，而无需在这里进行任何其他步骤。您也许也可以使用上面&amp;ldquo; Unix或Linux&amp;rdquo;部分中的CPAN指令。试试看。否则，您将必须执行以下步骤。</target>
        </trans-unit>
        <trans-unit id="4cf149afbf1f752337e23fcd4bf31955a925b612" translate="yes" xml:space="preserve">
          <source>First, we can calculate the plan dynamically using the &lt;code&gt;plan()&lt;/code&gt; function.</source>
          <target state="translated">首先，我们可以使用 &lt;code&gt;plan()&lt;/code&gt; 函数动态地计算计划。</target>
        </trans-unit>
        <trans-unit id="faab21d0b75e81479aa73f86a04f0c512fa41039" translate="yes" xml:space="preserve">
          <source>First, we include the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module, which exports a number of functions into your filter's namespace. The filter shown above uses two of these functions, &lt;code&gt;filter_add()&lt;/code&gt; and &lt;code&gt;filter_read()&lt;/code&gt; .</source>
          <target state="translated">首先，我们包含 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 模块，该模块将许多函数导出到过滤器的名称空间中。上面显示的过滤器使用其中两个函数 &lt;code&gt;filter_add()&lt;/code&gt; 和 &lt;code&gt;filter_read()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7666b71edfd993b3751616f817f20d8eb76a68d" translate="yes" xml:space="preserve">
          <source>First, we include the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module, which exports a number of functions into your filter's namespace. The filter shown above uses two of these functions, &lt;code&gt;filter_add()&lt;/code&gt; and &lt;code&gt;filter_read()&lt;/code&gt;.</source>
          <target state="translated">首先，我们包含 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 模块，该模块将许多函数导出到过滤器的名称空间中。上面显示的过滤器使用其中两个函数 &lt;code&gt;filter_add()&lt;/code&gt; 和 &lt;code&gt;filter_read()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bf86c04e9a07ad8ffe5ebc09738e5cc682edbbb" translate="yes" xml:space="preserve">
          <source>First, we note that this time-honored 16-bit CPU uses little-endian order, and that's why the low order byte is stored at the lower address. To unpack such a (unsigned) short we'll have to use code &lt;code&gt;v&lt;/code&gt; . A repeat count unpacks all 12 shorts:</source>
          <target state="translated">首先，我们注意到这个历史悠久的16位CPU使用低位字节序，这就是为什么低位字节存储在低位地址的原因。要解压缩这样的（无符号）短代码，我们必须使用代码 &lt;code&gt;v&lt;/code&gt; 。重复计数可以解开所有12条短裤：</target>
        </trans-unit>
        <trans-unit id="08bfd01e98e4edde23ed3f05bac3b5bc4b695e5c" translate="yes" xml:space="preserve">
          <source>First, we note that this time-honored 16-bit CPU uses little-endian order, and that's why the low order byte is stored at the lower address. To unpack such a (unsigned) short we'll have to use code &lt;code&gt;v&lt;/code&gt;. A repeat count unpacks all 12 shorts:</source>
          <target state="translated">首先，我们注意到这个历史悠久的16位CPU使用低位字节序，这就是为什么低位字节存储在低位地址的原因。要解压缩这样的（无符号）短代码，我们必须使用代码 &lt;code&gt;v&lt;/code&gt; 。重复计数可以解开所有12条短裤：</target>
        </trans-unit>
        <trans-unit id="5ec66f264026749a912802e1ee6df172076171fc" translate="yes" xml:space="preserve">
          <source>First, we'll look at the &lt;code&gt;Perl_yylex&lt;/code&gt; function in the lexer. We want to look for &lt;code&gt;case 'x'&lt;/code&gt;, where x is the first character of the operator. (Incidentally, when looking for the code that handles a keyword, you'll want to search for &lt;code&gt;KEY_foo&lt;/code&gt; where &quot;foo&quot; is the keyword.) Here is the code that handles assignment (there are quite a few operators beginning with &lt;code&gt;=&lt;/code&gt;, so most of it is omitted for brevity):</source>
          <target state="translated">首先，我们将研究词法分析器中的 &lt;code&gt;Perl_yylex&lt;/code&gt; 函数。我们要查找 &lt;code&gt;case 'x'&lt;/code&gt; ，其中x是运算符的第一个字符。（顺便说一句，在查找处理关键字的代码时，您将需要搜索 &lt;code&gt;KEY_foo&lt;/code&gt; ，其中&amp;ldquo; foo&amp;rdquo;是关键字。）这是处理赋值的代码（有很多以 &lt;code&gt;=&lt;/code&gt; 开头的运算符，所以大多数为了简洁起见，将其省略）：</target>
        </trans-unit>
        <trans-unit id="d040ecc2c88831fcb5be8f38daefabb27bdc8362" translate="yes" xml:space="preserve">
          <source>First, what is the op tree, anyway? The op tree is the parsed representation of your program, as we saw in our section on parsing, and it's the sequence of operations that Perl goes through to execute your program, as we saw in &lt;a href=&quot;#Running&quot;&gt;&quot;Running&quot;&lt;/a&gt;.</source>
          <target state="translated">首先，反正是什么树？正如我们在解析部分中所看到的那样，op树是您的程序的解析表示形式，这是Perl执行程序的操作序列，如我们在&lt;a href=&quot;#Running&quot;&gt;&amp;ldquo; Running&amp;rdquo;中&lt;/a&gt;所看到的。</target>
        </trans-unit>
        <trans-unit id="e1ae10fa25857645a38bd9df4324915b8e49d413" translate="yes" xml:space="preserve">
          <source>First, what is the op tree, anyway? The op tree is the parsed representation of your program, as we saw in our section on parsing, and it's the sequence of operations that Perl goes through to execute your program, as we saw in &lt;a href=&quot;#Running&quot;&gt;Running&lt;/a&gt;.</source>
          <target state="translated">首先，什么是操作树？正如我们在解析部分中所看到的那样，op树是您的程序的解析表示形式，就像在&lt;a href=&quot;#Running&quot;&gt;Running中&lt;/a&gt;所见，它是Perl执行程序的操作序列。</target>
        </trans-unit>
        <trans-unit id="9fd0da866187697a74c7a4d585f209f050b0a6ff" translate="yes" xml:space="preserve">
          <source>First:</source>
          <target state="translated">First:</target>
        </trans-unit>
        <trans-unit id="cd289dddd1b3873e3f239eb60db04e88470eea20" translate="yes" xml:space="preserve">
          <source>Firstly when &lt;code&gt;inflate&lt;/code&gt; has returned a status other than &lt;code&gt;Z_OK&lt;/code&gt; or &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; . This means that either the end of the compressed data stream has been reached (&lt;code&gt;Z_STREAM_END&lt;/code&gt; ) or there is an error in the compressed data. In either of these cases there is no point in continuing with reading the compressed data, so both loops are terminated.</source>
          <target state="translated">首先，当 &lt;code&gt;inflate&lt;/code&gt; 返回比其他状态 &lt;code&gt;Z_OK&lt;/code&gt; 或 &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; 。这意味着已达到压缩数据流的末尾（ &lt;code&gt;Z_STREAM_END&lt;/code&gt; ）或压缩数据中存在错误。在这两种情况下，继续读取压缩数据都是没有意义的，因此两个循环都终止了。</target>
        </trans-unit>
        <trans-unit id="580dea99b6376e56628cd97fc38cd26b362ae9be" translate="yes" xml:space="preserve">
          <source>Firstly when &lt;code&gt;inflate&lt;/code&gt; has returned a status other than &lt;code&gt;Z_OK&lt;/code&gt; or &lt;code&gt;Z_BUF_ERROR&lt;/code&gt;. This means that either the end of the compressed data stream has been reached (&lt;code&gt;Z_STREAM_END&lt;/code&gt;) or there is an error in the compressed data. In either of these cases there is no point in continuing with reading the compressed data, so both loops are terminated.</source>
          <target state="translated">首先，当 &lt;code&gt;inflate&lt;/code&gt; 返回比其他状态 &lt;code&gt;Z_OK&lt;/code&gt; 或 &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; 。这意味着已达到压缩数据流的末尾（ &lt;code&gt;Z_STREAM_END&lt;/code&gt; ）或压缩数据中存在错误。在这两种情况下，继续读取压缩数据都是没有意义的，因此两个循环都终止了。</target>
        </trans-unit>
        <trans-unit id="e91097a50eee7fb0157c9c563333af1f9aad192e" translate="yes" xml:space="preserve">
          <source>Firstly with &lt;code&gt;uncompress&lt;/code&gt;</source>
          <target state="translated">首先用 &lt;code&gt;uncompress&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c691ee82803b4a1c09fe4ae85950833e593adf1e" translate="yes" xml:space="preserve">
          <source>Firstly, copy the source and build a native copy of perl for your host system. Then, in the source to be cross compiled:</source>
          <target state="translated">首先,复制源码,为你的主机系统建立一个perl的本地副本。然后,在源码中进行交叉编译。</target>
        </trans-unit>
        <trans-unit id="b281be44ff171ec4ca97b3cec7cdd79193f13686" translate="yes" xml:space="preserve">
          <source>Firstly, here is code that uses &lt;code&gt;retr&lt;/code&gt; to uncompressed a file as it is read from the FTP Server.</source>
          <target state="translated">首先，这里是使用 &lt;code&gt;retr&lt;/code&gt; 来解压缩从FTP服务器读取文件的文件的代码。</target>
        </trans-unit>
        <trans-unit id="429b0e6343c2120d22b3e87cee9b0d4bae245bf0" translate="yes" xml:space="preserve">
          <source>Firstly, the code is considerably more complex than with the previous example.</source>
          <target state="translated">首先,代码比前面的例子要复杂得多。</target>
        </trans-unit>
        <trans-unit id="276509a617a885ae6ba6cc6313c1176be3ee48f5" translate="yes" xml:space="preserve">
          <source>Firstly, when either &lt;code&gt;filter&lt;/code&gt; or the anonymous sub are called, a local copy of &lt;code&gt;$_&lt;/code&gt; will automatically be created. It will always contain the empty string at this point.</source>
          <target state="translated">首先，当调用 &lt;code&gt;filter&lt;/code&gt; 或匿名子程序时，将自动创建 &lt;code&gt;$_&lt;/code&gt; 的本地副本。此时，它将始终包含空字符串。</target>
        </trans-unit>
        <trans-unit id="2cac4ae7495bba4659c20ff2b612b63d1529752e" translate="yes" xml:space="preserve">
          <source>Firstly, you need to establish a baseline time for the existing code, which timing needs to be reliable and repeatable. You'll probably want to use the &lt;code&gt;Benchmark&lt;/code&gt; or &lt;code&gt;Devel::NYTProf&lt;/code&gt; modules, or something similar, for this step, or perhaps the Unix system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility, whichever is appropriate. See the base of this document for a longer list of benchmarking and profiling modules, and recommended further reading.</source>
          <target state="translated">首先，您需要为现有代码建立基准时间，该时间必须可靠且可重复。您可能需要在此步骤中使用 &lt;code&gt;Benchmark&lt;/code&gt; 或 &lt;code&gt;Devel::NYTProf&lt;/code&gt; 模块或类似的模块，或者使用Unix系统 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 实用程序（以适当的为准）。有关基准测试和性能分析模块的详细列表，请参见本文档的基础，并建议进一步阅读。</target>
        </trans-unit>
        <trans-unit id="0912ace39576f3bff8ff6347fdfed9f37c93af54" translate="yes" xml:space="preserve">
          <source>Firstly, you need to establish a baseline time for the existing code, which timing needs to be reliable and repeatable. You'll probably want to use the &lt;code&gt;Benchmark&lt;/code&gt; or &lt;code&gt;Devel::NYTProf&lt;/code&gt; modules, or something similar, for this step, or perhaps the Unix system &lt;code&gt;time&lt;/code&gt; utility, whichever is appropriate. See the base of this document for a longer list of benchmarking and profiling modules, and recommended further reading.</source>
          <target state="translated">首先，您需要为现有代码建立基准时间，该时间必须可靠且可重复。您可能要在此步骤中使用 &lt;code&gt;Benchmark&lt;/code&gt; 或 &lt;code&gt;Devel::NYTProf&lt;/code&gt; 模块或类似的模块，或者使用Unix系统 &lt;code&gt;time&lt;/code&gt; 实用程序（以适当的为准）。有关基准测试和性能分析模块的详细列表，请参见本文档的基础，并建议进一步阅读。</target>
        </trans-unit>
        <trans-unit id="fda4e517cc99c618a0166c7c1427ce12e089520b" translate="yes" xml:space="preserve">
          <source>Five specially named code blocks are executed at the beginning and at the end of a running Perl program. These are the &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , and &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="translated">在运行的Perl程序的开头和结尾，将执行五个特殊命名的代码块。这些是 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;UNITCHECK&lt;/code&gt; ， &lt;code&gt;CHECK&lt;/code&gt; ， &lt;code&gt;INIT&lt;/code&gt; 和 &lt;code&gt;END&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="17ff08381265b477655a45e70fb5ae3e698605cc" translate="yes" xml:space="preserve">
          <source>Five specially named code blocks are executed at the beginning and at the end of a running Perl program. These are the &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, and &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="translated">在运行的Perl程序的开始和结束时，将执行五个特殊命名的代码块。这些是 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;UNITCHECK&lt;/code&gt; ， &lt;code&gt;CHECK&lt;/code&gt; ， &lt;code&gt;INIT&lt;/code&gt; 和 &lt;code&gt;END&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="c722bf4ef529e4eded31ce8c62d796cc90fbd29c" translate="yes" xml:space="preserve">
          <source>Fix as many discovered bugs as possible. Document all the bugs which are not fixed, and all the failures with unknown reasons. Inspect the produced logs</source>
          <target state="translated">尽可能多地修复发现的错误。记录所有未修复的错误,以及所有原因不明的故障。检查产生的日志</target>
        </trans-unit>
        <trans-unit id="df44dd4e66d3cab9cceb66ab9337728c16a604cb" translate="yes" xml:space="preserve">
          <source>Fix bugs!</source>
          <target state="translated">修复错误!</target>
        </trans-unit>
        <trans-unit id="d9d2b0f6093e9267469793bea33648599961e32d" translate="yes" xml:space="preserve">
          <source>Fix exec, and exit in &quot;forked&quot; subprocesses.</source>
          <target state="translated">在 &quot;forked &quot;子进程中修复exec,并退出。</target>
        </trans-unit>
        <trans-unit id="f9517d098aab673cc930fe5f552eaf1cd6c8267f" translate="yes" xml:space="preserve">
          <source>Fix inheritance of environment variables by subprocesses.</source>
          <target state="translated">修正子进程对环境变量的继承。</target>
        </trans-unit>
        <trans-unit id="ae5904c927a01dfd60190d4b60c8207a1973b7d9" translate="yes" xml:space="preserve">
          <source>Fix issue where kill was using the wrong kind of process ID</source>
          <target state="translated">修正kill使用错误的进程ID的问题。</target>
        </trans-unit>
        <trans-unit id="9bc92e3cff9e6a0dbd7ac3e0c0e26e4976790465" translate="yes" xml:space="preserve">
          <source>Fix issue with newlib's unlink, which could cause infinite loops.</source>
          <target state="translated">修正newlib的unlink问题,可能导致无限循环。</target>
        </trans-unit>
        <trans-unit id="b83649da6d49364618a24bf1f42332f131fef232" translate="yes" xml:space="preserve">
          <source>Fixed characters</source>
          <target state="translated">固定字符</target>
        </trans-unit>
        <trans-unit id="8fb62c73dff6424fec02bbefb83788e346747c19" translate="yes" xml:space="preserve">
          <source>Fixed existing link to YAML discussion thread to point to new &lt;a href=&quot;http://nntp.x.perl.org/group/&quot;&gt;http://nntp.x.perl.org/group/&lt;/a&gt; site.</source>
          <target state="translated">修复了指向YAML讨论线程的现有链接，以指向新的&lt;a href=&quot;http://nntp.x.perl.org/group/&quot;&gt;http://nntp.x.perl.org/group/&lt;/a&gt;网站。</target>
        </trans-unit>
        <trans-unit id="30f24223efa38b1e0c821d29e1e2ff7c73dc2563" translate="yes" xml:space="preserve">
          <source>Fixed header size</source>
          <target state="translated">固定头大小</target>
        </trans-unit>
        <trans-unit id="1612bd15c9421b6746280d95829fe2d2256c0953" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.007</source>
          <target state="translated">修正于版本:0.007</target>
        </trans-unit>
        <trans-unit id="f610e5ac87fab90f9565500603b8bb2a7f5611de" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.012</source>
          <target state="translated">修正于版本:0.012</target>
        </trans-unit>
        <trans-unit id="cd7cd10c589a3c1a03bf67a931ca237c61708446" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.025</source>
          <target state="translated">修正在版本:0.025</target>
        </trans-unit>
        <trans-unit id="7a6fc7d1e7bb925f0e155f6d3f8f4dd7c55cff80" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.04</source>
          <target state="translated">修正版本:0.04</target>
        </trans-unit>
        <trans-unit id="838194fc7cb5c547a3b4bbbf33000d2979b011eb" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.07</source>
          <target state="translated">修正于版本:0.07</target>
        </trans-unit>
        <trans-unit id="1cda70e9024dd56f02f35dcb5eb32f0c7fbf2708" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.12</source>
          <target state="translated">修正版本:0.12</target>
        </trans-unit>
        <trans-unit id="f51cff993c578c025a312a4daf87907ca66414a9" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.15</source>
          <target state="translated">修正于版本:0.15</target>
        </trans-unit>
        <trans-unit id="21e2f5911aadd9d8733160e7a729bf6a6f49643e" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.2.5</source>
          <target state="translated">修正于版本:0.2.5</target>
        </trans-unit>
        <trans-unit id="9b7c26595c9e0a4a54b1ef55fb178f6deeee31ff" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.35</source>
          <target state="translated">修正版本:0.35</target>
        </trans-unit>
        <trans-unit id="91bd05ad86efd33899ea3b32b7ed1a482bc6997f" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.43</source>
          <target state="translated">修正版本:0.43</target>
        </trans-unit>
        <trans-unit id="e4082202243548ced8a0d06b10b7e9ffd11225f9" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.45</source>
          <target state="translated">修正版本:0.45</target>
        </trans-unit>
        <trans-unit id="fd7762ab1f09d953c6f1610b6340e1b5f2b6d726" translate="yes" xml:space="preserve">
          <source>Fixed in version: 1.1.4</source>
          <target state="translated">修正于版本:1.1.4</target>
        </trans-unit>
        <trans-unit id="fdb1364271d22264a4012395e53d8c7918c07fa7" translate="yes" xml:space="preserve">
          <source>Fixed in version: 1.11</source>
          <target state="translated">修正在版本:1.11</target>
        </trans-unit>
        <trans-unit id="388c87de5e532d033e7c749d0900a68a3b45fb12" translate="yes" xml:space="preserve">
          <source>Fixed in version: 2.15</source>
          <target state="translated">修正于版本:2.15</target>
        </trans-unit>
        <trans-unit id="f9a93260b08de69ccea121c2ab5c95665512b9b8" translate="yes" xml:space="preserve">
          <source>Fixed some dead links to point to active resources.</source>
          <target state="translated">修正了一些死链接,使其指向活动资源。</target>
        </trans-unit>
        <trans-unit id="ecfb2a96b4b5f73e1fa6089350af79bfe24ae8f4" translate="yes" xml:space="preserve">
          <source>Fixed, sped-up and enhanced by Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 2001-2003. Further streamlining (api_version 1 etc.) by Tels 2004-2007.</source>
          <target state="translated">已通过Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 2001-2003 进行了修复，加速和增强。Tels 2004-2007进一步精简（api_version 1等）。</target>
        </trans-unit>
        <trans-unit id="330c21b294e09432feca3391543087a4db397d9c" translate="yes" xml:space="preserve">
          <source>Fixed, sped-up and enhanced by Tels http://bloodgate.com 2001-2003. Further streamlining (api_version 1 etc.) by Tels 2004-2007.</source>
          <target state="translated">2001-2003年由Telshttp://bloodgate.com进行修正、加速和增强。2004-2007年,Tels进一步精简(api_version 1等)。</target>
        </trans-unit>
        <trans-unit id="405b043abf0e87a42c31429945169f0dd7c5d88d" translate="yes" xml:space="preserve">
          <source>Fixed, speed-up, streamlined and enhanced by Tels 2001 - 2007.</source>
          <target state="translated">2001-2007年Tels对其进行了修正、加速、简化和强化。</target>
        </trans-unit>
        <trans-unit id="3ca59c972a528af8e7a14352bd6c37f9e70222bb" translate="yes" xml:space="preserve">
          <source>Fixed-length mode. Leave-blanks mode.</source>
          <target state="translated">固定长度模式。留空模式。</target>
        </trans-unit>
        <trans-unit id="f1659338bac13f477d12cd7d829279169513026b" translate="yes" xml:space="preserve">
          <source>Fixed-length record format.</source>
          <target state="translated">固定长度的记录格式。</target>
        </trans-unit>
        <trans-unit id="959687f22ec208a2b336a28e627dad8c7a247264" translate="yes" xml:space="preserve">
          <source>Fixed-table-size, fixed-key-length hashing</source>
          <target state="translated">固定表尺寸、固定键长的散列法。</target>
        </trans-unit>
        <trans-unit id="d34a8295ae4d44653579918a6b463ec2c7d9fc59" translate="yes" xml:space="preserve">
          <source>Fixes up numerous file and directory macros to insure VMS syntax regardless of input syntax. Also makes lists of files comma-separated.</source>
          <target state="translated">修正了许多文件和目录宏,以确保VMS语法与输入语法无关。还使文件列表以逗号分隔。</target>
        </trans-unit>
        <trans-unit id="d40ac06cf36190f3752a227ce1d3e621fc0665b2" translate="yes" xml:space="preserve">
          <source>Fixing security issues and user-visible bugs in the core</source>
          <target state="translated">修复核心中的安全问题和用户可见的错误。</target>
        </trans-unit>
        <trans-unit id="29642e3ca9418aa5ace5fd4900eeec9b27f8007e" translate="yes" xml:space="preserve">
          <source>Fixing system locale configuration</source>
          <target state="translated">修正系统本地化配置</target>
        </trans-unit>
        <trans-unit id="73cc249f918f8969b3fba39295da9b9b7fa5e26c" translate="yes" xml:space="preserve">
          <source>Flag bits modifying the behavior of an object handle and accessed via &lt;code&gt;GetHandleInformation&lt;/code&gt; and &lt;code&gt;SetHandleInformation&lt;/code&gt;.</source>
          <target state="translated">标志位修改对象句柄的行为，并可以通过 &lt;code&gt;GetHandleInformation&lt;/code&gt; 和 &lt;code&gt;SetHandleInformation&lt;/code&gt; 访问。</target>
        </trans-unit>
        <trans-unit id="daddf7d8bd736866de91cc44a32f0bc29d86f601" translate="yes" xml:space="preserve">
          <source>Flags =&amp;gt; $uFlags</source>
          <target state="translated">标志=&amp;gt; $ uFlags</target>
        </trans-unit>
        <trans-unit id="d83689a42f870aeb8b820eedd460f0c265e2f627" translate="yes" xml:space="preserve">
          <source>Flags are ORed together values, such as &lt;code&gt;MSG_BCAST&lt;/code&gt;, &lt;code&gt;MSG_OOB&lt;/code&gt;, &lt;code&gt;MSG_TRUNC&lt;/code&gt;. The default value for the flags is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">标志与值（例如 &lt;code&gt;MSG_BCAST&lt;/code&gt; ， &lt;code&gt;MSG_OOB&lt;/code&gt; ， &lt;code&gt;MSG_TRUNC&lt;/code&gt; )进行或运算。标志的默认值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86b4613698349d05ae2cbeb0e1d73fba54ce4b08" translate="yes" xml:space="preserve">
          <source>Flags described further in &lt;a href=&quot;perlretut#Using-regular-expressions-in-Perl&quot;&gt;&quot;Using regular expressions in Perl&quot; in perlretut&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;perlretut#Using-regular-expressions-in-Perl&quot;&gt;perlretut&lt;/a&gt;中的&amp;ldquo;在Perl中使用正则表达式&amp;rdquo;中进一步描述的标志是：</target>
        </trans-unit>
        <trans-unit id="6014390aa4fd7e389a7243e9000e4c32cd912a43" translate="yes" xml:space="preserve">
          <source>Flags described further in &lt;a href=&quot;perlretut#Using-regular-expressions-in-Perl&quot;&gt;Using regular expressions in Perl in perlretut&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;perlretut#Using-regular-expressions-in-Perl&quot;&gt;在perlretut中的Perl中使用正则表达式中&lt;/a&gt;进一步描述的标志是：</target>
        </trans-unit>
        <trans-unit id="95cffe720f5843720b2f2791ed48ac4c103a313f" translate="yes" xml:space="preserve">
          <source>Flags may be one of:</source>
          <target state="translated">旗帜可以是:</target>
        </trans-unit>
        <trans-unit id="adc8e7329bf4555216d7a3bfa9cef9955718902b" translate="yes" xml:space="preserve">
          <source>Flags. Use one of:</source>
          <target state="translated">旗帜。使用其中之一:</target>
        </trans-unit>
        <trans-unit id="6103463409204cb527cdac9c41a9a07b15e276a0" translate="yes" xml:space="preserve">
          <source>Flavors of Perl numeric operations</source>
          <target state="translated">Perl数字运算的特点</target>
        </trans-unit>
        <trans-unit id="8b3926c9cc6bcbb663057b65eb8ebe30826dbb42" translate="yes" xml:space="preserve">
          <source>Floating Point Anomalies with Perl on OS/390</source>
          <target state="translated">在OS/390上使用Perl的浮点异常现象</target>
        </trans-unit>
        <trans-unit id="5a5e19070c0cf7a423dbae9f66841c3fabf1ca2c" translate="yes" xml:space="preserve">
          <source>Floating point Numbers</source>
          <target state="translated">浮点数</target>
        </trans-unit>
        <trans-unit id="cdc8e382e56841728abcd2d046d6a53518ddf43c" translate="yes" xml:space="preserve">
          <source>Floating point anomalies on BS2000</source>
          <target state="translated">BS2000上的浮点异常现象</target>
        </trans-unit>
        <trans-unit id="6458d7358a6010e05479d7d3065fd1dc70e53021" translate="yes" xml:space="preserve">
          <source>Floating point comparisons which handle the &lt;code&gt;NaN&lt;/code&gt; [C99].</source>
          <target state="translated">处理 &lt;code&gt;NaN&lt;/code&gt; 的浮点比较[C99]。</target>
        </trans-unit>
        <trans-unit id="12643a69610ec7d65c380165a5bf7f423a31ce49" translate="yes" xml:space="preserve">
          <source>Floating point constants are truncated to integer. All parts and results of expressions are also truncated.</source>
          <target state="translated">浮点常数被截断为整数。表达式的所有部分和结果也被截断。</target>
        </trans-unit>
        <trans-unit id="cede3872ee4aa83d2bda6798fe8042b21fbcd8fe" translate="yes" xml:space="preserve">
          <source>Floating point values include the special values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; , for infinity and not-a-number. The infinity can be also negative.</source>
          <target state="translated">浮点值包括特殊值 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; ，表示无穷大和非数字。无限大也可以是负数。</target>
        </trans-unit>
        <trans-unit id="bd8d0ea7718d52d1572fd73c8242126ae8862128" translate="yes" xml:space="preserve">
          <source>Floating point values include the special values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt;, for infinity and not-a-number. The infinity can be also negative.</source>
          <target state="translated">浮点值包括特殊值 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; ，表示无穷大和非数字。无限大也可以是负数。</target>
        </trans-unit>
        <trans-unit id="709713db0a0caca978c5c319c22711e133d5178a" translate="yes" xml:space="preserve">
          <source>Floating-point Arithmetic</source>
          <target state="translated">浮点算术</target>
        </trans-unit>
        <trans-unit id="c49d97794f62dac628d25ae12fcfb3dd4f71313b" translate="yes" xml:space="preserve">
          <source>Floating-point numbers are only approximations to what a mathematician would call real numbers. There are infinitely more reals than floats, so some corners must be cut. For example:</source>
          <target state="translated">浮点数只是数学家所说的实数的近似值。由于实数比浮点数多得多,所以必须删减一些角落。例如:</target>
        </trans-unit>
        <trans-unit id="6477529bc9646ecedaf8e4ae8b6c8d51a8bc8383" translate="yes" xml:space="preserve">
          <source>Floppy, Zip, Offline Mode</source>
          <target state="translated">软盘,压缩,离线模式</target>
        </trans-unit>
        <trans-unit id="8adaf25b2605056f2e07d65e18faabac22731925" translate="yes" xml:space="preserve">
          <source>Florian Ragwitz</source>
          <target state="translated">Florian Ragwitz</target>
        </trans-unit>
        <trans-unit id="15fba67b0eee19071b7f3acb8dc1d2691dff0393" translate="yes" xml:space="preserve">
          <source>Florian Ragwitz &amp;lt;flora@cpan.org&amp;gt;, 2010.</source>
          <target state="translated">弗洛里安&amp;middot;拉格维兹（Florian Ragwitz），&amp;lt;flora@cpan.org&amp;gt;，2010年。</target>
        </trans-unit>
        <trans-unit id="cc546391510adffd5d42495f4fcd24b543fc28de" translate="yes" xml:space="preserve">
          <source>Florian Ragwitz &amp;lt;rafl@debian.org&amp;gt;</source>
          <target state="translated">弗洛里安&amp;middot;拉格维兹（Florian Ragwitz）&amp;lt;rafl@debian.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7c936d7c5a91dca9198671c84f6c29001e1635e0" translate="yes" xml:space="preserve">
          <source>Flush</source>
          <target state="translated">Flush</target>
        </trans-unit>
        <trans-unit id="8a27fc117a1fc8843011dfb82df5f33f7d437936" translate="yes" xml:space="preserve">
          <source>Flush any buffered write data. May possibly be called on readable handles too. Should return 0 on success, -1 on error.</source>
          <target state="translated">刷新任何缓冲区的写数据。也可能在可读句柄上被调用。成功时应返回0,错误时应返回-1。</target>
        </trans-unit>
        <trans-unit id="209099cf56b373e5745037d20085b43c5b416a14" translate="yes" xml:space="preserve">
          <source>Flush the cache.</source>
          <target state="translated">刷新缓存。</target>
        </trans-unit>
        <trans-unit id="7ea0600877c74e6c0fe89bbd3afcee971963f892" translate="yes" xml:space="preserve">
          <source>Flushes all pending output into the compressed file.</source>
          <target state="translated">将所有待处理的输出刷新到压缩文件中。</target>
        </trans-unit>
        <trans-unit id="082adecce9ec5788047efdf4da353f56b28da59d" translate="yes" xml:space="preserve">
          <source>Flushes any cached buffers to disk.</source>
          <target state="translated">将任何缓存的缓冲区刷新到磁盘。</target>
        </trans-unit>
        <trans-unit id="0946db717a74209041c8e2e8789decc09b0c8c1a" translate="yes" xml:space="preserve">
          <source>Flushes any pending compressed data and then closes the output file/buffer.</source>
          <target state="translated">清空所有待处理的压缩数据,然后关闭输出文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="cd9697be2c5b575554432a6587a955d4836a8e65" translate="yes" xml:space="preserve">
          <source>Flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">将所有待处理的压缩数据刷新到 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ff0666143651d5f03566ea681f5c75e80fe909d" translate="yes" xml:space="preserve">
          <source>Flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt;.</source>
          <target state="translated">将所有待处理的压缩数据刷新到 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3085611069b17b4d4af56b56fce73f275cd2d511" translate="yes" xml:space="preserve">
          <source>Flushes any pending compressed data to the output file/buffer.</source>
          <target state="translated">刷新任何待处理的压缩数据到输出文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="4773551f475406069f00051e9d104d3a35f79ad2" translate="yes" xml:space="preserve">
          <source>Flushes the directory cache.</source>
          <target state="translated">刷新目录缓存。</target>
        </trans-unit>
        <trans-unit id="928fef4d7417d4484f1f3fc7a84c5c97a0c10f03" translate="yes" xml:space="preserve">
          <source>Foldcase</source>
          <target state="translated">Foldcase</target>
        </trans-unit>
        <trans-unit id="8b66e3d01ed62d27bcca95567dd515e099e2e9d3" translate="yes" xml:space="preserve">
          <source>Follow the guidelines in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;.</source>
          <target state="translated">遵循&lt;a href=&quot;perlstyle&quot;&gt;perlstyle中&lt;/a&gt;的准则。</target>
        </trans-unit>
        <trans-unit id="630bce1629a6b0e8bb4da21f695760c25a3efb55" translate="yes" xml:space="preserve">
          <source>Follow the instructions and links on:</source>
          <target state="translated">按照指示和链接,在:</target>
        </trans-unit>
        <trans-unit id="444ce8dc04bb6c539c04e93cd526f6da5b1561ad" translate="yes" xml:space="preserve">
          <source>Follow the instructions in</source>
          <target state="translated">遵循以下指示</target>
        </trans-unit>
        <trans-unit id="e85aee671a6a0df6df7d5aaa8c5a698b13785622" translate="yes" xml:space="preserve">
          <source>Follow the messages ... and you're done.</source>
          <target state="translated">按照信息......你就可以了。</target>
        </trans-unit>
        <trans-unit id="e08690a98d641e3cbc8171b5ab25389a2271c13b" translate="yes" xml:space="preserve">
          <source>Follow the normal instructions for building perl; e.g, enter bash, run the Configure script, then use &quot;gmake&quot; to build perl.</source>
          <target state="translated">按照正常的说明来构建perl,例如,输入bash,运行Configure脚本,然后使用 &quot;gmake &quot;来构建perl。</target>
        </trans-unit>
        <trans-unit id="864440f25ee94f2eebf5d9e755372bbba17b62ef" translate="yes" xml:space="preserve">
          <source>Followed by a view command to see where we are:</source>
          <target state="translated">后面还有一个查看命令,看看我们在哪里。</target>
        </trans-unit>
        <trans-unit id="1a41044e3e9273867bb8cc0dfd68db2b82f20837" translate="yes" xml:space="preserve">
          <source>Following bisection you may wish to configure, build and test perl at commits identified by the bisection process. Sometimes, particularly with older perls, &lt;code&gt;make&lt;/code&gt; may fail during this process. In this case you may be able to patch the source code at the older commit point. To do so, please follow the suggestions provided in &lt;a href=&quot;perlhack#Building-perl-at-older-commits&quot;&gt;&quot;Building perl at older commits&quot; in perlhack&lt;/a&gt;.</source>
          <target state="translated">在二等分之后，您可能希望根据二等分过程确定的提交来配置，构建和测试perl。有时，特别是对于较早的Perl， &lt;code&gt;make&lt;/code&gt; 在此过程中可能会失败。在这种情况下，您可以在较早的提交点修补源代码。为此，请遵循&lt;a href=&quot;perlhack#Building-perl-at-older-commits&quot;&gt;perlhack&lt;/a&gt;中&amp;ldquo;在较早的提交上构建Perl&amp;rdquo;中提供的建议。</target>
        </trans-unit>
        <trans-unit id="d2431a18b10300a9cb947cadd732f97519440b32" translate="yes" xml:space="preserve">
          <source>Following codes are same.</source>
          <target state="translated">以下代码相同:</target>
        </trans-unit>
        <trans-unit id="1a1472c72b3b35650919410041b1e204b2d5f373" translate="yes" xml:space="preserve">
          <source>Following the normal convention of sixteen-color emulators, this module provides a pair of attributes for each color. For every normal color (0 through 7), the corresponding bright color (8 through 15) is obtained by prepending the string &lt;code&gt;bright_&lt;/code&gt; to the normal color name. For example, &lt;code&gt;red&lt;/code&gt; is color 1 and &lt;code&gt;bright_red&lt;/code&gt; is color 9. The same applies for background colors: &lt;code&gt;on_red&lt;/code&gt; is the normal color and &lt;code&gt;on_bright_red&lt;/code&gt; is the bright color. Capitalize these strings for the constant interface.</source>
          <target state="translated">遵循十六种颜色模拟器的常规约定，此模块为每种颜色提供一对属性。对于每种常规颜色（0到7），通过将字符串 &lt;code&gt;bright_&lt;/code&gt; 放在常规颜色名称之前，可以获得对应的明亮颜色（8到15）。例如， &lt;code&gt;red&lt;/code&gt; 是颜色1，而 &lt;code&gt;bright_red&lt;/code&gt; 是颜色9。背景颜色也是如此： &lt;code&gt;on_red&lt;/code&gt; 是常规颜色， &lt;code&gt;on_bright_red&lt;/code&gt; 是明亮颜色。将这些字符串大写以表示常量接口。</target>
        </trans-unit>
        <trans-unit id="339a6f2fa2aeea3b1c39c8b8cdd86cfc5ca212f8" translate="yes" xml:space="preserve">
          <source>Following the optimizer information is a dump of the offset/length table, here split across several lines:</source>
          <target state="translated">在优化器信息之后是偏移量/长度表的转储,这里分为几行。</target>
        </trans-unit>
        <trans-unit id="122efc697c2e89462f088f0feebaa5c870210258" translate="yes" xml:space="preserve">
          <source>Follows VMS naming conventions for executable files. If the name passed in doesn't exactly match an executable file, appends</source>
          <target state="translated">遵循VMS可执行文件的命名惯例。如果传入的名称与可执行文件不完全匹配,则在后面加上</target>
        </trans-unit>
        <trans-unit id="fcc0b02fa7c86000beeb89a30eaf5629188e75a8" translate="yes" xml:space="preserve">
          <source>Foo.pm</source>
          <target state="translated">Foo.pm</target>
        </trans-unit>
        <trans-unit id="da5d4e2f7dabe2f03b8a59da35c55f83a0e24606" translate="yes" xml:space="preserve">
          <source>Foo.txt</source>
          <target state="translated">Foo.txt</target>
        </trans-unit>
        <trans-unit id="d715482d55fabe025e318c022fd82a1c933e4100" translate="yes" xml:space="preserve">
          <source>Foo.xs</source>
          <target state="translated">Foo.xs</target>
        </trans-unit>
        <trans-unit id="df808fb24c9efb33a59855928a13b51fb91724c1" translate="yes" xml:space="preserve">
          <source>Foo/Bar.pm</source>
          <target state="translated">Foo/Bar.pm</target>
        </trans-unit>
        <trans-unit id="ac143ab3d1c17f2a31332e229167b913e207dde2" translate="yes" xml:space="preserve">
          <source>Foo::Bar</source>
          <target state="translated">Foo::Bar</target>
        </trans-unit>
        <trans-unit id="cdf8cb90a5029548db08a3400753c839b0a8694f" translate="yes" xml:space="preserve">
          <source>Footers</source>
          <target state="translated">Footers</target>
        </trans-unit>
        <trans-unit id="f7880600348a091a43e2a84906d6002820643108" translate="yes" xml:space="preserve">
          <source>For</source>
          <target state="translated">For</target>
        </trans-unit>
        <trans-unit id="d69332b2911636a58346ec04cf4c168ff3905a2a" translate="yes" xml:space="preserve">
          <source>For &quot;Insecure &lt;code&gt;$ENV{PATH}&lt;/code&gt; &quot; messages, you need to set &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; to a known value, and each directory in the path must be absolute and non-writable by others than its owner and group. You may be surprised to get this message even if the pathname to your executable is fully qualified. This is</source>
          <target state="translated">对于&amp;ldquo;不安全的 &lt;code&gt;$ENV{PATH}&lt;/code&gt; &amp;rdquo;消息，您需要将 &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; 为一个已知值，并且该路径中的每个目录必须是绝对目录，并且除其所有者和组外，其他目录均不可写。即使可执行文件的路径名是完全限定的，您也可能会惊讶地收到此消息。这是</target>
        </trans-unit>
        <trans-unit id="458ce0be0117f196e68aa4441aff2c235ffca77c" translate="yes" xml:space="preserve">
          <source>For &quot;Insecure &lt;code&gt;$ENV{PATH}&lt;/code&gt;&quot; messages, you need to set &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; to a known value, and each directory in the path must be absolute and non-writable by others than its owner and group. You may be surprised to get this message even if the pathname to your executable is fully qualified. This is</source>
          <target state="translated">对于&amp;ldquo;不安全的 &lt;code&gt;$ENV{PATH}&lt;/code&gt; &amp;rdquo;消息，您需要将 &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; 为一个已知值，并且该路径中的每个目录必须是绝对目录，并且除其所有者和组外，其他目录均不可写。即使可执行文件的路径名是完全限定的，您也可能会惊讶地收到此消息。这是</target>
        </trans-unit>
        <trans-unit id="714f0a7ac0b9ec15987d10f44460eec1efc59934" translate="yes" xml:space="preserve">
          <source>For &quot;big&quot; data stores (i.e. ones that exceed available memory) consider using one of the DB modules to store it on disk instead of in RAM. This will incur a penalty in access time, but that's probably better than causing your hard disk to thrash due to massive swapping.</source>
          <target state="translated">对于 &quot;大 &quot;数据存储(即超过可用内存的数据),可以考虑使用DB模块之一将其存储在磁盘上而不是RAM中。这将会在访问时间上产生惩罚,但这可能比由于大量的交换而导致你的硬盘崩溃要好。</target>
        </trans-unit>
        <trans-unit id="216bed6df8bedc927acdb0d380e3ce0b17cdad4f" translate="yes" xml:space="preserve">
          <source>For &quot;g&quot; and &quot;G&quot;, this specifies the maximum number of digits to show, including those prior to the decimal point and those after it; for example:</source>
          <target state="translated">对于 &quot;g &quot;和 &quot;G&quot;,这指定了要显示的最大数字,包括小数点之前的数字和小数点之后的数字;例如。</target>
        </trans-unit>
        <trans-unit id="a648af0ad15c0dfdeff44093b0ccaf3206a57268" translate="yes" xml:space="preserve">
          <source>For &quot;g&quot; and &quot;G&quot;, this specifies the maximum number of significant digits to show; for example:</source>
          <target state="translated">对于 &quot;g &quot;和 &quot;G&quot;,这指定了要显示的最大有效数字,例如:。</target>
        </trans-unit>
        <trans-unit id="0f35f055609ac0e205f7abbab4e89f59e70313b8" translate="yes" xml:space="preserve">
          <source>For 256-color emulators, this module additionally provides &lt;code&gt;ansi0&lt;/code&gt; through &lt;code&gt;ansi15&lt;/code&gt; , which are the same as colors 0 through 15 in sixteen-color emulators but use the 256-color escape syntax, &lt;code&gt;grey0&lt;/code&gt; through &lt;code&gt;grey23&lt;/code&gt; ranging from nearly black to nearly white, and a set of RGB colors. The RGB colors are of the form &lt;code&gt;rgb&lt;i&gt;RGB&lt;/i&gt;&lt;/code&gt; where</source>
          <target state="translated">对于256色仿真器，此模块还提供 &lt;code&gt;ansi0&lt;/code&gt; 至 &lt;code&gt;ansi15&lt;/code&gt; ，与16色仿真器中的颜色0到15相同，但使用256色转义语法， &lt;code&gt;grey0&lt;/code&gt; 到 &lt;code&gt;grey23&lt;/code&gt; 的范围从近乎黑色到近乎白色，以及组的RGB颜色。RGB颜色的形式为 &lt;code&gt;rgb&lt;i&gt;RGB&lt;/i&gt;&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="a433027d577c25f33bfe8c1ce8c632502b230d50" translate="yes" xml:space="preserve">
          <source>For 256-color emulators, this module additionally provides &lt;code&gt;ansi0&lt;/code&gt; through &lt;code&gt;ansi15&lt;/code&gt;, which are the same as colors 0 through 15 in sixteen-color emulators but use the 256-color escape syntax, &lt;code&gt;grey0&lt;/code&gt; through &lt;code&gt;grey23&lt;/code&gt; ranging from nearly black to nearly white, and a set of RGB colors. The RGB colors are of the form &lt;code&gt;rgb&lt;i&gt;RGB&lt;/i&gt;&lt;/code&gt; where</source>
          <target state="translated">对于256色仿真器，此模块还提供 &lt;code&gt;ansi0&lt;/code&gt; 至 &lt;code&gt;ansi15&lt;/code&gt; ，与16色仿真器中的颜色0到15相同，但使用256色转义语法， &lt;code&gt;grey0&lt;/code&gt; 到 &lt;code&gt;grey23&lt;/code&gt; 的范围从近乎黑色到近乎白色，以及组的RGB颜色。RGB颜色的形式为 &lt;code&gt;rgb&lt;i&gt;RGB&lt;/i&gt;&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="9dba65b3ab3aa02b8076d20aa76888328be8a5c9" translate="yes" xml:space="preserve">
          <source>For 256-color terminals, the recognized foreground colors are:</source>
          <target state="translated">对于256色终端,识别的前景色为:。</target>
        </trans-unit>
        <trans-unit id="c5d9dc655e83477215f485473f4a8c147ee45bb5" translate="yes" xml:space="preserve">
          <source>For 5.11.0 and later, B::RV is abolished, and IVs can be used to store references, and a new type B::REGEXP is introduced, giving this structure:</source>
          <target state="translated">在5.11.0及以后的版本中,取消了B::RV,IV可以用来存储引用,并引入了一种新的类型B::REGEXP,给出了这种结构。</target>
        </trans-unit>
        <trans-unit id="a3b9459bd4ecaaeabf24e953c1001374ffa8f984" translate="yes" xml:space="preserve">
          <source>For 5.9.0 and earlier, PVLV is a direct subclass of PVMG, and BM is still present as a distinct type, so the base of this diagram is</source>
          <target state="translated">对于5.9.0和更早的版本,PVLV是PVMG的直接子类,而BM仍然作为一个独立的类型存在,所以这个图的基础是</target>
        </trans-unit>
        <trans-unit id="afcd88ba3a43999bb13c6a0581bba573aa2225e9" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;,</source>
          <target state="translated">对于&lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt;，</target>
        </trans-unit>
        <trans-unit id="b67046d89d36d48c7efd6e356e0580695c3d2279" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;, you write</source>
          <target state="translated">对于&lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt;，您写</target>
        </trans-unit>
        <trans-unit id="bb349f3962801c59d331a216fd1e10a8dbe12696" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;, an internal stack of integer arguments unpacked so far is used. You write &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">对于&lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt;，使用到目前为止已解压缩的内部整数整数参数堆栈。你写 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8f07249c48d21c67ab8413541e063aa7a291c88" translate="yes" xml:space="preserve">
          <source>For &lt;b&gt;sed&lt;/b&gt; devotees, &lt;code&gt;y&lt;/code&gt; is provided as a synonym for &lt;code&gt;tr&lt;/code&gt;.</source>
          <target state="translated">对于&lt;b&gt;sed的&lt;/b&gt;奉献者， &lt;code&gt;y&lt;/code&gt; 是 &lt;code&gt;tr&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="12aacf89124604a604d76e2c1ffa17f7f2f13984" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, you have to be more elaborate:</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; ，你必须要更复杂：</target>
        </trans-unit>
        <trans-unit id="33083321ae1d2e32225ec575a8dfdad8fc51bef0" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="8b70fae6950aa7895e620a82de485cc8ac6c8f65" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, you write</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ，您写</target>
        </trans-unit>
        <trans-unit id="68b84a9c646a03b6d82fe08053257a1d8dc4ee20" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, an internal stack of integer arguments unpacked so far is used. You write &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ，使用到目前为止已解压缩的内部整数整数参数堆栈。你写 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c6bfa42e2fbb77bda7d82e8856005087ade0aff" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="f6f91e66939fc35306c48af011860c291352dd16" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, you write</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ，您写</target>
        </trans-unit>
        <trans-unit id="9437652f34a1038c4388b97e25d520817a521814" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, an internal stack of integer arguments unpacked so far is used. You write &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ，使用到目前为止已解压缩的内部整数整数参数堆栈。你写 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9c5e92c976c0b87d55fa26353e0a93acdc6c1ce" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Build.PL&lt;/code&gt; -based distributions, use the --install_base option:</source>
          <target state="translated">对于基于 &lt;code&gt;Build.PL&lt;/code&gt; 的发行版，请使用--install_base选项：</target>
        </trans-unit>
        <trans-unit id="4ecf98761e1a3b107c4b1b90f83825ea697cbbba" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Build.PL&lt;/code&gt;-based distributions, use the --install_base option:</source>
          <target state="translated">对于基于 &lt;code&gt;Build.PL&lt;/code&gt; 的发行版，请使用--install_base选项：</target>
        </trans-unit>
        <trans-unit id="c829467e9c4b40b28176534e89832125f74b7e18" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DESTROY&lt;/code&gt; XSUBs only, a T_PTROBJ is optimized to a T_PTRREF. This means the class check is skipped.</source>
          <target state="translated">仅对于 &lt;code&gt;DESTROY&lt;/code&gt; XSUB，将T_PTROBJ优化为T_PTRREF。这意味着将跳过类检查。</target>
        </trans-unit>
        <trans-unit id="3f0884055516afc34f2b13593cc64878ec3fa103" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DESTROY&lt;/code&gt; XSUBs only, a T_REFOBJ is optimized to a T_REFREF. This means the class check is skipped.</source>
          <target state="translated">仅对于 &lt;code&gt;DESTROY&lt;/code&gt; XSUB，将T_REFOBJ优化为T_REFREF。这意味着将跳过类检查。</target>
        </trans-unit>
        <trans-unit id="1484118e1397c1b2c2710771f398a13c8a642ded" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DESTROY&lt;/code&gt; XSUBs only, a T_REF_IV_PTR is optimized to a T_PTRREF. This means the class check is skipped.</source>
          <target state="translated">仅对于 &lt;code&gt;DESTROY&lt;/code&gt; XSUB，将T_REF_IV_PTR优化为T_PTRREF。这意味着将跳过类检查。</target>
        </trans-unit>
        <trans-unit id="66b2f35d5f8f8421c2121030f67ed492cb7aab30" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; codes without a &quot;name|&quot; part, only &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; and &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; codes may occur. That is, authors should not use &quot;&lt;code&gt;L&amp;lt;B&amp;lt;Foo::Bar&amp;gt;&amp;gt;&lt;/code&gt; &quot;.</source>
          <target state="translated">对于不带&amp;ldquo;名称|&amp;rdquo;的 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 代码 部分，只能出现 &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; 代码。也就是说，作者不应使用&amp;ldquo; &lt;code&gt;L&amp;lt;B&amp;lt;Foo::Bar&amp;gt;&amp;gt;&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f0f87c65e7fff8eb6f507b6ea128ab017e2cdc4d" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; codes without a &quot;name|&quot; part, only &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; and &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; codes may occur. That is, authors should not use &quot;&lt;code&gt;L&amp;lt;B&amp;lt;Foo::Bar&amp;gt;&amp;gt;&lt;/code&gt;&quot;.</source>
          <target state="translated">对于不带&amp;ldquo;名称|&amp;rdquo;的 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 代码 部分，只能出现 &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; 代码。也就是说，作者不应使用&amp;ldquo; &lt;code&gt;L&amp;lt;B&amp;lt;Foo::Bar&amp;gt;&amp;gt;&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="45be8d936a33aec210b53bde0ce7f71408df21fa" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Makefile.PL&lt;/code&gt; -based distributions, use the INSTALL_BASE option when generating Makefiles:</source>
          <target state="translated">对于基于 &lt;code&gt;Makefile.PL&lt;/code&gt; 的发行版，在生成Makefile时使用INSTALL_BASE选项：</target>
        </trans-unit>
        <trans-unit id="1d9c46fd3bfeb22a99c449a7ef39ec2d82f1f5fd" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Makefile.PL&lt;/code&gt;-based distributions, use the INSTALL_BASE option when generating Makefiles:</source>
          <target state="translated">对于基于 &lt;code&gt;Makefile.PL&lt;/code&gt; 的发行版，在生成Makefile时使用INSTALL_BASE选项：</target>
        </trans-unit>
        <trans-unit id="6affbdccf85e4a86ac6e1ea88088cb893b7138f5" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;\N{NAME}&lt;/code&gt; , it is a fatal error if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect and the input name is that of a character that won't fit into a byte (i.e., whose ordinal is above 255).</source>
          <target state="translated">对于 &lt;code&gt;\N{NAME}&lt;/code&gt; ，如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 有效并且输入名称是不适合字节的字符的名称（即序数大于255），则是致命错误。</target>
        </trans-unit>
        <trans-unit id="56c98115c3b61593c6a9cc1d27a8a4d0986a1864" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;\N{NAME}&lt;/code&gt;, it is a fatal error if &lt;code&gt;use bytes&lt;/code&gt; is in effect and the input name is that of a character that won't fit into a byte (i.e., whose ordinal is above 255).</source>
          <target state="translated">对于 &lt;code&gt;\N{NAME}&lt;/code&gt; ，如果 &lt;code&gt;use bytes&lt;/code&gt; 有效并且输入名称是不适合字节的字符的名称（即序数大于255），则是致命错误。</target>
        </trans-unit>
        <trans-unit id="ea67c402005690cbe6252230aeb1b9e29463940b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;last&lt;/code&gt;, you have to be more elaborate and put braces around it:</source>
          <target state="translated">对于 &lt;code&gt;last&lt;/code&gt; ，你必须要更精细，并把它周围的括号：</target>
        </trans-unit>
        <trans-unit id="e79cd427b6a6f27bc463bdbb4440a5f8655fa529" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;mode=anyorder&lt;/code&gt; CPAN.pm answers a question as soon as the timeout is reached for the next byte in the input stream. In this mode you can use the &lt;code&gt;reuse&lt;/code&gt; parameter to decide what will happen with a question-answer pair after it has been used. In the default case (reuse=0) it is removed from the array, avoiding being used again accidentally. If you want to answer the question &lt;code&gt;Do you really want to &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; that&lt;/code&gt; several times, then it must be included in the array at least as often as you want this answer to be given. Setting the parameter &lt;code&gt;reuse&lt;/code&gt; to 1 makes this repetition unnecessary.</source>
          <target state="translated">对于 &lt;code&gt;mode=anyorder&lt;/code&gt; ，一旦输入流中的下一个字节达到超时，CPAN.pm就会回答问题。在这种模式下，您可以使用 &lt;code&gt;reuse&lt;/code&gt; 参数来确定问题-答案对使用后会发生什么。在默认情况下（reuse = 0），它会从数组中删除，以避免再次被意外使用。如果要回答这个问题 &lt;code&gt;Do you really want to &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; that&lt;/code&gt; 好几次，那么它必须包含至少数组作为经常要给出这个答案英寸 将参数 &lt;code&gt;reuse&lt;/code&gt; 设置为1使得不需要重复。</target>
        </trans-unit>
        <trans-unit id="9c8630b83e11b62d7083ae08d4bcbe9c6233a2fe" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;mode=deterministic&lt;/code&gt; , the CPAN.pm injects the corresponding answer as soon as the stream matches the regular expression.</source>
          <target state="translated">对于 &lt;code&gt;mode=deterministic&lt;/code&gt; ，只要流匹配正则表达式，CPAN.pm就会注入相应的答案。</target>
        </trans-unit>
        <trans-unit id="92e601981acde6d883af496a8f5b209e79aaf450" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;redo&lt;/code&gt;, just double the braces:</source>
          <target state="translated">对于 &lt;code&gt;next&lt;/code&gt; 或 &lt;code&gt;redo&lt;/code&gt; ，只需将花括号加倍：</target>
        </trans-unit>
        <trans-unit id="ef14d5377f916291fb2a9d24329993be66568e7c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;signal&lt;/code&gt; /&lt;code&gt;sigaction&lt;/code&gt; , use &lt;code&gt;rsignal(signo, handler)&lt;/code&gt; .</source>
          <target state="translated">对于 &lt;code&gt;signal&lt;/code&gt; / &lt;code&gt;sigaction&lt;/code&gt; ，请使用 &lt;code&gt;rsignal(signo, handler)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c6ef77a69497373d8f3b5756e0eb701254fe1dc" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;signal&lt;/code&gt;/&lt;code&gt;sigaction&lt;/code&gt;, use &lt;code&gt;rsignal(signo, handler)&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;signal&lt;/code&gt; / &lt;code&gt;sigaction&lt;/code&gt; ，请使用 &lt;code&gt;rsignal(signo, handler)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9ab0c714668cca72c9c6d7568133eb235eee645" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;version&lt;/code&gt; 2 (or higher), the filename should end in '.json'. &lt;a href=&quot;JSON::PP&quot;&gt;JSON::PP&lt;/a&gt; is the default JSON backend. Using another JSON backend requires &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; 2.5 or later and you must set the &lt;code&gt;$ENV{PERL_JSON_BACKEND}&lt;/code&gt; to a supported alternate backend like &lt;a href=&quot;JSON::XS&quot;&gt;JSON::XS&lt;/a&gt;.</source>
          <target state="translated">对于 &lt;code&gt;version&lt;/code&gt; 2（或更高版本），文件名应以'.json'结尾。&lt;a href=&quot;JSON::PP&quot;&gt;JSON :: PP&lt;/a&gt;是默认的JSON后端。使用另一个JSON后端需要&lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; 2.5或更高版本，并且您必须将 &lt;code&gt;$ENV{PERL_JSON_BACKEND}&lt;/code&gt; 设置为受支持的备用后端，例如&lt;a href=&quot;JSON::XS&quot;&gt;JSON :: XS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65c2fddde0dcb7e596a58cd7354413b00cdbb867" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;version&lt;/code&gt; greater than or equal to 2, the string will be serialized as JSON. For &lt;code&gt;version&lt;/code&gt; less than 2, the string will be serialized as YAML. In both cases, the same rules are followed as in the &lt;code&gt;save()&lt;/code&gt; method for choosing a serialization backend.</source>
          <target state="translated">对于 &lt;code&gt;version&lt;/code&gt; 大于或等于2时，该字符串将被序列化为JSON。对于小于2的 &lt;code&gt;version&lt;/code&gt; ，该字符串将序列化为YAML。在这两种情况下，都遵循与 &lt;code&gt;save()&lt;/code&gt; 方法相同的规则来选择序列化后端。</target>
        </trans-unit>
        <trans-unit id="2b66f10f5f611d13a272f684c07136d9442ecc4a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;version&lt;/code&gt; less than 2, the filename should end in '.yml'. &lt;a href=&quot;CPAN::Meta::Converter&quot;&gt;CPAN::Meta::Converter&lt;/a&gt; is used to generate an older metadata structure, which is serialized to YAML. CPAN::Meta::YAML is the default YAML backend. You may set the &lt;code&gt;$ENV{PERL_YAML_BACKEND}&lt;/code&gt; to a supported alternative backend, though this is not recommended due to subtle incompatibilities between YAML parsers on CPAN.</source>
          <target state="translated">对于小于2的 &lt;code&gt;version&lt;/code&gt; ，文件名应以'.yml'结尾。&lt;a href=&quot;CPAN::Meta::Converter&quot;&gt;CPAN :: Meta ::: Converter&lt;/a&gt;用于生成旧的元数据结构，该结构被序列化为YAML。CPAN :: Meta ::: YAML是默认的YAML后端。您可以将 &lt;code&gt;$ENV{PERL_YAML_BACKEND}&lt;/code&gt; 设置为受支持的备用后端，尽管由于CPAN上的YAML解析器之间存在细微的不兼容性，所以不建议这样做。</target>
        </trans-unit>
        <trans-unit id="a61181a75805f7799b6c0c697c05f83d8dd25596" translate="yes" xml:space="preserve">
          <source>For BigInts, no padding occurs.</source>
          <target state="translated">对于BigInts,不会发生填充。</target>
        </trans-unit>
        <trans-unit id="a198a8cc7df6e759ce28837fe6aa6551a85a48c7" translate="yes" xml:space="preserve">
          <source>For C99 and later compilers, these correspond to things like &lt;code&gt;INT_MAX&lt;/code&gt;, which are available to the C code. But these constants, furnished by Perl, allow code compiled on earlier compilers to portably have access to the same constants.</source>
          <target state="translated">对于C99和更高版本的编译器，它们对应于 &lt;code&gt;INT_MAX&lt;/code&gt; 之类的内容，可用于C代码。但是，Perl提供的这些常量允许在较早的编译器上编译的代码可移植地访问相同的常量。</target>
        </trans-unit>
        <trans-unit id="159007f5b1b467e0716f482dcfafb34641ca6593" translate="yes" xml:space="preserve">
          <source>For CPAN distributions, you can assume that the XS types defined by the perl core are already available. Additionally, the core typemap has default XS types for a large number of C types. For example, if you simply return a &lt;code&gt;char *&lt;/code&gt; from your XSUB, the core typemap will have this C type associated with the T_PV XS type. That means your C string will be copied into the PV (pointer value) slot of a new scalar that will be returned from your XSUB to Perl.</source>
          <target state="translated">对于CPAN发行版，可以假定由perl核心定义的XS类型已经可用。此外，核心类型图具有用于大量C类型的默认XS类型。例如，如果仅从XSUB 返回 &lt;code&gt;char *&lt;/code&gt; ，则核心类型映射将具有与T_PV XS类型关联的C类型。这意味着您的C字符串将被复制到新标量的PV（指针值）插槽中，该标量将从XSUB返回到Perl。</target>
        </trans-unit>
        <trans-unit id="067800c18ab159aedbe7176e2a1ed014fc0ab19b" translate="yes" xml:space="preserve">
          <source>For CPerlMode, see &lt;a href=&quot;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&quot;&gt;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&lt;/a&gt;</source>
          <target state="translated">对于CPerlMode，请参见&lt;a href=&quot;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&quot;&gt;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="341ec625bce09fbf5b1fa92d6e293411fe6cb9c3" translate="yes" xml:space="preserve">
          <source>For CPerlMode, see &lt;a href=&quot;https://www.emacswiki.org/cgi-bin/wiki/CPerlMode&quot;&gt;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&lt;/a&gt;</source>
          <target state="translated">对于CPerlMode，请参见&lt;a href=&quot;https://www.emacswiki.org/cgi-bin/wiki/CPerlMode&quot;&gt;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e12f48bd95a450fad76910cdbdd13b43b481003" translate="yes" xml:space="preserve">
          <source>For Haiku specific problems contact the HaikuPorts developers: &lt;a href=&quot;http://ports.haiku-files.org/&quot;&gt;http://ports.haiku-files.org/&lt;/a&gt;</source>
          <target state="translated">对于Haiku特定的问题，请与HaikuPorts开发人员联系：&lt;a href=&quot;http://ports.haiku-files.org/&quot;&gt;http&lt;/a&gt; ://ports.haiku-files.org/</target>
        </trans-unit>
        <trans-unit id="1aa725456deafc0e9398eb1c8777ad30635d6763" translate="yes" xml:space="preserve">
          <source>For Irix 6.2 with perl threads, you have to have the following patches installed:</source>
          <target state="translated">对于带有 perl 线程的 Irix 6.2,您必须安装以下补丁。</target>
        </trans-unit>
        <trans-unit id="a36b859180dd2062331e5d0956bbf601eda4340d" translate="yes" xml:space="preserve">
          <source>For Loops</source>
          <target state="translated">对于循环</target>
        </trans-unit>
        <trans-unit id="f525ec14cf3a7406a3fd20ef6618215772bcd0e1" translate="yes" xml:space="preserve">
          <source>For Mac OS X see README.macosx</source>
          <target state="translated">关于Mac OS X,请参见README.macosx。</target>
        </trans-unit>
        <trans-unit id="eed4676ab31dbcb6f11dfd095f0c73b413f8978b" translate="yes" xml:space="preserve">
          <source>For Math::BigInt objects, no padding occurs.</source>
          <target state="translated">对于Math::BigInt对象,不会发生padding。</target>
        </trans-unit>
        <trans-unit id="d38d4d7cfb9b600d5802da277c23639b1baaadfc" translate="yes" xml:space="preserve">
          <source>For OS/2 just use</source>
          <target state="translated">对于OS/2,只需使用</target>
        </trans-unit>
        <trans-unit id="ce1ecc333508fb99ea251c3b1fc189bc1c2a1790" translate="yes" xml:space="preserve">
          <source>For Perl 5.9.4 or later, this module's effect is lexical.</source>
          <target state="translated">对于Perl 5.9.4或更高版本,这个模块的效果是词法。</target>
        </trans-unit>
        <trans-unit id="e030cb0c555e8c70da95992616dd7168e848f991" translate="yes" xml:space="preserve">
          <source>For Perl versions prior to 5.9.4, this module affects the whole script, instead of inside its lexical block.</source>
          <target state="translated">对于5.9.4之前的Perl版本,这个模块会影响整个脚本,而不是影响它的词法块。</target>
        </trans-unit>
        <trans-unit id="123b8c1601c884b5764bece329526a87e1364285" translate="yes" xml:space="preserve">
          <source>For Perls earlier than those described above, or when a string is passed to a function outside the scope of &lt;code&gt;unicode_strings&lt;/code&gt; , see the next section.</source>
          <target state="translated">对于早于上述描述的Perls，或将字符串传递到 &lt;code&gt;unicode_strings&lt;/code&gt; 范围之外的函数时，请参见下一节。</target>
        </trans-unit>
        <trans-unit id="3f0e9fab4a1b7e92028bd04a307df33da9707d95" translate="yes" xml:space="preserve">
          <source>For Perls earlier than those described above, or when a string is passed to a function outside the scope of &lt;code&gt;unicode_strings&lt;/code&gt;, see the next section.</source>
          <target state="translated">对于早于上述描述的Perls，或将字符串传递到 &lt;code&gt;unicode_strings&lt;/code&gt; 范围之外的函数时，请参见下一节。</target>
        </trans-unit>
        <trans-unit id="51e9cd46d8dc985ae6ee50db0816aefe5399b510" translate="yes" xml:space="preserve">
          <source>For RFC 1950, 1951 and 1952 see</source>
          <target state="translated">1950年、1951年和1952年的RFC见。</target>
        </trans-unit>
        <trans-unit id="e866e04431ebd2a55ea722b05274f955f01d07ee" translate="yes" xml:space="preserve">
          <source>For RFC 1950, 1951 and 1952 see &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1950.html&quot;&gt;http://www.faqs.org/rfcs/rfc1950.html&lt;/a&gt;, &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1951.html&quot;&gt;http://www.faqs.org/rfcs/rfc1951.html&lt;/a&gt; and &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1952.html&quot;&gt;http://www.faqs.org/rfcs/rfc1952.html&lt;/a&gt;</source>
          <target state="translated">对于1950年RFC 1951年和1952年看&lt;a href=&quot;http://www.faqs.org/rfcs/rfc1950.html&quot;&gt;http://www.faqs.org/rfcs/rfc1950.html&lt;/a&gt;，&lt;a href=&quot;http://www.faqs.org/rfcs/rfc1951.html&quot;&gt;http://www.faqs.org/rfcs/rfc1951.html&lt;/a&gt;和&lt;a href=&quot;http://www.faqs.org/rfcs/rfc1952.html&quot;&gt;http://www.faqs.org/ rfcs / rfc1952.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79d250a5e514d12306957ae3038fcbffa25a0e46" translate="yes" xml:space="preserve">
          <source>For SV-heads, the first slot in each arena is reserved, and holds a link to the next arena, some flags, and a note of the number of slots. Snaked through each arena chain is a linked list of free items; when this becomes empty, an extra arena is allocated and divided up into N items which are threaded into the free list.</source>
          <target state="translated">对于SV头来说,每个竞技场的第一个槽位都是保留的,里面有一个通往下一个竞技场的链接,一些标志,以及一个槽位数的说明。贯穿每个竞技场链的是一个自由物品的链接列表;当这个列表变成空的时候,就会分配一个额外的竞技场,并将其分成N个物品,这些物品会被穿行到自由列表中。</target>
        </trans-unit>
        <trans-unit id="d83cc596cefab565f5916e26bce4790ad8fbd819" translate="yes" xml:space="preserve">
          <source>For Solaris 2.6 and onwards, there are two different ways for 32-bit applications to manipulate large files (files whose size is &amp;gt; 2GByte). (A 64-bit application automatically has largefile support built in by default.)</source>
          <target state="translated">对于Solaris 2.6及更高版本，32位应用程序有两种不同的方式来处理大文件（文件大小&amp;gt; 2GB）。（默认情况下，一个64位应用程序自动自动具有大文件支持。）</target>
        </trans-unit>
        <trans-unit id="8dd5fe06604a74e02ef8359829b5b43f385d6346" translate="yes" xml:space="preserve">
          <source>For Storable files the rule is that they must be constructed such that &lt;code&gt;Storable::retrieve(file)&lt;/code&gt; returns an array reference and the array elements represent one distropref object each. The conversion from YAML would look like so:</source>
          <target state="translated">对于可存储文件，规则是必须构造它们，以使 &lt;code&gt;Storable::retrieve(file)&lt;/code&gt; 返回一个数组引用，并且每个数组元素代表一个Distropref对象。从YAML进行的转换如下所示：</target>
        </trans-unit>
        <trans-unit id="72dfa7009d0195f370727c265fe04b54add44bed" translate="yes" xml:space="preserve">
          <source>For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;&quot;Titlecase&quot;&lt;/a&gt;.</source>
          <target state="translated">有关Titlecase的信息，请参见&lt;a href=&quot;#Titlecase&quot;&gt;&amp;ldquo; Titlecase&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f58ed6574a36d30b785f4f498f48637179894cd" translate="yes" xml:space="preserve">
          <source>For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;.</source>
          <target state="translated">有关Titlecase的信息，请参见&lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="805f6202ade256f373021f2e5892254d89bc09aa" translate="yes" xml:space="preserve">
          <source>For Unicode versions between 3.1 and 3.1.1 inclusive,</source>
          <target state="translated">适用于3.1和3.1.1之间的Unicode版本。</target>
        </trans-unit>
        <trans-unit id="04defd080a27e1372a9c1dbe8cf6a89380139dd2" translate="yes" xml:space="preserve">
          <source>For Unicode versions between 3.1 and 3.1.1 inclusive, this field is empty unless there is a special folding for Turkic languages, in which case</source>
          <target state="translated">对于3.1和3.1.1(含)之间的Unicode版本,该字段为空,除非对突厥语有特殊的折叠,在这种情况下。</target>
        </trans-unit>
        <trans-unit id="5ee5d030e77aa7ec603a17bf82531f5a250c7f69" translate="yes" xml:space="preserve">
          <source>For Unix platforms that will be the equivalent of &quot;:unix:perlio&quot; or &quot;:stdio&quot;. Configure is set up to prefer the &quot;:stdio&quot; implementation if the system's library provides for fast access to the buffer (not common on modern architectures); otherwise, it uses the &quot;:unix:perlio&quot; implementation.</source>
          <target state="translated">对于Unix平台,这相当于&quot;:unix:perlio &quot;或&quot;:stdio&quot;。如果系统的库提供了对缓冲区的快速访问(在现代架构上不常见),则Configure被设置为优先选择&quot;:stdio &quot;实现;否则,它使用&quot;:unix:perlio &quot;实现。</target>
        </trans-unit>
        <trans-unit id="cbc319b6a7e7bbc5b0a21fcef4a3c90f8aa75d2f" translate="yes" xml:space="preserve">
          <source>For Unix platforms that will be the equivalent of &quot;unix perlio&quot; or &quot;stdio&quot;. Configure is set up to prefer the &quot;stdio&quot; implementation if the system's library provides for fast access to the buffer; otherwise, it uses the &quot;unix perlio&quot; implementation.</source>
          <target state="translated">对于Unix平台,这相当于 &quot;unix perlio &quot;或 &quot;stdio&quot;。如果系统的库提供了对缓冲区的快速访问,则Configure被设置为优先选择 &quot;stdio &quot;实现;否则,它使用 &quot;unix perlio &quot;实现。</target>
        </trans-unit>
        <trans-unit id="ddf8e7684d2c33a7c1793ba874a5f04310e9d4fc" translate="yes" xml:space="preserve">
          <source>For WHENCE, you may also use the constants &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , and &lt;code&gt;SEEK_END&lt;/code&gt; (start of the file, current position, end of the file) from the Fcntl module. Use of the constants is also more portable than relying on 0, 1, and 2. For example to define a &quot;systell&quot; function:</source>
          <target state="translated">对于WHENCE，你也可以使用常量 &lt;code&gt;SEEK_SET&lt;/code&gt; ， &lt;code&gt;SEEK_CUR&lt;/code&gt; 和 &lt;code&gt;SEEK_END&lt;/code&gt; （启动文件，当前位置，文件月底）Fcntl模组。与依赖0、1和2相比，常量的使用也更加可移植。例如，定义&amp;ldquo; systell&amp;rdquo;函数：</target>
        </trans-unit>
        <trans-unit id="4713c9fe1d32698f610a4455023de1df0dafca06" translate="yes" xml:space="preserve">
          <source>For WHENCE, you may also use the constants &lt;code&gt;SEEK_SET&lt;/code&gt;, &lt;code&gt;SEEK_CUR&lt;/code&gt;, and &lt;code&gt;SEEK_END&lt;/code&gt; (start of the file, current position, end of the file) from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module. Use of the constants is also more portable than relying on 0, 1, and 2. For example to define a &quot;systell&quot; function:</source>
          <target state="translated">对于WHENCE，你也可以使用常量 &lt;code&gt;SEEK_SET&lt;/code&gt; ， &lt;code&gt;SEEK_CUR&lt;/code&gt; 和 &lt;code&gt;SEEK_END&lt;/code&gt; （启动文件，当前位置，文件月底）从&lt;a href=&quot;fcntl&quot;&gt;FCNTL&lt;/a&gt;模块。与依赖0、1和2相比，常量的使用也更可移植。例如，定义&amp;ldquo; systell&amp;rdquo;函数：</target>
        </trans-unit>
        <trans-unit id="9c6f354666b012fb0b17a8266f1f19a75a5cd7ea" translate="yes" xml:space="preserve">
          <source>For Windows, use a binary version of Perl, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fstrawberryperl.com%2f&quot;&gt;Strawberry Perl&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActivePerl&lt;/a&gt; come with a bundled C compiler.</source>
          <target state="translated">对于Windows，请使用Perl的二进制版本，&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fstrawberryperl.com%2f&quot;&gt;Strawberry Perl&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActivePerl&lt;/a&gt;附带捆绑的C编译器。</target>
        </trans-unit>
        <trans-unit id="2f693188a9ab8e985eb42e0efe6af6a9b973fe16" translate="yes" xml:space="preserve">
          <source>For Windows, use a binary version of Perl, &lt;a href=&quot;http://strawberryperl.com/&quot;&gt;Strawberry Perl&lt;/a&gt; and &lt;a href=&quot;http://www.activestate.com/activeperl&quot;&gt;ActivePerl&lt;/a&gt; come with a bundled C compiler.</source>
          <target state="translated">对于Windows，请使用Perl的二进制版本，&lt;a href=&quot;http://strawberryperl.com/&quot;&gt;Strawberry Perl&lt;/a&gt;和&lt;a href=&quot;http://www.activestate.com/activeperl&quot;&gt;ActivePerl&lt;/a&gt;附带捆绑的C编译器。</target>
        </trans-unit>
        <trans-unit id="0bc29c01f1f40b44222495237814148b2dc132b8" translate="yes" xml:space="preserve">
          <source>For Windows, use a binary version of Perl, &lt;a href=&quot;http://strawberryperl.com/&quot;&gt;Strawberry Perl&lt;/a&gt; and &lt;a href=&quot;https://www.activestate.com/activeperl&quot;&gt;ActivePerl&lt;/a&gt; come with a bundled C compiler.</source>
          <target state="translated">对于Windows，请使用Perl的二进制版本，&lt;a href=&quot;http://strawberryperl.com/&quot;&gt;Strawberry Perl&lt;/a&gt;和&lt;a href=&quot;https://www.activestate.com/activeperl&quot;&gt;ActivePerl&lt;/a&gt;附带捆绑的C编译器。</target>
        </trans-unit>
        <trans-unit id="ddebad79af1e1455a2ecfd8699251bd717e5556f" translate="yes" xml:space="preserve">
          <source>For a complete description of all MakeMaker methods see &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt;.</source>
          <target state="translated">有关所有MakeMaker方法的完整说明，请参见&lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils :: MM_Unix&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4096062d54d81319c0a84a69e9fb5a2773f4aae4" translate="yes" xml:space="preserve">
          <source>For a complete description of all MakeMaker methods see &lt;a href=&quot;mm_unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt;.</source>
          <target state="translated">有关所有MakeMaker方法的完整说明，请参见&lt;a href=&quot;mm_unix&quot;&gt;ExtUtils :: MM_Unix&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f3ff924d2e8af712b8d94ac227d4cdb31a1d1a1" translate="yes" xml:space="preserve">
          <source>For a complete description of the PerlIO abstraction, consult &lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt;.</source>
          <target state="translated">有关PerlIO抽象的完整说明，请参阅&lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc9dbf2a0896fe69103f2db77a57c60a5869908f" translate="yes" xml:space="preserve">
          <source>For a complete list of features check &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">有关功能的完整列表，请检查&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99ae84c904dc87594aba13edffb373bf48c2a651" translate="yes" xml:space="preserve">
          <source>For a complete version of Tom Christiansen's vi configuration file, see &lt;a href=&quot;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz&quot;&gt;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz&lt;/a&gt; , the standard benchmark file for vi emulators. The file runs best with nvi, the current version of vi out of Berkeley, which incidentally can be built with an embedded Perl interpreter--see &lt;a href=&quot;http://www.cpan.org/src/misc/&quot;&gt;http://www.cpan.org/src/misc/&lt;/a&gt; .</source>
          <target state="translated">有关Tom Christiansen的vi配置文件的完整版本，请参见&lt;a href=&quot;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz&quot;&gt;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz（vi&lt;/a&gt;仿真器的标准基准文件）。该文件在nvi上运行效果最好，nvi是Berkeley的vi的最新版本，顺便说一句，可以使用嵌入式Perl解释器构建该文件-请参见&lt;a href=&quot;http://www.cpan.org/src/misc/&quot;&gt;http://www.cpan.org/src/misc/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="537d1bfba604bd0eb2268586149eaf40c35ff3c1" translate="yes" xml:space="preserve">
          <source>For a complete version of Tom Christiansen's vi configuration file, see &lt;a href=&quot;http://www.cpan.org/authors/id/T/TO/TOMC/scripts/toms.exrc.gz&quot;&gt;http://www.cpan.org/authors/id/T/TO/TOMC/scripts/toms.exrc.gz&lt;/a&gt; , the standard benchmark file for vi emulators. The file runs best with nvi, the current version of vi out of Berkeley, which incidentally can be built with an embedded Perl interpreter--see &lt;a href=&quot;http://www.cpan.org/src/misc/&quot;&gt;http://www.cpan.org/src/misc/&lt;/a&gt; .</source>
          <target state="translated">有关Tom Christiansen的vi配置文件的完整版本，请参见&lt;a href=&quot;http://www.cpan.org/authors/id/T/TO/TOMC/scripts/toms.exrc.gz&quot;&gt;http://www.cpan.org/authors/id/T/TO/TOMC/scripts/toms.exrc.gz（vi&lt;/a&gt;仿真器的标准基准文件）。该文件在nvi上运行效果最好，nvi是Berkeley的vi的当前版本，顺便说一句，可以使用嵌入式Perl解释器进行构建-请参见&lt;a href=&quot;http://www.cpan.org/src/misc/&quot;&gt;http://www.cpan.org/src/misc/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="705318b135eb6a59cbff8cc7756ef8640468bf71" translate="yes" xml:space="preserve">
          <source>For a comprehensive date and time representation look at the &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; module on CPAN.</source>
          <target state="translated">要获得全面的日期和时间表示，请查看CPAN上的&lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="666016f5dbbd95bef8b212430bb2473fc2b4dcb2" translate="yes" xml:space="preserve">
          <source>For a comprehensive date and time representation look at the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module on CPAN.</source>
          <target state="translated">要获得全面的日期和时间表示，请查看CPAN 上的&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="16eedbead27a5bc94e1ec2e16fa1f6580882483a" translate="yes" xml:space="preserve">
          <source>For a definition of the meaning and valid values for &lt;code&gt;MemLevel&lt;/code&gt; refer to the</source>
          <target state="translated">有关 &lt;code&gt;MemLevel&lt;/code&gt; 含义和有效值的定义，请参阅</target>
        </trans-unit>
        <trans-unit id="a1e24d70e0b1f2c78e32cfdc770b1dd79ea05b81" translate="yes" xml:space="preserve">
          <source>For a definition of the meaning and valid values for &lt;code&gt;WindowBits&lt;/code&gt; refer to the</source>
          <target state="translated">有关 &lt;code&gt;WindowBits&lt;/code&gt; 含义和有效值的定义，请参见</target>
        </trans-unit>
        <trans-unit id="e1dffbb7b106a3b121865266cc8508e33d6967ff" translate="yes" xml:space="preserve">
          <source>For a description of the variables, please have a look at the Glossary file, as written in the Porting folder, or use the url: &lt;a href=&quot;http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary&quot;&gt;http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary&lt;/a&gt;</source>
          <target state="translated">有关变量的描述，请查看Porting文件夹中编写的Glossary文件，或使用以下网址：&lt;a href=&quot;http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary&quot;&gt;http&lt;/a&gt; : //perl5.git.perl.org/perl.git/blob/HEAD :/Porting /词汇表</target>
        </trans-unit>
        <trans-unit id="6062949904481f0e001f1e56a47c4953d0a38335" translate="yes" xml:space="preserve">
          <source>For a description of the variables, please have a look at the Glossary file, as written in the Porting folder, or use the url: https://github.com/Perl/perl5/blob/blead/Porting/Glossary</source>
          <target state="translated">关于变量的描述,请查看移植文件夹中的词汇表文件,或者使用网址:https://github.com/Perl/perl5/blob/blead/Porting/Glossary。</target>
        </trans-unit>
        <trans-unit id="522716bff942007c71b30eff73794b6a193c83f7" translate="yes" xml:space="preserve">
          <source>For a detailed description of calling conventions from C to Perl, consult &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">有关从C到Perl的调用约定的详细说明，请参阅&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce6a785d30d6f70115ae56148dad0b5f07adc9c9" translate="yes" xml:space="preserve">
          <source>For a discussion of issues surrounding file permissions and &lt;b&gt;-i&lt;/b&gt;, see &lt;a href=&quot;perlfaq5#Why-does-Perl-let-me-delete-read-only-files%3F-Why-does-i-clobber-protected-files%3F-Isn%27t-this-a-bug-in-Perl%3F&quot;&gt;&quot;Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl?&quot; in perlfaq5&lt;/a&gt;.</source>
          <target state="translated">有关文件权限和&lt;b&gt;-i&lt;/b&gt;的问题的讨论，请参见&lt;a href=&quot;perlfaq5#Why-does-Perl-let-me-delete-read-only-files%3F-Why-does-i-clobber-protected-files%3F-Isn%27t-this-a-bug-in-Perl%3F&quot;&gt;&amp;ldquo;为什么Perl让我删除只读文件？为什么-i破坏受保护的文件？这不是Perl中的错误吗？&amp;rdquo; 在perlfaq5中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb11e0b0c0d1be60a6f42c39836c50cc82216796" translate="yes" xml:space="preserve">
          <source>For a discussion of issues surrounding file permissions and &lt;b&gt;-i&lt;/b&gt;, see &lt;a href=&quot;perlfaq5#Why-does-Perl-let-me-delete-read-only-files%3f-Why-does--i-clobber-protected-files%3f-Isn't-this-a-bug-in-Perl%3f&quot;&gt;Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl? in perlfaq5&lt;/a&gt;.</source>
          <target state="translated">有关文件权限和&lt;b&gt;-i&lt;/b&gt;的问题的讨论，请参见&lt;a href=&quot;perlfaq5#Why-does-Perl-let-me-delete-read-only-files%3f-Why-does--i-clobber-protected-files%3f-Isn't-this-a-bug-in-Perl%3f&quot;&gt;为什么Perl让我删除只读文件？为什么-i破坏器保护文件？这不是Perl中的错误吗？在perlfaq5中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c17a0e02c18fc6ec53a4e2d1835d5c3756570710" translate="yes" xml:space="preserve">
          <source>For a full definition of the meaning and valid values for &lt;code&gt;WindowBits&lt;/code&gt; refer to the</source>
          <target state="translated">有关 &lt;code&gt;WindowBits&lt;/code&gt; 含义和有效值的完整定义，请参见</target>
        </trans-unit>
        <trans-unit id="ab6b2ccf022ed8c112662e8962e31264cb2b6d19" translate="yes" xml:space="preserve">
          <source>For a list of known issues, visit:</source>
          <target state="translated">有关已知问题的清单,请访问:</target>
        </trans-unit>
        <trans-unit id="e95ee6825d4d62b379fa548316d0c1e1647b716e" translate="yes" xml:space="preserve">
          <source>For a lot of situations, like interfacing to an error handler, this may be a perfectly adequate solution.</source>
          <target state="translated">对于很多情况下,比如与错误处理程序的接口,这可能是一个完美的解决方案。</target>
        </trans-unit>
        <trans-unit id="78fb5d513c6711626eae157d1505b4fda1465fce" translate="yes" xml:space="preserve">
          <source>For a module, this is generally where the documentation of the interfaces provided by the module goes, usually in the form of a list with an &lt;code&gt;=item&lt;/code&gt; for each interface. Depending on how many interfaces there are, you may want to put that documentation in separate METHODS, FUNCTIONS, CLASS METHODS, or INSTANCE METHODS sections instead and save the DESCRIPTION section for an overview.</source>
          <target state="translated">对于模块，通常是模块提供的接口文档所在的地方，通常采用列表的形式，每个接口带有 &lt;code&gt;=item&lt;/code&gt; 。根据存在的接口数量，您可能希望将该文档放在单独的METHODS，FUNCTIONS，CLASS METHODS或INSTANCE METHODS部分中，然后将DESCRIPTION部分保存为概述。</target>
        </trans-unit>
        <trans-unit id="a1d4f8c4cd53b34a329bab7f01392ac51898bdf5" translate="yes" xml:space="preserve">
          <source>For a more complete explanation of 64-bit issues, see the &quot;Solaris 64-bit Developer's Guide&quot; at &lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt;</source>
          <target state="translated">有关64位问题的更完整说明，请参见&lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/上&lt;/a&gt;的《 Solaris 64位开发人员指南》。</target>
        </trans-unit>
        <trans-unit id="8e2c5e657d81bf42c0416b6bb7cf83065d719466" translate="yes" xml:space="preserve">
          <source>For a more complicated interface, see &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;. Many (most) features of &lt;code&gt;DynaLoader&lt;/code&gt; are not implemented in &lt;code&gt;XSLoader&lt;/code&gt; , like for example the &lt;code&gt;dl_load_flags&lt;/code&gt; , not honored by &lt;code&gt;XSLoader&lt;/code&gt; .</source>
          <target state="translated">有关更复杂的界面，请参见&lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;。许多（大多数）功能 &lt;code&gt;DynaLoader&lt;/code&gt; 尚未实现 &lt;code&gt;XSLoader&lt;/code&gt; ，如例如 &lt;code&gt;dl_load_flags&lt;/code&gt; ，不兑现 &lt;code&gt;XSLoader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a54563befbfb9741b74c08411d734d73a701db49" translate="yes" xml:space="preserve">
          <source>For a more complicated interface, see &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;. Many (most) features of &lt;code&gt;DynaLoader&lt;/code&gt; are not implemented in &lt;code&gt;XSLoader&lt;/code&gt;, like for example the &lt;code&gt;dl_load_flags&lt;/code&gt;, not honored by &lt;code&gt;XSLoader&lt;/code&gt;.</source>
          <target state="translated">有关更复杂的界面，请参见&lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;。许多（大多数）功能 &lt;code&gt;DynaLoader&lt;/code&gt; 尚未实现 &lt;code&gt;XSLoader&lt;/code&gt; ，如例如 &lt;code&gt;dl_load_flags&lt;/code&gt; ，不兑现 &lt;code&gt;XSLoader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c134a320b4cf48bdf8f6ab3775da940622ed9a6" translate="yes" xml:space="preserve">
          <source>For a more detailed discussion, see &lt;a href=&quot;Unicode::Semantics&quot;&gt;Unicode::Semantics&lt;/a&gt; on CPAN.</source>
          <target state="translated">有关更详细的讨论，请参见CPAN上的&lt;a href=&quot;Unicode::Semantics&quot;&gt;Unicode :: Semantics&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cd2b461432789a1d128d890e829743972bfea8c" translate="yes" xml:space="preserve">
          <source>For a more detailed discussion, see &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Semantics&quot;&gt;Unicode::Semantics&lt;/a&gt; on CPAN.</source>
          <target state="translated">有关更详细的讨论，请参见CPAN上的&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Semantics&quot;&gt;Unicode :: Semantics&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="734d1e26906ca381487d708f04f33fc705057ebb" translate="yes" xml:space="preserve">
          <source>For a more featureful version of this program, you should look to the</source>
          <target state="translated">对于这个程序的功能更多的版本,你应该看一下。</target>
        </trans-unit>
        <trans-unit id="6cc9a4597b12d4f9cbe49ad17ba062101c23d9dc" translate="yes" xml:space="preserve">
          <source>For a multi-line string, you can apply the regular expression to each logical line in the string by adding the &lt;code&gt;/m&lt;/code&gt; flag (for &quot;multi-line&quot;). With the &lt;code&gt;/m&lt;/code&gt; flag, the &lt;code&gt;$&lt;/code&gt; matches</source>
          <target state="translated">对于多行字符串，可以通过添加 &lt;code&gt;/m&lt;/code&gt; 标志（对于&amp;ldquo;多行&amp;rdquo;）将正则表达式应用于字符串中的每个逻辑行。使用 &lt;code&gt;/m&lt;/code&gt; 标志， &lt;code&gt;$&lt;/code&gt; 匹配</target>
        </trans-unit>
        <trans-unit id="853ea4ea0b4a8a77b8f91e4b9431c81b99fef254" translate="yes" xml:space="preserve">
          <source>For a platform independent &lt;a href=&quot;File::Copy#move&quot;&gt;&lt;code&gt;move&lt;/code&gt;&lt;/a&gt; function look at the &lt;a href=&quot;File::Copy&quot;&gt;File::Copy&lt;/a&gt; module.</source>
          <target state="translated">对于独立于平台的&lt;a href=&quot;File::Copy#move&quot;&gt; &lt;code&gt;move&lt;/code&gt; &lt;/a&gt;功能，请&lt;a href=&quot;File::Copy&quot;&gt;查看File :: Copy&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="a6bf5a779844f3ff794b0be678bf9271933d780d" translate="yes" xml:space="preserve">
          <source>For a platform independent &lt;code&gt;move&lt;/code&gt; function look at the &lt;a href=&quot;../file/copy&quot;&gt;File::Copy&lt;/a&gt; module.</source>
          <target state="translated">对于独立于平台的 &lt;code&gt;move&lt;/code&gt; 功能，请&lt;a href=&quot;../file/copy&quot;&gt;查看File :: Copy&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="fab0333533e228e4f9c3f37bd78da5462c6d46ad" translate="yes" xml:space="preserve">
          <source>For a platform independent &lt;code&gt;move&lt;/code&gt; function look at the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module.</source>
          <target state="translated">对于独立于平台的 &lt;code&gt;move&lt;/code&gt; 功能，请&lt;a href=&quot;file/copy&quot;&gt;查看File :: Copy&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="9fe5f7ac43651f01500eab4dab5aa1857bdfdac3" translate="yes" xml:space="preserve">
          <source>For a reference of available functions, please consult &lt;a href=&quot;File::Spec::Unix&quot;&gt;File::Spec::Unix&lt;/a&gt;, which contains the entire set, and which is inherited by the modules for other platforms. For further information, please see &lt;a href=&quot;File::Spec::Mac&quot;&gt;File::Spec::Mac&lt;/a&gt;, &lt;a href=&quot;File::Spec::OS2&quot;&gt;File::Spec::OS2&lt;/a&gt;, &lt;a href=&quot;File::Spec::Win32&quot;&gt;File::Spec::Win32&lt;/a&gt;, or &lt;a href=&quot;File::Spec::VMS&quot;&gt;File::Spec::VMS&lt;/a&gt;.</source>
          <target state="translated">有关可用功能的参考，请查阅&lt;a href=&quot;File::Spec::Unix&quot;&gt;File :: Spec :: Unix&lt;/a&gt;，它包含整个集合，并且由其他平台的模块继承。有关更多信息，请参见&lt;a href=&quot;File::Spec::Mac&quot;&gt;File :: Spec :: Mac&lt;/a&gt;，&lt;a href=&quot;File::Spec::OS2&quot;&gt;File :: Spec :: OS2&lt;/a&gt;，&lt;a href=&quot;File::Spec::Win32&quot;&gt;File :: Spec :: Win32&lt;/a&gt;或&lt;a href=&quot;File::Spec::VMS&quot;&gt;File :: Spec :: VMS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f487551c011cbdc8bfa8463318b0aee937e41d35" translate="yes" xml:space="preserve">
          <source>For a reference of available functions, please consult &lt;a href=&quot;unix&quot;&gt;File::Spec::Unix&lt;/a&gt;, which contains the entire set, and which is inherited by the modules for other platforms. For further information, please see &lt;a href=&quot;mac&quot;&gt;File::Spec::Mac&lt;/a&gt;, &lt;a href=&quot;os2&quot;&gt;File::Spec::OS2&lt;/a&gt;, &lt;a href=&quot;win32&quot;&gt;File::Spec::Win32&lt;/a&gt;, or &lt;a href=&quot;vms&quot;&gt;File::Spec::VMS&lt;/a&gt;.</source>
          <target state="translated">有关可用功能的参考，请查阅&lt;a href=&quot;unix&quot;&gt;File :: Spec :: Unix&lt;/a&gt;，它包含整个集合，并且由其他平台的模块继承。有关更多信息，请参见&lt;a href=&quot;mac&quot;&gt;File :: Spec :: Mac&lt;/a&gt;，&lt;a href=&quot;os2&quot;&gt;File :: Spec :: OS2&lt;/a&gt;，&lt;a href=&quot;win32&quot;&gt;File :: Spec :: Win32&lt;/a&gt;或&lt;a href=&quot;vms&quot;&gt;File :: Spec :: VMS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f9c9e2ecd1a16426e5e2b2966118c8ee32aab8e" translate="yes" xml:space="preserve">
          <source>For a regular expression to match, the</source>
          <target state="translated">对于一个正则表达式来说,要匹配的</target>
        </trans-unit>
        <trans-unit id="12a058b2c4bc4051745b895283da9f14f036e153" translate="yes" xml:space="preserve">
          <source>For a shorter message you can use &lt;code&gt;carp()&lt;/code&gt; or &lt;code&gt;croak()&lt;/code&gt; which report the error as being from where your module was called. &lt;code&gt;shortmess()&lt;/code&gt; returns the contents of this error message. There is no guarantee that that is where the error was, but it is a good educated guess.</source>
          <target state="translated">对于简短消息，您可以使用 &lt;code&gt;carp()&lt;/code&gt; 或 &lt;code&gt;croak()&lt;/code&gt; 将错误报告为从调用模块的位置发出。 &lt;code&gt;shortmess()&lt;/code&gt; 返回此错误消息的内容。无法保证这就是错误的出处，但这是有根据的猜测。</target>
        </trans-unit>
        <trans-unit id="fb0c681298006459cb4148344c2595f821ef7745" translate="yes" xml:space="preserve">
          <source>For a simple memory dump we unpack some bytes into just as many pairs of hex digits, and use &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; to handle the traditional spacing - 16 bytes to a line:</source>
          <target state="translated">为了进行简单的内存转储，我们将一些字节解压缩为尽可能多的十六进制数字对，并使用 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 处理传统的间距-每行16字节：</target>
        </trans-unit>
        <trans-unit id="ccb1c1f18575521b9ef05aa8422ef0eb387743f9" translate="yes" xml:space="preserve">
          <source>For a simple memory dump we unpack some bytes into just as many pairs of hex digits, and use &lt;code&gt;map&lt;/code&gt; to handle the traditional spacing - 16 bytes to a line:</source>
          <target state="translated">为了进行简单的内存转储，我们将一些字节解压缩为尽可能多的十六进制数字对，并使用 &lt;code&gt;map&lt;/code&gt; 处理传统的间距-每行16字节：</target>
        </trans-unit>
        <trans-unit id="b2806550c8443279c35452efc8ac267d0d3adceb" translate="yes" xml:space="preserve">
          <source>For a string not starting with a colon, the string exactly matches the package and subroutine that threw the exception. For example, &lt;code&gt;MyModule::log&lt;/code&gt;. If the string does not contain a package name, &lt;code&gt;CORE::&lt;/code&gt; is assumed.</source>
          <target state="translated">对于不是以冒号开头的字符串，该字符串与引发异常的程序包和子例程完全匹配。例如， &lt;code&gt;MyModule::log&lt;/code&gt; 。如果字符串不包含程序包名称，则假定为 &lt;code&gt;CORE::&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="474b374fb568d2c64a0a26b261b680939a644f1e" translate="yes" xml:space="preserve">
          <source>For a string that does start with a colon, if the subroutine throwing the exception</source>
          <target state="translated">对于一个以冒号开头的字符串,如果抛出异常的子程序</target>
        </trans-unit>
        <trans-unit id="a9983d9987e6ef65795138624e5828a8ab90649d" translate="yes" xml:space="preserve">
          <source>For a summary of common filehandle operations such as these, see &lt;a href=&quot;perlintro#Files-and-I%2FO&quot;&gt;&quot;Files and I/O&quot; in perlintro&lt;/a&gt;.</source>
          <target state="translated">有关诸如此类的常见文件句柄操作的摘要，请参见&lt;a href=&quot;perlintro#Files-and-I%2FO&quot;&gt;perlintro中的&amp;ldquo;文件和I / O&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="026cee18f593cdbc6cd7c55d97ff71525a5c1f08" translate="yes" xml:space="preserve">
          <source>For a temporary directory object the directory will be removed unless the CLEANUP argument was used in the constructor (and set to false) or &lt;code&gt;unlink_on_destroy&lt;/code&gt; was modified after creation. Note that if a temp directory is your current directory, it cannot be removed - a warning will be given in this case. &lt;code&gt;chdir()&lt;/code&gt; out of the directory before letting the object go out of scope.</source>
          <target state="translated">对于临时目录对象，除非在构造函数中使用了CLEANUP参数（并将其设置为false）或在创建后修改了 &lt;code&gt;unlink_on_destroy&lt;/code&gt; ，否则该目录将被删除。请注意，如果临时目录是您的当前目录，则无法将其删除-在这种情况下将给出警告。 &lt;code&gt;chdir()&lt;/code&gt; 移出目录，然后再使对象超出范围。</target>
        </trans-unit>
        <trans-unit id="e678ac9367be7209ea98d2129135c603f780f7f5" translate="yes" xml:space="preserve">
          <source>For a temporary directory object the directory will be removed unless the CLEANUP argument was used in the constructor (and set to false) or C</source>
          <target state="translated">对于一个临时目录对象,除非在构造函数中使用了CLEANUP参数(并设置为false),否则该目录将被删除,或者C</target>
        </trans-unit>
        <trans-unit id="0e148eb23ba15eaf53b9aed2b26acd83d3960120" translate="yes" xml:space="preserve">
          <source>For a yet-more-powerful import facility, see &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">有关更强大的导入工具，请参见&lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;和&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3fb4aa2117d863e4ff4ee47b2be92089f4f6d542" translate="yes" xml:space="preserve">
          <source>For a yet-more-powerful import facility, see &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">有关更强大的导入工具，请参见&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99100d6030ac9440264e837ee275b962c9e0a325" translate="yes" xml:space="preserve">
          <source>For a yet-more-powerful import facility, see &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">有关更强大的导入工具，请参见&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;和&lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12d37a3337ef055e2912d9c372185cda516b253c" translate="yes" xml:space="preserve">
          <source>For abbreviated and full length days of the week and months of the year:</source>
          <target state="translated">用于一周和一年中各月的简称和全称。</target>
        </trans-unit>
        <trans-unit id="23a93e384211636cb7b918f38dba4af06dd07c92" translate="yes" xml:space="preserve">
          <source>For absolute paths, some cleanup is done, to ensure that the volume name isn't immediately followed by updirs. This is invalid, because this would go beyond &quot;root&quot;. Generally, these cases are handled like their Unix counterparts:</source>
          <target state="translated">对于绝对路径,会进行一些清理,以确保卷名后面不会紧跟updirs。这是无效的,因为这将超越 &quot;root&quot;。一般来说,这些情况的处理方式和Unix系统的处理方式是一样的。</target>
        </trans-unit>
        <trans-unit id="de74cc30b9d5ee8d61e142d3f7218703345c5703" translate="yes" xml:space="preserve">
          <source>For accessing ftp servers behind such firewalls you usually need to set the environment variable &lt;code&gt;FTP_PASSIVE&lt;/code&gt; or the config variable ftp_passive to a true value.</source>
          <target state="translated">要访问位于此类防火墙后的ftp服务器，通常需要将环境变量 &lt;code&gt;FTP_PASSIVE&lt;/code&gt; 或配置变量ftp_passive设置为真实值。</target>
        </trans-unit>
        <trans-unit id="e841dd02723243da9bd704ad42284da8ce16a1a4" translate="yes" xml:space="preserve">
          <source>For additional guidance on the naming of modules, please consult:</source>
          <target state="translated">关于模块命名的额外指导,请参考:</target>
        </trans-unit>
        <trans-unit id="0b4892803f30a1551edad3f36449d4dfea0cc9e9" translate="yes" xml:space="preserve">
          <source>For additional information that may be more accurate for your specific system, see either</source>
          <target state="translated">有关您的特定系统可能更准确的其他信息,请参见以下两种情况</target>
        </trans-unit>
        <trans-unit id="df5c3063e1e7bfc9c45afac4a1ff3ef3df54c7f4" translate="yes" xml:space="preserve">
          <source>For additional information that may be more accurate for your specific system, see either &lt;a href=&quot;http://man.he.net/man5/man&quot;&gt;man(5)&lt;/a&gt; or &lt;a href=&quot;http://man.he.net/man7/man&quot;&gt;man(7)&lt;/a&gt; depending on your system manual section numbering conventions.</source>
          <target state="translated">有关对于您的特定系统可能更准确的其他信息，请参见&lt;a href=&quot;http://man.he.net/man5/man&quot;&gt;man（5）&lt;/a&gt;或&lt;a href=&quot;http://man.he.net/man7/man&quot;&gt;man（7），&lt;/a&gt;具体取决于系统手册的部分编号约定。</target>
        </trans-unit>
        <trans-unit id="2a5a320ada3dc4a8bf88fe25047c87af995b7a83" translate="yes" xml:space="preserve">
          <source>For affected functions, the simple strategy to avoid data corruption is to always make the encoding of the exchanged data explicit. Choose an encoding that you know the extension can handle. Convert arguments passed to the extensions to that encoding and convert results back from that encoding. Write wrapper functions that do the conversions for you, so you can later change the functions when the extension catches up.</source>
          <target state="translated">对于受影响的函数,避免数据损坏的简单策略是始终明确交换数据的编码。选择一个你知道扩展可以处理的编码。将传递给扩展的参数转换为该编码,并将结果从该编码转换回来。编写包装函数,为你做转换,这样你可以在以后扩展赶上时改变函数。</target>
        </trans-unit>
        <trans-unit id="615225b2c41ede3ced593276d5e4d897d1d4111d" translate="yes" xml:space="preserve">
          <source>For alignment commands, a &lt;code&gt;count&lt;/code&gt; of 0 is equivalent to a &lt;code&gt;count&lt;/code&gt; of 1; both are no-ops.</source>
          <target state="translated">对于对齐命令， &lt;code&gt;count&lt;/code&gt; 0等于 &lt;code&gt;count&lt;/code&gt; 1；对于计数命令，计数等于1。两者都不是。</target>
        </trans-unit>
        <trans-unit id="317a7397e46e0f3311065cf89b919865f2fa40b0" translate="yes" xml:space="preserve">
          <source>For all Perl keywords, a &lt;code&gt;CORE::&lt;/code&gt; prefix will force the built-in function to be used, even if it has been overridden or would normally require the &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; pragma. Despite appearances, this has nothing to do with the CORE package, but is part of Perl's syntax.</source>
          <target state="translated">对于所有Perl关键字，即使已被覆盖或通常需要&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;编译指示， &lt;code&gt;CORE::&lt;/code&gt; 前缀也将强制使用内置函数。尽管有外观，但这与CORE包无关，但这是Perl语法的一部分。</target>
        </trans-unit>
        <trans-unit id="5654c5499f83106c9fbc91a4a0b159f7465964f0" translate="yes" xml:space="preserve">
          <source>For all of these quantifiers, Perl will try to match as much of the string as possible, while still allowing the regexp to succeed. Thus with &lt;code&gt;/a?.../&lt;/code&gt; , Perl will first try to match the regexp with the &lt;code&gt;a&lt;/code&gt; present; if that fails, Perl will try to match the regexp without the &lt;code&gt;a&lt;/code&gt; present. For the quantifier &lt;code&gt;*&lt;/code&gt; , we get the following:</source>
          <target state="translated">对于所有这些量词，Perl将尝试匹配尽可能多的字符串，同时仍允许正则表达式成功。因此，使用 &lt;code&gt;/a?.../&lt;/code&gt; ,Perl将首先尝试将regexp与 &lt;code&gt;a&lt;/code&gt; 匹配；如果失败了，Perl将尝试不匹配正则表达式 &lt;code&gt;a&lt;/code&gt; 礼物。对于量词 &lt;code&gt;*&lt;/code&gt; ，我们得到以下内容：</target>
        </trans-unit>
        <trans-unit id="c8d03f9e49df228290537d529cbf4990c0671b80" translate="yes" xml:space="preserve">
          <source>For all of these quantifiers, Perl will try to match as much of the string as possible, while still allowing the regexp to succeed. Thus with &lt;code&gt;/a?.../&lt;/code&gt;, Perl will first try to match the regexp with the &lt;code&gt;'a'&lt;/code&gt; present; if that fails, Perl will try to match the regexp without the &lt;code&gt;'a'&lt;/code&gt; present. For the quantifier &lt;code&gt;'*'&lt;/code&gt;, we get the following:</source>
          <target state="translated">对于所有这些量词，Perl将尝试匹配尽可能多的字符串，同时仍允许正则表达式成功。因此，使用 &lt;code&gt;/a?.../&lt;/code&gt; ,Perl将首先尝试将正则表达式与当前的 &lt;code&gt;'a'&lt;/code&gt; 匹配；如果失败，Perl将尝试匹配不存在 &lt;code&gt;'a'&lt;/code&gt; 的正则表达式。对于量词 &lt;code&gt;'*'&lt;/code&gt; ，我们得到以下结果：</target>
        </trans-unit>
        <trans-unit id="230fb8eb56a362692b30784cae41866149fb8d70" translate="yes" xml:space="preserve">
          <source>For all other systems it defaults to 0.</source>
          <target state="translated">对于所有其他系统,它的默认值为0。</target>
        </trans-unit>
        <trans-unit id="2b3be3625a22c5493e08ee37b2b7c03a9c3eeed2" translate="yes" xml:space="preserve">
          <source>For an alternate representation of digits, for the radix character used between the integer and the fractional part of decimal numbers, the group separator string for large-ish floating point numbers (yes, the final two are redundant with &lt;a href=&quot;posix#localeconv&quot;&gt;POSIX::localeconv()&lt;/a&gt;):</source>
          <target state="translated">对于数字的替代表示形式，对于整数和十进制小数部分之间使用的基数字符，使用大分隔浮点数的组分隔符字符串（是的，最后两个对于&lt;a href=&quot;posix#localeconv&quot;&gt;POSIX :: localeconv（）&lt;/a&gt;是多余的） ：</target>
        </trans-unit>
        <trans-unit id="2e88409e21116c6609cbafa0cf03db229fac1d32" translate="yes" xml:space="preserve">
          <source>For an autoloaded subroutine without a GV, will create a GV even if &lt;code&gt;level &amp;lt; 0&lt;/code&gt; . For an autoloaded subroutine without a stub, GvCV() of the result may be zero.</source>
          <target state="translated">对于没有GV的自动加载的子例程，即使 &lt;code&gt;level &amp;lt; 0&lt;/code&gt; ，也将创建GV 。对于没有存根的自动加载的子例程，结果的GvCV（）可能为零。</target>
        </trans-unit>
        <trans-unit id="44153398dcf07d8feee0f56cbeb2ca6ed0e81196" translate="yes" xml:space="preserve">
          <source>For an autoloaded subroutine without a GV, will create a GV even if &lt;code&gt;level &amp;lt; 0&lt;/code&gt;. For an autoloaded subroutine without a stub, &lt;code&gt;GvCV()&lt;/code&gt; of the result may be zero.</source>
          <target state="translated">对于没有GV的自动加载的子例程，即使 &lt;code&gt;level &amp;lt; 0&lt;/code&gt; ，也将创建GV 。对于没有存根的自动加载的子例程，结果的 &lt;code&gt;GvCV()&lt;/code&gt; 可能为零。</target>
        </trans-unit>
        <trans-unit id="9633677d1ed3a18e80dde705c855341e6f6f1ec2" translate="yes" xml:space="preserve">
          <source>For an example of its output, see &lt;a href=&quot;Devel::Peek&quot;&gt;Devel::Peek&lt;/a&gt;.</source>
          <target state="translated">有关其输出的示例，请参见&lt;a href=&quot;Devel::Peek&quot;&gt;Devel :: Peek&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fce8b2cbb90270479552270e5bb2cd555b023f38" translate="yes" xml:space="preserve">
          <source>For an example of its output, see &lt;a href=&quot;devel/peek&quot;&gt;Devel::Peek&lt;/a&gt;.</source>
          <target state="translated">有关其输出的示例，请参见&lt;a href=&quot;devel/peek&quot;&gt;Devel :: Peek&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a82a650eab82474d19ec3ef8108ffe5370503228" translate="yes" xml:space="preserve">
          <source>For an example of the use of Net::FTP see</source>
          <target state="translated">关于Net::FTP的使用实例,请参见</target>
        </trans-unit>
        <trans-unit id="bda70344f536c3a618951e75f8672661f9576c18" translate="yes" xml:space="preserve">
          <source>For an excellent all-around resource on the care and feeding of regular expressions, see the book</source>
          <target state="translated">有关正则表达式的护理和喂养的优秀的全方位资源,请参见本书的</target>
        </trans-unit>
        <trans-unit id="ca7f7d7124f6e693d58d8f8e7a5726f3c3d7d898" translate="yes" xml:space="preserve">
          <source>For an individual module:</source>
          <target state="translated">对于单个模块:</target>
        </trans-unit>
        <trans-unit id="e7eb2c9e0a9fd3fe5a6939bf4841e243661494a7" translate="yes" xml:space="preserve">
          <source>For an up-to-date list of plugins available, please check CPAN:</source>
          <target state="translated">最新的插件列表,请查看CPAN。</target>
        </trans-unit>
        <trans-unit id="cbc0f0a5a1b385be37d862973bb36b0e683cb185" translate="yes" xml:space="preserve">
          <source>For an up-to-date listing of CPAN sites, see &lt;a href=&quot;http://www.cpan.org/SITES&quot;&gt;http://www.cpan.org/SITES&lt;/a&gt; or &lt;a href=&quot;ftp://www.cpan.org/SITES&quot;&gt;ftp://www.cpan.org/SITES&lt;/a&gt; .</source>
          <target state="translated">有关CPAN网站的最新列表，请&lt;a href=&quot;http://www.cpan.org/SITES&quot;&gt;访问http://www.cpan.org/SITES&lt;/a&gt;或&lt;a href=&quot;ftp://www.cpan.org/SITES&quot;&gt;ftp://www.cpan.org/SITES&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f8d2f0deaef3e0e49b686044d018ef1fecb88ca" translate="yes" xml:space="preserve">
          <source>For an up-to-date listing of CPAN sites, see &lt;a href=&quot;https://www.cpan.org/SITES&quot;&gt;https://www.cpan.org/SITES&lt;/a&gt; or &lt;a href=&quot;ftp://www.cpan.org/SITES&quot;&gt;ftp://www.cpan.org/SITES&lt;/a&gt;.</source>
          <target state="translated">有关CPAN网站的最新列表，请参见&lt;a href=&quot;https://www.cpan.org/SITES&quot;&gt;https://www.cpan.org/SITES&lt;/a&gt;或&lt;a href=&quot;ftp://www.cpan.org/SITES&quot;&gt;ftp://www.cpan.org/SITES&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b089e20c1565cbb5757e1f93796b566e25654df" translate="yes" xml:space="preserve">
          <source>For another example using &lt;code&gt;IO::Poll&lt;/code&gt; and &lt;code&gt;Net::LibAsyncNS&lt;/code&gt;, see the</source>
          <target state="translated">有关使用 &lt;code&gt;IO::Poll&lt;/code&gt; 和 &lt;code&gt;Net::LibAsyncNS&lt;/code&gt; 另一个示例，请参见</target>
        </trans-unit>
        <trans-unit id="2a44adc0de3b8707fce2595b82fd4151cd924248" translate="yes" xml:space="preserve">
          <source>For any anon CVs in the pad, change &lt;code&gt;CvOUTSIDE&lt;/code&gt; of that CV from &lt;code&gt;old_cv&lt;/code&gt; to &lt;code&gt;new_cv&lt;/code&gt; if necessary. Needed when a newly-compiled CV has to be moved to a pre-existing CV struct.</source>
          <target state="translated">对于焊盘中的任何非 &lt;code&gt;CvOUTSIDE&lt;/code&gt; CV，如有必要，将该CV的 &lt;code&gt;old_cv&lt;/code&gt; 从old_cv更改为 &lt;code&gt;new_cv&lt;/code&gt; 。当新编译的CV必须移动到预先存在的CV结构时，需要此文件。</target>
        </trans-unit>
        <trans-unit id="d33a39ca090b8a159c7f5059badc4bd7ae75ac58" translate="yes" xml:space="preserve">
          <source>For any anon CVs in the pad, change CvOUTSIDE of that CV from old_cv to new_cv if necessary. Needed when a newly-compiled CV has to be moved to a pre-existing CV struct.</source>
          <target state="translated">对于垫子中的任何 anon CV,必要时将该 CV 的 CvOUTSIDE 从 old_cv 改为 new_cv。当新编译的 CV 需要移到已有的 CV 结构中时需要用到。</target>
        </trans-unit>
        <trans-unit id="a477cbd70fca9ccf72bc4fea464de24ee1323a5a" translate="yes" xml:space="preserve">
          <source>For any of the above listed attributes, case is not significant.</source>
          <target state="translated">对于上述任何一个属性,大小写都不重要。</target>
        </trans-unit>
        <trans-unit id="03cdf2cd57fb98494228a618ca150d5e64571b39" translate="yes" xml:space="preserve">
          <source>For any text entered at the debugger prompt, leading and trailing whitespace is first stripped before further processing. If a debugger command coincides with some function in your own program, merely precede the function with something that doesn't look like a debugger command, such as a leading &lt;code&gt;;&lt;/code&gt; or perhaps a &lt;code&gt;+&lt;/code&gt; , or by wrapping it with parentheses or braces.</source>
          <target state="translated">对于在调试器提示符下输入的任何文本，在进行进一步处理之前，首先会删除开头和结尾的空格。如果调试器命令与您自己程序中的某些功能相吻合，则只需在该功能之前加上看起来不像调试器命令的某些内容即可，例如Lead &lt;code&gt;;&lt;/code&gt; 或 &lt;code&gt;+&lt;/code&gt; 或用括号或花括号将其引起来。</target>
        </trans-unit>
        <trans-unit id="b820379547056e253ff549ed899ea5e188fbe0e7" translate="yes" xml:space="preserve">
          <source>For any text entered at the debugger prompt, leading and trailing whitespace is first stripped before further processing. If a debugger command coincides with some function in your own program, merely precede the function with something that doesn't look like a debugger command, such as a leading &lt;code&gt;;&lt;/code&gt; or perhaps a &lt;code&gt;+&lt;/code&gt;, or by wrapping it with parentheses or braces.</source>
          <target state="translated">对于在调试器提示符下输入的任何文本，在进行进一步处理之前，首先会删除开头和结尾的空格。如果调试器命令与您自己程序中的某些功能相吻合，则只需在该功能之前加上看起来不像调试器命令的某些内容即可，例如Lead &lt;code&gt;;&lt;/code&gt; 或 &lt;code&gt;+&lt;/code&gt; ，或用括号或花括号将其引起来。</target>
        </trans-unit>
        <trans-unit id="5f345c4981dc60d036c3d28eb6a32e02870746a6" translate="yes" xml:space="preserve">
          <source>For any type of reference, &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; is checked (see below). This variable is expected to be a code reference, and the current parameter is passed in. If this function doesn't exist (the variable is undef), or it recurses into &lt;code&gt;Carp&lt;/code&gt; , or it otherwise throws an exception, this is skipped, and Carp moves on to the next option, otherwise checking stops and the string returned is used.</source>
          <target state="translated">对于任何类型的引用，都将检查 &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; （请参见下文）。该变量应该是代码引用，并且会传入当前参数。如果该函数不存在（变量为undef），或者递归到 &lt;code&gt;Carp&lt;/code&gt; 中，或者抛出异常，则将其跳过，并鲤鱼移至下一个选项，否则检查停止并使用返回的字符串。</target>
        </trans-unit>
        <trans-unit id="59d104c59f183c270405bd88f8a633e59e8f7fcf" translate="yes" xml:space="preserve">
          <source>For any type of reference, &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; is checked (see below). This variable is expected to be a code reference, and the current parameter is passed in. If this function doesn't exist (the variable is undef), or it recurses into &lt;code&gt;Carp&lt;/code&gt;, or it otherwise throws an exception, this is skipped, and Carp moves on to the next option, otherwise checking stops and the string returned is used.</source>
          <target state="translated">对于任何类型的引用，都将检查 &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; （请参见下文）。该变量应该是代码引用，并且会传入当前参数。如果此函数不存在（变量为undef），或者递归到 &lt;code&gt;Carp&lt;/code&gt; 中，或者抛出异常，则将其跳过，并鲤鱼移至下一个选项，否则检查停止并使用返回的字符串。</target>
        </trans-unit>
        <trans-unit id="36e7ed4a969818cfa2aa043eb8a07c31ce2abf8d" translate="yes" xml:space="preserve">
          <source>For any version object which is initialized with multiple decimal places (either quoted or if possible v-string), or initialized using the &lt;a href=&quot;version#qv%28%29&quot;&gt;qv()&lt;/a&gt; operator, the stringified representation is returned in a normalized or reduced form (no extraneous zeros), and with a leading 'v':</source>
          <target state="translated">对于使用多个小数位初始化的任何版本对象（带引号或可能的v字符串），或使用&lt;a href=&quot;version#qv%28%29&quot;&gt;qv（）&lt;/a&gt;运算符初始化的任何版本对象，均以规范化或简化形式（无多余零）返回字符串化表示前导&amp;ldquo; v&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="7fa27de554c50c9df409ef4245d850e6b4403907" translate="yes" xml:space="preserve">
          <source>For applications using database backends, the standard &lt;code&gt;DBIx&lt;/code&gt; namespace has tries to help with keeping things nippy, not least because it tries to</source>
          <target state="translated">对于使用数据库后端的应用程序，标准 &lt;code&gt;DBIx&lt;/code&gt; 命名空间已尝试帮助使事情变得紧凑，尤其是因为它试图</target>
        </trans-unit>
        <trans-unit id="6520acef19e880d0e0ded68b3e58665471c2f6a0" translate="yes" xml:space="preserve">
          <source>For authors of extensions MakeMaker provides several Makefile targets. Most of the support comes from the &lt;a href=&quot;ExtUtils::Manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt; module, where additional documentation can be found.</source>
          <target state="translated">对于扩展的作者，MakeMaker提供了几个Makefile目标。大多数支持来自&lt;a href=&quot;ExtUtils::Manifest&quot;&gt;ExtUtils :: Manifest&lt;/a&gt;模块，可以在其中找到其他文档。</target>
        </trans-unit>
        <trans-unit id="1bce7a5486f7524150794956c47fe07d202d9af7" translate="yes" xml:space="preserve">
          <source>For authors of extensions MakeMaker provides several Makefile targets. Most of the support comes from the ExtUtils::Manifest module, where additional documentation can be found.</source>
          <target state="translated">对于扩展的作者,MakeMaker提供了几个Makefile目标。大部分的支持来自于ExtUtils::Manifest模块,在那里可以找到额外的文档。</target>
        </trans-unit>
        <trans-unit id="22bf05bb17e4a865ba888114b8b9f35fd176e0a9" translate="yes" xml:space="preserve">
          <source>For backward compatibility (with Perl 5.6), all properties writable without using the compound form mentioned so far may have &lt;code&gt;Is&lt;/code&gt; or &lt;code&gt;Is_&lt;/code&gt; prepended to their name, so &lt;code&gt;\P{Is_Lu}&lt;/code&gt; , for example, is equal to &lt;code&gt;\P{Lu}&lt;/code&gt; , and &lt;code&gt;\p{IsScript:Arabic}&lt;/code&gt; is equal to &lt;code&gt;\p{Arabic}&lt;/code&gt; .</source>
          <target state="translated">为了向后兼容（与Perl 5.6兼容），到目前为止，所有不使用上述化合物形式就可写的属性的名称都可能带有 &lt;code&gt;Is&lt;/code&gt; 或 &lt;code&gt;Is_&lt;/code&gt; ，因此 &lt;code&gt;\P{Is_Lu}&lt;/code&gt; 等于 &lt;code&gt;\P{Lu}&lt;/code&gt; ，并且 &lt;code&gt;\p{IsScript:Arabic}&lt;/code&gt; 等于 &lt;code&gt;\p{Arabic}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6f8997b0405898deebf35ed5de7d2d35e93f64e" translate="yes" xml:space="preserve">
          <source>For backward compatibility (with ancient Perl 5.6), all properties writable without using the compound form mentioned so far may have &lt;code&gt;Is&lt;/code&gt; or &lt;code&gt;Is_&lt;/code&gt; prepended to their name, so &lt;code&gt;\P{Is_Lu}&lt;/code&gt;, for example, is equal to &lt;code&gt;\P{Lu}&lt;/code&gt;, and &lt;code&gt;\p{IsScript:Arabic}&lt;/code&gt; is equal to &lt;code&gt;\p{Arabic}&lt;/code&gt;.</source>
          <target state="translated">为了向后兼容（与古老的Perl 5.6兼容），到目前为止，所有不使用上述复合形式而可写的属性都可以在其名称之前加上 &lt;code&gt;Is&lt;/code&gt; 或 &lt;code&gt;Is_&lt;/code&gt; ，因此 &lt;code&gt;\P{Is_Lu}&lt;/code&gt; 等于 &lt;code&gt;\P{Lu}&lt;/code&gt; ，和 &lt;code&gt;\p{IsScript:Arabic}&lt;/code&gt; 等于 &lt;code&gt;\p{Arabic}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="801eea6f48c31944eef870e82f2becb1739f362a" translate="yes" xml:space="preserve">
          <source>For backward compatibility reasons defining just PERL_GLOBAL_STRUCT doesn't actually hide all symbols inside a big global struct: some PerlIO_xxx vtables are left visible. The PERL_GLOBAL_STRUCT_PRIVATE then hides everything (see how the PERLIO_FUNCS_DECL is used).</source>
          <target state="translated">由于向后兼容性的原因,仅仅定义PERL_GLOBAL_STRUCT并不能真正隐藏一个大的全局结构内的所有符号:一些PerlIO_xxx vtables是可见的。PERL_GLOBAL_STRUCT_PRIVATE则会隐藏所有的东西(参见PERLIO_FUNCS_DECL的使用方法)。</target>
        </trans-unit>
        <trans-unit id="e59de1fc73fecfb78c070b75065d56f22077db4d" translate="yes" xml:space="preserve">
          <source>For backward compatibility with older implementations that didn't support anonymous globs, &lt;code&gt;Symbol::ungensym&lt;/code&gt; is also provided. But it doesn't do anything.</source>
          <target state="translated">为了与不支持匿名 &lt;code&gt;Symbol::ungensym&lt;/code&gt; 较旧实现向后兼容，还提供了Symbol :: ungensym。但是它什么也没做。</target>
        </trans-unit>
        <trans-unit id="1875b2cf9d0a9f2703d0d978c0e4f011fb418414" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;alternate&lt;/code&gt; (old name) can be used as an alias for &lt;code&gt;variable&lt;/code&gt; .</source>
          <target state="translated">为了向后兼容， &lt;code&gt;alternate&lt;/code&gt; （旧名称）可以用作 &lt;code&gt;variable&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="7db95484ae8f465f4ba0bfd96939032aa4269a8b" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;alternate&lt;/code&gt; (old name) can be used as an alias for &lt;code&gt;variable&lt;/code&gt;.</source>
          <target state="translated">为了向后兼容，可以将 &lt;code&gt;alternate&lt;/code&gt; （旧名称）用作 &lt;code&gt;variable&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="2a69034e83ea0d1a42d93d489742ef68d2660151" translate="yes" xml:space="preserve">
          <source>For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the &lt;code&gt;name=&amp;gt;value&lt;/code&gt; pairs.</source>
          <target state="translated">为了向后兼容，还可以将参数作为对包含 &lt;code&gt;name=&amp;gt;value&lt;/code&gt; 对的哈希的引用进行传递。</target>
        </trans-unit>
        <trans-unit id="3148562bf6a9aa8595388062dcaa9f8f17ba0473" translate="yes" xml:space="preserve">
          <source>For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the name=&amp;gt;value pairs.</source>
          <target state="translated">为了向后兼容，还可以将参数作为对包含name =&amp;gt; value对的哈希的引用进行传递。</target>
        </trans-unit>
        <trans-unit id="2ec61a0442a19b1bc3402a65ad2b4e4eaf169d23" translate="yes" xml:space="preserve">
          <source>For backward-compatibility, if the PADNAMEt_OUTER flag is set, the FLAGS method adds the SVf_FAKE flag, too.</source>
          <target state="translated">为了向后兼容,如果设置了PADNAMEt_OUTER标志,FLAGS方法也会添加SVf_FAKE标志。</target>
        </trans-unit>
        <trans-unit id="345abbc3eef47b853413a18eb3df89f5eb02f40e" translate="yes" xml:space="preserve">
          <source>For backwards compatibility in callbacks.</source>
          <target state="translated">用于回调的向后兼容性。</target>
        </trans-unit>
        <trans-unit id="fc612a7ead920771085f353b3e4c345acbc9a4da" translate="yes" xml:space="preserve">
          <source>For backwards compatibility reasons it is still possible to request a different storage class for use with Math::BigFloat:</source>
          <target state="translated">出于向后兼容的原因,仍然可以请求使用不同的存储类与Math::BigFloat一起使用。</target>
        </trans-unit>
        <trans-unit id="5515551787402a0e5935331cd95604ada3a19af4" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the &lt;code&gt;In&lt;/code&gt; prefix may be omitted if there is no naming conflict with a script or any other property, and you can even use an &lt;code&gt;Is&lt;/code&gt; prefix instead in those cases. But don't do this for new code because your code could break in new releases, and this has already happened: There was a time in very early Unicode releases when &lt;code&gt;\p{Hebrew}&lt;/code&gt; would have matched the</source>
          <target state="translated">为了向后兼容，如果与脚本或任何其他属性没有命名冲突，则可以省略 &lt;code&gt;In&lt;/code&gt; 前缀，在这种情况下，甚至可以使用 &lt;code&gt;Is&lt;/code&gt; 前缀。但是不要对新代码执行此操作，因为您的代码可能会在新版本中中断，并且这种情况已经发生：在很早的Unicode版本中，曾经有一段时间 &lt;code&gt;\p{Hebrew}&lt;/code&gt; 会与</target>
        </trans-unit>
        <trans-unit id="8221b631540f7fb41054f5d592fba788a0c89204" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, this error is also available as &lt;code&gt;$Archive::Tar::error&lt;/code&gt; although it is much recommended you use the method call instead.</source>
          <target state="translated">为了向后兼容，此错误也可以以 &lt;code&gt;$Archive::Tar::error&lt;/code&gt; 尽管强烈建议您改用方法调用。</target>
        </trans-unit>
        <trans-unit id="04c26648635d004dc1846a0436ba6682f4177e2f" translate="yes" xml:space="preserve">
          <source>For backwards compatibility. Use &lt;code&gt;grok_bin&lt;/code&gt; instead.</source>
          <target state="translated">为了向后兼容。请改用 &lt;code&gt;grok_bin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b83ee316e5b3391a5d7939b8d9c91163c18f189" translate="yes" xml:space="preserve">
          <source>For backwards compatibility. Use &lt;code&gt;grok_hex&lt;/code&gt; instead.</source>
          <target state="translated">为了向后兼容。请改用 &lt;code&gt;grok_hex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36110c740cb1d17f9559cf294dd0deb0c3ace7b6" translate="yes" xml:space="preserve">
          <source>For backwards compatibility. Use &lt;code&gt;grok_oct&lt;/code&gt; instead.</source>
          <target state="translated">为了向后兼容。请改用 &lt;code&gt;grok_oct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31ce154734530fbfe5db4b0523f628ba63c57438" translate="yes" xml:space="preserve">
          <source>For best results compile the C file below with the same options as the Perl DLL. However, a lot of functionality will work even if the executable is not an EMX applications, e.g., if compiled with</source>
          <target state="translated">为了获得最佳效果,请使用与Perl DLL相同的选项编译下面的C文件。然而,即使可执行文件不是EMX应用程序,很多功能也可以使用,例如,如果用</target>
        </trans-unit>
        <trans-unit id="3d5f802bf9952ee74baf54e5c421227e48fa981f" translate="yes" xml:space="preserve">
          <source>For best results use EMX pdksh. The standard binary (5.2.14 or later) runs under DOS (with &lt;a href=&quot;#RSX&quot;&gt;&quot;RSX&quot;&lt;/a&gt;) as well, see</source>
          <target state="translated">为了获得最佳效果，请使用EMX pdksh。标准二进制文件（5.2.14或更高版本）也可以在DOS下运行（带有&lt;a href=&quot;#RSX&quot;&gt;&amp;ldquo; RSX&amp;rdquo;&lt;/a&gt;），请参见</target>
        </trans-unit>
        <trans-unit id="9e295c225a2c063ef46517c1ea68fc0b9b4d3dfb" translate="yes" xml:space="preserve">
          <source>For best results use EMX pdksh. The standard binary (5.2.14 or later) runs under DOS (with &lt;a href=&quot;#RSX&quot;&gt;RSX&lt;/a&gt;) as well, see</source>
          <target state="translated">为了获得最佳效果，请使用EMX pdksh。标准二进制文件（5.2.14或更高版本）也可以在DOS（带有&lt;a href=&quot;#RSX&quot;&gt;RSX&lt;/a&gt;）下运行，请参见</target>
        </trans-unit>
        <trans-unit id="2f0811095fb18bd277912b660d1d859a6e53803d" translate="yes" xml:space="preserve">
          <source>For bigger projects, &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt; provides a rich set of features that will let you focus on implementing your business logic.</source>
          <target state="translated">对于较大的项目，&lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt;提供了丰富的功能集，使您可以专注于实现业务逻辑。</target>
        </trans-unit>
        <trans-unit id="485ae73f79d1afbd4e51bbd788b440af01136078" translate="yes" xml:space="preserve">
          <source>For bigger projects, &lt;a href=&quot;moose&quot;&gt;Moose&lt;/a&gt; provides a rich set of features that will let you focus on implementing your business logic. &lt;a href=&quot;moo&quot;&gt;Moo&lt;/a&gt; provides a nice alternative to &lt;a href=&quot;moose&quot;&gt;Moose&lt;/a&gt; when you want a lot of features but need faster compile time or to avoid XS.</source>
          <target state="translated">对于较大的项目，&lt;a href=&quot;moose&quot;&gt;Moose&lt;/a&gt;提供了一组丰富的功能，这些功能使您可以专注于实现业务逻辑。当您需要许多功能但需要更快的编译时间或避免使用XS时，&lt;a href=&quot;moo&quot;&gt;Moo&lt;/a&gt;是&lt;a href=&quot;moose&quot;&gt;Moose&lt;/a&gt;的不错选择。</target>
        </trans-unit>
        <trans-unit id="5b33560e28b1291edf22e615119f480a2b62681f" translate="yes" xml:space="preserve">
          <source>For bit fields, it returns a hash ref containing details about the field. The same reference will be returned for all bit positions that make up the bit field; so for example these both return the same hash ref:</source>
          <target state="translated">对于位字段,它返回一个包含字段细节的哈希 ref。对于构成位字段的所有位位置,将返回相同的引用;因此,例如,这两个位字段都返回相同的哈希 ref。</target>
        </trans-unit>
        <trans-unit id="d59e13b49a3ea8a677214c0ffa9c8aba3e39fb3c" translate="yes" xml:space="preserve">
          <source>For blocks see &lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/Blocks.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/Blocks.txt&lt;/a&gt;</source>
          <target state="translated">有关块，请参见&lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/Blocks.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/Blocks.txt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b4a370c8e600d80c0ddcf91afaf7c79cb7be44e" translate="yes" xml:space="preserve">
          <source>For blocks see &lt;a href=&quot;https://www.unicode.org/Public/UNIDATA/Blocks.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/Blocks.txt&lt;/a&gt;</source>
          <target state="translated">有关块，请参见&lt;a href=&quot;https://www.unicode.org/Public/UNIDATA/Blocks.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/Blocks.txt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6af4234a6a3a035875ec423a946acfcba1e657d0" translate="yes" xml:space="preserve">
          <source>For building and installing non-XS modules, all you need is a working perl under DJGPP. Non-XS modules do not require re-linking the perl binary, and so are simpler to build and install.</source>
          <target state="translated">对于非XS模块的构建和安装,您只需要在DJGPP下运行perl即可。非 XS 模块不需要重新链接 perl 二进制文件,因此构建和安装起来比较简单。</target>
        </trans-unit>
        <trans-unit id="bae42e060753892a262ac6235f3d580be0d729e0" translate="yes" xml:space="preserve">
          <source>For building perl to support Oracle, it needs to be linked with libcl and libpthread. So even if your perl is an unthreaded build, these libraries might be required. See &quot;Oracle on HP-UX&quot; below.</source>
          <target state="translated">为了构建支持Oracle的perl,需要与libcl和libpthread链接。所以即使你的perl是一个非线程的构建,这些库也可能是必需的。参见下面的 &quot;HP-UX上的Oracle&quot;。</target>
        </trans-unit>
        <trans-unit id="ae71424b7af33e662d7ce3e8063ed7f56ae7be34" translate="yes" xml:space="preserve">
          <source>For case-insensitive comparisions, look at the &lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt; case-folding function, available in Perl v5.16 or later:</source>
          <target state="translated">对于不区分大小写的比较，请查看&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;大小写折叠功能，该功能在Perl v5.16或更高版本中可用：</target>
        </trans-unit>
        <trans-unit id="c2c9f18069c14b8953e6086438f1569f7befce24" translate="yes" xml:space="preserve">
          <source>For case-insensitive comparisons, look at the &lt;a href=&quot;perlfunc#fc&quot;&gt;&quot;fc&quot; in perlfunc&lt;/a&gt; case-folding function, available in Perl v5.16 or later:</source>
          <target state="translated">对于不区分大小写的比较，请查看Perlunc大小写折叠功能中的&lt;a href=&quot;perlfunc#fc&quot;&gt;&amp;ldquo; fc&amp;rdquo;，该&lt;/a&gt;功能在Perl v5.16或更高版本中可用：</target>
        </trans-unit>
        <trans-unit id="1cb5c1d99fc673348b120d9a851d1117c6607188" translate="yes" xml:space="preserve">
          <source>For case-insensitiveness, the &quot;casefolding&quot; of Unicode is used instead of upper/lowercasing both the characters, see &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21/&quot;&gt;http://www.unicode.org/unicode/reports/tr21/&lt;/a&gt; (Case Mappings).</source>
          <target state="translated">对于不区分大小写的情况，使用Unicode的&amp;ldquo;大小写折叠&amp;rdquo;来代替上下两个字符，请参阅&lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21/&quot;&gt;http://www.unicode.org/unicode/reports/tr21/&lt;/a&gt;（大小写映射）。</target>
        </trans-unit>
        <trans-unit id="844ac956827b7b88b1f14a571dd1efe3bff10e90" translate="yes" xml:space="preserve">
          <source>For case-insensitiveness, the &quot;casefolding&quot; of Unicode is used instead of upper/lowercasing both the characters, see &lt;a href=&quot;https://www.unicode.org/unicode/reports/tr21/&quot;&gt;https://www.unicode.org/unicode/reports/tr21/&lt;/a&gt; (Case Mappings).</source>
          <target state="translated">对于不区分大小写的情况，将使用Unicode的&amp;ldquo;大小写折叠&amp;rdquo;来代替上下两个字符，请参阅&lt;a href=&quot;https://www.unicode.org/unicode/reports/tr21/&quot;&gt;https://www.unicode.org/unicode/reports/tr21/&lt;/a&gt;（案例映射）。</target>
        </trans-unit>
        <trans-unit id="724ee81f8304298ce7234758616a260234c90146" translate="yes" xml:space="preserve">
          <source>For changes significant enough to warrant a</source>
          <target state="translated">对于重大的变化,足以证明有必要进行</target>
        </trans-unit>
        <trans-unit id="b3dbbc26b46cd95b55d97892c7e30b541879c832" translate="yes" xml:space="preserve">
          <source>For clarity, you should already have been using &lt;code&gt;\t&lt;/code&gt; to specify a literal tab, and &lt;code&gt;\t&lt;/code&gt; is unaffected by &lt;code&gt;/xx&lt;/code&gt;.</source>
          <target state="translated">为了清楚起见，您应该已经在使用 &lt;code&gt;\t&lt;/code&gt; 来指定文字标签，并且 &lt;code&gt;\t&lt;/code&gt; 不受 &lt;code&gt;/xx&lt;/code&gt; 的影响。</target>
        </trans-unit>
        <trans-unit id="3357a4c3d096539100edeae44fe0fc63f41c1eb0" translate="yes" xml:space="preserve">
          <source>For cloning empty array or hash refs, the following may also be used:</source>
          <target state="translated">对于克隆空数组或哈希引用,也可以使用以下方法。</target>
        </trans-unit>
        <trans-unit id="066974b34c56796aa4147b1a5208072b1da06843" translate="yes" xml:space="preserve">
          <source>For code points above 255 ...</source>
          <target state="translated">代码点超过255的...</target>
        </trans-unit>
        <trans-unit id="4c34d997e245e8b3d1bd93691addc32a9edcde31" translate="yes" xml:space="preserve">
          <source>For code points below 256 ...</source>
          <target state="translated">对于代码点低于256...</target>
        </trans-unit>
        <trans-unit id="52fc59bd49cfa06cf9318166c80386309a2f14db" translate="yes" xml:space="preserve">
          <source>For compactness, '&lt;b&gt;*&lt;/b&gt;' is used as a wildcard instead of showing all possible combinations. For example, entries like:</source>
          <target state="translated">为了紧凑起见，&amp;ldquo; &lt;b&gt;*&lt;/b&gt; &amp;rdquo;用作通配符，而不显示所有可能的组合。例如，像这样的条目：</target>
        </trans-unit>
        <trans-unit id="7c09a91ddfd48857b97077c2773ecb81af6bc79f" translate="yes" xml:space="preserve">
          <source>For comparisons to a specific language it is often best to create a small project in both languages and compare the results, make sure to use all the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;resources&lt;/a&gt; of each language, as a language is far more than just it's syntax.</source>
          <target state="translated">为了与特定语言进行比较，通常最好使用两种语言创建一个小型项目并比较结果，并确保使用每种语言的所有&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;资源&lt;/a&gt;，因为一种语言不仅仅是语法。</target>
        </trans-unit>
        <trans-unit id="ced2a540dc94c886c1cbe6db66090842cbab20ed" translate="yes" xml:space="preserve">
          <source>For comparisons to a specific language it is often best to create a small project in both languages and compare the results, make sure to use all the &lt;a href=&quot;http://www.cpan.org/&quot;&gt;resources&lt;/a&gt; of each language, as a language is far more than just it's syntax.</source>
          <target state="translated">为了与特定语言进行比较，通常最好使用两种语言创建一个小型项目并比较结果，并确保使用每种语言的所有&lt;a href=&quot;http://www.cpan.org/&quot;&gt;资源&lt;/a&gt;，因为一种语言不仅仅是语法。</target>
        </trans-unit>
        <trans-unit id="5928beb9ec422a398dc240b1a98fb88a78eacc43" translate="yes" xml:space="preserve">
          <source>For compatibility with</source>
          <target state="translated">兼容性</target>
        </trans-unit>
        <trans-unit id="c8f850be2ede8c9aabb5e0eb4de353aba7ade37a" translate="yes" xml:space="preserve">
          <source>For compatibility with other parts of Perl, all the single forms given in the table in the &lt;a href=&quot;#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;section above&lt;/a&gt; are recognized. BUT, there are some ambiguities between some Perl extensions and the Unicode properties, all of which are silently resolved in favor of the official Unicode property. To avoid surprises, you should only use &lt;code&gt;prop_invmap()&lt;/code&gt; for forms listed in the table below, which omits the non-recommended ones. The affected forms are the Perl single form equivalents of Unicode properties, such as &lt;code&gt;\p{sc}&lt;/code&gt; being a single-form equivalent of &lt;code&gt;\p{gc=sc}&lt;/code&gt;, which is treated by &lt;code&gt;prop_invmap()&lt;/code&gt; as the &lt;code&gt;Script&lt;/code&gt; property, whose short name is &lt;code&gt;sc&lt;/code&gt;. The table indicates the current ambiguities in the INFO column, beginning with the word &lt;code&gt;&quot;NOT&quot;&lt;/code&gt;.</source>
          <target state="translated">为了与Perl的其他部分兼容，可以识别上&lt;a href=&quot;#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;一节&lt;/a&gt;中表中给出的所有单一格式。但是，某些Perl扩展和Unicode属性之间存在一些歧义，所有这些问题都被静默地解决，以支持正式的Unicode属性。为避免意外，您只 &lt;code&gt;prop_invmap()&lt;/code&gt; 下表中列出的表单使用prop_invmap（），而忽略不推荐的表单。受影响的形式是Unicode属性的Perl单一形式等效项，例如 &lt;code&gt;\p{sc}&lt;/code&gt; 是 &lt;code&gt;\p{gc=sc}&lt;/code&gt; 的单一形式等效项， &lt;code&gt;prop_invmap()&lt;/code&gt; 将其视为 &lt;code&gt;Script&lt;/code&gt; 属性，简称为Script属性。是 &lt;code&gt;sc&lt;/code&gt; 。该表在INFO列中指示当前歧义，以单词 &lt;code&gt;&quot;NOT&quot;&lt;/code&gt; 开头。</target>
        </trans-unit>
        <trans-unit id="a7092eb766c083ed1177ee219bb4e03d914e1567" translate="yes" xml:space="preserve">
          <source>For compatibility with other parts of Perl, all the single forms given in the table in the &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;section above&lt;/a&gt; are recognized. BUT, there are some ambiguities between some Perl extensions and the Unicode properties, all of which are silently resolved in favor of the official Unicode property. To avoid surprises, you should only use &lt;code&gt;prop_invmap()&lt;/code&gt; for forms listed in the table below, which omits the non-recommended ones. The affected forms are the Perl single form equivalents of Unicode properties, such as &lt;code&gt;\p{sc}&lt;/code&gt; being a single-form equivalent of &lt;code&gt;\p{gc=sc}&lt;/code&gt; , which is treated by &lt;code&gt;prop_invmap()&lt;/code&gt; as the &lt;code&gt;Script&lt;/code&gt; property, whose short name is &lt;code&gt;sc&lt;/code&gt; . The table indicates the current ambiguities in the INFO column, beginning with the word &lt;code&gt;&quot;NOT&quot;&lt;/code&gt; .</source>
          <target state="translated">为了与Perl的其他部分兼容，可以识别上&lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;一节&lt;/a&gt;中表中给出的所有单一格式。但是，某些Perl扩展名和Unicode属性之间存在一些歧义，所有这些问题都被默默地解决，以支持正式的Unicode属性。为避免意外，您仅 &lt;code&gt;prop_invmap()&lt;/code&gt; 用于下表中列出的表单，而忽略不推荐的表单。受影响的形式是Unicode属性的Perl单一形式等效项，例如 &lt;code&gt;\p{sc}&lt;/code&gt; 是 &lt;code&gt;\p{gc=sc}&lt;/code&gt; 的单一形式等效项， &lt;code&gt;prop_invmap()&lt;/code&gt; 将其视为 &lt;code&gt;Script&lt;/code&gt; 属性，其短名称是 &lt;code&gt;sc&lt;/code&gt; 。该表在INFO列中指示当前歧义，以单词 &lt;code&gt;&quot;NOT&quot;&lt;/code&gt; 开头。</target>
        </trans-unit>
        <trans-unit id="e8f8cf45418f21110ef02ba18a8fe7b0e0a35cfe" translate="yes" xml:space="preserve">
          <source>For compatibility with perl scripts written for the Unix environment, Plan 9 Perl uses the POSIX signal emulation provided in Plan 9's ANSI POSIX Environment (APE). Signal stacking isn't supported. The signals provided are:</source>
          <target state="translated">为了与为Unix环境编写的perl脚本兼容,Plan 9 Perl使用Plan 9的ANSI POSIX环境(APE)中提供的POSIX信号仿真。不支持信号堆叠。提供的信号有:</target>
        </trans-unit>
        <trans-unit id="f7ddc7130612083ca6f3d06a09409b25b9346875" translate="yes" xml:space="preserve">
          <source>For compatibility with popular C library functions, Perl implementations of the mkstemp() family of functions are provided. These are, mkstemp(), mkstemps(), mkdtemp() and mktemp().</source>
          <target state="translated">为了与流行的 C 库函数兼容,Perl 提供了 mkstemp()系列函数的实现,它们是:mkstemp()、mkstemps()、mkdtemp()和 mktemp()。这些函数是:mkstemp()、mkstemps()、mkdtemp()和mktemp()。</target>
        </trans-unit>
        <trans-unit id="d25b76835899d4044aad201d72be6ea01f31876a" translate="yes" xml:space="preserve">
          <source>For compatibility with the old B::Terse, this module also adds a method named &lt;code&gt;terse&lt;/code&gt; to B::OP and B::SV objects. The B::SV method is largely compatible with the old one, though authors of new software might be advised to choose a more user-friendly output format. The B::OP &lt;code&gt;terse&lt;/code&gt; method, however, doesn't work well. Since B::Terse was first written, much more information in OPs has migrated to the scratchpad datastructure, but the &lt;code&gt;terse&lt;/code&gt; interface doesn't have any way of getting to the correct pad. As a kludge, the new version will always use the pad for the main program, but for OPs in subroutines this will give the wrong answer or crash.</source>
          <target state="translated">为了与旧的B :: Terse兼容，该模块还向B :: OP和B :: SV对象添加了一个名为 &lt;code&gt;terse&lt;/code&gt; 的方法。 B :: SV方法在很大程度上与旧方法兼容，尽管可能会建议新软件的作者选择一种更加用户友好的输出格式。但是，B :: OP &lt;code&gt;terse&lt;/code&gt; 方法效果不佳。自从B :: Terse首次编写以来，OP中的更多信息已迁移到暂存器数据结构，但 &lt;code&gt;terse&lt;/code&gt; 界面无法获取正确的填充物。令人费解的是，新版本将始终在主程序中使用键盘，但对于子例程中的OP，这将给出错误的答案或崩溃。</target>
        </trans-unit>
        <trans-unit id="67ec1b88f948f8864ab885d448e428104a1f5cbb" translate="yes" xml:space="preserve">
          <source>For compiling, you need following:</source>
          <target state="translated">编译时,你需要以下内容。</target>
        </trans-unit>
        <trans-unit id="2c3582fce0d2ea8e40bba69ca7dfa38ec981ba20" translate="yes" xml:space="preserve">
          <source>For completeness, here is &lt;code&gt;asynch_close&lt;/code&gt; . This shows how to remove the entry from the hash &lt;code&gt;Mapping&lt;/code&gt; .</source>
          <target state="translated">为了完整 &lt;code&gt;asynch_close&lt;/code&gt; ，这里是asynch_close。这显示了如何从哈希 &lt;code&gt;Mapping&lt;/code&gt; 删除条目。</target>
        </trans-unit>
        <trans-unit id="9211f9a6bd70a952eb9e084b22fff2574a69c350" translate="yes" xml:space="preserve">
          <source>For completeness, here is &lt;code&gt;asynch_close&lt;/code&gt;. This shows how to remove the entry from the hash &lt;code&gt;Mapping&lt;/code&gt;.</source>
          <target state="translated">为了完整 &lt;code&gt;asynch_close&lt;/code&gt; ，这里是asynch_close。这显示了如何从哈希 &lt;code&gt;Mapping&lt;/code&gt; 删除条目。</target>
        </trans-unit>
        <trans-unit id="1c043d0855883cdf3536e0246bdff4dcd9fcd74e" translate="yes" xml:space="preserve">
          <source>For consistency with common usage, perl's Configure script performs some minor manipulations on the operating system name and version number as reported by uname. Here's a partial translation table:</source>
          <target state="translated">为了与普通用法保持一致,perl的Configure脚本对uname报告的操作系统名称和版本号进行了一些小的操作。下面是一个部分翻译表。</target>
        </trans-unit>
        <trans-unit id="c929174990d09b02dcdbbabbaa2a02596a638c93" translate="yes" xml:space="preserve">
          <source>For constant subroutines, returns the constant SV returned by the subroutine.</source>
          <target state="translated">对于常量子程序,返回子程序返回的常量SV。</target>
        </trans-unit>
        <trans-unit id="9e387ea14df2d8d86cc5babf9af2677b505e2619" translate="yes" xml:space="preserve">
          <source>For constructs that do interpolate, variables beginning with &quot;&lt;code&gt;$&lt;/code&gt; &quot; or &quot;&lt;code&gt;@&lt;/code&gt; &quot; are interpolated. Subscripted variables such as &lt;code&gt;$a[3]&lt;/code&gt; or &lt;code&gt;$href-&amp;gt;{key}[0]&lt;/code&gt; are also interpolated, as are array and hash slices. But method calls such as &lt;code&gt;$obj-&amp;gt;meth&lt;/code&gt; are not.</source>
          <target state="translated">对于进行插值的构造，将插值以&amp;ldquo; &lt;code&gt;$&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;@&lt;/code&gt; &amp;rdquo; 开头的变量。下标变量（例如 &lt;code&gt;$a[3]&lt;/code&gt; 或 &lt;code&gt;$href-&amp;gt;{key}[0]&lt;/code&gt; 也将被插值，数组和哈希片也将被插值。但是诸如 &lt;code&gt;$obj-&amp;gt;meth&lt;/code&gt; 类的方法调用不是。</target>
        </trans-unit>
        <trans-unit id="d824f17a668c6fb9730318bb144f77718695736e" translate="yes" xml:space="preserve">
          <source>For constructs that do interpolate, variables beginning with &quot;&lt;code&gt;$&lt;/code&gt;&quot; or &quot;&lt;code&gt;@&lt;/code&gt;&quot; are interpolated. Subscripted variables such as &lt;code&gt;$a[3]&lt;/code&gt; or &lt;code&gt;$href-&amp;gt;{key}[0]&lt;/code&gt; are also interpolated, as are array and hash slices. But method calls such as &lt;code&gt;$obj-&amp;gt;meth&lt;/code&gt; are not.</source>
          <target state="translated">对于进行插值的构造，将插值以&amp;ldquo; &lt;code&gt;$&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;@&lt;/code&gt; &amp;rdquo;开头的变量。下标变量（例如 &lt;code&gt;$a[3]&lt;/code&gt; 或 &lt;code&gt;$href-&amp;gt;{key}[0]&lt;/code&gt; 也将被插值，数组和哈希片也将被插值。但是诸如 &lt;code&gt;$obj-&amp;gt;meth&lt;/code&gt; 类的方法调用却不是。</target>
        </trans-unit>
        <trans-unit id="ec376fd19b0ff28e80aef02d1aa6f9c7cab7d82a" translate="yes" xml:space="preserve">
          <source>For constructs with three-part delimiters (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;), the search is repeated once more. If the first delimiter is not an opening punctuation, the three delimiters must be the same, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr)))&lt;/a&gt;&lt;/code&gt;, in which case the second delimiter terminates the left part and starts the right part at once. If the left part is delimited by bracketing punctuation (that is &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; , or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ), the right part needs another pair of delimiters such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s(){}&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[]//&lt;/a&gt;&lt;/code&gt;. In these cases, whitespace and comments are allowed between the two parts, although the comment must follow at least one whitespace character; otherwise a character expected as the start of the comment may be regarded as the starting delimiter of the right part.</source>
          <target state="translated">对于具有三部分定界符（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; ）的构造，将再次重复搜索。如果第一个定界符不是开头标点，则三个定界符必须相同，例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr)))&lt;/a&gt;&lt;/code&gt; ，在这种情况下，第二个定界符终止左部分并立即开始右部分。如果左侧部分用方括号括起来（即 &lt;code&gt;()&lt;/code&gt; ， &lt;code&gt;[]&lt;/code&gt; ， &lt;code&gt;{}&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ），则右侧部分需要另外一对定界符，例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s(){}&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[]//&lt;/a&gt;&lt;/code&gt; 。在这种情况下，尽管注释必须至少跟随一个空格字符，但在这两部分之间允许使用空格和注释。否则，应将预期用作注释开头的字符视为右侧部分的起始定界符。</target>
        </trans-unit>
        <trans-unit id="69f740e18c473e8e61739f44b26934139fa90e6b" translate="yes" xml:space="preserve">
          <source>For constructs with three-part delimiters (&lt;code&gt;s///&lt;/code&gt;, &lt;code&gt;y///&lt;/code&gt;, and &lt;code&gt;tr///&lt;/code&gt;), the search is repeated once more. If the first delimiter is not an opening punctuation, the three delimiters must be the same, such as &lt;code&gt;s!!!&lt;/code&gt; and &lt;code&gt;tr)))&lt;/code&gt;, in which case the second delimiter terminates the left part and starts the right part at once. If the left part is delimited by bracketing punctuation (that is &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;{}&lt;/code&gt;, or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;), the right part needs another pair of delimiters such as &lt;code&gt;s(){}&lt;/code&gt; and &lt;code&gt;tr[]//&lt;/code&gt;. In these cases, whitespace and comments are allowed between the two parts, although the comment must follow at least one whitespace character; otherwise a character expected as the start of the comment may be regarded as the starting delimiter of the right part.</source>
          <target state="translated">对于具有三部分定界符（ &lt;code&gt;s///&lt;/code&gt; ， &lt;code&gt;y///&lt;/code&gt; 和 &lt;code&gt;tr///&lt;/code&gt; ）的构造，将再次重复搜索。如果第一个定界符不是开头标点，则三个定界符必须相同，例如 &lt;code&gt;s!!!&lt;/code&gt; 和 &lt;code&gt;tr)))&lt;/code&gt; ，在这种情况下，第二个定界符终止左部分并立即开始右部分。如果左侧部分由方括号括起来（即 &lt;code&gt;()&lt;/code&gt; ， &lt;code&gt;[]&lt;/code&gt; ， &lt;code&gt;{}&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ），则右侧部分需要另外一对定界符，例如 &lt;code&gt;s(){}&lt;/code&gt; 和 &lt;code&gt;tr[]//&lt;/code&gt; 。在这些情况下，尽管注释必须至少跟随一个空格字符，但在这两部分之间允许使用空格和注释。否则，应将预期用作注释开头的字符视为右侧部分的起始定界符。</target>
        </trans-unit>
        <trans-unit id="343bf25e2927a4e247fde284894e20f4a2092df4" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;GLOB_CSH&lt;/code&gt; is a synonym for &lt;code&gt;GLOB_BRACE | GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT&lt;/code&gt; .</source>
          <target state="translated">为了方便起见， &lt;code&gt;GLOB_CSH&lt;/code&gt; 是 &lt;code&gt;GLOB_BRACE | GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT&lt;/code&gt; 的同义词。GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT。</target>
        </trans-unit>
        <trans-unit id="7db168533be63e476cbf03e4ddcd8399688a0c04" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;GLOB_CSH&lt;/code&gt; is a synonym for &lt;code&gt;GLOB_BRACE | GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT&lt;/code&gt;.</source>
          <target state="translated">为了方便起见， &lt;code&gt;GLOB_CSH&lt;/code&gt; 是 &lt;code&gt;GLOB_BRACE | GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT&lt;/code&gt; 的同义词。GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT。</target>
        </trans-unit>
        <trans-unit id="40732251f5c21be8c597889848a82040a77a373e" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;IO::File&lt;/code&gt; exports the O_XXX constants from the Fcntl module, if this module is available.</source>
          <target state="translated">为方便起见，如果该模块可用，则 &lt;code&gt;IO::File&lt;/code&gt; 从Fcntl模块中导出O_XXX常量。</target>
        </trans-unit>
        <trans-unit id="38a10ffe4a20ca5792a7fd00b9c73d9ce59a1dd3" translate="yes" xml:space="preserve">
          <source>For convenience, Perl sets &lt;code&gt;$+&lt;/code&gt; to the string held by the highest numbered &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... that got assigned (and, somewhat related, &lt;code&gt;$^N&lt;/code&gt; to the value of the &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... most-recently assigned; i.e. the &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... associated with the rightmost closing parenthesis used in the match).</source>
          <target state="translated">为方便起见，Perl将 &lt;code&gt;$+&lt;/code&gt; 设置为分配给编号最高的 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ，... 持有的字符串（并且有些相关， &lt;code&gt;$^N&lt;/code&gt; 设置为 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ，...的最近分配值） ；即 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; &amp;hellip;与匹配中使用的最右边的右括号相关联）。</target>
        </trans-unit>
        <trans-unit id="9011b98b95f15cd4a087ddfce8ee15dfdd0721aa" translate="yes" xml:space="preserve">
          <source>For convenience, Perl sets &lt;code&gt;$+&lt;/code&gt; to the string held by the highest numbered &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;,... that got assigned (and, somewhat related, &lt;code&gt;$^N&lt;/code&gt; to the value of the &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;,... most-recently assigned;</source>
          <target state="translated">为方便起见，Perl将 &lt;code&gt;$+&lt;/code&gt; 设置为分配给编号最高的 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ，...持有的字符串（并且有些相关， &lt;code&gt;$^N&lt;/code&gt; 设置为最近分配的 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ，...的值）;</target>
        </trans-unit>
        <trans-unit id="fb5611347ffd15c1223ef802d0edf52fb7e73b41" translate="yes" xml:space="preserve">
          <source>For convenience, during a &lt;code&gt;'code...'&lt;/code&gt; filtering operation, Filter::Simple provides a package variable (&lt;code&gt;$Filter::Simple::placeholder&lt;/code&gt; ) that contains a pre-compiled regex that matches any placeholder...and captures the identifier within the placeholder. Placeholders can be moved and re-ordered within the source code as needed.</source>
          <target state="translated">为了方便起见，在 &lt;code&gt;'code...'&lt;/code&gt; 过滤操作期间，Filter :: Simple提供了一个程序包变量（ &lt;code&gt;$Filter::Simple::placeholder&lt;/code&gt; ），该变量包含与任何占位符匹配的预编译正则表达式...并捕获标识符在占位符内。占位符可以根据需要在源代码中移动和重新排序。</target>
        </trans-unit>
        <trans-unit id="0a977f7d9164e482b657b3b8fb97633309d91ddb" translate="yes" xml:space="preserve">
          <source>For convenience, during a &lt;code&gt;'code...'&lt;/code&gt; filtering operation, Filter::Simple provides a package variable (&lt;code&gt;$Filter::Simple::placeholder&lt;/code&gt;) that contains a pre-compiled regex that matches any placeholder...and captures the identifier within the placeholder. Placeholders can be moved and re-ordered within the source code as needed.</source>
          <target state="translated">为了方便起见，在 &lt;code&gt;'code...'&lt;/code&gt; 过滤操作期间，Filter :: Simple提供了一个包变量（ &lt;code&gt;$Filter::Simple::placeholder&lt;/code&gt; ），该变量包含与任何占位符匹配的预编译正则表达式...并捕获标识符在占位符内。占位符可以根据需要在源代码中移动和重新排序。</target>
        </trans-unit>
        <trans-unit id="a034c7b9883166db2c708f0dc5f543d0d6c5f5c5" translate="yes" xml:space="preserve">
          <source>For conversion of code points potentially larger than will fit in a character, use &lt;a href=&quot;#NATIVE_TO_UNI&quot;&gt;&quot;NATIVE_TO_UNI&quot;&lt;/a&gt;.</source>
          <target state="translated">要转换可能比字符大的代码点，请使用&lt;a href=&quot;#NATIVE_TO_UNI&quot;&gt;&amp;ldquo; NATIVE_TO_UNI&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ab53246447ba99db18af65b753a1b02f0b27488" translate="yes" xml:space="preserve">
          <source>For conversion of code points potentially larger than will fit in a character, use &lt;a href=&quot;#UNI_TO_NATIVE&quot;&gt;&quot;UNI_TO_NATIVE&quot;&lt;/a&gt;.</source>
          <target state="translated">要转换可能比字符大的代码点，请使用&lt;a href=&quot;#UNI_TO_NATIVE&quot;&gt;&amp;ldquo; UNI_TO_NATIVE&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc4adefa4b79abf45088dcb0ac2e06a348c35319" translate="yes" xml:space="preserve">
          <source>For conversion we have &lt;code&gt;Cygwin::win_to_posix_path()&lt;/code&gt; and &lt;code&gt;Cygwin::posix_to_win_path()&lt;/code&gt; .</source>
          <target state="translated">为了进行转换，我们有 &lt;code&gt;Cygwin::win_to_posix_path()&lt;/code&gt; 和 &lt;code&gt;Cygwin::posix_to_win_path()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5d0e531ca755bbadc32f76a7bbbf87909f5f1d0" translate="yes" xml:space="preserve">
          <source>For conversion we have &lt;code&gt;Cygwin::win_to_posix_path()&lt;/code&gt; and &lt;code&gt;Cygwin::posix_to_win_path()&lt;/code&gt;.</source>
          <target state="translated">为了进行转换，我们有 &lt;code&gt;Cygwin::win_to_posix_path()&lt;/code&gt; 和 &lt;code&gt;Cygwin::posix_to_win_path()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d928fe0051212f2f8da39a8b5bc221435184fd0" translate="yes" xml:space="preserve">
          <source>For copyright</source>
          <target state="translated">关于版权</target>
        </trans-unit>
        <trans-unit id="1a0a72b7c53bc47eff73c9a1bbea76977d805414" translate="yes" xml:space="preserve">
          <source>For correct handling of East Asian half- and full-width characters, see &lt;a href=&quot;Text::WrapI18N&quot;&gt;Text::WrapI18N&lt;/a&gt;. For more detailed controls: &lt;a href=&quot;Text::Format&quot;&gt;Text::Format&lt;/a&gt;.</source>
          <target state="translated">有关正确处理东亚半角和全角字符的信息，请参见&lt;a href=&quot;Text::WrapI18N&quot;&gt;Text :: WrapI18N&lt;/a&gt;。有关更详细的控件，请执行以下操作：&lt;a href=&quot;Text::Format&quot;&gt;Text :: Format&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1eecebe67970e7a41398f09174a7fb5bf129f3a9" translate="yes" xml:space="preserve">
          <source>For correct handling of East Asian half- and full-width characters, see &lt;a href=&quot;http://search.cpan.org/perldoc/Text::WrapI18N&quot;&gt;Text::WrapI18N&lt;/a&gt;. For more detailed controls: &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Format&quot;&gt;Text::Format&lt;/a&gt;.</source>
          <target state="translated">有关正确处理东亚半角和全角字符的信息，请参见&lt;a href=&quot;http://search.cpan.org/perldoc/Text::WrapI18N&quot;&gt;Text :: WrapI18N&lt;/a&gt;。有关更详细的控件：&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Format&quot;&gt;Text :: Format&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e192d740cc4683287225288711c73e147509978a" translate="yes" xml:space="preserve">
          <source>For custom ops the type is returned from the registration, and it is up to the registree to ensure it is accurate. The value returned will be one of the &lt;code&gt;OA_&lt;/code&gt;* constants from</source>
          <target state="translated">对于自定义操作，类型是从注册中返回的，它取决于registree以确保其准确性。返回的值将是 &lt;code&gt;OA_&lt;/code&gt; *常量之一</target>
        </trans-unit>
        <trans-unit id="5605d690fc41e9584f8f39d50fb58f9b59b16327" translate="yes" xml:space="preserve">
          <source>For date and time processing look at the many related modules on CPAN. For a comprehensive date and time representation look at the &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; module.</source>
          <target state="translated">对于日期和时间处理，请查看CPAN上的许多相关模块。要获得全面的日期和时间表示，请查看&lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="b6f77b308a2ac839fd33563f9a552da3eeb4daa9" translate="yes" xml:space="preserve">
          <source>For date and time processing look at the many related modules on CPAN. For a comprehensive date and time representation look at the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module.</source>
          <target state="translated">对于日期和时间处理，请查看CPAN上的许多相关模块。要获得全面的日期和时间表示，请查看&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="07b6da6b04aa2922da90bdf4ba16ff504d7726a7" translate="yes" xml:space="preserve">
          <source>For debugging of CPAN data there is the &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; command which takes the same arguments as make/test/install and outputs each object's Data::Dumper dump. If an argument looks like a perl variable and contains one of &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; , it is eval()ed and fed to Data::Dumper directly.</source>
          <target state="translated">为了调试CPAN数据，有一个 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 命令，该命令采用与make / test / install相同的参数，并输出每个对象的Data :: Dumper dump。如果参数看起来像perl变量并且包含 &lt;code&gt;$&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; 之一，则将对它进行eval（）并直接将其提供给Data :: Dumper。</target>
        </trans-unit>
        <trans-unit id="8a807f2c9fb85faf8c9ac5d861d440bcf8bfce3c" translate="yes" xml:space="preserve">
          <source>For debugging the code of CPAN.pm itself in interactive mode, some debugging aid can be turned on for most packages within CPAN.pm with one of</source>
          <target state="translated">对于在交互模式下调试CPAN.pm本身的代码,可以为CPAN.pm中的大多数包开启一些调试辅助功能,并使用以下其中一种方式实现</target>
        </trans-unit>
        <trans-unit id="dc61b5871895f28ad48638872dd4fd8cf1a53e5e" translate="yes" xml:space="preserve">
          <source>For decimal versions, an integer portion (no leading 0), a decimal point, and one or more digits to the right of the decimal are all required.</source>
          <target state="translated">对于十进制版本,整数部分(无前导0)、小数点和小数点右边的一个或多个数字都是必需的。</target>
        </trans-unit>
        <trans-unit id="012acad439f571a1fc425f25a48809ae662859e2" translate="yes" xml:space="preserve">
          <source>For decimal versions:</source>
          <target state="translated">对于十进制版本:</target>
        </trans-unit>
        <trans-unit id="e18adf48baa2e5602e7386e7898a8696aea38703" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides &lt;a href=&quot;Time::HiRes#ualarm-%28-%24useconds-%5B%2C-%24interval_useconds-%5D-%29&quot;&gt;&lt;code&gt;ualarm&lt;/code&gt;&lt;/a&gt;. You may also use Perl's four-argument version of &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; leaving the first three arguments undefined, or you might be able to use the &lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt;&lt;code&gt;syscall&lt;/code&gt;&lt;/a&gt; interface to access &lt;a href=&quot;http://man.he.net/man2/setitimer&quot;&gt;setitimer(2)&lt;/a&gt; if your system supports it. See &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">对于比一秒更细粒度的延迟，&lt;a href=&quot;Time::HiRes&quot;&gt;Time :: HiRes&lt;/a&gt;模块（来自CPAN，从标准分发的Perl 5.8部分开始）提供&lt;a href=&quot;Time::HiRes#ualarm-%28-%24useconds-%5B%2C-%24interval_useconds-%5D-%29&quot;&gt; &lt;code&gt;ualarm&lt;/code&gt; &lt;/a&gt;。您也可以使用Perl的四参数版本的&lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt; &lt;code&gt;select&lt;/code&gt; ,&lt;/a&gt;而未定义前三个参数，或者，如果系统支持，则可以使用&lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt; &lt;code&gt;syscall&lt;/code&gt; &lt;/a&gt;接口访问&lt;a href=&quot;http://man.he.net/man2/setitimer&quot;&gt;setitimer（2）&lt;/a&gt;。有关详细信息，请参见&lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2375819172a576f1b09ffc97251059479964eff9" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides &lt;a href=&quot;Time::HiRes#usleep-%28-%24useconds-%29&quot;&gt;&lt;code&gt;usleep&lt;/code&gt;&lt;/a&gt;. You may also use Perl's four-argument version of &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; leaving the first three arguments undefined, or you might be able to use the &lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt;&lt;code&gt;syscall&lt;/code&gt;&lt;/a&gt; interface to access &lt;a href=&quot;http://man.he.net/man2/setitimer&quot;&gt;setitimer(2)&lt;/a&gt; if your system supports it. See &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">为了延迟比一秒更好的粒度，&lt;a href=&quot;Time::HiRes&quot;&gt;Time :: HiRes&lt;/a&gt;模块（来自CPAN，从标准分发的Perl 5.8部分开始）提供&lt;a href=&quot;Time::HiRes#usleep-%28-%24useconds-%29&quot;&gt; &lt;code&gt;usleep&lt;/code&gt; &lt;/a&gt;。您也可以使用Perl的四参数版本的&lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt; &lt;code&gt;select&lt;/code&gt; ,&lt;/a&gt;而未定义前三个参数，或者，如果系统支持，则可以使用&lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt; &lt;code&gt;syscall&lt;/code&gt; &lt;/a&gt;接口访问&lt;a href=&quot;http://man.he.net/man2/setitimer&quot;&gt;setitimer（2）&lt;/a&gt;。有关详细信息，请参见&lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb5d5a55a6b1cad338bb173db36952043185ac23" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides ualarm(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">对于比一秒更细粒度的延迟，Time :: HiRes模块（来自CPAN，从标准分发的Perl 5.8部分开始）提供ualarm（）。您也可以使用Perl的select（）的四个参数版本，而未定义前三个参数，或者，如果系统支持，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 接口访问setitimer（2）。有关详细信息，请参见&lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd003af05b2132ba4b881a232af5e4cee8933eae" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides ualarm(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">对于比一秒更细粒度的延迟，Time :: HiRes模块（来自CPAN，从标准分发的Perl 5.8部分开始）提供ualarm（）。您也可以使用Perl的select（）的四个参数版本，而未定义前三个参数，或者，如果系统支持，则可以使用 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 接口访问setitimer（2）。有关详细信息，请参见&lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="048bc05974c11cb3f14983d6e8a4de95a334014e" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides usleep(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">对于比一秒更精细的延迟，Time :: HiRes模块（来自CPAN，从标准分发的Perl 5.8部分开始）提供usleep（）。您也可以使用Perl的select（）的四个参数版本，而未定义前三个参数，或者，如果系统支持，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 接口访问setitimer（2）。有关详细信息，请参见&lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d999a8a7adf00f409cdbfb2fc0969a34ea071e33" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides usleep(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">对于比一秒更精细的延迟，Time :: HiRes模块（来自CPAN，从标准分发的Perl 5.8部分开始）提供usleep（）。您也可以使用Perl的select（）的四个参数版本，而未定义前三个参数，或者，如果系统支持，则可以使用 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 接口访问setitimer（2）。有关详细信息，请参见&lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="880c0e9f515e34271c2c3b119d8f343dab33b21c" translate="yes" xml:space="preserve">
          <source>For dependencies that are required in order to run &lt;code&gt;Makefile.PL&lt;/code&gt; , see &lt;code&gt;CONFIGURE_REQUIRES&lt;/code&gt; .</source>
          <target state="translated">有关运行 &lt;code&gt;Makefile.PL&lt;/code&gt; 所需的依赖关系，请参见 &lt;code&gt;CONFIGURE_REQUIRES&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56efd43ff2633084d0c4fb894544829d1847b596" translate="yes" xml:space="preserve">
          <source>For dependencies that are required in order to run &lt;code&gt;Makefile.PL&lt;/code&gt;, see &lt;code&gt;CONFIGURE_REQUIRES&lt;/code&gt;.</source>
          <target state="translated">有关运行 &lt;code&gt;Makefile.PL&lt;/code&gt; 所需的依赖关系，请参见 &lt;code&gt;CONFIGURE_REQUIRES&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25b652017d6aba87f803b1349ff4840587bb26a8" translate="yes" xml:space="preserve">
          <source>For descriptions of the class hierarchy of these objects and the methods that can be called on them, see below, &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;&quot;OVERVIEW OF CLASSES&quot;&lt;/a&gt; and &lt;a href=&quot;#OP-RELATED-CLASSES&quot;&gt;&quot;OP-RELATED CLASSES&quot;&lt;/a&gt;.</source>
          <target state="translated">有关这些对象的类层次结构以及可以在其上调用的方法的描述，请参见下文&lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;&amp;ldquo;类概述&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;#OP-RELATED-CLASSES&quot;&gt;&amp;ldquo; OP相关类&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a1506155c00ca0b29e754a84c95c6d4d84c08eb" translate="yes" xml:space="preserve">
          <source>For descriptions of the class hierarchy of these objects and the methods that can be called on them, see below, &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;&quot;OVERVIEW OF CLASSES&quot;&lt;/a&gt; and &lt;a href=&quot;#SV-RELATED-CLASSES&quot;&gt;&quot;SV-RELATED CLASSES&quot;&lt;/a&gt;.</source>
          <target state="translated">有关这些对象的类层次结构以及可以在其上调用的方法的描述，请参见下面的&lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;&amp;ldquo;类概述&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;#SV-RELATED-CLASSES&quot;&gt;&amp;ldquo; SV相关类&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33634f235f0082e4181888900b85711db47d8f18" translate="yes" xml:space="preserve">
          <source>For descriptions of the class hierarchy of these objects and the methods that can be called on them, see below, &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;OVERVIEW OF CLASSES&lt;/a&gt; and &lt;a href=&quot;#OP-RELATED-CLASSES&quot;&gt;OP-RELATED CLASSES&lt;/a&gt;.</source>
          <target state="translated">有关这些对象的类层次结构以及可以在其上调用的方法的描述，请参见下文&amp;ldquo;类&lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;概述&amp;rdquo;&lt;/a&gt;和&amp;ldquo;与&lt;a href=&quot;#OP-RELATED-CLASSES&quot;&gt;OP相关的类&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3b2ae9d73ddeeda58bc4e13e54cb8a6fed8f14d" translate="yes" xml:space="preserve">
          <source>For descriptions of the class hierarchy of these objects and the methods that can be called on them, see below, &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;OVERVIEW OF CLASSES&lt;/a&gt; and &lt;a href=&quot;#SV-RELATED-CLASSES&quot;&gt;SV-RELATED CLASSES&lt;/a&gt;.</source>
          <target state="translated">有关这些对象的类层次结构以及可以在其上调用的方法的描述，请参见下面的&amp;ldquo;类&lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;概述&amp;rdquo;&lt;/a&gt;和&amp;ldquo; &lt;a href=&quot;#SV-RELATED-CLASSES&quot;&gt;SV相关类&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ec22c5e89b166831180c8fd7d61e1db96cf2000" translate="yes" xml:space="preserve">
          <source>For deserialisation there are only two cases to consider: either nonstandard tagging was used, in which case &lt;code&gt;allow_tags&lt;/code&gt; decides, or objects cannot be automatically be deserialised, in which case you can use postprocessing or the &lt;code&gt;filter_json_object&lt;/code&gt; or &lt;code&gt;filter_json_single_key_object&lt;/code&gt; callbacks to get some real objects our of your JSON.</source>
          <target state="translated">对于反序列化，只有两种情况需要考虑：使用非标准标记（在这种情况下 &lt;code&gt;allow_tags&lt;/code&gt; 决定），或者无法自动反序列化对象，在这种情况下，您可以使用后处理或 &lt;code&gt;filter_json_object&lt;/code&gt; 或 &lt;code&gt;filter_json_single_key_object&lt;/code&gt; 回调来获取我们的某些真实对象您的JSON。</target>
        </trans-unit>
        <trans-unit id="ae8371a2b6a91f80da291b64adb024dd9ea39e6b" translate="yes" xml:space="preserve">
          <source>For details on typemaps: &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">有关类型&lt;a href=&quot;perlxstut&quot;&gt;映射的&lt;/a&gt;详细信息：perlxstut，&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="826700f3b65927540e360eda58122d1f12e92b58" translate="yes" xml:space="preserve">
          <source>For details, please see &lt;code&gt;Unicode mapping issues and notes:&lt;/code&gt; at &lt;a href=&quot;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/DEVANAGA.TXT&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/DEVANAGA.TXT&lt;/a&gt; .</source>
          <target state="translated">有关详细信息，请参阅 &lt;code&gt;Unicode mapping issues and notes:&lt;/code&gt; 在&lt;a href=&quot;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/DEVANAGA.TXT&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/DEVANAGA.TXT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dfd7e01e8ce19ce8f63863a1d7ecd9db34986ac0" translate="yes" xml:space="preserve">
          <source>For details, please see &lt;code&gt;Unicode mapping issues and notes:&lt;/code&gt; at &lt;a href=&quot;https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/DEVANAGA.TXT&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/DEVANAGA.TXT&lt;/a&gt; .</source>
          <target state="translated">有关详细信息，请参阅 &lt;code&gt;Unicode mapping issues and notes:&lt;/code&gt; 在&lt;a href=&quot;https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/DEVANAGA.TXT&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/DEVANAGA.TXT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6890c04c351eed8402cc96040025e018355d7713" translate="yes" xml:space="preserve">
          <source>For details, see &lt;code&gt;perldoc ppport.h&lt;/code&gt; .</source>
          <target state="translated">有关详细信息，请参见 &lt;code&gt;perldoc ppport.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98a64169dc734a8fe4119fbf2902257cf31763af" translate="yes" xml:space="preserve">
          <source>For details, see &lt;code&gt;perldoc ppport.h&lt;/code&gt;.</source>
          <target state="translated">有关详细信息，请参见 &lt;code&gt;perldoc ppport.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4be1d326997ed9e19e7a04e776dc614ee400c4f2" translate="yes" xml:space="preserve">
          <source>For details, see the description for &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;.</source>
          <target state="translated">有关详细信息，请参见&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;的描述。</target>
        </trans-unit>
        <trans-unit id="2da6125e37beb908e4b87a83be8efad53c88ed6a" translate="yes" xml:space="preserve">
          <source>For details, see the description for &lt;a href=&quot;perlapi#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">有关详细信息，请参见&lt;a href=&quot;perlapi#uvchr_to_utf8_flags&quot;&gt;perlapi中&lt;/a&gt;有关&amp;ldquo; uvchr_to_utf8_flags&amp;rdquo;的描述。</target>
        </trans-unit>
        <trans-unit id="fe4cabeb3c36ea2c5a3fbd884ca6fe8ba5049b92" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied arrays, the required methods are briefly defined below. See the &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section for more detailed descriptive, as well as example code:</source>
          <target state="translated">对于希望编写自己的绑定数组的开发人员，下面简要定义了所需的方法。请参阅&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;部分以获取更详细的描述以及示例代码：</target>
        </trans-unit>
        <trans-unit id="8316eda6036e10f32d157be6bef162675363fcbc" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied arrays, the required methods are briefly defined below. See the &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section for more detailed descriptive, as well as example code:</source>
          <target state="translated">对于希望编写自己的绑定数组的开发人员，下面简要定义了所需的方法。请参阅&lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;部分以获取更详细的描述以及示例代码：</target>
        </trans-unit>
        <trans-unit id="d33242068f9073573772617185fa7b62c43ab672" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied hashes, the required methods are briefly defined below. See the &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section for more detailed descriptive, as well as example code:</source>
          <target state="translated">对于希望编写自己的哈希表的开发人员，下面简要定义了所需的方法。请参阅&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;部分以获取更详细的描述以及示例代码：</target>
        </trans-unit>
        <trans-unit id="53d3c2e123f9e22a4cc720388ad65b46d722f606" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied hashes, the required methods are briefly defined below. See the &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section for more detailed descriptive, as well as example code:</source>
          <target state="translated">对于希望编写自己的哈希表的开发人员，下面简要定义了所需的方法。请参阅&lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;部分以获取更详细的描述以及示例代码：</target>
        </trans-unit>
        <trans-unit id="c6d44567c847615da73e4dc3fbe1131bc5a3e2c2" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied-handle classes, the methods are summarized below. The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section not only documents these, but has sample code as well:</source>
          <target state="translated">对于希望编写自己的绑定句柄类的开发人员，下面总结了这些方法。该&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;节不仅记录了这些，但示例代码，以及：</target>
        </trans-unit>
        <trans-unit id="cfab23da22f4cecd199b96340524fcbe57be2da2" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied-handle classes, the methods are summarized below. The &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section not only documents these, but has sample code as well:</source>
          <target state="translated">对于希望编写自己的绑定句柄类的开发人员，下面总结了这些方法。该&lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;节不仅记录了这些，但示例代码，以及：</target>
        </trans-unit>
        <trans-unit id="928786a6337e41cc2160d3e1f5e15f742b97fa65" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied-scalar classes, the methods are summarized below. The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section not only documents these, but has sample code as well:</source>
          <target state="translated">对于希望编写自己的绑定标量类的开发人员，下面总结了这些方法。该&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;节不仅记录了这些，但示例代码，以及：</target>
        </trans-unit>
        <trans-unit id="44a8d6f6fe6dd4abebf057c19fabf3ddbd2841d0" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied-scalar classes, the methods are summarized below. The &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section not only documents these, but has sample code as well:</source>
          <target state="translated">对于希望编写自己的绑定标量类的开发人员，下面总结了这些方法。该&lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;节不仅记录了这些，但示例代码，以及：</target>
        </trans-unit>
        <trans-unit id="0cff3dbfb52c9f4d663ef8f25c758142a479cc70" translate="yes" xml:space="preserve">
          <source>For direct examination of the buffer, the variable &lt;a href=&quot;#PL_parser-%3Ebufend&quot;&gt;&quot;PL_parser-&amp;gt;bufend&quot;&lt;/a&gt; points to the end of the buffer. The current lexing position is pointed to by &lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt;bufptr&quot;&lt;/a&gt;. Direct use of these pointers is usually preferable to examination of the scalar through normal scalar means.</source>
          <target state="translated">为了直接检查缓冲区，变量&lt;a href=&quot;#PL_parser-%3Ebufend&quot;&gt;&amp;ldquo; PL_parser-&amp;gt; bufend&amp;rdquo;&lt;/a&gt;指向缓冲区的末尾。当前词法位置由&lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&amp;ldquo; PL_parser-&amp;gt; bufptr&amp;rdquo;&lt;/a&gt;指向。通常，直接使用这些指针比通过常规标量方法检查标量更可取。</target>
        </trans-unit>
        <trans-unit id="83e90c795a8afb6a6c9de6553439d8f6cbbf665f" translate="yes" xml:space="preserve">
          <source>For direct examination of the buffer, the variable &lt;a href=&quot;#PL_parser-%3ebufend&quot;&gt;PL_parser-&amp;gt;bufend&lt;/a&gt; points to the end of the buffer. The current lexing position is pointed to by &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt;. Direct use of these pointers is usually preferable to examination of the scalar through normal scalar means.</source>
          <target state="translated">为了直接检查缓冲区，变量&lt;a href=&quot;#PL_parser-%3ebufend&quot;&gt;PL_parser-&amp;gt; bufend&lt;/a&gt;指向缓冲区的末尾。当前词法位置由&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt;指向。通常，直接使用这些指针比通过常规标量方法检查标量更可取。</target>
        </trans-unit>
        <trans-unit id="13c49c22472e027f068753f3e29a491152b0010b" translate="yes" xml:space="preserve">
          <source>For distributions that use</source>
          <target state="translated">对于使用</target>
        </trans-unit>
        <trans-unit id="985017370413b179ae3946fe35f99a058dfef566" translate="yes" xml:space="preserve">
          <source>For doing I/O it is suggested that you use the autotranslating features of PerlIO, see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">为了执行I / O，建议您使用PerlIO的自动翻译功能，请参见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6c6fdf9044dc1cd6c013956178bb36e51e123a3" translate="yes" xml:space="preserve">
          <source>For dotted decimals:</source>
          <target state="translated">对于点小数。</target>
        </trans-unit>
        <trans-unit id="f34dd79d1671e29d1a48a8679e05577208a886df" translate="yes" xml:space="preserve">
          <source>For dotted-decimal versions, a leading 'v' is required, with three or more sub-versions of no more than three digits. A leading 0 (zero) before the first sub-version (in the above example, '1') is also prohibited.</source>
          <target state="translated">对于点阵十进制版本,需要有一个前导的'v',三个或三个以上的子版本不超过三位数。在第一个子版本(在上面的例子中,'1')前也禁止使用前导的0(0)。</target>
        </trans-unit>
        <trans-unit id="ce51f0686aa7fd04915057c8a38b4ba2a606bb7b" translate="yes" xml:space="preserve">
          <source>For double-quoted strings, the quoting from &lt;code&gt;\Q&lt;/code&gt; is applied after interpolation and escapes are processed.</source>
          <target state="translated">对于双引号字符串，插值后将应用 &lt;code&gt;\Q&lt;/code&gt; 的引号并处理转义符。</target>
        </trans-unit>
        <trans-unit id="812614d64656fd03480d177dcb159cfedfd0b074" translate="yes" xml:space="preserve">
          <source>For dynamic extensions at build/link time</source>
          <target state="translated">对于建立/链接时的动态扩展</target>
        </trans-unit>
        <trans-unit id="c0153ffdb0839d7060eac410231aabcc8768cf39" translate="yes" xml:space="preserve">
          <source>For dynamic extensions at load time</source>
          <target state="translated">对于加载时的动态扩展</target>
        </trans-unit>
        <trans-unit id="7153807fff58e3cc6dcc7b6391711735f5c48fc7" translate="yes" xml:space="preserve">
          <source>For each component, we mention environment variables related to each installation directory. Either choose directories to match your values of the variables, or create/append-to variables to take into account the directories.</source>
          <target state="translated">对于每个组件,我们都会提到与每个安装目录相关的环境变量。你可以选择与你的变量值相匹配的目录,或者创建/附加到变量以考虑到这些目录。</target>
        </trans-unit>
        <trans-unit id="de6d45e2b8e4280d7556487f705375ab5958c2c9" translate="yes" xml:space="preserve">
          <source>For each currently defined drive letter, a &lt;code&gt;'\0'&lt;/code&gt;-terminated string of the path to the root of its file system is constructed. All of these strings are concatenated into a single larger string and an extra terminating &lt;code&gt;'\0'&lt;/code&gt; is added. This larger string is returned in &lt;code&gt;$osBuffer&lt;/code&gt;. Note that this includes drive letters that have been defined but that have no file system, such as drive letters assigned to unformatted partitions.</source>
          <target state="translated">对于每个当前定义的驱动器号，将构建一个以 &lt;code&gt;'\0'&lt;/code&gt; 结尾的文件系统根目录路径。所有这些字符串都串联成一个较大的字符串，并添加了一个额外的终止符 &lt;code&gt;'\0'&lt;/code&gt; 。这个较大的字符串在 &lt;code&gt;$osBuffer&lt;/code&gt; 返回。请注意，这包括已定义但没有文件系统的驱动器号，例如分配给未格式化分区的驱动器号。</target>
        </trans-unit>
        <trans-unit id="1f8371507ff701446b1827e00e5e462be60a5389" translate="yes" xml:space="preserve">
          <source>For each define, this gives a reference to an array of op names that use the flag.</source>
          <target state="translated">对于每个定义,这给出了一个使用标志的操作名数组的引用。</target>
        </trans-unit>
        <trans-unit id="ba4c925cffa4324c85082d132c7153102054ac63" translate="yes" xml:space="preserve">
          <source>For each directory in LIST (called $dir here) the lib module also checks to see if a directory called $dir/$archname/auto exists. If so the $dir/$archname directory is assumed to be a corresponding architecture specific directory and is added to @INC in front of $dir. lib.pm also checks if directories called $dir/$version and $dir/$version/$archname exist and adds these directories to @INC.</source>
          <target state="translated">对于LIST中的每一个目录(这里称为$dir),lib模块也会检查是否存在一个名为$dir/$archname/auto的目录。如果存在,那么$dir/$archname目录就被假定为对应的特定架构目录,并将其添加到@INC中$dir前面。lib.pm还检查是否存在$dir/$version和$dir/$version/$archname目录,并将这些目录添加到@INC中。</target>
        </trans-unit>
        <trans-unit id="d6c50d0e6a86403f83c942ee394e8555abc0ddcd" translate="yes" xml:space="preserve">
          <source>For each directory in LIST (called $dir here) the lib module also checks to see if a directory called $dir/$archname/auto exists. If so the $dir/$archname directory is assumed to be a corresponding architecture specific directory and is also deleted from @INC.</source>
          <target state="translated">对于LIST中的每一个目录(这里称为$dir),lib模块也会检查是否存在一个名为$dir/$archname/auto的目录。如果存在,那么$dir/$archname目录就会被认为是相应的架构专用目录,并且也会从@INC中删除。</target>
        </trans-unit>
        <trans-unit id="9b55b36de0f652d038ba1cdb31f1b3a1791c2037" translate="yes" xml:space="preserve">
          <source>For each directory in LIST (called $dir here) the lib module also checks to see if a directory called $dir/$archname/auto exists. If so the $dir/$archname directory is assumed to be a corresponding architecture specific directory and is also deleted from @INC. lib.pm also checks if directories called $dir/$version and $dir/$version/$archname exist and deletes these directories from @INC.</source>
          <target state="translated">对于LIST中的每一个目录(这里称为$dir),lib模块也会检查是否存在一个名为$dir/$archname/auto的目录。如果存在,那么$dir/$archname目录被认为是一个对应的特定架构的目录,并且也会从@INC中删除。lib.pm也会检查$dir/$version和$dir/$version/$archname目录是否存在,并且从@INC中删除这些目录。</target>
        </trans-unit>
        <trans-unit id="d3b570115f1b3f6cab2450c47d487f4ae062c54b" translate="yes" xml:space="preserve">
          <source>For each instance of amnesty the &lt;code&gt;details&lt;/code&gt; field explains why amnesty was granted.</source>
          <target state="translated">对于大赦的每个实例， &lt;code&gt;details&lt;/code&gt; 字段都说明了为什么批准大赦。</target>
        </trans-unit>
        <trans-unit id="c500f7aea9ecaf66833169bb60bfa93a088a3dfe" translate="yes" xml:space="preserve">
          <source>For each key, an example is provided followed by a description. The description begins with the version of spec in which the key was added or in which the definition was modified, whether the key is</source>
          <target state="translated">对于每个键,都提供了一个例子,然后是一个说明。说明的开头是添加键的规格版本或修改定义的规格版本,键是否是</target>
        </trans-unit>
        <trans-unit id="64daaac0c21c762b1798b346c0a1931a0dd72bc6" translate="yes" xml:space="preserve">
          <source>For each library that is found, an appropriate directive for a linker options file is generated. The return values are space-separated strings of these directives, rather than elements used on the linker command line.</source>
          <target state="translated">对于找到的每个库,都会生成一个适当的链接器选项文件指令。返回值是这些指令的以空格分隔的字符串,而不是链接器命令行中使用的元素。</target>
        </trans-unit>
        <trans-unit id="3313c88e144064867d27f9004bd8e9beaf19e663" translate="yes" xml:space="preserve">
          <source>For each line, the &lt;code&gt;PARSER&lt;/code&gt; loop first tries to match a series of digits followed by a word boundary. This match has to start at the place the last match left off (or the beginning of the string on the first match). Since &lt;code&gt;m/ \G( \d+\b
)/gcx&lt;/code&gt; uses the &lt;code&gt;c&lt;/code&gt; flag, if the string does not match that regular expression, perl does not reset pos() and the next match starts at the same position to try a different pattern.</source>
          <target state="translated">对于每一行， &lt;code&gt;PARSER&lt;/code&gt; 循环首先尝试匹配一系列数字，然后匹配单词边界。这场比赛必须从最后一场比赛（或首场比赛中字符串的开头）开始的地方开始。由于 &lt;code&gt;m/ \G( \d+\b )/gcx&lt;/code&gt; 使用 &lt;code&gt;c&lt;/code&gt; 标志，因此如果字符串与该正则表达式不匹配，则perl不会重置pos（），并且下一个匹配项将从同一位置开始尝试不同的模式。</target>
        </trans-unit>
        <trans-unit id="1e5961cf88fc461e10eaeb188dad6082abb09771" translate="yes" xml:space="preserve">
          <source>For each line, the &lt;code&gt;PARSER&lt;/code&gt; loop first tries to match a series of digits followed by a word boundary. This match has to start at the place the last match left off (or the beginning of the string on the first match). Since &lt;code&gt;m/ \G( \d+\b )/gcx&lt;/code&gt; uses the &lt;code&gt;c&lt;/code&gt; modifier, if the string does not match that regular expression, perl does not reset pos() and the next match starts at the same position to try a different pattern.</source>
          <target state="translated">对于每一行， &lt;code&gt;PARSER&lt;/code&gt; 循环首先尝试匹配一系列数字，然后匹配单词边界。这场比赛必须从最后一场比赛（或首场比赛中字符串的开头）开始的地方开始。由于 &lt;code&gt;m/ \G( \d+\b )/gcx&lt;/code&gt; 使用 &lt;code&gt;c&lt;/code&gt; 修饰符，因此如果字符串与该正则表达式不匹配，则perl不会重置pos（），并且下一个匹配项将从同一位置开始尝试不同的模式。</target>
        </trans-unit>
        <trans-unit id="fd6cfb118370f50c9c42bb5e390e24e86523c86f" translate="yes" xml:space="preserve">
          <source>For each line-style ('concise', 'terse', 'linenoise', etc.) there are 3 format-specs which control how OPs are rendered.</source>
          <target state="translated">对于每一种行式('简洁'、'精练'、'亚麻色'等),有3种格式规格来控制OP的渲染方式。</target>
        </trans-unit>
        <trans-unit id="2ef94716a1f5652ad5d33bb69a0e70bcd8744c37" translate="yes" xml:space="preserve">
          <source>For each of the fields marked &quot;(if any)&quot; the default value on success is an empty string. On failure, all of these values (except the remaining text) are &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于每个标记为&amp;ldquo;（如果有）&amp;rdquo;的字段，成功时的默认值为空字符串。失败时，所有这些值（其余文本除外）均为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="891b5f8726a4abe2a560a861ed1100968e0d0403" translate="yes" xml:space="preserve">
          <source>For each of the fields marked &quot;(if any)&quot; the default value on success is an empty string. On failure, all of these values (except the remaining text) are &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">对于每个标记为&amp;ldquo;（如果有）&amp;rdquo;的字段，成功时的默认值是一个空字符串。失败时，所有这些值（其余文本除外）均为 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fdf0186b6bb5a61b6cf887ce8022d9f1ed87feb" translate="yes" xml:space="preserve">
          <source>For each of these three lists, the collection of signals set to be trapped is checked before trapping; if your architecture does not implement a particular signal, it will not be trapped but rather silently ignored.</source>
          <target state="translated">对于这三个列表中的每一个,在诱捕前都会检查设置要诱捕的信号集合,如果你的架构没有实现某个信号,它将不会被诱捕,而是被默默忽略。</target>
        </trans-unit>
        <trans-unit id="ee92e857afe43bd5c799c71bf04f7d8761b4690e" translate="yes" xml:space="preserve">
          <source>For each such format, &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; generates 4 bits of result. With non-alphabetical characters, the result is based on the 4 least-significant bits of the input character, i.e., on &lt;code&gt;ord($char)%16&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate nybbles 0 and 1, as do bytes &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt;. For characters &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt;, the result is compatible with the usual hexadecimal digits, so that &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;&lt;/code&gt; both generate the nybble &lt;code&gt;0xA==10&lt;/code&gt;. Use only these specific hex characters with this format.</source>
          <target state="translated">对于每种这样的格式，&lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; 都会&lt;/a&gt;生成4位结果。对于非字母字符，结果基于输入字符的4个最低有效位，即基于 &lt;code&gt;ord($char)%16&lt;/code&gt; 。特别是，字符 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 产生小写0和1，字节 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 。对于字符 &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; ，结果与通常的十六进制数字兼容，因此， &lt;code&gt;&quot;a&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 都生成零位 &lt;code&gt;0xA==10&lt;/code&gt; 。只能使用此格式的这些特定十六进制字符。</target>
        </trans-unit>
        <trans-unit id="c00c059a52bac42904c37c4c2fb8927b36fa4f53" translate="yes" xml:space="preserve">
          <source>For each such format, pack() generates 4 bits of result. With non-alphabetical characters, the result is based on the 4 least-significant bits of the input character, i.e., on &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate nybbles 0 and 1, as do bytes &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; . For characters &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; , the result is compatible with the usual hexadecimal digits, so that &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;&lt;/code&gt; both generate the nybble &lt;code&gt;0xA==10&lt;/code&gt; . Use only these specific hex characters with this format.</source>
          <target state="translated">对于每种这样的格式，pack（）都会生成4位结果。对于非字母字符，结果基于输入字符的4个最低有效位，即基于 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt; 。特别是，字符 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 产生小写0和1，字节 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 。对于字符 &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; ，结果与常用的十六进制数字兼容，因此， &lt;code&gt;&quot;a&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 都生成零位 &lt;code&gt;0xA==10&lt;/code&gt; 。只能使用此格式的这些特定十六进制字符。</target>
        </trans-unit>
        <trans-unit id="8b61b8ba63bd2e7b3403785e0beac1c665bb76ab" translate="yes" xml:space="preserve">
          <source>For each such format, pack() generates 4 bits of result. With non-alphabetical characters, the result is based on the 4 least-significant bits of the input character, i.e., on &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate nybbles 0 and 1, as do bytes &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; . For characters &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; , the result is compatible with the usual hexadecimal digits, so that &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;&lt;/code&gt; both generate the nybble &lt;code&gt;0xA==10&lt;/code&gt; . Use only these specific hex characters with this format.</source>
          <target state="translated">对于每种这样的格式，pack（）都会生成4位结果。对于非字母字符，结果基于输入字符的4个最低有效位，即基于 &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt; 。特别是，字符 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 产生小写0和1，字节 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 。对于字符 &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; ，结果与常用的十六进制数字兼容，因此， &lt;code&gt;&quot;a&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 都生成零位 &lt;code&gt;0xA==10&lt;/code&gt; 。只能使用此格式的这些特定十六进制字符。</target>
        </trans-unit>
        <trans-unit id="56bab3e1fc980d5c9adf77a55a7a575a655bbcbb" translate="yes" xml:space="preserve">
          <source>For earlier Perls, a QP encoder that works on both ASCII and EBCDIC platforms would look somewhat like the following:</source>
          <target state="translated">对于早期的Perls来说,一个同时适用于ASCII和EBCDIC平台的QP编码器看起来有点像下面。</target>
        </trans-unit>
        <trans-unit id="d4008829801fc42279d6aea1087db0de93d9c0e6" translate="yes" xml:space="preserve">
          <source>For ease of access, the Perl manual has been split up into several sections.</source>
          <target state="translated">为了方便查阅,Perl手册被分成了几个部分。</target>
        </trans-unit>
        <trans-unit id="2508ccfe05f4a37451a9fb33f66c8f8a0dd451f8" translate="yes" xml:space="preserve">
          <source>For ease of use also the SEEK_* constants (for seek() and sysseek(), e.g. SEEK_END) and the S_I* constants (for chmod() and stat()) are available for import. They can be imported either separately or using the tags &lt;code&gt;:&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;:mode&lt;/code&gt; .</source>
          <target state="translated">为了易于使用，还可以导入SEEK_ *常量（用于seek（）和sysseek（），例如SEEK_END）和S_I *常量（用于chmod（）和stat（））。它们可以单独导入，也可以使用标签 &lt;code&gt;:&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;:mode&lt;/code&gt; 导入。</target>
        </trans-unit>
        <trans-unit id="080c953fd655148a5acb6735a1808c4238e35fff" translate="yes" xml:space="preserve">
          <source>For ease of use also the SEEK_* constants (for seek() and sysseek(), e.g. SEEK_END) and the S_I* constants (for chmod() and stat()) are available for import. They can be imported either separately or using the tags &lt;code&gt;:seek&lt;/code&gt; and &lt;code&gt;:mode&lt;/code&gt;.</source>
          <target state="translated">为了易于使用，还可以导入SEEK_ *常量（用于seek（）和sysseek（），例如SEEK_END）和S_I *常量（用于chmod（）和stat（））。它们可以单独导入，也可以使用标签 &lt;code&gt;:seek&lt;/code&gt; 和 &lt;code&gt;:mode&lt;/code&gt; 导入。</target>
        </trans-unit>
        <trans-unit id="c36f5b62afea33d1be2e3590e8d7005448aa361a" translate="yes" xml:space="preserve">
          <source>For easier debugging, you may prefer to always use the commas when not setting $Term::ANSIColor::AUTORESET or PUSHCOLOR/POPCOLOR so that you'll get a fatal compile error rather than a warning.</source>
          <target state="translated">为了便于调试,当不设置$Term::ANSIColor::AUTORESET或PUSHCOLOR/POPCOLOR时,你可能喜欢总是使用逗号,这样你会得到一个致命的编译错误而不是警告。</target>
        </trans-unit>
        <trans-unit id="98fbe6111f30281308f810d30686560db37e9754" translate="yes" xml:space="preserve">
          <source>For editors: if you're on Unix you probably have vi or a vi clone already, and possibly an emacs too, so you may not need to download anything. In any emacs the cperl-mode (M-x cperl-mode) gives you perhaps the best available Perl editing mode in any editor.</source>
          <target state="translated">对于编辑器:如果你是在Unix上,你可能已经有了vi或vi克隆,也可能有了emacs,所以你可能不需要下载任何东西。在任何 emacs 中,cperl-mode (M-x cperl-mode)给你提供了可能是任何编辑器中最好的可用 Perl 编辑模式。</target>
        </trans-unit>
        <trans-unit id="5aa663054769a993f1d5b54fdeaaf504f9f0a5ea" translate="yes" xml:space="preserve">
          <source>For efficiency reasons, Perl takes a conservative view of whether data is tainted. If an expression contains tainted data, any subexpression may be considered tainted, even if the value of the subexpression is not itself affected by the tainted data.</source>
          <target state="translated">出于效率的考虑,Perl对数据是否有污点采取保守的观点。如果一个表达式包含污点数据,任何子表达式都可能被认为是污点数据,即使子表达式的值本身不受污点数据的影响。</target>
        </trans-unit>
        <trans-unit id="88d03294b4e14b45668b8c5e5b3dfd1364498c9a" translate="yes" xml:space="preserve">
          <source>For efficiency, consider using &lt;code&gt;newSVpvn&lt;/code&gt; instead.</source>
          <target state="translated">为了提高效率，请考虑改用 &lt;code&gt;newSVpvn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="586297e0f4c9f862517187fc9706a3d0c6dfe92d" translate="yes" xml:space="preserve">
          <source>For emphasis, those properties that match no code points at all are listed as well in a separate section following the table.</source>
          <target state="translated">为了强调,那些完全不符合码点的属性也在表后单独列出。</target>
        </trans-unit>
        <trans-unit id="c6f3b14d486219cf0d85fabf0e9eb85e0b88039e" translate="yes" xml:space="preserve">
          <source>For encodings that are implemented by the &lt;code&gt;Encode::XS&lt;/code&gt; module, &lt;code&gt;CHECK&lt;/code&gt;&lt;code&gt;==&lt;/code&gt;&lt;code&gt;Encode::FB_PERLQQ&lt;/code&gt; puts &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; into &lt;code&gt;perlqq&lt;/code&gt; fallback mode.</source>
          <target state="translated">对于由 &lt;code&gt;Encode::XS&lt;/code&gt; 模块实现的编码， &lt;code&gt;CHECK&lt;/code&gt; &lt;code&gt;==&lt;/code&gt; &lt;code&gt;Encode::FB_PERLQQ&lt;/code&gt; 将 &lt;code&gt;encode&lt;/code&gt; 和 &lt;code&gt;decode&lt;/code&gt; 置于 &lt;code&gt;perlqq&lt;/code&gt; 后备模式。</target>
        </trans-unit>
        <trans-unit id="5dbd88840e300bb2976ee7b89691796d725de54c" translate="yes" xml:space="preserve">
          <source>For even better control look at &lt;a href=&quot;Test::Most&quot;&gt;Test::Most&lt;/a&gt;.</source>
          <target state="translated">要获得更好的控制，请查看&lt;a href=&quot;Test::Most&quot;&gt;Test :: Most&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f0461c72db1796ac384c3743d40421d6d728a24" translate="yes" xml:space="preserve">
          <source>For even better control look at &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Most&quot;&gt;Test::Most&lt;/a&gt;.</source>
          <target state="translated">要获得更好的控制，请查看&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Most&quot;&gt;Test :: Most&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6de84b40d8c9c92b7839fff9ac4fcc2776aacc0f" translate="yes" xml:space="preserve">
          <source>For even faster execution, you could do:</source>
          <target state="translated">为了更快的执行,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">比如说</target>
        </trans-unit>
        <trans-unit id="6b398db36194244f1d9cc63256c82345fa029b47" translate="yes" xml:space="preserve">
          <source>For example &quot;not ok 23 - hole count # TODO insufficient donuts&quot; would result in this structure:</source>
          <target state="translated">例如 &quot;不行23-洞数#TODO不够甜甜圈 &quot;就会出现这种结构。</target>
        </trans-unit>
        <trans-unit id="a5d3ee5d1b4b93034c4647239c3af6ae67c5bde3" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;Carp&lt;/code&gt; itself is listed in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; . Therefore the full stack backtrace from &lt;code&gt;confess&lt;/code&gt; will not start inside of &lt;code&gt;Carp&lt;/code&gt; , and the short message from calling &lt;code&gt;croak&lt;/code&gt; is not placed on the line where &lt;code&gt;croak&lt;/code&gt; was called.</source>
          <target state="translated">例如， &lt;code&gt;Carp&lt;/code&gt; 本身在 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 列出。因此，从整个堆栈追踪 &lt;code&gt;confess&lt;/code&gt; 不会内启动 &lt;code&gt;Carp&lt;/code&gt; ，以及调用短信 &lt;code&gt;croak&lt;/code&gt; 不是放在哪里行 &lt;code&gt;croak&lt;/code&gt; 叫。</target>
        </trans-unit>
        <trans-unit id="521fa6026ce8939c8d285bb972a9f7bcfff4cab1" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;Carp&lt;/code&gt; itself is listed in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt;. Therefore the full stack backtrace from &lt;code&gt;confess&lt;/code&gt; will not start inside of &lt;code&gt;Carp&lt;/code&gt;, and the short message from calling &lt;code&gt;croak&lt;/code&gt; is not placed on the line where &lt;code&gt;croak&lt;/code&gt; was called.</source>
          <target state="translated">例如， &lt;code&gt;Carp&lt;/code&gt; 本身在 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 列出。因此，从整个堆栈追踪 &lt;code&gt;confess&lt;/code&gt; 不会内启动 &lt;code&gt;Carp&lt;/code&gt; ，以及调用短信 &lt;code&gt;croak&lt;/code&gt; 不是放在哪里行 &lt;code&gt;croak&lt;/code&gt; 叫。</target>
        </trans-unit>
        <trans-unit id="ace2b7f25e1af57e029dcfd910f2807f801a5827" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC RR&lt;/code&gt; with &lt;code&gt;COMBINING TILDE OVERLAY&lt;/code&gt; (&lt;code&gt;U+0344&lt;/code&gt; ) is &lt;code&gt;0FB2 0344 0F71 0F80&lt;/code&gt; in NFD. In this case &lt;code&gt;0FB2 0F80&lt;/code&gt; (&lt;code&gt;TIBETAN VOWEL SIGN VOCALIC R&lt;/code&gt; ) is detected, instead of &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; . Inserted &lt;code&gt;0344&lt;/code&gt; makes &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; discontiguous and lack of contraction &lt;code&gt;0FB2 0F71&lt;/code&gt; prohibits &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; from being detected.</source>
          <target state="translated">例如 &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC RR&lt;/code&gt; 与 &lt;code&gt;COMBINING TILDE OVERLAY&lt;/code&gt; （ &lt;code&gt;U+0344&lt;/code&gt; ）是 &lt;code&gt;0FB2 0344 0F71 0F80&lt;/code&gt; 中NFD。在这种情况下，将检测到 &lt;code&gt;0FB2 0F80&lt;/code&gt; （ &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC R&lt;/code&gt; ），而不是 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 。插入 &lt;code&gt;0344&lt;/code&gt; 会使 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 不连续且没有收缩 &lt;code&gt;0FB2 0F71&lt;/code&gt; 禁止检测到 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b3b5d05e6eb63eda24be82cac42fbd12530ed9c" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC RR&lt;/code&gt; with &lt;code&gt;COMBINING TILDE OVERLAY&lt;/code&gt; (&lt;code&gt;U+0344&lt;/code&gt;) is &lt;code&gt;0FB2 0344 0F71 0F80&lt;/code&gt; in NFD. In this case &lt;code&gt;0FB2 0F80&lt;/code&gt; (&lt;code&gt;TIBETAN VOWEL SIGN VOCALIC R&lt;/code&gt;) is detected, instead of &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt;. Inserted &lt;code&gt;0344&lt;/code&gt; makes &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; discontiguous and lack of contraction &lt;code&gt;0FB2 0F71&lt;/code&gt; prohibits &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; from being detected.</source>
          <target state="translated">例如 &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC RR&lt;/code&gt; 与 &lt;code&gt;COMBINING TILDE OVERLAY&lt;/code&gt; （ &lt;code&gt;U+0344&lt;/code&gt; ）是 &lt;code&gt;0FB2 0344 0F71 0F80&lt;/code&gt; 中NFD。在这种情况下，将检测到 &lt;code&gt;0FB2 0F80&lt;/code&gt; （ &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC R&lt;/code&gt; ），而不是 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 。插入 &lt;code&gt;0344&lt;/code&gt; 会使 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 不连续且没有收缩 &lt;code&gt;0FB2 0F71&lt;/code&gt; 禁止检测到 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30e72f699aeed60ccae59fad4d360b3c19491b02" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;U+1F88&lt;/code&gt; is equivalent to &lt;code&gt;U+1F00 U+03B9&lt;/code&gt; , instead of just &lt;code&gt;U+1F80&lt;/code&gt; . This difference matters mainly for certain Greek capital letters with certain modifiers: the Full case-folding decomposes the letter, while the Simple case-folding would map it to a single character.</source>
          <target state="translated">例如， &lt;code&gt;U+1F88&lt;/code&gt; 等效于 &lt;code&gt;U+1F00 U+03B9&lt;/code&gt; ，而不仅仅是 &lt;code&gt;U+1F80&lt;/code&gt; 。这种差异主要对带有某些修饰符的某些希腊大写字母很重要：完整的大小写折叠会分解字母，而简单的大小写折叠会将其映射到单个字符。</target>
        </trans-unit>
        <trans-unit id="90b883def1af1c1a868a945977d2d26ca0ae5dc6" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;U+1F88&lt;/code&gt; is equivalent to &lt;code&gt;U+1F00 U+03B9&lt;/code&gt;, instead of just &lt;code&gt;U+1F80&lt;/code&gt;. This difference matters mainly for certain Greek capital letters with certain modifiers: the Full case-folding decomposes the letter, while the Simple case-folding would map it to a single character.</source>
          <target state="translated">例如， &lt;code&gt;U+1F88&lt;/code&gt; 等效于 &lt;code&gt;U+1F00 U+03B9&lt;/code&gt; ，而不仅仅是 &lt;code&gt;U+1F80&lt;/code&gt; 。这种差异主要对带有某些修饰符的某些希腊大写字母很重要：全大写字母折叠分解字母，而简单大写字母折叠会将其映射到单个字符。</target>
        </trans-unit>
        <trans-unit id="b565d7aeb5a29ca8ef10bd80a27e15b4565fe687" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;ilogb(20)&lt;/code&gt; is 4, as an integer.</source>
          <target state="translated">例如， &lt;code&gt;ilogb(20)&lt;/code&gt; 是4，是整数。</target>
        </trans-unit>
        <trans-unit id="214bce966a0b82f5da24e7d2944d4f30b962d2dd" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;logb(20)&lt;/code&gt; is 4, as a floating point number.</source>
          <target state="translated">例如 &lt;code&gt;logb(20)&lt;/code&gt; 为4，作为浮点数。</target>
        </trans-unit>
        <trans-unit id="ba3539c7ce6418ebe27c9aacef03ad1ef9e8f077" translate="yes" xml:space="preserve">
          <source>For example a &lt;a href=&quot;gdbm_file&quot;&gt;GDBM_File&lt;/a&gt; GDBM_READER tied hash will die with something like:</source>
          <target state="translated">例如，与&lt;a href=&quot;gdbm_file&quot;&gt;GDBM_File&lt;/a&gt; GDBM_READER绑定的哈希将死于以下内容：</target>
        </trans-unit>
        <trans-unit id="b1b87712e77039600d0bb5eadd729b52754dd4ad" translate="yes" xml:space="preserve">
          <source>For example a &lt;a href=&quot;http://search.cpan.org/perldoc/GDBM_File&quot;&gt;GDBM_File&lt;/a&gt; GDBM_READER tied hash will die with something like:</source>
          <target state="translated">例如，与&lt;a href=&quot;http://search.cpan.org/perldoc/GDBM_File&quot;&gt;GDBM_File&lt;/a&gt; GDBM_READER绑定的哈希将死于以下内容：</target>
        </trans-unit>
        <trans-unit id="318807e1faa6370da68f94b91a578d4d9a1a925f" translate="yes" xml:space="preserve">
          <source>For example a template of &lt;code&gt;testXXXXXX&lt;/code&gt; and suffix of &lt;code&gt;.dat&lt;/code&gt; would generate a file similar to</source>
          <target state="translated">例如， &lt;code&gt;testXXXXXX&lt;/code&gt; 的模板和 &lt;code&gt;.dat&lt;/code&gt; 的后缀将生成类似于以下内容的文件</target>
        </trans-unit>
        <trans-unit id="74bb45479d65e581a981105236dd80b5a848028d" translate="yes" xml:space="preserve">
          <source>For example a template of C</source>
          <target state="translated">例如C的模板</target>
        </trans-unit>
        <trans-unit id="cdc25bb52677c33d7412ae881f68406f010eba12" translate="yes" xml:space="preserve">
          <source>For example after the following program:</source>
          <target state="translated">比如下面的程序后。</target>
        </trans-unit>
        <trans-unit id="22c45cfbac1c695f1bfa7c0643b1ffc692ad7e5a" translate="yes" xml:space="preserve">
          <source>For example if there is a &lt;code&gt;=head2&lt;/code&gt; in the POD file prior to a &lt;code&gt;=head1&lt;/code&gt; .</source>
          <target state="translated">例如，如果有一个 &lt;code&gt;=head2&lt;/code&gt; 在之前的POD文件 &lt;code&gt;=head1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6de621c77744b42e19d169bcbfad2ade8e3c01f0" translate="yes" xml:space="preserve">
          <source>For example if there is a &lt;code&gt;=head2&lt;/code&gt; in the POD file prior to a &lt;code&gt;=head1&lt;/code&gt;.</source>
          <target state="translated">例如，如果有一个 &lt;code&gt;=head2&lt;/code&gt; 在之前的POD文件 &lt;code&gt;=head1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c9f1ca436392d899e51a2acc5e1317d1e2a72ba" translate="yes" xml:space="preserve">
          <source>For example the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fethanschoonover.com%2fsolarized&quot;&gt;Solarized&lt;/a&gt; colors can be mapped with:</source>
          <target state="translated">例如，&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fethanschoonover.com%2fsolarized&quot;&gt;日晒&lt;/a&gt;颜色可以映射为：</target>
        </trans-unit>
        <trans-unit id="d5022ccbe5240d64fbbb13f709a591ad35027c5e" translate="yes" xml:space="preserve">
          <source>For example the &lt;a href=&quot;https://ethanschoonover.com/solarized&quot;&gt;Solarized&lt;/a&gt; colors can be mapped with:</source>
          <target state="translated">例如，&lt;a href=&quot;https://ethanschoonover.com/solarized&quot;&gt;日光化的&lt;/a&gt;颜色可以映射为：</target>
        </trans-unit>
        <trans-unit id="313b954d842d0bc62b1462fc60b81d6d65b41bbd" translate="yes" xml:space="preserve">
          <source>For example the Latin &lt;b&gt;script&lt;/b&gt; is spread over several &lt;b&gt;blocks&lt;/b&gt;, such as &lt;code&gt;Basic Latin&lt;/code&gt; , &lt;code&gt;Latin 1 Supplement&lt;/code&gt;, &lt;code&gt;Latin Extended-A&lt;/code&gt; , and &lt;code&gt;Latin Extended-B&lt;/code&gt; . On the other hand, the Latin script does not contain all the characters of the &lt;code&gt;Basic Latin&lt;/code&gt; block (also known as ASCII): it includes only the letters, and not, for example, the digits nor the punctuation.</source>
          <target state="translated">例如，拉丁&lt;b&gt;文字&lt;/b&gt;分布在几个&lt;b&gt;块中&lt;/b&gt;，例如 &lt;code&gt;Basic Latin&lt;/code&gt; ， &lt;code&gt;Latin 1 Supplement&lt;/code&gt; ， &lt;code&gt;Latin Extended-A&lt;/code&gt; 和 &lt;code&gt;Latin Extended-B&lt;/code&gt; 。另一方面，拉丁语脚本不包含 &lt;code&gt;Basic Latin&lt;/code&gt; 块的所有字符（也称为ASCII）：它仅包含字母，而不包括数字或标点符号。</target>
        </trans-unit>
        <trans-unit id="44972a585eb47fd3c1cfd9cd70932eb7157d7010" translate="yes" xml:space="preserve">
          <source>For example the Latin &lt;b&gt;script&lt;/b&gt; is spread over several &lt;b&gt;blocks&lt;/b&gt;, such as &lt;code&gt;Basic Latin&lt;/code&gt;, &lt;code&gt;Latin 1 Supplement&lt;/code&gt;, &lt;code&gt;Latin Extended-A&lt;/code&gt;, and &lt;code&gt;Latin Extended-B&lt;/code&gt;. On the other hand, the Latin script does not contain all the characters of the &lt;code&gt;Basic Latin&lt;/code&gt; block (also known as ASCII): it includes only the letters, and not, for example, the digits nor the punctuation.</source>
          <target state="translated">例如，拉丁&lt;b&gt;文字&lt;/b&gt;分布在几个&lt;b&gt;块中&lt;/b&gt;，例如 &lt;code&gt;Basic Latin&lt;/code&gt; ， &lt;code&gt;Latin 1 Supplement&lt;/code&gt; ， &lt;code&gt;Latin Extended-A&lt;/code&gt; 和 &lt;code&gt;Latin Extended-B&lt;/code&gt; 。另一方面，拉丁语脚本不包含 &lt;code&gt;Basic Latin&lt;/code&gt; 块的所有字符（也称为ASCII）：它仅包含字母，而不包括数字或标点符号。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="82ef4144af1f8de5f1e9ae8b466d94344115ab2d" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; excludes items listed in &lt;code&gt;no_index&lt;/code&gt; when searching for POD, meaning files in these directories will not converted to HTML and made public - which is useful if you have example or test PODs that you don't want the search engine to go through.</source>
          <target state="translated">例如，&lt;a href=&quot;http://search.cpan.org/&quot;&gt;http：&lt;/a&gt; &lt;code&gt;no_index&lt;/code&gt; 在搜索POD时排除no_index中列出的项目，这意味着这些目录中的文件不会转换为HTML并公开显示-如果您有示例或测试的POD，则很有用不想让搜索引擎经历。</target>
        </trans-unit>
        <trans-unit id="6812d6ccb69fe61a2edf14ef55d513765cc75692" translate="yes" xml:space="preserve">
          <source>For example, &lt;b&gt;-COE&lt;/b&gt; and &lt;b&gt;-C6&lt;/b&gt; will both turn on UTF-8-ness on both STDOUT and STDERR. Repeating letters is just redundant, not cumulative nor toggling.</source>
          <target state="translated">例如，&lt;b&gt;-COE&lt;/b&gt;和&lt;b&gt;1 -C 6&lt;/b&gt;将两者接通UTF-8岬在两个STDOUT和stderr。重复字母只是多余的，不是累积的或切换的。</target>
        </trans-unit>
        <trans-unit id="e66983239615f4463efa1593676357175c070f41" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&quot;-2&quot;..&quot;2&quot;&lt;/code&gt; is the same as &lt;code&gt;-2..2&lt;/code&gt;, and &lt;code&gt;&quot;2.18&quot;..&quot;3.14&quot;&lt;/code&gt; produces &lt;code&gt;2, 3&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;&quot;-2&quot;..&quot;2&quot;&lt;/code&gt; 与 &lt;code&gt;-2..2&lt;/code&gt; 相同，而 &lt;code&gt;&quot;2.18&quot;..&quot;3.14&quot;&lt;/code&gt; 产生 &lt;code&gt;2, 3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fe6d9c5c68e102fdd57d245db85bb6c1c51a595" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&quot;01&quot;..&quot;04&quot;&lt;/code&gt; produces &lt;code&gt;&quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;&lt;/code&gt;, and &lt;code&gt;&quot;00&quot;..&quot;-1&quot;&lt;/code&gt; produces &lt;code&gt;&quot;00&quot;&lt;/code&gt; through &lt;code&gt;&quot;99&quot;&lt;/code&gt; - this may seem surprising, but see the following rules for why it works this way. To get dates with leading zeros, you can say:</source>
          <target state="translated">例如， &lt;code&gt;&quot;01&quot;..&quot;04&quot;&lt;/code&gt; 产生 &lt;code&gt;&quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;00&quot;..&quot;-1&quot;&lt;/code&gt; 产生 &lt;code&gt;&quot;00&quot;&lt;/code&gt; 到 &lt;code&gt;&quot;99&quot;&lt;/code&gt; -这似乎令人惊讶，但请参阅以下规则了解其为何如此工作。要获取前导零的日期，您可以说：</target>
        </trans-unit>
        <trans-unit id="b9b2d2aa7ae22fcbe14979eb61870192c4dd7f04" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&quot;a&quot;..&quot;--&quot;&lt;/code&gt; is the same as &lt;code&gt;&quot;a&quot;..&quot;zz&quot;&lt;/code&gt;, &lt;code&gt;&quot;0&quot;..&quot;xx&quot;&lt;/code&gt; produces &lt;code&gt;&quot;0&quot;&lt;/code&gt; through &lt;code&gt;&quot;99&quot;&lt;/code&gt;, and &lt;code&gt;&quot;aaa&quot;..&quot;--&quot;&lt;/code&gt; returns the empty list.</source>
          <target state="translated">例如， &lt;code&gt;&quot;a&quot;..&quot;--&quot;&lt;/code&gt; 与 &lt;code&gt;&quot;a&quot;..&quot;zz&quot;&lt;/code&gt; ， &lt;code&gt;&quot;0&quot;..&quot;xx&quot;&lt;/code&gt; 产生 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 到 &lt;code&gt;&quot;99&quot;&lt;/code&gt; ，以及 &lt;code&gt;&quot;aaa&quot;..&quot;--&quot;&lt;/code&gt; 返回空列表。</target>
        </trans-unit>
        <trans-unit id="fd2c9b68575feddafd5a08ad5dafea23856e19ad" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&quot;ax&quot;..&quot;az&quot;&lt;/code&gt; produces &lt;code&gt;&quot;ax&quot;, &quot;ay&quot;, &quot;az&quot;&lt;/code&gt;, but &lt;code&gt;&quot;*x&quot;..&quot;az&quot;&lt;/code&gt; produces only &lt;code&gt;&quot;*x&quot;&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;&quot;ax&quot;..&quot;az&quot;&lt;/code&gt; 产生 &lt;code&gt;&quot;ax&quot;, &quot;ay&quot;, &quot;az&quot;&lt;/code&gt; ，但是 &lt;code&gt;&quot;*x&quot;..&quot;az&quot;&lt;/code&gt; 仅产生 &lt;code&gt;&quot;*x&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29e6ab6115ba236468a1784dbaded696c523a4aa" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;$+{foo}&lt;/code&gt; is equivalent to &lt;code&gt;$1&lt;/code&gt; after the following match:</source>
          <target state="translated">例如，以下匹配后， &lt;code&gt;$+{foo}&lt;/code&gt; 等于 &lt;code&gt;$1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="222cd952b129bcca43a9663919abeeb392a2e171" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&amp;lt;..\\l*b\\file/*glob.p?&amp;gt;&lt;/code&gt; will work as expected (in that it will find something like '..\lib\File/DosGlob.pm' alright). Note that all path components are case-insensitive, and that backslashes and forward slashes are both accepted, and preserved. You may have to double the backslashes if you are putting them in literally, due to double-quotish parsing of the pattern by perl.</source>
          <target state="translated">例如， &lt;code&gt;&amp;lt;..\\l*b\\file/*glob.p?&amp;gt;&lt;/code&gt; 将按预期工作（因为它将找到类似&amp;ldquo; .. \ lib \ File / DosGlob.pm&amp;rdquo;的内容）。请注意，所有路径组成部分都不区分大小写，并且反斜杠和正斜杠均被接受并保留。如果将它们放在字面上，则可能必须加倍反斜杠，这是因为perl对模式进行了双引号解析。</target>
        </trans-unit>
        <trans-unit id="062393ae2c2d73fa3bc2e3a2d91a68adfcd83483" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-oLaTeX&lt;/code&gt; currently tries all of the following classes: Pod::Perldoc::ToLaTeX Pod::Perldoc::Tolatex Pod::Perldoc::ToLatex Pod::Perldoc::ToLATEX Pod::Simple::LaTeX Pod::Simple::latex Pod::Simple::Latex Pod::Simple::LATEX Pod::LaTeX Pod::latex Pod::Latex Pod::LATEX.</source>
          <target state="translated">例如， &lt;code&gt;-oLaTeX&lt;/code&gt; 当前尝试以下所有类：Pod :: Perldoc :: ToLaTeX Pod :: Perldoc :: Tolatex Pod :: Perldoc :: ToLatex Pod :: Perldoc :: ToLATEX Pod :: Simple :: LaTeX Pod： ：Simple :: latex Pod :: Simple :: Latex Pod :: Simple :: LATEX Pod :: LaTeX Pod :: latex Pod :: Latex Pod :: LATEX。</target>
        </trans-unit>
        <trans-unit id="77a1e585a487cc3bfbbd51ad5e562a48a610c1cd" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;HARNESS_PERL_SWITCHES=-T&lt;/code&gt; will turn on taint mode. &lt;code&gt;HARNESS_PERL_SWITCHES=-MDevel::Cover&lt;/code&gt; will run &lt;code&gt;Devel::Cover&lt;/code&gt; for each test.</source>
          <target state="translated">例如， &lt;code&gt;HARNESS_PERL_SWITCHES=-T&lt;/code&gt; 将打开异味模式。 &lt;code&gt;HARNESS_PERL_SWITCHES=-MDevel::Cover&lt;/code&gt; 将为每个测试运行 &lt;code&gt;Devel::Cover&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86e52df63e27db421ca6b9e4dc513368b0a83476" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;U+0041&lt;/code&gt;&lt;code&gt;&quot;LATIN CAPITAL LETTER A&quot;&lt;/code&gt; was present in the very first Unicode release available, which is &lt;code&gt;1.1&lt;/code&gt; , so this property is true for all valid &quot;*&quot; versions. On the other hand, &lt;code&gt;U+1EFF&lt;/code&gt; was not assigned until version 5.1 when it became &lt;code&gt;&quot;LATIN SMALL LETTER Y WITH LOOP&quot;&lt;/code&gt; , so the only &quot;*&quot; that would match it are 5.1, 5.2, and later.</source>
          <target state="translated">例如， &lt;code&gt;U+0041&lt;/code&gt; &lt;code&gt;&quot;LATIN CAPITAL LETTER A&quot;&lt;/code&gt; 字母A&amp;rdquo;出现在第一个可用的Unicode版本（即 &lt;code&gt;1.1&lt;/code&gt; )中，因此对于所有有效的&amp;ldquo; *&amp;rdquo;版本，此属性均为true。另一方面， &lt;code&gt;U+1EFF&lt;/code&gt; 直到5.1版成为 &lt;code&gt;&quot;LATIN SMALL LETTER Y WITH LOOP&quot;&lt;/code&gt; 拉丁文小写字母Y&amp;rdquo;时才分配，因此与之匹配的唯一&amp;ldquo; *&amp;rdquo;是5.1、5.2和更高版本。</target>
        </trans-unit>
        <trans-unit id="b293a722d09747451b766a52031476e1ba81af2d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;U+0041&lt;/code&gt;&lt;code&gt;&quot;LATIN CAPITAL LETTER A&quot;&lt;/code&gt; was present in the very first Unicode release available, which is &lt;code&gt;1.1&lt;/code&gt;, so this property is true for all valid &quot;*&quot; versions. On the other hand, &lt;code&gt;U+1EFF&lt;/code&gt; was not assigned until version 5.1 when it became &lt;code&gt;&quot;LATIN SMALL LETTER Y WITH LOOP&quot;&lt;/code&gt;, so the only &quot;*&quot; that would match it are 5.1, 5.2, and later.</source>
          <target state="translated">例如， &lt;code&gt;U+0041&lt;/code&gt; &lt;code&gt;&quot;LATIN CAPITAL LETTER A&quot;&lt;/code&gt; 字母A&amp;rdquo;出现在第一个可用的Unicode版本（即 &lt;code&gt;1.1&lt;/code&gt; )中，因此此属性对于所有有效的&amp;ldquo; *&amp;rdquo;版本都是正确的。另一方面， &lt;code&gt;U+1EFF&lt;/code&gt; 直到5.1版成为 &lt;code&gt;&quot;LATIN SMALL LETTER Y WITH LOOP&quot;&lt;/code&gt; 拉丁文小写字母Y&amp;rdquo;时才分配，因此与之匹配的唯一&amp;ldquo; *&amp;rdquo;是5.1、5.2和更高版本。</target>
        </trans-unit>
        <trans-unit id="346cf35fe7206ef61916e68c2ca5d063324557a7" translate="yes" xml:space="preserve">
          <source>For example, Foo::Bar becomes Foo-Bar.</source>
          <target state="translated">例如,Foo::Bar变成了Foo-Bar。</target>
        </trans-unit>
        <trans-unit id="ea8cd802fd235063bdbe8cd10be2c1b9866e7e9d" translate="yes" xml:space="preserve">
          <source>For example, MyExpirePolicy::TIEHASH might create an object that contains a regular Perl hash (which it will to store the cached values) and some extra information about the arguments and how old the data is and things like that. Let us call this object `C'.</source>
          <target state="translated">例如,MyExpirePolicy::TIEHASH可能会创建一个对象,这个对象包含一个常规的Perl哈希(它将用来存储缓存值)和一些关于参数的额外信息以及数据的年龄等等。让我们称这个对象为`C'。</target>
        </trans-unit>
        <trans-unit id="7e2c26a54a82719f79b06117790e2637ab0e300f" translate="yes" xml:space="preserve">
          <source>For example, a &lt;code&gt;Moose&lt;/code&gt; class can subclass a &lt;code&gt;Moo&lt;/code&gt; class using &lt;code&gt;extends&lt;/code&gt; or consume a &lt;code&gt;Moo&lt;/code&gt; role using &lt;code&gt;with&lt;/code&gt; .</source>
          <target state="translated">例如， &lt;code&gt;Moose&lt;/code&gt; 类可以使用 &lt;code&gt;extends&lt;/code&gt; 子类来创建 &lt;code&gt;Moo&lt;/code&gt; 类，或者使用 &lt;code&gt;with&lt;/code&gt; 来使用 &lt;code&gt;Moo&lt;/code&gt; 角色。</target>
        </trans-unit>
        <trans-unit id="e1743f8be5bc24aa84fbb2597cf9ba3fce287be4" translate="yes" xml:space="preserve">
          <source>For example, a &lt;code&gt;Moose&lt;/code&gt; class can subclass a &lt;code&gt;Moo&lt;/code&gt; class using &lt;code&gt;extends&lt;/code&gt; or consume a &lt;code&gt;Moo&lt;/code&gt; role using &lt;code&gt;with&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;Moose&lt;/code&gt; 类可以使用 &lt;code&gt;extends&lt;/code&gt; 子类化 &lt;code&gt;Moo&lt;/code&gt; 类，或者使用 &lt;code&gt;with&lt;/code&gt; 来消耗 &lt;code&gt;Moo&lt;/code&gt; 角色。</target>
        </trans-unit>
        <trans-unit id="557d3fcd9902744d46a8cb542c3d28eade0c9716" translate="yes" xml:space="preserve">
          <source>For example, a directive consisting of this:</source>
          <target state="translated">例如,一个指令包括这样的内容:</target>
        </trans-unit>
        <trans-unit id="bf2744eaf270dcbbff1985c2b73c221de5631d9d" translate="yes" xml:space="preserve">
          <source>For example, a version of &lt;code&gt;like()&lt;/code&gt; , sans the useful diagnostic messages, could be written as:</source>
          <target state="translated">例如，没有有用的诊断消息的 &lt;code&gt;like()&lt;/code&gt; 版本可以写为：</target>
        </trans-unit>
        <trans-unit id="54553804eb65ab331e5083c6d74eeb123e188def" translate="yes" xml:space="preserve">
          <source>For example, a version of &lt;code&gt;like()&lt;/code&gt;, sans the useful diagnostic messages, could be written as:</source>
          <target state="translated">例如，没有有用的诊断消息的 &lt;code&gt;like()&lt;/code&gt; 版本可以写为：</target>
        </trans-unit>
        <trans-unit id="f4218fb9c51483864cd6b3fb02448d68465452ff" translate="yes" xml:space="preserve">
          <source>For example, an XSUB</source>
          <target state="translated">例如,XSUB</target>
        </trans-unit>
        <trans-unit id="cce56f257ff2d1a6e195376cb7b5f349fe5b4b57" translate="yes" xml:space="preserve">
          <source>For example, as of Oct 31, 2009, the CPAN index file contained these module-distribution mappings:</source>
          <target state="translated">例如,截至2009年10月31日,CPAN索引文件中包含以下模块分布映射。</target>
        </trans-unit>
        <trans-unit id="7132575485b1cfbea0394c9ac448d0a435204db7" translate="yes" xml:space="preserve">
          <source>For example, both options given below are equivalent to setting &lt;code&gt;ReuseAddr&lt;/code&gt;.</source>
          <target state="translated">例如，下面给出的两个选项都等同于设置 &lt;code&gt;ReuseAddr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d908226f910991ef51ebc57880107e99b08586dc" translate="yes" xml:space="preserve">
          <source>For example, consider the code below:</source>
          <target state="translated">例如,考虑以下代码。</target>
        </trans-unit>
        <trans-unit id="ec1791bd29717623df33288ef02efc342f0cf537" translate="yes" xml:space="preserve">
          <source>For example, consider the following scenario. You have a DBM database that you need to share with a third-party C application. The C application assumes that</source>
          <target state="translated">例如,考虑以下场景。你有一个DBM数据库,你需要与一个第三方C应用程序共享。这个C应用程序假设</target>
        </trans-unit>
        <trans-unit id="8190f04d38d06a461e096583cfda36d375198e8e" translate="yes" xml:space="preserve">
          <source>For example, consider:</source>
          <target state="translated">例如,考虑:</target>
        </trans-unit>
        <trans-unit id="120867ef674bae56ea0364ba96f034264719d15f" translate="yes" xml:space="preserve">
          <source>For example, given &lt;code&gt;dir&lt;/code&gt; of 'lib' and &lt;code&gt;prefix&lt;/code&gt; of 'lib', the return value is a hashref of the form:</source>
          <target state="translated">例如，给定 &lt;code&gt;dir&lt;/code&gt; 为&amp;ldquo; lib&amp;rdquo;， &lt;code&gt;prefix&lt;/code&gt; 为&amp;ldquo; lib&amp;rdquo;，则返回值是以下形式的hashref：</target>
        </trans-unit>
        <trans-unit id="c1377b5d79a1a1b8f2eb1b799a03d844580027b4" translate="yes" xml:space="preserve">
          <source>For example, given the string:</source>
          <target state="translated">例如,给定字符串:</target>
        </trans-unit>
        <trans-unit id="61f7eb35077596ec97c395fa31a4c9dc65c12237" translate="yes" xml:space="preserve">
          <source>For example, here all the areas that are taken literally are underlined with a &quot;^&quot;, and all the in-bracket special regions are underlined with an X:</source>
          <target state="translated">例如,这里所有按字面意思取用的区域都用&quot;^&quot;划线,所有括号内的特殊区域都用X划线。</target>
        </trans-unit>
        <trans-unit id="282f0060364377e323c90656e8982dd19487e634" translate="yes" xml:space="preserve">
          <source>For example, here is a loop that inserts index producing entries before any line containing a certain pattern:</source>
          <target state="translated">例如,这里有一个循环,在包含特定模式的任何行之前插入产生索引的条目。</target>
        </trans-unit>
        <trans-unit id="c309481bf35b9a661995259865d469413fa7c131" translate="yes" xml:space="preserve">
          <source>For example, here is a minimal source code filter in a module named BANG.pm. It simply converts every occurrence of the sequence &lt;code&gt;BANG\s+BANG&lt;/code&gt; to the sequence &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt; 'BANG' if $BANG&lt;/code&gt; in any piece of code following a &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG;&lt;/code&gt; statement (until the next &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; statement, if any):</source>
          <target state="translated">例如，这是名为BANG.pm的模块中的最小源代码过滤器。它只是序列的每次发生转换 &lt;code&gt;BANG\s+BANG&lt;/code&gt; 的序列 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt; 'BANG' if $BANG&lt;/code&gt; 在以下任何一个的代码 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG;&lt;/code&gt; 语句（直到下一个 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; 语句，如果有的话）：</target>
        </trans-unit>
        <trans-unit id="1a7d21d7fdba8993fa8f320558eb8943554fa8e9" translate="yes" xml:space="preserve">
          <source>For example, here is a minimal source code filter in a module named BANG.pm. It simply converts every occurrence of the sequence &lt;code&gt;BANG\s+BANG&lt;/code&gt; to the sequence &lt;code&gt;die 'BANG' if $BANG&lt;/code&gt; in any piece of code following a &lt;code&gt;use BANG;&lt;/code&gt; statement (until the next &lt;code&gt;no BANG;&lt;/code&gt; statement, if any):</source>
          <target state="translated">例如，这是名为BANG.pm的模块中的最小源代码过滤器。 &lt;code&gt;die 'BANG' if $BANG&lt;/code&gt; 在 &lt;code&gt;use BANG;&lt;/code&gt; 之后的任何代码段中，它会将序列 &lt;code&gt;BANG\s+BANG&lt;/code&gt; 每次出现简单地转换为序列die'BANG' 。语句（直到下一个 &lt;code&gt;no BANG;&lt;/code&gt; 语句，如果有的话）：</target>
        </trans-unit>
        <trans-unit id="deab4a0dbceae95053981957ee52dc40c226b6c1" translate="yes" xml:space="preserve">
          <source>For example, here is a sample filter that adds a trailing NULL character to all strings before they are written to the DBM file, and removes the trailing NULL when they are read from the DBM file</source>
          <target state="translated">例如,下面是一个示例过滤器,它在所有字符串写入DBM文件之前给它们添加一个尾部的NULL字符,并在从DBM文件中读取它们时删除尾部的NULL字符。</target>
        </trans-unit>
        <trans-unit id="2ff6a04c682bedfc2159947b94ad35c5e1653401" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;$a&lt;/code&gt; is an object blessed into a package declaring</source>
          <target state="translated">例如，如果 &lt;code&gt;$a&lt;/code&gt; 是一个有福的对象，则它声明为包</target>
        </trans-unit>
        <trans-unit id="e47691ce5bbf77ccdd2c65322eb9ae19daa34236" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;A&lt;/code&gt; inherits from &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; (in that order), &lt;code&gt;B&lt;/code&gt; overloads &lt;code&gt;+&lt;/code&gt; with &lt;code&gt;\&amp;amp;D::plus_sub&lt;/code&gt; , and &lt;code&gt;C&lt;/code&gt; overloads &lt;code&gt;+&lt;/code&gt; by &lt;code&gt;&quot;plus_meth&quot;&lt;/code&gt; , then the subroutine &lt;code&gt;D::plus_sub&lt;/code&gt; will be called to implement operation &lt;code&gt;+&lt;/code&gt; for an object in package &lt;code&gt;A&lt;/code&gt; .</source>
          <target state="translated">例如，如果 &lt;code&gt;A&lt;/code&gt; 从继承 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; （以该顺序）， &lt;code&gt;B&lt;/code&gt; 重载 &lt;code&gt;+&lt;/code&gt; 与 &lt;code&gt;\&amp;amp;D::plus_sub&lt;/code&gt; ，和 &lt;code&gt;C&lt;/code&gt; 重载 &lt;code&gt;+&lt;/code&gt; 由 &lt;code&gt;&quot;plus_meth&quot;&lt;/code&gt; ，则子程序 &lt;code&gt;D::plus_sub&lt;/code&gt; 将被调用来执行操作 &lt;code&gt;+&lt;/code&gt; 为包 &lt;code&gt;A&lt;/code&gt; 中的一个对象。</target>
        </trans-unit>
        <trans-unit id="8ff3217e3f10be1d713ebcee2d82c19ffe203ca1" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;A&lt;/code&gt; inherits from &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; (in that order), &lt;code&gt;B&lt;/code&gt; overloads &lt;code&gt;+&lt;/code&gt; with &lt;code&gt;\&amp;amp;D::plus_sub&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt; overloads &lt;code&gt;+&lt;/code&gt; by &lt;code&gt;&quot;plus_meth&quot;&lt;/code&gt;, then the subroutine &lt;code&gt;D::plus_sub&lt;/code&gt; will be called to implement operation &lt;code&gt;+&lt;/code&gt; for an object in package &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">例如，如果 &lt;code&gt;A&lt;/code&gt; 从继承 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; （以该顺序）， &lt;code&gt;B&lt;/code&gt; 重载 &lt;code&gt;+&lt;/code&gt; 与 &lt;code&gt;\&amp;amp;D::plus_sub&lt;/code&gt; ，和 &lt;code&gt;C&lt;/code&gt; 重载 &lt;code&gt;+&lt;/code&gt; 由 &lt;code&gt;&quot;plus_meth&quot;&lt;/code&gt; ，则子程序 &lt;code&gt;D::plus_sub&lt;/code&gt; 将被调用来执行操作 &lt;code&gt;+&lt;/code&gt; 为包 &lt;code&gt;A&lt;/code&gt; 中的一个对象。</target>
        </trans-unit>
        <trans-unit id="fdb8e022d3a14d860cf1eee66a67b7f130110122" translate="yes" xml:space="preserve">
          <source>For example, if a user accepts only 'ca' (Catalan) and 'es' (Spanish), and the documents/interfaces you have available are just in German, Italian, and Chinese, then the user will most likely want the Italian one (and not the Chinese or German one!), instead of getting nothing. So &lt;code&gt;panic_languages('ca', 'es')&lt;/code&gt; returns a list containing 'it' (Italian).</source>
          <target state="translated">例如，如果用户仅接受&amp;ldquo; ca&amp;rdquo;（加泰罗尼亚语）和&amp;ldquo; es&amp;rdquo;（西班牙语），并且您可用的文档/界面只有德语，意大利语和中文，则该用户很可能想要意大利语（而不是中文或德语！），却一无所获。因此 &lt;code&gt;panic_languages('ca', 'es')&lt;/code&gt; 返回一个包含'it'（意大利语）的列表。</target>
        </trans-unit>
        <trans-unit id="dd033dcdd253bc51f444e9213dde5da48cee293c" translate="yes" xml:space="preserve">
          <source>For example, if all the characters in the sequence are Greek, or Common, or Inherited, this function will return TRUE, provided any decimal digits in it are from the same block of digits in Common. (These are the ASCII digits &quot;0&quot;..&quot;9&quot; and additionally a block for full width forms of these, and several others used in mathematical notation.) For scripts (unlike Greek) that have their own digits defined this will accept either digits from that set or from one of the Common digit sets, but not a combination of the two. Some scripts, such as Arabic, have more than one set of digits. All digits must come from the same set for this function to return TRUE.</source>
          <target state="translated">例如,如果序列中的所有字符都是希腊语,或者是通用的,或者是继承的,那么这个函数将返回TRUE,条件是其中的任何十进制数字都来自于通用的同一数字块。(这些数字是ASCII数字 &quot;0&quot;...&quot;9&quot;,另外还有一个全宽形式的数字块,以及其他一些数学符号中使用的数字)。对于有自己的数字定义的脚本(不像希腊语),这将接受来自该集的数字或来自通用数字集的数字,但不是两者的组合。有些脚本,如阿拉伯语,有多于一个数字集。所有的数字必须来自同一组,这个函数才能返回TRUE。</target>
        </trans-unit>
        <trans-unit id="36b2730284efb7215764ff65ce5779181405a788" translate="yes" xml:space="preserve">
          <source>For example, if both input and out are chosen to be &lt;code&gt;:encoding(UTF-8)&lt;/code&gt;, a &lt;code&gt;:std&lt;/code&gt; will mean that STDIN, STDOUT, and STDERR will also have &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; set. On the other hand, if only output is chosen to be in &lt;code&gt;:encoding(koi8r)&lt;/code&gt;, a &lt;code&gt;:std&lt;/code&gt; will cause only the STDOUT and STDERR to be in &lt;code&gt;koi8r&lt;/code&gt;.</source>
          <target state="translated">例如，如果输入和输出都选择为 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; ，则 &lt;code&gt;:std&lt;/code&gt; 表示STDIN，STDOUT和STDERR也将设置 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 。另一方面，如果仅选择在 &lt;code&gt;:encoding(koi8r)&lt;/code&gt; 中输出，则 &lt;code&gt;:std&lt;/code&gt; 将仅导致STDOUT和STDERR在 &lt;code&gt;koi8r&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="886940312d9491ca5ffc8d712e7908d39622ad09" translate="yes" xml:space="preserve">
          <source>For example, if no tests have run &lt;code&gt;is_passing()&lt;/code&gt; will be true because even though a suite with no tests is a failure you can add a passing test to it and start passing.</source>
          <target state="translated">例如，如果没有运行任何测试，则 &lt;code&gt;is_passing()&lt;/code&gt; 将为true，因为即使没有测试的套件失败，您也可以向其添加通过测试并开始通过。</target>
        </trans-unit>
        <trans-unit id="f350820f8a15ee234a6d0b5f40ef9ca061810978" translate="yes" xml:space="preserve">
          <source>For example, if the bug is present on &lt;code&gt;HEAD&lt;/code&gt; but wasn't in 5.10.0, &lt;code&gt;git&lt;/code&gt; will learn about this when you enter:</source>
          <target state="translated">例如，如果该错误存在于 &lt;code&gt;HEAD&lt;/code&gt; 上,但不是在5.10.0中存在，则 &lt;code&gt;git&lt;/code&gt; 在您输入以下内容时会了解到这一点：</target>
        </trans-unit>
        <trans-unit id="8759c901db12e35962f36dbb59c087c3f752959f" translate="yes" xml:space="preserve">
          <source>For example, if you add a Unicode string like</source>
          <target state="translated">例如,如果你添加一个Unicode字符串,如</target>
        </trans-unit>
        <trans-unit id="32c9f1310448f772c98938afaa753d6c8ad8468a" translate="yes" xml:space="preserve">
          <source>For example, if you have 4 C functions multiply(), divide(), add(), subtract() all having the signature:</source>
          <target state="translated">例如,如果你有4个C函数乘()、除()、加()、减()都有签名。</target>
        </trans-unit>
        <trans-unit id="4a173ebec9470f66747de7c5eefed0eb1d0d01a0" translate="yes" xml:space="preserve">
          <source>For example, if you have a uuencoded and compressed source file, it is possible to stack a uudecode filter and an uncompression filter like this:</source>
          <target state="translated">例如,如果你有一个Uuencoded和压缩的源文件,可以像这样堆叠一个Uudecode过滤器和一个uncompression过滤器。</target>
        </trans-unit>
        <trans-unit id="d9372470a314912841e718aa7d95049e68d683c3" translate="yes" xml:space="preserve">
          <source>For example, if you want all your regular expressions to have /msx on by default, simply put</source>
          <target state="translated">例如,如果你想让所有的正则表达式都默认为/msx,只需输入</target>
        </trans-unit>
        <trans-unit id="743af917ca6acb088488514506f78e5a56610546" translate="yes" xml:space="preserve">
          <source>For example, if you want all your regular expressions to have /msxx on by default, simply put</source>
          <target state="translated">例如,如果你想让所有的正则表达式默认为/msxx,只需将</target>
        </trans-unit>
        <trans-unit id="4909c84cf33294d068c280ab4acd84ce25b4c18c" translate="yes" xml:space="preserve">
          <source>For example, if you wanted a function to make a new hash and return a reference to it, you have these options:</source>
          <target state="translated">例如,如果你想用一个函数创建一个新的哈希并返回一个引用,你有这些选项。</target>
        </trans-unit>
        <trans-unit id="6c2555ae4677f2fae349053aea4869881467feea" translate="yes" xml:space="preserve">
          <source>For example, if your scalar is a reference and you want to modify the &lt;code&gt;SvIVX&lt;/code&gt; slot, you can't just do &lt;code&gt;SvROK_off&lt;/code&gt;, as that will leak the referent.</source>
          <target state="translated">例如，如果您的标量是参考，并且您想要修改 &lt;code&gt;SvIVX&lt;/code&gt; 插槽，则不能仅仅执行 &lt;code&gt;SvROK_off&lt;/code&gt; ，因为这会泄漏参考对象。</target>
        </trans-unit>
        <trans-unit id="a570ae33985ad610c93d2b21ee03162407502a4d" translate="yes" xml:space="preserve">
          <source>For example, if your scalar is a reference and you want to modify the SvIVX slot, you can't just do SvROK_off, as that will leak the referent.</source>
          <target state="translated">例如,如果你的标量是一个引用,而你想修改 SvIVX 槽,你不能只做 SvROK_off,因为那会泄露引用。</target>
        </trans-unit>
        <trans-unit id="85a3de5be37b1e7d1156f1cef62afbe6c76e2823" translate="yes" xml:space="preserve">
          <source>For example, imagine you want to return a reference from an XSUB function. Inside the XSUB routine, you create an SV which initially has a reference count of one. Then you call &lt;code&gt;newRV_inc&lt;/code&gt; , passing it the just-created SV. This returns the reference as a new SV, but the reference count of the SV you passed to &lt;code&gt;newRV_inc&lt;/code&gt; has been incremented to two. Now you return the reference from the XSUB routine and forget about the SV. But Perl hasn't! Whenever the returned reference is destroyed, the reference count of the original SV is decreased to one and nothing happens. The SV will hang around without any way to access it until Perl itself terminates. This is a memory leak.</source>
          <target state="translated">例如，假设您想从XSUB函数返回引用。在XSUB例程中，创建一个SV，该SV最初的引用计数为1。然后调用 &lt;code&gt;newRV_inc&lt;/code&gt; ，将刚刚创建的SV传递给它。这会将引用作为新的SV返回，但是传递给 &lt;code&gt;newRV_inc&lt;/code&gt; 的SV的引用计数已增加为2。现在，您从XSUB例程返回引用，而不必理会SV。但是Perl还没有！每当返回的引用被销毁时，原始SV的引用计数都将减少为1，并且什么也不会发生。直到Perl自身终止，SV都将徘徊而无法访问它。这是内存泄漏。</target>
        </trans-unit>
        <trans-unit id="21d2cc6afcf04419580fbfc3f6b2421473912245" translate="yes" xml:space="preserve">
          <source>For example, imagine you want to return a reference from an XSUB function. Inside the XSUB routine, you create an SV which initially has just a single reference, owned by the XSUB routine. This reference needs to be disposed of before the routine is complete, otherwise it will leak, preventing the SV from ever being destroyed. So to create an RV referencing the SV, it is most convenient to pass the SV to &lt;code&gt;newRV_noinc()&lt;/code&gt;, which consumes that reference. Now the XSUB routine no longer owns a reference to the SV, but does own a reference to the RV, which in turn owns a reference to the SV. The ownership of the reference to the RV is then transferred by the process of returning the RV from the XSUB.</source>
          <target state="translated">例如，假设您想从XSUB函数返回引用。在XSUB例程内，您将创建一个SV，该SV最初只有一个引用，由XSUB例程拥有。在例程完成之前，必须先删除此引用，否则它将泄漏，从而防止SV被破坏。因此，要创建引用SV的RV，将SV传递给 &lt;code&gt;newRV_noinc()&lt;/code&gt; 该引用的newRV_noinc（）最为方便。现在，XSUB例程不再拥有对SV的引用，而是拥有对RV的引用，而RV又拥有对SV的引用。然后，通过从XSUB返回RV的过程来转移对RV的引用的所有权。</target>
        </trans-unit>
        <trans-unit id="9cb2e2ef894e1ed98060074d6b4776bf06e4d3ee" translate="yes" xml:space="preserve">
          <source>For example, intuition tells you that this XS code:</source>
          <target state="translated">比如,直觉告诉你,这个XS代码。</target>
        </trans-unit>
        <trans-unit id="74d92c0f78a3f35d2b66123bb54771dbbcbaaae8" translate="yes" xml:space="preserve">
          <source>For example, it might return these data (among others) for the difference between 5.008000 and 5.008001:</source>
          <target state="translated">例如,它可能会返回5.008000和5.008001之间的差额的这些数据(还有其他数据)。</target>
        </trans-unit>
        <trans-unit id="8932a840658bb617ebb44a7bc96b426c503bdff7" translate="yes" xml:space="preserve">
          <source>For example, let's say that you have a long-running database server daemon that you want folks to be able to access from the Web, but only if they go through a CGI interface. You'd have a small, simple CGI program that does whatever checks and logging you feel like, and then acts as a Unix-domain client and connects to your private server.</source>
          <target state="translated">例如,假设你有一个长期运行的数据库服务器守护进程,你希望人们能够从Web上访问它,但只能通过CGI接口。你会有一个小的、简单的CGI程序,它可以做任何你喜欢的检查和记录,然后作为一个Unix域的客户端,连接到你的私有服务器。</target>
        </trans-unit>
        <trans-unit id="86ba35baedd2bab7b0f63f6847d21e1fa348e167" translate="yes" xml:space="preserve">
          <source>For example, let's say you'd like to have your</source>
          <target state="translated">例如,让我们假设你想让你的</target>
        </trans-unit>
        <trans-unit id="194fc6778319983cc9c4ca8c95042faf96fb7b65" translate="yes" xml:space="preserve">
          <source>For example, let's take a GUI driven program. It has a semaphore that it uses to synchronize access to the display, so only one thread is ever drawing at once. Handy, but of course you don't want any thread to start drawing until things are properly set up. In this case, you can create a semaphore with a counter set to zero, and up it when things are ready for drawing.</source>
          <target state="translated">例如,让我们以一个GUI驱动的程序为例,它有一个信号器,用来同步访问显示,所以一次只有一个线程在绘制。它有一个信号灯,用来同步对显示的访问,所以只有一个线程同时进行绘图。很方便,但当然你不希望任何线程在事情被正确设置之前开始绘图。在这种情况下,你可以创建一个信号体,将计数器设置为零,当事情准备就绪时再将其升起。</target>
        </trans-unit>
        <trans-unit id="a7c15f9bd991e32fcb9fda0fc1d672dd96785374" translate="yes" xml:space="preserve">
          <source>For example, line 2 below is wrong because it does not have at least 2 spaces, but lines 1 and 3 are fine because they have at least 2:</source>
          <target state="translated">例如,下面的第2行是错误的,因为它没有至少2个空格,但第1行和第3行是好的,因为它们至少有2个。</target>
        </trans-unit>
        <trans-unit id="b5cc0c799c8ac490a734bb661c428c57117107e1" translate="yes" xml:space="preserve">
          <source>For example, many newer useful APIs are not present in OS/2 v2; many PM-related APIs require DLLs not available on floppy-boot setup.</source>
          <target state="translated">例如,许多较新的有用的API在OS/2 v2中并不存在;许多与PM相关的API需要在软盘启动设置中不可用的DLL。</target>
        </trans-unit>
        <trans-unit id="dc5f27a11595298226b5ecd1db6f9aeef4a5b4ec" translate="yes" xml:space="preserve">
          <source>For example, on Unix this would escape any single-quotes in $text and put single-quotes around the whole thing.</source>
          <target state="translated">例如,在Unix上,这将转义$text中的任何单引号,并将单引号放在整个内容周围。</target>
        </trans-unit>
        <trans-unit id="609e914fb8a944506b94ed39a0575be3c2f1f46e" translate="yes" xml:space="preserve">
          <source>For example, on a poorly equipped computer,</source>
          <target state="translated">例如,在一台设备较差的电脑上。</target>
        </trans-unit>
        <trans-unit id="e6ea05a8d9aa3d31bd0e3e1d1aa6044dba6a83b8" translate="yes" xml:space="preserve">
          <source>For example, parsing a L&amp;lt;Foo/&quot;Bar&quot;&amp;gt; link will produce a start-token with a &quot;to&quot; attribute with the value &quot;Foo&quot;, a &quot;type&quot; attribute with the value &quot;pod&quot;, and a &quot;section&quot; attribute with the value &quot;Bar&quot;.</source>
          <target state="translated">例如，解析L &amp;lt;Foo /&amp;ldquo; Bar&amp;rdquo;&amp;gt;链接将产生一个起始令牌，其起始值为&amp;ldquo; to&amp;rdquo;属性的值为&amp;ldquo; Foo&amp;rdquo;，&amp;ldquo; type&amp;rdquo;属性的值为&amp;ldquo; pod&amp;rdquo;和&amp;ldquo; section&amp;rdquo;属性的值为&amp;ldquo; Bar&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7ea4a776edac8c6f6bfd35b979f9a6514e0b64fe" translate="yes" xml:space="preserve">
          <source>For example, parsing this paragraph of Pod:</source>
          <target state="translated">例如,解析Pod的这段话。</target>
        </trans-unit>
        <trans-unit id="4d8ed73a29aeabbe37200513a23647bf9812ba11" translate="yes" xml:space="preserve">
          <source>For example, say you need to create a class implementing overloaded mathematical operators, and would like to provide your own pragma that functions much like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; You'd like this code</source>
          <target state="translated">例如，假设您需要创建一个实现重载数学运算符的类，并希望提供自己的函数，其功能类似于 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 您想要此代码</target>
        </trans-unit>
        <trans-unit id="6daf57bf99f1fc518b402ca174d25b0d54e1f1c0" translate="yes" xml:space="preserve">
          <source>For example, say you need to create a class implementing overloaded mathematical operators, and would like to provide your own pragma that functions much like &lt;code&gt;use integer;&lt;/code&gt; You'd like this code</source>
          <target state="translated">例如，假设您需要创建一个实现重载数学运算符的类，并希望提供自己的函数，其功能类似于 &lt;code&gt;use integer;&lt;/code&gt; 您想要这个代码</target>
        </trans-unit>
        <trans-unit id="7fbbe0aa9845cec520a90786e8524e8299625199" translate="yes" xml:space="preserve">
          <source>For example, setting prefix_pattern to &lt;code&gt;--|-|\+|\/&lt;/code&gt; and long_prefix_pattern to &lt;code&gt;--|\/&lt;/code&gt; would add Win32 style argument handling.</source>
          <target state="translated">例如，将prefix_pattern设置为 &lt;code&gt;--|-|\+|\/&lt;/code&gt; ，将long_prefix_pattern设置为 &lt;code&gt;--|\/&lt;/code&gt; 将添加Win32样式参数处理。</target>
        </trans-unit>
        <trans-unit id="83cdc2b87550c2073421ee9d7b2b562b30e21210" translate="yes" xml:space="preserve">
          <source>For example, suppose that a C function is declared as</source>
          <target state="translated">例如,假设一个C函数被声明为</target>
        </trans-unit>
        <trans-unit id="3032721d2a0b9447ee105fd0f58af3c782c7c78e" translate="yes" xml:space="preserve">
          <source>For example, suppose that you have a module, A, which already has an import function:</source>
          <target state="translated">例如,假设你有一个模块A,它已经有一个导入函数。</target>
        </trans-unit>
        <trans-unit id="5d59fda06c904abab606e40ac19199fab2edd4c9" translate="yes" xml:space="preserve">
          <source>For example, suppose the start tag &quot;/para&quot; introduces a paragraph, which then continues until the next &quot;/endpara&quot; tag or until another &quot;/para&quot; tag is encountered:</source>
          <target state="translated">例如,假设开始标签&quot;/para &quot;介绍了一个段落,然后一直到下一个&quot;/endpara &quot;标签或遇到另一个&quot;/para &quot;标签为止。</target>
        </trans-unit>
        <trans-unit id="722e9b7fb9ae1447f9773a346a88fa54f1637a70" translate="yes" xml:space="preserve">
          <source>For example, suppose under the previous example, the memory footprints were</source>
          <target state="translated">例如,假设在前面的例子中,内存脚印为</target>
        </trans-unit>
        <trans-unit id="05d893596622d4a80e535a21a12a1aee563b93bd" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a document that starts out:</source>
          <target state="translated">例如,假设你有一个文档,开头是:。</target>
        </trans-unit>
        <trans-unit id="bffbbe302261255488cedcaf66d413bfbf36c6ca" translate="yes" xml:space="preserve">
          <source>For example, the</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="15b6b18c244e053f8f3ff342944215804ef30809" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;redundant&lt;/code&gt; category of warnings was introduced in Perl-5.22. This warning flags certain instances of superfluous arguments to &lt;code&gt;printf&lt;/code&gt; and &lt;code&gt;sprintf&lt;/code&gt;. But if your code was running warnings-free on earlier versions of</source>
          <target state="translated">例如，Perl-5.22中引入了 &lt;code&gt;redundant&lt;/code&gt; 的警告类别。该警告标志了 &lt;code&gt;printf&lt;/code&gt; 和 &lt;code&gt;sprintf&lt;/code&gt; 多余参数的某些实例。但是，如果您的代码在早期版本的</target>
        </trans-unit>
        <trans-unit id="f5d6ac4af7dc4fb8891b91e976475ba9ad84c4ec" translate="yes" xml:space="preserve">
          <source>For example, the basic Perl does not have any of the DB libraries (db, dbm, ndbm, gdsm). You can add these using iPKGui, however, you need to set environment variable LD_LIBRARY_PATH to the appropriate value:</source>
          <target state="translated">例如,基本的Perl没有任何的DB库(db、dbm、ndbm、gdsm),你可以用iPKGui添加这些库,但是你需要设置环境变量LD_LIBRARY_PATH为适当的值。你可以使用iPKGui来添加这些库,但是,你需要将环境变量LD_LIBRARY_PATH设置为合适的值。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
