<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="eae6ee7e119fbc5f2aa2be859ce356e5505eb961" translate="yes" xml:space="preserve">
          <source>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; would block. This can be avoided if you always use O_NONBLOCK on the socket. See select(2) and fcntl(2) for further details.</source>
          <target state="translated">在某些Unix上，即使没有可用数据，select（2）也会将套接字文件描述符报告为&amp;ldquo;准备读取&amp;rdquo;，因此任何后续 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 都会阻塞。如果始终在套接字上使用O_NONBLOCK，则可以避免这种情况。有关更多详细信息，请参见select（2）和fcntl（2）。</target>
        </trans-unit>
        <trans-unit id="c9de2fe586a63b0f77cf89fdbb109c06623eb1f4" translate="yes" xml:space="preserve">
          <source>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; would block. This can be avoided if you always use O_NONBLOCK on the socket. See select(2) and fcntl(2) for further details.</source>
          <target state="translated">在某些Unix上，即使没有可用数据，select（2）也会将套接字文件描述符报告为&amp;ldquo;准备读取&amp;rdquo;，因此任何后续 &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 都会阻塞。如果始终在套接字上使用O_NONBLOCK，则可以避免这种情况。有关更多详细信息，请参见select（2）和fcntl（2）。</target>
        </trans-unit>
        <trans-unit id="5ae4b16cd5d25f3c3c80ae711072c40499b4bc55" translate="yes" xml:space="preserve">
          <source>On some older systems, it may sleep up to a full second less than what you requested, depending on how it counts seconds. Most modern systems always sleep the full amount. They may appear to sleep longer than that, however, because your process might not be scheduled right away in a busy multitasking system.</source>
          <target state="translated">在一些旧系统上,它可能会比你要求的睡眠时间少一整秒,这取决于它如何计算秒数。大多数现代系统总是全量睡眠。然而,它们可能会出现比这个时间更长的睡眠时间,因为在一个繁忙的多任务系统中,你的进程可能不会立即被安排。</target>
        </trans-unit>
        <trans-unit id="558bd651fa8715821f75a4be7598cfc24234462e" translate="yes" xml:space="preserve">
          <source>On some operating systems certain signal handlers are supposed to &quot;do something&quot; before returning. One example can be CHLD or CLD, which indicates a child process has completed. On some operating systems the signal handler is expected to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; for the completed child process. On such systems the deferred signal scheme will not work for those signals: it does not do the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;. Again the failure will look like a loop as the operating system will reissue the signal because there are completed child processes that have not yet been &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;ed for.</source>
          <target state="translated">在某些操作系统上，某些信号处理程序应该在返回之前先&amp;ldquo;做某事&amp;rdquo;。一个示例可以是CHLD或CLD，它指示子进程已完成。在某些操作系统上，信号处理程序应 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 完成的子进程。在此类系统上，延迟信号方案将不适用于那些信号：它不会 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 。再次，该故障看起来像是一个循环，因为操作系统将重新发出该信号，因为尚未 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 完整的子进程。</target>
        </trans-unit>
        <trans-unit id="b286c0e46361b954aaba8f772a4a53334de3bd4e" translate="yes" xml:space="preserve">
          <source>On some operating systems such as Win32 installation may not be possible until after a reboot has occurred. This can have varying consequences: removing an old DLL does not impact programs using the new one, but if a new DLL cannot be installed properly until reboot then anything depending on it must wait. The package variable</source>
          <target state="translated">在某些操作系统上,如Win32,可能要等到重启后才能安装。这可能会产生不同的后果:删除一个旧的DLL不会影响使用新DLL的程序,但是如果一个新的DLL在重启之前无法正常安装,那么任何依赖它的程序都必须等待。软件包变量</target>
        </trans-unit>
        <trans-unit id="abbe82684e199993d30da7c411dda78b8ffa5204" translate="yes" xml:space="preserve">
          <source>On some operating systems, notably Solaris and Unixware, calling &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; from a child process will flush and close open filehandles in the parent, thereby corrupting the filehandles. On these systems, calling &lt;code&gt;_exit()&lt;/code&gt; is suggested instead. &lt;code&gt;_exit()&lt;/code&gt; is available in Perl through the &lt;code&gt;POSIX&lt;/code&gt; module. Please consult your system's manpages for more information on this.</source>
          <target state="translated">在某些操作系统上，尤其是Solaris和Unixware，从子进程调用 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 将刷新并关闭父进程中打开的文件句柄，从而损坏文件句柄。在这些系统上，建议改为调用 &lt;code&gt;_exit()&lt;/code&gt; 。 &lt;code&gt;_exit()&lt;/code&gt; 可通过 &lt;code&gt;POSIX&lt;/code&gt; 模块在Perl中使用。请参考系统的手册页以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="e360f8c5bbe5608f4331396810f247c8a100f0a1" translate="yes" xml:space="preserve">
          <source>On some platforms (notably DOS-like ones), the shell may not be capable of dealing with multiline commands, so putting newlines in the string may not get you what you want. You may be able to evaluate multiple commands in a single line by separating them with the command separator character, if your shell supports that (for example, &lt;code&gt;;&lt;/code&gt; on many Unix shells and &lt;code&gt;&amp;amp;&lt;/code&gt; on the Windows NT &lt;code&gt;cmd&lt;/code&gt; shell).</source>
          <target state="translated">在某些平台（尤其是类似DOS的平台）上，shell可能无法处理多行命令，因此在字符串中添加换行符可能无法获得所需的内容。您可以通过将其与命令分隔符分隔，以评估在一行多个命令，如果你的shell支持该（例如 &lt;code&gt;;&lt;/code&gt; 在许多Unix外壳，并 &lt;code&gt;&amp;amp;&lt;/code&gt; 在Windows NT &lt;code&gt;cmd&lt;/code&gt; 外壳）。</target>
        </trans-unit>
        <trans-unit id="b7498bd2534b138ca9192ebcb30213ef70ed5c94" translate="yes" xml:space="preserve">
          <source>On some platforms Perl supports retrieving the C level backtrace (similar to what symbolic debuggers like gdb do).</source>
          <target state="translated">在某些平台上,Perl 支持检索 C 级回溯(类似于 gdb 等符号调试器的工作)。</target>
        </trans-unit>
        <trans-unit id="a9e0966de849860f2089841e81ee24c757771be3" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the fork() system call is not available, Perl can be built to emulate fork() at the interpreter level. This emulation has limitations related to kill that have to be considered, for code running on Windows and in code intended to be portable.</source>
          <target state="translated">在某些平台上,比如Windows,系统调用fork()是不可用的,Perl可以在解释器层模拟fork()。对于在 Windows 上运行的代码和旨在可移植的代码,这种模拟有与 kill 有关的限制,必须加以考虑。</target>
        </trans-unit>
        <trans-unit id="4dca8272040520711e1d36a027c5a86ea7b32ae2" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the fork() system call is not available, Perl can be built to emulate fork() at the interpreter level. While the emulation is designed to be as compatible as possible with the real fork() at the level of the Perl program, there are certain important differences that stem from the fact that all the pseudo child &quot;processes&quot; created this way live in the same real process as far as the operating system is concerned.</source>
          <target state="translated">在某些平台上,比如Windows,系统调用fork()是不可用的,Perl可以在解释器级别上模拟fork()。虽然这种模拟被设计成在Perl程序级别上尽可能地与真正的fork()兼容,但是由于所有以这种方式创建的伪子 &quot;进程 &quot;就操作系统而言都生活在同一个真正的进程中,因此存在着某些重要的差异。</target>
        </trans-unit>
        <trans-unit id="c6a78bf511c92cd39ee02c1151b5e571d5127a45" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the fork() system call is not available, Perl can be built to emulate fork() in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; fork(). However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;../perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">在某些平台（例如Windows）上，其中fork（）系统调用不可用，可以构建Perl以在Perl解释器中模拟fork（）。在Perl程序级别，该仿真被设计为与&amp;ldquo; Unix&amp;rdquo; fork（）尽可能兼容。但是，它具有局限性，在旨在移植的代码中必须考虑这些限制。有关更多详细信息，请参见&lt;a href=&quot;../perlfork&quot;&gt;perlfork&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27073e810409a02dd0f24c371c3bfbfa303200d5" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the fork() system call is not available, Perl can be built to emulate fork() in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; fork(). However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">在某些平台（例如Windows）上，其中fork（）系统调用不可用，可以构建Perl以在Perl解释器中模拟fork（）。在Perl程序级别，该仿真被设计为与&amp;ldquo; Unix&amp;rdquo; fork（）尽可能兼容。但是，它具有局限性，在旨在移植的代码中必须考虑这些限制。有关更多详细信息，请参见&lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ed99749e4754bfa5b0b973c5aff98a5ab4786e4" translate="yes" xml:space="preserve">
          <source>On some platforms the thread-safe library interfaces may fail if the result buffer is too small (for example the user group databases may be rather large, and the reentrant interfaces may have to carry around a full snapshot of those databases). Perl will start with a small buffer, but keep retrying and growing the result buffer until the result fits. If this limitless growing sounds bad for security or memory consumption reasons you can recompile Perl with &lt;code&gt;PERL_REENTRANT_MAXSIZE&lt;/code&gt; defined to the maximum number of bytes you will allow.</source>
          <target state="translated">在某些平台上，如果结果缓冲区太小（例如，用户组数据库可能很大，并且可重入接口可能必须携带这些数据库的完整快照），则线程安全库接口可能会失败。Perl将以一个小的缓冲区开始，但是会继续重试并增加结果缓冲区，直到结果适合为止。如果出于安全性或内存消耗的原因，这种无限增长听起来很糟糕，则可以将 &lt;code&gt;PERL_REENTRANT_MAXSIZE&lt;/code&gt; 定义为允许的最大字节数，重新编译Perl 。</target>
        </trans-unit>
        <trans-unit id="79a433ae6e8abc1654ff92b55b4f90deb9b64777" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;savesharedpv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例如，在某些平台上，Windows会在线程结束时释放该线程拥有的所有已分配内存。因此，如果您不希望发生这种情况，则需要使用共享内存功能，例如 &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;savesharedpv&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a5fee577d9d0e5cea7ff481ecfa7871d14cc642" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;savesharedpvn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例如，在某些平台上，Windows会在线程结束时释放该线程拥有的所有已分配内存。因此，如果您不希望发生这种情况，则需要使用共享内存功能，例如 &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;savesharedpvn&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96135c965e974cf2dcbb35a5a0a72331dbb017cf" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;savesharedsvpv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例如，在某些平台上，Windows会在线程结束时释放该线程拥有的所有已分配内存。因此，如果您不希望发生这种情况，则需要使用共享内存功能，例如 &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;savesharedsvpv&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a47d30d42c677c2e62622d2c25ff6400601837c5" translate="yes" xml:space="preserve">
          <source>On some platforms, for example Windows NT, it is not possible to unlink an open file (the file must be closed first). On those platforms, the actual unlinking is deferred until the program ends and good status is returned. A check is still performed to make sure that the filehandle and filename are pointing to the same thing (but not at the time the end block is executed since the deferred removal may not have access to the filehandle).</source>
          <target state="translated">在某些平台上,例如Windows NT,不可能解除一个打开的文件的链接(必须先关闭该文件)。在这些平台上,实际的解链会被推迟到程序结束并返回良好状态时进行。仍然会进行检查,以确保文件柄和文件名指向同一个东西(但不是在执行结束块时,因为延迟删除可能无法访问文件柄)。</target>
        </trans-unit>
        <trans-unit id="9e21af4bec3442feba775d62193829f8b7a0c4e5" translate="yes" xml:space="preserve">
          <source>On some platforms, it might not be possible to destroy</source>
          <target state="translated">在某些平台上,可能无法销毁。</target>
        </trans-unit>
        <trans-unit id="b340b3bd6640d116c671c5bca7f5a658b943c207" translate="yes" xml:space="preserve">
          <source>On some platforms, this also makes Perl append suffixes to the filename while searching for it. For example, on Win32 platforms, the &quot;.bat&quot; and &quot;.cmd&quot; suffixes are appended if a lookup for the original name fails, and if the name does not already end in one of those suffixes. If your Perl was compiled with &lt;code&gt;DEBUGGING&lt;/code&gt; turned on, using the &lt;b&gt;-Dp&lt;/b&gt; switch to Perl shows how the search progresses.</source>
          <target state="translated">在某些平台上，这还使Perl在搜索文件名时将后缀附加到文件名。例如，在Win32平台上，如果对原始名称的查找失败，并且名称尚未以这些后缀之一结尾，则会附加&amp;ldquo; .bat&amp;rdquo;和&amp;ldquo; .cmd&amp;rdquo;后缀。如果您的Perl是在打开 &lt;code&gt;DEBUGGING&lt;/code&gt; 的情况下编译的，则使用&lt;b&gt;-Dp&lt;/b&gt;切换到Perl将显示搜索的进度。</target>
        </trans-unit>
        <trans-unit id="e74540fb7a91002e20c8eda026f9bf8b28624a25" translate="yes" xml:space="preserve">
          <source>On some systems (in general, DOS- and Windows-based systems) binmode() is necessary when you're not working with a text file. For the sake of portability it is a good idea always to use it when appropriate, and never to use it when it isn't appropriate. Also, people can set their I/O to be by default UTF8-encoded Unicode, not bytes.</source>
          <target state="translated">在某些系统上 (一般来说,基于 DOS 和 Windows 的系统)binmode()是必要的,当你不是在处理一个文本文件。为了便于移植,最好总是在合适的时候使用它,而在不合适的时候千万不要使用它。另外,大家可以将自己的I/O默认设置为UTF8编码的Unicode,而不是字节。</target>
        </trans-unit>
        <trans-unit id="bae1ed91e60744c25391f2c5a28e8865cb837e1c" translate="yes" xml:space="preserve">
          <source>On some systems, for an IO::Socket object created with new_from_fd(), or created with accept() from such an object, the protocol(), sockdomain() and socktype() methods may return undef.</source>
          <target state="translated">在某些系统中,对于用new_from_fd()创建的IO::Socket对象,或者用accept()从这样的对象中创建的IO::Socket对象,protocol()、sockdomain()和socktype()方法可能返回undef。</target>
        </trans-unit>
        <trans-unit id="5cb77e1072ab2963baa8f6d218988c1f72414bff" translate="yes" xml:space="preserve">
          <source>On some systems, the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's &lt;code&gt;strftime()&lt;/code&gt; function has been extended in a non-standard way to use a &lt;code&gt;%C&lt;/code&gt; format, which they sometimes claim is the &quot;century&quot;. It isn't, because on most such systems, this is only the first two digits of the four-digit year, and thus cannot be used to determine reliably the current century or millennium.</source>
          <target state="translated">在某些系统上，&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块的 &lt;code&gt;strftime()&lt;/code&gt; 函数已以非标准方式扩展为使用 &lt;code&gt;%C&lt;/code&gt; 格式，他们有时称这种格式为&amp;ldquo;世纪&amp;rdquo;。并非如此，因为在大多数此类系统上，这仅是四位数年份的前两位数字，因此无法可靠地确定当前世纪或千年。</target>
        </trans-unit>
        <trans-unit id="9a2307b9852232321e1093b21cd83d1ba46b51a6" translate="yes" xml:space="preserve">
          <source>On some systems, there can be cooperative and preemptive threads running simultaneously. (Threads running with realtime priorities often behave cooperatively, for example, while threads running at normal priorities behave preemptively.)</source>
          <target state="translated">在某些系统中,可以同时运行合作线程和抢先线程。例如,以实时优先级运行的线程通常表现为合作性,而以正常优先级运行的线程则表现为先发制人)。</target>
        </trans-unit>
        <trans-unit id="14dcaed53f17e703b8cfce8077083c7079226d84" translate="yes" xml:space="preserve">
          <source>On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">在某些系统中,您可能需要将单引号改为双引号,这时您必须</target>
        </trans-unit>
        <trans-unit id="a73b71b53a0ef6fd5b9c990fee1a5a53d7f99a60" translate="yes" xml:space="preserve">
          <source>On success in a list context, an array of 3 elements is returned. The elements are:</source>
          <target state="translated">在列表上下文中成功后,将返回一个包含3个元素的数组。这些元素是:</target>
        </trans-unit>
        <trans-unit id="104cbe85a4799563175bc8875552e7ec3d9444ff" translate="yes" xml:space="preserve">
          <source>On success in a list context, an array of 6 elements is returned. The elements are:</source>
          <target state="translated">在列表上下文中成功后,将返回一个包含6个元素的数组。这些元素是:</target>
        </trans-unit>
        <trans-unit id="bb19677ff47ab7a0061dc31fa21208b0fdd0ce0e" translate="yes" xml:space="preserve">
          <source>On success, $decoder is an object that is documented in &lt;a href=&quot;encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. So you can now do this;</source>
          <target state="translated">成功时，$ decoder是一个在&lt;a href=&quot;encoding&quot;&gt;Encode :: Encoding中&lt;/a&gt;记录的对象。因此，您现在可以执行此操作；</target>
        </trans-unit>
        <trans-unit id="9ed1d2d6abe6133cffe9d52759b8403cf251f405" translate="yes" xml:space="preserve">
          <source>On success, the autodying form of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; returns the</source>
          <target state="translated">成功后， &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的自动染色形式将返回</target>
        </trans-unit>
        <trans-unit id="555bab907001ef6e8e0bb6e66b34e7245218e3f9" translate="yes" xml:space="preserve">
          <source>On systems that do not support the HIGH or MEDIUM safety levels (for example Win NT or OS/2) any attempt to change the level will be ignored. The decision to ignore rather than raise an exception allows portable programs to be written with high security in mind for the systems that can support this without those programs failing on systems where the extra tests are irrelevant.</source>
          <target state="translated">在不支持HIGH或MEDIUM安全级别的系统上(例如Win NT或OS/2),任何改变级别的尝试都将被忽略。忽略而不是提出异常的决定允许在编写可移植程序时考虑到可以支持的系统的高安全性,而不会让这些程序在额外测试不相关的系统上失败。</target>
        </trans-unit>
        <trans-unit id="0c0c64b8ddf70f7334be3908bef0a4e5be9026f3" translate="yes" xml:space="preserve">
          <source>On systems that don't have locales, this pragma will cause your operations to behave as if in the &quot;C&quot; locale; attempts to change the locale will fail.</source>
          <target state="translated">在没有locale的系统上,这个pragma会让你的操作表现得像在 &quot;C &quot;区一样;试图改变locale会失败。</target>
        </trans-unit>
        <trans-unit id="8a74a95b0c966e10aac8d77a4f0a3bf544781a21" translate="yes" xml:space="preserve">
          <source>On systems that have a grammar that indicates filenames, this ignores the $base filename. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">在有语法指示文件名的系统中,这将忽略$base文件名。否则,所有的路径组件都被认为是目录。</target>
        </trans-unit>
        <trans-unit id="1b51da93b22332f93d96c5b573c9ad75ab82f7bf" translate="yes" xml:space="preserve">
          <source>On systems that have a grammar that indicates filenames, this ignores the &lt;code&gt;$base&lt;/code&gt; filename as well. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">在具有指示文件名语法的系统上，这也会忽略 &lt;code&gt;$base&lt;/code&gt; 文件名。否则，所有路径组件均假定为目录。</target>
        </trans-unit>
        <trans-unit id="5314c4a5a0cc48c834a98edadeb967581bfc1cbf" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;s are</source>
          <target state="translated">在那些支持对文件的close-on-exec标志系统，该标志被设置对所有新开的文件描述符，其 &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; s为</target>
        </trans-unit>
        <trans-unit id="be056ae4f4d92fcc824ea5af426faa5948d961c7" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;s are</source>
          <target state="translated">在那些支持对文件的close-on-exec标志系统，该标志被设置对所有新开的文件描述符，其 &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; s为</target>
        </trans-unit>
        <trans-unit id="3fcf7eb3896f4c5961c6c4a30af97fd660da9d5d" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;code&gt;$^F&lt;/code&gt; . See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">在支持文件上执行关闭标志的系统上，将为新打开的文件描述符设置该标志，该标志由 &lt;code&gt;$^F&lt;/code&gt; 的值确定。见&lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$ ^ F在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c665037f5c6992c82bd182869050b43d00b7e424" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;code&gt;$^F&lt;/code&gt; . See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">在支持文件上执行关闭标志的系统上，将为新打开的文件描述符设置该标志，该标志由 &lt;code&gt;$^F&lt;/code&gt; 的值确定。见&lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$ ^ F在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a490a64d93357b4e803f1bde203444d3253ea771" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of $^F. See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">在支持文件上执行时关闭标志的系统上，将为新打开的文件描述符设置该标志，该标志由$ ^ F的值确定。见&lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$ ^ F在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8889b4502c97331fb6c0d71d79b94f89a2ce179" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of $^F. See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">在支持文件上执行时关闭标志的系统上，将为新打开的文件描述符设置该标志，该标志由$ ^ F的值确定。见&lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$ ^ F在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="901c01459d3ad6fdd533264983a881490e329c6b" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of $^F. See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">在支持文件上执行时关闭标志的系统上，将为新打开的文件描述符设置该标志，该标志由$ ^ F的值确定。见&lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$ ^ F在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4b0eeffda71eae98ca0b23d4d9a435052a31c58" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of $^F. See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">在支持文件上执行时关闭标志的系统上，将为新打开的文件描述符设置该标志，该标志由$ ^ F的值确定。见&lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$ ^ F在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0bcb70dd655374823428e8ecf318b875be23f0d" translate="yes" xml:space="preserve">
          <source>On systems that support a real flock(2), locks are inherited across fork() calls, whereas those that must resort to the more capricious fcntl(2) function lose their locks, making it seriously harder to write servers.</source>
          <target state="translated">在支持真正的flock(2)的系统上,锁是在fork()调用中继承的,而那些必须求助于更任性的fcntl(2)函数的系统则会失去锁,这使得服务器的编写变得严重困难。</target>
        </trans-unit>
        <trans-unit id="92426fd5bb12f295ba78cf2e855950f52eab1f1b" translate="yes" xml:space="preserve">
          <source>On systems that support fchdir(2), you may pass a filehandle or directory handle as the argument. On systems that don't support fchdir(2), passing handles raises an exception.</source>
          <target state="translated">在支持 fchdir(2)的系统中,可以传递一个 filehandle 或目录句柄作为参数。在不支持 fchdir(2)的系统中,传递句柄会引起异常。</target>
        </trans-unit>
        <trans-unit id="92172c92aed2c4eacbbf108b43a01fa41c1e7227" translate="yes" xml:space="preserve">
          <source>On systems that support fchmod(2), you may pass filehandles among the files. On systems that don't support fchmod(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">在支持fchmod(2)的系统中,你可以在文件中传递filehandles,在不支持fchmod(2)的系统中,传递filehandles会引起异常。在不支持fchmod(2)的系统上,传递文件柄会引起异常。Filehandles 必须以 globs 或 glob 引用的形式传递才能被识别;裸词被视为文件名。</target>
        </trans-unit>
        <trans-unit id="dc52e8f7e1c0866f647ccf5e1cd248ecabff8b5f" translate="yes" xml:space="preserve">
          <source>On systems that support fchown(2), you may pass filehandles among the files. On systems that don't support fchown(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">在支持 fchown(2)的系统中,你可以在文件之间传递 filehandles。在不支持 fchown(2)的系统中,传递文件柄会引起异常。Filehandles 必须以 globs 或 glob 引用的形式传递才能被识别;裸词被视为文件名。</target>
        </trans-unit>
        <trans-unit id="9d32f7bede11ac1c00998cc26b587f02c25e363b" translate="yes" xml:space="preserve">
          <source>On systems that support futimes(2), you may pass filehandles among the files. On systems that don't support futimes(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">在支持futimes(2)的系统中,可以在文件之间传递filehandles,在不支持futimes(2)的系统中,传递filehandles会引起异常。在不支持 futimes(2)的系统中,传递文件手柄会引发异常。Filehandles 必须以 globs 或 glob 引用的形式传递才能被识别;裸词被视为文件名。</target>
        </trans-unit>
        <trans-unit id="c71329e94ef821ac647632fa2fb53326dd2a9466" translate="yes" xml:space="preserve">
          <source>On systems that supported it, older versions of Perl used the SA_RESTART flag when installing %SIG handlers. This meant that restartable system calls would continue rather than returning when a signal arrived. In order to deliver deferred signals promptly, Perl 5.8.0 and later do</source>
          <target state="translated">在支持它的系统中,旧版本的Perl在安装%SIG处理程序时使用SA_RESTART标志。这意味着可重启的系统调用会继续,而不是在信号到达时返回。为了及时传递延迟信号,Perl 5.8.0及以后的版本会做</target>
        </trans-unit>
        <trans-unit id="6ba77bd32e9b25ffdeddd2abe71a6e9ea02320ab" translate="yes" xml:space="preserve">
          <source>On systems traditionally bereft of a usable &lt;b&gt;man&lt;/b&gt; command, the debugger invokes &lt;b&gt;perldoc&lt;/b&gt;. Occasionally this determination is incorrect due to recalcitrant vendors or rather more felicitously, to enterprising users. If you fall into either category, just manually set the $DB::doccmd variable to whatever viewer to view the Perl documentation on your system. This may be set in an rc file, or through direct assignment. We're still waiting for a working example of something along the lines of:</source>
          <target state="translated">在传统上缺少可用的&lt;b&gt;man&lt;/b&gt;命令的系统上，调试器调用&lt;b&gt;perldoc&lt;/b&gt;。有时候，这种决定是不正确的，这是由于顽强的销售商，或更确切地说，是进取的用户。如果您属于这两个类别，只需手动将$ DB :: doccmd变量设置为任何查看器，以查看系统上的Perl文档。这可以在rc文件中设置，也可以通过直接分配来设置。我们仍在等待以下方面的可行示例：</target>
        </trans-unit>
        <trans-unit id="495743307752ec1e7f711d11bd0bef034af0b675" translate="yes" xml:space="preserve">
          <source>On systems which do support negative epoch values, this module should be able to cope with dates before the start of the epoch, down the minimum value of time_t for the system.</source>
          <target state="translated">在支持负纪元值的系统上,这个模块应该能够处理纪元开始前的日期,以系统的最小值time_t为基准。</target>
        </trans-unit>
        <trans-unit id="46c423b9491070d51507de37df7f4e753a419998" translate="yes" xml:space="preserve">
          <source>On systems with restrictions on file name length, the file corresponding to a subroutine may have a shorter name that the routine itself. This can lead to conflicting file names. The</source>
          <target state="translated">在对文件名长度有限制的系统中,子程序对应的文件名可能比例程本身的名字要短。这可能导致文件名冲突。在</target>
        </trans-unit>
        <trans-unit id="fec43c22ce98f30270ab97bbbb4fe9d6075857b3" translate="yes" xml:space="preserve">
          <source>On systems with the concept of a network share (currently only Windows) returns the sharename from a &lt;a href=&quot;file://&quot;&gt;file:////&lt;/a&gt; url. On other operating systems returns empty.</source>
          <target state="translated">在具有网络共享概念的系统上（当前仅Windows）从&lt;a href=&quot;file://&quot;&gt;file：////&lt;/a&gt; url 返回共享名。在其他操作系统上，返回空。</target>
        </trans-unit>
        <trans-unit id="928cc7ef7cb478fdbb60e26c8543bd66bba1f884" translate="yes" xml:space="preserve">
          <source>On systems with the concept of volume, if &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$base&lt;/code&gt; appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return &lt;code&gt;$path&lt;/code&gt; . Note that previous versions of this module ignored the volume of &lt;code&gt;$base&lt;/code&gt; , which resulted in garbage results part of the time.</source>
          <target state="translated">在具有卷概念的系统上，如果 &lt;code&gt;$path&lt;/code&gt; 和 &lt;code&gt;$base&lt;/code&gt; 似乎位于两个不同的卷上，则我们将不尝试解析这两个路径，而只是返回 &lt;code&gt;$path&lt;/code&gt; 。请注意，此模块的先前版本忽略了 &lt;code&gt;$base&lt;/code&gt; 的数量，这部分时间导致了垃圾结果。</target>
        </trans-unit>
        <trans-unit id="04b62c831c8eef6cc7d4b1d7cdb6bf880f9b84f3" translate="yes" xml:space="preserve">
          <source>On text fields the caret enables a kind of fill mode. Instead of an arbitrary expression, the value supplied must be a scalar variable that contains a text string. Perl puts the next portion of the text into the field, and then chops off the front of the string so that the next time the variable is referenced, more of the text can be printed. (Yes, this means that the variable itself is altered during execution of the write() call, and is not restored.) The next portion of text is determined by a crude line-breaking algorithm. You may use the carriage return character (&lt;code&gt;\r&lt;/code&gt; ) to force a line break. You can change which characters are legal to break on by changing the variable &lt;code&gt;$:&lt;/code&gt; (that's $FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a list of the desired characters.</source>
          <target state="translated">在文本字段上，插入号启用一种填充模式。提供的值必须是包含文本字符串的标量变量，而不是任意表达式。Perl将文本的下一部分放入字段中，然后将字符串的前面切掉，以便下次引用该变量时，可以打印更多的文本。（是的，这意味着变量本身在执行write（）调用期间会更改，并且不会恢复。）文本的下一部分由粗略的换行算法确定。您可以使用回车符（ &lt;code&gt;\r&lt;/code&gt; ）强制换行。您可以通过更改变量 &lt;code&gt;$:&lt;/code&gt; 来更改哪些字符可合法使用： （如果您使用的是英语模块，则为$ FORMAT_LINE_BREAK_CHARACTERS）到所需字符的列表。</target>
        </trans-unit>
        <trans-unit id="c0193cc78fe98d1b4b454c6f69412908ead97760" translate="yes" xml:space="preserve">
          <source>On the AS/400, if PERL5 is in your library list, you may need to wrap your Perl scripts in a CL procedure to invoke them like so:</source>
          <target state="translated">在AS/400上,如果PERL5在你的库列表中,你可能需要把你的Perl脚本包在一个CL过程中来调用它们,就像这样。</target>
        </trans-unit>
        <trans-unit id="ea65f5f2a1cec2b70340514d27743f128cc959b6" translate="yes" xml:space="preserve">
          <source>On the given program identified by &lt;code&gt;program_name&lt;/code&gt; .</source>
          <target state="translated">在由 &lt;code&gt;program_name&lt;/code&gt; 标识的给定程序上。</target>
        </trans-unit>
        <trans-unit id="5c9fcecabc9c2ff5c185e1af9b86fe28cd4ccda1" translate="yes" xml:space="preserve">
          <source>On the mainframe Perl currently works under the &quot;Unix system services for OS/390&quot; (formerly known as OpenEdition), VM/ESA OpenEdition, or the BS200 POSIX-BC system (BS2000 is supported in Perl 5.6 and greater). See &lt;a href=&quot;perlos390&quot;&gt;perlos390&lt;/a&gt; for details. Note that for OS/400 there is also a port of Perl 5.8.1/5.10.0 or later to the PASE which is ASCII-based (as opposed to ILE which is EBCDIC-based), see &lt;a href=&quot;perlos400&quot;&gt;perlos400&lt;/a&gt;.</source>
          <target state="translated">在大型机上，Perl当前在&amp;ldquo;用于OS / 390的Unix系统服务&amp;rdquo;（以前称为OpenEdition），VM / ESA OpenEdition或BS200 POSIX-BC系统（在Perl 5.6和更高版本中支持BS2000）下工作。有关详细信息，请参见&lt;a href=&quot;perlos390&quot;&gt;perlos390&lt;/a&gt;。请注意，对于OS / 400，PASE还存在一个Perl 5.8.1 / 5.10.0或更高版本的端口，该端口是基于ASCII的（与基于EBCDIC的ILE相反），请参见&lt;a href=&quot;perlos400&quot;&gt;perlos400&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="580309d3af9907826e397d1c3342546e17a8ad3c" translate="yes" xml:space="preserve">
          <source>On the opposite end of the scale, a declaration like</source>
          <target state="translated">在天平的另一端,像这样的声明</target>
        </trans-unit>
        <trans-unit id="30429117a84b2dd407e0605edcb4b807f19cd366" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want the other meaning, you can do this:</source>
          <target state="translated">另一方面,如果你想要其他的意思,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="fbae3feec67f27fa104cf2845f242f528c54850f" translate="yes" xml:space="preserve">
          <source>On the other hand, if you were actually hoping to treat the array element as a list, you need to look into how references work, because Perl will not magically convert between scalars and lists for you. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">另一方面，如果您实际上希望将数组元素视为列表，则需要研究引用的工作方式，因为Perl不会为您在标量和列表之间神奇地转换。参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce76eb877363ead375654de95e60f5e7b6c574b5" translate="yes" xml:space="preserve">
          <source>On the other hand, if you were actually hoping to treat the hash element as a list, you need to look into how references work, because Perl will not magically convert between scalars and lists for you. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">另一方面，如果您实际上希望将hash元素视为列表，则需要研究引用的工作方式，因为Perl不会为您在标量和列表之间神奇地转换。参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="528cd15a9b0aff8a5cdc97823c4262e5cf5bb2ab" translate="yes" xml:space="preserve">
          <source>On the other hand, mixing various national standard encodings automagically works unless $data is too short to allow for guessing.</source>
          <target state="translated">另一方面,混合各种国标编码自动工作,除非$data太短,无法猜测。</target>
        </trans-unit>
        <trans-unit id="095e1a5231bfc256caf5b97c9e59036a8cd94e78" translate="yes" xml:space="preserve">
          <source>On the other hand, sometimes you want to clobber whatever might already be there. To empty out a file before you start writing to it, you can open it in write-only mode:</source>
          <target state="translated">另一方面,有时你会想把已经存在的东西打掉。为了在开始向文件写入之前清空文件,你可以用只写模式打开它。</target>
        </trans-unit>
        <trans-unit id="94024e45d5031c319fa3ba71f3df1c69292913dd" translate="yes" xml:space="preserve">
          <source>On the other hand:</source>
          <target state="translated">另一方面:</target>
        </trans-unit>
        <trans-unit id="f18fa46000a23ad2307a5bee120c399fc4cc324f" translate="yes" xml:space="preserve">
          <source>On the right side of a list operator, the comma has very low precedence, such that it controls all comma-separated expressions found there. The only operators with lower precedence are the logical operators &lt;code&gt;&quot;and&quot;&lt;/code&gt; , &lt;code&gt;&quot;or&quot;&lt;/code&gt; , and &lt;code&gt;&quot;not&quot;&lt;/code&gt; , which may be used to evaluate calls to list operators without the need for parentheses:</source>
          <target state="translated">在列表运算符的右侧，逗号的优先级非常低，因此它控制在那里找到的所有逗号分隔的表达式。唯一具有较低优先级的运算符是逻辑运算符 &lt;code&gt;&quot;and&quot;&lt;/code&gt; ， &lt;code&gt;&quot;or&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;not&quot;&lt;/code&gt; ，它们可以用于评估对列表运算符的调用，而无需括号：</target>
        </trans-unit>
        <trans-unit id="c0b2c5bcb8fba3a9644276ad63b66e732faef04f" translate="yes" xml:space="preserve">
          <source>On these platforms, bear in mind that the EBCDIC character set may have an effect on what happens with some Perl functions (such as &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;), as well as bit-fiddling with ASCII constants using operators like &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;, not to mention dealing with socket interfaces to ASCII computers (see &lt;a href=&quot;#Newlines&quot;&gt;Newlines&lt;/a&gt;).</source>
          <target state="translated">在这些平台上，请记住，EBCDIC字符集可能会对某些Perl函数（例如 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ）发生的影响以及对使用 &lt;code&gt;^&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;|&lt;/code&gt; 等运算符的ASCII常量，更不用说处理ASCII计算机的套接字接口了（请参阅&lt;a href=&quot;#Newlines&quot;&gt;Newlines&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bf1c918758fe737aef37e1c0ba64400f9f7705ae" translate="yes" xml:space="preserve">
          <source>On those platforms and compilers where &lt;code&gt;bool&lt;/code&gt; really is a boolean (C++, C99), it is easy to forget the cast. You can force &lt;code&gt;bool&lt;/code&gt; to be a &lt;code&gt;char&lt;/code&gt; by compiling with &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; . You may also wish to run &lt;code&gt;Configure&lt;/code&gt; with something like</source>
          <target state="translated">在 &lt;code&gt;bool&lt;/code&gt; 确实是布尔值（C ++，C99）的那些平台和编译器上，很容易忘记转换。通过使用 &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; 进行编译，可以强制 &lt;code&gt;bool&lt;/code&gt; 成为 &lt;code&gt;char&lt;/code&gt; 。您可能还希望运行 &lt;code&gt;Configure&lt;/code&gt; 的东西，如</target>
        </trans-unit>
        <trans-unit id="750180603d4fade1f60619d413443d4388791bcb" translate="yes" xml:space="preserve">
          <source>On threaded builds a regexp may need to be duplicated so that the pattern can be used by multiple threads. This routine is expected to handle the duplication of any private data pointed to by the &lt;code&gt;pprivate&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure. It will be called with the preconstructed new &lt;code&gt;regexp&lt;/code&gt; structure as an argument, the &lt;code&gt;pprivate&lt;/code&gt; member will point at the &lt;b&gt;old&lt;/b&gt; private structure, and it is this routine's responsibility to construct a copy and return a pointer to it (which Perl will then use to overwrite the field as passed to this routine.)</source>
          <target state="translated">在线程构建中，可能需要复制一个正则表达式，以便多个线程可以使用该模式。预期该例程将处理 &lt;code&gt;regexp&lt;/code&gt; 结构的 &lt;code&gt;pprivate&lt;/code&gt; 成员指向的所有私有数据的重复。将使用预先构造的新 &lt;code&gt;regexp&lt;/code&gt; 结构作为参数调用它， &lt;code&gt;pprivate&lt;/code&gt; 成员将指向&lt;b&gt;旧的&lt;/b&gt;私有结构，并且此例程负责构造一个副本并返回指向它的指针（然后，Perl将使用该指针来覆盖字段传递给此例程。）&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c8ce1f6dab9f2ca8a499735e7d64c50092c9a849" translate="yes" xml:space="preserve">
          <source>On unthreaded builds this field doesn't exist.</source>
          <target state="translated">在非线程构建中,这个字段并不存在。</target>
        </trans-unit>
        <trans-unit id="baf07ba18b50ccd1689ea2941fb77a3117773a24" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_out&lt;/code&gt; or &lt;code&gt;test_err&lt;/code&gt; (or &lt;code&gt;test_fail&lt;/code&gt; or &lt;code&gt;test_diag&lt;/code&gt; ) have been called, all further output from &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; will be captured by &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt;. This means that you will not be able perform further tests to the normal output in the normal way until you call &lt;code&gt;test_test&lt;/code&gt; (well, unless you manually meddle with the output filehandles)</source>
          <target state="translated">一旦 &lt;code&gt;test_out&lt;/code&gt; 或 &lt;code&gt;test_err&lt;/code&gt; （或 &lt;code&gt;test_fail&lt;/code&gt; 或 &lt;code&gt;test_diag&lt;/code&gt; ）一直呼吁，从所有进一步的输出&lt;a href=&quot;../builder&quot;&gt;测试::生成器&lt;/a&gt;将被捕获&lt;a href=&quot;tester&quot;&gt;的Test ::生成器::测试仪&lt;/a&gt;。这意味着您将无法以正常方式对正常输出执行进一步的测试，直到调用 &lt;code&gt;test_test&lt;/code&gt; （好吧，除非您手动插入输出文件句柄）</target>
        </trans-unit>
        <trans-unit id="9443afa365a30ff5f37332fa968121f2dbb81425" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_test&lt;/code&gt; has been run test output will be redirected back to the original filehandles that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; was connected to (probably STDOUT and STDERR,) meaning any further tests you run will function normally and cause success/errors for &lt;a href=&quot;../harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">一旦运行了 &lt;code&gt;test_test&lt;/code&gt; ,测试输出将被重定向回&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;所连接的原始文件句柄（可能是STDOUT和STDERR），这意味着您运行的任何其他测试都将正常运行并导致&lt;a href=&quot;../harness&quot;&gt;Test :: Harness的&lt;/a&gt;成功/错误。</target>
        </trans-unit>
        <trans-unit id="c0908b28a0f268394a7964fa489d2fda27d507a0" translate="yes" xml:space="preserve">
          <source>Once EOF is detected (&lt;code&gt;$status&lt;/code&gt; is zero) the filter will insert an extra line into the source stream. When this extra line is executed it will print a count of the number of substitutions actually made. Note that &lt;code&gt;$status&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in this case.</source>
          <target state="translated">一旦检测到EOF（ &lt;code&gt;$status&lt;/code&gt; 为零），过滤器就会在源流中插入一条额外的行。当执行此额外的行时，它将打印实际进行的替换次数的计数。请注意，在这种情况下， &lt;code&gt;$status&lt;/code&gt; 设置为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48f0ab6402e0ed10a074d92b2f594ddaae93f903" translate="yes" xml:space="preserve">
          <source>Once Perl sees that you need one of these variables anywhere in the program, it provides them on each and every pattern match. That means that on every pattern match the entire string will be copied, part of it to $`, part to $&amp;amp;, and part to $'. Thus the penalty is most severe with long strings and patterns that match often. Avoid $&amp;amp;, $', and $` if you can, but if you can't, once you've used them at all, use them at will because you've already paid the price. Remember that some algorithms really appreciate them. As of the 5.005 release, the $&amp;amp; variable is no longer &quot;expensive&quot; the way the other two are.</source>
          <target state="translated">一旦Perl在程序中的任何位置看到您需要这些变量之一，它就会在每个模式匹配项中提供它们。这意味着在每个模式匹配项上，整个字符串都将被复制，一部分复制到$`，一部分复制到$＆，部分复制到$'。因此，对于经常匹配的长字符串和模式，惩罚是最严重的。如果可以，请避免使用$＆，$'和$`，但如果不能使用，则一旦使用它们，请立即使用它们，因为您已经支付了价格。请记住，有些算法真的很欣赏它们。从5.005版本开始，$＆变量不再像其他两个变量那样&amp;ldquo;昂贵&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="296ec9cb13f85c2f6eee6c3dfe23452785f51838" translate="yes" xml:space="preserve">
          <source>Once a feature, construct or module has been marked as deprecated, we may remove it from the Perl core. Unsurprisingly, we say we've &lt;b&gt;removed&lt;/b&gt; these things. When a module is removed, it will no longer ship with Perl, but will continue to be available on CPAN.</source>
          <target state="translated">将功能，构造或模块标记为不赞成使用后，我们可以将其从Perl核心中删除。毫不奇怪，我们说我们已经&lt;b&gt;删除了&lt;/b&gt;这些东西。卸下模块后，它将不再与Perl一起提供，但将继续在CPAN上可用。</target>
        </trans-unit>
        <trans-unit id="7394cfde1fc1b93e93cb9b4f086c54f1b9ffd59b" translate="yes" xml:space="preserve">
          <source>Once a module has been included in the Perl core, however, everyone involved in maintaining Perl should be aware that the module is still the property of the original author unless the original author explicitly gives up their ownership of it. In particular:</source>
          <target state="translated">然而,一旦一个模块被包含在Perl核心中,每一个参与维护Perl的人都应该意识到,该模块仍然是原作者的财产,除非原作者明确放弃对它的所有权。尤其是:</target>
        </trans-unit>
        <trans-unit id="395a04379c153d488a5c8556f8b5ec9aaac6c9a5" translate="yes" xml:space="preserve">
          <source>Once a referent has been blessed, the &lt;code&gt;blessed&lt;/code&gt; function from the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; core module can tell us its class name. This subroutine returns an object's class when passed an object, and false otherwise.</source>
          <target state="translated">引用对象获得祝福后，来自&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;核心模块的 &lt;code&gt;blessed&lt;/code&gt; 功能便可以告诉我们其类名。传递给对象时，此子例程返回对象的类，否则返回false。</target>
        </trans-unit>
        <trans-unit id="591c19dc13259933f77d04158c9b97cb405eddcb" translate="yes" xml:space="preserve">
          <source>Once a thread is detached, it may not be joined, and any return data that it might have produced (if it was done and waiting for a join) is lost.</source>
          <target state="translated">一旦一个线程脱离,它可能不会被加入,它可能产生的任何返回数据(如果它已经完成并等待加入)都会丢失。</target>
        </trans-unit>
        <trans-unit id="12df76345c558476956303e6bd354373a1af6336" translate="yes" xml:space="preserve">
          <source>Once a todo test starts succeeding, simply move it outside the block. When the block is empty, delete it.</source>
          <target state="translated">一旦一个todo测试开始成功,只需将其移到块外即可。当区块为空时,将其删除。</target>
        </trans-unit>
        <trans-unit id="de1c57e84d4335aa8d593dcd913db4541c9be506" translate="yes" xml:space="preserve">
          <source>Once a variable is removed, its use triggers an error telling you the variable is unsupported.</source>
          <target state="translated">一旦一个变量被删除,它的使用就会触发一个错误,告诉你这个变量是不支持的。</target>
        </trans-unit>
        <trans-unit id="aeba7900e971ad3f9f9e894e67cc3b717aab109e" translate="yes" xml:space="preserve">
          <source>Once again, &lt;code&gt;module-starter&lt;/code&gt; or &lt;code&gt;h2xs&lt;/code&gt; has done all the work for you. They produce the standard &lt;code&gt;Makefile.PL&lt;/code&gt; you see when you download and install modules, and this produces a Makefile with a &lt;code&gt;dist&lt;/code&gt; target.</source>
          <target state="translated">再次， &lt;code&gt;module-starter&lt;/code&gt; 或 &lt;code&gt;h2xs&lt;/code&gt; 为您完成了所有工作。它们生成标准的 &lt;code&gt;Makefile.PL&lt;/code&gt; ,您在下载和安装模块时会看到它们，这将生成带有 &lt;code&gt;dist&lt;/code&gt; 目标的Makefile 。</target>
        </trans-unit>
        <trans-unit id="8b1aff24b00940dd82d1491dbe39c6cb52b648ed" translate="yes" xml:space="preserve">
          <source>Once approved, changes are merged into &lt;a href=&quot;https://github.com/tpf/perlfaq&quot;&gt;https://github.com/tpf/perlfaq&lt;/a&gt;, the repository which drives &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;, and they are distributed with the next Perl 5 release.</source>
          <target state="translated">批准后，更改将合并到&lt;a href=&quot;https://github.com/tpf/perlfaq&quot;&gt;https://github.com/tpf/perlfaq&lt;/a&gt;（驱动&lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;的存储库）中，并随下一个Perl 5版本一起分发。</target>
        </trans-unit>
        <trans-unit id="2b54e888aa5f3b1e9daaa58b06235556e830e504" translate="yes" xml:space="preserve">
          <source>Once at the command line, type &lt;code&gt;h&lt;/code&gt; for one-page help screen; the rest should be self-explanatory.</source>
          <target state="translated">在命令行中，输入 &lt;code&gt;h&lt;/code&gt; 进入一页帮助屏幕；其余的应该不言自明。</target>
        </trans-unit>
        <trans-unit id="480a6fac81e70daea3f924bcfe32eba60a95619a" translate="yes" xml:space="preserve">
          <source>Once called the FILE * should</source>
          <target state="translated">一旦调用FILE *,应</target>
        </trans-unit>
        <trans-unit id="fadbaf9125427892864d707c6d22361430d22b8f" translate="yes" xml:space="preserve">
          <source>Once ended, no more items may be placed in the queue.</source>
          <target state="translated">一旦结束,不得再将任何物品放入队列中。</target>
        </trans-unit>
        <trans-unit id="916fa7b57196ffe55f0094ed9d80bbb62daf5b2c" translate="yes" xml:space="preserve">
          <source>Once mapped, you can treat &lt;code&gt;$string&lt;/code&gt; as you would any other string. Since you don't necessarily have to load the data, mmap-ing can be very fast and may not increase your memory footprint.</source>
          <target state="translated">映射后，您可以像对待任何其他字符串一样对待 &lt;code&gt;$string&lt;/code&gt; string。由于不必加载数据，因此映射速度非常快，并且可能不会增加内存占用。</target>
        </trans-unit>
        <trans-unit id="48df5812892e79e577960bece1b7fde5e79ea047" translate="yes" xml:space="preserve">
          <source>Once miniperl.exe creation is over, run nmake from the NetWare folder. This will build the Perl interpreter for NetWare as</source>
          <target state="translated">创建 miniperl.exe 后,从 NetWare 文件夹中运行 nmake。这将为 NetWare 创建一个 Perl 解释器,名为</target>
        </trans-unit>
        <trans-unit id="f6c4f57a7ab5a360e46162416f69b58e4d7acd9a" translate="yes" xml:space="preserve">
          <source>Once picked, it is important to stick to your version scheme, without reducing the number of digits. This is because &quot;downstream&quot; packagers, such as the FreeBSD ports system, interpret the version numbers in various ways. If you change the number of digits in your version scheme, you can confuse these systems so they get the versions of your module out of order, which is obviously bad.</source>
          <target state="translated">一旦选择了版本号,重要的是要坚持您的版本方案,而不要减少数字的数量。这是因为 &quot;下游 &quot;的打包程序,例如 FreeBSD ports 系统,会以不同的方式解释版本号。如果您改变了版本方案中的数字,就会使这些系统感到困惑,从而使它们对您的模块的版本不按顺序排列,这显然是不好的。</target>
        </trans-unit>
        <trans-unit id="07633063ecd66c0146fe9d11656fc4703df1f61f" translate="yes" xml:space="preserve">
          <source>Once produced Makefiles for MacOS Classic</source>
          <target state="translated">曾经制作过MacOS Classic的Makefiles</target>
        </trans-unit>
        <trans-unit id="654d50c5d753e55a4e1dbf0b00907d7f4969d3a9" translate="yes" xml:space="preserve">
          <source>Once registered, there is no mechanism to switch these hooks off, so if that is necessary you will need to do this yourself. An entry in &lt;code&gt;%^H&lt;/code&gt; is probably the best way, so the effect is lexically scoped; however it is also possible to use the &lt;code&gt;BhkDISABLE&lt;/code&gt; and &lt;code&gt;BhkENABLE&lt;/code&gt; macros to temporarily switch entries on and off. You should also be aware that generally speaking at least one scope will have opened before your extension is loaded, so you will see some &lt;code&gt;pre/post_end&lt;/code&gt; pairs that didn't have a matching &lt;code&gt;start&lt;/code&gt; .</source>
          <target state="translated">一旦注册，就没有关闭这些挂钩的机制，因此，如果有必要，您将需要自己执行此操作。 &lt;code&gt;%^H&lt;/code&gt; 的条目可能是最好的方法，因此效果在词法范围内；但是，也可以使用 &lt;code&gt;BhkDISABLE&lt;/code&gt; 和 &lt;code&gt;BhkENABLE&lt;/code&gt; 宏来临时打开和关闭条目。您还应该知道，通常来讲，在加载扩展之前至少会打开一个作用域，因此您会看到一些没有匹配的 &lt;code&gt;start&lt;/code&gt; 的 &lt;code&gt;pre/post_end&lt;/code&gt; 对。</target>
        </trans-unit>
        <trans-unit id="bbf6b188e1d6cda2b1c31b9f2ea910f75bac5ce6" translate="yes" xml:space="preserve">
          <source>Once the 'aaab' at the start of the string has matched, and the &lt;code&gt;(*SKIP)&lt;/code&gt; executed, the next starting point will be where the cursor was when the &lt;code&gt;(*SKIP)&lt;/code&gt; was executed.</source>
          <target state="translated">一旦字符串开头的'aaab'匹配并且执行了 &lt;code&gt;(*SKIP)&lt;/code&gt; ，下一个起始点将是执行 &lt;code&gt;(*SKIP)&lt;/code&gt; 时光标所在的位置。</target>
        </trans-unit>
        <trans-unit id="8672a62497c5f795c9c2acf9e29afcdfcf0e6269" translate="yes" xml:space="preserve">
          <source>Once the AV has been created, the following operations are possible on it:</source>
          <target state="translated">一旦创建了AV,就可以对其进行以下操作。</target>
        </trans-unit>
        <trans-unit id="67df8d841097b17fc29c0a4ea72cc77f4ff9a4eb" translate="yes" xml:space="preserve">
          <source>Once the HV has been created, the following operations are possible on it:</source>
          <target state="translated">一旦创建了 HV,就可以对其进行以下操作。</target>
        </trans-unit>
        <trans-unit id="57df9a521b252465d2cd33284b38479df5df9b79" translate="yes" xml:space="preserve">
          <source>Once the filtering has been applied, the original strings, regexes, POD, etc. are re-inserted into the code, by replacing each placeholder with the corresponding original component (from &lt;code&gt;@components&lt;/code&gt; ). Note that this means that the &lt;code&gt;@components&lt;/code&gt; variable must be treated with extreme care within the filter. The &lt;code&gt;@components&lt;/code&gt; array stores the &quot;back- translations&quot; of each placeholder inserted into &lt;code&gt;$_&lt;/code&gt; , as well as the interstitial source code between placeholders. If the placeholder backtranslations are altered in &lt;code&gt;@components&lt;/code&gt; , they will be similarly changed when the placeholders are removed from &lt;code&gt;$_&lt;/code&gt; after the filter is complete.</source>
          <target state="translated">一旦应用了过滤，通过将每个占位符替换为相应的原始组件（来自 &lt;code&gt;@components&lt;/code&gt; ），可以将原始字符串，正则表达式，POD等重新插入到代码中。请注意，这意味着 &lt;code&gt;@components&lt;/code&gt; 变量必须在过滤器内格外小心。所述 &lt;code&gt;@components&lt;/code&gt; 阵列存储&amp;ldquo;背翻译&amp;rdquo;每一个占位符插入到 &lt;code&gt;$_&lt;/code&gt; ，以及用作占位符之间的间隙的源代码。如果在 &lt;code&gt;@components&lt;/code&gt; 中更改了占位符的反向翻译，则在完成过滤器后从 &lt;code&gt;$_&lt;/code&gt; 中删除占位符时，也会类似地更改它们。</target>
        </trans-unit>
        <trans-unit id="4bda05c922f6c0e7108b9b6664cf70b280c74345" translate="yes" xml:space="preserve">
          <source>Once the first line has been processed, the flow will look like this:</source>
          <target state="translated">一旦第一行处理完毕,流程将是这样的。</target>
        </trans-unit>
        <trans-unit id="2abcd9048b9f7de01dd766ea3b827a4a4ca6e4d7" translate="yes" xml:space="preserve">
          <source>Once the generic server socket has been created using the parameters listed above, the server then waits for a new client to connect to it. The server blocks in the &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; method, which eventually accepts a bidirectional connection from the remote client. (Make sure to autoflush this handle to circumvent buffering.)</source>
          <target state="translated">使用上述参数创建通用服务器套接字后，服务器将等待新的客户端连接到该套接字。服务器阻塞了 &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; 方法，该方法最终接受来自远程客户端的双向连接。（确保自动刷新此句柄以避开缓冲。）</target>
        </trans-unit>
        <trans-unit id="3ee769afc72db89229ffb2a909f356b2b29d26cc" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the exit status. If the parser ran an executable, it returns the exit status of the executable.</source>
          <target state="translated">一旦解析器完成,将返回退出状态。如果解析器运行了一个可执行文件,它将返回该可执行文件的退出状态。</target>
        </trans-unit>
        <trans-unit id="4d1cfe61310d7995317dabd0218a153aefb9089c" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the version number for the parsed TAP. Version numbers were introduced with TAP version 13 so if no version number is found version 12 is assumed.</source>
          <target state="translated">一旦解析器完成,将返回解析后的TAP的版本号。版本号是在TAP版本13中引入的,所以如果没有找到版本号,则假定为版本12。</target>
        </trans-unit>
        <trans-unit id="295310f03609b1e9bcb5a3f97bee3cf209b7fdc9" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the wait status. If the parser ran an executable, it returns the wait status of the executable. Otherwise, this merely returns the &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; status.</source>
          <target state="translated">解析器完成后，将返回等待状态。如果解析器运行了可执行文件，它将返回可执行文件的等待状态。否则，这仅返回 &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="e563448cf76902cc1f89b5320bc98d51a6a5d5a8" translate="yes" xml:space="preserve">
          <source>Once the prefix an dthe outermost opening delimiter bracket have been recognized, code blocks are extracted by stepping through the input text and trying the following alternatives in sequence:</source>
          <target state="translated">一旦前缀和最外侧的分隔符括号被识别出来,代码块就会被提取出来,方法是对输入文本进行步进,并依次尝试以下选项。</target>
        </trans-unit>
        <trans-unit id="c16b3faffb99d8d54125fd9ac6e0e713e87e3953" translate="yes" xml:space="preserve">
          <source>Once the program is otherwise done, and once its localization for the first language works right (via the data and methods in Projname::L10N::en_us), you can get together the data for translation. If your first language lexicon isn't an _AUTO lexicon, then you already have all the messages explicitly in the lexicon (or else you'd be getting exceptions thrown when you call $lh-&amp;gt;maketext to get messages that aren't in there). But if you were (advisedly) lazy and are using an _AUTO lexicon, then you've got to make a list of all the phrases that you've so far been letting _AUTO generate for you. There are very many ways to assemble such a list. The most straightforward is to simply grep the source for every occurrence of &quot;maketext&quot; (or calls to wrappers around it, like the above &lt;code&gt;pmt&lt;/code&gt; function), and to log the following phrase.</source>
          <target state="translated">一旦完成了该程序，并且对第一种语言的本地化工作正常（通过Projname :: L10N :: en_us中的数据和方法），您就可以将数据汇总在一起进行翻译。如果您的第一语言词典不是_AUTO词典，那么您已经在词典中显式包含了所有消息（否则，在调用$ lh-&amp;gt; maketext来获取不在此处的消息时，您将抛出异常。 ）。但是，如果（建议）您是懒惰的，并且正在使用_AUTO词典，那么您必须列出迄今为止为止让_AUTO为您生成的所有短语的列表。有很多方法可以汇编这样的列表。最直接的方法是简单地grep每次出现&amp;ldquo; maketext&amp;rdquo;（或围绕它的包装器的调用）的源代码，就像上面的 &lt;code&gt;pmt&lt;/code&gt; 功能），并记录以下短语。</target>
        </trans-unit>
        <trans-unit id="2748f5e91bdbaf9d65e1b144f8ee5e1cdc0ecbe6" translate="yes" xml:space="preserve">
          <source>Once the reference is stored in a variable like $aref or $href, you can copy it or store it just the same as any other scalar value:</source>
          <target state="translated">一旦引用被存储在一个像$aref或$href这样的变量中,你就可以像其他标量值一样复制或存储它。</target>
        </trans-unit>
        <trans-unit id="15fa63ef5d4644b5d99dc644eff10efe12c6233c" translate="yes" xml:space="preserve">
          <source>Once the size of the program has been determined, the pattern is parsed again, but this time for real. Now &lt;code&gt;SIZE_ONLY&lt;/code&gt; will be false, and the actual construction can occur.</source>
          <target state="translated">确定了程序的大小后，将再次解析模式，但这一次是真实的。现在 &lt;code&gt;SIZE_ONLY&lt;/code&gt; 将为false，并且可以进行实际构造。</target>
        </trans-unit>
        <trans-unit id="1ce09f4f2086e283549a294da4a8bb0ec70720b9" translate="yes" xml:space="preserve">
          <source>Once this is done, do the following to build any extension:</source>
          <target state="translated">一旦这样做,做以下工作来建立任何扩展。</target>
        </trans-unit>
        <trans-unit id="c86d1961dcc0430277520b8cb5786b3c716d4a7c" translate="yes" xml:space="preserve">
          <source>Once this process completes for a given function, it is defined, so future calls to the subroutine will bypass the AUTOLOAD mechanism.</source>
          <target state="translated">一旦给定函数的这个过程完成,它就被定义了,所以未来对子程序的调用将绕过AUTOLOAD机制。</target>
        </trans-unit>
        <trans-unit id="9bc6c924aca0f68365c3f48d14dbdebf3eb3856a" translate="yes" xml:space="preserve">
          <source>Once uploaded, it'll sit unnoticed in your author directory. If you want it connected to the rest of the CPAN, you'll need to go to &quot;Register Namespace&quot; on PAUSE. Once registered, your module will appear in the by-module and by-category listings on CPAN.</source>
          <target state="translated">一旦上传,它就会被放在你的作者目录中,不被人注意。如果您想让它与CPAN的其他部分连接起来,您需要到PAUSE上的 &quot;注册命名空间&quot;。一旦注册,您的模块将出现在CPAN上的by-module和by-category列表中。</target>
        </trans-unit>
        <trans-unit id="852b82c0a8fc155a5b67d823ae98f4fd4d342839" translate="yes" xml:space="preserve">
          <source>Once upon a time, C code compilable under both BSD and SysV. In general, code that can be easily converted to run on another &lt;b&gt;platform&lt;/b&gt;, where &amp;ldquo;easily&amp;rdquo; can be defined however you like, and usually is. Anything may be considered portable if you try hard enough, such as a mobile home or London Bridge.</source>
          <target state="translated">从前，C代码可在BSD和SysV下编译。通常，可以轻松转换为在另一个&lt;b&gt;平台&lt;/b&gt;上运行的代码，可以根据自己的喜好（通常是这样）定义&amp;ldquo;轻松&amp;rdquo;。如果您足够努力，任何东西都可以认为是便携式的，例如活动房屋或伦敦桥。</target>
        </trans-unit>
        <trans-unit id="028479890974f67d52e50ca30dc71571debad796" translate="yes" xml:space="preserve">
          <source>Once upon a time, I wrote a program called pstruct. It was a perl program that tried to parse out C structures and display their member offsets for you. This was especially useful for people looking at binary dumps or poking around the kernel.</source>
          <target state="translated">很久以前,我写过一个叫pstruct的程序。这是一个perl程序,它试图解析出C结构,并为你显示它们的成员偏移量。这对于那些看二进制转储的人或者在内核里摸索的人来说特别有用。</target>
        </trans-unit>
        <trans-unit id="5311fe73402702af14e5a56e844da83a8b07a8a6" translate="yes" xml:space="preserve">
          <source>Once upon a time, MakeMaker could produce an approximation of a correct Makefile on MacOS Classic (MacPerl). Due to a lack of maintainers, this fell out of sync with the rest of MakeMaker and hadn't worked in years. Since there's little chance of it being repaired, MacOS Classic is fading away, and the code was icky to begin with, the code has been deleted to make maintenance easier.</source>
          <target state="translated">从前,MakeMaker可以在MacOS Classic(MacPerl)上生成一个近似正确的Makefile。由于缺乏维护者,这与MakeMaker的其他部分不同步,已经多年没有工作了。由于修复的机会不大,MacOS Classic也渐渐消失,而且一开始的代码就很恶心,为了方便维护,这段代码已经被删除。</target>
        </trans-unit>
        <trans-unit id="f360544bd22369fcd1b6d32877524b0035f30449" translate="yes" xml:space="preserve">
          <source>Once upon a time, there was a library called</source>
          <target state="translated">很久以前,有一个图书馆叫做</target>
        </trans-unit>
        <trans-unit id="c419b35f29ce772e59b3d6f120a7bf0188bed72b" translate="yes" xml:space="preserve">
          <source>Once we've blessed the hash referred to by &lt;code&gt;$self&lt;/code&gt; we can start calling methods on it. This is useful if you want to put object initialization in its own separate method:</source>
          <target state="translated">一旦祝福了 &lt;code&gt;$self&lt;/code&gt; 所引用的哈希，我们就可以开始对其调用方法。如果要将对象初始化放在其自己的单独方法中，这将很有用：</target>
        </trans-unit>
        <trans-unit id="6b240bbed00f45e13a77c757892ecbf1631c45c9" translate="yes" xml:space="preserve">
          <source>Once you can identify individual blocks, try allowing them to be nested. That isn't difficult either.</source>
          <target state="translated">一旦你能识别出各个区块,试着让它们嵌套。这也不难。</target>
        </trans-unit>
        <trans-unit id="383155a2b30e1482a3f900136a965760218a5249" translate="yes" xml:space="preserve">
          <source>Once you have a reference, you can use the following macro to dereference the reference:</source>
          <target state="translated">一旦你有了一个引用,你可以使用下面的宏来取消引用。</target>
        </trans-unit>
        <trans-unit id="77ad49af6893225c730f233c983aba4b11bcf0d8" translate="yes" xml:space="preserve">
          <source>Once you have done that, you can access the Berkeley DB API functions as &lt;b&gt;DB_File&lt;/b&gt; methods directly like this:</source>
          <target state="translated">完成此操作后，您可以直接使用&lt;b&gt;DB_File&lt;/b&gt;方法访问Berkeley DB API函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="9d9573b46c2994b393d22341f4e2899c15619352" translate="yes" xml:space="preserve">
          <source>Once you have it on, simply bring up a PASE shell and extract the tarball.</source>
          <target state="translated">开启后,只需调出PASE shell,提取tarball即可。</target>
        </trans-unit>
        <trans-unit id="2403323a2c0ab8ef6892066d26c525181d3596a2" translate="yes" xml:space="preserve">
          <source>Once you have the list of keys, you can process that list before you process the hash elements. For instance, you can sort the keys so you can process them in lexical order:</source>
          <target state="translated">一旦你有了密钥列表,你就可以在处理哈希元素之前处理这个列表。例如,你可以对密钥进行排序,这样你就可以按照词法顺序处理它们。</target>
        </trans-unit>
        <trans-unit id="fa2bd757e5448bc96817cbaf4661aeb1b493b281" translate="yes" xml:space="preserve">
          <source>Once you have this code, slap it into the second argument of</source>
          <target state="translated">一旦你有了这段代码,就把它贴到了</target>
        </trans-unit>
        <trans-unit id="ae0a83fd366650f3f9c13c1a72ec5ce82cd02510" translate="yes" xml:space="preserve">
          <source>Once you have your binary file properly opened in the right mode, you can use all the same Perl I/O functions as you used on text files. However, you may wish to use the fixed-size &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; instead of the variable-sized &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; for your input.</source>
          <target state="translated">在正确的模式下正确打开二进制文件后，便可以使用与文本文件相同的所有Perl I / O功能。但是，您可能希望使用固定大小的 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; ，而不是可变大小 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 您的输入。</target>
        </trans-unit>
        <trans-unit id="4a97180f59d4ebc49010b5f130f6497cfeb42c05" translate="yes" xml:space="preserve">
          <source>Once you have your hook functions, you need a &lt;code&gt;BHK&lt;/code&gt; structure to put them in. It's best to allocate it statically, since there is no way to free it once it's registered. The function pointers should be inserted into this structure using the &lt;code&gt;BhkENTRY_set&lt;/code&gt; macro, which will also set flags indicating which entries are valid. If you do need to allocate your &lt;code&gt;BHK&lt;/code&gt; dynamically for some reason, be sure to zero it before you start.</source>
          <target state="translated">一旦有了钩子函数，就需要一个 &lt;code&gt;BHK&lt;/code&gt; 结构来放入它们。最好是静态分配它，因为一旦注册，就无法释放它。应该使用 &lt;code&gt;BhkENTRY_set&lt;/code&gt; 宏将函数指针插入此结构，该宏还将设置标志，指​​示哪些条目有效。如果由于某些原因确实需要动态分配 &lt;code&gt;BHK&lt;/code&gt; ，请确保在开始之前将其归零。</target>
        </trans-unit>
        <trans-unit id="e41f59d96ffbb22709bea4ad583772ec9921c59e" translate="yes" xml:space="preserve">
          <source>Once you know what the type of an object is, you then know what subclass it belongs to, and therefore what methods it supports.</source>
          <target state="translated">一旦你知道一个对象的类型是什么,你就知道它属于什么子类,从而知道它支持什么方法。</target>
        </trans-unit>
        <trans-unit id="850880274fc323f37b6b25fc23ccf3a516cbf65a" translate="yes" xml:space="preserve">
          <source>Once you start accumulating users, they'll send you bug reports. If you're lucky, they'll even send you patches. Welcome to the joys of maintaining a software project...</source>
          <target state="translated">一旦你开始积累用户,他们就会给你发错误报告。如果你幸运的话,他们甚至会给你发送补丁。欢迎来到维护软件项目的乐趣......</target>
        </trans-unit>
        <trans-unit id="ba22e7b4a3b9d48110bef39d92876fccf1215f67" translate="yes" xml:space="preserve">
          <source>Once you're doing this, you may alter Concise output by adding new rendering styles, and by optionally adding callback routines which populate new variables, if such were referenced from those (just added) styles.</source>
          <target state="translated">一旦你这样做了,你可以通过添加新的渲染样式来改变Concise的输出,也可以通过添加回调例程来填充新的变量,如果这些变量是从这些(刚刚添加的)样式中引用的。</target>
        </trans-unit>
        <trans-unit id="566e6d16d506c3974bf904eb0b48aa55735c513e" translate="yes" xml:space="preserve">
          <source>Once you're done here, check out &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; next.</source>
          <target state="translated">在这里完成操作后，接下来请查看&lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29ed2494b99283db9c4753c1220697c79a656d72" translate="yes" xml:space="preserve">
          <source>Once you've actually set any options you want (if any), you can go ahead and use the following methods to search for Pod files in particular ways.</source>
          <target state="translated">一旦你实际设置了任何你想要的选项(如果有的话),你就可以继续使用以下方法以特定方式搜索Pod文件。</target>
        </trans-unit>
        <trans-unit id="23b007b44c67108f453a7c776499a8dd3ea3293f" translate="yes" xml:space="preserve">
          <source>Once you've done that, you can safely omit the encoding part of the open mode:</source>
          <target state="translated">一旦你做到了这一点,你就可以放心地省略开放模式的编码部分。</target>
        </trans-unit>
        <trans-unit id="57d330172757358785b8cc8eade4d52dfcf7f16d" translate="yes" xml:space="preserve">
          <source>Once you've ensured that your module passes its own tests - always a good thing to make sure - you can &lt;code&gt;make dist&lt;/code&gt; , and the Makefile will hopefully produce you a nice tarball of your module, ready for upload.</source>
          <target state="translated">一旦确保模块通过了自己的测试-确保始终是一件好事-您可以 &lt;code&gt;make dist&lt;/code&gt; ，并且Makefile有望为您生成模块的漂亮tarball，准备上载。</target>
        </trans-unit>
        <trans-unit id="f63abbf1c003f24ebc901d81ec59d8ecd65e101a" translate="yes" xml:space="preserve">
          <source>Once you've installed the NDK and set up your device, all that's left to do is setting up the device and the cross-compilation environment. Blackberry provides a script, &lt;code&gt;bbndk-env.sh&lt;/code&gt; (occasionally named something like &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; ) which can be used to do this. However, there's a bit of a snag that we have to work through: The script modifies PATH so that 'gcc' or 'ar' point to their cross-compilation equivalents, which screws over the build process.</source>
          <target state="translated">安装NDK并设置设备后，剩下要做的就是设置设备和交叉编译环境。 Blackberry提供了一个脚本 &lt;code&gt;bbndk-env.sh&lt;/code&gt; （有时名为bbndk-env_10_1_0_4828.sh之类的 &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; ）可用于执行此操作。但是，我们需要解决一些问题：脚本修改了PATH，以便'gcc'或'ar'指向它们的交叉编译等效项，这会干扰构建过程。</target>
        </trans-unit>
        <trans-unit id="6dca0ad4315ae940ee938651b8e1193e8aa9a420" translate="yes" xml:space="preserve">
          <source>Once you've localized your program/site/etc. for all desired languages, be sure to show the result (whether live, or via screenshots) to the translators. Once they approve, make every effort to have it then checked by at least one other speaker of that language. This holds true even when (or especially when) the translation is done by one of your own programmers. Some kinds of systems may be harder to find testers for than others, depending on the amount of domain-specific jargon and concepts involved -- it's easier to find people who can tell you whether they approve of your translation for &quot;delete this message&quot; in an email-via-Web interface, than to find people who can give you an informed opinion on your translation for &quot;attribute value&quot; in an XML query tool's interface.</source>
          <target state="translated">一旦你将你的程序/网站/等本地化为所有需要的语言,一定要将结果展示给翻译人员(无论是现场,还是通过屏幕截图)。一旦他们同意,就尽一切努力让至少一位讲该语言的人检查。这一点即使在翻译是由你自己的程序员完成的情况下也是如此。有些系统可能比其他系统更难找到测试者,这取决于所涉及的特定领域的术语和概念的数量--在一个email-via-Web界面中,找到能告诉你他们是否同意你的 &quot;删除这条消息 &quot;的翻译的人,比找到能给你一个XML查询工具界面中的 &quot;属性值 &quot;的翻译的人更容易。</target>
        </trans-unit>
        <trans-unit id="c53ec1e93f888bd372b8348217b36ca16ed6c602" translate="yes" xml:space="preserve">
          <source>Once you've understood those, embedding Perl in C is easy.</source>
          <target state="translated">一旦你了解了这些,在C语言中嵌入Perl就很容易了。</target>
        </trans-unit>
        <trans-unit id="8154145e302b1a07e64a971e9a8a8af681b5891f" translate="yes" xml:space="preserve">
          <source>Once you've unpacked the distribution, run &quot;sh Configure&quot; (see INSTALL for a full discussion of the Configure options). There is a &quot;hints&quot; file for os390 that specifies the correct values for most things. Some things to watch out for include:</source>
          <target state="translated">解压后,运行 &quot;sh Configure&quot; (参见 INSTALL 以了解 Configure 选项的完整讨论)。os390有一个 &quot;提示 &quot;文件,它指定了大多数事情的正确值。一些需要注意的地方包括</target>
        </trans-unit>
        <trans-unit id="db5c3d0411160491df177efaf9a707107fc6ab38" translate="yes" xml:space="preserve">
          <source>Once your extension is complete and passes all its tests, installing it is quite simple: you simply run &quot;make install&quot;. You will either need to have write permission into the directories where Perl is installed, or ask your system administrator to run the make for you.</source>
          <target state="translated">一旦你的扩展完成并通过了所有的测试,安装它就很简单了:你只需运行 &quot;make install&quot;。你需要有写权限进入安装Perl的目录,或者让你的系统管理员为你运行make。</target>
        </trans-unit>
        <trans-unit id="4f49dbc375a0394fd3dd511b9f8226cfef74fa93" translate="yes" xml:space="preserve">
          <source>One additional translation is performed: instead of</source>
          <target state="translated">进行了一个额外的翻译:将</target>
        </trans-unit>
        <trans-unit id="a68ac543ed261e894527754904db5e74312dfaac" translate="yes" xml:space="preserve">
          <source>One area where there has been conflict is in regards to C locales. (See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) perl, with one exception and unless told otherwise, sets up the underlying locale the program is running in to the locale passed into it from the environment. This is an important difference from a generic C language program, where the underlying locale is the &quot;C&quot; locale unless the program changes it. As of v5.20, this underlying locale is completely hidden from pure perl code outside the lexical scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; except for a couple of function calls in the POSIX module which of necessity use it. But the underlying locale, with that one exception is exposed to XS code, affecting all C library routines whose behavior is locale-dependent. Your XS code better not assume that the underlying locale is &quot;C&quot;. The exception is the &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3a-Numeric-Formatting&quot;&gt;LC_NUMERIC &lt;/a&gt; locale category, and the reason it is an exception is that experience has shown that it can be problematic for XS code, whereas we have not had reports of problems with the &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;other locale categories&lt;/a&gt;. And the reason for this one category being problematic is that the character used as a decimal point can vary. Many European languages use a comma, whereas English, and hence Perl are expecting a dot (U+002E: FULL STOP). Many modules can handle only the radix character being a dot, and so perl attempts to make it so. Up through Perl v5.20, the attempt was merely to set &lt;code&gt;LC_NUMERIC&lt;/code&gt; upon startup to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale. Any &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; otherwise would change it; this caused some failures. Therefore, starting in v5.22, perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; always set to &lt;code&gt;&quot;C&quot;&lt;/code&gt; for XS code.</source>
          <target state="translated">关于C语言环境，存在冲突的一个方面。 （请参阅&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。）perl例外，除非另有说明，否则将程序运行的基础语言环境设置为从环境传递到该语言环境的语言环境。这是与通用C语言程序的重要区别，在通用C语言程序中，除非程序对其进行了更改，否则基本语言环境是&amp;ldquo; C&amp;rdquo;语言环境。从v5.20开始，该基本语言环境在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境的词法范围之外完全对纯perl代码隐藏除了必须使用POSIX模块中的几个函数调用。但是底层语言环境（只有一个例外）暴露于XS代码，从而影响了行为依赖于语言环境的所有C库例程。您的XS代码最好不要假定基础语言环境是&amp;ldquo; C&amp;rdquo;。唯一的例外是&lt;a href=&quot;perllocale#Category-LC_NUMERIC%3a-Numeric-Formatting&quot;&gt;LC_NUMERIC&lt;/a&gt;语言环境类别，这是一个异常的原因是，经验表明，它可以为XS码有问题，而我们还没有与该问题的报告，&lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;其他语言环境类别&lt;/a&gt;。并且这一类出现问题的原因是用作小数点的字符可能会有所不同。许多欧洲语言使用逗号，而英语（因此Perl）期望使用点号（U + 002E：FULL STOP）。许多模块只能处理作为点的基数字符，因此perl尝试这样做。在Perl v5.20之前，仅尝试在启动时将 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 设置为 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 语言环境。否则，任何&lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale（）&lt;/a&gt;都会对其进行更改；这导致了一些失败。因此，从v5.22开始，perl尝试将XS代码的 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 始终设置为 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b3b34651f404f7056a8a03b94a1667665687e73" translate="yes" xml:space="preserve">
          <source>One big difference between ASCII-based character sets and EBCDIC ones are the relative positions of the characters when sorted in native order. Of most concern are the upper- and lowercase letters, the digits, and the underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt; ). On ASCII platforms the native sort order has the digits come before the uppercase letters which come before the underscore which comes before the lowercase letters. On EBCDIC, the underscore comes first, then the lowercase letters, then the uppercase ones, and the digits last. If sorted on an ASCII-based platform, the two-letter abbreviation for a physician comes before the two letter abbreviation for drive; that is:</source>
          <target state="translated">基于ASCII的字符集和EBCDIC的字符集之间的最大区别是，按本机顺序排序时，字符的相对位置。最需要注意的是大写和小写字母，数字和下划线（ &lt;code&gt;&quot;_&quot;&lt;/code&gt; ）。在ASCII平台上，本机排序顺序的数字在大写字母之前，在下划线之前，在下划线之前在小写字母之前。在EBCDIC上，下划线位于第一个，然后是小写字母，然后是大写字母，最后是数字。如果在基于ASCII的平台上排序，则医师的两个字母的缩写位于驱动器的两个字母的缩写之前；那是：</target>
        </trans-unit>
        <trans-unit id="a63660a2be4a88226e8e69f57c474e97932c916a" translate="yes" xml:space="preserve">
          <source>One can also use &quot;short&quot; names:</source>
          <target state="translated">也可以用 &quot;短 &quot;名。</target>
        </trans-unit>
        <trans-unit id="577442f1eff045466125f84e1aef5d482722c146" translate="yes" xml:space="preserve">
          <source>One can always start</source>
          <target state="translated">人们可以随时开始</target>
        </trans-unit>
        <trans-unit id="29c09e61bbeafec8533e6d27dfc8a923e0fca57d" translate="yes" xml:space="preserve">
          <source>One can build perl with thread support enabled by providing &lt;code&gt;-D usethreads&lt;/code&gt; option to</source>
          <target state="translated">通过提供 &lt;code&gt;-D usethreads&lt;/code&gt; 选项，可以构建启用了线程支持的perl。</target>
        </trans-unit>
        <trans-unit id="359cf3d8d5555fb74ca7adc2fbcedf983680dde4" translate="yes" xml:space="preserve">
          <source>One can change the output file handle of the messages by setting $Getopt::Std::OUTPUT_HELP_VERSION. One can print the messages of &lt;code&gt;--help&lt;/code&gt; (without the &lt;code&gt;Usage:&lt;/code&gt; line) and &lt;code&gt;--version&lt;/code&gt; by calling functions help_mess() and version_mess() with the switches string as an argument.</source>
          <target state="translated">可以通过设置$ Getopt :: Std :: OUTPUT_HELP_VERSION来更改消息的输出文件句柄。通过 &lt;code&gt;Usage:&lt;/code&gt; 开关字符串作为参数调用函数help_mess（）和version_mess（），可以打印 &lt;code&gt;--help&lt;/code&gt; （不使用用法：行）和 &lt;code&gt;--version&lt;/code&gt; 的消息。</target>
        </trans-unit>
        <trans-unit id="d414d38c04c2c09cb11f7d028ae1e652935790fa" translate="yes" xml:space="preserve">
          <source>One can check whether the currently loaded ReadLine package supports these methods by checking for corresponding &lt;code&gt;Features&lt;/code&gt; .</source>
          <target state="translated">可以通过检查相应的 &lt;code&gt;Features&lt;/code&gt; 来检查当前加载的ReadLine包是否支持这些方法。</target>
        </trans-unit>
        <trans-unit id="c198d2cf41321cd565d4f52242fa64736d1a9f4a" translate="yes" xml:space="preserve">
          <source>One can circumnavigate both these problems in two ways. Either transfer and store numbers always in text format, instead of raw binary, or else consider using modules like &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; (included as of Perl 5.8). Keeping all data as text significantly simplifies matters.</source>
          <target state="translated">一个人可以通过两种方式规避这两个问题。总是以文本格式而不是原始二进制格式传输和存储数字，或者考虑使用诸如 &lt;code&gt;Data::Dumper&lt;/code&gt; 和 &lt;code&gt;Storable&lt;/code&gt; （自Perl 5.8起包含）之类的模块。将所有数据保留为文本可大大简化事务。</target>
        </trans-unit>
        <trans-unit id="09119ba09b711474d1016a03da12b7c5aabeff6a" translate="yes" xml:space="preserve">
          <source>One can get RSX from, say</source>
          <target state="translated">我们可以从以下地方获得RSX</target>
        </trans-unit>
        <trans-unit id="fc1d1f2f775a433521e449135abda7dc4b545354" translate="yes" xml:space="preserve">
          <source>One can get different parts of EMX from, say</source>
          <target state="translated">人们可以从EMX的不同部分获得,比如说</target>
        </trans-unit>
        <trans-unit id="b1f6c95529bb8b413cce8749a9949bb156c89f7b" translate="yes" xml:space="preserve">
          <source>One can have Unicode in identifier names, but not in package/class or subroutine names. While some limited functionality towards this does exist as of Perl 5.8.0, that is more accidental than designed; use of Unicode for the said purposes is unsupported.</source>
          <target state="translated">我们可以在标识符名称中使用Unicode,但不能在包/类或子程序名称中使用Unicode。虽然在Perl 5.8.0中确实存在一些有限的功能,但这更多的是偶然的,而不是设计的;不支持为上述目的使用Unicode。</target>
        </trans-unit>
        <trans-unit id="419250bbe62537b6d8975e14166ba62003b501d4" translate="yes" xml:space="preserve">
          <source>One can read this document in the following formats:</source>
          <target state="translated">您可以以下列格式阅读本文件:</target>
        </trans-unit>
        <trans-unit id="6893de36816aebf716cd1fd72a1de7d9c51768bf" translate="yes" xml:space="preserve">
          <source>One can replace a numeric repeat count with a template letter enclosed in brackets to use the packed byte length of the bracketed template for the repeat count.</source>
          <target state="translated">可以用括号内的模板信代替一个数字重复计数,使用括号内模板的打包字节长度作为重复计数。</target>
        </trans-unit>
        <trans-unit id="05782b074320e38eef954451f657efc4b11fa74a" translate="yes" xml:space="preserve">
          <source>One case that this does not handle is a gv without SvFAKE set. After</source>
          <target state="translated">有一种情况是没有设置 SvFAKE 的 gv 不能处理。在</target>
        </trans-unit>
        <trans-unit id="702f5c0458dfb1f9b9fa361a8264610e99c16724" translate="yes" xml:space="preserve">
          <source>One common debugging approach here, would be to liberally sprinkle a few print statements, to add a check just before we print out our data, and another just after:</source>
          <target state="translated">这里有一种常见的调试方法,就是随意地洒上几条打印语句,在我们打印出数据之前加一个检查,在打印之后再加一个检查。</target>
        </trans-unit>
        <trans-unit id="38e71844bc36e8f5a99e4a47f54b762cb30af6e8" translate="yes" xml:space="preserve">
          <source>One common mistake when using this port with a GUI library like &lt;code&gt;Tk&lt;/code&gt; is assuming that Perl's normal behavior of opening a command-line window will go away. This isn't the case. If you want to start a copy of &lt;code&gt;perl&lt;/code&gt; without opening a command-line window, use the &lt;code&gt;wperl&lt;/code&gt; executable built during the installation process. Usage is exactly the same as normal &lt;code&gt;perl&lt;/code&gt; on Windows, except that options like &lt;code&gt;-h&lt;/code&gt; don't work (since they need a command-line window to print to).</source>
          <target state="translated">将此端口与 &lt;code&gt;Tk&lt;/code&gt; 之类的GUI库一起使用时，一个常见的错误是假设Perl打开命令行窗口的正常行为将消失。事实并非如此。如果要在不打开命令行窗口的情况下启动 &lt;code&gt;perl&lt;/code&gt; 的副本，请使用在安装过程中生成的 &lt;code&gt;wperl&lt;/code&gt; 可执行文件。用法与Windows上的常规 &lt;code&gt;perl&lt;/code&gt; 完全相同，除了 &lt;code&gt;-h&lt;/code&gt; 之类的选项不起作用（因为它们需要命令行窗口才能打印到）。</target>
        </trans-unit>
        <trans-unit id="8a4117118bb75dbafb375915c27d62ebe634dd07" translate="yes" xml:space="preserve">
          <source>One conveys this info to &lt;b&gt;xsubpp&lt;/b&gt; by replacing &lt;code&gt;*&lt;/code&gt; before the argument by &lt;code&gt;&amp;amp;&lt;/code&gt; . &lt;code&gt;&amp;amp;&lt;/code&gt; means that the argument should be passed to a library function by its address. The above two function may be XSUB-ified as</source>
          <target state="translated">通过将 &lt;code&gt;&amp;amp;&lt;/code&gt; 替换为参数之前的 &lt;code&gt;*&lt;/code&gt; ，可以将此信息传达给&lt;b&gt;xsubpp&lt;/b&gt;。 &lt;code&gt;&amp;amp;&lt;/code&gt; 表示该参数应通过其地址传递给库函数。上面的两个函数可以用XSUB表示为</target>
        </trans-unit>
        <trans-unit id="d10907c81f2d55151091ac660924f2a1e254db78" translate="yes" xml:space="preserve">
          <source>One could use this to create subclasses of &lt;b&gt;Pod::Paragraphs&lt;/b&gt; and &lt;b&gt;Pod::InteriorSequences&lt;/b&gt; for specific commands (or to create your own custom node-types in the parse-tree) and add some kind of &lt;b&gt;emit()&lt;/b&gt; method to each custom node/subclass object in the tree. Then all you'd need to do is recursively walk the tree in the desired order, processing the children (most likely from left to right) by formatting them if they are text-strings, or by calling their &lt;b&gt;emit()&lt;/b&gt; method if they are objects/references.</source>
          <target state="translated">可以使用它为特定命令创建&lt;b&gt;Pod :: Paragraphs&lt;/b&gt;和&lt;b&gt;Pod :: InteriorSequences的&lt;/b&gt;子类（或在解析树中创建自己的自定义节点类型），然后向每个自定义节点/ 添加某种类型的&lt;b&gt;generate（）&lt;/b&gt;方法树中的子类对象。然后，您所需要做的就是以所需顺序递归地遍历树，处理子级（最有可能是从左到右），方法是格式化子级（如果它们是文本字符串），或者调用子级的&lt;b&gt;embed（）&lt;/b&gt;方法&lt;b&gt;（&lt;/b&gt;如果它们是文本字符串&lt;b&gt;）。&lt;/b&gt;对象/引用。</target>
        </trans-unit>
        <trans-unit id="d5d134d4ce2691a8fd3e620efdc0c0a7dc96f2ab" translate="yes" xml:space="preserve">
          <source>One counterpart, in the column labelled &quot;ASCII-range Unicode&quot; in the table, matches only characters in the ASCII character set.</source>
          <target state="translated">其中,在表中标有 &quot;ASCII范围Unicode &quot;的一栏中,只匹配ASCII字符集中的字符。</target>
        </trans-unit>
        <trans-unit id="e759a7518c2a7615eb212a5b5c617930b5079aa4" translate="yes" xml:space="preserve">
          <source>One especially common bit of Perl code is opening a pipe to &lt;b&gt;sendmail&lt;/b&gt;:</source>
          <target state="translated">Perl代码的一个特别常见的地方是打开了一个发送&lt;b&gt;sendmail&lt;/b&gt;的管道：</target>
        </trans-unit>
        <trans-unit id="6006eb32ad88f65a8e3a677b12b70bf0c21cd44a" translate="yes" xml:space="preserve">
          <source>One example module, &lt;a href=&quot;via/quotedprint&quot;&gt;PerlIO::via::QuotedPrint&lt;/a&gt;, is included with Perl 5.8.0, and more example modules are available from CPAN, such as &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::StripHTML&quot;&gt;PerlIO::via::StripHTML&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::Base64&quot;&gt;PerlIO::via::Base64&lt;/a&gt;. The PerlIO::via::StripHTML module for instance, allows you to say:</source>
          <target state="translated">Perl 5.8.0附带了一个示例模块&lt;a href=&quot;via/quotedprint&quot;&gt;PerlIO :: via :: QuotedPrint&lt;/a&gt;，CPAN也提供了更多示例模块，例如&lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::StripHTML&quot;&gt;PerlIO :: via :: StripHTML&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::Base64&quot;&gt;PerlIO :: via :: Base64&lt;/a&gt;。例如，PerlIO :: via :: StripHTML模块允许您说：</target>
        </trans-unit>
        <trans-unit id="5ffc602a59cde7db4cddb26183a3140b07c9e1e7" translate="yes" xml:space="preserve">
          <source>One exception is the default scalar variable: starting with perl 5.14 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($_)&lt;/a&gt;&lt;/code&gt; will always strip all magic from $_, to make it possible to safely reuse $_ in a subroutine.</source>
          <target state="translated">默认标量变量是一个例外：从perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($_)&lt;/a&gt;&lt;/code&gt; 始终会剥离$ _中的所有魔术，以使可以安全地在子例程中重用$ _。</target>
        </trans-unit>
        <trans-unit id="08b4b3fb221020ddd9f00f023bbae8ca4cbaad9d" translate="yes" xml:space="preserve">
          <source>One facility, one priority.</source>
          <target state="translated">一个设施,一个重点。</target>
        </trans-unit>
        <trans-unit id="8aecc974b0a5e7d4fdcb37dff6e7916eb87115e6" translate="yes" xml:space="preserve">
          <source>One form, available starting in Perl 5.14 looks like &lt;code&gt;\o{...}&lt;/code&gt; , where the dots represent one or more octal digits. It can be used for any Unicode character.</source>
          <target state="translated">从Perl 5.14开始可用的一种形式看起来像 &lt;code&gt;\o{...}&lt;/code&gt; ，其中的点代表一个或多个八进制数字。它可以用于任何Unicode字符。</target>
        </trans-unit>
        <trans-unit id="322c61ed78983eea548dac2ca0c0f3a32df9d886" translate="yes" xml:space="preserve">
          <source>One generally uses it like so:</source>
          <target state="translated">人们一般是这样使用的。</target>
        </trans-unit>
        <trans-unit id="5328aa4f92833315a7e49e7973d7b5d5df515277" translate="yes" xml:space="preserve">
          <source>One good reason is when you already have an existing application written in another language that's all done (and done well), or you have an application language specifically designed for a certain task (e.g. prolog, make).</source>
          <target state="translated">一个很好的理由是,当你已经有了一个用另一种语言编写的现有应用程序,而且都已经完成了(而且做得很好),或者你有了一种专门为某项任务设计的应用程序语言(如prolog、make)。</target>
        </trans-unit>
        <trans-unit id="5181341efe5d191b40c7bb4f79e039f1b83f3ecd" translate="yes" xml:space="preserve">
          <source>One last thing before we show you how to open files: opening files does not (usually) automatically lock them in Perl. See &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; for how to lock.</source>
          <target state="translated">向我们展示如何打开文件之前的最后一件事：打开文件并不会（通常）自动将它们锁定在Perl中。有关如何锁定，请参见&lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7d0dbf83cb5d86dbb1f5f3433c118dbdc75390f" translate="yes" xml:space="preserve">
          <source>One level of double-quote interpretation is done first, but you can't say &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; because that's an indirect filehandle as explained in the previous paragraph. (In older versions of Perl, programmers would insert curly brackets to force interpretation as a filename glob: &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; . These days, it's considered cleaner to call the internal function directly as &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob($foo)&lt;/a&gt;&lt;/code&gt;, which is probably the right way to have done it in the first place.) For example:</source>
          <target state="translated">首先完成一个双引号解释级别，但是您不能说 &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; 因为这是上一段所述的间接文件句柄。（在旧版本的Perl中，程序员会插入大括号以强制将其解释为文件名glob： &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; 。这些天来，将内部函数直接调用为 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob($foo)&lt;/a&gt;&lt;/code&gt; 被认为是更干净的方法，这可能是首先要做的正确方法。）例如：</target>
        </trans-unit>
        <trans-unit id="cb3729bf6ea691a9592670464973a67c30ec7dce" translate="yes" xml:space="preserve">
          <source>One line description of the module. Will be included in PPD file.</source>
          <target state="translated">一行模块说明。将包含在PPD文件中。</target>
        </trans-unit>
        <trans-unit id="812bfff50b3cdd6b1a9ee7ea09cf72b33f18f12d" translate="yes" xml:space="preserve">
          <source>One log at a time.</source>
          <target state="translated">一次一个木头。</target>
        </trans-unit>
        <trans-unit id="283b267b63bd1be649ecf96f103c3d06603de13e" translate="yes" xml:space="preserve">
          <source>One macro controls the major Perl build flavor: MULTIPLICITY. The MULTIPLICITY build has a C structure that packages all the interpreter state. With multiplicity-enabled perls, PERL_IMPLICIT_CONTEXT is also normally defined, and enables the support for passing in a &quot;hidden&quot; first argument that represents all three data structures. MULTIPLICITY makes multi-threaded perls possible (with the ithreads threading model, related to the macro USE_ITHREADS.)</source>
          <target state="translated">一个宏控制主要的Perl构建风味。MULTIPLICITY。MULTIPLICITY构建有一个C结构,它可以封装所有的解释器状态。对于支持多线程的perls,通常还定义了PERL_IMPLICIT_CONTEXT,并实现了支持传递一个 &quot;隐藏的 &quot;第一个参数,代表所有三个数据结构。MULTIPLICITY 使得多线程 perls 成为可能 (使用 ithreads 线程模型,与宏 USE_ITHREADS 相关。)</target>
        </trans-unit>
        <trans-unit id="d690e728f490966c2e852c98cb2c60fa0b1d2fcd" translate="yes" xml:space="preserve">
          <source>One may also use pod directives to quickly comment out a section of code.</source>
          <target state="translated">我们也可以使用pod指令来快速注释出一段代码。</target>
        </trans-unit>
        <trans-unit id="9dbb00f26b5f18e0abff366f4de58cbb31829dd9" translate="yes" xml:space="preserve">
          <source>One may wonder why we call the above calculator symbolic. The reason is that the actual calculation of the value of expression is postponed until the value is</source>
          <target state="translated">也许有人会问,为什么我们把上述计算器称为符号式。原因是实际计算表达式的值的时间被推迟到了</target>
        </trans-unit>
        <trans-unit id="bf00ffa0a786e25adb9ef6ba76b09b1f7cf9677e" translate="yes" xml:space="preserve">
          <source>One might initially guess that Perl would find the &lt;code&gt;at&lt;/code&gt; in &lt;code&gt;cat&lt;/code&gt; and stop there, but that wouldn't give the longest possible string to the first quantifier &lt;code&gt;.*&lt;/code&gt;. Instead, the first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much of the string as possible while still having the regexp match. In this example, that means having the &lt;code&gt;at&lt;/code&gt; sequence with the final &lt;code&gt;at&lt;/code&gt; in the string. The other important principle illustrated here is that, when there are two or more elements in a regexp, the</source>
          <target state="translated">最初可能有人猜测Perl会在 &lt;code&gt;cat&lt;/code&gt; 中找到 &lt;code&gt;at&lt;/code&gt; 并在那里停下来，但这不会给第一个限定符 &lt;code&gt;.*&lt;/code&gt; 带来最长的字符串。取而代之的是，第一个量词 &lt;code&gt;.*&lt;/code&gt; 会在保持正则表达式匹配的同时获取尽可能多的字符串。在此示例中，这意味着在字符串中具有 &lt;code&gt;at&lt;/code&gt; 序列和最后一个 &lt;code&gt;at&lt;/code&gt; 。此处说明的另一个重要原理是，当正则表达式中包含两个或多个元素时，</target>
        </trans-unit>
        <trans-unit id="3150bc5b7154ac86649428809493c4398ced1ef5" translate="yes" xml:space="preserve">
          <source>One might think that &lt;code&gt;\s&lt;/code&gt; is equivalent to &lt;code&gt;[\h\v]&lt;/code&gt; . This is indeed true starting in Perl v5.18, but prior to that, the sole difference was that the vertical tab (&lt;code&gt;&quot;\cK&quot;&lt;/code&gt; ) was not matched by &lt;code&gt;\s&lt;/code&gt;.</source>
          <target state="translated">可能会认为 &lt;code&gt;\s&lt;/code&gt; 等效于 &lt;code&gt;[\h\v]&lt;/code&gt; 。从Perl v5.18开始确实如此，但是在此之前，唯一的区别是垂直制表符（ &lt;code&gt;&quot;\cK&quot;&lt;/code&gt; ）与 &lt;code&gt;\s&lt;/code&gt; 不匹配。</target>
        </trans-unit>
        <trans-unit id="9432dfd3d2e52e33cd8be01a23869f988f439b1e" translate="yes" xml:space="preserve">
          <source>One more thing here. The arrow is optional</source>
          <target state="translated">这里还有一件事。箭头是可选的</target>
        </trans-unit>
        <trans-unit id="a5eb562f91efde24f12f2e0986c6a04d104745fa" translate="yes" xml:space="preserve">
          <source>One must be careful with scalars and strings that are passed to print that contain ASCII encodings. One common place for this to occur is in the output of the MIME type header for CGI script writing. For example, many Perl programming guides recommend something similar to:</source>
          <target state="translated">必须小心处理传递给打印的包含ASCII编码的标量和字符串。一个常见的地方是在CGI脚本编写的MIME类型头的输出中出现这种情况。例如,许多Perl编程指南都推荐类似于这样的内容。</target>
        </trans-unit>
        <trans-unit id="8aa98e22038b28e02e918eedca3ae733d476de73" translate="yes" xml:space="preserve">
          <source>One name for a file. This name is listed in a &lt;b&gt;directory&lt;/b&gt;. You can use it in an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; to tell the &lt;b&gt;operating system&lt;/b&gt; exactly which file you want to open, and associate the file with a &lt;b&gt;filehandle&lt;/b&gt;, which will carry the subsequent identity of that file in your program, until you close it.</source>
          <target state="translated">文件的一个名称。此名称在&lt;b&gt;目录中&lt;/b&gt;列出。您可以在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 中使用它，以告诉&lt;b&gt;操作系统&lt;/b&gt;确切要打开的文件，并将该文件与&lt;b&gt;filehandle&lt;/b&gt;关联，该文件&lt;b&gt;句柄&lt;/b&gt;将在程序中带有该&lt;b&gt;文件&lt;/b&gt;的后续标识，直到您将其关闭。</target>
        </trans-unit>
        <trans-unit id="f26a31e071285811042cc63d258cbdf20a705a7a" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;Moo&lt;/code&gt; 's most compelling features is its interoperability with &lt;code&gt;Moose&lt;/code&gt; . When someone tries to use &lt;code&gt;Moose&lt;/code&gt; 's introspection API on a &lt;code&gt;Moo&lt;/code&gt; class or role, it is transparently inflated into a &lt;code&gt;Moose&lt;/code&gt; class or role. This makes it easier to incorporate &lt;code&gt;Moo&lt;/code&gt; -using code into a &lt;code&gt;Moose&lt;/code&gt; code base and vice versa.</source>
          <target state="translated">一 &lt;code&gt;Moo&lt;/code&gt; 的最引人注目的功能是它的互操作性 &lt;code&gt;Moose&lt;/code&gt; 。当有人尝试在 &lt;code&gt;Moo&lt;/code&gt; 类或角色上使用 &lt;code&gt;Moose&lt;/code&gt; 的自省API时，它会透明地膨胀为 &lt;code&gt;Moose&lt;/code&gt; 类或角色。这使得将使用 &lt;code&gt;Moo&lt;/code&gt; 的代码合并到 &lt;code&gt;Moose&lt;/code&gt; 代码库中变得更加容易，反之亦然。</target>
        </trans-unit>
        <trans-unit id="5bf48b13931751973cecbe1ffc3a845b843b66dc" translate="yes" xml:space="preserve">
          <source>One of HP porting centres URL's is &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt; The port currently available is built with GNU gcc.</source>
          <target state="translated">HP移植中心URL之一是&lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt;当前可用的端口是使用GNU gcc构建的。</target>
        </trans-unit>
        <trans-unit id="94bda56a061a9cf12b48d3cef39a83cda8c248d2" translate="yes" xml:space="preserve">
          <source>One of Perl's internal formats happens to be UTF-8. Unfortunately, Perl can't keep a secret, so everyone knows about this. That is the source of much confusion. It's better to pretend that the internal format is some unknown encoding, and that you always have to encode and decode explicitly.</source>
          <target state="translated">Perl的内部格式之一恰好是UTF-8。不幸的是,Perl无法保守秘密,所以每个人都知道这一点。这也是造成很多混乱的原因。最好假装内部格式是某种未知的编码,你总是要明确地进行编码和解码。</target>
        </trans-unit>
        <trans-unit id="cc31f4f8c344159a9afe652428d4adbed5ef0111" translate="yes" xml:space="preserve">
          <source>One of the filters between the data and what you get as input or what you end up with as output.</source>
          <target state="translated">数据与输入的数据或最终输出的数据之间的过滤器之一。</target>
        </trans-unit>
        <trans-unit id="3850b3f9f916208f5af479bdf2a17050a569dd0c" translate="yes" xml:space="preserve">
          <source>One of the hacks is to disable floating point exceptions on Perl startup (as is the default with EMX). This helps only with compile-time-linked DLLs changing the flags before main() had a chance to be called.</source>
          <target state="translated">其中一个小技巧是在Perl启动时禁用浮点异常(EMX的默认值)。这只对编译时关联的DLL在main()被调用之前改变标志有帮助。</target>
        </trans-unit>
        <trans-unit id="b9aab9b2588d728ddcd8fd3f3150c7ee7136503c" translate="yes" xml:space="preserve">
          <source>One of the major problems with ancient, antemillennial socket code in Perl was that it used hard-coded values for some of the constants, which severely hurt portability. If you ever see code that does anything like explicitly setting &lt;code&gt;$AF_INET = 2&lt;/code&gt; , you know you're in for big trouble. An immeasurably superior approach is to use the &lt;code&gt;Socket&lt;/code&gt; module, which more reliably grants access to the various constants and functions you'll need.</source>
          <target state="translated">Perl中古老的，千年前的套接字代码的主要问题之一是，它对某些常量使用了硬编码的值，这严重损害了可移植性。如果您看到执行类似显式设置 &lt;code&gt;$AF_INET = 2&lt;/code&gt; 代码的代码，那么您就知道自己陷入了大麻烦。一种无与伦比的优越方法是使用 &lt;code&gt;Socket&lt;/code&gt; 模块，它可以更可靠地授予对所需的各种常量和函数的访问权限。</target>
        </trans-unit>
        <trans-unit id="6c4fa2a95a0e37301600fc24249222e084bd9620" translate="yes" xml:space="preserve">
          <source>One of the most important new features in Perl 5 was the capability to manage complicated data structures like multidimensional arrays and nested hashes. To enable these, Perl 5 introduced a feature called 'references', and using references is the key to managing complicated, structured data in Perl. Unfortunately, there's a lot of funny syntax to learn, and the main manual page can be hard to follow. The manual is quite complete, and sometimes people find that a problem, because it can be hard to tell what is important and what isn't.</source>
          <target state="translated">Perl 5 中最重要的新特性之一就是能够管理复杂的数据结构,比如多维数组和嵌套哈希。为了实现这些功能,Perl 5引入了一个叫做 &quot;引用 &quot;的功能,而使用引用是Perl中管理复杂的结构化数据的关键。不幸的是,有很多有趣的语法需要学习,而且主要的手册页面可能很难遵循。手册相当完整,有时人们会觉得这是个问题,因为很难区分哪些是重要的,哪些不是。</target>
        </trans-unit>
        <trans-unit id="41a97cc2346bbbbc5f26243bf51ad23f4ba0e8d3" translate="yes" xml:space="preserve">
          <source>One of the problems with a filter like:</source>
          <target state="translated">样的过滤器的问题之一。</target>
        </trans-unit>
        <trans-unit id="a626f07a30077e1f9ff80b843148b2bf2dc96ddf" translate="yes" xml:space="preserve">
          <source>One of the things that makes Perl really powerful is the fact that Perl hackers tend to want to share the solutions to problems they've faced, so you and I don't have to battle with the same problem again.</source>
          <target state="translated">Perl的强大之处在于,Perl的黑客们往往希望分享他们所遇到的问题的解决方案,这样你我就不必再为同一个问题而战。</target>
        </trans-unit>
        <trans-unit id="aa5b2755a479a90ca14fceb1d31618523426dc94" translate="yes" xml:space="preserve">
          <source>One of the two modules that is used by perlivp was not present in the installation. This is a serious error since it adversely affects perlivp's ability to function. You may be able to correct this by performing a proper perl installation.</source>
          <target state="translated">perlivp使用的两个模块中的一个没有在安装中出现。这是一个严重的错误,因为它会对 perlivp 的功能产生不利影响。你可以通过正确安装perl来纠正这个问题。</target>
        </trans-unit>
        <trans-unit id="d738b6e570cef7894a16f160998423dd24b30a2e" translate="yes" xml:space="preserve">
          <source>One or more embedded pattern-match modifiers, to be turned on (or turned off, if preceded by &lt;code&gt;-&lt;/code&gt; ) for the remainder of the pattern or the remainder of the enclosing pattern group (if any).</source>
          <target state="translated">一个或多个嵌入式模式匹配修饰符，将为其余模式或封闭模式组的剩余模式（如果有的话）打开（或关闭，如果以 &lt;code&gt;-&lt;/code&gt; 开头）。</target>
        </trans-unit>
        <trans-unit id="721d29636c1b919768ad8c3269b118c8775df092" translate="yes" xml:space="preserve">
          <source>One or more files turned up missing according to a run of &lt;code&gt;ExtUtils::Installed -&amp;gt; validate()&lt;/code&gt; over your installation. Correct by conducting a proper installation.</source>
          <target state="translated">根据在 &lt;code&gt;ExtUtils::Installed -&amp;gt; validate()&lt;/code&gt; 运行的ExtUtils :: Installed-&amp;gt; validate（），一个或多个文件丢失。通过进行正确的安装进行纠正。</target>
        </trans-unit>
        <trans-unit id="88abd7d83fea4aa59fb220bc8cdda84165c2e0f9" translate="yes" xml:space="preserve">
          <source>One or more modifiers below may optionally follow certain letters in the TEMPLATE (the second column lists letters for which the modifier is valid):</source>
          <target state="translated">下面的一个或多个修饰符可以选择跟在TEMPLATE中的某些字母后面(第二列列出修饰符有效的字母)。</target>
        </trans-unit>
        <trans-unit id="3fcfdc5f9b9b3f122957e3a54f34893e2f61290e" translate="yes" xml:space="preserve">
          <source>One or more sections or subsections giving greater detail of available methods and routines and any other relevant information.</source>
          <target state="translated">一个或多个章节或小节,更详细地介绍现有方法和例行程序以及任何其他相关信息;</target>
        </trans-unit>
        <trans-unit id="c5eeb4b94f000feadb0a97d5609bef506c388a67" translate="yes" xml:space="preserve">
          <source>One other interesting thing that the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; flag allows is chaining substitutions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 标志允许的另一件有趣的事情是链接替换：</target>
        </trans-unit>
        <trans-unit id="1f9412fcd9541135d5364daa53310c1798b61f41" translate="yes" xml:space="preserve">
          <source>One other thing to consider is that a CV may be merely undefined rather than freed, eg &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; . In this case, its refcount may not have reached zero, but we still delete its pad and its &lt;code&gt;CvROOT&lt;/code&gt; etc. Since various children may still have their &lt;code&gt;CvOUTSIDE&lt;/code&gt; pointing at this undefined CV, we keep its own &lt;code&gt;CvOUTSIDE&lt;/code&gt; for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</source>
          <target state="translated">要考虑的另一件事是CV可能只是未定义而不是被释放，例如 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; 。在这种情况下，其引用计数可能尚未达到零，但我们仍会删除其填充和 &lt;code&gt;CvROOT&lt;/code&gt; 等。由于各种子代可能仍将其 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 指向此未定义的CV，因此我们 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 保留其自己的CvOUTSIDE，以便词汇范围的链是不间断的。例如，以下应打印123：</target>
        </trans-unit>
        <trans-unit id="54709e3c9ceaf35c18e13834b92c003e53cefa1d" translate="yes" xml:space="preserve">
          <source>One particularly pernicious problem with the 4NT command shell for Windows is that it (nearly) always treats a % character as indicating that environment variable expansion is needed. Under this shell, it is therefore important to always double any % characters which you want Perl to see (for example, for hash variables), even when they are quoted.</source>
          <target state="translated">Windows 下的 4NT 命令壳有一个特别有害的问题,那就是它(几乎)总是把 % 字符当作是需要扩展环境变量。因此,在这个 shell 下,重要的是始终将任何你想让 Perl 看到的 % 字符(例如,对于哈希变量)加倍,即使它们是引号。</target>
        </trans-unit>
        <trans-unit id="3b85137385a802506b55867204695f7dbafde5be" translate="yes" xml:space="preserve">
          <source>One possibility is to treat any match against these code points as undefined. But since Perl doesn't have the concept of a match being undefined, it converts this to failing or &lt;code&gt;FALSE&lt;/code&gt; . This is almost, but not quite, what Perl did from v5.14 (when use of these code points became generally reliable) through v5.18. The difference is that Perl treated all &lt;code&gt;\p{}&lt;/code&gt; matches as failing, but all &lt;code&gt;\P{}&lt;/code&gt; matches as succeeding.</source>
          <target state="translated">一种可能性是将针对这些代码点的任何匹配都视为未定义。但是由于Perl没有定义未定义匹配的概念，因此将其转换为failure或 &lt;code&gt;FALSE&lt;/code&gt; 。这几乎是（但不完全是）Perl从v5.14（使用这些代码点变得普遍可靠）到v5.18所做的事情。区别在于Perl将所有 &lt;code&gt;\p{}&lt;/code&gt; 匹配都视为失败，而所有 &lt;code&gt;\P{}&lt;/code&gt; 匹配都视为成功。</target>
        </trans-unit>
        <trans-unit id="1709a410cf93d9bdbeb6df92828279b6d704a7e5" translate="yes" xml:space="preserve">
          <source>One possible cause for this is that you expected to have imported a constant to your name space with &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; while no such importing took place, it may for example be that your operating system does not support that particular constant. Hopefully you did use an explicit import list for the constants you expect to see; please see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;. While an explicit import list would probably have caught this error earlier it naturally does not remedy the fact that your operating system still does not support that constant. Maybe you have a typo in the constants of the symbol import list of &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; or in the constant name at the line where this error was triggered?</source>
          <target state="translated">造成这种情况的一个可能原因是，您希望通过&lt;b&gt;使用&lt;/b&gt;或&lt;b&gt;导入&lt;/b&gt;将常量导入名称空间，而没有进行任何此类导入，例如，可能是您的操作系统不支持该常量。希望您对期望看到的常量使用了明确的导入列表；请参阅&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;和&lt;a href=&quot;functions/import&quot;&gt;导入&lt;/a&gt;。尽管显式导入列表很可能早已捕获了此错误，但它自然无法解决您的操作系统仍不支持该常数的事实。也许在&lt;b&gt;使用&lt;/b&gt;或&lt;b&gt;导入&lt;/b&gt;的符号导入列表的常量中或在触发此错误的行的常量名称中有错字？</target>
        </trans-unit>
        <trans-unit id="07ffb8bf7d3f585bbcc39c2a43071e1fcedc7e55" translate="yes" xml:space="preserve">
          <source>One possible cause is that you set the UTF8 flag yourself for data that you thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit data). To guard against this, you can use Encode::decode_utf8.</source>
          <target state="translated">一个可能的原因是,你自己设置了UTF8标志,你认为是UTF-8的数据,但它不是(例如,它是传统的8位数据)。为了防止这种情况,你可以使用Encode::decode_utf8。</target>
        </trans-unit>
        <trans-unit id="2c03f254e4e39f57b8a0f0a972c88db9a731c9ed" translate="yes" xml:space="preserve">
          <source>One possibly useful value for the &quot;fail&quot; attribute is the method name &quot;failure_handler_auto&quot;. This is a method defined in the class Locale::Maketext itself. You set it with:</source>
          <target state="translated">一个可能对 &quot;fail &quot;属性有用的值是方法名 &quot;fail_handler_auto&quot;。这是一个定义在类Locale::Maketext本身的方法。你可以用以下方法来设置它。</target>
        </trans-unit>
        <trans-unit id="b269ab649a9c9d812d50cb6b126828e7c900c2dc" translate="yes" xml:space="preserve">
          <source>One problem that comes up all the time is needing a hash whose values are lists. Perl has hashes, of course, but the values have to be scalars; they can't be lists.</source>
          <target state="translated">一个经常出现的问题是需要一个值是列表的哈希。当然,Perl 的哈希值必须是标量,不能是列表。</target>
        </trans-unit>
        <trans-unit id="da0157bdbeb61d81e4c036f5229eec00b96121c7" translate="yes" xml:space="preserve">
          <source>One problem with this is that it leads to unexpected, and confusting results in some cases:</source>
          <target state="translated">这样做的一个问题是,它在某些情况下会导致意想不到的、令人困惑的结果。</target>
        </trans-unit>
        <trans-unit id="28b64c8c7b545333b3723cd48a2c35dd515526c6" translate="yes" xml:space="preserve">
          <source>One reason of this unfinishedness is its (currently) inherent unportability: since both package names and subroutine names may need to be mapped to file and directory names, the Unicode capability of the filesystem becomes important-- and there unfortunately aren't portable answers.</source>
          <target state="translated">这种未完成性的原因之一是它(目前)固有的不可移植性:因为包名和子程序名都可能需要映射到文件和目录名,文件系统的Unicode能力就变得很重要--而且不幸的是没有可移植的答案。</target>
        </trans-unit>
        <trans-unit id="ea120cdc114e86190ef9485fa0b67ab7b3ed56c2" translate="yes" xml:space="preserve">
          <source>One reason that Perl does not attempt to resolve the role of Unicode in these situations is that the answers are highly dependent on the operating system and the file system(s). For example, whether filenames can be in Unicode and in exactly what kind of encoding, is not exactly a portable concept. Similarly for &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;: how well will the &quot;command-line interface&quot; (and which of them?) handle Unicode?</source>
          <target state="translated">在这种情况下，Perl不尝试解决Unicode角色的原因之一是答案高度依赖于操作系统和文件系统。例如，文件名是否可以采用Unicode以及采用哪种编码方式，并不是完全可移植的概念。对于 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 同样：&amp;ldquo;命令行界面&amp;rdquo;（以及其中的哪个？）将如何处理Unicode？</target>
        </trans-unit>
        <trans-unit id="f8927d95df9fc41f4dc802a7941a3910e635adce" translate="yes" xml:space="preserve">
          <source>One reference count is stolen, so you may need to do &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; .</source>
          <target state="translated">一个参考计数被盗，因此您可能需要执行 &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4267ef088e1112c0c8dad77c36351342e81e6a78" translate="yes" xml:space="preserve">
          <source>One simple way to check that things are in the right place is to print out the hard-coded &lt;code&gt;@INC&lt;/code&gt; that perl looks through for libraries:</source>
          <target state="translated">检查事情是否正确的一种简单方法是打印出perl查找库的硬编码 &lt;code&gt;@INC&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dc49c03d5b80e5ca3e1e2c3c5c594145d4d2cfdb" translate="yes" xml:space="preserve">
          <source>One solution to you problem might be autoupgrading|upgrading. See the pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; for an easy way to do this.</source>
          <target state="translated">解决您的问题的一种方法可能是自动升级。查看&lt;a href=&quot;../bigrat&quot;&gt;实用程序&lt;/a&gt;&lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;，&lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt;和bigrat可以轻松实现此目的。</target>
        </trans-unit>
        <trans-unit id="02a95fea5b4501f9e97b845e1295326b4030d00a" translate="yes" xml:space="preserve">
          <source>One such concept is that of a</source>
          <target state="translated">其中一个概念是</target>
        </trans-unit>
        <trans-unit id="9fa9079fbfabecb5820f55e5b80f8f3529f8caa0" translate="yes" xml:space="preserve">
          <source>One thing Perl porters should note is that</source>
          <target state="translated">Perl 移植者需要注意的是</target>
        </trans-unit>
        <trans-unit id="46c4b185ea7870c493b95dc5795ba2145a16a509" translate="yes" xml:space="preserve">
          <source>One thing you may not want to rely on is the EBCDIC encoding of punctuation characters since these may differ from code page to code page (and once your module or script is rumoured to work with EBCDIC, folks will want it to work with all EBCDIC character sets).</source>
          <target state="translated">有一件事你可能不想依赖EBCDIC编码的标点符号,因为这些符号可能会因代码页的不同而不同(一旦你的模块或脚本据说可以使用EBCDIC,人们就会希望它可以使用所有EBCDIC字符集)。</target>
        </trans-unit>
        <trans-unit id="3339e6cb559916439f958aa73fa10717ebc88663" translate="yes" xml:space="preserve">
          <source>One thing you'll notice about the Perl source is that it's full of macros. Some have called the pervasive use of macros the hardest thing to understand, others find it adds to clarity. Let's take an example, the code which implements the addition operator:</source>
          <target state="translated">关于Perl源代码,你会注意到一件事,那就是它充满了宏。有人称宏的普遍使用是最难理解的东西,也有人认为它增加了清晰度。我们举个例子,实现加法运算符的代码。</target>
        </trans-unit>
        <trans-unit id="6281791d1604f0f2ed2c5d9e3d66b1042f62e087" translate="yes" xml:space="preserve">
          <source>One trick is to use &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt;, which starts at the end of the file. That module provides an object that wraps the real filehandle to make it easy for you to move around the file. Once you get to the spot you need, you can get the actual filehandle and work with it as normal. In this case, you get the file position at the end of the last line you want to keep and truncate the file to that point:</source>
          <target state="translated">一种技巧是使用&lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File :: ReadBackwards&lt;/a&gt;，它从文件末尾开始。该模块提供了一个包装实际文件句柄的对象，使您可以轻松地在文件中移动。到达所需的位置后，您可以获取实际的文件句柄并像往常一样使用它。在这种情况下，您将在要保留的最后一行的末尾找到文件位置，并将文件截断到该位置：</target>
        </trans-unit>
        <trans-unit id="2f7425b7bd02b814bd9989aec894f5edbf698c87" translate="yes" xml:space="preserve">
          <source>One useful value for &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; is &lt;code&gt;less -+C -E&lt;/code&gt; .</source>
          <target state="translated">一个有用值 &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; 是 &lt;code&gt;less -+C -E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e54e615dc99abeb96e3dcca5dc954ca0886ad54d" translate="yes" xml:space="preserve">
          <source>One way I can do this involves the substitution operator and a double &lt;code&gt;/e&lt;/code&gt; flag. The first &lt;code&gt;/e&lt;/code&gt; evaluates &lt;code&gt;$1&lt;/code&gt; on the replacement side and turns it into &lt;code&gt;$foo&lt;/code&gt; . The second /e starts with &lt;code&gt;$foo&lt;/code&gt; and replaces it with its value. &lt;code&gt;$foo&lt;/code&gt; , then, turns into 'Fred', and that's finally what's left in the string:</source>
          <target state="translated">我执行此操作的一种方法涉及替换运算符和double &lt;code&gt;/e&lt;/code&gt; 标志。第一个 &lt;code&gt;/e&lt;/code&gt; 在替换端求值 &lt;code&gt;$1&lt;/code&gt; ，并将其转换为 &lt;code&gt;$foo&lt;/code&gt; 。第二个/ e以 &lt;code&gt;$foo&lt;/code&gt; 开头，并将其替换为它的值。然后， &lt;code&gt;$foo&lt;/code&gt; 变成'Fred'，最后就是字符串中剩下的：</target>
        </trans-unit>
        <trans-unit id="147fc583705f82dfe6c5d25a61550d429d726533" translate="yes" xml:space="preserve">
          <source>One way is to treat the return values as a list and index into it:</source>
          <target state="translated">一种方法是将返回值当作一个列表,并将其索引进去。</target>
        </trans-unit>
        <trans-unit id="f26562604a7b87b255854e546e57c428a05a7c6b" translate="yes" xml:space="preserve">
          <source>One way of peeking inside the internal encoding of Unicode characters is to use &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; to get the bytes of whatever the string encoding happens to be, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U0..&quot;, ...)&lt;/code&gt; to get the bytes of the UTF-8 encoding:</source>
          <target state="translated">窥视Unicode字符的内部编码的一种方法是使用 &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; 获取任意字符串编码碰巧的字节，或 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U0..&quot;, ...)&lt;/code&gt; 获取UTF-8编码的字节：</target>
        </trans-unit>
        <trans-unit id="aa5979d9afcdae3acb920da4d4cb51dd1f70406d" translate="yes" xml:space="preserve">
          <source>One way to avoid namespace collisions in this scenario is to translate the filename into a guaranteed-unique package name, and then compile the code into that package using &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;. In the example below, each file will only be compiled once. Or, the application might choose to clean out the symbol table associated with the file after it's no longer needed. Using &lt;a href=&quot;perlapi#call_argv&quot;&gt;call_argv in perlapi&lt;/a&gt;, We'll call the subroutine &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; which lives in the file &lt;code&gt;persistent.pl&lt;/code&gt; and pass the filename and boolean cleanup/cache flag as arguments.</source>
          <target state="translated">在这种情况下，避免名称空间冲突的一种方法是将文件名转换为保证唯一的包名称，然后使用&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;将代码编译到该包中。在下面的示例中，每个文件仅被编译一次。或者，应用程序可能会选择不再需要与文件关联的符号表。&lt;a href=&quot;perlapi#call_argv&quot;&gt;在perlapi中&lt;/a&gt;使用call_argv，我们将调用子例程 &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; （位于文件 &lt;code&gt;persistent.pl&lt;/code&gt; 中)，并将文件名和布尔值cleanup / cache标志作为参数传递。</target>
        </trans-unit>
        <trans-unit id="3bf742d4fed91595248e4e766bfc873dce09be23" translate="yes" xml:space="preserve">
          <source>One way to do this is to inject a rare call somewhere near what you're looking for. For example, you could add &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; before your method:</source>
          <target state="translated">一种方法是在您要查找的位置附近插入一个罕见的呼叫。例如，您可以在方法之前添加 &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2f4920008fd4d756e499ea61ff8d38a964bd84a8" translate="yes" xml:space="preserve">
          <source>One way to find out how much memory is being used by Perl data structures is to install the Devel::Size module from CPAN: it gives you the minimum number of bytes required to store a particular data structure. Please be mindful of the difference between the size() and total_size().</source>
          <target state="translated">了解Perl数据结构使用了多少内存的方法之一是安装CPAN的Devel::Size模块:它提供了存储特定数据结构所需的最小字节数。请注意size()和total_size()之间的区别。</target>
        </trans-unit>
        <trans-unit id="00322fdac947c21ed0522e06d3fcf307d762cdd8" translate="yes" xml:space="preserve">
          <source>One way to get around this macro hell is to use the dumping functions in</source>
          <target state="translated">绕过这个宏地狱的方法之一是使用在</target>
        </trans-unit>
        <trans-unit id="eeda9b7821d8b2cc38107791f4013f43a6f0fb4b" translate="yes" xml:space="preserve">
          <source>One way you can contribute is to send test results for each module that you install. If you install the CPAN::Reporter module, you have the option to automatically generate and deliver test reports to CPAN Testers whenever you run tests on a CPAN package.</source>
          <target state="translated">您可以贡献的一种方式是为您安装的每个模块发送测试结果。如果安装了CPAN::Reporter模块,每当你在CPAN包上运行测试时,你就可以选择自动生成并向CPAN测试人员发送测试报告。</target>
        </trans-unit>
        <trans-unit id="31e7d725bdb8f49cf001861a4a5f8e1249780511" translate="yes" xml:space="preserve">
          <source>One work around is to apply encodings to STDOUT and STDERR as early as possible and before Test::More (or any other Test module) loads.</source>
          <target state="translated">一个变通的办法是在Test::More (或任何其他测试模块)加载之前,尽可能早地将编码应用到STDOUT和STDERR。</target>
        </trans-unit>
        <trans-unit id="32a8b32d9a6fd88cc288ea2d28ee5e2eb22aa577" translate="yes" xml:space="preserve">
          <source>One would use either of these:</source>
          <target state="translated">人们会使用其中的一种。</target>
        </trans-unit>
        <trans-unit id="d2c29e5eed5921eb0c039672d0a71cd9e82eb212" translate="yes" xml:space="preserve">
          <source>One-Liner Command tips</source>
          <target state="translated">单行命令提示</target>
        </trans-unit>
        <trans-unit id="c123784569a1603a8fb4810445cb2d1918c306b4" translate="yes" xml:space="preserve">
          <source>One-argument system() (see &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;), exec() (see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;) with redirection or shell meta-characters;</source>
          <target state="translated">具有重定向或shell元字符的一参数system（）（请参阅&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;），exec（）（请参阅&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;）；</target>
        </trans-unit>
        <trans-unit id="486e0bed310a26c3d92d0d575fbba324cf28a58e" translate="yes" xml:space="preserve">
          <source>One-line BLOCK may be put on one line, including curlies.</source>
          <target state="translated">单行BLOCK可以放在一条线上,包括卷线。</target>
        </trans-unit>
        <trans-unit id="58784e03024491cc3bfab913b657f51ddfe4ea02" translate="yes" xml:space="preserve">
          <source>One-way visibility means these firewalls try to make themselves invisible to users inside the firewall. An FTP data connection is normally created by sending your IP address to the remote server and then listening for the return connection. But the remote server will not be able to connect to you because of the firewall. For these types of firewall, FTP connections need to be done in a passive mode.</source>
          <target state="translated">单向可见性是指这些防火墙尽量使自己对防火墙内的用户不可见。FTP数据连接通常是通过向远程服务器发送你的IP地址,然后监听返回的连接来建立的。但由于防火墙的存在,远程服务器将无法与你连接。对于这种类型的防火墙,FTP连接需要在被动模式下进行。</target>
        </trans-unit>
        <trans-unit id="c61018f75253ce1e2ca9788d8ce3f56d39e963aa" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;#define&lt;/code&gt; symbols get translated; you must still correctly pack up your own arguments to pass as args for locking functions, etc.</source>
          <target state="translated">仅 &lt;code&gt;#define&lt;/code&gt; 符号得到翻译；您仍然必须正确打包自己的参数以将其作为args传递给锁定函数等。</target>
        </trans-unit>
        <trans-unit id="54e17eb2662bd037dd06b791727211df88880e9a" translate="yes" xml:space="preserve">
          <source>Only Intel C++ Compiler v12.1 has been tested. Other versions probably will work. Using Intel C++ Compiler instead of Visual C has the benefit of C99 compatibility which is needed by some CPAN XS modules, while maintaining compatibility with Visual C object code and Visual C debugging infrastructure unlike GCC.</source>
          <target state="translated">只测试了Intel C++Compiler v12.1。其他版本可能也可以使用。使用Intel C++Compiler代替Visual C的好处是可以兼容C99,这也是一些CPAN XS模块所需要的,同时与Visual C对象代码和Visual C调试基础架构保持兼容,而不像GCC。</target>
        </trans-unit>
        <trans-unit id="833cc9382a3040aac18b72415747288176c0756d" translate="yes" xml:space="preserve">
          <source>Only available in 5.9 and later.</source>
          <target state="translated">仅在5.9及以后的版本中可用。</target>
        </trans-unit>
        <trans-unit id="791c96ad0d89f4c2a397055a16ea908da3689beb" translate="yes" xml:space="preserve">
          <source>Only certain operations originating outside Perl should be affected, as follows:</source>
          <target state="translated">只有某些源自Perl之外的操作才会受到影响,具体如下:</target>
        </trans-unit>
        <trans-unit id="332e2ea6f0f288093c9c025ee61a2877052c734b" translate="yes" xml:space="preserve">
          <source>Only good for changing &quot;owner&quot; and &quot;other&quot; read-write access. (RISC OS)</source>
          <target state="translated">只适用于改变 &quot;所有者 &quot;和 &quot;其他 &quot;读写访问。(RISC OS)</target>
        </trans-unit>
        <trans-unit id="066c19c4ab7873f5036df4d41c91cf9966174fcb" translate="yes" xml:space="preserve">
          <source>Only good for changing &quot;owner&quot; read-write access, &quot;group&quot;, and &quot;other&quot; bits are meaningless. (Win32)</source>
          <target state="translated">只适合改变 &quot;所有者 &quot;的读写权限,&quot;组&quot;,&quot;其他 &quot;位没有意义。(Win32)</target>
        </trans-unit>
        <trans-unit id="e35c0d1762bd110103b5f686e3235899e75efbd0" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid between the braces. If an invalid character is encountered, a warning will be issued and the invalid character and all subsequent characters (valid or invalid) within the braces will be discarded.</source>
          <target state="translated">只有十六进制数字在方括号之间有效。如果遇到无效字符,将发出警告,无效字符和括号内所有后续字符(有效或无效)将被丢弃。</target>
        </trans-unit>
        <trans-unit id="575a185473fa8007dc4a01bd9786576149895549" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid following &lt;code&gt;\x&lt;/code&gt; . When &lt;code&gt;\x&lt;/code&gt; is followed by fewer than two valid digits, any valid digits will be zero-padded. This means that &lt;code&gt;\x7&lt;/code&gt; will be interpreted as &lt;code&gt;\x07&lt;/code&gt; , and a lone &lt;code&gt;&quot;\x&quot;&lt;/code&gt; will be interpreted as &lt;code&gt;\x00&lt;/code&gt; . Except at the end of a string, having fewer than two valid digits will result in a warning. Note that although the warning says the illegal character is ignored, it is only ignored as part of the escape and will still be used as the subsequent character in the string. For example:</source>
          <target state="translated">&lt;code&gt;\x&lt;/code&gt; 之后仅十六进制数字有效。当 &lt;code&gt;\x&lt;/code&gt; 后跟少于两个有效数字时，任何有效数字都将补零。这意味着 &lt;code&gt;\x7&lt;/code&gt; 将被解释为 &lt;code&gt;\x07&lt;/code&gt; ，而单独的 &lt;code&gt;&quot;\x&quot;&lt;/code&gt; 将被解释为 &lt;code&gt;\x00&lt;/code&gt; 。除字符串末尾外，少于两个有效数字将导致警告。请注意，尽管警告指出非法字符将被忽略，但它仅作为转义的一部分而被忽略，仍将用作字符串中的后续字符。例如：</target>
        </trans-unit>
        <trans-unit id="6fefd95a29f89da3d95e7f9f02daa15254f112a5" translate="yes" xml:space="preserve">
          <source>Only identifiers starting with letters (or underscore) are stored in a package's symbol table. All other symbols are kept in package &lt;code&gt;main&lt;/code&gt; , including all punctuation variables, like $_. In addition, when unqualified, the identifiers STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC, and SIG are forced to be in package &lt;code&gt;main&lt;/code&gt; , even when used for other purposes than their built-in ones. If you have a package called &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, then you can't use the qualified form of an identifier because it would be instead interpreted as a pattern match, a substitution, or a transliteration.</source>
          <target state="translated">包的符号表中仅存储以字母（或下划线）开头的标识符。所有其他符号都保留在包 &lt;code&gt;main&lt;/code&gt; 中，包括所有标点符号变量，例如$ _。另外，如果不合格，则标识符STDIN，STDOUT，STDERR，ARGV，ARGVOUT，ENV，INC和SIG被强制放入包 &lt;code&gt;main&lt;/code&gt; 中，即使用于内置目的之外的其他目的。如果您有一个名为 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 的程序包，则不能使用标识符的限定形式，因为它会被解释为模式匹配，替换或音译。</target>
        </trans-unit>
        <trans-unit id="9758de0e100772430c6fab7d629b550064e3e906" translate="yes" xml:space="preserve">
          <source>Only implemented on sockets. (Win32, VMS)</source>
          <target state="translated">仅在套接字上实现。(Win32,VMS)</target>
        </trans-unit>
        <trans-unit id="59e3f78d233739ccaf48b169b4ca0ebaefa1c7ab" translate="yes" xml:space="preserve">
          <source>Only in very early releases; is a subset of</source>
          <target state="translated">只有在非常早期的版本中才会出现;是一个子集。</target>
        </trans-unit>
        <trans-unit id="e3b46eafe2952d2a80f0f05636b70051fd116c6a" translate="yes" xml:space="preserve">
          <source>Only in very rare circumstances should code need to be dealing in Unicode (as opposed to native) code points. In those few cases, use &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">仅在极少数情况下，才需要使用Unicode（而不是本机）代码点来处理代码。在这几种情况下，请改用 &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7a2ea2fb860587376b8c211541f4f73f5bfc66a" translate="yes" xml:space="preserve">
          <source>Only log errors:</source>
          <target state="translated">只记录错误。</target>
        </trans-unit>
        <trans-unit id="150ec79437779628315de700ea569bc7019ae33a" translate="yes" xml:space="preserve">
          <source>Only meaningful if PADNAMEt_OUTER is set.</source>
          <target state="translated">只有当PADNAMEt_OUTER被设置时才有意义。</target>
        </trans-unit>
        <trans-unit id="b3938c3e89a8c33d91a1c3ac566ca87a5a31bade" translate="yes" xml:space="preserve">
          <source>Only my/our variable slots get valid names. The rest are op targets/GVs/constants which are statically allocated or resolved at compile time. These don't have names by which they can be looked up from Perl code at run time through eval&quot;&quot; the way my/our variables can be. Since they can't be looked up by &quot;name&quot; but only by their index allocated at compile time (which is usually in PL_op-&amp;gt;op_targ), wasting a name SV for them doesn't make sense.</source>
          <target state="translated">只有我/我们的可变插槽会获得有效的名称。其余的是操作目标/ GV /常量，它们在编译时静态分配或解析。这些没有名称，可以在运行时通过我的/我们的变量通过eval&amp;ldquo;''从Perl代码中查找它们。由于不能通过&amp;ldquo;名称&amp;rdquo;来查找它们，而只能通过在编译时分配的索引来查找它们（通常在PL_op-&amp;gt; op_targ中），因此为它们浪费名称SV是没有意义的。</target>
        </trans-unit>
        <trans-unit id="1f33cd4a2033d06e1657cc72bf00ffb7bbc8903a" translate="yes" xml:space="preserve">
          <source>Only on VMS (where there is no ambiguity between the file and directory portions of a path) and AmigaOS (possibly due to an implementation quirk in this module) does &lt;code&gt;dirname()&lt;/code&gt; work like &lt;code&gt;fileparse($path)&lt;/code&gt; , returning just the $dirs.</source>
          <target state="translated">仅在VMS（路径的文件和目录部分之间没有歧义）和AmigaOS（可能由于此模块中的实现古怪）上， &lt;code&gt;dirname()&lt;/code&gt; 就像 &lt;code&gt;fileparse($path)&lt;/code&gt; 一样工作，仅返回$ dirs。</target>
        </trans-unit>
        <trans-unit id="cb371934ef388875a4c4834fa50d202d61748f1c" translate="yes" xml:space="preserve">
          <source>Only one encoding is allowed. If you combine modules in a program that have different encodings, only one will be actually used.</source>
          <target state="translated">只允许使用一种编码。如果你在一个程序中组合了具有不同编码的模块,那么实际上只会使用一种编码。</target>
        </trans-unit>
        <trans-unit id="99a4e5aa3778d9b7cf73bb7582fb4140a87cc1e7" translate="yes" xml:space="preserve">
          <source>Only one timer may be counting at once. Each call disables the previous timer, and an argument of &lt;code&gt;0&lt;/code&gt; may be supplied to cancel the previous timer without starting a new one. The returned value is the amount of time remaining on the previous timer.</source>
          <target state="translated">一次只能计数一个计时器。每次调用都会禁用前一个计时器，并且可以提供一个参数 &lt;code&gt;0&lt;/code&gt; 来取消前一个计时器而无需启动新的计时器。返回的值是前一个计时器上剩余的时间。</target>
        </trans-unit>
        <trans-unit id="f44c9ad6ed1548b5f164387565fa3e8cb708d77b" translate="yes" xml:space="preserve">
          <source>Only package variables (globals, even if localized) are visible to symbolic references. Lexical variables (declared with my()) aren't in a symbol table, and thus are invisible to this mechanism. For example:</source>
          <target state="translated">只有包变量(globals,即使是本地化的)对符号引用是可见的。词法变量(用my()声明)不在符号表中,因此对这个机制是不可见的。例如</target>
        </trans-unit>
        <trans-unit id="8a4fbadaeb2851f2ac1b0ed5194eefd55b4c5de6" translate="yes" xml:space="preserve">
          <source>Only read-accesses (via fetching the value or &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;) result in calls to the functions; the modify-accesses are performed as on a normal hash.</source>
          <target state="translated">只有读取访问（通过获取值或 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; ）才导致对函数的调用。修改访问的执行与普通哈希相同。</target>
        </trans-unit>
        <trans-unit id="b7947c4bc8660c246e83d1a75c7b2184fd12d7e5" translate="yes" xml:space="preserve">
          <source>Only reliable on sockets. (RISC OS)</source>
          <target state="translated">仅在插座上可靠。(RISC OS)</target>
        </trans-unit>
        <trans-unit id="fdb6f92993012f8b0d4ace849f814451bcfe4e88" translate="yes" xml:space="preserve">
          <source>Only some of these are used by the standard styles, the others are provided for you to delve into optree mechanics, should you wish to add a new style (see &lt;a href=&quot;#add_style&quot;&gt;add_style&lt;/a&gt; below) that uses them. You can also add new ones using &lt;a href=&quot;#add_callback&quot;&gt;add_callback&lt;/a&gt;.</source>
          <target state="translated">标准样式仅使用其中一些样式，如果您希望添加使用它们的新样式（请参见下面的&lt;a href=&quot;#add_style&quot;&gt;add_style&lt;/a&gt;），则提供了其他样式供您深入研究optree机制。您也可以使用&lt;a href=&quot;#add_callback&quot;&gt;add_callback&lt;/a&gt;添加新对象。</target>
        </trans-unit>
        <trans-unit id="fe3b6a74b3cb931875055e55d8dd7ade28775580" translate="yes" xml:space="preserve">
          <source>Only text files containing at least one valid POD command are found.</source>
          <target state="translated">只找到至少包含一条有效的POD命令的文本文件。</target>
        </trans-unit>
        <trans-unit id="d9f9d19343c8e9d3fc7cfa076da595c837a27fd3" translate="yes" xml:space="preserve">
          <source>Only the INPUT part of this is implemented (Perl to XSUB) and there are no known users in core or on CPAN.</source>
          <target state="translated">只有INPUT部分实现了(Perl转XSUB),核心和CPAN上没有已知的用户。</target>
        </trans-unit>
        <trans-unit id="3e92fe265d981838f6731ee2a1313d924147a101" translate="yes" xml:space="preserve">
          <source>Only the best match for &lt;code&gt;S&lt;/code&gt; is considered. (This is important only if &lt;code&gt;S&lt;/code&gt; has capturing parentheses, and backreferences are used somewhere else in the whole regular expression.)</source>
          <target state="translated">仅考虑与 &lt;code&gt;S&lt;/code&gt; 的最佳匹配。（这仅在 &lt;code&gt;S&lt;/code&gt; 具有捕获括号并且在整个正则表达式的其他位置使用反向引用时才重要。）</target>
        </trans-unit>
        <trans-unit id="8e81698472dd458b4e2c811d33c204c45a731d7f" translate="yes" xml:space="preserve">
          <source>Only the latest runtime is supported, currently &lt;code&gt;0.9d fix 03&lt;/code&gt;. Perl may run under earlier versions of EMX, but this is not tested.</source>
          <target state="translated">仅支持最新的运行时，当前为 &lt;code&gt;0.9d fix 03&lt;/code&gt; 。Perl可以在EMX的早期版本下运行，但这未经测试。</target>
        </trans-unit>
        <trans-unit id="ffed3ab3981beea3a9602d82e26d788b9e9c1484" translate="yes" xml:space="preserve">
          <source>Only the modification time is updated. (VMS, RISC OS)</source>
          <target state="translated">只更新修改时间。(VMS,RISC OS)</target>
        </trans-unit>
        <trans-unit id="9aa8446a580db25edb8f05217d7fb57147e13abf" translate="yes" xml:space="preserve">
          <source>Only up to Perl 5.9.4</source>
          <target state="translated">仅支持Perl 5.9.4</target>
        </trans-unit>
        <trans-unit id="ac1ac5484f948b783774a56425a6df37a8f81a3b" translate="yes" xml:space="preserve">
          <source>Only valid on r-magic, returns the integer value of the REGEX stored in the MAGIC.</source>
          <target state="translated">仅在r-magic上有效,返回存储在MAGIC中的REGEX的整数值。</target>
        </trans-unit>
        <trans-unit id="9f66fc81372c8ac766a246f4baea414733aad7cf" translate="yes" xml:space="preserve">
          <source>Only valid on r-magic, returns the string that generated the regexp.</source>
          <target state="translated">仅在r-magic上有效,返回生成regexp的字符串。</target>
        </trans-unit>
        <trans-unit id="a61aeee0d09958da7f9004eaa2f24e389c377add" translate="yes" xml:space="preserve">
          <source>Only when perl was compiled with ithreads.</source>
          <target state="translated">只有当perl用ithreads编译时才会出现。</target>
        </trans-unit>
        <trans-unit id="cd0ef3273488ddac67311854e00313faa5aef30e" translate="yes" xml:space="preserve">
          <source>Oodles of very useful information in there - this seems to be the way forward.</source>
          <target state="translated">里面有很多非常有用的信息--这似乎是前进的方向。</target>
        </trans-unit>
        <trans-unit id="95ff9f7a98d97e5bb7dd5d8797ddd23ecbc3a49a" translate="yes" xml:space="preserve">
          <source>Oops, we forgot one thing: what if there are spaces at the start of the pattern? &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;  U*&quot;, @stuff)&lt;/code&gt; will have &lt;code&gt;U&lt;/code&gt; as the first active character, even though it's not the first thing in the pattern. In this case, we have to advance &lt;code&gt;patcopy&lt;/code&gt; along with &lt;code&gt;pat&lt;/code&gt; when we see spaces:</source>
          <target state="translated">糟糕，我们忘记了一件事：如果模式开头有空格怎么办？ &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot; U*&quot;, @stuff)&lt;/code&gt; 将 &lt;code&gt;U&lt;/code&gt; 作为第一个活动字符，即使它不是模式中的第一件事。在这种情况下，当我们看到空格时，我们必须将 &lt;code&gt;patcopy&lt;/code&gt; 和 &lt;code&gt;pat&lt;/code&gt; 一起推进：</target>
        </trans-unit>
        <trans-unit id="74d23243f911dfb26f7142c0a3c3910d6d1436bc" translate="yes" xml:space="preserve">
          <source>Opcode</source>
          <target state="translated">Opcode</target>
        </trans-unit>
        <trans-unit id="d74efeac75c3ed1e29e1ef5d2a48fa327033703a" translate="yes" xml:space="preserve">
          <source>Opcode - Disable named opcodes when compiling perl code</source>
          <target state="translated">Opcode-编译perl代码时禁用命名的操作码。</target>
        </trans-unit>
        <trans-unit id="f07e565d51e16d912b38ef0d870eb764e49b25e3" translate="yes" xml:space="preserve">
          <source>Opcode Functions</source>
          <target state="translated">操作码功能</target>
        </trans-unit>
        <trans-unit id="96b61e5d9d0edd94f6948898f1398f5d478335a2" translate="yes" xml:space="preserve">
          <source>Open &quot;membername&quot; from the zip file for reading.</source>
          <target state="translated">打开压缩文件中的 &quot;会员名 &quot;进行阅读。</target>
        </trans-unit>
        <trans-unit id="55f7ee4c6a28ca478d6d447371d4c70238f47b16" translate="yes" xml:space="preserve">
          <source>Open /dev/tty and use the TIOCNOTTY ioctl on it. See</source>
          <target state="translated">打开/dev/tty并在上面使用TIOCNOTTY ioctl。请看</target>
        </trans-unit>
        <trans-unit id="bdb6e0b133b1b1b5b97afd41a0d0173daaa4add6" translate="yes" xml:space="preserve">
          <source>Open Edition (UNIX System Services) from V2R8 onward does support #!/path/to/perl script invocation. There is a PTF available from IBM for V2R7 that will allow shell/kernel support for #!. USS releases prior to V2R7 did not support the #! means of script invocation. If you are running V2R6 or earlier then see:</source>
          <target state="translated">V2R8以后的开放版(UNIX系统服务)确实支持#!/path/to/perl脚本调用。IBM公司为V2R7提供了一个PTF,它将允许shell/kernel支持#!。V2R7之前的USS版本不支持#!的脚本调用方式。如果你正在运行V2R6或更早的版本,那么请看。</target>
        </trans-unit>
        <trans-unit id="6a72f9cc67788da43d43bb9ed1f39ccdfc57b884" translate="yes" xml:space="preserve">
          <source>Open Perl IDE is an integrated development environment for writing and debugging Perl scripts with ActiveState's ActivePerl distribution under Windows 95/98/NT/2000.</source>
          <target state="translated">Open Perl IDE是一个集成的开发环境,用于在Windows 95/98/NT/2000下使用ActiveState的ActivePerl发行版编写和调试Perl脚本。</target>
        </trans-unit>
        <trans-unit id="23e95096990f8472afd6cb3709ce6af6451d33e6" translate="yes" xml:space="preserve">
          <source>Open a directory for reading.</source>
          <target state="translated">打开一个目录进行阅读。</target>
        </trans-unit>
        <trans-unit id="8ad49f69af5decd196c780b9f3d0aaa3e3816d7b" translate="yes" xml:space="preserve">
          <source>Open a file for read and write.</source>
          <target state="translated">打开一个文件进行读写。</target>
        </trans-unit>
        <trans-unit id="1e59fee2b2d0c9f3865876e8e0e389d326d3f7c1" translate="yes" xml:space="preserve">
          <source>Open a file for reading for writing. This returns file descriptors, not Perl filehandles. Use &lt;code&gt;POSIX::close&lt;/code&gt; to close the file.</source>
          <target state="translated">打开一个文件以进行读取以进行写入。这将返回文件描述符，而不是Perl文件句柄。使用 &lt;code&gt;POSIX::close&lt;/code&gt; 关闭文件。</target>
        </trans-unit>
        <trans-unit id="6c23e6c0a506e51b8807fe030bb649eaa2c7d5d5" translate="yes" xml:space="preserve">
          <source>Open a file for write, with truncation.</source>
          <target state="translated">打开一个文件进行写入,并进行截断。</target>
        </trans-unit>
        <trans-unit id="4308ff2808cb74655d1f6985fb86c3f779077365" translate="yes" xml:space="preserve">
          <source>Open a file read-only with mode 0666.</source>
          <target state="translated">用模式0666打开一个只读文件。</target>
        </trans-unit>
        <trans-unit id="83b3247daf1ae38653a1c2f6dc56f1f4dd823340" translate="yes" xml:space="preserve">
          <source>Open a process for both reading and writing using open2()</source>
          <target state="translated">使用open2()打开一个读写进程。</target>
        </trans-unit>
        <trans-unit id="2f8a8512d160e2040075be8a77906336494c9074" translate="yes" xml:space="preserve">
          <source>Open a process for reading, writing, and error handling using open3()</source>
          <target state="translated">使用open3()打开一个进程进行读写和错误处理。</target>
        </trans-unit>
        <trans-unit id="79ce744f7faf84a934a5966a77055041e905f34c" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Open成功则返回非零值，否则返回未定义的值。如果 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 涉及管道，则返回值恰好是子流程的pid。</target>
        </trans-unit>
        <trans-unit id="78b623ce85a0de7052165209a2216ebe49f4e867" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Open成功则返回非零值，否则返回未定义的值。如果 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 涉及管道，则返回值恰好是子流程的pid。</target>
        </trans-unit>
        <trans-unit id="47834b64146be82f867d9923797633975d9cd92f" translate="yes" xml:space="preserve">
          <source>Open should (perhaps indirectly) call &lt;code&gt;PerlIO_allocate()&lt;/code&gt; to allocate a slot in the table and associate it with the layers information for the opened file, by calling &lt;code&gt;PerlIO_push&lt;/code&gt; . The</source>
          <target state="translated">Open应该（也许间接地）调用 &lt;code&gt;PerlIO_allocate()&lt;/code&gt; 在表中分配一个插槽，并通过调用 &lt;code&gt;PerlIO_push&lt;/code&gt; 将其与打开文件的层信息相关联。的</target>
        </trans-unit>
        <trans-unit id="fa04c7c6f525f721026d1ba438790f3fcc864164" translate="yes" xml:space="preserve">
          <source>Open the syslog with options &lt;code&gt;ndelay&lt;/code&gt; and &lt;code&gt;pid&lt;/code&gt; , and with facility &lt;code&gt;LOCAL0&lt;/code&gt; :</source>
          <target state="translated">使用选项 &lt;code&gt;ndelay&lt;/code&gt; 和 &lt;code&gt;pid&lt;/code&gt; 以及设施 &lt;code&gt;LOCAL0&lt;/code&gt; 打开系统日志：</target>
        </trans-unit>
        <trans-unit id="49536a6420d53dc725b117e3d37bfc34dfb9bef1" translate="yes" xml:space="preserve">
          <source>OpenBSD core dumps from getprotobyname_r and getservbyname_r with ithreads</source>
          <target state="translated">OpenBSD core dumps from getprotobyname_r and getservbyname_r with ithreads.</target>
        </trans-unit>
        <trans-unit id="d32dc42d00fa4f78f0a59f030ed60cd6a30b3295" translate="yes" xml:space="preserve">
          <source>OpenVMS Alpha v7.3-1 and later and all version of OpenVMS I64 support case sensitivity as a process setting (see &lt;code&gt;SET PROCESS
/CASE_LOOKUP=SENSITIVE&lt;/code&gt; ). Perl does not currently support case sensitivity on VMS, but it may in the future, so Perl programs should use the &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; method to determine the state, and not the &lt;code&gt;$^O&lt;/code&gt; variable.</source>
          <target state="translated">OpenVMS Alpha v7.3-1和更高版本以及所有版本的OpenVMS I64支持区分大小写作为过程设置（请参阅 &lt;code&gt;SET PROCESS /CASE_LOOKUP=SENSITIVE&lt;/code&gt; ）。Perl当前不支持VMS区分大小写，但是将来可能会支持，因此Perl程序应使用 &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; 方法确定状态，而不是 &lt;code&gt;$^O&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="580bd0fefd9022c163462e267d5f62605679e1bf" translate="yes" xml:space="preserve">
          <source>Opening Binary Files</source>
          <target state="translated">打开二进制文件</target>
        </trans-unit>
        <trans-unit id="3b6c1a6dbd679781e98b430deca927902564168e" translate="yes" xml:space="preserve">
          <source>Opening Pipes</source>
          <target state="translated">开启管道</target>
        </trans-unit>
        <trans-unit id="97614657c24973c63e30d6aea12f0ee16c28cc0b" translate="yes" xml:space="preserve">
          <source>Opening Text Files</source>
          <target state="translated">打开文本文件</target>
        </trans-unit>
        <trans-unit id="36680b4c4dae060cef49428930207438c7efaa37" translate="yes" xml:space="preserve">
          <source>Opening Text Files for Reading</source>
          <target state="translated">打开文本文件进行阅读</target>
        </trans-unit>
        <trans-unit id="2a72037dbe3a876109b6617803140785c781433b" translate="yes" xml:space="preserve">
          <source>Opening Text Files for Writing</source>
          <target state="translated">打开文本文件进行写作</target>
        </trans-unit>
        <trans-unit id="d41c1a93b08d5c6da84630f4e7549a5cfa0c9f29" translate="yes" xml:space="preserve">
          <source>Opening a Berkeley DB Database File</source>
          <target state="translated">打开Berkeley DB数据库文件</target>
        </trans-unit>
        <trans-unit id="c901450d25c1b4adffc158756d930772312effed" translate="yes" xml:space="preserve">
          <source>Opening a process does not automatically flush output handles on some platforms. (SunOS, Solaris, HP-UX)</source>
          <target state="translated">在某些平台上,打开一个进程不会自动刷新输出句柄。(SunOS,Solaris,HP-UX)</target>
        </trans-unit>
        <trans-unit id="b294c249cb9dd744fe8333a0cf9a3eaca337d759" translate="yes" xml:space="preserve">
          <source>Opening and setup functions</source>
          <target state="translated">打开和设置功能</target>
        </trans-unit>
        <trans-unit id="9d1b0daa9340247fc5dd5775b7b3c96ab82ed183" translate="yes" xml:space="preserve">
          <source>Opening brace lines up with &quot;if&quot; when conditional spans multiple lines; should be at end-of-line otherwise</source>
          <target state="translated">当条件跨越多行时,用 &quot;if &quot;开头括号行,否则应在行尾。</target>
        </trans-unit>
        <trans-unit id="4a1d6b2927f0e3d3a000bd5c08d3176bb52e234e" translate="yes" xml:space="preserve">
          <source>Opening bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">轻量级回调的开括号。请参阅&lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcall中的轻量级回调&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2922ae0d4b2356e8683f8338a16e139ec4c04e6a" translate="yes" xml:space="preserve">
          <source>Opening bracket for arguments on a callback. See &lt;code&gt;PUTBACK&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">回调参数的左括号。请参阅 &lt;code&gt;PUTBACK&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0cd04a850fb6ef4b1c1ae0773c22c62016e5236" translate="yes" xml:space="preserve">
          <source>Opening bracket for temporaries on a callback. See &lt;code&gt;FREETMPS&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">回调临时成员的开括号。请参阅 &lt;code&gt;FREETMPS&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3379b419b90643ab2744dfbdcecf5edbb46257a1" translate="yes" xml:space="preserve">
          <source>Opening bracket on a callback. See &lt;code&gt;LEAVE&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">回调的左括号。参见 &lt;code&gt;LEAVE&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fcb5320c0f77aa06e6c4f3f19f91a0a627e401dd" translate="yes" xml:space="preserve">
          <source>Opening curly on same line as keyword, if possible, otherwise line up.</source>
          <target state="translated">开头大写与关键词在同一行,如有可能,否则要排队。</target>
        </trans-unit>
        <trans-unit id="702f344a10799adb9c373ae43617c29a1d640fe4" translate="yes" xml:space="preserve">
          <source>Opening files for read-write is currently not supported if they use stdio (normal perl file handles).</source>
          <target state="translated">如果使用stdio(普通的perl文件句柄),目前不支持打开文件进行读写。</target>
        </trans-unit>
        <trans-unit id="f85c9c937148eb202d62793f91340ba09b2f7a5e" translate="yes" xml:space="preserve">
          <source>Opening the data file in write-only or append mode is not supported.</source>
          <target state="translated">不支持以只写或追加模式打开数据文件。</target>
        </trans-unit>
        <trans-unit id="c745d61fd7e06451beaeff422ae86fd1baafa519" translate="yes" xml:space="preserve">
          <source>Opens &lt;code&gt;$output&lt;/code&gt; in append mode.</source>
          <target state="translated">在追加模式下打开 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83d174f108cd7d61c427811f31c1c3a17b3fd039" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. DIRHANDLEs have their own namespace separate from FILEHANDLEs.</source>
          <target state="translated">打开一个名为EXPR的目录，以供 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; 处理。如果成功，则返回true。 DIRHANDLE可以是一个表达式，其值可以用作间接dirhandle，通常是实际dirhandle名称。如果DIRHANDLE是未定义的标量变量（或数组或哈希元素），则为该变量分配对新匿名目录句柄的引用。也就是说，它是自动生存的。 DIRHANDLE具有与FILEHANDLE分开的名称空间。</target>
        </trans-unit>
        <trans-unit id="bde0bd94d408d74305c3ef236f8e210809c61889" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. DIRHANDLEs have their own namespace separate from FILEHANDLEs.</source>
          <target state="translated">打开一个名为EXPR的目录，以供 &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; 处理。如果成功，则返回true。 DIRHANDLE可以是一个表达式，其值可以用作间接dirhandle，通常是实际dirhandle名称。如果DIRHANDLE是未定义的标量变量（或数组或哈希元素），则为该变量分配对新匿名目录句柄的引用。也就是说，它是自动生存的。 DIRHANDLE具有与FILEHANDLE分开的名称空间。</target>
        </trans-unit>
        <trans-unit id="ef6eec3f73e02b66c5dbdd58e24c78d1b02394cb" translate="yes" xml:space="preserve">
          <source>Opens a pair of connected pipes like the corresponding system call. Note that if you set up a loop of piped processes, deadlock can occur unless you are very careful. In addition, note that Perl's pipes use IO buffering, so you may need to set &lt;code&gt;$|&lt;/code&gt; to flush your WRITEHANDLE after each command, depending on the application.</source>
          <target state="translated">打开一对连接的管道，如相应的系统调用。请注意，如果您设置了管道处理循环，除非非常小心，否则可能会发生死锁。另外，请注意，Perl的管道使用IO缓冲，因此您可能需要设置 &lt;code&gt;$|&lt;/code&gt; 在每个命令之后刷新WRITEHANDLE，具体取决于应用程序。</target>
        </trans-unit>
        <trans-unit id="97d9deba78acd708222827724c50fc7000bf21a2" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">打开指定种类的套接字，并将其附加到文件句柄SOCKET。指定的DOMAIN，TYPE和PROTOCOL与具有相同名称的syscall相同。您应该首先 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; 来导入正确的定义。请参阅&lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="1bf5e36d7b7be8ff46fbdc02b28950f2a5493007" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">打开指定种类的套接字，并将其附加到文件句柄SOCKET。指定的DOMAIN，TYPE和PROTOCOL与具有相同名称的syscall相同。您应该首先 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; 来导入正确的定义。请参阅&lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="f043104d316702a10e0ee9e23884fe89eeee7102" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by EXPR, and associates it with FILEHANDLE.</source>
          <target state="translated">打开文件名由EXPR给出的文件,并将其与FILEHANDLE关联。</target>
        </trans-unit>
        <trans-unit id="f8d3156ec9740e3cf785b92426587c9913bf7a48" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by FILENAME, and associates it with FILEHANDLE. If FILEHANDLE is an expression, its value is used as the real filehandle wanted; an undefined scalar will be suitably autovivified. This function calls the underlying operating system's</source>
          <target state="translated">打开文件名由FILENAME给出的文件,并将其与FILEHANDLE关联。如果FILEHANDLE是一个表达式,那么它的值将被用作真正的文件柄;一个未定义的标量将被适当地自动转换。这个函数调用底层操作系统的</target>
        </trans-unit>
        <trans-unit id="4d5a806f4d052ec496b3b922107438a0577f84fc" translate="yes" xml:space="preserve">
          <source>Opens the syslog. &lt;code&gt;$ident&lt;/code&gt; is prepended to every message. &lt;code&gt;$logopt&lt;/code&gt; contains zero or more of the options detailed below. &lt;code&gt;$facility&lt;/code&gt; specifies the part of the system to report about, for example &lt;code&gt;LOG_USER&lt;/code&gt; or &lt;code&gt;LOG_LOCAL0&lt;/code&gt; : see &lt;a href=&quot;#Facilities&quot;&gt;Facilities&lt;/a&gt; for a list of well-known facilities, and your &lt;code&gt;syslog(3)&lt;/code&gt; documentation for the facilities available in your system. Check &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; for useful links. Facility can be given as a string or a numeric macro.</source>
          <target state="translated">打开系统日志。 &lt;code&gt;$ident&lt;/code&gt; 在每个消息之前。 &lt;code&gt;$logopt&lt;/code&gt; 包含零个或多个下面详细说明的选项。 &lt;code&gt;$facility&lt;/code&gt; 指定要报告的系统部分，例如 &lt;code&gt;LOG_USER&lt;/code&gt; 或 &lt;code&gt;LOG_LOCAL0&lt;/code&gt; ：请参阅&lt;a href=&quot;#Facilities&quot;&gt;设施&lt;/a&gt;以获取知名设施的列表，以及有关系统中可用设施的 &lt;code&gt;syslog(3)&lt;/code&gt; 文档。还请&lt;a href=&quot;#SEE-ALSO&quot;&gt;参阅&lt;/a&gt; &amp;ldquo;有用的链接&amp;rdquo;。设施可以以字符串或数字宏的形式给出。</target>
        </trans-unit>
        <trans-unit id="d7befdfbc60eb47b3289957505fb12ce62daabea" translate="yes" xml:space="preserve">
          <source>Operating System Interfaces</source>
          <target state="translated">操作系统接口</target>
        </trans-unit>
        <trans-unit id="b9967a65c2c4c5007de8b77bf65865521f0d26c6" translate="yes" xml:space="preserve">
          <source>Operating on references to hashes.</source>
          <target state="translated">对哈希的引用进行操作。</target>
        </trans-unit>
        <trans-unit id="c28848b2a51553304abcd6de3ae0236ffb496efe" translate="yes" xml:space="preserve">
          <source>Operations with overloaded operators preserve the arguments which is exactly what you expect.</source>
          <target state="translated">使用重载操作符的操作会保留参数,这正是你所期望的。</target>
        </trans-unit>
        <trans-unit id="d4e4327f6fb8077a49e03daa6c0ea206ecb5c16a" translate="yes" xml:space="preserve">
          <source>Operations with overloaded operators preserve the arguments, which is exactly what you expect.</source>
          <target state="translated">使用重载操作符的操作会保留参数,这正是你所期望的。</target>
        </trans-unit>
        <trans-unit id="f921f14a57cf5d524fbd5fad00e7ed999feb448d" translate="yes" xml:space="preserve">
          <source>Operator Names and Operator Lists</source>
          <target state="translated">操作员名称和操作员列表</target>
        </trans-unit>
        <trans-unit id="f299c884a708c75ca75144e361f0c5cf282b235f" translate="yes" xml:space="preserve">
          <source>Operator Overloading</source>
          <target state="translated">操作员超载</target>
        </trans-unit>
        <trans-unit id="53d6250055dd8231245476710d174685174b7d89" translate="yes" xml:space="preserve">
          <source>Operator Precedence and Associativity</source>
          <target state="translated">操作者优先和关联性</target>
        </trans-unit>
        <trans-unit id="11c9953040dd3157f9326929003c9899b7cffb21" translate="yes" xml:space="preserve">
          <source>Operator associativity</source>
          <target state="translated">操作员关联性</target>
        </trans-unit>
        <trans-unit id="08ca8c19d61f0facd586cd4f482f39a253b12167" translate="yes" xml:space="preserve">
          <source>Operator implementations (the values) can be subroutines, references to subroutines, or anonymous subroutines - in other words, anything legal inside a &lt;code&gt;&amp;amp;{ ... }&lt;/code&gt; call. Values specified as strings are interpreted as method names. Thus</source>
          <target state="translated">运算符实现（值）可以是子例程，对子例程的引用或匿名子例程-换句话说，在 &lt;code&gt;&amp;amp;{ ... }&lt;/code&gt; 调用中合法的任何内容。指定为字符串的值将解释为方法名称。从而</target>
        </trans-unit>
        <trans-unit id="4f99a8916efac564a63d50ce560cad0dd70e1540" translate="yes" xml:space="preserve">
          <source>Operator names are typically small lowercase words like enterloop, leaveloop, last, next, redo etc. Sometimes they are rather cryptic like gv2cv, i_ncmp and ftsvtx.</source>
          <target state="translated">操作符名称通常是小写的单词,如enterloop、leaveloop、last、next、redo等。有时它们是相当神秘的,比如gv2cv、i_ncmp和ftsvtx。</target>
        </trans-unit>
        <trans-unit id="685048571a4f4db99cb190b311def264fc71eb0e" translate="yes" xml:space="preserve">
          <source>Operator precedence</source>
          <target state="translated">操作者优先</target>
        </trans-unit>
        <trans-unit id="b559bbb40846a93d37a125fab7a9a1b57c0dd2f9" translate="yes" xml:space="preserve">
          <source>Operator precedence and associativity work in Perl more or less like they do in mathematics.</source>
          <target state="translated">操作符优先性和关联性在 Perl 中的工作方式与数学中差不多。</target>
        </trans-unit>
        <trans-unit id="6852b1cd2bb1031ac4d81d694fd94535c3eb3d11" translate="yes" xml:space="preserve">
          <source>Operator tags can be used to refer to groups (or sets) of operators. Tag names always begin with a colon. The Opcode module defines several optags and the user can define others using the define_optag function.</source>
          <target state="translated">操作符标签可以用来指代操作符的组(或组)。标签名称总是以冒号开头。Opcode模块定义了几个optag,用户可以使用define_optag函数定义其他的optag。</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="63e0a2d0a1f37e46caa267d78be1feaf655b0cda" translate="yes" xml:space="preserve">
          <source>Operators dealing with filenames are examples.</source>
          <target state="translated">处理文件名的操作符就是例子。</target>
        </trans-unit>
        <trans-unit id="55ddd8565a51d103a65dc3c453ea6bce04b13905" translate="yes" xml:space="preserve">
          <source>Operators such as &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; force arguments to floating point format.</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; 等运算符将参数强制为浮点格式。</target>
        </trans-unit>
        <trans-unit id="864704fd78dbf2c79b9e58c4ea43f3220669cded" translate="yes" xml:space="preserve">
          <source>Ops such as chdir obviously effect the process as a whole and not just the code in the compartment. Ops such as rand and srand have a similar but more subtle effect.</source>
          <target state="translated">像chdir这样的操作显然会影响整个过程,而不仅仅是隔间里的代码。rand和srand等操作也有类似但更微妙的影响。</target>
        </trans-unit>
        <trans-unit id="977af567e0cb291a9f2082343e1b048e5433a7e1" translate="yes" xml:space="preserve">
          <source>Opsets may be manipulated using the perl bit vector operators &amp;amp; (and), | (or), ^ (xor) and ~ (negate/invert).</source>
          <target state="translated">可以使用perl位向量运算符＆（和）来操作Opset。（或），^（异或）和〜（取反/取反）。</target>
        </trans-unit>
        <trans-unit id="6221772a58b20793863ce371d773cbe75426798d" translate="yes" xml:space="preserve">
          <source>OptiPerl is a Windows IDE with simulated CGI environment, including debugger and syntax-highlighting editor.</source>
          <target state="translated">OptiPerl是一个具有模拟CGI环境的Windows IDE,包括调试器和语法高亮编辑器。</target>
        </trans-unit>
        <trans-unit id="3aefe0ba1ba6e76e7b11557d066b96b14e2c986e" translate="yes" xml:space="preserve">
          <source>Optimisation data; subject to change.</source>
          <target state="translated">优化数据;可能会有变化。</target>
        </trans-unit>
        <trans-unit id="6169946bff1ab1bb2fe62a2ebdb2dd4fa18f40fb" translate="yes" xml:space="preserve">
          <source>Optimisation flags; subject to change.</source>
          <target state="translated">优化标志;可能会有变化。</target>
        </trans-unit>
        <trans-unit id="fdf5e093149fa15365c797b12b39a00d5ec3a138" translate="yes" xml:space="preserve">
          <source>Optimization</source>
          <target state="translated">Optimization</target>
        </trans-unit>
        <trans-unit id="18a333060bee7f2ee65af71205072e100d62bacc" translate="yes" xml:space="preserve">
          <source>Optimized-away statements are rendered as '???'. This includes statements that have a compile-time side-effect, such as the obscure</source>
          <target state="translated">优化后的旁门左道语句呈现为'??'。这包括那些在编译时有副作用的语句,例如晦涩的</target>
        </trans-unit>
        <trans-unit id="3e1ccc3d0caaae646e1ab71f59e1842b2b4f1166" translate="yes" xml:space="preserve">
          <source>Optimizing that any further is a job for &lt;code&gt;p5p&lt;/code&gt; .</source>
          <target state="translated">对 &lt;code&gt;p5p&lt;/code&gt; 进行进一步优化是一项工作。</target>
        </trans-unit>
        <trans-unit id="2b89db00fb49023ab4c0f78acb572909bcf10d35" translate="yes" xml:space="preserve">
          <source>Option Format</source>
          <target state="translated">选项格式</target>
        </trans-unit>
        <trans-unit id="f506dd24a9e7c79211553ebe1422f91140092c4a" translate="yes" xml:space="preserve">
          <source>Option Stickiness</source>
          <target state="translated">期权粘性</target>
        </trans-unit>
        <trans-unit id="8b0267bbb54c30709fbd963f611e8c9f6fcd1f57" translate="yes" xml:space="preserve">
          <source>Option words are separated by commas (not whitespace) and follow the usual conventions of compiler backend options.</source>
          <target state="translated">选项词用逗号(不是空格)隔开,并遵循编译器后台选项的通常惯例。</target>
        </trans-unit>
        <trans-unit id="bd62828c4813996c3de7a8b7f837c827369e6d5e" translate="yes" xml:space="preserve">
          <source>Option, Argument, Parameter, and Configuration File Processing</source>
          <target state="translated">选项、参数、参数和配置文件处理。</target>
        </trans-unit>
        <trans-unit id="16df76c37a27e75c2b404f915ffcff82e54620ed" translate="yes" xml:space="preserve">
          <source>Optional - called when the layer is about to be removed.</source>
          <target state="translated">可选-当该层即将被移除时调用。</target>
        </trans-unit>
        <trans-unit id="279393da5192f90d67ca2ac7c82f748509f343b9" translate="yes" xml:space="preserve">
          <source>Optional - if not present a lower layer does the open. If present, called after the layer is pushed for opens which pass a numeric file descriptor. This function is subject to change as there is no easy way to get a lower layer to do the open and then regain control.</source>
          <target state="translated">可选-如果不存在,则由下层进行打开。如果存在,在层被推送后调用,用于传递数字文件描述符的打开。这个函数可能会改变,因为没有简单的方法让下层做打开,然后重新获得控制权。</target>
        </trans-unit>
        <trans-unit id="66c7071a6fa7cb2bb38d9b2c01a05a137c430add" translate="yes" xml:space="preserve">
          <source>Optional - if not present a lower layer does the open. If present, called after the layer is pushed for sysopen style opens which pass a numeric mode and permissions. This function is subject to change as there is no easy way to get a lower layer to do the open and then regain control.</source>
          <target state="translated">可选-如果不存在,则由下层打开。如果存在,在层被推送后调用,用于sysopen风格的打开,它传递一个数字模式和权限。这个函数可能会改变,因为没有简单的方法让下层做打开,然后重新获得控制权。</target>
        </trans-unit>
        <trans-unit id="00aae857e158214ab9fea8340d3e81b79261acff" translate="yes" xml:space="preserve">
          <source>Optional - if not present a lower layer does the open. If present, called for normal opens after the layer is pushed. This function is subject to change as there is no easy way to get a lower layer to do the open and then regain control.</source>
          <target state="translated">可选--如果不存在,由下层做打开。如果存在,则被调用,用于层推后的正常打开。这个功能可能会有变化,因为没有简单的方法让下层做打开,然后重新获得控制权。</target>
        </trans-unit>
        <trans-unit id="c67ecb9d9cd03592e40a8cfa5395a4594326ddf4" translate="yes" xml:space="preserve">
          <source>Optional - if not present the layer is popped on binmode($fh) or when &lt;code&gt;:raw&lt;/code&gt; is pushed. If present it should return 0 on success, -1 on error, or undef to pop the layer.</source>
          <target state="translated">可选-如果不存在，则在binmode（$ fh）上或在推送 &lt;code&gt;:raw&lt;/code&gt; 时弹出该层。如果存在，则应在成功时返回0，在错误时返回-1，或返回undef弹出层。</target>
        </trans-unit>
        <trans-unit id="ea8b4c621a2282475d1c70505956ae9cadc5c505" translate="yes" xml:space="preserve">
          <source>Optional - if present it will be called immediately after PUSHED has returned. It should return a true value if the layer expects data to be UTF-8 encoded. If it returns true, the result is as if the caller had done</source>
          <target state="translated">可选-如果存在,它将在PUSHED返回后立即被调用。如果该层期望数据是UTF-8编码的,它应该返回一个真值。如果它返回true,结果就像调用者做了</target>
        </trans-unit>
        <trans-unit id="74e7ab47ea9482eb12b8ad3e12ec65d52754eeba" translate="yes" xml:space="preserve">
          <source>Optional Exports</source>
          <target state="translated">可选出口</target>
        </trans-unit>
        <trans-unit id="a1586faede4e39ea6174b7a684a9a34f79190989" translate="yes" xml:space="preserve">
          <source>Optional Libraries for Perl on Cygwin</source>
          <target state="translated">Cygwin上Perl的可选库</target>
        </trans-unit>
        <trans-unit id="ddd2d4ec70a68949d8c75dd5fb57b7fa281e8e27" translate="yes" xml:space="preserve">
          <source>Optional Parameters</source>
          <target state="translated">可选参数</target>
        </trans-unit>
        <trans-unit id="5d44ae4df7ee3a08403ce68c38bfce3a82e017dd" translate="yes" xml:space="preserve">
          <source>Optional argument is (NAMESPACE), where NAMESPACE is the root namespace to use for the compartment (defaults to &quot;Safe::Root0&quot;, incremented for each new compartment).</source>
          <target state="translated">可选参数是(NAMESPACE),其中NAMESPACE是要用于分格的根名称空间(默认为 &quot;Safe::Root0&quot;,每个新分格都会递增)。</target>
        </trans-unit>
        <trans-unit id="b9ba9d28014863d3a9a0ee7c8bcd9a7976dbaee9" translate="yes" xml:space="preserve">
          <source>Optional positional parameters must come after all mandatory positional parameters. (If there are no mandatory positional parameters then an optional positional parameters can be the first thing in the signature.) If there are multiple optional positional parameters and not enough arguments are supplied to fill them all, they will be filled from left to right.</source>
          <target state="translated">可选位置参数必须排在所有强制性位置参数之后(如果没有强制性位置参数,那么可选位置参数可以排在签名的第一位)。如果没有强制性的位置参数,那么可选的位置参数可以是签名中的第一件事)。如果有多个可选位置参数,并且提供的参数不足以填满所有的位置参数,那么将从左到右填满。</target>
        </trans-unit>
        <trans-unit id="555e2b70062eccf33f8313bcc3fba207cf55ade3" translate="yes" xml:space="preserve">
          <source>Optional sorting weight for names, to determine the order of linear testing when multiple names fall in the same case of a switch clause. Higher comes earlier, undefined defaults to zero.</source>
          <target state="translated">可选的名字排序权重,当多个名字落在同一个开关子句的情况下,确定线性测试的顺序。越高越好,未定义的默认为零。</target>
        </trans-unit>
        <trans-unit id="da333a941fe0f82279c2c56c201f1766ccc0c3ef" translate="yes" xml:space="preserve">
          <source>Optional state for the subroutine. The state is passed in as &lt;code&gt;$_[1]&lt;/code&gt; . A reference to the subroutine itself is passed in as &lt;code&gt;$_[0]&lt;/code&gt; .</source>
          <target state="translated">子程序的可选状态。状态以 &lt;code&gt;$_[1]&lt;/code&gt; 的形式传入。对子例程本身的引用以 &lt;code&gt;$_[0]&lt;/code&gt; 的形式传入。</target>
        </trans-unit>
        <trans-unit id="3640bdb58e89d324060d7d4f59fe26b0786d9f1e" translate="yes" xml:space="preserve">
          <source>Optional system utilities/More</source>
          <target state="translated">可选系统实用程序/更多</target>
        </trans-unit>
        <trans-unit id="d82440108ab7dd6400453483bc258adad0e75461" translate="yes" xml:space="preserve">
          <source>Optional warnings are enabled by using the &lt;code&gt;warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; and &lt;b&gt;-W&lt;/b&gt; switches. Warnings may be captured by setting &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; to a reference to a routine that will be called on each warning instead of printing it. See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">通过使用 &lt;code&gt;warnings&lt;/code&gt; 编译指示或&lt;b&gt;-w&lt;/b&gt;和&lt;b&gt;-W&lt;/b&gt;开关可以启用可选警告。可以通过将 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 设置为对例程的引用来捕获警告，该例程将在每个警告上调用而不是将其打印出来。参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="24b988e3016e060f13aed9e152faafade2e2cb57" translate="yes" xml:space="preserve">
          <source>Optional. If present should return an SV * representing the string argument passed to the layer when it was pushed. e.g. &quot;:encoding(ascii)&quot; would return an SvPV with value &quot;ascii&quot;. (</source>
          <target state="translated">可选的,如果存在,应该返回一个SV *,代表推送时传递给层的字符串参数。如果存在,应该返回一个SV *,代表推送时传递给层的字符串参数,例如&quot;:encoding(ascii)&quot;将返回一个值为 &quot;ascii &quot;的SvPV。(</target>
        </trans-unit>
        <trans-unit id="f5c256c5844c41d82f2e7aa133aee1f37b9932b4" translate="yes" xml:space="preserve">
          <source>Optional. No return.</source>
          <target state="translated">可选。不返回。</target>
        </trans-unit>
        <trans-unit id="ce76e8ee73778e5c913a5dddf60e41e4482a439a" translate="yes" xml:space="preserve">
          <source>Optional. Returns end-of-file state. Default is a function of the return value of FILL or READ.</source>
          <target state="translated">可选。返回文件结束的状态。默认是FILL或READ的返回值的函数。</target>
        </trans-unit>
        <trans-unit id="aceaf62498201d3cb7c33131b06976b5e7ec5946" translate="yes" xml:space="preserve">
          <source>Optional. Returns error state. Default is no error until a mechanism to signal error (die?) is worked out.</source>
          <target state="translated">可选。返回错误状态。默认为无错误,直到一个错误信号机制(die?</target>
        </trans-unit>
        <trans-unit id="d29adb828f03b9de58472833d11e71256f30b852" translate="yes" xml:space="preserve">
          <source>Optional. Used when &lt;code&gt;:raw&lt;/code&gt; layer is pushed (explicitly or as a result of binmode(FH)). If not present layer will be popped. If present should configure layer as binary (or pop itself) and return 0. If it returns -1 for error &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; will fail with layer still on the stack.</source>
          <target state="translated">可选的。在 &lt;code&gt;:raw&lt;/code&gt; 层被推送时（明确地或作为binmode（FH）的结果）使用。如果不存在，将弹出层。如果存在，则应将层配置为二进制（或弹出自身）并返回0。如果返回-1，则错误 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 将失败，并且层仍在堆栈中。</target>
        </trans-unit>
        <trans-unit id="54b5a80daefc2af51dc49c0805f2d21b91e8668b" translate="yes" xml:space="preserve">
          <source>Optionally calls timethese(), then outputs comparison chart. This:</source>
          <target state="translated">可选择调用timethese(),然后输出对比图。这个。</target>
        </trans-unit>
        <trans-unit id="8f2a6f0c361fa39f73808260e667b43a0b479347" translate="yes" xml:space="preserve">
          <source>Optionally, for trying out the feature, you may want to enable automatic dumping of the backtrace just before a warning or croak (die) message is emitted, by adding &lt;code&gt;-Accflags=-DUSE_C_BACKTRACE_ON_ERROR&lt;/code&gt; for Configure.</source>
          <target state="translated">（可选）要尝试使用该功能，您可能希望通过在配置中添加 &lt;code&gt;-Accflags=-DUSE_C_BACKTRACE_ON_ERROR&lt;/code&gt; 来在发出警告或嘶哑（死）消息之前启用回溯自动转储。</target>
        </trans-unit>
        <trans-unit id="6d56e16a59906dea5f31b29892ce1311dd9cccd9" translate="yes" xml:space="preserve">
          <source>Optionally, one can merge the description of types and the list of argument names, rewriting this as</source>
          <target state="translated">也可以将类型描述和参数名列表合并,将其改写为</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="9c5258ecb746f12e305ee9f0999e8ac50793402b" translate="yes" xml:space="preserve">
          <source>Options (specified by the following modifiers) are:</source>
          <target state="translated">(由下列修饰符指定的)选项是:</target>
        </trans-unit>
        <trans-unit id="ec1f90c3315fe4700f720cb2f4a9e4c50e170f92" translate="yes" xml:space="preserve">
          <source>Options affect how things are rendered (ie printed). They're presented here by their visual effect, 1st being strongest. They're grouped according to how they interrelate; within each group the options are mutually exclusive (unless otherwise stated).</source>
          <target state="translated">选项会影响事物的渲染方式(即打印)。它们在这里按视觉效果排列,第 1 个是最强的。它们是根据它们之间的相互关系来分组的;在每一组中,选项是相互排斥的(除非另有说明)。</target>
        </trans-unit>
        <trans-unit id="48a464c28a671924b790e4e5d29f7c52e88ad928" translate="yes" xml:space="preserve">
          <source>Options are as described in &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; above; in addition, the following match process modifiers are available:</source>
          <target state="translated">选项如上文 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 所述；此外，还可以使用以下匹配过程修饰符：</target>
        </trans-unit>
        <trans-unit id="6e758911022c90dc88a8767e43a034d257baa395" translate="yes" xml:space="preserve">
          <source>Options are as with &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; with the addition of the following replacement specific options:</source>
          <target state="translated">选项与 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ，并增加了以下特定于替换的选项：</target>
        </trans-unit>
        <trans-unit id="1be4081ccaf3e011dcb6256fd6926414b643ca82" translate="yes" xml:space="preserve">
          <source>Options can be combined as required.</source>
          <target state="translated">可根据需要组合选项。</target>
        </trans-unit>
        <trans-unit id="44de2a921493b7d9eacebba61cb9256d0440d480" translate="yes" xml:space="preserve">
          <source>Options can have values, the value is placed after the option character. Sometimes with whitespace in between, sometimes not:</source>
          <target state="translated">选项可以有值,值放在选项字符之后。有时中间有空格,有时没有。</target>
        </trans-unit>
        <trans-unit id="6f40af16e1d24ead9dd1ab7a9826636a3e146727" translate="yes" xml:space="preserve">
          <source>Options can take multiple values at once, for example</source>
          <target state="translated">选项可以同时取多个值,例如</target>
        </trans-unit>
        <trans-unit id="3ddfd37b7dede31756596dac520f5a582b7ed831" translate="yes" xml:space="preserve">
          <source>Options controlling sequence numbering</source>
          <target state="translated">控制序列编号的选项</target>
        </trans-unit>
        <trans-unit id="9a8a3df69d73a894006df726b5df3d7d2139bdfa" translate="yes" xml:space="preserve">
          <source>Options for Line-Style</source>
          <target state="translated">线型的选择</target>
        </trans-unit>
        <trans-unit id="58018de8cc3dcfc82b97b039f35b6a1c13becc88" translate="yes" xml:space="preserve">
          <source>Options for Opcode Ordering</source>
          <target state="translated">操作码订购选项</target>
        </trans-unit>
        <trans-unit id="55b5d2921e00a398b412bd693eeb7b816a5988e5" translate="yes" xml:space="preserve">
          <source>Options for tree-specific formatting</source>
          <target state="translated">树的特定格式化选项</target>
        </trans-unit>
        <trans-unit id="85b85ab75dd0ae66d7aa6313828663d28696cdc6" translate="yes" xml:space="preserve">
          <source>Options include:</source>
          <target state="translated">选项包括:</target>
        </trans-unit>
        <trans-unit id="0cc4681b46a8bbe1672f6ee5cc5274a5a2e1321f" translate="yes" xml:space="preserve">
          <source>Options sometimes take several values. For example, a program could use multiple directories to search for library files:</source>
          <target state="translated">选项有时会取几个值。例如,一个程序可以使用多个目录来搜索库文件。</target>
        </trans-unit>
        <trans-unit id="f78d98a0f0a1d210a552e42c750a6f91f2370150" translate="yes" xml:space="preserve">
          <source>Options that take arguments:</source>
          <target state="translated">接受参数的选项。</target>
        </trans-unit>
        <trans-unit id="41151a23e0b5c5a846ca08d323cfca7cf516f1a6" translate="yes" xml:space="preserve">
          <source>Options with hash values</source>
          <target state="translated">带有哈希值的选项</target>
        </trans-unit>
        <trans-unit id="60f84bb401de02d865a716cc0a5e1289035f7821" translate="yes" xml:space="preserve">
          <source>Options with multiple names</source>
          <target state="translated">有多个名称的选项</target>
        </trans-unit>
        <trans-unit id="c9529a432aa4df6cdd00e1eef2fc89856c4d9538" translate="yes" xml:space="preserve">
          <source>Options with multiple values</source>
          <target state="translated">有多个值的选项</target>
        </trans-unit>
        <trans-unit id="ce4401244b851388c74b7c8db83ca37894df35bc" translate="yes" xml:space="preserve">
          <source>Options with values</source>
          <target state="translated">有价值的选项</target>
        </trans-unit>
        <trans-unit id="44b169e466bada4cebf1bd71469144108ff2f954" translate="yes" xml:space="preserve">
          <source>Options.U</source>
          <target state="translated">Options.U</target>
        </trans-unit>
        <trans-unit id="bdd0b506837a990803d8edf137f2934329835748" translate="yes" xml:space="preserve">
          <source>Options:</source>
          <target state="translated">Options:</target>
        </trans-unit>
        <trans-unit id="99fd4ae20169f4f1fd95e0b318eddbf04496e03f" translate="yes" xml:space="preserve">
          <source>Optree Manipulation Functions</source>
          <target state="translated">Optree操纵功能</target>
        </trans-unit>
        <trans-unit id="6660f96406f6f5efcf28a2f461913aed19ed8b17" translate="yes" xml:space="preserve">
          <source>Optree construction</source>
          <target state="translated">Optree建筑公司</target>
        </trans-unit>
        <trans-unit id="219c1efc76675f38bcd59bb9804c4faf6887590f" translate="yes" xml:space="preserve">
          <source>Or by including the &lt;a href=&quot;tester/color&quot;&gt;Test::Builder::Tester::Color&lt;/a&gt; module directly in the PERL5LIB.</source>
          <target state="translated">或者通过直接在PERL5LIB中包含&lt;a href=&quot;tester/color&quot;&gt;Test :: Builder :: Tester :: Color&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="939c0047d2a7d9894b911fc7f2bc8d3ef6ebb72b" translate="yes" xml:space="preserve">
          <source>Or even the day of the year (which is what some people think of as a Julian day):</source>
          <target state="translated">甚至是一年中的某一天(也就是有些人认为的朱利安日)。</target>
        </trans-unit>
        <trans-unit id="c8d29c4a4243321b13a4333a16028d3427ee5e4d" translate="yes" xml:space="preserve">
          <source>Or even to place backup copies of the original files into another directory (provided the directory already exists):</source>
          <target state="translated">甚至是将原文件的备份副本放到另一个目录中(前提是该目录已经存在)。</target>
        </trans-unit>
        <trans-unit id="a39395a536571e326a3e448e36d0980f046516aa" translate="yes" xml:space="preserve">
          <source>Or even with a literal numeric descriptor:</source>
          <target state="translated">甚至用文字数字描述符。</target>
        </trans-unit>
        <trans-unit id="ab622aab7528770d4b43d68b1cd75eb516c4a74e" translate="yes" xml:space="preserve">
          <source>Or for months:</source>
          <target state="translated">或者几个月。</target>
        </trans-unit>
        <trans-unit id="4fbd4993cb449934f1a66fbe81f10f2f69d366bb" translate="yes" xml:space="preserve">
          <source>Or here's another sample of using our tied class:</source>
          <target state="translated">或者这里还有一个使用我们的绑定类的例子。</target>
        </trans-unit>
        <trans-unit id="1cc3245f722d14e01ba8265aa59ed13c82aa6c08" translate="yes" xml:space="preserve">
          <source>Or if you already have an open filehandle:</source>
          <target state="translated">或者如果你已经有一个打开的文件柄。</target>
        </trans-unit>
        <trans-unit id="4b436dc18b09a9237b0e320d550c6bceb76aed2a" translate="yes" xml:space="preserve">
          <source>Or if you don't care to play it safe, like this:</source>
          <target state="translated">或者如果你不在乎安全,像这样。</target>
        </trans-unit>
        <trans-unit id="ab228fa27d4891d818d4fcc6cc01c02a70a2f225" translate="yes" xml:space="preserve">
          <source>Or if you don't mind pulling in a few thousand lines of code just because you're afraid of a little &lt;code&gt;$|&lt;/code&gt; variable:</source>
          <target state="translated">或者，如果您不介意仅仅因为担心 &lt;code&gt;$|&lt;/code&gt; 而输入几千行代码 变量：</target>
        </trans-unit>
        <trans-unit id="6de1ca81804fc1d18de6212eb9c2eb10c739f658" translate="yes" xml:space="preserve">
          <source>Or if you have a core dump:</source>
          <target state="translated">或者如果你有一个核心转储。</target>
        </trans-unit>
        <trans-unit id="08ae01f1533c609ba5994d6d80c6e627d6b146ea" translate="yes" xml:space="preserve">
          <source>Or if you really want to save space:</source>
          <target state="translated">或者如果你真的想节省空间。</target>
        </trans-unit>
        <trans-unit id="91c274909c10e199bdd764d2f1727e59782d9346" translate="yes" xml:space="preserve">
          <source>Or if you try to do</source>
          <target state="translated">或者如果你想做</target>
        </trans-unit>
        <trans-unit id="151d66e1a17731064f48e0aa8f42f3272b7c1ba5" translate="yes" xml:space="preserve">
          <source>Or if you want to schedule a</source>
          <target state="translated">或者如果你想安排一个</target>
        </trans-unit>
        <trans-unit id="a55b0108f3cf41f36382908140f2919f204761ba" translate="yes" xml:space="preserve">
          <source>Or in a more recent version:</source>
          <target state="translated">或在较新的版本中。</target>
        </trans-unit>
        <trans-unit id="c2f0409db7dd86c778a013b8c1b13fb97d9866d1" translate="yes" xml:space="preserve">
          <source>Or insert multiple javascript source in the header (or for that matter include anything, thought this is not recommended)</source>
          <target state="translated">或者在头部插入多个javascript源码(或者说包括任何东西,以为不建议这样做)。</target>
        </trans-unit>
        <trans-unit id="1f2f783b03d3690462c1ad2137de324e8f81f559" translate="yes" xml:space="preserve">
          <source>Or install it RPM Style:</source>
          <target state="translated">或者安装它的RPM风格。</target>
        </trans-unit>
        <trans-unit id="4e1bab7ea88f309a093f0d39d4f730b201961c56" translate="yes" xml:space="preserve">
          <source>Or instead of storing this in the language class's lexicon, you can (and, in some cases, really should) represent the same bit of knowledge as code in a method in the language class. (That leaves a tidy distinction between the lexicon as the things we know how to</source>
          <target state="translated">或者说,你可以(在某些情况下,确实应该)不把这些存储在语言类的词库中,而是把相同的知识点作为代码表示在语言类的一个方法中。(这样一来,词典与我们所知道的事物之间就有了一个整齐的区分。</target>
        </trans-unit>
        <trans-unit id="7045f93919469e6381656c230b7db826c2eef7c3" translate="yes" xml:space="preserve">
          <source>Or it can localize a typeglob and use the filehandle directly:</source>
          <target state="translated">或者它可以本地化一个typeglob,直接使用filehandle。</target>
        </trans-unit>
        <trans-unit id="ce435dd3f2375a45ae18754aa5933bf2c436dc74" translate="yes" xml:space="preserve">
          <source>Or just use &lt;code&gt;if&lt;/code&gt; .</source>
          <target state="translated">或只是使用 &lt;code&gt;if&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="136d46bac172392fa4cdf46c2009daa41e71888d" translate="yes" xml:space="preserve">
          <source>Or like this:</source>
          <target state="translated">或者像这样。</target>
        </trans-unit>
        <trans-unit id="48f08d1241f74e59beb562174576b8f1d306023b" translate="yes" xml:space="preserve">
          <source>Or maybe we could use regular expressions:</source>
          <target state="translated">或者我们可以使用正则表达式。</target>
        </trans-unit>
        <trans-unit id="d3bba577160bb629ef905e44edb323af58458622" translate="yes" xml:space="preserve">
          <source>Or maybe you don't want to &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; at all! Maybe you could use a handler like this:</source>
          <target state="translated">或者，也许您根本 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ！也许您可以使用如下处理程序：</target>
        </trans-unit>
        <trans-unit id="eb07ce954d095bd48c2be1f0fcad35b67c72a58b" translate="yes" xml:space="preserve">
          <source>Or more succinctly:</source>
          <target state="translated">或者更简洁的说。</target>
        </trans-unit>
        <trans-unit id="daea64cee75759eefcb8d884a9ad1d6ffab3b7eb" translate="yes" xml:space="preserve">
          <source>Or the modified Julian Day:</source>
          <target state="translated">或修改后的朱利安日。</target>
        </trans-unit>
        <trans-unit id="37cd5be2ebf8ceaba65ad66ef7810a2d95ad6a73" translate="yes" xml:space="preserve">
          <source>Or to make an swrite() subroutine, which is to write() what sprintf() is to printf(), do this:</source>
          <target state="translated">或者做一个swrite()子程序,它对write()的作用就像printf()对printf()的作用一样,这样做。</target>
        </trans-unit>
        <trans-unit id="b578c02852dfedb0541b5bd3610b753c127ee1fb" translate="yes" xml:space="preserve">
          <source>Or to plan a variable number of tests:</source>
          <target state="translated">或规划可变数量的测试。</target>
        </trans-unit>
        <trans-unit id="534e1e283610aa3e2f191a2196b648a7456ca580" translate="yes" xml:space="preserve">
          <source>Or use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; to try decoding it:</source>
          <target state="translated">或使用 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 尝试对其进行解码：</target>
        </trans-unit>
        <trans-unit id="70d6fd7de2724ba9f6a39374a9f05288463f8ef9" translate="yes" xml:space="preserve">
          <source>Or use specific un-Unicode properties, like &lt;code&gt;\p{ahex}&lt;/code&gt; and &lt;code&gt;\p{POSIX_Digit&lt;/code&gt; }. Properties still work normally no matter what charset modifiers (&lt;code&gt;/d /u /l /a /aa&lt;/code&gt; ) should be effect.</source>
          <target state="translated">或使用特定的非Unicode属性，例如 &lt;code&gt;\p{ahex}&lt;/code&gt; 和 &lt;code&gt;\p{POSIX_Digit&lt;/code&gt; }。无论什么字符集修饰符（ &lt;code&gt;/d /u /l /a /aa&lt;/code&gt; ）应该起作用，属性仍然正常工作。</target>
        </trans-unit>
        <trans-unit id="d147ca7029faa376379ab60dd5e184279f392c55" translate="yes" xml:space="preserve">
          <source>Or use the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt;:</source>
          <target state="translated">或使用CPAN模块&lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="3e3bc5aa2b1c65a2f0536a8ad61f1cf720e70bd7" translate="yes" xml:space="preserve">
          <source>Or use the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt;. Formatting files can be easily done by making a shell alias, like so:</source>
          <target state="translated">或使用CPAN模块&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text :: Autoformat&lt;/a&gt;。可以通过设置shell别名来轻松地格式化文件，如下所示：</target>
        </trans-unit>
        <trans-unit id="21cd44b0a63b2724e709817a957ed758ac294220" translate="yes" xml:space="preserve">
          <source>Or we can use the addfile method for more efficient reading of the file:</source>
          <target state="translated">或者我们可以使用addfile的方法来更高效的读取文件。</target>
        </trans-unit>
        <trans-unit id="7eb22b9341f8bed904b75d947077206dd520c369" translate="yes" xml:space="preserve">
          <source>Or we will publicly ridicule you. Seriously.</source>
          <target state="translated">否则我们会公开嘲笑你。认真的。</target>
        </trans-unit>
        <trans-unit id="2c4d7e281aa840be77762aa28882884e3b12c3e2" translate="yes" xml:space="preserve">
          <source>Or with a fixed amount of leading whitespace, with remaining indentation correctly preserved:</source>
          <target state="translated">或有固定数量的前导空格,其余缩进正确保留。</target>
        </trans-unit>
        <trans-unit id="9f8c04b29e5bdf5cb37189daec86558285ed03bf" translate="yes" xml:space="preserve">
          <source>Or with rationals:</source>
          <target state="translated">或与理性。</target>
        </trans-unit>
        <trans-unit id="ac4bf8a39abe6183f58cc853b82a958a3b19f773" translate="yes" xml:space="preserve">
          <source>Or write a small C program using the editor of champions:</source>
          <target state="translated">或者用冠军的编辑器写一个小C程序。</target>
        </trans-unit>
        <trans-unit id="071de2b484157eae02726aef816948b89ceb81e6" translate="yes" xml:space="preserve">
          <source>Or write it yourself, iterating through the indices and checking the array element at each index until you find one that satisfies the condition:</source>
          <target state="translated">或者自己写,通过索引迭代,检查每个索引处的数组元素,直到找到满足条件的元素。</target>
        </trans-unit>
        <trans-unit id="fd30f1e33b918715dd71d5fd528fc3bfe2e3a2f3" translate="yes" xml:space="preserve">
          <source>Or write the &quot;bar&quot; method so you don't need to pass it the output from calling quux.</source>
          <target state="translated">或者写 &quot;bar &quot;方法,这样你就不需要把调用quux的输出传递给它。</target>
        </trans-unit>
        <trans-unit id="1257832c1f8df8853297c11758dc7f82a58965f3" translate="yes" xml:space="preserve">
          <source>Or you can call these methods, which Pod::Simple::PullParser has defined to work just like Pod::Simple's same-named methods:</source>
          <target state="translated">或者你可以调用这些方法,Pod::Simple::PullParser已经定义了这些方法,就像Pod::Simple的同名方法一样工作。</target>
        </trans-unit>
        <trans-unit id="43deb0ef03dcaf9d7f9a23cfd26b6f349abc278d" translate="yes" xml:space="preserve">
          <source>Or you can give the name of a specific module:</source>
          <target state="translated">或者你可以给出一个特定模块的名称。</target>
        </trans-unit>
        <trans-unit id="44f4d760018e2beff2abc7deca32778f6b33edab" translate="yes" xml:space="preserve">
          <source>Or you can just use the &lt;a href=&quot;text/tabs&quot;&gt;Text::Tabs&lt;/a&gt; module (part of the standard Perl distribution).</source>
          <target state="translated">或者，您可以只使用&lt;a href=&quot;text/tabs&quot;&gt;Text :: Tabs&lt;/a&gt;模块（标准Perl发行版的一部分）。</target>
        </trans-unit>
        <trans-unit id="3f560caefa4961932943871223d7a55e15210337" translate="yes" xml:space="preserve">
          <source>Or you can link to a web page:</source>
          <target state="translated">或者你可以链接到一个网页。</target>
        </trans-unit>
        <trans-unit id="35426ac710dfda840e59a05cb7cce1999af24289" translate="yes" xml:space="preserve">
          <source>Or you can read the entire file contents into a scalar like this:</source>
          <target state="translated">或者你可以把整个文件内容读到一个标量中,像这样。</target>
        </trans-unit>
        <trans-unit id="7ca35881b01bed9e83e28982a2d8d72c5c6104a0" translate="yes" xml:space="preserve">
          <source>Or you can try casting to a &quot;wide enough&quot; type:</source>
          <target state="translated">或者你也可以尝试投向 &quot;够宽 &quot;的类型。</target>
        </trans-unit>
        <trans-unit id="043cc73307c25fd12afc139edc01af1987c07753" translate="yes" xml:space="preserve">
          <source>Or you can use</source>
          <target state="translated">或者您可以使用</target>
        </trans-unit>
        <trans-unit id="6eacf94ec3c91a6fb8f957244c216f33f4c57d92" translate="yes" xml:space="preserve">
          <source>Or you can use &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt;, though it is less convenient in the general case:</source>
          <target state="translated">或者，您可以使用 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; ，尽管在一般情况下不太方便：</target>
        </trans-unit>
        <trans-unit id="931b91df8b44901925eb12d70d322446a86049fc" translate="yes" xml:space="preserve">
          <source>Or you can use &lt;code&gt;add_suspects&lt;/code&gt; method. The difference is that &lt;code&gt;set_suspects&lt;/code&gt; flushes the current suspects list while &lt;code&gt;add_suspects&lt;/code&gt; adds.</source>
          <target state="translated">或者，您可以使用 &lt;code&gt;add_suspects&lt;/code&gt; 方法。区别在于 &lt;code&gt;set_suspects&lt;/code&gt; 会在 &lt;code&gt;add_suspects&lt;/code&gt; 添加时刷新当前的可疑列表。</target>
        </trans-unit>
        <trans-unit id="a39a91a0d1d979c65ad41157a37488c0834225c4" translate="yes" xml:space="preserve">
          <source>Or you could check out the &lt;a href=&quot;http://search.cpan.org/perldoc/String::Scanf&quot;&gt;String::Scanf&lt;/a&gt; module on the CPAN instead.</source>
          <target state="translated">或者，您也可以在CPAN上检出&lt;a href=&quot;http://search.cpan.org/perldoc/String::Scanf&quot;&gt;String :: Scanf&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="5093d94168468d0b2a02ecd19e89cf6d81de9b6e" translate="yes" xml:space="preserve">
          <source>Or you could use this module, like this:</source>
          <target state="translated">或者你可以使用这个模块,像这样。</target>
        </trans-unit>
        <trans-unit id="d54e1a4de96da66b4f1be3ddd384e9dc12182b2a" translate="yes" xml:space="preserve">
          <source>Or you may want to override it with something that traps any exceptions, if that's critical to your program:</source>
          <target state="translated">或者,如果这对你的程序很重要的话,你可能想用一些能捕获任何异常的东西来覆盖它。</target>
        </trans-unit>
        <trans-unit id="2bc5eff73e9b5c554f3a2ea69d7a2e4db2c90148" translate="yes" xml:space="preserve">
          <source>Or you might have had a temporary variable sitting around with the array in it.</source>
          <target state="translated">或者你可能有一个临时变量和数组放在一起。</target>
        </trans-unit>
        <trans-unit id="778e7ba107050bb841c6a420e4c310f8b170e2db" translate="yes" xml:space="preserve">
          <source>Or, as a third option you can choose RAND which will make a random decision (something regular CPAN testers will enjoy).</source>
          <target state="translated">或者,作为第三种选择,你可以选择RAND,它将做出一个随机的决定(常规CPAN测试者会喜欢的东西)。</target>
        </trans-unit>
        <trans-unit id="67fb52d7219a77edeaa3410be898dbaaf5eb7940" translate="yes" xml:space="preserve">
          <source>Or, going the other way:</source>
          <target state="translated">或者,走另一条路。</target>
        </trans-unit>
        <trans-unit id="c9cbc117e700c42b5960566f9d6e3ab9956f8e0e" translate="yes" xml:space="preserve">
          <source>Or, if you want to alter the value, you can even do things like this:</source>
          <target state="translated">或者,如果你想改变这个值,你甚至可以这样做。</target>
        </trans-unit>
        <trans-unit id="bbaa299505c09af1ba1a690349c0d5013974e787" translate="yes" xml:space="preserve">
          <source>Or, if you want to use SHA-256 instead of the default SHA-1, simply say:</source>
          <target state="translated">或者,如果你想使用SHA-256而不是默认的SHA-1,只需说。</target>
        </trans-unit>
        <trans-unit id="43c22f6d092ff91e39fcd2c49c563a09384d2c27" translate="yes" xml:space="preserve">
          <source>Or, if you're fond of VMS command syntax:</source>
          <target state="translated">或者,如果你喜欢VMS命令语法。</target>
        </trans-unit>
        <trans-unit id="8f53b2f39475162ce9507ab6d3bc142ec9ebf18d" translate="yes" xml:space="preserve">
          <source>Or, if you're lazy, just:</source>
          <target state="translated">或者,如果你很懒,就。</target>
        </trans-unit>
        <trans-unit id="2e075c729b27aef299f95b8f9b89c3205825fc03" translate="yes" xml:space="preserve">
          <source>Or, if you're using a recent release of Perl, you can just use the Symbol::delete_package() function instead.</source>
          <target state="translated">或者,如果你使用的是最新版本的 Perl,你可以使用 Symbol::delete_package()函数来代替。</target>
        </trans-unit>
        <trans-unit id="9ef47775ad6e32b75e39e1b8250e2051eeafc265" translate="yes" xml:space="preserve">
          <source>Or, in order to retain the UTF-x code points in hexadecimal:</source>
          <target state="translated">或者,为了保留十六进制的UTF-x码点。</target>
        </trans-unit>
        <trans-unit id="9ac1d61fe8e0e045309c1cd8c9bfbba7d77d8c46" translate="yes" xml:space="preserve">
          <source>Or, just use the fdopen(3S) feature of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">或者，只是使用的fdopen（3S）功能 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b65db10b884b8811cab09d1c35d73c9549dd89e0" translate="yes" xml:space="preserve">
          <source>Or, simply:</source>
          <target state="translated">或者,干脆。</target>
        </trans-unit>
        <trans-unit id="4509b32489cef8d9fa76782913fc02beac5d2e00" translate="yes" xml:space="preserve">
          <source>Or, you can combine this step with the next to save disk space:</source>
          <target state="translated">或者,你可以把这一步和下一步结合起来,以节省磁盘空间。</target>
        </trans-unit>
        <trans-unit id="a70a9c965ff5f01a36539ad3a4f1747814f861b5" translate="yes" xml:space="preserve">
          <source>Or, you can use a closure to bundle up the object, its method call, and arguments:</source>
          <target state="translated">或者,你可以使用一个闭包来捆绑对象、其方法调用和参数。</target>
        </trans-unit>
        <trans-unit id="8e30f14ff059f10f588d2a56e4ed3edbafad53cb" translate="yes" xml:space="preserve">
          <source>Or, you can use the &lt;code&gt;new&lt;/code&gt; method from one of the IO::* modules to create an anonymous filehandle and store that in a scalar variable.</source>
          <target state="translated">或者，您可以使用IO :: *模块之一中的 &lt;code&gt;new&lt;/code&gt; 方法来创建匿名文件句柄并将其存储在标量变量中。</target>
        </trans-unit>
        <trans-unit id="af6226005e40b70717bca3873f6972ffe8233b17" translate="yes" xml:space="preserve">
          <source>Or, you might want to only process some of the items. If you only want to deal with the keys that start with &lt;code&gt;text:&lt;/code&gt; , you can select just those using &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">或者，您可能只想处理某些项目。如果您只想处理以 &lt;code&gt;text:&lt;/code&gt; 开头的键，则可以只选择使用 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 的键：</target>
        </trans-unit>
        <trans-unit id="40119221cab56480c05aa14722b443b3fea26189" translate="yes" xml:space="preserve">
          <source>Or...</source>
          <target state="translated">Or...</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="ed006a3a71954db6f888573fde1410910ac75da8" translate="yes" xml:space="preserve">
          <source>Oracle on HP-UX</source>
          <target state="translated">HP-UX上的Oracle</target>
        </trans-unit>
        <trans-unit id="d62b80826f613ec1202935a4c2f641139f04ab27" translate="yes" xml:space="preserve">
          <source>Order of initialization: early load()</source>
          <target state="translated">初始化顺序:早期加载()</target>
        </trans-unit>
        <trans-unit id="7393d644018f3205b57f7e4d05fa28a3cb608a27" translate="yes" xml:space="preserve">
          <source>Ordering is important in all these examples. That's because the shell processes file descriptor redirections in strictly left to right order.</source>
          <target state="translated">在所有这些例子中,排序是很重要的。这是因为shell严格按照从左到右的顺序处理文件描述符重定向。</target>
        </trans-unit>
        <trans-unit id="184a2b9a0782971148728db5cbfcd9146f0d9d22" translate="yes" xml:space="preserve">
          <source>Ordering of two matches for &lt;code&gt;S&lt;/code&gt; is the same as for &lt;code&gt;S&lt;/code&gt; . Similar for two matches for &lt;code&gt;T&lt;/code&gt; .</source>
          <target state="translated">两场比赛的订货 &lt;code&gt;S&lt;/code&gt; 是一样的 &lt;code&gt;S&lt;/code&gt; 。 &lt;code&gt;T&lt;/code&gt; 的两场比赛相似。</target>
        </trans-unit>
        <trans-unit id="1f2e5db8ac8798852d4979873043eb23e9daf36e" translate="yes" xml:space="preserve">
          <source>Ordinarily you must assign the returned value to a variable, but there is one situation where an automatic assignment happens. If and only if the input symbol is the only thing inside the conditional of a &lt;code&gt;while&lt;/code&gt; statement (even if disguised as a &lt;code&gt;for(;;)&lt;/code&gt; loop), the value is automatically assigned to the global variable &lt;code&gt;$_&lt;/code&gt; , destroying whatever was there previously. (This may seem like an odd thing to you, but you'll use the construct in almost every Perl script you write.) The &lt;code&gt;$_&lt;/code&gt; variable is not implicitly localized. You'll have to put a &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $_;&lt;/code&gt; before the loop if you want that to happen.</source>
          <target state="translated">通常，您必须将返回值分配给变量，但是在一种情况下会发生自动分配。当且仅当输入符号是 &lt;code&gt;while&lt;/code&gt; 语句条件内的唯一内容时（即使伪装为 &lt;code&gt;for(;;)&lt;/code&gt; 循环），该值也会自动分配给全局变量 &lt;code&gt;$_&lt;/code&gt; ，从而销毁先前的内容。（这对您来说似乎很奇怪，但是您几乎在编写的每个Perl脚本中都会使用该构造。） &lt;code&gt;$_&lt;/code&gt; 变量不是隐式本地化的。您必须输入 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $_;&lt;/code&gt; 如果您希望这种情况发生在循环之前。</target>
        </trans-unit>
        <trans-unit id="53258e41460718a5a3f67ea0dcecd0cea963c78d" translate="yes" xml:space="preserve">
          <source>Ordinarily, if you use B::Deparse on a subroutine which has been compiled in the presence of one or more of these pragmas, the output will include statements to turn on the appropriate directives. So if you then compile the code returned by coderef2text, it will behave the same way as the subroutine which you deparsed.</source>
          <target state="translated">通常情况下,如果你在一个子程序上使用 B::Deparse,而这个子程序是在一个或多个这样的实用名词的情况下编译的,那么输出将包括开启相应指令的语句。所以如果你再编译coderef2text返回的代码,它的行为将与你deparsed的子程序一样。</target>
        </trans-unit>
        <trans-unit id="9eb59a093d68b441c9e588f45e1136962cd97df2" translate="yes" xml:space="preserve">
          <source>Ordinary Paragraph</source>
          <target state="translated">普通段</target>
        </trans-unit>
        <trans-unit id="852794a0888b2c26ae66b7390c3dc7aa906b25ab" translate="yes" xml:space="preserve">
          <source>Ordinary scalars are added to queues as they are.</source>
          <target state="translated">普通标量按原样添加到队列中。</target>
        </trans-unit>
        <trans-unit id="e643b2f1d6d20cd4b1a9b180a96d9d74142343a5" translate="yes" xml:space="preserve">
          <source>Organization of Perl Images</source>
          <target state="translated">Perl图像的组织</target>
        </trans-unit>
        <trans-unit id="b7ac1ae7a629fb1e4790255da63efabc71780dd7" translate="yes" xml:space="preserve">
          <source>Original author Charles Bailey</source>
          <target state="translated">原作者Charles Bailey</target>
        </trans-unit>
        <trans-unit id="6bb735e6ea9df22ee5b2de902784152d534e32cf" translate="yes" xml:space="preserve">
          <source>Original author lost in the mists of time. Probably the same as Makemaker.</source>
          <target state="translated">原作者已消失在时间的迷雾中。可能和造物主一样吧。</target>
        </trans-unit>
        <trans-unit id="8478bfad57c6e4bf8f9631f29cfcd8913f5e1f7b" translate="yes" xml:space="preserve">
          <source>Original author: Jos Boumans &amp;lt;kane@cpan.org&amp;gt;. Current maintainer: Chris Williams &amp;lt;bingos@cpan.org&amp;gt;.</source>
          <target state="translated">原始作者：Jos Boumans &amp;lt;kane@cpan.org&amp;gt;。现任维护者：克里斯&amp;middot;威廉姆斯（Chris Williams）&amp;lt;bingos@cpan.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="82456b1a006fa0cfc6f13442efd03f45359b0924" translate="yes" xml:space="preserve">
          <source>Original code by Mark Biggar, overloaded interface by Ilya Zakharevich. Completely rewritten by Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; in late 2000, 2001 - 2006 and still at it in 2007.</source>
          <target state="translated">Mark Biggar的原始代码，Ilya Zakharevich的重载接口。由Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt;于2000年末，2001年-2006年完全重写，并于2007年继续使用。</target>
        </trans-unit>
        <trans-unit id="4907c478063f242cdad148d2cf2e2a3834c957e0" translate="yes" xml:space="preserve">
          <source>Original code by chromatic, maintained by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;</source>
          <target state="translated">彩色的原始代码，由Michael G Schwern维护&amp;lt;schwern@pobox.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5aa8fbf538dffef8e3de83026f7b50c6ec7e3e15" translate="yes" xml:space="preserve">
          <source>Original idea (using constants) by Zenin, reimplemented using subs by Russ Allbery &amp;lt;rra@cpan.org&amp;gt;, and then combined with the original idea by Russ with input from Zenin. 256-color support is based on work by Kurt Starsinic. Russ Allbery now maintains this module.</source>
          <target state="translated">Zenin的原始思想（使用常量），Russ Allbery &amp;lt;rra@cpan.org&amp;gt;使用subs重新实现，然后与Russ的原始思想与Zenin的输入相结合。256色支持基于Kurt Starsinic的工作。现在，Russ Allbery维护此模块。</target>
        </trans-unit>
        <trans-unit id="531407d264d0d11235657451697ac677d9049ca2" translate="yes" xml:space="preserve">
          <source>Original math code by Mark Biggar, rewritten by Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt; in late 2000.</source>
          <target state="translated">Mark Biggar的原始数学代码，由Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt;在2000年末重写。</target>
        </trans-unit>
        <trans-unit id="de9fcab0737543137eaab2a0e06f6bd2ca79a9cc" translate="yes" xml:space="preserve">
          <source>Original math code by Mark Biggar, rewritten by Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt; in late 2000. Separated from BigInt and shaped API with the help of John Peacock.</source>
          <target state="translated">Mark Biggar的原始数学代码，由Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt;在2000年底重写。与BigInt分离，并在John Peacock的帮助下对API进行了修改。</target>
        </trans-unit>
        <trans-unit id="016eb101d0bd431b0d9ab4229772d8f00ba5eae2" translate="yes" xml:space="preserve">
          <source>Original module by Lionel Cons (CERN).</source>
          <target state="translated">莱昂内尔-康斯(欧洲核研究组织)的原始模块。</target>
        </trans-unit>
        <trans-unit id="a9ec70668a9cf8a9b6348458c85a3f762057ac0f" translate="yes" xml:space="preserve">
          <source>Original version by Tom Christiansen, &amp;lt;tchrist@perl.com&amp;gt;.</source>
          <target state="translated">汤姆&amp;middot;克里斯蒂安森（Tom Christiansen）的原始版本，&amp;lt;tchrist@perl.com&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="93bd0bc0b9a9e635b79e9c5f125cb705f4a31e8d" translate="yes" xml:space="preserve">
          <source>Originally &lt;code&gt;Class::Template&lt;/code&gt; by Dean Roehrich.</source>
          <target state="translated">由Dean Roehrich 最初使用 &lt;code&gt;Class::Template&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98ac195b142c467725515fdf5766071e9fc6f61f" translate="yes" xml:space="preserve">
          <source>Originally began life in May 1999 as an XS interface to the system mkstemp() function. In March 2000, the OpenBSD mkstemp() code was translated to Perl for total control of the code's security checking, to ensure the presence of the function regardless of operating system and to help with portability. The module was shipped as a standard part of perl from v5.6.1.</source>
          <target state="translated">最初是在1999年5月作为XS系统mkstemp()函数的接口开始使用的。2000年3月,OpenBSD mkstemp()的代码被翻译成Perl,以便完全控制代码的安全检查,确保该函数在任何操作系统下都能存在,并有助于移植。这个模块从v5.6.1开始就作为perl的一个标准部分。</target>
        </trans-unit>
        <trans-unit id="05d3b834a8e1ec7b7d1784cd966acd56262bc822" translate="yes" xml:space="preserve">
          <source>Originally by Larry Wall. Turned into the &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; module by Ken Williams.</source>
          <target state="translated">最初由拉里&amp;middot;沃尔（Larry Wall）撰写。由Ken Williams 转到 &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="78ba94984c09fe40c7fb0012a48157ae37638a1c" translate="yes" xml:space="preserve">
          <source>Originally by the perl5-porters.</source>
          <target state="translated">最初由perl5-porters。</target>
        </trans-unit>
        <trans-unit id="0a58abf22ae0f33a5d3fa45db34e7ceb2370f30b" translate="yes" xml:space="preserve">
          <source>Originally designed and implemented by Malcolm Beattie, mbeattie@sable.ox.ac.uk as part of Safe version 1.</source>
          <target state="translated">最初由Malcolm Beattie设计和实施,mbeattie@sable.ox.ac.uk,作为安全版1的一部分。</target>
        </trans-unit>
        <trans-unit id="c8441bf717fcfb993e717e28d6000796e14219bc" translate="yes" xml:space="preserve">
          <source>Originally designed and implemented by Malcolm Beattie.</source>
          <target state="translated">最初由Malcolm Beattie设计并实施。</target>
        </trans-unit>
        <trans-unit id="b5b9ddd002b9e83e3e5ffe5e5b5e1758fac1d1ee" translate="yes" xml:space="preserve">
          <source>Originally from the old Unix editor command for &amp;ldquo;Globally search for a Regular Expression and Print it&amp;rdquo;, now used in the general sense of any kind of search, especially text searches. Perl has a built-in &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; function that searches a list for elements matching any given criterion, whereas the &lt;b&gt;grep&lt;/b&gt;(1) program searches for lines matching a &lt;b&gt;regular expression&lt;/b&gt; in one or more files.</source>
          <target state="translated">最初是从旧的Unix编辑器命令&amp;ldquo;全局搜索正则表达式并打印&amp;rdquo;开始，现在通常用于任何类型的搜索，尤其是文本搜索。Perl具有内置的 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 函数，该函数在列表中搜索与任何给定条件匹配的元素，而&lt;b&gt;grep&lt;/b&gt;（1）程序在一个或多个文件中搜索与&lt;b&gt;正则表达式&lt;/b&gt;匹配的行。</target>
        </trans-unit>
        <trans-unit id="179faca61deeed3ab0f554d9e5a2deeffd88d631" translate="yes" xml:space="preserve">
          <source>Originally part of &lt;a href=&quot;perlreguts&quot;&gt;perlreguts&lt;/a&gt;.</source>
          <target state="translated">最初是&lt;a href=&quot;perlreguts&quot;&gt;perlreguts的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="f99926744d51a0882b56c8605cf23549f21bb7f7" translate="yes" xml:space="preserve">
          <source>Originally ripped off from &lt;a href=&quot;../../../test/harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">最初从&lt;a href=&quot;../../../test/harness&quot;&gt;Test :: Harness&lt;/a&gt;剥离。</target>
        </trans-unit>
        <trans-unit id="71cbfb5529d2f3e7043bc6450156ba2700321efe" translate="yes" xml:space="preserve">
          <source>Originally ripped off from &lt;a href=&quot;../../test/harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">最初从&lt;a href=&quot;../../test/harness&quot;&gt;Test :: Harness&lt;/a&gt;剥离。</target>
        </trans-unit>
        <trans-unit id="10558d1a36f98366d4aafd194d52755ed064b37d" translate="yes" xml:space="preserve">
          <source>Originally written by Dean Roehrich &amp;lt;</source>
          <target state="translated">最初由Dean Roehrich写&amp;lt;</target>
        </trans-unit>
        <trans-unit id="40fdd20b1b0722f4c9f525e21df0d8f46d7d85b2" translate="yes" xml:space="preserve">
          <source>Originally written by Yves Orton, expanded by &amp;AElig;var Arnfj&amp;ouml;r&amp;eth; Bjarmason.</source>
          <target state="translated">最初由伊夫&amp;middot;奥顿（Yves Orton）撰写，后来由&amp;AElig;varArnfj&amp;ouml;r&amp;eth;Bjarmason扩展。</target>
        </trans-unit>
        <trans-unit id="f0958a863745f7bb7b877718e9ffc0407e157bdf" translate="yes" xml:space="preserve">
          <source>Ossanna, Joseph F., and Brian W. Kernighan. &quot;Troff User's Manual,&quot; Computing Science Technical Report No. 54, AT&amp;amp;T Bell Laboratories. This is the best documentation of standard &lt;b&gt;nroff&lt;/b&gt; and &lt;b&gt;troff&lt;/b&gt;. At the time of this writing, it's available at &lt;a href=&quot;http://www.cs.bell-labs.com/cm/cs/cstr.html&quot;&gt;http://www.cs.bell-labs.com/cm/cs/cstr.html&lt;/a&gt;.</source>
          <target state="translated">Ossanna，Joseph F.和Brian W. Kernighan。&amp;ldquo; Troff用户手册&amp;rdquo;，计算科学技术报告，第54号，AT＆T贝尔实验室。这是标准&lt;b&gt;nroff&lt;/b&gt;和&lt;b&gt;troff&lt;/b&gt;的最佳文档。在撰写本文时，可以从&lt;a href=&quot;http://www.cs.bell-labs.com/cm/cs/cstr.html&quot;&gt;http://www.cs.bell-labs.com/cm/cs/cstr.html获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4209bd1da7b6357d7fd219e08de4663ac8c8de52" translate="yes" xml:space="preserve">
          <source>Other C compilers (yes, there &lt;b&gt;are&lt;/b&gt; other C compilers than gcc) often have their &quot;strict ANSI&quot; or &quot;strict ANSI with some portability extensions&quot; modes on, like for example the Sun Workshop has its &lt;code&gt;-Xa&lt;/code&gt; mode on (though implicitly), or the DEC (these days, HP...) has its &lt;code&gt;-std1&lt;/code&gt; mode on.</source>
          <target state="translated">其他C编译器（是的，有&lt;b&gt;是&lt;/b&gt;其他C编译器GCC比）往往有自己的&amp;ldquo;严格的ANSI&amp;rdquo;或&amp;ldquo;严格ANSI与一些便携的扩展名&amp;rdquo;上，例如像太阳工作室有模式 &lt;code&gt;-Xa&lt;/code&gt; 的模式（尽管隐含），或DEC（最近是HP ...）打开了 &lt;code&gt;-std1&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="551852c7028ddd04d28686d5a46f202fe2ad7cb7" translate="yes" xml:space="preserve">
          <source>Other Functions</source>
          <target state="translated">其他功能</target>
        </trans-unit>
        <trans-unit id="0bdf87a4ace9eb276a876bd8e9250301437be6c5" translate="yes" xml:space="preserve">
          <source>Other Handy Functions</source>
          <target state="translated">其他方便的功能</target>
        </trans-unit>
        <trans-unit id="0ae890b35ce85bf30d57cf160315165f538a27b8" translate="yes" xml:space="preserve">
          <source>Other JRRT books fair game for quotes would thus include</source>
          <target state="translated">因此,其他可供引用的JRRT书籍包括</target>
        </trans-unit>
        <trans-unit id="dfc61fffa8906502d8a54b080f23a45b3b6a145a" translate="yes" xml:space="preserve">
          <source>Other Methods</source>
          <target state="translated">其他方法</target>
        </trans-unit>
        <trans-unit id="9165ac20a0a94eccf10c1024b71472d0032177d7" translate="yes" xml:space="preserve">
          <source>Other OO Systems</source>
          <target state="translated">其他OO系统</target>
        </trans-unit>
        <trans-unit id="92b14232c00517718a7c45a7ecde335eb02684ba" translate="yes" xml:space="preserve">
          <source>Other OSes</source>
          <target state="translated">其他操作系统</target>
        </trans-unit>
        <trans-unit id="ebafbcc27b9633bf022834dac0afdd7fe5320b31" translate="yes" xml:space="preserve">
          <source>Other References</source>
          <target state="translated">其他参考资料</target>
        </trans-unit>
        <trans-unit id="fa1430ad78734f8ef31e36e90d4f36de9f13a735" translate="yes" xml:space="preserve">
          <source>Other Testing Methods</source>
          <target state="translated">其他测试方法</target>
        </trans-unit>
        <trans-unit id="f0e56c564684ea4c937565ef815405ac4aa82ff1" translate="yes" xml:space="preserve">
          <source>Other available flags are:</source>
          <target state="translated">其他可用的旗帜有:</target>
        </trans-unit>
        <trans-unit id="a9a6815e54ae300be1f551c6019a20062ec0f880" translate="yes" xml:space="preserve">
          <source>Other categories</source>
          <target state="translated">其他类别</target>
        </trans-unit>
        <trans-unit id="fa31529000a27db1a7fada94ddb4d6caa2048ed7" translate="yes" xml:space="preserve">
          <source>Other characters that can't appear in Perl identifiers are also supported as aliases with Getopt::Long of at least version 2.39.</source>
          <target state="translated">其他不能出现在Perl标识符中的字符,也可以用Getopt::Long至少2.39版本作为别名来支持。</target>
        </trans-unit>
        <trans-unit id="6be322bc8ea0db1e8be06d4ec43ad756a099bfb6" translate="yes" xml:space="preserve">
          <source>Other data worth storing in a lexicon might be things like filenames for language-targetted resources:</source>
          <target state="translated">其他值得存储在词典中的数据可能是语言目标资源的文件名等。</target>
        </trans-unit>
        <trans-unit id="36fefa00642398c0b54d66e1ab2941d7ce0381ab" translate="yes" xml:space="preserve">
          <source>Other environment variables that may influence tests</source>
          <target state="translated">可能影响测试的其他环境变量</target>
        </trans-unit>
        <trans-unit id="293561c7c0c8a1abe2aec3c1c2e6ea87fd9c52f7" translate="yes" xml:space="preserve">
          <source>Other examples include</source>
          <target state="translated">其他例子包括</target>
        </trans-unit>
        <trans-unit id="050e92356c2ad433980e335b3cd1c37de82b2130" translate="yes" xml:space="preserve">
          <source>Other examples include (using standard shell syntax to show environment variable settings):</source>
          <target state="translated">其他例子包括(使用标准shell语法来显示环境变量设置)。</target>
        </trans-unit>
        <trans-unit id="0890da9a3fe9000b110723faeb22296dde791fee" translate="yes" xml:space="preserve">
          <source>Other examples include:</source>
          <target state="translated">其他例子包括:</target>
        </trans-unit>
        <trans-unit id="9b4e9be46864e281795d5dbc03712be976c67f55" translate="yes" xml:space="preserve">
          <source>Other information in the Unicode data base</source>
          <target state="translated">统一码数据库中的其他信息</target>
        </trans-unit>
        <trans-unit id="be5464268eb0652d20727c597b5d478658d7e34b" translate="yes" xml:space="preserve">
          <source>Other interesting targets in the generated Makefile are</source>
          <target state="translated">在生成的Makefile中,其他有趣的目标是</target>
        </trans-unit>
        <trans-unit id="4995af619bf2d3ae8de0384100aa88eb416db8e0" translate="yes" xml:space="preserve">
          <source>Other interesting, non-Perl books</source>
          <target state="translated">其他有趣的,非Perl的书籍</target>
        </trans-unit>
        <trans-unit id="a0a7f74c7a5b001c1898061e6c8bbb41c2b8f981" translate="yes" xml:space="preserve">
          <source>Other larger &lt;code&gt;regnode&lt;/code&gt; -like structures are defined in</source>
          <target state="translated">其他较大的 &lt;code&gt;regnode&lt;/code&gt; 的结构在</target>
        </trans-unit>
        <trans-unit id="54a8c70b7563cbb778a36bb5bcccfde96170f9d6" translate="yes" xml:space="preserve">
          <source>Other man pages to check out, like man(1), man(7), makewhatis(8), or catman(8). Normally a simple list of man pages separated by commas, or a paragraph giving the name of a reference work. Man page references, if they use the standard &lt;code&gt;name(section)&lt;/code&gt; form, don't have to be enclosed in L&amp;lt;&amp;gt; (although it's recommended), but other things in this section probably should be when appropriate.</source>
          <target state="translated">其他要检出的手册页，例如man（1），man（7），makewhatis（8）或catman（8）。通常，手册页的简单列表以逗号分隔，或者给出引用作品名称的段落。手册页引用，如果使用标准 &lt;code&gt;name(section)&lt;/code&gt; 形式，则不必将其括在L &amp;lt;&amp;gt;中（尽管建议这样做），但是本节中的其他内容可能应该适当。</target>
        </trans-unit>
        <trans-unit id="2a0be4d7126d12c4393a8f81b69236cf7f3adb37" translate="yes" xml:space="preserve">
          <source>Other methods defined in Encode::Encodings</source>
          <target state="translated">Encode::Encodings中定义的其他方法</target>
        </trans-unit>
        <trans-unit id="8b02b29f176b90b35adf0979292f2a1a362170a1" translate="yes" xml:space="preserve">
          <source>Other module design guidelines can be found in &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6b0460067623519cc565a472bd480c100039cf" translate="yes" xml:space="preserve">
          <source>Other modules</source>
          <target state="translated">其他模块</target>
        </trans-unit>
        <trans-unit id="35b38a9ced9a9e6defe1372beb74c2a71438500f" translate="yes" xml:space="preserve">
          <source>Other modules provide more specific access: &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::ODBC&quot;&gt;Win32::ODBC&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Alzabo&quot;&gt;Alzabo&lt;/a&gt;, &lt;code&gt;iodbc&lt;/code&gt; , and others found on CPAN Search: &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d291165f3e48fa04de2df661e5577d3237e36a86" translate="yes" xml:space="preserve">
          <source>Other options</source>
          <target state="translated">其他选择</target>
        </trans-unit>
        <trans-unit id="014edefbdeb134528c300bbe292e9dea3d3171e2" translate="yes" xml:space="preserve">
          <source>Other people picked up on this and started to write clever or obfuscated programs to produce the same output, spinning things quickly out of control while still providing hours of amusement for their creators and readers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c45e1355cf0a47d9a693c24c0422d1a1693c9c" translate="yes" xml:space="preserve">
          <source>Other perls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d78880c37d6825d2ae3118f278c3357f9e4c7a8" translate="yes" xml:space="preserve">
          <source>Other places to ask questions are on the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perlmonks.org%2f&quot;&gt;PerlMonks site&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fstackoverflow.com%2fquestions%2ftagged%2fperl&quot;&gt;stackoverflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94bfe5471f8f9572c8f23295ec358290aa5c0ef5" translate="yes" xml:space="preserve">
          <source>Other prebuilt perl binaries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e084077b7075b7e9a73a17897df829f14ab4b896" translate="yes" xml:space="preserve">
          <source>Other return codes are defined. See below and in the Berkeley DB documentation for details. The Berkeley DB documentation should be used as the definitive source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b333dbc669f480c73b5b58df634b402ae239a596" translate="yes" xml:space="preserve">
          <source>Other than &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;, this module upgrades to Math::BigRat, meaning that instead of 2.5 you will get 2+1/2 as output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb36362d59c4594cc709a7ea4be2c2f79bf0b417" translate="yes" xml:space="preserve">
          <source>Other than those two situations, I don't imagine that it's useful to override the &lt;code&gt;maketext&lt;/code&gt; method. (If you run into a situation where it is useful, I'd be interested in hearing about it.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5b57060690dc31c3058289c6a303662394ee99" translate="yes" xml:space="preserve">
          <source>Other useful functions are &lt;code&gt;Perl_dump_sub&lt;/code&gt; , which turns a &lt;code&gt;GV&lt;/code&gt; into an op tree, &lt;code&gt;Perl_dump_packsubs&lt;/code&gt; which calls &lt;code&gt;Perl_dump_sub&lt;/code&gt; on all the subroutines in a package like so: (Thankfully, these are all xsubs, so there is no op tree)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aec5a2099bba9d9c155d5ff98c8d088a4d87e95" translate="yes" xml:space="preserve">
          <source>Other useful sources include the Unicode Glossary &lt;a href=&quot;http://unicode.org/glossary/&quot;&gt;http://unicode.org/glossary/&lt;/a&gt;, the Free On-Line Dictionary of Computing &lt;a href=&quot;http://foldoc.org/&quot;&gt;http://foldoc.org/&lt;/a&gt;, the Jargon File &lt;a href=&quot;http://catb.org/~esr/jargon/&quot;&gt;http://catb.org/~esr/jargon/&lt;/a&gt;, and Wikipedia &lt;a href=&quot;http://www.wikipedia.org/&quot;&gt;http://www.wikipedia.org/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5dd1af1a4d04ac7e7f3b21f718a7e15571fdc1c" translate="yes" xml:space="preserve">
          <source>Other voting mechanisms may be used instead, as long as the same number of votes is gathered in a transparent manner. Specifically, proposals of which changes to cherry-pick must be visible to everyone on perl5-porters so that the views of everyone interested may be heard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac0cc8652af1d4f7f345245edd00769715fa15d" translate="yes" xml:space="preserve">
          <source>Otherwise (i.e., if not a CGI), this tries various OS-specific ways to get the language-tags for the current locale/language, and then pretends that those were the value(s) passed to &lt;code&gt;get_handle&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8e5ffbd89769bd3258cb9b3ff5d583b3da49162" translate="yes" xml:space="preserve">
          <source>Otherwise if &lt;code&gt;Configure&lt;/code&gt; found out how to do &quot;fast&quot; IO using the system's stdio, then the default layers are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1be4e61a83d07cd0d9ce46ed206ea82b9d2b71" translate="yes" xml:space="preserve">
          <source>Otherwise if you really do want to build Perl, you need to get a binary version of &lt;code&gt;gcc&lt;/code&gt; for your system first. Use a search engine to find out how to do this for your operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e91ca326f6d29d45932c9e83458e6f42f6b2d6" translate="yes" xml:space="preserve">
          <source>Otherwise the &lt;code&gt;PerlIO&lt;/code&gt; package is a place holder for additional PerlIO related functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d28c2a38bdb42602aa40deca558a7edd1c1d73" translate="yes" xml:space="preserve">
          <source>Otherwise the default layers are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee20b17c349e20c2d2bb84cf8ffa7aac44d8cc6" translate="yes" xml:space="preserve">
          <source>Otherwise this bracket group is invalid. For example, in the group &quot;[!@#,whatever]&quot;, the first item &lt;code&gt;&quot;!@#&quot;&lt;/code&gt; is neither the empty-string, &quot;_</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa4578f342729b5a29e5d40bab856fc0c1cb526" translate="yes" xml:space="preserve">
          <source>Otherwise we will try and temporarily redirect STDERR and STDOUT, do a &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; call with your command and then re-open STDERR and STDOUT. This is the method of last resort and will still allow you to execute your commands cleanly. However, no buffers will be available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a8d6e2eac21a8bc64fe947c356d86d63089cab" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;/a&lt;/code&gt; behaves like the &lt;code&gt;/u&lt;/code&gt; modifier, in that case-insensitive matching uses Unicode rules; for example, &quot;k&quot; will match the Unicode &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching, and code points in the Latin1 range, above ASCII will have Unicode rules when it comes to case-insensitive matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283ab41299e1a089a797efad0855b8234af41dba" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; demands that a library file be included if it hasn't already been included. The file is included via the do-FILE mechanism, which is essentially just a variety of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; with the caveat that lexical variables in the invoking script will be invisible to the included code. If it were implemented in pure Perl, it would have semantics similar to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8c7636a7e3958c42214af86cef6bf8fdccad1c" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;&lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt;&lt;/code&gt; sets the default modifier to &lt;code&gt;/l&lt;/code&gt; ; and &lt;code&gt;&lt;a href=&quot;feature&quot;&gt;use feature 'unicode_strings&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use VERSION&lt;/a&gt;&lt;/code&gt; (or higher) set the default to &lt;code&gt;/u&lt;/code&gt; when not in the same scope as either &lt;code&gt;&lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt;. (&lt;code&gt;&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;use locale ':not_characters'&lt;/a&gt;&lt;/code&gt; also sets the default to &lt;code&gt;/u&lt;/code&gt; , overriding any plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; .) Unlike the mechanisms mentioned above, these affect operations besides regular expressions pattern matching, and so give more consistent results with other operators, including using &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , etc. in substitution replacements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4164414c2bb6199a4fd794c5abe6619c58bbd334" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; demands that a library file be included if it hasn't already been included. The file is included via the do-FILE mechanism, which is essentially just a variety of &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; with the caveat that lexical variables in the invoking script will be invisible to the included code. If it were implemented in pure Perl, it would have semantics similar to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7cd0e99a1d89c3f5e339c3635e7cb0b51fb95e1" translate="yes" xml:space="preserve">
          <source>Otherwise, If EXPR has the UTF8 flag set:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17eeffaf5cce6164da792d14c62e778122ced660" translate="yes" xml:space="preserve">
          <source>Otherwise, Perl quotes non-ASCII characters using an adaptation from Unicode (see &lt;a href=&quot;http://www.unicode.org/reports/tr31/&quot;&gt;http://www.unicode.org/reports/tr31/&lt;/a&gt;). The only code points that are quoted are those that have any of the Unicode properties: Pattern_Syntax, Pattern_White_Space, White_Space, Default_Ignorable_Code_Point, or General_Category=Control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b263d3e8956ad637fdb45e6619d7bb400854c44" translate="yes" xml:space="preserve">
          <source>Otherwise, a reference to a hash giving the mappings (or a reference to a hash of such hashes, explained below) is returned with the following keys and their meanings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a064c97bd76ea2baffc6a1f976852c73f8662d5" translate="yes" xml:space="preserve">
          <source>Otherwise, any string that includes a &lt;code&gt;\N{&lt;i&gt;charname&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\N{U+&lt;i&gt;code point&lt;/i&gt;}&lt;/code&gt; will automatically have Unicode rules (see &lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;Byte and Character Semantics in perlunicode&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d003c1d5c8b3dbf299902770f34abe7c1bae5fc" translate="yes" xml:space="preserve">
          <source>Otherwise, besides slowing you down, you're going to break code when the thing in the scalar is actually neither a string nor a number, but a reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9e5051cf80855af13f05b6891812714206afb2" translate="yes" xml:space="preserve">
          <source>Otherwise, each group is taken to be a comma-separated group of items, and each item is interpreted as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c4557e33865fb576853827b17e4610d1545dd5" translate="yes" xml:space="preserve">
          <source>Otherwise, each item is interpreted as a string literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8160c1d9bfe0c258f726fcde8a38eac529a9399b" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; is in effect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330cfb4214259a5977f17a0c8047846f1febf41e" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; for &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790132dff7791f0de9ca7fa702e257d000b8a890" translate="yes" xml:space="preserve">
          <source>Otherwise, if fallback is TRUE or undefined for the first operand then see if the &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;rules for autogeneration&lt;/a&gt; allows another of its operators to be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed36ee27979b8527903ca8fac2a605c006c6947" translate="yes" xml:space="preserve">
          <source>Otherwise, if neither &lt;code&gt;CARP_TRACE&lt;/code&gt; nor &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; is available, stringify the value ignoring any overloading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f787cbc7a032f69fffb6119d7035816b8ea11e2" translate="yes" xml:space="preserve">
          <source>Otherwise, if the variable &lt;code&gt;$IPC::Cmd::USE_IPC_OPEN3&lt;/code&gt; is set to true (See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section), try to execute the command using &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt;. Buffers will be available on all platforms, interactive commands will still execute cleanly, and also your verbosity settings will be adhered to nicely;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe09ff3823115671ffa501d26ad1a577bc040ded" translate="yes" xml:space="preserve">
          <source>Otherwise, if you have the &lt;code&gt;verbose&lt;/code&gt; argument set to true, we fall back to a simple &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; call. We cannot capture any buffers, but interactive commands will still work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643e7b58bd1c31793f061806f8ffae4f428818df" translate="yes" xml:space="preserve">
          <source>Otherwise, import the functions into a convenient package like &lt;code&gt;HUF&lt;/code&gt; or, more general, &lt;code&gt;Aux&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3718eb10f9299de84d9700b81d5d9ff67ef5c1" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns the index into the list of the range that contains the code point.; that is, find &lt;code&gt;i&lt;/code&gt; such that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7b4536a86a677a8d4d8e936e21d06c203d8809" translate="yes" xml:space="preserve">
          <source>Otherwise, one can &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; , which has effects at compile time and run time. Since Perl 5.9.5, this pragma is lexically scoped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060d2d5af4a10b8f17638e7be02655b970ad0e80" translate="yes" xml:space="preserve">
          <source>Otherwise, the &quot;fail&quot; attribute's value should be a string denoting a method name, so that $lh-&amp;gt;maketext(</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d6075a624f71d57d66727413b2c14075c13d0f" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator behaves exactly as the comma operator or list argument separator, according to context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153f18b9e853a33ec89bf986e0079606fc138189" translate="yes" xml:space="preserve">
          <source>Otherwise, the right side is a method name or a simple scalar variable containing either the method name or a subroutine reference, and the left side must be either an object (a blessed reference) or a class name (that is, a package name). See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93adaa86658b0d707fd7e6f95b2dd74b9f755925" translate="yes" xml:space="preserve">
          <source>Otherwise, you can use the File::Temp module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cbc6561d27e47c3ea5b5fa6d9459eb9629b7617" translate="yes" xml:space="preserve">
          <source>Otherwise:</source>
          <target state="translated">Otherwise:</target>
        </trans-unit>
        <trans-unit id="96b81f4b95ad77a7f2490339a2a4369277de66dd" translate="yes" xml:space="preserve">
          <source>Our best advice for verifying a person's mail address is to have them enter their address twice, just as you normally do to change a password. This usually weeds out typos. If both versions match, send mail to that address with a personal message. If you get the message back and they've followed your directions, you can be reasonably assured that it's real.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a36d716e41b5fdfa6778288f0df9280c6ac367a9" translate="yes" xml:space="preserve">
          <source>Our community has a long-held belief that backward-compatibility is a virtue, even when the functionality in question is a design flaw.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca2af8fba9b0e206c26228fbcf4f0a28aadfadd" translate="yes" xml:space="preserve">
          <source>Our constructor and accessors are not very smart. They don't check that a &lt;code&gt;$path&lt;/code&gt; is defined, nor do they check that a &lt;code&gt;$path&lt;/code&gt; is a valid filesystem path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02046a00610d7c36994a4a1cfc35b185bf538e5f" translate="yes" xml:space="preserve">
          <source>Our first extension will be very simple. When we call the routine in the extension, it will print out a well-known message and return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0a64102e29c4a40939ff09bce3a7c8b3baeb50" translate="yes" xml:space="preserve">
          <source>Our goals include, but are not limited to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd423773d407b1a40adc986c561aae58350fc823" translate="yes" xml:space="preserve">
          <source>Our third extension will take one argument as its input, round off that value, and set the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1eca9c1df299ed6f167227271a421fa1ed8acd5" translate="yes" xml:space="preserve">
          <source>Out of Memory!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="dbd857869dc8d796444978bd605ba7b7d270b4e9" translate="yes" xml:space="preserve">
          <source>Output File Glob</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabfa26f9d0a36c1ea391888431d2b012edaa467" translate="yes" xml:space="preserve">
          <source>Output FileGlobs take the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="320abeb6fc8745d8377c151e5e59cdadfc038781" translate="yes" xml:space="preserve">
          <source>Output arguments for linking the Perl library and any extensions linked with the current Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dff47f3a71d82ad60cb4cacc40b69b766de3ff9e" translate="yes" xml:space="preserve">
          <source>Output arguments for linking the Perl library and extensions to your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4513ca13498ae2966be4acb14ad297fe3972a7d" translate="yes" xml:space="preserve">
          <source>Output data values (when they appear as constants) using Data::Dumper. Without this option, B::Deparse will use some simple routines of its own for the same purpose. Currently, Data::Dumper is better for some kinds of data (such as complex structures with sharing and self-reference) while the built-in routines are better for others (such as odd floating-point values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="946f8eaf8de365c1db6707020e600be8dc0b2d32" translate="yes" xml:space="preserve">
          <source>Output from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="732197af5a245075eb093be6a52f4e49643ea019" translate="yes" xml:space="preserve">
          <source>Output produced by &lt;code&gt;POSIX::strftime()&lt;/code&gt; , which builds a formatted human-readable date/time string, is affected by the current &lt;code&gt;LC_TIME&lt;/code&gt; locale. Thus, in a French locale, the output produced by the &lt;code&gt;%B&lt;/code&gt; format element (full month name) for the first month of the year would be &quot;janvier&quot;. Here's how to get a list of long month names in the current locale:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d20389c9ad811915dc895816013a0d6320f55cc3" translate="yes" xml:space="preserve">
          <source>Output record formats are declared as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be7301f815488d71ba9c93bb5af631cc0c5c280" translate="yes" xml:space="preserve">
          <source>Output test preamble</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb96efb75c4bbeb8be2ce6be1b81199c7dc6523" translate="yes" xml:space="preserve">
          <source>Output the string for the given capability padded as appropriate without any parameter substitution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a057a50b92dcf0b95865eb0847c9c19f40cf41" translate="yes" xml:space="preserve">
          <source>Output the summary for a &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674e1e7520d063a11e6ddc4e4cd926f65dce8e61" translate="yes" xml:space="preserve">
          <source>Output values are BigFloat objects (normalized), except for bstr() and bsstr().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5729e52e9619576e333d708f5b86cf53768b1b3b" translate="yes" xml:space="preserve">
          <source>Output values are BigInt objects (normalized), except for the methods which return a string (see &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ee72c25cceb27be8a2caf11cbdcbd8ed211c74" translate="yes" xml:space="preserve">
          <source>Output will be indented and marked with a # so as not to interfere with test output. A newline will be put on the end if there isn't one already.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c19ab0b423651729aa903ab380edeb2bca39734" translate="yes" xml:space="preserve">
          <source>Outputs a literal string with appropriate padding for the current terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="27666598a1e0a42575577d9b60e589550171ef9f" translate="yes" xml:space="preserve">
          <source>Outstanding Issues with Perl on QNX4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639d7ade090cee980c6bc05e57d3d1577af16a27" translate="yes" xml:space="preserve">
          <source>Outstanding issues with perl under QNX6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf3ed1bb141b837355c86c7c0dd2614394d1b0b" translate="yes" xml:space="preserve">
          <source>Over this group of porters presides Larry Wall. He has the final word in what does and does not change in any of the Perl programming languages. These days, Larry spends most of his time on Perl 6, while Perl 5 is shepherded by a &quot;pumpking&quot;, a porter responsible for deciding what goes into each release and ensuring that releases happen on a regular basis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e40e3844fb4d3113244cc032fb4a908e8fcd75" translate="yes" xml:space="preserve">
          <source>Overloadable Operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec86957a0fb6a3d4fbc42d54b629b68b40ef88b9" translate="yes" xml:space="preserve">
          <source>Overloading Constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b399e489ae1423cf5aaa91fe52bb0ca8621359b8" translate="yes" xml:space="preserve">
          <source>Overloading respects inheritance via the @ISA hierarchy. Inheritance interacts with overloading in two ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25853ad0b9aa2087c0afaa6cc2a5913f690f84b" translate="yes" xml:space="preserve">
          <source>Overridable by PREFIX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467a685e8ada69aefbe5924cc457f1afc183b3db" translate="yes" xml:space="preserve">
          <source>Overridden by PREFIX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de838ce5cdf14a3fefb1762cc63935ac8b01d94" translate="yes" xml:space="preserve">
          <source>Overridden methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ab6a26cd6f669c409ca6006d7c65633ebdbc28" translate="yes" xml:space="preserve">
          <source>Override Unix. Cygwin case-tolerance depends on managed mount settings and as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE, indicating the case significance when comparing file specifications. Default: 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b812a67f3c81aa251e9cf3aa48fd3d76b409d29b" translate="yes" xml:space="preserve">
          <source>Override some of the slower, portable commands with Windows specific ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c9857b122b80fa1b6a56bf1ebf37d184d83e68" translate="yes" xml:space="preserve">
          <source>Override the *DEFINE_VERSION macros with VMS semantics. Translate the MAKEMAKER filepath to VMS style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e106e8d2f26a8506c045db84481cb6d80e276c4" translate="yes" xml:space="preserve">
          <source>Override the built-in hex() method with a version that can handle big integers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as hex() is lexically overridden in the current scope whenever the bigint pragma is active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1255a81faff303e8d6e7d3b798d7ce08d1d0bd" translate="yes" xml:space="preserve">
          <source>Override the built-in hex() method with a version that can handle big numbers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as hex() is lexically overridden in the current scope whenever the bignum pragma is active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912f152c86b0fefa5f757189a8d412dd86bae7f1" translate="yes" xml:space="preserve">
          <source>Override the built-in hex() method with a version that can handle big numbers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as hex() is lexically overridden in the current scope whenever the bigrat pragma is active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517fe3ab934c9baa1bbd4819a553d1bd788ad3b6" translate="yes" xml:space="preserve">
          <source>Override the built-in oct() method with a version that can handle big integers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as oct() is lexically overridden in the current scope whenever the bigint pragma is active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bed448b71cf61598fc58c7dedb86dd2c891a406" translate="yes" xml:space="preserve">
          <source>Override the built-in oct() method with a version that can handle big numbers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as oct() is lexically overridden in the current scope whenever the bigint pragma is active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5c7e59eb86a96d19a5d320701f2eeae30a9f3d" translate="yes" xml:space="preserve">
          <source>Override the built-in oct() method with a version that can handle big numbers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as oct() is lexically overridden in the current scope whenever the bigrat pragma is active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84161f7c8651d9dbb9584e62df4eb94978336a4" translate="yes" xml:space="preserve">
          <source>Override the default link and compile tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3576b163731229acda47e87e9f9b059e9f4a5b" translate="yes" xml:space="preserve">
          <source>Overriden Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ddbf620473fa127baa14c63b6b03e218cdb828" translate="yes" xml:space="preserve">
          <source>Overrides &lt;code&gt;Carp&lt;/code&gt; 's use of &lt;code&gt;@ISA&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f558940f2808fb5910806545f490b364bd4fae6" translate="yes" xml:space="preserve">
          <source>Overriding *AutoLoader*'s AUTOLOAD Subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad165e83687c2095d41c401a84a596f21c23d403" translate="yes" xml:space="preserve">
          <source>Overriding &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD Subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e4e6c170816454742428861af9c648b7770476" translate="yes" xml:space="preserve">
          <source>Overriding Built-in Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0473324f13f95874cc801aec0b7f96d36dd3f4de" translate="yes" xml:space="preserve">
          <source>Overriding MakeMaker Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8975db571ede7ae4ff4258fa3aa601af32455235" translate="yes" xml:space="preserve">
          <source>Overriding may be done only by importing the name from a module at compile time--ordinary predeclaration isn't good enough. However, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; pragma lets you, in effect, predeclare subs via the import syntax, and these names may then override built-in ones:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304bd31d39d40b4f3f802e079ce7c0e189c81a09" translate="yes" xml:space="preserve">
          <source>Overriding methods and method resolution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffad1af53b33d79810d2c0405dc312e1ae6928cd" translate="yes" xml:space="preserve">
          <source>Overstruck text is best viewed by page-at-a-time programs that take advantage of the terminal's &lt;b&gt;stand-out&lt;/b&gt; and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="a66e34441ac56e5f8863c6bb5ce6bb649c646c79" translate="yes" xml:space="preserve">
          <source>Ownwership of directories that already exist will not be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90ae34a7bbf5b215bf702e4f15a56d1024f60a9" translate="yes" xml:space="preserve">
          <source>Oxford English Dictionary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="a5574a0609f5eaeb5946f32c91fbd5d565ba5c54" translate="yes" xml:space="preserve">
          <source>PA-RISC</source>
          <target state="translated">PA-RISC</target>
        </trans-unit>
        <trans-unit id="b18e26c5d2442635220100cdbb4632471aa32d8c" translate="yes" xml:space="preserve">
          <source>PA-RISC 1.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb216919e4e2e5c1a44316f9467b8ca7837ec3cc" translate="yes" xml:space="preserve">
          <source>PA-RISC 1.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db7ada64f0dcd494ae2a9fde52058fe389930fc0" translate="yes" xml:space="preserve">
          <source>PA-RISC 2.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a671d1a90e2150d11e2b1f6323c00da36fa35704" translate="yes" xml:space="preserve">
          <source>PA-RISC and Itanium object files are not interchangeable. Although you may be able to use ar to create an archive library of PA-RISC object files on an Itanium system, you cannot link against it using an Itanium link editor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e778bd20eb20ec966352f3796d7c0931f2a1b52" translate="yes" xml:space="preserve">
          <source>PACKAGE</source>
          <target state="translated">PACKAGE</target>
        </trans-unit>
        <trans-unit id="3b24034394fd782a09f93e8a5e6a19e433f5c0b7" translate="yes" xml:space="preserve">
          <source>PACKAGE VARIABLES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5757bc942837b06dcea162133be87f1399efdb1" translate="yes" xml:space="preserve">
          <source>PAD-RELATED CLASSES</source>
          <target state="translated">垫相关类</target>
        </trans-unit>
        <trans-unit id="5256fd77701bc17fcebded5655a52af6c191f7ca" translate="yes" xml:space="preserve">
          <source>PADDING OF BASE64 DIGESTS</source>
          <target state="translated">BASE64 DIGESTS的衬垫。</target>
        </trans-unit>
        <trans-unit id="92903ba42bddaecab9133139d6657d1d38035291" translate="yes" xml:space="preserve">
          <source>PAR - optional module which can treat &lt;code&gt;.par&lt;/code&gt; files as Perl libraries.</source>
          <target state="translated">PAR-可选模块，可以将 &lt;code&gt;.par&lt;/code&gt; 文件视为Perl库。</target>
        </trans-unit>
        <trans-unit id="8aa67c70b62b88425c0805fe7ee18784ade05280" translate="yes" xml:space="preserve">
          <source>PARNO</source>
          <target state="translated">PARNO</target>
        </trans-unit>
        <trans-unit id="d76071dc758ed7e342554ae65110a5912fa75887" translate="yes" xml:space="preserve">
          <source>PARSING OPTIONS</source>
          <target state="translated">搜索选项</target>
        </trans-unit>
        <trans-unit id="2f27cfe52f75001eb8b13ac0b269b4d71a7d0eff" translate="yes" xml:space="preserve">
          <source>PATCHING</source>
          <target state="translated">PATCHING</target>
        </trans-unit>
        <trans-unit id="b991d9932b6d73d6525c72b0344ecaf0a6e70612" translate="yes" xml:space="preserve">
          <source>PATCHING PERL</source>
          <target state="translated">修补PERL</target>
        </trans-unit>
        <trans-unit id="09bd6a353a7bb8a33e37cfee71ada9fc9ce37d89" translate="yes" xml:space="preserve">
          <source>PATH</source>
          <target state="translated">PATH</target>
        </trans-unit>
        <trans-unit id="97000043438fbbe1d01d067a89cdcef2f0e8c14c" translate="yes" xml:space="preserve">
          <source>PATHNAME CONSTANTS</source>
          <target state="translated">路径名称常数</target>
        </trans-unit>
        <trans-unit id="84c16d6a502dba6bf2d3fee213424d5d6bfb7b62" translate="yes" xml:space="preserve">
          <source>PATTERN</source>
          <target state="translated">PATTERN</target>
        </trans-unit>
        <trans-unit id="dac71a6819627d348c31a24b525d7fa382bddadb" translate="yes" xml:space="preserve">
          <source>PCRE/Python Support</source>
          <target state="translated">PCRE/python支持</target>
        </trans-unit>
        <trans-unit id="d613d88cb2d86f484f6f82d44ac1fc60722abe20" translate="yes" xml:space="preserve">
          <source>PDF</source>
          <target state="translated">PDF</target>
        </trans-unit>
        <trans-unit id="aa3411cdbe71b0a21abc88a3963b8403693bbc1b" translate="yes" xml:space="preserve">
          <source>PERFORMANCE</source>
          <target state="translated">PERFORMANCE</target>
        </trans-unit>
        <trans-unit id="a039af5d518d5df4edecd9355e8862ee9074cf7a" translate="yes" xml:space="preserve">
          <source>PERL 5 PORTERS</source>
          <target state="translated">PERL 5 PORTERS</target>
        </trans-unit>
        <trans-unit id="7e824f1cd9308ba64d688a71fcc968d2bf452aa4" translate="yes" xml:space="preserve">
          <source>PERL 5.8.0 BROKEN IN AMIGAOS</source>
          <target state="translated">PERL 5.8.0 BROKEN IN AMIGAOS.</target>
        </trans-unit>
        <trans-unit id="2ad8575bde04df8f3c3405e287595936fe2f6b74" translate="yes" xml:space="preserve">
          <source>PERL OO SYSTEMS</source>
          <target state="translated">PERL OO系统</target>
        </trans-unit>
        <trans-unit id="38707bbc3a64c94dc99f9b43d452049c22f48409" translate="yes" xml:space="preserve">
          <source>PERL.C</source>
          <target state="translated">PERL.C</target>
        </trans-unit>
        <trans-unit id="c4ef015b035531ca89e73efd9974dbb427096dd2" translate="yes" xml:space="preserve">
          <source>PERL.EXE</source>
          <target state="translated">PERL.EXE</target>
        </trans-unit>
        <trans-unit id="0f9466733223ddd1a05cbf29bb33f0f356cbffcb" translate="yes" xml:space="preserve">
          <source>PERL.H</source>
          <target state="translated">PERL.H</target>
        </trans-unit>
        <trans-unit id="4a444e7468c0f9cc5930e13403ef14557c1dcc70" translate="yes" xml:space="preserve">
          <source>PERL.OBJ</source>
          <target state="translated">PERL.OBJ</target>
        </trans-unit>
        <trans-unit id="52d59ca4a1575427154cd0921e5e7f03fc93f8dc" translate="yes" xml:space="preserve">
          <source>PERL5LIB and PERLLIB</source>
          <target state="translated">PERL5LIB和PERLLIB</target>
        </trans-unit>
        <trans-unit id="f0a75fb949dd06b3f9081176db6123371bfe89bd" translate="yes" xml:space="preserve">
          <source>PERLDOCS</source>
          <target state="translated">PERLDOCS</target>
        </trans-unit>
        <trans-unit id="985d8b7cd33b8ae8b97c10576f8525c5e43feb2b" translate="yes" xml:space="preserve">
          <source>PERLLIB_PREFIX</source>
          <target state="translated">PERLLIB_PREFIX</target>
        </trans-unit>
        <trans-unit id="a58122b37384a35d76a112224ebc05023622985d" translate="yes" xml:space="preserve">
          <source>PERLSHR</source>
          <target state="translated">PERLSHR</target>
        </trans-unit>
        <trans-unit id="f9b90ea60310458da34842ec49d8ba2dcc6d6842" translate="yes" xml:space="preserve">
          <source>PERL_ARCHIVE: path to libperl.a equivalent to be linked to dynamic extensions.</source>
          <target state="translated">PERL_ARCHIVE:libperl.a等价物的路径,可以链接到动态扩展。</target>
        </trans-unit>
        <trans-unit id="6b32b9f2a6388fd49d59dc380fdfe54ede4bbab4" translate="yes" xml:space="preserve">
          <source>PERL_ARCHIVE_AFTER: path to a library which should be put on the linker command line</source>
          <target state="translated">PERL_ARCHIVE_AFTER:应该放在链接器命令行的库的路径。</target>
        </trans-unit>
        <trans-unit id="4c6d51550dda10c59c0baefc83a359a9b3e89e2d" translate="yes" xml:space="preserve">
          <source>PERL_BADFREE</source>
          <target state="translated">PERL_BADFREE</target>
        </trans-unit>
        <trans-unit id="a23a8f24b9f1defe9ff92b59171d38cc844c2e5c" translate="yes" xml:space="preserve">
          <source>PERL_BADLANG</source>
          <target state="translated">PERL_BADLANG</target>
        </trans-unit>
        <trans-unit id="ea61b8e3a3a6f667f8ac07d9441b74f7086fd4b1" translate="yes" xml:space="preserve">
          <source>PERL_DESTRUCT_LEVEL</source>
          <target state="translated">PERL_DESTRUCT_LEVEL</target>
        </trans-unit>
        <trans-unit id="61a82fd6ba532d8a72b14f2af64e53732c3f8065" translate="yes" xml:space="preserve">
          <source>PERL_ENV_TABLES</source>
          <target state="translated">PERL_ENV_TABLES</target>
        </trans-unit>
        <trans-unit id="df55d3100213212432ed7cb5fb2ce8aff5bb5e34" translate="yes" xml:space="preserve">
          <source>PERL_JSON_BACKEND</source>
          <target state="translated">PERL_JSON_BACKEND</target>
        </trans-unit>
        <trans-unit id="7406046b29d774dab6f67c9ebf1226de7875707f" translate="yes" xml:space="preserve">
          <source>PERL_MEM_LOG</source>
          <target state="translated">PERL_MEM_LOG</target>
        </trans-unit>
        <trans-unit id="35728d129bbb3e5ed03314204a1cbf6d4ce2e6d0" translate="yes" xml:space="preserve">
          <source>PERL_SET_CONTEXT(interp) should also be called whenever &lt;code&gt;interp&lt;/code&gt; is used by a thread that did not create it (using either perl_alloc(), or the more esoteric perl_clone()).</source>
          <target state="translated">每当PERL_SET_CONTEXT（口译）也应该被称为 &lt;code&gt;interp&lt;/code&gt; 时使用一个线程，并没有创造它（使用perl_alloc（），或更深奥的perl_clone（））。</target>
        </trans-unit>
        <trans-unit id="a871d7bf7b2a02e819c07cf4df026d57906b3e51" translate="yes" xml:space="preserve">
          <source>PERL_SH_DIR</source>
          <target state="translated">PERL_SH_DIR</target>
        </trans-unit>
        <trans-unit id="4e4019cc5e2b7ec5fc3d43d1227c4891f068a0c3" translate="yes" xml:space="preserve">
          <source>PERL_VMS_EXCEPTION_DEBUG</source>
          <target state="translated">PERL_VMS_EXCEPTION_DEBUG</target>
        </trans-unit>
        <trans-unit id="22d485a76570fc46268de520a55e10a9a69f35aa" translate="yes" xml:space="preserve">
          <source>PERL_YAML_BACKEND</source>
          <target state="translated">PERL_YAML_BACKEND</target>
        </trans-unit>
        <trans-unit id="70101c7c85d7116954e48d6da8dddb7074ef2a17" translate="yes" xml:space="preserve">
          <source>PERSISTENT CACHE SUPPORT</source>
          <target state="translated">持续的缓存支持</target>
        </trans-unit>
        <trans-unit id="60003793ea7b554ef4aa8d86e943a5c0f46d5e37" translate="yes" xml:space="preserve">
          <source>PF_INET, PF_INET6, PF_UNIX, ...</source>
          <target state="translated">PF_INET,PF_INET6,PF_UNIX,...</target>
        </trans-unit>
        <trans-unit id="fa7ff6fb00a7ace8d98cf880a492dc6c5ffc8ca7" translate="yes" xml:space="preserve">
          <source>PI</source>
          <target state="translated">PI</target>
        </trans-unit>
        <trans-unit id="3490ca5e3137d6e80d152267527e5428418a006e" translate="yes" xml:space="preserve">
          <source>PL files are normally run &lt;b&gt;after&lt;/b&gt; pm_to_blib and include INST_LIB and INST_ARCH in their &lt;code&gt;@INC&lt;/code&gt; , so the just built modules can be accessed... unless the PL file is making a module (or anything else in PM) in which case it is run &lt;b&gt;before&lt;/b&gt; pm_to_blib and does not include INST_LIB and INST_ARCH in its &lt;code&gt;@INC&lt;/code&gt; . This apparently odd behavior is there for backwards compatibility (and it's somewhat DWIM).</source>
          <target state="translated">PL文件被运行正常&lt;b&gt;后&lt;/b&gt; pm_to_blib，包括INST_LIB和INST_ARCH在他们的 &lt;code&gt;@INC&lt;/code&gt; ，所以刚刚建成的模块可以被访问......除非PL文件正在在这种情况下它运行模块（或PM别的）&lt;b&gt;前&lt;/b&gt; pm_to_blib，并且其 &lt;code&gt;@INC&lt;/code&gt; 中不包含INST_LIB和INST_ARCH 。这种显然奇怪的行为是为了向后兼容（有点DWIM）。</target>
        </trans-unit>
        <trans-unit id="1f9b4355202a16dca9278309f8c57bab627534d7" translate="yes" xml:space="preserve">
          <source>PLANE ANGLE CONVERSIONS</source>
          <target state="translated">飞机角度转换</target>
        </trans-unit>
        <trans-unit id="397f26f7a31d1d29ed32b8ae38758d964d147496" translate="yes" xml:space="preserve">
          <source>PLATFORMS</source>
          <target state="translated">PLATFORMS</target>
        </trans-unit>
        <trans-unit id="0fcaf629ebcd1ef3b077048317114d46dcb1a205" translate="yes" xml:space="preserve">
          <source>PLUGINS</source>
          <target state="translated">PLUGINS</target>
        </trans-unit>
        <trans-unit id="96bb1ede828d06c7c676fc4aca0b2ab0fc3aaec6" translate="yes" xml:space="preserve">
          <source>POD</source>
          <target state="translated">POD</target>
        </trans-unit>
        <trans-unit id="9757efd691d77c4c7ce7af22ae0498da057b96f2" translate="yes" xml:space="preserve">
          <source>POD commands.</source>
          <target state="translated">POD指令。</target>
        </trans-unit>
        <trans-unit id="4f47ae786af8b3ae6d44df79389191724c8e9b20" translate="yes" xml:space="preserve">
          <source>POD documentation</source>
          <target state="translated">POD文件</target>
        </trans-unit>
        <trans-unit id="e5ddb6a6721405eb11c587453e0434d2f646aa07" translate="yes" xml:space="preserve">
          <source>POD2MAN_macro</source>
          <target state="translated">POD2MAN_macro</target>
        </trans-unit>
        <trans-unit id="3bd1038b0ae3b6d74e0afdd1bb9c713c175f1f33" translate="yes" xml:space="preserve">
          <source>PODs: Embedded Documentation</source>
          <target state="translated">PODs。嵌入式文件</target>
        </trans-unit>
        <trans-unit id="27d22d20fdc49ff65099906e5eeacad058aeb916" translate="yes" xml:space="preserve">
          <source>POPULATE AN INSTALLATION WITH LOTS OF MODULES</source>
          <target state="translated">用大量的模块来填充一个装置。</target>
        </trans-unit>
        <trans-unit id="dfb1d5b6c2198f6b90dd9fb2aa67809b15a77598" translate="yes" xml:space="preserve">
          <source>PORTABILITY</source>
          <target state="translated">PORTABILITY</target>
        </trans-unit>
        <trans-unit id="fac926bb8a4de690e4dca18f3225a7ad2a06037c" translate="yes" xml:space="preserve">
          <source>PORTABILITY CAVEATS</source>
          <target state="translated">便携性缓冲器</target>
        </trans-unit>
        <trans-unit id="eeaaaed2401766705588000c95399212adce6cd4" translate="yes" xml:space="preserve">
          <source>POS is absolute position. (Seek relative to the start of the file)</source>
          <target state="translated">POS是绝对位置。(相对于文件的起始位置寻找)</target>
        </trans-unit>
        <trans-unit id="eff46aebd5f7e19f03d6237cd80da90014c8e132" translate="yes" xml:space="preserve">
          <source>POS is an offset from the current position. (Seek relative to current)</source>
          <target state="translated">POS是当前位置的偏移量。(相对于当前位置的搜索)</target>
        </trans-unit>
        <trans-unit id="4a3852f381cc7917e0a6f01c96db05db1939d7a5" translate="yes" xml:space="preserve">
          <source>POS is an offset from the end of the file. (Seek relative to end)</source>
          <target state="translated">POS是文件结束的偏移量。(相对于文件末尾寻找)</target>
        </trans-unit>
        <trans-unit id="23507e798d66fee0b05313c2a15e15ff93e82f20" translate="yes" xml:space="preserve">
          <source>POSIX</source>
          <target state="translated">POSIX</target>
        </trans-unit>
        <trans-unit id="ae89c95fa22e7b32fa45fce7e8bf404e997e9054" translate="yes" xml:space="preserve">
          <source>POSIX - Perl interface to IEEE Std 1003.1</source>
          <target state="translated">POSIX-IEEE Std 1003.1的Perl接口。</target>
        </trans-unit>
        <trans-unit id="d243eb13195dcdb315427d56a4c35f42dcb04024" translate="yes" xml:space="preserve">
          <source>POSIX CONSTANTS</source>
          <target state="translated">POSIX CONSTANTS</target>
        </trans-unit>
        <trans-unit id="5c9c75047d91af941801f6c6002bbc479d31b75d" translate="yes" xml:space="preserve">
          <source>POSIX Character Classes</source>
          <target state="translated">POSIX字符类</target>
        </trans-unit>
        <trans-unit id="f2d1e7de0e60a574e6d87a0cc3a67de6faf43784" translate="yes" xml:space="preserve">
          <source>POSIX FLAGS</source>
          <target state="translated">POSIX旗帜</target>
        </trans-unit>
        <trans-unit id="569385480ca60be76d48d613b39e1bc91f7990bf" translate="yes" xml:space="preserve">
          <source>POSIX FUNCTIONS</source>
          <target state="translated">POSIX函数</target>
        </trans-unit>
        <trans-unit id="06b4e35ce432cb4702f6a995fe95c52f8db39c2a" translate="yes" xml:space="preserve">
          <source>POSIX character classes and their Unicode and Perl equivalents:</source>
          <target state="translated">POSIX字符类及其Unicode和Perl等价物。</target>
        </trans-unit>
        <trans-unit id="72593fbc583aea6c901e13572f670a7d0d357161" translate="yes" xml:space="preserve">
          <source>POSIX character classes can be part of a larger bracketed character class. For example,</source>
          <target state="translated">POSIX字符类可以是一个更大的括号内字符类的一部分。例如:</target>
        </trans-unit>
        <trans-unit id="b4c2f7d57ee138ef8741ea704a671378863f20a1" translate="yes" xml:space="preserve">
          <source>POSIX character classes have the form &lt;code&gt;[:class:]&lt;/code&gt;, where</source>
          <target state="translated">POSIX字符类的格式为 &lt;code&gt;[:class:]&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="61668ef8f25bddd14989c415629b0df07e51f44b" translate="yes" xml:space="preserve">
          <source>POSIX functions:</source>
          <target state="translated">POSIX函数。</target>
        </trans-unit>
        <trans-unit id="04680e6e37ce6d2dcbb31e0e8a36d7516c0e506b" translate="yes" xml:space="preserve">
          <source>POSIX-BC?</source>
          <target state="translated">POSIX-BC?</target>
        </trans-unit>
        <trans-unit id="864a3ec5736c1f231ee60dfa1ac4b3cf0adce372" translate="yes" xml:space="preserve">
          <source>POSIX.2</source>
          <target state="translated">POSIX.2</target>
        </trans-unit>
        <trans-unit id="3777385d2dd1e8926a9b75a14303ee4b22211baa" translate="yes" xml:space="preserve">
          <source>POSIX.pm</source>
          <target state="translated">POSIX.pm</target>
        </trans-unit>
        <trans-unit id="d45e49d46b986bef0fad349a44b3e4ef42953d70" translate="yes" xml:space="preserve">
          <source>POSIX::SigAction</source>
          <target state="translated">POSIX::SigAction</target>
        </trans-unit>
        <trans-unit id="74a299dde6a5128d521b652f2ba458a4da06a6a1" translate="yes" xml:space="preserve">
          <source>POSIX::SigRt</source>
          <target state="translated">POSIX::SigRt</target>
        </trans-unit>
        <trans-unit id="9cca0191c626eb89ac7a531f06862f8df3747e24" translate="yes" xml:space="preserve">
          <source>POSIX::SigSet</source>
          <target state="translated">POSIX::SigSet</target>
        </trans-unit>
        <trans-unit id="2b1f5cae0839a5eb5bae78193bd1a07008a2110c" translate="yes" xml:space="preserve">
          <source>POSIX::Termios</source>
          <target state="translated">POSIX::Termios</target>
        </trans-unit>
        <trans-unit id="fa4963cab46f1be7f819925dbfd48f68153bfc4a" translate="yes" xml:space="preserve">
          <source>POST-STRING</source>
          <target state="translated">POST-STRING</target>
        </trans-unit>
        <trans-unit id="d0012d64d9af33bc1cf8483ab0fda421fad18ba8" translate="yes" xml:space="preserve">
          <source>POSTSCRIPT</source>
          <target state="translated">POSTSCRIPT</target>
        </trans-unit>
        <trans-unit id="f581395efe2773e539af041b5a27fa1d0df00b1e" translate="yes" xml:space="preserve">
          <source>PRE-STRING</source>
          <target state="translated">PRE-STRING</target>
        </trans-unit>
        <trans-unit id="7840941760ebcd9fee13ec0f1666aa06fbb11bc3" translate="yes" xml:space="preserve">
          <source>PREAMBLE</source>
          <target state="translated">PREAMBLE</target>
        </trans-unit>
        <trans-unit id="69db2c13c51cc2aaf32e02ecde5988835599fa47" translate="yes" xml:space="preserve">
          <source>PREBUILT BINARIES OF PERL FOR SOLARIS.</source>
          <target state="translated">为SOLARIS提供的PERL预制模块。</target>
        </trans-unit>
        <trans-unit id="4772fd326573fd42e768a1b15dd58bbb9cc8b317" translate="yes" xml:space="preserve">
          <source>PREFIX and LIB attribute</source>
          <target state="translated">PREFIX和LIB属性</target>
        </trans-unit>
        <trans-unit id="c6ea2417cccb8facb1f2ec2c030cf1e5c2fcb2f6" translate="yes" xml:space="preserve">
          <source>PREFIX and LIB can be used to set several INSTALL* attributes in one go. Here's an example for installing into your home directory.</source>
          <target state="translated">PREFIX和LIB可以用来一次设置多个INSTALL*属性。下面是一个安装到你的主目录的例子。</target>
        </trans-unit>
        <trans-unit id="40aa4e60b9a6d17247b06ec0bb028f55b0430593" translate="yes" xml:space="preserve">
          <source>PREFIX is the name of the SYMREF you're walking.</source>
          <target state="translated">PREFIX是你走的SYMREF的名字。</target>
        </trans-unit>
        <trans-unit id="300c67e39443a38d0f595a8a987e17d646e3c291" translate="yes" xml:space="preserve">
          <source>PREFS</source>
          <target state="translated">PREFS</target>
        </trans-unit>
        <trans-unit id="9bc7b53b4ddb9c0604309a8f097387c59f61cafb" translate="yes" xml:space="preserve">
          <source>PREPARING TO USE LOCALES</source>
          <target state="translated">准备使用LOCALES</target>
        </trans-unit>
        <trans-unit id="281d6f01426cc7b0d2d1be7a9e3ef9753991bf8a" translate="yes" xml:space="preserve">
          <source>PREREQUISITES</source>
          <target state="translated">PREREQUISITES</target>
        </trans-unit>
        <trans-unit id="109e7210182e5f1a38490846d4f7c1bf6d1efeaf" translate="yes" xml:space="preserve">
          <source>PREREQUISITES FOR COMPILING PERL ON CYGWIN</source>
          <target state="translated">在CYGWIN上编译PERL的先决条件。</target>
        </trans-unit>
        <trans-unit id="d596e5c41b06e835a227eaeb7f80e95e078526da" translate="yes" xml:space="preserve">
          <source>PRIVATE METHODS AND DATA</source>
          <target state="translated">私人方法和数据</target>
        </trans-unit>
        <trans-unit id="28128cb215ccf5b12e0dff7a0c33d632bc940a28" translate="yes" xml:space="preserve">
          <source>PROBES</source>
          <target state="translated">PROBES</target>
        </trans-unit>
        <trans-unit id="9f903b4f167ea635d9adabe61a39c7254588d35a" translate="yes" xml:space="preserve">
          <source>PROCESS</source>
          <target state="translated">PROCESS</target>
        </trans-unit>
        <trans-unit id="924eaf1172c6dafd288f2618c0a1efe247bb92db" translate="yes" xml:space="preserve">
          <source>PROFILING</source>
          <target state="translated">PROFILING</target>
        </trans-unit>
        <trans-unit id="85dfd02e93a90ca8a93ed7e5af4995f7549887d0" translate="yes" xml:space="preserve">
          <source>PROFILING TOOLS</source>
          <target state="translated">剖析工具</target>
        </trans-unit>
        <trans-unit id="9e3a8f7206c88ef34624181efda07f832c576870" translate="yes" xml:space="preserve">
          <source>PROGRAMMER'S INTERFACE</source>
          <target state="translated">程序员界面</target>
        </trans-unit>
        <trans-unit id="9e97d57f23d497e98a3c17e698f142751c84db81" translate="yes" xml:space="preserve">
          <source>PSEUDO RESPONSES</source>
          <target state="translated">PSEUDO答复</target>
        </trans-unit>
        <trans-unit id="dd4d85a958623a5705575960b9b4ae857188fa7f" translate="yes" xml:space="preserve">
          <source>PUSHCOLOR, POPCOLOR, and LOCALCOLOR were contributed by openmethods.com voice solutions.</source>
          <target state="translated">PUSHCOLOR、POPCOLOR和LOCALCOLOR由openmethods.com语音解决方案贡献。</target>
        </trans-unit>
        <trans-unit id="13e54ce098168f1fa1db9a288e5396806317b03b" translate="yes" xml:space="preserve">
          <source>PV</source>
          <target state="translated">PV</target>
        </trans-unit>
        <trans-unit id="4f4fc2fe1cdfbd4b127686b3c4701bfcc8bf5850" translate="yes" xml:space="preserve">
          <source>PVN</source>
          <target state="translated">PVN</target>
        </trans-unit>
        <trans-unit id="dbe7115eeb4102987d54e476c53cd399a6656a26" translate="yes" xml:space="preserve">
          <source>PVers</source>
          <target state="translated">PVers</target>
        </trans-unit>
        <trans-unit id="4db84d6ad2a10668614932a965ea5a3997c49335" translate="yes" xml:space="preserve">
          <source>Pack Recipes</source>
          <target state="translated">包装食谱</target>
        </trans-unit>
        <trans-unit id="e5a69f2e40897b5daef39457bf875f755ff8707d" translate="yes" xml:space="preserve">
          <source>Pack and Unpack</source>
          <target state="translated">包装和拆包</target>
        </trans-unit>
        <trans-unit id="ae88d737dc553c18917f526e7ed4fab3bcf7d255" translate="yes" xml:space="preserve">
          <source>Pack and unpack can operate in two modes: character mode (&lt;code&gt;C0&lt;/code&gt; mode) where the packed string is processed per character, and UTF-8 byte mode (&lt;code&gt;U0&lt;/code&gt; mode) where the packed string is processed in its UTF-8-encoded Unicode form on a byte-by-byte basis. Character mode is the default unless the format string starts with &lt;code&gt;U&lt;/code&gt; . You can always switch mode mid-format with an explicit &lt;code&gt;C0&lt;/code&gt; or &lt;code&gt;U0&lt;/code&gt; in the format. This mode remains in effect until the next mode change, or until the end of the &lt;code&gt;()&lt;/code&gt; group it (directly) applies to.</source>
          <target state="translated">打包和解压缩可以在两种模式下操作：字符模式（ &lt;code&gt;C0&lt;/code&gt; 模式），其中每个字符处理打包的字符串；以及UTF-8字节模式（ &lt;code&gt;U0&lt;/code&gt; 模式），其中打包字符串以其UTF-8编码的Unicode格式处理。以字节为单位。除非格式字符串以 &lt;code&gt;U&lt;/code&gt; 开头，否则默认为字符模式。您始终可以使用显式 &lt;code&gt;C0&lt;/code&gt; 或 &lt;code&gt;U0&lt;/code&gt; 格式切换中间格式的模式。该模式将保持有效，直到下一个模式更改或直到（直接）应用于 &lt;code&gt;()&lt;/code&gt; 组的末尾为止。</target>
        </trans-unit>
        <trans-unit id="1557120d5088a59d57273db042de727192d13fe4" translate="yes" xml:space="preserve">
          <source>Package &lt;code&gt;overload.pm&lt;/code&gt; provides the following public functions:</source>
          <target state="translated">软件包 &lt;code&gt;overload.pm&lt;/code&gt; 提供了以下公共功能：</target>
        </trans-unit>
        <trans-unit id="854d1d4510ef2ba36738b3c6bee00faff7d95b8e" translate="yes" xml:space="preserve">
          <source>Package Lexicals</source>
          <target state="translated">包装词条</target>
        </trans-unit>
        <trans-unit id="2c11074689b7e2ad2c208b4e9d700f62e8d77364" translate="yes" xml:space="preserve">
          <source>Package for overloading Perl operations</source>
          <target state="translated">用于重载Perl操作的软件包</target>
        </trans-unit>
        <trans-unit id="0bb1778e3f25a2a84d101d6e9168311f3de452b1" translate="yes" xml:space="preserve">
          <source>Package lexicals declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; in the main block of a package using &lt;b&gt;AutoLoader&lt;/b&gt; will not be visible to auto-loaded subroutines, due to the fact that the given scope ends at the &lt;code&gt;__END__&lt;/code&gt; marker. A module using such variables as package globals will not work properly under the &lt;b&gt;AutoLoader&lt;/b&gt;.</source>
          <target state="translated">使用给定的作用域以 &lt;code&gt;__END__&lt;/code&gt; 结尾的事实，使用&lt;b&gt;AutoLoader&lt;/b&gt;在包的主块中用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明的包词法对于自动加载的子例程不可见。使用诸如包全局变量之类的变量的模块在&lt;b&gt;AutoLoader&lt;/b&gt;下将无法正常工作。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="61fda0710845c0ff2e124df892b08c2fdc3b0249" translate="yes" xml:space="preserve">
          <source>Package names are sometimes an exception to this rule. Perl informally reserves lowercase module names for &quot;pragma&quot; modules like &lt;code&gt;integer&lt;/code&gt; and &lt;code&gt;strict&lt;/code&gt; . Other modules should begin with a capital letter and use mixed case, but probably without underscores due to limitations in primitive file systems' representations of module names as files that must fit into a few sparse bytes.</source>
          <target state="translated">程序包名称有时是该规则的例外。Perl非正式地为&amp;ldquo; pragma&amp;rdquo;模块保留小写的模块名称，例如 &lt;code&gt;integer&lt;/code&gt; 和 &lt;code&gt;strict&lt;/code&gt; 。其他模块应以大写字母开头并使用大小写混合，但由于原始文件系统将模块名称表示为必须容纳几个稀疏字节的文件的限制，因此可能没有下划线。</target>
        </trans-unit>
        <trans-unit id="017a94912f4272ea63da9e237abc82a6ecd1cbbc" translate="yes" xml:space="preserve">
          <source>Package namespace of currently executing code.</source>
          <target state="translated">当前正在执行的代码的包名空间。</target>
        </trans-unit>
        <trans-unit id="b77eb8988a1d4f067854db5e1f2b1a7c6ddf5108" translate="yes" xml:space="preserve">
          <source>Package the module using &quot;make dist&quot;</source>
          <target state="translated">使用 &quot;make dist &quot;打包模块</target>
        </trans-unit>
        <trans-unit id="dadc452bc83dd321cf9ff63134d60199b40bf1bd" translate="yes" xml:space="preserve">
          <source>Package-specific Attribute Handling</source>
          <target state="translated">特定包的属性处理</target>
        </trans-unit>
        <trans-unit id="1b6b83de2c1ebd183fc9268fc7fc44ce0413fd67" translate="yes" xml:space="preserve">
          <source>Package/Module names are an exception to this rule. Perl informally reserves lowercase module names for 'pragma' modules like integer and strict. Other modules normally begin with a capital letter and use mixed case with no underscores (need to be short and portable).</source>
          <target state="translated">包/模块名是这一规则的例外。Perl非正式地将小写的模块名保留给 &quot;pragma &quot;模块,比如integer和strict。其他模块通常以大写字母开头,并使用混合大小写,不加下划线(需要简短和可移植)。</target>
        </trans-unit>
        <trans-unit id="0a999012ffb87b3edac99adbdfc498b12831a1e2" translate="yes" xml:space="preserve">
          <source>Packages</source>
          <target state="translated">Packages</target>
        </trans-unit>
        <trans-unit id="dcec9cb396ed550d472d01c925021db01eb054ef" translate="yes" xml:space="preserve">
          <source>Packages claim that there won't be errors on calls to or from packages explicitly marked as safe by inclusion in &lt;code&gt;@CARP_NOT&lt;/code&gt; , or (if that array is empty) &lt;code&gt;@ISA&lt;/code&gt; . The ability to override what @ISA says is new in 5.8.</source>
          <target state="translated">程序包声称，通过包含在 &lt;code&gt;@CARP_NOT&lt;/code&gt; 或 &lt;code&gt;@ISA&lt;/code&gt; （如果该数组为空）中来显式标记为安全的程序包的调用或从该程序调用时不会出错。覆盖@ISA所说的功能是5.8中的新增功能。</target>
        </trans-unit>
        <trans-unit id="ecc8e8a892ee953e2d150356ce7f795f7e40a13f" translate="yes" xml:space="preserve">
          <source>Packages may themselves contain package separators, as in &lt;code&gt;$OUTER::INNER::var&lt;/code&gt; . This implies nothing about the order of name lookups, however. There are no relative packages: all symbols are either local to the current package, or must be fully qualified from the outer package name down. For instance, there is nowhere within package &lt;code&gt;OUTER&lt;/code&gt; that &lt;code&gt;$INNER::var&lt;/code&gt; refers to &lt;code&gt;$OUTER::INNER::var&lt;/code&gt; . &lt;code&gt;INNER&lt;/code&gt; refers to a totally separate global package.</source>
          <target state="translated">包本身可能包含包分隔符，如 &lt;code&gt;$OUTER::INNER::var&lt;/code&gt; 。但是，这并不意味着名称查找的顺序。没有相关的软件包：所有符号对于当前软件包都是本地的，或者必须从外部软件包名称开始完全限定。例如，包 &lt;code&gt;OUTER&lt;/code&gt; 中没有 &lt;code&gt;$INNER::var&lt;/code&gt; 指向 &lt;code&gt;$OUTER::INNER::var&lt;/code&gt; 。 &lt;code&gt;INNER&lt;/code&gt; 是指完全独立的全局程序包。</target>
        </trans-unit>
        <trans-unit id="5c700aceea5d157561b207ea0b138ca42d93986c" translate="yes" xml:space="preserve">
          <source>Packages should NOT be released with succeeding TODO tests. As soon as a TODO test starts working, it should be promoted to a normal test, and the newly working feature should be documented in the release notes or in the change log.</source>
          <target state="translated">软件包不应该和后续的TODO测试一起发布。一旦一个TODO测试开始工作,它就应该被提升为一个正常的测试,新工作的功能应该被记录在发布说明或变更日志中。</target>
        </trans-unit>
        <trans-unit id="f9b3a92a4e9c473029e482a2d030dd34f7fdde67" translate="yes" xml:space="preserve">
          <source>Packages such as the &lt;b&gt;AutoLoader&lt;/b&gt; and &lt;b&gt;SelfLoader&lt;/b&gt; that delay loading of subroutines within packages can create problems with package lexicals defined using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt;. While the &lt;b&gt;vars&lt;/b&gt; pragma cannot duplicate the effect of package lexicals (total transparency outside of the package), it can act as an acceptable substitute by pre-declaring global symbols, ensuring their availability to the later-loaded routines.</source>
          <target state="translated">诸如&lt;b&gt;AutoLoader&lt;/b&gt;和&lt;b&gt;SelfLoader&lt;/b&gt;之类的程序包会延迟程序包中子程序的加载，可能会导致使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; 定义的程序包词法出现问题。尽管&lt;b&gt;vars&lt;/b&gt; pragma不能复制包词汇的作用（包外部的总透明性），但可以通过预先声明全局符号来确保其可用于以后加载的例程，从而充当可接受的替代方法。</target>
        </trans-unit>
        <trans-unit id="3a39b68c35be609fae3db651a70893a29f102145" translate="yes" xml:space="preserve">
          <source>Packaging</source>
          <target state="translated">Packaging</target>
        </trans-unit>
        <trans-unit id="ebd1d6c956dcaa7e80ad01427e2c132c913acd56" translate="yes" xml:space="preserve">
          <source>Packing Numbers</source>
          <target state="translated">包装号</target>
        </trans-unit>
        <trans-unit id="77ff08af8cc464aced5aa97fba37b76b1a287c76" translate="yes" xml:space="preserve">
          <source>Packing Text</source>
          <target state="translated">包装文本</target>
        </trans-unit>
        <trans-unit id="1608f8af08441cd12fe9e2fbae53022489534f12" translate="yes" xml:space="preserve">
          <source>Packing and Unpacking C Structures</source>
          <target state="translated">C结构的包装和拆包</target>
        </trans-unit>
        <trans-unit id="755fc829fa6b30f5bd0dea1183fbb4e40f383943" translate="yes" xml:space="preserve">
          <source>Packing and unpacking numbers implies conversion to and from some</source>
          <target state="translated">包装和拆包的数字意味着转换为和从某种程度上转换。</target>
        </trans-unit>
        <trans-unit id="c9cf82b43fad60a42156fab44e3aea80e40a265e" translate="yes" xml:space="preserve">
          <source>Pad Data Structures</source>
          <target state="translated">垫数据结构</target>
        </trans-unit>
        <trans-unit id="a949a19a50821443871b3357ef792d3486159a28" translate="yes" xml:space="preserve">
          <source>Padre is cross-platform IDE for Perl written in Perl using wxWidgets to provide a native look and feel. It's open source under the Artistic License. It is one of the newer Perl IDEs.</source>
          <target state="translated">Padre是一个跨平台的Perl IDE,使用wxWidgets用Perl编写,提供本地的外观和感觉。它是Artistic License下的开源软件。它是较新的Perl IDE之一。</target>
        </trans-unit>
        <trans-unit id="e71eceb99b088c6966163f1c30b69039a2bc1008" translate="yes" xml:space="preserve">
          <source>Pairs of arguments will always be preserved in a single command, this is a heuristic for things like pm_to_blib and pod2man which work on pairs of arguments. This makes things like this safe:</source>
          <target state="translated">参数对总是会被保存在一个命令中,这是对pm_to_blib和pod2man这样工作在参数对上的东西的一种启发。这使得这样的事情变得安全。</target>
        </trans-unit>
        <trans-unit id="6a74d0b33c52deb33630c75d846ae47130145559" translate="yes" xml:space="preserve">
          <source>Paragraph mode?</source>
          <target state="translated">段位模式?</target>
        </trans-unit>
        <trans-unit id="8968f4cd8542e8f5dcc7b6c003f463e1278703a3" translate="yes" xml:space="preserve">
          <source>Parallel tests</source>
          <target state="translated">并行测试</target>
        </trans-unit>
        <trans-unit id="c5a55bab9e3352eacabd04b4af1ceaafddafe1be" translate="yes" xml:space="preserve">
          <source>Parameters are passed to the Perl subroutine using the Perl stack. This is the purpose of the code beginning with the line &lt;code&gt;dSP&lt;/code&gt; and ending with the line &lt;code&gt;PUTBACK&lt;/code&gt; . The &lt;code&gt;dSP&lt;/code&gt; declares a local copy of the stack pointer. This local copy should &lt;b&gt;always&lt;/b&gt; be accessed as &lt;code&gt;SP&lt;/code&gt; .</source>
          <target state="translated">使用Perl堆栈将参数传递给Perl子例程。这就是代码的目的，从 &lt;code&gt;dSP&lt;/code&gt; 行开始，到PUTBACK行 &lt;code&gt;PUTBACK&lt;/code&gt; 。该 &lt;code&gt;dSP&lt;/code&gt; 声明堆栈指针的本地副本。此本地副本应&lt;b&gt;始终&lt;/b&gt;以 &lt;code&gt;SP&lt;/code&gt; 访问。</target>
        </trans-unit>
        <trans-unit id="80783f8285e6c8c2e9ad9134ffee91ec59453e8c" translate="yes" xml:space="preserve">
          <source>Parameters for the './Build install' command? Typical frequently used setting:</source>
          <target state="translated">'./Build install'命令的参数?典型的常用设置。</target>
        </trans-unit>
        <trans-unit id="1d97e41da27293ace4ed2fbd57ab78ff1ca66f70" translate="yes" xml:space="preserve">
          <source>Parameters for the './Build' command? Setting might be:</source>
          <target state="translated">'./Build'命令的参数?设置可能是:</target>
        </trans-unit>
        <trans-unit id="f5e610dc6ea79e1fa2fc73a9c4a9f25754369b4d" translate="yes" xml:space="preserve">
          <source>Parameters for the 'make install' command? Typical frequently used setting:</source>
          <target state="translated">'make install'命令的参数?典型的常用设置。</target>
        </trans-unit>
        <trans-unit id="ac5f82546938b3fb52bd2ca5918d7cd917da5ad3" translate="yes" xml:space="preserve">
          <source>Parameters for the 'make' command? Typical frequently used setting:</source>
          <target state="translated">'make'命令的参数?典型的常用设置。</target>
        </trans-unit>
        <trans-unit id="2daf65e57908f6e4e34be353735de186e29fbed1" translate="yes" xml:space="preserve">
          <source>Parameters for the 'perl Build.PL' command?</source>
          <target state="translated">'perl Build.PL'命令的参数?</target>
        </trans-unit>
        <trans-unit id="f2122e9ae0f9d0d393a429df01b5fba0a3936055" translate="yes" xml:space="preserve">
          <source>Parameters for the 'perl Makefile.PL' command?</source>
          <target state="translated">'perl Makefile.PL'命令的参数?</target>
        </trans-unit>
        <trans-unit id="12a675963c2d259ddd1261e2417e886a181a761a" translate="yes" xml:space="preserve">
          <source>Parameters preceded by &lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt;</source>
          <target state="translated">以 &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; 开头的参数</target>
        </trans-unit>
        <trans-unit id="b0232bb8a39fafc143ca61d9de251f7dcdc27d0d" translate="yes" xml:space="preserve">
          <source>Parameters preceded by &lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; keywords are considered to be used by the C subroutine</source>
          <target state="translated">通过前面参数 &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; 关键字被认为由C子程序可以使用</target>
        </trans-unit>
        <trans-unit id="41ae2823f661f6ddef5e94291c2f12cd43c213a8" translate="yes" xml:space="preserve">
          <source>Parameters preceded by &lt;code&gt;OUTLIST&lt;/code&gt; keyword do not appear in the usage signature of the generated Perl function.</source>
          <target state="translated">以 &lt;code&gt;OUTLIST&lt;/code&gt; 关键字开头的参数不会出现在所生成的Perl函数的用法签名中。</target>
        </trans-unit>
        <trans-unit id="44ce2ab75a2d568796b9a81ad9fe53a999fb4475" translate="yes" xml:space="preserve">
          <source>Parameters with C pointer types can have different semantic: C functions with similar declarations</source>
          <target state="translated">C指针类型的参数可以有不同的语义。C函数有类似的声明</target>
        </trans-unit>
        <trans-unit id="381c775599d6e4185d4410725809e360928357cd" translate="yes" xml:space="preserve">
          <source>Parameters:</source>
          <target state="translated">Parameters:</target>
        </trans-unit>
        <trans-unit id="626558c7945f5a0bd6dde776e79591456600acd2" translate="yes" xml:space="preserve">
          <source>Params::Check</source>
          <target state="translated">Params::Check</target>
        </trans-unit>
        <trans-unit id="3c31e71b866e2be1b160d9df7e242f80a1e4ff7c" translate="yes" xml:space="preserve">
          <source>Params::Check - A generic input parsing/checking mechanism.</source>
          <target state="translated">Params::Check-一个通用的输入解析/检查机制。</target>
        </trans-unit>
        <trans-unit id="8e747ae27947e13afe9efbf29825a7aff5681ea5" translate="yes" xml:space="preserve">
          <source>Params::Check can do the following things for you:</source>
          <target state="translated">Params::Check可以为你做以下事情。</target>
        </trans-unit>
        <trans-unit id="d2c3a97d4f65d97cc22a071d5d73380ed7818098" translate="yes" xml:space="preserve">
          <source>Params::Check is a generic input parsing/checking mechanism.</source>
          <target state="translated">Params::Check是一个通用的输入解析/检查机制。</target>
        </trans-unit>
        <trans-unit id="0fcb11d8c3d4312636cc39b23c2f21a9a26545a6" translate="yes" xml:space="preserve">
          <source>Parrot</source>
          <target state="translated">Parrot</target>
        </trans-unit>
        <trans-unit id="f3350f0a17047f5a3aa07948204b506a6f7b873f" translate="yes" xml:space="preserve">
          <source>Parrot now uses C3</source>
          <target state="translated">鹦鹉现在使用C3</target>
        </trans-unit>
        <trans-unit id="39fea3034dad6653f4f66f72da190aee39c9d313" translate="yes" xml:space="preserve">
          <source>Parse &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; output</source>
          <target state="translated">解析&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt;输出</target>
        </trans-unit>
        <trans-unit id="864de3b696d3e06b04ffd3f5a91d959dcce58e7a" translate="yes" xml:space="preserve">
          <source>Parse Call Graph and a Grammar</source>
          <target state="translated">解析调用图和语法</target>
        </trans-unit>
        <trans-unit id="9712b394a0364a991bc67a7d52542c55240f7409" translate="yes" xml:space="preserve">
          <source>Parse META.yml and META.json CPAN metadata files</source>
          <target state="translated">解析META.yml和META.json CPAN元数据文件。</target>
        </trans-unit>
        <trans-unit id="00d969b75c5246184c1f10c93d4e0b0704ad883c" translate="yes" xml:space="preserve">
          <source>Parse Pod into a simple parse tree</source>
          <target state="translated">把Pod解析成一棵简单的解析树</target>
        </trans-unit>
        <trans-unit id="ce3404387b94afbebba7dec68b6b2b2a625f85c8" translate="yes" xml:space="preserve">
          <source>Parse a $file and return what $VERSION is set to by the first assignment. It will return the string &quot;undef&quot; if it can't figure out what $VERSION is. $VERSION should be for all to see, so &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt; $VERSION&lt;/code&gt; or plain $VERSION are okay, but &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt; $VERSION&lt;/code&gt; is not.</source>
          <target state="translated">解析$ file并返回第一个赋值设置的$ VERSION。如果无法确定$ VERSION是什么，它将返回字符串&amp;ldquo; undef&amp;rdquo;。$ VERSION应该是所有人都可以看到的，因此 &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt; $VERSION&lt;/code&gt; 或普通的$ VERSION都可以，但是 &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt; $VERSION&lt;/code&gt; 则不是。</target>
        </trans-unit>
        <trans-unit id="ad88342fff52b537c53c546c60e5e4da39c0d95b" translate="yes" xml:space="preserve">
          <source>Parse a Perl arithmetic expression. This may contain operators of precedence down to the bit shift operators. The expression must be followed (and thus terminated) either by a comparison or lower-precedence operator or by something that would normally terminate an expression such as semicolon. If</source>
          <target state="translated">解析一个 Perl 算术表达式。这个表达式可以包含优先运算符,直到位移运算符。表达式后面必须跟一个比较运算符或低位运算符,或者跟一个通常会终止表达式的东西,比如分号。如果</target>
        </trans-unit>
        <trans-unit id="d13919626420ad4ba57c7f1e236f7e3f81a7aa3e" translate="yes" xml:space="preserve">
          <source>Parse a Perl list expression. This may contain operators of precedence down to the comma operator. The expression must be followed (and thus terminated) either by a low-precedence logic operator such as &lt;code&gt;or&lt;/code&gt; or by something that would normally terminate an expression such as semicolon. If</source>
          <target state="translated">解析一个Perl列表表达式。这可能包含优先级低至逗号运算符的运算符。表达式必须跟在（或因此而终止）低优先级逻辑运算符（例如 &lt;code&gt;or&lt;/code&gt; 或通常会终止表达式的内容（例如分号）。如果</target>
        </trans-unit>
        <trans-unit id="73a31decc1f7a5c619a6729c16f491108de487bb" translate="yes" xml:space="preserve">
          <source>Parse a Perl term expression. This may contain operators of precedence down to the assignment operators. The expression must be followed (and thus terminated) either by a comma or lower-precedence operator or by something that would normally terminate an expression such as semicolon. If</source>
          <target state="translated">解析一个Perl术语表达式。它可以包含从优先级到赋值运算符的运算符。表达式后面必须跟一个逗号或低位运算符,或者跟一个通常会终止表达式的东西,比如分号。逗号</target>
        </trans-unit>
        <trans-unit id="03fd37a1b5d20bde462eaebffb2d4fbe34e1d46e" translate="yes" xml:space="preserve">
          <source>Parse a sequence of zero or more Perl statements. These may be normal imperative statements, including optional labels, or declarations that have compile-time effect, or any mixture thereof. The statement sequence ends when a closing brace or end-of-file is encountered in a place where a new statement could have validly started. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed and the lexical context for the statements.</source>
          <target state="translated">解析零个或多个Perl语句的序列。这些可能是常规的命令性语句，包括可选标签，具有编译时效果的声明或它们的任意组合。当在可能已经有效启动新语句的位置遇到右括号或文件结尾时，语句序列结束。调用者应确保正确设置动态解析器​​状态（&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt;等），以反映要解析的代码的源和语句的词法上下文。</target>
        </trans-unit>
        <trans-unit id="ce089482d2db81fc038bc61d37035494dbd4a5e7" translate="yes" xml:space="preserve">
          <source>Parse a single complete Perl code block. This consists of an opening brace, a sequence of statements, and a closing brace. The block constitutes a lexical scope, so &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables and various compile-time effects can be contained within it. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed and the lexical context for the statement.</source>
          <target state="translated">解析单个完整的Perl代码块。它由一个大括号，一系列语句和一个大括号组成。该块构成一个词法范围，因此可以在其中包含 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 变量和各种编译时效果。调用者应确保正确设置动态解析器​​状态（&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt;等），以反映要解析的代码的源以及该语句的词法上下文。</target>
        </trans-unit>
        <trans-unit id="9eba5130051b754a15b7c0146935178b7a793c12" translate="yes" xml:space="preserve">
          <source>Parse a single complete Perl expression. This allows the full expression grammar, including the lowest-precedence operators such as &lt;code&gt;or&lt;/code&gt; . The expression must be followed (and thus terminated) by a token that an expression would normally be terminated by: end-of-file, closing bracketing punctuation, semicolon, or one of the keywords that signals a postfix expression-statement modifier. If</source>
          <target state="translated">解析单个完整的Perl表达式。这允许完整的表达式语法，包括最低优先级的运算符，例如 &lt;code&gt;or&lt;/code&gt; 。表达式必须紧跟（并因此而终止）标记，该标记通常会以以下方式终止该表达式：文件结尾，右括号，标点，分号或表示后缀表达式声明修饰符的关键字之一。如果</target>
        </trans-unit>
        <trans-unit id="58f6019da7384a5fca463ab30964f465a7e74317" translate="yes" xml:space="preserve">
          <source>Parse a single complete Perl statement. This may be a normal imperative statement or a declaration that has compile-time effect, and may include optional labels. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed and the lexical context for the statement.</source>
          <target state="translated">解析单个完整的Perl语句。这可以是普通的命令式语句，也可以是具有编译时效果的声明，并且可以包括可选标签。调用者应确保正确设置动态解析器​​状态（&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt;等），以反映要解析的代码的源以及该语句的词法上下文。</target>
        </trans-unit>
        <trans-unit id="47cabbfacc2ecefb926eabaa7917ccc6eda5e749" translate="yes" xml:space="preserve">
          <source>Parse a single label, possibly optional, of the type that may prefix a Perl statement. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed. If</source>
          <target state="translated">解析单个标签（可能是可选的），该标签可以为Perl语句添加前缀。调用者应确保正确设置动态解析器​​状态（&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt;等）以反映要解析的代码的来源。如果</target>
        </trans-unit>
        <trans-unit id="2760bb775d2f5ac01c987fbbfc94d63c9c899e62" translate="yes" xml:space="preserve">
          <source>Parse a single unadorned Perl statement. This may be a normal imperative statement or a declaration that has compile-time effect. It does not include any label or other affixture. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed and the lexical context for the statement.</source>
          <target state="translated">解析一个简单的Perl语句。这可能是普通的命令式语句，也可能是具有编译时效果的声明。它不包含任何标签或其他附件。调用者应确保正确设置动态解析器​​状态（&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt;等），以反映要解析的代码的源以及该语句的词法上下文。</target>
        </trans-unit>
        <trans-unit id="7c6f184ce547c8aba43670b279e40b0257db5871" translate="yes" xml:space="preserve">
          <source>Parse an L&amp;lt;&amp;gt; formatting code in POD text</source>
          <target state="translated">解析POD文本中的L &amp;lt;&amp;gt;格式代码</target>
        </trans-unit>
        <trans-unit id="e36fba2ce293e9dd2d7ccd39cdd6da710089a942" translate="yes" xml:space="preserve">
          <source>Parse and process a file with pod in it:</source>
          <target state="translated">解析和处理带有pod的文件。</target>
        </trans-unit>
        <trans-unit id="95c795a721b662a23c96150509b7defee01aa093" translate="yes" xml:space="preserve">
          <source>Parse file paths into directory, filename and suffix.</source>
          <target state="translated">将文件路径解析为目录、文件名和后缀。</target>
        </trans-unit>
        <trans-unit id="7ef71ab4754324a2f907d13e0118b212e436f9d9" translate="yes" xml:space="preserve">
          <source>Parse text into an array of tokens or array of arrays</source>
          <target state="translated">将文本解析为一个标记数组或数组数组。</target>
        </trans-unit>
        <trans-unit id="8f66dc0790859dd1eeb3a917210e58e38ca209e0" translate="yes" xml:space="preserve">
          <source>Parse::CPAN::Meta</source>
          <target state="translated">Parse::CPAN::Meta</target>
        </trans-unit>
        <trans-unit id="14f134b3af22420beae12cee1984569fcb79b734" translate="yes" xml:space="preserve">
          <source>Parse::CPAN::Meta - Parse META.yml and META.json CPAN metadata files</source>
          <target state="translated">Parse::CPAN::Meta-解析META.yml和META.json CPAN元数据文件。</target>
        </trans-unit>
        <trans-unit id="fe64ba8660ae82053a168a558e1390828e9d75c0" translate="yes" xml:space="preserve">
          <source>Parse::RecDescent uses &lt;code&gt;extract_codeblock($text, '{}&amp;lt;&amp;gt;')&lt;/code&gt; to extract the code within the &lt;code&gt;&amp;lt;defer:...&amp;gt;&lt;/code&gt; directive, but there's a problem.</source>
          <target state="translated">Parse :: RecDescent使用 &lt;code&gt;extract_codeblock($text, '{}&amp;lt;&amp;gt;')&lt;/code&gt; 提取 &lt;code&gt;&amp;lt;defer:...&amp;gt;&lt;/code&gt; 指令中的代码，但是存在问题。</target>
        </trans-unit>
        <trans-unit id="418d1a5bd76755f2c0308bd1eebe8bb8f1bdc41d" translate="yes" xml:space="preserve">
          <source>Parser Components</source>
          <target state="translated">解析器组件</target>
        </trans-unit>
        <trans-unit id="fe2f07bac5eb2fe04d3c37f8f55ba8daadac0f8d" translate="yes" xml:space="preserve">
          <source>Parses a string containing a valid YAML stream into a list of Perl data structures.</source>
          <target state="translated">将一个包含有效YAML流的字符串解析成一个Perl数据结构的列表。</target>
        </trans-unit>
        <trans-unit id="581e381893d5cec0eef75cd617fe11072fd60c0d" translate="yes" xml:space="preserve">
          <source>Parses from &lt;code&gt;$source&lt;/code&gt; file to &lt;code&gt;$to&lt;/code&gt; file. Similar to &lt;a href=&quot;parser#parse_from_file&quot;&gt;parse_from_file in Pod::Parser&lt;/a&gt;.</source>
          <target state="translated">从 &lt;code&gt;$source&lt;/code&gt; 文件解析到 &lt;code&gt;$to&lt;/code&gt; 文件。类似于&lt;a href=&quot;parser#parse_from_file&quot;&gt;Pod :: Parser中的parse_from_file&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="092f1e46c6bd81566c97fcc512b18db5d5c4aab0" translate="yes" xml:space="preserve">
          <source>Parses the uri and creates a corresponding File::Fetch::Item object, that is ready to be &lt;code&gt;fetch&lt;/code&gt; ed and returns it.</source>
          <target state="translated">解析uri并创建一个对应的File :: Fetch :: Item对象，该对象准备好被 &lt;code&gt;fetch&lt;/code&gt; 并返回。</target>
        </trans-unit>
        <trans-unit id="7294d33710169103141018bfcb0ee5ad3daa81e2" translate="yes" xml:space="preserve">
          <source>Parsing</source>
          <target state="translated">Parsing</target>
        </trans-unit>
        <trans-unit id="201a7c8f517e70abce0e1a757b9f06ab6e1eaa4c" translate="yes" xml:space="preserve">
          <source>Parsing complications</source>
          <target state="translated">解析并发症</target>
        </trans-unit>
        <trans-unit id="56105dfe20714874a2e829f3d18d1b5e096635b7" translate="yes" xml:space="preserve">
          <source>Parsing for construction</source>
          <target state="translated">结构解析</target>
        </trans-unit>
        <trans-unit id="60d12b966804dcb52fae0aab613b1970bacceb22" translate="yes" xml:space="preserve">
          <source>Parsing for size</source>
          <target state="translated">尺寸解析</target>
        </trans-unit>
        <trans-unit id="80341dac319c1b5410ead916b5a70b09b9ef0f4d" translate="yes" xml:space="preserve">
          <source>Parsing harness related environmental variables where appropriate</source>
          <target state="translated">酌情解析与驾驭相关的环境变量。</target>
        </trans-unit>
        <trans-unit id="f5b02e670994bc090c4464c23b48f3c45762f6da" translate="yes" xml:space="preserve">
          <source>Parsing is implemented per &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;. For backward compatibility, links where there is no section and name contains spaces, or links where the entirety of the link (except for the anchor text if given) is enclosed in double-quotes are interpreted as links to a section (L&amp;lt;/section&amp;gt;).</source>
          <target state="translated">解析是根据&lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;实现的。为了向后兼容，没有节且名称不包含空格的链接，或将链接的整个部分（如果有锚文本，则用双引号引起来）的链接都解释为到节（L &amp;lt;/ section）的链接。 &amp;gt;）。</target>
        </trans-unit>
        <trans-unit id="21fec48dc32ed2c2c516a7d00eccd1fc2dbbf7ca" translate="yes" xml:space="preserve">
          <source>Parsing of the &lt;code&gt;#!&lt;/code&gt; switches starts wherever &quot;perl&quot; is mentioned in the line. The sequences &quot;-*&quot; and &quot;- &quot; are specifically ignored so that you could, if you were so inclined, say</source>
          <target state="translated">解析 &lt;code&gt;#!&lt;/code&gt; 只要在行中提到&amp;ldquo; perl&amp;rdquo;，开关就会启动。序列&amp;ldquo;-*&amp;rdquo;和&amp;ldquo;-&amp;rdquo;被特别忽略，因此，如果您愿意，可以说</target>
        </trans-unit>
        <trans-unit id="f4a66fb666677831fbb89c4617c9cb55023dbd3e" translate="yes" xml:space="preserve">
          <source>Parsing of the bracketed character class construct, &lt;code&gt;[...]&lt;/code&gt; , is rather different than the rule used for the rest of the pattern. The terminator of this construct is found using the same rules as for finding the terminator of a &lt;code&gt;{}&lt;/code&gt; -delimited construct, the only exception being that &lt;code&gt;]&lt;/code&gt; immediately following &lt;code&gt;[&lt;/code&gt; is treated as though preceded by a backslash.</source>
          <target state="translated">括号中的字符类构造 &lt;code&gt;[...]&lt;/code&gt; 的解析与模式其余部分所用的规则完全不同。使用与查找 &lt;code&gt;{}&lt;/code&gt; 分隔的构造器的终止符相同的规则来找到该构造的终止符，唯一的例外是紧随 &lt;code&gt;[&lt;/code&gt; 之后的 &lt;code&gt;]&lt;/code&gt; 被当作​​反斜杠开头。</target>
        </trans-unit>
        <trans-unit id="73445354eb44bc4201e65870d8cf75c662a12338" translate="yes" xml:space="preserve">
          <source>Parsing options from an arbitrary array</source>
          <target state="translated">从一个任意数组中解析选项</target>
        </trans-unit>
        <trans-unit id="7c23dc7bccdc54b6af40c30891098a1ec3018d31" translate="yes" xml:space="preserve">
          <source>Parsing options from an arbitrary string</source>
          <target state="translated">从一个任意字符串中解析选项</target>
        </trans-unit>
        <trans-unit id="fae1cc5f61c39d7ca25192b6ad11336a46da6cc3" translate="yes" xml:space="preserve">
          <source>Part 1: The basics</source>
          <target state="translated">第1部分:基础知识</target>
        </trans-unit>
        <trans-unit id="0ef5ae5e92fc124e5a59c33d1478fa00e49ca98c" translate="yes" xml:space="preserve">
          <source>Part 2: Power tools</source>
          <target state="translated">第2部分:电动工具</target>
        </trans-unit>
        <trans-unit id="67d014ca4761f29f2d21414f531603a8e6bec46f" translate="yes" xml:space="preserve">
          <source>Pass an undef value to disable it:</source>
          <target state="translated">传递一个undef值来禁用它。</target>
        </trans-unit>
        <trans-unit id="6c2219e935754aed07fd99bb89a0b43879d2aa88" translate="yes" xml:space="preserve">
          <source>Pass arrays and hashes by reference, not by value. For one thing, it's the only way to pass multiple lists or hashes (or both) in a single call/return. It also avoids creating a copy of all the contents. This requires some judgement, however, because any changes will be propagated back to the original data. If you really want to mangle (er, modify) a copy, you'll have to sacrifice the memory needed to make one.</source>
          <target state="translated">通过引用而不是通过值来传递数组和哈希。首先,这是唯一能在一次调用/返回中传递多个列表或哈希值(或两者)的方法。这也避免了创建一个所有内容的副本。然而,这需要一些判断,因为任何变化都会传播回原始数据。如果你真的想搞乱(呃,修改)一个副本,你将不得不牺牲制作副本所需的内存。</target>
        </trans-unit>
        <trans-unit id="0faa9975944d7d7c5896c953cdfdaa9399cd924e" translate="yes" xml:space="preserve">
          <source>Pass arrays as references so more parameters can be added later (it's also faster). Convert functions into methods where appropriate. Split large methods into smaller more flexible ones. Inherit methods from other modules if appropriate.</source>
          <target state="translated">将数组作为引用传递,这样以后就可以添加更多的参数(这样也更快)。在适当的地方将函数转换为方法。将大型方法分割成更小更灵活的方法。如果合适的话,从其他模块继承方法。</target>
        </trans-unit>
        <trans-unit id="7d95906c33f61c39cf91fb90166084e4d01776d3" translate="yes" xml:space="preserve">
          <source>Pass by Reference</source>
          <target state="translated">递补</target>
        </trans-unit>
        <trans-unit id="053ad74d06c8d9f5eb6073c958d95571ac0cf875" translate="yes" xml:space="preserve">
          <source>Pass-through options</source>
          <target state="translated">通过选项</target>
        </trans-unit>
        <trans-unit id="b99c51ad09b3295fb732520f288da663a4c77836" translate="yes" xml:space="preserve">
          <source>Passed in implicitly via standard input. This works only if there are no filename arguments--to pass arguments to a STDIN-read program you must explicitly specify a &quot;-&quot; for the program name.</source>
          <target state="translated">通过标准输入隐式传入。只有在没有文件名参数的情况下才会起作用--如果要把参数传给一个STDIN-read程序,你必须为程序名明确地指定一个&quot;-&quot;。</target>
        </trans-unit>
        <trans-unit id="c1dfda537026966c5e1e28098e3760a352bbbd9e" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;$hash{ 'foo' }&lt;/code&gt; to a subroutine used to be a special case, though. Since you could assign directly to &lt;code&gt;$_[0]&lt;/code&gt; , Perl had to be ready to make that assignment so it created the hash key ahead of time:</source>
          <target state="translated">不过，将 &lt;code&gt;$hash{ 'foo' }&lt;/code&gt; 传递给子例程曾经是一种特殊情况。因为您可以直接分配给 &lt;code&gt;$_[0]&lt;/code&gt; ，所以Perl必须准备好进行分配，因此它提前创建了哈希键：</target>
        </trans-unit>
        <trans-unit id="5c25d01562076258933dad64551143b78c5bd332" translate="yes" xml:space="preserve">
          <source>Passing NULL for SV creates a constant sub equivalent to &lt;code&gt;sub BAR () {}&lt;/code&gt; , which won't be called if used as a destructor, but will suppress the overhead of a call to &lt;code&gt;AUTOLOAD&lt;/code&gt; . (This form, however, isn't eligible for inlining at compile time.)</source>
          <target state="translated">为SV传递NULL会创建一个等效于 &lt;code&gt;sub BAR () {}&lt;/code&gt; 的常量子，如果用作析构函数，则不会调用该子，但会抑制调用 &lt;code&gt;AUTOLOAD&lt;/code&gt; 的开销。（但是，此表格在编译时不符合内联的条件。）</target>
        </trans-unit>
        <trans-unit id="92e7a89cda780976fa2b2bf15b8fa16940c9e791" translate="yes" xml:space="preserve">
          <source>Passing Parameters</source>
          <target state="translated">传递参数</target>
        </trans-unit>
        <trans-unit id="631e829d46dd7a132eee37564669347bda1fdeb4" translate="yes" xml:space="preserve">
          <source>Passing Symbol Table Entries (typeglobs)</source>
          <target state="translated">传递符号表条目(typeglobs)</target>
        </trans-unit>
        <trans-unit id="9c282987a3e4a9c1f484c40c67cee6ec02907f83" translate="yes" xml:space="preserve">
          <source>Passing a true value for &lt;code&gt;$no_file&lt;/code&gt; indicates that the path being split only contains directory components, even on systems where you can usually (when not supporting a foreign syntax) tell the difference between directories and files at a glance.</source>
          <target state="translated">为 &lt;code&gt;$no_file&lt;/code&gt; 传递一个真值表示即使在通常可以一目了然地分辨出目录和文件之间的差异的系统上，被拆分的路径也仅包含目录组件。</target>
        </trans-unit>
        <trans-unit id="57e7c7fde542cf4bbfc2454d2a7557dc31e803b8" translate="yes" xml:space="preserve">
          <source>Passing an array reference containing only one element, 'name', is special cased to return a list of names rather than a list of hash references, making it equivalent to calling &lt;code&gt;list_files&lt;/code&gt; without arguments.</source>
          <target state="translated">传递仅包含一个元素&amp;ldquo;名称&amp;rdquo;的数组引用是特殊情况，以返回名称列表而不是哈希引用列表，这使其等效于调用不带参数的 &lt;code&gt;list_files&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33e2edde52cbb4ec756e8a81aaf676fa8eab3f52" translate="yes" xml:space="preserve">
          <source>Passing an array reference containing only one element, 'name', is special cased to return a list of names rather than a list of hash references.</source>
          <target state="translated">传递一个只包含一个元素'name'的数组引用时,会被特殊处理,以返回一个名字列表,而不是一个哈希引用的列表。</target>
        </trans-unit>
        <trans-unit id="73e454c3c193b2c18919a57428be215c94732d74" translate="yes" xml:space="preserve">
          <source>Passing an empty string &quot;&quot; as the first argument to &lt;code&gt;catdir()&lt;/code&gt; is like passing&lt;code&gt;File::Spec-&amp;gt;rootdir()&lt;/code&gt; as the first argument, i.e.</source>
          <target state="translated">将空字符串&amp;ldquo;&amp;rdquo;作为第一个参数传递给 &lt;code&gt;catdir()&lt;/code&gt; 就像将 &lt;code&gt;File::Spec-&amp;gt;rootdir()&lt;/code&gt; 作为第一个参数传递一样，即</target>
        </trans-unit>
        <trans-unit id="d6de5b84e84c7ec759c47090ea234e479eb3f3b2" translate="yes" xml:space="preserve">
          <source>Passing array/hash refs that contain objects may not work for Perl prior to 5.10.0.</source>
          <target state="translated">传递包含对象的数组/散列引用,在5.10.0之前的Perl中可能无法使用。</target>
        </trans-unit>
        <trans-unit id="778d28f8a8c46b422aec9c2654919755f059cdd6" translate="yes" xml:space="preserve">
          <source>Passing new options to the $walker is the easiest way to change amongst any pre-defined styles (the ones you add are automatically recognized as options), and is the only way to alter rendering order without calling compile again. Note however that rendering state is still shared amongst multiple $walker objects, so they must still be used in a coordinated manner.</source>
          <target state="translated">向$walker传递新的选项是改变任何预定义样式的最简单的方法(你添加的样式会被自动识别为选项),也是改变渲染顺序而无需再次调用编译的唯一方法。但是请注意,渲染状态仍然是在多个$walker对象之间共享的,所以它们仍然必须以协调的方式使用。</target>
        </trans-unit>
        <trans-unit id="000338825dc1ad597f0654c697650b0c505e9d75" translate="yes" xml:space="preserve">
          <source>Passing objects on queues may not work if the objects' classes do not support sharing. See &lt;a href=&quot;../threads/shared#BUGS-AND-LIMITATIONS&quot;&gt;BUGS AND LIMITATIONS in threads::shared&lt;/a&gt; for more.</source>
          <target state="translated">如果对象的类不支持共享，则在队列上传递对象可能不起作用。有关更多信息，请参见&lt;a href=&quot;../threads/shared#BUGS-AND-LIMITATIONS&quot;&gt;thread :: shared中的错误和限制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b55ad2737b0f246adb41a25f43c9856e1465d7d3" translate="yes" xml:space="preserve">
          <source>Passing only one of the first two elements as &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is equivalent to passing a 0 and will not have the effect described when both are &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. This also triggers an uninitialized warning.</source>
          <target state="translated">仅将前两个元素之一传递为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 等效于传递0，并且当两个均为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 时将不会具有所描述的效果。这也会触发未初始化的警告。</target>
        </trans-unit>
        <trans-unit id="816c2ea902ef30f358f592af797150423983b160" translate="yes" xml:space="preserve">
          <source>Passing only one of the first two elements as &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is equivalent to passing a 0 and will not have the effect described when both are &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. This also triggers an uninitialized warning.</source>
          <target state="translated">仅将前两个元素之一传递为 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 等效于传递0，并且当两个均为 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 时将不会具有所描述的效果。这也会触发未初始化的警告。</target>
        </trans-unit>
        <trans-unit id="ff65b3fe44892512aa53628ad3cbe12f9d7ca3ec" translate="yes" xml:space="preserve">
          <source>Passing the tied object to &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将绑定的对象传递给 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85ec73bc8762feb2e3028dbf252686e023bd6e19" translate="yes" xml:space="preserve">
          <source>Past contributions from: brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; , Sean M. Burke &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt;</source>
          <target state="translated">过去的贡献来自：brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; ，Sean M. Burke &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c5e8c22064e37b00fe594c59a2558cd9b22cdd1" translate="yes" xml:space="preserve">
          <source>Past contributions from: brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; ; Sean M. Burke &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt; ; significant portions copied from</source>
          <target state="translated">过去的贡献来自：brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; ；肖恩&amp;middot;M&amp;middot;伯克 &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt; ; 从复制的重要部分</target>
        </trans-unit>
        <trans-unit id="b20a451c29c9cea2e46c19630395de2df6f76e08" translate="yes" xml:space="preserve">
          <source>Past contributors are: brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; , Sean M. Burke &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt; , Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafcol.lafayette.edu&amp;gt;&lt;/code&gt; , and many others.</source>
          <target state="translated">过去的贡献者是：brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; ，Sean M. Burke &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt; ，Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; ，Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafcol.lafayette.edu&amp;gt;&lt;/code&gt; ，还有许多其他内容。</target>
        </trans-unit>
        <trans-unit id="5b790410ca6021f643b25dc0684b80c6ac035a6f" translate="yes" xml:space="preserve">
          <source>Patch style</source>
          <target state="translated">补丁式</target>
        </trans-unit>
        <trans-unit id="e616d246e566a6e437d4992af55f91c42a43620c" translate="yes" xml:space="preserve">
          <source>Patch, extend or subclass an existing module where possible</source>
          <target state="translated">在可能的情况下,对现有模块进行修补、扩展或子类化。</target>
        </trans-unit>
        <trans-unit id="57bddba1c66e0b8fdc9d892c78bfc22f25c546f6" translate="yes" xml:space="preserve">
          <source>Patches against Pod::Simple are welcome. Please send bug reports to &amp;lt;bug-pod-simple@rt.cpan.org&amp;gt;.</source>
          <target state="translated">欢迎使用针对Pod :: Simple的补丁。请将错误报告发送至&amp;lt;bug-pod-simple@rt.cpan.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="139936b1a9a84a97721c26af3e777c3a03af1e6f" translate="yes" xml:space="preserve">
          <source>Patches are reviewed and discussed on the p5p list. Simple, uncontroversial patches will usually be applied without any discussion. When the patch is applied, the ticket will be updated and you will receive email. In addition, an email will be sent to the p5p list.</source>
          <target state="translated">补丁会在 p5p 列表中进行审查和讨论。简单的、没有争议的补丁通常会在没有任何讨论的情况下被应用。当补丁被应用时,票据会被更新,您会收到电子邮件。此外,一封电子邮件将被发送到p5p列表。</target>
        </trans-unit>
        <trans-unit id="f960f4eadeba1dd57f417d470c8e32c7459acc42" translate="yes" xml:space="preserve">
          <source>Patches may be applied by the pumpkin holder without the explicit cooperation of the module author if and only if they are very minor, time-critical in some fashion (such as urgent security fixes), or if the module author cannot be reached. Those patches must still be given back to the author when possible, and if the author decides on an alternate fix in their version, that fix should be strongly preferred unless there is a serious problem with it. Any changes not endorsed by the author should be marked as such, and the contributor of the change acknowledged.</source>
          <target state="translated">南瓜的持有者可以在没有得到模块作者明确合作的情况下打补丁,如果而且只有当这些补丁非常小,在某种程度上是时间紧迫的(比如紧急的安全修复),或者如果模块作者无法联系到。如果作者决定在他们的版本中使用另一个补丁,除非有严重的问题,否则应该优先考虑这个补丁。任何未经作者认可的修改都应该标明,并注明修改者。</target>
        </trans-unit>
        <trans-unit id="bb89b691c1294b8ada4f9cd31a429e4caf872c3f" translate="yes" xml:space="preserve">
          <source>Patches speak louder than words</source>
          <target state="translated">补丁比语言更有说服力</target>
        </trans-unit>
        <trans-unit id="d54931049c09c712e0cbea3d090e4d3b4a105c0b" translate="yes" xml:space="preserve">
          <source>Patches that add new warnings or errors or deprecate features.</source>
          <target state="translated">增加新的警告、错误或废弃功能的补丁。</target>
        </trans-unit>
        <trans-unit id="29abf1c3bbb8c54b1cd55ff655f670f9ebc399ee" translate="yes" xml:space="preserve">
          <source>Patches that add or remove features.</source>
          <target state="translated">增加或删除功能的补丁。</target>
        </trans-unit>
        <trans-unit id="f84461a4c1a5b5e429209771f4e83af6717ee46b" translate="yes" xml:space="preserve">
          <source>Patches that break binary compatibility. (Please talk to a pumpking.)</source>
          <target state="translated">破坏二进制兼容性的补丁。(请和南瓜谈)</target>
        </trans-unit>
        <trans-unit id="323fd112f38ff019a7ad9800eabd680b9a815934" translate="yes" xml:space="preserve">
          <source>Patches that fix CVEs or security issues. These changes should be run through the perl5-security-report@perl.org mailing list rather than applied directly.</source>
          <target state="translated">修正CVEs或安全问题的补丁。这些更改应通过 perl5-security-report@perl.org 邮件列表运行,而不是直接应用。</target>
        </trans-unit>
        <trans-unit id="f0910db599c5e57f13f342f2401ca7baceb18c00" translate="yes" xml:space="preserve">
          <source>Patches that fix anything which prevents or seriously impacts the build or installation of perl.</source>
          <target state="translated">修正任何阻碍或严重影响 perl 的构建或安装的补丁。</target>
        </trans-unit>
        <trans-unit id="21130596c95c32860a5fe99dde40cbc8202f1859" translate="yes" xml:space="preserve">
          <source>Patches that fix crashing bugs, assertion failures and memory corruption but which do not otherwise change perl's functionality or negatively impact performance.</source>
          <target state="translated">这些补丁修复了崩溃bug、断言失败和内存损坏,但没有改变perl的功能或对性能产生负面影响。</target>
        </trans-unit>
        <trans-unit id="c95c81109a9edefb7a99fa1792240b1c8c4accc7" translate="yes" xml:space="preserve">
          <source>Patches that fix regressions in perl's behavior relative to previous releases, no matter how old the regression, since some people may upgrade from very old versions of perl to the latest version.</source>
          <target state="translated">补丁修复了相对于以前版本的 perl 行为的回归,无论回归的时间有多长,因为有些人可能会从非常老的 perl 版本升级到最新的版本。</target>
        </trans-unit>
        <trans-unit id="93c3b06e57a98513617dbda85f73638d28687b18" translate="yes" xml:space="preserve">
          <source>Patches which change behaviour (fixing bugs or introducing new features) must include regression tests to verify that everything works as expected.</source>
          <target state="translated">改变行为(修复错误或引入新功能)的补丁必须包含回归测试,以验证一切都能按预期工作。</target>
        </trans-unit>
        <trans-unit id="8270f0c679e10266c6a9f82f5a4c89d2c3cc697e" translate="yes" xml:space="preserve">
          <source>Patches without documentation are probably ill-thought out or incomplete. No features can be added or changed without documentation, so submitting a patch for the appropriate pod docs as well as the source code is important.</source>
          <target state="translated">没有文档的补丁可能是考虑不周或不完整的。在没有文档的情况下,任何功能都不可能被添加或更改,所以提交相应的 pod 文档以及源代码的补丁是很重要的。</target>
        </trans-unit>
        <trans-unit id="e27ae82b9a6b018ee112b21851652cbe49271b3b" translate="yes" xml:space="preserve">
          <source>Patching a core module</source>
          <target state="translated">给核心模块打补丁</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="0b1fe397674f2ea0ca0d83a858144940f7da6b34" translate="yes" xml:space="preserve">
          <source>Patterns are implicitly anchored at the beginning and end of each string when testing for a match.</source>
          <target state="translated">在测试匹配时,模式会隐式地锚定在每个字符串的开头和结尾。</target>
        </trans-unit>
        <trans-unit id="d223d697e7957195cfa22daa9019ad4f989b3028" translate="yes" xml:space="preserve">
          <source>Patterns are subject to an additional level of interpretation as a regular expression. This is done as a second pass, after variables are interpolated, so that regular expressions may be incorporated into the pattern from the variables. If this is not what you want, use &lt;code&gt;\Q&lt;/code&gt; to interpolate a variable literally.</source>
          <target state="translated">模式需要作为正则表达式进行额外的解释。在对变量进行插值之后，将其作为第二遍操作来完成，以便可以将正则表达式从变量中合并到模式中。如果这不是您想要的，请使用 &lt;code&gt;\Q&lt;/code&gt; 逐字插入变量。</target>
        </trans-unit>
        <trans-unit id="e23f050b63735be39db7dcbaa09bfdd36470f510" translate="yes" xml:space="preserve">
          <source>Patterns of the form /#\d/ will be replaced with the</source>
          <target state="translated">格式为/#d//的模式将被替换为/#d//的模式。</target>
        </trans-unit>
        <trans-unit id="657c59b79c5dc51478a7a404f0af13b53b988447" translate="yes" xml:space="preserve">
          <source>Paul Green (Paul.Green@stratus.com)</source>
          <target state="translated">保罗-格林(Paul.Green@stratus.com)</target>
        </trans-unit>
        <trans-unit id="7bea737592f1b2469295059802a7399af95a087a" translate="yes" xml:space="preserve">
          <source>Paul Marquess</source>
          <target state="translated">Paul Marquess</target>
        </trans-unit>
        <trans-unit id="1da5f372b188cb5eeeeafb09b1f0a31fca9b993f" translate="yes" xml:space="preserve">
          <source>Paul Marquess &amp;lt;Paul.Marquess@btinternet.com&amp;gt;</source>
          <target state="translated">保罗&amp;middot;马克斯&amp;lt;Paul.Marquess@btinternet.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4fbcf625afc3d507d379cacdea04bbc6b875a1d5" translate="yes" xml:space="preserve">
          <source>Paul Marquess &amp;lt;pmqs@cpan.org&amp;gt;</source>
          <target state="translated">保罗&amp;middot;马克斯（Paul Marquess）&amp;lt;pmqs@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c4337beb0e4af629844f1525d967a958a8d53fbd" translate="yes" xml:space="preserve">
          <source>Paul Marquess pmqs@cpan.org</source>
          <target state="translated">Paul Marquess pmqs@cpan.org</target>
        </trans-unit>
        <trans-unit id="914e119a6f7c68c285bad290780b5645e4c2e6e0" translate="yes" xml:space="preserve">
          <source>Paul Szabo identified the race condition originally, and Brendan O'Dea wrote an implementation for Debian that addressed the problem. That code was used as a basis for the current code. Their efforts are greatly appreciated.</source>
          <target state="translated">Paul Szabo 最初发现了这个竞赛条件,Brendan O'Dea 为 Debian 写了一个解决这个问题的实现。该代码被用作当前代码的基础。我们非常感谢他们的努力。</target>
        </trans-unit>
        <trans-unit id="37c56bd6f44f98356093abe0640820d8fc0e4efe" translate="yes" xml:space="preserve">
          <source>Pay a special attention to the function &lt;code&gt;constant&lt;/code&gt; . This name appears twice in the generated .xs file: once in the first part, as a static C function, then another time in the second part, when an XSUB interface to this static C function is defined.</source>
          <target state="translated">要特别注意函数 &lt;code&gt;constant&lt;/code&gt; 。此名称在生成的.xs文件中出现两次：一次在第一部分中，作为静态C函数，然后在第二部分中，另一次，当定义到此静态C函数的XSUB接口时。</target>
        </trans-unit>
        <trans-unit id="fd86f5fbb7a13e213f07f240ee7591f9616574c1" translate="yes" xml:space="preserve">
          <source>Pay careful attention to the next example:</source>
          <target state="translated">仔细注意下一个例子。</target>
        </trans-unit>
        <trans-unit id="8629c3dd5ba30eee7c4ac6064407b780f19df3f6" translate="yes" xml:space="preserve">
          <source>Pay special attention to &lt;a href=&quot;#METHODS-FOR-PARSING-AND-PROCESSING&quot;&gt;METHODS FOR PARSING AND PROCESSING&lt;/a&gt; and to the objects described in &lt;a href=&quot;inputobjects&quot;&gt;Pod::InputObjects&lt;/a&gt;. The former describes the gory details and parameters for how to customize and extend the parsing behavior of &lt;b&gt;Pod::Parser&lt;/b&gt;. &lt;b&gt;Pod::InputObjects&lt;/b&gt; provides several objects that may all be used interchangeably as parse-trees. The most obvious one is the &lt;b&gt;Pod::ParseTree&lt;/b&gt; object. It defines the basic interface and functionality that all things trying to be a POD parse-tree should do. A &lt;b&gt;Pod::ParseTree&lt;/b&gt; is defined such that each &quot;node&quot; may be a text-string, or a reference to another parse-tree. Each &lt;b&gt;Pod::Paragraph&lt;/b&gt; object and each &lt;b&gt;Pod::InteriorSequence&lt;/b&gt; object also supports the basic parse-tree interface.</source>
          <target state="translated">要特别注意&lt;a href=&quot;#METHODS-FOR-PARSING-AND-PROCESSING&quot;&gt;解析和处理方法&lt;/a&gt;以及&lt;a href=&quot;inputobjects&quot;&gt;Pod :: InputObjects中&lt;/a&gt;描述的对象。前者描述了如何定制和扩展&lt;b&gt;Pod :: Parser&lt;/b&gt;的解析行为的详细信息和参数。&lt;b&gt;Pod :: InputObjects&lt;/b&gt;提供了几个对象，可以全部用作解析树。最明显的一个是&lt;b&gt;Pod :: ParseTree&lt;/b&gt;对象。它定义了所有试图成为POD解析树的东西都应该做的基本接口和功能。甲&lt;b&gt;波德::分析树&lt;/b&gt;被定义为使得每个&amp;ldquo;节点&amp;rdquo;可以是文本串，或到另一解析树的引用。每个&lt;b&gt;Pod :: Paragraph&lt;/b&gt;对象以及每个&lt;b&gt;Pod :: InteriorSequence&lt;/b&gt;对象还支持基本的分析树接口。</target>
        </trans-unit>
        <trans-unit id="8c0ffaf5c4cb2ca5b26bd5b8ebbf764c3f361b3b" translate="yes" xml:space="preserve">
          <source>Peeking At Perl's Internal Encoding</source>
          <target state="translated">窥探Perl的内部编码方式</target>
        </trans-unit>
        <trans-unit id="9326788fe51cb580ed1b0dbf97738788d7548374" translate="yes" xml:space="preserve">
          <source>Peep-hole Optimisation and Analysis</source>
          <target state="translated">窥视孔优化和分析</target>
        </trans-unit>
        <trans-unit id="942951d0647566db32d37d28d3b5cb152d328945" translate="yes" xml:space="preserve">
          <source>Peephole optimizations are done by calling the function pointed to by the global variable &lt;code&gt;PL_peepp&lt;/code&gt; . By default, &lt;code&gt;PL_peepp&lt;/code&gt; just calls the function pointed to by the global variable &lt;code&gt;PL_rpeepp&lt;/code&gt; . By default, that performs some basic op fixups and optimisations along the execution-order op chain, and recursively calls &lt;code&gt;PL_rpeepp&lt;/code&gt; for each side chain of ops (resulting from conditionals). Extensions may provide additional optimisations or fixups, hooking into either the per-subroutine or recursive stage, like this:</source>
          <target state="translated">通过调用全局变量 &lt;code&gt;PL_peepp&lt;/code&gt; 指向的函数来完成窥孔优化。默认情况下， &lt;code&gt;PL_peepp&lt;/code&gt; 仅调用全局变量 &lt;code&gt;PL_rpeepp&lt;/code&gt; 指向的函数。默认情况下，它会沿执行顺序操作链执行一些基本的操作修正和优化，并为操作的每个侧链递归调用 &lt;code&gt;PL_rpeepp&lt;/code&gt; （由条件决定）。扩展可以提供附加的优化或修正，可以挂接到每个子例程或递归阶段，如下所示：</target>
        </trans-unit>
        <trans-unit id="3d7bbafed59a27c1513d780d5e784c2a12ef1dc5" translate="yes" xml:space="preserve">
          <source>People frequently expect it to work like this. So it does.</source>
          <target state="translated">人们经常期望它能这样工作。所以它确实如此。</target>
        </trans-unit>
        <trans-unit id="bc1de57d7a939bd26a67e8c9562637156f53e824" translate="yes" xml:space="preserve">
          <source>People have a hard time remembering that some functions default to $_, or @ARGV, or whatever, but that others which you might expect to do not.</source>
          <target state="translated">人们很难记住,有些函数的默认值是$_,或者@ARGV,或者其他什么,但其他你可能期望的函数却不是。</target>
        </trans-unit>
        <trans-unit id="af3c23d7810d9feb567b332e5161af8d9bd9f452" translate="yes" xml:space="preserve">
          <source>People like to see their strings nicely sorted--or as Unicode parlance goes, collated. But again, what do you mean by collate?</source>
          <target state="translated">人们喜欢看到他们的字符串被很好地分类--或者像Unicode的说法一样,被整理。但是,你说的整理是什么意思呢?</target>
        </trans-unit>
        <trans-unit id="895626deb1f05ce05a822ae049fef844846a6710" translate="yes" xml:space="preserve">
          <source>People sometimes point out that &lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt; will do something similar, and ask why &lt;code&gt;Tie::File&lt;/code&gt; module is necessary.</source>
          <target state="translated">人们有时会指出&lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt;将执行类似的操作，并询问为什么需要 &lt;code&gt;Tie::File&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="99dcc00aba3ea5fec8f203b99f7aa0dc52bd345a" translate="yes" xml:space="preserve">
          <source>Per default all untar operations are done with the perl module Archive::Tar; by setting this variable to true the external tar command is used if available; on Unix this is usually preferred because they have a reliable and fast gnutar implementation.</source>
          <target state="translated">默认情况下,所有的 untar 操作都是通过 perl 模块 Archive::Tar 来完成的;通过将这个变量设置为 true,可以使用外部的 tar 命令;在 Unix 上,这通常是首选,因为他们有一个可靠和快速的 gnutar 实现。</target>
        </trans-unit>
        <trans-unit id="c4f661f9e3bbabdfe8977d8e07c04f728f007afa" translate="yes" xml:space="preserve">
          <source>Per-Interpreter Variables</source>
          <target state="translated">每个解释器变量</target>
        </trans-unit>
        <trans-unit id="2559c9f59f217f32b3e891e1ab6877c4f55356cc" translate="yes" xml:space="preserve">
          <source>Per-instance Data</source>
          <target state="translated">每个实例数据</target>
        </trans-unit>
        <trans-unit id="637c16442a8f555cae097e71247c5fc7ee45adfd" translate="yes" xml:space="preserve">
          <source>Per-instance flag bits</source>
          <target state="translated">每个实例的标志位</target>
        </trans-unit>
        <trans-unit id="24a428fdaa34dbb9d25a2ae2897474ba4a8b3383" translate="yes" xml:space="preserve">
          <source>Perceptive Perl hackers may have noticed that a &lt;code&gt;for&lt;/code&gt; loop has a return value, and that this value can be captured by wrapping the loop in a &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; block. The reward for this discovery is this cautionary advice: The return value of a &lt;code&gt;for&lt;/code&gt; loop is unspecified and may change without notice. Do not rely on it.</source>
          <target state="translated">敏锐的Perl黑客可能已经注意到 &lt;code&gt;for&lt;/code&gt; 循环具有返回值，并且可以通过将循环包装在 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 块中来捕获此值。此发现的好处是发出以下警告性建议： &lt;code&gt;for&lt;/code&gt; 循环的返回值未指定，并且可能会更改，恕不另行通知。不要依赖它。</target>
        </trans-unit>
        <trans-unit id="2c46ae69f753cf6246720edd2c4a9cebd27597f5" translate="yes" xml:space="preserve">
          <source>Perform cache scanning ('atstart', 'atexit' or 'never')?</source>
          <target state="translated">执行缓存扫描('atstart'、'atexit'或'never')?</target>
        </trans-unit>
        <trans-unit id="c63fc543a09237e1df38dff5523874d7739bd5c9" translate="yes" xml:space="preserve">
          <source>Perform sorting on one type of platform only.</source>
          <target state="translated">只对一种类型的平台进行排序。</target>
        </trans-unit>
        <trans-unit id="c27007b93a4bc1c8de4cbbfbb0c5571ba69e57a4" translate="yes" xml:space="preserve">
          <source>Perform the equivalent of &lt;code&gt;&lt;a href=&quot;../functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; on the array.</source>
          <target state="translated">在阵列上执行等效的 &lt;code&gt;&lt;a href=&quot;../functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4070651c463f5c50952530e94f62331111d1bf1" translate="yes" xml:space="preserve">
          <source>Perform the equivalent of &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; on the array.</source>
          <target state="translated">在阵列上执行等效的 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64184a2388a7346fec59e49f0f94873466b15963" translate="yes" xml:space="preserve">
          <source>Perform whatever actions the command line args specified. The &lt;code&gt;prove&lt;/code&gt; command line tool consists of the following code:</source>
          <target state="translated">执行命令行args指定的任何操作。的 &lt;code&gt;prove&lt;/code&gt; 命令行工具包括以下代码的：</target>
        </trans-unit>
        <trans-unit id="0cb883fc85b1fd84aaebb7319c682c586a065641" translate="yes" xml:space="preserve">
          <source>Performance considerations</source>
          <target state="translated">性能方面的考虑</target>
        </trans-unit>
        <trans-unit id="8b696788f6758fff45816e3f44d267110dbc7d28" translate="yes" xml:space="preserve">
          <source>Performance issues</source>
          <target state="translated">性能问题</target>
        </trans-unit>
        <trans-unit id="75fbc5c30da07f1356bcf407f1026c09ad8550fb" translate="yes" xml:space="preserve">
          <source>Performance testing</source>
          <target state="translated">性能测试</target>
        </trans-unit>
        <trans-unit id="d9a7e43f70de19f613749fe02de0e154833f44cd" translate="yes" xml:space="preserve">
          <source>Performing Perl pattern matches and substitutions from your C program</source>
          <target state="translated">从你的C程序中执行Perl模式匹配和替换。</target>
        </trans-unit>
        <trans-unit id="b82005b8824a2b9aeaec337d4f6692160e086478" translate="yes" xml:space="preserve">
          <source>Performs a callback to the Perl sub whose name is in the SV. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">对名称在SV中的Perl子执行回调。参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9a6e4b7d6eb6de9cfa7c1c05de09156f5313aec" translate="yes" xml:space="preserve">
          <source>Performs a callback to the specified Perl method. The blessed object must be on the stack. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">对指定的Perl方法执行回调。被祝福的对象必须在堆栈上。参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f3fb532eda4a585d8b90e5f5df9aa47f234c3a5" translate="yes" xml:space="preserve">
          <source>Performs a callback to the specified Perl sub. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">对指定的Perl子执行回调。参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="49600604ba37ec7bb2caf7fae02578e1f3fb4be1" translate="yes" xml:space="preserve">
          <source>Performs a callback to the specified named and package-scoped Perl subroutine with &lt;code&gt;argv&lt;/code&gt; (a NULL-terminated array of strings) as arguments. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;argv&lt;/code&gt; （以NULL终止的字符串数组）作为参数，执行对指定的命名和包作用域的Perl子例程的回调。参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ada148fba94bb82b7e37d39db36e65570e59f9e9" translate="yes" xml:space="preserve">
          <source>Performs an &lt;code&gt;hv_iternext&lt;/code&gt; , &lt;code&gt;hv_iterkey&lt;/code&gt; , and &lt;code&gt;hv_iterval&lt;/code&gt; in one operation.</source>
          <target state="translated">在一个操作中执行 &lt;code&gt;hv_iternext&lt;/code&gt; ， &lt;code&gt;hv_iterkey&lt;/code&gt; 和 &lt;code&gt;hv_iterval&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08fa9ec15a0ad6b718fdf2229eda1c22f6e3ebcd" translate="yes" xml:space="preserve">
          <source>Performs some preprocessing to the string to ensure that it has the correct characteristics of a version. Flags the object if it contains an underscore (which denotes this is an alpha version). The boolean qv denotes that the version should be interpreted as if it had multiple decimals, even if it doesn't.</source>
          <target state="translated">对字符串进行一些预处理,以确保它具有正确的版本特征。如果对象中包含下划线,则标记该对象(表示这是一个alpha版本)。布林qv表示版本应该被解释为有多个小数,即使没有。</target>
        </trans-unit>
        <trans-unit id="8509e18df89af9b03f62a1a48a7b2cabc5f8fb27" translate="yes" xml:space="preserve">
          <source>Performs the default fixup of the arguments part of an &lt;code&gt;entersub&lt;/code&gt; op tree. This consists of applying list context to each of the argument ops. This is the standard treatment used on a call marked with &lt;code&gt;&amp;amp;&lt;/code&gt; , or a method call, or a call through a subroutine reference, or any other call where the callee can't be identified at compile time, or a call where the callee has no prototype.</source>
          <target state="translated">对 &lt;code&gt;entersub&lt;/code&gt; op树的参数部分执行默认修正。这包括将列表上下文应用于每个参数ops。这是在带有 &lt;code&gt;&amp;amp;&lt;/code&gt; 标记的调用，方法调用，通过子例程引用的调用，或在编译时无法识别被调用方的任何其他调用或在没有被调用方的调用上使用的标准处理原型。</target>
        </trans-unit>
        <trans-unit id="f72b3c1a72c8131e9de33c78c73bf05b880137dc" translate="yes" xml:space="preserve">
          <source>Performs the fixup of the arguments part of an &lt;code&gt;entersub&lt;/code&gt; op tree based on a subroutine prototype. This makes various modifications to the argument ops, from applying context up to inserting &lt;code&gt;refgen&lt;/code&gt; ops, and checking the number and syntactic types of arguments, as directed by the prototype. This is the standard treatment used on a subroutine call, not marked with &lt;code&gt;&amp;amp;&lt;/code&gt; , where the callee can be identified at compile time and has a prototype.</source>
          <target state="translated">基于子例程原型执行 &lt;code&gt;entersub&lt;/code&gt; op树的参数部分的修正。这对参数ops进行了各种修改，从应用上下文到插入 &lt;code&gt;refgen&lt;/code&gt; ops，并按照原型的指示检查参数的数量和语法类型。这是子例程调用中使用的标准处理方式，未用 &lt;code&gt;&amp;amp;&lt;/code&gt; 标记，其中可以在编译时识别被调用方并具有原型。</target>
        </trans-unit>
        <trans-unit id="6157a20bbb392600596ac64ab923dad03e358522" translate="yes" xml:space="preserve">
          <source>Performs the fixup of the arguments part of an &lt;code&gt;entersub&lt;/code&gt; op tree either based on a subroutine prototype or using default list-context processing. This is the standard treatment used on a subroutine call, not marked with &lt;code&gt;&amp;amp;&lt;/code&gt; , where the callee can be identified at compile time.</source>
          <target state="translated">基于子例程原型或使用默认的列表上下文处理，执行 &lt;code&gt;entersub&lt;/code&gt; op树的参数部分的修正。这是在子例程调用中使用的标准处理方式，未用 &lt;code&gt;&amp;amp;&lt;/code&gt; 标记，可以在编译时识别被调用方。</target>
        </trans-unit>
        <trans-unit id="710b350b3985543df26a6fea7ac3e9557988bb88" translate="yes" xml:space="preserve">
          <source>Perhaps the most common mistake programmers make is to attempt to optimize their code before a program actually does anything useful - this is a bad idea. There's no point in having an extremely fast program that doesn't work. The first job is to get a program to</source>
          <target state="translated">也许程序员最常犯的错误是在程序实际做任何有用的事情之前,就试图优化他们的代码--这是一个坏主意。有一个极快的程序,但却不能用,这是没有意义的。第一项工作是让一个程序</target>
        </trans-unit>
        <trans-unit id="f111d810e7ca920bda8f128569fc002610c45314" translate="yes" xml:space="preserve">
          <source>Perl</source>
          <target state="translated">Perl</target>
        </trans-unit>
        <trans-unit id="c1f70e71f78a6960e6bfc54f17ed9725d674c2b0" translate="yes" xml:space="preserve">
          <source>Perl 5 Documentation</source>
          <target state="translated">Perl 5 文档</target>
        </trans-unit>
        <trans-unit id="8f5e9c26fdc65b3f883a3cb850a843ffd41fb0f9" translate="yes" xml:space="preserve">
          <source>Perl 5 Porters</source>
          <target state="translated">Perl 5 Porters</target>
        </trans-unit>
        <trans-unit id="142bd9030035d40d81779a4f9a904554905faa01" translate="yes" xml:space="preserve">
          <source>Perl 5 has extension mechanisms, modules and XS, specifically to avoid the need to keep changing the Perl interpreter. You can write modules that export functions, you can give those functions prototypes so they can be called like built-in functions, you can even write XS code to mess with the runtime data structures of the Perl interpreter if you want to implement really complicated things.</source>
          <target state="translated">Perl 5有扩展机制,模块和XS,专门用来避免不断改变Perl解释器。你可以写模块来导出函数,你可以给这些函数提供原型,这样就可以像内置函数一样被调用,如果你想实现真正复杂的东西,你甚至可以写XS代码来搞乱Perl解释器的运行时数据结构。</target>
        </trans-unit>
        <trans-unit id="365a603ab08b813cf9c586a16f80eeba34a1d121" translate="yes" xml:space="preserve">
          <source>Perl 5 is developed by a community, not a corporate entity. Every change contributed to the Perl core is the result of a donation. Typically, these donations are contributions of code or time by individual members of our community. On occasion, these donations come in the form of corporate or organizational sponsorship of a particular individual or project.</source>
          <target state="translated">Perl 5 是由一个社区开发的,而不是一个公司实体。对 Perl 核心的每一个改动都是由捐赠者贡献的。通常情况下,这些捐赠都是由我们社区中的个人成员所贡献的代码或时间。偶尔,这些捐赠也会以企业或组织赞助某个个人或项目的形式出现。</target>
        </trans-unit>
        <trans-unit id="c7abcac9fa9f634d755f347614a5c92a44d2c3e5" translate="yes" xml:space="preserve">
          <source>Perl 5 was successfully compiled and tested on:</source>
          <target state="translated">Perl 5已成功编译,并在下列设备上进行了测试:</target>
        </trans-unit>
        <trans-unit id="c7ebebb63cc5cd6e093751f9acf8676fc8362950" translate="yes" xml:space="preserve">
          <source>Perl 5.10 added three specials, &lt;code&gt;${^MATCH}&lt;/code&gt; , &lt;code&gt;${^PREMATCH}&lt;/code&gt; , and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; to do the same job but without the global performance penalty. Perl 5.10 only sets these variables if you compile or execute the regular expression with the &lt;code&gt;/p&lt;/code&gt; modifier.</source>
          <target state="translated">Perl 5.10添加了三个特殊功能， &lt;code&gt;${^MATCH}&lt;/code&gt; ， &lt;code&gt;${^PREMATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 可以完成相同的工作，但不会影响全局性能。仅当您使用 &lt;code&gt;/p&lt;/code&gt; 修饰符编译或执行正则表达式时，Perl 5.10才会设置这些变量。</target>
        </trans-unit>
        <trans-unit id="ce44e09ff142e65fee17e89d97567bf27f5d29b1" translate="yes" xml:space="preserve">
          <source>Perl 5.10 also introduced named capture groups and named backreferences. To attach a name to a capturing group, you write either &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; or &lt;code&gt;(?'name'...)&lt;/code&gt;. The backreference may then be written as &lt;code&gt;\g{name}&lt;/code&gt; . It is permissible to attach the same name to more than one group, but then only the leftmost one of the eponymous set can be referenced. Outside of the pattern a named capture group is accessible through the &lt;code&gt;%+&lt;/code&gt; hash.</source>
          <target state="translated">Perl 5.10还引入了命名捕获组和命名后向引用。要将名称附加到捕获组，请编写 &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; 或 &lt;code&gt;(?'name'...)&lt;/code&gt; 。然后可以将后向引用写为 &lt;code&gt;\g{name}&lt;/code&gt; 。允许将相同的名称附加到多个组中，但是只能引用同义集合中最左边的一组。在模式之外，可以通过 &lt;code&gt;%+&lt;/code&gt; 哈希访问命名的捕获组。</target>
        </trans-unit>
        <trans-unit id="d78bc07daf7287cd2d82e764c55679c183debb95" translate="yes" xml:space="preserve">
          <source>Perl 5.10 introduced a number of control verbs intended to provide detailed control over the backtracking process, by directly influencing the regexp engine and by providing monitoring techniques. As all the features in this group are experimental and subject to change or removal in a future version of Perl, the interested reader is referred to &lt;a href=&quot;perlre#Special-Backtracking-Control-Verbs&quot;&gt;Special Backtracking Control Verbs in perlre&lt;/a&gt; for a detailed description.</source>
          <target state="translated">Perl 5.10引入了许多控制动词，旨在通过直接影响正则表达式引擎并提供监视技术来提供对回溯过程的详细控制。由于该组中的所有功能都是实验性的，并且在Perl的将来版本中可能会更改或删除，因此有兴趣的读者可以参考&lt;a href=&quot;perlre#Special-Backtracking-Control-Verbs&quot;&gt;perlre&lt;/a&gt;中的&amp;ldquo; 特殊回溯控制动词&amp;rdquo;以获取详细说明。</target>
        </trans-unit>
        <trans-unit id="d8fc66ff20f940e5def5d5b04e16e404fe2d5094" translate="yes" xml:space="preserve">
          <source>Perl 5.12 an newer is not compatible with the IBM fileset perl.libext.</source>
          <target state="translated">Perl 5.12 或更新的版本与 IBM 文件集 perl.libext 不兼容。</target>
        </trans-unit>
        <trans-unit id="ea53addd5f513ae8ff9630b1ab8b434a441c0d82" translate="yes" xml:space="preserve">
          <source>Perl 5.16 introduced a slightly more efficient mechanism that notes separately whether each of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; , and &lt;code&gt;$'&lt;/code&gt; have been seen, and thus may only need to copy part of the string. Perl 5.20 introduced a much more efficient copy-on-write mechanism which eliminates any slowdown.</source>
          <target state="translated">Perl 5.16引入了一种效率更高的机制，该机制可以单独记录 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 和 &lt;code&gt;$'&lt;/code&gt; 中的每一个是否已被看到，因此可能只需要复制部分字符串。Perl 5.20引入了一种效率更高的写时复制机制，该机制消除了任何速度下降问题。</target>
        </trans-unit>
        <trans-unit id="ecdd633a06acc3333c70644f93001a3679676523" translate="yes" xml:space="preserve">
          <source>Perl 5.18 introduced a new class, B::PADLIST, returned by B::CV's &lt;code&gt;PADLIST&lt;/code&gt; method.</source>
          <target state="translated">Perl 5.18引入了一个新类B :: PADLIST，由B :: CV的 &lt;code&gt;PADLIST&lt;/code&gt; 方法返回。</target>
        </trans-unit>
        <trans-unit id="6b567ee259b41361a0ad9018ea4088cb70239efc" translate="yes" xml:space="preserve">
          <source>Perl 5.22 also introduces the experimental &quot;const&quot; attribute as an alternative. (Disable the &quot;experimental::const_attr&quot; warnings if you want to use it.) When applied to an anonymous subroutine, it forces the sub to be called when the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; expression is evaluated. The return value is captured and turned into a constant subroutine:</source>
          <target state="translated">Perl 5.22还引入了实验性的&amp;ldquo; const&amp;rdquo;属性作为替代。（如果要使用它，请禁用&amp;ldquo; experimental :: const_attr&amp;rdquo;警告。）当应用于匿名子例程时，它将在评估 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 表达式时强制调用该子例程。捕获返回值并将其转换为常量子例程：</target>
        </trans-unit>
        <trans-unit id="cf5bb1f9d37da5d5c2d35eb2fe5db684768a1718" translate="yes" xml:space="preserve">
          <source>Perl 5.22 introduced the B::PADNAMELIST and B::PADNAME classes.</source>
          <target state="translated">Perl 5.22引入了B::PADNAMELIST和B::PADNAME类。</target>
        </trans-unit>
        <trans-unit id="2c423e3fdc417abd5c0a870160561ad280c5b05c" translate="yes" xml:space="preserve">
          <source>Perl 5.6 added support for Unicode characters with code points &amp;gt; 255, and Perl 5.8 has full support for Unicode characters in hash keys. Perl internally encodes strings with these characters using utf8, and Storable serializes them as utf8. By default, if an older version of Perl encounters a utf8 value it cannot represent, it will &lt;code&gt;croak()&lt;/code&gt; . To change this behaviour so that Storable deserializes utf8 encoded values as the string of bytes (effectively dropping the</source>
          <target state="translated">Perl 5.6添加了对代码点&amp;gt; 255的Unicode字符的支持，而Perl 5.8对哈希键中的Unicode字符提供了完全支持。Perl使用utf8在内部使用这些字符编码字符串，而Storable将其序列化为utf8。默认情况下，如果旧版本的Perl遇到它无法表示的utf8值，它将 &lt;code&gt;croak()&lt;/code&gt; 。要更改此行为，以便Storable将utf8编码的值反序列化为字节串（有效地删除了</target>
        </trans-unit>
        <trans-unit id="4d666cc8f0c2aafb781a5c3ee7854aa462c22563" translate="yes" xml:space="preserve">
          <source>Perl 5.6 and earlier used a quicksort algorithm to implement sort. That algorithm was not stable, so</source>
          <target state="translated">Perl 5.6 和更早的版本使用 quicksort 算法来实现 sort。这种算法并不稳定,所以</target>
        </trans-unit>
        <trans-unit id="cc23cb198586dd32a543690c051c8df0366d1085" translate="yes" xml:space="preserve">
          <source>Perl 5.6 lets you write binary numbers directly with the &lt;code&gt;0b&lt;/code&gt; notation:</source>
          <target state="translated">Perl 5.6允许您直接使用 &lt;code&gt;0b&lt;/code&gt; 表示法编写二进制数字：</target>
        </trans-unit>
        <trans-unit id="45926b613d53010c55908af141dded6cf0223b03" translate="yes" xml:space="preserve">
          <source>Perl 5.6.0 introduced Unicode support. It's important for porters and XS writers to understand this support and make sure that the code they write does not corrupt Unicode data.</source>
          <target state="translated">Perl 5.6.0 引入了 Unicode 支持。对于移植者和 XS 编写者来说,理解这种支持并确保他们编写的代码不会损坏 Unicode 数据非常重要。</target>
        </trans-unit>
        <trans-unit id="d766774f1389bd4f4ba4c170949b6d3cfbd45c53" translate="yes" xml:space="preserve">
          <source>Perl 5.6.x introduced the ability to optional configure the perl interpreter to use C's &lt;code&gt;long long&lt;/code&gt; type to allow scalars to store 64 bit integers on 32 bit systems. However, due to the way the Perl configuration system generated the C configuration files on non-Windows platforms, and the way Storable generates its header, nothing in the Storable file header reflected whether the perl writing was using 32 or 64 bit integers, despite the fact that Storable was storing some data differently in the file. Hence Storable running on perl with 64 bit integers will read the header from a file written by a 32 bit perl, not realise that the data is actually in a subtly incompatible format, and then go horribly wrong (possibly crashing) if it encountered a stored integer. This is a design failure.</source>
          <target state="translated">Perl 5.6.x引入了对Perl解释器进行可选配置的功能，以使用C的 &lt;code&gt;long long&lt;/code&gt; 类型来允许标量在32位系统上存储64位整数。但是，由于Perl配置系统在非Windows平台上生成C配置文件的方式以及Storable生成其标头的方式，尽管在存储方式中，Perl配置标头中的任何内容都无法反映出Perl编写是使用32位还是64位整数。 Storable在文件中存储某些数据的事实。因此，在具有64位整数的perl上运行的Storable会从由32位perl写入的文件中读取标头，而不是意识到数据实际上是微妙不兼容的格式，然后如果遇到存储错误，则会出现严重错误（可能崩溃）整数。这是设计失败。</target>
        </trans-unit>
        <trans-unit id="85ca30a6ededa148e4bfea0d2618456fe4f02a72" translate="yes" xml:space="preserve">
          <source>Perl 5.8 adds support for restricted hashes, which have keys restricted to a given set, and can have values locked to be read only. By default, when Storable encounters a restricted hash on a perl that doesn't support them, it will deserialize it as a normal hash, silently discarding any placeholder keys and leaving the keys and all values unlocked. To make Storable &lt;code&gt;croak()&lt;/code&gt; instead, set &lt;code&gt;$Storable::downgrade_restricted&lt;/code&gt; to a &lt;code&gt;FALSE&lt;/code&gt; value. To restore the default set it back to some &lt;code&gt;TRUE&lt;/code&gt; value.</source>
          <target state="translated">Perl 5.8增加了对受限散列的支持，散列的键限于给定的集合，并且可以将值锁定为只读。默认情况下，当Storable在不支持它们的perl上遇到受限哈希时，它将以反序列化的形式将其作为普通哈希，静默丢弃任何占位符键，并保留键和所有值的解锁状态。要改用Storable &lt;code&gt;croak()&lt;/code&gt; ，请将 &lt;code&gt;$Storable::downgrade_restricted&lt;/code&gt; 设置为 &lt;code&gt;FALSE&lt;/code&gt; 值。要恢复默认值，请将其设置回一些 &lt;code&gt;TRUE&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="565a4d4fa800ce5182da9b6ba981e8a739829623" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 added support for Unicode on EBCDIC platforms. This support was allowed to lapse in later releases, but was revived in 5.22. Unicode support is somewhat more complex to implement since additional conversions are needed. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt; for more information.</source>
          <target state="translated">Perl 5.8.0在EBCDIC平台上增加了对Unicode的支持。在以后的版本中，该支持不再有效，但在5.22中恢复了。由于需要额外的转换，因此实现Unicode支持稍微复杂一些。有关更多信息，请参见&lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d3bf07733afdb8eccda724369492b44b06d3912" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 and later avoid these problems by &quot;deferring&quot; signals. That is, when the signal is delivered to the process by the system (to the C code that implements Perl) a flag is set, and the handler returns immediately. Then at strategic &quot;safe&quot; points in the Perl interpreter (e.g. when it is about to execute a new opcode) the flags are checked and the Perl level handler from %SIG is executed. The &quot;deferred&quot; scheme allows much more flexibility in the coding of signal handlers as we know the Perl interpreter is in a safe state, and that we are not in a system library function when the handler is called. However the implementation does differ from previous Perls in the following ways:</source>
          <target state="translated">Perl 5.8.0及以后的版本通过 &quot;延迟 &quot;信号来避免这些问题。也就是说,当系统将信号传递给进程时(传递给实现Perl的C代码),会设置一个标志,处理程序会立即返回。然后在Perl解释器中的战略 &quot;安全 &quot;点(例如当它要执行一个新的操作码时)检查标志,并执行%SIG的Perl级处理程序。延迟 &quot;方案允许信号处理程序的编码更加灵活,因为我们知道Perl解释器处于安全状态,而且当处理程序被调用时,我们不在系统库函数中。然而在实现上确实与以前的Perls有以下不同。</target>
        </trans-unit>
        <trans-unit id="e73fd9ce0c7c872add12735883aa527cd3cbf5df" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 or later</source>
          <target state="translated">Perl 5.8.0或更高版本</target>
        </trans-unit>
        <trans-unit id="4e8757ee96021b145f4cb52d1033c040338543b5" translate="yes" xml:space="preserve">
          <source>Perl 6 is a reinvention of Perl, it is a language in the same lineage but not compatible. The two are complementary, not mutually exclusive. Perl 6 is not meant to replace Perl 5, and vice versa. See &lt;a href=&quot;#What-is-Perl-6%3f&quot;&gt;What is Perl 6?&lt;/a&gt; below to find out more.</source>
          <target state="translated">Perl 6是Perl的重新发明，它是同一种谱系中的一种语言，但不兼容。两者是互补的，而不是相互排斥的。Perl 6并不是要取代Perl 5，反之亦然。请参阅&lt;a href=&quot;#What-is-Perl-6%3f&quot;&gt;什么是Perl 6？&lt;/a&gt;在下面找到更多。</target>
        </trans-unit>
        <trans-unit id="70eed57e9021b8ec1bdc60c299cf0007c990e85c" translate="yes" xml:space="preserve">
          <source>Perl 6 was</source>
          <target state="translated">Perl 6是</target>
        </trans-unit>
        <trans-unit id="c935317046cb2fe37bcb5104606c71edb33387e0" translate="yes" xml:space="preserve">
          <source>Perl &lt;b&gt;borrows syntax&lt;/b&gt; and concepts from many languages: awk, sed, C, Bourne Shell, Smalltalk, Lisp and even English. Other languages have borrowed syntax from Perl, particularly its regular expression extensions. So if you have programmed in another language you will see familiar pieces in Perl. They often work the same, but see &lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt; for information about how they differ.</source>
          <target state="translated">Perl 从多种语言中&lt;b&gt;借用了语法&lt;/b&gt;和概念：awk，sed，C，Bourne Shell，Smalltalk，Lisp甚至是英语。其他语言从Perl借用了语法，尤其是其正则表达式扩展。因此，如果您使用其他语言编程，您将在Perl中看到熟悉的部分。它们的工作原理通常相同，但是请参见&lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt;以获取有关它们之间的区别的信息。</target>
        </trans-unit>
        <trans-unit id="a37780bb487077495edf8f34f760c1da9044ebae" translate="yes" xml:space="preserve">
          <source>Perl API not supported by ppport.h</source>
          <target state="translated">ppport.h不支持Perl API。</target>
        </trans-unit>
        <trans-unit id="5b7471df455475e2c7d2175b53792162c97edfe3" translate="yes" xml:space="preserve">
          <source>Perl Authors Upload Server. Contains links to information for module authors.</source>
          <target state="translated">Perl作者上传服务器。包含模块作者信息的链接。</target>
        </trans-unit>
        <trans-unit id="8bf74964bb9b0e9e3d4da81f0703933934a7c358" translate="yes" xml:space="preserve">
          <source>Perl Best Practices</source>
          <target state="translated">Perl最佳实践</target>
        </trans-unit>
        <trans-unit id="2cc43b42e51a4a8837fffe3af550658174edb610" translate="yes" xml:space="preserve">
          <source>Perl Books</source>
          <target state="translated">Perl书籍</target>
        </trans-unit>
        <trans-unit id="a3a9e748e5c4dd7f9dfa7cc95a251e60be896a8f" translate="yes" xml:space="preserve">
          <source>Perl Classes</source>
          <target state="translated">Perl类</target>
        </trans-unit>
        <trans-unit id="e482403a1124e0521d166c90c8a0769c85673b5e" translate="yes" xml:space="preserve">
          <source>Perl Cookbook</source>
          <target state="translated">Perl Cookbook</target>
        </trans-unit>
        <trans-unit id="d4efb54c65e7e3af46d13e87c7581a8dcba624d0" translate="yes" xml:space="preserve">
          <source>Perl DLL</source>
          <target state="translated">Perl DLL</target>
        </trans-unit>
        <trans-unit id="3283f18cd28cbde0549accd86697398505934bb4" translate="yes" xml:space="preserve">
          <source>Perl Editor by EngInSite is a complete integrated development environment (IDE) for creating, testing, and debugging Perl scripts; the tool runs on Windows 9x/NT/2000/XP or later.</source>
          <target state="translated">EngInSite的Perl Editor是一个完整的集成开发环境(IDE),用于创建、测试和调试Perl脚本;该工具可在Windows 9x/NT/2000/XP或更高版本上运行。</target>
        </trans-unit>
        <trans-unit id="7ac9d4c93ef979889b211c88f596e981156f45f4" translate="yes" xml:space="preserve">
          <source>Perl Extensions</source>
          <target state="translated">Perl扩展</target>
        </trans-unit>
        <trans-unit id="f71fad82087d419a133c0dced88c67e1f9877063" translate="yes" xml:space="preserve">
          <source>Perl FAQ</source>
          <target state="translated">Perl FAQ</target>
        </trans-unit>
        <trans-unit id="da7c8c4aaafde8c9b2e5f84c7552444fbb08c636" translate="yes" xml:space="preserve">
          <source>Perl Fails Because Of Unresolved Symbol sockatmark</source>
          <target state="translated">由于未解决的符号 sockatmark,Perl 失败。</target>
        </trans-unit>
        <trans-unit id="7c3d43451e7cda778a3f9c97b52abf3fd44bedb9" translate="yes" xml:space="preserve">
          <source>Perl Functions by Category</source>
          <target state="translated">按类别划分的Perl函数</target>
        </trans-unit>
        <trans-unit id="920e14089fbbc423ee2d5724c1de68632aef3813" translate="yes" xml:space="preserve">
          <source>Perl GNU Info Files on AmigaOS</source>
          <target state="translated">Perl GNU信息文件在AmigaOS上的应用</target>
        </trans-unit>
        <trans-unit id="37de2a8ad505f52fcef06a6993c850291e480520" translate="yes" xml:space="preserve">
          <source>Perl HTML Documentation on AmigaOS</source>
          <target state="translated">AmigaOS上的Perl HTML文档</target>
        </trans-unit>
        <trans-unit id="05eb1caf8706fb276d9b12087337d5c6103138c5" translate="yes" xml:space="preserve">
          <source>Perl LaTeX Documentation on AmigaOS</source>
          <target state="translated">AmigaOS上的Perl LaTeX文档</target>
        </trans-unit>
        <trans-unit id="91a43bc6de8b72c656ec8849bbbaebef043357f9" translate="yes" xml:space="preserve">
          <source>Perl Modules</source>
          <target state="translated">Perl模块</target>
        </trans-unit>
        <trans-unit id="216d171ee4524430a28634ae1013da6c2f558efa" translate="yes" xml:space="preserve">
          <source>Perl Objects And C Structures</source>
          <target state="translated">Perl对象和C结构</target>
        </trans-unit>
        <trans-unit id="a472684894e509305085eced5d45bf35bf21cca5" translate="yes" xml:space="preserve">
          <source>Perl Smokers ( &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build/&lt;/a&gt; and &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build.reports/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build.reports/&lt;/a&gt; ) automatically test Perl source releases on platforms with various configurations.</source>
          <target state="translated">Perl吸烟者（&lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build/&lt;/a&gt;和&lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build.reports/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build.reports/&lt;/a&gt;）自动测试Perl在具有各种配置的平台上发布源代码。</target>
        </trans-unit>
        <trans-unit id="a5b49734e895fa49b2262a8eac32c0a87b309e7f" translate="yes" xml:space="preserve">
          <source>Perl Source Filter</source>
          <target state="translated">Perl源码过滤器</target>
        </trans-unit>
        <trans-unit id="d9385cb28cfa7ddf46c00b8a389aa72f1c3ecd2f" translate="yes" xml:space="preserve">
          <source>Perl Source Filter Utility Module</source>
          <target state="translated">Perl源码过滤工具模块</target>
        </trans-unit>
        <trans-unit id="11827d68497a169d041d5a9b84cc14e0b5402701" translate="yes" xml:space="preserve">
          <source>Perl Threads Are Not X Threads</source>
          <target state="translated">Perl线程不是X线程</target>
        </trans-unit>
        <trans-unit id="0d5f49a6432453dfdae5c9b853d5d2137d7a3d82" translate="yes" xml:space="preserve">
          <source>Perl Traps</source>
          <target state="translated">Perl陷阱</target>
        </trans-unit>
        <trans-unit id="e81612c89b54aaefee5157e85c78728a2455e0ca" translate="yes" xml:space="preserve">
          <source>Perl XS' attempt at a solution to this is the concept of typemaps. At an abstract level, a Perl XS typemap is nothing but a recipe for converting from a certain Perl data structure to a certain C data structure and vice versa. Since there can be C types that are sufficiently similar to one another to warrant converting with the same logic, XS typemaps are represented by a unique identifier, henceforth called an &lt;b&gt;XS type&lt;/b&gt; in this document. You can then tell the XS compiler that multiple C types are to be mapped with the same XS typemap.</source>
          <target state="translated">Perl XS解决此问题的尝试是类型映射的概念。从抽象的角度来看，Perl XS类型图不过是从某种Perl数据结构转换为某种C数据结构，反之亦然的秘诀。由于可能存在彼此非常相似的C类型，因此需要使用相同的逻辑进行转换，因此&lt;b&gt;XS类型图&lt;/b&gt;由唯一的标识符表示，因此在本文档中称为&lt;b&gt;XS类型&lt;/b&gt;。然后，您可以告诉XS编译器将使用同一XS类型图映射多个C类型。</target>
        </trans-unit>
        <trans-unit id="5aedddb9bed4a6f9cc4928e309c3362165c3d8aa" translate="yes" xml:space="preserve">
          <source>Perl actually inserts the following code:</source>
          <target state="translated">Perl实际上插入了以下代码。</target>
        </trans-unit>
        <trans-unit id="0370590002494d49cbee29303986558b8c939d60" translate="yes" xml:space="preserve">
          <source>Perl actually stands for Pathologically Eclectic Rubbish Lister, but don't tell anyone I said that.</source>
          <target state="translated">Perl其实是Pathologically Eclectic Rubbish Lister的缩写,但别告诉别人是我说的。</target>
        </trans-unit>
        <trans-unit id="4ac1014663aa23e842df07d5739089aa502fbf6c" translate="yes" xml:space="preserve">
          <source>Perl adds magic to an SV using the sv_magic function:</source>
          <target state="translated">Perl 使用 sv_magic 函数为 SV 添加魔法。</target>
        </trans-unit>
        <trans-unit id="c3b8bb4554b031723a2e07241fd747dea1d44323" translate="yes" xml:space="preserve">
          <source>Perl after 5.8.7 has support for the &lt;code&gt;CLONE_SKIP&lt;/code&gt; special subroutine. Like &lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; is called once per package; however, it is called just before cloning starts, and in the context of the parent thread. If it returns a true value, then no objects of that class will be cloned; or rather, they will be copied as unblessed, undef values. For example: if in the parent there are two references to a single blessed hash, then in the child there will be two references to a single undefined scalar value instead. This provides a simple mechanism for making a module threadsafe; just add &lt;code&gt;sub CLONE_SKIP { 1 }&lt;/code&gt; at the top of the class, and &lt;code&gt;DESTROY()&lt;/code&gt; will now only be called once per object. Of course, if the child thread needs to make use of the objects, then a more sophisticated approach is needed.</source>
          <target state="translated">5.8.7之后的Perl支持 &lt;code&gt;CLONE_SKIP&lt;/code&gt; 特殊子例程。与 &lt;code&gt;CLONE&lt;/code&gt; 一样， &lt;code&gt;CLONE_SKIP&lt;/code&gt; 每个包被调用一次；但是，它在克隆开始之前以及在父线程的上下文中被调用。如果返回真值，则不会克隆该类的任何对象；或者更确切地说，它们将被复制为un福气，undef值。例如：如果在父级中有两个引用指向一个有福的哈希，那么在子级中将有两个引用指向一个未定义的标量值。这提供了使模块线程安全的简单机制。只需在类顶部添加 &lt;code&gt;sub CLONE_SKIP { 1 }&lt;/code&gt; ，然后添加 &lt;code&gt;DESTROY()&lt;/code&gt; 现在每个对象只会被调用一次。当然，如果子线程需要使用对象，则需要一种更复杂的方法。</target>
        </trans-unit>
        <trans-unit id="c3994bbd1bc4bb2e8469e1a722d815312e8adf0c" translate="yes" xml:space="preserve">
          <source>Perl allows multiple inheritance, which means that a class can inherit from multiple parents. While this is possible, we strongly recommend against it. Generally, you can use &lt;b&gt;roles&lt;/b&gt; to do everything you can do with multiple inheritance, but in a cleaner way.</source>
          <target state="translated">Perl允许多重继承，这意味着一个类可以从多个父类继承。尽管这是可能的，但我们强烈建议您反对。通常，您可以使用&lt;b&gt;角色&lt;/b&gt;来做多继承可以做的所有事情，但是要用一种更简洁的方式。</target>
        </trans-unit>
        <trans-unit id="1876b83bb7cab17e23b16333856308b07e0072a3" translate="yes" xml:space="preserve">
          <source>Perl allows strings to contain a superset of Unicode code points, up to the limit of what is storable in an unsigned integer on your system, but these may not be accepted by other languages/systems. At one time, it was legal in some standards to have code points up to 0x7FFF_FFFF, but not higher. Code points above 0xFFFF_FFFF require larger than a 32 bit word.</source>
          <target state="translated">Perl 允许字符串中包含 Unicode 码点的超集,最多可存储在系统中的无符号整数中,但这些码点可能不被其他语言/系统接受。曾经,在某些标准中,码点最高为0x7FFF_FFFF是合法的,但不是更高。高于0xFFFF_FFFF的代码点需要大于32位的字。</target>
        </trans-unit>
        <trans-unit id="2ac9734d0ed22e02e26ee85745c9780f4e398059" translate="yes" xml:space="preserve">
          <source>Perl already</source>
          <target state="translated">Perl已经</target>
        </trans-unit>
        <trans-unit id="15634b8ec3adda1649ae8821b358664ffd34a247" translate="yes" xml:space="preserve">
          <source>Perl also defines a consistent extension syntax for features not found in standard tools like &lt;b&gt;awk&lt;/b&gt; and &lt;b&gt;lex&lt;/b&gt;. The syntax for most of these is a pair of parentheses with a question mark as the first thing within the parentheses. The character after the question mark indicates the extension.</source>
          <target state="translated">Perl还为&lt;b&gt;awk&lt;/b&gt;和&lt;b&gt;lex&lt;/b&gt;等标准工具中没有的功能定义了一致的扩展语法。其中大多数语法是一对带有问号的括号，括号内是第一个东西。问号后面的字符表示扩展名。</target>
        </trans-unit>
        <trans-unit id="a619d021759a90d753880bfe4b40f68e2b5378ff" translate="yes" xml:space="preserve">
          <source>Perl also guarantees that the ranges &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;a-z&lt;/code&gt; , &lt;code&gt;0-9&lt;/code&gt; , and any subranges of these match what an English-only speaker would expect them to match on any platform. That is, &lt;code&gt;[A-Z]&lt;/code&gt; matches the 26 ASCII uppercase letters; &lt;code&gt;[a-z]&lt;/code&gt; matches the 26 lowercase letters; and &lt;code&gt;[0-9]&lt;/code&gt; matches the 10 digits. Subranges, like &lt;code&gt;[h-k]&lt;/code&gt; , match correspondingly, in this case just the four letters &lt;code&gt;&quot;h&quot;&lt;/code&gt; , &lt;code&gt;&quot;i&quot;&lt;/code&gt; , &lt;code&gt;&quot;j&quot;&lt;/code&gt; , and &lt;code&gt;&quot;k&quot;&lt;/code&gt; . This is the natural behavior on ASCII platforms where the code points (ordinal values) for &lt;code&gt;&quot;h&quot;&lt;/code&gt; through &lt;code&gt;&quot;k&quot;&lt;/code&gt; are consecutive integers (0x68 through 0x6B). But special handling to achieve this may be needed on platforms with a non-ASCII native character set. For example, on EBCDIC platforms, the code point for &lt;code&gt;&quot;h&quot;&lt;/code&gt; is 0x88, &lt;code&gt;&quot;i&quot;&lt;/code&gt; is 0x89, &lt;code&gt;&quot;j&quot;&lt;/code&gt; is 0x91, and &lt;code&gt;&quot;k&quot;&lt;/code&gt; is 0x92. Perl specially treats &lt;code&gt;[h-k]&lt;/code&gt; to exclude the seven code points in the gap: 0x8A through 0x90. This special handling is only invoked when the range is a subrange of one of the ASCII uppercase, lowercase, and digit ranges, AND each end of the range is expressed either as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , or as a named character (&lt;code&gt;\N{...}&lt;/code&gt; , including the &lt;code&gt;\N{U+...&lt;/code&gt; form).</source>
          <target state="translated">Perl还保证范围 &lt;code&gt;A-Z&lt;/code&gt; ， &lt;code&gt;a-z&lt;/code&gt; ， &lt;code&gt;0-9&lt;/code&gt; 以及这些范围的任何子范围都与仅英语使用者在任何平台上期望的范围相匹配。也就是说， &lt;code&gt;[A-Z]&lt;/code&gt; 匹配26个ASCII大写字母； &lt;code&gt;[a-z]&lt;/code&gt; 匹配26个小写字母；和 &lt;code&gt;[0-9]&lt;/code&gt; 相匹配的10位数字。子范围（例如 &lt;code&gt;[h-k]&lt;/code&gt; ）相应地匹配，在这种情况下，仅匹配四个字母 &lt;code&gt;&quot;h&quot;&lt;/code&gt; ， &lt;code&gt;&quot;i&quot;&lt;/code&gt; ， &lt;code&gt;&quot;j&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;k&quot;&lt;/code&gt; 。这是ASCII平台上的自然行为，在该平台上， &lt;code&gt;&quot;h&quot;&lt;/code&gt; 到 &lt;code&gt;&quot;k&quot;&lt;/code&gt; h&amp;rdquo;的代码点（常规值）k&amp;ldquo;是连续的整数（0x68至0x6B）。但是，在具有非ASCII本机字符集的平台上，可能需要特殊处理才能实现此目的。例如，在EBCDIC平台上， &lt;code&gt;&quot;h&quot;&lt;/code&gt; 的代码点是0x88， &lt;code&gt;&quot;i&quot;&lt;/code&gt; 是0x89， &lt;code&gt;&quot;j&quot;&lt;/code&gt; 是0x91， &lt;code&gt;&quot;k&quot;&lt;/code&gt; 是0x92。 Perl特别对待 &lt;code&gt;[h-k]&lt;/code&gt; 以排除间隙中的七个代码点：0x8A到0x90。仅当范围是ASCII大写，小写和数字范围之一的子范围时，才调用此特殊处理，并且范围的每一端都以文字（如 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 或命名字符（ &lt;code&gt;\N{...}&lt;/code&gt; ，包括 &lt;code&gt;\N{U+...&lt;/code&gt; 形式）。</target>
        </trans-unit>
        <trans-unit id="43ed4c36b705c801489a6eaa310a7c1790004938" translate="yes" xml:space="preserve">
          <source>Perl also has environment variables that control how Perl handles data specific to particular natural languages; see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">Perl还具有环境变量，用于控制Perl如何处理特定于自然语言的数据。参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ec1e88310a904c3504c234668eb6f0ebab9fa04" translate="yes" xml:space="preserve">
          <source>Perl also has its own built-in variables whose names don't follow these rules. They have strange names so they don't accidentally collide with one of your normal variables. Strings that match parenthesized parts of a regular expression are saved under names containing only digits after the &lt;code&gt;$&lt;/code&gt; (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). In addition, several special variables that provide windows into the inner working of Perl have names containing punctuation characters and control characters. These are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">Perl还具有自己的内置变量，其名称不遵循这些规则。它们的名称很奇怪，因此不会意外与您的普通变量之一发生冲突。匹配正则表达式括号部分的字符串将保存在 &lt;code&gt;$&lt;/code&gt; 之后仅包含数字的名称下（请参阅&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;和&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;）。另外，一些提供Perl内部工作窗口的特殊变量的名称包含标点符号和控制字符。这些都在&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;中记录。</target>
        </trans-unit>
        <trans-unit id="841c07e6d7a8a9202a2c193293298a117297f325" translate="yes" xml:space="preserve">
          <source>Perl also has single-form extensions that refer to blocks, &lt;code&gt;In_Cyrillic&lt;/code&gt; , meaning &lt;code&gt;Block=Cyrillic&lt;/code&gt; . These have always been written in the new style.</source>
          <target state="translated">Perl还具有引用块的单一形式扩展 &lt;code&gt;In_Cyrillic&lt;/code&gt; ，意味着 &lt;code&gt;Block=Cyrillic&lt;/code&gt; 。这些总是以新样式编写的。</target>
        </trans-unit>
        <trans-unit id="e768cdcaf855f3ac360271eae70fa3fb2f42dd9c" translate="yes" xml:space="preserve">
          <source>Perl also lets you use a dereferenced scalar reference in a method call. That's a mouthful, so let's look at some code:</source>
          <target state="translated">Perl还允许你在方法调用中使用一个去引用的标量。这是一个口水仗,让我们来看一些代码。</target>
        </trans-unit>
        <trans-unit id="bb3ab86dafec3fc1c1204665ff3d23b69370b1f7" translate="yes" xml:space="preserve">
          <source>Perl also lets you use a scalar containing a string as a class name:</source>
          <target state="translated">Perl还允许你使用一个包含字符串的标量作为类名。</target>
        </trans-unit>
        <trans-unit id="371faeea377937a5cb124120c079958efb812b1f" translate="yes" xml:space="preserve">
          <source>Perl also provides some additional extensions and short-cut synonyms for Unicode properties.</source>
          <target state="translated">Perl还提供了一些额外的扩展和Unicode属性的快捷同义词。</target>
        </trans-unit>
        <trans-unit id="bc3b136059aadb780f36682ea1b93270fac2fc5f" translate="yes" xml:space="preserve">
          <source>Perl also uses two special typedefs, I32 and I16, which will always be at least 32-bits and 16-bits long, respectively. (Again, there are U32 and U16, as well.) They will usually be exactly 32 and 16 bits long, but on Crays they will both be 64 bits.</source>
          <target state="translated">Perl还使用了两个特殊的类型定义,I32和I16,它们将永远分别至少是32位和16位的长度,(同样,还有U32和U16)。(同样,还有U32和U16。)它们的长度通常正好是32位和16位,但在Crays上它们都是64位。</target>
        </trans-unit>
        <trans-unit id="d9ec80db167215866b69eb0ca3e0370b7320f73c" translate="yes" xml:space="preserve">
          <source>Perl and its various modules and components, including its test frameworks, may sometimes make use of certain other environment variables. Some of these are specific to a particular platform. Please consult the appropriate module documentation and any documentation for your platform (like &lt;a href=&quot;perlsolaris&quot;&gt;perlsolaris&lt;/a&gt;, &lt;a href=&quot;perllinux&quot;&gt;perllinux&lt;/a&gt;, &lt;a href=&quot;perlmacosx&quot;&gt;perlmacosx&lt;/a&gt;, &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;, etc) for variables peculiar to those specific situations.</source>
          <target state="translated">Perl及其各种模块和组件（包括其测试框架）有时可能会使用某些其他环境变量。其中一些特定于特定平台。请查阅适当的模块说明文件以及适用于您平台的任何说明文件（例如&lt;a href=&quot;perlsolaris&quot;&gt;perlsolaris&lt;/a&gt;，&lt;a href=&quot;perllinux&quot;&gt;perllinux&lt;/a&gt;，&lt;a href=&quot;perlmacosx&quot;&gt;perlmacosx&lt;/a&gt;，&lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;等），以获取特定于这些特定情况的变量。</target>
        </trans-unit>
        <trans-unit id="d1f38ea6665b57c86a485191974a93669f79515b" translate="yes" xml:space="preserve">
          <source>Perl applications</source>
          <target state="translated">Perl应用</target>
        </trans-unit>
        <trans-unit id="502f7e3b25466218701794ac8b146d454581203f" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before forking the child process, but this may not be supported on some platforms (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid duplicate output.</source>
          <target state="translated">Perl尝试在派生子进程之前刷新所有打开的用于输出的文件，但是在某些平台上可能不支持此操作（请参阅&lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;）。为了安全起见，您可能需要设置 &lt;code&gt;$|&lt;/code&gt; （英文的$ AUTOFLUSH）或在任何打开的句柄上调用 &lt;code&gt;IO::Handle&lt;/code&gt; 的 &lt;code&gt;autoflush()&lt;/code&gt; 方法，以避免重复输出。</target>
        </trans-unit>
        <trans-unit id="310c094e234f2eeac0cd6d541a4252ff1573cf15" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before forking the child process, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid duplicate output.</source>
          <target state="translated">Perl尝试在派生子进程之前刷新所有打开的用于输出的文件，但是在某些平台上可能不支持此操作（请参阅&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;）。为了安全起见，您可能需要设置 &lt;code&gt;$|&lt;/code&gt; （英文的$ AUTOFLUSH）或在任何打开的句柄上调用 &lt;code&gt;IO::Handle&lt;/code&gt; 的 &lt;code&gt;autoflush()&lt;/code&gt; 方法，以避免重复输出。</target>
        </trans-unit>
        <trans-unit id="de17dd0dec4269e99ee3620228765bf8385c7342" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before the exec, but this may not be supported on some platforms (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid lost output.</source>
          <target state="translated">Perl尝试在exec之前刷新所有打开的用于输出的文件，但是在某些平台上可能不支持此操作（请参阅&lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;）。为了安全起见，您可能需要设置 &lt;code&gt;$|&lt;/code&gt; （英语中的$ AUTOFLUSH）或在任何打开的句柄上调用 &lt;code&gt;IO::Handle&lt;/code&gt; 的 &lt;code&gt;autoflush()&lt;/code&gt; 方法，以避免输出丢失。</target>
        </trans-unit>
        <trans-unit id="003b4d9ba004fb0af8689ed0414255d30b89d115" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before the exec, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid lost output.</source>
          <target state="translated">Perl尝试在exec之前刷新所有打开的用于输出的文件，但是在某些平台上可能不支持此操作（请参阅&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;）。为了安全起见，您可能需要设置 &lt;code&gt;$|&lt;/code&gt; （英语中的$ AUTOFLUSH）或在任何打开的句柄上调用 &lt;code&gt;IO::Handle&lt;/code&gt; 的 &lt;code&gt;autoflush()&lt;/code&gt; 方法，以避免输出丢失。</target>
        </trans-unit>
        <trans-unit id="7d4f20a9384f8bc5428825b882bff482c1a8070c" translate="yes" xml:space="preserve">
          <source>Perl automatically calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method when processing a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement for a module. Modules and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; are documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;. Understanding the concept of modules and how the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement operates is important to understanding the Exporter.</source>
          <target state="translated">在处理模块的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句时，Perl自动调用 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法。模块和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 记录在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;和&lt;a href=&quot;perlmod&quot;&gt;perlmod中&lt;/a&gt;。理解模块的概念以及 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句的运行方式对于理解Exporter至关重要。</target>
        </trans-unit>
        <trans-unit id="f61b6a6317cfa23498f15dd9d06745532cf81070" translate="yes" xml:space="preserve">
          <source>Perl automatically enables a set of special security checks, called</source>
          <target state="translated">Perl会自动启用一组特殊的安全检查,称为</target>
        </trans-unit>
        <trans-unit id="fbe832a4f97c9466dde588ba9b2da8adad2850de" translate="yes" xml:space="preserve">
          <source>Perl automatically handles most of the common ways a method might be redefined. However, there are a few ways you could change a method in a stash without the cache code noticing, in which case you need to call this method afterwards:</source>
          <target state="translated">Perl 会自动处理大多数可能被重新定义的方法。然而,有几种方法可以在缓存代码没有注意到的情况下更改 stash 中的方法,在这种情况下,你需要在之后调用这个方法。</target>
        </trans-unit>
        <trans-unit id="036d8f87f677f8c5718f1d28012fa559462c3777" translate="yes" xml:space="preserve">
          <source>Perl automatically provides large file support when built under 64-bit Windows.</source>
          <target state="translated">在64位Windows下构建时,Perl自动提供大文件支持。</target>
        </trans-unit>
        <trans-unit id="7a716c995ea81037d2661a333de648b734bf1c68" translate="yes" xml:space="preserve">
          <source>Perl believes that no machine ever has more than one of &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;age&lt;/code&gt; , or &lt;code&gt;quota&lt;/code&gt; implemented, nor more than one of either &lt;code&gt;comment&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; . Some machines do not support &lt;code&gt;expire&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; , or allegedly, &lt;code&gt;passwd&lt;/code&gt; . You may call these methods no matter what machine you're on, but they return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if unimplemented.</source>
          <target state="translated">Perl相信，任何机器都不能实现 &lt;code&gt;change&lt;/code&gt; ， &lt;code&gt;age&lt;/code&gt; 或 &lt;code&gt;quota&lt;/code&gt; 的任何一项，也不能 &lt;code&gt;comment&lt;/code&gt; 或 &lt;code&gt;class&lt;/code&gt; 的任何一项。有些机器不支持 &lt;code&gt;expire&lt;/code&gt; ， &lt;code&gt;gecos&lt;/code&gt; ，或据称， &lt;code&gt;passwd&lt;/code&gt; 文件。无论您在什么计算机上，都可以调用这些方法，但是如果未实现，它们将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d0360d06e2a1778dd48425c09025dbdf8293f8e" translate="yes" xml:space="preserve">
          <source>Perl binary able to run this extension, load XS modules, etc...</source>
          <target state="translated">Perl二进制文件能够运行这个扩展,加载XS模块等...。</target>
        </trans-unit>
        <trans-unit id="cb8da21c98e2920d923d329d6f68942a153a615f" translate="yes" xml:space="preserve">
          <source>Perl binary distributions come with a</source>
          <target state="translated">Perl二进制发行版带有一个</target>
        </trans-unit>
        <trans-unit id="25b8cd5db95b73c8697ce2a24fc9a3c4624497ef" translate="yes" xml:space="preserve">
          <source>Perl binary for tasks that can be done by miniperl.</source>
          <target state="translated">可由miniperl完成的任务的Perl二进制。</target>
        </trans-unit>
        <trans-unit id="b72df5c4242785794c622b22864eb9d8a2e74001" translate="yes" xml:space="preserve">
          <source>Perl builds and runs on a bewildering number of platforms. Virtually all known and current Unix derivatives are supported (perl's native platform), as are other systems like VMS, DOS, OS/2, Windows, QNX, BeOS, OS X, MPE/iX and the Amiga.</source>
          <target state="translated">Perl可以在大量的平台上构建和运行。几乎所有已知的和当前的Unix派生系统(perl的本地平台)都被支持,其他系统如VMS、DOS、OS/2、Windows、QNX、BeOS、OS X、MPE/iX和Amiga也都支持。</target>
        </trans-unit>
        <trans-unit id="96b360f2cb263510b9740f1a358943c2a62edfbc" translate="yes" xml:space="preserve">
          <source>Perl by default comes with the latest supported Unicode version built-in, but the goal is to allow you to change to use any earlier one. In Perls v5.20 and v5.22, however, the earliest usable version is Unicode 5.1. Perl v5.18 is able to handle all earlier versions.</source>
          <target state="translated">Perl默认内置了最新的Unicode支持版本,但我们的目标是允许你改变使用任何早期版本。然而,在 Perls v5.20 和 v5.22 中,最早的可用版本是 Unicode 5.1。Perl v5.18能够处理所有早期的版本。</target>
        </trans-unit>
        <trans-unit id="858924b099068580d5d02f65c2520871f9621191" translate="yes" xml:space="preserve">
          <source>Perl by default is very forgiving. In order to make it more robust it is recommended to start every program with the following lines:</source>
          <target state="translated">Perl默认情况下是非常宽容的。为了使它更加健壮,建议在每个程序开始时都用下面的行。</target>
        </trans-unit>
        <trans-unit id="41943c9223a2849d683a6cec44cbaf36e58b907e" translate="yes" xml:space="preserve">
          <source>Perl can be built so that it by default will try to execute</source>
          <target state="translated">构建Perl时,可以让它默认尝试执行</target>
        </trans-unit>
        <trans-unit id="36ba407dbee2d6e43709ef0153d960c56996ecc9" translate="yes" xml:space="preserve">
          <source>Perl can be compiled on platforms that run any of three commonly used EBCDIC character sets, listed below.</source>
          <target state="translated">Perl可以在运行以下三种常用EBCDIC字符集的平台上编译。</target>
        </trans-unit>
        <trans-unit id="bea19b77ce1281f9b9bf9a47baf0d79604e6dd7a" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either HP's ANSI C compiler or with gcc. The former is recommended, as not only can it compile Perl with no difficulty, but also can take advantage of features listed later that require the use of HP compiler-specific command-line flags.</source>
          <target state="translated">Perl可以用HP的ANSI C编译器或gcc编译。建议使用前者,因为它不仅可以毫无困难地编译Perl,而且还可以利用后面列出的需要使用HP编译器专用命令行标志的特性。</target>
        </trans-unit>
        <trans-unit id="f05f1e5361560b59743e9bd4f32b54cc023f431f" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either IBM's ANSI C compiler or with gcc. The former is recommended, as not only can it compile Perl with no difficulty, but also can take advantage of features listed later that require the use of IBM compiler-specific command-line flags.</source>
          <target state="translated">Perl可以用IBM的ANSI C编译器或gcc编译。建议使用前者,因为它不仅可以毫无困难地编译Perl,而且可以利用后面列出的需要使用IBM编译器专用命令行标志的特性。</target>
        </trans-unit>
        <trans-unit id="19a69f0e2f064ea4c82b3309e77eb45ccd797a4c" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either IBM's ANSI C compiler or with gcc. The former is recommended, as not only it can compile Perl with no difficulty, but also can take advantage of features listed later that require the use of IBM compiler-specific command-line flags.</source>
          <target state="translated">Perl可以用IBM的ANSI C编译器或用gcc编译。建议使用前者,因为它不仅可以毫无困难地编译Perl,而且可以利用后面列出的需要使用IBM编译器专用命令行标志的特性。</target>
        </trans-unit>
        <trans-unit id="751c036d6e62fec07bc2f5f4e73156154792a0fd" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with gcc from MinGW release 3 and later (using gcc 3.4.5 and later). It can be downloaded here:</source>
          <target state="translated">Perl可以用MinGW第3版及以后的gcc编译(使用gcc 3.4.5及以后的版本)。它可以在这里下载。</target>
        </trans-unit>
        <trans-unit id="2e57623077581e01731874e47fb8c2a4b90f970b" translate="yes" xml:space="preserve">
          <source>Perl can be run under the &quot;C&quot; locale by setting the environment variable &lt;code&gt;LC_ALL&lt;/code&gt; to &quot;C&quot;. This method is perhaps a bit more civilized than the &lt;code&gt;PERL_BADLANG&lt;/code&gt; approach, but setting &lt;code&gt;LC_ALL&lt;/code&gt; (or other locale variables) may affect other programs as well, not just Perl. In particular, external programs run from within Perl will see these changes. If you make the new settings permanent (read on), all programs you run see the changes. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; for the full list of relevant environment variables and &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt; for their effects in Perl. Effects in other programs are easily deducible. For example, the variable &lt;code&gt;LC_COLLATE&lt;/code&gt; may well affect your &lt;b&gt;sort&lt;/b&gt; program (or whatever the program that arranges &quot;records&quot; alphabetically in your system is called).</source>
          <target state="translated">通过将环境变量 &lt;code&gt;LC_ALL&lt;/code&gt; 设置为&amp;ldquo; C&amp;rdquo;，可以在&amp;ldquo; C&amp;rdquo;语言环境下运行Perl 。该方法也许比 &lt;code&gt;PERL_BADLANG&lt;/code&gt; 方法更加文明，但是设置 &lt;code&gt;LC_ALL&lt;/code&gt; （或其他语言环境变量）也可能会影响其他程序，而不仅仅是Perl。特别是，从Perl内部运行的外部程序将看到这些更改。如果使新设置永久化（继续），则您运行的所有程序都会看到更改。有关相关环境变量的完整列表，请参见&lt;a href=&quot;#ENVIRONMENT&quot;&gt;环境；&lt;/a&gt;对于Perl，它们的作用请参见&lt;a href=&quot;#USING-LOCALES&quot;&gt;使用局部&lt;/a&gt;。其他程序中的效果很容易推论。例如，变量 &lt;code&gt;LC_COLLATE&lt;/code&gt; 可能会影响您的&lt;b&gt;排序&lt;/b&gt; 程序（或在系统中按字母顺序排列&amp;ldquo;记录&amp;rdquo;的任何程序都将被调用）。</target>
        </trans-unit>
        <trans-unit id="afea4028a165b75f73beb84894121ff0308d01df" translate="yes" xml:space="preserve">
          <source>Perl can be used for almost any coding problem, even ones which require integrating specialist C code for extra speed. As with any tool it can be used well or badly. Perl has many strengths, and a few weaknesses, precisely which areas are good and bad is often a personal choice.</source>
          <target state="translated">Perl几乎可以用于任何编码问题,甚至是那些需要整合专业C代码以获得额外速度的问题。就像任何工具一样,它可以用得好,也可以用得不好。Perl有很多优点,也有一些缺点,具体哪方面好,哪方面不好,往往是个人的选择。</target>
        </trans-unit>
        <trans-unit id="9f84aec4fa7ef06751c778c8e8173ffe00dcd629" translate="yes" xml:space="preserve">
          <source>Perl can compile and run under EBCDIC platforms. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;. This is transparent for the most part, but because the character sets differ, you shouldn't use numeric (decimal, octal, nor hex) constants to refer to characters. You can safely say &lt;code&gt;'A'&lt;/code&gt; , but not &lt;code&gt;0x41&lt;/code&gt; . You can safely say &lt;code&gt;'\n'&lt;/code&gt; , but not &lt;code&gt;\012&lt;/code&gt; . However, you can use macros defined in</source>
          <target state="translated">Perl可以在EBCDIC平台上编译和运行。参见&lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;。这在大多数情况下是透明的，但是由于字符集不同，因此不应使用数字（十进制，八进制或十六进制）常量来引用字符。您可以放心地说 &lt;code&gt;'A'&lt;/code&gt; ，但不能说 &lt;code&gt;0x41&lt;/code&gt; 。您可以放心说 &lt;code&gt;'\n'&lt;/code&gt; ，但不能说 &lt;code&gt;\012&lt;/code&gt; 。但是，您可以使用在中定义的宏</target>
        </trans-unit>
        <trans-unit id="fa07386a80b47ab8df8b6dbe1e6a41311efb8910" translate="yes" xml:space="preserve">
          <source>Perl can internally represent numbers in 3 different ways: as native integers, as native floating point numbers, and as decimal strings. Decimal strings may have an exponential notation part, as in &lt;code&gt;&quot;12.34e-56&quot;&lt;/code&gt; .</source>
          <target state="translated">Perl可以在内部以3种不同的方式表示数字：作为本机整数，作为本机浮点数和作为十进制字符串。小数字符串可以具有指数表示法部分，如 &lt;code&gt;&quot;12.34e-56&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05cb1fb37d34785f635f75844d77033b80fc24ef" translate="yes" xml:space="preserve">
          <source>Perl can process line directives, much like the C preprocessor. Using this, one can control Perl's idea of filenames and line numbers in error or warning messages (especially for strings that are processed with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;). The syntax for this mechanism is almost the same as for most C preprocessors: it matches the regular expression</source>
          <target state="translated">Perl可以像C预处理器一样处理行指令。使用它，可以控制错误或警告消息中的Perl文件名和行号的概念（尤其是对于使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 处理的字符串）。该机制的语法与大多数C预处理器的语法几乎相同：它与正则表达式匹配</target>
        </trans-unit>
        <trans-unit id="87b4bc522cc9bacefe7588c2849722683c7ccc0c" translate="yes" xml:space="preserve">
          <source>Perl can provide access to all non-provisional Unicode character properties, though not all are enabled by default. The omitted ones are the Unihan properties (accessible via the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Unihan&quot;&gt;Unicode::Unihan&lt;/a&gt;) and certain deprecated or Unicode-internal properties. (An installation may choose to recompile Perl's tables to change this. See &lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;Unicode character properties that are NOT accepted by Perl&lt;/a&gt;.)</source>
          <target state="translated">Perl可以提供对所有非临时Unicode字符属性的访问，尽管默认情况下并非全部启用。省略的是Unihan属性（可通过CPAN模块&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Unihan&quot;&gt;Unicode :: Unihan访问&lt;/a&gt;）和某些不推荐使用或Unicode内部的属性。（安装程序可以选择重新编译Perl的表来更改此设置。请参阅&lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;Perl不接受的Unicode字符属性&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="b9d3bae2bf6cbe36ec81823e26589a3e2497f6c1" translate="yes" xml:space="preserve">
          <source>Perl cannot be compiled with threading support ATM.</source>
          <target state="translated">Perl不能用ATM线程支持来编译。</target>
        </trans-unit>
        <trans-unit id="5aa9ff89c6dfca6cc410567a511ce06ca99ab635" translate="yes" xml:space="preserve">
          <source>Perl cannot protect you from all possibilities shown in the examples--there is no substitute for your own vigilance--but, when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, Perl uses the tainting mechanism (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) to mark string results that become locale-dependent, and which may be untrustworthy in consequence. Here is a summary of the tainting behavior of operators and functions that may be affected by the locale:</source>
          <target state="translated">Perl不能保护您免受示例中显示的所有可能性的困扰-不能替代您自己的警惕性-但是，当有效 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 时，Perl使用污染机制（请参阅&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;）来标记依赖于语言环境的字符串结果，其结果可能是不可信的。这是可能受语言环境影响的操作员和函数的污染行为的摘要：</target>
        </trans-unit>
        <trans-unit id="d5f3aa702381872bb34697babcd6d91dd23feeed" translate="yes" xml:space="preserve">
          <source>Perl code is always compiled into an internal format before execution.</source>
          <target state="translated">Perl代码在执行前总是被编译成内部格式。</target>
        </trans-unit>
        <trans-unit id="c5cce9b9678a00b1fe024a9af1e795642a5bcb9c" translate="yes" xml:space="preserve">
          <source>Perl comes with a wide selection of builtin functions. Some of the ones we've already seen include &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;. A list of them is given at the start of &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and you can easily read about any given function by using &lt;code&gt;perldoc -f &lt;i&gt;functionname&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="translated">Perl带有多种内置函数。我们已经看到的一些包括 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; 。在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;的开头给出了它们的列表，您可以使用 &lt;code&gt;perldoc -f &lt;i&gt;functionname&lt;/i&gt;&lt;/code&gt; 轻松了解任何给定的&lt;i&gt;函数&lt;/i&gt;。</target>
        </trans-unit>
        <trans-unit id="d575f0416db18e1fc564b29cf8cc390222ecf415" translate="yes" xml:space="preserve">
          <source>Perl comes with an interactive debugger, which you can start with the &lt;code&gt;-d&lt;/code&gt; switch. It's fully explained in &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;.</source>
          <target state="translated">Perl带有交互式调试器，您可以从 &lt;code&gt;-d&lt;/code&gt; 开关开始。在&lt;a href=&quot;perldebug&quot;&gt;perldebug中有&lt;/a&gt;充分的解释。</target>
        </trans-unit>
        <trans-unit id="641c8779114365eacf0b514d71b892f3c88f6444" translate="yes" xml:space="preserve">
          <source>Perl compiler backend to produce perl code</source>
          <target state="translated">Perl编译器后台生成perl代码</target>
        </trans-unit>
        <trans-unit id="a425209baf3b199ee00ab768f1943ede83ed4ff4" translate="yes" xml:space="preserve">
          <source>Perl contains internal support for reporting its own memory usage, but this is a fairly advanced concept that requires some understanding of how memory allocation works. See &lt;a href=&quot;perldebguts#Debugging-Perl-Memory-Usage&quot;&gt;Debugging Perl Memory Usage in perldebguts&lt;/a&gt; for the details.</source>
          <target state="translated">Perl包含内部支持以报告其自身的内存使用情况，但这是一个相当高级的概念，需要对内存分配的工作方式有所了解。有关详细信息，请参见&lt;a href=&quot;perldebguts#Debugging-Perl-Memory-Usage&quot;&gt;perldebguts&lt;/a&gt;中的调试Perl内存使用情况。</target>
        </trans-unit>
        <trans-unit id="a29ee67698d8ff496114e40d0f60aa708da987ff" translate="yes" xml:space="preserve">
          <source>Perl continues to warn (using the warning category &lt;code&gt;&quot;nonchar&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if an attempt is made to output noncharacters.</source>
          <target state="translated">如果尝试输出非字符，Perl将继续发出警告（使用警告类别 &lt;code&gt;&quot;nonchar&quot;&lt;/code&gt; ，这是 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 的子类别）。</target>
        </trans-unit>
        <trans-unit id="baa05b026a869001e1e5be6e67df2e5d03445c53" translate="yes" xml:space="preserve">
          <source>Perl currently only supports single-byte locales for &lt;code&gt;LC_COLLATE&lt;/code&gt; . This means that a UTF-8 locale likely will just give you machine-native ordering. Use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; for the full implementation of the Unicode Collation Algorithm.</source>
          <target state="translated">Perl当前仅支持 &lt;code&gt;LC_COLLATE&lt;/code&gt; 的单字节语言环境。这意味着UTF-8语言环境可能只会给您本机排序。将&lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;用于Unicode归类算法的完整实现。</target>
        </trans-unit>
        <trans-unit id="77cf5a91724851c2026eb0ed52027faf2ff9d8f3" translate="yes" xml:space="preserve">
          <source>Perl debug information is frequently required not just by debuggers, but also by modules that need some &quot;special&quot; information to do their job properly, like profilers.</source>
          <target state="translated">Perl调试信息不仅是调试器经常需要的,也是那些需要一些 &quot;特殊 &quot;信息才能正常工作的模块所需要的,比如剖析器。</target>
        </trans-unit>
        <trans-unit id="edcd0b1168988fe6213df824f5ad91c7a66c6c43" translate="yes" xml:space="preserve">
          <source>Perl defines the following zero-width assertions:</source>
          <target state="translated">Perl定义了以下零宽度断言。</target>
        </trans-unit>
        <trans-unit id="6b26390b798af49773d52f4620dbbc3aff54133e" translate="yes" xml:space="preserve">
          <source>Perl deliberately randomizes hash order for security purposes on both ASCII and EBCDIC platforms.</source>
          <target state="translated">Perl为了ASCII和EBCDIC平台的安全,特意随机化了哈希顺序。</target>
        </trans-unit>
        <trans-unit id="b360e4dc6087d3b16edb381fbc0c1f20ea026de5" translate="yes" xml:space="preserve">
          <source>Perl derives from the ubiquitous C programming language and to a lesser extent from sed, awk, the Unix shell, and many other tools and languages.</source>
          <target state="translated">Perl源于无处不在的C编程语言,其次是sed、awk、Unix shell以及许多其他工具和语言。</target>
        </trans-unit>
        <trans-unit id="82ed6e041cbd4aae6a032a9f05ea11dde0c68044" translate="yes" xml:space="preserve">
          <source>Perl does its own &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; formatting: it emulates the C function sprintf(3), but doesn't use it except for floating-point numbers, and even then only standard modifiers are allowed. Non-standard extensions in your local sprintf(3) are therefore unavailable from Perl.</source>
          <target state="translated">Perl进行自己的 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 格式化：它模拟C函数sprintf（3），但除浮点数外不使用它，即使如此，也只允许使用标准修饰符。因此，Perl无法使用本地sprintf（3）中的非标准扩展名。</target>
        </trans-unit>
        <trans-unit id="9fd3bbafbe5f224f645e29f633eba572a0b47a6b" translate="yes" xml:space="preserve">
          <source>Perl does its own &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; formatting: it emulates the C function sprintf(3), but doesn't use it except for floating-point numbers, and even then only standard modifiers are allowed. Non-standard extensions in your local sprintf(3) are therefore unavailable from Perl.</source>
          <target state="translated">Perl进行自己的 &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 格式化：它模拟C函数sprintf（3），但除浮点数外不使用它，即使如此，也只允许使用标准修饰符。因此，Perl无法使用本地sprintf（3）中的非标准扩展名。</target>
        </trans-unit>
        <trans-unit id="a4d0575e168bcb93baf91092d083b3f45edc7784" translate="yes" xml:space="preserve">
          <source>Perl does not allow overloading of ranges, so you can neither safely use ranges with bigint endpoints, nor is the iterator variable a bigint.</source>
          <target state="translated">Perl不允许重载范围,所以你既不能安全地使用带有bigint端点的范围,迭代器变量也不是bigint。</target>
        </trans-unit>
        <trans-unit id="c115815d6de8f54c97b95bbf1feacf608d2cdd8a" translate="yes" xml:space="preserve">
          <source>Perl does not call the shell to expand wild cards when you pass &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; explicit parameter lists instead of strings with possible shell wildcards in them. Unfortunately, the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, and backtick functions provide no such alternate calling convention, so more subterfuge will be required.</source>
          <target state="translated">当您传递 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 显式参数列表，而不是其中包含可能的外壳通配符的字符串时，Perl不会调用外壳扩展通配符。不幸的是， &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 和backtick函数不提供此类替代调用约定，因此将需要更多的替代方法。</target>
        </trans-unit>
        <trans-unit id="acf14eaf9fdbdb615c0b9a213270f3740bd4a2b7" translate="yes" xml:space="preserve">
          <source>Perl does not care about file systems, but the perl library contains many files with long names, so to install it intact one needs a file system which supports long file names.</source>
          <target state="translated">Perl不在乎文件系统,但是perl库中包含了很多长名的文件,所以要想完整的安装,需要一个支持长文件名的文件系统。</target>
        </trans-unit>
        <trans-unit id="5354348a14ac18fad5dfd9ae6dc9f4e8955fd5e4" translate="yes" xml:space="preserve">
          <source>Perl does not depend on the registry, but it can look up certain default values if you choose to put them there. Perl attempts to read entries from &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; and &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt; . Entries in the former override entries in the latter. One or more of the following entries (of type REG_SZ or REG_EXPAND_SZ) may be set:</source>
          <target state="translated">Perl不依赖于注册表，但是如果您选择将某些默认值放在注册表中，则它可以查找某些默认值。Perl尝试从 &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; 和 &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt; 读取条目。前者中的条目将覆盖后者中的条目。可以设置以下一项或多项（REG_SZ或REG_EXPAND_SZ类型）：</target>
        </trans-unit>
        <trans-unit id="e6697dea8bad1c38bf0eecc9764ad8eaf5ace311" translate="yes" xml:space="preserve">
          <source>Perl does not enforce private and public parts of its modules as you may have been used to in other languages like C++, Ada, or Modula-17. Perl doesn't have an infatuation with enforced privacy. It would prefer that you stayed out of its living room because you weren't invited, not because it has a shotgun.</source>
          <target state="translated">Perl并不像你可能已经习惯了其他语言如C++、Ada或Modula-17那样强制执行其模块的私有和公开部分。Perl并不迷恋强制的隐私。它更希望你远离它的客厅,因为你没有被邀请,而不是因为它有一把猎枪。</target>
        </trans-unit>
        <trans-unit id="7376046122227141976ff6a43223937f5fa71800" translate="yes" xml:space="preserve">
          <source>Perl does not expand &lt;code&gt;~&lt;/code&gt; in filenames, which is good, since some folks use it for their backup files:</source>
          <target state="translated">Perl不会在文件名中扩展 &lt;code&gt;~&lt;/code&gt; ，这很好，因为有些人将它用作备份文件：</target>
        </trans-unit>
        <trans-unit id="5b47de2bb8098559e3bf2dcabce87f213a6eb4f0" translate="yes" xml:space="preserve">
          <source>Perl does not have any built-in way to express roles. In the past, people just bit the bullet and used multiple inheritance. Nowadays, there are several good choices on CPAN for using roles.</source>
          <target state="translated">Perl没有任何内置的方式来表达角色。过去,人们只是咬紧牙关,使用多重继承。现在,在CPAN上有几个使用角色的好选择。</target>
        </trans-unit>
        <trans-unit id="eea568e6b9c913375e5a754c242df8539876547c" translate="yes" xml:space="preserve">
          <source>Perl does not provide any special syntax for class definitions. A package is simply a namespace containing variables and subroutines. The only difference is that in a class, the subroutines may expect a reference to an object or the name of a class as the first argument. This is purely a matter of convention, so a class may contain both methods and subroutines which</source>
          <target state="translated">Perl没有为类定义提供任何特殊的语法。一个包只是一个包含变量和子程序的命名空间。唯一不同的是,在一个类中,子程序可能需要一个对象的引用或一个类的名称作为第一个参数。这纯粹是一个约定俗成的问题,所以一个类可能同时包含方法和子程序,这些方法和子程序是</target>
        </trans-unit>
        <trans-unit id="c5c3b122d3c32f38c2b6df0053286a38a52964b9" translate="yes" xml:space="preserve">
          <source>Perl does not provide any special syntax for defining a method. A method is simply a regular subroutine, and is declared with &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;. What makes a method special is that it expects to receive either an object or a class name as its first argument.</source>
          <target state="translated">Perl没有提供用于定义方法的任何特殊语法。方法只是常规的子例程，并用 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 声明。使方法与众不同的是，它希望接收对象或类名作为其第一个参数。</target>
        </trans-unit>
        <trans-unit id="cedf75e55d51d5b15900a202031f864d4002fc15" translate="yes" xml:space="preserve">
          <source>Perl doesn't match multiple characters in a bracketed character class unless the character that maps to them is explicitly mentioned, and it doesn't match them at all if the character class is inverted, which otherwise could be highly confusing. See &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;Bracketed Character Classes in perlrecharclass&lt;/a&gt;, and &lt;a href=&quot;perlrecharclass#Negation&quot;&gt;Negation in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">除非明确提到映射到它们的字符，否则Perl不会匹配方括号字符类中的多个字符，并且如果字符类颠倒了，Perl根本不匹配它们，否则可能会造成很大的混乱。见&lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;在perlrecharclass括号内的字符类&lt;/a&gt;，并&lt;a href=&quot;perlrecharclass#Negation&quot;&gt;否定在perlrecharclass&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="160ee861b96d9abcad026bc93515a6480468d14a" translate="yes" xml:space="preserve">
          <source>Perl doesn't officially have a no-op operator, but the bare constants &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; are special-cased not to produce a warning in void context, so you can for example safely do</source>
          <target state="translated">Perl正式没有no-op运算符，但是裸常量 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 是特殊情况，不会在void上下文中产生警告，因此可以安全地进行操作</target>
        </trans-unit>
        <trans-unit id="ee11bfd628d5bc290b395480aaa995c735fee62a" translate="yes" xml:space="preserve">
          <source>Perl doesn't understand &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; as numeric literals, but you can have them as strings, and Perl will convert them as needed: &quot;Inf&quot; + 1. (You can, however, import them from the POSIX extension; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX qw(Inf NaN);&lt;/code&gt; and then use them as literals.)</source>
          <target state="translated">Perl不能将 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; 理解为数字文字，但是您可以将它们作为字符串，Perl会根据需要将它们转换：&amp;ldquo; Inf&amp;rdquo; +1。（但是，您可以从POSIX扩展名中导入它们；请 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX qw(Inf NaN);&lt;/code&gt; 然后将它们用作文字。）</target>
        </trans-unit>
        <trans-unit id="f06c7777ec6a9cec60c6bbba96236c8c49e10f30" translate="yes" xml:space="preserve">
          <source>Perl enables DECC$EFS_CASE_PRESERVE and DECC$ARGV_PARSE_STYLE by default. Note that the latter only takes effect when extended parse is set in the process in which Perl is running. When these features are explicitly disabled in the environment or the CRTL does not support them, Perl follows the traditional CRTL behavior of downcasing command-line arguments and returning file specifications in lower case only.</source>
          <target state="translated">Perl 默认启用 DECC$EFS_CASE_PRESERVE 和 DECC$ARGV_PARSE_STYLE。请注意,后者只有在 Perl 运行的进程中设置了扩展解析时才会生效。当环境中明确禁用这些特性或者 CRTL 不支持这些特性时,Perl 会遵循传统的 CRTL 行为,将命令行参数降格,并仅以小写形式返回文件规范。</target>
        </trans-unit>
        <trans-unit id="9a7ffa77beb4b5bfb6e9cd592ffc3d63fefd5d7f" translate="yes" xml:space="preserve">
          <source>Perl environment problems</source>
          <target state="translated">Perl环境问题</target>
        </trans-unit>
        <trans-unit id="efd321f1d642a6164aeb6c6061ba19e8d5553328" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($myarray[$key])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Perl等效项： &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($myarray[$key])&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1023174861c373cd70c764cd28a1ffe52c362de1" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @array;&lt;/code&gt; .</source>
          <target state="translated">相当于Perl： &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @array;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1efb4e8b7d1884210a677a24eedc3aaa4097d90" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @new_array = ($scalar1, $scalar2, $scalar3...);&lt;/code&gt;</source>
          <target state="translated">相当于Perl： &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @new_array = ($scalar1, $scalar2, $scalar3...);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="994d82ebaabf45f0326fee88481665e6c0ceb2c7" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop(@myarray);&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">相当于Perl： &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop(@myarray);&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c448473e835de05f1fd2f4b0a4490f988bfea19" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; @myarray, $elem;&lt;/code&gt; .</source>
          <target state="translated">相当于Perl： &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; @myarray, $elem;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c7b86a8f8deba930918279e3c4fc84bda790f23" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@myarray);&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Perl等效： &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@myarray);&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4b1f7bdfb013ea4679d96a3812b271f5a3c227d" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; @myarray, ( (&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;) x $n );&lt;/code&gt;</source>
          <target state="translated">等价于Perl： &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; @myarray, ( (&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;) x $n );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="066d54dd7f117a044b123bb5ad4d4d8cf43e8b71" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;@myarray = ();&lt;/code&gt; .</source>
          <target state="translated">Perl等效： &lt;code&gt;@myarray = ();&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cef9ffe6af51e7c258630229039bfd2bf1b03f4a" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;@{&quot;$name&quot;}&lt;/code&gt; .</source>
          <target state="translated">Perl等效项： &lt;code&gt;@{&quot;$name&quot;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8aec2fb1965c42df65abc2f4f5003e7dd1e44262" translate="yes" xml:space="preserve">
          <source>Perl extension for BSD glob routine</source>
          <target state="translated">BSD glob例程的Perl扩展</target>
        </trans-unit>
        <trans-unit id="24aff9b9093549c7d05ba26875dcbd18c62f3127" translate="yes" xml:space="preserve">
          <source>Perl extension for SHA-1/224/256/384/512</source>
          <target state="translated">SHA-1/224/256/384/512的Perl扩展。</target>
        </trans-unit>
        <trans-unit id="403524ab53fcfa65297b5c6d11da8a41e9bdf68e" translate="yes" xml:space="preserve">
          <source>Perl extension for Version Objects</source>
          <target state="translated">版本对象的Perl扩展</target>
        </trans-unit>
        <trans-unit id="c24a560ca7260d4a2d7424b6161a53890073335c" translate="yes" xml:space="preserve">
          <source>Perl extension for sharing data structures between threads</source>
          <target state="translated">线程间共享数据结构的Perl扩展</target>
        </trans-unit>
        <trans-unit id="3668aadc429b1304c6228d98dc9c4677872a86f1" translate="yes" xml:space="preserve">
          <source>Perl extension to manipulate DCL symbols</source>
          <target state="translated">用于操作DCL符号的Perl扩展</target>
        </trans-unit>
        <trans-unit id="b4ef3d43e200cfbf35d2a7b6f42754d585642e16" translate="yes" xml:space="preserve">
          <source>Perl extensions are packages which provide both XS and Perl code to add new functionality to perl. (XS is a meta-language which simplifies writing C code which interacts with Perl, see &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for more details.) The Perl code for an extension is treated like any other library module - it's made available in your script through the appropriate &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement, and usually defines a Perl package containing the extension.</source>
          <target state="translated">Perl扩展是提供XS和Perl代码以向perl添加新功能的软件包。（XS是一种元语言，它简化了与Perl交互的C代码的编写，有关更多详细信息，请参见&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;。）扩展的Perl代码被视为与其他任何库模块一样-通过适当的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 可以在脚本中使用它。语句，通常定义一个包含扩展名的Perl软件包。</target>
        </trans-unit>
        <trans-unit id="f81d1af8c2de641461c82be3969f85e5ad3bba8c" translate="yes" xml:space="preserve">
          <source>Perl flavors</source>
          <target state="translated">Perl的味道</target>
        </trans-unit>
        <trans-unit id="7d53205939368bef651c20e6009f95c9046101c6" translate="yes" xml:space="preserve">
          <source>Perl for VMS supports redirection of input and output on the command line, using a subset of Bourne shell syntax:</source>
          <target state="translated">Perl for VMS支持在命令行上重定向输入和输出,使用Bourne shell语法的子集。</target>
        </trans-unit>
        <trans-unit id="903e263457faf9b024e447e13142cbcffaf64dc8" translate="yes" xml:space="preserve">
          <source>Perl functions</source>
          <target state="translated">Perl函数</target>
        </trans-unit>
        <trans-unit id="5eab57fb6512949ddd22c0f3a298921f86d2bf10" translate="yes" xml:space="preserve">
          <source>Perl had to change internally to decouple &quot;bytes&quot; from &quot;characters&quot;. It is important that you too change your ideas, if you haven't already, so that &quot;byte&quot; and &quot;character&quot; no longer mean the same thing in your mind.</source>
          <target state="translated">Perl不得不在内部进行改变,将 &quot;字节 &quot;和 &quot;字符 &quot;解耦。重要的是,如果你还没有改变你的想法,你也要改变你的想法,让 &quot;字节 &quot;和 &quot;字符 &quot;在你的脑海中不再是同一个意思。</target>
        </trans-unit>
        <trans-unit id="eb521c7add3b7379a78d9a6b6db7917dc107bbad" translate="yes" xml:space="preserve">
          <source>Perl has a mechanism for intermixing documentation with source code. While it's expecting the beginning of a new statement, if the compiler encounters a line that begins with an equal sign and a word, like this</source>
          <target state="translated">Perl有一种机制,可以将文档和源代码混在一起。当它期待一个新语句的开始时,如果编译器遇到一行以等号和一个词开头的语句,就像这样</target>
        </trans-unit>
        <trans-unit id="1e3d0cb76e6880e13fbb5d4447acbcbd4213008d" translate="yes" xml:space="preserve">
          <source>Perl has a mechanism to help you generate simple reports and charts. To facilitate this, Perl helps you code up your output page close to how it will look when it's printed. It can keep track of things like how many lines are on a page, what page you're on, when to print page headers, etc. Keywords are borrowed from FORTRAN: format() to declare and write() to execute; see their entries in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. Fortunately, the layout is much more legible, more like BASIC's PRINT USING statement. Think of it as a poor man's nroff(1).</source>
          <target state="translated">Perl有一种机制可以帮助您生成简单的报告和图表。为方便起见，Perl帮助您对输出页进行编码，使其接近打印时的外观。它可以跟踪诸如页面上有多少行，您所在的页面，何时打印页面标题等内容。从FORTRAN借用关键字：format（）进行声明，write（）执行；在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;查看他们的条目。幸运的是，布局更加清晰，更像是BASIC的PRINT USING语句。将其视为穷人的nroff（1）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
